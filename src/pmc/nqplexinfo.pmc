/* This implements a container of static lexical information for
 * NQP (will also be used by Rakudo). It differs from Parrot's
 * LexInfo in that it provides support for static lexical values
 * that get set into each created lexpad by default. It will also
 * enable indexed lookups and, some day, may also allow for native
 * values to be stored too. */
pmclass NQPLexInfo provides hash auto_attrs dynpmc group nqp {
    /* Hash mapping a name to the register that always holds its
     * value. */
    ATTR PMC *name_to_register_map;
    
    /* Hash mapping names to static values. This is the authoritative
     * source of these, but we always build a more quickly usable
     * cache in the next two attributes. */
    ATTR PMC *static_values;
    
    /* Integer array of slots that we always want to pre-initialize
     * with static values; built from the static_values hash. */
    ATTR PMC *static_slots_cache;
    
    /* Matching PMC array of the values to pre-init with; built from
    * the static_values hash. */
    ATTR PMC *static_values_cache;
    
    void class_init() {
        INTERP->vtables[entry]->flags |= VTABLE_IS_CONST_PMC_FLAG;
    }

    VTABLE void init() {
        SELF.init_pmc(PMCNULL);
    }

    VTABLE void init_pmc(PMC *sub) {
        /* Set up the lex info storage. */
        PMC *name_to_register_map = pmc_new(interp, enum_class_Hash);
        VTABLE_init_int(interp, name_to_register_map, (INTVAL)enum_type_INTVAL);
        SET_ATTR_name_to_register_map(INTERP, SELF, name_to_register_map);
        
        /* Ensure we're constant. */
        PARROT_ASSERT(PObj_constant_TEST(SELF));

        /* Need custom mark. */
        PObj_custom_mark_SET(SELF);
    }
    
    VTABLE INTVAL get_integer_keyed_str(STRING *key) {
        PMC *name_to_register_map;
        GET_ATTR_name_to_register_map(INTERP, SELF, name_to_register_map);
        return VTABLE_get_integer_keyed_str(interp, name_to_register_map, key);
    }
    
    VTABLE INTVAL exists_keyed_str(STRING *key) {
        PMC *name_to_register_map;
        GET_ATTR_name_to_register_map(INTERP, SELF, name_to_register_map);
        return VTABLE_exists_keyed_str(interp, name_to_register_map, key);
    }
    
    VTABLE void set_integer_keyed_str(STRING *key, INTVAL value) {
        PMC *name_to_register_map;
        GET_ATTR_name_to_register_map(INTERP, SELF, name_to_register_map);
        VTABLE_set_integer_keyed_str(interp, name_to_register_map, key, value);
    }

/*

=item C<void declare_lex_preg(STRING *name, INTVAL preg)>

Declare a lexical variable that is an alias for a PMC register.  The PIR
compiler calls this method in response to a ".lex STRING, PREG" directive.

=cut

*/

    METHOD declare_lex_preg(STRING *name, INTVAL preg) {
        PMC *name_to_register_map;
        GET_ATTR_name_to_register_map(INTERP, SELF, name_to_register_map);
        VTABLE_set_integer_keyed_str(INTERP, name_to_register_map, name, preg);
    }

/*

=item C<PMC *inspect_str(STRING *what)>

Introspects this LexInfo structure. The only valid introspection key is
C<symbols>, which gets an array of the names of the symbols in this lexpad.

=cut

*/

    VTABLE PMC *inspect_str(STRING *what) {
        if (STRING_equal(INTERP, what, CONST_STRING(INTERP, "symbols"))) {
            PMC * const result    = Parrot_pmc_new(INTERP, enum_class_ResizableStringArray);
            PMC *name_to_register_map;
            Hash *hash;
            
            GET_ATTR_name_to_register_map(INTERP, SELF, name_to_register_map);
            hash = (Hash *)VTABLE_get_pointer(interp, name_to_register_map);

            parrot_hash_iterate(hash,
                PARROT_ASSERT(_bucket->key);
                VTABLE_push_string(INTERP, result, (STRING *)_bucket->key););

            return result;
        }
        else
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
                "Unknown introspection value '%S'", what);
    }
}
