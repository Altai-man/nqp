'use strict';

var NQPObject = require('./nqp-object.js');
var StaticCtx = require('./static-ctx.js');

class WrappedCtx {
  constructor(wrap) {
    this.$$outer = wrap;
  }
  codeRef() {
    return {statiCode: null};
  }
};

class CodeRef extends NQPObject {
  constructor(name, cuid) {
    super();
    this.name = name;
    this.cuid = cuid;
    this.staticCode = this;
  }

  captureCtx() {
    this.capture(this.closureTemplate.apply(null, arguments));
    this.outerCtx = arguments[arguments.length - 1];
  }

  capture(block) {
    this.$$call = block;
    return this;
  }

  setOuter(outerCtx) {
    this.outerCtx = outerCtx;
    return this;
  }

  // HACK - do this properly
  $$call() {
    //console.log("doing a hack with closure template", this.closureTemplate);
    let staticCode = this.staticCode;
    if (staticCode.closureTemplate) {
      var searched = staticCode;
      var forcedOuterCtx = null;
      while (searched) {
        if (searched.forcedOuterCtx) {
          forcedOuterCtx = searched.forcedOuterCtx;
          break;
        }
        searched = searched.outerCodeRef;
      }

      var i = staticCode.closureTemplate.length - 1;

      var codeRefForCtx = staticCode.outerCodeRef;
      var fakeCtxs = [];

      fakeCtxs.unshift(forcedOuterCtx ? new WrappedCtx(forcedOuterCtx) : new StaticCtx());


      if (codeRefForCtx && codeRefForCtx.staticVars) {
        for (var staticVarName in codeRefForCtx.staticVars) {
          fakeCtxs[0][staticVarName] = codeRefForCtx.staticVars[staticVarName];
        }
      }

      while (i-- > 0) {
        codeRefForCtx = codeRefForCtx.outerCodeRef;
        fakeCtxs.unshift(new StaticCtx());

        if (codeRefForCtx && codeRefForCtx.staticVars) {
          for (var staticVarName in codeRefForCtx.staticVars) {
            fakeCtxs[0][staticVarName] = codeRefForCtx.staticVars[staticVarName];
          }
        }
      }


      this.$$call = staticCode.closureTemplate.apply(null, fakeCtxs);
      return staticCode.$$call.apply(staticCode, arguments);
    } else {
      console.log("can't autoclose - BAD");
    }
  }

  $$apply(argsArray) {
    return this.$$call.apply(this, argsArray);
  }

  closure(block) {
    var closure = new CodeRef(this.name, this.cuid);
    closure.codeObj = this.codeObj;
    closure.$$call = block;
    closure.staticCode = this;
    // HACK - needed for code generated by rakudo.js to load the setting
    closure.forcedOuterCtx = this.forcedOuterCtx;
    return closure;
  }

  closureCtx() {
    var closure = new CodeRef(this.name, this.cuid);
    closure.codeObj = this.codeObj;
    closure.$$call = this.closureTemplate.apply(null, arguments);
    closure.staticCode = this;

    closure.outerCtx = arguments[arguments.length - 1];

    // HACK - needed for code generated by rakudo.js to load the setting
    closure.forcedOuterCtx = this.forcedOuterCtx;
    return closure;
  }

  captureAndClosure(outer, block) {
    this.capture(block);
    var closure = this.closure(block);
    if (outer !== null) {
      this.outerCtx = outer;
      closure.outerCtx = outer;
    }
    return closure;
  }

  captureAndClosureCtx() {
    let block = this.closureTemplate.apply(null, arguments);
    let outer = arguments[arguments.length - 1];
    this.capture(block);
    var closure = this.closure(block);

    /* TODO - think if we should set this */
    if (outer !== null) {
      this.outerCtx = outer;
      closure.outerCtx = outer;
    }
    return closure;
  }

  CPS(block) {
    this.$$callCPS = block;
    return this;
  }

  sameCPS(block) {
    this.$$callCPS = function() {
      var args = Array.prototype.slice.call(arguments);
      var cont = args.splice(2, 1)[0];
      return cont(this.$$call.apply(this, args));
    };
    return this;
  }

  onlyCPS(block) {
    this.$$call = function() {
      throw 'this block can be only called in CPS mode';
    };
    return this;
  }

  setCodeObj(codeObj) {
    this.codeObj = codeObj;
    return this;
  }

  setInfo(outerCodeRef, closureTemplate, lexicalsTypeInfo) {
    this.closureTemplate = closureTemplate;
    this.outerCodeRef = outerCodeRef;
    this.lexicalsTypeInfo = lexicalsTypeInfo;
    return this;
  }

  setStaticVars(staticVars) {
    this.staticVars = staticVars;
  }

  $$clone() {
    var clone = new CodeRef(this.name, undefined);
    clone.$$call = this.$$call;
    clone.codeObj = this.codeObj;
    clone.staticCode = this.staticCode;
    clone.outerCtx = this.outerCtx;
    return clone;
  }

  $$toBool(ctx) {
    return 1;
  }

  $$can(ctx, name) {
    return 0;
  }
};

module.exports = CodeRef;
