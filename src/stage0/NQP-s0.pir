
.HLL "nqp"

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1302110486.758")
    .param pmc param_13 :slurpy
.annotate 'line', 0
    get_hll_global $P5840, ["NQP";"Compiler"], "_block5839" 
    capture_lex $P5840
    get_hll_global $P5720, ["NQP";"RegexActions"], "_block5719" 
    capture_lex $P5720
    get_hll_global $P2502, ["NQP";"Actions"], "_block2501" 
    capture_lex $P2502
    get_hll_global $P2399, ["NQP";"Regex"], "_block2398" 
    capture_lex $P2399
    get_hll_global $P34, ["NQP";"Grammar"], "_block33" 
    capture_lex $P34
    .const 'Sub' $P14 = "11_1302110486.758" 
    capture_lex $P14
.annotate 'line', 1
    .lex "@ARGS", param_13
.annotate 'line', 2134
    .const 'Sub' $P14 = "11_1302110486.758" 
    newclosure $P32, $P14
    .lex "MAIN", $P32
.annotate 'line', 1
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
.annotate 'line', 9
    get_hll_global $P34, ["NQP";"Grammar"], "_block33" 
    capture_lex $P34
    $P34()
.annotate 'line', 698
    get_hll_global $P2399, ["NQP";"Regex"], "_block2398" 
    capture_lex $P2399
    $P2399()
.annotate 'line', 741
    get_hll_global $P2502, ["NQP";"Actions"], "_block2501" 
    capture_lex $P2502
    $P2502()
.annotate 'line', 2076
    get_hll_global $P5720, ["NQP";"RegexActions"], "_block5719" 
    capture_lex $P5720
    $P5720()
.annotate 'line', 2131
    get_hll_global $P5840, ["NQP";"Compiler"], "_block5839" 
    capture_lex $P5840
    $P5840()
    find_lex $P5849, "MAIN"
    find_lex $P5852, "@ARGS"
    if $P5852, if_5851
    set $P5850, $P5852
    goto if_5851_end
  if_5851:
    .const 'Sub' $P5853 = "11_1302110486.758" 
    find_lex $P5854, "@ARGS"
    $P5855 = $P5853($P5854 :flat)
    set $P5850, $P5855
  if_5851_end:
.annotate 'line', 1
    .return ($P5850)
    .const 'Sub' $P5857 = "569_1302110486.758" 
    .return ($P5857)
.end


.HLL "nqp"

.namespace []
.sub "" :load :init :subid("post570") :outer("10_1302110486.758")
.annotate 'line', 0
    .const 'Sub' $P12 = "10_1302110486.758" 
    .local pmc block
    set block, $P12
    nqp_get_sc $P5861, "1302110474.135"
    isnull $I5862, $P5861
    if $I5862, if_5860
    nqp_get_sc_object $P5909, "1302110474.135", 0
    set_hll_global ["NQP"], "Grammar", $P5909
    .const 'Sub' $P5910 = "12_1302110486.758" 
    $P5911 = $P5910."get_lexinfo"()
    nqp_get_sc_object $P5912, "1302110474.135", 0
    $P5911."set_static_lexpad_value"("$?CLASS", $P5912)
    .const 'Sub' $P5913 = "12_1302110486.758" 
    $P5914 = $P5913."get_lexinfo"()
    $P5914."finish_static_lexpad"()
    nqp_get_sc_object $P5915, "1302110474.135", 1
    set_hll_global ["NQP"], "Regex", $P5915
    .const 'Sub' $P5916 = "383_1302110486.758" 
    $P5917 = $P5916."get_lexinfo"()
    nqp_get_sc_object $P5918, "1302110474.135", 1
    $P5917."set_static_lexpad_value"("$?CLASS", $P5918)
    .const 'Sub' $P5919 = "383_1302110486.758" 
    $P5920 = $P5919."get_lexinfo"()
    $P5920."finish_static_lexpad"()
    nqp_get_sc_object $P5921, "1302110474.135", 2
    set_hll_global ["NQP"], "Actions", $P5921
    .const 'Sub' $P5922 = "405_1302110486.758" 
    $P5923 = $P5922."get_lexinfo"()
    nqp_get_sc_object $P5924, "1302110474.135", 2
    $P5923."set_static_lexpad_value"("$?CLASS", $P5924)
    .const 'Sub' $P5925 = "405_1302110486.758" 
    $P5926 = $P5925."get_lexinfo"()
    $P5926."finish_static_lexpad"()
    nqp_get_sc_object $P5927, "1302110474.135", 3
    set_hll_global ["NQP"], "RegexActions", $P5927
    .const 'Sub' $P5928 = "558_1302110486.758" 
    $P5929 = $P5928."get_lexinfo"()
    nqp_get_sc_object $P5930, "1302110474.135", 3
    $P5929."set_static_lexpad_value"("$?CLASS", $P5930)
    .const 'Sub' $P5931 = "558_1302110486.758" 
    $P5932 = $P5931."get_lexinfo"()
    $P5932."finish_static_lexpad"()
    nqp_get_sc_object $P5933, "1302110474.135", 4
    set_hll_global ["NQP"], "Compiler", $P5933
    .const 'Sub' $P5934 = "567_1302110486.758" 
    $P5935 = $P5934."get_lexinfo"()
    nqp_get_sc_object $P5936, "1302110474.135", 4
    $P5935."set_static_lexpad_value"("$?CLASS", $P5936)
    .const 'Sub' $P5937 = "567_1302110486.758" 
    $P5938 = $P5937."get_lexinfo"()
    $P5938."finish_static_lexpad"()
    goto if_5860_end
  if_5860:
    nqp_dynop_setup 
    getinterp $P5863
    get_class $P5864, "LexPad"
    get_class $P5865, "NQPLexPad"
    $P5863."hll_map"($P5864, $P5865)
    load_bytecode "nqpmo.pbc"
    nqp_create_sc $P5866, "1302110474.135"
    .local pmc cur_sc
    set cur_sc, $P5866
    load_bytecode "SettingManager.pbc"
    get_hll_global $P5867, ["HLL"], "SettingManager"
    $P5868 = $P5867."load_setting"("NQPCORE")
    block."set_outer_ctx"($P5868)
    load_bytecode "P6Regex.pbc"
    get_hll_global $P5869, "NQPClassHOW"
    $P5870 = $P5869."new_type"("NQP::Grammar" :named("name"))
    nqp_set_sc_for_object $P5870, cur_sc
    nqp_set_sc_object "1302110474.135", 0, $P5870
    nqp_get_sc_object $P5871, "1302110474.135", 0
    set_hll_global ["NQP"], "Grammar", $P5871
    .const 'Sub' $P5872 = "12_1302110486.758" 
    $P5873 = $P5872."get_lexinfo"()
    nqp_get_sc_object $P5874, "1302110474.135", 0
    $P5873."set_static_lexpad_value"("$?CLASS", $P5874)
    .const 'Sub' $P5875 = "12_1302110486.758" 
    $P5876 = $P5875."get_lexinfo"()
    $P5876."finish_static_lexpad"()
    get_hll_global $P5877, "NQPClassHOW"
    $P5878 = $P5877."new_type"("NQP::Regex" :named("name"))
    nqp_set_sc_for_object $P5878, cur_sc
    nqp_set_sc_object "1302110474.135", 1, $P5878
    nqp_get_sc_object $P5879, "1302110474.135", 1
    set_hll_global ["NQP"], "Regex", $P5879
    .const 'Sub' $P5880 = "383_1302110486.758" 
    $P5881 = $P5880."get_lexinfo"()
    nqp_get_sc_object $P5882, "1302110474.135", 1
    $P5881."set_static_lexpad_value"("$?CLASS", $P5882)
    .const 'Sub' $P5883 = "383_1302110486.758" 
    $P5884 = $P5883."get_lexinfo"()
    $P5884."finish_static_lexpad"()
    get_hll_global $P5885, "NQPClassHOW"
    $P5886 = $P5885."new_type"("NQP::Actions" :named("name"))
    nqp_set_sc_for_object $P5886, cur_sc
    nqp_set_sc_object "1302110474.135", 2, $P5886
    nqp_get_sc_object $P5887, "1302110474.135", 2
    set_hll_global ["NQP"], "Actions", $P5887
    .const 'Sub' $P5888 = "405_1302110486.758" 
    $P5889 = $P5888."get_lexinfo"()
    nqp_get_sc_object $P5890, "1302110474.135", 2
    $P5889."set_static_lexpad_value"("$?CLASS", $P5890)
    .const 'Sub' $P5891 = "405_1302110486.758" 
    $P5892 = $P5891."get_lexinfo"()
    $P5892."finish_static_lexpad"()
    get_hll_global $P5893, "NQPClassHOW"
    $P5894 = $P5893."new_type"("NQP::RegexActions" :named("name"))
    nqp_set_sc_for_object $P5894, cur_sc
    nqp_set_sc_object "1302110474.135", 3, $P5894
    nqp_get_sc_object $P5895, "1302110474.135", 3
    set_hll_global ["NQP"], "RegexActions", $P5895
    .const 'Sub' $P5896 = "558_1302110486.758" 
    $P5897 = $P5896."get_lexinfo"()
    nqp_get_sc_object $P5898, "1302110474.135", 3
    $P5897."set_static_lexpad_value"("$?CLASS", $P5898)
    .const 'Sub' $P5899 = "558_1302110486.758" 
    $P5900 = $P5899."get_lexinfo"()
    $P5900."finish_static_lexpad"()
    get_hll_global $P5901, "NQPClassHOW"
    $P5902 = $P5901."new_type"("NQP::Compiler" :named("name"))
    nqp_set_sc_for_object $P5902, cur_sc
    nqp_set_sc_object "1302110474.135", 4, $P5902
    nqp_get_sc_object $P5903, "1302110474.135", 4
    set_hll_global ["NQP"], "Compiler", $P5903
    .const 'Sub' $P5904 = "567_1302110486.758" 
    $P5905 = $P5904."get_lexinfo"()
    nqp_get_sc_object $P5906, "1302110474.135", 4
    $P5905."set_static_lexpad_value"("$?CLASS", $P5906)
    .const 'Sub' $P5907 = "567_1302110486.758" 
    $P5908 = $P5907."get_lexinfo"()
    $P5908."finish_static_lexpad"()
  if_5860_end:
.end


.HLL "nqp"

.namespace []
.sub "MAIN"  :subid("11_1302110486.758") :outer("10_1302110486.758")
    .param pmc param_15
.annotate 'line', 2134
    .lex "@ARGS", param_15
.annotate 'line', 2136
    new $P16, "Undef"
    .lex "$nqpcomp", $P16
.annotate 'line', 2142
    $P17 = root_new ['parrot';'ResizablePMCArray']
    .lex "@clo", $P17
.annotate 'line', 2136
    get_hll_global $P18, ["NQP"], "Compiler"
    $P19 = $P18."new"()
    store_lex "$nqpcomp", $P19
.annotate 'line', 2137
    find_lex $P20, "$nqpcomp"
    $P20."language"("nqp")
.annotate 'line', 2138
    find_lex $P21, "$nqpcomp"
    get_hll_global $P22, ["NQP"], "Grammar"
    $P21."parsegrammar"($P22)
.annotate 'line', 2139
    find_lex $P23, "$nqpcomp"
    get_hll_global $P24, ["NQP"], "Actions"
    $P23."parseactions"($P24)
.annotate 'line', 2142
    find_lex $P25, "$nqpcomp"
    $P26 = $P25."commandline_options"()
    store_lex "@clo", $P26
.annotate 'line', 2143
    find_lex $P27, "@clo"
    $P27."push"("parsetrace")
.annotate 'line', 2144
    find_lex $P28, "@clo"
    $P28."push"("setting=s")
.annotate 'line', 2147
    find_lex $P29, "$nqpcomp"
    find_lex $P30, "@ARGS"
    $P31 = $P29."command_line"($P30, "utf8" :named("encoding"), "ascii iso-8859-1" :named("transcode"))
.annotate 'line', 2134
    .return ($P31)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block33"  :subid("12_1302110486.758") :outer("10_1302110486.758")
.annotate 'line', 9
    .const 'Sub' $P1680 = "382_1302110486.758" 
    capture_lex $P1680
    .const 'Sub' $P1667 = "381_1302110486.758" 
    capture_lex $P1667
    .const 'Sub' $P1661 = "379_1302110486.758" 
    capture_lex $P1661
    .const 'Sub' $P1655 = "377_1302110486.758" 
    capture_lex $P1655
    .const 'Sub' $P1649 = "375_1302110486.758" 
    capture_lex $P1649
    .const 'Sub' $P1643 = "373_1302110486.758" 
    capture_lex $P1643
    .const 'Sub' $P1631 = "370_1302110486.758" 
    capture_lex $P1631
    .const 'Sub' $P1624 = "368_1302110486.758" 
    capture_lex $P1624
    .const 'Sub' $P1617 = "366_1302110486.758" 
    capture_lex $P1617
    .const 'Sub' $P1610 = "364_1302110486.758" 
    capture_lex $P1610
    .const 'Sub' $P1603 = "362_1302110486.758" 
    capture_lex $P1603
    .const 'Sub' $P1597 = "360_1302110486.758" 
    capture_lex $P1597
    .const 'Sub' $P1590 = "358_1302110486.758" 
    capture_lex $P1590
    .const 'Sub' $P1583 = "356_1302110486.758" 
    capture_lex $P1583
    .const 'Sub' $P1576 = "354_1302110486.758" 
    capture_lex $P1576
    .const 'Sub' $P1569 = "352_1302110486.758" 
    capture_lex $P1569
    .const 'Sub' $P1562 = "350_1302110486.758" 
    capture_lex $P1562
    .const 'Sub' $P1555 = "348_1302110486.758" 
    capture_lex $P1555
    .const 'Sub' $P1548 = "346_1302110486.758" 
    capture_lex $P1548
    .const 'Sub' $P1541 = "344_1302110486.758" 
    capture_lex $P1541
    .const 'Sub' $P1534 = "342_1302110486.758" 
    capture_lex $P1534
    .const 'Sub' $P1527 = "340_1302110486.758" 
    capture_lex $P1527
    .const 'Sub' $P1520 = "338_1302110486.758" 
    capture_lex $P1520
    .const 'Sub' $P1513 = "336_1302110486.758" 
    capture_lex $P1513
    .const 'Sub' $P1506 = "334_1302110486.758" 
    capture_lex $P1506
    .const 'Sub' $P1499 = "332_1302110486.758" 
    capture_lex $P1499
    .const 'Sub' $P1492 = "330_1302110486.758" 
    capture_lex $P1492
    .const 'Sub' $P1485 = "328_1302110486.758" 
    capture_lex $P1485
    .const 'Sub' $P1478 = "326_1302110486.758" 
    capture_lex $P1478
    .const 'Sub' $P1471 = "324_1302110486.758" 
    capture_lex $P1471
    .const 'Sub' $P1464 = "322_1302110486.758" 
    capture_lex $P1464
    .const 'Sub' $P1457 = "320_1302110486.758" 
    capture_lex $P1457
    .const 'Sub' $P1450 = "318_1302110486.758" 
    capture_lex $P1450
    .const 'Sub' $P1443 = "316_1302110486.758" 
    capture_lex $P1443
    .const 'Sub' $P1436 = "314_1302110486.758" 
    capture_lex $P1436
    .const 'Sub' $P1429 = "312_1302110486.758" 
    capture_lex $P1429
    .const 'Sub' $P1422 = "310_1302110486.758" 
    capture_lex $P1422
    .const 'Sub' $P1415 = "308_1302110486.758" 
    capture_lex $P1415
    .const 'Sub' $P1408 = "306_1302110486.758" 
    capture_lex $P1408
    .const 'Sub' $P1401 = "304_1302110486.758" 
    capture_lex $P1401
    .const 'Sub' $P1394 = "302_1302110486.758" 
    capture_lex $P1394
    .const 'Sub' $P1388 = "300_1302110486.758" 
    capture_lex $P1388
    .const 'Sub' $P1381 = "298_1302110486.758" 
    capture_lex $P1381
    .const 'Sub' $P1374 = "296_1302110486.758" 
    capture_lex $P1374
    .const 'Sub' $P1367 = "294_1302110486.758" 
    capture_lex $P1367
    .const 'Sub' $P1360 = "292_1302110486.758" 
    capture_lex $P1360
    .const 'Sub' $P1353 = "290_1302110486.758" 
    capture_lex $P1353
    .const 'Sub' $P1346 = "288_1302110486.758" 
    capture_lex $P1346
    .const 'Sub' $P1339 = "286_1302110486.758" 
    capture_lex $P1339
    .const 'Sub' $P1333 = "284_1302110486.758" 
    capture_lex $P1333
    .const 'Sub' $P1327 = "282_1302110486.758" 
    capture_lex $P1327
    .const 'Sub' $P1322 = "280_1302110486.758" 
    capture_lex $P1322
    .const 'Sub' $P1316 = "278_1302110486.758" 
    capture_lex $P1316
    .const 'Sub' $P1310 = "276_1302110486.758" 
    capture_lex $P1310
    .const 'Sub' $P1305 = "274_1302110486.758" 
    capture_lex $P1305
    .const 'Sub' $P1300 = "272_1302110486.758" 
    capture_lex $P1300
    .const 'Sub' $P1284 = "271_1302110486.758" 
    capture_lex $P1284
    .const 'Sub' $P1275 = "269_1302110486.758" 
    capture_lex $P1275
    .const 'Sub' $P1266 = "267_1302110486.758" 
    capture_lex $P1266
    .const 'Sub' $P1261 = "265_1302110486.758" 
    capture_lex $P1261
    .const 'Sub' $P1256 = "263_1302110486.758" 
    capture_lex $P1256
    .const 'Sub' $P1251 = "261_1302110486.758" 
    capture_lex $P1251
    .const 'Sub' $P1243 = "259_1302110486.758" 
    capture_lex $P1243
    .const 'Sub' $P1235 = "257_1302110486.758" 
    capture_lex $P1235
    .const 'Sub' $P1230 = "255_1302110486.758" 
    capture_lex $P1230
    .const 'Sub' $P1225 = "253_1302110486.758" 
    capture_lex $P1225
    .const 'Sub' $P1220 = "251_1302110486.758" 
    capture_lex $P1220
    .const 'Sub' $P1214 = "249_1302110486.758" 
    capture_lex $P1214
    .const 'Sub' $P1208 = "247_1302110486.758" 
    capture_lex $P1208
    .const 'Sub' $P1202 = "245_1302110486.758" 
    capture_lex $P1202
    .const 'Sub' $P1196 = "243_1302110486.758" 
    capture_lex $P1196
    .const 'Sub' $P1190 = "241_1302110486.758" 
    capture_lex $P1190
    .const 'Sub' $P1185 = "239_1302110486.758" 
    capture_lex $P1185
    .const 'Sub' $P1180 = "237_1302110486.758" 
    capture_lex $P1180
    .const 'Sub' $P1166 = "233_1302110486.758" 
    capture_lex $P1166
    .const 'Sub' $P1158 = "231_1302110486.758" 
    capture_lex $P1158
    .const 'Sub' $P1152 = "229_1302110486.758" 
    capture_lex $P1152
    .const 'Sub' $P1145 = "227_1302110486.758" 
    capture_lex $P1145
    .const 'Sub' $P1139 = "225_1302110486.758" 
    capture_lex $P1139
    .const 'Sub' $P1125 = "222_1302110486.758" 
    capture_lex $P1125
    .const 'Sub' $P1117 = "220_1302110486.758" 
    capture_lex $P1117
    .const 'Sub' $P1109 = "218_1302110486.758" 
    capture_lex $P1109
    .const 'Sub' $P1103 = "216_1302110486.758" 
    capture_lex $P1103
    .const 'Sub' $P1097 = "214_1302110486.758" 
    capture_lex $P1097
    .const 'Sub' $P1081 = "210_1302110486.758" 
    capture_lex $P1081
    .const 'Sub' $P1040 = "208_1302110486.758" 
    capture_lex $P1040
    .const 'Sub' $P1029 = "206_1302110486.758" 
    capture_lex $P1029
    .const 'Sub' $P1015 = "202_1302110486.758" 
    capture_lex $P1015
    .const 'Sub' $P1006 = "200_1302110486.758" 
    capture_lex $P1006
    .const 'Sub' $P1000 = "198_1302110486.758" 
    capture_lex $P1000
    .const 'Sub' $P990 = "196_1302110486.758" 
    capture_lex $P990
    .const 'Sub' $P975 = "194_1302110486.758" 
    capture_lex $P975
    .const 'Sub' $P961 = "191_1302110486.758" 
    capture_lex $P961
    .const 'Sub' $P953 = "189_1302110486.758" 
    capture_lex $P953
    .const 'Sub' $P943 = "187_1302110486.758" 
    capture_lex $P943
    .const 'Sub' $P933 = "185_1302110486.758" 
    capture_lex $P933
    .const 'Sub' $P914 = "180_1302110486.758" 
    capture_lex $P914
    .const 'Sub' $P870 = "177_1302110486.758" 
    capture_lex $P870
    .const 'Sub' $P836 = "175_1302110486.758" 
    capture_lex $P836
    .const 'Sub' $P829 = "173_1302110486.758" 
    capture_lex $P829
    .const 'Sub' $P822 = "171_1302110486.758" 
    capture_lex $P822
    .const 'Sub' $P805 = "167_1302110486.758" 
    capture_lex $P805
    .const 'Sub' $P797 = "165_1302110486.758" 
    capture_lex $P797
    .const 'Sub' $P791 = "163_1302110486.758" 
    capture_lex $P791
    .const 'Sub' $P775 = "161_1302110486.758" 
    capture_lex $P775
    .const 'Sub' $P768 = "159_1302110486.758" 
    capture_lex $P768
    .const 'Sub' $P761 = "157_1302110486.758" 
    capture_lex $P761
    .const 'Sub' $P754 = "155_1302110486.758" 
    capture_lex $P754
    .const 'Sub' $P676 = "150_1302110486.758" 
    capture_lex $P676
    .const 'Sub' $P664 = "148_1302110486.758" 
    capture_lex $P664
    .const 'Sub' $P652 = "146_1302110486.758" 
    capture_lex $P652
    .const 'Sub' $P640 = "144_1302110486.758" 
    capture_lex $P640
    .const 'Sub' $P628 = "142_1302110486.758" 
    capture_lex $P628
    .const 'Sub' $P616 = "140_1302110486.758" 
    capture_lex $P616
    .const 'Sub' $P604 = "138_1302110486.758" 
    capture_lex $P604
    .const 'Sub' $P593 = "134_1302110486.758" 
    capture_lex $P593
    .const 'Sub' $P588 = "132_1302110486.758" 
    capture_lex $P588
    .const 'Sub' $P576 = "130_1302110486.758" 
    capture_lex $P576
    .const 'Sub' $P564 = "128_1302110486.758" 
    capture_lex $P564
    .const 'Sub' $P557 = "126_1302110486.758" 
    capture_lex $P557
    .const 'Sub' $P552 = "124_1302110486.758" 
    capture_lex $P552
    .const 'Sub' $P546 = "122_1302110486.758" 
    capture_lex $P546
    .const 'Sub' $P540 = "120_1302110486.758" 
    capture_lex $P540
    .const 'Sub' $P525 = "116_1302110486.758" 
    capture_lex $P525
    .const 'Sub' $P519 = "114_1302110486.758" 
    capture_lex $P519
    .const 'Sub' $P513 = "112_1302110486.758" 
    capture_lex $P513
    .const 'Sub' $P507 = "110_1302110486.758" 
    capture_lex $P507
    .const 'Sub' $P501 = "108_1302110486.758" 
    capture_lex $P501
    .const 'Sub' $P495 = "106_1302110486.758" 
    capture_lex $P495
    .const 'Sub' $P489 = "104_1302110486.758" 
    capture_lex $P489
    .const 'Sub' $P480 = "102_1302110486.758" 
    capture_lex $P480
    .const 'Sub' $P471 = "100_1302110486.758" 
    capture_lex $P471
    .const 'Sub' $P462 = "98_1302110486.758" 
    capture_lex $P462
    .const 'Sub' $P447 = "94_1302110486.758" 
    capture_lex $P447
    .const 'Sub' $P438 = "92_1302110486.758" 
    capture_lex $P438
    .const 'Sub' $P426 = "88_1302110486.758" 
    capture_lex $P426
    .const 'Sub' $P419 = "86_1302110486.758" 
    capture_lex $P419
    .const 'Sub' $P412 = "84_1302110486.758" 
    capture_lex $P412
    .const 'Sub' $P398 = "80_1302110486.758" 
    capture_lex $P398
    .const 'Sub' $P390 = "78_1302110486.758" 
    capture_lex $P390
    .const 'Sub' $P382 = "76_1302110486.758" 
    capture_lex $P382
    .const 'Sub' $P362 = "74_1302110486.758" 
    capture_lex $P362
    .const 'Sub' $P353 = "72_1302110486.758" 
    capture_lex $P353
    .const 'Sub' $P335 = "69_1302110486.758" 
    capture_lex $P335
    .const 'Sub' $P317 = "67_1302110486.758" 
    capture_lex $P317
    .const 'Sub' $P309 = "65_1302110486.758" 
    capture_lex $P309
    .const 'Sub' $P298 = "61_1302110486.758" 
    capture_lex $P298
    .const 'Sub' $P293 = "59_1302110486.758" 
    capture_lex $P293
    .const 'Sub' $P282 = "55_1302110486.758" 
    capture_lex $P282
    .const 'Sub' $P277 = "53_1302110486.758" 
    capture_lex $P277
    .const 'Sub' $P272 = "51_1302110486.758" 
    capture_lex $P272
    .const 'Sub' $P267 = "49_1302110486.758" 
    capture_lex $P267
    .const 'Sub' $P257 = "47_1302110486.758" 
    capture_lex $P257
    .const 'Sub' $P250 = "45_1302110486.758" 
    capture_lex $P250
    .const 'Sub' $P244 = "43_1302110486.758" 
    capture_lex $P244
    .const 'Sub' $P236 = "41_1302110486.758" 
    capture_lex $P236
    .const 'Sub' $P230 = "39_1302110486.758" 
    capture_lex $P230
    .const 'Sub' $P224 = "37_1302110486.758" 
    capture_lex $P224
    .const 'Sub' $P209 = "34_1302110486.758" 
    capture_lex $P209
    .const 'Sub' $P195 = "32_1302110486.758" 
    capture_lex $P195
    .const 'Sub' $P184 = "30_1302110486.758" 
    capture_lex $P184
    .const 'Sub' $P145 = "27_1302110486.758" 
    capture_lex $P145
    .const 'Sub' $P130 = "24_1302110486.758" 
    capture_lex $P130
    .const 'Sub' $P119 = "22_1302110486.758" 
    capture_lex $P119
    .const 'Sub' $P107 = "20_1302110486.758" 
    capture_lex $P107
    .const 'Sub' $P99 = "18_1302110486.758" 
    capture_lex $P99
    .const 'Sub' $P92 = "16_1302110486.758" 
    capture_lex $P92
    .const 'Sub' $P85 = "14_1302110486.758" 
    capture_lex $P85
    .const 'Sub' $P36 = "13_1302110486.758" 
    capture_lex $P36
    .lex "$?CLASS", $P35
.annotate 'line', 10
    .const 'Sub' $P1284 = "271_1302110486.758" 
    capture_lex $P1284
    $P1284()
.annotate 'line', 692
    .const 'Sub' $P1667 = "381_1302110486.758" 
    newclosure $P1678, $P1667
.annotate 'line', 9
    .return ($P1678)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "" :load :init :subid("post571") :outer("12_1302110486.758")
.annotate 'line', 9
    get_hll_global $P34, ["NQP";"Grammar"], "_block33" 
    .local pmc block
    set block, $P34
    .const 'Sub' $P1680 = "382_1302110486.758" 
    capture_lex $P1680
    $P1680()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1679"  :anon :subid("382_1302110486.758") :outer("12_1302110486.758")
.annotate 'line', 9
    nqp_get_sc_object $P1681, "1302110474.135", 0
    .local pmc type_obj
    set type_obj, $P1681
    get_how $P1682, type_obj
    .const 'Sub' $P1683 = "13_1302110486.758" 
    $P1682."add_method"(type_obj, "TOP", $P1683)
    get_how $P1684, type_obj
    .const 'Sub' $P1685 = "14_1302110486.758" 
    $P1684."add_method"(type_obj, "identifier", $P1685)
    get_how $P1686, type_obj
    get_global $P1687, "!PREFIX__identifier"
    $P1686."add_method"(type_obj, "!PREFIX__identifier", $P1687)
    get_how $P1688, type_obj
    .const 'Sub' $P1689 = "16_1302110486.758" 
    $P1688."add_method"(type_obj, "name", $P1689)
    get_how $P1690, type_obj
    get_global $P1691, "!PREFIX__name"
    $P1690."add_method"(type_obj, "!PREFIX__name", $P1691)
    get_how $P1692, type_obj
    .const 'Sub' $P1693 = "18_1302110486.758" 
    $P1692."add_method"(type_obj, "deflongname", $P1693)
    get_how $P1694, type_obj
    get_global $P1695, "!PREFIX__deflongname"
    $P1694."add_method"(type_obj, "!PREFIX__deflongname", $P1695)
    get_how $P1696, type_obj
    .const 'Sub' $P1697 = "20_1302110486.758" 
    $P1696."add_method"(type_obj, "ENDSTMT", $P1697)
    get_how $P1698, type_obj
    get_global $P1699, "!PREFIX__ENDSTMT"
    $P1698."add_method"(type_obj, "!PREFIX__ENDSTMT", $P1699)
    get_how $P1700, type_obj
    .const 'Sub' $P1701 = "22_1302110486.758" 
    $P1700."add_method"(type_obj, "ws", $P1701)
    get_how $P1702, type_obj
    get_global $P1703, "!PREFIX__ws"
    $P1702."add_method"(type_obj, "!PREFIX__ws", $P1703)
    get_how $P1704, type_obj
    .const 'Sub' $P1705 = "24_1302110486.758" 
    $P1704."add_method"(type_obj, "unv", $P1705)
    get_how $P1706, type_obj
    get_global $P1707, "!PREFIX__unv"
    $P1706."add_method"(type_obj, "!PREFIX__unv", $P1707)
    get_how $P1708, type_obj
    .const 'Sub' $P1709 = "27_1302110486.758" 
    $P1708."add_method"(type_obj, "pod_comment", $P1709)
    get_how $P1710, type_obj
    get_global $P1711, "!PREFIX__pod_comment"
    $P1710."add_method"(type_obj, "!PREFIX__pod_comment", $P1711)
    get_how $P1712, type_obj
    .const 'Sub' $P1713 = "30_1302110486.758" 
    $P1712."add_method"(type_obj, "comp_unit", $P1713)
    get_how $P1714, type_obj
    get_global $P1715, "!PREFIX__comp_unit"
    $P1714."add_method"(type_obj, "!PREFIX__comp_unit", $P1715)
    get_how $P1716, type_obj
    .const 'Sub' $P1717 = "32_1302110486.758" 
    $P1716."add_method"(type_obj, "statementlist", $P1717)
    get_how $P1718, type_obj
    get_global $P1719, "!PREFIX__statementlist"
    $P1718."add_method"(type_obj, "!PREFIX__statementlist", $P1719)
    get_how $P1720, type_obj
    .const 'Sub' $P1721 = "34_1302110486.758" 
    $P1720."add_method"(type_obj, "statement", $P1721)
    get_how $P1722, type_obj
    get_global $P1723, "!PREFIX__statement"
    $P1722."add_method"(type_obj, "!PREFIX__statement", $P1723)
    get_how $P1724, type_obj
    .const 'Sub' $P1725 = "37_1302110486.758" 
    $P1724."add_method"(type_obj, "eat_terminator", $P1725)
    get_how $P1726, type_obj
    get_global $P1727, "!PREFIX__eat_terminator"
    $P1726."add_method"(type_obj, "!PREFIX__eat_terminator", $P1727)
    get_how $P1728, type_obj
    .const 'Sub' $P1729 = "39_1302110486.758" 
    $P1728."add_method"(type_obj, "xblock", $P1729)
    get_how $P1730, type_obj
    get_global $P1731, "!PREFIX__xblock"
    $P1730."add_method"(type_obj, "!PREFIX__xblock", $P1731)
    get_how $P1732, type_obj
    .const 'Sub' $P1733 = "41_1302110486.758" 
    $P1732."add_method"(type_obj, "pblock", $P1733)
    get_how $P1734, type_obj
    get_global $P1735, "!PREFIX__pblock"
    $P1734."add_method"(type_obj, "!PREFIX__pblock", $P1735)
    get_how $P1736, type_obj
    .const 'Sub' $P1737 = "43_1302110486.758" 
    $P1736."add_method"(type_obj, "lambda", $P1737)
    get_how $P1738, type_obj
    get_global $P1739, "!PREFIX__lambda"
    $P1738."add_method"(type_obj, "!PREFIX__lambda", $P1739)
    get_how $P1740, type_obj
    .const 'Sub' $P1741 = "45_1302110486.758" 
    $P1740."add_method"(type_obj, "block", $P1741)
    get_how $P1742, type_obj
    get_global $P1743, "!PREFIX__block"
    $P1742."add_method"(type_obj, "!PREFIX__block", $P1743)
    get_how $P1744, type_obj
    .const 'Sub' $P1745 = "47_1302110486.758" 
    $P1744."add_method"(type_obj, "blockoid", $P1745)
    get_how $P1746, type_obj
    get_global $P1747, "!PREFIX__blockoid"
    $P1746."add_method"(type_obj, "!PREFIX__blockoid", $P1747)
    get_how $P1748, type_obj
    .const 'Sub' $P1749 = "49_1302110486.758" 
    $P1748."add_method"(type_obj, "newpad", $P1749)
    get_how $P1750, type_obj
    get_global $P1751, "!PREFIX__newpad"
    $P1750."add_method"(type_obj, "!PREFIX__newpad", $P1751)
    get_how $P1752, type_obj
    .const 'Sub' $P1753 = "51_1302110486.758" 
    $P1752."add_method"(type_obj, "outerctx", $P1753)
    get_how $P1754, type_obj
    get_global $P1755, "!PREFIX__outerctx"
    $P1754."add_method"(type_obj, "!PREFIX__outerctx", $P1755)
    get_how $P1756, type_obj
    .const 'Sub' $P1757 = "53_1302110486.758" 
    $P1756."add_method"(type_obj, "finishpad", $P1757)
    get_how $P1758, type_obj
    get_global $P1759, "!PREFIX__finishpad"
    $P1758."add_method"(type_obj, "!PREFIX__finishpad", $P1759)
    get_how $P1760, type_obj
    .const 'Sub' $P1761 = "55_1302110486.758" 
    $P1760."add_method"(type_obj, "you_are_here", $P1761)
    get_how $P1762, type_obj
    get_global $P1763, "!PREFIX__you_are_here"
    $P1762."add_method"(type_obj, "!PREFIX__you_are_here", $P1763)
    get_how $P1764, type_obj
    .const 'Sub' $P1765 = "57_1302110486.758" 
    $P1764."add_method"(type_obj, "terminator", $P1765)
    get_how $P1766, type_obj
    .const 'Sub' $P1767 = "58_1302110486.758" 
    $P1766."add_method"(type_obj, "!PREFIX__terminator", $P1767)
    get_how $P1768, type_obj
    .const 'Sub' $P1769 = "59_1302110486.758" 
    $P1768."add_method"(type_obj, "terminator:sym<;>", $P1769)
    get_how $P1770, type_obj
    get_global $P1771, "!PREFIX__terminator:sym<;>"
    $P1770."add_method"(type_obj, "!PREFIX__terminator:sym<;>", $P1771)
    get_how $P1772, type_obj
    .const 'Sub' $P1773 = "61_1302110486.758" 
    $P1772."add_method"(type_obj, "terminator:sym<}>", $P1773)
    get_how $P1774, type_obj
    get_global $P1775, "!PREFIX__terminator:sym<}>"
    $P1774."add_method"(type_obj, "!PREFIX__terminator:sym<}>", $P1775)
    get_how $P1776, type_obj
    .const 'Sub' $P1777 = "63_1302110486.758" 
    $P1776."add_method"(type_obj, "statement_control", $P1777)
    get_how $P1778, type_obj
    .const 'Sub' $P1779 = "64_1302110486.758" 
    $P1778."add_method"(type_obj, "!PREFIX__statement_control", $P1779)
    get_how $P1780, type_obj
    .const 'Sub' $P1781 = "65_1302110486.758" 
    $P1780."add_method"(type_obj, "statement_control:sym<use>", $P1781)
    get_how $P1782, type_obj
    get_global $P1783, "!PREFIX__statement_control:sym<use>"
    $P1782."add_method"(type_obj, "!PREFIX__statement_control:sym<use>", $P1783)
    get_how $P1784, type_obj
    .const 'Sub' $P1785 = "67_1302110486.758" 
    $P1784."add_method"(type_obj, "statement_control:sym<if>", $P1785)
    get_how $P1786, type_obj
    get_global $P1787, "!PREFIX__statement_control:sym<if>"
    $P1786."add_method"(type_obj, "!PREFIX__statement_control:sym<if>", $P1787)
    get_how $P1788, type_obj
    .const 'Sub' $P1789 = "69_1302110486.758" 
    $P1788."add_method"(type_obj, "statement_control:sym<unless>", $P1789)
    get_how $P1790, type_obj
    get_global $P1791, "!PREFIX__statement_control:sym<unless>"
    $P1790."add_method"(type_obj, "!PREFIX__statement_control:sym<unless>", $P1791)
    get_how $P1792, type_obj
    .const 'Sub' $P1793 = "72_1302110486.758" 
    $P1792."add_method"(type_obj, "statement_control:sym<while>", $P1793)
    get_how $P1794, type_obj
    get_global $P1795, "!PREFIX__statement_control:sym<while>"
    $P1794."add_method"(type_obj, "!PREFIX__statement_control:sym<while>", $P1795)
    get_how $P1796, type_obj
    .const 'Sub' $P1797 = "74_1302110486.758" 
    $P1796."add_method"(type_obj, "statement_control:sym<repeat>", $P1797)
    get_how $P1798, type_obj
    get_global $P1799, "!PREFIX__statement_control:sym<repeat>"
    $P1798."add_method"(type_obj, "!PREFIX__statement_control:sym<repeat>", $P1799)
    get_how $P1800, type_obj
    .const 'Sub' $P1801 = "76_1302110486.758" 
    $P1800."add_method"(type_obj, "statement_control:sym<for>", $P1801)
    get_how $P1802, type_obj
    get_global $P1803, "!PREFIX__statement_control:sym<for>"
    $P1802."add_method"(type_obj, "!PREFIX__statement_control:sym<for>", $P1803)
    get_how $P1804, type_obj
    .const 'Sub' $P1805 = "78_1302110486.758" 
    $P1804."add_method"(type_obj, "statement_control:sym<CATCH>", $P1805)
    get_how $P1806, type_obj
    get_global $P1807, "!PREFIX__statement_control:sym<CATCH>"
    $P1806."add_method"(type_obj, "!PREFIX__statement_control:sym<CATCH>", $P1807)
    get_how $P1808, type_obj
    .const 'Sub' $P1809 = "80_1302110486.758" 
    $P1808."add_method"(type_obj, "statement_control:sym<CONTROL>", $P1809)
    get_how $P1810, type_obj
    get_global $P1811, "!PREFIX__statement_control:sym<CONTROL>"
    $P1810."add_method"(type_obj, "!PREFIX__statement_control:sym<CONTROL>", $P1811)
    get_how $P1812, type_obj
    .const 'Sub' $P1813 = "82_1302110486.758" 
    $P1812."add_method"(type_obj, "statement_prefix", $P1813)
    get_how $P1814, type_obj
    .const 'Sub' $P1815 = "83_1302110486.758" 
    $P1814."add_method"(type_obj, "!PREFIX__statement_prefix", $P1815)
    get_how $P1816, type_obj
    .const 'Sub' $P1817 = "84_1302110486.758" 
    $P1816."add_method"(type_obj, "statement_prefix:sym<INIT>", $P1817)
    get_how $P1818, type_obj
    get_global $P1819, "!PREFIX__statement_prefix:sym<INIT>"
    $P1818."add_method"(type_obj, "!PREFIX__statement_prefix:sym<INIT>", $P1819)
    get_how $P1820, type_obj
    .const 'Sub' $P1821 = "86_1302110486.758" 
    $P1820."add_method"(type_obj, "statement_prefix:sym<try>", $P1821)
    get_how $P1822, type_obj
    get_global $P1823, "!PREFIX__statement_prefix:sym<try>"
    $P1822."add_method"(type_obj, "!PREFIX__statement_prefix:sym<try>", $P1823)
    get_how $P1824, type_obj
    .const 'Sub' $P1825 = "88_1302110486.758" 
    $P1824."add_method"(type_obj, "blorst", $P1825)
    get_how $P1826, type_obj
    get_global $P1827, "!PREFIX__blorst"
    $P1826."add_method"(type_obj, "!PREFIX__blorst", $P1827)
    get_how $P1828, type_obj
    .const 'Sub' $P1829 = "90_1302110486.758" 
    $P1828."add_method"(type_obj, "statement_mod_cond", $P1829)
    get_how $P1830, type_obj
    .const 'Sub' $P1831 = "91_1302110486.758" 
    $P1830."add_method"(type_obj, "!PREFIX__statement_mod_cond", $P1831)
    get_how $P1832, type_obj
    .const 'Sub' $P1833 = "92_1302110486.758" 
    $P1832."add_method"(type_obj, "statement_mod_cond:sym<if>", $P1833)
    get_how $P1834, type_obj
    get_global $P1835, "!PREFIX__statement_mod_cond:sym<if>"
    $P1834."add_method"(type_obj, "!PREFIX__statement_mod_cond:sym<if>", $P1835)
    get_how $P1836, type_obj
    .const 'Sub' $P1837 = "94_1302110486.758" 
    $P1836."add_method"(type_obj, "statement_mod_cond:sym<unless>", $P1837)
    get_how $P1838, type_obj
    get_global $P1839, "!PREFIX__statement_mod_cond:sym<unless>"
    $P1838."add_method"(type_obj, "!PREFIX__statement_mod_cond:sym<unless>", $P1839)
    get_how $P1840, type_obj
    .const 'Sub' $P1841 = "96_1302110486.758" 
    $P1840."add_method"(type_obj, "statement_mod_loop", $P1841)
    get_how $P1842, type_obj
    .const 'Sub' $P1843 = "97_1302110486.758" 
    $P1842."add_method"(type_obj, "!PREFIX__statement_mod_loop", $P1843)
    get_how $P1844, type_obj
    .const 'Sub' $P1845 = "98_1302110486.758" 
    $P1844."add_method"(type_obj, "statement_mod_loop:sym<while>", $P1845)
    get_how $P1846, type_obj
    get_global $P1847, "!PREFIX__statement_mod_loop:sym<while>"
    $P1846."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<while>", $P1847)
    get_how $P1848, type_obj
    .const 'Sub' $P1849 = "100_1302110486.758" 
    $P1848."add_method"(type_obj, "statement_mod_loop:sym<until>", $P1849)
    get_how $P1850, type_obj
    get_global $P1851, "!PREFIX__statement_mod_loop:sym<until>"
    $P1850."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<until>", $P1851)
    get_how $P1852, type_obj
    .const 'Sub' $P1853 = "102_1302110486.758" 
    $P1852."add_method"(type_obj, "statement_mod_loop:sym<for>", $P1853)
    get_how $P1854, type_obj
    get_global $P1855, "!PREFIX__statement_mod_loop:sym<for>"
    $P1854."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<for>", $P1855)
    get_how $P1856, type_obj
    .const 'Sub' $P1857 = "104_1302110486.758" 
    $P1856."add_method"(type_obj, "term:sym<fatarrow>", $P1857)
    get_how $P1858, type_obj
    get_global $P1859, "!PREFIX__term:sym<fatarrow>"
    $P1858."add_method"(type_obj, "!PREFIX__term:sym<fatarrow>", $P1859)
    get_how $P1860, type_obj
    .const 'Sub' $P1861 = "106_1302110486.758" 
    $P1860."add_method"(type_obj, "term:sym<colonpair>", $P1861)
    get_how $P1862, type_obj
    get_global $P1863, "!PREFIX__term:sym<colonpair>"
    $P1862."add_method"(type_obj, "!PREFIX__term:sym<colonpair>", $P1863)
    get_how $P1864, type_obj
    .const 'Sub' $P1865 = "108_1302110486.758" 
    $P1864."add_method"(type_obj, "term:sym<variable>", $P1865)
    get_how $P1866, type_obj
    get_global $P1867, "!PREFIX__term:sym<variable>"
    $P1866."add_method"(type_obj, "!PREFIX__term:sym<variable>", $P1867)
    get_how $P1868, type_obj
    .const 'Sub' $P1869 = "110_1302110486.758" 
    $P1868."add_method"(type_obj, "term:sym<package_declarator>", $P1869)
    get_how $P1870, type_obj
    get_global $P1871, "!PREFIX__term:sym<package_declarator>"
    $P1870."add_method"(type_obj, "!PREFIX__term:sym<package_declarator>", $P1871)
    get_how $P1872, type_obj
    .const 'Sub' $P1873 = "112_1302110486.758" 
    $P1872."add_method"(type_obj, "term:sym<scope_declarator>", $P1873)
    get_how $P1874, type_obj
    get_global $P1875, "!PREFIX__term:sym<scope_declarator>"
    $P1874."add_method"(type_obj, "!PREFIX__term:sym<scope_declarator>", $P1875)
    get_how $P1876, type_obj
    .const 'Sub' $P1877 = "114_1302110486.758" 
    $P1876."add_method"(type_obj, "term:sym<routine_declarator>", $P1877)
    get_how $P1878, type_obj
    get_global $P1879, "!PREFIX__term:sym<routine_declarator>"
    $P1878."add_method"(type_obj, "!PREFIX__term:sym<routine_declarator>", $P1879)
    get_how $P1880, type_obj
    .const 'Sub' $P1881 = "116_1302110486.758" 
    $P1880."add_method"(type_obj, "term:sym<multi_declarator>", $P1881)
    get_how $P1882, type_obj
    get_global $P1883, "!PREFIX__term:sym<multi_declarator>"
    $P1882."add_method"(type_obj, "!PREFIX__term:sym<multi_declarator>", $P1883)
    get_how $P1884, type_obj
    .const 'Sub' $P1885 = "120_1302110486.758" 
    $P1884."add_method"(type_obj, "term:sym<regex_declarator>", $P1885)
    get_how $P1886, type_obj
    get_global $P1887, "!PREFIX__term:sym<regex_declarator>"
    $P1886."add_method"(type_obj, "!PREFIX__term:sym<regex_declarator>", $P1887)
    get_how $P1888, type_obj
    .const 'Sub' $P1889 = "122_1302110486.758" 
    $P1888."add_method"(type_obj, "term:sym<statement_prefix>", $P1889)
    get_how $P1890, type_obj
    get_global $P1891, "!PREFIX__term:sym<statement_prefix>"
    $P1890."add_method"(type_obj, "!PREFIX__term:sym<statement_prefix>", $P1891)
    get_how $P1892, type_obj
    .const 'Sub' $P1893 = "124_1302110486.758" 
    $P1892."add_method"(type_obj, "term:sym<lambda>", $P1893)
    get_how $P1894, type_obj
    get_global $P1895, "!PREFIX__term:sym<lambda>"
    $P1894."add_method"(type_obj, "!PREFIX__term:sym<lambda>", $P1895)
    get_how $P1896, type_obj
    .const 'Sub' $P1897 = "126_1302110486.758" 
    $P1896."add_method"(type_obj, "fatarrow", $P1897)
    get_how $P1898, type_obj
    get_global $P1899, "!PREFIX__fatarrow"
    $P1898."add_method"(type_obj, "!PREFIX__fatarrow", $P1899)
    get_how $P1900, type_obj
    .const 'Sub' $P1901 = "128_1302110486.758" 
    $P1900."add_method"(type_obj, "colonpair", $P1901)
    get_how $P1902, type_obj
    get_global $P1903, "!PREFIX__colonpair"
    $P1902."add_method"(type_obj, "!PREFIX__colonpair", $P1903)
    get_how $P1904, type_obj
    .const 'Sub' $P1905 = "130_1302110486.758" 
    $P1904."add_method"(type_obj, "variable", $P1905)
    get_how $P1906, type_obj
    get_global $P1907, "!PREFIX__variable"
    $P1906."add_method"(type_obj, "!PREFIX__variable", $P1907)
    get_how $P1908, type_obj
    .const 'Sub' $P1909 = "132_1302110486.758" 
    $P1908."add_method"(type_obj, "sigil", $P1909)
    get_how $P1910, type_obj
    get_global $P1911, "!PREFIX__sigil"
    $P1910."add_method"(type_obj, "!PREFIX__sigil", $P1911)
    get_how $P1912, type_obj
    .const 'Sub' $P1913 = "134_1302110486.758" 
    $P1912."add_method"(type_obj, "twigil", $P1913)
    get_how $P1914, type_obj
    get_global $P1915, "!PREFIX__twigil"
    $P1914."add_method"(type_obj, "!PREFIX__twigil", $P1915)
    get_how $P1916, type_obj
    .const 'Sub' $P1917 = "136_1302110486.758" 
    $P1916."add_method"(type_obj, "package_declarator", $P1917)
    get_how $P1918, type_obj
    .const 'Sub' $P1919 = "137_1302110486.758" 
    $P1918."add_method"(type_obj, "!PREFIX__package_declarator", $P1919)
    get_how $P1920, type_obj
    .const 'Sub' $P1921 = "138_1302110486.758" 
    $P1920."add_method"(type_obj, "package_declarator:sym<module>", $P1921)
    get_how $P1922, type_obj
    get_global $P1923, "!PREFIX__package_declarator:sym<module>"
    $P1922."add_method"(type_obj, "!PREFIX__package_declarator:sym<module>", $P1923)
    get_how $P1924, type_obj
    .const 'Sub' $P1925 = "140_1302110486.758" 
    $P1924."add_method"(type_obj, "package_declarator:sym<knowhow>", $P1925)
    get_how $P1926, type_obj
    get_global $P1927, "!PREFIX__package_declarator:sym<knowhow>"
    $P1926."add_method"(type_obj, "!PREFIX__package_declarator:sym<knowhow>", $P1927)
    get_how $P1928, type_obj
    .const 'Sub' $P1929 = "142_1302110486.758" 
    $P1928."add_method"(type_obj, "package_declarator:sym<class>", $P1929)
    get_how $P1930, type_obj
    get_global $P1931, "!PREFIX__package_declarator:sym<class>"
    $P1930."add_method"(type_obj, "!PREFIX__package_declarator:sym<class>", $P1931)
    get_how $P1932, type_obj
    .const 'Sub' $P1933 = "144_1302110486.758" 
    $P1932."add_method"(type_obj, "package_declarator:sym<grammar>", $P1933)
    get_how $P1934, type_obj
    get_global $P1935, "!PREFIX__package_declarator:sym<grammar>"
    $P1934."add_method"(type_obj, "!PREFIX__package_declarator:sym<grammar>", $P1935)
    get_how $P1936, type_obj
    .const 'Sub' $P1937 = "146_1302110486.758" 
    $P1936."add_method"(type_obj, "package_declarator:sym<role>", $P1937)
    get_how $P1938, type_obj
    get_global $P1939, "!PREFIX__package_declarator:sym<role>"
    $P1938."add_method"(type_obj, "!PREFIX__package_declarator:sym<role>", $P1939)
    get_how $P1940, type_obj
    .const 'Sub' $P1941 = "148_1302110486.758" 
    $P1940."add_method"(type_obj, "package_declarator:sym<native>", $P1941)
    get_how $P1942, type_obj
    get_global $P1943, "!PREFIX__package_declarator:sym<native>"
    $P1942."add_method"(type_obj, "!PREFIX__package_declarator:sym<native>", $P1943)
    get_how $P1944, type_obj
    .const 'Sub' $P1945 = "150_1302110486.758" 
    $P1944."add_method"(type_obj, "package_def", $P1945)
    get_how $P1946, type_obj
    get_global $P1947, "!PREFIX__package_def"
    $P1946."add_method"(type_obj, "!PREFIX__package_def", $P1947)
    get_how $P1948, type_obj
    .const 'Sub' $P1949 = "153_1302110486.758" 
    $P1948."add_method"(type_obj, "scope_declarator", $P1949)
    get_how $P1950, type_obj
    .const 'Sub' $P1951 = "154_1302110486.758" 
    $P1950."add_method"(type_obj, "!PREFIX__scope_declarator", $P1951)
    get_how $P1952, type_obj
    .const 'Sub' $P1953 = "155_1302110486.758" 
    $P1952."add_method"(type_obj, "scope_declarator:sym<my>", $P1953)
    get_how $P1954, type_obj
    get_global $P1955, "!PREFIX__scope_declarator:sym<my>"
    $P1954."add_method"(type_obj, "!PREFIX__scope_declarator:sym<my>", $P1955)
    get_how $P1956, type_obj
    .const 'Sub' $P1957 = "157_1302110486.758" 
    $P1956."add_method"(type_obj, "scope_declarator:sym<our>", $P1957)
    get_how $P1958, type_obj
    get_global $P1959, "!PREFIX__scope_declarator:sym<our>"
    $P1958."add_method"(type_obj, "!PREFIX__scope_declarator:sym<our>", $P1959)
    get_how $P1960, type_obj
    .const 'Sub' $P1961 = "159_1302110486.758" 
    $P1960."add_method"(type_obj, "scope_declarator:sym<has>", $P1961)
    get_how $P1962, type_obj
    get_global $P1963, "!PREFIX__scope_declarator:sym<has>"
    $P1962."add_method"(type_obj, "!PREFIX__scope_declarator:sym<has>", $P1963)
    get_how $P1964, type_obj
    .const 'Sub' $P1965 = "161_1302110486.758" 
    $P1964."add_method"(type_obj, "scoped", $P1965)
    get_how $P1966, type_obj
    get_global $P1967, "!PREFIX__scoped"
    $P1966."add_method"(type_obj, "!PREFIX__scoped", $P1967)
    get_how $P1968, type_obj
    .const 'Sub' $P1969 = "163_1302110486.758" 
    $P1968."add_method"(type_obj, "typename", $P1969)
    get_how $P1970, type_obj
    get_global $P1971, "!PREFIX__typename"
    $P1970."add_method"(type_obj, "!PREFIX__typename", $P1971)
    get_how $P1972, type_obj
    .const 'Sub' $P1973 = "165_1302110486.758" 
    $P1972."add_method"(type_obj, "declarator", $P1973)
    get_how $P1974, type_obj
    get_global $P1975, "!PREFIX__declarator"
    $P1974."add_method"(type_obj, "!PREFIX__declarator", $P1975)
    get_how $P1976, type_obj
    .const 'Sub' $P1977 = "167_1302110486.758" 
    $P1976."add_method"(type_obj, "variable_declarator", $P1977)
    get_how $P1978, type_obj
    get_global $P1979, "!PREFIX__variable_declarator"
    $P1978."add_method"(type_obj, "!PREFIX__variable_declarator", $P1979)
    get_how $P1980, type_obj
    .const 'Sub' $P1981 = "169_1302110486.758" 
    $P1980."add_method"(type_obj, "routine_declarator", $P1981)
    get_how $P1982, type_obj
    .const 'Sub' $P1983 = "170_1302110486.758" 
    $P1982."add_method"(type_obj, "!PREFIX__routine_declarator", $P1983)
    get_how $P1984, type_obj
    .const 'Sub' $P1985 = "171_1302110486.758" 
    $P1984."add_method"(type_obj, "routine_declarator:sym<sub>", $P1985)
    get_how $P1986, type_obj
    get_global $P1987, "!PREFIX__routine_declarator:sym<sub>"
    $P1986."add_method"(type_obj, "!PREFIX__routine_declarator:sym<sub>", $P1987)
    get_how $P1988, type_obj
    .const 'Sub' $P1989 = "173_1302110486.758" 
    $P1988."add_method"(type_obj, "routine_declarator:sym<method>", $P1989)
    get_how $P1990, type_obj
    get_global $P1991, "!PREFIX__routine_declarator:sym<method>"
    $P1990."add_method"(type_obj, "!PREFIX__routine_declarator:sym<method>", $P1991)
    get_how $P1992, type_obj
    .const 'Sub' $P1993 = "175_1302110486.758" 
    $P1992."add_method"(type_obj, "routine_def", $P1993)
    get_how $P1994, type_obj
    get_global $P1995, "!PREFIX__routine_def"
    $P1994."add_method"(type_obj, "!PREFIX__routine_def", $P1995)
    get_how $P1996, type_obj
    .const 'Sub' $P1997 = "177_1302110486.758" 
    $P1996."add_method"(type_obj, "method_def", $P1997)
    get_how $P1998, type_obj
    get_global $P1999, "!PREFIX__method_def"
    $P1998."add_method"(type_obj, "!PREFIX__method_def", $P1999)
    get_how $P2000, type_obj
    .const 'Sub' $P2001 = "180_1302110486.758" 
    $P2000."add_method"(type_obj, "onlystar", $P2001)
    get_how $P2002, type_obj
    get_global $P2003, "!PREFIX__onlystar"
    $P2002."add_method"(type_obj, "!PREFIX__onlystar", $P2003)
    get_how $P2004, type_obj
    .const 'Sub' $P2005 = "183_1302110486.758" 
    $P2004."add_method"(type_obj, "multi_declarator", $P2005)
    get_how $P2006, type_obj
    .const 'Sub' $P2007 = "184_1302110486.758" 
    $P2006."add_method"(type_obj, "!PREFIX__multi_declarator", $P2007)
    get_how $P2008, type_obj
    .const 'Sub' $P2009 = "185_1302110486.758" 
    $P2008."add_method"(type_obj, "multi_declarator:sym<multi>", $P2009)
    get_how $P2010, type_obj
    get_global $P2011, "!PREFIX__multi_declarator:sym<multi>"
    $P2010."add_method"(type_obj, "!PREFIX__multi_declarator:sym<multi>", $P2011)
    get_how $P2012, type_obj
    .const 'Sub' $P2013 = "187_1302110486.758" 
    $P2012."add_method"(type_obj, "multi_declarator:sym<proto>", $P2013)
    get_how $P2014, type_obj
    get_global $P2015, "!PREFIX__multi_declarator:sym<proto>"
    $P2014."add_method"(type_obj, "!PREFIX__multi_declarator:sym<proto>", $P2015)
    get_how $P2016, type_obj
    .const 'Sub' $P2017 = "189_1302110486.758" 
    $P2016."add_method"(type_obj, "multi_declarator:sym<null>", $P2017)
    get_how $P2018, type_obj
    get_global $P2019, "!PREFIX__multi_declarator:sym<null>"
    $P2018."add_method"(type_obj, "!PREFIX__multi_declarator:sym<null>", $P2019)
    get_how $P2020, type_obj
    .const 'Sub' $P2021 = "191_1302110486.758" 
    $P2020."add_method"(type_obj, "signature", $P2021)
    get_how $P2022, type_obj
    get_global $P2023, "!PREFIX__signature"
    $P2022."add_method"(type_obj, "!PREFIX__signature", $P2023)
    get_how $P2024, type_obj
    .const 'Sub' $P2025 = "194_1302110486.758" 
    $P2024."add_method"(type_obj, "parameter", $P2025)
    get_how $P2026, type_obj
    get_global $P2027, "!PREFIX__parameter"
    $P2026."add_method"(type_obj, "!PREFIX__parameter", $P2027)
    get_how $P2028, type_obj
    .const 'Sub' $P2029 = "196_1302110486.758" 
    $P2028."add_method"(type_obj, "param_var", $P2029)
    get_how $P2030, type_obj
    get_global $P2031, "!PREFIX__param_var"
    $P2030."add_method"(type_obj, "!PREFIX__param_var", $P2031)
    get_how $P2032, type_obj
    .const 'Sub' $P2033 = "198_1302110486.758" 
    $P2032."add_method"(type_obj, "named_param", $P2033)
    get_how $P2034, type_obj
    get_global $P2035, "!PREFIX__named_param"
    $P2034."add_method"(type_obj, "!PREFIX__named_param", $P2035)
    get_how $P2036, type_obj
    .const 'Sub' $P2037 = "200_1302110486.758" 
    $P2036."add_method"(type_obj, "default_value", $P2037)
    get_how $P2038, type_obj
    get_global $P2039, "!PREFIX__default_value"
    $P2038."add_method"(type_obj, "!PREFIX__default_value", $P2039)
    get_how $P2040, type_obj
    .const 'Sub' $P2041 = "202_1302110486.758" 
    $P2040."add_method"(type_obj, "trait", $P2041)
    get_how $P2042, type_obj
    get_global $P2043, "!PREFIX__trait"
    $P2042."add_method"(type_obj, "!PREFIX__trait", $P2043)
    get_how $P2044, type_obj
    .const 'Sub' $P2045 = "204_1302110486.758" 
    $P2044."add_method"(type_obj, "trait_mod", $P2045)
    get_how $P2046, type_obj
    .const 'Sub' $P2047 = "205_1302110486.758" 
    $P2046."add_method"(type_obj, "!PREFIX__trait_mod", $P2047)
    get_how $P2048, type_obj
    .const 'Sub' $P2049 = "206_1302110486.758" 
    $P2048."add_method"(type_obj, "trait_mod:sym<is>", $P2049)
    get_how $P2050, type_obj
    get_global $P2051, "!PREFIX__trait_mod:sym<is>"
    $P2050."add_method"(type_obj, "!PREFIX__trait_mod:sym<is>", $P2051)
    get_how $P2052, type_obj
    .const 'Sub' $P2053 = "208_1302110486.758" 
    $P2052."add_method"(type_obj, "regex_declarator", $P2053)
    get_how $P2054, type_obj
    get_global $P2055, "!PREFIX__regex_declarator"
    $P2054."add_method"(type_obj, "!PREFIX__regex_declarator", $P2055)
    get_how $P2056, type_obj
    .const 'Sub' $P2057 = "210_1302110486.758" 
    $P2056."add_method"(type_obj, "dotty", $P2057)
    get_how $P2058, type_obj
    get_global $P2059, "!PREFIX__dotty"
    $P2058."add_method"(type_obj, "!PREFIX__dotty", $P2059)
    get_how $P2060, type_obj
    .const 'Sub' $P2061 = "212_1302110486.758" 
    $P2060."add_method"(type_obj, "term", $P2061)
    get_how $P2062, type_obj
    .const 'Sub' $P2063 = "213_1302110486.758" 
    $P2062."add_method"(type_obj, "!PREFIX__term", $P2063)
    get_how $P2064, type_obj
    .const 'Sub' $P2065 = "214_1302110486.758" 
    $P2064."add_method"(type_obj, "term:sym<self>", $P2065)
    get_how $P2066, type_obj
    get_global $P2067, "!PREFIX__term:sym<self>"
    $P2066."add_method"(type_obj, "!PREFIX__term:sym<self>", $P2067)
    get_how $P2068, type_obj
    .const 'Sub' $P2069 = "216_1302110486.758" 
    $P2068."add_method"(type_obj, "term:sym<identifier>", $P2069)
    get_how $P2070, type_obj
    get_global $P2071, "!PREFIX__term:sym<identifier>"
    $P2070."add_method"(type_obj, "!PREFIX__term:sym<identifier>", $P2071)
    get_how $P2072, type_obj
    .const 'Sub' $P2073 = "218_1302110486.758" 
    $P2072."add_method"(type_obj, "term:sym<name>", $P2073)
    get_how $P2074, type_obj
    get_global $P2075, "!PREFIX__term:sym<name>"
    $P2074."add_method"(type_obj, "!PREFIX__term:sym<name>", $P2075)
    get_how $P2076, type_obj
    .const 'Sub' $P2077 = "220_1302110486.758" 
    $P2076."add_method"(type_obj, "term:sym<pir::op>", $P2077)
    get_how $P2078, type_obj
    get_global $P2079, "!PREFIX__term:sym<pir::op>"
    $P2078."add_method"(type_obj, "!PREFIX__term:sym<pir::op>", $P2079)
    get_how $P2080, type_obj
    .const 'Sub' $P2081 = "222_1302110486.758" 
    $P2080."add_method"(type_obj, "term:sym<onlystar>", $P2081)
    get_how $P2082, type_obj
    get_global $P2083, "!PREFIX__term:sym<onlystar>"
    $P2082."add_method"(type_obj, "!PREFIX__term:sym<onlystar>", $P2083)
    get_how $P2084, type_obj
    .const 'Sub' $P2085 = "225_1302110486.758" 
    $P2084."add_method"(type_obj, "args", $P2085)
    get_how $P2086, type_obj
    get_global $P2087, "!PREFIX__args"
    $P2086."add_method"(type_obj, "!PREFIX__args", $P2087)
    get_how $P2088, type_obj
    .const 'Sub' $P2089 = "227_1302110486.758" 
    $P2088."add_method"(type_obj, "arglist", $P2089)
    get_how $P2090, type_obj
    get_global $P2091, "!PREFIX__arglist"
    $P2090."add_method"(type_obj, "!PREFIX__arglist", $P2091)
    get_how $P2092, type_obj
    .const 'Sub' $P2093 = "229_1302110486.758" 
    $P2092."add_method"(type_obj, "term:sym<value>", $P2093)
    get_how $P2094, type_obj
    get_global $P2095, "!PREFIX__term:sym<value>"
    $P2094."add_method"(type_obj, "!PREFIX__term:sym<value>", $P2095)
    get_how $P2096, type_obj
    .const 'Sub' $P2097 = "231_1302110486.758" 
    $P2096."add_method"(type_obj, "value", $P2097)
    get_how $P2098, type_obj
    get_global $P2099, "!PREFIX__value"
    $P2098."add_method"(type_obj, "!PREFIX__value", $P2099)
    get_how $P2100, type_obj
    .const 'Sub' $P2101 = "233_1302110486.758" 
    $P2100."add_method"(type_obj, "number", $P2101)
    get_how $P2102, type_obj
    get_global $P2103, "!PREFIX__number"
    $P2102."add_method"(type_obj, "!PREFIX__number", $P2103)
    get_how $P2104, type_obj
    .const 'Sub' $P2105 = "235_1302110486.758" 
    $P2104."add_method"(type_obj, "quote", $P2105)
    get_how $P2106, type_obj
    .const 'Sub' $P2107 = "236_1302110486.758" 
    $P2106."add_method"(type_obj, "!PREFIX__quote", $P2107)
    get_how $P2108, type_obj
    .const 'Sub' $P2109 = "237_1302110486.758" 
    $P2108."add_method"(type_obj, "quote:sym<apos>", $P2109)
    get_how $P2110, type_obj
    get_global $P2111, "!PREFIX__quote:sym<apos>"
    $P2110."add_method"(type_obj, "!PREFIX__quote:sym<apos>", $P2111)
    get_how $P2112, type_obj
    .const 'Sub' $P2113 = "239_1302110486.758" 
    $P2112."add_method"(type_obj, "quote:sym<dblq>", $P2113)
    get_how $P2114, type_obj
    get_global $P2115, "!PREFIX__quote:sym<dblq>"
    $P2114."add_method"(type_obj, "!PREFIX__quote:sym<dblq>", $P2115)
    get_how $P2116, type_obj
    .const 'Sub' $P2117 = "241_1302110486.758" 
    $P2116."add_method"(type_obj, "quote:sym<q>", $P2117)
    get_how $P2118, type_obj
    get_global $P2119, "!PREFIX__quote:sym<q>"
    $P2118."add_method"(type_obj, "!PREFIX__quote:sym<q>", $P2119)
    get_how $P2120, type_obj
    .const 'Sub' $P2121 = "243_1302110486.758" 
    $P2120."add_method"(type_obj, "quote:sym<qq>", $P2121)
    get_how $P2122, type_obj
    get_global $P2123, "!PREFIX__quote:sym<qq>"
    $P2122."add_method"(type_obj, "!PREFIX__quote:sym<qq>", $P2123)
    get_how $P2124, type_obj
    .const 'Sub' $P2125 = "245_1302110486.758" 
    $P2124."add_method"(type_obj, "quote:sym<Q>", $P2125)
    get_how $P2126, type_obj
    get_global $P2127, "!PREFIX__quote:sym<Q>"
    $P2126."add_method"(type_obj, "!PREFIX__quote:sym<Q>", $P2127)
    get_how $P2128, type_obj
    .const 'Sub' $P2129 = "247_1302110486.758" 
    $P2128."add_method"(type_obj, "quote:sym<Q:PIR>", $P2129)
    get_how $P2130, type_obj
    get_global $P2131, "!PREFIX__quote:sym<Q:PIR>"
    $P2130."add_method"(type_obj, "!PREFIX__quote:sym<Q:PIR>", $P2131)
    get_how $P2132, type_obj
    .const 'Sub' $P2133 = "249_1302110486.758" 
    $P2132."add_method"(type_obj, "quote:sym</ />", $P2133)
    get_how $P2134, type_obj
    get_global $P2135, "!PREFIX__quote:sym</ />"
    $P2134."add_method"(type_obj, "!PREFIX__quote:sym</ />", $P2135)
    get_how $P2136, type_obj
    .const 'Sub' $P2137 = "251_1302110486.758" 
    $P2136."add_method"(type_obj, "quote_escape:sym<$>", $P2137)
    get_how $P2138, type_obj
    get_global $P2139, "!PREFIX__quote_escape:sym<$>"
    $P2138."add_method"(type_obj, "!PREFIX__quote_escape:sym<$>", $P2139)
    get_how $P2140, type_obj
    .const 'Sub' $P2141 = "253_1302110486.758" 
    $P2140."add_method"(type_obj, "quote_escape:sym<{ }>", $P2141)
    get_how $P2142, type_obj
    get_global $P2143, "!PREFIX__quote_escape:sym<{ }>"
    $P2142."add_method"(type_obj, "!PREFIX__quote_escape:sym<{ }>", $P2143)
    get_how $P2144, type_obj
    .const 'Sub' $P2145 = "255_1302110486.758" 
    $P2144."add_method"(type_obj, "quote_escape:sym<esc>", $P2145)
    get_how $P2146, type_obj
    get_global $P2147, "!PREFIX__quote_escape:sym<esc>"
    $P2146."add_method"(type_obj, "!PREFIX__quote_escape:sym<esc>", $P2147)
    get_how $P2148, type_obj
    .const 'Sub' $P2149 = "257_1302110486.758" 
    $P2148."add_method"(type_obj, "circumfix:sym<( )>", $P2149)
    get_how $P2150, type_obj
    get_global $P2151, "!PREFIX__circumfix:sym<( )>"
    $P2150."add_method"(type_obj, "!PREFIX__circumfix:sym<( )>", $P2151)
    get_how $P2152, type_obj
    .const 'Sub' $P2153 = "259_1302110486.758" 
    $P2152."add_method"(type_obj, "circumfix:sym<[ ]>", $P2153)
    get_how $P2154, type_obj
    get_global $P2155, "!PREFIX__circumfix:sym<[ ]>"
    $P2154."add_method"(type_obj, "!PREFIX__circumfix:sym<[ ]>", $P2155)
    get_how $P2156, type_obj
    .const 'Sub' $P2157 = "261_1302110486.758" 
    $P2156."add_method"(type_obj, "circumfix:sym<ang>", $P2157)
    get_how $P2158, type_obj
    get_global $P2159, "!PREFIX__circumfix:sym<ang>"
    $P2158."add_method"(type_obj, "!PREFIX__circumfix:sym<ang>", $P2159)
    get_how $P2160, type_obj
    .const 'Sub' $P2161 = "263_1302110486.758" 
    $P2160."add_method"(type_obj, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P2161)
    get_how $P2162, type_obj
    get_global $P2163, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"
    $P2162."add_method"(type_obj, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>", $P2163)
    get_how $P2164, type_obj
    .const 'Sub' $P2165 = "265_1302110486.758" 
    $P2164."add_method"(type_obj, "circumfix:sym<{ }>", $P2165)
    get_how $P2166, type_obj
    get_global $P2167, "!PREFIX__circumfix:sym<{ }>"
    $P2166."add_method"(type_obj, "!PREFIX__circumfix:sym<{ }>", $P2167)
    get_how $P2168, type_obj
    .const 'Sub' $P2169 = "267_1302110486.758" 
    $P2168."add_method"(type_obj, "circumfix:sym<sigil>", $P2169)
    get_how $P2170, type_obj
    get_global $P2171, "!PREFIX__circumfix:sym<sigil>"
    $P2170."add_method"(type_obj, "!PREFIX__circumfix:sym<sigil>", $P2171)
    get_how $P2172, type_obj
    .const 'Sub' $P2173 = "269_1302110486.758" 
    $P2172."add_method"(type_obj, "semilist", $P2173)
    get_how $P2174, type_obj
    get_global $P2175, "!PREFIX__semilist"
    $P2174."add_method"(type_obj, "!PREFIX__semilist", $P2175)
    get_how $P2176, type_obj
    .const 'Sub' $P2177 = "272_1302110486.758" 
    $P2176."add_method"(type_obj, "infixish", $P2177)
    get_how $P2178, type_obj
    get_global $P2179, "!PREFIX__infixish"
    $P2178."add_method"(type_obj, "!PREFIX__infixish", $P2179)
    get_how $P2180, type_obj
    .const 'Sub' $P2181 = "274_1302110486.758" 
    $P2180."add_method"(type_obj, "infixstopper", $P2181)
    get_how $P2182, type_obj
    get_global $P2183, "!PREFIX__infixstopper"
    $P2182."add_method"(type_obj, "!PREFIX__infixstopper", $P2183)
    get_how $P2184, type_obj
    .const 'Sub' $P2185 = "276_1302110486.758" 
    $P2184."add_method"(type_obj, "postcircumfix:sym<[ ]>", $P2185)
    get_how $P2186, type_obj
    get_global $P2187, "!PREFIX__postcircumfix:sym<[ ]>"
    $P2186."add_method"(type_obj, "!PREFIX__postcircumfix:sym<[ ]>", $P2187)
    get_how $P2188, type_obj
    .const 'Sub' $P2189 = "278_1302110486.758" 
    $P2188."add_method"(type_obj, "postcircumfix:sym<{ }>", $P2189)
    get_how $P2190, type_obj
    get_global $P2191, "!PREFIX__postcircumfix:sym<{ }>"
    $P2190."add_method"(type_obj, "!PREFIX__postcircumfix:sym<{ }>", $P2191)
    get_how $P2192, type_obj
    .const 'Sub' $P2193 = "280_1302110486.758" 
    $P2192."add_method"(type_obj, "postcircumfix:sym<ang>", $P2193)
    get_how $P2194, type_obj
    get_global $P2195, "!PREFIX__postcircumfix:sym<ang>"
    $P2194."add_method"(type_obj, "!PREFIX__postcircumfix:sym<ang>", $P2195)
    get_how $P2196, type_obj
    .const 'Sub' $P2197 = "282_1302110486.758" 
    $P2196."add_method"(type_obj, "postcircumfix:sym<( )>", $P2197)
    get_how $P2198, type_obj
    get_global $P2199, "!PREFIX__postcircumfix:sym<( )>"
    $P2198."add_method"(type_obj, "!PREFIX__postcircumfix:sym<( )>", $P2199)
    get_how $P2200, type_obj
    .const 'Sub' $P2201 = "284_1302110486.758" 
    $P2200."add_method"(type_obj, "postfix:sym<.>", $P2201)
    get_how $P2202, type_obj
    get_global $P2203, "!PREFIX__postfix:sym<.>"
    $P2202."add_method"(type_obj, "!PREFIX__postfix:sym<.>", $P2203)
    get_how $P2204, type_obj
    .const 'Sub' $P2205 = "286_1302110486.758" 
    $P2204."add_method"(type_obj, "prefix:sym<++>", $P2205)
    get_how $P2206, type_obj
    get_global $P2207, "!PREFIX__prefix:sym<++>"
    $P2206."add_method"(type_obj, "!PREFIX__prefix:sym<++>", $P2207)
    get_how $P2208, type_obj
    .const 'Sub' $P2209 = "288_1302110486.758" 
    $P2208."add_method"(type_obj, "prefix:sym<-->", $P2209)
    get_how $P2210, type_obj
    get_global $P2211, "!PREFIX__prefix:sym<-->"
    $P2210."add_method"(type_obj, "!PREFIX__prefix:sym<-->", $P2211)
    get_how $P2212, type_obj
    .const 'Sub' $P2213 = "290_1302110486.758" 
    $P2212."add_method"(type_obj, "postfix:sym<++>", $P2213)
    get_how $P2214, type_obj
    get_global $P2215, "!PREFIX__postfix:sym<++>"
    $P2214."add_method"(type_obj, "!PREFIX__postfix:sym<++>", $P2215)
    get_how $P2216, type_obj
    .const 'Sub' $P2217 = "292_1302110486.758" 
    $P2216."add_method"(type_obj, "postfix:sym<-->", $P2217)
    get_how $P2218, type_obj
    get_global $P2219, "!PREFIX__postfix:sym<-->"
    $P2218."add_method"(type_obj, "!PREFIX__postfix:sym<-->", $P2219)
    get_how $P2220, type_obj
    .const 'Sub' $P2221 = "294_1302110486.758" 
    $P2220."add_method"(type_obj, "infix:sym<**>", $P2221)
    get_how $P2222, type_obj
    get_global $P2223, "!PREFIX__infix:sym<**>"
    $P2222."add_method"(type_obj, "!PREFIX__infix:sym<**>", $P2223)
    get_how $P2224, type_obj
    .const 'Sub' $P2225 = "296_1302110486.758" 
    $P2224."add_method"(type_obj, "prefix:sym<+>", $P2225)
    get_how $P2226, type_obj
    get_global $P2227, "!PREFIX__prefix:sym<+>"
    $P2226."add_method"(type_obj, "!PREFIX__prefix:sym<+>", $P2227)
    get_how $P2228, type_obj
    .const 'Sub' $P2229 = "298_1302110486.758" 
    $P2228."add_method"(type_obj, "prefix:sym<~>", $P2229)
    get_how $P2230, type_obj
    get_global $P2231, "!PREFIX__prefix:sym<~>"
    $P2230."add_method"(type_obj, "!PREFIX__prefix:sym<~>", $P2231)
    get_how $P2232, type_obj
    .const 'Sub' $P2233 = "300_1302110486.758" 
    $P2232."add_method"(type_obj, "prefix:sym<->", $P2233)
    get_how $P2234, type_obj
    get_global $P2235, "!PREFIX__prefix:sym<->"
    $P2234."add_method"(type_obj, "!PREFIX__prefix:sym<->", $P2235)
    get_how $P2236, type_obj
    .const 'Sub' $P2237 = "302_1302110486.758" 
    $P2236."add_method"(type_obj, "prefix:sym<?>", $P2237)
    get_how $P2238, type_obj
    get_global $P2239, "!PREFIX__prefix:sym<?>"
    $P2238."add_method"(type_obj, "!PREFIX__prefix:sym<?>", $P2239)
    get_how $P2240, type_obj
    .const 'Sub' $P2241 = "304_1302110486.758" 
    $P2240."add_method"(type_obj, "prefix:sym<!>", $P2241)
    get_how $P2242, type_obj
    get_global $P2243, "!PREFIX__prefix:sym<!>"
    $P2242."add_method"(type_obj, "!PREFIX__prefix:sym<!>", $P2243)
    get_how $P2244, type_obj
    .const 'Sub' $P2245 = "306_1302110486.758" 
    $P2244."add_method"(type_obj, "prefix:sym<|>", $P2245)
    get_how $P2246, type_obj
    get_global $P2247, "!PREFIX__prefix:sym<|>"
    $P2246."add_method"(type_obj, "!PREFIX__prefix:sym<|>", $P2247)
    get_how $P2248, type_obj
    .const 'Sub' $P2249 = "308_1302110486.758" 
    $P2248."add_method"(type_obj, "infix:sym<*>", $P2249)
    get_how $P2250, type_obj
    get_global $P2251, "!PREFIX__infix:sym<*>"
    $P2250."add_method"(type_obj, "!PREFIX__infix:sym<*>", $P2251)
    get_how $P2252, type_obj
    .const 'Sub' $P2253 = "310_1302110486.758" 
    $P2252."add_method"(type_obj, "infix:sym</>", $P2253)
    get_how $P2254, type_obj
    get_global $P2255, "!PREFIX__infix:sym</>"
    $P2254."add_method"(type_obj, "!PREFIX__infix:sym</>", $P2255)
    get_how $P2256, type_obj
    .const 'Sub' $P2257 = "312_1302110486.758" 
    $P2256."add_method"(type_obj, "infix:sym<%>", $P2257)
    get_how $P2258, type_obj
    get_global $P2259, "!PREFIX__infix:sym<%>"
    $P2258."add_method"(type_obj, "!PREFIX__infix:sym<%>", $P2259)
    get_how $P2260, type_obj
    .const 'Sub' $P2261 = "314_1302110486.758" 
    $P2260."add_method"(type_obj, "infix:sym<+&>", $P2261)
    get_how $P2262, type_obj
    get_global $P2263, "!PREFIX__infix:sym<+&>"
    $P2262."add_method"(type_obj, "!PREFIX__infix:sym<+&>", $P2263)
    get_how $P2264, type_obj
    .const 'Sub' $P2265 = "316_1302110486.758" 
    $P2264."add_method"(type_obj, "infix:sym<+>", $P2265)
    get_how $P2266, type_obj
    get_global $P2267, "!PREFIX__infix:sym<+>"
    $P2266."add_method"(type_obj, "!PREFIX__infix:sym<+>", $P2267)
    get_how $P2268, type_obj
    .const 'Sub' $P2269 = "318_1302110486.758" 
    $P2268."add_method"(type_obj, "infix:sym<->", $P2269)
    get_how $P2270, type_obj
    get_global $P2271, "!PREFIX__infix:sym<->"
    $P2270."add_method"(type_obj, "!PREFIX__infix:sym<->", $P2271)
    get_how $P2272, type_obj
    .const 'Sub' $P2273 = "320_1302110486.758" 
    $P2272."add_method"(type_obj, "infix:sym<+|>", $P2273)
    get_how $P2274, type_obj
    get_global $P2275, "!PREFIX__infix:sym<+|>"
    $P2274."add_method"(type_obj, "!PREFIX__infix:sym<+|>", $P2275)
    get_how $P2276, type_obj
    .const 'Sub' $P2277 = "322_1302110486.758" 
    $P2276."add_method"(type_obj, "infix:sym<+^>", $P2277)
    get_how $P2278, type_obj
    get_global $P2279, "!PREFIX__infix:sym<+^>"
    $P2278."add_method"(type_obj, "!PREFIX__infix:sym<+^>", $P2279)
    get_how $P2280, type_obj
    .const 'Sub' $P2281 = "324_1302110486.758" 
    $P2280."add_method"(type_obj, "infix:sym<~>", $P2281)
    get_how $P2282, type_obj
    get_global $P2283, "!PREFIX__infix:sym<~>"
    $P2282."add_method"(type_obj, "!PREFIX__infix:sym<~>", $P2283)
    get_how $P2284, type_obj
    .const 'Sub' $P2285 = "326_1302110486.758" 
    $P2284."add_method"(type_obj, "infix:sym<==>", $P2285)
    get_how $P2286, type_obj
    get_global $P2287, "!PREFIX__infix:sym<==>"
    $P2286."add_method"(type_obj, "!PREFIX__infix:sym<==>", $P2287)
    get_how $P2288, type_obj
    .const 'Sub' $P2289 = "328_1302110486.758" 
    $P2288."add_method"(type_obj, "infix:sym<!=>", $P2289)
    get_how $P2290, type_obj
    get_global $P2291, "!PREFIX__infix:sym<!=>"
    $P2290."add_method"(type_obj, "!PREFIX__infix:sym<!=>", $P2291)
    get_how $P2292, type_obj
    .const 'Sub' $P2293 = "330_1302110486.758" 
    $P2292."add_method"(type_obj, "infix:sym<<=>", $P2293)
    get_how $P2294, type_obj
    get_global $P2295, "!PREFIX__infix:sym<<=>"
    $P2294."add_method"(type_obj, "!PREFIX__infix:sym<<=>", $P2295)
    get_how $P2296, type_obj
    .const 'Sub' $P2297 = "332_1302110486.758" 
    $P2296."add_method"(type_obj, "infix:sym<>=>", $P2297)
    get_how $P2298, type_obj
    get_global $P2299, "!PREFIX__infix:sym<>=>"
    $P2298."add_method"(type_obj, "!PREFIX__infix:sym<>=>", $P2299)
    get_how $P2300, type_obj
    .const 'Sub' $P2301 = "334_1302110486.758" 
    $P2300."add_method"(type_obj, "infix:sym<<>", $P2301)
    get_how $P2302, type_obj
    get_global $P2303, "!PREFIX__infix:sym<<>"
    $P2302."add_method"(type_obj, "!PREFIX__infix:sym<<>", $P2303)
    get_how $P2304, type_obj
    .const 'Sub' $P2305 = "336_1302110486.758" 
    $P2304."add_method"(type_obj, "infix:sym<>>", $P2305)
    get_how $P2306, type_obj
    get_global $P2307, "!PREFIX__infix:sym<>>"
    $P2306."add_method"(type_obj, "!PREFIX__infix:sym<>>", $P2307)
    get_how $P2308, type_obj
    .const 'Sub' $P2309 = "338_1302110486.758" 
    $P2308."add_method"(type_obj, "infix:sym<eq>", $P2309)
    get_how $P2310, type_obj
    get_global $P2311, "!PREFIX__infix:sym<eq>"
    $P2310."add_method"(type_obj, "!PREFIX__infix:sym<eq>", $P2311)
    get_how $P2312, type_obj
    .const 'Sub' $P2313 = "340_1302110486.758" 
    $P2312."add_method"(type_obj, "infix:sym<ne>", $P2313)
    get_how $P2314, type_obj
    get_global $P2315, "!PREFIX__infix:sym<ne>"
    $P2314."add_method"(type_obj, "!PREFIX__infix:sym<ne>", $P2315)
    get_how $P2316, type_obj
    .const 'Sub' $P2317 = "342_1302110486.758" 
    $P2316."add_method"(type_obj, "infix:sym<le>", $P2317)
    get_how $P2318, type_obj
    get_global $P2319, "!PREFIX__infix:sym<le>"
    $P2318."add_method"(type_obj, "!PREFIX__infix:sym<le>", $P2319)
    get_how $P2320, type_obj
    .const 'Sub' $P2321 = "344_1302110486.758" 
    $P2320."add_method"(type_obj, "infix:sym<ge>", $P2321)
    get_how $P2322, type_obj
    get_global $P2323, "!PREFIX__infix:sym<ge>"
    $P2322."add_method"(type_obj, "!PREFIX__infix:sym<ge>", $P2323)
    get_how $P2324, type_obj
    .const 'Sub' $P2325 = "346_1302110486.758" 
    $P2324."add_method"(type_obj, "infix:sym<lt>", $P2325)
    get_how $P2326, type_obj
    get_global $P2327, "!PREFIX__infix:sym<lt>"
    $P2326."add_method"(type_obj, "!PREFIX__infix:sym<lt>", $P2327)
    get_how $P2328, type_obj
    .const 'Sub' $P2329 = "348_1302110486.758" 
    $P2328."add_method"(type_obj, "infix:sym<gt>", $P2329)
    get_how $P2330, type_obj
    get_global $P2331, "!PREFIX__infix:sym<gt>"
    $P2330."add_method"(type_obj, "!PREFIX__infix:sym<gt>", $P2331)
    get_how $P2332, type_obj
    .const 'Sub' $P2333 = "350_1302110486.758" 
    $P2332."add_method"(type_obj, "infix:sym<=:=>", $P2333)
    get_how $P2334, type_obj
    get_global $P2335, "!PREFIX__infix:sym<=:=>"
    $P2334."add_method"(type_obj, "!PREFIX__infix:sym<=:=>", $P2335)
    get_how $P2336, type_obj
    .const 'Sub' $P2337 = "352_1302110486.758" 
    $P2336."add_method"(type_obj, "infix:sym<~~>", $P2337)
    get_how $P2338, type_obj
    get_global $P2339, "!PREFIX__infix:sym<~~>"
    $P2338."add_method"(type_obj, "!PREFIX__infix:sym<~~>", $P2339)
    get_how $P2340, type_obj
    .const 'Sub' $P2341 = "354_1302110486.758" 
    $P2340."add_method"(type_obj, "infix:sym<&&>", $P2341)
    get_how $P2342, type_obj
    get_global $P2343, "!PREFIX__infix:sym<&&>"
    $P2342."add_method"(type_obj, "!PREFIX__infix:sym<&&>", $P2343)
    get_how $P2344, type_obj
    .const 'Sub' $P2345 = "356_1302110486.758" 
    $P2344."add_method"(type_obj, "infix:sym<||>", $P2345)
    get_how $P2346, type_obj
    get_global $P2347, "!PREFIX__infix:sym<||>"
    $P2346."add_method"(type_obj, "!PREFIX__infix:sym<||>", $P2347)
    get_how $P2348, type_obj
    .const 'Sub' $P2349 = "358_1302110486.758" 
    $P2348."add_method"(type_obj, "infix:sym<//>", $P2349)
    get_how $P2350, type_obj
    get_global $P2351, "!PREFIX__infix:sym<//>"
    $P2350."add_method"(type_obj, "!PREFIX__infix:sym<//>", $P2351)
    get_how $P2352, type_obj
    .const 'Sub' $P2353 = "360_1302110486.758" 
    $P2352."add_method"(type_obj, "infix:sym<?? !!>", $P2353)
    get_how $P2354, type_obj
    get_global $P2355, "!PREFIX__infix:sym<?? !!>"
    $P2354."add_method"(type_obj, "!PREFIX__infix:sym<?? !!>", $P2355)
    get_how $P2356, type_obj
    .const 'Sub' $P2357 = "362_1302110486.758" 
    $P2356."add_method"(type_obj, "infix:sym<=>", $P2357)
    get_how $P2358, type_obj
    get_global $P2359, "!PREFIX__infix:sym<=>"
    $P2358."add_method"(type_obj, "!PREFIX__infix:sym<=>", $P2359)
    get_how $P2360, type_obj
    .const 'Sub' $P2361 = "364_1302110486.758" 
    $P2360."add_method"(type_obj, "infix:sym<:=>", $P2361)
    get_how $P2362, type_obj
    get_global $P2363, "!PREFIX__infix:sym<:=>"
    $P2362."add_method"(type_obj, "!PREFIX__infix:sym<:=>", $P2363)
    get_how $P2364, type_obj
    .const 'Sub' $P2365 = "366_1302110486.758" 
    $P2364."add_method"(type_obj, "infix:sym<::=>", $P2365)
    get_how $P2366, type_obj
    get_global $P2367, "!PREFIX__infix:sym<::=>"
    $P2366."add_method"(type_obj, "!PREFIX__infix:sym<::=>", $P2367)
    get_how $P2368, type_obj
    .const 'Sub' $P2369 = "368_1302110486.758" 
    $P2368."add_method"(type_obj, "infix:sym<,>", $P2369)
    get_how $P2370, type_obj
    get_global $P2371, "!PREFIX__infix:sym<,>"
    $P2370."add_method"(type_obj, "!PREFIX__infix:sym<,>", $P2371)
    get_how $P2372, type_obj
    .const 'Sub' $P2373 = "370_1302110486.758" 
    $P2372."add_method"(type_obj, "prefix:sym<return>", $P2373)
    get_how $P2374, type_obj
    get_global $P2375, "!PREFIX__prefix:sym<return>"
    $P2374."add_method"(type_obj, "!PREFIX__prefix:sym<return>", $P2375)
    get_how $P2376, type_obj
    .const 'Sub' $P2377 = "373_1302110486.758" 
    $P2376."add_method"(type_obj, "prefix:sym<make>", $P2377)
    get_how $P2378, type_obj
    get_global $P2379, "!PREFIX__prefix:sym<make>"
    $P2378."add_method"(type_obj, "!PREFIX__prefix:sym<make>", $P2379)
    get_how $P2380, type_obj
    .const 'Sub' $P2381 = "375_1302110486.758" 
    $P2380."add_method"(type_obj, "term:sym<last>", $P2381)
    get_how $P2382, type_obj
    get_global $P2383, "!PREFIX__term:sym<last>"
    $P2382."add_method"(type_obj, "!PREFIX__term:sym<last>", $P2383)
    get_how $P2384, type_obj
    .const 'Sub' $P2385 = "377_1302110486.758" 
    $P2384."add_method"(type_obj, "term:sym<next>", $P2385)
    get_how $P2386, type_obj
    get_global $P2387, "!PREFIX__term:sym<next>"
    $P2386."add_method"(type_obj, "!PREFIX__term:sym<next>", $P2387)
    get_how $P2388, type_obj
    .const 'Sub' $P2389 = "379_1302110486.758" 
    $P2388."add_method"(type_obj, "term:sym<redo>", $P2389)
    get_how $P2390, type_obj
    get_global $P2391, "!PREFIX__term:sym<redo>"
    $P2390."add_method"(type_obj, "!PREFIX__term:sym<redo>", $P2391)
    get_how $P2392, type_obj
    .const 'Sub' $P2393 = "381_1302110486.758" 
    $P2392."add_method"(type_obj, "smartmatch", $P2393)
    get_how $P2394, type_obj
    get_hll_global $P2395, ["HLL"], "Grammar"
    $P2394."add_parent"(type_obj, $P2395)
    get_how $P2396, type_obj
    $P2397 = $P2396."compose"(type_obj)
    .return ($P2397)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "TOP"  :subid("13_1302110486.758") :outer("12_1302110486.758")
    .param pmc param_37
.annotate 'line', 10
    .lex "self", param_37
.annotate 'line', 12
    $P38 = root_new ['parrot';'Hash']
    .lex "%*LANG", $P38
.annotate 'line', 19
    $P39 = root_new ['parrot';'Hash']
    .lex "%*HOW", $P39
.annotate 'line', 28
    new $P40, "Undef"
    .lex "$*DEFAULT-METAATTR", $P40
.annotate 'line', 29
    $P41 = root_new ['parrot';'Hash']
    .lex "%*HOW-METAATTR", $P41
.annotate 'line', 35
    new $P42, "Undef"
    .lex "$*SC", $P42
.annotate 'line', 39
    new $P43, "Undef"
    .lex "$*SCOPE", $P43
.annotate 'line', 40
    new $P44, "Undef"
    .lex "$*MULTINESS", $P44
.annotate 'line', 41
    new $P45, "Undef"
    .lex "$*INVOCANT_OK", $P45
.annotate 'line', 42
    new $P46, "Undef"
    .lex "$*RETURN_USED", $P46
.annotate 'line', 43
    new $P47, "Undef"
    .lex "$*PACKAGE-SETUP", $P47
.annotate 'line', 10
    find_lex $P48, "%*LANG"
    unless_null $P48, vivify_572
    get_hll_global $P48, "%LANG"
    unless_null $P48, vivify_573
    die "Contextual %*LANG not found"
  vivify_573:
  vivify_572:
.annotate 'line', 13
    get_hll_global $P49, ["NQP"], "Regex"
    find_lex $P50, "%*LANG"
    unless_null $P50, vivify_574
    get_hll_global $P50, "%LANG"
    unless_null $P50, vivify_575
    die "Contextual %*LANG not found"
  vivify_575:
    store_lex "%*LANG", $P50
  vivify_574:
    set $P50["Regex"], $P49
.annotate 'line', 14
    get_hll_global $P51, ["NQP"], "RegexActions"
    find_lex $P52, "%*LANG"
    unless_null $P52, vivify_576
    get_hll_global $P52, "%LANG"
    unless_null $P52, vivify_577
    die "Contextual %*LANG not found"
  vivify_577:
    store_lex "%*LANG", $P52
  vivify_576:
    set $P52["Regex-actions"], $P51
.annotate 'line', 15
    get_hll_global $P53, ["NQP"], "Grammar"
    find_lex $P54, "%*LANG"
    unless_null $P54, vivify_578
    get_hll_global $P54, "%LANG"
    unless_null $P54, vivify_579
    die "Contextual %*LANG not found"
  vivify_579:
    store_lex "%*LANG", $P54
  vivify_578:
    set $P54["MAIN"], $P53
.annotate 'line', 16
    get_hll_global $P55, ["NQP"], "Actions"
    find_lex $P56, "%*LANG"
    unless_null $P56, vivify_580
    get_hll_global $P56, "%LANG"
    unless_null $P56, vivify_581
    die "Contextual %*LANG not found"
  vivify_581:
    store_lex "%*LANG", $P56
  vivify_580:
    set $P56["MAIN-actions"], $P55
    find_lex $P57, "%*HOW"
    unless_null $P57, vivify_582
    get_hll_global $P57, "%HOW"
    unless_null $P57, vivify_583
    die "Contextual %*HOW not found"
  vivify_583:
  vivify_582:
.annotate 'line', 20
    get_hll_global $P58, "KnowHOW"
    find_lex $P59, "%*HOW"
    unless_null $P59, vivify_584
    get_hll_global $P59, "%HOW"
    unless_null $P59, vivify_585
    die "Contextual %*HOW not found"
  vivify_585:
    store_lex "%*HOW", $P59
  vivify_584:
    set $P59["knowhow"], $P58
.annotate 'line', 21
    get_hll_global $P60, "NQPModuleHOW"
    find_lex $P61, "%*HOW"
    unless_null $P61, vivify_586
    get_hll_global $P61, "%HOW"
    unless_null $P61, vivify_587
    die "Contextual %*HOW not found"
  vivify_587:
    store_lex "%*HOW", $P61
  vivify_586:
    set $P61["module"], $P60
.annotate 'line', 22
    get_hll_global $P62, "NQPClassHOW"
    find_lex $P63, "%*HOW"
    unless_null $P63, vivify_588
    get_hll_global $P63, "%HOW"
    unless_null $P63, vivify_589
    die "Contextual %*HOW not found"
  vivify_589:
    store_lex "%*HOW", $P63
  vivify_588:
    set $P63["class"], $P62
.annotate 'line', 23
    get_hll_global $P64, "NQPClassHOW"
    find_lex $P65, "%*HOW"
    unless_null $P65, vivify_590
    get_hll_global $P65, "%HOW"
    unless_null $P65, vivify_591
    die "Contextual %*HOW not found"
  vivify_591:
    store_lex "%*HOW", $P65
  vivify_590:
    set $P65["grammar"], $P64
.annotate 'line', 24
    get_hll_global $P66, "NQPParametricRoleHOW"
    find_lex $P67, "%*HOW"
    unless_null $P67, vivify_592
    get_hll_global $P67, "%HOW"
    unless_null $P67, vivify_593
    die "Contextual %*HOW not found"
  vivify_593:
    store_lex "%*HOW", $P67
  vivify_592:
    set $P67["role"], $P66
.annotate 'line', 25
    get_hll_global $P68, "NQPNativeHOW"
    find_lex $P69, "%*HOW"
    unless_null $P69, vivify_594
    get_hll_global $P69, "%HOW"
    unless_null $P69, vivify_595
    die "Contextual %*HOW not found"
  vivify_595:
    store_lex "%*HOW", $P69
  vivify_594:
    set $P69["native"], $P68
.annotate 'line', 28
    new $P70, "String"
    assign $P70, "NQPAttribute"
    store_lex "$*DEFAULT-METAATTR", $P70
    find_lex $P71, "%*HOW-METAATTR"
    unless_null $P71, vivify_596
    get_hll_global $P71, "%HOW-METAATTR"
    unless_null $P71, vivify_597
    die "Contextual %*HOW-METAATTR not found"
  vivify_597:
  vivify_596:
.annotate 'line', 30
    new $P72, "String"
    assign $P72, "KnowHOWAttribute"
    find_lex $P73, "%*HOW-METAATTR"
    unless_null $P73, vivify_598
    get_hll_global $P73, "%HOW-METAATTR"
    unless_null $P73, vivify_599
    die "Contextual %*HOW-METAATTR not found"
  vivify_599:
    store_lex "%*HOW-METAATTR", $P73
  vivify_598:
    set $P73["knowhow"], $P72
.annotate 'line', 35
    get_hll_global $P74, ["HLL";"Compiler"], "SerializationContextBuilder"
.annotate 'line', 37
    time $N75
    set $S76, $N75
    $P77 = $P74."new"($S76 :named("handle"))
.annotate 'line', 35
    store_lex "$*SC", $P77
.annotate 'line', 39
    new $P78, "String"
    assign $P78, ""
    store_lex "$*SCOPE", $P78
.annotate 'line', 40
    new $P79, "String"
    assign $P79, ""
    store_lex "$*MULTINESS", $P79
.annotate 'line', 41
    new $P80, "Integer"
    assign $P80, 0
    store_lex "$*INVOCANT_OK", $P80
.annotate 'line', 42
    new $P81, "Integer"
    assign $P81, 0
    store_lex "$*RETURN_USED", $P81
    find_lex $P82, "$*PACKAGE-SETUP"
    unless_null $P82, vivify_600
    get_hll_global $P82, "$PACKAGE-SETUP"
    unless_null $P82, vivify_601
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_601:
  vivify_600:
.annotate 'line', 44
    find_lex $P83, "self"
    $P84 = $P83."comp_unit"()
.annotate 'line', 10
    .return ($P84)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "identifier"  :subid("14_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx86_tgt
    .local int rx86_pos
    .local int rx86_off
    .local int rx86_eos
    .local int rx86_rep
    .local pmc rx86_cur
    .local pmc rx86_debug
    (rx86_cur, rx86_pos, rx86_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx86_cur
    .local pmc match
    .lex "$/", match
    length rx86_eos, rx86_tgt
    gt rx86_pos, rx86_eos, rx86_done
    set rx86_off, 0
    lt rx86_pos, 2, rx86_start
    sub rx86_off, rx86_pos, 1
    substr rx86_tgt, rx86_tgt, rx86_off
  rx86_start:
    eq $I10, 1, rx86_restart
    if_null rx86_debug, debug_602
    rx86_cur."!cursor_debug"("START", "identifier")
  debug_602:
    $I10 = self.'from'()
    ne $I10, -1, rxscan90_done
    goto rxscan90_scan
  rxscan90_loop:
    (rx86_pos) = rx86_cur."from"()
    inc rx86_pos
    rx86_cur."!cursor_from"(rx86_pos)
    ge rx86_pos, rx86_eos, rxscan90_done
  rxscan90_scan:
    set_addr $I10, rxscan90_loop
    rx86_cur."!mark_push"(0, rx86_pos, $I10)
  rxscan90_done:
.annotate 'line', 49
  # rx subrule "ident" subtype=method negate=
    rx86_cur."!cursor_pos"(rx86_pos)
    $P10 = rx86_cur."ident"()
    unless $P10, rx86_fail
    rx86_pos = $P10."pos"()
  # rx rxquantr91 ** 0..*
    set_addr $I10, rxquantr91_done
    rx86_cur."!mark_push"(0, rx86_pos, $I10)
  rxquantr91_loop:
  # rx enumcharlist negate=0 
    ge rx86_pos, rx86_eos, rx86_fail
    sub $I10, rx86_pos, rx86_off
    substr $S10, rx86_tgt, $I10, 1
    index $I11, "-'", $S10
    lt $I11, 0, rx86_fail
    inc rx86_pos
  # rx subrule "ident" subtype=method negate=
    rx86_cur."!cursor_pos"(rx86_pos)
    $P10 = rx86_cur."ident"()
    unless $P10, rx86_fail
    rx86_pos = $P10."pos"()
    set_addr $I10, rxquantr91_done
    (rx86_rep) = rx86_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr91_done
    rx86_cur."!mark_push"(rx86_rep, rx86_pos, $I10)
    goto rxquantr91_loop
  rxquantr91_done:
  # rx pass
    rx86_cur."!cursor_pass"(rx86_pos, "identifier")
    if_null rx86_debug, debug_603
    rx86_cur."!cursor_debug"("PASS", "identifier", " at pos=", rx86_pos)
  debug_603:
    .return (rx86_cur)
  rx86_restart:
.annotate 'line', 10
    if_null rx86_debug, debug_604
    rx86_cur."!cursor_debug"("NEXT", "identifier")
  debug_604:
  rx86_fail:
    (rx86_rep, rx86_pos, $I10, $P10) = rx86_cur."!mark_fail"(0)
    lt rx86_pos, -1, rx86_done
    eq rx86_pos, -1, rx86_fail
    jump $I10
  rx86_done:
    rx86_cur."!cursor_fail"()
    if_null rx86_debug, debug_605
    rx86_cur."!cursor_debug"("FAIL", "identifier")
  debug_605:
    .return (rx86_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__identifier"  :nsentry("!PREFIX__identifier") :subid("15_1302110486.758") :method
.annotate 'line', 10
    $P88 = self."!PREFIX__!subrule"("ident", "")
    new $P89, "ResizablePMCArray"
    push $P89, $P88
    .return ($P89)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "name"  :subid("16_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx93_tgt
    .local int rx93_pos
    .local int rx93_off
    .local int rx93_eos
    .local int rx93_rep
    .local pmc rx93_cur
    .local pmc rx93_debug
    (rx93_cur, rx93_pos, rx93_tgt, $I10) = self."!cursor_start"()
    rx93_cur."!cursor_caparray"("identifier")
    .lex unicode:"$\x{a2}", rx93_cur
    .local pmc match
    .lex "$/", match
    length rx93_eos, rx93_tgt
    gt rx93_pos, rx93_eos, rx93_done
    set rx93_off, 0
    lt rx93_pos, 2, rx93_start
    sub rx93_off, rx93_pos, 1
    substr rx93_tgt, rx93_tgt, rx93_off
  rx93_start:
    eq $I10, 1, rx93_restart
    if_null rx93_debug, debug_606
    rx93_cur."!cursor_debug"("START", "name")
  debug_606:
    $I10 = self.'from'()
    ne $I10, -1, rxscan96_done
    goto rxscan96_scan
  rxscan96_loop:
    (rx93_pos) = rx93_cur."from"()
    inc rx93_pos
    rx93_cur."!cursor_from"(rx93_pos)
    ge rx93_pos, rx93_eos, rxscan96_done
  rxscan96_scan:
    set_addr $I10, rxscan96_loop
    rx93_cur."!mark_push"(0, rx93_pos, $I10)
  rxscan96_done:
.annotate 'line', 51
  # rx rxquantr97 ** 1..*
    set_addr $I10, rxquantr97_done
    rx93_cur."!mark_push"(0, -1, $I10)
  rxquantr97_loop:
  # rx subrule "identifier" subtype=capture negate=
    rx93_cur."!cursor_pos"(rx93_pos)
    $P10 = rx93_cur."identifier"()
    unless $P10, rx93_fail
    goto rxsubrule98_pass
  rxsubrule98_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx93_fail
  rxsubrule98_pass:
    set_addr $I10, rxsubrule98_back
    rx93_cur."!mark_push"(0, rx93_pos, $I10, $P10)
    $P10."!cursor_names"("identifier")
    rx93_pos = $P10."pos"()
    set_addr $I10, rxquantr97_done
    (rx93_rep) = rx93_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr97_done
    rx93_cur."!mark_push"(rx93_rep, rx93_pos, $I10)
  # rx literal  "::"
    add $I11, rx93_pos, 2
    gt $I11, rx93_eos, rx93_fail
    sub $I11, rx93_pos, rx93_off
    substr $S10, rx93_tgt, $I11, 2
    ne $S10, "::", rx93_fail
    add rx93_pos, 2
    goto rxquantr97_loop
  rxquantr97_done:
  # rx pass
    rx93_cur."!cursor_pass"(rx93_pos, "name")
    if_null rx93_debug, debug_607
    rx93_cur."!cursor_debug"("PASS", "name", " at pos=", rx93_pos)
  debug_607:
    .return (rx93_cur)
  rx93_restart:
.annotate 'line', 10
    if_null rx93_debug, debug_608
    rx93_cur."!cursor_debug"("NEXT", "name")
  debug_608:
  rx93_fail:
    (rx93_rep, rx93_pos, $I10, $P10) = rx93_cur."!mark_fail"(0)
    lt rx93_pos, -1, rx93_done
    eq rx93_pos, -1, rx93_fail
    jump $I10
  rx93_done:
    rx93_cur."!cursor_fail"()
    if_null rx93_debug, debug_609
    rx93_cur."!cursor_debug"("FAIL", "name")
  debug_609:
    .return (rx93_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__name"  :nsentry("!PREFIX__name") :subid("17_1302110486.758") :method
.annotate 'line', 10
    new $P95, "ResizablePMCArray"
    push $P95, ""
    .return ($P95)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "deflongname"  :subid("18_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx100_tgt
    .local int rx100_pos
    .local int rx100_off
    .local int rx100_eos
    .local int rx100_rep
    .local pmc rx100_cur
    .local pmc rx100_debug
    (rx100_cur, rx100_pos, rx100_tgt, $I10) = self."!cursor_start"()
    rx100_cur."!cursor_caparray"("colonpair")
    .lex unicode:"$\x{a2}", rx100_cur
    .local pmc match
    .lex "$/", match
    length rx100_eos, rx100_tgt
    gt rx100_pos, rx100_eos, rx100_done
    set rx100_off, 0
    lt rx100_pos, 2, rx100_start
    sub rx100_off, rx100_pos, 1
    substr rx100_tgt, rx100_tgt, rx100_off
  rx100_start:
    eq $I10, 1, rx100_restart
    if_null rx100_debug, debug_610
    rx100_cur."!cursor_debug"("START", "deflongname")
  debug_610:
    $I10 = self.'from'()
    ne $I10, -1, rxscan104_done
    goto rxscan104_scan
  rxscan104_loop:
    (rx100_pos) = rx100_cur."from"()
    inc rx100_pos
    rx100_cur."!cursor_from"(rx100_pos)
    ge rx100_pos, rx100_eos, rxscan104_done
  rxscan104_scan:
    set_addr $I10, rxscan104_loop
    rx100_cur."!mark_push"(0, rx100_pos, $I10)
  rxscan104_done:
.annotate 'line', 54
  # rx subrule "identifier" subtype=capture negate=
    rx100_cur."!cursor_pos"(rx100_pos)
    $P10 = rx100_cur."identifier"()
    unless $P10, rx100_fail
    rx100_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx100_pos = $P10."pos"()
  # rx rxquantr105 ** 0..1
    set_addr $I10, rxquantr105_done
    rx100_cur."!mark_push"(0, rx100_pos, $I10)
  rxquantr105_loop:
  # rx subrule "colonpair" subtype=capture negate=
    rx100_cur."!cursor_pos"(rx100_pos)
    $P10 = rx100_cur."colonpair"()
    unless $P10, rx100_fail
    goto rxsubrule106_pass
  rxsubrule106_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx100_fail
  rxsubrule106_pass:
    set_addr $I10, rxsubrule106_back
    rx100_cur."!mark_push"(0, rx100_pos, $I10, $P10)
    $P10."!cursor_names"("colonpair")
    rx100_pos = $P10."pos"()
    set_addr $I10, rxquantr105_done
    (rx100_rep) = rx100_cur."!mark_commit"($I10)
  rxquantr105_done:
.annotate 'line', 53
  # rx pass
    rx100_cur."!cursor_pass"(rx100_pos, "deflongname")
    if_null rx100_debug, debug_611
    rx100_cur."!cursor_debug"("PASS", "deflongname", " at pos=", rx100_pos)
  debug_611:
    .return (rx100_cur)
  rx100_restart:
.annotate 'line', 10
    if_null rx100_debug, debug_612
    rx100_cur."!cursor_debug"("NEXT", "deflongname")
  debug_612:
  rx100_fail:
    (rx100_rep, rx100_pos, $I10, $P10) = rx100_cur."!mark_fail"(0)
    lt rx100_pos, -1, rx100_done
    eq rx100_pos, -1, rx100_fail
    jump $I10
  rx100_done:
    rx100_cur."!cursor_fail"()
    if_null rx100_debug, debug_613
    rx100_cur."!cursor_debug"("FAIL", "deflongname")
  debug_613:
    .return (rx100_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__deflongname"  :nsentry("!PREFIX__deflongname") :subid("19_1302110486.758") :method
.annotate 'line', 10
    $P102 = self."!PREFIX__!subrule"("identifier", "")
    new $P103, "ResizablePMCArray"
    push $P103, $P102
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ENDSTMT"  :subid("20_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx108_tgt
    .local int rx108_pos
    .local int rx108_off
    .local int rx108_eos
    .local int rx108_rep
    .local pmc rx108_cur
    .local pmc rx108_debug
    (rx108_cur, rx108_pos, rx108_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx108_cur
    .local pmc match
    .lex "$/", match
    length rx108_eos, rx108_tgt
    gt rx108_pos, rx108_eos, rx108_done
    set rx108_off, 0
    lt rx108_pos, 2, rx108_start
    sub rx108_off, rx108_pos, 1
    substr rx108_tgt, rx108_tgt, rx108_off
  rx108_start:
    eq $I10, 1, rx108_restart
    if_null rx108_debug, debug_614
    rx108_cur."!cursor_debug"("START", "ENDSTMT")
  debug_614:
    $I10 = self.'from'()
    ne $I10, -1, rxscan111_done
    goto rxscan111_scan
  rxscan111_loop:
    (rx108_pos) = rx108_cur."from"()
    inc rx108_pos
    rx108_cur."!cursor_from"(rx108_pos)
    ge rx108_pos, rx108_eos, rxscan111_done
  rxscan111_scan:
    set_addr $I10, rxscan111_loop
    rx108_cur."!mark_push"(0, rx108_pos, $I10)
  rxscan111_done:
.annotate 'line', 61
  # rx rxquantr112 ** 0..1
    set_addr $I10, rxquantr112_done
    rx108_cur."!mark_push"(0, rx108_pos, $I10)
  rxquantr112_loop:
  alt113_0:
.annotate 'line', 58
    set_addr $I10, alt113_1
    rx108_cur."!mark_push"(0, rx108_pos, $I10)
.annotate 'line', 59
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx108_pos, rx108_off
    set rx108_rep, 0
    sub $I12, rx108_eos, rx108_pos
  rxenumcharlistq114_loop:
    le $I12, 0, rxenumcharlistq114_done
    substr $S10, rx108_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq114_done
    inc rx108_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq114_loop
  rxenumcharlistq114_done:
    add rx108_pos, rx108_pos, rx108_rep
  # rxanchor eol
    sub $I10, rx108_pos, rx108_off
    is_cclass $I11, 4096, rx108_tgt, $I10
    if $I11, rxanchor115_done
    ne rx108_pos, rx108_eos, rx108_fail
    eq rx108_pos, 0, rxanchor115_done
    dec $I10
    is_cclass $I11, 4096, rx108_tgt, $I10
    if $I11, rx108_fail
  rxanchor115_done:
  # rx subrule "ws" subtype=method negate=
    rx108_cur."!cursor_pos"(rx108_pos)
    $P10 = rx108_cur."ws"()
    unless $P10, rx108_fail
    rx108_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx108_cur."!cursor_pos"(rx108_pos)
    $P10 = rx108_cur."MARKER"("endstmt")
    unless $P10, rx108_fail
    goto alt113_end
  alt113_1:
.annotate 'line', 60
  # rx rxquantr116 ** 0..1
    set_addr $I10, rxquantr116_done
    rx108_cur."!mark_push"(0, rx108_pos, $I10)
  rxquantr116_loop:
  # rx subrule "unv" subtype=method negate=
    rx108_cur."!cursor_pos"(rx108_pos)
    $P10 = rx108_cur."unv"()
    unless $P10, rx108_fail
    goto rxsubrule117_pass
  rxsubrule117_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx108_fail
  rxsubrule117_pass:
    set_addr $I10, rxsubrule117_back
    rx108_cur."!mark_push"(0, rx108_pos, $I10, $P10)
    rx108_pos = $P10."pos"()
    set_addr $I10, rxquantr116_done
    (rx108_rep) = rx108_cur."!mark_commit"($I10)
  rxquantr116_done:
  # rxanchor eol
    sub $I10, rx108_pos, rx108_off
    is_cclass $I11, 4096, rx108_tgt, $I10
    if $I11, rxanchor118_done
    ne rx108_pos, rx108_eos, rx108_fail
    eq rx108_pos, 0, rxanchor118_done
    dec $I10
    is_cclass $I11, 4096, rx108_tgt, $I10
    if $I11, rx108_fail
  rxanchor118_done:
  # rx subrule "ws" subtype=method negate=
    rx108_cur."!cursor_pos"(rx108_pos)
    $P10 = rx108_cur."ws"()
    unless $P10, rx108_fail
    rx108_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx108_cur."!cursor_pos"(rx108_pos)
    $P10 = rx108_cur."MARKER"("endstmt")
    unless $P10, rx108_fail
  alt113_end:
.annotate 'line', 61
    set_addr $I10, rxquantr112_done
    (rx108_rep) = rx108_cur."!mark_commit"($I10)
  rxquantr112_done:
.annotate 'line', 57
  # rx pass
    rx108_cur."!cursor_pass"(rx108_pos, "ENDSTMT")
    if_null rx108_debug, debug_615
    rx108_cur."!cursor_debug"("PASS", "ENDSTMT", " at pos=", rx108_pos)
  debug_615:
    .return (rx108_cur)
  rx108_restart:
.annotate 'line', 10
    if_null rx108_debug, debug_616
    rx108_cur."!cursor_debug"("NEXT", "ENDSTMT")
  debug_616:
  rx108_fail:
    (rx108_rep, rx108_pos, $I10, $P10) = rx108_cur."!mark_fail"(0)
    lt rx108_pos, -1, rx108_done
    eq rx108_pos, -1, rx108_fail
    jump $I10
  rx108_done:
    rx108_cur."!cursor_fail"()
    if_null rx108_debug, debug_617
    rx108_cur."!cursor_debug"("FAIL", "ENDSTMT")
  debug_617:
    .return (rx108_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ENDSTMT"  :nsentry("!PREFIX__ENDSTMT") :subid("21_1302110486.758") :method
.annotate 'line', 10
    new $P110, "ResizablePMCArray"
    push $P110, ""
    .return ($P110)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ws"  :subid("22_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx120_tgt
    .local int rx120_pos
    .local int rx120_off
    .local int rx120_eos
    .local int rx120_rep
    .local pmc rx120_cur
    .local pmc rx120_debug
    (rx120_cur, rx120_pos, rx120_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx120_cur
    .local pmc match
    .lex "$/", match
    length rx120_eos, rx120_tgt
    gt rx120_pos, rx120_eos, rx120_done
    set rx120_off, 0
    lt rx120_pos, 2, rx120_start
    sub rx120_off, rx120_pos, 1
    substr rx120_tgt, rx120_tgt, rx120_off
  rx120_start:
    eq $I10, 1, rx120_restart
    if_null rx120_debug, debug_618
    rx120_cur."!cursor_debug"("START", "ws")
  debug_618:
    $I10 = self.'from'()
    ne $I10, -1, rxscan123_done
    goto rxscan123_scan
  rxscan123_loop:
    (rx120_pos) = rx120_cur."from"()
    inc rx120_pos
    rx120_cur."!cursor_from"(rx120_pos)
    ge rx120_pos, rx120_eos, rxscan123_done
  rxscan123_scan:
    set_addr $I10, rxscan123_loop
    rx120_cur."!mark_push"(0, rx120_pos, $I10)
  rxscan123_done:
  alt124_0:
.annotate 'line', 64
    set_addr $I10, alt124_1
    rx120_cur."!mark_push"(0, rx120_pos, $I10)
.annotate 'line', 65
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx120_cur."!cursor_pos"(rx120_pos)
    $P10 = rx120_cur."MARKED"("ws")
    unless $P10, rx120_fail
    goto alt124_end
  alt124_1:
.annotate 'line', 66
  # rx subrule "ww" subtype=zerowidth negate=1
    rx120_cur."!cursor_pos"(rx120_pos)
    $P10 = rx120_cur."ww"()
    if $P10, rx120_fail
.annotate 'line', 71
  # rx rxquantr125 ** 0..*
    set_addr $I10, rxquantr125_done
    rx120_cur."!mark_push"(0, rx120_pos, $I10)
  rxquantr125_loop:
  alt126_0:
.annotate 'line', 67
    set_addr $I10, alt126_1
    rx120_cur."!mark_push"(0, rx120_pos, $I10)
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx120_pos, rx120_off
    set rx120_rep, 0
    sub $I12, rx120_eos, rx120_pos
  rxenumcharlistq127_loop:
    le $I12, 0, rxenumcharlistq127_done
    substr $S10, rx120_tgt, $I10, 1
    index $I11, unicode:"\n\x{b}\f\r\x{85}\u2028\u2029", $S10
    lt $I11, 0, rxenumcharlistq127_done
    inc rx120_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq127_loop
  rxenumcharlistq127_done:
    lt rx120_rep, 1, rx120_fail
    add rx120_pos, rx120_pos, rx120_rep
    goto alt126_end
  alt126_1:
    set_addr $I10, alt126_2
    rx120_cur."!mark_push"(0, rx120_pos, $I10)
.annotate 'line', 68
  # rx literal  "#"
    add $I11, rx120_pos, 1
    gt $I11, rx120_eos, rx120_fail
    sub $I11, rx120_pos, rx120_off
    ord $I11, rx120_tgt, $I11
    ne $I11, 35, rx120_fail
    add rx120_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx120_pos, rx120_off
    find_cclass $I11, 4096, rx120_tgt, $I10, rx120_eos
    add rx120_pos, rx120_off, $I11
    goto alt126_end
  alt126_2:
    set_addr $I10, alt126_3
    rx120_cur."!mark_push"(0, rx120_pos, $I10)
.annotate 'line', 69
  # rxanchor bol
    eq rx120_pos, 0, rxanchor128_done
    ge rx120_pos, rx120_eos, rx120_fail
    sub $I10, rx120_pos, rx120_off
    dec $I10
    is_cclass $I11, 4096, rx120_tgt, $I10
    unless $I11, rx120_fail
  rxanchor128_done:
  # rx subrule "pod_comment" subtype=method negate=
    rx120_cur."!cursor_pos"(rx120_pos)
    $P10 = rx120_cur."pod_comment"()
    unless $P10, rx120_fail
    rx120_pos = $P10."pos"()
    goto alt126_end
  alt126_3:
.annotate 'line', 70
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx120_pos, rx120_off
    set rx120_rep, 0
    sub $I12, rx120_eos, rx120_pos
  rxenumcharlistq129_loop:
    le $I12, 0, rxenumcharlistq129_done
    substr $S10, rx120_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq129_done
    inc rx120_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq129_loop
  rxenumcharlistq129_done:
    lt rx120_rep, 1, rx120_fail
    add rx120_pos, rx120_pos, rx120_rep
  alt126_end:
.annotate 'line', 71
    set_addr $I10, rxquantr125_done
    (rx120_rep) = rx120_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr125_done
    rx120_cur."!mark_push"(rx120_rep, rx120_pos, $I10)
    goto rxquantr125_loop
  rxquantr125_done:
.annotate 'line', 72
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx120_cur."!cursor_pos"(rx120_pos)
    $P10 = rx120_cur."MARKER"("ws")
    unless $P10, rx120_fail
  alt124_end:
.annotate 'line', 64
  # rx pass
    rx120_cur."!cursor_pass"(rx120_pos, "ws")
    if_null rx120_debug, debug_619
    rx120_cur."!cursor_debug"("PASS", "ws", " at pos=", rx120_pos)
  debug_619:
    .return (rx120_cur)
  rx120_restart:
.annotate 'line', 10
    if_null rx120_debug, debug_620
    rx120_cur."!cursor_debug"("NEXT", "ws")
  debug_620:
  rx120_fail:
    (rx120_rep, rx120_pos, $I10, $P10) = rx120_cur."!mark_fail"(0)
    lt rx120_pos, -1, rx120_done
    eq rx120_pos, -1, rx120_fail
    jump $I10
  rx120_done:
    rx120_cur."!cursor_fail"()
    if_null rx120_debug, debug_621
    rx120_cur."!cursor_debug"("FAIL", "ws")
  debug_621:
    .return (rx120_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ws"  :nsentry("!PREFIX__ws") :subid("23_1302110486.758") :method
.annotate 'line', 10
    new $P122, "ResizablePMCArray"
    push $P122, ""
    push $P122, ""
    .return ($P122)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "unv"  :subid("24_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .const 'Sub' $P138 = "26_1302110486.758" 
    capture_lex $P138
    .local string rx131_tgt
    .local int rx131_pos
    .local int rx131_off
    .local int rx131_eos
    .local int rx131_rep
    .local pmc rx131_cur
    .local pmc rx131_debug
    (rx131_cur, rx131_pos, rx131_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx131_cur
    .local pmc match
    .lex "$/", match
    length rx131_eos, rx131_tgt
    gt rx131_pos, rx131_eos, rx131_done
    set rx131_off, 0
    lt rx131_pos, 2, rx131_start
    sub rx131_off, rx131_pos, 1
    substr rx131_tgt, rx131_tgt, rx131_off
  rx131_start:
    eq $I10, 1, rx131_restart
    if_null rx131_debug, debug_622
    rx131_cur."!cursor_debug"("START", "unv")
  debug_622:
    $I10 = self.'from'()
    ne $I10, -1, rxscan134_done
    goto rxscan134_scan
  rxscan134_loop:
    (rx131_pos) = rx131_cur."from"()
    inc rx131_pos
    rx131_cur."!cursor_from"(rx131_pos)
    ge rx131_pos, rx131_eos, rxscan134_done
  rxscan134_scan:
    set_addr $I10, rxscan134_loop
    rx131_cur."!mark_push"(0, rx131_pos, $I10)
  rxscan134_done:
  alt135_0:
.annotate 'line', 77
    set_addr $I10, alt135_1
    rx131_cur."!mark_push"(0, rx131_pos, $I10)
.annotate 'line', 78
  # rxanchor bol
    eq rx131_pos, 0, rxanchor136_done
    ge rx131_pos, rx131_eos, rx131_fail
    sub $I10, rx131_pos, rx131_off
    dec $I10
    is_cclass $I11, 4096, rx131_tgt, $I10
    unless $I11, rx131_fail
  rxanchor136_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx131_cur."!cursor_pos"(rx131_pos)
    .const 'Sub' $P138 = "26_1302110486.758" 
    capture_lex $P138
    $P10 = rx131_cur."before"($P138)
    unless $P10, rx131_fail
  # rx subrule "pod_comment" subtype=method negate=
    rx131_cur."!cursor_pos"(rx131_pos)
    $P10 = rx131_cur."pod_comment"()
    unless $P10, rx131_fail
    rx131_pos = $P10."pos"()
    goto alt135_end
  alt135_1:
    set_addr $I10, alt135_2
    rx131_cur."!mark_push"(0, rx131_pos, $I10)
.annotate 'line', 79
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx131_pos, rx131_off
    set rx131_rep, 0
    sub $I12, rx131_eos, rx131_pos
  rxenumcharlistq143_loop:
    le $I12, 0, rxenumcharlistq143_done
    substr $S10, rx131_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq143_done
    inc rx131_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq143_loop
  rxenumcharlistq143_done:
    add rx131_pos, rx131_pos, rx131_rep
  # rx literal  "#"
    add $I11, rx131_pos, 1
    gt $I11, rx131_eos, rx131_fail
    sub $I11, rx131_pos, rx131_off
    ord $I11, rx131_tgt, $I11
    ne $I11, 35, rx131_fail
    add rx131_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx131_pos, rx131_off
    find_cclass $I11, 4096, rx131_tgt, $I10, rx131_eos
    add rx131_pos, rx131_off, $I11
    goto alt135_end
  alt135_2:
.annotate 'line', 80
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx131_pos, rx131_off
    set rx131_rep, 0
    sub $I12, rx131_eos, rx131_pos
  rxenumcharlistq144_loop:
    le $I12, 0, rxenumcharlistq144_done
    substr $S10, rx131_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq144_done
    inc rx131_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq144_loop
  rxenumcharlistq144_done:
    lt rx131_rep, 1, rx131_fail
    add rx131_pos, rx131_pos, rx131_rep
  alt135_end:
.annotate 'line', 75
  # rx pass
    rx131_cur."!cursor_pass"(rx131_pos, "unv")
    if_null rx131_debug, debug_627
    rx131_cur."!cursor_debug"("PASS", "unv", " at pos=", rx131_pos)
  debug_627:
    .return (rx131_cur)
  rx131_restart:
.annotate 'line', 10
    if_null rx131_debug, debug_628
    rx131_cur."!cursor_debug"("NEXT", "unv")
  debug_628:
  rx131_fail:
    (rx131_rep, rx131_pos, $I10, $P10) = rx131_cur."!mark_fail"(0)
    lt rx131_pos, -1, rx131_done
    eq rx131_pos, -1, rx131_fail
    jump $I10
  rx131_done:
    rx131_cur."!cursor_fail"()
    if_null rx131_debug, debug_629
    rx131_cur."!cursor_debug"("FAIL", "unv")
  debug_629:
    .return (rx131_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__unv"  :nsentry("!PREFIX__unv") :subid("25_1302110486.758") :method
.annotate 'line', 10
    new $P133, "ResizablePMCArray"
    push $P133, ""
    push $P133, ""
    push $P133, ""
    .return ($P133)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block137"  :anon :subid("26_1302110486.758") :method :outer("24_1302110486.758")
.annotate 'line', 78
    .local string rx139_tgt
    .local int rx139_pos
    .local int rx139_off
    .local int rx139_eos
    .local int rx139_rep
    .local pmc rx139_cur
    .local pmc rx139_debug
    (rx139_cur, rx139_pos, rx139_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx139_cur
    .local pmc match
    .lex "$/", match
    length rx139_eos, rx139_tgt
    gt rx139_pos, rx139_eos, rx139_done
    set rx139_off, 0
    lt rx139_pos, 2, rx139_start
    sub rx139_off, rx139_pos, 1
    substr rx139_tgt, rx139_tgt, rx139_off
  rx139_start:
    eq $I10, 1, rx139_restart
    if_null rx139_debug, debug_623
    rx139_cur."!cursor_debug"("START", "")
  debug_623:
    $I10 = self.'from'()
    ne $I10, -1, rxscan140_done
    goto rxscan140_scan
  rxscan140_loop:
    (rx139_pos) = rx139_cur."from"()
    inc rx139_pos
    rx139_cur."!cursor_from"(rx139_pos)
    ge rx139_pos, rx139_eos, rxscan140_done
  rxscan140_scan:
    set_addr $I10, rxscan140_loop
    rx139_cur."!mark_push"(0, rx139_pos, $I10)
  rxscan140_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx139_pos, rx139_off
    set rx139_rep, 0
    sub $I12, rx139_eos, rx139_pos
  rxenumcharlistq141_loop:
    le $I12, 0, rxenumcharlistq141_done
    substr $S10, rx139_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq141_done
    inc rx139_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq141_loop
  rxenumcharlistq141_done:
    add rx139_pos, rx139_pos, rx139_rep
  # rx literal  "="
    add $I11, rx139_pos, 1
    gt $I11, rx139_eos, rx139_fail
    sub $I11, rx139_pos, rx139_off
    ord $I11, rx139_tgt, $I11
    ne $I11, 61, rx139_fail
    add rx139_pos, 1
  alt142_0:
    set_addr $I10, alt142_1
    rx139_cur."!mark_push"(0, rx139_pos, $I10)
  # rx charclass w
    ge rx139_pos, rx139_eos, rx139_fail
    sub $I10, rx139_pos, rx139_off
    is_cclass $I11, 8192, rx139_tgt, $I10
    unless $I11, rx139_fail
    inc rx139_pos
    goto alt142_end
  alt142_1:
  # rx literal  "\\"
    add $I11, rx139_pos, 1
    gt $I11, rx139_eos, rx139_fail
    sub $I11, rx139_pos, rx139_off
    ord $I11, rx139_tgt, $I11
    ne $I11, 92, rx139_fail
    add rx139_pos, 1
  alt142_end:
  # rx pass
    rx139_cur."!cursor_pass"(rx139_pos, "")
    if_null rx139_debug, debug_624
    rx139_cur."!cursor_debug"("PASS", "", " at pos=", rx139_pos)
  debug_624:
    .return (rx139_cur)
  rx139_restart:
    if_null rx139_debug, debug_625
    rx139_cur."!cursor_debug"("NEXT", "")
  debug_625:
  rx139_fail:
    (rx139_rep, rx139_pos, $I10, $P10) = rx139_cur."!mark_fail"(0)
    lt rx139_pos, -1, rx139_done
    eq rx139_pos, -1, rx139_fail
    jump $I10
  rx139_done:
    rx139_cur."!cursor_fail"()
    if_null rx139_debug, debug_626
    rx139_cur."!cursor_debug"("FAIL", "")
  debug_626:
    .return (rx139_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pod_comment"  :subid("27_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .const 'Sub' $P177 = "29_1302110486.758" 
    capture_lex $P177
    .local string rx146_tgt
    .local int rx146_pos
    .local int rx146_off
    .local int rx146_eos
    .local int rx146_rep
    .local pmc rx146_cur
    .local pmc rx146_debug
    (rx146_cur, rx146_pos, rx146_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx146_cur
    .local pmc match
    .lex "$/", match
    length rx146_eos, rx146_tgt
    gt rx146_pos, rx146_eos, rx146_done
    set rx146_off, 0
    lt rx146_pos, 2, rx146_start
    sub rx146_off, rx146_pos, 1
    substr rx146_tgt, rx146_tgt, rx146_off
  rx146_start:
    eq $I10, 1, rx146_restart
    if_null rx146_debug, debug_630
    rx146_cur."!cursor_debug"("START", "pod_comment")
  debug_630:
    $I10 = self.'from'()
    ne $I10, -1, rxscan149_done
    goto rxscan149_scan
  rxscan149_loop:
    (rx146_pos) = rx146_cur."from"()
    inc rx146_pos
    rx146_cur."!cursor_from"(rx146_pos)
    ge rx146_pos, rx146_eos, rxscan149_done
  rxscan149_scan:
    set_addr $I10, rxscan149_loop
    rx146_cur."!mark_push"(0, rx146_pos, $I10)
  rxscan149_done:
.annotate 'line', 85
  # rxanchor bol
    eq rx146_pos, 0, rxanchor150_done
    ge rx146_pos, rx146_eos, rx146_fail
    sub $I10, rx146_pos, rx146_off
    dec $I10
    is_cclass $I11, 4096, rx146_tgt, $I10
    unless $I11, rx146_fail
  rxanchor150_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx146_pos, rx146_off
    set rx146_rep, 0
    sub $I12, rx146_eos, rx146_pos
  rxenumcharlistq151_loop:
    le $I12, 0, rxenumcharlistq151_done
    substr $S10, rx146_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq151_done
    inc rx146_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq151_loop
  rxenumcharlistq151_done:
    add rx146_pos, rx146_pos, rx146_rep
  # rx literal  "="
    add $I11, rx146_pos, 1
    gt $I11, rx146_eos, rx146_fail
    sub $I11, rx146_pos, rx146_off
    ord $I11, rx146_tgt, $I11
    ne $I11, 61, rx146_fail
    add rx146_pos, 1
  alt152_0:
.annotate 'line', 86
    set_addr $I10, alt152_1
    rx146_cur."!mark_push"(0, rx146_pos, $I10)
.annotate 'line', 87
  # rx literal  "begin"
    add $I11, rx146_pos, 5
    gt $I11, rx146_eos, rx146_fail
    sub $I11, rx146_pos, rx146_off
    substr $S10, rx146_tgt, $I11, 5
    ne $S10, "begin", rx146_fail
    add rx146_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx146_pos, rx146_off
    set rx146_rep, 0
    sub $I12, rx146_eos, rx146_pos
  rxenumcharlistq153_loop:
    le $I12, 0, rxenumcharlistq153_done
    substr $S10, rx146_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq153_done
    inc rx146_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq153_loop
  rxenumcharlistq153_done:
    lt rx146_rep, 1, rx146_fail
    add rx146_pos, rx146_pos, rx146_rep
  # rx literal  "END"
    add $I11, rx146_pos, 3
    gt $I11, rx146_eos, rx146_fail
    sub $I11, rx146_pos, rx146_off
    substr $S10, rx146_tgt, $I11, 3
    ne $S10, "END", rx146_fail
    add rx146_pos, 3
  # rxanchor rwb
    le rx146_pos, 0, rx146_fail
    sub $I10, rx146_pos, rx146_off
    is_cclass $I11, 8192, rx146_tgt, $I10
    if $I11, rx146_fail
    dec $I10
    is_cclass $I11, 8192, rx146_tgt, $I10
    unless $I11, rx146_fail
  alt154_0:
.annotate 'line', 88
    set_addr $I10, alt154_1
    rx146_cur."!mark_push"(0, rx146_pos, $I10)
  # rx rxquantf155 ** 0..*
    set_addr $I10, rxquantf155_loop
    rx146_cur."!mark_push"(0, rx146_pos, $I10)
    goto rxquantf155_done
  rxquantf155_loop:
  # rx charclass .
    ge rx146_pos, rx146_eos, rx146_fail
    inc rx146_pos
    set_addr $I10, rxquantf155_loop
    rx146_cur."!mark_push"(rx146_rep, rx146_pos, $I10)
  rxquantf155_done:
  # rx charclass nl
    ge rx146_pos, rx146_eos, rx146_fail
    sub $I10, rx146_pos, rx146_off
    is_cclass $I11, 4096, rx146_tgt, $I10
    unless $I11, rx146_fail
    substr $S10, rx146_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx146_pos, $I11
    inc rx146_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx146_pos, rx146_off
    set rx146_rep, 0
    sub $I12, rx146_eos, rx146_pos
  rxenumcharlistq157_loop:
    le $I12, 0, rxenumcharlistq157_done
    substr $S10, rx146_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq157_done
    inc rx146_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq157_loop
  rxenumcharlistq157_done:
    add rx146_pos, rx146_pos, rx146_rep
  # rx literal  "=end"
    add $I11, rx146_pos, 4
    gt $I11, rx146_eos, rx146_fail
    sub $I11, rx146_pos, rx146_off
    substr $S10, rx146_tgt, $I11, 4
    ne $S10, "=end", rx146_fail
    add rx146_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx146_pos, rx146_off
    set rx146_rep, 0
    sub $I12, rx146_eos, rx146_pos
  rxenumcharlistq158_loop:
    le $I12, 0, rxenumcharlistq158_done
    substr $S10, rx146_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq158_done
    inc rx146_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq158_loop
  rxenumcharlistq158_done:
    lt rx146_rep, 1, rx146_fail
    add rx146_pos, rx146_pos, rx146_rep
  # rx literal  "END"
    add $I11, rx146_pos, 3
    gt $I11, rx146_eos, rx146_fail
    sub $I11, rx146_pos, rx146_off
    substr $S10, rx146_tgt, $I11, 3
    ne $S10, "END", rx146_fail
    add rx146_pos, 3
  # rxanchor rwb
    le rx146_pos, 0, rx146_fail
    sub $I10, rx146_pos, rx146_off
    is_cclass $I11, 8192, rx146_tgt, $I10
    if $I11, rx146_fail
    dec $I10
    is_cclass $I11, 8192, rx146_tgt, $I10
    unless $I11, rx146_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx146_pos, rx146_off
    find_cclass $I11, 4096, rx146_tgt, $I10, rx146_eos
    add rx146_pos, rx146_off, $I11
    goto alt154_end
  alt154_1:
  # rx charclass_q . r 0..-1
    sub $I10, rx146_pos, rx146_off
    find_not_cclass $I11, 65535, rx146_tgt, $I10, rx146_eos
    add rx146_pos, rx146_off, $I11
  alt154_end:
.annotate 'line', 87
    goto alt152_end
  alt152_1:
    set_addr $I10, alt152_2
    rx146_cur."!mark_push"(0, rx146_pos, $I10)
.annotate 'line', 89
  # rx literal  "begin"
    add $I11, rx146_pos, 5
    gt $I11, rx146_eos, rx146_fail
    sub $I11, rx146_pos, rx146_off
    substr $S10, rx146_tgt, $I11, 5
    ne $S10, "begin", rx146_fail
    add rx146_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx146_pos, rx146_off
    set rx146_rep, 0
    sub $I12, rx146_eos, rx146_pos
  rxenumcharlistq159_loop:
    le $I12, 0, rxenumcharlistq159_done
    substr $S10, rx146_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq159_done
    inc rx146_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq159_loop
  rxenumcharlistq159_done:
    lt rx146_rep, 1, rx146_fail
    add rx146_pos, rx146_pos, rx146_rep
  # rx subrule "identifier" subtype=capture negate=
    rx146_cur."!cursor_pos"(rx146_pos)
    $P10 = rx146_cur."identifier"()
    unless $P10, rx146_fail
    rx146_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx146_pos = $P10."pos"()
  alt160_0:
.annotate 'line', 90
    set_addr $I10, alt160_1
    rx146_cur."!mark_push"(0, rx146_pos, $I10)
.annotate 'line', 91
  # rx rxquantf161 ** 0..*
    set_addr $I10, rxquantf161_loop
    rx146_cur."!mark_push"(0, rx146_pos, $I10)
    goto rxquantf161_done
  rxquantf161_loop:
  # rx charclass .
    ge rx146_pos, rx146_eos, rx146_fail
    inc rx146_pos
    set_addr $I10, rxquantf161_loop
    rx146_cur."!mark_push"(rx146_rep, rx146_pos, $I10)
  rxquantf161_done:
  # rx charclass nl
    ge rx146_pos, rx146_eos, rx146_fail
    sub $I10, rx146_pos, rx146_off
    is_cclass $I11, 4096, rx146_tgt, $I10
    unless $I11, rx146_fail
    substr $S10, rx146_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx146_pos, $I11
    inc rx146_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx146_pos, rx146_off
    set rx146_rep, 0
    sub $I12, rx146_eos, rx146_pos
  rxenumcharlistq163_loop:
    le $I12, 0, rxenumcharlistq163_done
    substr $S10, rx146_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq163_done
    inc rx146_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq163_loop
  rxenumcharlistq163_done:
    add rx146_pos, rx146_pos, rx146_rep
  # rx literal  "=end"
    add $I11, rx146_pos, 4
    gt $I11, rx146_eos, rx146_fail
    sub $I11, rx146_pos, rx146_off
    substr $S10, rx146_tgt, $I11, 4
    ne $S10, "=end", rx146_fail
    add rx146_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx146_pos, rx146_off
    set rx146_rep, 0
    sub $I12, rx146_eos, rx146_pos
  rxenumcharlistq164_loop:
    le $I12, 0, rxenumcharlistq164_done
    substr $S10, rx146_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq164_done
    inc rx146_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq164_loop
  rxenumcharlistq164_done:
    lt rx146_rep, 1, rx146_fail
    add rx146_pos, rx146_pos, rx146_rep
  # rx subrule "!BACKREF" subtype=method negate=
    rx146_cur."!cursor_pos"(rx146_pos)
    $P10 = rx146_cur."!BACKREF"("identifier")
    unless $P10, rx146_fail
    rx146_pos = $P10."pos"()
  # rxanchor rwb
    le rx146_pos, 0, rx146_fail
    sub $I10, rx146_pos, rx146_off
    is_cclass $I11, 8192, rx146_tgt, $I10
    if $I11, rx146_fail
    dec $I10
    is_cclass $I11, 8192, rx146_tgt, $I10
    unless $I11, rx146_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx146_pos, rx146_off
    find_cclass $I11, 4096, rx146_tgt, $I10, rx146_eos
    add rx146_pos, rx146_off, $I11
    goto alt160_end
  alt160_1:
.annotate 'line', 92
  # rx subrule "panic" subtype=method negate=
    rx146_cur."!cursor_pos"(rx146_pos)
    $P10 = rx146_cur."panic"("=begin without matching =end")
    unless $P10, rx146_fail
    rx146_pos = $P10."pos"()
  alt160_end:
.annotate 'line', 89
    goto alt152_end
  alt152_2:
    set_addr $I10, alt152_3
    rx146_cur."!mark_push"(0, rx146_pos, $I10)
.annotate 'line', 94
  # rx literal  "begin"
    add $I11, rx146_pos, 5
    gt $I11, rx146_eos, rx146_fail
    sub $I11, rx146_pos, rx146_off
    substr $S10, rx146_tgt, $I11, 5
    ne $S10, "begin", rx146_fail
    add rx146_pos, 5
  # rxanchor rwb
    le rx146_pos, 0, rx146_fail
    sub $I10, rx146_pos, rx146_off
    is_cclass $I11, 8192, rx146_tgt, $I10
    if $I11, rx146_fail
    dec $I10
    is_cclass $I11, 8192, rx146_tgt, $I10
    unless $I11, rx146_fail
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx146_pos, rx146_off
    set rx146_rep, 0
    sub $I12, rx146_eos, rx146_pos
  rxenumcharlistq166_loop:
    le $I12, 0, rxenumcharlistq166_done
    substr $S10, rx146_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq166_done
    inc rx146_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq166_loop
  rxenumcharlistq166_done:
    add rx146_pos, rx146_pos, rx146_rep
  alt167_0:
.annotate 'line', 95
    set_addr $I10, alt167_1
    rx146_cur."!mark_push"(0, rx146_pos, $I10)
  # rxanchor eol
    sub $I10, rx146_pos, rx146_off
    is_cclass $I11, 4096, rx146_tgt, $I10
    if $I11, rxanchor168_done
    ne rx146_pos, rx146_eos, rx146_fail
    eq rx146_pos, 0, rxanchor168_done
    dec $I10
    is_cclass $I11, 4096, rx146_tgt, $I10
    if $I11, rx146_fail
  rxanchor168_done:
    goto alt167_end
  alt167_1:
    set_addr $I10, alt167_2
    rx146_cur."!mark_push"(0, rx146_pos, $I10)
  # rx literal  "#"
    add $I11, rx146_pos, 1
    gt $I11, rx146_eos, rx146_fail
    sub $I11, rx146_pos, rx146_off
    ord $I11, rx146_tgt, $I11
    ne $I11, 35, rx146_fail
    add rx146_pos, 1
    goto alt167_end
  alt167_2:
  # rx subrule "panic" subtype=method negate=
    rx146_cur."!cursor_pos"(rx146_pos)
    $P10 = rx146_cur."panic"("Unrecognized token after =begin")
    unless $P10, rx146_fail
    rx146_pos = $P10."pos"()
  alt167_end:
  alt169_0:
.annotate 'line', 96
    set_addr $I10, alt169_1
    rx146_cur."!mark_push"(0, rx146_pos, $I10)
.annotate 'line', 97
  # rx rxquantf170 ** 0..*
    set_addr $I10, rxquantf170_loop
    rx146_cur."!mark_push"(0, rx146_pos, $I10)
    goto rxquantf170_done
  rxquantf170_loop:
  # rx charclass .
    ge rx146_pos, rx146_eos, rx146_fail
    inc rx146_pos
    set_addr $I10, rxquantf170_loop
    rx146_cur."!mark_push"(rx146_rep, rx146_pos, $I10)
  rxquantf170_done:
  # rx charclass nl
    ge rx146_pos, rx146_eos, rx146_fail
    sub $I10, rx146_pos, rx146_off
    is_cclass $I11, 4096, rx146_tgt, $I10
    unless $I11, rx146_fail
    substr $S10, rx146_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx146_pos, $I11
    inc rx146_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx146_pos, rx146_off
    set rx146_rep, 0
    sub $I12, rx146_eos, rx146_pos
  rxenumcharlistq172_loop:
    le $I12, 0, rxenumcharlistq172_done
    substr $S10, rx146_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq172_done
    inc rx146_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq172_loop
  rxenumcharlistq172_done:
    add rx146_pos, rx146_pos, rx146_rep
  # rx literal  "=end"
    add $I11, rx146_pos, 4
    gt $I11, rx146_eos, rx146_fail
    sub $I11, rx146_pos, rx146_off
    substr $S10, rx146_tgt, $I11, 4
    ne $S10, "=end", rx146_fail
    add rx146_pos, 4
  # rxanchor rwb
    le rx146_pos, 0, rx146_fail
    sub $I10, rx146_pos, rx146_off
    is_cclass $I11, 8192, rx146_tgt, $I10
    if $I11, rx146_fail
    dec $I10
    is_cclass $I11, 8192, rx146_tgt, $I10
    unless $I11, rx146_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx146_pos, rx146_off
    find_cclass $I11, 4096, rx146_tgt, $I10, rx146_eos
    add rx146_pos, rx146_off, $I11
    goto alt169_end
  alt169_1:
.annotate 'line', 98
  # rx subrule "panic" subtype=method negate=
    rx146_cur."!cursor_pos"(rx146_pos)
    $P10 = rx146_cur."panic"("=begin without matching =end")
    unless $P10, rx146_fail
    rx146_pos = $P10."pos"()
  alt169_end:
.annotate 'line', 94
    goto alt152_end
  alt152_3:
    set_addr $I10, alt152_4
    rx146_cur."!mark_push"(0, rx146_pos, $I10)
.annotate 'line', 100
  # rx subrule "identifier" subtype=capture negate=
    rx146_cur."!cursor_pos"(rx146_pos)
    $P10 = rx146_cur."identifier"()
    unless $P10, rx146_fail
    rx146_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx146_pos = $P10."pos"()
.annotate 'line', 101
  # rx rxquantf173 ** 0..*
    set_addr $I10, rxquantf173_loop
    rx146_cur."!mark_push"(0, rx146_pos, $I10)
    goto rxquantf173_done
  rxquantf173_loop:
  # rx charclass .
    ge rx146_pos, rx146_eos, rx146_fail
    inc rx146_pos
    set_addr $I10, rxquantf173_loop
    rx146_cur."!mark_push"(rx146_rep, rx146_pos, $I10)
  rxquantf173_done:
  # rxanchor bol
    eq rx146_pos, 0, rxanchor175_done
    ge rx146_pos, rx146_eos, rx146_fail
    sub $I10, rx146_pos, rx146_off
    dec $I10
    is_cclass $I11, 4096, rx146_tgt, $I10
    unless $I11, rx146_fail
  rxanchor175_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx146_cur."!cursor_pos"(rx146_pos)
    .const 'Sub' $P177 = "29_1302110486.758" 
    capture_lex $P177
    $P10 = rx146_cur."before"($P177)
    unless $P10, rx146_fail
.annotate 'line', 100
    goto alt152_end
  alt152_4:
  alt183_0:
.annotate 'line', 107
    set_addr $I10, alt183_1
    rx146_cur."!mark_push"(0, rx146_pos, $I10)
  # rx charclass s
    ge rx146_pos, rx146_eos, rx146_fail
    sub $I10, rx146_pos, rx146_off
    is_cclass $I11, 32, rx146_tgt, $I10
    unless $I11, rx146_fail
    inc rx146_pos
    goto alt183_end
  alt183_1:
  # rx subrule "panic" subtype=method negate=
    rx146_cur."!cursor_pos"(rx146_pos)
    $P10 = rx146_cur."panic"("Illegal pod directive")
    unless $P10, rx146_fail
    rx146_pos = $P10."pos"()
  alt183_end:
.annotate 'line', 108
  # rx charclass_q N r 0..-1
    sub $I10, rx146_pos, rx146_off
    find_cclass $I11, 4096, rx146_tgt, $I10, rx146_eos
    add rx146_pos, rx146_off, $I11
  alt152_end:
.annotate 'line', 84
  # rx pass
    rx146_cur."!cursor_pass"(rx146_pos, "pod_comment")
    if_null rx146_debug, debug_635
    rx146_cur."!cursor_debug"("PASS", "pod_comment", " at pos=", rx146_pos)
  debug_635:
    .return (rx146_cur)
  rx146_restart:
.annotate 'line', 10
    if_null rx146_debug, debug_636
    rx146_cur."!cursor_debug"("NEXT", "pod_comment")
  debug_636:
  rx146_fail:
    (rx146_rep, rx146_pos, $I10, $P10) = rx146_cur."!mark_fail"(0)
    lt rx146_pos, -1, rx146_done
    eq rx146_pos, -1, rx146_fail
    jump $I10
  rx146_done:
    rx146_cur."!cursor_fail"()
    if_null rx146_debug, debug_637
    rx146_cur."!cursor_debug"("FAIL", "pod_comment")
  debug_637:
    .return (rx146_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pod_comment"  :nsentry("!PREFIX__pod_comment") :subid("28_1302110486.758") :method
.annotate 'line', 10
    new $P148, "ResizablePMCArray"
    push $P148, ""
    .return ($P148)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block176"  :anon :subid("29_1302110486.758") :method :outer("27_1302110486.758")
.annotate 'line', 101
    .local string rx178_tgt
    .local int rx178_pos
    .local int rx178_off
    .local int rx178_eos
    .local int rx178_rep
    .local pmc rx178_cur
    .local pmc rx178_debug
    (rx178_cur, rx178_pos, rx178_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx178_cur
    .local pmc match
    .lex "$/", match
    length rx178_eos, rx178_tgt
    gt rx178_pos, rx178_eos, rx178_done
    set rx178_off, 0
    lt rx178_pos, 2, rx178_start
    sub rx178_off, rx178_pos, 1
    substr rx178_tgt, rx178_tgt, rx178_off
  rx178_start:
    eq $I10, 1, rx178_restart
    if_null rx178_debug, debug_631
    rx178_cur."!cursor_debug"("START", "")
  debug_631:
    $I10 = self.'from'()
    ne $I10, -1, rxscan179_done
    goto rxscan179_scan
  rxscan179_loop:
    (rx178_pos) = rx178_cur."from"()
    inc rx178_pos
    rx178_cur."!cursor_from"(rx178_pos)
    ge rx178_pos, rx178_eos, rxscan179_done
  rxscan179_scan:
    set_addr $I10, rxscan179_loop
    rx178_cur."!mark_push"(0, rx178_pos, $I10)
  rxscan179_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx178_pos, rx178_off
    set rx178_rep, 0
    sub $I12, rx178_eos, rx178_pos
  rxenumcharlistq180_loop:
    le $I12, 0, rxenumcharlistq180_done
    substr $S10, rx178_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq180_done
    inc rx178_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq180_loop
  rxenumcharlistq180_done:
    add rx178_pos, rx178_pos, rx178_rep
  alt181_0:
    set_addr $I10, alt181_1
    rx178_cur."!mark_push"(0, rx178_pos, $I10)
.annotate 'line', 102
  # rx literal  "="
    add $I11, rx178_pos, 1
    gt $I11, rx178_eos, rx178_fail
    sub $I11, rx178_pos, rx178_off
    ord $I11, rx178_tgt, $I11
    ne $I11, 61, rx178_fail
    add rx178_pos, 1
.annotate 'line', 104
  # rx rxquantr182 ** 0..1
    set_addr $I10, rxquantr182_done
    rx178_cur."!mark_push"(0, rx178_pos, $I10)
  rxquantr182_loop:
.annotate 'line', 103
  # rx literal  "cut"
    add $I11, rx178_pos, 3
    gt $I11, rx178_eos, rx178_fail
    sub $I11, rx178_pos, rx178_off
    substr $S10, rx178_tgt, $I11, 3
    ne $S10, "cut", rx178_fail
    add rx178_pos, 3
  # rxanchor rwb
    le rx178_pos, 0, rx178_fail
    sub $I10, rx178_pos, rx178_off
    is_cclass $I11, 8192, rx178_tgt, $I10
    if $I11, rx178_fail
    dec $I10
    is_cclass $I11, 8192, rx178_tgt, $I10
    unless $I11, rx178_fail
.annotate 'line', 104
  # rx subrule "panic" subtype=method negate=
    rx178_cur."!cursor_pos"(rx178_pos)
    $P10 = rx178_cur."panic"("Obsolete pod format, please use =begin/=end instead")
    unless $P10, rx178_fail
    rx178_pos = $P10."pos"()
    set_addr $I10, rxquantr182_done
    (rx178_rep) = rx178_cur."!mark_commit"($I10)
  rxquantr182_done:
.annotate 'line', 101
    goto alt181_end
  alt181_1:
.annotate 'line', 105
  # rx charclass nl
    ge rx178_pos, rx178_eos, rx178_fail
    sub $I10, rx178_pos, rx178_off
    is_cclass $I11, 4096, rx178_tgt, $I10
    unless $I11, rx178_fail
    substr $S10, rx178_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx178_pos, $I11
    inc rx178_pos
  alt181_end:
.annotate 'line', 101
  # rx pass
    rx178_cur."!cursor_pass"(rx178_pos, "")
    if_null rx178_debug, debug_632
    rx178_cur."!cursor_debug"("PASS", "", " at pos=", rx178_pos)
  debug_632:
    .return (rx178_cur)
  rx178_restart:
    if_null rx178_debug, debug_633
    rx178_cur."!cursor_debug"("NEXT", "")
  debug_633:
  rx178_fail:
    (rx178_rep, rx178_pos, $I10, $P10) = rx178_cur."!mark_fail"(0)
    lt rx178_pos, -1, rx178_done
    eq rx178_pos, -1, rx178_fail
    jump $I10
  rx178_done:
    rx178_cur."!cursor_fail"()
    if_null rx178_debug, debug_634
    rx178_cur."!cursor_debug"("FAIL", "")
  debug_634:
    .return (rx178_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "comp_unit"  :subid("30_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 116
    new $P185, "Undef"
    .lex "$*HAS_YOU_ARE_HERE", $P185
.annotate 'line', 117
    new $P186, "Undef"
    .lex "$*MAIN_SUB", $P186
.annotate 'line', 10
    .local string rx187_tgt
    .local int rx187_pos
    .local int rx187_off
    .local int rx187_eos
    .local int rx187_rep
    .local pmc rx187_cur
    .local pmc rx187_debug
    (rx187_cur, rx187_pos, rx187_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx187_cur
    .local pmc match
    .lex "$/", match
    length rx187_eos, rx187_tgt
    gt rx187_pos, rx187_eos, rx187_done
    set rx187_off, 0
    lt rx187_pos, 2, rx187_start
    sub rx187_off, rx187_pos, 1
    substr rx187_tgt, rx187_tgt, rx187_off
  rx187_start:
    eq $I10, 1, rx187_restart
    if_null rx187_debug, debug_638
    rx187_cur."!cursor_debug"("START", "comp_unit")
  debug_638:
    $I10 = self.'from'()
    ne $I10, -1, rxscan191_done
    goto rxscan191_scan
  rxscan191_loop:
    (rx187_pos) = rx187_cur."from"()
    inc rx187_pos
    rx187_cur."!cursor_from"(rx187_pos)
    ge rx187_pos, rx187_eos, rxscan191_done
  rxscan191_scan:
    set_addr $I10, rxscan191_loop
    rx187_cur."!mark_push"(0, rx187_pos, $I10)
  rxscan191_done:
.annotate 'line', 116
    rx187_cur."!cursor_pos"(rx187_pos)
    new $P192, "Integer"
    assign $P192, 0
    store_lex "$*HAS_YOU_ARE_HERE", $P192
.annotate 'line', 117
    rx187_cur."!cursor_pos"(rx187_pos)
    find_lex $P193, "$*MAIN_SUB"
    unless_null $P193, vivify_639
    get_hll_global $P193, "$MAIN_SUB"
    unless_null $P193, vivify_640
    die "Contextual $*MAIN_SUB not found"
  vivify_640:
  vivify_639:
.annotate 'line', 118
  # rx subrule "newpad" subtype=method negate=
    rx187_cur."!cursor_pos"(rx187_pos)
    $P10 = rx187_cur."newpad"()
    unless $P10, rx187_fail
    rx187_pos = $P10."pos"()
.annotate 'line', 119
  # rx subrule "outerctx" subtype=method negate=
    rx187_cur."!cursor_pos"(rx187_pos)
    $P10 = rx187_cur."outerctx"()
    unless $P10, rx187_fail
    rx187_pos = $P10."pos"()
.annotate 'line', 120
  # rx subrule "statementlist" subtype=capture negate=
    rx187_cur."!cursor_pos"(rx187_pos)
    $P10 = rx187_cur."statementlist"()
    unless $P10, rx187_fail
    rx187_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx187_pos = $P10."pos"()
  alt194_0:
.annotate 'line', 121
    set_addr $I10, alt194_1
    rx187_cur."!mark_push"(0, rx187_pos, $I10)
  # rxanchor eos
    ne rx187_pos, rx187_eos, rx187_fail
    goto alt194_end
  alt194_1:
  # rx subrule "panic" subtype=method negate=
    rx187_cur."!cursor_pos"(rx187_pos)
    $P10 = rx187_cur."panic"("Confused")
    unless $P10, rx187_fail
    rx187_pos = $P10."pos"()
  alt194_end:
.annotate 'line', 115
  # rx pass
    rx187_cur."!cursor_pass"(rx187_pos, "comp_unit")
    if_null rx187_debug, debug_641
    rx187_cur."!cursor_debug"("PASS", "comp_unit", " at pos=", rx187_pos)
  debug_641:
    .return (rx187_cur)
  rx187_restart:
.annotate 'line', 10
    if_null rx187_debug, debug_642
    rx187_cur."!cursor_debug"("NEXT", "comp_unit")
  debug_642:
  rx187_fail:
    (rx187_rep, rx187_pos, $I10, $P10) = rx187_cur."!mark_fail"(0)
    lt rx187_pos, -1, rx187_done
    eq rx187_pos, -1, rx187_fail
    jump $I10
  rx187_done:
    rx187_cur."!cursor_fail"()
    if_null rx187_debug, debug_643
    rx187_cur."!cursor_debug"("FAIL", "comp_unit")
  debug_643:
    .return (rx187_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__comp_unit"  :nsentry("!PREFIX__comp_unit") :subid("31_1302110486.758") :method
.annotate 'line', 10
    $P189 = self."!PREFIX__!subrule"("newpad", "")
    new $P190, "ResizablePMCArray"
    push $P190, $P189
    .return ($P190)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statementlist"  :subid("32_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx196_tgt
    .local int rx196_pos
    .local int rx196_off
    .local int rx196_eos
    .local int rx196_rep
    .local pmc rx196_cur
    .local pmc rx196_debug
    (rx196_cur, rx196_pos, rx196_tgt, $I10) = self."!cursor_start"()
    rx196_cur."!cursor_caparray"("statement")
    .lex unicode:"$\x{a2}", rx196_cur
    .local pmc match
    .lex "$/", match
    length rx196_eos, rx196_tgt
    gt rx196_pos, rx196_eos, rx196_done
    set rx196_off, 0
    lt rx196_pos, 2, rx196_start
    sub rx196_off, rx196_pos, 1
    substr rx196_tgt, rx196_tgt, rx196_off
  rx196_start:
    eq $I10, 1, rx196_restart
    if_null rx196_debug, debug_644
    rx196_cur."!cursor_debug"("START", "statementlist")
  debug_644:
    $I10 = self.'from'()
    ne $I10, -1, rxscan201_done
    goto rxscan201_scan
  rxscan201_loop:
    (rx196_pos) = rx196_cur."from"()
    inc rx196_pos
    rx196_cur."!cursor_from"(rx196_pos)
    ge rx196_pos, rx196_eos, rxscan201_done
  rxscan201_scan:
    set_addr $I10, rxscan201_loop
    rx196_cur."!mark_push"(0, rx196_pos, $I10)
  rxscan201_done:
  alt202_0:
.annotate 'line', 124
    set_addr $I10, alt202_1
    rx196_cur."!mark_push"(0, rx196_pos, $I10)
.annotate 'line', 125
  # rx subrule "ws" subtype=method negate=
    rx196_cur."!cursor_pos"(rx196_pos)
    $P10 = rx196_cur."ws"()
    unless $P10, rx196_fail
    rx196_pos = $P10."pos"()
  # rxanchor eos
    ne rx196_pos, rx196_eos, rx196_fail
  # rx subrule "ws" subtype=method negate=
    rx196_cur."!cursor_pos"(rx196_pos)
    $P10 = rx196_cur."ws"()
    unless $P10, rx196_fail
    rx196_pos = $P10."pos"()
    goto alt202_end
  alt202_1:
.annotate 'line', 126
  # rx subrule "ws" subtype=method negate=
    rx196_cur."!cursor_pos"(rx196_pos)
    $P10 = rx196_cur."ws"()
    unless $P10, rx196_fail
    rx196_pos = $P10."pos"()
  # rx rxquantr206 ** 0..*
    set_addr $I10, rxquantr206_done
    rx196_cur."!mark_push"(0, rx196_pos, $I10)
  rxquantr206_loop:
  # rx subrule "statement" subtype=capture negate=
    rx196_cur."!cursor_pos"(rx196_pos)
    $P10 = rx196_cur."statement"()
    unless $P10, rx196_fail
    rx196_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx196_pos = $P10."pos"()
  # rx subrule "eat_terminator" subtype=method negate=
    rx196_cur."!cursor_pos"(rx196_pos)
    $P10 = rx196_cur."eat_terminator"()
    unless $P10, rx196_fail
    rx196_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx196_cur."!cursor_pos"(rx196_pos)
    $P10 = rx196_cur."ws"()
    unless $P10, rx196_fail
    rx196_pos = $P10."pos"()
    set_addr $I10, rxquantr206_done
    (rx196_rep) = rx196_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr206_done
    rx196_cur."!mark_push"(rx196_rep, rx196_pos, $I10)
    goto rxquantr206_loop
  rxquantr206_done:
  # rx subrule "ws" subtype=method negate=
    rx196_cur."!cursor_pos"(rx196_pos)
    $P10 = rx196_cur."ws"()
    unless $P10, rx196_fail
    rx196_pos = $P10."pos"()
  alt202_end:
.annotate 'line', 124
  # rx pass
    rx196_cur."!cursor_pass"(rx196_pos, "statementlist")
    if_null rx196_debug, debug_645
    rx196_cur."!cursor_debug"("PASS", "statementlist", " at pos=", rx196_pos)
  debug_645:
    .return (rx196_cur)
  rx196_restart:
.annotate 'line', 10
    if_null rx196_debug, debug_646
    rx196_cur."!cursor_debug"("NEXT", "statementlist")
  debug_646:
  rx196_fail:
    (rx196_rep, rx196_pos, $I10, $P10) = rx196_cur."!mark_fail"(0)
    lt rx196_pos, -1, rx196_done
    eq rx196_pos, -1, rx196_fail
    jump $I10
  rx196_done:
    rx196_cur."!cursor_fail"()
    if_null rx196_debug, debug_647
    rx196_cur."!cursor_debug"("FAIL", "statementlist")
  debug_647:
    .return (rx196_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statementlist"  :nsentry("!PREFIX__statementlist") :subid("33_1302110486.758") :method
.annotate 'line', 10
    $P198 = self."!PREFIX__!subrule"("ws", "")
    $P199 = self."!PREFIX__!subrule"("ws", "")
    new $P200, "ResizablePMCArray"
    push $P200, $P198
    push $P200, $P199
    .return ($P200)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement"  :subid("34_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .const 'Sub' $P215 = "36_1302110486.758" 
    capture_lex $P215
    .local string rx210_tgt
    .local int rx210_pos
    .local int rx210_off
    .local int rx210_eos
    .local int rx210_rep
    .local pmc rx210_cur
    .local pmc rx210_debug
    (rx210_cur, rx210_pos, rx210_tgt, $I10) = self."!cursor_start"()
    rx210_cur."!cursor_caparray"("statement_mod_cond", "statement_mod_loop")
    .lex unicode:"$\x{a2}", rx210_cur
    .local pmc match
    .lex "$/", match
    length rx210_eos, rx210_tgt
    gt rx210_pos, rx210_eos, rx210_done
    set rx210_off, 0
    lt rx210_pos, 2, rx210_start
    sub rx210_off, rx210_pos, 1
    substr rx210_tgt, rx210_tgt, rx210_off
  rx210_start:
    eq $I10, 1, rx210_restart
    if_null rx210_debug, debug_648
    rx210_cur."!cursor_debug"("START", "statement")
  debug_648:
    $I10 = self.'from'()
    ne $I10, -1, rxscan213_done
    goto rxscan213_scan
  rxscan213_loop:
    (rx210_pos) = rx210_cur."from"()
    inc rx210_pos
    rx210_cur."!cursor_from"(rx210_pos)
    ge rx210_pos, rx210_eos, rxscan213_done
  rxscan213_scan:
    set_addr $I10, rxscan213_loop
    rx210_cur."!mark_push"(0, rx210_pos, $I10)
  rxscan213_done:
.annotate 'line', 130
  # rx subrule "before" subtype=zerowidth negate=1
    rx210_cur."!cursor_pos"(rx210_pos)
    .const 'Sub' $P215 = "36_1302110486.758" 
    capture_lex $P215
    $P10 = rx210_cur."before"($P215)
    if $P10, rx210_fail
  alt219_0:
.annotate 'line', 131
    set_addr $I10, alt219_1
    rx210_cur."!mark_push"(0, rx210_pos, $I10)
.annotate 'line', 132
  # rx subrule "statement_control" subtype=capture negate=
    rx210_cur."!cursor_pos"(rx210_pos)
    $P10 = rx210_cur."statement_control"()
    unless $P10, rx210_fail
    rx210_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_control")
    rx210_pos = $P10."pos"()
    goto alt219_end
  alt219_1:
.annotate 'line', 133
  # rx subrule "EXPR" subtype=capture negate=
    rx210_cur."!cursor_pos"(rx210_pos)
    $P10 = rx210_cur."EXPR"()
    unless $P10, rx210_fail
    rx210_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx210_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx210_cur."!cursor_pos"(rx210_pos)
    $P10 = rx210_cur."ws"()
    unless $P10, rx210_fail
    rx210_pos = $P10."pos"()
.annotate 'line', 138
  # rx rxquantr220 ** 0..1
    set_addr $I10, rxquantr220_done
    rx210_cur."!mark_push"(0, rx210_pos, $I10)
  rxquantr220_loop:
  alt221_0:
.annotate 'line', 134
    set_addr $I10, alt221_1
    rx210_cur."!mark_push"(0, rx210_pos, $I10)
.annotate 'line', 135
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx210_cur."!cursor_pos"(rx210_pos)
    $P10 = rx210_cur."MARKED"("endstmt")
    unless $P10, rx210_fail
    goto alt221_end
  alt221_1:
    set_addr $I10, alt221_2
    rx210_cur."!mark_push"(0, rx210_pos, $I10)
.annotate 'line', 136
  # rx subrule "statement_mod_cond" subtype=capture negate=
    rx210_cur."!cursor_pos"(rx210_pos)
    $P10 = rx210_cur."statement_mod_cond"()
    unless $P10, rx210_fail
    rx210_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_cond")
    rx210_pos = $P10."pos"()
  # rx rxquantr222 ** 0..1
    set_addr $I10, rxquantr222_done
    rx210_cur."!mark_push"(0, rx210_pos, $I10)
  rxquantr222_loop:
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx210_cur."!cursor_pos"(rx210_pos)
    $P10 = rx210_cur."statement_mod_loop"()
    unless $P10, rx210_fail
    goto rxsubrule223_pass
  rxsubrule223_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx210_fail
  rxsubrule223_pass:
    set_addr $I10, rxsubrule223_back
    rx210_cur."!mark_push"(0, rx210_pos, $I10, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx210_pos = $P10."pos"()
    set_addr $I10, rxquantr222_done
    (rx210_rep) = rx210_cur."!mark_commit"($I10)
  rxquantr222_done:
    goto alt221_end
  alt221_2:
.annotate 'line', 137
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx210_cur."!cursor_pos"(rx210_pos)
    $P10 = rx210_cur."statement_mod_loop"()
    unless $P10, rx210_fail
    rx210_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx210_pos = $P10."pos"()
  alt221_end:
.annotate 'line', 138
    set_addr $I10, rxquantr220_done
    (rx210_rep) = rx210_cur."!mark_commit"($I10)
  rxquantr220_done:
  alt219_end:
.annotate 'line', 129
  # rx pass
    rx210_cur."!cursor_pass"(rx210_pos, "statement")
    if_null rx210_debug, debug_653
    rx210_cur."!cursor_debug"("PASS", "statement", " at pos=", rx210_pos)
  debug_653:
    .return (rx210_cur)
  rx210_restart:
.annotate 'line', 10
    if_null rx210_debug, debug_654
    rx210_cur."!cursor_debug"("NEXT", "statement")
  debug_654:
  rx210_fail:
    (rx210_rep, rx210_pos, $I10, $P10) = rx210_cur."!mark_fail"(0)
    lt rx210_pos, -1, rx210_done
    eq rx210_pos, -1, rx210_fail
    jump $I10
  rx210_done:
    rx210_cur."!cursor_fail"()
    if_null rx210_debug, debug_655
    rx210_cur."!cursor_debug"("FAIL", "statement")
  debug_655:
    .return (rx210_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement"  :nsentry("!PREFIX__statement") :subid("35_1302110486.758") :method
.annotate 'line', 10
    new $P212, "ResizablePMCArray"
    push $P212, ""
    .return ($P212)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block214"  :anon :subid("36_1302110486.758") :method :outer("34_1302110486.758")
.annotate 'line', 130
    .local string rx216_tgt
    .local int rx216_pos
    .local int rx216_off
    .local int rx216_eos
    .local int rx216_rep
    .local pmc rx216_cur
    .local pmc rx216_debug
    (rx216_cur, rx216_pos, rx216_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx216_cur
    .local pmc match
    .lex "$/", match
    length rx216_eos, rx216_tgt
    gt rx216_pos, rx216_eos, rx216_done
    set rx216_off, 0
    lt rx216_pos, 2, rx216_start
    sub rx216_off, rx216_pos, 1
    substr rx216_tgt, rx216_tgt, rx216_off
  rx216_start:
    eq $I10, 1, rx216_restart
    if_null rx216_debug, debug_649
    rx216_cur."!cursor_debug"("START", "")
  debug_649:
    $I10 = self.'from'()
    ne $I10, -1, rxscan217_done
    goto rxscan217_scan
  rxscan217_loop:
    (rx216_pos) = rx216_cur."from"()
    inc rx216_pos
    rx216_cur."!cursor_from"(rx216_pos)
    ge rx216_pos, rx216_eos, rxscan217_done
  rxscan217_scan:
    set_addr $I10, rxscan217_loop
    rx216_cur."!mark_push"(0, rx216_pos, $I10)
  rxscan217_done:
  alt218_0:
    set_addr $I10, alt218_1
    rx216_cur."!mark_push"(0, rx216_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx216_pos, rx216_eos, rx216_fail
    sub $I10, rx216_pos, rx216_off
    substr $S10, rx216_tgt, $I10, 1
    index $I11, "])}", $S10
    lt $I11, 0, rx216_fail
    inc rx216_pos
    goto alt218_end
  alt218_1:
  # rxanchor eos
    ne rx216_pos, rx216_eos, rx216_fail
  alt218_end:
  # rx pass
    rx216_cur."!cursor_pass"(rx216_pos, "")
    if_null rx216_debug, debug_650
    rx216_cur."!cursor_debug"("PASS", "", " at pos=", rx216_pos)
  debug_650:
    .return (rx216_cur)
  rx216_restart:
    if_null rx216_debug, debug_651
    rx216_cur."!cursor_debug"("NEXT", "")
  debug_651:
  rx216_fail:
    (rx216_rep, rx216_pos, $I10, $P10) = rx216_cur."!mark_fail"(0)
    lt rx216_pos, -1, rx216_done
    eq rx216_pos, -1, rx216_fail
    jump $I10
  rx216_done:
    rx216_cur."!cursor_fail"()
    if_null rx216_debug, debug_652
    rx216_cur."!cursor_debug"("FAIL", "")
  debug_652:
    .return (rx216_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "eat_terminator"  :subid("37_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx225_tgt
    .local int rx225_pos
    .local int rx225_off
    .local int rx225_eos
    .local int rx225_rep
    .local pmc rx225_cur
    .local pmc rx225_debug
    (rx225_cur, rx225_pos, rx225_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx225_cur
    .local pmc match
    .lex "$/", match
    length rx225_eos, rx225_tgt
    gt rx225_pos, rx225_eos, rx225_done
    set rx225_off, 0
    lt rx225_pos, 2, rx225_start
    sub rx225_off, rx225_pos, 1
    substr rx225_tgt, rx225_tgt, rx225_off
  rx225_start:
    eq $I10, 1, rx225_restart
    if_null rx225_debug, debug_656
    rx225_cur."!cursor_debug"("START", "eat_terminator")
  debug_656:
    $I10 = self.'from'()
    ne $I10, -1, rxscan228_done
    goto rxscan228_scan
  rxscan228_loop:
    (rx225_pos) = rx225_cur."from"()
    inc rx225_pos
    rx225_cur."!cursor_from"(rx225_pos)
    ge rx225_pos, rx225_eos, rxscan228_done
  rxscan228_scan:
    set_addr $I10, rxscan228_loop
    rx225_cur."!mark_push"(0, rx225_pos, $I10)
  rxscan228_done:
  alt229_0:
.annotate 'line', 142
    set_addr $I10, alt229_1
    rx225_cur."!mark_push"(0, rx225_pos, $I10)
.annotate 'line', 143
  # rx literal  ";"
    add $I11, rx225_pos, 1
    gt $I11, rx225_eos, rx225_fail
    sub $I11, rx225_pos, rx225_off
    ord $I11, rx225_tgt, $I11
    ne $I11, 59, rx225_fail
    add rx225_pos, 1
    goto alt229_end
  alt229_1:
    set_addr $I10, alt229_2
    rx225_cur."!mark_push"(0, rx225_pos, $I10)
.annotate 'line', 144
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx225_cur."!cursor_pos"(rx225_pos)
    $P10 = rx225_cur."MARKED"("endstmt")
    unless $P10, rx225_fail
    goto alt229_end
  alt229_2:
    set_addr $I10, alt229_3
    rx225_cur."!mark_push"(0, rx225_pos, $I10)
.annotate 'line', 145
  # rx subrule "terminator" subtype=zerowidth negate=
    rx225_cur."!cursor_pos"(rx225_pos)
    $P10 = rx225_cur."terminator"()
    unless $P10, rx225_fail
    goto alt229_end
  alt229_3:
.annotate 'line', 146
  # rxanchor eos
    ne rx225_pos, rx225_eos, rx225_fail
  alt229_end:
.annotate 'line', 142
  # rx pass
    rx225_cur."!cursor_pass"(rx225_pos, "eat_terminator")
    if_null rx225_debug, debug_657
    rx225_cur."!cursor_debug"("PASS", "eat_terminator", " at pos=", rx225_pos)
  debug_657:
    .return (rx225_cur)
  rx225_restart:
.annotate 'line', 10
    if_null rx225_debug, debug_658
    rx225_cur."!cursor_debug"("NEXT", "eat_terminator")
  debug_658:
  rx225_fail:
    (rx225_rep, rx225_pos, $I10, $P10) = rx225_cur."!mark_fail"(0)
    lt rx225_pos, -1, rx225_done
    eq rx225_pos, -1, rx225_fail
    jump $I10
  rx225_done:
    rx225_cur."!cursor_fail"()
    if_null rx225_debug, debug_659
    rx225_cur."!cursor_debug"("FAIL", "eat_terminator")
  debug_659:
    .return (rx225_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__eat_terminator"  :nsentry("!PREFIX__eat_terminator") :subid("38_1302110486.758") :method
.annotate 'line', 10
    new $P227, "ResizablePMCArray"
    push $P227, ""
    push $P227, ""
    push $P227, ""
    push $P227, ";"
    .return ($P227)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "xblock"  :subid("39_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx231_tgt
    .local int rx231_pos
    .local int rx231_off
    .local int rx231_eos
    .local int rx231_rep
    .local pmc rx231_cur
    .local pmc rx231_debug
    (rx231_cur, rx231_pos, rx231_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx231_cur
    .local pmc match
    .lex "$/", match
    length rx231_eos, rx231_tgt
    gt rx231_pos, rx231_eos, rx231_done
    set rx231_off, 0
    lt rx231_pos, 2, rx231_start
    sub rx231_off, rx231_pos, 1
    substr rx231_tgt, rx231_tgt, rx231_off
  rx231_start:
    eq $I10, 1, rx231_restart
    if_null rx231_debug, debug_660
    rx231_cur."!cursor_debug"("START", "xblock")
  debug_660:
    $I10 = self.'from'()
    ne $I10, -1, rxscan235_done
    goto rxscan235_scan
  rxscan235_loop:
    (rx231_pos) = rx231_cur."from"()
    inc rx231_pos
    rx231_cur."!cursor_from"(rx231_pos)
    ge rx231_pos, rx231_eos, rxscan235_done
  rxscan235_scan:
    set_addr $I10, rxscan235_loop
    rx231_cur."!mark_push"(0, rx231_pos, $I10)
  rxscan235_done:
.annotate 'line', 150
  # rx subrule "EXPR" subtype=capture negate=
    rx231_cur."!cursor_pos"(rx231_pos)
    $P10 = rx231_cur."EXPR"()
    unless $P10, rx231_fail
    rx231_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx231_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx231_cur."!cursor_pos"(rx231_pos)
    $P10 = rx231_cur."ws"()
    unless $P10, rx231_fail
    rx231_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx231_cur."!cursor_pos"(rx231_pos)
    $P10 = rx231_cur."pblock"()
    unless $P10, rx231_fail
    rx231_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx231_pos = $P10."pos"()
.annotate 'line', 149
  # rx pass
    rx231_cur."!cursor_pass"(rx231_pos, "xblock")
    if_null rx231_debug, debug_661
    rx231_cur."!cursor_debug"("PASS", "xblock", " at pos=", rx231_pos)
  debug_661:
    .return (rx231_cur)
  rx231_restart:
.annotate 'line', 10
    if_null rx231_debug, debug_662
    rx231_cur."!cursor_debug"("NEXT", "xblock")
  debug_662:
  rx231_fail:
    (rx231_rep, rx231_pos, $I10, $P10) = rx231_cur."!mark_fail"(0)
    lt rx231_pos, -1, rx231_done
    eq rx231_pos, -1, rx231_fail
    jump $I10
  rx231_done:
    rx231_cur."!cursor_fail"()
    if_null rx231_debug, debug_663
    rx231_cur."!cursor_debug"("FAIL", "xblock")
  debug_663:
    .return (rx231_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__xblock"  :nsentry("!PREFIX__xblock") :subid("40_1302110486.758") :method
.annotate 'line', 10
    $P233 = self."!PREFIX__!subrule"("EXPR", "")
    new $P234, "ResizablePMCArray"
    push $P234, $P233
    .return ($P234)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pblock"  :subid("41_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx237_tgt
    .local int rx237_pos
    .local int rx237_off
    .local int rx237_eos
    .local int rx237_rep
    .local pmc rx237_cur
    .local pmc rx237_debug
    (rx237_cur, rx237_pos, rx237_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx237_cur
    .local pmc match
    .lex "$/", match
    length rx237_eos, rx237_tgt
    gt rx237_pos, rx237_eos, rx237_done
    set rx237_off, 0
    lt rx237_pos, 2, rx237_start
    sub rx237_off, rx237_pos, 1
    substr rx237_tgt, rx237_tgt, rx237_off
  rx237_start:
    eq $I10, 1, rx237_restart
    if_null rx237_debug, debug_664
    rx237_cur."!cursor_debug"("START", "pblock")
  debug_664:
    $I10 = self.'from'()
    ne $I10, -1, rxscan242_done
    goto rxscan242_scan
  rxscan242_loop:
    (rx237_pos) = rx237_cur."from"()
    inc rx237_pos
    rx237_cur."!cursor_from"(rx237_pos)
    ge rx237_pos, rx237_eos, rxscan242_done
  rxscan242_scan:
    set_addr $I10, rxscan242_loop
    rx237_cur."!mark_push"(0, rx237_pos, $I10)
  rxscan242_done:
  alt243_0:
.annotate 'line', 153
    set_addr $I10, alt243_1
    rx237_cur."!mark_push"(0, rx237_pos, $I10)
.annotate 'line', 154
  # rx subrule "lambda" subtype=method negate=
    rx237_cur."!cursor_pos"(rx237_pos)
    $P10 = rx237_cur."lambda"()
    unless $P10, rx237_fail
    rx237_pos = $P10."pos"()
.annotate 'line', 155
  # rx subrule "newpad" subtype=method negate=
    rx237_cur."!cursor_pos"(rx237_pos)
    $P10 = rx237_cur."newpad"()
    unless $P10, rx237_fail
    rx237_pos = $P10."pos"()
.annotate 'line', 156
  # rx subrule "signature" subtype=capture negate=
    rx237_cur."!cursor_pos"(rx237_pos)
    $P10 = rx237_cur."signature"()
    unless $P10, rx237_fail
    rx237_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx237_pos = $P10."pos"()
.annotate 'line', 157
  # rx subrule "blockoid" subtype=capture negate=
    rx237_cur."!cursor_pos"(rx237_pos)
    $P10 = rx237_cur."blockoid"()
    unless $P10, rx237_fail
    rx237_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx237_pos = $P10."pos"()
.annotate 'line', 154
    goto alt243_end
  alt243_1:
    set_addr $I10, alt243_2
    rx237_cur."!mark_push"(0, rx237_pos, $I10)
.annotate 'line', 158
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx237_pos, rx237_off
    substr $S10, rx237_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx237_fail
.annotate 'line', 159
  # rx subrule "newpad" subtype=method negate=
    rx237_cur."!cursor_pos"(rx237_pos)
    $P10 = rx237_cur."newpad"()
    unless $P10, rx237_fail
    rx237_pos = $P10."pos"()
.annotate 'line', 160
  # rx subrule "blockoid" subtype=capture negate=
    rx237_cur."!cursor_pos"(rx237_pos)
    $P10 = rx237_cur."blockoid"()
    unless $P10, rx237_fail
    rx237_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx237_pos = $P10."pos"()
.annotate 'line', 158
    goto alt243_end
  alt243_2:
.annotate 'line', 161
  # rx subrule "panic" subtype=method negate=
    rx237_cur."!cursor_pos"(rx237_pos)
    $P10 = rx237_cur."panic"("Missing block")
    unless $P10, rx237_fail
    rx237_pos = $P10."pos"()
  alt243_end:
.annotate 'line', 153
  # rx pass
    rx237_cur."!cursor_pass"(rx237_pos, "pblock")
    if_null rx237_debug, debug_665
    rx237_cur."!cursor_debug"("PASS", "pblock", " at pos=", rx237_pos)
  debug_665:
    .return (rx237_cur)
  rx237_restart:
.annotate 'line', 10
    if_null rx237_debug, debug_666
    rx237_cur."!cursor_debug"("NEXT", "pblock")
  debug_666:
  rx237_fail:
    (rx237_rep, rx237_pos, $I10, $P10) = rx237_cur."!mark_fail"(0)
    lt rx237_pos, -1, rx237_done
    eq rx237_pos, -1, rx237_fail
    jump $I10
  rx237_done:
    rx237_cur."!cursor_fail"()
    if_null rx237_debug, debug_667
    rx237_cur."!cursor_debug"("FAIL", "pblock")
  debug_667:
    .return (rx237_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pblock"  :nsentry("!PREFIX__pblock") :subid("42_1302110486.758") :method
.annotate 'line', 10
    $P239 = self."!PREFIX__!subrule"("panic", "")
    $P240 = self."!PREFIX__!subrule"("lambda", "")
    new $P241, "ResizablePMCArray"
    push $P241, $P239
    push $P241, "{"
    push $P241, $P240
    .return ($P241)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "lambda"  :subid("43_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx245_tgt
    .local int rx245_pos
    .local int rx245_off
    .local int rx245_eos
    .local int rx245_rep
    .local pmc rx245_cur
    .local pmc rx245_debug
    (rx245_cur, rx245_pos, rx245_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx245_cur
    .local pmc match
    .lex "$/", match
    length rx245_eos, rx245_tgt
    gt rx245_pos, rx245_eos, rx245_done
    set rx245_off, 0
    lt rx245_pos, 2, rx245_start
    sub rx245_off, rx245_pos, 1
    substr rx245_tgt, rx245_tgt, rx245_off
  rx245_start:
    eq $I10, 1, rx245_restart
    if_null rx245_debug, debug_668
    rx245_cur."!cursor_debug"("START", "lambda")
  debug_668:
    $I10 = self.'from'()
    ne $I10, -1, rxscan248_done
    goto rxscan248_scan
  rxscan248_loop:
    (rx245_pos) = rx245_cur."from"()
    inc rx245_pos
    rx245_cur."!cursor_from"(rx245_pos)
    ge rx245_pos, rx245_eos, rxscan248_done
  rxscan248_scan:
    set_addr $I10, rxscan248_loop
    rx245_cur."!mark_push"(0, rx245_pos, $I10)
  rxscan248_done:
  alt249_0:
.annotate 'line', 164
    set_addr $I10, alt249_1
    rx245_cur."!mark_push"(0, rx245_pos, $I10)
  # rx literal  "->"
    add $I11, rx245_pos, 2
    gt $I11, rx245_eos, rx245_fail
    sub $I11, rx245_pos, rx245_off
    substr $S10, rx245_tgt, $I11, 2
    ne $S10, "->", rx245_fail
    add rx245_pos, 2
    goto alt249_end
  alt249_1:
  # rx literal  "<->"
    add $I11, rx245_pos, 3
    gt $I11, rx245_eos, rx245_fail
    sub $I11, rx245_pos, rx245_off
    substr $S10, rx245_tgt, $I11, 3
    ne $S10, "<->", rx245_fail
    add rx245_pos, 3
  alt249_end:
  # rx pass
    rx245_cur."!cursor_pass"(rx245_pos, "lambda")
    if_null rx245_debug, debug_669
    rx245_cur."!cursor_debug"("PASS", "lambda", " at pos=", rx245_pos)
  debug_669:
    .return (rx245_cur)
  rx245_restart:
.annotate 'line', 10
    if_null rx245_debug, debug_670
    rx245_cur."!cursor_debug"("NEXT", "lambda")
  debug_670:
  rx245_fail:
    (rx245_rep, rx245_pos, $I10, $P10) = rx245_cur."!mark_fail"(0)
    lt rx245_pos, -1, rx245_done
    eq rx245_pos, -1, rx245_fail
    jump $I10
  rx245_done:
    rx245_cur."!cursor_fail"()
    if_null rx245_debug, debug_671
    rx245_cur."!cursor_debug"("FAIL", "lambda")
  debug_671:
    .return (rx245_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__lambda"  :nsentry("!PREFIX__lambda") :subid("44_1302110486.758") :method
.annotate 'line', 10
    new $P247, "ResizablePMCArray"
    push $P247, "<->"
    push $P247, "->"
    .return ($P247)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "block"  :subid("45_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx251_tgt
    .local int rx251_pos
    .local int rx251_off
    .local int rx251_eos
    .local int rx251_rep
    .local pmc rx251_cur
    .local pmc rx251_debug
    (rx251_cur, rx251_pos, rx251_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx251_cur
    .local pmc match
    .lex "$/", match
    length rx251_eos, rx251_tgt
    gt rx251_pos, rx251_eos, rx251_done
    set rx251_off, 0
    lt rx251_pos, 2, rx251_start
    sub rx251_off, rx251_pos, 1
    substr rx251_tgt, rx251_tgt, rx251_off
  rx251_start:
    eq $I10, 1, rx251_restart
    if_null rx251_debug, debug_672
    rx251_cur."!cursor_debug"("START", "block")
  debug_672:
    $I10 = self.'from'()
    ne $I10, -1, rxscan255_done
    goto rxscan255_scan
  rxscan255_loop:
    (rx251_pos) = rx251_cur."from"()
    inc rx251_pos
    rx251_cur."!cursor_from"(rx251_pos)
    ge rx251_pos, rx251_eos, rxscan255_done
  rxscan255_scan:
    set_addr $I10, rxscan255_loop
    rx251_cur."!mark_push"(0, rx251_pos, $I10)
  rxscan255_done:
  alt256_0:
.annotate 'line', 167
    set_addr $I10, alt256_1
    rx251_cur."!mark_push"(0, rx251_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx251_pos, rx251_off
    substr $S10, rx251_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx251_fail
    goto alt256_end
  alt256_1:
  # rx subrule "panic" subtype=method negate=
    rx251_cur."!cursor_pos"(rx251_pos)
    $P10 = rx251_cur."panic"("Missing block")
    unless $P10, rx251_fail
    rx251_pos = $P10."pos"()
  alt256_end:
.annotate 'line', 168
  # rx subrule "newpad" subtype=method negate=
    rx251_cur."!cursor_pos"(rx251_pos)
    $P10 = rx251_cur."newpad"()
    unless $P10, rx251_fail
    rx251_pos = $P10."pos"()
.annotate 'line', 169
  # rx subrule "blockoid" subtype=capture negate=
    rx251_cur."!cursor_pos"(rx251_pos)
    $P10 = rx251_cur."blockoid"()
    unless $P10, rx251_fail
    rx251_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx251_pos = $P10."pos"()
.annotate 'line', 166
  # rx pass
    rx251_cur."!cursor_pass"(rx251_pos, "block")
    if_null rx251_debug, debug_673
    rx251_cur."!cursor_debug"("PASS", "block", " at pos=", rx251_pos)
  debug_673:
    .return (rx251_cur)
  rx251_restart:
.annotate 'line', 10
    if_null rx251_debug, debug_674
    rx251_cur."!cursor_debug"("NEXT", "block")
  debug_674:
  rx251_fail:
    (rx251_rep, rx251_pos, $I10, $P10) = rx251_cur."!mark_fail"(0)
    lt rx251_pos, -1, rx251_done
    eq rx251_pos, -1, rx251_fail
    jump $I10
  rx251_done:
    rx251_cur."!cursor_fail"()
    if_null rx251_debug, debug_675
    rx251_cur."!cursor_debug"("FAIL", "block")
  debug_675:
    .return (rx251_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__block"  :nsentry("!PREFIX__block") :subid("46_1302110486.758") :method
.annotate 'line', 10
    $P253 = self."!PREFIX__!subrule"("panic", "")
    new $P254, "ResizablePMCArray"
    push $P254, $P253
    push $P254, "{"
    .return ($P254)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blockoid"  :subid("47_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx258_tgt
    .local int rx258_pos
    .local int rx258_off
    .local int rx258_eos
    .local int rx258_rep
    .local pmc rx258_cur
    .local pmc rx258_debug
    (rx258_cur, rx258_pos, rx258_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx258_cur
    .local pmc match
    .lex "$/", match
    length rx258_eos, rx258_tgt
    gt rx258_pos, rx258_eos, rx258_done
    set rx258_off, 0
    lt rx258_pos, 2, rx258_start
    sub rx258_off, rx258_pos, 1
    substr rx258_tgt, rx258_tgt, rx258_off
  rx258_start:
    eq $I10, 1, rx258_restart
    if_null rx258_debug, debug_676
    rx258_cur."!cursor_debug"("START", "blockoid")
  debug_676:
    $I10 = self.'from'()
    ne $I10, -1, rxscan262_done
    goto rxscan262_scan
  rxscan262_loop:
    (rx258_pos) = rx258_cur."from"()
    inc rx258_pos
    rx258_cur."!cursor_from"(rx258_pos)
    ge rx258_pos, rx258_eos, rxscan262_done
  rxscan262_scan:
    set_addr $I10, rxscan262_loop
    rx258_cur."!mark_push"(0, rx258_pos, $I10)
  rxscan262_done:
.annotate 'line', 173
  # rx subrule "finishpad" subtype=method negate=
    rx258_cur."!cursor_pos"(rx258_pos)
    $P10 = rx258_cur."finishpad"()
    unless $P10, rx258_fail
    rx258_pos = $P10."pos"()
  alt263_0:
.annotate 'line', 174
    set_addr $I10, alt263_1
    rx258_cur."!mark_push"(0, rx258_pos, $I10)
.annotate 'line', 175
  # rx literal  "{YOU_ARE_HERE}"
    add $I11, rx258_pos, 14
    gt $I11, rx258_eos, rx258_fail
    sub $I11, rx258_pos, rx258_off
    substr $S10, rx258_tgt, $I11, 14
    ne $S10, "{YOU_ARE_HERE}", rx258_fail
    add rx258_pos, 14
  # rx subrule "you_are_here" subtype=capture negate=
    rx258_cur."!cursor_pos"(rx258_pos)
    $P10 = rx258_cur."you_are_here"()
    unless $P10, rx258_fail
    rx258_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("you_are_here")
    rx258_pos = $P10."pos"()
    goto alt263_end
  alt263_1:
.annotate 'line', 176
  # rx literal  "{"
    add $I11, rx258_pos, 1
    gt $I11, rx258_eos, rx258_fail
    sub $I11, rx258_pos, rx258_off
    ord $I11, rx258_tgt, $I11
    ne $I11, 123, rx258_fail
    add rx258_pos, 1
  # rx subrule "statementlist" subtype=capture negate=
    rx258_cur."!cursor_pos"(rx258_pos)
    $P10 = rx258_cur."statementlist"()
    unless $P10, rx258_fail
    rx258_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx258_pos = $P10."pos"()
  alt264_0:
    set_addr $I10, alt264_1
    rx258_cur."!mark_push"(0, rx258_pos, $I10)
  # rx literal  "}"
    add $I11, rx258_pos, 1
    gt $I11, rx258_eos, rx258_fail
    sub $I11, rx258_pos, rx258_off
    ord $I11, rx258_tgt, $I11
    ne $I11, 125, rx258_fail
    add rx258_pos, 1
    goto alt264_end
  alt264_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx258_cur."!cursor_pos"(rx258_pos)
    $P10 = rx258_cur."FAILGOAL"("'}'")
    unless $P10, rx258_fail
    goto rxsubrule266_pass
  rxsubrule266_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx258_fail
  rxsubrule266_pass:
    set_addr $I10, rxsubrule266_back
    rx258_cur."!mark_push"(0, rx258_pos, $I10, $P10)
    rx258_pos = $P10."pos"()
  alt264_end:
  alt263_end:
.annotate 'line', 178
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx258_cur."!cursor_pos"(rx258_pos)
    $P10 = rx258_cur."ENDSTMT"()
    unless $P10, rx258_fail
.annotate 'line', 172
  # rx pass
    rx258_cur."!cursor_pass"(rx258_pos, "blockoid")
    if_null rx258_debug, debug_677
    rx258_cur."!cursor_debug"("PASS", "blockoid", " at pos=", rx258_pos)
  debug_677:
    .return (rx258_cur)
  rx258_restart:
.annotate 'line', 10
    if_null rx258_debug, debug_678
    rx258_cur."!cursor_debug"("NEXT", "blockoid")
  debug_678:
  rx258_fail:
    (rx258_rep, rx258_pos, $I10, $P10) = rx258_cur."!mark_fail"(0)
    lt rx258_pos, -1, rx258_done
    eq rx258_pos, -1, rx258_fail
    jump $I10
  rx258_done:
    rx258_cur."!cursor_fail"()
    if_null rx258_debug, debug_679
    rx258_cur."!cursor_debug"("FAIL", "blockoid")
  debug_679:
    .return (rx258_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blockoid"  :nsentry("!PREFIX__blockoid") :subid("48_1302110486.758") :method
.annotate 'line', 10
    $P260 = self."!PREFIX__!subrule"("finishpad", "")
    new $P261, "ResizablePMCArray"
    push $P261, $P260
    .return ($P261)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "newpad"  :subid("49_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx268_tgt
    .local int rx268_pos
    .local int rx268_off
    .local int rx268_eos
    .local int rx268_rep
    .local pmc rx268_cur
    .local pmc rx268_debug
    (rx268_cur, rx268_pos, rx268_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx268_cur
    .local pmc match
    .lex "$/", match
    length rx268_eos, rx268_tgt
    gt rx268_pos, rx268_eos, rx268_done
    set rx268_off, 0
    lt rx268_pos, 2, rx268_start
    sub rx268_off, rx268_pos, 1
    substr rx268_tgt, rx268_tgt, rx268_off
  rx268_start:
    eq $I10, 1, rx268_restart
    if_null rx268_debug, debug_680
    rx268_cur."!cursor_debug"("START", "newpad")
  debug_680:
    $I10 = self.'from'()
    ne $I10, -1, rxscan271_done
    goto rxscan271_scan
  rxscan271_loop:
    (rx268_pos) = rx268_cur."from"()
    inc rx268_pos
    rx268_cur."!cursor_from"(rx268_pos)
    ge rx268_pos, rx268_eos, rxscan271_done
  rxscan271_scan:
    set_addr $I10, rxscan271_loop
    rx268_cur."!mark_push"(0, rx268_pos, $I10)
  rxscan271_done:
.annotate 'line', 181
  # rx pass
    rx268_cur."!cursor_pass"(rx268_pos, "newpad")
    if_null rx268_debug, debug_681
    rx268_cur."!cursor_debug"("PASS", "newpad", " at pos=", rx268_pos)
  debug_681:
    .return (rx268_cur)
  rx268_restart:
.annotate 'line', 10
    if_null rx268_debug, debug_682
    rx268_cur."!cursor_debug"("NEXT", "newpad")
  debug_682:
  rx268_fail:
    (rx268_rep, rx268_pos, $I10, $P10) = rx268_cur."!mark_fail"(0)
    lt rx268_pos, -1, rx268_done
    eq rx268_pos, -1, rx268_fail
    jump $I10
  rx268_done:
    rx268_cur."!cursor_fail"()
    if_null rx268_debug, debug_683
    rx268_cur."!cursor_debug"("FAIL", "newpad")
  debug_683:
    .return (rx268_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__newpad"  :nsentry("!PREFIX__newpad") :subid("50_1302110486.758") :method
.annotate 'line', 10
    new $P270, "ResizablePMCArray"
    push $P270, ""
    .return ($P270)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "outerctx"  :subid("51_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx273_tgt
    .local int rx273_pos
    .local int rx273_off
    .local int rx273_eos
    .local int rx273_rep
    .local pmc rx273_cur
    .local pmc rx273_debug
    (rx273_cur, rx273_pos, rx273_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx273_cur
    .local pmc match
    .lex "$/", match
    length rx273_eos, rx273_tgt
    gt rx273_pos, rx273_eos, rx273_done
    set rx273_off, 0
    lt rx273_pos, 2, rx273_start
    sub rx273_off, rx273_pos, 1
    substr rx273_tgt, rx273_tgt, rx273_off
  rx273_start:
    eq $I10, 1, rx273_restart
    if_null rx273_debug, debug_684
    rx273_cur."!cursor_debug"("START", "outerctx")
  debug_684:
    $I10 = self.'from'()
    ne $I10, -1, rxscan276_done
    goto rxscan276_scan
  rxscan276_loop:
    (rx273_pos) = rx273_cur."from"()
    inc rx273_pos
    rx273_cur."!cursor_from"(rx273_pos)
    ge rx273_pos, rx273_eos, rxscan276_done
  rxscan276_scan:
    set_addr $I10, rxscan276_loop
    rx273_cur."!mark_push"(0, rx273_pos, $I10)
  rxscan276_done:
.annotate 'line', 182
  # rx pass
    rx273_cur."!cursor_pass"(rx273_pos, "outerctx")
    if_null rx273_debug, debug_685
    rx273_cur."!cursor_debug"("PASS", "outerctx", " at pos=", rx273_pos)
  debug_685:
    .return (rx273_cur)
  rx273_restart:
.annotate 'line', 10
    if_null rx273_debug, debug_686
    rx273_cur."!cursor_debug"("NEXT", "outerctx")
  debug_686:
  rx273_fail:
    (rx273_rep, rx273_pos, $I10, $P10) = rx273_cur."!mark_fail"(0)
    lt rx273_pos, -1, rx273_done
    eq rx273_pos, -1, rx273_fail
    jump $I10
  rx273_done:
    rx273_cur."!cursor_fail"()
    if_null rx273_debug, debug_687
    rx273_cur."!cursor_debug"("FAIL", "outerctx")
  debug_687:
    .return (rx273_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__outerctx"  :nsentry("!PREFIX__outerctx") :subid("52_1302110486.758") :method
.annotate 'line', 10
    new $P275, "ResizablePMCArray"
    push $P275, ""
    .return ($P275)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "finishpad"  :subid("53_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx278_tgt
    .local int rx278_pos
    .local int rx278_off
    .local int rx278_eos
    .local int rx278_rep
    .local pmc rx278_cur
    .local pmc rx278_debug
    (rx278_cur, rx278_pos, rx278_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx278_cur
    .local pmc match
    .lex "$/", match
    length rx278_eos, rx278_tgt
    gt rx278_pos, rx278_eos, rx278_done
    set rx278_off, 0
    lt rx278_pos, 2, rx278_start
    sub rx278_off, rx278_pos, 1
    substr rx278_tgt, rx278_tgt, rx278_off
  rx278_start:
    eq $I10, 1, rx278_restart
    if_null rx278_debug, debug_688
    rx278_cur."!cursor_debug"("START", "finishpad")
  debug_688:
    $I10 = self.'from'()
    ne $I10, -1, rxscan281_done
    goto rxscan281_scan
  rxscan281_loop:
    (rx278_pos) = rx278_cur."from"()
    inc rx278_pos
    rx278_cur."!cursor_from"(rx278_pos)
    ge rx278_pos, rx278_eos, rxscan281_done
  rxscan281_scan:
    set_addr $I10, rxscan281_loop
    rx278_cur."!mark_push"(0, rx278_pos, $I10)
  rxscan281_done:
.annotate 'line', 183
  # rx pass
    rx278_cur."!cursor_pass"(rx278_pos, "finishpad")
    if_null rx278_debug, debug_689
    rx278_cur."!cursor_debug"("PASS", "finishpad", " at pos=", rx278_pos)
  debug_689:
    .return (rx278_cur)
  rx278_restart:
.annotate 'line', 10
    if_null rx278_debug, debug_690
    rx278_cur."!cursor_debug"("NEXT", "finishpad")
  debug_690:
  rx278_fail:
    (rx278_rep, rx278_pos, $I10, $P10) = rx278_cur."!mark_fail"(0)
    lt rx278_pos, -1, rx278_done
    eq rx278_pos, -1, rx278_fail
    jump $I10
  rx278_done:
    rx278_cur."!cursor_fail"()
    if_null rx278_debug, debug_691
    rx278_cur."!cursor_debug"("FAIL", "finishpad")
  debug_691:
    .return (rx278_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__finishpad"  :nsentry("!PREFIX__finishpad") :subid("54_1302110486.758") :method
.annotate 'line', 10
    new $P280, "ResizablePMCArray"
    push $P280, ""
    .return ($P280)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "you_are_here"  :subid("55_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx283_tgt
    .local int rx283_pos
    .local int rx283_off
    .local int rx283_eos
    .local int rx283_rep
    .local pmc rx283_cur
    .local pmc rx283_debug
    (rx283_cur, rx283_pos, rx283_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx283_cur
    .local pmc match
    .lex "$/", match
    length rx283_eos, rx283_tgt
    gt rx283_pos, rx283_eos, rx283_done
    set rx283_off, 0
    lt rx283_pos, 2, rx283_start
    sub rx283_off, rx283_pos, 1
    substr rx283_tgt, rx283_tgt, rx283_off
  rx283_start:
    eq $I10, 1, rx283_restart
    if_null rx283_debug, debug_692
    rx283_cur."!cursor_debug"("START", "you_are_here")
  debug_692:
    $I10 = self.'from'()
    ne $I10, -1, rxscan286_done
    goto rxscan286_scan
  rxscan286_loop:
    (rx283_pos) = rx283_cur."from"()
    inc rx283_pos
    rx283_cur."!cursor_from"(rx283_pos)
    ge rx283_pos, rx283_eos, rxscan286_done
  rxscan286_scan:
    set_addr $I10, rxscan286_loop
    rx283_cur."!mark_push"(0, rx283_pos, $I10)
  rxscan286_done:
.annotate 'line', 184
  # rx pass
    rx283_cur."!cursor_pass"(rx283_pos, "you_are_here")
    if_null rx283_debug, debug_693
    rx283_cur."!cursor_debug"("PASS", "you_are_here", " at pos=", rx283_pos)
  debug_693:
    .return (rx283_cur)
  rx283_restart:
.annotate 'line', 10
    if_null rx283_debug, debug_694
    rx283_cur."!cursor_debug"("NEXT", "you_are_here")
  debug_694:
  rx283_fail:
    (rx283_rep, rx283_pos, $I10, $P10) = rx283_cur."!mark_fail"(0)
    lt rx283_pos, -1, rx283_done
    eq rx283_pos, -1, rx283_fail
    jump $I10
  rx283_done:
    rx283_cur."!cursor_fail"()
    if_null rx283_debug, debug_695
    rx283_cur."!cursor_debug"("FAIL", "you_are_here")
  debug_695:
    .return (rx283_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__you_are_here"  :nsentry("!PREFIX__you_are_here") :subid("56_1302110486.758") :method
.annotate 'line', 10
    new $P285, "ResizablePMCArray"
    push $P285, ""
    .return ($P285)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator"  :subid("57_1302110486.758")
    .param pmc param_288
.annotate 'line', 186
    .lex "self", param_288
    $P289 = param_288."!protoregex"("terminator")
    .return ($P289)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator"  :subid("58_1302110486.758")
    .param pmc param_291
.annotate 'line', 186
    .lex "self", param_291
    $P292 = param_291."!PREFIX__!protoregex"("terminator")
    .return ($P292)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<;>"  :subid("59_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx294_tgt
    .local int rx294_pos
    .local int rx294_off
    .local int rx294_eos
    .local int rx294_rep
    .local pmc rx294_cur
    .local pmc rx294_debug
    (rx294_cur, rx294_pos, rx294_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx294_cur
    .local pmc match
    .lex "$/", match
    length rx294_eos, rx294_tgt
    gt rx294_pos, rx294_eos, rx294_done
    set rx294_off, 0
    lt rx294_pos, 2, rx294_start
    sub rx294_off, rx294_pos, 1
    substr rx294_tgt, rx294_tgt, rx294_off
  rx294_start:
    eq $I10, 1, rx294_restart
    if_null rx294_debug, debug_696
    rx294_cur."!cursor_debug"("START", "terminator:sym<;>")
  debug_696:
    $I10 = self.'from'()
    ne $I10, -1, rxscan297_done
    goto rxscan297_scan
  rxscan297_loop:
    (rx294_pos) = rx294_cur."from"()
    inc rx294_pos
    rx294_cur."!cursor_from"(rx294_pos)
    ge rx294_pos, rx294_eos, rxscan297_done
  rxscan297_scan:
    set_addr $I10, rxscan297_loop
    rx294_cur."!mark_push"(0, rx294_pos, $I10)
  rxscan297_done:
.annotate 'line', 188
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx294_pos, rx294_off
    substr $S10, rx294_tgt, $I10, 1
    index $I11, ";", $S10
    lt $I11, 0, rx294_fail
  # rx pass
    rx294_cur."!cursor_pass"(rx294_pos, "terminator:sym<;>")
    if_null rx294_debug, debug_697
    rx294_cur."!cursor_debug"("PASS", "terminator:sym<;>", " at pos=", rx294_pos)
  debug_697:
    .return (rx294_cur)
  rx294_restart:
.annotate 'line', 10
    if_null rx294_debug, debug_698
    rx294_cur."!cursor_debug"("NEXT", "terminator:sym<;>")
  debug_698:
  rx294_fail:
    (rx294_rep, rx294_pos, $I10, $P10) = rx294_cur."!mark_fail"(0)
    lt rx294_pos, -1, rx294_done
    eq rx294_pos, -1, rx294_fail
    jump $I10
  rx294_done:
    rx294_cur."!cursor_fail"()
    if_null rx294_debug, debug_699
    rx294_cur."!cursor_debug"("FAIL", "terminator:sym<;>")
  debug_699:
    .return (rx294_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<;>"  :nsentry("!PREFIX__terminator:sym<;>") :subid("60_1302110486.758") :method
.annotate 'line', 10
    new $P296, "ResizablePMCArray"
    push $P296, ";"
    .return ($P296)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<}>"  :subid("61_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx299_tgt
    .local int rx299_pos
    .local int rx299_off
    .local int rx299_eos
    .local int rx299_rep
    .local pmc rx299_cur
    .local pmc rx299_debug
    (rx299_cur, rx299_pos, rx299_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx299_cur
    .local pmc match
    .lex "$/", match
    length rx299_eos, rx299_tgt
    gt rx299_pos, rx299_eos, rx299_done
    set rx299_off, 0
    lt rx299_pos, 2, rx299_start
    sub rx299_off, rx299_pos, 1
    substr rx299_tgt, rx299_tgt, rx299_off
  rx299_start:
    eq $I10, 1, rx299_restart
    if_null rx299_debug, debug_700
    rx299_cur."!cursor_debug"("START", "terminator:sym<}>")
  debug_700:
    $I10 = self.'from'()
    ne $I10, -1, rxscan302_done
    goto rxscan302_scan
  rxscan302_loop:
    (rx299_pos) = rx299_cur."from"()
    inc rx299_pos
    rx299_cur."!cursor_from"(rx299_pos)
    ge rx299_pos, rx299_eos, rxscan302_done
  rxscan302_scan:
    set_addr $I10, rxscan302_loop
    rx299_cur."!mark_push"(0, rx299_pos, $I10)
  rxscan302_done:
.annotate 'line', 189
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx299_pos, rx299_off
    substr $S10, rx299_tgt, $I10, 1
    index $I11, "}", $S10
    lt $I11, 0, rx299_fail
  # rx pass
    rx299_cur."!cursor_pass"(rx299_pos, "terminator:sym<}>")
    if_null rx299_debug, debug_701
    rx299_cur."!cursor_debug"("PASS", "terminator:sym<}>", " at pos=", rx299_pos)
  debug_701:
    .return (rx299_cur)
  rx299_restart:
.annotate 'line', 10
    if_null rx299_debug, debug_702
    rx299_cur."!cursor_debug"("NEXT", "terminator:sym<}>")
  debug_702:
  rx299_fail:
    (rx299_rep, rx299_pos, $I10, $P10) = rx299_cur."!mark_fail"(0)
    lt rx299_pos, -1, rx299_done
    eq rx299_pos, -1, rx299_fail
    jump $I10
  rx299_done:
    rx299_cur."!cursor_fail"()
    if_null rx299_debug, debug_703
    rx299_cur."!cursor_debug"("FAIL", "terminator:sym<}>")
  debug_703:
    .return (rx299_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<}>"  :nsentry("!PREFIX__terminator:sym<}>") :subid("62_1302110486.758") :method
.annotate 'line', 10
    new $P301, "ResizablePMCArray"
    push $P301, "}"
    .return ($P301)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control"  :subid("63_1302110486.758")
    .param pmc param_304
.annotate 'line', 193
    .lex "self", param_304
    $P305 = param_304."!protoregex"("statement_control")
    .return ($P305)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control"  :subid("64_1302110486.758")
    .param pmc param_307
.annotate 'line', 193
    .lex "self", param_307
    $P308 = param_307."!PREFIX__!protoregex"("statement_control")
    .return ($P308)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<use>"  :subid("65_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx310_tgt
    .local int rx310_pos
    .local int rx310_off
    .local int rx310_eos
    .local int rx310_rep
    .local pmc rx310_cur
    .local pmc rx310_debug
    (rx310_cur, rx310_pos, rx310_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx310_cur
    .local pmc match
    .lex "$/", match
    length rx310_eos, rx310_tgt
    gt rx310_pos, rx310_eos, rx310_done
    set rx310_off, 0
    lt rx310_pos, 2, rx310_start
    sub rx310_off, rx310_pos, 1
    substr rx310_tgt, rx310_tgt, rx310_off
  rx310_start:
    eq $I10, 1, rx310_restart
    if_null rx310_debug, debug_704
    rx310_cur."!cursor_debug"("START", "statement_control:sym<use>")
  debug_704:
    $I10 = self.'from'()
    ne $I10, -1, rxscan313_done
    goto rxscan313_scan
  rxscan313_loop:
    (rx310_pos) = rx310_cur."from"()
    inc rx310_pos
    rx310_cur."!cursor_from"(rx310_pos)
    ge rx310_pos, rx310_eos, rxscan313_done
  rxscan313_scan:
    set_addr $I10, rxscan313_loop
    rx310_cur."!mark_push"(0, rx310_pos, $I10)
  rxscan313_done:
.annotate 'line', 196
  # rx subcapture "sym"
    set_addr $I10, rxcap_314_fail
    rx310_cur."!mark_push"(0, rx310_pos, $I10)
  # rx literal  "use"
    add $I11, rx310_pos, 3
    gt $I11, rx310_eos, rx310_fail
    sub $I11, rx310_pos, rx310_off
    substr $S10, rx310_tgt, $I11, 3
    ne $S10, "use", rx310_fail
    add rx310_pos, 3
    set_addr $I10, rxcap_314_fail
    ($I12, $I11) = rx310_cur."!mark_peek"($I10)
    rx310_cur."!cursor_pos"($I11)
    ($P10) = rx310_cur."!cursor_start"()
    $P10."!cursor_pass"(rx310_pos, "")
    rx310_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_314_done
  rxcap_314_fail:
    goto rx310_fail
  rxcap_314_done:
  # rx charclass s
    ge rx310_pos, rx310_eos, rx310_fail
    sub $I10, rx310_pos, rx310_off
    is_cclass $I11, 32, rx310_tgt, $I10
    unless $I11, rx310_fail
    inc rx310_pos
  # rx subrule "ws" subtype=method negate=
    rx310_cur."!cursor_pos"(rx310_pos)
    $P10 = rx310_cur."ws"()
    unless $P10, rx310_fail
    rx310_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx310_cur."!cursor_pos"(rx310_pos)
    $P10 = rx310_cur."name"()
    unless $P10, rx310_fail
    rx310_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx310_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx310_cur."!cursor_pos"(rx310_pos)
    $P10 = rx310_cur."ws"()
    unless $P10, rx310_fail
    rx310_pos = $P10."pos"()
.annotate 'line', 195
  # rx pass
    rx310_cur."!cursor_pass"(rx310_pos, "statement_control:sym<use>")
    if_null rx310_debug, debug_705
    rx310_cur."!cursor_debug"("PASS", "statement_control:sym<use>", " at pos=", rx310_pos)
  debug_705:
    .return (rx310_cur)
  rx310_restart:
.annotate 'line', 10
    if_null rx310_debug, debug_706
    rx310_cur."!cursor_debug"("NEXT", "statement_control:sym<use>")
  debug_706:
  rx310_fail:
    (rx310_rep, rx310_pos, $I10, $P10) = rx310_cur."!mark_fail"(0)
    lt rx310_pos, -1, rx310_done
    eq rx310_pos, -1, rx310_fail
    jump $I10
  rx310_done:
    rx310_cur."!cursor_fail"()
    if_null rx310_debug, debug_707
    rx310_cur."!cursor_debug"("FAIL", "statement_control:sym<use>")
  debug_707:
    .return (rx310_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<use>"  :nsentry("!PREFIX__statement_control:sym<use>") :subid("66_1302110486.758") :method
.annotate 'line', 10
    new $P312, "ResizablePMCArray"
    push $P312, "use"
    .return ($P312)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<if>"  :subid("67_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx318_tgt
    .local int rx318_pos
    .local int rx318_off
    .local int rx318_eos
    .local int rx318_rep
    .local pmc rx318_cur
    .local pmc rx318_debug
    (rx318_cur, rx318_pos, rx318_tgt, $I10) = self."!cursor_start"()
    rx318_cur."!cursor_caparray"("xblock", "else")
    .lex unicode:"$\x{a2}", rx318_cur
    .local pmc match
    .lex "$/", match
    length rx318_eos, rx318_tgt
    gt rx318_pos, rx318_eos, rx318_done
    set rx318_off, 0
    lt rx318_pos, 2, rx318_start
    sub rx318_off, rx318_pos, 1
    substr rx318_tgt, rx318_tgt, rx318_off
  rx318_start:
    eq $I10, 1, rx318_restart
    if_null rx318_debug, debug_708
    rx318_cur."!cursor_debug"("START", "statement_control:sym<if>")
  debug_708:
    $I10 = self.'from'()
    ne $I10, -1, rxscan321_done
    goto rxscan321_scan
  rxscan321_loop:
    (rx318_pos) = rx318_cur."from"()
    inc rx318_pos
    rx318_cur."!cursor_from"(rx318_pos)
    ge rx318_pos, rx318_eos, rxscan321_done
  rxscan321_scan:
    set_addr $I10, rxscan321_loop
    rx318_cur."!mark_push"(0, rx318_pos, $I10)
  rxscan321_done:
.annotate 'line', 200
  # rx subcapture "sym"
    set_addr $I10, rxcap_322_fail
    rx318_cur."!mark_push"(0, rx318_pos, $I10)
  # rx literal  "if"
    add $I11, rx318_pos, 2
    gt $I11, rx318_eos, rx318_fail
    sub $I11, rx318_pos, rx318_off
    substr $S10, rx318_tgt, $I11, 2
    ne $S10, "if", rx318_fail
    add rx318_pos, 2
    set_addr $I10, rxcap_322_fail
    ($I12, $I11) = rx318_cur."!mark_peek"($I10)
    rx318_cur."!cursor_pos"($I11)
    ($P10) = rx318_cur."!cursor_start"()
    $P10."!cursor_pass"(rx318_pos, "")
    rx318_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_322_done
  rxcap_322_fail:
    goto rx318_fail
  rxcap_322_done:
  # rx charclass s
    ge rx318_pos, rx318_eos, rx318_fail
    sub $I10, rx318_pos, rx318_off
    is_cclass $I11, 32, rx318_tgt, $I10
    unless $I11, rx318_fail
    inc rx318_pos
  # rx subrule "ws" subtype=method negate=
    rx318_cur."!cursor_pos"(rx318_pos)
    $P10 = rx318_cur."ws"()
    unless $P10, rx318_fail
    rx318_pos = $P10."pos"()
.annotate 'line', 201
  # rx subrule "xblock" subtype=capture negate=
    rx318_cur."!cursor_pos"(rx318_pos)
    $P10 = rx318_cur."xblock"()
    unless $P10, rx318_fail
    rx318_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx318_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx318_cur."!cursor_pos"(rx318_pos)
    $P10 = rx318_cur."ws"()
    unless $P10, rx318_fail
    rx318_pos = $P10."pos"()
.annotate 'line', 202
  # rx rxquantr325 ** 0..*
    set_addr $I10, rxquantr325_done
    rx318_cur."!mark_push"(0, rx318_pos, $I10)
  rxquantr325_loop:
  # rx subrule "ws" subtype=method negate=
    rx318_cur."!cursor_pos"(rx318_pos)
    $P10 = rx318_cur."ws"()
    unless $P10, rx318_fail
    rx318_pos = $P10."pos"()
  # rx literal  "elsif"
    add $I11, rx318_pos, 5
    gt $I11, rx318_eos, rx318_fail
    sub $I11, rx318_pos, rx318_off
    substr $S10, rx318_tgt, $I11, 5
    ne $S10, "elsif", rx318_fail
    add rx318_pos, 5
  # rx charclass s
    ge rx318_pos, rx318_eos, rx318_fail
    sub $I10, rx318_pos, rx318_off
    is_cclass $I11, 32, rx318_tgt, $I10
    unless $I11, rx318_fail
    inc rx318_pos
  # rx subrule "ws" subtype=method negate=
    rx318_cur."!cursor_pos"(rx318_pos)
    $P10 = rx318_cur."ws"()
    unless $P10, rx318_fail
    rx318_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx318_cur."!cursor_pos"(rx318_pos)
    $P10 = rx318_cur."xblock"()
    unless $P10, rx318_fail
    rx318_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx318_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx318_cur."!cursor_pos"(rx318_pos)
    $P10 = rx318_cur."ws"()
    unless $P10, rx318_fail
    rx318_pos = $P10."pos"()
    set_addr $I10, rxquantr325_done
    (rx318_rep) = rx318_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr325_done
    rx318_cur."!mark_push"(rx318_rep, rx318_pos, $I10)
    goto rxquantr325_loop
  rxquantr325_done:
  # rx subrule "ws" subtype=method negate=
    rx318_cur."!cursor_pos"(rx318_pos)
    $P10 = rx318_cur."ws"()
    unless $P10, rx318_fail
    rx318_pos = $P10."pos"()
.annotate 'line', 203
  # rx rxquantr330 ** 0..1
    set_addr $I10, rxquantr330_done
    rx318_cur."!mark_push"(0, rx318_pos, $I10)
  rxquantr330_loop:
  # rx subrule "ws" subtype=method negate=
    rx318_cur."!cursor_pos"(rx318_pos)
    $P10 = rx318_cur."ws"()
    unless $P10, rx318_fail
    rx318_pos = $P10."pos"()
  # rx literal  "else"
    add $I11, rx318_pos, 4
    gt $I11, rx318_eos, rx318_fail
    sub $I11, rx318_pos, rx318_off
    substr $S10, rx318_tgt, $I11, 4
    ne $S10, "else", rx318_fail
    add rx318_pos, 4
  # rx charclass s
    ge rx318_pos, rx318_eos, rx318_fail
    sub $I10, rx318_pos, rx318_off
    is_cclass $I11, 32, rx318_tgt, $I10
    unless $I11, rx318_fail
    inc rx318_pos
  # rx subrule "ws" subtype=method negate=
    rx318_cur."!cursor_pos"(rx318_pos)
    $P10 = rx318_cur."ws"()
    unless $P10, rx318_fail
    rx318_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx318_cur."!cursor_pos"(rx318_pos)
    $P10 = rx318_cur."pblock"()
    unless $P10, rx318_fail
    rx318_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("else")
    rx318_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx318_cur."!cursor_pos"(rx318_pos)
    $P10 = rx318_cur."ws"()
    unless $P10, rx318_fail
    rx318_pos = $P10."pos"()
    set_addr $I10, rxquantr330_done
    (rx318_rep) = rx318_cur."!mark_commit"($I10)
  rxquantr330_done:
  # rx subrule "ws" subtype=method negate=
    rx318_cur."!cursor_pos"(rx318_pos)
    $P10 = rx318_cur."ws"()
    unless $P10, rx318_fail
    rx318_pos = $P10."pos"()
.annotate 'line', 199
  # rx pass
    rx318_cur."!cursor_pass"(rx318_pos, "statement_control:sym<if>")
    if_null rx318_debug, debug_709
    rx318_cur."!cursor_debug"("PASS", "statement_control:sym<if>", " at pos=", rx318_pos)
  debug_709:
    .return (rx318_cur)
  rx318_restart:
.annotate 'line', 10
    if_null rx318_debug, debug_710
    rx318_cur."!cursor_debug"("NEXT", "statement_control:sym<if>")
  debug_710:
  rx318_fail:
    (rx318_rep, rx318_pos, $I10, $P10) = rx318_cur."!mark_fail"(0)
    lt rx318_pos, -1, rx318_done
    eq rx318_pos, -1, rx318_fail
    jump $I10
  rx318_done:
    rx318_cur."!cursor_fail"()
    if_null rx318_debug, debug_711
    rx318_cur."!cursor_debug"("FAIL", "statement_control:sym<if>")
  debug_711:
    .return (rx318_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<if>"  :nsentry("!PREFIX__statement_control:sym<if>") :subid("68_1302110486.758") :method
.annotate 'line', 10
    new $P320, "ResizablePMCArray"
    push $P320, "if"
    .return ($P320)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<unless>"  :subid("69_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .const 'Sub' $P346 = "71_1302110486.758" 
    capture_lex $P346
    .local string rx336_tgt
    .local int rx336_pos
    .local int rx336_off
    .local int rx336_eos
    .local int rx336_rep
    .local pmc rx336_cur
    .local pmc rx336_debug
    (rx336_cur, rx336_pos, rx336_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx336_cur
    .local pmc match
    .lex "$/", match
    length rx336_eos, rx336_tgt
    gt rx336_pos, rx336_eos, rx336_done
    set rx336_off, 0
    lt rx336_pos, 2, rx336_start
    sub rx336_off, rx336_pos, 1
    substr rx336_tgt, rx336_tgt, rx336_off
  rx336_start:
    eq $I10, 1, rx336_restart
    if_null rx336_debug, debug_712
    rx336_cur."!cursor_debug"("START", "statement_control:sym<unless>")
  debug_712:
    $I10 = self.'from'()
    ne $I10, -1, rxscan339_done
    goto rxscan339_scan
  rxscan339_loop:
    (rx336_pos) = rx336_cur."from"()
    inc rx336_pos
    rx336_cur."!cursor_from"(rx336_pos)
    ge rx336_pos, rx336_eos, rxscan339_done
  rxscan339_scan:
    set_addr $I10, rxscan339_loop
    rx336_cur."!mark_push"(0, rx336_pos, $I10)
  rxscan339_done:
.annotate 'line', 207
  # rx subcapture "sym"
    set_addr $I10, rxcap_340_fail
    rx336_cur."!mark_push"(0, rx336_pos, $I10)
  # rx literal  "unless"
    add $I11, rx336_pos, 6
    gt $I11, rx336_eos, rx336_fail
    sub $I11, rx336_pos, rx336_off
    substr $S10, rx336_tgt, $I11, 6
    ne $S10, "unless", rx336_fail
    add rx336_pos, 6
    set_addr $I10, rxcap_340_fail
    ($I12, $I11) = rx336_cur."!mark_peek"($I10)
    rx336_cur."!cursor_pos"($I11)
    ($P10) = rx336_cur."!cursor_start"()
    $P10."!cursor_pass"(rx336_pos, "")
    rx336_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_340_done
  rxcap_340_fail:
    goto rx336_fail
  rxcap_340_done:
  # rx charclass s
    ge rx336_pos, rx336_eos, rx336_fail
    sub $I10, rx336_pos, rx336_off
    is_cclass $I11, 32, rx336_tgt, $I10
    unless $I11, rx336_fail
    inc rx336_pos
  # rx subrule "ws" subtype=method negate=
    rx336_cur."!cursor_pos"(rx336_pos)
    $P10 = rx336_cur."ws"()
    unless $P10, rx336_fail
    rx336_pos = $P10."pos"()
.annotate 'line', 208
  # rx subrule "xblock" subtype=capture negate=
    rx336_cur."!cursor_pos"(rx336_pos)
    $P10 = rx336_cur."xblock"()
    unless $P10, rx336_fail
    rx336_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx336_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx336_cur."!cursor_pos"(rx336_pos)
    $P10 = rx336_cur."ws"()
    unless $P10, rx336_fail
    rx336_pos = $P10."pos"()
  alt343_0:
.annotate 'line', 209
    set_addr $I10, alt343_1
    rx336_cur."!mark_push"(0, rx336_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx336_cur."!cursor_pos"(rx336_pos)
    $P10 = rx336_cur."ws"()
    unless $P10, rx336_fail
    rx336_pos = $P10."pos"()
  # rx subrule "before" subtype=zerowidth negate=1
    rx336_cur."!cursor_pos"(rx336_pos)
    .const 'Sub' $P346 = "71_1302110486.758" 
    capture_lex $P346
    $P10 = rx336_cur."before"($P346)
    if $P10, rx336_fail
  # rx subrule "ws" subtype=method negate=
    rx336_cur."!cursor_pos"(rx336_pos)
    $P10 = rx336_cur."ws"()
    unless $P10, rx336_fail
    rx336_pos = $P10."pos"()
    goto alt343_end
  alt343_1:
  # rx subrule "ws" subtype=method negate=
    rx336_cur."!cursor_pos"(rx336_pos)
    $P10 = rx336_cur."ws"()
    unless $P10, rx336_fail
    rx336_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx336_cur."!cursor_pos"(rx336_pos)
    $P10 = rx336_cur."panic"("unless does not take \"else\", please rewrite using \"if\"")
    unless $P10, rx336_fail
    rx336_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx336_cur."!cursor_pos"(rx336_pos)
    $P10 = rx336_cur."ws"()
    unless $P10, rx336_fail
    rx336_pos = $P10."pos"()
  alt343_end:
  # rx subrule "ws" subtype=method negate=
    rx336_cur."!cursor_pos"(rx336_pos)
    $P10 = rx336_cur."ws"()
    unless $P10, rx336_fail
    rx336_pos = $P10."pos"()
.annotate 'line', 206
  # rx pass
    rx336_cur."!cursor_pass"(rx336_pos, "statement_control:sym<unless>")
    if_null rx336_debug, debug_717
    rx336_cur."!cursor_debug"("PASS", "statement_control:sym<unless>", " at pos=", rx336_pos)
  debug_717:
    .return (rx336_cur)
  rx336_restart:
.annotate 'line', 10
    if_null rx336_debug, debug_718
    rx336_cur."!cursor_debug"("NEXT", "statement_control:sym<unless>")
  debug_718:
  rx336_fail:
    (rx336_rep, rx336_pos, $I10, $P10) = rx336_cur."!mark_fail"(0)
    lt rx336_pos, -1, rx336_done
    eq rx336_pos, -1, rx336_fail
    jump $I10
  rx336_done:
    rx336_cur."!cursor_fail"()
    if_null rx336_debug, debug_719
    rx336_cur."!cursor_debug"("FAIL", "statement_control:sym<unless>")
  debug_719:
    .return (rx336_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<unless>"  :nsentry("!PREFIX__statement_control:sym<unless>") :subid("70_1302110486.758") :method
.annotate 'line', 10
    new $P338, "ResizablePMCArray"
    push $P338, "unless"
    .return ($P338)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block345"  :anon :subid("71_1302110486.758") :method :outer("69_1302110486.758")
.annotate 'line', 209
    .local string rx347_tgt
    .local int rx347_pos
    .local int rx347_off
    .local int rx347_eos
    .local int rx347_rep
    .local pmc rx347_cur
    .local pmc rx347_debug
    (rx347_cur, rx347_pos, rx347_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx347_cur
    .local pmc match
    .lex "$/", match
    length rx347_eos, rx347_tgt
    gt rx347_pos, rx347_eos, rx347_done
    set rx347_off, 0
    lt rx347_pos, 2, rx347_start
    sub rx347_off, rx347_pos, 1
    substr rx347_tgt, rx347_tgt, rx347_off
  rx347_start:
    eq $I10, 1, rx347_restart
    if_null rx347_debug, debug_713
    rx347_cur."!cursor_debug"("START", "")
  debug_713:
    $I10 = self.'from'()
    ne $I10, -1, rxscan348_done
    goto rxscan348_scan
  rxscan348_loop:
    (rx347_pos) = rx347_cur."from"()
    inc rx347_pos
    rx347_cur."!cursor_from"(rx347_pos)
    ge rx347_pos, rx347_eos, rxscan348_done
  rxscan348_scan:
    set_addr $I10, rxscan348_loop
    rx347_cur."!mark_push"(0, rx347_pos, $I10)
  rxscan348_done:
  # rx literal  "else"
    add $I11, rx347_pos, 4
    gt $I11, rx347_eos, rx347_fail
    sub $I11, rx347_pos, rx347_off
    substr $S10, rx347_tgt, $I11, 4
    ne $S10, "else", rx347_fail
    add rx347_pos, 4
  # rx pass
    rx347_cur."!cursor_pass"(rx347_pos, "")
    if_null rx347_debug, debug_714
    rx347_cur."!cursor_debug"("PASS", "", " at pos=", rx347_pos)
  debug_714:
    .return (rx347_cur)
  rx347_restart:
    if_null rx347_debug, debug_715
    rx347_cur."!cursor_debug"("NEXT", "")
  debug_715:
  rx347_fail:
    (rx347_rep, rx347_pos, $I10, $P10) = rx347_cur."!mark_fail"(0)
    lt rx347_pos, -1, rx347_done
    eq rx347_pos, -1, rx347_fail
    jump $I10
  rx347_done:
    rx347_cur."!cursor_fail"()
    if_null rx347_debug, debug_716
    rx347_cur."!cursor_debug"("FAIL", "")
  debug_716:
    .return (rx347_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<while>"  :subid("72_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx354_tgt
    .local int rx354_pos
    .local int rx354_off
    .local int rx354_eos
    .local int rx354_rep
    .local pmc rx354_cur
    .local pmc rx354_debug
    (rx354_cur, rx354_pos, rx354_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx354_cur
    .local pmc match
    .lex "$/", match
    length rx354_eos, rx354_tgt
    gt rx354_pos, rx354_eos, rx354_done
    set rx354_off, 0
    lt rx354_pos, 2, rx354_start
    sub rx354_off, rx354_pos, 1
    substr rx354_tgt, rx354_tgt, rx354_off
  rx354_start:
    eq $I10, 1, rx354_restart
    if_null rx354_debug, debug_720
    rx354_cur."!cursor_debug"("START", "statement_control:sym<while>")
  debug_720:
    $I10 = self.'from'()
    ne $I10, -1, rxscan357_done
    goto rxscan357_scan
  rxscan357_loop:
    (rx354_pos) = rx354_cur."from"()
    inc rx354_pos
    rx354_cur."!cursor_from"(rx354_pos)
    ge rx354_pos, rx354_eos, rxscan357_done
  rxscan357_scan:
    set_addr $I10, rxscan357_loop
    rx354_cur."!mark_push"(0, rx354_pos, $I10)
  rxscan357_done:
.annotate 'line', 213
  # rx subcapture "sym"
    set_addr $I10, rxcap_359_fail
    rx354_cur."!mark_push"(0, rx354_pos, $I10)
  alt358_0:
    set_addr $I10, alt358_1
    rx354_cur."!mark_push"(0, rx354_pos, $I10)
  # rx literal  "while"
    add $I11, rx354_pos, 5
    gt $I11, rx354_eos, rx354_fail
    sub $I11, rx354_pos, rx354_off
    substr $S10, rx354_tgt, $I11, 5
    ne $S10, "while", rx354_fail
    add rx354_pos, 5
    goto alt358_end
  alt358_1:
  # rx literal  "until"
    add $I11, rx354_pos, 5
    gt $I11, rx354_eos, rx354_fail
    sub $I11, rx354_pos, rx354_off
    substr $S10, rx354_tgt, $I11, 5
    ne $S10, "until", rx354_fail
    add rx354_pos, 5
  alt358_end:
    set_addr $I10, rxcap_359_fail
    ($I12, $I11) = rx354_cur."!mark_peek"($I10)
    rx354_cur."!cursor_pos"($I11)
    ($P10) = rx354_cur."!cursor_start"()
    $P10."!cursor_pass"(rx354_pos, "")
    rx354_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_359_done
  rxcap_359_fail:
    goto rx354_fail
  rxcap_359_done:
  # rx charclass s
    ge rx354_pos, rx354_eos, rx354_fail
    sub $I10, rx354_pos, rx354_off
    is_cclass $I11, 32, rx354_tgt, $I10
    unless $I11, rx354_fail
    inc rx354_pos
  # rx subrule "ws" subtype=method negate=
    rx354_cur."!cursor_pos"(rx354_pos)
    $P10 = rx354_cur."ws"()
    unless $P10, rx354_fail
    rx354_pos = $P10."pos"()
.annotate 'line', 214
  # rx subrule "xblock" subtype=capture negate=
    rx354_cur."!cursor_pos"(rx354_pos)
    $P10 = rx354_cur."xblock"()
    unless $P10, rx354_fail
    rx354_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx354_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx354_cur."!cursor_pos"(rx354_pos)
    $P10 = rx354_cur."ws"()
    unless $P10, rx354_fail
    rx354_pos = $P10."pos"()
.annotate 'line', 212
  # rx pass
    rx354_cur."!cursor_pass"(rx354_pos, "statement_control:sym<while>")
    if_null rx354_debug, debug_721
    rx354_cur."!cursor_debug"("PASS", "statement_control:sym<while>", " at pos=", rx354_pos)
  debug_721:
    .return (rx354_cur)
  rx354_restart:
.annotate 'line', 10
    if_null rx354_debug, debug_722
    rx354_cur."!cursor_debug"("NEXT", "statement_control:sym<while>")
  debug_722:
  rx354_fail:
    (rx354_rep, rx354_pos, $I10, $P10) = rx354_cur."!mark_fail"(0)
    lt rx354_pos, -1, rx354_done
    eq rx354_pos, -1, rx354_fail
    jump $I10
  rx354_done:
    rx354_cur."!cursor_fail"()
    if_null rx354_debug, debug_723
    rx354_cur."!cursor_debug"("FAIL", "statement_control:sym<while>")
  debug_723:
    .return (rx354_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<while>"  :nsentry("!PREFIX__statement_control:sym<while>") :subid("73_1302110486.758") :method
.annotate 'line', 10
    new $P356, "ResizablePMCArray"
    push $P356, "until"
    push $P356, "while"
    .return ($P356)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<repeat>"  :subid("74_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx363_tgt
    .local int rx363_pos
    .local int rx363_off
    .local int rx363_eos
    .local int rx363_rep
    .local pmc rx363_cur
    .local pmc rx363_debug
    (rx363_cur, rx363_pos, rx363_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx363_cur
    .local pmc match
    .lex "$/", match
    length rx363_eos, rx363_tgt
    gt rx363_pos, rx363_eos, rx363_done
    set rx363_off, 0
    lt rx363_pos, 2, rx363_start
    sub rx363_off, rx363_pos, 1
    substr rx363_tgt, rx363_tgt, rx363_off
  rx363_start:
    eq $I10, 1, rx363_restart
    if_null rx363_debug, debug_724
    rx363_cur."!cursor_debug"("START", "statement_control:sym<repeat>")
  debug_724:
    $I10 = self.'from'()
    ne $I10, -1, rxscan366_done
    goto rxscan366_scan
  rxscan366_loop:
    (rx363_pos) = rx363_cur."from"()
    inc rx363_pos
    rx363_cur."!cursor_from"(rx363_pos)
    ge rx363_pos, rx363_eos, rxscan366_done
  rxscan366_scan:
    set_addr $I10, rxscan366_loop
    rx363_cur."!mark_push"(0, rx363_pos, $I10)
  rxscan366_done:
.annotate 'line', 218
  # rx subcapture "sym"
    set_addr $I10, rxcap_367_fail
    rx363_cur."!mark_push"(0, rx363_pos, $I10)
  # rx literal  "repeat"
    add $I11, rx363_pos, 6
    gt $I11, rx363_eos, rx363_fail
    sub $I11, rx363_pos, rx363_off
    substr $S10, rx363_tgt, $I11, 6
    ne $S10, "repeat", rx363_fail
    add rx363_pos, 6
    set_addr $I10, rxcap_367_fail
    ($I12, $I11) = rx363_cur."!mark_peek"($I10)
    rx363_cur."!cursor_pos"($I11)
    ($P10) = rx363_cur."!cursor_start"()
    $P10."!cursor_pass"(rx363_pos, "")
    rx363_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_367_done
  rxcap_367_fail:
    goto rx363_fail
  rxcap_367_done:
  # rx charclass s
    ge rx363_pos, rx363_eos, rx363_fail
    sub $I10, rx363_pos, rx363_off
    is_cclass $I11, 32, rx363_tgt, $I10
    unless $I11, rx363_fail
    inc rx363_pos
  # rx subrule "ws" subtype=method negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."ws"()
    unless $P10, rx363_fail
    rx363_pos = $P10."pos"()
  alt369_0:
.annotate 'line', 219
    set_addr $I10, alt369_1
    rx363_cur."!mark_push"(0, rx363_pos, $I10)
.annotate 'line', 220
  # rx subrule "ws" subtype=method negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."ws"()
    unless $P10, rx363_fail
    rx363_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_372_fail
    rx363_cur."!mark_push"(0, rx363_pos, $I10)
  alt371_0:
    set_addr $I10, alt371_1
    rx363_cur."!mark_push"(0, rx363_pos, $I10)
  # rx literal  "while"
    add $I11, rx363_pos, 5
    gt $I11, rx363_eos, rx363_fail
    sub $I11, rx363_pos, rx363_off
    substr $S10, rx363_tgt, $I11, 5
    ne $S10, "while", rx363_fail
    add rx363_pos, 5
    goto alt371_end
  alt371_1:
  # rx literal  "until"
    add $I11, rx363_pos, 5
    gt $I11, rx363_eos, rx363_fail
    sub $I11, rx363_pos, rx363_off
    substr $S10, rx363_tgt, $I11, 5
    ne $S10, "until", rx363_fail
    add rx363_pos, 5
  alt371_end:
    set_addr $I10, rxcap_372_fail
    ($I12, $I11) = rx363_cur."!mark_peek"($I10)
    rx363_cur."!cursor_pos"($I11)
    ($P10) = rx363_cur."!cursor_start"()
    $P10."!cursor_pass"(rx363_pos, "")
    rx363_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_372_done
  rxcap_372_fail:
    goto rx363_fail
  rxcap_372_done:
  # rx charclass s
    ge rx363_pos, rx363_eos, rx363_fail
    sub $I10, rx363_pos, rx363_off
    is_cclass $I11, 32, rx363_tgt, $I10
    unless $I11, rx363_fail
    inc rx363_pos
  # rx subrule "ws" subtype=method negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."ws"()
    unless $P10, rx363_fail
    rx363_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."xblock"()
    unless $P10, rx363_fail
    rx363_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx363_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."ws"()
    unless $P10, rx363_fail
    rx363_pos = $P10."pos"()
    goto alt369_end
  alt369_1:
.annotate 'line', 221
  # rx subrule "ws" subtype=method negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."ws"()
    unless $P10, rx363_fail
    rx363_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."pblock"()
    unless $P10, rx363_fail
    rx363_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx363_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."ws"()
    unless $P10, rx363_fail
    rx363_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_378_fail
    rx363_cur."!mark_push"(0, rx363_pos, $I10)
  alt377_0:
    set_addr $I10, alt377_1
    rx363_cur."!mark_push"(0, rx363_pos, $I10)
  # rx literal  "while"
    add $I11, rx363_pos, 5
    gt $I11, rx363_eos, rx363_fail
    sub $I11, rx363_pos, rx363_off
    substr $S10, rx363_tgt, $I11, 5
    ne $S10, "while", rx363_fail
    add rx363_pos, 5
    goto alt377_end
  alt377_1:
  # rx literal  "until"
    add $I11, rx363_pos, 5
    gt $I11, rx363_eos, rx363_fail
    sub $I11, rx363_pos, rx363_off
    substr $S10, rx363_tgt, $I11, 5
    ne $S10, "until", rx363_fail
    add rx363_pos, 5
  alt377_end:
    set_addr $I10, rxcap_378_fail
    ($I12, $I11) = rx363_cur."!mark_peek"($I10)
    rx363_cur."!cursor_pos"($I11)
    ($P10) = rx363_cur."!cursor_start"()
    $P10."!cursor_pass"(rx363_pos, "")
    rx363_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_378_done
  rxcap_378_fail:
    goto rx363_fail
  rxcap_378_done:
  # rx charclass s
    ge rx363_pos, rx363_eos, rx363_fail
    sub $I10, rx363_pos, rx363_off
    is_cclass $I11, 32, rx363_tgt, $I10
    unless $I11, rx363_fail
    inc rx363_pos
  # rx subrule "ws" subtype=method negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."ws"()
    unless $P10, rx363_fail
    rx363_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."EXPR"()
    unless $P10, rx363_fail
    rx363_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx363_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."ws"()
    unless $P10, rx363_fail
    rx363_pos = $P10."pos"()
  alt369_end:
.annotate 'line', 222
  # rx subrule "ws" subtype=method negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."ws"()
    unless $P10, rx363_fail
    rx363_pos = $P10."pos"()
.annotate 'line', 217
  # rx pass
    rx363_cur."!cursor_pass"(rx363_pos, "statement_control:sym<repeat>")
    if_null rx363_debug, debug_725
    rx363_cur."!cursor_debug"("PASS", "statement_control:sym<repeat>", " at pos=", rx363_pos)
  debug_725:
    .return (rx363_cur)
  rx363_restart:
.annotate 'line', 10
    if_null rx363_debug, debug_726
    rx363_cur."!cursor_debug"("NEXT", "statement_control:sym<repeat>")
  debug_726:
  rx363_fail:
    (rx363_rep, rx363_pos, $I10, $P10) = rx363_cur."!mark_fail"(0)
    lt rx363_pos, -1, rx363_done
    eq rx363_pos, -1, rx363_fail
    jump $I10
  rx363_done:
    rx363_cur."!cursor_fail"()
    if_null rx363_debug, debug_727
    rx363_cur."!cursor_debug"("FAIL", "statement_control:sym<repeat>")
  debug_727:
    .return (rx363_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<repeat>"  :nsentry("!PREFIX__statement_control:sym<repeat>") :subid("75_1302110486.758") :method
.annotate 'line', 10
    new $P365, "ResizablePMCArray"
    push $P365, "repeat"
    .return ($P365)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<for>"  :subid("76_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx383_tgt
    .local int rx383_pos
    .local int rx383_off
    .local int rx383_eos
    .local int rx383_rep
    .local pmc rx383_cur
    .local pmc rx383_debug
    (rx383_cur, rx383_pos, rx383_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx383_cur
    .local pmc match
    .lex "$/", match
    length rx383_eos, rx383_tgt
    gt rx383_pos, rx383_eos, rx383_done
    set rx383_off, 0
    lt rx383_pos, 2, rx383_start
    sub rx383_off, rx383_pos, 1
    substr rx383_tgt, rx383_tgt, rx383_off
  rx383_start:
    eq $I10, 1, rx383_restart
    if_null rx383_debug, debug_728
    rx383_cur."!cursor_debug"("START", "statement_control:sym<for>")
  debug_728:
    $I10 = self.'from'()
    ne $I10, -1, rxscan386_done
    goto rxscan386_scan
  rxscan386_loop:
    (rx383_pos) = rx383_cur."from"()
    inc rx383_pos
    rx383_cur."!cursor_from"(rx383_pos)
    ge rx383_pos, rx383_eos, rxscan386_done
  rxscan386_scan:
    set_addr $I10, rxscan386_loop
    rx383_cur."!mark_push"(0, rx383_pos, $I10)
  rxscan386_done:
.annotate 'line', 226
  # rx subcapture "sym"
    set_addr $I10, rxcap_387_fail
    rx383_cur."!mark_push"(0, rx383_pos, $I10)
  # rx literal  "for"
    add $I11, rx383_pos, 3
    gt $I11, rx383_eos, rx383_fail
    sub $I11, rx383_pos, rx383_off
    substr $S10, rx383_tgt, $I11, 3
    ne $S10, "for", rx383_fail
    add rx383_pos, 3
    set_addr $I10, rxcap_387_fail
    ($I12, $I11) = rx383_cur."!mark_peek"($I10)
    rx383_cur."!cursor_pos"($I11)
    ($P10) = rx383_cur."!cursor_start"()
    $P10."!cursor_pass"(rx383_pos, "")
    rx383_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_387_done
  rxcap_387_fail:
    goto rx383_fail
  rxcap_387_done:
  # rx charclass s
    ge rx383_pos, rx383_eos, rx383_fail
    sub $I10, rx383_pos, rx383_off
    is_cclass $I11, 32, rx383_tgt, $I10
    unless $I11, rx383_fail
    inc rx383_pos
  # rx subrule "ws" subtype=method negate=
    rx383_cur."!cursor_pos"(rx383_pos)
    $P10 = rx383_cur."ws"()
    unless $P10, rx383_fail
    rx383_pos = $P10."pos"()
.annotate 'line', 227
  # rx subrule "xblock" subtype=capture negate=
    rx383_cur."!cursor_pos"(rx383_pos)
    $P10 = rx383_cur."xblock"()
    unless $P10, rx383_fail
    rx383_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx383_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx383_cur."!cursor_pos"(rx383_pos)
    $P10 = rx383_cur."ws"()
    unless $P10, rx383_fail
    rx383_pos = $P10."pos"()
.annotate 'line', 225
  # rx pass
    rx383_cur."!cursor_pass"(rx383_pos, "statement_control:sym<for>")
    if_null rx383_debug, debug_729
    rx383_cur."!cursor_debug"("PASS", "statement_control:sym<for>", " at pos=", rx383_pos)
  debug_729:
    .return (rx383_cur)
  rx383_restart:
.annotate 'line', 10
    if_null rx383_debug, debug_730
    rx383_cur."!cursor_debug"("NEXT", "statement_control:sym<for>")
  debug_730:
  rx383_fail:
    (rx383_rep, rx383_pos, $I10, $P10) = rx383_cur."!mark_fail"(0)
    lt rx383_pos, -1, rx383_done
    eq rx383_pos, -1, rx383_fail
    jump $I10
  rx383_done:
    rx383_cur."!cursor_fail"()
    if_null rx383_debug, debug_731
    rx383_cur."!cursor_debug"("FAIL", "statement_control:sym<for>")
  debug_731:
    .return (rx383_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<for>"  :nsentry("!PREFIX__statement_control:sym<for>") :subid("77_1302110486.758") :method
.annotate 'line', 10
    new $P385, "ResizablePMCArray"
    push $P385, "for"
    .return ($P385)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CATCH>"  :subid("78_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx391_tgt
    .local int rx391_pos
    .local int rx391_off
    .local int rx391_eos
    .local int rx391_rep
    .local pmc rx391_cur
    .local pmc rx391_debug
    (rx391_cur, rx391_pos, rx391_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx391_cur
    .local pmc match
    .lex "$/", match
    length rx391_eos, rx391_tgt
    gt rx391_pos, rx391_eos, rx391_done
    set rx391_off, 0
    lt rx391_pos, 2, rx391_start
    sub rx391_off, rx391_pos, 1
    substr rx391_tgt, rx391_tgt, rx391_off
  rx391_start:
    eq $I10, 1, rx391_restart
    if_null rx391_debug, debug_732
    rx391_cur."!cursor_debug"("START", "statement_control:sym<CATCH>")
  debug_732:
    $I10 = self.'from'()
    ne $I10, -1, rxscan394_done
    goto rxscan394_scan
  rxscan394_loop:
    (rx391_pos) = rx391_cur."from"()
    inc rx391_pos
    rx391_cur."!cursor_from"(rx391_pos)
    ge rx391_pos, rx391_eos, rxscan394_done
  rxscan394_scan:
    set_addr $I10, rxscan394_loop
    rx391_cur."!mark_push"(0, rx391_pos, $I10)
  rxscan394_done:
.annotate 'line', 231
  # rx subcapture "sym"
    set_addr $I10, rxcap_395_fail
    rx391_cur."!mark_push"(0, rx391_pos, $I10)
  # rx literal  "CATCH"
    add $I11, rx391_pos, 5
    gt $I11, rx391_eos, rx391_fail
    sub $I11, rx391_pos, rx391_off
    substr $S10, rx391_tgt, $I11, 5
    ne $S10, "CATCH", rx391_fail
    add rx391_pos, 5
    set_addr $I10, rxcap_395_fail
    ($I12, $I11) = rx391_cur."!mark_peek"($I10)
    rx391_cur."!cursor_pos"($I11)
    ($P10) = rx391_cur."!cursor_start"()
    $P10."!cursor_pass"(rx391_pos, "")
    rx391_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_395_done
  rxcap_395_fail:
    goto rx391_fail
  rxcap_395_done:
  # rx charclass s
    ge rx391_pos, rx391_eos, rx391_fail
    sub $I10, rx391_pos, rx391_off
    is_cclass $I11, 32, rx391_tgt, $I10
    unless $I11, rx391_fail
    inc rx391_pos
  # rx subrule "ws" subtype=method negate=
    rx391_cur."!cursor_pos"(rx391_pos)
    $P10 = rx391_cur."ws"()
    unless $P10, rx391_fail
    rx391_pos = $P10."pos"()
.annotate 'line', 232
  # rx subrule "block" subtype=capture negate=
    rx391_cur."!cursor_pos"(rx391_pos)
    $P10 = rx391_cur."block"()
    unless $P10, rx391_fail
    rx391_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx391_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx391_cur."!cursor_pos"(rx391_pos)
    $P10 = rx391_cur."ws"()
    unless $P10, rx391_fail
    rx391_pos = $P10."pos"()
.annotate 'line', 230
  # rx pass
    rx391_cur."!cursor_pass"(rx391_pos, "statement_control:sym<CATCH>")
    if_null rx391_debug, debug_733
    rx391_cur."!cursor_debug"("PASS", "statement_control:sym<CATCH>", " at pos=", rx391_pos)
  debug_733:
    .return (rx391_cur)
  rx391_restart:
.annotate 'line', 10
    if_null rx391_debug, debug_734
    rx391_cur."!cursor_debug"("NEXT", "statement_control:sym<CATCH>")
  debug_734:
  rx391_fail:
    (rx391_rep, rx391_pos, $I10, $P10) = rx391_cur."!mark_fail"(0)
    lt rx391_pos, -1, rx391_done
    eq rx391_pos, -1, rx391_fail
    jump $I10
  rx391_done:
    rx391_cur."!cursor_fail"()
    if_null rx391_debug, debug_735
    rx391_cur."!cursor_debug"("FAIL", "statement_control:sym<CATCH>")
  debug_735:
    .return (rx391_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CATCH>"  :nsentry("!PREFIX__statement_control:sym<CATCH>") :subid("79_1302110486.758") :method
.annotate 'line', 10
    new $P393, "ResizablePMCArray"
    push $P393, "CATCH"
    .return ($P393)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CONTROL>"  :subid("80_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx399_tgt
    .local int rx399_pos
    .local int rx399_off
    .local int rx399_eos
    .local int rx399_rep
    .local pmc rx399_cur
    .local pmc rx399_debug
    (rx399_cur, rx399_pos, rx399_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx399_cur
    .local pmc match
    .lex "$/", match
    length rx399_eos, rx399_tgt
    gt rx399_pos, rx399_eos, rx399_done
    set rx399_off, 0
    lt rx399_pos, 2, rx399_start
    sub rx399_off, rx399_pos, 1
    substr rx399_tgt, rx399_tgt, rx399_off
  rx399_start:
    eq $I10, 1, rx399_restart
    if_null rx399_debug, debug_736
    rx399_cur."!cursor_debug"("START", "statement_control:sym<CONTROL>")
  debug_736:
    $I10 = self.'from'()
    ne $I10, -1, rxscan402_done
    goto rxscan402_scan
  rxscan402_loop:
    (rx399_pos) = rx399_cur."from"()
    inc rx399_pos
    rx399_cur."!cursor_from"(rx399_pos)
    ge rx399_pos, rx399_eos, rxscan402_done
  rxscan402_scan:
    set_addr $I10, rxscan402_loop
    rx399_cur."!mark_push"(0, rx399_pos, $I10)
  rxscan402_done:
.annotate 'line', 236
  # rx subcapture "sym"
    set_addr $I10, rxcap_403_fail
    rx399_cur."!mark_push"(0, rx399_pos, $I10)
  # rx literal  "CONTROL"
    add $I11, rx399_pos, 7
    gt $I11, rx399_eos, rx399_fail
    sub $I11, rx399_pos, rx399_off
    substr $S10, rx399_tgt, $I11, 7
    ne $S10, "CONTROL", rx399_fail
    add rx399_pos, 7
    set_addr $I10, rxcap_403_fail
    ($I12, $I11) = rx399_cur."!mark_peek"($I10)
    rx399_cur."!cursor_pos"($I11)
    ($P10) = rx399_cur."!cursor_start"()
    $P10."!cursor_pass"(rx399_pos, "")
    rx399_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_403_done
  rxcap_403_fail:
    goto rx399_fail
  rxcap_403_done:
  # rx charclass s
    ge rx399_pos, rx399_eos, rx399_fail
    sub $I10, rx399_pos, rx399_off
    is_cclass $I11, 32, rx399_tgt, $I10
    unless $I11, rx399_fail
    inc rx399_pos
  # rx subrule "ws" subtype=method negate=
    rx399_cur."!cursor_pos"(rx399_pos)
    $P10 = rx399_cur."ws"()
    unless $P10, rx399_fail
    rx399_pos = $P10."pos"()
.annotate 'line', 237
  # rx subrule "block" subtype=capture negate=
    rx399_cur."!cursor_pos"(rx399_pos)
    $P10 = rx399_cur."block"()
    unless $P10, rx399_fail
    rx399_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx399_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx399_cur."!cursor_pos"(rx399_pos)
    $P10 = rx399_cur."ws"()
    unless $P10, rx399_fail
    rx399_pos = $P10."pos"()
.annotate 'line', 235
  # rx pass
    rx399_cur."!cursor_pass"(rx399_pos, "statement_control:sym<CONTROL>")
    if_null rx399_debug, debug_737
    rx399_cur."!cursor_debug"("PASS", "statement_control:sym<CONTROL>", " at pos=", rx399_pos)
  debug_737:
    .return (rx399_cur)
  rx399_restart:
.annotate 'line', 10
    if_null rx399_debug, debug_738
    rx399_cur."!cursor_debug"("NEXT", "statement_control:sym<CONTROL>")
  debug_738:
  rx399_fail:
    (rx399_rep, rx399_pos, $I10, $P10) = rx399_cur."!mark_fail"(0)
    lt rx399_pos, -1, rx399_done
    eq rx399_pos, -1, rx399_fail
    jump $I10
  rx399_done:
    rx399_cur."!cursor_fail"()
    if_null rx399_debug, debug_739
    rx399_cur."!cursor_debug"("FAIL", "statement_control:sym<CONTROL>")
  debug_739:
    .return (rx399_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CONTROL>"  :nsentry("!PREFIX__statement_control:sym<CONTROL>") :subid("81_1302110486.758") :method
.annotate 'line', 10
    new $P401, "ResizablePMCArray"
    push $P401, "CONTROL"
    .return ($P401)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix"  :subid("82_1302110486.758")
    .param pmc param_407
.annotate 'line', 240
    .lex "self", param_407
    $P408 = param_407."!protoregex"("statement_prefix")
    .return ($P408)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix"  :subid("83_1302110486.758")
    .param pmc param_410
.annotate 'line', 240
    .lex "self", param_410
    $P411 = param_410."!PREFIX__!protoregex"("statement_prefix")
    .return ($P411)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<INIT>"  :subid("84_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx413_tgt
    .local int rx413_pos
    .local int rx413_off
    .local int rx413_eos
    .local int rx413_rep
    .local pmc rx413_cur
    .local pmc rx413_debug
    (rx413_cur, rx413_pos, rx413_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx413_cur
    .local pmc match
    .lex "$/", match
    length rx413_eos, rx413_tgt
    gt rx413_pos, rx413_eos, rx413_done
    set rx413_off, 0
    lt rx413_pos, 2, rx413_start
    sub rx413_off, rx413_pos, 1
    substr rx413_tgt, rx413_tgt, rx413_off
  rx413_start:
    eq $I10, 1, rx413_restart
    if_null rx413_debug, debug_740
    rx413_cur."!cursor_debug"("START", "statement_prefix:sym<INIT>")
  debug_740:
    $I10 = self.'from'()
    ne $I10, -1, rxscan417_done
    goto rxscan417_scan
  rxscan417_loop:
    (rx413_pos) = rx413_cur."from"()
    inc rx413_pos
    rx413_cur."!cursor_from"(rx413_pos)
    ge rx413_pos, rx413_eos, rxscan417_done
  rxscan417_scan:
    set_addr $I10, rxscan417_loop
    rx413_cur."!mark_push"(0, rx413_pos, $I10)
  rxscan417_done:
.annotate 'line', 241
  # rx subcapture "sym"
    set_addr $I10, rxcap_418_fail
    rx413_cur."!mark_push"(0, rx413_pos, $I10)
  # rx literal  "INIT"
    add $I11, rx413_pos, 4
    gt $I11, rx413_eos, rx413_fail
    sub $I11, rx413_pos, rx413_off
    substr $S10, rx413_tgt, $I11, 4
    ne $S10, "INIT", rx413_fail
    add rx413_pos, 4
    set_addr $I10, rxcap_418_fail
    ($I12, $I11) = rx413_cur."!mark_peek"($I10)
    rx413_cur."!cursor_pos"($I11)
    ($P10) = rx413_cur."!cursor_start"()
    $P10."!cursor_pass"(rx413_pos, "")
    rx413_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_418_done
  rxcap_418_fail:
    goto rx413_fail
  rxcap_418_done:
  # rx subrule "blorst" subtype=capture negate=
    rx413_cur."!cursor_pos"(rx413_pos)
    $P10 = rx413_cur."blorst"()
    unless $P10, rx413_fail
    rx413_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx413_pos = $P10."pos"()
  # rx pass
    rx413_cur."!cursor_pass"(rx413_pos, "statement_prefix:sym<INIT>")
    if_null rx413_debug, debug_741
    rx413_cur."!cursor_debug"("PASS", "statement_prefix:sym<INIT>", " at pos=", rx413_pos)
  debug_741:
    .return (rx413_cur)
  rx413_restart:
.annotate 'line', 10
    if_null rx413_debug, debug_742
    rx413_cur."!cursor_debug"("NEXT", "statement_prefix:sym<INIT>")
  debug_742:
  rx413_fail:
    (rx413_rep, rx413_pos, $I10, $P10) = rx413_cur."!mark_fail"(0)
    lt rx413_pos, -1, rx413_done
    eq rx413_pos, -1, rx413_fail
    jump $I10
  rx413_done:
    rx413_cur."!cursor_fail"()
    if_null rx413_debug, debug_743
    rx413_cur."!cursor_debug"("FAIL", "statement_prefix:sym<INIT>")
  debug_743:
    .return (rx413_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<INIT>"  :nsentry("!PREFIX__statement_prefix:sym<INIT>") :subid("85_1302110486.758") :method
.annotate 'line', 10
    $P415 = self."!PREFIX__!subrule"("blorst", "INIT")
    new $P416, "ResizablePMCArray"
    push $P416, $P415
    .return ($P416)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<try>"  :subid("86_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx420_tgt
    .local int rx420_pos
    .local int rx420_off
    .local int rx420_eos
    .local int rx420_rep
    .local pmc rx420_cur
    .local pmc rx420_debug
    (rx420_cur, rx420_pos, rx420_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx420_cur
    .local pmc match
    .lex "$/", match
    length rx420_eos, rx420_tgt
    gt rx420_pos, rx420_eos, rx420_done
    set rx420_off, 0
    lt rx420_pos, 2, rx420_start
    sub rx420_off, rx420_pos, 1
    substr rx420_tgt, rx420_tgt, rx420_off
  rx420_start:
    eq $I10, 1, rx420_restart
    if_null rx420_debug, debug_744
    rx420_cur."!cursor_debug"("START", "statement_prefix:sym<try>")
  debug_744:
    $I10 = self.'from'()
    ne $I10, -1, rxscan424_done
    goto rxscan424_scan
  rxscan424_loop:
    (rx420_pos) = rx420_cur."from"()
    inc rx420_pos
    rx420_cur."!cursor_from"(rx420_pos)
    ge rx420_pos, rx420_eos, rxscan424_done
  rxscan424_scan:
    set_addr $I10, rxscan424_loop
    rx420_cur."!mark_push"(0, rx420_pos, $I10)
  rxscan424_done:
.annotate 'line', 244
  # rx subcapture "sym"
    set_addr $I10, rxcap_425_fail
    rx420_cur."!mark_push"(0, rx420_pos, $I10)
  # rx literal  "try"
    add $I11, rx420_pos, 3
    gt $I11, rx420_eos, rx420_fail
    sub $I11, rx420_pos, rx420_off
    substr $S10, rx420_tgt, $I11, 3
    ne $S10, "try", rx420_fail
    add rx420_pos, 3
    set_addr $I10, rxcap_425_fail
    ($I12, $I11) = rx420_cur."!mark_peek"($I10)
    rx420_cur."!cursor_pos"($I11)
    ($P10) = rx420_cur."!cursor_start"()
    $P10."!cursor_pass"(rx420_pos, "")
    rx420_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_425_done
  rxcap_425_fail:
    goto rx420_fail
  rxcap_425_done:
.annotate 'line', 245
  # rx subrule "blorst" subtype=capture negate=
    rx420_cur."!cursor_pos"(rx420_pos)
    $P10 = rx420_cur."blorst"()
    unless $P10, rx420_fail
    rx420_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx420_pos = $P10."pos"()
.annotate 'line', 243
  # rx pass
    rx420_cur."!cursor_pass"(rx420_pos, "statement_prefix:sym<try>")
    if_null rx420_debug, debug_745
    rx420_cur."!cursor_debug"("PASS", "statement_prefix:sym<try>", " at pos=", rx420_pos)
  debug_745:
    .return (rx420_cur)
  rx420_restart:
.annotate 'line', 10
    if_null rx420_debug, debug_746
    rx420_cur."!cursor_debug"("NEXT", "statement_prefix:sym<try>")
  debug_746:
  rx420_fail:
    (rx420_rep, rx420_pos, $I10, $P10) = rx420_cur."!mark_fail"(0)
    lt rx420_pos, -1, rx420_done
    eq rx420_pos, -1, rx420_fail
    jump $I10
  rx420_done:
    rx420_cur."!cursor_fail"()
    if_null rx420_debug, debug_747
    rx420_cur."!cursor_debug"("FAIL", "statement_prefix:sym<try>")
  debug_747:
    .return (rx420_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<try>"  :nsentry("!PREFIX__statement_prefix:sym<try>") :subid("87_1302110486.758") :method
.annotate 'line', 10
    $P422 = self."!PREFIX__!subrule"("blorst", "try")
    new $P423, "ResizablePMCArray"
    push $P423, $P422
    .return ($P423)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blorst"  :subid("88_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx427_tgt
    .local int rx427_pos
    .local int rx427_off
    .local int rx427_eos
    .local int rx427_rep
    .local pmc rx427_cur
    .local pmc rx427_debug
    (rx427_cur, rx427_pos, rx427_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx427_cur
    .local pmc match
    .lex "$/", match
    length rx427_eos, rx427_tgt
    gt rx427_pos, rx427_eos, rx427_done
    set rx427_off, 0
    lt rx427_pos, 2, rx427_start
    sub rx427_off, rx427_pos, 1
    substr rx427_tgt, rx427_tgt, rx427_off
  rx427_start:
    eq $I10, 1, rx427_restart
    if_null rx427_debug, debug_748
    rx427_cur."!cursor_debug"("START", "blorst")
  debug_748:
    $I10 = self.'from'()
    ne $I10, -1, rxscan430_done
    goto rxscan430_scan
  rxscan430_loop:
    (rx427_pos) = rx427_cur."from"()
    inc rx427_pos
    rx427_cur."!cursor_from"(rx427_pos)
    ge rx427_pos, rx427_eos, rxscan430_done
  rxscan430_scan:
    set_addr $I10, rxscan430_loop
    rx427_cur."!mark_push"(0, rx427_pos, $I10)
  rxscan430_done:
.annotate 'line', 249
  # rx charclass s
    ge rx427_pos, rx427_eos, rx427_fail
    sub $I10, rx427_pos, rx427_off
    is_cclass $I11, 32, rx427_tgt, $I10
    unless $I11, rx427_fail
    inc rx427_pos
  # rx subrule "ws" subtype=method negate=
    rx427_cur."!cursor_pos"(rx427_pos)
    $P10 = rx427_cur."ws"()
    unless $P10, rx427_fail
    rx427_pos = $P10."pos"()
  alt431_0:
    set_addr $I10, alt431_1
    rx427_cur."!mark_push"(0, rx427_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx427_pos, rx427_off
    substr $S10, rx427_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx427_fail
  # rx subrule "block" subtype=capture negate=
    rx427_cur."!cursor_pos"(rx427_pos)
    $P10 = rx427_cur."block"()
    unless $P10, rx427_fail
    rx427_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx427_pos = $P10."pos"()
    goto alt431_end
  alt431_1:
  # rx subrule "statement" subtype=capture negate=
    rx427_cur."!cursor_pos"(rx427_pos)
    $P10 = rx427_cur."statement"()
    unless $P10, rx427_fail
    rx427_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx427_pos = $P10."pos"()
  alt431_end:
.annotate 'line', 248
  # rx pass
    rx427_cur."!cursor_pass"(rx427_pos, "blorst")
    if_null rx427_debug, debug_749
    rx427_cur."!cursor_debug"("PASS", "blorst", " at pos=", rx427_pos)
  debug_749:
    .return (rx427_cur)
  rx427_restart:
.annotate 'line', 10
    if_null rx427_debug, debug_750
    rx427_cur."!cursor_debug"("NEXT", "blorst")
  debug_750:
  rx427_fail:
    (rx427_rep, rx427_pos, $I10, $P10) = rx427_cur."!mark_fail"(0)
    lt rx427_pos, -1, rx427_done
    eq rx427_pos, -1, rx427_fail
    jump $I10
  rx427_done:
    rx427_cur."!cursor_fail"()
    if_null rx427_debug, debug_751
    rx427_cur."!cursor_debug"("FAIL", "blorst")
  debug_751:
    .return (rx427_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blorst"  :nsentry("!PREFIX__blorst") :subid("89_1302110486.758") :method
.annotate 'line', 10
    new $P429, "ResizablePMCArray"
    push $P429, ""
    .return ($P429)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond"  :subid("90_1302110486.758")
    .param pmc param_433
.annotate 'line', 254
    .lex "self", param_433
    $P434 = param_433."!protoregex"("statement_mod_cond")
    .return ($P434)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond"  :subid("91_1302110486.758")
    .param pmc param_436
.annotate 'line', 254
    .lex "self", param_436
    $P437 = param_436."!PREFIX__!protoregex"("statement_mod_cond")
    .return ($P437)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<if>"  :subid("92_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx439_tgt
    .local int rx439_pos
    .local int rx439_off
    .local int rx439_eos
    .local int rx439_rep
    .local pmc rx439_cur
    .local pmc rx439_debug
    (rx439_cur, rx439_pos, rx439_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx439_cur
    .local pmc match
    .lex "$/", match
    length rx439_eos, rx439_tgt
    gt rx439_pos, rx439_eos, rx439_done
    set rx439_off, 0
    lt rx439_pos, 2, rx439_start
    sub rx439_off, rx439_pos, 1
    substr rx439_tgt, rx439_tgt, rx439_off
  rx439_start:
    eq $I10, 1, rx439_restart
    if_null rx439_debug, debug_752
    rx439_cur."!cursor_debug"("START", "statement_mod_cond:sym<if>")
  debug_752:
    $I10 = self.'from'()
    ne $I10, -1, rxscan443_done
    goto rxscan443_scan
  rxscan443_loop:
    (rx439_pos) = rx439_cur."from"()
    inc rx439_pos
    rx439_cur."!cursor_from"(rx439_pos)
    ge rx439_pos, rx439_eos, rxscan443_done
  rxscan443_scan:
    set_addr $I10, rxscan443_loop
    rx439_cur."!mark_push"(0, rx439_pos, $I10)
  rxscan443_done:
.annotate 'line', 256
  # rx subcapture "sym"
    set_addr $I10, rxcap_444_fail
    rx439_cur."!mark_push"(0, rx439_pos, $I10)
  # rx literal  "if"
    add $I11, rx439_pos, 2
    gt $I11, rx439_eos, rx439_fail
    sub $I11, rx439_pos, rx439_off
    substr $S10, rx439_tgt, $I11, 2
    ne $S10, "if", rx439_fail
    add rx439_pos, 2
    set_addr $I10, rxcap_444_fail
    ($I12, $I11) = rx439_cur."!mark_peek"($I10)
    rx439_cur."!cursor_pos"($I11)
    ($P10) = rx439_cur."!cursor_start"()
    $P10."!cursor_pass"(rx439_pos, "")
    rx439_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_444_done
  rxcap_444_fail:
    goto rx439_fail
  rxcap_444_done:
  # rx subrule "ws" subtype=method negate=
    rx439_cur."!cursor_pos"(rx439_pos)
    $P10 = rx439_cur."ws"()
    unless $P10, rx439_fail
    rx439_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx439_cur."!cursor_pos"(rx439_pos)
    $P10 = rx439_cur."EXPR"()
    unless $P10, rx439_fail
    rx439_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx439_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx439_cur."!cursor_pos"(rx439_pos)
    $P10 = rx439_cur."ws"()
    unless $P10, rx439_fail
    rx439_pos = $P10."pos"()
  # rx pass
    rx439_cur."!cursor_pass"(rx439_pos, "statement_mod_cond:sym<if>")
    if_null rx439_debug, debug_753
    rx439_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<if>", " at pos=", rx439_pos)
  debug_753:
    .return (rx439_cur)
  rx439_restart:
.annotate 'line', 10
    if_null rx439_debug, debug_754
    rx439_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<if>")
  debug_754:
  rx439_fail:
    (rx439_rep, rx439_pos, $I10, $P10) = rx439_cur."!mark_fail"(0)
    lt rx439_pos, -1, rx439_done
    eq rx439_pos, -1, rx439_fail
    jump $I10
  rx439_done:
    rx439_cur."!cursor_fail"()
    if_null rx439_debug, debug_755
    rx439_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<if>")
  debug_755:
    .return (rx439_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<if>"  :nsentry("!PREFIX__statement_mod_cond:sym<if>") :subid("93_1302110486.758") :method
.annotate 'line', 10
    $P441 = self."!PREFIX__!subrule"("ws", "if")
    new $P442, "ResizablePMCArray"
    push $P442, $P441
    .return ($P442)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<unless>"  :subid("94_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx448_tgt
    .local int rx448_pos
    .local int rx448_off
    .local int rx448_eos
    .local int rx448_rep
    .local pmc rx448_cur
    .local pmc rx448_debug
    (rx448_cur, rx448_pos, rx448_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx448_cur
    .local pmc match
    .lex "$/", match
    length rx448_eos, rx448_tgt
    gt rx448_pos, rx448_eos, rx448_done
    set rx448_off, 0
    lt rx448_pos, 2, rx448_start
    sub rx448_off, rx448_pos, 1
    substr rx448_tgt, rx448_tgt, rx448_off
  rx448_start:
    eq $I10, 1, rx448_restart
    if_null rx448_debug, debug_756
    rx448_cur."!cursor_debug"("START", "statement_mod_cond:sym<unless>")
  debug_756:
    $I10 = self.'from'()
    ne $I10, -1, rxscan452_done
    goto rxscan452_scan
  rxscan452_loop:
    (rx448_pos) = rx448_cur."from"()
    inc rx448_pos
    rx448_cur."!cursor_from"(rx448_pos)
    ge rx448_pos, rx448_eos, rxscan452_done
  rxscan452_scan:
    set_addr $I10, rxscan452_loop
    rx448_cur."!mark_push"(0, rx448_pos, $I10)
  rxscan452_done:
.annotate 'line', 257
  # rx subcapture "sym"
    set_addr $I10, rxcap_453_fail
    rx448_cur."!mark_push"(0, rx448_pos, $I10)
  # rx literal  "unless"
    add $I11, rx448_pos, 6
    gt $I11, rx448_eos, rx448_fail
    sub $I11, rx448_pos, rx448_off
    substr $S10, rx448_tgt, $I11, 6
    ne $S10, "unless", rx448_fail
    add rx448_pos, 6
    set_addr $I10, rxcap_453_fail
    ($I12, $I11) = rx448_cur."!mark_peek"($I10)
    rx448_cur."!cursor_pos"($I11)
    ($P10) = rx448_cur."!cursor_start"()
    $P10."!cursor_pass"(rx448_pos, "")
    rx448_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_453_done
  rxcap_453_fail:
    goto rx448_fail
  rxcap_453_done:
  # rx subrule "ws" subtype=method negate=
    rx448_cur."!cursor_pos"(rx448_pos)
    $P10 = rx448_cur."ws"()
    unless $P10, rx448_fail
    rx448_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx448_cur."!cursor_pos"(rx448_pos)
    $P10 = rx448_cur."EXPR"()
    unless $P10, rx448_fail
    rx448_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx448_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx448_cur."!cursor_pos"(rx448_pos)
    $P10 = rx448_cur."ws"()
    unless $P10, rx448_fail
    rx448_pos = $P10."pos"()
  # rx pass
    rx448_cur."!cursor_pass"(rx448_pos, "statement_mod_cond:sym<unless>")
    if_null rx448_debug, debug_757
    rx448_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<unless>", " at pos=", rx448_pos)
  debug_757:
    .return (rx448_cur)
  rx448_restart:
.annotate 'line', 10
    if_null rx448_debug, debug_758
    rx448_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<unless>")
  debug_758:
  rx448_fail:
    (rx448_rep, rx448_pos, $I10, $P10) = rx448_cur."!mark_fail"(0)
    lt rx448_pos, -1, rx448_done
    eq rx448_pos, -1, rx448_fail
    jump $I10
  rx448_done:
    rx448_cur."!cursor_fail"()
    if_null rx448_debug, debug_759
    rx448_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<unless>")
  debug_759:
    .return (rx448_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<unless>"  :nsentry("!PREFIX__statement_mod_cond:sym<unless>") :subid("95_1302110486.758") :method
.annotate 'line', 10
    $P450 = self."!PREFIX__!subrule"("ws", "unless")
    new $P451, "ResizablePMCArray"
    push $P451, $P450
    .return ($P451)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop"  :subid("96_1302110486.758")
    .param pmc param_457
.annotate 'line', 259
    .lex "self", param_457
    $P458 = param_457."!protoregex"("statement_mod_loop")
    .return ($P458)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop"  :subid("97_1302110486.758")
    .param pmc param_460
.annotate 'line', 259
    .lex "self", param_460
    $P461 = param_460."!PREFIX__!protoregex"("statement_mod_loop")
    .return ($P461)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<while>"  :subid("98_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx463_tgt
    .local int rx463_pos
    .local int rx463_off
    .local int rx463_eos
    .local int rx463_rep
    .local pmc rx463_cur
    .local pmc rx463_debug
    (rx463_cur, rx463_pos, rx463_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx463_cur
    .local pmc match
    .lex "$/", match
    length rx463_eos, rx463_tgt
    gt rx463_pos, rx463_eos, rx463_done
    set rx463_off, 0
    lt rx463_pos, 2, rx463_start
    sub rx463_off, rx463_pos, 1
    substr rx463_tgt, rx463_tgt, rx463_off
  rx463_start:
    eq $I10, 1, rx463_restart
    if_null rx463_debug, debug_760
    rx463_cur."!cursor_debug"("START", "statement_mod_loop:sym<while>")
  debug_760:
    $I10 = self.'from'()
    ne $I10, -1, rxscan467_done
    goto rxscan467_scan
  rxscan467_loop:
    (rx463_pos) = rx463_cur."from"()
    inc rx463_pos
    rx463_cur."!cursor_from"(rx463_pos)
    ge rx463_pos, rx463_eos, rxscan467_done
  rxscan467_scan:
    set_addr $I10, rxscan467_loop
    rx463_cur."!mark_push"(0, rx463_pos, $I10)
  rxscan467_done:
.annotate 'line', 261
  # rx subcapture "sym"
    set_addr $I10, rxcap_468_fail
    rx463_cur."!mark_push"(0, rx463_pos, $I10)
  # rx literal  "while"
    add $I11, rx463_pos, 5
    gt $I11, rx463_eos, rx463_fail
    sub $I11, rx463_pos, rx463_off
    substr $S10, rx463_tgt, $I11, 5
    ne $S10, "while", rx463_fail
    add rx463_pos, 5
    set_addr $I10, rxcap_468_fail
    ($I12, $I11) = rx463_cur."!mark_peek"($I10)
    rx463_cur."!cursor_pos"($I11)
    ($P10) = rx463_cur."!cursor_start"()
    $P10."!cursor_pass"(rx463_pos, "")
    rx463_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_468_done
  rxcap_468_fail:
    goto rx463_fail
  rxcap_468_done:
  # rx subrule "ws" subtype=method negate=
    rx463_cur."!cursor_pos"(rx463_pos)
    $P10 = rx463_cur."ws"()
    unless $P10, rx463_fail
    rx463_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx463_cur."!cursor_pos"(rx463_pos)
    $P10 = rx463_cur."EXPR"()
    unless $P10, rx463_fail
    rx463_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx463_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx463_cur."!cursor_pos"(rx463_pos)
    $P10 = rx463_cur."ws"()
    unless $P10, rx463_fail
    rx463_pos = $P10."pos"()
  # rx pass
    rx463_cur."!cursor_pass"(rx463_pos, "statement_mod_loop:sym<while>")
    if_null rx463_debug, debug_761
    rx463_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<while>", " at pos=", rx463_pos)
  debug_761:
    .return (rx463_cur)
  rx463_restart:
.annotate 'line', 10
    if_null rx463_debug, debug_762
    rx463_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<while>")
  debug_762:
  rx463_fail:
    (rx463_rep, rx463_pos, $I10, $P10) = rx463_cur."!mark_fail"(0)
    lt rx463_pos, -1, rx463_done
    eq rx463_pos, -1, rx463_fail
    jump $I10
  rx463_done:
    rx463_cur."!cursor_fail"()
    if_null rx463_debug, debug_763
    rx463_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<while>")
  debug_763:
    .return (rx463_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<while>"  :nsentry("!PREFIX__statement_mod_loop:sym<while>") :subid("99_1302110486.758") :method
.annotate 'line', 10
    $P465 = self."!PREFIX__!subrule"("ws", "while")
    new $P466, "ResizablePMCArray"
    push $P466, $P465
    .return ($P466)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<until>"  :subid("100_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx472_tgt
    .local int rx472_pos
    .local int rx472_off
    .local int rx472_eos
    .local int rx472_rep
    .local pmc rx472_cur
    .local pmc rx472_debug
    (rx472_cur, rx472_pos, rx472_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx472_cur
    .local pmc match
    .lex "$/", match
    length rx472_eos, rx472_tgt
    gt rx472_pos, rx472_eos, rx472_done
    set rx472_off, 0
    lt rx472_pos, 2, rx472_start
    sub rx472_off, rx472_pos, 1
    substr rx472_tgt, rx472_tgt, rx472_off
  rx472_start:
    eq $I10, 1, rx472_restart
    if_null rx472_debug, debug_764
    rx472_cur."!cursor_debug"("START", "statement_mod_loop:sym<until>")
  debug_764:
    $I10 = self.'from'()
    ne $I10, -1, rxscan476_done
    goto rxscan476_scan
  rxscan476_loop:
    (rx472_pos) = rx472_cur."from"()
    inc rx472_pos
    rx472_cur."!cursor_from"(rx472_pos)
    ge rx472_pos, rx472_eos, rxscan476_done
  rxscan476_scan:
    set_addr $I10, rxscan476_loop
    rx472_cur."!mark_push"(0, rx472_pos, $I10)
  rxscan476_done:
.annotate 'line', 262
  # rx subcapture "sym"
    set_addr $I10, rxcap_477_fail
    rx472_cur."!mark_push"(0, rx472_pos, $I10)
  # rx literal  "until"
    add $I11, rx472_pos, 5
    gt $I11, rx472_eos, rx472_fail
    sub $I11, rx472_pos, rx472_off
    substr $S10, rx472_tgt, $I11, 5
    ne $S10, "until", rx472_fail
    add rx472_pos, 5
    set_addr $I10, rxcap_477_fail
    ($I12, $I11) = rx472_cur."!mark_peek"($I10)
    rx472_cur."!cursor_pos"($I11)
    ($P10) = rx472_cur."!cursor_start"()
    $P10."!cursor_pass"(rx472_pos, "")
    rx472_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_477_done
  rxcap_477_fail:
    goto rx472_fail
  rxcap_477_done:
  # rx subrule "ws" subtype=method negate=
    rx472_cur."!cursor_pos"(rx472_pos)
    $P10 = rx472_cur."ws"()
    unless $P10, rx472_fail
    rx472_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx472_cur."!cursor_pos"(rx472_pos)
    $P10 = rx472_cur."EXPR"()
    unless $P10, rx472_fail
    rx472_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx472_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx472_cur."!cursor_pos"(rx472_pos)
    $P10 = rx472_cur."ws"()
    unless $P10, rx472_fail
    rx472_pos = $P10."pos"()
  # rx pass
    rx472_cur."!cursor_pass"(rx472_pos, "statement_mod_loop:sym<until>")
    if_null rx472_debug, debug_765
    rx472_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<until>", " at pos=", rx472_pos)
  debug_765:
    .return (rx472_cur)
  rx472_restart:
.annotate 'line', 10
    if_null rx472_debug, debug_766
    rx472_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<until>")
  debug_766:
  rx472_fail:
    (rx472_rep, rx472_pos, $I10, $P10) = rx472_cur."!mark_fail"(0)
    lt rx472_pos, -1, rx472_done
    eq rx472_pos, -1, rx472_fail
    jump $I10
  rx472_done:
    rx472_cur."!cursor_fail"()
    if_null rx472_debug, debug_767
    rx472_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<until>")
  debug_767:
    .return (rx472_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<until>"  :nsentry("!PREFIX__statement_mod_loop:sym<until>") :subid("101_1302110486.758") :method
.annotate 'line', 10
    $P474 = self."!PREFIX__!subrule"("ws", "until")
    new $P475, "ResizablePMCArray"
    push $P475, $P474
    .return ($P475)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<for>"  :subid("102_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx481_tgt
    .local int rx481_pos
    .local int rx481_off
    .local int rx481_eos
    .local int rx481_rep
    .local pmc rx481_cur
    .local pmc rx481_debug
    (rx481_cur, rx481_pos, rx481_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx481_cur
    .local pmc match
    .lex "$/", match
    length rx481_eos, rx481_tgt
    gt rx481_pos, rx481_eos, rx481_done
    set rx481_off, 0
    lt rx481_pos, 2, rx481_start
    sub rx481_off, rx481_pos, 1
    substr rx481_tgt, rx481_tgt, rx481_off
  rx481_start:
    eq $I10, 1, rx481_restart
    if_null rx481_debug, debug_768
    rx481_cur."!cursor_debug"("START", "statement_mod_loop:sym<for>")
  debug_768:
    $I10 = self.'from'()
    ne $I10, -1, rxscan485_done
    goto rxscan485_scan
  rxscan485_loop:
    (rx481_pos) = rx481_cur."from"()
    inc rx481_pos
    rx481_cur."!cursor_from"(rx481_pos)
    ge rx481_pos, rx481_eos, rxscan485_done
  rxscan485_scan:
    set_addr $I10, rxscan485_loop
    rx481_cur."!mark_push"(0, rx481_pos, $I10)
  rxscan485_done:
.annotate 'line', 263
  # rx subcapture "sym"
    set_addr $I10, rxcap_486_fail
    rx481_cur."!mark_push"(0, rx481_pos, $I10)
  # rx literal  "for"
    add $I11, rx481_pos, 3
    gt $I11, rx481_eos, rx481_fail
    sub $I11, rx481_pos, rx481_off
    substr $S10, rx481_tgt, $I11, 3
    ne $S10, "for", rx481_fail
    add rx481_pos, 3
    set_addr $I10, rxcap_486_fail
    ($I12, $I11) = rx481_cur."!mark_peek"($I10)
    rx481_cur."!cursor_pos"($I11)
    ($P10) = rx481_cur."!cursor_start"()
    $P10."!cursor_pass"(rx481_pos, "")
    rx481_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_486_done
  rxcap_486_fail:
    goto rx481_fail
  rxcap_486_done:
  # rx subrule "ws" subtype=method negate=
    rx481_cur."!cursor_pos"(rx481_pos)
    $P10 = rx481_cur."ws"()
    unless $P10, rx481_fail
    rx481_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx481_cur."!cursor_pos"(rx481_pos)
    $P10 = rx481_cur."EXPR"()
    unless $P10, rx481_fail
    rx481_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx481_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx481_cur."!cursor_pos"(rx481_pos)
    $P10 = rx481_cur."ws"()
    unless $P10, rx481_fail
    rx481_pos = $P10."pos"()
  # rx pass
    rx481_cur."!cursor_pass"(rx481_pos, "statement_mod_loop:sym<for>")
    if_null rx481_debug, debug_769
    rx481_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<for>", " at pos=", rx481_pos)
  debug_769:
    .return (rx481_cur)
  rx481_restart:
.annotate 'line', 10
    if_null rx481_debug, debug_770
    rx481_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<for>")
  debug_770:
  rx481_fail:
    (rx481_rep, rx481_pos, $I10, $P10) = rx481_cur."!mark_fail"(0)
    lt rx481_pos, -1, rx481_done
    eq rx481_pos, -1, rx481_fail
    jump $I10
  rx481_done:
    rx481_cur."!cursor_fail"()
    if_null rx481_debug, debug_771
    rx481_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<for>")
  debug_771:
    .return (rx481_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<for>"  :nsentry("!PREFIX__statement_mod_loop:sym<for>") :subid("103_1302110486.758") :method
.annotate 'line', 10
    $P483 = self."!PREFIX__!subrule"("ws", "for")
    new $P484, "ResizablePMCArray"
    push $P484, $P483
    .return ($P484)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<fatarrow>"  :subid("104_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx490_tgt
    .local int rx490_pos
    .local int rx490_off
    .local int rx490_eos
    .local int rx490_rep
    .local pmc rx490_cur
    .local pmc rx490_debug
    (rx490_cur, rx490_pos, rx490_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx490_cur
    .local pmc match
    .lex "$/", match
    length rx490_eos, rx490_tgt
    gt rx490_pos, rx490_eos, rx490_done
    set rx490_off, 0
    lt rx490_pos, 2, rx490_start
    sub rx490_off, rx490_pos, 1
    substr rx490_tgt, rx490_tgt, rx490_off
  rx490_start:
    eq $I10, 1, rx490_restart
    if_null rx490_debug, debug_772
    rx490_cur."!cursor_debug"("START", "term:sym<fatarrow>")
  debug_772:
    $I10 = self.'from'()
    ne $I10, -1, rxscan494_done
    goto rxscan494_scan
  rxscan494_loop:
    (rx490_pos) = rx490_cur."from"()
    inc rx490_pos
    rx490_cur."!cursor_from"(rx490_pos)
    ge rx490_pos, rx490_eos, rxscan494_done
  rxscan494_scan:
    set_addr $I10, rxscan494_loop
    rx490_cur."!mark_push"(0, rx490_pos, $I10)
  rxscan494_done:
.annotate 'line', 267
  # rx subrule "fatarrow" subtype=capture negate=
    rx490_cur."!cursor_pos"(rx490_pos)
    $P10 = rx490_cur."fatarrow"()
    unless $P10, rx490_fail
    rx490_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("fatarrow")
    rx490_pos = $P10."pos"()
  # rx pass
    rx490_cur."!cursor_pass"(rx490_pos, "term:sym<fatarrow>")
    if_null rx490_debug, debug_773
    rx490_cur."!cursor_debug"("PASS", "term:sym<fatarrow>", " at pos=", rx490_pos)
  debug_773:
    .return (rx490_cur)
  rx490_restart:
.annotate 'line', 10
    if_null rx490_debug, debug_774
    rx490_cur."!cursor_debug"("NEXT", "term:sym<fatarrow>")
  debug_774:
  rx490_fail:
    (rx490_rep, rx490_pos, $I10, $P10) = rx490_cur."!mark_fail"(0)
    lt rx490_pos, -1, rx490_done
    eq rx490_pos, -1, rx490_fail
    jump $I10
  rx490_done:
    rx490_cur."!cursor_fail"()
    if_null rx490_debug, debug_775
    rx490_cur."!cursor_debug"("FAIL", "term:sym<fatarrow>")
  debug_775:
    .return (rx490_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<fatarrow>"  :nsentry("!PREFIX__term:sym<fatarrow>") :subid("105_1302110486.758") :method
.annotate 'line', 10
    $P492 = self."!PREFIX__!subrule"("fatarrow", "")
    new $P493, "ResizablePMCArray"
    push $P493, $P492
    .return ($P493)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<colonpair>"  :subid("106_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx496_tgt
    .local int rx496_pos
    .local int rx496_off
    .local int rx496_eos
    .local int rx496_rep
    .local pmc rx496_cur
    .local pmc rx496_debug
    (rx496_cur, rx496_pos, rx496_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx496_cur
    .local pmc match
    .lex "$/", match
    length rx496_eos, rx496_tgt
    gt rx496_pos, rx496_eos, rx496_done
    set rx496_off, 0
    lt rx496_pos, 2, rx496_start
    sub rx496_off, rx496_pos, 1
    substr rx496_tgt, rx496_tgt, rx496_off
  rx496_start:
    eq $I10, 1, rx496_restart
    if_null rx496_debug, debug_776
    rx496_cur."!cursor_debug"("START", "term:sym<colonpair>")
  debug_776:
    $I10 = self.'from'()
    ne $I10, -1, rxscan500_done
    goto rxscan500_scan
  rxscan500_loop:
    (rx496_pos) = rx496_cur."from"()
    inc rx496_pos
    rx496_cur."!cursor_from"(rx496_pos)
    ge rx496_pos, rx496_eos, rxscan500_done
  rxscan500_scan:
    set_addr $I10, rxscan500_loop
    rx496_cur."!mark_push"(0, rx496_pos, $I10)
  rxscan500_done:
.annotate 'line', 268
  # rx subrule "colonpair" subtype=capture negate=
    rx496_cur."!cursor_pos"(rx496_pos)
    $P10 = rx496_cur."colonpair"()
    unless $P10, rx496_fail
    rx496_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("colonpair")
    rx496_pos = $P10."pos"()
  # rx pass
    rx496_cur."!cursor_pass"(rx496_pos, "term:sym<colonpair>")
    if_null rx496_debug, debug_777
    rx496_cur."!cursor_debug"("PASS", "term:sym<colonpair>", " at pos=", rx496_pos)
  debug_777:
    .return (rx496_cur)
  rx496_restart:
.annotate 'line', 10
    if_null rx496_debug, debug_778
    rx496_cur."!cursor_debug"("NEXT", "term:sym<colonpair>")
  debug_778:
  rx496_fail:
    (rx496_rep, rx496_pos, $I10, $P10) = rx496_cur."!mark_fail"(0)
    lt rx496_pos, -1, rx496_done
    eq rx496_pos, -1, rx496_fail
    jump $I10
  rx496_done:
    rx496_cur."!cursor_fail"()
    if_null rx496_debug, debug_779
    rx496_cur."!cursor_debug"("FAIL", "term:sym<colonpair>")
  debug_779:
    .return (rx496_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<colonpair>"  :nsentry("!PREFIX__term:sym<colonpair>") :subid("107_1302110486.758") :method
.annotate 'line', 10
    $P498 = self."!PREFIX__!subrule"("colonpair", "")
    new $P499, "ResizablePMCArray"
    push $P499, $P498
    .return ($P499)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<variable>"  :subid("108_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx502_tgt
    .local int rx502_pos
    .local int rx502_off
    .local int rx502_eos
    .local int rx502_rep
    .local pmc rx502_cur
    .local pmc rx502_debug
    (rx502_cur, rx502_pos, rx502_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx502_cur
    .local pmc match
    .lex "$/", match
    length rx502_eos, rx502_tgt
    gt rx502_pos, rx502_eos, rx502_done
    set rx502_off, 0
    lt rx502_pos, 2, rx502_start
    sub rx502_off, rx502_pos, 1
    substr rx502_tgt, rx502_tgt, rx502_off
  rx502_start:
    eq $I10, 1, rx502_restart
    if_null rx502_debug, debug_780
    rx502_cur."!cursor_debug"("START", "term:sym<variable>")
  debug_780:
    $I10 = self.'from'()
    ne $I10, -1, rxscan506_done
    goto rxscan506_scan
  rxscan506_loop:
    (rx502_pos) = rx502_cur."from"()
    inc rx502_pos
    rx502_cur."!cursor_from"(rx502_pos)
    ge rx502_pos, rx502_eos, rxscan506_done
  rxscan506_scan:
    set_addr $I10, rxscan506_loop
    rx502_cur."!mark_push"(0, rx502_pos, $I10)
  rxscan506_done:
.annotate 'line', 269
  # rx subrule "variable" subtype=capture negate=
    rx502_cur."!cursor_pos"(rx502_pos)
    $P10 = rx502_cur."variable"()
    unless $P10, rx502_fail
    rx502_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx502_pos = $P10."pos"()
  # rx pass
    rx502_cur."!cursor_pass"(rx502_pos, "term:sym<variable>")
    if_null rx502_debug, debug_781
    rx502_cur."!cursor_debug"("PASS", "term:sym<variable>", " at pos=", rx502_pos)
  debug_781:
    .return (rx502_cur)
  rx502_restart:
.annotate 'line', 10
    if_null rx502_debug, debug_782
    rx502_cur."!cursor_debug"("NEXT", "term:sym<variable>")
  debug_782:
  rx502_fail:
    (rx502_rep, rx502_pos, $I10, $P10) = rx502_cur."!mark_fail"(0)
    lt rx502_pos, -1, rx502_done
    eq rx502_pos, -1, rx502_fail
    jump $I10
  rx502_done:
    rx502_cur."!cursor_fail"()
    if_null rx502_debug, debug_783
    rx502_cur."!cursor_debug"("FAIL", "term:sym<variable>")
  debug_783:
    .return (rx502_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<variable>"  :nsentry("!PREFIX__term:sym<variable>") :subid("109_1302110486.758") :method
.annotate 'line', 10
    $P504 = self."!PREFIX__!subrule"("variable", "")
    new $P505, "ResizablePMCArray"
    push $P505, $P504
    .return ($P505)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<package_declarator>"  :subid("110_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx508_tgt
    .local int rx508_pos
    .local int rx508_off
    .local int rx508_eos
    .local int rx508_rep
    .local pmc rx508_cur
    .local pmc rx508_debug
    (rx508_cur, rx508_pos, rx508_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx508_cur
    .local pmc match
    .lex "$/", match
    length rx508_eos, rx508_tgt
    gt rx508_pos, rx508_eos, rx508_done
    set rx508_off, 0
    lt rx508_pos, 2, rx508_start
    sub rx508_off, rx508_pos, 1
    substr rx508_tgt, rx508_tgt, rx508_off
  rx508_start:
    eq $I10, 1, rx508_restart
    if_null rx508_debug, debug_784
    rx508_cur."!cursor_debug"("START", "term:sym<package_declarator>")
  debug_784:
    $I10 = self.'from'()
    ne $I10, -1, rxscan512_done
    goto rxscan512_scan
  rxscan512_loop:
    (rx508_pos) = rx508_cur."from"()
    inc rx508_pos
    rx508_cur."!cursor_from"(rx508_pos)
    ge rx508_pos, rx508_eos, rxscan512_done
  rxscan512_scan:
    set_addr $I10, rxscan512_loop
    rx508_cur."!mark_push"(0, rx508_pos, $I10)
  rxscan512_done:
.annotate 'line', 270
  # rx subrule "package_declarator" subtype=capture negate=
    rx508_cur."!cursor_pos"(rx508_pos)
    $P10 = rx508_cur."package_declarator"()
    unless $P10, rx508_fail
    rx508_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx508_pos = $P10."pos"()
  # rx pass
    rx508_cur."!cursor_pass"(rx508_pos, "term:sym<package_declarator>")
    if_null rx508_debug, debug_785
    rx508_cur."!cursor_debug"("PASS", "term:sym<package_declarator>", " at pos=", rx508_pos)
  debug_785:
    .return (rx508_cur)
  rx508_restart:
.annotate 'line', 10
    if_null rx508_debug, debug_786
    rx508_cur."!cursor_debug"("NEXT", "term:sym<package_declarator>")
  debug_786:
  rx508_fail:
    (rx508_rep, rx508_pos, $I10, $P10) = rx508_cur."!mark_fail"(0)
    lt rx508_pos, -1, rx508_done
    eq rx508_pos, -1, rx508_fail
    jump $I10
  rx508_done:
    rx508_cur."!cursor_fail"()
    if_null rx508_debug, debug_787
    rx508_cur."!cursor_debug"("FAIL", "term:sym<package_declarator>")
  debug_787:
    .return (rx508_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<package_declarator>"  :nsentry("!PREFIX__term:sym<package_declarator>") :subid("111_1302110486.758") :method
.annotate 'line', 10
    $P510 = self."!PREFIX__!subrule"("package_declarator", "")
    new $P511, "ResizablePMCArray"
    push $P511, $P510
    .return ($P511)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<scope_declarator>"  :subid("112_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx514_tgt
    .local int rx514_pos
    .local int rx514_off
    .local int rx514_eos
    .local int rx514_rep
    .local pmc rx514_cur
    .local pmc rx514_debug
    (rx514_cur, rx514_pos, rx514_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx514_cur
    .local pmc match
    .lex "$/", match
    length rx514_eos, rx514_tgt
    gt rx514_pos, rx514_eos, rx514_done
    set rx514_off, 0
    lt rx514_pos, 2, rx514_start
    sub rx514_off, rx514_pos, 1
    substr rx514_tgt, rx514_tgt, rx514_off
  rx514_start:
    eq $I10, 1, rx514_restart
    if_null rx514_debug, debug_788
    rx514_cur."!cursor_debug"("START", "term:sym<scope_declarator>")
  debug_788:
    $I10 = self.'from'()
    ne $I10, -1, rxscan518_done
    goto rxscan518_scan
  rxscan518_loop:
    (rx514_pos) = rx514_cur."from"()
    inc rx514_pos
    rx514_cur."!cursor_from"(rx514_pos)
    ge rx514_pos, rx514_eos, rxscan518_done
  rxscan518_scan:
    set_addr $I10, rxscan518_loop
    rx514_cur."!mark_push"(0, rx514_pos, $I10)
  rxscan518_done:
.annotate 'line', 271
  # rx subrule "scope_declarator" subtype=capture negate=
    rx514_cur."!cursor_pos"(rx514_pos)
    $P10 = rx514_cur."scope_declarator"()
    unless $P10, rx514_fail
    rx514_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scope_declarator")
    rx514_pos = $P10."pos"()
  # rx pass
    rx514_cur."!cursor_pass"(rx514_pos, "term:sym<scope_declarator>")
    if_null rx514_debug, debug_789
    rx514_cur."!cursor_debug"("PASS", "term:sym<scope_declarator>", " at pos=", rx514_pos)
  debug_789:
    .return (rx514_cur)
  rx514_restart:
.annotate 'line', 10
    if_null rx514_debug, debug_790
    rx514_cur."!cursor_debug"("NEXT", "term:sym<scope_declarator>")
  debug_790:
  rx514_fail:
    (rx514_rep, rx514_pos, $I10, $P10) = rx514_cur."!mark_fail"(0)
    lt rx514_pos, -1, rx514_done
    eq rx514_pos, -1, rx514_fail
    jump $I10
  rx514_done:
    rx514_cur."!cursor_fail"()
    if_null rx514_debug, debug_791
    rx514_cur."!cursor_debug"("FAIL", "term:sym<scope_declarator>")
  debug_791:
    .return (rx514_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<scope_declarator>"  :nsentry("!PREFIX__term:sym<scope_declarator>") :subid("113_1302110486.758") :method
.annotate 'line', 10
    $P516 = self."!PREFIX__!subrule"("scope_declarator", "")
    new $P517, "ResizablePMCArray"
    push $P517, $P516
    .return ($P517)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<routine_declarator>"  :subid("114_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx520_tgt
    .local int rx520_pos
    .local int rx520_off
    .local int rx520_eos
    .local int rx520_rep
    .local pmc rx520_cur
    .local pmc rx520_debug
    (rx520_cur, rx520_pos, rx520_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx520_cur
    .local pmc match
    .lex "$/", match
    length rx520_eos, rx520_tgt
    gt rx520_pos, rx520_eos, rx520_done
    set rx520_off, 0
    lt rx520_pos, 2, rx520_start
    sub rx520_off, rx520_pos, 1
    substr rx520_tgt, rx520_tgt, rx520_off
  rx520_start:
    eq $I10, 1, rx520_restart
    if_null rx520_debug, debug_792
    rx520_cur."!cursor_debug"("START", "term:sym<routine_declarator>")
  debug_792:
    $I10 = self.'from'()
    ne $I10, -1, rxscan524_done
    goto rxscan524_scan
  rxscan524_loop:
    (rx520_pos) = rx520_cur."from"()
    inc rx520_pos
    rx520_cur."!cursor_from"(rx520_pos)
    ge rx520_pos, rx520_eos, rxscan524_done
  rxscan524_scan:
    set_addr $I10, rxscan524_loop
    rx520_cur."!mark_push"(0, rx520_pos, $I10)
  rxscan524_done:
.annotate 'line', 272
  # rx subrule "routine_declarator" subtype=capture negate=
    rx520_cur."!cursor_pos"(rx520_pos)
    $P10 = rx520_cur."routine_declarator"()
    unless $P10, rx520_fail
    rx520_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx520_pos = $P10."pos"()
  # rx pass
    rx520_cur."!cursor_pass"(rx520_pos, "term:sym<routine_declarator>")
    if_null rx520_debug, debug_793
    rx520_cur."!cursor_debug"("PASS", "term:sym<routine_declarator>", " at pos=", rx520_pos)
  debug_793:
    .return (rx520_cur)
  rx520_restart:
.annotate 'line', 10
    if_null rx520_debug, debug_794
    rx520_cur."!cursor_debug"("NEXT", "term:sym<routine_declarator>")
  debug_794:
  rx520_fail:
    (rx520_rep, rx520_pos, $I10, $P10) = rx520_cur."!mark_fail"(0)
    lt rx520_pos, -1, rx520_done
    eq rx520_pos, -1, rx520_fail
    jump $I10
  rx520_done:
    rx520_cur."!cursor_fail"()
    if_null rx520_debug, debug_795
    rx520_cur."!cursor_debug"("FAIL", "term:sym<routine_declarator>")
  debug_795:
    .return (rx520_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<routine_declarator>"  :nsentry("!PREFIX__term:sym<routine_declarator>") :subid("115_1302110486.758") :method
.annotate 'line', 10
    $P522 = self."!PREFIX__!subrule"("routine_declarator", "")
    new $P523, "ResizablePMCArray"
    push $P523, $P522
    .return ($P523)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<multi_declarator>"  :subid("116_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .const 'Sub' $P536 = "119_1302110486.758" 
    capture_lex $P536
    .const 'Sub' $P531 = "118_1302110486.758" 
    capture_lex $P531
    .local string rx526_tgt
    .local int rx526_pos
    .local int rx526_off
    .local int rx526_eos
    .local int rx526_rep
    .local pmc rx526_cur
    .local pmc rx526_debug
    (rx526_cur, rx526_pos, rx526_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx526_cur
    .local pmc match
    .lex "$/", match
    length rx526_eos, rx526_tgt
    gt rx526_pos, rx526_eos, rx526_done
    set rx526_off, 0
    lt rx526_pos, 2, rx526_start
    sub rx526_off, rx526_pos, 1
    substr rx526_tgt, rx526_tgt, rx526_off
  rx526_start:
    eq $I10, 1, rx526_restart
    if_null rx526_debug, debug_796
    rx526_cur."!cursor_debug"("START", "term:sym<multi_declarator>")
  debug_796:
    $I10 = self.'from'()
    ne $I10, -1, rxscan529_done
    goto rxscan529_scan
  rxscan529_loop:
    (rx526_pos) = rx526_cur."from"()
    inc rx526_pos
    rx526_cur."!cursor_from"(rx526_pos)
    ge rx526_pos, rx526_eos, rxscan529_done
  rxscan529_scan:
    set_addr $I10, rxscan529_loop
    rx526_cur."!mark_push"(0, rx526_pos, $I10)
  rxscan529_done:
.annotate 'line', 274
  # rx subrule "before" subtype=zerowidth negate=
    rx526_cur."!cursor_pos"(rx526_pos)
    .const 'Sub' $P531 = "118_1302110486.758" 
    capture_lex $P531
    $P10 = rx526_cur."before"($P531)
    unless $P10, rx526_fail
.annotate 'line', 275
  # rx subrule "before" subtype=zerowidth negate=1
    rx526_cur."!cursor_pos"(rx526_pos)
    .const 'Sub' $P536 = "119_1302110486.758" 
    capture_lex $P536
    $P10 = rx526_cur."before"($P536)
    if $P10, rx526_fail
.annotate 'line', 276
  # rx subrule "multi_declarator" subtype=capture negate=
    rx526_cur."!cursor_pos"(rx526_pos)
    $P10 = rx526_cur."multi_declarator"()
    unless $P10, rx526_fail
    rx526_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx526_pos = $P10."pos"()
.annotate 'line', 273
  # rx pass
    rx526_cur."!cursor_pass"(rx526_pos, "term:sym<multi_declarator>")
    if_null rx526_debug, debug_805
    rx526_cur."!cursor_debug"("PASS", "term:sym<multi_declarator>", " at pos=", rx526_pos)
  debug_805:
    .return (rx526_cur)
  rx526_restart:
.annotate 'line', 10
    if_null rx526_debug, debug_806
    rx526_cur."!cursor_debug"("NEXT", "term:sym<multi_declarator>")
  debug_806:
  rx526_fail:
    (rx526_rep, rx526_pos, $I10, $P10) = rx526_cur."!mark_fail"(0)
    lt rx526_pos, -1, rx526_done
    eq rx526_pos, -1, rx526_fail
    jump $I10
  rx526_done:
    rx526_cur."!cursor_fail"()
    if_null rx526_debug, debug_807
    rx526_cur."!cursor_debug"("FAIL", "term:sym<multi_declarator>")
  debug_807:
    .return (rx526_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<multi_declarator>"  :nsentry("!PREFIX__term:sym<multi_declarator>") :subid("117_1302110486.758") :method
.annotate 'line', 10
    new $P528, "ResizablePMCArray"
    push $P528, ""
    .return ($P528)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block530"  :anon :subid("118_1302110486.758") :method :outer("116_1302110486.758")
.annotate 'line', 274
    .local string rx532_tgt
    .local int rx532_pos
    .local int rx532_off
    .local int rx532_eos
    .local int rx532_rep
    .local pmc rx532_cur
    .local pmc rx532_debug
    (rx532_cur, rx532_pos, rx532_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx532_cur
    .local pmc match
    .lex "$/", match
    length rx532_eos, rx532_tgt
    gt rx532_pos, rx532_eos, rx532_done
    set rx532_off, 0
    lt rx532_pos, 2, rx532_start
    sub rx532_off, rx532_pos, 1
    substr rx532_tgt, rx532_tgt, rx532_off
  rx532_start:
    eq $I10, 1, rx532_restart
    if_null rx532_debug, debug_797
    rx532_cur."!cursor_debug"("START", "")
  debug_797:
    $I10 = self.'from'()
    ne $I10, -1, rxscan533_done
    goto rxscan533_scan
  rxscan533_loop:
    (rx532_pos) = rx532_cur."from"()
    inc rx532_pos
    rx532_cur."!cursor_from"(rx532_pos)
    ge rx532_pos, rx532_eos, rxscan533_done
  rxscan533_scan:
    set_addr $I10, rxscan533_loop
    rx532_cur."!mark_push"(0, rx532_pos, $I10)
  rxscan533_done:
  alt534_0:
    set_addr $I10, alt534_1
    rx532_cur."!mark_push"(0, rx532_pos, $I10)
  # rx literal  "multi"
    add $I11, rx532_pos, 5
    gt $I11, rx532_eos, rx532_fail
    sub $I11, rx532_pos, rx532_off
    substr $S10, rx532_tgt, $I11, 5
    ne $S10, "multi", rx532_fail
    add rx532_pos, 5
    goto alt534_end
  alt534_1:
    set_addr $I10, alt534_2
    rx532_cur."!mark_push"(0, rx532_pos, $I10)
  # rx literal  "proto"
    add $I11, rx532_pos, 5
    gt $I11, rx532_eos, rx532_fail
    sub $I11, rx532_pos, rx532_off
    substr $S10, rx532_tgt, $I11, 5
    ne $S10, "proto", rx532_fail
    add rx532_pos, 5
    goto alt534_end
  alt534_2:
  # rx literal  "only"
    add $I11, rx532_pos, 4
    gt $I11, rx532_eos, rx532_fail
    sub $I11, rx532_pos, rx532_off
    substr $S10, rx532_tgt, $I11, 4
    ne $S10, "only", rx532_fail
    add rx532_pos, 4
  alt534_end:
  # rx pass
    rx532_cur."!cursor_pass"(rx532_pos, "")
    if_null rx532_debug, debug_798
    rx532_cur."!cursor_debug"("PASS", "", " at pos=", rx532_pos)
  debug_798:
    .return (rx532_cur)
  rx532_restart:
    if_null rx532_debug, debug_799
    rx532_cur."!cursor_debug"("NEXT", "")
  debug_799:
  rx532_fail:
    (rx532_rep, rx532_pos, $I10, $P10) = rx532_cur."!mark_fail"(0)
    lt rx532_pos, -1, rx532_done
    eq rx532_pos, -1, rx532_fail
    jump $I10
  rx532_done:
    rx532_cur."!cursor_fail"()
    if_null rx532_debug, debug_800
    rx532_cur."!cursor_debug"("FAIL", "")
  debug_800:
    .return (rx532_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block535"  :anon :subid("119_1302110486.758") :method :outer("116_1302110486.758")
.annotate 'line', 275
    .local string rx537_tgt
    .local int rx537_pos
    .local int rx537_off
    .local int rx537_eos
    .local int rx537_rep
    .local pmc rx537_cur
    .local pmc rx537_debug
    (rx537_cur, rx537_pos, rx537_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx537_cur
    .local pmc match
    .lex "$/", match
    length rx537_eos, rx537_tgt
    gt rx537_pos, rx537_eos, rx537_done
    set rx537_off, 0
    lt rx537_pos, 2, rx537_start
    sub rx537_off, rx537_pos, 1
    substr rx537_tgt, rx537_tgt, rx537_off
  rx537_start:
    eq $I10, 1, rx537_restart
    if_null rx537_debug, debug_801
    rx537_cur."!cursor_debug"("START", "")
  debug_801:
    $I10 = self.'from'()
    ne $I10, -1, rxscan538_done
    goto rxscan538_scan
  rxscan538_loop:
    (rx537_pos) = rx537_cur."from"()
    inc rx537_pos
    rx537_cur."!cursor_from"(rx537_pos)
    ge rx537_pos, rx537_eos, rxscan538_done
  rxscan538_scan:
    set_addr $I10, rxscan538_loop
    rx537_cur."!mark_push"(0, rx537_pos, $I10)
  rxscan538_done:
  # rx literal  "proto"
    add $I11, rx537_pos, 5
    gt $I11, rx537_eos, rx537_fail
    sub $I11, rx537_pos, rx537_off
    substr $S10, rx537_tgt, $I11, 5
    ne $S10, "proto", rx537_fail
    add rx537_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx537_cur."!cursor_pos"(rx537_pos)
    $P10 = rx537_cur."ws"()
    unless $P10, rx537_fail
    rx537_pos = $P10."pos"()
  alt539_0:
    set_addr $I10, alt539_1
    rx537_cur."!mark_push"(0, rx537_pos, $I10)
  # rx literal  "regex"
    add $I11, rx537_pos, 5
    gt $I11, rx537_eos, rx537_fail
    sub $I11, rx537_pos, rx537_off
    substr $S10, rx537_tgt, $I11, 5
    ne $S10, "regex", rx537_fail
    add rx537_pos, 5
    goto alt539_end
  alt539_1:
    set_addr $I10, alt539_2
    rx537_cur."!mark_push"(0, rx537_pos, $I10)
  # rx literal  "token"
    add $I11, rx537_pos, 5
    gt $I11, rx537_eos, rx537_fail
    sub $I11, rx537_pos, rx537_off
    substr $S10, rx537_tgt, $I11, 5
    ne $S10, "token", rx537_fail
    add rx537_pos, 5
    goto alt539_end
  alt539_2:
  # rx literal  "rule"
    add $I11, rx537_pos, 4
    gt $I11, rx537_eos, rx537_fail
    sub $I11, rx537_pos, rx537_off
    substr $S10, rx537_tgt, $I11, 4
    ne $S10, "rule", rx537_fail
    add rx537_pos, 4
  alt539_end:
  # rx pass
    rx537_cur."!cursor_pass"(rx537_pos, "")
    if_null rx537_debug, debug_802
    rx537_cur."!cursor_debug"("PASS", "", " at pos=", rx537_pos)
  debug_802:
    .return (rx537_cur)
  rx537_restart:
    if_null rx537_debug, debug_803
    rx537_cur."!cursor_debug"("NEXT", "")
  debug_803:
  rx537_fail:
    (rx537_rep, rx537_pos, $I10, $P10) = rx537_cur."!mark_fail"(0)
    lt rx537_pos, -1, rx537_done
    eq rx537_pos, -1, rx537_fail
    jump $I10
  rx537_done:
    rx537_cur."!cursor_fail"()
    if_null rx537_debug, debug_804
    rx537_cur."!cursor_debug"("FAIL", "")
  debug_804:
    .return (rx537_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<regex_declarator>"  :subid("120_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx541_tgt
    .local int rx541_pos
    .local int rx541_off
    .local int rx541_eos
    .local int rx541_rep
    .local pmc rx541_cur
    .local pmc rx541_debug
    (rx541_cur, rx541_pos, rx541_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx541_cur
    .local pmc match
    .lex "$/", match
    length rx541_eos, rx541_tgt
    gt rx541_pos, rx541_eos, rx541_done
    set rx541_off, 0
    lt rx541_pos, 2, rx541_start
    sub rx541_off, rx541_pos, 1
    substr rx541_tgt, rx541_tgt, rx541_off
  rx541_start:
    eq $I10, 1, rx541_restart
    if_null rx541_debug, debug_808
    rx541_cur."!cursor_debug"("START", "term:sym<regex_declarator>")
  debug_808:
    $I10 = self.'from'()
    ne $I10, -1, rxscan545_done
    goto rxscan545_scan
  rxscan545_loop:
    (rx541_pos) = rx541_cur."from"()
    inc rx541_pos
    rx541_cur."!cursor_from"(rx541_pos)
    ge rx541_pos, rx541_eos, rxscan545_done
  rxscan545_scan:
    set_addr $I10, rxscan545_loop
    rx541_cur."!mark_push"(0, rx541_pos, $I10)
  rxscan545_done:
.annotate 'line', 278
  # rx subrule "regex_declarator" subtype=capture negate=
    rx541_cur."!cursor_pos"(rx541_pos)
    $P10 = rx541_cur."regex_declarator"()
    unless $P10, rx541_fail
    rx541_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("regex_declarator")
    rx541_pos = $P10."pos"()
  # rx pass
    rx541_cur."!cursor_pass"(rx541_pos, "term:sym<regex_declarator>")
    if_null rx541_debug, debug_809
    rx541_cur."!cursor_debug"("PASS", "term:sym<regex_declarator>", " at pos=", rx541_pos)
  debug_809:
    .return (rx541_cur)
  rx541_restart:
.annotate 'line', 10
    if_null rx541_debug, debug_810
    rx541_cur."!cursor_debug"("NEXT", "term:sym<regex_declarator>")
  debug_810:
  rx541_fail:
    (rx541_rep, rx541_pos, $I10, $P10) = rx541_cur."!mark_fail"(0)
    lt rx541_pos, -1, rx541_done
    eq rx541_pos, -1, rx541_fail
    jump $I10
  rx541_done:
    rx541_cur."!cursor_fail"()
    if_null rx541_debug, debug_811
    rx541_cur."!cursor_debug"("FAIL", "term:sym<regex_declarator>")
  debug_811:
    .return (rx541_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<regex_declarator>"  :nsentry("!PREFIX__term:sym<regex_declarator>") :subid("121_1302110486.758") :method
.annotate 'line', 10
    $P543 = self."!PREFIX__!subrule"("regex_declarator", "")
    new $P544, "ResizablePMCArray"
    push $P544, $P543
    .return ($P544)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<statement_prefix>"  :subid("122_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx547_tgt
    .local int rx547_pos
    .local int rx547_off
    .local int rx547_eos
    .local int rx547_rep
    .local pmc rx547_cur
    .local pmc rx547_debug
    (rx547_cur, rx547_pos, rx547_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx547_cur
    .local pmc match
    .lex "$/", match
    length rx547_eos, rx547_tgt
    gt rx547_pos, rx547_eos, rx547_done
    set rx547_off, 0
    lt rx547_pos, 2, rx547_start
    sub rx547_off, rx547_pos, 1
    substr rx547_tgt, rx547_tgt, rx547_off
  rx547_start:
    eq $I10, 1, rx547_restart
    if_null rx547_debug, debug_812
    rx547_cur."!cursor_debug"("START", "term:sym<statement_prefix>")
  debug_812:
    $I10 = self.'from'()
    ne $I10, -1, rxscan551_done
    goto rxscan551_scan
  rxscan551_loop:
    (rx547_pos) = rx547_cur."from"()
    inc rx547_pos
    rx547_cur."!cursor_from"(rx547_pos)
    ge rx547_pos, rx547_eos, rxscan551_done
  rxscan551_scan:
    set_addr $I10, rxscan551_loop
    rx547_cur."!mark_push"(0, rx547_pos, $I10)
  rxscan551_done:
.annotate 'line', 279
  # rx subrule "statement_prefix" subtype=capture negate=
    rx547_cur."!cursor_pos"(rx547_pos)
    $P10 = rx547_cur."statement_prefix"()
    unless $P10, rx547_fail
    rx547_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_prefix")
    rx547_pos = $P10."pos"()
  # rx pass
    rx547_cur."!cursor_pass"(rx547_pos, "term:sym<statement_prefix>")
    if_null rx547_debug, debug_813
    rx547_cur."!cursor_debug"("PASS", "term:sym<statement_prefix>", " at pos=", rx547_pos)
  debug_813:
    .return (rx547_cur)
  rx547_restart:
.annotate 'line', 10
    if_null rx547_debug, debug_814
    rx547_cur."!cursor_debug"("NEXT", "term:sym<statement_prefix>")
  debug_814:
  rx547_fail:
    (rx547_rep, rx547_pos, $I10, $P10) = rx547_cur."!mark_fail"(0)
    lt rx547_pos, -1, rx547_done
    eq rx547_pos, -1, rx547_fail
    jump $I10
  rx547_done:
    rx547_cur."!cursor_fail"()
    if_null rx547_debug, debug_815
    rx547_cur."!cursor_debug"("FAIL", "term:sym<statement_prefix>")
  debug_815:
    .return (rx547_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<statement_prefix>"  :nsentry("!PREFIX__term:sym<statement_prefix>") :subid("123_1302110486.758") :method
.annotate 'line', 10
    $P549 = self."!PREFIX__!subrule"("statement_prefix", "")
    new $P550, "ResizablePMCArray"
    push $P550, $P549
    .return ($P550)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<lambda>"  :subid("124_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx553_tgt
    .local int rx553_pos
    .local int rx553_off
    .local int rx553_eos
    .local int rx553_rep
    .local pmc rx553_cur
    .local pmc rx553_debug
    (rx553_cur, rx553_pos, rx553_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx553_cur
    .local pmc match
    .lex "$/", match
    length rx553_eos, rx553_tgt
    gt rx553_pos, rx553_eos, rx553_done
    set rx553_off, 0
    lt rx553_pos, 2, rx553_start
    sub rx553_off, rx553_pos, 1
    substr rx553_tgt, rx553_tgt, rx553_off
  rx553_start:
    eq $I10, 1, rx553_restart
    if_null rx553_debug, debug_816
    rx553_cur."!cursor_debug"("START", "term:sym<lambda>")
  debug_816:
    $I10 = self.'from'()
    ne $I10, -1, rxscan556_done
    goto rxscan556_scan
  rxscan556_loop:
    (rx553_pos) = rx553_cur."from"()
    inc rx553_pos
    rx553_cur."!cursor_from"(rx553_pos)
    ge rx553_pos, rx553_eos, rxscan556_done
  rxscan556_scan:
    set_addr $I10, rxscan556_loop
    rx553_cur."!mark_push"(0, rx553_pos, $I10)
  rxscan556_done:
.annotate 'line', 280
  # rx subrule "lambda" subtype=zerowidth negate=
    rx553_cur."!cursor_pos"(rx553_pos)
    $P10 = rx553_cur."lambda"()
    unless $P10, rx553_fail
  # rx subrule "pblock" subtype=capture negate=
    rx553_cur."!cursor_pos"(rx553_pos)
    $P10 = rx553_cur."pblock"()
    unless $P10, rx553_fail
    rx553_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx553_pos = $P10."pos"()
  # rx pass
    rx553_cur."!cursor_pass"(rx553_pos, "term:sym<lambda>")
    if_null rx553_debug, debug_817
    rx553_cur."!cursor_debug"("PASS", "term:sym<lambda>", " at pos=", rx553_pos)
  debug_817:
    .return (rx553_cur)
  rx553_restart:
.annotate 'line', 10
    if_null rx553_debug, debug_818
    rx553_cur."!cursor_debug"("NEXT", "term:sym<lambda>")
  debug_818:
  rx553_fail:
    (rx553_rep, rx553_pos, $I10, $P10) = rx553_cur."!mark_fail"(0)
    lt rx553_pos, -1, rx553_done
    eq rx553_pos, -1, rx553_fail
    jump $I10
  rx553_done:
    rx553_cur."!cursor_fail"()
    if_null rx553_debug, debug_819
    rx553_cur."!cursor_debug"("FAIL", "term:sym<lambda>")
  debug_819:
    .return (rx553_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<lambda>"  :nsentry("!PREFIX__term:sym<lambda>") :subid("125_1302110486.758") :method
.annotate 'line', 10
    new $P555, "ResizablePMCArray"
    push $P555, ""
    .return ($P555)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "fatarrow"  :subid("126_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx558_tgt
    .local int rx558_pos
    .local int rx558_off
    .local int rx558_eos
    .local int rx558_rep
    .local pmc rx558_cur
    .local pmc rx558_debug
    (rx558_cur, rx558_pos, rx558_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx558_cur
    .local pmc match
    .lex "$/", match
    length rx558_eos, rx558_tgt
    gt rx558_pos, rx558_eos, rx558_done
    set rx558_off, 0
    lt rx558_pos, 2, rx558_start
    sub rx558_off, rx558_pos, 1
    substr rx558_tgt, rx558_tgt, rx558_off
  rx558_start:
    eq $I10, 1, rx558_restart
    if_null rx558_debug, debug_820
    rx558_cur."!cursor_debug"("START", "fatarrow")
  debug_820:
    $I10 = self.'from'()
    ne $I10, -1, rxscan562_done
    goto rxscan562_scan
  rxscan562_loop:
    (rx558_pos) = rx558_cur."from"()
    inc rx558_pos
    rx558_cur."!cursor_from"(rx558_pos)
    ge rx558_pos, rx558_eos, rxscan562_done
  rxscan562_scan:
    set_addr $I10, rxscan562_loop
    rx558_cur."!mark_push"(0, rx558_pos, $I10)
  rxscan562_done:
.annotate 'line', 283
  # rx subrule "identifier" subtype=capture negate=
    rx558_cur."!cursor_pos"(rx558_pos)
    $P10 = rx558_cur."identifier"()
    unless $P10, rx558_fail
    rx558_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("key")
    rx558_pos = $P10."pos"()
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx558_pos, rx558_off
    set rx558_rep, 0
    sub $I12, rx558_eos, rx558_pos
  rxenumcharlistq563_loop:
    le $I12, 0, rxenumcharlistq563_done
    substr $S10, rx558_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq563_done
    inc rx558_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq563_loop
  rxenumcharlistq563_done:
    add rx558_pos, rx558_pos, rx558_rep
  # rx literal  "=>"
    add $I11, rx558_pos, 2
    gt $I11, rx558_eos, rx558_fail
    sub $I11, rx558_pos, rx558_off
    substr $S10, rx558_tgt, $I11, 2
    ne $S10, "=>", rx558_fail
    add rx558_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx558_cur."!cursor_pos"(rx558_pos)
    $P10 = rx558_cur."ws"()
    unless $P10, rx558_fail
    rx558_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx558_cur."!cursor_pos"(rx558_pos)
    $P10 = rx558_cur."EXPR"("i=")
    unless $P10, rx558_fail
    rx558_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("val")
    rx558_pos = $P10."pos"()
.annotate 'line', 282
  # rx pass
    rx558_cur."!cursor_pass"(rx558_pos, "fatarrow")
    if_null rx558_debug, debug_821
    rx558_cur."!cursor_debug"("PASS", "fatarrow", " at pos=", rx558_pos)
  debug_821:
    .return (rx558_cur)
  rx558_restart:
.annotate 'line', 10
    if_null rx558_debug, debug_822
    rx558_cur."!cursor_debug"("NEXT", "fatarrow")
  debug_822:
  rx558_fail:
    (rx558_rep, rx558_pos, $I10, $P10) = rx558_cur."!mark_fail"(0)
    lt rx558_pos, -1, rx558_done
    eq rx558_pos, -1, rx558_fail
    jump $I10
  rx558_done:
    rx558_cur."!cursor_fail"()
    if_null rx558_debug, debug_823
    rx558_cur."!cursor_debug"("FAIL", "fatarrow")
  debug_823:
    .return (rx558_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__fatarrow"  :nsentry("!PREFIX__fatarrow") :subid("127_1302110486.758") :method
.annotate 'line', 10
    $P560 = self."!PREFIX__!subrule"("identifier", "")
    new $P561, "ResizablePMCArray"
    push $P561, $P560
    .return ($P561)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "colonpair"  :subid("128_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx565_tgt
    .local int rx565_pos
    .local int rx565_off
    .local int rx565_eos
    .local int rx565_rep
    .local pmc rx565_cur
    .local pmc rx565_debug
    (rx565_cur, rx565_pos, rx565_tgt, $I10) = self."!cursor_start"()
    rx565_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx565_cur
    .local pmc match
    .lex "$/", match
    length rx565_eos, rx565_tgt
    gt rx565_pos, rx565_eos, rx565_done
    set rx565_off, 0
    lt rx565_pos, 2, rx565_start
    sub rx565_off, rx565_pos, 1
    substr rx565_tgt, rx565_tgt, rx565_off
  rx565_start:
    eq $I10, 1, rx565_restart
    if_null rx565_debug, debug_824
    rx565_cur."!cursor_debug"("START", "colonpair")
  debug_824:
    $I10 = self.'from'()
    ne $I10, -1, rxscan571_done
    goto rxscan571_scan
  rxscan571_loop:
    (rx565_pos) = rx565_cur."from"()
    inc rx565_pos
    rx565_cur."!cursor_from"(rx565_pos)
    ge rx565_pos, rx565_eos, rxscan571_done
  rxscan571_scan:
    set_addr $I10, rxscan571_loop
    rx565_cur."!mark_push"(0, rx565_pos, $I10)
  rxscan571_done:
.annotate 'line', 287
  # rx literal  ":"
    add $I11, rx565_pos, 1
    gt $I11, rx565_eos, rx565_fail
    sub $I11, rx565_pos, rx565_off
    ord $I11, rx565_tgt, $I11
    ne $I11, 58, rx565_fail
    add rx565_pos, 1
  alt572_0:
.annotate 'line', 288
    set_addr $I10, alt572_1
    rx565_cur."!mark_push"(0, rx565_pos, $I10)
.annotate 'line', 289
  # rx subcapture "not"
    set_addr $I10, rxcap_573_fail
    rx565_cur."!mark_push"(0, rx565_pos, $I10)
  # rx literal  "!"
    add $I11, rx565_pos, 1
    gt $I11, rx565_eos, rx565_fail
    sub $I11, rx565_pos, rx565_off
    ord $I11, rx565_tgt, $I11
    ne $I11, 33, rx565_fail
    add rx565_pos, 1
    set_addr $I10, rxcap_573_fail
    ($I12, $I11) = rx565_cur."!mark_peek"($I10)
    rx565_cur."!cursor_pos"($I11)
    ($P10) = rx565_cur."!cursor_start"()
    $P10."!cursor_pass"(rx565_pos, "")
    rx565_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("not")
    goto rxcap_573_done
  rxcap_573_fail:
    goto rx565_fail
  rxcap_573_done:
  # rx subrule "identifier" subtype=capture negate=
    rx565_cur."!cursor_pos"(rx565_pos)
    $P10 = rx565_cur."identifier"()
    unless $P10, rx565_fail
    rx565_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx565_pos = $P10."pos"()
    goto alt572_end
  alt572_1:
    set_addr $I10, alt572_2
    rx565_cur."!mark_push"(0, rx565_pos, $I10)
.annotate 'line', 290
  # rx subrule "identifier" subtype=capture negate=
    rx565_cur."!cursor_pos"(rx565_pos)
    $P10 = rx565_cur."identifier"()
    unless $P10, rx565_fail
    rx565_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx565_pos = $P10."pos"()
  # rx rxquantr574 ** 0..1
    set_addr $I10, rxquantr574_done
    rx565_cur."!mark_push"(0, rx565_pos, $I10)
  rxquantr574_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx565_cur."!cursor_pos"(rx565_pos)
    $P10 = rx565_cur."circumfix"()
    unless $P10, rx565_fail
    goto rxsubrule575_pass
  rxsubrule575_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx565_fail
  rxsubrule575_pass:
    set_addr $I10, rxsubrule575_back
    rx565_cur."!mark_push"(0, rx565_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx565_pos = $P10."pos"()
    set_addr $I10, rxquantr574_done
    (rx565_rep) = rx565_cur."!mark_commit"($I10)
  rxquantr574_done:
    goto alt572_end
  alt572_2:
.annotate 'line', 291
  # rx subrule "circumfix" subtype=capture negate=
    rx565_cur."!cursor_pos"(rx565_pos)
    $P10 = rx565_cur."circumfix"()
    unless $P10, rx565_fail
    rx565_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("circumfix")
    rx565_pos = $P10."pos"()
  alt572_end:
.annotate 'line', 286
  # rx pass
    rx565_cur."!cursor_pass"(rx565_pos, "colonpair")
    if_null rx565_debug, debug_825
    rx565_cur."!cursor_debug"("PASS", "colonpair", " at pos=", rx565_pos)
  debug_825:
    .return (rx565_cur)
  rx565_restart:
.annotate 'line', 10
    if_null rx565_debug, debug_826
    rx565_cur."!cursor_debug"("NEXT", "colonpair")
  debug_826:
  rx565_fail:
    (rx565_rep, rx565_pos, $I10, $P10) = rx565_cur."!mark_fail"(0)
    lt rx565_pos, -1, rx565_done
    eq rx565_pos, -1, rx565_fail
    jump $I10
  rx565_done:
    rx565_cur."!cursor_fail"()
    if_null rx565_debug, debug_827
    rx565_cur."!cursor_debug"("FAIL", "colonpair")
  debug_827:
    .return (rx565_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__colonpair"  :nsentry("!PREFIX__colonpair") :subid("129_1302110486.758") :method
.annotate 'line', 10
    $P567 = self."!PREFIX__!subrule"("circumfix", ":")
    $P568 = self."!PREFIX__!subrule"("identifier", ":")
    $P569 = self."!PREFIX__!subrule"("identifier", ":!")
    new $P570, "ResizablePMCArray"
    push $P570, $P567
    push $P570, $P568
    push $P570, $P569
    .return ($P570)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable"  :subid("130_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx577_tgt
    .local int rx577_pos
    .local int rx577_off
    .local int rx577_eos
    .local int rx577_rep
    .local pmc rx577_cur
    .local pmc rx577_debug
    (rx577_cur, rx577_pos, rx577_tgt, $I10) = self."!cursor_start"()
    rx577_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx577_cur
    .local pmc match
    .lex "$/", match
    length rx577_eos, rx577_tgt
    gt rx577_pos, rx577_eos, rx577_done
    set rx577_off, 0
    lt rx577_pos, 2, rx577_start
    sub rx577_off, rx577_pos, 1
    substr rx577_tgt, rx577_tgt, rx577_off
  rx577_start:
    eq $I10, 1, rx577_restart
    if_null rx577_debug, debug_828
    rx577_cur."!cursor_debug"("START", "variable")
  debug_828:
    $I10 = self.'from'()
    ne $I10, -1, rxscan582_done
    goto rxscan582_scan
  rxscan582_loop:
    (rx577_pos) = rx577_cur."from"()
    inc rx577_pos
    rx577_cur."!cursor_from"(rx577_pos)
    ge rx577_pos, rx577_eos, rxscan582_done
  rxscan582_scan:
    set_addr $I10, rxscan582_loop
    rx577_cur."!mark_push"(0, rx577_pos, $I10)
  rxscan582_done:
  alt583_0:
.annotate 'line', 295
    set_addr $I10, alt583_1
    rx577_cur."!mark_push"(0, rx577_pos, $I10)
.annotate 'line', 296
  # rx subrule "sigil" subtype=capture negate=
    rx577_cur."!cursor_pos"(rx577_pos)
    $P10 = rx577_cur."sigil"()
    unless $P10, rx577_fail
    rx577_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx577_pos = $P10."pos"()
  # rx rxquantr584 ** 0..1
    set_addr $I10, rxquantr584_done
    rx577_cur."!mark_push"(0, rx577_pos, $I10)
  rxquantr584_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx577_cur."!cursor_pos"(rx577_pos)
    $P10 = rx577_cur."twigil"()
    unless $P10, rx577_fail
    goto rxsubrule585_pass
  rxsubrule585_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx577_fail
  rxsubrule585_pass:
    set_addr $I10, rxsubrule585_back
    rx577_cur."!mark_push"(0, rx577_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx577_pos = $P10."pos"()
    set_addr $I10, rxquantr584_done
    (rx577_rep) = rx577_cur."!mark_commit"($I10)
  rxquantr584_done:
  # rx subrule "name" subtype=capture negate=
    rx577_cur."!cursor_pos"(rx577_pos)
    $P10 = rx577_cur."name"()
    unless $P10, rx577_fail
    rx577_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    rx577_pos = $P10."pos"()
    goto alt583_end
  alt583_1:
    set_addr $I10, alt583_2
    rx577_cur."!mark_push"(0, rx577_pos, $I10)
.annotate 'line', 297
  # rx subrule "sigil" subtype=capture negate=
    rx577_cur."!cursor_pos"(rx577_pos)
    $P10 = rx577_cur."sigil"()
    unless $P10, rx577_fail
    rx577_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx577_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx577_pos, rx577_off
    substr $S10, rx577_tgt, $I10, 1
    index $I11, "<[", $S10
    lt $I11, 0, rx577_fail
  # rx subrule "postcircumfix" subtype=capture negate=
    rx577_cur."!cursor_pos"(rx577_pos)
    $P10 = rx577_cur."postcircumfix"()
    unless $P10, rx577_fail
    rx577_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("postcircumfix")
    rx577_pos = $P10."pos"()
    goto alt583_end
  alt583_2:
.annotate 'line', 298
  # rx subcapture "sigil"
    set_addr $I10, rxcap_586_fail
    rx577_cur."!mark_push"(0, rx577_pos, $I10)
  # rx literal  "$"
    add $I11, rx577_pos, 1
    gt $I11, rx577_eos, rx577_fail
    sub $I11, rx577_pos, rx577_off
    ord $I11, rx577_tgt, $I11
    ne $I11, 36, rx577_fail
    add rx577_pos, 1
    set_addr $I10, rxcap_586_fail
    ($I12, $I11) = rx577_cur."!mark_peek"($I10)
    rx577_cur."!cursor_pos"($I11)
    ($P10) = rx577_cur."!cursor_start"()
    $P10."!cursor_pass"(rx577_pos, "")
    rx577_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_586_done
  rxcap_586_fail:
    goto rx577_fail
  rxcap_586_done:
  # rx subcapture "desigilname"
    set_addr $I10, rxcap_587_fail
    rx577_cur."!mark_push"(0, rx577_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx577_pos, rx577_eos, rx577_fail
    sub $I10, rx577_pos, rx577_off
    substr $S10, rx577_tgt, $I10, 1
    index $I11, "/_!", $S10
    lt $I11, 0, rx577_fail
    inc rx577_pos
    set_addr $I10, rxcap_587_fail
    ($I12, $I11) = rx577_cur."!mark_peek"($I10)
    rx577_cur."!cursor_pos"($I11)
    ($P10) = rx577_cur."!cursor_start"()
    $P10."!cursor_pass"(rx577_pos, "")
    rx577_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    goto rxcap_587_done
  rxcap_587_fail:
    goto rx577_fail
  rxcap_587_done:
  alt583_end:
.annotate 'line', 295
  # rx pass
    rx577_cur."!cursor_pass"(rx577_pos, "variable")
    if_null rx577_debug, debug_829
    rx577_cur."!cursor_debug"("PASS", "variable", " at pos=", rx577_pos)
  debug_829:
    .return (rx577_cur)
  rx577_restart:
.annotate 'line', 10
    if_null rx577_debug, debug_830
    rx577_cur."!cursor_debug"("NEXT", "variable")
  debug_830:
  rx577_fail:
    (rx577_rep, rx577_pos, $I10, $P10) = rx577_cur."!mark_fail"(0)
    lt rx577_pos, -1, rx577_done
    eq rx577_pos, -1, rx577_fail
    jump $I10
  rx577_done:
    rx577_cur."!cursor_fail"()
    if_null rx577_debug, debug_831
    rx577_cur."!cursor_debug"("FAIL", "variable")
  debug_831:
    .return (rx577_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable"  :nsentry("!PREFIX__variable") :subid("131_1302110486.758") :method
.annotate 'line', 10
    $P579 = self."!PREFIX__!subrule"("sigil", "")
    $P580 = self."!PREFIX__!subrule"("sigil", "")
    new $P581, "ResizablePMCArray"
    push $P581, "$!"
    push $P581, "$_"
    push $P581, "$/"
    push $P581, $P579
    push $P581, $P580
    .return ($P581)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "sigil"  :subid("132_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx589_tgt
    .local int rx589_pos
    .local int rx589_off
    .local int rx589_eos
    .local int rx589_rep
    .local pmc rx589_cur
    .local pmc rx589_debug
    (rx589_cur, rx589_pos, rx589_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx589_cur
    .local pmc match
    .lex "$/", match
    length rx589_eos, rx589_tgt
    gt rx589_pos, rx589_eos, rx589_done
    set rx589_off, 0
    lt rx589_pos, 2, rx589_start
    sub rx589_off, rx589_pos, 1
    substr rx589_tgt, rx589_tgt, rx589_off
  rx589_start:
    eq $I10, 1, rx589_restart
    if_null rx589_debug, debug_832
    rx589_cur."!cursor_debug"("START", "sigil")
  debug_832:
    $I10 = self.'from'()
    ne $I10, -1, rxscan592_done
    goto rxscan592_scan
  rxscan592_loop:
    (rx589_pos) = rx589_cur."from"()
    inc rx589_pos
    rx589_cur."!cursor_from"(rx589_pos)
    ge rx589_pos, rx589_eos, rxscan592_done
  rxscan592_scan:
    set_addr $I10, rxscan592_loop
    rx589_cur."!mark_push"(0, rx589_pos, $I10)
  rxscan592_done:
.annotate 'line', 301
  # rx enumcharlist negate=0 
    ge rx589_pos, rx589_eos, rx589_fail
    sub $I10, rx589_pos, rx589_off
    substr $S10, rx589_tgt, $I10, 1
    index $I11, "$@%&", $S10
    lt $I11, 0, rx589_fail
    inc rx589_pos
  # rx pass
    rx589_cur."!cursor_pass"(rx589_pos, "sigil")
    if_null rx589_debug, debug_833
    rx589_cur."!cursor_debug"("PASS", "sigil", " at pos=", rx589_pos)
  debug_833:
    .return (rx589_cur)
  rx589_restart:
.annotate 'line', 10
    if_null rx589_debug, debug_834
    rx589_cur."!cursor_debug"("NEXT", "sigil")
  debug_834:
  rx589_fail:
    (rx589_rep, rx589_pos, $I10, $P10) = rx589_cur."!mark_fail"(0)
    lt rx589_pos, -1, rx589_done
    eq rx589_pos, -1, rx589_fail
    jump $I10
  rx589_done:
    rx589_cur."!cursor_fail"()
    if_null rx589_debug, debug_835
    rx589_cur."!cursor_debug"("FAIL", "sigil")
  debug_835:
    .return (rx589_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__sigil"  :nsentry("!PREFIX__sigil") :subid("133_1302110486.758") :method
.annotate 'line', 10
    new $P591, "ResizablePMCArray"
    push $P591, "&"
    push $P591, "%"
    push $P591, "@"
    push $P591, "$"
    .return ($P591)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "twigil"  :subid("134_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx594_tgt
    .local int rx594_pos
    .local int rx594_off
    .local int rx594_eos
    .local int rx594_rep
    .local pmc rx594_cur
    .local pmc rx594_debug
    (rx594_cur, rx594_pos, rx594_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx594_cur
    .local pmc match
    .lex "$/", match
    length rx594_eos, rx594_tgt
    gt rx594_pos, rx594_eos, rx594_done
    set rx594_off, 0
    lt rx594_pos, 2, rx594_start
    sub rx594_off, rx594_pos, 1
    substr rx594_tgt, rx594_tgt, rx594_off
  rx594_start:
    eq $I10, 1, rx594_restart
    if_null rx594_debug, debug_836
    rx594_cur."!cursor_debug"("START", "twigil")
  debug_836:
    $I10 = self.'from'()
    ne $I10, -1, rxscan597_done
    goto rxscan597_scan
  rxscan597_loop:
    (rx594_pos) = rx594_cur."from"()
    inc rx594_pos
    rx594_cur."!cursor_from"(rx594_pos)
    ge rx594_pos, rx594_eos, rxscan597_done
  rxscan597_scan:
    set_addr $I10, rxscan597_loop
    rx594_cur."!mark_push"(0, rx594_pos, $I10)
  rxscan597_done:
.annotate 'line', 303
  # rx enumcharlist negate=0 
    ge rx594_pos, rx594_eos, rx594_fail
    sub $I10, rx594_pos, rx594_off
    substr $S10, rx594_tgt, $I10, 1
    index $I11, "*!?", $S10
    lt $I11, 0, rx594_fail
    inc rx594_pos
  # rx pass
    rx594_cur."!cursor_pass"(rx594_pos, "twigil")
    if_null rx594_debug, debug_837
    rx594_cur."!cursor_debug"("PASS", "twigil", " at pos=", rx594_pos)
  debug_837:
    .return (rx594_cur)
  rx594_restart:
.annotate 'line', 10
    if_null rx594_debug, debug_838
    rx594_cur."!cursor_debug"("NEXT", "twigil")
  debug_838:
  rx594_fail:
    (rx594_rep, rx594_pos, $I10, $P10) = rx594_cur."!mark_fail"(0)
    lt rx594_pos, -1, rx594_done
    eq rx594_pos, -1, rx594_fail
    jump $I10
  rx594_done:
    rx594_cur."!cursor_fail"()
    if_null rx594_debug, debug_839
    rx594_cur."!cursor_debug"("FAIL", "twigil")
  debug_839:
    .return (rx594_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__twigil"  :nsentry("!PREFIX__twigil") :subid("135_1302110486.758") :method
.annotate 'line', 10
    new $P596, "ResizablePMCArray"
    push $P596, "?"
    push $P596, "!"
    push $P596, "*"
    .return ($P596)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator"  :subid("136_1302110486.758")
    .param pmc param_599
.annotate 'line', 305
    .lex "self", param_599
    $P600 = param_599."!protoregex"("package_declarator")
    .return ($P600)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator"  :subid("137_1302110486.758")
    .param pmc param_602
.annotate 'line', 305
    .lex "self", param_602
    $P603 = param_602."!PREFIX__!protoregex"("package_declarator")
    .return ($P603)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<module>"  :subid("138_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 307
    new $P605, "Undef"
    .lex "$*PACKAGE-SETUP", $P605
.annotate 'line', 308
    new $P606, "Undef"
    .lex "$*PKGDECL", $P606
.annotate 'line', 10
    .local string rx607_tgt
    .local int rx607_pos
    .local int rx607_off
    .local int rx607_eos
    .local int rx607_rep
    .local pmc rx607_cur
    .local pmc rx607_debug
    (rx607_cur, rx607_pos, rx607_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx607_cur
    .local pmc match
    .lex "$/", match
    length rx607_eos, rx607_tgt
    gt rx607_pos, rx607_eos, rx607_done
    set rx607_off, 0
    lt rx607_pos, 2, rx607_start
    sub rx607_off, rx607_pos, 1
    substr rx607_tgt, rx607_tgt, rx607_off
  rx607_start:
    eq $I10, 1, rx607_restart
    if_null rx607_debug, debug_840
    rx607_cur."!cursor_debug"("START", "package_declarator:sym<module>")
  debug_840:
    $I10 = self.'from'()
    ne $I10, -1, rxscan611_done
    goto rxscan611_scan
  rxscan611_loop:
    (rx607_pos) = rx607_cur."from"()
    inc rx607_pos
    rx607_cur."!cursor_from"(rx607_pos)
    ge rx607_pos, rx607_eos, rxscan611_done
  rxscan611_scan:
    set_addr $I10, rxscan611_loop
    rx607_cur."!mark_push"(0, rx607_pos, $I10)
  rxscan611_done:
.annotate 'line', 307
    rx607_cur."!cursor_pos"(rx607_pos)
    get_hll_global $P612, ["PAST"], "Stmts"
    $P613 = $P612."new"()
    store_lex "$*PACKAGE-SETUP", $P613
.annotate 'line', 308
    rx607_cur."!cursor_pos"(rx607_pos)
    new $P614, "String"
    assign $P614, "module"
    store_lex "$*PKGDECL", $P614
.annotate 'line', 309
  # rx subcapture "sym"
    set_addr $I10, rxcap_615_fail
    rx607_cur."!mark_push"(0, rx607_pos, $I10)
  # rx literal  "module"
    add $I11, rx607_pos, 6
    gt $I11, rx607_eos, rx607_fail
    sub $I11, rx607_pos, rx607_off
    substr $S10, rx607_tgt, $I11, 6
    ne $S10, "module", rx607_fail
    add rx607_pos, 6
    set_addr $I10, rxcap_615_fail
    ($I12, $I11) = rx607_cur."!mark_peek"($I10)
    rx607_cur."!cursor_pos"($I11)
    ($P10) = rx607_cur."!cursor_start"()
    $P10."!cursor_pass"(rx607_pos, "")
    rx607_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_615_done
  rxcap_615_fail:
    goto rx607_fail
  rxcap_615_done:
  # rx subrule "package_def" subtype=capture negate=
    rx607_cur."!cursor_pos"(rx607_pos)
    $P10 = rx607_cur."package_def"()
    unless $P10, rx607_fail
    rx607_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx607_pos = $P10."pos"()
.annotate 'line', 306
  # rx pass
    rx607_cur."!cursor_pass"(rx607_pos, "package_declarator:sym<module>")
    if_null rx607_debug, debug_841
    rx607_cur."!cursor_debug"("PASS", "package_declarator:sym<module>", " at pos=", rx607_pos)
  debug_841:
    .return (rx607_cur)
  rx607_restart:
.annotate 'line', 10
    if_null rx607_debug, debug_842
    rx607_cur."!cursor_debug"("NEXT", "package_declarator:sym<module>")
  debug_842:
  rx607_fail:
    (rx607_rep, rx607_pos, $I10, $P10) = rx607_cur."!mark_fail"(0)
    lt rx607_pos, -1, rx607_done
    eq rx607_pos, -1, rx607_fail
    jump $I10
  rx607_done:
    rx607_cur."!cursor_fail"()
    if_null rx607_debug, debug_843
    rx607_cur."!cursor_debug"("FAIL", "package_declarator:sym<module>")
  debug_843:
    .return (rx607_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<module>"  :nsentry("!PREFIX__package_declarator:sym<module>") :subid("139_1302110486.758") :method
.annotate 'line', 10
    $P609 = self."!PREFIX__!subrule"("package_def", "module")
    new $P610, "ResizablePMCArray"
    push $P610, $P609
    .return ($P610)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<knowhow>"  :subid("140_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 312
    new $P617, "Undef"
    .lex "$*PACKAGE-SETUP", $P617
.annotate 'line', 313
    new $P618, "Undef"
    .lex "$*PKGDECL", $P618
.annotate 'line', 10
    .local string rx619_tgt
    .local int rx619_pos
    .local int rx619_off
    .local int rx619_eos
    .local int rx619_rep
    .local pmc rx619_cur
    .local pmc rx619_debug
    (rx619_cur, rx619_pos, rx619_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx619_cur
    .local pmc match
    .lex "$/", match
    length rx619_eos, rx619_tgt
    gt rx619_pos, rx619_eos, rx619_done
    set rx619_off, 0
    lt rx619_pos, 2, rx619_start
    sub rx619_off, rx619_pos, 1
    substr rx619_tgt, rx619_tgt, rx619_off
  rx619_start:
    eq $I10, 1, rx619_restart
    if_null rx619_debug, debug_844
    rx619_cur."!cursor_debug"("START", "package_declarator:sym<knowhow>")
  debug_844:
    $I10 = self.'from'()
    ne $I10, -1, rxscan623_done
    goto rxscan623_scan
  rxscan623_loop:
    (rx619_pos) = rx619_cur."from"()
    inc rx619_pos
    rx619_cur."!cursor_from"(rx619_pos)
    ge rx619_pos, rx619_eos, rxscan623_done
  rxscan623_scan:
    set_addr $I10, rxscan623_loop
    rx619_cur."!mark_push"(0, rx619_pos, $I10)
  rxscan623_done:
.annotate 'line', 312
    rx619_cur."!cursor_pos"(rx619_pos)
    get_hll_global $P624, ["PAST"], "Stmts"
    $P625 = $P624."new"()
    store_lex "$*PACKAGE-SETUP", $P625
.annotate 'line', 313
    rx619_cur."!cursor_pos"(rx619_pos)
    new $P626, "String"
    assign $P626, "knowhow"
    store_lex "$*PKGDECL", $P626
.annotate 'line', 314
  # rx subcapture "sym"
    set_addr $I10, rxcap_627_fail
    rx619_cur."!mark_push"(0, rx619_pos, $I10)
  # rx literal  "knowhow"
    add $I11, rx619_pos, 7
    gt $I11, rx619_eos, rx619_fail
    sub $I11, rx619_pos, rx619_off
    substr $S10, rx619_tgt, $I11, 7
    ne $S10, "knowhow", rx619_fail
    add rx619_pos, 7
    set_addr $I10, rxcap_627_fail
    ($I12, $I11) = rx619_cur."!mark_peek"($I10)
    rx619_cur."!cursor_pos"($I11)
    ($P10) = rx619_cur."!cursor_start"()
    $P10."!cursor_pass"(rx619_pos, "")
    rx619_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_627_done
  rxcap_627_fail:
    goto rx619_fail
  rxcap_627_done:
  # rx subrule "package_def" subtype=capture negate=
    rx619_cur."!cursor_pos"(rx619_pos)
    $P10 = rx619_cur."package_def"()
    unless $P10, rx619_fail
    rx619_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx619_pos = $P10."pos"()
.annotate 'line', 311
  # rx pass
    rx619_cur."!cursor_pass"(rx619_pos, "package_declarator:sym<knowhow>")
    if_null rx619_debug, debug_845
    rx619_cur."!cursor_debug"("PASS", "package_declarator:sym<knowhow>", " at pos=", rx619_pos)
  debug_845:
    .return (rx619_cur)
  rx619_restart:
.annotate 'line', 10
    if_null rx619_debug, debug_846
    rx619_cur."!cursor_debug"("NEXT", "package_declarator:sym<knowhow>")
  debug_846:
  rx619_fail:
    (rx619_rep, rx619_pos, $I10, $P10) = rx619_cur."!mark_fail"(0)
    lt rx619_pos, -1, rx619_done
    eq rx619_pos, -1, rx619_fail
    jump $I10
  rx619_done:
    rx619_cur."!cursor_fail"()
    if_null rx619_debug, debug_847
    rx619_cur."!cursor_debug"("FAIL", "package_declarator:sym<knowhow>")
  debug_847:
    .return (rx619_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<knowhow>"  :nsentry("!PREFIX__package_declarator:sym<knowhow>") :subid("141_1302110486.758") :method
.annotate 'line', 10
    $P621 = self."!PREFIX__!subrule"("package_def", "knowhow")
    new $P622, "ResizablePMCArray"
    push $P622, $P621
    .return ($P622)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<class>"  :subid("142_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 317
    new $P629, "Undef"
    .lex "$*PACKAGE-SETUP", $P629
.annotate 'line', 318
    new $P630, "Undef"
    .lex "$*PKGDECL", $P630
.annotate 'line', 10
    .local string rx631_tgt
    .local int rx631_pos
    .local int rx631_off
    .local int rx631_eos
    .local int rx631_rep
    .local pmc rx631_cur
    .local pmc rx631_debug
    (rx631_cur, rx631_pos, rx631_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx631_cur
    .local pmc match
    .lex "$/", match
    length rx631_eos, rx631_tgt
    gt rx631_pos, rx631_eos, rx631_done
    set rx631_off, 0
    lt rx631_pos, 2, rx631_start
    sub rx631_off, rx631_pos, 1
    substr rx631_tgt, rx631_tgt, rx631_off
  rx631_start:
    eq $I10, 1, rx631_restart
    if_null rx631_debug, debug_848
    rx631_cur."!cursor_debug"("START", "package_declarator:sym<class>")
  debug_848:
    $I10 = self.'from'()
    ne $I10, -1, rxscan635_done
    goto rxscan635_scan
  rxscan635_loop:
    (rx631_pos) = rx631_cur."from"()
    inc rx631_pos
    rx631_cur."!cursor_from"(rx631_pos)
    ge rx631_pos, rx631_eos, rxscan635_done
  rxscan635_scan:
    set_addr $I10, rxscan635_loop
    rx631_cur."!mark_push"(0, rx631_pos, $I10)
  rxscan635_done:
.annotate 'line', 317
    rx631_cur."!cursor_pos"(rx631_pos)
    get_hll_global $P636, ["PAST"], "Stmts"
    $P637 = $P636."new"()
    store_lex "$*PACKAGE-SETUP", $P637
.annotate 'line', 318
    rx631_cur."!cursor_pos"(rx631_pos)
    new $P638, "String"
    assign $P638, "class"
    store_lex "$*PKGDECL", $P638
.annotate 'line', 319
  # rx subcapture "sym"
    set_addr $I10, rxcap_639_fail
    rx631_cur."!mark_push"(0, rx631_pos, $I10)
  # rx literal  "class"
    add $I11, rx631_pos, 5
    gt $I11, rx631_eos, rx631_fail
    sub $I11, rx631_pos, rx631_off
    substr $S10, rx631_tgt, $I11, 5
    ne $S10, "class", rx631_fail
    add rx631_pos, 5
    set_addr $I10, rxcap_639_fail
    ($I12, $I11) = rx631_cur."!mark_peek"($I10)
    rx631_cur."!cursor_pos"($I11)
    ($P10) = rx631_cur."!cursor_start"()
    $P10."!cursor_pass"(rx631_pos, "")
    rx631_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_639_done
  rxcap_639_fail:
    goto rx631_fail
  rxcap_639_done:
  # rx subrule "package_def" subtype=capture negate=
    rx631_cur."!cursor_pos"(rx631_pos)
    $P10 = rx631_cur."package_def"()
    unless $P10, rx631_fail
    rx631_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx631_pos = $P10."pos"()
.annotate 'line', 316
  # rx pass
    rx631_cur."!cursor_pass"(rx631_pos, "package_declarator:sym<class>")
    if_null rx631_debug, debug_849
    rx631_cur."!cursor_debug"("PASS", "package_declarator:sym<class>", " at pos=", rx631_pos)
  debug_849:
    .return (rx631_cur)
  rx631_restart:
.annotate 'line', 10
    if_null rx631_debug, debug_850
    rx631_cur."!cursor_debug"("NEXT", "package_declarator:sym<class>")
  debug_850:
  rx631_fail:
    (rx631_rep, rx631_pos, $I10, $P10) = rx631_cur."!mark_fail"(0)
    lt rx631_pos, -1, rx631_done
    eq rx631_pos, -1, rx631_fail
    jump $I10
  rx631_done:
    rx631_cur."!cursor_fail"()
    if_null rx631_debug, debug_851
    rx631_cur."!cursor_debug"("FAIL", "package_declarator:sym<class>")
  debug_851:
    .return (rx631_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<class>"  :nsentry("!PREFIX__package_declarator:sym<class>") :subid("143_1302110486.758") :method
.annotate 'line', 10
    $P633 = self."!PREFIX__!subrule"("package_def", "class")
    new $P634, "ResizablePMCArray"
    push $P634, $P633
    .return ($P634)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<grammar>"  :subid("144_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 322
    new $P641, "Undef"
    .lex "$*PACKAGE-SETUP", $P641
.annotate 'line', 323
    new $P642, "Undef"
    .lex "$*PKGDECL", $P642
.annotate 'line', 10
    .local string rx643_tgt
    .local int rx643_pos
    .local int rx643_off
    .local int rx643_eos
    .local int rx643_rep
    .local pmc rx643_cur
    .local pmc rx643_debug
    (rx643_cur, rx643_pos, rx643_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx643_cur
    .local pmc match
    .lex "$/", match
    length rx643_eos, rx643_tgt
    gt rx643_pos, rx643_eos, rx643_done
    set rx643_off, 0
    lt rx643_pos, 2, rx643_start
    sub rx643_off, rx643_pos, 1
    substr rx643_tgt, rx643_tgt, rx643_off
  rx643_start:
    eq $I10, 1, rx643_restart
    if_null rx643_debug, debug_852
    rx643_cur."!cursor_debug"("START", "package_declarator:sym<grammar>")
  debug_852:
    $I10 = self.'from'()
    ne $I10, -1, rxscan647_done
    goto rxscan647_scan
  rxscan647_loop:
    (rx643_pos) = rx643_cur."from"()
    inc rx643_pos
    rx643_cur."!cursor_from"(rx643_pos)
    ge rx643_pos, rx643_eos, rxscan647_done
  rxscan647_scan:
    set_addr $I10, rxscan647_loop
    rx643_cur."!mark_push"(0, rx643_pos, $I10)
  rxscan647_done:
.annotate 'line', 322
    rx643_cur."!cursor_pos"(rx643_pos)
    get_hll_global $P648, ["PAST"], "Stmts"
    $P649 = $P648."new"()
    store_lex "$*PACKAGE-SETUP", $P649
.annotate 'line', 323
    rx643_cur."!cursor_pos"(rx643_pos)
    new $P650, "String"
    assign $P650, "grammar"
    store_lex "$*PKGDECL", $P650
.annotate 'line', 324
  # rx subcapture "sym"
    set_addr $I10, rxcap_651_fail
    rx643_cur."!mark_push"(0, rx643_pos, $I10)
  # rx literal  "grammar"
    add $I11, rx643_pos, 7
    gt $I11, rx643_eos, rx643_fail
    sub $I11, rx643_pos, rx643_off
    substr $S10, rx643_tgt, $I11, 7
    ne $S10, "grammar", rx643_fail
    add rx643_pos, 7
    set_addr $I10, rxcap_651_fail
    ($I12, $I11) = rx643_cur."!mark_peek"($I10)
    rx643_cur."!cursor_pos"($I11)
    ($P10) = rx643_cur."!cursor_start"()
    $P10."!cursor_pass"(rx643_pos, "")
    rx643_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_651_done
  rxcap_651_fail:
    goto rx643_fail
  rxcap_651_done:
  # rx subrule "package_def" subtype=capture negate=
    rx643_cur."!cursor_pos"(rx643_pos)
    $P10 = rx643_cur."package_def"()
    unless $P10, rx643_fail
    rx643_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx643_pos = $P10."pos"()
.annotate 'line', 321
  # rx pass
    rx643_cur."!cursor_pass"(rx643_pos, "package_declarator:sym<grammar>")
    if_null rx643_debug, debug_853
    rx643_cur."!cursor_debug"("PASS", "package_declarator:sym<grammar>", " at pos=", rx643_pos)
  debug_853:
    .return (rx643_cur)
  rx643_restart:
.annotate 'line', 10
    if_null rx643_debug, debug_854
    rx643_cur."!cursor_debug"("NEXT", "package_declarator:sym<grammar>")
  debug_854:
  rx643_fail:
    (rx643_rep, rx643_pos, $I10, $P10) = rx643_cur."!mark_fail"(0)
    lt rx643_pos, -1, rx643_done
    eq rx643_pos, -1, rx643_fail
    jump $I10
  rx643_done:
    rx643_cur."!cursor_fail"()
    if_null rx643_debug, debug_855
    rx643_cur."!cursor_debug"("FAIL", "package_declarator:sym<grammar>")
  debug_855:
    .return (rx643_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<grammar>"  :nsentry("!PREFIX__package_declarator:sym<grammar>") :subid("145_1302110486.758") :method
.annotate 'line', 10
    $P645 = self."!PREFIX__!subrule"("package_def", "grammar")
    new $P646, "ResizablePMCArray"
    push $P646, $P645
    .return ($P646)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<role>"  :subid("146_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 327
    new $P653, "Undef"
    .lex "$*PACKAGE-SETUP", $P653
.annotate 'line', 328
    new $P654, "Undef"
    .lex "$*PKGDECL", $P654
.annotate 'line', 10
    .local string rx655_tgt
    .local int rx655_pos
    .local int rx655_off
    .local int rx655_eos
    .local int rx655_rep
    .local pmc rx655_cur
    .local pmc rx655_debug
    (rx655_cur, rx655_pos, rx655_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx655_cur
    .local pmc match
    .lex "$/", match
    length rx655_eos, rx655_tgt
    gt rx655_pos, rx655_eos, rx655_done
    set rx655_off, 0
    lt rx655_pos, 2, rx655_start
    sub rx655_off, rx655_pos, 1
    substr rx655_tgt, rx655_tgt, rx655_off
  rx655_start:
    eq $I10, 1, rx655_restart
    if_null rx655_debug, debug_856
    rx655_cur."!cursor_debug"("START", "package_declarator:sym<role>")
  debug_856:
    $I10 = self.'from'()
    ne $I10, -1, rxscan659_done
    goto rxscan659_scan
  rxscan659_loop:
    (rx655_pos) = rx655_cur."from"()
    inc rx655_pos
    rx655_cur."!cursor_from"(rx655_pos)
    ge rx655_pos, rx655_eos, rxscan659_done
  rxscan659_scan:
    set_addr $I10, rxscan659_loop
    rx655_cur."!mark_push"(0, rx655_pos, $I10)
  rxscan659_done:
.annotate 'line', 327
    rx655_cur."!cursor_pos"(rx655_pos)
    get_hll_global $P660, ["PAST"], "Stmts"
    $P661 = $P660."new"()
    store_lex "$*PACKAGE-SETUP", $P661
.annotate 'line', 328
    rx655_cur."!cursor_pos"(rx655_pos)
    new $P662, "String"
    assign $P662, "role"
    store_lex "$*PKGDECL", $P662
.annotate 'line', 329
  # rx subcapture "sym"
    set_addr $I10, rxcap_663_fail
    rx655_cur."!mark_push"(0, rx655_pos, $I10)
  # rx literal  "role"
    add $I11, rx655_pos, 4
    gt $I11, rx655_eos, rx655_fail
    sub $I11, rx655_pos, rx655_off
    substr $S10, rx655_tgt, $I11, 4
    ne $S10, "role", rx655_fail
    add rx655_pos, 4
    set_addr $I10, rxcap_663_fail
    ($I12, $I11) = rx655_cur."!mark_peek"($I10)
    rx655_cur."!cursor_pos"($I11)
    ($P10) = rx655_cur."!cursor_start"()
    $P10."!cursor_pass"(rx655_pos, "")
    rx655_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_663_done
  rxcap_663_fail:
    goto rx655_fail
  rxcap_663_done:
  # rx subrule "package_def" subtype=capture negate=
    rx655_cur."!cursor_pos"(rx655_pos)
    $P10 = rx655_cur."package_def"()
    unless $P10, rx655_fail
    rx655_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx655_pos = $P10."pos"()
.annotate 'line', 326
  # rx pass
    rx655_cur."!cursor_pass"(rx655_pos, "package_declarator:sym<role>")
    if_null rx655_debug, debug_857
    rx655_cur."!cursor_debug"("PASS", "package_declarator:sym<role>", " at pos=", rx655_pos)
  debug_857:
    .return (rx655_cur)
  rx655_restart:
.annotate 'line', 10
    if_null rx655_debug, debug_858
    rx655_cur."!cursor_debug"("NEXT", "package_declarator:sym<role>")
  debug_858:
  rx655_fail:
    (rx655_rep, rx655_pos, $I10, $P10) = rx655_cur."!mark_fail"(0)
    lt rx655_pos, -1, rx655_done
    eq rx655_pos, -1, rx655_fail
    jump $I10
  rx655_done:
    rx655_cur."!cursor_fail"()
    if_null rx655_debug, debug_859
    rx655_cur."!cursor_debug"("FAIL", "package_declarator:sym<role>")
  debug_859:
    .return (rx655_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<role>"  :nsentry("!PREFIX__package_declarator:sym<role>") :subid("147_1302110486.758") :method
.annotate 'line', 10
    $P657 = self."!PREFIX__!subrule"("package_def", "role")
    new $P658, "ResizablePMCArray"
    push $P658, $P657
    .return ($P658)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<native>"  :subid("148_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 332
    new $P665, "Undef"
    .lex "$*PACKAGE-SETUP", $P665
.annotate 'line', 333
    new $P666, "Undef"
    .lex "$*PKGDECL", $P666
.annotate 'line', 10
    .local string rx667_tgt
    .local int rx667_pos
    .local int rx667_off
    .local int rx667_eos
    .local int rx667_rep
    .local pmc rx667_cur
    .local pmc rx667_debug
    (rx667_cur, rx667_pos, rx667_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx667_cur
    .local pmc match
    .lex "$/", match
    length rx667_eos, rx667_tgt
    gt rx667_pos, rx667_eos, rx667_done
    set rx667_off, 0
    lt rx667_pos, 2, rx667_start
    sub rx667_off, rx667_pos, 1
    substr rx667_tgt, rx667_tgt, rx667_off
  rx667_start:
    eq $I10, 1, rx667_restart
    if_null rx667_debug, debug_860
    rx667_cur."!cursor_debug"("START", "package_declarator:sym<native>")
  debug_860:
    $I10 = self.'from'()
    ne $I10, -1, rxscan671_done
    goto rxscan671_scan
  rxscan671_loop:
    (rx667_pos) = rx667_cur."from"()
    inc rx667_pos
    rx667_cur."!cursor_from"(rx667_pos)
    ge rx667_pos, rx667_eos, rxscan671_done
  rxscan671_scan:
    set_addr $I10, rxscan671_loop
    rx667_cur."!mark_push"(0, rx667_pos, $I10)
  rxscan671_done:
.annotate 'line', 332
    rx667_cur."!cursor_pos"(rx667_pos)
    get_hll_global $P672, ["PAST"], "Stmts"
    $P673 = $P672."new"()
    store_lex "$*PACKAGE-SETUP", $P673
.annotate 'line', 333
    rx667_cur."!cursor_pos"(rx667_pos)
    new $P674, "String"
    assign $P674, "native"
    store_lex "$*PKGDECL", $P674
.annotate 'line', 334
  # rx subcapture "sym"
    set_addr $I10, rxcap_675_fail
    rx667_cur."!mark_push"(0, rx667_pos, $I10)
  # rx literal  "native"
    add $I11, rx667_pos, 6
    gt $I11, rx667_eos, rx667_fail
    sub $I11, rx667_pos, rx667_off
    substr $S10, rx667_tgt, $I11, 6
    ne $S10, "native", rx667_fail
    add rx667_pos, 6
    set_addr $I10, rxcap_675_fail
    ($I12, $I11) = rx667_cur."!mark_peek"($I10)
    rx667_cur."!cursor_pos"($I11)
    ($P10) = rx667_cur."!cursor_start"()
    $P10."!cursor_pass"(rx667_pos, "")
    rx667_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_675_done
  rxcap_675_fail:
    goto rx667_fail
  rxcap_675_done:
  # rx subrule "package_def" subtype=capture negate=
    rx667_cur."!cursor_pos"(rx667_pos)
    $P10 = rx667_cur."package_def"()
    unless $P10, rx667_fail
    rx667_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx667_pos = $P10."pos"()
.annotate 'line', 331
  # rx pass
    rx667_cur."!cursor_pass"(rx667_pos, "package_declarator:sym<native>")
    if_null rx667_debug, debug_861
    rx667_cur."!cursor_debug"("PASS", "package_declarator:sym<native>", " at pos=", rx667_pos)
  debug_861:
    .return (rx667_cur)
  rx667_restart:
.annotate 'line', 10
    if_null rx667_debug, debug_862
    rx667_cur."!cursor_debug"("NEXT", "package_declarator:sym<native>")
  debug_862:
  rx667_fail:
    (rx667_rep, rx667_pos, $I10, $P10) = rx667_cur."!mark_fail"(0)
    lt rx667_pos, -1, rx667_done
    eq rx667_pos, -1, rx667_fail
    jump $I10
  rx667_done:
    rx667_cur."!cursor_fail"()
    if_null rx667_debug, debug_863
    rx667_cur."!cursor_debug"("FAIL", "package_declarator:sym<native>")
  debug_863:
    .return (rx667_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<native>"  :nsentry("!PREFIX__package_declarator:sym<native>") :subid("149_1302110486.758") :method
.annotate 'line', 10
    $P669 = self."!PREFIX__!subrule"("package_def", "native")
    new $P670, "ResizablePMCArray"
    push $P670, $P669
    .return ($P670)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_def"  :subid("150_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .const 'Sub' $P700 = "152_1302110486.758" 
    capture_lex $P700
.annotate 'line', 338
    new $P677, "Undef"
    .lex "$*PKGMETA", $P677
.annotate 'line', 339
    $P678 = root_new ['parrot';'Hash']
    .lex "%*ATTR-CHECK", $P678
.annotate 'line', 10
    .local string rx679_tgt
    .local int rx679_pos
    .local int rx679_off
    .local int rx679_eos
    .local int rx679_rep
    .local pmc rx679_cur
    .local pmc rx679_debug
    (rx679_cur, rx679_pos, rx679_tgt, $I10) = self."!cursor_start"()
    rx679_cur."!cursor_caparray"("repr", "parent", "role")
    .lex unicode:"$\x{a2}", rx679_cur
    .local pmc match
    .lex "$/", match
    length rx679_eos, rx679_tgt
    gt rx679_pos, rx679_eos, rx679_done
    set rx679_off, 0
    lt rx679_pos, 2, rx679_start
    sub rx679_off, rx679_pos, 1
    substr rx679_tgt, rx679_tgt, rx679_off
  rx679_start:
    eq $I10, 1, rx679_restart
    if_null rx679_debug, debug_864
    rx679_cur."!cursor_debug"("START", "package_def")
  debug_864:
    $I10 = self.'from'()
    ne $I10, -1, rxscan683_done
    goto rxscan683_scan
  rxscan683_loop:
    (rx679_pos) = rx679_cur."from"()
    inc rx679_pos
    rx679_cur."!cursor_from"(rx679_pos)
    ge rx679_pos, rx679_eos, rxscan683_done
  rxscan683_scan:
    set_addr $I10, rxscan683_loop
    rx679_cur."!mark_push"(0, rx679_pos, $I10)
  rxscan683_done:
.annotate 'line', 337
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
.annotate 'line', 338
    rx679_cur."!cursor_pos"(rx679_pos)
    find_lex $P685, "$*PKGMETA"
    unless_null $P685, vivify_865
    get_hll_global $P685, "$PKGMETA"
    unless_null $P685, vivify_866
    die "Contextual $*PKGMETA not found"
  vivify_866:
  vivify_865:
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
.annotate 'line', 339
    rx679_cur."!cursor_pos"(rx679_pos)
    find_lex $P687, "%*ATTR-CHECK"
    unless_null $P687, vivify_867
    get_hll_global $P687, "%ATTR-CHECK"
    unless_null $P687, vivify_868
    die "Contextual %*ATTR-CHECK not found"
  vivify_868:
  vivify_867:
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
.annotate 'line', 341
  # rx subrule "name" subtype=capture negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."name"()
    unless $P10, rx679_fail
    rx679_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx679_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
.annotate 'line', 342
  # rx rxquantr690 ** 0..1
    set_addr $I10, rxquantr690_done
    rx679_cur."!mark_push"(0, rx679_pos, $I10)
  rxquantr690_loop:
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx679_pos, 2
    gt $I11, rx679_eos, rx679_fail
    sub $I11, rx679_pos, rx679_off
    substr $S10, rx679_tgt, $I11, 2
    ne $S10, "is", rx679_fail
    add rx679_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
  # rx literal  "repr("
    add $I11, rx679_pos, 5
    gt $I11, rx679_eos, rx679_fail
    sub $I11, rx679_pos, rx679_off
    substr $S10, rx679_tgt, $I11, 5
    ne $S10, "repr(", rx679_fail
    add rx679_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."quote_EXPR"()
    unless $P10, rx679_fail
    rx679_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("repr")
    rx679_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx679_pos, 1
    gt $I11, rx679_eos, rx679_fail
    sub $I11, rx679_pos, rx679_off
    ord $I11, rx679_tgt, $I11
    ne $I11, 41, rx679_fail
    add rx679_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
    set_addr $I10, rxquantr690_done
    (rx679_rep) = rx679_cur."!mark_commit"($I10)
  rxquantr690_done:
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
.annotate 'line', 344
    rx679_cur."!cursor_pos"(rx679_pos)
    find_lex $P697, unicode:"$\x{a2}"
    $P698 = $P697."MATCH"()
    store_lex "$/", $P698
    .const 'Sub' $P700 = "152_1302110486.758" 
    capture_lex $P700
    $P726 = $P700()
.annotate 'line', 353
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
.annotate 'line', 355
  # rx rxquantr728 ** 0..1
    set_addr $I10, rxquantr728_done
    rx679_cur."!mark_push"(0, rx679_pos, $I10)
  rxquantr728_loop:
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx679_pos, 2
    gt $I11, rx679_eos, rx679_fail
    sub $I11, rx679_pos, rx679_off
    substr $S10, rx679_tgt, $I11, 2
    ne $S10, "is", rx679_fail
    add rx679_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."name"()
    unless $P10, rx679_fail
    rx679_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parent")
    rx679_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
    set_addr $I10, rxquantr728_done
    (rx679_rep) = rx679_cur."!mark_commit"($I10)
  rxquantr728_done:
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
.annotate 'line', 356
  # rx rxquantr733 ** 0..*
    set_addr $I10, rxquantr733_done
    rx679_cur."!mark_push"(0, rx679_pos, $I10)
  rxquantr733_loop:
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
  # rx literal  "does"
    add $I11, rx679_pos, 4
    gt $I11, rx679_eos, rx679_fail
    sub $I11, rx679_pos, rx679_off
    substr $S10, rx679_tgt, $I11, 4
    ne $S10, "does", rx679_fail
    add rx679_pos, 4
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."name"()
    unless $P10, rx679_fail
    rx679_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("role")
    rx679_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
    set_addr $I10, rxquantr733_done
    (rx679_rep) = rx679_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr733_done
    rx679_cur."!mark_push"(rx679_rep, rx679_pos, $I10)
    goto rxquantr733_loop
  rxquantr733_done:
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
  alt738_0:
.annotate 'line', 357
    set_addr $I10, alt738_1
    rx679_cur."!mark_push"(0, rx679_pos, $I10)
.annotate 'line', 358
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx679_pos, 1
    gt $I11, rx679_eos, rx679_fail
    sub $I11, rx679_pos, rx679_off
    ord $I11, rx679_tgt, $I11
    ne $I11, 59, rx679_fail
    add rx679_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
  # rx subrule "comp_unit" subtype=capture negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."comp_unit"()
    unless $P10, rx679_fail
    rx679_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("comp_unit")
    rx679_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
    goto alt738_end
  alt738_1:
    set_addr $I10, alt738_2
    rx679_cur."!mark_push"(0, rx679_pos, $I10)
.annotate 'line', 359
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx679_pos, rx679_off
    substr $S10, rx679_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx679_fail
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
  # rx subrule "block" subtype=capture negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."block"()
    unless $P10, rx679_fail
    rx679_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx679_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
    goto alt738_end
  alt738_2:
.annotate 'line', 360
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."panic"("Malformed package declaration")
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
  alt738_end:
.annotate 'line', 361
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
.annotate 'line', 337
  # rx pass
    rx679_cur."!cursor_pass"(rx679_pos, "package_def")
    if_null rx679_debug, debug_888
    rx679_cur."!cursor_debug"("PASS", "package_def", " at pos=", rx679_pos)
  debug_888:
    .return (rx679_cur)
  rx679_restart:
.annotate 'line', 10
    if_null rx679_debug, debug_889
    rx679_cur."!cursor_debug"("NEXT", "package_def")
  debug_889:
  rx679_fail:
    (rx679_rep, rx679_pos, $I10, $P10) = rx679_cur."!mark_fail"(0)
    lt rx679_pos, -1, rx679_done
    eq rx679_pos, -1, rx679_fail
    jump $I10
  rx679_done:
    rx679_cur."!cursor_fail"()
    if_null rx679_debug, debug_890
    rx679_cur."!cursor_debug"("FAIL", "package_def")
  debug_890:
    .return (rx679_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_def"  :nsentry("!PREFIX__package_def") :subid("151_1302110486.758") :method
.annotate 'line', 10
    $P681 = self."!PREFIX__!subrule"("ws", "")
    new $P682, "ResizablePMCArray"
    push $P682, $P681
    .return ($P682)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block699"  :anon :subid("152_1302110486.758") :outer("150_1302110486.758")
.annotate 'line', 347
    $P701 = root_new ['parrot';'Hash']
    .lex "%args", $P701
.annotate 'line', 344
    find_lex $P702, "%args"
.annotate 'line', 348
    find_lex $P703, "$/"
    unless_null $P703, vivify_869
    $P703 = root_new ['parrot';'Hash']
  vivify_869:
    set $P704, $P703["name"]
    unless_null $P704, vivify_870
    new $P704, "Undef"
  vivify_870:
    set $S705, $P704
    new $P706, 'String'
    set $P706, $S705
    find_lex $P707, "%args"
    unless_null $P707, vivify_871
    $P707 = root_new ['parrot';'Hash']
    store_lex "%args", $P707
  vivify_871:
    set $P707["name"], $P706
.annotate 'line', 349
    find_lex $P709, "$/"
    unless_null $P709, vivify_872
    $P709 = root_new ['parrot';'Hash']
  vivify_872:
    set $P710, $P709["repr"]
    unless_null $P710, vivify_873
    new $P710, "Undef"
  vivify_873:
    unless $P710, if_708_end
.annotate 'line', 350
    find_lex $P711, "$/"
    unless_null $P711, vivify_874
    $P711 = root_new ['parrot';'Hash']
  vivify_874:
    set $P712, $P711["repr"]
    unless_null $P712, vivify_875
    $P712 = root_new ['parrot';'ResizablePMCArray']
  vivify_875:
    set $P713, $P712[0]
    unless_null $P713, vivify_876
    $P713 = root_new ['parrot';'Hash']
  vivify_876:
    set $P714, $P713["quote_delimited"]
    unless_null $P714, vivify_877
    $P714 = root_new ['parrot';'Hash']
  vivify_877:
    set $P715, $P714["quote_atom"]
    unless_null $P715, vivify_878
    $P715 = root_new ['parrot';'ResizablePMCArray']
  vivify_878:
    set $P716, $P715[0]
    unless_null $P716, vivify_879
    new $P716, "Undef"
  vivify_879:
    set $S717, $P716
    new $P718, 'String'
    set $P718, $S717
    find_lex $P719, "%args"
    unless_null $P719, vivify_880
    $P719 = root_new ['parrot';'Hash']
    store_lex "%args", $P719
  vivify_880:
    set $P719["repr"], $P718
  if_708_end:
.annotate 'line', 352
    find_dynamic_lex $P720, "$*SC"
    unless_null $P720, vivify_881
    get_hll_global $P720, "$SC"
    unless_null $P720, vivify_882
    die "Contextual $*SC not found"
  vivify_882:
  vivify_881:
    find_dynamic_lex $P721, "$*PKGDECL"
    unless_null $P721, vivify_883
    get_hll_global $P721, "$PKGDECL"
    unless_null $P721, vivify_884
    die "Contextual $*PKGDECL not found"
  vivify_884:
  vivify_883:
    find_dynamic_lex $P722, "%*HOW"
    unless_null $P722, vivify_885
    get_hll_global $P722, "%HOW"
    unless_null $P722, vivify_886
    die "Contextual %*HOW not found"
  vivify_886:
  vivify_885:
    set $P723, $P722[$P721]
    unless_null $P723, vivify_887
    new $P723, "Undef"
  vivify_887:
    find_lex $P724, "%args"
    $P725 = $P720."pkg_create_mo"($P723, $P724 :flat)
    store_dynamic_lex "$*PKGMETA", $P725
.annotate 'line', 344
    .return ($P725)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator"  :subid("153_1302110486.758")
    .param pmc param_749
.annotate 'line', 364
    .lex "self", param_749
    $P750 = param_749."!protoregex"("scope_declarator")
    .return ($P750)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator"  :subid("154_1302110486.758")
    .param pmc param_752
.annotate 'line', 364
    .lex "self", param_752
    $P753 = param_752."!PREFIX__!protoregex"("scope_declarator")
    .return ($P753)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<my>"  :subid("155_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx755_tgt
    .local int rx755_pos
    .local int rx755_off
    .local int rx755_eos
    .local int rx755_rep
    .local pmc rx755_cur
    .local pmc rx755_debug
    (rx755_cur, rx755_pos, rx755_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx755_cur
    .local pmc match
    .lex "$/", match
    length rx755_eos, rx755_tgt
    gt rx755_pos, rx755_eos, rx755_done
    set rx755_off, 0
    lt rx755_pos, 2, rx755_start
    sub rx755_off, rx755_pos, 1
    substr rx755_tgt, rx755_tgt, rx755_off
  rx755_start:
    eq $I10, 1, rx755_restart
    if_null rx755_debug, debug_891
    rx755_cur."!cursor_debug"("START", "scope_declarator:sym<my>")
  debug_891:
    $I10 = self.'from'()
    ne $I10, -1, rxscan759_done
    goto rxscan759_scan
  rxscan759_loop:
    (rx755_pos) = rx755_cur."from"()
    inc rx755_pos
    rx755_cur."!cursor_from"(rx755_pos)
    ge rx755_pos, rx755_eos, rxscan759_done
  rxscan759_scan:
    set_addr $I10, rxscan759_loop
    rx755_cur."!mark_push"(0, rx755_pos, $I10)
  rxscan759_done:
.annotate 'line', 365
  # rx subcapture "sym"
    set_addr $I10, rxcap_760_fail
    rx755_cur."!mark_push"(0, rx755_pos, $I10)
  # rx literal  "my"
    add $I11, rx755_pos, 2
    gt $I11, rx755_eos, rx755_fail
    sub $I11, rx755_pos, rx755_off
    substr $S10, rx755_tgt, $I11, 2
    ne $S10, "my", rx755_fail
    add rx755_pos, 2
    set_addr $I10, rxcap_760_fail
    ($I12, $I11) = rx755_cur."!mark_peek"($I10)
    rx755_cur."!cursor_pos"($I11)
    ($P10) = rx755_cur."!cursor_start"()
    $P10."!cursor_pass"(rx755_pos, "")
    rx755_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_760_done
  rxcap_760_fail:
    goto rx755_fail
  rxcap_760_done:
  # rx subrule "scoped" subtype=capture negate=
    rx755_cur."!cursor_pos"(rx755_pos)
    $P10 = rx755_cur."scoped"("my")
    unless $P10, rx755_fail
    rx755_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx755_pos = $P10."pos"()
  # rx pass
    rx755_cur."!cursor_pass"(rx755_pos, "scope_declarator:sym<my>")
    if_null rx755_debug, debug_892
    rx755_cur."!cursor_debug"("PASS", "scope_declarator:sym<my>", " at pos=", rx755_pos)
  debug_892:
    .return (rx755_cur)
  rx755_restart:
.annotate 'line', 10
    if_null rx755_debug, debug_893
    rx755_cur."!cursor_debug"("NEXT", "scope_declarator:sym<my>")
  debug_893:
  rx755_fail:
    (rx755_rep, rx755_pos, $I10, $P10) = rx755_cur."!mark_fail"(0)
    lt rx755_pos, -1, rx755_done
    eq rx755_pos, -1, rx755_fail
    jump $I10
  rx755_done:
    rx755_cur."!cursor_fail"()
    if_null rx755_debug, debug_894
    rx755_cur."!cursor_debug"("FAIL", "scope_declarator:sym<my>")
  debug_894:
    .return (rx755_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<my>"  :nsentry("!PREFIX__scope_declarator:sym<my>") :subid("156_1302110486.758") :method
.annotate 'line', 10
    $P757 = self."!PREFIX__!subrule"("scoped", "my")
    new $P758, "ResizablePMCArray"
    push $P758, $P757
    .return ($P758)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<our>"  :subid("157_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx762_tgt
    .local int rx762_pos
    .local int rx762_off
    .local int rx762_eos
    .local int rx762_rep
    .local pmc rx762_cur
    .local pmc rx762_debug
    (rx762_cur, rx762_pos, rx762_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx762_cur
    .local pmc match
    .lex "$/", match
    length rx762_eos, rx762_tgt
    gt rx762_pos, rx762_eos, rx762_done
    set rx762_off, 0
    lt rx762_pos, 2, rx762_start
    sub rx762_off, rx762_pos, 1
    substr rx762_tgt, rx762_tgt, rx762_off
  rx762_start:
    eq $I10, 1, rx762_restart
    if_null rx762_debug, debug_895
    rx762_cur."!cursor_debug"("START", "scope_declarator:sym<our>")
  debug_895:
    $I10 = self.'from'()
    ne $I10, -1, rxscan766_done
    goto rxscan766_scan
  rxscan766_loop:
    (rx762_pos) = rx762_cur."from"()
    inc rx762_pos
    rx762_cur."!cursor_from"(rx762_pos)
    ge rx762_pos, rx762_eos, rxscan766_done
  rxscan766_scan:
    set_addr $I10, rxscan766_loop
    rx762_cur."!mark_push"(0, rx762_pos, $I10)
  rxscan766_done:
.annotate 'line', 366
  # rx subcapture "sym"
    set_addr $I10, rxcap_767_fail
    rx762_cur."!mark_push"(0, rx762_pos, $I10)
  # rx literal  "our"
    add $I11, rx762_pos, 3
    gt $I11, rx762_eos, rx762_fail
    sub $I11, rx762_pos, rx762_off
    substr $S10, rx762_tgt, $I11, 3
    ne $S10, "our", rx762_fail
    add rx762_pos, 3
    set_addr $I10, rxcap_767_fail
    ($I12, $I11) = rx762_cur."!mark_peek"($I10)
    rx762_cur."!cursor_pos"($I11)
    ($P10) = rx762_cur."!cursor_start"()
    $P10."!cursor_pass"(rx762_pos, "")
    rx762_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_767_done
  rxcap_767_fail:
    goto rx762_fail
  rxcap_767_done:
  # rx subrule "scoped" subtype=capture negate=
    rx762_cur."!cursor_pos"(rx762_pos)
    $P10 = rx762_cur."scoped"("our")
    unless $P10, rx762_fail
    rx762_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx762_pos = $P10."pos"()
  # rx pass
    rx762_cur."!cursor_pass"(rx762_pos, "scope_declarator:sym<our>")
    if_null rx762_debug, debug_896
    rx762_cur."!cursor_debug"("PASS", "scope_declarator:sym<our>", " at pos=", rx762_pos)
  debug_896:
    .return (rx762_cur)
  rx762_restart:
.annotate 'line', 10
    if_null rx762_debug, debug_897
    rx762_cur."!cursor_debug"("NEXT", "scope_declarator:sym<our>")
  debug_897:
  rx762_fail:
    (rx762_rep, rx762_pos, $I10, $P10) = rx762_cur."!mark_fail"(0)
    lt rx762_pos, -1, rx762_done
    eq rx762_pos, -1, rx762_fail
    jump $I10
  rx762_done:
    rx762_cur."!cursor_fail"()
    if_null rx762_debug, debug_898
    rx762_cur."!cursor_debug"("FAIL", "scope_declarator:sym<our>")
  debug_898:
    .return (rx762_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<our>"  :nsentry("!PREFIX__scope_declarator:sym<our>") :subid("158_1302110486.758") :method
.annotate 'line', 10
    $P764 = self."!PREFIX__!subrule"("scoped", "our")
    new $P765, "ResizablePMCArray"
    push $P765, $P764
    .return ($P765)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<has>"  :subid("159_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx769_tgt
    .local int rx769_pos
    .local int rx769_off
    .local int rx769_eos
    .local int rx769_rep
    .local pmc rx769_cur
    .local pmc rx769_debug
    (rx769_cur, rx769_pos, rx769_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx769_cur
    .local pmc match
    .lex "$/", match
    length rx769_eos, rx769_tgt
    gt rx769_pos, rx769_eos, rx769_done
    set rx769_off, 0
    lt rx769_pos, 2, rx769_start
    sub rx769_off, rx769_pos, 1
    substr rx769_tgt, rx769_tgt, rx769_off
  rx769_start:
    eq $I10, 1, rx769_restart
    if_null rx769_debug, debug_899
    rx769_cur."!cursor_debug"("START", "scope_declarator:sym<has>")
  debug_899:
    $I10 = self.'from'()
    ne $I10, -1, rxscan773_done
    goto rxscan773_scan
  rxscan773_loop:
    (rx769_pos) = rx769_cur."from"()
    inc rx769_pos
    rx769_cur."!cursor_from"(rx769_pos)
    ge rx769_pos, rx769_eos, rxscan773_done
  rxscan773_scan:
    set_addr $I10, rxscan773_loop
    rx769_cur."!mark_push"(0, rx769_pos, $I10)
  rxscan773_done:
.annotate 'line', 367
  # rx subcapture "sym"
    set_addr $I10, rxcap_774_fail
    rx769_cur."!mark_push"(0, rx769_pos, $I10)
  # rx literal  "has"
    add $I11, rx769_pos, 3
    gt $I11, rx769_eos, rx769_fail
    sub $I11, rx769_pos, rx769_off
    substr $S10, rx769_tgt, $I11, 3
    ne $S10, "has", rx769_fail
    add rx769_pos, 3
    set_addr $I10, rxcap_774_fail
    ($I12, $I11) = rx769_cur."!mark_peek"($I10)
    rx769_cur."!cursor_pos"($I11)
    ($P10) = rx769_cur."!cursor_start"()
    $P10."!cursor_pass"(rx769_pos, "")
    rx769_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_774_done
  rxcap_774_fail:
    goto rx769_fail
  rxcap_774_done:
  # rx subrule "scoped" subtype=capture negate=
    rx769_cur."!cursor_pos"(rx769_pos)
    $P10 = rx769_cur."scoped"("has")
    unless $P10, rx769_fail
    rx769_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx769_pos = $P10."pos"()
  # rx pass
    rx769_cur."!cursor_pass"(rx769_pos, "scope_declarator:sym<has>")
    if_null rx769_debug, debug_900
    rx769_cur."!cursor_debug"("PASS", "scope_declarator:sym<has>", " at pos=", rx769_pos)
  debug_900:
    .return (rx769_cur)
  rx769_restart:
.annotate 'line', 10
    if_null rx769_debug, debug_901
    rx769_cur."!cursor_debug"("NEXT", "scope_declarator:sym<has>")
  debug_901:
  rx769_fail:
    (rx769_rep, rx769_pos, $I10, $P10) = rx769_cur."!mark_fail"(0)
    lt rx769_pos, -1, rx769_done
    eq rx769_pos, -1, rx769_fail
    jump $I10
  rx769_done:
    rx769_cur."!cursor_fail"()
    if_null rx769_debug, debug_902
    rx769_cur."!cursor_debug"("FAIL", "scope_declarator:sym<has>")
  debug_902:
    .return (rx769_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<has>"  :nsentry("!PREFIX__scope_declarator:sym<has>") :subid("160_1302110486.758") :method
.annotate 'line', 10
    $P771 = self."!PREFIX__!subrule"("scoped", "has")
    new $P772, "ResizablePMCArray"
    push $P772, $P771
    .return ($P772)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scoped"  :subid("161_1302110486.758") :method :outer("12_1302110486.758")
    .param pmc param_776
.annotate 'line', 369
    .lex "$*SCOPE", param_776
.annotate 'line', 10
    .local string rx777_tgt
    .local int rx777_pos
    .local int rx777_off
    .local int rx777_eos
    .local int rx777_rep
    .local pmc rx777_cur
    .local pmc rx777_debug
    (rx777_cur, rx777_pos, rx777_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx777_cur
    .local pmc match
    .lex "$/", match
    length rx777_eos, rx777_tgt
    gt rx777_pos, rx777_eos, rx777_done
    set rx777_off, 0
    lt rx777_pos, 2, rx777_start
    sub rx777_off, rx777_pos, 1
    substr rx777_tgt, rx777_tgt, rx777_off
  rx777_start:
    eq $I10, 1, rx777_restart
    if_null rx777_debug, debug_903
    rx777_cur."!cursor_debug"("START", "scoped")
  debug_903:
    $I10 = self.'from'()
    ne $I10, -1, rxscan783_done
    goto rxscan783_scan
  rxscan783_loop:
    (rx777_pos) = rx777_cur."from"()
    inc rx777_pos
    rx777_cur."!cursor_from"(rx777_pos)
    ge rx777_pos, rx777_eos, rxscan783_done
  rxscan783_scan:
    set_addr $I10, rxscan783_loop
    rx777_cur."!mark_push"(0, rx777_pos, $I10)
  rxscan783_done:
  alt784_0:
.annotate 'line', 369
    set_addr $I10, alt784_1
    rx777_cur."!mark_push"(0, rx777_pos, $I10)
.annotate 'line', 370
  # rx subrule "ws" subtype=method negate=
    rx777_cur."!cursor_pos"(rx777_pos)
    $P10 = rx777_cur."ws"()
    unless $P10, rx777_fail
    rx777_pos = $P10."pos"()
  # rx subrule "declarator" subtype=capture negate=
    rx777_cur."!cursor_pos"(rx777_pos)
    $P10 = rx777_cur."declarator"()
    unless $P10, rx777_fail
    rx777_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx777_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx777_cur."!cursor_pos"(rx777_pos)
    $P10 = rx777_cur."ws"()
    unless $P10, rx777_fail
    rx777_pos = $P10."pos"()
    goto alt784_end
  alt784_1:
    set_addr $I10, alt784_2
    rx777_cur."!mark_push"(0, rx777_pos, $I10)
.annotate 'line', 371
  # rx subrule "ws" subtype=method negate=
    rx777_cur."!cursor_pos"(rx777_pos)
    $P10 = rx777_cur."ws"()
    unless $P10, rx777_fail
    rx777_pos = $P10."pos"()
  # rx subrule "multi_declarator" subtype=capture negate=
    rx777_cur."!cursor_pos"(rx777_pos)
    $P10 = rx777_cur."multi_declarator"()
    unless $P10, rx777_fail
    rx777_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx777_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx777_cur."!cursor_pos"(rx777_pos)
    $P10 = rx777_cur."ws"()
    unless $P10, rx777_fail
    rx777_pos = $P10."pos"()
    goto alt784_end
  alt784_2:
.annotate 'line', 372
  # rx subrule "ws" subtype=method negate=
    rx777_cur."!cursor_pos"(rx777_pos)
    $P10 = rx777_cur."ws"()
    unless $P10, rx777_fail
    rx777_pos = $P10."pos"()
  # rx subrule "package_declarator" subtype=capture negate=
    rx777_cur."!cursor_pos"(rx777_pos)
    $P10 = rx777_cur."package_declarator"()
    unless $P10, rx777_fail
    rx777_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx777_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx777_cur."!cursor_pos"(rx777_pos)
    $P10 = rx777_cur."ws"()
    unless $P10, rx777_fail
    rx777_pos = $P10."pos"()
  alt784_end:
.annotate 'line', 369
  # rx pass
    rx777_cur."!cursor_pass"(rx777_pos, "scoped")
    if_null rx777_debug, debug_904
    rx777_cur."!cursor_debug"("PASS", "scoped", " at pos=", rx777_pos)
  debug_904:
    .return (rx777_cur)
  rx777_restart:
.annotate 'line', 10
    if_null rx777_debug, debug_905
    rx777_cur."!cursor_debug"("NEXT", "scoped")
  debug_905:
  rx777_fail:
    (rx777_rep, rx777_pos, $I10, $P10) = rx777_cur."!mark_fail"(0)
    lt rx777_pos, -1, rx777_done
    eq rx777_pos, -1, rx777_fail
    jump $I10
  rx777_done:
    rx777_cur."!cursor_fail"()
    if_null rx777_debug, debug_906
    rx777_cur."!cursor_debug"("FAIL", "scoped")
  debug_906:
    .return (rx777_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scoped"  :nsentry("!PREFIX__scoped") :subid("162_1302110486.758") :method
.annotate 'line', 10
    $P779 = self."!PREFIX__!subrule"("ws", "")
    $P780 = self."!PREFIX__!subrule"("ws", "")
    $P781 = self."!PREFIX__!subrule"("ws", "")
    new $P782, "ResizablePMCArray"
    push $P782, $P779
    push $P782, $P780
    push $P782, $P781
    .return ($P782)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "typename"  :subid("163_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx792_tgt
    .local int rx792_pos
    .local int rx792_off
    .local int rx792_eos
    .local int rx792_rep
    .local pmc rx792_cur
    .local pmc rx792_debug
    (rx792_cur, rx792_pos, rx792_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx792_cur
    .local pmc match
    .lex "$/", match
    length rx792_eos, rx792_tgt
    gt rx792_pos, rx792_eos, rx792_done
    set rx792_off, 0
    lt rx792_pos, 2, rx792_start
    sub rx792_off, rx792_pos, 1
    substr rx792_tgt, rx792_tgt, rx792_off
  rx792_start:
    eq $I10, 1, rx792_restart
    if_null rx792_debug, debug_907
    rx792_cur."!cursor_debug"("START", "typename")
  debug_907:
    $I10 = self.'from'()
    ne $I10, -1, rxscan796_done
    goto rxscan796_scan
  rxscan796_loop:
    (rx792_pos) = rx792_cur."from"()
    inc rx792_pos
    rx792_cur."!cursor_from"(rx792_pos)
    ge rx792_pos, rx792_eos, rxscan796_done
  rxscan796_scan:
    set_addr $I10, rxscan796_loop
    rx792_cur."!mark_push"(0, rx792_pos, $I10)
  rxscan796_done:
.annotate 'line', 375
  # rx subrule "name" subtype=capture negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."name"()
    unless $P10, rx792_fail
    rx792_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx792_pos = $P10."pos"()
  # rx pass
    rx792_cur."!cursor_pass"(rx792_pos, "typename")
    if_null rx792_debug, debug_908
    rx792_cur."!cursor_debug"("PASS", "typename", " at pos=", rx792_pos)
  debug_908:
    .return (rx792_cur)
  rx792_restart:
.annotate 'line', 10
    if_null rx792_debug, debug_909
    rx792_cur."!cursor_debug"("NEXT", "typename")
  debug_909:
  rx792_fail:
    (rx792_rep, rx792_pos, $I10, $P10) = rx792_cur."!mark_fail"(0)
    lt rx792_pos, -1, rx792_done
    eq rx792_pos, -1, rx792_fail
    jump $I10
  rx792_done:
    rx792_cur."!cursor_fail"()
    if_null rx792_debug, debug_910
    rx792_cur."!cursor_debug"("FAIL", "typename")
  debug_910:
    .return (rx792_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__typename"  :nsentry("!PREFIX__typename") :subid("164_1302110486.758") :method
.annotate 'line', 10
    $P794 = self."!PREFIX__!subrule"("name", "")
    new $P795, "ResizablePMCArray"
    push $P795, $P794
    .return ($P795)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "declarator"  :subid("165_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx798_tgt
    .local int rx798_pos
    .local int rx798_off
    .local int rx798_eos
    .local int rx798_rep
    .local pmc rx798_cur
    .local pmc rx798_debug
    (rx798_cur, rx798_pos, rx798_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx798_cur
    .local pmc match
    .lex "$/", match
    length rx798_eos, rx798_tgt
    gt rx798_pos, rx798_eos, rx798_done
    set rx798_off, 0
    lt rx798_pos, 2, rx798_start
    sub rx798_off, rx798_pos, 1
    substr rx798_tgt, rx798_tgt, rx798_off
  rx798_start:
    eq $I10, 1, rx798_restart
    if_null rx798_debug, debug_911
    rx798_cur."!cursor_debug"("START", "declarator")
  debug_911:
    $I10 = self.'from'()
    ne $I10, -1, rxscan803_done
    goto rxscan803_scan
  rxscan803_loop:
    (rx798_pos) = rx798_cur."from"()
    inc rx798_pos
    rx798_cur."!cursor_from"(rx798_pos)
    ge rx798_pos, rx798_eos, rxscan803_done
  rxscan803_scan:
    set_addr $I10, rxscan803_loop
    rx798_cur."!mark_push"(0, rx798_pos, $I10)
  rxscan803_done:
  alt804_0:
.annotate 'line', 377
    set_addr $I10, alt804_1
    rx798_cur."!mark_push"(0, rx798_pos, $I10)
.annotate 'line', 378
  # rx subrule "variable_declarator" subtype=capture negate=
    rx798_cur."!cursor_pos"(rx798_pos)
    $P10 = rx798_cur."variable_declarator"()
    unless $P10, rx798_fail
    rx798_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable_declarator")
    rx798_pos = $P10."pos"()
    goto alt804_end
  alt804_1:
.annotate 'line', 379
  # rx subrule "routine_declarator" subtype=capture negate=
    rx798_cur."!cursor_pos"(rx798_pos)
    $P10 = rx798_cur."routine_declarator"()
    unless $P10, rx798_fail
    rx798_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx798_pos = $P10."pos"()
  alt804_end:
.annotate 'line', 377
  # rx pass
    rx798_cur."!cursor_pass"(rx798_pos, "declarator")
    if_null rx798_debug, debug_912
    rx798_cur."!cursor_debug"("PASS", "declarator", " at pos=", rx798_pos)
  debug_912:
    .return (rx798_cur)
  rx798_restart:
.annotate 'line', 10
    if_null rx798_debug, debug_913
    rx798_cur."!cursor_debug"("NEXT", "declarator")
  debug_913:
  rx798_fail:
    (rx798_rep, rx798_pos, $I10, $P10) = rx798_cur."!mark_fail"(0)
    lt rx798_pos, -1, rx798_done
    eq rx798_pos, -1, rx798_fail
    jump $I10
  rx798_done:
    rx798_cur."!cursor_fail"()
    if_null rx798_debug, debug_914
    rx798_cur."!cursor_debug"("FAIL", "declarator")
  debug_914:
    .return (rx798_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__declarator"  :nsentry("!PREFIX__declarator") :subid("166_1302110486.758") :method
.annotate 'line', 10
    $P800 = self."!PREFIX__!subrule"("routine_declarator", "")
    $P801 = self."!PREFIX__!subrule"("variable_declarator", "")
    new $P802, "ResizablePMCArray"
    push $P802, $P800
    push $P802, $P801
    .return ($P802)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable_declarator"  :subid("167_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx806_tgt
    .local int rx806_pos
    .local int rx806_off
    .local int rx806_eos
    .local int rx806_rep
    .local pmc rx806_cur
    .local pmc rx806_debug
    (rx806_cur, rx806_pos, rx806_tgt, $I10) = self."!cursor_start"()
    rx806_cur."!cursor_caparray"("typename")
    .lex unicode:"$\x{a2}", rx806_cur
    .local pmc match
    .lex "$/", match
    length rx806_eos, rx806_tgt
    gt rx806_pos, rx806_eos, rx806_done
    set rx806_off, 0
    lt rx806_pos, 2, rx806_start
    sub rx806_off, rx806_pos, 1
    substr rx806_tgt, rx806_tgt, rx806_off
  rx806_start:
    eq $I10, 1, rx806_restart
    if_null rx806_debug, debug_915
    rx806_cur."!cursor_debug"("START", "variable_declarator")
  debug_915:
    $I10 = self.'from'()
    ne $I10, -1, rxscan810_done
    goto rxscan810_scan
  rxscan810_loop:
    (rx806_pos) = rx806_cur."from"()
    inc rx806_pos
    rx806_cur."!cursor_from"(rx806_pos)
    ge rx806_pos, rx806_eos, rxscan810_done
  rxscan810_scan:
    set_addr $I10, rxscan810_loop
    rx806_cur."!mark_push"(0, rx806_pos, $I10)
  rxscan810_done:
.annotate 'line', 382
  # rx subrule "ws" subtype=method negate=
    rx806_cur."!cursor_pos"(rx806_pos)
    $P10 = rx806_cur."ws"()
    unless $P10, rx806_fail
    rx806_pos = $P10."pos"()
  # rx rxquantr812 ** 0..1
    set_addr $I10, rxquantr812_done
    rx806_cur."!mark_push"(0, rx806_pos, $I10)
  rxquantr812_loop:
  # rx subrule "typename" subtype=capture negate=
    rx806_cur."!cursor_pos"(rx806_pos)
    $P10 = rx806_cur."typename"()
    unless $P10, rx806_fail
    goto rxsubrule813_pass
  rxsubrule813_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx806_fail
  rxsubrule813_pass:
    set_addr $I10, rxsubrule813_back
    rx806_cur."!mark_push"(0, rx806_pos, $I10, $P10)
    $P10."!cursor_names"("typename")
    rx806_pos = $P10."pos"()
    set_addr $I10, rxquantr812_done
    (rx806_rep) = rx806_cur."!mark_commit"($I10)
  rxquantr812_done:
  # rx subrule "ws" subtype=method negate=
    rx806_cur."!cursor_pos"(rx806_pos)
    $P10 = rx806_cur."ws"()
    unless $P10, rx806_fail
    rx806_pos = $P10."pos"()
  # rx subrule "variable" subtype=capture negate=
    rx806_cur."!cursor_pos"(rx806_pos)
    $P10 = rx806_cur."variable"()
    unless $P10, rx806_fail
    rx806_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx806_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx806_cur."!cursor_pos"(rx806_pos)
    $P10 = rx806_cur."ws"()
    unless $P10, rx806_fail
    rx806_pos = $P10."pos"()
  # rx pass
    rx806_cur."!cursor_pass"(rx806_pos, "variable_declarator")
    if_null rx806_debug, debug_916
    rx806_cur."!cursor_debug"("PASS", "variable_declarator", " at pos=", rx806_pos)
  debug_916:
    .return (rx806_cur)
  rx806_restart:
.annotate 'line', 10
    if_null rx806_debug, debug_917
    rx806_cur."!cursor_debug"("NEXT", "variable_declarator")
  debug_917:
  rx806_fail:
    (rx806_rep, rx806_pos, $I10, $P10) = rx806_cur."!mark_fail"(0)
    lt rx806_pos, -1, rx806_done
    eq rx806_pos, -1, rx806_fail
    jump $I10
  rx806_done:
    rx806_cur."!cursor_fail"()
    if_null rx806_debug, debug_918
    rx806_cur."!cursor_debug"("FAIL", "variable_declarator")
  debug_918:
    .return (rx806_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable_declarator"  :nsentry("!PREFIX__variable_declarator") :subid("168_1302110486.758") :method
.annotate 'line', 10
    $P808 = self."!PREFIX__!subrule"("ws", "")
    new $P809, "ResizablePMCArray"
    push $P809, $P808
    .return ($P809)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator"  :subid("169_1302110486.758")
    .param pmc param_817
.annotate 'line', 384
    .lex "self", param_817
    $P818 = param_817."!protoregex"("routine_declarator")
    .return ($P818)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator"  :subid("170_1302110486.758")
    .param pmc param_820
.annotate 'line', 384
    .lex "self", param_820
    $P821 = param_820."!PREFIX__!protoregex"("routine_declarator")
    .return ($P821)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<sub>"  :subid("171_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx823_tgt
    .local int rx823_pos
    .local int rx823_off
    .local int rx823_eos
    .local int rx823_rep
    .local pmc rx823_cur
    .local pmc rx823_debug
    (rx823_cur, rx823_pos, rx823_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx823_cur
    .local pmc match
    .lex "$/", match
    length rx823_eos, rx823_tgt
    gt rx823_pos, rx823_eos, rx823_done
    set rx823_off, 0
    lt rx823_pos, 2, rx823_start
    sub rx823_off, rx823_pos, 1
    substr rx823_tgt, rx823_tgt, rx823_off
  rx823_start:
    eq $I10, 1, rx823_restart
    if_null rx823_debug, debug_919
    rx823_cur."!cursor_debug"("START", "routine_declarator:sym<sub>")
  debug_919:
    $I10 = self.'from'()
    ne $I10, -1, rxscan827_done
    goto rxscan827_scan
  rxscan827_loop:
    (rx823_pos) = rx823_cur."from"()
    inc rx823_pos
    rx823_cur."!cursor_from"(rx823_pos)
    ge rx823_pos, rx823_eos, rxscan827_done
  rxscan827_scan:
    set_addr $I10, rxscan827_loop
    rx823_cur."!mark_push"(0, rx823_pos, $I10)
  rxscan827_done:
.annotate 'line', 385
  # rx subcapture "sym"
    set_addr $I10, rxcap_828_fail
    rx823_cur."!mark_push"(0, rx823_pos, $I10)
  # rx literal  "sub"
    add $I11, rx823_pos, 3
    gt $I11, rx823_eos, rx823_fail
    sub $I11, rx823_pos, rx823_off
    substr $S10, rx823_tgt, $I11, 3
    ne $S10, "sub", rx823_fail
    add rx823_pos, 3
    set_addr $I10, rxcap_828_fail
    ($I12, $I11) = rx823_cur."!mark_peek"($I10)
    rx823_cur."!cursor_pos"($I11)
    ($P10) = rx823_cur."!cursor_start"()
    $P10."!cursor_pass"(rx823_pos, "")
    rx823_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_828_done
  rxcap_828_fail:
    goto rx823_fail
  rxcap_828_done:
  # rx subrule "routine_def" subtype=capture negate=
    rx823_cur."!cursor_pos"(rx823_pos)
    $P10 = rx823_cur."routine_def"()
    unless $P10, rx823_fail
    rx823_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx823_pos = $P10."pos"()
  # rx pass
    rx823_cur."!cursor_pass"(rx823_pos, "routine_declarator:sym<sub>")
    if_null rx823_debug, debug_920
    rx823_cur."!cursor_debug"("PASS", "routine_declarator:sym<sub>", " at pos=", rx823_pos)
  debug_920:
    .return (rx823_cur)
  rx823_restart:
.annotate 'line', 10
    if_null rx823_debug, debug_921
    rx823_cur."!cursor_debug"("NEXT", "routine_declarator:sym<sub>")
  debug_921:
  rx823_fail:
    (rx823_rep, rx823_pos, $I10, $P10) = rx823_cur."!mark_fail"(0)
    lt rx823_pos, -1, rx823_done
    eq rx823_pos, -1, rx823_fail
    jump $I10
  rx823_done:
    rx823_cur."!cursor_fail"()
    if_null rx823_debug, debug_922
    rx823_cur."!cursor_debug"("FAIL", "routine_declarator:sym<sub>")
  debug_922:
    .return (rx823_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<sub>"  :nsentry("!PREFIX__routine_declarator:sym<sub>") :subid("172_1302110486.758") :method
.annotate 'line', 10
    $P825 = self."!PREFIX__!subrule"("routine_def", "sub")
    new $P826, "ResizablePMCArray"
    push $P826, $P825
    .return ($P826)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<method>"  :subid("173_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx830_tgt
    .local int rx830_pos
    .local int rx830_off
    .local int rx830_eos
    .local int rx830_rep
    .local pmc rx830_cur
    .local pmc rx830_debug
    (rx830_cur, rx830_pos, rx830_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx830_cur
    .local pmc match
    .lex "$/", match
    length rx830_eos, rx830_tgt
    gt rx830_pos, rx830_eos, rx830_done
    set rx830_off, 0
    lt rx830_pos, 2, rx830_start
    sub rx830_off, rx830_pos, 1
    substr rx830_tgt, rx830_tgt, rx830_off
  rx830_start:
    eq $I10, 1, rx830_restart
    if_null rx830_debug, debug_923
    rx830_cur."!cursor_debug"("START", "routine_declarator:sym<method>")
  debug_923:
    $I10 = self.'from'()
    ne $I10, -1, rxscan834_done
    goto rxscan834_scan
  rxscan834_loop:
    (rx830_pos) = rx830_cur."from"()
    inc rx830_pos
    rx830_cur."!cursor_from"(rx830_pos)
    ge rx830_pos, rx830_eos, rxscan834_done
  rxscan834_scan:
    set_addr $I10, rxscan834_loop
    rx830_cur."!mark_push"(0, rx830_pos, $I10)
  rxscan834_done:
.annotate 'line', 386
  # rx subcapture "sym"
    set_addr $I10, rxcap_835_fail
    rx830_cur."!mark_push"(0, rx830_pos, $I10)
  # rx literal  "method"
    add $I11, rx830_pos, 6
    gt $I11, rx830_eos, rx830_fail
    sub $I11, rx830_pos, rx830_off
    substr $S10, rx830_tgt, $I11, 6
    ne $S10, "method", rx830_fail
    add rx830_pos, 6
    set_addr $I10, rxcap_835_fail
    ($I12, $I11) = rx830_cur."!mark_peek"($I10)
    rx830_cur."!cursor_pos"($I11)
    ($P10) = rx830_cur."!cursor_start"()
    $P10."!cursor_pass"(rx830_pos, "")
    rx830_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_835_done
  rxcap_835_fail:
    goto rx830_fail
  rxcap_835_done:
  # rx subrule "method_def" subtype=capture negate=
    rx830_cur."!cursor_pos"(rx830_pos)
    $P10 = rx830_cur."method_def"()
    unless $P10, rx830_fail
    rx830_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("method_def")
    rx830_pos = $P10."pos"()
  # rx pass
    rx830_cur."!cursor_pass"(rx830_pos, "routine_declarator:sym<method>")
    if_null rx830_debug, debug_924
    rx830_cur."!cursor_debug"("PASS", "routine_declarator:sym<method>", " at pos=", rx830_pos)
  debug_924:
    .return (rx830_cur)
  rx830_restart:
.annotate 'line', 10
    if_null rx830_debug, debug_925
    rx830_cur."!cursor_debug"("NEXT", "routine_declarator:sym<method>")
  debug_925:
  rx830_fail:
    (rx830_rep, rx830_pos, $I10, $P10) = rx830_cur."!mark_fail"(0)
    lt rx830_pos, -1, rx830_done
    eq rx830_pos, -1, rx830_fail
    jump $I10
  rx830_done:
    rx830_cur."!cursor_fail"()
    if_null rx830_debug, debug_926
    rx830_cur."!cursor_debug"("FAIL", "routine_declarator:sym<method>")
  debug_926:
    .return (rx830_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<method>"  :nsentry("!PREFIX__routine_declarator:sym<method>") :subid("174_1302110486.758") :method
.annotate 'line', 10
    $P832 = self."!PREFIX__!subrule"("method_def", "method")
    new $P833, "ResizablePMCArray"
    push $P833, $P832
    .return ($P833)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_def"  :subid("175_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 389
    new $P837, "Undef"
    .lex "$*RETURN_USED", $P837
.annotate 'line', 10
    .local string rx838_tgt
    .local int rx838_pos
    .local int rx838_off
    .local int rx838_eos
    .local int rx838_rep
    .local pmc rx838_cur
    .local pmc rx838_debug
    (rx838_cur, rx838_pos, rx838_tgt, $I10) = self."!cursor_start"()
    rx838_cur."!cursor_caparray"("sigil", "deflongname", "trait")
    .lex unicode:"$\x{a2}", rx838_cur
    .local pmc match
    .lex "$/", match
    length rx838_eos, rx838_tgt
    gt rx838_pos, rx838_eos, rx838_done
    set rx838_off, 0
    lt rx838_pos, 2, rx838_start
    sub rx838_off, rx838_pos, 1
    substr rx838_tgt, rx838_tgt, rx838_off
  rx838_start:
    eq $I10, 1, rx838_restart
    if_null rx838_debug, debug_927
    rx838_cur."!cursor_debug"("START", "routine_def")
  debug_927:
    $I10 = self.'from'()
    ne $I10, -1, rxscan842_done
    goto rxscan842_scan
  rxscan842_loop:
    (rx838_pos) = rx838_cur."from"()
    inc rx838_pos
    rx838_cur."!cursor_from"(rx838_pos)
    ge rx838_pos, rx838_eos, rxscan842_done
  rxscan842_scan:
    set_addr $I10, rxscan842_loop
    rx838_cur."!mark_push"(0, rx838_pos, $I10)
  rxscan842_done:
.annotate 'line', 388
  # rx subrule "ws" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."ws"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
.annotate 'line', 389
    rx838_cur."!cursor_pos"(rx838_pos)
    new $P844, "Integer"
    assign $P844, 0
    store_lex "$*RETURN_USED", $P844
  # rx subrule "ws" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."ws"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
.annotate 'line', 390
  # rx rxquantr846 ** 0..1
    set_addr $I10, rxquantr846_done
    rx838_cur."!mark_push"(0, rx838_pos, $I10)
  rxquantr846_loop:
  # rx subrule "ws" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."ws"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
  # rx subcapture "sigil"
    set_addr $I10, rxcap_849_fail
    rx838_cur."!mark_push"(0, rx838_pos, $I10)
  # rx rxquantr848 ** 0..1
    set_addr $I10, rxquantr848_done
    rx838_cur."!mark_push"(0, rx838_pos, $I10)
  rxquantr848_loop:
  # rx literal  "&"
    add $I11, rx838_pos, 1
    gt $I11, rx838_eos, rx838_fail
    sub $I11, rx838_pos, rx838_off
    ord $I11, rx838_tgt, $I11
    ne $I11, 38, rx838_fail
    add rx838_pos, 1
    set_addr $I10, rxquantr848_done
    (rx838_rep) = rx838_cur."!mark_commit"($I10)
  rxquantr848_done:
    set_addr $I10, rxcap_849_fail
    ($I12, $I11) = rx838_cur."!mark_peek"($I10)
    rx838_cur."!cursor_pos"($I11)
    ($P10) = rx838_cur."!cursor_start"()
    $P10."!cursor_pass"(rx838_pos, "")
    rx838_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_849_done
  rxcap_849_fail:
    goto rx838_fail
  rxcap_849_done:
  # rx subrule "deflongname" subtype=capture negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."deflongname"()
    unless $P10, rx838_fail
    rx838_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx838_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."ws"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
    set_addr $I10, rxquantr846_done
    (rx838_rep) = rx838_cur."!mark_commit"($I10)
  rxquantr846_done:
  # rx subrule "ws" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."ws"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
.annotate 'line', 391
  # rx subrule "newpad" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."newpad"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."ws"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
  alt853_0:
.annotate 'line', 392
    set_addr $I10, alt853_1
    rx838_cur."!mark_push"(0, rx838_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."ws"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx838_pos, 1
    gt $I11, rx838_eos, rx838_fail
    sub $I11, rx838_pos, rx838_off
    ord $I11, rx838_tgt, $I11
    ne $I11, 40, rx838_fail
    add rx838_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."ws"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."signature"()
    unless $P10, rx838_fail
    rx838_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx838_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."ws"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx838_pos, 1
    gt $I11, rx838_eos, rx838_fail
    sub $I11, rx838_pos, rx838_off
    ord $I11, rx838_tgt, $I11
    ne $I11, 41, rx838_fail
    add rx838_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."ws"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
    goto alt853_end
  alt853_1:
.annotate 'line', 393
  # rx subrule "ws" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."ws"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."ws"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
  alt853_end:
  # rx subrule "ws" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."ws"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
.annotate 'line', 394
  # rx rxquantr861 ** 0..*
    set_addr $I10, rxquantr861_done
    rx838_cur."!mark_push"(0, rx838_pos, $I10)
  rxquantr861_loop:
  # rx subrule "trait" subtype=capture negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."trait"()
    unless $P10, rx838_fail
    goto rxsubrule862_pass
  rxsubrule862_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx838_fail
  rxsubrule862_pass:
    set_addr $I10, rxsubrule862_back
    rx838_cur."!mark_push"(0, rx838_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx838_pos = $P10."pos"()
    set_addr $I10, rxquantr861_done
    (rx838_rep) = rx838_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr861_done
    rx838_cur."!mark_push"(rx838_rep, rx838_pos, $I10)
    goto rxquantr861_loop
  rxquantr861_done:
  # rx subrule "ws" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."ws"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
  alt864_0:
.annotate 'line', 395
    set_addr $I10, alt864_1
    rx838_cur."!mark_push"(0, rx838_pos, $I10)
.annotate 'line', 396
  # rx subrule "ws" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."ws"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."onlystar"()
    unless $P10, rx838_fail
    rx838_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx838_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."ws"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
    goto alt864_end
  alt864_1:
.annotate 'line', 397
  # rx subrule "ws" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."ws"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."blockoid"()
    unless $P10, rx838_fail
    rx838_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx838_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."ws"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
  alt864_end:
.annotate 'line', 398
  # rx subrule "ws" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."ws"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
.annotate 'line', 388
  # rx pass
    rx838_cur."!cursor_pass"(rx838_pos, "routine_def")
    if_null rx838_debug, debug_928
    rx838_cur."!cursor_debug"("PASS", "routine_def", " at pos=", rx838_pos)
  debug_928:
    .return (rx838_cur)
  rx838_restart:
.annotate 'line', 10
    if_null rx838_debug, debug_929
    rx838_cur."!cursor_debug"("NEXT", "routine_def")
  debug_929:
  rx838_fail:
    (rx838_rep, rx838_pos, $I10, $P10) = rx838_cur."!mark_fail"(0)
    lt rx838_pos, -1, rx838_done
    eq rx838_pos, -1, rx838_fail
    jump $I10
  rx838_done:
    rx838_cur."!cursor_fail"()
    if_null rx838_debug, debug_930
    rx838_cur."!cursor_debug"("FAIL", "routine_def")
  debug_930:
    .return (rx838_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_def"  :nsentry("!PREFIX__routine_def") :subid("176_1302110486.758") :method
.annotate 'line', 10
    $P840 = self."!PREFIX__!subrule"("ws", "")
    new $P841, "ResizablePMCArray"
    push $P841, $P840
    .return ($P841)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "method_def"  :subid("177_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .const 'Sub' $P901 = "179_1302110486.758" 
    capture_lex $P901
.annotate 'line', 402
    new $P871, "Undef"
    .lex "$*RETURN_USED", $P871
.annotate 'line', 403
    new $P872, "Undef"
    .lex "$*INVOCANT_OK", $P872
.annotate 'line', 10
    .local string rx873_tgt
    .local int rx873_pos
    .local int rx873_off
    .local int rx873_eos
    .local int rx873_rep
    .local pmc rx873_cur
    .local pmc rx873_debug
    (rx873_cur, rx873_pos, rx873_tgt, $I10) = self."!cursor_start"()
    rx873_cur."!cursor_caparray"("deflongname", "trait")
    .lex unicode:"$\x{a2}", rx873_cur
    .local pmc match
    .lex "$/", match
    length rx873_eos, rx873_tgt
    gt rx873_pos, rx873_eos, rx873_done
    set rx873_off, 0
    lt rx873_pos, 2, rx873_start
    sub rx873_off, rx873_pos, 1
    substr rx873_tgt, rx873_tgt, rx873_off
  rx873_start:
    eq $I10, 1, rx873_restart
    if_null rx873_debug, debug_931
    rx873_cur."!cursor_debug"("START", "method_def")
  debug_931:
    $I10 = self.'from'()
    ne $I10, -1, rxscan877_done
    goto rxscan877_scan
  rxscan877_loop:
    (rx873_pos) = rx873_cur."from"()
    inc rx873_pos
    rx873_cur."!cursor_from"(rx873_pos)
    ge rx873_pos, rx873_eos, rxscan877_done
  rxscan877_scan:
    set_addr $I10, rxscan877_loop
    rx873_cur."!mark_push"(0, rx873_pos, $I10)
  rxscan877_done:
.annotate 'line', 401
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
.annotate 'line', 402
    rx873_cur."!cursor_pos"(rx873_pos)
    new $P879, "Integer"
    assign $P879, 0
    store_lex "$*RETURN_USED", $P879
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
.annotate 'line', 403
    rx873_cur."!cursor_pos"(rx873_pos)
    new $P881, "Integer"
    assign $P881, 1
    store_lex "$*INVOCANT_OK", $P881
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
.annotate 'line', 404
  # rx subcapture "private"
    set_addr $I10, rxcap_884_fail
    rx873_cur."!mark_push"(0, rx873_pos, $I10)
  # rx rxquantr883 ** 0..1
    set_addr $I10, rxquantr883_done
    rx873_cur."!mark_push"(0, rx873_pos, $I10)
  rxquantr883_loop:
  # rx literal  "!"
    add $I11, rx873_pos, 1
    gt $I11, rx873_eos, rx873_fail
    sub $I11, rx873_pos, rx873_off
    ord $I11, rx873_tgt, $I11
    ne $I11, 33, rx873_fail
    add rx873_pos, 1
    set_addr $I10, rxquantr883_done
    (rx873_rep) = rx873_cur."!mark_commit"($I10)
  rxquantr883_done:
    set_addr $I10, rxcap_884_fail
    ($I12, $I11) = rx873_cur."!mark_peek"($I10)
    rx873_cur."!cursor_pos"($I11)
    ($P10) = rx873_cur."!cursor_start"()
    $P10."!cursor_pass"(rx873_pos, "")
    rx873_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("private")
    goto rxcap_884_done
  rxcap_884_fail:
    goto rx873_fail
  rxcap_884_done:
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
.annotate 'line', 405
  # rx rxquantr886 ** 0..1
    set_addr $I10, rxquantr886_done
    rx873_cur."!mark_push"(0, rx873_pos, $I10)
  rxquantr886_loop:
  # rx subrule "deflongname" subtype=capture negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."deflongname"()
    unless $P10, rx873_fail
    goto rxsubrule887_pass
  rxsubrule887_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx873_fail
  rxsubrule887_pass:
    set_addr $I10, rxsubrule887_back
    rx873_cur."!mark_push"(0, rx873_pos, $I10, $P10)
    $P10."!cursor_names"("deflongname")
    rx873_pos = $P10."pos"()
    set_addr $I10, rxquantr886_done
    (rx873_rep) = rx873_cur."!mark_commit"($I10)
  rxquantr886_done:
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
.annotate 'line', 406
  # rx subrule "newpad" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."newpad"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
  alt890_0:
.annotate 'line', 407
    set_addr $I10, alt890_1
    rx873_cur."!mark_push"(0, rx873_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx873_pos, 1
    gt $I11, rx873_eos, rx873_fail
    sub $I11, rx873_pos, rx873_off
    ord $I11, rx873_tgt, $I11
    ne $I11, 40, rx873_fail
    add rx873_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."signature"()
    unless $P10, rx873_fail
    rx873_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx873_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx873_pos, 1
    gt $I11, rx873_eos, rx873_fail
    sub $I11, rx873_pos, rx873_off
    ord $I11, rx873_tgt, $I11
    ne $I11, 41, rx873_fail
    add rx873_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
    goto alt890_end
  alt890_1:
.annotate 'line', 408
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
  alt890_end:
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
.annotate 'line', 409
    rx873_cur."!cursor_pos"(rx873_pos)
    find_lex $P898, unicode:"$\x{a2}"
    $P899 = $P898."MATCH"()
    store_lex "$/", $P899
    .const 'Sub' $P901 = "179_1302110486.758" 
    capture_lex $P901
    $P903 = $P901()
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
.annotate 'line', 410
  # rx rxquantr905 ** 0..*
    set_addr $I10, rxquantr905_done
    rx873_cur."!mark_push"(0, rx873_pos, $I10)
  rxquantr905_loop:
  # rx subrule "trait" subtype=capture negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."trait"()
    unless $P10, rx873_fail
    goto rxsubrule906_pass
  rxsubrule906_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx873_fail
  rxsubrule906_pass:
    set_addr $I10, rxsubrule906_back
    rx873_cur."!mark_push"(0, rx873_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx873_pos = $P10."pos"()
    set_addr $I10, rxquantr905_done
    (rx873_rep) = rx873_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr905_done
    rx873_cur."!mark_push"(rx873_rep, rx873_pos, $I10)
    goto rxquantr905_loop
  rxquantr905_done:
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
  alt908_0:
.annotate 'line', 411
    set_addr $I10, alt908_1
    rx873_cur."!mark_push"(0, rx873_pos, $I10)
.annotate 'line', 412
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."onlystar"()
    unless $P10, rx873_fail
    rx873_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx873_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
    goto alt908_end
  alt908_1:
.annotate 'line', 413
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."blockoid"()
    unless $P10, rx873_fail
    rx873_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx873_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
  alt908_end:
.annotate 'line', 414
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
.annotate 'line', 401
  # rx pass
    rx873_cur."!cursor_pass"(rx873_pos, "method_def")
    if_null rx873_debug, debug_932
    rx873_cur."!cursor_debug"("PASS", "method_def", " at pos=", rx873_pos)
  debug_932:
    .return (rx873_cur)
  rx873_restart:
.annotate 'line', 10
    if_null rx873_debug, debug_933
    rx873_cur."!cursor_debug"("NEXT", "method_def")
  debug_933:
  rx873_fail:
    (rx873_rep, rx873_pos, $I10, $P10) = rx873_cur."!mark_fail"(0)
    lt rx873_pos, -1, rx873_done
    eq rx873_pos, -1, rx873_fail
    jump $I10
  rx873_done:
    rx873_cur."!cursor_fail"()
    if_null rx873_debug, debug_934
    rx873_cur."!cursor_debug"("FAIL", "method_def")
  debug_934:
    .return (rx873_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__method_def"  :nsentry("!PREFIX__method_def") :subid("178_1302110486.758") :method
.annotate 'line', 10
    $P875 = self."!PREFIX__!subrule"("ws", "")
    new $P876, "ResizablePMCArray"
    push $P876, $P875
    .return ($P876)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block900"  :anon :subid("179_1302110486.758") :outer("177_1302110486.758")
.annotate 'line', 409
    new $P902, "Integer"
    assign $P902, 0
    store_dynamic_lex "$*INVOCANT_OK", $P902
    .return ($P902)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "onlystar"  :subid("180_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .const 'Sub' $P922 = "182_1302110486.758" 
    capture_lex $P922
    .local string rx915_tgt
    .local int rx915_pos
    .local int rx915_off
    .local int rx915_eos
    .local int rx915_rep
    .local pmc rx915_cur
    .local pmc rx915_debug
    (rx915_cur, rx915_pos, rx915_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx915_cur
    .local pmc match
    .lex "$/", match
    length rx915_eos, rx915_tgt
    gt rx915_pos, rx915_eos, rx915_done
    set rx915_off, 0
    lt rx915_pos, 2, rx915_start
    sub rx915_off, rx915_pos, 1
    substr rx915_tgt, rx915_tgt, rx915_off
  rx915_start:
    eq $I10, 1, rx915_restart
    if_null rx915_debug, debug_935
    rx915_cur."!cursor_debug"("START", "onlystar")
  debug_935:
    $I10 = self.'from'()
    ne $I10, -1, rxscan918_done
    goto rxscan918_scan
  rxscan918_loop:
    (rx915_pos) = rx915_cur."from"()
    inc rx915_pos
    rx915_cur."!cursor_from"(rx915_pos)
    ge rx915_pos, rx915_eos, rxscan918_done
  rxscan918_scan:
    set_addr $I10, rxscan918_loop
    rx915_cur."!mark_push"(0, rx915_pos, $I10)
  rxscan918_done:
.annotate 'line', 418
    rx915_cur."!cursor_pos"(rx915_pos)
    find_lex $P919, unicode:"$\x{a2}"
    $P920 = $P919."MATCH"()
    store_lex "$/", $P920
    .const 'Sub' $P922 = "182_1302110486.758" 
    capture_lex $P922
    $P926 = $P922()
    unless $P926, rx915_fail
.annotate 'line', 419
  # rx literal  "{"
    add $I11, rx915_pos, 1
    gt $I11, rx915_eos, rx915_fail
    sub $I11, rx915_pos, rx915_off
    ord $I11, rx915_tgt, $I11
    ne $I11, 123, rx915_fail
    add rx915_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx915_cur."!cursor_pos"(rx915_pos)
    $P10 = rx915_cur."ws"()
    unless $P10, rx915_fail
    rx915_pos = $P10."pos"()
  # rx literal  "*"
    add $I11, rx915_pos, 1
    gt $I11, rx915_eos, rx915_fail
    sub $I11, rx915_pos, rx915_off
    ord $I11, rx915_tgt, $I11
    ne $I11, 42, rx915_fail
    add rx915_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx915_cur."!cursor_pos"(rx915_pos)
    $P10 = rx915_cur."ws"()
    unless $P10, rx915_fail
    rx915_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx915_pos, 1
    gt $I11, rx915_eos, rx915_fail
    sub $I11, rx915_pos, rx915_off
    ord $I11, rx915_tgt, $I11
    ne $I11, 125, rx915_fail
    add rx915_pos, 1
.annotate 'line', 420
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx915_cur."!cursor_pos"(rx915_pos)
    $P10 = rx915_cur."ENDSTMT"()
    unless $P10, rx915_fail
.annotate 'line', 421
  # rx subrule "finishpad" subtype=method negate=
    rx915_cur."!cursor_pos"(rx915_pos)
    $P10 = rx915_cur."finishpad"()
    unless $P10, rx915_fail
    rx915_pos = $P10."pos"()
.annotate 'line', 417
  # rx pass
    rx915_cur."!cursor_pass"(rx915_pos, "onlystar")
    if_null rx915_debug, debug_938
    rx915_cur."!cursor_debug"("PASS", "onlystar", " at pos=", rx915_pos)
  debug_938:
    .return (rx915_cur)
  rx915_restart:
.annotate 'line', 10
    if_null rx915_debug, debug_939
    rx915_cur."!cursor_debug"("NEXT", "onlystar")
  debug_939:
  rx915_fail:
    (rx915_rep, rx915_pos, $I10, $P10) = rx915_cur."!mark_fail"(0)
    lt rx915_pos, -1, rx915_done
    eq rx915_pos, -1, rx915_fail
    jump $I10
  rx915_done:
    rx915_cur."!cursor_fail"()
    if_null rx915_debug, debug_940
    rx915_cur."!cursor_debug"("FAIL", "onlystar")
  debug_940:
    .return (rx915_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__onlystar"  :nsentry("!PREFIX__onlystar") :subid("181_1302110486.758") :method
.annotate 'line', 10
    new $P917, "ResizablePMCArray"
    push $P917, ""
    .return ($P917)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block921"  :anon :subid("182_1302110486.758") :outer("180_1302110486.758")
.annotate 'line', 418
    find_dynamic_lex $P923, "$*MULTINESS"
    unless_null $P923, vivify_936
    get_hll_global $P923, "$MULTINESS"
    unless_null $P923, vivify_937
    die "Contextual $*MULTINESS not found"
  vivify_937:
  vivify_936:
    set $S924, $P923
    iseq $I925, $S924, "proto"
    .return ($I925)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator"  :subid("183_1302110486.758")
    .param pmc param_928
.annotate 'line', 424
    .lex "self", param_928
    $P929 = param_928."!protoregex"("multi_declarator")
    .return ($P929)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator"  :subid("184_1302110486.758")
    .param pmc param_931
.annotate 'line', 424
    .lex "self", param_931
    $P932 = param_931."!PREFIX__!protoregex"("multi_declarator")
    .return ($P932)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<multi>"  :subid("185_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 426
    new $P934, "Undef"
    .lex "$*MULTINESS", $P934
.annotate 'line', 10
    .local string rx935_tgt
    .local int rx935_pos
    .local int rx935_off
    .local int rx935_eos
    .local int rx935_rep
    .local pmc rx935_cur
    .local pmc rx935_debug
    (rx935_cur, rx935_pos, rx935_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx935_cur
    .local pmc match
    .lex "$/", match
    length rx935_eos, rx935_tgt
    gt rx935_pos, rx935_eos, rx935_done
    set rx935_off, 0
    lt rx935_pos, 2, rx935_start
    sub rx935_off, rx935_pos, 1
    substr rx935_tgt, rx935_tgt, rx935_off
  rx935_start:
    eq $I10, 1, rx935_restart
    if_null rx935_debug, debug_941
    rx935_cur."!cursor_debug"("START", "multi_declarator:sym<multi>")
  debug_941:
    $I10 = self.'from'()
    ne $I10, -1, rxscan939_done
    goto rxscan939_scan
  rxscan939_loop:
    (rx935_pos) = rx935_cur."from"()
    inc rx935_pos
    rx935_cur."!cursor_from"(rx935_pos)
    ge rx935_pos, rx935_eos, rxscan939_done
  rxscan939_scan:
    set_addr $I10, rxscan939_loop
    rx935_cur."!mark_push"(0, rx935_pos, $I10)
  rxscan939_done:
.annotate 'line', 426
    rx935_cur."!cursor_pos"(rx935_pos)
    new $P940, "String"
    assign $P940, "multi"
    store_lex "$*MULTINESS", $P940
.annotate 'line', 427
  # rx subcapture "sym"
    set_addr $I10, rxcap_941_fail
    rx935_cur."!mark_push"(0, rx935_pos, $I10)
  # rx literal  "multi"
    add $I11, rx935_pos, 5
    gt $I11, rx935_eos, rx935_fail
    sub $I11, rx935_pos, rx935_off
    substr $S10, rx935_tgt, $I11, 5
    ne $S10, "multi", rx935_fail
    add rx935_pos, 5
    set_addr $I10, rxcap_941_fail
    ($I12, $I11) = rx935_cur."!mark_peek"($I10)
    rx935_cur."!cursor_pos"($I11)
    ($P10) = rx935_cur."!cursor_start"()
    $P10."!cursor_pass"(rx935_pos, "")
    rx935_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_941_done
  rxcap_941_fail:
    goto rx935_fail
  rxcap_941_done:
.annotate 'line', 428
  # rx subrule "ws" subtype=method negate=
    rx935_cur."!cursor_pos"(rx935_pos)
    $P10 = rx935_cur."ws"()
    unless $P10, rx935_fail
    rx935_pos = $P10."pos"()
  alt942_0:
    set_addr $I10, alt942_1
    rx935_cur."!mark_push"(0, rx935_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx935_cur."!cursor_pos"(rx935_pos)
    $P10 = rx935_cur."declarator"()
    unless $P10, rx935_fail
    rx935_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx935_pos = $P10."pos"()
    goto alt942_end
  alt942_1:
    set_addr $I10, alt942_2
    rx935_cur."!mark_push"(0, rx935_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx935_cur."!cursor_pos"(rx935_pos)
    $P10 = rx935_cur."routine_def"()
    unless $P10, rx935_fail
    rx935_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx935_pos = $P10."pos"()
    goto alt942_end
  alt942_2:
  # rx subrule "panic" subtype=method negate=
    rx935_cur."!cursor_pos"(rx935_pos)
    $P10 = rx935_cur."panic"("Malformed multi")
    unless $P10, rx935_fail
    rx935_pos = $P10."pos"()
  alt942_end:
.annotate 'line', 425
  # rx pass
    rx935_cur."!cursor_pass"(rx935_pos, "multi_declarator:sym<multi>")
    if_null rx935_debug, debug_942
    rx935_cur."!cursor_debug"("PASS", "multi_declarator:sym<multi>", " at pos=", rx935_pos)
  debug_942:
    .return (rx935_cur)
  rx935_restart:
.annotate 'line', 10
    if_null rx935_debug, debug_943
    rx935_cur."!cursor_debug"("NEXT", "multi_declarator:sym<multi>")
  debug_943:
  rx935_fail:
    (rx935_rep, rx935_pos, $I10, $P10) = rx935_cur."!mark_fail"(0)
    lt rx935_pos, -1, rx935_done
    eq rx935_pos, -1, rx935_fail
    jump $I10
  rx935_done:
    rx935_cur."!cursor_fail"()
    if_null rx935_debug, debug_944
    rx935_cur."!cursor_debug"("FAIL", "multi_declarator:sym<multi>")
  debug_944:
    .return (rx935_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<multi>"  :nsentry("!PREFIX__multi_declarator:sym<multi>") :subid("186_1302110486.758") :method
.annotate 'line', 10
    $P937 = self."!PREFIX__!subrule"("ws", "multi")
    new $P938, "ResizablePMCArray"
    push $P938, $P937
    .return ($P938)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<proto>"  :subid("187_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 431
    new $P944, "Undef"
    .lex "$*MULTINESS", $P944
.annotate 'line', 10
    .local string rx945_tgt
    .local int rx945_pos
    .local int rx945_off
    .local int rx945_eos
    .local int rx945_rep
    .local pmc rx945_cur
    .local pmc rx945_debug
    (rx945_cur, rx945_pos, rx945_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx945_cur
    .local pmc match
    .lex "$/", match
    length rx945_eos, rx945_tgt
    gt rx945_pos, rx945_eos, rx945_done
    set rx945_off, 0
    lt rx945_pos, 2, rx945_start
    sub rx945_off, rx945_pos, 1
    substr rx945_tgt, rx945_tgt, rx945_off
  rx945_start:
    eq $I10, 1, rx945_restart
    if_null rx945_debug, debug_945
    rx945_cur."!cursor_debug"("START", "multi_declarator:sym<proto>")
  debug_945:
    $I10 = self.'from'()
    ne $I10, -1, rxscan949_done
    goto rxscan949_scan
  rxscan949_loop:
    (rx945_pos) = rx945_cur."from"()
    inc rx945_pos
    rx945_cur."!cursor_from"(rx945_pos)
    ge rx945_pos, rx945_eos, rxscan949_done
  rxscan949_scan:
    set_addr $I10, rxscan949_loop
    rx945_cur."!mark_push"(0, rx945_pos, $I10)
  rxscan949_done:
.annotate 'line', 431
    rx945_cur."!cursor_pos"(rx945_pos)
    new $P950, "String"
    assign $P950, "proto"
    store_lex "$*MULTINESS", $P950
.annotate 'line', 432
  # rx subcapture "sym"
    set_addr $I10, rxcap_951_fail
    rx945_cur."!mark_push"(0, rx945_pos, $I10)
  # rx literal  "proto"
    add $I11, rx945_pos, 5
    gt $I11, rx945_eos, rx945_fail
    sub $I11, rx945_pos, rx945_off
    substr $S10, rx945_tgt, $I11, 5
    ne $S10, "proto", rx945_fail
    add rx945_pos, 5
    set_addr $I10, rxcap_951_fail
    ($I12, $I11) = rx945_cur."!mark_peek"($I10)
    rx945_cur."!cursor_pos"($I11)
    ($P10) = rx945_cur."!cursor_start"()
    $P10."!cursor_pass"(rx945_pos, "")
    rx945_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_951_done
  rxcap_951_fail:
    goto rx945_fail
  rxcap_951_done:
.annotate 'line', 433
  # rx subrule "ws" subtype=method negate=
    rx945_cur."!cursor_pos"(rx945_pos)
    $P10 = rx945_cur."ws"()
    unless $P10, rx945_fail
    rx945_pos = $P10."pos"()
  alt952_0:
    set_addr $I10, alt952_1
    rx945_cur."!mark_push"(0, rx945_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx945_cur."!cursor_pos"(rx945_pos)
    $P10 = rx945_cur."declarator"()
    unless $P10, rx945_fail
    rx945_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx945_pos = $P10."pos"()
    goto alt952_end
  alt952_1:
    set_addr $I10, alt952_2
    rx945_cur."!mark_push"(0, rx945_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx945_cur."!cursor_pos"(rx945_pos)
    $P10 = rx945_cur."routine_def"()
    unless $P10, rx945_fail
    rx945_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx945_pos = $P10."pos"()
    goto alt952_end
  alt952_2:
  # rx subrule "panic" subtype=method negate=
    rx945_cur."!cursor_pos"(rx945_pos)
    $P10 = rx945_cur."panic"("Malformed proto")
    unless $P10, rx945_fail
    rx945_pos = $P10."pos"()
  alt952_end:
.annotate 'line', 430
  # rx pass
    rx945_cur."!cursor_pass"(rx945_pos, "multi_declarator:sym<proto>")
    if_null rx945_debug, debug_946
    rx945_cur."!cursor_debug"("PASS", "multi_declarator:sym<proto>", " at pos=", rx945_pos)
  debug_946:
    .return (rx945_cur)
  rx945_restart:
.annotate 'line', 10
    if_null rx945_debug, debug_947
    rx945_cur."!cursor_debug"("NEXT", "multi_declarator:sym<proto>")
  debug_947:
  rx945_fail:
    (rx945_rep, rx945_pos, $I10, $P10) = rx945_cur."!mark_fail"(0)
    lt rx945_pos, -1, rx945_done
    eq rx945_pos, -1, rx945_fail
    jump $I10
  rx945_done:
    rx945_cur."!cursor_fail"()
    if_null rx945_debug, debug_948
    rx945_cur."!cursor_debug"("FAIL", "multi_declarator:sym<proto>")
  debug_948:
    .return (rx945_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<proto>"  :nsentry("!PREFIX__multi_declarator:sym<proto>") :subid("188_1302110486.758") :method
.annotate 'line', 10
    $P947 = self."!PREFIX__!subrule"("ws", "proto")
    new $P948, "ResizablePMCArray"
    push $P948, $P947
    .return ($P948)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<null>"  :subid("189_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 436
    new $P954, "Undef"
    .lex "$*MULTINESS", $P954
.annotate 'line', 10
    .local string rx955_tgt
    .local int rx955_pos
    .local int rx955_off
    .local int rx955_eos
    .local int rx955_rep
    .local pmc rx955_cur
    .local pmc rx955_debug
    (rx955_cur, rx955_pos, rx955_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx955_cur
    .local pmc match
    .lex "$/", match
    length rx955_eos, rx955_tgt
    gt rx955_pos, rx955_eos, rx955_done
    set rx955_off, 0
    lt rx955_pos, 2, rx955_start
    sub rx955_off, rx955_pos, 1
    substr rx955_tgt, rx955_tgt, rx955_off
  rx955_start:
    eq $I10, 1, rx955_restart
    if_null rx955_debug, debug_949
    rx955_cur."!cursor_debug"("START", "multi_declarator:sym<null>")
  debug_949:
    $I10 = self.'from'()
    ne $I10, -1, rxscan959_done
    goto rxscan959_scan
  rxscan959_loop:
    (rx955_pos) = rx955_cur."from"()
    inc rx955_pos
    rx955_cur."!cursor_from"(rx955_pos)
    ge rx955_pos, rx955_eos, rxscan959_done
  rxscan959_scan:
    set_addr $I10, rxscan959_loop
    rx955_cur."!mark_push"(0, rx955_pos, $I10)
  rxscan959_done:
.annotate 'line', 436
    rx955_cur."!cursor_pos"(rx955_pos)
    new $P960, "String"
    assign $P960, ""
    store_lex "$*MULTINESS", $P960
.annotate 'line', 437
  # rx subrule "declarator" subtype=capture negate=
    rx955_cur."!cursor_pos"(rx955_pos)
    $P10 = rx955_cur."declarator"()
    unless $P10, rx955_fail
    rx955_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx955_pos = $P10."pos"()
.annotate 'line', 435
  # rx pass
    rx955_cur."!cursor_pass"(rx955_pos, "multi_declarator:sym<null>")
    if_null rx955_debug, debug_950
    rx955_cur."!cursor_debug"("PASS", "multi_declarator:sym<null>", " at pos=", rx955_pos)
  debug_950:
    .return (rx955_cur)
  rx955_restart:
.annotate 'line', 10
    if_null rx955_debug, debug_951
    rx955_cur."!cursor_debug"("NEXT", "multi_declarator:sym<null>")
  debug_951:
  rx955_fail:
    (rx955_rep, rx955_pos, $I10, $P10) = rx955_cur."!mark_fail"(0)
    lt rx955_pos, -1, rx955_done
    eq rx955_pos, -1, rx955_fail
    jump $I10
  rx955_done:
    rx955_cur."!cursor_fail"()
    if_null rx955_debug, debug_952
    rx955_cur."!cursor_debug"("FAIL", "multi_declarator:sym<null>")
  debug_952:
    .return (rx955_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<null>"  :nsentry("!PREFIX__multi_declarator:sym<null>") :subid("190_1302110486.758") :method
.annotate 'line', 10
    $P957 = self."!PREFIX__!subrule"("declarator", "")
    new $P958, "ResizablePMCArray"
    push $P958, $P957
    .return ($P958)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "signature"  :subid("191_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .const 'Sub' $P970 = "193_1302110486.758" 
    capture_lex $P970
    .local string rx962_tgt
    .local int rx962_pos
    .local int rx962_off
    .local int rx962_eos
    .local int rx962_rep
    .local pmc rx962_cur
    .local pmc rx962_debug
    (rx962_cur, rx962_pos, rx962_tgt, $I10) = self."!cursor_start"()
    rx962_cur."!cursor_caparray"("invocant", "parameter")
    .lex unicode:"$\x{a2}", rx962_cur
    .local pmc match
    .lex "$/", match
    length rx962_eos, rx962_tgt
    gt rx962_pos, rx962_eos, rx962_done
    set rx962_off, 0
    lt rx962_pos, 2, rx962_start
    sub rx962_off, rx962_pos, 1
    substr rx962_tgt, rx962_tgt, rx962_off
  rx962_start:
    eq $I10, 1, rx962_restart
    if_null rx962_debug, debug_953
    rx962_cur."!cursor_debug"("START", "signature")
  debug_953:
    $I10 = self.'from'()
    ne $I10, -1, rxscan965_done
    goto rxscan965_scan
  rxscan965_loop:
    (rx962_pos) = rx962_cur."from"()
    inc rx962_pos
    rx962_cur."!cursor_from"(rx962_pos)
    ge rx962_pos, rx962_eos, rxscan965_done
  rxscan965_scan:
    set_addr $I10, rxscan965_loop
    rx962_cur."!mark_push"(0, rx962_pos, $I10)
  rxscan965_done:
.annotate 'line', 441
  # rx rxquantr966 ** 0..1
    set_addr $I10, rxquantr966_done
    rx962_cur."!mark_push"(0, rx962_pos, $I10)
  rxquantr966_loop:
    rx962_cur."!cursor_pos"(rx962_pos)
    find_lex $P967, unicode:"$\x{a2}"
    $P968 = $P967."MATCH"()
    store_lex "$/", $P968
    .const 'Sub' $P970 = "193_1302110486.758" 
    capture_lex $P970
    $P972 = $P970()
    unless $P972, rx962_fail
  # rx subrule "ws" subtype=method negate=
    rx962_cur."!cursor_pos"(rx962_pos)
    $P10 = rx962_cur."ws"()
    unless $P10, rx962_fail
    rx962_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx962_cur."!cursor_pos"(rx962_pos)
    $P10 = rx962_cur."parameter"()
    unless $P10, rx962_fail
    rx962_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("invocant")
    rx962_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx962_cur."!cursor_pos"(rx962_pos)
    $P10 = rx962_cur."ws"()
    unless $P10, rx962_fail
    rx962_pos = $P10."pos"()
  # rx literal  ":"
    add $I11, rx962_pos, 1
    gt $I11, rx962_eos, rx962_fail
    sub $I11, rx962_pos, rx962_off
    ord $I11, rx962_tgt, $I11
    ne $I11, 58, rx962_fail
    add rx962_pos, 1
    set_addr $I10, rxquantr966_done
    (rx962_rep) = rx962_cur."!mark_commit"($I10)
  rxquantr966_done:
.annotate 'line', 442
  # rx rxquantr973 ** 0..1
    set_addr $I10, rxquantr973_done
    rx962_cur."!mark_push"(0, rx962_pos, $I10)
  rxquantr973_loop:
  # rx rxquantr974 ** 1..*
    set_addr $I10, rxquantr974_done
    rx962_cur."!mark_push"(0, -1, $I10)
  rxquantr974_loop:
  # rx subrule "ws" subtype=method negate=
    rx962_cur."!cursor_pos"(rx962_pos)
    $P10 = rx962_cur."ws"()
    unless $P10, rx962_fail
    rx962_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx962_cur."!cursor_pos"(rx962_pos)
    $P10 = rx962_cur."parameter"()
    unless $P10, rx962_fail
    rx962_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parameter")
    rx962_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx962_cur."!cursor_pos"(rx962_pos)
    $P10 = rx962_cur."ws"()
    unless $P10, rx962_fail
    rx962_pos = $P10."pos"()
    set_addr $I10, rxquantr974_done
    (rx962_rep) = rx962_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr974_done
    rx962_cur."!mark_push"(rx962_rep, rx962_pos, $I10)
  # rx literal  ","
    add $I11, rx962_pos, 1
    gt $I11, rx962_eos, rx962_fail
    sub $I11, rx962_pos, rx962_off
    ord $I11, rx962_tgt, $I11
    ne $I11, 44, rx962_fail
    add rx962_pos, 1
    goto rxquantr974_loop
  rxquantr974_done:
    set_addr $I10, rxquantr973_done
    (rx962_rep) = rx962_cur."!mark_commit"($I10)
  rxquantr973_done:
.annotate 'line', 440
  # rx pass
    rx962_cur."!cursor_pass"(rx962_pos, "signature")
    if_null rx962_debug, debug_956
    rx962_cur."!cursor_debug"("PASS", "signature", " at pos=", rx962_pos)
  debug_956:
    .return (rx962_cur)
  rx962_restart:
.annotate 'line', 10
    if_null rx962_debug, debug_957
    rx962_cur."!cursor_debug"("NEXT", "signature")
  debug_957:
  rx962_fail:
    (rx962_rep, rx962_pos, $I10, $P10) = rx962_cur."!mark_fail"(0)
    lt rx962_pos, -1, rx962_done
    eq rx962_pos, -1, rx962_fail
    jump $I10
  rx962_done:
    rx962_cur."!cursor_fail"()
    if_null rx962_debug, debug_958
    rx962_cur."!cursor_debug"("FAIL", "signature")
  debug_958:
    .return (rx962_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__signature"  :nsentry("!PREFIX__signature") :subid("192_1302110486.758") :method
.annotate 'line', 10
    new $P964, "ResizablePMCArray"
    push $P964, ""
    .return ($P964)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block969"  :anon :subid("193_1302110486.758") :outer("191_1302110486.758")
.annotate 'line', 441
    find_dynamic_lex $P971, "$*INVOCANT_OK"
    unless_null $P971, vivify_954
    get_hll_global $P971, "$INVOCANT_OK"
    unless_null $P971, vivify_955
    die "Contextual $*INVOCANT_OK not found"
  vivify_955:
  vivify_954:
    .return ($P971)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "parameter"  :subid("194_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx976_tgt
    .local int rx976_pos
    .local int rx976_off
    .local int rx976_eos
    .local int rx976_rep
    .local pmc rx976_cur
    .local pmc rx976_debug
    (rx976_cur, rx976_pos, rx976_tgt, $I10) = self."!cursor_start"()
    rx976_cur."!cursor_caparray"("typename", "definedness", "default_value")
    .lex unicode:"$\x{a2}", rx976_cur
    .local pmc match
    .lex "$/", match
    length rx976_eos, rx976_tgt
    gt rx976_pos, rx976_eos, rx976_done
    set rx976_off, 0
    lt rx976_pos, 2, rx976_start
    sub rx976_off, rx976_pos, 1
    substr rx976_tgt, rx976_tgt, rx976_off
  rx976_start:
    eq $I10, 1, rx976_restart
    if_null rx976_debug, debug_959
    rx976_cur."!cursor_debug"("START", "parameter")
  debug_959:
    $I10 = self.'from'()
    ne $I10, -1, rxscan979_done
    goto rxscan979_scan
  rxscan979_loop:
    (rx976_pos) = rx976_cur."from"()
    inc rx976_pos
    rx976_cur."!cursor_from"(rx976_pos)
    ge rx976_pos, rx976_eos, rxscan979_done
  rxscan979_scan:
    set_addr $I10, rxscan979_loop
    rx976_cur."!mark_push"(0, rx976_pos, $I10)
  rxscan979_done:
.annotate 'line', 446
  # rx rxquantr980 ** 0..*
    set_addr $I10, rxquantr980_done
    rx976_cur."!mark_push"(0, rx976_pos, $I10)
  rxquantr980_loop:
  # rx subrule "typename" subtype=capture negate=
    rx976_cur."!cursor_pos"(rx976_pos)
    $P10 = rx976_cur."typename"()
    unless $P10, rx976_fail
    rx976_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("typename")
    rx976_pos = $P10."pos"()
  # rx rxquantr981 ** 0..1
    set_addr $I10, rxquantr981_done
    rx976_cur."!mark_push"(0, rx976_pos, $I10)
  rxquantr981_loop:
  # rx literal  ":"
    add $I11, rx976_pos, 1
    gt $I11, rx976_eos, rx976_fail
    sub $I11, rx976_pos, rx976_off
    ord $I11, rx976_tgt, $I11
    ne $I11, 58, rx976_fail
    add rx976_pos, 1
  # rx subcapture "definedness"
    set_addr $I10, rxcap_982_fail
    rx976_cur."!mark_push"(0, rx976_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx976_pos, rx976_eos, rx976_fail
    sub $I10, rx976_pos, rx976_off
    substr $S10, rx976_tgt, $I10, 1
    index $I11, "_DU", $S10
    lt $I11, 0, rx976_fail
    inc rx976_pos
    set_addr $I10, rxcap_982_fail
    ($I12, $I11) = rx976_cur."!mark_peek"($I10)
    rx976_cur."!cursor_pos"($I11)
    ($P10) = rx976_cur."!cursor_start"()
    $P10."!cursor_pass"(rx976_pos, "")
    rx976_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("definedness")
    goto rxcap_982_done
  rxcap_982_fail:
    goto rx976_fail
  rxcap_982_done:
    set_addr $I10, rxquantr981_done
    (rx976_rep) = rx976_cur."!mark_commit"($I10)
  rxquantr981_done:
  # rx subrule "ws" subtype=method negate=
    rx976_cur."!cursor_pos"(rx976_pos)
    $P10 = rx976_cur."ws"()
    unless $P10, rx976_fail
    rx976_pos = $P10."pos"()
    set_addr $I10, rxquantr980_done
    (rx976_rep) = rx976_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr980_done
    rx976_cur."!mark_push"(rx976_rep, rx976_pos, $I10)
    goto rxquantr980_loop
  rxquantr980_done:
  alt983_0:
.annotate 'line', 447
    set_addr $I10, alt983_1
    rx976_cur."!mark_push"(0, rx976_pos, $I10)
.annotate 'line', 448
  # rx subcapture "quant"
    set_addr $I10, rxcap_984_fail
    rx976_cur."!mark_push"(0, rx976_pos, $I10)
  # rx literal  "*"
    add $I11, rx976_pos, 1
    gt $I11, rx976_eos, rx976_fail
    sub $I11, rx976_pos, rx976_off
    ord $I11, rx976_tgt, $I11
    ne $I11, 42, rx976_fail
    add rx976_pos, 1
    set_addr $I10, rxcap_984_fail
    ($I12, $I11) = rx976_cur."!mark_peek"($I10)
    rx976_cur."!cursor_pos"($I11)
    ($P10) = rx976_cur."!cursor_start"()
    $P10."!cursor_pass"(rx976_pos, "")
    rx976_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_984_done
  rxcap_984_fail:
    goto rx976_fail
  rxcap_984_done:
  # rx subrule "param_var" subtype=capture negate=
    rx976_cur."!cursor_pos"(rx976_pos)
    $P10 = rx976_cur."param_var"()
    unless $P10, rx976_fail
    rx976_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx976_pos = $P10."pos"()
    goto alt983_end
  alt983_1:
  alt985_0:
.annotate 'line', 449
    set_addr $I10, alt985_1
    rx976_cur."!mark_push"(0, rx976_pos, $I10)
  # rx subrule "param_var" subtype=capture negate=
    rx976_cur."!cursor_pos"(rx976_pos)
    $P10 = rx976_cur."param_var"()
    unless $P10, rx976_fail
    rx976_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx976_pos = $P10."pos"()
    goto alt985_end
  alt985_1:
  # rx subrule "named_param" subtype=capture negate=
    rx976_cur."!cursor_pos"(rx976_pos)
    $P10 = rx976_cur."named_param"()
    unless $P10, rx976_fail
    rx976_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("named_param")
    rx976_pos = $P10."pos"()
  alt985_end:
  # rx subcapture "quant"
    set_addr $I10, rxcap_987_fail
    rx976_cur."!mark_push"(0, rx976_pos, $I10)
  alt986_0:
    set_addr $I10, alt986_1
    rx976_cur."!mark_push"(0, rx976_pos, $I10)
  # rx literal  "?"
    add $I11, rx976_pos, 1
    gt $I11, rx976_eos, rx976_fail
    sub $I11, rx976_pos, rx976_off
    ord $I11, rx976_tgt, $I11
    ne $I11, 63, rx976_fail
    add rx976_pos, 1
    goto alt986_end
  alt986_1:
    set_addr $I10, alt986_2
    rx976_cur."!mark_push"(0, rx976_pos, $I10)
  # rx literal  "!"
    add $I11, rx976_pos, 1
    gt $I11, rx976_eos, rx976_fail
    sub $I11, rx976_pos, rx976_off
    ord $I11, rx976_tgt, $I11
    ne $I11, 33, rx976_fail
    add rx976_pos, 1
    goto alt986_end
  alt986_2:
  alt986_end:
    set_addr $I10, rxcap_987_fail
    ($I12, $I11) = rx976_cur."!mark_peek"($I10)
    rx976_cur."!cursor_pos"($I11)
    ($P10) = rx976_cur."!cursor_start"()
    $P10."!cursor_pass"(rx976_pos, "")
    rx976_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_987_done
  rxcap_987_fail:
    goto rx976_fail
  rxcap_987_done:
  alt983_end:
.annotate 'line', 451
  # rx rxquantr988 ** 0..1
    set_addr $I10, rxquantr988_done
    rx976_cur."!mark_push"(0, rx976_pos, $I10)
  rxquantr988_loop:
  # rx subrule "default_value" subtype=capture negate=
    rx976_cur."!cursor_pos"(rx976_pos)
    $P10 = rx976_cur."default_value"()
    unless $P10, rx976_fail
    goto rxsubrule989_pass
  rxsubrule989_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx976_fail
  rxsubrule989_pass:
    set_addr $I10, rxsubrule989_back
    rx976_cur."!mark_push"(0, rx976_pos, $I10, $P10)
    $P10."!cursor_names"("default_value")
    rx976_pos = $P10."pos"()
    set_addr $I10, rxquantr988_done
    (rx976_rep) = rx976_cur."!mark_commit"($I10)
  rxquantr988_done:
.annotate 'line', 445
  # rx pass
    rx976_cur."!cursor_pass"(rx976_pos, "parameter")
    if_null rx976_debug, debug_960
    rx976_cur."!cursor_debug"("PASS", "parameter", " at pos=", rx976_pos)
  debug_960:
    .return (rx976_cur)
  rx976_restart:
.annotate 'line', 10
    if_null rx976_debug, debug_961
    rx976_cur."!cursor_debug"("NEXT", "parameter")
  debug_961:
  rx976_fail:
    (rx976_rep, rx976_pos, $I10, $P10) = rx976_cur."!mark_fail"(0)
    lt rx976_pos, -1, rx976_done
    eq rx976_pos, -1, rx976_fail
    jump $I10
  rx976_done:
    rx976_cur."!cursor_fail"()
    if_null rx976_debug, debug_962
    rx976_cur."!cursor_debug"("FAIL", "parameter")
  debug_962:
    .return (rx976_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__parameter"  :nsentry("!PREFIX__parameter") :subid("195_1302110486.758") :method
.annotate 'line', 10
    new $P978, "ResizablePMCArray"
    push $P978, ""
    .return ($P978)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "param_var"  :subid("196_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx991_tgt
    .local int rx991_pos
    .local int rx991_off
    .local int rx991_eos
    .local int rx991_rep
    .local pmc rx991_cur
    .local pmc rx991_debug
    (rx991_cur, rx991_pos, rx991_tgt, $I10) = self."!cursor_start"()
    rx991_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx991_cur
    .local pmc match
    .lex "$/", match
    length rx991_eos, rx991_tgt
    gt rx991_pos, rx991_eos, rx991_done
    set rx991_off, 0
    lt rx991_pos, 2, rx991_start
    sub rx991_off, rx991_pos, 1
    substr rx991_tgt, rx991_tgt, rx991_off
  rx991_start:
    eq $I10, 1, rx991_restart
    if_null rx991_debug, debug_963
    rx991_cur."!cursor_debug"("START", "param_var")
  debug_963:
    $I10 = self.'from'()
    ne $I10, -1, rxscan995_done
    goto rxscan995_scan
  rxscan995_loop:
    (rx991_pos) = rx991_cur."from"()
    inc rx991_pos
    rx991_cur."!cursor_from"(rx991_pos)
    ge rx991_pos, rx991_eos, rxscan995_done
  rxscan995_scan:
    set_addr $I10, rxscan995_loop
    rx991_cur."!mark_push"(0, rx991_pos, $I10)
  rxscan995_done:
.annotate 'line', 455
  # rx subrule "sigil" subtype=capture negate=
    rx991_cur."!cursor_pos"(rx991_pos)
    $P10 = rx991_cur."sigil"()
    unless $P10, rx991_fail
    rx991_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx991_pos = $P10."pos"()
  # rx rxquantr996 ** 0..1
    set_addr $I10, rxquantr996_done
    rx991_cur."!mark_push"(0, rx991_pos, $I10)
  rxquantr996_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx991_cur."!cursor_pos"(rx991_pos)
    $P10 = rx991_cur."twigil"()
    unless $P10, rx991_fail
    goto rxsubrule997_pass
  rxsubrule997_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx991_fail
  rxsubrule997_pass:
    set_addr $I10, rxsubrule997_back
    rx991_cur."!mark_push"(0, rx991_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx991_pos = $P10."pos"()
    set_addr $I10, rxquantr996_done
    (rx991_rep) = rx991_cur."!mark_commit"($I10)
  rxquantr996_done:
  alt998_0:
.annotate 'line', 456
    set_addr $I10, alt998_1
    rx991_cur."!mark_push"(0, rx991_pos, $I10)
  # rx subrule "ident" subtype=capture negate=
    rx991_cur."!cursor_pos"(rx991_pos)
    $P10 = rx991_cur."ident"()
    unless $P10, rx991_fail
    rx991_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx991_pos = $P10."pos"()
    goto alt998_end
  alt998_1:
  # rx subcapture "name"
    set_addr $I10, rxcap_999_fail
    rx991_cur."!mark_push"(0, rx991_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx991_pos, rx991_eos, rx991_fail
    sub $I10, rx991_pos, rx991_off
    substr $S10, rx991_tgt, $I10, 1
    index $I11, "/!", $S10
    lt $I11, 0, rx991_fail
    inc rx991_pos
    set_addr $I10, rxcap_999_fail
    ($I12, $I11) = rx991_cur."!mark_peek"($I10)
    rx991_cur."!cursor_pos"($I11)
    ($P10) = rx991_cur."!cursor_start"()
    $P10."!cursor_pass"(rx991_pos, "")
    rx991_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    goto rxcap_999_done
  rxcap_999_fail:
    goto rx991_fail
  rxcap_999_done:
  alt998_end:
.annotate 'line', 454
  # rx pass
    rx991_cur."!cursor_pass"(rx991_pos, "param_var")
    if_null rx991_debug, debug_964
    rx991_cur."!cursor_debug"("PASS", "param_var", " at pos=", rx991_pos)
  debug_964:
    .return (rx991_cur)
  rx991_restart:
.annotate 'line', 10
    if_null rx991_debug, debug_965
    rx991_cur."!cursor_debug"("NEXT", "param_var")
  debug_965:
  rx991_fail:
    (rx991_rep, rx991_pos, $I10, $P10) = rx991_cur."!mark_fail"(0)
    lt rx991_pos, -1, rx991_done
    eq rx991_pos, -1, rx991_fail
    jump $I10
  rx991_done:
    rx991_cur."!cursor_fail"()
    if_null rx991_debug, debug_966
    rx991_cur."!cursor_debug"("FAIL", "param_var")
  debug_966:
    .return (rx991_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__param_var"  :nsentry("!PREFIX__param_var") :subid("197_1302110486.758") :method
.annotate 'line', 10
    $P993 = self."!PREFIX__!subrule"("sigil", "")
    new $P994, "ResizablePMCArray"
    push $P994, $P993
    .return ($P994)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "named_param"  :subid("198_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1001_tgt
    .local int rx1001_pos
    .local int rx1001_off
    .local int rx1001_eos
    .local int rx1001_rep
    .local pmc rx1001_cur
    .local pmc rx1001_debug
    (rx1001_cur, rx1001_pos, rx1001_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1001_cur
    .local pmc match
    .lex "$/", match
    length rx1001_eos, rx1001_tgt
    gt rx1001_pos, rx1001_eos, rx1001_done
    set rx1001_off, 0
    lt rx1001_pos, 2, rx1001_start
    sub rx1001_off, rx1001_pos, 1
    substr rx1001_tgt, rx1001_tgt, rx1001_off
  rx1001_start:
    eq $I10, 1, rx1001_restart
    if_null rx1001_debug, debug_967
    rx1001_cur."!cursor_debug"("START", "named_param")
  debug_967:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1005_done
    goto rxscan1005_scan
  rxscan1005_loop:
    (rx1001_pos) = rx1001_cur."from"()
    inc rx1001_pos
    rx1001_cur."!cursor_from"(rx1001_pos)
    ge rx1001_pos, rx1001_eos, rxscan1005_done
  rxscan1005_scan:
    set_addr $I10, rxscan1005_loop
    rx1001_cur."!mark_push"(0, rx1001_pos, $I10)
  rxscan1005_done:
.annotate 'line', 460
  # rx literal  ":"
    add $I11, rx1001_pos, 1
    gt $I11, rx1001_eos, rx1001_fail
    sub $I11, rx1001_pos, rx1001_off
    ord $I11, rx1001_tgt, $I11
    ne $I11, 58, rx1001_fail
    add rx1001_pos, 1
  # rx subrule "param_var" subtype=capture negate=
    rx1001_cur."!cursor_pos"(rx1001_pos)
    $P10 = rx1001_cur."param_var"()
    unless $P10, rx1001_fail
    rx1001_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx1001_pos = $P10."pos"()
.annotate 'line', 459
  # rx pass
    rx1001_cur."!cursor_pass"(rx1001_pos, "named_param")
    if_null rx1001_debug, debug_968
    rx1001_cur."!cursor_debug"("PASS", "named_param", " at pos=", rx1001_pos)
  debug_968:
    .return (rx1001_cur)
  rx1001_restart:
.annotate 'line', 10
    if_null rx1001_debug, debug_969
    rx1001_cur."!cursor_debug"("NEXT", "named_param")
  debug_969:
  rx1001_fail:
    (rx1001_rep, rx1001_pos, $I10, $P10) = rx1001_cur."!mark_fail"(0)
    lt rx1001_pos, -1, rx1001_done
    eq rx1001_pos, -1, rx1001_fail
    jump $I10
  rx1001_done:
    rx1001_cur."!cursor_fail"()
    if_null rx1001_debug, debug_970
    rx1001_cur."!cursor_debug"("FAIL", "named_param")
  debug_970:
    .return (rx1001_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__named_param"  :nsentry("!PREFIX__named_param") :subid("199_1302110486.758") :method
.annotate 'line', 10
    $P1003 = self."!PREFIX__!subrule"("param_var", ":")
    new $P1004, "ResizablePMCArray"
    push $P1004, $P1003
    .return ($P1004)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "default_value"  :subid("200_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1007_tgt
    .local int rx1007_pos
    .local int rx1007_off
    .local int rx1007_eos
    .local int rx1007_rep
    .local pmc rx1007_cur
    .local pmc rx1007_debug
    (rx1007_cur, rx1007_pos, rx1007_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1007_cur
    .local pmc match
    .lex "$/", match
    length rx1007_eos, rx1007_tgt
    gt rx1007_pos, rx1007_eos, rx1007_done
    set rx1007_off, 0
    lt rx1007_pos, 2, rx1007_start
    sub rx1007_off, rx1007_pos, 1
    substr rx1007_tgt, rx1007_tgt, rx1007_off
  rx1007_start:
    eq $I10, 1, rx1007_restart
    if_null rx1007_debug, debug_971
    rx1007_cur."!cursor_debug"("START", "default_value")
  debug_971:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1011_done
    goto rxscan1011_scan
  rxscan1011_loop:
    (rx1007_pos) = rx1007_cur."from"()
    inc rx1007_pos
    rx1007_cur."!cursor_from"(rx1007_pos)
    ge rx1007_pos, rx1007_eos, rxscan1011_done
  rxscan1011_scan:
    set_addr $I10, rxscan1011_loop
    rx1007_cur."!mark_push"(0, rx1007_pos, $I10)
  rxscan1011_done:
.annotate 'line', 463
  # rx subrule "ws" subtype=method negate=
    rx1007_cur."!cursor_pos"(rx1007_pos)
    $P10 = rx1007_cur."ws"()
    unless $P10, rx1007_fail
    rx1007_pos = $P10."pos"()
  # rx literal  "="
    add $I11, rx1007_pos, 1
    gt $I11, rx1007_eos, rx1007_fail
    sub $I11, rx1007_pos, rx1007_off
    ord $I11, rx1007_tgt, $I11
    ne $I11, 61, rx1007_fail
    add rx1007_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1007_cur."!cursor_pos"(rx1007_pos)
    $P10 = rx1007_cur."ws"()
    unless $P10, rx1007_fail
    rx1007_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1007_cur."!cursor_pos"(rx1007_pos)
    $P10 = rx1007_cur."EXPR"("i=")
    unless $P10, rx1007_fail
    rx1007_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1007_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1007_cur."!cursor_pos"(rx1007_pos)
    $P10 = rx1007_cur."ws"()
    unless $P10, rx1007_fail
    rx1007_pos = $P10."pos"()
  # rx pass
    rx1007_cur."!cursor_pass"(rx1007_pos, "default_value")
    if_null rx1007_debug, debug_972
    rx1007_cur."!cursor_debug"("PASS", "default_value", " at pos=", rx1007_pos)
  debug_972:
    .return (rx1007_cur)
  rx1007_restart:
.annotate 'line', 10
    if_null rx1007_debug, debug_973
    rx1007_cur."!cursor_debug"("NEXT", "default_value")
  debug_973:
  rx1007_fail:
    (rx1007_rep, rx1007_pos, $I10, $P10) = rx1007_cur."!mark_fail"(0)
    lt rx1007_pos, -1, rx1007_done
    eq rx1007_pos, -1, rx1007_fail
    jump $I10
  rx1007_done:
    rx1007_cur."!cursor_fail"()
    if_null rx1007_debug, debug_974
    rx1007_cur."!cursor_debug"("FAIL", "default_value")
  debug_974:
    .return (rx1007_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__default_value"  :nsentry("!PREFIX__default_value") :subid("201_1302110486.758") :method
.annotate 'line', 10
    $P1009 = self."!PREFIX__!subrule"("ws", "")
    new $P1010, "ResizablePMCArray"
    push $P1010, $P1009
    .return ($P1010)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait"  :subid("202_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1016_tgt
    .local int rx1016_pos
    .local int rx1016_off
    .local int rx1016_eos
    .local int rx1016_rep
    .local pmc rx1016_cur
    .local pmc rx1016_debug
    (rx1016_cur, rx1016_pos, rx1016_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1016_cur
    .local pmc match
    .lex "$/", match
    length rx1016_eos, rx1016_tgt
    gt rx1016_pos, rx1016_eos, rx1016_done
    set rx1016_off, 0
    lt rx1016_pos, 2, rx1016_start
    sub rx1016_off, rx1016_pos, 1
    substr rx1016_tgt, rx1016_tgt, rx1016_off
  rx1016_start:
    eq $I10, 1, rx1016_restart
    if_null rx1016_debug, debug_975
    rx1016_cur."!cursor_debug"("START", "trait")
  debug_975:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1020_done
    goto rxscan1020_scan
  rxscan1020_loop:
    (rx1016_pos) = rx1016_cur."from"()
    inc rx1016_pos
    rx1016_cur."!cursor_from"(rx1016_pos)
    ge rx1016_pos, rx1016_eos, rxscan1020_done
  rxscan1020_scan:
    set_addr $I10, rxscan1020_loop
    rx1016_cur."!mark_push"(0, rx1016_pos, $I10)
  rxscan1020_done:
.annotate 'line', 465
  # rx subrule "ws" subtype=method negate=
    rx1016_cur."!cursor_pos"(rx1016_pos)
    $P10 = rx1016_cur."ws"()
    unless $P10, rx1016_fail
    rx1016_pos = $P10."pos"()
  # rx subrule "trait_mod" subtype=capture negate=
    rx1016_cur."!cursor_pos"(rx1016_pos)
    $P10 = rx1016_cur."trait_mod"()
    unless $P10, rx1016_fail
    rx1016_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("trait_mod")
    rx1016_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1016_cur."!cursor_pos"(rx1016_pos)
    $P10 = rx1016_cur."ws"()
    unless $P10, rx1016_fail
    rx1016_pos = $P10."pos"()
  # rx pass
    rx1016_cur."!cursor_pass"(rx1016_pos, "trait")
    if_null rx1016_debug, debug_976
    rx1016_cur."!cursor_debug"("PASS", "trait", " at pos=", rx1016_pos)
  debug_976:
    .return (rx1016_cur)
  rx1016_restart:
.annotate 'line', 10
    if_null rx1016_debug, debug_977
    rx1016_cur."!cursor_debug"("NEXT", "trait")
  debug_977:
  rx1016_fail:
    (rx1016_rep, rx1016_pos, $I10, $P10) = rx1016_cur."!mark_fail"(0)
    lt rx1016_pos, -1, rx1016_done
    eq rx1016_pos, -1, rx1016_fail
    jump $I10
  rx1016_done:
    rx1016_cur."!cursor_fail"()
    if_null rx1016_debug, debug_978
    rx1016_cur."!cursor_debug"("FAIL", "trait")
  debug_978:
    .return (rx1016_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait"  :nsentry("!PREFIX__trait") :subid("203_1302110486.758") :method
.annotate 'line', 10
    $P1018 = self."!PREFIX__!subrule"("ws", "")
    new $P1019, "ResizablePMCArray"
    push $P1019, $P1018
    .return ($P1019)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod"  :subid("204_1302110486.758")
    .param pmc param_1024
.annotate 'line', 467
    .lex "self", param_1024
    $P1025 = param_1024."!protoregex"("trait_mod")
    .return ($P1025)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod"  :subid("205_1302110486.758")
    .param pmc param_1027
.annotate 'line', 467
    .lex "self", param_1027
    $P1028 = param_1027."!PREFIX__!protoregex"("trait_mod")
    .return ($P1028)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod:sym<is>"  :subid("206_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1030_tgt
    .local int rx1030_pos
    .local int rx1030_off
    .local int rx1030_eos
    .local int rx1030_rep
    .local pmc rx1030_cur
    .local pmc rx1030_debug
    (rx1030_cur, rx1030_pos, rx1030_tgt, $I10) = self."!cursor_start"()
    rx1030_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx1030_cur
    .local pmc match
    .lex "$/", match
    length rx1030_eos, rx1030_tgt
    gt rx1030_pos, rx1030_eos, rx1030_done
    set rx1030_off, 0
    lt rx1030_pos, 2, rx1030_start
    sub rx1030_off, rx1030_pos, 1
    substr rx1030_tgt, rx1030_tgt, rx1030_off
  rx1030_start:
    eq $I10, 1, rx1030_restart
    if_null rx1030_debug, debug_979
    rx1030_cur."!cursor_debug"("START", "trait_mod:sym<is>")
  debug_979:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1034_done
    goto rxscan1034_scan
  rxscan1034_loop:
    (rx1030_pos) = rx1030_cur."from"()
    inc rx1030_pos
    rx1030_cur."!cursor_from"(rx1030_pos)
    ge rx1030_pos, rx1030_eos, rxscan1034_done
  rxscan1034_scan:
    set_addr $I10, rxscan1034_loop
    rx1030_cur."!mark_push"(0, rx1030_pos, $I10)
  rxscan1034_done:
.annotate 'line', 468
  # rx subcapture "sym"
    set_addr $I10, rxcap_1035_fail
    rx1030_cur."!mark_push"(0, rx1030_pos, $I10)
  # rx literal  "is"
    add $I11, rx1030_pos, 2
    gt $I11, rx1030_eos, rx1030_fail
    sub $I11, rx1030_pos, rx1030_off
    substr $S10, rx1030_tgt, $I11, 2
    ne $S10, "is", rx1030_fail
    add rx1030_pos, 2
    set_addr $I10, rxcap_1035_fail
    ($I12, $I11) = rx1030_cur."!mark_peek"($I10)
    rx1030_cur."!cursor_pos"($I11)
    ($P10) = rx1030_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1030_pos, "")
    rx1030_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1035_done
  rxcap_1035_fail:
    goto rx1030_fail
  rxcap_1035_done:
  # rx subrule "ws" subtype=method negate=
    rx1030_cur."!cursor_pos"(rx1030_pos)
    $P10 = rx1030_cur."ws"()
    unless $P10, rx1030_fail
    rx1030_pos = $P10."pos"()
  # rx subrule "deflongname" subtype=capture negate=
    rx1030_cur."!cursor_pos"(rx1030_pos)
    $P10 = rx1030_cur."deflongname"()
    unless $P10, rx1030_fail
    rx1030_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx1030_pos = $P10."pos"()
  # rx rxquantr1037 ** 0..1
    set_addr $I10, rxquantr1037_done
    rx1030_cur."!mark_push"(0, rx1030_pos, $I10)
  rxquantr1037_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx1030_cur."!cursor_pos"(rx1030_pos)
    $P10 = rx1030_cur."circumfix"()
    unless $P10, rx1030_fail
    goto rxsubrule1038_pass
  rxsubrule1038_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1030_fail
  rxsubrule1038_pass:
    set_addr $I10, rxsubrule1038_back
    rx1030_cur."!mark_push"(0, rx1030_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx1030_pos = $P10."pos"()
    set_addr $I10, rxquantr1037_done
    (rx1030_rep) = rx1030_cur."!mark_commit"($I10)
  rxquantr1037_done:
  # rx subrule "ws" subtype=method negate=
    rx1030_cur."!cursor_pos"(rx1030_pos)
    $P10 = rx1030_cur."ws"()
    unless $P10, rx1030_fail
    rx1030_pos = $P10."pos"()
  # rx pass
    rx1030_cur."!cursor_pass"(rx1030_pos, "trait_mod:sym<is>")
    if_null rx1030_debug, debug_980
    rx1030_cur."!cursor_debug"("PASS", "trait_mod:sym<is>", " at pos=", rx1030_pos)
  debug_980:
    .return (rx1030_cur)
  rx1030_restart:
.annotate 'line', 10
    if_null rx1030_debug, debug_981
    rx1030_cur."!cursor_debug"("NEXT", "trait_mod:sym<is>")
  debug_981:
  rx1030_fail:
    (rx1030_rep, rx1030_pos, $I10, $P10) = rx1030_cur."!mark_fail"(0)
    lt rx1030_pos, -1, rx1030_done
    eq rx1030_pos, -1, rx1030_fail
    jump $I10
  rx1030_done:
    rx1030_cur."!cursor_fail"()
    if_null rx1030_debug, debug_982
    rx1030_cur."!cursor_debug"("FAIL", "trait_mod:sym<is>")
  debug_982:
    .return (rx1030_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod:sym<is>"  :nsentry("!PREFIX__trait_mod:sym<is>") :subid("207_1302110486.758") :method
.annotate 'line', 10
    $P1032 = self."!PREFIX__!subrule"("ws", "is")
    new $P1033, "ResizablePMCArray"
    push $P1033, $P1032
    .return ($P1033)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "regex_declarator"  :subid("208_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1041_tgt
    .local int rx1041_pos
    .local int rx1041_off
    .local int rx1041_eos
    .local int rx1041_rep
    .local pmc rx1041_cur
    .local pmc rx1041_debug
    (rx1041_cur, rx1041_pos, rx1041_tgt, $I10) = self."!cursor_start"()
    rx1041_cur."!cursor_caparray"("signature")
    .lex unicode:"$\x{a2}", rx1041_cur
    .local pmc match
    .lex "$/", match
    length rx1041_eos, rx1041_tgt
    gt rx1041_pos, rx1041_eos, rx1041_done
    set rx1041_off, 0
    lt rx1041_pos, 2, rx1041_start
    sub rx1041_off, rx1041_pos, 1
    substr rx1041_tgt, rx1041_tgt, rx1041_off
  rx1041_start:
    eq $I10, 1, rx1041_restart
    if_null rx1041_debug, debug_983
    rx1041_cur."!cursor_debug"("START", "regex_declarator")
  debug_983:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1045_done
    goto rxscan1045_scan
  rxscan1045_loop:
    (rx1041_pos) = rx1041_cur."from"()
    inc rx1041_pos
    rx1041_cur."!cursor_from"(rx1041_pos)
    ge rx1041_pos, rx1041_eos, rxscan1045_done
  rxscan1045_scan:
    set_addr $I10, rxscan1045_loop
    rx1041_cur."!mark_push"(0, rx1041_pos, $I10)
  rxscan1045_done:
.annotate 'line', 470
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
  alt1047_0:
.annotate 'line', 471
    set_addr $I10, alt1047_1
    rx1041_cur."!mark_push"(0, rx1041_pos, $I10)
.annotate 'line', 472
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
  # rx subcapture "proto"
    set_addr $I10, rxcap_1049_fail
    rx1041_cur."!mark_push"(0, rx1041_pos, $I10)
  # rx literal  "proto"
    add $I11, rx1041_pos, 5
    gt $I11, rx1041_eos, rx1041_fail
    sub $I11, rx1041_pos, rx1041_off
    substr $S10, rx1041_tgt, $I11, 5
    ne $S10, "proto", rx1041_fail
    add rx1041_pos, 5
    set_addr $I10, rxcap_1049_fail
    ($I12, $I11) = rx1041_cur."!mark_peek"($I10)
    rx1041_cur."!cursor_pos"($I11)
    ($P10) = rx1041_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1041_pos, "")
    rx1041_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("proto")
    goto rxcap_1049_done
  rxcap_1049_fail:
    goto rx1041_fail
  rxcap_1049_done:
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
  alt1051_0:
    set_addr $I10, alt1051_1
    rx1041_cur."!mark_push"(0, rx1041_pos, $I10)
  # rx literal  "regex"
    add $I11, rx1041_pos, 5
    gt $I11, rx1041_eos, rx1041_fail
    sub $I11, rx1041_pos, rx1041_off
    substr $S10, rx1041_tgt, $I11, 5
    ne $S10, "regex", rx1041_fail
    add rx1041_pos, 5
    goto alt1051_end
  alt1051_1:
    set_addr $I10, alt1051_2
    rx1041_cur."!mark_push"(0, rx1041_pos, $I10)
  # rx literal  "token"
    add $I11, rx1041_pos, 5
    gt $I11, rx1041_eos, rx1041_fail
    sub $I11, rx1041_pos, rx1041_off
    substr $S10, rx1041_tgt, $I11, 5
    ne $S10, "token", rx1041_fail
    add rx1041_pos, 5
    goto alt1051_end
  alt1051_2:
  # rx literal  "rule"
    add $I11, rx1041_pos, 4
    gt $I11, rx1041_eos, rx1041_fail
    sub $I11, rx1041_pos, rx1041_off
    substr $S10, rx1041_tgt, $I11, 4
    ne $S10, "rule", rx1041_fail
    add rx1041_pos, 4
  alt1051_end:
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
.annotate 'line', 473
  # rx subrule "deflongname" subtype=capture negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."deflongname"()
    unless $P10, rx1041_fail
    rx1041_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1041_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
  alt1054_0:
.annotate 'line', 474
    set_addr $I10, alt1054_1
    rx1041_cur."!mark_push"(0, rx1041_pos, $I10)
.annotate 'line', 475
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx1041_pos, 1
    gt $I11, rx1041_eos, rx1041_fail
    sub $I11, rx1041_pos, rx1041_off
    ord $I11, rx1041_tgt, $I11
    ne $I11, 123, rx1041_fail
    add rx1041_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
  # rx literal  "<...>"
    add $I11, rx1041_pos, 5
    gt $I11, rx1041_eos, rx1041_fail
    sub $I11, rx1041_pos, rx1041_off
    substr $S10, rx1041_tgt, $I11, 5
    ne $S10, "<...>", rx1041_fail
    add rx1041_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1041_pos, 1
    gt $I11, rx1041_eos, rx1041_fail
    sub $I11, rx1041_pos, rx1041_off
    ord $I11, rx1041_tgt, $I11
    ne $I11, 125, rx1041_fail
    add rx1041_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ENDSTMT"()
    unless $P10, rx1041_fail
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
    goto alt1054_end
  alt1054_1:
    set_addr $I10, alt1054_2
    rx1041_cur."!mark_push"(0, rx1041_pos, $I10)
.annotate 'line', 476
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx1041_pos, 1
    gt $I11, rx1041_eos, rx1041_fail
    sub $I11, rx1041_pos, rx1041_off
    ord $I11, rx1041_tgt, $I11
    ne $I11, 123, rx1041_fail
    add rx1041_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
  # rx literal  "<*>"
    add $I11, rx1041_pos, 3
    gt $I11, rx1041_eos, rx1041_fail
    sub $I11, rx1041_pos, rx1041_off
    substr $S10, rx1041_tgt, $I11, 3
    ne $S10, "<*>", rx1041_fail
    add rx1041_pos, 3
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1041_pos, 1
    gt $I11, rx1041_eos, rx1041_fail
    sub $I11, rx1041_pos, rx1041_off
    ord $I11, rx1041_tgt, $I11
    ne $I11, 125, rx1041_fail
    add rx1041_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ENDSTMT"()
    unless $P10, rx1041_fail
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
    goto alt1054_end
  alt1054_2:
.annotate 'line', 477
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."panic"("Proto regex body must be <*> (or <...>, which is deprecated)")
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
  alt1054_end:
.annotate 'line', 478
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
.annotate 'line', 472
    goto alt1047_end
  alt1047_1:
.annotate 'line', 479
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
  # rx subcapture "sym"
    set_addr $I10, rxcap_1068_fail
    rx1041_cur."!mark_push"(0, rx1041_pos, $I10)
  alt1067_0:
    set_addr $I10, alt1067_1
    rx1041_cur."!mark_push"(0, rx1041_pos, $I10)
  # rx literal  "regex"
    add $I11, rx1041_pos, 5
    gt $I11, rx1041_eos, rx1041_fail
    sub $I11, rx1041_pos, rx1041_off
    substr $S10, rx1041_tgt, $I11, 5
    ne $S10, "regex", rx1041_fail
    add rx1041_pos, 5
    goto alt1067_end
  alt1067_1:
    set_addr $I10, alt1067_2
    rx1041_cur."!mark_push"(0, rx1041_pos, $I10)
  # rx literal  "token"
    add $I11, rx1041_pos, 5
    gt $I11, rx1041_eos, rx1041_fail
    sub $I11, rx1041_pos, rx1041_off
    substr $S10, rx1041_tgt, $I11, 5
    ne $S10, "token", rx1041_fail
    add rx1041_pos, 5
    goto alt1067_end
  alt1067_2:
  # rx literal  "rule"
    add $I11, rx1041_pos, 4
    gt $I11, rx1041_eos, rx1041_fail
    sub $I11, rx1041_pos, rx1041_off
    substr $S10, rx1041_tgt, $I11, 4
    ne $S10, "rule", rx1041_fail
    add rx1041_pos, 4
  alt1067_end:
    set_addr $I10, rxcap_1068_fail
    ($I12, $I11) = rx1041_cur."!mark_peek"($I10)
    rx1041_cur."!cursor_pos"($I11)
    ($P10) = rx1041_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1041_pos, "")
    rx1041_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1068_done
  rxcap_1068_fail:
    goto rx1041_fail
  rxcap_1068_done:
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
.annotate 'line', 480
  # rx subrule "deflongname" subtype=capture negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."deflongname"()
    unless $P10, rx1041_fail
    rx1041_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1041_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
.annotate 'line', 481
  # rx subrule "newpad" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."newpad"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
.annotate 'line', 482
  # rx rxquantr1072 ** 0..1
    set_addr $I10, rxquantr1072_done
    rx1041_cur."!mark_push"(0, rx1041_pos, $I10)
  rxquantr1072_loop:
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1041_pos, 1
    gt $I11, rx1041_eos, rx1041_fail
    sub $I11, rx1041_pos, rx1041_off
    ord $I11, rx1041_tgt, $I11
    ne $I11, 40, rx1041_fail
    add rx1041_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."signature"()
    unless $P10, rx1041_fail
    rx1041_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx1041_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1041_pos, 1
    gt $I11, rx1041_eos, rx1041_fail
    sub $I11, rx1041_pos, rx1041_off
    ord $I11, rx1041_tgt, $I11
    ne $I11, 41, rx1041_fail
    add rx1041_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
    set_addr $I10, rxquantr1072_done
    (rx1041_rep) = rx1041_cur."!mark_commit"($I10)
  rxquantr1072_done:
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
.annotate 'line', 483
  # rx reduce name="regex_declarator" key="open"
    rx1041_cur."!cursor_pos"(rx1041_pos)
    rx1041_cur."!reduce"("regex_declarator", "open")
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
.annotate 'line', 484
  # rx literal  "{"
    add $I11, rx1041_pos, 1
    gt $I11, rx1041_eos, rx1041_fail
    sub $I11, rx1041_pos, rx1041_off
    ord $I11, rx1041_tgt, $I11
    ne $I11, 123, rx1041_fail
    add rx1041_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."LANG"("Regex", "nibbler")
    unless $P10, rx1041_fail
    rx1041_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx1041_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1041_pos, 1
    gt $I11, rx1041_eos, rx1041_fail
    sub $I11, rx1041_pos, rx1041_off
    ord $I11, rx1041_tgt, $I11
    ne $I11, 125, rx1041_fail
    add rx1041_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ENDSTMT"()
    unless $P10, rx1041_fail
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
  alt1047_end:
.annotate 'line', 485
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
.annotate 'line', 470
  # rx pass
    rx1041_cur."!cursor_pass"(rx1041_pos, "regex_declarator")
    if_null rx1041_debug, debug_984
    rx1041_cur."!cursor_debug"("PASS", "regex_declarator", " at pos=", rx1041_pos)
  debug_984:
    .return (rx1041_cur)
  rx1041_restart:
.annotate 'line', 10
    if_null rx1041_debug, debug_985
    rx1041_cur."!cursor_debug"("NEXT", "regex_declarator")
  debug_985:
  rx1041_fail:
    (rx1041_rep, rx1041_pos, $I10, $P10) = rx1041_cur."!mark_fail"(0)
    lt rx1041_pos, -1, rx1041_done
    eq rx1041_pos, -1, rx1041_fail
    jump $I10
  rx1041_done:
    rx1041_cur."!cursor_fail"()
    if_null rx1041_debug, debug_986
    rx1041_cur."!cursor_debug"("FAIL", "regex_declarator")
  debug_986:
    .return (rx1041_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__regex_declarator"  :nsentry("!PREFIX__regex_declarator") :subid("209_1302110486.758") :method
.annotate 'line', 10
    $P1043 = self."!PREFIX__!subrule"("ws", "")
    new $P1044, "ResizablePMCArray"
    push $P1044, $P1043
    .return ($P1044)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "dotty"  :subid("210_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1082_tgt
    .local int rx1082_pos
    .local int rx1082_off
    .local int rx1082_eos
    .local int rx1082_rep
    .local pmc rx1082_cur
    .local pmc rx1082_debug
    (rx1082_cur, rx1082_pos, rx1082_tgt, $I10) = self."!cursor_start"()
    rx1082_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1082_cur
    .local pmc match
    .lex "$/", match
    length rx1082_eos, rx1082_tgt
    gt rx1082_pos, rx1082_eos, rx1082_done
    set rx1082_off, 0
    lt rx1082_pos, 2, rx1082_start
    sub rx1082_off, rx1082_pos, 1
    substr rx1082_tgt, rx1082_tgt, rx1082_off
  rx1082_start:
    eq $I10, 1, rx1082_restart
    if_null rx1082_debug, debug_987
    rx1082_cur."!cursor_debug"("START", "dotty")
  debug_987:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1086_done
    goto rxscan1086_scan
  rxscan1086_loop:
    (rx1082_pos) = rx1082_cur."from"()
    inc rx1082_pos
    rx1082_cur."!cursor_from"(rx1082_pos)
    ge rx1082_pos, rx1082_eos, rxscan1086_done
  rxscan1086_scan:
    set_addr $I10, rxscan1086_loop
    rx1082_cur."!mark_push"(0, rx1082_pos, $I10)
  rxscan1086_done:
.annotate 'line', 489
  # rx literal  "."
    add $I11, rx1082_pos, 1
    gt $I11, rx1082_eos, rx1082_fail
    sub $I11, rx1082_pos, rx1082_off
    ord $I11, rx1082_tgt, $I11
    ne $I11, 46, rx1082_fail
    add rx1082_pos, 1
  alt1087_0:
.annotate 'line', 490
    set_addr $I10, alt1087_1
    rx1082_cur."!mark_push"(0, rx1082_pos, $I10)
  # rx subrule "deflongname" subtype=capture negate=
    rx1082_cur."!cursor_pos"(rx1082_pos)
    $P10 = rx1082_cur."deflongname"()
    unless $P10, rx1082_fail
    rx1082_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname=deflongname")
    rx1082_pos = $P10."pos"()
    goto alt1087_end
  alt1087_1:
.annotate 'line', 491
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1082_pos, rx1082_off
    substr $S10, rx1082_tgt, $I10, 1
    index $I11, "'\"", $S10
    lt $I11, 0, rx1082_fail
  # rx subrule "quote" subtype=capture negate=
    rx1082_cur."!cursor_pos"(rx1082_pos)
    $P10 = rx1082_cur."quote"()
    unless $P10, rx1082_fail
    rx1082_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1082_pos = $P10."pos"()
  alt1088_0:
.annotate 'line', 492
    set_addr $I10, alt1088_1
    rx1082_cur."!mark_push"(0, rx1082_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1082_pos, rx1082_off
    substr $S10, rx1082_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1082_fail
    goto alt1088_end
  alt1088_1:
  # rx subrule "panic" subtype=method negate=
    rx1082_cur."!cursor_pos"(rx1082_pos)
    $P10 = rx1082_cur."panic"("Quoted method name requires parenthesized arguments")
    unless $P10, rx1082_fail
    rx1082_pos = $P10."pos"()
  alt1088_end:
  alt1087_end:
.annotate 'line', 498
  # rx rxquantr1089 ** 0..1
    set_addr $I10, rxquantr1089_done
    rx1082_cur."!mark_push"(0, rx1082_pos, $I10)
  rxquantr1089_loop:
  alt1090_0:
.annotate 'line', 495
    set_addr $I10, alt1090_1
    rx1082_cur."!mark_push"(0, rx1082_pos, $I10)
.annotate 'line', 496
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1082_pos, rx1082_off
    substr $S10, rx1082_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1082_fail
  # rx subrule "args" subtype=capture negate=
    rx1082_cur."!cursor_pos"(rx1082_pos)
    $P10 = rx1082_cur."args"()
    unless $P10, rx1082_fail
    rx1082_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1082_pos = $P10."pos"()
    goto alt1090_end
  alt1090_1:
.annotate 'line', 497
  # rx literal  ":"
    add $I11, rx1082_pos, 1
    gt $I11, rx1082_eos, rx1082_fail
    sub $I11, rx1082_pos, rx1082_off
    ord $I11, rx1082_tgt, $I11
    ne $I11, 58, rx1082_fail
    add rx1082_pos, 1
  # rx charclass s
    ge rx1082_pos, rx1082_eos, rx1082_fail
    sub $I10, rx1082_pos, rx1082_off
    is_cclass $I11, 32, rx1082_tgt, $I10
    unless $I11, rx1082_fail
    inc rx1082_pos
  # rx subrule "arglist" subtype=capture negate=
    rx1082_cur."!cursor_pos"(rx1082_pos)
    $P10 = rx1082_cur."arglist"()
    unless $P10, rx1082_fail
    rx1082_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1082_pos = $P10."pos"()
  alt1090_end:
.annotate 'line', 498
    set_addr $I10, rxquantr1089_done
    (rx1082_rep) = rx1082_cur."!mark_commit"($I10)
  rxquantr1089_done:
.annotate 'line', 488
  # rx pass
    rx1082_cur."!cursor_pass"(rx1082_pos, "dotty")
    if_null rx1082_debug, debug_988
    rx1082_cur."!cursor_debug"("PASS", "dotty", " at pos=", rx1082_pos)
  debug_988:
    .return (rx1082_cur)
  rx1082_restart:
.annotate 'line', 10
    if_null rx1082_debug, debug_989
    rx1082_cur."!cursor_debug"("NEXT", "dotty")
  debug_989:
  rx1082_fail:
    (rx1082_rep, rx1082_pos, $I10, $P10) = rx1082_cur."!mark_fail"(0)
    lt rx1082_pos, -1, rx1082_done
    eq rx1082_pos, -1, rx1082_fail
    jump $I10
  rx1082_done:
    rx1082_cur."!cursor_fail"()
    if_null rx1082_debug, debug_990
    rx1082_cur."!cursor_debug"("FAIL", "dotty")
  debug_990:
    .return (rx1082_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__dotty"  :nsentry("!PREFIX__dotty") :subid("211_1302110486.758") :method
.annotate 'line', 10
    $P1084 = self."!PREFIX__!subrule"("deflongname", ".")
    new $P1085, "ResizablePMCArray"
    push $P1085, "'"
    push $P1085, "\""
    push $P1085, $P1084
    .return ($P1085)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term"  :subid("212_1302110486.758")
    .param pmc param_1092
.annotate 'line', 502
    .lex "self", param_1092
    $P1093 = param_1092."!protoregex"("term")
    .return ($P1093)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term"  :subid("213_1302110486.758")
    .param pmc param_1095
.annotate 'line', 502
    .lex "self", param_1095
    $P1096 = param_1095."!PREFIX__!protoregex"("term")
    .return ($P1096)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<self>"  :subid("214_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1098_tgt
    .local int rx1098_pos
    .local int rx1098_off
    .local int rx1098_eos
    .local int rx1098_rep
    .local pmc rx1098_cur
    .local pmc rx1098_debug
    (rx1098_cur, rx1098_pos, rx1098_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1098_cur
    .local pmc match
    .lex "$/", match
    length rx1098_eos, rx1098_tgt
    gt rx1098_pos, rx1098_eos, rx1098_done
    set rx1098_off, 0
    lt rx1098_pos, 2, rx1098_start
    sub rx1098_off, rx1098_pos, 1
    substr rx1098_tgt, rx1098_tgt, rx1098_off
  rx1098_start:
    eq $I10, 1, rx1098_restart
    if_null rx1098_debug, debug_991
    rx1098_cur."!cursor_debug"("START", "term:sym<self>")
  debug_991:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1101_done
    goto rxscan1101_scan
  rxscan1101_loop:
    (rx1098_pos) = rx1098_cur."from"()
    inc rx1098_pos
    rx1098_cur."!cursor_from"(rx1098_pos)
    ge rx1098_pos, rx1098_eos, rxscan1101_done
  rxscan1101_scan:
    set_addr $I10, rxscan1101_loop
    rx1098_cur."!mark_push"(0, rx1098_pos, $I10)
  rxscan1101_done:
.annotate 'line', 504
  # rx subcapture "sym"
    set_addr $I10, rxcap_1102_fail
    rx1098_cur."!mark_push"(0, rx1098_pos, $I10)
  # rx literal  "self"
    add $I11, rx1098_pos, 4
    gt $I11, rx1098_eos, rx1098_fail
    sub $I11, rx1098_pos, rx1098_off
    substr $S10, rx1098_tgt, $I11, 4
    ne $S10, "self", rx1098_fail
    add rx1098_pos, 4
    set_addr $I10, rxcap_1102_fail
    ($I12, $I11) = rx1098_cur."!mark_peek"($I10)
    rx1098_cur."!cursor_pos"($I11)
    ($P10) = rx1098_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1098_pos, "")
    rx1098_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1102_done
  rxcap_1102_fail:
    goto rx1098_fail
  rxcap_1102_done:
  # rxanchor rwb
    le rx1098_pos, 0, rx1098_fail
    sub $I10, rx1098_pos, rx1098_off
    is_cclass $I11, 8192, rx1098_tgt, $I10
    if $I11, rx1098_fail
    dec $I10
    is_cclass $I11, 8192, rx1098_tgt, $I10
    unless $I11, rx1098_fail
  # rx pass
    rx1098_cur."!cursor_pass"(rx1098_pos, "term:sym<self>")
    if_null rx1098_debug, debug_992
    rx1098_cur."!cursor_debug"("PASS", "term:sym<self>", " at pos=", rx1098_pos)
  debug_992:
    .return (rx1098_cur)
  rx1098_restart:
.annotate 'line', 10
    if_null rx1098_debug, debug_993
    rx1098_cur."!cursor_debug"("NEXT", "term:sym<self>")
  debug_993:
  rx1098_fail:
    (rx1098_rep, rx1098_pos, $I10, $P10) = rx1098_cur."!mark_fail"(0)
    lt rx1098_pos, -1, rx1098_done
    eq rx1098_pos, -1, rx1098_fail
    jump $I10
  rx1098_done:
    rx1098_cur."!cursor_fail"()
    if_null rx1098_debug, debug_994
    rx1098_cur."!cursor_debug"("FAIL", "term:sym<self>")
  debug_994:
    .return (rx1098_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<self>"  :nsentry("!PREFIX__term:sym<self>") :subid("215_1302110486.758") :method
.annotate 'line', 10
    new $P1100, "ResizablePMCArray"
    push $P1100, "self"
    .return ($P1100)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<identifier>"  :subid("216_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1104_tgt
    .local int rx1104_pos
    .local int rx1104_off
    .local int rx1104_eos
    .local int rx1104_rep
    .local pmc rx1104_cur
    .local pmc rx1104_debug
    (rx1104_cur, rx1104_pos, rx1104_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1104_cur
    .local pmc match
    .lex "$/", match
    length rx1104_eos, rx1104_tgt
    gt rx1104_pos, rx1104_eos, rx1104_done
    set rx1104_off, 0
    lt rx1104_pos, 2, rx1104_start
    sub rx1104_off, rx1104_pos, 1
    substr rx1104_tgt, rx1104_tgt, rx1104_off
  rx1104_start:
    eq $I10, 1, rx1104_restart
    if_null rx1104_debug, debug_995
    rx1104_cur."!cursor_debug"("START", "term:sym<identifier>")
  debug_995:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1108_done
    goto rxscan1108_scan
  rxscan1108_loop:
    (rx1104_pos) = rx1104_cur."from"()
    inc rx1104_pos
    rx1104_cur."!cursor_from"(rx1104_pos)
    ge rx1104_pos, rx1104_eos, rxscan1108_done
  rxscan1108_scan:
    set_addr $I10, rxscan1108_loop
    rx1104_cur."!mark_push"(0, rx1104_pos, $I10)
  rxscan1108_done:
.annotate 'line', 507
  # rx subrule "deflongname" subtype=capture negate=
    rx1104_cur."!cursor_pos"(rx1104_pos)
    $P10 = rx1104_cur."deflongname"()
    unless $P10, rx1104_fail
    rx1104_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1104_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1104_pos, rx1104_off
    substr $S10, rx1104_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1104_fail
  # rx subrule "args" subtype=capture negate=
    rx1104_cur."!cursor_pos"(rx1104_pos)
    $P10 = rx1104_cur."args"()
    unless $P10, rx1104_fail
    rx1104_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1104_pos = $P10."pos"()
.annotate 'line', 506
  # rx pass
    rx1104_cur."!cursor_pass"(rx1104_pos, "term:sym<identifier>")
    if_null rx1104_debug, debug_996
    rx1104_cur."!cursor_debug"("PASS", "term:sym<identifier>", " at pos=", rx1104_pos)
  debug_996:
    .return (rx1104_cur)
  rx1104_restart:
.annotate 'line', 10
    if_null rx1104_debug, debug_997
    rx1104_cur."!cursor_debug"("NEXT", "term:sym<identifier>")
  debug_997:
  rx1104_fail:
    (rx1104_rep, rx1104_pos, $I10, $P10) = rx1104_cur."!mark_fail"(0)
    lt rx1104_pos, -1, rx1104_done
    eq rx1104_pos, -1, rx1104_fail
    jump $I10
  rx1104_done:
    rx1104_cur."!cursor_fail"()
    if_null rx1104_debug, debug_998
    rx1104_cur."!cursor_debug"("FAIL", "term:sym<identifier>")
  debug_998:
    .return (rx1104_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<identifier>"  :nsentry("!PREFIX__term:sym<identifier>") :subid("217_1302110486.758") :method
.annotate 'line', 10
    $P1106 = self."!PREFIX__!subrule"("deflongname", "")
    new $P1107, "ResizablePMCArray"
    push $P1107, $P1106
    .return ($P1107)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<name>"  :subid("218_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1110_tgt
    .local int rx1110_pos
    .local int rx1110_off
    .local int rx1110_eos
    .local int rx1110_rep
    .local pmc rx1110_cur
    .local pmc rx1110_debug
    (rx1110_cur, rx1110_pos, rx1110_tgt, $I10) = self."!cursor_start"()
    rx1110_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1110_cur
    .local pmc match
    .lex "$/", match
    length rx1110_eos, rx1110_tgt
    gt rx1110_pos, rx1110_eos, rx1110_done
    set rx1110_off, 0
    lt rx1110_pos, 2, rx1110_start
    sub rx1110_off, rx1110_pos, 1
    substr rx1110_tgt, rx1110_tgt, rx1110_off
  rx1110_start:
    eq $I10, 1, rx1110_restart
    if_null rx1110_debug, debug_999
    rx1110_cur."!cursor_debug"("START", "term:sym<name>")
  debug_999:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1114_done
    goto rxscan1114_scan
  rxscan1114_loop:
    (rx1110_pos) = rx1110_cur."from"()
    inc rx1110_pos
    rx1110_cur."!cursor_from"(rx1110_pos)
    ge rx1110_pos, rx1110_eos, rxscan1114_done
  rxscan1114_scan:
    set_addr $I10, rxscan1114_loop
    rx1110_cur."!mark_push"(0, rx1110_pos, $I10)
  rxscan1114_done:
.annotate 'line', 511
  # rx subrule "name" subtype=capture negate=
    rx1110_cur."!cursor_pos"(rx1110_pos)
    $P10 = rx1110_cur."name"()
    unless $P10, rx1110_fail
    rx1110_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1110_pos = $P10."pos"()
  # rx rxquantr1115 ** 0..1
    set_addr $I10, rxquantr1115_done
    rx1110_cur."!mark_push"(0, rx1110_pos, $I10)
  rxquantr1115_loop:
  # rx subrule "args" subtype=capture negate=
    rx1110_cur."!cursor_pos"(rx1110_pos)
    $P10 = rx1110_cur."args"()
    unless $P10, rx1110_fail
    goto rxsubrule1116_pass
  rxsubrule1116_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1110_fail
  rxsubrule1116_pass:
    set_addr $I10, rxsubrule1116_back
    rx1110_cur."!mark_push"(0, rx1110_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1110_pos = $P10."pos"()
    set_addr $I10, rxquantr1115_done
    (rx1110_rep) = rx1110_cur."!mark_commit"($I10)
  rxquantr1115_done:
.annotate 'line', 510
  # rx pass
    rx1110_cur."!cursor_pass"(rx1110_pos, "term:sym<name>")
    if_null rx1110_debug, debug_1000
    rx1110_cur."!cursor_debug"("PASS", "term:sym<name>", " at pos=", rx1110_pos)
  debug_1000:
    .return (rx1110_cur)
  rx1110_restart:
.annotate 'line', 10
    if_null rx1110_debug, debug_1001
    rx1110_cur."!cursor_debug"("NEXT", "term:sym<name>")
  debug_1001:
  rx1110_fail:
    (rx1110_rep, rx1110_pos, $I10, $P10) = rx1110_cur."!mark_fail"(0)
    lt rx1110_pos, -1, rx1110_done
    eq rx1110_pos, -1, rx1110_fail
    jump $I10
  rx1110_done:
    rx1110_cur."!cursor_fail"()
    if_null rx1110_debug, debug_1002
    rx1110_cur."!cursor_debug"("FAIL", "term:sym<name>")
  debug_1002:
    .return (rx1110_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<name>"  :nsentry("!PREFIX__term:sym<name>") :subid("219_1302110486.758") :method
.annotate 'line', 10
    $P1112 = self."!PREFIX__!subrule"("name", "")
    new $P1113, "ResizablePMCArray"
    push $P1113, $P1112
    .return ($P1113)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<pir::op>"  :subid("220_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1118_tgt
    .local int rx1118_pos
    .local int rx1118_off
    .local int rx1118_eos
    .local int rx1118_rep
    .local pmc rx1118_cur
    .local pmc rx1118_debug
    (rx1118_cur, rx1118_pos, rx1118_tgt, $I10) = self."!cursor_start"()
    rx1118_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1118_cur
    .local pmc match
    .lex "$/", match
    length rx1118_eos, rx1118_tgt
    gt rx1118_pos, rx1118_eos, rx1118_done
    set rx1118_off, 0
    lt rx1118_pos, 2, rx1118_start
    sub rx1118_off, rx1118_pos, 1
    substr rx1118_tgt, rx1118_tgt, rx1118_off
  rx1118_start:
    eq $I10, 1, rx1118_restart
    if_null rx1118_debug, debug_1003
    rx1118_cur."!cursor_debug"("START", "term:sym<pir::op>")
  debug_1003:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1121_done
    goto rxscan1121_scan
  rxscan1121_loop:
    (rx1118_pos) = rx1118_cur."from"()
    inc rx1118_pos
    rx1118_cur."!cursor_from"(rx1118_pos)
    ge rx1118_pos, rx1118_eos, rxscan1121_done
  rxscan1121_scan:
    set_addr $I10, rxscan1121_loop
    rx1118_cur."!mark_push"(0, rx1118_pos, $I10)
  rxscan1121_done:
.annotate 'line', 515
  # rx literal  "pir::"
    add $I11, rx1118_pos, 5
    gt $I11, rx1118_eos, rx1118_fail
    sub $I11, rx1118_pos, rx1118_off
    substr $S10, rx1118_tgt, $I11, 5
    ne $S10, "pir::", rx1118_fail
    add rx1118_pos, 5
  # rx subcapture "op"
    set_addr $I10, rxcap_1122_fail
    rx1118_cur."!mark_push"(0, rx1118_pos, $I10)
  # rx charclass_q w r 1..-1
    sub $I10, rx1118_pos, rx1118_off
    find_not_cclass $I11, 8192, rx1118_tgt, $I10, rx1118_eos
    add $I12, $I10, 1
    lt $I11, $I12, rx1118_fail
    add rx1118_pos, rx1118_off, $I11
    set_addr $I10, rxcap_1122_fail
    ($I12, $I11) = rx1118_cur."!mark_peek"($I10)
    rx1118_cur."!cursor_pos"($I11)
    ($P10) = rx1118_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1118_pos, "")
    rx1118_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("op")
    goto rxcap_1122_done
  rxcap_1122_fail:
    goto rx1118_fail
  rxcap_1122_done:
  # rx rxquantr1123 ** 0..1
    set_addr $I10, rxquantr1123_done
    rx1118_cur."!mark_push"(0, rx1118_pos, $I10)
  rxquantr1123_loop:
  # rx subrule "args" subtype=capture negate=
    rx1118_cur."!cursor_pos"(rx1118_pos)
    $P10 = rx1118_cur."args"()
    unless $P10, rx1118_fail
    goto rxsubrule1124_pass
  rxsubrule1124_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1118_fail
  rxsubrule1124_pass:
    set_addr $I10, rxsubrule1124_back
    rx1118_cur."!mark_push"(0, rx1118_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1118_pos = $P10."pos"()
    set_addr $I10, rxquantr1123_done
    (rx1118_rep) = rx1118_cur."!mark_commit"($I10)
  rxquantr1123_done:
.annotate 'line', 514
  # rx pass
    rx1118_cur."!cursor_pass"(rx1118_pos, "term:sym<pir::op>")
    if_null rx1118_debug, debug_1004
    rx1118_cur."!cursor_debug"("PASS", "term:sym<pir::op>", " at pos=", rx1118_pos)
  debug_1004:
    .return (rx1118_cur)
  rx1118_restart:
.annotate 'line', 10
    if_null rx1118_debug, debug_1005
    rx1118_cur."!cursor_debug"("NEXT", "term:sym<pir::op>")
  debug_1005:
  rx1118_fail:
    (rx1118_rep, rx1118_pos, $I10, $P10) = rx1118_cur."!mark_fail"(0)
    lt rx1118_pos, -1, rx1118_done
    eq rx1118_pos, -1, rx1118_fail
    jump $I10
  rx1118_done:
    rx1118_cur."!cursor_fail"()
    if_null rx1118_debug, debug_1006
    rx1118_cur."!cursor_debug"("FAIL", "term:sym<pir::op>")
  debug_1006:
    .return (rx1118_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<pir::op>"  :nsentry("!PREFIX__term:sym<pir::op>") :subid("221_1302110486.758") :method
.annotate 'line', 10
    new $P1120, "ResizablePMCArray"
    push $P1120, "pir::"
    .return ($P1120)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<onlystar>"  :subid("222_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .const 'Sub' $P1134 = "224_1302110486.758" 
    capture_lex $P1134
    .local string rx1126_tgt
    .local int rx1126_pos
    .local int rx1126_off
    .local int rx1126_eos
    .local int rx1126_rep
    .local pmc rx1126_cur
    .local pmc rx1126_debug
    (rx1126_cur, rx1126_pos, rx1126_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1126_cur
    .local pmc match
    .lex "$/", match
    length rx1126_eos, rx1126_tgt
    gt rx1126_pos, rx1126_eos, rx1126_done
    set rx1126_off, 0
    lt rx1126_pos, 2, rx1126_start
    sub rx1126_off, rx1126_pos, 1
    substr rx1126_tgt, rx1126_tgt, rx1126_off
  rx1126_start:
    eq $I10, 1, rx1126_restart
    if_null rx1126_debug, debug_1007
    rx1126_cur."!cursor_debug"("START", "term:sym<onlystar>")
  debug_1007:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1129_done
    goto rxscan1129_scan
  rxscan1129_loop:
    (rx1126_pos) = rx1126_cur."from"()
    inc rx1126_pos
    rx1126_cur."!cursor_from"(rx1126_pos)
    ge rx1126_pos, rx1126_eos, rxscan1129_done
  rxscan1129_scan:
    set_addr $I10, rxscan1129_loop
    rx1126_cur."!mark_push"(0, rx1126_pos, $I10)
  rxscan1129_done:
.annotate 'line', 519
  # rx literal  "{*}"
    add $I11, rx1126_pos, 3
    gt $I11, rx1126_eos, rx1126_fail
    sub $I11, rx1126_pos, rx1126_off
    substr $S10, rx1126_tgt, $I11, 3
    ne $S10, "{*}", rx1126_fail
    add rx1126_pos, 3
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1126_cur."!cursor_pos"(rx1126_pos)
    $P10 = rx1126_cur."ENDSTMT"()
    unless $P10, rx1126_fail
  alt1130_0:
.annotate 'line', 520
    set_addr $I10, alt1130_1
    rx1126_cur."!mark_push"(0, rx1126_pos, $I10)
    rx1126_cur."!cursor_pos"(rx1126_pos)
    find_lex $P1131, unicode:"$\x{a2}"
    $P1132 = $P1131."MATCH"()
    store_lex "$/", $P1132
    .const 'Sub' $P1134 = "224_1302110486.758" 
    capture_lex $P1134
    $P1138 = $P1134()
    unless $P1138, rx1126_fail
    goto alt1130_end
  alt1130_1:
  # rx subrule "panic" subtype=method negate=
    rx1126_cur."!cursor_pos"(rx1126_pos)
    $P10 = rx1126_cur."panic"("{*} may only appear in proto")
    unless $P10, rx1126_fail
    rx1126_pos = $P10."pos"()
  alt1130_end:
.annotate 'line', 518
  # rx pass
    rx1126_cur."!cursor_pass"(rx1126_pos, "term:sym<onlystar>")
    if_null rx1126_debug, debug_1010
    rx1126_cur."!cursor_debug"("PASS", "term:sym<onlystar>", " at pos=", rx1126_pos)
  debug_1010:
    .return (rx1126_cur)
  rx1126_restart:
.annotate 'line', 10
    if_null rx1126_debug, debug_1011
    rx1126_cur."!cursor_debug"("NEXT", "term:sym<onlystar>")
  debug_1011:
  rx1126_fail:
    (rx1126_rep, rx1126_pos, $I10, $P10) = rx1126_cur."!mark_fail"(0)
    lt rx1126_pos, -1, rx1126_done
    eq rx1126_pos, -1, rx1126_fail
    jump $I10
  rx1126_done:
    rx1126_cur."!cursor_fail"()
    if_null rx1126_debug, debug_1012
    rx1126_cur."!cursor_debug"("FAIL", "term:sym<onlystar>")
  debug_1012:
    .return (rx1126_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<onlystar>"  :nsentry("!PREFIX__term:sym<onlystar>") :subid("223_1302110486.758") :method
.annotate 'line', 10
    new $P1128, "ResizablePMCArray"
    push $P1128, "{*}"
    .return ($P1128)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1133"  :anon :subid("224_1302110486.758") :outer("222_1302110486.758")
.annotate 'line', 520
    find_dynamic_lex $P1135, "$*MULTINESS"
    unless_null $P1135, vivify_1008
    get_hll_global $P1135, "$MULTINESS"
    unless_null $P1135, vivify_1009
    die "Contextual $*MULTINESS not found"
  vivify_1009:
  vivify_1008:
    set $S1136, $P1135
    iseq $I1137, $S1136, "proto"
    .return ($I1137)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "args"  :subid("225_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1140_tgt
    .local int rx1140_pos
    .local int rx1140_off
    .local int rx1140_eos
    .local int rx1140_rep
    .local pmc rx1140_cur
    .local pmc rx1140_debug
    (rx1140_cur, rx1140_pos, rx1140_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1140_cur
    .local pmc match
    .lex "$/", match
    length rx1140_eos, rx1140_tgt
    gt rx1140_pos, rx1140_eos, rx1140_done
    set rx1140_off, 0
    lt rx1140_pos, 2, rx1140_start
    sub rx1140_off, rx1140_pos, 1
    substr rx1140_tgt, rx1140_tgt, rx1140_off
  rx1140_start:
    eq $I10, 1, rx1140_restart
    if_null rx1140_debug, debug_1013
    rx1140_cur."!cursor_debug"("START", "args")
  debug_1013:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1144_done
    goto rxscan1144_scan
  rxscan1144_loop:
    (rx1140_pos) = rx1140_cur."from"()
    inc rx1140_pos
    rx1140_cur."!cursor_from"(rx1140_pos)
    ge rx1140_pos, rx1140_eos, rxscan1144_done
  rxscan1144_scan:
    set_addr $I10, rxscan1144_loop
    rx1140_cur."!mark_push"(0, rx1140_pos, $I10)
  rxscan1144_done:
.annotate 'line', 524
  # rx literal  "("
    add $I11, rx1140_pos, 1
    gt $I11, rx1140_eos, rx1140_fail
    sub $I11, rx1140_pos, rx1140_off
    ord $I11, rx1140_tgt, $I11
    ne $I11, 40, rx1140_fail
    add rx1140_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx1140_cur."!cursor_pos"(rx1140_pos)
    $P10 = rx1140_cur."arglist"()
    unless $P10, rx1140_fail
    rx1140_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1140_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1140_pos, 1
    gt $I11, rx1140_eos, rx1140_fail
    sub $I11, rx1140_pos, rx1140_off
    ord $I11, rx1140_tgt, $I11
    ne $I11, 41, rx1140_fail
    add rx1140_pos, 1
  # rx pass
    rx1140_cur."!cursor_pass"(rx1140_pos, "args")
    if_null rx1140_debug, debug_1014
    rx1140_cur."!cursor_debug"("PASS", "args", " at pos=", rx1140_pos)
  debug_1014:
    .return (rx1140_cur)
  rx1140_restart:
.annotate 'line', 10
    if_null rx1140_debug, debug_1015
    rx1140_cur."!cursor_debug"("NEXT", "args")
  debug_1015:
  rx1140_fail:
    (rx1140_rep, rx1140_pos, $I10, $P10) = rx1140_cur."!mark_fail"(0)
    lt rx1140_pos, -1, rx1140_done
    eq rx1140_pos, -1, rx1140_fail
    jump $I10
  rx1140_done:
    rx1140_cur."!cursor_fail"()
    if_null rx1140_debug, debug_1016
    rx1140_cur."!cursor_debug"("FAIL", "args")
  debug_1016:
    .return (rx1140_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__args"  :nsentry("!PREFIX__args") :subid("226_1302110486.758") :method
.annotate 'line', 10
    $P1142 = self."!PREFIX__!subrule"("arglist", "(")
    new $P1143, "ResizablePMCArray"
    push $P1143, $P1142
    .return ($P1143)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "arglist"  :subid("227_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1146_tgt
    .local int rx1146_pos
    .local int rx1146_off
    .local int rx1146_eos
    .local int rx1146_rep
    .local pmc rx1146_cur
    .local pmc rx1146_debug
    (rx1146_cur, rx1146_pos, rx1146_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1146_cur
    .local pmc match
    .lex "$/", match
    length rx1146_eos, rx1146_tgt
    gt rx1146_pos, rx1146_eos, rx1146_done
    set rx1146_off, 0
    lt rx1146_pos, 2, rx1146_start
    sub rx1146_off, rx1146_pos, 1
    substr rx1146_tgt, rx1146_tgt, rx1146_off
  rx1146_start:
    eq $I10, 1, rx1146_restart
    if_null rx1146_debug, debug_1017
    rx1146_cur."!cursor_debug"("START", "arglist")
  debug_1017:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1150_done
    goto rxscan1150_scan
  rxscan1150_loop:
    (rx1146_pos) = rx1146_cur."from"()
    inc rx1146_pos
    rx1146_cur."!cursor_from"(rx1146_pos)
    ge rx1146_pos, rx1146_eos, rxscan1150_done
  rxscan1150_scan:
    set_addr $I10, rxscan1150_loop
    rx1146_cur."!mark_push"(0, rx1146_pos, $I10)
  rxscan1150_done:
.annotate 'line', 528
  # rx subrule "ws" subtype=method negate=
    rx1146_cur."!cursor_pos"(rx1146_pos)
    $P10 = rx1146_cur."ws"()
    unless $P10, rx1146_fail
    rx1146_pos = $P10."pos"()
  alt1151_0:
.annotate 'line', 529
    set_addr $I10, alt1151_1
    rx1146_cur."!mark_push"(0, rx1146_pos, $I10)
.annotate 'line', 530
  # rx subrule "EXPR" subtype=capture negate=
    rx1146_cur."!cursor_pos"(rx1146_pos)
    $P10 = rx1146_cur."EXPR"("f=")
    unless $P10, rx1146_fail
    rx1146_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1146_pos = $P10."pos"()
    goto alt1151_end
  alt1151_1:
  alt1151_end:
.annotate 'line', 527
  # rx pass
    rx1146_cur."!cursor_pass"(rx1146_pos, "arglist")
    if_null rx1146_debug, debug_1018
    rx1146_cur."!cursor_debug"("PASS", "arglist", " at pos=", rx1146_pos)
  debug_1018:
    .return (rx1146_cur)
  rx1146_restart:
.annotate 'line', 10
    if_null rx1146_debug, debug_1019
    rx1146_cur."!cursor_debug"("NEXT", "arglist")
  debug_1019:
  rx1146_fail:
    (rx1146_rep, rx1146_pos, $I10, $P10) = rx1146_cur."!mark_fail"(0)
    lt rx1146_pos, -1, rx1146_done
    eq rx1146_pos, -1, rx1146_fail
    jump $I10
  rx1146_done:
    rx1146_cur."!cursor_fail"()
    if_null rx1146_debug, debug_1020
    rx1146_cur."!cursor_debug"("FAIL", "arglist")
  debug_1020:
    .return (rx1146_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__arglist"  :nsentry("!PREFIX__arglist") :subid("228_1302110486.758") :method
.annotate 'line', 10
    $P1148 = self."!PREFIX__!subrule"("ws", "")
    new $P1149, "ResizablePMCArray"
    push $P1149, $P1148
    .return ($P1149)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<value>"  :subid("229_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1153_tgt
    .local int rx1153_pos
    .local int rx1153_off
    .local int rx1153_eos
    .local int rx1153_rep
    .local pmc rx1153_cur
    .local pmc rx1153_debug
    (rx1153_cur, rx1153_pos, rx1153_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1153_cur
    .local pmc match
    .lex "$/", match
    length rx1153_eos, rx1153_tgt
    gt rx1153_pos, rx1153_eos, rx1153_done
    set rx1153_off, 0
    lt rx1153_pos, 2, rx1153_start
    sub rx1153_off, rx1153_pos, 1
    substr rx1153_tgt, rx1153_tgt, rx1153_off
  rx1153_start:
    eq $I10, 1, rx1153_restart
    if_null rx1153_debug, debug_1021
    rx1153_cur."!cursor_debug"("START", "term:sym<value>")
  debug_1021:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1157_done
    goto rxscan1157_scan
  rxscan1157_loop:
    (rx1153_pos) = rx1153_cur."from"()
    inc rx1153_pos
    rx1153_cur."!cursor_from"(rx1153_pos)
    ge rx1153_pos, rx1153_eos, rxscan1157_done
  rxscan1157_scan:
    set_addr $I10, rxscan1157_loop
    rx1153_cur."!mark_push"(0, rx1153_pos, $I10)
  rxscan1157_done:
.annotate 'line', 536
  # rx subrule "value" subtype=capture negate=
    rx1153_cur."!cursor_pos"(rx1153_pos)
    $P10 = rx1153_cur."value"()
    unless $P10, rx1153_fail
    rx1153_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("value")
    rx1153_pos = $P10."pos"()
  # rx pass
    rx1153_cur."!cursor_pass"(rx1153_pos, "term:sym<value>")
    if_null rx1153_debug, debug_1022
    rx1153_cur."!cursor_debug"("PASS", "term:sym<value>", " at pos=", rx1153_pos)
  debug_1022:
    .return (rx1153_cur)
  rx1153_restart:
.annotate 'line', 10
    if_null rx1153_debug, debug_1023
    rx1153_cur."!cursor_debug"("NEXT", "term:sym<value>")
  debug_1023:
  rx1153_fail:
    (rx1153_rep, rx1153_pos, $I10, $P10) = rx1153_cur."!mark_fail"(0)
    lt rx1153_pos, -1, rx1153_done
    eq rx1153_pos, -1, rx1153_fail
    jump $I10
  rx1153_done:
    rx1153_cur."!cursor_fail"()
    if_null rx1153_debug, debug_1024
    rx1153_cur."!cursor_debug"("FAIL", "term:sym<value>")
  debug_1024:
    .return (rx1153_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<value>"  :nsentry("!PREFIX__term:sym<value>") :subid("230_1302110486.758") :method
.annotate 'line', 10
    $P1155 = self."!PREFIX__!subrule"("value", "")
    new $P1156, "ResizablePMCArray"
    push $P1156, $P1155
    .return ($P1156)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "value"  :subid("231_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1159_tgt
    .local int rx1159_pos
    .local int rx1159_off
    .local int rx1159_eos
    .local int rx1159_rep
    .local pmc rx1159_cur
    .local pmc rx1159_debug
    (rx1159_cur, rx1159_pos, rx1159_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1159_cur
    .local pmc match
    .lex "$/", match
    length rx1159_eos, rx1159_tgt
    gt rx1159_pos, rx1159_eos, rx1159_done
    set rx1159_off, 0
    lt rx1159_pos, 2, rx1159_start
    sub rx1159_off, rx1159_pos, 1
    substr rx1159_tgt, rx1159_tgt, rx1159_off
  rx1159_start:
    eq $I10, 1, rx1159_restart
    if_null rx1159_debug, debug_1025
    rx1159_cur."!cursor_debug"("START", "value")
  debug_1025:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1164_done
    goto rxscan1164_scan
  rxscan1164_loop:
    (rx1159_pos) = rx1159_cur."from"()
    inc rx1159_pos
    rx1159_cur."!cursor_from"(rx1159_pos)
    ge rx1159_pos, rx1159_eos, rxscan1164_done
  rxscan1164_scan:
    set_addr $I10, rxscan1164_loop
    rx1159_cur."!mark_push"(0, rx1159_pos, $I10)
  rxscan1164_done:
  alt1165_0:
.annotate 'line', 538
    set_addr $I10, alt1165_1
    rx1159_cur."!mark_push"(0, rx1159_pos, $I10)
.annotate 'line', 539
  # rx subrule "quote" subtype=capture negate=
    rx1159_cur."!cursor_pos"(rx1159_pos)
    $P10 = rx1159_cur."quote"()
    unless $P10, rx1159_fail
    rx1159_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1159_pos = $P10."pos"()
    goto alt1165_end
  alt1165_1:
.annotate 'line', 540
  # rx subrule "number" subtype=capture negate=
    rx1159_cur."!cursor_pos"(rx1159_pos)
    $P10 = rx1159_cur."number"()
    unless $P10, rx1159_fail
    rx1159_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("number")
    rx1159_pos = $P10."pos"()
  alt1165_end:
.annotate 'line', 538
  # rx pass
    rx1159_cur."!cursor_pass"(rx1159_pos, "value")
    if_null rx1159_debug, debug_1026
    rx1159_cur."!cursor_debug"("PASS", "value", " at pos=", rx1159_pos)
  debug_1026:
    .return (rx1159_cur)
  rx1159_restart:
.annotate 'line', 10
    if_null rx1159_debug, debug_1027
    rx1159_cur."!cursor_debug"("NEXT", "value")
  debug_1027:
  rx1159_fail:
    (rx1159_rep, rx1159_pos, $I10, $P10) = rx1159_cur."!mark_fail"(0)
    lt rx1159_pos, -1, rx1159_done
    eq rx1159_pos, -1, rx1159_fail
    jump $I10
  rx1159_done:
    rx1159_cur."!cursor_fail"()
    if_null rx1159_debug, debug_1028
    rx1159_cur."!cursor_debug"("FAIL", "value")
  debug_1028:
    .return (rx1159_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__value"  :nsentry("!PREFIX__value") :subid("232_1302110486.758") :method
.annotate 'line', 10
    $P1161 = self."!PREFIX__!subrule"("number", "")
    $P1162 = self."!PREFIX__!subrule"("quote", "")
    new $P1163, "ResizablePMCArray"
    push $P1163, $P1161
    push $P1163, $P1162
    .return ($P1163)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "number"  :subid("233_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1167_tgt
    .local int rx1167_pos
    .local int rx1167_off
    .local int rx1167_eos
    .local int rx1167_rep
    .local pmc rx1167_cur
    .local pmc rx1167_debug
    (rx1167_cur, rx1167_pos, rx1167_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1167_cur
    .local pmc match
    .lex "$/", match
    length rx1167_eos, rx1167_tgt
    gt rx1167_pos, rx1167_eos, rx1167_done
    set rx1167_off, 0
    lt rx1167_pos, 2, rx1167_start
    sub rx1167_off, rx1167_pos, 1
    substr rx1167_tgt, rx1167_tgt, rx1167_off
  rx1167_start:
    eq $I10, 1, rx1167_restart
    if_null rx1167_debug, debug_1029
    rx1167_cur."!cursor_debug"("START", "number")
  debug_1029:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1170_done
    goto rxscan1170_scan
  rxscan1170_loop:
    (rx1167_pos) = rx1167_cur."from"()
    inc rx1167_pos
    rx1167_cur."!cursor_from"(rx1167_pos)
    ge rx1167_pos, rx1167_eos, rxscan1170_done
  rxscan1170_scan:
    set_addr $I10, rxscan1170_loop
    rx1167_cur."!mark_push"(0, rx1167_pos, $I10)
  rxscan1170_done:
.annotate 'line', 544
  # rx subcapture "sign"
    set_addr $I10, rxcap_1172_fail
    rx1167_cur."!mark_push"(0, rx1167_pos, $I10)
  # rx enumcharlist_q negate=0  r 0..1
    sub $I10, rx1167_pos, rx1167_off
    set rx1167_rep, 0
    sub $I12, rx1167_eos, rx1167_pos
    le $I12, 1, rxenumcharlistq1171_loop
    set $I12, 1
  rxenumcharlistq1171_loop:
    le $I12, 0, rxenumcharlistq1171_done
    substr $S10, rx1167_tgt, $I10, 1
    index $I11, "+-", $S10
    lt $I11, 0, rxenumcharlistq1171_done
    inc rx1167_rep
  rxenumcharlistq1171_done:
    add rx1167_pos, rx1167_pos, rx1167_rep
    set_addr $I10, rxcap_1172_fail
    ($I12, $I11) = rx1167_cur."!mark_peek"($I10)
    rx1167_cur."!cursor_pos"($I11)
    ($P10) = rx1167_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1167_pos, "")
    rx1167_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sign")
    goto rxcap_1172_done
  rxcap_1172_fail:
    goto rx1167_fail
  rxcap_1172_done:
  alt1173_0:
.annotate 'line', 545
    set_addr $I10, alt1173_1
    rx1167_cur."!mark_push"(0, rx1167_pos, $I10)
  # rx subrule "dec_number" subtype=capture negate=
    rx1167_cur."!cursor_pos"(rx1167_pos)
    $P10 = rx1167_cur."dec_number"()
    unless $P10, rx1167_fail
    rx1167_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dec_number")
    rx1167_pos = $P10."pos"()
    goto alt1173_end
  alt1173_1:
  # rx subrule "integer" subtype=capture negate=
    rx1167_cur."!cursor_pos"(rx1167_pos)
    $P10 = rx1167_cur."integer"()
    unless $P10, rx1167_fail
    rx1167_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("integer")
    rx1167_pos = $P10."pos"()
  alt1173_end:
.annotate 'line', 543
  # rx pass
    rx1167_cur."!cursor_pass"(rx1167_pos, "number")
    if_null rx1167_debug, debug_1030
    rx1167_cur."!cursor_debug"("PASS", "number", " at pos=", rx1167_pos)
  debug_1030:
    .return (rx1167_cur)
  rx1167_restart:
.annotate 'line', 10
    if_null rx1167_debug, debug_1031
    rx1167_cur."!cursor_debug"("NEXT", "number")
  debug_1031:
  rx1167_fail:
    (rx1167_rep, rx1167_pos, $I10, $P10) = rx1167_cur."!mark_fail"(0)
    lt rx1167_pos, -1, rx1167_done
    eq rx1167_pos, -1, rx1167_fail
    jump $I10
  rx1167_done:
    rx1167_cur."!cursor_fail"()
    if_null rx1167_debug, debug_1032
    rx1167_cur."!cursor_debug"("FAIL", "number")
  debug_1032:
    .return (rx1167_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__number"  :nsentry("!PREFIX__number") :subid("234_1302110486.758") :method
.annotate 'line', 10
    new $P1169, "ResizablePMCArray"
    push $P1169, ""
    .return ($P1169)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote"  :subid("235_1302110486.758")
    .param pmc param_1175
.annotate 'line', 548
    .lex "self", param_1175
    $P1176 = param_1175."!protoregex"("quote")
    .return ($P1176)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote"  :subid("236_1302110486.758")
    .param pmc param_1178
.annotate 'line', 548
    .lex "self", param_1178
    $P1179 = param_1178."!PREFIX__!protoregex"("quote")
    .return ($P1179)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<apos>"  :subid("237_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1181_tgt
    .local int rx1181_pos
    .local int rx1181_off
    .local int rx1181_eos
    .local int rx1181_rep
    .local pmc rx1181_cur
    .local pmc rx1181_debug
    (rx1181_cur, rx1181_pos, rx1181_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1181_cur
    .local pmc match
    .lex "$/", match
    length rx1181_eos, rx1181_tgt
    gt rx1181_pos, rx1181_eos, rx1181_done
    set rx1181_off, 0
    lt rx1181_pos, 2, rx1181_start
    sub rx1181_off, rx1181_pos, 1
    substr rx1181_tgt, rx1181_tgt, rx1181_off
  rx1181_start:
    eq $I10, 1, rx1181_restart
    if_null rx1181_debug, debug_1033
    rx1181_cur."!cursor_debug"("START", "quote:sym<apos>")
  debug_1033:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1184_done
    goto rxscan1184_scan
  rxscan1184_loop:
    (rx1181_pos) = rx1181_cur."from"()
    inc rx1181_pos
    rx1181_cur."!cursor_from"(rx1181_pos)
    ge rx1181_pos, rx1181_eos, rxscan1184_done
  rxscan1184_scan:
    set_addr $I10, rxscan1184_loop
    rx1181_cur."!mark_push"(0, rx1181_pos, $I10)
  rxscan1184_done:
.annotate 'line', 549
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1181_pos, rx1181_off
    substr $S10, rx1181_tgt, $I10, 1
    index $I11, "'", $S10
    lt $I11, 0, rx1181_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1181_cur."!cursor_pos"(rx1181_pos)
    $P10 = rx1181_cur."quote_EXPR"(":q")
    unless $P10, rx1181_fail
    rx1181_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1181_pos = $P10."pos"()
  # rx pass
    rx1181_cur."!cursor_pass"(rx1181_pos, "quote:sym<apos>")
    if_null rx1181_debug, debug_1034
    rx1181_cur."!cursor_debug"("PASS", "quote:sym<apos>", " at pos=", rx1181_pos)
  debug_1034:
    .return (rx1181_cur)
  rx1181_restart:
.annotate 'line', 10
    if_null rx1181_debug, debug_1035
    rx1181_cur."!cursor_debug"("NEXT", "quote:sym<apos>")
  debug_1035:
  rx1181_fail:
    (rx1181_rep, rx1181_pos, $I10, $P10) = rx1181_cur."!mark_fail"(0)
    lt rx1181_pos, -1, rx1181_done
    eq rx1181_pos, -1, rx1181_fail
    jump $I10
  rx1181_done:
    rx1181_cur."!cursor_fail"()
    if_null rx1181_debug, debug_1036
    rx1181_cur."!cursor_debug"("FAIL", "quote:sym<apos>")
  debug_1036:
    .return (rx1181_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<apos>"  :nsentry("!PREFIX__quote:sym<apos>") :subid("238_1302110486.758") :method
.annotate 'line', 10
    new $P1183, "ResizablePMCArray"
    push $P1183, "'"
    .return ($P1183)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<dblq>"  :subid("239_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1186_tgt
    .local int rx1186_pos
    .local int rx1186_off
    .local int rx1186_eos
    .local int rx1186_rep
    .local pmc rx1186_cur
    .local pmc rx1186_debug
    (rx1186_cur, rx1186_pos, rx1186_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1186_cur
    .local pmc match
    .lex "$/", match
    length rx1186_eos, rx1186_tgt
    gt rx1186_pos, rx1186_eos, rx1186_done
    set rx1186_off, 0
    lt rx1186_pos, 2, rx1186_start
    sub rx1186_off, rx1186_pos, 1
    substr rx1186_tgt, rx1186_tgt, rx1186_off
  rx1186_start:
    eq $I10, 1, rx1186_restart
    if_null rx1186_debug, debug_1037
    rx1186_cur."!cursor_debug"("START", "quote:sym<dblq>")
  debug_1037:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1189_done
    goto rxscan1189_scan
  rxscan1189_loop:
    (rx1186_pos) = rx1186_cur."from"()
    inc rx1186_pos
    rx1186_cur."!cursor_from"(rx1186_pos)
    ge rx1186_pos, rx1186_eos, rxscan1189_done
  rxscan1189_scan:
    set_addr $I10, rxscan1189_loop
    rx1186_cur."!mark_push"(0, rx1186_pos, $I10)
  rxscan1189_done:
.annotate 'line', 550
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1186_pos, rx1186_off
    substr $S10, rx1186_tgt, $I10, 1
    index $I11, "\"", $S10
    lt $I11, 0, rx1186_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1186_cur."!cursor_pos"(rx1186_pos)
    $P10 = rx1186_cur."quote_EXPR"(":qq")
    unless $P10, rx1186_fail
    rx1186_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1186_pos = $P10."pos"()
  # rx pass
    rx1186_cur."!cursor_pass"(rx1186_pos, "quote:sym<dblq>")
    if_null rx1186_debug, debug_1038
    rx1186_cur."!cursor_debug"("PASS", "quote:sym<dblq>", " at pos=", rx1186_pos)
  debug_1038:
    .return (rx1186_cur)
  rx1186_restart:
.annotate 'line', 10
    if_null rx1186_debug, debug_1039
    rx1186_cur."!cursor_debug"("NEXT", "quote:sym<dblq>")
  debug_1039:
  rx1186_fail:
    (rx1186_rep, rx1186_pos, $I10, $P10) = rx1186_cur."!mark_fail"(0)
    lt rx1186_pos, -1, rx1186_done
    eq rx1186_pos, -1, rx1186_fail
    jump $I10
  rx1186_done:
    rx1186_cur."!cursor_fail"()
    if_null rx1186_debug, debug_1040
    rx1186_cur."!cursor_debug"("FAIL", "quote:sym<dblq>")
  debug_1040:
    .return (rx1186_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<dblq>"  :nsentry("!PREFIX__quote:sym<dblq>") :subid("240_1302110486.758") :method
.annotate 'line', 10
    new $P1188, "ResizablePMCArray"
    push $P1188, "\""
    .return ($P1188)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<q>"  :subid("241_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1191_tgt
    .local int rx1191_pos
    .local int rx1191_off
    .local int rx1191_eos
    .local int rx1191_rep
    .local pmc rx1191_cur
    .local pmc rx1191_debug
    (rx1191_cur, rx1191_pos, rx1191_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1191_cur
    .local pmc match
    .lex "$/", match
    length rx1191_eos, rx1191_tgt
    gt rx1191_pos, rx1191_eos, rx1191_done
    set rx1191_off, 0
    lt rx1191_pos, 2, rx1191_start
    sub rx1191_off, rx1191_pos, 1
    substr rx1191_tgt, rx1191_tgt, rx1191_off
  rx1191_start:
    eq $I10, 1, rx1191_restart
    if_null rx1191_debug, debug_1041
    rx1191_cur."!cursor_debug"("START", "quote:sym<q>")
  debug_1041:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1195_done
    goto rxscan1195_scan
  rxscan1195_loop:
    (rx1191_pos) = rx1191_cur."from"()
    inc rx1191_pos
    rx1191_cur."!cursor_from"(rx1191_pos)
    ge rx1191_pos, rx1191_eos, rxscan1195_done
  rxscan1195_scan:
    set_addr $I10, rxscan1195_loop
    rx1191_cur."!mark_push"(0, rx1191_pos, $I10)
  rxscan1195_done:
.annotate 'line', 551
  # rx literal  "q"
    add $I11, rx1191_pos, 1
    gt $I11, rx1191_eos, rx1191_fail
    sub $I11, rx1191_pos, rx1191_off
    ord $I11, rx1191_tgt, $I11
    ne $I11, 113, rx1191_fail
    add rx1191_pos, 1
  # rxanchor rwb
    le rx1191_pos, 0, rx1191_fail
    sub $I10, rx1191_pos, rx1191_off
    is_cclass $I11, 8192, rx1191_tgt, $I10
    if $I11, rx1191_fail
    dec $I10
    is_cclass $I11, 8192, rx1191_tgt, $I10
    unless $I11, rx1191_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1191_pos, rx1191_off
    substr $S10, rx1191_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1191_fail
  # rx subrule "ws" subtype=method negate=
    rx1191_cur."!cursor_pos"(rx1191_pos)
    $P10 = rx1191_cur."ws"()
    unless $P10, rx1191_fail
    rx1191_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1191_cur."!cursor_pos"(rx1191_pos)
    $P10 = rx1191_cur."quote_EXPR"(":q")
    unless $P10, rx1191_fail
    rx1191_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1191_pos = $P10."pos"()
  # rx pass
    rx1191_cur."!cursor_pass"(rx1191_pos, "quote:sym<q>")
    if_null rx1191_debug, debug_1042
    rx1191_cur."!cursor_debug"("PASS", "quote:sym<q>", " at pos=", rx1191_pos)
  debug_1042:
    .return (rx1191_cur)
  rx1191_restart:
.annotate 'line', 10
    if_null rx1191_debug, debug_1043
    rx1191_cur."!cursor_debug"("NEXT", "quote:sym<q>")
  debug_1043:
  rx1191_fail:
    (rx1191_rep, rx1191_pos, $I10, $P10) = rx1191_cur."!mark_fail"(0)
    lt rx1191_pos, -1, rx1191_done
    eq rx1191_pos, -1, rx1191_fail
    jump $I10
  rx1191_done:
    rx1191_cur."!cursor_fail"()
    if_null rx1191_debug, debug_1044
    rx1191_cur."!cursor_debug"("FAIL", "quote:sym<q>")
  debug_1044:
    .return (rx1191_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<q>"  :nsentry("!PREFIX__quote:sym<q>") :subid("242_1302110486.758") :method
.annotate 'line', 10
    $P1193 = self."!PREFIX__!subrule"("ws", "q")
    new $P1194, "ResizablePMCArray"
    push $P1194, $P1193
    .return ($P1194)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<qq>"  :subid("243_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1197_tgt
    .local int rx1197_pos
    .local int rx1197_off
    .local int rx1197_eos
    .local int rx1197_rep
    .local pmc rx1197_cur
    .local pmc rx1197_debug
    (rx1197_cur, rx1197_pos, rx1197_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1197_cur
    .local pmc match
    .lex "$/", match
    length rx1197_eos, rx1197_tgt
    gt rx1197_pos, rx1197_eos, rx1197_done
    set rx1197_off, 0
    lt rx1197_pos, 2, rx1197_start
    sub rx1197_off, rx1197_pos, 1
    substr rx1197_tgt, rx1197_tgt, rx1197_off
  rx1197_start:
    eq $I10, 1, rx1197_restart
    if_null rx1197_debug, debug_1045
    rx1197_cur."!cursor_debug"("START", "quote:sym<qq>")
  debug_1045:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1201_done
    goto rxscan1201_scan
  rxscan1201_loop:
    (rx1197_pos) = rx1197_cur."from"()
    inc rx1197_pos
    rx1197_cur."!cursor_from"(rx1197_pos)
    ge rx1197_pos, rx1197_eos, rxscan1201_done
  rxscan1201_scan:
    set_addr $I10, rxscan1201_loop
    rx1197_cur."!mark_push"(0, rx1197_pos, $I10)
  rxscan1201_done:
.annotate 'line', 552
  # rx literal  "qq"
    add $I11, rx1197_pos, 2
    gt $I11, rx1197_eos, rx1197_fail
    sub $I11, rx1197_pos, rx1197_off
    substr $S10, rx1197_tgt, $I11, 2
    ne $S10, "qq", rx1197_fail
    add rx1197_pos, 2
  # rxanchor rwb
    le rx1197_pos, 0, rx1197_fail
    sub $I10, rx1197_pos, rx1197_off
    is_cclass $I11, 8192, rx1197_tgt, $I10
    if $I11, rx1197_fail
    dec $I10
    is_cclass $I11, 8192, rx1197_tgt, $I10
    unless $I11, rx1197_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1197_pos, rx1197_off
    substr $S10, rx1197_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1197_fail
  # rx subrule "ws" subtype=method negate=
    rx1197_cur."!cursor_pos"(rx1197_pos)
    $P10 = rx1197_cur."ws"()
    unless $P10, rx1197_fail
    rx1197_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1197_cur."!cursor_pos"(rx1197_pos)
    $P10 = rx1197_cur."quote_EXPR"(":qq")
    unless $P10, rx1197_fail
    rx1197_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1197_pos = $P10."pos"()
  # rx pass
    rx1197_cur."!cursor_pass"(rx1197_pos, "quote:sym<qq>")
    if_null rx1197_debug, debug_1046
    rx1197_cur."!cursor_debug"("PASS", "quote:sym<qq>", " at pos=", rx1197_pos)
  debug_1046:
    .return (rx1197_cur)
  rx1197_restart:
.annotate 'line', 10
    if_null rx1197_debug, debug_1047
    rx1197_cur."!cursor_debug"("NEXT", "quote:sym<qq>")
  debug_1047:
  rx1197_fail:
    (rx1197_rep, rx1197_pos, $I10, $P10) = rx1197_cur."!mark_fail"(0)
    lt rx1197_pos, -1, rx1197_done
    eq rx1197_pos, -1, rx1197_fail
    jump $I10
  rx1197_done:
    rx1197_cur."!cursor_fail"()
    if_null rx1197_debug, debug_1048
    rx1197_cur."!cursor_debug"("FAIL", "quote:sym<qq>")
  debug_1048:
    .return (rx1197_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<qq>"  :nsentry("!PREFIX__quote:sym<qq>") :subid("244_1302110486.758") :method
.annotate 'line', 10
    $P1199 = self."!PREFIX__!subrule"("ws", "qq")
    new $P1200, "ResizablePMCArray"
    push $P1200, $P1199
    .return ($P1200)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q>"  :subid("245_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1203_tgt
    .local int rx1203_pos
    .local int rx1203_off
    .local int rx1203_eos
    .local int rx1203_rep
    .local pmc rx1203_cur
    .local pmc rx1203_debug
    (rx1203_cur, rx1203_pos, rx1203_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1203_cur
    .local pmc match
    .lex "$/", match
    length rx1203_eos, rx1203_tgt
    gt rx1203_pos, rx1203_eos, rx1203_done
    set rx1203_off, 0
    lt rx1203_pos, 2, rx1203_start
    sub rx1203_off, rx1203_pos, 1
    substr rx1203_tgt, rx1203_tgt, rx1203_off
  rx1203_start:
    eq $I10, 1, rx1203_restart
    if_null rx1203_debug, debug_1049
    rx1203_cur."!cursor_debug"("START", "quote:sym<Q>")
  debug_1049:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1207_done
    goto rxscan1207_scan
  rxscan1207_loop:
    (rx1203_pos) = rx1203_cur."from"()
    inc rx1203_pos
    rx1203_cur."!cursor_from"(rx1203_pos)
    ge rx1203_pos, rx1203_eos, rxscan1207_done
  rxscan1207_scan:
    set_addr $I10, rxscan1207_loop
    rx1203_cur."!mark_push"(0, rx1203_pos, $I10)
  rxscan1207_done:
.annotate 'line', 553
  # rx literal  "Q"
    add $I11, rx1203_pos, 1
    gt $I11, rx1203_eos, rx1203_fail
    sub $I11, rx1203_pos, rx1203_off
    ord $I11, rx1203_tgt, $I11
    ne $I11, 81, rx1203_fail
    add rx1203_pos, 1
  # rxanchor rwb
    le rx1203_pos, 0, rx1203_fail
    sub $I10, rx1203_pos, rx1203_off
    is_cclass $I11, 8192, rx1203_tgt, $I10
    if $I11, rx1203_fail
    dec $I10
    is_cclass $I11, 8192, rx1203_tgt, $I10
    unless $I11, rx1203_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1203_pos, rx1203_off
    substr $S10, rx1203_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1203_fail
  # rx subrule "ws" subtype=method negate=
    rx1203_cur."!cursor_pos"(rx1203_pos)
    $P10 = rx1203_cur."ws"()
    unless $P10, rx1203_fail
    rx1203_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1203_cur."!cursor_pos"(rx1203_pos)
    $P10 = rx1203_cur."quote_EXPR"()
    unless $P10, rx1203_fail
    rx1203_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1203_pos = $P10."pos"()
  # rx pass
    rx1203_cur."!cursor_pass"(rx1203_pos, "quote:sym<Q>")
    if_null rx1203_debug, debug_1050
    rx1203_cur."!cursor_debug"("PASS", "quote:sym<Q>", " at pos=", rx1203_pos)
  debug_1050:
    .return (rx1203_cur)
  rx1203_restart:
.annotate 'line', 10
    if_null rx1203_debug, debug_1051
    rx1203_cur."!cursor_debug"("NEXT", "quote:sym<Q>")
  debug_1051:
  rx1203_fail:
    (rx1203_rep, rx1203_pos, $I10, $P10) = rx1203_cur."!mark_fail"(0)
    lt rx1203_pos, -1, rx1203_done
    eq rx1203_pos, -1, rx1203_fail
    jump $I10
  rx1203_done:
    rx1203_cur."!cursor_fail"()
    if_null rx1203_debug, debug_1052
    rx1203_cur."!cursor_debug"("FAIL", "quote:sym<Q>")
  debug_1052:
    .return (rx1203_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q>"  :nsentry("!PREFIX__quote:sym<Q>") :subid("246_1302110486.758") :method
.annotate 'line', 10
    $P1205 = self."!PREFIX__!subrule"("ws", "Q")
    new $P1206, "ResizablePMCArray"
    push $P1206, $P1205
    .return ($P1206)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q:PIR>"  :subid("247_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1209_tgt
    .local int rx1209_pos
    .local int rx1209_off
    .local int rx1209_eos
    .local int rx1209_rep
    .local pmc rx1209_cur
    .local pmc rx1209_debug
    (rx1209_cur, rx1209_pos, rx1209_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1209_cur
    .local pmc match
    .lex "$/", match
    length rx1209_eos, rx1209_tgt
    gt rx1209_pos, rx1209_eos, rx1209_done
    set rx1209_off, 0
    lt rx1209_pos, 2, rx1209_start
    sub rx1209_off, rx1209_pos, 1
    substr rx1209_tgt, rx1209_tgt, rx1209_off
  rx1209_start:
    eq $I10, 1, rx1209_restart
    if_null rx1209_debug, debug_1053
    rx1209_cur."!cursor_debug"("START", "quote:sym<Q:PIR>")
  debug_1053:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1213_done
    goto rxscan1213_scan
  rxscan1213_loop:
    (rx1209_pos) = rx1209_cur."from"()
    inc rx1209_pos
    rx1209_cur."!cursor_from"(rx1209_pos)
    ge rx1209_pos, rx1209_eos, rxscan1213_done
  rxscan1213_scan:
    set_addr $I10, rxscan1213_loop
    rx1209_cur."!mark_push"(0, rx1209_pos, $I10)
  rxscan1213_done:
.annotate 'line', 554
  # rx literal  "Q:PIR"
    add $I11, rx1209_pos, 5
    gt $I11, rx1209_eos, rx1209_fail
    sub $I11, rx1209_pos, rx1209_off
    substr $S10, rx1209_tgt, $I11, 5
    ne $S10, "Q:PIR", rx1209_fail
    add rx1209_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx1209_cur."!cursor_pos"(rx1209_pos)
    $P10 = rx1209_cur."ws"()
    unless $P10, rx1209_fail
    rx1209_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1209_cur."!cursor_pos"(rx1209_pos)
    $P10 = rx1209_cur."quote_EXPR"()
    unless $P10, rx1209_fail
    rx1209_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1209_pos = $P10."pos"()
  # rx pass
    rx1209_cur."!cursor_pass"(rx1209_pos, "quote:sym<Q:PIR>")
    if_null rx1209_debug, debug_1054
    rx1209_cur."!cursor_debug"("PASS", "quote:sym<Q:PIR>", " at pos=", rx1209_pos)
  debug_1054:
    .return (rx1209_cur)
  rx1209_restart:
.annotate 'line', 10
    if_null rx1209_debug, debug_1055
    rx1209_cur."!cursor_debug"("NEXT", "quote:sym<Q:PIR>")
  debug_1055:
  rx1209_fail:
    (rx1209_rep, rx1209_pos, $I10, $P10) = rx1209_cur."!mark_fail"(0)
    lt rx1209_pos, -1, rx1209_done
    eq rx1209_pos, -1, rx1209_fail
    jump $I10
  rx1209_done:
    rx1209_cur."!cursor_fail"()
    if_null rx1209_debug, debug_1056
    rx1209_cur."!cursor_debug"("FAIL", "quote:sym<Q:PIR>")
  debug_1056:
    .return (rx1209_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q:PIR>"  :nsentry("!PREFIX__quote:sym<Q:PIR>") :subid("248_1302110486.758") :method
.annotate 'line', 10
    $P1211 = self."!PREFIX__!subrule"("ws", "Q:PIR")
    new $P1212, "ResizablePMCArray"
    push $P1212, $P1211
    .return ($P1212)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym</ />"  :subid("249_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1215_tgt
    .local int rx1215_pos
    .local int rx1215_off
    .local int rx1215_eos
    .local int rx1215_rep
    .local pmc rx1215_cur
    .local pmc rx1215_debug
    (rx1215_cur, rx1215_pos, rx1215_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1215_cur
    .local pmc match
    .lex "$/", match
    length rx1215_eos, rx1215_tgt
    gt rx1215_pos, rx1215_eos, rx1215_done
    set rx1215_off, 0
    lt rx1215_pos, 2, rx1215_start
    sub rx1215_off, rx1215_pos, 1
    substr rx1215_tgt, rx1215_tgt, rx1215_off
  rx1215_start:
    eq $I10, 1, rx1215_restart
    if_null rx1215_debug, debug_1057
    rx1215_cur."!cursor_debug"("START", "quote:sym</ />")
  debug_1057:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1219_done
    goto rxscan1219_scan
  rxscan1219_loop:
    (rx1215_pos) = rx1215_cur."from"()
    inc rx1215_pos
    rx1215_cur."!cursor_from"(rx1215_pos)
    ge rx1215_pos, rx1215_eos, rxscan1219_done
  rxscan1219_scan:
    set_addr $I10, rxscan1219_loop
    rx1215_cur."!mark_push"(0, rx1215_pos, $I10)
  rxscan1219_done:
.annotate 'line', 556
  # rx literal  "/"
    add $I11, rx1215_pos, 1
    gt $I11, rx1215_eos, rx1215_fail
    sub $I11, rx1215_pos, rx1215_off
    ord $I11, rx1215_tgt, $I11
    ne $I11, 47, rx1215_fail
    add rx1215_pos, 1
.annotate 'line', 557
  # rx subrule "newpad" subtype=method negate=
    rx1215_cur."!cursor_pos"(rx1215_pos)
    $P10 = rx1215_cur."newpad"()
    unless $P10, rx1215_fail
    rx1215_pos = $P10."pos"()
.annotate 'line', 558
  # rx reduce name="quote:sym</ />" key="open"
    rx1215_cur."!cursor_pos"(rx1215_pos)
    rx1215_cur."!reduce"("quote:sym</ />", "open")
.annotate 'line', 559
  # rx subrule "LANG" subtype=capture negate=
    rx1215_cur."!cursor_pos"(rx1215_pos)
    $P10 = rx1215_cur."LANG"("Regex", "nibbler")
    unless $P10, rx1215_fail
    rx1215_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx1215_pos = $P10."pos"()
.annotate 'line', 560
  # rx literal  "/"
    add $I11, rx1215_pos, 1
    gt $I11, rx1215_eos, rx1215_fail
    sub $I11, rx1215_pos, rx1215_off
    ord $I11, rx1215_tgt, $I11
    ne $I11, 47, rx1215_fail
    add rx1215_pos, 1
.annotate 'line', 555
  # rx pass
    rx1215_cur."!cursor_pass"(rx1215_pos, "quote:sym</ />")
    if_null rx1215_debug, debug_1058
    rx1215_cur."!cursor_debug"("PASS", "quote:sym</ />", " at pos=", rx1215_pos)
  debug_1058:
    .return (rx1215_cur)
  rx1215_restart:
.annotate 'line', 10
    if_null rx1215_debug, debug_1059
    rx1215_cur."!cursor_debug"("NEXT", "quote:sym</ />")
  debug_1059:
  rx1215_fail:
    (rx1215_rep, rx1215_pos, $I10, $P10) = rx1215_cur."!mark_fail"(0)
    lt rx1215_pos, -1, rx1215_done
    eq rx1215_pos, -1, rx1215_fail
    jump $I10
  rx1215_done:
    rx1215_cur."!cursor_fail"()
    if_null rx1215_debug, debug_1060
    rx1215_cur."!cursor_debug"("FAIL", "quote:sym</ />")
  debug_1060:
    .return (rx1215_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym</ />"  :nsentry("!PREFIX__quote:sym</ />") :subid("250_1302110486.758") :method
.annotate 'line', 10
    $P1217 = self."!PREFIX__!subrule"("newpad", "/")
    new $P1218, "ResizablePMCArray"
    push $P1218, $P1217
    .return ($P1218)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<$>"  :subid("251_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1221_tgt
    .local int rx1221_pos
    .local int rx1221_off
    .local int rx1221_eos
    .local int rx1221_rep
    .local pmc rx1221_cur
    .local pmc rx1221_debug
    (rx1221_cur, rx1221_pos, rx1221_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1221_cur
    .local pmc match
    .lex "$/", match
    length rx1221_eos, rx1221_tgt
    gt rx1221_pos, rx1221_eos, rx1221_done
    set rx1221_off, 0
    lt rx1221_pos, 2, rx1221_start
    sub rx1221_off, rx1221_pos, 1
    substr rx1221_tgt, rx1221_tgt, rx1221_off
  rx1221_start:
    eq $I10, 1, rx1221_restart
    if_null rx1221_debug, debug_1061
    rx1221_cur."!cursor_debug"("START", "quote_escape:sym<$>")
  debug_1061:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1224_done
    goto rxscan1224_scan
  rxscan1224_loop:
    (rx1221_pos) = rx1221_cur."from"()
    inc rx1221_pos
    rx1221_cur."!cursor_from"(rx1221_pos)
    ge rx1221_pos, rx1221_eos, rxscan1224_done
  rxscan1224_scan:
    set_addr $I10, rxscan1224_loop
    rx1221_cur."!mark_push"(0, rx1221_pos, $I10)
  rxscan1224_done:
.annotate 'line', 563
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1221_pos, rx1221_off
    substr $S10, rx1221_tgt, $I10, 1
    index $I11, "$", $S10
    lt $I11, 0, rx1221_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1221_cur."!cursor_pos"(rx1221_pos)
    $P10 = rx1221_cur."quotemod_check"("s")
    unless $P10, rx1221_fail
  # rx subrule "variable" subtype=capture negate=
    rx1221_cur."!cursor_pos"(rx1221_pos)
    $P10 = rx1221_cur."variable"()
    unless $P10, rx1221_fail
    rx1221_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx1221_pos = $P10."pos"()
  # rx pass
    rx1221_cur."!cursor_pass"(rx1221_pos, "quote_escape:sym<$>")
    if_null rx1221_debug, debug_1062
    rx1221_cur."!cursor_debug"("PASS", "quote_escape:sym<$>", " at pos=", rx1221_pos)
  debug_1062:
    .return (rx1221_cur)
  rx1221_restart:
.annotate 'line', 10
    if_null rx1221_debug, debug_1063
    rx1221_cur."!cursor_debug"("NEXT", "quote_escape:sym<$>")
  debug_1063:
  rx1221_fail:
    (rx1221_rep, rx1221_pos, $I10, $P10) = rx1221_cur."!mark_fail"(0)
    lt rx1221_pos, -1, rx1221_done
    eq rx1221_pos, -1, rx1221_fail
    jump $I10
  rx1221_done:
    rx1221_cur."!cursor_fail"()
    if_null rx1221_debug, debug_1064
    rx1221_cur."!cursor_debug"("FAIL", "quote_escape:sym<$>")
  debug_1064:
    .return (rx1221_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<$>"  :nsentry("!PREFIX__quote_escape:sym<$>") :subid("252_1302110486.758") :method
.annotate 'line', 10
    new $P1223, "ResizablePMCArray"
    push $P1223, "$"
    .return ($P1223)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<{ }>"  :subid("253_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1226_tgt
    .local int rx1226_pos
    .local int rx1226_off
    .local int rx1226_eos
    .local int rx1226_rep
    .local pmc rx1226_cur
    .local pmc rx1226_debug
    (rx1226_cur, rx1226_pos, rx1226_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1226_cur
    .local pmc match
    .lex "$/", match
    length rx1226_eos, rx1226_tgt
    gt rx1226_pos, rx1226_eos, rx1226_done
    set rx1226_off, 0
    lt rx1226_pos, 2, rx1226_start
    sub rx1226_off, rx1226_pos, 1
    substr rx1226_tgt, rx1226_tgt, rx1226_off
  rx1226_start:
    eq $I10, 1, rx1226_restart
    if_null rx1226_debug, debug_1065
    rx1226_cur."!cursor_debug"("START", "quote_escape:sym<{ }>")
  debug_1065:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1229_done
    goto rxscan1229_scan
  rxscan1229_loop:
    (rx1226_pos) = rx1226_cur."from"()
    inc rx1226_pos
    rx1226_cur."!cursor_from"(rx1226_pos)
    ge rx1226_pos, rx1226_eos, rxscan1229_done
  rxscan1229_scan:
    set_addr $I10, rxscan1229_loop
    rx1226_cur."!mark_push"(0, rx1226_pos, $I10)
  rxscan1229_done:
.annotate 'line', 564
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1226_pos, rx1226_off
    substr $S10, rx1226_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1226_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1226_cur."!cursor_pos"(rx1226_pos)
    $P10 = rx1226_cur."quotemod_check"("c")
    unless $P10, rx1226_fail
  # rx subrule "block" subtype=capture negate=
    rx1226_cur."!cursor_pos"(rx1226_pos)
    $P10 = rx1226_cur."block"()
    unless $P10, rx1226_fail
    rx1226_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1226_pos = $P10."pos"()
  # rx pass
    rx1226_cur."!cursor_pass"(rx1226_pos, "quote_escape:sym<{ }>")
    if_null rx1226_debug, debug_1066
    rx1226_cur."!cursor_debug"("PASS", "quote_escape:sym<{ }>", " at pos=", rx1226_pos)
  debug_1066:
    .return (rx1226_cur)
  rx1226_restart:
.annotate 'line', 10
    if_null rx1226_debug, debug_1067
    rx1226_cur."!cursor_debug"("NEXT", "quote_escape:sym<{ }>")
  debug_1067:
  rx1226_fail:
    (rx1226_rep, rx1226_pos, $I10, $P10) = rx1226_cur."!mark_fail"(0)
    lt rx1226_pos, -1, rx1226_done
    eq rx1226_pos, -1, rx1226_fail
    jump $I10
  rx1226_done:
    rx1226_cur."!cursor_fail"()
    if_null rx1226_debug, debug_1068
    rx1226_cur."!cursor_debug"("FAIL", "quote_escape:sym<{ }>")
  debug_1068:
    .return (rx1226_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<{ }>"  :nsentry("!PREFIX__quote_escape:sym<{ }>") :subid("254_1302110486.758") :method
.annotate 'line', 10
    new $P1228, "ResizablePMCArray"
    push $P1228, "{"
    .return ($P1228)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<esc>"  :subid("255_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1231_tgt
    .local int rx1231_pos
    .local int rx1231_off
    .local int rx1231_eos
    .local int rx1231_rep
    .local pmc rx1231_cur
    .local pmc rx1231_debug
    (rx1231_cur, rx1231_pos, rx1231_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1231_cur
    .local pmc match
    .lex "$/", match
    length rx1231_eos, rx1231_tgt
    gt rx1231_pos, rx1231_eos, rx1231_done
    set rx1231_off, 0
    lt rx1231_pos, 2, rx1231_start
    sub rx1231_off, rx1231_pos, 1
    substr rx1231_tgt, rx1231_tgt, rx1231_off
  rx1231_start:
    eq $I10, 1, rx1231_restart
    if_null rx1231_debug, debug_1069
    rx1231_cur."!cursor_debug"("START", "quote_escape:sym<esc>")
  debug_1069:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1234_done
    goto rxscan1234_scan
  rxscan1234_loop:
    (rx1231_pos) = rx1231_cur."from"()
    inc rx1231_pos
    rx1231_cur."!cursor_from"(rx1231_pos)
    ge rx1231_pos, rx1231_eos, rxscan1234_done
  rxscan1234_scan:
    set_addr $I10, rxscan1234_loop
    rx1231_cur."!mark_push"(0, rx1231_pos, $I10)
  rxscan1234_done:
.annotate 'line', 565
  # rx literal  "\\e"
    add $I11, rx1231_pos, 2
    gt $I11, rx1231_eos, rx1231_fail
    sub $I11, rx1231_pos, rx1231_off
    substr $S10, rx1231_tgt, $I11, 2
    ne $S10, "\\e", rx1231_fail
    add rx1231_pos, 2
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1231_cur."!cursor_pos"(rx1231_pos)
    $P10 = rx1231_cur."quotemod_check"("b")
    unless $P10, rx1231_fail
  # rx pass
    rx1231_cur."!cursor_pass"(rx1231_pos, "quote_escape:sym<esc>")
    if_null rx1231_debug, debug_1070
    rx1231_cur."!cursor_debug"("PASS", "quote_escape:sym<esc>", " at pos=", rx1231_pos)
  debug_1070:
    .return (rx1231_cur)
  rx1231_restart:
.annotate 'line', 10
    if_null rx1231_debug, debug_1071
    rx1231_cur."!cursor_debug"("NEXT", "quote_escape:sym<esc>")
  debug_1071:
  rx1231_fail:
    (rx1231_rep, rx1231_pos, $I10, $P10) = rx1231_cur."!mark_fail"(0)
    lt rx1231_pos, -1, rx1231_done
    eq rx1231_pos, -1, rx1231_fail
    jump $I10
  rx1231_done:
    rx1231_cur."!cursor_fail"()
    if_null rx1231_debug, debug_1072
    rx1231_cur."!cursor_debug"("FAIL", "quote_escape:sym<esc>")
  debug_1072:
    .return (rx1231_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<esc>"  :nsentry("!PREFIX__quote_escape:sym<esc>") :subid("256_1302110486.758") :method
.annotate 'line', 10
    new $P1233, "ResizablePMCArray"
    push $P1233, "\\e"
    .return ($P1233)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<( )>"  :subid("257_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1236_tgt
    .local int rx1236_pos
    .local int rx1236_off
    .local int rx1236_eos
    .local int rx1236_rep
    .local pmc rx1236_cur
    .local pmc rx1236_debug
    (rx1236_cur, rx1236_pos, rx1236_tgt, $I10) = self."!cursor_start"()
    rx1236_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx1236_cur
    .local pmc match
    .lex "$/", match
    length rx1236_eos, rx1236_tgt
    gt rx1236_pos, rx1236_eos, rx1236_done
    set rx1236_off, 0
    lt rx1236_pos, 2, rx1236_start
    sub rx1236_off, rx1236_pos, 1
    substr rx1236_tgt, rx1236_tgt, rx1236_off
  rx1236_start:
    eq $I10, 1, rx1236_restart
    if_null rx1236_debug, debug_1073
    rx1236_cur."!cursor_debug"("START", "circumfix:sym<( )>")
  debug_1073:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1240_done
    goto rxscan1240_scan
  rxscan1240_loop:
    (rx1236_pos) = rx1236_cur."from"()
    inc rx1236_pos
    rx1236_cur."!cursor_from"(rx1236_pos)
    ge rx1236_pos, rx1236_eos, rxscan1240_done
  rxscan1240_scan:
    set_addr $I10, rxscan1240_loop
    rx1236_cur."!mark_push"(0, rx1236_pos, $I10)
  rxscan1240_done:
.annotate 'line', 567
  # rx literal  "("
    add $I11, rx1236_pos, 1
    gt $I11, rx1236_eos, rx1236_fail
    sub $I11, rx1236_pos, rx1236_off
    ord $I11, rx1236_tgt, $I11
    ne $I11, 40, rx1236_fail
    add rx1236_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1236_cur."!cursor_pos"(rx1236_pos)
    $P10 = rx1236_cur."ws"()
    unless $P10, rx1236_fail
    rx1236_pos = $P10."pos"()
  # rx rxquantr1241 ** 0..1
    set_addr $I10, rxquantr1241_done
    rx1236_cur."!mark_push"(0, rx1236_pos, $I10)
  rxquantr1241_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx1236_cur."!cursor_pos"(rx1236_pos)
    $P10 = rx1236_cur."EXPR"()
    unless $P10, rx1236_fail
    goto rxsubrule1242_pass
  rxsubrule1242_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1236_fail
  rxsubrule1242_pass:
    set_addr $I10, rxsubrule1242_back
    rx1236_cur."!mark_push"(0, rx1236_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx1236_pos = $P10."pos"()
    set_addr $I10, rxquantr1241_done
    (rx1236_rep) = rx1236_cur."!mark_commit"($I10)
  rxquantr1241_done:
  # rx literal  ")"
    add $I11, rx1236_pos, 1
    gt $I11, rx1236_eos, rx1236_fail
    sub $I11, rx1236_pos, rx1236_off
    ord $I11, rx1236_tgt, $I11
    ne $I11, 41, rx1236_fail
    add rx1236_pos, 1
  # rx pass
    rx1236_cur."!cursor_pass"(rx1236_pos, "circumfix:sym<( )>")
    if_null rx1236_debug, debug_1074
    rx1236_cur."!cursor_debug"("PASS", "circumfix:sym<( )>", " at pos=", rx1236_pos)
  debug_1074:
    .return (rx1236_cur)
  rx1236_restart:
.annotate 'line', 10
    if_null rx1236_debug, debug_1075
    rx1236_cur."!cursor_debug"("NEXT", "circumfix:sym<( )>")
  debug_1075:
  rx1236_fail:
    (rx1236_rep, rx1236_pos, $I10, $P10) = rx1236_cur."!mark_fail"(0)
    lt rx1236_pos, -1, rx1236_done
    eq rx1236_pos, -1, rx1236_fail
    jump $I10
  rx1236_done:
    rx1236_cur."!cursor_fail"()
    if_null rx1236_debug, debug_1076
    rx1236_cur."!cursor_debug"("FAIL", "circumfix:sym<( )>")
  debug_1076:
    .return (rx1236_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<( )>"  :nsentry("!PREFIX__circumfix:sym<( )>") :subid("258_1302110486.758") :method
.annotate 'line', 10
    $P1238 = self."!PREFIX__!subrule"("ws", "(")
    new $P1239, "ResizablePMCArray"
    push $P1239, $P1238
    .return ($P1239)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<[ ]>"  :subid("259_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1244_tgt
    .local int rx1244_pos
    .local int rx1244_off
    .local int rx1244_eos
    .local int rx1244_rep
    .local pmc rx1244_cur
    .local pmc rx1244_debug
    (rx1244_cur, rx1244_pos, rx1244_tgt, $I10) = self."!cursor_start"()
    rx1244_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx1244_cur
    .local pmc match
    .lex "$/", match
    length rx1244_eos, rx1244_tgt
    gt rx1244_pos, rx1244_eos, rx1244_done
    set rx1244_off, 0
    lt rx1244_pos, 2, rx1244_start
    sub rx1244_off, rx1244_pos, 1
    substr rx1244_tgt, rx1244_tgt, rx1244_off
  rx1244_start:
    eq $I10, 1, rx1244_restart
    if_null rx1244_debug, debug_1077
    rx1244_cur."!cursor_debug"("START", "circumfix:sym<[ ]>")
  debug_1077:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1248_done
    goto rxscan1248_scan
  rxscan1248_loop:
    (rx1244_pos) = rx1244_cur."from"()
    inc rx1244_pos
    rx1244_cur."!cursor_from"(rx1244_pos)
    ge rx1244_pos, rx1244_eos, rxscan1248_done
  rxscan1248_scan:
    set_addr $I10, rxscan1248_loop
    rx1244_cur."!mark_push"(0, rx1244_pos, $I10)
  rxscan1248_done:
.annotate 'line', 568
  # rx literal  "["
    add $I11, rx1244_pos, 1
    gt $I11, rx1244_eos, rx1244_fail
    sub $I11, rx1244_pos, rx1244_off
    ord $I11, rx1244_tgt, $I11
    ne $I11, 91, rx1244_fail
    add rx1244_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1244_cur."!cursor_pos"(rx1244_pos)
    $P10 = rx1244_cur."ws"()
    unless $P10, rx1244_fail
    rx1244_pos = $P10."pos"()
  # rx rxquantr1249 ** 0..1
    set_addr $I10, rxquantr1249_done
    rx1244_cur."!mark_push"(0, rx1244_pos, $I10)
  rxquantr1249_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx1244_cur."!cursor_pos"(rx1244_pos)
    $P10 = rx1244_cur."EXPR"()
    unless $P10, rx1244_fail
    goto rxsubrule1250_pass
  rxsubrule1250_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1244_fail
  rxsubrule1250_pass:
    set_addr $I10, rxsubrule1250_back
    rx1244_cur."!mark_push"(0, rx1244_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx1244_pos = $P10."pos"()
    set_addr $I10, rxquantr1249_done
    (rx1244_rep) = rx1244_cur."!mark_commit"($I10)
  rxquantr1249_done:
  # rx literal  "]"
    add $I11, rx1244_pos, 1
    gt $I11, rx1244_eos, rx1244_fail
    sub $I11, rx1244_pos, rx1244_off
    ord $I11, rx1244_tgt, $I11
    ne $I11, 93, rx1244_fail
    add rx1244_pos, 1
  # rx pass
    rx1244_cur."!cursor_pass"(rx1244_pos, "circumfix:sym<[ ]>")
    if_null rx1244_debug, debug_1078
    rx1244_cur."!cursor_debug"("PASS", "circumfix:sym<[ ]>", " at pos=", rx1244_pos)
  debug_1078:
    .return (rx1244_cur)
  rx1244_restart:
.annotate 'line', 10
    if_null rx1244_debug, debug_1079
    rx1244_cur."!cursor_debug"("NEXT", "circumfix:sym<[ ]>")
  debug_1079:
  rx1244_fail:
    (rx1244_rep, rx1244_pos, $I10, $P10) = rx1244_cur."!mark_fail"(0)
    lt rx1244_pos, -1, rx1244_done
    eq rx1244_pos, -1, rx1244_fail
    jump $I10
  rx1244_done:
    rx1244_cur."!cursor_fail"()
    if_null rx1244_debug, debug_1080
    rx1244_cur."!cursor_debug"("FAIL", "circumfix:sym<[ ]>")
  debug_1080:
    .return (rx1244_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<[ ]>"  :nsentry("!PREFIX__circumfix:sym<[ ]>") :subid("260_1302110486.758") :method
.annotate 'line', 10
    $P1246 = self."!PREFIX__!subrule"("ws", "[")
    new $P1247, "ResizablePMCArray"
    push $P1247, $P1246
    .return ($P1247)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<ang>"  :subid("261_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1252_tgt
    .local int rx1252_pos
    .local int rx1252_off
    .local int rx1252_eos
    .local int rx1252_rep
    .local pmc rx1252_cur
    .local pmc rx1252_debug
    (rx1252_cur, rx1252_pos, rx1252_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1252_cur
    .local pmc match
    .lex "$/", match
    length rx1252_eos, rx1252_tgt
    gt rx1252_pos, rx1252_eos, rx1252_done
    set rx1252_off, 0
    lt rx1252_pos, 2, rx1252_start
    sub rx1252_off, rx1252_pos, 1
    substr rx1252_tgt, rx1252_tgt, rx1252_off
  rx1252_start:
    eq $I10, 1, rx1252_restart
    if_null rx1252_debug, debug_1081
    rx1252_cur."!cursor_debug"("START", "circumfix:sym<ang>")
  debug_1081:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1255_done
    goto rxscan1255_scan
  rxscan1255_loop:
    (rx1252_pos) = rx1252_cur."from"()
    inc rx1252_pos
    rx1252_cur."!cursor_from"(rx1252_pos)
    ge rx1252_pos, rx1252_eos, rxscan1255_done
  rxscan1255_scan:
    set_addr $I10, rxscan1255_loop
    rx1252_cur."!mark_push"(0, rx1252_pos, $I10)
  rxscan1255_done:
.annotate 'line', 569
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1252_pos, rx1252_off
    substr $S10, rx1252_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx1252_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1252_cur."!cursor_pos"(rx1252_pos)
    $P10 = rx1252_cur."quote_EXPR"(":q", ":w")
    unless $P10, rx1252_fail
    rx1252_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1252_pos = $P10."pos"()
  # rx pass
    rx1252_cur."!cursor_pass"(rx1252_pos, "circumfix:sym<ang>")
    if_null rx1252_debug, debug_1082
    rx1252_cur."!cursor_debug"("PASS", "circumfix:sym<ang>", " at pos=", rx1252_pos)
  debug_1082:
    .return (rx1252_cur)
  rx1252_restart:
.annotate 'line', 10
    if_null rx1252_debug, debug_1083
    rx1252_cur."!cursor_debug"("NEXT", "circumfix:sym<ang>")
  debug_1083:
  rx1252_fail:
    (rx1252_rep, rx1252_pos, $I10, $P10) = rx1252_cur."!mark_fail"(0)
    lt rx1252_pos, -1, rx1252_done
    eq rx1252_pos, -1, rx1252_fail
    jump $I10
  rx1252_done:
    rx1252_cur."!cursor_fail"()
    if_null rx1252_debug, debug_1084
    rx1252_cur."!cursor_debug"("FAIL", "circumfix:sym<ang>")
  debug_1084:
    .return (rx1252_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<ang>"  :nsentry("!PREFIX__circumfix:sym<ang>") :subid("262_1302110486.758") :method
.annotate 'line', 10
    new $P1254, "ResizablePMCArray"
    push $P1254, "<"
    .return ($P1254)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("263_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1257_tgt
    .local int rx1257_pos
    .local int rx1257_off
    .local int rx1257_eos
    .local int rx1257_rep
    .local pmc rx1257_cur
    .local pmc rx1257_debug
    (rx1257_cur, rx1257_pos, rx1257_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1257_cur
    .local pmc match
    .lex "$/", match
    length rx1257_eos, rx1257_tgt
    gt rx1257_pos, rx1257_eos, rx1257_done
    set rx1257_off, 0
    lt rx1257_pos, 2, rx1257_start
    sub rx1257_off, rx1257_pos, 1
    substr rx1257_tgt, rx1257_tgt, rx1257_off
  rx1257_start:
    eq $I10, 1, rx1257_restart
    if_null rx1257_debug, debug_1085
    rx1257_cur."!cursor_debug"("START", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1085:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1260_done
    goto rxscan1260_scan
  rxscan1260_loop:
    (rx1257_pos) = rx1257_cur."from"()
    inc rx1257_pos
    rx1257_cur."!cursor_from"(rx1257_pos)
    ge rx1257_pos, rx1257_eos, rxscan1260_done
  rxscan1260_scan:
    set_addr $I10, rxscan1260_loop
    rx1257_cur."!mark_push"(0, rx1257_pos, $I10)
  rxscan1260_done:
.annotate 'line', 570
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1257_pos, rx1257_off
    substr $S10, rx1257_tgt, $I10, 1
    index $I11, unicode:"\x{ab}", $S10
    lt $I11, 0, rx1257_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1257_cur."!cursor_pos"(rx1257_pos)
    $P10 = rx1257_cur."quote_EXPR"(":qq", ":w")
    unless $P10, rx1257_fail
    rx1257_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1257_pos = $P10."pos"()
  # rx pass
    rx1257_cur."!cursor_pass"(rx1257_pos, unicode:"circumfix:sym<\x{ab} \x{bb}>")
    if_null rx1257_debug, debug_1086
    rx1257_cur."!cursor_debug"("PASS", unicode:"circumfix:sym<\x{ab} \x{bb}>", " at pos=", rx1257_pos)
  debug_1086:
    .return (rx1257_cur)
  rx1257_restart:
.annotate 'line', 10
    if_null rx1257_debug, debug_1087
    rx1257_cur."!cursor_debug"("NEXT", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1087:
  rx1257_fail:
    (rx1257_rep, rx1257_pos, $I10, $P10) = rx1257_cur."!mark_fail"(0)
    lt rx1257_pos, -1, rx1257_done
    eq rx1257_pos, -1, rx1257_fail
    jump $I10
  rx1257_done:
    rx1257_cur."!cursor_fail"()
    if_null rx1257_debug, debug_1088
    rx1257_cur."!cursor_debug"("FAIL", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1088:
    .return (rx1257_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"  :nsentry(unicode:"!PREFIX__circumfix:sym<\\x{ab} \\x{bb}>") :subid("264_1302110486.758") :method
.annotate 'line', 10
    new $P1259, "ResizablePMCArray"
    push $P1259, unicode:"\x{ab}"
    .return ($P1259)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<{ }>"  :subid("265_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1262_tgt
    .local int rx1262_pos
    .local int rx1262_off
    .local int rx1262_eos
    .local int rx1262_rep
    .local pmc rx1262_cur
    .local pmc rx1262_debug
    (rx1262_cur, rx1262_pos, rx1262_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1262_cur
    .local pmc match
    .lex "$/", match
    length rx1262_eos, rx1262_tgt
    gt rx1262_pos, rx1262_eos, rx1262_done
    set rx1262_off, 0
    lt rx1262_pos, 2, rx1262_start
    sub rx1262_off, rx1262_pos, 1
    substr rx1262_tgt, rx1262_tgt, rx1262_off
  rx1262_start:
    eq $I10, 1, rx1262_restart
    if_null rx1262_debug, debug_1089
    rx1262_cur."!cursor_debug"("START", "circumfix:sym<{ }>")
  debug_1089:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1265_done
    goto rxscan1265_scan
  rxscan1265_loop:
    (rx1262_pos) = rx1262_cur."from"()
    inc rx1262_pos
    rx1262_cur."!cursor_from"(rx1262_pos)
    ge rx1262_pos, rx1262_eos, rxscan1265_done
  rxscan1265_scan:
    set_addr $I10, rxscan1265_loop
    rx1262_cur."!mark_push"(0, rx1262_pos, $I10)
  rxscan1265_done:
.annotate 'line', 571
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1262_pos, rx1262_off
    substr $S10, rx1262_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1262_fail
  # rx subrule "pblock" subtype=capture negate=
    rx1262_cur."!cursor_pos"(rx1262_pos)
    $P10 = rx1262_cur."pblock"()
    unless $P10, rx1262_fail
    rx1262_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx1262_pos = $P10."pos"()
  # rx pass
    rx1262_cur."!cursor_pass"(rx1262_pos, "circumfix:sym<{ }>")
    if_null rx1262_debug, debug_1090
    rx1262_cur."!cursor_debug"("PASS", "circumfix:sym<{ }>", " at pos=", rx1262_pos)
  debug_1090:
    .return (rx1262_cur)
  rx1262_restart:
.annotate 'line', 10
    if_null rx1262_debug, debug_1091
    rx1262_cur."!cursor_debug"("NEXT", "circumfix:sym<{ }>")
  debug_1091:
  rx1262_fail:
    (rx1262_rep, rx1262_pos, $I10, $P10) = rx1262_cur."!mark_fail"(0)
    lt rx1262_pos, -1, rx1262_done
    eq rx1262_pos, -1, rx1262_fail
    jump $I10
  rx1262_done:
    rx1262_cur."!cursor_fail"()
    if_null rx1262_debug, debug_1092
    rx1262_cur."!cursor_debug"("FAIL", "circumfix:sym<{ }>")
  debug_1092:
    .return (rx1262_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<{ }>"  :nsentry("!PREFIX__circumfix:sym<{ }>") :subid("266_1302110486.758") :method
.annotate 'line', 10
    new $P1264, "ResizablePMCArray"
    push $P1264, "{"
    .return ($P1264)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<sigil>"  :subid("267_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1267_tgt
    .local int rx1267_pos
    .local int rx1267_off
    .local int rx1267_eos
    .local int rx1267_rep
    .local pmc rx1267_cur
    .local pmc rx1267_debug
    (rx1267_cur, rx1267_pos, rx1267_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1267_cur
    .local pmc match
    .lex "$/", match
    length rx1267_eos, rx1267_tgt
    gt rx1267_pos, rx1267_eos, rx1267_done
    set rx1267_off, 0
    lt rx1267_pos, 2, rx1267_start
    sub rx1267_off, rx1267_pos, 1
    substr rx1267_tgt, rx1267_tgt, rx1267_off
  rx1267_start:
    eq $I10, 1, rx1267_restart
    if_null rx1267_debug, debug_1093
    rx1267_cur."!cursor_debug"("START", "circumfix:sym<sigil>")
  debug_1093:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1271_done
    goto rxscan1271_scan
  rxscan1271_loop:
    (rx1267_pos) = rx1267_cur."from"()
    inc rx1267_pos
    rx1267_cur."!cursor_from"(rx1267_pos)
    ge rx1267_pos, rx1267_eos, rxscan1271_done
  rxscan1271_scan:
    set_addr $I10, rxscan1271_loop
    rx1267_cur."!mark_push"(0, rx1267_pos, $I10)
  rxscan1271_done:
.annotate 'line', 572
  # rx subrule "sigil" subtype=capture negate=
    rx1267_cur."!cursor_pos"(rx1267_pos)
    $P10 = rx1267_cur."sigil"()
    unless $P10, rx1267_fail
    rx1267_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1267_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1267_pos, 1
    gt $I11, rx1267_eos, rx1267_fail
    sub $I11, rx1267_pos, rx1267_off
    ord $I11, rx1267_tgt, $I11
    ne $I11, 40, rx1267_fail
    add rx1267_pos, 1
  # rx subrule "semilist" subtype=capture negate=
    rx1267_cur."!cursor_pos"(rx1267_pos)
    $P10 = rx1267_cur."semilist"()
    unless $P10, rx1267_fail
    rx1267_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("semilist")
    rx1267_pos = $P10."pos"()
  alt1272_0:
    set_addr $I10, alt1272_1
    rx1267_cur."!mark_push"(0, rx1267_pos, $I10)
  # rx literal  ")"
    add $I11, rx1267_pos, 1
    gt $I11, rx1267_eos, rx1267_fail
    sub $I11, rx1267_pos, rx1267_off
    ord $I11, rx1267_tgt, $I11
    ne $I11, 41, rx1267_fail
    add rx1267_pos, 1
    goto alt1272_end
  alt1272_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx1267_cur."!cursor_pos"(rx1267_pos)
    $P10 = rx1267_cur."FAILGOAL"("')'")
    unless $P10, rx1267_fail
    goto rxsubrule1274_pass
  rxsubrule1274_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1267_fail
  rxsubrule1274_pass:
    set_addr $I10, rxsubrule1274_back
    rx1267_cur."!mark_push"(0, rx1267_pos, $I10, $P10)
    rx1267_pos = $P10."pos"()
  alt1272_end:
  # rx pass
    rx1267_cur."!cursor_pass"(rx1267_pos, "circumfix:sym<sigil>")
    if_null rx1267_debug, debug_1094
    rx1267_cur."!cursor_debug"("PASS", "circumfix:sym<sigil>", " at pos=", rx1267_pos)
  debug_1094:
    .return (rx1267_cur)
  rx1267_restart:
.annotate 'line', 10
    if_null rx1267_debug, debug_1095
    rx1267_cur."!cursor_debug"("NEXT", "circumfix:sym<sigil>")
  debug_1095:
  rx1267_fail:
    (rx1267_rep, rx1267_pos, $I10, $P10) = rx1267_cur."!mark_fail"(0)
    lt rx1267_pos, -1, rx1267_done
    eq rx1267_pos, -1, rx1267_fail
    jump $I10
  rx1267_done:
    rx1267_cur."!cursor_fail"()
    if_null rx1267_debug, debug_1096
    rx1267_cur."!cursor_debug"("FAIL", "circumfix:sym<sigil>")
  debug_1096:
    .return (rx1267_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<sigil>"  :nsentry("!PREFIX__circumfix:sym<sigil>") :subid("268_1302110486.758") :method
.annotate 'line', 10
    $P1269 = self."!PREFIX__!subrule"("sigil", "")
    new $P1270, "ResizablePMCArray"
    push $P1270, $P1269
    .return ($P1270)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "semilist"  :subid("269_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1276_tgt
    .local int rx1276_pos
    .local int rx1276_off
    .local int rx1276_eos
    .local int rx1276_rep
    .local pmc rx1276_cur
    .local pmc rx1276_debug
    (rx1276_cur, rx1276_pos, rx1276_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1276_cur
    .local pmc match
    .lex "$/", match
    length rx1276_eos, rx1276_tgt
    gt rx1276_pos, rx1276_eos, rx1276_done
    set rx1276_off, 0
    lt rx1276_pos, 2, rx1276_start
    sub rx1276_off, rx1276_pos, 1
    substr rx1276_tgt, rx1276_tgt, rx1276_off
  rx1276_start:
    eq $I10, 1, rx1276_restart
    if_null rx1276_debug, debug_1097
    rx1276_cur."!cursor_debug"("START", "semilist")
  debug_1097:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1280_done
    goto rxscan1280_scan
  rxscan1280_loop:
    (rx1276_pos) = rx1276_cur."from"()
    inc rx1276_pos
    rx1276_cur."!cursor_from"(rx1276_pos)
    ge rx1276_pos, rx1276_eos, rxscan1280_done
  rxscan1280_scan:
    set_addr $I10, rxscan1280_loop
    rx1276_cur."!mark_push"(0, rx1276_pos, $I10)
  rxscan1280_done:
.annotate 'line', 574
  # rx subrule "ws" subtype=method negate=
    rx1276_cur."!cursor_pos"(rx1276_pos)
    $P10 = rx1276_cur."ws"()
    unless $P10, rx1276_fail
    rx1276_pos = $P10."pos"()
  # rx subrule "statement" subtype=capture negate=
    rx1276_cur."!cursor_pos"(rx1276_pos)
    $P10 = rx1276_cur."statement"()
    unless $P10, rx1276_fail
    rx1276_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx1276_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1276_cur."!cursor_pos"(rx1276_pos)
    $P10 = rx1276_cur."ws"()
    unless $P10, rx1276_fail
    rx1276_pos = $P10."pos"()
  # rx pass
    rx1276_cur."!cursor_pass"(rx1276_pos, "semilist")
    if_null rx1276_debug, debug_1098
    rx1276_cur."!cursor_debug"("PASS", "semilist", " at pos=", rx1276_pos)
  debug_1098:
    .return (rx1276_cur)
  rx1276_restart:
.annotate 'line', 10
    if_null rx1276_debug, debug_1099
    rx1276_cur."!cursor_debug"("NEXT", "semilist")
  debug_1099:
  rx1276_fail:
    (rx1276_rep, rx1276_pos, $I10, $P10) = rx1276_cur."!mark_fail"(0)
    lt rx1276_pos, -1, rx1276_done
    eq rx1276_pos, -1, rx1276_fail
    jump $I10
  rx1276_done:
    rx1276_cur."!cursor_fail"()
    if_null rx1276_debug, debug_1100
    rx1276_cur."!cursor_debug"("FAIL", "semilist")
  debug_1100:
    .return (rx1276_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__semilist"  :nsentry("!PREFIX__semilist") :subid("270_1302110486.758") :method
.annotate 'line', 10
    $P1278 = self."!PREFIX__!subrule"("ws", "")
    new $P1279, "ResizablePMCArray"
    push $P1279, $P1278
    .return ($P1279)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1283"  :anon :subid("271_1302110486.758") :outer("12_1302110486.758")
.annotate 'line', 10
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "" :load :init :subid("post1101") :outer("271_1302110486.758")
.annotate 'line', 10
    .const 'Sub' $P1284 = "271_1302110486.758" 
    .local pmc block
    set block, $P1284
.annotate 'line', 579
    get_hll_global $P1285, ["NQP"], "Grammar"
    $P1285."O"(":prec<y=>, :assoc<unary>", "%methodop")
.annotate 'line', 580
    get_hll_global $P1286, ["NQP"], "Grammar"
    $P1286."O"(":prec<x=>, :assoc<unary>", "%autoincrement")
.annotate 'line', 581
    get_hll_global $P1287, ["NQP"], "Grammar"
    $P1287."O"(":prec<w=>, :assoc<left>", "%exponentiation")
.annotate 'line', 582
    get_hll_global $P1288, ["NQP"], "Grammar"
    $P1288."O"(":prec<v=>, :assoc<unary>", "%symbolic_unary")
.annotate 'line', 583
    get_hll_global $P1289, ["NQP"], "Grammar"
    $P1289."O"(":prec<u=>, :assoc<left>", "%multiplicative")
.annotate 'line', 584
    get_hll_global $P1290, ["NQP"], "Grammar"
    $P1290."O"(":prec<t=>, :assoc<left>", "%additive")
.annotate 'line', 585
    get_hll_global $P1291, ["NQP"], "Grammar"
    $P1291."O"(":prec<r=>, :assoc<left>", "%concatenation")
.annotate 'line', 586
    get_hll_global $P1292, ["NQP"], "Grammar"
    $P1292."O"(":prec<m=>, :assoc<left>", "%relational")
.annotate 'line', 587
    get_hll_global $P1293, ["NQP"], "Grammar"
    $P1293."O"(":prec<l=>, :assoc<left>", "%tight_and")
.annotate 'line', 588
    get_hll_global $P1294, ["NQP"], "Grammar"
    $P1294."O"(":prec<k=>, :assoc<left>", "%tight_or")
.annotate 'line', 589
    get_hll_global $P1295, ["NQP"], "Grammar"
    $P1295."O"(":prec<j=>, :assoc<right>", "%conditional")
.annotate 'line', 590
    get_hll_global $P1296, ["NQP"], "Grammar"
    $P1296."O"(":prec<i=>, :assoc<right>", "%assignment")
.annotate 'line', 591
    get_hll_global $P1297, ["NQP"], "Grammar"
    $P1297."O"(":prec<g=>, :assoc<list>, :nextterm<nulltermish>", "%comma")
.annotate 'line', 592
    get_hll_global $P1298, ["NQP"], "Grammar"
    $P1298."O"(":prec<f=>, :assoc<list>", "%list_infix")
.annotate 'line', 593
    get_hll_global $P1299, ["NQP"], "Grammar"
    $P1299."O"(":prec<e=>, :assoc<unary>", "%list_prefix")
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixish"  :subid("272_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1301_tgt
    .local int rx1301_pos
    .local int rx1301_off
    .local int rx1301_eos
    .local int rx1301_rep
    .local pmc rx1301_cur
    .local pmc rx1301_debug
    (rx1301_cur, rx1301_pos, rx1301_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1301_cur
    .local pmc match
    .lex "$/", match
    length rx1301_eos, rx1301_tgt
    gt rx1301_pos, rx1301_eos, rx1301_done
    set rx1301_off, 0
    lt rx1301_pos, 2, rx1301_start
    sub rx1301_off, rx1301_pos, 1
    substr rx1301_tgt, rx1301_tgt, rx1301_off
  rx1301_start:
    eq $I10, 1, rx1301_restart
    if_null rx1301_debug, debug_1102
    rx1301_cur."!cursor_debug"("START", "infixish")
  debug_1102:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1304_done
    goto rxscan1304_scan
  rxscan1304_loop:
    (rx1301_pos) = rx1301_cur."from"()
    inc rx1301_pos
    rx1301_cur."!cursor_from"(rx1301_pos)
    ge rx1301_pos, rx1301_eos, rxscan1304_done
  rxscan1304_scan:
    set_addr $I10, rxscan1304_loop
    rx1301_cur."!mark_push"(0, rx1301_pos, $I10)
  rxscan1304_done:
.annotate 'line', 597
  # rx subrule "infixstopper" subtype=zerowidth negate=1
    rx1301_cur."!cursor_pos"(rx1301_pos)
    $P10 = rx1301_cur."infixstopper"()
    if $P10, rx1301_fail
  # rx subrule "infix" subtype=capture negate=
    rx1301_cur."!cursor_pos"(rx1301_pos)
    $P10 = rx1301_cur."infix"()
    unless $P10, rx1301_fail
    rx1301_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("OPER=infix")
    rx1301_pos = $P10."pos"()
  # rx pass
    rx1301_cur."!cursor_pass"(rx1301_pos, "infixish")
    if_null rx1301_debug, debug_1103
    rx1301_cur."!cursor_debug"("PASS", "infixish", " at pos=", rx1301_pos)
  debug_1103:
    .return (rx1301_cur)
  rx1301_restart:
.annotate 'line', 10
    if_null rx1301_debug, debug_1104
    rx1301_cur."!cursor_debug"("NEXT", "infixish")
  debug_1104:
  rx1301_fail:
    (rx1301_rep, rx1301_pos, $I10, $P10) = rx1301_cur."!mark_fail"(0)
    lt rx1301_pos, -1, rx1301_done
    eq rx1301_pos, -1, rx1301_fail
    jump $I10
  rx1301_done:
    rx1301_cur."!cursor_fail"()
    if_null rx1301_debug, debug_1105
    rx1301_cur."!cursor_debug"("FAIL", "infixish")
  debug_1105:
    .return (rx1301_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixish"  :nsentry("!PREFIX__infixish") :subid("273_1302110486.758") :method
.annotate 'line', 10
    new $P1303, "ResizablePMCArray"
    push $P1303, ""
    .return ($P1303)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixstopper"  :subid("274_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1306_tgt
    .local int rx1306_pos
    .local int rx1306_off
    .local int rx1306_eos
    .local int rx1306_rep
    .local pmc rx1306_cur
    .local pmc rx1306_debug
    (rx1306_cur, rx1306_pos, rx1306_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1306_cur
    .local pmc match
    .lex "$/", match
    length rx1306_eos, rx1306_tgt
    gt rx1306_pos, rx1306_eos, rx1306_done
    set rx1306_off, 0
    lt rx1306_pos, 2, rx1306_start
    sub rx1306_off, rx1306_pos, 1
    substr rx1306_tgt, rx1306_tgt, rx1306_off
  rx1306_start:
    eq $I10, 1, rx1306_restart
    if_null rx1306_debug, debug_1106
    rx1306_cur."!cursor_debug"("START", "infixstopper")
  debug_1106:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1309_done
    goto rxscan1309_scan
  rxscan1309_loop:
    (rx1306_pos) = rx1306_cur."from"()
    inc rx1306_pos
    rx1306_cur."!cursor_from"(rx1306_pos)
    ge rx1306_pos, rx1306_eos, rxscan1309_done
  rxscan1309_scan:
    set_addr $I10, rxscan1309_loop
    rx1306_cur."!mark_push"(0, rx1306_pos, $I10)
  rxscan1309_done:
.annotate 'line', 598
  # rx subrule "lambda" subtype=zerowidth negate=
    rx1306_cur."!cursor_pos"(rx1306_pos)
    $P10 = rx1306_cur."lambda"()
    unless $P10, rx1306_fail
  # rx pass
    rx1306_cur."!cursor_pass"(rx1306_pos, "infixstopper")
    if_null rx1306_debug, debug_1107
    rx1306_cur."!cursor_debug"("PASS", "infixstopper", " at pos=", rx1306_pos)
  debug_1107:
    .return (rx1306_cur)
  rx1306_restart:
.annotate 'line', 10
    if_null rx1306_debug, debug_1108
    rx1306_cur."!cursor_debug"("NEXT", "infixstopper")
  debug_1108:
  rx1306_fail:
    (rx1306_rep, rx1306_pos, $I10, $P10) = rx1306_cur."!mark_fail"(0)
    lt rx1306_pos, -1, rx1306_done
    eq rx1306_pos, -1, rx1306_fail
    jump $I10
  rx1306_done:
    rx1306_cur."!cursor_fail"()
    if_null rx1306_debug, debug_1109
    rx1306_cur."!cursor_debug"("FAIL", "infixstopper")
  debug_1109:
    .return (rx1306_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixstopper"  :nsentry("!PREFIX__infixstopper") :subid("275_1302110486.758") :method
.annotate 'line', 10
    new $P1308, "ResizablePMCArray"
    push $P1308, ""
    .return ($P1308)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<[ ]>"  :subid("276_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1311_tgt
    .local int rx1311_pos
    .local int rx1311_off
    .local int rx1311_eos
    .local int rx1311_rep
    .local pmc rx1311_cur
    .local pmc rx1311_debug
    (rx1311_cur, rx1311_pos, rx1311_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1311_cur
    .local pmc match
    .lex "$/", match
    length rx1311_eos, rx1311_tgt
    gt rx1311_pos, rx1311_eos, rx1311_done
    set rx1311_off, 0
    lt rx1311_pos, 2, rx1311_start
    sub rx1311_off, rx1311_pos, 1
    substr rx1311_tgt, rx1311_tgt, rx1311_off
  rx1311_start:
    eq $I10, 1, rx1311_restart
    if_null rx1311_debug, debug_1110
    rx1311_cur."!cursor_debug"("START", "postcircumfix:sym<[ ]>")
  debug_1110:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1315_done
    goto rxscan1315_scan
  rxscan1315_loop:
    (rx1311_pos) = rx1311_cur."from"()
    inc rx1311_pos
    rx1311_cur."!cursor_from"(rx1311_pos)
    ge rx1311_pos, rx1311_eos, rxscan1315_done
  rxscan1315_scan:
    set_addr $I10, rxscan1315_loop
    rx1311_cur."!mark_push"(0, rx1311_pos, $I10)
  rxscan1315_done:
.annotate 'line', 601
  # rx literal  "["
    add $I11, rx1311_pos, 1
    gt $I11, rx1311_eos, rx1311_fail
    sub $I11, rx1311_pos, rx1311_off
    ord $I11, rx1311_tgt, $I11
    ne $I11, 91, rx1311_fail
    add rx1311_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1311_cur."!cursor_pos"(rx1311_pos)
    $P10 = rx1311_cur."ws"()
    unless $P10, rx1311_fail
    rx1311_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1311_cur."!cursor_pos"(rx1311_pos)
    $P10 = rx1311_cur."EXPR"()
    unless $P10, rx1311_fail
    rx1311_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1311_pos = $P10."pos"()
  # rx literal  "]"
    add $I11, rx1311_pos, 1
    gt $I11, rx1311_eos, rx1311_fail
    sub $I11, rx1311_pos, rx1311_off
    ord $I11, rx1311_tgt, $I11
    ne $I11, 93, rx1311_fail
    add rx1311_pos, 1
.annotate 'line', 602
  # rx subrule "O" subtype=capture negate=
    rx1311_cur."!cursor_pos"(rx1311_pos)
    $P10 = rx1311_cur."O"("%methodop")
    unless $P10, rx1311_fail
    rx1311_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1311_pos = $P10."pos"()
.annotate 'line', 600
  # rx pass
    rx1311_cur."!cursor_pass"(rx1311_pos, "postcircumfix:sym<[ ]>")
    if_null rx1311_debug, debug_1111
    rx1311_cur."!cursor_debug"("PASS", "postcircumfix:sym<[ ]>", " at pos=", rx1311_pos)
  debug_1111:
    .return (rx1311_cur)
  rx1311_restart:
.annotate 'line', 10
    if_null rx1311_debug, debug_1112
    rx1311_cur."!cursor_debug"("NEXT", "postcircumfix:sym<[ ]>")
  debug_1112:
  rx1311_fail:
    (rx1311_rep, rx1311_pos, $I10, $P10) = rx1311_cur."!mark_fail"(0)
    lt rx1311_pos, -1, rx1311_done
    eq rx1311_pos, -1, rx1311_fail
    jump $I10
  rx1311_done:
    rx1311_cur."!cursor_fail"()
    if_null rx1311_debug, debug_1113
    rx1311_cur."!cursor_debug"("FAIL", "postcircumfix:sym<[ ]>")
  debug_1113:
    .return (rx1311_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<[ ]>"  :nsentry("!PREFIX__postcircumfix:sym<[ ]>") :subid("277_1302110486.758") :method
.annotate 'line', 10
    $P1313 = self."!PREFIX__!subrule"("ws", "[")
    new $P1314, "ResizablePMCArray"
    push $P1314, $P1313
    .return ($P1314)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<{ }>"  :subid("278_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1317_tgt
    .local int rx1317_pos
    .local int rx1317_off
    .local int rx1317_eos
    .local int rx1317_rep
    .local pmc rx1317_cur
    .local pmc rx1317_debug
    (rx1317_cur, rx1317_pos, rx1317_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1317_cur
    .local pmc match
    .lex "$/", match
    length rx1317_eos, rx1317_tgt
    gt rx1317_pos, rx1317_eos, rx1317_done
    set rx1317_off, 0
    lt rx1317_pos, 2, rx1317_start
    sub rx1317_off, rx1317_pos, 1
    substr rx1317_tgt, rx1317_tgt, rx1317_off
  rx1317_start:
    eq $I10, 1, rx1317_restart
    if_null rx1317_debug, debug_1114
    rx1317_cur."!cursor_debug"("START", "postcircumfix:sym<{ }>")
  debug_1114:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1321_done
    goto rxscan1321_scan
  rxscan1321_loop:
    (rx1317_pos) = rx1317_cur."from"()
    inc rx1317_pos
    rx1317_cur."!cursor_from"(rx1317_pos)
    ge rx1317_pos, rx1317_eos, rxscan1321_done
  rxscan1321_scan:
    set_addr $I10, rxscan1321_loop
    rx1317_cur."!mark_push"(0, rx1317_pos, $I10)
  rxscan1321_done:
.annotate 'line', 606
  # rx literal  "{"
    add $I11, rx1317_pos, 1
    gt $I11, rx1317_eos, rx1317_fail
    sub $I11, rx1317_pos, rx1317_off
    ord $I11, rx1317_tgt, $I11
    ne $I11, 123, rx1317_fail
    add rx1317_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1317_cur."!cursor_pos"(rx1317_pos)
    $P10 = rx1317_cur."ws"()
    unless $P10, rx1317_fail
    rx1317_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1317_cur."!cursor_pos"(rx1317_pos)
    $P10 = rx1317_cur."EXPR"()
    unless $P10, rx1317_fail
    rx1317_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1317_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1317_pos, 1
    gt $I11, rx1317_eos, rx1317_fail
    sub $I11, rx1317_pos, rx1317_off
    ord $I11, rx1317_tgt, $I11
    ne $I11, 125, rx1317_fail
    add rx1317_pos, 1
.annotate 'line', 607
  # rx subrule "O" subtype=capture negate=
    rx1317_cur."!cursor_pos"(rx1317_pos)
    $P10 = rx1317_cur."O"("%methodop")
    unless $P10, rx1317_fail
    rx1317_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1317_pos = $P10."pos"()
.annotate 'line', 605
  # rx pass
    rx1317_cur."!cursor_pass"(rx1317_pos, "postcircumfix:sym<{ }>")
    if_null rx1317_debug, debug_1115
    rx1317_cur."!cursor_debug"("PASS", "postcircumfix:sym<{ }>", " at pos=", rx1317_pos)
  debug_1115:
    .return (rx1317_cur)
  rx1317_restart:
.annotate 'line', 10
    if_null rx1317_debug, debug_1116
    rx1317_cur."!cursor_debug"("NEXT", "postcircumfix:sym<{ }>")
  debug_1116:
  rx1317_fail:
    (rx1317_rep, rx1317_pos, $I10, $P10) = rx1317_cur."!mark_fail"(0)
    lt rx1317_pos, -1, rx1317_done
    eq rx1317_pos, -1, rx1317_fail
    jump $I10
  rx1317_done:
    rx1317_cur."!cursor_fail"()
    if_null rx1317_debug, debug_1117
    rx1317_cur."!cursor_debug"("FAIL", "postcircumfix:sym<{ }>")
  debug_1117:
    .return (rx1317_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<{ }>"  :nsentry("!PREFIX__postcircumfix:sym<{ }>") :subid("279_1302110486.758") :method
.annotate 'line', 10
    $P1319 = self."!PREFIX__!subrule"("ws", "{")
    new $P1320, "ResizablePMCArray"
    push $P1320, $P1319
    .return ($P1320)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<ang>"  :subid("280_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1323_tgt
    .local int rx1323_pos
    .local int rx1323_off
    .local int rx1323_eos
    .local int rx1323_rep
    .local pmc rx1323_cur
    .local pmc rx1323_debug
    (rx1323_cur, rx1323_pos, rx1323_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1323_cur
    .local pmc match
    .lex "$/", match
    length rx1323_eos, rx1323_tgt
    gt rx1323_pos, rx1323_eos, rx1323_done
    set rx1323_off, 0
    lt rx1323_pos, 2, rx1323_start
    sub rx1323_off, rx1323_pos, 1
    substr rx1323_tgt, rx1323_tgt, rx1323_off
  rx1323_start:
    eq $I10, 1, rx1323_restart
    if_null rx1323_debug, debug_1118
    rx1323_cur."!cursor_debug"("START", "postcircumfix:sym<ang>")
  debug_1118:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1326_done
    goto rxscan1326_scan
  rxscan1326_loop:
    (rx1323_pos) = rx1323_cur."from"()
    inc rx1323_pos
    rx1323_cur."!cursor_from"(rx1323_pos)
    ge rx1323_pos, rx1323_eos, rxscan1326_done
  rxscan1326_scan:
    set_addr $I10, rxscan1326_loop
    rx1323_cur."!mark_push"(0, rx1323_pos, $I10)
  rxscan1326_done:
.annotate 'line', 611
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1323_pos, rx1323_off
    substr $S10, rx1323_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx1323_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1323_cur."!cursor_pos"(rx1323_pos)
    $P10 = rx1323_cur."quote_EXPR"(":q")
    unless $P10, rx1323_fail
    rx1323_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1323_pos = $P10."pos"()
.annotate 'line', 612
  # rx subrule "O" subtype=capture negate=
    rx1323_cur."!cursor_pos"(rx1323_pos)
    $P10 = rx1323_cur."O"("%methodop")
    unless $P10, rx1323_fail
    rx1323_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1323_pos = $P10."pos"()
.annotate 'line', 610
  # rx pass
    rx1323_cur."!cursor_pass"(rx1323_pos, "postcircumfix:sym<ang>")
    if_null rx1323_debug, debug_1119
    rx1323_cur."!cursor_debug"("PASS", "postcircumfix:sym<ang>", " at pos=", rx1323_pos)
  debug_1119:
    .return (rx1323_cur)
  rx1323_restart:
.annotate 'line', 10
    if_null rx1323_debug, debug_1120
    rx1323_cur."!cursor_debug"("NEXT", "postcircumfix:sym<ang>")
  debug_1120:
  rx1323_fail:
    (rx1323_rep, rx1323_pos, $I10, $P10) = rx1323_cur."!mark_fail"(0)
    lt rx1323_pos, -1, rx1323_done
    eq rx1323_pos, -1, rx1323_fail
    jump $I10
  rx1323_done:
    rx1323_cur."!cursor_fail"()
    if_null rx1323_debug, debug_1121
    rx1323_cur."!cursor_debug"("FAIL", "postcircumfix:sym<ang>")
  debug_1121:
    .return (rx1323_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<ang>"  :nsentry("!PREFIX__postcircumfix:sym<ang>") :subid("281_1302110486.758") :method
.annotate 'line', 10
    new $P1325, "ResizablePMCArray"
    push $P1325, "<"
    .return ($P1325)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<( )>"  :subid("282_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1328_tgt
    .local int rx1328_pos
    .local int rx1328_off
    .local int rx1328_eos
    .local int rx1328_rep
    .local pmc rx1328_cur
    .local pmc rx1328_debug
    (rx1328_cur, rx1328_pos, rx1328_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1328_cur
    .local pmc match
    .lex "$/", match
    length rx1328_eos, rx1328_tgt
    gt rx1328_pos, rx1328_eos, rx1328_done
    set rx1328_off, 0
    lt rx1328_pos, 2, rx1328_start
    sub rx1328_off, rx1328_pos, 1
    substr rx1328_tgt, rx1328_tgt, rx1328_off
  rx1328_start:
    eq $I10, 1, rx1328_restart
    if_null rx1328_debug, debug_1122
    rx1328_cur."!cursor_debug"("START", "postcircumfix:sym<( )>")
  debug_1122:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1332_done
    goto rxscan1332_scan
  rxscan1332_loop:
    (rx1328_pos) = rx1328_cur."from"()
    inc rx1328_pos
    rx1328_cur."!cursor_from"(rx1328_pos)
    ge rx1328_pos, rx1328_eos, rxscan1332_done
  rxscan1332_scan:
    set_addr $I10, rxscan1332_loop
    rx1328_cur."!mark_push"(0, rx1328_pos, $I10)
  rxscan1332_done:
.annotate 'line', 616
  # rx literal  "("
    add $I11, rx1328_pos, 1
    gt $I11, rx1328_eos, rx1328_fail
    sub $I11, rx1328_pos, rx1328_off
    ord $I11, rx1328_tgt, $I11
    ne $I11, 40, rx1328_fail
    add rx1328_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1328_cur."!cursor_pos"(rx1328_pos)
    $P10 = rx1328_cur."ws"()
    unless $P10, rx1328_fail
    rx1328_pos = $P10."pos"()
  # rx subrule "arglist" subtype=capture negate=
    rx1328_cur."!cursor_pos"(rx1328_pos)
    $P10 = rx1328_cur."arglist"()
    unless $P10, rx1328_fail
    rx1328_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1328_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1328_pos, 1
    gt $I11, rx1328_eos, rx1328_fail
    sub $I11, rx1328_pos, rx1328_off
    ord $I11, rx1328_tgt, $I11
    ne $I11, 41, rx1328_fail
    add rx1328_pos, 1
.annotate 'line', 617
  # rx subrule "O" subtype=capture negate=
    rx1328_cur."!cursor_pos"(rx1328_pos)
    $P10 = rx1328_cur."O"("%methodop")
    unless $P10, rx1328_fail
    rx1328_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1328_pos = $P10."pos"()
.annotate 'line', 615
  # rx pass
    rx1328_cur."!cursor_pass"(rx1328_pos, "postcircumfix:sym<( )>")
    if_null rx1328_debug, debug_1123
    rx1328_cur."!cursor_debug"("PASS", "postcircumfix:sym<( )>", " at pos=", rx1328_pos)
  debug_1123:
    .return (rx1328_cur)
  rx1328_restart:
.annotate 'line', 10
    if_null rx1328_debug, debug_1124
    rx1328_cur."!cursor_debug"("NEXT", "postcircumfix:sym<( )>")
  debug_1124:
  rx1328_fail:
    (rx1328_rep, rx1328_pos, $I10, $P10) = rx1328_cur."!mark_fail"(0)
    lt rx1328_pos, -1, rx1328_done
    eq rx1328_pos, -1, rx1328_fail
    jump $I10
  rx1328_done:
    rx1328_cur."!cursor_fail"()
    if_null rx1328_debug, debug_1125
    rx1328_cur."!cursor_debug"("FAIL", "postcircumfix:sym<( )>")
  debug_1125:
    .return (rx1328_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<( )>"  :nsentry("!PREFIX__postcircumfix:sym<( )>") :subid("283_1302110486.758") :method
.annotate 'line', 10
    $P1330 = self."!PREFIX__!subrule"("ws", "(")
    new $P1331, "ResizablePMCArray"
    push $P1331, $P1330
    .return ($P1331)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<.>"  :subid("284_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1334_tgt
    .local int rx1334_pos
    .local int rx1334_off
    .local int rx1334_eos
    .local int rx1334_rep
    .local pmc rx1334_cur
    .local pmc rx1334_debug
    (rx1334_cur, rx1334_pos, rx1334_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1334_cur
    .local pmc match
    .lex "$/", match
    length rx1334_eos, rx1334_tgt
    gt rx1334_pos, rx1334_eos, rx1334_done
    set rx1334_off, 0
    lt rx1334_pos, 2, rx1334_start
    sub rx1334_off, rx1334_pos, 1
    substr rx1334_tgt, rx1334_tgt, rx1334_off
  rx1334_start:
    eq $I10, 1, rx1334_restart
    if_null rx1334_debug, debug_1126
    rx1334_cur."!cursor_debug"("START", "postfix:sym<.>")
  debug_1126:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1338_done
    goto rxscan1338_scan
  rxscan1338_loop:
    (rx1334_pos) = rx1334_cur."from"()
    inc rx1334_pos
    rx1334_cur."!cursor_from"(rx1334_pos)
    ge rx1334_pos, rx1334_eos, rxscan1338_done
  rxscan1338_scan:
    set_addr $I10, rxscan1338_loop
    rx1334_cur."!mark_push"(0, rx1334_pos, $I10)
  rxscan1338_done:
.annotate 'line', 620
  # rx subrule "dotty" subtype=capture negate=
    rx1334_cur."!cursor_pos"(rx1334_pos)
    $P10 = rx1334_cur."dotty"()
    unless $P10, rx1334_fail
    rx1334_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dotty")
    rx1334_pos = $P10."pos"()
  # rx subrule "O" subtype=capture negate=
    rx1334_cur."!cursor_pos"(rx1334_pos)
    $P10 = rx1334_cur."O"("%methodop")
    unless $P10, rx1334_fail
    rx1334_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1334_pos = $P10."pos"()
  # rx pass
    rx1334_cur."!cursor_pass"(rx1334_pos, "postfix:sym<.>")
    if_null rx1334_debug, debug_1127
    rx1334_cur."!cursor_debug"("PASS", "postfix:sym<.>", " at pos=", rx1334_pos)
  debug_1127:
    .return (rx1334_cur)
  rx1334_restart:
.annotate 'line', 10
    if_null rx1334_debug, debug_1128
    rx1334_cur."!cursor_debug"("NEXT", "postfix:sym<.>")
  debug_1128:
  rx1334_fail:
    (rx1334_rep, rx1334_pos, $I10, $P10) = rx1334_cur."!mark_fail"(0)
    lt rx1334_pos, -1, rx1334_done
    eq rx1334_pos, -1, rx1334_fail
    jump $I10
  rx1334_done:
    rx1334_cur."!cursor_fail"()
    if_null rx1334_debug, debug_1129
    rx1334_cur."!cursor_debug"("FAIL", "postfix:sym<.>")
  debug_1129:
    .return (rx1334_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<.>"  :nsentry("!PREFIX__postfix:sym<.>") :subid("285_1302110486.758") :method
.annotate 'line', 10
    $P1336 = self."!PREFIX__!subrule"("dotty", "")
    new $P1337, "ResizablePMCArray"
    push $P1337, $P1336
    .return ($P1337)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<++>"  :subid("286_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1340_tgt
    .local int rx1340_pos
    .local int rx1340_off
    .local int rx1340_eos
    .local int rx1340_rep
    .local pmc rx1340_cur
    .local pmc rx1340_debug
    (rx1340_cur, rx1340_pos, rx1340_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1340_cur
    .local pmc match
    .lex "$/", match
    length rx1340_eos, rx1340_tgt
    gt rx1340_pos, rx1340_eos, rx1340_done
    set rx1340_off, 0
    lt rx1340_pos, 2, rx1340_start
    sub rx1340_off, rx1340_pos, 1
    substr rx1340_tgt, rx1340_tgt, rx1340_off
  rx1340_start:
    eq $I10, 1, rx1340_restart
    if_null rx1340_debug, debug_1130
    rx1340_cur."!cursor_debug"("START", "prefix:sym<++>")
  debug_1130:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1344_done
    goto rxscan1344_scan
  rxscan1344_loop:
    (rx1340_pos) = rx1340_cur."from"()
    inc rx1340_pos
    rx1340_cur."!cursor_from"(rx1340_pos)
    ge rx1340_pos, rx1340_eos, rxscan1344_done
  rxscan1344_scan:
    set_addr $I10, rxscan1344_loop
    rx1340_cur."!mark_push"(0, rx1340_pos, $I10)
  rxscan1344_done:
.annotate 'line', 622
  # rx subcapture "sym"
    set_addr $I10, rxcap_1345_fail
    rx1340_cur."!mark_push"(0, rx1340_pos, $I10)
  # rx literal  "++"
    add $I11, rx1340_pos, 2
    gt $I11, rx1340_eos, rx1340_fail
    sub $I11, rx1340_pos, rx1340_off
    substr $S10, rx1340_tgt, $I11, 2
    ne $S10, "++", rx1340_fail
    add rx1340_pos, 2
    set_addr $I10, rxcap_1345_fail
    ($I12, $I11) = rx1340_cur."!mark_peek"($I10)
    rx1340_cur."!cursor_pos"($I11)
    ($P10) = rx1340_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1340_pos, "")
    rx1340_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1345_done
  rxcap_1345_fail:
    goto rx1340_fail
  rxcap_1345_done:
  # rx subrule "O" subtype=capture negate=
    rx1340_cur."!cursor_pos"(rx1340_pos)
    $P10 = rx1340_cur."O"("%autoincrement, :pirop<inc>")
    unless $P10, rx1340_fail
    rx1340_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1340_pos = $P10."pos"()
  # rx pass
    rx1340_cur."!cursor_pass"(rx1340_pos, "prefix:sym<++>")
    if_null rx1340_debug, debug_1131
    rx1340_cur."!cursor_debug"("PASS", "prefix:sym<++>", " at pos=", rx1340_pos)
  debug_1131:
    .return (rx1340_cur)
  rx1340_restart:
.annotate 'line', 10
    if_null rx1340_debug, debug_1132
    rx1340_cur."!cursor_debug"("NEXT", "prefix:sym<++>")
  debug_1132:
  rx1340_fail:
    (rx1340_rep, rx1340_pos, $I10, $P10) = rx1340_cur."!mark_fail"(0)
    lt rx1340_pos, -1, rx1340_done
    eq rx1340_pos, -1, rx1340_fail
    jump $I10
  rx1340_done:
    rx1340_cur."!cursor_fail"()
    if_null rx1340_debug, debug_1133
    rx1340_cur."!cursor_debug"("FAIL", "prefix:sym<++>")
  debug_1133:
    .return (rx1340_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<++>"  :nsentry("!PREFIX__prefix:sym<++>") :subid("287_1302110486.758") :method
.annotate 'line', 10
    $P1342 = self."!PREFIX__!subrule"("O", "++")
    new $P1343, "ResizablePMCArray"
    push $P1343, $P1342
    .return ($P1343)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<-->"  :subid("288_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1347_tgt
    .local int rx1347_pos
    .local int rx1347_off
    .local int rx1347_eos
    .local int rx1347_rep
    .local pmc rx1347_cur
    .local pmc rx1347_debug
    (rx1347_cur, rx1347_pos, rx1347_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1347_cur
    .local pmc match
    .lex "$/", match
    length rx1347_eos, rx1347_tgt
    gt rx1347_pos, rx1347_eos, rx1347_done
    set rx1347_off, 0
    lt rx1347_pos, 2, rx1347_start
    sub rx1347_off, rx1347_pos, 1
    substr rx1347_tgt, rx1347_tgt, rx1347_off
  rx1347_start:
    eq $I10, 1, rx1347_restart
    if_null rx1347_debug, debug_1134
    rx1347_cur."!cursor_debug"("START", "prefix:sym<-->")
  debug_1134:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1351_done
    goto rxscan1351_scan
  rxscan1351_loop:
    (rx1347_pos) = rx1347_cur."from"()
    inc rx1347_pos
    rx1347_cur."!cursor_from"(rx1347_pos)
    ge rx1347_pos, rx1347_eos, rxscan1351_done
  rxscan1351_scan:
    set_addr $I10, rxscan1351_loop
    rx1347_cur."!mark_push"(0, rx1347_pos, $I10)
  rxscan1351_done:
.annotate 'line', 623
  # rx subcapture "sym"
    set_addr $I10, rxcap_1352_fail
    rx1347_cur."!mark_push"(0, rx1347_pos, $I10)
  # rx literal  "--"
    add $I11, rx1347_pos, 2
    gt $I11, rx1347_eos, rx1347_fail
    sub $I11, rx1347_pos, rx1347_off
    substr $S10, rx1347_tgt, $I11, 2
    ne $S10, "--", rx1347_fail
    add rx1347_pos, 2
    set_addr $I10, rxcap_1352_fail
    ($I12, $I11) = rx1347_cur."!mark_peek"($I10)
    rx1347_cur."!cursor_pos"($I11)
    ($P10) = rx1347_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1347_pos, "")
    rx1347_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1352_done
  rxcap_1352_fail:
    goto rx1347_fail
  rxcap_1352_done:
  # rx subrule "O" subtype=capture negate=
    rx1347_cur."!cursor_pos"(rx1347_pos)
    $P10 = rx1347_cur."O"("%autoincrement, :pirop<dec>")
    unless $P10, rx1347_fail
    rx1347_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1347_pos = $P10."pos"()
  # rx pass
    rx1347_cur."!cursor_pass"(rx1347_pos, "prefix:sym<-->")
    if_null rx1347_debug, debug_1135
    rx1347_cur."!cursor_debug"("PASS", "prefix:sym<-->", " at pos=", rx1347_pos)
  debug_1135:
    .return (rx1347_cur)
  rx1347_restart:
.annotate 'line', 10
    if_null rx1347_debug, debug_1136
    rx1347_cur."!cursor_debug"("NEXT", "prefix:sym<-->")
  debug_1136:
  rx1347_fail:
    (rx1347_rep, rx1347_pos, $I10, $P10) = rx1347_cur."!mark_fail"(0)
    lt rx1347_pos, -1, rx1347_done
    eq rx1347_pos, -1, rx1347_fail
    jump $I10
  rx1347_done:
    rx1347_cur."!cursor_fail"()
    if_null rx1347_debug, debug_1137
    rx1347_cur."!cursor_debug"("FAIL", "prefix:sym<-->")
  debug_1137:
    .return (rx1347_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<-->"  :nsentry("!PREFIX__prefix:sym<-->") :subid("289_1302110486.758") :method
.annotate 'line', 10
    $P1349 = self."!PREFIX__!subrule"("O", "--")
    new $P1350, "ResizablePMCArray"
    push $P1350, $P1349
    .return ($P1350)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<++>"  :subid("290_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1354_tgt
    .local int rx1354_pos
    .local int rx1354_off
    .local int rx1354_eos
    .local int rx1354_rep
    .local pmc rx1354_cur
    .local pmc rx1354_debug
    (rx1354_cur, rx1354_pos, rx1354_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1354_cur
    .local pmc match
    .lex "$/", match
    length rx1354_eos, rx1354_tgt
    gt rx1354_pos, rx1354_eos, rx1354_done
    set rx1354_off, 0
    lt rx1354_pos, 2, rx1354_start
    sub rx1354_off, rx1354_pos, 1
    substr rx1354_tgt, rx1354_tgt, rx1354_off
  rx1354_start:
    eq $I10, 1, rx1354_restart
    if_null rx1354_debug, debug_1138
    rx1354_cur."!cursor_debug"("START", "postfix:sym<++>")
  debug_1138:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1358_done
    goto rxscan1358_scan
  rxscan1358_loop:
    (rx1354_pos) = rx1354_cur."from"()
    inc rx1354_pos
    rx1354_cur."!cursor_from"(rx1354_pos)
    ge rx1354_pos, rx1354_eos, rxscan1358_done
  rxscan1358_scan:
    set_addr $I10, rxscan1358_loop
    rx1354_cur."!mark_push"(0, rx1354_pos, $I10)
  rxscan1358_done:
.annotate 'line', 626
  # rx subcapture "sym"
    set_addr $I10, rxcap_1359_fail
    rx1354_cur."!mark_push"(0, rx1354_pos, $I10)
  # rx literal  "++"
    add $I11, rx1354_pos, 2
    gt $I11, rx1354_eos, rx1354_fail
    sub $I11, rx1354_pos, rx1354_off
    substr $S10, rx1354_tgt, $I11, 2
    ne $S10, "++", rx1354_fail
    add rx1354_pos, 2
    set_addr $I10, rxcap_1359_fail
    ($I12, $I11) = rx1354_cur."!mark_peek"($I10)
    rx1354_cur."!cursor_pos"($I11)
    ($P10) = rx1354_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1354_pos, "")
    rx1354_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1359_done
  rxcap_1359_fail:
    goto rx1354_fail
  rxcap_1359_done:
  # rx subrule "O" subtype=capture negate=
    rx1354_cur."!cursor_pos"(rx1354_pos)
    $P10 = rx1354_cur."O"("%autoincrement")
    unless $P10, rx1354_fail
    rx1354_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1354_pos = $P10."pos"()
  # rx pass
    rx1354_cur."!cursor_pass"(rx1354_pos, "postfix:sym<++>")
    if_null rx1354_debug, debug_1139
    rx1354_cur."!cursor_debug"("PASS", "postfix:sym<++>", " at pos=", rx1354_pos)
  debug_1139:
    .return (rx1354_cur)
  rx1354_restart:
.annotate 'line', 10
    if_null rx1354_debug, debug_1140
    rx1354_cur."!cursor_debug"("NEXT", "postfix:sym<++>")
  debug_1140:
  rx1354_fail:
    (rx1354_rep, rx1354_pos, $I10, $P10) = rx1354_cur."!mark_fail"(0)
    lt rx1354_pos, -1, rx1354_done
    eq rx1354_pos, -1, rx1354_fail
    jump $I10
  rx1354_done:
    rx1354_cur."!cursor_fail"()
    if_null rx1354_debug, debug_1141
    rx1354_cur."!cursor_debug"("FAIL", "postfix:sym<++>")
  debug_1141:
    .return (rx1354_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<++>"  :nsentry("!PREFIX__postfix:sym<++>") :subid("291_1302110486.758") :method
.annotate 'line', 10
    $P1356 = self."!PREFIX__!subrule"("O", "++")
    new $P1357, "ResizablePMCArray"
    push $P1357, $P1356
    .return ($P1357)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<-->"  :subid("292_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1361_tgt
    .local int rx1361_pos
    .local int rx1361_off
    .local int rx1361_eos
    .local int rx1361_rep
    .local pmc rx1361_cur
    .local pmc rx1361_debug
    (rx1361_cur, rx1361_pos, rx1361_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1361_cur
    .local pmc match
    .lex "$/", match
    length rx1361_eos, rx1361_tgt
    gt rx1361_pos, rx1361_eos, rx1361_done
    set rx1361_off, 0
    lt rx1361_pos, 2, rx1361_start
    sub rx1361_off, rx1361_pos, 1
    substr rx1361_tgt, rx1361_tgt, rx1361_off
  rx1361_start:
    eq $I10, 1, rx1361_restart
    if_null rx1361_debug, debug_1142
    rx1361_cur."!cursor_debug"("START", "postfix:sym<-->")
  debug_1142:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1365_done
    goto rxscan1365_scan
  rxscan1365_loop:
    (rx1361_pos) = rx1361_cur."from"()
    inc rx1361_pos
    rx1361_cur."!cursor_from"(rx1361_pos)
    ge rx1361_pos, rx1361_eos, rxscan1365_done
  rxscan1365_scan:
    set_addr $I10, rxscan1365_loop
    rx1361_cur."!mark_push"(0, rx1361_pos, $I10)
  rxscan1365_done:
.annotate 'line', 627
  # rx subcapture "sym"
    set_addr $I10, rxcap_1366_fail
    rx1361_cur."!mark_push"(0, rx1361_pos, $I10)
  # rx literal  "--"
    add $I11, rx1361_pos, 2
    gt $I11, rx1361_eos, rx1361_fail
    sub $I11, rx1361_pos, rx1361_off
    substr $S10, rx1361_tgt, $I11, 2
    ne $S10, "--", rx1361_fail
    add rx1361_pos, 2
    set_addr $I10, rxcap_1366_fail
    ($I12, $I11) = rx1361_cur."!mark_peek"($I10)
    rx1361_cur."!cursor_pos"($I11)
    ($P10) = rx1361_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1361_pos, "")
    rx1361_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1366_done
  rxcap_1366_fail:
    goto rx1361_fail
  rxcap_1366_done:
  # rx subrule "O" subtype=capture negate=
    rx1361_cur."!cursor_pos"(rx1361_pos)
    $P10 = rx1361_cur."O"("%autoincrement")
    unless $P10, rx1361_fail
    rx1361_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1361_pos = $P10."pos"()
  # rx pass
    rx1361_cur."!cursor_pass"(rx1361_pos, "postfix:sym<-->")
    if_null rx1361_debug, debug_1143
    rx1361_cur."!cursor_debug"("PASS", "postfix:sym<-->", " at pos=", rx1361_pos)
  debug_1143:
    .return (rx1361_cur)
  rx1361_restart:
.annotate 'line', 10
    if_null rx1361_debug, debug_1144
    rx1361_cur."!cursor_debug"("NEXT", "postfix:sym<-->")
  debug_1144:
  rx1361_fail:
    (rx1361_rep, rx1361_pos, $I10, $P10) = rx1361_cur."!mark_fail"(0)
    lt rx1361_pos, -1, rx1361_done
    eq rx1361_pos, -1, rx1361_fail
    jump $I10
  rx1361_done:
    rx1361_cur."!cursor_fail"()
    if_null rx1361_debug, debug_1145
    rx1361_cur."!cursor_debug"("FAIL", "postfix:sym<-->")
  debug_1145:
    .return (rx1361_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<-->"  :nsentry("!PREFIX__postfix:sym<-->") :subid("293_1302110486.758") :method
.annotate 'line', 10
    $P1363 = self."!PREFIX__!subrule"("O", "--")
    new $P1364, "ResizablePMCArray"
    push $P1364, $P1363
    .return ($P1364)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<**>"  :subid("294_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1368_tgt
    .local int rx1368_pos
    .local int rx1368_off
    .local int rx1368_eos
    .local int rx1368_rep
    .local pmc rx1368_cur
    .local pmc rx1368_debug
    (rx1368_cur, rx1368_pos, rx1368_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1368_cur
    .local pmc match
    .lex "$/", match
    length rx1368_eos, rx1368_tgt
    gt rx1368_pos, rx1368_eos, rx1368_done
    set rx1368_off, 0
    lt rx1368_pos, 2, rx1368_start
    sub rx1368_off, rx1368_pos, 1
    substr rx1368_tgt, rx1368_tgt, rx1368_off
  rx1368_start:
    eq $I10, 1, rx1368_restart
    if_null rx1368_debug, debug_1146
    rx1368_cur."!cursor_debug"("START", "infix:sym<**>")
  debug_1146:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1372_done
    goto rxscan1372_scan
  rxscan1372_loop:
    (rx1368_pos) = rx1368_cur."from"()
    inc rx1368_pos
    rx1368_cur."!cursor_from"(rx1368_pos)
    ge rx1368_pos, rx1368_eos, rxscan1372_done
  rxscan1372_scan:
    set_addr $I10, rxscan1372_loop
    rx1368_cur."!mark_push"(0, rx1368_pos, $I10)
  rxscan1372_done:
.annotate 'line', 629
  # rx subcapture "sym"
    set_addr $I10, rxcap_1373_fail
    rx1368_cur."!mark_push"(0, rx1368_pos, $I10)
  # rx literal  "**"
    add $I11, rx1368_pos, 2
    gt $I11, rx1368_eos, rx1368_fail
    sub $I11, rx1368_pos, rx1368_off
    substr $S10, rx1368_tgt, $I11, 2
    ne $S10, "**", rx1368_fail
    add rx1368_pos, 2
    set_addr $I10, rxcap_1373_fail
    ($I12, $I11) = rx1368_cur."!mark_peek"($I10)
    rx1368_cur."!cursor_pos"($I11)
    ($P10) = rx1368_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1368_pos, "")
    rx1368_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1373_done
  rxcap_1373_fail:
    goto rx1368_fail
  rxcap_1373_done:
  # rx subrule "O" subtype=capture negate=
    rx1368_cur."!cursor_pos"(rx1368_pos)
    $P10 = rx1368_cur."O"("%exponentiation, :pirop<pow>")
    unless $P10, rx1368_fail
    rx1368_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1368_pos = $P10."pos"()
  # rx pass
    rx1368_cur."!cursor_pass"(rx1368_pos, "infix:sym<**>")
    if_null rx1368_debug, debug_1147
    rx1368_cur."!cursor_debug"("PASS", "infix:sym<**>", " at pos=", rx1368_pos)
  debug_1147:
    .return (rx1368_cur)
  rx1368_restart:
.annotate 'line', 10
    if_null rx1368_debug, debug_1148
    rx1368_cur."!cursor_debug"("NEXT", "infix:sym<**>")
  debug_1148:
  rx1368_fail:
    (rx1368_rep, rx1368_pos, $I10, $P10) = rx1368_cur."!mark_fail"(0)
    lt rx1368_pos, -1, rx1368_done
    eq rx1368_pos, -1, rx1368_fail
    jump $I10
  rx1368_done:
    rx1368_cur."!cursor_fail"()
    if_null rx1368_debug, debug_1149
    rx1368_cur."!cursor_debug"("FAIL", "infix:sym<**>")
  debug_1149:
    .return (rx1368_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<**>"  :nsentry("!PREFIX__infix:sym<**>") :subid("295_1302110486.758") :method
.annotate 'line', 10
    $P1370 = self."!PREFIX__!subrule"("O", "**")
    new $P1371, "ResizablePMCArray"
    push $P1371, $P1370
    .return ($P1371)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<+>"  :subid("296_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1375_tgt
    .local int rx1375_pos
    .local int rx1375_off
    .local int rx1375_eos
    .local int rx1375_rep
    .local pmc rx1375_cur
    .local pmc rx1375_debug
    (rx1375_cur, rx1375_pos, rx1375_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1375_cur
    .local pmc match
    .lex "$/", match
    length rx1375_eos, rx1375_tgt
    gt rx1375_pos, rx1375_eos, rx1375_done
    set rx1375_off, 0
    lt rx1375_pos, 2, rx1375_start
    sub rx1375_off, rx1375_pos, 1
    substr rx1375_tgt, rx1375_tgt, rx1375_off
  rx1375_start:
    eq $I10, 1, rx1375_restart
    if_null rx1375_debug, debug_1150
    rx1375_cur."!cursor_debug"("START", "prefix:sym<+>")
  debug_1150:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1379_done
    goto rxscan1379_scan
  rxscan1379_loop:
    (rx1375_pos) = rx1375_cur."from"()
    inc rx1375_pos
    rx1375_cur."!cursor_from"(rx1375_pos)
    ge rx1375_pos, rx1375_eos, rxscan1379_done
  rxscan1379_scan:
    set_addr $I10, rxscan1379_loop
    rx1375_cur."!mark_push"(0, rx1375_pos, $I10)
  rxscan1379_done:
.annotate 'line', 631
  # rx subcapture "sym"
    set_addr $I10, rxcap_1380_fail
    rx1375_cur."!mark_push"(0, rx1375_pos, $I10)
  # rx literal  "+"
    add $I11, rx1375_pos, 1
    gt $I11, rx1375_eos, rx1375_fail
    sub $I11, rx1375_pos, rx1375_off
    ord $I11, rx1375_tgt, $I11
    ne $I11, 43, rx1375_fail
    add rx1375_pos, 1
    set_addr $I10, rxcap_1380_fail
    ($I12, $I11) = rx1375_cur."!mark_peek"($I10)
    rx1375_cur."!cursor_pos"($I11)
    ($P10) = rx1375_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1375_pos, "")
    rx1375_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1380_done
  rxcap_1380_fail:
    goto rx1375_fail
  rxcap_1380_done:
  # rx subrule "O" subtype=capture negate=
    rx1375_cur."!cursor_pos"(rx1375_pos)
    $P10 = rx1375_cur."O"("%symbolic_unary, :pirop<set N*>")
    unless $P10, rx1375_fail
    rx1375_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1375_pos = $P10."pos"()
  # rx pass
    rx1375_cur."!cursor_pass"(rx1375_pos, "prefix:sym<+>")
    if_null rx1375_debug, debug_1151
    rx1375_cur."!cursor_debug"("PASS", "prefix:sym<+>", " at pos=", rx1375_pos)
  debug_1151:
    .return (rx1375_cur)
  rx1375_restart:
.annotate 'line', 10
    if_null rx1375_debug, debug_1152
    rx1375_cur."!cursor_debug"("NEXT", "prefix:sym<+>")
  debug_1152:
  rx1375_fail:
    (rx1375_rep, rx1375_pos, $I10, $P10) = rx1375_cur."!mark_fail"(0)
    lt rx1375_pos, -1, rx1375_done
    eq rx1375_pos, -1, rx1375_fail
    jump $I10
  rx1375_done:
    rx1375_cur."!cursor_fail"()
    if_null rx1375_debug, debug_1153
    rx1375_cur."!cursor_debug"("FAIL", "prefix:sym<+>")
  debug_1153:
    .return (rx1375_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<+>"  :nsentry("!PREFIX__prefix:sym<+>") :subid("297_1302110486.758") :method
.annotate 'line', 10
    $P1377 = self."!PREFIX__!subrule"("O", "+")
    new $P1378, "ResizablePMCArray"
    push $P1378, $P1377
    .return ($P1378)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<~>"  :subid("298_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1382_tgt
    .local int rx1382_pos
    .local int rx1382_off
    .local int rx1382_eos
    .local int rx1382_rep
    .local pmc rx1382_cur
    .local pmc rx1382_debug
    (rx1382_cur, rx1382_pos, rx1382_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1382_cur
    .local pmc match
    .lex "$/", match
    length rx1382_eos, rx1382_tgt
    gt rx1382_pos, rx1382_eos, rx1382_done
    set rx1382_off, 0
    lt rx1382_pos, 2, rx1382_start
    sub rx1382_off, rx1382_pos, 1
    substr rx1382_tgt, rx1382_tgt, rx1382_off
  rx1382_start:
    eq $I10, 1, rx1382_restart
    if_null rx1382_debug, debug_1154
    rx1382_cur."!cursor_debug"("START", "prefix:sym<~>")
  debug_1154:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1386_done
    goto rxscan1386_scan
  rxscan1386_loop:
    (rx1382_pos) = rx1382_cur."from"()
    inc rx1382_pos
    rx1382_cur."!cursor_from"(rx1382_pos)
    ge rx1382_pos, rx1382_eos, rxscan1386_done
  rxscan1386_scan:
    set_addr $I10, rxscan1386_loop
    rx1382_cur."!mark_push"(0, rx1382_pos, $I10)
  rxscan1386_done:
.annotate 'line', 632
  # rx subcapture "sym"
    set_addr $I10, rxcap_1387_fail
    rx1382_cur."!mark_push"(0, rx1382_pos, $I10)
  # rx literal  "~"
    add $I11, rx1382_pos, 1
    gt $I11, rx1382_eos, rx1382_fail
    sub $I11, rx1382_pos, rx1382_off
    ord $I11, rx1382_tgt, $I11
    ne $I11, 126, rx1382_fail
    add rx1382_pos, 1
    set_addr $I10, rxcap_1387_fail
    ($I12, $I11) = rx1382_cur."!mark_peek"($I10)
    rx1382_cur."!cursor_pos"($I11)
    ($P10) = rx1382_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1382_pos, "")
    rx1382_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1387_done
  rxcap_1387_fail:
    goto rx1382_fail
  rxcap_1387_done:
  # rx subrule "O" subtype=capture negate=
    rx1382_cur."!cursor_pos"(rx1382_pos)
    $P10 = rx1382_cur."O"("%symbolic_unary, :pirop<set S*>")
    unless $P10, rx1382_fail
    rx1382_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1382_pos = $P10."pos"()
  # rx pass
    rx1382_cur."!cursor_pass"(rx1382_pos, "prefix:sym<~>")
    if_null rx1382_debug, debug_1155
    rx1382_cur."!cursor_debug"("PASS", "prefix:sym<~>", " at pos=", rx1382_pos)
  debug_1155:
    .return (rx1382_cur)
  rx1382_restart:
.annotate 'line', 10
    if_null rx1382_debug, debug_1156
    rx1382_cur."!cursor_debug"("NEXT", "prefix:sym<~>")
  debug_1156:
  rx1382_fail:
    (rx1382_rep, rx1382_pos, $I10, $P10) = rx1382_cur."!mark_fail"(0)
    lt rx1382_pos, -1, rx1382_done
    eq rx1382_pos, -1, rx1382_fail
    jump $I10
  rx1382_done:
    rx1382_cur."!cursor_fail"()
    if_null rx1382_debug, debug_1157
    rx1382_cur."!cursor_debug"("FAIL", "prefix:sym<~>")
  debug_1157:
    .return (rx1382_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<~>"  :nsentry("!PREFIX__prefix:sym<~>") :subid("299_1302110486.758") :method
.annotate 'line', 10
    $P1384 = self."!PREFIX__!subrule"("O", "~")
    new $P1385, "ResizablePMCArray"
    push $P1385, $P1384
    .return ($P1385)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<->"  :subid("300_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1389_tgt
    .local int rx1389_pos
    .local int rx1389_off
    .local int rx1389_eos
    .local int rx1389_rep
    .local pmc rx1389_cur
    .local pmc rx1389_debug
    (rx1389_cur, rx1389_pos, rx1389_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1389_cur
    .local pmc match
    .lex "$/", match
    length rx1389_eos, rx1389_tgt
    gt rx1389_pos, rx1389_eos, rx1389_done
    set rx1389_off, 0
    lt rx1389_pos, 2, rx1389_start
    sub rx1389_off, rx1389_pos, 1
    substr rx1389_tgt, rx1389_tgt, rx1389_off
  rx1389_start:
    eq $I10, 1, rx1389_restart
    if_null rx1389_debug, debug_1158
    rx1389_cur."!cursor_debug"("START", "prefix:sym<->")
  debug_1158:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1392_done
    goto rxscan1392_scan
  rxscan1392_loop:
    (rx1389_pos) = rx1389_cur."from"()
    inc rx1389_pos
    rx1389_cur."!cursor_from"(rx1389_pos)
    ge rx1389_pos, rx1389_eos, rxscan1392_done
  rxscan1392_scan:
    set_addr $I10, rxscan1392_loop
    rx1389_cur."!mark_push"(0, rx1389_pos, $I10)
  rxscan1392_done:
.annotate 'line', 633
  # rx subcapture "sym"
    set_addr $I10, rxcap_1393_fail
    rx1389_cur."!mark_push"(0, rx1389_pos, $I10)
  # rx literal  "-"
    add $I11, rx1389_pos, 1
    gt $I11, rx1389_eos, rx1389_fail
    sub $I11, rx1389_pos, rx1389_off
    ord $I11, rx1389_tgt, $I11
    ne $I11, 45, rx1389_fail
    add rx1389_pos, 1
    set_addr $I10, rxcap_1393_fail
    ($I12, $I11) = rx1389_cur."!mark_peek"($I10)
    rx1389_cur."!cursor_pos"($I11)
    ($P10) = rx1389_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1389_pos, "")
    rx1389_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1393_done
  rxcap_1393_fail:
    goto rx1389_fail
  rxcap_1393_done:
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1389_pos, rx1389_off
    substr $S10, rx1389_tgt, $I10, 1
    index $I11, ">", $S10
    ge $I11, 0, rx1389_fail
  # rx subrule "number" subtype=zerowidth negate=1
    rx1389_cur."!cursor_pos"(rx1389_pos)
    $P10 = rx1389_cur."number"()
    if $P10, rx1389_fail
  # rx subrule "O" subtype=capture negate=
    rx1389_cur."!cursor_pos"(rx1389_pos)
    $P10 = rx1389_cur."O"("%symbolic_unary, :pirop<neg>")
    unless $P10, rx1389_fail
    rx1389_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1389_pos = $P10."pos"()
  # rx pass
    rx1389_cur."!cursor_pass"(rx1389_pos, "prefix:sym<->")
    if_null rx1389_debug, debug_1159
    rx1389_cur."!cursor_debug"("PASS", "prefix:sym<->", " at pos=", rx1389_pos)
  debug_1159:
    .return (rx1389_cur)
  rx1389_restart:
.annotate 'line', 10
    if_null rx1389_debug, debug_1160
    rx1389_cur."!cursor_debug"("NEXT", "prefix:sym<->")
  debug_1160:
  rx1389_fail:
    (rx1389_rep, rx1389_pos, $I10, $P10) = rx1389_cur."!mark_fail"(0)
    lt rx1389_pos, -1, rx1389_done
    eq rx1389_pos, -1, rx1389_fail
    jump $I10
  rx1389_done:
    rx1389_cur."!cursor_fail"()
    if_null rx1389_debug, debug_1161
    rx1389_cur."!cursor_debug"("FAIL", "prefix:sym<->")
  debug_1161:
    .return (rx1389_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<->"  :nsentry("!PREFIX__prefix:sym<->") :subid("301_1302110486.758") :method
.annotate 'line', 10
    new $P1391, "ResizablePMCArray"
    push $P1391, "-"
    .return ($P1391)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<?>"  :subid("302_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1395_tgt
    .local int rx1395_pos
    .local int rx1395_off
    .local int rx1395_eos
    .local int rx1395_rep
    .local pmc rx1395_cur
    .local pmc rx1395_debug
    (rx1395_cur, rx1395_pos, rx1395_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1395_cur
    .local pmc match
    .lex "$/", match
    length rx1395_eos, rx1395_tgt
    gt rx1395_pos, rx1395_eos, rx1395_done
    set rx1395_off, 0
    lt rx1395_pos, 2, rx1395_start
    sub rx1395_off, rx1395_pos, 1
    substr rx1395_tgt, rx1395_tgt, rx1395_off
  rx1395_start:
    eq $I10, 1, rx1395_restart
    if_null rx1395_debug, debug_1162
    rx1395_cur."!cursor_debug"("START", "prefix:sym<?>")
  debug_1162:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1399_done
    goto rxscan1399_scan
  rxscan1399_loop:
    (rx1395_pos) = rx1395_cur."from"()
    inc rx1395_pos
    rx1395_cur."!cursor_from"(rx1395_pos)
    ge rx1395_pos, rx1395_eos, rxscan1399_done
  rxscan1399_scan:
    set_addr $I10, rxscan1399_loop
    rx1395_cur."!mark_push"(0, rx1395_pos, $I10)
  rxscan1399_done:
.annotate 'line', 634
  # rx subcapture "sym"
    set_addr $I10, rxcap_1400_fail
    rx1395_cur."!mark_push"(0, rx1395_pos, $I10)
  # rx literal  "?"
    add $I11, rx1395_pos, 1
    gt $I11, rx1395_eos, rx1395_fail
    sub $I11, rx1395_pos, rx1395_off
    ord $I11, rx1395_tgt, $I11
    ne $I11, 63, rx1395_fail
    add rx1395_pos, 1
    set_addr $I10, rxcap_1400_fail
    ($I12, $I11) = rx1395_cur."!mark_peek"($I10)
    rx1395_cur."!cursor_pos"($I11)
    ($P10) = rx1395_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1395_pos, "")
    rx1395_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1400_done
  rxcap_1400_fail:
    goto rx1395_fail
  rxcap_1400_done:
  # rx subrule "O" subtype=capture negate=
    rx1395_cur."!cursor_pos"(rx1395_pos)
    $P10 = rx1395_cur."O"("%symbolic_unary, :pirop<istrue>")
    unless $P10, rx1395_fail
    rx1395_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1395_pos = $P10."pos"()
  # rx pass
    rx1395_cur."!cursor_pass"(rx1395_pos, "prefix:sym<?>")
    if_null rx1395_debug, debug_1163
    rx1395_cur."!cursor_debug"("PASS", "prefix:sym<?>", " at pos=", rx1395_pos)
  debug_1163:
    .return (rx1395_cur)
  rx1395_restart:
.annotate 'line', 10
    if_null rx1395_debug, debug_1164
    rx1395_cur."!cursor_debug"("NEXT", "prefix:sym<?>")
  debug_1164:
  rx1395_fail:
    (rx1395_rep, rx1395_pos, $I10, $P10) = rx1395_cur."!mark_fail"(0)
    lt rx1395_pos, -1, rx1395_done
    eq rx1395_pos, -1, rx1395_fail
    jump $I10
  rx1395_done:
    rx1395_cur."!cursor_fail"()
    if_null rx1395_debug, debug_1165
    rx1395_cur."!cursor_debug"("FAIL", "prefix:sym<?>")
  debug_1165:
    .return (rx1395_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<?>"  :nsentry("!PREFIX__prefix:sym<?>") :subid("303_1302110486.758") :method
.annotate 'line', 10
    $P1397 = self."!PREFIX__!subrule"("O", "?")
    new $P1398, "ResizablePMCArray"
    push $P1398, $P1397
    .return ($P1398)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<!>"  :subid("304_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1402_tgt
    .local int rx1402_pos
    .local int rx1402_off
    .local int rx1402_eos
    .local int rx1402_rep
    .local pmc rx1402_cur
    .local pmc rx1402_debug
    (rx1402_cur, rx1402_pos, rx1402_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1402_cur
    .local pmc match
    .lex "$/", match
    length rx1402_eos, rx1402_tgt
    gt rx1402_pos, rx1402_eos, rx1402_done
    set rx1402_off, 0
    lt rx1402_pos, 2, rx1402_start
    sub rx1402_off, rx1402_pos, 1
    substr rx1402_tgt, rx1402_tgt, rx1402_off
  rx1402_start:
    eq $I10, 1, rx1402_restart
    if_null rx1402_debug, debug_1166
    rx1402_cur."!cursor_debug"("START", "prefix:sym<!>")
  debug_1166:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1406_done
    goto rxscan1406_scan
  rxscan1406_loop:
    (rx1402_pos) = rx1402_cur."from"()
    inc rx1402_pos
    rx1402_cur."!cursor_from"(rx1402_pos)
    ge rx1402_pos, rx1402_eos, rxscan1406_done
  rxscan1406_scan:
    set_addr $I10, rxscan1406_loop
    rx1402_cur."!mark_push"(0, rx1402_pos, $I10)
  rxscan1406_done:
.annotate 'line', 635
  # rx subcapture "sym"
    set_addr $I10, rxcap_1407_fail
    rx1402_cur."!mark_push"(0, rx1402_pos, $I10)
  # rx literal  "!"
    add $I11, rx1402_pos, 1
    gt $I11, rx1402_eos, rx1402_fail
    sub $I11, rx1402_pos, rx1402_off
    ord $I11, rx1402_tgt, $I11
    ne $I11, 33, rx1402_fail
    add rx1402_pos, 1
    set_addr $I10, rxcap_1407_fail
    ($I12, $I11) = rx1402_cur."!mark_peek"($I10)
    rx1402_cur."!cursor_pos"($I11)
    ($P10) = rx1402_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1402_pos, "")
    rx1402_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1407_done
  rxcap_1407_fail:
    goto rx1402_fail
  rxcap_1407_done:
  # rx subrule "O" subtype=capture negate=
    rx1402_cur."!cursor_pos"(rx1402_pos)
    $P10 = rx1402_cur."O"("%symbolic_unary, :pirop<isfalse>")
    unless $P10, rx1402_fail
    rx1402_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1402_pos = $P10."pos"()
  # rx pass
    rx1402_cur."!cursor_pass"(rx1402_pos, "prefix:sym<!>")
    if_null rx1402_debug, debug_1167
    rx1402_cur."!cursor_debug"("PASS", "prefix:sym<!>", " at pos=", rx1402_pos)
  debug_1167:
    .return (rx1402_cur)
  rx1402_restart:
.annotate 'line', 10
    if_null rx1402_debug, debug_1168
    rx1402_cur."!cursor_debug"("NEXT", "prefix:sym<!>")
  debug_1168:
  rx1402_fail:
    (rx1402_rep, rx1402_pos, $I10, $P10) = rx1402_cur."!mark_fail"(0)
    lt rx1402_pos, -1, rx1402_done
    eq rx1402_pos, -1, rx1402_fail
    jump $I10
  rx1402_done:
    rx1402_cur."!cursor_fail"()
    if_null rx1402_debug, debug_1169
    rx1402_cur."!cursor_debug"("FAIL", "prefix:sym<!>")
  debug_1169:
    .return (rx1402_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<!>"  :nsentry("!PREFIX__prefix:sym<!>") :subid("305_1302110486.758") :method
.annotate 'line', 10
    $P1404 = self."!PREFIX__!subrule"("O", "!")
    new $P1405, "ResizablePMCArray"
    push $P1405, $P1404
    .return ($P1405)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<|>"  :subid("306_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1409_tgt
    .local int rx1409_pos
    .local int rx1409_off
    .local int rx1409_eos
    .local int rx1409_rep
    .local pmc rx1409_cur
    .local pmc rx1409_debug
    (rx1409_cur, rx1409_pos, rx1409_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1409_cur
    .local pmc match
    .lex "$/", match
    length rx1409_eos, rx1409_tgt
    gt rx1409_pos, rx1409_eos, rx1409_done
    set rx1409_off, 0
    lt rx1409_pos, 2, rx1409_start
    sub rx1409_off, rx1409_pos, 1
    substr rx1409_tgt, rx1409_tgt, rx1409_off
  rx1409_start:
    eq $I10, 1, rx1409_restart
    if_null rx1409_debug, debug_1170
    rx1409_cur."!cursor_debug"("START", "prefix:sym<|>")
  debug_1170:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1413_done
    goto rxscan1413_scan
  rxscan1413_loop:
    (rx1409_pos) = rx1409_cur."from"()
    inc rx1409_pos
    rx1409_cur."!cursor_from"(rx1409_pos)
    ge rx1409_pos, rx1409_eos, rxscan1413_done
  rxscan1413_scan:
    set_addr $I10, rxscan1413_loop
    rx1409_cur."!mark_push"(0, rx1409_pos, $I10)
  rxscan1413_done:
.annotate 'line', 636
  # rx subcapture "sym"
    set_addr $I10, rxcap_1414_fail
    rx1409_cur."!mark_push"(0, rx1409_pos, $I10)
  # rx literal  "|"
    add $I11, rx1409_pos, 1
    gt $I11, rx1409_eos, rx1409_fail
    sub $I11, rx1409_pos, rx1409_off
    ord $I11, rx1409_tgt, $I11
    ne $I11, 124, rx1409_fail
    add rx1409_pos, 1
    set_addr $I10, rxcap_1414_fail
    ($I12, $I11) = rx1409_cur."!mark_peek"($I10)
    rx1409_cur."!cursor_pos"($I11)
    ($P10) = rx1409_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1409_pos, "")
    rx1409_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1414_done
  rxcap_1414_fail:
    goto rx1409_fail
  rxcap_1414_done:
  # rx subrule "O" subtype=capture negate=
    rx1409_cur."!cursor_pos"(rx1409_pos)
    $P10 = rx1409_cur."O"("%symbolic_unary")
    unless $P10, rx1409_fail
    rx1409_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1409_pos = $P10."pos"()
  # rx pass
    rx1409_cur."!cursor_pass"(rx1409_pos, "prefix:sym<|>")
    if_null rx1409_debug, debug_1171
    rx1409_cur."!cursor_debug"("PASS", "prefix:sym<|>", " at pos=", rx1409_pos)
  debug_1171:
    .return (rx1409_cur)
  rx1409_restart:
.annotate 'line', 10
    if_null rx1409_debug, debug_1172
    rx1409_cur."!cursor_debug"("NEXT", "prefix:sym<|>")
  debug_1172:
  rx1409_fail:
    (rx1409_rep, rx1409_pos, $I10, $P10) = rx1409_cur."!mark_fail"(0)
    lt rx1409_pos, -1, rx1409_done
    eq rx1409_pos, -1, rx1409_fail
    jump $I10
  rx1409_done:
    rx1409_cur."!cursor_fail"()
    if_null rx1409_debug, debug_1173
    rx1409_cur."!cursor_debug"("FAIL", "prefix:sym<|>")
  debug_1173:
    .return (rx1409_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<|>"  :nsentry("!PREFIX__prefix:sym<|>") :subid("307_1302110486.758") :method
.annotate 'line', 10
    $P1411 = self."!PREFIX__!subrule"("O", "|")
    new $P1412, "ResizablePMCArray"
    push $P1412, $P1411
    .return ($P1412)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<*>"  :subid("308_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1416_tgt
    .local int rx1416_pos
    .local int rx1416_off
    .local int rx1416_eos
    .local int rx1416_rep
    .local pmc rx1416_cur
    .local pmc rx1416_debug
    (rx1416_cur, rx1416_pos, rx1416_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1416_cur
    .local pmc match
    .lex "$/", match
    length rx1416_eos, rx1416_tgt
    gt rx1416_pos, rx1416_eos, rx1416_done
    set rx1416_off, 0
    lt rx1416_pos, 2, rx1416_start
    sub rx1416_off, rx1416_pos, 1
    substr rx1416_tgt, rx1416_tgt, rx1416_off
  rx1416_start:
    eq $I10, 1, rx1416_restart
    if_null rx1416_debug, debug_1174
    rx1416_cur."!cursor_debug"("START", "infix:sym<*>")
  debug_1174:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1420_done
    goto rxscan1420_scan
  rxscan1420_loop:
    (rx1416_pos) = rx1416_cur."from"()
    inc rx1416_pos
    rx1416_cur."!cursor_from"(rx1416_pos)
    ge rx1416_pos, rx1416_eos, rxscan1420_done
  rxscan1420_scan:
    set_addr $I10, rxscan1420_loop
    rx1416_cur."!mark_push"(0, rx1416_pos, $I10)
  rxscan1420_done:
.annotate 'line', 638
  # rx subcapture "sym"
    set_addr $I10, rxcap_1421_fail
    rx1416_cur."!mark_push"(0, rx1416_pos, $I10)
  # rx literal  "*"
    add $I11, rx1416_pos, 1
    gt $I11, rx1416_eos, rx1416_fail
    sub $I11, rx1416_pos, rx1416_off
    ord $I11, rx1416_tgt, $I11
    ne $I11, 42, rx1416_fail
    add rx1416_pos, 1
    set_addr $I10, rxcap_1421_fail
    ($I12, $I11) = rx1416_cur."!mark_peek"($I10)
    rx1416_cur."!cursor_pos"($I11)
    ($P10) = rx1416_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1416_pos, "")
    rx1416_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1421_done
  rxcap_1421_fail:
    goto rx1416_fail
  rxcap_1421_done:
  # rx subrule "O" subtype=capture negate=
    rx1416_cur."!cursor_pos"(rx1416_pos)
    $P10 = rx1416_cur."O"("%multiplicative, :pirop<mul>")
    unless $P10, rx1416_fail
    rx1416_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1416_pos = $P10."pos"()
  # rx pass
    rx1416_cur."!cursor_pass"(rx1416_pos, "infix:sym<*>")
    if_null rx1416_debug, debug_1175
    rx1416_cur."!cursor_debug"("PASS", "infix:sym<*>", " at pos=", rx1416_pos)
  debug_1175:
    .return (rx1416_cur)
  rx1416_restart:
.annotate 'line', 10
    if_null rx1416_debug, debug_1176
    rx1416_cur."!cursor_debug"("NEXT", "infix:sym<*>")
  debug_1176:
  rx1416_fail:
    (rx1416_rep, rx1416_pos, $I10, $P10) = rx1416_cur."!mark_fail"(0)
    lt rx1416_pos, -1, rx1416_done
    eq rx1416_pos, -1, rx1416_fail
    jump $I10
  rx1416_done:
    rx1416_cur."!cursor_fail"()
    if_null rx1416_debug, debug_1177
    rx1416_cur."!cursor_debug"("FAIL", "infix:sym<*>")
  debug_1177:
    .return (rx1416_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<*>"  :nsentry("!PREFIX__infix:sym<*>") :subid("309_1302110486.758") :method
.annotate 'line', 10
    $P1418 = self."!PREFIX__!subrule"("O", "*")
    new $P1419, "ResizablePMCArray"
    push $P1419, $P1418
    .return ($P1419)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym</>"  :subid("310_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1423_tgt
    .local int rx1423_pos
    .local int rx1423_off
    .local int rx1423_eos
    .local int rx1423_rep
    .local pmc rx1423_cur
    .local pmc rx1423_debug
    (rx1423_cur, rx1423_pos, rx1423_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1423_cur
    .local pmc match
    .lex "$/", match
    length rx1423_eos, rx1423_tgt
    gt rx1423_pos, rx1423_eos, rx1423_done
    set rx1423_off, 0
    lt rx1423_pos, 2, rx1423_start
    sub rx1423_off, rx1423_pos, 1
    substr rx1423_tgt, rx1423_tgt, rx1423_off
  rx1423_start:
    eq $I10, 1, rx1423_restart
    if_null rx1423_debug, debug_1178
    rx1423_cur."!cursor_debug"("START", "infix:sym</>")
  debug_1178:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1427_done
    goto rxscan1427_scan
  rxscan1427_loop:
    (rx1423_pos) = rx1423_cur."from"()
    inc rx1423_pos
    rx1423_cur."!cursor_from"(rx1423_pos)
    ge rx1423_pos, rx1423_eos, rxscan1427_done
  rxscan1427_scan:
    set_addr $I10, rxscan1427_loop
    rx1423_cur."!mark_push"(0, rx1423_pos, $I10)
  rxscan1427_done:
.annotate 'line', 639
  # rx subcapture "sym"
    set_addr $I10, rxcap_1428_fail
    rx1423_cur."!mark_push"(0, rx1423_pos, $I10)
  # rx literal  "/"
    add $I11, rx1423_pos, 1
    gt $I11, rx1423_eos, rx1423_fail
    sub $I11, rx1423_pos, rx1423_off
    ord $I11, rx1423_tgt, $I11
    ne $I11, 47, rx1423_fail
    add rx1423_pos, 1
    set_addr $I10, rxcap_1428_fail
    ($I12, $I11) = rx1423_cur."!mark_peek"($I10)
    rx1423_cur."!cursor_pos"($I11)
    ($P10) = rx1423_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1423_pos, "")
    rx1423_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1428_done
  rxcap_1428_fail:
    goto rx1423_fail
  rxcap_1428_done:
  # rx subrule "O" subtype=capture negate=
    rx1423_cur."!cursor_pos"(rx1423_pos)
    $P10 = rx1423_cur."O"("%multiplicative, :pirop<div>")
    unless $P10, rx1423_fail
    rx1423_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1423_pos = $P10."pos"()
  # rx pass
    rx1423_cur."!cursor_pass"(rx1423_pos, "infix:sym</>")
    if_null rx1423_debug, debug_1179
    rx1423_cur."!cursor_debug"("PASS", "infix:sym</>", " at pos=", rx1423_pos)
  debug_1179:
    .return (rx1423_cur)
  rx1423_restart:
.annotate 'line', 10
    if_null rx1423_debug, debug_1180
    rx1423_cur."!cursor_debug"("NEXT", "infix:sym</>")
  debug_1180:
  rx1423_fail:
    (rx1423_rep, rx1423_pos, $I10, $P10) = rx1423_cur."!mark_fail"(0)
    lt rx1423_pos, -1, rx1423_done
    eq rx1423_pos, -1, rx1423_fail
    jump $I10
  rx1423_done:
    rx1423_cur."!cursor_fail"()
    if_null rx1423_debug, debug_1181
    rx1423_cur."!cursor_debug"("FAIL", "infix:sym</>")
  debug_1181:
    .return (rx1423_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym</>"  :nsentry("!PREFIX__infix:sym</>") :subid("311_1302110486.758") :method
.annotate 'line', 10
    $P1425 = self."!PREFIX__!subrule"("O", "/")
    new $P1426, "ResizablePMCArray"
    push $P1426, $P1425
    .return ($P1426)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<%>"  :subid("312_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1430_tgt
    .local int rx1430_pos
    .local int rx1430_off
    .local int rx1430_eos
    .local int rx1430_rep
    .local pmc rx1430_cur
    .local pmc rx1430_debug
    (rx1430_cur, rx1430_pos, rx1430_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1430_cur
    .local pmc match
    .lex "$/", match
    length rx1430_eos, rx1430_tgt
    gt rx1430_pos, rx1430_eos, rx1430_done
    set rx1430_off, 0
    lt rx1430_pos, 2, rx1430_start
    sub rx1430_off, rx1430_pos, 1
    substr rx1430_tgt, rx1430_tgt, rx1430_off
  rx1430_start:
    eq $I10, 1, rx1430_restart
    if_null rx1430_debug, debug_1182
    rx1430_cur."!cursor_debug"("START", "infix:sym<%>")
  debug_1182:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1434_done
    goto rxscan1434_scan
  rxscan1434_loop:
    (rx1430_pos) = rx1430_cur."from"()
    inc rx1430_pos
    rx1430_cur."!cursor_from"(rx1430_pos)
    ge rx1430_pos, rx1430_eos, rxscan1434_done
  rxscan1434_scan:
    set_addr $I10, rxscan1434_loop
    rx1430_cur."!mark_push"(0, rx1430_pos, $I10)
  rxscan1434_done:
.annotate 'line', 640
  # rx subcapture "sym"
    set_addr $I10, rxcap_1435_fail
    rx1430_cur."!mark_push"(0, rx1430_pos, $I10)
  # rx literal  "%"
    add $I11, rx1430_pos, 1
    gt $I11, rx1430_eos, rx1430_fail
    sub $I11, rx1430_pos, rx1430_off
    ord $I11, rx1430_tgt, $I11
    ne $I11, 37, rx1430_fail
    add rx1430_pos, 1
    set_addr $I10, rxcap_1435_fail
    ($I12, $I11) = rx1430_cur."!mark_peek"($I10)
    rx1430_cur."!cursor_pos"($I11)
    ($P10) = rx1430_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1430_pos, "")
    rx1430_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1435_done
  rxcap_1435_fail:
    goto rx1430_fail
  rxcap_1435_done:
  # rx subrule "O" subtype=capture negate=
    rx1430_cur."!cursor_pos"(rx1430_pos)
    $P10 = rx1430_cur."O"("%multiplicative, :pirop<mod>")
    unless $P10, rx1430_fail
    rx1430_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1430_pos = $P10."pos"()
  # rx pass
    rx1430_cur."!cursor_pass"(rx1430_pos, "infix:sym<%>")
    if_null rx1430_debug, debug_1183
    rx1430_cur."!cursor_debug"("PASS", "infix:sym<%>", " at pos=", rx1430_pos)
  debug_1183:
    .return (rx1430_cur)
  rx1430_restart:
.annotate 'line', 10
    if_null rx1430_debug, debug_1184
    rx1430_cur."!cursor_debug"("NEXT", "infix:sym<%>")
  debug_1184:
  rx1430_fail:
    (rx1430_rep, rx1430_pos, $I10, $P10) = rx1430_cur."!mark_fail"(0)
    lt rx1430_pos, -1, rx1430_done
    eq rx1430_pos, -1, rx1430_fail
    jump $I10
  rx1430_done:
    rx1430_cur."!cursor_fail"()
    if_null rx1430_debug, debug_1185
    rx1430_cur."!cursor_debug"("FAIL", "infix:sym<%>")
  debug_1185:
    .return (rx1430_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<%>"  :nsentry("!PREFIX__infix:sym<%>") :subid("313_1302110486.758") :method
.annotate 'line', 10
    $P1432 = self."!PREFIX__!subrule"("O", "%")
    new $P1433, "ResizablePMCArray"
    push $P1433, $P1432
    .return ($P1433)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+&>"  :subid("314_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1437_tgt
    .local int rx1437_pos
    .local int rx1437_off
    .local int rx1437_eos
    .local int rx1437_rep
    .local pmc rx1437_cur
    .local pmc rx1437_debug
    (rx1437_cur, rx1437_pos, rx1437_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1437_cur
    .local pmc match
    .lex "$/", match
    length rx1437_eos, rx1437_tgt
    gt rx1437_pos, rx1437_eos, rx1437_done
    set rx1437_off, 0
    lt rx1437_pos, 2, rx1437_start
    sub rx1437_off, rx1437_pos, 1
    substr rx1437_tgt, rx1437_tgt, rx1437_off
  rx1437_start:
    eq $I10, 1, rx1437_restart
    if_null rx1437_debug, debug_1186
    rx1437_cur."!cursor_debug"("START", "infix:sym<+&>")
  debug_1186:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1441_done
    goto rxscan1441_scan
  rxscan1441_loop:
    (rx1437_pos) = rx1437_cur."from"()
    inc rx1437_pos
    rx1437_cur."!cursor_from"(rx1437_pos)
    ge rx1437_pos, rx1437_eos, rxscan1441_done
  rxscan1441_scan:
    set_addr $I10, rxscan1441_loop
    rx1437_cur."!mark_push"(0, rx1437_pos, $I10)
  rxscan1441_done:
.annotate 'line', 641
  # rx subcapture "sym"
    set_addr $I10, rxcap_1442_fail
    rx1437_cur."!mark_push"(0, rx1437_pos, $I10)
  # rx literal  "+&"
    add $I11, rx1437_pos, 2
    gt $I11, rx1437_eos, rx1437_fail
    sub $I11, rx1437_pos, rx1437_off
    substr $S10, rx1437_tgt, $I11, 2
    ne $S10, "+&", rx1437_fail
    add rx1437_pos, 2
    set_addr $I10, rxcap_1442_fail
    ($I12, $I11) = rx1437_cur."!mark_peek"($I10)
    rx1437_cur."!cursor_pos"($I11)
    ($P10) = rx1437_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1437_pos, "")
    rx1437_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1442_done
  rxcap_1442_fail:
    goto rx1437_fail
  rxcap_1442_done:
  # rx subrule "O" subtype=capture negate=
    rx1437_cur."!cursor_pos"(rx1437_pos)
    $P10 = rx1437_cur."O"("%multiplicative, :pirop<band III>")
    unless $P10, rx1437_fail
    rx1437_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1437_pos = $P10."pos"()
  # rx pass
    rx1437_cur."!cursor_pass"(rx1437_pos, "infix:sym<+&>")
    if_null rx1437_debug, debug_1187
    rx1437_cur."!cursor_debug"("PASS", "infix:sym<+&>", " at pos=", rx1437_pos)
  debug_1187:
    .return (rx1437_cur)
  rx1437_restart:
.annotate 'line', 10
    if_null rx1437_debug, debug_1188
    rx1437_cur."!cursor_debug"("NEXT", "infix:sym<+&>")
  debug_1188:
  rx1437_fail:
    (rx1437_rep, rx1437_pos, $I10, $P10) = rx1437_cur."!mark_fail"(0)
    lt rx1437_pos, -1, rx1437_done
    eq rx1437_pos, -1, rx1437_fail
    jump $I10
  rx1437_done:
    rx1437_cur."!cursor_fail"()
    if_null rx1437_debug, debug_1189
    rx1437_cur."!cursor_debug"("FAIL", "infix:sym<+&>")
  debug_1189:
    .return (rx1437_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+&>"  :nsentry("!PREFIX__infix:sym<+&>") :subid("315_1302110486.758") :method
.annotate 'line', 10
    $P1439 = self."!PREFIX__!subrule"("O", "+&")
    new $P1440, "ResizablePMCArray"
    push $P1440, $P1439
    .return ($P1440)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+>"  :subid("316_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1444_tgt
    .local int rx1444_pos
    .local int rx1444_off
    .local int rx1444_eos
    .local int rx1444_rep
    .local pmc rx1444_cur
    .local pmc rx1444_debug
    (rx1444_cur, rx1444_pos, rx1444_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1444_cur
    .local pmc match
    .lex "$/", match
    length rx1444_eos, rx1444_tgt
    gt rx1444_pos, rx1444_eos, rx1444_done
    set rx1444_off, 0
    lt rx1444_pos, 2, rx1444_start
    sub rx1444_off, rx1444_pos, 1
    substr rx1444_tgt, rx1444_tgt, rx1444_off
  rx1444_start:
    eq $I10, 1, rx1444_restart
    if_null rx1444_debug, debug_1190
    rx1444_cur."!cursor_debug"("START", "infix:sym<+>")
  debug_1190:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1448_done
    goto rxscan1448_scan
  rxscan1448_loop:
    (rx1444_pos) = rx1444_cur."from"()
    inc rx1444_pos
    rx1444_cur."!cursor_from"(rx1444_pos)
    ge rx1444_pos, rx1444_eos, rxscan1448_done
  rxscan1448_scan:
    set_addr $I10, rxscan1448_loop
    rx1444_cur."!mark_push"(0, rx1444_pos, $I10)
  rxscan1448_done:
.annotate 'line', 643
  # rx subcapture "sym"
    set_addr $I10, rxcap_1449_fail
    rx1444_cur."!mark_push"(0, rx1444_pos, $I10)
  # rx literal  "+"
    add $I11, rx1444_pos, 1
    gt $I11, rx1444_eos, rx1444_fail
    sub $I11, rx1444_pos, rx1444_off
    ord $I11, rx1444_tgt, $I11
    ne $I11, 43, rx1444_fail
    add rx1444_pos, 1
    set_addr $I10, rxcap_1449_fail
    ($I12, $I11) = rx1444_cur."!mark_peek"($I10)
    rx1444_cur."!cursor_pos"($I11)
    ($P10) = rx1444_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1444_pos, "")
    rx1444_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1449_done
  rxcap_1449_fail:
    goto rx1444_fail
  rxcap_1449_done:
  # rx subrule "O" subtype=capture negate=
    rx1444_cur."!cursor_pos"(rx1444_pos)
    $P10 = rx1444_cur."O"("%additive, :pirop<add>")
    unless $P10, rx1444_fail
    rx1444_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1444_pos = $P10."pos"()
  # rx pass
    rx1444_cur."!cursor_pass"(rx1444_pos, "infix:sym<+>")
    if_null rx1444_debug, debug_1191
    rx1444_cur."!cursor_debug"("PASS", "infix:sym<+>", " at pos=", rx1444_pos)
  debug_1191:
    .return (rx1444_cur)
  rx1444_restart:
.annotate 'line', 10
    if_null rx1444_debug, debug_1192
    rx1444_cur."!cursor_debug"("NEXT", "infix:sym<+>")
  debug_1192:
  rx1444_fail:
    (rx1444_rep, rx1444_pos, $I10, $P10) = rx1444_cur."!mark_fail"(0)
    lt rx1444_pos, -1, rx1444_done
    eq rx1444_pos, -1, rx1444_fail
    jump $I10
  rx1444_done:
    rx1444_cur."!cursor_fail"()
    if_null rx1444_debug, debug_1193
    rx1444_cur."!cursor_debug"("FAIL", "infix:sym<+>")
  debug_1193:
    .return (rx1444_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+>"  :nsentry("!PREFIX__infix:sym<+>") :subid("317_1302110486.758") :method
.annotate 'line', 10
    $P1446 = self."!PREFIX__!subrule"("O", "+")
    new $P1447, "ResizablePMCArray"
    push $P1447, $P1446
    .return ($P1447)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<->"  :subid("318_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1451_tgt
    .local int rx1451_pos
    .local int rx1451_off
    .local int rx1451_eos
    .local int rx1451_rep
    .local pmc rx1451_cur
    .local pmc rx1451_debug
    (rx1451_cur, rx1451_pos, rx1451_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1451_cur
    .local pmc match
    .lex "$/", match
    length rx1451_eos, rx1451_tgt
    gt rx1451_pos, rx1451_eos, rx1451_done
    set rx1451_off, 0
    lt rx1451_pos, 2, rx1451_start
    sub rx1451_off, rx1451_pos, 1
    substr rx1451_tgt, rx1451_tgt, rx1451_off
  rx1451_start:
    eq $I10, 1, rx1451_restart
    if_null rx1451_debug, debug_1194
    rx1451_cur."!cursor_debug"("START", "infix:sym<->")
  debug_1194:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1455_done
    goto rxscan1455_scan
  rxscan1455_loop:
    (rx1451_pos) = rx1451_cur."from"()
    inc rx1451_pos
    rx1451_cur."!cursor_from"(rx1451_pos)
    ge rx1451_pos, rx1451_eos, rxscan1455_done
  rxscan1455_scan:
    set_addr $I10, rxscan1455_loop
    rx1451_cur."!mark_push"(0, rx1451_pos, $I10)
  rxscan1455_done:
.annotate 'line', 644
  # rx subcapture "sym"
    set_addr $I10, rxcap_1456_fail
    rx1451_cur."!mark_push"(0, rx1451_pos, $I10)
  # rx literal  "-"
    add $I11, rx1451_pos, 1
    gt $I11, rx1451_eos, rx1451_fail
    sub $I11, rx1451_pos, rx1451_off
    ord $I11, rx1451_tgt, $I11
    ne $I11, 45, rx1451_fail
    add rx1451_pos, 1
    set_addr $I10, rxcap_1456_fail
    ($I12, $I11) = rx1451_cur."!mark_peek"($I10)
    rx1451_cur."!cursor_pos"($I11)
    ($P10) = rx1451_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1451_pos, "")
    rx1451_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1456_done
  rxcap_1456_fail:
    goto rx1451_fail
  rxcap_1456_done:
  # rx subrule "O" subtype=capture negate=
    rx1451_cur."!cursor_pos"(rx1451_pos)
    $P10 = rx1451_cur."O"("%additive, :pirop<sub>")
    unless $P10, rx1451_fail
    rx1451_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1451_pos = $P10."pos"()
  # rx pass
    rx1451_cur."!cursor_pass"(rx1451_pos, "infix:sym<->")
    if_null rx1451_debug, debug_1195
    rx1451_cur."!cursor_debug"("PASS", "infix:sym<->", " at pos=", rx1451_pos)
  debug_1195:
    .return (rx1451_cur)
  rx1451_restart:
.annotate 'line', 10
    if_null rx1451_debug, debug_1196
    rx1451_cur."!cursor_debug"("NEXT", "infix:sym<->")
  debug_1196:
  rx1451_fail:
    (rx1451_rep, rx1451_pos, $I10, $P10) = rx1451_cur."!mark_fail"(0)
    lt rx1451_pos, -1, rx1451_done
    eq rx1451_pos, -1, rx1451_fail
    jump $I10
  rx1451_done:
    rx1451_cur."!cursor_fail"()
    if_null rx1451_debug, debug_1197
    rx1451_cur."!cursor_debug"("FAIL", "infix:sym<->")
  debug_1197:
    .return (rx1451_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<->"  :nsentry("!PREFIX__infix:sym<->") :subid("319_1302110486.758") :method
.annotate 'line', 10
    $P1453 = self."!PREFIX__!subrule"("O", "-")
    new $P1454, "ResizablePMCArray"
    push $P1454, $P1453
    .return ($P1454)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+|>"  :subid("320_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1458_tgt
    .local int rx1458_pos
    .local int rx1458_off
    .local int rx1458_eos
    .local int rx1458_rep
    .local pmc rx1458_cur
    .local pmc rx1458_debug
    (rx1458_cur, rx1458_pos, rx1458_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1458_cur
    .local pmc match
    .lex "$/", match
    length rx1458_eos, rx1458_tgt
    gt rx1458_pos, rx1458_eos, rx1458_done
    set rx1458_off, 0
    lt rx1458_pos, 2, rx1458_start
    sub rx1458_off, rx1458_pos, 1
    substr rx1458_tgt, rx1458_tgt, rx1458_off
  rx1458_start:
    eq $I10, 1, rx1458_restart
    if_null rx1458_debug, debug_1198
    rx1458_cur."!cursor_debug"("START", "infix:sym<+|>")
  debug_1198:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1462_done
    goto rxscan1462_scan
  rxscan1462_loop:
    (rx1458_pos) = rx1458_cur."from"()
    inc rx1458_pos
    rx1458_cur."!cursor_from"(rx1458_pos)
    ge rx1458_pos, rx1458_eos, rxscan1462_done
  rxscan1462_scan:
    set_addr $I10, rxscan1462_loop
    rx1458_cur."!mark_push"(0, rx1458_pos, $I10)
  rxscan1462_done:
.annotate 'line', 645
  # rx subcapture "sym"
    set_addr $I10, rxcap_1463_fail
    rx1458_cur."!mark_push"(0, rx1458_pos, $I10)
  # rx literal  "+|"
    add $I11, rx1458_pos, 2
    gt $I11, rx1458_eos, rx1458_fail
    sub $I11, rx1458_pos, rx1458_off
    substr $S10, rx1458_tgt, $I11, 2
    ne $S10, "+|", rx1458_fail
    add rx1458_pos, 2
    set_addr $I10, rxcap_1463_fail
    ($I12, $I11) = rx1458_cur."!mark_peek"($I10)
    rx1458_cur."!cursor_pos"($I11)
    ($P10) = rx1458_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1458_pos, "")
    rx1458_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1463_done
  rxcap_1463_fail:
    goto rx1458_fail
  rxcap_1463_done:
  # rx subrule "O" subtype=capture negate=
    rx1458_cur."!cursor_pos"(rx1458_pos)
    $P10 = rx1458_cur."O"("%additive, :pirop<bor III>")
    unless $P10, rx1458_fail
    rx1458_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1458_pos = $P10."pos"()
  # rx pass
    rx1458_cur."!cursor_pass"(rx1458_pos, "infix:sym<+|>")
    if_null rx1458_debug, debug_1199
    rx1458_cur."!cursor_debug"("PASS", "infix:sym<+|>", " at pos=", rx1458_pos)
  debug_1199:
    .return (rx1458_cur)
  rx1458_restart:
.annotate 'line', 10
    if_null rx1458_debug, debug_1200
    rx1458_cur."!cursor_debug"("NEXT", "infix:sym<+|>")
  debug_1200:
  rx1458_fail:
    (rx1458_rep, rx1458_pos, $I10, $P10) = rx1458_cur."!mark_fail"(0)
    lt rx1458_pos, -1, rx1458_done
    eq rx1458_pos, -1, rx1458_fail
    jump $I10
  rx1458_done:
    rx1458_cur."!cursor_fail"()
    if_null rx1458_debug, debug_1201
    rx1458_cur."!cursor_debug"("FAIL", "infix:sym<+|>")
  debug_1201:
    .return (rx1458_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+|>"  :nsentry("!PREFIX__infix:sym<+|>") :subid("321_1302110486.758") :method
.annotate 'line', 10
    $P1460 = self."!PREFIX__!subrule"("O", "+|")
    new $P1461, "ResizablePMCArray"
    push $P1461, $P1460
    .return ($P1461)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+^>"  :subid("322_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1465_tgt
    .local int rx1465_pos
    .local int rx1465_off
    .local int rx1465_eos
    .local int rx1465_rep
    .local pmc rx1465_cur
    .local pmc rx1465_debug
    (rx1465_cur, rx1465_pos, rx1465_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1465_cur
    .local pmc match
    .lex "$/", match
    length rx1465_eos, rx1465_tgt
    gt rx1465_pos, rx1465_eos, rx1465_done
    set rx1465_off, 0
    lt rx1465_pos, 2, rx1465_start
    sub rx1465_off, rx1465_pos, 1
    substr rx1465_tgt, rx1465_tgt, rx1465_off
  rx1465_start:
    eq $I10, 1, rx1465_restart
    if_null rx1465_debug, debug_1202
    rx1465_cur."!cursor_debug"("START", "infix:sym<+^>")
  debug_1202:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1469_done
    goto rxscan1469_scan
  rxscan1469_loop:
    (rx1465_pos) = rx1465_cur."from"()
    inc rx1465_pos
    rx1465_cur."!cursor_from"(rx1465_pos)
    ge rx1465_pos, rx1465_eos, rxscan1469_done
  rxscan1469_scan:
    set_addr $I10, rxscan1469_loop
    rx1465_cur."!mark_push"(0, rx1465_pos, $I10)
  rxscan1469_done:
.annotate 'line', 646
  # rx subcapture "sym"
    set_addr $I10, rxcap_1470_fail
    rx1465_cur."!mark_push"(0, rx1465_pos, $I10)
  # rx literal  "+^"
    add $I11, rx1465_pos, 2
    gt $I11, rx1465_eos, rx1465_fail
    sub $I11, rx1465_pos, rx1465_off
    substr $S10, rx1465_tgt, $I11, 2
    ne $S10, "+^", rx1465_fail
    add rx1465_pos, 2
    set_addr $I10, rxcap_1470_fail
    ($I12, $I11) = rx1465_cur."!mark_peek"($I10)
    rx1465_cur."!cursor_pos"($I11)
    ($P10) = rx1465_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1465_pos, "")
    rx1465_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1470_done
  rxcap_1470_fail:
    goto rx1465_fail
  rxcap_1470_done:
  # rx subrule "O" subtype=capture negate=
    rx1465_cur."!cursor_pos"(rx1465_pos)
    $P10 = rx1465_cur."O"("%additive, :pirop<bxor III>")
    unless $P10, rx1465_fail
    rx1465_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1465_pos = $P10."pos"()
  # rx pass
    rx1465_cur."!cursor_pass"(rx1465_pos, "infix:sym<+^>")
    if_null rx1465_debug, debug_1203
    rx1465_cur."!cursor_debug"("PASS", "infix:sym<+^>", " at pos=", rx1465_pos)
  debug_1203:
    .return (rx1465_cur)
  rx1465_restart:
.annotate 'line', 10
    if_null rx1465_debug, debug_1204
    rx1465_cur."!cursor_debug"("NEXT", "infix:sym<+^>")
  debug_1204:
  rx1465_fail:
    (rx1465_rep, rx1465_pos, $I10, $P10) = rx1465_cur."!mark_fail"(0)
    lt rx1465_pos, -1, rx1465_done
    eq rx1465_pos, -1, rx1465_fail
    jump $I10
  rx1465_done:
    rx1465_cur."!cursor_fail"()
    if_null rx1465_debug, debug_1205
    rx1465_cur."!cursor_debug"("FAIL", "infix:sym<+^>")
  debug_1205:
    .return (rx1465_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+^>"  :nsentry("!PREFIX__infix:sym<+^>") :subid("323_1302110486.758") :method
.annotate 'line', 10
    $P1467 = self."!PREFIX__!subrule"("O", "+^")
    new $P1468, "ResizablePMCArray"
    push $P1468, $P1467
    .return ($P1468)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~>"  :subid("324_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1472_tgt
    .local int rx1472_pos
    .local int rx1472_off
    .local int rx1472_eos
    .local int rx1472_rep
    .local pmc rx1472_cur
    .local pmc rx1472_debug
    (rx1472_cur, rx1472_pos, rx1472_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1472_cur
    .local pmc match
    .lex "$/", match
    length rx1472_eos, rx1472_tgt
    gt rx1472_pos, rx1472_eos, rx1472_done
    set rx1472_off, 0
    lt rx1472_pos, 2, rx1472_start
    sub rx1472_off, rx1472_pos, 1
    substr rx1472_tgt, rx1472_tgt, rx1472_off
  rx1472_start:
    eq $I10, 1, rx1472_restart
    if_null rx1472_debug, debug_1206
    rx1472_cur."!cursor_debug"("START", "infix:sym<~>")
  debug_1206:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1476_done
    goto rxscan1476_scan
  rxscan1476_loop:
    (rx1472_pos) = rx1472_cur."from"()
    inc rx1472_pos
    rx1472_cur."!cursor_from"(rx1472_pos)
    ge rx1472_pos, rx1472_eos, rxscan1476_done
  rxscan1476_scan:
    set_addr $I10, rxscan1476_loop
    rx1472_cur."!mark_push"(0, rx1472_pos, $I10)
  rxscan1476_done:
.annotate 'line', 648
  # rx subcapture "sym"
    set_addr $I10, rxcap_1477_fail
    rx1472_cur."!mark_push"(0, rx1472_pos, $I10)
  # rx literal  "~"
    add $I11, rx1472_pos, 1
    gt $I11, rx1472_eos, rx1472_fail
    sub $I11, rx1472_pos, rx1472_off
    ord $I11, rx1472_tgt, $I11
    ne $I11, 126, rx1472_fail
    add rx1472_pos, 1
    set_addr $I10, rxcap_1477_fail
    ($I12, $I11) = rx1472_cur."!mark_peek"($I10)
    rx1472_cur."!cursor_pos"($I11)
    ($P10) = rx1472_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1472_pos, "")
    rx1472_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1477_done
  rxcap_1477_fail:
    goto rx1472_fail
  rxcap_1477_done:
  # rx subrule "O" subtype=capture negate=
    rx1472_cur."!cursor_pos"(rx1472_pos)
    $P10 = rx1472_cur."O"("%concatenation , :pirop<concat>")
    unless $P10, rx1472_fail
    rx1472_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1472_pos = $P10."pos"()
  # rx pass
    rx1472_cur."!cursor_pass"(rx1472_pos, "infix:sym<~>")
    if_null rx1472_debug, debug_1207
    rx1472_cur."!cursor_debug"("PASS", "infix:sym<~>", " at pos=", rx1472_pos)
  debug_1207:
    .return (rx1472_cur)
  rx1472_restart:
.annotate 'line', 10
    if_null rx1472_debug, debug_1208
    rx1472_cur."!cursor_debug"("NEXT", "infix:sym<~>")
  debug_1208:
  rx1472_fail:
    (rx1472_rep, rx1472_pos, $I10, $P10) = rx1472_cur."!mark_fail"(0)
    lt rx1472_pos, -1, rx1472_done
    eq rx1472_pos, -1, rx1472_fail
    jump $I10
  rx1472_done:
    rx1472_cur."!cursor_fail"()
    if_null rx1472_debug, debug_1209
    rx1472_cur."!cursor_debug"("FAIL", "infix:sym<~>")
  debug_1209:
    .return (rx1472_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~>"  :nsentry("!PREFIX__infix:sym<~>") :subid("325_1302110486.758") :method
.annotate 'line', 10
    $P1474 = self."!PREFIX__!subrule"("O", "~")
    new $P1475, "ResizablePMCArray"
    push $P1475, $P1474
    .return ($P1475)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<==>"  :subid("326_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1479_tgt
    .local int rx1479_pos
    .local int rx1479_off
    .local int rx1479_eos
    .local int rx1479_rep
    .local pmc rx1479_cur
    .local pmc rx1479_debug
    (rx1479_cur, rx1479_pos, rx1479_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1479_cur
    .local pmc match
    .lex "$/", match
    length rx1479_eos, rx1479_tgt
    gt rx1479_pos, rx1479_eos, rx1479_done
    set rx1479_off, 0
    lt rx1479_pos, 2, rx1479_start
    sub rx1479_off, rx1479_pos, 1
    substr rx1479_tgt, rx1479_tgt, rx1479_off
  rx1479_start:
    eq $I10, 1, rx1479_restart
    if_null rx1479_debug, debug_1210
    rx1479_cur."!cursor_debug"("START", "infix:sym<==>")
  debug_1210:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1483_done
    goto rxscan1483_scan
  rxscan1483_loop:
    (rx1479_pos) = rx1479_cur."from"()
    inc rx1479_pos
    rx1479_cur."!cursor_from"(rx1479_pos)
    ge rx1479_pos, rx1479_eos, rxscan1483_done
  rxscan1483_scan:
    set_addr $I10, rxscan1483_loop
    rx1479_cur."!mark_push"(0, rx1479_pos, $I10)
  rxscan1483_done:
.annotate 'line', 650
  # rx subcapture "sym"
    set_addr $I10, rxcap_1484_fail
    rx1479_cur."!mark_push"(0, rx1479_pos, $I10)
  # rx literal  "=="
    add $I11, rx1479_pos, 2
    gt $I11, rx1479_eos, rx1479_fail
    sub $I11, rx1479_pos, rx1479_off
    substr $S10, rx1479_tgt, $I11, 2
    ne $S10, "==", rx1479_fail
    add rx1479_pos, 2
    set_addr $I10, rxcap_1484_fail
    ($I12, $I11) = rx1479_cur."!mark_peek"($I10)
    rx1479_cur."!cursor_pos"($I11)
    ($P10) = rx1479_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1479_pos, "")
    rx1479_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1484_done
  rxcap_1484_fail:
    goto rx1479_fail
  rxcap_1484_done:
  # rx subrule "O" subtype=capture negate=
    rx1479_cur."!cursor_pos"(rx1479_pos)
    $P10 = rx1479_cur."O"("%relational, :pirop<iseq INn>")
    unless $P10, rx1479_fail
    rx1479_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1479_pos = $P10."pos"()
  # rx pass
    rx1479_cur."!cursor_pass"(rx1479_pos, "infix:sym<==>")
    if_null rx1479_debug, debug_1211
    rx1479_cur."!cursor_debug"("PASS", "infix:sym<==>", " at pos=", rx1479_pos)
  debug_1211:
    .return (rx1479_cur)
  rx1479_restart:
.annotate 'line', 10
    if_null rx1479_debug, debug_1212
    rx1479_cur."!cursor_debug"("NEXT", "infix:sym<==>")
  debug_1212:
  rx1479_fail:
    (rx1479_rep, rx1479_pos, $I10, $P10) = rx1479_cur."!mark_fail"(0)
    lt rx1479_pos, -1, rx1479_done
    eq rx1479_pos, -1, rx1479_fail
    jump $I10
  rx1479_done:
    rx1479_cur."!cursor_fail"()
    if_null rx1479_debug, debug_1213
    rx1479_cur."!cursor_debug"("FAIL", "infix:sym<==>")
  debug_1213:
    .return (rx1479_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<==>"  :nsentry("!PREFIX__infix:sym<==>") :subid("327_1302110486.758") :method
.annotate 'line', 10
    $P1481 = self."!PREFIX__!subrule"("O", "==")
    new $P1482, "ResizablePMCArray"
    push $P1482, $P1481
    .return ($P1482)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<!=>"  :subid("328_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1486_tgt
    .local int rx1486_pos
    .local int rx1486_off
    .local int rx1486_eos
    .local int rx1486_rep
    .local pmc rx1486_cur
    .local pmc rx1486_debug
    (rx1486_cur, rx1486_pos, rx1486_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1486_cur
    .local pmc match
    .lex "$/", match
    length rx1486_eos, rx1486_tgt
    gt rx1486_pos, rx1486_eos, rx1486_done
    set rx1486_off, 0
    lt rx1486_pos, 2, rx1486_start
    sub rx1486_off, rx1486_pos, 1
    substr rx1486_tgt, rx1486_tgt, rx1486_off
  rx1486_start:
    eq $I10, 1, rx1486_restart
    if_null rx1486_debug, debug_1214
    rx1486_cur."!cursor_debug"("START", "infix:sym<!=>")
  debug_1214:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1490_done
    goto rxscan1490_scan
  rxscan1490_loop:
    (rx1486_pos) = rx1486_cur."from"()
    inc rx1486_pos
    rx1486_cur."!cursor_from"(rx1486_pos)
    ge rx1486_pos, rx1486_eos, rxscan1490_done
  rxscan1490_scan:
    set_addr $I10, rxscan1490_loop
    rx1486_cur."!mark_push"(0, rx1486_pos, $I10)
  rxscan1490_done:
.annotate 'line', 651
  # rx subcapture "sym"
    set_addr $I10, rxcap_1491_fail
    rx1486_cur."!mark_push"(0, rx1486_pos, $I10)
  # rx literal  "!="
    add $I11, rx1486_pos, 2
    gt $I11, rx1486_eos, rx1486_fail
    sub $I11, rx1486_pos, rx1486_off
    substr $S10, rx1486_tgt, $I11, 2
    ne $S10, "!=", rx1486_fail
    add rx1486_pos, 2
    set_addr $I10, rxcap_1491_fail
    ($I12, $I11) = rx1486_cur."!mark_peek"($I10)
    rx1486_cur."!cursor_pos"($I11)
    ($P10) = rx1486_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1486_pos, "")
    rx1486_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1491_done
  rxcap_1491_fail:
    goto rx1486_fail
  rxcap_1491_done:
  # rx subrule "O" subtype=capture negate=
    rx1486_cur."!cursor_pos"(rx1486_pos)
    $P10 = rx1486_cur."O"("%relational, :pirop<isne INn>")
    unless $P10, rx1486_fail
    rx1486_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1486_pos = $P10."pos"()
  # rx pass
    rx1486_cur."!cursor_pass"(rx1486_pos, "infix:sym<!=>")
    if_null rx1486_debug, debug_1215
    rx1486_cur."!cursor_debug"("PASS", "infix:sym<!=>", " at pos=", rx1486_pos)
  debug_1215:
    .return (rx1486_cur)
  rx1486_restart:
.annotate 'line', 10
    if_null rx1486_debug, debug_1216
    rx1486_cur."!cursor_debug"("NEXT", "infix:sym<!=>")
  debug_1216:
  rx1486_fail:
    (rx1486_rep, rx1486_pos, $I10, $P10) = rx1486_cur."!mark_fail"(0)
    lt rx1486_pos, -1, rx1486_done
    eq rx1486_pos, -1, rx1486_fail
    jump $I10
  rx1486_done:
    rx1486_cur."!cursor_fail"()
    if_null rx1486_debug, debug_1217
    rx1486_cur."!cursor_debug"("FAIL", "infix:sym<!=>")
  debug_1217:
    .return (rx1486_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<!=>"  :nsentry("!PREFIX__infix:sym<!=>") :subid("329_1302110486.758") :method
.annotate 'line', 10
    $P1488 = self."!PREFIX__!subrule"("O", "!=")
    new $P1489, "ResizablePMCArray"
    push $P1489, $P1488
    .return ($P1489)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<=>"  :subid("330_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1493_tgt
    .local int rx1493_pos
    .local int rx1493_off
    .local int rx1493_eos
    .local int rx1493_rep
    .local pmc rx1493_cur
    .local pmc rx1493_debug
    (rx1493_cur, rx1493_pos, rx1493_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1493_cur
    .local pmc match
    .lex "$/", match
    length rx1493_eos, rx1493_tgt
    gt rx1493_pos, rx1493_eos, rx1493_done
    set rx1493_off, 0
    lt rx1493_pos, 2, rx1493_start
    sub rx1493_off, rx1493_pos, 1
    substr rx1493_tgt, rx1493_tgt, rx1493_off
  rx1493_start:
    eq $I10, 1, rx1493_restart
    if_null rx1493_debug, debug_1218
    rx1493_cur."!cursor_debug"("START", "infix:sym<<=>")
  debug_1218:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1497_done
    goto rxscan1497_scan
  rxscan1497_loop:
    (rx1493_pos) = rx1493_cur."from"()
    inc rx1493_pos
    rx1493_cur."!cursor_from"(rx1493_pos)
    ge rx1493_pos, rx1493_eos, rxscan1497_done
  rxscan1497_scan:
    set_addr $I10, rxscan1497_loop
    rx1493_cur."!mark_push"(0, rx1493_pos, $I10)
  rxscan1497_done:
.annotate 'line', 652
  # rx subcapture "sym"
    set_addr $I10, rxcap_1498_fail
    rx1493_cur."!mark_push"(0, rx1493_pos, $I10)
  # rx literal  "<="
    add $I11, rx1493_pos, 2
    gt $I11, rx1493_eos, rx1493_fail
    sub $I11, rx1493_pos, rx1493_off
    substr $S10, rx1493_tgt, $I11, 2
    ne $S10, "<=", rx1493_fail
    add rx1493_pos, 2
    set_addr $I10, rxcap_1498_fail
    ($I12, $I11) = rx1493_cur."!mark_peek"($I10)
    rx1493_cur."!cursor_pos"($I11)
    ($P10) = rx1493_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1493_pos, "")
    rx1493_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1498_done
  rxcap_1498_fail:
    goto rx1493_fail
  rxcap_1498_done:
  # rx subrule "O" subtype=capture negate=
    rx1493_cur."!cursor_pos"(rx1493_pos)
    $P10 = rx1493_cur."O"("%relational, :pirop<isle INn>")
    unless $P10, rx1493_fail
    rx1493_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1493_pos = $P10."pos"()
  # rx pass
    rx1493_cur."!cursor_pass"(rx1493_pos, "infix:sym<<=>")
    if_null rx1493_debug, debug_1219
    rx1493_cur."!cursor_debug"("PASS", "infix:sym<<=>", " at pos=", rx1493_pos)
  debug_1219:
    .return (rx1493_cur)
  rx1493_restart:
.annotate 'line', 10
    if_null rx1493_debug, debug_1220
    rx1493_cur."!cursor_debug"("NEXT", "infix:sym<<=>")
  debug_1220:
  rx1493_fail:
    (rx1493_rep, rx1493_pos, $I10, $P10) = rx1493_cur."!mark_fail"(0)
    lt rx1493_pos, -1, rx1493_done
    eq rx1493_pos, -1, rx1493_fail
    jump $I10
  rx1493_done:
    rx1493_cur."!cursor_fail"()
    if_null rx1493_debug, debug_1221
    rx1493_cur."!cursor_debug"("FAIL", "infix:sym<<=>")
  debug_1221:
    .return (rx1493_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<=>"  :nsentry("!PREFIX__infix:sym<<=>") :subid("331_1302110486.758") :method
.annotate 'line', 10
    $P1495 = self."!PREFIX__!subrule"("O", "<=")
    new $P1496, "ResizablePMCArray"
    push $P1496, $P1495
    .return ($P1496)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>=>"  :subid("332_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1500_tgt
    .local int rx1500_pos
    .local int rx1500_off
    .local int rx1500_eos
    .local int rx1500_rep
    .local pmc rx1500_cur
    .local pmc rx1500_debug
    (rx1500_cur, rx1500_pos, rx1500_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1500_cur
    .local pmc match
    .lex "$/", match
    length rx1500_eos, rx1500_tgt
    gt rx1500_pos, rx1500_eos, rx1500_done
    set rx1500_off, 0
    lt rx1500_pos, 2, rx1500_start
    sub rx1500_off, rx1500_pos, 1
    substr rx1500_tgt, rx1500_tgt, rx1500_off
  rx1500_start:
    eq $I10, 1, rx1500_restart
    if_null rx1500_debug, debug_1222
    rx1500_cur."!cursor_debug"("START", "infix:sym<>=>")
  debug_1222:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1504_done
    goto rxscan1504_scan
  rxscan1504_loop:
    (rx1500_pos) = rx1500_cur."from"()
    inc rx1500_pos
    rx1500_cur."!cursor_from"(rx1500_pos)
    ge rx1500_pos, rx1500_eos, rxscan1504_done
  rxscan1504_scan:
    set_addr $I10, rxscan1504_loop
    rx1500_cur."!mark_push"(0, rx1500_pos, $I10)
  rxscan1504_done:
.annotate 'line', 653
  # rx subcapture "sym"
    set_addr $I10, rxcap_1505_fail
    rx1500_cur."!mark_push"(0, rx1500_pos, $I10)
  # rx literal  ">="
    add $I11, rx1500_pos, 2
    gt $I11, rx1500_eos, rx1500_fail
    sub $I11, rx1500_pos, rx1500_off
    substr $S10, rx1500_tgt, $I11, 2
    ne $S10, ">=", rx1500_fail
    add rx1500_pos, 2
    set_addr $I10, rxcap_1505_fail
    ($I12, $I11) = rx1500_cur."!mark_peek"($I10)
    rx1500_cur."!cursor_pos"($I11)
    ($P10) = rx1500_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1500_pos, "")
    rx1500_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1505_done
  rxcap_1505_fail:
    goto rx1500_fail
  rxcap_1505_done:
  # rx subrule "O" subtype=capture negate=
    rx1500_cur."!cursor_pos"(rx1500_pos)
    $P10 = rx1500_cur."O"("%relational, :pirop<isge INn>")
    unless $P10, rx1500_fail
    rx1500_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1500_pos = $P10."pos"()
  # rx pass
    rx1500_cur."!cursor_pass"(rx1500_pos, "infix:sym<>=>")
    if_null rx1500_debug, debug_1223
    rx1500_cur."!cursor_debug"("PASS", "infix:sym<>=>", " at pos=", rx1500_pos)
  debug_1223:
    .return (rx1500_cur)
  rx1500_restart:
.annotate 'line', 10
    if_null rx1500_debug, debug_1224
    rx1500_cur."!cursor_debug"("NEXT", "infix:sym<>=>")
  debug_1224:
  rx1500_fail:
    (rx1500_rep, rx1500_pos, $I10, $P10) = rx1500_cur."!mark_fail"(0)
    lt rx1500_pos, -1, rx1500_done
    eq rx1500_pos, -1, rx1500_fail
    jump $I10
  rx1500_done:
    rx1500_cur."!cursor_fail"()
    if_null rx1500_debug, debug_1225
    rx1500_cur."!cursor_debug"("FAIL", "infix:sym<>=>")
  debug_1225:
    .return (rx1500_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>=>"  :nsentry("!PREFIX__infix:sym<>=>") :subid("333_1302110486.758") :method
.annotate 'line', 10
    $P1502 = self."!PREFIX__!subrule"("O", ">=")
    new $P1503, "ResizablePMCArray"
    push $P1503, $P1502
    .return ($P1503)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<>"  :subid("334_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1507_tgt
    .local int rx1507_pos
    .local int rx1507_off
    .local int rx1507_eos
    .local int rx1507_rep
    .local pmc rx1507_cur
    .local pmc rx1507_debug
    (rx1507_cur, rx1507_pos, rx1507_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1507_cur
    .local pmc match
    .lex "$/", match
    length rx1507_eos, rx1507_tgt
    gt rx1507_pos, rx1507_eos, rx1507_done
    set rx1507_off, 0
    lt rx1507_pos, 2, rx1507_start
    sub rx1507_off, rx1507_pos, 1
    substr rx1507_tgt, rx1507_tgt, rx1507_off
  rx1507_start:
    eq $I10, 1, rx1507_restart
    if_null rx1507_debug, debug_1226
    rx1507_cur."!cursor_debug"("START", "infix:sym<<>")
  debug_1226:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1511_done
    goto rxscan1511_scan
  rxscan1511_loop:
    (rx1507_pos) = rx1507_cur."from"()
    inc rx1507_pos
    rx1507_cur."!cursor_from"(rx1507_pos)
    ge rx1507_pos, rx1507_eos, rxscan1511_done
  rxscan1511_scan:
    set_addr $I10, rxscan1511_loop
    rx1507_cur."!mark_push"(0, rx1507_pos, $I10)
  rxscan1511_done:
.annotate 'line', 654
  # rx subcapture "sym"
    set_addr $I10, rxcap_1512_fail
    rx1507_cur."!mark_push"(0, rx1507_pos, $I10)
  # rx literal  "<"
    add $I11, rx1507_pos, 1
    gt $I11, rx1507_eos, rx1507_fail
    sub $I11, rx1507_pos, rx1507_off
    ord $I11, rx1507_tgt, $I11
    ne $I11, 60, rx1507_fail
    add rx1507_pos, 1
    set_addr $I10, rxcap_1512_fail
    ($I12, $I11) = rx1507_cur."!mark_peek"($I10)
    rx1507_cur."!cursor_pos"($I11)
    ($P10) = rx1507_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1507_pos, "")
    rx1507_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1512_done
  rxcap_1512_fail:
    goto rx1507_fail
  rxcap_1512_done:
  # rx subrule "O" subtype=capture negate=
    rx1507_cur."!cursor_pos"(rx1507_pos)
    $P10 = rx1507_cur."O"("%relational, :pirop<islt INn>")
    unless $P10, rx1507_fail
    rx1507_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1507_pos = $P10."pos"()
  # rx pass
    rx1507_cur."!cursor_pass"(rx1507_pos, "infix:sym<<>")
    if_null rx1507_debug, debug_1227
    rx1507_cur."!cursor_debug"("PASS", "infix:sym<<>", " at pos=", rx1507_pos)
  debug_1227:
    .return (rx1507_cur)
  rx1507_restart:
.annotate 'line', 10
    if_null rx1507_debug, debug_1228
    rx1507_cur."!cursor_debug"("NEXT", "infix:sym<<>")
  debug_1228:
  rx1507_fail:
    (rx1507_rep, rx1507_pos, $I10, $P10) = rx1507_cur."!mark_fail"(0)
    lt rx1507_pos, -1, rx1507_done
    eq rx1507_pos, -1, rx1507_fail
    jump $I10
  rx1507_done:
    rx1507_cur."!cursor_fail"()
    if_null rx1507_debug, debug_1229
    rx1507_cur."!cursor_debug"("FAIL", "infix:sym<<>")
  debug_1229:
    .return (rx1507_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<>"  :nsentry("!PREFIX__infix:sym<<>") :subid("335_1302110486.758") :method
.annotate 'line', 10
    $P1509 = self."!PREFIX__!subrule"("O", "<")
    new $P1510, "ResizablePMCArray"
    push $P1510, $P1509
    .return ($P1510)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>>"  :subid("336_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1514_tgt
    .local int rx1514_pos
    .local int rx1514_off
    .local int rx1514_eos
    .local int rx1514_rep
    .local pmc rx1514_cur
    .local pmc rx1514_debug
    (rx1514_cur, rx1514_pos, rx1514_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1514_cur
    .local pmc match
    .lex "$/", match
    length rx1514_eos, rx1514_tgt
    gt rx1514_pos, rx1514_eos, rx1514_done
    set rx1514_off, 0
    lt rx1514_pos, 2, rx1514_start
    sub rx1514_off, rx1514_pos, 1
    substr rx1514_tgt, rx1514_tgt, rx1514_off
  rx1514_start:
    eq $I10, 1, rx1514_restart
    if_null rx1514_debug, debug_1230
    rx1514_cur."!cursor_debug"("START", "infix:sym<>>")
  debug_1230:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1518_done
    goto rxscan1518_scan
  rxscan1518_loop:
    (rx1514_pos) = rx1514_cur."from"()
    inc rx1514_pos
    rx1514_cur."!cursor_from"(rx1514_pos)
    ge rx1514_pos, rx1514_eos, rxscan1518_done
  rxscan1518_scan:
    set_addr $I10, rxscan1518_loop
    rx1514_cur."!mark_push"(0, rx1514_pos, $I10)
  rxscan1518_done:
.annotate 'line', 655
  # rx subcapture "sym"
    set_addr $I10, rxcap_1519_fail
    rx1514_cur."!mark_push"(0, rx1514_pos, $I10)
  # rx literal  ">"
    add $I11, rx1514_pos, 1
    gt $I11, rx1514_eos, rx1514_fail
    sub $I11, rx1514_pos, rx1514_off
    ord $I11, rx1514_tgt, $I11
    ne $I11, 62, rx1514_fail
    add rx1514_pos, 1
    set_addr $I10, rxcap_1519_fail
    ($I12, $I11) = rx1514_cur."!mark_peek"($I10)
    rx1514_cur."!cursor_pos"($I11)
    ($P10) = rx1514_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1514_pos, "")
    rx1514_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1519_done
  rxcap_1519_fail:
    goto rx1514_fail
  rxcap_1519_done:
  # rx subrule "O" subtype=capture negate=
    rx1514_cur."!cursor_pos"(rx1514_pos)
    $P10 = rx1514_cur."O"("%relational, :pirop<isgt INn>")
    unless $P10, rx1514_fail
    rx1514_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1514_pos = $P10."pos"()
  # rx pass
    rx1514_cur."!cursor_pass"(rx1514_pos, "infix:sym<>>")
    if_null rx1514_debug, debug_1231
    rx1514_cur."!cursor_debug"("PASS", "infix:sym<>>", " at pos=", rx1514_pos)
  debug_1231:
    .return (rx1514_cur)
  rx1514_restart:
.annotate 'line', 10
    if_null rx1514_debug, debug_1232
    rx1514_cur."!cursor_debug"("NEXT", "infix:sym<>>")
  debug_1232:
  rx1514_fail:
    (rx1514_rep, rx1514_pos, $I10, $P10) = rx1514_cur."!mark_fail"(0)
    lt rx1514_pos, -1, rx1514_done
    eq rx1514_pos, -1, rx1514_fail
    jump $I10
  rx1514_done:
    rx1514_cur."!cursor_fail"()
    if_null rx1514_debug, debug_1233
    rx1514_cur."!cursor_debug"("FAIL", "infix:sym<>>")
  debug_1233:
    .return (rx1514_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>>"  :nsentry("!PREFIX__infix:sym<>>") :subid("337_1302110486.758") :method
.annotate 'line', 10
    $P1516 = self."!PREFIX__!subrule"("O", ">")
    new $P1517, "ResizablePMCArray"
    push $P1517, $P1516
    .return ($P1517)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<eq>"  :subid("338_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1521_tgt
    .local int rx1521_pos
    .local int rx1521_off
    .local int rx1521_eos
    .local int rx1521_rep
    .local pmc rx1521_cur
    .local pmc rx1521_debug
    (rx1521_cur, rx1521_pos, rx1521_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1521_cur
    .local pmc match
    .lex "$/", match
    length rx1521_eos, rx1521_tgt
    gt rx1521_pos, rx1521_eos, rx1521_done
    set rx1521_off, 0
    lt rx1521_pos, 2, rx1521_start
    sub rx1521_off, rx1521_pos, 1
    substr rx1521_tgt, rx1521_tgt, rx1521_off
  rx1521_start:
    eq $I10, 1, rx1521_restart
    if_null rx1521_debug, debug_1234
    rx1521_cur."!cursor_debug"("START", "infix:sym<eq>")
  debug_1234:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1525_done
    goto rxscan1525_scan
  rxscan1525_loop:
    (rx1521_pos) = rx1521_cur."from"()
    inc rx1521_pos
    rx1521_cur."!cursor_from"(rx1521_pos)
    ge rx1521_pos, rx1521_eos, rxscan1525_done
  rxscan1525_scan:
    set_addr $I10, rxscan1525_loop
    rx1521_cur."!mark_push"(0, rx1521_pos, $I10)
  rxscan1525_done:
.annotate 'line', 656
  # rx subcapture "sym"
    set_addr $I10, rxcap_1526_fail
    rx1521_cur."!mark_push"(0, rx1521_pos, $I10)
  # rx literal  "eq"
    add $I11, rx1521_pos, 2
    gt $I11, rx1521_eos, rx1521_fail
    sub $I11, rx1521_pos, rx1521_off
    substr $S10, rx1521_tgt, $I11, 2
    ne $S10, "eq", rx1521_fail
    add rx1521_pos, 2
    set_addr $I10, rxcap_1526_fail
    ($I12, $I11) = rx1521_cur."!mark_peek"($I10)
    rx1521_cur."!cursor_pos"($I11)
    ($P10) = rx1521_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1521_pos, "")
    rx1521_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1526_done
  rxcap_1526_fail:
    goto rx1521_fail
  rxcap_1526_done:
  # rx subrule "O" subtype=capture negate=
    rx1521_cur."!cursor_pos"(rx1521_pos)
    $P10 = rx1521_cur."O"("%relational, :pirop<iseq ISs>")
    unless $P10, rx1521_fail
    rx1521_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1521_pos = $P10."pos"()
  # rx pass
    rx1521_cur."!cursor_pass"(rx1521_pos, "infix:sym<eq>")
    if_null rx1521_debug, debug_1235
    rx1521_cur."!cursor_debug"("PASS", "infix:sym<eq>", " at pos=", rx1521_pos)
  debug_1235:
    .return (rx1521_cur)
  rx1521_restart:
.annotate 'line', 10
    if_null rx1521_debug, debug_1236
    rx1521_cur."!cursor_debug"("NEXT", "infix:sym<eq>")
  debug_1236:
  rx1521_fail:
    (rx1521_rep, rx1521_pos, $I10, $P10) = rx1521_cur."!mark_fail"(0)
    lt rx1521_pos, -1, rx1521_done
    eq rx1521_pos, -1, rx1521_fail
    jump $I10
  rx1521_done:
    rx1521_cur."!cursor_fail"()
    if_null rx1521_debug, debug_1237
    rx1521_cur."!cursor_debug"("FAIL", "infix:sym<eq>")
  debug_1237:
    .return (rx1521_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<eq>"  :nsentry("!PREFIX__infix:sym<eq>") :subid("339_1302110486.758") :method
.annotate 'line', 10
    $P1523 = self."!PREFIX__!subrule"("O", "eq")
    new $P1524, "ResizablePMCArray"
    push $P1524, $P1523
    .return ($P1524)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ne>"  :subid("340_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1528_tgt
    .local int rx1528_pos
    .local int rx1528_off
    .local int rx1528_eos
    .local int rx1528_rep
    .local pmc rx1528_cur
    .local pmc rx1528_debug
    (rx1528_cur, rx1528_pos, rx1528_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1528_cur
    .local pmc match
    .lex "$/", match
    length rx1528_eos, rx1528_tgt
    gt rx1528_pos, rx1528_eos, rx1528_done
    set rx1528_off, 0
    lt rx1528_pos, 2, rx1528_start
    sub rx1528_off, rx1528_pos, 1
    substr rx1528_tgt, rx1528_tgt, rx1528_off
  rx1528_start:
    eq $I10, 1, rx1528_restart
    if_null rx1528_debug, debug_1238
    rx1528_cur."!cursor_debug"("START", "infix:sym<ne>")
  debug_1238:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1532_done
    goto rxscan1532_scan
  rxscan1532_loop:
    (rx1528_pos) = rx1528_cur."from"()
    inc rx1528_pos
    rx1528_cur."!cursor_from"(rx1528_pos)
    ge rx1528_pos, rx1528_eos, rxscan1532_done
  rxscan1532_scan:
    set_addr $I10, rxscan1532_loop
    rx1528_cur."!mark_push"(0, rx1528_pos, $I10)
  rxscan1532_done:
.annotate 'line', 657
  # rx subcapture "sym"
    set_addr $I10, rxcap_1533_fail
    rx1528_cur."!mark_push"(0, rx1528_pos, $I10)
  # rx literal  "ne"
    add $I11, rx1528_pos, 2
    gt $I11, rx1528_eos, rx1528_fail
    sub $I11, rx1528_pos, rx1528_off
    substr $S10, rx1528_tgt, $I11, 2
    ne $S10, "ne", rx1528_fail
    add rx1528_pos, 2
    set_addr $I10, rxcap_1533_fail
    ($I12, $I11) = rx1528_cur."!mark_peek"($I10)
    rx1528_cur."!cursor_pos"($I11)
    ($P10) = rx1528_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1528_pos, "")
    rx1528_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1533_done
  rxcap_1533_fail:
    goto rx1528_fail
  rxcap_1533_done:
  # rx subrule "O" subtype=capture negate=
    rx1528_cur."!cursor_pos"(rx1528_pos)
    $P10 = rx1528_cur."O"("%relational, :pirop<isne ISs>")
    unless $P10, rx1528_fail
    rx1528_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1528_pos = $P10."pos"()
  # rx pass
    rx1528_cur."!cursor_pass"(rx1528_pos, "infix:sym<ne>")
    if_null rx1528_debug, debug_1239
    rx1528_cur."!cursor_debug"("PASS", "infix:sym<ne>", " at pos=", rx1528_pos)
  debug_1239:
    .return (rx1528_cur)
  rx1528_restart:
.annotate 'line', 10
    if_null rx1528_debug, debug_1240
    rx1528_cur."!cursor_debug"("NEXT", "infix:sym<ne>")
  debug_1240:
  rx1528_fail:
    (rx1528_rep, rx1528_pos, $I10, $P10) = rx1528_cur."!mark_fail"(0)
    lt rx1528_pos, -1, rx1528_done
    eq rx1528_pos, -1, rx1528_fail
    jump $I10
  rx1528_done:
    rx1528_cur."!cursor_fail"()
    if_null rx1528_debug, debug_1241
    rx1528_cur."!cursor_debug"("FAIL", "infix:sym<ne>")
  debug_1241:
    .return (rx1528_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ne>"  :nsentry("!PREFIX__infix:sym<ne>") :subid("341_1302110486.758") :method
.annotate 'line', 10
    $P1530 = self."!PREFIX__!subrule"("O", "ne")
    new $P1531, "ResizablePMCArray"
    push $P1531, $P1530
    .return ($P1531)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<le>"  :subid("342_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1535_tgt
    .local int rx1535_pos
    .local int rx1535_off
    .local int rx1535_eos
    .local int rx1535_rep
    .local pmc rx1535_cur
    .local pmc rx1535_debug
    (rx1535_cur, rx1535_pos, rx1535_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1535_cur
    .local pmc match
    .lex "$/", match
    length rx1535_eos, rx1535_tgt
    gt rx1535_pos, rx1535_eos, rx1535_done
    set rx1535_off, 0
    lt rx1535_pos, 2, rx1535_start
    sub rx1535_off, rx1535_pos, 1
    substr rx1535_tgt, rx1535_tgt, rx1535_off
  rx1535_start:
    eq $I10, 1, rx1535_restart
    if_null rx1535_debug, debug_1242
    rx1535_cur."!cursor_debug"("START", "infix:sym<le>")
  debug_1242:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1539_done
    goto rxscan1539_scan
  rxscan1539_loop:
    (rx1535_pos) = rx1535_cur."from"()
    inc rx1535_pos
    rx1535_cur."!cursor_from"(rx1535_pos)
    ge rx1535_pos, rx1535_eos, rxscan1539_done
  rxscan1539_scan:
    set_addr $I10, rxscan1539_loop
    rx1535_cur."!mark_push"(0, rx1535_pos, $I10)
  rxscan1539_done:
.annotate 'line', 658
  # rx subcapture "sym"
    set_addr $I10, rxcap_1540_fail
    rx1535_cur."!mark_push"(0, rx1535_pos, $I10)
  # rx literal  "le"
    add $I11, rx1535_pos, 2
    gt $I11, rx1535_eos, rx1535_fail
    sub $I11, rx1535_pos, rx1535_off
    substr $S10, rx1535_tgt, $I11, 2
    ne $S10, "le", rx1535_fail
    add rx1535_pos, 2
    set_addr $I10, rxcap_1540_fail
    ($I12, $I11) = rx1535_cur."!mark_peek"($I10)
    rx1535_cur."!cursor_pos"($I11)
    ($P10) = rx1535_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1535_pos, "")
    rx1535_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1540_done
  rxcap_1540_fail:
    goto rx1535_fail
  rxcap_1540_done:
  # rx subrule "O" subtype=capture negate=
    rx1535_cur."!cursor_pos"(rx1535_pos)
    $P10 = rx1535_cur."O"("%relational, :pirop<isle ISs>")
    unless $P10, rx1535_fail
    rx1535_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1535_pos = $P10."pos"()
  # rx pass
    rx1535_cur."!cursor_pass"(rx1535_pos, "infix:sym<le>")
    if_null rx1535_debug, debug_1243
    rx1535_cur."!cursor_debug"("PASS", "infix:sym<le>", " at pos=", rx1535_pos)
  debug_1243:
    .return (rx1535_cur)
  rx1535_restart:
.annotate 'line', 10
    if_null rx1535_debug, debug_1244
    rx1535_cur."!cursor_debug"("NEXT", "infix:sym<le>")
  debug_1244:
  rx1535_fail:
    (rx1535_rep, rx1535_pos, $I10, $P10) = rx1535_cur."!mark_fail"(0)
    lt rx1535_pos, -1, rx1535_done
    eq rx1535_pos, -1, rx1535_fail
    jump $I10
  rx1535_done:
    rx1535_cur."!cursor_fail"()
    if_null rx1535_debug, debug_1245
    rx1535_cur."!cursor_debug"("FAIL", "infix:sym<le>")
  debug_1245:
    .return (rx1535_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<le>"  :nsentry("!PREFIX__infix:sym<le>") :subid("343_1302110486.758") :method
.annotate 'line', 10
    $P1537 = self."!PREFIX__!subrule"("O", "le")
    new $P1538, "ResizablePMCArray"
    push $P1538, $P1537
    .return ($P1538)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ge>"  :subid("344_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1542_tgt
    .local int rx1542_pos
    .local int rx1542_off
    .local int rx1542_eos
    .local int rx1542_rep
    .local pmc rx1542_cur
    .local pmc rx1542_debug
    (rx1542_cur, rx1542_pos, rx1542_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1542_cur
    .local pmc match
    .lex "$/", match
    length rx1542_eos, rx1542_tgt
    gt rx1542_pos, rx1542_eos, rx1542_done
    set rx1542_off, 0
    lt rx1542_pos, 2, rx1542_start
    sub rx1542_off, rx1542_pos, 1
    substr rx1542_tgt, rx1542_tgt, rx1542_off
  rx1542_start:
    eq $I10, 1, rx1542_restart
    if_null rx1542_debug, debug_1246
    rx1542_cur."!cursor_debug"("START", "infix:sym<ge>")
  debug_1246:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1546_done
    goto rxscan1546_scan
  rxscan1546_loop:
    (rx1542_pos) = rx1542_cur."from"()
    inc rx1542_pos
    rx1542_cur."!cursor_from"(rx1542_pos)
    ge rx1542_pos, rx1542_eos, rxscan1546_done
  rxscan1546_scan:
    set_addr $I10, rxscan1546_loop
    rx1542_cur."!mark_push"(0, rx1542_pos, $I10)
  rxscan1546_done:
.annotate 'line', 659
  # rx subcapture "sym"
    set_addr $I10, rxcap_1547_fail
    rx1542_cur."!mark_push"(0, rx1542_pos, $I10)
  # rx literal  "ge"
    add $I11, rx1542_pos, 2
    gt $I11, rx1542_eos, rx1542_fail
    sub $I11, rx1542_pos, rx1542_off
    substr $S10, rx1542_tgt, $I11, 2
    ne $S10, "ge", rx1542_fail
    add rx1542_pos, 2
    set_addr $I10, rxcap_1547_fail
    ($I12, $I11) = rx1542_cur."!mark_peek"($I10)
    rx1542_cur."!cursor_pos"($I11)
    ($P10) = rx1542_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1542_pos, "")
    rx1542_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1547_done
  rxcap_1547_fail:
    goto rx1542_fail
  rxcap_1547_done:
  # rx subrule "O" subtype=capture negate=
    rx1542_cur."!cursor_pos"(rx1542_pos)
    $P10 = rx1542_cur."O"("%relational, :pirop<isge ISs>")
    unless $P10, rx1542_fail
    rx1542_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1542_pos = $P10."pos"()
  # rx pass
    rx1542_cur."!cursor_pass"(rx1542_pos, "infix:sym<ge>")
    if_null rx1542_debug, debug_1247
    rx1542_cur."!cursor_debug"("PASS", "infix:sym<ge>", " at pos=", rx1542_pos)
  debug_1247:
    .return (rx1542_cur)
  rx1542_restart:
.annotate 'line', 10
    if_null rx1542_debug, debug_1248
    rx1542_cur."!cursor_debug"("NEXT", "infix:sym<ge>")
  debug_1248:
  rx1542_fail:
    (rx1542_rep, rx1542_pos, $I10, $P10) = rx1542_cur."!mark_fail"(0)
    lt rx1542_pos, -1, rx1542_done
    eq rx1542_pos, -1, rx1542_fail
    jump $I10
  rx1542_done:
    rx1542_cur."!cursor_fail"()
    if_null rx1542_debug, debug_1249
    rx1542_cur."!cursor_debug"("FAIL", "infix:sym<ge>")
  debug_1249:
    .return (rx1542_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ge>"  :nsentry("!PREFIX__infix:sym<ge>") :subid("345_1302110486.758") :method
.annotate 'line', 10
    $P1544 = self."!PREFIX__!subrule"("O", "ge")
    new $P1545, "ResizablePMCArray"
    push $P1545, $P1544
    .return ($P1545)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<lt>"  :subid("346_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1549_tgt
    .local int rx1549_pos
    .local int rx1549_off
    .local int rx1549_eos
    .local int rx1549_rep
    .local pmc rx1549_cur
    .local pmc rx1549_debug
    (rx1549_cur, rx1549_pos, rx1549_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1549_cur
    .local pmc match
    .lex "$/", match
    length rx1549_eos, rx1549_tgt
    gt rx1549_pos, rx1549_eos, rx1549_done
    set rx1549_off, 0
    lt rx1549_pos, 2, rx1549_start
    sub rx1549_off, rx1549_pos, 1
    substr rx1549_tgt, rx1549_tgt, rx1549_off
  rx1549_start:
    eq $I10, 1, rx1549_restart
    if_null rx1549_debug, debug_1250
    rx1549_cur."!cursor_debug"("START", "infix:sym<lt>")
  debug_1250:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1553_done
    goto rxscan1553_scan
  rxscan1553_loop:
    (rx1549_pos) = rx1549_cur."from"()
    inc rx1549_pos
    rx1549_cur."!cursor_from"(rx1549_pos)
    ge rx1549_pos, rx1549_eos, rxscan1553_done
  rxscan1553_scan:
    set_addr $I10, rxscan1553_loop
    rx1549_cur."!mark_push"(0, rx1549_pos, $I10)
  rxscan1553_done:
.annotate 'line', 660
  # rx subcapture "sym"
    set_addr $I10, rxcap_1554_fail
    rx1549_cur."!mark_push"(0, rx1549_pos, $I10)
  # rx literal  "lt"
    add $I11, rx1549_pos, 2
    gt $I11, rx1549_eos, rx1549_fail
    sub $I11, rx1549_pos, rx1549_off
    substr $S10, rx1549_tgt, $I11, 2
    ne $S10, "lt", rx1549_fail
    add rx1549_pos, 2
    set_addr $I10, rxcap_1554_fail
    ($I12, $I11) = rx1549_cur."!mark_peek"($I10)
    rx1549_cur."!cursor_pos"($I11)
    ($P10) = rx1549_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1549_pos, "")
    rx1549_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1554_done
  rxcap_1554_fail:
    goto rx1549_fail
  rxcap_1554_done:
  # rx subrule "O" subtype=capture negate=
    rx1549_cur."!cursor_pos"(rx1549_pos)
    $P10 = rx1549_cur."O"("%relational, :pirop<islt ISs>")
    unless $P10, rx1549_fail
    rx1549_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1549_pos = $P10."pos"()
  # rx pass
    rx1549_cur."!cursor_pass"(rx1549_pos, "infix:sym<lt>")
    if_null rx1549_debug, debug_1251
    rx1549_cur."!cursor_debug"("PASS", "infix:sym<lt>", " at pos=", rx1549_pos)
  debug_1251:
    .return (rx1549_cur)
  rx1549_restart:
.annotate 'line', 10
    if_null rx1549_debug, debug_1252
    rx1549_cur."!cursor_debug"("NEXT", "infix:sym<lt>")
  debug_1252:
  rx1549_fail:
    (rx1549_rep, rx1549_pos, $I10, $P10) = rx1549_cur."!mark_fail"(0)
    lt rx1549_pos, -1, rx1549_done
    eq rx1549_pos, -1, rx1549_fail
    jump $I10
  rx1549_done:
    rx1549_cur."!cursor_fail"()
    if_null rx1549_debug, debug_1253
    rx1549_cur."!cursor_debug"("FAIL", "infix:sym<lt>")
  debug_1253:
    .return (rx1549_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<lt>"  :nsentry("!PREFIX__infix:sym<lt>") :subid("347_1302110486.758") :method
.annotate 'line', 10
    $P1551 = self."!PREFIX__!subrule"("O", "lt")
    new $P1552, "ResizablePMCArray"
    push $P1552, $P1551
    .return ($P1552)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<gt>"  :subid("348_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1556_tgt
    .local int rx1556_pos
    .local int rx1556_off
    .local int rx1556_eos
    .local int rx1556_rep
    .local pmc rx1556_cur
    .local pmc rx1556_debug
    (rx1556_cur, rx1556_pos, rx1556_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1556_cur
    .local pmc match
    .lex "$/", match
    length rx1556_eos, rx1556_tgt
    gt rx1556_pos, rx1556_eos, rx1556_done
    set rx1556_off, 0
    lt rx1556_pos, 2, rx1556_start
    sub rx1556_off, rx1556_pos, 1
    substr rx1556_tgt, rx1556_tgt, rx1556_off
  rx1556_start:
    eq $I10, 1, rx1556_restart
    if_null rx1556_debug, debug_1254
    rx1556_cur."!cursor_debug"("START", "infix:sym<gt>")
  debug_1254:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1560_done
    goto rxscan1560_scan
  rxscan1560_loop:
    (rx1556_pos) = rx1556_cur."from"()
    inc rx1556_pos
    rx1556_cur."!cursor_from"(rx1556_pos)
    ge rx1556_pos, rx1556_eos, rxscan1560_done
  rxscan1560_scan:
    set_addr $I10, rxscan1560_loop
    rx1556_cur."!mark_push"(0, rx1556_pos, $I10)
  rxscan1560_done:
.annotate 'line', 661
  # rx subcapture "sym"
    set_addr $I10, rxcap_1561_fail
    rx1556_cur."!mark_push"(0, rx1556_pos, $I10)
  # rx literal  "gt"
    add $I11, rx1556_pos, 2
    gt $I11, rx1556_eos, rx1556_fail
    sub $I11, rx1556_pos, rx1556_off
    substr $S10, rx1556_tgt, $I11, 2
    ne $S10, "gt", rx1556_fail
    add rx1556_pos, 2
    set_addr $I10, rxcap_1561_fail
    ($I12, $I11) = rx1556_cur."!mark_peek"($I10)
    rx1556_cur."!cursor_pos"($I11)
    ($P10) = rx1556_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1556_pos, "")
    rx1556_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1561_done
  rxcap_1561_fail:
    goto rx1556_fail
  rxcap_1561_done:
  # rx subrule "O" subtype=capture negate=
    rx1556_cur."!cursor_pos"(rx1556_pos)
    $P10 = rx1556_cur."O"("%relational, :pirop<isgt ISs>")
    unless $P10, rx1556_fail
    rx1556_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1556_pos = $P10."pos"()
  # rx pass
    rx1556_cur."!cursor_pass"(rx1556_pos, "infix:sym<gt>")
    if_null rx1556_debug, debug_1255
    rx1556_cur."!cursor_debug"("PASS", "infix:sym<gt>", " at pos=", rx1556_pos)
  debug_1255:
    .return (rx1556_cur)
  rx1556_restart:
.annotate 'line', 10
    if_null rx1556_debug, debug_1256
    rx1556_cur."!cursor_debug"("NEXT", "infix:sym<gt>")
  debug_1256:
  rx1556_fail:
    (rx1556_rep, rx1556_pos, $I10, $P10) = rx1556_cur."!mark_fail"(0)
    lt rx1556_pos, -1, rx1556_done
    eq rx1556_pos, -1, rx1556_fail
    jump $I10
  rx1556_done:
    rx1556_cur."!cursor_fail"()
    if_null rx1556_debug, debug_1257
    rx1556_cur."!cursor_debug"("FAIL", "infix:sym<gt>")
  debug_1257:
    .return (rx1556_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<gt>"  :nsentry("!PREFIX__infix:sym<gt>") :subid("349_1302110486.758") :method
.annotate 'line', 10
    $P1558 = self."!PREFIX__!subrule"("O", "gt")
    new $P1559, "ResizablePMCArray"
    push $P1559, $P1558
    .return ($P1559)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=:=>"  :subid("350_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1563_tgt
    .local int rx1563_pos
    .local int rx1563_off
    .local int rx1563_eos
    .local int rx1563_rep
    .local pmc rx1563_cur
    .local pmc rx1563_debug
    (rx1563_cur, rx1563_pos, rx1563_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1563_cur
    .local pmc match
    .lex "$/", match
    length rx1563_eos, rx1563_tgt
    gt rx1563_pos, rx1563_eos, rx1563_done
    set rx1563_off, 0
    lt rx1563_pos, 2, rx1563_start
    sub rx1563_off, rx1563_pos, 1
    substr rx1563_tgt, rx1563_tgt, rx1563_off
  rx1563_start:
    eq $I10, 1, rx1563_restart
    if_null rx1563_debug, debug_1258
    rx1563_cur."!cursor_debug"("START", "infix:sym<=:=>")
  debug_1258:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1567_done
    goto rxscan1567_scan
  rxscan1567_loop:
    (rx1563_pos) = rx1563_cur."from"()
    inc rx1563_pos
    rx1563_cur."!cursor_from"(rx1563_pos)
    ge rx1563_pos, rx1563_eos, rxscan1567_done
  rxscan1567_scan:
    set_addr $I10, rxscan1567_loop
    rx1563_cur."!mark_push"(0, rx1563_pos, $I10)
  rxscan1567_done:
.annotate 'line', 662
  # rx subcapture "sym"
    set_addr $I10, rxcap_1568_fail
    rx1563_cur."!mark_push"(0, rx1563_pos, $I10)
  # rx literal  "=:="
    add $I11, rx1563_pos, 3
    gt $I11, rx1563_eos, rx1563_fail
    sub $I11, rx1563_pos, rx1563_off
    substr $S10, rx1563_tgt, $I11, 3
    ne $S10, "=:=", rx1563_fail
    add rx1563_pos, 3
    set_addr $I10, rxcap_1568_fail
    ($I12, $I11) = rx1563_cur."!mark_peek"($I10)
    rx1563_cur."!cursor_pos"($I11)
    ($P10) = rx1563_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1563_pos, "")
    rx1563_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1568_done
  rxcap_1568_fail:
    goto rx1563_fail
  rxcap_1568_done:
  # rx subrule "O" subtype=capture negate=
    rx1563_cur."!cursor_pos"(rx1563_pos)
    $P10 = rx1563_cur."O"("%relational, :pirop<issame>")
    unless $P10, rx1563_fail
    rx1563_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1563_pos = $P10."pos"()
  # rx pass
    rx1563_cur."!cursor_pass"(rx1563_pos, "infix:sym<=:=>")
    if_null rx1563_debug, debug_1259
    rx1563_cur."!cursor_debug"("PASS", "infix:sym<=:=>", " at pos=", rx1563_pos)
  debug_1259:
    .return (rx1563_cur)
  rx1563_restart:
.annotate 'line', 10
    if_null rx1563_debug, debug_1260
    rx1563_cur."!cursor_debug"("NEXT", "infix:sym<=:=>")
  debug_1260:
  rx1563_fail:
    (rx1563_rep, rx1563_pos, $I10, $P10) = rx1563_cur."!mark_fail"(0)
    lt rx1563_pos, -1, rx1563_done
    eq rx1563_pos, -1, rx1563_fail
    jump $I10
  rx1563_done:
    rx1563_cur."!cursor_fail"()
    if_null rx1563_debug, debug_1261
    rx1563_cur."!cursor_debug"("FAIL", "infix:sym<=:=>")
  debug_1261:
    .return (rx1563_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=:=>"  :nsentry("!PREFIX__infix:sym<=:=>") :subid("351_1302110486.758") :method
.annotate 'line', 10
    $P1565 = self."!PREFIX__!subrule"("O", "=:=")
    new $P1566, "ResizablePMCArray"
    push $P1566, $P1565
    .return ($P1566)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~~>"  :subid("352_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1570_tgt
    .local int rx1570_pos
    .local int rx1570_off
    .local int rx1570_eos
    .local int rx1570_rep
    .local pmc rx1570_cur
    .local pmc rx1570_debug
    (rx1570_cur, rx1570_pos, rx1570_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1570_cur
    .local pmc match
    .lex "$/", match
    length rx1570_eos, rx1570_tgt
    gt rx1570_pos, rx1570_eos, rx1570_done
    set rx1570_off, 0
    lt rx1570_pos, 2, rx1570_start
    sub rx1570_off, rx1570_pos, 1
    substr rx1570_tgt, rx1570_tgt, rx1570_off
  rx1570_start:
    eq $I10, 1, rx1570_restart
    if_null rx1570_debug, debug_1262
    rx1570_cur."!cursor_debug"("START", "infix:sym<~~>")
  debug_1262:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1574_done
    goto rxscan1574_scan
  rxscan1574_loop:
    (rx1570_pos) = rx1570_cur."from"()
    inc rx1570_pos
    rx1570_cur."!cursor_from"(rx1570_pos)
    ge rx1570_pos, rx1570_eos, rxscan1574_done
  rxscan1574_scan:
    set_addr $I10, rxscan1574_loop
    rx1570_cur."!mark_push"(0, rx1570_pos, $I10)
  rxscan1574_done:
.annotate 'line', 663
  # rx subcapture "sym"
    set_addr $I10, rxcap_1575_fail
    rx1570_cur."!mark_push"(0, rx1570_pos, $I10)
  # rx literal  "~~"
    add $I11, rx1570_pos, 2
    gt $I11, rx1570_eos, rx1570_fail
    sub $I11, rx1570_pos, rx1570_off
    substr $S10, rx1570_tgt, $I11, 2
    ne $S10, "~~", rx1570_fail
    add rx1570_pos, 2
    set_addr $I10, rxcap_1575_fail
    ($I12, $I11) = rx1570_cur."!mark_peek"($I10)
    rx1570_cur."!cursor_pos"($I11)
    ($P10) = rx1570_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1570_pos, "")
    rx1570_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1575_done
  rxcap_1575_fail:
    goto rx1570_fail
  rxcap_1575_done:
  # rx subrule "O" subtype=capture negate=
    rx1570_cur."!cursor_pos"(rx1570_pos)
    $P10 = rx1570_cur."O"("%relational, :reducecheck<smartmatch>")
    unless $P10, rx1570_fail
    rx1570_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1570_pos = $P10."pos"()
  # rx pass
    rx1570_cur."!cursor_pass"(rx1570_pos, "infix:sym<~~>")
    if_null rx1570_debug, debug_1263
    rx1570_cur."!cursor_debug"("PASS", "infix:sym<~~>", " at pos=", rx1570_pos)
  debug_1263:
    .return (rx1570_cur)
  rx1570_restart:
.annotate 'line', 10
    if_null rx1570_debug, debug_1264
    rx1570_cur."!cursor_debug"("NEXT", "infix:sym<~~>")
  debug_1264:
  rx1570_fail:
    (rx1570_rep, rx1570_pos, $I10, $P10) = rx1570_cur."!mark_fail"(0)
    lt rx1570_pos, -1, rx1570_done
    eq rx1570_pos, -1, rx1570_fail
    jump $I10
  rx1570_done:
    rx1570_cur."!cursor_fail"()
    if_null rx1570_debug, debug_1265
    rx1570_cur."!cursor_debug"("FAIL", "infix:sym<~~>")
  debug_1265:
    .return (rx1570_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~~>"  :nsentry("!PREFIX__infix:sym<~~>") :subid("353_1302110486.758") :method
.annotate 'line', 10
    $P1572 = self."!PREFIX__!subrule"("O", "~~")
    new $P1573, "ResizablePMCArray"
    push $P1573, $P1572
    .return ($P1573)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<&&>"  :subid("354_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1577_tgt
    .local int rx1577_pos
    .local int rx1577_off
    .local int rx1577_eos
    .local int rx1577_rep
    .local pmc rx1577_cur
    .local pmc rx1577_debug
    (rx1577_cur, rx1577_pos, rx1577_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1577_cur
    .local pmc match
    .lex "$/", match
    length rx1577_eos, rx1577_tgt
    gt rx1577_pos, rx1577_eos, rx1577_done
    set rx1577_off, 0
    lt rx1577_pos, 2, rx1577_start
    sub rx1577_off, rx1577_pos, 1
    substr rx1577_tgt, rx1577_tgt, rx1577_off
  rx1577_start:
    eq $I10, 1, rx1577_restart
    if_null rx1577_debug, debug_1266
    rx1577_cur."!cursor_debug"("START", "infix:sym<&&>")
  debug_1266:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1581_done
    goto rxscan1581_scan
  rxscan1581_loop:
    (rx1577_pos) = rx1577_cur."from"()
    inc rx1577_pos
    rx1577_cur."!cursor_from"(rx1577_pos)
    ge rx1577_pos, rx1577_eos, rxscan1581_done
  rxscan1581_scan:
    set_addr $I10, rxscan1581_loop
    rx1577_cur."!mark_push"(0, rx1577_pos, $I10)
  rxscan1581_done:
.annotate 'line', 665
  # rx subcapture "sym"
    set_addr $I10, rxcap_1582_fail
    rx1577_cur."!mark_push"(0, rx1577_pos, $I10)
  # rx literal  "&&"
    add $I11, rx1577_pos, 2
    gt $I11, rx1577_eos, rx1577_fail
    sub $I11, rx1577_pos, rx1577_off
    substr $S10, rx1577_tgt, $I11, 2
    ne $S10, "&&", rx1577_fail
    add rx1577_pos, 2
    set_addr $I10, rxcap_1582_fail
    ($I12, $I11) = rx1577_cur."!mark_peek"($I10)
    rx1577_cur."!cursor_pos"($I11)
    ($P10) = rx1577_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1577_pos, "")
    rx1577_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1582_done
  rxcap_1582_fail:
    goto rx1577_fail
  rxcap_1582_done:
  # rx subrule "O" subtype=capture negate=
    rx1577_cur."!cursor_pos"(rx1577_pos)
    $P10 = rx1577_cur."O"("%tight_and, :pasttype<if>")
    unless $P10, rx1577_fail
    rx1577_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1577_pos = $P10."pos"()
  # rx pass
    rx1577_cur."!cursor_pass"(rx1577_pos, "infix:sym<&&>")
    if_null rx1577_debug, debug_1267
    rx1577_cur."!cursor_debug"("PASS", "infix:sym<&&>", " at pos=", rx1577_pos)
  debug_1267:
    .return (rx1577_cur)
  rx1577_restart:
.annotate 'line', 10
    if_null rx1577_debug, debug_1268
    rx1577_cur."!cursor_debug"("NEXT", "infix:sym<&&>")
  debug_1268:
  rx1577_fail:
    (rx1577_rep, rx1577_pos, $I10, $P10) = rx1577_cur."!mark_fail"(0)
    lt rx1577_pos, -1, rx1577_done
    eq rx1577_pos, -1, rx1577_fail
    jump $I10
  rx1577_done:
    rx1577_cur."!cursor_fail"()
    if_null rx1577_debug, debug_1269
    rx1577_cur."!cursor_debug"("FAIL", "infix:sym<&&>")
  debug_1269:
    .return (rx1577_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<&&>"  :nsentry("!PREFIX__infix:sym<&&>") :subid("355_1302110486.758") :method
.annotate 'line', 10
    $P1579 = self."!PREFIX__!subrule"("O", "&&")
    new $P1580, "ResizablePMCArray"
    push $P1580, $P1579
    .return ($P1580)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<||>"  :subid("356_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1584_tgt
    .local int rx1584_pos
    .local int rx1584_off
    .local int rx1584_eos
    .local int rx1584_rep
    .local pmc rx1584_cur
    .local pmc rx1584_debug
    (rx1584_cur, rx1584_pos, rx1584_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1584_cur
    .local pmc match
    .lex "$/", match
    length rx1584_eos, rx1584_tgt
    gt rx1584_pos, rx1584_eos, rx1584_done
    set rx1584_off, 0
    lt rx1584_pos, 2, rx1584_start
    sub rx1584_off, rx1584_pos, 1
    substr rx1584_tgt, rx1584_tgt, rx1584_off
  rx1584_start:
    eq $I10, 1, rx1584_restart
    if_null rx1584_debug, debug_1270
    rx1584_cur."!cursor_debug"("START", "infix:sym<||>")
  debug_1270:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1588_done
    goto rxscan1588_scan
  rxscan1588_loop:
    (rx1584_pos) = rx1584_cur."from"()
    inc rx1584_pos
    rx1584_cur."!cursor_from"(rx1584_pos)
    ge rx1584_pos, rx1584_eos, rxscan1588_done
  rxscan1588_scan:
    set_addr $I10, rxscan1588_loop
    rx1584_cur."!mark_push"(0, rx1584_pos, $I10)
  rxscan1588_done:
.annotate 'line', 667
  # rx subcapture "sym"
    set_addr $I10, rxcap_1589_fail
    rx1584_cur."!mark_push"(0, rx1584_pos, $I10)
  # rx literal  "||"
    add $I11, rx1584_pos, 2
    gt $I11, rx1584_eos, rx1584_fail
    sub $I11, rx1584_pos, rx1584_off
    substr $S10, rx1584_tgt, $I11, 2
    ne $S10, "||", rx1584_fail
    add rx1584_pos, 2
    set_addr $I10, rxcap_1589_fail
    ($I12, $I11) = rx1584_cur."!mark_peek"($I10)
    rx1584_cur."!cursor_pos"($I11)
    ($P10) = rx1584_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1584_pos, "")
    rx1584_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1589_done
  rxcap_1589_fail:
    goto rx1584_fail
  rxcap_1589_done:
  # rx subrule "O" subtype=capture negate=
    rx1584_cur."!cursor_pos"(rx1584_pos)
    $P10 = rx1584_cur."O"("%tight_or, :pasttype<unless>")
    unless $P10, rx1584_fail
    rx1584_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1584_pos = $P10."pos"()
  # rx pass
    rx1584_cur."!cursor_pass"(rx1584_pos, "infix:sym<||>")
    if_null rx1584_debug, debug_1271
    rx1584_cur."!cursor_debug"("PASS", "infix:sym<||>", " at pos=", rx1584_pos)
  debug_1271:
    .return (rx1584_cur)
  rx1584_restart:
.annotate 'line', 10
    if_null rx1584_debug, debug_1272
    rx1584_cur."!cursor_debug"("NEXT", "infix:sym<||>")
  debug_1272:
  rx1584_fail:
    (rx1584_rep, rx1584_pos, $I10, $P10) = rx1584_cur."!mark_fail"(0)
    lt rx1584_pos, -1, rx1584_done
    eq rx1584_pos, -1, rx1584_fail
    jump $I10
  rx1584_done:
    rx1584_cur."!cursor_fail"()
    if_null rx1584_debug, debug_1273
    rx1584_cur."!cursor_debug"("FAIL", "infix:sym<||>")
  debug_1273:
    .return (rx1584_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<||>"  :nsentry("!PREFIX__infix:sym<||>") :subid("357_1302110486.758") :method
.annotate 'line', 10
    $P1586 = self."!PREFIX__!subrule"("O", "||")
    new $P1587, "ResizablePMCArray"
    push $P1587, $P1586
    .return ($P1587)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<//>"  :subid("358_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1591_tgt
    .local int rx1591_pos
    .local int rx1591_off
    .local int rx1591_eos
    .local int rx1591_rep
    .local pmc rx1591_cur
    .local pmc rx1591_debug
    (rx1591_cur, rx1591_pos, rx1591_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1591_cur
    .local pmc match
    .lex "$/", match
    length rx1591_eos, rx1591_tgt
    gt rx1591_pos, rx1591_eos, rx1591_done
    set rx1591_off, 0
    lt rx1591_pos, 2, rx1591_start
    sub rx1591_off, rx1591_pos, 1
    substr rx1591_tgt, rx1591_tgt, rx1591_off
  rx1591_start:
    eq $I10, 1, rx1591_restart
    if_null rx1591_debug, debug_1274
    rx1591_cur."!cursor_debug"("START", "infix:sym<//>")
  debug_1274:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1595_done
    goto rxscan1595_scan
  rxscan1595_loop:
    (rx1591_pos) = rx1591_cur."from"()
    inc rx1591_pos
    rx1591_cur."!cursor_from"(rx1591_pos)
    ge rx1591_pos, rx1591_eos, rxscan1595_done
  rxscan1595_scan:
    set_addr $I10, rxscan1595_loop
    rx1591_cur."!mark_push"(0, rx1591_pos, $I10)
  rxscan1595_done:
.annotate 'line', 668
  # rx subcapture "sym"
    set_addr $I10, rxcap_1596_fail
    rx1591_cur."!mark_push"(0, rx1591_pos, $I10)
  # rx literal  "//"
    add $I11, rx1591_pos, 2
    gt $I11, rx1591_eos, rx1591_fail
    sub $I11, rx1591_pos, rx1591_off
    substr $S10, rx1591_tgt, $I11, 2
    ne $S10, "//", rx1591_fail
    add rx1591_pos, 2
    set_addr $I10, rxcap_1596_fail
    ($I12, $I11) = rx1591_cur."!mark_peek"($I10)
    rx1591_cur."!cursor_pos"($I11)
    ($P10) = rx1591_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1591_pos, "")
    rx1591_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1596_done
  rxcap_1596_fail:
    goto rx1591_fail
  rxcap_1596_done:
  # rx subrule "O" subtype=capture negate=
    rx1591_cur."!cursor_pos"(rx1591_pos)
    $P10 = rx1591_cur."O"("%tight_or, :pasttype<def_or>")
    unless $P10, rx1591_fail
    rx1591_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1591_pos = $P10."pos"()
  # rx pass
    rx1591_cur."!cursor_pass"(rx1591_pos, "infix:sym<//>")
    if_null rx1591_debug, debug_1275
    rx1591_cur."!cursor_debug"("PASS", "infix:sym<//>", " at pos=", rx1591_pos)
  debug_1275:
    .return (rx1591_cur)
  rx1591_restart:
.annotate 'line', 10
    if_null rx1591_debug, debug_1276
    rx1591_cur."!cursor_debug"("NEXT", "infix:sym<//>")
  debug_1276:
  rx1591_fail:
    (rx1591_rep, rx1591_pos, $I10, $P10) = rx1591_cur."!mark_fail"(0)
    lt rx1591_pos, -1, rx1591_done
    eq rx1591_pos, -1, rx1591_fail
    jump $I10
  rx1591_done:
    rx1591_cur."!cursor_fail"()
    if_null rx1591_debug, debug_1277
    rx1591_cur."!cursor_debug"("FAIL", "infix:sym<//>")
  debug_1277:
    .return (rx1591_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<//>"  :nsentry("!PREFIX__infix:sym<//>") :subid("359_1302110486.758") :method
.annotate 'line', 10
    $P1593 = self."!PREFIX__!subrule"("O", "//")
    new $P1594, "ResizablePMCArray"
    push $P1594, $P1593
    .return ($P1594)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<?? !!>"  :subid("360_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1598_tgt
    .local int rx1598_pos
    .local int rx1598_off
    .local int rx1598_eos
    .local int rx1598_rep
    .local pmc rx1598_cur
    .local pmc rx1598_debug
    (rx1598_cur, rx1598_pos, rx1598_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1598_cur
    .local pmc match
    .lex "$/", match
    length rx1598_eos, rx1598_tgt
    gt rx1598_pos, rx1598_eos, rx1598_done
    set rx1598_off, 0
    lt rx1598_pos, 2, rx1598_start
    sub rx1598_off, rx1598_pos, 1
    substr rx1598_tgt, rx1598_tgt, rx1598_off
  rx1598_start:
    eq $I10, 1, rx1598_restart
    if_null rx1598_debug, debug_1278
    rx1598_cur."!cursor_debug"("START", "infix:sym<?? !!>")
  debug_1278:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1602_done
    goto rxscan1602_scan
  rxscan1602_loop:
    (rx1598_pos) = rx1598_cur."from"()
    inc rx1598_pos
    rx1598_cur."!cursor_from"(rx1598_pos)
    ge rx1598_pos, rx1598_eos, rxscan1602_done
  rxscan1602_scan:
    set_addr $I10, rxscan1602_loop
    rx1598_cur."!mark_push"(0, rx1598_pos, $I10)
  rxscan1602_done:
.annotate 'line', 671
  # rx literal  "??"
    add $I11, rx1598_pos, 2
    gt $I11, rx1598_eos, rx1598_fail
    sub $I11, rx1598_pos, rx1598_off
    substr $S10, rx1598_tgt, $I11, 2
    ne $S10, "??", rx1598_fail
    add rx1598_pos, 2
.annotate 'line', 672
  # rx subrule "ws" subtype=method negate=
    rx1598_cur."!cursor_pos"(rx1598_pos)
    $P10 = rx1598_cur."ws"()
    unless $P10, rx1598_fail
    rx1598_pos = $P10."pos"()
.annotate 'line', 673
  # rx subrule "EXPR" subtype=capture negate=
    rx1598_cur."!cursor_pos"(rx1598_pos)
    $P10 = rx1598_cur."EXPR"("i=")
    unless $P10, rx1598_fail
    rx1598_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1598_pos = $P10."pos"()
.annotate 'line', 674
  # rx literal  "!!"
    add $I11, rx1598_pos, 2
    gt $I11, rx1598_eos, rx1598_fail
    sub $I11, rx1598_pos, rx1598_off
    substr $S10, rx1598_tgt, $I11, 2
    ne $S10, "!!", rx1598_fail
    add rx1598_pos, 2
.annotate 'line', 675
  # rx subrule "O" subtype=capture negate=
    rx1598_cur."!cursor_pos"(rx1598_pos)
    $P10 = rx1598_cur."O"("%conditional, :reducecheck<ternary>, :pasttype<if>")
    unless $P10, rx1598_fail
    rx1598_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1598_pos = $P10."pos"()
.annotate 'line', 670
  # rx pass
    rx1598_cur."!cursor_pass"(rx1598_pos, "infix:sym<?? !!>")
    if_null rx1598_debug, debug_1279
    rx1598_cur."!cursor_debug"("PASS", "infix:sym<?? !!>", " at pos=", rx1598_pos)
  debug_1279:
    .return (rx1598_cur)
  rx1598_restart:
.annotate 'line', 10
    if_null rx1598_debug, debug_1280
    rx1598_cur."!cursor_debug"("NEXT", "infix:sym<?? !!>")
  debug_1280:
  rx1598_fail:
    (rx1598_rep, rx1598_pos, $I10, $P10) = rx1598_cur."!mark_fail"(0)
    lt rx1598_pos, -1, rx1598_done
    eq rx1598_pos, -1, rx1598_fail
    jump $I10
  rx1598_done:
    rx1598_cur."!cursor_fail"()
    if_null rx1598_debug, debug_1281
    rx1598_cur."!cursor_debug"("FAIL", "infix:sym<?? !!>")
  debug_1281:
    .return (rx1598_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<?? !!>"  :nsentry("!PREFIX__infix:sym<?? !!>") :subid("361_1302110486.758") :method
.annotate 'line', 10
    $P1600 = self."!PREFIX__!subrule"("ws", "??")
    new $P1601, "ResizablePMCArray"
    push $P1601, $P1600
    .return ($P1601)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=>"  :subid("362_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1604_tgt
    .local int rx1604_pos
    .local int rx1604_off
    .local int rx1604_eos
    .local int rx1604_rep
    .local pmc rx1604_cur
    .local pmc rx1604_debug
    (rx1604_cur, rx1604_pos, rx1604_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1604_cur
    .local pmc match
    .lex "$/", match
    length rx1604_eos, rx1604_tgt
    gt rx1604_pos, rx1604_eos, rx1604_done
    set rx1604_off, 0
    lt rx1604_pos, 2, rx1604_start
    sub rx1604_off, rx1604_pos, 1
    substr rx1604_tgt, rx1604_tgt, rx1604_off
  rx1604_start:
    eq $I10, 1, rx1604_restart
    if_null rx1604_debug, debug_1282
    rx1604_cur."!cursor_debug"("START", "infix:sym<=>")
  debug_1282:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1608_done
    goto rxscan1608_scan
  rxscan1608_loop:
    (rx1604_pos) = rx1604_cur."from"()
    inc rx1604_pos
    rx1604_cur."!cursor_from"(rx1604_pos)
    ge rx1604_pos, rx1604_eos, rxscan1608_done
  rxscan1608_scan:
    set_addr $I10, rxscan1608_loop
    rx1604_cur."!mark_push"(0, rx1604_pos, $I10)
  rxscan1608_done:
.annotate 'line', 679
  # rx subcapture "sym"
    set_addr $I10, rxcap_1609_fail
    rx1604_cur."!mark_push"(0, rx1604_pos, $I10)
  # rx literal  "="
    add $I11, rx1604_pos, 1
    gt $I11, rx1604_eos, rx1604_fail
    sub $I11, rx1604_pos, rx1604_off
    ord $I11, rx1604_tgt, $I11
    ne $I11, 61, rx1604_fail
    add rx1604_pos, 1
    set_addr $I10, rxcap_1609_fail
    ($I12, $I11) = rx1604_cur."!mark_peek"($I10)
    rx1604_cur."!cursor_pos"($I11)
    ($P10) = rx1604_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1604_pos, "")
    rx1604_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1609_done
  rxcap_1609_fail:
    goto rx1604_fail
  rxcap_1609_done:
  # rx subrule "panic" subtype=method negate=
    rx1604_cur."!cursor_pos"(rx1604_pos)
    $P10 = rx1604_cur."panic"("Assignment (\"=\") not supported in NQP, use \":=\" instead")
    unless $P10, rx1604_fail
    rx1604_pos = $P10."pos"()
.annotate 'line', 678
  # rx pass
    rx1604_cur."!cursor_pass"(rx1604_pos, "infix:sym<=>")
    if_null rx1604_debug, debug_1283
    rx1604_cur."!cursor_debug"("PASS", "infix:sym<=>", " at pos=", rx1604_pos)
  debug_1283:
    .return (rx1604_cur)
  rx1604_restart:
.annotate 'line', 10
    if_null rx1604_debug, debug_1284
    rx1604_cur."!cursor_debug"("NEXT", "infix:sym<=>")
  debug_1284:
  rx1604_fail:
    (rx1604_rep, rx1604_pos, $I10, $P10) = rx1604_cur."!mark_fail"(0)
    lt rx1604_pos, -1, rx1604_done
    eq rx1604_pos, -1, rx1604_fail
    jump $I10
  rx1604_done:
    rx1604_cur."!cursor_fail"()
    if_null rx1604_debug, debug_1285
    rx1604_cur."!cursor_debug"("FAIL", "infix:sym<=>")
  debug_1285:
    .return (rx1604_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=>"  :nsentry("!PREFIX__infix:sym<=>") :subid("363_1302110486.758") :method
.annotate 'line', 10
    $P1606 = self."!PREFIX__!subrule"("panic", "=")
    new $P1607, "ResizablePMCArray"
    push $P1607, $P1606
    .return ($P1607)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<:=>"  :subid("364_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1611_tgt
    .local int rx1611_pos
    .local int rx1611_off
    .local int rx1611_eos
    .local int rx1611_rep
    .local pmc rx1611_cur
    .local pmc rx1611_debug
    (rx1611_cur, rx1611_pos, rx1611_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1611_cur
    .local pmc match
    .lex "$/", match
    length rx1611_eos, rx1611_tgt
    gt rx1611_pos, rx1611_eos, rx1611_done
    set rx1611_off, 0
    lt rx1611_pos, 2, rx1611_start
    sub rx1611_off, rx1611_pos, 1
    substr rx1611_tgt, rx1611_tgt, rx1611_off
  rx1611_start:
    eq $I10, 1, rx1611_restart
    if_null rx1611_debug, debug_1286
    rx1611_cur."!cursor_debug"("START", "infix:sym<:=>")
  debug_1286:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1615_done
    goto rxscan1615_scan
  rxscan1615_loop:
    (rx1611_pos) = rx1611_cur."from"()
    inc rx1611_pos
    rx1611_cur."!cursor_from"(rx1611_pos)
    ge rx1611_pos, rx1611_eos, rxscan1615_done
  rxscan1615_scan:
    set_addr $I10, rxscan1615_loop
    rx1611_cur."!mark_push"(0, rx1611_pos, $I10)
  rxscan1615_done:
.annotate 'line', 681
  # rx subcapture "sym"
    set_addr $I10, rxcap_1616_fail
    rx1611_cur."!mark_push"(0, rx1611_pos, $I10)
  # rx literal  ":="
    add $I11, rx1611_pos, 2
    gt $I11, rx1611_eos, rx1611_fail
    sub $I11, rx1611_pos, rx1611_off
    substr $S10, rx1611_tgt, $I11, 2
    ne $S10, ":=", rx1611_fail
    add rx1611_pos, 2
    set_addr $I10, rxcap_1616_fail
    ($I12, $I11) = rx1611_cur."!mark_peek"($I10)
    rx1611_cur."!cursor_pos"($I11)
    ($P10) = rx1611_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1611_pos, "")
    rx1611_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1616_done
  rxcap_1616_fail:
    goto rx1611_fail
  rxcap_1616_done:
  # rx subrule "O" subtype=capture negate=
    rx1611_cur."!cursor_pos"(rx1611_pos)
    $P10 = rx1611_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx1611_fail
    rx1611_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1611_pos = $P10."pos"()
  # rx pass
    rx1611_cur."!cursor_pass"(rx1611_pos, "infix:sym<:=>")
    if_null rx1611_debug, debug_1287
    rx1611_cur."!cursor_debug"("PASS", "infix:sym<:=>", " at pos=", rx1611_pos)
  debug_1287:
    .return (rx1611_cur)
  rx1611_restart:
.annotate 'line', 10
    if_null rx1611_debug, debug_1288
    rx1611_cur."!cursor_debug"("NEXT", "infix:sym<:=>")
  debug_1288:
  rx1611_fail:
    (rx1611_rep, rx1611_pos, $I10, $P10) = rx1611_cur."!mark_fail"(0)
    lt rx1611_pos, -1, rx1611_done
    eq rx1611_pos, -1, rx1611_fail
    jump $I10
  rx1611_done:
    rx1611_cur."!cursor_fail"()
    if_null rx1611_debug, debug_1289
    rx1611_cur."!cursor_debug"("FAIL", "infix:sym<:=>")
  debug_1289:
    .return (rx1611_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<:=>"  :nsentry("!PREFIX__infix:sym<:=>") :subid("365_1302110486.758") :method
.annotate 'line', 10
    $P1613 = self."!PREFIX__!subrule"("O", ":=")
    new $P1614, "ResizablePMCArray"
    push $P1614, $P1613
    .return ($P1614)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<::=>"  :subid("366_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1618_tgt
    .local int rx1618_pos
    .local int rx1618_off
    .local int rx1618_eos
    .local int rx1618_rep
    .local pmc rx1618_cur
    .local pmc rx1618_debug
    (rx1618_cur, rx1618_pos, rx1618_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1618_cur
    .local pmc match
    .lex "$/", match
    length rx1618_eos, rx1618_tgt
    gt rx1618_pos, rx1618_eos, rx1618_done
    set rx1618_off, 0
    lt rx1618_pos, 2, rx1618_start
    sub rx1618_off, rx1618_pos, 1
    substr rx1618_tgt, rx1618_tgt, rx1618_off
  rx1618_start:
    eq $I10, 1, rx1618_restart
    if_null rx1618_debug, debug_1290
    rx1618_cur."!cursor_debug"("START", "infix:sym<::=>")
  debug_1290:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1622_done
    goto rxscan1622_scan
  rxscan1622_loop:
    (rx1618_pos) = rx1618_cur."from"()
    inc rx1618_pos
    rx1618_cur."!cursor_from"(rx1618_pos)
    ge rx1618_pos, rx1618_eos, rxscan1622_done
  rxscan1622_scan:
    set_addr $I10, rxscan1622_loop
    rx1618_cur."!mark_push"(0, rx1618_pos, $I10)
  rxscan1622_done:
.annotate 'line', 682
  # rx subcapture "sym"
    set_addr $I10, rxcap_1623_fail
    rx1618_cur."!mark_push"(0, rx1618_pos, $I10)
  # rx literal  "::="
    add $I11, rx1618_pos, 3
    gt $I11, rx1618_eos, rx1618_fail
    sub $I11, rx1618_pos, rx1618_off
    substr $S10, rx1618_tgt, $I11, 3
    ne $S10, "::=", rx1618_fail
    add rx1618_pos, 3
    set_addr $I10, rxcap_1623_fail
    ($I12, $I11) = rx1618_cur."!mark_peek"($I10)
    rx1618_cur."!cursor_pos"($I11)
    ($P10) = rx1618_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1618_pos, "")
    rx1618_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1623_done
  rxcap_1623_fail:
    goto rx1618_fail
  rxcap_1623_done:
  # rx subrule "O" subtype=capture negate=
    rx1618_cur."!cursor_pos"(rx1618_pos)
    $P10 = rx1618_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx1618_fail
    rx1618_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1618_pos = $P10."pos"()
  # rx pass
    rx1618_cur."!cursor_pass"(rx1618_pos, "infix:sym<::=>")
    if_null rx1618_debug, debug_1291
    rx1618_cur."!cursor_debug"("PASS", "infix:sym<::=>", " at pos=", rx1618_pos)
  debug_1291:
    .return (rx1618_cur)
  rx1618_restart:
.annotate 'line', 10
    if_null rx1618_debug, debug_1292
    rx1618_cur."!cursor_debug"("NEXT", "infix:sym<::=>")
  debug_1292:
  rx1618_fail:
    (rx1618_rep, rx1618_pos, $I10, $P10) = rx1618_cur."!mark_fail"(0)
    lt rx1618_pos, -1, rx1618_done
    eq rx1618_pos, -1, rx1618_fail
    jump $I10
  rx1618_done:
    rx1618_cur."!cursor_fail"()
    if_null rx1618_debug, debug_1293
    rx1618_cur."!cursor_debug"("FAIL", "infix:sym<::=>")
  debug_1293:
    .return (rx1618_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<::=>"  :nsentry("!PREFIX__infix:sym<::=>") :subid("367_1302110486.758") :method
.annotate 'line', 10
    $P1620 = self."!PREFIX__!subrule"("O", "::=")
    new $P1621, "ResizablePMCArray"
    push $P1621, $P1620
    .return ($P1621)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<,>"  :subid("368_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1625_tgt
    .local int rx1625_pos
    .local int rx1625_off
    .local int rx1625_eos
    .local int rx1625_rep
    .local pmc rx1625_cur
    .local pmc rx1625_debug
    (rx1625_cur, rx1625_pos, rx1625_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1625_cur
    .local pmc match
    .lex "$/", match
    length rx1625_eos, rx1625_tgt
    gt rx1625_pos, rx1625_eos, rx1625_done
    set rx1625_off, 0
    lt rx1625_pos, 2, rx1625_start
    sub rx1625_off, rx1625_pos, 1
    substr rx1625_tgt, rx1625_tgt, rx1625_off
  rx1625_start:
    eq $I10, 1, rx1625_restart
    if_null rx1625_debug, debug_1294
    rx1625_cur."!cursor_debug"("START", "infix:sym<,>")
  debug_1294:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1629_done
    goto rxscan1629_scan
  rxscan1629_loop:
    (rx1625_pos) = rx1625_cur."from"()
    inc rx1625_pos
    rx1625_cur."!cursor_from"(rx1625_pos)
    ge rx1625_pos, rx1625_eos, rxscan1629_done
  rxscan1629_scan:
    set_addr $I10, rxscan1629_loop
    rx1625_cur."!mark_push"(0, rx1625_pos, $I10)
  rxscan1629_done:
.annotate 'line', 684
  # rx subcapture "sym"
    set_addr $I10, rxcap_1630_fail
    rx1625_cur."!mark_push"(0, rx1625_pos, $I10)
  # rx literal  ","
    add $I11, rx1625_pos, 1
    gt $I11, rx1625_eos, rx1625_fail
    sub $I11, rx1625_pos, rx1625_off
    ord $I11, rx1625_tgt, $I11
    ne $I11, 44, rx1625_fail
    add rx1625_pos, 1
    set_addr $I10, rxcap_1630_fail
    ($I12, $I11) = rx1625_cur."!mark_peek"($I10)
    rx1625_cur."!cursor_pos"($I11)
    ($P10) = rx1625_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1625_pos, "")
    rx1625_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1630_done
  rxcap_1630_fail:
    goto rx1625_fail
  rxcap_1630_done:
  # rx subrule "O" subtype=capture negate=
    rx1625_cur."!cursor_pos"(rx1625_pos)
    $P10 = rx1625_cur."O"("%comma, :pasttype<list>")
    unless $P10, rx1625_fail
    rx1625_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1625_pos = $P10."pos"()
  # rx pass
    rx1625_cur."!cursor_pass"(rx1625_pos, "infix:sym<,>")
    if_null rx1625_debug, debug_1295
    rx1625_cur."!cursor_debug"("PASS", "infix:sym<,>", " at pos=", rx1625_pos)
  debug_1295:
    .return (rx1625_cur)
  rx1625_restart:
.annotate 'line', 10
    if_null rx1625_debug, debug_1296
    rx1625_cur."!cursor_debug"("NEXT", "infix:sym<,>")
  debug_1296:
  rx1625_fail:
    (rx1625_rep, rx1625_pos, $I10, $P10) = rx1625_cur."!mark_fail"(0)
    lt rx1625_pos, -1, rx1625_done
    eq rx1625_pos, -1, rx1625_fail
    jump $I10
  rx1625_done:
    rx1625_cur."!cursor_fail"()
    if_null rx1625_debug, debug_1297
    rx1625_cur."!cursor_debug"("FAIL", "infix:sym<,>")
  debug_1297:
    .return (rx1625_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<,>"  :nsentry("!PREFIX__infix:sym<,>") :subid("369_1302110486.758") :method
.annotate 'line', 10
    $P1627 = self."!PREFIX__!subrule"("O", ",")
    new $P1628, "ResizablePMCArray"
    push $P1628, $P1627
    .return ($P1628)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<return>"  :subid("370_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .const 'Sub' $P1640 = "372_1302110486.758" 
    capture_lex $P1640
    .local string rx1632_tgt
    .local int rx1632_pos
    .local int rx1632_off
    .local int rx1632_eos
    .local int rx1632_rep
    .local pmc rx1632_cur
    .local pmc rx1632_debug
    (rx1632_cur, rx1632_pos, rx1632_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1632_cur
    .local pmc match
    .lex "$/", match
    length rx1632_eos, rx1632_tgt
    gt rx1632_pos, rx1632_eos, rx1632_done
    set rx1632_off, 0
    lt rx1632_pos, 2, rx1632_start
    sub rx1632_off, rx1632_pos, 1
    substr rx1632_tgt, rx1632_tgt, rx1632_off
  rx1632_start:
    eq $I10, 1, rx1632_restart
    if_null rx1632_debug, debug_1298
    rx1632_cur."!cursor_debug"("START", "prefix:sym<return>")
  debug_1298:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1635_done
    goto rxscan1635_scan
  rxscan1635_loop:
    (rx1632_pos) = rx1632_cur."from"()
    inc rx1632_pos
    rx1632_cur."!cursor_from"(rx1632_pos)
    ge rx1632_pos, rx1632_eos, rxscan1635_done
  rxscan1635_scan:
    set_addr $I10, rxscan1635_loop
    rx1632_cur."!mark_push"(0, rx1632_pos, $I10)
  rxscan1635_done:
.annotate 'line', 686
  # rx subcapture "sym"
    set_addr $I10, rxcap_1636_fail
    rx1632_cur."!mark_push"(0, rx1632_pos, $I10)
  # rx literal  "return"
    add $I11, rx1632_pos, 6
    gt $I11, rx1632_eos, rx1632_fail
    sub $I11, rx1632_pos, rx1632_off
    substr $S10, rx1632_tgt, $I11, 6
    ne $S10, "return", rx1632_fail
    add rx1632_pos, 6
    set_addr $I10, rxcap_1636_fail
    ($I12, $I11) = rx1632_cur."!mark_peek"($I10)
    rx1632_cur."!cursor_pos"($I11)
    ($P10) = rx1632_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1632_pos, "")
    rx1632_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1636_done
  rxcap_1636_fail:
    goto rx1632_fail
  rxcap_1636_done:
  # rx charclass s
    ge rx1632_pos, rx1632_eos, rx1632_fail
    sub $I10, rx1632_pos, rx1632_off
    is_cclass $I11, 32, rx1632_tgt, $I10
    unless $I11, rx1632_fail
    inc rx1632_pos
  # rx subrule "O" subtype=capture negate=
    rx1632_cur."!cursor_pos"(rx1632_pos)
    $P10 = rx1632_cur."O"("%list_prefix, :pasttype<return>")
    unless $P10, rx1632_fail
    rx1632_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1632_pos = $P10."pos"()
    rx1632_cur."!cursor_pos"(rx1632_pos)
    find_lex $P1637, unicode:"$\x{a2}"
    $P1638 = $P1637."MATCH"()
    store_lex "$/", $P1638
    .const 'Sub' $P1640 = "372_1302110486.758" 
    capture_lex $P1640
    $P1642 = $P1640()
  # rx pass
    rx1632_cur."!cursor_pass"(rx1632_pos, "prefix:sym<return>")
    if_null rx1632_debug, debug_1299
    rx1632_cur."!cursor_debug"("PASS", "prefix:sym<return>", " at pos=", rx1632_pos)
  debug_1299:
    .return (rx1632_cur)
  rx1632_restart:
.annotate 'line', 10
    if_null rx1632_debug, debug_1300
    rx1632_cur."!cursor_debug"("NEXT", "prefix:sym<return>")
  debug_1300:
  rx1632_fail:
    (rx1632_rep, rx1632_pos, $I10, $P10) = rx1632_cur."!mark_fail"(0)
    lt rx1632_pos, -1, rx1632_done
    eq rx1632_pos, -1, rx1632_fail
    jump $I10
  rx1632_done:
    rx1632_cur."!cursor_fail"()
    if_null rx1632_debug, debug_1301
    rx1632_cur."!cursor_debug"("FAIL", "prefix:sym<return>")
  debug_1301:
    .return (rx1632_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<return>"  :nsentry("!PREFIX__prefix:sym<return>") :subid("371_1302110486.758") :method
.annotate 'line', 10
    new $P1634, "ResizablePMCArray"
    push $P1634, "return"
    .return ($P1634)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1639"  :anon :subid("372_1302110486.758") :outer("370_1302110486.758")
.annotate 'line', 686
    new $P1641, "Integer"
    assign $P1641, 1
    store_dynamic_lex "$*RETURN_USED", $P1641
    .return ($P1641)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<make>"  :subid("373_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1644_tgt
    .local int rx1644_pos
    .local int rx1644_off
    .local int rx1644_eos
    .local int rx1644_rep
    .local pmc rx1644_cur
    .local pmc rx1644_debug
    (rx1644_cur, rx1644_pos, rx1644_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1644_cur
    .local pmc match
    .lex "$/", match
    length rx1644_eos, rx1644_tgt
    gt rx1644_pos, rx1644_eos, rx1644_done
    set rx1644_off, 0
    lt rx1644_pos, 2, rx1644_start
    sub rx1644_off, rx1644_pos, 1
    substr rx1644_tgt, rx1644_tgt, rx1644_off
  rx1644_start:
    eq $I10, 1, rx1644_restart
    if_null rx1644_debug, debug_1302
    rx1644_cur."!cursor_debug"("START", "prefix:sym<make>")
  debug_1302:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1647_done
    goto rxscan1647_scan
  rxscan1647_loop:
    (rx1644_pos) = rx1644_cur."from"()
    inc rx1644_pos
    rx1644_cur."!cursor_from"(rx1644_pos)
    ge rx1644_pos, rx1644_eos, rxscan1647_done
  rxscan1647_scan:
    set_addr $I10, rxscan1647_loop
    rx1644_cur."!mark_push"(0, rx1644_pos, $I10)
  rxscan1647_done:
.annotate 'line', 687
  # rx subcapture "sym"
    set_addr $I10, rxcap_1648_fail
    rx1644_cur."!mark_push"(0, rx1644_pos, $I10)
  # rx literal  "make"
    add $I11, rx1644_pos, 4
    gt $I11, rx1644_eos, rx1644_fail
    sub $I11, rx1644_pos, rx1644_off
    substr $S10, rx1644_tgt, $I11, 4
    ne $S10, "make", rx1644_fail
    add rx1644_pos, 4
    set_addr $I10, rxcap_1648_fail
    ($I12, $I11) = rx1644_cur."!mark_peek"($I10)
    rx1644_cur."!cursor_pos"($I11)
    ($P10) = rx1644_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1644_pos, "")
    rx1644_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1648_done
  rxcap_1648_fail:
    goto rx1644_fail
  rxcap_1648_done:
  # rx charclass s
    ge rx1644_pos, rx1644_eos, rx1644_fail
    sub $I10, rx1644_pos, rx1644_off
    is_cclass $I11, 32, rx1644_tgt, $I10
    unless $I11, rx1644_fail
    inc rx1644_pos
  # rx subrule "O" subtype=capture negate=
    rx1644_cur."!cursor_pos"(rx1644_pos)
    $P10 = rx1644_cur."O"("%list_prefix")
    unless $P10, rx1644_fail
    rx1644_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1644_pos = $P10."pos"()
  # rx pass
    rx1644_cur."!cursor_pass"(rx1644_pos, "prefix:sym<make>")
    if_null rx1644_debug, debug_1303
    rx1644_cur."!cursor_debug"("PASS", "prefix:sym<make>", " at pos=", rx1644_pos)
  debug_1303:
    .return (rx1644_cur)
  rx1644_restart:
.annotate 'line', 10
    if_null rx1644_debug, debug_1304
    rx1644_cur."!cursor_debug"("NEXT", "prefix:sym<make>")
  debug_1304:
  rx1644_fail:
    (rx1644_rep, rx1644_pos, $I10, $P10) = rx1644_cur."!mark_fail"(0)
    lt rx1644_pos, -1, rx1644_done
    eq rx1644_pos, -1, rx1644_fail
    jump $I10
  rx1644_done:
    rx1644_cur."!cursor_fail"()
    if_null rx1644_debug, debug_1305
    rx1644_cur."!cursor_debug"("FAIL", "prefix:sym<make>")
  debug_1305:
    .return (rx1644_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<make>"  :nsentry("!PREFIX__prefix:sym<make>") :subid("374_1302110486.758") :method
.annotate 'line', 10
    new $P1646, "ResizablePMCArray"
    push $P1646, "make"
    .return ($P1646)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<last>"  :subid("375_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1650_tgt
    .local int rx1650_pos
    .local int rx1650_off
    .local int rx1650_eos
    .local int rx1650_rep
    .local pmc rx1650_cur
    .local pmc rx1650_debug
    (rx1650_cur, rx1650_pos, rx1650_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1650_cur
    .local pmc match
    .lex "$/", match
    length rx1650_eos, rx1650_tgt
    gt rx1650_pos, rx1650_eos, rx1650_done
    set rx1650_off, 0
    lt rx1650_pos, 2, rx1650_start
    sub rx1650_off, rx1650_pos, 1
    substr rx1650_tgt, rx1650_tgt, rx1650_off
  rx1650_start:
    eq $I10, 1, rx1650_restart
    if_null rx1650_debug, debug_1306
    rx1650_cur."!cursor_debug"("START", "term:sym<last>")
  debug_1306:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1653_done
    goto rxscan1653_scan
  rxscan1653_loop:
    (rx1650_pos) = rx1650_cur."from"()
    inc rx1650_pos
    rx1650_cur."!cursor_from"(rx1650_pos)
    ge rx1650_pos, rx1650_eos, rxscan1653_done
  rxscan1653_scan:
    set_addr $I10, rxscan1653_loop
    rx1650_cur."!mark_push"(0, rx1650_pos, $I10)
  rxscan1653_done:
.annotate 'line', 688
  # rx subcapture "sym"
    set_addr $I10, rxcap_1654_fail
    rx1650_cur."!mark_push"(0, rx1650_pos, $I10)
  # rx literal  "last"
    add $I11, rx1650_pos, 4
    gt $I11, rx1650_eos, rx1650_fail
    sub $I11, rx1650_pos, rx1650_off
    substr $S10, rx1650_tgt, $I11, 4
    ne $S10, "last", rx1650_fail
    add rx1650_pos, 4
    set_addr $I10, rxcap_1654_fail
    ($I12, $I11) = rx1650_cur."!mark_peek"($I10)
    rx1650_cur."!cursor_pos"($I11)
    ($P10) = rx1650_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1650_pos, "")
    rx1650_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1654_done
  rxcap_1654_fail:
    goto rx1650_fail
  rxcap_1654_done:
  # rx pass
    rx1650_cur."!cursor_pass"(rx1650_pos, "term:sym<last>")
    if_null rx1650_debug, debug_1307
    rx1650_cur."!cursor_debug"("PASS", "term:sym<last>", " at pos=", rx1650_pos)
  debug_1307:
    .return (rx1650_cur)
  rx1650_restart:
.annotate 'line', 10
    if_null rx1650_debug, debug_1308
    rx1650_cur."!cursor_debug"("NEXT", "term:sym<last>")
  debug_1308:
  rx1650_fail:
    (rx1650_rep, rx1650_pos, $I10, $P10) = rx1650_cur."!mark_fail"(0)
    lt rx1650_pos, -1, rx1650_done
    eq rx1650_pos, -1, rx1650_fail
    jump $I10
  rx1650_done:
    rx1650_cur."!cursor_fail"()
    if_null rx1650_debug, debug_1309
    rx1650_cur."!cursor_debug"("FAIL", "term:sym<last>")
  debug_1309:
    .return (rx1650_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<last>"  :nsentry("!PREFIX__term:sym<last>") :subid("376_1302110486.758") :method
.annotate 'line', 10
    new $P1652, "ResizablePMCArray"
    push $P1652, "last"
    .return ($P1652)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<next>"  :subid("377_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1656_tgt
    .local int rx1656_pos
    .local int rx1656_off
    .local int rx1656_eos
    .local int rx1656_rep
    .local pmc rx1656_cur
    .local pmc rx1656_debug
    (rx1656_cur, rx1656_pos, rx1656_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1656_cur
    .local pmc match
    .lex "$/", match
    length rx1656_eos, rx1656_tgt
    gt rx1656_pos, rx1656_eos, rx1656_done
    set rx1656_off, 0
    lt rx1656_pos, 2, rx1656_start
    sub rx1656_off, rx1656_pos, 1
    substr rx1656_tgt, rx1656_tgt, rx1656_off
  rx1656_start:
    eq $I10, 1, rx1656_restart
    if_null rx1656_debug, debug_1310
    rx1656_cur."!cursor_debug"("START", "term:sym<next>")
  debug_1310:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1659_done
    goto rxscan1659_scan
  rxscan1659_loop:
    (rx1656_pos) = rx1656_cur."from"()
    inc rx1656_pos
    rx1656_cur."!cursor_from"(rx1656_pos)
    ge rx1656_pos, rx1656_eos, rxscan1659_done
  rxscan1659_scan:
    set_addr $I10, rxscan1659_loop
    rx1656_cur."!mark_push"(0, rx1656_pos, $I10)
  rxscan1659_done:
.annotate 'line', 689
  # rx subcapture "sym"
    set_addr $I10, rxcap_1660_fail
    rx1656_cur."!mark_push"(0, rx1656_pos, $I10)
  # rx literal  "next"
    add $I11, rx1656_pos, 4
    gt $I11, rx1656_eos, rx1656_fail
    sub $I11, rx1656_pos, rx1656_off
    substr $S10, rx1656_tgt, $I11, 4
    ne $S10, "next", rx1656_fail
    add rx1656_pos, 4
    set_addr $I10, rxcap_1660_fail
    ($I12, $I11) = rx1656_cur."!mark_peek"($I10)
    rx1656_cur."!cursor_pos"($I11)
    ($P10) = rx1656_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1656_pos, "")
    rx1656_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1660_done
  rxcap_1660_fail:
    goto rx1656_fail
  rxcap_1660_done:
  # rx pass
    rx1656_cur."!cursor_pass"(rx1656_pos, "term:sym<next>")
    if_null rx1656_debug, debug_1311
    rx1656_cur."!cursor_debug"("PASS", "term:sym<next>", " at pos=", rx1656_pos)
  debug_1311:
    .return (rx1656_cur)
  rx1656_restart:
.annotate 'line', 10
    if_null rx1656_debug, debug_1312
    rx1656_cur."!cursor_debug"("NEXT", "term:sym<next>")
  debug_1312:
  rx1656_fail:
    (rx1656_rep, rx1656_pos, $I10, $P10) = rx1656_cur."!mark_fail"(0)
    lt rx1656_pos, -1, rx1656_done
    eq rx1656_pos, -1, rx1656_fail
    jump $I10
  rx1656_done:
    rx1656_cur."!cursor_fail"()
    if_null rx1656_debug, debug_1313
    rx1656_cur."!cursor_debug"("FAIL", "term:sym<next>")
  debug_1313:
    .return (rx1656_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<next>"  :nsentry("!PREFIX__term:sym<next>") :subid("378_1302110486.758") :method
.annotate 'line', 10
    new $P1658, "ResizablePMCArray"
    push $P1658, "next"
    .return ($P1658)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<redo>"  :subid("379_1302110486.758") :method :outer("12_1302110486.758")
.annotate 'line', 10
    .local string rx1662_tgt
    .local int rx1662_pos
    .local int rx1662_off
    .local int rx1662_eos
    .local int rx1662_rep
    .local pmc rx1662_cur
    .local pmc rx1662_debug
    (rx1662_cur, rx1662_pos, rx1662_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1662_cur
    .local pmc match
    .lex "$/", match
    length rx1662_eos, rx1662_tgt
    gt rx1662_pos, rx1662_eos, rx1662_done
    set rx1662_off, 0
    lt rx1662_pos, 2, rx1662_start
    sub rx1662_off, rx1662_pos, 1
    substr rx1662_tgt, rx1662_tgt, rx1662_off
  rx1662_start:
    eq $I10, 1, rx1662_restart
    if_null rx1662_debug, debug_1314
    rx1662_cur."!cursor_debug"("START", "term:sym<redo>")
  debug_1314:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1665_done
    goto rxscan1665_scan
  rxscan1665_loop:
    (rx1662_pos) = rx1662_cur."from"()
    inc rx1662_pos
    rx1662_cur."!cursor_from"(rx1662_pos)
    ge rx1662_pos, rx1662_eos, rxscan1665_done
  rxscan1665_scan:
    set_addr $I10, rxscan1665_loop
    rx1662_cur."!mark_push"(0, rx1662_pos, $I10)
  rxscan1665_done:
.annotate 'line', 690
  # rx subcapture "sym"
    set_addr $I10, rxcap_1666_fail
    rx1662_cur."!mark_push"(0, rx1662_pos, $I10)
  # rx literal  "redo"
    add $I11, rx1662_pos, 4
    gt $I11, rx1662_eos, rx1662_fail
    sub $I11, rx1662_pos, rx1662_off
    substr $S10, rx1662_tgt, $I11, 4
    ne $S10, "redo", rx1662_fail
    add rx1662_pos, 4
    set_addr $I10, rxcap_1666_fail
    ($I12, $I11) = rx1662_cur."!mark_peek"($I10)
    rx1662_cur."!cursor_pos"($I11)
    ($P10) = rx1662_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1662_pos, "")
    rx1662_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1666_done
  rxcap_1666_fail:
    goto rx1662_fail
  rxcap_1666_done:
  # rx pass
    rx1662_cur."!cursor_pass"(rx1662_pos, "term:sym<redo>")
    if_null rx1662_debug, debug_1315
    rx1662_cur."!cursor_debug"("PASS", "term:sym<redo>", " at pos=", rx1662_pos)
  debug_1315:
    .return (rx1662_cur)
  rx1662_restart:
.annotate 'line', 10
    if_null rx1662_debug, debug_1316
    rx1662_cur."!cursor_debug"("NEXT", "term:sym<redo>")
  debug_1316:
  rx1662_fail:
    (rx1662_rep, rx1662_pos, $I10, $P10) = rx1662_cur."!mark_fail"(0)
    lt rx1662_pos, -1, rx1662_done
    eq rx1662_pos, -1, rx1662_fail
    jump $I10
  rx1662_done:
    rx1662_cur."!cursor_fail"()
    if_null rx1662_debug, debug_1317
    rx1662_cur."!cursor_debug"("FAIL", "term:sym<redo>")
  debug_1317:
    .return (rx1662_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<redo>"  :nsentry("!PREFIX__term:sym<redo>") :subid("380_1302110486.758") :method
.annotate 'line', 10
    new $P1664, "ResizablePMCArray"
    push $P1664, "redo"
    .return ($P1664)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "smartmatch"  :subid("381_1302110486.758") :outer("12_1302110486.758")
    .param pmc param_1668
    .param pmc param_1669
.annotate 'line', 692
    .lex "self", param_1668
    .lex "$/", param_1669
.annotate 'line', 694
    new $P1670, "Undef"
    .lex "$t", $P1670
    find_lex $P1671, "$/"
    unless_null $P1671, vivify_1318
    $P1671 = root_new ['parrot';'ResizablePMCArray']
  vivify_1318:
    set $P1672, $P1671[0]
    unless_null $P1672, vivify_1319
    new $P1672, "Undef"
  vivify_1319:
    store_lex "$t", $P1672
    find_lex $P1673, "$/"
    unless_null $P1673, vivify_1320
    $P1673 = root_new ['parrot';'ResizablePMCArray']
  vivify_1320:
    set $P1674, $P1673[1]
    unless_null $P1674, vivify_1321
    new $P1674, "Undef"
  vivify_1321:
    find_lex $P1675, "$/"
    unless_null $P1675, vivify_1322
    $P1675 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P1675
  vivify_1322:
    set $P1675[0], $P1674
    find_lex $P1676, "$t"
    find_lex $P1677, "$/"
    unless_null $P1677, vivify_1323
    $P1677 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P1677
  vivify_1323:
    set $P1677[1], $P1676
.annotate 'line', 692
    .return ($P1676)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2398"  :subid("383_1302110486.758") :outer("10_1302110486.758")
.annotate 'line', 698
    .const 'Sub' $P2463 = "404_1302110486.758" 
    capture_lex $P2463
    .const 'Sub' $P2456 = "402_1302110486.758" 
    capture_lex $P2456
    .const 'Sub' $P2451 = "400_1302110486.758" 
    capture_lex $P2451
    .const 'Sub' $P2439 = "397_1302110486.758" 
    capture_lex $P2439
    .const 'Sub' $P2429 = "394_1302110486.758" 
    capture_lex $P2429
    .const 'Sub' $P2424 = "392_1302110486.758" 
    capture_lex $P2424
    .const 'Sub' $P2415 = "389_1302110486.758" 
    capture_lex $P2415
    .const 'Sub' $P2410 = "387_1302110486.758" 
    capture_lex $P2410
    .const 'Sub' $P2401 = "384_1302110486.758" 
    capture_lex $P2401
    .lex "$?CLASS", $P2400
    .const 'Sub' $P2456 = "402_1302110486.758" 
    capture_lex $P2456
    .return ($P2456)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "" :load :init :subid("post1324") :outer("383_1302110486.758")
.annotate 'line', 698
    get_hll_global $P2399, ["NQP";"Regex"], "_block2398" 
    .local pmc block
    set block, $P2399
    .const 'Sub' $P2463 = "404_1302110486.758" 
    capture_lex $P2463
    $P2463()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2462"  :anon :subid("404_1302110486.758") :outer("383_1302110486.758")
.annotate 'line', 698
    nqp_get_sc_object $P2464, "1302110474.135", 1
    .local pmc type_obj
    set type_obj, $P2464
    get_how $P2465, type_obj
    .const 'Sub' $P2466 = "384_1302110486.758" 
    $P2465."add_method"(type_obj, "metachar:sym<:my>", $P2466)
    get_how $P2467, type_obj
    get_global $P2468, "!PREFIX__metachar:sym<:my>"
    $P2467."add_method"(type_obj, "!PREFIX__metachar:sym<:my>", $P2468)
    get_how $P2469, type_obj
    .const 'Sub' $P2470 = "387_1302110486.758" 
    $P2469."add_method"(type_obj, "metachar:sym<{ }>", $P2470)
    get_how $P2471, type_obj
    get_global $P2472, "!PREFIX__metachar:sym<{ }>"
    $P2471."add_method"(type_obj, "!PREFIX__metachar:sym<{ }>", $P2472)
    get_how $P2473, type_obj
    .const 'Sub' $P2474 = "389_1302110486.758" 
    $P2473."add_method"(type_obj, "metachar:sym<nqpvar>", $P2474)
    get_how $P2475, type_obj
    get_global $P2476, "!PREFIX__metachar:sym<nqpvar>"
    $P2475."add_method"(type_obj, "!PREFIX__metachar:sym<nqpvar>", $P2476)
    get_how $P2477, type_obj
    .const 'Sub' $P2478 = "392_1302110486.758" 
    $P2477."add_method"(type_obj, "assertion:sym<{ }>", $P2478)
    get_how $P2479, type_obj
    get_global $P2480, "!PREFIX__assertion:sym<{ }>"
    $P2479."add_method"(type_obj, "!PREFIX__assertion:sym<{ }>", $P2480)
    get_how $P2481, type_obj
    .const 'Sub' $P2482 = "394_1302110486.758" 
    $P2481."add_method"(type_obj, "assertion:sym<?{ }>", $P2482)
    get_how $P2483, type_obj
    get_global $P2484, "!PREFIX__assertion:sym<?{ }>"
    $P2483."add_method"(type_obj, "!PREFIX__assertion:sym<?{ }>", $P2484)
    get_how $P2485, type_obj
    .const 'Sub' $P2486 = "397_1302110486.758" 
    $P2485."add_method"(type_obj, "assertion:sym<name>", $P2486)
    get_how $P2487, type_obj
    get_global $P2488, "!PREFIX__assertion:sym<name>"
    $P2487."add_method"(type_obj, "!PREFIX__assertion:sym<name>", $P2488)
    get_how $P2489, type_obj
    .const 'Sub' $P2490 = "400_1302110486.758" 
    $P2489."add_method"(type_obj, "assertion:sym<var>", $P2490)
    get_how $P2491, type_obj
    get_global $P2492, "!PREFIX__assertion:sym<var>"
    $P2491."add_method"(type_obj, "!PREFIX__assertion:sym<var>", $P2492)
    get_how $P2493, type_obj
    .const 'Sub' $P2494 = "402_1302110486.758" 
    $P2493."add_method"(type_obj, "codeblock", $P2494)
    get_how $P2495, type_obj
    get_global $P2496, "!PREFIX__codeblock"
    $P2495."add_method"(type_obj, "!PREFIX__codeblock", $P2496)
    get_how $P2497, type_obj
    get_hll_global $P2498, ["Regex";"P6Regex"], "Grammar"
    $P2497."add_parent"(type_obj, $P2498)
    get_how $P2499, type_obj
    $P2500 = $P2499."compose"(type_obj)
    .return ($P2500)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<:my>"  :subid("384_1302110486.758") :method :outer("383_1302110486.758")
.annotate 'line', 698
    .const 'Sub' $P2407 = "386_1302110486.758" 
    capture_lex $P2407
    .local string rx2402_tgt
    .local int rx2402_pos
    .local int rx2402_off
    .local int rx2402_eos
    .local int rx2402_rep
    .local pmc rx2402_cur
    .local pmc rx2402_debug
    (rx2402_cur, rx2402_pos, rx2402_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2402_cur
    .local pmc match
    .lex "$/", match
    length rx2402_eos, rx2402_tgt
    gt rx2402_pos, rx2402_eos, rx2402_done
    set rx2402_off, 0
    lt rx2402_pos, 2, rx2402_start
    sub rx2402_off, rx2402_pos, 1
    substr rx2402_tgt, rx2402_tgt, rx2402_off
  rx2402_start:
    eq $I10, 1, rx2402_restart
    if_null rx2402_debug, debug_1325
    rx2402_cur."!cursor_debug"("START", "metachar:sym<:my>")
  debug_1325:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2405_done
    goto rxscan2405_scan
  rxscan2405_loop:
    (rx2402_pos) = rx2402_cur."from"()
    inc rx2402_pos
    rx2402_cur."!cursor_from"(rx2402_pos)
    ge rx2402_pos, rx2402_eos, rxscan2405_done
  rxscan2405_scan:
    set_addr $I10, rxscan2405_loop
    rx2402_cur."!mark_push"(0, rx2402_pos, $I10)
  rxscan2405_done:
.annotate 'line', 700
  # rx literal  ":"
    add $I11, rx2402_pos, 1
    gt $I11, rx2402_eos, rx2402_fail
    sub $I11, rx2402_pos, rx2402_off
    ord $I11, rx2402_tgt, $I11
    ne $I11, 58, rx2402_fail
    add rx2402_pos, 1
  # rx subrule "before" subtype=zerowidth negate=
    rx2402_cur."!cursor_pos"(rx2402_pos)
    .const 'Sub' $P2407 = "386_1302110486.758" 
    capture_lex $P2407
    $P10 = rx2402_cur."before"($P2407)
    unless $P10, rx2402_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2402_cur."!cursor_pos"(rx2402_pos)
    $P10 = rx2402_cur."LANG"("MAIN", "statement")
    unless $P10, rx2402_fail
    rx2402_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx2402_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2402_cur."!cursor_pos"(rx2402_pos)
    $P10 = rx2402_cur."ws"()
    unless $P10, rx2402_fail
    rx2402_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx2402_pos, 1
    gt $I11, rx2402_eos, rx2402_fail
    sub $I11, rx2402_pos, rx2402_off
    ord $I11, rx2402_tgt, $I11
    ne $I11, 59, rx2402_fail
    add rx2402_pos, 1
.annotate 'line', 699
  # rx pass
    rx2402_cur."!cursor_pass"(rx2402_pos, "metachar:sym<:my>")
    if_null rx2402_debug, debug_1330
    rx2402_cur."!cursor_debug"("PASS", "metachar:sym<:my>", " at pos=", rx2402_pos)
  debug_1330:
    .return (rx2402_cur)
  rx2402_restart:
.annotate 'line', 698
    if_null rx2402_debug, debug_1331
    rx2402_cur."!cursor_debug"("NEXT", "metachar:sym<:my>")
  debug_1331:
  rx2402_fail:
    (rx2402_rep, rx2402_pos, $I10, $P10) = rx2402_cur."!mark_fail"(0)
    lt rx2402_pos, -1, rx2402_done
    eq rx2402_pos, -1, rx2402_fail
    jump $I10
  rx2402_done:
    rx2402_cur."!cursor_fail"()
    if_null rx2402_debug, debug_1332
    rx2402_cur."!cursor_debug"("FAIL", "metachar:sym<:my>")
  debug_1332:
    .return (rx2402_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<:my>"  :nsentry("!PREFIX__metachar:sym<:my>") :subid("385_1302110486.758") :method
.annotate 'line', 698
    new $P2404, "ResizablePMCArray"
    push $P2404, ":"
    .return ($P2404)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2406"  :anon :subid("386_1302110486.758") :method :outer("384_1302110486.758")
.annotate 'line', 700
    .local string rx2408_tgt
    .local int rx2408_pos
    .local int rx2408_off
    .local int rx2408_eos
    .local int rx2408_rep
    .local pmc rx2408_cur
    .local pmc rx2408_debug
    (rx2408_cur, rx2408_pos, rx2408_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2408_cur
    .local pmc match
    .lex "$/", match
    length rx2408_eos, rx2408_tgt
    gt rx2408_pos, rx2408_eos, rx2408_done
    set rx2408_off, 0
    lt rx2408_pos, 2, rx2408_start
    sub rx2408_off, rx2408_pos, 1
    substr rx2408_tgt, rx2408_tgt, rx2408_off
  rx2408_start:
    eq $I10, 1, rx2408_restart
    if_null rx2408_debug, debug_1326
    rx2408_cur."!cursor_debug"("START", "")
  debug_1326:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2409_done
    goto rxscan2409_scan
  rxscan2409_loop:
    (rx2408_pos) = rx2408_cur."from"()
    inc rx2408_pos
    rx2408_cur."!cursor_from"(rx2408_pos)
    ge rx2408_pos, rx2408_eos, rxscan2409_done
  rxscan2409_scan:
    set_addr $I10, rxscan2409_loop
    rx2408_cur."!mark_push"(0, rx2408_pos, $I10)
  rxscan2409_done:
  # rx literal  "my"
    add $I11, rx2408_pos, 2
    gt $I11, rx2408_eos, rx2408_fail
    sub $I11, rx2408_pos, rx2408_off
    substr $S10, rx2408_tgt, $I11, 2
    ne $S10, "my", rx2408_fail
    add rx2408_pos, 2
  # rx pass
    rx2408_cur."!cursor_pass"(rx2408_pos, "")
    if_null rx2408_debug, debug_1327
    rx2408_cur."!cursor_debug"("PASS", "", " at pos=", rx2408_pos)
  debug_1327:
    .return (rx2408_cur)
  rx2408_restart:
    if_null rx2408_debug, debug_1328
    rx2408_cur."!cursor_debug"("NEXT", "")
  debug_1328:
  rx2408_fail:
    (rx2408_rep, rx2408_pos, $I10, $P10) = rx2408_cur."!mark_fail"(0)
    lt rx2408_pos, -1, rx2408_done
    eq rx2408_pos, -1, rx2408_fail
    jump $I10
  rx2408_done:
    rx2408_cur."!cursor_fail"()
    if_null rx2408_debug, debug_1329
    rx2408_cur."!cursor_debug"("FAIL", "")
  debug_1329:
    .return (rx2408_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<{ }>"  :subid("387_1302110486.758") :method :outer("383_1302110486.758")
.annotate 'line', 698
    .local string rx2411_tgt
    .local int rx2411_pos
    .local int rx2411_off
    .local int rx2411_eos
    .local int rx2411_rep
    .local pmc rx2411_cur
    .local pmc rx2411_debug
    (rx2411_cur, rx2411_pos, rx2411_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2411_cur
    .local pmc match
    .lex "$/", match
    length rx2411_eos, rx2411_tgt
    gt rx2411_pos, rx2411_eos, rx2411_done
    set rx2411_off, 0
    lt rx2411_pos, 2, rx2411_start
    sub rx2411_off, rx2411_pos, 1
    substr rx2411_tgt, rx2411_tgt, rx2411_off
  rx2411_start:
    eq $I10, 1, rx2411_restart
    if_null rx2411_debug, debug_1333
    rx2411_cur."!cursor_debug"("START", "metachar:sym<{ }>")
  debug_1333:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2414_done
    goto rxscan2414_scan
  rxscan2414_loop:
    (rx2411_pos) = rx2411_cur."from"()
    inc rx2411_pos
    rx2411_cur."!cursor_from"(rx2411_pos)
    ge rx2411_pos, rx2411_eos, rxscan2414_done
  rxscan2414_scan:
    set_addr $I10, rxscan2414_loop
    rx2411_cur."!mark_push"(0, rx2411_pos, $I10)
  rxscan2414_done:
.annotate 'line', 704
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2411_pos, rx2411_off
    substr $S10, rx2411_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2411_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx2411_cur."!cursor_pos"(rx2411_pos)
    $P10 = rx2411_cur."codeblock"()
    unless $P10, rx2411_fail
    rx2411_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2411_pos = $P10."pos"()
.annotate 'line', 703
  # rx pass
    rx2411_cur."!cursor_pass"(rx2411_pos, "metachar:sym<{ }>")
    if_null rx2411_debug, debug_1334
    rx2411_cur."!cursor_debug"("PASS", "metachar:sym<{ }>", " at pos=", rx2411_pos)
  debug_1334:
    .return (rx2411_cur)
  rx2411_restart:
.annotate 'line', 698
    if_null rx2411_debug, debug_1335
    rx2411_cur."!cursor_debug"("NEXT", "metachar:sym<{ }>")
  debug_1335:
  rx2411_fail:
    (rx2411_rep, rx2411_pos, $I10, $P10) = rx2411_cur."!mark_fail"(0)
    lt rx2411_pos, -1, rx2411_done
    eq rx2411_pos, -1, rx2411_fail
    jump $I10
  rx2411_done:
    rx2411_cur."!cursor_fail"()
    if_null rx2411_debug, debug_1336
    rx2411_cur."!cursor_debug"("FAIL", "metachar:sym<{ }>")
  debug_1336:
    .return (rx2411_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<{ }>"  :nsentry("!PREFIX__metachar:sym<{ }>") :subid("388_1302110486.758") :method
.annotate 'line', 698
    new $P2413, "ResizablePMCArray"
    push $P2413, "{"
    .return ($P2413)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<nqpvar>"  :subid("389_1302110486.758") :method :outer("383_1302110486.758")
.annotate 'line', 698
    .const 'Sub' $P2421 = "391_1302110486.758" 
    capture_lex $P2421
    .local string rx2416_tgt
    .local int rx2416_pos
    .local int rx2416_off
    .local int rx2416_eos
    .local int rx2416_rep
    .local pmc rx2416_cur
    .local pmc rx2416_debug
    (rx2416_cur, rx2416_pos, rx2416_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2416_cur
    .local pmc match
    .lex "$/", match
    length rx2416_eos, rx2416_tgt
    gt rx2416_pos, rx2416_eos, rx2416_done
    set rx2416_off, 0
    lt rx2416_pos, 2, rx2416_start
    sub rx2416_off, rx2416_pos, 1
    substr rx2416_tgt, rx2416_tgt, rx2416_off
  rx2416_start:
    eq $I10, 1, rx2416_restart
    if_null rx2416_debug, debug_1337
    rx2416_cur."!cursor_debug"("START", "metachar:sym<nqpvar>")
  debug_1337:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2419_done
    goto rxscan2419_scan
  rxscan2419_loop:
    (rx2416_pos) = rx2416_cur."from"()
    inc rx2416_pos
    rx2416_cur."!cursor_from"(rx2416_pos)
    ge rx2416_pos, rx2416_eos, rxscan2419_done
  rxscan2419_scan:
    set_addr $I10, rxscan2419_loop
    rx2416_cur."!mark_push"(0, rx2416_pos, $I10)
  rxscan2419_done:
.annotate 'line', 708
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2416_pos, rx2416_off
    substr $S10, rx2416_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx2416_fail
  # rx subrule "before" subtype=zerowidth negate=
    rx2416_cur."!cursor_pos"(rx2416_pos)
    .const 'Sub' $P2421 = "391_1302110486.758" 
    capture_lex $P2421
    $P10 = rx2416_cur."before"($P2421)
    unless $P10, rx2416_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2416_cur."!cursor_pos"(rx2416_pos)
    $P10 = rx2416_cur."LANG"("MAIN", "variable")
    unless $P10, rx2416_fail
    rx2416_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx2416_pos = $P10."pos"()
.annotate 'line', 707
  # rx pass
    rx2416_cur."!cursor_pass"(rx2416_pos, "metachar:sym<nqpvar>")
    if_null rx2416_debug, debug_1342
    rx2416_cur."!cursor_debug"("PASS", "metachar:sym<nqpvar>", " at pos=", rx2416_pos)
  debug_1342:
    .return (rx2416_cur)
  rx2416_restart:
.annotate 'line', 698
    if_null rx2416_debug, debug_1343
    rx2416_cur."!cursor_debug"("NEXT", "metachar:sym<nqpvar>")
  debug_1343:
  rx2416_fail:
    (rx2416_rep, rx2416_pos, $I10, $P10) = rx2416_cur."!mark_fail"(0)
    lt rx2416_pos, -1, rx2416_done
    eq rx2416_pos, -1, rx2416_fail
    jump $I10
  rx2416_done:
    rx2416_cur."!cursor_fail"()
    if_null rx2416_debug, debug_1344
    rx2416_cur."!cursor_debug"("FAIL", "metachar:sym<nqpvar>")
  debug_1344:
    .return (rx2416_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<nqpvar>"  :nsentry("!PREFIX__metachar:sym<nqpvar>") :subid("390_1302110486.758") :method
.annotate 'line', 698
    new $P2418, "ResizablePMCArray"
    push $P2418, "$"
    push $P2418, "@"
    .return ($P2418)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2420"  :anon :subid("391_1302110486.758") :method :outer("389_1302110486.758")
.annotate 'line', 708
    .local string rx2422_tgt
    .local int rx2422_pos
    .local int rx2422_off
    .local int rx2422_eos
    .local int rx2422_rep
    .local pmc rx2422_cur
    .local pmc rx2422_debug
    (rx2422_cur, rx2422_pos, rx2422_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2422_cur
    .local pmc match
    .lex "$/", match
    length rx2422_eos, rx2422_tgt
    gt rx2422_pos, rx2422_eos, rx2422_done
    set rx2422_off, 0
    lt rx2422_pos, 2, rx2422_start
    sub rx2422_off, rx2422_pos, 1
    substr rx2422_tgt, rx2422_tgt, rx2422_off
  rx2422_start:
    eq $I10, 1, rx2422_restart
    if_null rx2422_debug, debug_1338
    rx2422_cur."!cursor_debug"("START", "")
  debug_1338:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2423_done
    goto rxscan2423_scan
  rxscan2423_loop:
    (rx2422_pos) = rx2422_cur."from"()
    inc rx2422_pos
    rx2422_cur."!cursor_from"(rx2422_pos)
    ge rx2422_pos, rx2422_eos, rxscan2423_done
  rxscan2423_scan:
    set_addr $I10, rxscan2423_loop
    rx2422_cur."!mark_push"(0, rx2422_pos, $I10)
  rxscan2423_done:
  # rx charclass .
    ge rx2422_pos, rx2422_eos, rx2422_fail
    inc rx2422_pos
  # rx charclass w
    ge rx2422_pos, rx2422_eos, rx2422_fail
    sub $I10, rx2422_pos, rx2422_off
    is_cclass $I11, 8192, rx2422_tgt, $I10
    unless $I11, rx2422_fail
    inc rx2422_pos
  # rx pass
    rx2422_cur."!cursor_pass"(rx2422_pos, "")
    if_null rx2422_debug, debug_1339
    rx2422_cur."!cursor_debug"("PASS", "", " at pos=", rx2422_pos)
  debug_1339:
    .return (rx2422_cur)
  rx2422_restart:
    if_null rx2422_debug, debug_1340
    rx2422_cur."!cursor_debug"("NEXT", "")
  debug_1340:
  rx2422_fail:
    (rx2422_rep, rx2422_pos, $I10, $P10) = rx2422_cur."!mark_fail"(0)
    lt rx2422_pos, -1, rx2422_done
    eq rx2422_pos, -1, rx2422_fail
    jump $I10
  rx2422_done:
    rx2422_cur."!cursor_fail"()
    if_null rx2422_debug, debug_1341
    rx2422_cur."!cursor_debug"("FAIL", "")
  debug_1341:
    .return (rx2422_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<{ }>"  :subid("392_1302110486.758") :method :outer("383_1302110486.758")
.annotate 'line', 698
    .local string rx2425_tgt
    .local int rx2425_pos
    .local int rx2425_off
    .local int rx2425_eos
    .local int rx2425_rep
    .local pmc rx2425_cur
    .local pmc rx2425_debug
    (rx2425_cur, rx2425_pos, rx2425_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2425_cur
    .local pmc match
    .lex "$/", match
    length rx2425_eos, rx2425_tgt
    gt rx2425_pos, rx2425_eos, rx2425_done
    set rx2425_off, 0
    lt rx2425_pos, 2, rx2425_start
    sub rx2425_off, rx2425_pos, 1
    substr rx2425_tgt, rx2425_tgt, rx2425_off
  rx2425_start:
    eq $I10, 1, rx2425_restart
    if_null rx2425_debug, debug_1345
    rx2425_cur."!cursor_debug"("START", "assertion:sym<{ }>")
  debug_1345:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2428_done
    goto rxscan2428_scan
  rxscan2428_loop:
    (rx2425_pos) = rx2425_cur."from"()
    inc rx2425_pos
    rx2425_cur."!cursor_from"(rx2425_pos)
    ge rx2425_pos, rx2425_eos, rxscan2428_done
  rxscan2428_scan:
    set_addr $I10, rxscan2428_loop
    rx2425_cur."!mark_push"(0, rx2425_pos, $I10)
  rxscan2428_done:
.annotate 'line', 712
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2425_pos, rx2425_off
    substr $S10, rx2425_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2425_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx2425_cur."!cursor_pos"(rx2425_pos)
    $P10 = rx2425_cur."codeblock"()
    unless $P10, rx2425_fail
    rx2425_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2425_pos = $P10."pos"()
.annotate 'line', 711
  # rx pass
    rx2425_cur."!cursor_pass"(rx2425_pos, "assertion:sym<{ }>")
    if_null rx2425_debug, debug_1346
    rx2425_cur."!cursor_debug"("PASS", "assertion:sym<{ }>", " at pos=", rx2425_pos)
  debug_1346:
    .return (rx2425_cur)
  rx2425_restart:
.annotate 'line', 698
    if_null rx2425_debug, debug_1347
    rx2425_cur."!cursor_debug"("NEXT", "assertion:sym<{ }>")
  debug_1347:
  rx2425_fail:
    (rx2425_rep, rx2425_pos, $I10, $P10) = rx2425_cur."!mark_fail"(0)
    lt rx2425_pos, -1, rx2425_done
    eq rx2425_pos, -1, rx2425_fail
    jump $I10
  rx2425_done:
    rx2425_cur."!cursor_fail"()
    if_null rx2425_debug, debug_1348
    rx2425_cur."!cursor_debug"("FAIL", "assertion:sym<{ }>")
  debug_1348:
    .return (rx2425_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<{ }>"  :nsentry("!PREFIX__assertion:sym<{ }>") :subid("393_1302110486.758") :method
.annotate 'line', 698
    new $P2427, "ResizablePMCArray"
    push $P2427, "{"
    .return ($P2427)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<?{ }>"  :subid("394_1302110486.758") :method :outer("383_1302110486.758")
.annotate 'line', 698
    .const 'Sub' $P2435 = "396_1302110486.758" 
    capture_lex $P2435
    .local string rx2430_tgt
    .local int rx2430_pos
    .local int rx2430_off
    .local int rx2430_eos
    .local int rx2430_rep
    .local pmc rx2430_cur
    .local pmc rx2430_debug
    (rx2430_cur, rx2430_pos, rx2430_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2430_cur
    .local pmc match
    .lex "$/", match
    length rx2430_eos, rx2430_tgt
    gt rx2430_pos, rx2430_eos, rx2430_done
    set rx2430_off, 0
    lt rx2430_pos, 2, rx2430_start
    sub rx2430_off, rx2430_pos, 1
    substr rx2430_tgt, rx2430_tgt, rx2430_off
  rx2430_start:
    eq $I10, 1, rx2430_restart
    if_null rx2430_debug, debug_1349
    rx2430_cur."!cursor_debug"("START", "assertion:sym<?{ }>")
  debug_1349:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2433_done
    goto rxscan2433_scan
  rxscan2433_loop:
    (rx2430_pos) = rx2430_cur."from"()
    inc rx2430_pos
    rx2430_cur."!cursor_from"(rx2430_pos)
    ge rx2430_pos, rx2430_eos, rxscan2433_done
  rxscan2433_scan:
    set_addr $I10, rxscan2433_loop
    rx2430_cur."!mark_push"(0, rx2430_pos, $I10)
  rxscan2433_done:
.annotate 'line', 716
  # rx subcapture "zw"
    set_addr $I10, rxcap_2438_fail
    rx2430_cur."!mark_push"(0, rx2430_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx2430_pos, rx2430_eos, rx2430_fail
    sub $I10, rx2430_pos, rx2430_off
    substr $S10, rx2430_tgt, $I10, 1
    index $I11, "?!", $S10
    lt $I11, 0, rx2430_fail
    inc rx2430_pos
  # rx subrule "before" subtype=zerowidth negate=
    rx2430_cur."!cursor_pos"(rx2430_pos)
    .const 'Sub' $P2435 = "396_1302110486.758" 
    capture_lex $P2435
    $P10 = rx2430_cur."before"($P2435)
    unless $P10, rx2430_fail
    set_addr $I10, rxcap_2438_fail
    ($I12, $I11) = rx2430_cur."!mark_peek"($I10)
    rx2430_cur."!cursor_pos"($I11)
    ($P10) = rx2430_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2430_pos, "")
    rx2430_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("zw")
    goto rxcap_2438_done
  rxcap_2438_fail:
    goto rx2430_fail
  rxcap_2438_done:
  # rx subrule "codeblock" subtype=capture negate=
    rx2430_cur."!cursor_pos"(rx2430_pos)
    $P10 = rx2430_cur."codeblock"()
    unless $P10, rx2430_fail
    rx2430_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2430_pos = $P10."pos"()
.annotate 'line', 715
  # rx pass
    rx2430_cur."!cursor_pass"(rx2430_pos, "assertion:sym<?{ }>")
    if_null rx2430_debug, debug_1354
    rx2430_cur."!cursor_debug"("PASS", "assertion:sym<?{ }>", " at pos=", rx2430_pos)
  debug_1354:
    .return (rx2430_cur)
  rx2430_restart:
.annotate 'line', 698
    if_null rx2430_debug, debug_1355
    rx2430_cur."!cursor_debug"("NEXT", "assertion:sym<?{ }>")
  debug_1355:
  rx2430_fail:
    (rx2430_rep, rx2430_pos, $I10, $P10) = rx2430_cur."!mark_fail"(0)
    lt rx2430_pos, -1, rx2430_done
    eq rx2430_pos, -1, rx2430_fail
    jump $I10
  rx2430_done:
    rx2430_cur."!cursor_fail"()
    if_null rx2430_debug, debug_1356
    rx2430_cur."!cursor_debug"("FAIL", "assertion:sym<?{ }>")
  debug_1356:
    .return (rx2430_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<?{ }>"  :nsentry("!PREFIX__assertion:sym<?{ }>") :subid("395_1302110486.758") :method
.annotate 'line', 698
    new $P2432, "ResizablePMCArray"
    push $P2432, "!"
    push $P2432, "?"
    .return ($P2432)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2434"  :anon :subid("396_1302110486.758") :method :outer("394_1302110486.758")
.annotate 'line', 716
    .local string rx2436_tgt
    .local int rx2436_pos
    .local int rx2436_off
    .local int rx2436_eos
    .local int rx2436_rep
    .local pmc rx2436_cur
    .local pmc rx2436_debug
    (rx2436_cur, rx2436_pos, rx2436_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2436_cur
    .local pmc match
    .lex "$/", match
    length rx2436_eos, rx2436_tgt
    gt rx2436_pos, rx2436_eos, rx2436_done
    set rx2436_off, 0
    lt rx2436_pos, 2, rx2436_start
    sub rx2436_off, rx2436_pos, 1
    substr rx2436_tgt, rx2436_tgt, rx2436_off
  rx2436_start:
    eq $I10, 1, rx2436_restart
    if_null rx2436_debug, debug_1350
    rx2436_cur."!cursor_debug"("START", "")
  debug_1350:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2437_done
    goto rxscan2437_scan
  rxscan2437_loop:
    (rx2436_pos) = rx2436_cur."from"()
    inc rx2436_pos
    rx2436_cur."!cursor_from"(rx2436_pos)
    ge rx2436_pos, rx2436_eos, rxscan2437_done
  rxscan2437_scan:
    set_addr $I10, rxscan2437_loop
    rx2436_cur."!mark_push"(0, rx2436_pos, $I10)
  rxscan2437_done:
  # rx literal  "{"
    add $I11, rx2436_pos, 1
    gt $I11, rx2436_eos, rx2436_fail
    sub $I11, rx2436_pos, rx2436_off
    ord $I11, rx2436_tgt, $I11
    ne $I11, 123, rx2436_fail
    add rx2436_pos, 1
  # rx pass
    rx2436_cur."!cursor_pass"(rx2436_pos, "")
    if_null rx2436_debug, debug_1351
    rx2436_cur."!cursor_debug"("PASS", "", " at pos=", rx2436_pos)
  debug_1351:
    .return (rx2436_cur)
  rx2436_restart:
    if_null rx2436_debug, debug_1352
    rx2436_cur."!cursor_debug"("NEXT", "")
  debug_1352:
  rx2436_fail:
    (rx2436_rep, rx2436_pos, $I10, $P10) = rx2436_cur."!mark_fail"(0)
    lt rx2436_pos, -1, rx2436_done
    eq rx2436_pos, -1, rx2436_fail
    jump $I10
  rx2436_done:
    rx2436_cur."!cursor_fail"()
    if_null rx2436_debug, debug_1353
    rx2436_cur."!cursor_debug"("FAIL", "")
  debug_1353:
    .return (rx2436_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<name>"  :subid("397_1302110486.758") :method :outer("383_1302110486.758")
.annotate 'line', 698
    .const 'Sub' $P2448 = "399_1302110486.758" 
    capture_lex $P2448
    .local string rx2440_tgt
    .local int rx2440_pos
    .local int rx2440_off
    .local int rx2440_eos
    .local int rx2440_rep
    .local pmc rx2440_cur
    .local pmc rx2440_debug
    (rx2440_cur, rx2440_pos, rx2440_tgt, $I10) = self."!cursor_start"()
    rx2440_cur."!cursor_caparray"("assertion", "arglist", "nibbler")
    .lex unicode:"$\x{a2}", rx2440_cur
    .local pmc match
    .lex "$/", match
    length rx2440_eos, rx2440_tgt
    gt rx2440_pos, rx2440_eos, rx2440_done
    set rx2440_off, 0
    lt rx2440_pos, 2, rx2440_start
    sub rx2440_off, rx2440_pos, 1
    substr rx2440_tgt, rx2440_tgt, rx2440_off
  rx2440_start:
    eq $I10, 1, rx2440_restart
    if_null rx2440_debug, debug_1357
    rx2440_cur."!cursor_debug"("START", "assertion:sym<name>")
  debug_1357:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2444_done
    goto rxscan2444_scan
  rxscan2444_loop:
    (rx2440_pos) = rx2440_cur."from"()
    inc rx2440_pos
    rx2440_cur."!cursor_from"(rx2440_pos)
    ge rx2440_pos, rx2440_eos, rxscan2444_done
  rxscan2444_scan:
    set_addr $I10, rxscan2444_loop
    rx2440_cur."!mark_push"(0, rx2440_pos, $I10)
  rxscan2444_done:
.annotate 'line', 720
  # rx subrule "identifier" subtype=capture negate=
    rx2440_cur."!cursor_pos"(rx2440_pos)
    $P10 = rx2440_cur."identifier"()
    unless $P10, rx2440_fail
    rx2440_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx2440_pos = $P10."pos"()
.annotate 'line', 727
  # rx rxquantr2445 ** 0..1
    set_addr $I10, rxquantr2445_done
    rx2440_cur."!mark_push"(0, rx2440_pos, $I10)
  rxquantr2445_loop:
  alt2446_0:
.annotate 'line', 721
    set_addr $I10, alt2446_1
    rx2440_cur."!mark_push"(0, rx2440_pos, $I10)
.annotate 'line', 722
  # rx subrule "before" subtype=zerowidth negate=
    rx2440_cur."!cursor_pos"(rx2440_pos)
    .const 'Sub' $P2448 = "399_1302110486.758" 
    capture_lex $P2448
    $P10 = rx2440_cur."before"($P2448)
    unless $P10, rx2440_fail
    goto alt2446_end
  alt2446_1:
    set_addr $I10, alt2446_2
    rx2440_cur."!mark_push"(0, rx2440_pos, $I10)
.annotate 'line', 723
  # rx literal  "="
    add $I11, rx2440_pos, 1
    gt $I11, rx2440_eos, rx2440_fail
    sub $I11, rx2440_pos, rx2440_off
    ord $I11, rx2440_tgt, $I11
    ne $I11, 61, rx2440_fail
    add rx2440_pos, 1
  # rx subrule "assertion" subtype=capture negate=
    rx2440_cur."!cursor_pos"(rx2440_pos)
    $P10 = rx2440_cur."assertion"()
    unless $P10, rx2440_fail
    rx2440_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("assertion")
    rx2440_pos = $P10."pos"()
    goto alt2446_end
  alt2446_2:
    set_addr $I10, alt2446_3
    rx2440_cur."!mark_push"(0, rx2440_pos, $I10)
.annotate 'line', 724
  # rx literal  ":"
    add $I11, rx2440_pos, 1
    gt $I11, rx2440_eos, rx2440_fail
    sub $I11, rx2440_pos, rx2440_off
    ord $I11, rx2440_tgt, $I11
    ne $I11, 58, rx2440_fail
    add rx2440_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx2440_cur."!cursor_pos"(rx2440_pos)
    $P10 = rx2440_cur."arglist"()
    unless $P10, rx2440_fail
    rx2440_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2440_pos = $P10."pos"()
    goto alt2446_end
  alt2446_3:
    set_addr $I10, alt2446_4
    rx2440_cur."!mark_push"(0, rx2440_pos, $I10)
.annotate 'line', 725
  # rx literal  "("
    add $I11, rx2440_pos, 1
    gt $I11, rx2440_eos, rx2440_fail
    sub $I11, rx2440_pos, rx2440_off
    ord $I11, rx2440_tgt, $I11
    ne $I11, 40, rx2440_fail
    add rx2440_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx2440_cur."!cursor_pos"(rx2440_pos)
    $P10 = rx2440_cur."LANG"("MAIN", "arglist")
    unless $P10, rx2440_fail
    rx2440_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2440_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx2440_pos, 1
    gt $I11, rx2440_eos, rx2440_fail
    sub $I11, rx2440_pos, rx2440_off
    ord $I11, rx2440_tgt, $I11
    ne $I11, 41, rx2440_fail
    add rx2440_pos, 1
    goto alt2446_end
  alt2446_4:
.annotate 'line', 726
  # rx subrule "normspace" subtype=method negate=
    rx2440_cur."!cursor_pos"(rx2440_pos)
    $P10 = rx2440_cur."normspace"()
    unless $P10, rx2440_fail
    rx2440_pos = $P10."pos"()
  # rx subrule "nibbler" subtype=capture negate=
    rx2440_cur."!cursor_pos"(rx2440_pos)
    $P10 = rx2440_cur."nibbler"()
    unless $P10, rx2440_fail
    rx2440_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("nibbler")
    rx2440_pos = $P10."pos"()
  alt2446_end:
.annotate 'line', 727
    set_addr $I10, rxquantr2445_done
    (rx2440_rep) = rx2440_cur."!mark_commit"($I10)
  rxquantr2445_done:
.annotate 'line', 719
  # rx pass
    rx2440_cur."!cursor_pass"(rx2440_pos, "assertion:sym<name>")
    if_null rx2440_debug, debug_1362
    rx2440_cur."!cursor_debug"("PASS", "assertion:sym<name>", " at pos=", rx2440_pos)
  debug_1362:
    .return (rx2440_cur)
  rx2440_restart:
.annotate 'line', 698
    if_null rx2440_debug, debug_1363
    rx2440_cur."!cursor_debug"("NEXT", "assertion:sym<name>")
  debug_1363:
  rx2440_fail:
    (rx2440_rep, rx2440_pos, $I10, $P10) = rx2440_cur."!mark_fail"(0)
    lt rx2440_pos, -1, rx2440_done
    eq rx2440_pos, -1, rx2440_fail
    jump $I10
  rx2440_done:
    rx2440_cur."!cursor_fail"()
    if_null rx2440_debug, debug_1364
    rx2440_cur."!cursor_debug"("FAIL", "assertion:sym<name>")
  debug_1364:
    .return (rx2440_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<name>"  :nsentry("!PREFIX__assertion:sym<name>") :subid("398_1302110486.758") :method
.annotate 'line', 698
    $P2442 = self."!PREFIX__!subrule"("identifier", "")
    new $P2443, "ResizablePMCArray"
    push $P2443, $P2442
    .return ($P2443)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2447"  :anon :subid("399_1302110486.758") :method :outer("397_1302110486.758")
.annotate 'line', 722
    .local string rx2449_tgt
    .local int rx2449_pos
    .local int rx2449_off
    .local int rx2449_eos
    .local int rx2449_rep
    .local pmc rx2449_cur
    .local pmc rx2449_debug
    (rx2449_cur, rx2449_pos, rx2449_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2449_cur
    .local pmc match
    .lex "$/", match
    length rx2449_eos, rx2449_tgt
    gt rx2449_pos, rx2449_eos, rx2449_done
    set rx2449_off, 0
    lt rx2449_pos, 2, rx2449_start
    sub rx2449_off, rx2449_pos, 1
    substr rx2449_tgt, rx2449_tgt, rx2449_off
  rx2449_start:
    eq $I10, 1, rx2449_restart
    if_null rx2449_debug, debug_1358
    rx2449_cur."!cursor_debug"("START", "")
  debug_1358:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2450_done
    goto rxscan2450_scan
  rxscan2450_loop:
    (rx2449_pos) = rx2449_cur."from"()
    inc rx2449_pos
    rx2449_cur."!cursor_from"(rx2449_pos)
    ge rx2449_pos, rx2449_eos, rxscan2450_done
  rxscan2450_scan:
    set_addr $I10, rxscan2450_loop
    rx2449_cur."!mark_push"(0, rx2449_pos, $I10)
  rxscan2450_done:
  # rx literal  ">"
    add $I11, rx2449_pos, 1
    gt $I11, rx2449_eos, rx2449_fail
    sub $I11, rx2449_pos, rx2449_off
    ord $I11, rx2449_tgt, $I11
    ne $I11, 62, rx2449_fail
    add rx2449_pos, 1
  # rx pass
    rx2449_cur."!cursor_pass"(rx2449_pos, "")
    if_null rx2449_debug, debug_1359
    rx2449_cur."!cursor_debug"("PASS", "", " at pos=", rx2449_pos)
  debug_1359:
    .return (rx2449_cur)
  rx2449_restart:
    if_null rx2449_debug, debug_1360
    rx2449_cur."!cursor_debug"("NEXT", "")
  debug_1360:
  rx2449_fail:
    (rx2449_rep, rx2449_pos, $I10, $P10) = rx2449_cur."!mark_fail"(0)
    lt rx2449_pos, -1, rx2449_done
    eq rx2449_pos, -1, rx2449_fail
    jump $I10
  rx2449_done:
    rx2449_cur."!cursor_fail"()
    if_null rx2449_debug, debug_1361
    rx2449_cur."!cursor_debug"("FAIL", "")
  debug_1361:
    .return (rx2449_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<var>"  :subid("400_1302110486.758") :method :outer("383_1302110486.758")
.annotate 'line', 698
    .local string rx2452_tgt
    .local int rx2452_pos
    .local int rx2452_off
    .local int rx2452_eos
    .local int rx2452_rep
    .local pmc rx2452_cur
    .local pmc rx2452_debug
    (rx2452_cur, rx2452_pos, rx2452_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2452_cur
    .local pmc match
    .lex "$/", match
    length rx2452_eos, rx2452_tgt
    gt rx2452_pos, rx2452_eos, rx2452_done
    set rx2452_off, 0
    lt rx2452_pos, 2, rx2452_start
    sub rx2452_off, rx2452_pos, 1
    substr rx2452_tgt, rx2452_tgt, rx2452_off
  rx2452_start:
    eq $I10, 1, rx2452_restart
    if_null rx2452_debug, debug_1365
    rx2452_cur."!cursor_debug"("START", "assertion:sym<var>")
  debug_1365:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2455_done
    goto rxscan2455_scan
  rxscan2455_loop:
    (rx2452_pos) = rx2452_cur."from"()
    inc rx2452_pos
    rx2452_cur."!cursor_from"(rx2452_pos)
    ge rx2452_pos, rx2452_eos, rxscan2455_done
  rxscan2455_scan:
    set_addr $I10, rxscan2455_loop
    rx2452_cur."!mark_push"(0, rx2452_pos, $I10)
  rxscan2455_done:
.annotate 'line', 731
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2452_pos, rx2452_off
    substr $S10, rx2452_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx2452_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2452_cur."!cursor_pos"(rx2452_pos)
    $P10 = rx2452_cur."LANG"("MAIN", "variable")
    unless $P10, rx2452_fail
    rx2452_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx2452_pos = $P10."pos"()
.annotate 'line', 730
  # rx pass
    rx2452_cur."!cursor_pass"(rx2452_pos, "assertion:sym<var>")
    if_null rx2452_debug, debug_1366
    rx2452_cur."!cursor_debug"("PASS", "assertion:sym<var>", " at pos=", rx2452_pos)
  debug_1366:
    .return (rx2452_cur)
  rx2452_restart:
.annotate 'line', 698
    if_null rx2452_debug, debug_1367
    rx2452_cur."!cursor_debug"("NEXT", "assertion:sym<var>")
  debug_1367:
  rx2452_fail:
    (rx2452_rep, rx2452_pos, $I10, $P10) = rx2452_cur."!mark_fail"(0)
    lt rx2452_pos, -1, rx2452_done
    eq rx2452_pos, -1, rx2452_fail
    jump $I10
  rx2452_done:
    rx2452_cur."!cursor_fail"()
    if_null rx2452_debug, debug_1368
    rx2452_cur."!cursor_debug"("FAIL", "assertion:sym<var>")
  debug_1368:
    .return (rx2452_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<var>"  :nsentry("!PREFIX__assertion:sym<var>") :subid("401_1302110486.758") :method
.annotate 'line', 698
    new $P2454, "ResizablePMCArray"
    push $P2454, "$"
    push $P2454, "@"
    .return ($P2454)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "codeblock"  :subid("402_1302110486.758") :method :outer("383_1302110486.758")
.annotate 'line', 698
    .local string rx2457_tgt
    .local int rx2457_pos
    .local int rx2457_off
    .local int rx2457_eos
    .local int rx2457_rep
    .local pmc rx2457_cur
    .local pmc rx2457_debug
    (rx2457_cur, rx2457_pos, rx2457_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2457_cur
    .local pmc match
    .lex "$/", match
    length rx2457_eos, rx2457_tgt
    gt rx2457_pos, rx2457_eos, rx2457_done
    set rx2457_off, 0
    lt rx2457_pos, 2, rx2457_start
    sub rx2457_off, rx2457_pos, 1
    substr rx2457_tgt, rx2457_tgt, rx2457_off
  rx2457_start:
    eq $I10, 1, rx2457_restart
    if_null rx2457_debug, debug_1369
    rx2457_cur."!cursor_debug"("START", "codeblock")
  debug_1369:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2461_done
    goto rxscan2461_scan
  rxscan2461_loop:
    (rx2457_pos) = rx2457_cur."from"()
    inc rx2457_pos
    rx2457_cur."!cursor_from"(rx2457_pos)
    ge rx2457_pos, rx2457_eos, rxscan2461_done
  rxscan2461_scan:
    set_addr $I10, rxscan2461_loop
    rx2457_cur."!mark_push"(0, rx2457_pos, $I10)
  rxscan2461_done:
.annotate 'line', 735
  # rx subrule "LANG" subtype=capture negate=
    rx2457_cur."!cursor_pos"(rx2457_pos)
    $P10 = rx2457_cur."LANG"("MAIN", "pblock")
    unless $P10, rx2457_fail
    rx2457_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx2457_pos = $P10."pos"()
.annotate 'line', 734
  # rx pass
    rx2457_cur."!cursor_pass"(rx2457_pos, "codeblock")
    if_null rx2457_debug, debug_1370
    rx2457_cur."!cursor_debug"("PASS", "codeblock", " at pos=", rx2457_pos)
  debug_1370:
    .return (rx2457_cur)
  rx2457_restart:
.annotate 'line', 698
    if_null rx2457_debug, debug_1371
    rx2457_cur."!cursor_debug"("NEXT", "codeblock")
  debug_1371:
  rx2457_fail:
    (rx2457_rep, rx2457_pos, $I10, $P10) = rx2457_cur."!mark_fail"(0)
    lt rx2457_pos, -1, rx2457_done
    eq rx2457_pos, -1, rx2457_fail
    jump $I10
  rx2457_done:
    rx2457_cur."!cursor_fail"()
    if_null rx2457_debug, debug_1372
    rx2457_cur."!cursor_debug"("FAIL", "codeblock")
  debug_1372:
    .return (rx2457_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__codeblock"  :nsentry("!PREFIX__codeblock") :subid("403_1302110486.758") :method
.annotate 'line', 698
    $P2459 = self."!PREFIX__!subrule"("LANG", "")
    new $P2460, "ResizablePMCArray"
    push $P2460, $P2459
    .return ($P2460)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2501"  :subid("405_1302110486.758") :outer("10_1302110486.758")
.annotate 'line', 741
    .const 'Sub' $P5497 = "557_1302110486.758" 
    capture_lex $P5497
    .const 'Sub' $P5487 = "556_1302110486.758" 
    capture_lex $P5487
    .const 'Sub' $P5482 = "555_1302110486.758" 
    capture_lex $P5482
    .const 'Sub' $P5477 = "554_1302110486.758" 
    capture_lex $P5477
    .const 'Sub' $P5472 = "553_1302110486.758" 
    capture_lex $P5472
    .const 'Sub' $P5461 = "552_1302110486.758" 
    capture_lex $P5461
    .const 'Sub' $P5453 = "551_1302110486.758" 
    capture_lex $P5453
    .const 'Sub' $P5445 = "550_1302110486.758" 
    capture_lex $P5445
    .const 'Sub' $P5437 = "549_1302110486.758" 
    capture_lex $P5437
    .const 'Sub' $P5432 = "548_1302110486.758" 
    capture_lex $P5432
    .const 'Sub' $P5420 = "547_1302110486.758" 
    capture_lex $P5420
    .const 'Sub' $P5412 = "546_1302110486.758" 
    capture_lex $P5412
    .const 'Sub' $P5374 = "545_1302110486.758" 
    capture_lex $P5374
    .const 'Sub' $P5362 = "544_1302110486.758" 
    capture_lex $P5362
    .const 'Sub' $P5354 = "543_1302110486.758" 
    capture_lex $P5354
    .const 'Sub' $P5346 = "542_1302110486.758" 
    capture_lex $P5346
    .const 'Sub' $P5338 = "541_1302110486.758" 
    capture_lex $P5338
    .const 'Sub' $P5330 = "540_1302110486.758" 
    capture_lex $P5330
    .const 'Sub' $P5322 = "539_1302110486.758" 
    capture_lex $P5322
    .const 'Sub' $P5296 = "538_1302110486.758" 
    capture_lex $P5296
    .const 'Sub' $P5281 = "537_1302110486.758" 
    capture_lex $P5281
    .const 'Sub' $P5273 = "536_1302110486.758" 
    capture_lex $P5273
    .const 'Sub' $P5262 = "535_1302110486.758" 
    capture_lex $P5262
    .const 'Sub' $P5251 = "534_1302110486.758" 
    capture_lex $P5251
    .const 'Sub' $P5240 = "533_1302110486.758" 
    capture_lex $P5240
    .const 'Sub' $P5232 = "532_1302110486.758" 
    capture_lex $P5232
    .const 'Sub' $P5205 = "531_1302110486.758" 
    capture_lex $P5205
    .const 'Sub' $P5167 = "529_1302110486.758" 
    capture_lex $P5167
    .const 'Sub' $P5159 = "528_1302110486.758" 
    capture_lex $P5159
    .const 'Sub' $P5151 = "527_1302110486.758" 
    capture_lex $P5151
    .const 'Sub' $P5126 = "526_1302110486.758" 
    capture_lex $P5126
    .const 'Sub' $P5110 = "525_1302110486.758" 
    capture_lex $P5110
    .const 'Sub' $P5102 = "524_1302110486.758" 
    capture_lex $P5102
    .const 'Sub' $P5094 = "523_1302110486.758" 
    capture_lex $P5094
    .const 'Sub' $P4992 = "520_1302110486.758" 
    capture_lex $P4992
    .const 'Sub' $P4984 = "519_1302110486.758" 
    capture_lex $P4984
    .const 'Sub' $P4977 = "518_1302110486.758" 
    capture_lex $P4977
    .const 'Sub' $P4950 = "517_1302110486.758" 
    capture_lex $P4950
    .const 'Sub' $P4896 = "515_1302110486.758" 
    capture_lex $P4896
    .const 'Sub' $P4882 = "514_1302110486.758" 
    capture_lex $P4882
    .const 'Sub' $P4875 = "513_1302110486.758" 
    capture_lex $P4875
    .const 'Sub' $P4826 = "512_1302110486.758" 
    capture_lex $P4826
    .const 'Sub' $P4661 = "508_1302110486.758" 
    capture_lex $P4661
    .const 'Sub' $P4598 = "506_1302110486.758" 
    capture_lex $P4598
    .const 'Sub' $P4590 = "505_1302110486.758" 
    capture_lex $P4590
    .const 'Sub' $P4575 = "504_1302110486.758" 
    capture_lex $P4575
    .const 'Sub' $P4560 = "503_1302110486.758" 
    capture_lex $P4560
    .const 'Sub' $P4542 = "502_1302110486.758" 
    capture_lex $P4542
    .const 'Sub' $P4443 = "501_1302110486.758" 
    capture_lex $P4443
    .const 'Sub' $P4399 = "498_1302110486.758" 
    capture_lex $P4399
    .const 'Sub' $P4274 = "495_1302110486.758" 
    capture_lex $P4274
    .const 'Sub' $P4023 = "488_1302110486.758" 
    capture_lex $P4023
    .const 'Sub' $P4015 = "487_1302110486.758" 
    capture_lex $P4015
    .const 'Sub' $P4007 = "486_1302110486.758" 
    capture_lex $P4007
    .const 'Sub' $P3906 = "482_1302110486.758" 
    capture_lex $P3906
    .const 'Sub' $P3898 = "481_1302110486.758" 
    capture_lex $P3898
    .const 'Sub' $P3883 = "480_1302110486.758" 
    capture_lex $P3883
    .const 'Sub' $P3868 = "479_1302110486.758" 
    capture_lex $P3868
    .const 'Sub' $P3853 = "478_1302110486.758" 
    capture_lex $P3853
    .const 'Sub' $P3831 = "477_1302110486.758" 
    capture_lex $P3831
    .const 'Sub' $P3823 = "476_1302110486.758" 
    capture_lex $P3823
    .const 'Sub' $P3815 = "475_1302110486.758" 
    capture_lex $P3815
    .const 'Sub' $P3807 = "474_1302110486.758" 
    capture_lex $P3807
    .const 'Sub' $P3596 = "471_1302110486.758" 
    capture_lex $P3596
    .const 'Sub' $P3588 = "470_1302110486.758" 
    capture_lex $P3588
    .const 'Sub' $P3580 = "469_1302110486.758" 
    capture_lex $P3580
    .const 'Sub' $P3572 = "468_1302110486.758" 
    capture_lex $P3572
    .const 'Sub' $P3564 = "467_1302110486.758" 
    capture_lex $P3564
    .const 'Sub' $P3556 = "466_1302110486.758" 
    capture_lex $P3556
    .const 'Sub' $P3548 = "465_1302110486.758" 
    capture_lex $P3548
    .const 'Sub' $P3458 = "463_1302110486.758" 
    capture_lex $P3458
    .const 'Sub' $P3434 = "462_1302110486.758" 
    capture_lex $P3434
    .const 'Sub' $P3420 = "461_1302110486.758" 
    capture_lex $P3420
    .const 'Sub' $P3412 = "460_1302110486.758" 
    capture_lex $P3412
    .const 'Sub' $P3404 = "459_1302110486.758" 
    capture_lex $P3404
    .const 'Sub' $P3396 = "458_1302110486.758" 
    capture_lex $P3396
    .const 'Sub' $P3388 = "457_1302110486.758" 
    capture_lex $P3388
    .const 'Sub' $P3380 = "456_1302110486.758" 
    capture_lex $P3380
    .const 'Sub' $P3372 = "455_1302110486.758" 
    capture_lex $P3372
    .const 'Sub' $P3364 = "454_1302110486.758" 
    capture_lex $P3364
    .const 'Sub' $P3356 = "453_1302110486.758" 
    capture_lex $P3356
    .const 'Sub' $P3348 = "452_1302110486.758" 
    capture_lex $P3348
    .const 'Sub' $P3340 = "451_1302110486.758" 
    capture_lex $P3340
    .const 'Sub' $P3332 = "450_1302110486.758" 
    capture_lex $P3332
    .const 'Sub' $P3324 = "449_1302110486.758" 
    capture_lex $P3324
    .const 'Sub' $P3316 = "448_1302110486.758" 
    capture_lex $P3316
    .const 'Sub' $P3300 = "447_1302110486.758" 
    capture_lex $P3300
    .const 'Sub' $P3267 = "446_1302110486.758" 
    capture_lex $P3267
    .const 'Sub' $P3253 = "445_1302110486.758" 
    capture_lex $P3253
    .const 'Sub' $P3234 = "444_1302110486.758" 
    capture_lex $P3234
    .const 'Sub' $P3216 = "443_1302110486.758" 
    capture_lex $P3216
    .const 'Sub' $P3192 = "442_1302110486.758" 
    capture_lex $P3192
    .const 'Sub' $P3158 = "441_1302110486.758" 
    capture_lex $P3158
    .const 'Sub' $P3143 = "440_1302110486.758" 
    capture_lex $P3143
    .const 'Sub' $P3131 = "439_1302110486.758" 
    capture_lex $P3131
    .const 'Sub' $P3080 = "437_1302110486.758" 
    capture_lex $P3080
    .const 'Sub' $P3069 = "436_1302110486.758" 
    capture_lex $P3069
    .const 'Sub' $P3062 = "435_1302110486.758" 
    capture_lex $P3062
    .const 'Sub' $P3040 = "434_1302110486.758" 
    capture_lex $P3040
    .const 'Sub' $P3029 = "433_1302110486.758" 
    capture_lex $P3029
    .const 'Sub' $P2994 = "431_1302110486.758" 
    capture_lex $P2994
    .const 'Sub' $P2986 = "430_1302110486.758" 
    capture_lex $P2986
    .const 'Sub' $P2978 = "429_1302110486.758" 
    capture_lex $P2978
    .const 'Sub' $P2964 = "428_1302110486.758" 
    capture_lex $P2964
    .const 'Sub' $P2883 = "426_1302110486.758" 
    capture_lex $P2883
    .const 'Sub' $P2842 = "424_1302110486.758" 
    capture_lex $P2842
    .const 'Sub' $P2787 = "423_1302110486.758" 
    capture_lex $P2787
    .const 'Sub' $P2756 = "422_1302110486.758" 
    capture_lex $P2756
    .const 'Sub' $P2748 = "421_1302110486.758" 
    capture_lex $P2748
    .const 'Sub' $P2740 = "419_1302110486.758" 
    capture_lex $P2740
    .const 'Sub' $P2725 = "418_1302110486.758" 
    capture_lex $P2725
    .const 'Sub' $P2699 = "416_1302110486.758" 
    capture_lex $P2699
    .const 'Sub' $P2634 = "414_1302110486.758" 
    capture_lex $P2634
    .const 'Sub' $P2624 = "413_1302110486.758" 
    capture_lex $P2624
    .const 'Sub' $P2576 = "412_1302110486.758" 
    capture_lex $P2576
    .const 'Sub' $P2563 = "411_1302110486.758" 
    capture_lex $P2563
    .const 'Sub' $P2545 = "410_1302110486.758" 
    capture_lex $P2545
    .const 'Sub' $P2512 = "407_1302110486.758" 
    capture_lex $P2512
    .const 'Sub' $P2504 = "406_1302110486.758" 
    capture_lex $P2504
.annotate 'line', 743
    get_global $P2503, "@BLOCK"
    unless_null $P2503, vivify_1374
    $P2503 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P2503
  vivify_1374:
.annotate 'line', 749
    .const 'Sub' $P2504 = "406_1302110486.758" 
    newclosure $P2511, $P2504
    .lex "xblock_immediate", $P2511
.annotate 'line', 754
    .const 'Sub' $P2512 = "407_1302110486.758" 
    newclosure $P2544, $P2512
    .lex "block_immediate", $P2544
.annotate 'line', 764
    .const 'Sub' $P2545 = "410_1302110486.758" 
    newclosure $P2562, $P2545
    .lex "vivitype", $P2562
.annotate 'line', 783
    .const 'Sub' $P2563 = "411_1302110486.758" 
    newclosure $P2575, $P2563
    .lex "colonpair_str", $P2575
.annotate 'line', 1010
    .const 'Sub' $P2576 = "412_1302110486.758" 
    newclosure $P2623, $P2576
    .lex "push_block_handler", $P2623
.annotate 'line', 1553
    .const 'Sub' $P2624 = "413_1302110486.758" 
    newclosure $P2633, $P2624
    .lex "only_star_block", $P2633
.annotate 'line', 1562
    .const 'Sub' $P2634 = "414_1302110486.758" 
    newclosure $P2698, $P2634
    .lex "attach_multi_signature", $P2698
.annotate 'line', 1850
    .const 'Sub' $P2699 = "416_1302110486.758" 
    newclosure $P2724, $P2699
    .lex "is_lexical", $P2724
.annotate 'line', 2058
    .const 'Sub' $P2725 = "418_1302110486.758" 
    newclosure $P2736, $P2725
    .lex "control", $P2736
.annotate 'line', 743
    .lex "$?CLASS", $P2737
.annotate 'line', 741
    get_global $P2738, "@BLOCK"
    .const 'Sub' $P2740 = "419_1302110486.758" 
    capture_lex $P2740
    $P2740()
    find_lex $P2745, "xblock_immediate"
    find_lex $P2746, "block_immediate"
    find_lex $P2747, "vivitype"
.annotate 'line', 775
    find_lex $P2786, "colonpair_str"
.annotate 'line', 1003
    find_lex $P3252, "push_block_handler"
.annotate 'line', 1481
    find_lex $P4397, "only_star_block"
    find_lex $P4398, "attach_multi_signature"
.annotate 'line', 1828
    find_lex $P4949, "is_lexical"
.annotate 'line', 2049
    find_lex $P5471, "control"
.annotate 'line', 2071
    .const 'Sub' $P5487 = "556_1302110486.758" 
    newclosure $P5495, $P5487
.annotate 'line', 741
    .return ($P5495)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "" :load :init :subid("post1373") :outer("405_1302110486.758")
.annotate 'line', 741
    get_hll_global $P2502, ["NQP";"Actions"], "_block2501" 
    .local pmc block
    set block, $P2502
    .const 'Sub' $P5497 = "557_1302110486.758" 
    capture_lex $P5497
    $P5497()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5496"  :anon :subid("557_1302110486.758") :outer("405_1302110486.758")
.annotate 'line', 741
    nqp_get_sc_object $P5498, "1302110474.135", 2
    .local pmc type_obj
    set type_obj, $P5498
    get_how $P5499, type_obj
    .const 'Sub' $P5500 = "421_1302110486.758" 
    $P5499."add_method"(type_obj, "TOP", $P5500)
    get_how $P5501, type_obj
    .const 'Sub' $P5502 = "422_1302110486.758" 
    $P5501."add_method"(type_obj, "deflongname", $P5502)
    get_how $P5503, type_obj
    .const 'Sub' $P5504 = "423_1302110486.758" 
    $P5503."add_method"(type_obj, "comp_unit", $P5504)
    get_how $P5505, type_obj
    .const 'Sub' $P5506 = "424_1302110486.758" 
    $P5505."add_method"(type_obj, "statementlist", $P5506)
    get_how $P5507, type_obj
    .const 'Sub' $P5508 = "426_1302110486.758" 
    $P5507."add_method"(type_obj, "statement", $P5508)
    get_how $P5509, type_obj
    .const 'Sub' $P5510 = "428_1302110486.758" 
    $P5509."add_method"(type_obj, "xblock", $P5510)
    get_how $P5511, type_obj
    .const 'Sub' $P5512 = "429_1302110486.758" 
    $P5511."add_method"(type_obj, "pblock", $P5512)
    get_how $P5513, type_obj
    .const 'Sub' $P5514 = "430_1302110486.758" 
    $P5513."add_method"(type_obj, "block", $P5514)
    get_how $P5515, type_obj
    .const 'Sub' $P5516 = "431_1302110486.758" 
    $P5515."add_method"(type_obj, "blockoid", $P5516)
    get_how $P5517, type_obj
    .const 'Sub' $P5518 = "433_1302110486.758" 
    $P5517."add_method"(type_obj, "newpad", $P5518)
    get_how $P5519, type_obj
    .const 'Sub' $P5520 = "434_1302110486.758" 
    $P5519."add_method"(type_obj, "outerctx", $P5520)
    get_how $P5521, type_obj
    .const 'Sub' $P5522 = "435_1302110486.758" 
    $P5521."add_method"(type_obj, "you_are_here", $P5522)
    get_how $P5523, type_obj
    .const 'Sub' $P5524 = "436_1302110486.758" 
    $P5523."add_method"(type_obj, "statement_control:sym<use>", $P5524)
    get_how $P5525, type_obj
    .const 'Sub' $P5526 = "437_1302110486.758" 
    $P5525."add_method"(type_obj, "statement_control:sym<if>", $P5526)
    get_how $P5527, type_obj
    .const 'Sub' $P5528 = "439_1302110486.758" 
    $P5527."add_method"(type_obj, "statement_control:sym<unless>", $P5528)
    get_how $P5529, type_obj
    .const 'Sub' $P5530 = "440_1302110486.758" 
    $P5529."add_method"(type_obj, "statement_control:sym<while>", $P5530)
    get_how $P5531, type_obj
    .const 'Sub' $P5532 = "441_1302110486.758" 
    $P5531."add_method"(type_obj, "statement_control:sym<repeat>", $P5532)
    get_how $P5533, type_obj
    .const 'Sub' $P5534 = "442_1302110486.758" 
    $P5533."add_method"(type_obj, "statement_control:sym<for>", $P5534)
    get_how $P5535, type_obj
    .const 'Sub' $P5536 = "443_1302110486.758" 
    $P5535."add_method"(type_obj, "statement_control:sym<CATCH>", $P5536)
    get_how $P5537, type_obj
    .const 'Sub' $P5538 = "444_1302110486.758" 
    $P5537."add_method"(type_obj, "statement_control:sym<CONTROL>", $P5538)
    get_how $P5539, type_obj
    .const 'Sub' $P5540 = "445_1302110486.758" 
    $P5539."add_method"(type_obj, "statement_prefix:sym<INIT>", $P5540)
    get_how $P5541, type_obj
    .const 'Sub' $P5542 = "446_1302110486.758" 
    $P5541."add_method"(type_obj, "statement_prefix:sym<try>", $P5542)
    get_how $P5543, type_obj
    .const 'Sub' $P5544 = "447_1302110486.758" 
    $P5543."add_method"(type_obj, "blorst", $P5544)
    get_how $P5545, type_obj
    .const 'Sub' $P5546 = "448_1302110486.758" 
    $P5545."add_method"(type_obj, "statement_mod_cond:sym<if>", $P5546)
    get_how $P5547, type_obj
    .const 'Sub' $P5548 = "449_1302110486.758" 
    $P5547."add_method"(type_obj, "statement_mod_cond:sym<unless>", $P5548)
    get_how $P5549, type_obj
    .const 'Sub' $P5550 = "450_1302110486.758" 
    $P5549."add_method"(type_obj, "statement_mod_loop:sym<while>", $P5550)
    get_how $P5551, type_obj
    .const 'Sub' $P5552 = "451_1302110486.758" 
    $P5551."add_method"(type_obj, "statement_mod_loop:sym<until>", $P5552)
    get_how $P5553, type_obj
    .const 'Sub' $P5554 = "452_1302110486.758" 
    $P5553."add_method"(type_obj, "term:sym<fatarrow>", $P5554)
    get_how $P5555, type_obj
    .const 'Sub' $P5556 = "453_1302110486.758" 
    $P5555."add_method"(type_obj, "term:sym<colonpair>", $P5556)
    get_how $P5557, type_obj
    .const 'Sub' $P5558 = "454_1302110486.758" 
    $P5557."add_method"(type_obj, "term:sym<variable>", $P5558)
    get_how $P5559, type_obj
    .const 'Sub' $P5560 = "455_1302110486.758" 
    $P5559."add_method"(type_obj, "term:sym<package_declarator>", $P5560)
    get_how $P5561, type_obj
    .const 'Sub' $P5562 = "456_1302110486.758" 
    $P5561."add_method"(type_obj, "term:sym<scope_declarator>", $P5562)
    get_how $P5563, type_obj
    .const 'Sub' $P5564 = "457_1302110486.758" 
    $P5563."add_method"(type_obj, "term:sym<routine_declarator>", $P5564)
    get_how $P5565, type_obj
    .const 'Sub' $P5566 = "458_1302110486.758" 
    $P5565."add_method"(type_obj, "term:sym<regex_declarator>", $P5566)
    get_how $P5567, type_obj
    .const 'Sub' $P5568 = "459_1302110486.758" 
    $P5567."add_method"(type_obj, "term:sym<statement_prefix>", $P5568)
    get_how $P5569, type_obj
    .const 'Sub' $P5570 = "460_1302110486.758" 
    $P5569."add_method"(type_obj, "term:sym<lambda>", $P5570)
    get_how $P5571, type_obj
    .const 'Sub' $P5572 = "461_1302110486.758" 
    $P5571."add_method"(type_obj, "fatarrow", $P5572)
    get_how $P5573, type_obj
    .const 'Sub' $P5574 = "462_1302110486.758" 
    $P5573."add_method"(type_obj, "colonpair", $P5574)
    get_how $P5575, type_obj
    .const 'Sub' $P5576 = "463_1302110486.758" 
    $P5575."add_method"(type_obj, "variable", $P5576)
    get_how $P5577, type_obj
    .const 'Sub' $P5578 = "465_1302110486.758" 
    $P5577."add_method"(type_obj, "package_declarator:sym<module>", $P5578)
    get_how $P5579, type_obj
    .const 'Sub' $P5580 = "466_1302110486.758" 
    $P5579."add_method"(type_obj, "package_declarator:sym<knowhow>", $P5580)
    get_how $P5581, type_obj
    .const 'Sub' $P5582 = "467_1302110486.758" 
    $P5581."add_method"(type_obj, "package_declarator:sym<class>", $P5582)
    get_how $P5583, type_obj
    .const 'Sub' $P5584 = "468_1302110486.758" 
    $P5583."add_method"(type_obj, "package_declarator:sym<grammar>", $P5584)
    get_how $P5585, type_obj
    .const 'Sub' $P5586 = "469_1302110486.758" 
    $P5585."add_method"(type_obj, "package_declarator:sym<role>", $P5586)
    get_how $P5587, type_obj
    .const 'Sub' $P5588 = "470_1302110486.758" 
    $P5587."add_method"(type_obj, "package_declarator:sym<native>", $P5588)
    get_how $P5589, type_obj
    .const 'Sub' $P5590 = "471_1302110486.758" 
    $P5589."add_method"(type_obj, "package_def", $P5590)
    get_how $P5591, type_obj
    .const 'Sub' $P5592 = "474_1302110486.758" 
    $P5591."add_method"(type_obj, "scope_declarator:sym<my>", $P5592)
    get_how $P5593, type_obj
    .const 'Sub' $P5594 = "475_1302110486.758" 
    $P5593."add_method"(type_obj, "scope_declarator:sym<our>", $P5594)
    get_how $P5595, type_obj
    .const 'Sub' $P5596 = "476_1302110486.758" 
    $P5595."add_method"(type_obj, "scope_declarator:sym<has>", $P5596)
    get_how $P5597, type_obj
    .const 'Sub' $P5598 = "477_1302110486.758" 
    $P5597."add_method"(type_obj, "scoped", $P5598)
    get_how $P5599, type_obj
    .const 'Sub' $P5600 = "478_1302110486.758" 
    $P5599."add_method"(type_obj, "declarator", $P5600)
    get_how $P5601, type_obj
    .const 'Sub' $P5602 = "479_1302110486.758" 
    $P5601."add_method"(type_obj, "multi_declarator:sym<multi>", $P5602)
    get_how $P5603, type_obj
    .const 'Sub' $P5604 = "480_1302110486.758" 
    $P5603."add_method"(type_obj, "multi_declarator:sym<proto>", $P5604)
    get_how $P5605, type_obj
    .const 'Sub' $P5606 = "481_1302110486.758" 
    $P5605."add_method"(type_obj, "multi_declarator:sym<null>", $P5606)
    get_how $P5607, type_obj
    .const 'Sub' $P5608 = "482_1302110486.758" 
    $P5607."add_method"(type_obj, "variable_declarator", $P5608)
    get_how $P5609, type_obj
    .const 'Sub' $P5610 = "486_1302110486.758" 
    $P5609."add_method"(type_obj, "routine_declarator:sym<sub>", $P5610)
    get_how $P5611, type_obj
    .const 'Sub' $P5612 = "487_1302110486.758" 
    $P5611."add_method"(type_obj, "routine_declarator:sym<method>", $P5612)
    get_how $P5613, type_obj
    .const 'Sub' $P5614 = "488_1302110486.758" 
    $P5613."add_method"(type_obj, "routine_def", $P5614)
    get_how $P5615, type_obj
    .const 'Sub' $P5616 = "495_1302110486.758" 
    $P5615."add_method"(type_obj, "method_def", $P5616)
    get_how $P5617, type_obj
    .const 'Sub' $P5618 = "498_1302110486.758" 
    $P5617."add_method"(type_obj, "signature", $P5618)
    get_how $P5619, type_obj
    .const 'Sub' $P5620 = "501_1302110486.758" 
    $P5619."add_method"(type_obj, "parameter", $P5620)
    get_how $P5621, type_obj
    .const 'Sub' $P5622 = "502_1302110486.758" 
    $P5621."add_method"(type_obj, "param_var", $P5622)
    get_how $P5623, type_obj
    .const 'Sub' $P5624 = "503_1302110486.758" 
    $P5623."add_method"(type_obj, "named_param", $P5624)
    get_how $P5625, type_obj
    .const 'Sub' $P5626 = "504_1302110486.758" 
    $P5625."add_method"(type_obj, "typename", $P5626)
    get_how $P5627, type_obj
    .const 'Sub' $P5628 = "505_1302110486.758" 
    $P5627."add_method"(type_obj, "trait", $P5628)
    get_how $P5629, type_obj
    .const 'Sub' $P5630 = "506_1302110486.758" 
    $P5629."add_method"(type_obj, "trait_mod:sym<is>", $P5630)
    get_how $P5631, type_obj
    .const 'Sub' $P5632 = "508_1302110486.758" 
    $P5631."add_method"(type_obj, "regex_declarator", $P5632)
    get_how $P5633, type_obj
    .const 'Sub' $P5634 = "512_1302110486.758" 
    $P5633."add_method"(type_obj, "dotty", $P5634)
    get_how $P5635, type_obj
    .const 'Sub' $P5636 = "513_1302110486.758" 
    $P5635."add_method"(type_obj, "term:sym<self>", $P5636)
    get_how $P5637, type_obj
    .const 'Sub' $P5638 = "514_1302110486.758" 
    $P5637."add_method"(type_obj, "term:sym<identifier>", $P5638)
    get_how $P5639, type_obj
    .const 'Sub' $P5640 = "515_1302110486.758" 
    $P5639."add_method"(type_obj, "term:sym<name>", $P5640)
    get_how $P5641, type_obj
    .const 'Sub' $P5642 = "517_1302110486.758" 
    $P5641."add_method"(type_obj, "term:sym<pir::op>", $P5642)
    get_how $P5643, type_obj
    .const 'Sub' $P5644 = "518_1302110486.758" 
    $P5643."add_method"(type_obj, "term:sym<onlystar>", $P5644)
    get_how $P5645, type_obj
    .const 'Sub' $P5646 = "519_1302110486.758" 
    $P5645."add_method"(type_obj, "args", $P5646)
    get_how $P5647, type_obj
    .const 'Sub' $P5648 = "520_1302110486.758" 
    $P5647."add_method"(type_obj, "arglist", $P5648)
    get_how $P5649, type_obj
    .const 'Sub' $P5650 = "523_1302110486.758" 
    $P5649."add_method"(type_obj, "term:sym<multi_declarator>", $P5650)
    get_how $P5651, type_obj
    .const 'Sub' $P5652 = "524_1302110486.758" 
    $P5651."add_method"(type_obj, "term:sym<value>", $P5652)
    get_how $P5653, type_obj
    .const 'Sub' $P5654 = "525_1302110486.758" 
    $P5653."add_method"(type_obj, "circumfix:sym<( )>", $P5654)
    get_how $P5655, type_obj
    .const 'Sub' $P5656 = "526_1302110486.758" 
    $P5655."add_method"(type_obj, "circumfix:sym<[ ]>", $P5656)
    get_how $P5657, type_obj
    .const 'Sub' $P5658 = "527_1302110486.758" 
    $P5657."add_method"(type_obj, "circumfix:sym<ang>", $P5658)
    get_how $P5659, type_obj
    .const 'Sub' $P5660 = "528_1302110486.758" 
    $P5659."add_method"(type_obj, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P5660)
    get_how $P5661, type_obj
    .const 'Sub' $P5662 = "529_1302110486.758" 
    $P5661."add_method"(type_obj, "circumfix:sym<{ }>", $P5662)
    get_how $P5663, type_obj
    .const 'Sub' $P5664 = "531_1302110486.758" 
    $P5663."add_method"(type_obj, "circumfix:sym<sigil>", $P5664)
    get_how $P5665, type_obj
    .const 'Sub' $P5666 = "532_1302110486.758" 
    $P5665."add_method"(type_obj, "semilist", $P5666)
    get_how $P5667, type_obj
    .const 'Sub' $P5668 = "533_1302110486.758" 
    $P5667."add_method"(type_obj, "postcircumfix:sym<[ ]>", $P5668)
    get_how $P5669, type_obj
    .const 'Sub' $P5670 = "534_1302110486.758" 
    $P5669."add_method"(type_obj, "postcircumfix:sym<{ }>", $P5670)
    get_how $P5671, type_obj
    .const 'Sub' $P5672 = "535_1302110486.758" 
    $P5671."add_method"(type_obj, "postcircumfix:sym<ang>", $P5672)
    get_how $P5673, type_obj
    .const 'Sub' $P5674 = "536_1302110486.758" 
    $P5673."add_method"(type_obj, "postcircumfix:sym<( )>", $P5674)
    get_how $P5675, type_obj
    .const 'Sub' $P5676 = "537_1302110486.758" 
    $P5675."add_method"(type_obj, "value", $P5676)
    get_how $P5677, type_obj
    .const 'Sub' $P5678 = "538_1302110486.758" 
    $P5677."add_method"(type_obj, "number", $P5678)
    get_how $P5679, type_obj
    .const 'Sub' $P5680 = "539_1302110486.758" 
    $P5679."add_method"(type_obj, "quote:sym<apos>", $P5680)
    get_how $P5681, type_obj
    .const 'Sub' $P5682 = "540_1302110486.758" 
    $P5681."add_method"(type_obj, "quote:sym<dblq>", $P5682)
    get_how $P5683, type_obj
    .const 'Sub' $P5684 = "541_1302110486.758" 
    $P5683."add_method"(type_obj, "quote:sym<qq>", $P5684)
    get_how $P5685, type_obj
    .const 'Sub' $P5686 = "542_1302110486.758" 
    $P5685."add_method"(type_obj, "quote:sym<q>", $P5686)
    get_how $P5687, type_obj
    .const 'Sub' $P5688 = "543_1302110486.758" 
    $P5687."add_method"(type_obj, "quote:sym<Q>", $P5688)
    get_how $P5689, type_obj
    .const 'Sub' $P5690 = "544_1302110486.758" 
    $P5689."add_method"(type_obj, "quote:sym<Q:PIR>", $P5690)
    get_how $P5691, type_obj
    .const 'Sub' $P5692 = "545_1302110486.758" 
    $P5691."add_method"(type_obj, "quote:sym</ />", $P5692)
    get_how $P5693, type_obj
    .const 'Sub' $P5694 = "546_1302110486.758" 
    $P5693."add_method"(type_obj, "quote_escape:sym<$>", $P5694)
    get_how $P5695, type_obj
    .const 'Sub' $P5696 = "547_1302110486.758" 
    $P5695."add_method"(type_obj, "quote_escape:sym<{ }>", $P5696)
    get_how $P5697, type_obj
    .const 'Sub' $P5698 = "548_1302110486.758" 
    $P5697."add_method"(type_obj, "quote_escape:sym<esc>", $P5698)
    get_how $P5699, type_obj
    .const 'Sub' $P5700 = "549_1302110486.758" 
    $P5699."add_method"(type_obj, "postfix:sym<.>", $P5700)
    get_how $P5701, type_obj
    .const 'Sub' $P5702 = "550_1302110486.758" 
    $P5701."add_method"(type_obj, "postfix:sym<++>", $P5702)
    get_how $P5703, type_obj
    .const 'Sub' $P5704 = "551_1302110486.758" 
    $P5703."add_method"(type_obj, "postfix:sym<-->", $P5704)
    get_how $P5705, type_obj
    .const 'Sub' $P5706 = "552_1302110486.758" 
    $P5705."add_method"(type_obj, "prefix:sym<make>", $P5706)
    get_how $P5707, type_obj
    .const 'Sub' $P5708 = "553_1302110486.758" 
    $P5707."add_method"(type_obj, "term:sym<next>", $P5708)
    get_how $P5709, type_obj
    .const 'Sub' $P5710 = "554_1302110486.758" 
    $P5709."add_method"(type_obj, "term:sym<last>", $P5710)
    get_how $P5711, type_obj
    .const 'Sub' $P5712 = "555_1302110486.758" 
    $P5711."add_method"(type_obj, "term:sym<redo>", $P5712)
    get_how $P5713, type_obj
    .const 'Sub' $P5714 = "556_1302110486.758" 
    $P5713."add_method"(type_obj, "infix:sym<~~>", $P5714)
    get_how $P5715, type_obj
    get_hll_global $P5716, ["HLL"], "Actions"
    $P5715."add_parent"(type_obj, $P5716)
    get_how $P5717, type_obj
    $P5718 = $P5717."compose"(type_obj)
    .return ($P5718)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock_immediate"  :subid("406_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_2505
.annotate 'line', 749
    .lex "$xblock", param_2505
.annotate 'line', 750
    find_lex $P2506, "$xblock"
    unless_null $P2506, vivify_1375
    $P2506 = root_new ['parrot';'ResizablePMCArray']
  vivify_1375:
    set $P2507, $P2506[1]
    unless_null $P2507, vivify_1376
    new $P2507, "Undef"
  vivify_1376:
    $P2508 = "block_immediate"($P2507)
    find_lex $P2509, "$xblock"
    unless_null $P2509, vivify_1377
    $P2509 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$xblock", $P2509
  vivify_1377:
    set $P2509[1], $P2508
    find_lex $P2510, "$xblock"
.annotate 'line', 749
    .return ($P2510)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block_immediate"  :subid("407_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_2513
.annotate 'line', 754
    .const 'Sub' $P2523 = "408_1302110486.758" 
    capture_lex $P2523
    .lex "$block", param_2513
.annotate 'line', 755
    find_lex $P2514, "$block"
    $P2514."blocktype"("immediate")
.annotate 'line', 756
    find_lex $P2518, "$block"
    $P2519 = $P2518."symtable"()
    unless $P2519, unless_2517
    set $P2516, $P2519
    goto unless_2517_end
  unless_2517:
    find_lex $P2520, "$block"
    $P2521 = $P2520."handlers"()
    set $P2516, $P2521
  unless_2517_end:
    if $P2516, unless_2515_end
    .const 'Sub' $P2523 = "408_1302110486.758" 
    capture_lex $P2523
    $P2523()
  unless_2515_end:
    find_lex $P2543, "$block"
.annotate 'line', 754
    .return ($P2543)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2522"  :anon :subid("408_1302110486.758") :outer("407_1302110486.758")
.annotate 'line', 756
    .const 'Sub' $P2534 = "409_1302110486.758" 
    capture_lex $P2534
.annotate 'line', 757
    new $P2524, "Undef"
    .lex "$stmts", $P2524
    get_hll_global $P2525, ["PAST"], "Stmts"
    find_lex $P2526, "$block"
    $P2527 = $P2525."new"($P2526 :named("node"))
    store_lex "$stmts", $P2527
.annotate 'line', 758
    find_lex $P2529, "$block"
    $P2530 = $P2529."list"()
    defined $I2531, $P2530
    unless $I2531, for_undef_1378
    iter $P2528, $P2530
    new $P2540, 'ExceptionHandler'
    set_label $P2540, loop2539_handler
    $P2540."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2540
  loop2539_test:
    unless $P2528, loop2539_done
    shift $P2532, $P2528
  loop2539_redo:
    .const 'Sub' $P2534 = "409_1302110486.758" 
    capture_lex $P2534
    $P2534($P2532)
  loop2539_next:
    goto loop2539_test
  loop2539_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2541, exception, 'type'
    eq $P2541, .CONTROL_LOOP_NEXT, loop2539_next
    eq $P2541, .CONTROL_LOOP_REDO, loop2539_redo
  loop2539_done:
    pop_eh 
  for_undef_1378:
.annotate 'line', 759
    find_lex $P2542, "$stmts"
    store_lex "$block", $P2542
.annotate 'line', 756
    .return ($P2542)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2533"  :anon :subid("409_1302110486.758") :outer("408_1302110486.758")
    .param pmc param_2535
.annotate 'line', 758
    .lex "$_", param_2535
    find_lex $P2536, "$stmts"
    find_lex $P2537, "$_"
    $P2538 = $P2536."push"($P2537)
    .return ($P2538)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "vivitype"  :subid("410_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_2546
.annotate 'line', 764
    .lex "$sigil", param_2546
.annotate 'line', 765
    find_lex $P2549, "$sigil"
    set $S2550, $P2549
    iseq $I2551, $S2550, "%"
    if $I2551, if_2548
.annotate 'line', 767
    find_lex $P2556, "$sigil"
    set $S2557, $P2556
    iseq $I2558, $S2557, "@"
    if $I2558, if_2555
    new $P2561, "String"
    assign $P2561, "Undef"
    set $P2554, $P2561
    goto if_2555_end
  if_2555:
.annotate 'line', 768
    get_hll_global $P2559, ["PAST"], "Op"
    $P2560 = $P2559."new"("    %r = root_new ['parrot';'ResizablePMCArray']" :named("inline"))
    set $P2554, $P2560
  if_2555_end:
    set $P2547, $P2554
.annotate 'line', 765
    goto if_2548_end
  if_2548:
.annotate 'line', 766
    get_hll_global $P2552, ["PAST"], "Op"
    $P2553 = $P2552."new"("    %r = root_new ['parrot';'Hash']" :named("inline"))
    set $P2547, $P2553
  if_2548_end:
.annotate 'line', 764
    .return ($P2547)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair_str"  :subid("411_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_2564
.annotate 'line', 783
    .lex "$ast", param_2564
.annotate 'line', 784
    get_hll_global $P2567, ["PAST"], "Op"
    find_lex $P2568, "$ast"
    $P2569 = $P2567."ACCEPTS"($P2568)
    if $P2569, if_2566
.annotate 'line', 786
    find_lex $P2573, "$ast"
    $P2574 = $P2573."value"()
    set $P2565, $P2574
.annotate 'line', 784
    goto if_2566_end
  if_2566:
.annotate 'line', 785
    find_lex $P2570, "$ast"
    $P2571 = $P2570."list"()
    join $S2572, " ", $P2571
    new $P2565, 'String'
    set $P2565, $S2572
  if_2566_end:
.annotate 'line', 783
    .return ($P2565)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "push_block_handler"  :subid("412_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_2577
    .param pmc param_2578
.annotate 'line', 1010
    .lex "$/", param_2577
    .lex "$block", param_2578
.annotate 'line', 1011
    get_global $P2580, "@BLOCK"
    unless_null $P2580, vivify_1379
    $P2580 = root_new ['parrot';'ResizablePMCArray']
  vivify_1379:
    set $P2581, $P2580[0]
    unless_null $P2581, vivify_1380
    new $P2581, "Undef"
  vivify_1380:
    $P2582 = $P2581."handlers"()
    if $P2582, unless_2579_end
.annotate 'line', 1012
    get_global $P2583, "@BLOCK"
    unless_null $P2583, vivify_1381
    $P2583 = root_new ['parrot';'ResizablePMCArray']
  vivify_1381:
    set $P2584, $P2583[0]
    unless_null $P2584, vivify_1382
    new $P2584, "Undef"
  vivify_1382:
    new $P2585, "ResizablePMCArray"
    $P2584."handlers"($P2585)
  unless_2579_end:
.annotate 'line', 1014
    find_lex $P2587, "$block"
    $P2588 = $P2587."arity"()
    if $P2588, unless_2586_end
.annotate 'line', 1015
    find_lex $P2589, "$block"
.annotate 'line', 1016
    get_hll_global $P2590, ["PAST"], "Op"
.annotate 'line', 1017
    get_hll_global $P2591, ["PAST"], "Var"
    $P2592 = $P2591."new"("lexical" :named("scope"), "$!" :named("name"), 1 :named("isdecl"))
.annotate 'line', 1018
    get_hll_global $P2593, ["PAST"], "Var"
    $P2594 = $P2593."new"("lexical" :named("scope"), "$_" :named("name"))
    $P2595 = $P2590."new"($P2592, $P2594, "bind" :named("pasttype"))
.annotate 'line', 1016
    $P2589."unshift"($P2595)
.annotate 'line', 1021
    find_lex $P2596, "$block"
    get_hll_global $P2597, ["PAST"], "Var"
    $P2598 = $P2597."new"("$_" :named("name"), "parameter" :named("scope"))
    $P2596."unshift"($P2598)
.annotate 'line', 1022
    find_lex $P2599, "$block"
    $P2599."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 1023
    find_lex $P2600, "$block"
    $P2600."symbol"("$!", "lexical" :named("scope"))
.annotate 'line', 1024
    find_lex $P2601, "$block"
    $P2601."arity"(1)
  unless_2586_end:
.annotate 'line', 1026
    find_lex $P2602, "$block"
    $P2602."blocktype"("declaration")
.annotate 'line', 1027
    get_global $P2603, "@BLOCK"
    unless_null $P2603, vivify_1383
    $P2603 = root_new ['parrot';'ResizablePMCArray']
  vivify_1383:
    set $P2604, $P2603[0]
    unless_null $P2604, vivify_1384
    new $P2604, "Undef"
  vivify_1384:
    $P2605 = $P2604."handlers"()
.annotate 'line', 1028
    get_hll_global $P2606, ["PAST"], "Control"
    find_lex $P2607, "$/"
.annotate 'line', 1030
    get_hll_global $P2608, ["PAST"], "Stmts"
.annotate 'line', 1031
    get_hll_global $P2609, ["PAST"], "Op"
    find_lex $P2610, "$block"
.annotate 'line', 1033
    get_hll_global $P2611, ["PAST"], "Var"
    $P2612 = $P2611."new"("register" :named("scope"), "exception" :named("name"))
    $P2613 = $P2609."new"($P2610, $P2612, "call" :named("pasttype"))
.annotate 'line', 1035
    get_hll_global $P2614, ["PAST"], "Op"
.annotate 'line', 1036
    get_hll_global $P2615, ["PAST"], "Var"
.annotate 'line', 1037
    get_hll_global $P2616, ["PAST"], "Var"
    $P2617 = $P2616."new"("register" :named("scope"), "exception" :named("name"))
    $P2618 = $P2615."new"($P2617, "handled", "keyed" :named("scope"))
.annotate 'line', 1036
    $P2619 = $P2614."new"($P2618, 1, "bind" :named("pasttype"))
.annotate 'line', 1035
    $P2620 = $P2608."new"($P2613, $P2619)
.annotate 'line', 1030
    $P2621 = $P2606."new"($P2620, $P2607 :named("node"))
.annotate 'line', 1028
    $P2622 = $P2605."unshift"($P2621)
.annotate 'line', 1010
    .return ($P2622)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "only_star_block"  :subid("413_1302110486.758") :outer("405_1302110486.758")
.annotate 'line', 1554
    new $P2625, "Undef"
    .lex "$past", $P2625
    get_global $P2626, "@BLOCK"
    $P2627 = $P2626."shift"()
    store_lex "$past", $P2627
.annotate 'line', 1555
    find_lex $P2628, "$past"
    $P2628."closure"(1)
.annotate 'line', 1556
    find_lex $P2629, "$past"
    get_hll_global $P2630, ["PAST"], "Op"
    $P2631 = $P2630."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P2629."push"($P2631)
    find_lex $P2632, "$past"
.annotate 'line', 1553
    .return ($P2632)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "attach_multi_signature"  :subid("414_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_2635
.annotate 'line', 1562
    .const 'Sub' $P2649 = "415_1302110486.758" 
    capture_lex $P2649
    .lex "$routine", param_2635
.annotate 'line', 1566
    new $P2636, "Undef"
    .lex "$types", $P2636
.annotate 'line', 1567
    new $P2637, "Undef"
    .lex "$definednesses", $P2637
.annotate 'line', 1566
    get_hll_global $P2638, ["PAST"], "Op"
    $P2639 = $P2638."new"("list" :named("pasttype"))
    store_lex "$types", $P2639
.annotate 'line', 1567
    get_hll_global $P2640, ["PAST"], "Op"
    $P2641 = $P2640."new"("list" :named("pasttype"))
    store_lex "$definednesses", $P2641
.annotate 'line', 1568
    find_lex $P2643, "$routine"
    unless_null $P2643, vivify_1385
    $P2643 = root_new ['parrot';'ResizablePMCArray']
  vivify_1385:
    set $P2644, $P2643[0]
    unless_null $P2644, vivify_1386
    new $P2644, "Undef"
  vivify_1386:
    $P2645 = $P2644."list"()
    defined $I2646, $P2645
    unless $I2646, for_undef_1387
    iter $P2642, $P2645
    new $P2687, 'ExceptionHandler'
    set_label $P2687, loop2686_handler
    $P2687."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2687
  loop2686_test:
    unless $P2642, loop2686_done
    shift $P2647, $P2642
  loop2686_redo:
    .const 'Sub' $P2649 = "415_1302110486.758" 
    capture_lex $P2649
    $P2649($P2647)
  loop2686_next:
    goto loop2686_test
  loop2686_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2688, exception, 'type'
    eq $P2688, .CONTROL_LOOP_NEXT, loop2686_next
    eq $P2688, .CONTROL_LOOP_REDO, loop2686_redo
  loop2686_done:
    pop_eh 
  for_undef_1387:
.annotate 'line', 1575
    find_lex $P2689, "$routine"
    $P2690 = $P2689."loadinit"()
    get_hll_global $P2691, ["PAST"], "Op"
.annotate 'line', 1576
    get_hll_global $P2692, ["PAST"], "Var"
    $P2693 = $P2692."new"("block" :named("name"), "register" :named("scope"))
    find_lex $P2694, "$types"
    find_lex $P2695, "$definednesses"
    $P2696 = $P2691."new"($P2693, $P2694, $P2695, "set_sub_multisig vPPP" :named("pirop"))
.annotate 'line', 1575
    $P2697 = $P2690."push"($P2696)
.annotate 'line', 1562
    .return ($P2697)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2648"  :anon :subid("415_1302110486.758") :outer("414_1302110486.758")
    .param pmc param_2650
.annotate 'line', 1568
    .lex "$_", param_2650
.annotate 'line', 1569
    get_hll_global $P2655, ["PAST"], "Var"
    find_lex $P2656, "$_"
    $P2657 = $P2655."ACCEPTS"($P2656)
    if $P2657, if_2654
    set $P2653, $P2657
    goto if_2654_end
  if_2654:
    find_lex $P2658, "$_"
    $S2659 = $P2658."scope"()
    iseq $I2660, $S2659, "parameter"
    new $P2653, 'Integer'
    set $P2653, $I2660
  if_2654_end:
    if $P2653, if_2652
    set $P2651, $P2653
    goto if_2652_end
  if_2652:
.annotate 'line', 1570
    find_lex $P2661, "$types"
    find_lex $P2663, "$_"
    $P2664 = $P2663."multitype"()
    set $P2662, $P2664
    defined $I2666, $P2662
    if $I2666, default_2665
    get_hll_global $P2667, ["PAST"], "Op"
    $P2668 = $P2667."new"("null P" :named("pirop"))
    set $P2662, $P2668
  default_2665:
    $P2661."push"($P2662)
.annotate 'line', 1571
    find_lex $P2669, "$definednesses"
    find_lex $P2672, "$_"
    unless_null $P2672, vivify_1388
    $P2672 = root_new ['parrot';'Hash']
  vivify_1388:
    set $P2673, $P2672["definedness"]
    unless_null $P2673, vivify_1389
    new $P2673, "Undef"
  vivify_1389:
    set $S2674, $P2673
    iseq $I2675, $S2674, "D"
    if $I2675, if_2671
.annotate 'line', 1572
    find_lex $P2679, "$_"
    unless_null $P2679, vivify_1390
    $P2679 = root_new ['parrot';'Hash']
  vivify_1390:
    set $P2680, $P2679["definedness"]
    unless_null $P2680, vivify_1391
    new $P2680, "Undef"
  vivify_1391:
    set $S2681, $P2680
    iseq $I2682, $S2681, "U"
    if $I2682, if_2678
    new $P2684, "Integer"
    assign $P2684, 0
    set $P2677, $P2684
    goto if_2678_end
  if_2678:
    new $P2683, "Integer"
    assign $P2683, 2
    set $P2677, $P2683
  if_2678_end:
    set $P2670, $P2677
.annotate 'line', 1571
    goto if_2671_end
  if_2671:
    new $P2676, "Integer"
    assign $P2676, 1
    set $P2670, $P2676
  if_2671_end:
    $P2685 = $P2669."push"($P2670)
.annotate 'line', 1569
    set $P2651, $P2685
  if_2652_end:
.annotate 'line', 1568
    .return ($P2651)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "is_lexical"  :subid("416_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_2702
.annotate 'line', 1850
    .const 'Sub' $P2708 = "417_1302110486.758" 
    capture_lex $P2708
    new $P2701, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2701, control_2700
    push_eh $P2701
    .lex "$name", param_2702
.annotate 'line', 1851
    get_global $P2704, "@BLOCK"
    defined $I2705, $P2704
    unless $I2705, for_undef_1392
    iter $P2703, $P2704
    new $P2721, 'ExceptionHandler'
    set_label $P2721, loop2720_handler
    $P2721."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2721
  loop2720_test:
    unless $P2703, loop2720_done
    shift $P2706, $P2703
  loop2720_redo:
    .const 'Sub' $P2708 = "417_1302110486.758" 
    capture_lex $P2708
    $P2708($P2706)
  loop2720_next:
    goto loop2720_test
  loop2720_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2722, exception, 'type'
    eq $P2722, .CONTROL_LOOP_NEXT, loop2720_next
    eq $P2722, .CONTROL_LOOP_REDO, loop2720_redo
  loop2720_done:
    pop_eh 
  for_undef_1392:
.annotate 'line', 1850
    .return (0)
  control_2700:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2723, exception, "payload"
    .return ($P2723)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2707"  :anon :subid("417_1302110486.758") :outer("416_1302110486.758")
    .param pmc param_2710
.annotate 'line', 1852
    $P2709 = root_new ['parrot';'Hash']
    .lex "%sym", $P2709
    .lex "$_", param_2710
    find_lex $P2711, "$_"
    find_lex $P2712, "$name"
    $P2713 = $P2711."symbol"($P2712)
    store_lex "%sym", $P2713
.annotate 'line', 1853
    find_lex $P2716, "%sym"
    set $N2717, $P2716
    if $N2717, if_2715
    new $P2714, 'Float'
    set $P2714, $N2717
    goto if_2715_end
  if_2715:
.annotate 'line', 1854
    new $P2718, "Exception"
    set $P2718['type'], .CONTROL_RETURN
    new $P2719, "Integer"
    assign $P2719, 1
    setattribute $P2718, 'payload', $P2719
    throw $P2718
  if_2715_end:
.annotate 'line', 1851
    .return ($P2714)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "control"  :subid("418_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_2726
    .param pmc param_2727
.annotate 'line', 2058
    .lex "$/", param_2726
    .lex "$type", param_2727
.annotate 'line', 2059
    find_lex $P2728, "$/"
    get_hll_global $P2729, ["PAST"], "Op"
    find_lex $P2730, "$/"
.annotate 'line', 2063
    get_hll_global $P2731, ["PAST"], "Val"
    find_lex $P2732, "$type"
    $P2733 = $P2731."new"($P2732 :named("value"), "!except_types" :named("returns"))
    $P2734 = $P2729."new"(0, $P2733, $P2730 :named("node"), "die__vii" :named("pirop"))
.annotate 'line', 2059
    $P2735 = $P2728."!make"($P2734)
.annotate 'line', 2058
    .return ($P2735)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2739"  :anon :subid("419_1302110486.758") :outer("405_1302110486.758")
.annotate 'line', 741
    .const 'Sub' $P2742 = "420_1302110486.758" 
    capture_lex $P2742
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "" :load :init :subid("post1393") :outer("419_1302110486.758")
.annotate 'line', 741
    .const 'Sub' $P2740 = "419_1302110486.758" 
    .local pmc block
    set block, $P2740
.annotate 'line', 745
    .const 'Sub' $P2742 = "420_1302110486.758" 
    capture_lex $P2742
    $P2742()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2741"  :anon :subid("420_1302110486.758") :outer("419_1302110486.758")
.annotate 'line', 746
    get_global $P2743, "@BLOCK"
    unless_null $P2743, vivify_1394
    $P2743 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P2743
  vivify_1394:
 $P2744 = new ['ResizablePMCArray'] 
    set_global "@BLOCK", $P2744
.annotate 'line', 745
    .return ($P2744)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "TOP"  :subid("421_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_2749
    .param pmc param_2750
.annotate 'line', 773
    .lex "self", param_2749
    .lex "$/", param_2750
    find_lex $P2751, "$/"
    find_lex $P2752, "$/"
    unless_null $P2752, vivify_1395
    $P2752 = root_new ['parrot';'Hash']
  vivify_1395:
    set $P2753, $P2752["comp_unit"]
    unless_null $P2753, vivify_1396
    new $P2753, "Undef"
  vivify_1396:
    $P2754 = $P2753."ast"()
    $P2755 = $P2751."!make"($P2754)
    .return ($P2755)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "deflongname"  :subid("422_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_2757
    .param pmc param_2758
.annotate 'line', 775
    .lex "self", param_2757
    .lex "$/", param_2758
.annotate 'line', 776
    find_lex $P2759, "$/"
.annotate 'line', 777
    find_lex $P2762, "$/"
    unless_null $P2762, vivify_1397
    $P2762 = root_new ['parrot';'Hash']
  vivify_1397:
    set $P2763, $P2762["colonpair"]
    unless_null $P2763, vivify_1398
    new $P2763, "Undef"
  vivify_1398:
    if $P2763, if_2761
.annotate 'line', 779
    find_lex $P2783, "$/"
    set $S2784, $P2783
    new $P2760, 'String'
    set $P2760, $S2784
.annotate 'line', 777
    goto if_2761_end
  if_2761:
    find_lex $P2764, "$/"
    unless_null $P2764, vivify_1399
    $P2764 = root_new ['parrot';'Hash']
  vivify_1399:
    set $P2765, $P2764["identifier"]
    unless_null $P2765, vivify_1400
    new $P2765, "Undef"
  vivify_1400:
    set $S2766, $P2765
    new $P2767, 'String'
    set $P2767, $S2766
    concat $P2768, $P2767, ":"
    find_lex $P2769, "$/"
    unless_null $P2769, vivify_1401
    $P2769 = root_new ['parrot';'Hash']
  vivify_1401:
    set $P2770, $P2769["colonpair"]
    unless_null $P2770, vivify_1402
    $P2770 = root_new ['parrot';'ResizablePMCArray']
  vivify_1402:
    set $P2771, $P2770[0]
    unless_null $P2771, vivify_1403
    new $P2771, "Undef"
  vivify_1403:
    $P2772 = $P2771."ast"()
    $S2773 = $P2772."named"()
    concat $P2774, $P2768, $S2773
    concat $P2775, $P2774, "<"
.annotate 'line', 778
    find_lex $P2776, "$/"
    unless_null $P2776, vivify_1404
    $P2776 = root_new ['parrot';'Hash']
  vivify_1404:
    set $P2777, $P2776["colonpair"]
    unless_null $P2777, vivify_1405
    $P2777 = root_new ['parrot';'ResizablePMCArray']
  vivify_1405:
    set $P2778, $P2777[0]
    unless_null $P2778, vivify_1406
    new $P2778, "Undef"
  vivify_1406:
    $P2779 = $P2778."ast"()
    $S2780 = "colonpair_str"($P2779)
    concat $P2781, $P2775, $S2780
    concat $P2782, $P2781, ">"
    set $P2760, $P2782
  if_2761_end:
.annotate 'line', 777
    $P2785 = $P2759."!make"($P2760)
.annotate 'line', 775
    .return ($P2785)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "comp_unit"  :subid("423_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_2788
    .param pmc param_2789
.annotate 'line', 789
    .lex "self", param_2788
    .lex "$/", param_2789
.annotate 'line', 790
    new $P2790, "Undef"
    .lex "$mainline", $P2790
.annotate 'line', 791
    new $P2791, "Undef"
    .lex "$unit", $P2791
.annotate 'line', 790
    find_lex $P2792, "$/"
    unless_null $P2792, vivify_1407
    $P2792 = root_new ['parrot';'Hash']
  vivify_1407:
    set $P2793, $P2792["statementlist"]
    unless_null $P2793, vivify_1408
    new $P2793, "Undef"
  vivify_1408:
    $P2794 = $P2793."ast"()
    store_lex "$mainline", $P2794
.annotate 'line', 791
    get_global $P2795, "@BLOCK"
    $P2796 = $P2795."shift"()
    store_lex "$unit", $P2796
.annotate 'line', 795
    find_lex $P2797, "$unit"
    $P2798 = $P2797."loadinit"()
    find_dynamic_lex $P2799, "$*SC"
    unless_null $P2799, vivify_1409
    get_hll_global $P2799, "$SC"
    unless_null $P2799, vivify_1410
    die "Contextual $*SC not found"
  vivify_1410:
  vivify_1409:
    $P2800 = $P2799."to_past"()
    $P2798."push"($P2800)
.annotate 'line', 800
    find_dynamic_lex $P2802, "$*HAS_YOU_ARE_HERE"
    unless_null $P2802, vivify_1411
    get_hll_global $P2802, "$HAS_YOU_ARE_HERE"
    unless_null $P2802, vivify_1412
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_1412:
  vivify_1411:
    if $P2802, unless_2801_end
.annotate 'line', 801
    find_lex $P2803, "$unit"
    find_lex $P2804, "self"
    $P2805 = $P2804."CTXSAVE"()
    $P2803."push"($P2805)
  unless_2801_end:
.annotate 'line', 805
    find_lex $P2806, "$unit"
    $P2806."loadlibs"("nqp_group", "nqp_ops")
.annotate 'line', 809
    find_dynamic_lex $P2808, "$*MAIN_SUB"
    unless_null $P2808, vivify_1413
    get_hll_global $P2808, "$MAIN_SUB"
    unless_null $P2808, vivify_1414
    die "Contextual $*MAIN_SUB not found"
  vivify_1414:
  vivify_1413:
    unless $P2808, if_2807_end
.annotate 'line', 810
    find_lex $P2809, "$unit"
    get_hll_global $P2810, ["PAST"], "Var"
    $P2811 = $P2810."new"("parameter" :named("scope"), "@ARGS" :named("name"), 1 :named("slurpy"))
    $P2809."unshift"($P2811)
.annotate 'line', 811
    find_lex $P2812, "$mainline"
    get_hll_global $P2813, ["PAST"], "Op"
.annotate 'line', 813
    get_hll_global $P2814, ["PAST"], "Var"
    $P2815 = $P2814."new"("lexical" :named("scope"), "@ARGS" :named("name"))
.annotate 'line', 814
    get_hll_global $P2816, ["PAST"], "Op"
.annotate 'line', 815
    get_hll_global $P2817, ["PAST"], "Val"
    find_dynamic_lex $P2818, "$*MAIN_SUB"
    unless_null $P2818, vivify_1415
    get_hll_global $P2818, "$MAIN_SUB"
    unless_null $P2818, vivify_1416
    die "Contextual $*MAIN_SUB not found"
  vivify_1416:
  vivify_1415:
    $P2819 = $P2817."new"($P2818 :named("value"))
.annotate 'line', 816
    get_hll_global $P2820, ["PAST"], "Var"
    $P2821 = $P2820."new"("lexical" :named("scope"), "@ARGS" :named("name"), 1 :named("flat"))
    $P2822 = $P2816."new"($P2819, $P2821, "call" :named("pasttype"))
.annotate 'line', 814
    $P2823 = $P2813."new"($P2815, $P2822, "if" :named("pasttype"))
.annotate 'line', 811
    $P2812."push"($P2823)
  if_2807_end:
.annotate 'line', 824
    find_lex $P2824, "$unit"
.annotate 'line', 825
    get_hll_global $P2825, ["PAST"], "Op"
    find_lex $P2826, "$mainline"
    $P2827 = $P2825."new"($P2826, "return" :named("pirop"))
    $P2824."push"($P2827)
.annotate 'line', 830
    find_lex $P2828, "$unit"
.annotate 'line', 831
    get_hll_global $P2829, ["PAST"], "Block"
.annotate 'line', 833
    get_hll_global $P2830, ["PAST"], "Op"
    get_hll_global $P2831, ["PAST"], "Val"
    find_lex $P2832, "$unit"
    $P2833 = $P2831."new"($P2832 :named("value"))
    $P2834 = $P2830."new"($P2833, "call" :named("pasttype"))
    $P2835 = $P2829."new"($P2834, ":load" :named("pirflags"), 0 :named("lexical"), "" :named("namespace"))
.annotate 'line', 831
    $P2828."push"($P2835)
.annotate 'line', 836
    find_lex $P2836, "$unit"
    find_lex $P2837, "$/"
    $P2836."node"($P2837)
.annotate 'line', 839
    find_lex $P2838, "$unit"
    $P2838."hll"("nqp")
.annotate 'line', 841
    find_lex $P2839, "$/"
    find_lex $P2840, "$unit"
    $P2841 = $P2839."!make"($P2840)
.annotate 'line', 789
    .return ($P2841)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statementlist"  :subid("424_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_2843
    .param pmc param_2844
.annotate 'line', 844
    .const 'Sub' $P2858 = "425_1302110486.758" 
    capture_lex $P2858
    .lex "self", param_2843
    .lex "$/", param_2844
.annotate 'line', 845
    new $P2845, "Undef"
    .lex "$past", $P2845
    get_hll_global $P2846, ["PAST"], "Stmts"
    find_lex $P2847, "$/"
    $P2848 = $P2846."new"($P2847 :named("node"))
    store_lex "$past", $P2848
.annotate 'line', 846
    find_lex $P2850, "$/"
    unless_null $P2850, vivify_1417
    $P2850 = root_new ['parrot';'Hash']
  vivify_1417:
    set $P2851, $P2850["statement"]
    unless_null $P2851, vivify_1418
    new $P2851, "Undef"
  vivify_1418:
    unless $P2851, if_2849_end
.annotate 'line', 847
    find_lex $P2853, "$/"
    unless_null $P2853, vivify_1419
    $P2853 = root_new ['parrot';'Hash']
  vivify_1419:
    set $P2854, $P2853["statement"]
    unless_null $P2854, vivify_1420
    new $P2854, "Undef"
  vivify_1420:
    defined $I2855, $P2854
    unless $I2855, for_undef_1421
    iter $P2852, $P2854
    new $P2878, 'ExceptionHandler'
    set_label $P2878, loop2877_handler
    $P2878."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2878
  loop2877_test:
    unless $P2852, loop2877_done
    shift $P2856, $P2852
  loop2877_redo:
    .const 'Sub' $P2858 = "425_1302110486.758" 
    capture_lex $P2858
    $P2858($P2856)
  loop2877_next:
    goto loop2877_test
  loop2877_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2879, exception, 'type'
    eq $P2879, .CONTROL_LOOP_NEXT, loop2877_next
    eq $P2879, .CONTROL_LOOP_REDO, loop2877_redo
  loop2877_done:
    pop_eh 
  for_undef_1421:
  if_2849_end:
.annotate 'line', 854
    find_lex $P2880, "$/"
    find_lex $P2881, "$past"
    $P2882 = $P2880."!make"($P2881)
.annotate 'line', 844
    .return ($P2882)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2857"  :anon :subid("425_1302110486.758") :outer("424_1302110486.758")
    .param pmc param_2860
.annotate 'line', 848
    new $P2859, "Undef"
    .lex "$ast", $P2859
    .lex "$_", param_2860
    find_lex $P2861, "$_"
    $P2862 = $P2861."ast"()
    store_lex "$ast", $P2862
.annotate 'line', 849
    find_lex $P2864, "$ast"
    unless_null $P2864, vivify_1422
    $P2864 = root_new ['parrot';'Hash']
  vivify_1422:
    set $P2865, $P2864["sink"]
    unless_null $P2865, vivify_1423
    new $P2865, "Undef"
  vivify_1423:
    defined $I2866, $P2865
    unless $I2866, if_2863_end
    find_lex $P2867, "$ast"
    unless_null $P2867, vivify_1424
    $P2867 = root_new ['parrot';'Hash']
  vivify_1424:
    set $P2868, $P2867["sink"]
    unless_null $P2868, vivify_1425
    new $P2868, "Undef"
  vivify_1425:
    store_lex "$ast", $P2868
  if_2863_end:
.annotate 'line', 850
    find_lex $P2870, "$ast"
    unless_null $P2870, vivify_1426
    $P2870 = root_new ['parrot';'Hash']
  vivify_1426:
    set $P2871, $P2870["bareblock"]
    unless_null $P2871, vivify_1427
    new $P2871, "Undef"
  vivify_1427:
    unless $P2871, if_2869_end
    find_lex $P2872, "$ast"
    $P2873 = "block_immediate"($P2872)
    store_lex "$ast", $P2873
  if_2869_end:
.annotate 'line', 851
    find_lex $P2874, "$past"
    find_lex $P2875, "$ast"
    $P2876 = $P2874."push"($P2875)
.annotate 'line', 847
    .return ($P2876)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement"  :subid("426_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_2884
    .param pmc param_2885
    .param pmc param_2886 :optional
    .param int has_param_2886 :opt_flag
.annotate 'line', 857
    .const 'Sub' $P2894 = "427_1302110486.758" 
    capture_lex $P2894
    .lex "self", param_2884
    .lex "$/", param_2885
    if has_param_2886, optparam_1428
    new $P2887, "Undef"
    set param_2886, $P2887
  optparam_1428:
    .lex "$key", param_2886
.annotate 'line', 858
    new $P2888, "Undef"
    .lex "$past", $P2888
.annotate 'line', 857
    find_lex $P2889, "$past"
.annotate 'line', 859
    find_lex $P2891, "$/"
    unless_null $P2891, vivify_1429
    $P2891 = root_new ['parrot';'Hash']
  vivify_1429:
    set $P2892, $P2891["EXPR"]
    unless_null $P2892, vivify_1430
    new $P2892, "Undef"
  vivify_1430:
    if $P2892, if_2890
.annotate 'line', 880
    find_lex $P2955, "$/"
    unless_null $P2955, vivify_1431
    $P2955 = root_new ['parrot';'Hash']
  vivify_1431:
    set $P2956, $P2955["statement_control"]
    unless_null $P2956, vivify_1432
    new $P2956, "Undef"
  vivify_1432:
    if $P2956, if_2954
.annotate 'line', 881
    new $P2960, "Integer"
    assign $P2960, 0
    store_lex "$past", $P2960
    goto if_2954_end
  if_2954:
.annotate 'line', 880
    find_lex $P2957, "$/"
    unless_null $P2957, vivify_1433
    $P2957 = root_new ['parrot';'Hash']
  vivify_1433:
    set $P2958, $P2957["statement_control"]
    unless_null $P2958, vivify_1434
    new $P2958, "Undef"
  vivify_1434:
    $P2959 = $P2958."ast"()
    store_lex "$past", $P2959
  if_2954_end:
    goto if_2890_end
  if_2890:
.annotate 'line', 859
    .const 'Sub' $P2894 = "427_1302110486.758" 
    capture_lex $P2894
    $P2894()
  if_2890_end:
.annotate 'line', 882
    find_lex $P2961, "$/"
    find_lex $P2962, "$past"
    $P2963 = $P2961."!make"($P2962)
.annotate 'line', 857
    .return ($P2963)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2893"  :anon :subid("427_1302110486.758") :outer("426_1302110486.758")
.annotate 'line', 860
    new $P2895, "Undef"
    .lex "$mc", $P2895
.annotate 'line', 861
    new $P2896, "Undef"
    .lex "$ml", $P2896
.annotate 'line', 860
    find_lex $P2897, "$/"
    unless_null $P2897, vivify_1435
    $P2897 = root_new ['parrot';'Hash']
  vivify_1435:
    set $P2898, $P2897["statement_mod_cond"]
    unless_null $P2898, vivify_1436
    $P2898 = root_new ['parrot';'ResizablePMCArray']
  vivify_1436:
    set $P2899, $P2898[0]
    unless_null $P2899, vivify_1437
    new $P2899, "Undef"
  vivify_1437:
    store_lex "$mc", $P2899
.annotate 'line', 861
    find_lex $P2900, "$/"
    unless_null $P2900, vivify_1438
    $P2900 = root_new ['parrot';'Hash']
  vivify_1438:
    set $P2901, $P2900["statement_mod_loop"]
    unless_null $P2901, vivify_1439
    $P2901 = root_new ['parrot';'ResizablePMCArray']
  vivify_1439:
    set $P2902, $P2901[0]
    unless_null $P2902, vivify_1440
    new $P2902, "Undef"
  vivify_1440:
    store_lex "$ml", $P2902
.annotate 'line', 862
    find_lex $P2903, "$/"
    unless_null $P2903, vivify_1441
    $P2903 = root_new ['parrot';'Hash']
  vivify_1441:
    set $P2904, $P2903["EXPR"]
    unless_null $P2904, vivify_1442
    new $P2904, "Undef"
  vivify_1442:
    $P2905 = $P2904."ast"()
    store_lex "$past", $P2905
.annotate 'line', 863
    find_lex $P2907, "$mc"
    unless $P2907, if_2906_end
.annotate 'line', 864
    get_hll_global $P2908, ["PAST"], "Op"
    find_lex $P2909, "$mc"
    unless_null $P2909, vivify_1443
    $P2909 = root_new ['parrot';'Hash']
  vivify_1443:
    set $P2910, $P2909["cond"]
    unless_null $P2910, vivify_1444
    new $P2910, "Undef"
  vivify_1444:
    $P2911 = $P2910."ast"()
    find_lex $P2912, "$past"
    find_lex $P2913, "$mc"
    unless_null $P2913, vivify_1445
    $P2913 = root_new ['parrot';'Hash']
  vivify_1445:
    set $P2914, $P2913["sym"]
    unless_null $P2914, vivify_1446
    new $P2914, "Undef"
  vivify_1446:
    set $S2915, $P2914
    find_lex $P2916, "$/"
    $P2917 = $P2908."new"($P2911, $P2912, $S2915 :named("pasttype"), $P2916 :named("node"))
    store_lex "$past", $P2917
  if_2906_end:
.annotate 'line', 866
    find_lex $P2920, "$ml"
    if $P2920, if_2919
    set $P2918, $P2920
    goto if_2919_end
  if_2919:
.annotate 'line', 867
    find_lex $P2923, "$ml"
    unless_null $P2923, vivify_1447
    $P2923 = root_new ['parrot';'Hash']
  vivify_1447:
    set $P2924, $P2923["sym"]
    unless_null $P2924, vivify_1448
    new $P2924, "Undef"
  vivify_1448:
    set $S2925, $P2924
    iseq $I2926, $S2925, "for"
    if $I2926, if_2922
.annotate 'line', 876
    get_hll_global $P2944, ["PAST"], "Op"
    find_lex $P2945, "$ml"
    unless_null $P2945, vivify_1449
    $P2945 = root_new ['parrot';'Hash']
  vivify_1449:
    set $P2946, $P2945["cond"]
    unless_null $P2946, vivify_1450
    new $P2946, "Undef"
  vivify_1450:
    $P2947 = $P2946."ast"()
    find_lex $P2948, "$past"
    find_lex $P2949, "$ml"
    unless_null $P2949, vivify_1451
    $P2949 = root_new ['parrot';'Hash']
  vivify_1451:
    set $P2950, $P2949["sym"]
    unless_null $P2950, vivify_1452
    new $P2950, "Undef"
  vivify_1452:
    set $S2951, $P2950
    find_lex $P2952, "$/"
    $P2953 = $P2944."new"($P2947, $P2948, $S2951 :named("pasttype"), $P2952 :named("node"))
    store_lex "$past", $P2953
.annotate 'line', 875
    set $P2921, $P2953
.annotate 'line', 867
    goto if_2922_end
  if_2922:
.annotate 'line', 868
    get_hll_global $P2927, ["PAST"], "Block"
.annotate 'line', 869
    get_hll_global $P2928, ["PAST"], "Var"
    $P2929 = $P2928."new"("$_" :named("name"), "parameter" :named("scope"), 1 :named("isdecl"))
    find_lex $P2930, "$past"
    $P2931 = $P2927."new"($P2929, $P2930, "immediate" :named("blocktype"))
.annotate 'line', 868
    store_lex "$past", $P2931
.annotate 'line', 871
    find_lex $P2932, "$past"
    $P2932."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 872
    find_lex $P2933, "$past"
    $P2933."arity"(1)
.annotate 'line', 873
    get_hll_global $P2934, ["PAST"], "Op"
    find_lex $P2935, "$ml"
    unless_null $P2935, vivify_1453
    $P2935 = root_new ['parrot';'Hash']
  vivify_1453:
    set $P2936, $P2935["cond"]
    unless_null $P2936, vivify_1454
    new $P2936, "Undef"
  vivify_1454:
    $P2937 = $P2936."ast"()
    find_lex $P2938, "$past"
    find_lex $P2939, "$ml"
    unless_null $P2939, vivify_1455
    $P2939 = root_new ['parrot';'Hash']
  vivify_1455:
    set $P2940, $P2939["sym"]
    unless_null $P2940, vivify_1456
    new $P2940, "Undef"
  vivify_1456:
    set $S2941, $P2940
    find_lex $P2942, "$/"
    $P2943 = $P2934."new"($P2937, $P2938, $S2941 :named("pasttype"), $P2942 :named("node"))
    store_lex "$past", $P2943
.annotate 'line', 867
    set $P2921, $P2943
  if_2922_end:
.annotate 'line', 866
    set $P2918, $P2921
  if_2919_end:
.annotate 'line', 859
    .return ($P2918)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock"  :subid("428_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_2965
    .param pmc param_2966
.annotate 'line', 885
    .lex "self", param_2965
    .lex "$/", param_2966
.annotate 'line', 886
    find_lex $P2967, "$/"
    get_hll_global $P2968, ["PAST"], "Op"
    find_lex $P2969, "$/"
    unless_null $P2969, vivify_1457
    $P2969 = root_new ['parrot';'Hash']
  vivify_1457:
    set $P2970, $P2969["EXPR"]
    unless_null $P2970, vivify_1458
    new $P2970, "Undef"
  vivify_1458:
    $P2971 = $P2970."ast"()
    find_lex $P2972, "$/"
    unless_null $P2972, vivify_1459
    $P2972 = root_new ['parrot';'Hash']
  vivify_1459:
    set $P2973, $P2972["pblock"]
    unless_null $P2973, vivify_1460
    new $P2973, "Undef"
  vivify_1460:
    $P2974 = $P2973."ast"()
    find_lex $P2975, "$/"
    $P2976 = $P2968."new"($P2971, $P2974, "if" :named("pasttype"), $P2975 :named("node"))
    $P2977 = $P2967."!make"($P2976)
.annotate 'line', 885
    .return ($P2977)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "pblock"  :subid("429_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_2979
    .param pmc param_2980
.annotate 'line', 889
    .lex "self", param_2979
    .lex "$/", param_2980
.annotate 'line', 890
    find_lex $P2981, "$/"
    find_lex $P2982, "$/"
    unless_null $P2982, vivify_1461
    $P2982 = root_new ['parrot';'Hash']
  vivify_1461:
    set $P2983, $P2982["blockoid"]
    unless_null $P2983, vivify_1462
    new $P2983, "Undef"
  vivify_1462:
    $P2984 = $P2983."ast"()
    $P2985 = $P2981."!make"($P2984)
.annotate 'line', 889
    .return ($P2985)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block"  :subid("430_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_2987
    .param pmc param_2988
.annotate 'line', 893
    .lex "self", param_2987
    .lex "$/", param_2988
.annotate 'line', 894
    find_lex $P2989, "$/"
    find_lex $P2990, "$/"
    unless_null $P2990, vivify_1463
    $P2990 = root_new ['parrot';'Hash']
  vivify_1463:
    set $P2991, $P2990["blockoid"]
    unless_null $P2991, vivify_1464
    new $P2991, "Undef"
  vivify_1464:
    $P2992 = $P2991."ast"()
    $P2993 = $P2989."!make"($P2992)
.annotate 'line', 893
    .return ($P2993)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blockoid"  :subid("431_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_2995
    .param pmc param_2996
.annotate 'line', 897
    .const 'Sub' $P3005 = "432_1302110486.758" 
    capture_lex $P3005
    .lex "self", param_2995
    .lex "$/", param_2996
.annotate 'line', 898
    new $P2997, "Undef"
    .lex "$BLOCK", $P2997
    get_global $P2998, "@BLOCK"
    $P2999 = $P2998."shift"()
    store_lex "$BLOCK", $P2999
.annotate 'line', 899
    find_lex $P3002, "$/"
    unless_null $P3002, vivify_1465
    $P3002 = root_new ['parrot';'Hash']
  vivify_1465:
    set $P3003, $P3002["statementlist"]
    unless_null $P3003, vivify_1466
    new $P3003, "Undef"
  vivify_1466:
    if $P3003, if_3001
.annotate 'line', 907
    find_dynamic_lex $P3020, "$*HAS_YOU_ARE_HERE"
    unless_null $P3020, vivify_1467
    get_hll_global $P3020, "$HAS_YOU_ARE_HERE"
    unless_null $P3020, vivify_1468
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_1468:
  vivify_1467:
    unless $P3020, if_3019_end
.annotate 'line', 908
    find_lex $P3021, "$/"
    $P3022 = $P3021."CURSOR"()
    $P3022."panic"("{YOU_ARE_HERE} may only appear once in a setting")
  if_3019_end:
.annotate 'line', 910
    new $P3023, "Integer"
    assign $P3023, 1
    store_dynamic_lex "$*HAS_YOU_ARE_HERE", $P3023
.annotate 'line', 911
    find_lex $P3024, "$/"
    find_lex $P3025, "$/"
    unless_null $P3025, vivify_1469
    $P3025 = root_new ['parrot';'Hash']
  vivify_1469:
    set $P3026, $P3025["you_are_here"]
    unless_null $P3026, vivify_1470
    new $P3026, "Undef"
  vivify_1470:
    $P3027 = $P3026."ast"()
    $P3028 = $P3024."!make"($P3027)
.annotate 'line', 906
    set $P3000, $P3028
.annotate 'line', 899
    goto if_3001_end
  if_3001:
    .const 'Sub' $P3005 = "432_1302110486.758" 
    capture_lex $P3005
    $P3018 = $P3005()
    set $P3000, $P3018
  if_3001_end:
.annotate 'line', 897
    .return ($P3000)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3004"  :anon :subid("432_1302110486.758") :outer("431_1302110486.758")
.annotate 'line', 900
    new $P3006, "Undef"
    .lex "$past", $P3006
    find_lex $P3007, "$/"
    unless_null $P3007, vivify_1471
    $P3007 = root_new ['parrot';'Hash']
  vivify_1471:
    set $P3008, $P3007["statementlist"]
    unless_null $P3008, vivify_1472
    new $P3008, "Undef"
  vivify_1472:
    $P3009 = $P3008."ast"()
    store_lex "$past", $P3009
.annotate 'line', 901
    find_lex $P3010, "$BLOCK"
    find_lex $P3011, "$past"
    $P3010."push"($P3011)
.annotate 'line', 902
    find_lex $P3012, "$BLOCK"
    find_lex $P3013, "$/"
    $P3012."node"($P3013)
.annotate 'line', 903
    find_lex $P3014, "$BLOCK"
    $P3014."closure"(1)
.annotate 'line', 904
    find_dynamic_lex $P3015, "$/"
    find_lex $P3016, "$BLOCK"
    $P3017 = $P3015."!make"($P3016)
.annotate 'line', 899
    .return ($P3017)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "newpad"  :subid("433_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_3030
    .param pmc param_3031
.annotate 'line', 915
    .lex "self", param_3030
    .lex "$/", param_3031
.annotate 'line', 916
    get_global $P3032, "@BLOCK"
    unless_null $P3032, vivify_1473
    $P3032 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P3032
  vivify_1473:
.annotate 'line', 915
    get_global $P3033, "@BLOCK"
.annotate 'line', 917
    get_global $P3034, "@BLOCK"
    get_hll_global $P3035, ["PAST"], "Block"
    get_hll_global $P3036, ["PAST"], "Stmts"
    $P3037 = $P3036."new"()
    $P3038 = $P3035."new"($P3037)
    $P3039 = $P3034."unshift"($P3038)
.annotate 'line', 915
    .return ($P3039)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "outerctx"  :subid("434_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_3041
    .param pmc param_3042
.annotate 'line', 920
    .lex "self", param_3041
    .lex "$/", param_3042
.annotate 'line', 921
    get_global $P3043, "@BLOCK"
    unless_null $P3043, vivify_1474
    $P3043 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P3043
  vivify_1474:
.annotate 'line', 920
    get_global $P3044, "@BLOCK"
.annotate 'line', 922
    find_dynamic_lex $P3046, "%*COMPILING"
    unless_null $P3046, vivify_1475
    get_hll_global $P3046, "%COMPILING"
    unless_null $P3046, vivify_1476
    die "Contextual %*COMPILING not found"
  vivify_1476:
  vivify_1475:
    set $P3047, $P3046["%?OPTIONS"]
    unless_null $P3047, vivify_1477
    $P3047 = root_new ['parrot';'Hash']
  vivify_1477:
    set $P3048, $P3047["outer_ctx"]
    unless_null $P3048, vivify_1478
    new $P3048, "Undef"
  vivify_1478:
    defined $I3049, $P3048
    if $I3049, unless_3045_end
.annotate 'line', 925
    find_dynamic_lex $P3050, "$*SC"
    unless_null $P3050, vivify_1479
    get_hll_global $P3050, "$SC"
    unless_null $P3050, vivify_1480
    die "Contextual $*SC not found"
  vivify_1480:
  vivify_1479:
    find_dynamic_lex $P3052, "%*COMPILING"
    unless_null $P3052, vivify_1481
    get_hll_global $P3052, "%COMPILING"
    unless_null $P3052, vivify_1482
    die "Contextual %*COMPILING not found"
  vivify_1482:
  vivify_1481:
    set $P3053, $P3052["%?OPTIONS"]
    unless_null $P3053, vivify_1483
    $P3053 = root_new ['parrot';'Hash']
  vivify_1483:
    set $P3054, $P3053["setting"]
    unless_null $P3054, vivify_1484
    new $P3054, "Undef"
  vivify_1484:
    set $P3051, $P3054
    defined $I3056, $P3051
    if $I3056, default_3055
    new $P3057, "String"
    assign $P3057, "NQPCORE"
    set $P3051, $P3057
  default_3055:
    $P3050."load_setting"($P3051)
  unless_3045_end:
.annotate 'line', 927
    find_lex $P3058, "self"
    get_global $P3059, "@BLOCK"
    unless_null $P3059, vivify_1485
    $P3059 = root_new ['parrot';'ResizablePMCArray']
  vivify_1485:
    set $P3060, $P3059[0]
    unless_null $P3060, vivify_1486
    new $P3060, "Undef"
  vivify_1486:
    $P3061 = $P3058."SET_BLOCK_OUTER_CTX"($P3060)
.annotate 'line', 920
    .return ($P3061)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "you_are_here"  :subid("435_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_3063
    .param pmc param_3064
.annotate 'line', 930
    .lex "self", param_3063
    .lex "$/", param_3064
.annotate 'line', 931
    find_lex $P3065, "$/"
    find_lex $P3066, "self"
    $P3067 = $P3066."CTXSAVE"()
    $P3068 = $P3065."!make"($P3067)
.annotate 'line', 930
    .return ($P3068)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<use>"  :subid("436_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_3070
    .param pmc param_3071
.annotate 'line', 936
    .lex "self", param_3070
    .lex "$/", param_3071
.annotate 'line', 937
    find_dynamic_lex $P3072, "$*SC"
    unless_null $P3072, vivify_1487
    get_hll_global $P3072, "$SC"
    unless_null $P3072, vivify_1488
    die "Contextual $*SC not found"
  vivify_1488:
  vivify_1487:
    find_lex $P3073, "$/"
    unless_null $P3073, vivify_1489
    $P3073 = root_new ['parrot';'Hash']
  vivify_1489:
    set $P3074, $P3073["name"]
    unless_null $P3074, vivify_1490
    new $P3074, "Undef"
  vivify_1490:
    set $S3075, $P3074
    $P3072."load_module"($S3075)
.annotate 'line', 938
    find_lex $P3076, "$/"
    get_hll_global $P3077, ["PAST"], "Stmts"
    $P3078 = $P3077."new"()
    $P3079 = $P3076."!make"($P3078)
.annotate 'line', 936
    .return ($P3079)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statement_control:sym<if>"  :subid("437_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_3081
    .param pmc param_3082
.annotate 'line', 941
    .const 'Sub' $P3110 = "438_1302110486.758" 
    capture_lex $P3110
    .lex "self", param_3081
    .lex "$/", param_3082
.annotate 'line', 942
    new $P3083, "Undef"
    .lex "$count", $P3083
.annotate 'line', 943
    new $P3084, "Undef"
    .lex "$past", $P3084
.annotate 'line', 942
    find_lex $P3085, "$/"
    unless_null $P3085, vivify_1491
    $P3085 = root_new ['parrot';'Hash']
  vivify_1491:
    set $P3086, $P3085["xblock"]
    unless_null $P3086, vivify_1492
    new $P3086, "Undef"
  vivify_1492:
    set $N3087, $P3086
    new $P3088, 'Float'
    set $P3088, $N3087
    sub $P3089, $P3088, 1
    store_lex "$count", $P3089
.annotate 'line', 943
    find_lex $P3090, "$count"
    set $I3091, $P3090
    find_lex $P3092, "$/"
    unless_null $P3092, vivify_1493
    $P3092 = root_new ['parrot';'Hash']
  vivify_1493:
    set $P3093, $P3092["xblock"]
    unless_null $P3093, vivify_1494
    $P3093 = root_new ['parrot';'ResizablePMCArray']
  vivify_1494:
    set $P3094, $P3093[$I3091]
    unless_null $P3094, vivify_1495
    new $P3094, "Undef"
  vivify_1495:
    $P3095 = $P3094."ast"()
    $P3096 = "xblock_immediate"($P3095)
    store_lex "$past", $P3096
.annotate 'line', 944
    find_lex $P3098, "$/"
    unless_null $P3098, vivify_1496
    $P3098 = root_new ['parrot';'Hash']
  vivify_1496:
    set $P3099, $P3098["else"]
    unless_null $P3099, vivify_1497
    new $P3099, "Undef"
  vivify_1497:
    unless $P3099, if_3097_end
.annotate 'line', 945
    find_lex $P3100, "$past"
    find_lex $P3101, "$/"
    unless_null $P3101, vivify_1498
    $P3101 = root_new ['parrot';'Hash']
  vivify_1498:
    set $P3102, $P3101["else"]
    unless_null $P3102, vivify_1499
    $P3102 = root_new ['parrot';'ResizablePMCArray']
  vivify_1499:
    set $P3103, $P3102[0]
    unless_null $P3103, vivify_1500
    new $P3103, "Undef"
  vivify_1500:
    $P3104 = $P3103."ast"()
    $P3105 = "block_immediate"($P3104)
    $P3100."push"($P3105)
  if_3097_end:
.annotate 'line', 948
    new $P3126, 'ExceptionHandler'
    set_label $P3126, loop3125_handler
    $P3126."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3126
  loop3125_test:
    find_lex $P3106, "$count"
    set $N3107, $P3106
    isgt $I3108, $N3107, 0.0
    unless $I3108, loop3125_done
  loop3125_redo:
    .const 'Sub' $P3110 = "438_1302110486.758" 
    capture_lex $P3110
    $P3110()
  loop3125_next:
    goto loop3125_test
  loop3125_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3127, exception, 'type'
    eq $P3127, .CONTROL_LOOP_NEXT, loop3125_next
    eq $P3127, .CONTROL_LOOP_REDO, loop3125_redo
  loop3125_done:
    pop_eh 
.annotate 'line', 954
    find_lex $P3128, "$/"
    find_lex $P3129, "$past"
    $P3130 = $P3128."!make"($P3129)
.annotate 'line', 941
    .return ($P3130)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3109"  :anon :subid("438_1302110486.758") :outer("437_1302110486.758")
.annotate 'line', 950
    new $P3111, "Undef"
    .lex "$else", $P3111
.annotate 'line', 948
    find_lex $P3112, "$count"
    clone $P3113, $P3112
    dec $P3112
.annotate 'line', 950
    find_lex $P3114, "$past"
    store_lex "$else", $P3114
.annotate 'line', 951
    find_lex $P3115, "$count"
    set $I3116, $P3115
    find_lex $P3117, "$/"
    unless_null $P3117, vivify_1501
    $P3117 = root_new ['parrot';'Hash']
  vivify_1501:
    set $P3118, $P3117["xblock"]
    unless_null $P3118, vivify_1502
    $P3118 = root_new ['parrot';'ResizablePMCArray']
  vivify_1502:
    set $P3119, $P3118[$I3116]
    unless_null $P3119, vivify_1503
    new $P3119, "Undef"
  vivify_1503:
    $P3120 = $P3119."ast"()
    $P3121 = "xblock_immediate"($P3120)
    store_lex "$past", $P3121
.annotate 'line', 952
    find_lex $P3122, "$past"
    find_lex $P3123, "$else"
    $P3124 = $P3122."push"($P3123)
.annotate 'line', 948
    .return ($P3124)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<unless>"  :subid("439_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_3132
    .param pmc param_3133
.annotate 'line', 957
    .lex "self", param_3132
    .lex "$/", param_3133
.annotate 'line', 958
    new $P3134, "Undef"
    .lex "$past", $P3134
    find_lex $P3135, "$/"
    unless_null $P3135, vivify_1504
    $P3135 = root_new ['parrot';'Hash']
  vivify_1504:
    set $P3136, $P3135["xblock"]
    unless_null $P3136, vivify_1505
    new $P3136, "Undef"
  vivify_1505:
    $P3137 = $P3136."ast"()
    $P3138 = "xblock_immediate"($P3137)
    store_lex "$past", $P3138
.annotate 'line', 959
    find_lex $P3139, "$past"
    $P3139."pasttype"("unless")
.annotate 'line', 960
    find_lex $P3140, "$/"
    find_lex $P3141, "$past"
    $P3142 = $P3140."!make"($P3141)
.annotate 'line', 957
    .return ($P3142)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<while>"  :subid("440_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_3144
    .param pmc param_3145
.annotate 'line', 963
    .lex "self", param_3144
    .lex "$/", param_3145
.annotate 'line', 964
    new $P3146, "Undef"
    .lex "$past", $P3146
    find_lex $P3147, "$/"
    unless_null $P3147, vivify_1506
    $P3147 = root_new ['parrot';'Hash']
  vivify_1506:
    set $P3148, $P3147["xblock"]
    unless_null $P3148, vivify_1507
    new $P3148, "Undef"
  vivify_1507:
    $P3149 = $P3148."ast"()
    $P3150 = "xblock_immediate"($P3149)
    store_lex "$past", $P3150
.annotate 'line', 965
    find_lex $P3151, "$past"
    find_lex $P3152, "$/"
    unless_null $P3152, vivify_1508
    $P3152 = root_new ['parrot';'Hash']
  vivify_1508:
    set $P3153, $P3152["sym"]
    unless_null $P3153, vivify_1509
    new $P3153, "Undef"
  vivify_1509:
    set $S3154, $P3153
    $P3151."pasttype"($S3154)
.annotate 'line', 966
    find_lex $P3155, "$/"
    find_lex $P3156, "$past"
    $P3157 = $P3155."!make"($P3156)
.annotate 'line', 963
    .return ($P3157)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<repeat>"  :subid("441_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_3159
    .param pmc param_3160
.annotate 'line', 969
    .lex "self", param_3159
    .lex "$/", param_3160
.annotate 'line', 970
    new $P3161, "Undef"
    .lex "$pasttype", $P3161
.annotate 'line', 971
    new $P3162, "Undef"
    .lex "$past", $P3162
.annotate 'line', 970
    new $P3163, "String"
    assign $P3163, "repeat_"
    find_lex $P3164, "$/"
    unless_null $P3164, vivify_1510
    $P3164 = root_new ['parrot';'Hash']
  vivify_1510:
    set $P3165, $P3164["wu"]
    unless_null $P3165, vivify_1511
    new $P3165, "Undef"
  vivify_1511:
    set $S3166, $P3165
    concat $P3167, $P3163, $S3166
    store_lex "$pasttype", $P3167
    find_lex $P3168, "$past"
.annotate 'line', 972
    find_lex $P3170, "$/"
    unless_null $P3170, vivify_1512
    $P3170 = root_new ['parrot';'Hash']
  vivify_1512:
    set $P3171, $P3170["xblock"]
    unless_null $P3171, vivify_1513
    new $P3171, "Undef"
  vivify_1513:
    if $P3171, if_3169
.annotate 'line', 977
    get_hll_global $P3178, ["PAST"], "Op"
    find_lex $P3179, "$/"
    unless_null $P3179, vivify_1514
    $P3179 = root_new ['parrot';'Hash']
  vivify_1514:
    set $P3180, $P3179["EXPR"]
    unless_null $P3180, vivify_1515
    new $P3180, "Undef"
  vivify_1515:
    $P3181 = $P3180."ast"()
    find_lex $P3182, "$/"
    unless_null $P3182, vivify_1516
    $P3182 = root_new ['parrot';'Hash']
  vivify_1516:
    set $P3183, $P3182["pblock"]
    unless_null $P3183, vivify_1517
    new $P3183, "Undef"
  vivify_1517:
    $P3184 = $P3183."ast"()
    $P3185 = "block_immediate"($P3184)
    find_lex $P3186, "$pasttype"
    find_lex $P3187, "$/"
    $P3188 = $P3178."new"($P3181, $P3185, $P3186 :named("pasttype"), $P3187 :named("node"))
    store_lex "$past", $P3188
.annotate 'line', 976
    goto if_3169_end
  if_3169:
.annotate 'line', 973
    find_lex $P3172, "$/"
    unless_null $P3172, vivify_1518
    $P3172 = root_new ['parrot';'Hash']
  vivify_1518:
    set $P3173, $P3172["xblock"]
    unless_null $P3173, vivify_1519
    new $P3173, "Undef"
  vivify_1519:
    $P3174 = $P3173."ast"()
    $P3175 = "xblock_immediate"($P3174)
    store_lex "$past", $P3175
.annotate 'line', 974
    find_lex $P3176, "$past"
    find_lex $P3177, "$pasttype"
    $P3176."pasttype"($P3177)
  if_3169_end:
.annotate 'line', 980
    find_lex $P3189, "$/"
    find_lex $P3190, "$past"
    $P3191 = $P3189."!make"($P3190)
.annotate 'line', 969
    .return ($P3191)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<for>"  :subid("442_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_3193
    .param pmc param_3194
.annotate 'line', 983
    .lex "self", param_3193
    .lex "$/", param_3194
.annotate 'line', 984
    new $P3195, "Undef"
    .lex "$past", $P3195
.annotate 'line', 986
    new $P3196, "Undef"
    .lex "$block", $P3196
.annotate 'line', 984
    find_lex $P3197, "$/"
    unless_null $P3197, vivify_1520
    $P3197 = root_new ['parrot';'Hash']
  vivify_1520:
    set $P3198, $P3197["xblock"]
    unless_null $P3198, vivify_1521
    new $P3198, "Undef"
  vivify_1521:
    $P3199 = $P3198."ast"()
    store_lex "$past", $P3199
.annotate 'line', 985
    find_lex $P3200, "$past"
    $P3200."pasttype"("for")
.annotate 'line', 986
    find_lex $P3201, "$past"
    unless_null $P3201, vivify_1522
    $P3201 = root_new ['parrot';'ResizablePMCArray']
  vivify_1522:
    set $P3202, $P3201[1]
    unless_null $P3202, vivify_1523
    new $P3202, "Undef"
  vivify_1523:
    store_lex "$block", $P3202
.annotate 'line', 987
    find_lex $P3204, "$block"
    $P3205 = $P3204."arity"()
    if $P3205, unless_3203_end
.annotate 'line', 988
    find_lex $P3206, "$block"
    unless_null $P3206, vivify_1524
    $P3206 = root_new ['parrot';'ResizablePMCArray']
  vivify_1524:
    set $P3207, $P3206[0]
    unless_null $P3207, vivify_1525
    new $P3207, "Undef"
  vivify_1525:
    get_hll_global $P3208, ["PAST"], "Var"
    $P3209 = $P3208."new"("$_" :named("name"), "parameter" :named("scope"))
    $P3207."push"($P3209)
.annotate 'line', 989
    find_lex $P3210, "$block"
    $P3210."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 990
    find_lex $P3211, "$block"
    $P3211."arity"(1)
  unless_3203_end:
.annotate 'line', 992
    find_lex $P3212, "$block"
    $P3212."blocktype"("immediate")
.annotate 'line', 993
    find_lex $P3213, "$/"
    find_lex $P3214, "$past"
    $P3215 = $P3213."!make"($P3214)
.annotate 'line', 983
    .return ($P3215)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CATCH>"  :subid("443_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_3217
    .param pmc param_3218
.annotate 'line', 996
    .lex "self", param_3217
    .lex "$/", param_3218
.annotate 'line', 997
    new $P3219, "Undef"
    .lex "$block", $P3219
    find_lex $P3220, "$/"
    unless_null $P3220, vivify_1526
    $P3220 = root_new ['parrot';'Hash']
  vivify_1526:
    set $P3221, $P3220["block"]
    unless_null $P3221, vivify_1527
    new $P3221, "Undef"
  vivify_1527:
    $P3222 = $P3221."ast"()
    store_lex "$block", $P3222
.annotate 'line', 998
    find_lex $P3223, "$/"
    find_lex $P3224, "$block"
    "push_block_handler"($P3223, $P3224)
.annotate 'line', 999
    get_global $P3225, "@BLOCK"
    unless_null $P3225, vivify_1528
    $P3225 = root_new ['parrot';'ResizablePMCArray']
  vivify_1528:
    set $P3226, $P3225[0]
    unless_null $P3226, vivify_1529
    new $P3226, "Undef"
  vivify_1529:
    $P3227 = $P3226."handlers"()
    set $P3228, $P3227[0]
    unless_null $P3228, vivify_1530
    new $P3228, "Undef"
  vivify_1530:
    $P3228."handle_types_except"("CONTROL")
.annotate 'line', 1000
    find_lex $P3229, "$/"
    get_hll_global $P3230, ["PAST"], "Stmts"
    find_lex $P3231, "$/"
    $P3232 = $P3230."new"($P3231 :named("node"))
    $P3233 = $P3229."!make"($P3232)
.annotate 'line', 996
    .return ($P3233)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CONTROL>"  :subid("444_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_3235
    .param pmc param_3236
.annotate 'line', 1003
    .lex "self", param_3235
    .lex "$/", param_3236
.annotate 'line', 1004
    new $P3237, "Undef"
    .lex "$block", $P3237
    find_lex $P3238, "$/"
    unless_null $P3238, vivify_1531
    $P3238 = root_new ['parrot';'Hash']
  vivify_1531:
    set $P3239, $P3238["block"]
    unless_null $P3239, vivify_1532
    new $P3239, "Undef"
  vivify_1532:
    $P3240 = $P3239."ast"()
    store_lex "$block", $P3240
.annotate 'line', 1005
    find_lex $P3241, "$/"
    find_lex $P3242, "$block"
    "push_block_handler"($P3241, $P3242)
.annotate 'line', 1006
    get_global $P3243, "@BLOCK"
    unless_null $P3243, vivify_1533
    $P3243 = root_new ['parrot';'ResizablePMCArray']
  vivify_1533:
    set $P3244, $P3243[0]
    unless_null $P3244, vivify_1534
    new $P3244, "Undef"
  vivify_1534:
    $P3245 = $P3244."handlers"()
    set $P3246, $P3245[0]
    unless_null $P3246, vivify_1535
    new $P3246, "Undef"
  vivify_1535:
    $P3246."handle_types"("CONTROL")
.annotate 'line', 1007
    find_lex $P3247, "$/"
    get_hll_global $P3248, ["PAST"], "Stmts"
    find_lex $P3249, "$/"
    $P3250 = $P3248."new"($P3249 :named("node"))
    $P3251 = $P3247."!make"($P3250)
.annotate 'line', 1003
    .return ($P3251)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<INIT>"  :subid("445_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_3254
    .param pmc param_3255
.annotate 'line', 1047
    .lex "self", param_3254
    .lex "$/", param_3255
.annotate 'line', 1048
    new $P3256, "Undef"
    .lex "$init_block", $P3256
    get_hll_global $P3257, ["PAST"], "Block"
    $P3258 = $P3257."new"("immediate" :named("blocktype"))
    store_lex "$init_block", $P3258
.annotate 'line', 1049
    find_lex $P3259, "$init_block"
    $P3260 = $P3259."loadinit"()
    find_lex $P3261, "$/"
    unless_null $P3261, vivify_1536
    $P3261 = root_new ['parrot';'Hash']
  vivify_1536:
    set $P3262, $P3261["blorst"]
    unless_null $P3262, vivify_1537
    new $P3262, "Undef"
  vivify_1537:
    $P3263 = $P3262."ast"()
    $P3260."push"($P3263)
.annotate 'line', 1050
    find_lex $P3264, "$/"
    find_lex $P3265, "$init_block"
    $P3266 = $P3264."!make"($P3265)
.annotate 'line', 1047
    .return ($P3266)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<try>"  :subid("446_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_3268
    .param pmc param_3269
.annotate 'line', 1053
    .lex "self", param_3268
    .lex "$/", param_3269
.annotate 'line', 1054
    new $P3270, "Undef"
    .lex "$past", $P3270
    find_lex $P3271, "$/"
    unless_null $P3271, vivify_1538
    $P3271 = root_new ['parrot';'Hash']
  vivify_1538:
    set $P3272, $P3271["blorst"]
    unless_null $P3272, vivify_1539
    new $P3272, "Undef"
  vivify_1539:
    $P3273 = $P3272."ast"()
    store_lex "$past", $P3273
.annotate 'line', 1055
    get_hll_global $P3275, ["PAST"], "Block"
    find_lex $P3276, "$past"
    $P3277 = $P3275."ACCEPTS"($P3276)
    if $P3277, unless_3274_end
.annotate 'line', 1056
    get_hll_global $P3278, ["PAST"], "Block"
    find_lex $P3279, "$past"
    find_lex $P3280, "$/"
    $P3281 = $P3278."new"($P3279, "immediate" :named("blocktype"), $P3280 :named("node"))
    store_lex "$past", $P3281
  unless_3274_end:
.annotate 'line', 1058
    find_lex $P3283, "$past"
    $P3284 = $P3283."handlers"()
    if $P3284, unless_3282_end
.annotate 'line', 1059
    find_lex $P3285, "$past"
    get_hll_global $P3286, ["PAST"], "Control"
.annotate 'line', 1061
    get_hll_global $P3287, ["PAST"], "Stmts"
.annotate 'line', 1062
    get_hll_global $P3288, ["PAST"], "Op"
.annotate 'line', 1063
    get_hll_global $P3289, ["PAST"], "Var"
.annotate 'line', 1064
    get_hll_global $P3290, ["PAST"], "Var"
    $P3291 = $P3290."new"("register" :named("scope"), "exception" :named("name"))
    $P3292 = $P3289."new"($P3291, "handled", "keyed" :named("scope"))
.annotate 'line', 1063
    $P3293 = $P3288."new"($P3292, 1, "bind" :named("pasttype"))
.annotate 'line', 1062
    $P3294 = $P3287."new"($P3293)
.annotate 'line', 1061
    $P3295 = $P3286."new"($P3294, "CONTROL" :named("handle_types_except"))
.annotate 'line', 1059
    new $P3296, "ResizablePMCArray"
    push $P3296, $P3295
    $P3285."handlers"($P3296)
  unless_3282_end:
.annotate 'line', 1073
    find_lex $P3297, "$/"
    find_lex $P3298, "$past"
    $P3299 = $P3297."!make"($P3298)
.annotate 'line', 1053
    .return ($P3299)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blorst"  :subid("447_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_3301
    .param pmc param_3302
.annotate 'line', 1076
    .lex "self", param_3301
    .lex "$/", param_3302
.annotate 'line', 1077
    find_lex $P3303, "$/"
.annotate 'line', 1078
    find_lex $P3306, "$/"
    unless_null $P3306, vivify_1540
    $P3306 = root_new ['parrot';'Hash']
  vivify_1540:
    set $P3307, $P3306["block"]
    unless_null $P3307, vivify_1541
    new $P3307, "Undef"
  vivify_1541:
    if $P3307, if_3305
.annotate 'line', 1079
    find_lex $P3312, "$/"
    unless_null $P3312, vivify_1542
    $P3312 = root_new ['parrot';'Hash']
  vivify_1542:
    set $P3313, $P3312["statement"]
    unless_null $P3313, vivify_1543
    new $P3313, "Undef"
  vivify_1543:
    $P3314 = $P3313."ast"()
    set $P3304, $P3314
.annotate 'line', 1078
    goto if_3305_end
  if_3305:
    find_lex $P3308, "$/"
    unless_null $P3308, vivify_1544
    $P3308 = root_new ['parrot';'Hash']
  vivify_1544:
    set $P3309, $P3308["block"]
    unless_null $P3309, vivify_1545
    new $P3309, "Undef"
  vivify_1545:
    $P3310 = $P3309."ast"()
    $P3311 = "block_immediate"($P3310)
    set $P3304, $P3311
  if_3305_end:
    $P3315 = $P3303."!make"($P3304)
.annotate 'line', 1076
    .return ($P3315)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<if>"  :subid("448_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_3317
    .param pmc param_3318
.annotate 'line', 1084
    .lex "self", param_3317
    .lex "$/", param_3318
    find_lex $P3319, "$/"
    find_lex $P3320, "$/"
    unless_null $P3320, vivify_1546
    $P3320 = root_new ['parrot';'Hash']
  vivify_1546:
    set $P3321, $P3320["cond"]
    unless_null $P3321, vivify_1547
    new $P3321, "Undef"
  vivify_1547:
    $P3322 = $P3321."ast"()
    $P3323 = $P3319."!make"($P3322)
    .return ($P3323)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<unless>"  :subid("449_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_3325
    .param pmc param_3326
.annotate 'line', 1085
    .lex "self", param_3325
    .lex "$/", param_3326
    find_lex $P3327, "$/"
    find_lex $P3328, "$/"
    unless_null $P3328, vivify_1548
    $P3328 = root_new ['parrot';'Hash']
  vivify_1548:
    set $P3329, $P3328["cond"]
    unless_null $P3329, vivify_1549
    new $P3329, "Undef"
  vivify_1549:
    $P3330 = $P3329."ast"()
    $P3331 = $P3327."!make"($P3330)
    .return ($P3331)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<while>"  :subid("450_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_3333
    .param pmc param_3334
.annotate 'line', 1087
    .lex "self", param_3333
    .lex "$/", param_3334
    find_lex $P3335, "$/"
    find_lex $P3336, "$/"
    unless_null $P3336, vivify_1550
    $P3336 = root_new ['parrot';'Hash']
  vivify_1550:
    set $P3337, $P3336["cond"]
    unless_null $P3337, vivify_1551
    new $P3337, "Undef"
  vivify_1551:
    $P3338 = $P3337."ast"()
    $P3339 = $P3335."!make"($P3338)
    .return ($P3339)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<until>"  :subid("451_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_3341
    .param pmc param_3342
.annotate 'line', 1088
    .lex "self", param_3341
    .lex "$/", param_3342
    find_lex $P3343, "$/"
    find_lex $P3344, "$/"
    unless_null $P3344, vivify_1552
    $P3344 = root_new ['parrot';'Hash']
  vivify_1552:
    set $P3345, $P3344["cond"]
    unless_null $P3345, vivify_1553
    new $P3345, "Undef"
  vivify_1553:
    $P3346 = $P3345."ast"()
    $P3347 = $P3343."!make"($P3346)
    .return ($P3347)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<fatarrow>"  :subid("452_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_3349
    .param pmc param_3350
.annotate 'line', 1092
    .lex "self", param_3349
    .lex "$/", param_3350
    find_lex $P3351, "$/"
    find_lex $P3352, "$/"
    unless_null $P3352, vivify_1554
    $P3352 = root_new ['parrot';'Hash']
  vivify_1554:
    set $P3353, $P3352["fatarrow"]
    unless_null $P3353, vivify_1555
    new $P3353, "Undef"
  vivify_1555:
    $P3354 = $P3353."ast"()
    $P3355 = $P3351."!make"($P3354)
    .return ($P3355)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<colonpair>"  :subid("453_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_3357
    .param pmc param_3358
.annotate 'line', 1093
    .lex "self", param_3357
    .lex "$/", param_3358
    find_lex $P3359, "$/"
    find_lex $P3360, "$/"
    unless_null $P3360, vivify_1556
    $P3360 = root_new ['parrot';'Hash']
  vivify_1556:
    set $P3361, $P3360["colonpair"]
    unless_null $P3361, vivify_1557
    new $P3361, "Undef"
  vivify_1557:
    $P3362 = $P3361."ast"()
    $P3363 = $P3359."!make"($P3362)
    .return ($P3363)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<variable>"  :subid("454_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_3365
    .param pmc param_3366
.annotate 'line', 1094
    .lex "self", param_3365
    .lex "$/", param_3366
    find_lex $P3367, "$/"
    find_lex $P3368, "$/"
    unless_null $P3368, vivify_1558
    $P3368 = root_new ['parrot';'Hash']
  vivify_1558:
    set $P3369, $P3368["variable"]
    unless_null $P3369, vivify_1559
    new $P3369, "Undef"
  vivify_1559:
    $P3370 = $P3369."ast"()
    $P3371 = $P3367."!make"($P3370)
    .return ($P3371)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<package_declarator>"  :subid("455_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_3373
    .param pmc param_3374
.annotate 'line', 1095
    .lex "self", param_3373
    .lex "$/", param_3374
    find_lex $P3375, "$/"
    find_lex $P3376, "$/"
    unless_null $P3376, vivify_1560
    $P3376 = root_new ['parrot';'Hash']
  vivify_1560:
    set $P3377, $P3376["package_declarator"]
    unless_null $P3377, vivify_1561
    new $P3377, "Undef"
  vivify_1561:
    $P3378 = $P3377."ast"()
    $P3379 = $P3375."!make"($P3378)
    .return ($P3379)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<scope_declarator>"  :subid("456_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_3381
    .param pmc param_3382
.annotate 'line', 1096
    .lex "self", param_3381
    .lex "$/", param_3382
    find_lex $P3383, "$/"
    find_lex $P3384, "$/"
    unless_null $P3384, vivify_1562
    $P3384 = root_new ['parrot';'Hash']
  vivify_1562:
    set $P3385, $P3384["scope_declarator"]
    unless_null $P3385, vivify_1563
    new $P3385, "Undef"
  vivify_1563:
    $P3386 = $P3385."ast"()
    $P3387 = $P3383."!make"($P3386)
    .return ($P3387)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<routine_declarator>"  :subid("457_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_3389
    .param pmc param_3390
.annotate 'line', 1097
    .lex "self", param_3389
    .lex "$/", param_3390
    find_lex $P3391, "$/"
    find_lex $P3392, "$/"
    unless_null $P3392, vivify_1564
    $P3392 = root_new ['parrot';'Hash']
  vivify_1564:
    set $P3393, $P3392["routine_declarator"]
    unless_null $P3393, vivify_1565
    new $P3393, "Undef"
  vivify_1565:
    $P3394 = $P3393."ast"()
    $P3395 = $P3391."!make"($P3394)
    .return ($P3395)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<regex_declarator>"  :subid("458_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_3397
    .param pmc param_3398
.annotate 'line', 1098
    .lex "self", param_3397
    .lex "$/", param_3398
    find_lex $P3399, "$/"
    find_lex $P3400, "$/"
    unless_null $P3400, vivify_1566
    $P3400 = root_new ['parrot';'Hash']
  vivify_1566:
    set $P3401, $P3400["regex_declarator"]
    unless_null $P3401, vivify_1567
    new $P3401, "Undef"
  vivify_1567:
    $P3402 = $P3401."ast"()
    $P3403 = $P3399."!make"($P3402)
    .return ($P3403)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<statement_prefix>"  :subid("459_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_3405
    .param pmc param_3406
.annotate 'line', 1099
    .lex "self", param_3405
    .lex "$/", param_3406
    find_lex $P3407, "$/"
    find_lex $P3408, "$/"
    unless_null $P3408, vivify_1568
    $P3408 = root_new ['parrot';'Hash']
  vivify_1568:
    set $P3409, $P3408["statement_prefix"]
    unless_null $P3409, vivify_1569
    new $P3409, "Undef"
  vivify_1569:
    $P3410 = $P3409."ast"()
    $P3411 = $P3407."!make"($P3410)
    .return ($P3411)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<lambda>"  :subid("460_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_3413
    .param pmc param_3414
.annotate 'line', 1100
    .lex "self", param_3413
    .lex "$/", param_3414
    find_lex $P3415, "$/"
    find_lex $P3416, "$/"
    unless_null $P3416, vivify_1570
    $P3416 = root_new ['parrot';'Hash']
  vivify_1570:
    set $P3417, $P3416["pblock"]
    unless_null $P3417, vivify_1571
    new $P3417, "Undef"
  vivify_1571:
    $P3418 = $P3417."ast"()
    $P3419 = $P3415."!make"($P3418)
    .return ($P3419)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "fatarrow"  :subid("461_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_3421
    .param pmc param_3422
.annotate 'line', 1102
    .lex "self", param_3421
    .lex "$/", param_3422
.annotate 'line', 1103
    new $P3423, "Undef"
    .lex "$past", $P3423
    find_lex $P3424, "$/"
    unless_null $P3424, vivify_1572
    $P3424 = root_new ['parrot';'Hash']
  vivify_1572:
    set $P3425, $P3424["val"]
    unless_null $P3425, vivify_1573
    new $P3425, "Undef"
  vivify_1573:
    $P3426 = $P3425."ast"()
    store_lex "$past", $P3426
.annotate 'line', 1104
    find_lex $P3427, "$past"
    find_lex $P3428, "$/"
    unless_null $P3428, vivify_1574
    $P3428 = root_new ['parrot';'Hash']
  vivify_1574:
    set $P3429, $P3428["key"]
    unless_null $P3429, vivify_1575
    new $P3429, "Undef"
  vivify_1575:
    $P3430 = $P3429."Str"()
    $P3427."named"($P3430)
.annotate 'line', 1105
    find_lex $P3431, "$/"
    find_lex $P3432, "$past"
    $P3433 = $P3431."!make"($P3432)
.annotate 'line', 1102
    .return ($P3433)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair"  :subid("462_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_3435
    .param pmc param_3436
.annotate 'line', 1108
    .lex "self", param_3435
    .lex "$/", param_3436
.annotate 'line', 1109
    new $P3437, "Undef"
    .lex "$past", $P3437
.annotate 'line', 1110
    find_lex $P3440, "$/"
    unless_null $P3440, vivify_1576
    $P3440 = root_new ['parrot';'Hash']
  vivify_1576:
    set $P3441, $P3440["circumfix"]
    unless_null $P3441, vivify_1577
    new $P3441, "Undef"
  vivify_1577:
    if $P3441, if_3439
.annotate 'line', 1111
    get_hll_global $P3446, ["PAST"], "Val"
    find_lex $P3447, "$/"
    unless_null $P3447, vivify_1578
    $P3447 = root_new ['parrot';'Hash']
  vivify_1578:
    set $P3448, $P3447["not"]
    unless_null $P3448, vivify_1579
    new $P3448, "Undef"
  vivify_1579:
    isfalse $I3449, $P3448
    $P3450 = $P3446."new"($I3449 :named("value"))
    set $P3438, $P3450
.annotate 'line', 1110
    goto if_3439_end
  if_3439:
    find_lex $P3442, "$/"
    unless_null $P3442, vivify_1580
    $P3442 = root_new ['parrot';'Hash']
  vivify_1580:
    set $P3443, $P3442["circumfix"]
    unless_null $P3443, vivify_1581
    $P3443 = root_new ['parrot';'ResizablePMCArray']
  vivify_1581:
    set $P3444, $P3443[0]
    unless_null $P3444, vivify_1582
    new $P3444, "Undef"
  vivify_1582:
    $P3445 = $P3444."ast"()
    set $P3438, $P3445
  if_3439_end:
    store_lex "$past", $P3438
.annotate 'line', 1112
    find_lex $P3451, "$past"
    find_lex $P3452, "$/"
    unless_null $P3452, vivify_1583
    $P3452 = root_new ['parrot';'Hash']
  vivify_1583:
    set $P3453, $P3452["identifier"]
    unless_null $P3453, vivify_1584
    new $P3453, "Undef"
  vivify_1584:
    set $S3454, $P3453
    $P3451."named"($S3454)
.annotate 'line', 1113
    find_lex $P3455, "$/"
    find_lex $P3456, "$past"
    $P3457 = $P3455."!make"($P3456)
.annotate 'line', 1108
    .return ($P3457)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "variable"  :subid("463_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_3459
    .param pmc param_3460
.annotate 'line', 1116
    .const 'Sub' $P3473 = "464_1302110486.758" 
    capture_lex $P3473
    .lex "self", param_3459
    .lex "$/", param_3460
.annotate 'line', 1117
    new $P3461, "Undef"
    .lex "$past", $P3461
.annotate 'line', 1116
    find_lex $P3462, "$past"
.annotate 'line', 1118
    find_lex $P3464, "$/"
    unless_null $P3464, vivify_1585
    $P3464 = root_new ['parrot';'Hash']
  vivify_1585:
    set $P3465, $P3464["postcircumfix"]
    unless_null $P3465, vivify_1586
    new $P3465, "Undef"
  vivify_1586:
    if $P3465, if_3463
.annotate 'line', 1122
    .const 'Sub' $P3473 = "464_1302110486.758" 
    capture_lex $P3473
    $P3473()
    goto if_3463_end
  if_3463:
.annotate 'line', 1119
    find_lex $P3466, "$/"
    unless_null $P3466, vivify_1603
    $P3466 = root_new ['parrot';'Hash']
  vivify_1603:
    set $P3467, $P3466["postcircumfix"]
    unless_null $P3467, vivify_1604
    new $P3467, "Undef"
  vivify_1604:
    $P3468 = $P3467."ast"()
    store_lex "$past", $P3468
.annotate 'line', 1120
    find_lex $P3469, "$past"
    get_hll_global $P3470, ["PAST"], "Var"
    $P3471 = $P3470."new"("$/" :named("name"))
    $P3469."unshift"($P3471)
  if_3463_end:
.annotate 'line', 1152
    find_lex $P3545, "$/"
    find_lex $P3546, "$past"
    $P3547 = $P3545."!make"($P3546)
.annotate 'line', 1116
    .return ($P3547)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3472"  :anon :subid("464_1302110486.758") :outer("463_1302110486.758")
.annotate 'line', 1123
    $P3474 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P3474
    get_hll_global $P3475, ["NQP"], "Compiler"
    find_lex $P3476, "$/"
    set $S3477, $P3476
    $P3478 = $P3475."parse_name"($S3477)
    store_lex "@name", $P3478
.annotate 'line', 1124
    get_hll_global $P3479, ["PAST"], "Var"
    find_lex $P3480, "@name"
    $P3481 = $P3480."pop"()
    set $S3482, $P3481
    $P3483 = $P3479."new"($S3482 :named("name"))
    store_lex "$past", $P3483
.annotate 'line', 1125
    find_lex $P3485, "@name"
    unless $P3485, if_3484_end
.annotate 'line', 1126
    find_lex $P3487, "@name"
    unless_null $P3487, vivify_1587
    $P3487 = root_new ['parrot';'ResizablePMCArray']
  vivify_1587:
    set $P3488, $P3487[0]
    unless_null $P3488, vivify_1588
    new $P3488, "Undef"
  vivify_1588:
    set $S3489, $P3488
    iseq $I3490, $S3489, "GLOBAL"
    unless $I3490, if_3486_end
    find_lex $P3491, "@name"
    $P3491."shift"()
  if_3486_end:
.annotate 'line', 1127
    find_lex $P3492, "$past"
    find_lex $P3493, "@name"
    $P3492."namespace"($P3493)
.annotate 'line', 1128
    find_lex $P3494, "$past"
    $P3494."scope"("package")
.annotate 'line', 1129
    find_lex $P3495, "$past"
    find_lex $P3496, "$/"
    unless_null $P3496, vivify_1589
    $P3496 = root_new ['parrot';'Hash']
  vivify_1589:
    set $P3497, $P3496["sigil"]
    unless_null $P3497, vivify_1590
    new $P3497, "Undef"
  vivify_1590:
    $P3498 = "vivitype"($P3497)
    $P3495."viviself"($P3498)
.annotate 'line', 1130
    find_lex $P3499, "$past"
    $P3499."lvalue"(1)
  if_3484_end:
.annotate 'line', 1132
    find_lex $P3502, "$/"
    unless_null $P3502, vivify_1591
    $P3502 = root_new ['parrot';'Hash']
  vivify_1591:
    set $P3503, $P3502["twigil"]
    unless_null $P3503, vivify_1592
    $P3503 = root_new ['parrot';'ResizablePMCArray']
  vivify_1592:
    set $P3504, $P3503[0]
    unless_null $P3504, vivify_1593
    new $P3504, "Undef"
  vivify_1593:
    set $S3505, $P3504
    iseq $I3506, $S3505, "*"
    if $I3506, if_3501
.annotate 'line', 1145
    find_lex $P3528, "$/"
    unless_null $P3528, vivify_1594
    $P3528 = root_new ['parrot';'Hash']
  vivify_1594:
    set $P3529, $P3528["twigil"]
    unless_null $P3529, vivify_1595
    $P3529 = root_new ['parrot';'ResizablePMCArray']
  vivify_1595:
    set $P3530, $P3529[0]
    unless_null $P3530, vivify_1596
    new $P3530, "Undef"
  vivify_1596:
    set $S3531, $P3530
    iseq $I3532, $S3531, "!"
    if $I3532, if_3527
    new $P3526, 'Integer'
    set $P3526, $I3532
    goto if_3527_end
  if_3527:
.annotate 'line', 1146
    find_lex $P3533, "$past"
    get_hll_global $P3534, ["PAST"], "Var"
    $P3535 = $P3534."new"("self" :named("name"))
    $P3533."push"($P3535)
.annotate 'line', 1147
    find_lex $P3536, "$past"
    $P3536."scope"("attribute")
.annotate 'line', 1148
    find_lex $P3537, "$past"
    find_lex $P3538, "$/"
    unless_null $P3538, vivify_1597
    $P3538 = root_new ['parrot';'Hash']
  vivify_1597:
    set $P3539, $P3538["sigil"]
    unless_null $P3539, vivify_1598
    new $P3539, "Undef"
  vivify_1598:
    $P3540 = "vivitype"($P3539)
    $P3537."viviself"($P3540)
.annotate 'line', 1149
    find_lex $P3541, "$past"
    get_hll_global $P3542, ["PAST"], "Var"
    $P3543 = $P3542."new"("$?CLASS" :named("name"))
    $P3544 = $P3541."push"($P3543)
.annotate 'line', 1145
    set $P3526, $P3544
  if_3527_end:
    set $P3500, $P3526
.annotate 'line', 1132
    goto if_3501_end
  if_3501:
.annotate 'line', 1133
    find_lex $P3507, "$past"
    $P3507."scope"("contextual")
.annotate 'line', 1134
    find_lex $P3508, "$past"
.annotate 'line', 1135
    get_hll_global $P3509, ["PAST"], "Var"
.annotate 'line', 1137
    find_lex $P3510, "$/"
    unless_null $P3510, vivify_1599
    $P3510 = root_new ['parrot';'Hash']
  vivify_1599:
    set $P3511, $P3510["sigil"]
    unless_null $P3511, vivify_1600
    new $P3511, "Undef"
  vivify_1600:
    set $S3512, $P3511
    new $P3513, 'String'
    set $P3513, $S3512
    find_lex $P3514, "$/"
    unless_null $P3514, vivify_1601
    $P3514 = root_new ['parrot';'Hash']
  vivify_1601:
    set $P3515, $P3514["desigilname"]
    unless_null $P3515, vivify_1602
    new $P3515, "Undef"
  vivify_1602:
    concat $P3516, $P3513, $P3515
.annotate 'line', 1139
    get_hll_global $P3517, ["PAST"], "Op"
    new $P3518, "String"
    assign $P3518, "Contextual "
    find_lex $P3519, "$/"
    set $S3520, $P3519
    concat $P3521, $P3518, $S3520
    concat $P3522, $P3521, " not found"
    $P3523 = $P3517."new"($P3522, "die" :named("pirop"))
    $P3524 = $P3509."new"("package" :named("scope"), "" :named("namespace"), $P3516 :named("name"), $P3523 :named("viviself"))
.annotate 'line', 1135
    $P3525 = $P3508."viviself"($P3524)
.annotate 'line', 1132
    set $P3500, $P3525
  if_3501_end:
.annotate 'line', 1122
    .return ($P3500)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<module>"  :subid("465_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_3549
    .param pmc param_3550
.annotate 'line', 1155
    .lex "self", param_3549
    .lex "$/", param_3550
    find_lex $P3551, "$/"
    find_lex $P3552, "$/"
    unless_null $P3552, vivify_1605
    $P3552 = root_new ['parrot';'Hash']
  vivify_1605:
    set $P3553, $P3552["package_def"]
    unless_null $P3553, vivify_1606
    new $P3553, "Undef"
  vivify_1606:
    $P3554 = $P3553."ast"()
    $P3555 = $P3551."!make"($P3554)
    .return ($P3555)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<knowhow>"  :subid("466_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_3557
    .param pmc param_3558
.annotate 'line', 1156
    .lex "self", param_3557
    .lex "$/", param_3558
    find_lex $P3559, "$/"
    find_lex $P3560, "$/"
    unless_null $P3560, vivify_1607
    $P3560 = root_new ['parrot';'Hash']
  vivify_1607:
    set $P3561, $P3560["package_def"]
    unless_null $P3561, vivify_1608
    new $P3561, "Undef"
  vivify_1608:
    $P3562 = $P3561."ast"()
    $P3563 = $P3559."!make"($P3562)
    .return ($P3563)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<class>"  :subid("467_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_3565
    .param pmc param_3566
.annotate 'line', 1157
    .lex "self", param_3565
    .lex "$/", param_3566
    find_lex $P3567, "$/"
    find_lex $P3568, "$/"
    unless_null $P3568, vivify_1609
    $P3568 = root_new ['parrot';'Hash']
  vivify_1609:
    set $P3569, $P3568["package_def"]
    unless_null $P3569, vivify_1610
    new $P3569, "Undef"
  vivify_1610:
    $P3570 = $P3569."ast"()
    $P3571 = $P3567."!make"($P3570)
    .return ($P3571)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<grammar>"  :subid("468_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_3573
    .param pmc param_3574
.annotate 'line', 1158
    .lex "self", param_3573
    .lex "$/", param_3574
    find_lex $P3575, "$/"
    find_lex $P3576, "$/"
    unless_null $P3576, vivify_1611
    $P3576 = root_new ['parrot';'Hash']
  vivify_1611:
    set $P3577, $P3576["package_def"]
    unless_null $P3577, vivify_1612
    new $P3577, "Undef"
  vivify_1612:
    $P3578 = $P3577."ast"()
    $P3579 = $P3575."!make"($P3578)
    .return ($P3579)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<role>"  :subid("469_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_3581
    .param pmc param_3582
.annotate 'line', 1159
    .lex "self", param_3581
    .lex "$/", param_3582
    find_lex $P3583, "$/"
    find_lex $P3584, "$/"
    unless_null $P3584, vivify_1613
    $P3584 = root_new ['parrot';'Hash']
  vivify_1613:
    set $P3585, $P3584["package_def"]
    unless_null $P3585, vivify_1614
    new $P3585, "Undef"
  vivify_1614:
    $P3586 = $P3585."ast"()
    $P3587 = $P3583."!make"($P3586)
    .return ($P3587)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<native>"  :subid("470_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_3589
    .param pmc param_3590
.annotate 'line', 1160
    .lex "self", param_3589
    .lex "$/", param_3590
    find_lex $P3591, "$/"
    find_lex $P3592, "$/"
    unless_null $P3592, vivify_1615
    $P3592 = root_new ['parrot';'Hash']
  vivify_1615:
    set $P3593, $P3592["package_def"]
    unless_null $P3593, vivify_1616
    new $P3593, "Undef"
  vivify_1616:
    $P3594 = $P3593."ast"()
    $P3595 = $P3591."!make"($P3594)
    .return ($P3595)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "package_def"  :subid("471_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_3597
    .param pmc param_3598
.annotate 'line', 1162
    .const 'Sub' $P3761 = "473_1302110486.758" 
    capture_lex $P3761
    .const 'Sub' $P3710 = "472_1302110486.758" 
    capture_lex $P3710
    .lex "self", param_3597
    .lex "$/", param_3598
.annotate 'line', 1164
    $P3599 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P3599
.annotate 'line', 1165
    new $P3600, "Undef"
    .lex "$name", $P3600
.annotate 'line', 1166
    new $P3601, "Undef"
    .lex "$how", $P3601
.annotate 'line', 1169
    new $P3602, "Undef"
    .lex "$past", $P3602
.annotate 'line', 1164
    find_lex $P3603, "$/"
    unless_null $P3603, vivify_1617
    $P3603 = root_new ['parrot';'Hash']
  vivify_1617:
    set $P3604, $P3603["name"]
    unless_null $P3604, vivify_1618
    $P3604 = root_new ['parrot';'Hash']
  vivify_1618:
    set $P3605, $P3604["identifier"]
    unless_null $P3605, vivify_1619
    new $P3605, "Undef"
  vivify_1619:
    clone $P3606, $P3605
    store_lex "@ns", $P3606
.annotate 'line', 1165
    find_lex $P3607, "@ns"
    $P3608 = $P3607."pop"()
    set $S3609, $P3608
    new $P3610, 'String'
    set $P3610, $S3609
    store_lex "$name", $P3610
.annotate 'line', 1166
    find_dynamic_lex $P3611, "$*PKGDECL"
    unless_null $P3611, vivify_1620
    get_hll_global $P3611, "$PKGDECL"
    unless_null $P3611, vivify_1621
    die "Contextual $*PKGDECL not found"
  vivify_1621:
  vivify_1620:
    find_dynamic_lex $P3612, "%*HOW"
    unless_null $P3612, vivify_1622
    get_hll_global $P3612, "%HOW"
    unless_null $P3612, vivify_1623
    die "Contextual %*HOW not found"
  vivify_1623:
  vivify_1622:
    set $P3613, $P3612[$P3611]
    unless_null $P3613, vivify_1624
    new $P3613, "Undef"
  vivify_1624:
    store_lex "$how", $P3613
.annotate 'line', 1169
    find_lex $P3616, "$/"
    unless_null $P3616, vivify_1625
    $P3616 = root_new ['parrot';'Hash']
  vivify_1625:
    set $P3617, $P3616["block"]
    unless_null $P3617, vivify_1626
    new $P3617, "Undef"
  vivify_1626:
    if $P3617, if_3615
    find_lex $P3621, "$/"
    unless_null $P3621, vivify_1627
    $P3621 = root_new ['parrot';'Hash']
  vivify_1627:
    set $P3622, $P3621["comp_unit"]
    unless_null $P3622, vivify_1628
    new $P3622, "Undef"
  vivify_1628:
    $P3623 = $P3622."ast"()
    set $P3614, $P3623
    goto if_3615_end
  if_3615:
    find_lex $P3618, "$/"
    unless_null $P3618, vivify_1629
    $P3618 = root_new ['parrot';'Hash']
  vivify_1629:
    set $P3619, $P3618["block"]
    unless_null $P3619, vivify_1630
    new $P3619, "Undef"
  vivify_1630:
    $P3620 = $P3619."ast"()
    set $P3614, $P3620
  if_3615_end:
    store_lex "$past", $P3614
.annotate 'line', 1172
    find_dynamic_lex $P3627, "$*SCOPE"
    unless_null $P3627, vivify_1631
    get_hll_global $P3627, "$SCOPE"
    unless_null $P3627, vivify_1632
    die "Contextual $*SCOPE not found"
  vivify_1632:
  vivify_1631:
    set $S3628, $P3627
    iseq $I3629, $S3628, "our"
    unless $I3629, unless_3626
    new $P3625, 'Integer'
    set $P3625, $I3629
    goto unless_3626_end
  unless_3626:
    find_dynamic_lex $P3630, "$*SCOPE"
    unless_null $P3630, vivify_1633
    get_hll_global $P3630, "$SCOPE"
    unless_null $P3630, vivify_1634
    die "Contextual $*SCOPE not found"
  vivify_1634:
  vivify_1633:
    set $S3631, $P3630
    iseq $I3632, $S3631, ""
    new $P3625, 'Integer'
    set $P3625, $I3632
  unless_3626_end:
    if $P3625, if_3624
.annotate 'line', 1176
    find_dynamic_lex $P3643, "$*SCOPE"
    unless_null $P3643, vivify_1635
    get_hll_global $P3643, "$SCOPE"
    unless_null $P3643, vivify_1636
    die "Contextual $*SCOPE not found"
  vivify_1636:
  vivify_1635:
    set $S3644, $P3643
    iseq $I3645, $S3644, "my"
    if $I3645, if_3642
.annotate 'line', 1183
    find_lex $P3663, "$/"
    $P3664 = $P3663."CURSOR"()
    find_dynamic_lex $P3665, "$*SCOPE"
    unless_null $P3665, vivify_1637
    get_hll_global $P3665, "$SCOPE"
    unless_null $P3665, vivify_1638
    die "Contextual $*SCOPE not found"
  vivify_1638:
  vivify_1637:
    concat $P3666, $P3665, " scoped packages are not supported"
    $P3664."panic"($P3666)
.annotate 'line', 1182
    goto if_3642_end
  if_3642:
.annotate 'line', 1177
    find_lex $P3647, "$/"
    unless_null $P3647, vivify_1639
    $P3647 = root_new ['parrot';'Hash']
  vivify_1639:
    set $P3648, $P3647["name"]
    unless_null $P3648, vivify_1640
    $P3648 = root_new ['parrot';'Hash']
  vivify_1640:
    set $P3649, $P3648["identifier"]
    unless_null $P3649, vivify_1641
    new $P3649, "Undef"
  vivify_1641:
    set $N3650, $P3649
    isne $I3651, $N3650, 1.0
    unless $I3651, if_3646_end
.annotate 'line', 1178
    find_lex $P3652, "$/"
    unless_null $P3652, vivify_1642
    $P3652 = root_new ['parrot';'Hash']
  vivify_1642:
    set $P3653, $P3652["name"]
    unless_null $P3653, vivify_1643
    new $P3653, "Undef"
  vivify_1643:
    $P3654 = $P3653."CURSOR"()
    $P3654."panic"("A my scoped package cannot have a multi-part name yet")
  if_3646_end:
.annotate 'line', 1180
    find_dynamic_lex $P3655, "$*SC"
    unless_null $P3655, vivify_1644
    get_hll_global $P3655, "$SC"
    unless_null $P3655, vivify_1645
    die "Contextual $*SC not found"
  vivify_1645:
  vivify_1644:
    get_global $P3656, "@BLOCK"
    unless_null $P3656, vivify_1646
    $P3656 = root_new ['parrot';'ResizablePMCArray']
  vivify_1646:
    set $P3657, $P3656[0]
    unless_null $P3657, vivify_1647
    new $P3657, "Undef"
  vivify_1647:
    find_lex $P3658, "$/"
    unless_null $P3658, vivify_1648
    $P3658 = root_new ['parrot';'Hash']
  vivify_1648:
    set $P3659, $P3658["name"]
    unless_null $P3659, vivify_1649
    $P3659 = root_new ['parrot';'Hash']
  vivify_1649:
    set $P3660, $P3659["identifier"]
    unless_null $P3660, vivify_1650
    $P3660 = root_new ['parrot';'ResizablePMCArray']
  vivify_1650:
    set $P3661, $P3660[0]
    unless_null $P3661, vivify_1651
    new $P3661, "Undef"
  vivify_1651:
    find_dynamic_lex $P3662, "$*PKGMETA"
    unless_null $P3662, vivify_1652
    get_hll_global $P3662, "$PKGMETA"
    unless_null $P3662, vivify_1653
    die "Contextual $*PKGMETA not found"
  vivify_1653:
  vivify_1652:
    $P3655."install_lexical_symbol"($P3657, $P3661, $P3662)
  if_3642_end:
.annotate 'line', 1176
    goto if_3624_end
  if_3624:
.annotate 'line', 1173
    find_lex $P3633, "$past"
    find_lex $P3634, "$/"
    unless_null $P3634, vivify_1654
    $P3634 = root_new ['parrot';'Hash']
  vivify_1654:
    set $P3635, $P3634["name"]
    unless_null $P3635, vivify_1655
    $P3635 = root_new ['parrot';'Hash']
  vivify_1655:
    set $P3636, $P3635["identifier"]
    unless_null $P3636, vivify_1656
    new $P3636, "Undef"
  vivify_1656:
    $P3633."namespace"($P3636)
.annotate 'line', 1174
    find_dynamic_lex $P3637, "$*SC"
    unless_null $P3637, vivify_1657
    get_hll_global $P3637, "$SC"
    unless_null $P3637, vivify_1658
    die "Contextual $*SC not found"
  vivify_1658:
  vivify_1657:
    find_lex $P3638, "$/"
    unless_null $P3638, vivify_1659
    $P3638 = root_new ['parrot';'Hash']
  vivify_1659:
    set $P3639, $P3638["name"]
    unless_null $P3639, vivify_1660
    $P3639 = root_new ['parrot';'Hash']
  vivify_1660:
    set $P3640, $P3639["identifier"]
    unless_null $P3640, vivify_1661
    new $P3640, "Undef"
  vivify_1661:
    find_dynamic_lex $P3641, "$*PKGMETA"
    unless_null $P3641, vivify_1662
    get_hll_global $P3641, "$PKGMETA"
    unless_null $P3641, vivify_1663
    die "Contextual $*PKGMETA not found"
  vivify_1663:
  vivify_1662:
    $P3637."install_package_symbol"($P3640, $P3641)
  if_3624_end:
.annotate 'line', 1187
    find_dynamic_lex $P3667, "$*PACKAGE-SETUP"
    unless_null $P3667, vivify_1664
    get_hll_global $P3667, "$PACKAGE-SETUP"
    unless_null $P3667, vivify_1665
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1665:
  vivify_1664:
    get_hll_global $P3668, ["PAST"], "Stmts"
.annotate 'line', 1188
    get_hll_global $P3669, ["PAST"], "Op"
.annotate 'line', 1189
    get_hll_global $P3670, ["PAST"], "Var"
    $P3671 = $P3670."new"("type_obj" :named("name"), "register" :named("scope"), 1 :named("isdecl"))
.annotate 'line', 1190
    find_dynamic_lex $P3672, "$*SC"
    unless_null $P3672, vivify_1666
    get_hll_global $P3672, "$SC"
    unless_null $P3672, vivify_1667
    die "Contextual $*SC not found"
  vivify_1667:
  vivify_1666:
    find_dynamic_lex $P3673, "$*PKGMETA"
    unless_null $P3673, vivify_1668
    get_hll_global $P3673, "$PKGMETA"
    unless_null $P3673, vivify_1669
    die "Contextual $*PKGMETA not found"
  vivify_1669:
  vivify_1668:
    $P3674 = $P3672."get_slot_past_for_object"($P3673)
    $P3675 = $P3669."new"($P3671, $P3674, "bind" :named("pasttype"))
.annotate 'line', 1188
    $P3676 = $P3668."new"($P3675)
.annotate 'line', 1187
    $P3667."unshift"($P3676)
.annotate 'line', 1199
    find_lex $P3680, "$how"
    can $I3681, $P3680, "parametric"
    if $I3681, if_3679
    new $P3678, 'Integer'
    set $P3678, $I3681
    goto if_3679_end
  if_3679:
    find_lex $P3682, "$how"
    find_lex $P3683, "$how"
    $P3684 = $P3682."parametric"($P3683)
    set $P3678, $P3684
  if_3679_end:
    if $P3678, if_3677
.annotate 'line', 1215
    find_lex $P3702, "$past"
    $P3702."blocktype"("immediate")
.annotate 'line', 1216
    find_dynamic_lex $P3703, "$*SC"
    unless_null $P3703, vivify_1670
    get_hll_global $P3703, "$SC"
    unless_null $P3703, vivify_1671
    die "Contextual $*SC not found"
  vivify_1671:
  vivify_1670:
    find_lex $P3704, "$past"
    find_dynamic_lex $P3705, "$*PKGMETA"
    unless_null $P3705, vivify_1672
    get_hll_global $P3705, "$PKGMETA"
    unless_null $P3705, vivify_1673
    die "Contextual $*PKGMETA not found"
  vivify_1673:
  vivify_1672:
    $P3703."install_lexical_symbol"($P3704, "$?CLASS", $P3705)
.annotate 'line', 1214
    goto if_3677_end
  if_3677:
.annotate 'line', 1200
    find_lex $P3685, "$past"
    $P3685."blocktype"("declaration")
.annotate 'line', 1201
    find_lex $P3686, "$past"
    get_hll_global $P3687, ["PAST"], "Var"
    $P3688 = $P3687."new"("$?CLASS" :named("name"), "parameter" :named("scope"))
    $P3686."unshift"($P3688)
.annotate 'line', 1202
    find_lex $P3689, "$past"
    $P3689."symbol"("$?CLASS", "lexical" :named("scope"))
.annotate 'line', 1203
    find_dynamic_lex $P3690, "$*PACKAGE-SETUP"
    unless_null $P3690, vivify_1674
    get_hll_global $P3690, "$PACKAGE-SETUP"
    unless_null $P3690, vivify_1675
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1675:
  vivify_1674:
    get_hll_global $P3691, ["PAST"], "Op"
.annotate 'line', 1205
    get_hll_global $P3692, ["PAST"], "Op"
.annotate 'line', 1208
    get_hll_global $P3693, ["PAST"], "Var"
    $P3694 = $P3693."new"("type_obj" :named("name"), "register" :named("scope"))
    $P3695 = $P3692."new"($P3694, "get_how PP" :named("pirop"))
.annotate 'line', 1210
    get_hll_global $P3696, ["PAST"], "Var"
    $P3697 = $P3696."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1211
    get_hll_global $P3698, ["PAST"], "Val"
    find_lex $P3699, "$past"
    $P3700 = $P3698."new"($P3699 :named("value"))
    $P3701 = $P3691."new"($P3695, $P3697, $P3700, "callmethod" :named("pasttype"), "set_body_block" :named("name"))
.annotate 'line', 1203
    $P3690."push"($P3701)
  if_3677_end:
.annotate 'line', 1221
    find_lex $P3707, "$/"
    unless_null $P3707, vivify_1676
    $P3707 = root_new ['parrot';'Hash']
  vivify_1676:
    set $P3708, $P3707["parent"]
    unless_null $P3708, vivify_1677
    new $P3708, "Undef"
  vivify_1677:
    if $P3708, if_3706
.annotate 'line', 1235
    find_dynamic_lex $P3738, "$*PKGDECL"
    unless_null $P3738, vivify_1678
    get_hll_global $P3738, "$PKGDECL"
    unless_null $P3738, vivify_1679
    die "Contextual $*PKGDECL not found"
  vivify_1679:
  vivify_1678:
    set $S3739, $P3738
    iseq $I3740, $S3739, "grammar"
    unless $I3740, if_3737_end
.annotate 'line', 1236
    find_dynamic_lex $P3741, "$*PACKAGE-SETUP"
    unless_null $P3741, vivify_1680
    get_hll_global $P3741, "$PACKAGE-SETUP"
    unless_null $P3741, vivify_1681
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1681:
  vivify_1680:
    get_hll_global $P3742, ["PAST"], "Op"
.annotate 'line', 1238
    get_hll_global $P3743, ["PAST"], "Op"
.annotate 'line', 1241
    get_hll_global $P3744, ["PAST"], "Var"
    $P3745 = $P3744."new"("type_obj" :named("name"), "register" :named("scope"))
    $P3746 = $P3743."new"($P3745, "get_how PP" :named("pirop"))
.annotate 'line', 1243
    get_hll_global $P3747, ["PAST"], "Var"
    $P3748 = $P3747."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1244
    get_hll_global $P3749, ["PAST"], "Var"
    $P3750 = $P3749."new"("Cursor" :named("name"), "Regex" :named("namespace"), "package" :named("scope"))
    $P3751 = $P3742."new"($P3746, $P3748, $P3750, "callmethod" :named("pasttype"), "add_parent" :named("name"))
.annotate 'line', 1236
    $P3741."push"($P3751)
  if_3737_end:
.annotate 'line', 1235
    goto if_3706_end
  if_3706:
.annotate 'line', 1221
    .const 'Sub' $P3710 = "472_1302110486.758" 
    capture_lex $P3710
    $P3710()
  if_3706_end:
.annotate 'line', 1249
    find_lex $P3753, "$/"
    unless_null $P3753, vivify_1688
    $P3753 = root_new ['parrot';'Hash']
  vivify_1688:
    set $P3754, $P3753["role"]
    unless_null $P3754, vivify_1689
    new $P3754, "Undef"
  vivify_1689:
    unless $P3754, if_3752_end
.annotate 'line', 1250
    find_lex $P3756, "$/"
    unless_null $P3756, vivify_1690
    $P3756 = root_new ['parrot';'Hash']
  vivify_1690:
    set $P3757, $P3756["role"]
    unless_null $P3757, vivify_1691
    new $P3757, "Undef"
  vivify_1691:
    defined $I3758, $P3757
    unless $I3758, for_undef_1692
    iter $P3755, $P3757
    new $P3788, 'ExceptionHandler'
    set_label $P3788, loop3787_handler
    $P3788."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3788
  loop3787_test:
    unless $P3755, loop3787_done
    shift $P3759, $P3755
  loop3787_redo:
    .const 'Sub' $P3761 = "473_1302110486.758" 
    capture_lex $P3761
    $P3761($P3759)
  loop3787_next:
    goto loop3787_test
  loop3787_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3789, exception, 'type'
    eq $P3789, .CONTROL_LOOP_NEXT, loop3787_next
    eq $P3789, .CONTROL_LOOP_REDO, loop3787_redo
  loop3787_done:
    pop_eh 
  for_undef_1692:
  if_3752_end:
.annotate 'line', 1267
    find_dynamic_lex $P3790, "$*PACKAGE-SETUP"
    unless_null $P3790, vivify_1697
    get_hll_global $P3790, "$PACKAGE-SETUP"
    unless_null $P3790, vivify_1698
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1698:
  vivify_1697:
    get_hll_global $P3791, ["PAST"], "Op"
.annotate 'line', 1269
    get_hll_global $P3792, ["PAST"], "Op"
.annotate 'line', 1272
    get_hll_global $P3793, ["PAST"], "Var"
    $P3794 = $P3793."new"("type_obj" :named("name"), "register" :named("scope"))
    $P3795 = $P3792."new"($P3794, "get_how PP" :named("pirop"))
.annotate 'line', 1274
    get_hll_global $P3796, ["PAST"], "Var"
    $P3797 = $P3796."new"("type_obj" :named("name"), "register" :named("scope"))
    $P3798 = $P3791."new"($P3795, $P3797, "callmethod" :named("pasttype"), "compose" :named("name"))
.annotate 'line', 1267
    $P3790."push"($P3798)
.annotate 'line', 1278
    find_lex $P3799, "$past"
    $P3800 = $P3799."loadinit"()
    get_hll_global $P3801, ["PAST"], "Block"
    find_dynamic_lex $P3802, "$*PACKAGE-SETUP"
    unless_null $P3802, vivify_1699
    get_hll_global $P3802, "$PACKAGE-SETUP"
    unless_null $P3802, vivify_1700
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1700:
  vivify_1699:
    $P3803 = $P3801."new"($P3802, "immediate" :named("blocktype"))
    $P3800."push"($P3803)
.annotate 'line', 1280
    find_lex $P3804, "$/"
    find_lex $P3805, "$past"
    $P3806 = $P3804."!make"($P3805)
.annotate 'line', 1162
    .return ($P3806)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3709"  :anon :subid("472_1302110486.758") :outer("471_1302110486.758")
.annotate 'line', 1222
    $P3711 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P3711
.annotate 'line', 1223
    new $P3712, "Undef"
    .lex "$name", $P3712
.annotate 'line', 1222
    find_lex $P3713, "$/"
    unless_null $P3713, vivify_1682
    $P3713 = root_new ['parrot';'Hash']
  vivify_1682:
    set $P3714, $P3713["parent"]
    unless_null $P3714, vivify_1683
    $P3714 = root_new ['parrot';'ResizablePMCArray']
  vivify_1683:
    set $P3715, $P3714[0]
    unless_null $P3715, vivify_1684
    $P3715 = root_new ['parrot';'Hash']
  vivify_1684:
    set $P3716, $P3715["identifier"]
    unless_null $P3716, vivify_1685
    new $P3716, "Undef"
  vivify_1685:
    clone $P3717, $P3716
    store_lex "@ns", $P3717
.annotate 'line', 1223
    find_lex $P3718, "@ns"
    $P3719 = $P3718."pop"()
    set $S3720, $P3719
    new $P3721, 'String'
    set $P3721, $S3720
    store_lex "$name", $P3721
.annotate 'line', 1224
    find_dynamic_lex $P3722, "$*PACKAGE-SETUP"
    unless_null $P3722, vivify_1686
    get_hll_global $P3722, "$PACKAGE-SETUP"
    unless_null $P3722, vivify_1687
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1687:
  vivify_1686:
    get_hll_global $P3723, ["PAST"], "Op"
.annotate 'line', 1226
    get_hll_global $P3724, ["PAST"], "Op"
.annotate 'line', 1229
    get_hll_global $P3725, ["PAST"], "Var"
    $P3726 = $P3725."new"("type_obj" :named("name"), "register" :named("scope"))
    $P3727 = $P3724."new"($P3726, "get_how PP" :named("pirop"))
.annotate 'line', 1231
    get_hll_global $P3728, ["PAST"], "Var"
    $P3729 = $P3728."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1232
    get_hll_global $P3730, ["PAST"], "Var"
    find_lex $P3731, "$name"
    set $S3732, $P3731
    find_lex $P3733, "@ns"
    $P3734 = $P3730."new"($S3732 :named("name"), $P3733 :named("namespace"), "package" :named("scope"))
    $P3735 = $P3723."new"($P3727, $P3729, $P3734, "callmethod" :named("pasttype"), "add_parent" :named("name"))
.annotate 'line', 1224
    $P3736 = $P3722."push"($P3735)
.annotate 'line', 1221
    .return ($P3736)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3760"  :anon :subid("473_1302110486.758") :outer("471_1302110486.758")
    .param pmc param_3764
.annotate 'line', 1251
    $P3762 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P3762
.annotate 'line', 1252
    new $P3763, "Undef"
    .lex "$name", $P3763
    .lex "$_", param_3764
.annotate 'line', 1251
    find_lex $P3765, "$_"
    unless_null $P3765, vivify_1693
    $P3765 = root_new ['parrot';'Hash']
  vivify_1693:
    set $P3766, $P3765["identifier"]
    unless_null $P3766, vivify_1694
    new $P3766, "Undef"
  vivify_1694:
    clone $P3767, $P3766
    store_lex "@ns", $P3767
.annotate 'line', 1252
    find_lex $P3768, "@ns"
    $P3769 = $P3768."pop"()
    set $S3770, $P3769
    new $P3771, 'String'
    set $P3771, $S3770
    store_lex "$name", $P3771
.annotate 'line', 1253
    find_dynamic_lex $P3772, "$*PACKAGE-SETUP"
    unless_null $P3772, vivify_1695
    get_hll_global $P3772, "$PACKAGE-SETUP"
    unless_null $P3772, vivify_1696
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1696:
  vivify_1695:
    get_hll_global $P3773, ["PAST"], "Op"
.annotate 'line', 1255
    get_hll_global $P3774, ["PAST"], "Op"
.annotate 'line', 1258
    get_hll_global $P3775, ["PAST"], "Var"
    $P3776 = $P3775."new"("type_obj" :named("name"), "register" :named("scope"))
    $P3777 = $P3774."new"($P3776, "get_how PP" :named("pirop"))
.annotate 'line', 1260
    get_hll_global $P3778, ["PAST"], "Var"
    $P3779 = $P3778."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1261
    get_hll_global $P3780, ["PAST"], "Var"
    find_lex $P3781, "$name"
    set $S3782, $P3781
    find_lex $P3783, "@ns"
    $P3784 = $P3780."new"($S3782 :named("name"), $P3783 :named("namespace"), "package" :named("scope"))
    $P3785 = $P3773."new"($P3777, $P3779, $P3784, "callmethod" :named("pasttype"), "add_role" :named("name"))
.annotate 'line', 1253
    $P3786 = $P3772."push"($P3785)
.annotate 'line', 1250
    .return ($P3786)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<my>"  :subid("474_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_3808
    .param pmc param_3809
.annotate 'line', 1283
    .lex "self", param_3808
    .lex "$/", param_3809
    find_lex $P3810, "$/"
    find_lex $P3811, "$/"
    unless_null $P3811, vivify_1701
    $P3811 = root_new ['parrot';'Hash']
  vivify_1701:
    set $P3812, $P3811["scoped"]
    unless_null $P3812, vivify_1702
    new $P3812, "Undef"
  vivify_1702:
    $P3813 = $P3812."ast"()
    $P3814 = $P3810."!make"($P3813)
    .return ($P3814)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<our>"  :subid("475_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_3816
    .param pmc param_3817
.annotate 'line', 1284
    .lex "self", param_3816
    .lex "$/", param_3817
    find_lex $P3818, "$/"
    find_lex $P3819, "$/"
    unless_null $P3819, vivify_1703
    $P3819 = root_new ['parrot';'Hash']
  vivify_1703:
    set $P3820, $P3819["scoped"]
    unless_null $P3820, vivify_1704
    new $P3820, "Undef"
  vivify_1704:
    $P3821 = $P3820."ast"()
    $P3822 = $P3818."!make"($P3821)
    .return ($P3822)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<has>"  :subid("476_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_3824
    .param pmc param_3825
.annotate 'line', 1285
    .lex "self", param_3824
    .lex "$/", param_3825
    find_lex $P3826, "$/"
    find_lex $P3827, "$/"
    unless_null $P3827, vivify_1705
    $P3827 = root_new ['parrot';'Hash']
  vivify_1705:
    set $P3828, $P3827["scoped"]
    unless_null $P3828, vivify_1706
    new $P3828, "Undef"
  vivify_1706:
    $P3829 = $P3828."ast"()
    $P3830 = $P3826."!make"($P3829)
    .return ($P3830)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scoped"  :subid("477_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_3832
    .param pmc param_3833
.annotate 'line', 1287
    .lex "self", param_3832
    .lex "$/", param_3833
.annotate 'line', 1288
    find_lex $P3834, "$/"
    find_lex $P3837, "$/"
    unless_null $P3837, vivify_1707
    $P3837 = root_new ['parrot';'Hash']
  vivify_1707:
    set $P3838, $P3837["declarator"]
    unless_null $P3838, vivify_1708
    new $P3838, "Undef"
  vivify_1708:
    if $P3838, if_3836
.annotate 'line', 1289
    find_lex $P3844, "$/"
    unless_null $P3844, vivify_1709
    $P3844 = root_new ['parrot';'Hash']
  vivify_1709:
    set $P3845, $P3844["multi_declarator"]
    unless_null $P3845, vivify_1710
    new $P3845, "Undef"
  vivify_1710:
    if $P3845, if_3843
.annotate 'line', 1290
    find_lex $P3849, "$/"
    unless_null $P3849, vivify_1711
    $P3849 = root_new ['parrot';'Hash']
  vivify_1711:
    set $P3850, $P3849["package_declarator"]
    unless_null $P3850, vivify_1712
    new $P3850, "Undef"
  vivify_1712:
    $P3851 = $P3850."ast"()
    set $P3842, $P3851
.annotate 'line', 1289
    goto if_3843_end
  if_3843:
    find_lex $P3846, "$/"
    unless_null $P3846, vivify_1713
    $P3846 = root_new ['parrot';'Hash']
  vivify_1713:
    set $P3847, $P3846["multi_declarator"]
    unless_null $P3847, vivify_1714
    new $P3847, "Undef"
  vivify_1714:
    $P3848 = $P3847."ast"()
    set $P3842, $P3848
  if_3843_end:
    set $P3835, $P3842
.annotate 'line', 1288
    goto if_3836_end
  if_3836:
    find_lex $P3839, "$/"
    unless_null $P3839, vivify_1715
    $P3839 = root_new ['parrot';'Hash']
  vivify_1715:
    set $P3840, $P3839["declarator"]
    unless_null $P3840, vivify_1716
    new $P3840, "Undef"
  vivify_1716:
    $P3841 = $P3840."ast"()
    set $P3835, $P3841
  if_3836_end:
    $P3852 = $P3834."!make"($P3835)
.annotate 'line', 1287
    .return ($P3852)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "declarator"  :subid("478_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_3854
    .param pmc param_3855
.annotate 'line', 1293
    .lex "self", param_3854
    .lex "$/", param_3855
.annotate 'line', 1294
    find_lex $P3856, "$/"
.annotate 'line', 1295
    find_lex $P3859, "$/"
    unless_null $P3859, vivify_1717
    $P3859 = root_new ['parrot';'Hash']
  vivify_1717:
    set $P3860, $P3859["routine_declarator"]
    unless_null $P3860, vivify_1718
    new $P3860, "Undef"
  vivify_1718:
    if $P3860, if_3858
.annotate 'line', 1296
    find_lex $P3864, "$/"
    unless_null $P3864, vivify_1719
    $P3864 = root_new ['parrot';'Hash']
  vivify_1719:
    set $P3865, $P3864["variable_declarator"]
    unless_null $P3865, vivify_1720
    new $P3865, "Undef"
  vivify_1720:
    $P3866 = $P3865."ast"()
    set $P3857, $P3866
.annotate 'line', 1295
    goto if_3858_end
  if_3858:
    find_lex $P3861, "$/"
    unless_null $P3861, vivify_1721
    $P3861 = root_new ['parrot';'Hash']
  vivify_1721:
    set $P3862, $P3861["routine_declarator"]
    unless_null $P3862, vivify_1722
    new $P3862, "Undef"
  vivify_1722:
    $P3863 = $P3862."ast"()
    set $P3857, $P3863
  if_3858_end:
    $P3867 = $P3856."!make"($P3857)
.annotate 'line', 1293
    .return ($P3867)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<multi>"  :subid("479_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_3869
    .param pmc param_3870
.annotate 'line', 1299
    .lex "self", param_3869
    .lex "$/", param_3870
    find_lex $P3871, "$/"
    find_lex $P3874, "$/"
    unless_null $P3874, vivify_1723
    $P3874 = root_new ['parrot';'Hash']
  vivify_1723:
    set $P3875, $P3874["declarator"]
    unless_null $P3875, vivify_1724
    new $P3875, "Undef"
  vivify_1724:
    if $P3875, if_3873
    find_lex $P3879, "$/"
    unless_null $P3879, vivify_1725
    $P3879 = root_new ['parrot';'Hash']
  vivify_1725:
    set $P3880, $P3879["routine_def"]
    unless_null $P3880, vivify_1726
    new $P3880, "Undef"
  vivify_1726:
    $P3881 = $P3880."ast"()
    set $P3872, $P3881
    goto if_3873_end
  if_3873:
    find_lex $P3876, "$/"
    unless_null $P3876, vivify_1727
    $P3876 = root_new ['parrot';'Hash']
  vivify_1727:
    set $P3877, $P3876["declarator"]
    unless_null $P3877, vivify_1728
    new $P3877, "Undef"
  vivify_1728:
    $P3878 = $P3877."ast"()
    set $P3872, $P3878
  if_3873_end:
    $P3882 = $P3871."!make"($P3872)
    .return ($P3882)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<proto>"  :subid("480_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_3884
    .param pmc param_3885
.annotate 'line', 1300
    .lex "self", param_3884
    .lex "$/", param_3885
    find_lex $P3886, "$/"
    find_lex $P3889, "$/"
    unless_null $P3889, vivify_1729
    $P3889 = root_new ['parrot';'Hash']
  vivify_1729:
    set $P3890, $P3889["declarator"]
    unless_null $P3890, vivify_1730
    new $P3890, "Undef"
  vivify_1730:
    if $P3890, if_3888
    find_lex $P3894, "$/"
    unless_null $P3894, vivify_1731
    $P3894 = root_new ['parrot';'Hash']
  vivify_1731:
    set $P3895, $P3894["routine_def"]
    unless_null $P3895, vivify_1732
    new $P3895, "Undef"
  vivify_1732:
    $P3896 = $P3895."ast"()
    set $P3887, $P3896
    goto if_3888_end
  if_3888:
    find_lex $P3891, "$/"
    unless_null $P3891, vivify_1733
    $P3891 = root_new ['parrot';'Hash']
  vivify_1733:
    set $P3892, $P3891["declarator"]
    unless_null $P3892, vivify_1734
    new $P3892, "Undef"
  vivify_1734:
    $P3893 = $P3892."ast"()
    set $P3887, $P3893
  if_3888_end:
    $P3897 = $P3886."!make"($P3887)
    .return ($P3897)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<null>"  :subid("481_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_3899
    .param pmc param_3900
.annotate 'line', 1301
    .lex "self", param_3899
    .lex "$/", param_3900
    find_lex $P3901, "$/"
    find_lex $P3902, "$/"
    unless_null $P3902, vivify_1735
    $P3902 = root_new ['parrot';'Hash']
  vivify_1735:
    set $P3903, $P3902["declarator"]
    unless_null $P3903, vivify_1736
    new $P3903, "Undef"
  vivify_1736:
    $P3904 = $P3903."ast"()
    $P3905 = $P3901."!make"($P3904)
    .return ($P3905)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "variable_declarator"  :subid("482_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_3907
    .param pmc param_3908
.annotate 'line', 1304
    .const 'Sub' $P3980 = "485_1302110486.758" 
    capture_lex $P3980
    .const 'Sub' $P3935 = "483_1302110486.758" 
    capture_lex $P3935
    .lex "self", param_3907
    .lex "$/", param_3908
.annotate 'line', 1305
    new $P3909, "Undef"
    .lex "$past", $P3909
.annotate 'line', 1306
    new $P3910, "Undef"
    .lex "$sigil", $P3910
.annotate 'line', 1307
    new $P3911, "Undef"
    .lex "$name", $P3911
.annotate 'line', 1308
    new $P3912, "Undef"
    .lex "$BLOCK", $P3912
.annotate 'line', 1305
    find_lex $P3913, "$/"
    unless_null $P3913, vivify_1737
    $P3913 = root_new ['parrot';'Hash']
  vivify_1737:
    set $P3914, $P3913["variable"]
    unless_null $P3914, vivify_1738
    new $P3914, "Undef"
  vivify_1738:
    $P3915 = $P3914."ast"()
    store_lex "$past", $P3915
.annotate 'line', 1306
    find_lex $P3916, "$/"
    unless_null $P3916, vivify_1739
    $P3916 = root_new ['parrot';'Hash']
  vivify_1739:
    set $P3917, $P3916["variable"]
    unless_null $P3917, vivify_1740
    $P3917 = root_new ['parrot';'Hash']
  vivify_1740:
    set $P3918, $P3917["sigil"]
    unless_null $P3918, vivify_1741
    new $P3918, "Undef"
  vivify_1741:
    store_lex "$sigil", $P3918
.annotate 'line', 1307
    find_lex $P3919, "$past"
    $P3920 = $P3919."name"()
    store_lex "$name", $P3920
.annotate 'line', 1308
    get_global $P3921, "@BLOCK"
    unless_null $P3921, vivify_1742
    $P3921 = root_new ['parrot';'ResizablePMCArray']
  vivify_1742:
    set $P3922, $P3921[0]
    unless_null $P3922, vivify_1743
    new $P3922, "Undef"
  vivify_1743:
    store_lex "$BLOCK", $P3922
.annotate 'line', 1309
    find_lex $P3924, "$BLOCK"
    find_lex $P3925, "$name"
    $P3926 = $P3924."symbol"($P3925)
    unless $P3926, if_3923_end
.annotate 'line', 1310
    find_lex $P3927, "$/"
    $P3928 = $P3927."CURSOR"()
    find_lex $P3929, "$name"
    $P3928."panic"("Redeclaration of symbol ", $P3929)
  if_3923_end:
.annotate 'line', 1312
    find_dynamic_lex $P3931, "$*SCOPE"
    unless_null $P3931, vivify_1744
    get_hll_global $P3931, "$SCOPE"
    unless_null $P3931, vivify_1745
    die "Contextual $*SCOPE not found"
  vivify_1745:
  vivify_1744:
    set $S3932, $P3931
    iseq $I3933, $S3932, "has"
    if $I3933, if_3930
.annotate 'line', 1337
    .const 'Sub' $P3980 = "485_1302110486.758" 
    capture_lex $P3980
    $P3980()
    goto if_3930_end
  if_3930:
.annotate 'line', 1312
    .const 'Sub' $P3935 = "483_1302110486.758" 
    capture_lex $P3935
    $P3935()
  if_3930_end:
.annotate 'line', 1345
    find_lex $P4004, "$/"
    find_lex $P4005, "$past"
    $P4006 = $P4004."!make"($P4005)
.annotate 'line', 1304
    .return ($P4006)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3979"  :anon :subid("485_1302110486.758") :outer("482_1302110486.758")
.annotate 'line', 1338
    new $P3981, "Undef"
    .lex "$scope", $P3981
.annotate 'line', 1339
    new $P3982, "Undef"
    .lex "$decl", $P3982
.annotate 'line', 1338
    find_dynamic_lex $P3985, "$*SCOPE"
    unless_null $P3985, vivify_1746
    get_hll_global $P3985, "$SCOPE"
    unless_null $P3985, vivify_1747
    die "Contextual $*SCOPE not found"
  vivify_1747:
  vivify_1746:
    set $S3986, $P3985
    iseq $I3987, $S3986, "our"
    if $I3987, if_3984
    new $P3989, "String"
    assign $P3989, "lexical"
    set $P3983, $P3989
    goto if_3984_end
  if_3984:
    new $P3988, "String"
    assign $P3988, "package"
    set $P3983, $P3988
  if_3984_end:
    store_lex "$scope", $P3983
.annotate 'line', 1339
    get_hll_global $P3990, ["PAST"], "Var"
    find_lex $P3991, "$name"
    find_lex $P3992, "$scope"
.annotate 'line', 1340
    find_lex $P3993, "$sigil"
    $P3994 = "vivitype"($P3993)
    find_lex $P3995, "$/"
    $P3996 = $P3990."new"($P3991 :named("name"), $P3992 :named("scope"), 1 :named("isdecl"), 1 :named("lvalue"), $P3994 :named("viviself"), $P3995 :named("node"))
.annotate 'line', 1339
    store_lex "$decl", $P3996
.annotate 'line', 1342
    find_lex $P3997, "$BLOCK"
    find_lex $P3998, "$name"
    find_lex $P3999, "$scope"
    $P3997."symbol"($P3998, $P3999 :named("scope"))
.annotate 'line', 1343
    find_lex $P4000, "$BLOCK"
    unless_null $P4000, vivify_1748
    $P4000 = root_new ['parrot';'ResizablePMCArray']
  vivify_1748:
    set $P4001, $P4000[0]
    unless_null $P4001, vivify_1749
    new $P4001, "Undef"
  vivify_1749:
    find_lex $P4002, "$decl"
    $P4003 = $P4001."push"($P4002)
.annotate 'line', 1337
    .return ($P4003)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3934"  :anon :subid("483_1302110486.758") :outer("482_1302110486.758")
.annotate 'line', 1312
    .const 'Sub' $P3965 = "484_1302110486.758" 
    capture_lex $P3965
.annotate 'line', 1314
    new $P3936, "Undef"
    .lex "$meta-attr-type", $P3936
.annotate 'line', 1322
    new $P3937, "Undef"
    .lex "$meta_args", $P3937
.annotate 'line', 1314
    find_dynamic_lex $P3940, "$*PKGDECL"
    unless_null $P3940, vivify_1750
    get_hll_global $P3940, "$PKGDECL"
    unless_null $P3940, vivify_1751
    die "Contextual $*PKGDECL not found"
  vivify_1751:
  vivify_1750:
    find_dynamic_lex $P3941, "%*HOW-METAATTR"
    unless_null $P3941, vivify_1752
    get_hll_global $P3941, "%HOW-METAATTR"
    unless_null $P3941, vivify_1753
    die "Contextual %*HOW-METAATTR not found"
  vivify_1753:
  vivify_1752:
    set $P3942, $P3941[$P3940]
    unless_null $P3942, vivify_1754
    new $P3942, "Undef"
  vivify_1754:
    unless $P3942, unless_3939
    set $P3938, $P3942
    goto unless_3939_end
  unless_3939:
    find_dynamic_lex $P3943, "$*DEFAULT-METAATTR"
    unless_null $P3943, vivify_1755
    get_hll_global $P3943, "$DEFAULT-METAATTR"
    unless_null $P3943, vivify_1756
    die "Contextual $*DEFAULT-METAATTR not found"
  vivify_1756:
  vivify_1755:
    set $P3938, $P3943
  unless_3939_end:
    store_lex "$meta-attr-type", $P3938
.annotate 'line', 1315
    find_dynamic_lex $P3944, "$*PACKAGE-SETUP"
    unless_null $P3944, vivify_1757
    get_hll_global $P3944, "$PACKAGE-SETUP"
    unless_null $P3944, vivify_1758
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1758:
  vivify_1757:
    get_hll_global $P3945, ["PAST"], "Op"
.annotate 'line', 1317
    get_hll_global $P3946, ["PAST"], "Op"
.annotate 'line', 1319
    get_hll_global $P3947, ["PAST"], "Var"
    $P3948 = $P3947."new"("type_obj" :named("name"), "register" :named("scope"))
    $P3949 = $P3946."new"($P3948, "get_how PP" :named("pirop"))
.annotate 'line', 1321
    get_hll_global $P3950, ["PAST"], "Var"
    $P3951 = $P3950."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1322
    get_hll_global $P3952, ["PAST"], "Op"
.annotate 'line', 1324
    get_hll_global $P3953, ["PAST"], "Var"
    find_lex $P3954, "$meta-attr-type"
    $P3955 = $P3953."new"($P3954 :named("name"), "" :named("namespace"), "package" :named("scope"))
.annotate 'line', 1325
    get_hll_global $P3956, ["PAST"], "Val"
    find_lex $P3957, "$name"
    $P3958 = $P3956."new"($P3957 :named("value"), "name" :named("named"))
    $P3959 = $P3952."new"($P3955, $P3958, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 1322
    store_lex "$meta_args", $P3959
    $P3960 = $P3945."new"($P3949, $P3951, $P3959, "callmethod" :named("pasttype"), "add_attribute" :named("name"))
.annotate 'line', 1315
    $P3944."push"($P3960)
.annotate 'line', 1328
    find_lex $P3962, "$/"
    unless_null $P3962, vivify_1759
    $P3962 = root_new ['parrot';'Hash']
  vivify_1759:
    set $P3963, $P3962["typename"]
    unless_null $P3963, vivify_1760
    new $P3963, "Undef"
  vivify_1760:
    unless $P3963, if_3961_end
    .const 'Sub' $P3965 = "484_1302110486.758" 
    capture_lex $P3965
    $P3965()
  if_3961_end:
.annotate 'line', 1334
    find_lex $P3975, "$BLOCK"
    find_lex $P3976, "$name"
    $P3975."symbol"($P3976, "attribute" :named("scope"))
.annotate 'line', 1335
    get_hll_global $P3977, ["PAST"], "Stmts"
    $P3978 = $P3977."new"()
    store_lex "$past", $P3978
.annotate 'line', 1312
    .return ($P3978)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3964"  :anon :subid("484_1302110486.758") :outer("483_1302110486.758")
.annotate 'line', 1329
    new $P3966, "Undef"
    .lex "$type", $P3966
    find_lex $P3967, "$/"
    unless_null $P3967, vivify_1761
    $P3967 = root_new ['parrot';'Hash']
  vivify_1761:
    set $P3968, $P3967["typename"]
    unless_null $P3968, vivify_1762
    $P3968 = root_new ['parrot';'ResizablePMCArray']
  vivify_1762:
    set $P3969, $P3968[0]
    unless_null $P3969, vivify_1763
    new $P3969, "Undef"
  vivify_1763:
    $P3970 = $P3969."ast"()
    store_lex "$type", $P3970
.annotate 'line', 1330
    find_lex $P3971, "$type"
    $P3971."named"("type")
.annotate 'line', 1331
    find_lex $P3972, "$meta_args"
    find_lex $P3973, "$type"
    $P3974 = $P3972."push"($P3973)
.annotate 'line', 1328
    .return ($P3974)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<sub>"  :subid("486_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_4008
    .param pmc param_4009
.annotate 'line', 1348
    .lex "self", param_4008
    .lex "$/", param_4009
    find_lex $P4010, "$/"
    find_lex $P4011, "$/"
    unless_null $P4011, vivify_1764
    $P4011 = root_new ['parrot';'Hash']
  vivify_1764:
    set $P4012, $P4011["routine_def"]
    unless_null $P4012, vivify_1765
    new $P4012, "Undef"
  vivify_1765:
    $P4013 = $P4012."ast"()
    $P4014 = $P4010."!make"($P4013)
    .return ($P4014)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<method>"  :subid("487_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_4016
    .param pmc param_4017
.annotate 'line', 1349
    .lex "self", param_4016
    .lex "$/", param_4017
    find_lex $P4018, "$/"
    find_lex $P4019, "$/"
    unless_null $P4019, vivify_1766
    $P4019 = root_new ['parrot';'Hash']
  vivify_1766:
    set $P4020, $P4019["method_def"]
    unless_null $P4020, vivify_1767
    new $P4020, "Undef"
  vivify_1767:
    $P4021 = $P4020."ast"()
    $P4022 = $P4018."!make"($P4021)
    .return ($P4022)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "routine_def"  :subid("488_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_4024
    .param pmc param_4025
.annotate 'line', 1351
    .const 'Sub' $P4262 = "494_1302110486.758" 
    capture_lex $P4262
    .const 'Sub' $P4045 = "489_1302110486.758" 
    capture_lex $P4045
    .lex "self", param_4024
    .lex "$/", param_4025
.annotate 'line', 1354
    new $P4026, "Undef"
    .lex "$past", $P4026
.annotate 'line', 1365
    new $P4027, "Undef"
    .lex "$block", $P4027
.annotate 'line', 1351
    find_lex $P4028, "$past"
.annotate 'line', 1355
    find_lex $P4030, "$/"
    unless_null $P4030, vivify_1768
    $P4030 = root_new ['parrot';'Hash']
  vivify_1768:
    set $P4031, $P4030["onlystar"]
    unless_null $P4031, vivify_1769
    new $P4031, "Undef"
  vivify_1769:
    if $P4031, if_4029
.annotate 'line', 1359
    find_lex $P4033, "$/"
    unless_null $P4033, vivify_1770
    $P4033 = root_new ['parrot';'Hash']
  vivify_1770:
    set $P4034, $P4033["blockoid"]
    unless_null $P4034, vivify_1771
    new $P4034, "Undef"
  vivify_1771:
    $P4035 = $P4034."ast"()
    store_lex "$past", $P4035
.annotate 'line', 1360
    find_lex $P4036, "$past"
    $P4036."blocktype"("declaration")
.annotate 'line', 1361
    find_dynamic_lex $P4038, "$*RETURN_USED"
    unless_null $P4038, vivify_1772
    get_hll_global $P4038, "$RETURN_USED"
    unless_null $P4038, vivify_1773
    die "Contextual $*RETURN_USED not found"
  vivify_1773:
  vivify_1772:
    unless $P4038, if_4037_end
.annotate 'line', 1362
    find_lex $P4039, "$past"
    $P4039."control"("return_pir")
  if_4037_end:
.annotate 'line', 1358
    goto if_4029_end
  if_4029:
.annotate 'line', 1356
    $P4032 = "only_star_block"()
    store_lex "$past", $P4032
  if_4029_end:
.annotate 'line', 1365
    find_lex $P4040, "$past"
    store_lex "$block", $P4040
.annotate 'line', 1367
    find_lex $P4042, "$/"
    unless_null $P4042, vivify_1774
    $P4042 = root_new ['parrot';'Hash']
  vivify_1774:
    set $P4043, $P4042["deflongname"]
    unless_null $P4043, vivify_1775
    new $P4043, "Undef"
  vivify_1775:
    unless $P4043, if_4041_end
    .const 'Sub' $P4045 = "489_1302110486.758" 
    capture_lex $P4045
    $P4045()
  if_4041_end:
.annotate 'line', 1472
    find_lex $P4251, "$block"
    find_lex $P4252, "$past"
    unless_null $P4252, vivify_1838
    $P4252 = root_new ['parrot';'Hash']
    store_lex "$past", $P4252
  vivify_1838:
    set $P4252["block_past"], $P4251
.annotate 'line', 1473
    find_lex $P4254, "$/"
    unless_null $P4254, vivify_1839
    $P4254 = root_new ['parrot';'Hash']
  vivify_1839:
    set $P4255, $P4254["trait"]
    unless_null $P4255, vivify_1840
    new $P4255, "Undef"
  vivify_1840:
    unless $P4255, if_4253_end
.annotate 'line', 1474
    find_lex $P4257, "$/"
    unless_null $P4257, vivify_1841
    $P4257 = root_new ['parrot';'Hash']
  vivify_1841:
    set $P4258, $P4257["trait"]
    unless_null $P4258, vivify_1842
    new $P4258, "Undef"
  vivify_1842:
    defined $I4259, $P4258
    unless $I4259, for_undef_1843
    iter $P4256, $P4258
    new $P4269, 'ExceptionHandler'
    set_label $P4269, loop4268_handler
    $P4269."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4269
  loop4268_test:
    unless $P4256, loop4268_done
    shift $P4260, $P4256
  loop4268_redo:
    .const 'Sub' $P4262 = "494_1302110486.758" 
    capture_lex $P4262
    $P4262($P4260)
  loop4268_next:
    goto loop4268_test
  loop4268_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4270, exception, 'type'
    eq $P4270, .CONTROL_LOOP_NEXT, loop4268_next
    eq $P4270, .CONTROL_LOOP_REDO, loop4268_redo
  loop4268_done:
    pop_eh 
  for_undef_1843:
  if_4253_end:
.annotate 'line', 1477
    find_lex $P4271, "$/"
    find_lex $P4272, "$past"
    $P4273 = $P4271."!make"($P4272)
.annotate 'line', 1351
    .return ($P4273)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4044"  :anon :subid("489_1302110486.758") :outer("488_1302110486.758")
.annotate 'line', 1367
    .const 'Sub' $P4167 = "493_1302110486.758" 
    capture_lex $P4167
    .const 'Sub' $P4078 = "490_1302110486.758" 
    capture_lex $P4078
.annotate 'line', 1368
    new $P4046, "Undef"
    .lex "$name", $P4046
    find_lex $P4047, "$/"
    unless_null $P4047, vivify_1776
    $P4047 = root_new ['parrot';'Hash']
  vivify_1776:
    set $P4048, $P4047["sigil"]
    unless_null $P4048, vivify_1777
    $P4048 = root_new ['parrot';'ResizablePMCArray']
  vivify_1777:
    set $P4049, $P4048[0]
    unless_null $P4049, vivify_1778
    new $P4049, "Undef"
  vivify_1778:
    set $S4050, $P4049
    new $P4051, 'String'
    set $P4051, $S4050
    find_lex $P4052, "$/"
    unless_null $P4052, vivify_1779
    $P4052 = root_new ['parrot';'Hash']
  vivify_1779:
    set $P4053, $P4052["deflongname"]
    unless_null $P4053, vivify_1780
    $P4053 = root_new ['parrot';'ResizablePMCArray']
  vivify_1780:
    set $P4054, $P4053[0]
    unless_null $P4054, vivify_1781
    new $P4054, "Undef"
  vivify_1781:
    $S4055 = $P4054."ast"()
    concat $P4056, $P4051, $S4055
    store_lex "$name", $P4056
.annotate 'line', 1369
    find_lex $P4057, "$past"
    find_lex $P4058, "$name"
    $P4057."name"($P4058)
.annotate 'line', 1370
    find_dynamic_lex $P4064, "$*SCOPE"
    unless_null $P4064, vivify_1782
    get_hll_global $P4064, "$SCOPE"
    unless_null $P4064, vivify_1783
    die "Contextual $*SCOPE not found"
  vivify_1783:
  vivify_1782:
    set $S4065, $P4064
    iseq $I4066, $S4065, ""
    unless $I4066, unless_4063
    new $P4062, 'Integer'
    set $P4062, $I4066
    goto unless_4063_end
  unless_4063:
    find_dynamic_lex $P4067, "$*SCOPE"
    unless_null $P4067, vivify_1784
    get_hll_global $P4067, "$SCOPE"
    unless_null $P4067, vivify_1785
    die "Contextual $*SCOPE not found"
  vivify_1785:
  vivify_1784:
    set $S4068, $P4067
    iseq $I4069, $S4068, "my"
    new $P4062, 'Integer'
    set $P4062, $I4069
  unless_4063_end:
    unless $P4062, unless_4061
    set $P4060, $P4062
    goto unless_4061_end
  unless_4061:
    find_dynamic_lex $P4070, "$*SCOPE"
    unless_null $P4070, vivify_1786
    get_hll_global $P4070, "$SCOPE"
    unless_null $P4070, vivify_1787
    die "Contextual $*SCOPE not found"
  vivify_1787:
  vivify_1786:
    set $S4071, $P4070
    iseq $I4072, $S4071, "our"
    new $P4060, 'Integer'
    set $P4060, $I4072
  unless_4061_end:
    if $P4060, if_4059
.annotate 'line', 1462
    find_lex $P4236, "$/"
    $P4237 = $P4236."CURSOR"()
    find_dynamic_lex $P4238, "$*SCOPE"
    unless_null $P4238, vivify_1788
    get_hll_global $P4238, "$SCOPE"
    unless_null $P4238, vivify_1789
    die "Contextual $*SCOPE not found"
  vivify_1789:
  vivify_1788:
    concat $P4239, $P4238, " scoped routines are not supported yet"
    $P4237."panic"($P4239)
.annotate 'line', 1461
    goto if_4059_end
  if_4059:
.annotate 'line', 1371
    find_dynamic_lex $P4074, "$*MULTINESS"
    unless_null $P4074, vivify_1790
    get_hll_global $P4074, "$MULTINESS"
    unless_null $P4074, vivify_1791
    die "Contextual $*MULTINESS not found"
  vivify_1791:
  vivify_1790:
    set $S4075, $P4074
    iseq $I4076, $S4075, "multi"
    if $I4076, if_4073
.annotate 'line', 1422
    find_dynamic_lex $P4163, "$*MULTINESS"
    unless_null $P4163, vivify_1792
    get_hll_global $P4163, "$MULTINESS"
    unless_null $P4163, vivify_1793
    die "Contextual $*MULTINESS not found"
  vivify_1793:
  vivify_1792:
    set $S4164, $P4163
    iseq $I4165, $S4164, "proto"
    if $I4165, if_4162
.annotate 'line', 1441
    get_global $P4197, "@BLOCK"
    unless_null $P4197, vivify_1794
    $P4197 = root_new ['parrot';'ResizablePMCArray']
  vivify_1794:
    set $P4198, $P4197[0]
    unless_null $P4198, vivify_1795
    $P4198 = root_new ['parrot';'ResizablePMCArray']
  vivify_1795:
    set $P4199, $P4198[0]
    unless_null $P4199, vivify_1796
    new $P4199, "Undef"
  vivify_1796:
    get_hll_global $P4200, ["PAST"], "Var"
    find_lex $P4201, "$name"
    find_lex $P4202, "$past"
    $P4203 = $P4200."new"($P4201 :named("name"), 1 :named("isdecl"), $P4202 :named("viviself"), "lexical" :named("scope"))
    $P4199."push"($P4203)
.annotate 'line', 1443
    get_global $P4204, "@BLOCK"
    unless_null $P4204, vivify_1797
    $P4204 = root_new ['parrot';'ResizablePMCArray']
  vivify_1797:
    set $P4205, $P4204[0]
    unless_null $P4205, vivify_1798
    new $P4205, "Undef"
  vivify_1798:
    find_lex $P4206, "$name"
    $P4205."symbol"($P4206, "lexical" :named("scope"))
.annotate 'line', 1444
    find_dynamic_lex $P4208, "$*SCOPE"
    unless_null $P4208, vivify_1799
    get_hll_global $P4208, "$SCOPE"
    unless_null $P4208, vivify_1800
    die "Contextual $*SCOPE not found"
  vivify_1800:
  vivify_1799:
    set $S4209, $P4208
    iseq $I4210, $S4209, "our"
    unless $I4210, if_4207_end
.annotate 'line', 1447
    get_global $P4211, "@BLOCK"
    unless_null $P4211, vivify_1801
    $P4211 = root_new ['parrot';'ResizablePMCArray']
  vivify_1801:
    set $P4212, $P4211[0]
    unless_null $P4212, vivify_1802
    $P4212 = root_new ['parrot';'ResizablePMCArray']
  vivify_1802:
    set $P4213, $P4212[0]
    unless_null $P4213, vivify_1803
    new $P4213, "Undef"
  vivify_1803:
    get_hll_global $P4214, ["PAST"], "Op"
.annotate 'line', 1449
    get_hll_global $P4215, ["PAST"], "Var"
    find_lex $P4216, "$name"
    $P4217 = $P4215."new"($P4216 :named("name"), "package" :named("scope"))
.annotate 'line', 1450
    get_hll_global $P4218, ["PAST"], "Var"
    find_lex $P4219, "$name"
    $P4220 = $P4218."new"($P4219 :named("name"), "lexical" :named("scope"))
    $P4221 = $P4214."new"($P4217, $P4220, "bind" :named("pasttype"))
.annotate 'line', 1447
    $P4213."push"($P4221)
.annotate 'line', 1452
    get_global $P4222, "@BLOCK"
    unless_null $P4222, vivify_1804
    $P4222 = root_new ['parrot';'ResizablePMCArray']
  vivify_1804:
    set $P4223, $P4222[0]
    unless_null $P4223, vivify_1805
    new $P4223, "Undef"
  vivify_1805:
    $P4224 = $P4223."loadinit"()
    get_hll_global $P4225, ["PAST"], "Op"
.annotate 'line', 1454
    get_hll_global $P4226, ["PAST"], "Var"
    find_lex $P4227, "$name"
    $P4228 = $P4226."new"($P4227 :named("name"), "package" :named("scope"))
.annotate 'line', 1455
    get_hll_global $P4229, ["PAST"], "Val"
    find_lex $P4230, "$past"
    $P4231 = $P4229."new"($P4230 :named("value"))
    $P4232 = $P4225."new"($P4228, $P4231, "bind" :named("pasttype"))
.annotate 'line', 1452
    $P4224."push"($P4232)
  if_4207_end:
.annotate 'line', 1440
    goto if_4162_end
  if_4162:
.annotate 'line', 1422
    .const 'Sub' $P4167 = "493_1302110486.758" 
    capture_lex $P4167
    $P4167()
  if_4162_end:
    goto if_4073_end
  if_4073:
.annotate 'line', 1371
    .const 'Sub' $P4078 = "490_1302110486.758" 
    capture_lex $P4078
    $P4078()
  if_4073_end:
.annotate 'line', 1459
    get_hll_global $P4233, ["PAST"], "Var"
    find_lex $P4234, "$name"
    $P4235 = $P4233."new"($P4234 :named("name"))
    store_lex "$past", $P4235
  if_4059_end:
.annotate 'line', 1466
    find_lex $P4244, "$name"
    set $S4245, $P4244
    iseq $I4246, $S4245, "MAIN"
    if $I4246, if_4243
    new $P4242, 'Integer'
    set $P4242, $I4246
    goto if_4243_end
  if_4243:
    find_dynamic_lex $P4247, "$*MULTINESS"
    unless_null $P4247, vivify_1836
    get_hll_global $P4247, "$MULTINESS"
    unless_null $P4247, vivify_1837
    die "Contextual $*MULTINESS not found"
  vivify_1837:
  vivify_1836:
    set $S4248, $P4247
    isne $I4249, $S4248, "multi"
    new $P4242, 'Integer'
    set $P4242, $I4249
  if_4243_end:
    if $P4242, if_4241
    set $P4240, $P4242
    goto if_4241_end
  if_4241:
.annotate 'line', 1467
    find_lex $P4250, "$block"
    store_dynamic_lex "$*MAIN_SUB", $P4250
.annotate 'line', 1466
    set $P4240, $P4250
  if_4241_end:
.annotate 'line', 1367
    .return ($P4240)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4166"  :anon :subid("493_1302110486.758") :outer("489_1302110486.758")
.annotate 'line', 1427
    new $P4168, "Undef"
    .lex "$cholder", $P4168
.annotate 'line', 1426
    find_dynamic_lex $P4170, "$*SCOPE"
    unless_null $P4170, vivify_1806
    get_hll_global $P4170, "$SCOPE"
    unless_null $P4170, vivify_1807
    die "Contextual $*SCOPE not found"
  vivify_1807:
  vivify_1806:
    set $S4171, $P4170
    iseq $I4172, $S4171, "our"
    unless $I4172, if_4169_end
    die "our-scoped protos not yet implemented"
  if_4169_end:
.annotate 'line', 1427
    get_hll_global $P4173, ["PAST"], "Op"
    $P4174 = $P4173."new"("list" :named("pasttype"))
    store_lex "$cholder", $P4174
.annotate 'line', 1428
    get_global $P4175, "@BLOCK"
    unless_null $P4175, vivify_1808
    $P4175 = root_new ['parrot';'ResizablePMCArray']
  vivify_1808:
    set $P4176, $P4175[0]
    unless_null $P4176, vivify_1809
    $P4176 = root_new ['parrot';'ResizablePMCArray']
  vivify_1809:
    set $P4177, $P4176[0]
    unless_null $P4177, vivify_1810
    new $P4177, "Undef"
  vivify_1810:
    get_hll_global $P4178, ["PAST"], "Var"
    find_lex $P4179, "$name"
    find_lex $P4180, "$past"
    $P4181 = $P4178."new"($P4179 :named("name"), 1 :named("isdecl"), $P4180 :named("viviself"), "lexical" :named("scope"))
    $P4177."push"($P4181)
.annotate 'line', 1430
    get_global $P4182, "@BLOCK"
    unless_null $P4182, vivify_1811
    $P4182 = root_new ['parrot';'ResizablePMCArray']
  vivify_1811:
    set $P4183, $P4182[0]
    unless_null $P4183, vivify_1812
    $P4183 = root_new ['parrot';'ResizablePMCArray']
  vivify_1812:
    set $P4184, $P4183[0]
    unless_null $P4184, vivify_1813
    new $P4184, "Undef"
  vivify_1813:
    get_hll_global $P4185, ["PAST"], "Op"
.annotate 'line', 1432
    get_hll_global $P4186, ["PAST"], "Var"
    find_lex $P4187, "$name"
    $P4188 = $P4186."new"($P4187 :named("name"))
    find_lex $P4189, "$cholder"
    $P4190 = $P4185."new"($P4188, $P4189, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 1430
    $P4184."push"($P4190)
.annotate 'line', 1435
    get_global $P4191, "@BLOCK"
    unless_null $P4191, vivify_1814
    $P4191 = root_new ['parrot';'ResizablePMCArray']
  vivify_1814:
    set $P4192, $P4191[0]
    unless_null $P4192, vivify_1815
    new $P4192, "Undef"
  vivify_1815:
    find_lex $P4193, "$name"
    find_lex $P4194, "$cholder"
    $P4192."symbol"($P4193, "lexical" :named("scope"), 1 :named("proto"), $P4194 :named("cholder"))
.annotate 'line', 1438
    find_lex $P4195, "$past"
    $P4196 = $P4195."pirflags"(":instanceof(\"DispatcherSub\")")
.annotate 'line', 1422
    .return ($P4196)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4077"  :anon :subid("490_1302110486.758") :outer("489_1302110486.758")
.annotate 'line', 1371
    .const 'Sub' $P4096 = "491_1302110486.758" 
    capture_lex $P4096
.annotate 'line', 1374
    new $P4079, "Undef"
    .lex "$cholder", $P4079
.annotate 'line', 1375
    $P4080 = root_new ['parrot';'Hash']
    .lex "%sym", $P4080
.annotate 'line', 1373
    find_dynamic_lex $P4082, "$*SCOPE"
    unless_null $P4082, vivify_1816
    get_hll_global $P4082, "$SCOPE"
    unless_null $P4082, vivify_1817
    die "Contextual $*SCOPE not found"
  vivify_1817:
  vivify_1816:
    set $S4083, $P4082
    iseq $I4084, $S4083, "our"
    unless $I4084, if_4081_end
    die "our-scoped multis not yet implemented"
  if_4081_end:
    find_lex $P4085, "$cholder"
.annotate 'line', 1375
    get_global $P4086, "@BLOCK"
    unless_null $P4086, vivify_1818
    $P4086 = root_new ['parrot';'ResizablePMCArray']
  vivify_1818:
    set $P4087, $P4086[0]
    unless_null $P4087, vivify_1819
    new $P4087, "Undef"
  vivify_1819:
    find_lex $P4088, "$name"
    $P4089 = $P4087."symbol"($P4088)
    store_lex "%sym", $P4089
.annotate 'line', 1376
    find_lex $P4091, "%sym"
    unless_null $P4091, vivify_1820
    $P4091 = root_new ['parrot';'Hash']
  vivify_1820:
    set $P4092, $P4091["cholder"]
    unless_null $P4092, vivify_1821
    new $P4092, "Undef"
  vivify_1821:
    if $P4092, if_4090
.annotate 'line', 1381
    .const 'Sub' $P4096 = "491_1302110486.758" 
    capture_lex $P4096
    $P4096()
    goto if_4090_end
  if_4090:
.annotate 'line', 1377
    find_lex $P4093, "%sym"
    unless_null $P4093, vivify_1834
    $P4093 = root_new ['parrot';'Hash']
  vivify_1834:
    set $P4094, $P4093["cholder"]
    unless_null $P4094, vivify_1835
    new $P4094, "Undef"
  vivify_1835:
    store_lex "$cholder", $P4094
  if_4090_end:
.annotate 'line', 1417
    find_lex $P4158, "$cholder"
    find_lex $P4159, "$past"
    $P4158."push"($P4159)
.annotate 'line', 1420
    find_lex $P4160, "$past"
    $P4161 = "attach_multi_signature"($P4160)
.annotate 'line', 1371
    .return ($P4161)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block4095"  :anon :subid("491_1302110486.758") :outer("490_1302110486.758")
.annotate 'line', 1381
    .const 'Sub' $P4110 = "492_1302110486.758" 
    capture_lex $P4110
.annotate 'line', 1388
    new $P4097, "Undef"
    .lex "$found_proto", $P4097
.annotate 'line', 1406
    new $P4098, "Undef"
    .lex "$dispatch_setup", $P4098
.annotate 'line', 1383
    find_lex $P4100, "%sym"
    unless_null $P4100, vivify_1822
    $P4100 = root_new ['parrot';'Hash']
  vivify_1822:
    set $P4101, $P4100["proto"]
    unless_null $P4101, vivify_1823
    new $P4101, "Undef"
  vivify_1823:
    unless $P4101, if_4099_end
.annotate 'line', 1386
    find_lex $P4102, "$/"
    $P4103 = $P4102."CURSOR"()
    $P4103."panic"("Internal Error: Current scope has a proto, but no candidate list holder was set up. (This should never happen.)")
  if_4099_end:
.annotate 'line', 1383
    find_lex $P4104, "$found_proto"
.annotate 'line', 1389
    get_global $P4106, "@BLOCK"
    defined $I4107, $P4106
    unless $I4107, for_undef_1824
    iter $P4105, $P4106
    new $P4132, 'ExceptionHandler'
    set_label $P4132, loop4131_handler
    $P4132."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4132
  loop4131_test:
    unless $P4105, loop4131_done
    shift $P4108, $P4105
  loop4131_redo:
    .const 'Sub' $P4110 = "492_1302110486.758" 
    capture_lex $P4110
    $P4110($P4108)
  loop4131_next:
    goto loop4131_test
  loop4131_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4133, exception, 'type'
    eq $P4133, .CONTROL_LOOP_NEXT, loop4131_next
    eq $P4133, .CONTROL_LOOP_REDO, loop4131_redo
  loop4131_done:
    pop_eh 
  for_undef_1824:
.annotate 'line', 1400
    find_lex $P4135, "$found_proto"
    if $P4135, unless_4134_end
.annotate 'line', 1401
    find_lex $P4136, "$/"
    $P4137 = $P4136."CURSOR"()
    $P4137."panic"("Sorry, no proto sub in scope, and auto-generation of protos is not yet implemented.")
  unless_4134_end:
.annotate 'line', 1405
    get_hll_global $P4138, ["PAST"], "Op"
    $P4139 = $P4138."new"("list" :named("pasttype"))
    store_lex "$cholder", $P4139
.annotate 'line', 1406
    get_hll_global $P4140, ["PAST"], "Op"
.annotate 'line', 1408
    get_hll_global $P4141, ["PAST"], "Var"
    find_lex $P4142, "$name"
    $P4143 = $P4141."new"($P4142 :named("name"), "outer" :named("scope"))
    find_lex $P4144, "$cholder"
    $P4145 = $P4140."new"($P4143, $P4144, "create_dispatch_and_add_candidates PPP" :named("pirop"))
.annotate 'line', 1406
    store_lex "$dispatch_setup", $P4145
.annotate 'line', 1411
    get_global $P4146, "@BLOCK"
    unless_null $P4146, vivify_1829
    $P4146 = root_new ['parrot';'ResizablePMCArray']
  vivify_1829:
    set $P4147, $P4146[0]
    unless_null $P4147, vivify_1830
    $P4147 = root_new ['parrot';'ResizablePMCArray']
  vivify_1830:
    set $P4148, $P4147[0]
    unless_null $P4148, vivify_1831
    new $P4148, "Undef"
  vivify_1831:
    get_hll_global $P4149, ["PAST"], "Var"
    find_lex $P4150, "$name"
    find_lex $P4151, "$dispatch_setup"
    $P4152 = $P4149."new"($P4150 :named("name"), 1 :named("isdecl"), $P4151 :named("viviself"), "lexical" :named("scope"))
    $P4148."push"($P4152)
.annotate 'line', 1413
    get_global $P4153, "@BLOCK"
    unless_null $P4153, vivify_1832
    $P4153 = root_new ['parrot';'ResizablePMCArray']
  vivify_1832:
    set $P4154, $P4153[0]
    unless_null $P4154, vivify_1833
    new $P4154, "Undef"
  vivify_1833:
    find_lex $P4155, "$name"
    find_lex $P4156, "$cholder"
    $P4157 = $P4154."symbol"($P4155, "lexical" :named("scope"), $P4156 :named("cholder"))
.annotate 'line', 1381
    .return ($P4157)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4109"  :anon :subid("492_1302110486.758") :outer("491_1302110486.758")
    .param pmc param_4112
.annotate 'line', 1390
    $P4111 = root_new ['parrot';'Hash']
    .lex "%sym", $P4111
    .lex "$_", param_4112
    find_lex $P4113, "$_"
    find_lex $P4114, "$name"
    $P4115 = $P4113."symbol"($P4114)
    store_lex "%sym", $P4115
.annotate 'line', 1391
    find_lex $P4120, "%sym"
    unless_null $P4120, vivify_1825
    $P4120 = root_new ['parrot';'Hash']
  vivify_1825:
    set $P4121, $P4120["proto"]
    unless_null $P4121, vivify_1826
    new $P4121, "Undef"
  vivify_1826:
    unless $P4121, unless_4119
    set $P4118, $P4121
    goto unless_4119_end
  unless_4119:
    find_lex $P4122, "%sym"
    unless_null $P4122, vivify_1827
    $P4122 = root_new ['parrot';'Hash']
  vivify_1827:
    set $P4123, $P4122["cholder"]
    unless_null $P4123, vivify_1828
    new $P4123, "Undef"
  vivify_1828:
    set $P4118, $P4123
  unless_4119_end:
    if $P4118, if_4117
.annotate 'line', 1394
    find_lex $P4127, "%sym"
    if $P4127, if_4126
    set $P4125, $P4127
    goto if_4126_end
  if_4126:
.annotate 'line', 1395
    find_lex $P4128, "$/"
    $P4129 = $P4128."CURSOR"()
    $P4130 = $P4129."panic"("Cannot declare a multi when an only is already in scope.")
.annotate 'line', 1394
    set $P4125, $P4130
  if_4126_end:
    set $P4116, $P4125
.annotate 'line', 1391
    goto if_4117_end
  if_4117:
.annotate 'line', 1392
    new $P4124, "Integer"
    assign $P4124, 1
    store_lex "$found_proto", $P4124
.annotate 'line', 1391
    set $P4116, $P4124
  if_4117_end:
.annotate 'line', 1389
    .return ($P4116)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4261"  :anon :subid("494_1302110486.758") :outer("488_1302110486.758")
    .param pmc param_4263
.annotate 'line', 1474
    .lex "$_", param_4263
    find_lex $P4264, "$_"
    $P4265 = $P4264."ast"()
    find_lex $P4266, "$/"
    $P4267 = $P4265($P4266)
    .return ($P4267)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "method_def"  :subid("495_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_4275
    .param pmc param_4276
.annotate 'line', 1481
    .const 'Sub' $P4388 = "497_1302110486.758" 
    capture_lex $P4388
    .const 'Sub' $P4304 = "496_1302110486.758" 
    capture_lex $P4304
    .lex "self", param_4275
    .lex "$/", param_4276
.annotate 'line', 1484
    new $P4277, "Undef"
    .lex "$past", $P4277
.annotate 'line', 1481
    find_lex $P4278, "$past"
.annotate 'line', 1485
    find_lex $P4280, "$/"
    unless_null $P4280, vivify_1844
    $P4280 = root_new ['parrot';'Hash']
  vivify_1844:
    set $P4281, $P4280["onlystar"]
    unless_null $P4281, vivify_1845
    new $P4281, "Undef"
  vivify_1845:
    if $P4281, if_4279
.annotate 'line', 1489
    find_lex $P4283, "$/"
    unless_null $P4283, vivify_1846
    $P4283 = root_new ['parrot';'Hash']
  vivify_1846:
    set $P4284, $P4283["blockoid"]
    unless_null $P4284, vivify_1847
    new $P4284, "Undef"
  vivify_1847:
    $P4285 = $P4284."ast"()
    store_lex "$past", $P4285
.annotate 'line', 1490
    find_lex $P4286, "$past"
    $P4286."blocktype"("declaration")
.annotate 'line', 1491
    find_dynamic_lex $P4288, "$*RETURN_USED"
    unless_null $P4288, vivify_1848
    get_hll_global $P4288, "$RETURN_USED"
    unless_null $P4288, vivify_1849
    die "Contextual $*RETURN_USED not found"
  vivify_1849:
  vivify_1848:
    unless $P4288, if_4287_end
.annotate 'line', 1492
    find_lex $P4289, "$past"
    $P4289."control"("return_pir")
  if_4287_end:
.annotate 'line', 1488
    goto if_4279_end
  if_4279:
.annotate 'line', 1486
    $P4282 = "only_star_block"()
    store_lex "$past", $P4282
  if_4279_end:
.annotate 'line', 1497
    find_lex $P4291, "$past"
    unless_null $P4291, vivify_1850
    $P4291 = root_new ['parrot';'Hash']
  vivify_1850:
    set $P4292, $P4291["signature_has_invocant"]
    unless_null $P4292, vivify_1851
    new $P4292, "Undef"
  vivify_1851:
    if $P4292, unless_4290_end
.annotate 'line', 1498
    find_lex $P4293, "$past"
    unless_null $P4293, vivify_1852
    $P4293 = root_new ['parrot';'ResizablePMCArray']
  vivify_1852:
    set $P4294, $P4293[0]
    unless_null $P4294, vivify_1853
    new $P4294, "Undef"
  vivify_1853:
    get_hll_global $P4295, ["PAST"], "Var"
.annotate 'line', 1500
    get_hll_global $P4296, ["PAST"], "Var"
    $P4297 = $P4296."new"("$?CLASS" :named("name"))
    $P4298 = $P4295."new"("self" :named("name"), "parameter" :named("scope"), $P4297 :named("multitype"))
.annotate 'line', 1498
    $P4294."unshift"($P4298)
  unless_4290_end:
.annotate 'line', 1503
    find_lex $P4299, "$past"
    $P4299."symbol"("self", "lexical" :named("scope"))
.annotate 'line', 1506
    find_lex $P4301, "$/"
    unless_null $P4301, vivify_1854
    $P4301 = root_new ['parrot';'Hash']
  vivify_1854:
    set $P4302, $P4301["deflongname"]
    unless_null $P4302, vivify_1855
    new $P4302, "Undef"
  vivify_1855:
    unless $P4302, if_4300_end
    .const 'Sub' $P4304 = "496_1302110486.758" 
    capture_lex $P4304
    $P4304()
  if_4300_end:
.annotate 'line', 1541
    find_dynamic_lex $P4370, "$*SCOPE"
    unless_null $P4370, vivify_1873
    get_hll_global $P4370, "$SCOPE"
    unless_null $P4370, vivify_1874
    die "Contextual $*SCOPE not found"
  vivify_1874:
  vivify_1873:
    set $S4371, $P4370
    iseq $I4372, $S4371, "our"
    unless $I4372, if_4369_end
.annotate 'line', 1542
    find_lex $P4373, "$past"
    $P4373."pirflags"(":nsentry")
  if_4369_end:
.annotate 'line', 1546
    find_lex $P4374, "$/"
    find_lex $P4375, "$past"
    $P4374."!make"($P4375)
.annotate 'line', 1547
    find_lex $P4376, "$past"
    find_lex $P4377, "$past"
    unless_null $P4377, vivify_1875
    $P4377 = root_new ['parrot';'Hash']
    store_lex "$past", $P4377
  vivify_1875:
    set $P4377["block_past"], $P4376
.annotate 'line', 1548
    find_lex $P4380, "$/"
    unless_null $P4380, vivify_1876
    $P4380 = root_new ['parrot';'Hash']
  vivify_1876:
    set $P4381, $P4380["trait"]
    unless_null $P4381, vivify_1877
    new $P4381, "Undef"
  vivify_1877:
    if $P4381, if_4379
    set $P4378, $P4381
    goto if_4379_end
  if_4379:
.annotate 'line', 1549
    find_lex $P4383, "$/"
    unless_null $P4383, vivify_1878
    $P4383 = root_new ['parrot';'Hash']
  vivify_1878:
    set $P4384, $P4383["trait"]
    unless_null $P4384, vivify_1879
    new $P4384, "Undef"
  vivify_1879:
    defined $I4385, $P4384
    unless $I4385, for_undef_1880
    iter $P4382, $P4384
    new $P4395, 'ExceptionHandler'
    set_label $P4395, loop4394_handler
    $P4395."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4395
  loop4394_test:
    unless $P4382, loop4394_done
    shift $P4386, $P4382
  loop4394_redo:
    .const 'Sub' $P4388 = "497_1302110486.758" 
    capture_lex $P4388
    $P4388($P4386)
  loop4394_next:
    goto loop4394_test
  loop4394_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4396, exception, 'type'
    eq $P4396, .CONTROL_LOOP_NEXT, loop4394_next
    eq $P4396, .CONTROL_LOOP_REDO, loop4394_redo
  loop4394_done:
    pop_eh 
  for_undef_1880:
.annotate 'line', 1548
    set $P4378, $P4382
  if_4379_end:
.annotate 'line', 1481
    .return ($P4378)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4303"  :anon :subid("496_1302110486.758") :outer("495_1302110486.758")
.annotate 'line', 1508
    new $P4305, "Undef"
    .lex "$name", $P4305
.annotate 'line', 1513
    new $P4306, "Undef"
    .lex "$to_add", $P4306
.annotate 'line', 1508
    find_lex $P4307, "$/"
    unless_null $P4307, vivify_1856
    $P4307 = root_new ['parrot';'Hash']
  vivify_1856:
    set $P4308, $P4307["private"]
    unless_null $P4308, vivify_1857
    new $P4308, "Undef"
  vivify_1857:
    set $S4309, $P4308
    new $P4310, 'String'
    set $P4310, $S4309
    find_lex $P4311, "$/"
    unless_null $P4311, vivify_1858
    $P4311 = root_new ['parrot';'Hash']
  vivify_1858:
    set $P4312, $P4311["deflongname"]
    unless_null $P4312, vivify_1859
    $P4312 = root_new ['parrot';'ResizablePMCArray']
  vivify_1859:
    set $P4313, $P4312[0]
    unless_null $P4313, vivify_1860
    new $P4313, "Undef"
  vivify_1860:
    $P4314 = $P4313."ast"()
    set $S4315, $P4314
    concat $P4316, $P4310, $S4315
    store_lex "$name", $P4316
.annotate 'line', 1509
    find_lex $P4317, "$past"
    find_lex $P4318, "$name"
    $P4317."name"($P4318)
.annotate 'line', 1513
    find_dynamic_lex $P4321, "$*MULTINESS"
    unless_null $P4321, vivify_1861
    get_hll_global $P4321, "$MULTINESS"
    unless_null $P4321, vivify_1862
    die "Contextual $*MULTINESS not found"
  vivify_1862:
  vivify_1861:
    set $S4322, $P4321
    isne $I4323, $S4322, "proto"
    if $I4323, if_4320
.annotate 'line', 1515
    get_hll_global $P4327, ["PAST"], "Op"
.annotate 'line', 1517
    get_hll_global $P4328, ["PAST"], "Val"
    find_lex $P4329, "$past"
    $P4330 = $P4328."new"($P4329 :named("value"))
.annotate 'line', 1518
    get_hll_global $P4331, ["PAST"], "Op"
    $P4332 = $P4331."new"("list" :named("pasttype"))
    $P4333 = $P4327."new"($P4330, $P4332, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 1515
    set $P4319, $P4333
.annotate 'line', 1513
    goto if_4320_end
  if_4320:
.annotate 'line', 1514
    get_hll_global $P4324, ["PAST"], "Val"
    find_lex $P4325, "$past"
    $P4326 = $P4324."new"($P4325 :named("value"))
    set $P4319, $P4326
  if_4320_end:
.annotate 'line', 1513
    store_lex "$to_add", $P4319
.annotate 'line', 1520
    find_dynamic_lex $P4335, "$*MULTINESS"
    unless_null $P4335, vivify_1863
    get_hll_global $P4335, "$MULTINESS"
    unless_null $P4335, vivify_1864
    die "Contextual $*MULTINESS not found"
  vivify_1864:
  vivify_1863:
    set $S4336, $P4335
    iseq $I4337, $S4336, "proto"
    unless $I4337, if_4334_end
    find_lex $P4338, "$past"
    $P4338."pirflags"(":instanceof(\"DispatcherSub\")")
  if_4334_end:
.annotate 'line', 1524
    find_dynamic_lex $P4340, "$*MULTINESS"
    unless_null $P4340, vivify_1865
    get_hll_global $P4340, "$MULTINESS"
    unless_null $P4340, vivify_1866
    die "Contextual $*MULTINESS not found"
  vivify_1866:
  vivify_1865:
    set $S4341, $P4340
    iseq $I4342, $S4341, "multi"
    unless $I4342, if_4339_end
    find_lex $P4343, "$past"
    "attach_multi_signature"($P4343)
  if_4339_end:
.annotate 'line', 1527
    find_dynamic_lex $P4346, "$*PACKAGE-SETUP"
    unless_null $P4346, vivify_1867
    get_hll_global $P4346, "$PACKAGE-SETUP"
    unless_null $P4346, vivify_1868
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1868:
  vivify_1867:
    defined $I4347, $P4346
    if $I4347, if_4345
    new $P4344, 'Integer'
    set $P4344, $I4347
    goto if_4345_end
  if_4345:
.annotate 'line', 1528
    find_dynamic_lex $P4348, "$*PACKAGE-SETUP"
    unless_null $P4348, vivify_1869
    get_hll_global $P4348, "$PACKAGE-SETUP"
    unless_null $P4348, vivify_1870
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1870:
  vivify_1869:
    get_hll_global $P4349, ["PAST"], "Op"
.annotate 'line', 1529
    find_dynamic_lex $P4352, "$*MULTINESS"
    unless_null $P4352, vivify_1871
    get_hll_global $P4352, "$MULTINESS"
    unless_null $P4352, vivify_1872
    die "Contextual $*MULTINESS not found"
  vivify_1872:
  vivify_1871:
    set $S4353, $P4352
    iseq $I4354, $S4353, "multi"
    if $I4354, if_4351
    new $P4356, "String"
    assign $P4356, "add_method"
    set $P4350, $P4356
    goto if_4351_end
  if_4351:
    new $P4355, "String"
    assign $P4355, "add_multi_method"
    set $P4350, $P4355
  if_4351_end:
.annotate 'line', 1530
    get_hll_global $P4357, ["PAST"], "Op"
.annotate 'line', 1533
    get_hll_global $P4358, ["PAST"], "Var"
    $P4359 = $P4358."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4360 = $P4357."new"($P4359, "get_how PP" :named("pirop"))
.annotate 'line', 1535
    get_hll_global $P4361, ["PAST"], "Var"
    $P4362 = $P4361."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1536
    get_hll_global $P4363, ["PAST"], "Val"
    find_lex $P4364, "$name"
    $P4365 = $P4363."new"($P4364 :named("value"))
    find_lex $P4366, "$to_add"
    $P4367 = $P4349."new"($P4360, $P4362, $P4365, $P4366, "callmethod" :named("pasttype"), $P4350 :named("name"))
.annotate 'line', 1528
    $P4368 = $P4348."push"($P4367)
.annotate 'line', 1527
    set $P4344, $P4368
  if_4345_end:
.annotate 'line', 1506
    .return ($P4344)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4387"  :anon :subid("497_1302110486.758") :outer("495_1302110486.758")
    .param pmc param_4389
.annotate 'line', 1549
    .lex "$_", param_4389
    find_lex $P4390, "$_"
    $P4391 = $P4390."ast"()
    find_lex $P4392, "$/"
    $P4393 = $P4391($P4392)
    .return ($P4393)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "signature"  :subid("498_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_4400
    .param pmc param_4401
.annotate 'line', 1581
    .const 'Sub' $P4434 = "500_1302110486.758" 
    capture_lex $P4434
    .const 'Sub' $P4410 = "499_1302110486.758" 
    capture_lex $P4410
    .lex "self", param_4400
    .lex "$/", param_4401
.annotate 'line', 1582
    new $P4402, "Undef"
    .lex "$BLOCKINIT", $P4402
    get_global $P4403, "@BLOCK"
    unless_null $P4403, vivify_1881
    $P4403 = root_new ['parrot';'ResizablePMCArray']
  vivify_1881:
    set $P4404, $P4403[0]
    unless_null $P4404, vivify_1882
    $P4404 = root_new ['parrot';'ResizablePMCArray']
  vivify_1882:
    set $P4405, $P4404[0]
    unless_null $P4405, vivify_1883
    new $P4405, "Undef"
  vivify_1883:
    store_lex "$BLOCKINIT", $P4405
.annotate 'line', 1583
    find_lex $P4407, "$/"
    unless_null $P4407, vivify_1884
    $P4407 = root_new ['parrot';'Hash']
  vivify_1884:
    set $P4408, $P4407["invocant"]
    unless_null $P4408, vivify_1885
    new $P4408, "Undef"
  vivify_1885:
    unless $P4408, if_4406_end
    .const 'Sub' $P4410 = "499_1302110486.758" 
    capture_lex $P4410
    $P4410()
  if_4406_end:
.annotate 'line', 1592
    find_lex $P4429, "$/"
    unless_null $P4429, vivify_1891
    $P4429 = root_new ['parrot';'Hash']
  vivify_1891:
    set $P4430, $P4429["parameter"]
    unless_null $P4430, vivify_1892
    new $P4430, "Undef"
  vivify_1892:
    defined $I4431, $P4430
    unless $I4431, for_undef_1893
    iter $P4428, $P4430
    new $P4441, 'ExceptionHandler'
    set_label $P4441, loop4440_handler
    $P4441."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4441
  loop4440_test:
    unless $P4428, loop4440_done
    shift $P4432, $P4428
  loop4440_redo:
    .const 'Sub' $P4434 = "500_1302110486.758" 
    capture_lex $P4434
    $P4434($P4432)
  loop4440_next:
    goto loop4440_test
  loop4440_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4442, exception, 'type'
    eq $P4442, .CONTROL_LOOP_NEXT, loop4440_next
    eq $P4442, .CONTROL_LOOP_REDO, loop4440_redo
  loop4440_done:
    pop_eh 
  for_undef_1893:
.annotate 'line', 1581
    .return ($P4428)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4409"  :anon :subid("499_1302110486.758") :outer("498_1302110486.758")
.annotate 'line', 1584
    new $P4411, "Undef"
    .lex "$inv", $P4411
    find_lex $P4412, "$/"
    unless_null $P4412, vivify_1886
    $P4412 = root_new ['parrot';'Hash']
  vivify_1886:
    set $P4413, $P4412["invocant"]
    unless_null $P4413, vivify_1887
    $P4413 = root_new ['parrot';'ResizablePMCArray']
  vivify_1887:
    set $P4414, $P4413[0]
    unless_null $P4414, vivify_1888
    new $P4414, "Undef"
  vivify_1888:
    $P4415 = $P4414."ast"()
    store_lex "$inv", $P4415
.annotate 'line', 1585
    find_lex $P4416, "$BLOCKINIT"
    find_lex $P4417, "$inv"
    $P4416."push"($P4417)
.annotate 'line', 1586
    find_lex $P4418, "$BLOCKINIT"
    get_hll_global $P4419, ["PAST"], "Var"
.annotate 'line', 1588
    get_hll_global $P4420, ["PAST"], "Var"
    find_lex $P4421, "$inv"
    $P4422 = $P4421."name"()
    $P4423 = $P4420."new"("lexical" :named("scope"), $P4422 :named("name"))
    $P4424 = $P4419."new"("self" :named("name"), "lexical" :named("scope"), 1 :named("isdecl"), $P4423 :named("viviself"))
.annotate 'line', 1586
    $P4418."push"($P4424)
.annotate 'line', 1590
    new $P4425, "Integer"
    assign $P4425, 1
    get_global $P4426, "@BLOCK"
    unless_null $P4426, vivify_1889
    $P4426 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P4426
  vivify_1889:
    set $P4427, $P4426[0]
    unless_null $P4427, vivify_1890
    $P4427 = root_new ['parrot';'Hash']
    set $P4426[0], $P4427
  vivify_1890:
    set $P4427["signature_has_invocant"], $P4425
.annotate 'line', 1583
    .return ($P4425)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4433"  :anon :subid("500_1302110486.758") :outer("498_1302110486.758")
    .param pmc param_4435
.annotate 'line', 1592
    .lex "$_", param_4435
    find_lex $P4436, "$BLOCKINIT"
    find_lex $P4437, "$_"
    $P4438 = $P4437."ast"()
    $P4439 = $P4436."push"($P4438)
    .return ($P4439)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "parameter"  :subid("501_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_4444
    .param pmc param_4445
.annotate 'line', 1595
    .lex "self", param_4444
    .lex "$/", param_4445
.annotate 'line', 1596
    new $P4446, "Undef"
    .lex "$quant", $P4446
.annotate 'line', 1597
    new $P4447, "Undef"
    .lex "$past", $P4447
.annotate 'line', 1596
    find_lex $P4448, "$/"
    unless_null $P4448, vivify_1894
    $P4448 = root_new ['parrot';'Hash']
  vivify_1894:
    set $P4449, $P4448["quant"]
    unless_null $P4449, vivify_1895
    new $P4449, "Undef"
  vivify_1895:
    store_lex "$quant", $P4449
    find_lex $P4450, "$past"
.annotate 'line', 1598
    find_lex $P4452, "$/"
    unless_null $P4452, vivify_1896
    $P4452 = root_new ['parrot';'Hash']
  vivify_1896:
    set $P4453, $P4452["named_param"]
    unless_null $P4453, vivify_1897
    new $P4453, "Undef"
  vivify_1897:
    if $P4453, if_4451
.annotate 'line', 1605
    find_lex $P4467, "$/"
    unless_null $P4467, vivify_1898
    $P4467 = root_new ['parrot';'Hash']
  vivify_1898:
    set $P4468, $P4467["param_var"]
    unless_null $P4468, vivify_1899
    new $P4468, "Undef"
  vivify_1899:
    $P4469 = $P4468."ast"()
    store_lex "$past", $P4469
.annotate 'line', 1606
    find_lex $P4471, "$quant"
    set $S4472, $P4471
    iseq $I4473, $S4472, "*"
    if $I4473, if_4470
.annotate 'line', 1610
    find_lex $P4482, "$quant"
    set $S4483, $P4482
    iseq $I4484, $S4483, "?"
    unless $I4484, if_4481_end
.annotate 'line', 1611
    find_lex $P4485, "$past"
    find_lex $P4486, "$/"
    unless_null $P4486, vivify_1900
    $P4486 = root_new ['parrot';'Hash']
  vivify_1900:
    set $P4487, $P4486["param_var"]
    unless_null $P4487, vivify_1901
    $P4487 = root_new ['parrot';'Hash']
  vivify_1901:
    set $P4488, $P4487["sigil"]
    unless_null $P4488, vivify_1902
    new $P4488, "Undef"
  vivify_1902:
    $P4489 = "vivitype"($P4488)
    $P4485."viviself"($P4489)
  if_4481_end:
.annotate 'line', 1610
    goto if_4470_end
  if_4470:
.annotate 'line', 1607
    find_lex $P4474, "$past"
    $P4474."slurpy"(1)
.annotate 'line', 1608
    find_lex $P4475, "$past"
    find_lex $P4476, "$/"
    unless_null $P4476, vivify_1903
    $P4476 = root_new ['parrot';'Hash']
  vivify_1903:
    set $P4477, $P4476["param_var"]
    unless_null $P4477, vivify_1904
    $P4477 = root_new ['parrot';'Hash']
  vivify_1904:
    set $P4478, $P4477["sigil"]
    unless_null $P4478, vivify_1905
    new $P4478, "Undef"
  vivify_1905:
    set $S4479, $P4478
    iseq $I4480, $S4479, "%"
    $P4475."named"($I4480)
  if_4470_end:
.annotate 'line', 1604
    goto if_4451_end
  if_4451:
.annotate 'line', 1599
    find_lex $P4454, "$/"
    unless_null $P4454, vivify_1906
    $P4454 = root_new ['parrot';'Hash']
  vivify_1906:
    set $P4455, $P4454["named_param"]
    unless_null $P4455, vivify_1907
    new $P4455, "Undef"
  vivify_1907:
    $P4456 = $P4455."ast"()
    store_lex "$past", $P4456
.annotate 'line', 1600
    find_lex $P4458, "$quant"
    set $S4459, $P4458
    isne $I4460, $S4459, "!"
    unless $I4460, if_4457_end
.annotate 'line', 1601
    find_lex $P4461, "$past"
    find_lex $P4462, "$/"
    unless_null $P4462, vivify_1908
    $P4462 = root_new ['parrot';'Hash']
  vivify_1908:
    set $P4463, $P4462["named_param"]
    unless_null $P4463, vivify_1909
    $P4463 = root_new ['parrot';'Hash']
  vivify_1909:
    set $P4464, $P4463["param_var"]
    unless_null $P4464, vivify_1910
    $P4464 = root_new ['parrot';'Hash']
  vivify_1910:
    set $P4465, $P4464["sigil"]
    unless_null $P4465, vivify_1911
    new $P4465, "Undef"
  vivify_1911:
    $P4466 = "vivitype"($P4465)
    $P4461."viviself"($P4466)
  if_4457_end:
  if_4451_end:
.annotate 'line', 1614
    find_lex $P4491, "$/"
    unless_null $P4491, vivify_1912
    $P4491 = root_new ['parrot';'Hash']
  vivify_1912:
    set $P4492, $P4491["default_value"]
    unless_null $P4492, vivify_1913
    new $P4492, "Undef"
  vivify_1913:
    unless $P4492, if_4490_end
.annotate 'line', 1615
    find_lex $P4494, "$quant"
    set $S4495, $P4494
    iseq $I4496, $S4495, "*"
    unless $I4496, if_4493_end
.annotate 'line', 1616
    find_lex $P4497, "$/"
    $P4498 = $P4497."CURSOR"()
    $P4498."panic"("Can't put default on slurpy parameter")
  if_4493_end:
.annotate 'line', 1618
    find_lex $P4500, "$quant"
    set $S4501, $P4500
    iseq $I4502, $S4501, "!"
    unless $I4502, if_4499_end
.annotate 'line', 1619
    find_lex $P4503, "$/"
    $P4504 = $P4503."CURSOR"()
    $P4504."panic"("Can't put default on required parameter")
  if_4499_end:
.annotate 'line', 1621
    find_lex $P4505, "$past"
    find_lex $P4506, "$/"
    unless_null $P4506, vivify_1914
    $P4506 = root_new ['parrot';'Hash']
  vivify_1914:
    set $P4507, $P4506["default_value"]
    unless_null $P4507, vivify_1915
    $P4507 = root_new ['parrot';'ResizablePMCArray']
  vivify_1915:
    set $P4508, $P4507[0]
    unless_null $P4508, vivify_1916
    $P4508 = root_new ['parrot';'Hash']
  vivify_1916:
    set $P4509, $P4508["EXPR"]
    unless_null $P4509, vivify_1917
    new $P4509, "Undef"
  vivify_1917:
    $P4510 = $P4509."ast"()
    $P4505."viviself"($P4510)
  if_4490_end:
.annotate 'line', 1623
    find_lex $P4512, "$past"
    $P4513 = $P4512."viviself"()
    if $P4513, unless_4511_end
    get_global $P4514, "@BLOCK"
    unless_null $P4514, vivify_1918
    $P4514 = root_new ['parrot';'ResizablePMCArray']
  vivify_1918:
    set $P4515, $P4514[0]
    unless_null $P4515, vivify_1919
    new $P4515, "Undef"
  vivify_1919:
    get_global $P4516, "@BLOCK"
    unless_null $P4516, vivify_1920
    $P4516 = root_new ['parrot';'ResizablePMCArray']
  vivify_1920:
    set $P4517, $P4516[0]
    unless_null $P4517, vivify_1921
    new $P4517, "Undef"
  vivify_1921:
    $P4518 = $P4517."arity"()
    set $N4519, $P4518
    new $P4520, 'Float'
    set $P4520, $N4519
    add $P4521, $P4520, 1
    $P4515."arity"($P4521)
  unless_4511_end:
.annotate 'line', 1627
    find_lex $P4523, "$/"
    unless_null $P4523, vivify_1922
    $P4523 = root_new ['parrot';'Hash']
  vivify_1922:
    set $P4524, $P4523["typename"]
    unless_null $P4524, vivify_1923
    new $P4524, "Undef"
  vivify_1923:
    unless $P4524, if_4522_end
.annotate 'line', 1628
    find_lex $P4525, "$past"
    find_lex $P4526, "$/"
    unless_null $P4526, vivify_1924
    $P4526 = root_new ['parrot';'Hash']
  vivify_1924:
    set $P4527, $P4526["typename"]
    unless_null $P4527, vivify_1925
    $P4527 = root_new ['parrot';'ResizablePMCArray']
  vivify_1925:
    set $P4528, $P4527[0]
    unless_null $P4528, vivify_1926
    new $P4528, "Undef"
  vivify_1926:
    $P4529 = $P4528."ast"()
    $P4525."multitype"($P4529)
  if_4522_end:
.annotate 'line', 1632
    find_lex $P4531, "$/"
    unless_null $P4531, vivify_1927
    $P4531 = root_new ['parrot';'Hash']
  vivify_1927:
    set $P4532, $P4531["definedness"]
    unless_null $P4532, vivify_1928
    new $P4532, "Undef"
  vivify_1928:
    unless $P4532, if_4530_end
.annotate 'line', 1633
    find_lex $P4533, "$/"
    unless_null $P4533, vivify_1929
    $P4533 = root_new ['parrot';'Hash']
  vivify_1929:
    set $P4534, $P4533["definedness"]
    unless_null $P4534, vivify_1930
    $P4534 = root_new ['parrot';'ResizablePMCArray']
  vivify_1930:
    set $P4535, $P4534[0]
    unless_null $P4535, vivify_1931
    new $P4535, "Undef"
  vivify_1931:
    set $S4536, $P4535
    new $P4537, 'String'
    set $P4537, $S4536
    find_lex $P4538, "$past"
    unless_null $P4538, vivify_1932
    $P4538 = root_new ['parrot';'Hash']
    store_lex "$past", $P4538
  vivify_1932:
    set $P4538["definedness"], $P4537
  if_4530_end:
.annotate 'line', 1636
    find_lex $P4539, "$/"
    find_lex $P4540, "$past"
    $P4541 = $P4539."!make"($P4540)
.annotate 'line', 1595
    .return ($P4541)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "param_var"  :subid("502_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_4543
    .param pmc param_4544
.annotate 'line', 1639
    .lex "self", param_4543
    .lex "$/", param_4544
.annotate 'line', 1640
    new $P4545, "Undef"
    .lex "$name", $P4545
.annotate 'line', 1641
    new $P4546, "Undef"
    .lex "$past", $P4546
.annotate 'line', 1640
    find_lex $P4547, "$/"
    set $S4548, $P4547
    new $P4549, 'String'
    set $P4549, $S4548
    store_lex "$name", $P4549
.annotate 'line', 1641
    get_hll_global $P4550, ["PAST"], "Var"
    find_lex $P4551, "$name"
    find_lex $P4552, "$/"
    $P4553 = $P4550."new"($P4551 :named("name"), "parameter" :named("scope"), 1 :named("isdecl"), $P4552 :named("node"))
    store_lex "$past", $P4553
.annotate 'line', 1643
    get_global $P4554, "@BLOCK"
    unless_null $P4554, vivify_1933
    $P4554 = root_new ['parrot';'ResizablePMCArray']
  vivify_1933:
    set $P4555, $P4554[0]
    unless_null $P4555, vivify_1934
    new $P4555, "Undef"
  vivify_1934:
    find_lex $P4556, "$name"
    $P4555."symbol"($P4556, "lexical" :named("scope"))
.annotate 'line', 1644
    find_lex $P4557, "$/"
    find_lex $P4558, "$past"
    $P4559 = $P4557."!make"($P4558)
.annotate 'line', 1639
    .return ($P4559)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "named_param"  :subid("503_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_4561
    .param pmc param_4562
.annotate 'line', 1647
    .lex "self", param_4561
    .lex "$/", param_4562
.annotate 'line', 1648
    new $P4563, "Undef"
    .lex "$past", $P4563
    find_lex $P4564, "$/"
    unless_null $P4564, vivify_1935
    $P4564 = root_new ['parrot';'Hash']
  vivify_1935:
    set $P4565, $P4564["param_var"]
    unless_null $P4565, vivify_1936
    new $P4565, "Undef"
  vivify_1936:
    $P4566 = $P4565."ast"()
    store_lex "$past", $P4566
.annotate 'line', 1649
    find_lex $P4567, "$past"
    find_lex $P4568, "$/"
    unless_null $P4568, vivify_1937
    $P4568 = root_new ['parrot';'Hash']
  vivify_1937:
    set $P4569, $P4568["param_var"]
    unless_null $P4569, vivify_1938
    $P4569 = root_new ['parrot';'Hash']
  vivify_1938:
    set $P4570, $P4569["name"]
    unless_null $P4570, vivify_1939
    new $P4570, "Undef"
  vivify_1939:
    set $S4571, $P4570
    $P4567."named"($S4571)
.annotate 'line', 1650
    find_lex $P4572, "$/"
    find_lex $P4573, "$past"
    $P4574 = $P4572."!make"($P4573)
.annotate 'line', 1647
    .return ($P4574)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "typename"  :subid("504_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_4576
    .param pmc param_4577
.annotate 'line', 1653
    .lex "self", param_4576
    .lex "$/", param_4577
.annotate 'line', 1654
    $P4578 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P4578
    get_hll_global $P4579, ["HLL"], "Compiler"
    find_lex $P4580, "$/"
    set $S4581, $P4580
    $P4582 = $P4579."parse_name"($S4581)
    store_lex "@name", $P4582
.annotate 'line', 1655
    find_lex $P4583, "$/"
    get_hll_global $P4584, ["PAST"], "Var"
.annotate 'line', 1656
    find_lex $P4585, "@name"
    $P4586 = $P4585."pop"()
    find_lex $P4587, "@name"
    $P4588 = $P4584."new"($P4586 :named("name"), $P4587 :named("namespace"), "package" :named("scope"))
.annotate 'line', 1655
    $P4589 = $P4583."!make"($P4588)
.annotate 'line', 1653
    .return ($P4589)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait"  :subid("505_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_4591
    .param pmc param_4592
.annotate 'line', 1662
    .lex "self", param_4591
    .lex "$/", param_4592
.annotate 'line', 1663
    find_lex $P4593, "$/"
    find_lex $P4594, "$/"
    unless_null $P4594, vivify_1940
    $P4594 = root_new ['parrot';'Hash']
  vivify_1940:
    set $P4595, $P4594["trait_mod"]
    unless_null $P4595, vivify_1941
    new $P4595, "Undef"
  vivify_1941:
    $P4596 = $P4595."ast"()
    $P4597 = $P4593."!make"($P4596)
.annotate 'line', 1662
    .return ($P4597)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait_mod:sym<is>"  :subid("506_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_4599
    .param pmc param_4600
.annotate 'line', 1666
    .const 'Sub' $P4620 = "507_1302110486.758" 
    capture_lex $P4620
    .lex "self", param_4599
    .lex "$/", param_4600
.annotate 'line', 1667
    new $P4601, "Undef"
    .lex "$cpast", $P4601
    find_lex $P4602, "$/"
    unless_null $P4602, vivify_1942
    $P4602 = root_new ['parrot';'Hash']
  vivify_1942:
    set $P4603, $P4602["circumfix"]
    unless_null $P4603, vivify_1943
    $P4603 = root_new ['parrot';'ResizablePMCArray']
  vivify_1943:
    set $P4604, $P4603[0]
    unless_null $P4604, vivify_1944
    new $P4604, "Undef"
  vivify_1944:
    $P4605 = $P4604."ast"()
    store_lex "$cpast", $P4605
.annotate 'line', 1668
    find_lex $P4608, "$/"
    unless_null $P4608, vivify_1945
    $P4608 = root_new ['parrot';'Hash']
  vivify_1945:
    set $P4609, $P4608["longname"]
    unless_null $P4609, vivify_1946
    new $P4609, "Undef"
  vivify_1946:
    set $S4610, $P4609
    iseq $I4611, $S4610, "parrot_vtable"
    if $I4611, if_4607
.annotate 'line', 1688
    find_lex $P4646, "$/"
    unless_null $P4646, vivify_1947
    $P4646 = root_new ['parrot';'Hash']
  vivify_1947:
    set $P4647, $P4646["longname"]
    unless_null $P4647, vivify_1948
    new $P4647, "Undef"
  vivify_1948:
    set $S4648, $P4647
    iseq $I4649, $S4648, "pirflags"
    if $I4649, if_4645
.annotate 'line', 1692
    find_lex $P4653, "$/"
    $P4654 = $P4653."CURSOR"()
    new $P4655, 'String'
    set $P4655, "Trait '"
    find_lex $P4656, "$/"
    unless_null $P4656, vivify_1949
    $P4656 = root_new ['parrot';'Hash']
  vivify_1949:
    set $P4657, $P4656["longname"]
    unless_null $P4657, vivify_1950
    new $P4657, "Undef"
  vivify_1950:
    concat $P4658, $P4655, $P4657
    concat $P4659, $P4658, "' not implemented"
    $P4660 = $P4654."panic"($P4659)
.annotate 'line', 1691
    set $P4644, $P4660
.annotate 'line', 1688
    goto if_4645_end
  if_4645:
.annotate 'line', 1689
    find_lex $P4650, "$/"
    $P4651 = $P4650."CURSOR"()
    $P4652 = $P4651."panic"("Trait 'pirflags' no longer supported; use 'is vtable'")
.annotate 'line', 1688
    set $P4644, $P4652
  if_4645_end:
    set $P4606, $P4644
.annotate 'line', 1668
    goto if_4607_end
  if_4607:
.annotate 'line', 1671
    get_hll_global $P4613, ["PAST"], "Val"
    find_lex $P4614, "$cpast"
    $P4615 = $P4613."ACCEPTS"($P4614)
    if $P4615, unless_4612_end
.annotate 'line', 1670
    find_lex $P4616, "$/"
    $P4617 = $P4616."CURSOR"()
    $P4617."panic"("Trait 'parrot_vtable' requires constant scalar argument")
  unless_4612_end:
.annotate 'line', 1672
    find_lex $P4618, "$/"
    .const 'Sub' $P4620 = "507_1302110486.758" 
    newclosure $P4642, $P4620
    $P4643 = $P4618."!make"($P4642)
.annotate 'line', 1668
    set $P4606, $P4643
  if_4607_end:
.annotate 'line', 1666
    .return ($P4606)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4619"  :anon :subid("507_1302110486.758") :outer("506_1302110486.758")
    .param pmc param_4621
.annotate 'line', 1672
    .lex "$match", param_4621
.annotate 'line', 1673
    new $P4622, "Undef"
    .lex "$meth", $P4622
    find_lex $P4623, "$match"
    $P4624 = $P4623."ast"()
    set $P4625, $P4624["block_past"]
    unless_null $P4625, vivify_1951
    new $P4625, "Undef"
  vivify_1951:
    store_lex "$meth", $P4625
.annotate 'line', 1674
    find_dynamic_lex $P4628, "$*PACKAGE-SETUP"
    unless_null $P4628, vivify_1952
    get_hll_global $P4628, "$PACKAGE-SETUP"
    unless_null $P4628, vivify_1953
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1953:
  vivify_1952:
    defined $I4629, $P4628
    if $I4629, if_4627
    new $P4626, 'Integer'
    set $P4626, $I4629
    goto if_4627_end
  if_4627:
.annotate 'line', 1675
    find_dynamic_lex $P4630, "$*PACKAGE-SETUP"
    unless_null $P4630, vivify_1954
    get_hll_global $P4630, "$PACKAGE-SETUP"
    unless_null $P4630, vivify_1955
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1955:
  vivify_1954:
    get_hll_global $P4631, ["PAST"], "Op"
.annotate 'line', 1677
    get_hll_global $P4632, ["PAST"], "Op"
.annotate 'line', 1680
    get_hll_global $P4633, ["PAST"], "Var"
    $P4634 = $P4633."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4635 = $P4632."new"($P4634, "get_how PP" :named("pirop"))
.annotate 'line', 1682
    get_hll_global $P4636, ["PAST"], "Var"
    $P4637 = $P4636."new"("type_obj" :named("name"), "register" :named("scope"))
    find_lex $P4638, "$cpast"
    find_lex $P4639, "$meth"
    $P4640 = $P4631."new"($P4635, $P4637, $P4638, $P4639, "callmethod" :named("pasttype"), "add_parrot_vtable_mapping" :named("name"))
.annotate 'line', 1675
    $P4641 = $P4630."push"($P4640)
.annotate 'line', 1674
    set $P4626, $P4641
  if_4627_end:
.annotate 'line', 1672
    .return ($P4626)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "regex_declarator"  :subid("508_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_4664
    .param pmc param_4665
    .param pmc param_4666 :optional
    .param int has_param_4666 :opt_flag
.annotate 'line', 1696
    .const 'Sub' $P4764 = "511_1302110486.758" 
    capture_lex $P4764
    .const 'Sub' $P4736 = "510_1302110486.758" 
    capture_lex $P4736
    .const 'Sub' $P4709 = "509_1302110486.758" 
    capture_lex $P4709
    new $P4663, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P4663, control_4662
    push_eh $P4663
    .lex "self", param_4664
    .lex "$/", param_4665
    if has_param_4666, optparam_1956
    new $P4667, "Undef"
    set param_4666, $P4667
  optparam_1956:
    .lex "$key", param_4666
.annotate 'line', 1697
    $P4668 = root_new ['parrot';'ResizablePMCArray']
    .lex "@MODIFIERS", $P4668
.annotate 'line', 1700
    new $P4669, "Undef"
    .lex "$name", $P4669
.annotate 'line', 1701
    new $P4670, "Undef"
    .lex "$past", $P4670
.annotate 'line', 1697

            $P4671 = get_hll_global ['Regex';'P6Regex';'Actions'], '@MODIFIERS'
        
    store_lex "@MODIFIERS", $P4671
.annotate 'line', 1700
    find_lex $P4672, "$/"
    unless_null $P4672, vivify_1957
    $P4672 = root_new ['parrot';'Hash']
  vivify_1957:
    set $P4673, $P4672["deflongname"]
    unless_null $P4673, vivify_1958
    new $P4673, "Undef"
  vivify_1958:
    $P4674 = $P4673."ast"()
    set $S4675, $P4674
    new $P4676, 'String'
    set $P4676, $S4675
    store_lex "$name", $P4676
    find_lex $P4677, "$past"
.annotate 'line', 1702
    find_lex $P4679, "$/"
    unless_null $P4679, vivify_1959
    $P4679 = root_new ['parrot';'Hash']
  vivify_1959:
    set $P4680, $P4679["proto"]
    unless_null $P4680, vivify_1960
    new $P4680, "Undef"
  vivify_1960:
    if $P4680, if_4678
.annotate 'line', 1741
    find_lex $P4732, "$key"
    set $S4733, $P4732
    iseq $I4734, $S4733, "open"
    if $I4734, if_4731
.annotate 'line', 1754
    .const 'Sub' $P4764 = "511_1302110486.758" 
    capture_lex $P4764
    $P4764()
    goto if_4731_end
  if_4731:
.annotate 'line', 1741
    .const 'Sub' $P4736 = "510_1302110486.758" 
    capture_lex $P4736
    $P4736()
  if_4731_end:
    goto if_4678_end
  if_4678:
.annotate 'line', 1704
    get_hll_global $P4681, ["PAST"], "Stmts"
.annotate 'line', 1705
    get_hll_global $P4682, ["PAST"], "Block"
    find_lex $P4683, "$name"
.annotate 'line', 1706
    get_hll_global $P4684, ["PAST"], "Op"
.annotate 'line', 1707
    get_hll_global $P4685, ["PAST"], "Var"
    $P4686 = $P4685."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P4687, "$name"
    $P4688 = $P4684."new"($P4686, $P4687, "!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 1706
    find_lex $P4689, "$/"
    $P4690 = $P4682."new"($P4688, $P4683 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P4689 :named("node"))
.annotate 'line', 1716
    get_hll_global $P4691, ["PAST"], "Block"
    new $P4692, "String"
    assign $P4692, "!PREFIX__"
    find_lex $P4693, "$name"
    concat $P4694, $P4692, $P4693
.annotate 'line', 1717
    get_hll_global $P4695, ["PAST"], "Op"
.annotate 'line', 1718
    get_hll_global $P4696, ["PAST"], "Var"
    $P4697 = $P4696."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P4698, "$name"
    $P4699 = $P4695."new"($P4697, $P4698, "!PREFIX__!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 1717
    find_lex $P4700, "$/"
    $P4701 = $P4691."new"($P4699, $P4694 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P4700 :named("node"))
.annotate 'line', 1716
    $P4702 = $P4681."new"($P4690, $P4701)
.annotate 'line', 1704
    store_lex "$past", $P4702
.annotate 'line', 1728
    find_lex $P4704, "$past"
    $P4705 = $P4704."list"()
    defined $I4706, $P4705
    unless $I4706, for_undef_1981
    iter $P4703, $P4705
    new $P4729, 'ExceptionHandler'
    set_label $P4729, loop4728_handler
    $P4729."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4729
  loop4728_test:
    unless $P4703, loop4728_done
    shift $P4707, $P4703
  loop4728_redo:
    .const 'Sub' $P4709 = "509_1302110486.758" 
    capture_lex $P4709
    $P4709($P4707)
  loop4728_next:
    goto loop4728_test
  loop4728_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4730, exception, 'type'
    eq $P4730, .CONTROL_LOOP_NEXT, loop4728_next
    eq $P4730, .CONTROL_LOOP_REDO, loop4728_redo
  loop4728_done:
    pop_eh 
  for_undef_1981:
  if_4678_end:
.annotate 'line', 1790
    find_lex $P4822, "$/"
    find_lex $P4823, "$past"
    $P4824 = $P4822."!make"($P4823)
.annotate 'line', 1696
    .return ($P4824)
  control_4662:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4825, exception, "payload"
    .return ($P4825)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4763"  :anon :subid("511_1302110486.758") :outer("508_1302110486.758")
.annotate 'line', 1755
    new $P4765, "Undef"
    .lex "$regex", $P4765
.annotate 'line', 1756
    get_hll_global $P4766, ["Regex";"P6Regex";"Actions"], "buildsub"
    find_lex $P4767, "$/"
    unless_null $P4767, vivify_1961
    $P4767 = root_new ['parrot';'Hash']
  vivify_1961:
    set $P4768, $P4767["p6regex"]
    unless_null $P4768, vivify_1962
    new $P4768, "Undef"
  vivify_1962:
    $P4769 = $P4768."ast"()
    get_global $P4770, "@BLOCK"
    $P4771 = $P4770."shift"()
    $P4772 = $P4766($P4769, $P4771)
    store_lex "$regex", $P4772
.annotate 'line', 1757
    find_lex $P4773, "$regex"
    find_lex $P4774, "$name"
    $P4773."name"($P4774)
.annotate 'line', 1759
    get_hll_global $P4775, ["PAST"], "Op"
.annotate 'line', 1761
    get_hll_global $P4776, ["PAST"], "Var"
    new $P4777, "ResizablePMCArray"
    push $P4777, "Regex"
    $P4778 = $P4776."new"("Method" :named("name"), $P4777 :named("namespace"), "package" :named("scope"))
    find_lex $P4779, "$regex"
    $P4780 = $P4775."new"($P4778, $P4779, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 1759
    store_lex "$past", $P4780
.annotate 'line', 1764
    find_dynamic_lex $P4782, "$*PACKAGE-SETUP"
    unless_null $P4782, vivify_1963
    get_hll_global $P4782, "$PACKAGE-SETUP"
    unless_null $P4782, vivify_1964
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1964:
  vivify_1963:
    defined $I4783, $P4782
    unless $I4783, if_4781_end
.annotate 'line', 1765
    find_dynamic_lex $P4784, "$*PACKAGE-SETUP"
    unless_null $P4784, vivify_1965
    get_hll_global $P4784, "$PACKAGE-SETUP"
    unless_null $P4784, vivify_1966
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1966:
  vivify_1965:
    get_hll_global $P4785, ["PAST"], "Op"
.annotate 'line', 1767
    get_hll_global $P4786, ["PAST"], "Op"
.annotate 'line', 1769
    get_hll_global $P4787, ["PAST"], "Var"
    $P4788 = $P4787."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4789 = $P4786."new"($P4788, "get_how PP" :named("pirop"))
.annotate 'line', 1771
    get_hll_global $P4790, ["PAST"], "Var"
    $P4791 = $P4790."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1772
    get_hll_global $P4792, ["PAST"], "Val"
    find_lex $P4793, "$name"
    $P4794 = $P4792."new"($P4793 :named("value"))
.annotate 'line', 1773
    get_hll_global $P4795, ["PAST"], "Val"
    find_lex $P4796, "$regex"
    $P4797 = $P4795."new"($P4796 :named("value"))
    $P4798 = $P4785."new"($P4789, $P4791, $P4794, $P4797, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 1765
    $P4784."push"($P4798)
.annotate 'line', 1775
    find_dynamic_lex $P4799, "$*PACKAGE-SETUP"
    unless_null $P4799, vivify_1967
    get_hll_global $P4799, "$PACKAGE-SETUP"
    unless_null $P4799, vivify_1968
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1968:
  vivify_1967:
    get_hll_global $P4800, ["PAST"], "Op"
.annotate 'line', 1777
    get_hll_global $P4801, ["PAST"], "Op"
.annotate 'line', 1779
    get_hll_global $P4802, ["PAST"], "Var"
    $P4803 = $P4802."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4804 = $P4801."new"($P4803, "get_how PP" :named("pirop"))
.annotate 'line', 1781
    get_hll_global $P4805, ["PAST"], "Var"
    $P4806 = $P4805."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1782
    get_hll_global $P4807, ["PAST"], "Val"
    new $P4808, "String"
    assign $P4808, "!PREFIX__"
    find_lex $P4809, "$name"
    concat $P4810, $P4808, $P4809
    $P4811 = $P4807."new"($P4810 :named("value"))
.annotate 'line', 1783
    get_hll_global $P4812, ["PAST"], "Var"
    new $P4813, "String"
    assign $P4813, "!PREFIX__"
    find_lex $P4814, "$name"
    concat $P4815, $P4813, $P4814
    $P4816 = $P4812."new"($P4815 :named("name"), "package" :named("scope"))
    $P4817 = $P4800."new"($P4804, $P4806, $P4811, $P4816, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 1775
    $P4799."push"($P4817)
  if_4781_end:
.annotate 'line', 1787
    find_lex $P4818, "$regex"
    find_lex $P4819, "$past"
    unless_null $P4819, vivify_1969
    $P4819 = root_new ['parrot';'Hash']
    store_lex "$past", $P4819
  vivify_1969:
    set $P4819["sink"], $P4818
.annotate 'line', 1788
    find_lex $P4820, "@MODIFIERS"
    $P4821 = $P4820."shift"()
.annotate 'line', 1754
    .return ($P4821)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block4735"  :anon :subid("510_1302110486.758") :outer("508_1302110486.758")
.annotate 'line', 1742
    $P4737 = root_new ['parrot';'Hash']
    .lex "%h", $P4737
.annotate 'line', 1741
    find_lex $P4738, "%h"
.annotate 'line', 1743
    find_lex $P4740, "$/"
    unless_null $P4740, vivify_1970
    $P4740 = root_new ['parrot';'Hash']
  vivify_1970:
    set $P4741, $P4740["sym"]
    unless_null $P4741, vivify_1971
    new $P4741, "Undef"
  vivify_1971:
    set $S4742, $P4741
    iseq $I4743, $S4742, "token"
    unless $I4743, if_4739_end
    new $P4744, "Integer"
    assign $P4744, 1
    find_lex $P4745, "%h"
    unless_null $P4745, vivify_1972
    $P4745 = root_new ['parrot';'Hash']
    store_lex "%h", $P4745
  vivify_1972:
    set $P4745["r"], $P4744
  if_4739_end:
.annotate 'line', 1744
    find_lex $P4747, "$/"
    unless_null $P4747, vivify_1973
    $P4747 = root_new ['parrot';'Hash']
  vivify_1973:
    set $P4748, $P4747["sym"]
    unless_null $P4748, vivify_1974
    new $P4748, "Undef"
  vivify_1974:
    set $S4749, $P4748
    iseq $I4750, $S4749, "rule"
    unless $I4750, if_4746_end
    new $P4751, "Integer"
    assign $P4751, 1
    find_lex $P4752, "%h"
    unless_null $P4752, vivify_1975
    $P4752 = root_new ['parrot';'Hash']
    store_lex "%h", $P4752
  vivify_1975:
    set $P4752["r"], $P4751
    new $P4753, "Integer"
    assign $P4753, 1
    find_lex $P4754, "%h"
    unless_null $P4754, vivify_1976
    $P4754 = root_new ['parrot';'Hash']
    store_lex "%h", $P4754
  vivify_1976:
    set $P4754["s"], $P4753
  if_4746_end:
.annotate 'line', 1745
    find_lex $P4755, "@MODIFIERS"
    find_lex $P4756, "%h"
    $P4755."unshift"($P4756)
.annotate 'line', 1746

                $P0 = find_lex '$name'
                set_hll_global ['Regex';'P6Regex';'Actions'], '$REGEXNAME', $P0
            
.annotate 'line', 1750
    get_global $P4757, "@BLOCK"
    unless_null $P4757, vivify_1977
    $P4757 = root_new ['parrot';'ResizablePMCArray']
  vivify_1977:
    set $P4758, $P4757[0]
    unless_null $P4758, vivify_1978
    new $P4758, "Undef"
  vivify_1978:
    $P4758."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 1751
    get_global $P4759, "@BLOCK"
    unless_null $P4759, vivify_1979
    $P4759 = root_new ['parrot';'ResizablePMCArray']
  vivify_1979:
    set $P4760, $P4759[0]
    unless_null $P4760, vivify_1980
    new $P4760, "Undef"
  vivify_1980:
    $P4760."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 1752
    new $P4761, "Exception"
    set $P4761['type'], .CONTROL_RETURN
    new $P4762, "Integer"
    assign $P4762, 0
    setattribute $P4761, 'payload', $P4762
    throw $P4761
.annotate 'line', 1741
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4708"  :anon :subid("509_1302110486.758") :outer("508_1302110486.758")
    .param pmc param_4710
.annotate 'line', 1728
    .lex "$_", param_4710
.annotate 'line', 1729
    find_dynamic_lex $P4711, "$*PACKAGE-SETUP"
    unless_null $P4711, vivify_1982
    get_hll_global $P4711, "$PACKAGE-SETUP"
    unless_null $P4711, vivify_1983
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1983:
  vivify_1982:
    get_hll_global $P4712, ["PAST"], "Op"
.annotate 'line', 1731
    get_hll_global $P4713, ["PAST"], "Op"
.annotate 'line', 1733
    get_hll_global $P4714, ["PAST"], "Var"
    $P4715 = $P4714."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4716 = $P4713."new"($P4715, "get_how PP" :named("pirop"))
.annotate 'line', 1735
    get_hll_global $P4717, ["PAST"], "Var"
    $P4718 = $P4717."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1736
    get_hll_global $P4719, ["PAST"], "Val"
    find_lex $P4720, "$_"
    $P4721 = $P4720."name"()
    $P4722 = $P4719."new"($P4721 :named("value"))
.annotate 'line', 1737
    get_hll_global $P4723, ["PAST"], "Val"
    find_lex $P4724, "$_"
    $P4725 = $P4723."new"($P4724 :named("value"))
    $P4726 = $P4712."new"($P4716, $P4718, $P4722, $P4725, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 1729
    $P4727 = $P4711."push"($P4726)
.annotate 'line', 1728
    .return ($P4727)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "dotty"  :subid("512_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_4827
    .param pmc param_4828
.annotate 'line', 1794
    .lex "self", param_4827
    .lex "$/", param_4828
.annotate 'line', 1795
    new $P4829, "Undef"
    .lex "$past", $P4829
    find_lex $P4832, "$/"
    unless_null $P4832, vivify_1984
    $P4832 = root_new ['parrot';'Hash']
  vivify_1984:
    set $P4833, $P4832["args"]
    unless_null $P4833, vivify_1985
    new $P4833, "Undef"
  vivify_1985:
    if $P4833, if_4831
    get_hll_global $P4838, ["PAST"], "Op"
    find_lex $P4839, "$/"
    $P4840 = $P4838."new"($P4839 :named("node"))
    set $P4830, $P4840
    goto if_4831_end
  if_4831:
    find_lex $P4834, "$/"
    unless_null $P4834, vivify_1986
    $P4834 = root_new ['parrot';'Hash']
  vivify_1986:
    set $P4835, $P4834["args"]
    unless_null $P4835, vivify_1987
    $P4835 = root_new ['parrot';'ResizablePMCArray']
  vivify_1987:
    set $P4836, $P4835[0]
    unless_null $P4836, vivify_1988
    new $P4836, "Undef"
  vivify_1988:
    $P4837 = $P4836."ast"()
    set $P4830, $P4837
  if_4831_end:
    store_lex "$past", $P4830
.annotate 'line', 1796
    find_lex $P4842, "$/"
    unless_null $P4842, vivify_1989
    $P4842 = root_new ['parrot';'Hash']
  vivify_1989:
    set $P4843, $P4842["quote"]
    unless_null $P4843, vivify_1990
    new $P4843, "Undef"
  vivify_1990:
    if $P4843, if_4841
.annotate 'line', 1800
    find_lex $P4850, "$/"
    unless_null $P4850, vivify_1991
    $P4850 = root_new ['parrot';'Hash']
  vivify_1991:
    set $P4851, $P4850["longname"]
    unless_null $P4851, vivify_1992
    new $P4851, "Undef"
  vivify_1992:
    set $S4852, $P4851
    iseq $I4853, $S4852, "HOW"
    if $I4853, if_4849
.annotate 'line', 1803
    find_lex $P4856, "$/"
    unless_null $P4856, vivify_1993
    $P4856 = root_new ['parrot';'Hash']
  vivify_1993:
    set $P4857, $P4856["longname"]
    unless_null $P4857, vivify_1994
    new $P4857, "Undef"
  vivify_1994:
    set $S4858, $P4857
    iseq $I4859, $S4858, "WHAT"
    if $I4859, if_4855
.annotate 'line', 1806
    find_lex $P4862, "$/"
    unless_null $P4862, vivify_1995
    $P4862 = root_new ['parrot';'Hash']
  vivify_1995:
    set $P4863, $P4862["longname"]
    unless_null $P4863, vivify_1996
    new $P4863, "Undef"
  vivify_1996:
    set $S4864, $P4863
    iseq $I4865, $S4864, "WHO"
    if $I4865, if_4861
.annotate 'line', 1810
    find_lex $P4867, "$past"
    find_lex $P4868, "$/"
    unless_null $P4868, vivify_1997
    $P4868 = root_new ['parrot';'Hash']
  vivify_1997:
    set $P4869, $P4868["longname"]
    unless_null $P4869, vivify_1998
    new $P4869, "Undef"
  vivify_1998:
    set $S4870, $P4869
    $P4867."name"($S4870)
.annotate 'line', 1811
    find_lex $P4871, "$past"
    $P4871."pasttype"("callmethod")
.annotate 'line', 1809
    goto if_4861_end
  if_4861:
.annotate 'line', 1807
    find_lex $P4866, "$past"
    $P4866."pirop"("get_who PP")
  if_4861_end:
.annotate 'line', 1806
    goto if_4855_end
  if_4855:
.annotate 'line', 1804
    find_lex $P4860, "$past"
    $P4860."pirop"("get_what PP")
  if_4855_end:
.annotate 'line', 1803
    goto if_4849_end
  if_4849:
.annotate 'line', 1801
    find_lex $P4854, "$past"
    $P4854."pirop"("get_how PP")
  if_4849_end:
.annotate 'line', 1800
    goto if_4841_end
  if_4841:
.annotate 'line', 1797
    find_lex $P4844, "$past"
    find_lex $P4845, "$/"
    unless_null $P4845, vivify_1999
    $P4845 = root_new ['parrot';'Hash']
  vivify_1999:
    set $P4846, $P4845["quote"]
    unless_null $P4846, vivify_2000
    new $P4846, "Undef"
  vivify_2000:
    $P4847 = $P4846."ast"()
    $P4844."name"($P4847)
.annotate 'line', 1798
    find_lex $P4848, "$past"
    $P4848."pasttype"("callmethod")
  if_4841_end:
.annotate 'line', 1813
    find_lex $P4872, "$/"
    find_lex $P4873, "$past"
    $P4874 = $P4872."!make"($P4873)
.annotate 'line', 1794
    .return ($P4874)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<self>"  :subid("513_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_4876
    .param pmc param_4877
.annotate 'line', 1818
    .lex "self", param_4876
    .lex "$/", param_4877
.annotate 'line', 1819
    find_lex $P4878, "$/"
    get_hll_global $P4879, ["PAST"], "Var"
    $P4880 = $P4879."new"("self" :named("name"))
    $P4881 = $P4878."!make"($P4880)
.annotate 'line', 1818
    .return ($P4881)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<identifier>"  :subid("514_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_4883
    .param pmc param_4884
.annotate 'line', 1822
    .lex "self", param_4883
    .lex "$/", param_4884
.annotate 'line', 1823
    new $P4885, "Undef"
    .lex "$past", $P4885
    find_lex $P4886, "$/"
    unless_null $P4886, vivify_2001
    $P4886 = root_new ['parrot';'Hash']
  vivify_2001:
    set $P4887, $P4886["args"]
    unless_null $P4887, vivify_2002
    new $P4887, "Undef"
  vivify_2002:
    $P4888 = $P4887."ast"()
    store_lex "$past", $P4888
.annotate 'line', 1824
    find_lex $P4889, "$past"
    find_lex $P4890, "$/"
    unless_null $P4890, vivify_2003
    $P4890 = root_new ['parrot';'Hash']
  vivify_2003:
    set $P4891, $P4890["deflongname"]
    unless_null $P4891, vivify_2004
    new $P4891, "Undef"
  vivify_2004:
    set $S4892, $P4891
    $P4889."name"($S4892)
.annotate 'line', 1825
    find_lex $P4893, "$/"
    find_lex $P4894, "$past"
    $P4895 = $P4893."!make"($P4894)
.annotate 'line', 1822
    .return ($P4895)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<name>"  :subid("515_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_4897
    .param pmc param_4898
.annotate 'line', 1828
    .const 'Sub' $P4913 = "516_1302110486.758" 
    capture_lex $P4913
    .lex "self", param_4897
    .lex "$/", param_4898
.annotate 'line', 1830
    new $P4899, "Undef"
    .lex "$var", $P4899
.annotate 'line', 1842
    new $P4900, "Undef"
    .lex "$past", $P4900
.annotate 'line', 1828
    find_lex $P4901, "$var"
.annotate 'line', 1831
    find_lex $P4903, "$/"
    unless_null $P4903, vivify_2005
    $P4903 = root_new ['parrot';'Hash']
  vivify_2005:
    set $P4904, $P4903["name"]
    unless_null $P4904, vivify_2006
    new $P4904, "Undef"
  vivify_2006:
    set $S4905, $P4904
    $P4906 = "is_lexical"($S4905)
    if $P4906, if_4902
.annotate 'line', 1834
    .const 'Sub' $P4913 = "516_1302110486.758" 
    capture_lex $P4913
    $P4913()
    goto if_4902_end
  if_4902:
.annotate 'line', 1832
    get_hll_global $P4907, ["PAST"], "Var"
    find_lex $P4908, "$/"
    unless_null $P4908, vivify_2012
    $P4908 = root_new ['parrot';'Hash']
  vivify_2012:
    set $P4909, $P4908["name"]
    unless_null $P4909, vivify_2013
    new $P4909, "Undef"
  vivify_2013:
    set $S4910, $P4909
    $P4911 = $P4907."new"($S4910 :named("name"), "lexical" :named("scope"))
    store_lex "$var", $P4911
  if_4902_end:
.annotate 'line', 1842
    find_lex $P4936, "$var"
    store_lex "$past", $P4936
.annotate 'line', 1843
    find_lex $P4938, "$/"
    unless_null $P4938, vivify_2014
    $P4938 = root_new ['parrot';'Hash']
  vivify_2014:
    set $P4939, $P4938["args"]
    unless_null $P4939, vivify_2015
    new $P4939, "Undef"
  vivify_2015:
    unless $P4939, if_4937_end
.annotate 'line', 1844
    find_lex $P4940, "$/"
    unless_null $P4940, vivify_2016
    $P4940 = root_new ['parrot';'Hash']
  vivify_2016:
    set $P4941, $P4940["args"]
    unless_null $P4941, vivify_2017
    $P4941 = root_new ['parrot';'ResizablePMCArray']
  vivify_2017:
    set $P4942, $P4941[0]
    unless_null $P4942, vivify_2018
    new $P4942, "Undef"
  vivify_2018:
    $P4943 = $P4942."ast"()
    store_lex "$past", $P4943
.annotate 'line', 1845
    find_lex $P4944, "$past"
    find_lex $P4945, "$var"
    $P4944."unshift"($P4945)
  if_4937_end:
.annotate 'line', 1847
    find_lex $P4946, "$/"
    find_lex $P4947, "$past"
    $P4948 = $P4946."!make"($P4947)
.annotate 'line', 1828
    .return ($P4948)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4912"  :anon :subid("516_1302110486.758") :outer("515_1302110486.758")
.annotate 'line', 1835
    $P4914 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P4914
.annotate 'line', 1836
    new $P4915, "Undef"
    .lex "$name", $P4915
.annotate 'line', 1835
    find_lex $P4916, "$/"
    unless_null $P4916, vivify_2007
    $P4916 = root_new ['parrot';'Hash']
  vivify_2007:
    set $P4917, $P4916["name"]
    unless_null $P4917, vivify_2008
    $P4917 = root_new ['parrot';'Hash']
  vivify_2008:
    set $P4918, $P4917["identifier"]
    unless_null $P4918, vivify_2009
    new $P4918, "Undef"
  vivify_2009:
    clone $P4919, $P4918
    store_lex "@ns", $P4919
.annotate 'line', 1836
    find_lex $P4920, "@ns"
    $P4921 = $P4920."pop"()
    store_lex "$name", $P4921
.annotate 'line', 1837
    find_lex $P4925, "@ns"
    if $P4925, if_4924
    set $P4923, $P4925
    goto if_4924_end
  if_4924:
    find_lex $P4926, "@ns"
    unless_null $P4926, vivify_2010
    $P4926 = root_new ['parrot';'ResizablePMCArray']
  vivify_2010:
    set $P4927, $P4926[0]
    unless_null $P4927, vivify_2011
    new $P4927, "Undef"
  vivify_2011:
    set $S4928, $P4927
    iseq $I4929, $S4928, "GLOBAL"
    new $P4923, 'Integer'
    set $P4923, $I4929
  if_4924_end:
    unless $P4923, if_4922_end
    find_lex $P4930, "@ns"
    $P4930."shift"()
  if_4922_end:
.annotate 'line', 1838
    get_hll_global $P4931, ["PAST"], "Var"
    find_lex $P4932, "$name"
    set $S4933, $P4932
    find_lex $P4934, "@ns"
    $P4935 = $P4931."new"($S4933 :named("name"), $P4934 :named("namespace"), "package" :named("scope"))
    store_lex "$var", $P4935
.annotate 'line', 1834
    .return ($P4935)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<pir::op>"  :subid("517_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_4951
    .param pmc param_4952
.annotate 'line', 1860
    .lex "self", param_4951
    .lex "$/", param_4952
.annotate 'line', 1861
    new $P4953, "Undef"
    .lex "$past", $P4953
.annotate 'line', 1862
    new $P4954, "Undef"
    .lex "$pirop", $P4954
.annotate 'line', 1861
    find_lex $P4957, "$/"
    unless_null $P4957, vivify_2019
    $P4957 = root_new ['parrot';'Hash']
  vivify_2019:
    set $P4958, $P4957["args"]
    unless_null $P4958, vivify_2020
    new $P4958, "Undef"
  vivify_2020:
    if $P4958, if_4956
    get_hll_global $P4963, ["PAST"], "Op"
    find_lex $P4964, "$/"
    $P4965 = $P4963."new"($P4964 :named("node"))
    set $P4955, $P4965
    goto if_4956_end
  if_4956:
    find_lex $P4959, "$/"
    unless_null $P4959, vivify_2021
    $P4959 = root_new ['parrot';'Hash']
  vivify_2021:
    set $P4960, $P4959["args"]
    unless_null $P4960, vivify_2022
    $P4960 = root_new ['parrot';'ResizablePMCArray']
  vivify_2022:
    set $P4961, $P4960[0]
    unless_null $P4961, vivify_2023
    new $P4961, "Undef"
  vivify_2023:
    $P4962 = $P4961."ast"()
    set $P4955, $P4962
  if_4956_end:
    store_lex "$past", $P4955
.annotate 'line', 1862
    find_lex $P4966, "$/"
    unless_null $P4966, vivify_2024
    $P4966 = root_new ['parrot';'Hash']
  vivify_2024:
    set $P4967, $P4966["op"]
    unless_null $P4967, vivify_2025
    new $P4967, "Undef"
  vivify_2025:
    set $S4968, $P4967
    new $P4969, 'String'
    set $P4969, $S4968
    store_lex "$pirop", $P4969
.annotate 'line', 1863

            $P0 = find_lex '$pirop'
            $S0 = $P0
            $P0 = split '__', $S0
            $S0 = join ' ', $P0
            $P4970 = box $S0
        
    store_lex "$pirop", $P4970
.annotate 'line', 1870
    find_lex $P4971, "$past"
    find_lex $P4972, "$pirop"
    $P4971."pirop"($P4972)
.annotate 'line', 1871
    find_lex $P4973, "$past"
    $P4973."pasttype"("pirop")
.annotate 'line', 1872
    find_lex $P4974, "$/"
    find_lex $P4975, "$past"
    $P4976 = $P4974."!make"($P4975)
.annotate 'line', 1860
    .return ($P4976)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<onlystar>"  :subid("518_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_4978
    .param pmc param_4979
.annotate 'line', 1875
    .lex "self", param_4978
    .lex "$/", param_4979
.annotate 'line', 1876
    find_lex $P4980, "$/"
    get_hll_global $P4981, ["PAST"], "Op"
    $P4982 = $P4981."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P4983 = $P4980."!make"($P4982)
.annotate 'line', 1875
    .return ($P4983)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "args"  :subid("519_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_4985
    .param pmc param_4986
.annotate 'line', 1881
    .lex "self", param_4985
    .lex "$/", param_4986
    find_lex $P4987, "$/"
    find_lex $P4988, "$/"
    unless_null $P4988, vivify_2026
    $P4988 = root_new ['parrot';'Hash']
  vivify_2026:
    set $P4989, $P4988["arglist"]
    unless_null $P4989, vivify_2027
    new $P4989, "Undef"
  vivify_2027:
    $P4990 = $P4989."ast"()
    $P4991 = $P4987."!make"($P4990)
    .return ($P4991)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "arglist"  :subid("520_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_4993
    .param pmc param_4994
.annotate 'line', 1883
    .const 'Sub' $P5005 = "521_1302110486.758" 
    capture_lex $P5005
    .lex "self", param_4993
    .lex "$/", param_4994
.annotate 'line', 1884
    new $P4995, "Undef"
    .lex "$past", $P4995
.annotate 'line', 1892
    new $P4996, "Undef"
    .lex "$i", $P4996
.annotate 'line', 1893
    new $P4997, "Undef"
    .lex "$n", $P4997
.annotate 'line', 1884
    get_hll_global $P4998, ["PAST"], "Op"
    find_lex $P4999, "$/"
    $P5000 = $P4998."new"("call" :named("pasttype"), $P4999 :named("node"))
    store_lex "$past", $P5000
.annotate 'line', 1885
    find_lex $P5002, "$/"
    unless_null $P5002, vivify_2028
    $P5002 = root_new ['parrot';'Hash']
  vivify_2028:
    set $P5003, $P5002["EXPR"]
    unless_null $P5003, vivify_2029
    new $P5003, "Undef"
  vivify_2029:
    unless $P5003, if_5001_end
    .const 'Sub' $P5005 = "521_1302110486.758" 
    capture_lex $P5005
    $P5005()
  if_5001_end:
.annotate 'line', 1892
    new $P5037, "Integer"
    assign $P5037, 0
    store_lex "$i", $P5037
.annotate 'line', 1893
    find_lex $P5038, "$past"
    $P5039 = $P5038."list"()
    set $N5040, $P5039
    new $P5041, 'Float'
    set $P5041, $N5040
    store_lex "$n", $P5041
.annotate 'line', 1894
    new $P5089, 'ExceptionHandler'
    set_label $P5089, loop5088_handler
    $P5089."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5089
  loop5088_test:
    find_lex $P5042, "$i"
    set $N5043, $P5042
    find_lex $P5044, "$n"
    set $N5045, $P5044
    islt $I5046, $N5043, $N5045
    unless $I5046, loop5088_done
  loop5088_redo:
.annotate 'line', 1895
    find_lex $P5048, "$i"
    set $I5049, $P5048
    find_lex $P5050, "$past"
    unless_null $P5050, vivify_2033
    $P5050 = root_new ['parrot';'ResizablePMCArray']
  vivify_2033:
    set $P5051, $P5050[$I5049]
    unless_null $P5051, vivify_2034
    new $P5051, "Undef"
  vivify_2034:
    $S5052 = $P5051."name"()
    iseq $I5053, $S5052, "&prefix:<|>"
    unless $I5053, if_5047_end
.annotate 'line', 1896
    find_lex $P5054, "$i"
    set $I5055, $P5054
    find_lex $P5056, "$past"
    unless_null $P5056, vivify_2035
    $P5056 = root_new ['parrot';'ResizablePMCArray']
  vivify_2035:
    set $P5057, $P5056[$I5055]
    unless_null $P5057, vivify_2036
    $P5057 = root_new ['parrot';'ResizablePMCArray']
  vivify_2036:
    set $P5058, $P5057[0]
    unless_null $P5058, vivify_2037
    new $P5058, "Undef"
  vivify_2037:
    find_lex $P5059, "$i"
    set $I5060, $P5059
    find_lex $P5061, "$past"
    unless_null $P5061, vivify_2038
    $P5061 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$past", $P5061
  vivify_2038:
    set $P5061[$I5060], $P5058
.annotate 'line', 1897
    find_lex $P5062, "$i"
    set $I5063, $P5062
    find_lex $P5064, "$past"
    unless_null $P5064, vivify_2039
    $P5064 = root_new ['parrot';'ResizablePMCArray']
  vivify_2039:
    set $P5065, $P5064[$I5063]
    unless_null $P5065, vivify_2040
    new $P5065, "Undef"
  vivify_2040:
    $P5065."flat"(1)
.annotate 'line', 1898
    find_lex $P5069, "$i"
    set $I5070, $P5069
    find_lex $P5071, "$past"
    unless_null $P5071, vivify_2041
    $P5071 = root_new ['parrot';'ResizablePMCArray']
  vivify_2041:
    set $P5072, $P5071[$I5070]
    unless_null $P5072, vivify_2042
    new $P5072, "Undef"
  vivify_2042:
    get_hll_global $P5073, ["PAST"], "Val"
    $P5074 = $P5072."isa"($P5073)
    if $P5074, if_5068
    set $P5067, $P5074
    goto if_5068_end
  if_5068:
.annotate 'line', 1899
    find_lex $P5075, "$i"
    set $I5076, $P5075
    find_lex $P5077, "$past"
    unless_null $P5077, vivify_2043
    $P5077 = root_new ['parrot';'ResizablePMCArray']
  vivify_2043:
    set $P5078, $P5077[$I5076]
    unless_null $P5078, vivify_2044
    new $P5078, "Undef"
  vivify_2044:
    $S5079 = $P5078."name"()
    substr $S5080, $S5079, 0, 1
    iseq $I5081, $S5080, "%"
    new $P5067, 'Integer'
    set $P5067, $I5081
  if_5068_end:
    unless $P5067, if_5066_end
.annotate 'line', 1900
    find_lex $P5082, "$i"
    set $I5083, $P5082
    find_lex $P5084, "$past"
    unless_null $P5084, vivify_2045
    $P5084 = root_new ['parrot';'ResizablePMCArray']
  vivify_2045:
    set $P5085, $P5084[$I5083]
    unless_null $P5085, vivify_2046
    new $P5085, "Undef"
  vivify_2046:
    $P5085."named"(1)
  if_5066_end:
  if_5047_end:
.annotate 'line', 1895
    find_lex $P5086, "$i"
    clone $P5087, $P5086
    inc $P5086
  loop5088_next:
.annotate 'line', 1894
    goto loop5088_test
  loop5088_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5090, exception, 'type'
    eq $P5090, .CONTROL_LOOP_NEXT, loop5088_next
    eq $P5090, .CONTROL_LOOP_REDO, loop5088_redo
  loop5088_done:
    pop_eh 
.annotate 'line', 1905
    find_lex $P5091, "$/"
    find_lex $P5092, "$past"
    $P5093 = $P5091."!make"($P5092)
.annotate 'line', 1883
    .return ($P5093)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block5004"  :anon :subid("521_1302110486.758") :outer("520_1302110486.758")
.annotate 'line', 1885
    .const 'Sub' $P5026 = "522_1302110486.758" 
    capture_lex $P5026
.annotate 'line', 1886
    new $P5006, "Undef"
    .lex "$expr", $P5006
    find_lex $P5007, "$/"
    unless_null $P5007, vivify_2030
    $P5007 = root_new ['parrot';'Hash']
  vivify_2030:
    set $P5008, $P5007["EXPR"]
    unless_null $P5008, vivify_2031
    new $P5008, "Undef"
  vivify_2031:
    $P5009 = $P5008."ast"()
    store_lex "$expr", $P5009
.annotate 'line', 1887
    find_lex $P5014, "$expr"
    $S5015 = $P5014."name"()
    iseq $I5016, $S5015, "&infix:<,>"
    if $I5016, if_5013
    new $P5012, 'Integer'
    set $P5012, $I5016
    goto if_5013_end
  if_5013:
    find_lex $P5017, "$expr"
    $P5018 = $P5017."named"()
    isfalse $I5019, $P5018
    new $P5012, 'Integer'
    set $P5012, $I5019
  if_5013_end:
    if $P5012, if_5011
.annotate 'line', 1890
    find_lex $P5034, "$past"
    find_lex $P5035, "$expr"
    $P5036 = $P5034."push"($P5035)
    set $P5010, $P5036
.annotate 'line', 1887
    goto if_5011_end
  if_5011:
.annotate 'line', 1888
    find_lex $P5021, "$expr"
    $P5022 = $P5021."list"()
    defined $I5023, $P5022
    unless $I5023, for_undef_2032
    iter $P5020, $P5022
    new $P5032, 'ExceptionHandler'
    set_label $P5032, loop5031_handler
    $P5032."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5032
  loop5031_test:
    unless $P5020, loop5031_done
    shift $P5024, $P5020
  loop5031_redo:
    .const 'Sub' $P5026 = "522_1302110486.758" 
    capture_lex $P5026
    $P5026($P5024)
  loop5031_next:
    goto loop5031_test
  loop5031_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5033, exception, 'type'
    eq $P5033, .CONTROL_LOOP_NEXT, loop5031_next
    eq $P5033, .CONTROL_LOOP_REDO, loop5031_redo
  loop5031_done:
    pop_eh 
  for_undef_2032:
.annotate 'line', 1887
    set $P5010, $P5020
  if_5011_end:
.annotate 'line', 1885
    .return ($P5010)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5025"  :anon :subid("522_1302110486.758") :outer("521_1302110486.758")
    .param pmc param_5027
.annotate 'line', 1888
    .lex "$_", param_5027
    find_lex $P5028, "$past"
    find_lex $P5029, "$_"
    $P5030 = $P5028."push"($P5029)
    .return ($P5030)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<multi_declarator>"  :subid("523_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_5095
    .param pmc param_5096
.annotate 'line', 1908
    .lex "self", param_5095
    .lex "$/", param_5096
    find_lex $P5097, "$/"
    find_lex $P5098, "$/"
    unless_null $P5098, vivify_2047
    $P5098 = root_new ['parrot';'Hash']
  vivify_2047:
    set $P5099, $P5098["multi_declarator"]
    unless_null $P5099, vivify_2048
    new $P5099, "Undef"
  vivify_2048:
    $P5100 = $P5099."ast"()
    $P5101 = $P5097."!make"($P5100)
    .return ($P5101)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<value>"  :subid("524_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_5103
    .param pmc param_5104
.annotate 'line', 1910
    .lex "self", param_5103
    .lex "$/", param_5104
    find_lex $P5105, "$/"
    find_lex $P5106, "$/"
    unless_null $P5106, vivify_2049
    $P5106 = root_new ['parrot';'Hash']
  vivify_2049:
    set $P5107, $P5106["value"]
    unless_null $P5107, vivify_2050
    new $P5107, "Undef"
  vivify_2050:
    $P5108 = $P5107."ast"()
    $P5109 = $P5105."!make"($P5108)
    .return ($P5109)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<( )>"  :subid("525_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_5111
    .param pmc param_5112
.annotate 'line', 1912
    .lex "self", param_5111
    .lex "$/", param_5112
.annotate 'line', 1913
    find_lex $P5113, "$/"
.annotate 'line', 1914
    find_lex $P5116, "$/"
    unless_null $P5116, vivify_2051
    $P5116 = root_new ['parrot';'Hash']
  vivify_2051:
    set $P5117, $P5116["EXPR"]
    unless_null $P5117, vivify_2052
    new $P5117, "Undef"
  vivify_2052:
    if $P5117, if_5115
.annotate 'line', 1915
    get_hll_global $P5122, ["PAST"], "Op"
    find_lex $P5123, "$/"
    $P5124 = $P5122."new"("list" :named("pasttype"), $P5123 :named("node"))
    set $P5114, $P5124
.annotate 'line', 1914
    goto if_5115_end
  if_5115:
    find_lex $P5118, "$/"
    unless_null $P5118, vivify_2053
    $P5118 = root_new ['parrot';'Hash']
  vivify_2053:
    set $P5119, $P5118["EXPR"]
    unless_null $P5119, vivify_2054
    $P5119 = root_new ['parrot';'ResizablePMCArray']
  vivify_2054:
    set $P5120, $P5119[0]
    unless_null $P5120, vivify_2055
    new $P5120, "Undef"
  vivify_2055:
    $P5121 = $P5120."ast"()
    set $P5114, $P5121
  if_5115_end:
    $P5125 = $P5113."!make"($P5114)
.annotate 'line', 1912
    .return ($P5125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<[ ]>"  :subid("526_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_5127
    .param pmc param_5128
.annotate 'line', 1918
    .lex "self", param_5127
    .lex "$/", param_5128
.annotate 'line', 1919
    new $P5129, "Undef"
    .lex "$past", $P5129
.annotate 'line', 1918
    find_lex $P5130, "$past"
.annotate 'line', 1920
    find_lex $P5132, "$/"
    unless_null $P5132, vivify_2056
    $P5132 = root_new ['parrot';'Hash']
  vivify_2056:
    set $P5133, $P5132["EXPR"]
    unless_null $P5133, vivify_2057
    new $P5133, "Undef"
  vivify_2057:
    if $P5133, if_5131
.annotate 'line', 1927
    get_hll_global $P5145, ["PAST"], "Op"
    $P5146 = $P5145."new"("list" :named("pasttype"))
    store_lex "$past", $P5146
.annotate 'line', 1926
    goto if_5131_end
  if_5131:
.annotate 'line', 1921
    find_lex $P5134, "$/"
    unless_null $P5134, vivify_2058
    $P5134 = root_new ['parrot';'Hash']
  vivify_2058:
    set $P5135, $P5134["EXPR"]
    unless_null $P5135, vivify_2059
    $P5135 = root_new ['parrot';'ResizablePMCArray']
  vivify_2059:
    set $P5136, $P5135[0]
    unless_null $P5136, vivify_2060
    new $P5136, "Undef"
  vivify_2060:
    $P5137 = $P5136."ast"()
    store_lex "$past", $P5137
.annotate 'line', 1922
    find_lex $P5139, "$past"
    $S5140 = $P5139."name"()
    isne $I5141, $S5140, "&infix:<,>"
    unless $I5141, if_5138_end
.annotate 'line', 1923
    get_hll_global $P5142, ["PAST"], "Op"
    find_lex $P5143, "$past"
    $P5144 = $P5142."new"($P5143, "list" :named("pasttype"))
    store_lex "$past", $P5144
  if_5138_end:
  if_5131_end:
.annotate 'line', 1929
    find_lex $P5147, "$past"
    $P5147."name"("&circumfix:<[ ]>")
.annotate 'line', 1930
    find_lex $P5148, "$/"
    find_lex $P5149, "$past"
    $P5150 = $P5148."!make"($P5149)
.annotate 'line', 1918
    .return ($P5150)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<ang>"  :subid("527_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_5152
    .param pmc param_5153
.annotate 'line', 1933
    .lex "self", param_5152
    .lex "$/", param_5153
    find_lex $P5154, "$/"
    find_lex $P5155, "$/"
    unless_null $P5155, vivify_2061
    $P5155 = root_new ['parrot';'Hash']
  vivify_2061:
    set $P5156, $P5155["quote_EXPR"]
    unless_null $P5156, vivify_2062
    new $P5156, "Undef"
  vivify_2062:
    $P5157 = $P5156."ast"()
    $P5158 = $P5154."!make"($P5157)
    .return ($P5158)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("528_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_5160
    .param pmc param_5161
.annotate 'line', 1934
    .lex "self", param_5160
    .lex "$/", param_5161
    find_lex $P5162, "$/"
    find_lex $P5163, "$/"
    unless_null $P5163, vivify_2063
    $P5163 = root_new ['parrot';'Hash']
  vivify_2063:
    set $P5164, $P5163["quote_EXPR"]
    unless_null $P5164, vivify_2064
    new $P5164, "Undef"
  vivify_2064:
    $P5165 = $P5164."ast"()
    $P5166 = $P5162."!make"($P5165)
    .return ($P5166)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<{ }>"  :subid("529_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_5168
    .param pmc param_5169
.annotate 'line', 1936
    .const 'Sub' $P5180 = "530_1302110486.758" 
    capture_lex $P5180
    .lex "self", param_5168
    .lex "$/", param_5169
.annotate 'line', 1937
    find_lex $P5172, "$/"
    unless_null $P5172, vivify_2065
    $P5172 = root_new ['parrot';'Hash']
  vivify_2065:
    set $P5173, $P5172["pblock"]
    unless_null $P5173, vivify_2066
    $P5173 = root_new ['parrot';'Hash']
  vivify_2066:
    set $P5174, $P5173["blockoid"]
    unless_null $P5174, vivify_2067
    $P5174 = root_new ['parrot';'Hash']
  vivify_2067:
    set $P5175, $P5174["statementlist"]
    unless_null $P5175, vivify_2068
    $P5175 = root_new ['parrot';'Hash']
  vivify_2068:
    set $P5176, $P5175["statement"]
    unless_null $P5176, vivify_2069
    new $P5176, "Undef"
  vivify_2069:
    set $N5177, $P5176
    isgt $I5178, $N5177, 0.0
    if $I5178, if_5171
.annotate 'line', 1942
    find_lex $P5193, "$/"
    unless_null $P5193, vivify_2070
    $P5193 = root_new ['parrot';'Hash']
  vivify_2070:
    set $P5194, $P5193["pblock"]
    unless_null $P5194, vivify_2071
    $P5194 = root_new ['parrot';'Hash']
  vivify_2071:
    set $P5195, $P5194["blockoid"]
    unless_null $P5195, vivify_2072
    $P5195 = root_new ['parrot';'Hash']
  vivify_2072:
    set $P5196, $P5195["you_are_here"]
    unless_null $P5196, vivify_2073
    new $P5196, "Undef"
  vivify_2073:
    if $P5196, if_5192
.annotate 'line', 1946
    find_lex $P5202, "$/"
    $P5203 = "vivitype"("%")
    $P5204 = $P5202."!make"($P5203)
.annotate 'line', 1945
    set $P5191, $P5204
.annotate 'line', 1942
    goto if_5192_end
  if_5192:
.annotate 'line', 1943
    find_lex $P5197, "$/"
    find_lex $P5198, "$/"
    unless_null $P5198, vivify_2074
    $P5198 = root_new ['parrot';'Hash']
  vivify_2074:
    set $P5199, $P5198["pblock"]
    unless_null $P5199, vivify_2075
    new $P5199, "Undef"
  vivify_2075:
    $P5200 = $P5199."ast"()
    $P5201 = $P5197."!make"($P5200)
.annotate 'line', 1942
    set $P5191, $P5201
  if_5192_end:
    set $P5170, $P5191
.annotate 'line', 1937
    goto if_5171_end
  if_5171:
    .const 'Sub' $P5180 = "530_1302110486.758" 
    capture_lex $P5180
    $P5190 = $P5180()
    set $P5170, $P5190
  if_5171_end:
.annotate 'line', 1936
    .return ($P5170)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5179"  :anon :subid("530_1302110486.758") :outer("529_1302110486.758")
.annotate 'line', 1938
    new $P5181, "Undef"
    .lex "$past", $P5181
    find_lex $P5182, "$/"
    unless_null $P5182, vivify_2076
    $P5182 = root_new ['parrot';'Hash']
  vivify_2076:
    set $P5183, $P5182["pblock"]
    unless_null $P5183, vivify_2077
    new $P5183, "Undef"
  vivify_2077:
    $P5184 = $P5183."ast"()
    store_lex "$past", $P5184
.annotate 'line', 1939
    new $P5185, "Integer"
    assign $P5185, 1
    find_lex $P5186, "$past"
    unless_null $P5186, vivify_2078
    $P5186 = root_new ['parrot';'Hash']
    store_lex "$past", $P5186
  vivify_2078:
    set $P5186["bareblock"], $P5185
.annotate 'line', 1940
    find_dynamic_lex $P5187, "$/"
    find_lex $P5188, "$past"
    $P5189 = $P5187."!make"($P5188)
.annotate 'line', 1937
    .return ($P5189)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<sigil>"  :subid("531_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_5206
    .param pmc param_5207
.annotate 'line', 1950
    .lex "self", param_5206
    .lex "$/", param_5207
.annotate 'line', 1951
    new $P5208, "Undef"
    .lex "$name", $P5208
    find_lex $P5211, "$/"
    unless_null $P5211, vivify_2079
    $P5211 = root_new ['parrot';'Hash']
  vivify_2079:
    set $P5212, $P5211["sigil"]
    unless_null $P5212, vivify_2080
    new $P5212, "Undef"
  vivify_2080:
    set $S5213, $P5212
    iseq $I5214, $S5213, "@"
    if $I5214, if_5210
.annotate 'line', 1952
    find_lex $P5218, "$/"
    unless_null $P5218, vivify_2081
    $P5218 = root_new ['parrot';'Hash']
  vivify_2081:
    set $P5219, $P5218["sigil"]
    unless_null $P5219, vivify_2082
    new $P5219, "Undef"
  vivify_2082:
    set $S5220, $P5219
    iseq $I5221, $S5220, "%"
    if $I5221, if_5217
    new $P5223, "String"
    assign $P5223, "item"
    set $P5216, $P5223
    goto if_5217_end
  if_5217:
    new $P5222, "String"
    assign $P5222, "hash"
    set $P5216, $P5222
  if_5217_end:
    set $P5209, $P5216
.annotate 'line', 1951
    goto if_5210_end
  if_5210:
    new $P5215, "String"
    assign $P5215, "list"
    set $P5209, $P5215
  if_5210_end:
    store_lex "$name", $P5209
.annotate 'line', 1954
    find_lex $P5224, "$/"
    get_hll_global $P5225, ["PAST"], "Op"
    find_lex $P5226, "$name"
    find_lex $P5227, "$/"
    unless_null $P5227, vivify_2083
    $P5227 = root_new ['parrot';'Hash']
  vivify_2083:
    set $P5228, $P5227["semilist"]
    unless_null $P5228, vivify_2084
    new $P5228, "Undef"
  vivify_2084:
    $P5229 = $P5228."ast"()
    $P5230 = $P5225."new"($P5229, "callmethod" :named("pasttype"), $P5226 :named("name"))
    $P5231 = $P5224."!make"($P5230)
.annotate 'line', 1950
    .return ($P5231)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "semilist"  :subid("532_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_5233
    .param pmc param_5234
.annotate 'line', 1957
    .lex "self", param_5233
    .lex "$/", param_5234
    find_lex $P5235, "$/"
    find_lex $P5236, "$/"
    unless_null $P5236, vivify_2085
    $P5236 = root_new ['parrot';'Hash']
  vivify_2085:
    set $P5237, $P5236["statement"]
    unless_null $P5237, vivify_2086
    new $P5237, "Undef"
  vivify_2086:
    $P5238 = $P5237."ast"()
    $P5239 = $P5235."!make"($P5238)
    .return ($P5239)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<[ ]>"  :subid("533_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_5241
    .param pmc param_5242
.annotate 'line', 1959
    .lex "self", param_5241
    .lex "$/", param_5242
.annotate 'line', 1960
    find_lex $P5243, "$/"
    get_hll_global $P5244, ["PAST"], "Var"
    find_lex $P5245, "$/"
    unless_null $P5245, vivify_2087
    $P5245 = root_new ['parrot';'Hash']
  vivify_2087:
    set $P5246, $P5245["EXPR"]
    unless_null $P5246, vivify_2088
    new $P5246, "Undef"
  vivify_2088:
    $P5247 = $P5246."ast"()
.annotate 'line', 1962
    $P5248 = "vivitype"("@")
    $P5249 = $P5244."new"($P5247, "keyed_int" :named("scope"), "Undef" :named("viviself"), $P5248 :named("vivibase"))
.annotate 'line', 1960
    $P5250 = $P5243."!make"($P5249)
.annotate 'line', 1959
    .return ($P5250)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<{ }>"  :subid("534_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_5252
    .param pmc param_5253
.annotate 'line', 1965
    .lex "self", param_5252
    .lex "$/", param_5253
.annotate 'line', 1966
    find_lex $P5254, "$/"
    get_hll_global $P5255, ["PAST"], "Var"
    find_lex $P5256, "$/"
    unless_null $P5256, vivify_2089
    $P5256 = root_new ['parrot';'Hash']
  vivify_2089:
    set $P5257, $P5256["EXPR"]
    unless_null $P5257, vivify_2090
    new $P5257, "Undef"
  vivify_2090:
    $P5258 = $P5257."ast"()
.annotate 'line', 1968
    $P5259 = "vivitype"("%")
    $P5260 = $P5255."new"($P5258, "keyed" :named("scope"), "Undef" :named("viviself"), $P5259 :named("vivibase"))
.annotate 'line', 1966
    $P5261 = $P5254."!make"($P5260)
.annotate 'line', 1965
    .return ($P5261)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<ang>"  :subid("535_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_5263
    .param pmc param_5264
.annotate 'line', 1971
    .lex "self", param_5263
    .lex "$/", param_5264
.annotate 'line', 1972
    find_lex $P5265, "$/"
    get_hll_global $P5266, ["PAST"], "Var"
    find_lex $P5267, "$/"
    unless_null $P5267, vivify_2091
    $P5267 = root_new ['parrot';'Hash']
  vivify_2091:
    set $P5268, $P5267["quote_EXPR"]
    unless_null $P5268, vivify_2092
    new $P5268, "Undef"
  vivify_2092:
    $P5269 = $P5268."ast"()
.annotate 'line', 1974
    $P5270 = "vivitype"("%")
    $P5271 = $P5266."new"($P5269, "keyed" :named("scope"), "Undef" :named("viviself"), $P5270 :named("vivibase"))
.annotate 'line', 1972
    $P5272 = $P5265."!make"($P5271)
.annotate 'line', 1971
    .return ($P5272)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<( )>"  :subid("536_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_5274
    .param pmc param_5275
.annotate 'line', 1977
    .lex "self", param_5274
    .lex "$/", param_5275
.annotate 'line', 1978
    find_lex $P5276, "$/"
    find_lex $P5277, "$/"
    unless_null $P5277, vivify_2093
    $P5277 = root_new ['parrot';'Hash']
  vivify_2093:
    set $P5278, $P5277["arglist"]
    unless_null $P5278, vivify_2094
    new $P5278, "Undef"
  vivify_2094:
    $P5279 = $P5278."ast"()
    $P5280 = $P5276."!make"($P5279)
.annotate 'line', 1977
    .return ($P5280)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "value"  :subid("537_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_5282
    .param pmc param_5283
.annotate 'line', 1981
    .lex "self", param_5282
    .lex "$/", param_5283
.annotate 'line', 1982
    find_lex $P5284, "$/"
    find_lex $P5287, "$/"
    unless_null $P5287, vivify_2095
    $P5287 = root_new ['parrot';'Hash']
  vivify_2095:
    set $P5288, $P5287["quote"]
    unless_null $P5288, vivify_2096
    new $P5288, "Undef"
  vivify_2096:
    if $P5288, if_5286
    find_lex $P5292, "$/"
    unless_null $P5292, vivify_2097
    $P5292 = root_new ['parrot';'Hash']
  vivify_2097:
    set $P5293, $P5292["number"]
    unless_null $P5293, vivify_2098
    new $P5293, "Undef"
  vivify_2098:
    $P5294 = $P5293."ast"()
    set $P5285, $P5294
    goto if_5286_end
  if_5286:
    find_lex $P5289, "$/"
    unless_null $P5289, vivify_2099
    $P5289 = root_new ['parrot';'Hash']
  vivify_2099:
    set $P5290, $P5289["quote"]
    unless_null $P5290, vivify_2100
    new $P5290, "Undef"
  vivify_2100:
    $P5291 = $P5290."ast"()
    set $P5285, $P5291
  if_5286_end:
    $P5295 = $P5284."!make"($P5285)
.annotate 'line', 1981
    .return ($P5295)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "number"  :subid("538_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_5297
    .param pmc param_5298
.annotate 'line', 1985
    .lex "self", param_5297
    .lex "$/", param_5298
.annotate 'line', 1986
    new $P5299, "Undef"
    .lex "$value", $P5299
    find_lex $P5302, "$/"
    unless_null $P5302, vivify_2101
    $P5302 = root_new ['parrot';'Hash']
  vivify_2101:
    set $P5303, $P5302["dec_number"]
    unless_null $P5303, vivify_2102
    new $P5303, "Undef"
  vivify_2102:
    if $P5303, if_5301
    find_lex $P5307, "$/"
    unless_null $P5307, vivify_2103
    $P5307 = root_new ['parrot';'Hash']
  vivify_2103:
    set $P5308, $P5307["integer"]
    unless_null $P5308, vivify_2104
    new $P5308, "Undef"
  vivify_2104:
    $P5309 = $P5308."ast"()
    set $P5300, $P5309
    goto if_5301_end
  if_5301:
    find_lex $P5304, "$/"
    unless_null $P5304, vivify_2105
    $P5304 = root_new ['parrot';'Hash']
  vivify_2105:
    set $P5305, $P5304["dec_number"]
    unless_null $P5305, vivify_2106
    new $P5305, "Undef"
  vivify_2106:
    $P5306 = $P5305."ast"()
    set $P5300, $P5306
  if_5301_end:
    store_lex "$value", $P5300
.annotate 'line', 1987
    find_lex $P5311, "$/"
    unless_null $P5311, vivify_2107
    $P5311 = root_new ['parrot';'Hash']
  vivify_2107:
    set $P5312, $P5311["sign"]
    unless_null $P5312, vivify_2108
    new $P5312, "Undef"
  vivify_2108:
    set $S5313, $P5312
    iseq $I5314, $S5313, "-"
    unless $I5314, if_5310_end
    find_lex $P5315, "$value"
    neg $P5316, $P5315
    store_lex "$value", $P5316
  if_5310_end:
.annotate 'line', 1988
    find_lex $P5317, "$/"
    get_hll_global $P5318, ["PAST"], "Val"
    find_lex $P5319, "$value"
    $P5320 = $P5318."new"($P5319 :named("value"))
    $P5321 = $P5317."!make"($P5320)
.annotate 'line', 1985
    .return ($P5321)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<apos>"  :subid("539_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_5323
    .param pmc param_5324
.annotate 'line', 1991
    .lex "self", param_5323
    .lex "$/", param_5324
    find_lex $P5325, "$/"
    find_lex $P5326, "$/"
    unless_null $P5326, vivify_2109
    $P5326 = root_new ['parrot';'Hash']
  vivify_2109:
    set $P5327, $P5326["quote_EXPR"]
    unless_null $P5327, vivify_2110
    new $P5327, "Undef"
  vivify_2110:
    $P5328 = $P5327."ast"()
    $P5329 = $P5325."!make"($P5328)
    .return ($P5329)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<dblq>"  :subid("540_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_5331
    .param pmc param_5332
.annotate 'line', 1992
    .lex "self", param_5331
    .lex "$/", param_5332
    find_lex $P5333, "$/"
    find_lex $P5334, "$/"
    unless_null $P5334, vivify_2111
    $P5334 = root_new ['parrot';'Hash']
  vivify_2111:
    set $P5335, $P5334["quote_EXPR"]
    unless_null $P5335, vivify_2112
    new $P5335, "Undef"
  vivify_2112:
    $P5336 = $P5335."ast"()
    $P5337 = $P5333."!make"($P5336)
    .return ($P5337)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<qq>"  :subid("541_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_5339
    .param pmc param_5340
.annotate 'line', 1993
    .lex "self", param_5339
    .lex "$/", param_5340
    find_lex $P5341, "$/"
    find_lex $P5342, "$/"
    unless_null $P5342, vivify_2113
    $P5342 = root_new ['parrot';'Hash']
  vivify_2113:
    set $P5343, $P5342["quote_EXPR"]
    unless_null $P5343, vivify_2114
    new $P5343, "Undef"
  vivify_2114:
    $P5344 = $P5343."ast"()
    $P5345 = $P5341."!make"($P5344)
    .return ($P5345)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<q>"  :subid("542_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_5347
    .param pmc param_5348
.annotate 'line', 1994
    .lex "self", param_5347
    .lex "$/", param_5348
    find_lex $P5349, "$/"
    find_lex $P5350, "$/"
    unless_null $P5350, vivify_2115
    $P5350 = root_new ['parrot';'Hash']
  vivify_2115:
    set $P5351, $P5350["quote_EXPR"]
    unless_null $P5351, vivify_2116
    new $P5351, "Undef"
  vivify_2116:
    $P5352 = $P5351."ast"()
    $P5353 = $P5349."!make"($P5352)
    .return ($P5353)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q>"  :subid("543_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_5355
    .param pmc param_5356
.annotate 'line', 1995
    .lex "self", param_5355
    .lex "$/", param_5356
    find_lex $P5357, "$/"
    find_lex $P5358, "$/"
    unless_null $P5358, vivify_2117
    $P5358 = root_new ['parrot';'Hash']
  vivify_2117:
    set $P5359, $P5358["quote_EXPR"]
    unless_null $P5359, vivify_2118
    new $P5359, "Undef"
  vivify_2118:
    $P5360 = $P5359."ast"()
    $P5361 = $P5357."!make"($P5360)
    .return ($P5361)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q:PIR>"  :subid("544_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_5363
    .param pmc param_5364
.annotate 'line', 1996
    .lex "self", param_5363
    .lex "$/", param_5364
.annotate 'line', 1997
    find_lex $P5365, "$/"
    get_hll_global $P5366, ["PAST"], "Op"
    find_lex $P5367, "$/"
    unless_null $P5367, vivify_2119
    $P5367 = root_new ['parrot';'Hash']
  vivify_2119:
    set $P5368, $P5367["quote_EXPR"]
    unless_null $P5368, vivify_2120
    new $P5368, "Undef"
  vivify_2120:
    $P5369 = $P5368."ast"()
    $P5370 = $P5369."value"()
    find_lex $P5371, "$/"
    $P5372 = $P5366."new"($P5370 :named("inline"), "inline" :named("pasttype"), $P5371 :named("node"))
    $P5373 = $P5365."!make"($P5372)
.annotate 'line', 1996
    .return ($P5373)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "quote:sym</ />"  :subid("545_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_5377
    .param pmc param_5378
    .param pmc param_5379 :optional
    .param int has_param_5379 :opt_flag
.annotate 'line', 2002
    new $P5376, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P5376, control_5375
    push_eh $P5376
    .lex "self", param_5377
    .lex "$/", param_5378
    if has_param_5379, optparam_2121
    new $P5380, "Undef"
    set param_5379, $P5380
  optparam_2121:
    .lex "$key", param_5379
.annotate 'line', 2012
    new $P5381, "Undef"
    .lex "$regex", $P5381
.annotate 'line', 2014
    new $P5382, "Undef"
    .lex "$past", $P5382
.annotate 'line', 2003
    find_lex $P5384, "$key"
    set $S5385, $P5384
    iseq $I5386, $S5385, "open"
    unless $I5386, if_5383_end
.annotate 'line', 2004

                null $P0
                set_hll_global ['Regex';'P6Regex';'Actions'], '$REGEXNAME', $P0
            
.annotate 'line', 2008
    get_global $P5387, "@BLOCK"
    unless_null $P5387, vivify_2122
    $P5387 = root_new ['parrot';'ResizablePMCArray']
  vivify_2122:
    set $P5388, $P5387[0]
    unless_null $P5388, vivify_2123
    new $P5388, "Undef"
  vivify_2123:
    $P5388."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 2009
    get_global $P5389, "@BLOCK"
    unless_null $P5389, vivify_2124
    $P5389 = root_new ['parrot';'ResizablePMCArray']
  vivify_2124:
    set $P5390, $P5389[0]
    unless_null $P5390, vivify_2125
    new $P5390, "Undef"
  vivify_2125:
    $P5390."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 2010
    new $P5391, "Exception"
    set $P5391['type'], .CONTROL_RETURN
    new $P5392, "Integer"
    assign $P5392, 0
    setattribute $P5391, 'payload', $P5392
    throw $P5391
  if_5383_end:
.annotate 'line', 2013
    get_hll_global $P5393, ["Regex";"P6Regex";"Actions"], "buildsub"
    find_lex $P5394, "$/"
    unless_null $P5394, vivify_2126
    $P5394 = root_new ['parrot';'Hash']
  vivify_2126:
    set $P5395, $P5394["p6regex"]
    unless_null $P5395, vivify_2127
    new $P5395, "Undef"
  vivify_2127:
    $P5396 = $P5395."ast"()
    get_global $P5397, "@BLOCK"
    $P5398 = $P5397."shift"()
    $P5399 = $P5393($P5396, $P5398)
    store_lex "$regex", $P5399
.annotate 'line', 2015
    get_hll_global $P5400, ["PAST"], "Op"
.annotate 'line', 2017
    get_hll_global $P5401, ["PAST"], "Var"
    new $P5402, "ResizablePMCArray"
    push $P5402, "Regex"
    $P5403 = $P5401."new"("Regex" :named("name"), $P5402 :named("namespace"), "package" :named("scope"))
    find_lex $P5404, "$regex"
    $P5405 = $P5400."new"($P5403, $P5404, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 2015
    store_lex "$past", $P5405
.annotate 'line', 2021
    find_lex $P5406, "$regex"
    find_lex $P5407, "$past"
    unless_null $P5407, vivify_2128
    $P5407 = root_new ['parrot';'Hash']
    store_lex "$past", $P5407
  vivify_2128:
    set $P5407["sink"], $P5406
.annotate 'line', 2022
    find_lex $P5408, "$/"
    find_lex $P5409, "$past"
    $P5410 = $P5408."!make"($P5409)
.annotate 'line', 2002
    .return ($P5410)
  control_5375:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5411, exception, "payload"
    .return ($P5411)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<$>"  :subid("546_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_5413
    .param pmc param_5414
.annotate 'line', 2025
    .lex "self", param_5413
    .lex "$/", param_5414
    find_lex $P5415, "$/"
    find_lex $P5416, "$/"
    unless_null $P5416, vivify_2129
    $P5416 = root_new ['parrot';'Hash']
  vivify_2129:
    set $P5417, $P5416["variable"]
    unless_null $P5417, vivify_2130
    new $P5417, "Undef"
  vivify_2130:
    $P5418 = $P5417."ast"()
    $P5419 = $P5415."!make"($P5418)
    .return ($P5419)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<{ }>"  :subid("547_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_5421
    .param pmc param_5422
.annotate 'line', 2026
    .lex "self", param_5421
    .lex "$/", param_5422
.annotate 'line', 2027
    find_lex $P5423, "$/"
    get_hll_global $P5424, ["PAST"], "Op"
.annotate 'line', 2028
    find_lex $P5425, "$/"
    unless_null $P5425, vivify_2131
    $P5425 = root_new ['parrot';'Hash']
  vivify_2131:
    set $P5426, $P5425["block"]
    unless_null $P5426, vivify_2132
    new $P5426, "Undef"
  vivify_2132:
    $P5427 = $P5426."ast"()
    $P5428 = "block_immediate"($P5427)
    find_lex $P5429, "$/"
    $P5430 = $P5424."new"($P5428, "set S*" :named("pirop"), $P5429 :named("node"))
.annotate 'line', 2027
    $P5431 = $P5423."!make"($P5430)
.annotate 'line', 2026
    .return ($P5431)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<esc>"  :subid("548_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_5433
    .param pmc param_5434
.annotate 'line', 2031
    .lex "self", param_5433
    .lex "$/", param_5434
    find_lex $P5435, "$/"
    $P5436 = $P5435."!make"("\e")
    .return ($P5436)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<.>"  :subid("549_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_5438
    .param pmc param_5439
.annotate 'line', 2035
    .lex "self", param_5438
    .lex "$/", param_5439
    find_lex $P5440, "$/"
    find_lex $P5441, "$/"
    unless_null $P5441, vivify_2133
    $P5441 = root_new ['parrot';'Hash']
  vivify_2133:
    set $P5442, $P5441["dotty"]
    unless_null $P5442, vivify_2134
    new $P5442, "Undef"
  vivify_2134:
    $P5443 = $P5442."ast"()
    $P5444 = $P5440."!make"($P5443)
    .return ($P5444)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<++>"  :subid("550_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_5446
    .param pmc param_5447
.annotate 'line', 2037
    .lex "self", param_5446
    .lex "$/", param_5447
.annotate 'line', 2038
    find_lex $P5448, "$/"
    get_hll_global $P5449, ["PAST"], "Op"
.annotate 'line', 2039
    new $P5450, "ResizablePMCArray"
    push $P5450, "    clone %r, %0"
    push $P5450, "    inc %0"
    $P5451 = $P5449."new"("postfix:<++>" :named("name"), $P5450 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 2038
    $P5452 = $P5448."!make"($P5451)
.annotate 'line', 2037
    .return ($P5452)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<-->"  :subid("551_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_5454
    .param pmc param_5455
.annotate 'line', 2043
    .lex "self", param_5454
    .lex "$/", param_5455
.annotate 'line', 2044
    find_lex $P5456, "$/"
    get_hll_global $P5457, ["PAST"], "Op"
.annotate 'line', 2045
    new $P5458, "ResizablePMCArray"
    push $P5458, "    clone %r, %0"
    push $P5458, "    dec %0"
    $P5459 = $P5457."new"("postfix:<-->" :named("name"), $P5458 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 2044
    $P5460 = $P5456."!make"($P5459)
.annotate 'line', 2043
    .return ($P5460)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "prefix:sym<make>"  :subid("552_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_5462
    .param pmc param_5463
.annotate 'line', 2049
    .lex "self", param_5462
    .lex "$/", param_5463
.annotate 'line', 2050
    find_lex $P5464, "$/"
    get_hll_global $P5465, ["PAST"], "Op"
.annotate 'line', 2051
    get_hll_global $P5466, ["PAST"], "Var"
    $P5467 = $P5466."new"("$/" :named("name"), "contextual" :named("scope"))
    find_lex $P5468, "$/"
    $P5469 = $P5465."new"($P5467, "callmethod" :named("pasttype"), "!make" :named("name"), $P5468 :named("node"))
.annotate 'line', 2050
    $P5470 = $P5464."!make"($P5469)
.annotate 'line', 2049
    .return ($P5470)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<next>"  :subid("553_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_5473
    .param pmc param_5474
.annotate 'line', 2067
    .lex "self", param_5473
    .lex "$/", param_5474
    find_lex $P5475, "$/"
    $P5476 = "control"($P5475, "CONTROL_LOOP_NEXT")
    .return ($P5476)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<last>"  :subid("554_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_5478
    .param pmc param_5479
.annotate 'line', 2068
    .lex "self", param_5478
    .lex "$/", param_5479
    find_lex $P5480, "$/"
    $P5481 = "control"($P5480, "CONTROL_LOOP_LAST")
    .return ($P5481)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<redo>"  :subid("555_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_5483
    .param pmc param_5484
.annotate 'line', 2069
    .lex "self", param_5483
    .lex "$/", param_5484
    find_lex $P5485, "$/"
    $P5486 = "control"($P5485, "CONTROL_LOOP_REDO")
    .return ($P5486)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "infix:sym<~~>"  :subid("556_1302110486.758") :outer("405_1302110486.758")
    .param pmc param_5488
    .param pmc param_5489
.annotate 'line', 2071
    .lex "self", param_5488
    .lex "$/", param_5489
.annotate 'line', 2072
    find_lex $P5490, "$/"
    get_hll_global $P5491, ["PAST"], "Op"
    find_lex $P5492, "$/"
    $P5493 = $P5491."new"("callmethod" :named("pasttype"), "ACCEPTS" :named("name"), $P5492 :named("node"))
    $P5494 = $P5490."!make"($P5493)
.annotate 'line', 2071
    .return ($P5494)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "_block5719"  :subid("558_1302110486.758") :outer("10_1302110486.758")
.annotate 'line', 2076
    .const 'Sub' $P5819 = "566_1302110486.758" 
    capture_lex $P5819
    .const 'Sub' $P5794 = "565_1302110486.758" 
    capture_lex $P5794
    .const 'Sub' $P5783 = "564_1302110486.758" 
    capture_lex $P5783
    .const 'Sub' $P5768 = "563_1302110486.758" 
    capture_lex $P5768
    .const 'Sub' $P5757 = "562_1302110486.758" 
    capture_lex $P5757
    .const 'Sub' $P5746 = "561_1302110486.758" 
    capture_lex $P5746
    .const 'Sub' $P5735 = "560_1302110486.758" 
    capture_lex $P5735
    .const 'Sub' $P5722 = "559_1302110486.758" 
    capture_lex $P5722
    .lex "$?CLASS", $P5721
.annotate 'line', 2110
    .const 'Sub' $P5794 = "565_1302110486.758" 
    newclosure $P5817, $P5794
.annotate 'line', 2076
    .return ($P5817)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "" :load :init :subid("post2135") :outer("558_1302110486.758")
.annotate 'line', 2076
    get_hll_global $P5720, ["NQP";"RegexActions"], "_block5719" 
    .local pmc block
    set block, $P5720
    .const 'Sub' $P5819 = "566_1302110486.758" 
    capture_lex $P5819
    $P5819()
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "_block5818"  :anon :subid("566_1302110486.758") :outer("558_1302110486.758")
.annotate 'line', 2076
    nqp_get_sc_object $P5820, "1302110474.135", 3
    .local pmc type_obj
    set type_obj, $P5820
    get_how $P5821, type_obj
    .const 'Sub' $P5822 = "559_1302110486.758" 
    $P5821."add_method"(type_obj, "metachar:sym<:my>", $P5822)
    get_how $P5823, type_obj
    .const 'Sub' $P5824 = "560_1302110486.758" 
    $P5823."add_method"(type_obj, "metachar:sym<{ }>", $P5824)
    get_how $P5825, type_obj
    .const 'Sub' $P5826 = "561_1302110486.758" 
    $P5825."add_method"(type_obj, "metachar:sym<nqpvar>", $P5826)
    get_how $P5827, type_obj
    .const 'Sub' $P5828 = "562_1302110486.758" 
    $P5827."add_method"(type_obj, "assertion:sym<{ }>", $P5828)
    get_how $P5829, type_obj
    .const 'Sub' $P5830 = "563_1302110486.758" 
    $P5829."add_method"(type_obj, "assertion:sym<?{ }>", $P5830)
    get_how $P5831, type_obj
    .const 'Sub' $P5832 = "564_1302110486.758" 
    $P5831."add_method"(type_obj, "assertion:sym<var>", $P5832)
    get_how $P5833, type_obj
    .const 'Sub' $P5834 = "565_1302110486.758" 
    $P5833."add_method"(type_obj, "codeblock", $P5834)
    get_how $P5835, type_obj
    get_hll_global $P5836, ["Regex";"P6Regex"], "Actions"
    $P5835."add_parent"(type_obj, $P5836)
    get_how $P5837, type_obj
    $P5838 = $P5837."compose"(type_obj)
    .return ($P5838)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<:my>"  :subid("559_1302110486.758") :outer("558_1302110486.758")
    .param pmc param_5723
    .param pmc param_5724
.annotate 'line', 2078
    .lex "self", param_5723
    .lex "$/", param_5724
.annotate 'line', 2079
    new $P5725, "Undef"
    .lex "$past", $P5725
    find_lex $P5726, "$/"
    unless_null $P5726, vivify_2136
    $P5726 = root_new ['parrot';'Hash']
  vivify_2136:
    set $P5727, $P5726["statement"]
    unless_null $P5727, vivify_2137
    new $P5727, "Undef"
  vivify_2137:
    $P5728 = $P5727."ast"()
    store_lex "$past", $P5728
.annotate 'line', 2080
    find_lex $P5729, "$/"
    get_hll_global $P5730, ["PAST"], "Regex"
    find_lex $P5731, "$past"
    find_lex $P5732, "$/"
    $P5733 = $P5730."new"($P5731, "pastnode" :named("pasttype"), "declarative" :named("subtype"), $P5732 :named("node"))
    $P5734 = $P5729."!make"($P5733)
.annotate 'line', 2078
    .return ($P5734)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<{ }>"  :subid("560_1302110486.758") :outer("558_1302110486.758")
    .param pmc param_5736
    .param pmc param_5737
.annotate 'line', 2084
    .lex "self", param_5736
    .lex "$/", param_5737
.annotate 'line', 2085
    find_lex $P5738, "$/"
    get_hll_global $P5739, ["PAST"], "Regex"
    find_lex $P5740, "$/"
    unless_null $P5740, vivify_2138
    $P5740 = root_new ['parrot';'Hash']
  vivify_2138:
    set $P5741, $P5740["codeblock"]
    unless_null $P5741, vivify_2139
    new $P5741, "Undef"
  vivify_2139:
    $P5742 = $P5741."ast"()
    find_lex $P5743, "$/"
    $P5744 = $P5739."new"($P5742, "pastnode" :named("pasttype"), $P5743 :named("node"))
    $P5745 = $P5738."!make"($P5744)
.annotate 'line', 2084
    .return ($P5745)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<nqpvar>"  :subid("561_1302110486.758") :outer("558_1302110486.758")
    .param pmc param_5747
    .param pmc param_5748
.annotate 'line', 2089
    .lex "self", param_5747
    .lex "$/", param_5748
.annotate 'line', 2090
    find_lex $P5749, "$/"
    get_hll_global $P5750, ["PAST"], "Regex"
    find_lex $P5751, "$/"
    unless_null $P5751, vivify_2140
    $P5751 = root_new ['parrot';'Hash']
  vivify_2140:
    set $P5752, $P5751["var"]
    unless_null $P5752, vivify_2141
    new $P5752, "Undef"
  vivify_2141:
    $P5753 = $P5752."ast"()
    find_lex $P5754, "$/"
    $P5755 = $P5750."new"("!INTERPOLATE", $P5753, "subrule" :named("pasttype"), "method" :named("subtype"), $P5754 :named("node"))
    $P5756 = $P5749."!make"($P5755)
.annotate 'line', 2089
    .return ($P5756)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<{ }>"  :subid("562_1302110486.758") :outer("558_1302110486.758")
    .param pmc param_5758
    .param pmc param_5759
.annotate 'line', 2094
    .lex "self", param_5758
    .lex "$/", param_5759
.annotate 'line', 2095
    find_lex $P5760, "$/"
    get_hll_global $P5761, ["PAST"], "Regex"
    find_lex $P5762, "$/"
    unless_null $P5762, vivify_2142
    $P5762 = root_new ['parrot';'Hash']
  vivify_2142:
    set $P5763, $P5762["codeblock"]
    unless_null $P5763, vivify_2143
    new $P5763, "Undef"
  vivify_2143:
    $P5764 = $P5763."ast"()
    find_lex $P5765, "$/"
    $P5766 = $P5761."new"("!INTERPOLATE_REGEX", $P5764, "subrule" :named("pasttype"), "method" :named("subtype"), $P5765 :named("node"))
    $P5767 = $P5760."!make"($P5766)
.annotate 'line', 2094
    .return ($P5767)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<?{ }>"  :subid("563_1302110486.758") :outer("558_1302110486.758")
    .param pmc param_5769
    .param pmc param_5770
.annotate 'line', 2099
    .lex "self", param_5769
    .lex "$/", param_5770
.annotate 'line', 2100
    find_lex $P5771, "$/"
    get_hll_global $P5772, ["PAST"], "Regex"
    find_lex $P5773, "$/"
    unless_null $P5773, vivify_2144
    $P5773 = root_new ['parrot';'Hash']
  vivify_2144:
    set $P5774, $P5773["codeblock"]
    unless_null $P5774, vivify_2145
    new $P5774, "Undef"
  vivify_2145:
    $P5775 = $P5774."ast"()
.annotate 'line', 2101
    find_lex $P5776, "$/"
    unless_null $P5776, vivify_2146
    $P5776 = root_new ['parrot';'Hash']
  vivify_2146:
    set $P5777, $P5776["zw"]
    unless_null $P5777, vivify_2147
    new $P5777, "Undef"
  vivify_2147:
    set $S5778, $P5777
    iseq $I5779, $S5778, "!"
    find_lex $P5780, "$/"
    $P5781 = $P5772."new"($P5775, "zerowidth" :named("subtype"), $I5779 :named("negate"), "pastnode" :named("pasttype"), $P5780 :named("node"))
.annotate 'line', 2100
    $P5782 = $P5771."!make"($P5781)
.annotate 'line', 2099
    .return ($P5782)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<var>"  :subid("564_1302110486.758") :outer("558_1302110486.758")
    .param pmc param_5784
    .param pmc param_5785
.annotate 'line', 2105
    .lex "self", param_5784
    .lex "$/", param_5785
.annotate 'line', 2106
    find_lex $P5786, "$/"
    get_hll_global $P5787, ["PAST"], "Regex"
    find_lex $P5788, "$/"
    unless_null $P5788, vivify_2148
    $P5788 = root_new ['parrot';'Hash']
  vivify_2148:
    set $P5789, $P5788["var"]
    unless_null $P5789, vivify_2149
    new $P5789, "Undef"
  vivify_2149:
    $P5790 = $P5789."ast"()
    find_lex $P5791, "$/"
    $P5792 = $P5787."new"("!INTERPOLATE_REGEX", $P5790, "subrule" :named("pasttype"), "method" :named("subtype"), $P5791 :named("node"))
    $P5793 = $P5786."!make"($P5792)
.annotate 'line', 2105
    .return ($P5793)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "codeblock"  :subid("565_1302110486.758") :outer("558_1302110486.758")
    .param pmc param_5795
    .param pmc param_5796
.annotate 'line', 2110
    .lex "self", param_5795
    .lex "$/", param_5796
.annotate 'line', 2111
    new $P5797, "Undef"
    .lex "$block", $P5797
.annotate 'line', 2113
    new $P5798, "Undef"
    .lex "$past", $P5798
.annotate 'line', 2111
    find_lex $P5799, "$/"
    unless_null $P5799, vivify_2150
    $P5799 = root_new ['parrot';'Hash']
  vivify_2150:
    set $P5800, $P5799["block"]
    unless_null $P5800, vivify_2151
    new $P5800, "Undef"
  vivify_2151:
    $P5801 = $P5800."ast"()
    store_lex "$block", $P5801
.annotate 'line', 2112
    find_lex $P5802, "$block"
    $P5802."blocktype"("immediate")
.annotate 'line', 2114
    get_hll_global $P5803, ["PAST"], "Stmts"
.annotate 'line', 2115
    get_hll_global $P5804, ["PAST"], "Op"
.annotate 'line', 2116
    get_hll_global $P5805, ["PAST"], "Var"
    $P5806 = $P5805."new"("$/" :named("name"))
.annotate 'line', 2117
    get_hll_global $P5807, ["PAST"], "Op"
.annotate 'line', 2118
    get_hll_global $P5808, ["PAST"], "Var"
    $P5809 = $P5808."new"(unicode:"$\x{a2}" :named("name"))
    $P5810 = $P5807."new"($P5809, "MATCH" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 2117
    $P5811 = $P5804."new"($P5806, $P5810, "bind" :named("pasttype"))
.annotate 'line', 2115
    find_lex $P5812, "$block"
    $P5813 = $P5803."new"($P5811, $P5812)
.annotate 'line', 2114
    store_lex "$past", $P5813
.annotate 'line', 2126
    find_lex $P5814, "$/"
    find_lex $P5815, "$past"
    $P5816 = $P5814."!make"($P5815)
.annotate 'line', 2110
    .return ($P5816)
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "_block5839"  :subid("567_1302110486.758") :outer("10_1302110486.758")
.annotate 'line', 2131
    .const 'Sub' $P5843 = "568_1302110486.758" 
    capture_lex $P5843
    .lex "$?CLASS", $P5841
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "" :load :init :subid("post2152") :outer("567_1302110486.758")
.annotate 'line', 2131
    get_hll_global $P5840, ["NQP";"Compiler"], "_block5839" 
    .local pmc block
    set block, $P5840
    .const 'Sub' $P5843 = "568_1302110486.758" 
    capture_lex $P5843
    $P5843()
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "_block5842"  :anon :subid("568_1302110486.758") :outer("567_1302110486.758")
.annotate 'line', 2131
    nqp_get_sc_object $P5844, "1302110474.135", 4
    .local pmc type_obj
    set type_obj, $P5844
    get_how $P5845, type_obj
    get_hll_global $P5846, ["HLL"], "Compiler"
    $P5845."add_parent"(type_obj, $P5846)
    get_how $P5847, type_obj
    $P5848 = $P5847."compose"(type_obj)
    .return ($P5848)
.end


.HLL "nqp"

.namespace []
.sub "_block5856" :load :anon :subid("569_1302110486.758")
.annotate 'line', 1
    .const 'Sub' $P5858 = "10_1302110486.758" 
    $P5859 = $P5858()
    .return ($P5859)
.end

