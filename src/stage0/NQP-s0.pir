
.HLL "nqp"

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1300062003.824")
    .param pmc param_13 :slurpy
.annotate 'line', 0
    get_hll_global $P5822, ["NQP";"Compiler"], "_block5821" 
    capture_lex $P5822
    get_hll_global $P5702, ["NQP";"RegexActions"], "_block5701" 
    capture_lex $P5702
    get_hll_global $P2502, ["NQP";"Actions"], "_block2501" 
    capture_lex $P2502
    get_hll_global $P2399, ["NQP";"Regex"], "_block2398" 
    capture_lex $P2399
    get_hll_global $P34, ["NQP";"Grammar"], "_block33" 
    capture_lex $P34
    .const 'Sub' $P14 = "11_1300062003.824" 
    capture_lex $P14
.annotate 'line', 1
    .lex "@ARGS", param_13
.annotate 'line', 2128
    .const 'Sub' $P14 = "11_1300062003.824" 
    newclosure $P32, $P14
    .lex "MAIN", $P32
.annotate 'line', 1
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
.annotate 'line', 9
    get_hll_global $P34, ["NQP";"Grammar"], "_block33" 
    capture_lex $P34
    $P34()
.annotate 'line', 698
    get_hll_global $P2399, ["NQP";"Regex"], "_block2398" 
    capture_lex $P2399
    $P2399()
.annotate 'line', 741
    get_hll_global $P2502, ["NQP";"Actions"], "_block2501" 
    capture_lex $P2502
    $P2502()
.annotate 'line', 2070
    get_hll_global $P5702, ["NQP";"RegexActions"], "_block5701" 
    capture_lex $P5702
    $P5702()
.annotate 'line', 2125
    get_hll_global $P5822, ["NQP";"Compiler"], "_block5821" 
    capture_lex $P5822
    $P5822()
    find_lex $P5831, "MAIN"
    .const 'Sub' $P5832 = "11_1300062003.824" 
    find_lex $P5833, "@ARGS"
    $P5834 = $P5832($P5833 :flat)
.annotate 'line', 1
    .return ($P5834)
    .const 'Sub' $P5836 = "569_1300062003.824" 
    .return ($P5836)
.end


.HLL "nqp"

.namespace []
.sub "" :load :init :subid("post570") :outer("10_1300062003.824")
.annotate 'line', 0
    .const 'Sub' $P12 = "10_1300062003.824" 
    .local pmc block
    set block, $P12
    nqp_get_sc $P5840, "1300061983.846"
    isnull $I5841, $P5840
    if $I5841, if_5839
    nqp_get_sc_object $P5863, "1300061983.846", 0
    set_hll_global ["NQP"], "Grammar", $P5863
    nqp_get_sc_object $P5864, "1300061983.846", 1
    set_hll_global ["NQP"], "Regex", $P5864
    nqp_get_sc_object $P5865, "1300061983.846", 2
    set_hll_global ["NQP"], "Actions", $P5865
    nqp_get_sc_object $P5866, "1300061983.846", 3
    set_hll_global ["NQP"], "RegexActions", $P5866
    nqp_get_sc_object $P5867, "1300061983.846", 4
    set_hll_global ["NQP"], "Compiler", $P5867
    goto if_5839_end
  if_5839:
    nqp_dynop_setup 
    getinterp $P5842
    get_class $P5843, "LexPad"
    get_class $P5844, "NQPLexPad"
    $P5842."hll_map"($P5843, $P5844)
    load_bytecode "nqpmo.pbc"
    nqp_create_sc $P5845, "1300061983.846"
    .local pmc cur_sc
    set cur_sc, $P5845
    load_bytecode "SettingManager.pbc"
    get_hll_global $P5846, ["HLL"], "SettingManager"
    $P5847 = $P5846."load_setting"("NQPCORE")
    block."set_outer_ctx"($P5847)
    load_bytecode "P6Regex.pbc"
    get_hll_global $P5848, "NQPClassHOW"
    $P5849 = $P5848."new_type"("NQP::Grammar" :named("name"))
    nqp_set_sc_for_object $P5849, cur_sc
    nqp_set_sc_object "1300061983.846", 0, $P5849
    nqp_get_sc_object $P5850, "1300061983.846", 0
    set_hll_global ["NQP"], "Grammar", $P5850
    get_hll_global $P5851, "NQPClassHOW"
    $P5852 = $P5851."new_type"("NQP::Regex" :named("name"))
    nqp_set_sc_for_object $P5852, cur_sc
    nqp_set_sc_object "1300061983.846", 1, $P5852
    nqp_get_sc_object $P5853, "1300061983.846", 1
    set_hll_global ["NQP"], "Regex", $P5853
    get_hll_global $P5854, "NQPClassHOW"
    $P5855 = $P5854."new_type"("NQP::Actions" :named("name"))
    nqp_set_sc_for_object $P5855, cur_sc
    nqp_set_sc_object "1300061983.846", 2, $P5855
    nqp_get_sc_object $P5856, "1300061983.846", 2
    set_hll_global ["NQP"], "Actions", $P5856
    get_hll_global $P5857, "NQPClassHOW"
    $P5858 = $P5857."new_type"("NQP::RegexActions" :named("name"))
    nqp_set_sc_for_object $P5858, cur_sc
    nqp_set_sc_object "1300061983.846", 3, $P5858
    nqp_get_sc_object $P5859, "1300061983.846", 3
    set_hll_global ["NQP"], "RegexActions", $P5859
    get_hll_global $P5860, "NQPClassHOW"
    $P5861 = $P5860."new_type"("NQP::Compiler" :named("name"))
    nqp_set_sc_for_object $P5861, cur_sc
    nqp_set_sc_object "1300061983.846", 4, $P5861
    nqp_get_sc_object $P5862, "1300061983.846", 4
    set_hll_global ["NQP"], "Compiler", $P5862
  if_5839_end:
.end


.HLL "nqp"

.namespace []
.sub "MAIN"  :subid("11_1300062003.824") :outer("10_1300062003.824")
    .param pmc param_15
.annotate 'line', 2128
    .lex "@ARGS", param_15
.annotate 'line', 2130
    new $P16, "Undef"
    .lex "$nqpcomp", $P16
.annotate 'line', 2136
    $P17 = root_new ['parrot';'ResizablePMCArray']
    .lex "@clo", $P17
.annotate 'line', 2130
    get_hll_global $P18, ["NQP"], "Compiler"
    $P19 = $P18."new"()
    store_lex "$nqpcomp", $P19
.annotate 'line', 2131
    find_lex $P20, "$nqpcomp"
    $P20."language"("nqp")
.annotate 'line', 2132
    find_lex $P21, "$nqpcomp"
    get_hll_global $P22, ["NQP"], "Grammar"
    $P21."parsegrammar"($P22)
.annotate 'line', 2133
    find_lex $P23, "$nqpcomp"
    get_hll_global $P24, ["NQP"], "Actions"
    $P23."parseactions"($P24)
.annotate 'line', 2136
    find_lex $P25, "$nqpcomp"
    $P26 = $P25."commandline_options"()
    store_lex "@clo", $P26
.annotate 'line', 2137
    find_lex $P27, "@clo"
    $P27."push"("parsetrace")
.annotate 'line', 2138
    find_lex $P28, "@clo"
    $P28."push"("setting=s")
.annotate 'line', 2141
    find_lex $P29, "$nqpcomp"
    find_lex $P30, "@ARGS"
    $P31 = $P29."command_line"($P30, "utf8" :named("encoding"), "ascii iso-8859-1" :named("transcode"))
.annotate 'line', 2128
    .return ($P31)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block33"  :subid("12_1300062003.824") :outer("10_1300062003.824")
.annotate 'line', 9
    .const 'Sub' $P1680 = "382_1300062003.824" 
    capture_lex $P1680
    .const 'Sub' $P1667 = "381_1300062003.824" 
    capture_lex $P1667
    .const 'Sub' $P1661 = "379_1300062003.824" 
    capture_lex $P1661
    .const 'Sub' $P1655 = "377_1300062003.824" 
    capture_lex $P1655
    .const 'Sub' $P1649 = "375_1300062003.824" 
    capture_lex $P1649
    .const 'Sub' $P1643 = "373_1300062003.824" 
    capture_lex $P1643
    .const 'Sub' $P1631 = "370_1300062003.824" 
    capture_lex $P1631
    .const 'Sub' $P1624 = "368_1300062003.824" 
    capture_lex $P1624
    .const 'Sub' $P1617 = "366_1300062003.824" 
    capture_lex $P1617
    .const 'Sub' $P1610 = "364_1300062003.824" 
    capture_lex $P1610
    .const 'Sub' $P1603 = "362_1300062003.824" 
    capture_lex $P1603
    .const 'Sub' $P1597 = "360_1300062003.824" 
    capture_lex $P1597
    .const 'Sub' $P1590 = "358_1300062003.824" 
    capture_lex $P1590
    .const 'Sub' $P1583 = "356_1300062003.824" 
    capture_lex $P1583
    .const 'Sub' $P1576 = "354_1300062003.824" 
    capture_lex $P1576
    .const 'Sub' $P1569 = "352_1300062003.824" 
    capture_lex $P1569
    .const 'Sub' $P1562 = "350_1300062003.824" 
    capture_lex $P1562
    .const 'Sub' $P1555 = "348_1300062003.824" 
    capture_lex $P1555
    .const 'Sub' $P1548 = "346_1300062003.824" 
    capture_lex $P1548
    .const 'Sub' $P1541 = "344_1300062003.824" 
    capture_lex $P1541
    .const 'Sub' $P1534 = "342_1300062003.824" 
    capture_lex $P1534
    .const 'Sub' $P1527 = "340_1300062003.824" 
    capture_lex $P1527
    .const 'Sub' $P1520 = "338_1300062003.824" 
    capture_lex $P1520
    .const 'Sub' $P1513 = "336_1300062003.824" 
    capture_lex $P1513
    .const 'Sub' $P1506 = "334_1300062003.824" 
    capture_lex $P1506
    .const 'Sub' $P1499 = "332_1300062003.824" 
    capture_lex $P1499
    .const 'Sub' $P1492 = "330_1300062003.824" 
    capture_lex $P1492
    .const 'Sub' $P1485 = "328_1300062003.824" 
    capture_lex $P1485
    .const 'Sub' $P1478 = "326_1300062003.824" 
    capture_lex $P1478
    .const 'Sub' $P1471 = "324_1300062003.824" 
    capture_lex $P1471
    .const 'Sub' $P1464 = "322_1300062003.824" 
    capture_lex $P1464
    .const 'Sub' $P1457 = "320_1300062003.824" 
    capture_lex $P1457
    .const 'Sub' $P1450 = "318_1300062003.824" 
    capture_lex $P1450
    .const 'Sub' $P1443 = "316_1300062003.824" 
    capture_lex $P1443
    .const 'Sub' $P1436 = "314_1300062003.824" 
    capture_lex $P1436
    .const 'Sub' $P1429 = "312_1300062003.824" 
    capture_lex $P1429
    .const 'Sub' $P1422 = "310_1300062003.824" 
    capture_lex $P1422
    .const 'Sub' $P1415 = "308_1300062003.824" 
    capture_lex $P1415
    .const 'Sub' $P1408 = "306_1300062003.824" 
    capture_lex $P1408
    .const 'Sub' $P1401 = "304_1300062003.824" 
    capture_lex $P1401
    .const 'Sub' $P1394 = "302_1300062003.824" 
    capture_lex $P1394
    .const 'Sub' $P1388 = "300_1300062003.824" 
    capture_lex $P1388
    .const 'Sub' $P1381 = "298_1300062003.824" 
    capture_lex $P1381
    .const 'Sub' $P1374 = "296_1300062003.824" 
    capture_lex $P1374
    .const 'Sub' $P1367 = "294_1300062003.824" 
    capture_lex $P1367
    .const 'Sub' $P1360 = "292_1300062003.824" 
    capture_lex $P1360
    .const 'Sub' $P1353 = "290_1300062003.824" 
    capture_lex $P1353
    .const 'Sub' $P1346 = "288_1300062003.824" 
    capture_lex $P1346
    .const 'Sub' $P1339 = "286_1300062003.824" 
    capture_lex $P1339
    .const 'Sub' $P1333 = "284_1300062003.824" 
    capture_lex $P1333
    .const 'Sub' $P1327 = "282_1300062003.824" 
    capture_lex $P1327
    .const 'Sub' $P1322 = "280_1300062003.824" 
    capture_lex $P1322
    .const 'Sub' $P1316 = "278_1300062003.824" 
    capture_lex $P1316
    .const 'Sub' $P1310 = "276_1300062003.824" 
    capture_lex $P1310
    .const 'Sub' $P1305 = "274_1300062003.824" 
    capture_lex $P1305
    .const 'Sub' $P1300 = "272_1300062003.824" 
    capture_lex $P1300
    .const 'Sub' $P1284 = "271_1300062003.824" 
    capture_lex $P1284
    .const 'Sub' $P1275 = "269_1300062003.824" 
    capture_lex $P1275
    .const 'Sub' $P1266 = "267_1300062003.824" 
    capture_lex $P1266
    .const 'Sub' $P1261 = "265_1300062003.824" 
    capture_lex $P1261
    .const 'Sub' $P1256 = "263_1300062003.824" 
    capture_lex $P1256
    .const 'Sub' $P1251 = "261_1300062003.824" 
    capture_lex $P1251
    .const 'Sub' $P1243 = "259_1300062003.824" 
    capture_lex $P1243
    .const 'Sub' $P1235 = "257_1300062003.824" 
    capture_lex $P1235
    .const 'Sub' $P1230 = "255_1300062003.824" 
    capture_lex $P1230
    .const 'Sub' $P1225 = "253_1300062003.824" 
    capture_lex $P1225
    .const 'Sub' $P1220 = "251_1300062003.824" 
    capture_lex $P1220
    .const 'Sub' $P1214 = "249_1300062003.824" 
    capture_lex $P1214
    .const 'Sub' $P1208 = "247_1300062003.824" 
    capture_lex $P1208
    .const 'Sub' $P1202 = "245_1300062003.824" 
    capture_lex $P1202
    .const 'Sub' $P1196 = "243_1300062003.824" 
    capture_lex $P1196
    .const 'Sub' $P1190 = "241_1300062003.824" 
    capture_lex $P1190
    .const 'Sub' $P1185 = "239_1300062003.824" 
    capture_lex $P1185
    .const 'Sub' $P1180 = "237_1300062003.824" 
    capture_lex $P1180
    .const 'Sub' $P1166 = "233_1300062003.824" 
    capture_lex $P1166
    .const 'Sub' $P1158 = "231_1300062003.824" 
    capture_lex $P1158
    .const 'Sub' $P1152 = "229_1300062003.824" 
    capture_lex $P1152
    .const 'Sub' $P1145 = "227_1300062003.824" 
    capture_lex $P1145
    .const 'Sub' $P1139 = "225_1300062003.824" 
    capture_lex $P1139
    .const 'Sub' $P1125 = "222_1300062003.824" 
    capture_lex $P1125
    .const 'Sub' $P1117 = "220_1300062003.824" 
    capture_lex $P1117
    .const 'Sub' $P1109 = "218_1300062003.824" 
    capture_lex $P1109
    .const 'Sub' $P1103 = "216_1300062003.824" 
    capture_lex $P1103
    .const 'Sub' $P1097 = "214_1300062003.824" 
    capture_lex $P1097
    .const 'Sub' $P1081 = "210_1300062003.824" 
    capture_lex $P1081
    .const 'Sub' $P1040 = "208_1300062003.824" 
    capture_lex $P1040
    .const 'Sub' $P1029 = "206_1300062003.824" 
    capture_lex $P1029
    .const 'Sub' $P1015 = "202_1300062003.824" 
    capture_lex $P1015
    .const 'Sub' $P1006 = "200_1300062003.824" 
    capture_lex $P1006
    .const 'Sub' $P1000 = "198_1300062003.824" 
    capture_lex $P1000
    .const 'Sub' $P990 = "196_1300062003.824" 
    capture_lex $P990
    .const 'Sub' $P975 = "194_1300062003.824" 
    capture_lex $P975
    .const 'Sub' $P961 = "191_1300062003.824" 
    capture_lex $P961
    .const 'Sub' $P953 = "189_1300062003.824" 
    capture_lex $P953
    .const 'Sub' $P943 = "187_1300062003.824" 
    capture_lex $P943
    .const 'Sub' $P933 = "185_1300062003.824" 
    capture_lex $P933
    .const 'Sub' $P914 = "180_1300062003.824" 
    capture_lex $P914
    .const 'Sub' $P870 = "177_1300062003.824" 
    capture_lex $P870
    .const 'Sub' $P836 = "175_1300062003.824" 
    capture_lex $P836
    .const 'Sub' $P829 = "173_1300062003.824" 
    capture_lex $P829
    .const 'Sub' $P822 = "171_1300062003.824" 
    capture_lex $P822
    .const 'Sub' $P805 = "167_1300062003.824" 
    capture_lex $P805
    .const 'Sub' $P797 = "165_1300062003.824" 
    capture_lex $P797
    .const 'Sub' $P791 = "163_1300062003.824" 
    capture_lex $P791
    .const 'Sub' $P775 = "161_1300062003.824" 
    capture_lex $P775
    .const 'Sub' $P768 = "159_1300062003.824" 
    capture_lex $P768
    .const 'Sub' $P761 = "157_1300062003.824" 
    capture_lex $P761
    .const 'Sub' $P754 = "155_1300062003.824" 
    capture_lex $P754
    .const 'Sub' $P676 = "150_1300062003.824" 
    capture_lex $P676
    .const 'Sub' $P664 = "148_1300062003.824" 
    capture_lex $P664
    .const 'Sub' $P652 = "146_1300062003.824" 
    capture_lex $P652
    .const 'Sub' $P640 = "144_1300062003.824" 
    capture_lex $P640
    .const 'Sub' $P628 = "142_1300062003.824" 
    capture_lex $P628
    .const 'Sub' $P616 = "140_1300062003.824" 
    capture_lex $P616
    .const 'Sub' $P604 = "138_1300062003.824" 
    capture_lex $P604
    .const 'Sub' $P593 = "134_1300062003.824" 
    capture_lex $P593
    .const 'Sub' $P588 = "132_1300062003.824" 
    capture_lex $P588
    .const 'Sub' $P576 = "130_1300062003.824" 
    capture_lex $P576
    .const 'Sub' $P564 = "128_1300062003.824" 
    capture_lex $P564
    .const 'Sub' $P557 = "126_1300062003.824" 
    capture_lex $P557
    .const 'Sub' $P552 = "124_1300062003.824" 
    capture_lex $P552
    .const 'Sub' $P546 = "122_1300062003.824" 
    capture_lex $P546
    .const 'Sub' $P540 = "120_1300062003.824" 
    capture_lex $P540
    .const 'Sub' $P525 = "116_1300062003.824" 
    capture_lex $P525
    .const 'Sub' $P519 = "114_1300062003.824" 
    capture_lex $P519
    .const 'Sub' $P513 = "112_1300062003.824" 
    capture_lex $P513
    .const 'Sub' $P507 = "110_1300062003.824" 
    capture_lex $P507
    .const 'Sub' $P501 = "108_1300062003.824" 
    capture_lex $P501
    .const 'Sub' $P495 = "106_1300062003.824" 
    capture_lex $P495
    .const 'Sub' $P489 = "104_1300062003.824" 
    capture_lex $P489
    .const 'Sub' $P480 = "102_1300062003.824" 
    capture_lex $P480
    .const 'Sub' $P471 = "100_1300062003.824" 
    capture_lex $P471
    .const 'Sub' $P462 = "98_1300062003.824" 
    capture_lex $P462
    .const 'Sub' $P447 = "94_1300062003.824" 
    capture_lex $P447
    .const 'Sub' $P438 = "92_1300062003.824" 
    capture_lex $P438
    .const 'Sub' $P426 = "88_1300062003.824" 
    capture_lex $P426
    .const 'Sub' $P419 = "86_1300062003.824" 
    capture_lex $P419
    .const 'Sub' $P412 = "84_1300062003.824" 
    capture_lex $P412
    .const 'Sub' $P398 = "80_1300062003.824" 
    capture_lex $P398
    .const 'Sub' $P390 = "78_1300062003.824" 
    capture_lex $P390
    .const 'Sub' $P382 = "76_1300062003.824" 
    capture_lex $P382
    .const 'Sub' $P362 = "74_1300062003.824" 
    capture_lex $P362
    .const 'Sub' $P353 = "72_1300062003.824" 
    capture_lex $P353
    .const 'Sub' $P335 = "69_1300062003.824" 
    capture_lex $P335
    .const 'Sub' $P317 = "67_1300062003.824" 
    capture_lex $P317
    .const 'Sub' $P309 = "65_1300062003.824" 
    capture_lex $P309
    .const 'Sub' $P298 = "61_1300062003.824" 
    capture_lex $P298
    .const 'Sub' $P293 = "59_1300062003.824" 
    capture_lex $P293
    .const 'Sub' $P282 = "55_1300062003.824" 
    capture_lex $P282
    .const 'Sub' $P277 = "53_1300062003.824" 
    capture_lex $P277
    .const 'Sub' $P272 = "51_1300062003.824" 
    capture_lex $P272
    .const 'Sub' $P267 = "49_1300062003.824" 
    capture_lex $P267
    .const 'Sub' $P257 = "47_1300062003.824" 
    capture_lex $P257
    .const 'Sub' $P250 = "45_1300062003.824" 
    capture_lex $P250
    .const 'Sub' $P244 = "43_1300062003.824" 
    capture_lex $P244
    .const 'Sub' $P236 = "41_1300062003.824" 
    capture_lex $P236
    .const 'Sub' $P230 = "39_1300062003.824" 
    capture_lex $P230
    .const 'Sub' $P224 = "37_1300062003.824" 
    capture_lex $P224
    .const 'Sub' $P209 = "34_1300062003.824" 
    capture_lex $P209
    .const 'Sub' $P195 = "32_1300062003.824" 
    capture_lex $P195
    .const 'Sub' $P184 = "30_1300062003.824" 
    capture_lex $P184
    .const 'Sub' $P145 = "27_1300062003.824" 
    capture_lex $P145
    .const 'Sub' $P130 = "24_1300062003.824" 
    capture_lex $P130
    .const 'Sub' $P119 = "22_1300062003.824" 
    capture_lex $P119
    .const 'Sub' $P107 = "20_1300062003.824" 
    capture_lex $P107
    .const 'Sub' $P99 = "18_1300062003.824" 
    capture_lex $P99
    .const 'Sub' $P92 = "16_1300062003.824" 
    capture_lex $P92
    .const 'Sub' $P85 = "14_1300062003.824" 
    capture_lex $P85
    .const 'Sub' $P36 = "13_1300062003.824" 
    capture_lex $P36
    get_global $P35, "$?CLASS"
.annotate 'line', 10
    .const 'Sub' $P1284 = "271_1300062003.824" 
    capture_lex $P1284
    $P1284()
.annotate 'line', 692
    .const 'Sub' $P1667 = "381_1300062003.824" 
    newclosure $P1678, $P1667
.annotate 'line', 9
    .return ($P1678)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "" :load :init :subid("post571") :outer("12_1300062003.824")
.annotate 'line', 9
    get_hll_global $P34, ["NQP";"Grammar"], "_block33" 
    .local pmc block
    set block, $P34
    .const 'Sub' $P1680 = "382_1300062003.824" 
    capture_lex $P1680
    $P1680()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1679"  :anon :subid("382_1300062003.824") :outer("12_1300062003.824")
.annotate 'line', 9
    nqp_get_sc_object $P1681, "1300061983.846", 0
    .local pmc type_obj
    set type_obj, $P1681
    set_global "$?CLASS", type_obj
    get_how $P1682, type_obj
    .const 'Sub' $P1683 = "13_1300062003.824" 
    $P1682."add_method"(type_obj, "TOP", $P1683)
    get_how $P1684, type_obj
    .const 'Sub' $P1685 = "14_1300062003.824" 
    $P1684."add_method"(type_obj, "identifier", $P1685)
    get_how $P1686, type_obj
    get_global $P1687, "!PREFIX__identifier"
    $P1686."add_method"(type_obj, "!PREFIX__identifier", $P1687)
    get_how $P1688, type_obj
    .const 'Sub' $P1689 = "16_1300062003.824" 
    $P1688."add_method"(type_obj, "name", $P1689)
    get_how $P1690, type_obj
    get_global $P1691, "!PREFIX__name"
    $P1690."add_method"(type_obj, "!PREFIX__name", $P1691)
    get_how $P1692, type_obj
    .const 'Sub' $P1693 = "18_1300062003.824" 
    $P1692."add_method"(type_obj, "deflongname", $P1693)
    get_how $P1694, type_obj
    get_global $P1695, "!PREFIX__deflongname"
    $P1694."add_method"(type_obj, "!PREFIX__deflongname", $P1695)
    get_how $P1696, type_obj
    .const 'Sub' $P1697 = "20_1300062003.824" 
    $P1696."add_method"(type_obj, "ENDSTMT", $P1697)
    get_how $P1698, type_obj
    get_global $P1699, "!PREFIX__ENDSTMT"
    $P1698."add_method"(type_obj, "!PREFIX__ENDSTMT", $P1699)
    get_how $P1700, type_obj
    .const 'Sub' $P1701 = "22_1300062003.824" 
    $P1700."add_method"(type_obj, "ws", $P1701)
    get_how $P1702, type_obj
    get_global $P1703, "!PREFIX__ws"
    $P1702."add_method"(type_obj, "!PREFIX__ws", $P1703)
    get_how $P1704, type_obj
    .const 'Sub' $P1705 = "24_1300062003.824" 
    $P1704."add_method"(type_obj, "unv", $P1705)
    get_how $P1706, type_obj
    get_global $P1707, "!PREFIX__unv"
    $P1706."add_method"(type_obj, "!PREFIX__unv", $P1707)
    get_how $P1708, type_obj
    .const 'Sub' $P1709 = "27_1300062003.824" 
    $P1708."add_method"(type_obj, "pod_comment", $P1709)
    get_how $P1710, type_obj
    get_global $P1711, "!PREFIX__pod_comment"
    $P1710."add_method"(type_obj, "!PREFIX__pod_comment", $P1711)
    get_how $P1712, type_obj
    .const 'Sub' $P1713 = "30_1300062003.824" 
    $P1712."add_method"(type_obj, "comp_unit", $P1713)
    get_how $P1714, type_obj
    get_global $P1715, "!PREFIX__comp_unit"
    $P1714."add_method"(type_obj, "!PREFIX__comp_unit", $P1715)
    get_how $P1716, type_obj
    .const 'Sub' $P1717 = "32_1300062003.824" 
    $P1716."add_method"(type_obj, "statementlist", $P1717)
    get_how $P1718, type_obj
    get_global $P1719, "!PREFIX__statementlist"
    $P1718."add_method"(type_obj, "!PREFIX__statementlist", $P1719)
    get_how $P1720, type_obj
    .const 'Sub' $P1721 = "34_1300062003.824" 
    $P1720."add_method"(type_obj, "statement", $P1721)
    get_how $P1722, type_obj
    get_global $P1723, "!PREFIX__statement"
    $P1722."add_method"(type_obj, "!PREFIX__statement", $P1723)
    get_how $P1724, type_obj
    .const 'Sub' $P1725 = "37_1300062003.824" 
    $P1724."add_method"(type_obj, "eat_terminator", $P1725)
    get_how $P1726, type_obj
    get_global $P1727, "!PREFIX__eat_terminator"
    $P1726."add_method"(type_obj, "!PREFIX__eat_terminator", $P1727)
    get_how $P1728, type_obj
    .const 'Sub' $P1729 = "39_1300062003.824" 
    $P1728."add_method"(type_obj, "xblock", $P1729)
    get_how $P1730, type_obj
    get_global $P1731, "!PREFIX__xblock"
    $P1730."add_method"(type_obj, "!PREFIX__xblock", $P1731)
    get_how $P1732, type_obj
    .const 'Sub' $P1733 = "41_1300062003.824" 
    $P1732."add_method"(type_obj, "pblock", $P1733)
    get_how $P1734, type_obj
    get_global $P1735, "!PREFIX__pblock"
    $P1734."add_method"(type_obj, "!PREFIX__pblock", $P1735)
    get_how $P1736, type_obj
    .const 'Sub' $P1737 = "43_1300062003.824" 
    $P1736."add_method"(type_obj, "lambda", $P1737)
    get_how $P1738, type_obj
    get_global $P1739, "!PREFIX__lambda"
    $P1738."add_method"(type_obj, "!PREFIX__lambda", $P1739)
    get_how $P1740, type_obj
    .const 'Sub' $P1741 = "45_1300062003.824" 
    $P1740."add_method"(type_obj, "block", $P1741)
    get_how $P1742, type_obj
    get_global $P1743, "!PREFIX__block"
    $P1742."add_method"(type_obj, "!PREFIX__block", $P1743)
    get_how $P1744, type_obj
    .const 'Sub' $P1745 = "47_1300062003.824" 
    $P1744."add_method"(type_obj, "blockoid", $P1745)
    get_how $P1746, type_obj
    get_global $P1747, "!PREFIX__blockoid"
    $P1746."add_method"(type_obj, "!PREFIX__blockoid", $P1747)
    get_how $P1748, type_obj
    .const 'Sub' $P1749 = "49_1300062003.824" 
    $P1748."add_method"(type_obj, "newpad", $P1749)
    get_how $P1750, type_obj
    get_global $P1751, "!PREFIX__newpad"
    $P1750."add_method"(type_obj, "!PREFIX__newpad", $P1751)
    get_how $P1752, type_obj
    .const 'Sub' $P1753 = "51_1300062003.824" 
    $P1752."add_method"(type_obj, "outerctx", $P1753)
    get_how $P1754, type_obj
    get_global $P1755, "!PREFIX__outerctx"
    $P1754."add_method"(type_obj, "!PREFIX__outerctx", $P1755)
    get_how $P1756, type_obj
    .const 'Sub' $P1757 = "53_1300062003.824" 
    $P1756."add_method"(type_obj, "finishpad", $P1757)
    get_how $P1758, type_obj
    get_global $P1759, "!PREFIX__finishpad"
    $P1758."add_method"(type_obj, "!PREFIX__finishpad", $P1759)
    get_how $P1760, type_obj
    .const 'Sub' $P1761 = "55_1300062003.824" 
    $P1760."add_method"(type_obj, "you_are_here", $P1761)
    get_how $P1762, type_obj
    get_global $P1763, "!PREFIX__you_are_here"
    $P1762."add_method"(type_obj, "!PREFIX__you_are_here", $P1763)
    get_how $P1764, type_obj
    .const 'Sub' $P1765 = "57_1300062003.824" 
    $P1764."add_method"(type_obj, "terminator", $P1765)
    get_how $P1766, type_obj
    .const 'Sub' $P1767 = "58_1300062003.824" 
    $P1766."add_method"(type_obj, "!PREFIX__terminator", $P1767)
    get_how $P1768, type_obj
    .const 'Sub' $P1769 = "59_1300062003.824" 
    $P1768."add_method"(type_obj, "terminator:sym<;>", $P1769)
    get_how $P1770, type_obj
    get_global $P1771, "!PREFIX__terminator:sym<;>"
    $P1770."add_method"(type_obj, "!PREFIX__terminator:sym<;>", $P1771)
    get_how $P1772, type_obj
    .const 'Sub' $P1773 = "61_1300062003.824" 
    $P1772."add_method"(type_obj, "terminator:sym<}>", $P1773)
    get_how $P1774, type_obj
    get_global $P1775, "!PREFIX__terminator:sym<}>"
    $P1774."add_method"(type_obj, "!PREFIX__terminator:sym<}>", $P1775)
    get_how $P1776, type_obj
    .const 'Sub' $P1777 = "63_1300062003.824" 
    $P1776."add_method"(type_obj, "statement_control", $P1777)
    get_how $P1778, type_obj
    .const 'Sub' $P1779 = "64_1300062003.824" 
    $P1778."add_method"(type_obj, "!PREFIX__statement_control", $P1779)
    get_how $P1780, type_obj
    .const 'Sub' $P1781 = "65_1300062003.824" 
    $P1780."add_method"(type_obj, "statement_control:sym<use>", $P1781)
    get_how $P1782, type_obj
    get_global $P1783, "!PREFIX__statement_control:sym<use>"
    $P1782."add_method"(type_obj, "!PREFIX__statement_control:sym<use>", $P1783)
    get_how $P1784, type_obj
    .const 'Sub' $P1785 = "67_1300062003.824" 
    $P1784."add_method"(type_obj, "statement_control:sym<if>", $P1785)
    get_how $P1786, type_obj
    get_global $P1787, "!PREFIX__statement_control:sym<if>"
    $P1786."add_method"(type_obj, "!PREFIX__statement_control:sym<if>", $P1787)
    get_how $P1788, type_obj
    .const 'Sub' $P1789 = "69_1300062003.824" 
    $P1788."add_method"(type_obj, "statement_control:sym<unless>", $P1789)
    get_how $P1790, type_obj
    get_global $P1791, "!PREFIX__statement_control:sym<unless>"
    $P1790."add_method"(type_obj, "!PREFIX__statement_control:sym<unless>", $P1791)
    get_how $P1792, type_obj
    .const 'Sub' $P1793 = "72_1300062003.824" 
    $P1792."add_method"(type_obj, "statement_control:sym<while>", $P1793)
    get_how $P1794, type_obj
    get_global $P1795, "!PREFIX__statement_control:sym<while>"
    $P1794."add_method"(type_obj, "!PREFIX__statement_control:sym<while>", $P1795)
    get_how $P1796, type_obj
    .const 'Sub' $P1797 = "74_1300062003.824" 
    $P1796."add_method"(type_obj, "statement_control:sym<repeat>", $P1797)
    get_how $P1798, type_obj
    get_global $P1799, "!PREFIX__statement_control:sym<repeat>"
    $P1798."add_method"(type_obj, "!PREFIX__statement_control:sym<repeat>", $P1799)
    get_how $P1800, type_obj
    .const 'Sub' $P1801 = "76_1300062003.824" 
    $P1800."add_method"(type_obj, "statement_control:sym<for>", $P1801)
    get_how $P1802, type_obj
    get_global $P1803, "!PREFIX__statement_control:sym<for>"
    $P1802."add_method"(type_obj, "!PREFIX__statement_control:sym<for>", $P1803)
    get_how $P1804, type_obj
    .const 'Sub' $P1805 = "78_1300062003.824" 
    $P1804."add_method"(type_obj, "statement_control:sym<CATCH>", $P1805)
    get_how $P1806, type_obj
    get_global $P1807, "!PREFIX__statement_control:sym<CATCH>"
    $P1806."add_method"(type_obj, "!PREFIX__statement_control:sym<CATCH>", $P1807)
    get_how $P1808, type_obj
    .const 'Sub' $P1809 = "80_1300062003.824" 
    $P1808."add_method"(type_obj, "statement_control:sym<CONTROL>", $P1809)
    get_how $P1810, type_obj
    get_global $P1811, "!PREFIX__statement_control:sym<CONTROL>"
    $P1810."add_method"(type_obj, "!PREFIX__statement_control:sym<CONTROL>", $P1811)
    get_how $P1812, type_obj
    .const 'Sub' $P1813 = "82_1300062003.824" 
    $P1812."add_method"(type_obj, "statement_prefix", $P1813)
    get_how $P1814, type_obj
    .const 'Sub' $P1815 = "83_1300062003.824" 
    $P1814."add_method"(type_obj, "!PREFIX__statement_prefix", $P1815)
    get_how $P1816, type_obj
    .const 'Sub' $P1817 = "84_1300062003.824" 
    $P1816."add_method"(type_obj, "statement_prefix:sym<INIT>", $P1817)
    get_how $P1818, type_obj
    get_global $P1819, "!PREFIX__statement_prefix:sym<INIT>"
    $P1818."add_method"(type_obj, "!PREFIX__statement_prefix:sym<INIT>", $P1819)
    get_how $P1820, type_obj
    .const 'Sub' $P1821 = "86_1300062003.824" 
    $P1820."add_method"(type_obj, "statement_prefix:sym<try>", $P1821)
    get_how $P1822, type_obj
    get_global $P1823, "!PREFIX__statement_prefix:sym<try>"
    $P1822."add_method"(type_obj, "!PREFIX__statement_prefix:sym<try>", $P1823)
    get_how $P1824, type_obj
    .const 'Sub' $P1825 = "88_1300062003.824" 
    $P1824."add_method"(type_obj, "blorst", $P1825)
    get_how $P1826, type_obj
    get_global $P1827, "!PREFIX__blorst"
    $P1826."add_method"(type_obj, "!PREFIX__blorst", $P1827)
    get_how $P1828, type_obj
    .const 'Sub' $P1829 = "90_1300062003.824" 
    $P1828."add_method"(type_obj, "statement_mod_cond", $P1829)
    get_how $P1830, type_obj
    .const 'Sub' $P1831 = "91_1300062003.824" 
    $P1830."add_method"(type_obj, "!PREFIX__statement_mod_cond", $P1831)
    get_how $P1832, type_obj
    .const 'Sub' $P1833 = "92_1300062003.824" 
    $P1832."add_method"(type_obj, "statement_mod_cond:sym<if>", $P1833)
    get_how $P1834, type_obj
    get_global $P1835, "!PREFIX__statement_mod_cond:sym<if>"
    $P1834."add_method"(type_obj, "!PREFIX__statement_mod_cond:sym<if>", $P1835)
    get_how $P1836, type_obj
    .const 'Sub' $P1837 = "94_1300062003.824" 
    $P1836."add_method"(type_obj, "statement_mod_cond:sym<unless>", $P1837)
    get_how $P1838, type_obj
    get_global $P1839, "!PREFIX__statement_mod_cond:sym<unless>"
    $P1838."add_method"(type_obj, "!PREFIX__statement_mod_cond:sym<unless>", $P1839)
    get_how $P1840, type_obj
    .const 'Sub' $P1841 = "96_1300062003.824" 
    $P1840."add_method"(type_obj, "statement_mod_loop", $P1841)
    get_how $P1842, type_obj
    .const 'Sub' $P1843 = "97_1300062003.824" 
    $P1842."add_method"(type_obj, "!PREFIX__statement_mod_loop", $P1843)
    get_how $P1844, type_obj
    .const 'Sub' $P1845 = "98_1300062003.824" 
    $P1844."add_method"(type_obj, "statement_mod_loop:sym<while>", $P1845)
    get_how $P1846, type_obj
    get_global $P1847, "!PREFIX__statement_mod_loop:sym<while>"
    $P1846."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<while>", $P1847)
    get_how $P1848, type_obj
    .const 'Sub' $P1849 = "100_1300062003.824" 
    $P1848."add_method"(type_obj, "statement_mod_loop:sym<until>", $P1849)
    get_how $P1850, type_obj
    get_global $P1851, "!PREFIX__statement_mod_loop:sym<until>"
    $P1850."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<until>", $P1851)
    get_how $P1852, type_obj
    .const 'Sub' $P1853 = "102_1300062003.824" 
    $P1852."add_method"(type_obj, "statement_mod_loop:sym<for>", $P1853)
    get_how $P1854, type_obj
    get_global $P1855, "!PREFIX__statement_mod_loop:sym<for>"
    $P1854."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<for>", $P1855)
    get_how $P1856, type_obj
    .const 'Sub' $P1857 = "104_1300062003.824" 
    $P1856."add_method"(type_obj, "term:sym<fatarrow>", $P1857)
    get_how $P1858, type_obj
    get_global $P1859, "!PREFIX__term:sym<fatarrow>"
    $P1858."add_method"(type_obj, "!PREFIX__term:sym<fatarrow>", $P1859)
    get_how $P1860, type_obj
    .const 'Sub' $P1861 = "106_1300062003.824" 
    $P1860."add_method"(type_obj, "term:sym<colonpair>", $P1861)
    get_how $P1862, type_obj
    get_global $P1863, "!PREFIX__term:sym<colonpair>"
    $P1862."add_method"(type_obj, "!PREFIX__term:sym<colonpair>", $P1863)
    get_how $P1864, type_obj
    .const 'Sub' $P1865 = "108_1300062003.824" 
    $P1864."add_method"(type_obj, "term:sym<variable>", $P1865)
    get_how $P1866, type_obj
    get_global $P1867, "!PREFIX__term:sym<variable>"
    $P1866."add_method"(type_obj, "!PREFIX__term:sym<variable>", $P1867)
    get_how $P1868, type_obj
    .const 'Sub' $P1869 = "110_1300062003.824" 
    $P1868."add_method"(type_obj, "term:sym<package_declarator>", $P1869)
    get_how $P1870, type_obj
    get_global $P1871, "!PREFIX__term:sym<package_declarator>"
    $P1870."add_method"(type_obj, "!PREFIX__term:sym<package_declarator>", $P1871)
    get_how $P1872, type_obj
    .const 'Sub' $P1873 = "112_1300062003.824" 
    $P1872."add_method"(type_obj, "term:sym<scope_declarator>", $P1873)
    get_how $P1874, type_obj
    get_global $P1875, "!PREFIX__term:sym<scope_declarator>"
    $P1874."add_method"(type_obj, "!PREFIX__term:sym<scope_declarator>", $P1875)
    get_how $P1876, type_obj
    .const 'Sub' $P1877 = "114_1300062003.824" 
    $P1876."add_method"(type_obj, "term:sym<routine_declarator>", $P1877)
    get_how $P1878, type_obj
    get_global $P1879, "!PREFIX__term:sym<routine_declarator>"
    $P1878."add_method"(type_obj, "!PREFIX__term:sym<routine_declarator>", $P1879)
    get_how $P1880, type_obj
    .const 'Sub' $P1881 = "116_1300062003.824" 
    $P1880."add_method"(type_obj, "term:sym<multi_declarator>", $P1881)
    get_how $P1882, type_obj
    get_global $P1883, "!PREFIX__term:sym<multi_declarator>"
    $P1882."add_method"(type_obj, "!PREFIX__term:sym<multi_declarator>", $P1883)
    get_how $P1884, type_obj
    .const 'Sub' $P1885 = "120_1300062003.824" 
    $P1884."add_method"(type_obj, "term:sym<regex_declarator>", $P1885)
    get_how $P1886, type_obj
    get_global $P1887, "!PREFIX__term:sym<regex_declarator>"
    $P1886."add_method"(type_obj, "!PREFIX__term:sym<regex_declarator>", $P1887)
    get_how $P1888, type_obj
    .const 'Sub' $P1889 = "122_1300062003.824" 
    $P1888."add_method"(type_obj, "term:sym<statement_prefix>", $P1889)
    get_how $P1890, type_obj
    get_global $P1891, "!PREFIX__term:sym<statement_prefix>"
    $P1890."add_method"(type_obj, "!PREFIX__term:sym<statement_prefix>", $P1891)
    get_how $P1892, type_obj
    .const 'Sub' $P1893 = "124_1300062003.824" 
    $P1892."add_method"(type_obj, "term:sym<lambda>", $P1893)
    get_how $P1894, type_obj
    get_global $P1895, "!PREFIX__term:sym<lambda>"
    $P1894."add_method"(type_obj, "!PREFIX__term:sym<lambda>", $P1895)
    get_how $P1896, type_obj
    .const 'Sub' $P1897 = "126_1300062003.824" 
    $P1896."add_method"(type_obj, "fatarrow", $P1897)
    get_how $P1898, type_obj
    get_global $P1899, "!PREFIX__fatarrow"
    $P1898."add_method"(type_obj, "!PREFIX__fatarrow", $P1899)
    get_how $P1900, type_obj
    .const 'Sub' $P1901 = "128_1300062003.824" 
    $P1900."add_method"(type_obj, "colonpair", $P1901)
    get_how $P1902, type_obj
    get_global $P1903, "!PREFIX__colonpair"
    $P1902."add_method"(type_obj, "!PREFIX__colonpair", $P1903)
    get_how $P1904, type_obj
    .const 'Sub' $P1905 = "130_1300062003.824" 
    $P1904."add_method"(type_obj, "variable", $P1905)
    get_how $P1906, type_obj
    get_global $P1907, "!PREFIX__variable"
    $P1906."add_method"(type_obj, "!PREFIX__variable", $P1907)
    get_how $P1908, type_obj
    .const 'Sub' $P1909 = "132_1300062003.824" 
    $P1908."add_method"(type_obj, "sigil", $P1909)
    get_how $P1910, type_obj
    get_global $P1911, "!PREFIX__sigil"
    $P1910."add_method"(type_obj, "!PREFIX__sigil", $P1911)
    get_how $P1912, type_obj
    .const 'Sub' $P1913 = "134_1300062003.824" 
    $P1912."add_method"(type_obj, "twigil", $P1913)
    get_how $P1914, type_obj
    get_global $P1915, "!PREFIX__twigil"
    $P1914."add_method"(type_obj, "!PREFIX__twigil", $P1915)
    get_how $P1916, type_obj
    .const 'Sub' $P1917 = "136_1300062003.824" 
    $P1916."add_method"(type_obj, "package_declarator", $P1917)
    get_how $P1918, type_obj
    .const 'Sub' $P1919 = "137_1300062003.824" 
    $P1918."add_method"(type_obj, "!PREFIX__package_declarator", $P1919)
    get_how $P1920, type_obj
    .const 'Sub' $P1921 = "138_1300062003.824" 
    $P1920."add_method"(type_obj, "package_declarator:sym<module>", $P1921)
    get_how $P1922, type_obj
    get_global $P1923, "!PREFIX__package_declarator:sym<module>"
    $P1922."add_method"(type_obj, "!PREFIX__package_declarator:sym<module>", $P1923)
    get_how $P1924, type_obj
    .const 'Sub' $P1925 = "140_1300062003.824" 
    $P1924."add_method"(type_obj, "package_declarator:sym<knowhow>", $P1925)
    get_how $P1926, type_obj
    get_global $P1927, "!PREFIX__package_declarator:sym<knowhow>"
    $P1926."add_method"(type_obj, "!PREFIX__package_declarator:sym<knowhow>", $P1927)
    get_how $P1928, type_obj
    .const 'Sub' $P1929 = "142_1300062003.824" 
    $P1928."add_method"(type_obj, "package_declarator:sym<class>", $P1929)
    get_how $P1930, type_obj
    get_global $P1931, "!PREFIX__package_declarator:sym<class>"
    $P1930."add_method"(type_obj, "!PREFIX__package_declarator:sym<class>", $P1931)
    get_how $P1932, type_obj
    .const 'Sub' $P1933 = "144_1300062003.824" 
    $P1932."add_method"(type_obj, "package_declarator:sym<grammar>", $P1933)
    get_how $P1934, type_obj
    get_global $P1935, "!PREFIX__package_declarator:sym<grammar>"
    $P1934."add_method"(type_obj, "!PREFIX__package_declarator:sym<grammar>", $P1935)
    get_how $P1936, type_obj
    .const 'Sub' $P1937 = "146_1300062003.824" 
    $P1936."add_method"(type_obj, "package_declarator:sym<role>", $P1937)
    get_how $P1938, type_obj
    get_global $P1939, "!PREFIX__package_declarator:sym<role>"
    $P1938."add_method"(type_obj, "!PREFIX__package_declarator:sym<role>", $P1939)
    get_how $P1940, type_obj
    .const 'Sub' $P1941 = "148_1300062003.824" 
    $P1940."add_method"(type_obj, "package_declarator:sym<native>", $P1941)
    get_how $P1942, type_obj
    get_global $P1943, "!PREFIX__package_declarator:sym<native>"
    $P1942."add_method"(type_obj, "!PREFIX__package_declarator:sym<native>", $P1943)
    get_how $P1944, type_obj
    .const 'Sub' $P1945 = "150_1300062003.824" 
    $P1944."add_method"(type_obj, "package_def", $P1945)
    get_how $P1946, type_obj
    get_global $P1947, "!PREFIX__package_def"
    $P1946."add_method"(type_obj, "!PREFIX__package_def", $P1947)
    get_how $P1948, type_obj
    .const 'Sub' $P1949 = "153_1300062003.824" 
    $P1948."add_method"(type_obj, "scope_declarator", $P1949)
    get_how $P1950, type_obj
    .const 'Sub' $P1951 = "154_1300062003.824" 
    $P1950."add_method"(type_obj, "!PREFIX__scope_declarator", $P1951)
    get_how $P1952, type_obj
    .const 'Sub' $P1953 = "155_1300062003.824" 
    $P1952."add_method"(type_obj, "scope_declarator:sym<my>", $P1953)
    get_how $P1954, type_obj
    get_global $P1955, "!PREFIX__scope_declarator:sym<my>"
    $P1954."add_method"(type_obj, "!PREFIX__scope_declarator:sym<my>", $P1955)
    get_how $P1956, type_obj
    .const 'Sub' $P1957 = "157_1300062003.824" 
    $P1956."add_method"(type_obj, "scope_declarator:sym<our>", $P1957)
    get_how $P1958, type_obj
    get_global $P1959, "!PREFIX__scope_declarator:sym<our>"
    $P1958."add_method"(type_obj, "!PREFIX__scope_declarator:sym<our>", $P1959)
    get_how $P1960, type_obj
    .const 'Sub' $P1961 = "159_1300062003.824" 
    $P1960."add_method"(type_obj, "scope_declarator:sym<has>", $P1961)
    get_how $P1962, type_obj
    get_global $P1963, "!PREFIX__scope_declarator:sym<has>"
    $P1962."add_method"(type_obj, "!PREFIX__scope_declarator:sym<has>", $P1963)
    get_how $P1964, type_obj
    .const 'Sub' $P1965 = "161_1300062003.824" 
    $P1964."add_method"(type_obj, "scoped", $P1965)
    get_how $P1966, type_obj
    get_global $P1967, "!PREFIX__scoped"
    $P1966."add_method"(type_obj, "!PREFIX__scoped", $P1967)
    get_how $P1968, type_obj
    .const 'Sub' $P1969 = "163_1300062003.824" 
    $P1968."add_method"(type_obj, "typename", $P1969)
    get_how $P1970, type_obj
    get_global $P1971, "!PREFIX__typename"
    $P1970."add_method"(type_obj, "!PREFIX__typename", $P1971)
    get_how $P1972, type_obj
    .const 'Sub' $P1973 = "165_1300062003.824" 
    $P1972."add_method"(type_obj, "declarator", $P1973)
    get_how $P1974, type_obj
    get_global $P1975, "!PREFIX__declarator"
    $P1974."add_method"(type_obj, "!PREFIX__declarator", $P1975)
    get_how $P1976, type_obj
    .const 'Sub' $P1977 = "167_1300062003.824" 
    $P1976."add_method"(type_obj, "variable_declarator", $P1977)
    get_how $P1978, type_obj
    get_global $P1979, "!PREFIX__variable_declarator"
    $P1978."add_method"(type_obj, "!PREFIX__variable_declarator", $P1979)
    get_how $P1980, type_obj
    .const 'Sub' $P1981 = "169_1300062003.824" 
    $P1980."add_method"(type_obj, "routine_declarator", $P1981)
    get_how $P1982, type_obj
    .const 'Sub' $P1983 = "170_1300062003.824" 
    $P1982."add_method"(type_obj, "!PREFIX__routine_declarator", $P1983)
    get_how $P1984, type_obj
    .const 'Sub' $P1985 = "171_1300062003.824" 
    $P1984."add_method"(type_obj, "routine_declarator:sym<sub>", $P1985)
    get_how $P1986, type_obj
    get_global $P1987, "!PREFIX__routine_declarator:sym<sub>"
    $P1986."add_method"(type_obj, "!PREFIX__routine_declarator:sym<sub>", $P1987)
    get_how $P1988, type_obj
    .const 'Sub' $P1989 = "173_1300062003.824" 
    $P1988."add_method"(type_obj, "routine_declarator:sym<method>", $P1989)
    get_how $P1990, type_obj
    get_global $P1991, "!PREFIX__routine_declarator:sym<method>"
    $P1990."add_method"(type_obj, "!PREFIX__routine_declarator:sym<method>", $P1991)
    get_how $P1992, type_obj
    .const 'Sub' $P1993 = "175_1300062003.824" 
    $P1992."add_method"(type_obj, "routine_def", $P1993)
    get_how $P1994, type_obj
    get_global $P1995, "!PREFIX__routine_def"
    $P1994."add_method"(type_obj, "!PREFIX__routine_def", $P1995)
    get_how $P1996, type_obj
    .const 'Sub' $P1997 = "177_1300062003.824" 
    $P1996."add_method"(type_obj, "method_def", $P1997)
    get_how $P1998, type_obj
    get_global $P1999, "!PREFIX__method_def"
    $P1998."add_method"(type_obj, "!PREFIX__method_def", $P1999)
    get_how $P2000, type_obj
    .const 'Sub' $P2001 = "180_1300062003.824" 
    $P2000."add_method"(type_obj, "onlystar", $P2001)
    get_how $P2002, type_obj
    get_global $P2003, "!PREFIX__onlystar"
    $P2002."add_method"(type_obj, "!PREFIX__onlystar", $P2003)
    get_how $P2004, type_obj
    .const 'Sub' $P2005 = "183_1300062003.824" 
    $P2004."add_method"(type_obj, "multi_declarator", $P2005)
    get_how $P2006, type_obj
    .const 'Sub' $P2007 = "184_1300062003.824" 
    $P2006."add_method"(type_obj, "!PREFIX__multi_declarator", $P2007)
    get_how $P2008, type_obj
    .const 'Sub' $P2009 = "185_1300062003.824" 
    $P2008."add_method"(type_obj, "multi_declarator:sym<multi>", $P2009)
    get_how $P2010, type_obj
    get_global $P2011, "!PREFIX__multi_declarator:sym<multi>"
    $P2010."add_method"(type_obj, "!PREFIX__multi_declarator:sym<multi>", $P2011)
    get_how $P2012, type_obj
    .const 'Sub' $P2013 = "187_1300062003.824" 
    $P2012."add_method"(type_obj, "multi_declarator:sym<proto>", $P2013)
    get_how $P2014, type_obj
    get_global $P2015, "!PREFIX__multi_declarator:sym<proto>"
    $P2014."add_method"(type_obj, "!PREFIX__multi_declarator:sym<proto>", $P2015)
    get_how $P2016, type_obj
    .const 'Sub' $P2017 = "189_1300062003.824" 
    $P2016."add_method"(type_obj, "multi_declarator:sym<null>", $P2017)
    get_how $P2018, type_obj
    get_global $P2019, "!PREFIX__multi_declarator:sym<null>"
    $P2018."add_method"(type_obj, "!PREFIX__multi_declarator:sym<null>", $P2019)
    get_how $P2020, type_obj
    .const 'Sub' $P2021 = "191_1300062003.824" 
    $P2020."add_method"(type_obj, "signature", $P2021)
    get_how $P2022, type_obj
    get_global $P2023, "!PREFIX__signature"
    $P2022."add_method"(type_obj, "!PREFIX__signature", $P2023)
    get_how $P2024, type_obj
    .const 'Sub' $P2025 = "194_1300062003.824" 
    $P2024."add_method"(type_obj, "parameter", $P2025)
    get_how $P2026, type_obj
    get_global $P2027, "!PREFIX__parameter"
    $P2026."add_method"(type_obj, "!PREFIX__parameter", $P2027)
    get_how $P2028, type_obj
    .const 'Sub' $P2029 = "196_1300062003.824" 
    $P2028."add_method"(type_obj, "param_var", $P2029)
    get_how $P2030, type_obj
    get_global $P2031, "!PREFIX__param_var"
    $P2030."add_method"(type_obj, "!PREFIX__param_var", $P2031)
    get_how $P2032, type_obj
    .const 'Sub' $P2033 = "198_1300062003.824" 
    $P2032."add_method"(type_obj, "named_param", $P2033)
    get_how $P2034, type_obj
    get_global $P2035, "!PREFIX__named_param"
    $P2034."add_method"(type_obj, "!PREFIX__named_param", $P2035)
    get_how $P2036, type_obj
    .const 'Sub' $P2037 = "200_1300062003.824" 
    $P2036."add_method"(type_obj, "default_value", $P2037)
    get_how $P2038, type_obj
    get_global $P2039, "!PREFIX__default_value"
    $P2038."add_method"(type_obj, "!PREFIX__default_value", $P2039)
    get_how $P2040, type_obj
    .const 'Sub' $P2041 = "202_1300062003.824" 
    $P2040."add_method"(type_obj, "trait", $P2041)
    get_how $P2042, type_obj
    get_global $P2043, "!PREFIX__trait"
    $P2042."add_method"(type_obj, "!PREFIX__trait", $P2043)
    get_how $P2044, type_obj
    .const 'Sub' $P2045 = "204_1300062003.824" 
    $P2044."add_method"(type_obj, "trait_mod", $P2045)
    get_how $P2046, type_obj
    .const 'Sub' $P2047 = "205_1300062003.824" 
    $P2046."add_method"(type_obj, "!PREFIX__trait_mod", $P2047)
    get_how $P2048, type_obj
    .const 'Sub' $P2049 = "206_1300062003.824" 
    $P2048."add_method"(type_obj, "trait_mod:sym<is>", $P2049)
    get_how $P2050, type_obj
    get_global $P2051, "!PREFIX__trait_mod:sym<is>"
    $P2050."add_method"(type_obj, "!PREFIX__trait_mod:sym<is>", $P2051)
    get_how $P2052, type_obj
    .const 'Sub' $P2053 = "208_1300062003.824" 
    $P2052."add_method"(type_obj, "regex_declarator", $P2053)
    get_how $P2054, type_obj
    get_global $P2055, "!PREFIX__regex_declarator"
    $P2054."add_method"(type_obj, "!PREFIX__regex_declarator", $P2055)
    get_how $P2056, type_obj
    .const 'Sub' $P2057 = "210_1300062003.824" 
    $P2056."add_method"(type_obj, "dotty", $P2057)
    get_how $P2058, type_obj
    get_global $P2059, "!PREFIX__dotty"
    $P2058."add_method"(type_obj, "!PREFIX__dotty", $P2059)
    get_how $P2060, type_obj
    .const 'Sub' $P2061 = "212_1300062003.824" 
    $P2060."add_method"(type_obj, "term", $P2061)
    get_how $P2062, type_obj
    .const 'Sub' $P2063 = "213_1300062003.824" 
    $P2062."add_method"(type_obj, "!PREFIX__term", $P2063)
    get_how $P2064, type_obj
    .const 'Sub' $P2065 = "214_1300062003.824" 
    $P2064."add_method"(type_obj, "term:sym<self>", $P2065)
    get_how $P2066, type_obj
    get_global $P2067, "!PREFIX__term:sym<self>"
    $P2066."add_method"(type_obj, "!PREFIX__term:sym<self>", $P2067)
    get_how $P2068, type_obj
    .const 'Sub' $P2069 = "216_1300062003.824" 
    $P2068."add_method"(type_obj, "term:sym<identifier>", $P2069)
    get_how $P2070, type_obj
    get_global $P2071, "!PREFIX__term:sym<identifier>"
    $P2070."add_method"(type_obj, "!PREFIX__term:sym<identifier>", $P2071)
    get_how $P2072, type_obj
    .const 'Sub' $P2073 = "218_1300062003.824" 
    $P2072."add_method"(type_obj, "term:sym<name>", $P2073)
    get_how $P2074, type_obj
    get_global $P2075, "!PREFIX__term:sym<name>"
    $P2074."add_method"(type_obj, "!PREFIX__term:sym<name>", $P2075)
    get_how $P2076, type_obj
    .const 'Sub' $P2077 = "220_1300062003.824" 
    $P2076."add_method"(type_obj, "term:sym<pir::op>", $P2077)
    get_how $P2078, type_obj
    get_global $P2079, "!PREFIX__term:sym<pir::op>"
    $P2078."add_method"(type_obj, "!PREFIX__term:sym<pir::op>", $P2079)
    get_how $P2080, type_obj
    .const 'Sub' $P2081 = "222_1300062003.824" 
    $P2080."add_method"(type_obj, "term:sym<onlystar>", $P2081)
    get_how $P2082, type_obj
    get_global $P2083, "!PREFIX__term:sym<onlystar>"
    $P2082."add_method"(type_obj, "!PREFIX__term:sym<onlystar>", $P2083)
    get_how $P2084, type_obj
    .const 'Sub' $P2085 = "225_1300062003.824" 
    $P2084."add_method"(type_obj, "args", $P2085)
    get_how $P2086, type_obj
    get_global $P2087, "!PREFIX__args"
    $P2086."add_method"(type_obj, "!PREFIX__args", $P2087)
    get_how $P2088, type_obj
    .const 'Sub' $P2089 = "227_1300062003.824" 
    $P2088."add_method"(type_obj, "arglist", $P2089)
    get_how $P2090, type_obj
    get_global $P2091, "!PREFIX__arglist"
    $P2090."add_method"(type_obj, "!PREFIX__arglist", $P2091)
    get_how $P2092, type_obj
    .const 'Sub' $P2093 = "229_1300062003.824" 
    $P2092."add_method"(type_obj, "term:sym<value>", $P2093)
    get_how $P2094, type_obj
    get_global $P2095, "!PREFIX__term:sym<value>"
    $P2094."add_method"(type_obj, "!PREFIX__term:sym<value>", $P2095)
    get_how $P2096, type_obj
    .const 'Sub' $P2097 = "231_1300062003.824" 
    $P2096."add_method"(type_obj, "value", $P2097)
    get_how $P2098, type_obj
    get_global $P2099, "!PREFIX__value"
    $P2098."add_method"(type_obj, "!PREFIX__value", $P2099)
    get_how $P2100, type_obj
    .const 'Sub' $P2101 = "233_1300062003.824" 
    $P2100."add_method"(type_obj, "number", $P2101)
    get_how $P2102, type_obj
    get_global $P2103, "!PREFIX__number"
    $P2102."add_method"(type_obj, "!PREFIX__number", $P2103)
    get_how $P2104, type_obj
    .const 'Sub' $P2105 = "235_1300062003.824" 
    $P2104."add_method"(type_obj, "quote", $P2105)
    get_how $P2106, type_obj
    .const 'Sub' $P2107 = "236_1300062003.824" 
    $P2106."add_method"(type_obj, "!PREFIX__quote", $P2107)
    get_how $P2108, type_obj
    .const 'Sub' $P2109 = "237_1300062003.824" 
    $P2108."add_method"(type_obj, "quote:sym<apos>", $P2109)
    get_how $P2110, type_obj
    get_global $P2111, "!PREFIX__quote:sym<apos>"
    $P2110."add_method"(type_obj, "!PREFIX__quote:sym<apos>", $P2111)
    get_how $P2112, type_obj
    .const 'Sub' $P2113 = "239_1300062003.824" 
    $P2112."add_method"(type_obj, "quote:sym<dblq>", $P2113)
    get_how $P2114, type_obj
    get_global $P2115, "!PREFIX__quote:sym<dblq>"
    $P2114."add_method"(type_obj, "!PREFIX__quote:sym<dblq>", $P2115)
    get_how $P2116, type_obj
    .const 'Sub' $P2117 = "241_1300062003.824" 
    $P2116."add_method"(type_obj, "quote:sym<q>", $P2117)
    get_how $P2118, type_obj
    get_global $P2119, "!PREFIX__quote:sym<q>"
    $P2118."add_method"(type_obj, "!PREFIX__quote:sym<q>", $P2119)
    get_how $P2120, type_obj
    .const 'Sub' $P2121 = "243_1300062003.824" 
    $P2120."add_method"(type_obj, "quote:sym<qq>", $P2121)
    get_how $P2122, type_obj
    get_global $P2123, "!PREFIX__quote:sym<qq>"
    $P2122."add_method"(type_obj, "!PREFIX__quote:sym<qq>", $P2123)
    get_how $P2124, type_obj
    .const 'Sub' $P2125 = "245_1300062003.824" 
    $P2124."add_method"(type_obj, "quote:sym<Q>", $P2125)
    get_how $P2126, type_obj
    get_global $P2127, "!PREFIX__quote:sym<Q>"
    $P2126."add_method"(type_obj, "!PREFIX__quote:sym<Q>", $P2127)
    get_how $P2128, type_obj
    .const 'Sub' $P2129 = "247_1300062003.824" 
    $P2128."add_method"(type_obj, "quote:sym<Q:PIR>", $P2129)
    get_how $P2130, type_obj
    get_global $P2131, "!PREFIX__quote:sym<Q:PIR>"
    $P2130."add_method"(type_obj, "!PREFIX__quote:sym<Q:PIR>", $P2131)
    get_how $P2132, type_obj
    .const 'Sub' $P2133 = "249_1300062003.824" 
    $P2132."add_method"(type_obj, "quote:sym</ />", $P2133)
    get_how $P2134, type_obj
    get_global $P2135, "!PREFIX__quote:sym</ />"
    $P2134."add_method"(type_obj, "!PREFIX__quote:sym</ />", $P2135)
    get_how $P2136, type_obj
    .const 'Sub' $P2137 = "251_1300062003.824" 
    $P2136."add_method"(type_obj, "quote_escape:sym<$>", $P2137)
    get_how $P2138, type_obj
    get_global $P2139, "!PREFIX__quote_escape:sym<$>"
    $P2138."add_method"(type_obj, "!PREFIX__quote_escape:sym<$>", $P2139)
    get_how $P2140, type_obj
    .const 'Sub' $P2141 = "253_1300062003.824" 
    $P2140."add_method"(type_obj, "quote_escape:sym<{ }>", $P2141)
    get_how $P2142, type_obj
    get_global $P2143, "!PREFIX__quote_escape:sym<{ }>"
    $P2142."add_method"(type_obj, "!PREFIX__quote_escape:sym<{ }>", $P2143)
    get_how $P2144, type_obj
    .const 'Sub' $P2145 = "255_1300062003.824" 
    $P2144."add_method"(type_obj, "quote_escape:sym<esc>", $P2145)
    get_how $P2146, type_obj
    get_global $P2147, "!PREFIX__quote_escape:sym<esc>"
    $P2146."add_method"(type_obj, "!PREFIX__quote_escape:sym<esc>", $P2147)
    get_how $P2148, type_obj
    .const 'Sub' $P2149 = "257_1300062003.824" 
    $P2148."add_method"(type_obj, "circumfix:sym<( )>", $P2149)
    get_how $P2150, type_obj
    get_global $P2151, "!PREFIX__circumfix:sym<( )>"
    $P2150."add_method"(type_obj, "!PREFIX__circumfix:sym<( )>", $P2151)
    get_how $P2152, type_obj
    .const 'Sub' $P2153 = "259_1300062003.824" 
    $P2152."add_method"(type_obj, "circumfix:sym<[ ]>", $P2153)
    get_how $P2154, type_obj
    get_global $P2155, "!PREFIX__circumfix:sym<[ ]>"
    $P2154."add_method"(type_obj, "!PREFIX__circumfix:sym<[ ]>", $P2155)
    get_how $P2156, type_obj
    .const 'Sub' $P2157 = "261_1300062003.824" 
    $P2156."add_method"(type_obj, "circumfix:sym<ang>", $P2157)
    get_how $P2158, type_obj
    get_global $P2159, "!PREFIX__circumfix:sym<ang>"
    $P2158."add_method"(type_obj, "!PREFIX__circumfix:sym<ang>", $P2159)
    get_how $P2160, type_obj
    .const 'Sub' $P2161 = "263_1300062003.824" 
    $P2160."add_method"(type_obj, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P2161)
    get_how $P2162, type_obj
    get_global $P2163, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"
    $P2162."add_method"(type_obj, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>", $P2163)
    get_how $P2164, type_obj
    .const 'Sub' $P2165 = "265_1300062003.824" 
    $P2164."add_method"(type_obj, "circumfix:sym<{ }>", $P2165)
    get_how $P2166, type_obj
    get_global $P2167, "!PREFIX__circumfix:sym<{ }>"
    $P2166."add_method"(type_obj, "!PREFIX__circumfix:sym<{ }>", $P2167)
    get_how $P2168, type_obj
    .const 'Sub' $P2169 = "267_1300062003.824" 
    $P2168."add_method"(type_obj, "circumfix:sym<sigil>", $P2169)
    get_how $P2170, type_obj
    get_global $P2171, "!PREFIX__circumfix:sym<sigil>"
    $P2170."add_method"(type_obj, "!PREFIX__circumfix:sym<sigil>", $P2171)
    get_how $P2172, type_obj
    .const 'Sub' $P2173 = "269_1300062003.824" 
    $P2172."add_method"(type_obj, "semilist", $P2173)
    get_how $P2174, type_obj
    get_global $P2175, "!PREFIX__semilist"
    $P2174."add_method"(type_obj, "!PREFIX__semilist", $P2175)
    get_how $P2176, type_obj
    .const 'Sub' $P2177 = "272_1300062003.824" 
    $P2176."add_method"(type_obj, "infixish", $P2177)
    get_how $P2178, type_obj
    get_global $P2179, "!PREFIX__infixish"
    $P2178."add_method"(type_obj, "!PREFIX__infixish", $P2179)
    get_how $P2180, type_obj
    .const 'Sub' $P2181 = "274_1300062003.824" 
    $P2180."add_method"(type_obj, "infixstopper", $P2181)
    get_how $P2182, type_obj
    get_global $P2183, "!PREFIX__infixstopper"
    $P2182."add_method"(type_obj, "!PREFIX__infixstopper", $P2183)
    get_how $P2184, type_obj
    .const 'Sub' $P2185 = "276_1300062003.824" 
    $P2184."add_method"(type_obj, "postcircumfix:sym<[ ]>", $P2185)
    get_how $P2186, type_obj
    get_global $P2187, "!PREFIX__postcircumfix:sym<[ ]>"
    $P2186."add_method"(type_obj, "!PREFIX__postcircumfix:sym<[ ]>", $P2187)
    get_how $P2188, type_obj
    .const 'Sub' $P2189 = "278_1300062003.824" 
    $P2188."add_method"(type_obj, "postcircumfix:sym<{ }>", $P2189)
    get_how $P2190, type_obj
    get_global $P2191, "!PREFIX__postcircumfix:sym<{ }>"
    $P2190."add_method"(type_obj, "!PREFIX__postcircumfix:sym<{ }>", $P2191)
    get_how $P2192, type_obj
    .const 'Sub' $P2193 = "280_1300062003.824" 
    $P2192."add_method"(type_obj, "postcircumfix:sym<ang>", $P2193)
    get_how $P2194, type_obj
    get_global $P2195, "!PREFIX__postcircumfix:sym<ang>"
    $P2194."add_method"(type_obj, "!PREFIX__postcircumfix:sym<ang>", $P2195)
    get_how $P2196, type_obj
    .const 'Sub' $P2197 = "282_1300062003.824" 
    $P2196."add_method"(type_obj, "postcircumfix:sym<( )>", $P2197)
    get_how $P2198, type_obj
    get_global $P2199, "!PREFIX__postcircumfix:sym<( )>"
    $P2198."add_method"(type_obj, "!PREFIX__postcircumfix:sym<( )>", $P2199)
    get_how $P2200, type_obj
    .const 'Sub' $P2201 = "284_1300062003.824" 
    $P2200."add_method"(type_obj, "postfix:sym<.>", $P2201)
    get_how $P2202, type_obj
    get_global $P2203, "!PREFIX__postfix:sym<.>"
    $P2202."add_method"(type_obj, "!PREFIX__postfix:sym<.>", $P2203)
    get_how $P2204, type_obj
    .const 'Sub' $P2205 = "286_1300062003.824" 
    $P2204."add_method"(type_obj, "prefix:sym<++>", $P2205)
    get_how $P2206, type_obj
    get_global $P2207, "!PREFIX__prefix:sym<++>"
    $P2206."add_method"(type_obj, "!PREFIX__prefix:sym<++>", $P2207)
    get_how $P2208, type_obj
    .const 'Sub' $P2209 = "288_1300062003.824" 
    $P2208."add_method"(type_obj, "prefix:sym<-->", $P2209)
    get_how $P2210, type_obj
    get_global $P2211, "!PREFIX__prefix:sym<-->"
    $P2210."add_method"(type_obj, "!PREFIX__prefix:sym<-->", $P2211)
    get_how $P2212, type_obj
    .const 'Sub' $P2213 = "290_1300062003.824" 
    $P2212."add_method"(type_obj, "postfix:sym<++>", $P2213)
    get_how $P2214, type_obj
    get_global $P2215, "!PREFIX__postfix:sym<++>"
    $P2214."add_method"(type_obj, "!PREFIX__postfix:sym<++>", $P2215)
    get_how $P2216, type_obj
    .const 'Sub' $P2217 = "292_1300062003.824" 
    $P2216."add_method"(type_obj, "postfix:sym<-->", $P2217)
    get_how $P2218, type_obj
    get_global $P2219, "!PREFIX__postfix:sym<-->"
    $P2218."add_method"(type_obj, "!PREFIX__postfix:sym<-->", $P2219)
    get_how $P2220, type_obj
    .const 'Sub' $P2221 = "294_1300062003.824" 
    $P2220."add_method"(type_obj, "infix:sym<**>", $P2221)
    get_how $P2222, type_obj
    get_global $P2223, "!PREFIX__infix:sym<**>"
    $P2222."add_method"(type_obj, "!PREFIX__infix:sym<**>", $P2223)
    get_how $P2224, type_obj
    .const 'Sub' $P2225 = "296_1300062003.824" 
    $P2224."add_method"(type_obj, "prefix:sym<+>", $P2225)
    get_how $P2226, type_obj
    get_global $P2227, "!PREFIX__prefix:sym<+>"
    $P2226."add_method"(type_obj, "!PREFIX__prefix:sym<+>", $P2227)
    get_how $P2228, type_obj
    .const 'Sub' $P2229 = "298_1300062003.824" 
    $P2228."add_method"(type_obj, "prefix:sym<~>", $P2229)
    get_how $P2230, type_obj
    get_global $P2231, "!PREFIX__prefix:sym<~>"
    $P2230."add_method"(type_obj, "!PREFIX__prefix:sym<~>", $P2231)
    get_how $P2232, type_obj
    .const 'Sub' $P2233 = "300_1300062003.824" 
    $P2232."add_method"(type_obj, "prefix:sym<->", $P2233)
    get_how $P2234, type_obj
    get_global $P2235, "!PREFIX__prefix:sym<->"
    $P2234."add_method"(type_obj, "!PREFIX__prefix:sym<->", $P2235)
    get_how $P2236, type_obj
    .const 'Sub' $P2237 = "302_1300062003.824" 
    $P2236."add_method"(type_obj, "prefix:sym<?>", $P2237)
    get_how $P2238, type_obj
    get_global $P2239, "!PREFIX__prefix:sym<?>"
    $P2238."add_method"(type_obj, "!PREFIX__prefix:sym<?>", $P2239)
    get_how $P2240, type_obj
    .const 'Sub' $P2241 = "304_1300062003.824" 
    $P2240."add_method"(type_obj, "prefix:sym<!>", $P2241)
    get_how $P2242, type_obj
    get_global $P2243, "!PREFIX__prefix:sym<!>"
    $P2242."add_method"(type_obj, "!PREFIX__prefix:sym<!>", $P2243)
    get_how $P2244, type_obj
    .const 'Sub' $P2245 = "306_1300062003.824" 
    $P2244."add_method"(type_obj, "prefix:sym<|>", $P2245)
    get_how $P2246, type_obj
    get_global $P2247, "!PREFIX__prefix:sym<|>"
    $P2246."add_method"(type_obj, "!PREFIX__prefix:sym<|>", $P2247)
    get_how $P2248, type_obj
    .const 'Sub' $P2249 = "308_1300062003.824" 
    $P2248."add_method"(type_obj, "infix:sym<*>", $P2249)
    get_how $P2250, type_obj
    get_global $P2251, "!PREFIX__infix:sym<*>"
    $P2250."add_method"(type_obj, "!PREFIX__infix:sym<*>", $P2251)
    get_how $P2252, type_obj
    .const 'Sub' $P2253 = "310_1300062003.824" 
    $P2252."add_method"(type_obj, "infix:sym</>", $P2253)
    get_how $P2254, type_obj
    get_global $P2255, "!PREFIX__infix:sym</>"
    $P2254."add_method"(type_obj, "!PREFIX__infix:sym</>", $P2255)
    get_how $P2256, type_obj
    .const 'Sub' $P2257 = "312_1300062003.824" 
    $P2256."add_method"(type_obj, "infix:sym<%>", $P2257)
    get_how $P2258, type_obj
    get_global $P2259, "!PREFIX__infix:sym<%>"
    $P2258."add_method"(type_obj, "!PREFIX__infix:sym<%>", $P2259)
    get_how $P2260, type_obj
    .const 'Sub' $P2261 = "314_1300062003.824" 
    $P2260."add_method"(type_obj, "infix:sym<+&>", $P2261)
    get_how $P2262, type_obj
    get_global $P2263, "!PREFIX__infix:sym<+&>"
    $P2262."add_method"(type_obj, "!PREFIX__infix:sym<+&>", $P2263)
    get_how $P2264, type_obj
    .const 'Sub' $P2265 = "316_1300062003.824" 
    $P2264."add_method"(type_obj, "infix:sym<+>", $P2265)
    get_how $P2266, type_obj
    get_global $P2267, "!PREFIX__infix:sym<+>"
    $P2266."add_method"(type_obj, "!PREFIX__infix:sym<+>", $P2267)
    get_how $P2268, type_obj
    .const 'Sub' $P2269 = "318_1300062003.824" 
    $P2268."add_method"(type_obj, "infix:sym<->", $P2269)
    get_how $P2270, type_obj
    get_global $P2271, "!PREFIX__infix:sym<->"
    $P2270."add_method"(type_obj, "!PREFIX__infix:sym<->", $P2271)
    get_how $P2272, type_obj
    .const 'Sub' $P2273 = "320_1300062003.824" 
    $P2272."add_method"(type_obj, "infix:sym<+|>", $P2273)
    get_how $P2274, type_obj
    get_global $P2275, "!PREFIX__infix:sym<+|>"
    $P2274."add_method"(type_obj, "!PREFIX__infix:sym<+|>", $P2275)
    get_how $P2276, type_obj
    .const 'Sub' $P2277 = "322_1300062003.824" 
    $P2276."add_method"(type_obj, "infix:sym<+^>", $P2277)
    get_how $P2278, type_obj
    get_global $P2279, "!PREFIX__infix:sym<+^>"
    $P2278."add_method"(type_obj, "!PREFIX__infix:sym<+^>", $P2279)
    get_how $P2280, type_obj
    .const 'Sub' $P2281 = "324_1300062003.824" 
    $P2280."add_method"(type_obj, "infix:sym<~>", $P2281)
    get_how $P2282, type_obj
    get_global $P2283, "!PREFIX__infix:sym<~>"
    $P2282."add_method"(type_obj, "!PREFIX__infix:sym<~>", $P2283)
    get_how $P2284, type_obj
    .const 'Sub' $P2285 = "326_1300062003.824" 
    $P2284."add_method"(type_obj, "infix:sym<==>", $P2285)
    get_how $P2286, type_obj
    get_global $P2287, "!PREFIX__infix:sym<==>"
    $P2286."add_method"(type_obj, "!PREFIX__infix:sym<==>", $P2287)
    get_how $P2288, type_obj
    .const 'Sub' $P2289 = "328_1300062003.824" 
    $P2288."add_method"(type_obj, "infix:sym<!=>", $P2289)
    get_how $P2290, type_obj
    get_global $P2291, "!PREFIX__infix:sym<!=>"
    $P2290."add_method"(type_obj, "!PREFIX__infix:sym<!=>", $P2291)
    get_how $P2292, type_obj
    .const 'Sub' $P2293 = "330_1300062003.824" 
    $P2292."add_method"(type_obj, "infix:sym<<=>", $P2293)
    get_how $P2294, type_obj
    get_global $P2295, "!PREFIX__infix:sym<<=>"
    $P2294."add_method"(type_obj, "!PREFIX__infix:sym<<=>", $P2295)
    get_how $P2296, type_obj
    .const 'Sub' $P2297 = "332_1300062003.824" 
    $P2296."add_method"(type_obj, "infix:sym<>=>", $P2297)
    get_how $P2298, type_obj
    get_global $P2299, "!PREFIX__infix:sym<>=>"
    $P2298."add_method"(type_obj, "!PREFIX__infix:sym<>=>", $P2299)
    get_how $P2300, type_obj
    .const 'Sub' $P2301 = "334_1300062003.824" 
    $P2300."add_method"(type_obj, "infix:sym<<>", $P2301)
    get_how $P2302, type_obj
    get_global $P2303, "!PREFIX__infix:sym<<>"
    $P2302."add_method"(type_obj, "!PREFIX__infix:sym<<>", $P2303)
    get_how $P2304, type_obj
    .const 'Sub' $P2305 = "336_1300062003.824" 
    $P2304."add_method"(type_obj, "infix:sym<>>", $P2305)
    get_how $P2306, type_obj
    get_global $P2307, "!PREFIX__infix:sym<>>"
    $P2306."add_method"(type_obj, "!PREFIX__infix:sym<>>", $P2307)
    get_how $P2308, type_obj
    .const 'Sub' $P2309 = "338_1300062003.824" 
    $P2308."add_method"(type_obj, "infix:sym<eq>", $P2309)
    get_how $P2310, type_obj
    get_global $P2311, "!PREFIX__infix:sym<eq>"
    $P2310."add_method"(type_obj, "!PREFIX__infix:sym<eq>", $P2311)
    get_how $P2312, type_obj
    .const 'Sub' $P2313 = "340_1300062003.824" 
    $P2312."add_method"(type_obj, "infix:sym<ne>", $P2313)
    get_how $P2314, type_obj
    get_global $P2315, "!PREFIX__infix:sym<ne>"
    $P2314."add_method"(type_obj, "!PREFIX__infix:sym<ne>", $P2315)
    get_how $P2316, type_obj
    .const 'Sub' $P2317 = "342_1300062003.824" 
    $P2316."add_method"(type_obj, "infix:sym<le>", $P2317)
    get_how $P2318, type_obj
    get_global $P2319, "!PREFIX__infix:sym<le>"
    $P2318."add_method"(type_obj, "!PREFIX__infix:sym<le>", $P2319)
    get_how $P2320, type_obj
    .const 'Sub' $P2321 = "344_1300062003.824" 
    $P2320."add_method"(type_obj, "infix:sym<ge>", $P2321)
    get_how $P2322, type_obj
    get_global $P2323, "!PREFIX__infix:sym<ge>"
    $P2322."add_method"(type_obj, "!PREFIX__infix:sym<ge>", $P2323)
    get_how $P2324, type_obj
    .const 'Sub' $P2325 = "346_1300062003.824" 
    $P2324."add_method"(type_obj, "infix:sym<lt>", $P2325)
    get_how $P2326, type_obj
    get_global $P2327, "!PREFIX__infix:sym<lt>"
    $P2326."add_method"(type_obj, "!PREFIX__infix:sym<lt>", $P2327)
    get_how $P2328, type_obj
    .const 'Sub' $P2329 = "348_1300062003.824" 
    $P2328."add_method"(type_obj, "infix:sym<gt>", $P2329)
    get_how $P2330, type_obj
    get_global $P2331, "!PREFIX__infix:sym<gt>"
    $P2330."add_method"(type_obj, "!PREFIX__infix:sym<gt>", $P2331)
    get_how $P2332, type_obj
    .const 'Sub' $P2333 = "350_1300062003.824" 
    $P2332."add_method"(type_obj, "infix:sym<=:=>", $P2333)
    get_how $P2334, type_obj
    get_global $P2335, "!PREFIX__infix:sym<=:=>"
    $P2334."add_method"(type_obj, "!PREFIX__infix:sym<=:=>", $P2335)
    get_how $P2336, type_obj
    .const 'Sub' $P2337 = "352_1300062003.824" 
    $P2336."add_method"(type_obj, "infix:sym<~~>", $P2337)
    get_how $P2338, type_obj
    get_global $P2339, "!PREFIX__infix:sym<~~>"
    $P2338."add_method"(type_obj, "!PREFIX__infix:sym<~~>", $P2339)
    get_how $P2340, type_obj
    .const 'Sub' $P2341 = "354_1300062003.824" 
    $P2340."add_method"(type_obj, "infix:sym<&&>", $P2341)
    get_how $P2342, type_obj
    get_global $P2343, "!PREFIX__infix:sym<&&>"
    $P2342."add_method"(type_obj, "!PREFIX__infix:sym<&&>", $P2343)
    get_how $P2344, type_obj
    .const 'Sub' $P2345 = "356_1300062003.824" 
    $P2344."add_method"(type_obj, "infix:sym<||>", $P2345)
    get_how $P2346, type_obj
    get_global $P2347, "!PREFIX__infix:sym<||>"
    $P2346."add_method"(type_obj, "!PREFIX__infix:sym<||>", $P2347)
    get_how $P2348, type_obj
    .const 'Sub' $P2349 = "358_1300062003.824" 
    $P2348."add_method"(type_obj, "infix:sym<//>", $P2349)
    get_how $P2350, type_obj
    get_global $P2351, "!PREFIX__infix:sym<//>"
    $P2350."add_method"(type_obj, "!PREFIX__infix:sym<//>", $P2351)
    get_how $P2352, type_obj
    .const 'Sub' $P2353 = "360_1300062003.824" 
    $P2352."add_method"(type_obj, "infix:sym<?? !!>", $P2353)
    get_how $P2354, type_obj
    get_global $P2355, "!PREFIX__infix:sym<?? !!>"
    $P2354."add_method"(type_obj, "!PREFIX__infix:sym<?? !!>", $P2355)
    get_how $P2356, type_obj
    .const 'Sub' $P2357 = "362_1300062003.824" 
    $P2356."add_method"(type_obj, "infix:sym<=>", $P2357)
    get_how $P2358, type_obj
    get_global $P2359, "!PREFIX__infix:sym<=>"
    $P2358."add_method"(type_obj, "!PREFIX__infix:sym<=>", $P2359)
    get_how $P2360, type_obj
    .const 'Sub' $P2361 = "364_1300062003.824" 
    $P2360."add_method"(type_obj, "infix:sym<:=>", $P2361)
    get_how $P2362, type_obj
    get_global $P2363, "!PREFIX__infix:sym<:=>"
    $P2362."add_method"(type_obj, "!PREFIX__infix:sym<:=>", $P2363)
    get_how $P2364, type_obj
    .const 'Sub' $P2365 = "366_1300062003.824" 
    $P2364."add_method"(type_obj, "infix:sym<::=>", $P2365)
    get_how $P2366, type_obj
    get_global $P2367, "!PREFIX__infix:sym<::=>"
    $P2366."add_method"(type_obj, "!PREFIX__infix:sym<::=>", $P2367)
    get_how $P2368, type_obj
    .const 'Sub' $P2369 = "368_1300062003.824" 
    $P2368."add_method"(type_obj, "infix:sym<,>", $P2369)
    get_how $P2370, type_obj
    get_global $P2371, "!PREFIX__infix:sym<,>"
    $P2370."add_method"(type_obj, "!PREFIX__infix:sym<,>", $P2371)
    get_how $P2372, type_obj
    .const 'Sub' $P2373 = "370_1300062003.824" 
    $P2372."add_method"(type_obj, "prefix:sym<return>", $P2373)
    get_how $P2374, type_obj
    get_global $P2375, "!PREFIX__prefix:sym<return>"
    $P2374."add_method"(type_obj, "!PREFIX__prefix:sym<return>", $P2375)
    get_how $P2376, type_obj
    .const 'Sub' $P2377 = "373_1300062003.824" 
    $P2376."add_method"(type_obj, "prefix:sym<make>", $P2377)
    get_how $P2378, type_obj
    get_global $P2379, "!PREFIX__prefix:sym<make>"
    $P2378."add_method"(type_obj, "!PREFIX__prefix:sym<make>", $P2379)
    get_how $P2380, type_obj
    .const 'Sub' $P2381 = "375_1300062003.824" 
    $P2380."add_method"(type_obj, "term:sym<last>", $P2381)
    get_how $P2382, type_obj
    get_global $P2383, "!PREFIX__term:sym<last>"
    $P2382."add_method"(type_obj, "!PREFIX__term:sym<last>", $P2383)
    get_how $P2384, type_obj
    .const 'Sub' $P2385 = "377_1300062003.824" 
    $P2384."add_method"(type_obj, "term:sym<next>", $P2385)
    get_how $P2386, type_obj
    get_global $P2387, "!PREFIX__term:sym<next>"
    $P2386."add_method"(type_obj, "!PREFIX__term:sym<next>", $P2387)
    get_how $P2388, type_obj
    .const 'Sub' $P2389 = "379_1300062003.824" 
    $P2388."add_method"(type_obj, "term:sym<redo>", $P2389)
    get_how $P2390, type_obj
    get_global $P2391, "!PREFIX__term:sym<redo>"
    $P2390."add_method"(type_obj, "!PREFIX__term:sym<redo>", $P2391)
    get_how $P2392, type_obj
    .const 'Sub' $P2393 = "381_1300062003.824" 
    $P2392."add_method"(type_obj, "smartmatch", $P2393)
    get_how $P2394, type_obj
    get_hll_global $P2395, ["HLL"], "Grammar"
    $P2394."add_parent"(type_obj, $P2395)
    get_how $P2396, type_obj
    $P2397 = $P2396."compose"(type_obj)
    .return ($P2397)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "TOP"  :subid("13_1300062003.824") :outer("12_1300062003.824")
    .param pmc param_37
.annotate 'line', 10
    .lex "self", param_37
.annotate 'line', 12
    $P38 = root_new ['parrot';'Hash']
    .lex "%*LANG", $P38
.annotate 'line', 19
    $P39 = root_new ['parrot';'Hash']
    .lex "%*HOW", $P39
.annotate 'line', 28
    new $P40, "Undef"
    .lex "$*DEFAULT-METAATTR", $P40
.annotate 'line', 29
    $P41 = root_new ['parrot';'Hash']
    .lex "%*HOW-METAATTR", $P41
.annotate 'line', 35
    new $P42, "Undef"
    .lex "$*SC", $P42
.annotate 'line', 39
    new $P43, "Undef"
    .lex "$*SCOPE", $P43
.annotate 'line', 40
    new $P44, "Undef"
    .lex "$*MULTINESS", $P44
.annotate 'line', 41
    new $P45, "Undef"
    .lex "$*INVOCANT_OK", $P45
.annotate 'line', 42
    new $P46, "Undef"
    .lex "$*RETURN_USED", $P46
.annotate 'line', 43
    new $P47, "Undef"
    .lex "$*PACKAGE-SETUP", $P47
.annotate 'line', 10
    find_lex $P48, "%*LANG"
    unless_null $P48, vivify_572
    get_hll_global $P48, "%LANG"
    unless_null $P48, vivify_573
    die "Contextual %*LANG not found"
  vivify_573:
  vivify_572:
.annotate 'line', 13
    get_hll_global $P49, ["NQP"], "Regex"
    find_lex $P50, "%*LANG"
    unless_null $P50, vivify_574
    get_hll_global $P50, "%LANG"
    unless_null $P50, vivify_575
    die "Contextual %*LANG not found"
  vivify_575:
    store_lex "%*LANG", $P50
  vivify_574:
    set $P50["Regex"], $P49
.annotate 'line', 14
    get_hll_global $P51, ["NQP"], "RegexActions"
    find_lex $P52, "%*LANG"
    unless_null $P52, vivify_576
    get_hll_global $P52, "%LANG"
    unless_null $P52, vivify_577
    die "Contextual %*LANG not found"
  vivify_577:
    store_lex "%*LANG", $P52
  vivify_576:
    set $P52["Regex-actions"], $P51
.annotate 'line', 15
    get_hll_global $P53, ["NQP"], "Grammar"
    find_lex $P54, "%*LANG"
    unless_null $P54, vivify_578
    get_hll_global $P54, "%LANG"
    unless_null $P54, vivify_579
    die "Contextual %*LANG not found"
  vivify_579:
    store_lex "%*LANG", $P54
  vivify_578:
    set $P54["MAIN"], $P53
.annotate 'line', 16
    get_hll_global $P55, ["NQP"], "Actions"
    find_lex $P56, "%*LANG"
    unless_null $P56, vivify_580
    get_hll_global $P56, "%LANG"
    unless_null $P56, vivify_581
    die "Contextual %*LANG not found"
  vivify_581:
    store_lex "%*LANG", $P56
  vivify_580:
    set $P56["MAIN-actions"], $P55
    find_lex $P57, "%*HOW"
    unless_null $P57, vivify_582
    get_hll_global $P57, "%HOW"
    unless_null $P57, vivify_583
    die "Contextual %*HOW not found"
  vivify_583:
  vivify_582:
.annotate 'line', 20
    get_hll_global $P58, "KnowHOW"
    find_lex $P59, "%*HOW"
    unless_null $P59, vivify_584
    get_hll_global $P59, "%HOW"
    unless_null $P59, vivify_585
    die "Contextual %*HOW not found"
  vivify_585:
    store_lex "%*HOW", $P59
  vivify_584:
    set $P59["knowhow"], $P58
.annotate 'line', 21
    get_hll_global $P60, "NQPModuleHOW"
    find_lex $P61, "%*HOW"
    unless_null $P61, vivify_586
    get_hll_global $P61, "%HOW"
    unless_null $P61, vivify_587
    die "Contextual %*HOW not found"
  vivify_587:
    store_lex "%*HOW", $P61
  vivify_586:
    set $P61["module"], $P60
.annotate 'line', 22
    get_hll_global $P62, "NQPClassHOW"
    find_lex $P63, "%*HOW"
    unless_null $P63, vivify_588
    get_hll_global $P63, "%HOW"
    unless_null $P63, vivify_589
    die "Contextual %*HOW not found"
  vivify_589:
    store_lex "%*HOW", $P63
  vivify_588:
    set $P63["class"], $P62
.annotate 'line', 23
    get_hll_global $P64, "NQPClassHOW"
    find_lex $P65, "%*HOW"
    unless_null $P65, vivify_590
    get_hll_global $P65, "%HOW"
    unless_null $P65, vivify_591
    die "Contextual %*HOW not found"
  vivify_591:
    store_lex "%*HOW", $P65
  vivify_590:
    set $P65["grammar"], $P64
.annotate 'line', 24
    get_hll_global $P66, "NQPParametricRoleHOW"
    find_lex $P67, "%*HOW"
    unless_null $P67, vivify_592
    get_hll_global $P67, "%HOW"
    unless_null $P67, vivify_593
    die "Contextual %*HOW not found"
  vivify_593:
    store_lex "%*HOW", $P67
  vivify_592:
    set $P67["role"], $P66
.annotate 'line', 25
    get_hll_global $P68, "NQPNativeHOW"
    find_lex $P69, "%*HOW"
    unless_null $P69, vivify_594
    get_hll_global $P69, "%HOW"
    unless_null $P69, vivify_595
    die "Contextual %*HOW not found"
  vivify_595:
    store_lex "%*HOW", $P69
  vivify_594:
    set $P69["native"], $P68
.annotate 'line', 28
    new $P70, "String"
    assign $P70, "NQPAttribute"
    store_lex "$*DEFAULT-METAATTR", $P70
    find_lex $P71, "%*HOW-METAATTR"
    unless_null $P71, vivify_596
    get_hll_global $P71, "%HOW-METAATTR"
    unless_null $P71, vivify_597
    die "Contextual %*HOW-METAATTR not found"
  vivify_597:
  vivify_596:
.annotate 'line', 30
    new $P72, "String"
    assign $P72, "KnowHOWAttribute"
    find_lex $P73, "%*HOW-METAATTR"
    unless_null $P73, vivify_598
    get_hll_global $P73, "%HOW-METAATTR"
    unless_null $P73, vivify_599
    die "Contextual %*HOW-METAATTR not found"
  vivify_599:
    store_lex "%*HOW-METAATTR", $P73
  vivify_598:
    set $P73["knowhow"], $P72
.annotate 'line', 35
    get_hll_global $P74, ["HLL";"Compiler"], "SerializationContextBuilder"
.annotate 'line', 37
    time $N75
    set $S76, $N75
    $P77 = $P74."new"($S76 :named("handle"))
.annotate 'line', 35
    store_lex "$*SC", $P77
.annotate 'line', 39
    new $P78, "String"
    assign $P78, ""
    store_lex "$*SCOPE", $P78
.annotate 'line', 40
    new $P79, "String"
    assign $P79, ""
    store_lex "$*MULTINESS", $P79
.annotate 'line', 41
    new $P80, "Integer"
    assign $P80, 0
    store_lex "$*INVOCANT_OK", $P80
.annotate 'line', 42
    new $P81, "Integer"
    assign $P81, 0
    store_lex "$*RETURN_USED", $P81
    find_lex $P82, "$*PACKAGE-SETUP"
    unless_null $P82, vivify_600
    get_hll_global $P82, "$PACKAGE-SETUP"
    unless_null $P82, vivify_601
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_601:
  vivify_600:
.annotate 'line', 44
    find_lex $P83, "self"
    $P84 = $P83."comp_unit"()
.annotate 'line', 10
    .return ($P84)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "identifier"  :subid("14_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx86_tgt
    .local int rx86_pos
    .local int rx86_off
    .local int rx86_eos
    .local int rx86_rep
    .local pmc rx86_cur
    .local pmc rx86_debug
    (rx86_cur, rx86_pos, rx86_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx86_cur
    .local pmc match
    .lex "$/", match
    length rx86_eos, rx86_tgt
    gt rx86_pos, rx86_eos, rx86_done
    set rx86_off, 0
    lt rx86_pos, 2, rx86_start
    sub rx86_off, rx86_pos, 1
    substr rx86_tgt, rx86_tgt, rx86_off
  rx86_start:
    eq $I10, 1, rx86_restart
    if_null rx86_debug, debug_602
    rx86_cur."!cursor_debug"("START", "identifier")
  debug_602:
    $I10 = self.'from'()
    ne $I10, -1, rxscan90_done
    goto rxscan90_scan
  rxscan90_loop:
    (rx86_pos) = rx86_cur."from"()
    inc rx86_pos
    rx86_cur."!cursor_from"(rx86_pos)
    ge rx86_pos, rx86_eos, rxscan90_done
  rxscan90_scan:
    set_addr $I10, rxscan90_loop
    rx86_cur."!mark_push"(0, rx86_pos, $I10)
  rxscan90_done:
.annotate 'line', 49
  # rx subrule "ident" subtype=method negate=
    rx86_cur."!cursor_pos"(rx86_pos)
    $P10 = rx86_cur."ident"()
    unless $P10, rx86_fail
    rx86_pos = $P10."pos"()
  # rx rxquantr91 ** 0..*
    set_addr $I10, rxquantr91_done
    rx86_cur."!mark_push"(0, rx86_pos, $I10)
  rxquantr91_loop:
  # rx enumcharlist negate=0 
    ge rx86_pos, rx86_eos, rx86_fail
    sub $I10, rx86_pos, rx86_off
    substr $S10, rx86_tgt, $I10, 1
    index $I11, "-'", $S10
    lt $I11, 0, rx86_fail
    inc rx86_pos
  # rx subrule "ident" subtype=method negate=
    rx86_cur."!cursor_pos"(rx86_pos)
    $P10 = rx86_cur."ident"()
    unless $P10, rx86_fail
    rx86_pos = $P10."pos"()
    set_addr $I10, rxquantr91_done
    (rx86_rep) = rx86_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr91_done
    rx86_cur."!mark_push"(rx86_rep, rx86_pos, $I10)
    goto rxquantr91_loop
  rxquantr91_done:
  # rx pass
    rx86_cur."!cursor_pass"(rx86_pos, "identifier")
    if_null rx86_debug, debug_603
    rx86_cur."!cursor_debug"("PASS", "identifier", " at pos=", rx86_pos)
  debug_603:
    .return (rx86_cur)
  rx86_restart:
.annotate 'line', 10
    if_null rx86_debug, debug_604
    rx86_cur."!cursor_debug"("NEXT", "identifier")
  debug_604:
  rx86_fail:
    (rx86_rep, rx86_pos, $I10, $P10) = rx86_cur."!mark_fail"(0)
    lt rx86_pos, -1, rx86_done
    eq rx86_pos, -1, rx86_fail
    jump $I10
  rx86_done:
    rx86_cur."!cursor_fail"()
    if_null rx86_debug, debug_605
    rx86_cur."!cursor_debug"("FAIL", "identifier")
  debug_605:
    .return (rx86_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__identifier"  :nsentry("!PREFIX__identifier") :subid("15_1300062003.824") :method
.annotate 'line', 10
    $P88 = self."!PREFIX__!subrule"("ident", "")
    new $P89, "ResizablePMCArray"
    push $P89, $P88
    .return ($P89)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "name"  :subid("16_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx93_tgt
    .local int rx93_pos
    .local int rx93_off
    .local int rx93_eos
    .local int rx93_rep
    .local pmc rx93_cur
    .local pmc rx93_debug
    (rx93_cur, rx93_pos, rx93_tgt, $I10) = self."!cursor_start"()
    rx93_cur."!cursor_caparray"("identifier")
    .lex unicode:"$\x{a2}", rx93_cur
    .local pmc match
    .lex "$/", match
    length rx93_eos, rx93_tgt
    gt rx93_pos, rx93_eos, rx93_done
    set rx93_off, 0
    lt rx93_pos, 2, rx93_start
    sub rx93_off, rx93_pos, 1
    substr rx93_tgt, rx93_tgt, rx93_off
  rx93_start:
    eq $I10, 1, rx93_restart
    if_null rx93_debug, debug_606
    rx93_cur."!cursor_debug"("START", "name")
  debug_606:
    $I10 = self.'from'()
    ne $I10, -1, rxscan96_done
    goto rxscan96_scan
  rxscan96_loop:
    (rx93_pos) = rx93_cur."from"()
    inc rx93_pos
    rx93_cur."!cursor_from"(rx93_pos)
    ge rx93_pos, rx93_eos, rxscan96_done
  rxscan96_scan:
    set_addr $I10, rxscan96_loop
    rx93_cur."!mark_push"(0, rx93_pos, $I10)
  rxscan96_done:
.annotate 'line', 51
  # rx rxquantr97 ** 1..*
    set_addr $I10, rxquantr97_done
    rx93_cur."!mark_push"(0, -1, $I10)
  rxquantr97_loop:
  # rx subrule "identifier" subtype=capture negate=
    rx93_cur."!cursor_pos"(rx93_pos)
    $P10 = rx93_cur."identifier"()
    unless $P10, rx93_fail
    goto rxsubrule98_pass
  rxsubrule98_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx93_fail
  rxsubrule98_pass:
    set_addr $I10, rxsubrule98_back
    rx93_cur."!mark_push"(0, rx93_pos, $I10, $P10)
    $P10."!cursor_names"("identifier")
    rx93_pos = $P10."pos"()
    set_addr $I10, rxquantr97_done
    (rx93_rep) = rx93_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr97_done
    rx93_cur."!mark_push"(rx93_rep, rx93_pos, $I10)
  # rx literal  "::"
    add $I11, rx93_pos, 2
    gt $I11, rx93_eos, rx93_fail
    sub $I11, rx93_pos, rx93_off
    substr $S10, rx93_tgt, $I11, 2
    ne $S10, "::", rx93_fail
    add rx93_pos, 2
    goto rxquantr97_loop
  rxquantr97_done:
  # rx pass
    rx93_cur."!cursor_pass"(rx93_pos, "name")
    if_null rx93_debug, debug_607
    rx93_cur."!cursor_debug"("PASS", "name", " at pos=", rx93_pos)
  debug_607:
    .return (rx93_cur)
  rx93_restart:
.annotate 'line', 10
    if_null rx93_debug, debug_608
    rx93_cur."!cursor_debug"("NEXT", "name")
  debug_608:
  rx93_fail:
    (rx93_rep, rx93_pos, $I10, $P10) = rx93_cur."!mark_fail"(0)
    lt rx93_pos, -1, rx93_done
    eq rx93_pos, -1, rx93_fail
    jump $I10
  rx93_done:
    rx93_cur."!cursor_fail"()
    if_null rx93_debug, debug_609
    rx93_cur."!cursor_debug"("FAIL", "name")
  debug_609:
    .return (rx93_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__name"  :nsentry("!PREFIX__name") :subid("17_1300062003.824") :method
.annotate 'line', 10
    new $P95, "ResizablePMCArray"
    push $P95, ""
    .return ($P95)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "deflongname"  :subid("18_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx100_tgt
    .local int rx100_pos
    .local int rx100_off
    .local int rx100_eos
    .local int rx100_rep
    .local pmc rx100_cur
    .local pmc rx100_debug
    (rx100_cur, rx100_pos, rx100_tgt, $I10) = self."!cursor_start"()
    rx100_cur."!cursor_caparray"("colonpair")
    .lex unicode:"$\x{a2}", rx100_cur
    .local pmc match
    .lex "$/", match
    length rx100_eos, rx100_tgt
    gt rx100_pos, rx100_eos, rx100_done
    set rx100_off, 0
    lt rx100_pos, 2, rx100_start
    sub rx100_off, rx100_pos, 1
    substr rx100_tgt, rx100_tgt, rx100_off
  rx100_start:
    eq $I10, 1, rx100_restart
    if_null rx100_debug, debug_610
    rx100_cur."!cursor_debug"("START", "deflongname")
  debug_610:
    $I10 = self.'from'()
    ne $I10, -1, rxscan104_done
    goto rxscan104_scan
  rxscan104_loop:
    (rx100_pos) = rx100_cur."from"()
    inc rx100_pos
    rx100_cur."!cursor_from"(rx100_pos)
    ge rx100_pos, rx100_eos, rxscan104_done
  rxscan104_scan:
    set_addr $I10, rxscan104_loop
    rx100_cur."!mark_push"(0, rx100_pos, $I10)
  rxscan104_done:
.annotate 'line', 54
  # rx subrule "identifier" subtype=capture negate=
    rx100_cur."!cursor_pos"(rx100_pos)
    $P10 = rx100_cur."identifier"()
    unless $P10, rx100_fail
    rx100_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx100_pos = $P10."pos"()
  # rx rxquantr105 ** 0..1
    set_addr $I10, rxquantr105_done
    rx100_cur."!mark_push"(0, rx100_pos, $I10)
  rxquantr105_loop:
  # rx subrule "colonpair" subtype=capture negate=
    rx100_cur."!cursor_pos"(rx100_pos)
    $P10 = rx100_cur."colonpair"()
    unless $P10, rx100_fail
    goto rxsubrule106_pass
  rxsubrule106_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx100_fail
  rxsubrule106_pass:
    set_addr $I10, rxsubrule106_back
    rx100_cur."!mark_push"(0, rx100_pos, $I10, $P10)
    $P10."!cursor_names"("colonpair")
    rx100_pos = $P10."pos"()
    set_addr $I10, rxquantr105_done
    (rx100_rep) = rx100_cur."!mark_commit"($I10)
  rxquantr105_done:
.annotate 'line', 53
  # rx pass
    rx100_cur."!cursor_pass"(rx100_pos, "deflongname")
    if_null rx100_debug, debug_611
    rx100_cur."!cursor_debug"("PASS", "deflongname", " at pos=", rx100_pos)
  debug_611:
    .return (rx100_cur)
  rx100_restart:
.annotate 'line', 10
    if_null rx100_debug, debug_612
    rx100_cur."!cursor_debug"("NEXT", "deflongname")
  debug_612:
  rx100_fail:
    (rx100_rep, rx100_pos, $I10, $P10) = rx100_cur."!mark_fail"(0)
    lt rx100_pos, -1, rx100_done
    eq rx100_pos, -1, rx100_fail
    jump $I10
  rx100_done:
    rx100_cur."!cursor_fail"()
    if_null rx100_debug, debug_613
    rx100_cur."!cursor_debug"("FAIL", "deflongname")
  debug_613:
    .return (rx100_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__deflongname"  :nsentry("!PREFIX__deflongname") :subid("19_1300062003.824") :method
.annotate 'line', 10
    $P102 = self."!PREFIX__!subrule"("identifier", "")
    new $P103, "ResizablePMCArray"
    push $P103, $P102
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ENDSTMT"  :subid("20_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx108_tgt
    .local int rx108_pos
    .local int rx108_off
    .local int rx108_eos
    .local int rx108_rep
    .local pmc rx108_cur
    .local pmc rx108_debug
    (rx108_cur, rx108_pos, rx108_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx108_cur
    .local pmc match
    .lex "$/", match
    length rx108_eos, rx108_tgt
    gt rx108_pos, rx108_eos, rx108_done
    set rx108_off, 0
    lt rx108_pos, 2, rx108_start
    sub rx108_off, rx108_pos, 1
    substr rx108_tgt, rx108_tgt, rx108_off
  rx108_start:
    eq $I10, 1, rx108_restart
    if_null rx108_debug, debug_614
    rx108_cur."!cursor_debug"("START", "ENDSTMT")
  debug_614:
    $I10 = self.'from'()
    ne $I10, -1, rxscan111_done
    goto rxscan111_scan
  rxscan111_loop:
    (rx108_pos) = rx108_cur."from"()
    inc rx108_pos
    rx108_cur."!cursor_from"(rx108_pos)
    ge rx108_pos, rx108_eos, rxscan111_done
  rxscan111_scan:
    set_addr $I10, rxscan111_loop
    rx108_cur."!mark_push"(0, rx108_pos, $I10)
  rxscan111_done:
.annotate 'line', 61
  # rx rxquantr112 ** 0..1
    set_addr $I10, rxquantr112_done
    rx108_cur."!mark_push"(0, rx108_pos, $I10)
  rxquantr112_loop:
  alt113_0:
.annotate 'line', 58
    set_addr $I10, alt113_1
    rx108_cur."!mark_push"(0, rx108_pos, $I10)
.annotate 'line', 59
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx108_pos, rx108_off
    set rx108_rep, 0
    sub $I12, rx108_eos, rx108_pos
  rxenumcharlistq114_loop:
    le $I12, 0, rxenumcharlistq114_done
    substr $S10, rx108_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq114_done
    inc rx108_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq114_loop
  rxenumcharlistq114_done:
    add rx108_pos, rx108_pos, rx108_rep
  # rxanchor eol
    sub $I10, rx108_pos, rx108_off
    is_cclass $I11, 4096, rx108_tgt, $I10
    if $I11, rxanchor115_done
    ne rx108_pos, rx108_eos, rx108_fail
    eq rx108_pos, 0, rxanchor115_done
    dec $I10
    is_cclass $I11, 4096, rx108_tgt, $I10
    if $I11, rx108_fail
  rxanchor115_done:
  # rx subrule "ws" subtype=method negate=
    rx108_cur."!cursor_pos"(rx108_pos)
    $P10 = rx108_cur."ws"()
    unless $P10, rx108_fail
    rx108_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx108_cur."!cursor_pos"(rx108_pos)
    $P10 = rx108_cur."MARKER"("endstmt")
    unless $P10, rx108_fail
    goto alt113_end
  alt113_1:
.annotate 'line', 60
  # rx rxquantr116 ** 0..1
    set_addr $I10, rxquantr116_done
    rx108_cur."!mark_push"(0, rx108_pos, $I10)
  rxquantr116_loop:
  # rx subrule "unv" subtype=method negate=
    rx108_cur."!cursor_pos"(rx108_pos)
    $P10 = rx108_cur."unv"()
    unless $P10, rx108_fail
    goto rxsubrule117_pass
  rxsubrule117_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx108_fail
  rxsubrule117_pass:
    set_addr $I10, rxsubrule117_back
    rx108_cur."!mark_push"(0, rx108_pos, $I10, $P10)
    rx108_pos = $P10."pos"()
    set_addr $I10, rxquantr116_done
    (rx108_rep) = rx108_cur."!mark_commit"($I10)
  rxquantr116_done:
  # rxanchor eol
    sub $I10, rx108_pos, rx108_off
    is_cclass $I11, 4096, rx108_tgt, $I10
    if $I11, rxanchor118_done
    ne rx108_pos, rx108_eos, rx108_fail
    eq rx108_pos, 0, rxanchor118_done
    dec $I10
    is_cclass $I11, 4096, rx108_tgt, $I10
    if $I11, rx108_fail
  rxanchor118_done:
  # rx subrule "ws" subtype=method negate=
    rx108_cur."!cursor_pos"(rx108_pos)
    $P10 = rx108_cur."ws"()
    unless $P10, rx108_fail
    rx108_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx108_cur."!cursor_pos"(rx108_pos)
    $P10 = rx108_cur."MARKER"("endstmt")
    unless $P10, rx108_fail
  alt113_end:
.annotate 'line', 61
    set_addr $I10, rxquantr112_done
    (rx108_rep) = rx108_cur."!mark_commit"($I10)
  rxquantr112_done:
.annotate 'line', 57
  # rx pass
    rx108_cur."!cursor_pass"(rx108_pos, "ENDSTMT")
    if_null rx108_debug, debug_615
    rx108_cur."!cursor_debug"("PASS", "ENDSTMT", " at pos=", rx108_pos)
  debug_615:
    .return (rx108_cur)
  rx108_restart:
.annotate 'line', 10
    if_null rx108_debug, debug_616
    rx108_cur."!cursor_debug"("NEXT", "ENDSTMT")
  debug_616:
  rx108_fail:
    (rx108_rep, rx108_pos, $I10, $P10) = rx108_cur."!mark_fail"(0)
    lt rx108_pos, -1, rx108_done
    eq rx108_pos, -1, rx108_fail
    jump $I10
  rx108_done:
    rx108_cur."!cursor_fail"()
    if_null rx108_debug, debug_617
    rx108_cur."!cursor_debug"("FAIL", "ENDSTMT")
  debug_617:
    .return (rx108_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ENDSTMT"  :nsentry("!PREFIX__ENDSTMT") :subid("21_1300062003.824") :method
.annotate 'line', 10
    new $P110, "ResizablePMCArray"
    push $P110, ""
    .return ($P110)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ws"  :subid("22_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx120_tgt
    .local int rx120_pos
    .local int rx120_off
    .local int rx120_eos
    .local int rx120_rep
    .local pmc rx120_cur
    .local pmc rx120_debug
    (rx120_cur, rx120_pos, rx120_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx120_cur
    .local pmc match
    .lex "$/", match
    length rx120_eos, rx120_tgt
    gt rx120_pos, rx120_eos, rx120_done
    set rx120_off, 0
    lt rx120_pos, 2, rx120_start
    sub rx120_off, rx120_pos, 1
    substr rx120_tgt, rx120_tgt, rx120_off
  rx120_start:
    eq $I10, 1, rx120_restart
    if_null rx120_debug, debug_618
    rx120_cur."!cursor_debug"("START", "ws")
  debug_618:
    $I10 = self.'from'()
    ne $I10, -1, rxscan123_done
    goto rxscan123_scan
  rxscan123_loop:
    (rx120_pos) = rx120_cur."from"()
    inc rx120_pos
    rx120_cur."!cursor_from"(rx120_pos)
    ge rx120_pos, rx120_eos, rxscan123_done
  rxscan123_scan:
    set_addr $I10, rxscan123_loop
    rx120_cur."!mark_push"(0, rx120_pos, $I10)
  rxscan123_done:
  alt124_0:
.annotate 'line', 64
    set_addr $I10, alt124_1
    rx120_cur."!mark_push"(0, rx120_pos, $I10)
.annotate 'line', 65
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx120_cur."!cursor_pos"(rx120_pos)
    $P10 = rx120_cur."MARKED"("ws")
    unless $P10, rx120_fail
    goto alt124_end
  alt124_1:
.annotate 'line', 66
  # rx subrule "ww" subtype=zerowidth negate=1
    rx120_cur."!cursor_pos"(rx120_pos)
    $P10 = rx120_cur."ww"()
    if $P10, rx120_fail
.annotate 'line', 71
  # rx rxquantr125 ** 0..*
    set_addr $I10, rxquantr125_done
    rx120_cur."!mark_push"(0, rx120_pos, $I10)
  rxquantr125_loop:
  alt126_0:
.annotate 'line', 67
    set_addr $I10, alt126_1
    rx120_cur."!mark_push"(0, rx120_pos, $I10)
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx120_pos, rx120_off
    set rx120_rep, 0
    sub $I12, rx120_eos, rx120_pos
  rxenumcharlistq127_loop:
    le $I12, 0, rxenumcharlistq127_done
    substr $S10, rx120_tgt, $I10, 1
    index $I11, unicode:"\n\x{b}\f\r\x{85}\u2028\u2029", $S10
    lt $I11, 0, rxenumcharlistq127_done
    inc rx120_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq127_loop
  rxenumcharlistq127_done:
    lt rx120_rep, 1, rx120_fail
    add rx120_pos, rx120_pos, rx120_rep
    goto alt126_end
  alt126_1:
    set_addr $I10, alt126_2
    rx120_cur."!mark_push"(0, rx120_pos, $I10)
.annotate 'line', 68
  # rx literal  "#"
    add $I11, rx120_pos, 1
    gt $I11, rx120_eos, rx120_fail
    sub $I11, rx120_pos, rx120_off
    ord $I11, rx120_tgt, $I11
    ne $I11, 35, rx120_fail
    add rx120_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx120_pos, rx120_off
    find_cclass $I11, 4096, rx120_tgt, $I10, rx120_eos
    add rx120_pos, rx120_off, $I11
    goto alt126_end
  alt126_2:
    set_addr $I10, alt126_3
    rx120_cur."!mark_push"(0, rx120_pos, $I10)
.annotate 'line', 69
  # rxanchor bol
    eq rx120_pos, 0, rxanchor128_done
    ge rx120_pos, rx120_eos, rx120_fail
    sub $I10, rx120_pos, rx120_off
    dec $I10
    is_cclass $I11, 4096, rx120_tgt, $I10
    unless $I11, rx120_fail
  rxanchor128_done:
  # rx subrule "pod_comment" subtype=method negate=
    rx120_cur."!cursor_pos"(rx120_pos)
    $P10 = rx120_cur."pod_comment"()
    unless $P10, rx120_fail
    rx120_pos = $P10."pos"()
    goto alt126_end
  alt126_3:
.annotate 'line', 70
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx120_pos, rx120_off
    set rx120_rep, 0
    sub $I12, rx120_eos, rx120_pos
  rxenumcharlistq129_loop:
    le $I12, 0, rxenumcharlistq129_done
    substr $S10, rx120_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq129_done
    inc rx120_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq129_loop
  rxenumcharlistq129_done:
    lt rx120_rep, 1, rx120_fail
    add rx120_pos, rx120_pos, rx120_rep
  alt126_end:
.annotate 'line', 71
    set_addr $I10, rxquantr125_done
    (rx120_rep) = rx120_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr125_done
    rx120_cur."!mark_push"(rx120_rep, rx120_pos, $I10)
    goto rxquantr125_loop
  rxquantr125_done:
.annotate 'line', 72
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx120_cur."!cursor_pos"(rx120_pos)
    $P10 = rx120_cur."MARKER"("ws")
    unless $P10, rx120_fail
  alt124_end:
.annotate 'line', 64
  # rx pass
    rx120_cur."!cursor_pass"(rx120_pos, "ws")
    if_null rx120_debug, debug_619
    rx120_cur."!cursor_debug"("PASS", "ws", " at pos=", rx120_pos)
  debug_619:
    .return (rx120_cur)
  rx120_restart:
.annotate 'line', 10
    if_null rx120_debug, debug_620
    rx120_cur."!cursor_debug"("NEXT", "ws")
  debug_620:
  rx120_fail:
    (rx120_rep, rx120_pos, $I10, $P10) = rx120_cur."!mark_fail"(0)
    lt rx120_pos, -1, rx120_done
    eq rx120_pos, -1, rx120_fail
    jump $I10
  rx120_done:
    rx120_cur."!cursor_fail"()
    if_null rx120_debug, debug_621
    rx120_cur."!cursor_debug"("FAIL", "ws")
  debug_621:
    .return (rx120_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ws"  :nsentry("!PREFIX__ws") :subid("23_1300062003.824") :method
.annotate 'line', 10
    new $P122, "ResizablePMCArray"
    push $P122, ""
    push $P122, ""
    .return ($P122)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "unv"  :subid("24_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .const 'Sub' $P138 = "26_1300062003.824" 
    capture_lex $P138
    .local string rx131_tgt
    .local int rx131_pos
    .local int rx131_off
    .local int rx131_eos
    .local int rx131_rep
    .local pmc rx131_cur
    .local pmc rx131_debug
    (rx131_cur, rx131_pos, rx131_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx131_cur
    .local pmc match
    .lex "$/", match
    length rx131_eos, rx131_tgt
    gt rx131_pos, rx131_eos, rx131_done
    set rx131_off, 0
    lt rx131_pos, 2, rx131_start
    sub rx131_off, rx131_pos, 1
    substr rx131_tgt, rx131_tgt, rx131_off
  rx131_start:
    eq $I10, 1, rx131_restart
    if_null rx131_debug, debug_622
    rx131_cur."!cursor_debug"("START", "unv")
  debug_622:
    $I10 = self.'from'()
    ne $I10, -1, rxscan134_done
    goto rxscan134_scan
  rxscan134_loop:
    (rx131_pos) = rx131_cur."from"()
    inc rx131_pos
    rx131_cur."!cursor_from"(rx131_pos)
    ge rx131_pos, rx131_eos, rxscan134_done
  rxscan134_scan:
    set_addr $I10, rxscan134_loop
    rx131_cur."!mark_push"(0, rx131_pos, $I10)
  rxscan134_done:
  alt135_0:
.annotate 'line', 77
    set_addr $I10, alt135_1
    rx131_cur."!mark_push"(0, rx131_pos, $I10)
.annotate 'line', 78
  # rxanchor bol
    eq rx131_pos, 0, rxanchor136_done
    ge rx131_pos, rx131_eos, rx131_fail
    sub $I10, rx131_pos, rx131_off
    dec $I10
    is_cclass $I11, 4096, rx131_tgt, $I10
    unless $I11, rx131_fail
  rxanchor136_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx131_cur."!cursor_pos"(rx131_pos)
    .const 'Sub' $P138 = "26_1300062003.824" 
    capture_lex $P138
    $P10 = rx131_cur."before"($P138)
    unless $P10, rx131_fail
  # rx subrule "pod_comment" subtype=method negate=
    rx131_cur."!cursor_pos"(rx131_pos)
    $P10 = rx131_cur."pod_comment"()
    unless $P10, rx131_fail
    rx131_pos = $P10."pos"()
    goto alt135_end
  alt135_1:
    set_addr $I10, alt135_2
    rx131_cur."!mark_push"(0, rx131_pos, $I10)
.annotate 'line', 79
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx131_pos, rx131_off
    set rx131_rep, 0
    sub $I12, rx131_eos, rx131_pos
  rxenumcharlistq143_loop:
    le $I12, 0, rxenumcharlistq143_done
    substr $S10, rx131_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq143_done
    inc rx131_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq143_loop
  rxenumcharlistq143_done:
    add rx131_pos, rx131_pos, rx131_rep
  # rx literal  "#"
    add $I11, rx131_pos, 1
    gt $I11, rx131_eos, rx131_fail
    sub $I11, rx131_pos, rx131_off
    ord $I11, rx131_tgt, $I11
    ne $I11, 35, rx131_fail
    add rx131_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx131_pos, rx131_off
    find_cclass $I11, 4096, rx131_tgt, $I10, rx131_eos
    add rx131_pos, rx131_off, $I11
    goto alt135_end
  alt135_2:
.annotate 'line', 80
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx131_pos, rx131_off
    set rx131_rep, 0
    sub $I12, rx131_eos, rx131_pos
  rxenumcharlistq144_loop:
    le $I12, 0, rxenumcharlistq144_done
    substr $S10, rx131_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq144_done
    inc rx131_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq144_loop
  rxenumcharlistq144_done:
    lt rx131_rep, 1, rx131_fail
    add rx131_pos, rx131_pos, rx131_rep
  alt135_end:
.annotate 'line', 75
  # rx pass
    rx131_cur."!cursor_pass"(rx131_pos, "unv")
    if_null rx131_debug, debug_627
    rx131_cur."!cursor_debug"("PASS", "unv", " at pos=", rx131_pos)
  debug_627:
    .return (rx131_cur)
  rx131_restart:
.annotate 'line', 10
    if_null rx131_debug, debug_628
    rx131_cur."!cursor_debug"("NEXT", "unv")
  debug_628:
  rx131_fail:
    (rx131_rep, rx131_pos, $I10, $P10) = rx131_cur."!mark_fail"(0)
    lt rx131_pos, -1, rx131_done
    eq rx131_pos, -1, rx131_fail
    jump $I10
  rx131_done:
    rx131_cur."!cursor_fail"()
    if_null rx131_debug, debug_629
    rx131_cur."!cursor_debug"("FAIL", "unv")
  debug_629:
    .return (rx131_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__unv"  :nsentry("!PREFIX__unv") :subid("25_1300062003.824") :method
.annotate 'line', 10
    new $P133, "ResizablePMCArray"
    push $P133, ""
    push $P133, ""
    push $P133, ""
    .return ($P133)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block137"  :anon :subid("26_1300062003.824") :method :outer("24_1300062003.824")
.annotate 'line', 78
    .local string rx139_tgt
    .local int rx139_pos
    .local int rx139_off
    .local int rx139_eos
    .local int rx139_rep
    .local pmc rx139_cur
    .local pmc rx139_debug
    (rx139_cur, rx139_pos, rx139_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx139_cur
    .local pmc match
    .lex "$/", match
    length rx139_eos, rx139_tgt
    gt rx139_pos, rx139_eos, rx139_done
    set rx139_off, 0
    lt rx139_pos, 2, rx139_start
    sub rx139_off, rx139_pos, 1
    substr rx139_tgt, rx139_tgt, rx139_off
  rx139_start:
    eq $I10, 1, rx139_restart
    if_null rx139_debug, debug_623
    rx139_cur."!cursor_debug"("START", "")
  debug_623:
    $I10 = self.'from'()
    ne $I10, -1, rxscan140_done
    goto rxscan140_scan
  rxscan140_loop:
    (rx139_pos) = rx139_cur."from"()
    inc rx139_pos
    rx139_cur."!cursor_from"(rx139_pos)
    ge rx139_pos, rx139_eos, rxscan140_done
  rxscan140_scan:
    set_addr $I10, rxscan140_loop
    rx139_cur."!mark_push"(0, rx139_pos, $I10)
  rxscan140_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx139_pos, rx139_off
    set rx139_rep, 0
    sub $I12, rx139_eos, rx139_pos
  rxenumcharlistq141_loop:
    le $I12, 0, rxenumcharlistq141_done
    substr $S10, rx139_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq141_done
    inc rx139_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq141_loop
  rxenumcharlistq141_done:
    add rx139_pos, rx139_pos, rx139_rep
  # rx literal  "="
    add $I11, rx139_pos, 1
    gt $I11, rx139_eos, rx139_fail
    sub $I11, rx139_pos, rx139_off
    ord $I11, rx139_tgt, $I11
    ne $I11, 61, rx139_fail
    add rx139_pos, 1
  alt142_0:
    set_addr $I10, alt142_1
    rx139_cur."!mark_push"(0, rx139_pos, $I10)
  # rx charclass w
    ge rx139_pos, rx139_eos, rx139_fail
    sub $I10, rx139_pos, rx139_off
    is_cclass $I11, 8192, rx139_tgt, $I10
    unless $I11, rx139_fail
    inc rx139_pos
    goto alt142_end
  alt142_1:
  # rx literal  "\\"
    add $I11, rx139_pos, 1
    gt $I11, rx139_eos, rx139_fail
    sub $I11, rx139_pos, rx139_off
    ord $I11, rx139_tgt, $I11
    ne $I11, 92, rx139_fail
    add rx139_pos, 1
  alt142_end:
  # rx pass
    rx139_cur."!cursor_pass"(rx139_pos, "")
    if_null rx139_debug, debug_624
    rx139_cur."!cursor_debug"("PASS", "", " at pos=", rx139_pos)
  debug_624:
    .return (rx139_cur)
  rx139_restart:
    if_null rx139_debug, debug_625
    rx139_cur."!cursor_debug"("NEXT", "")
  debug_625:
  rx139_fail:
    (rx139_rep, rx139_pos, $I10, $P10) = rx139_cur."!mark_fail"(0)
    lt rx139_pos, -1, rx139_done
    eq rx139_pos, -1, rx139_fail
    jump $I10
  rx139_done:
    rx139_cur."!cursor_fail"()
    if_null rx139_debug, debug_626
    rx139_cur."!cursor_debug"("FAIL", "")
  debug_626:
    .return (rx139_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pod_comment"  :subid("27_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .const 'Sub' $P177 = "29_1300062003.824" 
    capture_lex $P177
    .local string rx146_tgt
    .local int rx146_pos
    .local int rx146_off
    .local int rx146_eos
    .local int rx146_rep
    .local pmc rx146_cur
    .local pmc rx146_debug
    (rx146_cur, rx146_pos, rx146_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx146_cur
    .local pmc match
    .lex "$/", match
    length rx146_eos, rx146_tgt
    gt rx146_pos, rx146_eos, rx146_done
    set rx146_off, 0
    lt rx146_pos, 2, rx146_start
    sub rx146_off, rx146_pos, 1
    substr rx146_tgt, rx146_tgt, rx146_off
  rx146_start:
    eq $I10, 1, rx146_restart
    if_null rx146_debug, debug_630
    rx146_cur."!cursor_debug"("START", "pod_comment")
  debug_630:
    $I10 = self.'from'()
    ne $I10, -1, rxscan149_done
    goto rxscan149_scan
  rxscan149_loop:
    (rx146_pos) = rx146_cur."from"()
    inc rx146_pos
    rx146_cur."!cursor_from"(rx146_pos)
    ge rx146_pos, rx146_eos, rxscan149_done
  rxscan149_scan:
    set_addr $I10, rxscan149_loop
    rx146_cur."!mark_push"(0, rx146_pos, $I10)
  rxscan149_done:
.annotate 'line', 85
  # rxanchor bol
    eq rx146_pos, 0, rxanchor150_done
    ge rx146_pos, rx146_eos, rx146_fail
    sub $I10, rx146_pos, rx146_off
    dec $I10
    is_cclass $I11, 4096, rx146_tgt, $I10
    unless $I11, rx146_fail
  rxanchor150_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx146_pos, rx146_off
    set rx146_rep, 0
    sub $I12, rx146_eos, rx146_pos
  rxenumcharlistq151_loop:
    le $I12, 0, rxenumcharlistq151_done
    substr $S10, rx146_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq151_done
    inc rx146_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq151_loop
  rxenumcharlistq151_done:
    add rx146_pos, rx146_pos, rx146_rep
  # rx literal  "="
    add $I11, rx146_pos, 1
    gt $I11, rx146_eos, rx146_fail
    sub $I11, rx146_pos, rx146_off
    ord $I11, rx146_tgt, $I11
    ne $I11, 61, rx146_fail
    add rx146_pos, 1
  alt152_0:
.annotate 'line', 86
    set_addr $I10, alt152_1
    rx146_cur."!mark_push"(0, rx146_pos, $I10)
.annotate 'line', 87
  # rx literal  "begin"
    add $I11, rx146_pos, 5
    gt $I11, rx146_eos, rx146_fail
    sub $I11, rx146_pos, rx146_off
    substr $S10, rx146_tgt, $I11, 5
    ne $S10, "begin", rx146_fail
    add rx146_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx146_pos, rx146_off
    set rx146_rep, 0
    sub $I12, rx146_eos, rx146_pos
  rxenumcharlistq153_loop:
    le $I12, 0, rxenumcharlistq153_done
    substr $S10, rx146_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq153_done
    inc rx146_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq153_loop
  rxenumcharlistq153_done:
    lt rx146_rep, 1, rx146_fail
    add rx146_pos, rx146_pos, rx146_rep
  # rx literal  "END"
    add $I11, rx146_pos, 3
    gt $I11, rx146_eos, rx146_fail
    sub $I11, rx146_pos, rx146_off
    substr $S10, rx146_tgt, $I11, 3
    ne $S10, "END", rx146_fail
    add rx146_pos, 3
  # rxanchor rwb
    le rx146_pos, 0, rx146_fail
    sub $I10, rx146_pos, rx146_off
    is_cclass $I11, 8192, rx146_tgt, $I10
    if $I11, rx146_fail
    dec $I10
    is_cclass $I11, 8192, rx146_tgt, $I10
    unless $I11, rx146_fail
  alt154_0:
.annotate 'line', 88
    set_addr $I10, alt154_1
    rx146_cur."!mark_push"(0, rx146_pos, $I10)
  # rx rxquantf155 ** 0..*
    set_addr $I10, rxquantf155_loop
    rx146_cur."!mark_push"(0, rx146_pos, $I10)
    goto rxquantf155_done
  rxquantf155_loop:
  # rx charclass .
    ge rx146_pos, rx146_eos, rx146_fail
    inc rx146_pos
    set_addr $I10, rxquantf155_loop
    rx146_cur."!mark_push"(rx146_rep, rx146_pos, $I10)
  rxquantf155_done:
  # rx charclass nl
    ge rx146_pos, rx146_eos, rx146_fail
    sub $I10, rx146_pos, rx146_off
    is_cclass $I11, 4096, rx146_tgt, $I10
    unless $I11, rx146_fail
    substr $S10, rx146_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx146_pos, $I11
    inc rx146_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx146_pos, rx146_off
    set rx146_rep, 0
    sub $I12, rx146_eos, rx146_pos
  rxenumcharlistq157_loop:
    le $I12, 0, rxenumcharlistq157_done
    substr $S10, rx146_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq157_done
    inc rx146_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq157_loop
  rxenumcharlistq157_done:
    add rx146_pos, rx146_pos, rx146_rep
  # rx literal  "=end"
    add $I11, rx146_pos, 4
    gt $I11, rx146_eos, rx146_fail
    sub $I11, rx146_pos, rx146_off
    substr $S10, rx146_tgt, $I11, 4
    ne $S10, "=end", rx146_fail
    add rx146_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx146_pos, rx146_off
    set rx146_rep, 0
    sub $I12, rx146_eos, rx146_pos
  rxenumcharlistq158_loop:
    le $I12, 0, rxenumcharlistq158_done
    substr $S10, rx146_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq158_done
    inc rx146_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq158_loop
  rxenumcharlistq158_done:
    lt rx146_rep, 1, rx146_fail
    add rx146_pos, rx146_pos, rx146_rep
  # rx literal  "END"
    add $I11, rx146_pos, 3
    gt $I11, rx146_eos, rx146_fail
    sub $I11, rx146_pos, rx146_off
    substr $S10, rx146_tgt, $I11, 3
    ne $S10, "END", rx146_fail
    add rx146_pos, 3
  # rxanchor rwb
    le rx146_pos, 0, rx146_fail
    sub $I10, rx146_pos, rx146_off
    is_cclass $I11, 8192, rx146_tgt, $I10
    if $I11, rx146_fail
    dec $I10
    is_cclass $I11, 8192, rx146_tgt, $I10
    unless $I11, rx146_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx146_pos, rx146_off
    find_cclass $I11, 4096, rx146_tgt, $I10, rx146_eos
    add rx146_pos, rx146_off, $I11
    goto alt154_end
  alt154_1:
  # rx charclass_q . r 0..-1
    sub $I10, rx146_pos, rx146_off
    find_not_cclass $I11, 65535, rx146_tgt, $I10, rx146_eos
    add rx146_pos, rx146_off, $I11
  alt154_end:
.annotate 'line', 87
    goto alt152_end
  alt152_1:
    set_addr $I10, alt152_2
    rx146_cur."!mark_push"(0, rx146_pos, $I10)
.annotate 'line', 89
  # rx literal  "begin"
    add $I11, rx146_pos, 5
    gt $I11, rx146_eos, rx146_fail
    sub $I11, rx146_pos, rx146_off
    substr $S10, rx146_tgt, $I11, 5
    ne $S10, "begin", rx146_fail
    add rx146_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx146_pos, rx146_off
    set rx146_rep, 0
    sub $I12, rx146_eos, rx146_pos
  rxenumcharlistq159_loop:
    le $I12, 0, rxenumcharlistq159_done
    substr $S10, rx146_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq159_done
    inc rx146_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq159_loop
  rxenumcharlistq159_done:
    lt rx146_rep, 1, rx146_fail
    add rx146_pos, rx146_pos, rx146_rep
  # rx subrule "identifier" subtype=capture negate=
    rx146_cur."!cursor_pos"(rx146_pos)
    $P10 = rx146_cur."identifier"()
    unless $P10, rx146_fail
    rx146_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx146_pos = $P10."pos"()
  alt160_0:
.annotate 'line', 90
    set_addr $I10, alt160_1
    rx146_cur."!mark_push"(0, rx146_pos, $I10)
.annotate 'line', 91
  # rx rxquantf161 ** 0..*
    set_addr $I10, rxquantf161_loop
    rx146_cur."!mark_push"(0, rx146_pos, $I10)
    goto rxquantf161_done
  rxquantf161_loop:
  # rx charclass .
    ge rx146_pos, rx146_eos, rx146_fail
    inc rx146_pos
    set_addr $I10, rxquantf161_loop
    rx146_cur."!mark_push"(rx146_rep, rx146_pos, $I10)
  rxquantf161_done:
  # rx charclass nl
    ge rx146_pos, rx146_eos, rx146_fail
    sub $I10, rx146_pos, rx146_off
    is_cclass $I11, 4096, rx146_tgt, $I10
    unless $I11, rx146_fail
    substr $S10, rx146_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx146_pos, $I11
    inc rx146_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx146_pos, rx146_off
    set rx146_rep, 0
    sub $I12, rx146_eos, rx146_pos
  rxenumcharlistq163_loop:
    le $I12, 0, rxenumcharlistq163_done
    substr $S10, rx146_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq163_done
    inc rx146_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq163_loop
  rxenumcharlistq163_done:
    add rx146_pos, rx146_pos, rx146_rep
  # rx literal  "=end"
    add $I11, rx146_pos, 4
    gt $I11, rx146_eos, rx146_fail
    sub $I11, rx146_pos, rx146_off
    substr $S10, rx146_tgt, $I11, 4
    ne $S10, "=end", rx146_fail
    add rx146_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx146_pos, rx146_off
    set rx146_rep, 0
    sub $I12, rx146_eos, rx146_pos
  rxenumcharlistq164_loop:
    le $I12, 0, rxenumcharlistq164_done
    substr $S10, rx146_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq164_done
    inc rx146_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq164_loop
  rxenumcharlistq164_done:
    lt rx146_rep, 1, rx146_fail
    add rx146_pos, rx146_pos, rx146_rep
  # rx subrule "!BACKREF" subtype=method negate=
    rx146_cur."!cursor_pos"(rx146_pos)
    $P10 = rx146_cur."!BACKREF"("identifier")
    unless $P10, rx146_fail
    rx146_pos = $P10."pos"()
  # rxanchor rwb
    le rx146_pos, 0, rx146_fail
    sub $I10, rx146_pos, rx146_off
    is_cclass $I11, 8192, rx146_tgt, $I10
    if $I11, rx146_fail
    dec $I10
    is_cclass $I11, 8192, rx146_tgt, $I10
    unless $I11, rx146_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx146_pos, rx146_off
    find_cclass $I11, 4096, rx146_tgt, $I10, rx146_eos
    add rx146_pos, rx146_off, $I11
    goto alt160_end
  alt160_1:
.annotate 'line', 92
  # rx subrule "panic" subtype=method negate=
    rx146_cur."!cursor_pos"(rx146_pos)
    $P10 = rx146_cur."panic"("=begin without matching =end")
    unless $P10, rx146_fail
    rx146_pos = $P10."pos"()
  alt160_end:
.annotate 'line', 89
    goto alt152_end
  alt152_2:
    set_addr $I10, alt152_3
    rx146_cur."!mark_push"(0, rx146_pos, $I10)
.annotate 'line', 94
  # rx literal  "begin"
    add $I11, rx146_pos, 5
    gt $I11, rx146_eos, rx146_fail
    sub $I11, rx146_pos, rx146_off
    substr $S10, rx146_tgt, $I11, 5
    ne $S10, "begin", rx146_fail
    add rx146_pos, 5
  # rxanchor rwb
    le rx146_pos, 0, rx146_fail
    sub $I10, rx146_pos, rx146_off
    is_cclass $I11, 8192, rx146_tgt, $I10
    if $I11, rx146_fail
    dec $I10
    is_cclass $I11, 8192, rx146_tgt, $I10
    unless $I11, rx146_fail
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx146_pos, rx146_off
    set rx146_rep, 0
    sub $I12, rx146_eos, rx146_pos
  rxenumcharlistq166_loop:
    le $I12, 0, rxenumcharlistq166_done
    substr $S10, rx146_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq166_done
    inc rx146_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq166_loop
  rxenumcharlistq166_done:
    add rx146_pos, rx146_pos, rx146_rep
  alt167_0:
.annotate 'line', 95
    set_addr $I10, alt167_1
    rx146_cur."!mark_push"(0, rx146_pos, $I10)
  # rxanchor eol
    sub $I10, rx146_pos, rx146_off
    is_cclass $I11, 4096, rx146_tgt, $I10
    if $I11, rxanchor168_done
    ne rx146_pos, rx146_eos, rx146_fail
    eq rx146_pos, 0, rxanchor168_done
    dec $I10
    is_cclass $I11, 4096, rx146_tgt, $I10
    if $I11, rx146_fail
  rxanchor168_done:
    goto alt167_end
  alt167_1:
    set_addr $I10, alt167_2
    rx146_cur."!mark_push"(0, rx146_pos, $I10)
  # rx literal  "#"
    add $I11, rx146_pos, 1
    gt $I11, rx146_eos, rx146_fail
    sub $I11, rx146_pos, rx146_off
    ord $I11, rx146_tgt, $I11
    ne $I11, 35, rx146_fail
    add rx146_pos, 1
    goto alt167_end
  alt167_2:
  # rx subrule "panic" subtype=method negate=
    rx146_cur."!cursor_pos"(rx146_pos)
    $P10 = rx146_cur."panic"("Unrecognized token after =begin")
    unless $P10, rx146_fail
    rx146_pos = $P10."pos"()
  alt167_end:
  alt169_0:
.annotate 'line', 96
    set_addr $I10, alt169_1
    rx146_cur."!mark_push"(0, rx146_pos, $I10)
.annotate 'line', 97
  # rx rxquantf170 ** 0..*
    set_addr $I10, rxquantf170_loop
    rx146_cur."!mark_push"(0, rx146_pos, $I10)
    goto rxquantf170_done
  rxquantf170_loop:
  # rx charclass .
    ge rx146_pos, rx146_eos, rx146_fail
    inc rx146_pos
    set_addr $I10, rxquantf170_loop
    rx146_cur."!mark_push"(rx146_rep, rx146_pos, $I10)
  rxquantf170_done:
  # rx charclass nl
    ge rx146_pos, rx146_eos, rx146_fail
    sub $I10, rx146_pos, rx146_off
    is_cclass $I11, 4096, rx146_tgt, $I10
    unless $I11, rx146_fail
    substr $S10, rx146_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx146_pos, $I11
    inc rx146_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx146_pos, rx146_off
    set rx146_rep, 0
    sub $I12, rx146_eos, rx146_pos
  rxenumcharlistq172_loop:
    le $I12, 0, rxenumcharlistq172_done
    substr $S10, rx146_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq172_done
    inc rx146_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq172_loop
  rxenumcharlistq172_done:
    add rx146_pos, rx146_pos, rx146_rep
  # rx literal  "=end"
    add $I11, rx146_pos, 4
    gt $I11, rx146_eos, rx146_fail
    sub $I11, rx146_pos, rx146_off
    substr $S10, rx146_tgt, $I11, 4
    ne $S10, "=end", rx146_fail
    add rx146_pos, 4
  # rxanchor rwb
    le rx146_pos, 0, rx146_fail
    sub $I10, rx146_pos, rx146_off
    is_cclass $I11, 8192, rx146_tgt, $I10
    if $I11, rx146_fail
    dec $I10
    is_cclass $I11, 8192, rx146_tgt, $I10
    unless $I11, rx146_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx146_pos, rx146_off
    find_cclass $I11, 4096, rx146_tgt, $I10, rx146_eos
    add rx146_pos, rx146_off, $I11
    goto alt169_end
  alt169_1:
.annotate 'line', 98
  # rx subrule "panic" subtype=method negate=
    rx146_cur."!cursor_pos"(rx146_pos)
    $P10 = rx146_cur."panic"("=begin without matching =end")
    unless $P10, rx146_fail
    rx146_pos = $P10."pos"()
  alt169_end:
.annotate 'line', 94
    goto alt152_end
  alt152_3:
    set_addr $I10, alt152_4
    rx146_cur."!mark_push"(0, rx146_pos, $I10)
.annotate 'line', 100
  # rx subrule "identifier" subtype=capture negate=
    rx146_cur."!cursor_pos"(rx146_pos)
    $P10 = rx146_cur."identifier"()
    unless $P10, rx146_fail
    rx146_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx146_pos = $P10."pos"()
.annotate 'line', 101
  # rx rxquantf173 ** 0..*
    set_addr $I10, rxquantf173_loop
    rx146_cur."!mark_push"(0, rx146_pos, $I10)
    goto rxquantf173_done
  rxquantf173_loop:
  # rx charclass .
    ge rx146_pos, rx146_eos, rx146_fail
    inc rx146_pos
    set_addr $I10, rxquantf173_loop
    rx146_cur."!mark_push"(rx146_rep, rx146_pos, $I10)
  rxquantf173_done:
  # rxanchor bol
    eq rx146_pos, 0, rxanchor175_done
    ge rx146_pos, rx146_eos, rx146_fail
    sub $I10, rx146_pos, rx146_off
    dec $I10
    is_cclass $I11, 4096, rx146_tgt, $I10
    unless $I11, rx146_fail
  rxanchor175_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx146_cur."!cursor_pos"(rx146_pos)
    .const 'Sub' $P177 = "29_1300062003.824" 
    capture_lex $P177
    $P10 = rx146_cur."before"($P177)
    unless $P10, rx146_fail
.annotate 'line', 100
    goto alt152_end
  alt152_4:
  alt183_0:
.annotate 'line', 107
    set_addr $I10, alt183_1
    rx146_cur."!mark_push"(0, rx146_pos, $I10)
  # rx charclass s
    ge rx146_pos, rx146_eos, rx146_fail
    sub $I10, rx146_pos, rx146_off
    is_cclass $I11, 32, rx146_tgt, $I10
    unless $I11, rx146_fail
    inc rx146_pos
    goto alt183_end
  alt183_1:
  # rx subrule "panic" subtype=method negate=
    rx146_cur."!cursor_pos"(rx146_pos)
    $P10 = rx146_cur."panic"("Illegal pod directive")
    unless $P10, rx146_fail
    rx146_pos = $P10."pos"()
  alt183_end:
.annotate 'line', 108
  # rx charclass_q N r 0..-1
    sub $I10, rx146_pos, rx146_off
    find_cclass $I11, 4096, rx146_tgt, $I10, rx146_eos
    add rx146_pos, rx146_off, $I11
  alt152_end:
.annotate 'line', 84
  # rx pass
    rx146_cur."!cursor_pass"(rx146_pos, "pod_comment")
    if_null rx146_debug, debug_635
    rx146_cur."!cursor_debug"("PASS", "pod_comment", " at pos=", rx146_pos)
  debug_635:
    .return (rx146_cur)
  rx146_restart:
.annotate 'line', 10
    if_null rx146_debug, debug_636
    rx146_cur."!cursor_debug"("NEXT", "pod_comment")
  debug_636:
  rx146_fail:
    (rx146_rep, rx146_pos, $I10, $P10) = rx146_cur."!mark_fail"(0)
    lt rx146_pos, -1, rx146_done
    eq rx146_pos, -1, rx146_fail
    jump $I10
  rx146_done:
    rx146_cur."!cursor_fail"()
    if_null rx146_debug, debug_637
    rx146_cur."!cursor_debug"("FAIL", "pod_comment")
  debug_637:
    .return (rx146_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pod_comment"  :nsentry("!PREFIX__pod_comment") :subid("28_1300062003.824") :method
.annotate 'line', 10
    new $P148, "ResizablePMCArray"
    push $P148, ""
    .return ($P148)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block176"  :anon :subid("29_1300062003.824") :method :outer("27_1300062003.824")
.annotate 'line', 101
    .local string rx178_tgt
    .local int rx178_pos
    .local int rx178_off
    .local int rx178_eos
    .local int rx178_rep
    .local pmc rx178_cur
    .local pmc rx178_debug
    (rx178_cur, rx178_pos, rx178_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx178_cur
    .local pmc match
    .lex "$/", match
    length rx178_eos, rx178_tgt
    gt rx178_pos, rx178_eos, rx178_done
    set rx178_off, 0
    lt rx178_pos, 2, rx178_start
    sub rx178_off, rx178_pos, 1
    substr rx178_tgt, rx178_tgt, rx178_off
  rx178_start:
    eq $I10, 1, rx178_restart
    if_null rx178_debug, debug_631
    rx178_cur."!cursor_debug"("START", "")
  debug_631:
    $I10 = self.'from'()
    ne $I10, -1, rxscan179_done
    goto rxscan179_scan
  rxscan179_loop:
    (rx178_pos) = rx178_cur."from"()
    inc rx178_pos
    rx178_cur."!cursor_from"(rx178_pos)
    ge rx178_pos, rx178_eos, rxscan179_done
  rxscan179_scan:
    set_addr $I10, rxscan179_loop
    rx178_cur."!mark_push"(0, rx178_pos, $I10)
  rxscan179_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx178_pos, rx178_off
    set rx178_rep, 0
    sub $I12, rx178_eos, rx178_pos
  rxenumcharlistq180_loop:
    le $I12, 0, rxenumcharlistq180_done
    substr $S10, rx178_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq180_done
    inc rx178_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq180_loop
  rxenumcharlistq180_done:
    add rx178_pos, rx178_pos, rx178_rep
  alt181_0:
    set_addr $I10, alt181_1
    rx178_cur."!mark_push"(0, rx178_pos, $I10)
.annotate 'line', 102
  # rx literal  "="
    add $I11, rx178_pos, 1
    gt $I11, rx178_eos, rx178_fail
    sub $I11, rx178_pos, rx178_off
    ord $I11, rx178_tgt, $I11
    ne $I11, 61, rx178_fail
    add rx178_pos, 1
.annotate 'line', 104
  # rx rxquantr182 ** 0..1
    set_addr $I10, rxquantr182_done
    rx178_cur."!mark_push"(0, rx178_pos, $I10)
  rxquantr182_loop:
.annotate 'line', 103
  # rx literal  "cut"
    add $I11, rx178_pos, 3
    gt $I11, rx178_eos, rx178_fail
    sub $I11, rx178_pos, rx178_off
    substr $S10, rx178_tgt, $I11, 3
    ne $S10, "cut", rx178_fail
    add rx178_pos, 3
  # rxanchor rwb
    le rx178_pos, 0, rx178_fail
    sub $I10, rx178_pos, rx178_off
    is_cclass $I11, 8192, rx178_tgt, $I10
    if $I11, rx178_fail
    dec $I10
    is_cclass $I11, 8192, rx178_tgt, $I10
    unless $I11, rx178_fail
.annotate 'line', 104
  # rx subrule "panic" subtype=method negate=
    rx178_cur."!cursor_pos"(rx178_pos)
    $P10 = rx178_cur."panic"("Obsolete pod format, please use =begin/=end instead")
    unless $P10, rx178_fail
    rx178_pos = $P10."pos"()
    set_addr $I10, rxquantr182_done
    (rx178_rep) = rx178_cur."!mark_commit"($I10)
  rxquantr182_done:
.annotate 'line', 101
    goto alt181_end
  alt181_1:
.annotate 'line', 105
  # rx charclass nl
    ge rx178_pos, rx178_eos, rx178_fail
    sub $I10, rx178_pos, rx178_off
    is_cclass $I11, 4096, rx178_tgt, $I10
    unless $I11, rx178_fail
    substr $S10, rx178_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx178_pos, $I11
    inc rx178_pos
  alt181_end:
.annotate 'line', 101
  # rx pass
    rx178_cur."!cursor_pass"(rx178_pos, "")
    if_null rx178_debug, debug_632
    rx178_cur."!cursor_debug"("PASS", "", " at pos=", rx178_pos)
  debug_632:
    .return (rx178_cur)
  rx178_restart:
    if_null rx178_debug, debug_633
    rx178_cur."!cursor_debug"("NEXT", "")
  debug_633:
  rx178_fail:
    (rx178_rep, rx178_pos, $I10, $P10) = rx178_cur."!mark_fail"(0)
    lt rx178_pos, -1, rx178_done
    eq rx178_pos, -1, rx178_fail
    jump $I10
  rx178_done:
    rx178_cur."!cursor_fail"()
    if_null rx178_debug, debug_634
    rx178_cur."!cursor_debug"("FAIL", "")
  debug_634:
    .return (rx178_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "comp_unit"  :subid("30_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 116
    new $P185, "Undef"
    .lex "$*HAS_YOU_ARE_HERE", $P185
.annotate 'line', 117
    new $P186, "Undef"
    .lex "$*MAIN_SUB", $P186
.annotate 'line', 10
    .local string rx187_tgt
    .local int rx187_pos
    .local int rx187_off
    .local int rx187_eos
    .local int rx187_rep
    .local pmc rx187_cur
    .local pmc rx187_debug
    (rx187_cur, rx187_pos, rx187_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx187_cur
    .local pmc match
    .lex "$/", match
    length rx187_eos, rx187_tgt
    gt rx187_pos, rx187_eos, rx187_done
    set rx187_off, 0
    lt rx187_pos, 2, rx187_start
    sub rx187_off, rx187_pos, 1
    substr rx187_tgt, rx187_tgt, rx187_off
  rx187_start:
    eq $I10, 1, rx187_restart
    if_null rx187_debug, debug_638
    rx187_cur."!cursor_debug"("START", "comp_unit")
  debug_638:
    $I10 = self.'from'()
    ne $I10, -1, rxscan191_done
    goto rxscan191_scan
  rxscan191_loop:
    (rx187_pos) = rx187_cur."from"()
    inc rx187_pos
    rx187_cur."!cursor_from"(rx187_pos)
    ge rx187_pos, rx187_eos, rxscan191_done
  rxscan191_scan:
    set_addr $I10, rxscan191_loop
    rx187_cur."!mark_push"(0, rx187_pos, $I10)
  rxscan191_done:
.annotate 'line', 116
    rx187_cur."!cursor_pos"(rx187_pos)
    new $P192, "Integer"
    assign $P192, 0
    store_lex "$*HAS_YOU_ARE_HERE", $P192
.annotate 'line', 117
    rx187_cur."!cursor_pos"(rx187_pos)
    find_lex $P193, "$*MAIN_SUB"
    unless_null $P193, vivify_639
    get_hll_global $P193, "$MAIN_SUB"
    unless_null $P193, vivify_640
    die "Contextual $*MAIN_SUB not found"
  vivify_640:
  vivify_639:
.annotate 'line', 118
  # rx subrule "newpad" subtype=method negate=
    rx187_cur."!cursor_pos"(rx187_pos)
    $P10 = rx187_cur."newpad"()
    unless $P10, rx187_fail
    rx187_pos = $P10."pos"()
.annotate 'line', 119
  # rx subrule "outerctx" subtype=method negate=
    rx187_cur."!cursor_pos"(rx187_pos)
    $P10 = rx187_cur."outerctx"()
    unless $P10, rx187_fail
    rx187_pos = $P10."pos"()
.annotate 'line', 120
  # rx subrule "statementlist" subtype=capture negate=
    rx187_cur."!cursor_pos"(rx187_pos)
    $P10 = rx187_cur."statementlist"()
    unless $P10, rx187_fail
    rx187_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx187_pos = $P10."pos"()
  alt194_0:
.annotate 'line', 121
    set_addr $I10, alt194_1
    rx187_cur."!mark_push"(0, rx187_pos, $I10)
  # rxanchor eos
    ne rx187_pos, rx187_eos, rx187_fail
    goto alt194_end
  alt194_1:
  # rx subrule "panic" subtype=method negate=
    rx187_cur."!cursor_pos"(rx187_pos)
    $P10 = rx187_cur."panic"("Confused")
    unless $P10, rx187_fail
    rx187_pos = $P10."pos"()
  alt194_end:
.annotate 'line', 115
  # rx pass
    rx187_cur."!cursor_pass"(rx187_pos, "comp_unit")
    if_null rx187_debug, debug_641
    rx187_cur."!cursor_debug"("PASS", "comp_unit", " at pos=", rx187_pos)
  debug_641:
    .return (rx187_cur)
  rx187_restart:
.annotate 'line', 10
    if_null rx187_debug, debug_642
    rx187_cur."!cursor_debug"("NEXT", "comp_unit")
  debug_642:
  rx187_fail:
    (rx187_rep, rx187_pos, $I10, $P10) = rx187_cur."!mark_fail"(0)
    lt rx187_pos, -1, rx187_done
    eq rx187_pos, -1, rx187_fail
    jump $I10
  rx187_done:
    rx187_cur."!cursor_fail"()
    if_null rx187_debug, debug_643
    rx187_cur."!cursor_debug"("FAIL", "comp_unit")
  debug_643:
    .return (rx187_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__comp_unit"  :nsentry("!PREFIX__comp_unit") :subid("31_1300062003.824") :method
.annotate 'line', 10
    $P189 = self."!PREFIX__!subrule"("newpad", "")
    new $P190, "ResizablePMCArray"
    push $P190, $P189
    .return ($P190)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statementlist"  :subid("32_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx196_tgt
    .local int rx196_pos
    .local int rx196_off
    .local int rx196_eos
    .local int rx196_rep
    .local pmc rx196_cur
    .local pmc rx196_debug
    (rx196_cur, rx196_pos, rx196_tgt, $I10) = self."!cursor_start"()
    rx196_cur."!cursor_caparray"("statement")
    .lex unicode:"$\x{a2}", rx196_cur
    .local pmc match
    .lex "$/", match
    length rx196_eos, rx196_tgt
    gt rx196_pos, rx196_eos, rx196_done
    set rx196_off, 0
    lt rx196_pos, 2, rx196_start
    sub rx196_off, rx196_pos, 1
    substr rx196_tgt, rx196_tgt, rx196_off
  rx196_start:
    eq $I10, 1, rx196_restart
    if_null rx196_debug, debug_644
    rx196_cur."!cursor_debug"("START", "statementlist")
  debug_644:
    $I10 = self.'from'()
    ne $I10, -1, rxscan201_done
    goto rxscan201_scan
  rxscan201_loop:
    (rx196_pos) = rx196_cur."from"()
    inc rx196_pos
    rx196_cur."!cursor_from"(rx196_pos)
    ge rx196_pos, rx196_eos, rxscan201_done
  rxscan201_scan:
    set_addr $I10, rxscan201_loop
    rx196_cur."!mark_push"(0, rx196_pos, $I10)
  rxscan201_done:
  alt202_0:
.annotate 'line', 124
    set_addr $I10, alt202_1
    rx196_cur."!mark_push"(0, rx196_pos, $I10)
.annotate 'line', 125
  # rx subrule "ws" subtype=method negate=
    rx196_cur."!cursor_pos"(rx196_pos)
    $P10 = rx196_cur."ws"()
    unless $P10, rx196_fail
    rx196_pos = $P10."pos"()
  # rxanchor eos
    ne rx196_pos, rx196_eos, rx196_fail
  # rx subrule "ws" subtype=method negate=
    rx196_cur."!cursor_pos"(rx196_pos)
    $P10 = rx196_cur."ws"()
    unless $P10, rx196_fail
    rx196_pos = $P10."pos"()
    goto alt202_end
  alt202_1:
.annotate 'line', 126
  # rx subrule "ws" subtype=method negate=
    rx196_cur."!cursor_pos"(rx196_pos)
    $P10 = rx196_cur."ws"()
    unless $P10, rx196_fail
    rx196_pos = $P10."pos"()
  # rx rxquantr206 ** 0..*
    set_addr $I10, rxquantr206_done
    rx196_cur."!mark_push"(0, rx196_pos, $I10)
  rxquantr206_loop:
  # rx subrule "statement" subtype=capture negate=
    rx196_cur."!cursor_pos"(rx196_pos)
    $P10 = rx196_cur."statement"()
    unless $P10, rx196_fail
    rx196_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx196_pos = $P10."pos"()
  # rx subrule "eat_terminator" subtype=method negate=
    rx196_cur."!cursor_pos"(rx196_pos)
    $P10 = rx196_cur."eat_terminator"()
    unless $P10, rx196_fail
    rx196_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx196_cur."!cursor_pos"(rx196_pos)
    $P10 = rx196_cur."ws"()
    unless $P10, rx196_fail
    rx196_pos = $P10."pos"()
    set_addr $I10, rxquantr206_done
    (rx196_rep) = rx196_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr206_done
    rx196_cur."!mark_push"(rx196_rep, rx196_pos, $I10)
    goto rxquantr206_loop
  rxquantr206_done:
  # rx subrule "ws" subtype=method negate=
    rx196_cur."!cursor_pos"(rx196_pos)
    $P10 = rx196_cur."ws"()
    unless $P10, rx196_fail
    rx196_pos = $P10."pos"()
  alt202_end:
.annotate 'line', 124
  # rx pass
    rx196_cur."!cursor_pass"(rx196_pos, "statementlist")
    if_null rx196_debug, debug_645
    rx196_cur."!cursor_debug"("PASS", "statementlist", " at pos=", rx196_pos)
  debug_645:
    .return (rx196_cur)
  rx196_restart:
.annotate 'line', 10
    if_null rx196_debug, debug_646
    rx196_cur."!cursor_debug"("NEXT", "statementlist")
  debug_646:
  rx196_fail:
    (rx196_rep, rx196_pos, $I10, $P10) = rx196_cur."!mark_fail"(0)
    lt rx196_pos, -1, rx196_done
    eq rx196_pos, -1, rx196_fail
    jump $I10
  rx196_done:
    rx196_cur."!cursor_fail"()
    if_null rx196_debug, debug_647
    rx196_cur."!cursor_debug"("FAIL", "statementlist")
  debug_647:
    .return (rx196_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statementlist"  :nsentry("!PREFIX__statementlist") :subid("33_1300062003.824") :method
.annotate 'line', 10
    $P198 = self."!PREFIX__!subrule"("ws", "")
    $P199 = self."!PREFIX__!subrule"("ws", "")
    new $P200, "ResizablePMCArray"
    push $P200, $P198
    push $P200, $P199
    .return ($P200)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement"  :subid("34_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .const 'Sub' $P215 = "36_1300062003.824" 
    capture_lex $P215
    .local string rx210_tgt
    .local int rx210_pos
    .local int rx210_off
    .local int rx210_eos
    .local int rx210_rep
    .local pmc rx210_cur
    .local pmc rx210_debug
    (rx210_cur, rx210_pos, rx210_tgt, $I10) = self."!cursor_start"()
    rx210_cur."!cursor_caparray"("statement_mod_cond", "statement_mod_loop")
    .lex unicode:"$\x{a2}", rx210_cur
    .local pmc match
    .lex "$/", match
    length rx210_eos, rx210_tgt
    gt rx210_pos, rx210_eos, rx210_done
    set rx210_off, 0
    lt rx210_pos, 2, rx210_start
    sub rx210_off, rx210_pos, 1
    substr rx210_tgt, rx210_tgt, rx210_off
  rx210_start:
    eq $I10, 1, rx210_restart
    if_null rx210_debug, debug_648
    rx210_cur."!cursor_debug"("START", "statement")
  debug_648:
    $I10 = self.'from'()
    ne $I10, -1, rxscan213_done
    goto rxscan213_scan
  rxscan213_loop:
    (rx210_pos) = rx210_cur."from"()
    inc rx210_pos
    rx210_cur."!cursor_from"(rx210_pos)
    ge rx210_pos, rx210_eos, rxscan213_done
  rxscan213_scan:
    set_addr $I10, rxscan213_loop
    rx210_cur."!mark_push"(0, rx210_pos, $I10)
  rxscan213_done:
.annotate 'line', 130
  # rx subrule "before" subtype=zerowidth negate=1
    rx210_cur."!cursor_pos"(rx210_pos)
    .const 'Sub' $P215 = "36_1300062003.824" 
    capture_lex $P215
    $P10 = rx210_cur."before"($P215)
    if $P10, rx210_fail
  alt219_0:
.annotate 'line', 131
    set_addr $I10, alt219_1
    rx210_cur."!mark_push"(0, rx210_pos, $I10)
.annotate 'line', 132
  # rx subrule "statement_control" subtype=capture negate=
    rx210_cur."!cursor_pos"(rx210_pos)
    $P10 = rx210_cur."statement_control"()
    unless $P10, rx210_fail
    rx210_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_control")
    rx210_pos = $P10."pos"()
    goto alt219_end
  alt219_1:
.annotate 'line', 133
  # rx subrule "EXPR" subtype=capture negate=
    rx210_cur."!cursor_pos"(rx210_pos)
    $P10 = rx210_cur."EXPR"()
    unless $P10, rx210_fail
    rx210_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx210_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx210_cur."!cursor_pos"(rx210_pos)
    $P10 = rx210_cur."ws"()
    unless $P10, rx210_fail
    rx210_pos = $P10."pos"()
.annotate 'line', 138
  # rx rxquantr220 ** 0..1
    set_addr $I10, rxquantr220_done
    rx210_cur."!mark_push"(0, rx210_pos, $I10)
  rxquantr220_loop:
  alt221_0:
.annotate 'line', 134
    set_addr $I10, alt221_1
    rx210_cur."!mark_push"(0, rx210_pos, $I10)
.annotate 'line', 135
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx210_cur."!cursor_pos"(rx210_pos)
    $P10 = rx210_cur."MARKED"("endstmt")
    unless $P10, rx210_fail
    goto alt221_end
  alt221_1:
    set_addr $I10, alt221_2
    rx210_cur."!mark_push"(0, rx210_pos, $I10)
.annotate 'line', 136
  # rx subrule "statement_mod_cond" subtype=capture negate=
    rx210_cur."!cursor_pos"(rx210_pos)
    $P10 = rx210_cur."statement_mod_cond"()
    unless $P10, rx210_fail
    rx210_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_cond")
    rx210_pos = $P10."pos"()
  # rx rxquantr222 ** 0..1
    set_addr $I10, rxquantr222_done
    rx210_cur."!mark_push"(0, rx210_pos, $I10)
  rxquantr222_loop:
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx210_cur."!cursor_pos"(rx210_pos)
    $P10 = rx210_cur."statement_mod_loop"()
    unless $P10, rx210_fail
    goto rxsubrule223_pass
  rxsubrule223_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx210_fail
  rxsubrule223_pass:
    set_addr $I10, rxsubrule223_back
    rx210_cur."!mark_push"(0, rx210_pos, $I10, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx210_pos = $P10."pos"()
    set_addr $I10, rxquantr222_done
    (rx210_rep) = rx210_cur."!mark_commit"($I10)
  rxquantr222_done:
    goto alt221_end
  alt221_2:
.annotate 'line', 137
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx210_cur."!cursor_pos"(rx210_pos)
    $P10 = rx210_cur."statement_mod_loop"()
    unless $P10, rx210_fail
    rx210_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx210_pos = $P10."pos"()
  alt221_end:
.annotate 'line', 138
    set_addr $I10, rxquantr220_done
    (rx210_rep) = rx210_cur."!mark_commit"($I10)
  rxquantr220_done:
  alt219_end:
.annotate 'line', 129
  # rx pass
    rx210_cur."!cursor_pass"(rx210_pos, "statement")
    if_null rx210_debug, debug_653
    rx210_cur."!cursor_debug"("PASS", "statement", " at pos=", rx210_pos)
  debug_653:
    .return (rx210_cur)
  rx210_restart:
.annotate 'line', 10
    if_null rx210_debug, debug_654
    rx210_cur."!cursor_debug"("NEXT", "statement")
  debug_654:
  rx210_fail:
    (rx210_rep, rx210_pos, $I10, $P10) = rx210_cur."!mark_fail"(0)
    lt rx210_pos, -1, rx210_done
    eq rx210_pos, -1, rx210_fail
    jump $I10
  rx210_done:
    rx210_cur."!cursor_fail"()
    if_null rx210_debug, debug_655
    rx210_cur."!cursor_debug"("FAIL", "statement")
  debug_655:
    .return (rx210_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement"  :nsentry("!PREFIX__statement") :subid("35_1300062003.824") :method
.annotate 'line', 10
    new $P212, "ResizablePMCArray"
    push $P212, ""
    .return ($P212)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block214"  :anon :subid("36_1300062003.824") :method :outer("34_1300062003.824")
.annotate 'line', 130
    .local string rx216_tgt
    .local int rx216_pos
    .local int rx216_off
    .local int rx216_eos
    .local int rx216_rep
    .local pmc rx216_cur
    .local pmc rx216_debug
    (rx216_cur, rx216_pos, rx216_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx216_cur
    .local pmc match
    .lex "$/", match
    length rx216_eos, rx216_tgt
    gt rx216_pos, rx216_eos, rx216_done
    set rx216_off, 0
    lt rx216_pos, 2, rx216_start
    sub rx216_off, rx216_pos, 1
    substr rx216_tgt, rx216_tgt, rx216_off
  rx216_start:
    eq $I10, 1, rx216_restart
    if_null rx216_debug, debug_649
    rx216_cur."!cursor_debug"("START", "")
  debug_649:
    $I10 = self.'from'()
    ne $I10, -1, rxscan217_done
    goto rxscan217_scan
  rxscan217_loop:
    (rx216_pos) = rx216_cur."from"()
    inc rx216_pos
    rx216_cur."!cursor_from"(rx216_pos)
    ge rx216_pos, rx216_eos, rxscan217_done
  rxscan217_scan:
    set_addr $I10, rxscan217_loop
    rx216_cur."!mark_push"(0, rx216_pos, $I10)
  rxscan217_done:
  alt218_0:
    set_addr $I10, alt218_1
    rx216_cur."!mark_push"(0, rx216_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx216_pos, rx216_eos, rx216_fail
    sub $I10, rx216_pos, rx216_off
    substr $S10, rx216_tgt, $I10, 1
    index $I11, "])}", $S10
    lt $I11, 0, rx216_fail
    inc rx216_pos
    goto alt218_end
  alt218_1:
  # rxanchor eos
    ne rx216_pos, rx216_eos, rx216_fail
  alt218_end:
  # rx pass
    rx216_cur."!cursor_pass"(rx216_pos, "")
    if_null rx216_debug, debug_650
    rx216_cur."!cursor_debug"("PASS", "", " at pos=", rx216_pos)
  debug_650:
    .return (rx216_cur)
  rx216_restart:
    if_null rx216_debug, debug_651
    rx216_cur."!cursor_debug"("NEXT", "")
  debug_651:
  rx216_fail:
    (rx216_rep, rx216_pos, $I10, $P10) = rx216_cur."!mark_fail"(0)
    lt rx216_pos, -1, rx216_done
    eq rx216_pos, -1, rx216_fail
    jump $I10
  rx216_done:
    rx216_cur."!cursor_fail"()
    if_null rx216_debug, debug_652
    rx216_cur."!cursor_debug"("FAIL", "")
  debug_652:
    .return (rx216_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "eat_terminator"  :subid("37_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx225_tgt
    .local int rx225_pos
    .local int rx225_off
    .local int rx225_eos
    .local int rx225_rep
    .local pmc rx225_cur
    .local pmc rx225_debug
    (rx225_cur, rx225_pos, rx225_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx225_cur
    .local pmc match
    .lex "$/", match
    length rx225_eos, rx225_tgt
    gt rx225_pos, rx225_eos, rx225_done
    set rx225_off, 0
    lt rx225_pos, 2, rx225_start
    sub rx225_off, rx225_pos, 1
    substr rx225_tgt, rx225_tgt, rx225_off
  rx225_start:
    eq $I10, 1, rx225_restart
    if_null rx225_debug, debug_656
    rx225_cur."!cursor_debug"("START", "eat_terminator")
  debug_656:
    $I10 = self.'from'()
    ne $I10, -1, rxscan228_done
    goto rxscan228_scan
  rxscan228_loop:
    (rx225_pos) = rx225_cur."from"()
    inc rx225_pos
    rx225_cur."!cursor_from"(rx225_pos)
    ge rx225_pos, rx225_eos, rxscan228_done
  rxscan228_scan:
    set_addr $I10, rxscan228_loop
    rx225_cur."!mark_push"(0, rx225_pos, $I10)
  rxscan228_done:
  alt229_0:
.annotate 'line', 142
    set_addr $I10, alt229_1
    rx225_cur."!mark_push"(0, rx225_pos, $I10)
.annotate 'line', 143
  # rx literal  ";"
    add $I11, rx225_pos, 1
    gt $I11, rx225_eos, rx225_fail
    sub $I11, rx225_pos, rx225_off
    ord $I11, rx225_tgt, $I11
    ne $I11, 59, rx225_fail
    add rx225_pos, 1
    goto alt229_end
  alt229_1:
    set_addr $I10, alt229_2
    rx225_cur."!mark_push"(0, rx225_pos, $I10)
.annotate 'line', 144
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx225_cur."!cursor_pos"(rx225_pos)
    $P10 = rx225_cur."MARKED"("endstmt")
    unless $P10, rx225_fail
    goto alt229_end
  alt229_2:
    set_addr $I10, alt229_3
    rx225_cur."!mark_push"(0, rx225_pos, $I10)
.annotate 'line', 145
  # rx subrule "terminator" subtype=zerowidth negate=
    rx225_cur."!cursor_pos"(rx225_pos)
    $P10 = rx225_cur."terminator"()
    unless $P10, rx225_fail
    goto alt229_end
  alt229_3:
.annotate 'line', 146
  # rxanchor eos
    ne rx225_pos, rx225_eos, rx225_fail
  alt229_end:
.annotate 'line', 142
  # rx pass
    rx225_cur."!cursor_pass"(rx225_pos, "eat_terminator")
    if_null rx225_debug, debug_657
    rx225_cur."!cursor_debug"("PASS", "eat_terminator", " at pos=", rx225_pos)
  debug_657:
    .return (rx225_cur)
  rx225_restart:
.annotate 'line', 10
    if_null rx225_debug, debug_658
    rx225_cur."!cursor_debug"("NEXT", "eat_terminator")
  debug_658:
  rx225_fail:
    (rx225_rep, rx225_pos, $I10, $P10) = rx225_cur."!mark_fail"(0)
    lt rx225_pos, -1, rx225_done
    eq rx225_pos, -1, rx225_fail
    jump $I10
  rx225_done:
    rx225_cur."!cursor_fail"()
    if_null rx225_debug, debug_659
    rx225_cur."!cursor_debug"("FAIL", "eat_terminator")
  debug_659:
    .return (rx225_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__eat_terminator"  :nsentry("!PREFIX__eat_terminator") :subid("38_1300062003.824") :method
.annotate 'line', 10
    new $P227, "ResizablePMCArray"
    push $P227, ""
    push $P227, ""
    push $P227, ""
    push $P227, ";"
    .return ($P227)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "xblock"  :subid("39_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx231_tgt
    .local int rx231_pos
    .local int rx231_off
    .local int rx231_eos
    .local int rx231_rep
    .local pmc rx231_cur
    .local pmc rx231_debug
    (rx231_cur, rx231_pos, rx231_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx231_cur
    .local pmc match
    .lex "$/", match
    length rx231_eos, rx231_tgt
    gt rx231_pos, rx231_eos, rx231_done
    set rx231_off, 0
    lt rx231_pos, 2, rx231_start
    sub rx231_off, rx231_pos, 1
    substr rx231_tgt, rx231_tgt, rx231_off
  rx231_start:
    eq $I10, 1, rx231_restart
    if_null rx231_debug, debug_660
    rx231_cur."!cursor_debug"("START", "xblock")
  debug_660:
    $I10 = self.'from'()
    ne $I10, -1, rxscan235_done
    goto rxscan235_scan
  rxscan235_loop:
    (rx231_pos) = rx231_cur."from"()
    inc rx231_pos
    rx231_cur."!cursor_from"(rx231_pos)
    ge rx231_pos, rx231_eos, rxscan235_done
  rxscan235_scan:
    set_addr $I10, rxscan235_loop
    rx231_cur."!mark_push"(0, rx231_pos, $I10)
  rxscan235_done:
.annotate 'line', 150
  # rx subrule "EXPR" subtype=capture negate=
    rx231_cur."!cursor_pos"(rx231_pos)
    $P10 = rx231_cur."EXPR"()
    unless $P10, rx231_fail
    rx231_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx231_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx231_cur."!cursor_pos"(rx231_pos)
    $P10 = rx231_cur."ws"()
    unless $P10, rx231_fail
    rx231_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx231_cur."!cursor_pos"(rx231_pos)
    $P10 = rx231_cur."pblock"()
    unless $P10, rx231_fail
    rx231_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx231_pos = $P10."pos"()
.annotate 'line', 149
  # rx pass
    rx231_cur."!cursor_pass"(rx231_pos, "xblock")
    if_null rx231_debug, debug_661
    rx231_cur."!cursor_debug"("PASS", "xblock", " at pos=", rx231_pos)
  debug_661:
    .return (rx231_cur)
  rx231_restart:
.annotate 'line', 10
    if_null rx231_debug, debug_662
    rx231_cur."!cursor_debug"("NEXT", "xblock")
  debug_662:
  rx231_fail:
    (rx231_rep, rx231_pos, $I10, $P10) = rx231_cur."!mark_fail"(0)
    lt rx231_pos, -1, rx231_done
    eq rx231_pos, -1, rx231_fail
    jump $I10
  rx231_done:
    rx231_cur."!cursor_fail"()
    if_null rx231_debug, debug_663
    rx231_cur."!cursor_debug"("FAIL", "xblock")
  debug_663:
    .return (rx231_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__xblock"  :nsentry("!PREFIX__xblock") :subid("40_1300062003.824") :method
.annotate 'line', 10
    $P233 = self."!PREFIX__!subrule"("EXPR", "")
    new $P234, "ResizablePMCArray"
    push $P234, $P233
    .return ($P234)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pblock"  :subid("41_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx237_tgt
    .local int rx237_pos
    .local int rx237_off
    .local int rx237_eos
    .local int rx237_rep
    .local pmc rx237_cur
    .local pmc rx237_debug
    (rx237_cur, rx237_pos, rx237_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx237_cur
    .local pmc match
    .lex "$/", match
    length rx237_eos, rx237_tgt
    gt rx237_pos, rx237_eos, rx237_done
    set rx237_off, 0
    lt rx237_pos, 2, rx237_start
    sub rx237_off, rx237_pos, 1
    substr rx237_tgt, rx237_tgt, rx237_off
  rx237_start:
    eq $I10, 1, rx237_restart
    if_null rx237_debug, debug_664
    rx237_cur."!cursor_debug"("START", "pblock")
  debug_664:
    $I10 = self.'from'()
    ne $I10, -1, rxscan242_done
    goto rxscan242_scan
  rxscan242_loop:
    (rx237_pos) = rx237_cur."from"()
    inc rx237_pos
    rx237_cur."!cursor_from"(rx237_pos)
    ge rx237_pos, rx237_eos, rxscan242_done
  rxscan242_scan:
    set_addr $I10, rxscan242_loop
    rx237_cur."!mark_push"(0, rx237_pos, $I10)
  rxscan242_done:
  alt243_0:
.annotate 'line', 153
    set_addr $I10, alt243_1
    rx237_cur."!mark_push"(0, rx237_pos, $I10)
.annotate 'line', 154
  # rx subrule "lambda" subtype=method negate=
    rx237_cur."!cursor_pos"(rx237_pos)
    $P10 = rx237_cur."lambda"()
    unless $P10, rx237_fail
    rx237_pos = $P10."pos"()
.annotate 'line', 155
  # rx subrule "newpad" subtype=method negate=
    rx237_cur."!cursor_pos"(rx237_pos)
    $P10 = rx237_cur."newpad"()
    unless $P10, rx237_fail
    rx237_pos = $P10."pos"()
.annotate 'line', 156
  # rx subrule "signature" subtype=capture negate=
    rx237_cur."!cursor_pos"(rx237_pos)
    $P10 = rx237_cur."signature"()
    unless $P10, rx237_fail
    rx237_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx237_pos = $P10."pos"()
.annotate 'line', 157
  # rx subrule "blockoid" subtype=capture negate=
    rx237_cur."!cursor_pos"(rx237_pos)
    $P10 = rx237_cur."blockoid"()
    unless $P10, rx237_fail
    rx237_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx237_pos = $P10."pos"()
.annotate 'line', 154
    goto alt243_end
  alt243_1:
    set_addr $I10, alt243_2
    rx237_cur."!mark_push"(0, rx237_pos, $I10)
.annotate 'line', 158
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx237_pos, rx237_off
    substr $S10, rx237_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx237_fail
.annotate 'line', 159
  # rx subrule "newpad" subtype=method negate=
    rx237_cur."!cursor_pos"(rx237_pos)
    $P10 = rx237_cur."newpad"()
    unless $P10, rx237_fail
    rx237_pos = $P10."pos"()
.annotate 'line', 160
  # rx subrule "blockoid" subtype=capture negate=
    rx237_cur."!cursor_pos"(rx237_pos)
    $P10 = rx237_cur."blockoid"()
    unless $P10, rx237_fail
    rx237_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx237_pos = $P10."pos"()
.annotate 'line', 158
    goto alt243_end
  alt243_2:
.annotate 'line', 161
  # rx subrule "panic" subtype=method negate=
    rx237_cur."!cursor_pos"(rx237_pos)
    $P10 = rx237_cur."panic"("Missing block")
    unless $P10, rx237_fail
    rx237_pos = $P10."pos"()
  alt243_end:
.annotate 'line', 153
  # rx pass
    rx237_cur."!cursor_pass"(rx237_pos, "pblock")
    if_null rx237_debug, debug_665
    rx237_cur."!cursor_debug"("PASS", "pblock", " at pos=", rx237_pos)
  debug_665:
    .return (rx237_cur)
  rx237_restart:
.annotate 'line', 10
    if_null rx237_debug, debug_666
    rx237_cur."!cursor_debug"("NEXT", "pblock")
  debug_666:
  rx237_fail:
    (rx237_rep, rx237_pos, $I10, $P10) = rx237_cur."!mark_fail"(0)
    lt rx237_pos, -1, rx237_done
    eq rx237_pos, -1, rx237_fail
    jump $I10
  rx237_done:
    rx237_cur."!cursor_fail"()
    if_null rx237_debug, debug_667
    rx237_cur."!cursor_debug"("FAIL", "pblock")
  debug_667:
    .return (rx237_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pblock"  :nsentry("!PREFIX__pblock") :subid("42_1300062003.824") :method
.annotate 'line', 10
    $P239 = self."!PREFIX__!subrule"("panic", "")
    $P240 = self."!PREFIX__!subrule"("lambda", "")
    new $P241, "ResizablePMCArray"
    push $P241, $P239
    push $P241, "{"
    push $P241, $P240
    .return ($P241)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "lambda"  :subid("43_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx245_tgt
    .local int rx245_pos
    .local int rx245_off
    .local int rx245_eos
    .local int rx245_rep
    .local pmc rx245_cur
    .local pmc rx245_debug
    (rx245_cur, rx245_pos, rx245_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx245_cur
    .local pmc match
    .lex "$/", match
    length rx245_eos, rx245_tgt
    gt rx245_pos, rx245_eos, rx245_done
    set rx245_off, 0
    lt rx245_pos, 2, rx245_start
    sub rx245_off, rx245_pos, 1
    substr rx245_tgt, rx245_tgt, rx245_off
  rx245_start:
    eq $I10, 1, rx245_restart
    if_null rx245_debug, debug_668
    rx245_cur."!cursor_debug"("START", "lambda")
  debug_668:
    $I10 = self.'from'()
    ne $I10, -1, rxscan248_done
    goto rxscan248_scan
  rxscan248_loop:
    (rx245_pos) = rx245_cur."from"()
    inc rx245_pos
    rx245_cur."!cursor_from"(rx245_pos)
    ge rx245_pos, rx245_eos, rxscan248_done
  rxscan248_scan:
    set_addr $I10, rxscan248_loop
    rx245_cur."!mark_push"(0, rx245_pos, $I10)
  rxscan248_done:
  alt249_0:
.annotate 'line', 164
    set_addr $I10, alt249_1
    rx245_cur."!mark_push"(0, rx245_pos, $I10)
  # rx literal  "->"
    add $I11, rx245_pos, 2
    gt $I11, rx245_eos, rx245_fail
    sub $I11, rx245_pos, rx245_off
    substr $S10, rx245_tgt, $I11, 2
    ne $S10, "->", rx245_fail
    add rx245_pos, 2
    goto alt249_end
  alt249_1:
  # rx literal  "<->"
    add $I11, rx245_pos, 3
    gt $I11, rx245_eos, rx245_fail
    sub $I11, rx245_pos, rx245_off
    substr $S10, rx245_tgt, $I11, 3
    ne $S10, "<->", rx245_fail
    add rx245_pos, 3
  alt249_end:
  # rx pass
    rx245_cur."!cursor_pass"(rx245_pos, "lambda")
    if_null rx245_debug, debug_669
    rx245_cur."!cursor_debug"("PASS", "lambda", " at pos=", rx245_pos)
  debug_669:
    .return (rx245_cur)
  rx245_restart:
.annotate 'line', 10
    if_null rx245_debug, debug_670
    rx245_cur."!cursor_debug"("NEXT", "lambda")
  debug_670:
  rx245_fail:
    (rx245_rep, rx245_pos, $I10, $P10) = rx245_cur."!mark_fail"(0)
    lt rx245_pos, -1, rx245_done
    eq rx245_pos, -1, rx245_fail
    jump $I10
  rx245_done:
    rx245_cur."!cursor_fail"()
    if_null rx245_debug, debug_671
    rx245_cur."!cursor_debug"("FAIL", "lambda")
  debug_671:
    .return (rx245_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__lambda"  :nsentry("!PREFIX__lambda") :subid("44_1300062003.824") :method
.annotate 'line', 10
    new $P247, "ResizablePMCArray"
    push $P247, "<->"
    push $P247, "->"
    .return ($P247)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "block"  :subid("45_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx251_tgt
    .local int rx251_pos
    .local int rx251_off
    .local int rx251_eos
    .local int rx251_rep
    .local pmc rx251_cur
    .local pmc rx251_debug
    (rx251_cur, rx251_pos, rx251_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx251_cur
    .local pmc match
    .lex "$/", match
    length rx251_eos, rx251_tgt
    gt rx251_pos, rx251_eos, rx251_done
    set rx251_off, 0
    lt rx251_pos, 2, rx251_start
    sub rx251_off, rx251_pos, 1
    substr rx251_tgt, rx251_tgt, rx251_off
  rx251_start:
    eq $I10, 1, rx251_restart
    if_null rx251_debug, debug_672
    rx251_cur."!cursor_debug"("START", "block")
  debug_672:
    $I10 = self.'from'()
    ne $I10, -1, rxscan255_done
    goto rxscan255_scan
  rxscan255_loop:
    (rx251_pos) = rx251_cur."from"()
    inc rx251_pos
    rx251_cur."!cursor_from"(rx251_pos)
    ge rx251_pos, rx251_eos, rxscan255_done
  rxscan255_scan:
    set_addr $I10, rxscan255_loop
    rx251_cur."!mark_push"(0, rx251_pos, $I10)
  rxscan255_done:
  alt256_0:
.annotate 'line', 167
    set_addr $I10, alt256_1
    rx251_cur."!mark_push"(0, rx251_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx251_pos, rx251_off
    substr $S10, rx251_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx251_fail
    goto alt256_end
  alt256_1:
  # rx subrule "panic" subtype=method negate=
    rx251_cur."!cursor_pos"(rx251_pos)
    $P10 = rx251_cur."panic"("Missing block")
    unless $P10, rx251_fail
    rx251_pos = $P10."pos"()
  alt256_end:
.annotate 'line', 168
  # rx subrule "newpad" subtype=method negate=
    rx251_cur."!cursor_pos"(rx251_pos)
    $P10 = rx251_cur."newpad"()
    unless $P10, rx251_fail
    rx251_pos = $P10."pos"()
.annotate 'line', 169
  # rx subrule "blockoid" subtype=capture negate=
    rx251_cur."!cursor_pos"(rx251_pos)
    $P10 = rx251_cur."blockoid"()
    unless $P10, rx251_fail
    rx251_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx251_pos = $P10."pos"()
.annotate 'line', 166
  # rx pass
    rx251_cur."!cursor_pass"(rx251_pos, "block")
    if_null rx251_debug, debug_673
    rx251_cur."!cursor_debug"("PASS", "block", " at pos=", rx251_pos)
  debug_673:
    .return (rx251_cur)
  rx251_restart:
.annotate 'line', 10
    if_null rx251_debug, debug_674
    rx251_cur."!cursor_debug"("NEXT", "block")
  debug_674:
  rx251_fail:
    (rx251_rep, rx251_pos, $I10, $P10) = rx251_cur."!mark_fail"(0)
    lt rx251_pos, -1, rx251_done
    eq rx251_pos, -1, rx251_fail
    jump $I10
  rx251_done:
    rx251_cur."!cursor_fail"()
    if_null rx251_debug, debug_675
    rx251_cur."!cursor_debug"("FAIL", "block")
  debug_675:
    .return (rx251_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__block"  :nsentry("!PREFIX__block") :subid("46_1300062003.824") :method
.annotate 'line', 10
    $P253 = self."!PREFIX__!subrule"("panic", "")
    new $P254, "ResizablePMCArray"
    push $P254, $P253
    push $P254, "{"
    .return ($P254)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blockoid"  :subid("47_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx258_tgt
    .local int rx258_pos
    .local int rx258_off
    .local int rx258_eos
    .local int rx258_rep
    .local pmc rx258_cur
    .local pmc rx258_debug
    (rx258_cur, rx258_pos, rx258_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx258_cur
    .local pmc match
    .lex "$/", match
    length rx258_eos, rx258_tgt
    gt rx258_pos, rx258_eos, rx258_done
    set rx258_off, 0
    lt rx258_pos, 2, rx258_start
    sub rx258_off, rx258_pos, 1
    substr rx258_tgt, rx258_tgt, rx258_off
  rx258_start:
    eq $I10, 1, rx258_restart
    if_null rx258_debug, debug_676
    rx258_cur."!cursor_debug"("START", "blockoid")
  debug_676:
    $I10 = self.'from'()
    ne $I10, -1, rxscan262_done
    goto rxscan262_scan
  rxscan262_loop:
    (rx258_pos) = rx258_cur."from"()
    inc rx258_pos
    rx258_cur."!cursor_from"(rx258_pos)
    ge rx258_pos, rx258_eos, rxscan262_done
  rxscan262_scan:
    set_addr $I10, rxscan262_loop
    rx258_cur."!mark_push"(0, rx258_pos, $I10)
  rxscan262_done:
.annotate 'line', 173
  # rx subrule "finishpad" subtype=method negate=
    rx258_cur."!cursor_pos"(rx258_pos)
    $P10 = rx258_cur."finishpad"()
    unless $P10, rx258_fail
    rx258_pos = $P10."pos"()
  alt263_0:
.annotate 'line', 174
    set_addr $I10, alt263_1
    rx258_cur."!mark_push"(0, rx258_pos, $I10)
.annotate 'line', 175
  # rx literal  "{YOU_ARE_HERE}"
    add $I11, rx258_pos, 14
    gt $I11, rx258_eos, rx258_fail
    sub $I11, rx258_pos, rx258_off
    substr $S10, rx258_tgt, $I11, 14
    ne $S10, "{YOU_ARE_HERE}", rx258_fail
    add rx258_pos, 14
  # rx subrule "you_are_here" subtype=capture negate=
    rx258_cur."!cursor_pos"(rx258_pos)
    $P10 = rx258_cur."you_are_here"()
    unless $P10, rx258_fail
    rx258_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("you_are_here")
    rx258_pos = $P10."pos"()
    goto alt263_end
  alt263_1:
.annotate 'line', 176
  # rx literal  "{"
    add $I11, rx258_pos, 1
    gt $I11, rx258_eos, rx258_fail
    sub $I11, rx258_pos, rx258_off
    ord $I11, rx258_tgt, $I11
    ne $I11, 123, rx258_fail
    add rx258_pos, 1
  # rx subrule "statementlist" subtype=capture negate=
    rx258_cur."!cursor_pos"(rx258_pos)
    $P10 = rx258_cur."statementlist"()
    unless $P10, rx258_fail
    rx258_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx258_pos = $P10."pos"()
  alt264_0:
    set_addr $I10, alt264_1
    rx258_cur."!mark_push"(0, rx258_pos, $I10)
  # rx literal  "}"
    add $I11, rx258_pos, 1
    gt $I11, rx258_eos, rx258_fail
    sub $I11, rx258_pos, rx258_off
    ord $I11, rx258_tgt, $I11
    ne $I11, 125, rx258_fail
    add rx258_pos, 1
    goto alt264_end
  alt264_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx258_cur."!cursor_pos"(rx258_pos)
    $P10 = rx258_cur."FAILGOAL"("'}'")
    unless $P10, rx258_fail
    goto rxsubrule266_pass
  rxsubrule266_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx258_fail
  rxsubrule266_pass:
    set_addr $I10, rxsubrule266_back
    rx258_cur."!mark_push"(0, rx258_pos, $I10, $P10)
    rx258_pos = $P10."pos"()
  alt264_end:
  alt263_end:
.annotate 'line', 178
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx258_cur."!cursor_pos"(rx258_pos)
    $P10 = rx258_cur."ENDSTMT"()
    unless $P10, rx258_fail
.annotate 'line', 172
  # rx pass
    rx258_cur."!cursor_pass"(rx258_pos, "blockoid")
    if_null rx258_debug, debug_677
    rx258_cur."!cursor_debug"("PASS", "blockoid", " at pos=", rx258_pos)
  debug_677:
    .return (rx258_cur)
  rx258_restart:
.annotate 'line', 10
    if_null rx258_debug, debug_678
    rx258_cur."!cursor_debug"("NEXT", "blockoid")
  debug_678:
  rx258_fail:
    (rx258_rep, rx258_pos, $I10, $P10) = rx258_cur."!mark_fail"(0)
    lt rx258_pos, -1, rx258_done
    eq rx258_pos, -1, rx258_fail
    jump $I10
  rx258_done:
    rx258_cur."!cursor_fail"()
    if_null rx258_debug, debug_679
    rx258_cur."!cursor_debug"("FAIL", "blockoid")
  debug_679:
    .return (rx258_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blockoid"  :nsentry("!PREFIX__blockoid") :subid("48_1300062003.824") :method
.annotate 'line', 10
    $P260 = self."!PREFIX__!subrule"("finishpad", "")
    new $P261, "ResizablePMCArray"
    push $P261, $P260
    .return ($P261)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "newpad"  :subid("49_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx268_tgt
    .local int rx268_pos
    .local int rx268_off
    .local int rx268_eos
    .local int rx268_rep
    .local pmc rx268_cur
    .local pmc rx268_debug
    (rx268_cur, rx268_pos, rx268_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx268_cur
    .local pmc match
    .lex "$/", match
    length rx268_eos, rx268_tgt
    gt rx268_pos, rx268_eos, rx268_done
    set rx268_off, 0
    lt rx268_pos, 2, rx268_start
    sub rx268_off, rx268_pos, 1
    substr rx268_tgt, rx268_tgt, rx268_off
  rx268_start:
    eq $I10, 1, rx268_restart
    if_null rx268_debug, debug_680
    rx268_cur."!cursor_debug"("START", "newpad")
  debug_680:
    $I10 = self.'from'()
    ne $I10, -1, rxscan271_done
    goto rxscan271_scan
  rxscan271_loop:
    (rx268_pos) = rx268_cur."from"()
    inc rx268_pos
    rx268_cur."!cursor_from"(rx268_pos)
    ge rx268_pos, rx268_eos, rxscan271_done
  rxscan271_scan:
    set_addr $I10, rxscan271_loop
    rx268_cur."!mark_push"(0, rx268_pos, $I10)
  rxscan271_done:
.annotate 'line', 181
  # rx pass
    rx268_cur."!cursor_pass"(rx268_pos, "newpad")
    if_null rx268_debug, debug_681
    rx268_cur."!cursor_debug"("PASS", "newpad", " at pos=", rx268_pos)
  debug_681:
    .return (rx268_cur)
  rx268_restart:
.annotate 'line', 10
    if_null rx268_debug, debug_682
    rx268_cur."!cursor_debug"("NEXT", "newpad")
  debug_682:
  rx268_fail:
    (rx268_rep, rx268_pos, $I10, $P10) = rx268_cur."!mark_fail"(0)
    lt rx268_pos, -1, rx268_done
    eq rx268_pos, -1, rx268_fail
    jump $I10
  rx268_done:
    rx268_cur."!cursor_fail"()
    if_null rx268_debug, debug_683
    rx268_cur."!cursor_debug"("FAIL", "newpad")
  debug_683:
    .return (rx268_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__newpad"  :nsentry("!PREFIX__newpad") :subid("50_1300062003.824") :method
.annotate 'line', 10
    new $P270, "ResizablePMCArray"
    push $P270, ""
    .return ($P270)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "outerctx"  :subid("51_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx273_tgt
    .local int rx273_pos
    .local int rx273_off
    .local int rx273_eos
    .local int rx273_rep
    .local pmc rx273_cur
    .local pmc rx273_debug
    (rx273_cur, rx273_pos, rx273_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx273_cur
    .local pmc match
    .lex "$/", match
    length rx273_eos, rx273_tgt
    gt rx273_pos, rx273_eos, rx273_done
    set rx273_off, 0
    lt rx273_pos, 2, rx273_start
    sub rx273_off, rx273_pos, 1
    substr rx273_tgt, rx273_tgt, rx273_off
  rx273_start:
    eq $I10, 1, rx273_restart
    if_null rx273_debug, debug_684
    rx273_cur."!cursor_debug"("START", "outerctx")
  debug_684:
    $I10 = self.'from'()
    ne $I10, -1, rxscan276_done
    goto rxscan276_scan
  rxscan276_loop:
    (rx273_pos) = rx273_cur."from"()
    inc rx273_pos
    rx273_cur."!cursor_from"(rx273_pos)
    ge rx273_pos, rx273_eos, rxscan276_done
  rxscan276_scan:
    set_addr $I10, rxscan276_loop
    rx273_cur."!mark_push"(0, rx273_pos, $I10)
  rxscan276_done:
.annotate 'line', 182
  # rx pass
    rx273_cur."!cursor_pass"(rx273_pos, "outerctx")
    if_null rx273_debug, debug_685
    rx273_cur."!cursor_debug"("PASS", "outerctx", " at pos=", rx273_pos)
  debug_685:
    .return (rx273_cur)
  rx273_restart:
.annotate 'line', 10
    if_null rx273_debug, debug_686
    rx273_cur."!cursor_debug"("NEXT", "outerctx")
  debug_686:
  rx273_fail:
    (rx273_rep, rx273_pos, $I10, $P10) = rx273_cur."!mark_fail"(0)
    lt rx273_pos, -1, rx273_done
    eq rx273_pos, -1, rx273_fail
    jump $I10
  rx273_done:
    rx273_cur."!cursor_fail"()
    if_null rx273_debug, debug_687
    rx273_cur."!cursor_debug"("FAIL", "outerctx")
  debug_687:
    .return (rx273_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__outerctx"  :nsentry("!PREFIX__outerctx") :subid("52_1300062003.824") :method
.annotate 'line', 10
    new $P275, "ResizablePMCArray"
    push $P275, ""
    .return ($P275)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "finishpad"  :subid("53_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx278_tgt
    .local int rx278_pos
    .local int rx278_off
    .local int rx278_eos
    .local int rx278_rep
    .local pmc rx278_cur
    .local pmc rx278_debug
    (rx278_cur, rx278_pos, rx278_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx278_cur
    .local pmc match
    .lex "$/", match
    length rx278_eos, rx278_tgt
    gt rx278_pos, rx278_eos, rx278_done
    set rx278_off, 0
    lt rx278_pos, 2, rx278_start
    sub rx278_off, rx278_pos, 1
    substr rx278_tgt, rx278_tgt, rx278_off
  rx278_start:
    eq $I10, 1, rx278_restart
    if_null rx278_debug, debug_688
    rx278_cur."!cursor_debug"("START", "finishpad")
  debug_688:
    $I10 = self.'from'()
    ne $I10, -1, rxscan281_done
    goto rxscan281_scan
  rxscan281_loop:
    (rx278_pos) = rx278_cur."from"()
    inc rx278_pos
    rx278_cur."!cursor_from"(rx278_pos)
    ge rx278_pos, rx278_eos, rxscan281_done
  rxscan281_scan:
    set_addr $I10, rxscan281_loop
    rx278_cur."!mark_push"(0, rx278_pos, $I10)
  rxscan281_done:
.annotate 'line', 183
  # rx pass
    rx278_cur."!cursor_pass"(rx278_pos, "finishpad")
    if_null rx278_debug, debug_689
    rx278_cur."!cursor_debug"("PASS", "finishpad", " at pos=", rx278_pos)
  debug_689:
    .return (rx278_cur)
  rx278_restart:
.annotate 'line', 10
    if_null rx278_debug, debug_690
    rx278_cur."!cursor_debug"("NEXT", "finishpad")
  debug_690:
  rx278_fail:
    (rx278_rep, rx278_pos, $I10, $P10) = rx278_cur."!mark_fail"(0)
    lt rx278_pos, -1, rx278_done
    eq rx278_pos, -1, rx278_fail
    jump $I10
  rx278_done:
    rx278_cur."!cursor_fail"()
    if_null rx278_debug, debug_691
    rx278_cur."!cursor_debug"("FAIL", "finishpad")
  debug_691:
    .return (rx278_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__finishpad"  :nsentry("!PREFIX__finishpad") :subid("54_1300062003.824") :method
.annotate 'line', 10
    new $P280, "ResizablePMCArray"
    push $P280, ""
    .return ($P280)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "you_are_here"  :subid("55_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx283_tgt
    .local int rx283_pos
    .local int rx283_off
    .local int rx283_eos
    .local int rx283_rep
    .local pmc rx283_cur
    .local pmc rx283_debug
    (rx283_cur, rx283_pos, rx283_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx283_cur
    .local pmc match
    .lex "$/", match
    length rx283_eos, rx283_tgt
    gt rx283_pos, rx283_eos, rx283_done
    set rx283_off, 0
    lt rx283_pos, 2, rx283_start
    sub rx283_off, rx283_pos, 1
    substr rx283_tgt, rx283_tgt, rx283_off
  rx283_start:
    eq $I10, 1, rx283_restart
    if_null rx283_debug, debug_692
    rx283_cur."!cursor_debug"("START", "you_are_here")
  debug_692:
    $I10 = self.'from'()
    ne $I10, -1, rxscan286_done
    goto rxscan286_scan
  rxscan286_loop:
    (rx283_pos) = rx283_cur."from"()
    inc rx283_pos
    rx283_cur."!cursor_from"(rx283_pos)
    ge rx283_pos, rx283_eos, rxscan286_done
  rxscan286_scan:
    set_addr $I10, rxscan286_loop
    rx283_cur."!mark_push"(0, rx283_pos, $I10)
  rxscan286_done:
.annotate 'line', 184
  # rx pass
    rx283_cur."!cursor_pass"(rx283_pos, "you_are_here")
    if_null rx283_debug, debug_693
    rx283_cur."!cursor_debug"("PASS", "you_are_here", " at pos=", rx283_pos)
  debug_693:
    .return (rx283_cur)
  rx283_restart:
.annotate 'line', 10
    if_null rx283_debug, debug_694
    rx283_cur."!cursor_debug"("NEXT", "you_are_here")
  debug_694:
  rx283_fail:
    (rx283_rep, rx283_pos, $I10, $P10) = rx283_cur."!mark_fail"(0)
    lt rx283_pos, -1, rx283_done
    eq rx283_pos, -1, rx283_fail
    jump $I10
  rx283_done:
    rx283_cur."!cursor_fail"()
    if_null rx283_debug, debug_695
    rx283_cur."!cursor_debug"("FAIL", "you_are_here")
  debug_695:
    .return (rx283_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__you_are_here"  :nsentry("!PREFIX__you_are_here") :subid("56_1300062003.824") :method
.annotate 'line', 10
    new $P285, "ResizablePMCArray"
    push $P285, ""
    .return ($P285)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator"  :subid("57_1300062003.824")
    .param pmc param_288
.annotate 'line', 186
    .lex "self", param_288
    $P289 = param_288."!protoregex"("terminator")
    .return ($P289)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator"  :subid("58_1300062003.824")
    .param pmc param_291
.annotate 'line', 186
    .lex "self", param_291
    $P292 = param_291."!PREFIX__!protoregex"("terminator")
    .return ($P292)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<;>"  :subid("59_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx294_tgt
    .local int rx294_pos
    .local int rx294_off
    .local int rx294_eos
    .local int rx294_rep
    .local pmc rx294_cur
    .local pmc rx294_debug
    (rx294_cur, rx294_pos, rx294_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx294_cur
    .local pmc match
    .lex "$/", match
    length rx294_eos, rx294_tgt
    gt rx294_pos, rx294_eos, rx294_done
    set rx294_off, 0
    lt rx294_pos, 2, rx294_start
    sub rx294_off, rx294_pos, 1
    substr rx294_tgt, rx294_tgt, rx294_off
  rx294_start:
    eq $I10, 1, rx294_restart
    if_null rx294_debug, debug_696
    rx294_cur."!cursor_debug"("START", "terminator:sym<;>")
  debug_696:
    $I10 = self.'from'()
    ne $I10, -1, rxscan297_done
    goto rxscan297_scan
  rxscan297_loop:
    (rx294_pos) = rx294_cur."from"()
    inc rx294_pos
    rx294_cur."!cursor_from"(rx294_pos)
    ge rx294_pos, rx294_eos, rxscan297_done
  rxscan297_scan:
    set_addr $I10, rxscan297_loop
    rx294_cur."!mark_push"(0, rx294_pos, $I10)
  rxscan297_done:
.annotate 'line', 188
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx294_pos, rx294_off
    substr $S10, rx294_tgt, $I10, 1
    index $I11, ";", $S10
    lt $I11, 0, rx294_fail
  # rx pass
    rx294_cur."!cursor_pass"(rx294_pos, "terminator:sym<;>")
    if_null rx294_debug, debug_697
    rx294_cur."!cursor_debug"("PASS", "terminator:sym<;>", " at pos=", rx294_pos)
  debug_697:
    .return (rx294_cur)
  rx294_restart:
.annotate 'line', 10
    if_null rx294_debug, debug_698
    rx294_cur."!cursor_debug"("NEXT", "terminator:sym<;>")
  debug_698:
  rx294_fail:
    (rx294_rep, rx294_pos, $I10, $P10) = rx294_cur."!mark_fail"(0)
    lt rx294_pos, -1, rx294_done
    eq rx294_pos, -1, rx294_fail
    jump $I10
  rx294_done:
    rx294_cur."!cursor_fail"()
    if_null rx294_debug, debug_699
    rx294_cur."!cursor_debug"("FAIL", "terminator:sym<;>")
  debug_699:
    .return (rx294_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<;>"  :nsentry("!PREFIX__terminator:sym<;>") :subid("60_1300062003.824") :method
.annotate 'line', 10
    new $P296, "ResizablePMCArray"
    push $P296, ";"
    .return ($P296)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<}>"  :subid("61_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx299_tgt
    .local int rx299_pos
    .local int rx299_off
    .local int rx299_eos
    .local int rx299_rep
    .local pmc rx299_cur
    .local pmc rx299_debug
    (rx299_cur, rx299_pos, rx299_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx299_cur
    .local pmc match
    .lex "$/", match
    length rx299_eos, rx299_tgt
    gt rx299_pos, rx299_eos, rx299_done
    set rx299_off, 0
    lt rx299_pos, 2, rx299_start
    sub rx299_off, rx299_pos, 1
    substr rx299_tgt, rx299_tgt, rx299_off
  rx299_start:
    eq $I10, 1, rx299_restart
    if_null rx299_debug, debug_700
    rx299_cur."!cursor_debug"("START", "terminator:sym<}>")
  debug_700:
    $I10 = self.'from'()
    ne $I10, -1, rxscan302_done
    goto rxscan302_scan
  rxscan302_loop:
    (rx299_pos) = rx299_cur."from"()
    inc rx299_pos
    rx299_cur."!cursor_from"(rx299_pos)
    ge rx299_pos, rx299_eos, rxscan302_done
  rxscan302_scan:
    set_addr $I10, rxscan302_loop
    rx299_cur."!mark_push"(0, rx299_pos, $I10)
  rxscan302_done:
.annotate 'line', 189
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx299_pos, rx299_off
    substr $S10, rx299_tgt, $I10, 1
    index $I11, "}", $S10
    lt $I11, 0, rx299_fail
  # rx pass
    rx299_cur."!cursor_pass"(rx299_pos, "terminator:sym<}>")
    if_null rx299_debug, debug_701
    rx299_cur."!cursor_debug"("PASS", "terminator:sym<}>", " at pos=", rx299_pos)
  debug_701:
    .return (rx299_cur)
  rx299_restart:
.annotate 'line', 10
    if_null rx299_debug, debug_702
    rx299_cur."!cursor_debug"("NEXT", "terminator:sym<}>")
  debug_702:
  rx299_fail:
    (rx299_rep, rx299_pos, $I10, $P10) = rx299_cur."!mark_fail"(0)
    lt rx299_pos, -1, rx299_done
    eq rx299_pos, -1, rx299_fail
    jump $I10
  rx299_done:
    rx299_cur."!cursor_fail"()
    if_null rx299_debug, debug_703
    rx299_cur."!cursor_debug"("FAIL", "terminator:sym<}>")
  debug_703:
    .return (rx299_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<}>"  :nsentry("!PREFIX__terminator:sym<}>") :subid("62_1300062003.824") :method
.annotate 'line', 10
    new $P301, "ResizablePMCArray"
    push $P301, "}"
    .return ($P301)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control"  :subid("63_1300062003.824")
    .param pmc param_304
.annotate 'line', 193
    .lex "self", param_304
    $P305 = param_304."!protoregex"("statement_control")
    .return ($P305)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control"  :subid("64_1300062003.824")
    .param pmc param_307
.annotate 'line', 193
    .lex "self", param_307
    $P308 = param_307."!PREFIX__!protoregex"("statement_control")
    .return ($P308)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<use>"  :subid("65_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx310_tgt
    .local int rx310_pos
    .local int rx310_off
    .local int rx310_eos
    .local int rx310_rep
    .local pmc rx310_cur
    .local pmc rx310_debug
    (rx310_cur, rx310_pos, rx310_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx310_cur
    .local pmc match
    .lex "$/", match
    length rx310_eos, rx310_tgt
    gt rx310_pos, rx310_eos, rx310_done
    set rx310_off, 0
    lt rx310_pos, 2, rx310_start
    sub rx310_off, rx310_pos, 1
    substr rx310_tgt, rx310_tgt, rx310_off
  rx310_start:
    eq $I10, 1, rx310_restart
    if_null rx310_debug, debug_704
    rx310_cur."!cursor_debug"("START", "statement_control:sym<use>")
  debug_704:
    $I10 = self.'from'()
    ne $I10, -1, rxscan313_done
    goto rxscan313_scan
  rxscan313_loop:
    (rx310_pos) = rx310_cur."from"()
    inc rx310_pos
    rx310_cur."!cursor_from"(rx310_pos)
    ge rx310_pos, rx310_eos, rxscan313_done
  rxscan313_scan:
    set_addr $I10, rxscan313_loop
    rx310_cur."!mark_push"(0, rx310_pos, $I10)
  rxscan313_done:
.annotate 'line', 196
  # rx subcapture "sym"
    set_addr $I10, rxcap_314_fail
    rx310_cur."!mark_push"(0, rx310_pos, $I10)
  # rx literal  "use"
    add $I11, rx310_pos, 3
    gt $I11, rx310_eos, rx310_fail
    sub $I11, rx310_pos, rx310_off
    substr $S10, rx310_tgt, $I11, 3
    ne $S10, "use", rx310_fail
    add rx310_pos, 3
    set_addr $I10, rxcap_314_fail
    ($I12, $I11) = rx310_cur."!mark_peek"($I10)
    rx310_cur."!cursor_pos"($I11)
    ($P10) = rx310_cur."!cursor_start"()
    $P10."!cursor_pass"(rx310_pos, "")
    rx310_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_314_done
  rxcap_314_fail:
    goto rx310_fail
  rxcap_314_done:
  # rx charclass s
    ge rx310_pos, rx310_eos, rx310_fail
    sub $I10, rx310_pos, rx310_off
    is_cclass $I11, 32, rx310_tgt, $I10
    unless $I11, rx310_fail
    inc rx310_pos
  # rx subrule "ws" subtype=method negate=
    rx310_cur."!cursor_pos"(rx310_pos)
    $P10 = rx310_cur."ws"()
    unless $P10, rx310_fail
    rx310_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx310_cur."!cursor_pos"(rx310_pos)
    $P10 = rx310_cur."name"()
    unless $P10, rx310_fail
    rx310_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx310_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx310_cur."!cursor_pos"(rx310_pos)
    $P10 = rx310_cur."ws"()
    unless $P10, rx310_fail
    rx310_pos = $P10."pos"()
.annotate 'line', 195
  # rx pass
    rx310_cur."!cursor_pass"(rx310_pos, "statement_control:sym<use>")
    if_null rx310_debug, debug_705
    rx310_cur."!cursor_debug"("PASS", "statement_control:sym<use>", " at pos=", rx310_pos)
  debug_705:
    .return (rx310_cur)
  rx310_restart:
.annotate 'line', 10
    if_null rx310_debug, debug_706
    rx310_cur."!cursor_debug"("NEXT", "statement_control:sym<use>")
  debug_706:
  rx310_fail:
    (rx310_rep, rx310_pos, $I10, $P10) = rx310_cur."!mark_fail"(0)
    lt rx310_pos, -1, rx310_done
    eq rx310_pos, -1, rx310_fail
    jump $I10
  rx310_done:
    rx310_cur."!cursor_fail"()
    if_null rx310_debug, debug_707
    rx310_cur."!cursor_debug"("FAIL", "statement_control:sym<use>")
  debug_707:
    .return (rx310_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<use>"  :nsentry("!PREFIX__statement_control:sym<use>") :subid("66_1300062003.824") :method
.annotate 'line', 10
    new $P312, "ResizablePMCArray"
    push $P312, "use"
    .return ($P312)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<if>"  :subid("67_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx318_tgt
    .local int rx318_pos
    .local int rx318_off
    .local int rx318_eos
    .local int rx318_rep
    .local pmc rx318_cur
    .local pmc rx318_debug
    (rx318_cur, rx318_pos, rx318_tgt, $I10) = self."!cursor_start"()
    rx318_cur."!cursor_caparray"("xblock", "else")
    .lex unicode:"$\x{a2}", rx318_cur
    .local pmc match
    .lex "$/", match
    length rx318_eos, rx318_tgt
    gt rx318_pos, rx318_eos, rx318_done
    set rx318_off, 0
    lt rx318_pos, 2, rx318_start
    sub rx318_off, rx318_pos, 1
    substr rx318_tgt, rx318_tgt, rx318_off
  rx318_start:
    eq $I10, 1, rx318_restart
    if_null rx318_debug, debug_708
    rx318_cur."!cursor_debug"("START", "statement_control:sym<if>")
  debug_708:
    $I10 = self.'from'()
    ne $I10, -1, rxscan321_done
    goto rxscan321_scan
  rxscan321_loop:
    (rx318_pos) = rx318_cur."from"()
    inc rx318_pos
    rx318_cur."!cursor_from"(rx318_pos)
    ge rx318_pos, rx318_eos, rxscan321_done
  rxscan321_scan:
    set_addr $I10, rxscan321_loop
    rx318_cur."!mark_push"(0, rx318_pos, $I10)
  rxscan321_done:
.annotate 'line', 200
  # rx subcapture "sym"
    set_addr $I10, rxcap_322_fail
    rx318_cur."!mark_push"(0, rx318_pos, $I10)
  # rx literal  "if"
    add $I11, rx318_pos, 2
    gt $I11, rx318_eos, rx318_fail
    sub $I11, rx318_pos, rx318_off
    substr $S10, rx318_tgt, $I11, 2
    ne $S10, "if", rx318_fail
    add rx318_pos, 2
    set_addr $I10, rxcap_322_fail
    ($I12, $I11) = rx318_cur."!mark_peek"($I10)
    rx318_cur."!cursor_pos"($I11)
    ($P10) = rx318_cur."!cursor_start"()
    $P10."!cursor_pass"(rx318_pos, "")
    rx318_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_322_done
  rxcap_322_fail:
    goto rx318_fail
  rxcap_322_done:
  # rx charclass s
    ge rx318_pos, rx318_eos, rx318_fail
    sub $I10, rx318_pos, rx318_off
    is_cclass $I11, 32, rx318_tgt, $I10
    unless $I11, rx318_fail
    inc rx318_pos
  # rx subrule "ws" subtype=method negate=
    rx318_cur."!cursor_pos"(rx318_pos)
    $P10 = rx318_cur."ws"()
    unless $P10, rx318_fail
    rx318_pos = $P10."pos"()
.annotate 'line', 201
  # rx subrule "xblock" subtype=capture negate=
    rx318_cur."!cursor_pos"(rx318_pos)
    $P10 = rx318_cur."xblock"()
    unless $P10, rx318_fail
    rx318_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx318_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx318_cur."!cursor_pos"(rx318_pos)
    $P10 = rx318_cur."ws"()
    unless $P10, rx318_fail
    rx318_pos = $P10."pos"()
.annotate 'line', 202
  # rx rxquantr325 ** 0..*
    set_addr $I10, rxquantr325_done
    rx318_cur."!mark_push"(0, rx318_pos, $I10)
  rxquantr325_loop:
  # rx subrule "ws" subtype=method negate=
    rx318_cur."!cursor_pos"(rx318_pos)
    $P10 = rx318_cur."ws"()
    unless $P10, rx318_fail
    rx318_pos = $P10."pos"()
  # rx literal  "elsif"
    add $I11, rx318_pos, 5
    gt $I11, rx318_eos, rx318_fail
    sub $I11, rx318_pos, rx318_off
    substr $S10, rx318_tgt, $I11, 5
    ne $S10, "elsif", rx318_fail
    add rx318_pos, 5
  # rx charclass s
    ge rx318_pos, rx318_eos, rx318_fail
    sub $I10, rx318_pos, rx318_off
    is_cclass $I11, 32, rx318_tgt, $I10
    unless $I11, rx318_fail
    inc rx318_pos
  # rx subrule "ws" subtype=method negate=
    rx318_cur."!cursor_pos"(rx318_pos)
    $P10 = rx318_cur."ws"()
    unless $P10, rx318_fail
    rx318_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx318_cur."!cursor_pos"(rx318_pos)
    $P10 = rx318_cur."xblock"()
    unless $P10, rx318_fail
    rx318_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx318_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx318_cur."!cursor_pos"(rx318_pos)
    $P10 = rx318_cur."ws"()
    unless $P10, rx318_fail
    rx318_pos = $P10."pos"()
    set_addr $I10, rxquantr325_done
    (rx318_rep) = rx318_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr325_done
    rx318_cur."!mark_push"(rx318_rep, rx318_pos, $I10)
    goto rxquantr325_loop
  rxquantr325_done:
  # rx subrule "ws" subtype=method negate=
    rx318_cur."!cursor_pos"(rx318_pos)
    $P10 = rx318_cur."ws"()
    unless $P10, rx318_fail
    rx318_pos = $P10."pos"()
.annotate 'line', 203
  # rx rxquantr330 ** 0..1
    set_addr $I10, rxquantr330_done
    rx318_cur."!mark_push"(0, rx318_pos, $I10)
  rxquantr330_loop:
  # rx subrule "ws" subtype=method negate=
    rx318_cur."!cursor_pos"(rx318_pos)
    $P10 = rx318_cur."ws"()
    unless $P10, rx318_fail
    rx318_pos = $P10."pos"()
  # rx literal  "else"
    add $I11, rx318_pos, 4
    gt $I11, rx318_eos, rx318_fail
    sub $I11, rx318_pos, rx318_off
    substr $S10, rx318_tgt, $I11, 4
    ne $S10, "else", rx318_fail
    add rx318_pos, 4
  # rx charclass s
    ge rx318_pos, rx318_eos, rx318_fail
    sub $I10, rx318_pos, rx318_off
    is_cclass $I11, 32, rx318_tgt, $I10
    unless $I11, rx318_fail
    inc rx318_pos
  # rx subrule "ws" subtype=method negate=
    rx318_cur."!cursor_pos"(rx318_pos)
    $P10 = rx318_cur."ws"()
    unless $P10, rx318_fail
    rx318_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx318_cur."!cursor_pos"(rx318_pos)
    $P10 = rx318_cur."pblock"()
    unless $P10, rx318_fail
    rx318_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("else")
    rx318_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx318_cur."!cursor_pos"(rx318_pos)
    $P10 = rx318_cur."ws"()
    unless $P10, rx318_fail
    rx318_pos = $P10."pos"()
    set_addr $I10, rxquantr330_done
    (rx318_rep) = rx318_cur."!mark_commit"($I10)
  rxquantr330_done:
  # rx subrule "ws" subtype=method negate=
    rx318_cur."!cursor_pos"(rx318_pos)
    $P10 = rx318_cur."ws"()
    unless $P10, rx318_fail
    rx318_pos = $P10."pos"()
.annotate 'line', 199
  # rx pass
    rx318_cur."!cursor_pass"(rx318_pos, "statement_control:sym<if>")
    if_null rx318_debug, debug_709
    rx318_cur."!cursor_debug"("PASS", "statement_control:sym<if>", " at pos=", rx318_pos)
  debug_709:
    .return (rx318_cur)
  rx318_restart:
.annotate 'line', 10
    if_null rx318_debug, debug_710
    rx318_cur."!cursor_debug"("NEXT", "statement_control:sym<if>")
  debug_710:
  rx318_fail:
    (rx318_rep, rx318_pos, $I10, $P10) = rx318_cur."!mark_fail"(0)
    lt rx318_pos, -1, rx318_done
    eq rx318_pos, -1, rx318_fail
    jump $I10
  rx318_done:
    rx318_cur."!cursor_fail"()
    if_null rx318_debug, debug_711
    rx318_cur."!cursor_debug"("FAIL", "statement_control:sym<if>")
  debug_711:
    .return (rx318_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<if>"  :nsentry("!PREFIX__statement_control:sym<if>") :subid("68_1300062003.824") :method
.annotate 'line', 10
    new $P320, "ResizablePMCArray"
    push $P320, "if"
    .return ($P320)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<unless>"  :subid("69_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .const 'Sub' $P346 = "71_1300062003.824" 
    capture_lex $P346
    .local string rx336_tgt
    .local int rx336_pos
    .local int rx336_off
    .local int rx336_eos
    .local int rx336_rep
    .local pmc rx336_cur
    .local pmc rx336_debug
    (rx336_cur, rx336_pos, rx336_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx336_cur
    .local pmc match
    .lex "$/", match
    length rx336_eos, rx336_tgt
    gt rx336_pos, rx336_eos, rx336_done
    set rx336_off, 0
    lt rx336_pos, 2, rx336_start
    sub rx336_off, rx336_pos, 1
    substr rx336_tgt, rx336_tgt, rx336_off
  rx336_start:
    eq $I10, 1, rx336_restart
    if_null rx336_debug, debug_712
    rx336_cur."!cursor_debug"("START", "statement_control:sym<unless>")
  debug_712:
    $I10 = self.'from'()
    ne $I10, -1, rxscan339_done
    goto rxscan339_scan
  rxscan339_loop:
    (rx336_pos) = rx336_cur."from"()
    inc rx336_pos
    rx336_cur."!cursor_from"(rx336_pos)
    ge rx336_pos, rx336_eos, rxscan339_done
  rxscan339_scan:
    set_addr $I10, rxscan339_loop
    rx336_cur."!mark_push"(0, rx336_pos, $I10)
  rxscan339_done:
.annotate 'line', 207
  # rx subcapture "sym"
    set_addr $I10, rxcap_340_fail
    rx336_cur."!mark_push"(0, rx336_pos, $I10)
  # rx literal  "unless"
    add $I11, rx336_pos, 6
    gt $I11, rx336_eos, rx336_fail
    sub $I11, rx336_pos, rx336_off
    substr $S10, rx336_tgt, $I11, 6
    ne $S10, "unless", rx336_fail
    add rx336_pos, 6
    set_addr $I10, rxcap_340_fail
    ($I12, $I11) = rx336_cur."!mark_peek"($I10)
    rx336_cur."!cursor_pos"($I11)
    ($P10) = rx336_cur."!cursor_start"()
    $P10."!cursor_pass"(rx336_pos, "")
    rx336_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_340_done
  rxcap_340_fail:
    goto rx336_fail
  rxcap_340_done:
  # rx charclass s
    ge rx336_pos, rx336_eos, rx336_fail
    sub $I10, rx336_pos, rx336_off
    is_cclass $I11, 32, rx336_tgt, $I10
    unless $I11, rx336_fail
    inc rx336_pos
  # rx subrule "ws" subtype=method negate=
    rx336_cur."!cursor_pos"(rx336_pos)
    $P10 = rx336_cur."ws"()
    unless $P10, rx336_fail
    rx336_pos = $P10."pos"()
.annotate 'line', 208
  # rx subrule "xblock" subtype=capture negate=
    rx336_cur."!cursor_pos"(rx336_pos)
    $P10 = rx336_cur."xblock"()
    unless $P10, rx336_fail
    rx336_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx336_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx336_cur."!cursor_pos"(rx336_pos)
    $P10 = rx336_cur."ws"()
    unless $P10, rx336_fail
    rx336_pos = $P10."pos"()
  alt343_0:
.annotate 'line', 209
    set_addr $I10, alt343_1
    rx336_cur."!mark_push"(0, rx336_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx336_cur."!cursor_pos"(rx336_pos)
    $P10 = rx336_cur."ws"()
    unless $P10, rx336_fail
    rx336_pos = $P10."pos"()
  # rx subrule "before" subtype=zerowidth negate=1
    rx336_cur."!cursor_pos"(rx336_pos)
    .const 'Sub' $P346 = "71_1300062003.824" 
    capture_lex $P346
    $P10 = rx336_cur."before"($P346)
    if $P10, rx336_fail
  # rx subrule "ws" subtype=method negate=
    rx336_cur."!cursor_pos"(rx336_pos)
    $P10 = rx336_cur."ws"()
    unless $P10, rx336_fail
    rx336_pos = $P10."pos"()
    goto alt343_end
  alt343_1:
  # rx subrule "ws" subtype=method negate=
    rx336_cur."!cursor_pos"(rx336_pos)
    $P10 = rx336_cur."ws"()
    unless $P10, rx336_fail
    rx336_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx336_cur."!cursor_pos"(rx336_pos)
    $P10 = rx336_cur."panic"("unless does not take \"else\", please rewrite using \"if\"")
    unless $P10, rx336_fail
    rx336_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx336_cur."!cursor_pos"(rx336_pos)
    $P10 = rx336_cur."ws"()
    unless $P10, rx336_fail
    rx336_pos = $P10."pos"()
  alt343_end:
  # rx subrule "ws" subtype=method negate=
    rx336_cur."!cursor_pos"(rx336_pos)
    $P10 = rx336_cur."ws"()
    unless $P10, rx336_fail
    rx336_pos = $P10."pos"()
.annotate 'line', 206
  # rx pass
    rx336_cur."!cursor_pass"(rx336_pos, "statement_control:sym<unless>")
    if_null rx336_debug, debug_717
    rx336_cur."!cursor_debug"("PASS", "statement_control:sym<unless>", " at pos=", rx336_pos)
  debug_717:
    .return (rx336_cur)
  rx336_restart:
.annotate 'line', 10
    if_null rx336_debug, debug_718
    rx336_cur."!cursor_debug"("NEXT", "statement_control:sym<unless>")
  debug_718:
  rx336_fail:
    (rx336_rep, rx336_pos, $I10, $P10) = rx336_cur."!mark_fail"(0)
    lt rx336_pos, -1, rx336_done
    eq rx336_pos, -1, rx336_fail
    jump $I10
  rx336_done:
    rx336_cur."!cursor_fail"()
    if_null rx336_debug, debug_719
    rx336_cur."!cursor_debug"("FAIL", "statement_control:sym<unless>")
  debug_719:
    .return (rx336_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<unless>"  :nsentry("!PREFIX__statement_control:sym<unless>") :subid("70_1300062003.824") :method
.annotate 'line', 10
    new $P338, "ResizablePMCArray"
    push $P338, "unless"
    .return ($P338)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block345"  :anon :subid("71_1300062003.824") :method :outer("69_1300062003.824")
.annotate 'line', 209
    .local string rx347_tgt
    .local int rx347_pos
    .local int rx347_off
    .local int rx347_eos
    .local int rx347_rep
    .local pmc rx347_cur
    .local pmc rx347_debug
    (rx347_cur, rx347_pos, rx347_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx347_cur
    .local pmc match
    .lex "$/", match
    length rx347_eos, rx347_tgt
    gt rx347_pos, rx347_eos, rx347_done
    set rx347_off, 0
    lt rx347_pos, 2, rx347_start
    sub rx347_off, rx347_pos, 1
    substr rx347_tgt, rx347_tgt, rx347_off
  rx347_start:
    eq $I10, 1, rx347_restart
    if_null rx347_debug, debug_713
    rx347_cur."!cursor_debug"("START", "")
  debug_713:
    $I10 = self.'from'()
    ne $I10, -1, rxscan348_done
    goto rxscan348_scan
  rxscan348_loop:
    (rx347_pos) = rx347_cur."from"()
    inc rx347_pos
    rx347_cur."!cursor_from"(rx347_pos)
    ge rx347_pos, rx347_eos, rxscan348_done
  rxscan348_scan:
    set_addr $I10, rxscan348_loop
    rx347_cur."!mark_push"(0, rx347_pos, $I10)
  rxscan348_done:
  # rx literal  "else"
    add $I11, rx347_pos, 4
    gt $I11, rx347_eos, rx347_fail
    sub $I11, rx347_pos, rx347_off
    substr $S10, rx347_tgt, $I11, 4
    ne $S10, "else", rx347_fail
    add rx347_pos, 4
  # rx pass
    rx347_cur."!cursor_pass"(rx347_pos, "")
    if_null rx347_debug, debug_714
    rx347_cur."!cursor_debug"("PASS", "", " at pos=", rx347_pos)
  debug_714:
    .return (rx347_cur)
  rx347_restart:
    if_null rx347_debug, debug_715
    rx347_cur."!cursor_debug"("NEXT", "")
  debug_715:
  rx347_fail:
    (rx347_rep, rx347_pos, $I10, $P10) = rx347_cur."!mark_fail"(0)
    lt rx347_pos, -1, rx347_done
    eq rx347_pos, -1, rx347_fail
    jump $I10
  rx347_done:
    rx347_cur."!cursor_fail"()
    if_null rx347_debug, debug_716
    rx347_cur."!cursor_debug"("FAIL", "")
  debug_716:
    .return (rx347_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<while>"  :subid("72_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx354_tgt
    .local int rx354_pos
    .local int rx354_off
    .local int rx354_eos
    .local int rx354_rep
    .local pmc rx354_cur
    .local pmc rx354_debug
    (rx354_cur, rx354_pos, rx354_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx354_cur
    .local pmc match
    .lex "$/", match
    length rx354_eos, rx354_tgt
    gt rx354_pos, rx354_eos, rx354_done
    set rx354_off, 0
    lt rx354_pos, 2, rx354_start
    sub rx354_off, rx354_pos, 1
    substr rx354_tgt, rx354_tgt, rx354_off
  rx354_start:
    eq $I10, 1, rx354_restart
    if_null rx354_debug, debug_720
    rx354_cur."!cursor_debug"("START", "statement_control:sym<while>")
  debug_720:
    $I10 = self.'from'()
    ne $I10, -1, rxscan357_done
    goto rxscan357_scan
  rxscan357_loop:
    (rx354_pos) = rx354_cur."from"()
    inc rx354_pos
    rx354_cur."!cursor_from"(rx354_pos)
    ge rx354_pos, rx354_eos, rxscan357_done
  rxscan357_scan:
    set_addr $I10, rxscan357_loop
    rx354_cur."!mark_push"(0, rx354_pos, $I10)
  rxscan357_done:
.annotate 'line', 213
  # rx subcapture "sym"
    set_addr $I10, rxcap_359_fail
    rx354_cur."!mark_push"(0, rx354_pos, $I10)
  alt358_0:
    set_addr $I10, alt358_1
    rx354_cur."!mark_push"(0, rx354_pos, $I10)
  # rx literal  "while"
    add $I11, rx354_pos, 5
    gt $I11, rx354_eos, rx354_fail
    sub $I11, rx354_pos, rx354_off
    substr $S10, rx354_tgt, $I11, 5
    ne $S10, "while", rx354_fail
    add rx354_pos, 5
    goto alt358_end
  alt358_1:
  # rx literal  "until"
    add $I11, rx354_pos, 5
    gt $I11, rx354_eos, rx354_fail
    sub $I11, rx354_pos, rx354_off
    substr $S10, rx354_tgt, $I11, 5
    ne $S10, "until", rx354_fail
    add rx354_pos, 5
  alt358_end:
    set_addr $I10, rxcap_359_fail
    ($I12, $I11) = rx354_cur."!mark_peek"($I10)
    rx354_cur."!cursor_pos"($I11)
    ($P10) = rx354_cur."!cursor_start"()
    $P10."!cursor_pass"(rx354_pos, "")
    rx354_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_359_done
  rxcap_359_fail:
    goto rx354_fail
  rxcap_359_done:
  # rx charclass s
    ge rx354_pos, rx354_eos, rx354_fail
    sub $I10, rx354_pos, rx354_off
    is_cclass $I11, 32, rx354_tgt, $I10
    unless $I11, rx354_fail
    inc rx354_pos
  # rx subrule "ws" subtype=method negate=
    rx354_cur."!cursor_pos"(rx354_pos)
    $P10 = rx354_cur."ws"()
    unless $P10, rx354_fail
    rx354_pos = $P10."pos"()
.annotate 'line', 214
  # rx subrule "xblock" subtype=capture negate=
    rx354_cur."!cursor_pos"(rx354_pos)
    $P10 = rx354_cur."xblock"()
    unless $P10, rx354_fail
    rx354_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx354_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx354_cur."!cursor_pos"(rx354_pos)
    $P10 = rx354_cur."ws"()
    unless $P10, rx354_fail
    rx354_pos = $P10."pos"()
.annotate 'line', 212
  # rx pass
    rx354_cur."!cursor_pass"(rx354_pos, "statement_control:sym<while>")
    if_null rx354_debug, debug_721
    rx354_cur."!cursor_debug"("PASS", "statement_control:sym<while>", " at pos=", rx354_pos)
  debug_721:
    .return (rx354_cur)
  rx354_restart:
.annotate 'line', 10
    if_null rx354_debug, debug_722
    rx354_cur."!cursor_debug"("NEXT", "statement_control:sym<while>")
  debug_722:
  rx354_fail:
    (rx354_rep, rx354_pos, $I10, $P10) = rx354_cur."!mark_fail"(0)
    lt rx354_pos, -1, rx354_done
    eq rx354_pos, -1, rx354_fail
    jump $I10
  rx354_done:
    rx354_cur."!cursor_fail"()
    if_null rx354_debug, debug_723
    rx354_cur."!cursor_debug"("FAIL", "statement_control:sym<while>")
  debug_723:
    .return (rx354_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<while>"  :nsentry("!PREFIX__statement_control:sym<while>") :subid("73_1300062003.824") :method
.annotate 'line', 10
    new $P356, "ResizablePMCArray"
    push $P356, "until"
    push $P356, "while"
    .return ($P356)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<repeat>"  :subid("74_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx363_tgt
    .local int rx363_pos
    .local int rx363_off
    .local int rx363_eos
    .local int rx363_rep
    .local pmc rx363_cur
    .local pmc rx363_debug
    (rx363_cur, rx363_pos, rx363_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx363_cur
    .local pmc match
    .lex "$/", match
    length rx363_eos, rx363_tgt
    gt rx363_pos, rx363_eos, rx363_done
    set rx363_off, 0
    lt rx363_pos, 2, rx363_start
    sub rx363_off, rx363_pos, 1
    substr rx363_tgt, rx363_tgt, rx363_off
  rx363_start:
    eq $I10, 1, rx363_restart
    if_null rx363_debug, debug_724
    rx363_cur."!cursor_debug"("START", "statement_control:sym<repeat>")
  debug_724:
    $I10 = self.'from'()
    ne $I10, -1, rxscan366_done
    goto rxscan366_scan
  rxscan366_loop:
    (rx363_pos) = rx363_cur."from"()
    inc rx363_pos
    rx363_cur."!cursor_from"(rx363_pos)
    ge rx363_pos, rx363_eos, rxscan366_done
  rxscan366_scan:
    set_addr $I10, rxscan366_loop
    rx363_cur."!mark_push"(0, rx363_pos, $I10)
  rxscan366_done:
.annotate 'line', 218
  # rx subcapture "sym"
    set_addr $I10, rxcap_367_fail
    rx363_cur."!mark_push"(0, rx363_pos, $I10)
  # rx literal  "repeat"
    add $I11, rx363_pos, 6
    gt $I11, rx363_eos, rx363_fail
    sub $I11, rx363_pos, rx363_off
    substr $S10, rx363_tgt, $I11, 6
    ne $S10, "repeat", rx363_fail
    add rx363_pos, 6
    set_addr $I10, rxcap_367_fail
    ($I12, $I11) = rx363_cur."!mark_peek"($I10)
    rx363_cur."!cursor_pos"($I11)
    ($P10) = rx363_cur."!cursor_start"()
    $P10."!cursor_pass"(rx363_pos, "")
    rx363_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_367_done
  rxcap_367_fail:
    goto rx363_fail
  rxcap_367_done:
  # rx charclass s
    ge rx363_pos, rx363_eos, rx363_fail
    sub $I10, rx363_pos, rx363_off
    is_cclass $I11, 32, rx363_tgt, $I10
    unless $I11, rx363_fail
    inc rx363_pos
  # rx subrule "ws" subtype=method negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."ws"()
    unless $P10, rx363_fail
    rx363_pos = $P10."pos"()
  alt369_0:
.annotate 'line', 219
    set_addr $I10, alt369_1
    rx363_cur."!mark_push"(0, rx363_pos, $I10)
.annotate 'line', 220
  # rx subrule "ws" subtype=method negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."ws"()
    unless $P10, rx363_fail
    rx363_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_372_fail
    rx363_cur."!mark_push"(0, rx363_pos, $I10)
  alt371_0:
    set_addr $I10, alt371_1
    rx363_cur."!mark_push"(0, rx363_pos, $I10)
  # rx literal  "while"
    add $I11, rx363_pos, 5
    gt $I11, rx363_eos, rx363_fail
    sub $I11, rx363_pos, rx363_off
    substr $S10, rx363_tgt, $I11, 5
    ne $S10, "while", rx363_fail
    add rx363_pos, 5
    goto alt371_end
  alt371_1:
  # rx literal  "until"
    add $I11, rx363_pos, 5
    gt $I11, rx363_eos, rx363_fail
    sub $I11, rx363_pos, rx363_off
    substr $S10, rx363_tgt, $I11, 5
    ne $S10, "until", rx363_fail
    add rx363_pos, 5
  alt371_end:
    set_addr $I10, rxcap_372_fail
    ($I12, $I11) = rx363_cur."!mark_peek"($I10)
    rx363_cur."!cursor_pos"($I11)
    ($P10) = rx363_cur."!cursor_start"()
    $P10."!cursor_pass"(rx363_pos, "")
    rx363_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_372_done
  rxcap_372_fail:
    goto rx363_fail
  rxcap_372_done:
  # rx charclass s
    ge rx363_pos, rx363_eos, rx363_fail
    sub $I10, rx363_pos, rx363_off
    is_cclass $I11, 32, rx363_tgt, $I10
    unless $I11, rx363_fail
    inc rx363_pos
  # rx subrule "ws" subtype=method negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."ws"()
    unless $P10, rx363_fail
    rx363_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."xblock"()
    unless $P10, rx363_fail
    rx363_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx363_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."ws"()
    unless $P10, rx363_fail
    rx363_pos = $P10."pos"()
    goto alt369_end
  alt369_1:
.annotate 'line', 221
  # rx subrule "ws" subtype=method negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."ws"()
    unless $P10, rx363_fail
    rx363_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."pblock"()
    unless $P10, rx363_fail
    rx363_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx363_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."ws"()
    unless $P10, rx363_fail
    rx363_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_378_fail
    rx363_cur."!mark_push"(0, rx363_pos, $I10)
  alt377_0:
    set_addr $I10, alt377_1
    rx363_cur."!mark_push"(0, rx363_pos, $I10)
  # rx literal  "while"
    add $I11, rx363_pos, 5
    gt $I11, rx363_eos, rx363_fail
    sub $I11, rx363_pos, rx363_off
    substr $S10, rx363_tgt, $I11, 5
    ne $S10, "while", rx363_fail
    add rx363_pos, 5
    goto alt377_end
  alt377_1:
  # rx literal  "until"
    add $I11, rx363_pos, 5
    gt $I11, rx363_eos, rx363_fail
    sub $I11, rx363_pos, rx363_off
    substr $S10, rx363_tgt, $I11, 5
    ne $S10, "until", rx363_fail
    add rx363_pos, 5
  alt377_end:
    set_addr $I10, rxcap_378_fail
    ($I12, $I11) = rx363_cur."!mark_peek"($I10)
    rx363_cur."!cursor_pos"($I11)
    ($P10) = rx363_cur."!cursor_start"()
    $P10."!cursor_pass"(rx363_pos, "")
    rx363_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_378_done
  rxcap_378_fail:
    goto rx363_fail
  rxcap_378_done:
  # rx charclass s
    ge rx363_pos, rx363_eos, rx363_fail
    sub $I10, rx363_pos, rx363_off
    is_cclass $I11, 32, rx363_tgt, $I10
    unless $I11, rx363_fail
    inc rx363_pos
  # rx subrule "ws" subtype=method negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."ws"()
    unless $P10, rx363_fail
    rx363_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."EXPR"()
    unless $P10, rx363_fail
    rx363_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx363_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."ws"()
    unless $P10, rx363_fail
    rx363_pos = $P10."pos"()
  alt369_end:
.annotate 'line', 222
  # rx subrule "ws" subtype=method negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."ws"()
    unless $P10, rx363_fail
    rx363_pos = $P10."pos"()
.annotate 'line', 217
  # rx pass
    rx363_cur."!cursor_pass"(rx363_pos, "statement_control:sym<repeat>")
    if_null rx363_debug, debug_725
    rx363_cur."!cursor_debug"("PASS", "statement_control:sym<repeat>", " at pos=", rx363_pos)
  debug_725:
    .return (rx363_cur)
  rx363_restart:
.annotate 'line', 10
    if_null rx363_debug, debug_726
    rx363_cur."!cursor_debug"("NEXT", "statement_control:sym<repeat>")
  debug_726:
  rx363_fail:
    (rx363_rep, rx363_pos, $I10, $P10) = rx363_cur."!mark_fail"(0)
    lt rx363_pos, -1, rx363_done
    eq rx363_pos, -1, rx363_fail
    jump $I10
  rx363_done:
    rx363_cur."!cursor_fail"()
    if_null rx363_debug, debug_727
    rx363_cur."!cursor_debug"("FAIL", "statement_control:sym<repeat>")
  debug_727:
    .return (rx363_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<repeat>"  :nsentry("!PREFIX__statement_control:sym<repeat>") :subid("75_1300062003.824") :method
.annotate 'line', 10
    new $P365, "ResizablePMCArray"
    push $P365, "repeat"
    .return ($P365)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<for>"  :subid("76_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx383_tgt
    .local int rx383_pos
    .local int rx383_off
    .local int rx383_eos
    .local int rx383_rep
    .local pmc rx383_cur
    .local pmc rx383_debug
    (rx383_cur, rx383_pos, rx383_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx383_cur
    .local pmc match
    .lex "$/", match
    length rx383_eos, rx383_tgt
    gt rx383_pos, rx383_eos, rx383_done
    set rx383_off, 0
    lt rx383_pos, 2, rx383_start
    sub rx383_off, rx383_pos, 1
    substr rx383_tgt, rx383_tgt, rx383_off
  rx383_start:
    eq $I10, 1, rx383_restart
    if_null rx383_debug, debug_728
    rx383_cur."!cursor_debug"("START", "statement_control:sym<for>")
  debug_728:
    $I10 = self.'from'()
    ne $I10, -1, rxscan386_done
    goto rxscan386_scan
  rxscan386_loop:
    (rx383_pos) = rx383_cur."from"()
    inc rx383_pos
    rx383_cur."!cursor_from"(rx383_pos)
    ge rx383_pos, rx383_eos, rxscan386_done
  rxscan386_scan:
    set_addr $I10, rxscan386_loop
    rx383_cur."!mark_push"(0, rx383_pos, $I10)
  rxscan386_done:
.annotate 'line', 226
  # rx subcapture "sym"
    set_addr $I10, rxcap_387_fail
    rx383_cur."!mark_push"(0, rx383_pos, $I10)
  # rx literal  "for"
    add $I11, rx383_pos, 3
    gt $I11, rx383_eos, rx383_fail
    sub $I11, rx383_pos, rx383_off
    substr $S10, rx383_tgt, $I11, 3
    ne $S10, "for", rx383_fail
    add rx383_pos, 3
    set_addr $I10, rxcap_387_fail
    ($I12, $I11) = rx383_cur."!mark_peek"($I10)
    rx383_cur."!cursor_pos"($I11)
    ($P10) = rx383_cur."!cursor_start"()
    $P10."!cursor_pass"(rx383_pos, "")
    rx383_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_387_done
  rxcap_387_fail:
    goto rx383_fail
  rxcap_387_done:
  # rx charclass s
    ge rx383_pos, rx383_eos, rx383_fail
    sub $I10, rx383_pos, rx383_off
    is_cclass $I11, 32, rx383_tgt, $I10
    unless $I11, rx383_fail
    inc rx383_pos
  # rx subrule "ws" subtype=method negate=
    rx383_cur."!cursor_pos"(rx383_pos)
    $P10 = rx383_cur."ws"()
    unless $P10, rx383_fail
    rx383_pos = $P10."pos"()
.annotate 'line', 227
  # rx subrule "xblock" subtype=capture negate=
    rx383_cur."!cursor_pos"(rx383_pos)
    $P10 = rx383_cur."xblock"()
    unless $P10, rx383_fail
    rx383_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx383_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx383_cur."!cursor_pos"(rx383_pos)
    $P10 = rx383_cur."ws"()
    unless $P10, rx383_fail
    rx383_pos = $P10."pos"()
.annotate 'line', 225
  # rx pass
    rx383_cur."!cursor_pass"(rx383_pos, "statement_control:sym<for>")
    if_null rx383_debug, debug_729
    rx383_cur."!cursor_debug"("PASS", "statement_control:sym<for>", " at pos=", rx383_pos)
  debug_729:
    .return (rx383_cur)
  rx383_restart:
.annotate 'line', 10
    if_null rx383_debug, debug_730
    rx383_cur."!cursor_debug"("NEXT", "statement_control:sym<for>")
  debug_730:
  rx383_fail:
    (rx383_rep, rx383_pos, $I10, $P10) = rx383_cur."!mark_fail"(0)
    lt rx383_pos, -1, rx383_done
    eq rx383_pos, -1, rx383_fail
    jump $I10
  rx383_done:
    rx383_cur."!cursor_fail"()
    if_null rx383_debug, debug_731
    rx383_cur."!cursor_debug"("FAIL", "statement_control:sym<for>")
  debug_731:
    .return (rx383_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<for>"  :nsentry("!PREFIX__statement_control:sym<for>") :subid("77_1300062003.824") :method
.annotate 'line', 10
    new $P385, "ResizablePMCArray"
    push $P385, "for"
    .return ($P385)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CATCH>"  :subid("78_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx391_tgt
    .local int rx391_pos
    .local int rx391_off
    .local int rx391_eos
    .local int rx391_rep
    .local pmc rx391_cur
    .local pmc rx391_debug
    (rx391_cur, rx391_pos, rx391_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx391_cur
    .local pmc match
    .lex "$/", match
    length rx391_eos, rx391_tgt
    gt rx391_pos, rx391_eos, rx391_done
    set rx391_off, 0
    lt rx391_pos, 2, rx391_start
    sub rx391_off, rx391_pos, 1
    substr rx391_tgt, rx391_tgt, rx391_off
  rx391_start:
    eq $I10, 1, rx391_restart
    if_null rx391_debug, debug_732
    rx391_cur."!cursor_debug"("START", "statement_control:sym<CATCH>")
  debug_732:
    $I10 = self.'from'()
    ne $I10, -1, rxscan394_done
    goto rxscan394_scan
  rxscan394_loop:
    (rx391_pos) = rx391_cur."from"()
    inc rx391_pos
    rx391_cur."!cursor_from"(rx391_pos)
    ge rx391_pos, rx391_eos, rxscan394_done
  rxscan394_scan:
    set_addr $I10, rxscan394_loop
    rx391_cur."!mark_push"(0, rx391_pos, $I10)
  rxscan394_done:
.annotate 'line', 231
  # rx subcapture "sym"
    set_addr $I10, rxcap_395_fail
    rx391_cur."!mark_push"(0, rx391_pos, $I10)
  # rx literal  "CATCH"
    add $I11, rx391_pos, 5
    gt $I11, rx391_eos, rx391_fail
    sub $I11, rx391_pos, rx391_off
    substr $S10, rx391_tgt, $I11, 5
    ne $S10, "CATCH", rx391_fail
    add rx391_pos, 5
    set_addr $I10, rxcap_395_fail
    ($I12, $I11) = rx391_cur."!mark_peek"($I10)
    rx391_cur."!cursor_pos"($I11)
    ($P10) = rx391_cur."!cursor_start"()
    $P10."!cursor_pass"(rx391_pos, "")
    rx391_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_395_done
  rxcap_395_fail:
    goto rx391_fail
  rxcap_395_done:
  # rx charclass s
    ge rx391_pos, rx391_eos, rx391_fail
    sub $I10, rx391_pos, rx391_off
    is_cclass $I11, 32, rx391_tgt, $I10
    unless $I11, rx391_fail
    inc rx391_pos
  # rx subrule "ws" subtype=method negate=
    rx391_cur."!cursor_pos"(rx391_pos)
    $P10 = rx391_cur."ws"()
    unless $P10, rx391_fail
    rx391_pos = $P10."pos"()
.annotate 'line', 232
  # rx subrule "block" subtype=capture negate=
    rx391_cur."!cursor_pos"(rx391_pos)
    $P10 = rx391_cur."block"()
    unless $P10, rx391_fail
    rx391_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx391_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx391_cur."!cursor_pos"(rx391_pos)
    $P10 = rx391_cur."ws"()
    unless $P10, rx391_fail
    rx391_pos = $P10."pos"()
.annotate 'line', 230
  # rx pass
    rx391_cur."!cursor_pass"(rx391_pos, "statement_control:sym<CATCH>")
    if_null rx391_debug, debug_733
    rx391_cur."!cursor_debug"("PASS", "statement_control:sym<CATCH>", " at pos=", rx391_pos)
  debug_733:
    .return (rx391_cur)
  rx391_restart:
.annotate 'line', 10
    if_null rx391_debug, debug_734
    rx391_cur."!cursor_debug"("NEXT", "statement_control:sym<CATCH>")
  debug_734:
  rx391_fail:
    (rx391_rep, rx391_pos, $I10, $P10) = rx391_cur."!mark_fail"(0)
    lt rx391_pos, -1, rx391_done
    eq rx391_pos, -1, rx391_fail
    jump $I10
  rx391_done:
    rx391_cur."!cursor_fail"()
    if_null rx391_debug, debug_735
    rx391_cur."!cursor_debug"("FAIL", "statement_control:sym<CATCH>")
  debug_735:
    .return (rx391_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CATCH>"  :nsentry("!PREFIX__statement_control:sym<CATCH>") :subid("79_1300062003.824") :method
.annotate 'line', 10
    new $P393, "ResizablePMCArray"
    push $P393, "CATCH"
    .return ($P393)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CONTROL>"  :subid("80_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx399_tgt
    .local int rx399_pos
    .local int rx399_off
    .local int rx399_eos
    .local int rx399_rep
    .local pmc rx399_cur
    .local pmc rx399_debug
    (rx399_cur, rx399_pos, rx399_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx399_cur
    .local pmc match
    .lex "$/", match
    length rx399_eos, rx399_tgt
    gt rx399_pos, rx399_eos, rx399_done
    set rx399_off, 0
    lt rx399_pos, 2, rx399_start
    sub rx399_off, rx399_pos, 1
    substr rx399_tgt, rx399_tgt, rx399_off
  rx399_start:
    eq $I10, 1, rx399_restart
    if_null rx399_debug, debug_736
    rx399_cur."!cursor_debug"("START", "statement_control:sym<CONTROL>")
  debug_736:
    $I10 = self.'from'()
    ne $I10, -1, rxscan402_done
    goto rxscan402_scan
  rxscan402_loop:
    (rx399_pos) = rx399_cur."from"()
    inc rx399_pos
    rx399_cur."!cursor_from"(rx399_pos)
    ge rx399_pos, rx399_eos, rxscan402_done
  rxscan402_scan:
    set_addr $I10, rxscan402_loop
    rx399_cur."!mark_push"(0, rx399_pos, $I10)
  rxscan402_done:
.annotate 'line', 236
  # rx subcapture "sym"
    set_addr $I10, rxcap_403_fail
    rx399_cur."!mark_push"(0, rx399_pos, $I10)
  # rx literal  "CONTROL"
    add $I11, rx399_pos, 7
    gt $I11, rx399_eos, rx399_fail
    sub $I11, rx399_pos, rx399_off
    substr $S10, rx399_tgt, $I11, 7
    ne $S10, "CONTROL", rx399_fail
    add rx399_pos, 7
    set_addr $I10, rxcap_403_fail
    ($I12, $I11) = rx399_cur."!mark_peek"($I10)
    rx399_cur."!cursor_pos"($I11)
    ($P10) = rx399_cur."!cursor_start"()
    $P10."!cursor_pass"(rx399_pos, "")
    rx399_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_403_done
  rxcap_403_fail:
    goto rx399_fail
  rxcap_403_done:
  # rx charclass s
    ge rx399_pos, rx399_eos, rx399_fail
    sub $I10, rx399_pos, rx399_off
    is_cclass $I11, 32, rx399_tgt, $I10
    unless $I11, rx399_fail
    inc rx399_pos
  # rx subrule "ws" subtype=method negate=
    rx399_cur."!cursor_pos"(rx399_pos)
    $P10 = rx399_cur."ws"()
    unless $P10, rx399_fail
    rx399_pos = $P10."pos"()
.annotate 'line', 237
  # rx subrule "block" subtype=capture negate=
    rx399_cur."!cursor_pos"(rx399_pos)
    $P10 = rx399_cur."block"()
    unless $P10, rx399_fail
    rx399_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx399_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx399_cur."!cursor_pos"(rx399_pos)
    $P10 = rx399_cur."ws"()
    unless $P10, rx399_fail
    rx399_pos = $P10."pos"()
.annotate 'line', 235
  # rx pass
    rx399_cur."!cursor_pass"(rx399_pos, "statement_control:sym<CONTROL>")
    if_null rx399_debug, debug_737
    rx399_cur."!cursor_debug"("PASS", "statement_control:sym<CONTROL>", " at pos=", rx399_pos)
  debug_737:
    .return (rx399_cur)
  rx399_restart:
.annotate 'line', 10
    if_null rx399_debug, debug_738
    rx399_cur."!cursor_debug"("NEXT", "statement_control:sym<CONTROL>")
  debug_738:
  rx399_fail:
    (rx399_rep, rx399_pos, $I10, $P10) = rx399_cur."!mark_fail"(0)
    lt rx399_pos, -1, rx399_done
    eq rx399_pos, -1, rx399_fail
    jump $I10
  rx399_done:
    rx399_cur."!cursor_fail"()
    if_null rx399_debug, debug_739
    rx399_cur."!cursor_debug"("FAIL", "statement_control:sym<CONTROL>")
  debug_739:
    .return (rx399_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CONTROL>"  :nsentry("!PREFIX__statement_control:sym<CONTROL>") :subid("81_1300062003.824") :method
.annotate 'line', 10
    new $P401, "ResizablePMCArray"
    push $P401, "CONTROL"
    .return ($P401)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix"  :subid("82_1300062003.824")
    .param pmc param_407
.annotate 'line', 240
    .lex "self", param_407
    $P408 = param_407."!protoregex"("statement_prefix")
    .return ($P408)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix"  :subid("83_1300062003.824")
    .param pmc param_410
.annotate 'line', 240
    .lex "self", param_410
    $P411 = param_410."!PREFIX__!protoregex"("statement_prefix")
    .return ($P411)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<INIT>"  :subid("84_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx413_tgt
    .local int rx413_pos
    .local int rx413_off
    .local int rx413_eos
    .local int rx413_rep
    .local pmc rx413_cur
    .local pmc rx413_debug
    (rx413_cur, rx413_pos, rx413_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx413_cur
    .local pmc match
    .lex "$/", match
    length rx413_eos, rx413_tgt
    gt rx413_pos, rx413_eos, rx413_done
    set rx413_off, 0
    lt rx413_pos, 2, rx413_start
    sub rx413_off, rx413_pos, 1
    substr rx413_tgt, rx413_tgt, rx413_off
  rx413_start:
    eq $I10, 1, rx413_restart
    if_null rx413_debug, debug_740
    rx413_cur."!cursor_debug"("START", "statement_prefix:sym<INIT>")
  debug_740:
    $I10 = self.'from'()
    ne $I10, -1, rxscan417_done
    goto rxscan417_scan
  rxscan417_loop:
    (rx413_pos) = rx413_cur."from"()
    inc rx413_pos
    rx413_cur."!cursor_from"(rx413_pos)
    ge rx413_pos, rx413_eos, rxscan417_done
  rxscan417_scan:
    set_addr $I10, rxscan417_loop
    rx413_cur."!mark_push"(0, rx413_pos, $I10)
  rxscan417_done:
.annotate 'line', 241
  # rx subcapture "sym"
    set_addr $I10, rxcap_418_fail
    rx413_cur."!mark_push"(0, rx413_pos, $I10)
  # rx literal  "INIT"
    add $I11, rx413_pos, 4
    gt $I11, rx413_eos, rx413_fail
    sub $I11, rx413_pos, rx413_off
    substr $S10, rx413_tgt, $I11, 4
    ne $S10, "INIT", rx413_fail
    add rx413_pos, 4
    set_addr $I10, rxcap_418_fail
    ($I12, $I11) = rx413_cur."!mark_peek"($I10)
    rx413_cur."!cursor_pos"($I11)
    ($P10) = rx413_cur."!cursor_start"()
    $P10."!cursor_pass"(rx413_pos, "")
    rx413_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_418_done
  rxcap_418_fail:
    goto rx413_fail
  rxcap_418_done:
  # rx subrule "blorst" subtype=capture negate=
    rx413_cur."!cursor_pos"(rx413_pos)
    $P10 = rx413_cur."blorst"()
    unless $P10, rx413_fail
    rx413_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx413_pos = $P10."pos"()
  # rx pass
    rx413_cur."!cursor_pass"(rx413_pos, "statement_prefix:sym<INIT>")
    if_null rx413_debug, debug_741
    rx413_cur."!cursor_debug"("PASS", "statement_prefix:sym<INIT>", " at pos=", rx413_pos)
  debug_741:
    .return (rx413_cur)
  rx413_restart:
.annotate 'line', 10
    if_null rx413_debug, debug_742
    rx413_cur."!cursor_debug"("NEXT", "statement_prefix:sym<INIT>")
  debug_742:
  rx413_fail:
    (rx413_rep, rx413_pos, $I10, $P10) = rx413_cur."!mark_fail"(0)
    lt rx413_pos, -1, rx413_done
    eq rx413_pos, -1, rx413_fail
    jump $I10
  rx413_done:
    rx413_cur."!cursor_fail"()
    if_null rx413_debug, debug_743
    rx413_cur."!cursor_debug"("FAIL", "statement_prefix:sym<INIT>")
  debug_743:
    .return (rx413_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<INIT>"  :nsentry("!PREFIX__statement_prefix:sym<INIT>") :subid("85_1300062003.824") :method
.annotate 'line', 10
    $P415 = self."!PREFIX__!subrule"("blorst", "INIT")
    new $P416, "ResizablePMCArray"
    push $P416, $P415
    .return ($P416)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<try>"  :subid("86_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx420_tgt
    .local int rx420_pos
    .local int rx420_off
    .local int rx420_eos
    .local int rx420_rep
    .local pmc rx420_cur
    .local pmc rx420_debug
    (rx420_cur, rx420_pos, rx420_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx420_cur
    .local pmc match
    .lex "$/", match
    length rx420_eos, rx420_tgt
    gt rx420_pos, rx420_eos, rx420_done
    set rx420_off, 0
    lt rx420_pos, 2, rx420_start
    sub rx420_off, rx420_pos, 1
    substr rx420_tgt, rx420_tgt, rx420_off
  rx420_start:
    eq $I10, 1, rx420_restart
    if_null rx420_debug, debug_744
    rx420_cur."!cursor_debug"("START", "statement_prefix:sym<try>")
  debug_744:
    $I10 = self.'from'()
    ne $I10, -1, rxscan424_done
    goto rxscan424_scan
  rxscan424_loop:
    (rx420_pos) = rx420_cur."from"()
    inc rx420_pos
    rx420_cur."!cursor_from"(rx420_pos)
    ge rx420_pos, rx420_eos, rxscan424_done
  rxscan424_scan:
    set_addr $I10, rxscan424_loop
    rx420_cur."!mark_push"(0, rx420_pos, $I10)
  rxscan424_done:
.annotate 'line', 244
  # rx subcapture "sym"
    set_addr $I10, rxcap_425_fail
    rx420_cur."!mark_push"(0, rx420_pos, $I10)
  # rx literal  "try"
    add $I11, rx420_pos, 3
    gt $I11, rx420_eos, rx420_fail
    sub $I11, rx420_pos, rx420_off
    substr $S10, rx420_tgt, $I11, 3
    ne $S10, "try", rx420_fail
    add rx420_pos, 3
    set_addr $I10, rxcap_425_fail
    ($I12, $I11) = rx420_cur."!mark_peek"($I10)
    rx420_cur."!cursor_pos"($I11)
    ($P10) = rx420_cur."!cursor_start"()
    $P10."!cursor_pass"(rx420_pos, "")
    rx420_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_425_done
  rxcap_425_fail:
    goto rx420_fail
  rxcap_425_done:
.annotate 'line', 245
  # rx subrule "blorst" subtype=capture negate=
    rx420_cur."!cursor_pos"(rx420_pos)
    $P10 = rx420_cur."blorst"()
    unless $P10, rx420_fail
    rx420_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx420_pos = $P10."pos"()
.annotate 'line', 243
  # rx pass
    rx420_cur."!cursor_pass"(rx420_pos, "statement_prefix:sym<try>")
    if_null rx420_debug, debug_745
    rx420_cur."!cursor_debug"("PASS", "statement_prefix:sym<try>", " at pos=", rx420_pos)
  debug_745:
    .return (rx420_cur)
  rx420_restart:
.annotate 'line', 10
    if_null rx420_debug, debug_746
    rx420_cur."!cursor_debug"("NEXT", "statement_prefix:sym<try>")
  debug_746:
  rx420_fail:
    (rx420_rep, rx420_pos, $I10, $P10) = rx420_cur."!mark_fail"(0)
    lt rx420_pos, -1, rx420_done
    eq rx420_pos, -1, rx420_fail
    jump $I10
  rx420_done:
    rx420_cur."!cursor_fail"()
    if_null rx420_debug, debug_747
    rx420_cur."!cursor_debug"("FAIL", "statement_prefix:sym<try>")
  debug_747:
    .return (rx420_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<try>"  :nsentry("!PREFIX__statement_prefix:sym<try>") :subid("87_1300062003.824") :method
.annotate 'line', 10
    $P422 = self."!PREFIX__!subrule"("blorst", "try")
    new $P423, "ResizablePMCArray"
    push $P423, $P422
    .return ($P423)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blorst"  :subid("88_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx427_tgt
    .local int rx427_pos
    .local int rx427_off
    .local int rx427_eos
    .local int rx427_rep
    .local pmc rx427_cur
    .local pmc rx427_debug
    (rx427_cur, rx427_pos, rx427_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx427_cur
    .local pmc match
    .lex "$/", match
    length rx427_eos, rx427_tgt
    gt rx427_pos, rx427_eos, rx427_done
    set rx427_off, 0
    lt rx427_pos, 2, rx427_start
    sub rx427_off, rx427_pos, 1
    substr rx427_tgt, rx427_tgt, rx427_off
  rx427_start:
    eq $I10, 1, rx427_restart
    if_null rx427_debug, debug_748
    rx427_cur."!cursor_debug"("START", "blorst")
  debug_748:
    $I10 = self.'from'()
    ne $I10, -1, rxscan430_done
    goto rxscan430_scan
  rxscan430_loop:
    (rx427_pos) = rx427_cur."from"()
    inc rx427_pos
    rx427_cur."!cursor_from"(rx427_pos)
    ge rx427_pos, rx427_eos, rxscan430_done
  rxscan430_scan:
    set_addr $I10, rxscan430_loop
    rx427_cur."!mark_push"(0, rx427_pos, $I10)
  rxscan430_done:
.annotate 'line', 249
  # rx charclass s
    ge rx427_pos, rx427_eos, rx427_fail
    sub $I10, rx427_pos, rx427_off
    is_cclass $I11, 32, rx427_tgt, $I10
    unless $I11, rx427_fail
    inc rx427_pos
  # rx subrule "ws" subtype=method negate=
    rx427_cur."!cursor_pos"(rx427_pos)
    $P10 = rx427_cur."ws"()
    unless $P10, rx427_fail
    rx427_pos = $P10."pos"()
  alt431_0:
    set_addr $I10, alt431_1
    rx427_cur."!mark_push"(0, rx427_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx427_pos, rx427_off
    substr $S10, rx427_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx427_fail
  # rx subrule "block" subtype=capture negate=
    rx427_cur."!cursor_pos"(rx427_pos)
    $P10 = rx427_cur."block"()
    unless $P10, rx427_fail
    rx427_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx427_pos = $P10."pos"()
    goto alt431_end
  alt431_1:
  # rx subrule "statement" subtype=capture negate=
    rx427_cur."!cursor_pos"(rx427_pos)
    $P10 = rx427_cur."statement"()
    unless $P10, rx427_fail
    rx427_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx427_pos = $P10."pos"()
  alt431_end:
.annotate 'line', 248
  # rx pass
    rx427_cur."!cursor_pass"(rx427_pos, "blorst")
    if_null rx427_debug, debug_749
    rx427_cur."!cursor_debug"("PASS", "blorst", " at pos=", rx427_pos)
  debug_749:
    .return (rx427_cur)
  rx427_restart:
.annotate 'line', 10
    if_null rx427_debug, debug_750
    rx427_cur."!cursor_debug"("NEXT", "blorst")
  debug_750:
  rx427_fail:
    (rx427_rep, rx427_pos, $I10, $P10) = rx427_cur."!mark_fail"(0)
    lt rx427_pos, -1, rx427_done
    eq rx427_pos, -1, rx427_fail
    jump $I10
  rx427_done:
    rx427_cur."!cursor_fail"()
    if_null rx427_debug, debug_751
    rx427_cur."!cursor_debug"("FAIL", "blorst")
  debug_751:
    .return (rx427_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blorst"  :nsentry("!PREFIX__blorst") :subid("89_1300062003.824") :method
.annotate 'line', 10
    new $P429, "ResizablePMCArray"
    push $P429, ""
    .return ($P429)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond"  :subid("90_1300062003.824")
    .param pmc param_433
.annotate 'line', 254
    .lex "self", param_433
    $P434 = param_433."!protoregex"("statement_mod_cond")
    .return ($P434)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond"  :subid("91_1300062003.824")
    .param pmc param_436
.annotate 'line', 254
    .lex "self", param_436
    $P437 = param_436."!PREFIX__!protoregex"("statement_mod_cond")
    .return ($P437)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<if>"  :subid("92_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx439_tgt
    .local int rx439_pos
    .local int rx439_off
    .local int rx439_eos
    .local int rx439_rep
    .local pmc rx439_cur
    .local pmc rx439_debug
    (rx439_cur, rx439_pos, rx439_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx439_cur
    .local pmc match
    .lex "$/", match
    length rx439_eos, rx439_tgt
    gt rx439_pos, rx439_eos, rx439_done
    set rx439_off, 0
    lt rx439_pos, 2, rx439_start
    sub rx439_off, rx439_pos, 1
    substr rx439_tgt, rx439_tgt, rx439_off
  rx439_start:
    eq $I10, 1, rx439_restart
    if_null rx439_debug, debug_752
    rx439_cur."!cursor_debug"("START", "statement_mod_cond:sym<if>")
  debug_752:
    $I10 = self.'from'()
    ne $I10, -1, rxscan443_done
    goto rxscan443_scan
  rxscan443_loop:
    (rx439_pos) = rx439_cur."from"()
    inc rx439_pos
    rx439_cur."!cursor_from"(rx439_pos)
    ge rx439_pos, rx439_eos, rxscan443_done
  rxscan443_scan:
    set_addr $I10, rxscan443_loop
    rx439_cur."!mark_push"(0, rx439_pos, $I10)
  rxscan443_done:
.annotate 'line', 256
  # rx subcapture "sym"
    set_addr $I10, rxcap_444_fail
    rx439_cur."!mark_push"(0, rx439_pos, $I10)
  # rx literal  "if"
    add $I11, rx439_pos, 2
    gt $I11, rx439_eos, rx439_fail
    sub $I11, rx439_pos, rx439_off
    substr $S10, rx439_tgt, $I11, 2
    ne $S10, "if", rx439_fail
    add rx439_pos, 2
    set_addr $I10, rxcap_444_fail
    ($I12, $I11) = rx439_cur."!mark_peek"($I10)
    rx439_cur."!cursor_pos"($I11)
    ($P10) = rx439_cur."!cursor_start"()
    $P10."!cursor_pass"(rx439_pos, "")
    rx439_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_444_done
  rxcap_444_fail:
    goto rx439_fail
  rxcap_444_done:
  # rx subrule "ws" subtype=method negate=
    rx439_cur."!cursor_pos"(rx439_pos)
    $P10 = rx439_cur."ws"()
    unless $P10, rx439_fail
    rx439_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx439_cur."!cursor_pos"(rx439_pos)
    $P10 = rx439_cur."EXPR"()
    unless $P10, rx439_fail
    rx439_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx439_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx439_cur."!cursor_pos"(rx439_pos)
    $P10 = rx439_cur."ws"()
    unless $P10, rx439_fail
    rx439_pos = $P10."pos"()
  # rx pass
    rx439_cur."!cursor_pass"(rx439_pos, "statement_mod_cond:sym<if>")
    if_null rx439_debug, debug_753
    rx439_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<if>", " at pos=", rx439_pos)
  debug_753:
    .return (rx439_cur)
  rx439_restart:
.annotate 'line', 10
    if_null rx439_debug, debug_754
    rx439_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<if>")
  debug_754:
  rx439_fail:
    (rx439_rep, rx439_pos, $I10, $P10) = rx439_cur."!mark_fail"(0)
    lt rx439_pos, -1, rx439_done
    eq rx439_pos, -1, rx439_fail
    jump $I10
  rx439_done:
    rx439_cur."!cursor_fail"()
    if_null rx439_debug, debug_755
    rx439_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<if>")
  debug_755:
    .return (rx439_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<if>"  :nsentry("!PREFIX__statement_mod_cond:sym<if>") :subid("93_1300062003.824") :method
.annotate 'line', 10
    $P441 = self."!PREFIX__!subrule"("ws", "if")
    new $P442, "ResizablePMCArray"
    push $P442, $P441
    .return ($P442)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<unless>"  :subid("94_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx448_tgt
    .local int rx448_pos
    .local int rx448_off
    .local int rx448_eos
    .local int rx448_rep
    .local pmc rx448_cur
    .local pmc rx448_debug
    (rx448_cur, rx448_pos, rx448_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx448_cur
    .local pmc match
    .lex "$/", match
    length rx448_eos, rx448_tgt
    gt rx448_pos, rx448_eos, rx448_done
    set rx448_off, 0
    lt rx448_pos, 2, rx448_start
    sub rx448_off, rx448_pos, 1
    substr rx448_tgt, rx448_tgt, rx448_off
  rx448_start:
    eq $I10, 1, rx448_restart
    if_null rx448_debug, debug_756
    rx448_cur."!cursor_debug"("START", "statement_mod_cond:sym<unless>")
  debug_756:
    $I10 = self.'from'()
    ne $I10, -1, rxscan452_done
    goto rxscan452_scan
  rxscan452_loop:
    (rx448_pos) = rx448_cur."from"()
    inc rx448_pos
    rx448_cur."!cursor_from"(rx448_pos)
    ge rx448_pos, rx448_eos, rxscan452_done
  rxscan452_scan:
    set_addr $I10, rxscan452_loop
    rx448_cur."!mark_push"(0, rx448_pos, $I10)
  rxscan452_done:
.annotate 'line', 257
  # rx subcapture "sym"
    set_addr $I10, rxcap_453_fail
    rx448_cur."!mark_push"(0, rx448_pos, $I10)
  # rx literal  "unless"
    add $I11, rx448_pos, 6
    gt $I11, rx448_eos, rx448_fail
    sub $I11, rx448_pos, rx448_off
    substr $S10, rx448_tgt, $I11, 6
    ne $S10, "unless", rx448_fail
    add rx448_pos, 6
    set_addr $I10, rxcap_453_fail
    ($I12, $I11) = rx448_cur."!mark_peek"($I10)
    rx448_cur."!cursor_pos"($I11)
    ($P10) = rx448_cur."!cursor_start"()
    $P10."!cursor_pass"(rx448_pos, "")
    rx448_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_453_done
  rxcap_453_fail:
    goto rx448_fail
  rxcap_453_done:
  # rx subrule "ws" subtype=method negate=
    rx448_cur."!cursor_pos"(rx448_pos)
    $P10 = rx448_cur."ws"()
    unless $P10, rx448_fail
    rx448_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx448_cur."!cursor_pos"(rx448_pos)
    $P10 = rx448_cur."EXPR"()
    unless $P10, rx448_fail
    rx448_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx448_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx448_cur."!cursor_pos"(rx448_pos)
    $P10 = rx448_cur."ws"()
    unless $P10, rx448_fail
    rx448_pos = $P10."pos"()
  # rx pass
    rx448_cur."!cursor_pass"(rx448_pos, "statement_mod_cond:sym<unless>")
    if_null rx448_debug, debug_757
    rx448_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<unless>", " at pos=", rx448_pos)
  debug_757:
    .return (rx448_cur)
  rx448_restart:
.annotate 'line', 10
    if_null rx448_debug, debug_758
    rx448_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<unless>")
  debug_758:
  rx448_fail:
    (rx448_rep, rx448_pos, $I10, $P10) = rx448_cur."!mark_fail"(0)
    lt rx448_pos, -1, rx448_done
    eq rx448_pos, -1, rx448_fail
    jump $I10
  rx448_done:
    rx448_cur."!cursor_fail"()
    if_null rx448_debug, debug_759
    rx448_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<unless>")
  debug_759:
    .return (rx448_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<unless>"  :nsentry("!PREFIX__statement_mod_cond:sym<unless>") :subid("95_1300062003.824") :method
.annotate 'line', 10
    $P450 = self."!PREFIX__!subrule"("ws", "unless")
    new $P451, "ResizablePMCArray"
    push $P451, $P450
    .return ($P451)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop"  :subid("96_1300062003.824")
    .param pmc param_457
.annotate 'line', 259
    .lex "self", param_457
    $P458 = param_457."!protoregex"("statement_mod_loop")
    .return ($P458)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop"  :subid("97_1300062003.824")
    .param pmc param_460
.annotate 'line', 259
    .lex "self", param_460
    $P461 = param_460."!PREFIX__!protoregex"("statement_mod_loop")
    .return ($P461)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<while>"  :subid("98_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx463_tgt
    .local int rx463_pos
    .local int rx463_off
    .local int rx463_eos
    .local int rx463_rep
    .local pmc rx463_cur
    .local pmc rx463_debug
    (rx463_cur, rx463_pos, rx463_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx463_cur
    .local pmc match
    .lex "$/", match
    length rx463_eos, rx463_tgt
    gt rx463_pos, rx463_eos, rx463_done
    set rx463_off, 0
    lt rx463_pos, 2, rx463_start
    sub rx463_off, rx463_pos, 1
    substr rx463_tgt, rx463_tgt, rx463_off
  rx463_start:
    eq $I10, 1, rx463_restart
    if_null rx463_debug, debug_760
    rx463_cur."!cursor_debug"("START", "statement_mod_loop:sym<while>")
  debug_760:
    $I10 = self.'from'()
    ne $I10, -1, rxscan467_done
    goto rxscan467_scan
  rxscan467_loop:
    (rx463_pos) = rx463_cur."from"()
    inc rx463_pos
    rx463_cur."!cursor_from"(rx463_pos)
    ge rx463_pos, rx463_eos, rxscan467_done
  rxscan467_scan:
    set_addr $I10, rxscan467_loop
    rx463_cur."!mark_push"(0, rx463_pos, $I10)
  rxscan467_done:
.annotate 'line', 261
  # rx subcapture "sym"
    set_addr $I10, rxcap_468_fail
    rx463_cur."!mark_push"(0, rx463_pos, $I10)
  # rx literal  "while"
    add $I11, rx463_pos, 5
    gt $I11, rx463_eos, rx463_fail
    sub $I11, rx463_pos, rx463_off
    substr $S10, rx463_tgt, $I11, 5
    ne $S10, "while", rx463_fail
    add rx463_pos, 5
    set_addr $I10, rxcap_468_fail
    ($I12, $I11) = rx463_cur."!mark_peek"($I10)
    rx463_cur."!cursor_pos"($I11)
    ($P10) = rx463_cur."!cursor_start"()
    $P10."!cursor_pass"(rx463_pos, "")
    rx463_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_468_done
  rxcap_468_fail:
    goto rx463_fail
  rxcap_468_done:
  # rx subrule "ws" subtype=method negate=
    rx463_cur."!cursor_pos"(rx463_pos)
    $P10 = rx463_cur."ws"()
    unless $P10, rx463_fail
    rx463_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx463_cur."!cursor_pos"(rx463_pos)
    $P10 = rx463_cur."EXPR"()
    unless $P10, rx463_fail
    rx463_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx463_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx463_cur."!cursor_pos"(rx463_pos)
    $P10 = rx463_cur."ws"()
    unless $P10, rx463_fail
    rx463_pos = $P10."pos"()
  # rx pass
    rx463_cur."!cursor_pass"(rx463_pos, "statement_mod_loop:sym<while>")
    if_null rx463_debug, debug_761
    rx463_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<while>", " at pos=", rx463_pos)
  debug_761:
    .return (rx463_cur)
  rx463_restart:
.annotate 'line', 10
    if_null rx463_debug, debug_762
    rx463_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<while>")
  debug_762:
  rx463_fail:
    (rx463_rep, rx463_pos, $I10, $P10) = rx463_cur."!mark_fail"(0)
    lt rx463_pos, -1, rx463_done
    eq rx463_pos, -1, rx463_fail
    jump $I10
  rx463_done:
    rx463_cur."!cursor_fail"()
    if_null rx463_debug, debug_763
    rx463_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<while>")
  debug_763:
    .return (rx463_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<while>"  :nsentry("!PREFIX__statement_mod_loop:sym<while>") :subid("99_1300062003.824") :method
.annotate 'line', 10
    $P465 = self."!PREFIX__!subrule"("ws", "while")
    new $P466, "ResizablePMCArray"
    push $P466, $P465
    .return ($P466)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<until>"  :subid("100_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx472_tgt
    .local int rx472_pos
    .local int rx472_off
    .local int rx472_eos
    .local int rx472_rep
    .local pmc rx472_cur
    .local pmc rx472_debug
    (rx472_cur, rx472_pos, rx472_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx472_cur
    .local pmc match
    .lex "$/", match
    length rx472_eos, rx472_tgt
    gt rx472_pos, rx472_eos, rx472_done
    set rx472_off, 0
    lt rx472_pos, 2, rx472_start
    sub rx472_off, rx472_pos, 1
    substr rx472_tgt, rx472_tgt, rx472_off
  rx472_start:
    eq $I10, 1, rx472_restart
    if_null rx472_debug, debug_764
    rx472_cur."!cursor_debug"("START", "statement_mod_loop:sym<until>")
  debug_764:
    $I10 = self.'from'()
    ne $I10, -1, rxscan476_done
    goto rxscan476_scan
  rxscan476_loop:
    (rx472_pos) = rx472_cur."from"()
    inc rx472_pos
    rx472_cur."!cursor_from"(rx472_pos)
    ge rx472_pos, rx472_eos, rxscan476_done
  rxscan476_scan:
    set_addr $I10, rxscan476_loop
    rx472_cur."!mark_push"(0, rx472_pos, $I10)
  rxscan476_done:
.annotate 'line', 262
  # rx subcapture "sym"
    set_addr $I10, rxcap_477_fail
    rx472_cur."!mark_push"(0, rx472_pos, $I10)
  # rx literal  "until"
    add $I11, rx472_pos, 5
    gt $I11, rx472_eos, rx472_fail
    sub $I11, rx472_pos, rx472_off
    substr $S10, rx472_tgt, $I11, 5
    ne $S10, "until", rx472_fail
    add rx472_pos, 5
    set_addr $I10, rxcap_477_fail
    ($I12, $I11) = rx472_cur."!mark_peek"($I10)
    rx472_cur."!cursor_pos"($I11)
    ($P10) = rx472_cur."!cursor_start"()
    $P10."!cursor_pass"(rx472_pos, "")
    rx472_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_477_done
  rxcap_477_fail:
    goto rx472_fail
  rxcap_477_done:
  # rx subrule "ws" subtype=method negate=
    rx472_cur."!cursor_pos"(rx472_pos)
    $P10 = rx472_cur."ws"()
    unless $P10, rx472_fail
    rx472_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx472_cur."!cursor_pos"(rx472_pos)
    $P10 = rx472_cur."EXPR"()
    unless $P10, rx472_fail
    rx472_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx472_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx472_cur."!cursor_pos"(rx472_pos)
    $P10 = rx472_cur."ws"()
    unless $P10, rx472_fail
    rx472_pos = $P10."pos"()
  # rx pass
    rx472_cur."!cursor_pass"(rx472_pos, "statement_mod_loop:sym<until>")
    if_null rx472_debug, debug_765
    rx472_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<until>", " at pos=", rx472_pos)
  debug_765:
    .return (rx472_cur)
  rx472_restart:
.annotate 'line', 10
    if_null rx472_debug, debug_766
    rx472_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<until>")
  debug_766:
  rx472_fail:
    (rx472_rep, rx472_pos, $I10, $P10) = rx472_cur."!mark_fail"(0)
    lt rx472_pos, -1, rx472_done
    eq rx472_pos, -1, rx472_fail
    jump $I10
  rx472_done:
    rx472_cur."!cursor_fail"()
    if_null rx472_debug, debug_767
    rx472_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<until>")
  debug_767:
    .return (rx472_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<until>"  :nsentry("!PREFIX__statement_mod_loop:sym<until>") :subid("101_1300062003.824") :method
.annotate 'line', 10
    $P474 = self."!PREFIX__!subrule"("ws", "until")
    new $P475, "ResizablePMCArray"
    push $P475, $P474
    .return ($P475)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<for>"  :subid("102_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx481_tgt
    .local int rx481_pos
    .local int rx481_off
    .local int rx481_eos
    .local int rx481_rep
    .local pmc rx481_cur
    .local pmc rx481_debug
    (rx481_cur, rx481_pos, rx481_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx481_cur
    .local pmc match
    .lex "$/", match
    length rx481_eos, rx481_tgt
    gt rx481_pos, rx481_eos, rx481_done
    set rx481_off, 0
    lt rx481_pos, 2, rx481_start
    sub rx481_off, rx481_pos, 1
    substr rx481_tgt, rx481_tgt, rx481_off
  rx481_start:
    eq $I10, 1, rx481_restart
    if_null rx481_debug, debug_768
    rx481_cur."!cursor_debug"("START", "statement_mod_loop:sym<for>")
  debug_768:
    $I10 = self.'from'()
    ne $I10, -1, rxscan485_done
    goto rxscan485_scan
  rxscan485_loop:
    (rx481_pos) = rx481_cur."from"()
    inc rx481_pos
    rx481_cur."!cursor_from"(rx481_pos)
    ge rx481_pos, rx481_eos, rxscan485_done
  rxscan485_scan:
    set_addr $I10, rxscan485_loop
    rx481_cur."!mark_push"(0, rx481_pos, $I10)
  rxscan485_done:
.annotate 'line', 263
  # rx subcapture "sym"
    set_addr $I10, rxcap_486_fail
    rx481_cur."!mark_push"(0, rx481_pos, $I10)
  # rx literal  "for"
    add $I11, rx481_pos, 3
    gt $I11, rx481_eos, rx481_fail
    sub $I11, rx481_pos, rx481_off
    substr $S10, rx481_tgt, $I11, 3
    ne $S10, "for", rx481_fail
    add rx481_pos, 3
    set_addr $I10, rxcap_486_fail
    ($I12, $I11) = rx481_cur."!mark_peek"($I10)
    rx481_cur."!cursor_pos"($I11)
    ($P10) = rx481_cur."!cursor_start"()
    $P10."!cursor_pass"(rx481_pos, "")
    rx481_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_486_done
  rxcap_486_fail:
    goto rx481_fail
  rxcap_486_done:
  # rx subrule "ws" subtype=method negate=
    rx481_cur."!cursor_pos"(rx481_pos)
    $P10 = rx481_cur."ws"()
    unless $P10, rx481_fail
    rx481_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx481_cur."!cursor_pos"(rx481_pos)
    $P10 = rx481_cur."EXPR"()
    unless $P10, rx481_fail
    rx481_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx481_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx481_cur."!cursor_pos"(rx481_pos)
    $P10 = rx481_cur."ws"()
    unless $P10, rx481_fail
    rx481_pos = $P10."pos"()
  # rx pass
    rx481_cur."!cursor_pass"(rx481_pos, "statement_mod_loop:sym<for>")
    if_null rx481_debug, debug_769
    rx481_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<for>", " at pos=", rx481_pos)
  debug_769:
    .return (rx481_cur)
  rx481_restart:
.annotate 'line', 10
    if_null rx481_debug, debug_770
    rx481_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<for>")
  debug_770:
  rx481_fail:
    (rx481_rep, rx481_pos, $I10, $P10) = rx481_cur."!mark_fail"(0)
    lt rx481_pos, -1, rx481_done
    eq rx481_pos, -1, rx481_fail
    jump $I10
  rx481_done:
    rx481_cur."!cursor_fail"()
    if_null rx481_debug, debug_771
    rx481_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<for>")
  debug_771:
    .return (rx481_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<for>"  :nsentry("!PREFIX__statement_mod_loop:sym<for>") :subid("103_1300062003.824") :method
.annotate 'line', 10
    $P483 = self."!PREFIX__!subrule"("ws", "for")
    new $P484, "ResizablePMCArray"
    push $P484, $P483
    .return ($P484)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<fatarrow>"  :subid("104_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx490_tgt
    .local int rx490_pos
    .local int rx490_off
    .local int rx490_eos
    .local int rx490_rep
    .local pmc rx490_cur
    .local pmc rx490_debug
    (rx490_cur, rx490_pos, rx490_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx490_cur
    .local pmc match
    .lex "$/", match
    length rx490_eos, rx490_tgt
    gt rx490_pos, rx490_eos, rx490_done
    set rx490_off, 0
    lt rx490_pos, 2, rx490_start
    sub rx490_off, rx490_pos, 1
    substr rx490_tgt, rx490_tgt, rx490_off
  rx490_start:
    eq $I10, 1, rx490_restart
    if_null rx490_debug, debug_772
    rx490_cur."!cursor_debug"("START", "term:sym<fatarrow>")
  debug_772:
    $I10 = self.'from'()
    ne $I10, -1, rxscan494_done
    goto rxscan494_scan
  rxscan494_loop:
    (rx490_pos) = rx490_cur."from"()
    inc rx490_pos
    rx490_cur."!cursor_from"(rx490_pos)
    ge rx490_pos, rx490_eos, rxscan494_done
  rxscan494_scan:
    set_addr $I10, rxscan494_loop
    rx490_cur."!mark_push"(0, rx490_pos, $I10)
  rxscan494_done:
.annotate 'line', 267
  # rx subrule "fatarrow" subtype=capture negate=
    rx490_cur."!cursor_pos"(rx490_pos)
    $P10 = rx490_cur."fatarrow"()
    unless $P10, rx490_fail
    rx490_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("fatarrow")
    rx490_pos = $P10."pos"()
  # rx pass
    rx490_cur."!cursor_pass"(rx490_pos, "term:sym<fatarrow>")
    if_null rx490_debug, debug_773
    rx490_cur."!cursor_debug"("PASS", "term:sym<fatarrow>", " at pos=", rx490_pos)
  debug_773:
    .return (rx490_cur)
  rx490_restart:
.annotate 'line', 10
    if_null rx490_debug, debug_774
    rx490_cur."!cursor_debug"("NEXT", "term:sym<fatarrow>")
  debug_774:
  rx490_fail:
    (rx490_rep, rx490_pos, $I10, $P10) = rx490_cur."!mark_fail"(0)
    lt rx490_pos, -1, rx490_done
    eq rx490_pos, -1, rx490_fail
    jump $I10
  rx490_done:
    rx490_cur."!cursor_fail"()
    if_null rx490_debug, debug_775
    rx490_cur."!cursor_debug"("FAIL", "term:sym<fatarrow>")
  debug_775:
    .return (rx490_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<fatarrow>"  :nsentry("!PREFIX__term:sym<fatarrow>") :subid("105_1300062003.824") :method
.annotate 'line', 10
    $P492 = self."!PREFIX__!subrule"("fatarrow", "")
    new $P493, "ResizablePMCArray"
    push $P493, $P492
    .return ($P493)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<colonpair>"  :subid("106_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx496_tgt
    .local int rx496_pos
    .local int rx496_off
    .local int rx496_eos
    .local int rx496_rep
    .local pmc rx496_cur
    .local pmc rx496_debug
    (rx496_cur, rx496_pos, rx496_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx496_cur
    .local pmc match
    .lex "$/", match
    length rx496_eos, rx496_tgt
    gt rx496_pos, rx496_eos, rx496_done
    set rx496_off, 0
    lt rx496_pos, 2, rx496_start
    sub rx496_off, rx496_pos, 1
    substr rx496_tgt, rx496_tgt, rx496_off
  rx496_start:
    eq $I10, 1, rx496_restart
    if_null rx496_debug, debug_776
    rx496_cur."!cursor_debug"("START", "term:sym<colonpair>")
  debug_776:
    $I10 = self.'from'()
    ne $I10, -1, rxscan500_done
    goto rxscan500_scan
  rxscan500_loop:
    (rx496_pos) = rx496_cur."from"()
    inc rx496_pos
    rx496_cur."!cursor_from"(rx496_pos)
    ge rx496_pos, rx496_eos, rxscan500_done
  rxscan500_scan:
    set_addr $I10, rxscan500_loop
    rx496_cur."!mark_push"(0, rx496_pos, $I10)
  rxscan500_done:
.annotate 'line', 268
  # rx subrule "colonpair" subtype=capture negate=
    rx496_cur."!cursor_pos"(rx496_pos)
    $P10 = rx496_cur."colonpair"()
    unless $P10, rx496_fail
    rx496_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("colonpair")
    rx496_pos = $P10."pos"()
  # rx pass
    rx496_cur."!cursor_pass"(rx496_pos, "term:sym<colonpair>")
    if_null rx496_debug, debug_777
    rx496_cur."!cursor_debug"("PASS", "term:sym<colonpair>", " at pos=", rx496_pos)
  debug_777:
    .return (rx496_cur)
  rx496_restart:
.annotate 'line', 10
    if_null rx496_debug, debug_778
    rx496_cur."!cursor_debug"("NEXT", "term:sym<colonpair>")
  debug_778:
  rx496_fail:
    (rx496_rep, rx496_pos, $I10, $P10) = rx496_cur."!mark_fail"(0)
    lt rx496_pos, -1, rx496_done
    eq rx496_pos, -1, rx496_fail
    jump $I10
  rx496_done:
    rx496_cur."!cursor_fail"()
    if_null rx496_debug, debug_779
    rx496_cur."!cursor_debug"("FAIL", "term:sym<colonpair>")
  debug_779:
    .return (rx496_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<colonpair>"  :nsentry("!PREFIX__term:sym<colonpair>") :subid("107_1300062003.824") :method
.annotate 'line', 10
    $P498 = self."!PREFIX__!subrule"("colonpair", "")
    new $P499, "ResizablePMCArray"
    push $P499, $P498
    .return ($P499)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<variable>"  :subid("108_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx502_tgt
    .local int rx502_pos
    .local int rx502_off
    .local int rx502_eos
    .local int rx502_rep
    .local pmc rx502_cur
    .local pmc rx502_debug
    (rx502_cur, rx502_pos, rx502_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx502_cur
    .local pmc match
    .lex "$/", match
    length rx502_eos, rx502_tgt
    gt rx502_pos, rx502_eos, rx502_done
    set rx502_off, 0
    lt rx502_pos, 2, rx502_start
    sub rx502_off, rx502_pos, 1
    substr rx502_tgt, rx502_tgt, rx502_off
  rx502_start:
    eq $I10, 1, rx502_restart
    if_null rx502_debug, debug_780
    rx502_cur."!cursor_debug"("START", "term:sym<variable>")
  debug_780:
    $I10 = self.'from'()
    ne $I10, -1, rxscan506_done
    goto rxscan506_scan
  rxscan506_loop:
    (rx502_pos) = rx502_cur."from"()
    inc rx502_pos
    rx502_cur."!cursor_from"(rx502_pos)
    ge rx502_pos, rx502_eos, rxscan506_done
  rxscan506_scan:
    set_addr $I10, rxscan506_loop
    rx502_cur."!mark_push"(0, rx502_pos, $I10)
  rxscan506_done:
.annotate 'line', 269
  # rx subrule "variable" subtype=capture negate=
    rx502_cur."!cursor_pos"(rx502_pos)
    $P10 = rx502_cur."variable"()
    unless $P10, rx502_fail
    rx502_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx502_pos = $P10."pos"()
  # rx pass
    rx502_cur."!cursor_pass"(rx502_pos, "term:sym<variable>")
    if_null rx502_debug, debug_781
    rx502_cur."!cursor_debug"("PASS", "term:sym<variable>", " at pos=", rx502_pos)
  debug_781:
    .return (rx502_cur)
  rx502_restart:
.annotate 'line', 10
    if_null rx502_debug, debug_782
    rx502_cur."!cursor_debug"("NEXT", "term:sym<variable>")
  debug_782:
  rx502_fail:
    (rx502_rep, rx502_pos, $I10, $P10) = rx502_cur."!mark_fail"(0)
    lt rx502_pos, -1, rx502_done
    eq rx502_pos, -1, rx502_fail
    jump $I10
  rx502_done:
    rx502_cur."!cursor_fail"()
    if_null rx502_debug, debug_783
    rx502_cur."!cursor_debug"("FAIL", "term:sym<variable>")
  debug_783:
    .return (rx502_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<variable>"  :nsentry("!PREFIX__term:sym<variable>") :subid("109_1300062003.824") :method
.annotate 'line', 10
    $P504 = self."!PREFIX__!subrule"("variable", "")
    new $P505, "ResizablePMCArray"
    push $P505, $P504
    .return ($P505)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<package_declarator>"  :subid("110_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx508_tgt
    .local int rx508_pos
    .local int rx508_off
    .local int rx508_eos
    .local int rx508_rep
    .local pmc rx508_cur
    .local pmc rx508_debug
    (rx508_cur, rx508_pos, rx508_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx508_cur
    .local pmc match
    .lex "$/", match
    length rx508_eos, rx508_tgt
    gt rx508_pos, rx508_eos, rx508_done
    set rx508_off, 0
    lt rx508_pos, 2, rx508_start
    sub rx508_off, rx508_pos, 1
    substr rx508_tgt, rx508_tgt, rx508_off
  rx508_start:
    eq $I10, 1, rx508_restart
    if_null rx508_debug, debug_784
    rx508_cur."!cursor_debug"("START", "term:sym<package_declarator>")
  debug_784:
    $I10 = self.'from'()
    ne $I10, -1, rxscan512_done
    goto rxscan512_scan
  rxscan512_loop:
    (rx508_pos) = rx508_cur."from"()
    inc rx508_pos
    rx508_cur."!cursor_from"(rx508_pos)
    ge rx508_pos, rx508_eos, rxscan512_done
  rxscan512_scan:
    set_addr $I10, rxscan512_loop
    rx508_cur."!mark_push"(0, rx508_pos, $I10)
  rxscan512_done:
.annotate 'line', 270
  # rx subrule "package_declarator" subtype=capture negate=
    rx508_cur."!cursor_pos"(rx508_pos)
    $P10 = rx508_cur."package_declarator"()
    unless $P10, rx508_fail
    rx508_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx508_pos = $P10."pos"()
  # rx pass
    rx508_cur."!cursor_pass"(rx508_pos, "term:sym<package_declarator>")
    if_null rx508_debug, debug_785
    rx508_cur."!cursor_debug"("PASS", "term:sym<package_declarator>", " at pos=", rx508_pos)
  debug_785:
    .return (rx508_cur)
  rx508_restart:
.annotate 'line', 10
    if_null rx508_debug, debug_786
    rx508_cur."!cursor_debug"("NEXT", "term:sym<package_declarator>")
  debug_786:
  rx508_fail:
    (rx508_rep, rx508_pos, $I10, $P10) = rx508_cur."!mark_fail"(0)
    lt rx508_pos, -1, rx508_done
    eq rx508_pos, -1, rx508_fail
    jump $I10
  rx508_done:
    rx508_cur."!cursor_fail"()
    if_null rx508_debug, debug_787
    rx508_cur."!cursor_debug"("FAIL", "term:sym<package_declarator>")
  debug_787:
    .return (rx508_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<package_declarator>"  :nsentry("!PREFIX__term:sym<package_declarator>") :subid("111_1300062003.824") :method
.annotate 'line', 10
    $P510 = self."!PREFIX__!subrule"("package_declarator", "")
    new $P511, "ResizablePMCArray"
    push $P511, $P510
    .return ($P511)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<scope_declarator>"  :subid("112_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx514_tgt
    .local int rx514_pos
    .local int rx514_off
    .local int rx514_eos
    .local int rx514_rep
    .local pmc rx514_cur
    .local pmc rx514_debug
    (rx514_cur, rx514_pos, rx514_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx514_cur
    .local pmc match
    .lex "$/", match
    length rx514_eos, rx514_tgt
    gt rx514_pos, rx514_eos, rx514_done
    set rx514_off, 0
    lt rx514_pos, 2, rx514_start
    sub rx514_off, rx514_pos, 1
    substr rx514_tgt, rx514_tgt, rx514_off
  rx514_start:
    eq $I10, 1, rx514_restart
    if_null rx514_debug, debug_788
    rx514_cur."!cursor_debug"("START", "term:sym<scope_declarator>")
  debug_788:
    $I10 = self.'from'()
    ne $I10, -1, rxscan518_done
    goto rxscan518_scan
  rxscan518_loop:
    (rx514_pos) = rx514_cur."from"()
    inc rx514_pos
    rx514_cur."!cursor_from"(rx514_pos)
    ge rx514_pos, rx514_eos, rxscan518_done
  rxscan518_scan:
    set_addr $I10, rxscan518_loop
    rx514_cur."!mark_push"(0, rx514_pos, $I10)
  rxscan518_done:
.annotate 'line', 271
  # rx subrule "scope_declarator" subtype=capture negate=
    rx514_cur."!cursor_pos"(rx514_pos)
    $P10 = rx514_cur."scope_declarator"()
    unless $P10, rx514_fail
    rx514_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scope_declarator")
    rx514_pos = $P10."pos"()
  # rx pass
    rx514_cur."!cursor_pass"(rx514_pos, "term:sym<scope_declarator>")
    if_null rx514_debug, debug_789
    rx514_cur."!cursor_debug"("PASS", "term:sym<scope_declarator>", " at pos=", rx514_pos)
  debug_789:
    .return (rx514_cur)
  rx514_restart:
.annotate 'line', 10
    if_null rx514_debug, debug_790
    rx514_cur."!cursor_debug"("NEXT", "term:sym<scope_declarator>")
  debug_790:
  rx514_fail:
    (rx514_rep, rx514_pos, $I10, $P10) = rx514_cur."!mark_fail"(0)
    lt rx514_pos, -1, rx514_done
    eq rx514_pos, -1, rx514_fail
    jump $I10
  rx514_done:
    rx514_cur."!cursor_fail"()
    if_null rx514_debug, debug_791
    rx514_cur."!cursor_debug"("FAIL", "term:sym<scope_declarator>")
  debug_791:
    .return (rx514_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<scope_declarator>"  :nsentry("!PREFIX__term:sym<scope_declarator>") :subid("113_1300062003.824") :method
.annotate 'line', 10
    $P516 = self."!PREFIX__!subrule"("scope_declarator", "")
    new $P517, "ResizablePMCArray"
    push $P517, $P516
    .return ($P517)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<routine_declarator>"  :subid("114_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx520_tgt
    .local int rx520_pos
    .local int rx520_off
    .local int rx520_eos
    .local int rx520_rep
    .local pmc rx520_cur
    .local pmc rx520_debug
    (rx520_cur, rx520_pos, rx520_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx520_cur
    .local pmc match
    .lex "$/", match
    length rx520_eos, rx520_tgt
    gt rx520_pos, rx520_eos, rx520_done
    set rx520_off, 0
    lt rx520_pos, 2, rx520_start
    sub rx520_off, rx520_pos, 1
    substr rx520_tgt, rx520_tgt, rx520_off
  rx520_start:
    eq $I10, 1, rx520_restart
    if_null rx520_debug, debug_792
    rx520_cur."!cursor_debug"("START", "term:sym<routine_declarator>")
  debug_792:
    $I10 = self.'from'()
    ne $I10, -1, rxscan524_done
    goto rxscan524_scan
  rxscan524_loop:
    (rx520_pos) = rx520_cur."from"()
    inc rx520_pos
    rx520_cur."!cursor_from"(rx520_pos)
    ge rx520_pos, rx520_eos, rxscan524_done
  rxscan524_scan:
    set_addr $I10, rxscan524_loop
    rx520_cur."!mark_push"(0, rx520_pos, $I10)
  rxscan524_done:
.annotate 'line', 272
  # rx subrule "routine_declarator" subtype=capture negate=
    rx520_cur."!cursor_pos"(rx520_pos)
    $P10 = rx520_cur."routine_declarator"()
    unless $P10, rx520_fail
    rx520_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx520_pos = $P10."pos"()
  # rx pass
    rx520_cur."!cursor_pass"(rx520_pos, "term:sym<routine_declarator>")
    if_null rx520_debug, debug_793
    rx520_cur."!cursor_debug"("PASS", "term:sym<routine_declarator>", " at pos=", rx520_pos)
  debug_793:
    .return (rx520_cur)
  rx520_restart:
.annotate 'line', 10
    if_null rx520_debug, debug_794
    rx520_cur."!cursor_debug"("NEXT", "term:sym<routine_declarator>")
  debug_794:
  rx520_fail:
    (rx520_rep, rx520_pos, $I10, $P10) = rx520_cur."!mark_fail"(0)
    lt rx520_pos, -1, rx520_done
    eq rx520_pos, -1, rx520_fail
    jump $I10
  rx520_done:
    rx520_cur."!cursor_fail"()
    if_null rx520_debug, debug_795
    rx520_cur."!cursor_debug"("FAIL", "term:sym<routine_declarator>")
  debug_795:
    .return (rx520_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<routine_declarator>"  :nsentry("!PREFIX__term:sym<routine_declarator>") :subid("115_1300062003.824") :method
.annotate 'line', 10
    $P522 = self."!PREFIX__!subrule"("routine_declarator", "")
    new $P523, "ResizablePMCArray"
    push $P523, $P522
    .return ($P523)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<multi_declarator>"  :subid("116_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .const 'Sub' $P536 = "119_1300062003.824" 
    capture_lex $P536
    .const 'Sub' $P531 = "118_1300062003.824" 
    capture_lex $P531
    .local string rx526_tgt
    .local int rx526_pos
    .local int rx526_off
    .local int rx526_eos
    .local int rx526_rep
    .local pmc rx526_cur
    .local pmc rx526_debug
    (rx526_cur, rx526_pos, rx526_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx526_cur
    .local pmc match
    .lex "$/", match
    length rx526_eos, rx526_tgt
    gt rx526_pos, rx526_eos, rx526_done
    set rx526_off, 0
    lt rx526_pos, 2, rx526_start
    sub rx526_off, rx526_pos, 1
    substr rx526_tgt, rx526_tgt, rx526_off
  rx526_start:
    eq $I10, 1, rx526_restart
    if_null rx526_debug, debug_796
    rx526_cur."!cursor_debug"("START", "term:sym<multi_declarator>")
  debug_796:
    $I10 = self.'from'()
    ne $I10, -1, rxscan529_done
    goto rxscan529_scan
  rxscan529_loop:
    (rx526_pos) = rx526_cur."from"()
    inc rx526_pos
    rx526_cur."!cursor_from"(rx526_pos)
    ge rx526_pos, rx526_eos, rxscan529_done
  rxscan529_scan:
    set_addr $I10, rxscan529_loop
    rx526_cur."!mark_push"(0, rx526_pos, $I10)
  rxscan529_done:
.annotate 'line', 274
  # rx subrule "before" subtype=zerowidth negate=
    rx526_cur."!cursor_pos"(rx526_pos)
    .const 'Sub' $P531 = "118_1300062003.824" 
    capture_lex $P531
    $P10 = rx526_cur."before"($P531)
    unless $P10, rx526_fail
.annotate 'line', 275
  # rx subrule "before" subtype=zerowidth negate=1
    rx526_cur."!cursor_pos"(rx526_pos)
    .const 'Sub' $P536 = "119_1300062003.824" 
    capture_lex $P536
    $P10 = rx526_cur."before"($P536)
    if $P10, rx526_fail
.annotate 'line', 276
  # rx subrule "multi_declarator" subtype=capture negate=
    rx526_cur."!cursor_pos"(rx526_pos)
    $P10 = rx526_cur."multi_declarator"()
    unless $P10, rx526_fail
    rx526_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx526_pos = $P10."pos"()
.annotate 'line', 273
  # rx pass
    rx526_cur."!cursor_pass"(rx526_pos, "term:sym<multi_declarator>")
    if_null rx526_debug, debug_805
    rx526_cur."!cursor_debug"("PASS", "term:sym<multi_declarator>", " at pos=", rx526_pos)
  debug_805:
    .return (rx526_cur)
  rx526_restart:
.annotate 'line', 10
    if_null rx526_debug, debug_806
    rx526_cur."!cursor_debug"("NEXT", "term:sym<multi_declarator>")
  debug_806:
  rx526_fail:
    (rx526_rep, rx526_pos, $I10, $P10) = rx526_cur."!mark_fail"(0)
    lt rx526_pos, -1, rx526_done
    eq rx526_pos, -1, rx526_fail
    jump $I10
  rx526_done:
    rx526_cur."!cursor_fail"()
    if_null rx526_debug, debug_807
    rx526_cur."!cursor_debug"("FAIL", "term:sym<multi_declarator>")
  debug_807:
    .return (rx526_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<multi_declarator>"  :nsentry("!PREFIX__term:sym<multi_declarator>") :subid("117_1300062003.824") :method
.annotate 'line', 10
    new $P528, "ResizablePMCArray"
    push $P528, ""
    .return ($P528)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block530"  :anon :subid("118_1300062003.824") :method :outer("116_1300062003.824")
.annotate 'line', 274
    .local string rx532_tgt
    .local int rx532_pos
    .local int rx532_off
    .local int rx532_eos
    .local int rx532_rep
    .local pmc rx532_cur
    .local pmc rx532_debug
    (rx532_cur, rx532_pos, rx532_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx532_cur
    .local pmc match
    .lex "$/", match
    length rx532_eos, rx532_tgt
    gt rx532_pos, rx532_eos, rx532_done
    set rx532_off, 0
    lt rx532_pos, 2, rx532_start
    sub rx532_off, rx532_pos, 1
    substr rx532_tgt, rx532_tgt, rx532_off
  rx532_start:
    eq $I10, 1, rx532_restart
    if_null rx532_debug, debug_797
    rx532_cur."!cursor_debug"("START", "")
  debug_797:
    $I10 = self.'from'()
    ne $I10, -1, rxscan533_done
    goto rxscan533_scan
  rxscan533_loop:
    (rx532_pos) = rx532_cur."from"()
    inc rx532_pos
    rx532_cur."!cursor_from"(rx532_pos)
    ge rx532_pos, rx532_eos, rxscan533_done
  rxscan533_scan:
    set_addr $I10, rxscan533_loop
    rx532_cur."!mark_push"(0, rx532_pos, $I10)
  rxscan533_done:
  alt534_0:
    set_addr $I10, alt534_1
    rx532_cur."!mark_push"(0, rx532_pos, $I10)
  # rx literal  "multi"
    add $I11, rx532_pos, 5
    gt $I11, rx532_eos, rx532_fail
    sub $I11, rx532_pos, rx532_off
    substr $S10, rx532_tgt, $I11, 5
    ne $S10, "multi", rx532_fail
    add rx532_pos, 5
    goto alt534_end
  alt534_1:
    set_addr $I10, alt534_2
    rx532_cur."!mark_push"(0, rx532_pos, $I10)
  # rx literal  "proto"
    add $I11, rx532_pos, 5
    gt $I11, rx532_eos, rx532_fail
    sub $I11, rx532_pos, rx532_off
    substr $S10, rx532_tgt, $I11, 5
    ne $S10, "proto", rx532_fail
    add rx532_pos, 5
    goto alt534_end
  alt534_2:
  # rx literal  "only"
    add $I11, rx532_pos, 4
    gt $I11, rx532_eos, rx532_fail
    sub $I11, rx532_pos, rx532_off
    substr $S10, rx532_tgt, $I11, 4
    ne $S10, "only", rx532_fail
    add rx532_pos, 4
  alt534_end:
  # rx pass
    rx532_cur."!cursor_pass"(rx532_pos, "")
    if_null rx532_debug, debug_798
    rx532_cur."!cursor_debug"("PASS", "", " at pos=", rx532_pos)
  debug_798:
    .return (rx532_cur)
  rx532_restart:
    if_null rx532_debug, debug_799
    rx532_cur."!cursor_debug"("NEXT", "")
  debug_799:
  rx532_fail:
    (rx532_rep, rx532_pos, $I10, $P10) = rx532_cur."!mark_fail"(0)
    lt rx532_pos, -1, rx532_done
    eq rx532_pos, -1, rx532_fail
    jump $I10
  rx532_done:
    rx532_cur."!cursor_fail"()
    if_null rx532_debug, debug_800
    rx532_cur."!cursor_debug"("FAIL", "")
  debug_800:
    .return (rx532_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block535"  :anon :subid("119_1300062003.824") :method :outer("116_1300062003.824")
.annotate 'line', 275
    .local string rx537_tgt
    .local int rx537_pos
    .local int rx537_off
    .local int rx537_eos
    .local int rx537_rep
    .local pmc rx537_cur
    .local pmc rx537_debug
    (rx537_cur, rx537_pos, rx537_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx537_cur
    .local pmc match
    .lex "$/", match
    length rx537_eos, rx537_tgt
    gt rx537_pos, rx537_eos, rx537_done
    set rx537_off, 0
    lt rx537_pos, 2, rx537_start
    sub rx537_off, rx537_pos, 1
    substr rx537_tgt, rx537_tgt, rx537_off
  rx537_start:
    eq $I10, 1, rx537_restart
    if_null rx537_debug, debug_801
    rx537_cur."!cursor_debug"("START", "")
  debug_801:
    $I10 = self.'from'()
    ne $I10, -1, rxscan538_done
    goto rxscan538_scan
  rxscan538_loop:
    (rx537_pos) = rx537_cur."from"()
    inc rx537_pos
    rx537_cur."!cursor_from"(rx537_pos)
    ge rx537_pos, rx537_eos, rxscan538_done
  rxscan538_scan:
    set_addr $I10, rxscan538_loop
    rx537_cur."!mark_push"(0, rx537_pos, $I10)
  rxscan538_done:
  # rx literal  "proto"
    add $I11, rx537_pos, 5
    gt $I11, rx537_eos, rx537_fail
    sub $I11, rx537_pos, rx537_off
    substr $S10, rx537_tgt, $I11, 5
    ne $S10, "proto", rx537_fail
    add rx537_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx537_cur."!cursor_pos"(rx537_pos)
    $P10 = rx537_cur."ws"()
    unless $P10, rx537_fail
    rx537_pos = $P10."pos"()
  alt539_0:
    set_addr $I10, alt539_1
    rx537_cur."!mark_push"(0, rx537_pos, $I10)
  # rx literal  "regex"
    add $I11, rx537_pos, 5
    gt $I11, rx537_eos, rx537_fail
    sub $I11, rx537_pos, rx537_off
    substr $S10, rx537_tgt, $I11, 5
    ne $S10, "regex", rx537_fail
    add rx537_pos, 5
    goto alt539_end
  alt539_1:
    set_addr $I10, alt539_2
    rx537_cur."!mark_push"(0, rx537_pos, $I10)
  # rx literal  "token"
    add $I11, rx537_pos, 5
    gt $I11, rx537_eos, rx537_fail
    sub $I11, rx537_pos, rx537_off
    substr $S10, rx537_tgt, $I11, 5
    ne $S10, "token", rx537_fail
    add rx537_pos, 5
    goto alt539_end
  alt539_2:
  # rx literal  "rule"
    add $I11, rx537_pos, 4
    gt $I11, rx537_eos, rx537_fail
    sub $I11, rx537_pos, rx537_off
    substr $S10, rx537_tgt, $I11, 4
    ne $S10, "rule", rx537_fail
    add rx537_pos, 4
  alt539_end:
  # rx pass
    rx537_cur."!cursor_pass"(rx537_pos, "")
    if_null rx537_debug, debug_802
    rx537_cur."!cursor_debug"("PASS", "", " at pos=", rx537_pos)
  debug_802:
    .return (rx537_cur)
  rx537_restart:
    if_null rx537_debug, debug_803
    rx537_cur."!cursor_debug"("NEXT", "")
  debug_803:
  rx537_fail:
    (rx537_rep, rx537_pos, $I10, $P10) = rx537_cur."!mark_fail"(0)
    lt rx537_pos, -1, rx537_done
    eq rx537_pos, -1, rx537_fail
    jump $I10
  rx537_done:
    rx537_cur."!cursor_fail"()
    if_null rx537_debug, debug_804
    rx537_cur."!cursor_debug"("FAIL", "")
  debug_804:
    .return (rx537_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<regex_declarator>"  :subid("120_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx541_tgt
    .local int rx541_pos
    .local int rx541_off
    .local int rx541_eos
    .local int rx541_rep
    .local pmc rx541_cur
    .local pmc rx541_debug
    (rx541_cur, rx541_pos, rx541_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx541_cur
    .local pmc match
    .lex "$/", match
    length rx541_eos, rx541_tgt
    gt rx541_pos, rx541_eos, rx541_done
    set rx541_off, 0
    lt rx541_pos, 2, rx541_start
    sub rx541_off, rx541_pos, 1
    substr rx541_tgt, rx541_tgt, rx541_off
  rx541_start:
    eq $I10, 1, rx541_restart
    if_null rx541_debug, debug_808
    rx541_cur."!cursor_debug"("START", "term:sym<regex_declarator>")
  debug_808:
    $I10 = self.'from'()
    ne $I10, -1, rxscan545_done
    goto rxscan545_scan
  rxscan545_loop:
    (rx541_pos) = rx541_cur."from"()
    inc rx541_pos
    rx541_cur."!cursor_from"(rx541_pos)
    ge rx541_pos, rx541_eos, rxscan545_done
  rxscan545_scan:
    set_addr $I10, rxscan545_loop
    rx541_cur."!mark_push"(0, rx541_pos, $I10)
  rxscan545_done:
.annotate 'line', 278
  # rx subrule "regex_declarator" subtype=capture negate=
    rx541_cur."!cursor_pos"(rx541_pos)
    $P10 = rx541_cur."regex_declarator"()
    unless $P10, rx541_fail
    rx541_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("regex_declarator")
    rx541_pos = $P10."pos"()
  # rx pass
    rx541_cur."!cursor_pass"(rx541_pos, "term:sym<regex_declarator>")
    if_null rx541_debug, debug_809
    rx541_cur."!cursor_debug"("PASS", "term:sym<regex_declarator>", " at pos=", rx541_pos)
  debug_809:
    .return (rx541_cur)
  rx541_restart:
.annotate 'line', 10
    if_null rx541_debug, debug_810
    rx541_cur."!cursor_debug"("NEXT", "term:sym<regex_declarator>")
  debug_810:
  rx541_fail:
    (rx541_rep, rx541_pos, $I10, $P10) = rx541_cur."!mark_fail"(0)
    lt rx541_pos, -1, rx541_done
    eq rx541_pos, -1, rx541_fail
    jump $I10
  rx541_done:
    rx541_cur."!cursor_fail"()
    if_null rx541_debug, debug_811
    rx541_cur."!cursor_debug"("FAIL", "term:sym<regex_declarator>")
  debug_811:
    .return (rx541_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<regex_declarator>"  :nsentry("!PREFIX__term:sym<regex_declarator>") :subid("121_1300062003.824") :method
.annotate 'line', 10
    $P543 = self."!PREFIX__!subrule"("regex_declarator", "")
    new $P544, "ResizablePMCArray"
    push $P544, $P543
    .return ($P544)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<statement_prefix>"  :subid("122_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx547_tgt
    .local int rx547_pos
    .local int rx547_off
    .local int rx547_eos
    .local int rx547_rep
    .local pmc rx547_cur
    .local pmc rx547_debug
    (rx547_cur, rx547_pos, rx547_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx547_cur
    .local pmc match
    .lex "$/", match
    length rx547_eos, rx547_tgt
    gt rx547_pos, rx547_eos, rx547_done
    set rx547_off, 0
    lt rx547_pos, 2, rx547_start
    sub rx547_off, rx547_pos, 1
    substr rx547_tgt, rx547_tgt, rx547_off
  rx547_start:
    eq $I10, 1, rx547_restart
    if_null rx547_debug, debug_812
    rx547_cur."!cursor_debug"("START", "term:sym<statement_prefix>")
  debug_812:
    $I10 = self.'from'()
    ne $I10, -1, rxscan551_done
    goto rxscan551_scan
  rxscan551_loop:
    (rx547_pos) = rx547_cur."from"()
    inc rx547_pos
    rx547_cur."!cursor_from"(rx547_pos)
    ge rx547_pos, rx547_eos, rxscan551_done
  rxscan551_scan:
    set_addr $I10, rxscan551_loop
    rx547_cur."!mark_push"(0, rx547_pos, $I10)
  rxscan551_done:
.annotate 'line', 279
  # rx subrule "statement_prefix" subtype=capture negate=
    rx547_cur."!cursor_pos"(rx547_pos)
    $P10 = rx547_cur."statement_prefix"()
    unless $P10, rx547_fail
    rx547_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_prefix")
    rx547_pos = $P10."pos"()
  # rx pass
    rx547_cur."!cursor_pass"(rx547_pos, "term:sym<statement_prefix>")
    if_null rx547_debug, debug_813
    rx547_cur."!cursor_debug"("PASS", "term:sym<statement_prefix>", " at pos=", rx547_pos)
  debug_813:
    .return (rx547_cur)
  rx547_restart:
.annotate 'line', 10
    if_null rx547_debug, debug_814
    rx547_cur."!cursor_debug"("NEXT", "term:sym<statement_prefix>")
  debug_814:
  rx547_fail:
    (rx547_rep, rx547_pos, $I10, $P10) = rx547_cur."!mark_fail"(0)
    lt rx547_pos, -1, rx547_done
    eq rx547_pos, -1, rx547_fail
    jump $I10
  rx547_done:
    rx547_cur."!cursor_fail"()
    if_null rx547_debug, debug_815
    rx547_cur."!cursor_debug"("FAIL", "term:sym<statement_prefix>")
  debug_815:
    .return (rx547_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<statement_prefix>"  :nsentry("!PREFIX__term:sym<statement_prefix>") :subid("123_1300062003.824") :method
.annotate 'line', 10
    $P549 = self."!PREFIX__!subrule"("statement_prefix", "")
    new $P550, "ResizablePMCArray"
    push $P550, $P549
    .return ($P550)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<lambda>"  :subid("124_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx553_tgt
    .local int rx553_pos
    .local int rx553_off
    .local int rx553_eos
    .local int rx553_rep
    .local pmc rx553_cur
    .local pmc rx553_debug
    (rx553_cur, rx553_pos, rx553_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx553_cur
    .local pmc match
    .lex "$/", match
    length rx553_eos, rx553_tgt
    gt rx553_pos, rx553_eos, rx553_done
    set rx553_off, 0
    lt rx553_pos, 2, rx553_start
    sub rx553_off, rx553_pos, 1
    substr rx553_tgt, rx553_tgt, rx553_off
  rx553_start:
    eq $I10, 1, rx553_restart
    if_null rx553_debug, debug_816
    rx553_cur."!cursor_debug"("START", "term:sym<lambda>")
  debug_816:
    $I10 = self.'from'()
    ne $I10, -1, rxscan556_done
    goto rxscan556_scan
  rxscan556_loop:
    (rx553_pos) = rx553_cur."from"()
    inc rx553_pos
    rx553_cur."!cursor_from"(rx553_pos)
    ge rx553_pos, rx553_eos, rxscan556_done
  rxscan556_scan:
    set_addr $I10, rxscan556_loop
    rx553_cur."!mark_push"(0, rx553_pos, $I10)
  rxscan556_done:
.annotate 'line', 280
  # rx subrule "lambda" subtype=zerowidth negate=
    rx553_cur."!cursor_pos"(rx553_pos)
    $P10 = rx553_cur."lambda"()
    unless $P10, rx553_fail
  # rx subrule "pblock" subtype=capture negate=
    rx553_cur."!cursor_pos"(rx553_pos)
    $P10 = rx553_cur."pblock"()
    unless $P10, rx553_fail
    rx553_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx553_pos = $P10."pos"()
  # rx pass
    rx553_cur."!cursor_pass"(rx553_pos, "term:sym<lambda>")
    if_null rx553_debug, debug_817
    rx553_cur."!cursor_debug"("PASS", "term:sym<lambda>", " at pos=", rx553_pos)
  debug_817:
    .return (rx553_cur)
  rx553_restart:
.annotate 'line', 10
    if_null rx553_debug, debug_818
    rx553_cur."!cursor_debug"("NEXT", "term:sym<lambda>")
  debug_818:
  rx553_fail:
    (rx553_rep, rx553_pos, $I10, $P10) = rx553_cur."!mark_fail"(0)
    lt rx553_pos, -1, rx553_done
    eq rx553_pos, -1, rx553_fail
    jump $I10
  rx553_done:
    rx553_cur."!cursor_fail"()
    if_null rx553_debug, debug_819
    rx553_cur."!cursor_debug"("FAIL", "term:sym<lambda>")
  debug_819:
    .return (rx553_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<lambda>"  :nsentry("!PREFIX__term:sym<lambda>") :subid("125_1300062003.824") :method
.annotate 'line', 10
    new $P555, "ResizablePMCArray"
    push $P555, ""
    .return ($P555)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "fatarrow"  :subid("126_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx558_tgt
    .local int rx558_pos
    .local int rx558_off
    .local int rx558_eos
    .local int rx558_rep
    .local pmc rx558_cur
    .local pmc rx558_debug
    (rx558_cur, rx558_pos, rx558_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx558_cur
    .local pmc match
    .lex "$/", match
    length rx558_eos, rx558_tgt
    gt rx558_pos, rx558_eos, rx558_done
    set rx558_off, 0
    lt rx558_pos, 2, rx558_start
    sub rx558_off, rx558_pos, 1
    substr rx558_tgt, rx558_tgt, rx558_off
  rx558_start:
    eq $I10, 1, rx558_restart
    if_null rx558_debug, debug_820
    rx558_cur."!cursor_debug"("START", "fatarrow")
  debug_820:
    $I10 = self.'from'()
    ne $I10, -1, rxscan562_done
    goto rxscan562_scan
  rxscan562_loop:
    (rx558_pos) = rx558_cur."from"()
    inc rx558_pos
    rx558_cur."!cursor_from"(rx558_pos)
    ge rx558_pos, rx558_eos, rxscan562_done
  rxscan562_scan:
    set_addr $I10, rxscan562_loop
    rx558_cur."!mark_push"(0, rx558_pos, $I10)
  rxscan562_done:
.annotate 'line', 283
  # rx subrule "identifier" subtype=capture negate=
    rx558_cur."!cursor_pos"(rx558_pos)
    $P10 = rx558_cur."identifier"()
    unless $P10, rx558_fail
    rx558_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("key")
    rx558_pos = $P10."pos"()
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx558_pos, rx558_off
    set rx558_rep, 0
    sub $I12, rx558_eos, rx558_pos
  rxenumcharlistq563_loop:
    le $I12, 0, rxenumcharlistq563_done
    substr $S10, rx558_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq563_done
    inc rx558_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq563_loop
  rxenumcharlistq563_done:
    add rx558_pos, rx558_pos, rx558_rep
  # rx literal  "=>"
    add $I11, rx558_pos, 2
    gt $I11, rx558_eos, rx558_fail
    sub $I11, rx558_pos, rx558_off
    substr $S10, rx558_tgt, $I11, 2
    ne $S10, "=>", rx558_fail
    add rx558_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx558_cur."!cursor_pos"(rx558_pos)
    $P10 = rx558_cur."ws"()
    unless $P10, rx558_fail
    rx558_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx558_cur."!cursor_pos"(rx558_pos)
    $P10 = rx558_cur."EXPR"("i=")
    unless $P10, rx558_fail
    rx558_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("val")
    rx558_pos = $P10."pos"()
.annotate 'line', 282
  # rx pass
    rx558_cur."!cursor_pass"(rx558_pos, "fatarrow")
    if_null rx558_debug, debug_821
    rx558_cur."!cursor_debug"("PASS", "fatarrow", " at pos=", rx558_pos)
  debug_821:
    .return (rx558_cur)
  rx558_restart:
.annotate 'line', 10
    if_null rx558_debug, debug_822
    rx558_cur."!cursor_debug"("NEXT", "fatarrow")
  debug_822:
  rx558_fail:
    (rx558_rep, rx558_pos, $I10, $P10) = rx558_cur."!mark_fail"(0)
    lt rx558_pos, -1, rx558_done
    eq rx558_pos, -1, rx558_fail
    jump $I10
  rx558_done:
    rx558_cur."!cursor_fail"()
    if_null rx558_debug, debug_823
    rx558_cur."!cursor_debug"("FAIL", "fatarrow")
  debug_823:
    .return (rx558_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__fatarrow"  :nsentry("!PREFIX__fatarrow") :subid("127_1300062003.824") :method
.annotate 'line', 10
    $P560 = self."!PREFIX__!subrule"("identifier", "")
    new $P561, "ResizablePMCArray"
    push $P561, $P560
    .return ($P561)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "colonpair"  :subid("128_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx565_tgt
    .local int rx565_pos
    .local int rx565_off
    .local int rx565_eos
    .local int rx565_rep
    .local pmc rx565_cur
    .local pmc rx565_debug
    (rx565_cur, rx565_pos, rx565_tgt, $I10) = self."!cursor_start"()
    rx565_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx565_cur
    .local pmc match
    .lex "$/", match
    length rx565_eos, rx565_tgt
    gt rx565_pos, rx565_eos, rx565_done
    set rx565_off, 0
    lt rx565_pos, 2, rx565_start
    sub rx565_off, rx565_pos, 1
    substr rx565_tgt, rx565_tgt, rx565_off
  rx565_start:
    eq $I10, 1, rx565_restart
    if_null rx565_debug, debug_824
    rx565_cur."!cursor_debug"("START", "colonpair")
  debug_824:
    $I10 = self.'from'()
    ne $I10, -1, rxscan571_done
    goto rxscan571_scan
  rxscan571_loop:
    (rx565_pos) = rx565_cur."from"()
    inc rx565_pos
    rx565_cur."!cursor_from"(rx565_pos)
    ge rx565_pos, rx565_eos, rxscan571_done
  rxscan571_scan:
    set_addr $I10, rxscan571_loop
    rx565_cur."!mark_push"(0, rx565_pos, $I10)
  rxscan571_done:
.annotate 'line', 287
  # rx literal  ":"
    add $I11, rx565_pos, 1
    gt $I11, rx565_eos, rx565_fail
    sub $I11, rx565_pos, rx565_off
    ord $I11, rx565_tgt, $I11
    ne $I11, 58, rx565_fail
    add rx565_pos, 1
  alt572_0:
.annotate 'line', 288
    set_addr $I10, alt572_1
    rx565_cur."!mark_push"(0, rx565_pos, $I10)
.annotate 'line', 289
  # rx subcapture "not"
    set_addr $I10, rxcap_573_fail
    rx565_cur."!mark_push"(0, rx565_pos, $I10)
  # rx literal  "!"
    add $I11, rx565_pos, 1
    gt $I11, rx565_eos, rx565_fail
    sub $I11, rx565_pos, rx565_off
    ord $I11, rx565_tgt, $I11
    ne $I11, 33, rx565_fail
    add rx565_pos, 1
    set_addr $I10, rxcap_573_fail
    ($I12, $I11) = rx565_cur."!mark_peek"($I10)
    rx565_cur."!cursor_pos"($I11)
    ($P10) = rx565_cur."!cursor_start"()
    $P10."!cursor_pass"(rx565_pos, "")
    rx565_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("not")
    goto rxcap_573_done
  rxcap_573_fail:
    goto rx565_fail
  rxcap_573_done:
  # rx subrule "identifier" subtype=capture negate=
    rx565_cur."!cursor_pos"(rx565_pos)
    $P10 = rx565_cur."identifier"()
    unless $P10, rx565_fail
    rx565_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx565_pos = $P10."pos"()
    goto alt572_end
  alt572_1:
    set_addr $I10, alt572_2
    rx565_cur."!mark_push"(0, rx565_pos, $I10)
.annotate 'line', 290
  # rx subrule "identifier" subtype=capture negate=
    rx565_cur."!cursor_pos"(rx565_pos)
    $P10 = rx565_cur."identifier"()
    unless $P10, rx565_fail
    rx565_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx565_pos = $P10."pos"()
  # rx rxquantr574 ** 0..1
    set_addr $I10, rxquantr574_done
    rx565_cur."!mark_push"(0, rx565_pos, $I10)
  rxquantr574_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx565_cur."!cursor_pos"(rx565_pos)
    $P10 = rx565_cur."circumfix"()
    unless $P10, rx565_fail
    goto rxsubrule575_pass
  rxsubrule575_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx565_fail
  rxsubrule575_pass:
    set_addr $I10, rxsubrule575_back
    rx565_cur."!mark_push"(0, rx565_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx565_pos = $P10."pos"()
    set_addr $I10, rxquantr574_done
    (rx565_rep) = rx565_cur."!mark_commit"($I10)
  rxquantr574_done:
    goto alt572_end
  alt572_2:
.annotate 'line', 291
  # rx subrule "circumfix" subtype=capture negate=
    rx565_cur."!cursor_pos"(rx565_pos)
    $P10 = rx565_cur."circumfix"()
    unless $P10, rx565_fail
    rx565_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("circumfix")
    rx565_pos = $P10."pos"()
  alt572_end:
.annotate 'line', 286
  # rx pass
    rx565_cur."!cursor_pass"(rx565_pos, "colonpair")
    if_null rx565_debug, debug_825
    rx565_cur."!cursor_debug"("PASS", "colonpair", " at pos=", rx565_pos)
  debug_825:
    .return (rx565_cur)
  rx565_restart:
.annotate 'line', 10
    if_null rx565_debug, debug_826
    rx565_cur."!cursor_debug"("NEXT", "colonpair")
  debug_826:
  rx565_fail:
    (rx565_rep, rx565_pos, $I10, $P10) = rx565_cur."!mark_fail"(0)
    lt rx565_pos, -1, rx565_done
    eq rx565_pos, -1, rx565_fail
    jump $I10
  rx565_done:
    rx565_cur."!cursor_fail"()
    if_null rx565_debug, debug_827
    rx565_cur."!cursor_debug"("FAIL", "colonpair")
  debug_827:
    .return (rx565_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__colonpair"  :nsentry("!PREFIX__colonpair") :subid("129_1300062003.824") :method
.annotate 'line', 10
    $P567 = self."!PREFIX__!subrule"("circumfix", ":")
    $P568 = self."!PREFIX__!subrule"("identifier", ":")
    $P569 = self."!PREFIX__!subrule"("identifier", ":!")
    new $P570, "ResizablePMCArray"
    push $P570, $P567
    push $P570, $P568
    push $P570, $P569
    .return ($P570)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable"  :subid("130_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx577_tgt
    .local int rx577_pos
    .local int rx577_off
    .local int rx577_eos
    .local int rx577_rep
    .local pmc rx577_cur
    .local pmc rx577_debug
    (rx577_cur, rx577_pos, rx577_tgt, $I10) = self."!cursor_start"()
    rx577_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx577_cur
    .local pmc match
    .lex "$/", match
    length rx577_eos, rx577_tgt
    gt rx577_pos, rx577_eos, rx577_done
    set rx577_off, 0
    lt rx577_pos, 2, rx577_start
    sub rx577_off, rx577_pos, 1
    substr rx577_tgt, rx577_tgt, rx577_off
  rx577_start:
    eq $I10, 1, rx577_restart
    if_null rx577_debug, debug_828
    rx577_cur."!cursor_debug"("START", "variable")
  debug_828:
    $I10 = self.'from'()
    ne $I10, -1, rxscan582_done
    goto rxscan582_scan
  rxscan582_loop:
    (rx577_pos) = rx577_cur."from"()
    inc rx577_pos
    rx577_cur."!cursor_from"(rx577_pos)
    ge rx577_pos, rx577_eos, rxscan582_done
  rxscan582_scan:
    set_addr $I10, rxscan582_loop
    rx577_cur."!mark_push"(0, rx577_pos, $I10)
  rxscan582_done:
  alt583_0:
.annotate 'line', 295
    set_addr $I10, alt583_1
    rx577_cur."!mark_push"(0, rx577_pos, $I10)
.annotate 'line', 296
  # rx subrule "sigil" subtype=capture negate=
    rx577_cur."!cursor_pos"(rx577_pos)
    $P10 = rx577_cur."sigil"()
    unless $P10, rx577_fail
    rx577_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx577_pos = $P10."pos"()
  # rx rxquantr584 ** 0..1
    set_addr $I10, rxquantr584_done
    rx577_cur."!mark_push"(0, rx577_pos, $I10)
  rxquantr584_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx577_cur."!cursor_pos"(rx577_pos)
    $P10 = rx577_cur."twigil"()
    unless $P10, rx577_fail
    goto rxsubrule585_pass
  rxsubrule585_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx577_fail
  rxsubrule585_pass:
    set_addr $I10, rxsubrule585_back
    rx577_cur."!mark_push"(0, rx577_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx577_pos = $P10."pos"()
    set_addr $I10, rxquantr584_done
    (rx577_rep) = rx577_cur."!mark_commit"($I10)
  rxquantr584_done:
  # rx subrule "name" subtype=capture negate=
    rx577_cur."!cursor_pos"(rx577_pos)
    $P10 = rx577_cur."name"()
    unless $P10, rx577_fail
    rx577_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    rx577_pos = $P10."pos"()
    goto alt583_end
  alt583_1:
    set_addr $I10, alt583_2
    rx577_cur."!mark_push"(0, rx577_pos, $I10)
.annotate 'line', 297
  # rx subrule "sigil" subtype=capture negate=
    rx577_cur."!cursor_pos"(rx577_pos)
    $P10 = rx577_cur."sigil"()
    unless $P10, rx577_fail
    rx577_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx577_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx577_pos, rx577_off
    substr $S10, rx577_tgt, $I10, 1
    index $I11, "<[", $S10
    lt $I11, 0, rx577_fail
  # rx subrule "postcircumfix" subtype=capture negate=
    rx577_cur."!cursor_pos"(rx577_pos)
    $P10 = rx577_cur."postcircumfix"()
    unless $P10, rx577_fail
    rx577_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("postcircumfix")
    rx577_pos = $P10."pos"()
    goto alt583_end
  alt583_2:
.annotate 'line', 298
  # rx subcapture "sigil"
    set_addr $I10, rxcap_586_fail
    rx577_cur."!mark_push"(0, rx577_pos, $I10)
  # rx literal  "$"
    add $I11, rx577_pos, 1
    gt $I11, rx577_eos, rx577_fail
    sub $I11, rx577_pos, rx577_off
    ord $I11, rx577_tgt, $I11
    ne $I11, 36, rx577_fail
    add rx577_pos, 1
    set_addr $I10, rxcap_586_fail
    ($I12, $I11) = rx577_cur."!mark_peek"($I10)
    rx577_cur."!cursor_pos"($I11)
    ($P10) = rx577_cur."!cursor_start"()
    $P10."!cursor_pass"(rx577_pos, "")
    rx577_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_586_done
  rxcap_586_fail:
    goto rx577_fail
  rxcap_586_done:
  # rx subcapture "desigilname"
    set_addr $I10, rxcap_587_fail
    rx577_cur."!mark_push"(0, rx577_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx577_pos, rx577_eos, rx577_fail
    sub $I10, rx577_pos, rx577_off
    substr $S10, rx577_tgt, $I10, 1
    index $I11, "/_!", $S10
    lt $I11, 0, rx577_fail
    inc rx577_pos
    set_addr $I10, rxcap_587_fail
    ($I12, $I11) = rx577_cur."!mark_peek"($I10)
    rx577_cur."!cursor_pos"($I11)
    ($P10) = rx577_cur."!cursor_start"()
    $P10."!cursor_pass"(rx577_pos, "")
    rx577_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    goto rxcap_587_done
  rxcap_587_fail:
    goto rx577_fail
  rxcap_587_done:
  alt583_end:
.annotate 'line', 295
  # rx pass
    rx577_cur."!cursor_pass"(rx577_pos, "variable")
    if_null rx577_debug, debug_829
    rx577_cur."!cursor_debug"("PASS", "variable", " at pos=", rx577_pos)
  debug_829:
    .return (rx577_cur)
  rx577_restart:
.annotate 'line', 10
    if_null rx577_debug, debug_830
    rx577_cur."!cursor_debug"("NEXT", "variable")
  debug_830:
  rx577_fail:
    (rx577_rep, rx577_pos, $I10, $P10) = rx577_cur."!mark_fail"(0)
    lt rx577_pos, -1, rx577_done
    eq rx577_pos, -1, rx577_fail
    jump $I10
  rx577_done:
    rx577_cur."!cursor_fail"()
    if_null rx577_debug, debug_831
    rx577_cur."!cursor_debug"("FAIL", "variable")
  debug_831:
    .return (rx577_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable"  :nsentry("!PREFIX__variable") :subid("131_1300062003.824") :method
.annotate 'line', 10
    $P579 = self."!PREFIX__!subrule"("sigil", "")
    $P580 = self."!PREFIX__!subrule"("sigil", "")
    new $P581, "ResizablePMCArray"
    push $P581, "$!"
    push $P581, "$_"
    push $P581, "$/"
    push $P581, $P579
    push $P581, $P580
    .return ($P581)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "sigil"  :subid("132_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx589_tgt
    .local int rx589_pos
    .local int rx589_off
    .local int rx589_eos
    .local int rx589_rep
    .local pmc rx589_cur
    .local pmc rx589_debug
    (rx589_cur, rx589_pos, rx589_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx589_cur
    .local pmc match
    .lex "$/", match
    length rx589_eos, rx589_tgt
    gt rx589_pos, rx589_eos, rx589_done
    set rx589_off, 0
    lt rx589_pos, 2, rx589_start
    sub rx589_off, rx589_pos, 1
    substr rx589_tgt, rx589_tgt, rx589_off
  rx589_start:
    eq $I10, 1, rx589_restart
    if_null rx589_debug, debug_832
    rx589_cur."!cursor_debug"("START", "sigil")
  debug_832:
    $I10 = self.'from'()
    ne $I10, -1, rxscan592_done
    goto rxscan592_scan
  rxscan592_loop:
    (rx589_pos) = rx589_cur."from"()
    inc rx589_pos
    rx589_cur."!cursor_from"(rx589_pos)
    ge rx589_pos, rx589_eos, rxscan592_done
  rxscan592_scan:
    set_addr $I10, rxscan592_loop
    rx589_cur."!mark_push"(0, rx589_pos, $I10)
  rxscan592_done:
.annotate 'line', 301
  # rx enumcharlist negate=0 
    ge rx589_pos, rx589_eos, rx589_fail
    sub $I10, rx589_pos, rx589_off
    substr $S10, rx589_tgt, $I10, 1
    index $I11, "$@%&", $S10
    lt $I11, 0, rx589_fail
    inc rx589_pos
  # rx pass
    rx589_cur."!cursor_pass"(rx589_pos, "sigil")
    if_null rx589_debug, debug_833
    rx589_cur."!cursor_debug"("PASS", "sigil", " at pos=", rx589_pos)
  debug_833:
    .return (rx589_cur)
  rx589_restart:
.annotate 'line', 10
    if_null rx589_debug, debug_834
    rx589_cur."!cursor_debug"("NEXT", "sigil")
  debug_834:
  rx589_fail:
    (rx589_rep, rx589_pos, $I10, $P10) = rx589_cur."!mark_fail"(0)
    lt rx589_pos, -1, rx589_done
    eq rx589_pos, -1, rx589_fail
    jump $I10
  rx589_done:
    rx589_cur."!cursor_fail"()
    if_null rx589_debug, debug_835
    rx589_cur."!cursor_debug"("FAIL", "sigil")
  debug_835:
    .return (rx589_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__sigil"  :nsentry("!PREFIX__sigil") :subid("133_1300062003.824") :method
.annotate 'line', 10
    new $P591, "ResizablePMCArray"
    push $P591, "&"
    push $P591, "%"
    push $P591, "@"
    push $P591, "$"
    .return ($P591)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "twigil"  :subid("134_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx594_tgt
    .local int rx594_pos
    .local int rx594_off
    .local int rx594_eos
    .local int rx594_rep
    .local pmc rx594_cur
    .local pmc rx594_debug
    (rx594_cur, rx594_pos, rx594_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx594_cur
    .local pmc match
    .lex "$/", match
    length rx594_eos, rx594_tgt
    gt rx594_pos, rx594_eos, rx594_done
    set rx594_off, 0
    lt rx594_pos, 2, rx594_start
    sub rx594_off, rx594_pos, 1
    substr rx594_tgt, rx594_tgt, rx594_off
  rx594_start:
    eq $I10, 1, rx594_restart
    if_null rx594_debug, debug_836
    rx594_cur."!cursor_debug"("START", "twigil")
  debug_836:
    $I10 = self.'from'()
    ne $I10, -1, rxscan597_done
    goto rxscan597_scan
  rxscan597_loop:
    (rx594_pos) = rx594_cur."from"()
    inc rx594_pos
    rx594_cur."!cursor_from"(rx594_pos)
    ge rx594_pos, rx594_eos, rxscan597_done
  rxscan597_scan:
    set_addr $I10, rxscan597_loop
    rx594_cur."!mark_push"(0, rx594_pos, $I10)
  rxscan597_done:
.annotate 'line', 303
  # rx enumcharlist negate=0 
    ge rx594_pos, rx594_eos, rx594_fail
    sub $I10, rx594_pos, rx594_off
    substr $S10, rx594_tgt, $I10, 1
    index $I11, "*!?", $S10
    lt $I11, 0, rx594_fail
    inc rx594_pos
  # rx pass
    rx594_cur."!cursor_pass"(rx594_pos, "twigil")
    if_null rx594_debug, debug_837
    rx594_cur."!cursor_debug"("PASS", "twigil", " at pos=", rx594_pos)
  debug_837:
    .return (rx594_cur)
  rx594_restart:
.annotate 'line', 10
    if_null rx594_debug, debug_838
    rx594_cur."!cursor_debug"("NEXT", "twigil")
  debug_838:
  rx594_fail:
    (rx594_rep, rx594_pos, $I10, $P10) = rx594_cur."!mark_fail"(0)
    lt rx594_pos, -1, rx594_done
    eq rx594_pos, -1, rx594_fail
    jump $I10
  rx594_done:
    rx594_cur."!cursor_fail"()
    if_null rx594_debug, debug_839
    rx594_cur."!cursor_debug"("FAIL", "twigil")
  debug_839:
    .return (rx594_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__twigil"  :nsentry("!PREFIX__twigil") :subid("135_1300062003.824") :method
.annotate 'line', 10
    new $P596, "ResizablePMCArray"
    push $P596, "?"
    push $P596, "!"
    push $P596, "*"
    .return ($P596)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator"  :subid("136_1300062003.824")
    .param pmc param_599
.annotate 'line', 305
    .lex "self", param_599
    $P600 = param_599."!protoregex"("package_declarator")
    .return ($P600)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator"  :subid("137_1300062003.824")
    .param pmc param_602
.annotate 'line', 305
    .lex "self", param_602
    $P603 = param_602."!PREFIX__!protoregex"("package_declarator")
    .return ($P603)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<module>"  :subid("138_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 307
    new $P605, "Undef"
    .lex "$*PACKAGE-SETUP", $P605
.annotate 'line', 308
    new $P606, "Undef"
    .lex "$*PKGDECL", $P606
.annotate 'line', 10
    .local string rx607_tgt
    .local int rx607_pos
    .local int rx607_off
    .local int rx607_eos
    .local int rx607_rep
    .local pmc rx607_cur
    .local pmc rx607_debug
    (rx607_cur, rx607_pos, rx607_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx607_cur
    .local pmc match
    .lex "$/", match
    length rx607_eos, rx607_tgt
    gt rx607_pos, rx607_eos, rx607_done
    set rx607_off, 0
    lt rx607_pos, 2, rx607_start
    sub rx607_off, rx607_pos, 1
    substr rx607_tgt, rx607_tgt, rx607_off
  rx607_start:
    eq $I10, 1, rx607_restart
    if_null rx607_debug, debug_840
    rx607_cur."!cursor_debug"("START", "package_declarator:sym<module>")
  debug_840:
    $I10 = self.'from'()
    ne $I10, -1, rxscan611_done
    goto rxscan611_scan
  rxscan611_loop:
    (rx607_pos) = rx607_cur."from"()
    inc rx607_pos
    rx607_cur."!cursor_from"(rx607_pos)
    ge rx607_pos, rx607_eos, rxscan611_done
  rxscan611_scan:
    set_addr $I10, rxscan611_loop
    rx607_cur."!mark_push"(0, rx607_pos, $I10)
  rxscan611_done:
.annotate 'line', 307
    rx607_cur."!cursor_pos"(rx607_pos)
    get_hll_global $P612, ["PAST"], "Stmts"
    $P613 = $P612."new"()
    store_lex "$*PACKAGE-SETUP", $P613
.annotate 'line', 308
    rx607_cur."!cursor_pos"(rx607_pos)
    new $P614, "String"
    assign $P614, "module"
    store_lex "$*PKGDECL", $P614
.annotate 'line', 309
  # rx subcapture "sym"
    set_addr $I10, rxcap_615_fail
    rx607_cur."!mark_push"(0, rx607_pos, $I10)
  # rx literal  "module"
    add $I11, rx607_pos, 6
    gt $I11, rx607_eos, rx607_fail
    sub $I11, rx607_pos, rx607_off
    substr $S10, rx607_tgt, $I11, 6
    ne $S10, "module", rx607_fail
    add rx607_pos, 6
    set_addr $I10, rxcap_615_fail
    ($I12, $I11) = rx607_cur."!mark_peek"($I10)
    rx607_cur."!cursor_pos"($I11)
    ($P10) = rx607_cur."!cursor_start"()
    $P10."!cursor_pass"(rx607_pos, "")
    rx607_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_615_done
  rxcap_615_fail:
    goto rx607_fail
  rxcap_615_done:
  # rx subrule "package_def" subtype=capture negate=
    rx607_cur."!cursor_pos"(rx607_pos)
    $P10 = rx607_cur."package_def"()
    unless $P10, rx607_fail
    rx607_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx607_pos = $P10."pos"()
.annotate 'line', 306
  # rx pass
    rx607_cur."!cursor_pass"(rx607_pos, "package_declarator:sym<module>")
    if_null rx607_debug, debug_841
    rx607_cur."!cursor_debug"("PASS", "package_declarator:sym<module>", " at pos=", rx607_pos)
  debug_841:
    .return (rx607_cur)
  rx607_restart:
.annotate 'line', 10
    if_null rx607_debug, debug_842
    rx607_cur."!cursor_debug"("NEXT", "package_declarator:sym<module>")
  debug_842:
  rx607_fail:
    (rx607_rep, rx607_pos, $I10, $P10) = rx607_cur."!mark_fail"(0)
    lt rx607_pos, -1, rx607_done
    eq rx607_pos, -1, rx607_fail
    jump $I10
  rx607_done:
    rx607_cur."!cursor_fail"()
    if_null rx607_debug, debug_843
    rx607_cur."!cursor_debug"("FAIL", "package_declarator:sym<module>")
  debug_843:
    .return (rx607_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<module>"  :nsentry("!PREFIX__package_declarator:sym<module>") :subid("139_1300062003.824") :method
.annotate 'line', 10
    $P609 = self."!PREFIX__!subrule"("package_def", "module")
    new $P610, "ResizablePMCArray"
    push $P610, $P609
    .return ($P610)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<knowhow>"  :subid("140_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 312
    new $P617, "Undef"
    .lex "$*PACKAGE-SETUP", $P617
.annotate 'line', 313
    new $P618, "Undef"
    .lex "$*PKGDECL", $P618
.annotate 'line', 10
    .local string rx619_tgt
    .local int rx619_pos
    .local int rx619_off
    .local int rx619_eos
    .local int rx619_rep
    .local pmc rx619_cur
    .local pmc rx619_debug
    (rx619_cur, rx619_pos, rx619_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx619_cur
    .local pmc match
    .lex "$/", match
    length rx619_eos, rx619_tgt
    gt rx619_pos, rx619_eos, rx619_done
    set rx619_off, 0
    lt rx619_pos, 2, rx619_start
    sub rx619_off, rx619_pos, 1
    substr rx619_tgt, rx619_tgt, rx619_off
  rx619_start:
    eq $I10, 1, rx619_restart
    if_null rx619_debug, debug_844
    rx619_cur."!cursor_debug"("START", "package_declarator:sym<knowhow>")
  debug_844:
    $I10 = self.'from'()
    ne $I10, -1, rxscan623_done
    goto rxscan623_scan
  rxscan623_loop:
    (rx619_pos) = rx619_cur."from"()
    inc rx619_pos
    rx619_cur."!cursor_from"(rx619_pos)
    ge rx619_pos, rx619_eos, rxscan623_done
  rxscan623_scan:
    set_addr $I10, rxscan623_loop
    rx619_cur."!mark_push"(0, rx619_pos, $I10)
  rxscan623_done:
.annotate 'line', 312
    rx619_cur."!cursor_pos"(rx619_pos)
    get_hll_global $P624, ["PAST"], "Stmts"
    $P625 = $P624."new"()
    store_lex "$*PACKAGE-SETUP", $P625
.annotate 'line', 313
    rx619_cur."!cursor_pos"(rx619_pos)
    new $P626, "String"
    assign $P626, "knowhow"
    store_lex "$*PKGDECL", $P626
.annotate 'line', 314
  # rx subcapture "sym"
    set_addr $I10, rxcap_627_fail
    rx619_cur."!mark_push"(0, rx619_pos, $I10)
  # rx literal  "knowhow"
    add $I11, rx619_pos, 7
    gt $I11, rx619_eos, rx619_fail
    sub $I11, rx619_pos, rx619_off
    substr $S10, rx619_tgt, $I11, 7
    ne $S10, "knowhow", rx619_fail
    add rx619_pos, 7
    set_addr $I10, rxcap_627_fail
    ($I12, $I11) = rx619_cur."!mark_peek"($I10)
    rx619_cur."!cursor_pos"($I11)
    ($P10) = rx619_cur."!cursor_start"()
    $P10."!cursor_pass"(rx619_pos, "")
    rx619_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_627_done
  rxcap_627_fail:
    goto rx619_fail
  rxcap_627_done:
  # rx subrule "package_def" subtype=capture negate=
    rx619_cur."!cursor_pos"(rx619_pos)
    $P10 = rx619_cur."package_def"()
    unless $P10, rx619_fail
    rx619_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx619_pos = $P10."pos"()
.annotate 'line', 311
  # rx pass
    rx619_cur."!cursor_pass"(rx619_pos, "package_declarator:sym<knowhow>")
    if_null rx619_debug, debug_845
    rx619_cur."!cursor_debug"("PASS", "package_declarator:sym<knowhow>", " at pos=", rx619_pos)
  debug_845:
    .return (rx619_cur)
  rx619_restart:
.annotate 'line', 10
    if_null rx619_debug, debug_846
    rx619_cur."!cursor_debug"("NEXT", "package_declarator:sym<knowhow>")
  debug_846:
  rx619_fail:
    (rx619_rep, rx619_pos, $I10, $P10) = rx619_cur."!mark_fail"(0)
    lt rx619_pos, -1, rx619_done
    eq rx619_pos, -1, rx619_fail
    jump $I10
  rx619_done:
    rx619_cur."!cursor_fail"()
    if_null rx619_debug, debug_847
    rx619_cur."!cursor_debug"("FAIL", "package_declarator:sym<knowhow>")
  debug_847:
    .return (rx619_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<knowhow>"  :nsentry("!PREFIX__package_declarator:sym<knowhow>") :subid("141_1300062003.824") :method
.annotate 'line', 10
    $P621 = self."!PREFIX__!subrule"("package_def", "knowhow")
    new $P622, "ResizablePMCArray"
    push $P622, $P621
    .return ($P622)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<class>"  :subid("142_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 317
    new $P629, "Undef"
    .lex "$*PACKAGE-SETUP", $P629
.annotate 'line', 318
    new $P630, "Undef"
    .lex "$*PKGDECL", $P630
.annotate 'line', 10
    .local string rx631_tgt
    .local int rx631_pos
    .local int rx631_off
    .local int rx631_eos
    .local int rx631_rep
    .local pmc rx631_cur
    .local pmc rx631_debug
    (rx631_cur, rx631_pos, rx631_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx631_cur
    .local pmc match
    .lex "$/", match
    length rx631_eos, rx631_tgt
    gt rx631_pos, rx631_eos, rx631_done
    set rx631_off, 0
    lt rx631_pos, 2, rx631_start
    sub rx631_off, rx631_pos, 1
    substr rx631_tgt, rx631_tgt, rx631_off
  rx631_start:
    eq $I10, 1, rx631_restart
    if_null rx631_debug, debug_848
    rx631_cur."!cursor_debug"("START", "package_declarator:sym<class>")
  debug_848:
    $I10 = self.'from'()
    ne $I10, -1, rxscan635_done
    goto rxscan635_scan
  rxscan635_loop:
    (rx631_pos) = rx631_cur."from"()
    inc rx631_pos
    rx631_cur."!cursor_from"(rx631_pos)
    ge rx631_pos, rx631_eos, rxscan635_done
  rxscan635_scan:
    set_addr $I10, rxscan635_loop
    rx631_cur."!mark_push"(0, rx631_pos, $I10)
  rxscan635_done:
.annotate 'line', 317
    rx631_cur."!cursor_pos"(rx631_pos)
    get_hll_global $P636, ["PAST"], "Stmts"
    $P637 = $P636."new"()
    store_lex "$*PACKAGE-SETUP", $P637
.annotate 'line', 318
    rx631_cur."!cursor_pos"(rx631_pos)
    new $P638, "String"
    assign $P638, "class"
    store_lex "$*PKGDECL", $P638
.annotate 'line', 319
  # rx subcapture "sym"
    set_addr $I10, rxcap_639_fail
    rx631_cur."!mark_push"(0, rx631_pos, $I10)
  # rx literal  "class"
    add $I11, rx631_pos, 5
    gt $I11, rx631_eos, rx631_fail
    sub $I11, rx631_pos, rx631_off
    substr $S10, rx631_tgt, $I11, 5
    ne $S10, "class", rx631_fail
    add rx631_pos, 5
    set_addr $I10, rxcap_639_fail
    ($I12, $I11) = rx631_cur."!mark_peek"($I10)
    rx631_cur."!cursor_pos"($I11)
    ($P10) = rx631_cur."!cursor_start"()
    $P10."!cursor_pass"(rx631_pos, "")
    rx631_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_639_done
  rxcap_639_fail:
    goto rx631_fail
  rxcap_639_done:
  # rx subrule "package_def" subtype=capture negate=
    rx631_cur."!cursor_pos"(rx631_pos)
    $P10 = rx631_cur."package_def"()
    unless $P10, rx631_fail
    rx631_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx631_pos = $P10."pos"()
.annotate 'line', 316
  # rx pass
    rx631_cur."!cursor_pass"(rx631_pos, "package_declarator:sym<class>")
    if_null rx631_debug, debug_849
    rx631_cur."!cursor_debug"("PASS", "package_declarator:sym<class>", " at pos=", rx631_pos)
  debug_849:
    .return (rx631_cur)
  rx631_restart:
.annotate 'line', 10
    if_null rx631_debug, debug_850
    rx631_cur."!cursor_debug"("NEXT", "package_declarator:sym<class>")
  debug_850:
  rx631_fail:
    (rx631_rep, rx631_pos, $I10, $P10) = rx631_cur."!mark_fail"(0)
    lt rx631_pos, -1, rx631_done
    eq rx631_pos, -1, rx631_fail
    jump $I10
  rx631_done:
    rx631_cur."!cursor_fail"()
    if_null rx631_debug, debug_851
    rx631_cur."!cursor_debug"("FAIL", "package_declarator:sym<class>")
  debug_851:
    .return (rx631_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<class>"  :nsentry("!PREFIX__package_declarator:sym<class>") :subid("143_1300062003.824") :method
.annotate 'line', 10
    $P633 = self."!PREFIX__!subrule"("package_def", "class")
    new $P634, "ResizablePMCArray"
    push $P634, $P633
    .return ($P634)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<grammar>"  :subid("144_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 322
    new $P641, "Undef"
    .lex "$*PACKAGE-SETUP", $P641
.annotate 'line', 323
    new $P642, "Undef"
    .lex "$*PKGDECL", $P642
.annotate 'line', 10
    .local string rx643_tgt
    .local int rx643_pos
    .local int rx643_off
    .local int rx643_eos
    .local int rx643_rep
    .local pmc rx643_cur
    .local pmc rx643_debug
    (rx643_cur, rx643_pos, rx643_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx643_cur
    .local pmc match
    .lex "$/", match
    length rx643_eos, rx643_tgt
    gt rx643_pos, rx643_eos, rx643_done
    set rx643_off, 0
    lt rx643_pos, 2, rx643_start
    sub rx643_off, rx643_pos, 1
    substr rx643_tgt, rx643_tgt, rx643_off
  rx643_start:
    eq $I10, 1, rx643_restart
    if_null rx643_debug, debug_852
    rx643_cur."!cursor_debug"("START", "package_declarator:sym<grammar>")
  debug_852:
    $I10 = self.'from'()
    ne $I10, -1, rxscan647_done
    goto rxscan647_scan
  rxscan647_loop:
    (rx643_pos) = rx643_cur."from"()
    inc rx643_pos
    rx643_cur."!cursor_from"(rx643_pos)
    ge rx643_pos, rx643_eos, rxscan647_done
  rxscan647_scan:
    set_addr $I10, rxscan647_loop
    rx643_cur."!mark_push"(0, rx643_pos, $I10)
  rxscan647_done:
.annotate 'line', 322
    rx643_cur."!cursor_pos"(rx643_pos)
    get_hll_global $P648, ["PAST"], "Stmts"
    $P649 = $P648."new"()
    store_lex "$*PACKAGE-SETUP", $P649
.annotate 'line', 323
    rx643_cur."!cursor_pos"(rx643_pos)
    new $P650, "String"
    assign $P650, "grammar"
    store_lex "$*PKGDECL", $P650
.annotate 'line', 324
  # rx subcapture "sym"
    set_addr $I10, rxcap_651_fail
    rx643_cur."!mark_push"(0, rx643_pos, $I10)
  # rx literal  "grammar"
    add $I11, rx643_pos, 7
    gt $I11, rx643_eos, rx643_fail
    sub $I11, rx643_pos, rx643_off
    substr $S10, rx643_tgt, $I11, 7
    ne $S10, "grammar", rx643_fail
    add rx643_pos, 7
    set_addr $I10, rxcap_651_fail
    ($I12, $I11) = rx643_cur."!mark_peek"($I10)
    rx643_cur."!cursor_pos"($I11)
    ($P10) = rx643_cur."!cursor_start"()
    $P10."!cursor_pass"(rx643_pos, "")
    rx643_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_651_done
  rxcap_651_fail:
    goto rx643_fail
  rxcap_651_done:
  # rx subrule "package_def" subtype=capture negate=
    rx643_cur."!cursor_pos"(rx643_pos)
    $P10 = rx643_cur."package_def"()
    unless $P10, rx643_fail
    rx643_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx643_pos = $P10."pos"()
.annotate 'line', 321
  # rx pass
    rx643_cur."!cursor_pass"(rx643_pos, "package_declarator:sym<grammar>")
    if_null rx643_debug, debug_853
    rx643_cur."!cursor_debug"("PASS", "package_declarator:sym<grammar>", " at pos=", rx643_pos)
  debug_853:
    .return (rx643_cur)
  rx643_restart:
.annotate 'line', 10
    if_null rx643_debug, debug_854
    rx643_cur."!cursor_debug"("NEXT", "package_declarator:sym<grammar>")
  debug_854:
  rx643_fail:
    (rx643_rep, rx643_pos, $I10, $P10) = rx643_cur."!mark_fail"(0)
    lt rx643_pos, -1, rx643_done
    eq rx643_pos, -1, rx643_fail
    jump $I10
  rx643_done:
    rx643_cur."!cursor_fail"()
    if_null rx643_debug, debug_855
    rx643_cur."!cursor_debug"("FAIL", "package_declarator:sym<grammar>")
  debug_855:
    .return (rx643_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<grammar>"  :nsentry("!PREFIX__package_declarator:sym<grammar>") :subid("145_1300062003.824") :method
.annotate 'line', 10
    $P645 = self."!PREFIX__!subrule"("package_def", "grammar")
    new $P646, "ResizablePMCArray"
    push $P646, $P645
    .return ($P646)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<role>"  :subid("146_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 327
    new $P653, "Undef"
    .lex "$*PACKAGE-SETUP", $P653
.annotate 'line', 328
    new $P654, "Undef"
    .lex "$*PKGDECL", $P654
.annotate 'line', 10
    .local string rx655_tgt
    .local int rx655_pos
    .local int rx655_off
    .local int rx655_eos
    .local int rx655_rep
    .local pmc rx655_cur
    .local pmc rx655_debug
    (rx655_cur, rx655_pos, rx655_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx655_cur
    .local pmc match
    .lex "$/", match
    length rx655_eos, rx655_tgt
    gt rx655_pos, rx655_eos, rx655_done
    set rx655_off, 0
    lt rx655_pos, 2, rx655_start
    sub rx655_off, rx655_pos, 1
    substr rx655_tgt, rx655_tgt, rx655_off
  rx655_start:
    eq $I10, 1, rx655_restart
    if_null rx655_debug, debug_856
    rx655_cur."!cursor_debug"("START", "package_declarator:sym<role>")
  debug_856:
    $I10 = self.'from'()
    ne $I10, -1, rxscan659_done
    goto rxscan659_scan
  rxscan659_loop:
    (rx655_pos) = rx655_cur."from"()
    inc rx655_pos
    rx655_cur."!cursor_from"(rx655_pos)
    ge rx655_pos, rx655_eos, rxscan659_done
  rxscan659_scan:
    set_addr $I10, rxscan659_loop
    rx655_cur."!mark_push"(0, rx655_pos, $I10)
  rxscan659_done:
.annotate 'line', 327
    rx655_cur."!cursor_pos"(rx655_pos)
    get_hll_global $P660, ["PAST"], "Stmts"
    $P661 = $P660."new"()
    store_lex "$*PACKAGE-SETUP", $P661
.annotate 'line', 328
    rx655_cur."!cursor_pos"(rx655_pos)
    new $P662, "String"
    assign $P662, "role"
    store_lex "$*PKGDECL", $P662
.annotate 'line', 329
  # rx subcapture "sym"
    set_addr $I10, rxcap_663_fail
    rx655_cur."!mark_push"(0, rx655_pos, $I10)
  # rx literal  "role"
    add $I11, rx655_pos, 4
    gt $I11, rx655_eos, rx655_fail
    sub $I11, rx655_pos, rx655_off
    substr $S10, rx655_tgt, $I11, 4
    ne $S10, "role", rx655_fail
    add rx655_pos, 4
    set_addr $I10, rxcap_663_fail
    ($I12, $I11) = rx655_cur."!mark_peek"($I10)
    rx655_cur."!cursor_pos"($I11)
    ($P10) = rx655_cur."!cursor_start"()
    $P10."!cursor_pass"(rx655_pos, "")
    rx655_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_663_done
  rxcap_663_fail:
    goto rx655_fail
  rxcap_663_done:
  # rx subrule "package_def" subtype=capture negate=
    rx655_cur."!cursor_pos"(rx655_pos)
    $P10 = rx655_cur."package_def"()
    unless $P10, rx655_fail
    rx655_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx655_pos = $P10."pos"()
.annotate 'line', 326
  # rx pass
    rx655_cur."!cursor_pass"(rx655_pos, "package_declarator:sym<role>")
    if_null rx655_debug, debug_857
    rx655_cur."!cursor_debug"("PASS", "package_declarator:sym<role>", " at pos=", rx655_pos)
  debug_857:
    .return (rx655_cur)
  rx655_restart:
.annotate 'line', 10
    if_null rx655_debug, debug_858
    rx655_cur."!cursor_debug"("NEXT", "package_declarator:sym<role>")
  debug_858:
  rx655_fail:
    (rx655_rep, rx655_pos, $I10, $P10) = rx655_cur."!mark_fail"(0)
    lt rx655_pos, -1, rx655_done
    eq rx655_pos, -1, rx655_fail
    jump $I10
  rx655_done:
    rx655_cur."!cursor_fail"()
    if_null rx655_debug, debug_859
    rx655_cur."!cursor_debug"("FAIL", "package_declarator:sym<role>")
  debug_859:
    .return (rx655_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<role>"  :nsentry("!PREFIX__package_declarator:sym<role>") :subid("147_1300062003.824") :method
.annotate 'line', 10
    $P657 = self."!PREFIX__!subrule"("package_def", "role")
    new $P658, "ResizablePMCArray"
    push $P658, $P657
    .return ($P658)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<native>"  :subid("148_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 332
    new $P665, "Undef"
    .lex "$*PACKAGE-SETUP", $P665
.annotate 'line', 333
    new $P666, "Undef"
    .lex "$*PKGDECL", $P666
.annotate 'line', 10
    .local string rx667_tgt
    .local int rx667_pos
    .local int rx667_off
    .local int rx667_eos
    .local int rx667_rep
    .local pmc rx667_cur
    .local pmc rx667_debug
    (rx667_cur, rx667_pos, rx667_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx667_cur
    .local pmc match
    .lex "$/", match
    length rx667_eos, rx667_tgt
    gt rx667_pos, rx667_eos, rx667_done
    set rx667_off, 0
    lt rx667_pos, 2, rx667_start
    sub rx667_off, rx667_pos, 1
    substr rx667_tgt, rx667_tgt, rx667_off
  rx667_start:
    eq $I10, 1, rx667_restart
    if_null rx667_debug, debug_860
    rx667_cur."!cursor_debug"("START", "package_declarator:sym<native>")
  debug_860:
    $I10 = self.'from'()
    ne $I10, -1, rxscan671_done
    goto rxscan671_scan
  rxscan671_loop:
    (rx667_pos) = rx667_cur."from"()
    inc rx667_pos
    rx667_cur."!cursor_from"(rx667_pos)
    ge rx667_pos, rx667_eos, rxscan671_done
  rxscan671_scan:
    set_addr $I10, rxscan671_loop
    rx667_cur."!mark_push"(0, rx667_pos, $I10)
  rxscan671_done:
.annotate 'line', 332
    rx667_cur."!cursor_pos"(rx667_pos)
    get_hll_global $P672, ["PAST"], "Stmts"
    $P673 = $P672."new"()
    store_lex "$*PACKAGE-SETUP", $P673
.annotate 'line', 333
    rx667_cur."!cursor_pos"(rx667_pos)
    new $P674, "String"
    assign $P674, "native"
    store_lex "$*PKGDECL", $P674
.annotate 'line', 334
  # rx subcapture "sym"
    set_addr $I10, rxcap_675_fail
    rx667_cur."!mark_push"(0, rx667_pos, $I10)
  # rx literal  "native"
    add $I11, rx667_pos, 6
    gt $I11, rx667_eos, rx667_fail
    sub $I11, rx667_pos, rx667_off
    substr $S10, rx667_tgt, $I11, 6
    ne $S10, "native", rx667_fail
    add rx667_pos, 6
    set_addr $I10, rxcap_675_fail
    ($I12, $I11) = rx667_cur."!mark_peek"($I10)
    rx667_cur."!cursor_pos"($I11)
    ($P10) = rx667_cur."!cursor_start"()
    $P10."!cursor_pass"(rx667_pos, "")
    rx667_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_675_done
  rxcap_675_fail:
    goto rx667_fail
  rxcap_675_done:
  # rx subrule "package_def" subtype=capture negate=
    rx667_cur."!cursor_pos"(rx667_pos)
    $P10 = rx667_cur."package_def"()
    unless $P10, rx667_fail
    rx667_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx667_pos = $P10."pos"()
.annotate 'line', 331
  # rx pass
    rx667_cur."!cursor_pass"(rx667_pos, "package_declarator:sym<native>")
    if_null rx667_debug, debug_861
    rx667_cur."!cursor_debug"("PASS", "package_declarator:sym<native>", " at pos=", rx667_pos)
  debug_861:
    .return (rx667_cur)
  rx667_restart:
.annotate 'line', 10
    if_null rx667_debug, debug_862
    rx667_cur."!cursor_debug"("NEXT", "package_declarator:sym<native>")
  debug_862:
  rx667_fail:
    (rx667_rep, rx667_pos, $I10, $P10) = rx667_cur."!mark_fail"(0)
    lt rx667_pos, -1, rx667_done
    eq rx667_pos, -1, rx667_fail
    jump $I10
  rx667_done:
    rx667_cur."!cursor_fail"()
    if_null rx667_debug, debug_863
    rx667_cur."!cursor_debug"("FAIL", "package_declarator:sym<native>")
  debug_863:
    .return (rx667_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<native>"  :nsentry("!PREFIX__package_declarator:sym<native>") :subid("149_1300062003.824") :method
.annotate 'line', 10
    $P669 = self."!PREFIX__!subrule"("package_def", "native")
    new $P670, "ResizablePMCArray"
    push $P670, $P669
    .return ($P670)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_def"  :subid("150_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .const 'Sub' $P700 = "152_1300062003.824" 
    capture_lex $P700
.annotate 'line', 338
    new $P677, "Undef"
    .lex "$*PKGMETA", $P677
.annotate 'line', 339
    $P678 = root_new ['parrot';'Hash']
    .lex "%*ATTR-CHECK", $P678
.annotate 'line', 10
    .local string rx679_tgt
    .local int rx679_pos
    .local int rx679_off
    .local int rx679_eos
    .local int rx679_rep
    .local pmc rx679_cur
    .local pmc rx679_debug
    (rx679_cur, rx679_pos, rx679_tgt, $I10) = self."!cursor_start"()
    rx679_cur."!cursor_caparray"("repr", "parent", "role")
    .lex unicode:"$\x{a2}", rx679_cur
    .local pmc match
    .lex "$/", match
    length rx679_eos, rx679_tgt
    gt rx679_pos, rx679_eos, rx679_done
    set rx679_off, 0
    lt rx679_pos, 2, rx679_start
    sub rx679_off, rx679_pos, 1
    substr rx679_tgt, rx679_tgt, rx679_off
  rx679_start:
    eq $I10, 1, rx679_restart
    if_null rx679_debug, debug_864
    rx679_cur."!cursor_debug"("START", "package_def")
  debug_864:
    $I10 = self.'from'()
    ne $I10, -1, rxscan683_done
    goto rxscan683_scan
  rxscan683_loop:
    (rx679_pos) = rx679_cur."from"()
    inc rx679_pos
    rx679_cur."!cursor_from"(rx679_pos)
    ge rx679_pos, rx679_eos, rxscan683_done
  rxscan683_scan:
    set_addr $I10, rxscan683_loop
    rx679_cur."!mark_push"(0, rx679_pos, $I10)
  rxscan683_done:
.annotate 'line', 337
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
.annotate 'line', 338
    rx679_cur."!cursor_pos"(rx679_pos)
    find_lex $P685, "$*PKGMETA"
    unless_null $P685, vivify_865
    get_hll_global $P685, "$PKGMETA"
    unless_null $P685, vivify_866
    die "Contextual $*PKGMETA not found"
  vivify_866:
  vivify_865:
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
.annotate 'line', 339
    rx679_cur."!cursor_pos"(rx679_pos)
    find_lex $P687, "%*ATTR-CHECK"
    unless_null $P687, vivify_867
    get_hll_global $P687, "%ATTR-CHECK"
    unless_null $P687, vivify_868
    die "Contextual %*ATTR-CHECK not found"
  vivify_868:
  vivify_867:
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
.annotate 'line', 341
  # rx subrule "name" subtype=capture negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."name"()
    unless $P10, rx679_fail
    rx679_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx679_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
.annotate 'line', 342
  # rx rxquantr690 ** 0..1
    set_addr $I10, rxquantr690_done
    rx679_cur."!mark_push"(0, rx679_pos, $I10)
  rxquantr690_loop:
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx679_pos, 2
    gt $I11, rx679_eos, rx679_fail
    sub $I11, rx679_pos, rx679_off
    substr $S10, rx679_tgt, $I11, 2
    ne $S10, "is", rx679_fail
    add rx679_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
  # rx literal  "repr("
    add $I11, rx679_pos, 5
    gt $I11, rx679_eos, rx679_fail
    sub $I11, rx679_pos, rx679_off
    substr $S10, rx679_tgt, $I11, 5
    ne $S10, "repr(", rx679_fail
    add rx679_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."quote_EXPR"()
    unless $P10, rx679_fail
    rx679_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("repr")
    rx679_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx679_pos, 1
    gt $I11, rx679_eos, rx679_fail
    sub $I11, rx679_pos, rx679_off
    ord $I11, rx679_tgt, $I11
    ne $I11, 41, rx679_fail
    add rx679_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
    set_addr $I10, rxquantr690_done
    (rx679_rep) = rx679_cur."!mark_commit"($I10)
  rxquantr690_done:
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
.annotate 'line', 344
    rx679_cur."!cursor_pos"(rx679_pos)
    find_lex $P697, unicode:"$\x{a2}"
    $P698 = $P697."MATCH"()
    store_lex "$/", $P698
    .const 'Sub' $P700 = "152_1300062003.824" 
    capture_lex $P700
    $P726 = $P700()
.annotate 'line', 353
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
.annotate 'line', 355
  # rx rxquantr728 ** 0..1
    set_addr $I10, rxquantr728_done
    rx679_cur."!mark_push"(0, rx679_pos, $I10)
  rxquantr728_loop:
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx679_pos, 2
    gt $I11, rx679_eos, rx679_fail
    sub $I11, rx679_pos, rx679_off
    substr $S10, rx679_tgt, $I11, 2
    ne $S10, "is", rx679_fail
    add rx679_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."name"()
    unless $P10, rx679_fail
    rx679_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parent")
    rx679_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
    set_addr $I10, rxquantr728_done
    (rx679_rep) = rx679_cur."!mark_commit"($I10)
  rxquantr728_done:
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
.annotate 'line', 356
  # rx rxquantr733 ** 0..*
    set_addr $I10, rxquantr733_done
    rx679_cur."!mark_push"(0, rx679_pos, $I10)
  rxquantr733_loop:
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
  # rx literal  "does"
    add $I11, rx679_pos, 4
    gt $I11, rx679_eos, rx679_fail
    sub $I11, rx679_pos, rx679_off
    substr $S10, rx679_tgt, $I11, 4
    ne $S10, "does", rx679_fail
    add rx679_pos, 4
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."name"()
    unless $P10, rx679_fail
    rx679_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("role")
    rx679_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
    set_addr $I10, rxquantr733_done
    (rx679_rep) = rx679_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr733_done
    rx679_cur."!mark_push"(rx679_rep, rx679_pos, $I10)
    goto rxquantr733_loop
  rxquantr733_done:
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
  alt738_0:
.annotate 'line', 357
    set_addr $I10, alt738_1
    rx679_cur."!mark_push"(0, rx679_pos, $I10)
.annotate 'line', 358
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx679_pos, 1
    gt $I11, rx679_eos, rx679_fail
    sub $I11, rx679_pos, rx679_off
    ord $I11, rx679_tgt, $I11
    ne $I11, 59, rx679_fail
    add rx679_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
  # rx subrule "comp_unit" subtype=capture negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."comp_unit"()
    unless $P10, rx679_fail
    rx679_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("comp_unit")
    rx679_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
    goto alt738_end
  alt738_1:
    set_addr $I10, alt738_2
    rx679_cur."!mark_push"(0, rx679_pos, $I10)
.annotate 'line', 359
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx679_pos, rx679_off
    substr $S10, rx679_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx679_fail
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
  # rx subrule "block" subtype=capture negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."block"()
    unless $P10, rx679_fail
    rx679_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx679_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
    goto alt738_end
  alt738_2:
.annotate 'line', 360
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."panic"("Malformed package declaration")
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
  alt738_end:
.annotate 'line', 361
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
.annotate 'line', 337
  # rx pass
    rx679_cur."!cursor_pass"(rx679_pos, "package_def")
    if_null rx679_debug, debug_888
    rx679_cur."!cursor_debug"("PASS", "package_def", " at pos=", rx679_pos)
  debug_888:
    .return (rx679_cur)
  rx679_restart:
.annotate 'line', 10
    if_null rx679_debug, debug_889
    rx679_cur."!cursor_debug"("NEXT", "package_def")
  debug_889:
  rx679_fail:
    (rx679_rep, rx679_pos, $I10, $P10) = rx679_cur."!mark_fail"(0)
    lt rx679_pos, -1, rx679_done
    eq rx679_pos, -1, rx679_fail
    jump $I10
  rx679_done:
    rx679_cur."!cursor_fail"()
    if_null rx679_debug, debug_890
    rx679_cur."!cursor_debug"("FAIL", "package_def")
  debug_890:
    .return (rx679_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_def"  :nsentry("!PREFIX__package_def") :subid("151_1300062003.824") :method
.annotate 'line', 10
    $P681 = self."!PREFIX__!subrule"("ws", "")
    new $P682, "ResizablePMCArray"
    push $P682, $P681
    .return ($P682)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block699"  :anon :subid("152_1300062003.824") :outer("150_1300062003.824")
.annotate 'line', 347
    $P701 = root_new ['parrot';'Hash']
    .lex "%args", $P701
.annotate 'line', 344
    find_lex $P702, "%args"
.annotate 'line', 348
    find_lex $P703, "$/"
    unless_null $P703, vivify_869
    $P703 = root_new ['parrot';'Hash']
  vivify_869:
    set $P704, $P703["name"]
    unless_null $P704, vivify_870
    new $P704, "Undef"
  vivify_870:
    set $S705, $P704
    new $P706, 'String'
    set $P706, $S705
    find_lex $P707, "%args"
    unless_null $P707, vivify_871
    $P707 = root_new ['parrot';'Hash']
    store_lex "%args", $P707
  vivify_871:
    set $P707["name"], $P706
.annotate 'line', 349
    find_lex $P709, "$/"
    unless_null $P709, vivify_872
    $P709 = root_new ['parrot';'Hash']
  vivify_872:
    set $P710, $P709["repr"]
    unless_null $P710, vivify_873
    new $P710, "Undef"
  vivify_873:
    unless $P710, if_708_end
.annotate 'line', 350
    find_lex $P711, "$/"
    unless_null $P711, vivify_874
    $P711 = root_new ['parrot';'Hash']
  vivify_874:
    set $P712, $P711["repr"]
    unless_null $P712, vivify_875
    $P712 = root_new ['parrot';'ResizablePMCArray']
  vivify_875:
    set $P713, $P712[0]
    unless_null $P713, vivify_876
    $P713 = root_new ['parrot';'Hash']
  vivify_876:
    set $P714, $P713["quote_delimited"]
    unless_null $P714, vivify_877
    $P714 = root_new ['parrot';'Hash']
  vivify_877:
    set $P715, $P714["quote_atom"]
    unless_null $P715, vivify_878
    $P715 = root_new ['parrot';'ResizablePMCArray']
  vivify_878:
    set $P716, $P715[0]
    unless_null $P716, vivify_879
    new $P716, "Undef"
  vivify_879:
    set $S717, $P716
    new $P718, 'String'
    set $P718, $S717
    find_lex $P719, "%args"
    unless_null $P719, vivify_880
    $P719 = root_new ['parrot';'Hash']
    store_lex "%args", $P719
  vivify_880:
    set $P719["repr"], $P718
  if_708_end:
.annotate 'line', 352
    find_dynamic_lex $P720, "$*SC"
    unless_null $P720, vivify_881
    get_hll_global $P720, "$SC"
    unless_null $P720, vivify_882
    die "Contextual $*SC not found"
  vivify_882:
  vivify_881:
    find_dynamic_lex $P721, "$*PKGDECL"
    unless_null $P721, vivify_883
    get_hll_global $P721, "$PKGDECL"
    unless_null $P721, vivify_884
    die "Contextual $*PKGDECL not found"
  vivify_884:
  vivify_883:
    find_dynamic_lex $P722, "%*HOW"
    unless_null $P722, vivify_885
    get_hll_global $P722, "%HOW"
    unless_null $P722, vivify_886
    die "Contextual %*HOW not found"
  vivify_886:
  vivify_885:
    set $P723, $P722[$P721]
    unless_null $P723, vivify_887
    new $P723, "Undef"
  vivify_887:
    find_lex $P724, "%args"
    $P725 = $P720."pkg_create_mo"($P723, $P724 :flat)
    store_dynamic_lex "$*PKGMETA", $P725
.annotate 'line', 344
    .return ($P725)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator"  :subid("153_1300062003.824")
    .param pmc param_749
.annotate 'line', 364
    .lex "self", param_749
    $P750 = param_749."!protoregex"("scope_declarator")
    .return ($P750)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator"  :subid("154_1300062003.824")
    .param pmc param_752
.annotate 'line', 364
    .lex "self", param_752
    $P753 = param_752."!PREFIX__!protoregex"("scope_declarator")
    .return ($P753)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<my>"  :subid("155_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx755_tgt
    .local int rx755_pos
    .local int rx755_off
    .local int rx755_eos
    .local int rx755_rep
    .local pmc rx755_cur
    .local pmc rx755_debug
    (rx755_cur, rx755_pos, rx755_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx755_cur
    .local pmc match
    .lex "$/", match
    length rx755_eos, rx755_tgt
    gt rx755_pos, rx755_eos, rx755_done
    set rx755_off, 0
    lt rx755_pos, 2, rx755_start
    sub rx755_off, rx755_pos, 1
    substr rx755_tgt, rx755_tgt, rx755_off
  rx755_start:
    eq $I10, 1, rx755_restart
    if_null rx755_debug, debug_891
    rx755_cur."!cursor_debug"("START", "scope_declarator:sym<my>")
  debug_891:
    $I10 = self.'from'()
    ne $I10, -1, rxscan759_done
    goto rxscan759_scan
  rxscan759_loop:
    (rx755_pos) = rx755_cur."from"()
    inc rx755_pos
    rx755_cur."!cursor_from"(rx755_pos)
    ge rx755_pos, rx755_eos, rxscan759_done
  rxscan759_scan:
    set_addr $I10, rxscan759_loop
    rx755_cur."!mark_push"(0, rx755_pos, $I10)
  rxscan759_done:
.annotate 'line', 365
  # rx subcapture "sym"
    set_addr $I10, rxcap_760_fail
    rx755_cur."!mark_push"(0, rx755_pos, $I10)
  # rx literal  "my"
    add $I11, rx755_pos, 2
    gt $I11, rx755_eos, rx755_fail
    sub $I11, rx755_pos, rx755_off
    substr $S10, rx755_tgt, $I11, 2
    ne $S10, "my", rx755_fail
    add rx755_pos, 2
    set_addr $I10, rxcap_760_fail
    ($I12, $I11) = rx755_cur."!mark_peek"($I10)
    rx755_cur."!cursor_pos"($I11)
    ($P10) = rx755_cur."!cursor_start"()
    $P10."!cursor_pass"(rx755_pos, "")
    rx755_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_760_done
  rxcap_760_fail:
    goto rx755_fail
  rxcap_760_done:
  # rx subrule "scoped" subtype=capture negate=
    rx755_cur."!cursor_pos"(rx755_pos)
    $P10 = rx755_cur."scoped"("my")
    unless $P10, rx755_fail
    rx755_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx755_pos = $P10."pos"()
  # rx pass
    rx755_cur."!cursor_pass"(rx755_pos, "scope_declarator:sym<my>")
    if_null rx755_debug, debug_892
    rx755_cur."!cursor_debug"("PASS", "scope_declarator:sym<my>", " at pos=", rx755_pos)
  debug_892:
    .return (rx755_cur)
  rx755_restart:
.annotate 'line', 10
    if_null rx755_debug, debug_893
    rx755_cur."!cursor_debug"("NEXT", "scope_declarator:sym<my>")
  debug_893:
  rx755_fail:
    (rx755_rep, rx755_pos, $I10, $P10) = rx755_cur."!mark_fail"(0)
    lt rx755_pos, -1, rx755_done
    eq rx755_pos, -1, rx755_fail
    jump $I10
  rx755_done:
    rx755_cur."!cursor_fail"()
    if_null rx755_debug, debug_894
    rx755_cur."!cursor_debug"("FAIL", "scope_declarator:sym<my>")
  debug_894:
    .return (rx755_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<my>"  :nsentry("!PREFIX__scope_declarator:sym<my>") :subid("156_1300062003.824") :method
.annotate 'line', 10
    $P757 = self."!PREFIX__!subrule"("scoped", "my")
    new $P758, "ResizablePMCArray"
    push $P758, $P757
    .return ($P758)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<our>"  :subid("157_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx762_tgt
    .local int rx762_pos
    .local int rx762_off
    .local int rx762_eos
    .local int rx762_rep
    .local pmc rx762_cur
    .local pmc rx762_debug
    (rx762_cur, rx762_pos, rx762_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx762_cur
    .local pmc match
    .lex "$/", match
    length rx762_eos, rx762_tgt
    gt rx762_pos, rx762_eos, rx762_done
    set rx762_off, 0
    lt rx762_pos, 2, rx762_start
    sub rx762_off, rx762_pos, 1
    substr rx762_tgt, rx762_tgt, rx762_off
  rx762_start:
    eq $I10, 1, rx762_restart
    if_null rx762_debug, debug_895
    rx762_cur."!cursor_debug"("START", "scope_declarator:sym<our>")
  debug_895:
    $I10 = self.'from'()
    ne $I10, -1, rxscan766_done
    goto rxscan766_scan
  rxscan766_loop:
    (rx762_pos) = rx762_cur."from"()
    inc rx762_pos
    rx762_cur."!cursor_from"(rx762_pos)
    ge rx762_pos, rx762_eos, rxscan766_done
  rxscan766_scan:
    set_addr $I10, rxscan766_loop
    rx762_cur."!mark_push"(0, rx762_pos, $I10)
  rxscan766_done:
.annotate 'line', 366
  # rx subcapture "sym"
    set_addr $I10, rxcap_767_fail
    rx762_cur."!mark_push"(0, rx762_pos, $I10)
  # rx literal  "our"
    add $I11, rx762_pos, 3
    gt $I11, rx762_eos, rx762_fail
    sub $I11, rx762_pos, rx762_off
    substr $S10, rx762_tgt, $I11, 3
    ne $S10, "our", rx762_fail
    add rx762_pos, 3
    set_addr $I10, rxcap_767_fail
    ($I12, $I11) = rx762_cur."!mark_peek"($I10)
    rx762_cur."!cursor_pos"($I11)
    ($P10) = rx762_cur."!cursor_start"()
    $P10."!cursor_pass"(rx762_pos, "")
    rx762_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_767_done
  rxcap_767_fail:
    goto rx762_fail
  rxcap_767_done:
  # rx subrule "scoped" subtype=capture negate=
    rx762_cur."!cursor_pos"(rx762_pos)
    $P10 = rx762_cur."scoped"("our")
    unless $P10, rx762_fail
    rx762_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx762_pos = $P10."pos"()
  # rx pass
    rx762_cur."!cursor_pass"(rx762_pos, "scope_declarator:sym<our>")
    if_null rx762_debug, debug_896
    rx762_cur."!cursor_debug"("PASS", "scope_declarator:sym<our>", " at pos=", rx762_pos)
  debug_896:
    .return (rx762_cur)
  rx762_restart:
.annotate 'line', 10
    if_null rx762_debug, debug_897
    rx762_cur."!cursor_debug"("NEXT", "scope_declarator:sym<our>")
  debug_897:
  rx762_fail:
    (rx762_rep, rx762_pos, $I10, $P10) = rx762_cur."!mark_fail"(0)
    lt rx762_pos, -1, rx762_done
    eq rx762_pos, -1, rx762_fail
    jump $I10
  rx762_done:
    rx762_cur."!cursor_fail"()
    if_null rx762_debug, debug_898
    rx762_cur."!cursor_debug"("FAIL", "scope_declarator:sym<our>")
  debug_898:
    .return (rx762_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<our>"  :nsentry("!PREFIX__scope_declarator:sym<our>") :subid("158_1300062003.824") :method
.annotate 'line', 10
    $P764 = self."!PREFIX__!subrule"("scoped", "our")
    new $P765, "ResizablePMCArray"
    push $P765, $P764
    .return ($P765)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<has>"  :subid("159_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx769_tgt
    .local int rx769_pos
    .local int rx769_off
    .local int rx769_eos
    .local int rx769_rep
    .local pmc rx769_cur
    .local pmc rx769_debug
    (rx769_cur, rx769_pos, rx769_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx769_cur
    .local pmc match
    .lex "$/", match
    length rx769_eos, rx769_tgt
    gt rx769_pos, rx769_eos, rx769_done
    set rx769_off, 0
    lt rx769_pos, 2, rx769_start
    sub rx769_off, rx769_pos, 1
    substr rx769_tgt, rx769_tgt, rx769_off
  rx769_start:
    eq $I10, 1, rx769_restart
    if_null rx769_debug, debug_899
    rx769_cur."!cursor_debug"("START", "scope_declarator:sym<has>")
  debug_899:
    $I10 = self.'from'()
    ne $I10, -1, rxscan773_done
    goto rxscan773_scan
  rxscan773_loop:
    (rx769_pos) = rx769_cur."from"()
    inc rx769_pos
    rx769_cur."!cursor_from"(rx769_pos)
    ge rx769_pos, rx769_eos, rxscan773_done
  rxscan773_scan:
    set_addr $I10, rxscan773_loop
    rx769_cur."!mark_push"(0, rx769_pos, $I10)
  rxscan773_done:
.annotate 'line', 367
  # rx subcapture "sym"
    set_addr $I10, rxcap_774_fail
    rx769_cur."!mark_push"(0, rx769_pos, $I10)
  # rx literal  "has"
    add $I11, rx769_pos, 3
    gt $I11, rx769_eos, rx769_fail
    sub $I11, rx769_pos, rx769_off
    substr $S10, rx769_tgt, $I11, 3
    ne $S10, "has", rx769_fail
    add rx769_pos, 3
    set_addr $I10, rxcap_774_fail
    ($I12, $I11) = rx769_cur."!mark_peek"($I10)
    rx769_cur."!cursor_pos"($I11)
    ($P10) = rx769_cur."!cursor_start"()
    $P10."!cursor_pass"(rx769_pos, "")
    rx769_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_774_done
  rxcap_774_fail:
    goto rx769_fail
  rxcap_774_done:
  # rx subrule "scoped" subtype=capture negate=
    rx769_cur."!cursor_pos"(rx769_pos)
    $P10 = rx769_cur."scoped"("has")
    unless $P10, rx769_fail
    rx769_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx769_pos = $P10."pos"()
  # rx pass
    rx769_cur."!cursor_pass"(rx769_pos, "scope_declarator:sym<has>")
    if_null rx769_debug, debug_900
    rx769_cur."!cursor_debug"("PASS", "scope_declarator:sym<has>", " at pos=", rx769_pos)
  debug_900:
    .return (rx769_cur)
  rx769_restart:
.annotate 'line', 10
    if_null rx769_debug, debug_901
    rx769_cur."!cursor_debug"("NEXT", "scope_declarator:sym<has>")
  debug_901:
  rx769_fail:
    (rx769_rep, rx769_pos, $I10, $P10) = rx769_cur."!mark_fail"(0)
    lt rx769_pos, -1, rx769_done
    eq rx769_pos, -1, rx769_fail
    jump $I10
  rx769_done:
    rx769_cur."!cursor_fail"()
    if_null rx769_debug, debug_902
    rx769_cur."!cursor_debug"("FAIL", "scope_declarator:sym<has>")
  debug_902:
    .return (rx769_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<has>"  :nsentry("!PREFIX__scope_declarator:sym<has>") :subid("160_1300062003.824") :method
.annotate 'line', 10
    $P771 = self."!PREFIX__!subrule"("scoped", "has")
    new $P772, "ResizablePMCArray"
    push $P772, $P771
    .return ($P772)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scoped"  :subid("161_1300062003.824") :method :outer("12_1300062003.824")
    .param pmc param_776
.annotate 'line', 369
    .lex "$*SCOPE", param_776
.annotate 'line', 10
    .local string rx777_tgt
    .local int rx777_pos
    .local int rx777_off
    .local int rx777_eos
    .local int rx777_rep
    .local pmc rx777_cur
    .local pmc rx777_debug
    (rx777_cur, rx777_pos, rx777_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx777_cur
    .local pmc match
    .lex "$/", match
    length rx777_eos, rx777_tgt
    gt rx777_pos, rx777_eos, rx777_done
    set rx777_off, 0
    lt rx777_pos, 2, rx777_start
    sub rx777_off, rx777_pos, 1
    substr rx777_tgt, rx777_tgt, rx777_off
  rx777_start:
    eq $I10, 1, rx777_restart
    if_null rx777_debug, debug_903
    rx777_cur."!cursor_debug"("START", "scoped")
  debug_903:
    $I10 = self.'from'()
    ne $I10, -1, rxscan783_done
    goto rxscan783_scan
  rxscan783_loop:
    (rx777_pos) = rx777_cur."from"()
    inc rx777_pos
    rx777_cur."!cursor_from"(rx777_pos)
    ge rx777_pos, rx777_eos, rxscan783_done
  rxscan783_scan:
    set_addr $I10, rxscan783_loop
    rx777_cur."!mark_push"(0, rx777_pos, $I10)
  rxscan783_done:
  alt784_0:
.annotate 'line', 369
    set_addr $I10, alt784_1
    rx777_cur."!mark_push"(0, rx777_pos, $I10)
.annotate 'line', 370
  # rx subrule "ws" subtype=method negate=
    rx777_cur."!cursor_pos"(rx777_pos)
    $P10 = rx777_cur."ws"()
    unless $P10, rx777_fail
    rx777_pos = $P10."pos"()
  # rx subrule "declarator" subtype=capture negate=
    rx777_cur."!cursor_pos"(rx777_pos)
    $P10 = rx777_cur."declarator"()
    unless $P10, rx777_fail
    rx777_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx777_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx777_cur."!cursor_pos"(rx777_pos)
    $P10 = rx777_cur."ws"()
    unless $P10, rx777_fail
    rx777_pos = $P10."pos"()
    goto alt784_end
  alt784_1:
    set_addr $I10, alt784_2
    rx777_cur."!mark_push"(0, rx777_pos, $I10)
.annotate 'line', 371
  # rx subrule "ws" subtype=method negate=
    rx777_cur."!cursor_pos"(rx777_pos)
    $P10 = rx777_cur."ws"()
    unless $P10, rx777_fail
    rx777_pos = $P10."pos"()
  # rx subrule "multi_declarator" subtype=capture negate=
    rx777_cur."!cursor_pos"(rx777_pos)
    $P10 = rx777_cur."multi_declarator"()
    unless $P10, rx777_fail
    rx777_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx777_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx777_cur."!cursor_pos"(rx777_pos)
    $P10 = rx777_cur."ws"()
    unless $P10, rx777_fail
    rx777_pos = $P10."pos"()
    goto alt784_end
  alt784_2:
.annotate 'line', 372
  # rx subrule "ws" subtype=method negate=
    rx777_cur."!cursor_pos"(rx777_pos)
    $P10 = rx777_cur."ws"()
    unless $P10, rx777_fail
    rx777_pos = $P10."pos"()
  # rx subrule "package_declarator" subtype=capture negate=
    rx777_cur."!cursor_pos"(rx777_pos)
    $P10 = rx777_cur."package_declarator"()
    unless $P10, rx777_fail
    rx777_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx777_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx777_cur."!cursor_pos"(rx777_pos)
    $P10 = rx777_cur."ws"()
    unless $P10, rx777_fail
    rx777_pos = $P10."pos"()
  alt784_end:
.annotate 'line', 369
  # rx pass
    rx777_cur."!cursor_pass"(rx777_pos, "scoped")
    if_null rx777_debug, debug_904
    rx777_cur."!cursor_debug"("PASS", "scoped", " at pos=", rx777_pos)
  debug_904:
    .return (rx777_cur)
  rx777_restart:
.annotate 'line', 10
    if_null rx777_debug, debug_905
    rx777_cur."!cursor_debug"("NEXT", "scoped")
  debug_905:
  rx777_fail:
    (rx777_rep, rx777_pos, $I10, $P10) = rx777_cur."!mark_fail"(0)
    lt rx777_pos, -1, rx777_done
    eq rx777_pos, -1, rx777_fail
    jump $I10
  rx777_done:
    rx777_cur."!cursor_fail"()
    if_null rx777_debug, debug_906
    rx777_cur."!cursor_debug"("FAIL", "scoped")
  debug_906:
    .return (rx777_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scoped"  :nsentry("!PREFIX__scoped") :subid("162_1300062003.824") :method
.annotate 'line', 10
    $P779 = self."!PREFIX__!subrule"("ws", "")
    $P780 = self."!PREFIX__!subrule"("ws", "")
    $P781 = self."!PREFIX__!subrule"("ws", "")
    new $P782, "ResizablePMCArray"
    push $P782, $P779
    push $P782, $P780
    push $P782, $P781
    .return ($P782)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "typename"  :subid("163_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx792_tgt
    .local int rx792_pos
    .local int rx792_off
    .local int rx792_eos
    .local int rx792_rep
    .local pmc rx792_cur
    .local pmc rx792_debug
    (rx792_cur, rx792_pos, rx792_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx792_cur
    .local pmc match
    .lex "$/", match
    length rx792_eos, rx792_tgt
    gt rx792_pos, rx792_eos, rx792_done
    set rx792_off, 0
    lt rx792_pos, 2, rx792_start
    sub rx792_off, rx792_pos, 1
    substr rx792_tgt, rx792_tgt, rx792_off
  rx792_start:
    eq $I10, 1, rx792_restart
    if_null rx792_debug, debug_907
    rx792_cur."!cursor_debug"("START", "typename")
  debug_907:
    $I10 = self.'from'()
    ne $I10, -1, rxscan796_done
    goto rxscan796_scan
  rxscan796_loop:
    (rx792_pos) = rx792_cur."from"()
    inc rx792_pos
    rx792_cur."!cursor_from"(rx792_pos)
    ge rx792_pos, rx792_eos, rxscan796_done
  rxscan796_scan:
    set_addr $I10, rxscan796_loop
    rx792_cur."!mark_push"(0, rx792_pos, $I10)
  rxscan796_done:
.annotate 'line', 375
  # rx subrule "name" subtype=capture negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."name"()
    unless $P10, rx792_fail
    rx792_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx792_pos = $P10."pos"()
  # rx pass
    rx792_cur."!cursor_pass"(rx792_pos, "typename")
    if_null rx792_debug, debug_908
    rx792_cur."!cursor_debug"("PASS", "typename", " at pos=", rx792_pos)
  debug_908:
    .return (rx792_cur)
  rx792_restart:
.annotate 'line', 10
    if_null rx792_debug, debug_909
    rx792_cur."!cursor_debug"("NEXT", "typename")
  debug_909:
  rx792_fail:
    (rx792_rep, rx792_pos, $I10, $P10) = rx792_cur."!mark_fail"(0)
    lt rx792_pos, -1, rx792_done
    eq rx792_pos, -1, rx792_fail
    jump $I10
  rx792_done:
    rx792_cur."!cursor_fail"()
    if_null rx792_debug, debug_910
    rx792_cur."!cursor_debug"("FAIL", "typename")
  debug_910:
    .return (rx792_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__typename"  :nsentry("!PREFIX__typename") :subid("164_1300062003.824") :method
.annotate 'line', 10
    $P794 = self."!PREFIX__!subrule"("name", "")
    new $P795, "ResizablePMCArray"
    push $P795, $P794
    .return ($P795)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "declarator"  :subid("165_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx798_tgt
    .local int rx798_pos
    .local int rx798_off
    .local int rx798_eos
    .local int rx798_rep
    .local pmc rx798_cur
    .local pmc rx798_debug
    (rx798_cur, rx798_pos, rx798_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx798_cur
    .local pmc match
    .lex "$/", match
    length rx798_eos, rx798_tgt
    gt rx798_pos, rx798_eos, rx798_done
    set rx798_off, 0
    lt rx798_pos, 2, rx798_start
    sub rx798_off, rx798_pos, 1
    substr rx798_tgt, rx798_tgt, rx798_off
  rx798_start:
    eq $I10, 1, rx798_restart
    if_null rx798_debug, debug_911
    rx798_cur."!cursor_debug"("START", "declarator")
  debug_911:
    $I10 = self.'from'()
    ne $I10, -1, rxscan803_done
    goto rxscan803_scan
  rxscan803_loop:
    (rx798_pos) = rx798_cur."from"()
    inc rx798_pos
    rx798_cur."!cursor_from"(rx798_pos)
    ge rx798_pos, rx798_eos, rxscan803_done
  rxscan803_scan:
    set_addr $I10, rxscan803_loop
    rx798_cur."!mark_push"(0, rx798_pos, $I10)
  rxscan803_done:
  alt804_0:
.annotate 'line', 377
    set_addr $I10, alt804_1
    rx798_cur."!mark_push"(0, rx798_pos, $I10)
.annotate 'line', 378
  # rx subrule "variable_declarator" subtype=capture negate=
    rx798_cur."!cursor_pos"(rx798_pos)
    $P10 = rx798_cur."variable_declarator"()
    unless $P10, rx798_fail
    rx798_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable_declarator")
    rx798_pos = $P10."pos"()
    goto alt804_end
  alt804_1:
.annotate 'line', 379
  # rx subrule "routine_declarator" subtype=capture negate=
    rx798_cur."!cursor_pos"(rx798_pos)
    $P10 = rx798_cur."routine_declarator"()
    unless $P10, rx798_fail
    rx798_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx798_pos = $P10."pos"()
  alt804_end:
.annotate 'line', 377
  # rx pass
    rx798_cur."!cursor_pass"(rx798_pos, "declarator")
    if_null rx798_debug, debug_912
    rx798_cur."!cursor_debug"("PASS", "declarator", " at pos=", rx798_pos)
  debug_912:
    .return (rx798_cur)
  rx798_restart:
.annotate 'line', 10
    if_null rx798_debug, debug_913
    rx798_cur."!cursor_debug"("NEXT", "declarator")
  debug_913:
  rx798_fail:
    (rx798_rep, rx798_pos, $I10, $P10) = rx798_cur."!mark_fail"(0)
    lt rx798_pos, -1, rx798_done
    eq rx798_pos, -1, rx798_fail
    jump $I10
  rx798_done:
    rx798_cur."!cursor_fail"()
    if_null rx798_debug, debug_914
    rx798_cur."!cursor_debug"("FAIL", "declarator")
  debug_914:
    .return (rx798_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__declarator"  :nsentry("!PREFIX__declarator") :subid("166_1300062003.824") :method
.annotate 'line', 10
    $P800 = self."!PREFIX__!subrule"("routine_declarator", "")
    $P801 = self."!PREFIX__!subrule"("variable_declarator", "")
    new $P802, "ResizablePMCArray"
    push $P802, $P800
    push $P802, $P801
    .return ($P802)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable_declarator"  :subid("167_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx806_tgt
    .local int rx806_pos
    .local int rx806_off
    .local int rx806_eos
    .local int rx806_rep
    .local pmc rx806_cur
    .local pmc rx806_debug
    (rx806_cur, rx806_pos, rx806_tgt, $I10) = self."!cursor_start"()
    rx806_cur."!cursor_caparray"("typename")
    .lex unicode:"$\x{a2}", rx806_cur
    .local pmc match
    .lex "$/", match
    length rx806_eos, rx806_tgt
    gt rx806_pos, rx806_eos, rx806_done
    set rx806_off, 0
    lt rx806_pos, 2, rx806_start
    sub rx806_off, rx806_pos, 1
    substr rx806_tgt, rx806_tgt, rx806_off
  rx806_start:
    eq $I10, 1, rx806_restart
    if_null rx806_debug, debug_915
    rx806_cur."!cursor_debug"("START", "variable_declarator")
  debug_915:
    $I10 = self.'from'()
    ne $I10, -1, rxscan810_done
    goto rxscan810_scan
  rxscan810_loop:
    (rx806_pos) = rx806_cur."from"()
    inc rx806_pos
    rx806_cur."!cursor_from"(rx806_pos)
    ge rx806_pos, rx806_eos, rxscan810_done
  rxscan810_scan:
    set_addr $I10, rxscan810_loop
    rx806_cur."!mark_push"(0, rx806_pos, $I10)
  rxscan810_done:
.annotate 'line', 382
  # rx subrule "ws" subtype=method negate=
    rx806_cur."!cursor_pos"(rx806_pos)
    $P10 = rx806_cur."ws"()
    unless $P10, rx806_fail
    rx806_pos = $P10."pos"()
  # rx rxquantr812 ** 0..1
    set_addr $I10, rxquantr812_done
    rx806_cur."!mark_push"(0, rx806_pos, $I10)
  rxquantr812_loop:
  # rx subrule "typename" subtype=capture negate=
    rx806_cur."!cursor_pos"(rx806_pos)
    $P10 = rx806_cur."typename"()
    unless $P10, rx806_fail
    goto rxsubrule813_pass
  rxsubrule813_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx806_fail
  rxsubrule813_pass:
    set_addr $I10, rxsubrule813_back
    rx806_cur."!mark_push"(0, rx806_pos, $I10, $P10)
    $P10."!cursor_names"("typename")
    rx806_pos = $P10."pos"()
    set_addr $I10, rxquantr812_done
    (rx806_rep) = rx806_cur."!mark_commit"($I10)
  rxquantr812_done:
  # rx subrule "ws" subtype=method negate=
    rx806_cur."!cursor_pos"(rx806_pos)
    $P10 = rx806_cur."ws"()
    unless $P10, rx806_fail
    rx806_pos = $P10."pos"()
  # rx subrule "variable" subtype=capture negate=
    rx806_cur."!cursor_pos"(rx806_pos)
    $P10 = rx806_cur."variable"()
    unless $P10, rx806_fail
    rx806_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx806_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx806_cur."!cursor_pos"(rx806_pos)
    $P10 = rx806_cur."ws"()
    unless $P10, rx806_fail
    rx806_pos = $P10."pos"()
  # rx pass
    rx806_cur."!cursor_pass"(rx806_pos, "variable_declarator")
    if_null rx806_debug, debug_916
    rx806_cur."!cursor_debug"("PASS", "variable_declarator", " at pos=", rx806_pos)
  debug_916:
    .return (rx806_cur)
  rx806_restart:
.annotate 'line', 10
    if_null rx806_debug, debug_917
    rx806_cur."!cursor_debug"("NEXT", "variable_declarator")
  debug_917:
  rx806_fail:
    (rx806_rep, rx806_pos, $I10, $P10) = rx806_cur."!mark_fail"(0)
    lt rx806_pos, -1, rx806_done
    eq rx806_pos, -1, rx806_fail
    jump $I10
  rx806_done:
    rx806_cur."!cursor_fail"()
    if_null rx806_debug, debug_918
    rx806_cur."!cursor_debug"("FAIL", "variable_declarator")
  debug_918:
    .return (rx806_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable_declarator"  :nsentry("!PREFIX__variable_declarator") :subid("168_1300062003.824") :method
.annotate 'line', 10
    $P808 = self."!PREFIX__!subrule"("ws", "")
    new $P809, "ResizablePMCArray"
    push $P809, $P808
    .return ($P809)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator"  :subid("169_1300062003.824")
    .param pmc param_817
.annotate 'line', 384
    .lex "self", param_817
    $P818 = param_817."!protoregex"("routine_declarator")
    .return ($P818)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator"  :subid("170_1300062003.824")
    .param pmc param_820
.annotate 'line', 384
    .lex "self", param_820
    $P821 = param_820."!PREFIX__!protoregex"("routine_declarator")
    .return ($P821)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<sub>"  :subid("171_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx823_tgt
    .local int rx823_pos
    .local int rx823_off
    .local int rx823_eos
    .local int rx823_rep
    .local pmc rx823_cur
    .local pmc rx823_debug
    (rx823_cur, rx823_pos, rx823_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx823_cur
    .local pmc match
    .lex "$/", match
    length rx823_eos, rx823_tgt
    gt rx823_pos, rx823_eos, rx823_done
    set rx823_off, 0
    lt rx823_pos, 2, rx823_start
    sub rx823_off, rx823_pos, 1
    substr rx823_tgt, rx823_tgt, rx823_off
  rx823_start:
    eq $I10, 1, rx823_restart
    if_null rx823_debug, debug_919
    rx823_cur."!cursor_debug"("START", "routine_declarator:sym<sub>")
  debug_919:
    $I10 = self.'from'()
    ne $I10, -1, rxscan827_done
    goto rxscan827_scan
  rxscan827_loop:
    (rx823_pos) = rx823_cur."from"()
    inc rx823_pos
    rx823_cur."!cursor_from"(rx823_pos)
    ge rx823_pos, rx823_eos, rxscan827_done
  rxscan827_scan:
    set_addr $I10, rxscan827_loop
    rx823_cur."!mark_push"(0, rx823_pos, $I10)
  rxscan827_done:
.annotate 'line', 385
  # rx subcapture "sym"
    set_addr $I10, rxcap_828_fail
    rx823_cur."!mark_push"(0, rx823_pos, $I10)
  # rx literal  "sub"
    add $I11, rx823_pos, 3
    gt $I11, rx823_eos, rx823_fail
    sub $I11, rx823_pos, rx823_off
    substr $S10, rx823_tgt, $I11, 3
    ne $S10, "sub", rx823_fail
    add rx823_pos, 3
    set_addr $I10, rxcap_828_fail
    ($I12, $I11) = rx823_cur."!mark_peek"($I10)
    rx823_cur."!cursor_pos"($I11)
    ($P10) = rx823_cur."!cursor_start"()
    $P10."!cursor_pass"(rx823_pos, "")
    rx823_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_828_done
  rxcap_828_fail:
    goto rx823_fail
  rxcap_828_done:
  # rx subrule "routine_def" subtype=capture negate=
    rx823_cur."!cursor_pos"(rx823_pos)
    $P10 = rx823_cur."routine_def"()
    unless $P10, rx823_fail
    rx823_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx823_pos = $P10."pos"()
  # rx pass
    rx823_cur."!cursor_pass"(rx823_pos, "routine_declarator:sym<sub>")
    if_null rx823_debug, debug_920
    rx823_cur."!cursor_debug"("PASS", "routine_declarator:sym<sub>", " at pos=", rx823_pos)
  debug_920:
    .return (rx823_cur)
  rx823_restart:
.annotate 'line', 10
    if_null rx823_debug, debug_921
    rx823_cur."!cursor_debug"("NEXT", "routine_declarator:sym<sub>")
  debug_921:
  rx823_fail:
    (rx823_rep, rx823_pos, $I10, $P10) = rx823_cur."!mark_fail"(0)
    lt rx823_pos, -1, rx823_done
    eq rx823_pos, -1, rx823_fail
    jump $I10
  rx823_done:
    rx823_cur."!cursor_fail"()
    if_null rx823_debug, debug_922
    rx823_cur."!cursor_debug"("FAIL", "routine_declarator:sym<sub>")
  debug_922:
    .return (rx823_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<sub>"  :nsentry("!PREFIX__routine_declarator:sym<sub>") :subid("172_1300062003.824") :method
.annotate 'line', 10
    $P825 = self."!PREFIX__!subrule"("routine_def", "sub")
    new $P826, "ResizablePMCArray"
    push $P826, $P825
    .return ($P826)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<method>"  :subid("173_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx830_tgt
    .local int rx830_pos
    .local int rx830_off
    .local int rx830_eos
    .local int rx830_rep
    .local pmc rx830_cur
    .local pmc rx830_debug
    (rx830_cur, rx830_pos, rx830_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx830_cur
    .local pmc match
    .lex "$/", match
    length rx830_eos, rx830_tgt
    gt rx830_pos, rx830_eos, rx830_done
    set rx830_off, 0
    lt rx830_pos, 2, rx830_start
    sub rx830_off, rx830_pos, 1
    substr rx830_tgt, rx830_tgt, rx830_off
  rx830_start:
    eq $I10, 1, rx830_restart
    if_null rx830_debug, debug_923
    rx830_cur."!cursor_debug"("START", "routine_declarator:sym<method>")
  debug_923:
    $I10 = self.'from'()
    ne $I10, -1, rxscan834_done
    goto rxscan834_scan
  rxscan834_loop:
    (rx830_pos) = rx830_cur."from"()
    inc rx830_pos
    rx830_cur."!cursor_from"(rx830_pos)
    ge rx830_pos, rx830_eos, rxscan834_done
  rxscan834_scan:
    set_addr $I10, rxscan834_loop
    rx830_cur."!mark_push"(0, rx830_pos, $I10)
  rxscan834_done:
.annotate 'line', 386
  # rx subcapture "sym"
    set_addr $I10, rxcap_835_fail
    rx830_cur."!mark_push"(0, rx830_pos, $I10)
  # rx literal  "method"
    add $I11, rx830_pos, 6
    gt $I11, rx830_eos, rx830_fail
    sub $I11, rx830_pos, rx830_off
    substr $S10, rx830_tgt, $I11, 6
    ne $S10, "method", rx830_fail
    add rx830_pos, 6
    set_addr $I10, rxcap_835_fail
    ($I12, $I11) = rx830_cur."!mark_peek"($I10)
    rx830_cur."!cursor_pos"($I11)
    ($P10) = rx830_cur."!cursor_start"()
    $P10."!cursor_pass"(rx830_pos, "")
    rx830_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_835_done
  rxcap_835_fail:
    goto rx830_fail
  rxcap_835_done:
  # rx subrule "method_def" subtype=capture negate=
    rx830_cur."!cursor_pos"(rx830_pos)
    $P10 = rx830_cur."method_def"()
    unless $P10, rx830_fail
    rx830_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("method_def")
    rx830_pos = $P10."pos"()
  # rx pass
    rx830_cur."!cursor_pass"(rx830_pos, "routine_declarator:sym<method>")
    if_null rx830_debug, debug_924
    rx830_cur."!cursor_debug"("PASS", "routine_declarator:sym<method>", " at pos=", rx830_pos)
  debug_924:
    .return (rx830_cur)
  rx830_restart:
.annotate 'line', 10
    if_null rx830_debug, debug_925
    rx830_cur."!cursor_debug"("NEXT", "routine_declarator:sym<method>")
  debug_925:
  rx830_fail:
    (rx830_rep, rx830_pos, $I10, $P10) = rx830_cur."!mark_fail"(0)
    lt rx830_pos, -1, rx830_done
    eq rx830_pos, -1, rx830_fail
    jump $I10
  rx830_done:
    rx830_cur."!cursor_fail"()
    if_null rx830_debug, debug_926
    rx830_cur."!cursor_debug"("FAIL", "routine_declarator:sym<method>")
  debug_926:
    .return (rx830_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<method>"  :nsentry("!PREFIX__routine_declarator:sym<method>") :subid("174_1300062003.824") :method
.annotate 'line', 10
    $P832 = self."!PREFIX__!subrule"("method_def", "method")
    new $P833, "ResizablePMCArray"
    push $P833, $P832
    .return ($P833)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_def"  :subid("175_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 389
    new $P837, "Undef"
    .lex "$*RETURN_USED", $P837
.annotate 'line', 10
    .local string rx838_tgt
    .local int rx838_pos
    .local int rx838_off
    .local int rx838_eos
    .local int rx838_rep
    .local pmc rx838_cur
    .local pmc rx838_debug
    (rx838_cur, rx838_pos, rx838_tgt, $I10) = self."!cursor_start"()
    rx838_cur."!cursor_caparray"("sigil", "deflongname", "trait")
    .lex unicode:"$\x{a2}", rx838_cur
    .local pmc match
    .lex "$/", match
    length rx838_eos, rx838_tgt
    gt rx838_pos, rx838_eos, rx838_done
    set rx838_off, 0
    lt rx838_pos, 2, rx838_start
    sub rx838_off, rx838_pos, 1
    substr rx838_tgt, rx838_tgt, rx838_off
  rx838_start:
    eq $I10, 1, rx838_restart
    if_null rx838_debug, debug_927
    rx838_cur."!cursor_debug"("START", "routine_def")
  debug_927:
    $I10 = self.'from'()
    ne $I10, -1, rxscan842_done
    goto rxscan842_scan
  rxscan842_loop:
    (rx838_pos) = rx838_cur."from"()
    inc rx838_pos
    rx838_cur."!cursor_from"(rx838_pos)
    ge rx838_pos, rx838_eos, rxscan842_done
  rxscan842_scan:
    set_addr $I10, rxscan842_loop
    rx838_cur."!mark_push"(0, rx838_pos, $I10)
  rxscan842_done:
.annotate 'line', 388
  # rx subrule "ws" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."ws"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
.annotate 'line', 389
    rx838_cur."!cursor_pos"(rx838_pos)
    new $P844, "Integer"
    assign $P844, 0
    store_lex "$*RETURN_USED", $P844
  # rx subrule "ws" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."ws"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
.annotate 'line', 390
  # rx rxquantr846 ** 0..1
    set_addr $I10, rxquantr846_done
    rx838_cur."!mark_push"(0, rx838_pos, $I10)
  rxquantr846_loop:
  # rx subrule "ws" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."ws"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
  # rx subcapture "sigil"
    set_addr $I10, rxcap_849_fail
    rx838_cur."!mark_push"(0, rx838_pos, $I10)
  # rx rxquantr848 ** 0..1
    set_addr $I10, rxquantr848_done
    rx838_cur."!mark_push"(0, rx838_pos, $I10)
  rxquantr848_loop:
  # rx literal  "&"
    add $I11, rx838_pos, 1
    gt $I11, rx838_eos, rx838_fail
    sub $I11, rx838_pos, rx838_off
    ord $I11, rx838_tgt, $I11
    ne $I11, 38, rx838_fail
    add rx838_pos, 1
    set_addr $I10, rxquantr848_done
    (rx838_rep) = rx838_cur."!mark_commit"($I10)
  rxquantr848_done:
    set_addr $I10, rxcap_849_fail
    ($I12, $I11) = rx838_cur."!mark_peek"($I10)
    rx838_cur."!cursor_pos"($I11)
    ($P10) = rx838_cur."!cursor_start"()
    $P10."!cursor_pass"(rx838_pos, "")
    rx838_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_849_done
  rxcap_849_fail:
    goto rx838_fail
  rxcap_849_done:
  # rx subrule "deflongname" subtype=capture negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."deflongname"()
    unless $P10, rx838_fail
    rx838_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx838_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."ws"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
    set_addr $I10, rxquantr846_done
    (rx838_rep) = rx838_cur."!mark_commit"($I10)
  rxquantr846_done:
  # rx subrule "ws" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."ws"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
.annotate 'line', 391
  # rx subrule "newpad" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."newpad"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."ws"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
  alt853_0:
.annotate 'line', 392
    set_addr $I10, alt853_1
    rx838_cur."!mark_push"(0, rx838_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."ws"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx838_pos, 1
    gt $I11, rx838_eos, rx838_fail
    sub $I11, rx838_pos, rx838_off
    ord $I11, rx838_tgt, $I11
    ne $I11, 40, rx838_fail
    add rx838_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."ws"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."signature"()
    unless $P10, rx838_fail
    rx838_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx838_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."ws"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx838_pos, 1
    gt $I11, rx838_eos, rx838_fail
    sub $I11, rx838_pos, rx838_off
    ord $I11, rx838_tgt, $I11
    ne $I11, 41, rx838_fail
    add rx838_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."ws"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
    goto alt853_end
  alt853_1:
.annotate 'line', 393
  # rx subrule "ws" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."ws"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."ws"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
  alt853_end:
  # rx subrule "ws" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."ws"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
.annotate 'line', 394
  # rx rxquantr861 ** 0..*
    set_addr $I10, rxquantr861_done
    rx838_cur."!mark_push"(0, rx838_pos, $I10)
  rxquantr861_loop:
  # rx subrule "trait" subtype=capture negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."trait"()
    unless $P10, rx838_fail
    goto rxsubrule862_pass
  rxsubrule862_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx838_fail
  rxsubrule862_pass:
    set_addr $I10, rxsubrule862_back
    rx838_cur."!mark_push"(0, rx838_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx838_pos = $P10."pos"()
    set_addr $I10, rxquantr861_done
    (rx838_rep) = rx838_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr861_done
    rx838_cur."!mark_push"(rx838_rep, rx838_pos, $I10)
    goto rxquantr861_loop
  rxquantr861_done:
  # rx subrule "ws" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."ws"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
  alt864_0:
.annotate 'line', 395
    set_addr $I10, alt864_1
    rx838_cur."!mark_push"(0, rx838_pos, $I10)
.annotate 'line', 396
  # rx subrule "ws" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."ws"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."onlystar"()
    unless $P10, rx838_fail
    rx838_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx838_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."ws"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
    goto alt864_end
  alt864_1:
.annotate 'line', 397
  # rx subrule "ws" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."ws"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."blockoid"()
    unless $P10, rx838_fail
    rx838_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx838_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."ws"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
  alt864_end:
.annotate 'line', 398
  # rx subrule "ws" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."ws"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
.annotate 'line', 388
  # rx pass
    rx838_cur."!cursor_pass"(rx838_pos, "routine_def")
    if_null rx838_debug, debug_928
    rx838_cur."!cursor_debug"("PASS", "routine_def", " at pos=", rx838_pos)
  debug_928:
    .return (rx838_cur)
  rx838_restart:
.annotate 'line', 10
    if_null rx838_debug, debug_929
    rx838_cur."!cursor_debug"("NEXT", "routine_def")
  debug_929:
  rx838_fail:
    (rx838_rep, rx838_pos, $I10, $P10) = rx838_cur."!mark_fail"(0)
    lt rx838_pos, -1, rx838_done
    eq rx838_pos, -1, rx838_fail
    jump $I10
  rx838_done:
    rx838_cur."!cursor_fail"()
    if_null rx838_debug, debug_930
    rx838_cur."!cursor_debug"("FAIL", "routine_def")
  debug_930:
    .return (rx838_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_def"  :nsentry("!PREFIX__routine_def") :subid("176_1300062003.824") :method
.annotate 'line', 10
    $P840 = self."!PREFIX__!subrule"("ws", "")
    new $P841, "ResizablePMCArray"
    push $P841, $P840
    .return ($P841)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "method_def"  :subid("177_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .const 'Sub' $P901 = "179_1300062003.824" 
    capture_lex $P901
.annotate 'line', 402
    new $P871, "Undef"
    .lex "$*RETURN_USED", $P871
.annotate 'line', 403
    new $P872, "Undef"
    .lex "$*INVOCANT_OK", $P872
.annotate 'line', 10
    .local string rx873_tgt
    .local int rx873_pos
    .local int rx873_off
    .local int rx873_eos
    .local int rx873_rep
    .local pmc rx873_cur
    .local pmc rx873_debug
    (rx873_cur, rx873_pos, rx873_tgt, $I10) = self."!cursor_start"()
    rx873_cur."!cursor_caparray"("deflongname", "trait")
    .lex unicode:"$\x{a2}", rx873_cur
    .local pmc match
    .lex "$/", match
    length rx873_eos, rx873_tgt
    gt rx873_pos, rx873_eos, rx873_done
    set rx873_off, 0
    lt rx873_pos, 2, rx873_start
    sub rx873_off, rx873_pos, 1
    substr rx873_tgt, rx873_tgt, rx873_off
  rx873_start:
    eq $I10, 1, rx873_restart
    if_null rx873_debug, debug_931
    rx873_cur."!cursor_debug"("START", "method_def")
  debug_931:
    $I10 = self.'from'()
    ne $I10, -1, rxscan877_done
    goto rxscan877_scan
  rxscan877_loop:
    (rx873_pos) = rx873_cur."from"()
    inc rx873_pos
    rx873_cur."!cursor_from"(rx873_pos)
    ge rx873_pos, rx873_eos, rxscan877_done
  rxscan877_scan:
    set_addr $I10, rxscan877_loop
    rx873_cur."!mark_push"(0, rx873_pos, $I10)
  rxscan877_done:
.annotate 'line', 401
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
.annotate 'line', 402
    rx873_cur."!cursor_pos"(rx873_pos)
    new $P879, "Integer"
    assign $P879, 0
    store_lex "$*RETURN_USED", $P879
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
.annotate 'line', 403
    rx873_cur."!cursor_pos"(rx873_pos)
    new $P881, "Integer"
    assign $P881, 1
    store_lex "$*INVOCANT_OK", $P881
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
.annotate 'line', 404
  # rx subcapture "private"
    set_addr $I10, rxcap_884_fail
    rx873_cur."!mark_push"(0, rx873_pos, $I10)
  # rx rxquantr883 ** 0..1
    set_addr $I10, rxquantr883_done
    rx873_cur."!mark_push"(0, rx873_pos, $I10)
  rxquantr883_loop:
  # rx literal  "!"
    add $I11, rx873_pos, 1
    gt $I11, rx873_eos, rx873_fail
    sub $I11, rx873_pos, rx873_off
    ord $I11, rx873_tgt, $I11
    ne $I11, 33, rx873_fail
    add rx873_pos, 1
    set_addr $I10, rxquantr883_done
    (rx873_rep) = rx873_cur."!mark_commit"($I10)
  rxquantr883_done:
    set_addr $I10, rxcap_884_fail
    ($I12, $I11) = rx873_cur."!mark_peek"($I10)
    rx873_cur."!cursor_pos"($I11)
    ($P10) = rx873_cur."!cursor_start"()
    $P10."!cursor_pass"(rx873_pos, "")
    rx873_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("private")
    goto rxcap_884_done
  rxcap_884_fail:
    goto rx873_fail
  rxcap_884_done:
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
.annotate 'line', 405
  # rx rxquantr886 ** 0..1
    set_addr $I10, rxquantr886_done
    rx873_cur."!mark_push"(0, rx873_pos, $I10)
  rxquantr886_loop:
  # rx subrule "deflongname" subtype=capture negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."deflongname"()
    unless $P10, rx873_fail
    goto rxsubrule887_pass
  rxsubrule887_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx873_fail
  rxsubrule887_pass:
    set_addr $I10, rxsubrule887_back
    rx873_cur."!mark_push"(0, rx873_pos, $I10, $P10)
    $P10."!cursor_names"("deflongname")
    rx873_pos = $P10."pos"()
    set_addr $I10, rxquantr886_done
    (rx873_rep) = rx873_cur."!mark_commit"($I10)
  rxquantr886_done:
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
.annotate 'line', 406
  # rx subrule "newpad" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."newpad"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
  alt890_0:
.annotate 'line', 407
    set_addr $I10, alt890_1
    rx873_cur."!mark_push"(0, rx873_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx873_pos, 1
    gt $I11, rx873_eos, rx873_fail
    sub $I11, rx873_pos, rx873_off
    ord $I11, rx873_tgt, $I11
    ne $I11, 40, rx873_fail
    add rx873_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."signature"()
    unless $P10, rx873_fail
    rx873_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx873_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx873_pos, 1
    gt $I11, rx873_eos, rx873_fail
    sub $I11, rx873_pos, rx873_off
    ord $I11, rx873_tgt, $I11
    ne $I11, 41, rx873_fail
    add rx873_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
    goto alt890_end
  alt890_1:
.annotate 'line', 408
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
  alt890_end:
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
.annotate 'line', 409
    rx873_cur."!cursor_pos"(rx873_pos)
    find_lex $P898, unicode:"$\x{a2}"
    $P899 = $P898."MATCH"()
    store_lex "$/", $P899
    .const 'Sub' $P901 = "179_1300062003.824" 
    capture_lex $P901
    $P903 = $P901()
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
.annotate 'line', 410
  # rx rxquantr905 ** 0..*
    set_addr $I10, rxquantr905_done
    rx873_cur."!mark_push"(0, rx873_pos, $I10)
  rxquantr905_loop:
  # rx subrule "trait" subtype=capture negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."trait"()
    unless $P10, rx873_fail
    goto rxsubrule906_pass
  rxsubrule906_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx873_fail
  rxsubrule906_pass:
    set_addr $I10, rxsubrule906_back
    rx873_cur."!mark_push"(0, rx873_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx873_pos = $P10."pos"()
    set_addr $I10, rxquantr905_done
    (rx873_rep) = rx873_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr905_done
    rx873_cur."!mark_push"(rx873_rep, rx873_pos, $I10)
    goto rxquantr905_loop
  rxquantr905_done:
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
  alt908_0:
.annotate 'line', 411
    set_addr $I10, alt908_1
    rx873_cur."!mark_push"(0, rx873_pos, $I10)
.annotate 'line', 412
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."onlystar"()
    unless $P10, rx873_fail
    rx873_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx873_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
    goto alt908_end
  alt908_1:
.annotate 'line', 413
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."blockoid"()
    unless $P10, rx873_fail
    rx873_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx873_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
  alt908_end:
.annotate 'line', 414
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
.annotate 'line', 401
  # rx pass
    rx873_cur."!cursor_pass"(rx873_pos, "method_def")
    if_null rx873_debug, debug_932
    rx873_cur."!cursor_debug"("PASS", "method_def", " at pos=", rx873_pos)
  debug_932:
    .return (rx873_cur)
  rx873_restart:
.annotate 'line', 10
    if_null rx873_debug, debug_933
    rx873_cur."!cursor_debug"("NEXT", "method_def")
  debug_933:
  rx873_fail:
    (rx873_rep, rx873_pos, $I10, $P10) = rx873_cur."!mark_fail"(0)
    lt rx873_pos, -1, rx873_done
    eq rx873_pos, -1, rx873_fail
    jump $I10
  rx873_done:
    rx873_cur."!cursor_fail"()
    if_null rx873_debug, debug_934
    rx873_cur."!cursor_debug"("FAIL", "method_def")
  debug_934:
    .return (rx873_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__method_def"  :nsentry("!PREFIX__method_def") :subid("178_1300062003.824") :method
.annotate 'line', 10
    $P875 = self."!PREFIX__!subrule"("ws", "")
    new $P876, "ResizablePMCArray"
    push $P876, $P875
    .return ($P876)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block900"  :anon :subid("179_1300062003.824") :outer("177_1300062003.824")
.annotate 'line', 409
    new $P902, "Integer"
    assign $P902, 0
    store_dynamic_lex "$*INVOCANT_OK", $P902
    .return ($P902)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "onlystar"  :subid("180_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .const 'Sub' $P922 = "182_1300062003.824" 
    capture_lex $P922
    .local string rx915_tgt
    .local int rx915_pos
    .local int rx915_off
    .local int rx915_eos
    .local int rx915_rep
    .local pmc rx915_cur
    .local pmc rx915_debug
    (rx915_cur, rx915_pos, rx915_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx915_cur
    .local pmc match
    .lex "$/", match
    length rx915_eos, rx915_tgt
    gt rx915_pos, rx915_eos, rx915_done
    set rx915_off, 0
    lt rx915_pos, 2, rx915_start
    sub rx915_off, rx915_pos, 1
    substr rx915_tgt, rx915_tgt, rx915_off
  rx915_start:
    eq $I10, 1, rx915_restart
    if_null rx915_debug, debug_935
    rx915_cur."!cursor_debug"("START", "onlystar")
  debug_935:
    $I10 = self.'from'()
    ne $I10, -1, rxscan918_done
    goto rxscan918_scan
  rxscan918_loop:
    (rx915_pos) = rx915_cur."from"()
    inc rx915_pos
    rx915_cur."!cursor_from"(rx915_pos)
    ge rx915_pos, rx915_eos, rxscan918_done
  rxscan918_scan:
    set_addr $I10, rxscan918_loop
    rx915_cur."!mark_push"(0, rx915_pos, $I10)
  rxscan918_done:
.annotate 'line', 418
    rx915_cur."!cursor_pos"(rx915_pos)
    find_lex $P919, unicode:"$\x{a2}"
    $P920 = $P919."MATCH"()
    store_lex "$/", $P920
    .const 'Sub' $P922 = "182_1300062003.824" 
    capture_lex $P922
    $P926 = $P922()
    unless $P926, rx915_fail
.annotate 'line', 419
  # rx literal  "{"
    add $I11, rx915_pos, 1
    gt $I11, rx915_eos, rx915_fail
    sub $I11, rx915_pos, rx915_off
    ord $I11, rx915_tgt, $I11
    ne $I11, 123, rx915_fail
    add rx915_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx915_cur."!cursor_pos"(rx915_pos)
    $P10 = rx915_cur."ws"()
    unless $P10, rx915_fail
    rx915_pos = $P10."pos"()
  # rx literal  "*"
    add $I11, rx915_pos, 1
    gt $I11, rx915_eos, rx915_fail
    sub $I11, rx915_pos, rx915_off
    ord $I11, rx915_tgt, $I11
    ne $I11, 42, rx915_fail
    add rx915_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx915_cur."!cursor_pos"(rx915_pos)
    $P10 = rx915_cur."ws"()
    unless $P10, rx915_fail
    rx915_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx915_pos, 1
    gt $I11, rx915_eos, rx915_fail
    sub $I11, rx915_pos, rx915_off
    ord $I11, rx915_tgt, $I11
    ne $I11, 125, rx915_fail
    add rx915_pos, 1
.annotate 'line', 420
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx915_cur."!cursor_pos"(rx915_pos)
    $P10 = rx915_cur."ENDSTMT"()
    unless $P10, rx915_fail
.annotate 'line', 421
  # rx subrule "finishpad" subtype=method negate=
    rx915_cur."!cursor_pos"(rx915_pos)
    $P10 = rx915_cur."finishpad"()
    unless $P10, rx915_fail
    rx915_pos = $P10."pos"()
.annotate 'line', 417
  # rx pass
    rx915_cur."!cursor_pass"(rx915_pos, "onlystar")
    if_null rx915_debug, debug_938
    rx915_cur."!cursor_debug"("PASS", "onlystar", " at pos=", rx915_pos)
  debug_938:
    .return (rx915_cur)
  rx915_restart:
.annotate 'line', 10
    if_null rx915_debug, debug_939
    rx915_cur."!cursor_debug"("NEXT", "onlystar")
  debug_939:
  rx915_fail:
    (rx915_rep, rx915_pos, $I10, $P10) = rx915_cur."!mark_fail"(0)
    lt rx915_pos, -1, rx915_done
    eq rx915_pos, -1, rx915_fail
    jump $I10
  rx915_done:
    rx915_cur."!cursor_fail"()
    if_null rx915_debug, debug_940
    rx915_cur."!cursor_debug"("FAIL", "onlystar")
  debug_940:
    .return (rx915_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__onlystar"  :nsentry("!PREFIX__onlystar") :subid("181_1300062003.824") :method
.annotate 'line', 10
    new $P917, "ResizablePMCArray"
    push $P917, ""
    .return ($P917)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block921"  :anon :subid("182_1300062003.824") :outer("180_1300062003.824")
.annotate 'line', 418
    find_dynamic_lex $P923, "$*MULTINESS"
    unless_null $P923, vivify_936
    get_hll_global $P923, "$MULTINESS"
    unless_null $P923, vivify_937
    die "Contextual $*MULTINESS not found"
  vivify_937:
  vivify_936:
    set $S924, $P923
    iseq $I925, $S924, "proto"
    .return ($I925)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator"  :subid("183_1300062003.824")
    .param pmc param_928
.annotate 'line', 424
    .lex "self", param_928
    $P929 = param_928."!protoregex"("multi_declarator")
    .return ($P929)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator"  :subid("184_1300062003.824")
    .param pmc param_931
.annotate 'line', 424
    .lex "self", param_931
    $P932 = param_931."!PREFIX__!protoregex"("multi_declarator")
    .return ($P932)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<multi>"  :subid("185_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 426
    new $P934, "Undef"
    .lex "$*MULTINESS", $P934
.annotate 'line', 10
    .local string rx935_tgt
    .local int rx935_pos
    .local int rx935_off
    .local int rx935_eos
    .local int rx935_rep
    .local pmc rx935_cur
    .local pmc rx935_debug
    (rx935_cur, rx935_pos, rx935_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx935_cur
    .local pmc match
    .lex "$/", match
    length rx935_eos, rx935_tgt
    gt rx935_pos, rx935_eos, rx935_done
    set rx935_off, 0
    lt rx935_pos, 2, rx935_start
    sub rx935_off, rx935_pos, 1
    substr rx935_tgt, rx935_tgt, rx935_off
  rx935_start:
    eq $I10, 1, rx935_restart
    if_null rx935_debug, debug_941
    rx935_cur."!cursor_debug"("START", "multi_declarator:sym<multi>")
  debug_941:
    $I10 = self.'from'()
    ne $I10, -1, rxscan939_done
    goto rxscan939_scan
  rxscan939_loop:
    (rx935_pos) = rx935_cur."from"()
    inc rx935_pos
    rx935_cur."!cursor_from"(rx935_pos)
    ge rx935_pos, rx935_eos, rxscan939_done
  rxscan939_scan:
    set_addr $I10, rxscan939_loop
    rx935_cur."!mark_push"(0, rx935_pos, $I10)
  rxscan939_done:
.annotate 'line', 426
    rx935_cur."!cursor_pos"(rx935_pos)
    new $P940, "String"
    assign $P940, "multi"
    store_lex "$*MULTINESS", $P940
.annotate 'line', 427
  # rx subcapture "sym"
    set_addr $I10, rxcap_941_fail
    rx935_cur."!mark_push"(0, rx935_pos, $I10)
  # rx literal  "multi"
    add $I11, rx935_pos, 5
    gt $I11, rx935_eos, rx935_fail
    sub $I11, rx935_pos, rx935_off
    substr $S10, rx935_tgt, $I11, 5
    ne $S10, "multi", rx935_fail
    add rx935_pos, 5
    set_addr $I10, rxcap_941_fail
    ($I12, $I11) = rx935_cur."!mark_peek"($I10)
    rx935_cur."!cursor_pos"($I11)
    ($P10) = rx935_cur."!cursor_start"()
    $P10."!cursor_pass"(rx935_pos, "")
    rx935_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_941_done
  rxcap_941_fail:
    goto rx935_fail
  rxcap_941_done:
.annotate 'line', 428
  # rx subrule "ws" subtype=method negate=
    rx935_cur."!cursor_pos"(rx935_pos)
    $P10 = rx935_cur."ws"()
    unless $P10, rx935_fail
    rx935_pos = $P10."pos"()
  alt942_0:
    set_addr $I10, alt942_1
    rx935_cur."!mark_push"(0, rx935_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx935_cur."!cursor_pos"(rx935_pos)
    $P10 = rx935_cur."declarator"()
    unless $P10, rx935_fail
    rx935_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx935_pos = $P10."pos"()
    goto alt942_end
  alt942_1:
    set_addr $I10, alt942_2
    rx935_cur."!mark_push"(0, rx935_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx935_cur."!cursor_pos"(rx935_pos)
    $P10 = rx935_cur."routine_def"()
    unless $P10, rx935_fail
    rx935_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx935_pos = $P10."pos"()
    goto alt942_end
  alt942_2:
  # rx subrule "panic" subtype=method negate=
    rx935_cur."!cursor_pos"(rx935_pos)
    $P10 = rx935_cur."panic"("Malformed multi")
    unless $P10, rx935_fail
    rx935_pos = $P10."pos"()
  alt942_end:
.annotate 'line', 425
  # rx pass
    rx935_cur."!cursor_pass"(rx935_pos, "multi_declarator:sym<multi>")
    if_null rx935_debug, debug_942
    rx935_cur."!cursor_debug"("PASS", "multi_declarator:sym<multi>", " at pos=", rx935_pos)
  debug_942:
    .return (rx935_cur)
  rx935_restart:
.annotate 'line', 10
    if_null rx935_debug, debug_943
    rx935_cur."!cursor_debug"("NEXT", "multi_declarator:sym<multi>")
  debug_943:
  rx935_fail:
    (rx935_rep, rx935_pos, $I10, $P10) = rx935_cur."!mark_fail"(0)
    lt rx935_pos, -1, rx935_done
    eq rx935_pos, -1, rx935_fail
    jump $I10
  rx935_done:
    rx935_cur."!cursor_fail"()
    if_null rx935_debug, debug_944
    rx935_cur."!cursor_debug"("FAIL", "multi_declarator:sym<multi>")
  debug_944:
    .return (rx935_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<multi>"  :nsentry("!PREFIX__multi_declarator:sym<multi>") :subid("186_1300062003.824") :method
.annotate 'line', 10
    $P937 = self."!PREFIX__!subrule"("ws", "multi")
    new $P938, "ResizablePMCArray"
    push $P938, $P937
    .return ($P938)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<proto>"  :subid("187_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 431
    new $P944, "Undef"
    .lex "$*MULTINESS", $P944
.annotate 'line', 10
    .local string rx945_tgt
    .local int rx945_pos
    .local int rx945_off
    .local int rx945_eos
    .local int rx945_rep
    .local pmc rx945_cur
    .local pmc rx945_debug
    (rx945_cur, rx945_pos, rx945_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx945_cur
    .local pmc match
    .lex "$/", match
    length rx945_eos, rx945_tgt
    gt rx945_pos, rx945_eos, rx945_done
    set rx945_off, 0
    lt rx945_pos, 2, rx945_start
    sub rx945_off, rx945_pos, 1
    substr rx945_tgt, rx945_tgt, rx945_off
  rx945_start:
    eq $I10, 1, rx945_restart
    if_null rx945_debug, debug_945
    rx945_cur."!cursor_debug"("START", "multi_declarator:sym<proto>")
  debug_945:
    $I10 = self.'from'()
    ne $I10, -1, rxscan949_done
    goto rxscan949_scan
  rxscan949_loop:
    (rx945_pos) = rx945_cur."from"()
    inc rx945_pos
    rx945_cur."!cursor_from"(rx945_pos)
    ge rx945_pos, rx945_eos, rxscan949_done
  rxscan949_scan:
    set_addr $I10, rxscan949_loop
    rx945_cur."!mark_push"(0, rx945_pos, $I10)
  rxscan949_done:
.annotate 'line', 431
    rx945_cur."!cursor_pos"(rx945_pos)
    new $P950, "String"
    assign $P950, "proto"
    store_lex "$*MULTINESS", $P950
.annotate 'line', 432
  # rx subcapture "sym"
    set_addr $I10, rxcap_951_fail
    rx945_cur."!mark_push"(0, rx945_pos, $I10)
  # rx literal  "proto"
    add $I11, rx945_pos, 5
    gt $I11, rx945_eos, rx945_fail
    sub $I11, rx945_pos, rx945_off
    substr $S10, rx945_tgt, $I11, 5
    ne $S10, "proto", rx945_fail
    add rx945_pos, 5
    set_addr $I10, rxcap_951_fail
    ($I12, $I11) = rx945_cur."!mark_peek"($I10)
    rx945_cur."!cursor_pos"($I11)
    ($P10) = rx945_cur."!cursor_start"()
    $P10."!cursor_pass"(rx945_pos, "")
    rx945_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_951_done
  rxcap_951_fail:
    goto rx945_fail
  rxcap_951_done:
.annotate 'line', 433
  # rx subrule "ws" subtype=method negate=
    rx945_cur."!cursor_pos"(rx945_pos)
    $P10 = rx945_cur."ws"()
    unless $P10, rx945_fail
    rx945_pos = $P10."pos"()
  alt952_0:
    set_addr $I10, alt952_1
    rx945_cur."!mark_push"(0, rx945_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx945_cur."!cursor_pos"(rx945_pos)
    $P10 = rx945_cur."declarator"()
    unless $P10, rx945_fail
    rx945_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx945_pos = $P10."pos"()
    goto alt952_end
  alt952_1:
    set_addr $I10, alt952_2
    rx945_cur."!mark_push"(0, rx945_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx945_cur."!cursor_pos"(rx945_pos)
    $P10 = rx945_cur."routine_def"()
    unless $P10, rx945_fail
    rx945_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx945_pos = $P10."pos"()
    goto alt952_end
  alt952_2:
  # rx subrule "panic" subtype=method negate=
    rx945_cur."!cursor_pos"(rx945_pos)
    $P10 = rx945_cur."panic"("Malformed proto")
    unless $P10, rx945_fail
    rx945_pos = $P10."pos"()
  alt952_end:
.annotate 'line', 430
  # rx pass
    rx945_cur."!cursor_pass"(rx945_pos, "multi_declarator:sym<proto>")
    if_null rx945_debug, debug_946
    rx945_cur."!cursor_debug"("PASS", "multi_declarator:sym<proto>", " at pos=", rx945_pos)
  debug_946:
    .return (rx945_cur)
  rx945_restart:
.annotate 'line', 10
    if_null rx945_debug, debug_947
    rx945_cur."!cursor_debug"("NEXT", "multi_declarator:sym<proto>")
  debug_947:
  rx945_fail:
    (rx945_rep, rx945_pos, $I10, $P10) = rx945_cur."!mark_fail"(0)
    lt rx945_pos, -1, rx945_done
    eq rx945_pos, -1, rx945_fail
    jump $I10
  rx945_done:
    rx945_cur."!cursor_fail"()
    if_null rx945_debug, debug_948
    rx945_cur."!cursor_debug"("FAIL", "multi_declarator:sym<proto>")
  debug_948:
    .return (rx945_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<proto>"  :nsentry("!PREFIX__multi_declarator:sym<proto>") :subid("188_1300062003.824") :method
.annotate 'line', 10
    $P947 = self."!PREFIX__!subrule"("ws", "proto")
    new $P948, "ResizablePMCArray"
    push $P948, $P947
    .return ($P948)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<null>"  :subid("189_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 436
    new $P954, "Undef"
    .lex "$*MULTINESS", $P954
.annotate 'line', 10
    .local string rx955_tgt
    .local int rx955_pos
    .local int rx955_off
    .local int rx955_eos
    .local int rx955_rep
    .local pmc rx955_cur
    .local pmc rx955_debug
    (rx955_cur, rx955_pos, rx955_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx955_cur
    .local pmc match
    .lex "$/", match
    length rx955_eos, rx955_tgt
    gt rx955_pos, rx955_eos, rx955_done
    set rx955_off, 0
    lt rx955_pos, 2, rx955_start
    sub rx955_off, rx955_pos, 1
    substr rx955_tgt, rx955_tgt, rx955_off
  rx955_start:
    eq $I10, 1, rx955_restart
    if_null rx955_debug, debug_949
    rx955_cur."!cursor_debug"("START", "multi_declarator:sym<null>")
  debug_949:
    $I10 = self.'from'()
    ne $I10, -1, rxscan959_done
    goto rxscan959_scan
  rxscan959_loop:
    (rx955_pos) = rx955_cur."from"()
    inc rx955_pos
    rx955_cur."!cursor_from"(rx955_pos)
    ge rx955_pos, rx955_eos, rxscan959_done
  rxscan959_scan:
    set_addr $I10, rxscan959_loop
    rx955_cur."!mark_push"(0, rx955_pos, $I10)
  rxscan959_done:
.annotate 'line', 436
    rx955_cur."!cursor_pos"(rx955_pos)
    new $P960, "String"
    assign $P960, ""
    store_lex "$*MULTINESS", $P960
.annotate 'line', 437
  # rx subrule "declarator" subtype=capture negate=
    rx955_cur."!cursor_pos"(rx955_pos)
    $P10 = rx955_cur."declarator"()
    unless $P10, rx955_fail
    rx955_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx955_pos = $P10."pos"()
.annotate 'line', 435
  # rx pass
    rx955_cur."!cursor_pass"(rx955_pos, "multi_declarator:sym<null>")
    if_null rx955_debug, debug_950
    rx955_cur."!cursor_debug"("PASS", "multi_declarator:sym<null>", " at pos=", rx955_pos)
  debug_950:
    .return (rx955_cur)
  rx955_restart:
.annotate 'line', 10
    if_null rx955_debug, debug_951
    rx955_cur."!cursor_debug"("NEXT", "multi_declarator:sym<null>")
  debug_951:
  rx955_fail:
    (rx955_rep, rx955_pos, $I10, $P10) = rx955_cur."!mark_fail"(0)
    lt rx955_pos, -1, rx955_done
    eq rx955_pos, -1, rx955_fail
    jump $I10
  rx955_done:
    rx955_cur."!cursor_fail"()
    if_null rx955_debug, debug_952
    rx955_cur."!cursor_debug"("FAIL", "multi_declarator:sym<null>")
  debug_952:
    .return (rx955_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<null>"  :nsentry("!PREFIX__multi_declarator:sym<null>") :subid("190_1300062003.824") :method
.annotate 'line', 10
    $P957 = self."!PREFIX__!subrule"("declarator", "")
    new $P958, "ResizablePMCArray"
    push $P958, $P957
    .return ($P958)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "signature"  :subid("191_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .const 'Sub' $P970 = "193_1300062003.824" 
    capture_lex $P970
    .local string rx962_tgt
    .local int rx962_pos
    .local int rx962_off
    .local int rx962_eos
    .local int rx962_rep
    .local pmc rx962_cur
    .local pmc rx962_debug
    (rx962_cur, rx962_pos, rx962_tgt, $I10) = self."!cursor_start"()
    rx962_cur."!cursor_caparray"("invocant", "parameter")
    .lex unicode:"$\x{a2}", rx962_cur
    .local pmc match
    .lex "$/", match
    length rx962_eos, rx962_tgt
    gt rx962_pos, rx962_eos, rx962_done
    set rx962_off, 0
    lt rx962_pos, 2, rx962_start
    sub rx962_off, rx962_pos, 1
    substr rx962_tgt, rx962_tgt, rx962_off
  rx962_start:
    eq $I10, 1, rx962_restart
    if_null rx962_debug, debug_953
    rx962_cur."!cursor_debug"("START", "signature")
  debug_953:
    $I10 = self.'from'()
    ne $I10, -1, rxscan965_done
    goto rxscan965_scan
  rxscan965_loop:
    (rx962_pos) = rx962_cur."from"()
    inc rx962_pos
    rx962_cur."!cursor_from"(rx962_pos)
    ge rx962_pos, rx962_eos, rxscan965_done
  rxscan965_scan:
    set_addr $I10, rxscan965_loop
    rx962_cur."!mark_push"(0, rx962_pos, $I10)
  rxscan965_done:
.annotate 'line', 441
  # rx rxquantr966 ** 0..1
    set_addr $I10, rxquantr966_done
    rx962_cur."!mark_push"(0, rx962_pos, $I10)
  rxquantr966_loop:
    rx962_cur."!cursor_pos"(rx962_pos)
    find_lex $P967, unicode:"$\x{a2}"
    $P968 = $P967."MATCH"()
    store_lex "$/", $P968
    .const 'Sub' $P970 = "193_1300062003.824" 
    capture_lex $P970
    $P972 = $P970()
    unless $P972, rx962_fail
  # rx subrule "ws" subtype=method negate=
    rx962_cur."!cursor_pos"(rx962_pos)
    $P10 = rx962_cur."ws"()
    unless $P10, rx962_fail
    rx962_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx962_cur."!cursor_pos"(rx962_pos)
    $P10 = rx962_cur."parameter"()
    unless $P10, rx962_fail
    rx962_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("invocant")
    rx962_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx962_cur."!cursor_pos"(rx962_pos)
    $P10 = rx962_cur."ws"()
    unless $P10, rx962_fail
    rx962_pos = $P10."pos"()
  # rx literal  ":"
    add $I11, rx962_pos, 1
    gt $I11, rx962_eos, rx962_fail
    sub $I11, rx962_pos, rx962_off
    ord $I11, rx962_tgt, $I11
    ne $I11, 58, rx962_fail
    add rx962_pos, 1
    set_addr $I10, rxquantr966_done
    (rx962_rep) = rx962_cur."!mark_commit"($I10)
  rxquantr966_done:
.annotate 'line', 442
  # rx rxquantr973 ** 0..1
    set_addr $I10, rxquantr973_done
    rx962_cur."!mark_push"(0, rx962_pos, $I10)
  rxquantr973_loop:
  # rx rxquantr974 ** 1..*
    set_addr $I10, rxquantr974_done
    rx962_cur."!mark_push"(0, -1, $I10)
  rxquantr974_loop:
  # rx subrule "ws" subtype=method negate=
    rx962_cur."!cursor_pos"(rx962_pos)
    $P10 = rx962_cur."ws"()
    unless $P10, rx962_fail
    rx962_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx962_cur."!cursor_pos"(rx962_pos)
    $P10 = rx962_cur."parameter"()
    unless $P10, rx962_fail
    rx962_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parameter")
    rx962_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx962_cur."!cursor_pos"(rx962_pos)
    $P10 = rx962_cur."ws"()
    unless $P10, rx962_fail
    rx962_pos = $P10."pos"()
    set_addr $I10, rxquantr974_done
    (rx962_rep) = rx962_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr974_done
    rx962_cur."!mark_push"(rx962_rep, rx962_pos, $I10)
  # rx literal  ","
    add $I11, rx962_pos, 1
    gt $I11, rx962_eos, rx962_fail
    sub $I11, rx962_pos, rx962_off
    ord $I11, rx962_tgt, $I11
    ne $I11, 44, rx962_fail
    add rx962_pos, 1
    goto rxquantr974_loop
  rxquantr974_done:
    set_addr $I10, rxquantr973_done
    (rx962_rep) = rx962_cur."!mark_commit"($I10)
  rxquantr973_done:
.annotate 'line', 440
  # rx pass
    rx962_cur."!cursor_pass"(rx962_pos, "signature")
    if_null rx962_debug, debug_956
    rx962_cur."!cursor_debug"("PASS", "signature", " at pos=", rx962_pos)
  debug_956:
    .return (rx962_cur)
  rx962_restart:
.annotate 'line', 10
    if_null rx962_debug, debug_957
    rx962_cur."!cursor_debug"("NEXT", "signature")
  debug_957:
  rx962_fail:
    (rx962_rep, rx962_pos, $I10, $P10) = rx962_cur."!mark_fail"(0)
    lt rx962_pos, -1, rx962_done
    eq rx962_pos, -1, rx962_fail
    jump $I10
  rx962_done:
    rx962_cur."!cursor_fail"()
    if_null rx962_debug, debug_958
    rx962_cur."!cursor_debug"("FAIL", "signature")
  debug_958:
    .return (rx962_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__signature"  :nsentry("!PREFIX__signature") :subid("192_1300062003.824") :method
.annotate 'line', 10
    new $P964, "ResizablePMCArray"
    push $P964, ""
    .return ($P964)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block969"  :anon :subid("193_1300062003.824") :outer("191_1300062003.824")
.annotate 'line', 441
    find_dynamic_lex $P971, "$*INVOCANT_OK"
    unless_null $P971, vivify_954
    get_hll_global $P971, "$INVOCANT_OK"
    unless_null $P971, vivify_955
    die "Contextual $*INVOCANT_OK not found"
  vivify_955:
  vivify_954:
    .return ($P971)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "parameter"  :subid("194_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx976_tgt
    .local int rx976_pos
    .local int rx976_off
    .local int rx976_eos
    .local int rx976_rep
    .local pmc rx976_cur
    .local pmc rx976_debug
    (rx976_cur, rx976_pos, rx976_tgt, $I10) = self."!cursor_start"()
    rx976_cur."!cursor_caparray"("typename", "definedness", "default_value")
    .lex unicode:"$\x{a2}", rx976_cur
    .local pmc match
    .lex "$/", match
    length rx976_eos, rx976_tgt
    gt rx976_pos, rx976_eos, rx976_done
    set rx976_off, 0
    lt rx976_pos, 2, rx976_start
    sub rx976_off, rx976_pos, 1
    substr rx976_tgt, rx976_tgt, rx976_off
  rx976_start:
    eq $I10, 1, rx976_restart
    if_null rx976_debug, debug_959
    rx976_cur."!cursor_debug"("START", "parameter")
  debug_959:
    $I10 = self.'from'()
    ne $I10, -1, rxscan979_done
    goto rxscan979_scan
  rxscan979_loop:
    (rx976_pos) = rx976_cur."from"()
    inc rx976_pos
    rx976_cur."!cursor_from"(rx976_pos)
    ge rx976_pos, rx976_eos, rxscan979_done
  rxscan979_scan:
    set_addr $I10, rxscan979_loop
    rx976_cur."!mark_push"(0, rx976_pos, $I10)
  rxscan979_done:
.annotate 'line', 446
  # rx rxquantr980 ** 0..*
    set_addr $I10, rxquantr980_done
    rx976_cur."!mark_push"(0, rx976_pos, $I10)
  rxquantr980_loop:
  # rx subrule "typename" subtype=capture negate=
    rx976_cur."!cursor_pos"(rx976_pos)
    $P10 = rx976_cur."typename"()
    unless $P10, rx976_fail
    rx976_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("typename")
    rx976_pos = $P10."pos"()
  # rx rxquantr981 ** 0..1
    set_addr $I10, rxquantr981_done
    rx976_cur."!mark_push"(0, rx976_pos, $I10)
  rxquantr981_loop:
  # rx literal  ":"
    add $I11, rx976_pos, 1
    gt $I11, rx976_eos, rx976_fail
    sub $I11, rx976_pos, rx976_off
    ord $I11, rx976_tgt, $I11
    ne $I11, 58, rx976_fail
    add rx976_pos, 1
  # rx subcapture "definedness"
    set_addr $I10, rxcap_982_fail
    rx976_cur."!mark_push"(0, rx976_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx976_pos, rx976_eos, rx976_fail
    sub $I10, rx976_pos, rx976_off
    substr $S10, rx976_tgt, $I10, 1
    index $I11, "_DU", $S10
    lt $I11, 0, rx976_fail
    inc rx976_pos
    set_addr $I10, rxcap_982_fail
    ($I12, $I11) = rx976_cur."!mark_peek"($I10)
    rx976_cur."!cursor_pos"($I11)
    ($P10) = rx976_cur."!cursor_start"()
    $P10."!cursor_pass"(rx976_pos, "")
    rx976_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("definedness")
    goto rxcap_982_done
  rxcap_982_fail:
    goto rx976_fail
  rxcap_982_done:
    set_addr $I10, rxquantr981_done
    (rx976_rep) = rx976_cur."!mark_commit"($I10)
  rxquantr981_done:
  # rx subrule "ws" subtype=method negate=
    rx976_cur."!cursor_pos"(rx976_pos)
    $P10 = rx976_cur."ws"()
    unless $P10, rx976_fail
    rx976_pos = $P10."pos"()
    set_addr $I10, rxquantr980_done
    (rx976_rep) = rx976_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr980_done
    rx976_cur."!mark_push"(rx976_rep, rx976_pos, $I10)
    goto rxquantr980_loop
  rxquantr980_done:
  alt983_0:
.annotate 'line', 447
    set_addr $I10, alt983_1
    rx976_cur."!mark_push"(0, rx976_pos, $I10)
.annotate 'line', 448
  # rx subcapture "quant"
    set_addr $I10, rxcap_984_fail
    rx976_cur."!mark_push"(0, rx976_pos, $I10)
  # rx literal  "*"
    add $I11, rx976_pos, 1
    gt $I11, rx976_eos, rx976_fail
    sub $I11, rx976_pos, rx976_off
    ord $I11, rx976_tgt, $I11
    ne $I11, 42, rx976_fail
    add rx976_pos, 1
    set_addr $I10, rxcap_984_fail
    ($I12, $I11) = rx976_cur."!mark_peek"($I10)
    rx976_cur."!cursor_pos"($I11)
    ($P10) = rx976_cur."!cursor_start"()
    $P10."!cursor_pass"(rx976_pos, "")
    rx976_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_984_done
  rxcap_984_fail:
    goto rx976_fail
  rxcap_984_done:
  # rx subrule "param_var" subtype=capture negate=
    rx976_cur."!cursor_pos"(rx976_pos)
    $P10 = rx976_cur."param_var"()
    unless $P10, rx976_fail
    rx976_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx976_pos = $P10."pos"()
    goto alt983_end
  alt983_1:
  alt985_0:
.annotate 'line', 449
    set_addr $I10, alt985_1
    rx976_cur."!mark_push"(0, rx976_pos, $I10)
  # rx subrule "param_var" subtype=capture negate=
    rx976_cur."!cursor_pos"(rx976_pos)
    $P10 = rx976_cur."param_var"()
    unless $P10, rx976_fail
    rx976_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx976_pos = $P10."pos"()
    goto alt985_end
  alt985_1:
  # rx subrule "named_param" subtype=capture negate=
    rx976_cur."!cursor_pos"(rx976_pos)
    $P10 = rx976_cur."named_param"()
    unless $P10, rx976_fail
    rx976_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("named_param")
    rx976_pos = $P10."pos"()
  alt985_end:
  # rx subcapture "quant"
    set_addr $I10, rxcap_987_fail
    rx976_cur."!mark_push"(0, rx976_pos, $I10)
  alt986_0:
    set_addr $I10, alt986_1
    rx976_cur."!mark_push"(0, rx976_pos, $I10)
  # rx literal  "?"
    add $I11, rx976_pos, 1
    gt $I11, rx976_eos, rx976_fail
    sub $I11, rx976_pos, rx976_off
    ord $I11, rx976_tgt, $I11
    ne $I11, 63, rx976_fail
    add rx976_pos, 1
    goto alt986_end
  alt986_1:
    set_addr $I10, alt986_2
    rx976_cur."!mark_push"(0, rx976_pos, $I10)
  # rx literal  "!"
    add $I11, rx976_pos, 1
    gt $I11, rx976_eos, rx976_fail
    sub $I11, rx976_pos, rx976_off
    ord $I11, rx976_tgt, $I11
    ne $I11, 33, rx976_fail
    add rx976_pos, 1
    goto alt986_end
  alt986_2:
  alt986_end:
    set_addr $I10, rxcap_987_fail
    ($I12, $I11) = rx976_cur."!mark_peek"($I10)
    rx976_cur."!cursor_pos"($I11)
    ($P10) = rx976_cur."!cursor_start"()
    $P10."!cursor_pass"(rx976_pos, "")
    rx976_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_987_done
  rxcap_987_fail:
    goto rx976_fail
  rxcap_987_done:
  alt983_end:
.annotate 'line', 451
  # rx rxquantr988 ** 0..1
    set_addr $I10, rxquantr988_done
    rx976_cur."!mark_push"(0, rx976_pos, $I10)
  rxquantr988_loop:
  # rx subrule "default_value" subtype=capture negate=
    rx976_cur."!cursor_pos"(rx976_pos)
    $P10 = rx976_cur."default_value"()
    unless $P10, rx976_fail
    goto rxsubrule989_pass
  rxsubrule989_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx976_fail
  rxsubrule989_pass:
    set_addr $I10, rxsubrule989_back
    rx976_cur."!mark_push"(0, rx976_pos, $I10, $P10)
    $P10."!cursor_names"("default_value")
    rx976_pos = $P10."pos"()
    set_addr $I10, rxquantr988_done
    (rx976_rep) = rx976_cur."!mark_commit"($I10)
  rxquantr988_done:
.annotate 'line', 445
  # rx pass
    rx976_cur."!cursor_pass"(rx976_pos, "parameter")
    if_null rx976_debug, debug_960
    rx976_cur."!cursor_debug"("PASS", "parameter", " at pos=", rx976_pos)
  debug_960:
    .return (rx976_cur)
  rx976_restart:
.annotate 'line', 10
    if_null rx976_debug, debug_961
    rx976_cur."!cursor_debug"("NEXT", "parameter")
  debug_961:
  rx976_fail:
    (rx976_rep, rx976_pos, $I10, $P10) = rx976_cur."!mark_fail"(0)
    lt rx976_pos, -1, rx976_done
    eq rx976_pos, -1, rx976_fail
    jump $I10
  rx976_done:
    rx976_cur."!cursor_fail"()
    if_null rx976_debug, debug_962
    rx976_cur."!cursor_debug"("FAIL", "parameter")
  debug_962:
    .return (rx976_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__parameter"  :nsentry("!PREFIX__parameter") :subid("195_1300062003.824") :method
.annotate 'line', 10
    new $P978, "ResizablePMCArray"
    push $P978, ""
    .return ($P978)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "param_var"  :subid("196_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx991_tgt
    .local int rx991_pos
    .local int rx991_off
    .local int rx991_eos
    .local int rx991_rep
    .local pmc rx991_cur
    .local pmc rx991_debug
    (rx991_cur, rx991_pos, rx991_tgt, $I10) = self."!cursor_start"()
    rx991_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx991_cur
    .local pmc match
    .lex "$/", match
    length rx991_eos, rx991_tgt
    gt rx991_pos, rx991_eos, rx991_done
    set rx991_off, 0
    lt rx991_pos, 2, rx991_start
    sub rx991_off, rx991_pos, 1
    substr rx991_tgt, rx991_tgt, rx991_off
  rx991_start:
    eq $I10, 1, rx991_restart
    if_null rx991_debug, debug_963
    rx991_cur."!cursor_debug"("START", "param_var")
  debug_963:
    $I10 = self.'from'()
    ne $I10, -1, rxscan995_done
    goto rxscan995_scan
  rxscan995_loop:
    (rx991_pos) = rx991_cur."from"()
    inc rx991_pos
    rx991_cur."!cursor_from"(rx991_pos)
    ge rx991_pos, rx991_eos, rxscan995_done
  rxscan995_scan:
    set_addr $I10, rxscan995_loop
    rx991_cur."!mark_push"(0, rx991_pos, $I10)
  rxscan995_done:
.annotate 'line', 455
  # rx subrule "sigil" subtype=capture negate=
    rx991_cur."!cursor_pos"(rx991_pos)
    $P10 = rx991_cur."sigil"()
    unless $P10, rx991_fail
    rx991_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx991_pos = $P10."pos"()
  # rx rxquantr996 ** 0..1
    set_addr $I10, rxquantr996_done
    rx991_cur."!mark_push"(0, rx991_pos, $I10)
  rxquantr996_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx991_cur."!cursor_pos"(rx991_pos)
    $P10 = rx991_cur."twigil"()
    unless $P10, rx991_fail
    goto rxsubrule997_pass
  rxsubrule997_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx991_fail
  rxsubrule997_pass:
    set_addr $I10, rxsubrule997_back
    rx991_cur."!mark_push"(0, rx991_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx991_pos = $P10."pos"()
    set_addr $I10, rxquantr996_done
    (rx991_rep) = rx991_cur."!mark_commit"($I10)
  rxquantr996_done:
  alt998_0:
.annotate 'line', 456
    set_addr $I10, alt998_1
    rx991_cur."!mark_push"(0, rx991_pos, $I10)
  # rx subrule "ident" subtype=capture negate=
    rx991_cur."!cursor_pos"(rx991_pos)
    $P10 = rx991_cur."ident"()
    unless $P10, rx991_fail
    rx991_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx991_pos = $P10."pos"()
    goto alt998_end
  alt998_1:
  # rx subcapture "name"
    set_addr $I10, rxcap_999_fail
    rx991_cur."!mark_push"(0, rx991_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx991_pos, rx991_eos, rx991_fail
    sub $I10, rx991_pos, rx991_off
    substr $S10, rx991_tgt, $I10, 1
    index $I11, "/!", $S10
    lt $I11, 0, rx991_fail
    inc rx991_pos
    set_addr $I10, rxcap_999_fail
    ($I12, $I11) = rx991_cur."!mark_peek"($I10)
    rx991_cur."!cursor_pos"($I11)
    ($P10) = rx991_cur."!cursor_start"()
    $P10."!cursor_pass"(rx991_pos, "")
    rx991_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    goto rxcap_999_done
  rxcap_999_fail:
    goto rx991_fail
  rxcap_999_done:
  alt998_end:
.annotate 'line', 454
  # rx pass
    rx991_cur."!cursor_pass"(rx991_pos, "param_var")
    if_null rx991_debug, debug_964
    rx991_cur."!cursor_debug"("PASS", "param_var", " at pos=", rx991_pos)
  debug_964:
    .return (rx991_cur)
  rx991_restart:
.annotate 'line', 10
    if_null rx991_debug, debug_965
    rx991_cur."!cursor_debug"("NEXT", "param_var")
  debug_965:
  rx991_fail:
    (rx991_rep, rx991_pos, $I10, $P10) = rx991_cur."!mark_fail"(0)
    lt rx991_pos, -1, rx991_done
    eq rx991_pos, -1, rx991_fail
    jump $I10
  rx991_done:
    rx991_cur."!cursor_fail"()
    if_null rx991_debug, debug_966
    rx991_cur."!cursor_debug"("FAIL", "param_var")
  debug_966:
    .return (rx991_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__param_var"  :nsentry("!PREFIX__param_var") :subid("197_1300062003.824") :method
.annotate 'line', 10
    $P993 = self."!PREFIX__!subrule"("sigil", "")
    new $P994, "ResizablePMCArray"
    push $P994, $P993
    .return ($P994)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "named_param"  :subid("198_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1001_tgt
    .local int rx1001_pos
    .local int rx1001_off
    .local int rx1001_eos
    .local int rx1001_rep
    .local pmc rx1001_cur
    .local pmc rx1001_debug
    (rx1001_cur, rx1001_pos, rx1001_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1001_cur
    .local pmc match
    .lex "$/", match
    length rx1001_eos, rx1001_tgt
    gt rx1001_pos, rx1001_eos, rx1001_done
    set rx1001_off, 0
    lt rx1001_pos, 2, rx1001_start
    sub rx1001_off, rx1001_pos, 1
    substr rx1001_tgt, rx1001_tgt, rx1001_off
  rx1001_start:
    eq $I10, 1, rx1001_restart
    if_null rx1001_debug, debug_967
    rx1001_cur."!cursor_debug"("START", "named_param")
  debug_967:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1005_done
    goto rxscan1005_scan
  rxscan1005_loop:
    (rx1001_pos) = rx1001_cur."from"()
    inc rx1001_pos
    rx1001_cur."!cursor_from"(rx1001_pos)
    ge rx1001_pos, rx1001_eos, rxscan1005_done
  rxscan1005_scan:
    set_addr $I10, rxscan1005_loop
    rx1001_cur."!mark_push"(0, rx1001_pos, $I10)
  rxscan1005_done:
.annotate 'line', 460
  # rx literal  ":"
    add $I11, rx1001_pos, 1
    gt $I11, rx1001_eos, rx1001_fail
    sub $I11, rx1001_pos, rx1001_off
    ord $I11, rx1001_tgt, $I11
    ne $I11, 58, rx1001_fail
    add rx1001_pos, 1
  # rx subrule "param_var" subtype=capture negate=
    rx1001_cur."!cursor_pos"(rx1001_pos)
    $P10 = rx1001_cur."param_var"()
    unless $P10, rx1001_fail
    rx1001_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx1001_pos = $P10."pos"()
.annotate 'line', 459
  # rx pass
    rx1001_cur."!cursor_pass"(rx1001_pos, "named_param")
    if_null rx1001_debug, debug_968
    rx1001_cur."!cursor_debug"("PASS", "named_param", " at pos=", rx1001_pos)
  debug_968:
    .return (rx1001_cur)
  rx1001_restart:
.annotate 'line', 10
    if_null rx1001_debug, debug_969
    rx1001_cur."!cursor_debug"("NEXT", "named_param")
  debug_969:
  rx1001_fail:
    (rx1001_rep, rx1001_pos, $I10, $P10) = rx1001_cur."!mark_fail"(0)
    lt rx1001_pos, -1, rx1001_done
    eq rx1001_pos, -1, rx1001_fail
    jump $I10
  rx1001_done:
    rx1001_cur."!cursor_fail"()
    if_null rx1001_debug, debug_970
    rx1001_cur."!cursor_debug"("FAIL", "named_param")
  debug_970:
    .return (rx1001_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__named_param"  :nsentry("!PREFIX__named_param") :subid("199_1300062003.824") :method
.annotate 'line', 10
    $P1003 = self."!PREFIX__!subrule"("param_var", ":")
    new $P1004, "ResizablePMCArray"
    push $P1004, $P1003
    .return ($P1004)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "default_value"  :subid("200_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1007_tgt
    .local int rx1007_pos
    .local int rx1007_off
    .local int rx1007_eos
    .local int rx1007_rep
    .local pmc rx1007_cur
    .local pmc rx1007_debug
    (rx1007_cur, rx1007_pos, rx1007_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1007_cur
    .local pmc match
    .lex "$/", match
    length rx1007_eos, rx1007_tgt
    gt rx1007_pos, rx1007_eos, rx1007_done
    set rx1007_off, 0
    lt rx1007_pos, 2, rx1007_start
    sub rx1007_off, rx1007_pos, 1
    substr rx1007_tgt, rx1007_tgt, rx1007_off
  rx1007_start:
    eq $I10, 1, rx1007_restart
    if_null rx1007_debug, debug_971
    rx1007_cur."!cursor_debug"("START", "default_value")
  debug_971:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1011_done
    goto rxscan1011_scan
  rxscan1011_loop:
    (rx1007_pos) = rx1007_cur."from"()
    inc rx1007_pos
    rx1007_cur."!cursor_from"(rx1007_pos)
    ge rx1007_pos, rx1007_eos, rxscan1011_done
  rxscan1011_scan:
    set_addr $I10, rxscan1011_loop
    rx1007_cur."!mark_push"(0, rx1007_pos, $I10)
  rxscan1011_done:
.annotate 'line', 463
  # rx subrule "ws" subtype=method negate=
    rx1007_cur."!cursor_pos"(rx1007_pos)
    $P10 = rx1007_cur."ws"()
    unless $P10, rx1007_fail
    rx1007_pos = $P10."pos"()
  # rx literal  "="
    add $I11, rx1007_pos, 1
    gt $I11, rx1007_eos, rx1007_fail
    sub $I11, rx1007_pos, rx1007_off
    ord $I11, rx1007_tgt, $I11
    ne $I11, 61, rx1007_fail
    add rx1007_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1007_cur."!cursor_pos"(rx1007_pos)
    $P10 = rx1007_cur."ws"()
    unless $P10, rx1007_fail
    rx1007_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1007_cur."!cursor_pos"(rx1007_pos)
    $P10 = rx1007_cur."EXPR"("i=")
    unless $P10, rx1007_fail
    rx1007_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1007_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1007_cur."!cursor_pos"(rx1007_pos)
    $P10 = rx1007_cur."ws"()
    unless $P10, rx1007_fail
    rx1007_pos = $P10."pos"()
  # rx pass
    rx1007_cur."!cursor_pass"(rx1007_pos, "default_value")
    if_null rx1007_debug, debug_972
    rx1007_cur."!cursor_debug"("PASS", "default_value", " at pos=", rx1007_pos)
  debug_972:
    .return (rx1007_cur)
  rx1007_restart:
.annotate 'line', 10
    if_null rx1007_debug, debug_973
    rx1007_cur."!cursor_debug"("NEXT", "default_value")
  debug_973:
  rx1007_fail:
    (rx1007_rep, rx1007_pos, $I10, $P10) = rx1007_cur."!mark_fail"(0)
    lt rx1007_pos, -1, rx1007_done
    eq rx1007_pos, -1, rx1007_fail
    jump $I10
  rx1007_done:
    rx1007_cur."!cursor_fail"()
    if_null rx1007_debug, debug_974
    rx1007_cur."!cursor_debug"("FAIL", "default_value")
  debug_974:
    .return (rx1007_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__default_value"  :nsentry("!PREFIX__default_value") :subid("201_1300062003.824") :method
.annotate 'line', 10
    $P1009 = self."!PREFIX__!subrule"("ws", "")
    new $P1010, "ResizablePMCArray"
    push $P1010, $P1009
    .return ($P1010)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait"  :subid("202_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1016_tgt
    .local int rx1016_pos
    .local int rx1016_off
    .local int rx1016_eos
    .local int rx1016_rep
    .local pmc rx1016_cur
    .local pmc rx1016_debug
    (rx1016_cur, rx1016_pos, rx1016_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1016_cur
    .local pmc match
    .lex "$/", match
    length rx1016_eos, rx1016_tgt
    gt rx1016_pos, rx1016_eos, rx1016_done
    set rx1016_off, 0
    lt rx1016_pos, 2, rx1016_start
    sub rx1016_off, rx1016_pos, 1
    substr rx1016_tgt, rx1016_tgt, rx1016_off
  rx1016_start:
    eq $I10, 1, rx1016_restart
    if_null rx1016_debug, debug_975
    rx1016_cur."!cursor_debug"("START", "trait")
  debug_975:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1020_done
    goto rxscan1020_scan
  rxscan1020_loop:
    (rx1016_pos) = rx1016_cur."from"()
    inc rx1016_pos
    rx1016_cur."!cursor_from"(rx1016_pos)
    ge rx1016_pos, rx1016_eos, rxscan1020_done
  rxscan1020_scan:
    set_addr $I10, rxscan1020_loop
    rx1016_cur."!mark_push"(0, rx1016_pos, $I10)
  rxscan1020_done:
.annotate 'line', 465
  # rx subrule "ws" subtype=method negate=
    rx1016_cur."!cursor_pos"(rx1016_pos)
    $P10 = rx1016_cur."ws"()
    unless $P10, rx1016_fail
    rx1016_pos = $P10."pos"()
  # rx subrule "trait_mod" subtype=capture negate=
    rx1016_cur."!cursor_pos"(rx1016_pos)
    $P10 = rx1016_cur."trait_mod"()
    unless $P10, rx1016_fail
    rx1016_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("trait_mod")
    rx1016_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1016_cur."!cursor_pos"(rx1016_pos)
    $P10 = rx1016_cur."ws"()
    unless $P10, rx1016_fail
    rx1016_pos = $P10."pos"()
  # rx pass
    rx1016_cur."!cursor_pass"(rx1016_pos, "trait")
    if_null rx1016_debug, debug_976
    rx1016_cur."!cursor_debug"("PASS", "trait", " at pos=", rx1016_pos)
  debug_976:
    .return (rx1016_cur)
  rx1016_restart:
.annotate 'line', 10
    if_null rx1016_debug, debug_977
    rx1016_cur."!cursor_debug"("NEXT", "trait")
  debug_977:
  rx1016_fail:
    (rx1016_rep, rx1016_pos, $I10, $P10) = rx1016_cur."!mark_fail"(0)
    lt rx1016_pos, -1, rx1016_done
    eq rx1016_pos, -1, rx1016_fail
    jump $I10
  rx1016_done:
    rx1016_cur."!cursor_fail"()
    if_null rx1016_debug, debug_978
    rx1016_cur."!cursor_debug"("FAIL", "trait")
  debug_978:
    .return (rx1016_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait"  :nsentry("!PREFIX__trait") :subid("203_1300062003.824") :method
.annotate 'line', 10
    $P1018 = self."!PREFIX__!subrule"("ws", "")
    new $P1019, "ResizablePMCArray"
    push $P1019, $P1018
    .return ($P1019)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod"  :subid("204_1300062003.824")
    .param pmc param_1024
.annotate 'line', 467
    .lex "self", param_1024
    $P1025 = param_1024."!protoregex"("trait_mod")
    .return ($P1025)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod"  :subid("205_1300062003.824")
    .param pmc param_1027
.annotate 'line', 467
    .lex "self", param_1027
    $P1028 = param_1027."!PREFIX__!protoregex"("trait_mod")
    .return ($P1028)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod:sym<is>"  :subid("206_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1030_tgt
    .local int rx1030_pos
    .local int rx1030_off
    .local int rx1030_eos
    .local int rx1030_rep
    .local pmc rx1030_cur
    .local pmc rx1030_debug
    (rx1030_cur, rx1030_pos, rx1030_tgt, $I10) = self."!cursor_start"()
    rx1030_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx1030_cur
    .local pmc match
    .lex "$/", match
    length rx1030_eos, rx1030_tgt
    gt rx1030_pos, rx1030_eos, rx1030_done
    set rx1030_off, 0
    lt rx1030_pos, 2, rx1030_start
    sub rx1030_off, rx1030_pos, 1
    substr rx1030_tgt, rx1030_tgt, rx1030_off
  rx1030_start:
    eq $I10, 1, rx1030_restart
    if_null rx1030_debug, debug_979
    rx1030_cur."!cursor_debug"("START", "trait_mod:sym<is>")
  debug_979:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1034_done
    goto rxscan1034_scan
  rxscan1034_loop:
    (rx1030_pos) = rx1030_cur."from"()
    inc rx1030_pos
    rx1030_cur."!cursor_from"(rx1030_pos)
    ge rx1030_pos, rx1030_eos, rxscan1034_done
  rxscan1034_scan:
    set_addr $I10, rxscan1034_loop
    rx1030_cur."!mark_push"(0, rx1030_pos, $I10)
  rxscan1034_done:
.annotate 'line', 468
  # rx subcapture "sym"
    set_addr $I10, rxcap_1035_fail
    rx1030_cur."!mark_push"(0, rx1030_pos, $I10)
  # rx literal  "is"
    add $I11, rx1030_pos, 2
    gt $I11, rx1030_eos, rx1030_fail
    sub $I11, rx1030_pos, rx1030_off
    substr $S10, rx1030_tgt, $I11, 2
    ne $S10, "is", rx1030_fail
    add rx1030_pos, 2
    set_addr $I10, rxcap_1035_fail
    ($I12, $I11) = rx1030_cur."!mark_peek"($I10)
    rx1030_cur."!cursor_pos"($I11)
    ($P10) = rx1030_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1030_pos, "")
    rx1030_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1035_done
  rxcap_1035_fail:
    goto rx1030_fail
  rxcap_1035_done:
  # rx subrule "ws" subtype=method negate=
    rx1030_cur."!cursor_pos"(rx1030_pos)
    $P10 = rx1030_cur."ws"()
    unless $P10, rx1030_fail
    rx1030_pos = $P10."pos"()
  # rx subrule "deflongname" subtype=capture negate=
    rx1030_cur."!cursor_pos"(rx1030_pos)
    $P10 = rx1030_cur."deflongname"()
    unless $P10, rx1030_fail
    rx1030_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx1030_pos = $P10."pos"()
  # rx rxquantr1037 ** 0..1
    set_addr $I10, rxquantr1037_done
    rx1030_cur."!mark_push"(0, rx1030_pos, $I10)
  rxquantr1037_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx1030_cur."!cursor_pos"(rx1030_pos)
    $P10 = rx1030_cur."circumfix"()
    unless $P10, rx1030_fail
    goto rxsubrule1038_pass
  rxsubrule1038_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1030_fail
  rxsubrule1038_pass:
    set_addr $I10, rxsubrule1038_back
    rx1030_cur."!mark_push"(0, rx1030_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx1030_pos = $P10."pos"()
    set_addr $I10, rxquantr1037_done
    (rx1030_rep) = rx1030_cur."!mark_commit"($I10)
  rxquantr1037_done:
  # rx subrule "ws" subtype=method negate=
    rx1030_cur."!cursor_pos"(rx1030_pos)
    $P10 = rx1030_cur."ws"()
    unless $P10, rx1030_fail
    rx1030_pos = $P10."pos"()
  # rx pass
    rx1030_cur."!cursor_pass"(rx1030_pos, "trait_mod:sym<is>")
    if_null rx1030_debug, debug_980
    rx1030_cur."!cursor_debug"("PASS", "trait_mod:sym<is>", " at pos=", rx1030_pos)
  debug_980:
    .return (rx1030_cur)
  rx1030_restart:
.annotate 'line', 10
    if_null rx1030_debug, debug_981
    rx1030_cur."!cursor_debug"("NEXT", "trait_mod:sym<is>")
  debug_981:
  rx1030_fail:
    (rx1030_rep, rx1030_pos, $I10, $P10) = rx1030_cur."!mark_fail"(0)
    lt rx1030_pos, -1, rx1030_done
    eq rx1030_pos, -1, rx1030_fail
    jump $I10
  rx1030_done:
    rx1030_cur."!cursor_fail"()
    if_null rx1030_debug, debug_982
    rx1030_cur."!cursor_debug"("FAIL", "trait_mod:sym<is>")
  debug_982:
    .return (rx1030_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod:sym<is>"  :nsentry("!PREFIX__trait_mod:sym<is>") :subid("207_1300062003.824") :method
.annotate 'line', 10
    $P1032 = self."!PREFIX__!subrule"("ws", "is")
    new $P1033, "ResizablePMCArray"
    push $P1033, $P1032
    .return ($P1033)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "regex_declarator"  :subid("208_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1041_tgt
    .local int rx1041_pos
    .local int rx1041_off
    .local int rx1041_eos
    .local int rx1041_rep
    .local pmc rx1041_cur
    .local pmc rx1041_debug
    (rx1041_cur, rx1041_pos, rx1041_tgt, $I10) = self."!cursor_start"()
    rx1041_cur."!cursor_caparray"("signature")
    .lex unicode:"$\x{a2}", rx1041_cur
    .local pmc match
    .lex "$/", match
    length rx1041_eos, rx1041_tgt
    gt rx1041_pos, rx1041_eos, rx1041_done
    set rx1041_off, 0
    lt rx1041_pos, 2, rx1041_start
    sub rx1041_off, rx1041_pos, 1
    substr rx1041_tgt, rx1041_tgt, rx1041_off
  rx1041_start:
    eq $I10, 1, rx1041_restart
    if_null rx1041_debug, debug_983
    rx1041_cur."!cursor_debug"("START", "regex_declarator")
  debug_983:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1045_done
    goto rxscan1045_scan
  rxscan1045_loop:
    (rx1041_pos) = rx1041_cur."from"()
    inc rx1041_pos
    rx1041_cur."!cursor_from"(rx1041_pos)
    ge rx1041_pos, rx1041_eos, rxscan1045_done
  rxscan1045_scan:
    set_addr $I10, rxscan1045_loop
    rx1041_cur."!mark_push"(0, rx1041_pos, $I10)
  rxscan1045_done:
.annotate 'line', 470
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
  alt1047_0:
.annotate 'line', 471
    set_addr $I10, alt1047_1
    rx1041_cur."!mark_push"(0, rx1041_pos, $I10)
.annotate 'line', 472
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
  # rx subcapture "proto"
    set_addr $I10, rxcap_1049_fail
    rx1041_cur."!mark_push"(0, rx1041_pos, $I10)
  # rx literal  "proto"
    add $I11, rx1041_pos, 5
    gt $I11, rx1041_eos, rx1041_fail
    sub $I11, rx1041_pos, rx1041_off
    substr $S10, rx1041_tgt, $I11, 5
    ne $S10, "proto", rx1041_fail
    add rx1041_pos, 5
    set_addr $I10, rxcap_1049_fail
    ($I12, $I11) = rx1041_cur."!mark_peek"($I10)
    rx1041_cur."!cursor_pos"($I11)
    ($P10) = rx1041_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1041_pos, "")
    rx1041_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("proto")
    goto rxcap_1049_done
  rxcap_1049_fail:
    goto rx1041_fail
  rxcap_1049_done:
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
  alt1051_0:
    set_addr $I10, alt1051_1
    rx1041_cur."!mark_push"(0, rx1041_pos, $I10)
  # rx literal  "regex"
    add $I11, rx1041_pos, 5
    gt $I11, rx1041_eos, rx1041_fail
    sub $I11, rx1041_pos, rx1041_off
    substr $S10, rx1041_tgt, $I11, 5
    ne $S10, "regex", rx1041_fail
    add rx1041_pos, 5
    goto alt1051_end
  alt1051_1:
    set_addr $I10, alt1051_2
    rx1041_cur."!mark_push"(0, rx1041_pos, $I10)
  # rx literal  "token"
    add $I11, rx1041_pos, 5
    gt $I11, rx1041_eos, rx1041_fail
    sub $I11, rx1041_pos, rx1041_off
    substr $S10, rx1041_tgt, $I11, 5
    ne $S10, "token", rx1041_fail
    add rx1041_pos, 5
    goto alt1051_end
  alt1051_2:
  # rx literal  "rule"
    add $I11, rx1041_pos, 4
    gt $I11, rx1041_eos, rx1041_fail
    sub $I11, rx1041_pos, rx1041_off
    substr $S10, rx1041_tgt, $I11, 4
    ne $S10, "rule", rx1041_fail
    add rx1041_pos, 4
  alt1051_end:
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
.annotate 'line', 473
  # rx subrule "deflongname" subtype=capture negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."deflongname"()
    unless $P10, rx1041_fail
    rx1041_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1041_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
  alt1054_0:
.annotate 'line', 474
    set_addr $I10, alt1054_1
    rx1041_cur."!mark_push"(0, rx1041_pos, $I10)
.annotate 'line', 475
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx1041_pos, 1
    gt $I11, rx1041_eos, rx1041_fail
    sub $I11, rx1041_pos, rx1041_off
    ord $I11, rx1041_tgt, $I11
    ne $I11, 123, rx1041_fail
    add rx1041_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
  # rx literal  "<...>"
    add $I11, rx1041_pos, 5
    gt $I11, rx1041_eos, rx1041_fail
    sub $I11, rx1041_pos, rx1041_off
    substr $S10, rx1041_tgt, $I11, 5
    ne $S10, "<...>", rx1041_fail
    add rx1041_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1041_pos, 1
    gt $I11, rx1041_eos, rx1041_fail
    sub $I11, rx1041_pos, rx1041_off
    ord $I11, rx1041_tgt, $I11
    ne $I11, 125, rx1041_fail
    add rx1041_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ENDSTMT"()
    unless $P10, rx1041_fail
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
    goto alt1054_end
  alt1054_1:
    set_addr $I10, alt1054_2
    rx1041_cur."!mark_push"(0, rx1041_pos, $I10)
.annotate 'line', 476
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx1041_pos, 1
    gt $I11, rx1041_eos, rx1041_fail
    sub $I11, rx1041_pos, rx1041_off
    ord $I11, rx1041_tgt, $I11
    ne $I11, 123, rx1041_fail
    add rx1041_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
  # rx literal  "<*>"
    add $I11, rx1041_pos, 3
    gt $I11, rx1041_eos, rx1041_fail
    sub $I11, rx1041_pos, rx1041_off
    substr $S10, rx1041_tgt, $I11, 3
    ne $S10, "<*>", rx1041_fail
    add rx1041_pos, 3
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1041_pos, 1
    gt $I11, rx1041_eos, rx1041_fail
    sub $I11, rx1041_pos, rx1041_off
    ord $I11, rx1041_tgt, $I11
    ne $I11, 125, rx1041_fail
    add rx1041_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ENDSTMT"()
    unless $P10, rx1041_fail
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
    goto alt1054_end
  alt1054_2:
.annotate 'line', 477
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."panic"("Proto regex body must be <*> (or <...>, which is deprecated)")
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
  alt1054_end:
.annotate 'line', 478
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
.annotate 'line', 472
    goto alt1047_end
  alt1047_1:
.annotate 'line', 479
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
  # rx subcapture "sym"
    set_addr $I10, rxcap_1068_fail
    rx1041_cur."!mark_push"(0, rx1041_pos, $I10)
  alt1067_0:
    set_addr $I10, alt1067_1
    rx1041_cur."!mark_push"(0, rx1041_pos, $I10)
  # rx literal  "regex"
    add $I11, rx1041_pos, 5
    gt $I11, rx1041_eos, rx1041_fail
    sub $I11, rx1041_pos, rx1041_off
    substr $S10, rx1041_tgt, $I11, 5
    ne $S10, "regex", rx1041_fail
    add rx1041_pos, 5
    goto alt1067_end
  alt1067_1:
    set_addr $I10, alt1067_2
    rx1041_cur."!mark_push"(0, rx1041_pos, $I10)
  # rx literal  "token"
    add $I11, rx1041_pos, 5
    gt $I11, rx1041_eos, rx1041_fail
    sub $I11, rx1041_pos, rx1041_off
    substr $S10, rx1041_tgt, $I11, 5
    ne $S10, "token", rx1041_fail
    add rx1041_pos, 5
    goto alt1067_end
  alt1067_2:
  # rx literal  "rule"
    add $I11, rx1041_pos, 4
    gt $I11, rx1041_eos, rx1041_fail
    sub $I11, rx1041_pos, rx1041_off
    substr $S10, rx1041_tgt, $I11, 4
    ne $S10, "rule", rx1041_fail
    add rx1041_pos, 4
  alt1067_end:
    set_addr $I10, rxcap_1068_fail
    ($I12, $I11) = rx1041_cur."!mark_peek"($I10)
    rx1041_cur."!cursor_pos"($I11)
    ($P10) = rx1041_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1041_pos, "")
    rx1041_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1068_done
  rxcap_1068_fail:
    goto rx1041_fail
  rxcap_1068_done:
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
.annotate 'line', 480
  # rx subrule "deflongname" subtype=capture negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."deflongname"()
    unless $P10, rx1041_fail
    rx1041_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1041_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
.annotate 'line', 481
  # rx subrule "newpad" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."newpad"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
.annotate 'line', 482
  # rx rxquantr1072 ** 0..1
    set_addr $I10, rxquantr1072_done
    rx1041_cur."!mark_push"(0, rx1041_pos, $I10)
  rxquantr1072_loop:
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1041_pos, 1
    gt $I11, rx1041_eos, rx1041_fail
    sub $I11, rx1041_pos, rx1041_off
    ord $I11, rx1041_tgt, $I11
    ne $I11, 40, rx1041_fail
    add rx1041_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."signature"()
    unless $P10, rx1041_fail
    rx1041_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx1041_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1041_pos, 1
    gt $I11, rx1041_eos, rx1041_fail
    sub $I11, rx1041_pos, rx1041_off
    ord $I11, rx1041_tgt, $I11
    ne $I11, 41, rx1041_fail
    add rx1041_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
    set_addr $I10, rxquantr1072_done
    (rx1041_rep) = rx1041_cur."!mark_commit"($I10)
  rxquantr1072_done:
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
.annotate 'line', 483
  # rx reduce name="regex_declarator" key="open"
    rx1041_cur."!cursor_pos"(rx1041_pos)
    rx1041_cur."!reduce"("regex_declarator", "open")
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
.annotate 'line', 484
  # rx literal  "{"
    add $I11, rx1041_pos, 1
    gt $I11, rx1041_eos, rx1041_fail
    sub $I11, rx1041_pos, rx1041_off
    ord $I11, rx1041_tgt, $I11
    ne $I11, 123, rx1041_fail
    add rx1041_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."LANG"("Regex", "nibbler")
    unless $P10, rx1041_fail
    rx1041_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx1041_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1041_pos, 1
    gt $I11, rx1041_eos, rx1041_fail
    sub $I11, rx1041_pos, rx1041_off
    ord $I11, rx1041_tgt, $I11
    ne $I11, 125, rx1041_fail
    add rx1041_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ENDSTMT"()
    unless $P10, rx1041_fail
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
  alt1047_end:
.annotate 'line', 485
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
.annotate 'line', 470
  # rx pass
    rx1041_cur."!cursor_pass"(rx1041_pos, "regex_declarator")
    if_null rx1041_debug, debug_984
    rx1041_cur."!cursor_debug"("PASS", "regex_declarator", " at pos=", rx1041_pos)
  debug_984:
    .return (rx1041_cur)
  rx1041_restart:
.annotate 'line', 10
    if_null rx1041_debug, debug_985
    rx1041_cur."!cursor_debug"("NEXT", "regex_declarator")
  debug_985:
  rx1041_fail:
    (rx1041_rep, rx1041_pos, $I10, $P10) = rx1041_cur."!mark_fail"(0)
    lt rx1041_pos, -1, rx1041_done
    eq rx1041_pos, -1, rx1041_fail
    jump $I10
  rx1041_done:
    rx1041_cur."!cursor_fail"()
    if_null rx1041_debug, debug_986
    rx1041_cur."!cursor_debug"("FAIL", "regex_declarator")
  debug_986:
    .return (rx1041_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__regex_declarator"  :nsentry("!PREFIX__regex_declarator") :subid("209_1300062003.824") :method
.annotate 'line', 10
    $P1043 = self."!PREFIX__!subrule"("ws", "")
    new $P1044, "ResizablePMCArray"
    push $P1044, $P1043
    .return ($P1044)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "dotty"  :subid("210_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1082_tgt
    .local int rx1082_pos
    .local int rx1082_off
    .local int rx1082_eos
    .local int rx1082_rep
    .local pmc rx1082_cur
    .local pmc rx1082_debug
    (rx1082_cur, rx1082_pos, rx1082_tgt, $I10) = self."!cursor_start"()
    rx1082_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1082_cur
    .local pmc match
    .lex "$/", match
    length rx1082_eos, rx1082_tgt
    gt rx1082_pos, rx1082_eos, rx1082_done
    set rx1082_off, 0
    lt rx1082_pos, 2, rx1082_start
    sub rx1082_off, rx1082_pos, 1
    substr rx1082_tgt, rx1082_tgt, rx1082_off
  rx1082_start:
    eq $I10, 1, rx1082_restart
    if_null rx1082_debug, debug_987
    rx1082_cur."!cursor_debug"("START", "dotty")
  debug_987:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1086_done
    goto rxscan1086_scan
  rxscan1086_loop:
    (rx1082_pos) = rx1082_cur."from"()
    inc rx1082_pos
    rx1082_cur."!cursor_from"(rx1082_pos)
    ge rx1082_pos, rx1082_eos, rxscan1086_done
  rxscan1086_scan:
    set_addr $I10, rxscan1086_loop
    rx1082_cur."!mark_push"(0, rx1082_pos, $I10)
  rxscan1086_done:
.annotate 'line', 489
  # rx literal  "."
    add $I11, rx1082_pos, 1
    gt $I11, rx1082_eos, rx1082_fail
    sub $I11, rx1082_pos, rx1082_off
    ord $I11, rx1082_tgt, $I11
    ne $I11, 46, rx1082_fail
    add rx1082_pos, 1
  alt1087_0:
.annotate 'line', 490
    set_addr $I10, alt1087_1
    rx1082_cur."!mark_push"(0, rx1082_pos, $I10)
  # rx subrule "deflongname" subtype=capture negate=
    rx1082_cur."!cursor_pos"(rx1082_pos)
    $P10 = rx1082_cur."deflongname"()
    unless $P10, rx1082_fail
    rx1082_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname=deflongname")
    rx1082_pos = $P10."pos"()
    goto alt1087_end
  alt1087_1:
.annotate 'line', 491
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1082_pos, rx1082_off
    substr $S10, rx1082_tgt, $I10, 1
    index $I11, "'\"", $S10
    lt $I11, 0, rx1082_fail
  # rx subrule "quote" subtype=capture negate=
    rx1082_cur."!cursor_pos"(rx1082_pos)
    $P10 = rx1082_cur."quote"()
    unless $P10, rx1082_fail
    rx1082_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1082_pos = $P10."pos"()
  alt1088_0:
.annotate 'line', 492
    set_addr $I10, alt1088_1
    rx1082_cur."!mark_push"(0, rx1082_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1082_pos, rx1082_off
    substr $S10, rx1082_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1082_fail
    goto alt1088_end
  alt1088_1:
  # rx subrule "panic" subtype=method negate=
    rx1082_cur."!cursor_pos"(rx1082_pos)
    $P10 = rx1082_cur."panic"("Quoted method name requires parenthesized arguments")
    unless $P10, rx1082_fail
    rx1082_pos = $P10."pos"()
  alt1088_end:
  alt1087_end:
.annotate 'line', 498
  # rx rxquantr1089 ** 0..1
    set_addr $I10, rxquantr1089_done
    rx1082_cur."!mark_push"(0, rx1082_pos, $I10)
  rxquantr1089_loop:
  alt1090_0:
.annotate 'line', 495
    set_addr $I10, alt1090_1
    rx1082_cur."!mark_push"(0, rx1082_pos, $I10)
.annotate 'line', 496
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1082_pos, rx1082_off
    substr $S10, rx1082_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1082_fail
  # rx subrule "args" subtype=capture negate=
    rx1082_cur."!cursor_pos"(rx1082_pos)
    $P10 = rx1082_cur."args"()
    unless $P10, rx1082_fail
    rx1082_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1082_pos = $P10."pos"()
    goto alt1090_end
  alt1090_1:
.annotate 'line', 497
  # rx literal  ":"
    add $I11, rx1082_pos, 1
    gt $I11, rx1082_eos, rx1082_fail
    sub $I11, rx1082_pos, rx1082_off
    ord $I11, rx1082_tgt, $I11
    ne $I11, 58, rx1082_fail
    add rx1082_pos, 1
  # rx charclass s
    ge rx1082_pos, rx1082_eos, rx1082_fail
    sub $I10, rx1082_pos, rx1082_off
    is_cclass $I11, 32, rx1082_tgt, $I10
    unless $I11, rx1082_fail
    inc rx1082_pos
  # rx subrule "arglist" subtype=capture negate=
    rx1082_cur."!cursor_pos"(rx1082_pos)
    $P10 = rx1082_cur."arglist"()
    unless $P10, rx1082_fail
    rx1082_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1082_pos = $P10."pos"()
  alt1090_end:
.annotate 'line', 498
    set_addr $I10, rxquantr1089_done
    (rx1082_rep) = rx1082_cur."!mark_commit"($I10)
  rxquantr1089_done:
.annotate 'line', 488
  # rx pass
    rx1082_cur."!cursor_pass"(rx1082_pos, "dotty")
    if_null rx1082_debug, debug_988
    rx1082_cur."!cursor_debug"("PASS", "dotty", " at pos=", rx1082_pos)
  debug_988:
    .return (rx1082_cur)
  rx1082_restart:
.annotate 'line', 10
    if_null rx1082_debug, debug_989
    rx1082_cur."!cursor_debug"("NEXT", "dotty")
  debug_989:
  rx1082_fail:
    (rx1082_rep, rx1082_pos, $I10, $P10) = rx1082_cur."!mark_fail"(0)
    lt rx1082_pos, -1, rx1082_done
    eq rx1082_pos, -1, rx1082_fail
    jump $I10
  rx1082_done:
    rx1082_cur."!cursor_fail"()
    if_null rx1082_debug, debug_990
    rx1082_cur."!cursor_debug"("FAIL", "dotty")
  debug_990:
    .return (rx1082_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__dotty"  :nsentry("!PREFIX__dotty") :subid("211_1300062003.824") :method
.annotate 'line', 10
    $P1084 = self."!PREFIX__!subrule"("deflongname", ".")
    new $P1085, "ResizablePMCArray"
    push $P1085, "'"
    push $P1085, "\""
    push $P1085, $P1084
    .return ($P1085)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term"  :subid("212_1300062003.824")
    .param pmc param_1092
.annotate 'line', 502
    .lex "self", param_1092
    $P1093 = param_1092."!protoregex"("term")
    .return ($P1093)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term"  :subid("213_1300062003.824")
    .param pmc param_1095
.annotate 'line', 502
    .lex "self", param_1095
    $P1096 = param_1095."!PREFIX__!protoregex"("term")
    .return ($P1096)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<self>"  :subid("214_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1098_tgt
    .local int rx1098_pos
    .local int rx1098_off
    .local int rx1098_eos
    .local int rx1098_rep
    .local pmc rx1098_cur
    .local pmc rx1098_debug
    (rx1098_cur, rx1098_pos, rx1098_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1098_cur
    .local pmc match
    .lex "$/", match
    length rx1098_eos, rx1098_tgt
    gt rx1098_pos, rx1098_eos, rx1098_done
    set rx1098_off, 0
    lt rx1098_pos, 2, rx1098_start
    sub rx1098_off, rx1098_pos, 1
    substr rx1098_tgt, rx1098_tgt, rx1098_off
  rx1098_start:
    eq $I10, 1, rx1098_restart
    if_null rx1098_debug, debug_991
    rx1098_cur."!cursor_debug"("START", "term:sym<self>")
  debug_991:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1101_done
    goto rxscan1101_scan
  rxscan1101_loop:
    (rx1098_pos) = rx1098_cur."from"()
    inc rx1098_pos
    rx1098_cur."!cursor_from"(rx1098_pos)
    ge rx1098_pos, rx1098_eos, rxscan1101_done
  rxscan1101_scan:
    set_addr $I10, rxscan1101_loop
    rx1098_cur."!mark_push"(0, rx1098_pos, $I10)
  rxscan1101_done:
.annotate 'line', 504
  # rx subcapture "sym"
    set_addr $I10, rxcap_1102_fail
    rx1098_cur."!mark_push"(0, rx1098_pos, $I10)
  # rx literal  "self"
    add $I11, rx1098_pos, 4
    gt $I11, rx1098_eos, rx1098_fail
    sub $I11, rx1098_pos, rx1098_off
    substr $S10, rx1098_tgt, $I11, 4
    ne $S10, "self", rx1098_fail
    add rx1098_pos, 4
    set_addr $I10, rxcap_1102_fail
    ($I12, $I11) = rx1098_cur."!mark_peek"($I10)
    rx1098_cur."!cursor_pos"($I11)
    ($P10) = rx1098_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1098_pos, "")
    rx1098_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1102_done
  rxcap_1102_fail:
    goto rx1098_fail
  rxcap_1102_done:
  # rxanchor rwb
    le rx1098_pos, 0, rx1098_fail
    sub $I10, rx1098_pos, rx1098_off
    is_cclass $I11, 8192, rx1098_tgt, $I10
    if $I11, rx1098_fail
    dec $I10
    is_cclass $I11, 8192, rx1098_tgt, $I10
    unless $I11, rx1098_fail
  # rx pass
    rx1098_cur."!cursor_pass"(rx1098_pos, "term:sym<self>")
    if_null rx1098_debug, debug_992
    rx1098_cur."!cursor_debug"("PASS", "term:sym<self>", " at pos=", rx1098_pos)
  debug_992:
    .return (rx1098_cur)
  rx1098_restart:
.annotate 'line', 10
    if_null rx1098_debug, debug_993
    rx1098_cur."!cursor_debug"("NEXT", "term:sym<self>")
  debug_993:
  rx1098_fail:
    (rx1098_rep, rx1098_pos, $I10, $P10) = rx1098_cur."!mark_fail"(0)
    lt rx1098_pos, -1, rx1098_done
    eq rx1098_pos, -1, rx1098_fail
    jump $I10
  rx1098_done:
    rx1098_cur."!cursor_fail"()
    if_null rx1098_debug, debug_994
    rx1098_cur."!cursor_debug"("FAIL", "term:sym<self>")
  debug_994:
    .return (rx1098_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<self>"  :nsentry("!PREFIX__term:sym<self>") :subid("215_1300062003.824") :method
.annotate 'line', 10
    new $P1100, "ResizablePMCArray"
    push $P1100, "self"
    .return ($P1100)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<identifier>"  :subid("216_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1104_tgt
    .local int rx1104_pos
    .local int rx1104_off
    .local int rx1104_eos
    .local int rx1104_rep
    .local pmc rx1104_cur
    .local pmc rx1104_debug
    (rx1104_cur, rx1104_pos, rx1104_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1104_cur
    .local pmc match
    .lex "$/", match
    length rx1104_eos, rx1104_tgt
    gt rx1104_pos, rx1104_eos, rx1104_done
    set rx1104_off, 0
    lt rx1104_pos, 2, rx1104_start
    sub rx1104_off, rx1104_pos, 1
    substr rx1104_tgt, rx1104_tgt, rx1104_off
  rx1104_start:
    eq $I10, 1, rx1104_restart
    if_null rx1104_debug, debug_995
    rx1104_cur."!cursor_debug"("START", "term:sym<identifier>")
  debug_995:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1108_done
    goto rxscan1108_scan
  rxscan1108_loop:
    (rx1104_pos) = rx1104_cur."from"()
    inc rx1104_pos
    rx1104_cur."!cursor_from"(rx1104_pos)
    ge rx1104_pos, rx1104_eos, rxscan1108_done
  rxscan1108_scan:
    set_addr $I10, rxscan1108_loop
    rx1104_cur."!mark_push"(0, rx1104_pos, $I10)
  rxscan1108_done:
.annotate 'line', 507
  # rx subrule "deflongname" subtype=capture negate=
    rx1104_cur."!cursor_pos"(rx1104_pos)
    $P10 = rx1104_cur."deflongname"()
    unless $P10, rx1104_fail
    rx1104_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1104_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1104_pos, rx1104_off
    substr $S10, rx1104_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1104_fail
  # rx subrule "args" subtype=capture negate=
    rx1104_cur."!cursor_pos"(rx1104_pos)
    $P10 = rx1104_cur."args"()
    unless $P10, rx1104_fail
    rx1104_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1104_pos = $P10."pos"()
.annotate 'line', 506
  # rx pass
    rx1104_cur."!cursor_pass"(rx1104_pos, "term:sym<identifier>")
    if_null rx1104_debug, debug_996
    rx1104_cur."!cursor_debug"("PASS", "term:sym<identifier>", " at pos=", rx1104_pos)
  debug_996:
    .return (rx1104_cur)
  rx1104_restart:
.annotate 'line', 10
    if_null rx1104_debug, debug_997
    rx1104_cur."!cursor_debug"("NEXT", "term:sym<identifier>")
  debug_997:
  rx1104_fail:
    (rx1104_rep, rx1104_pos, $I10, $P10) = rx1104_cur."!mark_fail"(0)
    lt rx1104_pos, -1, rx1104_done
    eq rx1104_pos, -1, rx1104_fail
    jump $I10
  rx1104_done:
    rx1104_cur."!cursor_fail"()
    if_null rx1104_debug, debug_998
    rx1104_cur."!cursor_debug"("FAIL", "term:sym<identifier>")
  debug_998:
    .return (rx1104_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<identifier>"  :nsentry("!PREFIX__term:sym<identifier>") :subid("217_1300062003.824") :method
.annotate 'line', 10
    $P1106 = self."!PREFIX__!subrule"("deflongname", "")
    new $P1107, "ResizablePMCArray"
    push $P1107, $P1106
    .return ($P1107)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<name>"  :subid("218_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1110_tgt
    .local int rx1110_pos
    .local int rx1110_off
    .local int rx1110_eos
    .local int rx1110_rep
    .local pmc rx1110_cur
    .local pmc rx1110_debug
    (rx1110_cur, rx1110_pos, rx1110_tgt, $I10) = self."!cursor_start"()
    rx1110_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1110_cur
    .local pmc match
    .lex "$/", match
    length rx1110_eos, rx1110_tgt
    gt rx1110_pos, rx1110_eos, rx1110_done
    set rx1110_off, 0
    lt rx1110_pos, 2, rx1110_start
    sub rx1110_off, rx1110_pos, 1
    substr rx1110_tgt, rx1110_tgt, rx1110_off
  rx1110_start:
    eq $I10, 1, rx1110_restart
    if_null rx1110_debug, debug_999
    rx1110_cur."!cursor_debug"("START", "term:sym<name>")
  debug_999:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1114_done
    goto rxscan1114_scan
  rxscan1114_loop:
    (rx1110_pos) = rx1110_cur."from"()
    inc rx1110_pos
    rx1110_cur."!cursor_from"(rx1110_pos)
    ge rx1110_pos, rx1110_eos, rxscan1114_done
  rxscan1114_scan:
    set_addr $I10, rxscan1114_loop
    rx1110_cur."!mark_push"(0, rx1110_pos, $I10)
  rxscan1114_done:
.annotate 'line', 511
  # rx subrule "name" subtype=capture negate=
    rx1110_cur."!cursor_pos"(rx1110_pos)
    $P10 = rx1110_cur."name"()
    unless $P10, rx1110_fail
    rx1110_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1110_pos = $P10."pos"()
  # rx rxquantr1115 ** 0..1
    set_addr $I10, rxquantr1115_done
    rx1110_cur."!mark_push"(0, rx1110_pos, $I10)
  rxquantr1115_loop:
  # rx subrule "args" subtype=capture negate=
    rx1110_cur."!cursor_pos"(rx1110_pos)
    $P10 = rx1110_cur."args"()
    unless $P10, rx1110_fail
    goto rxsubrule1116_pass
  rxsubrule1116_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1110_fail
  rxsubrule1116_pass:
    set_addr $I10, rxsubrule1116_back
    rx1110_cur."!mark_push"(0, rx1110_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1110_pos = $P10."pos"()
    set_addr $I10, rxquantr1115_done
    (rx1110_rep) = rx1110_cur."!mark_commit"($I10)
  rxquantr1115_done:
.annotate 'line', 510
  # rx pass
    rx1110_cur."!cursor_pass"(rx1110_pos, "term:sym<name>")
    if_null rx1110_debug, debug_1000
    rx1110_cur."!cursor_debug"("PASS", "term:sym<name>", " at pos=", rx1110_pos)
  debug_1000:
    .return (rx1110_cur)
  rx1110_restart:
.annotate 'line', 10
    if_null rx1110_debug, debug_1001
    rx1110_cur."!cursor_debug"("NEXT", "term:sym<name>")
  debug_1001:
  rx1110_fail:
    (rx1110_rep, rx1110_pos, $I10, $P10) = rx1110_cur."!mark_fail"(0)
    lt rx1110_pos, -1, rx1110_done
    eq rx1110_pos, -1, rx1110_fail
    jump $I10
  rx1110_done:
    rx1110_cur."!cursor_fail"()
    if_null rx1110_debug, debug_1002
    rx1110_cur."!cursor_debug"("FAIL", "term:sym<name>")
  debug_1002:
    .return (rx1110_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<name>"  :nsentry("!PREFIX__term:sym<name>") :subid("219_1300062003.824") :method
.annotate 'line', 10
    $P1112 = self."!PREFIX__!subrule"("name", "")
    new $P1113, "ResizablePMCArray"
    push $P1113, $P1112
    .return ($P1113)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<pir::op>"  :subid("220_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1118_tgt
    .local int rx1118_pos
    .local int rx1118_off
    .local int rx1118_eos
    .local int rx1118_rep
    .local pmc rx1118_cur
    .local pmc rx1118_debug
    (rx1118_cur, rx1118_pos, rx1118_tgt, $I10) = self."!cursor_start"()
    rx1118_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1118_cur
    .local pmc match
    .lex "$/", match
    length rx1118_eos, rx1118_tgt
    gt rx1118_pos, rx1118_eos, rx1118_done
    set rx1118_off, 0
    lt rx1118_pos, 2, rx1118_start
    sub rx1118_off, rx1118_pos, 1
    substr rx1118_tgt, rx1118_tgt, rx1118_off
  rx1118_start:
    eq $I10, 1, rx1118_restart
    if_null rx1118_debug, debug_1003
    rx1118_cur."!cursor_debug"("START", "term:sym<pir::op>")
  debug_1003:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1121_done
    goto rxscan1121_scan
  rxscan1121_loop:
    (rx1118_pos) = rx1118_cur."from"()
    inc rx1118_pos
    rx1118_cur."!cursor_from"(rx1118_pos)
    ge rx1118_pos, rx1118_eos, rxscan1121_done
  rxscan1121_scan:
    set_addr $I10, rxscan1121_loop
    rx1118_cur."!mark_push"(0, rx1118_pos, $I10)
  rxscan1121_done:
.annotate 'line', 515
  # rx literal  "pir::"
    add $I11, rx1118_pos, 5
    gt $I11, rx1118_eos, rx1118_fail
    sub $I11, rx1118_pos, rx1118_off
    substr $S10, rx1118_tgt, $I11, 5
    ne $S10, "pir::", rx1118_fail
    add rx1118_pos, 5
  # rx subcapture "op"
    set_addr $I10, rxcap_1122_fail
    rx1118_cur."!mark_push"(0, rx1118_pos, $I10)
  # rx charclass_q w r 1..-1
    sub $I10, rx1118_pos, rx1118_off
    find_not_cclass $I11, 8192, rx1118_tgt, $I10, rx1118_eos
    add $I12, $I10, 1
    lt $I11, $I12, rx1118_fail
    add rx1118_pos, rx1118_off, $I11
    set_addr $I10, rxcap_1122_fail
    ($I12, $I11) = rx1118_cur."!mark_peek"($I10)
    rx1118_cur."!cursor_pos"($I11)
    ($P10) = rx1118_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1118_pos, "")
    rx1118_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("op")
    goto rxcap_1122_done
  rxcap_1122_fail:
    goto rx1118_fail
  rxcap_1122_done:
  # rx rxquantr1123 ** 0..1
    set_addr $I10, rxquantr1123_done
    rx1118_cur."!mark_push"(0, rx1118_pos, $I10)
  rxquantr1123_loop:
  # rx subrule "args" subtype=capture negate=
    rx1118_cur."!cursor_pos"(rx1118_pos)
    $P10 = rx1118_cur."args"()
    unless $P10, rx1118_fail
    goto rxsubrule1124_pass
  rxsubrule1124_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1118_fail
  rxsubrule1124_pass:
    set_addr $I10, rxsubrule1124_back
    rx1118_cur."!mark_push"(0, rx1118_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1118_pos = $P10."pos"()
    set_addr $I10, rxquantr1123_done
    (rx1118_rep) = rx1118_cur."!mark_commit"($I10)
  rxquantr1123_done:
.annotate 'line', 514
  # rx pass
    rx1118_cur."!cursor_pass"(rx1118_pos, "term:sym<pir::op>")
    if_null rx1118_debug, debug_1004
    rx1118_cur."!cursor_debug"("PASS", "term:sym<pir::op>", " at pos=", rx1118_pos)
  debug_1004:
    .return (rx1118_cur)
  rx1118_restart:
.annotate 'line', 10
    if_null rx1118_debug, debug_1005
    rx1118_cur."!cursor_debug"("NEXT", "term:sym<pir::op>")
  debug_1005:
  rx1118_fail:
    (rx1118_rep, rx1118_pos, $I10, $P10) = rx1118_cur."!mark_fail"(0)
    lt rx1118_pos, -1, rx1118_done
    eq rx1118_pos, -1, rx1118_fail
    jump $I10
  rx1118_done:
    rx1118_cur."!cursor_fail"()
    if_null rx1118_debug, debug_1006
    rx1118_cur."!cursor_debug"("FAIL", "term:sym<pir::op>")
  debug_1006:
    .return (rx1118_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<pir::op>"  :nsentry("!PREFIX__term:sym<pir::op>") :subid("221_1300062003.824") :method
.annotate 'line', 10
    new $P1120, "ResizablePMCArray"
    push $P1120, "pir::"
    .return ($P1120)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<onlystar>"  :subid("222_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .const 'Sub' $P1134 = "224_1300062003.824" 
    capture_lex $P1134
    .local string rx1126_tgt
    .local int rx1126_pos
    .local int rx1126_off
    .local int rx1126_eos
    .local int rx1126_rep
    .local pmc rx1126_cur
    .local pmc rx1126_debug
    (rx1126_cur, rx1126_pos, rx1126_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1126_cur
    .local pmc match
    .lex "$/", match
    length rx1126_eos, rx1126_tgt
    gt rx1126_pos, rx1126_eos, rx1126_done
    set rx1126_off, 0
    lt rx1126_pos, 2, rx1126_start
    sub rx1126_off, rx1126_pos, 1
    substr rx1126_tgt, rx1126_tgt, rx1126_off
  rx1126_start:
    eq $I10, 1, rx1126_restart
    if_null rx1126_debug, debug_1007
    rx1126_cur."!cursor_debug"("START", "term:sym<onlystar>")
  debug_1007:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1129_done
    goto rxscan1129_scan
  rxscan1129_loop:
    (rx1126_pos) = rx1126_cur."from"()
    inc rx1126_pos
    rx1126_cur."!cursor_from"(rx1126_pos)
    ge rx1126_pos, rx1126_eos, rxscan1129_done
  rxscan1129_scan:
    set_addr $I10, rxscan1129_loop
    rx1126_cur."!mark_push"(0, rx1126_pos, $I10)
  rxscan1129_done:
.annotate 'line', 519
  # rx literal  "{*}"
    add $I11, rx1126_pos, 3
    gt $I11, rx1126_eos, rx1126_fail
    sub $I11, rx1126_pos, rx1126_off
    substr $S10, rx1126_tgt, $I11, 3
    ne $S10, "{*}", rx1126_fail
    add rx1126_pos, 3
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1126_cur."!cursor_pos"(rx1126_pos)
    $P10 = rx1126_cur."ENDSTMT"()
    unless $P10, rx1126_fail
  alt1130_0:
.annotate 'line', 520
    set_addr $I10, alt1130_1
    rx1126_cur."!mark_push"(0, rx1126_pos, $I10)
    rx1126_cur."!cursor_pos"(rx1126_pos)
    find_lex $P1131, unicode:"$\x{a2}"
    $P1132 = $P1131."MATCH"()
    store_lex "$/", $P1132
    .const 'Sub' $P1134 = "224_1300062003.824" 
    capture_lex $P1134
    $P1138 = $P1134()
    unless $P1138, rx1126_fail
    goto alt1130_end
  alt1130_1:
  # rx subrule "panic" subtype=method negate=
    rx1126_cur."!cursor_pos"(rx1126_pos)
    $P10 = rx1126_cur."panic"("{*} may only appear in proto")
    unless $P10, rx1126_fail
    rx1126_pos = $P10."pos"()
  alt1130_end:
.annotate 'line', 518
  # rx pass
    rx1126_cur."!cursor_pass"(rx1126_pos, "term:sym<onlystar>")
    if_null rx1126_debug, debug_1010
    rx1126_cur."!cursor_debug"("PASS", "term:sym<onlystar>", " at pos=", rx1126_pos)
  debug_1010:
    .return (rx1126_cur)
  rx1126_restart:
.annotate 'line', 10
    if_null rx1126_debug, debug_1011
    rx1126_cur."!cursor_debug"("NEXT", "term:sym<onlystar>")
  debug_1011:
  rx1126_fail:
    (rx1126_rep, rx1126_pos, $I10, $P10) = rx1126_cur."!mark_fail"(0)
    lt rx1126_pos, -1, rx1126_done
    eq rx1126_pos, -1, rx1126_fail
    jump $I10
  rx1126_done:
    rx1126_cur."!cursor_fail"()
    if_null rx1126_debug, debug_1012
    rx1126_cur."!cursor_debug"("FAIL", "term:sym<onlystar>")
  debug_1012:
    .return (rx1126_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<onlystar>"  :nsentry("!PREFIX__term:sym<onlystar>") :subid("223_1300062003.824") :method
.annotate 'line', 10
    new $P1128, "ResizablePMCArray"
    push $P1128, "{*}"
    .return ($P1128)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1133"  :anon :subid("224_1300062003.824") :outer("222_1300062003.824")
.annotate 'line', 520
    find_dynamic_lex $P1135, "$*MULTINESS"
    unless_null $P1135, vivify_1008
    get_hll_global $P1135, "$MULTINESS"
    unless_null $P1135, vivify_1009
    die "Contextual $*MULTINESS not found"
  vivify_1009:
  vivify_1008:
    set $S1136, $P1135
    iseq $I1137, $S1136, "proto"
    .return ($I1137)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "args"  :subid("225_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1140_tgt
    .local int rx1140_pos
    .local int rx1140_off
    .local int rx1140_eos
    .local int rx1140_rep
    .local pmc rx1140_cur
    .local pmc rx1140_debug
    (rx1140_cur, rx1140_pos, rx1140_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1140_cur
    .local pmc match
    .lex "$/", match
    length rx1140_eos, rx1140_tgt
    gt rx1140_pos, rx1140_eos, rx1140_done
    set rx1140_off, 0
    lt rx1140_pos, 2, rx1140_start
    sub rx1140_off, rx1140_pos, 1
    substr rx1140_tgt, rx1140_tgt, rx1140_off
  rx1140_start:
    eq $I10, 1, rx1140_restart
    if_null rx1140_debug, debug_1013
    rx1140_cur."!cursor_debug"("START", "args")
  debug_1013:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1144_done
    goto rxscan1144_scan
  rxscan1144_loop:
    (rx1140_pos) = rx1140_cur."from"()
    inc rx1140_pos
    rx1140_cur."!cursor_from"(rx1140_pos)
    ge rx1140_pos, rx1140_eos, rxscan1144_done
  rxscan1144_scan:
    set_addr $I10, rxscan1144_loop
    rx1140_cur."!mark_push"(0, rx1140_pos, $I10)
  rxscan1144_done:
.annotate 'line', 524
  # rx literal  "("
    add $I11, rx1140_pos, 1
    gt $I11, rx1140_eos, rx1140_fail
    sub $I11, rx1140_pos, rx1140_off
    ord $I11, rx1140_tgt, $I11
    ne $I11, 40, rx1140_fail
    add rx1140_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx1140_cur."!cursor_pos"(rx1140_pos)
    $P10 = rx1140_cur."arglist"()
    unless $P10, rx1140_fail
    rx1140_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1140_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1140_pos, 1
    gt $I11, rx1140_eos, rx1140_fail
    sub $I11, rx1140_pos, rx1140_off
    ord $I11, rx1140_tgt, $I11
    ne $I11, 41, rx1140_fail
    add rx1140_pos, 1
  # rx pass
    rx1140_cur."!cursor_pass"(rx1140_pos, "args")
    if_null rx1140_debug, debug_1014
    rx1140_cur."!cursor_debug"("PASS", "args", " at pos=", rx1140_pos)
  debug_1014:
    .return (rx1140_cur)
  rx1140_restart:
.annotate 'line', 10
    if_null rx1140_debug, debug_1015
    rx1140_cur."!cursor_debug"("NEXT", "args")
  debug_1015:
  rx1140_fail:
    (rx1140_rep, rx1140_pos, $I10, $P10) = rx1140_cur."!mark_fail"(0)
    lt rx1140_pos, -1, rx1140_done
    eq rx1140_pos, -1, rx1140_fail
    jump $I10
  rx1140_done:
    rx1140_cur."!cursor_fail"()
    if_null rx1140_debug, debug_1016
    rx1140_cur."!cursor_debug"("FAIL", "args")
  debug_1016:
    .return (rx1140_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__args"  :nsentry("!PREFIX__args") :subid("226_1300062003.824") :method
.annotate 'line', 10
    $P1142 = self."!PREFIX__!subrule"("arglist", "(")
    new $P1143, "ResizablePMCArray"
    push $P1143, $P1142
    .return ($P1143)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "arglist"  :subid("227_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1146_tgt
    .local int rx1146_pos
    .local int rx1146_off
    .local int rx1146_eos
    .local int rx1146_rep
    .local pmc rx1146_cur
    .local pmc rx1146_debug
    (rx1146_cur, rx1146_pos, rx1146_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1146_cur
    .local pmc match
    .lex "$/", match
    length rx1146_eos, rx1146_tgt
    gt rx1146_pos, rx1146_eos, rx1146_done
    set rx1146_off, 0
    lt rx1146_pos, 2, rx1146_start
    sub rx1146_off, rx1146_pos, 1
    substr rx1146_tgt, rx1146_tgt, rx1146_off
  rx1146_start:
    eq $I10, 1, rx1146_restart
    if_null rx1146_debug, debug_1017
    rx1146_cur."!cursor_debug"("START", "arglist")
  debug_1017:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1150_done
    goto rxscan1150_scan
  rxscan1150_loop:
    (rx1146_pos) = rx1146_cur."from"()
    inc rx1146_pos
    rx1146_cur."!cursor_from"(rx1146_pos)
    ge rx1146_pos, rx1146_eos, rxscan1150_done
  rxscan1150_scan:
    set_addr $I10, rxscan1150_loop
    rx1146_cur."!mark_push"(0, rx1146_pos, $I10)
  rxscan1150_done:
.annotate 'line', 528
  # rx subrule "ws" subtype=method negate=
    rx1146_cur."!cursor_pos"(rx1146_pos)
    $P10 = rx1146_cur."ws"()
    unless $P10, rx1146_fail
    rx1146_pos = $P10."pos"()
  alt1151_0:
.annotate 'line', 529
    set_addr $I10, alt1151_1
    rx1146_cur."!mark_push"(0, rx1146_pos, $I10)
.annotate 'line', 530
  # rx subrule "EXPR" subtype=capture negate=
    rx1146_cur."!cursor_pos"(rx1146_pos)
    $P10 = rx1146_cur."EXPR"("f=")
    unless $P10, rx1146_fail
    rx1146_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1146_pos = $P10."pos"()
    goto alt1151_end
  alt1151_1:
  alt1151_end:
.annotate 'line', 527
  # rx pass
    rx1146_cur."!cursor_pass"(rx1146_pos, "arglist")
    if_null rx1146_debug, debug_1018
    rx1146_cur."!cursor_debug"("PASS", "arglist", " at pos=", rx1146_pos)
  debug_1018:
    .return (rx1146_cur)
  rx1146_restart:
.annotate 'line', 10
    if_null rx1146_debug, debug_1019
    rx1146_cur."!cursor_debug"("NEXT", "arglist")
  debug_1019:
  rx1146_fail:
    (rx1146_rep, rx1146_pos, $I10, $P10) = rx1146_cur."!mark_fail"(0)
    lt rx1146_pos, -1, rx1146_done
    eq rx1146_pos, -1, rx1146_fail
    jump $I10
  rx1146_done:
    rx1146_cur."!cursor_fail"()
    if_null rx1146_debug, debug_1020
    rx1146_cur."!cursor_debug"("FAIL", "arglist")
  debug_1020:
    .return (rx1146_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__arglist"  :nsentry("!PREFIX__arglist") :subid("228_1300062003.824") :method
.annotate 'line', 10
    $P1148 = self."!PREFIX__!subrule"("ws", "")
    new $P1149, "ResizablePMCArray"
    push $P1149, $P1148
    .return ($P1149)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<value>"  :subid("229_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1153_tgt
    .local int rx1153_pos
    .local int rx1153_off
    .local int rx1153_eos
    .local int rx1153_rep
    .local pmc rx1153_cur
    .local pmc rx1153_debug
    (rx1153_cur, rx1153_pos, rx1153_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1153_cur
    .local pmc match
    .lex "$/", match
    length rx1153_eos, rx1153_tgt
    gt rx1153_pos, rx1153_eos, rx1153_done
    set rx1153_off, 0
    lt rx1153_pos, 2, rx1153_start
    sub rx1153_off, rx1153_pos, 1
    substr rx1153_tgt, rx1153_tgt, rx1153_off
  rx1153_start:
    eq $I10, 1, rx1153_restart
    if_null rx1153_debug, debug_1021
    rx1153_cur."!cursor_debug"("START", "term:sym<value>")
  debug_1021:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1157_done
    goto rxscan1157_scan
  rxscan1157_loop:
    (rx1153_pos) = rx1153_cur."from"()
    inc rx1153_pos
    rx1153_cur."!cursor_from"(rx1153_pos)
    ge rx1153_pos, rx1153_eos, rxscan1157_done
  rxscan1157_scan:
    set_addr $I10, rxscan1157_loop
    rx1153_cur."!mark_push"(0, rx1153_pos, $I10)
  rxscan1157_done:
.annotate 'line', 536
  # rx subrule "value" subtype=capture negate=
    rx1153_cur."!cursor_pos"(rx1153_pos)
    $P10 = rx1153_cur."value"()
    unless $P10, rx1153_fail
    rx1153_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("value")
    rx1153_pos = $P10."pos"()
  # rx pass
    rx1153_cur."!cursor_pass"(rx1153_pos, "term:sym<value>")
    if_null rx1153_debug, debug_1022
    rx1153_cur."!cursor_debug"("PASS", "term:sym<value>", " at pos=", rx1153_pos)
  debug_1022:
    .return (rx1153_cur)
  rx1153_restart:
.annotate 'line', 10
    if_null rx1153_debug, debug_1023
    rx1153_cur."!cursor_debug"("NEXT", "term:sym<value>")
  debug_1023:
  rx1153_fail:
    (rx1153_rep, rx1153_pos, $I10, $P10) = rx1153_cur."!mark_fail"(0)
    lt rx1153_pos, -1, rx1153_done
    eq rx1153_pos, -1, rx1153_fail
    jump $I10
  rx1153_done:
    rx1153_cur."!cursor_fail"()
    if_null rx1153_debug, debug_1024
    rx1153_cur."!cursor_debug"("FAIL", "term:sym<value>")
  debug_1024:
    .return (rx1153_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<value>"  :nsentry("!PREFIX__term:sym<value>") :subid("230_1300062003.824") :method
.annotate 'line', 10
    $P1155 = self."!PREFIX__!subrule"("value", "")
    new $P1156, "ResizablePMCArray"
    push $P1156, $P1155
    .return ($P1156)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "value"  :subid("231_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1159_tgt
    .local int rx1159_pos
    .local int rx1159_off
    .local int rx1159_eos
    .local int rx1159_rep
    .local pmc rx1159_cur
    .local pmc rx1159_debug
    (rx1159_cur, rx1159_pos, rx1159_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1159_cur
    .local pmc match
    .lex "$/", match
    length rx1159_eos, rx1159_tgt
    gt rx1159_pos, rx1159_eos, rx1159_done
    set rx1159_off, 0
    lt rx1159_pos, 2, rx1159_start
    sub rx1159_off, rx1159_pos, 1
    substr rx1159_tgt, rx1159_tgt, rx1159_off
  rx1159_start:
    eq $I10, 1, rx1159_restart
    if_null rx1159_debug, debug_1025
    rx1159_cur."!cursor_debug"("START", "value")
  debug_1025:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1164_done
    goto rxscan1164_scan
  rxscan1164_loop:
    (rx1159_pos) = rx1159_cur."from"()
    inc rx1159_pos
    rx1159_cur."!cursor_from"(rx1159_pos)
    ge rx1159_pos, rx1159_eos, rxscan1164_done
  rxscan1164_scan:
    set_addr $I10, rxscan1164_loop
    rx1159_cur."!mark_push"(0, rx1159_pos, $I10)
  rxscan1164_done:
  alt1165_0:
.annotate 'line', 538
    set_addr $I10, alt1165_1
    rx1159_cur."!mark_push"(0, rx1159_pos, $I10)
.annotate 'line', 539
  # rx subrule "quote" subtype=capture negate=
    rx1159_cur."!cursor_pos"(rx1159_pos)
    $P10 = rx1159_cur."quote"()
    unless $P10, rx1159_fail
    rx1159_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1159_pos = $P10."pos"()
    goto alt1165_end
  alt1165_1:
.annotate 'line', 540
  # rx subrule "number" subtype=capture negate=
    rx1159_cur."!cursor_pos"(rx1159_pos)
    $P10 = rx1159_cur."number"()
    unless $P10, rx1159_fail
    rx1159_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("number")
    rx1159_pos = $P10."pos"()
  alt1165_end:
.annotate 'line', 538
  # rx pass
    rx1159_cur."!cursor_pass"(rx1159_pos, "value")
    if_null rx1159_debug, debug_1026
    rx1159_cur."!cursor_debug"("PASS", "value", " at pos=", rx1159_pos)
  debug_1026:
    .return (rx1159_cur)
  rx1159_restart:
.annotate 'line', 10
    if_null rx1159_debug, debug_1027
    rx1159_cur."!cursor_debug"("NEXT", "value")
  debug_1027:
  rx1159_fail:
    (rx1159_rep, rx1159_pos, $I10, $P10) = rx1159_cur."!mark_fail"(0)
    lt rx1159_pos, -1, rx1159_done
    eq rx1159_pos, -1, rx1159_fail
    jump $I10
  rx1159_done:
    rx1159_cur."!cursor_fail"()
    if_null rx1159_debug, debug_1028
    rx1159_cur."!cursor_debug"("FAIL", "value")
  debug_1028:
    .return (rx1159_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__value"  :nsentry("!PREFIX__value") :subid("232_1300062003.824") :method
.annotate 'line', 10
    $P1161 = self."!PREFIX__!subrule"("number", "")
    $P1162 = self."!PREFIX__!subrule"("quote", "")
    new $P1163, "ResizablePMCArray"
    push $P1163, $P1161
    push $P1163, $P1162
    .return ($P1163)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "number"  :subid("233_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1167_tgt
    .local int rx1167_pos
    .local int rx1167_off
    .local int rx1167_eos
    .local int rx1167_rep
    .local pmc rx1167_cur
    .local pmc rx1167_debug
    (rx1167_cur, rx1167_pos, rx1167_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1167_cur
    .local pmc match
    .lex "$/", match
    length rx1167_eos, rx1167_tgt
    gt rx1167_pos, rx1167_eos, rx1167_done
    set rx1167_off, 0
    lt rx1167_pos, 2, rx1167_start
    sub rx1167_off, rx1167_pos, 1
    substr rx1167_tgt, rx1167_tgt, rx1167_off
  rx1167_start:
    eq $I10, 1, rx1167_restart
    if_null rx1167_debug, debug_1029
    rx1167_cur."!cursor_debug"("START", "number")
  debug_1029:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1170_done
    goto rxscan1170_scan
  rxscan1170_loop:
    (rx1167_pos) = rx1167_cur."from"()
    inc rx1167_pos
    rx1167_cur."!cursor_from"(rx1167_pos)
    ge rx1167_pos, rx1167_eos, rxscan1170_done
  rxscan1170_scan:
    set_addr $I10, rxscan1170_loop
    rx1167_cur."!mark_push"(0, rx1167_pos, $I10)
  rxscan1170_done:
.annotate 'line', 544
  # rx subcapture "sign"
    set_addr $I10, rxcap_1172_fail
    rx1167_cur."!mark_push"(0, rx1167_pos, $I10)
  # rx enumcharlist_q negate=0  r 0..1
    sub $I10, rx1167_pos, rx1167_off
    set rx1167_rep, 0
    sub $I12, rx1167_eos, rx1167_pos
    le $I12, 1, rxenumcharlistq1171_loop
    set $I12, 1
  rxenumcharlistq1171_loop:
    le $I12, 0, rxenumcharlistq1171_done
    substr $S10, rx1167_tgt, $I10, 1
    index $I11, "+-", $S10
    lt $I11, 0, rxenumcharlistq1171_done
    inc rx1167_rep
  rxenumcharlistq1171_done:
    add rx1167_pos, rx1167_pos, rx1167_rep
    set_addr $I10, rxcap_1172_fail
    ($I12, $I11) = rx1167_cur."!mark_peek"($I10)
    rx1167_cur."!cursor_pos"($I11)
    ($P10) = rx1167_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1167_pos, "")
    rx1167_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sign")
    goto rxcap_1172_done
  rxcap_1172_fail:
    goto rx1167_fail
  rxcap_1172_done:
  alt1173_0:
.annotate 'line', 545
    set_addr $I10, alt1173_1
    rx1167_cur."!mark_push"(0, rx1167_pos, $I10)
  # rx subrule "dec_number" subtype=capture negate=
    rx1167_cur."!cursor_pos"(rx1167_pos)
    $P10 = rx1167_cur."dec_number"()
    unless $P10, rx1167_fail
    rx1167_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dec_number")
    rx1167_pos = $P10."pos"()
    goto alt1173_end
  alt1173_1:
  # rx subrule "integer" subtype=capture negate=
    rx1167_cur."!cursor_pos"(rx1167_pos)
    $P10 = rx1167_cur."integer"()
    unless $P10, rx1167_fail
    rx1167_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("integer")
    rx1167_pos = $P10."pos"()
  alt1173_end:
.annotate 'line', 543
  # rx pass
    rx1167_cur."!cursor_pass"(rx1167_pos, "number")
    if_null rx1167_debug, debug_1030
    rx1167_cur."!cursor_debug"("PASS", "number", " at pos=", rx1167_pos)
  debug_1030:
    .return (rx1167_cur)
  rx1167_restart:
.annotate 'line', 10
    if_null rx1167_debug, debug_1031
    rx1167_cur."!cursor_debug"("NEXT", "number")
  debug_1031:
  rx1167_fail:
    (rx1167_rep, rx1167_pos, $I10, $P10) = rx1167_cur."!mark_fail"(0)
    lt rx1167_pos, -1, rx1167_done
    eq rx1167_pos, -1, rx1167_fail
    jump $I10
  rx1167_done:
    rx1167_cur."!cursor_fail"()
    if_null rx1167_debug, debug_1032
    rx1167_cur."!cursor_debug"("FAIL", "number")
  debug_1032:
    .return (rx1167_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__number"  :nsentry("!PREFIX__number") :subid("234_1300062003.824") :method
.annotate 'line', 10
    new $P1169, "ResizablePMCArray"
    push $P1169, ""
    .return ($P1169)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote"  :subid("235_1300062003.824")
    .param pmc param_1175
.annotate 'line', 548
    .lex "self", param_1175
    $P1176 = param_1175."!protoregex"("quote")
    .return ($P1176)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote"  :subid("236_1300062003.824")
    .param pmc param_1178
.annotate 'line', 548
    .lex "self", param_1178
    $P1179 = param_1178."!PREFIX__!protoregex"("quote")
    .return ($P1179)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<apos>"  :subid("237_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1181_tgt
    .local int rx1181_pos
    .local int rx1181_off
    .local int rx1181_eos
    .local int rx1181_rep
    .local pmc rx1181_cur
    .local pmc rx1181_debug
    (rx1181_cur, rx1181_pos, rx1181_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1181_cur
    .local pmc match
    .lex "$/", match
    length rx1181_eos, rx1181_tgt
    gt rx1181_pos, rx1181_eos, rx1181_done
    set rx1181_off, 0
    lt rx1181_pos, 2, rx1181_start
    sub rx1181_off, rx1181_pos, 1
    substr rx1181_tgt, rx1181_tgt, rx1181_off
  rx1181_start:
    eq $I10, 1, rx1181_restart
    if_null rx1181_debug, debug_1033
    rx1181_cur."!cursor_debug"("START", "quote:sym<apos>")
  debug_1033:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1184_done
    goto rxscan1184_scan
  rxscan1184_loop:
    (rx1181_pos) = rx1181_cur."from"()
    inc rx1181_pos
    rx1181_cur."!cursor_from"(rx1181_pos)
    ge rx1181_pos, rx1181_eos, rxscan1184_done
  rxscan1184_scan:
    set_addr $I10, rxscan1184_loop
    rx1181_cur."!mark_push"(0, rx1181_pos, $I10)
  rxscan1184_done:
.annotate 'line', 549
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1181_pos, rx1181_off
    substr $S10, rx1181_tgt, $I10, 1
    index $I11, "'", $S10
    lt $I11, 0, rx1181_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1181_cur."!cursor_pos"(rx1181_pos)
    $P10 = rx1181_cur."quote_EXPR"(":q")
    unless $P10, rx1181_fail
    rx1181_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1181_pos = $P10."pos"()
  # rx pass
    rx1181_cur."!cursor_pass"(rx1181_pos, "quote:sym<apos>")
    if_null rx1181_debug, debug_1034
    rx1181_cur."!cursor_debug"("PASS", "quote:sym<apos>", " at pos=", rx1181_pos)
  debug_1034:
    .return (rx1181_cur)
  rx1181_restart:
.annotate 'line', 10
    if_null rx1181_debug, debug_1035
    rx1181_cur."!cursor_debug"("NEXT", "quote:sym<apos>")
  debug_1035:
  rx1181_fail:
    (rx1181_rep, rx1181_pos, $I10, $P10) = rx1181_cur."!mark_fail"(0)
    lt rx1181_pos, -1, rx1181_done
    eq rx1181_pos, -1, rx1181_fail
    jump $I10
  rx1181_done:
    rx1181_cur."!cursor_fail"()
    if_null rx1181_debug, debug_1036
    rx1181_cur."!cursor_debug"("FAIL", "quote:sym<apos>")
  debug_1036:
    .return (rx1181_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<apos>"  :nsentry("!PREFIX__quote:sym<apos>") :subid("238_1300062003.824") :method
.annotate 'line', 10
    new $P1183, "ResizablePMCArray"
    push $P1183, "'"
    .return ($P1183)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<dblq>"  :subid("239_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1186_tgt
    .local int rx1186_pos
    .local int rx1186_off
    .local int rx1186_eos
    .local int rx1186_rep
    .local pmc rx1186_cur
    .local pmc rx1186_debug
    (rx1186_cur, rx1186_pos, rx1186_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1186_cur
    .local pmc match
    .lex "$/", match
    length rx1186_eos, rx1186_tgt
    gt rx1186_pos, rx1186_eos, rx1186_done
    set rx1186_off, 0
    lt rx1186_pos, 2, rx1186_start
    sub rx1186_off, rx1186_pos, 1
    substr rx1186_tgt, rx1186_tgt, rx1186_off
  rx1186_start:
    eq $I10, 1, rx1186_restart
    if_null rx1186_debug, debug_1037
    rx1186_cur."!cursor_debug"("START", "quote:sym<dblq>")
  debug_1037:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1189_done
    goto rxscan1189_scan
  rxscan1189_loop:
    (rx1186_pos) = rx1186_cur."from"()
    inc rx1186_pos
    rx1186_cur."!cursor_from"(rx1186_pos)
    ge rx1186_pos, rx1186_eos, rxscan1189_done
  rxscan1189_scan:
    set_addr $I10, rxscan1189_loop
    rx1186_cur."!mark_push"(0, rx1186_pos, $I10)
  rxscan1189_done:
.annotate 'line', 550
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1186_pos, rx1186_off
    substr $S10, rx1186_tgt, $I10, 1
    index $I11, "\"", $S10
    lt $I11, 0, rx1186_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1186_cur."!cursor_pos"(rx1186_pos)
    $P10 = rx1186_cur."quote_EXPR"(":qq")
    unless $P10, rx1186_fail
    rx1186_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1186_pos = $P10."pos"()
  # rx pass
    rx1186_cur."!cursor_pass"(rx1186_pos, "quote:sym<dblq>")
    if_null rx1186_debug, debug_1038
    rx1186_cur."!cursor_debug"("PASS", "quote:sym<dblq>", " at pos=", rx1186_pos)
  debug_1038:
    .return (rx1186_cur)
  rx1186_restart:
.annotate 'line', 10
    if_null rx1186_debug, debug_1039
    rx1186_cur."!cursor_debug"("NEXT", "quote:sym<dblq>")
  debug_1039:
  rx1186_fail:
    (rx1186_rep, rx1186_pos, $I10, $P10) = rx1186_cur."!mark_fail"(0)
    lt rx1186_pos, -1, rx1186_done
    eq rx1186_pos, -1, rx1186_fail
    jump $I10
  rx1186_done:
    rx1186_cur."!cursor_fail"()
    if_null rx1186_debug, debug_1040
    rx1186_cur."!cursor_debug"("FAIL", "quote:sym<dblq>")
  debug_1040:
    .return (rx1186_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<dblq>"  :nsentry("!PREFIX__quote:sym<dblq>") :subid("240_1300062003.824") :method
.annotate 'line', 10
    new $P1188, "ResizablePMCArray"
    push $P1188, "\""
    .return ($P1188)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<q>"  :subid("241_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1191_tgt
    .local int rx1191_pos
    .local int rx1191_off
    .local int rx1191_eos
    .local int rx1191_rep
    .local pmc rx1191_cur
    .local pmc rx1191_debug
    (rx1191_cur, rx1191_pos, rx1191_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1191_cur
    .local pmc match
    .lex "$/", match
    length rx1191_eos, rx1191_tgt
    gt rx1191_pos, rx1191_eos, rx1191_done
    set rx1191_off, 0
    lt rx1191_pos, 2, rx1191_start
    sub rx1191_off, rx1191_pos, 1
    substr rx1191_tgt, rx1191_tgt, rx1191_off
  rx1191_start:
    eq $I10, 1, rx1191_restart
    if_null rx1191_debug, debug_1041
    rx1191_cur."!cursor_debug"("START", "quote:sym<q>")
  debug_1041:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1195_done
    goto rxscan1195_scan
  rxscan1195_loop:
    (rx1191_pos) = rx1191_cur."from"()
    inc rx1191_pos
    rx1191_cur."!cursor_from"(rx1191_pos)
    ge rx1191_pos, rx1191_eos, rxscan1195_done
  rxscan1195_scan:
    set_addr $I10, rxscan1195_loop
    rx1191_cur."!mark_push"(0, rx1191_pos, $I10)
  rxscan1195_done:
.annotate 'line', 551
  # rx literal  "q"
    add $I11, rx1191_pos, 1
    gt $I11, rx1191_eos, rx1191_fail
    sub $I11, rx1191_pos, rx1191_off
    ord $I11, rx1191_tgt, $I11
    ne $I11, 113, rx1191_fail
    add rx1191_pos, 1
  # rxanchor rwb
    le rx1191_pos, 0, rx1191_fail
    sub $I10, rx1191_pos, rx1191_off
    is_cclass $I11, 8192, rx1191_tgt, $I10
    if $I11, rx1191_fail
    dec $I10
    is_cclass $I11, 8192, rx1191_tgt, $I10
    unless $I11, rx1191_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1191_pos, rx1191_off
    substr $S10, rx1191_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1191_fail
  # rx subrule "ws" subtype=method negate=
    rx1191_cur."!cursor_pos"(rx1191_pos)
    $P10 = rx1191_cur."ws"()
    unless $P10, rx1191_fail
    rx1191_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1191_cur."!cursor_pos"(rx1191_pos)
    $P10 = rx1191_cur."quote_EXPR"(":q")
    unless $P10, rx1191_fail
    rx1191_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1191_pos = $P10."pos"()
  # rx pass
    rx1191_cur."!cursor_pass"(rx1191_pos, "quote:sym<q>")
    if_null rx1191_debug, debug_1042
    rx1191_cur."!cursor_debug"("PASS", "quote:sym<q>", " at pos=", rx1191_pos)
  debug_1042:
    .return (rx1191_cur)
  rx1191_restart:
.annotate 'line', 10
    if_null rx1191_debug, debug_1043
    rx1191_cur."!cursor_debug"("NEXT", "quote:sym<q>")
  debug_1043:
  rx1191_fail:
    (rx1191_rep, rx1191_pos, $I10, $P10) = rx1191_cur."!mark_fail"(0)
    lt rx1191_pos, -1, rx1191_done
    eq rx1191_pos, -1, rx1191_fail
    jump $I10
  rx1191_done:
    rx1191_cur."!cursor_fail"()
    if_null rx1191_debug, debug_1044
    rx1191_cur."!cursor_debug"("FAIL", "quote:sym<q>")
  debug_1044:
    .return (rx1191_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<q>"  :nsentry("!PREFIX__quote:sym<q>") :subid("242_1300062003.824") :method
.annotate 'line', 10
    $P1193 = self."!PREFIX__!subrule"("ws", "q")
    new $P1194, "ResizablePMCArray"
    push $P1194, $P1193
    .return ($P1194)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<qq>"  :subid("243_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1197_tgt
    .local int rx1197_pos
    .local int rx1197_off
    .local int rx1197_eos
    .local int rx1197_rep
    .local pmc rx1197_cur
    .local pmc rx1197_debug
    (rx1197_cur, rx1197_pos, rx1197_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1197_cur
    .local pmc match
    .lex "$/", match
    length rx1197_eos, rx1197_tgt
    gt rx1197_pos, rx1197_eos, rx1197_done
    set rx1197_off, 0
    lt rx1197_pos, 2, rx1197_start
    sub rx1197_off, rx1197_pos, 1
    substr rx1197_tgt, rx1197_tgt, rx1197_off
  rx1197_start:
    eq $I10, 1, rx1197_restart
    if_null rx1197_debug, debug_1045
    rx1197_cur."!cursor_debug"("START", "quote:sym<qq>")
  debug_1045:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1201_done
    goto rxscan1201_scan
  rxscan1201_loop:
    (rx1197_pos) = rx1197_cur."from"()
    inc rx1197_pos
    rx1197_cur."!cursor_from"(rx1197_pos)
    ge rx1197_pos, rx1197_eos, rxscan1201_done
  rxscan1201_scan:
    set_addr $I10, rxscan1201_loop
    rx1197_cur."!mark_push"(0, rx1197_pos, $I10)
  rxscan1201_done:
.annotate 'line', 552
  # rx literal  "qq"
    add $I11, rx1197_pos, 2
    gt $I11, rx1197_eos, rx1197_fail
    sub $I11, rx1197_pos, rx1197_off
    substr $S10, rx1197_tgt, $I11, 2
    ne $S10, "qq", rx1197_fail
    add rx1197_pos, 2
  # rxanchor rwb
    le rx1197_pos, 0, rx1197_fail
    sub $I10, rx1197_pos, rx1197_off
    is_cclass $I11, 8192, rx1197_tgt, $I10
    if $I11, rx1197_fail
    dec $I10
    is_cclass $I11, 8192, rx1197_tgt, $I10
    unless $I11, rx1197_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1197_pos, rx1197_off
    substr $S10, rx1197_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1197_fail
  # rx subrule "ws" subtype=method negate=
    rx1197_cur."!cursor_pos"(rx1197_pos)
    $P10 = rx1197_cur."ws"()
    unless $P10, rx1197_fail
    rx1197_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1197_cur."!cursor_pos"(rx1197_pos)
    $P10 = rx1197_cur."quote_EXPR"(":qq")
    unless $P10, rx1197_fail
    rx1197_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1197_pos = $P10."pos"()
  # rx pass
    rx1197_cur."!cursor_pass"(rx1197_pos, "quote:sym<qq>")
    if_null rx1197_debug, debug_1046
    rx1197_cur."!cursor_debug"("PASS", "quote:sym<qq>", " at pos=", rx1197_pos)
  debug_1046:
    .return (rx1197_cur)
  rx1197_restart:
.annotate 'line', 10
    if_null rx1197_debug, debug_1047
    rx1197_cur."!cursor_debug"("NEXT", "quote:sym<qq>")
  debug_1047:
  rx1197_fail:
    (rx1197_rep, rx1197_pos, $I10, $P10) = rx1197_cur."!mark_fail"(0)
    lt rx1197_pos, -1, rx1197_done
    eq rx1197_pos, -1, rx1197_fail
    jump $I10
  rx1197_done:
    rx1197_cur."!cursor_fail"()
    if_null rx1197_debug, debug_1048
    rx1197_cur."!cursor_debug"("FAIL", "quote:sym<qq>")
  debug_1048:
    .return (rx1197_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<qq>"  :nsentry("!PREFIX__quote:sym<qq>") :subid("244_1300062003.824") :method
.annotate 'line', 10
    $P1199 = self."!PREFIX__!subrule"("ws", "qq")
    new $P1200, "ResizablePMCArray"
    push $P1200, $P1199
    .return ($P1200)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q>"  :subid("245_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1203_tgt
    .local int rx1203_pos
    .local int rx1203_off
    .local int rx1203_eos
    .local int rx1203_rep
    .local pmc rx1203_cur
    .local pmc rx1203_debug
    (rx1203_cur, rx1203_pos, rx1203_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1203_cur
    .local pmc match
    .lex "$/", match
    length rx1203_eos, rx1203_tgt
    gt rx1203_pos, rx1203_eos, rx1203_done
    set rx1203_off, 0
    lt rx1203_pos, 2, rx1203_start
    sub rx1203_off, rx1203_pos, 1
    substr rx1203_tgt, rx1203_tgt, rx1203_off
  rx1203_start:
    eq $I10, 1, rx1203_restart
    if_null rx1203_debug, debug_1049
    rx1203_cur."!cursor_debug"("START", "quote:sym<Q>")
  debug_1049:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1207_done
    goto rxscan1207_scan
  rxscan1207_loop:
    (rx1203_pos) = rx1203_cur."from"()
    inc rx1203_pos
    rx1203_cur."!cursor_from"(rx1203_pos)
    ge rx1203_pos, rx1203_eos, rxscan1207_done
  rxscan1207_scan:
    set_addr $I10, rxscan1207_loop
    rx1203_cur."!mark_push"(0, rx1203_pos, $I10)
  rxscan1207_done:
.annotate 'line', 553
  # rx literal  "Q"
    add $I11, rx1203_pos, 1
    gt $I11, rx1203_eos, rx1203_fail
    sub $I11, rx1203_pos, rx1203_off
    ord $I11, rx1203_tgt, $I11
    ne $I11, 81, rx1203_fail
    add rx1203_pos, 1
  # rxanchor rwb
    le rx1203_pos, 0, rx1203_fail
    sub $I10, rx1203_pos, rx1203_off
    is_cclass $I11, 8192, rx1203_tgt, $I10
    if $I11, rx1203_fail
    dec $I10
    is_cclass $I11, 8192, rx1203_tgt, $I10
    unless $I11, rx1203_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1203_pos, rx1203_off
    substr $S10, rx1203_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1203_fail
  # rx subrule "ws" subtype=method negate=
    rx1203_cur."!cursor_pos"(rx1203_pos)
    $P10 = rx1203_cur."ws"()
    unless $P10, rx1203_fail
    rx1203_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1203_cur."!cursor_pos"(rx1203_pos)
    $P10 = rx1203_cur."quote_EXPR"()
    unless $P10, rx1203_fail
    rx1203_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1203_pos = $P10."pos"()
  # rx pass
    rx1203_cur."!cursor_pass"(rx1203_pos, "quote:sym<Q>")
    if_null rx1203_debug, debug_1050
    rx1203_cur."!cursor_debug"("PASS", "quote:sym<Q>", " at pos=", rx1203_pos)
  debug_1050:
    .return (rx1203_cur)
  rx1203_restart:
.annotate 'line', 10
    if_null rx1203_debug, debug_1051
    rx1203_cur."!cursor_debug"("NEXT", "quote:sym<Q>")
  debug_1051:
  rx1203_fail:
    (rx1203_rep, rx1203_pos, $I10, $P10) = rx1203_cur."!mark_fail"(0)
    lt rx1203_pos, -1, rx1203_done
    eq rx1203_pos, -1, rx1203_fail
    jump $I10
  rx1203_done:
    rx1203_cur."!cursor_fail"()
    if_null rx1203_debug, debug_1052
    rx1203_cur."!cursor_debug"("FAIL", "quote:sym<Q>")
  debug_1052:
    .return (rx1203_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q>"  :nsentry("!PREFIX__quote:sym<Q>") :subid("246_1300062003.824") :method
.annotate 'line', 10
    $P1205 = self."!PREFIX__!subrule"("ws", "Q")
    new $P1206, "ResizablePMCArray"
    push $P1206, $P1205
    .return ($P1206)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q:PIR>"  :subid("247_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1209_tgt
    .local int rx1209_pos
    .local int rx1209_off
    .local int rx1209_eos
    .local int rx1209_rep
    .local pmc rx1209_cur
    .local pmc rx1209_debug
    (rx1209_cur, rx1209_pos, rx1209_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1209_cur
    .local pmc match
    .lex "$/", match
    length rx1209_eos, rx1209_tgt
    gt rx1209_pos, rx1209_eos, rx1209_done
    set rx1209_off, 0
    lt rx1209_pos, 2, rx1209_start
    sub rx1209_off, rx1209_pos, 1
    substr rx1209_tgt, rx1209_tgt, rx1209_off
  rx1209_start:
    eq $I10, 1, rx1209_restart
    if_null rx1209_debug, debug_1053
    rx1209_cur."!cursor_debug"("START", "quote:sym<Q:PIR>")
  debug_1053:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1213_done
    goto rxscan1213_scan
  rxscan1213_loop:
    (rx1209_pos) = rx1209_cur."from"()
    inc rx1209_pos
    rx1209_cur."!cursor_from"(rx1209_pos)
    ge rx1209_pos, rx1209_eos, rxscan1213_done
  rxscan1213_scan:
    set_addr $I10, rxscan1213_loop
    rx1209_cur."!mark_push"(0, rx1209_pos, $I10)
  rxscan1213_done:
.annotate 'line', 554
  # rx literal  "Q:PIR"
    add $I11, rx1209_pos, 5
    gt $I11, rx1209_eos, rx1209_fail
    sub $I11, rx1209_pos, rx1209_off
    substr $S10, rx1209_tgt, $I11, 5
    ne $S10, "Q:PIR", rx1209_fail
    add rx1209_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx1209_cur."!cursor_pos"(rx1209_pos)
    $P10 = rx1209_cur."ws"()
    unless $P10, rx1209_fail
    rx1209_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1209_cur."!cursor_pos"(rx1209_pos)
    $P10 = rx1209_cur."quote_EXPR"()
    unless $P10, rx1209_fail
    rx1209_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1209_pos = $P10."pos"()
  # rx pass
    rx1209_cur."!cursor_pass"(rx1209_pos, "quote:sym<Q:PIR>")
    if_null rx1209_debug, debug_1054
    rx1209_cur."!cursor_debug"("PASS", "quote:sym<Q:PIR>", " at pos=", rx1209_pos)
  debug_1054:
    .return (rx1209_cur)
  rx1209_restart:
.annotate 'line', 10
    if_null rx1209_debug, debug_1055
    rx1209_cur."!cursor_debug"("NEXT", "quote:sym<Q:PIR>")
  debug_1055:
  rx1209_fail:
    (rx1209_rep, rx1209_pos, $I10, $P10) = rx1209_cur."!mark_fail"(0)
    lt rx1209_pos, -1, rx1209_done
    eq rx1209_pos, -1, rx1209_fail
    jump $I10
  rx1209_done:
    rx1209_cur."!cursor_fail"()
    if_null rx1209_debug, debug_1056
    rx1209_cur."!cursor_debug"("FAIL", "quote:sym<Q:PIR>")
  debug_1056:
    .return (rx1209_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q:PIR>"  :nsentry("!PREFIX__quote:sym<Q:PIR>") :subid("248_1300062003.824") :method
.annotate 'line', 10
    $P1211 = self."!PREFIX__!subrule"("ws", "Q:PIR")
    new $P1212, "ResizablePMCArray"
    push $P1212, $P1211
    .return ($P1212)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym</ />"  :subid("249_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1215_tgt
    .local int rx1215_pos
    .local int rx1215_off
    .local int rx1215_eos
    .local int rx1215_rep
    .local pmc rx1215_cur
    .local pmc rx1215_debug
    (rx1215_cur, rx1215_pos, rx1215_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1215_cur
    .local pmc match
    .lex "$/", match
    length rx1215_eos, rx1215_tgt
    gt rx1215_pos, rx1215_eos, rx1215_done
    set rx1215_off, 0
    lt rx1215_pos, 2, rx1215_start
    sub rx1215_off, rx1215_pos, 1
    substr rx1215_tgt, rx1215_tgt, rx1215_off
  rx1215_start:
    eq $I10, 1, rx1215_restart
    if_null rx1215_debug, debug_1057
    rx1215_cur."!cursor_debug"("START", "quote:sym</ />")
  debug_1057:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1219_done
    goto rxscan1219_scan
  rxscan1219_loop:
    (rx1215_pos) = rx1215_cur."from"()
    inc rx1215_pos
    rx1215_cur."!cursor_from"(rx1215_pos)
    ge rx1215_pos, rx1215_eos, rxscan1219_done
  rxscan1219_scan:
    set_addr $I10, rxscan1219_loop
    rx1215_cur."!mark_push"(0, rx1215_pos, $I10)
  rxscan1219_done:
.annotate 'line', 556
  # rx literal  "/"
    add $I11, rx1215_pos, 1
    gt $I11, rx1215_eos, rx1215_fail
    sub $I11, rx1215_pos, rx1215_off
    ord $I11, rx1215_tgt, $I11
    ne $I11, 47, rx1215_fail
    add rx1215_pos, 1
.annotate 'line', 557
  # rx subrule "newpad" subtype=method negate=
    rx1215_cur."!cursor_pos"(rx1215_pos)
    $P10 = rx1215_cur."newpad"()
    unless $P10, rx1215_fail
    rx1215_pos = $P10."pos"()
.annotate 'line', 558
  # rx reduce name="quote:sym</ />" key="open"
    rx1215_cur."!cursor_pos"(rx1215_pos)
    rx1215_cur."!reduce"("quote:sym</ />", "open")
.annotate 'line', 559
  # rx subrule "LANG" subtype=capture negate=
    rx1215_cur."!cursor_pos"(rx1215_pos)
    $P10 = rx1215_cur."LANG"("Regex", "nibbler")
    unless $P10, rx1215_fail
    rx1215_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx1215_pos = $P10."pos"()
.annotate 'line', 560
  # rx literal  "/"
    add $I11, rx1215_pos, 1
    gt $I11, rx1215_eos, rx1215_fail
    sub $I11, rx1215_pos, rx1215_off
    ord $I11, rx1215_tgt, $I11
    ne $I11, 47, rx1215_fail
    add rx1215_pos, 1
.annotate 'line', 555
  # rx pass
    rx1215_cur."!cursor_pass"(rx1215_pos, "quote:sym</ />")
    if_null rx1215_debug, debug_1058
    rx1215_cur."!cursor_debug"("PASS", "quote:sym</ />", " at pos=", rx1215_pos)
  debug_1058:
    .return (rx1215_cur)
  rx1215_restart:
.annotate 'line', 10
    if_null rx1215_debug, debug_1059
    rx1215_cur."!cursor_debug"("NEXT", "quote:sym</ />")
  debug_1059:
  rx1215_fail:
    (rx1215_rep, rx1215_pos, $I10, $P10) = rx1215_cur."!mark_fail"(0)
    lt rx1215_pos, -1, rx1215_done
    eq rx1215_pos, -1, rx1215_fail
    jump $I10
  rx1215_done:
    rx1215_cur."!cursor_fail"()
    if_null rx1215_debug, debug_1060
    rx1215_cur."!cursor_debug"("FAIL", "quote:sym</ />")
  debug_1060:
    .return (rx1215_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym</ />"  :nsentry("!PREFIX__quote:sym</ />") :subid("250_1300062003.824") :method
.annotate 'line', 10
    $P1217 = self."!PREFIX__!subrule"("newpad", "/")
    new $P1218, "ResizablePMCArray"
    push $P1218, $P1217
    .return ($P1218)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<$>"  :subid("251_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1221_tgt
    .local int rx1221_pos
    .local int rx1221_off
    .local int rx1221_eos
    .local int rx1221_rep
    .local pmc rx1221_cur
    .local pmc rx1221_debug
    (rx1221_cur, rx1221_pos, rx1221_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1221_cur
    .local pmc match
    .lex "$/", match
    length rx1221_eos, rx1221_tgt
    gt rx1221_pos, rx1221_eos, rx1221_done
    set rx1221_off, 0
    lt rx1221_pos, 2, rx1221_start
    sub rx1221_off, rx1221_pos, 1
    substr rx1221_tgt, rx1221_tgt, rx1221_off
  rx1221_start:
    eq $I10, 1, rx1221_restart
    if_null rx1221_debug, debug_1061
    rx1221_cur."!cursor_debug"("START", "quote_escape:sym<$>")
  debug_1061:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1224_done
    goto rxscan1224_scan
  rxscan1224_loop:
    (rx1221_pos) = rx1221_cur."from"()
    inc rx1221_pos
    rx1221_cur."!cursor_from"(rx1221_pos)
    ge rx1221_pos, rx1221_eos, rxscan1224_done
  rxscan1224_scan:
    set_addr $I10, rxscan1224_loop
    rx1221_cur."!mark_push"(0, rx1221_pos, $I10)
  rxscan1224_done:
.annotate 'line', 563
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1221_pos, rx1221_off
    substr $S10, rx1221_tgt, $I10, 1
    index $I11, "$", $S10
    lt $I11, 0, rx1221_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1221_cur."!cursor_pos"(rx1221_pos)
    $P10 = rx1221_cur."quotemod_check"("s")
    unless $P10, rx1221_fail
  # rx subrule "variable" subtype=capture negate=
    rx1221_cur."!cursor_pos"(rx1221_pos)
    $P10 = rx1221_cur."variable"()
    unless $P10, rx1221_fail
    rx1221_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx1221_pos = $P10."pos"()
  # rx pass
    rx1221_cur."!cursor_pass"(rx1221_pos, "quote_escape:sym<$>")
    if_null rx1221_debug, debug_1062
    rx1221_cur."!cursor_debug"("PASS", "quote_escape:sym<$>", " at pos=", rx1221_pos)
  debug_1062:
    .return (rx1221_cur)
  rx1221_restart:
.annotate 'line', 10
    if_null rx1221_debug, debug_1063
    rx1221_cur."!cursor_debug"("NEXT", "quote_escape:sym<$>")
  debug_1063:
  rx1221_fail:
    (rx1221_rep, rx1221_pos, $I10, $P10) = rx1221_cur."!mark_fail"(0)
    lt rx1221_pos, -1, rx1221_done
    eq rx1221_pos, -1, rx1221_fail
    jump $I10
  rx1221_done:
    rx1221_cur."!cursor_fail"()
    if_null rx1221_debug, debug_1064
    rx1221_cur."!cursor_debug"("FAIL", "quote_escape:sym<$>")
  debug_1064:
    .return (rx1221_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<$>"  :nsentry("!PREFIX__quote_escape:sym<$>") :subid("252_1300062003.824") :method
.annotate 'line', 10
    new $P1223, "ResizablePMCArray"
    push $P1223, "$"
    .return ($P1223)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<{ }>"  :subid("253_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1226_tgt
    .local int rx1226_pos
    .local int rx1226_off
    .local int rx1226_eos
    .local int rx1226_rep
    .local pmc rx1226_cur
    .local pmc rx1226_debug
    (rx1226_cur, rx1226_pos, rx1226_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1226_cur
    .local pmc match
    .lex "$/", match
    length rx1226_eos, rx1226_tgt
    gt rx1226_pos, rx1226_eos, rx1226_done
    set rx1226_off, 0
    lt rx1226_pos, 2, rx1226_start
    sub rx1226_off, rx1226_pos, 1
    substr rx1226_tgt, rx1226_tgt, rx1226_off
  rx1226_start:
    eq $I10, 1, rx1226_restart
    if_null rx1226_debug, debug_1065
    rx1226_cur."!cursor_debug"("START", "quote_escape:sym<{ }>")
  debug_1065:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1229_done
    goto rxscan1229_scan
  rxscan1229_loop:
    (rx1226_pos) = rx1226_cur."from"()
    inc rx1226_pos
    rx1226_cur."!cursor_from"(rx1226_pos)
    ge rx1226_pos, rx1226_eos, rxscan1229_done
  rxscan1229_scan:
    set_addr $I10, rxscan1229_loop
    rx1226_cur."!mark_push"(0, rx1226_pos, $I10)
  rxscan1229_done:
.annotate 'line', 564
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1226_pos, rx1226_off
    substr $S10, rx1226_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1226_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1226_cur."!cursor_pos"(rx1226_pos)
    $P10 = rx1226_cur."quotemod_check"("c")
    unless $P10, rx1226_fail
  # rx subrule "block" subtype=capture negate=
    rx1226_cur."!cursor_pos"(rx1226_pos)
    $P10 = rx1226_cur."block"()
    unless $P10, rx1226_fail
    rx1226_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1226_pos = $P10."pos"()
  # rx pass
    rx1226_cur."!cursor_pass"(rx1226_pos, "quote_escape:sym<{ }>")
    if_null rx1226_debug, debug_1066
    rx1226_cur."!cursor_debug"("PASS", "quote_escape:sym<{ }>", " at pos=", rx1226_pos)
  debug_1066:
    .return (rx1226_cur)
  rx1226_restart:
.annotate 'line', 10
    if_null rx1226_debug, debug_1067
    rx1226_cur."!cursor_debug"("NEXT", "quote_escape:sym<{ }>")
  debug_1067:
  rx1226_fail:
    (rx1226_rep, rx1226_pos, $I10, $P10) = rx1226_cur."!mark_fail"(0)
    lt rx1226_pos, -1, rx1226_done
    eq rx1226_pos, -1, rx1226_fail
    jump $I10
  rx1226_done:
    rx1226_cur."!cursor_fail"()
    if_null rx1226_debug, debug_1068
    rx1226_cur."!cursor_debug"("FAIL", "quote_escape:sym<{ }>")
  debug_1068:
    .return (rx1226_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<{ }>"  :nsentry("!PREFIX__quote_escape:sym<{ }>") :subid("254_1300062003.824") :method
.annotate 'line', 10
    new $P1228, "ResizablePMCArray"
    push $P1228, "{"
    .return ($P1228)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<esc>"  :subid("255_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1231_tgt
    .local int rx1231_pos
    .local int rx1231_off
    .local int rx1231_eos
    .local int rx1231_rep
    .local pmc rx1231_cur
    .local pmc rx1231_debug
    (rx1231_cur, rx1231_pos, rx1231_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1231_cur
    .local pmc match
    .lex "$/", match
    length rx1231_eos, rx1231_tgt
    gt rx1231_pos, rx1231_eos, rx1231_done
    set rx1231_off, 0
    lt rx1231_pos, 2, rx1231_start
    sub rx1231_off, rx1231_pos, 1
    substr rx1231_tgt, rx1231_tgt, rx1231_off
  rx1231_start:
    eq $I10, 1, rx1231_restart
    if_null rx1231_debug, debug_1069
    rx1231_cur."!cursor_debug"("START", "quote_escape:sym<esc>")
  debug_1069:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1234_done
    goto rxscan1234_scan
  rxscan1234_loop:
    (rx1231_pos) = rx1231_cur."from"()
    inc rx1231_pos
    rx1231_cur."!cursor_from"(rx1231_pos)
    ge rx1231_pos, rx1231_eos, rxscan1234_done
  rxscan1234_scan:
    set_addr $I10, rxscan1234_loop
    rx1231_cur."!mark_push"(0, rx1231_pos, $I10)
  rxscan1234_done:
.annotate 'line', 565
  # rx literal  "\\e"
    add $I11, rx1231_pos, 2
    gt $I11, rx1231_eos, rx1231_fail
    sub $I11, rx1231_pos, rx1231_off
    substr $S10, rx1231_tgt, $I11, 2
    ne $S10, "\\e", rx1231_fail
    add rx1231_pos, 2
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1231_cur."!cursor_pos"(rx1231_pos)
    $P10 = rx1231_cur."quotemod_check"("b")
    unless $P10, rx1231_fail
  # rx pass
    rx1231_cur."!cursor_pass"(rx1231_pos, "quote_escape:sym<esc>")
    if_null rx1231_debug, debug_1070
    rx1231_cur."!cursor_debug"("PASS", "quote_escape:sym<esc>", " at pos=", rx1231_pos)
  debug_1070:
    .return (rx1231_cur)
  rx1231_restart:
.annotate 'line', 10
    if_null rx1231_debug, debug_1071
    rx1231_cur."!cursor_debug"("NEXT", "quote_escape:sym<esc>")
  debug_1071:
  rx1231_fail:
    (rx1231_rep, rx1231_pos, $I10, $P10) = rx1231_cur."!mark_fail"(0)
    lt rx1231_pos, -1, rx1231_done
    eq rx1231_pos, -1, rx1231_fail
    jump $I10
  rx1231_done:
    rx1231_cur."!cursor_fail"()
    if_null rx1231_debug, debug_1072
    rx1231_cur."!cursor_debug"("FAIL", "quote_escape:sym<esc>")
  debug_1072:
    .return (rx1231_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<esc>"  :nsentry("!PREFIX__quote_escape:sym<esc>") :subid("256_1300062003.824") :method
.annotate 'line', 10
    new $P1233, "ResizablePMCArray"
    push $P1233, "\\e"
    .return ($P1233)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<( )>"  :subid("257_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1236_tgt
    .local int rx1236_pos
    .local int rx1236_off
    .local int rx1236_eos
    .local int rx1236_rep
    .local pmc rx1236_cur
    .local pmc rx1236_debug
    (rx1236_cur, rx1236_pos, rx1236_tgt, $I10) = self."!cursor_start"()
    rx1236_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx1236_cur
    .local pmc match
    .lex "$/", match
    length rx1236_eos, rx1236_tgt
    gt rx1236_pos, rx1236_eos, rx1236_done
    set rx1236_off, 0
    lt rx1236_pos, 2, rx1236_start
    sub rx1236_off, rx1236_pos, 1
    substr rx1236_tgt, rx1236_tgt, rx1236_off
  rx1236_start:
    eq $I10, 1, rx1236_restart
    if_null rx1236_debug, debug_1073
    rx1236_cur."!cursor_debug"("START", "circumfix:sym<( )>")
  debug_1073:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1240_done
    goto rxscan1240_scan
  rxscan1240_loop:
    (rx1236_pos) = rx1236_cur."from"()
    inc rx1236_pos
    rx1236_cur."!cursor_from"(rx1236_pos)
    ge rx1236_pos, rx1236_eos, rxscan1240_done
  rxscan1240_scan:
    set_addr $I10, rxscan1240_loop
    rx1236_cur."!mark_push"(0, rx1236_pos, $I10)
  rxscan1240_done:
.annotate 'line', 567
  # rx literal  "("
    add $I11, rx1236_pos, 1
    gt $I11, rx1236_eos, rx1236_fail
    sub $I11, rx1236_pos, rx1236_off
    ord $I11, rx1236_tgt, $I11
    ne $I11, 40, rx1236_fail
    add rx1236_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1236_cur."!cursor_pos"(rx1236_pos)
    $P10 = rx1236_cur."ws"()
    unless $P10, rx1236_fail
    rx1236_pos = $P10."pos"()
  # rx rxquantr1241 ** 0..1
    set_addr $I10, rxquantr1241_done
    rx1236_cur."!mark_push"(0, rx1236_pos, $I10)
  rxquantr1241_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx1236_cur."!cursor_pos"(rx1236_pos)
    $P10 = rx1236_cur."EXPR"()
    unless $P10, rx1236_fail
    goto rxsubrule1242_pass
  rxsubrule1242_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1236_fail
  rxsubrule1242_pass:
    set_addr $I10, rxsubrule1242_back
    rx1236_cur."!mark_push"(0, rx1236_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx1236_pos = $P10."pos"()
    set_addr $I10, rxquantr1241_done
    (rx1236_rep) = rx1236_cur."!mark_commit"($I10)
  rxquantr1241_done:
  # rx literal  ")"
    add $I11, rx1236_pos, 1
    gt $I11, rx1236_eos, rx1236_fail
    sub $I11, rx1236_pos, rx1236_off
    ord $I11, rx1236_tgt, $I11
    ne $I11, 41, rx1236_fail
    add rx1236_pos, 1
  # rx pass
    rx1236_cur."!cursor_pass"(rx1236_pos, "circumfix:sym<( )>")
    if_null rx1236_debug, debug_1074
    rx1236_cur."!cursor_debug"("PASS", "circumfix:sym<( )>", " at pos=", rx1236_pos)
  debug_1074:
    .return (rx1236_cur)
  rx1236_restart:
.annotate 'line', 10
    if_null rx1236_debug, debug_1075
    rx1236_cur."!cursor_debug"("NEXT", "circumfix:sym<( )>")
  debug_1075:
  rx1236_fail:
    (rx1236_rep, rx1236_pos, $I10, $P10) = rx1236_cur."!mark_fail"(0)
    lt rx1236_pos, -1, rx1236_done
    eq rx1236_pos, -1, rx1236_fail
    jump $I10
  rx1236_done:
    rx1236_cur."!cursor_fail"()
    if_null rx1236_debug, debug_1076
    rx1236_cur."!cursor_debug"("FAIL", "circumfix:sym<( )>")
  debug_1076:
    .return (rx1236_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<( )>"  :nsentry("!PREFIX__circumfix:sym<( )>") :subid("258_1300062003.824") :method
.annotate 'line', 10
    $P1238 = self."!PREFIX__!subrule"("ws", "(")
    new $P1239, "ResizablePMCArray"
    push $P1239, $P1238
    .return ($P1239)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<[ ]>"  :subid("259_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1244_tgt
    .local int rx1244_pos
    .local int rx1244_off
    .local int rx1244_eos
    .local int rx1244_rep
    .local pmc rx1244_cur
    .local pmc rx1244_debug
    (rx1244_cur, rx1244_pos, rx1244_tgt, $I10) = self."!cursor_start"()
    rx1244_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx1244_cur
    .local pmc match
    .lex "$/", match
    length rx1244_eos, rx1244_tgt
    gt rx1244_pos, rx1244_eos, rx1244_done
    set rx1244_off, 0
    lt rx1244_pos, 2, rx1244_start
    sub rx1244_off, rx1244_pos, 1
    substr rx1244_tgt, rx1244_tgt, rx1244_off
  rx1244_start:
    eq $I10, 1, rx1244_restart
    if_null rx1244_debug, debug_1077
    rx1244_cur."!cursor_debug"("START", "circumfix:sym<[ ]>")
  debug_1077:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1248_done
    goto rxscan1248_scan
  rxscan1248_loop:
    (rx1244_pos) = rx1244_cur."from"()
    inc rx1244_pos
    rx1244_cur."!cursor_from"(rx1244_pos)
    ge rx1244_pos, rx1244_eos, rxscan1248_done
  rxscan1248_scan:
    set_addr $I10, rxscan1248_loop
    rx1244_cur."!mark_push"(0, rx1244_pos, $I10)
  rxscan1248_done:
.annotate 'line', 568
  # rx literal  "["
    add $I11, rx1244_pos, 1
    gt $I11, rx1244_eos, rx1244_fail
    sub $I11, rx1244_pos, rx1244_off
    ord $I11, rx1244_tgt, $I11
    ne $I11, 91, rx1244_fail
    add rx1244_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1244_cur."!cursor_pos"(rx1244_pos)
    $P10 = rx1244_cur."ws"()
    unless $P10, rx1244_fail
    rx1244_pos = $P10."pos"()
  # rx rxquantr1249 ** 0..1
    set_addr $I10, rxquantr1249_done
    rx1244_cur."!mark_push"(0, rx1244_pos, $I10)
  rxquantr1249_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx1244_cur."!cursor_pos"(rx1244_pos)
    $P10 = rx1244_cur."EXPR"()
    unless $P10, rx1244_fail
    goto rxsubrule1250_pass
  rxsubrule1250_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1244_fail
  rxsubrule1250_pass:
    set_addr $I10, rxsubrule1250_back
    rx1244_cur."!mark_push"(0, rx1244_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx1244_pos = $P10."pos"()
    set_addr $I10, rxquantr1249_done
    (rx1244_rep) = rx1244_cur."!mark_commit"($I10)
  rxquantr1249_done:
  # rx literal  "]"
    add $I11, rx1244_pos, 1
    gt $I11, rx1244_eos, rx1244_fail
    sub $I11, rx1244_pos, rx1244_off
    ord $I11, rx1244_tgt, $I11
    ne $I11, 93, rx1244_fail
    add rx1244_pos, 1
  # rx pass
    rx1244_cur."!cursor_pass"(rx1244_pos, "circumfix:sym<[ ]>")
    if_null rx1244_debug, debug_1078
    rx1244_cur."!cursor_debug"("PASS", "circumfix:sym<[ ]>", " at pos=", rx1244_pos)
  debug_1078:
    .return (rx1244_cur)
  rx1244_restart:
.annotate 'line', 10
    if_null rx1244_debug, debug_1079
    rx1244_cur."!cursor_debug"("NEXT", "circumfix:sym<[ ]>")
  debug_1079:
  rx1244_fail:
    (rx1244_rep, rx1244_pos, $I10, $P10) = rx1244_cur."!mark_fail"(0)
    lt rx1244_pos, -1, rx1244_done
    eq rx1244_pos, -1, rx1244_fail
    jump $I10
  rx1244_done:
    rx1244_cur."!cursor_fail"()
    if_null rx1244_debug, debug_1080
    rx1244_cur."!cursor_debug"("FAIL", "circumfix:sym<[ ]>")
  debug_1080:
    .return (rx1244_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<[ ]>"  :nsentry("!PREFIX__circumfix:sym<[ ]>") :subid("260_1300062003.824") :method
.annotate 'line', 10
    $P1246 = self."!PREFIX__!subrule"("ws", "[")
    new $P1247, "ResizablePMCArray"
    push $P1247, $P1246
    .return ($P1247)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<ang>"  :subid("261_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1252_tgt
    .local int rx1252_pos
    .local int rx1252_off
    .local int rx1252_eos
    .local int rx1252_rep
    .local pmc rx1252_cur
    .local pmc rx1252_debug
    (rx1252_cur, rx1252_pos, rx1252_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1252_cur
    .local pmc match
    .lex "$/", match
    length rx1252_eos, rx1252_tgt
    gt rx1252_pos, rx1252_eos, rx1252_done
    set rx1252_off, 0
    lt rx1252_pos, 2, rx1252_start
    sub rx1252_off, rx1252_pos, 1
    substr rx1252_tgt, rx1252_tgt, rx1252_off
  rx1252_start:
    eq $I10, 1, rx1252_restart
    if_null rx1252_debug, debug_1081
    rx1252_cur."!cursor_debug"("START", "circumfix:sym<ang>")
  debug_1081:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1255_done
    goto rxscan1255_scan
  rxscan1255_loop:
    (rx1252_pos) = rx1252_cur."from"()
    inc rx1252_pos
    rx1252_cur."!cursor_from"(rx1252_pos)
    ge rx1252_pos, rx1252_eos, rxscan1255_done
  rxscan1255_scan:
    set_addr $I10, rxscan1255_loop
    rx1252_cur."!mark_push"(0, rx1252_pos, $I10)
  rxscan1255_done:
.annotate 'line', 569
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1252_pos, rx1252_off
    substr $S10, rx1252_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx1252_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1252_cur."!cursor_pos"(rx1252_pos)
    $P10 = rx1252_cur."quote_EXPR"(":q", ":w")
    unless $P10, rx1252_fail
    rx1252_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1252_pos = $P10."pos"()
  # rx pass
    rx1252_cur."!cursor_pass"(rx1252_pos, "circumfix:sym<ang>")
    if_null rx1252_debug, debug_1082
    rx1252_cur."!cursor_debug"("PASS", "circumfix:sym<ang>", " at pos=", rx1252_pos)
  debug_1082:
    .return (rx1252_cur)
  rx1252_restart:
.annotate 'line', 10
    if_null rx1252_debug, debug_1083
    rx1252_cur."!cursor_debug"("NEXT", "circumfix:sym<ang>")
  debug_1083:
  rx1252_fail:
    (rx1252_rep, rx1252_pos, $I10, $P10) = rx1252_cur."!mark_fail"(0)
    lt rx1252_pos, -1, rx1252_done
    eq rx1252_pos, -1, rx1252_fail
    jump $I10
  rx1252_done:
    rx1252_cur."!cursor_fail"()
    if_null rx1252_debug, debug_1084
    rx1252_cur."!cursor_debug"("FAIL", "circumfix:sym<ang>")
  debug_1084:
    .return (rx1252_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<ang>"  :nsentry("!PREFIX__circumfix:sym<ang>") :subid("262_1300062003.824") :method
.annotate 'line', 10
    new $P1254, "ResizablePMCArray"
    push $P1254, "<"
    .return ($P1254)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("263_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1257_tgt
    .local int rx1257_pos
    .local int rx1257_off
    .local int rx1257_eos
    .local int rx1257_rep
    .local pmc rx1257_cur
    .local pmc rx1257_debug
    (rx1257_cur, rx1257_pos, rx1257_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1257_cur
    .local pmc match
    .lex "$/", match
    length rx1257_eos, rx1257_tgt
    gt rx1257_pos, rx1257_eos, rx1257_done
    set rx1257_off, 0
    lt rx1257_pos, 2, rx1257_start
    sub rx1257_off, rx1257_pos, 1
    substr rx1257_tgt, rx1257_tgt, rx1257_off
  rx1257_start:
    eq $I10, 1, rx1257_restart
    if_null rx1257_debug, debug_1085
    rx1257_cur."!cursor_debug"("START", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1085:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1260_done
    goto rxscan1260_scan
  rxscan1260_loop:
    (rx1257_pos) = rx1257_cur."from"()
    inc rx1257_pos
    rx1257_cur."!cursor_from"(rx1257_pos)
    ge rx1257_pos, rx1257_eos, rxscan1260_done
  rxscan1260_scan:
    set_addr $I10, rxscan1260_loop
    rx1257_cur."!mark_push"(0, rx1257_pos, $I10)
  rxscan1260_done:
.annotate 'line', 570
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1257_pos, rx1257_off
    substr $S10, rx1257_tgt, $I10, 1
    index $I11, unicode:"\x{ab}", $S10
    lt $I11, 0, rx1257_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1257_cur."!cursor_pos"(rx1257_pos)
    $P10 = rx1257_cur."quote_EXPR"(":qq", ":w")
    unless $P10, rx1257_fail
    rx1257_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1257_pos = $P10."pos"()
  # rx pass
    rx1257_cur."!cursor_pass"(rx1257_pos, unicode:"circumfix:sym<\x{ab} \x{bb}>")
    if_null rx1257_debug, debug_1086
    rx1257_cur."!cursor_debug"("PASS", unicode:"circumfix:sym<\x{ab} \x{bb}>", " at pos=", rx1257_pos)
  debug_1086:
    .return (rx1257_cur)
  rx1257_restart:
.annotate 'line', 10
    if_null rx1257_debug, debug_1087
    rx1257_cur."!cursor_debug"("NEXT", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1087:
  rx1257_fail:
    (rx1257_rep, rx1257_pos, $I10, $P10) = rx1257_cur."!mark_fail"(0)
    lt rx1257_pos, -1, rx1257_done
    eq rx1257_pos, -1, rx1257_fail
    jump $I10
  rx1257_done:
    rx1257_cur."!cursor_fail"()
    if_null rx1257_debug, debug_1088
    rx1257_cur."!cursor_debug"("FAIL", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1088:
    .return (rx1257_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"  :nsentry(unicode:"!PREFIX__circumfix:sym<\\x{ab} \\x{bb}>") :subid("264_1300062003.824") :method
.annotate 'line', 10
    new $P1259, "ResizablePMCArray"
    push $P1259, unicode:"\x{ab}"
    .return ($P1259)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<{ }>"  :subid("265_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1262_tgt
    .local int rx1262_pos
    .local int rx1262_off
    .local int rx1262_eos
    .local int rx1262_rep
    .local pmc rx1262_cur
    .local pmc rx1262_debug
    (rx1262_cur, rx1262_pos, rx1262_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1262_cur
    .local pmc match
    .lex "$/", match
    length rx1262_eos, rx1262_tgt
    gt rx1262_pos, rx1262_eos, rx1262_done
    set rx1262_off, 0
    lt rx1262_pos, 2, rx1262_start
    sub rx1262_off, rx1262_pos, 1
    substr rx1262_tgt, rx1262_tgt, rx1262_off
  rx1262_start:
    eq $I10, 1, rx1262_restart
    if_null rx1262_debug, debug_1089
    rx1262_cur."!cursor_debug"("START", "circumfix:sym<{ }>")
  debug_1089:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1265_done
    goto rxscan1265_scan
  rxscan1265_loop:
    (rx1262_pos) = rx1262_cur."from"()
    inc rx1262_pos
    rx1262_cur."!cursor_from"(rx1262_pos)
    ge rx1262_pos, rx1262_eos, rxscan1265_done
  rxscan1265_scan:
    set_addr $I10, rxscan1265_loop
    rx1262_cur."!mark_push"(0, rx1262_pos, $I10)
  rxscan1265_done:
.annotate 'line', 571
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1262_pos, rx1262_off
    substr $S10, rx1262_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1262_fail
  # rx subrule "pblock" subtype=capture negate=
    rx1262_cur."!cursor_pos"(rx1262_pos)
    $P10 = rx1262_cur."pblock"()
    unless $P10, rx1262_fail
    rx1262_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx1262_pos = $P10."pos"()
  # rx pass
    rx1262_cur."!cursor_pass"(rx1262_pos, "circumfix:sym<{ }>")
    if_null rx1262_debug, debug_1090
    rx1262_cur."!cursor_debug"("PASS", "circumfix:sym<{ }>", " at pos=", rx1262_pos)
  debug_1090:
    .return (rx1262_cur)
  rx1262_restart:
.annotate 'line', 10
    if_null rx1262_debug, debug_1091
    rx1262_cur."!cursor_debug"("NEXT", "circumfix:sym<{ }>")
  debug_1091:
  rx1262_fail:
    (rx1262_rep, rx1262_pos, $I10, $P10) = rx1262_cur."!mark_fail"(0)
    lt rx1262_pos, -1, rx1262_done
    eq rx1262_pos, -1, rx1262_fail
    jump $I10
  rx1262_done:
    rx1262_cur."!cursor_fail"()
    if_null rx1262_debug, debug_1092
    rx1262_cur."!cursor_debug"("FAIL", "circumfix:sym<{ }>")
  debug_1092:
    .return (rx1262_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<{ }>"  :nsentry("!PREFIX__circumfix:sym<{ }>") :subid("266_1300062003.824") :method
.annotate 'line', 10
    new $P1264, "ResizablePMCArray"
    push $P1264, "{"
    .return ($P1264)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<sigil>"  :subid("267_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1267_tgt
    .local int rx1267_pos
    .local int rx1267_off
    .local int rx1267_eos
    .local int rx1267_rep
    .local pmc rx1267_cur
    .local pmc rx1267_debug
    (rx1267_cur, rx1267_pos, rx1267_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1267_cur
    .local pmc match
    .lex "$/", match
    length rx1267_eos, rx1267_tgt
    gt rx1267_pos, rx1267_eos, rx1267_done
    set rx1267_off, 0
    lt rx1267_pos, 2, rx1267_start
    sub rx1267_off, rx1267_pos, 1
    substr rx1267_tgt, rx1267_tgt, rx1267_off
  rx1267_start:
    eq $I10, 1, rx1267_restart
    if_null rx1267_debug, debug_1093
    rx1267_cur."!cursor_debug"("START", "circumfix:sym<sigil>")
  debug_1093:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1271_done
    goto rxscan1271_scan
  rxscan1271_loop:
    (rx1267_pos) = rx1267_cur."from"()
    inc rx1267_pos
    rx1267_cur."!cursor_from"(rx1267_pos)
    ge rx1267_pos, rx1267_eos, rxscan1271_done
  rxscan1271_scan:
    set_addr $I10, rxscan1271_loop
    rx1267_cur."!mark_push"(0, rx1267_pos, $I10)
  rxscan1271_done:
.annotate 'line', 572
  # rx subrule "sigil" subtype=capture negate=
    rx1267_cur."!cursor_pos"(rx1267_pos)
    $P10 = rx1267_cur."sigil"()
    unless $P10, rx1267_fail
    rx1267_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1267_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1267_pos, 1
    gt $I11, rx1267_eos, rx1267_fail
    sub $I11, rx1267_pos, rx1267_off
    ord $I11, rx1267_tgt, $I11
    ne $I11, 40, rx1267_fail
    add rx1267_pos, 1
  # rx subrule "semilist" subtype=capture negate=
    rx1267_cur."!cursor_pos"(rx1267_pos)
    $P10 = rx1267_cur."semilist"()
    unless $P10, rx1267_fail
    rx1267_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("semilist")
    rx1267_pos = $P10."pos"()
  alt1272_0:
    set_addr $I10, alt1272_1
    rx1267_cur."!mark_push"(0, rx1267_pos, $I10)
  # rx literal  ")"
    add $I11, rx1267_pos, 1
    gt $I11, rx1267_eos, rx1267_fail
    sub $I11, rx1267_pos, rx1267_off
    ord $I11, rx1267_tgt, $I11
    ne $I11, 41, rx1267_fail
    add rx1267_pos, 1
    goto alt1272_end
  alt1272_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx1267_cur."!cursor_pos"(rx1267_pos)
    $P10 = rx1267_cur."FAILGOAL"("')'")
    unless $P10, rx1267_fail
    goto rxsubrule1274_pass
  rxsubrule1274_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1267_fail
  rxsubrule1274_pass:
    set_addr $I10, rxsubrule1274_back
    rx1267_cur."!mark_push"(0, rx1267_pos, $I10, $P10)
    rx1267_pos = $P10."pos"()
  alt1272_end:
  # rx pass
    rx1267_cur."!cursor_pass"(rx1267_pos, "circumfix:sym<sigil>")
    if_null rx1267_debug, debug_1094
    rx1267_cur."!cursor_debug"("PASS", "circumfix:sym<sigil>", " at pos=", rx1267_pos)
  debug_1094:
    .return (rx1267_cur)
  rx1267_restart:
.annotate 'line', 10
    if_null rx1267_debug, debug_1095
    rx1267_cur."!cursor_debug"("NEXT", "circumfix:sym<sigil>")
  debug_1095:
  rx1267_fail:
    (rx1267_rep, rx1267_pos, $I10, $P10) = rx1267_cur."!mark_fail"(0)
    lt rx1267_pos, -1, rx1267_done
    eq rx1267_pos, -1, rx1267_fail
    jump $I10
  rx1267_done:
    rx1267_cur."!cursor_fail"()
    if_null rx1267_debug, debug_1096
    rx1267_cur."!cursor_debug"("FAIL", "circumfix:sym<sigil>")
  debug_1096:
    .return (rx1267_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<sigil>"  :nsentry("!PREFIX__circumfix:sym<sigil>") :subid("268_1300062003.824") :method
.annotate 'line', 10
    $P1269 = self."!PREFIX__!subrule"("sigil", "")
    new $P1270, "ResizablePMCArray"
    push $P1270, $P1269
    .return ($P1270)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "semilist"  :subid("269_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1276_tgt
    .local int rx1276_pos
    .local int rx1276_off
    .local int rx1276_eos
    .local int rx1276_rep
    .local pmc rx1276_cur
    .local pmc rx1276_debug
    (rx1276_cur, rx1276_pos, rx1276_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1276_cur
    .local pmc match
    .lex "$/", match
    length rx1276_eos, rx1276_tgt
    gt rx1276_pos, rx1276_eos, rx1276_done
    set rx1276_off, 0
    lt rx1276_pos, 2, rx1276_start
    sub rx1276_off, rx1276_pos, 1
    substr rx1276_tgt, rx1276_tgt, rx1276_off
  rx1276_start:
    eq $I10, 1, rx1276_restart
    if_null rx1276_debug, debug_1097
    rx1276_cur."!cursor_debug"("START", "semilist")
  debug_1097:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1280_done
    goto rxscan1280_scan
  rxscan1280_loop:
    (rx1276_pos) = rx1276_cur."from"()
    inc rx1276_pos
    rx1276_cur."!cursor_from"(rx1276_pos)
    ge rx1276_pos, rx1276_eos, rxscan1280_done
  rxscan1280_scan:
    set_addr $I10, rxscan1280_loop
    rx1276_cur."!mark_push"(0, rx1276_pos, $I10)
  rxscan1280_done:
.annotate 'line', 574
  # rx subrule "ws" subtype=method negate=
    rx1276_cur."!cursor_pos"(rx1276_pos)
    $P10 = rx1276_cur."ws"()
    unless $P10, rx1276_fail
    rx1276_pos = $P10."pos"()
  # rx subrule "statement" subtype=capture negate=
    rx1276_cur."!cursor_pos"(rx1276_pos)
    $P10 = rx1276_cur."statement"()
    unless $P10, rx1276_fail
    rx1276_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx1276_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1276_cur."!cursor_pos"(rx1276_pos)
    $P10 = rx1276_cur."ws"()
    unless $P10, rx1276_fail
    rx1276_pos = $P10."pos"()
  # rx pass
    rx1276_cur."!cursor_pass"(rx1276_pos, "semilist")
    if_null rx1276_debug, debug_1098
    rx1276_cur."!cursor_debug"("PASS", "semilist", " at pos=", rx1276_pos)
  debug_1098:
    .return (rx1276_cur)
  rx1276_restart:
.annotate 'line', 10
    if_null rx1276_debug, debug_1099
    rx1276_cur."!cursor_debug"("NEXT", "semilist")
  debug_1099:
  rx1276_fail:
    (rx1276_rep, rx1276_pos, $I10, $P10) = rx1276_cur."!mark_fail"(0)
    lt rx1276_pos, -1, rx1276_done
    eq rx1276_pos, -1, rx1276_fail
    jump $I10
  rx1276_done:
    rx1276_cur."!cursor_fail"()
    if_null rx1276_debug, debug_1100
    rx1276_cur."!cursor_debug"("FAIL", "semilist")
  debug_1100:
    .return (rx1276_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__semilist"  :nsentry("!PREFIX__semilist") :subid("270_1300062003.824") :method
.annotate 'line', 10
    $P1278 = self."!PREFIX__!subrule"("ws", "")
    new $P1279, "ResizablePMCArray"
    push $P1279, $P1278
    .return ($P1279)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1283"  :anon :subid("271_1300062003.824") :outer("12_1300062003.824")
.annotate 'line', 10
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "" :load :init :subid("post1101") :outer("271_1300062003.824")
.annotate 'line', 10
    .const 'Sub' $P1284 = "271_1300062003.824" 
    .local pmc block
    set block, $P1284
.annotate 'line', 579
    get_hll_global $P1285, ["NQP"], "Grammar"
    $P1285."O"(":prec<y=>, :assoc<unary>", "%methodop")
.annotate 'line', 580
    get_hll_global $P1286, ["NQP"], "Grammar"
    $P1286."O"(":prec<x=>, :assoc<unary>", "%autoincrement")
.annotate 'line', 581
    get_hll_global $P1287, ["NQP"], "Grammar"
    $P1287."O"(":prec<w=>, :assoc<left>", "%exponentiation")
.annotate 'line', 582
    get_hll_global $P1288, ["NQP"], "Grammar"
    $P1288."O"(":prec<v=>, :assoc<unary>", "%symbolic_unary")
.annotate 'line', 583
    get_hll_global $P1289, ["NQP"], "Grammar"
    $P1289."O"(":prec<u=>, :assoc<left>", "%multiplicative")
.annotate 'line', 584
    get_hll_global $P1290, ["NQP"], "Grammar"
    $P1290."O"(":prec<t=>, :assoc<left>", "%additive")
.annotate 'line', 585
    get_hll_global $P1291, ["NQP"], "Grammar"
    $P1291."O"(":prec<r=>, :assoc<left>", "%concatenation")
.annotate 'line', 586
    get_hll_global $P1292, ["NQP"], "Grammar"
    $P1292."O"(":prec<m=>, :assoc<left>", "%relational")
.annotate 'line', 587
    get_hll_global $P1293, ["NQP"], "Grammar"
    $P1293."O"(":prec<l=>, :assoc<left>", "%tight_and")
.annotate 'line', 588
    get_hll_global $P1294, ["NQP"], "Grammar"
    $P1294."O"(":prec<k=>, :assoc<left>", "%tight_or")
.annotate 'line', 589
    get_hll_global $P1295, ["NQP"], "Grammar"
    $P1295."O"(":prec<j=>, :assoc<right>", "%conditional")
.annotate 'line', 590
    get_hll_global $P1296, ["NQP"], "Grammar"
    $P1296."O"(":prec<i=>, :assoc<right>", "%assignment")
.annotate 'line', 591
    get_hll_global $P1297, ["NQP"], "Grammar"
    $P1297."O"(":prec<g=>, :assoc<list>, :nextterm<nulltermish>", "%comma")
.annotate 'line', 592
    get_hll_global $P1298, ["NQP"], "Grammar"
    $P1298."O"(":prec<f=>, :assoc<list>", "%list_infix")
.annotate 'line', 593
    get_hll_global $P1299, ["NQP"], "Grammar"
    $P1299."O"(":prec<e=>, :assoc<unary>", "%list_prefix")
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixish"  :subid("272_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1301_tgt
    .local int rx1301_pos
    .local int rx1301_off
    .local int rx1301_eos
    .local int rx1301_rep
    .local pmc rx1301_cur
    .local pmc rx1301_debug
    (rx1301_cur, rx1301_pos, rx1301_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1301_cur
    .local pmc match
    .lex "$/", match
    length rx1301_eos, rx1301_tgt
    gt rx1301_pos, rx1301_eos, rx1301_done
    set rx1301_off, 0
    lt rx1301_pos, 2, rx1301_start
    sub rx1301_off, rx1301_pos, 1
    substr rx1301_tgt, rx1301_tgt, rx1301_off
  rx1301_start:
    eq $I10, 1, rx1301_restart
    if_null rx1301_debug, debug_1102
    rx1301_cur."!cursor_debug"("START", "infixish")
  debug_1102:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1304_done
    goto rxscan1304_scan
  rxscan1304_loop:
    (rx1301_pos) = rx1301_cur."from"()
    inc rx1301_pos
    rx1301_cur."!cursor_from"(rx1301_pos)
    ge rx1301_pos, rx1301_eos, rxscan1304_done
  rxscan1304_scan:
    set_addr $I10, rxscan1304_loop
    rx1301_cur."!mark_push"(0, rx1301_pos, $I10)
  rxscan1304_done:
.annotate 'line', 597
  # rx subrule "infixstopper" subtype=zerowidth negate=1
    rx1301_cur."!cursor_pos"(rx1301_pos)
    $P10 = rx1301_cur."infixstopper"()
    if $P10, rx1301_fail
  # rx subrule "infix" subtype=capture negate=
    rx1301_cur."!cursor_pos"(rx1301_pos)
    $P10 = rx1301_cur."infix"()
    unless $P10, rx1301_fail
    rx1301_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("OPER=infix")
    rx1301_pos = $P10."pos"()
  # rx pass
    rx1301_cur."!cursor_pass"(rx1301_pos, "infixish")
    if_null rx1301_debug, debug_1103
    rx1301_cur."!cursor_debug"("PASS", "infixish", " at pos=", rx1301_pos)
  debug_1103:
    .return (rx1301_cur)
  rx1301_restart:
.annotate 'line', 10
    if_null rx1301_debug, debug_1104
    rx1301_cur."!cursor_debug"("NEXT", "infixish")
  debug_1104:
  rx1301_fail:
    (rx1301_rep, rx1301_pos, $I10, $P10) = rx1301_cur."!mark_fail"(0)
    lt rx1301_pos, -1, rx1301_done
    eq rx1301_pos, -1, rx1301_fail
    jump $I10
  rx1301_done:
    rx1301_cur."!cursor_fail"()
    if_null rx1301_debug, debug_1105
    rx1301_cur."!cursor_debug"("FAIL", "infixish")
  debug_1105:
    .return (rx1301_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixish"  :nsentry("!PREFIX__infixish") :subid("273_1300062003.824") :method
.annotate 'line', 10
    new $P1303, "ResizablePMCArray"
    push $P1303, ""
    .return ($P1303)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixstopper"  :subid("274_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1306_tgt
    .local int rx1306_pos
    .local int rx1306_off
    .local int rx1306_eos
    .local int rx1306_rep
    .local pmc rx1306_cur
    .local pmc rx1306_debug
    (rx1306_cur, rx1306_pos, rx1306_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1306_cur
    .local pmc match
    .lex "$/", match
    length rx1306_eos, rx1306_tgt
    gt rx1306_pos, rx1306_eos, rx1306_done
    set rx1306_off, 0
    lt rx1306_pos, 2, rx1306_start
    sub rx1306_off, rx1306_pos, 1
    substr rx1306_tgt, rx1306_tgt, rx1306_off
  rx1306_start:
    eq $I10, 1, rx1306_restart
    if_null rx1306_debug, debug_1106
    rx1306_cur."!cursor_debug"("START", "infixstopper")
  debug_1106:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1309_done
    goto rxscan1309_scan
  rxscan1309_loop:
    (rx1306_pos) = rx1306_cur."from"()
    inc rx1306_pos
    rx1306_cur."!cursor_from"(rx1306_pos)
    ge rx1306_pos, rx1306_eos, rxscan1309_done
  rxscan1309_scan:
    set_addr $I10, rxscan1309_loop
    rx1306_cur."!mark_push"(0, rx1306_pos, $I10)
  rxscan1309_done:
.annotate 'line', 598
  # rx subrule "lambda" subtype=zerowidth negate=
    rx1306_cur."!cursor_pos"(rx1306_pos)
    $P10 = rx1306_cur."lambda"()
    unless $P10, rx1306_fail
  # rx pass
    rx1306_cur."!cursor_pass"(rx1306_pos, "infixstopper")
    if_null rx1306_debug, debug_1107
    rx1306_cur."!cursor_debug"("PASS", "infixstopper", " at pos=", rx1306_pos)
  debug_1107:
    .return (rx1306_cur)
  rx1306_restart:
.annotate 'line', 10
    if_null rx1306_debug, debug_1108
    rx1306_cur."!cursor_debug"("NEXT", "infixstopper")
  debug_1108:
  rx1306_fail:
    (rx1306_rep, rx1306_pos, $I10, $P10) = rx1306_cur."!mark_fail"(0)
    lt rx1306_pos, -1, rx1306_done
    eq rx1306_pos, -1, rx1306_fail
    jump $I10
  rx1306_done:
    rx1306_cur."!cursor_fail"()
    if_null rx1306_debug, debug_1109
    rx1306_cur."!cursor_debug"("FAIL", "infixstopper")
  debug_1109:
    .return (rx1306_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixstopper"  :nsentry("!PREFIX__infixstopper") :subid("275_1300062003.824") :method
.annotate 'line', 10
    new $P1308, "ResizablePMCArray"
    push $P1308, ""
    .return ($P1308)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<[ ]>"  :subid("276_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1311_tgt
    .local int rx1311_pos
    .local int rx1311_off
    .local int rx1311_eos
    .local int rx1311_rep
    .local pmc rx1311_cur
    .local pmc rx1311_debug
    (rx1311_cur, rx1311_pos, rx1311_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1311_cur
    .local pmc match
    .lex "$/", match
    length rx1311_eos, rx1311_tgt
    gt rx1311_pos, rx1311_eos, rx1311_done
    set rx1311_off, 0
    lt rx1311_pos, 2, rx1311_start
    sub rx1311_off, rx1311_pos, 1
    substr rx1311_tgt, rx1311_tgt, rx1311_off
  rx1311_start:
    eq $I10, 1, rx1311_restart
    if_null rx1311_debug, debug_1110
    rx1311_cur."!cursor_debug"("START", "postcircumfix:sym<[ ]>")
  debug_1110:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1315_done
    goto rxscan1315_scan
  rxscan1315_loop:
    (rx1311_pos) = rx1311_cur."from"()
    inc rx1311_pos
    rx1311_cur."!cursor_from"(rx1311_pos)
    ge rx1311_pos, rx1311_eos, rxscan1315_done
  rxscan1315_scan:
    set_addr $I10, rxscan1315_loop
    rx1311_cur."!mark_push"(0, rx1311_pos, $I10)
  rxscan1315_done:
.annotate 'line', 601
  # rx literal  "["
    add $I11, rx1311_pos, 1
    gt $I11, rx1311_eos, rx1311_fail
    sub $I11, rx1311_pos, rx1311_off
    ord $I11, rx1311_tgt, $I11
    ne $I11, 91, rx1311_fail
    add rx1311_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1311_cur."!cursor_pos"(rx1311_pos)
    $P10 = rx1311_cur."ws"()
    unless $P10, rx1311_fail
    rx1311_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1311_cur."!cursor_pos"(rx1311_pos)
    $P10 = rx1311_cur."EXPR"()
    unless $P10, rx1311_fail
    rx1311_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1311_pos = $P10."pos"()
  # rx literal  "]"
    add $I11, rx1311_pos, 1
    gt $I11, rx1311_eos, rx1311_fail
    sub $I11, rx1311_pos, rx1311_off
    ord $I11, rx1311_tgt, $I11
    ne $I11, 93, rx1311_fail
    add rx1311_pos, 1
.annotate 'line', 602
  # rx subrule "O" subtype=capture negate=
    rx1311_cur."!cursor_pos"(rx1311_pos)
    $P10 = rx1311_cur."O"("%methodop")
    unless $P10, rx1311_fail
    rx1311_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1311_pos = $P10."pos"()
.annotate 'line', 600
  # rx pass
    rx1311_cur."!cursor_pass"(rx1311_pos, "postcircumfix:sym<[ ]>")
    if_null rx1311_debug, debug_1111
    rx1311_cur."!cursor_debug"("PASS", "postcircumfix:sym<[ ]>", " at pos=", rx1311_pos)
  debug_1111:
    .return (rx1311_cur)
  rx1311_restart:
.annotate 'line', 10
    if_null rx1311_debug, debug_1112
    rx1311_cur."!cursor_debug"("NEXT", "postcircumfix:sym<[ ]>")
  debug_1112:
  rx1311_fail:
    (rx1311_rep, rx1311_pos, $I10, $P10) = rx1311_cur."!mark_fail"(0)
    lt rx1311_pos, -1, rx1311_done
    eq rx1311_pos, -1, rx1311_fail
    jump $I10
  rx1311_done:
    rx1311_cur."!cursor_fail"()
    if_null rx1311_debug, debug_1113
    rx1311_cur."!cursor_debug"("FAIL", "postcircumfix:sym<[ ]>")
  debug_1113:
    .return (rx1311_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<[ ]>"  :nsentry("!PREFIX__postcircumfix:sym<[ ]>") :subid("277_1300062003.824") :method
.annotate 'line', 10
    $P1313 = self."!PREFIX__!subrule"("ws", "[")
    new $P1314, "ResizablePMCArray"
    push $P1314, $P1313
    .return ($P1314)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<{ }>"  :subid("278_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1317_tgt
    .local int rx1317_pos
    .local int rx1317_off
    .local int rx1317_eos
    .local int rx1317_rep
    .local pmc rx1317_cur
    .local pmc rx1317_debug
    (rx1317_cur, rx1317_pos, rx1317_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1317_cur
    .local pmc match
    .lex "$/", match
    length rx1317_eos, rx1317_tgt
    gt rx1317_pos, rx1317_eos, rx1317_done
    set rx1317_off, 0
    lt rx1317_pos, 2, rx1317_start
    sub rx1317_off, rx1317_pos, 1
    substr rx1317_tgt, rx1317_tgt, rx1317_off
  rx1317_start:
    eq $I10, 1, rx1317_restart
    if_null rx1317_debug, debug_1114
    rx1317_cur."!cursor_debug"("START", "postcircumfix:sym<{ }>")
  debug_1114:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1321_done
    goto rxscan1321_scan
  rxscan1321_loop:
    (rx1317_pos) = rx1317_cur."from"()
    inc rx1317_pos
    rx1317_cur."!cursor_from"(rx1317_pos)
    ge rx1317_pos, rx1317_eos, rxscan1321_done
  rxscan1321_scan:
    set_addr $I10, rxscan1321_loop
    rx1317_cur."!mark_push"(0, rx1317_pos, $I10)
  rxscan1321_done:
.annotate 'line', 606
  # rx literal  "{"
    add $I11, rx1317_pos, 1
    gt $I11, rx1317_eos, rx1317_fail
    sub $I11, rx1317_pos, rx1317_off
    ord $I11, rx1317_tgt, $I11
    ne $I11, 123, rx1317_fail
    add rx1317_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1317_cur."!cursor_pos"(rx1317_pos)
    $P10 = rx1317_cur."ws"()
    unless $P10, rx1317_fail
    rx1317_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1317_cur."!cursor_pos"(rx1317_pos)
    $P10 = rx1317_cur."EXPR"()
    unless $P10, rx1317_fail
    rx1317_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1317_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1317_pos, 1
    gt $I11, rx1317_eos, rx1317_fail
    sub $I11, rx1317_pos, rx1317_off
    ord $I11, rx1317_tgt, $I11
    ne $I11, 125, rx1317_fail
    add rx1317_pos, 1
.annotate 'line', 607
  # rx subrule "O" subtype=capture negate=
    rx1317_cur."!cursor_pos"(rx1317_pos)
    $P10 = rx1317_cur."O"("%methodop")
    unless $P10, rx1317_fail
    rx1317_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1317_pos = $P10."pos"()
.annotate 'line', 605
  # rx pass
    rx1317_cur."!cursor_pass"(rx1317_pos, "postcircumfix:sym<{ }>")
    if_null rx1317_debug, debug_1115
    rx1317_cur."!cursor_debug"("PASS", "postcircumfix:sym<{ }>", " at pos=", rx1317_pos)
  debug_1115:
    .return (rx1317_cur)
  rx1317_restart:
.annotate 'line', 10
    if_null rx1317_debug, debug_1116
    rx1317_cur."!cursor_debug"("NEXT", "postcircumfix:sym<{ }>")
  debug_1116:
  rx1317_fail:
    (rx1317_rep, rx1317_pos, $I10, $P10) = rx1317_cur."!mark_fail"(0)
    lt rx1317_pos, -1, rx1317_done
    eq rx1317_pos, -1, rx1317_fail
    jump $I10
  rx1317_done:
    rx1317_cur."!cursor_fail"()
    if_null rx1317_debug, debug_1117
    rx1317_cur."!cursor_debug"("FAIL", "postcircumfix:sym<{ }>")
  debug_1117:
    .return (rx1317_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<{ }>"  :nsentry("!PREFIX__postcircumfix:sym<{ }>") :subid("279_1300062003.824") :method
.annotate 'line', 10
    $P1319 = self."!PREFIX__!subrule"("ws", "{")
    new $P1320, "ResizablePMCArray"
    push $P1320, $P1319
    .return ($P1320)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<ang>"  :subid("280_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1323_tgt
    .local int rx1323_pos
    .local int rx1323_off
    .local int rx1323_eos
    .local int rx1323_rep
    .local pmc rx1323_cur
    .local pmc rx1323_debug
    (rx1323_cur, rx1323_pos, rx1323_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1323_cur
    .local pmc match
    .lex "$/", match
    length rx1323_eos, rx1323_tgt
    gt rx1323_pos, rx1323_eos, rx1323_done
    set rx1323_off, 0
    lt rx1323_pos, 2, rx1323_start
    sub rx1323_off, rx1323_pos, 1
    substr rx1323_tgt, rx1323_tgt, rx1323_off
  rx1323_start:
    eq $I10, 1, rx1323_restart
    if_null rx1323_debug, debug_1118
    rx1323_cur."!cursor_debug"("START", "postcircumfix:sym<ang>")
  debug_1118:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1326_done
    goto rxscan1326_scan
  rxscan1326_loop:
    (rx1323_pos) = rx1323_cur."from"()
    inc rx1323_pos
    rx1323_cur."!cursor_from"(rx1323_pos)
    ge rx1323_pos, rx1323_eos, rxscan1326_done
  rxscan1326_scan:
    set_addr $I10, rxscan1326_loop
    rx1323_cur."!mark_push"(0, rx1323_pos, $I10)
  rxscan1326_done:
.annotate 'line', 611
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1323_pos, rx1323_off
    substr $S10, rx1323_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx1323_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1323_cur."!cursor_pos"(rx1323_pos)
    $P10 = rx1323_cur."quote_EXPR"(":q")
    unless $P10, rx1323_fail
    rx1323_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1323_pos = $P10."pos"()
.annotate 'line', 612
  # rx subrule "O" subtype=capture negate=
    rx1323_cur."!cursor_pos"(rx1323_pos)
    $P10 = rx1323_cur."O"("%methodop")
    unless $P10, rx1323_fail
    rx1323_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1323_pos = $P10."pos"()
.annotate 'line', 610
  # rx pass
    rx1323_cur."!cursor_pass"(rx1323_pos, "postcircumfix:sym<ang>")
    if_null rx1323_debug, debug_1119
    rx1323_cur."!cursor_debug"("PASS", "postcircumfix:sym<ang>", " at pos=", rx1323_pos)
  debug_1119:
    .return (rx1323_cur)
  rx1323_restart:
.annotate 'line', 10
    if_null rx1323_debug, debug_1120
    rx1323_cur."!cursor_debug"("NEXT", "postcircumfix:sym<ang>")
  debug_1120:
  rx1323_fail:
    (rx1323_rep, rx1323_pos, $I10, $P10) = rx1323_cur."!mark_fail"(0)
    lt rx1323_pos, -1, rx1323_done
    eq rx1323_pos, -1, rx1323_fail
    jump $I10
  rx1323_done:
    rx1323_cur."!cursor_fail"()
    if_null rx1323_debug, debug_1121
    rx1323_cur."!cursor_debug"("FAIL", "postcircumfix:sym<ang>")
  debug_1121:
    .return (rx1323_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<ang>"  :nsentry("!PREFIX__postcircumfix:sym<ang>") :subid("281_1300062003.824") :method
.annotate 'line', 10
    new $P1325, "ResizablePMCArray"
    push $P1325, "<"
    .return ($P1325)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<( )>"  :subid("282_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1328_tgt
    .local int rx1328_pos
    .local int rx1328_off
    .local int rx1328_eos
    .local int rx1328_rep
    .local pmc rx1328_cur
    .local pmc rx1328_debug
    (rx1328_cur, rx1328_pos, rx1328_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1328_cur
    .local pmc match
    .lex "$/", match
    length rx1328_eos, rx1328_tgt
    gt rx1328_pos, rx1328_eos, rx1328_done
    set rx1328_off, 0
    lt rx1328_pos, 2, rx1328_start
    sub rx1328_off, rx1328_pos, 1
    substr rx1328_tgt, rx1328_tgt, rx1328_off
  rx1328_start:
    eq $I10, 1, rx1328_restart
    if_null rx1328_debug, debug_1122
    rx1328_cur."!cursor_debug"("START", "postcircumfix:sym<( )>")
  debug_1122:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1332_done
    goto rxscan1332_scan
  rxscan1332_loop:
    (rx1328_pos) = rx1328_cur."from"()
    inc rx1328_pos
    rx1328_cur."!cursor_from"(rx1328_pos)
    ge rx1328_pos, rx1328_eos, rxscan1332_done
  rxscan1332_scan:
    set_addr $I10, rxscan1332_loop
    rx1328_cur."!mark_push"(0, rx1328_pos, $I10)
  rxscan1332_done:
.annotate 'line', 616
  # rx literal  "("
    add $I11, rx1328_pos, 1
    gt $I11, rx1328_eos, rx1328_fail
    sub $I11, rx1328_pos, rx1328_off
    ord $I11, rx1328_tgt, $I11
    ne $I11, 40, rx1328_fail
    add rx1328_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1328_cur."!cursor_pos"(rx1328_pos)
    $P10 = rx1328_cur."ws"()
    unless $P10, rx1328_fail
    rx1328_pos = $P10."pos"()
  # rx subrule "arglist" subtype=capture negate=
    rx1328_cur."!cursor_pos"(rx1328_pos)
    $P10 = rx1328_cur."arglist"()
    unless $P10, rx1328_fail
    rx1328_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1328_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1328_pos, 1
    gt $I11, rx1328_eos, rx1328_fail
    sub $I11, rx1328_pos, rx1328_off
    ord $I11, rx1328_tgt, $I11
    ne $I11, 41, rx1328_fail
    add rx1328_pos, 1
.annotate 'line', 617
  # rx subrule "O" subtype=capture negate=
    rx1328_cur."!cursor_pos"(rx1328_pos)
    $P10 = rx1328_cur."O"("%methodop")
    unless $P10, rx1328_fail
    rx1328_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1328_pos = $P10."pos"()
.annotate 'line', 615
  # rx pass
    rx1328_cur."!cursor_pass"(rx1328_pos, "postcircumfix:sym<( )>")
    if_null rx1328_debug, debug_1123
    rx1328_cur."!cursor_debug"("PASS", "postcircumfix:sym<( )>", " at pos=", rx1328_pos)
  debug_1123:
    .return (rx1328_cur)
  rx1328_restart:
.annotate 'line', 10
    if_null rx1328_debug, debug_1124
    rx1328_cur."!cursor_debug"("NEXT", "postcircumfix:sym<( )>")
  debug_1124:
  rx1328_fail:
    (rx1328_rep, rx1328_pos, $I10, $P10) = rx1328_cur."!mark_fail"(0)
    lt rx1328_pos, -1, rx1328_done
    eq rx1328_pos, -1, rx1328_fail
    jump $I10
  rx1328_done:
    rx1328_cur."!cursor_fail"()
    if_null rx1328_debug, debug_1125
    rx1328_cur."!cursor_debug"("FAIL", "postcircumfix:sym<( )>")
  debug_1125:
    .return (rx1328_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<( )>"  :nsentry("!PREFIX__postcircumfix:sym<( )>") :subid("283_1300062003.824") :method
.annotate 'line', 10
    $P1330 = self."!PREFIX__!subrule"("ws", "(")
    new $P1331, "ResizablePMCArray"
    push $P1331, $P1330
    .return ($P1331)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<.>"  :subid("284_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1334_tgt
    .local int rx1334_pos
    .local int rx1334_off
    .local int rx1334_eos
    .local int rx1334_rep
    .local pmc rx1334_cur
    .local pmc rx1334_debug
    (rx1334_cur, rx1334_pos, rx1334_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1334_cur
    .local pmc match
    .lex "$/", match
    length rx1334_eos, rx1334_tgt
    gt rx1334_pos, rx1334_eos, rx1334_done
    set rx1334_off, 0
    lt rx1334_pos, 2, rx1334_start
    sub rx1334_off, rx1334_pos, 1
    substr rx1334_tgt, rx1334_tgt, rx1334_off
  rx1334_start:
    eq $I10, 1, rx1334_restart
    if_null rx1334_debug, debug_1126
    rx1334_cur."!cursor_debug"("START", "postfix:sym<.>")
  debug_1126:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1338_done
    goto rxscan1338_scan
  rxscan1338_loop:
    (rx1334_pos) = rx1334_cur."from"()
    inc rx1334_pos
    rx1334_cur."!cursor_from"(rx1334_pos)
    ge rx1334_pos, rx1334_eos, rxscan1338_done
  rxscan1338_scan:
    set_addr $I10, rxscan1338_loop
    rx1334_cur."!mark_push"(0, rx1334_pos, $I10)
  rxscan1338_done:
.annotate 'line', 620
  # rx subrule "dotty" subtype=capture negate=
    rx1334_cur."!cursor_pos"(rx1334_pos)
    $P10 = rx1334_cur."dotty"()
    unless $P10, rx1334_fail
    rx1334_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dotty")
    rx1334_pos = $P10."pos"()
  # rx subrule "O" subtype=capture negate=
    rx1334_cur."!cursor_pos"(rx1334_pos)
    $P10 = rx1334_cur."O"("%methodop")
    unless $P10, rx1334_fail
    rx1334_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1334_pos = $P10."pos"()
  # rx pass
    rx1334_cur."!cursor_pass"(rx1334_pos, "postfix:sym<.>")
    if_null rx1334_debug, debug_1127
    rx1334_cur."!cursor_debug"("PASS", "postfix:sym<.>", " at pos=", rx1334_pos)
  debug_1127:
    .return (rx1334_cur)
  rx1334_restart:
.annotate 'line', 10
    if_null rx1334_debug, debug_1128
    rx1334_cur."!cursor_debug"("NEXT", "postfix:sym<.>")
  debug_1128:
  rx1334_fail:
    (rx1334_rep, rx1334_pos, $I10, $P10) = rx1334_cur."!mark_fail"(0)
    lt rx1334_pos, -1, rx1334_done
    eq rx1334_pos, -1, rx1334_fail
    jump $I10
  rx1334_done:
    rx1334_cur."!cursor_fail"()
    if_null rx1334_debug, debug_1129
    rx1334_cur."!cursor_debug"("FAIL", "postfix:sym<.>")
  debug_1129:
    .return (rx1334_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<.>"  :nsentry("!PREFIX__postfix:sym<.>") :subid("285_1300062003.824") :method
.annotate 'line', 10
    $P1336 = self."!PREFIX__!subrule"("dotty", "")
    new $P1337, "ResizablePMCArray"
    push $P1337, $P1336
    .return ($P1337)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<++>"  :subid("286_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1340_tgt
    .local int rx1340_pos
    .local int rx1340_off
    .local int rx1340_eos
    .local int rx1340_rep
    .local pmc rx1340_cur
    .local pmc rx1340_debug
    (rx1340_cur, rx1340_pos, rx1340_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1340_cur
    .local pmc match
    .lex "$/", match
    length rx1340_eos, rx1340_tgt
    gt rx1340_pos, rx1340_eos, rx1340_done
    set rx1340_off, 0
    lt rx1340_pos, 2, rx1340_start
    sub rx1340_off, rx1340_pos, 1
    substr rx1340_tgt, rx1340_tgt, rx1340_off
  rx1340_start:
    eq $I10, 1, rx1340_restart
    if_null rx1340_debug, debug_1130
    rx1340_cur."!cursor_debug"("START", "prefix:sym<++>")
  debug_1130:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1344_done
    goto rxscan1344_scan
  rxscan1344_loop:
    (rx1340_pos) = rx1340_cur."from"()
    inc rx1340_pos
    rx1340_cur."!cursor_from"(rx1340_pos)
    ge rx1340_pos, rx1340_eos, rxscan1344_done
  rxscan1344_scan:
    set_addr $I10, rxscan1344_loop
    rx1340_cur."!mark_push"(0, rx1340_pos, $I10)
  rxscan1344_done:
.annotate 'line', 622
  # rx subcapture "sym"
    set_addr $I10, rxcap_1345_fail
    rx1340_cur."!mark_push"(0, rx1340_pos, $I10)
  # rx literal  "++"
    add $I11, rx1340_pos, 2
    gt $I11, rx1340_eos, rx1340_fail
    sub $I11, rx1340_pos, rx1340_off
    substr $S10, rx1340_tgt, $I11, 2
    ne $S10, "++", rx1340_fail
    add rx1340_pos, 2
    set_addr $I10, rxcap_1345_fail
    ($I12, $I11) = rx1340_cur."!mark_peek"($I10)
    rx1340_cur."!cursor_pos"($I11)
    ($P10) = rx1340_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1340_pos, "")
    rx1340_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1345_done
  rxcap_1345_fail:
    goto rx1340_fail
  rxcap_1345_done:
  # rx subrule "O" subtype=capture negate=
    rx1340_cur."!cursor_pos"(rx1340_pos)
    $P10 = rx1340_cur."O"("%autoincrement, :pirop<inc>")
    unless $P10, rx1340_fail
    rx1340_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1340_pos = $P10."pos"()
  # rx pass
    rx1340_cur."!cursor_pass"(rx1340_pos, "prefix:sym<++>")
    if_null rx1340_debug, debug_1131
    rx1340_cur."!cursor_debug"("PASS", "prefix:sym<++>", " at pos=", rx1340_pos)
  debug_1131:
    .return (rx1340_cur)
  rx1340_restart:
.annotate 'line', 10
    if_null rx1340_debug, debug_1132
    rx1340_cur."!cursor_debug"("NEXT", "prefix:sym<++>")
  debug_1132:
  rx1340_fail:
    (rx1340_rep, rx1340_pos, $I10, $P10) = rx1340_cur."!mark_fail"(0)
    lt rx1340_pos, -1, rx1340_done
    eq rx1340_pos, -1, rx1340_fail
    jump $I10
  rx1340_done:
    rx1340_cur."!cursor_fail"()
    if_null rx1340_debug, debug_1133
    rx1340_cur."!cursor_debug"("FAIL", "prefix:sym<++>")
  debug_1133:
    .return (rx1340_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<++>"  :nsentry("!PREFIX__prefix:sym<++>") :subid("287_1300062003.824") :method
.annotate 'line', 10
    $P1342 = self."!PREFIX__!subrule"("O", "++")
    new $P1343, "ResizablePMCArray"
    push $P1343, $P1342
    .return ($P1343)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<-->"  :subid("288_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1347_tgt
    .local int rx1347_pos
    .local int rx1347_off
    .local int rx1347_eos
    .local int rx1347_rep
    .local pmc rx1347_cur
    .local pmc rx1347_debug
    (rx1347_cur, rx1347_pos, rx1347_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1347_cur
    .local pmc match
    .lex "$/", match
    length rx1347_eos, rx1347_tgt
    gt rx1347_pos, rx1347_eos, rx1347_done
    set rx1347_off, 0
    lt rx1347_pos, 2, rx1347_start
    sub rx1347_off, rx1347_pos, 1
    substr rx1347_tgt, rx1347_tgt, rx1347_off
  rx1347_start:
    eq $I10, 1, rx1347_restart
    if_null rx1347_debug, debug_1134
    rx1347_cur."!cursor_debug"("START", "prefix:sym<-->")
  debug_1134:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1351_done
    goto rxscan1351_scan
  rxscan1351_loop:
    (rx1347_pos) = rx1347_cur."from"()
    inc rx1347_pos
    rx1347_cur."!cursor_from"(rx1347_pos)
    ge rx1347_pos, rx1347_eos, rxscan1351_done
  rxscan1351_scan:
    set_addr $I10, rxscan1351_loop
    rx1347_cur."!mark_push"(0, rx1347_pos, $I10)
  rxscan1351_done:
.annotate 'line', 623
  # rx subcapture "sym"
    set_addr $I10, rxcap_1352_fail
    rx1347_cur."!mark_push"(0, rx1347_pos, $I10)
  # rx literal  "--"
    add $I11, rx1347_pos, 2
    gt $I11, rx1347_eos, rx1347_fail
    sub $I11, rx1347_pos, rx1347_off
    substr $S10, rx1347_tgt, $I11, 2
    ne $S10, "--", rx1347_fail
    add rx1347_pos, 2
    set_addr $I10, rxcap_1352_fail
    ($I12, $I11) = rx1347_cur."!mark_peek"($I10)
    rx1347_cur."!cursor_pos"($I11)
    ($P10) = rx1347_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1347_pos, "")
    rx1347_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1352_done
  rxcap_1352_fail:
    goto rx1347_fail
  rxcap_1352_done:
  # rx subrule "O" subtype=capture negate=
    rx1347_cur."!cursor_pos"(rx1347_pos)
    $P10 = rx1347_cur."O"("%autoincrement, :pirop<dec>")
    unless $P10, rx1347_fail
    rx1347_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1347_pos = $P10."pos"()
  # rx pass
    rx1347_cur."!cursor_pass"(rx1347_pos, "prefix:sym<-->")
    if_null rx1347_debug, debug_1135
    rx1347_cur."!cursor_debug"("PASS", "prefix:sym<-->", " at pos=", rx1347_pos)
  debug_1135:
    .return (rx1347_cur)
  rx1347_restart:
.annotate 'line', 10
    if_null rx1347_debug, debug_1136
    rx1347_cur."!cursor_debug"("NEXT", "prefix:sym<-->")
  debug_1136:
  rx1347_fail:
    (rx1347_rep, rx1347_pos, $I10, $P10) = rx1347_cur."!mark_fail"(0)
    lt rx1347_pos, -1, rx1347_done
    eq rx1347_pos, -1, rx1347_fail
    jump $I10
  rx1347_done:
    rx1347_cur."!cursor_fail"()
    if_null rx1347_debug, debug_1137
    rx1347_cur."!cursor_debug"("FAIL", "prefix:sym<-->")
  debug_1137:
    .return (rx1347_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<-->"  :nsentry("!PREFIX__prefix:sym<-->") :subid("289_1300062003.824") :method
.annotate 'line', 10
    $P1349 = self."!PREFIX__!subrule"("O", "--")
    new $P1350, "ResizablePMCArray"
    push $P1350, $P1349
    .return ($P1350)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<++>"  :subid("290_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1354_tgt
    .local int rx1354_pos
    .local int rx1354_off
    .local int rx1354_eos
    .local int rx1354_rep
    .local pmc rx1354_cur
    .local pmc rx1354_debug
    (rx1354_cur, rx1354_pos, rx1354_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1354_cur
    .local pmc match
    .lex "$/", match
    length rx1354_eos, rx1354_tgt
    gt rx1354_pos, rx1354_eos, rx1354_done
    set rx1354_off, 0
    lt rx1354_pos, 2, rx1354_start
    sub rx1354_off, rx1354_pos, 1
    substr rx1354_tgt, rx1354_tgt, rx1354_off
  rx1354_start:
    eq $I10, 1, rx1354_restart
    if_null rx1354_debug, debug_1138
    rx1354_cur."!cursor_debug"("START", "postfix:sym<++>")
  debug_1138:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1358_done
    goto rxscan1358_scan
  rxscan1358_loop:
    (rx1354_pos) = rx1354_cur."from"()
    inc rx1354_pos
    rx1354_cur."!cursor_from"(rx1354_pos)
    ge rx1354_pos, rx1354_eos, rxscan1358_done
  rxscan1358_scan:
    set_addr $I10, rxscan1358_loop
    rx1354_cur."!mark_push"(0, rx1354_pos, $I10)
  rxscan1358_done:
.annotate 'line', 626
  # rx subcapture "sym"
    set_addr $I10, rxcap_1359_fail
    rx1354_cur."!mark_push"(0, rx1354_pos, $I10)
  # rx literal  "++"
    add $I11, rx1354_pos, 2
    gt $I11, rx1354_eos, rx1354_fail
    sub $I11, rx1354_pos, rx1354_off
    substr $S10, rx1354_tgt, $I11, 2
    ne $S10, "++", rx1354_fail
    add rx1354_pos, 2
    set_addr $I10, rxcap_1359_fail
    ($I12, $I11) = rx1354_cur."!mark_peek"($I10)
    rx1354_cur."!cursor_pos"($I11)
    ($P10) = rx1354_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1354_pos, "")
    rx1354_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1359_done
  rxcap_1359_fail:
    goto rx1354_fail
  rxcap_1359_done:
  # rx subrule "O" subtype=capture negate=
    rx1354_cur."!cursor_pos"(rx1354_pos)
    $P10 = rx1354_cur."O"("%autoincrement")
    unless $P10, rx1354_fail
    rx1354_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1354_pos = $P10."pos"()
  # rx pass
    rx1354_cur."!cursor_pass"(rx1354_pos, "postfix:sym<++>")
    if_null rx1354_debug, debug_1139
    rx1354_cur."!cursor_debug"("PASS", "postfix:sym<++>", " at pos=", rx1354_pos)
  debug_1139:
    .return (rx1354_cur)
  rx1354_restart:
.annotate 'line', 10
    if_null rx1354_debug, debug_1140
    rx1354_cur."!cursor_debug"("NEXT", "postfix:sym<++>")
  debug_1140:
  rx1354_fail:
    (rx1354_rep, rx1354_pos, $I10, $P10) = rx1354_cur."!mark_fail"(0)
    lt rx1354_pos, -1, rx1354_done
    eq rx1354_pos, -1, rx1354_fail
    jump $I10
  rx1354_done:
    rx1354_cur."!cursor_fail"()
    if_null rx1354_debug, debug_1141
    rx1354_cur."!cursor_debug"("FAIL", "postfix:sym<++>")
  debug_1141:
    .return (rx1354_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<++>"  :nsentry("!PREFIX__postfix:sym<++>") :subid("291_1300062003.824") :method
.annotate 'line', 10
    $P1356 = self."!PREFIX__!subrule"("O", "++")
    new $P1357, "ResizablePMCArray"
    push $P1357, $P1356
    .return ($P1357)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<-->"  :subid("292_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1361_tgt
    .local int rx1361_pos
    .local int rx1361_off
    .local int rx1361_eos
    .local int rx1361_rep
    .local pmc rx1361_cur
    .local pmc rx1361_debug
    (rx1361_cur, rx1361_pos, rx1361_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1361_cur
    .local pmc match
    .lex "$/", match
    length rx1361_eos, rx1361_tgt
    gt rx1361_pos, rx1361_eos, rx1361_done
    set rx1361_off, 0
    lt rx1361_pos, 2, rx1361_start
    sub rx1361_off, rx1361_pos, 1
    substr rx1361_tgt, rx1361_tgt, rx1361_off
  rx1361_start:
    eq $I10, 1, rx1361_restart
    if_null rx1361_debug, debug_1142
    rx1361_cur."!cursor_debug"("START", "postfix:sym<-->")
  debug_1142:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1365_done
    goto rxscan1365_scan
  rxscan1365_loop:
    (rx1361_pos) = rx1361_cur."from"()
    inc rx1361_pos
    rx1361_cur."!cursor_from"(rx1361_pos)
    ge rx1361_pos, rx1361_eos, rxscan1365_done
  rxscan1365_scan:
    set_addr $I10, rxscan1365_loop
    rx1361_cur."!mark_push"(0, rx1361_pos, $I10)
  rxscan1365_done:
.annotate 'line', 627
  # rx subcapture "sym"
    set_addr $I10, rxcap_1366_fail
    rx1361_cur."!mark_push"(0, rx1361_pos, $I10)
  # rx literal  "--"
    add $I11, rx1361_pos, 2
    gt $I11, rx1361_eos, rx1361_fail
    sub $I11, rx1361_pos, rx1361_off
    substr $S10, rx1361_tgt, $I11, 2
    ne $S10, "--", rx1361_fail
    add rx1361_pos, 2
    set_addr $I10, rxcap_1366_fail
    ($I12, $I11) = rx1361_cur."!mark_peek"($I10)
    rx1361_cur."!cursor_pos"($I11)
    ($P10) = rx1361_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1361_pos, "")
    rx1361_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1366_done
  rxcap_1366_fail:
    goto rx1361_fail
  rxcap_1366_done:
  # rx subrule "O" subtype=capture negate=
    rx1361_cur."!cursor_pos"(rx1361_pos)
    $P10 = rx1361_cur."O"("%autoincrement")
    unless $P10, rx1361_fail
    rx1361_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1361_pos = $P10."pos"()
  # rx pass
    rx1361_cur."!cursor_pass"(rx1361_pos, "postfix:sym<-->")
    if_null rx1361_debug, debug_1143
    rx1361_cur."!cursor_debug"("PASS", "postfix:sym<-->", " at pos=", rx1361_pos)
  debug_1143:
    .return (rx1361_cur)
  rx1361_restart:
.annotate 'line', 10
    if_null rx1361_debug, debug_1144
    rx1361_cur."!cursor_debug"("NEXT", "postfix:sym<-->")
  debug_1144:
  rx1361_fail:
    (rx1361_rep, rx1361_pos, $I10, $P10) = rx1361_cur."!mark_fail"(0)
    lt rx1361_pos, -1, rx1361_done
    eq rx1361_pos, -1, rx1361_fail
    jump $I10
  rx1361_done:
    rx1361_cur."!cursor_fail"()
    if_null rx1361_debug, debug_1145
    rx1361_cur."!cursor_debug"("FAIL", "postfix:sym<-->")
  debug_1145:
    .return (rx1361_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<-->"  :nsentry("!PREFIX__postfix:sym<-->") :subid("293_1300062003.824") :method
.annotate 'line', 10
    $P1363 = self."!PREFIX__!subrule"("O", "--")
    new $P1364, "ResizablePMCArray"
    push $P1364, $P1363
    .return ($P1364)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<**>"  :subid("294_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1368_tgt
    .local int rx1368_pos
    .local int rx1368_off
    .local int rx1368_eos
    .local int rx1368_rep
    .local pmc rx1368_cur
    .local pmc rx1368_debug
    (rx1368_cur, rx1368_pos, rx1368_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1368_cur
    .local pmc match
    .lex "$/", match
    length rx1368_eos, rx1368_tgt
    gt rx1368_pos, rx1368_eos, rx1368_done
    set rx1368_off, 0
    lt rx1368_pos, 2, rx1368_start
    sub rx1368_off, rx1368_pos, 1
    substr rx1368_tgt, rx1368_tgt, rx1368_off
  rx1368_start:
    eq $I10, 1, rx1368_restart
    if_null rx1368_debug, debug_1146
    rx1368_cur."!cursor_debug"("START", "infix:sym<**>")
  debug_1146:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1372_done
    goto rxscan1372_scan
  rxscan1372_loop:
    (rx1368_pos) = rx1368_cur."from"()
    inc rx1368_pos
    rx1368_cur."!cursor_from"(rx1368_pos)
    ge rx1368_pos, rx1368_eos, rxscan1372_done
  rxscan1372_scan:
    set_addr $I10, rxscan1372_loop
    rx1368_cur."!mark_push"(0, rx1368_pos, $I10)
  rxscan1372_done:
.annotate 'line', 629
  # rx subcapture "sym"
    set_addr $I10, rxcap_1373_fail
    rx1368_cur."!mark_push"(0, rx1368_pos, $I10)
  # rx literal  "**"
    add $I11, rx1368_pos, 2
    gt $I11, rx1368_eos, rx1368_fail
    sub $I11, rx1368_pos, rx1368_off
    substr $S10, rx1368_tgt, $I11, 2
    ne $S10, "**", rx1368_fail
    add rx1368_pos, 2
    set_addr $I10, rxcap_1373_fail
    ($I12, $I11) = rx1368_cur."!mark_peek"($I10)
    rx1368_cur."!cursor_pos"($I11)
    ($P10) = rx1368_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1368_pos, "")
    rx1368_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1373_done
  rxcap_1373_fail:
    goto rx1368_fail
  rxcap_1373_done:
  # rx subrule "O" subtype=capture negate=
    rx1368_cur."!cursor_pos"(rx1368_pos)
    $P10 = rx1368_cur."O"("%exponentiation, :pirop<pow>")
    unless $P10, rx1368_fail
    rx1368_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1368_pos = $P10."pos"()
  # rx pass
    rx1368_cur."!cursor_pass"(rx1368_pos, "infix:sym<**>")
    if_null rx1368_debug, debug_1147
    rx1368_cur."!cursor_debug"("PASS", "infix:sym<**>", " at pos=", rx1368_pos)
  debug_1147:
    .return (rx1368_cur)
  rx1368_restart:
.annotate 'line', 10
    if_null rx1368_debug, debug_1148
    rx1368_cur."!cursor_debug"("NEXT", "infix:sym<**>")
  debug_1148:
  rx1368_fail:
    (rx1368_rep, rx1368_pos, $I10, $P10) = rx1368_cur."!mark_fail"(0)
    lt rx1368_pos, -1, rx1368_done
    eq rx1368_pos, -1, rx1368_fail
    jump $I10
  rx1368_done:
    rx1368_cur."!cursor_fail"()
    if_null rx1368_debug, debug_1149
    rx1368_cur."!cursor_debug"("FAIL", "infix:sym<**>")
  debug_1149:
    .return (rx1368_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<**>"  :nsentry("!PREFIX__infix:sym<**>") :subid("295_1300062003.824") :method
.annotate 'line', 10
    $P1370 = self."!PREFIX__!subrule"("O", "**")
    new $P1371, "ResizablePMCArray"
    push $P1371, $P1370
    .return ($P1371)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<+>"  :subid("296_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1375_tgt
    .local int rx1375_pos
    .local int rx1375_off
    .local int rx1375_eos
    .local int rx1375_rep
    .local pmc rx1375_cur
    .local pmc rx1375_debug
    (rx1375_cur, rx1375_pos, rx1375_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1375_cur
    .local pmc match
    .lex "$/", match
    length rx1375_eos, rx1375_tgt
    gt rx1375_pos, rx1375_eos, rx1375_done
    set rx1375_off, 0
    lt rx1375_pos, 2, rx1375_start
    sub rx1375_off, rx1375_pos, 1
    substr rx1375_tgt, rx1375_tgt, rx1375_off
  rx1375_start:
    eq $I10, 1, rx1375_restart
    if_null rx1375_debug, debug_1150
    rx1375_cur."!cursor_debug"("START", "prefix:sym<+>")
  debug_1150:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1379_done
    goto rxscan1379_scan
  rxscan1379_loop:
    (rx1375_pos) = rx1375_cur."from"()
    inc rx1375_pos
    rx1375_cur."!cursor_from"(rx1375_pos)
    ge rx1375_pos, rx1375_eos, rxscan1379_done
  rxscan1379_scan:
    set_addr $I10, rxscan1379_loop
    rx1375_cur."!mark_push"(0, rx1375_pos, $I10)
  rxscan1379_done:
.annotate 'line', 631
  # rx subcapture "sym"
    set_addr $I10, rxcap_1380_fail
    rx1375_cur."!mark_push"(0, rx1375_pos, $I10)
  # rx literal  "+"
    add $I11, rx1375_pos, 1
    gt $I11, rx1375_eos, rx1375_fail
    sub $I11, rx1375_pos, rx1375_off
    ord $I11, rx1375_tgt, $I11
    ne $I11, 43, rx1375_fail
    add rx1375_pos, 1
    set_addr $I10, rxcap_1380_fail
    ($I12, $I11) = rx1375_cur."!mark_peek"($I10)
    rx1375_cur."!cursor_pos"($I11)
    ($P10) = rx1375_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1375_pos, "")
    rx1375_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1380_done
  rxcap_1380_fail:
    goto rx1375_fail
  rxcap_1380_done:
  # rx subrule "O" subtype=capture negate=
    rx1375_cur."!cursor_pos"(rx1375_pos)
    $P10 = rx1375_cur."O"("%symbolic_unary, :pirop<set N*>")
    unless $P10, rx1375_fail
    rx1375_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1375_pos = $P10."pos"()
  # rx pass
    rx1375_cur."!cursor_pass"(rx1375_pos, "prefix:sym<+>")
    if_null rx1375_debug, debug_1151
    rx1375_cur."!cursor_debug"("PASS", "prefix:sym<+>", " at pos=", rx1375_pos)
  debug_1151:
    .return (rx1375_cur)
  rx1375_restart:
.annotate 'line', 10
    if_null rx1375_debug, debug_1152
    rx1375_cur."!cursor_debug"("NEXT", "prefix:sym<+>")
  debug_1152:
  rx1375_fail:
    (rx1375_rep, rx1375_pos, $I10, $P10) = rx1375_cur."!mark_fail"(0)
    lt rx1375_pos, -1, rx1375_done
    eq rx1375_pos, -1, rx1375_fail
    jump $I10
  rx1375_done:
    rx1375_cur."!cursor_fail"()
    if_null rx1375_debug, debug_1153
    rx1375_cur."!cursor_debug"("FAIL", "prefix:sym<+>")
  debug_1153:
    .return (rx1375_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<+>"  :nsentry("!PREFIX__prefix:sym<+>") :subid("297_1300062003.824") :method
.annotate 'line', 10
    $P1377 = self."!PREFIX__!subrule"("O", "+")
    new $P1378, "ResizablePMCArray"
    push $P1378, $P1377
    .return ($P1378)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<~>"  :subid("298_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1382_tgt
    .local int rx1382_pos
    .local int rx1382_off
    .local int rx1382_eos
    .local int rx1382_rep
    .local pmc rx1382_cur
    .local pmc rx1382_debug
    (rx1382_cur, rx1382_pos, rx1382_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1382_cur
    .local pmc match
    .lex "$/", match
    length rx1382_eos, rx1382_tgt
    gt rx1382_pos, rx1382_eos, rx1382_done
    set rx1382_off, 0
    lt rx1382_pos, 2, rx1382_start
    sub rx1382_off, rx1382_pos, 1
    substr rx1382_tgt, rx1382_tgt, rx1382_off
  rx1382_start:
    eq $I10, 1, rx1382_restart
    if_null rx1382_debug, debug_1154
    rx1382_cur."!cursor_debug"("START", "prefix:sym<~>")
  debug_1154:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1386_done
    goto rxscan1386_scan
  rxscan1386_loop:
    (rx1382_pos) = rx1382_cur."from"()
    inc rx1382_pos
    rx1382_cur."!cursor_from"(rx1382_pos)
    ge rx1382_pos, rx1382_eos, rxscan1386_done
  rxscan1386_scan:
    set_addr $I10, rxscan1386_loop
    rx1382_cur."!mark_push"(0, rx1382_pos, $I10)
  rxscan1386_done:
.annotate 'line', 632
  # rx subcapture "sym"
    set_addr $I10, rxcap_1387_fail
    rx1382_cur."!mark_push"(0, rx1382_pos, $I10)
  # rx literal  "~"
    add $I11, rx1382_pos, 1
    gt $I11, rx1382_eos, rx1382_fail
    sub $I11, rx1382_pos, rx1382_off
    ord $I11, rx1382_tgt, $I11
    ne $I11, 126, rx1382_fail
    add rx1382_pos, 1
    set_addr $I10, rxcap_1387_fail
    ($I12, $I11) = rx1382_cur."!mark_peek"($I10)
    rx1382_cur."!cursor_pos"($I11)
    ($P10) = rx1382_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1382_pos, "")
    rx1382_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1387_done
  rxcap_1387_fail:
    goto rx1382_fail
  rxcap_1387_done:
  # rx subrule "O" subtype=capture negate=
    rx1382_cur."!cursor_pos"(rx1382_pos)
    $P10 = rx1382_cur."O"("%symbolic_unary, :pirop<set S*>")
    unless $P10, rx1382_fail
    rx1382_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1382_pos = $P10."pos"()
  # rx pass
    rx1382_cur."!cursor_pass"(rx1382_pos, "prefix:sym<~>")
    if_null rx1382_debug, debug_1155
    rx1382_cur."!cursor_debug"("PASS", "prefix:sym<~>", " at pos=", rx1382_pos)
  debug_1155:
    .return (rx1382_cur)
  rx1382_restart:
.annotate 'line', 10
    if_null rx1382_debug, debug_1156
    rx1382_cur."!cursor_debug"("NEXT", "prefix:sym<~>")
  debug_1156:
  rx1382_fail:
    (rx1382_rep, rx1382_pos, $I10, $P10) = rx1382_cur."!mark_fail"(0)
    lt rx1382_pos, -1, rx1382_done
    eq rx1382_pos, -1, rx1382_fail
    jump $I10
  rx1382_done:
    rx1382_cur."!cursor_fail"()
    if_null rx1382_debug, debug_1157
    rx1382_cur."!cursor_debug"("FAIL", "prefix:sym<~>")
  debug_1157:
    .return (rx1382_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<~>"  :nsentry("!PREFIX__prefix:sym<~>") :subid("299_1300062003.824") :method
.annotate 'line', 10
    $P1384 = self."!PREFIX__!subrule"("O", "~")
    new $P1385, "ResizablePMCArray"
    push $P1385, $P1384
    .return ($P1385)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<->"  :subid("300_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1389_tgt
    .local int rx1389_pos
    .local int rx1389_off
    .local int rx1389_eos
    .local int rx1389_rep
    .local pmc rx1389_cur
    .local pmc rx1389_debug
    (rx1389_cur, rx1389_pos, rx1389_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1389_cur
    .local pmc match
    .lex "$/", match
    length rx1389_eos, rx1389_tgt
    gt rx1389_pos, rx1389_eos, rx1389_done
    set rx1389_off, 0
    lt rx1389_pos, 2, rx1389_start
    sub rx1389_off, rx1389_pos, 1
    substr rx1389_tgt, rx1389_tgt, rx1389_off
  rx1389_start:
    eq $I10, 1, rx1389_restart
    if_null rx1389_debug, debug_1158
    rx1389_cur."!cursor_debug"("START", "prefix:sym<->")
  debug_1158:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1392_done
    goto rxscan1392_scan
  rxscan1392_loop:
    (rx1389_pos) = rx1389_cur."from"()
    inc rx1389_pos
    rx1389_cur."!cursor_from"(rx1389_pos)
    ge rx1389_pos, rx1389_eos, rxscan1392_done
  rxscan1392_scan:
    set_addr $I10, rxscan1392_loop
    rx1389_cur."!mark_push"(0, rx1389_pos, $I10)
  rxscan1392_done:
.annotate 'line', 633
  # rx subcapture "sym"
    set_addr $I10, rxcap_1393_fail
    rx1389_cur."!mark_push"(0, rx1389_pos, $I10)
  # rx literal  "-"
    add $I11, rx1389_pos, 1
    gt $I11, rx1389_eos, rx1389_fail
    sub $I11, rx1389_pos, rx1389_off
    ord $I11, rx1389_tgt, $I11
    ne $I11, 45, rx1389_fail
    add rx1389_pos, 1
    set_addr $I10, rxcap_1393_fail
    ($I12, $I11) = rx1389_cur."!mark_peek"($I10)
    rx1389_cur."!cursor_pos"($I11)
    ($P10) = rx1389_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1389_pos, "")
    rx1389_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1393_done
  rxcap_1393_fail:
    goto rx1389_fail
  rxcap_1393_done:
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1389_pos, rx1389_off
    substr $S10, rx1389_tgt, $I10, 1
    index $I11, ">", $S10
    ge $I11, 0, rx1389_fail
  # rx subrule "number" subtype=zerowidth negate=1
    rx1389_cur."!cursor_pos"(rx1389_pos)
    $P10 = rx1389_cur."number"()
    if $P10, rx1389_fail
  # rx subrule "O" subtype=capture negate=
    rx1389_cur."!cursor_pos"(rx1389_pos)
    $P10 = rx1389_cur."O"("%symbolic_unary, :pirop<neg>")
    unless $P10, rx1389_fail
    rx1389_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1389_pos = $P10."pos"()
  # rx pass
    rx1389_cur."!cursor_pass"(rx1389_pos, "prefix:sym<->")
    if_null rx1389_debug, debug_1159
    rx1389_cur."!cursor_debug"("PASS", "prefix:sym<->", " at pos=", rx1389_pos)
  debug_1159:
    .return (rx1389_cur)
  rx1389_restart:
.annotate 'line', 10
    if_null rx1389_debug, debug_1160
    rx1389_cur."!cursor_debug"("NEXT", "prefix:sym<->")
  debug_1160:
  rx1389_fail:
    (rx1389_rep, rx1389_pos, $I10, $P10) = rx1389_cur."!mark_fail"(0)
    lt rx1389_pos, -1, rx1389_done
    eq rx1389_pos, -1, rx1389_fail
    jump $I10
  rx1389_done:
    rx1389_cur."!cursor_fail"()
    if_null rx1389_debug, debug_1161
    rx1389_cur."!cursor_debug"("FAIL", "prefix:sym<->")
  debug_1161:
    .return (rx1389_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<->"  :nsentry("!PREFIX__prefix:sym<->") :subid("301_1300062003.824") :method
.annotate 'line', 10
    new $P1391, "ResizablePMCArray"
    push $P1391, "-"
    .return ($P1391)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<?>"  :subid("302_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1395_tgt
    .local int rx1395_pos
    .local int rx1395_off
    .local int rx1395_eos
    .local int rx1395_rep
    .local pmc rx1395_cur
    .local pmc rx1395_debug
    (rx1395_cur, rx1395_pos, rx1395_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1395_cur
    .local pmc match
    .lex "$/", match
    length rx1395_eos, rx1395_tgt
    gt rx1395_pos, rx1395_eos, rx1395_done
    set rx1395_off, 0
    lt rx1395_pos, 2, rx1395_start
    sub rx1395_off, rx1395_pos, 1
    substr rx1395_tgt, rx1395_tgt, rx1395_off
  rx1395_start:
    eq $I10, 1, rx1395_restart
    if_null rx1395_debug, debug_1162
    rx1395_cur."!cursor_debug"("START", "prefix:sym<?>")
  debug_1162:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1399_done
    goto rxscan1399_scan
  rxscan1399_loop:
    (rx1395_pos) = rx1395_cur."from"()
    inc rx1395_pos
    rx1395_cur."!cursor_from"(rx1395_pos)
    ge rx1395_pos, rx1395_eos, rxscan1399_done
  rxscan1399_scan:
    set_addr $I10, rxscan1399_loop
    rx1395_cur."!mark_push"(0, rx1395_pos, $I10)
  rxscan1399_done:
.annotate 'line', 634
  # rx subcapture "sym"
    set_addr $I10, rxcap_1400_fail
    rx1395_cur."!mark_push"(0, rx1395_pos, $I10)
  # rx literal  "?"
    add $I11, rx1395_pos, 1
    gt $I11, rx1395_eos, rx1395_fail
    sub $I11, rx1395_pos, rx1395_off
    ord $I11, rx1395_tgt, $I11
    ne $I11, 63, rx1395_fail
    add rx1395_pos, 1
    set_addr $I10, rxcap_1400_fail
    ($I12, $I11) = rx1395_cur."!mark_peek"($I10)
    rx1395_cur."!cursor_pos"($I11)
    ($P10) = rx1395_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1395_pos, "")
    rx1395_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1400_done
  rxcap_1400_fail:
    goto rx1395_fail
  rxcap_1400_done:
  # rx subrule "O" subtype=capture negate=
    rx1395_cur."!cursor_pos"(rx1395_pos)
    $P10 = rx1395_cur."O"("%symbolic_unary, :pirop<istrue>")
    unless $P10, rx1395_fail
    rx1395_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1395_pos = $P10."pos"()
  # rx pass
    rx1395_cur."!cursor_pass"(rx1395_pos, "prefix:sym<?>")
    if_null rx1395_debug, debug_1163
    rx1395_cur."!cursor_debug"("PASS", "prefix:sym<?>", " at pos=", rx1395_pos)
  debug_1163:
    .return (rx1395_cur)
  rx1395_restart:
.annotate 'line', 10
    if_null rx1395_debug, debug_1164
    rx1395_cur."!cursor_debug"("NEXT", "prefix:sym<?>")
  debug_1164:
  rx1395_fail:
    (rx1395_rep, rx1395_pos, $I10, $P10) = rx1395_cur."!mark_fail"(0)
    lt rx1395_pos, -1, rx1395_done
    eq rx1395_pos, -1, rx1395_fail
    jump $I10
  rx1395_done:
    rx1395_cur."!cursor_fail"()
    if_null rx1395_debug, debug_1165
    rx1395_cur."!cursor_debug"("FAIL", "prefix:sym<?>")
  debug_1165:
    .return (rx1395_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<?>"  :nsentry("!PREFIX__prefix:sym<?>") :subid("303_1300062003.824") :method
.annotate 'line', 10
    $P1397 = self."!PREFIX__!subrule"("O", "?")
    new $P1398, "ResizablePMCArray"
    push $P1398, $P1397
    .return ($P1398)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<!>"  :subid("304_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1402_tgt
    .local int rx1402_pos
    .local int rx1402_off
    .local int rx1402_eos
    .local int rx1402_rep
    .local pmc rx1402_cur
    .local pmc rx1402_debug
    (rx1402_cur, rx1402_pos, rx1402_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1402_cur
    .local pmc match
    .lex "$/", match
    length rx1402_eos, rx1402_tgt
    gt rx1402_pos, rx1402_eos, rx1402_done
    set rx1402_off, 0
    lt rx1402_pos, 2, rx1402_start
    sub rx1402_off, rx1402_pos, 1
    substr rx1402_tgt, rx1402_tgt, rx1402_off
  rx1402_start:
    eq $I10, 1, rx1402_restart
    if_null rx1402_debug, debug_1166
    rx1402_cur."!cursor_debug"("START", "prefix:sym<!>")
  debug_1166:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1406_done
    goto rxscan1406_scan
  rxscan1406_loop:
    (rx1402_pos) = rx1402_cur."from"()
    inc rx1402_pos
    rx1402_cur."!cursor_from"(rx1402_pos)
    ge rx1402_pos, rx1402_eos, rxscan1406_done
  rxscan1406_scan:
    set_addr $I10, rxscan1406_loop
    rx1402_cur."!mark_push"(0, rx1402_pos, $I10)
  rxscan1406_done:
.annotate 'line', 635
  # rx subcapture "sym"
    set_addr $I10, rxcap_1407_fail
    rx1402_cur."!mark_push"(0, rx1402_pos, $I10)
  # rx literal  "!"
    add $I11, rx1402_pos, 1
    gt $I11, rx1402_eos, rx1402_fail
    sub $I11, rx1402_pos, rx1402_off
    ord $I11, rx1402_tgt, $I11
    ne $I11, 33, rx1402_fail
    add rx1402_pos, 1
    set_addr $I10, rxcap_1407_fail
    ($I12, $I11) = rx1402_cur."!mark_peek"($I10)
    rx1402_cur."!cursor_pos"($I11)
    ($P10) = rx1402_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1402_pos, "")
    rx1402_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1407_done
  rxcap_1407_fail:
    goto rx1402_fail
  rxcap_1407_done:
  # rx subrule "O" subtype=capture negate=
    rx1402_cur."!cursor_pos"(rx1402_pos)
    $P10 = rx1402_cur."O"("%symbolic_unary, :pirop<isfalse>")
    unless $P10, rx1402_fail
    rx1402_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1402_pos = $P10."pos"()
  # rx pass
    rx1402_cur."!cursor_pass"(rx1402_pos, "prefix:sym<!>")
    if_null rx1402_debug, debug_1167
    rx1402_cur."!cursor_debug"("PASS", "prefix:sym<!>", " at pos=", rx1402_pos)
  debug_1167:
    .return (rx1402_cur)
  rx1402_restart:
.annotate 'line', 10
    if_null rx1402_debug, debug_1168
    rx1402_cur."!cursor_debug"("NEXT", "prefix:sym<!>")
  debug_1168:
  rx1402_fail:
    (rx1402_rep, rx1402_pos, $I10, $P10) = rx1402_cur."!mark_fail"(0)
    lt rx1402_pos, -1, rx1402_done
    eq rx1402_pos, -1, rx1402_fail
    jump $I10
  rx1402_done:
    rx1402_cur."!cursor_fail"()
    if_null rx1402_debug, debug_1169
    rx1402_cur."!cursor_debug"("FAIL", "prefix:sym<!>")
  debug_1169:
    .return (rx1402_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<!>"  :nsentry("!PREFIX__prefix:sym<!>") :subid("305_1300062003.824") :method
.annotate 'line', 10
    $P1404 = self."!PREFIX__!subrule"("O", "!")
    new $P1405, "ResizablePMCArray"
    push $P1405, $P1404
    .return ($P1405)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<|>"  :subid("306_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1409_tgt
    .local int rx1409_pos
    .local int rx1409_off
    .local int rx1409_eos
    .local int rx1409_rep
    .local pmc rx1409_cur
    .local pmc rx1409_debug
    (rx1409_cur, rx1409_pos, rx1409_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1409_cur
    .local pmc match
    .lex "$/", match
    length rx1409_eos, rx1409_tgt
    gt rx1409_pos, rx1409_eos, rx1409_done
    set rx1409_off, 0
    lt rx1409_pos, 2, rx1409_start
    sub rx1409_off, rx1409_pos, 1
    substr rx1409_tgt, rx1409_tgt, rx1409_off
  rx1409_start:
    eq $I10, 1, rx1409_restart
    if_null rx1409_debug, debug_1170
    rx1409_cur."!cursor_debug"("START", "prefix:sym<|>")
  debug_1170:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1413_done
    goto rxscan1413_scan
  rxscan1413_loop:
    (rx1409_pos) = rx1409_cur."from"()
    inc rx1409_pos
    rx1409_cur."!cursor_from"(rx1409_pos)
    ge rx1409_pos, rx1409_eos, rxscan1413_done
  rxscan1413_scan:
    set_addr $I10, rxscan1413_loop
    rx1409_cur."!mark_push"(0, rx1409_pos, $I10)
  rxscan1413_done:
.annotate 'line', 636
  # rx subcapture "sym"
    set_addr $I10, rxcap_1414_fail
    rx1409_cur."!mark_push"(0, rx1409_pos, $I10)
  # rx literal  "|"
    add $I11, rx1409_pos, 1
    gt $I11, rx1409_eos, rx1409_fail
    sub $I11, rx1409_pos, rx1409_off
    ord $I11, rx1409_tgt, $I11
    ne $I11, 124, rx1409_fail
    add rx1409_pos, 1
    set_addr $I10, rxcap_1414_fail
    ($I12, $I11) = rx1409_cur."!mark_peek"($I10)
    rx1409_cur."!cursor_pos"($I11)
    ($P10) = rx1409_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1409_pos, "")
    rx1409_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1414_done
  rxcap_1414_fail:
    goto rx1409_fail
  rxcap_1414_done:
  # rx subrule "O" subtype=capture negate=
    rx1409_cur."!cursor_pos"(rx1409_pos)
    $P10 = rx1409_cur."O"("%symbolic_unary")
    unless $P10, rx1409_fail
    rx1409_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1409_pos = $P10."pos"()
  # rx pass
    rx1409_cur."!cursor_pass"(rx1409_pos, "prefix:sym<|>")
    if_null rx1409_debug, debug_1171
    rx1409_cur."!cursor_debug"("PASS", "prefix:sym<|>", " at pos=", rx1409_pos)
  debug_1171:
    .return (rx1409_cur)
  rx1409_restart:
.annotate 'line', 10
    if_null rx1409_debug, debug_1172
    rx1409_cur."!cursor_debug"("NEXT", "prefix:sym<|>")
  debug_1172:
  rx1409_fail:
    (rx1409_rep, rx1409_pos, $I10, $P10) = rx1409_cur."!mark_fail"(0)
    lt rx1409_pos, -1, rx1409_done
    eq rx1409_pos, -1, rx1409_fail
    jump $I10
  rx1409_done:
    rx1409_cur."!cursor_fail"()
    if_null rx1409_debug, debug_1173
    rx1409_cur."!cursor_debug"("FAIL", "prefix:sym<|>")
  debug_1173:
    .return (rx1409_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<|>"  :nsentry("!PREFIX__prefix:sym<|>") :subid("307_1300062003.824") :method
.annotate 'line', 10
    $P1411 = self."!PREFIX__!subrule"("O", "|")
    new $P1412, "ResizablePMCArray"
    push $P1412, $P1411
    .return ($P1412)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<*>"  :subid("308_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1416_tgt
    .local int rx1416_pos
    .local int rx1416_off
    .local int rx1416_eos
    .local int rx1416_rep
    .local pmc rx1416_cur
    .local pmc rx1416_debug
    (rx1416_cur, rx1416_pos, rx1416_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1416_cur
    .local pmc match
    .lex "$/", match
    length rx1416_eos, rx1416_tgt
    gt rx1416_pos, rx1416_eos, rx1416_done
    set rx1416_off, 0
    lt rx1416_pos, 2, rx1416_start
    sub rx1416_off, rx1416_pos, 1
    substr rx1416_tgt, rx1416_tgt, rx1416_off
  rx1416_start:
    eq $I10, 1, rx1416_restart
    if_null rx1416_debug, debug_1174
    rx1416_cur."!cursor_debug"("START", "infix:sym<*>")
  debug_1174:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1420_done
    goto rxscan1420_scan
  rxscan1420_loop:
    (rx1416_pos) = rx1416_cur."from"()
    inc rx1416_pos
    rx1416_cur."!cursor_from"(rx1416_pos)
    ge rx1416_pos, rx1416_eos, rxscan1420_done
  rxscan1420_scan:
    set_addr $I10, rxscan1420_loop
    rx1416_cur."!mark_push"(0, rx1416_pos, $I10)
  rxscan1420_done:
.annotate 'line', 638
  # rx subcapture "sym"
    set_addr $I10, rxcap_1421_fail
    rx1416_cur."!mark_push"(0, rx1416_pos, $I10)
  # rx literal  "*"
    add $I11, rx1416_pos, 1
    gt $I11, rx1416_eos, rx1416_fail
    sub $I11, rx1416_pos, rx1416_off
    ord $I11, rx1416_tgt, $I11
    ne $I11, 42, rx1416_fail
    add rx1416_pos, 1
    set_addr $I10, rxcap_1421_fail
    ($I12, $I11) = rx1416_cur."!mark_peek"($I10)
    rx1416_cur."!cursor_pos"($I11)
    ($P10) = rx1416_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1416_pos, "")
    rx1416_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1421_done
  rxcap_1421_fail:
    goto rx1416_fail
  rxcap_1421_done:
  # rx subrule "O" subtype=capture negate=
    rx1416_cur."!cursor_pos"(rx1416_pos)
    $P10 = rx1416_cur."O"("%multiplicative, :pirop<mul>")
    unless $P10, rx1416_fail
    rx1416_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1416_pos = $P10."pos"()
  # rx pass
    rx1416_cur."!cursor_pass"(rx1416_pos, "infix:sym<*>")
    if_null rx1416_debug, debug_1175
    rx1416_cur."!cursor_debug"("PASS", "infix:sym<*>", " at pos=", rx1416_pos)
  debug_1175:
    .return (rx1416_cur)
  rx1416_restart:
.annotate 'line', 10
    if_null rx1416_debug, debug_1176
    rx1416_cur."!cursor_debug"("NEXT", "infix:sym<*>")
  debug_1176:
  rx1416_fail:
    (rx1416_rep, rx1416_pos, $I10, $P10) = rx1416_cur."!mark_fail"(0)
    lt rx1416_pos, -1, rx1416_done
    eq rx1416_pos, -1, rx1416_fail
    jump $I10
  rx1416_done:
    rx1416_cur."!cursor_fail"()
    if_null rx1416_debug, debug_1177
    rx1416_cur."!cursor_debug"("FAIL", "infix:sym<*>")
  debug_1177:
    .return (rx1416_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<*>"  :nsentry("!PREFIX__infix:sym<*>") :subid("309_1300062003.824") :method
.annotate 'line', 10
    $P1418 = self."!PREFIX__!subrule"("O", "*")
    new $P1419, "ResizablePMCArray"
    push $P1419, $P1418
    .return ($P1419)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym</>"  :subid("310_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1423_tgt
    .local int rx1423_pos
    .local int rx1423_off
    .local int rx1423_eos
    .local int rx1423_rep
    .local pmc rx1423_cur
    .local pmc rx1423_debug
    (rx1423_cur, rx1423_pos, rx1423_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1423_cur
    .local pmc match
    .lex "$/", match
    length rx1423_eos, rx1423_tgt
    gt rx1423_pos, rx1423_eos, rx1423_done
    set rx1423_off, 0
    lt rx1423_pos, 2, rx1423_start
    sub rx1423_off, rx1423_pos, 1
    substr rx1423_tgt, rx1423_tgt, rx1423_off
  rx1423_start:
    eq $I10, 1, rx1423_restart
    if_null rx1423_debug, debug_1178
    rx1423_cur."!cursor_debug"("START", "infix:sym</>")
  debug_1178:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1427_done
    goto rxscan1427_scan
  rxscan1427_loop:
    (rx1423_pos) = rx1423_cur."from"()
    inc rx1423_pos
    rx1423_cur."!cursor_from"(rx1423_pos)
    ge rx1423_pos, rx1423_eos, rxscan1427_done
  rxscan1427_scan:
    set_addr $I10, rxscan1427_loop
    rx1423_cur."!mark_push"(0, rx1423_pos, $I10)
  rxscan1427_done:
.annotate 'line', 639
  # rx subcapture "sym"
    set_addr $I10, rxcap_1428_fail
    rx1423_cur."!mark_push"(0, rx1423_pos, $I10)
  # rx literal  "/"
    add $I11, rx1423_pos, 1
    gt $I11, rx1423_eos, rx1423_fail
    sub $I11, rx1423_pos, rx1423_off
    ord $I11, rx1423_tgt, $I11
    ne $I11, 47, rx1423_fail
    add rx1423_pos, 1
    set_addr $I10, rxcap_1428_fail
    ($I12, $I11) = rx1423_cur."!mark_peek"($I10)
    rx1423_cur."!cursor_pos"($I11)
    ($P10) = rx1423_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1423_pos, "")
    rx1423_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1428_done
  rxcap_1428_fail:
    goto rx1423_fail
  rxcap_1428_done:
  # rx subrule "O" subtype=capture negate=
    rx1423_cur."!cursor_pos"(rx1423_pos)
    $P10 = rx1423_cur."O"("%multiplicative, :pirop<div>")
    unless $P10, rx1423_fail
    rx1423_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1423_pos = $P10."pos"()
  # rx pass
    rx1423_cur."!cursor_pass"(rx1423_pos, "infix:sym</>")
    if_null rx1423_debug, debug_1179
    rx1423_cur."!cursor_debug"("PASS", "infix:sym</>", " at pos=", rx1423_pos)
  debug_1179:
    .return (rx1423_cur)
  rx1423_restart:
.annotate 'line', 10
    if_null rx1423_debug, debug_1180
    rx1423_cur."!cursor_debug"("NEXT", "infix:sym</>")
  debug_1180:
  rx1423_fail:
    (rx1423_rep, rx1423_pos, $I10, $P10) = rx1423_cur."!mark_fail"(0)
    lt rx1423_pos, -1, rx1423_done
    eq rx1423_pos, -1, rx1423_fail
    jump $I10
  rx1423_done:
    rx1423_cur."!cursor_fail"()
    if_null rx1423_debug, debug_1181
    rx1423_cur."!cursor_debug"("FAIL", "infix:sym</>")
  debug_1181:
    .return (rx1423_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym</>"  :nsentry("!PREFIX__infix:sym</>") :subid("311_1300062003.824") :method
.annotate 'line', 10
    $P1425 = self."!PREFIX__!subrule"("O", "/")
    new $P1426, "ResizablePMCArray"
    push $P1426, $P1425
    .return ($P1426)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<%>"  :subid("312_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1430_tgt
    .local int rx1430_pos
    .local int rx1430_off
    .local int rx1430_eos
    .local int rx1430_rep
    .local pmc rx1430_cur
    .local pmc rx1430_debug
    (rx1430_cur, rx1430_pos, rx1430_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1430_cur
    .local pmc match
    .lex "$/", match
    length rx1430_eos, rx1430_tgt
    gt rx1430_pos, rx1430_eos, rx1430_done
    set rx1430_off, 0
    lt rx1430_pos, 2, rx1430_start
    sub rx1430_off, rx1430_pos, 1
    substr rx1430_tgt, rx1430_tgt, rx1430_off
  rx1430_start:
    eq $I10, 1, rx1430_restart
    if_null rx1430_debug, debug_1182
    rx1430_cur."!cursor_debug"("START", "infix:sym<%>")
  debug_1182:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1434_done
    goto rxscan1434_scan
  rxscan1434_loop:
    (rx1430_pos) = rx1430_cur."from"()
    inc rx1430_pos
    rx1430_cur."!cursor_from"(rx1430_pos)
    ge rx1430_pos, rx1430_eos, rxscan1434_done
  rxscan1434_scan:
    set_addr $I10, rxscan1434_loop
    rx1430_cur."!mark_push"(0, rx1430_pos, $I10)
  rxscan1434_done:
.annotate 'line', 640
  # rx subcapture "sym"
    set_addr $I10, rxcap_1435_fail
    rx1430_cur."!mark_push"(0, rx1430_pos, $I10)
  # rx literal  "%"
    add $I11, rx1430_pos, 1
    gt $I11, rx1430_eos, rx1430_fail
    sub $I11, rx1430_pos, rx1430_off
    ord $I11, rx1430_tgt, $I11
    ne $I11, 37, rx1430_fail
    add rx1430_pos, 1
    set_addr $I10, rxcap_1435_fail
    ($I12, $I11) = rx1430_cur."!mark_peek"($I10)
    rx1430_cur."!cursor_pos"($I11)
    ($P10) = rx1430_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1430_pos, "")
    rx1430_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1435_done
  rxcap_1435_fail:
    goto rx1430_fail
  rxcap_1435_done:
  # rx subrule "O" subtype=capture negate=
    rx1430_cur."!cursor_pos"(rx1430_pos)
    $P10 = rx1430_cur."O"("%multiplicative, :pirop<mod>")
    unless $P10, rx1430_fail
    rx1430_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1430_pos = $P10."pos"()
  # rx pass
    rx1430_cur."!cursor_pass"(rx1430_pos, "infix:sym<%>")
    if_null rx1430_debug, debug_1183
    rx1430_cur."!cursor_debug"("PASS", "infix:sym<%>", " at pos=", rx1430_pos)
  debug_1183:
    .return (rx1430_cur)
  rx1430_restart:
.annotate 'line', 10
    if_null rx1430_debug, debug_1184
    rx1430_cur."!cursor_debug"("NEXT", "infix:sym<%>")
  debug_1184:
  rx1430_fail:
    (rx1430_rep, rx1430_pos, $I10, $P10) = rx1430_cur."!mark_fail"(0)
    lt rx1430_pos, -1, rx1430_done
    eq rx1430_pos, -1, rx1430_fail
    jump $I10
  rx1430_done:
    rx1430_cur."!cursor_fail"()
    if_null rx1430_debug, debug_1185
    rx1430_cur."!cursor_debug"("FAIL", "infix:sym<%>")
  debug_1185:
    .return (rx1430_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<%>"  :nsentry("!PREFIX__infix:sym<%>") :subid("313_1300062003.824") :method
.annotate 'line', 10
    $P1432 = self."!PREFIX__!subrule"("O", "%")
    new $P1433, "ResizablePMCArray"
    push $P1433, $P1432
    .return ($P1433)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+&>"  :subid("314_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1437_tgt
    .local int rx1437_pos
    .local int rx1437_off
    .local int rx1437_eos
    .local int rx1437_rep
    .local pmc rx1437_cur
    .local pmc rx1437_debug
    (rx1437_cur, rx1437_pos, rx1437_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1437_cur
    .local pmc match
    .lex "$/", match
    length rx1437_eos, rx1437_tgt
    gt rx1437_pos, rx1437_eos, rx1437_done
    set rx1437_off, 0
    lt rx1437_pos, 2, rx1437_start
    sub rx1437_off, rx1437_pos, 1
    substr rx1437_tgt, rx1437_tgt, rx1437_off
  rx1437_start:
    eq $I10, 1, rx1437_restart
    if_null rx1437_debug, debug_1186
    rx1437_cur."!cursor_debug"("START", "infix:sym<+&>")
  debug_1186:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1441_done
    goto rxscan1441_scan
  rxscan1441_loop:
    (rx1437_pos) = rx1437_cur."from"()
    inc rx1437_pos
    rx1437_cur."!cursor_from"(rx1437_pos)
    ge rx1437_pos, rx1437_eos, rxscan1441_done
  rxscan1441_scan:
    set_addr $I10, rxscan1441_loop
    rx1437_cur."!mark_push"(0, rx1437_pos, $I10)
  rxscan1441_done:
.annotate 'line', 641
  # rx subcapture "sym"
    set_addr $I10, rxcap_1442_fail
    rx1437_cur."!mark_push"(0, rx1437_pos, $I10)
  # rx literal  "+&"
    add $I11, rx1437_pos, 2
    gt $I11, rx1437_eos, rx1437_fail
    sub $I11, rx1437_pos, rx1437_off
    substr $S10, rx1437_tgt, $I11, 2
    ne $S10, "+&", rx1437_fail
    add rx1437_pos, 2
    set_addr $I10, rxcap_1442_fail
    ($I12, $I11) = rx1437_cur."!mark_peek"($I10)
    rx1437_cur."!cursor_pos"($I11)
    ($P10) = rx1437_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1437_pos, "")
    rx1437_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1442_done
  rxcap_1442_fail:
    goto rx1437_fail
  rxcap_1442_done:
  # rx subrule "O" subtype=capture negate=
    rx1437_cur."!cursor_pos"(rx1437_pos)
    $P10 = rx1437_cur."O"("%multiplicative, :pirop<band III>")
    unless $P10, rx1437_fail
    rx1437_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1437_pos = $P10."pos"()
  # rx pass
    rx1437_cur."!cursor_pass"(rx1437_pos, "infix:sym<+&>")
    if_null rx1437_debug, debug_1187
    rx1437_cur."!cursor_debug"("PASS", "infix:sym<+&>", " at pos=", rx1437_pos)
  debug_1187:
    .return (rx1437_cur)
  rx1437_restart:
.annotate 'line', 10
    if_null rx1437_debug, debug_1188
    rx1437_cur."!cursor_debug"("NEXT", "infix:sym<+&>")
  debug_1188:
  rx1437_fail:
    (rx1437_rep, rx1437_pos, $I10, $P10) = rx1437_cur."!mark_fail"(0)
    lt rx1437_pos, -1, rx1437_done
    eq rx1437_pos, -1, rx1437_fail
    jump $I10
  rx1437_done:
    rx1437_cur."!cursor_fail"()
    if_null rx1437_debug, debug_1189
    rx1437_cur."!cursor_debug"("FAIL", "infix:sym<+&>")
  debug_1189:
    .return (rx1437_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+&>"  :nsentry("!PREFIX__infix:sym<+&>") :subid("315_1300062003.824") :method
.annotate 'line', 10
    $P1439 = self."!PREFIX__!subrule"("O", "+&")
    new $P1440, "ResizablePMCArray"
    push $P1440, $P1439
    .return ($P1440)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+>"  :subid("316_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1444_tgt
    .local int rx1444_pos
    .local int rx1444_off
    .local int rx1444_eos
    .local int rx1444_rep
    .local pmc rx1444_cur
    .local pmc rx1444_debug
    (rx1444_cur, rx1444_pos, rx1444_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1444_cur
    .local pmc match
    .lex "$/", match
    length rx1444_eos, rx1444_tgt
    gt rx1444_pos, rx1444_eos, rx1444_done
    set rx1444_off, 0
    lt rx1444_pos, 2, rx1444_start
    sub rx1444_off, rx1444_pos, 1
    substr rx1444_tgt, rx1444_tgt, rx1444_off
  rx1444_start:
    eq $I10, 1, rx1444_restart
    if_null rx1444_debug, debug_1190
    rx1444_cur."!cursor_debug"("START", "infix:sym<+>")
  debug_1190:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1448_done
    goto rxscan1448_scan
  rxscan1448_loop:
    (rx1444_pos) = rx1444_cur."from"()
    inc rx1444_pos
    rx1444_cur."!cursor_from"(rx1444_pos)
    ge rx1444_pos, rx1444_eos, rxscan1448_done
  rxscan1448_scan:
    set_addr $I10, rxscan1448_loop
    rx1444_cur."!mark_push"(0, rx1444_pos, $I10)
  rxscan1448_done:
.annotate 'line', 643
  # rx subcapture "sym"
    set_addr $I10, rxcap_1449_fail
    rx1444_cur."!mark_push"(0, rx1444_pos, $I10)
  # rx literal  "+"
    add $I11, rx1444_pos, 1
    gt $I11, rx1444_eos, rx1444_fail
    sub $I11, rx1444_pos, rx1444_off
    ord $I11, rx1444_tgt, $I11
    ne $I11, 43, rx1444_fail
    add rx1444_pos, 1
    set_addr $I10, rxcap_1449_fail
    ($I12, $I11) = rx1444_cur."!mark_peek"($I10)
    rx1444_cur."!cursor_pos"($I11)
    ($P10) = rx1444_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1444_pos, "")
    rx1444_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1449_done
  rxcap_1449_fail:
    goto rx1444_fail
  rxcap_1449_done:
  # rx subrule "O" subtype=capture negate=
    rx1444_cur."!cursor_pos"(rx1444_pos)
    $P10 = rx1444_cur."O"("%additive, :pirop<add>")
    unless $P10, rx1444_fail
    rx1444_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1444_pos = $P10."pos"()
  # rx pass
    rx1444_cur."!cursor_pass"(rx1444_pos, "infix:sym<+>")
    if_null rx1444_debug, debug_1191
    rx1444_cur."!cursor_debug"("PASS", "infix:sym<+>", " at pos=", rx1444_pos)
  debug_1191:
    .return (rx1444_cur)
  rx1444_restart:
.annotate 'line', 10
    if_null rx1444_debug, debug_1192
    rx1444_cur."!cursor_debug"("NEXT", "infix:sym<+>")
  debug_1192:
  rx1444_fail:
    (rx1444_rep, rx1444_pos, $I10, $P10) = rx1444_cur."!mark_fail"(0)
    lt rx1444_pos, -1, rx1444_done
    eq rx1444_pos, -1, rx1444_fail
    jump $I10
  rx1444_done:
    rx1444_cur."!cursor_fail"()
    if_null rx1444_debug, debug_1193
    rx1444_cur."!cursor_debug"("FAIL", "infix:sym<+>")
  debug_1193:
    .return (rx1444_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+>"  :nsentry("!PREFIX__infix:sym<+>") :subid("317_1300062003.824") :method
.annotate 'line', 10
    $P1446 = self."!PREFIX__!subrule"("O", "+")
    new $P1447, "ResizablePMCArray"
    push $P1447, $P1446
    .return ($P1447)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<->"  :subid("318_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1451_tgt
    .local int rx1451_pos
    .local int rx1451_off
    .local int rx1451_eos
    .local int rx1451_rep
    .local pmc rx1451_cur
    .local pmc rx1451_debug
    (rx1451_cur, rx1451_pos, rx1451_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1451_cur
    .local pmc match
    .lex "$/", match
    length rx1451_eos, rx1451_tgt
    gt rx1451_pos, rx1451_eos, rx1451_done
    set rx1451_off, 0
    lt rx1451_pos, 2, rx1451_start
    sub rx1451_off, rx1451_pos, 1
    substr rx1451_tgt, rx1451_tgt, rx1451_off
  rx1451_start:
    eq $I10, 1, rx1451_restart
    if_null rx1451_debug, debug_1194
    rx1451_cur."!cursor_debug"("START", "infix:sym<->")
  debug_1194:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1455_done
    goto rxscan1455_scan
  rxscan1455_loop:
    (rx1451_pos) = rx1451_cur."from"()
    inc rx1451_pos
    rx1451_cur."!cursor_from"(rx1451_pos)
    ge rx1451_pos, rx1451_eos, rxscan1455_done
  rxscan1455_scan:
    set_addr $I10, rxscan1455_loop
    rx1451_cur."!mark_push"(0, rx1451_pos, $I10)
  rxscan1455_done:
.annotate 'line', 644
  # rx subcapture "sym"
    set_addr $I10, rxcap_1456_fail
    rx1451_cur."!mark_push"(0, rx1451_pos, $I10)
  # rx literal  "-"
    add $I11, rx1451_pos, 1
    gt $I11, rx1451_eos, rx1451_fail
    sub $I11, rx1451_pos, rx1451_off
    ord $I11, rx1451_tgt, $I11
    ne $I11, 45, rx1451_fail
    add rx1451_pos, 1
    set_addr $I10, rxcap_1456_fail
    ($I12, $I11) = rx1451_cur."!mark_peek"($I10)
    rx1451_cur."!cursor_pos"($I11)
    ($P10) = rx1451_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1451_pos, "")
    rx1451_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1456_done
  rxcap_1456_fail:
    goto rx1451_fail
  rxcap_1456_done:
  # rx subrule "O" subtype=capture negate=
    rx1451_cur."!cursor_pos"(rx1451_pos)
    $P10 = rx1451_cur."O"("%additive, :pirop<sub>")
    unless $P10, rx1451_fail
    rx1451_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1451_pos = $P10."pos"()
  # rx pass
    rx1451_cur."!cursor_pass"(rx1451_pos, "infix:sym<->")
    if_null rx1451_debug, debug_1195
    rx1451_cur."!cursor_debug"("PASS", "infix:sym<->", " at pos=", rx1451_pos)
  debug_1195:
    .return (rx1451_cur)
  rx1451_restart:
.annotate 'line', 10
    if_null rx1451_debug, debug_1196
    rx1451_cur."!cursor_debug"("NEXT", "infix:sym<->")
  debug_1196:
  rx1451_fail:
    (rx1451_rep, rx1451_pos, $I10, $P10) = rx1451_cur."!mark_fail"(0)
    lt rx1451_pos, -1, rx1451_done
    eq rx1451_pos, -1, rx1451_fail
    jump $I10
  rx1451_done:
    rx1451_cur."!cursor_fail"()
    if_null rx1451_debug, debug_1197
    rx1451_cur."!cursor_debug"("FAIL", "infix:sym<->")
  debug_1197:
    .return (rx1451_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<->"  :nsentry("!PREFIX__infix:sym<->") :subid("319_1300062003.824") :method
.annotate 'line', 10
    $P1453 = self."!PREFIX__!subrule"("O", "-")
    new $P1454, "ResizablePMCArray"
    push $P1454, $P1453
    .return ($P1454)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+|>"  :subid("320_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1458_tgt
    .local int rx1458_pos
    .local int rx1458_off
    .local int rx1458_eos
    .local int rx1458_rep
    .local pmc rx1458_cur
    .local pmc rx1458_debug
    (rx1458_cur, rx1458_pos, rx1458_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1458_cur
    .local pmc match
    .lex "$/", match
    length rx1458_eos, rx1458_tgt
    gt rx1458_pos, rx1458_eos, rx1458_done
    set rx1458_off, 0
    lt rx1458_pos, 2, rx1458_start
    sub rx1458_off, rx1458_pos, 1
    substr rx1458_tgt, rx1458_tgt, rx1458_off
  rx1458_start:
    eq $I10, 1, rx1458_restart
    if_null rx1458_debug, debug_1198
    rx1458_cur."!cursor_debug"("START", "infix:sym<+|>")
  debug_1198:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1462_done
    goto rxscan1462_scan
  rxscan1462_loop:
    (rx1458_pos) = rx1458_cur."from"()
    inc rx1458_pos
    rx1458_cur."!cursor_from"(rx1458_pos)
    ge rx1458_pos, rx1458_eos, rxscan1462_done
  rxscan1462_scan:
    set_addr $I10, rxscan1462_loop
    rx1458_cur."!mark_push"(0, rx1458_pos, $I10)
  rxscan1462_done:
.annotate 'line', 645
  # rx subcapture "sym"
    set_addr $I10, rxcap_1463_fail
    rx1458_cur."!mark_push"(0, rx1458_pos, $I10)
  # rx literal  "+|"
    add $I11, rx1458_pos, 2
    gt $I11, rx1458_eos, rx1458_fail
    sub $I11, rx1458_pos, rx1458_off
    substr $S10, rx1458_tgt, $I11, 2
    ne $S10, "+|", rx1458_fail
    add rx1458_pos, 2
    set_addr $I10, rxcap_1463_fail
    ($I12, $I11) = rx1458_cur."!mark_peek"($I10)
    rx1458_cur."!cursor_pos"($I11)
    ($P10) = rx1458_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1458_pos, "")
    rx1458_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1463_done
  rxcap_1463_fail:
    goto rx1458_fail
  rxcap_1463_done:
  # rx subrule "O" subtype=capture negate=
    rx1458_cur."!cursor_pos"(rx1458_pos)
    $P10 = rx1458_cur."O"("%additive, :pirop<bor III>")
    unless $P10, rx1458_fail
    rx1458_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1458_pos = $P10."pos"()
  # rx pass
    rx1458_cur."!cursor_pass"(rx1458_pos, "infix:sym<+|>")
    if_null rx1458_debug, debug_1199
    rx1458_cur."!cursor_debug"("PASS", "infix:sym<+|>", " at pos=", rx1458_pos)
  debug_1199:
    .return (rx1458_cur)
  rx1458_restart:
.annotate 'line', 10
    if_null rx1458_debug, debug_1200
    rx1458_cur."!cursor_debug"("NEXT", "infix:sym<+|>")
  debug_1200:
  rx1458_fail:
    (rx1458_rep, rx1458_pos, $I10, $P10) = rx1458_cur."!mark_fail"(0)
    lt rx1458_pos, -1, rx1458_done
    eq rx1458_pos, -1, rx1458_fail
    jump $I10
  rx1458_done:
    rx1458_cur."!cursor_fail"()
    if_null rx1458_debug, debug_1201
    rx1458_cur."!cursor_debug"("FAIL", "infix:sym<+|>")
  debug_1201:
    .return (rx1458_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+|>"  :nsentry("!PREFIX__infix:sym<+|>") :subid("321_1300062003.824") :method
.annotate 'line', 10
    $P1460 = self."!PREFIX__!subrule"("O", "+|")
    new $P1461, "ResizablePMCArray"
    push $P1461, $P1460
    .return ($P1461)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+^>"  :subid("322_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1465_tgt
    .local int rx1465_pos
    .local int rx1465_off
    .local int rx1465_eos
    .local int rx1465_rep
    .local pmc rx1465_cur
    .local pmc rx1465_debug
    (rx1465_cur, rx1465_pos, rx1465_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1465_cur
    .local pmc match
    .lex "$/", match
    length rx1465_eos, rx1465_tgt
    gt rx1465_pos, rx1465_eos, rx1465_done
    set rx1465_off, 0
    lt rx1465_pos, 2, rx1465_start
    sub rx1465_off, rx1465_pos, 1
    substr rx1465_tgt, rx1465_tgt, rx1465_off
  rx1465_start:
    eq $I10, 1, rx1465_restart
    if_null rx1465_debug, debug_1202
    rx1465_cur."!cursor_debug"("START", "infix:sym<+^>")
  debug_1202:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1469_done
    goto rxscan1469_scan
  rxscan1469_loop:
    (rx1465_pos) = rx1465_cur."from"()
    inc rx1465_pos
    rx1465_cur."!cursor_from"(rx1465_pos)
    ge rx1465_pos, rx1465_eos, rxscan1469_done
  rxscan1469_scan:
    set_addr $I10, rxscan1469_loop
    rx1465_cur."!mark_push"(0, rx1465_pos, $I10)
  rxscan1469_done:
.annotate 'line', 646
  # rx subcapture "sym"
    set_addr $I10, rxcap_1470_fail
    rx1465_cur."!mark_push"(0, rx1465_pos, $I10)
  # rx literal  "+^"
    add $I11, rx1465_pos, 2
    gt $I11, rx1465_eos, rx1465_fail
    sub $I11, rx1465_pos, rx1465_off
    substr $S10, rx1465_tgt, $I11, 2
    ne $S10, "+^", rx1465_fail
    add rx1465_pos, 2
    set_addr $I10, rxcap_1470_fail
    ($I12, $I11) = rx1465_cur."!mark_peek"($I10)
    rx1465_cur."!cursor_pos"($I11)
    ($P10) = rx1465_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1465_pos, "")
    rx1465_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1470_done
  rxcap_1470_fail:
    goto rx1465_fail
  rxcap_1470_done:
  # rx subrule "O" subtype=capture negate=
    rx1465_cur."!cursor_pos"(rx1465_pos)
    $P10 = rx1465_cur."O"("%additive, :pirop<bxor III>")
    unless $P10, rx1465_fail
    rx1465_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1465_pos = $P10."pos"()
  # rx pass
    rx1465_cur."!cursor_pass"(rx1465_pos, "infix:sym<+^>")
    if_null rx1465_debug, debug_1203
    rx1465_cur."!cursor_debug"("PASS", "infix:sym<+^>", " at pos=", rx1465_pos)
  debug_1203:
    .return (rx1465_cur)
  rx1465_restart:
.annotate 'line', 10
    if_null rx1465_debug, debug_1204
    rx1465_cur."!cursor_debug"("NEXT", "infix:sym<+^>")
  debug_1204:
  rx1465_fail:
    (rx1465_rep, rx1465_pos, $I10, $P10) = rx1465_cur."!mark_fail"(0)
    lt rx1465_pos, -1, rx1465_done
    eq rx1465_pos, -1, rx1465_fail
    jump $I10
  rx1465_done:
    rx1465_cur."!cursor_fail"()
    if_null rx1465_debug, debug_1205
    rx1465_cur."!cursor_debug"("FAIL", "infix:sym<+^>")
  debug_1205:
    .return (rx1465_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+^>"  :nsentry("!PREFIX__infix:sym<+^>") :subid("323_1300062003.824") :method
.annotate 'line', 10
    $P1467 = self."!PREFIX__!subrule"("O", "+^")
    new $P1468, "ResizablePMCArray"
    push $P1468, $P1467
    .return ($P1468)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~>"  :subid("324_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1472_tgt
    .local int rx1472_pos
    .local int rx1472_off
    .local int rx1472_eos
    .local int rx1472_rep
    .local pmc rx1472_cur
    .local pmc rx1472_debug
    (rx1472_cur, rx1472_pos, rx1472_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1472_cur
    .local pmc match
    .lex "$/", match
    length rx1472_eos, rx1472_tgt
    gt rx1472_pos, rx1472_eos, rx1472_done
    set rx1472_off, 0
    lt rx1472_pos, 2, rx1472_start
    sub rx1472_off, rx1472_pos, 1
    substr rx1472_tgt, rx1472_tgt, rx1472_off
  rx1472_start:
    eq $I10, 1, rx1472_restart
    if_null rx1472_debug, debug_1206
    rx1472_cur."!cursor_debug"("START", "infix:sym<~>")
  debug_1206:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1476_done
    goto rxscan1476_scan
  rxscan1476_loop:
    (rx1472_pos) = rx1472_cur."from"()
    inc rx1472_pos
    rx1472_cur."!cursor_from"(rx1472_pos)
    ge rx1472_pos, rx1472_eos, rxscan1476_done
  rxscan1476_scan:
    set_addr $I10, rxscan1476_loop
    rx1472_cur."!mark_push"(0, rx1472_pos, $I10)
  rxscan1476_done:
.annotate 'line', 648
  # rx subcapture "sym"
    set_addr $I10, rxcap_1477_fail
    rx1472_cur."!mark_push"(0, rx1472_pos, $I10)
  # rx literal  "~"
    add $I11, rx1472_pos, 1
    gt $I11, rx1472_eos, rx1472_fail
    sub $I11, rx1472_pos, rx1472_off
    ord $I11, rx1472_tgt, $I11
    ne $I11, 126, rx1472_fail
    add rx1472_pos, 1
    set_addr $I10, rxcap_1477_fail
    ($I12, $I11) = rx1472_cur."!mark_peek"($I10)
    rx1472_cur."!cursor_pos"($I11)
    ($P10) = rx1472_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1472_pos, "")
    rx1472_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1477_done
  rxcap_1477_fail:
    goto rx1472_fail
  rxcap_1477_done:
  # rx subrule "O" subtype=capture negate=
    rx1472_cur."!cursor_pos"(rx1472_pos)
    $P10 = rx1472_cur."O"("%concatenation , :pirop<concat>")
    unless $P10, rx1472_fail
    rx1472_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1472_pos = $P10."pos"()
  # rx pass
    rx1472_cur."!cursor_pass"(rx1472_pos, "infix:sym<~>")
    if_null rx1472_debug, debug_1207
    rx1472_cur."!cursor_debug"("PASS", "infix:sym<~>", " at pos=", rx1472_pos)
  debug_1207:
    .return (rx1472_cur)
  rx1472_restart:
.annotate 'line', 10
    if_null rx1472_debug, debug_1208
    rx1472_cur."!cursor_debug"("NEXT", "infix:sym<~>")
  debug_1208:
  rx1472_fail:
    (rx1472_rep, rx1472_pos, $I10, $P10) = rx1472_cur."!mark_fail"(0)
    lt rx1472_pos, -1, rx1472_done
    eq rx1472_pos, -1, rx1472_fail
    jump $I10
  rx1472_done:
    rx1472_cur."!cursor_fail"()
    if_null rx1472_debug, debug_1209
    rx1472_cur."!cursor_debug"("FAIL", "infix:sym<~>")
  debug_1209:
    .return (rx1472_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~>"  :nsentry("!PREFIX__infix:sym<~>") :subid("325_1300062003.824") :method
.annotate 'line', 10
    $P1474 = self."!PREFIX__!subrule"("O", "~")
    new $P1475, "ResizablePMCArray"
    push $P1475, $P1474
    .return ($P1475)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<==>"  :subid("326_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1479_tgt
    .local int rx1479_pos
    .local int rx1479_off
    .local int rx1479_eos
    .local int rx1479_rep
    .local pmc rx1479_cur
    .local pmc rx1479_debug
    (rx1479_cur, rx1479_pos, rx1479_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1479_cur
    .local pmc match
    .lex "$/", match
    length rx1479_eos, rx1479_tgt
    gt rx1479_pos, rx1479_eos, rx1479_done
    set rx1479_off, 0
    lt rx1479_pos, 2, rx1479_start
    sub rx1479_off, rx1479_pos, 1
    substr rx1479_tgt, rx1479_tgt, rx1479_off
  rx1479_start:
    eq $I10, 1, rx1479_restart
    if_null rx1479_debug, debug_1210
    rx1479_cur."!cursor_debug"("START", "infix:sym<==>")
  debug_1210:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1483_done
    goto rxscan1483_scan
  rxscan1483_loop:
    (rx1479_pos) = rx1479_cur."from"()
    inc rx1479_pos
    rx1479_cur."!cursor_from"(rx1479_pos)
    ge rx1479_pos, rx1479_eos, rxscan1483_done
  rxscan1483_scan:
    set_addr $I10, rxscan1483_loop
    rx1479_cur."!mark_push"(0, rx1479_pos, $I10)
  rxscan1483_done:
.annotate 'line', 650
  # rx subcapture "sym"
    set_addr $I10, rxcap_1484_fail
    rx1479_cur."!mark_push"(0, rx1479_pos, $I10)
  # rx literal  "=="
    add $I11, rx1479_pos, 2
    gt $I11, rx1479_eos, rx1479_fail
    sub $I11, rx1479_pos, rx1479_off
    substr $S10, rx1479_tgt, $I11, 2
    ne $S10, "==", rx1479_fail
    add rx1479_pos, 2
    set_addr $I10, rxcap_1484_fail
    ($I12, $I11) = rx1479_cur."!mark_peek"($I10)
    rx1479_cur."!cursor_pos"($I11)
    ($P10) = rx1479_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1479_pos, "")
    rx1479_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1484_done
  rxcap_1484_fail:
    goto rx1479_fail
  rxcap_1484_done:
  # rx subrule "O" subtype=capture negate=
    rx1479_cur."!cursor_pos"(rx1479_pos)
    $P10 = rx1479_cur."O"("%relational, :pirop<iseq INn>")
    unless $P10, rx1479_fail
    rx1479_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1479_pos = $P10."pos"()
  # rx pass
    rx1479_cur."!cursor_pass"(rx1479_pos, "infix:sym<==>")
    if_null rx1479_debug, debug_1211
    rx1479_cur."!cursor_debug"("PASS", "infix:sym<==>", " at pos=", rx1479_pos)
  debug_1211:
    .return (rx1479_cur)
  rx1479_restart:
.annotate 'line', 10
    if_null rx1479_debug, debug_1212
    rx1479_cur."!cursor_debug"("NEXT", "infix:sym<==>")
  debug_1212:
  rx1479_fail:
    (rx1479_rep, rx1479_pos, $I10, $P10) = rx1479_cur."!mark_fail"(0)
    lt rx1479_pos, -1, rx1479_done
    eq rx1479_pos, -1, rx1479_fail
    jump $I10
  rx1479_done:
    rx1479_cur."!cursor_fail"()
    if_null rx1479_debug, debug_1213
    rx1479_cur."!cursor_debug"("FAIL", "infix:sym<==>")
  debug_1213:
    .return (rx1479_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<==>"  :nsentry("!PREFIX__infix:sym<==>") :subid("327_1300062003.824") :method
.annotate 'line', 10
    $P1481 = self."!PREFIX__!subrule"("O", "==")
    new $P1482, "ResizablePMCArray"
    push $P1482, $P1481
    .return ($P1482)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<!=>"  :subid("328_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1486_tgt
    .local int rx1486_pos
    .local int rx1486_off
    .local int rx1486_eos
    .local int rx1486_rep
    .local pmc rx1486_cur
    .local pmc rx1486_debug
    (rx1486_cur, rx1486_pos, rx1486_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1486_cur
    .local pmc match
    .lex "$/", match
    length rx1486_eos, rx1486_tgt
    gt rx1486_pos, rx1486_eos, rx1486_done
    set rx1486_off, 0
    lt rx1486_pos, 2, rx1486_start
    sub rx1486_off, rx1486_pos, 1
    substr rx1486_tgt, rx1486_tgt, rx1486_off
  rx1486_start:
    eq $I10, 1, rx1486_restart
    if_null rx1486_debug, debug_1214
    rx1486_cur."!cursor_debug"("START", "infix:sym<!=>")
  debug_1214:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1490_done
    goto rxscan1490_scan
  rxscan1490_loop:
    (rx1486_pos) = rx1486_cur."from"()
    inc rx1486_pos
    rx1486_cur."!cursor_from"(rx1486_pos)
    ge rx1486_pos, rx1486_eos, rxscan1490_done
  rxscan1490_scan:
    set_addr $I10, rxscan1490_loop
    rx1486_cur."!mark_push"(0, rx1486_pos, $I10)
  rxscan1490_done:
.annotate 'line', 651
  # rx subcapture "sym"
    set_addr $I10, rxcap_1491_fail
    rx1486_cur."!mark_push"(0, rx1486_pos, $I10)
  # rx literal  "!="
    add $I11, rx1486_pos, 2
    gt $I11, rx1486_eos, rx1486_fail
    sub $I11, rx1486_pos, rx1486_off
    substr $S10, rx1486_tgt, $I11, 2
    ne $S10, "!=", rx1486_fail
    add rx1486_pos, 2
    set_addr $I10, rxcap_1491_fail
    ($I12, $I11) = rx1486_cur."!mark_peek"($I10)
    rx1486_cur."!cursor_pos"($I11)
    ($P10) = rx1486_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1486_pos, "")
    rx1486_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1491_done
  rxcap_1491_fail:
    goto rx1486_fail
  rxcap_1491_done:
  # rx subrule "O" subtype=capture negate=
    rx1486_cur."!cursor_pos"(rx1486_pos)
    $P10 = rx1486_cur."O"("%relational, :pirop<isne INn>")
    unless $P10, rx1486_fail
    rx1486_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1486_pos = $P10."pos"()
  # rx pass
    rx1486_cur."!cursor_pass"(rx1486_pos, "infix:sym<!=>")
    if_null rx1486_debug, debug_1215
    rx1486_cur."!cursor_debug"("PASS", "infix:sym<!=>", " at pos=", rx1486_pos)
  debug_1215:
    .return (rx1486_cur)
  rx1486_restart:
.annotate 'line', 10
    if_null rx1486_debug, debug_1216
    rx1486_cur."!cursor_debug"("NEXT", "infix:sym<!=>")
  debug_1216:
  rx1486_fail:
    (rx1486_rep, rx1486_pos, $I10, $P10) = rx1486_cur."!mark_fail"(0)
    lt rx1486_pos, -1, rx1486_done
    eq rx1486_pos, -1, rx1486_fail
    jump $I10
  rx1486_done:
    rx1486_cur."!cursor_fail"()
    if_null rx1486_debug, debug_1217
    rx1486_cur."!cursor_debug"("FAIL", "infix:sym<!=>")
  debug_1217:
    .return (rx1486_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<!=>"  :nsentry("!PREFIX__infix:sym<!=>") :subid("329_1300062003.824") :method
.annotate 'line', 10
    $P1488 = self."!PREFIX__!subrule"("O", "!=")
    new $P1489, "ResizablePMCArray"
    push $P1489, $P1488
    .return ($P1489)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<=>"  :subid("330_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1493_tgt
    .local int rx1493_pos
    .local int rx1493_off
    .local int rx1493_eos
    .local int rx1493_rep
    .local pmc rx1493_cur
    .local pmc rx1493_debug
    (rx1493_cur, rx1493_pos, rx1493_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1493_cur
    .local pmc match
    .lex "$/", match
    length rx1493_eos, rx1493_tgt
    gt rx1493_pos, rx1493_eos, rx1493_done
    set rx1493_off, 0
    lt rx1493_pos, 2, rx1493_start
    sub rx1493_off, rx1493_pos, 1
    substr rx1493_tgt, rx1493_tgt, rx1493_off
  rx1493_start:
    eq $I10, 1, rx1493_restart
    if_null rx1493_debug, debug_1218
    rx1493_cur."!cursor_debug"("START", "infix:sym<<=>")
  debug_1218:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1497_done
    goto rxscan1497_scan
  rxscan1497_loop:
    (rx1493_pos) = rx1493_cur."from"()
    inc rx1493_pos
    rx1493_cur."!cursor_from"(rx1493_pos)
    ge rx1493_pos, rx1493_eos, rxscan1497_done
  rxscan1497_scan:
    set_addr $I10, rxscan1497_loop
    rx1493_cur."!mark_push"(0, rx1493_pos, $I10)
  rxscan1497_done:
.annotate 'line', 652
  # rx subcapture "sym"
    set_addr $I10, rxcap_1498_fail
    rx1493_cur."!mark_push"(0, rx1493_pos, $I10)
  # rx literal  "<="
    add $I11, rx1493_pos, 2
    gt $I11, rx1493_eos, rx1493_fail
    sub $I11, rx1493_pos, rx1493_off
    substr $S10, rx1493_tgt, $I11, 2
    ne $S10, "<=", rx1493_fail
    add rx1493_pos, 2
    set_addr $I10, rxcap_1498_fail
    ($I12, $I11) = rx1493_cur."!mark_peek"($I10)
    rx1493_cur."!cursor_pos"($I11)
    ($P10) = rx1493_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1493_pos, "")
    rx1493_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1498_done
  rxcap_1498_fail:
    goto rx1493_fail
  rxcap_1498_done:
  # rx subrule "O" subtype=capture negate=
    rx1493_cur."!cursor_pos"(rx1493_pos)
    $P10 = rx1493_cur."O"("%relational, :pirop<isle INn>")
    unless $P10, rx1493_fail
    rx1493_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1493_pos = $P10."pos"()
  # rx pass
    rx1493_cur."!cursor_pass"(rx1493_pos, "infix:sym<<=>")
    if_null rx1493_debug, debug_1219
    rx1493_cur."!cursor_debug"("PASS", "infix:sym<<=>", " at pos=", rx1493_pos)
  debug_1219:
    .return (rx1493_cur)
  rx1493_restart:
.annotate 'line', 10
    if_null rx1493_debug, debug_1220
    rx1493_cur."!cursor_debug"("NEXT", "infix:sym<<=>")
  debug_1220:
  rx1493_fail:
    (rx1493_rep, rx1493_pos, $I10, $P10) = rx1493_cur."!mark_fail"(0)
    lt rx1493_pos, -1, rx1493_done
    eq rx1493_pos, -1, rx1493_fail
    jump $I10
  rx1493_done:
    rx1493_cur."!cursor_fail"()
    if_null rx1493_debug, debug_1221
    rx1493_cur."!cursor_debug"("FAIL", "infix:sym<<=>")
  debug_1221:
    .return (rx1493_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<=>"  :nsentry("!PREFIX__infix:sym<<=>") :subid("331_1300062003.824") :method
.annotate 'line', 10
    $P1495 = self."!PREFIX__!subrule"("O", "<=")
    new $P1496, "ResizablePMCArray"
    push $P1496, $P1495
    .return ($P1496)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>=>"  :subid("332_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1500_tgt
    .local int rx1500_pos
    .local int rx1500_off
    .local int rx1500_eos
    .local int rx1500_rep
    .local pmc rx1500_cur
    .local pmc rx1500_debug
    (rx1500_cur, rx1500_pos, rx1500_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1500_cur
    .local pmc match
    .lex "$/", match
    length rx1500_eos, rx1500_tgt
    gt rx1500_pos, rx1500_eos, rx1500_done
    set rx1500_off, 0
    lt rx1500_pos, 2, rx1500_start
    sub rx1500_off, rx1500_pos, 1
    substr rx1500_tgt, rx1500_tgt, rx1500_off
  rx1500_start:
    eq $I10, 1, rx1500_restart
    if_null rx1500_debug, debug_1222
    rx1500_cur."!cursor_debug"("START", "infix:sym<>=>")
  debug_1222:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1504_done
    goto rxscan1504_scan
  rxscan1504_loop:
    (rx1500_pos) = rx1500_cur."from"()
    inc rx1500_pos
    rx1500_cur."!cursor_from"(rx1500_pos)
    ge rx1500_pos, rx1500_eos, rxscan1504_done
  rxscan1504_scan:
    set_addr $I10, rxscan1504_loop
    rx1500_cur."!mark_push"(0, rx1500_pos, $I10)
  rxscan1504_done:
.annotate 'line', 653
  # rx subcapture "sym"
    set_addr $I10, rxcap_1505_fail
    rx1500_cur."!mark_push"(0, rx1500_pos, $I10)
  # rx literal  ">="
    add $I11, rx1500_pos, 2
    gt $I11, rx1500_eos, rx1500_fail
    sub $I11, rx1500_pos, rx1500_off
    substr $S10, rx1500_tgt, $I11, 2
    ne $S10, ">=", rx1500_fail
    add rx1500_pos, 2
    set_addr $I10, rxcap_1505_fail
    ($I12, $I11) = rx1500_cur."!mark_peek"($I10)
    rx1500_cur."!cursor_pos"($I11)
    ($P10) = rx1500_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1500_pos, "")
    rx1500_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1505_done
  rxcap_1505_fail:
    goto rx1500_fail
  rxcap_1505_done:
  # rx subrule "O" subtype=capture negate=
    rx1500_cur."!cursor_pos"(rx1500_pos)
    $P10 = rx1500_cur."O"("%relational, :pirop<isge INn>")
    unless $P10, rx1500_fail
    rx1500_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1500_pos = $P10."pos"()
  # rx pass
    rx1500_cur."!cursor_pass"(rx1500_pos, "infix:sym<>=>")
    if_null rx1500_debug, debug_1223
    rx1500_cur."!cursor_debug"("PASS", "infix:sym<>=>", " at pos=", rx1500_pos)
  debug_1223:
    .return (rx1500_cur)
  rx1500_restart:
.annotate 'line', 10
    if_null rx1500_debug, debug_1224
    rx1500_cur."!cursor_debug"("NEXT", "infix:sym<>=>")
  debug_1224:
  rx1500_fail:
    (rx1500_rep, rx1500_pos, $I10, $P10) = rx1500_cur."!mark_fail"(0)
    lt rx1500_pos, -1, rx1500_done
    eq rx1500_pos, -1, rx1500_fail
    jump $I10
  rx1500_done:
    rx1500_cur."!cursor_fail"()
    if_null rx1500_debug, debug_1225
    rx1500_cur."!cursor_debug"("FAIL", "infix:sym<>=>")
  debug_1225:
    .return (rx1500_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>=>"  :nsentry("!PREFIX__infix:sym<>=>") :subid("333_1300062003.824") :method
.annotate 'line', 10
    $P1502 = self."!PREFIX__!subrule"("O", ">=")
    new $P1503, "ResizablePMCArray"
    push $P1503, $P1502
    .return ($P1503)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<>"  :subid("334_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1507_tgt
    .local int rx1507_pos
    .local int rx1507_off
    .local int rx1507_eos
    .local int rx1507_rep
    .local pmc rx1507_cur
    .local pmc rx1507_debug
    (rx1507_cur, rx1507_pos, rx1507_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1507_cur
    .local pmc match
    .lex "$/", match
    length rx1507_eos, rx1507_tgt
    gt rx1507_pos, rx1507_eos, rx1507_done
    set rx1507_off, 0
    lt rx1507_pos, 2, rx1507_start
    sub rx1507_off, rx1507_pos, 1
    substr rx1507_tgt, rx1507_tgt, rx1507_off
  rx1507_start:
    eq $I10, 1, rx1507_restart
    if_null rx1507_debug, debug_1226
    rx1507_cur."!cursor_debug"("START", "infix:sym<<>")
  debug_1226:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1511_done
    goto rxscan1511_scan
  rxscan1511_loop:
    (rx1507_pos) = rx1507_cur."from"()
    inc rx1507_pos
    rx1507_cur."!cursor_from"(rx1507_pos)
    ge rx1507_pos, rx1507_eos, rxscan1511_done
  rxscan1511_scan:
    set_addr $I10, rxscan1511_loop
    rx1507_cur."!mark_push"(0, rx1507_pos, $I10)
  rxscan1511_done:
.annotate 'line', 654
  # rx subcapture "sym"
    set_addr $I10, rxcap_1512_fail
    rx1507_cur."!mark_push"(0, rx1507_pos, $I10)
  # rx literal  "<"
    add $I11, rx1507_pos, 1
    gt $I11, rx1507_eos, rx1507_fail
    sub $I11, rx1507_pos, rx1507_off
    ord $I11, rx1507_tgt, $I11
    ne $I11, 60, rx1507_fail
    add rx1507_pos, 1
    set_addr $I10, rxcap_1512_fail
    ($I12, $I11) = rx1507_cur."!mark_peek"($I10)
    rx1507_cur."!cursor_pos"($I11)
    ($P10) = rx1507_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1507_pos, "")
    rx1507_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1512_done
  rxcap_1512_fail:
    goto rx1507_fail
  rxcap_1512_done:
  # rx subrule "O" subtype=capture negate=
    rx1507_cur."!cursor_pos"(rx1507_pos)
    $P10 = rx1507_cur."O"("%relational, :pirop<islt INn>")
    unless $P10, rx1507_fail
    rx1507_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1507_pos = $P10."pos"()
  # rx pass
    rx1507_cur."!cursor_pass"(rx1507_pos, "infix:sym<<>")
    if_null rx1507_debug, debug_1227
    rx1507_cur."!cursor_debug"("PASS", "infix:sym<<>", " at pos=", rx1507_pos)
  debug_1227:
    .return (rx1507_cur)
  rx1507_restart:
.annotate 'line', 10
    if_null rx1507_debug, debug_1228
    rx1507_cur."!cursor_debug"("NEXT", "infix:sym<<>")
  debug_1228:
  rx1507_fail:
    (rx1507_rep, rx1507_pos, $I10, $P10) = rx1507_cur."!mark_fail"(0)
    lt rx1507_pos, -1, rx1507_done
    eq rx1507_pos, -1, rx1507_fail
    jump $I10
  rx1507_done:
    rx1507_cur."!cursor_fail"()
    if_null rx1507_debug, debug_1229
    rx1507_cur."!cursor_debug"("FAIL", "infix:sym<<>")
  debug_1229:
    .return (rx1507_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<>"  :nsentry("!PREFIX__infix:sym<<>") :subid("335_1300062003.824") :method
.annotate 'line', 10
    $P1509 = self."!PREFIX__!subrule"("O", "<")
    new $P1510, "ResizablePMCArray"
    push $P1510, $P1509
    .return ($P1510)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>>"  :subid("336_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1514_tgt
    .local int rx1514_pos
    .local int rx1514_off
    .local int rx1514_eos
    .local int rx1514_rep
    .local pmc rx1514_cur
    .local pmc rx1514_debug
    (rx1514_cur, rx1514_pos, rx1514_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1514_cur
    .local pmc match
    .lex "$/", match
    length rx1514_eos, rx1514_tgt
    gt rx1514_pos, rx1514_eos, rx1514_done
    set rx1514_off, 0
    lt rx1514_pos, 2, rx1514_start
    sub rx1514_off, rx1514_pos, 1
    substr rx1514_tgt, rx1514_tgt, rx1514_off
  rx1514_start:
    eq $I10, 1, rx1514_restart
    if_null rx1514_debug, debug_1230
    rx1514_cur."!cursor_debug"("START", "infix:sym<>>")
  debug_1230:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1518_done
    goto rxscan1518_scan
  rxscan1518_loop:
    (rx1514_pos) = rx1514_cur."from"()
    inc rx1514_pos
    rx1514_cur."!cursor_from"(rx1514_pos)
    ge rx1514_pos, rx1514_eos, rxscan1518_done
  rxscan1518_scan:
    set_addr $I10, rxscan1518_loop
    rx1514_cur."!mark_push"(0, rx1514_pos, $I10)
  rxscan1518_done:
.annotate 'line', 655
  # rx subcapture "sym"
    set_addr $I10, rxcap_1519_fail
    rx1514_cur."!mark_push"(0, rx1514_pos, $I10)
  # rx literal  ">"
    add $I11, rx1514_pos, 1
    gt $I11, rx1514_eos, rx1514_fail
    sub $I11, rx1514_pos, rx1514_off
    ord $I11, rx1514_tgt, $I11
    ne $I11, 62, rx1514_fail
    add rx1514_pos, 1
    set_addr $I10, rxcap_1519_fail
    ($I12, $I11) = rx1514_cur."!mark_peek"($I10)
    rx1514_cur."!cursor_pos"($I11)
    ($P10) = rx1514_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1514_pos, "")
    rx1514_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1519_done
  rxcap_1519_fail:
    goto rx1514_fail
  rxcap_1519_done:
  # rx subrule "O" subtype=capture negate=
    rx1514_cur."!cursor_pos"(rx1514_pos)
    $P10 = rx1514_cur."O"("%relational, :pirop<isgt INn>")
    unless $P10, rx1514_fail
    rx1514_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1514_pos = $P10."pos"()
  # rx pass
    rx1514_cur."!cursor_pass"(rx1514_pos, "infix:sym<>>")
    if_null rx1514_debug, debug_1231
    rx1514_cur."!cursor_debug"("PASS", "infix:sym<>>", " at pos=", rx1514_pos)
  debug_1231:
    .return (rx1514_cur)
  rx1514_restart:
.annotate 'line', 10
    if_null rx1514_debug, debug_1232
    rx1514_cur."!cursor_debug"("NEXT", "infix:sym<>>")
  debug_1232:
  rx1514_fail:
    (rx1514_rep, rx1514_pos, $I10, $P10) = rx1514_cur."!mark_fail"(0)
    lt rx1514_pos, -1, rx1514_done
    eq rx1514_pos, -1, rx1514_fail
    jump $I10
  rx1514_done:
    rx1514_cur."!cursor_fail"()
    if_null rx1514_debug, debug_1233
    rx1514_cur."!cursor_debug"("FAIL", "infix:sym<>>")
  debug_1233:
    .return (rx1514_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>>"  :nsentry("!PREFIX__infix:sym<>>") :subid("337_1300062003.824") :method
.annotate 'line', 10
    $P1516 = self."!PREFIX__!subrule"("O", ">")
    new $P1517, "ResizablePMCArray"
    push $P1517, $P1516
    .return ($P1517)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<eq>"  :subid("338_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1521_tgt
    .local int rx1521_pos
    .local int rx1521_off
    .local int rx1521_eos
    .local int rx1521_rep
    .local pmc rx1521_cur
    .local pmc rx1521_debug
    (rx1521_cur, rx1521_pos, rx1521_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1521_cur
    .local pmc match
    .lex "$/", match
    length rx1521_eos, rx1521_tgt
    gt rx1521_pos, rx1521_eos, rx1521_done
    set rx1521_off, 0
    lt rx1521_pos, 2, rx1521_start
    sub rx1521_off, rx1521_pos, 1
    substr rx1521_tgt, rx1521_tgt, rx1521_off
  rx1521_start:
    eq $I10, 1, rx1521_restart
    if_null rx1521_debug, debug_1234
    rx1521_cur."!cursor_debug"("START", "infix:sym<eq>")
  debug_1234:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1525_done
    goto rxscan1525_scan
  rxscan1525_loop:
    (rx1521_pos) = rx1521_cur."from"()
    inc rx1521_pos
    rx1521_cur."!cursor_from"(rx1521_pos)
    ge rx1521_pos, rx1521_eos, rxscan1525_done
  rxscan1525_scan:
    set_addr $I10, rxscan1525_loop
    rx1521_cur."!mark_push"(0, rx1521_pos, $I10)
  rxscan1525_done:
.annotate 'line', 656
  # rx subcapture "sym"
    set_addr $I10, rxcap_1526_fail
    rx1521_cur."!mark_push"(0, rx1521_pos, $I10)
  # rx literal  "eq"
    add $I11, rx1521_pos, 2
    gt $I11, rx1521_eos, rx1521_fail
    sub $I11, rx1521_pos, rx1521_off
    substr $S10, rx1521_tgt, $I11, 2
    ne $S10, "eq", rx1521_fail
    add rx1521_pos, 2
    set_addr $I10, rxcap_1526_fail
    ($I12, $I11) = rx1521_cur."!mark_peek"($I10)
    rx1521_cur."!cursor_pos"($I11)
    ($P10) = rx1521_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1521_pos, "")
    rx1521_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1526_done
  rxcap_1526_fail:
    goto rx1521_fail
  rxcap_1526_done:
  # rx subrule "O" subtype=capture negate=
    rx1521_cur."!cursor_pos"(rx1521_pos)
    $P10 = rx1521_cur."O"("%relational, :pirop<iseq ISs>")
    unless $P10, rx1521_fail
    rx1521_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1521_pos = $P10."pos"()
  # rx pass
    rx1521_cur."!cursor_pass"(rx1521_pos, "infix:sym<eq>")
    if_null rx1521_debug, debug_1235
    rx1521_cur."!cursor_debug"("PASS", "infix:sym<eq>", " at pos=", rx1521_pos)
  debug_1235:
    .return (rx1521_cur)
  rx1521_restart:
.annotate 'line', 10
    if_null rx1521_debug, debug_1236
    rx1521_cur."!cursor_debug"("NEXT", "infix:sym<eq>")
  debug_1236:
  rx1521_fail:
    (rx1521_rep, rx1521_pos, $I10, $P10) = rx1521_cur."!mark_fail"(0)
    lt rx1521_pos, -1, rx1521_done
    eq rx1521_pos, -1, rx1521_fail
    jump $I10
  rx1521_done:
    rx1521_cur."!cursor_fail"()
    if_null rx1521_debug, debug_1237
    rx1521_cur."!cursor_debug"("FAIL", "infix:sym<eq>")
  debug_1237:
    .return (rx1521_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<eq>"  :nsentry("!PREFIX__infix:sym<eq>") :subid("339_1300062003.824") :method
.annotate 'line', 10
    $P1523 = self."!PREFIX__!subrule"("O", "eq")
    new $P1524, "ResizablePMCArray"
    push $P1524, $P1523
    .return ($P1524)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ne>"  :subid("340_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1528_tgt
    .local int rx1528_pos
    .local int rx1528_off
    .local int rx1528_eos
    .local int rx1528_rep
    .local pmc rx1528_cur
    .local pmc rx1528_debug
    (rx1528_cur, rx1528_pos, rx1528_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1528_cur
    .local pmc match
    .lex "$/", match
    length rx1528_eos, rx1528_tgt
    gt rx1528_pos, rx1528_eos, rx1528_done
    set rx1528_off, 0
    lt rx1528_pos, 2, rx1528_start
    sub rx1528_off, rx1528_pos, 1
    substr rx1528_tgt, rx1528_tgt, rx1528_off
  rx1528_start:
    eq $I10, 1, rx1528_restart
    if_null rx1528_debug, debug_1238
    rx1528_cur."!cursor_debug"("START", "infix:sym<ne>")
  debug_1238:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1532_done
    goto rxscan1532_scan
  rxscan1532_loop:
    (rx1528_pos) = rx1528_cur."from"()
    inc rx1528_pos
    rx1528_cur."!cursor_from"(rx1528_pos)
    ge rx1528_pos, rx1528_eos, rxscan1532_done
  rxscan1532_scan:
    set_addr $I10, rxscan1532_loop
    rx1528_cur."!mark_push"(0, rx1528_pos, $I10)
  rxscan1532_done:
.annotate 'line', 657
  # rx subcapture "sym"
    set_addr $I10, rxcap_1533_fail
    rx1528_cur."!mark_push"(0, rx1528_pos, $I10)
  # rx literal  "ne"
    add $I11, rx1528_pos, 2
    gt $I11, rx1528_eos, rx1528_fail
    sub $I11, rx1528_pos, rx1528_off
    substr $S10, rx1528_tgt, $I11, 2
    ne $S10, "ne", rx1528_fail
    add rx1528_pos, 2
    set_addr $I10, rxcap_1533_fail
    ($I12, $I11) = rx1528_cur."!mark_peek"($I10)
    rx1528_cur."!cursor_pos"($I11)
    ($P10) = rx1528_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1528_pos, "")
    rx1528_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1533_done
  rxcap_1533_fail:
    goto rx1528_fail
  rxcap_1533_done:
  # rx subrule "O" subtype=capture negate=
    rx1528_cur."!cursor_pos"(rx1528_pos)
    $P10 = rx1528_cur."O"("%relational, :pirop<isne ISs>")
    unless $P10, rx1528_fail
    rx1528_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1528_pos = $P10."pos"()
  # rx pass
    rx1528_cur."!cursor_pass"(rx1528_pos, "infix:sym<ne>")
    if_null rx1528_debug, debug_1239
    rx1528_cur."!cursor_debug"("PASS", "infix:sym<ne>", " at pos=", rx1528_pos)
  debug_1239:
    .return (rx1528_cur)
  rx1528_restart:
.annotate 'line', 10
    if_null rx1528_debug, debug_1240
    rx1528_cur."!cursor_debug"("NEXT", "infix:sym<ne>")
  debug_1240:
  rx1528_fail:
    (rx1528_rep, rx1528_pos, $I10, $P10) = rx1528_cur."!mark_fail"(0)
    lt rx1528_pos, -1, rx1528_done
    eq rx1528_pos, -1, rx1528_fail
    jump $I10
  rx1528_done:
    rx1528_cur."!cursor_fail"()
    if_null rx1528_debug, debug_1241
    rx1528_cur."!cursor_debug"("FAIL", "infix:sym<ne>")
  debug_1241:
    .return (rx1528_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ne>"  :nsentry("!PREFIX__infix:sym<ne>") :subid("341_1300062003.824") :method
.annotate 'line', 10
    $P1530 = self."!PREFIX__!subrule"("O", "ne")
    new $P1531, "ResizablePMCArray"
    push $P1531, $P1530
    .return ($P1531)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<le>"  :subid("342_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1535_tgt
    .local int rx1535_pos
    .local int rx1535_off
    .local int rx1535_eos
    .local int rx1535_rep
    .local pmc rx1535_cur
    .local pmc rx1535_debug
    (rx1535_cur, rx1535_pos, rx1535_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1535_cur
    .local pmc match
    .lex "$/", match
    length rx1535_eos, rx1535_tgt
    gt rx1535_pos, rx1535_eos, rx1535_done
    set rx1535_off, 0
    lt rx1535_pos, 2, rx1535_start
    sub rx1535_off, rx1535_pos, 1
    substr rx1535_tgt, rx1535_tgt, rx1535_off
  rx1535_start:
    eq $I10, 1, rx1535_restart
    if_null rx1535_debug, debug_1242
    rx1535_cur."!cursor_debug"("START", "infix:sym<le>")
  debug_1242:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1539_done
    goto rxscan1539_scan
  rxscan1539_loop:
    (rx1535_pos) = rx1535_cur."from"()
    inc rx1535_pos
    rx1535_cur."!cursor_from"(rx1535_pos)
    ge rx1535_pos, rx1535_eos, rxscan1539_done
  rxscan1539_scan:
    set_addr $I10, rxscan1539_loop
    rx1535_cur."!mark_push"(0, rx1535_pos, $I10)
  rxscan1539_done:
.annotate 'line', 658
  # rx subcapture "sym"
    set_addr $I10, rxcap_1540_fail
    rx1535_cur."!mark_push"(0, rx1535_pos, $I10)
  # rx literal  "le"
    add $I11, rx1535_pos, 2
    gt $I11, rx1535_eos, rx1535_fail
    sub $I11, rx1535_pos, rx1535_off
    substr $S10, rx1535_tgt, $I11, 2
    ne $S10, "le", rx1535_fail
    add rx1535_pos, 2
    set_addr $I10, rxcap_1540_fail
    ($I12, $I11) = rx1535_cur."!mark_peek"($I10)
    rx1535_cur."!cursor_pos"($I11)
    ($P10) = rx1535_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1535_pos, "")
    rx1535_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1540_done
  rxcap_1540_fail:
    goto rx1535_fail
  rxcap_1540_done:
  # rx subrule "O" subtype=capture negate=
    rx1535_cur."!cursor_pos"(rx1535_pos)
    $P10 = rx1535_cur."O"("%relational, :pirop<isle ISs>")
    unless $P10, rx1535_fail
    rx1535_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1535_pos = $P10."pos"()
  # rx pass
    rx1535_cur."!cursor_pass"(rx1535_pos, "infix:sym<le>")
    if_null rx1535_debug, debug_1243
    rx1535_cur."!cursor_debug"("PASS", "infix:sym<le>", " at pos=", rx1535_pos)
  debug_1243:
    .return (rx1535_cur)
  rx1535_restart:
.annotate 'line', 10
    if_null rx1535_debug, debug_1244
    rx1535_cur."!cursor_debug"("NEXT", "infix:sym<le>")
  debug_1244:
  rx1535_fail:
    (rx1535_rep, rx1535_pos, $I10, $P10) = rx1535_cur."!mark_fail"(0)
    lt rx1535_pos, -1, rx1535_done
    eq rx1535_pos, -1, rx1535_fail
    jump $I10
  rx1535_done:
    rx1535_cur."!cursor_fail"()
    if_null rx1535_debug, debug_1245
    rx1535_cur."!cursor_debug"("FAIL", "infix:sym<le>")
  debug_1245:
    .return (rx1535_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<le>"  :nsentry("!PREFIX__infix:sym<le>") :subid("343_1300062003.824") :method
.annotate 'line', 10
    $P1537 = self."!PREFIX__!subrule"("O", "le")
    new $P1538, "ResizablePMCArray"
    push $P1538, $P1537
    .return ($P1538)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ge>"  :subid("344_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1542_tgt
    .local int rx1542_pos
    .local int rx1542_off
    .local int rx1542_eos
    .local int rx1542_rep
    .local pmc rx1542_cur
    .local pmc rx1542_debug
    (rx1542_cur, rx1542_pos, rx1542_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1542_cur
    .local pmc match
    .lex "$/", match
    length rx1542_eos, rx1542_tgt
    gt rx1542_pos, rx1542_eos, rx1542_done
    set rx1542_off, 0
    lt rx1542_pos, 2, rx1542_start
    sub rx1542_off, rx1542_pos, 1
    substr rx1542_tgt, rx1542_tgt, rx1542_off
  rx1542_start:
    eq $I10, 1, rx1542_restart
    if_null rx1542_debug, debug_1246
    rx1542_cur."!cursor_debug"("START", "infix:sym<ge>")
  debug_1246:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1546_done
    goto rxscan1546_scan
  rxscan1546_loop:
    (rx1542_pos) = rx1542_cur."from"()
    inc rx1542_pos
    rx1542_cur."!cursor_from"(rx1542_pos)
    ge rx1542_pos, rx1542_eos, rxscan1546_done
  rxscan1546_scan:
    set_addr $I10, rxscan1546_loop
    rx1542_cur."!mark_push"(0, rx1542_pos, $I10)
  rxscan1546_done:
.annotate 'line', 659
  # rx subcapture "sym"
    set_addr $I10, rxcap_1547_fail
    rx1542_cur."!mark_push"(0, rx1542_pos, $I10)
  # rx literal  "ge"
    add $I11, rx1542_pos, 2
    gt $I11, rx1542_eos, rx1542_fail
    sub $I11, rx1542_pos, rx1542_off
    substr $S10, rx1542_tgt, $I11, 2
    ne $S10, "ge", rx1542_fail
    add rx1542_pos, 2
    set_addr $I10, rxcap_1547_fail
    ($I12, $I11) = rx1542_cur."!mark_peek"($I10)
    rx1542_cur."!cursor_pos"($I11)
    ($P10) = rx1542_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1542_pos, "")
    rx1542_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1547_done
  rxcap_1547_fail:
    goto rx1542_fail
  rxcap_1547_done:
  # rx subrule "O" subtype=capture negate=
    rx1542_cur."!cursor_pos"(rx1542_pos)
    $P10 = rx1542_cur."O"("%relational, :pirop<isge ISs>")
    unless $P10, rx1542_fail
    rx1542_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1542_pos = $P10."pos"()
  # rx pass
    rx1542_cur."!cursor_pass"(rx1542_pos, "infix:sym<ge>")
    if_null rx1542_debug, debug_1247
    rx1542_cur."!cursor_debug"("PASS", "infix:sym<ge>", " at pos=", rx1542_pos)
  debug_1247:
    .return (rx1542_cur)
  rx1542_restart:
.annotate 'line', 10
    if_null rx1542_debug, debug_1248
    rx1542_cur."!cursor_debug"("NEXT", "infix:sym<ge>")
  debug_1248:
  rx1542_fail:
    (rx1542_rep, rx1542_pos, $I10, $P10) = rx1542_cur."!mark_fail"(0)
    lt rx1542_pos, -1, rx1542_done
    eq rx1542_pos, -1, rx1542_fail
    jump $I10
  rx1542_done:
    rx1542_cur."!cursor_fail"()
    if_null rx1542_debug, debug_1249
    rx1542_cur."!cursor_debug"("FAIL", "infix:sym<ge>")
  debug_1249:
    .return (rx1542_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ge>"  :nsentry("!PREFIX__infix:sym<ge>") :subid("345_1300062003.824") :method
.annotate 'line', 10
    $P1544 = self."!PREFIX__!subrule"("O", "ge")
    new $P1545, "ResizablePMCArray"
    push $P1545, $P1544
    .return ($P1545)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<lt>"  :subid("346_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1549_tgt
    .local int rx1549_pos
    .local int rx1549_off
    .local int rx1549_eos
    .local int rx1549_rep
    .local pmc rx1549_cur
    .local pmc rx1549_debug
    (rx1549_cur, rx1549_pos, rx1549_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1549_cur
    .local pmc match
    .lex "$/", match
    length rx1549_eos, rx1549_tgt
    gt rx1549_pos, rx1549_eos, rx1549_done
    set rx1549_off, 0
    lt rx1549_pos, 2, rx1549_start
    sub rx1549_off, rx1549_pos, 1
    substr rx1549_tgt, rx1549_tgt, rx1549_off
  rx1549_start:
    eq $I10, 1, rx1549_restart
    if_null rx1549_debug, debug_1250
    rx1549_cur."!cursor_debug"("START", "infix:sym<lt>")
  debug_1250:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1553_done
    goto rxscan1553_scan
  rxscan1553_loop:
    (rx1549_pos) = rx1549_cur."from"()
    inc rx1549_pos
    rx1549_cur."!cursor_from"(rx1549_pos)
    ge rx1549_pos, rx1549_eos, rxscan1553_done
  rxscan1553_scan:
    set_addr $I10, rxscan1553_loop
    rx1549_cur."!mark_push"(0, rx1549_pos, $I10)
  rxscan1553_done:
.annotate 'line', 660
  # rx subcapture "sym"
    set_addr $I10, rxcap_1554_fail
    rx1549_cur."!mark_push"(0, rx1549_pos, $I10)
  # rx literal  "lt"
    add $I11, rx1549_pos, 2
    gt $I11, rx1549_eos, rx1549_fail
    sub $I11, rx1549_pos, rx1549_off
    substr $S10, rx1549_tgt, $I11, 2
    ne $S10, "lt", rx1549_fail
    add rx1549_pos, 2
    set_addr $I10, rxcap_1554_fail
    ($I12, $I11) = rx1549_cur."!mark_peek"($I10)
    rx1549_cur."!cursor_pos"($I11)
    ($P10) = rx1549_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1549_pos, "")
    rx1549_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1554_done
  rxcap_1554_fail:
    goto rx1549_fail
  rxcap_1554_done:
  # rx subrule "O" subtype=capture negate=
    rx1549_cur."!cursor_pos"(rx1549_pos)
    $P10 = rx1549_cur."O"("%relational, :pirop<islt ISs>")
    unless $P10, rx1549_fail
    rx1549_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1549_pos = $P10."pos"()
  # rx pass
    rx1549_cur."!cursor_pass"(rx1549_pos, "infix:sym<lt>")
    if_null rx1549_debug, debug_1251
    rx1549_cur."!cursor_debug"("PASS", "infix:sym<lt>", " at pos=", rx1549_pos)
  debug_1251:
    .return (rx1549_cur)
  rx1549_restart:
.annotate 'line', 10
    if_null rx1549_debug, debug_1252
    rx1549_cur."!cursor_debug"("NEXT", "infix:sym<lt>")
  debug_1252:
  rx1549_fail:
    (rx1549_rep, rx1549_pos, $I10, $P10) = rx1549_cur."!mark_fail"(0)
    lt rx1549_pos, -1, rx1549_done
    eq rx1549_pos, -1, rx1549_fail
    jump $I10
  rx1549_done:
    rx1549_cur."!cursor_fail"()
    if_null rx1549_debug, debug_1253
    rx1549_cur."!cursor_debug"("FAIL", "infix:sym<lt>")
  debug_1253:
    .return (rx1549_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<lt>"  :nsentry("!PREFIX__infix:sym<lt>") :subid("347_1300062003.824") :method
.annotate 'line', 10
    $P1551 = self."!PREFIX__!subrule"("O", "lt")
    new $P1552, "ResizablePMCArray"
    push $P1552, $P1551
    .return ($P1552)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<gt>"  :subid("348_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1556_tgt
    .local int rx1556_pos
    .local int rx1556_off
    .local int rx1556_eos
    .local int rx1556_rep
    .local pmc rx1556_cur
    .local pmc rx1556_debug
    (rx1556_cur, rx1556_pos, rx1556_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1556_cur
    .local pmc match
    .lex "$/", match
    length rx1556_eos, rx1556_tgt
    gt rx1556_pos, rx1556_eos, rx1556_done
    set rx1556_off, 0
    lt rx1556_pos, 2, rx1556_start
    sub rx1556_off, rx1556_pos, 1
    substr rx1556_tgt, rx1556_tgt, rx1556_off
  rx1556_start:
    eq $I10, 1, rx1556_restart
    if_null rx1556_debug, debug_1254
    rx1556_cur."!cursor_debug"("START", "infix:sym<gt>")
  debug_1254:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1560_done
    goto rxscan1560_scan
  rxscan1560_loop:
    (rx1556_pos) = rx1556_cur."from"()
    inc rx1556_pos
    rx1556_cur."!cursor_from"(rx1556_pos)
    ge rx1556_pos, rx1556_eos, rxscan1560_done
  rxscan1560_scan:
    set_addr $I10, rxscan1560_loop
    rx1556_cur."!mark_push"(0, rx1556_pos, $I10)
  rxscan1560_done:
.annotate 'line', 661
  # rx subcapture "sym"
    set_addr $I10, rxcap_1561_fail
    rx1556_cur."!mark_push"(0, rx1556_pos, $I10)
  # rx literal  "gt"
    add $I11, rx1556_pos, 2
    gt $I11, rx1556_eos, rx1556_fail
    sub $I11, rx1556_pos, rx1556_off
    substr $S10, rx1556_tgt, $I11, 2
    ne $S10, "gt", rx1556_fail
    add rx1556_pos, 2
    set_addr $I10, rxcap_1561_fail
    ($I12, $I11) = rx1556_cur."!mark_peek"($I10)
    rx1556_cur."!cursor_pos"($I11)
    ($P10) = rx1556_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1556_pos, "")
    rx1556_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1561_done
  rxcap_1561_fail:
    goto rx1556_fail
  rxcap_1561_done:
  # rx subrule "O" subtype=capture negate=
    rx1556_cur."!cursor_pos"(rx1556_pos)
    $P10 = rx1556_cur."O"("%relational, :pirop<isgt ISs>")
    unless $P10, rx1556_fail
    rx1556_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1556_pos = $P10."pos"()
  # rx pass
    rx1556_cur."!cursor_pass"(rx1556_pos, "infix:sym<gt>")
    if_null rx1556_debug, debug_1255
    rx1556_cur."!cursor_debug"("PASS", "infix:sym<gt>", " at pos=", rx1556_pos)
  debug_1255:
    .return (rx1556_cur)
  rx1556_restart:
.annotate 'line', 10
    if_null rx1556_debug, debug_1256
    rx1556_cur."!cursor_debug"("NEXT", "infix:sym<gt>")
  debug_1256:
  rx1556_fail:
    (rx1556_rep, rx1556_pos, $I10, $P10) = rx1556_cur."!mark_fail"(0)
    lt rx1556_pos, -1, rx1556_done
    eq rx1556_pos, -1, rx1556_fail
    jump $I10
  rx1556_done:
    rx1556_cur."!cursor_fail"()
    if_null rx1556_debug, debug_1257
    rx1556_cur."!cursor_debug"("FAIL", "infix:sym<gt>")
  debug_1257:
    .return (rx1556_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<gt>"  :nsentry("!PREFIX__infix:sym<gt>") :subid("349_1300062003.824") :method
.annotate 'line', 10
    $P1558 = self."!PREFIX__!subrule"("O", "gt")
    new $P1559, "ResizablePMCArray"
    push $P1559, $P1558
    .return ($P1559)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=:=>"  :subid("350_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1563_tgt
    .local int rx1563_pos
    .local int rx1563_off
    .local int rx1563_eos
    .local int rx1563_rep
    .local pmc rx1563_cur
    .local pmc rx1563_debug
    (rx1563_cur, rx1563_pos, rx1563_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1563_cur
    .local pmc match
    .lex "$/", match
    length rx1563_eos, rx1563_tgt
    gt rx1563_pos, rx1563_eos, rx1563_done
    set rx1563_off, 0
    lt rx1563_pos, 2, rx1563_start
    sub rx1563_off, rx1563_pos, 1
    substr rx1563_tgt, rx1563_tgt, rx1563_off
  rx1563_start:
    eq $I10, 1, rx1563_restart
    if_null rx1563_debug, debug_1258
    rx1563_cur."!cursor_debug"("START", "infix:sym<=:=>")
  debug_1258:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1567_done
    goto rxscan1567_scan
  rxscan1567_loop:
    (rx1563_pos) = rx1563_cur."from"()
    inc rx1563_pos
    rx1563_cur."!cursor_from"(rx1563_pos)
    ge rx1563_pos, rx1563_eos, rxscan1567_done
  rxscan1567_scan:
    set_addr $I10, rxscan1567_loop
    rx1563_cur."!mark_push"(0, rx1563_pos, $I10)
  rxscan1567_done:
.annotate 'line', 662
  # rx subcapture "sym"
    set_addr $I10, rxcap_1568_fail
    rx1563_cur."!mark_push"(0, rx1563_pos, $I10)
  # rx literal  "=:="
    add $I11, rx1563_pos, 3
    gt $I11, rx1563_eos, rx1563_fail
    sub $I11, rx1563_pos, rx1563_off
    substr $S10, rx1563_tgt, $I11, 3
    ne $S10, "=:=", rx1563_fail
    add rx1563_pos, 3
    set_addr $I10, rxcap_1568_fail
    ($I12, $I11) = rx1563_cur."!mark_peek"($I10)
    rx1563_cur."!cursor_pos"($I11)
    ($P10) = rx1563_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1563_pos, "")
    rx1563_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1568_done
  rxcap_1568_fail:
    goto rx1563_fail
  rxcap_1568_done:
  # rx subrule "O" subtype=capture negate=
    rx1563_cur."!cursor_pos"(rx1563_pos)
    $P10 = rx1563_cur."O"("%relational, :pirop<issame>")
    unless $P10, rx1563_fail
    rx1563_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1563_pos = $P10."pos"()
  # rx pass
    rx1563_cur."!cursor_pass"(rx1563_pos, "infix:sym<=:=>")
    if_null rx1563_debug, debug_1259
    rx1563_cur."!cursor_debug"("PASS", "infix:sym<=:=>", " at pos=", rx1563_pos)
  debug_1259:
    .return (rx1563_cur)
  rx1563_restart:
.annotate 'line', 10
    if_null rx1563_debug, debug_1260
    rx1563_cur."!cursor_debug"("NEXT", "infix:sym<=:=>")
  debug_1260:
  rx1563_fail:
    (rx1563_rep, rx1563_pos, $I10, $P10) = rx1563_cur."!mark_fail"(0)
    lt rx1563_pos, -1, rx1563_done
    eq rx1563_pos, -1, rx1563_fail
    jump $I10
  rx1563_done:
    rx1563_cur."!cursor_fail"()
    if_null rx1563_debug, debug_1261
    rx1563_cur."!cursor_debug"("FAIL", "infix:sym<=:=>")
  debug_1261:
    .return (rx1563_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=:=>"  :nsentry("!PREFIX__infix:sym<=:=>") :subid("351_1300062003.824") :method
.annotate 'line', 10
    $P1565 = self."!PREFIX__!subrule"("O", "=:=")
    new $P1566, "ResizablePMCArray"
    push $P1566, $P1565
    .return ($P1566)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~~>"  :subid("352_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1570_tgt
    .local int rx1570_pos
    .local int rx1570_off
    .local int rx1570_eos
    .local int rx1570_rep
    .local pmc rx1570_cur
    .local pmc rx1570_debug
    (rx1570_cur, rx1570_pos, rx1570_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1570_cur
    .local pmc match
    .lex "$/", match
    length rx1570_eos, rx1570_tgt
    gt rx1570_pos, rx1570_eos, rx1570_done
    set rx1570_off, 0
    lt rx1570_pos, 2, rx1570_start
    sub rx1570_off, rx1570_pos, 1
    substr rx1570_tgt, rx1570_tgt, rx1570_off
  rx1570_start:
    eq $I10, 1, rx1570_restart
    if_null rx1570_debug, debug_1262
    rx1570_cur."!cursor_debug"("START", "infix:sym<~~>")
  debug_1262:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1574_done
    goto rxscan1574_scan
  rxscan1574_loop:
    (rx1570_pos) = rx1570_cur."from"()
    inc rx1570_pos
    rx1570_cur."!cursor_from"(rx1570_pos)
    ge rx1570_pos, rx1570_eos, rxscan1574_done
  rxscan1574_scan:
    set_addr $I10, rxscan1574_loop
    rx1570_cur."!mark_push"(0, rx1570_pos, $I10)
  rxscan1574_done:
.annotate 'line', 663
  # rx subcapture "sym"
    set_addr $I10, rxcap_1575_fail
    rx1570_cur."!mark_push"(0, rx1570_pos, $I10)
  # rx literal  "~~"
    add $I11, rx1570_pos, 2
    gt $I11, rx1570_eos, rx1570_fail
    sub $I11, rx1570_pos, rx1570_off
    substr $S10, rx1570_tgt, $I11, 2
    ne $S10, "~~", rx1570_fail
    add rx1570_pos, 2
    set_addr $I10, rxcap_1575_fail
    ($I12, $I11) = rx1570_cur."!mark_peek"($I10)
    rx1570_cur."!cursor_pos"($I11)
    ($P10) = rx1570_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1570_pos, "")
    rx1570_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1575_done
  rxcap_1575_fail:
    goto rx1570_fail
  rxcap_1575_done:
  # rx subrule "O" subtype=capture negate=
    rx1570_cur."!cursor_pos"(rx1570_pos)
    $P10 = rx1570_cur."O"("%relational, :reducecheck<smartmatch>")
    unless $P10, rx1570_fail
    rx1570_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1570_pos = $P10."pos"()
  # rx pass
    rx1570_cur."!cursor_pass"(rx1570_pos, "infix:sym<~~>")
    if_null rx1570_debug, debug_1263
    rx1570_cur."!cursor_debug"("PASS", "infix:sym<~~>", " at pos=", rx1570_pos)
  debug_1263:
    .return (rx1570_cur)
  rx1570_restart:
.annotate 'line', 10
    if_null rx1570_debug, debug_1264
    rx1570_cur."!cursor_debug"("NEXT", "infix:sym<~~>")
  debug_1264:
  rx1570_fail:
    (rx1570_rep, rx1570_pos, $I10, $P10) = rx1570_cur."!mark_fail"(0)
    lt rx1570_pos, -1, rx1570_done
    eq rx1570_pos, -1, rx1570_fail
    jump $I10
  rx1570_done:
    rx1570_cur."!cursor_fail"()
    if_null rx1570_debug, debug_1265
    rx1570_cur."!cursor_debug"("FAIL", "infix:sym<~~>")
  debug_1265:
    .return (rx1570_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~~>"  :nsentry("!PREFIX__infix:sym<~~>") :subid("353_1300062003.824") :method
.annotate 'line', 10
    $P1572 = self."!PREFIX__!subrule"("O", "~~")
    new $P1573, "ResizablePMCArray"
    push $P1573, $P1572
    .return ($P1573)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<&&>"  :subid("354_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1577_tgt
    .local int rx1577_pos
    .local int rx1577_off
    .local int rx1577_eos
    .local int rx1577_rep
    .local pmc rx1577_cur
    .local pmc rx1577_debug
    (rx1577_cur, rx1577_pos, rx1577_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1577_cur
    .local pmc match
    .lex "$/", match
    length rx1577_eos, rx1577_tgt
    gt rx1577_pos, rx1577_eos, rx1577_done
    set rx1577_off, 0
    lt rx1577_pos, 2, rx1577_start
    sub rx1577_off, rx1577_pos, 1
    substr rx1577_tgt, rx1577_tgt, rx1577_off
  rx1577_start:
    eq $I10, 1, rx1577_restart
    if_null rx1577_debug, debug_1266
    rx1577_cur."!cursor_debug"("START", "infix:sym<&&>")
  debug_1266:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1581_done
    goto rxscan1581_scan
  rxscan1581_loop:
    (rx1577_pos) = rx1577_cur."from"()
    inc rx1577_pos
    rx1577_cur."!cursor_from"(rx1577_pos)
    ge rx1577_pos, rx1577_eos, rxscan1581_done
  rxscan1581_scan:
    set_addr $I10, rxscan1581_loop
    rx1577_cur."!mark_push"(0, rx1577_pos, $I10)
  rxscan1581_done:
.annotate 'line', 665
  # rx subcapture "sym"
    set_addr $I10, rxcap_1582_fail
    rx1577_cur."!mark_push"(0, rx1577_pos, $I10)
  # rx literal  "&&"
    add $I11, rx1577_pos, 2
    gt $I11, rx1577_eos, rx1577_fail
    sub $I11, rx1577_pos, rx1577_off
    substr $S10, rx1577_tgt, $I11, 2
    ne $S10, "&&", rx1577_fail
    add rx1577_pos, 2
    set_addr $I10, rxcap_1582_fail
    ($I12, $I11) = rx1577_cur."!mark_peek"($I10)
    rx1577_cur."!cursor_pos"($I11)
    ($P10) = rx1577_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1577_pos, "")
    rx1577_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1582_done
  rxcap_1582_fail:
    goto rx1577_fail
  rxcap_1582_done:
  # rx subrule "O" subtype=capture negate=
    rx1577_cur."!cursor_pos"(rx1577_pos)
    $P10 = rx1577_cur."O"("%tight_and, :pasttype<if>")
    unless $P10, rx1577_fail
    rx1577_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1577_pos = $P10."pos"()
  # rx pass
    rx1577_cur."!cursor_pass"(rx1577_pos, "infix:sym<&&>")
    if_null rx1577_debug, debug_1267
    rx1577_cur."!cursor_debug"("PASS", "infix:sym<&&>", " at pos=", rx1577_pos)
  debug_1267:
    .return (rx1577_cur)
  rx1577_restart:
.annotate 'line', 10
    if_null rx1577_debug, debug_1268
    rx1577_cur."!cursor_debug"("NEXT", "infix:sym<&&>")
  debug_1268:
  rx1577_fail:
    (rx1577_rep, rx1577_pos, $I10, $P10) = rx1577_cur."!mark_fail"(0)
    lt rx1577_pos, -1, rx1577_done
    eq rx1577_pos, -1, rx1577_fail
    jump $I10
  rx1577_done:
    rx1577_cur."!cursor_fail"()
    if_null rx1577_debug, debug_1269
    rx1577_cur."!cursor_debug"("FAIL", "infix:sym<&&>")
  debug_1269:
    .return (rx1577_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<&&>"  :nsentry("!PREFIX__infix:sym<&&>") :subid("355_1300062003.824") :method
.annotate 'line', 10
    $P1579 = self."!PREFIX__!subrule"("O", "&&")
    new $P1580, "ResizablePMCArray"
    push $P1580, $P1579
    .return ($P1580)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<||>"  :subid("356_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1584_tgt
    .local int rx1584_pos
    .local int rx1584_off
    .local int rx1584_eos
    .local int rx1584_rep
    .local pmc rx1584_cur
    .local pmc rx1584_debug
    (rx1584_cur, rx1584_pos, rx1584_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1584_cur
    .local pmc match
    .lex "$/", match
    length rx1584_eos, rx1584_tgt
    gt rx1584_pos, rx1584_eos, rx1584_done
    set rx1584_off, 0
    lt rx1584_pos, 2, rx1584_start
    sub rx1584_off, rx1584_pos, 1
    substr rx1584_tgt, rx1584_tgt, rx1584_off
  rx1584_start:
    eq $I10, 1, rx1584_restart
    if_null rx1584_debug, debug_1270
    rx1584_cur."!cursor_debug"("START", "infix:sym<||>")
  debug_1270:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1588_done
    goto rxscan1588_scan
  rxscan1588_loop:
    (rx1584_pos) = rx1584_cur."from"()
    inc rx1584_pos
    rx1584_cur."!cursor_from"(rx1584_pos)
    ge rx1584_pos, rx1584_eos, rxscan1588_done
  rxscan1588_scan:
    set_addr $I10, rxscan1588_loop
    rx1584_cur."!mark_push"(0, rx1584_pos, $I10)
  rxscan1588_done:
.annotate 'line', 667
  # rx subcapture "sym"
    set_addr $I10, rxcap_1589_fail
    rx1584_cur."!mark_push"(0, rx1584_pos, $I10)
  # rx literal  "||"
    add $I11, rx1584_pos, 2
    gt $I11, rx1584_eos, rx1584_fail
    sub $I11, rx1584_pos, rx1584_off
    substr $S10, rx1584_tgt, $I11, 2
    ne $S10, "||", rx1584_fail
    add rx1584_pos, 2
    set_addr $I10, rxcap_1589_fail
    ($I12, $I11) = rx1584_cur."!mark_peek"($I10)
    rx1584_cur."!cursor_pos"($I11)
    ($P10) = rx1584_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1584_pos, "")
    rx1584_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1589_done
  rxcap_1589_fail:
    goto rx1584_fail
  rxcap_1589_done:
  # rx subrule "O" subtype=capture negate=
    rx1584_cur."!cursor_pos"(rx1584_pos)
    $P10 = rx1584_cur."O"("%tight_or, :pasttype<unless>")
    unless $P10, rx1584_fail
    rx1584_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1584_pos = $P10."pos"()
  # rx pass
    rx1584_cur."!cursor_pass"(rx1584_pos, "infix:sym<||>")
    if_null rx1584_debug, debug_1271
    rx1584_cur."!cursor_debug"("PASS", "infix:sym<||>", " at pos=", rx1584_pos)
  debug_1271:
    .return (rx1584_cur)
  rx1584_restart:
.annotate 'line', 10
    if_null rx1584_debug, debug_1272
    rx1584_cur."!cursor_debug"("NEXT", "infix:sym<||>")
  debug_1272:
  rx1584_fail:
    (rx1584_rep, rx1584_pos, $I10, $P10) = rx1584_cur."!mark_fail"(0)
    lt rx1584_pos, -1, rx1584_done
    eq rx1584_pos, -1, rx1584_fail
    jump $I10
  rx1584_done:
    rx1584_cur."!cursor_fail"()
    if_null rx1584_debug, debug_1273
    rx1584_cur."!cursor_debug"("FAIL", "infix:sym<||>")
  debug_1273:
    .return (rx1584_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<||>"  :nsentry("!PREFIX__infix:sym<||>") :subid("357_1300062003.824") :method
.annotate 'line', 10
    $P1586 = self."!PREFIX__!subrule"("O", "||")
    new $P1587, "ResizablePMCArray"
    push $P1587, $P1586
    .return ($P1587)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<//>"  :subid("358_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1591_tgt
    .local int rx1591_pos
    .local int rx1591_off
    .local int rx1591_eos
    .local int rx1591_rep
    .local pmc rx1591_cur
    .local pmc rx1591_debug
    (rx1591_cur, rx1591_pos, rx1591_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1591_cur
    .local pmc match
    .lex "$/", match
    length rx1591_eos, rx1591_tgt
    gt rx1591_pos, rx1591_eos, rx1591_done
    set rx1591_off, 0
    lt rx1591_pos, 2, rx1591_start
    sub rx1591_off, rx1591_pos, 1
    substr rx1591_tgt, rx1591_tgt, rx1591_off
  rx1591_start:
    eq $I10, 1, rx1591_restart
    if_null rx1591_debug, debug_1274
    rx1591_cur."!cursor_debug"("START", "infix:sym<//>")
  debug_1274:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1595_done
    goto rxscan1595_scan
  rxscan1595_loop:
    (rx1591_pos) = rx1591_cur."from"()
    inc rx1591_pos
    rx1591_cur."!cursor_from"(rx1591_pos)
    ge rx1591_pos, rx1591_eos, rxscan1595_done
  rxscan1595_scan:
    set_addr $I10, rxscan1595_loop
    rx1591_cur."!mark_push"(0, rx1591_pos, $I10)
  rxscan1595_done:
.annotate 'line', 668
  # rx subcapture "sym"
    set_addr $I10, rxcap_1596_fail
    rx1591_cur."!mark_push"(0, rx1591_pos, $I10)
  # rx literal  "//"
    add $I11, rx1591_pos, 2
    gt $I11, rx1591_eos, rx1591_fail
    sub $I11, rx1591_pos, rx1591_off
    substr $S10, rx1591_tgt, $I11, 2
    ne $S10, "//", rx1591_fail
    add rx1591_pos, 2
    set_addr $I10, rxcap_1596_fail
    ($I12, $I11) = rx1591_cur."!mark_peek"($I10)
    rx1591_cur."!cursor_pos"($I11)
    ($P10) = rx1591_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1591_pos, "")
    rx1591_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1596_done
  rxcap_1596_fail:
    goto rx1591_fail
  rxcap_1596_done:
  # rx subrule "O" subtype=capture negate=
    rx1591_cur."!cursor_pos"(rx1591_pos)
    $P10 = rx1591_cur."O"("%tight_or, :pasttype<def_or>")
    unless $P10, rx1591_fail
    rx1591_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1591_pos = $P10."pos"()
  # rx pass
    rx1591_cur."!cursor_pass"(rx1591_pos, "infix:sym<//>")
    if_null rx1591_debug, debug_1275
    rx1591_cur."!cursor_debug"("PASS", "infix:sym<//>", " at pos=", rx1591_pos)
  debug_1275:
    .return (rx1591_cur)
  rx1591_restart:
.annotate 'line', 10
    if_null rx1591_debug, debug_1276
    rx1591_cur."!cursor_debug"("NEXT", "infix:sym<//>")
  debug_1276:
  rx1591_fail:
    (rx1591_rep, rx1591_pos, $I10, $P10) = rx1591_cur."!mark_fail"(0)
    lt rx1591_pos, -1, rx1591_done
    eq rx1591_pos, -1, rx1591_fail
    jump $I10
  rx1591_done:
    rx1591_cur."!cursor_fail"()
    if_null rx1591_debug, debug_1277
    rx1591_cur."!cursor_debug"("FAIL", "infix:sym<//>")
  debug_1277:
    .return (rx1591_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<//>"  :nsentry("!PREFIX__infix:sym<//>") :subid("359_1300062003.824") :method
.annotate 'line', 10
    $P1593 = self."!PREFIX__!subrule"("O", "//")
    new $P1594, "ResizablePMCArray"
    push $P1594, $P1593
    .return ($P1594)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<?? !!>"  :subid("360_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1598_tgt
    .local int rx1598_pos
    .local int rx1598_off
    .local int rx1598_eos
    .local int rx1598_rep
    .local pmc rx1598_cur
    .local pmc rx1598_debug
    (rx1598_cur, rx1598_pos, rx1598_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1598_cur
    .local pmc match
    .lex "$/", match
    length rx1598_eos, rx1598_tgt
    gt rx1598_pos, rx1598_eos, rx1598_done
    set rx1598_off, 0
    lt rx1598_pos, 2, rx1598_start
    sub rx1598_off, rx1598_pos, 1
    substr rx1598_tgt, rx1598_tgt, rx1598_off
  rx1598_start:
    eq $I10, 1, rx1598_restart
    if_null rx1598_debug, debug_1278
    rx1598_cur."!cursor_debug"("START", "infix:sym<?? !!>")
  debug_1278:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1602_done
    goto rxscan1602_scan
  rxscan1602_loop:
    (rx1598_pos) = rx1598_cur."from"()
    inc rx1598_pos
    rx1598_cur."!cursor_from"(rx1598_pos)
    ge rx1598_pos, rx1598_eos, rxscan1602_done
  rxscan1602_scan:
    set_addr $I10, rxscan1602_loop
    rx1598_cur."!mark_push"(0, rx1598_pos, $I10)
  rxscan1602_done:
.annotate 'line', 671
  # rx literal  "??"
    add $I11, rx1598_pos, 2
    gt $I11, rx1598_eos, rx1598_fail
    sub $I11, rx1598_pos, rx1598_off
    substr $S10, rx1598_tgt, $I11, 2
    ne $S10, "??", rx1598_fail
    add rx1598_pos, 2
.annotate 'line', 672
  # rx subrule "ws" subtype=method negate=
    rx1598_cur."!cursor_pos"(rx1598_pos)
    $P10 = rx1598_cur."ws"()
    unless $P10, rx1598_fail
    rx1598_pos = $P10."pos"()
.annotate 'line', 673
  # rx subrule "EXPR" subtype=capture negate=
    rx1598_cur."!cursor_pos"(rx1598_pos)
    $P10 = rx1598_cur."EXPR"("i=")
    unless $P10, rx1598_fail
    rx1598_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1598_pos = $P10."pos"()
.annotate 'line', 674
  # rx literal  "!!"
    add $I11, rx1598_pos, 2
    gt $I11, rx1598_eos, rx1598_fail
    sub $I11, rx1598_pos, rx1598_off
    substr $S10, rx1598_tgt, $I11, 2
    ne $S10, "!!", rx1598_fail
    add rx1598_pos, 2
.annotate 'line', 675
  # rx subrule "O" subtype=capture negate=
    rx1598_cur."!cursor_pos"(rx1598_pos)
    $P10 = rx1598_cur."O"("%conditional, :reducecheck<ternary>, :pasttype<if>")
    unless $P10, rx1598_fail
    rx1598_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1598_pos = $P10."pos"()
.annotate 'line', 670
  # rx pass
    rx1598_cur."!cursor_pass"(rx1598_pos, "infix:sym<?? !!>")
    if_null rx1598_debug, debug_1279
    rx1598_cur."!cursor_debug"("PASS", "infix:sym<?? !!>", " at pos=", rx1598_pos)
  debug_1279:
    .return (rx1598_cur)
  rx1598_restart:
.annotate 'line', 10
    if_null rx1598_debug, debug_1280
    rx1598_cur."!cursor_debug"("NEXT", "infix:sym<?? !!>")
  debug_1280:
  rx1598_fail:
    (rx1598_rep, rx1598_pos, $I10, $P10) = rx1598_cur."!mark_fail"(0)
    lt rx1598_pos, -1, rx1598_done
    eq rx1598_pos, -1, rx1598_fail
    jump $I10
  rx1598_done:
    rx1598_cur."!cursor_fail"()
    if_null rx1598_debug, debug_1281
    rx1598_cur."!cursor_debug"("FAIL", "infix:sym<?? !!>")
  debug_1281:
    .return (rx1598_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<?? !!>"  :nsentry("!PREFIX__infix:sym<?? !!>") :subid("361_1300062003.824") :method
.annotate 'line', 10
    $P1600 = self."!PREFIX__!subrule"("ws", "??")
    new $P1601, "ResizablePMCArray"
    push $P1601, $P1600
    .return ($P1601)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=>"  :subid("362_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1604_tgt
    .local int rx1604_pos
    .local int rx1604_off
    .local int rx1604_eos
    .local int rx1604_rep
    .local pmc rx1604_cur
    .local pmc rx1604_debug
    (rx1604_cur, rx1604_pos, rx1604_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1604_cur
    .local pmc match
    .lex "$/", match
    length rx1604_eos, rx1604_tgt
    gt rx1604_pos, rx1604_eos, rx1604_done
    set rx1604_off, 0
    lt rx1604_pos, 2, rx1604_start
    sub rx1604_off, rx1604_pos, 1
    substr rx1604_tgt, rx1604_tgt, rx1604_off
  rx1604_start:
    eq $I10, 1, rx1604_restart
    if_null rx1604_debug, debug_1282
    rx1604_cur."!cursor_debug"("START", "infix:sym<=>")
  debug_1282:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1608_done
    goto rxscan1608_scan
  rxscan1608_loop:
    (rx1604_pos) = rx1604_cur."from"()
    inc rx1604_pos
    rx1604_cur."!cursor_from"(rx1604_pos)
    ge rx1604_pos, rx1604_eos, rxscan1608_done
  rxscan1608_scan:
    set_addr $I10, rxscan1608_loop
    rx1604_cur."!mark_push"(0, rx1604_pos, $I10)
  rxscan1608_done:
.annotate 'line', 679
  # rx subcapture "sym"
    set_addr $I10, rxcap_1609_fail
    rx1604_cur."!mark_push"(0, rx1604_pos, $I10)
  # rx literal  "="
    add $I11, rx1604_pos, 1
    gt $I11, rx1604_eos, rx1604_fail
    sub $I11, rx1604_pos, rx1604_off
    ord $I11, rx1604_tgt, $I11
    ne $I11, 61, rx1604_fail
    add rx1604_pos, 1
    set_addr $I10, rxcap_1609_fail
    ($I12, $I11) = rx1604_cur."!mark_peek"($I10)
    rx1604_cur."!cursor_pos"($I11)
    ($P10) = rx1604_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1604_pos, "")
    rx1604_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1609_done
  rxcap_1609_fail:
    goto rx1604_fail
  rxcap_1609_done:
  # rx subrule "panic" subtype=method negate=
    rx1604_cur."!cursor_pos"(rx1604_pos)
    $P10 = rx1604_cur."panic"("Assignment (\"=\") not supported in NQP, use \":=\" instead")
    unless $P10, rx1604_fail
    rx1604_pos = $P10."pos"()
.annotate 'line', 678
  # rx pass
    rx1604_cur."!cursor_pass"(rx1604_pos, "infix:sym<=>")
    if_null rx1604_debug, debug_1283
    rx1604_cur."!cursor_debug"("PASS", "infix:sym<=>", " at pos=", rx1604_pos)
  debug_1283:
    .return (rx1604_cur)
  rx1604_restart:
.annotate 'line', 10
    if_null rx1604_debug, debug_1284
    rx1604_cur."!cursor_debug"("NEXT", "infix:sym<=>")
  debug_1284:
  rx1604_fail:
    (rx1604_rep, rx1604_pos, $I10, $P10) = rx1604_cur."!mark_fail"(0)
    lt rx1604_pos, -1, rx1604_done
    eq rx1604_pos, -1, rx1604_fail
    jump $I10
  rx1604_done:
    rx1604_cur."!cursor_fail"()
    if_null rx1604_debug, debug_1285
    rx1604_cur."!cursor_debug"("FAIL", "infix:sym<=>")
  debug_1285:
    .return (rx1604_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=>"  :nsentry("!PREFIX__infix:sym<=>") :subid("363_1300062003.824") :method
.annotate 'line', 10
    $P1606 = self."!PREFIX__!subrule"("panic", "=")
    new $P1607, "ResizablePMCArray"
    push $P1607, $P1606
    .return ($P1607)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<:=>"  :subid("364_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1611_tgt
    .local int rx1611_pos
    .local int rx1611_off
    .local int rx1611_eos
    .local int rx1611_rep
    .local pmc rx1611_cur
    .local pmc rx1611_debug
    (rx1611_cur, rx1611_pos, rx1611_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1611_cur
    .local pmc match
    .lex "$/", match
    length rx1611_eos, rx1611_tgt
    gt rx1611_pos, rx1611_eos, rx1611_done
    set rx1611_off, 0
    lt rx1611_pos, 2, rx1611_start
    sub rx1611_off, rx1611_pos, 1
    substr rx1611_tgt, rx1611_tgt, rx1611_off
  rx1611_start:
    eq $I10, 1, rx1611_restart
    if_null rx1611_debug, debug_1286
    rx1611_cur."!cursor_debug"("START", "infix:sym<:=>")
  debug_1286:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1615_done
    goto rxscan1615_scan
  rxscan1615_loop:
    (rx1611_pos) = rx1611_cur."from"()
    inc rx1611_pos
    rx1611_cur."!cursor_from"(rx1611_pos)
    ge rx1611_pos, rx1611_eos, rxscan1615_done
  rxscan1615_scan:
    set_addr $I10, rxscan1615_loop
    rx1611_cur."!mark_push"(0, rx1611_pos, $I10)
  rxscan1615_done:
.annotate 'line', 681
  # rx subcapture "sym"
    set_addr $I10, rxcap_1616_fail
    rx1611_cur."!mark_push"(0, rx1611_pos, $I10)
  # rx literal  ":="
    add $I11, rx1611_pos, 2
    gt $I11, rx1611_eos, rx1611_fail
    sub $I11, rx1611_pos, rx1611_off
    substr $S10, rx1611_tgt, $I11, 2
    ne $S10, ":=", rx1611_fail
    add rx1611_pos, 2
    set_addr $I10, rxcap_1616_fail
    ($I12, $I11) = rx1611_cur."!mark_peek"($I10)
    rx1611_cur."!cursor_pos"($I11)
    ($P10) = rx1611_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1611_pos, "")
    rx1611_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1616_done
  rxcap_1616_fail:
    goto rx1611_fail
  rxcap_1616_done:
  # rx subrule "O" subtype=capture negate=
    rx1611_cur."!cursor_pos"(rx1611_pos)
    $P10 = rx1611_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx1611_fail
    rx1611_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1611_pos = $P10."pos"()
  # rx pass
    rx1611_cur."!cursor_pass"(rx1611_pos, "infix:sym<:=>")
    if_null rx1611_debug, debug_1287
    rx1611_cur."!cursor_debug"("PASS", "infix:sym<:=>", " at pos=", rx1611_pos)
  debug_1287:
    .return (rx1611_cur)
  rx1611_restart:
.annotate 'line', 10
    if_null rx1611_debug, debug_1288
    rx1611_cur."!cursor_debug"("NEXT", "infix:sym<:=>")
  debug_1288:
  rx1611_fail:
    (rx1611_rep, rx1611_pos, $I10, $P10) = rx1611_cur."!mark_fail"(0)
    lt rx1611_pos, -1, rx1611_done
    eq rx1611_pos, -1, rx1611_fail
    jump $I10
  rx1611_done:
    rx1611_cur."!cursor_fail"()
    if_null rx1611_debug, debug_1289
    rx1611_cur."!cursor_debug"("FAIL", "infix:sym<:=>")
  debug_1289:
    .return (rx1611_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<:=>"  :nsentry("!PREFIX__infix:sym<:=>") :subid("365_1300062003.824") :method
.annotate 'line', 10
    $P1613 = self."!PREFIX__!subrule"("O", ":=")
    new $P1614, "ResizablePMCArray"
    push $P1614, $P1613
    .return ($P1614)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<::=>"  :subid("366_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1618_tgt
    .local int rx1618_pos
    .local int rx1618_off
    .local int rx1618_eos
    .local int rx1618_rep
    .local pmc rx1618_cur
    .local pmc rx1618_debug
    (rx1618_cur, rx1618_pos, rx1618_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1618_cur
    .local pmc match
    .lex "$/", match
    length rx1618_eos, rx1618_tgt
    gt rx1618_pos, rx1618_eos, rx1618_done
    set rx1618_off, 0
    lt rx1618_pos, 2, rx1618_start
    sub rx1618_off, rx1618_pos, 1
    substr rx1618_tgt, rx1618_tgt, rx1618_off
  rx1618_start:
    eq $I10, 1, rx1618_restart
    if_null rx1618_debug, debug_1290
    rx1618_cur."!cursor_debug"("START", "infix:sym<::=>")
  debug_1290:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1622_done
    goto rxscan1622_scan
  rxscan1622_loop:
    (rx1618_pos) = rx1618_cur."from"()
    inc rx1618_pos
    rx1618_cur."!cursor_from"(rx1618_pos)
    ge rx1618_pos, rx1618_eos, rxscan1622_done
  rxscan1622_scan:
    set_addr $I10, rxscan1622_loop
    rx1618_cur."!mark_push"(0, rx1618_pos, $I10)
  rxscan1622_done:
.annotate 'line', 682
  # rx subcapture "sym"
    set_addr $I10, rxcap_1623_fail
    rx1618_cur."!mark_push"(0, rx1618_pos, $I10)
  # rx literal  "::="
    add $I11, rx1618_pos, 3
    gt $I11, rx1618_eos, rx1618_fail
    sub $I11, rx1618_pos, rx1618_off
    substr $S10, rx1618_tgt, $I11, 3
    ne $S10, "::=", rx1618_fail
    add rx1618_pos, 3
    set_addr $I10, rxcap_1623_fail
    ($I12, $I11) = rx1618_cur."!mark_peek"($I10)
    rx1618_cur."!cursor_pos"($I11)
    ($P10) = rx1618_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1618_pos, "")
    rx1618_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1623_done
  rxcap_1623_fail:
    goto rx1618_fail
  rxcap_1623_done:
  # rx subrule "O" subtype=capture negate=
    rx1618_cur."!cursor_pos"(rx1618_pos)
    $P10 = rx1618_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx1618_fail
    rx1618_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1618_pos = $P10."pos"()
  # rx pass
    rx1618_cur."!cursor_pass"(rx1618_pos, "infix:sym<::=>")
    if_null rx1618_debug, debug_1291
    rx1618_cur."!cursor_debug"("PASS", "infix:sym<::=>", " at pos=", rx1618_pos)
  debug_1291:
    .return (rx1618_cur)
  rx1618_restart:
.annotate 'line', 10
    if_null rx1618_debug, debug_1292
    rx1618_cur."!cursor_debug"("NEXT", "infix:sym<::=>")
  debug_1292:
  rx1618_fail:
    (rx1618_rep, rx1618_pos, $I10, $P10) = rx1618_cur."!mark_fail"(0)
    lt rx1618_pos, -1, rx1618_done
    eq rx1618_pos, -1, rx1618_fail
    jump $I10
  rx1618_done:
    rx1618_cur."!cursor_fail"()
    if_null rx1618_debug, debug_1293
    rx1618_cur."!cursor_debug"("FAIL", "infix:sym<::=>")
  debug_1293:
    .return (rx1618_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<::=>"  :nsentry("!PREFIX__infix:sym<::=>") :subid("367_1300062003.824") :method
.annotate 'line', 10
    $P1620 = self."!PREFIX__!subrule"("O", "::=")
    new $P1621, "ResizablePMCArray"
    push $P1621, $P1620
    .return ($P1621)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<,>"  :subid("368_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1625_tgt
    .local int rx1625_pos
    .local int rx1625_off
    .local int rx1625_eos
    .local int rx1625_rep
    .local pmc rx1625_cur
    .local pmc rx1625_debug
    (rx1625_cur, rx1625_pos, rx1625_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1625_cur
    .local pmc match
    .lex "$/", match
    length rx1625_eos, rx1625_tgt
    gt rx1625_pos, rx1625_eos, rx1625_done
    set rx1625_off, 0
    lt rx1625_pos, 2, rx1625_start
    sub rx1625_off, rx1625_pos, 1
    substr rx1625_tgt, rx1625_tgt, rx1625_off
  rx1625_start:
    eq $I10, 1, rx1625_restart
    if_null rx1625_debug, debug_1294
    rx1625_cur."!cursor_debug"("START", "infix:sym<,>")
  debug_1294:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1629_done
    goto rxscan1629_scan
  rxscan1629_loop:
    (rx1625_pos) = rx1625_cur."from"()
    inc rx1625_pos
    rx1625_cur."!cursor_from"(rx1625_pos)
    ge rx1625_pos, rx1625_eos, rxscan1629_done
  rxscan1629_scan:
    set_addr $I10, rxscan1629_loop
    rx1625_cur."!mark_push"(0, rx1625_pos, $I10)
  rxscan1629_done:
.annotate 'line', 684
  # rx subcapture "sym"
    set_addr $I10, rxcap_1630_fail
    rx1625_cur."!mark_push"(0, rx1625_pos, $I10)
  # rx literal  ","
    add $I11, rx1625_pos, 1
    gt $I11, rx1625_eos, rx1625_fail
    sub $I11, rx1625_pos, rx1625_off
    ord $I11, rx1625_tgt, $I11
    ne $I11, 44, rx1625_fail
    add rx1625_pos, 1
    set_addr $I10, rxcap_1630_fail
    ($I12, $I11) = rx1625_cur."!mark_peek"($I10)
    rx1625_cur."!cursor_pos"($I11)
    ($P10) = rx1625_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1625_pos, "")
    rx1625_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1630_done
  rxcap_1630_fail:
    goto rx1625_fail
  rxcap_1630_done:
  # rx subrule "O" subtype=capture negate=
    rx1625_cur."!cursor_pos"(rx1625_pos)
    $P10 = rx1625_cur."O"("%comma, :pasttype<list>")
    unless $P10, rx1625_fail
    rx1625_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1625_pos = $P10."pos"()
  # rx pass
    rx1625_cur."!cursor_pass"(rx1625_pos, "infix:sym<,>")
    if_null rx1625_debug, debug_1295
    rx1625_cur."!cursor_debug"("PASS", "infix:sym<,>", " at pos=", rx1625_pos)
  debug_1295:
    .return (rx1625_cur)
  rx1625_restart:
.annotate 'line', 10
    if_null rx1625_debug, debug_1296
    rx1625_cur."!cursor_debug"("NEXT", "infix:sym<,>")
  debug_1296:
  rx1625_fail:
    (rx1625_rep, rx1625_pos, $I10, $P10) = rx1625_cur."!mark_fail"(0)
    lt rx1625_pos, -1, rx1625_done
    eq rx1625_pos, -1, rx1625_fail
    jump $I10
  rx1625_done:
    rx1625_cur."!cursor_fail"()
    if_null rx1625_debug, debug_1297
    rx1625_cur."!cursor_debug"("FAIL", "infix:sym<,>")
  debug_1297:
    .return (rx1625_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<,>"  :nsentry("!PREFIX__infix:sym<,>") :subid("369_1300062003.824") :method
.annotate 'line', 10
    $P1627 = self."!PREFIX__!subrule"("O", ",")
    new $P1628, "ResizablePMCArray"
    push $P1628, $P1627
    .return ($P1628)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<return>"  :subid("370_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .const 'Sub' $P1640 = "372_1300062003.824" 
    capture_lex $P1640
    .local string rx1632_tgt
    .local int rx1632_pos
    .local int rx1632_off
    .local int rx1632_eos
    .local int rx1632_rep
    .local pmc rx1632_cur
    .local pmc rx1632_debug
    (rx1632_cur, rx1632_pos, rx1632_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1632_cur
    .local pmc match
    .lex "$/", match
    length rx1632_eos, rx1632_tgt
    gt rx1632_pos, rx1632_eos, rx1632_done
    set rx1632_off, 0
    lt rx1632_pos, 2, rx1632_start
    sub rx1632_off, rx1632_pos, 1
    substr rx1632_tgt, rx1632_tgt, rx1632_off
  rx1632_start:
    eq $I10, 1, rx1632_restart
    if_null rx1632_debug, debug_1298
    rx1632_cur."!cursor_debug"("START", "prefix:sym<return>")
  debug_1298:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1635_done
    goto rxscan1635_scan
  rxscan1635_loop:
    (rx1632_pos) = rx1632_cur."from"()
    inc rx1632_pos
    rx1632_cur."!cursor_from"(rx1632_pos)
    ge rx1632_pos, rx1632_eos, rxscan1635_done
  rxscan1635_scan:
    set_addr $I10, rxscan1635_loop
    rx1632_cur."!mark_push"(0, rx1632_pos, $I10)
  rxscan1635_done:
.annotate 'line', 686
  # rx subcapture "sym"
    set_addr $I10, rxcap_1636_fail
    rx1632_cur."!mark_push"(0, rx1632_pos, $I10)
  # rx literal  "return"
    add $I11, rx1632_pos, 6
    gt $I11, rx1632_eos, rx1632_fail
    sub $I11, rx1632_pos, rx1632_off
    substr $S10, rx1632_tgt, $I11, 6
    ne $S10, "return", rx1632_fail
    add rx1632_pos, 6
    set_addr $I10, rxcap_1636_fail
    ($I12, $I11) = rx1632_cur."!mark_peek"($I10)
    rx1632_cur."!cursor_pos"($I11)
    ($P10) = rx1632_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1632_pos, "")
    rx1632_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1636_done
  rxcap_1636_fail:
    goto rx1632_fail
  rxcap_1636_done:
  # rx charclass s
    ge rx1632_pos, rx1632_eos, rx1632_fail
    sub $I10, rx1632_pos, rx1632_off
    is_cclass $I11, 32, rx1632_tgt, $I10
    unless $I11, rx1632_fail
    inc rx1632_pos
  # rx subrule "O" subtype=capture negate=
    rx1632_cur."!cursor_pos"(rx1632_pos)
    $P10 = rx1632_cur."O"("%list_prefix, :pasttype<return>")
    unless $P10, rx1632_fail
    rx1632_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1632_pos = $P10."pos"()
    rx1632_cur."!cursor_pos"(rx1632_pos)
    find_lex $P1637, unicode:"$\x{a2}"
    $P1638 = $P1637."MATCH"()
    store_lex "$/", $P1638
    .const 'Sub' $P1640 = "372_1300062003.824" 
    capture_lex $P1640
    $P1642 = $P1640()
  # rx pass
    rx1632_cur."!cursor_pass"(rx1632_pos, "prefix:sym<return>")
    if_null rx1632_debug, debug_1299
    rx1632_cur."!cursor_debug"("PASS", "prefix:sym<return>", " at pos=", rx1632_pos)
  debug_1299:
    .return (rx1632_cur)
  rx1632_restart:
.annotate 'line', 10
    if_null rx1632_debug, debug_1300
    rx1632_cur."!cursor_debug"("NEXT", "prefix:sym<return>")
  debug_1300:
  rx1632_fail:
    (rx1632_rep, rx1632_pos, $I10, $P10) = rx1632_cur."!mark_fail"(0)
    lt rx1632_pos, -1, rx1632_done
    eq rx1632_pos, -1, rx1632_fail
    jump $I10
  rx1632_done:
    rx1632_cur."!cursor_fail"()
    if_null rx1632_debug, debug_1301
    rx1632_cur."!cursor_debug"("FAIL", "prefix:sym<return>")
  debug_1301:
    .return (rx1632_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<return>"  :nsentry("!PREFIX__prefix:sym<return>") :subid("371_1300062003.824") :method
.annotate 'line', 10
    new $P1634, "ResizablePMCArray"
    push $P1634, "return"
    .return ($P1634)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1639"  :anon :subid("372_1300062003.824") :outer("370_1300062003.824")
.annotate 'line', 686
    new $P1641, "Integer"
    assign $P1641, 1
    store_dynamic_lex "$*RETURN_USED", $P1641
    .return ($P1641)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<make>"  :subid("373_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1644_tgt
    .local int rx1644_pos
    .local int rx1644_off
    .local int rx1644_eos
    .local int rx1644_rep
    .local pmc rx1644_cur
    .local pmc rx1644_debug
    (rx1644_cur, rx1644_pos, rx1644_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1644_cur
    .local pmc match
    .lex "$/", match
    length rx1644_eos, rx1644_tgt
    gt rx1644_pos, rx1644_eos, rx1644_done
    set rx1644_off, 0
    lt rx1644_pos, 2, rx1644_start
    sub rx1644_off, rx1644_pos, 1
    substr rx1644_tgt, rx1644_tgt, rx1644_off
  rx1644_start:
    eq $I10, 1, rx1644_restart
    if_null rx1644_debug, debug_1302
    rx1644_cur."!cursor_debug"("START", "prefix:sym<make>")
  debug_1302:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1647_done
    goto rxscan1647_scan
  rxscan1647_loop:
    (rx1644_pos) = rx1644_cur."from"()
    inc rx1644_pos
    rx1644_cur."!cursor_from"(rx1644_pos)
    ge rx1644_pos, rx1644_eos, rxscan1647_done
  rxscan1647_scan:
    set_addr $I10, rxscan1647_loop
    rx1644_cur."!mark_push"(0, rx1644_pos, $I10)
  rxscan1647_done:
.annotate 'line', 687
  # rx subcapture "sym"
    set_addr $I10, rxcap_1648_fail
    rx1644_cur."!mark_push"(0, rx1644_pos, $I10)
  # rx literal  "make"
    add $I11, rx1644_pos, 4
    gt $I11, rx1644_eos, rx1644_fail
    sub $I11, rx1644_pos, rx1644_off
    substr $S10, rx1644_tgt, $I11, 4
    ne $S10, "make", rx1644_fail
    add rx1644_pos, 4
    set_addr $I10, rxcap_1648_fail
    ($I12, $I11) = rx1644_cur."!mark_peek"($I10)
    rx1644_cur."!cursor_pos"($I11)
    ($P10) = rx1644_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1644_pos, "")
    rx1644_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1648_done
  rxcap_1648_fail:
    goto rx1644_fail
  rxcap_1648_done:
  # rx charclass s
    ge rx1644_pos, rx1644_eos, rx1644_fail
    sub $I10, rx1644_pos, rx1644_off
    is_cclass $I11, 32, rx1644_tgt, $I10
    unless $I11, rx1644_fail
    inc rx1644_pos
  # rx subrule "O" subtype=capture negate=
    rx1644_cur."!cursor_pos"(rx1644_pos)
    $P10 = rx1644_cur."O"("%list_prefix")
    unless $P10, rx1644_fail
    rx1644_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1644_pos = $P10."pos"()
  # rx pass
    rx1644_cur."!cursor_pass"(rx1644_pos, "prefix:sym<make>")
    if_null rx1644_debug, debug_1303
    rx1644_cur."!cursor_debug"("PASS", "prefix:sym<make>", " at pos=", rx1644_pos)
  debug_1303:
    .return (rx1644_cur)
  rx1644_restart:
.annotate 'line', 10
    if_null rx1644_debug, debug_1304
    rx1644_cur."!cursor_debug"("NEXT", "prefix:sym<make>")
  debug_1304:
  rx1644_fail:
    (rx1644_rep, rx1644_pos, $I10, $P10) = rx1644_cur."!mark_fail"(0)
    lt rx1644_pos, -1, rx1644_done
    eq rx1644_pos, -1, rx1644_fail
    jump $I10
  rx1644_done:
    rx1644_cur."!cursor_fail"()
    if_null rx1644_debug, debug_1305
    rx1644_cur."!cursor_debug"("FAIL", "prefix:sym<make>")
  debug_1305:
    .return (rx1644_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<make>"  :nsentry("!PREFIX__prefix:sym<make>") :subid("374_1300062003.824") :method
.annotate 'line', 10
    new $P1646, "ResizablePMCArray"
    push $P1646, "make"
    .return ($P1646)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<last>"  :subid("375_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1650_tgt
    .local int rx1650_pos
    .local int rx1650_off
    .local int rx1650_eos
    .local int rx1650_rep
    .local pmc rx1650_cur
    .local pmc rx1650_debug
    (rx1650_cur, rx1650_pos, rx1650_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1650_cur
    .local pmc match
    .lex "$/", match
    length rx1650_eos, rx1650_tgt
    gt rx1650_pos, rx1650_eos, rx1650_done
    set rx1650_off, 0
    lt rx1650_pos, 2, rx1650_start
    sub rx1650_off, rx1650_pos, 1
    substr rx1650_tgt, rx1650_tgt, rx1650_off
  rx1650_start:
    eq $I10, 1, rx1650_restart
    if_null rx1650_debug, debug_1306
    rx1650_cur."!cursor_debug"("START", "term:sym<last>")
  debug_1306:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1653_done
    goto rxscan1653_scan
  rxscan1653_loop:
    (rx1650_pos) = rx1650_cur."from"()
    inc rx1650_pos
    rx1650_cur."!cursor_from"(rx1650_pos)
    ge rx1650_pos, rx1650_eos, rxscan1653_done
  rxscan1653_scan:
    set_addr $I10, rxscan1653_loop
    rx1650_cur."!mark_push"(0, rx1650_pos, $I10)
  rxscan1653_done:
.annotate 'line', 688
  # rx subcapture "sym"
    set_addr $I10, rxcap_1654_fail
    rx1650_cur."!mark_push"(0, rx1650_pos, $I10)
  # rx literal  "last"
    add $I11, rx1650_pos, 4
    gt $I11, rx1650_eos, rx1650_fail
    sub $I11, rx1650_pos, rx1650_off
    substr $S10, rx1650_tgt, $I11, 4
    ne $S10, "last", rx1650_fail
    add rx1650_pos, 4
    set_addr $I10, rxcap_1654_fail
    ($I12, $I11) = rx1650_cur."!mark_peek"($I10)
    rx1650_cur."!cursor_pos"($I11)
    ($P10) = rx1650_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1650_pos, "")
    rx1650_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1654_done
  rxcap_1654_fail:
    goto rx1650_fail
  rxcap_1654_done:
  # rx pass
    rx1650_cur."!cursor_pass"(rx1650_pos, "term:sym<last>")
    if_null rx1650_debug, debug_1307
    rx1650_cur."!cursor_debug"("PASS", "term:sym<last>", " at pos=", rx1650_pos)
  debug_1307:
    .return (rx1650_cur)
  rx1650_restart:
.annotate 'line', 10
    if_null rx1650_debug, debug_1308
    rx1650_cur."!cursor_debug"("NEXT", "term:sym<last>")
  debug_1308:
  rx1650_fail:
    (rx1650_rep, rx1650_pos, $I10, $P10) = rx1650_cur."!mark_fail"(0)
    lt rx1650_pos, -1, rx1650_done
    eq rx1650_pos, -1, rx1650_fail
    jump $I10
  rx1650_done:
    rx1650_cur."!cursor_fail"()
    if_null rx1650_debug, debug_1309
    rx1650_cur."!cursor_debug"("FAIL", "term:sym<last>")
  debug_1309:
    .return (rx1650_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<last>"  :nsentry("!PREFIX__term:sym<last>") :subid("376_1300062003.824") :method
.annotate 'line', 10
    new $P1652, "ResizablePMCArray"
    push $P1652, "last"
    .return ($P1652)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<next>"  :subid("377_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1656_tgt
    .local int rx1656_pos
    .local int rx1656_off
    .local int rx1656_eos
    .local int rx1656_rep
    .local pmc rx1656_cur
    .local pmc rx1656_debug
    (rx1656_cur, rx1656_pos, rx1656_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1656_cur
    .local pmc match
    .lex "$/", match
    length rx1656_eos, rx1656_tgt
    gt rx1656_pos, rx1656_eos, rx1656_done
    set rx1656_off, 0
    lt rx1656_pos, 2, rx1656_start
    sub rx1656_off, rx1656_pos, 1
    substr rx1656_tgt, rx1656_tgt, rx1656_off
  rx1656_start:
    eq $I10, 1, rx1656_restart
    if_null rx1656_debug, debug_1310
    rx1656_cur."!cursor_debug"("START", "term:sym<next>")
  debug_1310:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1659_done
    goto rxscan1659_scan
  rxscan1659_loop:
    (rx1656_pos) = rx1656_cur."from"()
    inc rx1656_pos
    rx1656_cur."!cursor_from"(rx1656_pos)
    ge rx1656_pos, rx1656_eos, rxscan1659_done
  rxscan1659_scan:
    set_addr $I10, rxscan1659_loop
    rx1656_cur."!mark_push"(0, rx1656_pos, $I10)
  rxscan1659_done:
.annotate 'line', 689
  # rx subcapture "sym"
    set_addr $I10, rxcap_1660_fail
    rx1656_cur."!mark_push"(0, rx1656_pos, $I10)
  # rx literal  "next"
    add $I11, rx1656_pos, 4
    gt $I11, rx1656_eos, rx1656_fail
    sub $I11, rx1656_pos, rx1656_off
    substr $S10, rx1656_tgt, $I11, 4
    ne $S10, "next", rx1656_fail
    add rx1656_pos, 4
    set_addr $I10, rxcap_1660_fail
    ($I12, $I11) = rx1656_cur."!mark_peek"($I10)
    rx1656_cur."!cursor_pos"($I11)
    ($P10) = rx1656_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1656_pos, "")
    rx1656_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1660_done
  rxcap_1660_fail:
    goto rx1656_fail
  rxcap_1660_done:
  # rx pass
    rx1656_cur."!cursor_pass"(rx1656_pos, "term:sym<next>")
    if_null rx1656_debug, debug_1311
    rx1656_cur."!cursor_debug"("PASS", "term:sym<next>", " at pos=", rx1656_pos)
  debug_1311:
    .return (rx1656_cur)
  rx1656_restart:
.annotate 'line', 10
    if_null rx1656_debug, debug_1312
    rx1656_cur."!cursor_debug"("NEXT", "term:sym<next>")
  debug_1312:
  rx1656_fail:
    (rx1656_rep, rx1656_pos, $I10, $P10) = rx1656_cur."!mark_fail"(0)
    lt rx1656_pos, -1, rx1656_done
    eq rx1656_pos, -1, rx1656_fail
    jump $I10
  rx1656_done:
    rx1656_cur."!cursor_fail"()
    if_null rx1656_debug, debug_1313
    rx1656_cur."!cursor_debug"("FAIL", "term:sym<next>")
  debug_1313:
    .return (rx1656_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<next>"  :nsentry("!PREFIX__term:sym<next>") :subid("378_1300062003.824") :method
.annotate 'line', 10
    new $P1658, "ResizablePMCArray"
    push $P1658, "next"
    .return ($P1658)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<redo>"  :subid("379_1300062003.824") :method :outer("12_1300062003.824")
.annotate 'line', 10
    .local string rx1662_tgt
    .local int rx1662_pos
    .local int rx1662_off
    .local int rx1662_eos
    .local int rx1662_rep
    .local pmc rx1662_cur
    .local pmc rx1662_debug
    (rx1662_cur, rx1662_pos, rx1662_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1662_cur
    .local pmc match
    .lex "$/", match
    length rx1662_eos, rx1662_tgt
    gt rx1662_pos, rx1662_eos, rx1662_done
    set rx1662_off, 0
    lt rx1662_pos, 2, rx1662_start
    sub rx1662_off, rx1662_pos, 1
    substr rx1662_tgt, rx1662_tgt, rx1662_off
  rx1662_start:
    eq $I10, 1, rx1662_restart
    if_null rx1662_debug, debug_1314
    rx1662_cur."!cursor_debug"("START", "term:sym<redo>")
  debug_1314:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1665_done
    goto rxscan1665_scan
  rxscan1665_loop:
    (rx1662_pos) = rx1662_cur."from"()
    inc rx1662_pos
    rx1662_cur."!cursor_from"(rx1662_pos)
    ge rx1662_pos, rx1662_eos, rxscan1665_done
  rxscan1665_scan:
    set_addr $I10, rxscan1665_loop
    rx1662_cur."!mark_push"(0, rx1662_pos, $I10)
  rxscan1665_done:
.annotate 'line', 690
  # rx subcapture "sym"
    set_addr $I10, rxcap_1666_fail
    rx1662_cur."!mark_push"(0, rx1662_pos, $I10)
  # rx literal  "redo"
    add $I11, rx1662_pos, 4
    gt $I11, rx1662_eos, rx1662_fail
    sub $I11, rx1662_pos, rx1662_off
    substr $S10, rx1662_tgt, $I11, 4
    ne $S10, "redo", rx1662_fail
    add rx1662_pos, 4
    set_addr $I10, rxcap_1666_fail
    ($I12, $I11) = rx1662_cur."!mark_peek"($I10)
    rx1662_cur."!cursor_pos"($I11)
    ($P10) = rx1662_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1662_pos, "")
    rx1662_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1666_done
  rxcap_1666_fail:
    goto rx1662_fail
  rxcap_1666_done:
  # rx pass
    rx1662_cur."!cursor_pass"(rx1662_pos, "term:sym<redo>")
    if_null rx1662_debug, debug_1315
    rx1662_cur."!cursor_debug"("PASS", "term:sym<redo>", " at pos=", rx1662_pos)
  debug_1315:
    .return (rx1662_cur)
  rx1662_restart:
.annotate 'line', 10
    if_null rx1662_debug, debug_1316
    rx1662_cur."!cursor_debug"("NEXT", "term:sym<redo>")
  debug_1316:
  rx1662_fail:
    (rx1662_rep, rx1662_pos, $I10, $P10) = rx1662_cur."!mark_fail"(0)
    lt rx1662_pos, -1, rx1662_done
    eq rx1662_pos, -1, rx1662_fail
    jump $I10
  rx1662_done:
    rx1662_cur."!cursor_fail"()
    if_null rx1662_debug, debug_1317
    rx1662_cur."!cursor_debug"("FAIL", "term:sym<redo>")
  debug_1317:
    .return (rx1662_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<redo>"  :nsentry("!PREFIX__term:sym<redo>") :subid("380_1300062003.824") :method
.annotate 'line', 10
    new $P1664, "ResizablePMCArray"
    push $P1664, "redo"
    .return ($P1664)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "smartmatch"  :subid("381_1300062003.824") :outer("12_1300062003.824")
    .param pmc param_1668
    .param pmc param_1669
.annotate 'line', 692
    .lex "self", param_1668
    .lex "$/", param_1669
.annotate 'line', 694
    new $P1670, "Undef"
    .lex "$t", $P1670
    find_lex $P1671, "$/"
    unless_null $P1671, vivify_1318
    $P1671 = root_new ['parrot';'ResizablePMCArray']
  vivify_1318:
    set $P1672, $P1671[0]
    unless_null $P1672, vivify_1319
    new $P1672, "Undef"
  vivify_1319:
    store_lex "$t", $P1672
    find_lex $P1673, "$/"
    unless_null $P1673, vivify_1320
    $P1673 = root_new ['parrot';'ResizablePMCArray']
  vivify_1320:
    set $P1674, $P1673[1]
    unless_null $P1674, vivify_1321
    new $P1674, "Undef"
  vivify_1321:
    find_lex $P1675, "$/"
    unless_null $P1675, vivify_1322
    $P1675 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P1675
  vivify_1322:
    set $P1675[0], $P1674
    find_lex $P1676, "$t"
    find_lex $P1677, "$/"
    unless_null $P1677, vivify_1323
    $P1677 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P1677
  vivify_1323:
    set $P1677[1], $P1676
.annotate 'line', 692
    .return ($P1676)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2398"  :subid("383_1300062003.824") :outer("10_1300062003.824")
.annotate 'line', 698
    .const 'Sub' $P2463 = "404_1300062003.824" 
    capture_lex $P2463
    .const 'Sub' $P2456 = "402_1300062003.824" 
    capture_lex $P2456
    .const 'Sub' $P2451 = "400_1300062003.824" 
    capture_lex $P2451
    .const 'Sub' $P2439 = "397_1300062003.824" 
    capture_lex $P2439
    .const 'Sub' $P2429 = "394_1300062003.824" 
    capture_lex $P2429
    .const 'Sub' $P2424 = "392_1300062003.824" 
    capture_lex $P2424
    .const 'Sub' $P2415 = "389_1300062003.824" 
    capture_lex $P2415
    .const 'Sub' $P2410 = "387_1300062003.824" 
    capture_lex $P2410
    .const 'Sub' $P2401 = "384_1300062003.824" 
    capture_lex $P2401
    get_global $P2400, "$?CLASS"
    .const 'Sub' $P2456 = "402_1300062003.824" 
    capture_lex $P2456
    .return ($P2456)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "" :load :init :subid("post1324") :outer("383_1300062003.824")
.annotate 'line', 698
    get_hll_global $P2399, ["NQP";"Regex"], "_block2398" 
    .local pmc block
    set block, $P2399
    .const 'Sub' $P2463 = "404_1300062003.824" 
    capture_lex $P2463
    $P2463()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2462"  :anon :subid("404_1300062003.824") :outer("383_1300062003.824")
.annotate 'line', 698
    nqp_get_sc_object $P2464, "1300061983.846", 1
    .local pmc type_obj
    set type_obj, $P2464
    set_global "$?CLASS", type_obj
    get_how $P2465, type_obj
    .const 'Sub' $P2466 = "384_1300062003.824" 
    $P2465."add_method"(type_obj, "metachar:sym<:my>", $P2466)
    get_how $P2467, type_obj
    get_global $P2468, "!PREFIX__metachar:sym<:my>"
    $P2467."add_method"(type_obj, "!PREFIX__metachar:sym<:my>", $P2468)
    get_how $P2469, type_obj
    .const 'Sub' $P2470 = "387_1300062003.824" 
    $P2469."add_method"(type_obj, "metachar:sym<{ }>", $P2470)
    get_how $P2471, type_obj
    get_global $P2472, "!PREFIX__metachar:sym<{ }>"
    $P2471."add_method"(type_obj, "!PREFIX__metachar:sym<{ }>", $P2472)
    get_how $P2473, type_obj
    .const 'Sub' $P2474 = "389_1300062003.824" 
    $P2473."add_method"(type_obj, "metachar:sym<nqpvar>", $P2474)
    get_how $P2475, type_obj
    get_global $P2476, "!PREFIX__metachar:sym<nqpvar>"
    $P2475."add_method"(type_obj, "!PREFIX__metachar:sym<nqpvar>", $P2476)
    get_how $P2477, type_obj
    .const 'Sub' $P2478 = "392_1300062003.824" 
    $P2477."add_method"(type_obj, "assertion:sym<{ }>", $P2478)
    get_how $P2479, type_obj
    get_global $P2480, "!PREFIX__assertion:sym<{ }>"
    $P2479."add_method"(type_obj, "!PREFIX__assertion:sym<{ }>", $P2480)
    get_how $P2481, type_obj
    .const 'Sub' $P2482 = "394_1300062003.824" 
    $P2481."add_method"(type_obj, "assertion:sym<?{ }>", $P2482)
    get_how $P2483, type_obj
    get_global $P2484, "!PREFIX__assertion:sym<?{ }>"
    $P2483."add_method"(type_obj, "!PREFIX__assertion:sym<?{ }>", $P2484)
    get_how $P2485, type_obj
    .const 'Sub' $P2486 = "397_1300062003.824" 
    $P2485."add_method"(type_obj, "assertion:sym<name>", $P2486)
    get_how $P2487, type_obj
    get_global $P2488, "!PREFIX__assertion:sym<name>"
    $P2487."add_method"(type_obj, "!PREFIX__assertion:sym<name>", $P2488)
    get_how $P2489, type_obj
    .const 'Sub' $P2490 = "400_1300062003.824" 
    $P2489."add_method"(type_obj, "assertion:sym<var>", $P2490)
    get_how $P2491, type_obj
    get_global $P2492, "!PREFIX__assertion:sym<var>"
    $P2491."add_method"(type_obj, "!PREFIX__assertion:sym<var>", $P2492)
    get_how $P2493, type_obj
    .const 'Sub' $P2494 = "402_1300062003.824" 
    $P2493."add_method"(type_obj, "codeblock", $P2494)
    get_how $P2495, type_obj
    get_global $P2496, "!PREFIX__codeblock"
    $P2495."add_method"(type_obj, "!PREFIX__codeblock", $P2496)
    get_how $P2497, type_obj
    get_hll_global $P2498, ["Regex";"P6Regex"], "Grammar"
    $P2497."add_parent"(type_obj, $P2498)
    get_how $P2499, type_obj
    $P2500 = $P2499."compose"(type_obj)
    .return ($P2500)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<:my>"  :subid("384_1300062003.824") :method :outer("383_1300062003.824")
.annotate 'line', 698
    .const 'Sub' $P2407 = "386_1300062003.824" 
    capture_lex $P2407
    .local string rx2402_tgt
    .local int rx2402_pos
    .local int rx2402_off
    .local int rx2402_eos
    .local int rx2402_rep
    .local pmc rx2402_cur
    .local pmc rx2402_debug
    (rx2402_cur, rx2402_pos, rx2402_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2402_cur
    .local pmc match
    .lex "$/", match
    length rx2402_eos, rx2402_tgt
    gt rx2402_pos, rx2402_eos, rx2402_done
    set rx2402_off, 0
    lt rx2402_pos, 2, rx2402_start
    sub rx2402_off, rx2402_pos, 1
    substr rx2402_tgt, rx2402_tgt, rx2402_off
  rx2402_start:
    eq $I10, 1, rx2402_restart
    if_null rx2402_debug, debug_1325
    rx2402_cur."!cursor_debug"("START", "metachar:sym<:my>")
  debug_1325:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2405_done
    goto rxscan2405_scan
  rxscan2405_loop:
    (rx2402_pos) = rx2402_cur."from"()
    inc rx2402_pos
    rx2402_cur."!cursor_from"(rx2402_pos)
    ge rx2402_pos, rx2402_eos, rxscan2405_done
  rxscan2405_scan:
    set_addr $I10, rxscan2405_loop
    rx2402_cur."!mark_push"(0, rx2402_pos, $I10)
  rxscan2405_done:
.annotate 'line', 700
  # rx literal  ":"
    add $I11, rx2402_pos, 1
    gt $I11, rx2402_eos, rx2402_fail
    sub $I11, rx2402_pos, rx2402_off
    ord $I11, rx2402_tgt, $I11
    ne $I11, 58, rx2402_fail
    add rx2402_pos, 1
  # rx subrule "before" subtype=zerowidth negate=
    rx2402_cur."!cursor_pos"(rx2402_pos)
    .const 'Sub' $P2407 = "386_1300062003.824" 
    capture_lex $P2407
    $P10 = rx2402_cur."before"($P2407)
    unless $P10, rx2402_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2402_cur."!cursor_pos"(rx2402_pos)
    $P10 = rx2402_cur."LANG"("MAIN", "statement")
    unless $P10, rx2402_fail
    rx2402_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx2402_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2402_cur."!cursor_pos"(rx2402_pos)
    $P10 = rx2402_cur."ws"()
    unless $P10, rx2402_fail
    rx2402_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx2402_pos, 1
    gt $I11, rx2402_eos, rx2402_fail
    sub $I11, rx2402_pos, rx2402_off
    ord $I11, rx2402_tgt, $I11
    ne $I11, 59, rx2402_fail
    add rx2402_pos, 1
.annotate 'line', 699
  # rx pass
    rx2402_cur."!cursor_pass"(rx2402_pos, "metachar:sym<:my>")
    if_null rx2402_debug, debug_1330
    rx2402_cur."!cursor_debug"("PASS", "metachar:sym<:my>", " at pos=", rx2402_pos)
  debug_1330:
    .return (rx2402_cur)
  rx2402_restart:
.annotate 'line', 698
    if_null rx2402_debug, debug_1331
    rx2402_cur."!cursor_debug"("NEXT", "metachar:sym<:my>")
  debug_1331:
  rx2402_fail:
    (rx2402_rep, rx2402_pos, $I10, $P10) = rx2402_cur."!mark_fail"(0)
    lt rx2402_pos, -1, rx2402_done
    eq rx2402_pos, -1, rx2402_fail
    jump $I10
  rx2402_done:
    rx2402_cur."!cursor_fail"()
    if_null rx2402_debug, debug_1332
    rx2402_cur."!cursor_debug"("FAIL", "metachar:sym<:my>")
  debug_1332:
    .return (rx2402_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<:my>"  :nsentry("!PREFIX__metachar:sym<:my>") :subid("385_1300062003.824") :method
.annotate 'line', 698
    new $P2404, "ResizablePMCArray"
    push $P2404, ":"
    .return ($P2404)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2406"  :anon :subid("386_1300062003.824") :method :outer("384_1300062003.824")
.annotate 'line', 700
    .local string rx2408_tgt
    .local int rx2408_pos
    .local int rx2408_off
    .local int rx2408_eos
    .local int rx2408_rep
    .local pmc rx2408_cur
    .local pmc rx2408_debug
    (rx2408_cur, rx2408_pos, rx2408_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2408_cur
    .local pmc match
    .lex "$/", match
    length rx2408_eos, rx2408_tgt
    gt rx2408_pos, rx2408_eos, rx2408_done
    set rx2408_off, 0
    lt rx2408_pos, 2, rx2408_start
    sub rx2408_off, rx2408_pos, 1
    substr rx2408_tgt, rx2408_tgt, rx2408_off
  rx2408_start:
    eq $I10, 1, rx2408_restart
    if_null rx2408_debug, debug_1326
    rx2408_cur."!cursor_debug"("START", "")
  debug_1326:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2409_done
    goto rxscan2409_scan
  rxscan2409_loop:
    (rx2408_pos) = rx2408_cur."from"()
    inc rx2408_pos
    rx2408_cur."!cursor_from"(rx2408_pos)
    ge rx2408_pos, rx2408_eos, rxscan2409_done
  rxscan2409_scan:
    set_addr $I10, rxscan2409_loop
    rx2408_cur."!mark_push"(0, rx2408_pos, $I10)
  rxscan2409_done:
  # rx literal  "my"
    add $I11, rx2408_pos, 2
    gt $I11, rx2408_eos, rx2408_fail
    sub $I11, rx2408_pos, rx2408_off
    substr $S10, rx2408_tgt, $I11, 2
    ne $S10, "my", rx2408_fail
    add rx2408_pos, 2
  # rx pass
    rx2408_cur."!cursor_pass"(rx2408_pos, "")
    if_null rx2408_debug, debug_1327
    rx2408_cur."!cursor_debug"("PASS", "", " at pos=", rx2408_pos)
  debug_1327:
    .return (rx2408_cur)
  rx2408_restart:
    if_null rx2408_debug, debug_1328
    rx2408_cur."!cursor_debug"("NEXT", "")
  debug_1328:
  rx2408_fail:
    (rx2408_rep, rx2408_pos, $I10, $P10) = rx2408_cur."!mark_fail"(0)
    lt rx2408_pos, -1, rx2408_done
    eq rx2408_pos, -1, rx2408_fail
    jump $I10
  rx2408_done:
    rx2408_cur."!cursor_fail"()
    if_null rx2408_debug, debug_1329
    rx2408_cur."!cursor_debug"("FAIL", "")
  debug_1329:
    .return (rx2408_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<{ }>"  :subid("387_1300062003.824") :method :outer("383_1300062003.824")
.annotate 'line', 698
    .local string rx2411_tgt
    .local int rx2411_pos
    .local int rx2411_off
    .local int rx2411_eos
    .local int rx2411_rep
    .local pmc rx2411_cur
    .local pmc rx2411_debug
    (rx2411_cur, rx2411_pos, rx2411_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2411_cur
    .local pmc match
    .lex "$/", match
    length rx2411_eos, rx2411_tgt
    gt rx2411_pos, rx2411_eos, rx2411_done
    set rx2411_off, 0
    lt rx2411_pos, 2, rx2411_start
    sub rx2411_off, rx2411_pos, 1
    substr rx2411_tgt, rx2411_tgt, rx2411_off
  rx2411_start:
    eq $I10, 1, rx2411_restart
    if_null rx2411_debug, debug_1333
    rx2411_cur."!cursor_debug"("START", "metachar:sym<{ }>")
  debug_1333:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2414_done
    goto rxscan2414_scan
  rxscan2414_loop:
    (rx2411_pos) = rx2411_cur."from"()
    inc rx2411_pos
    rx2411_cur."!cursor_from"(rx2411_pos)
    ge rx2411_pos, rx2411_eos, rxscan2414_done
  rxscan2414_scan:
    set_addr $I10, rxscan2414_loop
    rx2411_cur."!mark_push"(0, rx2411_pos, $I10)
  rxscan2414_done:
.annotate 'line', 704
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2411_pos, rx2411_off
    substr $S10, rx2411_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2411_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx2411_cur."!cursor_pos"(rx2411_pos)
    $P10 = rx2411_cur."codeblock"()
    unless $P10, rx2411_fail
    rx2411_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2411_pos = $P10."pos"()
.annotate 'line', 703
  # rx pass
    rx2411_cur."!cursor_pass"(rx2411_pos, "metachar:sym<{ }>")
    if_null rx2411_debug, debug_1334
    rx2411_cur."!cursor_debug"("PASS", "metachar:sym<{ }>", " at pos=", rx2411_pos)
  debug_1334:
    .return (rx2411_cur)
  rx2411_restart:
.annotate 'line', 698
    if_null rx2411_debug, debug_1335
    rx2411_cur."!cursor_debug"("NEXT", "metachar:sym<{ }>")
  debug_1335:
  rx2411_fail:
    (rx2411_rep, rx2411_pos, $I10, $P10) = rx2411_cur."!mark_fail"(0)
    lt rx2411_pos, -1, rx2411_done
    eq rx2411_pos, -1, rx2411_fail
    jump $I10
  rx2411_done:
    rx2411_cur."!cursor_fail"()
    if_null rx2411_debug, debug_1336
    rx2411_cur."!cursor_debug"("FAIL", "metachar:sym<{ }>")
  debug_1336:
    .return (rx2411_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<{ }>"  :nsentry("!PREFIX__metachar:sym<{ }>") :subid("388_1300062003.824") :method
.annotate 'line', 698
    new $P2413, "ResizablePMCArray"
    push $P2413, "{"
    .return ($P2413)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<nqpvar>"  :subid("389_1300062003.824") :method :outer("383_1300062003.824")
.annotate 'line', 698
    .const 'Sub' $P2421 = "391_1300062003.824" 
    capture_lex $P2421
    .local string rx2416_tgt
    .local int rx2416_pos
    .local int rx2416_off
    .local int rx2416_eos
    .local int rx2416_rep
    .local pmc rx2416_cur
    .local pmc rx2416_debug
    (rx2416_cur, rx2416_pos, rx2416_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2416_cur
    .local pmc match
    .lex "$/", match
    length rx2416_eos, rx2416_tgt
    gt rx2416_pos, rx2416_eos, rx2416_done
    set rx2416_off, 0
    lt rx2416_pos, 2, rx2416_start
    sub rx2416_off, rx2416_pos, 1
    substr rx2416_tgt, rx2416_tgt, rx2416_off
  rx2416_start:
    eq $I10, 1, rx2416_restart
    if_null rx2416_debug, debug_1337
    rx2416_cur."!cursor_debug"("START", "metachar:sym<nqpvar>")
  debug_1337:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2419_done
    goto rxscan2419_scan
  rxscan2419_loop:
    (rx2416_pos) = rx2416_cur."from"()
    inc rx2416_pos
    rx2416_cur."!cursor_from"(rx2416_pos)
    ge rx2416_pos, rx2416_eos, rxscan2419_done
  rxscan2419_scan:
    set_addr $I10, rxscan2419_loop
    rx2416_cur."!mark_push"(0, rx2416_pos, $I10)
  rxscan2419_done:
.annotate 'line', 708
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2416_pos, rx2416_off
    substr $S10, rx2416_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx2416_fail
  # rx subrule "before" subtype=zerowidth negate=
    rx2416_cur."!cursor_pos"(rx2416_pos)
    .const 'Sub' $P2421 = "391_1300062003.824" 
    capture_lex $P2421
    $P10 = rx2416_cur."before"($P2421)
    unless $P10, rx2416_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2416_cur."!cursor_pos"(rx2416_pos)
    $P10 = rx2416_cur."LANG"("MAIN", "variable")
    unless $P10, rx2416_fail
    rx2416_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx2416_pos = $P10."pos"()
.annotate 'line', 707
  # rx pass
    rx2416_cur."!cursor_pass"(rx2416_pos, "metachar:sym<nqpvar>")
    if_null rx2416_debug, debug_1342
    rx2416_cur."!cursor_debug"("PASS", "metachar:sym<nqpvar>", " at pos=", rx2416_pos)
  debug_1342:
    .return (rx2416_cur)
  rx2416_restart:
.annotate 'line', 698
    if_null rx2416_debug, debug_1343
    rx2416_cur."!cursor_debug"("NEXT", "metachar:sym<nqpvar>")
  debug_1343:
  rx2416_fail:
    (rx2416_rep, rx2416_pos, $I10, $P10) = rx2416_cur."!mark_fail"(0)
    lt rx2416_pos, -1, rx2416_done
    eq rx2416_pos, -1, rx2416_fail
    jump $I10
  rx2416_done:
    rx2416_cur."!cursor_fail"()
    if_null rx2416_debug, debug_1344
    rx2416_cur."!cursor_debug"("FAIL", "metachar:sym<nqpvar>")
  debug_1344:
    .return (rx2416_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<nqpvar>"  :nsentry("!PREFIX__metachar:sym<nqpvar>") :subid("390_1300062003.824") :method
.annotate 'line', 698
    new $P2418, "ResizablePMCArray"
    push $P2418, "$"
    push $P2418, "@"
    .return ($P2418)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2420"  :anon :subid("391_1300062003.824") :method :outer("389_1300062003.824")
.annotate 'line', 708
    .local string rx2422_tgt
    .local int rx2422_pos
    .local int rx2422_off
    .local int rx2422_eos
    .local int rx2422_rep
    .local pmc rx2422_cur
    .local pmc rx2422_debug
    (rx2422_cur, rx2422_pos, rx2422_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2422_cur
    .local pmc match
    .lex "$/", match
    length rx2422_eos, rx2422_tgt
    gt rx2422_pos, rx2422_eos, rx2422_done
    set rx2422_off, 0
    lt rx2422_pos, 2, rx2422_start
    sub rx2422_off, rx2422_pos, 1
    substr rx2422_tgt, rx2422_tgt, rx2422_off
  rx2422_start:
    eq $I10, 1, rx2422_restart
    if_null rx2422_debug, debug_1338
    rx2422_cur."!cursor_debug"("START", "")
  debug_1338:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2423_done
    goto rxscan2423_scan
  rxscan2423_loop:
    (rx2422_pos) = rx2422_cur."from"()
    inc rx2422_pos
    rx2422_cur."!cursor_from"(rx2422_pos)
    ge rx2422_pos, rx2422_eos, rxscan2423_done
  rxscan2423_scan:
    set_addr $I10, rxscan2423_loop
    rx2422_cur."!mark_push"(0, rx2422_pos, $I10)
  rxscan2423_done:
  # rx charclass .
    ge rx2422_pos, rx2422_eos, rx2422_fail
    inc rx2422_pos
  # rx charclass w
    ge rx2422_pos, rx2422_eos, rx2422_fail
    sub $I10, rx2422_pos, rx2422_off
    is_cclass $I11, 8192, rx2422_tgt, $I10
    unless $I11, rx2422_fail
    inc rx2422_pos
  # rx pass
    rx2422_cur."!cursor_pass"(rx2422_pos, "")
    if_null rx2422_debug, debug_1339
    rx2422_cur."!cursor_debug"("PASS", "", " at pos=", rx2422_pos)
  debug_1339:
    .return (rx2422_cur)
  rx2422_restart:
    if_null rx2422_debug, debug_1340
    rx2422_cur."!cursor_debug"("NEXT", "")
  debug_1340:
  rx2422_fail:
    (rx2422_rep, rx2422_pos, $I10, $P10) = rx2422_cur."!mark_fail"(0)
    lt rx2422_pos, -1, rx2422_done
    eq rx2422_pos, -1, rx2422_fail
    jump $I10
  rx2422_done:
    rx2422_cur."!cursor_fail"()
    if_null rx2422_debug, debug_1341
    rx2422_cur."!cursor_debug"("FAIL", "")
  debug_1341:
    .return (rx2422_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<{ }>"  :subid("392_1300062003.824") :method :outer("383_1300062003.824")
.annotate 'line', 698
    .local string rx2425_tgt
    .local int rx2425_pos
    .local int rx2425_off
    .local int rx2425_eos
    .local int rx2425_rep
    .local pmc rx2425_cur
    .local pmc rx2425_debug
    (rx2425_cur, rx2425_pos, rx2425_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2425_cur
    .local pmc match
    .lex "$/", match
    length rx2425_eos, rx2425_tgt
    gt rx2425_pos, rx2425_eos, rx2425_done
    set rx2425_off, 0
    lt rx2425_pos, 2, rx2425_start
    sub rx2425_off, rx2425_pos, 1
    substr rx2425_tgt, rx2425_tgt, rx2425_off
  rx2425_start:
    eq $I10, 1, rx2425_restart
    if_null rx2425_debug, debug_1345
    rx2425_cur."!cursor_debug"("START", "assertion:sym<{ }>")
  debug_1345:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2428_done
    goto rxscan2428_scan
  rxscan2428_loop:
    (rx2425_pos) = rx2425_cur."from"()
    inc rx2425_pos
    rx2425_cur."!cursor_from"(rx2425_pos)
    ge rx2425_pos, rx2425_eos, rxscan2428_done
  rxscan2428_scan:
    set_addr $I10, rxscan2428_loop
    rx2425_cur."!mark_push"(0, rx2425_pos, $I10)
  rxscan2428_done:
.annotate 'line', 712
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2425_pos, rx2425_off
    substr $S10, rx2425_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2425_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx2425_cur."!cursor_pos"(rx2425_pos)
    $P10 = rx2425_cur."codeblock"()
    unless $P10, rx2425_fail
    rx2425_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2425_pos = $P10."pos"()
.annotate 'line', 711
  # rx pass
    rx2425_cur."!cursor_pass"(rx2425_pos, "assertion:sym<{ }>")
    if_null rx2425_debug, debug_1346
    rx2425_cur."!cursor_debug"("PASS", "assertion:sym<{ }>", " at pos=", rx2425_pos)
  debug_1346:
    .return (rx2425_cur)
  rx2425_restart:
.annotate 'line', 698
    if_null rx2425_debug, debug_1347
    rx2425_cur."!cursor_debug"("NEXT", "assertion:sym<{ }>")
  debug_1347:
  rx2425_fail:
    (rx2425_rep, rx2425_pos, $I10, $P10) = rx2425_cur."!mark_fail"(0)
    lt rx2425_pos, -1, rx2425_done
    eq rx2425_pos, -1, rx2425_fail
    jump $I10
  rx2425_done:
    rx2425_cur."!cursor_fail"()
    if_null rx2425_debug, debug_1348
    rx2425_cur."!cursor_debug"("FAIL", "assertion:sym<{ }>")
  debug_1348:
    .return (rx2425_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<{ }>"  :nsentry("!PREFIX__assertion:sym<{ }>") :subid("393_1300062003.824") :method
.annotate 'line', 698
    new $P2427, "ResizablePMCArray"
    push $P2427, "{"
    .return ($P2427)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<?{ }>"  :subid("394_1300062003.824") :method :outer("383_1300062003.824")
.annotate 'line', 698
    .const 'Sub' $P2435 = "396_1300062003.824" 
    capture_lex $P2435
    .local string rx2430_tgt
    .local int rx2430_pos
    .local int rx2430_off
    .local int rx2430_eos
    .local int rx2430_rep
    .local pmc rx2430_cur
    .local pmc rx2430_debug
    (rx2430_cur, rx2430_pos, rx2430_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2430_cur
    .local pmc match
    .lex "$/", match
    length rx2430_eos, rx2430_tgt
    gt rx2430_pos, rx2430_eos, rx2430_done
    set rx2430_off, 0
    lt rx2430_pos, 2, rx2430_start
    sub rx2430_off, rx2430_pos, 1
    substr rx2430_tgt, rx2430_tgt, rx2430_off
  rx2430_start:
    eq $I10, 1, rx2430_restart
    if_null rx2430_debug, debug_1349
    rx2430_cur."!cursor_debug"("START", "assertion:sym<?{ }>")
  debug_1349:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2433_done
    goto rxscan2433_scan
  rxscan2433_loop:
    (rx2430_pos) = rx2430_cur."from"()
    inc rx2430_pos
    rx2430_cur."!cursor_from"(rx2430_pos)
    ge rx2430_pos, rx2430_eos, rxscan2433_done
  rxscan2433_scan:
    set_addr $I10, rxscan2433_loop
    rx2430_cur."!mark_push"(0, rx2430_pos, $I10)
  rxscan2433_done:
.annotate 'line', 716
  # rx subcapture "zw"
    set_addr $I10, rxcap_2438_fail
    rx2430_cur."!mark_push"(0, rx2430_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx2430_pos, rx2430_eos, rx2430_fail
    sub $I10, rx2430_pos, rx2430_off
    substr $S10, rx2430_tgt, $I10, 1
    index $I11, "?!", $S10
    lt $I11, 0, rx2430_fail
    inc rx2430_pos
  # rx subrule "before" subtype=zerowidth negate=
    rx2430_cur."!cursor_pos"(rx2430_pos)
    .const 'Sub' $P2435 = "396_1300062003.824" 
    capture_lex $P2435
    $P10 = rx2430_cur."before"($P2435)
    unless $P10, rx2430_fail
    set_addr $I10, rxcap_2438_fail
    ($I12, $I11) = rx2430_cur."!mark_peek"($I10)
    rx2430_cur."!cursor_pos"($I11)
    ($P10) = rx2430_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2430_pos, "")
    rx2430_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("zw")
    goto rxcap_2438_done
  rxcap_2438_fail:
    goto rx2430_fail
  rxcap_2438_done:
  # rx subrule "codeblock" subtype=capture negate=
    rx2430_cur."!cursor_pos"(rx2430_pos)
    $P10 = rx2430_cur."codeblock"()
    unless $P10, rx2430_fail
    rx2430_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2430_pos = $P10."pos"()
.annotate 'line', 715
  # rx pass
    rx2430_cur."!cursor_pass"(rx2430_pos, "assertion:sym<?{ }>")
    if_null rx2430_debug, debug_1354
    rx2430_cur."!cursor_debug"("PASS", "assertion:sym<?{ }>", " at pos=", rx2430_pos)
  debug_1354:
    .return (rx2430_cur)
  rx2430_restart:
.annotate 'line', 698
    if_null rx2430_debug, debug_1355
    rx2430_cur."!cursor_debug"("NEXT", "assertion:sym<?{ }>")
  debug_1355:
  rx2430_fail:
    (rx2430_rep, rx2430_pos, $I10, $P10) = rx2430_cur."!mark_fail"(0)
    lt rx2430_pos, -1, rx2430_done
    eq rx2430_pos, -1, rx2430_fail
    jump $I10
  rx2430_done:
    rx2430_cur."!cursor_fail"()
    if_null rx2430_debug, debug_1356
    rx2430_cur."!cursor_debug"("FAIL", "assertion:sym<?{ }>")
  debug_1356:
    .return (rx2430_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<?{ }>"  :nsentry("!PREFIX__assertion:sym<?{ }>") :subid("395_1300062003.824") :method
.annotate 'line', 698
    new $P2432, "ResizablePMCArray"
    push $P2432, "!"
    push $P2432, "?"
    .return ($P2432)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2434"  :anon :subid("396_1300062003.824") :method :outer("394_1300062003.824")
.annotate 'line', 716
    .local string rx2436_tgt
    .local int rx2436_pos
    .local int rx2436_off
    .local int rx2436_eos
    .local int rx2436_rep
    .local pmc rx2436_cur
    .local pmc rx2436_debug
    (rx2436_cur, rx2436_pos, rx2436_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2436_cur
    .local pmc match
    .lex "$/", match
    length rx2436_eos, rx2436_tgt
    gt rx2436_pos, rx2436_eos, rx2436_done
    set rx2436_off, 0
    lt rx2436_pos, 2, rx2436_start
    sub rx2436_off, rx2436_pos, 1
    substr rx2436_tgt, rx2436_tgt, rx2436_off
  rx2436_start:
    eq $I10, 1, rx2436_restart
    if_null rx2436_debug, debug_1350
    rx2436_cur."!cursor_debug"("START", "")
  debug_1350:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2437_done
    goto rxscan2437_scan
  rxscan2437_loop:
    (rx2436_pos) = rx2436_cur."from"()
    inc rx2436_pos
    rx2436_cur."!cursor_from"(rx2436_pos)
    ge rx2436_pos, rx2436_eos, rxscan2437_done
  rxscan2437_scan:
    set_addr $I10, rxscan2437_loop
    rx2436_cur."!mark_push"(0, rx2436_pos, $I10)
  rxscan2437_done:
  # rx literal  "{"
    add $I11, rx2436_pos, 1
    gt $I11, rx2436_eos, rx2436_fail
    sub $I11, rx2436_pos, rx2436_off
    ord $I11, rx2436_tgt, $I11
    ne $I11, 123, rx2436_fail
    add rx2436_pos, 1
  # rx pass
    rx2436_cur."!cursor_pass"(rx2436_pos, "")
    if_null rx2436_debug, debug_1351
    rx2436_cur."!cursor_debug"("PASS", "", " at pos=", rx2436_pos)
  debug_1351:
    .return (rx2436_cur)
  rx2436_restart:
    if_null rx2436_debug, debug_1352
    rx2436_cur."!cursor_debug"("NEXT", "")
  debug_1352:
  rx2436_fail:
    (rx2436_rep, rx2436_pos, $I10, $P10) = rx2436_cur."!mark_fail"(0)
    lt rx2436_pos, -1, rx2436_done
    eq rx2436_pos, -1, rx2436_fail
    jump $I10
  rx2436_done:
    rx2436_cur."!cursor_fail"()
    if_null rx2436_debug, debug_1353
    rx2436_cur."!cursor_debug"("FAIL", "")
  debug_1353:
    .return (rx2436_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<name>"  :subid("397_1300062003.824") :method :outer("383_1300062003.824")
.annotate 'line', 698
    .const 'Sub' $P2448 = "399_1300062003.824" 
    capture_lex $P2448
    .local string rx2440_tgt
    .local int rx2440_pos
    .local int rx2440_off
    .local int rx2440_eos
    .local int rx2440_rep
    .local pmc rx2440_cur
    .local pmc rx2440_debug
    (rx2440_cur, rx2440_pos, rx2440_tgt, $I10) = self."!cursor_start"()
    rx2440_cur."!cursor_caparray"("assertion", "arglist", "nibbler")
    .lex unicode:"$\x{a2}", rx2440_cur
    .local pmc match
    .lex "$/", match
    length rx2440_eos, rx2440_tgt
    gt rx2440_pos, rx2440_eos, rx2440_done
    set rx2440_off, 0
    lt rx2440_pos, 2, rx2440_start
    sub rx2440_off, rx2440_pos, 1
    substr rx2440_tgt, rx2440_tgt, rx2440_off
  rx2440_start:
    eq $I10, 1, rx2440_restart
    if_null rx2440_debug, debug_1357
    rx2440_cur."!cursor_debug"("START", "assertion:sym<name>")
  debug_1357:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2444_done
    goto rxscan2444_scan
  rxscan2444_loop:
    (rx2440_pos) = rx2440_cur."from"()
    inc rx2440_pos
    rx2440_cur."!cursor_from"(rx2440_pos)
    ge rx2440_pos, rx2440_eos, rxscan2444_done
  rxscan2444_scan:
    set_addr $I10, rxscan2444_loop
    rx2440_cur."!mark_push"(0, rx2440_pos, $I10)
  rxscan2444_done:
.annotate 'line', 720
  # rx subrule "identifier" subtype=capture negate=
    rx2440_cur."!cursor_pos"(rx2440_pos)
    $P10 = rx2440_cur."identifier"()
    unless $P10, rx2440_fail
    rx2440_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx2440_pos = $P10."pos"()
.annotate 'line', 727
  # rx rxquantr2445 ** 0..1
    set_addr $I10, rxquantr2445_done
    rx2440_cur."!mark_push"(0, rx2440_pos, $I10)
  rxquantr2445_loop:
  alt2446_0:
.annotate 'line', 721
    set_addr $I10, alt2446_1
    rx2440_cur."!mark_push"(0, rx2440_pos, $I10)
.annotate 'line', 722
  # rx subrule "before" subtype=zerowidth negate=
    rx2440_cur."!cursor_pos"(rx2440_pos)
    .const 'Sub' $P2448 = "399_1300062003.824" 
    capture_lex $P2448
    $P10 = rx2440_cur."before"($P2448)
    unless $P10, rx2440_fail
    goto alt2446_end
  alt2446_1:
    set_addr $I10, alt2446_2
    rx2440_cur."!mark_push"(0, rx2440_pos, $I10)
.annotate 'line', 723
  # rx literal  "="
    add $I11, rx2440_pos, 1
    gt $I11, rx2440_eos, rx2440_fail
    sub $I11, rx2440_pos, rx2440_off
    ord $I11, rx2440_tgt, $I11
    ne $I11, 61, rx2440_fail
    add rx2440_pos, 1
  # rx subrule "assertion" subtype=capture negate=
    rx2440_cur."!cursor_pos"(rx2440_pos)
    $P10 = rx2440_cur."assertion"()
    unless $P10, rx2440_fail
    rx2440_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("assertion")
    rx2440_pos = $P10."pos"()
    goto alt2446_end
  alt2446_2:
    set_addr $I10, alt2446_3
    rx2440_cur."!mark_push"(0, rx2440_pos, $I10)
.annotate 'line', 724
  # rx literal  ":"
    add $I11, rx2440_pos, 1
    gt $I11, rx2440_eos, rx2440_fail
    sub $I11, rx2440_pos, rx2440_off
    ord $I11, rx2440_tgt, $I11
    ne $I11, 58, rx2440_fail
    add rx2440_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx2440_cur."!cursor_pos"(rx2440_pos)
    $P10 = rx2440_cur."arglist"()
    unless $P10, rx2440_fail
    rx2440_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2440_pos = $P10."pos"()
    goto alt2446_end
  alt2446_3:
    set_addr $I10, alt2446_4
    rx2440_cur."!mark_push"(0, rx2440_pos, $I10)
.annotate 'line', 725
  # rx literal  "("
    add $I11, rx2440_pos, 1
    gt $I11, rx2440_eos, rx2440_fail
    sub $I11, rx2440_pos, rx2440_off
    ord $I11, rx2440_tgt, $I11
    ne $I11, 40, rx2440_fail
    add rx2440_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx2440_cur."!cursor_pos"(rx2440_pos)
    $P10 = rx2440_cur."LANG"("MAIN", "arglist")
    unless $P10, rx2440_fail
    rx2440_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2440_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx2440_pos, 1
    gt $I11, rx2440_eos, rx2440_fail
    sub $I11, rx2440_pos, rx2440_off
    ord $I11, rx2440_tgt, $I11
    ne $I11, 41, rx2440_fail
    add rx2440_pos, 1
    goto alt2446_end
  alt2446_4:
.annotate 'line', 726
  # rx subrule "normspace" subtype=method negate=
    rx2440_cur."!cursor_pos"(rx2440_pos)
    $P10 = rx2440_cur."normspace"()
    unless $P10, rx2440_fail
    rx2440_pos = $P10."pos"()
  # rx subrule "nibbler" subtype=capture negate=
    rx2440_cur."!cursor_pos"(rx2440_pos)
    $P10 = rx2440_cur."nibbler"()
    unless $P10, rx2440_fail
    rx2440_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("nibbler")
    rx2440_pos = $P10."pos"()
  alt2446_end:
.annotate 'line', 727
    set_addr $I10, rxquantr2445_done
    (rx2440_rep) = rx2440_cur."!mark_commit"($I10)
  rxquantr2445_done:
.annotate 'line', 719
  # rx pass
    rx2440_cur."!cursor_pass"(rx2440_pos, "assertion:sym<name>")
    if_null rx2440_debug, debug_1362
    rx2440_cur."!cursor_debug"("PASS", "assertion:sym<name>", " at pos=", rx2440_pos)
  debug_1362:
    .return (rx2440_cur)
  rx2440_restart:
.annotate 'line', 698
    if_null rx2440_debug, debug_1363
    rx2440_cur."!cursor_debug"("NEXT", "assertion:sym<name>")
  debug_1363:
  rx2440_fail:
    (rx2440_rep, rx2440_pos, $I10, $P10) = rx2440_cur."!mark_fail"(0)
    lt rx2440_pos, -1, rx2440_done
    eq rx2440_pos, -1, rx2440_fail
    jump $I10
  rx2440_done:
    rx2440_cur."!cursor_fail"()
    if_null rx2440_debug, debug_1364
    rx2440_cur."!cursor_debug"("FAIL", "assertion:sym<name>")
  debug_1364:
    .return (rx2440_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<name>"  :nsentry("!PREFIX__assertion:sym<name>") :subid("398_1300062003.824") :method
.annotate 'line', 698
    $P2442 = self."!PREFIX__!subrule"("identifier", "")
    new $P2443, "ResizablePMCArray"
    push $P2443, $P2442
    .return ($P2443)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2447"  :anon :subid("399_1300062003.824") :method :outer("397_1300062003.824")
.annotate 'line', 722
    .local string rx2449_tgt
    .local int rx2449_pos
    .local int rx2449_off
    .local int rx2449_eos
    .local int rx2449_rep
    .local pmc rx2449_cur
    .local pmc rx2449_debug
    (rx2449_cur, rx2449_pos, rx2449_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2449_cur
    .local pmc match
    .lex "$/", match
    length rx2449_eos, rx2449_tgt
    gt rx2449_pos, rx2449_eos, rx2449_done
    set rx2449_off, 0
    lt rx2449_pos, 2, rx2449_start
    sub rx2449_off, rx2449_pos, 1
    substr rx2449_tgt, rx2449_tgt, rx2449_off
  rx2449_start:
    eq $I10, 1, rx2449_restart
    if_null rx2449_debug, debug_1358
    rx2449_cur."!cursor_debug"("START", "")
  debug_1358:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2450_done
    goto rxscan2450_scan
  rxscan2450_loop:
    (rx2449_pos) = rx2449_cur."from"()
    inc rx2449_pos
    rx2449_cur."!cursor_from"(rx2449_pos)
    ge rx2449_pos, rx2449_eos, rxscan2450_done
  rxscan2450_scan:
    set_addr $I10, rxscan2450_loop
    rx2449_cur."!mark_push"(0, rx2449_pos, $I10)
  rxscan2450_done:
  # rx literal  ">"
    add $I11, rx2449_pos, 1
    gt $I11, rx2449_eos, rx2449_fail
    sub $I11, rx2449_pos, rx2449_off
    ord $I11, rx2449_tgt, $I11
    ne $I11, 62, rx2449_fail
    add rx2449_pos, 1
  # rx pass
    rx2449_cur."!cursor_pass"(rx2449_pos, "")
    if_null rx2449_debug, debug_1359
    rx2449_cur."!cursor_debug"("PASS", "", " at pos=", rx2449_pos)
  debug_1359:
    .return (rx2449_cur)
  rx2449_restart:
    if_null rx2449_debug, debug_1360
    rx2449_cur."!cursor_debug"("NEXT", "")
  debug_1360:
  rx2449_fail:
    (rx2449_rep, rx2449_pos, $I10, $P10) = rx2449_cur."!mark_fail"(0)
    lt rx2449_pos, -1, rx2449_done
    eq rx2449_pos, -1, rx2449_fail
    jump $I10
  rx2449_done:
    rx2449_cur."!cursor_fail"()
    if_null rx2449_debug, debug_1361
    rx2449_cur."!cursor_debug"("FAIL", "")
  debug_1361:
    .return (rx2449_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<var>"  :subid("400_1300062003.824") :method :outer("383_1300062003.824")
.annotate 'line', 698
    .local string rx2452_tgt
    .local int rx2452_pos
    .local int rx2452_off
    .local int rx2452_eos
    .local int rx2452_rep
    .local pmc rx2452_cur
    .local pmc rx2452_debug
    (rx2452_cur, rx2452_pos, rx2452_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2452_cur
    .local pmc match
    .lex "$/", match
    length rx2452_eos, rx2452_tgt
    gt rx2452_pos, rx2452_eos, rx2452_done
    set rx2452_off, 0
    lt rx2452_pos, 2, rx2452_start
    sub rx2452_off, rx2452_pos, 1
    substr rx2452_tgt, rx2452_tgt, rx2452_off
  rx2452_start:
    eq $I10, 1, rx2452_restart
    if_null rx2452_debug, debug_1365
    rx2452_cur."!cursor_debug"("START", "assertion:sym<var>")
  debug_1365:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2455_done
    goto rxscan2455_scan
  rxscan2455_loop:
    (rx2452_pos) = rx2452_cur."from"()
    inc rx2452_pos
    rx2452_cur."!cursor_from"(rx2452_pos)
    ge rx2452_pos, rx2452_eos, rxscan2455_done
  rxscan2455_scan:
    set_addr $I10, rxscan2455_loop
    rx2452_cur."!mark_push"(0, rx2452_pos, $I10)
  rxscan2455_done:
.annotate 'line', 731
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2452_pos, rx2452_off
    substr $S10, rx2452_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx2452_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2452_cur."!cursor_pos"(rx2452_pos)
    $P10 = rx2452_cur."LANG"("MAIN", "variable")
    unless $P10, rx2452_fail
    rx2452_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx2452_pos = $P10."pos"()
.annotate 'line', 730
  # rx pass
    rx2452_cur."!cursor_pass"(rx2452_pos, "assertion:sym<var>")
    if_null rx2452_debug, debug_1366
    rx2452_cur."!cursor_debug"("PASS", "assertion:sym<var>", " at pos=", rx2452_pos)
  debug_1366:
    .return (rx2452_cur)
  rx2452_restart:
.annotate 'line', 698
    if_null rx2452_debug, debug_1367
    rx2452_cur."!cursor_debug"("NEXT", "assertion:sym<var>")
  debug_1367:
  rx2452_fail:
    (rx2452_rep, rx2452_pos, $I10, $P10) = rx2452_cur."!mark_fail"(0)
    lt rx2452_pos, -1, rx2452_done
    eq rx2452_pos, -1, rx2452_fail
    jump $I10
  rx2452_done:
    rx2452_cur."!cursor_fail"()
    if_null rx2452_debug, debug_1368
    rx2452_cur."!cursor_debug"("FAIL", "assertion:sym<var>")
  debug_1368:
    .return (rx2452_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<var>"  :nsentry("!PREFIX__assertion:sym<var>") :subid("401_1300062003.824") :method
.annotate 'line', 698
    new $P2454, "ResizablePMCArray"
    push $P2454, "$"
    push $P2454, "@"
    .return ($P2454)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "codeblock"  :subid("402_1300062003.824") :method :outer("383_1300062003.824")
.annotate 'line', 698
    .local string rx2457_tgt
    .local int rx2457_pos
    .local int rx2457_off
    .local int rx2457_eos
    .local int rx2457_rep
    .local pmc rx2457_cur
    .local pmc rx2457_debug
    (rx2457_cur, rx2457_pos, rx2457_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2457_cur
    .local pmc match
    .lex "$/", match
    length rx2457_eos, rx2457_tgt
    gt rx2457_pos, rx2457_eos, rx2457_done
    set rx2457_off, 0
    lt rx2457_pos, 2, rx2457_start
    sub rx2457_off, rx2457_pos, 1
    substr rx2457_tgt, rx2457_tgt, rx2457_off
  rx2457_start:
    eq $I10, 1, rx2457_restart
    if_null rx2457_debug, debug_1369
    rx2457_cur."!cursor_debug"("START", "codeblock")
  debug_1369:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2461_done
    goto rxscan2461_scan
  rxscan2461_loop:
    (rx2457_pos) = rx2457_cur."from"()
    inc rx2457_pos
    rx2457_cur."!cursor_from"(rx2457_pos)
    ge rx2457_pos, rx2457_eos, rxscan2461_done
  rxscan2461_scan:
    set_addr $I10, rxscan2461_loop
    rx2457_cur."!mark_push"(0, rx2457_pos, $I10)
  rxscan2461_done:
.annotate 'line', 735
  # rx subrule "LANG" subtype=capture negate=
    rx2457_cur."!cursor_pos"(rx2457_pos)
    $P10 = rx2457_cur."LANG"("MAIN", "pblock")
    unless $P10, rx2457_fail
    rx2457_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx2457_pos = $P10."pos"()
.annotate 'line', 734
  # rx pass
    rx2457_cur."!cursor_pass"(rx2457_pos, "codeblock")
    if_null rx2457_debug, debug_1370
    rx2457_cur."!cursor_debug"("PASS", "codeblock", " at pos=", rx2457_pos)
  debug_1370:
    .return (rx2457_cur)
  rx2457_restart:
.annotate 'line', 698
    if_null rx2457_debug, debug_1371
    rx2457_cur."!cursor_debug"("NEXT", "codeblock")
  debug_1371:
  rx2457_fail:
    (rx2457_rep, rx2457_pos, $I10, $P10) = rx2457_cur."!mark_fail"(0)
    lt rx2457_pos, -1, rx2457_done
    eq rx2457_pos, -1, rx2457_fail
    jump $I10
  rx2457_done:
    rx2457_cur."!cursor_fail"()
    if_null rx2457_debug, debug_1372
    rx2457_cur."!cursor_debug"("FAIL", "codeblock")
  debug_1372:
    .return (rx2457_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__codeblock"  :nsentry("!PREFIX__codeblock") :subid("403_1300062003.824") :method
.annotate 'line', 698
    $P2459 = self."!PREFIX__!subrule"("LANG", "")
    new $P2460, "ResizablePMCArray"
    push $P2460, $P2459
    .return ($P2460)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2501"  :subid("405_1300062003.824") :outer("10_1300062003.824")
.annotate 'line', 741
    .const 'Sub' $P5479 = "557_1300062003.824" 
    capture_lex $P5479
    .const 'Sub' $P5469 = "556_1300062003.824" 
    capture_lex $P5469
    .const 'Sub' $P5464 = "555_1300062003.824" 
    capture_lex $P5464
    .const 'Sub' $P5459 = "554_1300062003.824" 
    capture_lex $P5459
    .const 'Sub' $P5454 = "553_1300062003.824" 
    capture_lex $P5454
    .const 'Sub' $P5443 = "552_1300062003.824" 
    capture_lex $P5443
    .const 'Sub' $P5435 = "551_1300062003.824" 
    capture_lex $P5435
    .const 'Sub' $P5427 = "550_1300062003.824" 
    capture_lex $P5427
    .const 'Sub' $P5419 = "549_1300062003.824" 
    capture_lex $P5419
    .const 'Sub' $P5414 = "548_1300062003.824" 
    capture_lex $P5414
    .const 'Sub' $P5402 = "547_1300062003.824" 
    capture_lex $P5402
    .const 'Sub' $P5394 = "546_1300062003.824" 
    capture_lex $P5394
    .const 'Sub' $P5356 = "545_1300062003.824" 
    capture_lex $P5356
    .const 'Sub' $P5344 = "544_1300062003.824" 
    capture_lex $P5344
    .const 'Sub' $P5336 = "543_1300062003.824" 
    capture_lex $P5336
    .const 'Sub' $P5328 = "542_1300062003.824" 
    capture_lex $P5328
    .const 'Sub' $P5320 = "541_1300062003.824" 
    capture_lex $P5320
    .const 'Sub' $P5312 = "540_1300062003.824" 
    capture_lex $P5312
    .const 'Sub' $P5304 = "539_1300062003.824" 
    capture_lex $P5304
    .const 'Sub' $P5278 = "538_1300062003.824" 
    capture_lex $P5278
    .const 'Sub' $P5263 = "537_1300062003.824" 
    capture_lex $P5263
    .const 'Sub' $P5255 = "536_1300062003.824" 
    capture_lex $P5255
    .const 'Sub' $P5244 = "535_1300062003.824" 
    capture_lex $P5244
    .const 'Sub' $P5233 = "534_1300062003.824" 
    capture_lex $P5233
    .const 'Sub' $P5222 = "533_1300062003.824" 
    capture_lex $P5222
    .const 'Sub' $P5214 = "532_1300062003.824" 
    capture_lex $P5214
    .const 'Sub' $P5187 = "531_1300062003.824" 
    capture_lex $P5187
    .const 'Sub' $P5149 = "529_1300062003.824" 
    capture_lex $P5149
    .const 'Sub' $P5141 = "528_1300062003.824" 
    capture_lex $P5141
    .const 'Sub' $P5133 = "527_1300062003.824" 
    capture_lex $P5133
    .const 'Sub' $P5108 = "526_1300062003.824" 
    capture_lex $P5108
    .const 'Sub' $P5092 = "525_1300062003.824" 
    capture_lex $P5092
    .const 'Sub' $P5084 = "524_1300062003.824" 
    capture_lex $P5084
    .const 'Sub' $P5076 = "523_1300062003.824" 
    capture_lex $P5076
    .const 'Sub' $P4974 = "520_1300062003.824" 
    capture_lex $P4974
    .const 'Sub' $P4966 = "519_1300062003.824" 
    capture_lex $P4966
    .const 'Sub' $P4959 = "518_1300062003.824" 
    capture_lex $P4959
    .const 'Sub' $P4932 = "517_1300062003.824" 
    capture_lex $P4932
    .const 'Sub' $P4878 = "515_1300062003.824" 
    capture_lex $P4878
    .const 'Sub' $P4864 = "514_1300062003.824" 
    capture_lex $P4864
    .const 'Sub' $P4857 = "513_1300062003.824" 
    capture_lex $P4857
    .const 'Sub' $P4808 = "512_1300062003.824" 
    capture_lex $P4808
    .const 'Sub' $P4643 = "508_1300062003.824" 
    capture_lex $P4643
    .const 'Sub' $P4580 = "506_1300062003.824" 
    capture_lex $P4580
    .const 'Sub' $P4572 = "505_1300062003.824" 
    capture_lex $P4572
    .const 'Sub' $P4557 = "504_1300062003.824" 
    capture_lex $P4557
    .const 'Sub' $P4542 = "503_1300062003.824" 
    capture_lex $P4542
    .const 'Sub' $P4524 = "502_1300062003.824" 
    capture_lex $P4524
    .const 'Sub' $P4425 = "501_1300062003.824" 
    capture_lex $P4425
    .const 'Sub' $P4381 = "498_1300062003.824" 
    capture_lex $P4381
    .const 'Sub' $P4256 = "495_1300062003.824" 
    capture_lex $P4256
    .const 'Sub' $P4005 = "488_1300062003.824" 
    capture_lex $P4005
    .const 'Sub' $P3997 = "487_1300062003.824" 
    capture_lex $P3997
    .const 'Sub' $P3989 = "486_1300062003.824" 
    capture_lex $P3989
    .const 'Sub' $P3888 = "482_1300062003.824" 
    capture_lex $P3888
    .const 'Sub' $P3880 = "481_1300062003.824" 
    capture_lex $P3880
    .const 'Sub' $P3865 = "480_1300062003.824" 
    capture_lex $P3865
    .const 'Sub' $P3850 = "479_1300062003.824" 
    capture_lex $P3850
    .const 'Sub' $P3835 = "478_1300062003.824" 
    capture_lex $P3835
    .const 'Sub' $P3813 = "477_1300062003.824" 
    capture_lex $P3813
    .const 'Sub' $P3805 = "476_1300062003.824" 
    capture_lex $P3805
    .const 'Sub' $P3797 = "475_1300062003.824" 
    capture_lex $P3797
    .const 'Sub' $P3789 = "474_1300062003.824" 
    capture_lex $P3789
    .const 'Sub' $P3592 = "471_1300062003.824" 
    capture_lex $P3592
    .const 'Sub' $P3584 = "470_1300062003.824" 
    capture_lex $P3584
    .const 'Sub' $P3576 = "469_1300062003.824" 
    capture_lex $P3576
    .const 'Sub' $P3568 = "468_1300062003.824" 
    capture_lex $P3568
    .const 'Sub' $P3560 = "467_1300062003.824" 
    capture_lex $P3560
    .const 'Sub' $P3552 = "466_1300062003.824" 
    capture_lex $P3552
    .const 'Sub' $P3544 = "465_1300062003.824" 
    capture_lex $P3544
    .const 'Sub' $P3454 = "463_1300062003.824" 
    capture_lex $P3454
    .const 'Sub' $P3430 = "462_1300062003.824" 
    capture_lex $P3430
    .const 'Sub' $P3416 = "461_1300062003.824" 
    capture_lex $P3416
    .const 'Sub' $P3408 = "460_1300062003.824" 
    capture_lex $P3408
    .const 'Sub' $P3400 = "459_1300062003.824" 
    capture_lex $P3400
    .const 'Sub' $P3392 = "458_1300062003.824" 
    capture_lex $P3392
    .const 'Sub' $P3384 = "457_1300062003.824" 
    capture_lex $P3384
    .const 'Sub' $P3376 = "456_1300062003.824" 
    capture_lex $P3376
    .const 'Sub' $P3368 = "455_1300062003.824" 
    capture_lex $P3368
    .const 'Sub' $P3360 = "454_1300062003.824" 
    capture_lex $P3360
    .const 'Sub' $P3352 = "453_1300062003.824" 
    capture_lex $P3352
    .const 'Sub' $P3344 = "452_1300062003.824" 
    capture_lex $P3344
    .const 'Sub' $P3336 = "451_1300062003.824" 
    capture_lex $P3336
    .const 'Sub' $P3328 = "450_1300062003.824" 
    capture_lex $P3328
    .const 'Sub' $P3320 = "449_1300062003.824" 
    capture_lex $P3320
    .const 'Sub' $P3312 = "448_1300062003.824" 
    capture_lex $P3312
    .const 'Sub' $P3296 = "447_1300062003.824" 
    capture_lex $P3296
    .const 'Sub' $P3263 = "446_1300062003.824" 
    capture_lex $P3263
    .const 'Sub' $P3249 = "445_1300062003.824" 
    capture_lex $P3249
    .const 'Sub' $P3230 = "444_1300062003.824" 
    capture_lex $P3230
    .const 'Sub' $P3212 = "443_1300062003.824" 
    capture_lex $P3212
    .const 'Sub' $P3188 = "442_1300062003.824" 
    capture_lex $P3188
    .const 'Sub' $P3154 = "441_1300062003.824" 
    capture_lex $P3154
    .const 'Sub' $P3139 = "440_1300062003.824" 
    capture_lex $P3139
    .const 'Sub' $P3127 = "439_1300062003.824" 
    capture_lex $P3127
    .const 'Sub' $P3076 = "437_1300062003.824" 
    capture_lex $P3076
    .const 'Sub' $P3065 = "436_1300062003.824" 
    capture_lex $P3065
    .const 'Sub' $P3058 = "435_1300062003.824" 
    capture_lex $P3058
    .const 'Sub' $P3036 = "434_1300062003.824" 
    capture_lex $P3036
    .const 'Sub' $P3025 = "433_1300062003.824" 
    capture_lex $P3025
    .const 'Sub' $P2990 = "431_1300062003.824" 
    capture_lex $P2990
    .const 'Sub' $P2982 = "430_1300062003.824" 
    capture_lex $P2982
    .const 'Sub' $P2974 = "429_1300062003.824" 
    capture_lex $P2974
    .const 'Sub' $P2960 = "428_1300062003.824" 
    capture_lex $P2960
    .const 'Sub' $P2879 = "426_1300062003.824" 
    capture_lex $P2879
    .const 'Sub' $P2838 = "424_1300062003.824" 
    capture_lex $P2838
    .const 'Sub' $P2787 = "423_1300062003.824" 
    capture_lex $P2787
    .const 'Sub' $P2756 = "422_1300062003.824" 
    capture_lex $P2756
    .const 'Sub' $P2748 = "421_1300062003.824" 
    capture_lex $P2748
    .const 'Sub' $P2740 = "419_1300062003.824" 
    capture_lex $P2740
    .const 'Sub' $P2726 = "418_1300062003.824" 
    capture_lex $P2726
    .const 'Sub' $P2700 = "416_1300062003.824" 
    capture_lex $P2700
    .const 'Sub' $P2635 = "414_1300062003.824" 
    capture_lex $P2635
    .const 'Sub' $P2625 = "413_1300062003.824" 
    capture_lex $P2625
    .const 'Sub' $P2577 = "412_1300062003.824" 
    capture_lex $P2577
    .const 'Sub' $P2564 = "411_1300062003.824" 
    capture_lex $P2564
    .const 'Sub' $P2546 = "410_1300062003.824" 
    capture_lex $P2546
    .const 'Sub' $P2513 = "407_1300062003.824" 
    capture_lex $P2513
    .const 'Sub' $P2505 = "406_1300062003.824" 
    capture_lex $P2505
    get_global $P2503, "$?CLASS"
.annotate 'line', 743
    get_global $P2504, "@BLOCK"
    unless_null $P2504, vivify_1374
    $P2504 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P2504
  vivify_1374:
.annotate 'line', 749
    .const 'Sub' $P2505 = "406_1300062003.824" 
    newclosure $P2512, $P2505
    .lex "xblock_immediate", $P2512
.annotate 'line', 754
    .const 'Sub' $P2513 = "407_1300062003.824" 
    newclosure $P2545, $P2513
    .lex "block_immediate", $P2545
.annotate 'line', 764
    .const 'Sub' $P2546 = "410_1300062003.824" 
    newclosure $P2563, $P2546
    .lex "vivitype", $P2563
.annotate 'line', 783
    .const 'Sub' $P2564 = "411_1300062003.824" 
    newclosure $P2576, $P2564
    .lex "colonpair_str", $P2576
.annotate 'line', 1005
    .const 'Sub' $P2577 = "412_1300062003.824" 
    newclosure $P2624, $P2577
    .lex "push_block_handler", $P2624
.annotate 'line', 1547
    .const 'Sub' $P2625 = "413_1300062003.824" 
    newclosure $P2634, $P2625
    .lex "only_star_block", $P2634
.annotate 'line', 1556
    .const 'Sub' $P2635 = "414_1300062003.824" 
    newclosure $P2699, $P2635
    .lex "attach_multi_signature", $P2699
.annotate 'line', 1844
    .const 'Sub' $P2700 = "416_1300062003.824" 
    newclosure $P2725, $P2700
    .lex "is_lexical", $P2725
.annotate 'line', 2052
    .const 'Sub' $P2726 = "418_1300062003.824" 
    newclosure $P2737, $P2726
    .lex "control", $P2737
.annotate 'line', 741
    get_global $P2738, "@BLOCK"
    .const 'Sub' $P2740 = "419_1300062003.824" 
    capture_lex $P2740
    $P2740()
    find_lex $P2745, "xblock_immediate"
    find_lex $P2746, "block_immediate"
    find_lex $P2747, "vivitype"
.annotate 'line', 775
    find_lex $P2786, "colonpair_str"
.annotate 'line', 998
    find_lex $P3248, "push_block_handler"
.annotate 'line', 1475
    find_lex $P4379, "only_star_block"
    find_lex $P4380, "attach_multi_signature"
.annotate 'line', 1822
    find_lex $P4931, "is_lexical"
.annotate 'line', 2043
    find_lex $P5453, "control"
.annotate 'line', 2065
    .const 'Sub' $P5469 = "556_1300062003.824" 
    newclosure $P5477, $P5469
.annotate 'line', 741
    .return ($P5477)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "" :load :init :subid("post1373") :outer("405_1300062003.824")
.annotate 'line', 741
    get_hll_global $P2502, ["NQP";"Actions"], "_block2501" 
    .local pmc block
    set block, $P2502
    .const 'Sub' $P5479 = "557_1300062003.824" 
    capture_lex $P5479
    $P5479()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5478"  :anon :subid("557_1300062003.824") :outer("405_1300062003.824")
.annotate 'line', 741
    nqp_get_sc_object $P5480, "1300061983.846", 2
    .local pmc type_obj
    set type_obj, $P5480
    set_global "$?CLASS", type_obj
    get_how $P5481, type_obj
    .const 'Sub' $P5482 = "421_1300062003.824" 
    $P5481."add_method"(type_obj, "TOP", $P5482)
    get_how $P5483, type_obj
    .const 'Sub' $P5484 = "422_1300062003.824" 
    $P5483."add_method"(type_obj, "deflongname", $P5484)
    get_how $P5485, type_obj
    .const 'Sub' $P5486 = "423_1300062003.824" 
    $P5485."add_method"(type_obj, "comp_unit", $P5486)
    get_how $P5487, type_obj
    .const 'Sub' $P5488 = "424_1300062003.824" 
    $P5487."add_method"(type_obj, "statementlist", $P5488)
    get_how $P5489, type_obj
    .const 'Sub' $P5490 = "426_1300062003.824" 
    $P5489."add_method"(type_obj, "statement", $P5490)
    get_how $P5491, type_obj
    .const 'Sub' $P5492 = "428_1300062003.824" 
    $P5491."add_method"(type_obj, "xblock", $P5492)
    get_how $P5493, type_obj
    .const 'Sub' $P5494 = "429_1300062003.824" 
    $P5493."add_method"(type_obj, "pblock", $P5494)
    get_how $P5495, type_obj
    .const 'Sub' $P5496 = "430_1300062003.824" 
    $P5495."add_method"(type_obj, "block", $P5496)
    get_how $P5497, type_obj
    .const 'Sub' $P5498 = "431_1300062003.824" 
    $P5497."add_method"(type_obj, "blockoid", $P5498)
    get_how $P5499, type_obj
    .const 'Sub' $P5500 = "433_1300062003.824" 
    $P5499."add_method"(type_obj, "newpad", $P5500)
    get_how $P5501, type_obj
    .const 'Sub' $P5502 = "434_1300062003.824" 
    $P5501."add_method"(type_obj, "outerctx", $P5502)
    get_how $P5503, type_obj
    .const 'Sub' $P5504 = "435_1300062003.824" 
    $P5503."add_method"(type_obj, "you_are_here", $P5504)
    get_how $P5505, type_obj
    .const 'Sub' $P5506 = "436_1300062003.824" 
    $P5505."add_method"(type_obj, "statement_control:sym<use>", $P5506)
    get_how $P5507, type_obj
    .const 'Sub' $P5508 = "437_1300062003.824" 
    $P5507."add_method"(type_obj, "statement_control:sym<if>", $P5508)
    get_how $P5509, type_obj
    .const 'Sub' $P5510 = "439_1300062003.824" 
    $P5509."add_method"(type_obj, "statement_control:sym<unless>", $P5510)
    get_how $P5511, type_obj
    .const 'Sub' $P5512 = "440_1300062003.824" 
    $P5511."add_method"(type_obj, "statement_control:sym<while>", $P5512)
    get_how $P5513, type_obj
    .const 'Sub' $P5514 = "441_1300062003.824" 
    $P5513."add_method"(type_obj, "statement_control:sym<repeat>", $P5514)
    get_how $P5515, type_obj
    .const 'Sub' $P5516 = "442_1300062003.824" 
    $P5515."add_method"(type_obj, "statement_control:sym<for>", $P5516)
    get_how $P5517, type_obj
    .const 'Sub' $P5518 = "443_1300062003.824" 
    $P5517."add_method"(type_obj, "statement_control:sym<CATCH>", $P5518)
    get_how $P5519, type_obj
    .const 'Sub' $P5520 = "444_1300062003.824" 
    $P5519."add_method"(type_obj, "statement_control:sym<CONTROL>", $P5520)
    get_how $P5521, type_obj
    .const 'Sub' $P5522 = "445_1300062003.824" 
    $P5521."add_method"(type_obj, "statement_prefix:sym<INIT>", $P5522)
    get_how $P5523, type_obj
    .const 'Sub' $P5524 = "446_1300062003.824" 
    $P5523."add_method"(type_obj, "statement_prefix:sym<try>", $P5524)
    get_how $P5525, type_obj
    .const 'Sub' $P5526 = "447_1300062003.824" 
    $P5525."add_method"(type_obj, "blorst", $P5526)
    get_how $P5527, type_obj
    .const 'Sub' $P5528 = "448_1300062003.824" 
    $P5527."add_method"(type_obj, "statement_mod_cond:sym<if>", $P5528)
    get_how $P5529, type_obj
    .const 'Sub' $P5530 = "449_1300062003.824" 
    $P5529."add_method"(type_obj, "statement_mod_cond:sym<unless>", $P5530)
    get_how $P5531, type_obj
    .const 'Sub' $P5532 = "450_1300062003.824" 
    $P5531."add_method"(type_obj, "statement_mod_loop:sym<while>", $P5532)
    get_how $P5533, type_obj
    .const 'Sub' $P5534 = "451_1300062003.824" 
    $P5533."add_method"(type_obj, "statement_mod_loop:sym<until>", $P5534)
    get_how $P5535, type_obj
    .const 'Sub' $P5536 = "452_1300062003.824" 
    $P5535."add_method"(type_obj, "term:sym<fatarrow>", $P5536)
    get_how $P5537, type_obj
    .const 'Sub' $P5538 = "453_1300062003.824" 
    $P5537."add_method"(type_obj, "term:sym<colonpair>", $P5538)
    get_how $P5539, type_obj
    .const 'Sub' $P5540 = "454_1300062003.824" 
    $P5539."add_method"(type_obj, "term:sym<variable>", $P5540)
    get_how $P5541, type_obj
    .const 'Sub' $P5542 = "455_1300062003.824" 
    $P5541."add_method"(type_obj, "term:sym<package_declarator>", $P5542)
    get_how $P5543, type_obj
    .const 'Sub' $P5544 = "456_1300062003.824" 
    $P5543."add_method"(type_obj, "term:sym<scope_declarator>", $P5544)
    get_how $P5545, type_obj
    .const 'Sub' $P5546 = "457_1300062003.824" 
    $P5545."add_method"(type_obj, "term:sym<routine_declarator>", $P5546)
    get_how $P5547, type_obj
    .const 'Sub' $P5548 = "458_1300062003.824" 
    $P5547."add_method"(type_obj, "term:sym<regex_declarator>", $P5548)
    get_how $P5549, type_obj
    .const 'Sub' $P5550 = "459_1300062003.824" 
    $P5549."add_method"(type_obj, "term:sym<statement_prefix>", $P5550)
    get_how $P5551, type_obj
    .const 'Sub' $P5552 = "460_1300062003.824" 
    $P5551."add_method"(type_obj, "term:sym<lambda>", $P5552)
    get_how $P5553, type_obj
    .const 'Sub' $P5554 = "461_1300062003.824" 
    $P5553."add_method"(type_obj, "fatarrow", $P5554)
    get_how $P5555, type_obj
    .const 'Sub' $P5556 = "462_1300062003.824" 
    $P5555."add_method"(type_obj, "colonpair", $P5556)
    get_how $P5557, type_obj
    .const 'Sub' $P5558 = "463_1300062003.824" 
    $P5557."add_method"(type_obj, "variable", $P5558)
    get_how $P5559, type_obj
    .const 'Sub' $P5560 = "465_1300062003.824" 
    $P5559."add_method"(type_obj, "package_declarator:sym<module>", $P5560)
    get_how $P5561, type_obj
    .const 'Sub' $P5562 = "466_1300062003.824" 
    $P5561."add_method"(type_obj, "package_declarator:sym<knowhow>", $P5562)
    get_how $P5563, type_obj
    .const 'Sub' $P5564 = "467_1300062003.824" 
    $P5563."add_method"(type_obj, "package_declarator:sym<class>", $P5564)
    get_how $P5565, type_obj
    .const 'Sub' $P5566 = "468_1300062003.824" 
    $P5565."add_method"(type_obj, "package_declarator:sym<grammar>", $P5566)
    get_how $P5567, type_obj
    .const 'Sub' $P5568 = "469_1300062003.824" 
    $P5567."add_method"(type_obj, "package_declarator:sym<role>", $P5568)
    get_how $P5569, type_obj
    .const 'Sub' $P5570 = "470_1300062003.824" 
    $P5569."add_method"(type_obj, "package_declarator:sym<native>", $P5570)
    get_how $P5571, type_obj
    .const 'Sub' $P5572 = "471_1300062003.824" 
    $P5571."add_method"(type_obj, "package_def", $P5572)
    get_how $P5573, type_obj
    .const 'Sub' $P5574 = "474_1300062003.824" 
    $P5573."add_method"(type_obj, "scope_declarator:sym<my>", $P5574)
    get_how $P5575, type_obj
    .const 'Sub' $P5576 = "475_1300062003.824" 
    $P5575."add_method"(type_obj, "scope_declarator:sym<our>", $P5576)
    get_how $P5577, type_obj
    .const 'Sub' $P5578 = "476_1300062003.824" 
    $P5577."add_method"(type_obj, "scope_declarator:sym<has>", $P5578)
    get_how $P5579, type_obj
    .const 'Sub' $P5580 = "477_1300062003.824" 
    $P5579."add_method"(type_obj, "scoped", $P5580)
    get_how $P5581, type_obj
    .const 'Sub' $P5582 = "478_1300062003.824" 
    $P5581."add_method"(type_obj, "declarator", $P5582)
    get_how $P5583, type_obj
    .const 'Sub' $P5584 = "479_1300062003.824" 
    $P5583."add_method"(type_obj, "multi_declarator:sym<multi>", $P5584)
    get_how $P5585, type_obj
    .const 'Sub' $P5586 = "480_1300062003.824" 
    $P5585."add_method"(type_obj, "multi_declarator:sym<proto>", $P5586)
    get_how $P5587, type_obj
    .const 'Sub' $P5588 = "481_1300062003.824" 
    $P5587."add_method"(type_obj, "multi_declarator:sym<null>", $P5588)
    get_how $P5589, type_obj
    .const 'Sub' $P5590 = "482_1300062003.824" 
    $P5589."add_method"(type_obj, "variable_declarator", $P5590)
    get_how $P5591, type_obj
    .const 'Sub' $P5592 = "486_1300062003.824" 
    $P5591."add_method"(type_obj, "routine_declarator:sym<sub>", $P5592)
    get_how $P5593, type_obj
    .const 'Sub' $P5594 = "487_1300062003.824" 
    $P5593."add_method"(type_obj, "routine_declarator:sym<method>", $P5594)
    get_how $P5595, type_obj
    .const 'Sub' $P5596 = "488_1300062003.824" 
    $P5595."add_method"(type_obj, "routine_def", $P5596)
    get_how $P5597, type_obj
    .const 'Sub' $P5598 = "495_1300062003.824" 
    $P5597."add_method"(type_obj, "method_def", $P5598)
    get_how $P5599, type_obj
    .const 'Sub' $P5600 = "498_1300062003.824" 
    $P5599."add_method"(type_obj, "signature", $P5600)
    get_how $P5601, type_obj
    .const 'Sub' $P5602 = "501_1300062003.824" 
    $P5601."add_method"(type_obj, "parameter", $P5602)
    get_how $P5603, type_obj
    .const 'Sub' $P5604 = "502_1300062003.824" 
    $P5603."add_method"(type_obj, "param_var", $P5604)
    get_how $P5605, type_obj
    .const 'Sub' $P5606 = "503_1300062003.824" 
    $P5605."add_method"(type_obj, "named_param", $P5606)
    get_how $P5607, type_obj
    .const 'Sub' $P5608 = "504_1300062003.824" 
    $P5607."add_method"(type_obj, "typename", $P5608)
    get_how $P5609, type_obj
    .const 'Sub' $P5610 = "505_1300062003.824" 
    $P5609."add_method"(type_obj, "trait", $P5610)
    get_how $P5611, type_obj
    .const 'Sub' $P5612 = "506_1300062003.824" 
    $P5611."add_method"(type_obj, "trait_mod:sym<is>", $P5612)
    get_how $P5613, type_obj
    .const 'Sub' $P5614 = "508_1300062003.824" 
    $P5613."add_method"(type_obj, "regex_declarator", $P5614)
    get_how $P5615, type_obj
    .const 'Sub' $P5616 = "512_1300062003.824" 
    $P5615."add_method"(type_obj, "dotty", $P5616)
    get_how $P5617, type_obj
    .const 'Sub' $P5618 = "513_1300062003.824" 
    $P5617."add_method"(type_obj, "term:sym<self>", $P5618)
    get_how $P5619, type_obj
    .const 'Sub' $P5620 = "514_1300062003.824" 
    $P5619."add_method"(type_obj, "term:sym<identifier>", $P5620)
    get_how $P5621, type_obj
    .const 'Sub' $P5622 = "515_1300062003.824" 
    $P5621."add_method"(type_obj, "term:sym<name>", $P5622)
    get_how $P5623, type_obj
    .const 'Sub' $P5624 = "517_1300062003.824" 
    $P5623."add_method"(type_obj, "term:sym<pir::op>", $P5624)
    get_how $P5625, type_obj
    .const 'Sub' $P5626 = "518_1300062003.824" 
    $P5625."add_method"(type_obj, "term:sym<onlystar>", $P5626)
    get_how $P5627, type_obj
    .const 'Sub' $P5628 = "519_1300062003.824" 
    $P5627."add_method"(type_obj, "args", $P5628)
    get_how $P5629, type_obj
    .const 'Sub' $P5630 = "520_1300062003.824" 
    $P5629."add_method"(type_obj, "arglist", $P5630)
    get_how $P5631, type_obj
    .const 'Sub' $P5632 = "523_1300062003.824" 
    $P5631."add_method"(type_obj, "term:sym<multi_declarator>", $P5632)
    get_how $P5633, type_obj
    .const 'Sub' $P5634 = "524_1300062003.824" 
    $P5633."add_method"(type_obj, "term:sym<value>", $P5634)
    get_how $P5635, type_obj
    .const 'Sub' $P5636 = "525_1300062003.824" 
    $P5635."add_method"(type_obj, "circumfix:sym<( )>", $P5636)
    get_how $P5637, type_obj
    .const 'Sub' $P5638 = "526_1300062003.824" 
    $P5637."add_method"(type_obj, "circumfix:sym<[ ]>", $P5638)
    get_how $P5639, type_obj
    .const 'Sub' $P5640 = "527_1300062003.824" 
    $P5639."add_method"(type_obj, "circumfix:sym<ang>", $P5640)
    get_how $P5641, type_obj
    .const 'Sub' $P5642 = "528_1300062003.824" 
    $P5641."add_method"(type_obj, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P5642)
    get_how $P5643, type_obj
    .const 'Sub' $P5644 = "529_1300062003.824" 
    $P5643."add_method"(type_obj, "circumfix:sym<{ }>", $P5644)
    get_how $P5645, type_obj
    .const 'Sub' $P5646 = "531_1300062003.824" 
    $P5645."add_method"(type_obj, "circumfix:sym<sigil>", $P5646)
    get_how $P5647, type_obj
    .const 'Sub' $P5648 = "532_1300062003.824" 
    $P5647."add_method"(type_obj, "semilist", $P5648)
    get_how $P5649, type_obj
    .const 'Sub' $P5650 = "533_1300062003.824" 
    $P5649."add_method"(type_obj, "postcircumfix:sym<[ ]>", $P5650)
    get_how $P5651, type_obj
    .const 'Sub' $P5652 = "534_1300062003.824" 
    $P5651."add_method"(type_obj, "postcircumfix:sym<{ }>", $P5652)
    get_how $P5653, type_obj
    .const 'Sub' $P5654 = "535_1300062003.824" 
    $P5653."add_method"(type_obj, "postcircumfix:sym<ang>", $P5654)
    get_how $P5655, type_obj
    .const 'Sub' $P5656 = "536_1300062003.824" 
    $P5655."add_method"(type_obj, "postcircumfix:sym<( )>", $P5656)
    get_how $P5657, type_obj
    .const 'Sub' $P5658 = "537_1300062003.824" 
    $P5657."add_method"(type_obj, "value", $P5658)
    get_how $P5659, type_obj
    .const 'Sub' $P5660 = "538_1300062003.824" 
    $P5659."add_method"(type_obj, "number", $P5660)
    get_how $P5661, type_obj
    .const 'Sub' $P5662 = "539_1300062003.824" 
    $P5661."add_method"(type_obj, "quote:sym<apos>", $P5662)
    get_how $P5663, type_obj
    .const 'Sub' $P5664 = "540_1300062003.824" 
    $P5663."add_method"(type_obj, "quote:sym<dblq>", $P5664)
    get_how $P5665, type_obj
    .const 'Sub' $P5666 = "541_1300062003.824" 
    $P5665."add_method"(type_obj, "quote:sym<qq>", $P5666)
    get_how $P5667, type_obj
    .const 'Sub' $P5668 = "542_1300062003.824" 
    $P5667."add_method"(type_obj, "quote:sym<q>", $P5668)
    get_how $P5669, type_obj
    .const 'Sub' $P5670 = "543_1300062003.824" 
    $P5669."add_method"(type_obj, "quote:sym<Q>", $P5670)
    get_how $P5671, type_obj
    .const 'Sub' $P5672 = "544_1300062003.824" 
    $P5671."add_method"(type_obj, "quote:sym<Q:PIR>", $P5672)
    get_how $P5673, type_obj
    .const 'Sub' $P5674 = "545_1300062003.824" 
    $P5673."add_method"(type_obj, "quote:sym</ />", $P5674)
    get_how $P5675, type_obj
    .const 'Sub' $P5676 = "546_1300062003.824" 
    $P5675."add_method"(type_obj, "quote_escape:sym<$>", $P5676)
    get_how $P5677, type_obj
    .const 'Sub' $P5678 = "547_1300062003.824" 
    $P5677."add_method"(type_obj, "quote_escape:sym<{ }>", $P5678)
    get_how $P5679, type_obj
    .const 'Sub' $P5680 = "548_1300062003.824" 
    $P5679."add_method"(type_obj, "quote_escape:sym<esc>", $P5680)
    get_how $P5681, type_obj
    .const 'Sub' $P5682 = "549_1300062003.824" 
    $P5681."add_method"(type_obj, "postfix:sym<.>", $P5682)
    get_how $P5683, type_obj
    .const 'Sub' $P5684 = "550_1300062003.824" 
    $P5683."add_method"(type_obj, "postfix:sym<++>", $P5684)
    get_how $P5685, type_obj
    .const 'Sub' $P5686 = "551_1300062003.824" 
    $P5685."add_method"(type_obj, "postfix:sym<-->", $P5686)
    get_how $P5687, type_obj
    .const 'Sub' $P5688 = "552_1300062003.824" 
    $P5687."add_method"(type_obj, "prefix:sym<make>", $P5688)
    get_how $P5689, type_obj
    .const 'Sub' $P5690 = "553_1300062003.824" 
    $P5689."add_method"(type_obj, "term:sym<next>", $P5690)
    get_how $P5691, type_obj
    .const 'Sub' $P5692 = "554_1300062003.824" 
    $P5691."add_method"(type_obj, "term:sym<last>", $P5692)
    get_how $P5693, type_obj
    .const 'Sub' $P5694 = "555_1300062003.824" 
    $P5693."add_method"(type_obj, "term:sym<redo>", $P5694)
    get_how $P5695, type_obj
    .const 'Sub' $P5696 = "556_1300062003.824" 
    $P5695."add_method"(type_obj, "infix:sym<~~>", $P5696)
    get_how $P5697, type_obj
    get_hll_global $P5698, ["HLL"], "Actions"
    $P5697."add_parent"(type_obj, $P5698)
    get_how $P5699, type_obj
    $P5700 = $P5699."compose"(type_obj)
    .return ($P5700)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock_immediate"  :subid("406_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_2506
.annotate 'line', 749
    .lex "$xblock", param_2506
.annotate 'line', 750
    find_lex $P2507, "$xblock"
    unless_null $P2507, vivify_1375
    $P2507 = root_new ['parrot';'ResizablePMCArray']
  vivify_1375:
    set $P2508, $P2507[1]
    unless_null $P2508, vivify_1376
    new $P2508, "Undef"
  vivify_1376:
    $P2509 = "block_immediate"($P2508)
    find_lex $P2510, "$xblock"
    unless_null $P2510, vivify_1377
    $P2510 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$xblock", $P2510
  vivify_1377:
    set $P2510[1], $P2509
    find_lex $P2511, "$xblock"
.annotate 'line', 749
    .return ($P2511)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block_immediate"  :subid("407_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_2514
.annotate 'line', 754
    .const 'Sub' $P2524 = "408_1300062003.824" 
    capture_lex $P2524
    .lex "$block", param_2514
.annotate 'line', 755
    find_lex $P2515, "$block"
    $P2515."blocktype"("immediate")
.annotate 'line', 756
    find_lex $P2519, "$block"
    $P2520 = $P2519."symtable"()
    unless $P2520, unless_2518
    set $P2517, $P2520
    goto unless_2518_end
  unless_2518:
    find_lex $P2521, "$block"
    $P2522 = $P2521."handlers"()
    set $P2517, $P2522
  unless_2518_end:
    if $P2517, unless_2516_end
    .const 'Sub' $P2524 = "408_1300062003.824" 
    capture_lex $P2524
    $P2524()
  unless_2516_end:
    find_lex $P2544, "$block"
.annotate 'line', 754
    .return ($P2544)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2523"  :anon :subid("408_1300062003.824") :outer("407_1300062003.824")
.annotate 'line', 756
    .const 'Sub' $P2535 = "409_1300062003.824" 
    capture_lex $P2535
.annotate 'line', 757
    new $P2525, "Undef"
    .lex "$stmts", $P2525
    get_hll_global $P2526, ["PAST"], "Stmts"
    find_lex $P2527, "$block"
    $P2528 = $P2526."new"($P2527 :named("node"))
    store_lex "$stmts", $P2528
.annotate 'line', 758
    find_lex $P2530, "$block"
    $P2531 = $P2530."list"()
    defined $I2532, $P2531
    unless $I2532, for_undef_1378
    iter $P2529, $P2531
    new $P2541, 'ExceptionHandler'
    set_label $P2541, loop2540_handler
    $P2541."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2541
  loop2540_test:
    unless $P2529, loop2540_done
    shift $P2533, $P2529
  loop2540_redo:
    .const 'Sub' $P2535 = "409_1300062003.824" 
    capture_lex $P2535
    $P2535($P2533)
  loop2540_next:
    goto loop2540_test
  loop2540_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2542, exception, 'type'
    eq $P2542, .CONTROL_LOOP_NEXT, loop2540_next
    eq $P2542, .CONTROL_LOOP_REDO, loop2540_redo
  loop2540_done:
    pop_eh 
  for_undef_1378:
.annotate 'line', 759
    find_lex $P2543, "$stmts"
    store_lex "$block", $P2543
.annotate 'line', 756
    .return ($P2543)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2534"  :anon :subid("409_1300062003.824") :outer("408_1300062003.824")
    .param pmc param_2536
.annotate 'line', 758
    .lex "$_", param_2536
    find_lex $P2537, "$stmts"
    find_lex $P2538, "$_"
    $P2539 = $P2537."push"($P2538)
    .return ($P2539)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "vivitype"  :subid("410_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_2547
.annotate 'line', 764
    .lex "$sigil", param_2547
.annotate 'line', 765
    find_lex $P2550, "$sigil"
    set $S2551, $P2550
    iseq $I2552, $S2551, "%"
    if $I2552, if_2549
.annotate 'line', 767
    find_lex $P2557, "$sigil"
    set $S2558, $P2557
    iseq $I2559, $S2558, "@"
    if $I2559, if_2556
    new $P2562, "String"
    assign $P2562, "Undef"
    set $P2555, $P2562
    goto if_2556_end
  if_2556:
.annotate 'line', 768
    get_hll_global $P2560, ["PAST"], "Op"
    $P2561 = $P2560."new"("    %r = root_new ['parrot';'ResizablePMCArray']" :named("inline"))
    set $P2555, $P2561
  if_2556_end:
    set $P2548, $P2555
.annotate 'line', 765
    goto if_2549_end
  if_2549:
.annotate 'line', 766
    get_hll_global $P2553, ["PAST"], "Op"
    $P2554 = $P2553."new"("    %r = root_new ['parrot';'Hash']" :named("inline"))
    set $P2548, $P2554
  if_2549_end:
.annotate 'line', 764
    .return ($P2548)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair_str"  :subid("411_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_2565
.annotate 'line', 783
    .lex "$ast", param_2565
.annotate 'line', 784
    get_hll_global $P2568, ["PAST"], "Op"
    find_lex $P2569, "$ast"
    $P2570 = $P2568."ACCEPTS"($P2569)
    if $P2570, if_2567
.annotate 'line', 786
    find_lex $P2574, "$ast"
    $P2575 = $P2574."value"()
    set $P2566, $P2575
.annotate 'line', 784
    goto if_2567_end
  if_2567:
.annotate 'line', 785
    find_lex $P2571, "$ast"
    $P2572 = $P2571."list"()
    join $S2573, " ", $P2572
    new $P2566, 'String'
    set $P2566, $S2573
  if_2567_end:
.annotate 'line', 783
    .return ($P2566)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "push_block_handler"  :subid("412_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_2578
    .param pmc param_2579
.annotate 'line', 1005
    .lex "$/", param_2578
    .lex "$block", param_2579
.annotate 'line', 1006
    get_global $P2581, "@BLOCK"
    unless_null $P2581, vivify_1379
    $P2581 = root_new ['parrot';'ResizablePMCArray']
  vivify_1379:
    set $P2582, $P2581[0]
    unless_null $P2582, vivify_1380
    new $P2582, "Undef"
  vivify_1380:
    $P2583 = $P2582."handlers"()
    if $P2583, unless_2580_end
.annotate 'line', 1007
    get_global $P2584, "@BLOCK"
    unless_null $P2584, vivify_1381
    $P2584 = root_new ['parrot';'ResizablePMCArray']
  vivify_1381:
    set $P2585, $P2584[0]
    unless_null $P2585, vivify_1382
    new $P2585, "Undef"
  vivify_1382:
    new $P2586, "ResizablePMCArray"
    $P2585."handlers"($P2586)
  unless_2580_end:
.annotate 'line', 1009
    find_lex $P2588, "$block"
    $P2589 = $P2588."arity"()
    if $P2589, unless_2587_end
.annotate 'line', 1010
    find_lex $P2590, "$block"
.annotate 'line', 1011
    get_hll_global $P2591, ["PAST"], "Op"
.annotate 'line', 1012
    get_hll_global $P2592, ["PAST"], "Var"
    $P2593 = $P2592."new"("lexical" :named("scope"), "$!" :named("name"), 1 :named("isdecl"))
.annotate 'line', 1013
    get_hll_global $P2594, ["PAST"], "Var"
    $P2595 = $P2594."new"("lexical" :named("scope"), "$_" :named("name"))
    $P2596 = $P2591."new"($P2593, $P2595, "bind" :named("pasttype"))
.annotate 'line', 1011
    $P2590."unshift"($P2596)
.annotate 'line', 1016
    find_lex $P2597, "$block"
    get_hll_global $P2598, ["PAST"], "Var"
    $P2599 = $P2598."new"("$_" :named("name"), "parameter" :named("scope"))
    $P2597."unshift"($P2599)
.annotate 'line', 1017
    find_lex $P2600, "$block"
    $P2600."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 1018
    find_lex $P2601, "$block"
    $P2601."symbol"("$!", "lexical" :named("scope"))
.annotate 'line', 1019
    find_lex $P2602, "$block"
    $P2602."arity"(1)
  unless_2587_end:
.annotate 'line', 1021
    find_lex $P2603, "$block"
    $P2603."blocktype"("declaration")
.annotate 'line', 1022
    get_global $P2604, "@BLOCK"
    unless_null $P2604, vivify_1383
    $P2604 = root_new ['parrot';'ResizablePMCArray']
  vivify_1383:
    set $P2605, $P2604[0]
    unless_null $P2605, vivify_1384
    new $P2605, "Undef"
  vivify_1384:
    $P2606 = $P2605."handlers"()
.annotate 'line', 1023
    get_hll_global $P2607, ["PAST"], "Control"
    find_lex $P2608, "$/"
.annotate 'line', 1025
    get_hll_global $P2609, ["PAST"], "Stmts"
.annotate 'line', 1026
    get_hll_global $P2610, ["PAST"], "Op"
    find_lex $P2611, "$block"
.annotate 'line', 1028
    get_hll_global $P2612, ["PAST"], "Var"
    $P2613 = $P2612."new"("register" :named("scope"), "exception" :named("name"))
    $P2614 = $P2610."new"($P2611, $P2613, "call" :named("pasttype"))
.annotate 'line', 1030
    get_hll_global $P2615, ["PAST"], "Op"
.annotate 'line', 1031
    get_hll_global $P2616, ["PAST"], "Var"
.annotate 'line', 1032
    get_hll_global $P2617, ["PAST"], "Var"
    $P2618 = $P2617."new"("register" :named("scope"), "exception" :named("name"))
    $P2619 = $P2616."new"($P2618, "handled", "keyed" :named("scope"))
.annotate 'line', 1031
    $P2620 = $P2615."new"($P2619, 1, "bind" :named("pasttype"))
.annotate 'line', 1030
    $P2621 = $P2609."new"($P2614, $P2620)
.annotate 'line', 1025
    $P2622 = $P2607."new"($P2621, $P2608 :named("node"))
.annotate 'line', 1023
    $P2623 = $P2606."unshift"($P2622)
.annotate 'line', 1005
    .return ($P2623)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "only_star_block"  :subid("413_1300062003.824") :outer("405_1300062003.824")
.annotate 'line', 1548
    new $P2626, "Undef"
    .lex "$past", $P2626
    get_global $P2627, "@BLOCK"
    $P2628 = $P2627."shift"()
    store_lex "$past", $P2628
.annotate 'line', 1549
    find_lex $P2629, "$past"
    $P2629."closure"(1)
.annotate 'line', 1550
    find_lex $P2630, "$past"
    get_hll_global $P2631, ["PAST"], "Op"
    $P2632 = $P2631."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P2630."push"($P2632)
    find_lex $P2633, "$past"
.annotate 'line', 1547
    .return ($P2633)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "attach_multi_signature"  :subid("414_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_2636
.annotate 'line', 1556
    .const 'Sub' $P2650 = "415_1300062003.824" 
    capture_lex $P2650
    .lex "$routine", param_2636
.annotate 'line', 1560
    new $P2637, "Undef"
    .lex "$types", $P2637
.annotate 'line', 1561
    new $P2638, "Undef"
    .lex "$definednesses", $P2638
.annotate 'line', 1560
    get_hll_global $P2639, ["PAST"], "Op"
    $P2640 = $P2639."new"("list" :named("pasttype"))
    store_lex "$types", $P2640
.annotate 'line', 1561
    get_hll_global $P2641, ["PAST"], "Op"
    $P2642 = $P2641."new"("list" :named("pasttype"))
    store_lex "$definednesses", $P2642
.annotate 'line', 1562
    find_lex $P2644, "$routine"
    unless_null $P2644, vivify_1385
    $P2644 = root_new ['parrot';'ResizablePMCArray']
  vivify_1385:
    set $P2645, $P2644[0]
    unless_null $P2645, vivify_1386
    new $P2645, "Undef"
  vivify_1386:
    $P2646 = $P2645."list"()
    defined $I2647, $P2646
    unless $I2647, for_undef_1387
    iter $P2643, $P2646
    new $P2688, 'ExceptionHandler'
    set_label $P2688, loop2687_handler
    $P2688."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2688
  loop2687_test:
    unless $P2643, loop2687_done
    shift $P2648, $P2643
  loop2687_redo:
    .const 'Sub' $P2650 = "415_1300062003.824" 
    capture_lex $P2650
    $P2650($P2648)
  loop2687_next:
    goto loop2687_test
  loop2687_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2689, exception, 'type'
    eq $P2689, .CONTROL_LOOP_NEXT, loop2687_next
    eq $P2689, .CONTROL_LOOP_REDO, loop2687_redo
  loop2687_done:
    pop_eh 
  for_undef_1387:
.annotate 'line', 1569
    find_lex $P2690, "$routine"
    $P2691 = $P2690."loadinit"()
    get_hll_global $P2692, ["PAST"], "Op"
.annotate 'line', 1570
    get_hll_global $P2693, ["PAST"], "Var"
    $P2694 = $P2693."new"("block" :named("name"), "register" :named("scope"))
    find_lex $P2695, "$types"
    find_lex $P2696, "$definednesses"
    $P2697 = $P2692."new"($P2694, $P2695, $P2696, "set_sub_multisig vPPP" :named("pirop"))
.annotate 'line', 1569
    $P2698 = $P2691."push"($P2697)
.annotate 'line', 1556
    .return ($P2698)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2649"  :anon :subid("415_1300062003.824") :outer("414_1300062003.824")
    .param pmc param_2651
.annotate 'line', 1562
    .lex "$_", param_2651
.annotate 'line', 1563
    get_hll_global $P2656, ["PAST"], "Var"
    find_lex $P2657, "$_"
    $P2658 = $P2656."ACCEPTS"($P2657)
    if $P2658, if_2655
    set $P2654, $P2658
    goto if_2655_end
  if_2655:
    find_lex $P2659, "$_"
    $S2660 = $P2659."scope"()
    iseq $I2661, $S2660, "parameter"
    new $P2654, 'Integer'
    set $P2654, $I2661
  if_2655_end:
    if $P2654, if_2653
    set $P2652, $P2654
    goto if_2653_end
  if_2653:
.annotate 'line', 1564
    find_lex $P2662, "$types"
    find_lex $P2664, "$_"
    $P2665 = $P2664."multitype"()
    set $P2663, $P2665
    defined $I2667, $P2663
    if $I2667, default_2666
    get_hll_global $P2668, ["PAST"], "Op"
    $P2669 = $P2668."new"("null P" :named("pirop"))
    set $P2663, $P2669
  default_2666:
    $P2662."push"($P2663)
.annotate 'line', 1565
    find_lex $P2670, "$definednesses"
    find_lex $P2673, "$_"
    unless_null $P2673, vivify_1388
    $P2673 = root_new ['parrot';'Hash']
  vivify_1388:
    set $P2674, $P2673["definedness"]
    unless_null $P2674, vivify_1389
    new $P2674, "Undef"
  vivify_1389:
    set $S2675, $P2674
    iseq $I2676, $S2675, "D"
    if $I2676, if_2672
.annotate 'line', 1566
    find_lex $P2680, "$_"
    unless_null $P2680, vivify_1390
    $P2680 = root_new ['parrot';'Hash']
  vivify_1390:
    set $P2681, $P2680["definedness"]
    unless_null $P2681, vivify_1391
    new $P2681, "Undef"
  vivify_1391:
    set $S2682, $P2681
    iseq $I2683, $S2682, "U"
    if $I2683, if_2679
    new $P2685, "Integer"
    assign $P2685, 0
    set $P2678, $P2685
    goto if_2679_end
  if_2679:
    new $P2684, "Integer"
    assign $P2684, 2
    set $P2678, $P2684
  if_2679_end:
    set $P2671, $P2678
.annotate 'line', 1565
    goto if_2672_end
  if_2672:
    new $P2677, "Integer"
    assign $P2677, 1
    set $P2671, $P2677
  if_2672_end:
    $P2686 = $P2670."push"($P2671)
.annotate 'line', 1563
    set $P2652, $P2686
  if_2653_end:
.annotate 'line', 1562
    .return ($P2652)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "is_lexical"  :subid("416_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_2703
.annotate 'line', 1844
    .const 'Sub' $P2709 = "417_1300062003.824" 
    capture_lex $P2709
    new $P2702, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2702, control_2701
    push_eh $P2702
    .lex "$name", param_2703
.annotate 'line', 1845
    get_global $P2705, "@BLOCK"
    defined $I2706, $P2705
    unless $I2706, for_undef_1392
    iter $P2704, $P2705
    new $P2722, 'ExceptionHandler'
    set_label $P2722, loop2721_handler
    $P2722."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2722
  loop2721_test:
    unless $P2704, loop2721_done
    shift $P2707, $P2704
  loop2721_redo:
    .const 'Sub' $P2709 = "417_1300062003.824" 
    capture_lex $P2709
    $P2709($P2707)
  loop2721_next:
    goto loop2721_test
  loop2721_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2723, exception, 'type'
    eq $P2723, .CONTROL_LOOP_NEXT, loop2721_next
    eq $P2723, .CONTROL_LOOP_REDO, loop2721_redo
  loop2721_done:
    pop_eh 
  for_undef_1392:
.annotate 'line', 1844
    .return (0)
  control_2701:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2724, exception, "payload"
    .return ($P2724)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2708"  :anon :subid("417_1300062003.824") :outer("416_1300062003.824")
    .param pmc param_2711
.annotate 'line', 1846
    $P2710 = root_new ['parrot';'Hash']
    .lex "%sym", $P2710
    .lex "$_", param_2711
    find_lex $P2712, "$_"
    find_lex $P2713, "$name"
    $P2714 = $P2712."symbol"($P2713)
    store_lex "%sym", $P2714
.annotate 'line', 1847
    find_lex $P2717, "%sym"
    set $N2718, $P2717
    if $N2718, if_2716
    new $P2715, 'Float'
    set $P2715, $N2718
    goto if_2716_end
  if_2716:
.annotate 'line', 1848
    new $P2719, "Exception"
    set $P2719['type'], .CONTROL_RETURN
    new $P2720, "Integer"
    assign $P2720, 1
    setattribute $P2719, 'payload', $P2720
    throw $P2719
  if_2716_end:
.annotate 'line', 1845
    .return ($P2715)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "control"  :subid("418_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_2727
    .param pmc param_2728
.annotate 'line', 2052
    .lex "$/", param_2727
    .lex "$type", param_2728
.annotate 'line', 2053
    find_lex $P2729, "$/"
    get_hll_global $P2730, ["PAST"], "Op"
    find_lex $P2731, "$/"
.annotate 'line', 2057
    get_hll_global $P2732, ["PAST"], "Val"
    find_lex $P2733, "$type"
    $P2734 = $P2732."new"($P2733 :named("value"), "!except_types" :named("returns"))
    $P2735 = $P2730."new"(0, $P2734, $P2731 :named("node"), "die__vii" :named("pirop"))
.annotate 'line', 2053
    $P2736 = $P2729."!make"($P2735)
.annotate 'line', 2052
    .return ($P2736)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2739"  :anon :subid("419_1300062003.824") :outer("405_1300062003.824")
.annotate 'line', 741
    .const 'Sub' $P2742 = "420_1300062003.824" 
    capture_lex $P2742
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "" :load :init :subid("post1393") :outer("419_1300062003.824")
.annotate 'line', 741
    .const 'Sub' $P2740 = "419_1300062003.824" 
    .local pmc block
    set block, $P2740
.annotate 'line', 745
    .const 'Sub' $P2742 = "420_1300062003.824" 
    capture_lex $P2742
    $P2742()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2741"  :anon :subid("420_1300062003.824") :outer("419_1300062003.824")
.annotate 'line', 746
    get_global $P2743, "@BLOCK"
    unless_null $P2743, vivify_1394
    $P2743 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P2743
  vivify_1394:
 $P2744 = new ['ResizablePMCArray'] 
    set_global "@BLOCK", $P2744
.annotate 'line', 745
    .return ($P2744)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "TOP"  :subid("421_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_2749
    .param pmc param_2750
.annotate 'line', 773
    .lex "self", param_2749
    .lex "$/", param_2750
    find_lex $P2751, "$/"
    find_lex $P2752, "$/"
    unless_null $P2752, vivify_1395
    $P2752 = root_new ['parrot';'Hash']
  vivify_1395:
    set $P2753, $P2752["comp_unit"]
    unless_null $P2753, vivify_1396
    new $P2753, "Undef"
  vivify_1396:
    $P2754 = $P2753."ast"()
    $P2755 = $P2751."!make"($P2754)
    .return ($P2755)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "deflongname"  :subid("422_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_2757
    .param pmc param_2758
.annotate 'line', 775
    .lex "self", param_2757
    .lex "$/", param_2758
.annotate 'line', 776
    find_lex $P2759, "$/"
.annotate 'line', 777
    find_lex $P2762, "$/"
    unless_null $P2762, vivify_1397
    $P2762 = root_new ['parrot';'Hash']
  vivify_1397:
    set $P2763, $P2762["colonpair"]
    unless_null $P2763, vivify_1398
    new $P2763, "Undef"
  vivify_1398:
    if $P2763, if_2761
.annotate 'line', 779
    find_lex $P2783, "$/"
    set $S2784, $P2783
    new $P2760, 'String'
    set $P2760, $S2784
.annotate 'line', 777
    goto if_2761_end
  if_2761:
    find_lex $P2764, "$/"
    unless_null $P2764, vivify_1399
    $P2764 = root_new ['parrot';'Hash']
  vivify_1399:
    set $P2765, $P2764["identifier"]
    unless_null $P2765, vivify_1400
    new $P2765, "Undef"
  vivify_1400:
    set $S2766, $P2765
    new $P2767, 'String'
    set $P2767, $S2766
    concat $P2768, $P2767, ":"
    find_lex $P2769, "$/"
    unless_null $P2769, vivify_1401
    $P2769 = root_new ['parrot';'Hash']
  vivify_1401:
    set $P2770, $P2769["colonpair"]
    unless_null $P2770, vivify_1402
    $P2770 = root_new ['parrot';'ResizablePMCArray']
  vivify_1402:
    set $P2771, $P2770[0]
    unless_null $P2771, vivify_1403
    new $P2771, "Undef"
  vivify_1403:
    $P2772 = $P2771."ast"()
    $S2773 = $P2772."named"()
    concat $P2774, $P2768, $S2773
    concat $P2775, $P2774, "<"
.annotate 'line', 778
    find_lex $P2776, "$/"
    unless_null $P2776, vivify_1404
    $P2776 = root_new ['parrot';'Hash']
  vivify_1404:
    set $P2777, $P2776["colonpair"]
    unless_null $P2777, vivify_1405
    $P2777 = root_new ['parrot';'ResizablePMCArray']
  vivify_1405:
    set $P2778, $P2777[0]
    unless_null $P2778, vivify_1406
    new $P2778, "Undef"
  vivify_1406:
    $P2779 = $P2778."ast"()
    $S2780 = "colonpair_str"($P2779)
    concat $P2781, $P2775, $S2780
    concat $P2782, $P2781, ">"
    set $P2760, $P2782
  if_2761_end:
.annotate 'line', 777
    $P2785 = $P2759."!make"($P2760)
.annotate 'line', 775
    .return ($P2785)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "comp_unit"  :subid("423_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_2788
    .param pmc param_2789
.annotate 'line', 789
    .lex "self", param_2788
    .lex "$/", param_2789
.annotate 'line', 790
    new $P2790, "Undef"
    .lex "$mainline", $P2790
.annotate 'line', 791
    new $P2791, "Undef"
    .lex "$unit", $P2791
.annotate 'line', 790
    find_lex $P2792, "$/"
    unless_null $P2792, vivify_1407
    $P2792 = root_new ['parrot';'Hash']
  vivify_1407:
    set $P2793, $P2792["statementlist"]
    unless_null $P2793, vivify_1408
    new $P2793, "Undef"
  vivify_1408:
    $P2794 = $P2793."ast"()
    store_lex "$mainline", $P2794
.annotate 'line', 791
    get_global $P2795, "@BLOCK"
    $P2796 = $P2795."shift"()
    store_lex "$unit", $P2796
.annotate 'line', 795
    find_lex $P2797, "$unit"
    $P2798 = $P2797."loadinit"()
    find_dynamic_lex $P2799, "$*SC"
    unless_null $P2799, vivify_1409
    get_hll_global $P2799, "$SC"
    unless_null $P2799, vivify_1410
    die "Contextual $*SC not found"
  vivify_1410:
  vivify_1409:
    $P2800 = $P2799."to_past"()
    $P2798."push"($P2800)
.annotate 'line', 800
    find_dynamic_lex $P2802, "$*HAS_YOU_ARE_HERE"
    unless_null $P2802, vivify_1411
    get_hll_global $P2802, "$HAS_YOU_ARE_HERE"
    unless_null $P2802, vivify_1412
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_1412:
  vivify_1411:
    if $P2802, unless_2801_end
.annotate 'line', 801
    find_lex $P2803, "$unit"
    find_lex $P2804, "self"
    $P2805 = $P2804."CTXSAVE"()
    $P2803."push"($P2805)
  unless_2801_end:
.annotate 'line', 805
    find_lex $P2806, "$unit"
    $P2806."loadlibs"("nqp_group", "nqp_ops")
.annotate 'line', 808
    find_dynamic_lex $P2808, "$*MAIN_SUB"
    unless_null $P2808, vivify_1413
    get_hll_global $P2808, "$MAIN_SUB"
    unless_null $P2808, vivify_1414
    die "Contextual $*MAIN_SUB not found"
  vivify_1414:
  vivify_1413:
    unless $P2808, if_2807_end
.annotate 'line', 809
    find_lex $P2809, "$unit"
    get_hll_global $P2810, ["PAST"], "Var"
    $P2811 = $P2810."new"("parameter" :named("scope"), "@ARGS" :named("name"), 1 :named("slurpy"))
    $P2809."unshift"($P2811)
.annotate 'line', 810
    find_lex $P2812, "$mainline"
    get_hll_global $P2813, ["PAST"], "Op"
.annotate 'line', 811
    get_hll_global $P2814, ["PAST"], "Val"
    find_dynamic_lex $P2815, "$*MAIN_SUB"
    unless_null $P2815, vivify_1415
    get_hll_global $P2815, "$MAIN_SUB"
    unless_null $P2815, vivify_1416
    die "Contextual $*MAIN_SUB not found"
  vivify_1416:
  vivify_1415:
    $P2816 = $P2814."new"($P2815 :named("value"))
.annotate 'line', 812
    get_hll_global $P2817, ["PAST"], "Var"
    $P2818 = $P2817."new"("lexical" :named("scope"), "@ARGS" :named("name"), 1 :named("flat"))
    $P2819 = $P2813."new"($P2816, $P2818, "call" :named("pasttype"))
.annotate 'line', 810
    $P2812."push"($P2819)
  if_2807_end:
.annotate 'line', 819
    find_lex $P2820, "$unit"
.annotate 'line', 820
    get_hll_global $P2821, ["PAST"], "Op"
    find_lex $P2822, "$mainline"
    $P2823 = $P2821."new"($P2822, "return" :named("pirop"))
    $P2820."push"($P2823)
.annotate 'line', 825
    find_lex $P2824, "$unit"
.annotate 'line', 826
    get_hll_global $P2825, ["PAST"], "Block"
.annotate 'line', 828
    get_hll_global $P2826, ["PAST"], "Op"
    get_hll_global $P2827, ["PAST"], "Val"
    find_lex $P2828, "$unit"
    $P2829 = $P2827."new"($P2828 :named("value"))
    $P2830 = $P2826."new"($P2829, "call" :named("pasttype"))
    $P2831 = $P2825."new"($P2830, ":load" :named("pirflags"), 0 :named("lexical"), "" :named("namespace"))
.annotate 'line', 826
    $P2824."push"($P2831)
.annotate 'line', 831
    find_lex $P2832, "$unit"
    find_lex $P2833, "$/"
    $P2832."node"($P2833)
.annotate 'line', 834
    find_lex $P2834, "$unit"
    $P2834."hll"("nqp")
.annotate 'line', 836
    find_lex $P2835, "$/"
    find_lex $P2836, "$unit"
    $P2837 = $P2835."!make"($P2836)
.annotate 'line', 789
    .return ($P2837)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statementlist"  :subid("424_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_2839
    .param pmc param_2840
.annotate 'line', 839
    .const 'Sub' $P2854 = "425_1300062003.824" 
    capture_lex $P2854
    .lex "self", param_2839
    .lex "$/", param_2840
.annotate 'line', 840
    new $P2841, "Undef"
    .lex "$past", $P2841
    get_hll_global $P2842, ["PAST"], "Stmts"
    find_lex $P2843, "$/"
    $P2844 = $P2842."new"($P2843 :named("node"))
    store_lex "$past", $P2844
.annotate 'line', 841
    find_lex $P2846, "$/"
    unless_null $P2846, vivify_1417
    $P2846 = root_new ['parrot';'Hash']
  vivify_1417:
    set $P2847, $P2846["statement"]
    unless_null $P2847, vivify_1418
    new $P2847, "Undef"
  vivify_1418:
    unless $P2847, if_2845_end
.annotate 'line', 842
    find_lex $P2849, "$/"
    unless_null $P2849, vivify_1419
    $P2849 = root_new ['parrot';'Hash']
  vivify_1419:
    set $P2850, $P2849["statement"]
    unless_null $P2850, vivify_1420
    new $P2850, "Undef"
  vivify_1420:
    defined $I2851, $P2850
    unless $I2851, for_undef_1421
    iter $P2848, $P2850
    new $P2874, 'ExceptionHandler'
    set_label $P2874, loop2873_handler
    $P2874."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2874
  loop2873_test:
    unless $P2848, loop2873_done
    shift $P2852, $P2848
  loop2873_redo:
    .const 'Sub' $P2854 = "425_1300062003.824" 
    capture_lex $P2854
    $P2854($P2852)
  loop2873_next:
    goto loop2873_test
  loop2873_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2875, exception, 'type'
    eq $P2875, .CONTROL_LOOP_NEXT, loop2873_next
    eq $P2875, .CONTROL_LOOP_REDO, loop2873_redo
  loop2873_done:
    pop_eh 
  for_undef_1421:
  if_2845_end:
.annotate 'line', 849
    find_lex $P2876, "$/"
    find_lex $P2877, "$past"
    $P2878 = $P2876."!make"($P2877)
.annotate 'line', 839
    .return ($P2878)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2853"  :anon :subid("425_1300062003.824") :outer("424_1300062003.824")
    .param pmc param_2856
.annotate 'line', 843
    new $P2855, "Undef"
    .lex "$ast", $P2855
    .lex "$_", param_2856
    find_lex $P2857, "$_"
    $P2858 = $P2857."ast"()
    store_lex "$ast", $P2858
.annotate 'line', 844
    find_lex $P2860, "$ast"
    unless_null $P2860, vivify_1422
    $P2860 = root_new ['parrot';'Hash']
  vivify_1422:
    set $P2861, $P2860["sink"]
    unless_null $P2861, vivify_1423
    new $P2861, "Undef"
  vivify_1423:
    defined $I2862, $P2861
    unless $I2862, if_2859_end
    find_lex $P2863, "$ast"
    unless_null $P2863, vivify_1424
    $P2863 = root_new ['parrot';'Hash']
  vivify_1424:
    set $P2864, $P2863["sink"]
    unless_null $P2864, vivify_1425
    new $P2864, "Undef"
  vivify_1425:
    store_lex "$ast", $P2864
  if_2859_end:
.annotate 'line', 845
    find_lex $P2866, "$ast"
    unless_null $P2866, vivify_1426
    $P2866 = root_new ['parrot';'Hash']
  vivify_1426:
    set $P2867, $P2866["bareblock"]
    unless_null $P2867, vivify_1427
    new $P2867, "Undef"
  vivify_1427:
    unless $P2867, if_2865_end
    find_lex $P2868, "$ast"
    $P2869 = "block_immediate"($P2868)
    store_lex "$ast", $P2869
  if_2865_end:
.annotate 'line', 846
    find_lex $P2870, "$past"
    find_lex $P2871, "$ast"
    $P2872 = $P2870."push"($P2871)
.annotate 'line', 842
    .return ($P2872)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement"  :subid("426_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_2880
    .param pmc param_2881
    .param pmc param_2882 :optional
    .param int has_param_2882 :opt_flag
.annotate 'line', 852
    .const 'Sub' $P2890 = "427_1300062003.824" 
    capture_lex $P2890
    .lex "self", param_2880
    .lex "$/", param_2881
    if has_param_2882, optparam_1428
    new $P2883, "Undef"
    set param_2882, $P2883
  optparam_1428:
    .lex "$key", param_2882
.annotate 'line', 853
    new $P2884, "Undef"
    .lex "$past", $P2884
.annotate 'line', 852
    find_lex $P2885, "$past"
.annotate 'line', 854
    find_lex $P2887, "$/"
    unless_null $P2887, vivify_1429
    $P2887 = root_new ['parrot';'Hash']
  vivify_1429:
    set $P2888, $P2887["EXPR"]
    unless_null $P2888, vivify_1430
    new $P2888, "Undef"
  vivify_1430:
    if $P2888, if_2886
.annotate 'line', 875
    find_lex $P2951, "$/"
    unless_null $P2951, vivify_1431
    $P2951 = root_new ['parrot';'Hash']
  vivify_1431:
    set $P2952, $P2951["statement_control"]
    unless_null $P2952, vivify_1432
    new $P2952, "Undef"
  vivify_1432:
    if $P2952, if_2950
.annotate 'line', 876
    new $P2956, "Integer"
    assign $P2956, 0
    store_lex "$past", $P2956
    goto if_2950_end
  if_2950:
.annotate 'line', 875
    find_lex $P2953, "$/"
    unless_null $P2953, vivify_1433
    $P2953 = root_new ['parrot';'Hash']
  vivify_1433:
    set $P2954, $P2953["statement_control"]
    unless_null $P2954, vivify_1434
    new $P2954, "Undef"
  vivify_1434:
    $P2955 = $P2954."ast"()
    store_lex "$past", $P2955
  if_2950_end:
    goto if_2886_end
  if_2886:
.annotate 'line', 854
    .const 'Sub' $P2890 = "427_1300062003.824" 
    capture_lex $P2890
    $P2890()
  if_2886_end:
.annotate 'line', 877
    find_lex $P2957, "$/"
    find_lex $P2958, "$past"
    $P2959 = $P2957."!make"($P2958)
.annotate 'line', 852
    .return ($P2959)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2889"  :anon :subid("427_1300062003.824") :outer("426_1300062003.824")
.annotate 'line', 855
    new $P2891, "Undef"
    .lex "$mc", $P2891
.annotate 'line', 856
    new $P2892, "Undef"
    .lex "$ml", $P2892
.annotate 'line', 855
    find_lex $P2893, "$/"
    unless_null $P2893, vivify_1435
    $P2893 = root_new ['parrot';'Hash']
  vivify_1435:
    set $P2894, $P2893["statement_mod_cond"]
    unless_null $P2894, vivify_1436
    $P2894 = root_new ['parrot';'ResizablePMCArray']
  vivify_1436:
    set $P2895, $P2894[0]
    unless_null $P2895, vivify_1437
    new $P2895, "Undef"
  vivify_1437:
    store_lex "$mc", $P2895
.annotate 'line', 856
    find_lex $P2896, "$/"
    unless_null $P2896, vivify_1438
    $P2896 = root_new ['parrot';'Hash']
  vivify_1438:
    set $P2897, $P2896["statement_mod_loop"]
    unless_null $P2897, vivify_1439
    $P2897 = root_new ['parrot';'ResizablePMCArray']
  vivify_1439:
    set $P2898, $P2897[0]
    unless_null $P2898, vivify_1440
    new $P2898, "Undef"
  vivify_1440:
    store_lex "$ml", $P2898
.annotate 'line', 857
    find_lex $P2899, "$/"
    unless_null $P2899, vivify_1441
    $P2899 = root_new ['parrot';'Hash']
  vivify_1441:
    set $P2900, $P2899["EXPR"]
    unless_null $P2900, vivify_1442
    new $P2900, "Undef"
  vivify_1442:
    $P2901 = $P2900."ast"()
    store_lex "$past", $P2901
.annotate 'line', 858
    find_lex $P2903, "$mc"
    unless $P2903, if_2902_end
.annotate 'line', 859
    get_hll_global $P2904, ["PAST"], "Op"
    find_lex $P2905, "$mc"
    unless_null $P2905, vivify_1443
    $P2905 = root_new ['parrot';'Hash']
  vivify_1443:
    set $P2906, $P2905["cond"]
    unless_null $P2906, vivify_1444
    new $P2906, "Undef"
  vivify_1444:
    $P2907 = $P2906."ast"()
    find_lex $P2908, "$past"
    find_lex $P2909, "$mc"
    unless_null $P2909, vivify_1445
    $P2909 = root_new ['parrot';'Hash']
  vivify_1445:
    set $P2910, $P2909["sym"]
    unless_null $P2910, vivify_1446
    new $P2910, "Undef"
  vivify_1446:
    set $S2911, $P2910
    find_lex $P2912, "$/"
    $P2913 = $P2904."new"($P2907, $P2908, $S2911 :named("pasttype"), $P2912 :named("node"))
    store_lex "$past", $P2913
  if_2902_end:
.annotate 'line', 861
    find_lex $P2916, "$ml"
    if $P2916, if_2915
    set $P2914, $P2916
    goto if_2915_end
  if_2915:
.annotate 'line', 862
    find_lex $P2919, "$ml"
    unless_null $P2919, vivify_1447
    $P2919 = root_new ['parrot';'Hash']
  vivify_1447:
    set $P2920, $P2919["sym"]
    unless_null $P2920, vivify_1448
    new $P2920, "Undef"
  vivify_1448:
    set $S2921, $P2920
    iseq $I2922, $S2921, "for"
    if $I2922, if_2918
.annotate 'line', 871
    get_hll_global $P2940, ["PAST"], "Op"
    find_lex $P2941, "$ml"
    unless_null $P2941, vivify_1449
    $P2941 = root_new ['parrot';'Hash']
  vivify_1449:
    set $P2942, $P2941["cond"]
    unless_null $P2942, vivify_1450
    new $P2942, "Undef"
  vivify_1450:
    $P2943 = $P2942."ast"()
    find_lex $P2944, "$past"
    find_lex $P2945, "$ml"
    unless_null $P2945, vivify_1451
    $P2945 = root_new ['parrot';'Hash']
  vivify_1451:
    set $P2946, $P2945["sym"]
    unless_null $P2946, vivify_1452
    new $P2946, "Undef"
  vivify_1452:
    set $S2947, $P2946
    find_lex $P2948, "$/"
    $P2949 = $P2940."new"($P2943, $P2944, $S2947 :named("pasttype"), $P2948 :named("node"))
    store_lex "$past", $P2949
.annotate 'line', 870
    set $P2917, $P2949
.annotate 'line', 862
    goto if_2918_end
  if_2918:
.annotate 'line', 863
    get_hll_global $P2923, ["PAST"], "Block"
.annotate 'line', 864
    get_hll_global $P2924, ["PAST"], "Var"
    $P2925 = $P2924."new"("$_" :named("name"), "parameter" :named("scope"), 1 :named("isdecl"))
    find_lex $P2926, "$past"
    $P2927 = $P2923."new"($P2925, $P2926, "immediate" :named("blocktype"))
.annotate 'line', 863
    store_lex "$past", $P2927
.annotate 'line', 866
    find_lex $P2928, "$past"
    $P2928."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 867
    find_lex $P2929, "$past"
    $P2929."arity"(1)
.annotate 'line', 868
    get_hll_global $P2930, ["PAST"], "Op"
    find_lex $P2931, "$ml"
    unless_null $P2931, vivify_1453
    $P2931 = root_new ['parrot';'Hash']
  vivify_1453:
    set $P2932, $P2931["cond"]
    unless_null $P2932, vivify_1454
    new $P2932, "Undef"
  vivify_1454:
    $P2933 = $P2932."ast"()
    find_lex $P2934, "$past"
    find_lex $P2935, "$ml"
    unless_null $P2935, vivify_1455
    $P2935 = root_new ['parrot';'Hash']
  vivify_1455:
    set $P2936, $P2935["sym"]
    unless_null $P2936, vivify_1456
    new $P2936, "Undef"
  vivify_1456:
    set $S2937, $P2936
    find_lex $P2938, "$/"
    $P2939 = $P2930."new"($P2933, $P2934, $S2937 :named("pasttype"), $P2938 :named("node"))
    store_lex "$past", $P2939
.annotate 'line', 862
    set $P2917, $P2939
  if_2918_end:
.annotate 'line', 861
    set $P2914, $P2917
  if_2915_end:
.annotate 'line', 854
    .return ($P2914)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock"  :subid("428_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_2961
    .param pmc param_2962
.annotate 'line', 880
    .lex "self", param_2961
    .lex "$/", param_2962
.annotate 'line', 881
    find_lex $P2963, "$/"
    get_hll_global $P2964, ["PAST"], "Op"
    find_lex $P2965, "$/"
    unless_null $P2965, vivify_1457
    $P2965 = root_new ['parrot';'Hash']
  vivify_1457:
    set $P2966, $P2965["EXPR"]
    unless_null $P2966, vivify_1458
    new $P2966, "Undef"
  vivify_1458:
    $P2967 = $P2966."ast"()
    find_lex $P2968, "$/"
    unless_null $P2968, vivify_1459
    $P2968 = root_new ['parrot';'Hash']
  vivify_1459:
    set $P2969, $P2968["pblock"]
    unless_null $P2969, vivify_1460
    new $P2969, "Undef"
  vivify_1460:
    $P2970 = $P2969."ast"()
    find_lex $P2971, "$/"
    $P2972 = $P2964."new"($P2967, $P2970, "if" :named("pasttype"), $P2971 :named("node"))
    $P2973 = $P2963."!make"($P2972)
.annotate 'line', 880
    .return ($P2973)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "pblock"  :subid("429_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_2975
    .param pmc param_2976
.annotate 'line', 884
    .lex "self", param_2975
    .lex "$/", param_2976
.annotate 'line', 885
    find_lex $P2977, "$/"
    find_lex $P2978, "$/"
    unless_null $P2978, vivify_1461
    $P2978 = root_new ['parrot';'Hash']
  vivify_1461:
    set $P2979, $P2978["blockoid"]
    unless_null $P2979, vivify_1462
    new $P2979, "Undef"
  vivify_1462:
    $P2980 = $P2979."ast"()
    $P2981 = $P2977."!make"($P2980)
.annotate 'line', 884
    .return ($P2981)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block"  :subid("430_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_2983
    .param pmc param_2984
.annotate 'line', 888
    .lex "self", param_2983
    .lex "$/", param_2984
.annotate 'line', 889
    find_lex $P2985, "$/"
    find_lex $P2986, "$/"
    unless_null $P2986, vivify_1463
    $P2986 = root_new ['parrot';'Hash']
  vivify_1463:
    set $P2987, $P2986["blockoid"]
    unless_null $P2987, vivify_1464
    new $P2987, "Undef"
  vivify_1464:
    $P2988 = $P2987."ast"()
    $P2989 = $P2985."!make"($P2988)
.annotate 'line', 888
    .return ($P2989)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blockoid"  :subid("431_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_2991
    .param pmc param_2992
.annotate 'line', 892
    .const 'Sub' $P3001 = "432_1300062003.824" 
    capture_lex $P3001
    .lex "self", param_2991
    .lex "$/", param_2992
.annotate 'line', 893
    new $P2993, "Undef"
    .lex "$BLOCK", $P2993
    get_global $P2994, "@BLOCK"
    $P2995 = $P2994."shift"()
    store_lex "$BLOCK", $P2995
.annotate 'line', 894
    find_lex $P2998, "$/"
    unless_null $P2998, vivify_1465
    $P2998 = root_new ['parrot';'Hash']
  vivify_1465:
    set $P2999, $P2998["statementlist"]
    unless_null $P2999, vivify_1466
    new $P2999, "Undef"
  vivify_1466:
    if $P2999, if_2997
.annotate 'line', 902
    find_dynamic_lex $P3016, "$*HAS_YOU_ARE_HERE"
    unless_null $P3016, vivify_1467
    get_hll_global $P3016, "$HAS_YOU_ARE_HERE"
    unless_null $P3016, vivify_1468
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_1468:
  vivify_1467:
    unless $P3016, if_3015_end
.annotate 'line', 903
    find_lex $P3017, "$/"
    $P3018 = $P3017."CURSOR"()
    $P3018."panic"("{YOU_ARE_HERE} may only appear once in a setting")
  if_3015_end:
.annotate 'line', 905
    new $P3019, "Integer"
    assign $P3019, 1
    store_dynamic_lex "$*HAS_YOU_ARE_HERE", $P3019
.annotate 'line', 906
    find_lex $P3020, "$/"
    find_lex $P3021, "$/"
    unless_null $P3021, vivify_1469
    $P3021 = root_new ['parrot';'Hash']
  vivify_1469:
    set $P3022, $P3021["you_are_here"]
    unless_null $P3022, vivify_1470
    new $P3022, "Undef"
  vivify_1470:
    $P3023 = $P3022."ast"()
    $P3024 = $P3020."!make"($P3023)
.annotate 'line', 901
    set $P2996, $P3024
.annotate 'line', 894
    goto if_2997_end
  if_2997:
    .const 'Sub' $P3001 = "432_1300062003.824" 
    capture_lex $P3001
    $P3014 = $P3001()
    set $P2996, $P3014
  if_2997_end:
.annotate 'line', 892
    .return ($P2996)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3000"  :anon :subid("432_1300062003.824") :outer("431_1300062003.824")
.annotate 'line', 895
    new $P3002, "Undef"
    .lex "$past", $P3002
    find_lex $P3003, "$/"
    unless_null $P3003, vivify_1471
    $P3003 = root_new ['parrot';'Hash']
  vivify_1471:
    set $P3004, $P3003["statementlist"]
    unless_null $P3004, vivify_1472
    new $P3004, "Undef"
  vivify_1472:
    $P3005 = $P3004."ast"()
    store_lex "$past", $P3005
.annotate 'line', 896
    find_lex $P3006, "$BLOCK"
    find_lex $P3007, "$past"
    $P3006."push"($P3007)
.annotate 'line', 897
    find_lex $P3008, "$BLOCK"
    find_lex $P3009, "$/"
    $P3008."node"($P3009)
.annotate 'line', 898
    find_lex $P3010, "$BLOCK"
    $P3010."closure"(1)
.annotate 'line', 899
    find_dynamic_lex $P3011, "$/"
    find_lex $P3012, "$BLOCK"
    $P3013 = $P3011."!make"($P3012)
.annotate 'line', 894
    .return ($P3013)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "newpad"  :subid("433_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_3026
    .param pmc param_3027
.annotate 'line', 910
    .lex "self", param_3026
    .lex "$/", param_3027
.annotate 'line', 911
    get_global $P3028, "@BLOCK"
    unless_null $P3028, vivify_1473
    $P3028 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P3028
  vivify_1473:
.annotate 'line', 910
    get_global $P3029, "@BLOCK"
.annotate 'line', 912
    get_global $P3030, "@BLOCK"
    get_hll_global $P3031, ["PAST"], "Block"
    get_hll_global $P3032, ["PAST"], "Stmts"
    $P3033 = $P3032."new"()
    $P3034 = $P3031."new"($P3033)
    $P3035 = $P3030."unshift"($P3034)
.annotate 'line', 910
    .return ($P3035)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "outerctx"  :subid("434_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_3037
    .param pmc param_3038
.annotate 'line', 915
    .lex "self", param_3037
    .lex "$/", param_3038
.annotate 'line', 916
    get_global $P3039, "@BLOCK"
    unless_null $P3039, vivify_1474
    $P3039 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P3039
  vivify_1474:
.annotate 'line', 915
    get_global $P3040, "@BLOCK"
.annotate 'line', 917
    find_dynamic_lex $P3042, "%*COMPILING"
    unless_null $P3042, vivify_1475
    get_hll_global $P3042, "%COMPILING"
    unless_null $P3042, vivify_1476
    die "Contextual %*COMPILING not found"
  vivify_1476:
  vivify_1475:
    set $P3043, $P3042["%?OPTIONS"]
    unless_null $P3043, vivify_1477
    $P3043 = root_new ['parrot';'Hash']
  vivify_1477:
    set $P3044, $P3043["outer_ctx"]
    unless_null $P3044, vivify_1478
    new $P3044, "Undef"
  vivify_1478:
    defined $I3045, $P3044
    if $I3045, unless_3041_end
.annotate 'line', 920
    find_dynamic_lex $P3046, "$*SC"
    unless_null $P3046, vivify_1479
    get_hll_global $P3046, "$SC"
    unless_null $P3046, vivify_1480
    die "Contextual $*SC not found"
  vivify_1480:
  vivify_1479:
    find_dynamic_lex $P3048, "%*COMPILING"
    unless_null $P3048, vivify_1481
    get_hll_global $P3048, "%COMPILING"
    unless_null $P3048, vivify_1482
    die "Contextual %*COMPILING not found"
  vivify_1482:
  vivify_1481:
    set $P3049, $P3048["%?OPTIONS"]
    unless_null $P3049, vivify_1483
    $P3049 = root_new ['parrot';'Hash']
  vivify_1483:
    set $P3050, $P3049["setting"]
    unless_null $P3050, vivify_1484
    new $P3050, "Undef"
  vivify_1484:
    set $P3047, $P3050
    defined $I3052, $P3047
    if $I3052, default_3051
    new $P3053, "String"
    assign $P3053, "NQPCORE"
    set $P3047, $P3053
  default_3051:
    $P3046."load_setting"($P3047)
  unless_3041_end:
.annotate 'line', 922
    find_lex $P3054, "self"
    get_global $P3055, "@BLOCK"
    unless_null $P3055, vivify_1485
    $P3055 = root_new ['parrot';'ResizablePMCArray']
  vivify_1485:
    set $P3056, $P3055[0]
    unless_null $P3056, vivify_1486
    new $P3056, "Undef"
  vivify_1486:
    $P3057 = $P3054."SET_BLOCK_OUTER_CTX"($P3056)
.annotate 'line', 915
    .return ($P3057)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "you_are_here"  :subid("435_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_3059
    .param pmc param_3060
.annotate 'line', 925
    .lex "self", param_3059
    .lex "$/", param_3060
.annotate 'line', 926
    find_lex $P3061, "$/"
    find_lex $P3062, "self"
    $P3063 = $P3062."CTXSAVE"()
    $P3064 = $P3061."!make"($P3063)
.annotate 'line', 925
    .return ($P3064)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<use>"  :subid("436_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_3066
    .param pmc param_3067
.annotate 'line', 931
    .lex "self", param_3066
    .lex "$/", param_3067
.annotate 'line', 932
    find_dynamic_lex $P3068, "$*SC"
    unless_null $P3068, vivify_1487
    get_hll_global $P3068, "$SC"
    unless_null $P3068, vivify_1488
    die "Contextual $*SC not found"
  vivify_1488:
  vivify_1487:
    find_lex $P3069, "$/"
    unless_null $P3069, vivify_1489
    $P3069 = root_new ['parrot';'Hash']
  vivify_1489:
    set $P3070, $P3069["name"]
    unless_null $P3070, vivify_1490
    new $P3070, "Undef"
  vivify_1490:
    set $S3071, $P3070
    $P3068."load_module"($S3071)
.annotate 'line', 933
    find_lex $P3072, "$/"
    get_hll_global $P3073, ["PAST"], "Stmts"
    $P3074 = $P3073."new"()
    $P3075 = $P3072."!make"($P3074)
.annotate 'line', 931
    .return ($P3075)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statement_control:sym<if>"  :subid("437_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_3077
    .param pmc param_3078
.annotate 'line', 936
    .const 'Sub' $P3106 = "438_1300062003.824" 
    capture_lex $P3106
    .lex "self", param_3077
    .lex "$/", param_3078
.annotate 'line', 937
    new $P3079, "Undef"
    .lex "$count", $P3079
.annotate 'line', 938
    new $P3080, "Undef"
    .lex "$past", $P3080
.annotate 'line', 937
    find_lex $P3081, "$/"
    unless_null $P3081, vivify_1491
    $P3081 = root_new ['parrot';'Hash']
  vivify_1491:
    set $P3082, $P3081["xblock"]
    unless_null $P3082, vivify_1492
    new $P3082, "Undef"
  vivify_1492:
    set $N3083, $P3082
    new $P3084, 'Float'
    set $P3084, $N3083
    sub $P3085, $P3084, 1
    store_lex "$count", $P3085
.annotate 'line', 938
    find_lex $P3086, "$count"
    set $I3087, $P3086
    find_lex $P3088, "$/"
    unless_null $P3088, vivify_1493
    $P3088 = root_new ['parrot';'Hash']
  vivify_1493:
    set $P3089, $P3088["xblock"]
    unless_null $P3089, vivify_1494
    $P3089 = root_new ['parrot';'ResizablePMCArray']
  vivify_1494:
    set $P3090, $P3089[$I3087]
    unless_null $P3090, vivify_1495
    new $P3090, "Undef"
  vivify_1495:
    $P3091 = $P3090."ast"()
    $P3092 = "xblock_immediate"($P3091)
    store_lex "$past", $P3092
.annotate 'line', 939
    find_lex $P3094, "$/"
    unless_null $P3094, vivify_1496
    $P3094 = root_new ['parrot';'Hash']
  vivify_1496:
    set $P3095, $P3094["else"]
    unless_null $P3095, vivify_1497
    new $P3095, "Undef"
  vivify_1497:
    unless $P3095, if_3093_end
.annotate 'line', 940
    find_lex $P3096, "$past"
    find_lex $P3097, "$/"
    unless_null $P3097, vivify_1498
    $P3097 = root_new ['parrot';'Hash']
  vivify_1498:
    set $P3098, $P3097["else"]
    unless_null $P3098, vivify_1499
    $P3098 = root_new ['parrot';'ResizablePMCArray']
  vivify_1499:
    set $P3099, $P3098[0]
    unless_null $P3099, vivify_1500
    new $P3099, "Undef"
  vivify_1500:
    $P3100 = $P3099."ast"()
    $P3101 = "block_immediate"($P3100)
    $P3096."push"($P3101)
  if_3093_end:
.annotate 'line', 943
    new $P3122, 'ExceptionHandler'
    set_label $P3122, loop3121_handler
    $P3122."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3122
  loop3121_test:
    find_lex $P3102, "$count"
    set $N3103, $P3102
    isgt $I3104, $N3103, 0.0
    unless $I3104, loop3121_done
  loop3121_redo:
    .const 'Sub' $P3106 = "438_1300062003.824" 
    capture_lex $P3106
    $P3106()
  loop3121_next:
    goto loop3121_test
  loop3121_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3123, exception, 'type'
    eq $P3123, .CONTROL_LOOP_NEXT, loop3121_next
    eq $P3123, .CONTROL_LOOP_REDO, loop3121_redo
  loop3121_done:
    pop_eh 
.annotate 'line', 949
    find_lex $P3124, "$/"
    find_lex $P3125, "$past"
    $P3126 = $P3124."!make"($P3125)
.annotate 'line', 936
    .return ($P3126)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3105"  :anon :subid("438_1300062003.824") :outer("437_1300062003.824")
.annotate 'line', 945
    new $P3107, "Undef"
    .lex "$else", $P3107
.annotate 'line', 943
    find_lex $P3108, "$count"
    clone $P3109, $P3108
    dec $P3108
.annotate 'line', 945
    find_lex $P3110, "$past"
    store_lex "$else", $P3110
.annotate 'line', 946
    find_lex $P3111, "$count"
    set $I3112, $P3111
    find_lex $P3113, "$/"
    unless_null $P3113, vivify_1501
    $P3113 = root_new ['parrot';'Hash']
  vivify_1501:
    set $P3114, $P3113["xblock"]
    unless_null $P3114, vivify_1502
    $P3114 = root_new ['parrot';'ResizablePMCArray']
  vivify_1502:
    set $P3115, $P3114[$I3112]
    unless_null $P3115, vivify_1503
    new $P3115, "Undef"
  vivify_1503:
    $P3116 = $P3115."ast"()
    $P3117 = "xblock_immediate"($P3116)
    store_lex "$past", $P3117
.annotate 'line', 947
    find_lex $P3118, "$past"
    find_lex $P3119, "$else"
    $P3120 = $P3118."push"($P3119)
.annotate 'line', 943
    .return ($P3120)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<unless>"  :subid("439_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_3128
    .param pmc param_3129
.annotate 'line', 952
    .lex "self", param_3128
    .lex "$/", param_3129
.annotate 'line', 953
    new $P3130, "Undef"
    .lex "$past", $P3130
    find_lex $P3131, "$/"
    unless_null $P3131, vivify_1504
    $P3131 = root_new ['parrot';'Hash']
  vivify_1504:
    set $P3132, $P3131["xblock"]
    unless_null $P3132, vivify_1505
    new $P3132, "Undef"
  vivify_1505:
    $P3133 = $P3132."ast"()
    $P3134 = "xblock_immediate"($P3133)
    store_lex "$past", $P3134
.annotate 'line', 954
    find_lex $P3135, "$past"
    $P3135."pasttype"("unless")
.annotate 'line', 955
    find_lex $P3136, "$/"
    find_lex $P3137, "$past"
    $P3138 = $P3136."!make"($P3137)
.annotate 'line', 952
    .return ($P3138)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<while>"  :subid("440_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_3140
    .param pmc param_3141
.annotate 'line', 958
    .lex "self", param_3140
    .lex "$/", param_3141
.annotate 'line', 959
    new $P3142, "Undef"
    .lex "$past", $P3142
    find_lex $P3143, "$/"
    unless_null $P3143, vivify_1506
    $P3143 = root_new ['parrot';'Hash']
  vivify_1506:
    set $P3144, $P3143["xblock"]
    unless_null $P3144, vivify_1507
    new $P3144, "Undef"
  vivify_1507:
    $P3145 = $P3144."ast"()
    $P3146 = "xblock_immediate"($P3145)
    store_lex "$past", $P3146
.annotate 'line', 960
    find_lex $P3147, "$past"
    find_lex $P3148, "$/"
    unless_null $P3148, vivify_1508
    $P3148 = root_new ['parrot';'Hash']
  vivify_1508:
    set $P3149, $P3148["sym"]
    unless_null $P3149, vivify_1509
    new $P3149, "Undef"
  vivify_1509:
    set $S3150, $P3149
    $P3147."pasttype"($S3150)
.annotate 'line', 961
    find_lex $P3151, "$/"
    find_lex $P3152, "$past"
    $P3153 = $P3151."!make"($P3152)
.annotate 'line', 958
    .return ($P3153)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<repeat>"  :subid("441_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_3155
    .param pmc param_3156
.annotate 'line', 964
    .lex "self", param_3155
    .lex "$/", param_3156
.annotate 'line', 965
    new $P3157, "Undef"
    .lex "$pasttype", $P3157
.annotate 'line', 966
    new $P3158, "Undef"
    .lex "$past", $P3158
.annotate 'line', 965
    new $P3159, "String"
    assign $P3159, "repeat_"
    find_lex $P3160, "$/"
    unless_null $P3160, vivify_1510
    $P3160 = root_new ['parrot';'Hash']
  vivify_1510:
    set $P3161, $P3160["wu"]
    unless_null $P3161, vivify_1511
    new $P3161, "Undef"
  vivify_1511:
    set $S3162, $P3161
    concat $P3163, $P3159, $S3162
    store_lex "$pasttype", $P3163
    find_lex $P3164, "$past"
.annotate 'line', 967
    find_lex $P3166, "$/"
    unless_null $P3166, vivify_1512
    $P3166 = root_new ['parrot';'Hash']
  vivify_1512:
    set $P3167, $P3166["xblock"]
    unless_null $P3167, vivify_1513
    new $P3167, "Undef"
  vivify_1513:
    if $P3167, if_3165
.annotate 'line', 972
    get_hll_global $P3174, ["PAST"], "Op"
    find_lex $P3175, "$/"
    unless_null $P3175, vivify_1514
    $P3175 = root_new ['parrot';'Hash']
  vivify_1514:
    set $P3176, $P3175["EXPR"]
    unless_null $P3176, vivify_1515
    new $P3176, "Undef"
  vivify_1515:
    $P3177 = $P3176."ast"()
    find_lex $P3178, "$/"
    unless_null $P3178, vivify_1516
    $P3178 = root_new ['parrot';'Hash']
  vivify_1516:
    set $P3179, $P3178["pblock"]
    unless_null $P3179, vivify_1517
    new $P3179, "Undef"
  vivify_1517:
    $P3180 = $P3179."ast"()
    $P3181 = "block_immediate"($P3180)
    find_lex $P3182, "$pasttype"
    find_lex $P3183, "$/"
    $P3184 = $P3174."new"($P3177, $P3181, $P3182 :named("pasttype"), $P3183 :named("node"))
    store_lex "$past", $P3184
.annotate 'line', 971
    goto if_3165_end
  if_3165:
.annotate 'line', 968
    find_lex $P3168, "$/"
    unless_null $P3168, vivify_1518
    $P3168 = root_new ['parrot';'Hash']
  vivify_1518:
    set $P3169, $P3168["xblock"]
    unless_null $P3169, vivify_1519
    new $P3169, "Undef"
  vivify_1519:
    $P3170 = $P3169."ast"()
    $P3171 = "xblock_immediate"($P3170)
    store_lex "$past", $P3171
.annotate 'line', 969
    find_lex $P3172, "$past"
    find_lex $P3173, "$pasttype"
    $P3172."pasttype"($P3173)
  if_3165_end:
.annotate 'line', 975
    find_lex $P3185, "$/"
    find_lex $P3186, "$past"
    $P3187 = $P3185."!make"($P3186)
.annotate 'line', 964
    .return ($P3187)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<for>"  :subid("442_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_3189
    .param pmc param_3190
.annotate 'line', 978
    .lex "self", param_3189
    .lex "$/", param_3190
.annotate 'line', 979
    new $P3191, "Undef"
    .lex "$past", $P3191
.annotate 'line', 981
    new $P3192, "Undef"
    .lex "$block", $P3192
.annotate 'line', 979
    find_lex $P3193, "$/"
    unless_null $P3193, vivify_1520
    $P3193 = root_new ['parrot';'Hash']
  vivify_1520:
    set $P3194, $P3193["xblock"]
    unless_null $P3194, vivify_1521
    new $P3194, "Undef"
  vivify_1521:
    $P3195 = $P3194."ast"()
    store_lex "$past", $P3195
.annotate 'line', 980
    find_lex $P3196, "$past"
    $P3196."pasttype"("for")
.annotate 'line', 981
    find_lex $P3197, "$past"
    unless_null $P3197, vivify_1522
    $P3197 = root_new ['parrot';'ResizablePMCArray']
  vivify_1522:
    set $P3198, $P3197[1]
    unless_null $P3198, vivify_1523
    new $P3198, "Undef"
  vivify_1523:
    store_lex "$block", $P3198
.annotate 'line', 982
    find_lex $P3200, "$block"
    $P3201 = $P3200."arity"()
    if $P3201, unless_3199_end
.annotate 'line', 983
    find_lex $P3202, "$block"
    unless_null $P3202, vivify_1524
    $P3202 = root_new ['parrot';'ResizablePMCArray']
  vivify_1524:
    set $P3203, $P3202[0]
    unless_null $P3203, vivify_1525
    new $P3203, "Undef"
  vivify_1525:
    get_hll_global $P3204, ["PAST"], "Var"
    $P3205 = $P3204."new"("$_" :named("name"), "parameter" :named("scope"))
    $P3203."push"($P3205)
.annotate 'line', 984
    find_lex $P3206, "$block"
    $P3206."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 985
    find_lex $P3207, "$block"
    $P3207."arity"(1)
  unless_3199_end:
.annotate 'line', 987
    find_lex $P3208, "$block"
    $P3208."blocktype"("immediate")
.annotate 'line', 988
    find_lex $P3209, "$/"
    find_lex $P3210, "$past"
    $P3211 = $P3209."!make"($P3210)
.annotate 'line', 978
    .return ($P3211)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CATCH>"  :subid("443_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_3213
    .param pmc param_3214
.annotate 'line', 991
    .lex "self", param_3213
    .lex "$/", param_3214
.annotate 'line', 992
    new $P3215, "Undef"
    .lex "$block", $P3215
    find_lex $P3216, "$/"
    unless_null $P3216, vivify_1526
    $P3216 = root_new ['parrot';'Hash']
  vivify_1526:
    set $P3217, $P3216["block"]
    unless_null $P3217, vivify_1527
    new $P3217, "Undef"
  vivify_1527:
    $P3218 = $P3217."ast"()
    store_lex "$block", $P3218
.annotate 'line', 993
    find_lex $P3219, "$/"
    find_lex $P3220, "$block"
    "push_block_handler"($P3219, $P3220)
.annotate 'line', 994
    get_global $P3221, "@BLOCK"
    unless_null $P3221, vivify_1528
    $P3221 = root_new ['parrot';'ResizablePMCArray']
  vivify_1528:
    set $P3222, $P3221[0]
    unless_null $P3222, vivify_1529
    new $P3222, "Undef"
  vivify_1529:
    $P3223 = $P3222."handlers"()
    set $P3224, $P3223[0]
    unless_null $P3224, vivify_1530
    new $P3224, "Undef"
  vivify_1530:
    $P3224."handle_types_except"("CONTROL")
.annotate 'line', 995
    find_lex $P3225, "$/"
    get_hll_global $P3226, ["PAST"], "Stmts"
    find_lex $P3227, "$/"
    $P3228 = $P3226."new"($P3227 :named("node"))
    $P3229 = $P3225."!make"($P3228)
.annotate 'line', 991
    .return ($P3229)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CONTROL>"  :subid("444_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_3231
    .param pmc param_3232
.annotate 'line', 998
    .lex "self", param_3231
    .lex "$/", param_3232
.annotate 'line', 999
    new $P3233, "Undef"
    .lex "$block", $P3233
    find_lex $P3234, "$/"
    unless_null $P3234, vivify_1531
    $P3234 = root_new ['parrot';'Hash']
  vivify_1531:
    set $P3235, $P3234["block"]
    unless_null $P3235, vivify_1532
    new $P3235, "Undef"
  vivify_1532:
    $P3236 = $P3235."ast"()
    store_lex "$block", $P3236
.annotate 'line', 1000
    find_lex $P3237, "$/"
    find_lex $P3238, "$block"
    "push_block_handler"($P3237, $P3238)
.annotate 'line', 1001
    get_global $P3239, "@BLOCK"
    unless_null $P3239, vivify_1533
    $P3239 = root_new ['parrot';'ResizablePMCArray']
  vivify_1533:
    set $P3240, $P3239[0]
    unless_null $P3240, vivify_1534
    new $P3240, "Undef"
  vivify_1534:
    $P3241 = $P3240."handlers"()
    set $P3242, $P3241[0]
    unless_null $P3242, vivify_1535
    new $P3242, "Undef"
  vivify_1535:
    $P3242."handle_types"("CONTROL")
.annotate 'line', 1002
    find_lex $P3243, "$/"
    get_hll_global $P3244, ["PAST"], "Stmts"
    find_lex $P3245, "$/"
    $P3246 = $P3244."new"($P3245 :named("node"))
    $P3247 = $P3243."!make"($P3246)
.annotate 'line', 998
    .return ($P3247)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<INIT>"  :subid("445_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_3250
    .param pmc param_3251
.annotate 'line', 1042
    .lex "self", param_3250
    .lex "$/", param_3251
.annotate 'line', 1043
    new $P3252, "Undef"
    .lex "$init_block", $P3252
    get_hll_global $P3253, ["PAST"], "Block"
    $P3254 = $P3253."new"("immediate" :named("blocktype"))
    store_lex "$init_block", $P3254
.annotate 'line', 1044
    find_lex $P3255, "$init_block"
    $P3256 = $P3255."loadinit"()
    find_lex $P3257, "$/"
    unless_null $P3257, vivify_1536
    $P3257 = root_new ['parrot';'Hash']
  vivify_1536:
    set $P3258, $P3257["blorst"]
    unless_null $P3258, vivify_1537
    new $P3258, "Undef"
  vivify_1537:
    $P3259 = $P3258."ast"()
    $P3256."push"($P3259)
.annotate 'line', 1045
    find_lex $P3260, "$/"
    find_lex $P3261, "$init_block"
    $P3262 = $P3260."!make"($P3261)
.annotate 'line', 1042
    .return ($P3262)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<try>"  :subid("446_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_3264
    .param pmc param_3265
.annotate 'line', 1048
    .lex "self", param_3264
    .lex "$/", param_3265
.annotate 'line', 1049
    new $P3266, "Undef"
    .lex "$past", $P3266
    find_lex $P3267, "$/"
    unless_null $P3267, vivify_1538
    $P3267 = root_new ['parrot';'Hash']
  vivify_1538:
    set $P3268, $P3267["blorst"]
    unless_null $P3268, vivify_1539
    new $P3268, "Undef"
  vivify_1539:
    $P3269 = $P3268."ast"()
    store_lex "$past", $P3269
.annotate 'line', 1050
    get_hll_global $P3271, ["PAST"], "Block"
    find_lex $P3272, "$past"
    $P3273 = $P3271."ACCEPTS"($P3272)
    if $P3273, unless_3270_end
.annotate 'line', 1051
    get_hll_global $P3274, ["PAST"], "Block"
    find_lex $P3275, "$past"
    find_lex $P3276, "$/"
    $P3277 = $P3274."new"($P3275, "immediate" :named("blocktype"), $P3276 :named("node"))
    store_lex "$past", $P3277
  unless_3270_end:
.annotate 'line', 1053
    find_lex $P3279, "$past"
    $P3280 = $P3279."handlers"()
    if $P3280, unless_3278_end
.annotate 'line', 1054
    find_lex $P3281, "$past"
    get_hll_global $P3282, ["PAST"], "Control"
.annotate 'line', 1056
    get_hll_global $P3283, ["PAST"], "Stmts"
.annotate 'line', 1057
    get_hll_global $P3284, ["PAST"], "Op"
.annotate 'line', 1058
    get_hll_global $P3285, ["PAST"], "Var"
.annotate 'line', 1059
    get_hll_global $P3286, ["PAST"], "Var"
    $P3287 = $P3286."new"("register" :named("scope"), "exception" :named("name"))
    $P3288 = $P3285."new"($P3287, "handled", "keyed" :named("scope"))
.annotate 'line', 1058
    $P3289 = $P3284."new"($P3288, 1, "bind" :named("pasttype"))
.annotate 'line', 1057
    $P3290 = $P3283."new"($P3289)
.annotate 'line', 1056
    $P3291 = $P3282."new"($P3290, "CONTROL" :named("handle_types_except"))
.annotate 'line', 1054
    new $P3292, "ResizablePMCArray"
    push $P3292, $P3291
    $P3281."handlers"($P3292)
  unless_3278_end:
.annotate 'line', 1068
    find_lex $P3293, "$/"
    find_lex $P3294, "$past"
    $P3295 = $P3293."!make"($P3294)
.annotate 'line', 1048
    .return ($P3295)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blorst"  :subid("447_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_3297
    .param pmc param_3298
.annotate 'line', 1071
    .lex "self", param_3297
    .lex "$/", param_3298
.annotate 'line', 1072
    find_lex $P3299, "$/"
.annotate 'line', 1073
    find_lex $P3302, "$/"
    unless_null $P3302, vivify_1540
    $P3302 = root_new ['parrot';'Hash']
  vivify_1540:
    set $P3303, $P3302["block"]
    unless_null $P3303, vivify_1541
    new $P3303, "Undef"
  vivify_1541:
    if $P3303, if_3301
.annotate 'line', 1074
    find_lex $P3308, "$/"
    unless_null $P3308, vivify_1542
    $P3308 = root_new ['parrot';'Hash']
  vivify_1542:
    set $P3309, $P3308["statement"]
    unless_null $P3309, vivify_1543
    new $P3309, "Undef"
  vivify_1543:
    $P3310 = $P3309."ast"()
    set $P3300, $P3310
.annotate 'line', 1073
    goto if_3301_end
  if_3301:
    find_lex $P3304, "$/"
    unless_null $P3304, vivify_1544
    $P3304 = root_new ['parrot';'Hash']
  vivify_1544:
    set $P3305, $P3304["block"]
    unless_null $P3305, vivify_1545
    new $P3305, "Undef"
  vivify_1545:
    $P3306 = $P3305."ast"()
    $P3307 = "block_immediate"($P3306)
    set $P3300, $P3307
  if_3301_end:
    $P3311 = $P3299."!make"($P3300)
.annotate 'line', 1071
    .return ($P3311)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<if>"  :subid("448_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_3313
    .param pmc param_3314
.annotate 'line', 1079
    .lex "self", param_3313
    .lex "$/", param_3314
    find_lex $P3315, "$/"
    find_lex $P3316, "$/"
    unless_null $P3316, vivify_1546
    $P3316 = root_new ['parrot';'Hash']
  vivify_1546:
    set $P3317, $P3316["cond"]
    unless_null $P3317, vivify_1547
    new $P3317, "Undef"
  vivify_1547:
    $P3318 = $P3317."ast"()
    $P3319 = $P3315."!make"($P3318)
    .return ($P3319)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<unless>"  :subid("449_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_3321
    .param pmc param_3322
.annotate 'line', 1080
    .lex "self", param_3321
    .lex "$/", param_3322
    find_lex $P3323, "$/"
    find_lex $P3324, "$/"
    unless_null $P3324, vivify_1548
    $P3324 = root_new ['parrot';'Hash']
  vivify_1548:
    set $P3325, $P3324["cond"]
    unless_null $P3325, vivify_1549
    new $P3325, "Undef"
  vivify_1549:
    $P3326 = $P3325."ast"()
    $P3327 = $P3323."!make"($P3326)
    .return ($P3327)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<while>"  :subid("450_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_3329
    .param pmc param_3330
.annotate 'line', 1082
    .lex "self", param_3329
    .lex "$/", param_3330
    find_lex $P3331, "$/"
    find_lex $P3332, "$/"
    unless_null $P3332, vivify_1550
    $P3332 = root_new ['parrot';'Hash']
  vivify_1550:
    set $P3333, $P3332["cond"]
    unless_null $P3333, vivify_1551
    new $P3333, "Undef"
  vivify_1551:
    $P3334 = $P3333."ast"()
    $P3335 = $P3331."!make"($P3334)
    .return ($P3335)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<until>"  :subid("451_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_3337
    .param pmc param_3338
.annotate 'line', 1083
    .lex "self", param_3337
    .lex "$/", param_3338
    find_lex $P3339, "$/"
    find_lex $P3340, "$/"
    unless_null $P3340, vivify_1552
    $P3340 = root_new ['parrot';'Hash']
  vivify_1552:
    set $P3341, $P3340["cond"]
    unless_null $P3341, vivify_1553
    new $P3341, "Undef"
  vivify_1553:
    $P3342 = $P3341."ast"()
    $P3343 = $P3339."!make"($P3342)
    .return ($P3343)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<fatarrow>"  :subid("452_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_3345
    .param pmc param_3346
.annotate 'line', 1087
    .lex "self", param_3345
    .lex "$/", param_3346
    find_lex $P3347, "$/"
    find_lex $P3348, "$/"
    unless_null $P3348, vivify_1554
    $P3348 = root_new ['parrot';'Hash']
  vivify_1554:
    set $P3349, $P3348["fatarrow"]
    unless_null $P3349, vivify_1555
    new $P3349, "Undef"
  vivify_1555:
    $P3350 = $P3349."ast"()
    $P3351 = $P3347."!make"($P3350)
    .return ($P3351)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<colonpair>"  :subid("453_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_3353
    .param pmc param_3354
.annotate 'line', 1088
    .lex "self", param_3353
    .lex "$/", param_3354
    find_lex $P3355, "$/"
    find_lex $P3356, "$/"
    unless_null $P3356, vivify_1556
    $P3356 = root_new ['parrot';'Hash']
  vivify_1556:
    set $P3357, $P3356["colonpair"]
    unless_null $P3357, vivify_1557
    new $P3357, "Undef"
  vivify_1557:
    $P3358 = $P3357."ast"()
    $P3359 = $P3355."!make"($P3358)
    .return ($P3359)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<variable>"  :subid("454_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_3361
    .param pmc param_3362
.annotate 'line', 1089
    .lex "self", param_3361
    .lex "$/", param_3362
    find_lex $P3363, "$/"
    find_lex $P3364, "$/"
    unless_null $P3364, vivify_1558
    $P3364 = root_new ['parrot';'Hash']
  vivify_1558:
    set $P3365, $P3364["variable"]
    unless_null $P3365, vivify_1559
    new $P3365, "Undef"
  vivify_1559:
    $P3366 = $P3365."ast"()
    $P3367 = $P3363."!make"($P3366)
    .return ($P3367)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<package_declarator>"  :subid("455_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_3369
    .param pmc param_3370
.annotate 'line', 1090
    .lex "self", param_3369
    .lex "$/", param_3370
    find_lex $P3371, "$/"
    find_lex $P3372, "$/"
    unless_null $P3372, vivify_1560
    $P3372 = root_new ['parrot';'Hash']
  vivify_1560:
    set $P3373, $P3372["package_declarator"]
    unless_null $P3373, vivify_1561
    new $P3373, "Undef"
  vivify_1561:
    $P3374 = $P3373."ast"()
    $P3375 = $P3371."!make"($P3374)
    .return ($P3375)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<scope_declarator>"  :subid("456_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_3377
    .param pmc param_3378
.annotate 'line', 1091
    .lex "self", param_3377
    .lex "$/", param_3378
    find_lex $P3379, "$/"
    find_lex $P3380, "$/"
    unless_null $P3380, vivify_1562
    $P3380 = root_new ['parrot';'Hash']
  vivify_1562:
    set $P3381, $P3380["scope_declarator"]
    unless_null $P3381, vivify_1563
    new $P3381, "Undef"
  vivify_1563:
    $P3382 = $P3381."ast"()
    $P3383 = $P3379."!make"($P3382)
    .return ($P3383)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<routine_declarator>"  :subid("457_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_3385
    .param pmc param_3386
.annotate 'line', 1092
    .lex "self", param_3385
    .lex "$/", param_3386
    find_lex $P3387, "$/"
    find_lex $P3388, "$/"
    unless_null $P3388, vivify_1564
    $P3388 = root_new ['parrot';'Hash']
  vivify_1564:
    set $P3389, $P3388["routine_declarator"]
    unless_null $P3389, vivify_1565
    new $P3389, "Undef"
  vivify_1565:
    $P3390 = $P3389."ast"()
    $P3391 = $P3387."!make"($P3390)
    .return ($P3391)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<regex_declarator>"  :subid("458_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_3393
    .param pmc param_3394
.annotate 'line', 1093
    .lex "self", param_3393
    .lex "$/", param_3394
    find_lex $P3395, "$/"
    find_lex $P3396, "$/"
    unless_null $P3396, vivify_1566
    $P3396 = root_new ['parrot';'Hash']
  vivify_1566:
    set $P3397, $P3396["regex_declarator"]
    unless_null $P3397, vivify_1567
    new $P3397, "Undef"
  vivify_1567:
    $P3398 = $P3397."ast"()
    $P3399 = $P3395."!make"($P3398)
    .return ($P3399)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<statement_prefix>"  :subid("459_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_3401
    .param pmc param_3402
.annotate 'line', 1094
    .lex "self", param_3401
    .lex "$/", param_3402
    find_lex $P3403, "$/"
    find_lex $P3404, "$/"
    unless_null $P3404, vivify_1568
    $P3404 = root_new ['parrot';'Hash']
  vivify_1568:
    set $P3405, $P3404["statement_prefix"]
    unless_null $P3405, vivify_1569
    new $P3405, "Undef"
  vivify_1569:
    $P3406 = $P3405."ast"()
    $P3407 = $P3403."!make"($P3406)
    .return ($P3407)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<lambda>"  :subid("460_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_3409
    .param pmc param_3410
.annotate 'line', 1095
    .lex "self", param_3409
    .lex "$/", param_3410
    find_lex $P3411, "$/"
    find_lex $P3412, "$/"
    unless_null $P3412, vivify_1570
    $P3412 = root_new ['parrot';'Hash']
  vivify_1570:
    set $P3413, $P3412["pblock"]
    unless_null $P3413, vivify_1571
    new $P3413, "Undef"
  vivify_1571:
    $P3414 = $P3413."ast"()
    $P3415 = $P3411."!make"($P3414)
    .return ($P3415)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "fatarrow"  :subid("461_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_3417
    .param pmc param_3418
.annotate 'line', 1097
    .lex "self", param_3417
    .lex "$/", param_3418
.annotate 'line', 1098
    new $P3419, "Undef"
    .lex "$past", $P3419
    find_lex $P3420, "$/"
    unless_null $P3420, vivify_1572
    $P3420 = root_new ['parrot';'Hash']
  vivify_1572:
    set $P3421, $P3420["val"]
    unless_null $P3421, vivify_1573
    new $P3421, "Undef"
  vivify_1573:
    $P3422 = $P3421."ast"()
    store_lex "$past", $P3422
.annotate 'line', 1099
    find_lex $P3423, "$past"
    find_lex $P3424, "$/"
    unless_null $P3424, vivify_1574
    $P3424 = root_new ['parrot';'Hash']
  vivify_1574:
    set $P3425, $P3424["key"]
    unless_null $P3425, vivify_1575
    new $P3425, "Undef"
  vivify_1575:
    $P3426 = $P3425."Str"()
    $P3423."named"($P3426)
.annotate 'line', 1100
    find_lex $P3427, "$/"
    find_lex $P3428, "$past"
    $P3429 = $P3427."!make"($P3428)
.annotate 'line', 1097
    .return ($P3429)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair"  :subid("462_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_3431
    .param pmc param_3432
.annotate 'line', 1103
    .lex "self", param_3431
    .lex "$/", param_3432
.annotate 'line', 1104
    new $P3433, "Undef"
    .lex "$past", $P3433
.annotate 'line', 1105
    find_lex $P3436, "$/"
    unless_null $P3436, vivify_1576
    $P3436 = root_new ['parrot';'Hash']
  vivify_1576:
    set $P3437, $P3436["circumfix"]
    unless_null $P3437, vivify_1577
    new $P3437, "Undef"
  vivify_1577:
    if $P3437, if_3435
.annotate 'line', 1106
    get_hll_global $P3442, ["PAST"], "Val"
    find_lex $P3443, "$/"
    unless_null $P3443, vivify_1578
    $P3443 = root_new ['parrot';'Hash']
  vivify_1578:
    set $P3444, $P3443["not"]
    unless_null $P3444, vivify_1579
    new $P3444, "Undef"
  vivify_1579:
    isfalse $I3445, $P3444
    $P3446 = $P3442."new"($I3445 :named("value"))
    set $P3434, $P3446
.annotate 'line', 1105
    goto if_3435_end
  if_3435:
    find_lex $P3438, "$/"
    unless_null $P3438, vivify_1580
    $P3438 = root_new ['parrot';'Hash']
  vivify_1580:
    set $P3439, $P3438["circumfix"]
    unless_null $P3439, vivify_1581
    $P3439 = root_new ['parrot';'ResizablePMCArray']
  vivify_1581:
    set $P3440, $P3439[0]
    unless_null $P3440, vivify_1582
    new $P3440, "Undef"
  vivify_1582:
    $P3441 = $P3440."ast"()
    set $P3434, $P3441
  if_3435_end:
    store_lex "$past", $P3434
.annotate 'line', 1107
    find_lex $P3447, "$past"
    find_lex $P3448, "$/"
    unless_null $P3448, vivify_1583
    $P3448 = root_new ['parrot';'Hash']
  vivify_1583:
    set $P3449, $P3448["identifier"]
    unless_null $P3449, vivify_1584
    new $P3449, "Undef"
  vivify_1584:
    set $S3450, $P3449
    $P3447."named"($S3450)
.annotate 'line', 1108
    find_lex $P3451, "$/"
    find_lex $P3452, "$past"
    $P3453 = $P3451."!make"($P3452)
.annotate 'line', 1103
    .return ($P3453)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "variable"  :subid("463_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_3455
    .param pmc param_3456
.annotate 'line', 1111
    .const 'Sub' $P3469 = "464_1300062003.824" 
    capture_lex $P3469
    .lex "self", param_3455
    .lex "$/", param_3456
.annotate 'line', 1112
    new $P3457, "Undef"
    .lex "$past", $P3457
.annotate 'line', 1111
    find_lex $P3458, "$past"
.annotate 'line', 1113
    find_lex $P3460, "$/"
    unless_null $P3460, vivify_1585
    $P3460 = root_new ['parrot';'Hash']
  vivify_1585:
    set $P3461, $P3460["postcircumfix"]
    unless_null $P3461, vivify_1586
    new $P3461, "Undef"
  vivify_1586:
    if $P3461, if_3459
.annotate 'line', 1117
    .const 'Sub' $P3469 = "464_1300062003.824" 
    capture_lex $P3469
    $P3469()
    goto if_3459_end
  if_3459:
.annotate 'line', 1114
    find_lex $P3462, "$/"
    unless_null $P3462, vivify_1603
    $P3462 = root_new ['parrot';'Hash']
  vivify_1603:
    set $P3463, $P3462["postcircumfix"]
    unless_null $P3463, vivify_1604
    new $P3463, "Undef"
  vivify_1604:
    $P3464 = $P3463."ast"()
    store_lex "$past", $P3464
.annotate 'line', 1115
    find_lex $P3465, "$past"
    get_hll_global $P3466, ["PAST"], "Var"
    $P3467 = $P3466."new"("$/" :named("name"))
    $P3465."unshift"($P3467)
  if_3459_end:
.annotate 'line', 1147
    find_lex $P3541, "$/"
    find_lex $P3542, "$past"
    $P3543 = $P3541."!make"($P3542)
.annotate 'line', 1111
    .return ($P3543)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3468"  :anon :subid("464_1300062003.824") :outer("463_1300062003.824")
.annotate 'line', 1118
    $P3470 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P3470
    get_hll_global $P3471, ["NQP"], "Compiler"
    find_lex $P3472, "$/"
    set $S3473, $P3472
    $P3474 = $P3471."parse_name"($S3473)
    store_lex "@name", $P3474
.annotate 'line', 1119
    get_hll_global $P3475, ["PAST"], "Var"
    find_lex $P3476, "@name"
    $P3477 = $P3476."pop"()
    set $S3478, $P3477
    $P3479 = $P3475."new"($S3478 :named("name"))
    store_lex "$past", $P3479
.annotate 'line', 1120
    find_lex $P3481, "@name"
    unless $P3481, if_3480_end
.annotate 'line', 1121
    find_lex $P3483, "@name"
    unless_null $P3483, vivify_1587
    $P3483 = root_new ['parrot';'ResizablePMCArray']
  vivify_1587:
    set $P3484, $P3483[0]
    unless_null $P3484, vivify_1588
    new $P3484, "Undef"
  vivify_1588:
    set $S3485, $P3484
    iseq $I3486, $S3485, "GLOBAL"
    unless $I3486, if_3482_end
    find_lex $P3487, "@name"
    $P3487."shift"()
  if_3482_end:
.annotate 'line', 1122
    find_lex $P3488, "$past"
    find_lex $P3489, "@name"
    $P3488."namespace"($P3489)
.annotate 'line', 1123
    find_lex $P3490, "$past"
    $P3490."scope"("package")
.annotate 'line', 1124
    find_lex $P3491, "$past"
    find_lex $P3492, "$/"
    unless_null $P3492, vivify_1589
    $P3492 = root_new ['parrot';'Hash']
  vivify_1589:
    set $P3493, $P3492["sigil"]
    unless_null $P3493, vivify_1590
    new $P3493, "Undef"
  vivify_1590:
    $P3494 = "vivitype"($P3493)
    $P3491."viviself"($P3494)
.annotate 'line', 1125
    find_lex $P3495, "$past"
    $P3495."lvalue"(1)
  if_3480_end:
.annotate 'line', 1127
    find_lex $P3498, "$/"
    unless_null $P3498, vivify_1591
    $P3498 = root_new ['parrot';'Hash']
  vivify_1591:
    set $P3499, $P3498["twigil"]
    unless_null $P3499, vivify_1592
    $P3499 = root_new ['parrot';'ResizablePMCArray']
  vivify_1592:
    set $P3500, $P3499[0]
    unless_null $P3500, vivify_1593
    new $P3500, "Undef"
  vivify_1593:
    set $S3501, $P3500
    iseq $I3502, $S3501, "*"
    if $I3502, if_3497
.annotate 'line', 1140
    find_lex $P3524, "$/"
    unless_null $P3524, vivify_1594
    $P3524 = root_new ['parrot';'Hash']
  vivify_1594:
    set $P3525, $P3524["twigil"]
    unless_null $P3525, vivify_1595
    $P3525 = root_new ['parrot';'ResizablePMCArray']
  vivify_1595:
    set $P3526, $P3525[0]
    unless_null $P3526, vivify_1596
    new $P3526, "Undef"
  vivify_1596:
    set $S3527, $P3526
    iseq $I3528, $S3527, "!"
    if $I3528, if_3523
    new $P3522, 'Integer'
    set $P3522, $I3528
    goto if_3523_end
  if_3523:
.annotate 'line', 1141
    find_lex $P3529, "$past"
    get_hll_global $P3530, ["PAST"], "Var"
    $P3531 = $P3530."new"("self" :named("name"))
    $P3529."push"($P3531)
.annotate 'line', 1142
    find_lex $P3532, "$past"
    $P3532."scope"("attribute")
.annotate 'line', 1143
    find_lex $P3533, "$past"
    find_lex $P3534, "$/"
    unless_null $P3534, vivify_1597
    $P3534 = root_new ['parrot';'Hash']
  vivify_1597:
    set $P3535, $P3534["sigil"]
    unless_null $P3535, vivify_1598
    new $P3535, "Undef"
  vivify_1598:
    $P3536 = "vivitype"($P3535)
    $P3533."viviself"($P3536)
.annotate 'line', 1144
    find_lex $P3537, "$past"
    get_hll_global $P3538, ["PAST"], "Var"
    $P3539 = $P3538."new"("$?CLASS" :named("name"))
    $P3540 = $P3537."push"($P3539)
.annotate 'line', 1140
    set $P3522, $P3540
  if_3523_end:
    set $P3496, $P3522
.annotate 'line', 1127
    goto if_3497_end
  if_3497:
.annotate 'line', 1128
    find_lex $P3503, "$past"
    $P3503."scope"("contextual")
.annotate 'line', 1129
    find_lex $P3504, "$past"
.annotate 'line', 1130
    get_hll_global $P3505, ["PAST"], "Var"
.annotate 'line', 1132
    find_lex $P3506, "$/"
    unless_null $P3506, vivify_1599
    $P3506 = root_new ['parrot';'Hash']
  vivify_1599:
    set $P3507, $P3506["sigil"]
    unless_null $P3507, vivify_1600
    new $P3507, "Undef"
  vivify_1600:
    set $S3508, $P3507
    new $P3509, 'String'
    set $P3509, $S3508
    find_lex $P3510, "$/"
    unless_null $P3510, vivify_1601
    $P3510 = root_new ['parrot';'Hash']
  vivify_1601:
    set $P3511, $P3510["desigilname"]
    unless_null $P3511, vivify_1602
    new $P3511, "Undef"
  vivify_1602:
    concat $P3512, $P3509, $P3511
.annotate 'line', 1134
    get_hll_global $P3513, ["PAST"], "Op"
    new $P3514, "String"
    assign $P3514, "Contextual "
    find_lex $P3515, "$/"
    set $S3516, $P3515
    concat $P3517, $P3514, $S3516
    concat $P3518, $P3517, " not found"
    $P3519 = $P3513."new"($P3518, "die" :named("pirop"))
    $P3520 = $P3505."new"("package" :named("scope"), "" :named("namespace"), $P3512 :named("name"), $P3519 :named("viviself"))
.annotate 'line', 1130
    $P3521 = $P3504."viviself"($P3520)
.annotate 'line', 1127
    set $P3496, $P3521
  if_3497_end:
.annotate 'line', 1117
    .return ($P3496)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<module>"  :subid("465_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_3545
    .param pmc param_3546
.annotate 'line', 1150
    .lex "self", param_3545
    .lex "$/", param_3546
    find_lex $P3547, "$/"
    find_lex $P3548, "$/"
    unless_null $P3548, vivify_1605
    $P3548 = root_new ['parrot';'Hash']
  vivify_1605:
    set $P3549, $P3548["package_def"]
    unless_null $P3549, vivify_1606
    new $P3549, "Undef"
  vivify_1606:
    $P3550 = $P3549."ast"()
    $P3551 = $P3547."!make"($P3550)
    .return ($P3551)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<knowhow>"  :subid("466_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_3553
    .param pmc param_3554
.annotate 'line', 1151
    .lex "self", param_3553
    .lex "$/", param_3554
    find_lex $P3555, "$/"
    find_lex $P3556, "$/"
    unless_null $P3556, vivify_1607
    $P3556 = root_new ['parrot';'Hash']
  vivify_1607:
    set $P3557, $P3556["package_def"]
    unless_null $P3557, vivify_1608
    new $P3557, "Undef"
  vivify_1608:
    $P3558 = $P3557."ast"()
    $P3559 = $P3555."!make"($P3558)
    .return ($P3559)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<class>"  :subid("467_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_3561
    .param pmc param_3562
.annotate 'line', 1152
    .lex "self", param_3561
    .lex "$/", param_3562
    find_lex $P3563, "$/"
    find_lex $P3564, "$/"
    unless_null $P3564, vivify_1609
    $P3564 = root_new ['parrot';'Hash']
  vivify_1609:
    set $P3565, $P3564["package_def"]
    unless_null $P3565, vivify_1610
    new $P3565, "Undef"
  vivify_1610:
    $P3566 = $P3565."ast"()
    $P3567 = $P3563."!make"($P3566)
    .return ($P3567)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<grammar>"  :subid("468_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_3569
    .param pmc param_3570
.annotate 'line', 1153
    .lex "self", param_3569
    .lex "$/", param_3570
    find_lex $P3571, "$/"
    find_lex $P3572, "$/"
    unless_null $P3572, vivify_1611
    $P3572 = root_new ['parrot';'Hash']
  vivify_1611:
    set $P3573, $P3572["package_def"]
    unless_null $P3573, vivify_1612
    new $P3573, "Undef"
  vivify_1612:
    $P3574 = $P3573."ast"()
    $P3575 = $P3571."!make"($P3574)
    .return ($P3575)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<role>"  :subid("469_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_3577
    .param pmc param_3578
.annotate 'line', 1154
    .lex "self", param_3577
    .lex "$/", param_3578
    find_lex $P3579, "$/"
    find_lex $P3580, "$/"
    unless_null $P3580, vivify_1613
    $P3580 = root_new ['parrot';'Hash']
  vivify_1613:
    set $P3581, $P3580["package_def"]
    unless_null $P3581, vivify_1614
    new $P3581, "Undef"
  vivify_1614:
    $P3582 = $P3581."ast"()
    $P3583 = $P3579."!make"($P3582)
    .return ($P3583)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<native>"  :subid("470_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_3585
    .param pmc param_3586
.annotate 'line', 1155
    .lex "self", param_3585
    .lex "$/", param_3586
    find_lex $P3587, "$/"
    find_lex $P3588, "$/"
    unless_null $P3588, vivify_1615
    $P3588 = root_new ['parrot';'Hash']
  vivify_1615:
    set $P3589, $P3588["package_def"]
    unless_null $P3589, vivify_1616
    new $P3589, "Undef"
  vivify_1616:
    $P3590 = $P3589."ast"()
    $P3591 = $P3587."!make"($P3590)
    .return ($P3591)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "package_def"  :subid("471_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_3593
    .param pmc param_3594
.annotate 'line', 1157
    .const 'Sub' $P3743 = "473_1300062003.824" 
    capture_lex $P3743
    .const 'Sub' $P3692 = "472_1300062003.824" 
    capture_lex $P3692
    .lex "self", param_3593
    .lex "$/", param_3594
.annotate 'line', 1159
    $P3595 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P3595
.annotate 'line', 1160
    new $P3596, "Undef"
    .lex "$name", $P3596
.annotate 'line', 1161
    new $P3597, "Undef"
    .lex "$how", $P3597
.annotate 'line', 1164
    new $P3598, "Undef"
    .lex "$past", $P3598
.annotate 'line', 1159
    find_lex $P3599, "$/"
    unless_null $P3599, vivify_1617
    $P3599 = root_new ['parrot';'Hash']
  vivify_1617:
    set $P3600, $P3599["name"]
    unless_null $P3600, vivify_1618
    $P3600 = root_new ['parrot';'Hash']
  vivify_1618:
    set $P3601, $P3600["identifier"]
    unless_null $P3601, vivify_1619
    new $P3601, "Undef"
  vivify_1619:
    clone $P3602, $P3601
    store_lex "@ns", $P3602
.annotate 'line', 1160
    find_lex $P3603, "@ns"
    $P3604 = $P3603."pop"()
    set $S3605, $P3604
    new $P3606, 'String'
    set $P3606, $S3605
    store_lex "$name", $P3606
.annotate 'line', 1161
    find_dynamic_lex $P3607, "$*PKGDECL"
    unless_null $P3607, vivify_1620
    get_hll_global $P3607, "$PKGDECL"
    unless_null $P3607, vivify_1621
    die "Contextual $*PKGDECL not found"
  vivify_1621:
  vivify_1620:
    find_dynamic_lex $P3608, "%*HOW"
    unless_null $P3608, vivify_1622
    get_hll_global $P3608, "%HOW"
    unless_null $P3608, vivify_1623
    die "Contextual %*HOW not found"
  vivify_1623:
  vivify_1622:
    set $P3609, $P3608[$P3607]
    unless_null $P3609, vivify_1624
    new $P3609, "Undef"
  vivify_1624:
    store_lex "$how", $P3609
.annotate 'line', 1164
    find_lex $P3612, "$/"
    unless_null $P3612, vivify_1625
    $P3612 = root_new ['parrot';'Hash']
  vivify_1625:
    set $P3613, $P3612["block"]
    unless_null $P3613, vivify_1626
    new $P3613, "Undef"
  vivify_1626:
    if $P3613, if_3611
    find_lex $P3617, "$/"
    unless_null $P3617, vivify_1627
    $P3617 = root_new ['parrot';'Hash']
  vivify_1627:
    set $P3618, $P3617["comp_unit"]
    unless_null $P3618, vivify_1628
    new $P3618, "Undef"
  vivify_1628:
    $P3619 = $P3618."ast"()
    set $P3610, $P3619
    goto if_3611_end
  if_3611:
    find_lex $P3614, "$/"
    unless_null $P3614, vivify_1629
    $P3614 = root_new ['parrot';'Hash']
  vivify_1629:
    set $P3615, $P3614["block"]
    unless_null $P3615, vivify_1630
    new $P3615, "Undef"
  vivify_1630:
    $P3616 = $P3615."ast"()
    set $P3610, $P3616
  if_3611_end:
    store_lex "$past", $P3610
.annotate 'line', 1167
    find_dynamic_lex $P3623, "$*SCOPE"
    unless_null $P3623, vivify_1631
    get_hll_global $P3623, "$SCOPE"
    unless_null $P3623, vivify_1632
    die "Contextual $*SCOPE not found"
  vivify_1632:
  vivify_1631:
    set $S3624, $P3623
    iseq $I3625, $S3624, "our"
    unless $I3625, unless_3622
    new $P3621, 'Integer'
    set $P3621, $I3625
    goto unless_3622_end
  unless_3622:
    find_dynamic_lex $P3626, "$*SCOPE"
    unless_null $P3626, vivify_1633
    get_hll_global $P3626, "$SCOPE"
    unless_null $P3626, vivify_1634
    die "Contextual $*SCOPE not found"
  vivify_1634:
  vivify_1633:
    set $S3627, $P3626
    iseq $I3628, $S3627, ""
    new $P3621, 'Integer'
    set $P3621, $I3628
  unless_3622_end:
    if $P3621, if_3620
.annotate 'line', 1172
    find_lex $P3638, "$/"
    $P3639 = $P3638."CURSOR"()
    find_dynamic_lex $P3640, "$*SCOPE"
    unless_null $P3640, vivify_1635
    get_hll_global $P3640, "$SCOPE"
    unless_null $P3640, vivify_1636
    die "Contextual $*SCOPE not found"
  vivify_1636:
  vivify_1635:
    concat $P3641, $P3640, " scoped packages are not supported"
    $P3639."panic"($P3641)
.annotate 'line', 1171
    goto if_3620_end
  if_3620:
.annotate 'line', 1168
    find_lex $P3629, "$past"
    find_lex $P3630, "$/"
    unless_null $P3630, vivify_1637
    $P3630 = root_new ['parrot';'Hash']
  vivify_1637:
    set $P3631, $P3630["name"]
    unless_null $P3631, vivify_1638
    $P3631 = root_new ['parrot';'Hash']
  vivify_1638:
    set $P3632, $P3631["identifier"]
    unless_null $P3632, vivify_1639
    new $P3632, "Undef"
  vivify_1639:
    $P3629."namespace"($P3632)
.annotate 'line', 1169
    find_dynamic_lex $P3633, "$*SC"
    unless_null $P3633, vivify_1640
    get_hll_global $P3633, "$SC"
    unless_null $P3633, vivify_1641
    die "Contextual $*SC not found"
  vivify_1641:
  vivify_1640:
    find_lex $P3634, "$/"
    unless_null $P3634, vivify_1642
    $P3634 = root_new ['parrot';'Hash']
  vivify_1642:
    set $P3635, $P3634["name"]
    unless_null $P3635, vivify_1643
    $P3635 = root_new ['parrot';'Hash']
  vivify_1643:
    set $P3636, $P3635["identifier"]
    unless_null $P3636, vivify_1644
    new $P3636, "Undef"
  vivify_1644:
    find_dynamic_lex $P3637, "$*PKGMETA"
    unless_null $P3637, vivify_1645
    get_hll_global $P3637, "$PKGMETA"
    unless_null $P3637, vivify_1646
    die "Contextual $*PKGMETA not found"
  vivify_1646:
  vivify_1645:
    $P3633."install_package_symbol"($P3636, $P3637)
  if_3620_end:
.annotate 'line', 1176
    find_dynamic_lex $P3642, "$*PACKAGE-SETUP"
    unless_null $P3642, vivify_1647
    get_hll_global $P3642, "$PACKAGE-SETUP"
    unless_null $P3642, vivify_1648
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1648:
  vivify_1647:
    get_hll_global $P3643, ["PAST"], "Stmts"
.annotate 'line', 1177
    get_hll_global $P3644, ["PAST"], "Op"
.annotate 'line', 1178
    get_hll_global $P3645, ["PAST"], "Var"
    $P3646 = $P3645."new"("type_obj" :named("name"), "register" :named("scope"), 1 :named("isdecl"))
.annotate 'line', 1179
    find_dynamic_lex $P3647, "$*SC"
    unless_null $P3647, vivify_1649
    get_hll_global $P3647, "$SC"
    unless_null $P3647, vivify_1650
    die "Contextual $*SC not found"
  vivify_1650:
  vivify_1649:
    find_dynamic_lex $P3648, "$*PKGMETA"
    unless_null $P3648, vivify_1651
    get_hll_global $P3648, "$PKGMETA"
    unless_null $P3648, vivify_1652
    die "Contextual $*PKGMETA not found"
  vivify_1652:
  vivify_1651:
    $P3649 = $P3647."get_slot_past_for_object"($P3648)
    $P3650 = $P3644."new"($P3646, $P3649, "bind" :named("pasttype"))
.annotate 'line', 1181
    get_hll_global $P3651, ["PAST"], "Op"
.annotate 'line', 1182
    get_hll_global $P3652, ["PAST"], "Var"
    $P3653 = $P3652."new"("$?CLASS" :named("name"))
.annotate 'line', 1183
    get_hll_global $P3654, ["PAST"], "Var"
    $P3655 = $P3654."new"("type_obj" :named("name"), "register" :named("scope"))
    $P3656 = $P3651."new"($P3653, $P3655, "bind" :named("pasttype"))
.annotate 'line', 1181
    $P3657 = $P3643."new"($P3650, $P3656)
.annotate 'line', 1176
    $P3642."unshift"($P3657)
.annotate 'line', 1192
    find_lex $P3661, "$how"
    can $I3662, $P3661, "parametric"
    if $I3662, if_3660
    new $P3659, 'Integer'
    set $P3659, $I3662
    goto if_3660_end
  if_3660:
    find_lex $P3663, "$how"
    find_lex $P3664, "$how"
    $P3665 = $P3663."parametric"($P3664)
    set $P3659, $P3665
  if_3660_end:
    if $P3659, if_3658
.annotate 'line', 1208
    find_lex $P3683, "$past"
    $P3683."blocktype"("immediate")
.annotate 'line', 1209
    find_lex $P3684, "$past"
    get_hll_global $P3685, ["PAST"], "Var"
    $P3686 = $P3685."new"("$?CLASS" :named("name"), "package" :named("scope"), 1 :named("isdecl"))
    $P3684."unshift"($P3686)
.annotate 'line', 1210
    find_lex $P3687, "$past"
    $P3687."symbol"("$?CLASS", "package" :named("scope"))
.annotate 'line', 1207
    goto if_3658_end
  if_3658:
.annotate 'line', 1193
    find_lex $P3666, "$past"
    $P3666."blocktype"("declaration")
.annotate 'line', 1194
    find_lex $P3667, "$past"
    get_hll_global $P3668, ["PAST"], "Var"
    $P3669 = $P3668."new"("$?CLASS" :named("name"), "parameter" :named("scope"))
    $P3667."unshift"($P3669)
.annotate 'line', 1195
    find_lex $P3670, "$past"
    $P3670."symbol"("$?CLASS", "lexical" :named("scope"))
.annotate 'line', 1196
    find_dynamic_lex $P3671, "$*PACKAGE-SETUP"
    unless_null $P3671, vivify_1653
    get_hll_global $P3671, "$PACKAGE-SETUP"
    unless_null $P3671, vivify_1654
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1654:
  vivify_1653:
    get_hll_global $P3672, ["PAST"], "Op"
.annotate 'line', 1198
    get_hll_global $P3673, ["PAST"], "Op"
.annotate 'line', 1201
    get_hll_global $P3674, ["PAST"], "Var"
    $P3675 = $P3674."new"("type_obj" :named("name"), "register" :named("scope"))
    $P3676 = $P3673."new"($P3675, "get_how PP" :named("pirop"))
.annotate 'line', 1203
    get_hll_global $P3677, ["PAST"], "Var"
    $P3678 = $P3677."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1204
    get_hll_global $P3679, ["PAST"], "Val"
    find_lex $P3680, "$past"
    $P3681 = $P3679."new"($P3680 :named("value"))
    $P3682 = $P3672."new"($P3676, $P3678, $P3681, "callmethod" :named("pasttype"), "set_body_block" :named("name"))
.annotate 'line', 1196
    $P3671."push"($P3682)
  if_3658_end:
.annotate 'line', 1215
    find_lex $P3689, "$/"
    unless_null $P3689, vivify_1655
    $P3689 = root_new ['parrot';'Hash']
  vivify_1655:
    set $P3690, $P3689["parent"]
    unless_null $P3690, vivify_1656
    new $P3690, "Undef"
  vivify_1656:
    if $P3690, if_3688
.annotate 'line', 1229
    find_dynamic_lex $P3720, "$*PKGDECL"
    unless_null $P3720, vivify_1657
    get_hll_global $P3720, "$PKGDECL"
    unless_null $P3720, vivify_1658
    die "Contextual $*PKGDECL not found"
  vivify_1658:
  vivify_1657:
    set $S3721, $P3720
    iseq $I3722, $S3721, "grammar"
    unless $I3722, if_3719_end
.annotate 'line', 1230
    find_dynamic_lex $P3723, "$*PACKAGE-SETUP"
    unless_null $P3723, vivify_1659
    get_hll_global $P3723, "$PACKAGE-SETUP"
    unless_null $P3723, vivify_1660
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1660:
  vivify_1659:
    get_hll_global $P3724, ["PAST"], "Op"
.annotate 'line', 1232
    get_hll_global $P3725, ["PAST"], "Op"
.annotate 'line', 1235
    get_hll_global $P3726, ["PAST"], "Var"
    $P3727 = $P3726."new"("type_obj" :named("name"), "register" :named("scope"))
    $P3728 = $P3725."new"($P3727, "get_how PP" :named("pirop"))
.annotate 'line', 1237
    get_hll_global $P3729, ["PAST"], "Var"
    $P3730 = $P3729."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1238
    get_hll_global $P3731, ["PAST"], "Var"
    $P3732 = $P3731."new"("Cursor" :named("name"), "Regex" :named("namespace"), "package" :named("scope"))
    $P3733 = $P3724."new"($P3728, $P3730, $P3732, "callmethod" :named("pasttype"), "add_parent" :named("name"))
.annotate 'line', 1230
    $P3723."push"($P3733)
  if_3719_end:
.annotate 'line', 1229
    goto if_3688_end
  if_3688:
.annotate 'line', 1215
    .const 'Sub' $P3692 = "472_1300062003.824" 
    capture_lex $P3692
    $P3692()
  if_3688_end:
.annotate 'line', 1243
    find_lex $P3735, "$/"
    unless_null $P3735, vivify_1667
    $P3735 = root_new ['parrot';'Hash']
  vivify_1667:
    set $P3736, $P3735["role"]
    unless_null $P3736, vivify_1668
    new $P3736, "Undef"
  vivify_1668:
    unless $P3736, if_3734_end
.annotate 'line', 1244
    find_lex $P3738, "$/"
    unless_null $P3738, vivify_1669
    $P3738 = root_new ['parrot';'Hash']
  vivify_1669:
    set $P3739, $P3738["role"]
    unless_null $P3739, vivify_1670
    new $P3739, "Undef"
  vivify_1670:
    defined $I3740, $P3739
    unless $I3740, for_undef_1671
    iter $P3737, $P3739
    new $P3770, 'ExceptionHandler'
    set_label $P3770, loop3769_handler
    $P3770."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3770
  loop3769_test:
    unless $P3737, loop3769_done
    shift $P3741, $P3737
  loop3769_redo:
    .const 'Sub' $P3743 = "473_1300062003.824" 
    capture_lex $P3743
    $P3743($P3741)
  loop3769_next:
    goto loop3769_test
  loop3769_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3771, exception, 'type'
    eq $P3771, .CONTROL_LOOP_NEXT, loop3769_next
    eq $P3771, .CONTROL_LOOP_REDO, loop3769_redo
  loop3769_done:
    pop_eh 
  for_undef_1671:
  if_3734_end:
.annotate 'line', 1261
    find_dynamic_lex $P3772, "$*PACKAGE-SETUP"
    unless_null $P3772, vivify_1676
    get_hll_global $P3772, "$PACKAGE-SETUP"
    unless_null $P3772, vivify_1677
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1677:
  vivify_1676:
    get_hll_global $P3773, ["PAST"], "Op"
.annotate 'line', 1263
    get_hll_global $P3774, ["PAST"], "Op"
.annotate 'line', 1266
    get_hll_global $P3775, ["PAST"], "Var"
    $P3776 = $P3775."new"("type_obj" :named("name"), "register" :named("scope"))
    $P3777 = $P3774."new"($P3776, "get_how PP" :named("pirop"))
.annotate 'line', 1268
    get_hll_global $P3778, ["PAST"], "Var"
    $P3779 = $P3778."new"("type_obj" :named("name"), "register" :named("scope"))
    $P3780 = $P3773."new"($P3777, $P3779, "callmethod" :named("pasttype"), "compose" :named("name"))
.annotate 'line', 1261
    $P3772."push"($P3780)
.annotate 'line', 1272
    find_lex $P3781, "$past"
    $P3782 = $P3781."loadinit"()
    get_hll_global $P3783, ["PAST"], "Block"
    find_dynamic_lex $P3784, "$*PACKAGE-SETUP"
    unless_null $P3784, vivify_1678
    get_hll_global $P3784, "$PACKAGE-SETUP"
    unless_null $P3784, vivify_1679
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1679:
  vivify_1678:
    $P3785 = $P3783."new"($P3784, "immediate" :named("blocktype"))
    $P3782."push"($P3785)
.annotate 'line', 1274
    find_lex $P3786, "$/"
    find_lex $P3787, "$past"
    $P3788 = $P3786."!make"($P3787)
.annotate 'line', 1157
    .return ($P3788)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3691"  :anon :subid("472_1300062003.824") :outer("471_1300062003.824")
.annotate 'line', 1216
    $P3693 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P3693
.annotate 'line', 1217
    new $P3694, "Undef"
    .lex "$name", $P3694
.annotate 'line', 1216
    find_lex $P3695, "$/"
    unless_null $P3695, vivify_1661
    $P3695 = root_new ['parrot';'Hash']
  vivify_1661:
    set $P3696, $P3695["parent"]
    unless_null $P3696, vivify_1662
    $P3696 = root_new ['parrot';'ResizablePMCArray']
  vivify_1662:
    set $P3697, $P3696[0]
    unless_null $P3697, vivify_1663
    $P3697 = root_new ['parrot';'Hash']
  vivify_1663:
    set $P3698, $P3697["identifier"]
    unless_null $P3698, vivify_1664
    new $P3698, "Undef"
  vivify_1664:
    clone $P3699, $P3698
    store_lex "@ns", $P3699
.annotate 'line', 1217
    find_lex $P3700, "@ns"
    $P3701 = $P3700."pop"()
    set $S3702, $P3701
    new $P3703, 'String'
    set $P3703, $S3702
    store_lex "$name", $P3703
.annotate 'line', 1218
    find_dynamic_lex $P3704, "$*PACKAGE-SETUP"
    unless_null $P3704, vivify_1665
    get_hll_global $P3704, "$PACKAGE-SETUP"
    unless_null $P3704, vivify_1666
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1666:
  vivify_1665:
    get_hll_global $P3705, ["PAST"], "Op"
.annotate 'line', 1220
    get_hll_global $P3706, ["PAST"], "Op"
.annotate 'line', 1223
    get_hll_global $P3707, ["PAST"], "Var"
    $P3708 = $P3707."new"("type_obj" :named("name"), "register" :named("scope"))
    $P3709 = $P3706."new"($P3708, "get_how PP" :named("pirop"))
.annotate 'line', 1225
    get_hll_global $P3710, ["PAST"], "Var"
    $P3711 = $P3710."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1226
    get_hll_global $P3712, ["PAST"], "Var"
    find_lex $P3713, "$name"
    set $S3714, $P3713
    find_lex $P3715, "@ns"
    $P3716 = $P3712."new"($S3714 :named("name"), $P3715 :named("namespace"), "package" :named("scope"))
    $P3717 = $P3705."new"($P3709, $P3711, $P3716, "callmethod" :named("pasttype"), "add_parent" :named("name"))
.annotate 'line', 1218
    $P3718 = $P3704."push"($P3717)
.annotate 'line', 1215
    .return ($P3718)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3742"  :anon :subid("473_1300062003.824") :outer("471_1300062003.824")
    .param pmc param_3746
.annotate 'line', 1245
    $P3744 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P3744
.annotate 'line', 1246
    new $P3745, "Undef"
    .lex "$name", $P3745
    .lex "$_", param_3746
.annotate 'line', 1245
    find_lex $P3747, "$_"
    unless_null $P3747, vivify_1672
    $P3747 = root_new ['parrot';'Hash']
  vivify_1672:
    set $P3748, $P3747["identifier"]
    unless_null $P3748, vivify_1673
    new $P3748, "Undef"
  vivify_1673:
    clone $P3749, $P3748
    store_lex "@ns", $P3749
.annotate 'line', 1246
    find_lex $P3750, "@ns"
    $P3751 = $P3750."pop"()
    set $S3752, $P3751
    new $P3753, 'String'
    set $P3753, $S3752
    store_lex "$name", $P3753
.annotate 'line', 1247
    find_dynamic_lex $P3754, "$*PACKAGE-SETUP"
    unless_null $P3754, vivify_1674
    get_hll_global $P3754, "$PACKAGE-SETUP"
    unless_null $P3754, vivify_1675
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1675:
  vivify_1674:
    get_hll_global $P3755, ["PAST"], "Op"
.annotate 'line', 1249
    get_hll_global $P3756, ["PAST"], "Op"
.annotate 'line', 1252
    get_hll_global $P3757, ["PAST"], "Var"
    $P3758 = $P3757."new"("type_obj" :named("name"), "register" :named("scope"))
    $P3759 = $P3756."new"($P3758, "get_how PP" :named("pirop"))
.annotate 'line', 1254
    get_hll_global $P3760, ["PAST"], "Var"
    $P3761 = $P3760."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1255
    get_hll_global $P3762, ["PAST"], "Var"
    find_lex $P3763, "$name"
    set $S3764, $P3763
    find_lex $P3765, "@ns"
    $P3766 = $P3762."new"($S3764 :named("name"), $P3765 :named("namespace"), "package" :named("scope"))
    $P3767 = $P3755."new"($P3759, $P3761, $P3766, "callmethod" :named("pasttype"), "add_role" :named("name"))
.annotate 'line', 1247
    $P3768 = $P3754."push"($P3767)
.annotate 'line', 1244
    .return ($P3768)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<my>"  :subid("474_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_3790
    .param pmc param_3791
.annotate 'line', 1277
    .lex "self", param_3790
    .lex "$/", param_3791
    find_lex $P3792, "$/"
    find_lex $P3793, "$/"
    unless_null $P3793, vivify_1680
    $P3793 = root_new ['parrot';'Hash']
  vivify_1680:
    set $P3794, $P3793["scoped"]
    unless_null $P3794, vivify_1681
    new $P3794, "Undef"
  vivify_1681:
    $P3795 = $P3794."ast"()
    $P3796 = $P3792."!make"($P3795)
    .return ($P3796)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<our>"  :subid("475_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_3798
    .param pmc param_3799
.annotate 'line', 1278
    .lex "self", param_3798
    .lex "$/", param_3799
    find_lex $P3800, "$/"
    find_lex $P3801, "$/"
    unless_null $P3801, vivify_1682
    $P3801 = root_new ['parrot';'Hash']
  vivify_1682:
    set $P3802, $P3801["scoped"]
    unless_null $P3802, vivify_1683
    new $P3802, "Undef"
  vivify_1683:
    $P3803 = $P3802."ast"()
    $P3804 = $P3800."!make"($P3803)
    .return ($P3804)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<has>"  :subid("476_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_3806
    .param pmc param_3807
.annotate 'line', 1279
    .lex "self", param_3806
    .lex "$/", param_3807
    find_lex $P3808, "$/"
    find_lex $P3809, "$/"
    unless_null $P3809, vivify_1684
    $P3809 = root_new ['parrot';'Hash']
  vivify_1684:
    set $P3810, $P3809["scoped"]
    unless_null $P3810, vivify_1685
    new $P3810, "Undef"
  vivify_1685:
    $P3811 = $P3810."ast"()
    $P3812 = $P3808."!make"($P3811)
    .return ($P3812)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scoped"  :subid("477_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_3814
    .param pmc param_3815
.annotate 'line', 1281
    .lex "self", param_3814
    .lex "$/", param_3815
.annotate 'line', 1282
    find_lex $P3816, "$/"
    find_lex $P3819, "$/"
    unless_null $P3819, vivify_1686
    $P3819 = root_new ['parrot';'Hash']
  vivify_1686:
    set $P3820, $P3819["declarator"]
    unless_null $P3820, vivify_1687
    new $P3820, "Undef"
  vivify_1687:
    if $P3820, if_3818
.annotate 'line', 1283
    find_lex $P3826, "$/"
    unless_null $P3826, vivify_1688
    $P3826 = root_new ['parrot';'Hash']
  vivify_1688:
    set $P3827, $P3826["multi_declarator"]
    unless_null $P3827, vivify_1689
    new $P3827, "Undef"
  vivify_1689:
    if $P3827, if_3825
.annotate 'line', 1284
    find_lex $P3831, "$/"
    unless_null $P3831, vivify_1690
    $P3831 = root_new ['parrot';'Hash']
  vivify_1690:
    set $P3832, $P3831["package_declarator"]
    unless_null $P3832, vivify_1691
    new $P3832, "Undef"
  vivify_1691:
    $P3833 = $P3832."ast"()
    set $P3824, $P3833
.annotate 'line', 1283
    goto if_3825_end
  if_3825:
    find_lex $P3828, "$/"
    unless_null $P3828, vivify_1692
    $P3828 = root_new ['parrot';'Hash']
  vivify_1692:
    set $P3829, $P3828["multi_declarator"]
    unless_null $P3829, vivify_1693
    new $P3829, "Undef"
  vivify_1693:
    $P3830 = $P3829."ast"()
    set $P3824, $P3830
  if_3825_end:
    set $P3817, $P3824
.annotate 'line', 1282
    goto if_3818_end
  if_3818:
    find_lex $P3821, "$/"
    unless_null $P3821, vivify_1694
    $P3821 = root_new ['parrot';'Hash']
  vivify_1694:
    set $P3822, $P3821["declarator"]
    unless_null $P3822, vivify_1695
    new $P3822, "Undef"
  vivify_1695:
    $P3823 = $P3822."ast"()
    set $P3817, $P3823
  if_3818_end:
    $P3834 = $P3816."!make"($P3817)
.annotate 'line', 1281
    .return ($P3834)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "declarator"  :subid("478_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_3836
    .param pmc param_3837
.annotate 'line', 1287
    .lex "self", param_3836
    .lex "$/", param_3837
.annotate 'line', 1288
    find_lex $P3838, "$/"
.annotate 'line', 1289
    find_lex $P3841, "$/"
    unless_null $P3841, vivify_1696
    $P3841 = root_new ['parrot';'Hash']
  vivify_1696:
    set $P3842, $P3841["routine_declarator"]
    unless_null $P3842, vivify_1697
    new $P3842, "Undef"
  vivify_1697:
    if $P3842, if_3840
.annotate 'line', 1290
    find_lex $P3846, "$/"
    unless_null $P3846, vivify_1698
    $P3846 = root_new ['parrot';'Hash']
  vivify_1698:
    set $P3847, $P3846["variable_declarator"]
    unless_null $P3847, vivify_1699
    new $P3847, "Undef"
  vivify_1699:
    $P3848 = $P3847."ast"()
    set $P3839, $P3848
.annotate 'line', 1289
    goto if_3840_end
  if_3840:
    find_lex $P3843, "$/"
    unless_null $P3843, vivify_1700
    $P3843 = root_new ['parrot';'Hash']
  vivify_1700:
    set $P3844, $P3843["routine_declarator"]
    unless_null $P3844, vivify_1701
    new $P3844, "Undef"
  vivify_1701:
    $P3845 = $P3844."ast"()
    set $P3839, $P3845
  if_3840_end:
    $P3849 = $P3838."!make"($P3839)
.annotate 'line', 1287
    .return ($P3849)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<multi>"  :subid("479_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_3851
    .param pmc param_3852
.annotate 'line', 1293
    .lex "self", param_3851
    .lex "$/", param_3852
    find_lex $P3853, "$/"
    find_lex $P3856, "$/"
    unless_null $P3856, vivify_1702
    $P3856 = root_new ['parrot';'Hash']
  vivify_1702:
    set $P3857, $P3856["declarator"]
    unless_null $P3857, vivify_1703
    new $P3857, "Undef"
  vivify_1703:
    if $P3857, if_3855
    find_lex $P3861, "$/"
    unless_null $P3861, vivify_1704
    $P3861 = root_new ['parrot';'Hash']
  vivify_1704:
    set $P3862, $P3861["routine_def"]
    unless_null $P3862, vivify_1705
    new $P3862, "Undef"
  vivify_1705:
    $P3863 = $P3862."ast"()
    set $P3854, $P3863
    goto if_3855_end
  if_3855:
    find_lex $P3858, "$/"
    unless_null $P3858, vivify_1706
    $P3858 = root_new ['parrot';'Hash']
  vivify_1706:
    set $P3859, $P3858["declarator"]
    unless_null $P3859, vivify_1707
    new $P3859, "Undef"
  vivify_1707:
    $P3860 = $P3859."ast"()
    set $P3854, $P3860
  if_3855_end:
    $P3864 = $P3853."!make"($P3854)
    .return ($P3864)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<proto>"  :subid("480_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_3866
    .param pmc param_3867
.annotate 'line', 1294
    .lex "self", param_3866
    .lex "$/", param_3867
    find_lex $P3868, "$/"
    find_lex $P3871, "$/"
    unless_null $P3871, vivify_1708
    $P3871 = root_new ['parrot';'Hash']
  vivify_1708:
    set $P3872, $P3871["declarator"]
    unless_null $P3872, vivify_1709
    new $P3872, "Undef"
  vivify_1709:
    if $P3872, if_3870
    find_lex $P3876, "$/"
    unless_null $P3876, vivify_1710
    $P3876 = root_new ['parrot';'Hash']
  vivify_1710:
    set $P3877, $P3876["routine_def"]
    unless_null $P3877, vivify_1711
    new $P3877, "Undef"
  vivify_1711:
    $P3878 = $P3877."ast"()
    set $P3869, $P3878
    goto if_3870_end
  if_3870:
    find_lex $P3873, "$/"
    unless_null $P3873, vivify_1712
    $P3873 = root_new ['parrot';'Hash']
  vivify_1712:
    set $P3874, $P3873["declarator"]
    unless_null $P3874, vivify_1713
    new $P3874, "Undef"
  vivify_1713:
    $P3875 = $P3874."ast"()
    set $P3869, $P3875
  if_3870_end:
    $P3879 = $P3868."!make"($P3869)
    .return ($P3879)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<null>"  :subid("481_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_3881
    .param pmc param_3882
.annotate 'line', 1295
    .lex "self", param_3881
    .lex "$/", param_3882
    find_lex $P3883, "$/"
    find_lex $P3884, "$/"
    unless_null $P3884, vivify_1714
    $P3884 = root_new ['parrot';'Hash']
  vivify_1714:
    set $P3885, $P3884["declarator"]
    unless_null $P3885, vivify_1715
    new $P3885, "Undef"
  vivify_1715:
    $P3886 = $P3885."ast"()
    $P3887 = $P3883."!make"($P3886)
    .return ($P3887)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "variable_declarator"  :subid("482_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_3889
    .param pmc param_3890
.annotate 'line', 1298
    .const 'Sub' $P3962 = "485_1300062003.824" 
    capture_lex $P3962
    .const 'Sub' $P3917 = "483_1300062003.824" 
    capture_lex $P3917
    .lex "self", param_3889
    .lex "$/", param_3890
.annotate 'line', 1299
    new $P3891, "Undef"
    .lex "$past", $P3891
.annotate 'line', 1300
    new $P3892, "Undef"
    .lex "$sigil", $P3892
.annotate 'line', 1301
    new $P3893, "Undef"
    .lex "$name", $P3893
.annotate 'line', 1302
    new $P3894, "Undef"
    .lex "$BLOCK", $P3894
.annotate 'line', 1299
    find_lex $P3895, "$/"
    unless_null $P3895, vivify_1716
    $P3895 = root_new ['parrot';'Hash']
  vivify_1716:
    set $P3896, $P3895["variable"]
    unless_null $P3896, vivify_1717
    new $P3896, "Undef"
  vivify_1717:
    $P3897 = $P3896."ast"()
    store_lex "$past", $P3897
.annotate 'line', 1300
    find_lex $P3898, "$/"
    unless_null $P3898, vivify_1718
    $P3898 = root_new ['parrot';'Hash']
  vivify_1718:
    set $P3899, $P3898["variable"]
    unless_null $P3899, vivify_1719
    $P3899 = root_new ['parrot';'Hash']
  vivify_1719:
    set $P3900, $P3899["sigil"]
    unless_null $P3900, vivify_1720
    new $P3900, "Undef"
  vivify_1720:
    store_lex "$sigil", $P3900
.annotate 'line', 1301
    find_lex $P3901, "$past"
    $P3902 = $P3901."name"()
    store_lex "$name", $P3902
.annotate 'line', 1302
    get_global $P3903, "@BLOCK"
    unless_null $P3903, vivify_1721
    $P3903 = root_new ['parrot';'ResizablePMCArray']
  vivify_1721:
    set $P3904, $P3903[0]
    unless_null $P3904, vivify_1722
    new $P3904, "Undef"
  vivify_1722:
    store_lex "$BLOCK", $P3904
.annotate 'line', 1303
    find_lex $P3906, "$BLOCK"
    find_lex $P3907, "$name"
    $P3908 = $P3906."symbol"($P3907)
    unless $P3908, if_3905_end
.annotate 'line', 1304
    find_lex $P3909, "$/"
    $P3910 = $P3909."CURSOR"()
    find_lex $P3911, "$name"
    $P3910."panic"("Redeclaration of symbol ", $P3911)
  if_3905_end:
.annotate 'line', 1306
    find_dynamic_lex $P3913, "$*SCOPE"
    unless_null $P3913, vivify_1723
    get_hll_global $P3913, "$SCOPE"
    unless_null $P3913, vivify_1724
    die "Contextual $*SCOPE not found"
  vivify_1724:
  vivify_1723:
    set $S3914, $P3913
    iseq $I3915, $S3914, "has"
    if $I3915, if_3912
.annotate 'line', 1331
    .const 'Sub' $P3962 = "485_1300062003.824" 
    capture_lex $P3962
    $P3962()
    goto if_3912_end
  if_3912:
.annotate 'line', 1306
    .const 'Sub' $P3917 = "483_1300062003.824" 
    capture_lex $P3917
    $P3917()
  if_3912_end:
.annotate 'line', 1339
    find_lex $P3986, "$/"
    find_lex $P3987, "$past"
    $P3988 = $P3986."!make"($P3987)
.annotate 'line', 1298
    .return ($P3988)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3961"  :anon :subid("485_1300062003.824") :outer("482_1300062003.824")
.annotate 'line', 1332
    new $P3963, "Undef"
    .lex "$scope", $P3963
.annotate 'line', 1333
    new $P3964, "Undef"
    .lex "$decl", $P3964
.annotate 'line', 1332
    find_dynamic_lex $P3967, "$*SCOPE"
    unless_null $P3967, vivify_1725
    get_hll_global $P3967, "$SCOPE"
    unless_null $P3967, vivify_1726
    die "Contextual $*SCOPE not found"
  vivify_1726:
  vivify_1725:
    set $S3968, $P3967
    iseq $I3969, $S3968, "our"
    if $I3969, if_3966
    new $P3971, "String"
    assign $P3971, "lexical"
    set $P3965, $P3971
    goto if_3966_end
  if_3966:
    new $P3970, "String"
    assign $P3970, "package"
    set $P3965, $P3970
  if_3966_end:
    store_lex "$scope", $P3965
.annotate 'line', 1333
    get_hll_global $P3972, ["PAST"], "Var"
    find_lex $P3973, "$name"
    find_lex $P3974, "$scope"
.annotate 'line', 1334
    find_lex $P3975, "$sigil"
    $P3976 = "vivitype"($P3975)
    find_lex $P3977, "$/"
    $P3978 = $P3972."new"($P3973 :named("name"), $P3974 :named("scope"), 1 :named("isdecl"), 1 :named("lvalue"), $P3976 :named("viviself"), $P3977 :named("node"))
.annotate 'line', 1333
    store_lex "$decl", $P3978
.annotate 'line', 1336
    find_lex $P3979, "$BLOCK"
    find_lex $P3980, "$name"
    find_lex $P3981, "$scope"
    $P3979."symbol"($P3980, $P3981 :named("scope"))
.annotate 'line', 1337
    find_lex $P3982, "$BLOCK"
    unless_null $P3982, vivify_1727
    $P3982 = root_new ['parrot';'ResizablePMCArray']
  vivify_1727:
    set $P3983, $P3982[0]
    unless_null $P3983, vivify_1728
    new $P3983, "Undef"
  vivify_1728:
    find_lex $P3984, "$decl"
    $P3985 = $P3983."push"($P3984)
.annotate 'line', 1331
    .return ($P3985)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3916"  :anon :subid("483_1300062003.824") :outer("482_1300062003.824")
.annotate 'line', 1306
    .const 'Sub' $P3947 = "484_1300062003.824" 
    capture_lex $P3947
.annotate 'line', 1308
    new $P3918, "Undef"
    .lex "$meta-attr-type", $P3918
.annotate 'line', 1316
    new $P3919, "Undef"
    .lex "$meta_args", $P3919
.annotate 'line', 1308
    find_dynamic_lex $P3922, "$*PKGDECL"
    unless_null $P3922, vivify_1729
    get_hll_global $P3922, "$PKGDECL"
    unless_null $P3922, vivify_1730
    die "Contextual $*PKGDECL not found"
  vivify_1730:
  vivify_1729:
    find_dynamic_lex $P3923, "%*HOW-METAATTR"
    unless_null $P3923, vivify_1731
    get_hll_global $P3923, "%HOW-METAATTR"
    unless_null $P3923, vivify_1732
    die "Contextual %*HOW-METAATTR not found"
  vivify_1732:
  vivify_1731:
    set $P3924, $P3923[$P3922]
    unless_null $P3924, vivify_1733
    new $P3924, "Undef"
  vivify_1733:
    unless $P3924, unless_3921
    set $P3920, $P3924
    goto unless_3921_end
  unless_3921:
    find_dynamic_lex $P3925, "$*DEFAULT-METAATTR"
    unless_null $P3925, vivify_1734
    get_hll_global $P3925, "$DEFAULT-METAATTR"
    unless_null $P3925, vivify_1735
    die "Contextual $*DEFAULT-METAATTR not found"
  vivify_1735:
  vivify_1734:
    set $P3920, $P3925
  unless_3921_end:
    store_lex "$meta-attr-type", $P3920
.annotate 'line', 1309
    find_dynamic_lex $P3926, "$*PACKAGE-SETUP"
    unless_null $P3926, vivify_1736
    get_hll_global $P3926, "$PACKAGE-SETUP"
    unless_null $P3926, vivify_1737
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1737:
  vivify_1736:
    get_hll_global $P3927, ["PAST"], "Op"
.annotate 'line', 1311
    get_hll_global $P3928, ["PAST"], "Op"
.annotate 'line', 1313
    get_hll_global $P3929, ["PAST"], "Var"
    $P3930 = $P3929."new"("type_obj" :named("name"), "register" :named("scope"))
    $P3931 = $P3928."new"($P3930, "get_how PP" :named("pirop"))
.annotate 'line', 1315
    get_hll_global $P3932, ["PAST"], "Var"
    $P3933 = $P3932."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1316
    get_hll_global $P3934, ["PAST"], "Op"
.annotate 'line', 1318
    get_hll_global $P3935, ["PAST"], "Var"
    find_lex $P3936, "$meta-attr-type"
    $P3937 = $P3935."new"($P3936 :named("name"), "" :named("namespace"), "package" :named("scope"))
.annotate 'line', 1319
    get_hll_global $P3938, ["PAST"], "Val"
    find_lex $P3939, "$name"
    $P3940 = $P3938."new"($P3939 :named("value"), "name" :named("named"))
    $P3941 = $P3934."new"($P3937, $P3940, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 1316
    store_lex "$meta_args", $P3941
    $P3942 = $P3927."new"($P3931, $P3933, $P3941, "callmethod" :named("pasttype"), "add_attribute" :named("name"))
.annotate 'line', 1309
    $P3926."push"($P3942)
.annotate 'line', 1322
    find_lex $P3944, "$/"
    unless_null $P3944, vivify_1738
    $P3944 = root_new ['parrot';'Hash']
  vivify_1738:
    set $P3945, $P3944["typename"]
    unless_null $P3945, vivify_1739
    new $P3945, "Undef"
  vivify_1739:
    unless $P3945, if_3943_end
    .const 'Sub' $P3947 = "484_1300062003.824" 
    capture_lex $P3947
    $P3947()
  if_3943_end:
.annotate 'line', 1328
    find_lex $P3957, "$BLOCK"
    find_lex $P3958, "$name"
    $P3957."symbol"($P3958, "attribute" :named("scope"))
.annotate 'line', 1329
    get_hll_global $P3959, ["PAST"], "Stmts"
    $P3960 = $P3959."new"()
    store_lex "$past", $P3960
.annotate 'line', 1306
    .return ($P3960)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3946"  :anon :subid("484_1300062003.824") :outer("483_1300062003.824")
.annotate 'line', 1323
    new $P3948, "Undef"
    .lex "$type", $P3948
    find_lex $P3949, "$/"
    unless_null $P3949, vivify_1740
    $P3949 = root_new ['parrot';'Hash']
  vivify_1740:
    set $P3950, $P3949["typename"]
    unless_null $P3950, vivify_1741
    $P3950 = root_new ['parrot';'ResizablePMCArray']
  vivify_1741:
    set $P3951, $P3950[0]
    unless_null $P3951, vivify_1742
    new $P3951, "Undef"
  vivify_1742:
    $P3952 = $P3951."ast"()
    store_lex "$type", $P3952
.annotate 'line', 1324
    find_lex $P3953, "$type"
    $P3953."named"("type")
.annotate 'line', 1325
    find_lex $P3954, "$meta_args"
    find_lex $P3955, "$type"
    $P3956 = $P3954."push"($P3955)
.annotate 'line', 1322
    .return ($P3956)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<sub>"  :subid("486_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_3990
    .param pmc param_3991
.annotate 'line', 1342
    .lex "self", param_3990
    .lex "$/", param_3991
    find_lex $P3992, "$/"
    find_lex $P3993, "$/"
    unless_null $P3993, vivify_1743
    $P3993 = root_new ['parrot';'Hash']
  vivify_1743:
    set $P3994, $P3993["routine_def"]
    unless_null $P3994, vivify_1744
    new $P3994, "Undef"
  vivify_1744:
    $P3995 = $P3994."ast"()
    $P3996 = $P3992."!make"($P3995)
    .return ($P3996)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<method>"  :subid("487_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_3998
    .param pmc param_3999
.annotate 'line', 1343
    .lex "self", param_3998
    .lex "$/", param_3999
    find_lex $P4000, "$/"
    find_lex $P4001, "$/"
    unless_null $P4001, vivify_1745
    $P4001 = root_new ['parrot';'Hash']
  vivify_1745:
    set $P4002, $P4001["method_def"]
    unless_null $P4002, vivify_1746
    new $P4002, "Undef"
  vivify_1746:
    $P4003 = $P4002."ast"()
    $P4004 = $P4000."!make"($P4003)
    .return ($P4004)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "routine_def"  :subid("488_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_4006
    .param pmc param_4007
.annotate 'line', 1345
    .const 'Sub' $P4244 = "494_1300062003.824" 
    capture_lex $P4244
    .const 'Sub' $P4027 = "489_1300062003.824" 
    capture_lex $P4027
    .lex "self", param_4006
    .lex "$/", param_4007
.annotate 'line', 1348
    new $P4008, "Undef"
    .lex "$past", $P4008
.annotate 'line', 1359
    new $P4009, "Undef"
    .lex "$block", $P4009
.annotate 'line', 1345
    find_lex $P4010, "$past"
.annotate 'line', 1349
    find_lex $P4012, "$/"
    unless_null $P4012, vivify_1747
    $P4012 = root_new ['parrot';'Hash']
  vivify_1747:
    set $P4013, $P4012["onlystar"]
    unless_null $P4013, vivify_1748
    new $P4013, "Undef"
  vivify_1748:
    if $P4013, if_4011
.annotate 'line', 1353
    find_lex $P4015, "$/"
    unless_null $P4015, vivify_1749
    $P4015 = root_new ['parrot';'Hash']
  vivify_1749:
    set $P4016, $P4015["blockoid"]
    unless_null $P4016, vivify_1750
    new $P4016, "Undef"
  vivify_1750:
    $P4017 = $P4016."ast"()
    store_lex "$past", $P4017
.annotate 'line', 1354
    find_lex $P4018, "$past"
    $P4018."blocktype"("declaration")
.annotate 'line', 1355
    find_dynamic_lex $P4020, "$*RETURN_USED"
    unless_null $P4020, vivify_1751
    get_hll_global $P4020, "$RETURN_USED"
    unless_null $P4020, vivify_1752
    die "Contextual $*RETURN_USED not found"
  vivify_1752:
  vivify_1751:
    unless $P4020, if_4019_end
.annotate 'line', 1356
    find_lex $P4021, "$past"
    $P4021."control"("return_pir")
  if_4019_end:
.annotate 'line', 1352
    goto if_4011_end
  if_4011:
.annotate 'line', 1350
    $P4014 = "only_star_block"()
    store_lex "$past", $P4014
  if_4011_end:
.annotate 'line', 1359
    find_lex $P4022, "$past"
    store_lex "$block", $P4022
.annotate 'line', 1361
    find_lex $P4024, "$/"
    unless_null $P4024, vivify_1753
    $P4024 = root_new ['parrot';'Hash']
  vivify_1753:
    set $P4025, $P4024["deflongname"]
    unless_null $P4025, vivify_1754
    new $P4025, "Undef"
  vivify_1754:
    unless $P4025, if_4023_end
    .const 'Sub' $P4027 = "489_1300062003.824" 
    capture_lex $P4027
    $P4027()
  if_4023_end:
.annotate 'line', 1466
    find_lex $P4233, "$block"
    find_lex $P4234, "$past"
    unless_null $P4234, vivify_1817
    $P4234 = root_new ['parrot';'Hash']
    store_lex "$past", $P4234
  vivify_1817:
    set $P4234["block_past"], $P4233
.annotate 'line', 1467
    find_lex $P4236, "$/"
    unless_null $P4236, vivify_1818
    $P4236 = root_new ['parrot';'Hash']
  vivify_1818:
    set $P4237, $P4236["trait"]
    unless_null $P4237, vivify_1819
    new $P4237, "Undef"
  vivify_1819:
    unless $P4237, if_4235_end
.annotate 'line', 1468
    find_lex $P4239, "$/"
    unless_null $P4239, vivify_1820
    $P4239 = root_new ['parrot';'Hash']
  vivify_1820:
    set $P4240, $P4239["trait"]
    unless_null $P4240, vivify_1821
    new $P4240, "Undef"
  vivify_1821:
    defined $I4241, $P4240
    unless $I4241, for_undef_1822
    iter $P4238, $P4240
    new $P4251, 'ExceptionHandler'
    set_label $P4251, loop4250_handler
    $P4251."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4251
  loop4250_test:
    unless $P4238, loop4250_done
    shift $P4242, $P4238
  loop4250_redo:
    .const 'Sub' $P4244 = "494_1300062003.824" 
    capture_lex $P4244
    $P4244($P4242)
  loop4250_next:
    goto loop4250_test
  loop4250_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4252, exception, 'type'
    eq $P4252, .CONTROL_LOOP_NEXT, loop4250_next
    eq $P4252, .CONTROL_LOOP_REDO, loop4250_redo
  loop4250_done:
    pop_eh 
  for_undef_1822:
  if_4235_end:
.annotate 'line', 1471
    find_lex $P4253, "$/"
    find_lex $P4254, "$past"
    $P4255 = $P4253."!make"($P4254)
.annotate 'line', 1345
    .return ($P4255)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4026"  :anon :subid("489_1300062003.824") :outer("488_1300062003.824")
.annotate 'line', 1361
    .const 'Sub' $P4149 = "493_1300062003.824" 
    capture_lex $P4149
    .const 'Sub' $P4060 = "490_1300062003.824" 
    capture_lex $P4060
.annotate 'line', 1362
    new $P4028, "Undef"
    .lex "$name", $P4028
    find_lex $P4029, "$/"
    unless_null $P4029, vivify_1755
    $P4029 = root_new ['parrot';'Hash']
  vivify_1755:
    set $P4030, $P4029["sigil"]
    unless_null $P4030, vivify_1756
    $P4030 = root_new ['parrot';'ResizablePMCArray']
  vivify_1756:
    set $P4031, $P4030[0]
    unless_null $P4031, vivify_1757
    new $P4031, "Undef"
  vivify_1757:
    set $S4032, $P4031
    new $P4033, 'String'
    set $P4033, $S4032
    find_lex $P4034, "$/"
    unless_null $P4034, vivify_1758
    $P4034 = root_new ['parrot';'Hash']
  vivify_1758:
    set $P4035, $P4034["deflongname"]
    unless_null $P4035, vivify_1759
    $P4035 = root_new ['parrot';'ResizablePMCArray']
  vivify_1759:
    set $P4036, $P4035[0]
    unless_null $P4036, vivify_1760
    new $P4036, "Undef"
  vivify_1760:
    $S4037 = $P4036."ast"()
    concat $P4038, $P4033, $S4037
    store_lex "$name", $P4038
.annotate 'line', 1363
    find_lex $P4039, "$past"
    find_lex $P4040, "$name"
    $P4039."name"($P4040)
.annotate 'line', 1364
    find_dynamic_lex $P4046, "$*SCOPE"
    unless_null $P4046, vivify_1761
    get_hll_global $P4046, "$SCOPE"
    unless_null $P4046, vivify_1762
    die "Contextual $*SCOPE not found"
  vivify_1762:
  vivify_1761:
    set $S4047, $P4046
    iseq $I4048, $S4047, ""
    unless $I4048, unless_4045
    new $P4044, 'Integer'
    set $P4044, $I4048
    goto unless_4045_end
  unless_4045:
    find_dynamic_lex $P4049, "$*SCOPE"
    unless_null $P4049, vivify_1763
    get_hll_global $P4049, "$SCOPE"
    unless_null $P4049, vivify_1764
    die "Contextual $*SCOPE not found"
  vivify_1764:
  vivify_1763:
    set $S4050, $P4049
    iseq $I4051, $S4050, "my"
    new $P4044, 'Integer'
    set $P4044, $I4051
  unless_4045_end:
    unless $P4044, unless_4043
    set $P4042, $P4044
    goto unless_4043_end
  unless_4043:
    find_dynamic_lex $P4052, "$*SCOPE"
    unless_null $P4052, vivify_1765
    get_hll_global $P4052, "$SCOPE"
    unless_null $P4052, vivify_1766
    die "Contextual $*SCOPE not found"
  vivify_1766:
  vivify_1765:
    set $S4053, $P4052
    iseq $I4054, $S4053, "our"
    new $P4042, 'Integer'
    set $P4042, $I4054
  unless_4043_end:
    if $P4042, if_4041
.annotate 'line', 1456
    find_lex $P4218, "$/"
    $P4219 = $P4218."CURSOR"()
    find_dynamic_lex $P4220, "$*SCOPE"
    unless_null $P4220, vivify_1767
    get_hll_global $P4220, "$SCOPE"
    unless_null $P4220, vivify_1768
    die "Contextual $*SCOPE not found"
  vivify_1768:
  vivify_1767:
    concat $P4221, $P4220, " scoped routines are not supported yet"
    $P4219."panic"($P4221)
.annotate 'line', 1455
    goto if_4041_end
  if_4041:
.annotate 'line', 1365
    find_dynamic_lex $P4056, "$*MULTINESS"
    unless_null $P4056, vivify_1769
    get_hll_global $P4056, "$MULTINESS"
    unless_null $P4056, vivify_1770
    die "Contextual $*MULTINESS not found"
  vivify_1770:
  vivify_1769:
    set $S4057, $P4056
    iseq $I4058, $S4057, "multi"
    if $I4058, if_4055
.annotate 'line', 1416
    find_dynamic_lex $P4145, "$*MULTINESS"
    unless_null $P4145, vivify_1771
    get_hll_global $P4145, "$MULTINESS"
    unless_null $P4145, vivify_1772
    die "Contextual $*MULTINESS not found"
  vivify_1772:
  vivify_1771:
    set $S4146, $P4145
    iseq $I4147, $S4146, "proto"
    if $I4147, if_4144
.annotate 'line', 1435
    get_global $P4179, "@BLOCK"
    unless_null $P4179, vivify_1773
    $P4179 = root_new ['parrot';'ResizablePMCArray']
  vivify_1773:
    set $P4180, $P4179[0]
    unless_null $P4180, vivify_1774
    $P4180 = root_new ['parrot';'ResizablePMCArray']
  vivify_1774:
    set $P4181, $P4180[0]
    unless_null $P4181, vivify_1775
    new $P4181, "Undef"
  vivify_1775:
    get_hll_global $P4182, ["PAST"], "Var"
    find_lex $P4183, "$name"
    find_lex $P4184, "$past"
    $P4185 = $P4182."new"($P4183 :named("name"), 1 :named("isdecl"), $P4184 :named("viviself"), "lexical" :named("scope"))
    $P4181."push"($P4185)
.annotate 'line', 1437
    get_global $P4186, "@BLOCK"
    unless_null $P4186, vivify_1776
    $P4186 = root_new ['parrot';'ResizablePMCArray']
  vivify_1776:
    set $P4187, $P4186[0]
    unless_null $P4187, vivify_1777
    new $P4187, "Undef"
  vivify_1777:
    find_lex $P4188, "$name"
    $P4187."symbol"($P4188, "lexical" :named("scope"))
.annotate 'line', 1438
    find_dynamic_lex $P4190, "$*SCOPE"
    unless_null $P4190, vivify_1778
    get_hll_global $P4190, "$SCOPE"
    unless_null $P4190, vivify_1779
    die "Contextual $*SCOPE not found"
  vivify_1779:
  vivify_1778:
    set $S4191, $P4190
    iseq $I4192, $S4191, "our"
    unless $I4192, if_4189_end
.annotate 'line', 1441
    get_global $P4193, "@BLOCK"
    unless_null $P4193, vivify_1780
    $P4193 = root_new ['parrot';'ResizablePMCArray']
  vivify_1780:
    set $P4194, $P4193[0]
    unless_null $P4194, vivify_1781
    $P4194 = root_new ['parrot';'ResizablePMCArray']
  vivify_1781:
    set $P4195, $P4194[0]
    unless_null $P4195, vivify_1782
    new $P4195, "Undef"
  vivify_1782:
    get_hll_global $P4196, ["PAST"], "Op"
.annotate 'line', 1443
    get_hll_global $P4197, ["PAST"], "Var"
    find_lex $P4198, "$name"
    $P4199 = $P4197."new"($P4198 :named("name"), "package" :named("scope"))
.annotate 'line', 1444
    get_hll_global $P4200, ["PAST"], "Var"
    find_lex $P4201, "$name"
    $P4202 = $P4200."new"($P4201 :named("name"), "lexical" :named("scope"))
    $P4203 = $P4196."new"($P4199, $P4202, "bind" :named("pasttype"))
.annotate 'line', 1441
    $P4195."push"($P4203)
.annotate 'line', 1446
    get_global $P4204, "@BLOCK"
    unless_null $P4204, vivify_1783
    $P4204 = root_new ['parrot';'ResizablePMCArray']
  vivify_1783:
    set $P4205, $P4204[0]
    unless_null $P4205, vivify_1784
    new $P4205, "Undef"
  vivify_1784:
    $P4206 = $P4205."loadinit"()
    get_hll_global $P4207, ["PAST"], "Op"
.annotate 'line', 1448
    get_hll_global $P4208, ["PAST"], "Var"
    find_lex $P4209, "$name"
    $P4210 = $P4208."new"($P4209 :named("name"), "package" :named("scope"))
.annotate 'line', 1449
    get_hll_global $P4211, ["PAST"], "Val"
    find_lex $P4212, "$past"
    $P4213 = $P4211."new"($P4212 :named("value"))
    $P4214 = $P4207."new"($P4210, $P4213, "bind" :named("pasttype"))
.annotate 'line', 1446
    $P4206."push"($P4214)
  if_4189_end:
.annotate 'line', 1434
    goto if_4144_end
  if_4144:
.annotate 'line', 1416
    .const 'Sub' $P4149 = "493_1300062003.824" 
    capture_lex $P4149
    $P4149()
  if_4144_end:
    goto if_4055_end
  if_4055:
.annotate 'line', 1365
    .const 'Sub' $P4060 = "490_1300062003.824" 
    capture_lex $P4060
    $P4060()
  if_4055_end:
.annotate 'line', 1453
    get_hll_global $P4215, ["PAST"], "Var"
    find_lex $P4216, "$name"
    $P4217 = $P4215."new"($P4216 :named("name"))
    store_lex "$past", $P4217
  if_4041_end:
.annotate 'line', 1460
    find_lex $P4226, "$name"
    set $S4227, $P4226
    iseq $I4228, $S4227, "MAIN"
    if $I4228, if_4225
    new $P4224, 'Integer'
    set $P4224, $I4228
    goto if_4225_end
  if_4225:
    find_dynamic_lex $P4229, "$*MULTINESS"
    unless_null $P4229, vivify_1815
    get_hll_global $P4229, "$MULTINESS"
    unless_null $P4229, vivify_1816
    die "Contextual $*MULTINESS not found"
  vivify_1816:
  vivify_1815:
    set $S4230, $P4229
    isne $I4231, $S4230, "multi"
    new $P4224, 'Integer'
    set $P4224, $I4231
  if_4225_end:
    if $P4224, if_4223
    set $P4222, $P4224
    goto if_4223_end
  if_4223:
.annotate 'line', 1461
    find_lex $P4232, "$block"
    store_dynamic_lex "$*MAIN_SUB", $P4232
.annotate 'line', 1460
    set $P4222, $P4232
  if_4223_end:
.annotate 'line', 1361
    .return ($P4222)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4148"  :anon :subid("493_1300062003.824") :outer("489_1300062003.824")
.annotate 'line', 1421
    new $P4150, "Undef"
    .lex "$cholder", $P4150
.annotate 'line', 1420
    find_dynamic_lex $P4152, "$*SCOPE"
    unless_null $P4152, vivify_1785
    get_hll_global $P4152, "$SCOPE"
    unless_null $P4152, vivify_1786
    die "Contextual $*SCOPE not found"
  vivify_1786:
  vivify_1785:
    set $S4153, $P4152
    iseq $I4154, $S4153, "our"
    unless $I4154, if_4151_end
    die "our-scoped protos not yet implemented"
  if_4151_end:
.annotate 'line', 1421
    get_hll_global $P4155, ["PAST"], "Op"
    $P4156 = $P4155."new"("list" :named("pasttype"))
    store_lex "$cholder", $P4156
.annotate 'line', 1422
    get_global $P4157, "@BLOCK"
    unless_null $P4157, vivify_1787
    $P4157 = root_new ['parrot';'ResizablePMCArray']
  vivify_1787:
    set $P4158, $P4157[0]
    unless_null $P4158, vivify_1788
    $P4158 = root_new ['parrot';'ResizablePMCArray']
  vivify_1788:
    set $P4159, $P4158[0]
    unless_null $P4159, vivify_1789
    new $P4159, "Undef"
  vivify_1789:
    get_hll_global $P4160, ["PAST"], "Var"
    find_lex $P4161, "$name"
    find_lex $P4162, "$past"
    $P4163 = $P4160."new"($P4161 :named("name"), 1 :named("isdecl"), $P4162 :named("viviself"), "lexical" :named("scope"))
    $P4159."push"($P4163)
.annotate 'line', 1424
    get_global $P4164, "@BLOCK"
    unless_null $P4164, vivify_1790
    $P4164 = root_new ['parrot';'ResizablePMCArray']
  vivify_1790:
    set $P4165, $P4164[0]
    unless_null $P4165, vivify_1791
    $P4165 = root_new ['parrot';'ResizablePMCArray']
  vivify_1791:
    set $P4166, $P4165[0]
    unless_null $P4166, vivify_1792
    new $P4166, "Undef"
  vivify_1792:
    get_hll_global $P4167, ["PAST"], "Op"
.annotate 'line', 1426
    get_hll_global $P4168, ["PAST"], "Var"
    find_lex $P4169, "$name"
    $P4170 = $P4168."new"($P4169 :named("name"))
    find_lex $P4171, "$cholder"
    $P4172 = $P4167."new"($P4170, $P4171, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 1424
    $P4166."push"($P4172)
.annotate 'line', 1429
    get_global $P4173, "@BLOCK"
    unless_null $P4173, vivify_1793
    $P4173 = root_new ['parrot';'ResizablePMCArray']
  vivify_1793:
    set $P4174, $P4173[0]
    unless_null $P4174, vivify_1794
    new $P4174, "Undef"
  vivify_1794:
    find_lex $P4175, "$name"
    find_lex $P4176, "$cholder"
    $P4174."symbol"($P4175, "lexical" :named("scope"), 1 :named("proto"), $P4176 :named("cholder"))
.annotate 'line', 1432
    find_lex $P4177, "$past"
    $P4178 = $P4177."pirflags"(":instanceof(\"DispatcherSub\")")
.annotate 'line', 1416
    .return ($P4178)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4059"  :anon :subid("490_1300062003.824") :outer("489_1300062003.824")
.annotate 'line', 1365
    .const 'Sub' $P4078 = "491_1300062003.824" 
    capture_lex $P4078
.annotate 'line', 1368
    new $P4061, "Undef"
    .lex "$cholder", $P4061
.annotate 'line', 1369
    $P4062 = root_new ['parrot';'Hash']
    .lex "%sym", $P4062
.annotate 'line', 1367
    find_dynamic_lex $P4064, "$*SCOPE"
    unless_null $P4064, vivify_1795
    get_hll_global $P4064, "$SCOPE"
    unless_null $P4064, vivify_1796
    die "Contextual $*SCOPE not found"
  vivify_1796:
  vivify_1795:
    set $S4065, $P4064
    iseq $I4066, $S4065, "our"
    unless $I4066, if_4063_end
    die "our-scoped multis not yet implemented"
  if_4063_end:
    find_lex $P4067, "$cholder"
.annotate 'line', 1369
    get_global $P4068, "@BLOCK"
    unless_null $P4068, vivify_1797
    $P4068 = root_new ['parrot';'ResizablePMCArray']
  vivify_1797:
    set $P4069, $P4068[0]
    unless_null $P4069, vivify_1798
    new $P4069, "Undef"
  vivify_1798:
    find_lex $P4070, "$name"
    $P4071 = $P4069."symbol"($P4070)
    store_lex "%sym", $P4071
.annotate 'line', 1370
    find_lex $P4073, "%sym"
    unless_null $P4073, vivify_1799
    $P4073 = root_new ['parrot';'Hash']
  vivify_1799:
    set $P4074, $P4073["cholder"]
    unless_null $P4074, vivify_1800
    new $P4074, "Undef"
  vivify_1800:
    if $P4074, if_4072
.annotate 'line', 1375
    .const 'Sub' $P4078 = "491_1300062003.824" 
    capture_lex $P4078
    $P4078()
    goto if_4072_end
  if_4072:
.annotate 'line', 1371
    find_lex $P4075, "%sym"
    unless_null $P4075, vivify_1813
    $P4075 = root_new ['parrot';'Hash']
  vivify_1813:
    set $P4076, $P4075["cholder"]
    unless_null $P4076, vivify_1814
    new $P4076, "Undef"
  vivify_1814:
    store_lex "$cholder", $P4076
  if_4072_end:
.annotate 'line', 1411
    find_lex $P4140, "$cholder"
    find_lex $P4141, "$past"
    $P4140."push"($P4141)
.annotate 'line', 1414
    find_lex $P4142, "$past"
    $P4143 = "attach_multi_signature"($P4142)
.annotate 'line', 1365
    .return ($P4143)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block4077"  :anon :subid("491_1300062003.824") :outer("490_1300062003.824")
.annotate 'line', 1375
    .const 'Sub' $P4092 = "492_1300062003.824" 
    capture_lex $P4092
.annotate 'line', 1382
    new $P4079, "Undef"
    .lex "$found_proto", $P4079
.annotate 'line', 1400
    new $P4080, "Undef"
    .lex "$dispatch_setup", $P4080
.annotate 'line', 1377
    find_lex $P4082, "%sym"
    unless_null $P4082, vivify_1801
    $P4082 = root_new ['parrot';'Hash']
  vivify_1801:
    set $P4083, $P4082["proto"]
    unless_null $P4083, vivify_1802
    new $P4083, "Undef"
  vivify_1802:
    unless $P4083, if_4081_end
.annotate 'line', 1380
    find_lex $P4084, "$/"
    $P4085 = $P4084."CURSOR"()
    $P4085."panic"("Internal Error: Current scope has a proto, but no candidate list holder was set up. (This should never happen.)")
  if_4081_end:
.annotate 'line', 1377
    find_lex $P4086, "$found_proto"
.annotate 'line', 1383
    get_global $P4088, "@BLOCK"
    defined $I4089, $P4088
    unless $I4089, for_undef_1803
    iter $P4087, $P4088
    new $P4114, 'ExceptionHandler'
    set_label $P4114, loop4113_handler
    $P4114."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4114
  loop4113_test:
    unless $P4087, loop4113_done
    shift $P4090, $P4087
  loop4113_redo:
    .const 'Sub' $P4092 = "492_1300062003.824" 
    capture_lex $P4092
    $P4092($P4090)
  loop4113_next:
    goto loop4113_test
  loop4113_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4115, exception, 'type'
    eq $P4115, .CONTROL_LOOP_NEXT, loop4113_next
    eq $P4115, .CONTROL_LOOP_REDO, loop4113_redo
  loop4113_done:
    pop_eh 
  for_undef_1803:
.annotate 'line', 1394
    find_lex $P4117, "$found_proto"
    if $P4117, unless_4116_end
.annotate 'line', 1395
    find_lex $P4118, "$/"
    $P4119 = $P4118."CURSOR"()
    $P4119."panic"("Sorry, no proto sub in scope, and auto-generation of protos is not yet implemented.")
  unless_4116_end:
.annotate 'line', 1399
    get_hll_global $P4120, ["PAST"], "Op"
    $P4121 = $P4120."new"("list" :named("pasttype"))
    store_lex "$cholder", $P4121
.annotate 'line', 1400
    get_hll_global $P4122, ["PAST"], "Op"
.annotate 'line', 1402
    get_hll_global $P4123, ["PAST"], "Var"
    find_lex $P4124, "$name"
    $P4125 = $P4123."new"($P4124 :named("name"), "outer" :named("scope"))
    find_lex $P4126, "$cholder"
    $P4127 = $P4122."new"($P4125, $P4126, "create_dispatch_and_add_candidates PPP" :named("pirop"))
.annotate 'line', 1400
    store_lex "$dispatch_setup", $P4127
.annotate 'line', 1405
    get_global $P4128, "@BLOCK"
    unless_null $P4128, vivify_1808
    $P4128 = root_new ['parrot';'ResizablePMCArray']
  vivify_1808:
    set $P4129, $P4128[0]
    unless_null $P4129, vivify_1809
    $P4129 = root_new ['parrot';'ResizablePMCArray']
  vivify_1809:
    set $P4130, $P4129[0]
    unless_null $P4130, vivify_1810
    new $P4130, "Undef"
  vivify_1810:
    get_hll_global $P4131, ["PAST"], "Var"
    find_lex $P4132, "$name"
    find_lex $P4133, "$dispatch_setup"
    $P4134 = $P4131."new"($P4132 :named("name"), 1 :named("isdecl"), $P4133 :named("viviself"), "lexical" :named("scope"))
    $P4130."push"($P4134)
.annotate 'line', 1407
    get_global $P4135, "@BLOCK"
    unless_null $P4135, vivify_1811
    $P4135 = root_new ['parrot';'ResizablePMCArray']
  vivify_1811:
    set $P4136, $P4135[0]
    unless_null $P4136, vivify_1812
    new $P4136, "Undef"
  vivify_1812:
    find_lex $P4137, "$name"
    find_lex $P4138, "$cholder"
    $P4139 = $P4136."symbol"($P4137, "lexical" :named("scope"), $P4138 :named("cholder"))
.annotate 'line', 1375
    .return ($P4139)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4091"  :anon :subid("492_1300062003.824") :outer("491_1300062003.824")
    .param pmc param_4094
.annotate 'line', 1384
    $P4093 = root_new ['parrot';'Hash']
    .lex "%sym", $P4093
    .lex "$_", param_4094
    find_lex $P4095, "$_"
    find_lex $P4096, "$name"
    $P4097 = $P4095."symbol"($P4096)
    store_lex "%sym", $P4097
.annotate 'line', 1385
    find_lex $P4102, "%sym"
    unless_null $P4102, vivify_1804
    $P4102 = root_new ['parrot';'Hash']
  vivify_1804:
    set $P4103, $P4102["proto"]
    unless_null $P4103, vivify_1805
    new $P4103, "Undef"
  vivify_1805:
    unless $P4103, unless_4101
    set $P4100, $P4103
    goto unless_4101_end
  unless_4101:
    find_lex $P4104, "%sym"
    unless_null $P4104, vivify_1806
    $P4104 = root_new ['parrot';'Hash']
  vivify_1806:
    set $P4105, $P4104["cholder"]
    unless_null $P4105, vivify_1807
    new $P4105, "Undef"
  vivify_1807:
    set $P4100, $P4105
  unless_4101_end:
    if $P4100, if_4099
.annotate 'line', 1388
    find_lex $P4109, "%sym"
    if $P4109, if_4108
    set $P4107, $P4109
    goto if_4108_end
  if_4108:
.annotate 'line', 1389
    find_lex $P4110, "$/"
    $P4111 = $P4110."CURSOR"()
    $P4112 = $P4111."panic"("Cannot declare a multi when an only is already in scope.")
.annotate 'line', 1388
    set $P4107, $P4112
  if_4108_end:
    set $P4098, $P4107
.annotate 'line', 1385
    goto if_4099_end
  if_4099:
.annotate 'line', 1386
    new $P4106, "Integer"
    assign $P4106, 1
    store_lex "$found_proto", $P4106
.annotate 'line', 1385
    set $P4098, $P4106
  if_4099_end:
.annotate 'line', 1383
    .return ($P4098)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4243"  :anon :subid("494_1300062003.824") :outer("488_1300062003.824")
    .param pmc param_4245
.annotate 'line', 1468
    .lex "$_", param_4245
    find_lex $P4246, "$_"
    $P4247 = $P4246."ast"()
    find_lex $P4248, "$/"
    $P4249 = $P4247($P4248)
    .return ($P4249)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "method_def"  :subid("495_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_4257
    .param pmc param_4258
.annotate 'line', 1475
    .const 'Sub' $P4370 = "497_1300062003.824" 
    capture_lex $P4370
    .const 'Sub' $P4286 = "496_1300062003.824" 
    capture_lex $P4286
    .lex "self", param_4257
    .lex "$/", param_4258
.annotate 'line', 1478
    new $P4259, "Undef"
    .lex "$past", $P4259
.annotate 'line', 1475
    find_lex $P4260, "$past"
.annotate 'line', 1479
    find_lex $P4262, "$/"
    unless_null $P4262, vivify_1823
    $P4262 = root_new ['parrot';'Hash']
  vivify_1823:
    set $P4263, $P4262["onlystar"]
    unless_null $P4263, vivify_1824
    new $P4263, "Undef"
  vivify_1824:
    if $P4263, if_4261
.annotate 'line', 1483
    find_lex $P4265, "$/"
    unless_null $P4265, vivify_1825
    $P4265 = root_new ['parrot';'Hash']
  vivify_1825:
    set $P4266, $P4265["blockoid"]
    unless_null $P4266, vivify_1826
    new $P4266, "Undef"
  vivify_1826:
    $P4267 = $P4266."ast"()
    store_lex "$past", $P4267
.annotate 'line', 1484
    find_lex $P4268, "$past"
    $P4268."blocktype"("declaration")
.annotate 'line', 1485
    find_dynamic_lex $P4270, "$*RETURN_USED"
    unless_null $P4270, vivify_1827
    get_hll_global $P4270, "$RETURN_USED"
    unless_null $P4270, vivify_1828
    die "Contextual $*RETURN_USED not found"
  vivify_1828:
  vivify_1827:
    unless $P4270, if_4269_end
.annotate 'line', 1486
    find_lex $P4271, "$past"
    $P4271."control"("return_pir")
  if_4269_end:
.annotate 'line', 1482
    goto if_4261_end
  if_4261:
.annotate 'line', 1480
    $P4264 = "only_star_block"()
    store_lex "$past", $P4264
  if_4261_end:
.annotate 'line', 1491
    find_lex $P4273, "$past"
    unless_null $P4273, vivify_1829
    $P4273 = root_new ['parrot';'Hash']
  vivify_1829:
    set $P4274, $P4273["signature_has_invocant"]
    unless_null $P4274, vivify_1830
    new $P4274, "Undef"
  vivify_1830:
    if $P4274, unless_4272_end
.annotate 'line', 1492
    find_lex $P4275, "$past"
    unless_null $P4275, vivify_1831
    $P4275 = root_new ['parrot';'ResizablePMCArray']
  vivify_1831:
    set $P4276, $P4275[0]
    unless_null $P4276, vivify_1832
    new $P4276, "Undef"
  vivify_1832:
    get_hll_global $P4277, ["PAST"], "Var"
.annotate 'line', 1494
    get_hll_global $P4278, ["PAST"], "Var"
    $P4279 = $P4278."new"("$?CLASS" :named("name"))
    $P4280 = $P4277."new"("self" :named("name"), "parameter" :named("scope"), $P4279 :named("multitype"))
.annotate 'line', 1492
    $P4276."unshift"($P4280)
  unless_4272_end:
.annotate 'line', 1497
    find_lex $P4281, "$past"
    $P4281."symbol"("self", "lexical" :named("scope"))
.annotate 'line', 1500
    find_lex $P4283, "$/"
    unless_null $P4283, vivify_1833
    $P4283 = root_new ['parrot';'Hash']
  vivify_1833:
    set $P4284, $P4283["deflongname"]
    unless_null $P4284, vivify_1834
    new $P4284, "Undef"
  vivify_1834:
    unless $P4284, if_4282_end
    .const 'Sub' $P4286 = "496_1300062003.824" 
    capture_lex $P4286
    $P4286()
  if_4282_end:
.annotate 'line', 1535
    find_dynamic_lex $P4352, "$*SCOPE"
    unless_null $P4352, vivify_1852
    get_hll_global $P4352, "$SCOPE"
    unless_null $P4352, vivify_1853
    die "Contextual $*SCOPE not found"
  vivify_1853:
  vivify_1852:
    set $S4353, $P4352
    iseq $I4354, $S4353, "our"
    unless $I4354, if_4351_end
.annotate 'line', 1536
    find_lex $P4355, "$past"
    $P4355."pirflags"(":nsentry")
  if_4351_end:
.annotate 'line', 1540
    find_lex $P4356, "$/"
    find_lex $P4357, "$past"
    $P4356."!make"($P4357)
.annotate 'line', 1541
    find_lex $P4358, "$past"
    find_lex $P4359, "$past"
    unless_null $P4359, vivify_1854
    $P4359 = root_new ['parrot';'Hash']
    store_lex "$past", $P4359
  vivify_1854:
    set $P4359["block_past"], $P4358
.annotate 'line', 1542
    find_lex $P4362, "$/"
    unless_null $P4362, vivify_1855
    $P4362 = root_new ['parrot';'Hash']
  vivify_1855:
    set $P4363, $P4362["trait"]
    unless_null $P4363, vivify_1856
    new $P4363, "Undef"
  vivify_1856:
    if $P4363, if_4361
    set $P4360, $P4363
    goto if_4361_end
  if_4361:
.annotate 'line', 1543
    find_lex $P4365, "$/"
    unless_null $P4365, vivify_1857
    $P4365 = root_new ['parrot';'Hash']
  vivify_1857:
    set $P4366, $P4365["trait"]
    unless_null $P4366, vivify_1858
    new $P4366, "Undef"
  vivify_1858:
    defined $I4367, $P4366
    unless $I4367, for_undef_1859
    iter $P4364, $P4366
    new $P4377, 'ExceptionHandler'
    set_label $P4377, loop4376_handler
    $P4377."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4377
  loop4376_test:
    unless $P4364, loop4376_done
    shift $P4368, $P4364
  loop4376_redo:
    .const 'Sub' $P4370 = "497_1300062003.824" 
    capture_lex $P4370
    $P4370($P4368)
  loop4376_next:
    goto loop4376_test
  loop4376_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4378, exception, 'type'
    eq $P4378, .CONTROL_LOOP_NEXT, loop4376_next
    eq $P4378, .CONTROL_LOOP_REDO, loop4376_redo
  loop4376_done:
    pop_eh 
  for_undef_1859:
.annotate 'line', 1542
    set $P4360, $P4364
  if_4361_end:
.annotate 'line', 1475
    .return ($P4360)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4285"  :anon :subid("496_1300062003.824") :outer("495_1300062003.824")
.annotate 'line', 1502
    new $P4287, "Undef"
    .lex "$name", $P4287
.annotate 'line', 1507
    new $P4288, "Undef"
    .lex "$to_add", $P4288
.annotate 'line', 1502
    find_lex $P4289, "$/"
    unless_null $P4289, vivify_1835
    $P4289 = root_new ['parrot';'Hash']
  vivify_1835:
    set $P4290, $P4289["private"]
    unless_null $P4290, vivify_1836
    new $P4290, "Undef"
  vivify_1836:
    set $S4291, $P4290
    new $P4292, 'String'
    set $P4292, $S4291
    find_lex $P4293, "$/"
    unless_null $P4293, vivify_1837
    $P4293 = root_new ['parrot';'Hash']
  vivify_1837:
    set $P4294, $P4293["deflongname"]
    unless_null $P4294, vivify_1838
    $P4294 = root_new ['parrot';'ResizablePMCArray']
  vivify_1838:
    set $P4295, $P4294[0]
    unless_null $P4295, vivify_1839
    new $P4295, "Undef"
  vivify_1839:
    $P4296 = $P4295."ast"()
    set $S4297, $P4296
    concat $P4298, $P4292, $S4297
    store_lex "$name", $P4298
.annotate 'line', 1503
    find_lex $P4299, "$past"
    find_lex $P4300, "$name"
    $P4299."name"($P4300)
.annotate 'line', 1507
    find_dynamic_lex $P4303, "$*MULTINESS"
    unless_null $P4303, vivify_1840
    get_hll_global $P4303, "$MULTINESS"
    unless_null $P4303, vivify_1841
    die "Contextual $*MULTINESS not found"
  vivify_1841:
  vivify_1840:
    set $S4304, $P4303
    isne $I4305, $S4304, "proto"
    if $I4305, if_4302
.annotate 'line', 1509
    get_hll_global $P4309, ["PAST"], "Op"
.annotate 'line', 1511
    get_hll_global $P4310, ["PAST"], "Val"
    find_lex $P4311, "$past"
    $P4312 = $P4310."new"($P4311 :named("value"))
.annotate 'line', 1512
    get_hll_global $P4313, ["PAST"], "Op"
    $P4314 = $P4313."new"("list" :named("pasttype"))
    $P4315 = $P4309."new"($P4312, $P4314, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 1509
    set $P4301, $P4315
.annotate 'line', 1507
    goto if_4302_end
  if_4302:
.annotate 'line', 1508
    get_hll_global $P4306, ["PAST"], "Val"
    find_lex $P4307, "$past"
    $P4308 = $P4306."new"($P4307 :named("value"))
    set $P4301, $P4308
  if_4302_end:
.annotate 'line', 1507
    store_lex "$to_add", $P4301
.annotate 'line', 1514
    find_dynamic_lex $P4317, "$*MULTINESS"
    unless_null $P4317, vivify_1842
    get_hll_global $P4317, "$MULTINESS"
    unless_null $P4317, vivify_1843
    die "Contextual $*MULTINESS not found"
  vivify_1843:
  vivify_1842:
    set $S4318, $P4317
    iseq $I4319, $S4318, "proto"
    unless $I4319, if_4316_end
    find_lex $P4320, "$past"
    $P4320."pirflags"(":instanceof(\"DispatcherSub\")")
  if_4316_end:
.annotate 'line', 1518
    find_dynamic_lex $P4322, "$*MULTINESS"
    unless_null $P4322, vivify_1844
    get_hll_global $P4322, "$MULTINESS"
    unless_null $P4322, vivify_1845
    die "Contextual $*MULTINESS not found"
  vivify_1845:
  vivify_1844:
    set $S4323, $P4322
    iseq $I4324, $S4323, "multi"
    unless $I4324, if_4321_end
    find_lex $P4325, "$past"
    "attach_multi_signature"($P4325)
  if_4321_end:
.annotate 'line', 1521
    find_dynamic_lex $P4328, "$*PACKAGE-SETUP"
    unless_null $P4328, vivify_1846
    get_hll_global $P4328, "$PACKAGE-SETUP"
    unless_null $P4328, vivify_1847
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1847:
  vivify_1846:
    defined $I4329, $P4328
    if $I4329, if_4327
    new $P4326, 'Integer'
    set $P4326, $I4329
    goto if_4327_end
  if_4327:
.annotate 'line', 1522
    find_dynamic_lex $P4330, "$*PACKAGE-SETUP"
    unless_null $P4330, vivify_1848
    get_hll_global $P4330, "$PACKAGE-SETUP"
    unless_null $P4330, vivify_1849
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1849:
  vivify_1848:
    get_hll_global $P4331, ["PAST"], "Op"
.annotate 'line', 1523
    find_dynamic_lex $P4334, "$*MULTINESS"
    unless_null $P4334, vivify_1850
    get_hll_global $P4334, "$MULTINESS"
    unless_null $P4334, vivify_1851
    die "Contextual $*MULTINESS not found"
  vivify_1851:
  vivify_1850:
    set $S4335, $P4334
    iseq $I4336, $S4335, "multi"
    if $I4336, if_4333
    new $P4338, "String"
    assign $P4338, "add_method"
    set $P4332, $P4338
    goto if_4333_end
  if_4333:
    new $P4337, "String"
    assign $P4337, "add_multi_method"
    set $P4332, $P4337
  if_4333_end:
.annotate 'line', 1524
    get_hll_global $P4339, ["PAST"], "Op"
.annotate 'line', 1527
    get_hll_global $P4340, ["PAST"], "Var"
    $P4341 = $P4340."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4342 = $P4339."new"($P4341, "get_how PP" :named("pirop"))
.annotate 'line', 1529
    get_hll_global $P4343, ["PAST"], "Var"
    $P4344 = $P4343."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1530
    get_hll_global $P4345, ["PAST"], "Val"
    find_lex $P4346, "$name"
    $P4347 = $P4345."new"($P4346 :named("value"))
    find_lex $P4348, "$to_add"
    $P4349 = $P4331."new"($P4342, $P4344, $P4347, $P4348, "callmethod" :named("pasttype"), $P4332 :named("name"))
.annotate 'line', 1522
    $P4350 = $P4330."push"($P4349)
.annotate 'line', 1521
    set $P4326, $P4350
  if_4327_end:
.annotate 'line', 1500
    .return ($P4326)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4369"  :anon :subid("497_1300062003.824") :outer("495_1300062003.824")
    .param pmc param_4371
.annotate 'line', 1543
    .lex "$_", param_4371
    find_lex $P4372, "$_"
    $P4373 = $P4372."ast"()
    find_lex $P4374, "$/"
    $P4375 = $P4373($P4374)
    .return ($P4375)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "signature"  :subid("498_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_4382
    .param pmc param_4383
.annotate 'line', 1575
    .const 'Sub' $P4416 = "500_1300062003.824" 
    capture_lex $P4416
    .const 'Sub' $P4392 = "499_1300062003.824" 
    capture_lex $P4392
    .lex "self", param_4382
    .lex "$/", param_4383
.annotate 'line', 1576
    new $P4384, "Undef"
    .lex "$BLOCKINIT", $P4384
    get_global $P4385, "@BLOCK"
    unless_null $P4385, vivify_1860
    $P4385 = root_new ['parrot';'ResizablePMCArray']
  vivify_1860:
    set $P4386, $P4385[0]
    unless_null $P4386, vivify_1861
    $P4386 = root_new ['parrot';'ResizablePMCArray']
  vivify_1861:
    set $P4387, $P4386[0]
    unless_null $P4387, vivify_1862
    new $P4387, "Undef"
  vivify_1862:
    store_lex "$BLOCKINIT", $P4387
.annotate 'line', 1577
    find_lex $P4389, "$/"
    unless_null $P4389, vivify_1863
    $P4389 = root_new ['parrot';'Hash']
  vivify_1863:
    set $P4390, $P4389["invocant"]
    unless_null $P4390, vivify_1864
    new $P4390, "Undef"
  vivify_1864:
    unless $P4390, if_4388_end
    .const 'Sub' $P4392 = "499_1300062003.824" 
    capture_lex $P4392
    $P4392()
  if_4388_end:
.annotate 'line', 1586
    find_lex $P4411, "$/"
    unless_null $P4411, vivify_1870
    $P4411 = root_new ['parrot';'Hash']
  vivify_1870:
    set $P4412, $P4411["parameter"]
    unless_null $P4412, vivify_1871
    new $P4412, "Undef"
  vivify_1871:
    defined $I4413, $P4412
    unless $I4413, for_undef_1872
    iter $P4410, $P4412
    new $P4423, 'ExceptionHandler'
    set_label $P4423, loop4422_handler
    $P4423."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4423
  loop4422_test:
    unless $P4410, loop4422_done
    shift $P4414, $P4410
  loop4422_redo:
    .const 'Sub' $P4416 = "500_1300062003.824" 
    capture_lex $P4416
    $P4416($P4414)
  loop4422_next:
    goto loop4422_test
  loop4422_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4424, exception, 'type'
    eq $P4424, .CONTROL_LOOP_NEXT, loop4422_next
    eq $P4424, .CONTROL_LOOP_REDO, loop4422_redo
  loop4422_done:
    pop_eh 
  for_undef_1872:
.annotate 'line', 1575
    .return ($P4410)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4391"  :anon :subid("499_1300062003.824") :outer("498_1300062003.824")
.annotate 'line', 1578
    new $P4393, "Undef"
    .lex "$inv", $P4393
    find_lex $P4394, "$/"
    unless_null $P4394, vivify_1865
    $P4394 = root_new ['parrot';'Hash']
  vivify_1865:
    set $P4395, $P4394["invocant"]
    unless_null $P4395, vivify_1866
    $P4395 = root_new ['parrot';'ResizablePMCArray']
  vivify_1866:
    set $P4396, $P4395[0]
    unless_null $P4396, vivify_1867
    new $P4396, "Undef"
  vivify_1867:
    $P4397 = $P4396."ast"()
    store_lex "$inv", $P4397
.annotate 'line', 1579
    find_lex $P4398, "$BLOCKINIT"
    find_lex $P4399, "$inv"
    $P4398."push"($P4399)
.annotate 'line', 1580
    find_lex $P4400, "$BLOCKINIT"
    get_hll_global $P4401, ["PAST"], "Var"
.annotate 'line', 1582
    get_hll_global $P4402, ["PAST"], "Var"
    find_lex $P4403, "$inv"
    $P4404 = $P4403."name"()
    $P4405 = $P4402."new"("lexical" :named("scope"), $P4404 :named("name"))
    $P4406 = $P4401."new"("self" :named("name"), "lexical" :named("scope"), 1 :named("isdecl"), $P4405 :named("viviself"))
.annotate 'line', 1580
    $P4400."push"($P4406)
.annotate 'line', 1584
    new $P4407, "Integer"
    assign $P4407, 1
    get_global $P4408, "@BLOCK"
    unless_null $P4408, vivify_1868
    $P4408 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P4408
  vivify_1868:
    set $P4409, $P4408[0]
    unless_null $P4409, vivify_1869
    $P4409 = root_new ['parrot';'Hash']
    set $P4408[0], $P4409
  vivify_1869:
    set $P4409["signature_has_invocant"], $P4407
.annotate 'line', 1577
    .return ($P4407)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4415"  :anon :subid("500_1300062003.824") :outer("498_1300062003.824")
    .param pmc param_4417
.annotate 'line', 1586
    .lex "$_", param_4417
    find_lex $P4418, "$BLOCKINIT"
    find_lex $P4419, "$_"
    $P4420 = $P4419."ast"()
    $P4421 = $P4418."push"($P4420)
    .return ($P4421)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "parameter"  :subid("501_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_4426
    .param pmc param_4427
.annotate 'line', 1589
    .lex "self", param_4426
    .lex "$/", param_4427
.annotate 'line', 1590
    new $P4428, "Undef"
    .lex "$quant", $P4428
.annotate 'line', 1591
    new $P4429, "Undef"
    .lex "$past", $P4429
.annotate 'line', 1590
    find_lex $P4430, "$/"
    unless_null $P4430, vivify_1873
    $P4430 = root_new ['parrot';'Hash']
  vivify_1873:
    set $P4431, $P4430["quant"]
    unless_null $P4431, vivify_1874
    new $P4431, "Undef"
  vivify_1874:
    store_lex "$quant", $P4431
    find_lex $P4432, "$past"
.annotate 'line', 1592
    find_lex $P4434, "$/"
    unless_null $P4434, vivify_1875
    $P4434 = root_new ['parrot';'Hash']
  vivify_1875:
    set $P4435, $P4434["named_param"]
    unless_null $P4435, vivify_1876
    new $P4435, "Undef"
  vivify_1876:
    if $P4435, if_4433
.annotate 'line', 1599
    find_lex $P4449, "$/"
    unless_null $P4449, vivify_1877
    $P4449 = root_new ['parrot';'Hash']
  vivify_1877:
    set $P4450, $P4449["param_var"]
    unless_null $P4450, vivify_1878
    new $P4450, "Undef"
  vivify_1878:
    $P4451 = $P4450."ast"()
    store_lex "$past", $P4451
.annotate 'line', 1600
    find_lex $P4453, "$quant"
    set $S4454, $P4453
    iseq $I4455, $S4454, "*"
    if $I4455, if_4452
.annotate 'line', 1604
    find_lex $P4464, "$quant"
    set $S4465, $P4464
    iseq $I4466, $S4465, "?"
    unless $I4466, if_4463_end
.annotate 'line', 1605
    find_lex $P4467, "$past"
    find_lex $P4468, "$/"
    unless_null $P4468, vivify_1879
    $P4468 = root_new ['parrot';'Hash']
  vivify_1879:
    set $P4469, $P4468["param_var"]
    unless_null $P4469, vivify_1880
    $P4469 = root_new ['parrot';'Hash']
  vivify_1880:
    set $P4470, $P4469["sigil"]
    unless_null $P4470, vivify_1881
    new $P4470, "Undef"
  vivify_1881:
    $P4471 = "vivitype"($P4470)
    $P4467."viviself"($P4471)
  if_4463_end:
.annotate 'line', 1604
    goto if_4452_end
  if_4452:
.annotate 'line', 1601
    find_lex $P4456, "$past"
    $P4456."slurpy"(1)
.annotate 'line', 1602
    find_lex $P4457, "$past"
    find_lex $P4458, "$/"
    unless_null $P4458, vivify_1882
    $P4458 = root_new ['parrot';'Hash']
  vivify_1882:
    set $P4459, $P4458["param_var"]
    unless_null $P4459, vivify_1883
    $P4459 = root_new ['parrot';'Hash']
  vivify_1883:
    set $P4460, $P4459["sigil"]
    unless_null $P4460, vivify_1884
    new $P4460, "Undef"
  vivify_1884:
    set $S4461, $P4460
    iseq $I4462, $S4461, "%"
    $P4457."named"($I4462)
  if_4452_end:
.annotate 'line', 1598
    goto if_4433_end
  if_4433:
.annotate 'line', 1593
    find_lex $P4436, "$/"
    unless_null $P4436, vivify_1885
    $P4436 = root_new ['parrot';'Hash']
  vivify_1885:
    set $P4437, $P4436["named_param"]
    unless_null $P4437, vivify_1886
    new $P4437, "Undef"
  vivify_1886:
    $P4438 = $P4437."ast"()
    store_lex "$past", $P4438
.annotate 'line', 1594
    find_lex $P4440, "$quant"
    set $S4441, $P4440
    isne $I4442, $S4441, "!"
    unless $I4442, if_4439_end
.annotate 'line', 1595
    find_lex $P4443, "$past"
    find_lex $P4444, "$/"
    unless_null $P4444, vivify_1887
    $P4444 = root_new ['parrot';'Hash']
  vivify_1887:
    set $P4445, $P4444["named_param"]
    unless_null $P4445, vivify_1888
    $P4445 = root_new ['parrot';'Hash']
  vivify_1888:
    set $P4446, $P4445["param_var"]
    unless_null $P4446, vivify_1889
    $P4446 = root_new ['parrot';'Hash']
  vivify_1889:
    set $P4447, $P4446["sigil"]
    unless_null $P4447, vivify_1890
    new $P4447, "Undef"
  vivify_1890:
    $P4448 = "vivitype"($P4447)
    $P4443."viviself"($P4448)
  if_4439_end:
  if_4433_end:
.annotate 'line', 1608
    find_lex $P4473, "$/"
    unless_null $P4473, vivify_1891
    $P4473 = root_new ['parrot';'Hash']
  vivify_1891:
    set $P4474, $P4473["default_value"]
    unless_null $P4474, vivify_1892
    new $P4474, "Undef"
  vivify_1892:
    unless $P4474, if_4472_end
.annotate 'line', 1609
    find_lex $P4476, "$quant"
    set $S4477, $P4476
    iseq $I4478, $S4477, "*"
    unless $I4478, if_4475_end
.annotate 'line', 1610
    find_lex $P4479, "$/"
    $P4480 = $P4479."CURSOR"()
    $P4480."panic"("Can't put default on slurpy parameter")
  if_4475_end:
.annotate 'line', 1612
    find_lex $P4482, "$quant"
    set $S4483, $P4482
    iseq $I4484, $S4483, "!"
    unless $I4484, if_4481_end
.annotate 'line', 1613
    find_lex $P4485, "$/"
    $P4486 = $P4485."CURSOR"()
    $P4486."panic"("Can't put default on required parameter")
  if_4481_end:
.annotate 'line', 1615
    find_lex $P4487, "$past"
    find_lex $P4488, "$/"
    unless_null $P4488, vivify_1893
    $P4488 = root_new ['parrot';'Hash']
  vivify_1893:
    set $P4489, $P4488["default_value"]
    unless_null $P4489, vivify_1894
    $P4489 = root_new ['parrot';'ResizablePMCArray']
  vivify_1894:
    set $P4490, $P4489[0]
    unless_null $P4490, vivify_1895
    $P4490 = root_new ['parrot';'Hash']
  vivify_1895:
    set $P4491, $P4490["EXPR"]
    unless_null $P4491, vivify_1896
    new $P4491, "Undef"
  vivify_1896:
    $P4492 = $P4491."ast"()
    $P4487."viviself"($P4492)
  if_4472_end:
.annotate 'line', 1617
    find_lex $P4494, "$past"
    $P4495 = $P4494."viviself"()
    if $P4495, unless_4493_end
    get_global $P4496, "@BLOCK"
    unless_null $P4496, vivify_1897
    $P4496 = root_new ['parrot';'ResizablePMCArray']
  vivify_1897:
    set $P4497, $P4496[0]
    unless_null $P4497, vivify_1898
    new $P4497, "Undef"
  vivify_1898:
    get_global $P4498, "@BLOCK"
    unless_null $P4498, vivify_1899
    $P4498 = root_new ['parrot';'ResizablePMCArray']
  vivify_1899:
    set $P4499, $P4498[0]
    unless_null $P4499, vivify_1900
    new $P4499, "Undef"
  vivify_1900:
    $P4500 = $P4499."arity"()
    set $N4501, $P4500
    new $P4502, 'Float'
    set $P4502, $N4501
    add $P4503, $P4502, 1
    $P4497."arity"($P4503)
  unless_4493_end:
.annotate 'line', 1621
    find_lex $P4505, "$/"
    unless_null $P4505, vivify_1901
    $P4505 = root_new ['parrot';'Hash']
  vivify_1901:
    set $P4506, $P4505["typename"]
    unless_null $P4506, vivify_1902
    new $P4506, "Undef"
  vivify_1902:
    unless $P4506, if_4504_end
.annotate 'line', 1622
    find_lex $P4507, "$past"
    find_lex $P4508, "$/"
    unless_null $P4508, vivify_1903
    $P4508 = root_new ['parrot';'Hash']
  vivify_1903:
    set $P4509, $P4508["typename"]
    unless_null $P4509, vivify_1904
    $P4509 = root_new ['parrot';'ResizablePMCArray']
  vivify_1904:
    set $P4510, $P4509[0]
    unless_null $P4510, vivify_1905
    new $P4510, "Undef"
  vivify_1905:
    $P4511 = $P4510."ast"()
    $P4507."multitype"($P4511)
  if_4504_end:
.annotate 'line', 1626
    find_lex $P4513, "$/"
    unless_null $P4513, vivify_1906
    $P4513 = root_new ['parrot';'Hash']
  vivify_1906:
    set $P4514, $P4513["definedness"]
    unless_null $P4514, vivify_1907
    new $P4514, "Undef"
  vivify_1907:
    unless $P4514, if_4512_end
.annotate 'line', 1627
    find_lex $P4515, "$/"
    unless_null $P4515, vivify_1908
    $P4515 = root_new ['parrot';'Hash']
  vivify_1908:
    set $P4516, $P4515["definedness"]
    unless_null $P4516, vivify_1909
    $P4516 = root_new ['parrot';'ResizablePMCArray']
  vivify_1909:
    set $P4517, $P4516[0]
    unless_null $P4517, vivify_1910
    new $P4517, "Undef"
  vivify_1910:
    set $S4518, $P4517
    new $P4519, 'String'
    set $P4519, $S4518
    find_lex $P4520, "$past"
    unless_null $P4520, vivify_1911
    $P4520 = root_new ['parrot';'Hash']
    store_lex "$past", $P4520
  vivify_1911:
    set $P4520["definedness"], $P4519
  if_4512_end:
.annotate 'line', 1630
    find_lex $P4521, "$/"
    find_lex $P4522, "$past"
    $P4523 = $P4521."!make"($P4522)
.annotate 'line', 1589
    .return ($P4523)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "param_var"  :subid("502_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_4525
    .param pmc param_4526
.annotate 'line', 1633
    .lex "self", param_4525
    .lex "$/", param_4526
.annotate 'line', 1634
    new $P4527, "Undef"
    .lex "$name", $P4527
.annotate 'line', 1635
    new $P4528, "Undef"
    .lex "$past", $P4528
.annotate 'line', 1634
    find_lex $P4529, "$/"
    set $S4530, $P4529
    new $P4531, 'String'
    set $P4531, $S4530
    store_lex "$name", $P4531
.annotate 'line', 1635
    get_hll_global $P4532, ["PAST"], "Var"
    find_lex $P4533, "$name"
    find_lex $P4534, "$/"
    $P4535 = $P4532."new"($P4533 :named("name"), "parameter" :named("scope"), 1 :named("isdecl"), $P4534 :named("node"))
    store_lex "$past", $P4535
.annotate 'line', 1637
    get_global $P4536, "@BLOCK"
    unless_null $P4536, vivify_1912
    $P4536 = root_new ['parrot';'ResizablePMCArray']
  vivify_1912:
    set $P4537, $P4536[0]
    unless_null $P4537, vivify_1913
    new $P4537, "Undef"
  vivify_1913:
    find_lex $P4538, "$name"
    $P4537."symbol"($P4538, "lexical" :named("scope"))
.annotate 'line', 1638
    find_lex $P4539, "$/"
    find_lex $P4540, "$past"
    $P4541 = $P4539."!make"($P4540)
.annotate 'line', 1633
    .return ($P4541)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "named_param"  :subid("503_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_4543
    .param pmc param_4544
.annotate 'line', 1641
    .lex "self", param_4543
    .lex "$/", param_4544
.annotate 'line', 1642
    new $P4545, "Undef"
    .lex "$past", $P4545
    find_lex $P4546, "$/"
    unless_null $P4546, vivify_1914
    $P4546 = root_new ['parrot';'Hash']
  vivify_1914:
    set $P4547, $P4546["param_var"]
    unless_null $P4547, vivify_1915
    new $P4547, "Undef"
  vivify_1915:
    $P4548 = $P4547."ast"()
    store_lex "$past", $P4548
.annotate 'line', 1643
    find_lex $P4549, "$past"
    find_lex $P4550, "$/"
    unless_null $P4550, vivify_1916
    $P4550 = root_new ['parrot';'Hash']
  vivify_1916:
    set $P4551, $P4550["param_var"]
    unless_null $P4551, vivify_1917
    $P4551 = root_new ['parrot';'Hash']
  vivify_1917:
    set $P4552, $P4551["name"]
    unless_null $P4552, vivify_1918
    new $P4552, "Undef"
  vivify_1918:
    set $S4553, $P4552
    $P4549."named"($S4553)
.annotate 'line', 1644
    find_lex $P4554, "$/"
    find_lex $P4555, "$past"
    $P4556 = $P4554."!make"($P4555)
.annotate 'line', 1641
    .return ($P4556)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "typename"  :subid("504_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_4558
    .param pmc param_4559
.annotate 'line', 1647
    .lex "self", param_4558
    .lex "$/", param_4559
.annotate 'line', 1648
    $P4560 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P4560
    get_hll_global $P4561, ["HLL"], "Compiler"
    find_lex $P4562, "$/"
    set $S4563, $P4562
    $P4564 = $P4561."parse_name"($S4563)
    store_lex "@name", $P4564
.annotate 'line', 1649
    find_lex $P4565, "$/"
    get_hll_global $P4566, ["PAST"], "Var"
.annotate 'line', 1650
    find_lex $P4567, "@name"
    $P4568 = $P4567."pop"()
    find_lex $P4569, "@name"
    $P4570 = $P4566."new"($P4568 :named("name"), $P4569 :named("namespace"), "package" :named("scope"))
.annotate 'line', 1649
    $P4571 = $P4565."!make"($P4570)
.annotate 'line', 1647
    .return ($P4571)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait"  :subid("505_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_4573
    .param pmc param_4574
.annotate 'line', 1656
    .lex "self", param_4573
    .lex "$/", param_4574
.annotate 'line', 1657
    find_lex $P4575, "$/"
    find_lex $P4576, "$/"
    unless_null $P4576, vivify_1919
    $P4576 = root_new ['parrot';'Hash']
  vivify_1919:
    set $P4577, $P4576["trait_mod"]
    unless_null $P4577, vivify_1920
    new $P4577, "Undef"
  vivify_1920:
    $P4578 = $P4577."ast"()
    $P4579 = $P4575."!make"($P4578)
.annotate 'line', 1656
    .return ($P4579)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait_mod:sym<is>"  :subid("506_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_4581
    .param pmc param_4582
.annotate 'line', 1660
    .const 'Sub' $P4602 = "507_1300062003.824" 
    capture_lex $P4602
    .lex "self", param_4581
    .lex "$/", param_4582
.annotate 'line', 1661
    new $P4583, "Undef"
    .lex "$cpast", $P4583
    find_lex $P4584, "$/"
    unless_null $P4584, vivify_1921
    $P4584 = root_new ['parrot';'Hash']
  vivify_1921:
    set $P4585, $P4584["circumfix"]
    unless_null $P4585, vivify_1922
    $P4585 = root_new ['parrot';'ResizablePMCArray']
  vivify_1922:
    set $P4586, $P4585[0]
    unless_null $P4586, vivify_1923
    new $P4586, "Undef"
  vivify_1923:
    $P4587 = $P4586."ast"()
    store_lex "$cpast", $P4587
.annotate 'line', 1662
    find_lex $P4590, "$/"
    unless_null $P4590, vivify_1924
    $P4590 = root_new ['parrot';'Hash']
  vivify_1924:
    set $P4591, $P4590["longname"]
    unless_null $P4591, vivify_1925
    new $P4591, "Undef"
  vivify_1925:
    set $S4592, $P4591
    iseq $I4593, $S4592, "parrot_vtable"
    if $I4593, if_4589
.annotate 'line', 1682
    find_lex $P4628, "$/"
    unless_null $P4628, vivify_1926
    $P4628 = root_new ['parrot';'Hash']
  vivify_1926:
    set $P4629, $P4628["longname"]
    unless_null $P4629, vivify_1927
    new $P4629, "Undef"
  vivify_1927:
    set $S4630, $P4629
    iseq $I4631, $S4630, "pirflags"
    if $I4631, if_4627
.annotate 'line', 1686
    find_lex $P4635, "$/"
    $P4636 = $P4635."CURSOR"()
    new $P4637, 'String'
    set $P4637, "Trait '"
    find_lex $P4638, "$/"
    unless_null $P4638, vivify_1928
    $P4638 = root_new ['parrot';'Hash']
  vivify_1928:
    set $P4639, $P4638["longname"]
    unless_null $P4639, vivify_1929
    new $P4639, "Undef"
  vivify_1929:
    concat $P4640, $P4637, $P4639
    concat $P4641, $P4640, "' not implemented"
    $P4642 = $P4636."panic"($P4641)
.annotate 'line', 1685
    set $P4626, $P4642
.annotate 'line', 1682
    goto if_4627_end
  if_4627:
.annotate 'line', 1683
    find_lex $P4632, "$/"
    $P4633 = $P4632."CURSOR"()
    $P4634 = $P4633."panic"("Trait 'pirflags' no longer supported; use 'is vtable'")
.annotate 'line', 1682
    set $P4626, $P4634
  if_4627_end:
    set $P4588, $P4626
.annotate 'line', 1662
    goto if_4589_end
  if_4589:
.annotate 'line', 1665
    get_hll_global $P4595, ["PAST"], "Val"
    find_lex $P4596, "$cpast"
    $P4597 = $P4595."ACCEPTS"($P4596)
    if $P4597, unless_4594_end
.annotate 'line', 1664
    find_lex $P4598, "$/"
    $P4599 = $P4598."CURSOR"()
    $P4599."panic"("Trait 'parrot_vtable' requires constant scalar argument")
  unless_4594_end:
.annotate 'line', 1666
    find_lex $P4600, "$/"
    .const 'Sub' $P4602 = "507_1300062003.824" 
    newclosure $P4624, $P4602
    $P4625 = $P4600."!make"($P4624)
.annotate 'line', 1662
    set $P4588, $P4625
  if_4589_end:
.annotate 'line', 1660
    .return ($P4588)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4601"  :anon :subid("507_1300062003.824") :outer("506_1300062003.824")
    .param pmc param_4603
.annotate 'line', 1666
    .lex "$match", param_4603
.annotate 'line', 1667
    new $P4604, "Undef"
    .lex "$meth", $P4604
    find_lex $P4605, "$match"
    $P4606 = $P4605."ast"()
    set $P4607, $P4606["block_past"]
    unless_null $P4607, vivify_1930
    new $P4607, "Undef"
  vivify_1930:
    store_lex "$meth", $P4607
.annotate 'line', 1668
    find_dynamic_lex $P4610, "$*PACKAGE-SETUP"
    unless_null $P4610, vivify_1931
    get_hll_global $P4610, "$PACKAGE-SETUP"
    unless_null $P4610, vivify_1932
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1932:
  vivify_1931:
    defined $I4611, $P4610
    if $I4611, if_4609
    new $P4608, 'Integer'
    set $P4608, $I4611
    goto if_4609_end
  if_4609:
.annotate 'line', 1669
    find_dynamic_lex $P4612, "$*PACKAGE-SETUP"
    unless_null $P4612, vivify_1933
    get_hll_global $P4612, "$PACKAGE-SETUP"
    unless_null $P4612, vivify_1934
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1934:
  vivify_1933:
    get_hll_global $P4613, ["PAST"], "Op"
.annotate 'line', 1671
    get_hll_global $P4614, ["PAST"], "Op"
.annotate 'line', 1674
    get_hll_global $P4615, ["PAST"], "Var"
    $P4616 = $P4615."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4617 = $P4614."new"($P4616, "get_how PP" :named("pirop"))
.annotate 'line', 1676
    get_hll_global $P4618, ["PAST"], "Var"
    $P4619 = $P4618."new"("type_obj" :named("name"), "register" :named("scope"))
    find_lex $P4620, "$cpast"
    find_lex $P4621, "$meth"
    $P4622 = $P4613."new"($P4617, $P4619, $P4620, $P4621, "callmethod" :named("pasttype"), "add_parrot_vtable_mapping" :named("name"))
.annotate 'line', 1669
    $P4623 = $P4612."push"($P4622)
.annotate 'line', 1668
    set $P4608, $P4623
  if_4609_end:
.annotate 'line', 1666
    .return ($P4608)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "regex_declarator"  :subid("508_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_4646
    .param pmc param_4647
    .param pmc param_4648 :optional
    .param int has_param_4648 :opt_flag
.annotate 'line', 1690
    .const 'Sub' $P4746 = "511_1300062003.824" 
    capture_lex $P4746
    .const 'Sub' $P4718 = "510_1300062003.824" 
    capture_lex $P4718
    .const 'Sub' $P4691 = "509_1300062003.824" 
    capture_lex $P4691
    new $P4645, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P4645, control_4644
    push_eh $P4645
    .lex "self", param_4646
    .lex "$/", param_4647
    if has_param_4648, optparam_1935
    new $P4649, "Undef"
    set param_4648, $P4649
  optparam_1935:
    .lex "$key", param_4648
.annotate 'line', 1691
    $P4650 = root_new ['parrot';'ResizablePMCArray']
    .lex "@MODIFIERS", $P4650
.annotate 'line', 1694
    new $P4651, "Undef"
    .lex "$name", $P4651
.annotate 'line', 1695
    new $P4652, "Undef"
    .lex "$past", $P4652
.annotate 'line', 1691

            $P4653 = get_hll_global ['Regex';'P6Regex';'Actions'], '@MODIFIERS'
        
    store_lex "@MODIFIERS", $P4653
.annotate 'line', 1694
    find_lex $P4654, "$/"
    unless_null $P4654, vivify_1936
    $P4654 = root_new ['parrot';'Hash']
  vivify_1936:
    set $P4655, $P4654["deflongname"]
    unless_null $P4655, vivify_1937
    new $P4655, "Undef"
  vivify_1937:
    $P4656 = $P4655."ast"()
    set $S4657, $P4656
    new $P4658, 'String'
    set $P4658, $S4657
    store_lex "$name", $P4658
    find_lex $P4659, "$past"
.annotate 'line', 1696
    find_lex $P4661, "$/"
    unless_null $P4661, vivify_1938
    $P4661 = root_new ['parrot';'Hash']
  vivify_1938:
    set $P4662, $P4661["proto"]
    unless_null $P4662, vivify_1939
    new $P4662, "Undef"
  vivify_1939:
    if $P4662, if_4660
.annotate 'line', 1735
    find_lex $P4714, "$key"
    set $S4715, $P4714
    iseq $I4716, $S4715, "open"
    if $I4716, if_4713
.annotate 'line', 1748
    .const 'Sub' $P4746 = "511_1300062003.824" 
    capture_lex $P4746
    $P4746()
    goto if_4713_end
  if_4713:
.annotate 'line', 1735
    .const 'Sub' $P4718 = "510_1300062003.824" 
    capture_lex $P4718
    $P4718()
  if_4713_end:
    goto if_4660_end
  if_4660:
.annotate 'line', 1698
    get_hll_global $P4663, ["PAST"], "Stmts"
.annotate 'line', 1699
    get_hll_global $P4664, ["PAST"], "Block"
    find_lex $P4665, "$name"
.annotate 'line', 1700
    get_hll_global $P4666, ["PAST"], "Op"
.annotate 'line', 1701
    get_hll_global $P4667, ["PAST"], "Var"
    $P4668 = $P4667."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P4669, "$name"
    $P4670 = $P4666."new"($P4668, $P4669, "!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 1700
    find_lex $P4671, "$/"
    $P4672 = $P4664."new"($P4670, $P4665 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P4671 :named("node"))
.annotate 'line', 1710
    get_hll_global $P4673, ["PAST"], "Block"
    new $P4674, "String"
    assign $P4674, "!PREFIX__"
    find_lex $P4675, "$name"
    concat $P4676, $P4674, $P4675
.annotate 'line', 1711
    get_hll_global $P4677, ["PAST"], "Op"
.annotate 'line', 1712
    get_hll_global $P4678, ["PAST"], "Var"
    $P4679 = $P4678."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P4680, "$name"
    $P4681 = $P4677."new"($P4679, $P4680, "!PREFIX__!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 1711
    find_lex $P4682, "$/"
    $P4683 = $P4673."new"($P4681, $P4676 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P4682 :named("node"))
.annotate 'line', 1710
    $P4684 = $P4663."new"($P4672, $P4683)
.annotate 'line', 1698
    store_lex "$past", $P4684
.annotate 'line', 1722
    find_lex $P4686, "$past"
    $P4687 = $P4686."list"()
    defined $I4688, $P4687
    unless $I4688, for_undef_1960
    iter $P4685, $P4687
    new $P4711, 'ExceptionHandler'
    set_label $P4711, loop4710_handler
    $P4711."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4711
  loop4710_test:
    unless $P4685, loop4710_done
    shift $P4689, $P4685
  loop4710_redo:
    .const 'Sub' $P4691 = "509_1300062003.824" 
    capture_lex $P4691
    $P4691($P4689)
  loop4710_next:
    goto loop4710_test
  loop4710_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4712, exception, 'type'
    eq $P4712, .CONTROL_LOOP_NEXT, loop4710_next
    eq $P4712, .CONTROL_LOOP_REDO, loop4710_redo
  loop4710_done:
    pop_eh 
  for_undef_1960:
  if_4660_end:
.annotate 'line', 1784
    find_lex $P4804, "$/"
    find_lex $P4805, "$past"
    $P4806 = $P4804."!make"($P4805)
.annotate 'line', 1690
    .return ($P4806)
  control_4644:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4807, exception, "payload"
    .return ($P4807)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4745"  :anon :subid("511_1300062003.824") :outer("508_1300062003.824")
.annotate 'line', 1749
    new $P4747, "Undef"
    .lex "$regex", $P4747
.annotate 'line', 1750
    get_hll_global $P4748, ["Regex";"P6Regex";"Actions"], "buildsub"
    find_lex $P4749, "$/"
    unless_null $P4749, vivify_1940
    $P4749 = root_new ['parrot';'Hash']
  vivify_1940:
    set $P4750, $P4749["p6regex"]
    unless_null $P4750, vivify_1941
    new $P4750, "Undef"
  vivify_1941:
    $P4751 = $P4750."ast"()
    get_global $P4752, "@BLOCK"
    $P4753 = $P4752."shift"()
    $P4754 = $P4748($P4751, $P4753)
    store_lex "$regex", $P4754
.annotate 'line', 1751
    find_lex $P4755, "$regex"
    find_lex $P4756, "$name"
    $P4755."name"($P4756)
.annotate 'line', 1753
    get_hll_global $P4757, ["PAST"], "Op"
.annotate 'line', 1755
    get_hll_global $P4758, ["PAST"], "Var"
    new $P4759, "ResizablePMCArray"
    push $P4759, "Regex"
    $P4760 = $P4758."new"("Method" :named("name"), $P4759 :named("namespace"), "package" :named("scope"))
    find_lex $P4761, "$regex"
    $P4762 = $P4757."new"($P4760, $P4761, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 1753
    store_lex "$past", $P4762
.annotate 'line', 1758
    find_dynamic_lex $P4764, "$*PACKAGE-SETUP"
    unless_null $P4764, vivify_1942
    get_hll_global $P4764, "$PACKAGE-SETUP"
    unless_null $P4764, vivify_1943
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1943:
  vivify_1942:
    defined $I4765, $P4764
    unless $I4765, if_4763_end
.annotate 'line', 1759
    find_dynamic_lex $P4766, "$*PACKAGE-SETUP"
    unless_null $P4766, vivify_1944
    get_hll_global $P4766, "$PACKAGE-SETUP"
    unless_null $P4766, vivify_1945
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1945:
  vivify_1944:
    get_hll_global $P4767, ["PAST"], "Op"
.annotate 'line', 1761
    get_hll_global $P4768, ["PAST"], "Op"
.annotate 'line', 1763
    get_hll_global $P4769, ["PAST"], "Var"
    $P4770 = $P4769."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4771 = $P4768."new"($P4770, "get_how PP" :named("pirop"))
.annotate 'line', 1765
    get_hll_global $P4772, ["PAST"], "Var"
    $P4773 = $P4772."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1766
    get_hll_global $P4774, ["PAST"], "Val"
    find_lex $P4775, "$name"
    $P4776 = $P4774."new"($P4775 :named("value"))
.annotate 'line', 1767
    get_hll_global $P4777, ["PAST"], "Val"
    find_lex $P4778, "$regex"
    $P4779 = $P4777."new"($P4778 :named("value"))
    $P4780 = $P4767."new"($P4771, $P4773, $P4776, $P4779, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 1759
    $P4766."push"($P4780)
.annotate 'line', 1769
    find_dynamic_lex $P4781, "$*PACKAGE-SETUP"
    unless_null $P4781, vivify_1946
    get_hll_global $P4781, "$PACKAGE-SETUP"
    unless_null $P4781, vivify_1947
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1947:
  vivify_1946:
    get_hll_global $P4782, ["PAST"], "Op"
.annotate 'line', 1771
    get_hll_global $P4783, ["PAST"], "Op"
.annotate 'line', 1773
    get_hll_global $P4784, ["PAST"], "Var"
    $P4785 = $P4784."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4786 = $P4783."new"($P4785, "get_how PP" :named("pirop"))
.annotate 'line', 1775
    get_hll_global $P4787, ["PAST"], "Var"
    $P4788 = $P4787."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1776
    get_hll_global $P4789, ["PAST"], "Val"
    new $P4790, "String"
    assign $P4790, "!PREFIX__"
    find_lex $P4791, "$name"
    concat $P4792, $P4790, $P4791
    $P4793 = $P4789."new"($P4792 :named("value"))
.annotate 'line', 1777
    get_hll_global $P4794, ["PAST"], "Var"
    new $P4795, "String"
    assign $P4795, "!PREFIX__"
    find_lex $P4796, "$name"
    concat $P4797, $P4795, $P4796
    $P4798 = $P4794."new"($P4797 :named("name"), "package" :named("scope"))
    $P4799 = $P4782."new"($P4786, $P4788, $P4793, $P4798, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 1769
    $P4781."push"($P4799)
  if_4763_end:
.annotate 'line', 1781
    find_lex $P4800, "$regex"
    find_lex $P4801, "$past"
    unless_null $P4801, vivify_1948
    $P4801 = root_new ['parrot';'Hash']
    store_lex "$past", $P4801
  vivify_1948:
    set $P4801["sink"], $P4800
.annotate 'line', 1782
    find_lex $P4802, "@MODIFIERS"
    $P4803 = $P4802."shift"()
.annotate 'line', 1748
    .return ($P4803)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block4717"  :anon :subid("510_1300062003.824") :outer("508_1300062003.824")
.annotate 'line', 1736
    $P4719 = root_new ['parrot';'Hash']
    .lex "%h", $P4719
.annotate 'line', 1735
    find_lex $P4720, "%h"
.annotate 'line', 1737
    find_lex $P4722, "$/"
    unless_null $P4722, vivify_1949
    $P4722 = root_new ['parrot';'Hash']
  vivify_1949:
    set $P4723, $P4722["sym"]
    unless_null $P4723, vivify_1950
    new $P4723, "Undef"
  vivify_1950:
    set $S4724, $P4723
    iseq $I4725, $S4724, "token"
    unless $I4725, if_4721_end
    new $P4726, "Integer"
    assign $P4726, 1
    find_lex $P4727, "%h"
    unless_null $P4727, vivify_1951
    $P4727 = root_new ['parrot';'Hash']
    store_lex "%h", $P4727
  vivify_1951:
    set $P4727["r"], $P4726
  if_4721_end:
.annotate 'line', 1738
    find_lex $P4729, "$/"
    unless_null $P4729, vivify_1952
    $P4729 = root_new ['parrot';'Hash']
  vivify_1952:
    set $P4730, $P4729["sym"]
    unless_null $P4730, vivify_1953
    new $P4730, "Undef"
  vivify_1953:
    set $S4731, $P4730
    iseq $I4732, $S4731, "rule"
    unless $I4732, if_4728_end
    new $P4733, "Integer"
    assign $P4733, 1
    find_lex $P4734, "%h"
    unless_null $P4734, vivify_1954
    $P4734 = root_new ['parrot';'Hash']
    store_lex "%h", $P4734
  vivify_1954:
    set $P4734["r"], $P4733
    new $P4735, "Integer"
    assign $P4735, 1
    find_lex $P4736, "%h"
    unless_null $P4736, vivify_1955
    $P4736 = root_new ['parrot';'Hash']
    store_lex "%h", $P4736
  vivify_1955:
    set $P4736["s"], $P4735
  if_4728_end:
.annotate 'line', 1739
    find_lex $P4737, "@MODIFIERS"
    find_lex $P4738, "%h"
    $P4737."unshift"($P4738)
.annotate 'line', 1740

                $P0 = find_lex '$name'
                set_hll_global ['Regex';'P6Regex';'Actions'], '$REGEXNAME', $P0
            
.annotate 'line', 1744
    get_global $P4739, "@BLOCK"
    unless_null $P4739, vivify_1956
    $P4739 = root_new ['parrot';'ResizablePMCArray']
  vivify_1956:
    set $P4740, $P4739[0]
    unless_null $P4740, vivify_1957
    new $P4740, "Undef"
  vivify_1957:
    $P4740."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 1745
    get_global $P4741, "@BLOCK"
    unless_null $P4741, vivify_1958
    $P4741 = root_new ['parrot';'ResizablePMCArray']
  vivify_1958:
    set $P4742, $P4741[0]
    unless_null $P4742, vivify_1959
    new $P4742, "Undef"
  vivify_1959:
    $P4742."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 1746
    new $P4743, "Exception"
    set $P4743['type'], .CONTROL_RETURN
    new $P4744, "Integer"
    assign $P4744, 0
    setattribute $P4743, 'payload', $P4744
    throw $P4743
.annotate 'line', 1735
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4690"  :anon :subid("509_1300062003.824") :outer("508_1300062003.824")
    .param pmc param_4692
.annotate 'line', 1722
    .lex "$_", param_4692
.annotate 'line', 1723
    find_dynamic_lex $P4693, "$*PACKAGE-SETUP"
    unless_null $P4693, vivify_1961
    get_hll_global $P4693, "$PACKAGE-SETUP"
    unless_null $P4693, vivify_1962
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1962:
  vivify_1961:
    get_hll_global $P4694, ["PAST"], "Op"
.annotate 'line', 1725
    get_hll_global $P4695, ["PAST"], "Op"
.annotate 'line', 1727
    get_hll_global $P4696, ["PAST"], "Var"
    $P4697 = $P4696."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4698 = $P4695."new"($P4697, "get_how PP" :named("pirop"))
.annotate 'line', 1729
    get_hll_global $P4699, ["PAST"], "Var"
    $P4700 = $P4699."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1730
    get_hll_global $P4701, ["PAST"], "Val"
    find_lex $P4702, "$_"
    $P4703 = $P4702."name"()
    $P4704 = $P4701."new"($P4703 :named("value"))
.annotate 'line', 1731
    get_hll_global $P4705, ["PAST"], "Val"
    find_lex $P4706, "$_"
    $P4707 = $P4705."new"($P4706 :named("value"))
    $P4708 = $P4694."new"($P4698, $P4700, $P4704, $P4707, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 1723
    $P4709 = $P4693."push"($P4708)
.annotate 'line', 1722
    .return ($P4709)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "dotty"  :subid("512_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_4809
    .param pmc param_4810
.annotate 'line', 1788
    .lex "self", param_4809
    .lex "$/", param_4810
.annotate 'line', 1789
    new $P4811, "Undef"
    .lex "$past", $P4811
    find_lex $P4814, "$/"
    unless_null $P4814, vivify_1963
    $P4814 = root_new ['parrot';'Hash']
  vivify_1963:
    set $P4815, $P4814["args"]
    unless_null $P4815, vivify_1964
    new $P4815, "Undef"
  vivify_1964:
    if $P4815, if_4813
    get_hll_global $P4820, ["PAST"], "Op"
    find_lex $P4821, "$/"
    $P4822 = $P4820."new"($P4821 :named("node"))
    set $P4812, $P4822
    goto if_4813_end
  if_4813:
    find_lex $P4816, "$/"
    unless_null $P4816, vivify_1965
    $P4816 = root_new ['parrot';'Hash']
  vivify_1965:
    set $P4817, $P4816["args"]
    unless_null $P4817, vivify_1966
    $P4817 = root_new ['parrot';'ResizablePMCArray']
  vivify_1966:
    set $P4818, $P4817[0]
    unless_null $P4818, vivify_1967
    new $P4818, "Undef"
  vivify_1967:
    $P4819 = $P4818."ast"()
    set $P4812, $P4819
  if_4813_end:
    store_lex "$past", $P4812
.annotate 'line', 1790
    find_lex $P4824, "$/"
    unless_null $P4824, vivify_1968
    $P4824 = root_new ['parrot';'Hash']
  vivify_1968:
    set $P4825, $P4824["quote"]
    unless_null $P4825, vivify_1969
    new $P4825, "Undef"
  vivify_1969:
    if $P4825, if_4823
.annotate 'line', 1794
    find_lex $P4832, "$/"
    unless_null $P4832, vivify_1970
    $P4832 = root_new ['parrot';'Hash']
  vivify_1970:
    set $P4833, $P4832["longname"]
    unless_null $P4833, vivify_1971
    new $P4833, "Undef"
  vivify_1971:
    set $S4834, $P4833
    iseq $I4835, $S4834, "HOW"
    if $I4835, if_4831
.annotate 'line', 1797
    find_lex $P4838, "$/"
    unless_null $P4838, vivify_1972
    $P4838 = root_new ['parrot';'Hash']
  vivify_1972:
    set $P4839, $P4838["longname"]
    unless_null $P4839, vivify_1973
    new $P4839, "Undef"
  vivify_1973:
    set $S4840, $P4839
    iseq $I4841, $S4840, "WHAT"
    if $I4841, if_4837
.annotate 'line', 1800
    find_lex $P4844, "$/"
    unless_null $P4844, vivify_1974
    $P4844 = root_new ['parrot';'Hash']
  vivify_1974:
    set $P4845, $P4844["longname"]
    unless_null $P4845, vivify_1975
    new $P4845, "Undef"
  vivify_1975:
    set $S4846, $P4845
    iseq $I4847, $S4846, "WHO"
    if $I4847, if_4843
.annotate 'line', 1804
    find_lex $P4849, "$past"
    find_lex $P4850, "$/"
    unless_null $P4850, vivify_1976
    $P4850 = root_new ['parrot';'Hash']
  vivify_1976:
    set $P4851, $P4850["longname"]
    unless_null $P4851, vivify_1977
    new $P4851, "Undef"
  vivify_1977:
    set $S4852, $P4851
    $P4849."name"($S4852)
.annotate 'line', 1805
    find_lex $P4853, "$past"
    $P4853."pasttype"("callmethod")
.annotate 'line', 1803
    goto if_4843_end
  if_4843:
.annotate 'line', 1801
    find_lex $P4848, "$past"
    $P4848."pirop"("get_who PP")
  if_4843_end:
.annotate 'line', 1800
    goto if_4837_end
  if_4837:
.annotate 'line', 1798
    find_lex $P4842, "$past"
    $P4842."pirop"("get_what PP")
  if_4837_end:
.annotate 'line', 1797
    goto if_4831_end
  if_4831:
.annotate 'line', 1795
    find_lex $P4836, "$past"
    $P4836."pirop"("get_how PP")
  if_4831_end:
.annotate 'line', 1794
    goto if_4823_end
  if_4823:
.annotate 'line', 1791
    find_lex $P4826, "$past"
    find_lex $P4827, "$/"
    unless_null $P4827, vivify_1978
    $P4827 = root_new ['parrot';'Hash']
  vivify_1978:
    set $P4828, $P4827["quote"]
    unless_null $P4828, vivify_1979
    new $P4828, "Undef"
  vivify_1979:
    $P4829 = $P4828."ast"()
    $P4826."name"($P4829)
.annotate 'line', 1792
    find_lex $P4830, "$past"
    $P4830."pasttype"("callmethod")
  if_4823_end:
.annotate 'line', 1807
    find_lex $P4854, "$/"
    find_lex $P4855, "$past"
    $P4856 = $P4854."!make"($P4855)
.annotate 'line', 1788
    .return ($P4856)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<self>"  :subid("513_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_4858
    .param pmc param_4859
.annotate 'line', 1812
    .lex "self", param_4858
    .lex "$/", param_4859
.annotate 'line', 1813
    find_lex $P4860, "$/"
    get_hll_global $P4861, ["PAST"], "Var"
    $P4862 = $P4861."new"("self" :named("name"))
    $P4863 = $P4860."!make"($P4862)
.annotate 'line', 1812
    .return ($P4863)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<identifier>"  :subid("514_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_4865
    .param pmc param_4866
.annotate 'line', 1816
    .lex "self", param_4865
    .lex "$/", param_4866
.annotate 'line', 1817
    new $P4867, "Undef"
    .lex "$past", $P4867
    find_lex $P4868, "$/"
    unless_null $P4868, vivify_1980
    $P4868 = root_new ['parrot';'Hash']
  vivify_1980:
    set $P4869, $P4868["args"]
    unless_null $P4869, vivify_1981
    new $P4869, "Undef"
  vivify_1981:
    $P4870 = $P4869."ast"()
    store_lex "$past", $P4870
.annotate 'line', 1818
    find_lex $P4871, "$past"
    find_lex $P4872, "$/"
    unless_null $P4872, vivify_1982
    $P4872 = root_new ['parrot';'Hash']
  vivify_1982:
    set $P4873, $P4872["deflongname"]
    unless_null $P4873, vivify_1983
    new $P4873, "Undef"
  vivify_1983:
    set $S4874, $P4873
    $P4871."name"($S4874)
.annotate 'line', 1819
    find_lex $P4875, "$/"
    find_lex $P4876, "$past"
    $P4877 = $P4875."!make"($P4876)
.annotate 'line', 1816
    .return ($P4877)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<name>"  :subid("515_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_4879
    .param pmc param_4880
.annotate 'line', 1822
    .const 'Sub' $P4895 = "516_1300062003.824" 
    capture_lex $P4895
    .lex "self", param_4879
    .lex "$/", param_4880
.annotate 'line', 1824
    new $P4881, "Undef"
    .lex "$var", $P4881
.annotate 'line', 1836
    new $P4882, "Undef"
    .lex "$past", $P4882
.annotate 'line', 1822
    find_lex $P4883, "$var"
.annotate 'line', 1825
    find_lex $P4885, "$/"
    unless_null $P4885, vivify_1984
    $P4885 = root_new ['parrot';'Hash']
  vivify_1984:
    set $P4886, $P4885["name"]
    unless_null $P4886, vivify_1985
    new $P4886, "Undef"
  vivify_1985:
    set $S4887, $P4886
    $P4888 = "is_lexical"($S4887)
    if $P4888, if_4884
.annotate 'line', 1828
    .const 'Sub' $P4895 = "516_1300062003.824" 
    capture_lex $P4895
    $P4895()
    goto if_4884_end
  if_4884:
.annotate 'line', 1826
    get_hll_global $P4889, ["PAST"], "Var"
    find_lex $P4890, "$/"
    unless_null $P4890, vivify_1991
    $P4890 = root_new ['parrot';'Hash']
  vivify_1991:
    set $P4891, $P4890["name"]
    unless_null $P4891, vivify_1992
    new $P4891, "Undef"
  vivify_1992:
    set $S4892, $P4891
    $P4893 = $P4889."new"($S4892 :named("name"), "lexical" :named("scope"))
    store_lex "$var", $P4893
  if_4884_end:
.annotate 'line', 1836
    find_lex $P4918, "$var"
    store_lex "$past", $P4918
.annotate 'line', 1837
    find_lex $P4920, "$/"
    unless_null $P4920, vivify_1993
    $P4920 = root_new ['parrot';'Hash']
  vivify_1993:
    set $P4921, $P4920["args"]
    unless_null $P4921, vivify_1994
    new $P4921, "Undef"
  vivify_1994:
    unless $P4921, if_4919_end
.annotate 'line', 1838
    find_lex $P4922, "$/"
    unless_null $P4922, vivify_1995
    $P4922 = root_new ['parrot';'Hash']
  vivify_1995:
    set $P4923, $P4922["args"]
    unless_null $P4923, vivify_1996
    $P4923 = root_new ['parrot';'ResizablePMCArray']
  vivify_1996:
    set $P4924, $P4923[0]
    unless_null $P4924, vivify_1997
    new $P4924, "Undef"
  vivify_1997:
    $P4925 = $P4924."ast"()
    store_lex "$past", $P4925
.annotate 'line', 1839
    find_lex $P4926, "$past"
    find_lex $P4927, "$var"
    $P4926."unshift"($P4927)
  if_4919_end:
.annotate 'line', 1841
    find_lex $P4928, "$/"
    find_lex $P4929, "$past"
    $P4930 = $P4928."!make"($P4929)
.annotate 'line', 1822
    .return ($P4930)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4894"  :anon :subid("516_1300062003.824") :outer("515_1300062003.824")
.annotate 'line', 1829
    $P4896 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P4896
.annotate 'line', 1830
    new $P4897, "Undef"
    .lex "$name", $P4897
.annotate 'line', 1829
    find_lex $P4898, "$/"
    unless_null $P4898, vivify_1986
    $P4898 = root_new ['parrot';'Hash']
  vivify_1986:
    set $P4899, $P4898["name"]
    unless_null $P4899, vivify_1987
    $P4899 = root_new ['parrot';'Hash']
  vivify_1987:
    set $P4900, $P4899["identifier"]
    unless_null $P4900, vivify_1988
    new $P4900, "Undef"
  vivify_1988:
    clone $P4901, $P4900
    store_lex "@ns", $P4901
.annotate 'line', 1830
    find_lex $P4902, "@ns"
    $P4903 = $P4902."pop"()
    store_lex "$name", $P4903
.annotate 'line', 1831
    find_lex $P4907, "@ns"
    if $P4907, if_4906
    set $P4905, $P4907
    goto if_4906_end
  if_4906:
    find_lex $P4908, "@ns"
    unless_null $P4908, vivify_1989
    $P4908 = root_new ['parrot';'ResizablePMCArray']
  vivify_1989:
    set $P4909, $P4908[0]
    unless_null $P4909, vivify_1990
    new $P4909, "Undef"
  vivify_1990:
    set $S4910, $P4909
    iseq $I4911, $S4910, "GLOBAL"
    new $P4905, 'Integer'
    set $P4905, $I4911
  if_4906_end:
    unless $P4905, if_4904_end
    find_lex $P4912, "@ns"
    $P4912."shift"()
  if_4904_end:
.annotate 'line', 1832
    get_hll_global $P4913, ["PAST"], "Var"
    find_lex $P4914, "$name"
    set $S4915, $P4914
    find_lex $P4916, "@ns"
    $P4917 = $P4913."new"($S4915 :named("name"), $P4916 :named("namespace"), "package" :named("scope"))
    store_lex "$var", $P4917
.annotate 'line', 1828
    .return ($P4917)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<pir::op>"  :subid("517_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_4933
    .param pmc param_4934
.annotate 'line', 1854
    .lex "self", param_4933
    .lex "$/", param_4934
.annotate 'line', 1855
    new $P4935, "Undef"
    .lex "$past", $P4935
.annotate 'line', 1856
    new $P4936, "Undef"
    .lex "$pirop", $P4936
.annotate 'line', 1855
    find_lex $P4939, "$/"
    unless_null $P4939, vivify_1998
    $P4939 = root_new ['parrot';'Hash']
  vivify_1998:
    set $P4940, $P4939["args"]
    unless_null $P4940, vivify_1999
    new $P4940, "Undef"
  vivify_1999:
    if $P4940, if_4938
    get_hll_global $P4945, ["PAST"], "Op"
    find_lex $P4946, "$/"
    $P4947 = $P4945."new"($P4946 :named("node"))
    set $P4937, $P4947
    goto if_4938_end
  if_4938:
    find_lex $P4941, "$/"
    unless_null $P4941, vivify_2000
    $P4941 = root_new ['parrot';'Hash']
  vivify_2000:
    set $P4942, $P4941["args"]
    unless_null $P4942, vivify_2001
    $P4942 = root_new ['parrot';'ResizablePMCArray']
  vivify_2001:
    set $P4943, $P4942[0]
    unless_null $P4943, vivify_2002
    new $P4943, "Undef"
  vivify_2002:
    $P4944 = $P4943."ast"()
    set $P4937, $P4944
  if_4938_end:
    store_lex "$past", $P4937
.annotate 'line', 1856
    find_lex $P4948, "$/"
    unless_null $P4948, vivify_2003
    $P4948 = root_new ['parrot';'Hash']
  vivify_2003:
    set $P4949, $P4948["op"]
    unless_null $P4949, vivify_2004
    new $P4949, "Undef"
  vivify_2004:
    set $S4950, $P4949
    new $P4951, 'String'
    set $P4951, $S4950
    store_lex "$pirop", $P4951
.annotate 'line', 1857

            $P0 = find_lex '$pirop'
            $S0 = $P0
            $P0 = split '__', $S0
            $S0 = join ' ', $P0
            $P4952 = box $S0
        
    store_lex "$pirop", $P4952
.annotate 'line', 1864
    find_lex $P4953, "$past"
    find_lex $P4954, "$pirop"
    $P4953."pirop"($P4954)
.annotate 'line', 1865
    find_lex $P4955, "$past"
    $P4955."pasttype"("pirop")
.annotate 'line', 1866
    find_lex $P4956, "$/"
    find_lex $P4957, "$past"
    $P4958 = $P4956."!make"($P4957)
.annotate 'line', 1854
    .return ($P4958)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<onlystar>"  :subid("518_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_4960
    .param pmc param_4961
.annotate 'line', 1869
    .lex "self", param_4960
    .lex "$/", param_4961
.annotate 'line', 1870
    find_lex $P4962, "$/"
    get_hll_global $P4963, ["PAST"], "Op"
    $P4964 = $P4963."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P4965 = $P4962."!make"($P4964)
.annotate 'line', 1869
    .return ($P4965)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "args"  :subid("519_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_4967
    .param pmc param_4968
.annotate 'line', 1875
    .lex "self", param_4967
    .lex "$/", param_4968
    find_lex $P4969, "$/"
    find_lex $P4970, "$/"
    unless_null $P4970, vivify_2005
    $P4970 = root_new ['parrot';'Hash']
  vivify_2005:
    set $P4971, $P4970["arglist"]
    unless_null $P4971, vivify_2006
    new $P4971, "Undef"
  vivify_2006:
    $P4972 = $P4971."ast"()
    $P4973 = $P4969."!make"($P4972)
    .return ($P4973)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "arglist"  :subid("520_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_4975
    .param pmc param_4976
.annotate 'line', 1877
    .const 'Sub' $P4987 = "521_1300062003.824" 
    capture_lex $P4987
    .lex "self", param_4975
    .lex "$/", param_4976
.annotate 'line', 1878
    new $P4977, "Undef"
    .lex "$past", $P4977
.annotate 'line', 1886
    new $P4978, "Undef"
    .lex "$i", $P4978
.annotate 'line', 1887
    new $P4979, "Undef"
    .lex "$n", $P4979
.annotate 'line', 1878
    get_hll_global $P4980, ["PAST"], "Op"
    find_lex $P4981, "$/"
    $P4982 = $P4980."new"("call" :named("pasttype"), $P4981 :named("node"))
    store_lex "$past", $P4982
.annotate 'line', 1879
    find_lex $P4984, "$/"
    unless_null $P4984, vivify_2007
    $P4984 = root_new ['parrot';'Hash']
  vivify_2007:
    set $P4985, $P4984["EXPR"]
    unless_null $P4985, vivify_2008
    new $P4985, "Undef"
  vivify_2008:
    unless $P4985, if_4983_end
    .const 'Sub' $P4987 = "521_1300062003.824" 
    capture_lex $P4987
    $P4987()
  if_4983_end:
.annotate 'line', 1886
    new $P5019, "Integer"
    assign $P5019, 0
    store_lex "$i", $P5019
.annotate 'line', 1887
    find_lex $P5020, "$past"
    $P5021 = $P5020."list"()
    set $N5022, $P5021
    new $P5023, 'Float'
    set $P5023, $N5022
    store_lex "$n", $P5023
.annotate 'line', 1888
    new $P5071, 'ExceptionHandler'
    set_label $P5071, loop5070_handler
    $P5071."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5071
  loop5070_test:
    find_lex $P5024, "$i"
    set $N5025, $P5024
    find_lex $P5026, "$n"
    set $N5027, $P5026
    islt $I5028, $N5025, $N5027
    unless $I5028, loop5070_done
  loop5070_redo:
.annotate 'line', 1889
    find_lex $P5030, "$i"
    set $I5031, $P5030
    find_lex $P5032, "$past"
    unless_null $P5032, vivify_2012
    $P5032 = root_new ['parrot';'ResizablePMCArray']
  vivify_2012:
    set $P5033, $P5032[$I5031]
    unless_null $P5033, vivify_2013
    new $P5033, "Undef"
  vivify_2013:
    $S5034 = $P5033."name"()
    iseq $I5035, $S5034, "&prefix:<|>"
    unless $I5035, if_5029_end
.annotate 'line', 1890
    find_lex $P5036, "$i"
    set $I5037, $P5036
    find_lex $P5038, "$past"
    unless_null $P5038, vivify_2014
    $P5038 = root_new ['parrot';'ResizablePMCArray']
  vivify_2014:
    set $P5039, $P5038[$I5037]
    unless_null $P5039, vivify_2015
    $P5039 = root_new ['parrot';'ResizablePMCArray']
  vivify_2015:
    set $P5040, $P5039[0]
    unless_null $P5040, vivify_2016
    new $P5040, "Undef"
  vivify_2016:
    find_lex $P5041, "$i"
    set $I5042, $P5041
    find_lex $P5043, "$past"
    unless_null $P5043, vivify_2017
    $P5043 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$past", $P5043
  vivify_2017:
    set $P5043[$I5042], $P5040
.annotate 'line', 1891
    find_lex $P5044, "$i"
    set $I5045, $P5044
    find_lex $P5046, "$past"
    unless_null $P5046, vivify_2018
    $P5046 = root_new ['parrot';'ResizablePMCArray']
  vivify_2018:
    set $P5047, $P5046[$I5045]
    unless_null $P5047, vivify_2019
    new $P5047, "Undef"
  vivify_2019:
    $P5047."flat"(1)
.annotate 'line', 1892
    find_lex $P5051, "$i"
    set $I5052, $P5051
    find_lex $P5053, "$past"
    unless_null $P5053, vivify_2020
    $P5053 = root_new ['parrot';'ResizablePMCArray']
  vivify_2020:
    set $P5054, $P5053[$I5052]
    unless_null $P5054, vivify_2021
    new $P5054, "Undef"
  vivify_2021:
    get_hll_global $P5055, ["PAST"], "Val"
    $P5056 = $P5054."isa"($P5055)
    if $P5056, if_5050
    set $P5049, $P5056
    goto if_5050_end
  if_5050:
.annotate 'line', 1893
    find_lex $P5057, "$i"
    set $I5058, $P5057
    find_lex $P5059, "$past"
    unless_null $P5059, vivify_2022
    $P5059 = root_new ['parrot';'ResizablePMCArray']
  vivify_2022:
    set $P5060, $P5059[$I5058]
    unless_null $P5060, vivify_2023
    new $P5060, "Undef"
  vivify_2023:
    $S5061 = $P5060."name"()
    substr $S5062, $S5061, 0, 1
    iseq $I5063, $S5062, "%"
    new $P5049, 'Integer'
    set $P5049, $I5063
  if_5050_end:
    unless $P5049, if_5048_end
.annotate 'line', 1894
    find_lex $P5064, "$i"
    set $I5065, $P5064
    find_lex $P5066, "$past"
    unless_null $P5066, vivify_2024
    $P5066 = root_new ['parrot';'ResizablePMCArray']
  vivify_2024:
    set $P5067, $P5066[$I5065]
    unless_null $P5067, vivify_2025
    new $P5067, "Undef"
  vivify_2025:
    $P5067."named"(1)
  if_5048_end:
  if_5029_end:
.annotate 'line', 1889
    find_lex $P5068, "$i"
    clone $P5069, $P5068
    inc $P5068
  loop5070_next:
.annotate 'line', 1888
    goto loop5070_test
  loop5070_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5072, exception, 'type'
    eq $P5072, .CONTROL_LOOP_NEXT, loop5070_next
    eq $P5072, .CONTROL_LOOP_REDO, loop5070_redo
  loop5070_done:
    pop_eh 
.annotate 'line', 1899
    find_lex $P5073, "$/"
    find_lex $P5074, "$past"
    $P5075 = $P5073."!make"($P5074)
.annotate 'line', 1877
    .return ($P5075)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block4986"  :anon :subid("521_1300062003.824") :outer("520_1300062003.824")
.annotate 'line', 1879
    .const 'Sub' $P5008 = "522_1300062003.824" 
    capture_lex $P5008
.annotate 'line', 1880
    new $P4988, "Undef"
    .lex "$expr", $P4988
    find_lex $P4989, "$/"
    unless_null $P4989, vivify_2009
    $P4989 = root_new ['parrot';'Hash']
  vivify_2009:
    set $P4990, $P4989["EXPR"]
    unless_null $P4990, vivify_2010
    new $P4990, "Undef"
  vivify_2010:
    $P4991 = $P4990."ast"()
    store_lex "$expr", $P4991
.annotate 'line', 1881
    find_lex $P4996, "$expr"
    $S4997 = $P4996."name"()
    iseq $I4998, $S4997, "&infix:<,>"
    if $I4998, if_4995
    new $P4994, 'Integer'
    set $P4994, $I4998
    goto if_4995_end
  if_4995:
    find_lex $P4999, "$expr"
    $P5000 = $P4999."named"()
    isfalse $I5001, $P5000
    new $P4994, 'Integer'
    set $P4994, $I5001
  if_4995_end:
    if $P4994, if_4993
.annotate 'line', 1884
    find_lex $P5016, "$past"
    find_lex $P5017, "$expr"
    $P5018 = $P5016."push"($P5017)
    set $P4992, $P5018
.annotate 'line', 1881
    goto if_4993_end
  if_4993:
.annotate 'line', 1882
    find_lex $P5003, "$expr"
    $P5004 = $P5003."list"()
    defined $I5005, $P5004
    unless $I5005, for_undef_2011
    iter $P5002, $P5004
    new $P5014, 'ExceptionHandler'
    set_label $P5014, loop5013_handler
    $P5014."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5014
  loop5013_test:
    unless $P5002, loop5013_done
    shift $P5006, $P5002
  loop5013_redo:
    .const 'Sub' $P5008 = "522_1300062003.824" 
    capture_lex $P5008
    $P5008($P5006)
  loop5013_next:
    goto loop5013_test
  loop5013_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5015, exception, 'type'
    eq $P5015, .CONTROL_LOOP_NEXT, loop5013_next
    eq $P5015, .CONTROL_LOOP_REDO, loop5013_redo
  loop5013_done:
    pop_eh 
  for_undef_2011:
.annotate 'line', 1881
    set $P4992, $P5002
  if_4993_end:
.annotate 'line', 1879
    .return ($P4992)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5007"  :anon :subid("522_1300062003.824") :outer("521_1300062003.824")
    .param pmc param_5009
.annotate 'line', 1882
    .lex "$_", param_5009
    find_lex $P5010, "$past"
    find_lex $P5011, "$_"
    $P5012 = $P5010."push"($P5011)
    .return ($P5012)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<multi_declarator>"  :subid("523_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_5077
    .param pmc param_5078
.annotate 'line', 1902
    .lex "self", param_5077
    .lex "$/", param_5078
    find_lex $P5079, "$/"
    find_lex $P5080, "$/"
    unless_null $P5080, vivify_2026
    $P5080 = root_new ['parrot';'Hash']
  vivify_2026:
    set $P5081, $P5080["multi_declarator"]
    unless_null $P5081, vivify_2027
    new $P5081, "Undef"
  vivify_2027:
    $P5082 = $P5081."ast"()
    $P5083 = $P5079."!make"($P5082)
    .return ($P5083)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<value>"  :subid("524_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_5085
    .param pmc param_5086
.annotate 'line', 1904
    .lex "self", param_5085
    .lex "$/", param_5086
    find_lex $P5087, "$/"
    find_lex $P5088, "$/"
    unless_null $P5088, vivify_2028
    $P5088 = root_new ['parrot';'Hash']
  vivify_2028:
    set $P5089, $P5088["value"]
    unless_null $P5089, vivify_2029
    new $P5089, "Undef"
  vivify_2029:
    $P5090 = $P5089."ast"()
    $P5091 = $P5087."!make"($P5090)
    .return ($P5091)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<( )>"  :subid("525_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_5093
    .param pmc param_5094
.annotate 'line', 1906
    .lex "self", param_5093
    .lex "$/", param_5094
.annotate 'line', 1907
    find_lex $P5095, "$/"
.annotate 'line', 1908
    find_lex $P5098, "$/"
    unless_null $P5098, vivify_2030
    $P5098 = root_new ['parrot';'Hash']
  vivify_2030:
    set $P5099, $P5098["EXPR"]
    unless_null $P5099, vivify_2031
    new $P5099, "Undef"
  vivify_2031:
    if $P5099, if_5097
.annotate 'line', 1909
    get_hll_global $P5104, ["PAST"], "Op"
    find_lex $P5105, "$/"
    $P5106 = $P5104."new"("list" :named("pasttype"), $P5105 :named("node"))
    set $P5096, $P5106
.annotate 'line', 1908
    goto if_5097_end
  if_5097:
    find_lex $P5100, "$/"
    unless_null $P5100, vivify_2032
    $P5100 = root_new ['parrot';'Hash']
  vivify_2032:
    set $P5101, $P5100["EXPR"]
    unless_null $P5101, vivify_2033
    $P5101 = root_new ['parrot';'ResizablePMCArray']
  vivify_2033:
    set $P5102, $P5101[0]
    unless_null $P5102, vivify_2034
    new $P5102, "Undef"
  vivify_2034:
    $P5103 = $P5102."ast"()
    set $P5096, $P5103
  if_5097_end:
    $P5107 = $P5095."!make"($P5096)
.annotate 'line', 1906
    .return ($P5107)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<[ ]>"  :subid("526_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_5109
    .param pmc param_5110
.annotate 'line', 1912
    .lex "self", param_5109
    .lex "$/", param_5110
.annotate 'line', 1913
    new $P5111, "Undef"
    .lex "$past", $P5111
.annotate 'line', 1912
    find_lex $P5112, "$past"
.annotate 'line', 1914
    find_lex $P5114, "$/"
    unless_null $P5114, vivify_2035
    $P5114 = root_new ['parrot';'Hash']
  vivify_2035:
    set $P5115, $P5114["EXPR"]
    unless_null $P5115, vivify_2036
    new $P5115, "Undef"
  vivify_2036:
    if $P5115, if_5113
.annotate 'line', 1921
    get_hll_global $P5127, ["PAST"], "Op"
    $P5128 = $P5127."new"("list" :named("pasttype"))
    store_lex "$past", $P5128
.annotate 'line', 1920
    goto if_5113_end
  if_5113:
.annotate 'line', 1915
    find_lex $P5116, "$/"
    unless_null $P5116, vivify_2037
    $P5116 = root_new ['parrot';'Hash']
  vivify_2037:
    set $P5117, $P5116["EXPR"]
    unless_null $P5117, vivify_2038
    $P5117 = root_new ['parrot';'ResizablePMCArray']
  vivify_2038:
    set $P5118, $P5117[0]
    unless_null $P5118, vivify_2039
    new $P5118, "Undef"
  vivify_2039:
    $P5119 = $P5118."ast"()
    store_lex "$past", $P5119
.annotate 'line', 1916
    find_lex $P5121, "$past"
    $S5122 = $P5121."name"()
    isne $I5123, $S5122, "&infix:<,>"
    unless $I5123, if_5120_end
.annotate 'line', 1917
    get_hll_global $P5124, ["PAST"], "Op"
    find_lex $P5125, "$past"
    $P5126 = $P5124."new"($P5125, "list" :named("pasttype"))
    store_lex "$past", $P5126
  if_5120_end:
  if_5113_end:
.annotate 'line', 1923
    find_lex $P5129, "$past"
    $P5129."name"("&circumfix:<[ ]>")
.annotate 'line', 1924
    find_lex $P5130, "$/"
    find_lex $P5131, "$past"
    $P5132 = $P5130."!make"($P5131)
.annotate 'line', 1912
    .return ($P5132)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<ang>"  :subid("527_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_5134
    .param pmc param_5135
.annotate 'line', 1927
    .lex "self", param_5134
    .lex "$/", param_5135
    find_lex $P5136, "$/"
    find_lex $P5137, "$/"
    unless_null $P5137, vivify_2040
    $P5137 = root_new ['parrot';'Hash']
  vivify_2040:
    set $P5138, $P5137["quote_EXPR"]
    unless_null $P5138, vivify_2041
    new $P5138, "Undef"
  vivify_2041:
    $P5139 = $P5138."ast"()
    $P5140 = $P5136."!make"($P5139)
    .return ($P5140)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("528_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_5142
    .param pmc param_5143
.annotate 'line', 1928
    .lex "self", param_5142
    .lex "$/", param_5143
    find_lex $P5144, "$/"
    find_lex $P5145, "$/"
    unless_null $P5145, vivify_2042
    $P5145 = root_new ['parrot';'Hash']
  vivify_2042:
    set $P5146, $P5145["quote_EXPR"]
    unless_null $P5146, vivify_2043
    new $P5146, "Undef"
  vivify_2043:
    $P5147 = $P5146."ast"()
    $P5148 = $P5144."!make"($P5147)
    .return ($P5148)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<{ }>"  :subid("529_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_5150
    .param pmc param_5151
.annotate 'line', 1930
    .const 'Sub' $P5162 = "530_1300062003.824" 
    capture_lex $P5162
    .lex "self", param_5150
    .lex "$/", param_5151
.annotate 'line', 1931
    find_lex $P5154, "$/"
    unless_null $P5154, vivify_2044
    $P5154 = root_new ['parrot';'Hash']
  vivify_2044:
    set $P5155, $P5154["pblock"]
    unless_null $P5155, vivify_2045
    $P5155 = root_new ['parrot';'Hash']
  vivify_2045:
    set $P5156, $P5155["blockoid"]
    unless_null $P5156, vivify_2046
    $P5156 = root_new ['parrot';'Hash']
  vivify_2046:
    set $P5157, $P5156["statementlist"]
    unless_null $P5157, vivify_2047
    $P5157 = root_new ['parrot';'Hash']
  vivify_2047:
    set $P5158, $P5157["statement"]
    unless_null $P5158, vivify_2048
    new $P5158, "Undef"
  vivify_2048:
    set $N5159, $P5158
    isgt $I5160, $N5159, 0.0
    if $I5160, if_5153
.annotate 'line', 1936
    find_lex $P5175, "$/"
    unless_null $P5175, vivify_2049
    $P5175 = root_new ['parrot';'Hash']
  vivify_2049:
    set $P5176, $P5175["pblock"]
    unless_null $P5176, vivify_2050
    $P5176 = root_new ['parrot';'Hash']
  vivify_2050:
    set $P5177, $P5176["blockoid"]
    unless_null $P5177, vivify_2051
    $P5177 = root_new ['parrot';'Hash']
  vivify_2051:
    set $P5178, $P5177["you_are_here"]
    unless_null $P5178, vivify_2052
    new $P5178, "Undef"
  vivify_2052:
    if $P5178, if_5174
.annotate 'line', 1940
    find_lex $P5184, "$/"
    $P5185 = "vivitype"("%")
    $P5186 = $P5184."!make"($P5185)
.annotate 'line', 1939
    set $P5173, $P5186
.annotate 'line', 1936
    goto if_5174_end
  if_5174:
.annotate 'line', 1937
    find_lex $P5179, "$/"
    find_lex $P5180, "$/"
    unless_null $P5180, vivify_2053
    $P5180 = root_new ['parrot';'Hash']
  vivify_2053:
    set $P5181, $P5180["pblock"]
    unless_null $P5181, vivify_2054
    new $P5181, "Undef"
  vivify_2054:
    $P5182 = $P5181."ast"()
    $P5183 = $P5179."!make"($P5182)
.annotate 'line', 1936
    set $P5173, $P5183
  if_5174_end:
    set $P5152, $P5173
.annotate 'line', 1931
    goto if_5153_end
  if_5153:
    .const 'Sub' $P5162 = "530_1300062003.824" 
    capture_lex $P5162
    $P5172 = $P5162()
    set $P5152, $P5172
  if_5153_end:
.annotate 'line', 1930
    .return ($P5152)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5161"  :anon :subid("530_1300062003.824") :outer("529_1300062003.824")
.annotate 'line', 1932
    new $P5163, "Undef"
    .lex "$past", $P5163
    find_lex $P5164, "$/"
    unless_null $P5164, vivify_2055
    $P5164 = root_new ['parrot';'Hash']
  vivify_2055:
    set $P5165, $P5164["pblock"]
    unless_null $P5165, vivify_2056
    new $P5165, "Undef"
  vivify_2056:
    $P5166 = $P5165."ast"()
    store_lex "$past", $P5166
.annotate 'line', 1933
    new $P5167, "Integer"
    assign $P5167, 1
    find_lex $P5168, "$past"
    unless_null $P5168, vivify_2057
    $P5168 = root_new ['parrot';'Hash']
    store_lex "$past", $P5168
  vivify_2057:
    set $P5168["bareblock"], $P5167
.annotate 'line', 1934
    find_dynamic_lex $P5169, "$/"
    find_lex $P5170, "$past"
    $P5171 = $P5169."!make"($P5170)
.annotate 'line', 1931
    .return ($P5171)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<sigil>"  :subid("531_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_5188
    .param pmc param_5189
.annotate 'line', 1944
    .lex "self", param_5188
    .lex "$/", param_5189
.annotate 'line', 1945
    new $P5190, "Undef"
    .lex "$name", $P5190
    find_lex $P5193, "$/"
    unless_null $P5193, vivify_2058
    $P5193 = root_new ['parrot';'Hash']
  vivify_2058:
    set $P5194, $P5193["sigil"]
    unless_null $P5194, vivify_2059
    new $P5194, "Undef"
  vivify_2059:
    set $S5195, $P5194
    iseq $I5196, $S5195, "@"
    if $I5196, if_5192
.annotate 'line', 1946
    find_lex $P5200, "$/"
    unless_null $P5200, vivify_2060
    $P5200 = root_new ['parrot';'Hash']
  vivify_2060:
    set $P5201, $P5200["sigil"]
    unless_null $P5201, vivify_2061
    new $P5201, "Undef"
  vivify_2061:
    set $S5202, $P5201
    iseq $I5203, $S5202, "%"
    if $I5203, if_5199
    new $P5205, "String"
    assign $P5205, "item"
    set $P5198, $P5205
    goto if_5199_end
  if_5199:
    new $P5204, "String"
    assign $P5204, "hash"
    set $P5198, $P5204
  if_5199_end:
    set $P5191, $P5198
.annotate 'line', 1945
    goto if_5192_end
  if_5192:
    new $P5197, "String"
    assign $P5197, "list"
    set $P5191, $P5197
  if_5192_end:
    store_lex "$name", $P5191
.annotate 'line', 1948
    find_lex $P5206, "$/"
    get_hll_global $P5207, ["PAST"], "Op"
    find_lex $P5208, "$name"
    find_lex $P5209, "$/"
    unless_null $P5209, vivify_2062
    $P5209 = root_new ['parrot';'Hash']
  vivify_2062:
    set $P5210, $P5209["semilist"]
    unless_null $P5210, vivify_2063
    new $P5210, "Undef"
  vivify_2063:
    $P5211 = $P5210."ast"()
    $P5212 = $P5207."new"($P5211, "callmethod" :named("pasttype"), $P5208 :named("name"))
    $P5213 = $P5206."!make"($P5212)
.annotate 'line', 1944
    .return ($P5213)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "semilist"  :subid("532_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_5215
    .param pmc param_5216
.annotate 'line', 1951
    .lex "self", param_5215
    .lex "$/", param_5216
    find_lex $P5217, "$/"
    find_lex $P5218, "$/"
    unless_null $P5218, vivify_2064
    $P5218 = root_new ['parrot';'Hash']
  vivify_2064:
    set $P5219, $P5218["statement"]
    unless_null $P5219, vivify_2065
    new $P5219, "Undef"
  vivify_2065:
    $P5220 = $P5219."ast"()
    $P5221 = $P5217."!make"($P5220)
    .return ($P5221)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<[ ]>"  :subid("533_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_5223
    .param pmc param_5224
.annotate 'line', 1953
    .lex "self", param_5223
    .lex "$/", param_5224
.annotate 'line', 1954
    find_lex $P5225, "$/"
    get_hll_global $P5226, ["PAST"], "Var"
    find_lex $P5227, "$/"
    unless_null $P5227, vivify_2066
    $P5227 = root_new ['parrot';'Hash']
  vivify_2066:
    set $P5228, $P5227["EXPR"]
    unless_null $P5228, vivify_2067
    new $P5228, "Undef"
  vivify_2067:
    $P5229 = $P5228."ast"()
.annotate 'line', 1956
    $P5230 = "vivitype"("@")
    $P5231 = $P5226."new"($P5229, "keyed_int" :named("scope"), "Undef" :named("viviself"), $P5230 :named("vivibase"))
.annotate 'line', 1954
    $P5232 = $P5225."!make"($P5231)
.annotate 'line', 1953
    .return ($P5232)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<{ }>"  :subid("534_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_5234
    .param pmc param_5235
.annotate 'line', 1959
    .lex "self", param_5234
    .lex "$/", param_5235
.annotate 'line', 1960
    find_lex $P5236, "$/"
    get_hll_global $P5237, ["PAST"], "Var"
    find_lex $P5238, "$/"
    unless_null $P5238, vivify_2068
    $P5238 = root_new ['parrot';'Hash']
  vivify_2068:
    set $P5239, $P5238["EXPR"]
    unless_null $P5239, vivify_2069
    new $P5239, "Undef"
  vivify_2069:
    $P5240 = $P5239."ast"()
.annotate 'line', 1962
    $P5241 = "vivitype"("%")
    $P5242 = $P5237."new"($P5240, "keyed" :named("scope"), "Undef" :named("viviself"), $P5241 :named("vivibase"))
.annotate 'line', 1960
    $P5243 = $P5236."!make"($P5242)
.annotate 'line', 1959
    .return ($P5243)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<ang>"  :subid("535_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_5245
    .param pmc param_5246
.annotate 'line', 1965
    .lex "self", param_5245
    .lex "$/", param_5246
.annotate 'line', 1966
    find_lex $P5247, "$/"
    get_hll_global $P5248, ["PAST"], "Var"
    find_lex $P5249, "$/"
    unless_null $P5249, vivify_2070
    $P5249 = root_new ['parrot';'Hash']
  vivify_2070:
    set $P5250, $P5249["quote_EXPR"]
    unless_null $P5250, vivify_2071
    new $P5250, "Undef"
  vivify_2071:
    $P5251 = $P5250."ast"()
.annotate 'line', 1968
    $P5252 = "vivitype"("%")
    $P5253 = $P5248."new"($P5251, "keyed" :named("scope"), "Undef" :named("viviself"), $P5252 :named("vivibase"))
.annotate 'line', 1966
    $P5254 = $P5247."!make"($P5253)
.annotate 'line', 1965
    .return ($P5254)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<( )>"  :subid("536_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_5256
    .param pmc param_5257
.annotate 'line', 1971
    .lex "self", param_5256
    .lex "$/", param_5257
.annotate 'line', 1972
    find_lex $P5258, "$/"
    find_lex $P5259, "$/"
    unless_null $P5259, vivify_2072
    $P5259 = root_new ['parrot';'Hash']
  vivify_2072:
    set $P5260, $P5259["arglist"]
    unless_null $P5260, vivify_2073
    new $P5260, "Undef"
  vivify_2073:
    $P5261 = $P5260."ast"()
    $P5262 = $P5258."!make"($P5261)
.annotate 'line', 1971
    .return ($P5262)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "value"  :subid("537_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_5264
    .param pmc param_5265
.annotate 'line', 1975
    .lex "self", param_5264
    .lex "$/", param_5265
.annotate 'line', 1976
    find_lex $P5266, "$/"
    find_lex $P5269, "$/"
    unless_null $P5269, vivify_2074
    $P5269 = root_new ['parrot';'Hash']
  vivify_2074:
    set $P5270, $P5269["quote"]
    unless_null $P5270, vivify_2075
    new $P5270, "Undef"
  vivify_2075:
    if $P5270, if_5268
    find_lex $P5274, "$/"
    unless_null $P5274, vivify_2076
    $P5274 = root_new ['parrot';'Hash']
  vivify_2076:
    set $P5275, $P5274["number"]
    unless_null $P5275, vivify_2077
    new $P5275, "Undef"
  vivify_2077:
    $P5276 = $P5275."ast"()
    set $P5267, $P5276
    goto if_5268_end
  if_5268:
    find_lex $P5271, "$/"
    unless_null $P5271, vivify_2078
    $P5271 = root_new ['parrot';'Hash']
  vivify_2078:
    set $P5272, $P5271["quote"]
    unless_null $P5272, vivify_2079
    new $P5272, "Undef"
  vivify_2079:
    $P5273 = $P5272."ast"()
    set $P5267, $P5273
  if_5268_end:
    $P5277 = $P5266."!make"($P5267)
.annotate 'line', 1975
    .return ($P5277)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "number"  :subid("538_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_5279
    .param pmc param_5280
.annotate 'line', 1979
    .lex "self", param_5279
    .lex "$/", param_5280
.annotate 'line', 1980
    new $P5281, "Undef"
    .lex "$value", $P5281
    find_lex $P5284, "$/"
    unless_null $P5284, vivify_2080
    $P5284 = root_new ['parrot';'Hash']
  vivify_2080:
    set $P5285, $P5284["dec_number"]
    unless_null $P5285, vivify_2081
    new $P5285, "Undef"
  vivify_2081:
    if $P5285, if_5283
    find_lex $P5289, "$/"
    unless_null $P5289, vivify_2082
    $P5289 = root_new ['parrot';'Hash']
  vivify_2082:
    set $P5290, $P5289["integer"]
    unless_null $P5290, vivify_2083
    new $P5290, "Undef"
  vivify_2083:
    $P5291 = $P5290."ast"()
    set $P5282, $P5291
    goto if_5283_end
  if_5283:
    find_lex $P5286, "$/"
    unless_null $P5286, vivify_2084
    $P5286 = root_new ['parrot';'Hash']
  vivify_2084:
    set $P5287, $P5286["dec_number"]
    unless_null $P5287, vivify_2085
    new $P5287, "Undef"
  vivify_2085:
    $P5288 = $P5287."ast"()
    set $P5282, $P5288
  if_5283_end:
    store_lex "$value", $P5282
.annotate 'line', 1981
    find_lex $P5293, "$/"
    unless_null $P5293, vivify_2086
    $P5293 = root_new ['parrot';'Hash']
  vivify_2086:
    set $P5294, $P5293["sign"]
    unless_null $P5294, vivify_2087
    new $P5294, "Undef"
  vivify_2087:
    set $S5295, $P5294
    iseq $I5296, $S5295, "-"
    unless $I5296, if_5292_end
    find_lex $P5297, "$value"
    neg $P5298, $P5297
    store_lex "$value", $P5298
  if_5292_end:
.annotate 'line', 1982
    find_lex $P5299, "$/"
    get_hll_global $P5300, ["PAST"], "Val"
    find_lex $P5301, "$value"
    $P5302 = $P5300."new"($P5301 :named("value"))
    $P5303 = $P5299."!make"($P5302)
.annotate 'line', 1979
    .return ($P5303)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<apos>"  :subid("539_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_5305
    .param pmc param_5306
.annotate 'line', 1985
    .lex "self", param_5305
    .lex "$/", param_5306
    find_lex $P5307, "$/"
    find_lex $P5308, "$/"
    unless_null $P5308, vivify_2088
    $P5308 = root_new ['parrot';'Hash']
  vivify_2088:
    set $P5309, $P5308["quote_EXPR"]
    unless_null $P5309, vivify_2089
    new $P5309, "Undef"
  vivify_2089:
    $P5310 = $P5309."ast"()
    $P5311 = $P5307."!make"($P5310)
    .return ($P5311)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<dblq>"  :subid("540_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_5313
    .param pmc param_5314
.annotate 'line', 1986
    .lex "self", param_5313
    .lex "$/", param_5314
    find_lex $P5315, "$/"
    find_lex $P5316, "$/"
    unless_null $P5316, vivify_2090
    $P5316 = root_new ['parrot';'Hash']
  vivify_2090:
    set $P5317, $P5316["quote_EXPR"]
    unless_null $P5317, vivify_2091
    new $P5317, "Undef"
  vivify_2091:
    $P5318 = $P5317."ast"()
    $P5319 = $P5315."!make"($P5318)
    .return ($P5319)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<qq>"  :subid("541_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_5321
    .param pmc param_5322
.annotate 'line', 1987
    .lex "self", param_5321
    .lex "$/", param_5322
    find_lex $P5323, "$/"
    find_lex $P5324, "$/"
    unless_null $P5324, vivify_2092
    $P5324 = root_new ['parrot';'Hash']
  vivify_2092:
    set $P5325, $P5324["quote_EXPR"]
    unless_null $P5325, vivify_2093
    new $P5325, "Undef"
  vivify_2093:
    $P5326 = $P5325."ast"()
    $P5327 = $P5323."!make"($P5326)
    .return ($P5327)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<q>"  :subid("542_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_5329
    .param pmc param_5330
.annotate 'line', 1988
    .lex "self", param_5329
    .lex "$/", param_5330
    find_lex $P5331, "$/"
    find_lex $P5332, "$/"
    unless_null $P5332, vivify_2094
    $P5332 = root_new ['parrot';'Hash']
  vivify_2094:
    set $P5333, $P5332["quote_EXPR"]
    unless_null $P5333, vivify_2095
    new $P5333, "Undef"
  vivify_2095:
    $P5334 = $P5333."ast"()
    $P5335 = $P5331."!make"($P5334)
    .return ($P5335)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q>"  :subid("543_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_5337
    .param pmc param_5338
.annotate 'line', 1989
    .lex "self", param_5337
    .lex "$/", param_5338
    find_lex $P5339, "$/"
    find_lex $P5340, "$/"
    unless_null $P5340, vivify_2096
    $P5340 = root_new ['parrot';'Hash']
  vivify_2096:
    set $P5341, $P5340["quote_EXPR"]
    unless_null $P5341, vivify_2097
    new $P5341, "Undef"
  vivify_2097:
    $P5342 = $P5341."ast"()
    $P5343 = $P5339."!make"($P5342)
    .return ($P5343)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q:PIR>"  :subid("544_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_5345
    .param pmc param_5346
.annotate 'line', 1990
    .lex "self", param_5345
    .lex "$/", param_5346
.annotate 'line', 1991
    find_lex $P5347, "$/"
    get_hll_global $P5348, ["PAST"], "Op"
    find_lex $P5349, "$/"
    unless_null $P5349, vivify_2098
    $P5349 = root_new ['parrot';'Hash']
  vivify_2098:
    set $P5350, $P5349["quote_EXPR"]
    unless_null $P5350, vivify_2099
    new $P5350, "Undef"
  vivify_2099:
    $P5351 = $P5350."ast"()
    $P5352 = $P5351."value"()
    find_lex $P5353, "$/"
    $P5354 = $P5348."new"($P5352 :named("inline"), "inline" :named("pasttype"), $P5353 :named("node"))
    $P5355 = $P5347."!make"($P5354)
.annotate 'line', 1990
    .return ($P5355)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "quote:sym</ />"  :subid("545_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_5359
    .param pmc param_5360
    .param pmc param_5361 :optional
    .param int has_param_5361 :opt_flag
.annotate 'line', 1996
    new $P5358, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P5358, control_5357
    push_eh $P5358
    .lex "self", param_5359
    .lex "$/", param_5360
    if has_param_5361, optparam_2100
    new $P5362, "Undef"
    set param_5361, $P5362
  optparam_2100:
    .lex "$key", param_5361
.annotate 'line', 2006
    new $P5363, "Undef"
    .lex "$regex", $P5363
.annotate 'line', 2008
    new $P5364, "Undef"
    .lex "$past", $P5364
.annotate 'line', 1997
    find_lex $P5366, "$key"
    set $S5367, $P5366
    iseq $I5368, $S5367, "open"
    unless $I5368, if_5365_end
.annotate 'line', 1998

                null $P0
                set_hll_global ['Regex';'P6Regex';'Actions'], '$REGEXNAME', $P0
            
.annotate 'line', 2002
    get_global $P5369, "@BLOCK"
    unless_null $P5369, vivify_2101
    $P5369 = root_new ['parrot';'ResizablePMCArray']
  vivify_2101:
    set $P5370, $P5369[0]
    unless_null $P5370, vivify_2102
    new $P5370, "Undef"
  vivify_2102:
    $P5370."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 2003
    get_global $P5371, "@BLOCK"
    unless_null $P5371, vivify_2103
    $P5371 = root_new ['parrot';'ResizablePMCArray']
  vivify_2103:
    set $P5372, $P5371[0]
    unless_null $P5372, vivify_2104
    new $P5372, "Undef"
  vivify_2104:
    $P5372."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 2004
    new $P5373, "Exception"
    set $P5373['type'], .CONTROL_RETURN
    new $P5374, "Integer"
    assign $P5374, 0
    setattribute $P5373, 'payload', $P5374
    throw $P5373
  if_5365_end:
.annotate 'line', 2007
    get_hll_global $P5375, ["Regex";"P6Regex";"Actions"], "buildsub"
    find_lex $P5376, "$/"
    unless_null $P5376, vivify_2105
    $P5376 = root_new ['parrot';'Hash']
  vivify_2105:
    set $P5377, $P5376["p6regex"]
    unless_null $P5377, vivify_2106
    new $P5377, "Undef"
  vivify_2106:
    $P5378 = $P5377."ast"()
    get_global $P5379, "@BLOCK"
    $P5380 = $P5379."shift"()
    $P5381 = $P5375($P5378, $P5380)
    store_lex "$regex", $P5381
.annotate 'line', 2009
    get_hll_global $P5382, ["PAST"], "Op"
.annotate 'line', 2011
    get_hll_global $P5383, ["PAST"], "Var"
    new $P5384, "ResizablePMCArray"
    push $P5384, "Regex"
    $P5385 = $P5383."new"("Regex" :named("name"), $P5384 :named("namespace"), "package" :named("scope"))
    find_lex $P5386, "$regex"
    $P5387 = $P5382."new"($P5385, $P5386, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 2009
    store_lex "$past", $P5387
.annotate 'line', 2015
    find_lex $P5388, "$regex"
    find_lex $P5389, "$past"
    unless_null $P5389, vivify_2107
    $P5389 = root_new ['parrot';'Hash']
    store_lex "$past", $P5389
  vivify_2107:
    set $P5389["sink"], $P5388
.annotate 'line', 2016
    find_lex $P5390, "$/"
    find_lex $P5391, "$past"
    $P5392 = $P5390."!make"($P5391)
.annotate 'line', 1996
    .return ($P5392)
  control_5357:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5393, exception, "payload"
    .return ($P5393)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<$>"  :subid("546_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_5395
    .param pmc param_5396
.annotate 'line', 2019
    .lex "self", param_5395
    .lex "$/", param_5396
    find_lex $P5397, "$/"
    find_lex $P5398, "$/"
    unless_null $P5398, vivify_2108
    $P5398 = root_new ['parrot';'Hash']
  vivify_2108:
    set $P5399, $P5398["variable"]
    unless_null $P5399, vivify_2109
    new $P5399, "Undef"
  vivify_2109:
    $P5400 = $P5399."ast"()
    $P5401 = $P5397."!make"($P5400)
    .return ($P5401)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<{ }>"  :subid("547_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_5403
    .param pmc param_5404
.annotate 'line', 2020
    .lex "self", param_5403
    .lex "$/", param_5404
.annotate 'line', 2021
    find_lex $P5405, "$/"
    get_hll_global $P5406, ["PAST"], "Op"
.annotate 'line', 2022
    find_lex $P5407, "$/"
    unless_null $P5407, vivify_2110
    $P5407 = root_new ['parrot';'Hash']
  vivify_2110:
    set $P5408, $P5407["block"]
    unless_null $P5408, vivify_2111
    new $P5408, "Undef"
  vivify_2111:
    $P5409 = $P5408."ast"()
    $P5410 = "block_immediate"($P5409)
    find_lex $P5411, "$/"
    $P5412 = $P5406."new"($P5410, "set S*" :named("pirop"), $P5411 :named("node"))
.annotate 'line', 2021
    $P5413 = $P5405."!make"($P5412)
.annotate 'line', 2020
    .return ($P5413)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<esc>"  :subid("548_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_5415
    .param pmc param_5416
.annotate 'line', 2025
    .lex "self", param_5415
    .lex "$/", param_5416
    find_lex $P5417, "$/"
    $P5418 = $P5417."!make"("\e")
    .return ($P5418)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<.>"  :subid("549_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_5420
    .param pmc param_5421
.annotate 'line', 2029
    .lex "self", param_5420
    .lex "$/", param_5421
    find_lex $P5422, "$/"
    find_lex $P5423, "$/"
    unless_null $P5423, vivify_2112
    $P5423 = root_new ['parrot';'Hash']
  vivify_2112:
    set $P5424, $P5423["dotty"]
    unless_null $P5424, vivify_2113
    new $P5424, "Undef"
  vivify_2113:
    $P5425 = $P5424."ast"()
    $P5426 = $P5422."!make"($P5425)
    .return ($P5426)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<++>"  :subid("550_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_5428
    .param pmc param_5429
.annotate 'line', 2031
    .lex "self", param_5428
    .lex "$/", param_5429
.annotate 'line', 2032
    find_lex $P5430, "$/"
    get_hll_global $P5431, ["PAST"], "Op"
.annotate 'line', 2033
    new $P5432, "ResizablePMCArray"
    push $P5432, "    clone %r, %0"
    push $P5432, "    inc %0"
    $P5433 = $P5431."new"("postfix:<++>" :named("name"), $P5432 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 2032
    $P5434 = $P5430."!make"($P5433)
.annotate 'line', 2031
    .return ($P5434)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<-->"  :subid("551_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_5436
    .param pmc param_5437
.annotate 'line', 2037
    .lex "self", param_5436
    .lex "$/", param_5437
.annotate 'line', 2038
    find_lex $P5438, "$/"
    get_hll_global $P5439, ["PAST"], "Op"
.annotate 'line', 2039
    new $P5440, "ResizablePMCArray"
    push $P5440, "    clone %r, %0"
    push $P5440, "    dec %0"
    $P5441 = $P5439."new"("postfix:<-->" :named("name"), $P5440 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 2038
    $P5442 = $P5438."!make"($P5441)
.annotate 'line', 2037
    .return ($P5442)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "prefix:sym<make>"  :subid("552_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_5444
    .param pmc param_5445
.annotate 'line', 2043
    .lex "self", param_5444
    .lex "$/", param_5445
.annotate 'line', 2044
    find_lex $P5446, "$/"
    get_hll_global $P5447, ["PAST"], "Op"
.annotate 'line', 2045
    get_hll_global $P5448, ["PAST"], "Var"
    $P5449 = $P5448."new"("$/" :named("name"), "contextual" :named("scope"))
    find_lex $P5450, "$/"
    $P5451 = $P5447."new"($P5449, "callmethod" :named("pasttype"), "!make" :named("name"), $P5450 :named("node"))
.annotate 'line', 2044
    $P5452 = $P5446."!make"($P5451)
.annotate 'line', 2043
    .return ($P5452)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<next>"  :subid("553_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_5455
    .param pmc param_5456
.annotate 'line', 2061
    .lex "self", param_5455
    .lex "$/", param_5456
    find_lex $P5457, "$/"
    $P5458 = "control"($P5457, "CONTROL_LOOP_NEXT")
    .return ($P5458)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<last>"  :subid("554_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_5460
    .param pmc param_5461
.annotate 'line', 2062
    .lex "self", param_5460
    .lex "$/", param_5461
    find_lex $P5462, "$/"
    $P5463 = "control"($P5462, "CONTROL_LOOP_LAST")
    .return ($P5463)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<redo>"  :subid("555_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_5465
    .param pmc param_5466
.annotate 'line', 2063
    .lex "self", param_5465
    .lex "$/", param_5466
    find_lex $P5467, "$/"
    $P5468 = "control"($P5467, "CONTROL_LOOP_REDO")
    .return ($P5468)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "infix:sym<~~>"  :subid("556_1300062003.824") :outer("405_1300062003.824")
    .param pmc param_5470
    .param pmc param_5471
.annotate 'line', 2065
    .lex "self", param_5470
    .lex "$/", param_5471
.annotate 'line', 2066
    find_lex $P5472, "$/"
    get_hll_global $P5473, ["PAST"], "Op"
    find_lex $P5474, "$/"
    $P5475 = $P5473."new"("callmethod" :named("pasttype"), "ACCEPTS" :named("name"), $P5474 :named("node"))
    $P5476 = $P5472."!make"($P5475)
.annotate 'line', 2065
    .return ($P5476)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "_block5701"  :subid("558_1300062003.824") :outer("10_1300062003.824")
.annotate 'line', 2070
    .const 'Sub' $P5801 = "566_1300062003.824" 
    capture_lex $P5801
    .const 'Sub' $P5776 = "565_1300062003.824" 
    capture_lex $P5776
    .const 'Sub' $P5765 = "564_1300062003.824" 
    capture_lex $P5765
    .const 'Sub' $P5750 = "563_1300062003.824" 
    capture_lex $P5750
    .const 'Sub' $P5739 = "562_1300062003.824" 
    capture_lex $P5739
    .const 'Sub' $P5728 = "561_1300062003.824" 
    capture_lex $P5728
    .const 'Sub' $P5717 = "560_1300062003.824" 
    capture_lex $P5717
    .const 'Sub' $P5704 = "559_1300062003.824" 
    capture_lex $P5704
    get_global $P5703, "$?CLASS"
.annotate 'line', 2104
    .const 'Sub' $P5776 = "565_1300062003.824" 
    newclosure $P5799, $P5776
.annotate 'line', 2070
    .return ($P5799)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "" :load :init :subid("post2114") :outer("558_1300062003.824")
.annotate 'line', 2070
    get_hll_global $P5702, ["NQP";"RegexActions"], "_block5701" 
    .local pmc block
    set block, $P5702
    .const 'Sub' $P5801 = "566_1300062003.824" 
    capture_lex $P5801
    $P5801()
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "_block5800"  :anon :subid("566_1300062003.824") :outer("558_1300062003.824")
.annotate 'line', 2070
    nqp_get_sc_object $P5802, "1300061983.846", 3
    .local pmc type_obj
    set type_obj, $P5802
    set_global "$?CLASS", type_obj
    get_how $P5803, type_obj
    .const 'Sub' $P5804 = "559_1300062003.824" 
    $P5803."add_method"(type_obj, "metachar:sym<:my>", $P5804)
    get_how $P5805, type_obj
    .const 'Sub' $P5806 = "560_1300062003.824" 
    $P5805."add_method"(type_obj, "metachar:sym<{ }>", $P5806)
    get_how $P5807, type_obj
    .const 'Sub' $P5808 = "561_1300062003.824" 
    $P5807."add_method"(type_obj, "metachar:sym<nqpvar>", $P5808)
    get_how $P5809, type_obj
    .const 'Sub' $P5810 = "562_1300062003.824" 
    $P5809."add_method"(type_obj, "assertion:sym<{ }>", $P5810)
    get_how $P5811, type_obj
    .const 'Sub' $P5812 = "563_1300062003.824" 
    $P5811."add_method"(type_obj, "assertion:sym<?{ }>", $P5812)
    get_how $P5813, type_obj
    .const 'Sub' $P5814 = "564_1300062003.824" 
    $P5813."add_method"(type_obj, "assertion:sym<var>", $P5814)
    get_how $P5815, type_obj
    .const 'Sub' $P5816 = "565_1300062003.824" 
    $P5815."add_method"(type_obj, "codeblock", $P5816)
    get_how $P5817, type_obj
    get_hll_global $P5818, ["Regex";"P6Regex"], "Actions"
    $P5817."add_parent"(type_obj, $P5818)
    get_how $P5819, type_obj
    $P5820 = $P5819."compose"(type_obj)
    .return ($P5820)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<:my>"  :subid("559_1300062003.824") :outer("558_1300062003.824")
    .param pmc param_5705
    .param pmc param_5706
.annotate 'line', 2072
    .lex "self", param_5705
    .lex "$/", param_5706
.annotate 'line', 2073
    new $P5707, "Undef"
    .lex "$past", $P5707
    find_lex $P5708, "$/"
    unless_null $P5708, vivify_2115
    $P5708 = root_new ['parrot';'Hash']
  vivify_2115:
    set $P5709, $P5708["statement"]
    unless_null $P5709, vivify_2116
    new $P5709, "Undef"
  vivify_2116:
    $P5710 = $P5709."ast"()
    store_lex "$past", $P5710
.annotate 'line', 2074
    find_lex $P5711, "$/"
    get_hll_global $P5712, ["PAST"], "Regex"
    find_lex $P5713, "$past"
    find_lex $P5714, "$/"
    $P5715 = $P5712."new"($P5713, "pastnode" :named("pasttype"), "declarative" :named("subtype"), $P5714 :named("node"))
    $P5716 = $P5711."!make"($P5715)
.annotate 'line', 2072
    .return ($P5716)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<{ }>"  :subid("560_1300062003.824") :outer("558_1300062003.824")
    .param pmc param_5718
    .param pmc param_5719
.annotate 'line', 2078
    .lex "self", param_5718
    .lex "$/", param_5719
.annotate 'line', 2079
    find_lex $P5720, "$/"
    get_hll_global $P5721, ["PAST"], "Regex"
    find_lex $P5722, "$/"
    unless_null $P5722, vivify_2117
    $P5722 = root_new ['parrot';'Hash']
  vivify_2117:
    set $P5723, $P5722["codeblock"]
    unless_null $P5723, vivify_2118
    new $P5723, "Undef"
  vivify_2118:
    $P5724 = $P5723."ast"()
    find_lex $P5725, "$/"
    $P5726 = $P5721."new"($P5724, "pastnode" :named("pasttype"), $P5725 :named("node"))
    $P5727 = $P5720."!make"($P5726)
.annotate 'line', 2078
    .return ($P5727)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<nqpvar>"  :subid("561_1300062003.824") :outer("558_1300062003.824")
    .param pmc param_5729
    .param pmc param_5730
.annotate 'line', 2083
    .lex "self", param_5729
    .lex "$/", param_5730
.annotate 'line', 2084
    find_lex $P5731, "$/"
    get_hll_global $P5732, ["PAST"], "Regex"
    find_lex $P5733, "$/"
    unless_null $P5733, vivify_2119
    $P5733 = root_new ['parrot';'Hash']
  vivify_2119:
    set $P5734, $P5733["var"]
    unless_null $P5734, vivify_2120
    new $P5734, "Undef"
  vivify_2120:
    $P5735 = $P5734."ast"()
    find_lex $P5736, "$/"
    $P5737 = $P5732."new"("!INTERPOLATE", $P5735, "subrule" :named("pasttype"), "method" :named("subtype"), $P5736 :named("node"))
    $P5738 = $P5731."!make"($P5737)
.annotate 'line', 2083
    .return ($P5738)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<{ }>"  :subid("562_1300062003.824") :outer("558_1300062003.824")
    .param pmc param_5740
    .param pmc param_5741
.annotate 'line', 2088
    .lex "self", param_5740
    .lex "$/", param_5741
.annotate 'line', 2089
    find_lex $P5742, "$/"
    get_hll_global $P5743, ["PAST"], "Regex"
    find_lex $P5744, "$/"
    unless_null $P5744, vivify_2121
    $P5744 = root_new ['parrot';'Hash']
  vivify_2121:
    set $P5745, $P5744["codeblock"]
    unless_null $P5745, vivify_2122
    new $P5745, "Undef"
  vivify_2122:
    $P5746 = $P5745."ast"()
    find_lex $P5747, "$/"
    $P5748 = $P5743."new"("!INTERPOLATE_REGEX", $P5746, "subrule" :named("pasttype"), "method" :named("subtype"), $P5747 :named("node"))
    $P5749 = $P5742."!make"($P5748)
.annotate 'line', 2088
    .return ($P5749)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<?{ }>"  :subid("563_1300062003.824") :outer("558_1300062003.824")
    .param pmc param_5751
    .param pmc param_5752
.annotate 'line', 2093
    .lex "self", param_5751
    .lex "$/", param_5752
.annotate 'line', 2094
    find_lex $P5753, "$/"
    get_hll_global $P5754, ["PAST"], "Regex"
    find_lex $P5755, "$/"
    unless_null $P5755, vivify_2123
    $P5755 = root_new ['parrot';'Hash']
  vivify_2123:
    set $P5756, $P5755["codeblock"]
    unless_null $P5756, vivify_2124
    new $P5756, "Undef"
  vivify_2124:
    $P5757 = $P5756."ast"()
.annotate 'line', 2095
    find_lex $P5758, "$/"
    unless_null $P5758, vivify_2125
    $P5758 = root_new ['parrot';'Hash']
  vivify_2125:
    set $P5759, $P5758["zw"]
    unless_null $P5759, vivify_2126
    new $P5759, "Undef"
  vivify_2126:
    set $S5760, $P5759
    iseq $I5761, $S5760, "!"
    find_lex $P5762, "$/"
    $P5763 = $P5754."new"($P5757, "zerowidth" :named("subtype"), $I5761 :named("negate"), "pastnode" :named("pasttype"), $P5762 :named("node"))
.annotate 'line', 2094
    $P5764 = $P5753."!make"($P5763)
.annotate 'line', 2093
    .return ($P5764)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<var>"  :subid("564_1300062003.824") :outer("558_1300062003.824")
    .param pmc param_5766
    .param pmc param_5767
.annotate 'line', 2099
    .lex "self", param_5766
    .lex "$/", param_5767
.annotate 'line', 2100
    find_lex $P5768, "$/"
    get_hll_global $P5769, ["PAST"], "Regex"
    find_lex $P5770, "$/"
    unless_null $P5770, vivify_2127
    $P5770 = root_new ['parrot';'Hash']
  vivify_2127:
    set $P5771, $P5770["var"]
    unless_null $P5771, vivify_2128
    new $P5771, "Undef"
  vivify_2128:
    $P5772 = $P5771."ast"()
    find_lex $P5773, "$/"
    $P5774 = $P5769."new"("!INTERPOLATE_REGEX", $P5772, "subrule" :named("pasttype"), "method" :named("subtype"), $P5773 :named("node"))
    $P5775 = $P5768."!make"($P5774)
.annotate 'line', 2099
    .return ($P5775)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "codeblock"  :subid("565_1300062003.824") :outer("558_1300062003.824")
    .param pmc param_5777
    .param pmc param_5778
.annotate 'line', 2104
    .lex "self", param_5777
    .lex "$/", param_5778
.annotate 'line', 2105
    new $P5779, "Undef"
    .lex "$block", $P5779
.annotate 'line', 2107
    new $P5780, "Undef"
    .lex "$past", $P5780
.annotate 'line', 2105
    find_lex $P5781, "$/"
    unless_null $P5781, vivify_2129
    $P5781 = root_new ['parrot';'Hash']
  vivify_2129:
    set $P5782, $P5781["block"]
    unless_null $P5782, vivify_2130
    new $P5782, "Undef"
  vivify_2130:
    $P5783 = $P5782."ast"()
    store_lex "$block", $P5783
.annotate 'line', 2106
    find_lex $P5784, "$block"
    $P5784."blocktype"("immediate")
.annotate 'line', 2108
    get_hll_global $P5785, ["PAST"], "Stmts"
.annotate 'line', 2109
    get_hll_global $P5786, ["PAST"], "Op"
.annotate 'line', 2110
    get_hll_global $P5787, ["PAST"], "Var"
    $P5788 = $P5787."new"("$/" :named("name"))
.annotate 'line', 2111
    get_hll_global $P5789, ["PAST"], "Op"
.annotate 'line', 2112
    get_hll_global $P5790, ["PAST"], "Var"
    $P5791 = $P5790."new"(unicode:"$\x{a2}" :named("name"))
    $P5792 = $P5789."new"($P5791, "MATCH" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 2111
    $P5793 = $P5786."new"($P5788, $P5792, "bind" :named("pasttype"))
.annotate 'line', 2109
    find_lex $P5794, "$block"
    $P5795 = $P5785."new"($P5793, $P5794)
.annotate 'line', 2108
    store_lex "$past", $P5795
.annotate 'line', 2120
    find_lex $P5796, "$/"
    find_lex $P5797, "$past"
    $P5798 = $P5796."!make"($P5797)
.annotate 'line', 2104
    .return ($P5798)
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "_block5821"  :subid("567_1300062003.824") :outer("10_1300062003.824")
.annotate 'line', 2125
    .const 'Sub' $P5825 = "568_1300062003.824" 
    capture_lex $P5825
    get_global $P5823, "$?CLASS"
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "" :load :init :subid("post2131") :outer("567_1300062003.824")
.annotate 'line', 2125
    get_hll_global $P5822, ["NQP";"Compiler"], "_block5821" 
    .local pmc block
    set block, $P5822
    .const 'Sub' $P5825 = "568_1300062003.824" 
    capture_lex $P5825
    $P5825()
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "_block5824"  :anon :subid("568_1300062003.824") :outer("567_1300062003.824")
.annotate 'line', 2125
    nqp_get_sc_object $P5826, "1300061983.846", 4
    .local pmc type_obj
    set type_obj, $P5826
    set_global "$?CLASS", type_obj
    get_how $P5827, type_obj
    get_hll_global $P5828, ["HLL"], "Compiler"
    $P5827."add_parent"(type_obj, $P5828)
    get_how $P5829, type_obj
    $P5830 = $P5829."compose"(type_obj)
    .return ($P5830)
.end


.HLL "nqp"

.namespace []
.sub "_block5835" :load :anon :subid("569_1300062003.824")
.annotate 'line', 1
    .const 'Sub' $P5837 = "10_1300062003.824" 
    $P5838 = $P5837()
    .return ($P5838)
.end

