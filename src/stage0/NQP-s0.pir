
.HLL "nqp"

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1303401201.841")
    .param pmc param_13 :slurpy
.annotate 'line', 0
    get_hll_global $P6145, ["NQP";"Compiler"], "_block6144" 
    capture_lex $P6145
    get_hll_global $P6024, ["NQP";"RegexActions"], "_block6023" 
    capture_lex $P6024
    get_hll_global $P2597, ["NQP";"Actions"], "_block2596" 
    capture_lex $P2597
    get_hll_global $P2493, ["NQP";"Regex"], "_block2492" 
    capture_lex $P2493
    get_hll_global $P36, ["NQP";"Grammar"], "_block35" 
    capture_lex $P36
    .const 'Sub' $P16 = "11_1303401201.841" 
    capture_lex $P16
.annotate 'line', 1
    .lex "@ARGS", param_13
    .lex "GLOBALish", $P14
    .lex "$?PACKAGE", $P15
.annotate 'line', 2241
    .const 'Sub' $P16 = "11_1303401201.841" 
    newclosure $P34, $P16
    .lex "MAIN", $P34
.annotate 'line', 1
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
.annotate 'line', 9
    get_hll_global $P36, ["NQP";"Grammar"], "_block35" 
    capture_lex $P36
    $P36()
.annotate 'line', 727
    get_hll_global $P2493, ["NQP";"Regex"], "_block2492" 
    capture_lex $P2493
    $P2493()
.annotate 'line', 770
    get_hll_global $P2597, ["NQP";"Actions"], "_block2596" 
    capture_lex $P2597
    $P2597()
.annotate 'line', 2183
    get_hll_global $P6024, ["NQP";"RegexActions"], "_block6023" 
    capture_lex $P6024
    $P6024()
.annotate 'line', 2238
    get_hll_global $P6145, ["NQP";"Compiler"], "_block6144" 
    capture_lex $P6145
    $P6145()
    find_lex $P6155, "MAIN"
    find_lex $P6158, "@ARGS"
    if $P6158, if_6157
    set $P6156, $P6158
    goto if_6157_end
  if_6157:
    .const 'Sub' $P6159 = "11_1303401201.841" 
    find_lex $P6160, "@ARGS"
    $P6161 = $P6159($P6160 :flat)
    set $P6156, $P6161
  if_6157_end:
.annotate 'line', 1
    .return ($P6156)
    .const 'Sub' $P6163 = "573_1303401201.841" 
    .return ($P6163)
.end


.HLL "nqp"

.namespace []
.sub "" :load :init :subid("post574") :outer("10_1303401201.841")
.annotate 'line', 0
    .const 'Sub' $P12 = "10_1303401201.841" 
    .local pmc block
    set block, $P12
    nqp_get_sc $P6167, "1303401190.883"
    isnull $I6168, $P6167
    if $I6168, if_6166
    .const 'Sub' $P6272 = "10_1303401201.841" 
    $P6273 = $P6272."get_lexinfo"()
    nqp_get_sc_object $P6274, "1303401190.883", 0
    $P6273."set_static_lexpad_value"("GLOBALish", $P6274)
    .const 'Sub' $P6275 = "10_1303401201.841" 
    $P6276 = $P6275."get_lexinfo"()
    $P6276."finish_static_lexpad"()
    .const 'Sub' $P6277 = "10_1303401201.841" 
    $P6278 = $P6277."get_lexinfo"()
    nqp_get_sc_object $P6279, "1303401190.883", 0
    $P6278."set_static_lexpad_value"("$?PACKAGE", $P6279)
    .const 'Sub' $P6280 = "10_1303401201.841" 
    $P6281 = $P6280."get_lexinfo"()
    $P6281."finish_static_lexpad"()
    nqp_get_sc_object $P6282, "1303401190.883", 1
    set_hll_global ["NQP"], "Grammar", $P6282
    .const 'Sub' $P6283 = "12_1303401201.841" 
    $P6284 = $P6283."get_lexinfo"()
    nqp_get_sc_object $P6285, "1303401190.883", 1
    $P6284."set_static_lexpad_value"("$?PACKAGE", $P6285)
    .const 'Sub' $P6286 = "12_1303401201.841" 
    $P6287 = $P6286."get_lexinfo"()
    $P6287."finish_static_lexpad"()
    .const 'Sub' $P6288 = "12_1303401201.841" 
    $P6289 = $P6288."get_lexinfo"()
    nqp_get_sc_object $P6290, "1303401190.883", 1
    $P6289."set_static_lexpad_value"("$?CLASS", $P6290)
    .const 'Sub' $P6291 = "12_1303401201.841" 
    $P6292 = $P6291."get_lexinfo"()
    $P6292."finish_static_lexpad"()
    nqp_get_sc_object $P6293, "1303401190.883", 2
    set_hll_global ["NQP"], "Regex", $P6293
    .const 'Sub' $P6294 = "384_1303401201.841" 
    $P6295 = $P6294."get_lexinfo"()
    nqp_get_sc_object $P6296, "1303401190.883", 2
    $P6295."set_static_lexpad_value"("$?PACKAGE", $P6296)
    .const 'Sub' $P6297 = "384_1303401201.841" 
    $P6298 = $P6297."get_lexinfo"()
    $P6298."finish_static_lexpad"()
    .const 'Sub' $P6299 = "384_1303401201.841" 
    $P6300 = $P6299."get_lexinfo"()
    nqp_get_sc_object $P6301, "1303401190.883", 2
    $P6300."set_static_lexpad_value"("$?CLASS", $P6301)
    .const 'Sub' $P6302 = "384_1303401201.841" 
    $P6303 = $P6302."get_lexinfo"()
    $P6303."finish_static_lexpad"()
    nqp_get_sc_object $P6304, "1303401190.883", 3
    set_hll_global ["NQP"], "Actions", $P6304
    .const 'Sub' $P6305 = "406_1303401201.841" 
    $P6306 = $P6305."get_lexinfo"()
    nqp_get_sc_object $P6307, "1303401190.883", 3
    $P6306."set_static_lexpad_value"("$?PACKAGE", $P6307)
    .const 'Sub' $P6308 = "406_1303401201.841" 
    $P6309 = $P6308."get_lexinfo"()
    $P6309."finish_static_lexpad"()
    .const 'Sub' $P6310 = "406_1303401201.841" 
    $P6311 = $P6310."get_lexinfo"()
    nqp_get_sc_object $P6312, "1303401190.883", 3
    $P6311."set_static_lexpad_value"("$?CLASS", $P6312)
    .const 'Sub' $P6313 = "406_1303401201.841" 
    $P6314 = $P6313."get_lexinfo"()
    $P6314."finish_static_lexpad"()
    nqp_get_sc_object $P6315, "1303401190.883", 4
    set_hll_global ["NQP"], "RegexActions", $P6315
    .const 'Sub' $P6316 = "562_1303401201.841" 
    $P6317 = $P6316."get_lexinfo"()
    nqp_get_sc_object $P6318, "1303401190.883", 4
    $P6317."set_static_lexpad_value"("$?PACKAGE", $P6318)
    .const 'Sub' $P6319 = "562_1303401201.841" 
    $P6320 = $P6319."get_lexinfo"()
    $P6320."finish_static_lexpad"()
    .const 'Sub' $P6321 = "562_1303401201.841" 
    $P6322 = $P6321."get_lexinfo"()
    nqp_get_sc_object $P6323, "1303401190.883", 4
    $P6322."set_static_lexpad_value"("$?CLASS", $P6323)
    .const 'Sub' $P6324 = "562_1303401201.841" 
    $P6325 = $P6324."get_lexinfo"()
    $P6325."finish_static_lexpad"()
    nqp_get_sc_object $P6326, "1303401190.883", 5
    set_hll_global ["NQP"], "Compiler", $P6326
    .const 'Sub' $P6327 = "571_1303401201.841" 
    $P6328 = $P6327."get_lexinfo"()
    nqp_get_sc_object $P6329, "1303401190.883", 5
    $P6328."set_static_lexpad_value"("$?PACKAGE", $P6329)
    .const 'Sub' $P6330 = "571_1303401201.841" 
    $P6331 = $P6330."get_lexinfo"()
    $P6331."finish_static_lexpad"()
    .const 'Sub' $P6332 = "571_1303401201.841" 
    $P6333 = $P6332."get_lexinfo"()
    nqp_get_sc_object $P6334, "1303401190.883", 5
    $P6333."set_static_lexpad_value"("$?CLASS", $P6334)
    .const 'Sub' $P6335 = "571_1303401201.841" 
    $P6336 = $P6335."get_lexinfo"()
    $P6336."finish_static_lexpad"()
    goto if_6166_end
  if_6166:
    nqp_dynop_setup 
    getinterp $P6169
    get_class $P6170, "LexPad"
    get_class $P6171, "NQPLexPad"
    $P6169."hll_map"($P6170, $P6171)
    load_bytecode "nqpmo.pbc"
    nqp_create_sc $P6172, "1303401190.883"
    .local pmc cur_sc
    set cur_sc, $P6172
    load_bytecode "SettingManager.pbc"
    get_hll_global $P6173, ["HLL"], "SettingManager"
    $P6174 = $P6173."load_setting"("NQPCORE")
    block."set_outer_ctx"($P6174)
    get_hll_global $P6175, "KnowHOW"
    $P6176 = $P6175."new_type"("GLOBALish" :named("name"))
    nqp_set_sc_for_object $P6176, cur_sc
    nqp_set_sc_object "1303401190.883", 0, $P6176
    .const 'Sub' $P6177 = "10_1303401201.841" 
    $P6178 = $P6177."get_lexinfo"()
    nqp_get_sc_object $P6179, "1303401190.883", 0
    $P6178."set_static_lexpad_value"("GLOBALish", $P6179)
    .const 'Sub' $P6180 = "10_1303401201.841" 
    $P6181 = $P6180."get_lexinfo"()
    $P6181."finish_static_lexpad"()
    .const 'Sub' $P6182 = "10_1303401201.841" 
    $P6183 = $P6182."get_lexinfo"()
    nqp_get_sc_object $P6184, "1303401190.883", 0
    $P6183."set_static_lexpad_value"("$?PACKAGE", $P6184)
    .const 'Sub' $P6185 = "10_1303401201.841" 
    $P6186 = $P6185."get_lexinfo"()
    $P6186."finish_static_lexpad"()
    load_bytecode "P6Regex.pbc"
    get_hll_global $P6187, "NQPClassHOW"
    $P6188 = $P6187."new_type"("NQP::Grammar" :named("name"))
    nqp_set_sc_for_object $P6188, cur_sc
    nqp_set_sc_object "1303401190.883", 1, $P6188
    nqp_get_sc_object $P6189, "1303401190.883", 1
    nqp_get_sc_object $P6190, "1303401190.883", 0
    nqp_get_package_through_who $P6191, $P6190, "NQP"
    get_who $P6192, $P6191
    set $P6192["Grammar"], $P6189
    nqp_get_sc_object $P6193, "1303401190.883", 1
    set_hll_global ["NQP"], "Grammar", $P6193
    .const 'Sub' $P6194 = "12_1303401201.841" 
    $P6195 = $P6194."get_lexinfo"()
    nqp_get_sc_object $P6196, "1303401190.883", 1
    $P6195."set_static_lexpad_value"("$?PACKAGE", $P6196)
    .const 'Sub' $P6197 = "12_1303401201.841" 
    $P6198 = $P6197."get_lexinfo"()
    $P6198."finish_static_lexpad"()
    .const 'Sub' $P6199 = "12_1303401201.841" 
    $P6200 = $P6199."get_lexinfo"()
    nqp_get_sc_object $P6201, "1303401190.883", 1
    $P6200."set_static_lexpad_value"("$?CLASS", $P6201)
    .const 'Sub' $P6202 = "12_1303401201.841" 
    $P6203 = $P6202."get_lexinfo"()
    $P6203."finish_static_lexpad"()
    get_hll_global $P6204, "NQPClassHOW"
    $P6205 = $P6204."new_type"("NQP::Regex" :named("name"))
    nqp_set_sc_for_object $P6205, cur_sc
    nqp_set_sc_object "1303401190.883", 2, $P6205
    nqp_get_sc_object $P6206, "1303401190.883", 2
    nqp_get_sc_object $P6207, "1303401190.883", 0
    nqp_get_package_through_who $P6208, $P6207, "NQP"
    get_who $P6209, $P6208
    set $P6209["Regex"], $P6206
    nqp_get_sc_object $P6210, "1303401190.883", 2
    set_hll_global ["NQP"], "Regex", $P6210
    .const 'Sub' $P6211 = "384_1303401201.841" 
    $P6212 = $P6211."get_lexinfo"()
    nqp_get_sc_object $P6213, "1303401190.883", 2
    $P6212."set_static_lexpad_value"("$?PACKAGE", $P6213)
    .const 'Sub' $P6214 = "384_1303401201.841" 
    $P6215 = $P6214."get_lexinfo"()
    $P6215."finish_static_lexpad"()
    .const 'Sub' $P6216 = "384_1303401201.841" 
    $P6217 = $P6216."get_lexinfo"()
    nqp_get_sc_object $P6218, "1303401190.883", 2
    $P6217."set_static_lexpad_value"("$?CLASS", $P6218)
    .const 'Sub' $P6219 = "384_1303401201.841" 
    $P6220 = $P6219."get_lexinfo"()
    $P6220."finish_static_lexpad"()
    get_hll_global $P6221, "NQPClassHOW"
    $P6222 = $P6221."new_type"("NQP::Actions" :named("name"))
    nqp_set_sc_for_object $P6222, cur_sc
    nqp_set_sc_object "1303401190.883", 3, $P6222
    nqp_get_sc_object $P6223, "1303401190.883", 3
    nqp_get_sc_object $P6224, "1303401190.883", 0
    nqp_get_package_through_who $P6225, $P6224, "NQP"
    get_who $P6226, $P6225
    set $P6226["Actions"], $P6223
    nqp_get_sc_object $P6227, "1303401190.883", 3
    set_hll_global ["NQP"], "Actions", $P6227
    .const 'Sub' $P6228 = "406_1303401201.841" 
    $P6229 = $P6228."get_lexinfo"()
    nqp_get_sc_object $P6230, "1303401190.883", 3
    $P6229."set_static_lexpad_value"("$?PACKAGE", $P6230)
    .const 'Sub' $P6231 = "406_1303401201.841" 
    $P6232 = $P6231."get_lexinfo"()
    $P6232."finish_static_lexpad"()
    .const 'Sub' $P6233 = "406_1303401201.841" 
    $P6234 = $P6233."get_lexinfo"()
    nqp_get_sc_object $P6235, "1303401190.883", 3
    $P6234."set_static_lexpad_value"("$?CLASS", $P6235)
    .const 'Sub' $P6236 = "406_1303401201.841" 
    $P6237 = $P6236."get_lexinfo"()
    $P6237."finish_static_lexpad"()
    get_hll_global $P6238, "NQPClassHOW"
    $P6239 = $P6238."new_type"("NQP::RegexActions" :named("name"))
    nqp_set_sc_for_object $P6239, cur_sc
    nqp_set_sc_object "1303401190.883", 4, $P6239
    nqp_get_sc_object $P6240, "1303401190.883", 4
    nqp_get_sc_object $P6241, "1303401190.883", 0
    nqp_get_package_through_who $P6242, $P6241, "NQP"
    get_who $P6243, $P6242
    set $P6243["RegexActions"], $P6240
    nqp_get_sc_object $P6244, "1303401190.883", 4
    set_hll_global ["NQP"], "RegexActions", $P6244
    .const 'Sub' $P6245 = "562_1303401201.841" 
    $P6246 = $P6245."get_lexinfo"()
    nqp_get_sc_object $P6247, "1303401190.883", 4
    $P6246."set_static_lexpad_value"("$?PACKAGE", $P6247)
    .const 'Sub' $P6248 = "562_1303401201.841" 
    $P6249 = $P6248."get_lexinfo"()
    $P6249."finish_static_lexpad"()
    .const 'Sub' $P6250 = "562_1303401201.841" 
    $P6251 = $P6250."get_lexinfo"()
    nqp_get_sc_object $P6252, "1303401190.883", 4
    $P6251."set_static_lexpad_value"("$?CLASS", $P6252)
    .const 'Sub' $P6253 = "562_1303401201.841" 
    $P6254 = $P6253."get_lexinfo"()
    $P6254."finish_static_lexpad"()
    get_hll_global $P6255, "NQPClassHOW"
    $P6256 = $P6255."new_type"("NQP::Compiler" :named("name"))
    nqp_set_sc_for_object $P6256, cur_sc
    nqp_set_sc_object "1303401190.883", 5, $P6256
    nqp_get_sc_object $P6257, "1303401190.883", 5
    nqp_get_sc_object $P6258, "1303401190.883", 0
    nqp_get_package_through_who $P6259, $P6258, "NQP"
    get_who $P6260, $P6259
    set $P6260["Compiler"], $P6257
    nqp_get_sc_object $P6261, "1303401190.883", 5
    set_hll_global ["NQP"], "Compiler", $P6261
    .const 'Sub' $P6262 = "571_1303401201.841" 
    $P6263 = $P6262."get_lexinfo"()
    nqp_get_sc_object $P6264, "1303401190.883", 5
    $P6263."set_static_lexpad_value"("$?PACKAGE", $P6264)
    .const 'Sub' $P6265 = "571_1303401201.841" 
    $P6266 = $P6265."get_lexinfo"()
    $P6266."finish_static_lexpad"()
    .const 'Sub' $P6267 = "571_1303401201.841" 
    $P6268 = $P6267."get_lexinfo"()
    nqp_get_sc_object $P6269, "1303401190.883", 5
    $P6268."set_static_lexpad_value"("$?CLASS", $P6269)
    .const 'Sub' $P6270 = "571_1303401201.841" 
    $P6271 = $P6270."get_lexinfo"()
    $P6271."finish_static_lexpad"()
  if_6166_end:
    nqp_get_sc_object $P6337, "1303401190.883", 0
    set_hll_global "GLOBAL", $P6337
.end


.HLL "nqp"

.namespace []
.sub "MAIN"  :subid("11_1303401201.841") :outer("10_1303401201.841")
    .param pmc param_17
.annotate 'line', 2241
    .lex "@ARGS", param_17
.annotate 'line', 2243
    new $P18, "Undef"
    .lex "$nqpcomp", $P18
.annotate 'line', 2249
    $P19 = root_new ['parrot';'ResizablePMCArray']
    .lex "@clo", $P19
.annotate 'line', 2243
    get_hll_global $P20, ["NQP"], "Compiler"
    $P21 = $P20."new"()
    store_lex "$nqpcomp", $P21
.annotate 'line', 2244
    find_lex $P22, "$nqpcomp"
    unless_null $P22, vivify_575
    new $P22, "Undef"
  vivify_575:
    $P22."language"("nqp")
.annotate 'line', 2245
    find_lex $P23, "$nqpcomp"
    unless_null $P23, vivify_576
    new $P23, "Undef"
  vivify_576:
    get_hll_global $P24, ["NQP"], "Grammar"
    $P23."parsegrammar"($P24)
.annotate 'line', 2246
    find_lex $P25, "$nqpcomp"
    unless_null $P25, vivify_577
    new $P25, "Undef"
  vivify_577:
    get_hll_global $P26, ["NQP"], "Actions"
    $P25."parseactions"($P26)
.annotate 'line', 2249
    find_lex $P27, "$nqpcomp"
    unless_null $P27, vivify_578
    new $P27, "Undef"
  vivify_578:
    $P28 = $P27."commandline_options"()
    store_lex "@clo", $P28
.annotate 'line', 2250
    find_lex $P29, "@clo"
    unless_null $P29, vivify_579
    $P29 = root_new ['parrot';'ResizablePMCArray']
  vivify_579:
    $P29."push"("parsetrace")
.annotate 'line', 2251
    find_lex $P30, "@clo"
    unless_null $P30, vivify_580
    $P30 = root_new ['parrot';'ResizablePMCArray']
  vivify_580:
    $P30."push"("setting=s")
.annotate 'line', 2254
    find_lex $P31, "$nqpcomp"
    unless_null $P31, vivify_581
    new $P31, "Undef"
  vivify_581:
    find_lex $P32, "@ARGS"
    unless_null $P32, vivify_582
    $P32 = root_new ['parrot';'ResizablePMCArray']
  vivify_582:
    $P33 = $P31."command_line"($P32, "utf8" :named("encoding"), "ascii iso-8859-1" :named("transcode"))
.annotate 'line', 2241
    .return ($P33)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block35"  :subid("12_1303401201.841") :outer("10_1303401201.841")
.annotate 'line', 9
    .const 'Sub' $P1770 = "383_1303401201.841" 
    capture_lex $P1770
    .const 'Sub' $P1757 = "382_1303401201.841" 
    capture_lex $P1757
    .const 'Sub' $P1751 = "380_1303401201.841" 
    capture_lex $P1751
    .const 'Sub' $P1745 = "378_1303401201.841" 
    capture_lex $P1745
    .const 'Sub' $P1739 = "376_1303401201.841" 
    capture_lex $P1739
    .const 'Sub' $P1733 = "374_1303401201.841" 
    capture_lex $P1733
    .const 'Sub' $P1721 = "371_1303401201.841" 
    capture_lex $P1721
    .const 'Sub' $P1714 = "369_1303401201.841" 
    capture_lex $P1714
    .const 'Sub' $P1707 = "367_1303401201.841" 
    capture_lex $P1707
    .const 'Sub' $P1700 = "365_1303401201.841" 
    capture_lex $P1700
    .const 'Sub' $P1693 = "363_1303401201.841" 
    capture_lex $P1693
    .const 'Sub' $P1687 = "361_1303401201.841" 
    capture_lex $P1687
    .const 'Sub' $P1680 = "359_1303401201.841" 
    capture_lex $P1680
    .const 'Sub' $P1673 = "357_1303401201.841" 
    capture_lex $P1673
    .const 'Sub' $P1666 = "355_1303401201.841" 
    capture_lex $P1666
    .const 'Sub' $P1659 = "353_1303401201.841" 
    capture_lex $P1659
    .const 'Sub' $P1652 = "351_1303401201.841" 
    capture_lex $P1652
    .const 'Sub' $P1645 = "349_1303401201.841" 
    capture_lex $P1645
    .const 'Sub' $P1638 = "347_1303401201.841" 
    capture_lex $P1638
    .const 'Sub' $P1631 = "345_1303401201.841" 
    capture_lex $P1631
    .const 'Sub' $P1624 = "343_1303401201.841" 
    capture_lex $P1624
    .const 'Sub' $P1617 = "341_1303401201.841" 
    capture_lex $P1617
    .const 'Sub' $P1610 = "339_1303401201.841" 
    capture_lex $P1610
    .const 'Sub' $P1603 = "337_1303401201.841" 
    capture_lex $P1603
    .const 'Sub' $P1596 = "335_1303401201.841" 
    capture_lex $P1596
    .const 'Sub' $P1589 = "333_1303401201.841" 
    capture_lex $P1589
    .const 'Sub' $P1582 = "331_1303401201.841" 
    capture_lex $P1582
    .const 'Sub' $P1575 = "329_1303401201.841" 
    capture_lex $P1575
    .const 'Sub' $P1568 = "327_1303401201.841" 
    capture_lex $P1568
    .const 'Sub' $P1561 = "325_1303401201.841" 
    capture_lex $P1561
    .const 'Sub' $P1554 = "323_1303401201.841" 
    capture_lex $P1554
    .const 'Sub' $P1547 = "321_1303401201.841" 
    capture_lex $P1547
    .const 'Sub' $P1540 = "319_1303401201.841" 
    capture_lex $P1540
    .const 'Sub' $P1533 = "317_1303401201.841" 
    capture_lex $P1533
    .const 'Sub' $P1526 = "315_1303401201.841" 
    capture_lex $P1526
    .const 'Sub' $P1519 = "313_1303401201.841" 
    capture_lex $P1519
    .const 'Sub' $P1512 = "311_1303401201.841" 
    capture_lex $P1512
    .const 'Sub' $P1505 = "309_1303401201.841" 
    capture_lex $P1505
    .const 'Sub' $P1498 = "307_1303401201.841" 
    capture_lex $P1498
    .const 'Sub' $P1491 = "305_1303401201.841" 
    capture_lex $P1491
    .const 'Sub' $P1484 = "303_1303401201.841" 
    capture_lex $P1484
    .const 'Sub' $P1478 = "301_1303401201.841" 
    capture_lex $P1478
    .const 'Sub' $P1471 = "299_1303401201.841" 
    capture_lex $P1471
    .const 'Sub' $P1464 = "297_1303401201.841" 
    capture_lex $P1464
    .const 'Sub' $P1457 = "295_1303401201.841" 
    capture_lex $P1457
    .const 'Sub' $P1450 = "293_1303401201.841" 
    capture_lex $P1450
    .const 'Sub' $P1443 = "291_1303401201.841" 
    capture_lex $P1443
    .const 'Sub' $P1436 = "289_1303401201.841" 
    capture_lex $P1436
    .const 'Sub' $P1429 = "287_1303401201.841" 
    capture_lex $P1429
    .const 'Sub' $P1423 = "285_1303401201.841" 
    capture_lex $P1423
    .const 'Sub' $P1417 = "283_1303401201.841" 
    capture_lex $P1417
    .const 'Sub' $P1412 = "281_1303401201.841" 
    capture_lex $P1412
    .const 'Sub' $P1406 = "279_1303401201.841" 
    capture_lex $P1406
    .const 'Sub' $P1400 = "277_1303401201.841" 
    capture_lex $P1400
    .const 'Sub' $P1395 = "275_1303401201.841" 
    capture_lex $P1395
    .const 'Sub' $P1390 = "273_1303401201.841" 
    capture_lex $P1390
    .const 'Sub' $P1382 = "271_1303401201.841" 
    capture_lex $P1382
    .const 'Sub' $P1373 = "269_1303401201.841" 
    capture_lex $P1373
    .const 'Sub' $P1368 = "267_1303401201.841" 
    capture_lex $P1368
    .const 'Sub' $P1363 = "265_1303401201.841" 
    capture_lex $P1363
    .const 'Sub' $P1358 = "263_1303401201.841" 
    capture_lex $P1358
    .const 'Sub' $P1350 = "261_1303401201.841" 
    capture_lex $P1350
    .const 'Sub' $P1342 = "259_1303401201.841" 
    capture_lex $P1342
    .const 'Sub' $P1337 = "257_1303401201.841" 
    capture_lex $P1337
    .const 'Sub' $P1332 = "255_1303401201.841" 
    capture_lex $P1332
    .const 'Sub' $P1327 = "253_1303401201.841" 
    capture_lex $P1327
    .const 'Sub' $P1321 = "251_1303401201.841" 
    capture_lex $P1321
    .const 'Sub' $P1314 = "249_1303401201.841" 
    capture_lex $P1314
    .const 'Sub' $P1307 = "247_1303401201.841" 
    capture_lex $P1307
    .const 'Sub' $P1300 = "245_1303401201.841" 
    capture_lex $P1300
    .const 'Sub' $P1293 = "243_1303401201.841" 
    capture_lex $P1293
    .const 'Sub' $P1288 = "241_1303401201.841" 
    capture_lex $P1288
    .const 'Sub' $P1283 = "239_1303401201.841" 
    capture_lex $P1283
    .const 'Sub' $P1269 = "235_1303401201.841" 
    capture_lex $P1269
    .const 'Sub' $P1261 = "233_1303401201.841" 
    capture_lex $P1261
    .const 'Sub' $P1255 = "231_1303401201.841" 
    capture_lex $P1255
    .const 'Sub' $P1248 = "229_1303401201.841" 
    capture_lex $P1248
    .const 'Sub' $P1242 = "227_1303401201.841" 
    capture_lex $P1242
    .const 'Sub' $P1228 = "224_1303401201.841" 
    capture_lex $P1228
    .const 'Sub' $P1220 = "222_1303401201.841" 
    capture_lex $P1220
    .const 'Sub' $P1212 = "220_1303401201.841" 
    capture_lex $P1212
    .const 'Sub' $P1206 = "218_1303401201.841" 
    capture_lex $P1206
    .const 'Sub' $P1200 = "216_1303401201.841" 
    capture_lex $P1200
    .const 'Sub' $P1184 = "212_1303401201.841" 
    capture_lex $P1184
    .const 'Sub' $P1143 = "210_1303401201.841" 
    capture_lex $P1143
    .const 'Sub' $P1132 = "208_1303401201.841" 
    capture_lex $P1132
    .const 'Sub' $P1118 = "204_1303401201.841" 
    capture_lex $P1118
    .const 'Sub' $P1109 = "202_1303401201.841" 
    capture_lex $P1109
    .const 'Sub' $P1103 = "200_1303401201.841" 
    capture_lex $P1103
    .const 'Sub' $P1093 = "198_1303401201.841" 
    capture_lex $P1093
    .const 'Sub' $P1078 = "196_1303401201.841" 
    capture_lex $P1078
    .const 'Sub' $P1064 = "193_1303401201.841" 
    capture_lex $P1064
    .const 'Sub' $P1056 = "191_1303401201.841" 
    capture_lex $P1056
    .const 'Sub' $P1046 = "189_1303401201.841" 
    capture_lex $P1046
    .const 'Sub' $P1036 = "187_1303401201.841" 
    capture_lex $P1036
    .const 'Sub' $P1017 = "182_1303401201.841" 
    capture_lex $P1017
    .const 'Sub' $P973 = "179_1303401201.841" 
    capture_lex $P973
    .const 'Sub' $P939 = "177_1303401201.841" 
    capture_lex $P939
    .const 'Sub' $P932 = "175_1303401201.841" 
    capture_lex $P932
    .const 'Sub' $P925 = "173_1303401201.841" 
    capture_lex $P925
    .const 'Sub' $P908 = "169_1303401201.841" 
    capture_lex $P908
    .const 'Sub' $P900 = "167_1303401201.841" 
    capture_lex $P900
    .const 'Sub' $P894 = "165_1303401201.841" 
    capture_lex $P894
    .const 'Sub' $P878 = "163_1303401201.841" 
    capture_lex $P878
    .const 'Sub' $P871 = "161_1303401201.841" 
    capture_lex $P871
    .const 'Sub' $P864 = "159_1303401201.841" 
    capture_lex $P864
    .const 'Sub' $P857 = "157_1303401201.841" 
    capture_lex $P857
    .const 'Sub' $P715 = "152_1303401201.841" 
    capture_lex $P715
    .const 'Sub' $P701 = "150_1303401201.841" 
    capture_lex $P701
    .const 'Sub' $P687 = "148_1303401201.841" 
    capture_lex $P687
    .const 'Sub' $P673 = "146_1303401201.841" 
    capture_lex $P673
    .const 'Sub' $P659 = "144_1303401201.841" 
    capture_lex $P659
    .const 'Sub' $P645 = "142_1303401201.841" 
    capture_lex $P645
    .const 'Sub' $P631 = "140_1303401201.841" 
    capture_lex $P631
    .const 'Sub' $P620 = "136_1303401201.841" 
    capture_lex $P620
    .const 'Sub' $P615 = "134_1303401201.841" 
    capture_lex $P615
    .const 'Sub' $P603 = "132_1303401201.841" 
    capture_lex $P603
    .const 'Sub' $P591 = "130_1303401201.841" 
    capture_lex $P591
    .const 'Sub' $P584 = "128_1303401201.841" 
    capture_lex $P584
    .const 'Sub' $P579 = "126_1303401201.841" 
    capture_lex $P579
    .const 'Sub' $P573 = "124_1303401201.841" 
    capture_lex $P573
    .const 'Sub' $P567 = "122_1303401201.841" 
    capture_lex $P567
    .const 'Sub' $P552 = "118_1303401201.841" 
    capture_lex $P552
    .const 'Sub' $P546 = "116_1303401201.841" 
    capture_lex $P546
    .const 'Sub' $P540 = "114_1303401201.841" 
    capture_lex $P540
    .const 'Sub' $P534 = "112_1303401201.841" 
    capture_lex $P534
    .const 'Sub' $P528 = "110_1303401201.841" 
    capture_lex $P528
    .const 'Sub' $P522 = "108_1303401201.841" 
    capture_lex $P522
    .const 'Sub' $P516 = "106_1303401201.841" 
    capture_lex $P516
    .const 'Sub' $P507 = "104_1303401201.841" 
    capture_lex $P507
    .const 'Sub' $P498 = "102_1303401201.841" 
    capture_lex $P498
    .const 'Sub' $P489 = "100_1303401201.841" 
    capture_lex $P489
    .const 'Sub' $P474 = "96_1303401201.841" 
    capture_lex $P474
    .const 'Sub' $P465 = "94_1303401201.841" 
    capture_lex $P465
    .const 'Sub' $P453 = "90_1303401201.841" 
    capture_lex $P453
    .const 'Sub' $P446 = "88_1303401201.841" 
    capture_lex $P446
    .const 'Sub' $P439 = "86_1303401201.841" 
    capture_lex $P439
    .const 'Sub' $P425 = "82_1303401201.841" 
    capture_lex $P425
    .const 'Sub' $P417 = "80_1303401201.841" 
    capture_lex $P417
    .const 'Sub' $P409 = "78_1303401201.841" 
    capture_lex $P409
    .const 'Sub' $P389 = "76_1303401201.841" 
    capture_lex $P389
    .const 'Sub' $P380 = "74_1303401201.841" 
    capture_lex $P380
    .const 'Sub' $P362 = "71_1303401201.841" 
    capture_lex $P362
    .const 'Sub' $P344 = "69_1303401201.841" 
    capture_lex $P344
    .const 'Sub' $P336 = "67_1303401201.841" 
    capture_lex $P336
    .const 'Sub' $P325 = "63_1303401201.841" 
    capture_lex $P325
    .const 'Sub' $P320 = "61_1303401201.841" 
    capture_lex $P320
    .const 'Sub' $P309 = "57_1303401201.841" 
    capture_lex $P309
    .const 'Sub' $P304 = "55_1303401201.841" 
    capture_lex $P304
    .const 'Sub' $P299 = "53_1303401201.841" 
    capture_lex $P299
    .const 'Sub' $P294 = "51_1303401201.841" 
    capture_lex $P294
    .const 'Sub' $P289 = "49_1303401201.841" 
    capture_lex $P289
    .const 'Sub' $P279 = "47_1303401201.841" 
    capture_lex $P279
    .const 'Sub' $P272 = "45_1303401201.841" 
    capture_lex $P272
    .const 'Sub' $P266 = "43_1303401201.841" 
    capture_lex $P266
    .const 'Sub' $P258 = "41_1303401201.841" 
    capture_lex $P258
    .const 'Sub' $P252 = "39_1303401201.841" 
    capture_lex $P252
    .const 'Sub' $P246 = "37_1303401201.841" 
    capture_lex $P246
    .const 'Sub' $P231 = "34_1303401201.841" 
    capture_lex $P231
    .const 'Sub' $P217 = "32_1303401201.841" 
    capture_lex $P217
    .const 'Sub' $P202 = "30_1303401201.841" 
    capture_lex $P202
    .const 'Sub' $P163 = "27_1303401201.841" 
    capture_lex $P163
    .const 'Sub' $P148 = "24_1303401201.841" 
    capture_lex $P148
    .const 'Sub' $P137 = "22_1303401201.841" 
    capture_lex $P137
    .const 'Sub' $P125 = "20_1303401201.841" 
    capture_lex $P125
    .const 'Sub' $P117 = "18_1303401201.841" 
    capture_lex $P117
    .const 'Sub' $P110 = "16_1303401201.841" 
    capture_lex $P110
    .const 'Sub' $P103 = "14_1303401201.841" 
    capture_lex $P103
    .const 'Sub' $P54 = "13_1303401201.841" 
    capture_lex $P54
    .lex "$?PACKAGE", $P37
    .lex "$?CLASS", $P38
.annotate 'line', 608
    get_hll_global $P39, ["NQP"], "Grammar"
    $P39."O"(":prec<y=>, :assoc<unary>", "%methodop")
.annotate 'line', 609
    get_hll_global $P40, ["NQP"], "Grammar"
    $P40."O"(":prec<x=>, :assoc<unary>", "%autoincrement")
.annotate 'line', 610
    get_hll_global $P41, ["NQP"], "Grammar"
    $P41."O"(":prec<w=>, :assoc<left>", "%exponentiation")
.annotate 'line', 611
    get_hll_global $P42, ["NQP"], "Grammar"
    $P42."O"(":prec<v=>, :assoc<unary>", "%symbolic_unary")
.annotate 'line', 612
    get_hll_global $P43, ["NQP"], "Grammar"
    $P43."O"(":prec<u=>, :assoc<left>", "%multiplicative")
.annotate 'line', 613
    get_hll_global $P44, ["NQP"], "Grammar"
    $P44."O"(":prec<t=>, :assoc<left>", "%additive")
.annotate 'line', 614
    get_hll_global $P45, ["NQP"], "Grammar"
    $P45."O"(":prec<r=>, :assoc<left>", "%concatenation")
.annotate 'line', 615
    get_hll_global $P46, ["NQP"], "Grammar"
    $P46."O"(":prec<m=>, :assoc<left>", "%relational")
.annotate 'line', 616
    get_hll_global $P47, ["NQP"], "Grammar"
    $P47."O"(":prec<l=>, :assoc<left>", "%tight_and")
.annotate 'line', 617
    get_hll_global $P48, ["NQP"], "Grammar"
    $P48."O"(":prec<k=>, :assoc<left>", "%tight_or")
.annotate 'line', 618
    get_hll_global $P49, ["NQP"], "Grammar"
    $P49."O"(":prec<j=>, :assoc<right>", "%conditional")
.annotate 'line', 619
    get_hll_global $P50, ["NQP"], "Grammar"
    $P50."O"(":prec<i=>, :assoc<right>", "%assignment")
.annotate 'line', 620
    get_hll_global $P51, ["NQP"], "Grammar"
    $P51."O"(":prec<g=>, :assoc<list>, :nextterm<nulltermish>", "%comma")
.annotate 'line', 621
    get_hll_global $P52, ["NQP"], "Grammar"
    $P52."O"(":prec<f=>, :assoc<list>", "%list_infix")
.annotate 'line', 622
    get_hll_global $P53, ["NQP"], "Grammar"
    $P53."O"(":prec<e=>, :assoc<unary>", "%list_prefix")
.annotate 'line', 721
    .const 'Sub' $P1757 = "382_1303401201.841" 
    newclosure $P1768, $P1757
.annotate 'line', 9
    .return ($P1768)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "" :load :init :subid("post583") :outer("12_1303401201.841")
.annotate 'line', 9
    get_hll_global $P36, ["NQP";"Grammar"], "_block35" 
    .local pmc block
    set block, $P36
    .const 'Sub' $P1770 = "383_1303401201.841" 
    capture_lex $P1770
    $P1770()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1769"  :anon :subid("383_1303401201.841") :outer("12_1303401201.841")
.annotate 'line', 9
    nqp_get_sc_object $P1771, "1303401190.883", 1
    .local pmc type_obj
    set type_obj, $P1771
    get_how $P1772, type_obj
    .const 'Sub' $P1773 = "13_1303401201.841" 
    $P1772."add_method"(type_obj, "TOP", $P1773)
    get_how $P1774, type_obj
    .const 'Sub' $P1775 = "14_1303401201.841" 
    $P1774."add_method"(type_obj, "identifier", $P1775)
    get_how $P1776, type_obj
    get_global $P1777, "!PREFIX__identifier"
    $P1776."add_method"(type_obj, "!PREFIX__identifier", $P1777)
    get_how $P1778, type_obj
    .const 'Sub' $P1779 = "16_1303401201.841" 
    $P1778."add_method"(type_obj, "name", $P1779)
    get_how $P1780, type_obj
    get_global $P1781, "!PREFIX__name"
    $P1780."add_method"(type_obj, "!PREFIX__name", $P1781)
    get_how $P1782, type_obj
    .const 'Sub' $P1783 = "18_1303401201.841" 
    $P1782."add_method"(type_obj, "deflongname", $P1783)
    get_how $P1784, type_obj
    get_global $P1785, "!PREFIX__deflongname"
    $P1784."add_method"(type_obj, "!PREFIX__deflongname", $P1785)
    get_how $P1786, type_obj
    .const 'Sub' $P1787 = "20_1303401201.841" 
    $P1786."add_method"(type_obj, "ENDSTMT", $P1787)
    get_how $P1788, type_obj
    get_global $P1789, "!PREFIX__ENDSTMT"
    $P1788."add_method"(type_obj, "!PREFIX__ENDSTMT", $P1789)
    get_how $P1790, type_obj
    .const 'Sub' $P1791 = "22_1303401201.841" 
    $P1790."add_method"(type_obj, "ws", $P1791)
    get_how $P1792, type_obj
    get_global $P1793, "!PREFIX__ws"
    $P1792."add_method"(type_obj, "!PREFIX__ws", $P1793)
    get_how $P1794, type_obj
    .const 'Sub' $P1795 = "24_1303401201.841" 
    $P1794."add_method"(type_obj, "unv", $P1795)
    get_how $P1796, type_obj
    get_global $P1797, "!PREFIX__unv"
    $P1796."add_method"(type_obj, "!PREFIX__unv", $P1797)
    get_how $P1798, type_obj
    .const 'Sub' $P1799 = "27_1303401201.841" 
    $P1798."add_method"(type_obj, "pod_comment", $P1799)
    get_how $P1800, type_obj
    get_global $P1801, "!PREFIX__pod_comment"
    $P1800."add_method"(type_obj, "!PREFIX__pod_comment", $P1801)
    get_how $P1802, type_obj
    .const 'Sub' $P1803 = "30_1303401201.841" 
    $P1802."add_method"(type_obj, "comp_unit", $P1803)
    get_how $P1804, type_obj
    get_global $P1805, "!PREFIX__comp_unit"
    $P1804."add_method"(type_obj, "!PREFIX__comp_unit", $P1805)
    get_how $P1806, type_obj
    .const 'Sub' $P1807 = "32_1303401201.841" 
    $P1806."add_method"(type_obj, "statementlist", $P1807)
    get_how $P1808, type_obj
    get_global $P1809, "!PREFIX__statementlist"
    $P1808."add_method"(type_obj, "!PREFIX__statementlist", $P1809)
    get_how $P1810, type_obj
    .const 'Sub' $P1811 = "34_1303401201.841" 
    $P1810."add_method"(type_obj, "statement", $P1811)
    get_how $P1812, type_obj
    get_global $P1813, "!PREFIX__statement"
    $P1812."add_method"(type_obj, "!PREFIX__statement", $P1813)
    get_how $P1814, type_obj
    .const 'Sub' $P1815 = "37_1303401201.841" 
    $P1814."add_method"(type_obj, "eat_terminator", $P1815)
    get_how $P1816, type_obj
    get_global $P1817, "!PREFIX__eat_terminator"
    $P1816."add_method"(type_obj, "!PREFIX__eat_terminator", $P1817)
    get_how $P1818, type_obj
    .const 'Sub' $P1819 = "39_1303401201.841" 
    $P1818."add_method"(type_obj, "xblock", $P1819)
    get_how $P1820, type_obj
    get_global $P1821, "!PREFIX__xblock"
    $P1820."add_method"(type_obj, "!PREFIX__xblock", $P1821)
    get_how $P1822, type_obj
    .const 'Sub' $P1823 = "41_1303401201.841" 
    $P1822."add_method"(type_obj, "pblock", $P1823)
    get_how $P1824, type_obj
    get_global $P1825, "!PREFIX__pblock"
    $P1824."add_method"(type_obj, "!PREFIX__pblock", $P1825)
    get_how $P1826, type_obj
    .const 'Sub' $P1827 = "43_1303401201.841" 
    $P1826."add_method"(type_obj, "lambda", $P1827)
    get_how $P1828, type_obj
    get_global $P1829, "!PREFIX__lambda"
    $P1828."add_method"(type_obj, "!PREFIX__lambda", $P1829)
    get_how $P1830, type_obj
    .const 'Sub' $P1831 = "45_1303401201.841" 
    $P1830."add_method"(type_obj, "block", $P1831)
    get_how $P1832, type_obj
    get_global $P1833, "!PREFIX__block"
    $P1832."add_method"(type_obj, "!PREFIX__block", $P1833)
    get_how $P1834, type_obj
    .const 'Sub' $P1835 = "47_1303401201.841" 
    $P1834."add_method"(type_obj, "blockoid", $P1835)
    get_how $P1836, type_obj
    get_global $P1837, "!PREFIX__blockoid"
    $P1836."add_method"(type_obj, "!PREFIX__blockoid", $P1837)
    get_how $P1838, type_obj
    .const 'Sub' $P1839 = "49_1303401201.841" 
    $P1838."add_method"(type_obj, "newpad", $P1839)
    get_how $P1840, type_obj
    get_global $P1841, "!PREFIX__newpad"
    $P1840."add_method"(type_obj, "!PREFIX__newpad", $P1841)
    get_how $P1842, type_obj
    .const 'Sub' $P1843 = "51_1303401201.841" 
    $P1842."add_method"(type_obj, "outerctx", $P1843)
    get_how $P1844, type_obj
    get_global $P1845, "!PREFIX__outerctx"
    $P1844."add_method"(type_obj, "!PREFIX__outerctx", $P1845)
    get_how $P1846, type_obj
    .const 'Sub' $P1847 = "53_1303401201.841" 
    $P1846."add_method"(type_obj, "GLOBALish", $P1847)
    get_how $P1848, type_obj
    get_global $P1849, "!PREFIX__GLOBALish"
    $P1848."add_method"(type_obj, "!PREFIX__GLOBALish", $P1849)
    get_how $P1850, type_obj
    .const 'Sub' $P1851 = "55_1303401201.841" 
    $P1850."add_method"(type_obj, "finishpad", $P1851)
    get_how $P1852, type_obj
    get_global $P1853, "!PREFIX__finishpad"
    $P1852."add_method"(type_obj, "!PREFIX__finishpad", $P1853)
    get_how $P1854, type_obj
    .const 'Sub' $P1855 = "57_1303401201.841" 
    $P1854."add_method"(type_obj, "you_are_here", $P1855)
    get_how $P1856, type_obj
    get_global $P1857, "!PREFIX__you_are_here"
    $P1856."add_method"(type_obj, "!PREFIX__you_are_here", $P1857)
    get_how $P1858, type_obj
    .const 'Sub' $P1859 = "59_1303401201.841" 
    $P1858."add_method"(type_obj, "terminator", $P1859)
    get_how $P1860, type_obj
    .const 'Sub' $P1861 = "60_1303401201.841" 
    $P1860."add_method"(type_obj, "!PREFIX__terminator", $P1861)
    get_how $P1862, type_obj
    .const 'Sub' $P1863 = "61_1303401201.841" 
    $P1862."add_method"(type_obj, "terminator:sym<;>", $P1863)
    get_how $P1864, type_obj
    get_global $P1865, "!PREFIX__terminator:sym<;>"
    $P1864."add_method"(type_obj, "!PREFIX__terminator:sym<;>", $P1865)
    get_how $P1866, type_obj
    .const 'Sub' $P1867 = "63_1303401201.841" 
    $P1866."add_method"(type_obj, "terminator:sym<}>", $P1867)
    get_how $P1868, type_obj
    get_global $P1869, "!PREFIX__terminator:sym<}>"
    $P1868."add_method"(type_obj, "!PREFIX__terminator:sym<}>", $P1869)
    get_how $P1870, type_obj
    .const 'Sub' $P1871 = "65_1303401201.841" 
    $P1870."add_method"(type_obj, "statement_control", $P1871)
    get_how $P1872, type_obj
    .const 'Sub' $P1873 = "66_1303401201.841" 
    $P1872."add_method"(type_obj, "!PREFIX__statement_control", $P1873)
    get_how $P1874, type_obj
    .const 'Sub' $P1875 = "67_1303401201.841" 
    $P1874."add_method"(type_obj, "statement_control:sym<use>", $P1875)
    get_how $P1876, type_obj
    get_global $P1877, "!PREFIX__statement_control:sym<use>"
    $P1876."add_method"(type_obj, "!PREFIX__statement_control:sym<use>", $P1877)
    get_how $P1878, type_obj
    .const 'Sub' $P1879 = "69_1303401201.841" 
    $P1878."add_method"(type_obj, "statement_control:sym<if>", $P1879)
    get_how $P1880, type_obj
    get_global $P1881, "!PREFIX__statement_control:sym<if>"
    $P1880."add_method"(type_obj, "!PREFIX__statement_control:sym<if>", $P1881)
    get_how $P1882, type_obj
    .const 'Sub' $P1883 = "71_1303401201.841" 
    $P1882."add_method"(type_obj, "statement_control:sym<unless>", $P1883)
    get_how $P1884, type_obj
    get_global $P1885, "!PREFIX__statement_control:sym<unless>"
    $P1884."add_method"(type_obj, "!PREFIX__statement_control:sym<unless>", $P1885)
    get_how $P1886, type_obj
    .const 'Sub' $P1887 = "74_1303401201.841" 
    $P1886."add_method"(type_obj, "statement_control:sym<while>", $P1887)
    get_how $P1888, type_obj
    get_global $P1889, "!PREFIX__statement_control:sym<while>"
    $P1888."add_method"(type_obj, "!PREFIX__statement_control:sym<while>", $P1889)
    get_how $P1890, type_obj
    .const 'Sub' $P1891 = "76_1303401201.841" 
    $P1890."add_method"(type_obj, "statement_control:sym<repeat>", $P1891)
    get_how $P1892, type_obj
    get_global $P1893, "!PREFIX__statement_control:sym<repeat>"
    $P1892."add_method"(type_obj, "!PREFIX__statement_control:sym<repeat>", $P1893)
    get_how $P1894, type_obj
    .const 'Sub' $P1895 = "78_1303401201.841" 
    $P1894."add_method"(type_obj, "statement_control:sym<for>", $P1895)
    get_how $P1896, type_obj
    get_global $P1897, "!PREFIX__statement_control:sym<for>"
    $P1896."add_method"(type_obj, "!PREFIX__statement_control:sym<for>", $P1897)
    get_how $P1898, type_obj
    .const 'Sub' $P1899 = "80_1303401201.841" 
    $P1898."add_method"(type_obj, "statement_control:sym<CATCH>", $P1899)
    get_how $P1900, type_obj
    get_global $P1901, "!PREFIX__statement_control:sym<CATCH>"
    $P1900."add_method"(type_obj, "!PREFIX__statement_control:sym<CATCH>", $P1901)
    get_how $P1902, type_obj
    .const 'Sub' $P1903 = "82_1303401201.841" 
    $P1902."add_method"(type_obj, "statement_control:sym<CONTROL>", $P1903)
    get_how $P1904, type_obj
    get_global $P1905, "!PREFIX__statement_control:sym<CONTROL>"
    $P1904."add_method"(type_obj, "!PREFIX__statement_control:sym<CONTROL>", $P1905)
    get_how $P1906, type_obj
    .const 'Sub' $P1907 = "84_1303401201.841" 
    $P1906."add_method"(type_obj, "statement_prefix", $P1907)
    get_how $P1908, type_obj
    .const 'Sub' $P1909 = "85_1303401201.841" 
    $P1908."add_method"(type_obj, "!PREFIX__statement_prefix", $P1909)
    get_how $P1910, type_obj
    .const 'Sub' $P1911 = "86_1303401201.841" 
    $P1910."add_method"(type_obj, "statement_prefix:sym<INIT>", $P1911)
    get_how $P1912, type_obj
    get_global $P1913, "!PREFIX__statement_prefix:sym<INIT>"
    $P1912."add_method"(type_obj, "!PREFIX__statement_prefix:sym<INIT>", $P1913)
    get_how $P1914, type_obj
    .const 'Sub' $P1915 = "88_1303401201.841" 
    $P1914."add_method"(type_obj, "statement_prefix:sym<try>", $P1915)
    get_how $P1916, type_obj
    get_global $P1917, "!PREFIX__statement_prefix:sym<try>"
    $P1916."add_method"(type_obj, "!PREFIX__statement_prefix:sym<try>", $P1917)
    get_how $P1918, type_obj
    .const 'Sub' $P1919 = "90_1303401201.841" 
    $P1918."add_method"(type_obj, "blorst", $P1919)
    get_how $P1920, type_obj
    get_global $P1921, "!PREFIX__blorst"
    $P1920."add_method"(type_obj, "!PREFIX__blorst", $P1921)
    get_how $P1922, type_obj
    .const 'Sub' $P1923 = "92_1303401201.841" 
    $P1922."add_method"(type_obj, "statement_mod_cond", $P1923)
    get_how $P1924, type_obj
    .const 'Sub' $P1925 = "93_1303401201.841" 
    $P1924."add_method"(type_obj, "!PREFIX__statement_mod_cond", $P1925)
    get_how $P1926, type_obj
    .const 'Sub' $P1927 = "94_1303401201.841" 
    $P1926."add_method"(type_obj, "statement_mod_cond:sym<if>", $P1927)
    get_how $P1928, type_obj
    get_global $P1929, "!PREFIX__statement_mod_cond:sym<if>"
    $P1928."add_method"(type_obj, "!PREFIX__statement_mod_cond:sym<if>", $P1929)
    get_how $P1930, type_obj
    .const 'Sub' $P1931 = "96_1303401201.841" 
    $P1930."add_method"(type_obj, "statement_mod_cond:sym<unless>", $P1931)
    get_how $P1932, type_obj
    get_global $P1933, "!PREFIX__statement_mod_cond:sym<unless>"
    $P1932."add_method"(type_obj, "!PREFIX__statement_mod_cond:sym<unless>", $P1933)
    get_how $P1934, type_obj
    .const 'Sub' $P1935 = "98_1303401201.841" 
    $P1934."add_method"(type_obj, "statement_mod_loop", $P1935)
    get_how $P1936, type_obj
    .const 'Sub' $P1937 = "99_1303401201.841" 
    $P1936."add_method"(type_obj, "!PREFIX__statement_mod_loop", $P1937)
    get_how $P1938, type_obj
    .const 'Sub' $P1939 = "100_1303401201.841" 
    $P1938."add_method"(type_obj, "statement_mod_loop:sym<while>", $P1939)
    get_how $P1940, type_obj
    get_global $P1941, "!PREFIX__statement_mod_loop:sym<while>"
    $P1940."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<while>", $P1941)
    get_how $P1942, type_obj
    .const 'Sub' $P1943 = "102_1303401201.841" 
    $P1942."add_method"(type_obj, "statement_mod_loop:sym<until>", $P1943)
    get_how $P1944, type_obj
    get_global $P1945, "!PREFIX__statement_mod_loop:sym<until>"
    $P1944."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<until>", $P1945)
    get_how $P1946, type_obj
    .const 'Sub' $P1947 = "104_1303401201.841" 
    $P1946."add_method"(type_obj, "statement_mod_loop:sym<for>", $P1947)
    get_how $P1948, type_obj
    get_global $P1949, "!PREFIX__statement_mod_loop:sym<for>"
    $P1948."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<for>", $P1949)
    get_how $P1950, type_obj
    .const 'Sub' $P1951 = "106_1303401201.841" 
    $P1950."add_method"(type_obj, "term:sym<fatarrow>", $P1951)
    get_how $P1952, type_obj
    get_global $P1953, "!PREFIX__term:sym<fatarrow>"
    $P1952."add_method"(type_obj, "!PREFIX__term:sym<fatarrow>", $P1953)
    get_how $P1954, type_obj
    .const 'Sub' $P1955 = "108_1303401201.841" 
    $P1954."add_method"(type_obj, "term:sym<colonpair>", $P1955)
    get_how $P1956, type_obj
    get_global $P1957, "!PREFIX__term:sym<colonpair>"
    $P1956."add_method"(type_obj, "!PREFIX__term:sym<colonpair>", $P1957)
    get_how $P1958, type_obj
    .const 'Sub' $P1959 = "110_1303401201.841" 
    $P1958."add_method"(type_obj, "term:sym<variable>", $P1959)
    get_how $P1960, type_obj
    get_global $P1961, "!PREFIX__term:sym<variable>"
    $P1960."add_method"(type_obj, "!PREFIX__term:sym<variable>", $P1961)
    get_how $P1962, type_obj
    .const 'Sub' $P1963 = "112_1303401201.841" 
    $P1962."add_method"(type_obj, "term:sym<package_declarator>", $P1963)
    get_how $P1964, type_obj
    get_global $P1965, "!PREFIX__term:sym<package_declarator>"
    $P1964."add_method"(type_obj, "!PREFIX__term:sym<package_declarator>", $P1965)
    get_how $P1966, type_obj
    .const 'Sub' $P1967 = "114_1303401201.841" 
    $P1966."add_method"(type_obj, "term:sym<scope_declarator>", $P1967)
    get_how $P1968, type_obj
    get_global $P1969, "!PREFIX__term:sym<scope_declarator>"
    $P1968."add_method"(type_obj, "!PREFIX__term:sym<scope_declarator>", $P1969)
    get_how $P1970, type_obj
    .const 'Sub' $P1971 = "116_1303401201.841" 
    $P1970."add_method"(type_obj, "term:sym<routine_declarator>", $P1971)
    get_how $P1972, type_obj
    get_global $P1973, "!PREFIX__term:sym<routine_declarator>"
    $P1972."add_method"(type_obj, "!PREFIX__term:sym<routine_declarator>", $P1973)
    get_how $P1974, type_obj
    .const 'Sub' $P1975 = "118_1303401201.841" 
    $P1974."add_method"(type_obj, "term:sym<multi_declarator>", $P1975)
    get_how $P1976, type_obj
    get_global $P1977, "!PREFIX__term:sym<multi_declarator>"
    $P1976."add_method"(type_obj, "!PREFIX__term:sym<multi_declarator>", $P1977)
    get_how $P1978, type_obj
    .const 'Sub' $P1979 = "122_1303401201.841" 
    $P1978."add_method"(type_obj, "term:sym<regex_declarator>", $P1979)
    get_how $P1980, type_obj
    get_global $P1981, "!PREFIX__term:sym<regex_declarator>"
    $P1980."add_method"(type_obj, "!PREFIX__term:sym<regex_declarator>", $P1981)
    get_how $P1982, type_obj
    .const 'Sub' $P1983 = "124_1303401201.841" 
    $P1982."add_method"(type_obj, "term:sym<statement_prefix>", $P1983)
    get_how $P1984, type_obj
    get_global $P1985, "!PREFIX__term:sym<statement_prefix>"
    $P1984."add_method"(type_obj, "!PREFIX__term:sym<statement_prefix>", $P1985)
    get_how $P1986, type_obj
    .const 'Sub' $P1987 = "126_1303401201.841" 
    $P1986."add_method"(type_obj, "term:sym<lambda>", $P1987)
    get_how $P1988, type_obj
    get_global $P1989, "!PREFIX__term:sym<lambda>"
    $P1988."add_method"(type_obj, "!PREFIX__term:sym<lambda>", $P1989)
    get_how $P1990, type_obj
    .const 'Sub' $P1991 = "128_1303401201.841" 
    $P1990."add_method"(type_obj, "fatarrow", $P1991)
    get_how $P1992, type_obj
    get_global $P1993, "!PREFIX__fatarrow"
    $P1992."add_method"(type_obj, "!PREFIX__fatarrow", $P1993)
    get_how $P1994, type_obj
    .const 'Sub' $P1995 = "130_1303401201.841" 
    $P1994."add_method"(type_obj, "colonpair", $P1995)
    get_how $P1996, type_obj
    get_global $P1997, "!PREFIX__colonpair"
    $P1996."add_method"(type_obj, "!PREFIX__colonpair", $P1997)
    get_how $P1998, type_obj
    .const 'Sub' $P1999 = "132_1303401201.841" 
    $P1998."add_method"(type_obj, "variable", $P1999)
    get_how $P2000, type_obj
    get_global $P2001, "!PREFIX__variable"
    $P2000."add_method"(type_obj, "!PREFIX__variable", $P2001)
    get_how $P2002, type_obj
    .const 'Sub' $P2003 = "134_1303401201.841" 
    $P2002."add_method"(type_obj, "sigil", $P2003)
    get_how $P2004, type_obj
    get_global $P2005, "!PREFIX__sigil"
    $P2004."add_method"(type_obj, "!PREFIX__sigil", $P2005)
    get_how $P2006, type_obj
    .const 'Sub' $P2007 = "136_1303401201.841" 
    $P2006."add_method"(type_obj, "twigil", $P2007)
    get_how $P2008, type_obj
    get_global $P2009, "!PREFIX__twigil"
    $P2008."add_method"(type_obj, "!PREFIX__twigil", $P2009)
    get_how $P2010, type_obj
    .const 'Sub' $P2011 = "138_1303401201.841" 
    $P2010."add_method"(type_obj, "package_declarator", $P2011)
    get_how $P2012, type_obj
    .const 'Sub' $P2013 = "139_1303401201.841" 
    $P2012."add_method"(type_obj, "!PREFIX__package_declarator", $P2013)
    get_how $P2014, type_obj
    .const 'Sub' $P2015 = "140_1303401201.841" 
    $P2014."add_method"(type_obj, "package_declarator:sym<module>", $P2015)
    get_how $P2016, type_obj
    get_global $P2017, "!PREFIX__package_declarator:sym<module>"
    $P2016."add_method"(type_obj, "!PREFIX__package_declarator:sym<module>", $P2017)
    get_how $P2018, type_obj
    .const 'Sub' $P2019 = "142_1303401201.841" 
    $P2018."add_method"(type_obj, "package_declarator:sym<knowhow>", $P2019)
    get_how $P2020, type_obj
    get_global $P2021, "!PREFIX__package_declarator:sym<knowhow>"
    $P2020."add_method"(type_obj, "!PREFIX__package_declarator:sym<knowhow>", $P2021)
    get_how $P2022, type_obj
    .const 'Sub' $P2023 = "144_1303401201.841" 
    $P2022."add_method"(type_obj, "package_declarator:sym<class>", $P2023)
    get_how $P2024, type_obj
    get_global $P2025, "!PREFIX__package_declarator:sym<class>"
    $P2024."add_method"(type_obj, "!PREFIX__package_declarator:sym<class>", $P2025)
    get_how $P2026, type_obj
    .const 'Sub' $P2027 = "146_1303401201.841" 
    $P2026."add_method"(type_obj, "package_declarator:sym<grammar>", $P2027)
    get_how $P2028, type_obj
    get_global $P2029, "!PREFIX__package_declarator:sym<grammar>"
    $P2028."add_method"(type_obj, "!PREFIX__package_declarator:sym<grammar>", $P2029)
    get_how $P2030, type_obj
    .const 'Sub' $P2031 = "148_1303401201.841" 
    $P2030."add_method"(type_obj, "package_declarator:sym<role>", $P2031)
    get_how $P2032, type_obj
    get_global $P2033, "!PREFIX__package_declarator:sym<role>"
    $P2032."add_method"(type_obj, "!PREFIX__package_declarator:sym<role>", $P2033)
    get_how $P2034, type_obj
    .const 'Sub' $P2035 = "150_1303401201.841" 
    $P2034."add_method"(type_obj, "package_declarator:sym<native>", $P2035)
    get_how $P2036, type_obj
    get_global $P2037, "!PREFIX__package_declarator:sym<native>"
    $P2036."add_method"(type_obj, "!PREFIX__package_declarator:sym<native>", $P2037)
    get_how $P2038, type_obj
    .const 'Sub' $P2039 = "152_1303401201.841" 
    $P2038."add_method"(type_obj, "package_def", $P2039)
    get_how $P2040, type_obj
    get_global $P2041, "!PREFIX__package_def"
    $P2040."add_method"(type_obj, "!PREFIX__package_def", $P2041)
    get_how $P2042, type_obj
    .const 'Sub' $P2043 = "155_1303401201.841" 
    $P2042."add_method"(type_obj, "scope_declarator", $P2043)
    get_how $P2044, type_obj
    .const 'Sub' $P2045 = "156_1303401201.841" 
    $P2044."add_method"(type_obj, "!PREFIX__scope_declarator", $P2045)
    get_how $P2046, type_obj
    .const 'Sub' $P2047 = "157_1303401201.841" 
    $P2046."add_method"(type_obj, "scope_declarator:sym<my>", $P2047)
    get_how $P2048, type_obj
    get_global $P2049, "!PREFIX__scope_declarator:sym<my>"
    $P2048."add_method"(type_obj, "!PREFIX__scope_declarator:sym<my>", $P2049)
    get_how $P2050, type_obj
    .const 'Sub' $P2051 = "159_1303401201.841" 
    $P2050."add_method"(type_obj, "scope_declarator:sym<our>", $P2051)
    get_how $P2052, type_obj
    get_global $P2053, "!PREFIX__scope_declarator:sym<our>"
    $P2052."add_method"(type_obj, "!PREFIX__scope_declarator:sym<our>", $P2053)
    get_how $P2054, type_obj
    .const 'Sub' $P2055 = "161_1303401201.841" 
    $P2054."add_method"(type_obj, "scope_declarator:sym<has>", $P2055)
    get_how $P2056, type_obj
    get_global $P2057, "!PREFIX__scope_declarator:sym<has>"
    $P2056."add_method"(type_obj, "!PREFIX__scope_declarator:sym<has>", $P2057)
    get_how $P2058, type_obj
    .const 'Sub' $P2059 = "163_1303401201.841" 
    $P2058."add_method"(type_obj, "scoped", $P2059)
    get_how $P2060, type_obj
    get_global $P2061, "!PREFIX__scoped"
    $P2060."add_method"(type_obj, "!PREFIX__scoped", $P2061)
    get_how $P2062, type_obj
    .const 'Sub' $P2063 = "165_1303401201.841" 
    $P2062."add_method"(type_obj, "typename", $P2063)
    get_how $P2064, type_obj
    get_global $P2065, "!PREFIX__typename"
    $P2064."add_method"(type_obj, "!PREFIX__typename", $P2065)
    get_how $P2066, type_obj
    .const 'Sub' $P2067 = "167_1303401201.841" 
    $P2066."add_method"(type_obj, "declarator", $P2067)
    get_how $P2068, type_obj
    get_global $P2069, "!PREFIX__declarator"
    $P2068."add_method"(type_obj, "!PREFIX__declarator", $P2069)
    get_how $P2070, type_obj
    .const 'Sub' $P2071 = "169_1303401201.841" 
    $P2070."add_method"(type_obj, "variable_declarator", $P2071)
    get_how $P2072, type_obj
    get_global $P2073, "!PREFIX__variable_declarator"
    $P2072."add_method"(type_obj, "!PREFIX__variable_declarator", $P2073)
    get_how $P2074, type_obj
    .const 'Sub' $P2075 = "171_1303401201.841" 
    $P2074."add_method"(type_obj, "routine_declarator", $P2075)
    get_how $P2076, type_obj
    .const 'Sub' $P2077 = "172_1303401201.841" 
    $P2076."add_method"(type_obj, "!PREFIX__routine_declarator", $P2077)
    get_how $P2078, type_obj
    .const 'Sub' $P2079 = "173_1303401201.841" 
    $P2078."add_method"(type_obj, "routine_declarator:sym<sub>", $P2079)
    get_how $P2080, type_obj
    get_global $P2081, "!PREFIX__routine_declarator:sym<sub>"
    $P2080."add_method"(type_obj, "!PREFIX__routine_declarator:sym<sub>", $P2081)
    get_how $P2082, type_obj
    .const 'Sub' $P2083 = "175_1303401201.841" 
    $P2082."add_method"(type_obj, "routine_declarator:sym<method>", $P2083)
    get_how $P2084, type_obj
    get_global $P2085, "!PREFIX__routine_declarator:sym<method>"
    $P2084."add_method"(type_obj, "!PREFIX__routine_declarator:sym<method>", $P2085)
    get_how $P2086, type_obj
    .const 'Sub' $P2087 = "177_1303401201.841" 
    $P2086."add_method"(type_obj, "routine_def", $P2087)
    get_how $P2088, type_obj
    get_global $P2089, "!PREFIX__routine_def"
    $P2088."add_method"(type_obj, "!PREFIX__routine_def", $P2089)
    get_how $P2090, type_obj
    .const 'Sub' $P2091 = "179_1303401201.841" 
    $P2090."add_method"(type_obj, "method_def", $P2091)
    get_how $P2092, type_obj
    get_global $P2093, "!PREFIX__method_def"
    $P2092."add_method"(type_obj, "!PREFIX__method_def", $P2093)
    get_how $P2094, type_obj
    .const 'Sub' $P2095 = "182_1303401201.841" 
    $P2094."add_method"(type_obj, "onlystar", $P2095)
    get_how $P2096, type_obj
    get_global $P2097, "!PREFIX__onlystar"
    $P2096."add_method"(type_obj, "!PREFIX__onlystar", $P2097)
    get_how $P2098, type_obj
    .const 'Sub' $P2099 = "185_1303401201.841" 
    $P2098."add_method"(type_obj, "multi_declarator", $P2099)
    get_how $P2100, type_obj
    .const 'Sub' $P2101 = "186_1303401201.841" 
    $P2100."add_method"(type_obj, "!PREFIX__multi_declarator", $P2101)
    get_how $P2102, type_obj
    .const 'Sub' $P2103 = "187_1303401201.841" 
    $P2102."add_method"(type_obj, "multi_declarator:sym<multi>", $P2103)
    get_how $P2104, type_obj
    get_global $P2105, "!PREFIX__multi_declarator:sym<multi>"
    $P2104."add_method"(type_obj, "!PREFIX__multi_declarator:sym<multi>", $P2105)
    get_how $P2106, type_obj
    .const 'Sub' $P2107 = "189_1303401201.841" 
    $P2106."add_method"(type_obj, "multi_declarator:sym<proto>", $P2107)
    get_how $P2108, type_obj
    get_global $P2109, "!PREFIX__multi_declarator:sym<proto>"
    $P2108."add_method"(type_obj, "!PREFIX__multi_declarator:sym<proto>", $P2109)
    get_how $P2110, type_obj
    .const 'Sub' $P2111 = "191_1303401201.841" 
    $P2110."add_method"(type_obj, "multi_declarator:sym<null>", $P2111)
    get_how $P2112, type_obj
    get_global $P2113, "!PREFIX__multi_declarator:sym<null>"
    $P2112."add_method"(type_obj, "!PREFIX__multi_declarator:sym<null>", $P2113)
    get_how $P2114, type_obj
    .const 'Sub' $P2115 = "193_1303401201.841" 
    $P2114."add_method"(type_obj, "signature", $P2115)
    get_how $P2116, type_obj
    get_global $P2117, "!PREFIX__signature"
    $P2116."add_method"(type_obj, "!PREFIX__signature", $P2117)
    get_how $P2118, type_obj
    .const 'Sub' $P2119 = "196_1303401201.841" 
    $P2118."add_method"(type_obj, "parameter", $P2119)
    get_how $P2120, type_obj
    get_global $P2121, "!PREFIX__parameter"
    $P2120."add_method"(type_obj, "!PREFIX__parameter", $P2121)
    get_how $P2122, type_obj
    .const 'Sub' $P2123 = "198_1303401201.841" 
    $P2122."add_method"(type_obj, "param_var", $P2123)
    get_how $P2124, type_obj
    get_global $P2125, "!PREFIX__param_var"
    $P2124."add_method"(type_obj, "!PREFIX__param_var", $P2125)
    get_how $P2126, type_obj
    .const 'Sub' $P2127 = "200_1303401201.841" 
    $P2126."add_method"(type_obj, "named_param", $P2127)
    get_how $P2128, type_obj
    get_global $P2129, "!PREFIX__named_param"
    $P2128."add_method"(type_obj, "!PREFIX__named_param", $P2129)
    get_how $P2130, type_obj
    .const 'Sub' $P2131 = "202_1303401201.841" 
    $P2130."add_method"(type_obj, "default_value", $P2131)
    get_how $P2132, type_obj
    get_global $P2133, "!PREFIX__default_value"
    $P2132."add_method"(type_obj, "!PREFIX__default_value", $P2133)
    get_how $P2134, type_obj
    .const 'Sub' $P2135 = "204_1303401201.841" 
    $P2134."add_method"(type_obj, "trait", $P2135)
    get_how $P2136, type_obj
    get_global $P2137, "!PREFIX__trait"
    $P2136."add_method"(type_obj, "!PREFIX__trait", $P2137)
    get_how $P2138, type_obj
    .const 'Sub' $P2139 = "206_1303401201.841" 
    $P2138."add_method"(type_obj, "trait_mod", $P2139)
    get_how $P2140, type_obj
    .const 'Sub' $P2141 = "207_1303401201.841" 
    $P2140."add_method"(type_obj, "!PREFIX__trait_mod", $P2141)
    get_how $P2142, type_obj
    .const 'Sub' $P2143 = "208_1303401201.841" 
    $P2142."add_method"(type_obj, "trait_mod:sym<is>", $P2143)
    get_how $P2144, type_obj
    get_global $P2145, "!PREFIX__trait_mod:sym<is>"
    $P2144."add_method"(type_obj, "!PREFIX__trait_mod:sym<is>", $P2145)
    get_how $P2146, type_obj
    .const 'Sub' $P2147 = "210_1303401201.841" 
    $P2146."add_method"(type_obj, "regex_declarator", $P2147)
    get_how $P2148, type_obj
    get_global $P2149, "!PREFIX__regex_declarator"
    $P2148."add_method"(type_obj, "!PREFIX__regex_declarator", $P2149)
    get_how $P2150, type_obj
    .const 'Sub' $P2151 = "212_1303401201.841" 
    $P2150."add_method"(type_obj, "dotty", $P2151)
    get_how $P2152, type_obj
    get_global $P2153, "!PREFIX__dotty"
    $P2152."add_method"(type_obj, "!PREFIX__dotty", $P2153)
    get_how $P2154, type_obj
    .const 'Sub' $P2155 = "214_1303401201.841" 
    $P2154."add_method"(type_obj, "term", $P2155)
    get_how $P2156, type_obj
    .const 'Sub' $P2157 = "215_1303401201.841" 
    $P2156."add_method"(type_obj, "!PREFIX__term", $P2157)
    get_how $P2158, type_obj
    .const 'Sub' $P2159 = "216_1303401201.841" 
    $P2158."add_method"(type_obj, "term:sym<self>", $P2159)
    get_how $P2160, type_obj
    get_global $P2161, "!PREFIX__term:sym<self>"
    $P2160."add_method"(type_obj, "!PREFIX__term:sym<self>", $P2161)
    get_how $P2162, type_obj
    .const 'Sub' $P2163 = "218_1303401201.841" 
    $P2162."add_method"(type_obj, "term:sym<identifier>", $P2163)
    get_how $P2164, type_obj
    get_global $P2165, "!PREFIX__term:sym<identifier>"
    $P2164."add_method"(type_obj, "!PREFIX__term:sym<identifier>", $P2165)
    get_how $P2166, type_obj
    .const 'Sub' $P2167 = "220_1303401201.841" 
    $P2166."add_method"(type_obj, "term:sym<name>", $P2167)
    get_how $P2168, type_obj
    get_global $P2169, "!PREFIX__term:sym<name>"
    $P2168."add_method"(type_obj, "!PREFIX__term:sym<name>", $P2169)
    get_how $P2170, type_obj
    .const 'Sub' $P2171 = "222_1303401201.841" 
    $P2170."add_method"(type_obj, "term:sym<pir::op>", $P2171)
    get_how $P2172, type_obj
    get_global $P2173, "!PREFIX__term:sym<pir::op>"
    $P2172."add_method"(type_obj, "!PREFIX__term:sym<pir::op>", $P2173)
    get_how $P2174, type_obj
    .const 'Sub' $P2175 = "224_1303401201.841" 
    $P2174."add_method"(type_obj, "term:sym<onlystar>", $P2175)
    get_how $P2176, type_obj
    get_global $P2177, "!PREFIX__term:sym<onlystar>"
    $P2176."add_method"(type_obj, "!PREFIX__term:sym<onlystar>", $P2177)
    get_how $P2178, type_obj
    .const 'Sub' $P2179 = "227_1303401201.841" 
    $P2178."add_method"(type_obj, "args", $P2179)
    get_how $P2180, type_obj
    get_global $P2181, "!PREFIX__args"
    $P2180."add_method"(type_obj, "!PREFIX__args", $P2181)
    get_how $P2182, type_obj
    .const 'Sub' $P2183 = "229_1303401201.841" 
    $P2182."add_method"(type_obj, "arglist", $P2183)
    get_how $P2184, type_obj
    get_global $P2185, "!PREFIX__arglist"
    $P2184."add_method"(type_obj, "!PREFIX__arglist", $P2185)
    get_how $P2186, type_obj
    .const 'Sub' $P2187 = "231_1303401201.841" 
    $P2186."add_method"(type_obj, "term:sym<value>", $P2187)
    get_how $P2188, type_obj
    get_global $P2189, "!PREFIX__term:sym<value>"
    $P2188."add_method"(type_obj, "!PREFIX__term:sym<value>", $P2189)
    get_how $P2190, type_obj
    .const 'Sub' $P2191 = "233_1303401201.841" 
    $P2190."add_method"(type_obj, "value", $P2191)
    get_how $P2192, type_obj
    get_global $P2193, "!PREFIX__value"
    $P2192."add_method"(type_obj, "!PREFIX__value", $P2193)
    get_how $P2194, type_obj
    .const 'Sub' $P2195 = "235_1303401201.841" 
    $P2194."add_method"(type_obj, "number", $P2195)
    get_how $P2196, type_obj
    get_global $P2197, "!PREFIX__number"
    $P2196."add_method"(type_obj, "!PREFIX__number", $P2197)
    get_how $P2198, type_obj
    .const 'Sub' $P2199 = "237_1303401201.841" 
    $P2198."add_method"(type_obj, "quote", $P2199)
    get_how $P2200, type_obj
    .const 'Sub' $P2201 = "238_1303401201.841" 
    $P2200."add_method"(type_obj, "!PREFIX__quote", $P2201)
    get_how $P2202, type_obj
    .const 'Sub' $P2203 = "239_1303401201.841" 
    $P2202."add_method"(type_obj, "quote:sym<apos>", $P2203)
    get_how $P2204, type_obj
    get_global $P2205, "!PREFIX__quote:sym<apos>"
    $P2204."add_method"(type_obj, "!PREFIX__quote:sym<apos>", $P2205)
    get_how $P2206, type_obj
    .const 'Sub' $P2207 = "241_1303401201.841" 
    $P2206."add_method"(type_obj, "quote:sym<dblq>", $P2207)
    get_how $P2208, type_obj
    get_global $P2209, "!PREFIX__quote:sym<dblq>"
    $P2208."add_method"(type_obj, "!PREFIX__quote:sym<dblq>", $P2209)
    get_how $P2210, type_obj
    .const 'Sub' $P2211 = "243_1303401201.841" 
    $P2210."add_method"(type_obj, "quote:sym<q>", $P2211)
    get_how $P2212, type_obj
    get_global $P2213, "!PREFIX__quote:sym<q>"
    $P2212."add_method"(type_obj, "!PREFIX__quote:sym<q>", $P2213)
    get_how $P2214, type_obj
    .const 'Sub' $P2215 = "245_1303401201.841" 
    $P2214."add_method"(type_obj, "quote:sym<qq>", $P2215)
    get_how $P2216, type_obj
    get_global $P2217, "!PREFIX__quote:sym<qq>"
    $P2216."add_method"(type_obj, "!PREFIX__quote:sym<qq>", $P2217)
    get_how $P2218, type_obj
    .const 'Sub' $P2219 = "247_1303401201.841" 
    $P2218."add_method"(type_obj, "quote:sym<Q>", $P2219)
    get_how $P2220, type_obj
    get_global $P2221, "!PREFIX__quote:sym<Q>"
    $P2220."add_method"(type_obj, "!PREFIX__quote:sym<Q>", $P2221)
    get_how $P2222, type_obj
    .const 'Sub' $P2223 = "249_1303401201.841" 
    $P2222."add_method"(type_obj, "quote:sym<Q:PIR>", $P2223)
    get_how $P2224, type_obj
    get_global $P2225, "!PREFIX__quote:sym<Q:PIR>"
    $P2224."add_method"(type_obj, "!PREFIX__quote:sym<Q:PIR>", $P2225)
    get_how $P2226, type_obj
    .const 'Sub' $P2227 = "251_1303401201.841" 
    $P2226."add_method"(type_obj, "quote:sym</ />", $P2227)
    get_how $P2228, type_obj
    get_global $P2229, "!PREFIX__quote:sym</ />"
    $P2228."add_method"(type_obj, "!PREFIX__quote:sym</ />", $P2229)
    get_how $P2230, type_obj
    .const 'Sub' $P2231 = "253_1303401201.841" 
    $P2230."add_method"(type_obj, "quote_escape:sym<$>", $P2231)
    get_how $P2232, type_obj
    get_global $P2233, "!PREFIX__quote_escape:sym<$>"
    $P2232."add_method"(type_obj, "!PREFIX__quote_escape:sym<$>", $P2233)
    get_how $P2234, type_obj
    .const 'Sub' $P2235 = "255_1303401201.841" 
    $P2234."add_method"(type_obj, "quote_escape:sym<{ }>", $P2235)
    get_how $P2236, type_obj
    get_global $P2237, "!PREFIX__quote_escape:sym<{ }>"
    $P2236."add_method"(type_obj, "!PREFIX__quote_escape:sym<{ }>", $P2237)
    get_how $P2238, type_obj
    .const 'Sub' $P2239 = "257_1303401201.841" 
    $P2238."add_method"(type_obj, "quote_escape:sym<esc>", $P2239)
    get_how $P2240, type_obj
    get_global $P2241, "!PREFIX__quote_escape:sym<esc>"
    $P2240."add_method"(type_obj, "!PREFIX__quote_escape:sym<esc>", $P2241)
    get_how $P2242, type_obj
    .const 'Sub' $P2243 = "259_1303401201.841" 
    $P2242."add_method"(type_obj, "circumfix:sym<( )>", $P2243)
    get_how $P2244, type_obj
    get_global $P2245, "!PREFIX__circumfix:sym<( )>"
    $P2244."add_method"(type_obj, "!PREFIX__circumfix:sym<( )>", $P2245)
    get_how $P2246, type_obj
    .const 'Sub' $P2247 = "261_1303401201.841" 
    $P2246."add_method"(type_obj, "circumfix:sym<[ ]>", $P2247)
    get_how $P2248, type_obj
    get_global $P2249, "!PREFIX__circumfix:sym<[ ]>"
    $P2248."add_method"(type_obj, "!PREFIX__circumfix:sym<[ ]>", $P2249)
    get_how $P2250, type_obj
    .const 'Sub' $P2251 = "263_1303401201.841" 
    $P2250."add_method"(type_obj, "circumfix:sym<ang>", $P2251)
    get_how $P2252, type_obj
    get_global $P2253, "!PREFIX__circumfix:sym<ang>"
    $P2252."add_method"(type_obj, "!PREFIX__circumfix:sym<ang>", $P2253)
    get_how $P2254, type_obj
    .const 'Sub' $P2255 = "265_1303401201.841" 
    $P2254."add_method"(type_obj, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P2255)
    get_how $P2256, type_obj
    get_global $P2257, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"
    $P2256."add_method"(type_obj, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>", $P2257)
    get_how $P2258, type_obj
    .const 'Sub' $P2259 = "267_1303401201.841" 
    $P2258."add_method"(type_obj, "circumfix:sym<{ }>", $P2259)
    get_how $P2260, type_obj
    get_global $P2261, "!PREFIX__circumfix:sym<{ }>"
    $P2260."add_method"(type_obj, "!PREFIX__circumfix:sym<{ }>", $P2261)
    get_how $P2262, type_obj
    .const 'Sub' $P2263 = "269_1303401201.841" 
    $P2262."add_method"(type_obj, "circumfix:sym<sigil>", $P2263)
    get_how $P2264, type_obj
    get_global $P2265, "!PREFIX__circumfix:sym<sigil>"
    $P2264."add_method"(type_obj, "!PREFIX__circumfix:sym<sigil>", $P2265)
    get_how $P2266, type_obj
    .const 'Sub' $P2267 = "271_1303401201.841" 
    $P2266."add_method"(type_obj, "semilist", $P2267)
    get_how $P2268, type_obj
    get_global $P2269, "!PREFIX__semilist"
    $P2268."add_method"(type_obj, "!PREFIX__semilist", $P2269)
    get_how $P2270, type_obj
    .const 'Sub' $P2271 = "273_1303401201.841" 
    $P2270."add_method"(type_obj, "infixish", $P2271)
    get_how $P2272, type_obj
    get_global $P2273, "!PREFIX__infixish"
    $P2272."add_method"(type_obj, "!PREFIX__infixish", $P2273)
    get_how $P2274, type_obj
    .const 'Sub' $P2275 = "275_1303401201.841" 
    $P2274."add_method"(type_obj, "infixstopper", $P2275)
    get_how $P2276, type_obj
    get_global $P2277, "!PREFIX__infixstopper"
    $P2276."add_method"(type_obj, "!PREFIX__infixstopper", $P2277)
    get_how $P2278, type_obj
    .const 'Sub' $P2279 = "277_1303401201.841" 
    $P2278."add_method"(type_obj, "postcircumfix:sym<[ ]>", $P2279)
    get_how $P2280, type_obj
    get_global $P2281, "!PREFIX__postcircumfix:sym<[ ]>"
    $P2280."add_method"(type_obj, "!PREFIX__postcircumfix:sym<[ ]>", $P2281)
    get_how $P2282, type_obj
    .const 'Sub' $P2283 = "279_1303401201.841" 
    $P2282."add_method"(type_obj, "postcircumfix:sym<{ }>", $P2283)
    get_how $P2284, type_obj
    get_global $P2285, "!PREFIX__postcircumfix:sym<{ }>"
    $P2284."add_method"(type_obj, "!PREFIX__postcircumfix:sym<{ }>", $P2285)
    get_how $P2286, type_obj
    .const 'Sub' $P2287 = "281_1303401201.841" 
    $P2286."add_method"(type_obj, "postcircumfix:sym<ang>", $P2287)
    get_how $P2288, type_obj
    get_global $P2289, "!PREFIX__postcircumfix:sym<ang>"
    $P2288."add_method"(type_obj, "!PREFIX__postcircumfix:sym<ang>", $P2289)
    get_how $P2290, type_obj
    .const 'Sub' $P2291 = "283_1303401201.841" 
    $P2290."add_method"(type_obj, "postcircumfix:sym<( )>", $P2291)
    get_how $P2292, type_obj
    get_global $P2293, "!PREFIX__postcircumfix:sym<( )>"
    $P2292."add_method"(type_obj, "!PREFIX__postcircumfix:sym<( )>", $P2293)
    get_how $P2294, type_obj
    .const 'Sub' $P2295 = "285_1303401201.841" 
    $P2294."add_method"(type_obj, "postfix:sym<.>", $P2295)
    get_how $P2296, type_obj
    get_global $P2297, "!PREFIX__postfix:sym<.>"
    $P2296."add_method"(type_obj, "!PREFIX__postfix:sym<.>", $P2297)
    get_how $P2298, type_obj
    .const 'Sub' $P2299 = "287_1303401201.841" 
    $P2298."add_method"(type_obj, "prefix:sym<++>", $P2299)
    get_how $P2300, type_obj
    get_global $P2301, "!PREFIX__prefix:sym<++>"
    $P2300."add_method"(type_obj, "!PREFIX__prefix:sym<++>", $P2301)
    get_how $P2302, type_obj
    .const 'Sub' $P2303 = "289_1303401201.841" 
    $P2302."add_method"(type_obj, "prefix:sym<-->", $P2303)
    get_how $P2304, type_obj
    get_global $P2305, "!PREFIX__prefix:sym<-->"
    $P2304."add_method"(type_obj, "!PREFIX__prefix:sym<-->", $P2305)
    get_how $P2306, type_obj
    .const 'Sub' $P2307 = "291_1303401201.841" 
    $P2306."add_method"(type_obj, "postfix:sym<++>", $P2307)
    get_how $P2308, type_obj
    get_global $P2309, "!PREFIX__postfix:sym<++>"
    $P2308."add_method"(type_obj, "!PREFIX__postfix:sym<++>", $P2309)
    get_how $P2310, type_obj
    .const 'Sub' $P2311 = "293_1303401201.841" 
    $P2310."add_method"(type_obj, "postfix:sym<-->", $P2311)
    get_how $P2312, type_obj
    get_global $P2313, "!PREFIX__postfix:sym<-->"
    $P2312."add_method"(type_obj, "!PREFIX__postfix:sym<-->", $P2313)
    get_how $P2314, type_obj
    .const 'Sub' $P2315 = "295_1303401201.841" 
    $P2314."add_method"(type_obj, "infix:sym<**>", $P2315)
    get_how $P2316, type_obj
    get_global $P2317, "!PREFIX__infix:sym<**>"
    $P2316."add_method"(type_obj, "!PREFIX__infix:sym<**>", $P2317)
    get_how $P2318, type_obj
    .const 'Sub' $P2319 = "297_1303401201.841" 
    $P2318."add_method"(type_obj, "prefix:sym<+>", $P2319)
    get_how $P2320, type_obj
    get_global $P2321, "!PREFIX__prefix:sym<+>"
    $P2320."add_method"(type_obj, "!PREFIX__prefix:sym<+>", $P2321)
    get_how $P2322, type_obj
    .const 'Sub' $P2323 = "299_1303401201.841" 
    $P2322."add_method"(type_obj, "prefix:sym<~>", $P2323)
    get_how $P2324, type_obj
    get_global $P2325, "!PREFIX__prefix:sym<~>"
    $P2324."add_method"(type_obj, "!PREFIX__prefix:sym<~>", $P2325)
    get_how $P2326, type_obj
    .const 'Sub' $P2327 = "301_1303401201.841" 
    $P2326."add_method"(type_obj, "prefix:sym<->", $P2327)
    get_how $P2328, type_obj
    get_global $P2329, "!PREFIX__prefix:sym<->"
    $P2328."add_method"(type_obj, "!PREFIX__prefix:sym<->", $P2329)
    get_how $P2330, type_obj
    .const 'Sub' $P2331 = "303_1303401201.841" 
    $P2330."add_method"(type_obj, "prefix:sym<?>", $P2331)
    get_how $P2332, type_obj
    get_global $P2333, "!PREFIX__prefix:sym<?>"
    $P2332."add_method"(type_obj, "!PREFIX__prefix:sym<?>", $P2333)
    get_how $P2334, type_obj
    .const 'Sub' $P2335 = "305_1303401201.841" 
    $P2334."add_method"(type_obj, "prefix:sym<!>", $P2335)
    get_how $P2336, type_obj
    get_global $P2337, "!PREFIX__prefix:sym<!>"
    $P2336."add_method"(type_obj, "!PREFIX__prefix:sym<!>", $P2337)
    get_how $P2338, type_obj
    .const 'Sub' $P2339 = "307_1303401201.841" 
    $P2338."add_method"(type_obj, "prefix:sym<|>", $P2339)
    get_how $P2340, type_obj
    get_global $P2341, "!PREFIX__prefix:sym<|>"
    $P2340."add_method"(type_obj, "!PREFIX__prefix:sym<|>", $P2341)
    get_how $P2342, type_obj
    .const 'Sub' $P2343 = "309_1303401201.841" 
    $P2342."add_method"(type_obj, "infix:sym<*>", $P2343)
    get_how $P2344, type_obj
    get_global $P2345, "!PREFIX__infix:sym<*>"
    $P2344."add_method"(type_obj, "!PREFIX__infix:sym<*>", $P2345)
    get_how $P2346, type_obj
    .const 'Sub' $P2347 = "311_1303401201.841" 
    $P2346."add_method"(type_obj, "infix:sym</>", $P2347)
    get_how $P2348, type_obj
    get_global $P2349, "!PREFIX__infix:sym</>"
    $P2348."add_method"(type_obj, "!PREFIX__infix:sym</>", $P2349)
    get_how $P2350, type_obj
    .const 'Sub' $P2351 = "313_1303401201.841" 
    $P2350."add_method"(type_obj, "infix:sym<%>", $P2351)
    get_how $P2352, type_obj
    get_global $P2353, "!PREFIX__infix:sym<%>"
    $P2352."add_method"(type_obj, "!PREFIX__infix:sym<%>", $P2353)
    get_how $P2354, type_obj
    .const 'Sub' $P2355 = "315_1303401201.841" 
    $P2354."add_method"(type_obj, "infix:sym<+&>", $P2355)
    get_how $P2356, type_obj
    get_global $P2357, "!PREFIX__infix:sym<+&>"
    $P2356."add_method"(type_obj, "!PREFIX__infix:sym<+&>", $P2357)
    get_how $P2358, type_obj
    .const 'Sub' $P2359 = "317_1303401201.841" 
    $P2358."add_method"(type_obj, "infix:sym<+>", $P2359)
    get_how $P2360, type_obj
    get_global $P2361, "!PREFIX__infix:sym<+>"
    $P2360."add_method"(type_obj, "!PREFIX__infix:sym<+>", $P2361)
    get_how $P2362, type_obj
    .const 'Sub' $P2363 = "319_1303401201.841" 
    $P2362."add_method"(type_obj, "infix:sym<->", $P2363)
    get_how $P2364, type_obj
    get_global $P2365, "!PREFIX__infix:sym<->"
    $P2364."add_method"(type_obj, "!PREFIX__infix:sym<->", $P2365)
    get_how $P2366, type_obj
    .const 'Sub' $P2367 = "321_1303401201.841" 
    $P2366."add_method"(type_obj, "infix:sym<+|>", $P2367)
    get_how $P2368, type_obj
    get_global $P2369, "!PREFIX__infix:sym<+|>"
    $P2368."add_method"(type_obj, "!PREFIX__infix:sym<+|>", $P2369)
    get_how $P2370, type_obj
    .const 'Sub' $P2371 = "323_1303401201.841" 
    $P2370."add_method"(type_obj, "infix:sym<+^>", $P2371)
    get_how $P2372, type_obj
    get_global $P2373, "!PREFIX__infix:sym<+^>"
    $P2372."add_method"(type_obj, "!PREFIX__infix:sym<+^>", $P2373)
    get_how $P2374, type_obj
    .const 'Sub' $P2375 = "325_1303401201.841" 
    $P2374."add_method"(type_obj, "infix:sym<~>", $P2375)
    get_how $P2376, type_obj
    get_global $P2377, "!PREFIX__infix:sym<~>"
    $P2376."add_method"(type_obj, "!PREFIX__infix:sym<~>", $P2377)
    get_how $P2378, type_obj
    .const 'Sub' $P2379 = "327_1303401201.841" 
    $P2378."add_method"(type_obj, "infix:sym<==>", $P2379)
    get_how $P2380, type_obj
    get_global $P2381, "!PREFIX__infix:sym<==>"
    $P2380."add_method"(type_obj, "!PREFIX__infix:sym<==>", $P2381)
    get_how $P2382, type_obj
    .const 'Sub' $P2383 = "329_1303401201.841" 
    $P2382."add_method"(type_obj, "infix:sym<!=>", $P2383)
    get_how $P2384, type_obj
    get_global $P2385, "!PREFIX__infix:sym<!=>"
    $P2384."add_method"(type_obj, "!PREFIX__infix:sym<!=>", $P2385)
    get_how $P2386, type_obj
    .const 'Sub' $P2387 = "331_1303401201.841" 
    $P2386."add_method"(type_obj, "infix:sym<<=>", $P2387)
    get_how $P2388, type_obj
    get_global $P2389, "!PREFIX__infix:sym<<=>"
    $P2388."add_method"(type_obj, "!PREFIX__infix:sym<<=>", $P2389)
    get_how $P2390, type_obj
    .const 'Sub' $P2391 = "333_1303401201.841" 
    $P2390."add_method"(type_obj, "infix:sym<>=>", $P2391)
    get_how $P2392, type_obj
    get_global $P2393, "!PREFIX__infix:sym<>=>"
    $P2392."add_method"(type_obj, "!PREFIX__infix:sym<>=>", $P2393)
    get_how $P2394, type_obj
    .const 'Sub' $P2395 = "335_1303401201.841" 
    $P2394."add_method"(type_obj, "infix:sym<<>", $P2395)
    get_how $P2396, type_obj
    get_global $P2397, "!PREFIX__infix:sym<<>"
    $P2396."add_method"(type_obj, "!PREFIX__infix:sym<<>", $P2397)
    get_how $P2398, type_obj
    .const 'Sub' $P2399 = "337_1303401201.841" 
    $P2398."add_method"(type_obj, "infix:sym<>>", $P2399)
    get_how $P2400, type_obj
    get_global $P2401, "!PREFIX__infix:sym<>>"
    $P2400."add_method"(type_obj, "!PREFIX__infix:sym<>>", $P2401)
    get_how $P2402, type_obj
    .const 'Sub' $P2403 = "339_1303401201.841" 
    $P2402."add_method"(type_obj, "infix:sym<eq>", $P2403)
    get_how $P2404, type_obj
    get_global $P2405, "!PREFIX__infix:sym<eq>"
    $P2404."add_method"(type_obj, "!PREFIX__infix:sym<eq>", $P2405)
    get_how $P2406, type_obj
    .const 'Sub' $P2407 = "341_1303401201.841" 
    $P2406."add_method"(type_obj, "infix:sym<ne>", $P2407)
    get_how $P2408, type_obj
    get_global $P2409, "!PREFIX__infix:sym<ne>"
    $P2408."add_method"(type_obj, "!PREFIX__infix:sym<ne>", $P2409)
    get_how $P2410, type_obj
    .const 'Sub' $P2411 = "343_1303401201.841" 
    $P2410."add_method"(type_obj, "infix:sym<le>", $P2411)
    get_how $P2412, type_obj
    get_global $P2413, "!PREFIX__infix:sym<le>"
    $P2412."add_method"(type_obj, "!PREFIX__infix:sym<le>", $P2413)
    get_how $P2414, type_obj
    .const 'Sub' $P2415 = "345_1303401201.841" 
    $P2414."add_method"(type_obj, "infix:sym<ge>", $P2415)
    get_how $P2416, type_obj
    get_global $P2417, "!PREFIX__infix:sym<ge>"
    $P2416."add_method"(type_obj, "!PREFIX__infix:sym<ge>", $P2417)
    get_how $P2418, type_obj
    .const 'Sub' $P2419 = "347_1303401201.841" 
    $P2418."add_method"(type_obj, "infix:sym<lt>", $P2419)
    get_how $P2420, type_obj
    get_global $P2421, "!PREFIX__infix:sym<lt>"
    $P2420."add_method"(type_obj, "!PREFIX__infix:sym<lt>", $P2421)
    get_how $P2422, type_obj
    .const 'Sub' $P2423 = "349_1303401201.841" 
    $P2422."add_method"(type_obj, "infix:sym<gt>", $P2423)
    get_how $P2424, type_obj
    get_global $P2425, "!PREFIX__infix:sym<gt>"
    $P2424."add_method"(type_obj, "!PREFIX__infix:sym<gt>", $P2425)
    get_how $P2426, type_obj
    .const 'Sub' $P2427 = "351_1303401201.841" 
    $P2426."add_method"(type_obj, "infix:sym<=:=>", $P2427)
    get_how $P2428, type_obj
    get_global $P2429, "!PREFIX__infix:sym<=:=>"
    $P2428."add_method"(type_obj, "!PREFIX__infix:sym<=:=>", $P2429)
    get_how $P2430, type_obj
    .const 'Sub' $P2431 = "353_1303401201.841" 
    $P2430."add_method"(type_obj, "infix:sym<~~>", $P2431)
    get_how $P2432, type_obj
    get_global $P2433, "!PREFIX__infix:sym<~~>"
    $P2432."add_method"(type_obj, "!PREFIX__infix:sym<~~>", $P2433)
    get_how $P2434, type_obj
    .const 'Sub' $P2435 = "355_1303401201.841" 
    $P2434."add_method"(type_obj, "infix:sym<&&>", $P2435)
    get_how $P2436, type_obj
    get_global $P2437, "!PREFIX__infix:sym<&&>"
    $P2436."add_method"(type_obj, "!PREFIX__infix:sym<&&>", $P2437)
    get_how $P2438, type_obj
    .const 'Sub' $P2439 = "357_1303401201.841" 
    $P2438."add_method"(type_obj, "infix:sym<||>", $P2439)
    get_how $P2440, type_obj
    get_global $P2441, "!PREFIX__infix:sym<||>"
    $P2440."add_method"(type_obj, "!PREFIX__infix:sym<||>", $P2441)
    get_how $P2442, type_obj
    .const 'Sub' $P2443 = "359_1303401201.841" 
    $P2442."add_method"(type_obj, "infix:sym<//>", $P2443)
    get_how $P2444, type_obj
    get_global $P2445, "!PREFIX__infix:sym<//>"
    $P2444."add_method"(type_obj, "!PREFIX__infix:sym<//>", $P2445)
    get_how $P2446, type_obj
    .const 'Sub' $P2447 = "361_1303401201.841" 
    $P2446."add_method"(type_obj, "infix:sym<?? !!>", $P2447)
    get_how $P2448, type_obj
    get_global $P2449, "!PREFIX__infix:sym<?? !!>"
    $P2448."add_method"(type_obj, "!PREFIX__infix:sym<?? !!>", $P2449)
    get_how $P2450, type_obj
    .const 'Sub' $P2451 = "363_1303401201.841" 
    $P2450."add_method"(type_obj, "infix:sym<=>", $P2451)
    get_how $P2452, type_obj
    get_global $P2453, "!PREFIX__infix:sym<=>"
    $P2452."add_method"(type_obj, "!PREFIX__infix:sym<=>", $P2453)
    get_how $P2454, type_obj
    .const 'Sub' $P2455 = "365_1303401201.841" 
    $P2454."add_method"(type_obj, "infix:sym<:=>", $P2455)
    get_how $P2456, type_obj
    get_global $P2457, "!PREFIX__infix:sym<:=>"
    $P2456."add_method"(type_obj, "!PREFIX__infix:sym<:=>", $P2457)
    get_how $P2458, type_obj
    .const 'Sub' $P2459 = "367_1303401201.841" 
    $P2458."add_method"(type_obj, "infix:sym<::=>", $P2459)
    get_how $P2460, type_obj
    get_global $P2461, "!PREFIX__infix:sym<::=>"
    $P2460."add_method"(type_obj, "!PREFIX__infix:sym<::=>", $P2461)
    get_how $P2462, type_obj
    .const 'Sub' $P2463 = "369_1303401201.841" 
    $P2462."add_method"(type_obj, "infix:sym<,>", $P2463)
    get_how $P2464, type_obj
    get_global $P2465, "!PREFIX__infix:sym<,>"
    $P2464."add_method"(type_obj, "!PREFIX__infix:sym<,>", $P2465)
    get_how $P2466, type_obj
    .const 'Sub' $P2467 = "371_1303401201.841" 
    $P2466."add_method"(type_obj, "prefix:sym<return>", $P2467)
    get_how $P2468, type_obj
    get_global $P2469, "!PREFIX__prefix:sym<return>"
    $P2468."add_method"(type_obj, "!PREFIX__prefix:sym<return>", $P2469)
    get_how $P2470, type_obj
    .const 'Sub' $P2471 = "374_1303401201.841" 
    $P2470."add_method"(type_obj, "prefix:sym<make>", $P2471)
    get_how $P2472, type_obj
    get_global $P2473, "!PREFIX__prefix:sym<make>"
    $P2472."add_method"(type_obj, "!PREFIX__prefix:sym<make>", $P2473)
    get_how $P2474, type_obj
    .const 'Sub' $P2475 = "376_1303401201.841" 
    $P2474."add_method"(type_obj, "term:sym<last>", $P2475)
    get_how $P2476, type_obj
    get_global $P2477, "!PREFIX__term:sym<last>"
    $P2476."add_method"(type_obj, "!PREFIX__term:sym<last>", $P2477)
    get_how $P2478, type_obj
    .const 'Sub' $P2479 = "378_1303401201.841" 
    $P2478."add_method"(type_obj, "term:sym<next>", $P2479)
    get_how $P2480, type_obj
    get_global $P2481, "!PREFIX__term:sym<next>"
    $P2480."add_method"(type_obj, "!PREFIX__term:sym<next>", $P2481)
    get_how $P2482, type_obj
    .const 'Sub' $P2483 = "380_1303401201.841" 
    $P2482."add_method"(type_obj, "term:sym<redo>", $P2483)
    get_how $P2484, type_obj
    get_global $P2485, "!PREFIX__term:sym<redo>"
    $P2484."add_method"(type_obj, "!PREFIX__term:sym<redo>", $P2485)
    get_how $P2486, type_obj
    .const 'Sub' $P2487 = "382_1303401201.841" 
    $P2486."add_method"(type_obj, "smartmatch", $P2487)
    get_how $P2488, type_obj
    get_hll_global $P2489, ["HLL"], "Grammar"
    $P2488."add_parent"(type_obj, $P2489)
    get_how $P2490, type_obj
    $P2491 = $P2490."compose"(type_obj)
    .return ($P2491)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "TOP"  :subid("13_1303401201.841") :outer("12_1303401201.841")
    .param pmc param_55
.annotate 'line', 10
    .lex "self", param_55
.annotate 'line', 12
    $P56 = root_new ['parrot';'Hash']
    .lex "%*LANG", $P56
.annotate 'line', 19
    $P57 = root_new ['parrot';'Hash']
    .lex "%*HOW", $P57
.annotate 'line', 28
    new $P58, "Undef"
    .lex "$*DEFAULT-METAATTR", $P58
.annotate 'line', 29
    $P59 = root_new ['parrot';'Hash']
    .lex "%*HOW-METAATTR", $P59
.annotate 'line', 35
    new $P60, "Undef"
    .lex "$*SC", $P60
.annotate 'line', 39
    new $P61, "Undef"
    .lex "$*SCOPE", $P61
.annotate 'line', 40
    new $P62, "Undef"
    .lex "$*MULTINESS", $P62
.annotate 'line', 41
    new $P63, "Undef"
    .lex "$*INVOCANT_OK", $P63
.annotate 'line', 42
    new $P64, "Undef"
    .lex "$*RETURN_USED", $P64
.annotate 'line', 43
    new $P65, "Undef"
    .lex "$*PACKAGE-SETUP", $P65
.annotate 'line', 10
    find_lex $P66, "%*LANG"
    unless_null $P66, vivify_584
    get_hll_global $P66, "%LANG"
    unless_null $P66, vivify_585
    die "Contextual %*LANG not found"
  vivify_585:
  vivify_584:
.annotate 'line', 13
    get_hll_global $P67, ["NQP"], "Regex"
    find_lex $P68, "%*LANG"
    unless_null $P68, vivify_586
    get_hll_global $P68, "%LANG"
    unless_null $P68, vivify_587
    die "Contextual %*LANG not found"
  vivify_587:
    store_lex "%*LANG", $P68
  vivify_586:
    set $P68["Regex"], $P67
.annotate 'line', 14
    get_hll_global $P69, ["NQP"], "RegexActions"
    find_lex $P70, "%*LANG"
    unless_null $P70, vivify_588
    get_hll_global $P70, "%LANG"
    unless_null $P70, vivify_589
    die "Contextual %*LANG not found"
  vivify_589:
    store_lex "%*LANG", $P70
  vivify_588:
    set $P70["Regex-actions"], $P69
.annotate 'line', 15
    get_hll_global $P71, ["NQP"], "Grammar"
    find_lex $P72, "%*LANG"
    unless_null $P72, vivify_590
    get_hll_global $P72, "%LANG"
    unless_null $P72, vivify_591
    die "Contextual %*LANG not found"
  vivify_591:
    store_lex "%*LANG", $P72
  vivify_590:
    set $P72["MAIN"], $P71
.annotate 'line', 16
    get_hll_global $P73, ["NQP"], "Actions"
    find_lex $P74, "%*LANG"
    unless_null $P74, vivify_592
    get_hll_global $P74, "%LANG"
    unless_null $P74, vivify_593
    die "Contextual %*LANG not found"
  vivify_593:
    store_lex "%*LANG", $P74
  vivify_592:
    set $P74["MAIN-actions"], $P73
    find_lex $P75, "%*HOW"
    unless_null $P75, vivify_594
    get_hll_global $P75, "%HOW"
    unless_null $P75, vivify_595
    die "Contextual %*HOW not found"
  vivify_595:
  vivify_594:
.annotate 'line', 20
    get_hll_global $P76, "KnowHOW"
    find_lex $P77, "%*HOW"
    unless_null $P77, vivify_596
    get_hll_global $P77, "%HOW"
    unless_null $P77, vivify_597
    die "Contextual %*HOW not found"
  vivify_597:
    store_lex "%*HOW", $P77
  vivify_596:
    set $P77["knowhow"], $P76
.annotate 'line', 21
    get_hll_global $P78, "NQPModuleHOW"
    find_lex $P79, "%*HOW"
    unless_null $P79, vivify_598
    get_hll_global $P79, "%HOW"
    unless_null $P79, vivify_599
    die "Contextual %*HOW not found"
  vivify_599:
    store_lex "%*HOW", $P79
  vivify_598:
    set $P79["module"], $P78
.annotate 'line', 22
    get_hll_global $P80, "NQPClassHOW"
    find_lex $P81, "%*HOW"
    unless_null $P81, vivify_600
    get_hll_global $P81, "%HOW"
    unless_null $P81, vivify_601
    die "Contextual %*HOW not found"
  vivify_601:
    store_lex "%*HOW", $P81
  vivify_600:
    set $P81["class"], $P80
.annotate 'line', 23
    get_hll_global $P82, "NQPClassHOW"
    find_lex $P83, "%*HOW"
    unless_null $P83, vivify_602
    get_hll_global $P83, "%HOW"
    unless_null $P83, vivify_603
    die "Contextual %*HOW not found"
  vivify_603:
    store_lex "%*HOW", $P83
  vivify_602:
    set $P83["grammar"], $P82
.annotate 'line', 24
    get_hll_global $P84, "NQPParametricRoleHOW"
    find_lex $P85, "%*HOW"
    unless_null $P85, vivify_604
    get_hll_global $P85, "%HOW"
    unless_null $P85, vivify_605
    die "Contextual %*HOW not found"
  vivify_605:
    store_lex "%*HOW", $P85
  vivify_604:
    set $P85["role"], $P84
.annotate 'line', 25
    get_hll_global $P86, "NQPNativeHOW"
    find_lex $P87, "%*HOW"
    unless_null $P87, vivify_606
    get_hll_global $P87, "%HOW"
    unless_null $P87, vivify_607
    die "Contextual %*HOW not found"
  vivify_607:
    store_lex "%*HOW", $P87
  vivify_606:
    set $P87["native"], $P86
.annotate 'line', 28
    new $P88, "String"
    assign $P88, "NQPAttribute"
    store_lex "$*DEFAULT-METAATTR", $P88
    find_lex $P89, "%*HOW-METAATTR"
    unless_null $P89, vivify_608
    get_hll_global $P89, "%HOW-METAATTR"
    unless_null $P89, vivify_609
    die "Contextual %*HOW-METAATTR not found"
  vivify_609:
  vivify_608:
.annotate 'line', 30
    new $P90, "String"
    assign $P90, "KnowHOWAttribute"
    find_lex $P91, "%*HOW-METAATTR"
    unless_null $P91, vivify_610
    get_hll_global $P91, "%HOW-METAATTR"
    unless_null $P91, vivify_611
    die "Contextual %*HOW-METAATTR not found"
  vivify_611:
    store_lex "%*HOW-METAATTR", $P91
  vivify_610:
    set $P91["knowhow"], $P90
.annotate 'line', 35
    get_hll_global $P92, ["HLL";"Compiler"], "SerializationContextBuilder"
.annotate 'line', 37
    time $N93
    set $S94, $N93
    $P95 = $P92."new"($S94 :named("handle"))
.annotate 'line', 35
    store_lex "$*SC", $P95
.annotate 'line', 39
    new $P96, "String"
    assign $P96, ""
    store_lex "$*SCOPE", $P96
.annotate 'line', 40
    new $P97, "String"
    assign $P97, ""
    store_lex "$*MULTINESS", $P97
.annotate 'line', 41
    new $P98, "Integer"
    assign $P98, 0
    store_lex "$*INVOCANT_OK", $P98
.annotate 'line', 42
    new $P99, "Integer"
    assign $P99, 0
    store_lex "$*RETURN_USED", $P99
    find_lex $P100, "$*PACKAGE-SETUP"
    unless_null $P100, vivify_612
    get_hll_global $P100, "$PACKAGE-SETUP"
    unless_null $P100, vivify_613
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_613:
  vivify_612:
.annotate 'line', 44
    find_lex $P101, "self"
    $P102 = $P101."comp_unit"()
.annotate 'line', 10
    .return ($P102)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "identifier"  :subid("14_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx104_tgt
    .local int rx104_pos
    .local int rx104_off
    .local int rx104_eos
    .local int rx104_rep
    .local pmc rx104_cur
    .local pmc rx104_debug
    (rx104_cur, rx104_pos, rx104_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx104_cur
    .local pmc match
    .lex "$/", match
    length rx104_eos, rx104_tgt
    gt rx104_pos, rx104_eos, rx104_done
    set rx104_off, 0
    lt rx104_pos, 2, rx104_start
    sub rx104_off, rx104_pos, 1
    substr rx104_tgt, rx104_tgt, rx104_off
  rx104_start:
    eq $I10, 1, rx104_restart
    if_null rx104_debug, debug_614
    rx104_cur."!cursor_debug"("START", "identifier")
  debug_614:
    $I10 = self.'from'()
    ne $I10, -1, rxscan108_done
    goto rxscan108_scan
  rxscan108_loop:
    (rx104_pos) = rx104_cur."from"()
    inc rx104_pos
    rx104_cur."!cursor_from"(rx104_pos)
    ge rx104_pos, rx104_eos, rxscan108_done
  rxscan108_scan:
    set_addr $I10, rxscan108_loop
    rx104_cur."!mark_push"(0, rx104_pos, $I10)
  rxscan108_done:
.annotate 'line', 49
  # rx subrule "ident" subtype=method negate=
    rx104_cur."!cursor_pos"(rx104_pos)
    $P10 = rx104_cur."ident"()
    unless $P10, rx104_fail
    rx104_pos = $P10."pos"()
  # rx rxquantr109 ** 0..*
    set_addr $I10, rxquantr109_done
    rx104_cur."!mark_push"(0, rx104_pos, $I10)
  rxquantr109_loop:
  # rx enumcharlist negate=0 
    ge rx104_pos, rx104_eos, rx104_fail
    sub $I10, rx104_pos, rx104_off
    substr $S10, rx104_tgt, $I10, 1
    index $I11, "-'", $S10
    lt $I11, 0, rx104_fail
    inc rx104_pos
  # rx subrule "ident" subtype=method negate=
    rx104_cur."!cursor_pos"(rx104_pos)
    $P10 = rx104_cur."ident"()
    unless $P10, rx104_fail
    rx104_pos = $P10."pos"()
    set_addr $I10, rxquantr109_done
    (rx104_rep) = rx104_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr109_done
    rx104_cur."!mark_push"(rx104_rep, rx104_pos, $I10)
    goto rxquantr109_loop
  rxquantr109_done:
  # rx pass
    rx104_cur."!cursor_pass"(rx104_pos, "identifier")
    if_null rx104_debug, debug_615
    rx104_cur."!cursor_debug"("PASS", "identifier", " at pos=", rx104_pos)
  debug_615:
    .return (rx104_cur)
  rx104_restart:
.annotate 'line', 10
    if_null rx104_debug, debug_616
    rx104_cur."!cursor_debug"("NEXT", "identifier")
  debug_616:
  rx104_fail:
    (rx104_rep, rx104_pos, $I10, $P10) = rx104_cur."!mark_fail"(0)
    lt rx104_pos, -1, rx104_done
    eq rx104_pos, -1, rx104_fail
    jump $I10
  rx104_done:
    rx104_cur."!cursor_fail"()
    if_null rx104_debug, debug_617
    rx104_cur."!cursor_debug"("FAIL", "identifier")
  debug_617:
    .return (rx104_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__identifier"  :nsentry("!PREFIX__identifier") :subid("15_1303401201.841") :method
.annotate 'line', 10
    $P106 = self."!PREFIX__!subrule"("ident", "")
    new $P107, "ResizablePMCArray"
    push $P107, $P106
    .return ($P107)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "name"  :subid("16_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx111_tgt
    .local int rx111_pos
    .local int rx111_off
    .local int rx111_eos
    .local int rx111_rep
    .local pmc rx111_cur
    .local pmc rx111_debug
    (rx111_cur, rx111_pos, rx111_tgt, $I10) = self."!cursor_start"()
    rx111_cur."!cursor_caparray"("identifier")
    .lex unicode:"$\x{a2}", rx111_cur
    .local pmc match
    .lex "$/", match
    length rx111_eos, rx111_tgt
    gt rx111_pos, rx111_eos, rx111_done
    set rx111_off, 0
    lt rx111_pos, 2, rx111_start
    sub rx111_off, rx111_pos, 1
    substr rx111_tgt, rx111_tgt, rx111_off
  rx111_start:
    eq $I10, 1, rx111_restart
    if_null rx111_debug, debug_618
    rx111_cur."!cursor_debug"("START", "name")
  debug_618:
    $I10 = self.'from'()
    ne $I10, -1, rxscan114_done
    goto rxscan114_scan
  rxscan114_loop:
    (rx111_pos) = rx111_cur."from"()
    inc rx111_pos
    rx111_cur."!cursor_from"(rx111_pos)
    ge rx111_pos, rx111_eos, rxscan114_done
  rxscan114_scan:
    set_addr $I10, rxscan114_loop
    rx111_cur."!mark_push"(0, rx111_pos, $I10)
  rxscan114_done:
.annotate 'line', 51
  # rx rxquantr115 ** 1..*
    set_addr $I10, rxquantr115_done
    rx111_cur."!mark_push"(0, -1, $I10)
  rxquantr115_loop:
  # rx subrule "identifier" subtype=capture negate=
    rx111_cur."!cursor_pos"(rx111_pos)
    $P10 = rx111_cur."identifier"()
    unless $P10, rx111_fail
    goto rxsubrule116_pass
  rxsubrule116_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx111_fail
  rxsubrule116_pass:
    set_addr $I10, rxsubrule116_back
    rx111_cur."!mark_push"(0, rx111_pos, $I10, $P10)
    $P10."!cursor_names"("identifier")
    rx111_pos = $P10."pos"()
    set_addr $I10, rxquantr115_done
    (rx111_rep) = rx111_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr115_done
    rx111_cur."!mark_push"(rx111_rep, rx111_pos, $I10)
  # rx literal  "::"
    add $I11, rx111_pos, 2
    gt $I11, rx111_eos, rx111_fail
    sub $I11, rx111_pos, rx111_off
    substr $S10, rx111_tgt, $I11, 2
    ne $S10, "::", rx111_fail
    add rx111_pos, 2
    goto rxquantr115_loop
  rxquantr115_done:
  # rx pass
    rx111_cur."!cursor_pass"(rx111_pos, "name")
    if_null rx111_debug, debug_619
    rx111_cur."!cursor_debug"("PASS", "name", " at pos=", rx111_pos)
  debug_619:
    .return (rx111_cur)
  rx111_restart:
.annotate 'line', 10
    if_null rx111_debug, debug_620
    rx111_cur."!cursor_debug"("NEXT", "name")
  debug_620:
  rx111_fail:
    (rx111_rep, rx111_pos, $I10, $P10) = rx111_cur."!mark_fail"(0)
    lt rx111_pos, -1, rx111_done
    eq rx111_pos, -1, rx111_fail
    jump $I10
  rx111_done:
    rx111_cur."!cursor_fail"()
    if_null rx111_debug, debug_621
    rx111_cur."!cursor_debug"("FAIL", "name")
  debug_621:
    .return (rx111_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__name"  :nsentry("!PREFIX__name") :subid("17_1303401201.841") :method
.annotate 'line', 10
    new $P113, "ResizablePMCArray"
    push $P113, ""
    .return ($P113)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "deflongname"  :subid("18_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx118_tgt
    .local int rx118_pos
    .local int rx118_off
    .local int rx118_eos
    .local int rx118_rep
    .local pmc rx118_cur
    .local pmc rx118_debug
    (rx118_cur, rx118_pos, rx118_tgt, $I10) = self."!cursor_start"()
    rx118_cur."!cursor_caparray"("colonpair")
    .lex unicode:"$\x{a2}", rx118_cur
    .local pmc match
    .lex "$/", match
    length rx118_eos, rx118_tgt
    gt rx118_pos, rx118_eos, rx118_done
    set rx118_off, 0
    lt rx118_pos, 2, rx118_start
    sub rx118_off, rx118_pos, 1
    substr rx118_tgt, rx118_tgt, rx118_off
  rx118_start:
    eq $I10, 1, rx118_restart
    if_null rx118_debug, debug_622
    rx118_cur."!cursor_debug"("START", "deflongname")
  debug_622:
    $I10 = self.'from'()
    ne $I10, -1, rxscan122_done
    goto rxscan122_scan
  rxscan122_loop:
    (rx118_pos) = rx118_cur."from"()
    inc rx118_pos
    rx118_cur."!cursor_from"(rx118_pos)
    ge rx118_pos, rx118_eos, rxscan122_done
  rxscan122_scan:
    set_addr $I10, rxscan122_loop
    rx118_cur."!mark_push"(0, rx118_pos, $I10)
  rxscan122_done:
.annotate 'line', 54
  # rx subrule "identifier" subtype=capture negate=
    rx118_cur."!cursor_pos"(rx118_pos)
    $P10 = rx118_cur."identifier"()
    unless $P10, rx118_fail
    rx118_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx118_pos = $P10."pos"()
  # rx rxquantr123 ** 0..1
    set_addr $I10, rxquantr123_done
    rx118_cur."!mark_push"(0, rx118_pos, $I10)
  rxquantr123_loop:
  # rx subrule "colonpair" subtype=capture negate=
    rx118_cur."!cursor_pos"(rx118_pos)
    $P10 = rx118_cur."colonpair"()
    unless $P10, rx118_fail
    goto rxsubrule124_pass
  rxsubrule124_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx118_fail
  rxsubrule124_pass:
    set_addr $I10, rxsubrule124_back
    rx118_cur."!mark_push"(0, rx118_pos, $I10, $P10)
    $P10."!cursor_names"("colonpair")
    rx118_pos = $P10."pos"()
    set_addr $I10, rxquantr123_done
    (rx118_rep) = rx118_cur."!mark_commit"($I10)
  rxquantr123_done:
.annotate 'line', 53
  # rx pass
    rx118_cur."!cursor_pass"(rx118_pos, "deflongname")
    if_null rx118_debug, debug_623
    rx118_cur."!cursor_debug"("PASS", "deflongname", " at pos=", rx118_pos)
  debug_623:
    .return (rx118_cur)
  rx118_restart:
.annotate 'line', 10
    if_null rx118_debug, debug_624
    rx118_cur."!cursor_debug"("NEXT", "deflongname")
  debug_624:
  rx118_fail:
    (rx118_rep, rx118_pos, $I10, $P10) = rx118_cur."!mark_fail"(0)
    lt rx118_pos, -1, rx118_done
    eq rx118_pos, -1, rx118_fail
    jump $I10
  rx118_done:
    rx118_cur."!cursor_fail"()
    if_null rx118_debug, debug_625
    rx118_cur."!cursor_debug"("FAIL", "deflongname")
  debug_625:
    .return (rx118_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__deflongname"  :nsentry("!PREFIX__deflongname") :subid("19_1303401201.841") :method
.annotate 'line', 10
    $P120 = self."!PREFIX__!subrule"("identifier", "")
    new $P121, "ResizablePMCArray"
    push $P121, $P120
    .return ($P121)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ENDSTMT"  :subid("20_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx126_tgt
    .local int rx126_pos
    .local int rx126_off
    .local int rx126_eos
    .local int rx126_rep
    .local pmc rx126_cur
    .local pmc rx126_debug
    (rx126_cur, rx126_pos, rx126_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx126_cur
    .local pmc match
    .lex "$/", match
    length rx126_eos, rx126_tgt
    gt rx126_pos, rx126_eos, rx126_done
    set rx126_off, 0
    lt rx126_pos, 2, rx126_start
    sub rx126_off, rx126_pos, 1
    substr rx126_tgt, rx126_tgt, rx126_off
  rx126_start:
    eq $I10, 1, rx126_restart
    if_null rx126_debug, debug_626
    rx126_cur."!cursor_debug"("START", "ENDSTMT")
  debug_626:
    $I10 = self.'from'()
    ne $I10, -1, rxscan129_done
    goto rxscan129_scan
  rxscan129_loop:
    (rx126_pos) = rx126_cur."from"()
    inc rx126_pos
    rx126_cur."!cursor_from"(rx126_pos)
    ge rx126_pos, rx126_eos, rxscan129_done
  rxscan129_scan:
    set_addr $I10, rxscan129_loop
    rx126_cur."!mark_push"(0, rx126_pos, $I10)
  rxscan129_done:
.annotate 'line', 61
  # rx rxquantr130 ** 0..1
    set_addr $I10, rxquantr130_done
    rx126_cur."!mark_push"(0, rx126_pos, $I10)
  rxquantr130_loop:
  alt131_0:
.annotate 'line', 58
    set_addr $I10, alt131_1
    rx126_cur."!mark_push"(0, rx126_pos, $I10)
.annotate 'line', 59
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx126_pos, rx126_off
    set rx126_rep, 0
    sub $I12, rx126_eos, rx126_pos
  rxenumcharlistq132_loop:
    le $I12, 0, rxenumcharlistq132_done
    substr $S10, rx126_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq132_done
    inc rx126_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq132_loop
  rxenumcharlistq132_done:
    add rx126_pos, rx126_pos, rx126_rep
  # rxanchor eol
    sub $I10, rx126_pos, rx126_off
    is_cclass $I11, 4096, rx126_tgt, $I10
    if $I11, rxanchor133_done
    ne rx126_pos, rx126_eos, rx126_fail
    eq rx126_pos, 0, rxanchor133_done
    dec $I10
    is_cclass $I11, 4096, rx126_tgt, $I10
    if $I11, rx126_fail
  rxanchor133_done:
  # rx subrule "ws" subtype=method negate=
    rx126_cur."!cursor_pos"(rx126_pos)
    $P10 = rx126_cur."ws"()
    unless $P10, rx126_fail
    rx126_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx126_cur."!cursor_pos"(rx126_pos)
    $P10 = rx126_cur."MARKER"("endstmt")
    unless $P10, rx126_fail
    goto alt131_end
  alt131_1:
.annotate 'line', 60
  # rx rxquantr134 ** 0..1
    set_addr $I10, rxquantr134_done
    rx126_cur."!mark_push"(0, rx126_pos, $I10)
  rxquantr134_loop:
  # rx subrule "unv" subtype=method negate=
    rx126_cur."!cursor_pos"(rx126_pos)
    $P10 = rx126_cur."unv"()
    unless $P10, rx126_fail
    goto rxsubrule135_pass
  rxsubrule135_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx126_fail
  rxsubrule135_pass:
    set_addr $I10, rxsubrule135_back
    rx126_cur."!mark_push"(0, rx126_pos, $I10, $P10)
    rx126_pos = $P10."pos"()
    set_addr $I10, rxquantr134_done
    (rx126_rep) = rx126_cur."!mark_commit"($I10)
  rxquantr134_done:
  # rxanchor eol
    sub $I10, rx126_pos, rx126_off
    is_cclass $I11, 4096, rx126_tgt, $I10
    if $I11, rxanchor136_done
    ne rx126_pos, rx126_eos, rx126_fail
    eq rx126_pos, 0, rxanchor136_done
    dec $I10
    is_cclass $I11, 4096, rx126_tgt, $I10
    if $I11, rx126_fail
  rxanchor136_done:
  # rx subrule "ws" subtype=method negate=
    rx126_cur."!cursor_pos"(rx126_pos)
    $P10 = rx126_cur."ws"()
    unless $P10, rx126_fail
    rx126_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx126_cur."!cursor_pos"(rx126_pos)
    $P10 = rx126_cur."MARKER"("endstmt")
    unless $P10, rx126_fail
  alt131_end:
.annotate 'line', 61
    set_addr $I10, rxquantr130_done
    (rx126_rep) = rx126_cur."!mark_commit"($I10)
  rxquantr130_done:
.annotate 'line', 57
  # rx pass
    rx126_cur."!cursor_pass"(rx126_pos, "ENDSTMT")
    if_null rx126_debug, debug_627
    rx126_cur."!cursor_debug"("PASS", "ENDSTMT", " at pos=", rx126_pos)
  debug_627:
    .return (rx126_cur)
  rx126_restart:
.annotate 'line', 10
    if_null rx126_debug, debug_628
    rx126_cur."!cursor_debug"("NEXT", "ENDSTMT")
  debug_628:
  rx126_fail:
    (rx126_rep, rx126_pos, $I10, $P10) = rx126_cur."!mark_fail"(0)
    lt rx126_pos, -1, rx126_done
    eq rx126_pos, -1, rx126_fail
    jump $I10
  rx126_done:
    rx126_cur."!cursor_fail"()
    if_null rx126_debug, debug_629
    rx126_cur."!cursor_debug"("FAIL", "ENDSTMT")
  debug_629:
    .return (rx126_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ENDSTMT"  :nsentry("!PREFIX__ENDSTMT") :subid("21_1303401201.841") :method
.annotate 'line', 10
    new $P128, "ResizablePMCArray"
    push $P128, ""
    .return ($P128)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ws"  :subid("22_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx138_tgt
    .local int rx138_pos
    .local int rx138_off
    .local int rx138_eos
    .local int rx138_rep
    .local pmc rx138_cur
    .local pmc rx138_debug
    (rx138_cur, rx138_pos, rx138_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx138_cur
    .local pmc match
    .lex "$/", match
    length rx138_eos, rx138_tgt
    gt rx138_pos, rx138_eos, rx138_done
    set rx138_off, 0
    lt rx138_pos, 2, rx138_start
    sub rx138_off, rx138_pos, 1
    substr rx138_tgt, rx138_tgt, rx138_off
  rx138_start:
    eq $I10, 1, rx138_restart
    if_null rx138_debug, debug_630
    rx138_cur."!cursor_debug"("START", "ws")
  debug_630:
    $I10 = self.'from'()
    ne $I10, -1, rxscan141_done
    goto rxscan141_scan
  rxscan141_loop:
    (rx138_pos) = rx138_cur."from"()
    inc rx138_pos
    rx138_cur."!cursor_from"(rx138_pos)
    ge rx138_pos, rx138_eos, rxscan141_done
  rxscan141_scan:
    set_addr $I10, rxscan141_loop
    rx138_cur."!mark_push"(0, rx138_pos, $I10)
  rxscan141_done:
  alt142_0:
.annotate 'line', 64
    set_addr $I10, alt142_1
    rx138_cur."!mark_push"(0, rx138_pos, $I10)
.annotate 'line', 65
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx138_cur."!cursor_pos"(rx138_pos)
    $P10 = rx138_cur."MARKED"("ws")
    unless $P10, rx138_fail
    goto alt142_end
  alt142_1:
.annotate 'line', 66
  # rx subrule "ww" subtype=zerowidth negate=1
    rx138_cur."!cursor_pos"(rx138_pos)
    $P10 = rx138_cur."ww"()
    if $P10, rx138_fail
.annotate 'line', 71
  # rx rxquantr143 ** 0..*
    set_addr $I10, rxquantr143_done
    rx138_cur."!mark_push"(0, rx138_pos, $I10)
  rxquantr143_loop:
  alt144_0:
.annotate 'line', 67
    set_addr $I10, alt144_1
    rx138_cur."!mark_push"(0, rx138_pos, $I10)
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx138_pos, rx138_off
    set rx138_rep, 0
    sub $I12, rx138_eos, rx138_pos
  rxenumcharlistq145_loop:
    le $I12, 0, rxenumcharlistq145_done
    substr $S10, rx138_tgt, $I10, 1
    index $I11, unicode:"\n\x{b}\f\r\x{85}\u2028\u2029", $S10
    lt $I11, 0, rxenumcharlistq145_done
    inc rx138_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq145_loop
  rxenumcharlistq145_done:
    lt rx138_rep, 1, rx138_fail
    add rx138_pos, rx138_pos, rx138_rep
    goto alt144_end
  alt144_1:
    set_addr $I10, alt144_2
    rx138_cur."!mark_push"(0, rx138_pos, $I10)
.annotate 'line', 68
  # rx literal  "#"
    add $I11, rx138_pos, 1
    gt $I11, rx138_eos, rx138_fail
    sub $I11, rx138_pos, rx138_off
    ord $I11, rx138_tgt, $I11
    ne $I11, 35, rx138_fail
    add rx138_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx138_pos, rx138_off
    find_cclass $I11, 4096, rx138_tgt, $I10, rx138_eos
    add rx138_pos, rx138_off, $I11
    goto alt144_end
  alt144_2:
    set_addr $I10, alt144_3
    rx138_cur."!mark_push"(0, rx138_pos, $I10)
.annotate 'line', 69
  # rxanchor bol
    eq rx138_pos, 0, rxanchor146_done
    ge rx138_pos, rx138_eos, rx138_fail
    sub $I10, rx138_pos, rx138_off
    dec $I10
    is_cclass $I11, 4096, rx138_tgt, $I10
    unless $I11, rx138_fail
  rxanchor146_done:
  # rx subrule "pod_comment" subtype=method negate=
    rx138_cur."!cursor_pos"(rx138_pos)
    $P10 = rx138_cur."pod_comment"()
    unless $P10, rx138_fail
    rx138_pos = $P10."pos"()
    goto alt144_end
  alt144_3:
.annotate 'line', 70
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx138_pos, rx138_off
    set rx138_rep, 0
    sub $I12, rx138_eos, rx138_pos
  rxenumcharlistq147_loop:
    le $I12, 0, rxenumcharlistq147_done
    substr $S10, rx138_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq147_done
    inc rx138_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq147_loop
  rxenumcharlistq147_done:
    lt rx138_rep, 1, rx138_fail
    add rx138_pos, rx138_pos, rx138_rep
  alt144_end:
.annotate 'line', 71
    set_addr $I10, rxquantr143_done
    (rx138_rep) = rx138_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr143_done
    rx138_cur."!mark_push"(rx138_rep, rx138_pos, $I10)
    goto rxquantr143_loop
  rxquantr143_done:
.annotate 'line', 72
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx138_cur."!cursor_pos"(rx138_pos)
    $P10 = rx138_cur."MARKER"("ws")
    unless $P10, rx138_fail
  alt142_end:
.annotate 'line', 64
  # rx pass
    rx138_cur."!cursor_pass"(rx138_pos, "ws")
    if_null rx138_debug, debug_631
    rx138_cur."!cursor_debug"("PASS", "ws", " at pos=", rx138_pos)
  debug_631:
    .return (rx138_cur)
  rx138_restart:
.annotate 'line', 10
    if_null rx138_debug, debug_632
    rx138_cur."!cursor_debug"("NEXT", "ws")
  debug_632:
  rx138_fail:
    (rx138_rep, rx138_pos, $I10, $P10) = rx138_cur."!mark_fail"(0)
    lt rx138_pos, -1, rx138_done
    eq rx138_pos, -1, rx138_fail
    jump $I10
  rx138_done:
    rx138_cur."!cursor_fail"()
    if_null rx138_debug, debug_633
    rx138_cur."!cursor_debug"("FAIL", "ws")
  debug_633:
    .return (rx138_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ws"  :nsentry("!PREFIX__ws") :subid("23_1303401201.841") :method
.annotate 'line', 10
    new $P140, "ResizablePMCArray"
    push $P140, ""
    push $P140, ""
    .return ($P140)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "unv"  :subid("24_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .const 'Sub' $P156 = "26_1303401201.841" 
    capture_lex $P156
    .local string rx149_tgt
    .local int rx149_pos
    .local int rx149_off
    .local int rx149_eos
    .local int rx149_rep
    .local pmc rx149_cur
    .local pmc rx149_debug
    (rx149_cur, rx149_pos, rx149_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx149_cur
    .local pmc match
    .lex "$/", match
    length rx149_eos, rx149_tgt
    gt rx149_pos, rx149_eos, rx149_done
    set rx149_off, 0
    lt rx149_pos, 2, rx149_start
    sub rx149_off, rx149_pos, 1
    substr rx149_tgt, rx149_tgt, rx149_off
  rx149_start:
    eq $I10, 1, rx149_restart
    if_null rx149_debug, debug_634
    rx149_cur."!cursor_debug"("START", "unv")
  debug_634:
    $I10 = self.'from'()
    ne $I10, -1, rxscan152_done
    goto rxscan152_scan
  rxscan152_loop:
    (rx149_pos) = rx149_cur."from"()
    inc rx149_pos
    rx149_cur."!cursor_from"(rx149_pos)
    ge rx149_pos, rx149_eos, rxscan152_done
  rxscan152_scan:
    set_addr $I10, rxscan152_loop
    rx149_cur."!mark_push"(0, rx149_pos, $I10)
  rxscan152_done:
  alt153_0:
.annotate 'line', 77
    set_addr $I10, alt153_1
    rx149_cur."!mark_push"(0, rx149_pos, $I10)
.annotate 'line', 78
  # rxanchor bol
    eq rx149_pos, 0, rxanchor154_done
    ge rx149_pos, rx149_eos, rx149_fail
    sub $I10, rx149_pos, rx149_off
    dec $I10
    is_cclass $I11, 4096, rx149_tgt, $I10
    unless $I11, rx149_fail
  rxanchor154_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx149_cur."!cursor_pos"(rx149_pos)
    .const 'Sub' $P156 = "26_1303401201.841" 
    capture_lex $P156
    $P10 = rx149_cur."before"($P156)
    unless $P10, rx149_fail
  # rx subrule "pod_comment" subtype=method negate=
    rx149_cur."!cursor_pos"(rx149_pos)
    $P10 = rx149_cur."pod_comment"()
    unless $P10, rx149_fail
    rx149_pos = $P10."pos"()
    goto alt153_end
  alt153_1:
    set_addr $I10, alt153_2
    rx149_cur."!mark_push"(0, rx149_pos, $I10)
.annotate 'line', 79
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx149_pos, rx149_off
    set rx149_rep, 0
    sub $I12, rx149_eos, rx149_pos
  rxenumcharlistq161_loop:
    le $I12, 0, rxenumcharlistq161_done
    substr $S10, rx149_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq161_done
    inc rx149_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq161_loop
  rxenumcharlistq161_done:
    add rx149_pos, rx149_pos, rx149_rep
  # rx literal  "#"
    add $I11, rx149_pos, 1
    gt $I11, rx149_eos, rx149_fail
    sub $I11, rx149_pos, rx149_off
    ord $I11, rx149_tgt, $I11
    ne $I11, 35, rx149_fail
    add rx149_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx149_pos, rx149_off
    find_cclass $I11, 4096, rx149_tgt, $I10, rx149_eos
    add rx149_pos, rx149_off, $I11
    goto alt153_end
  alt153_2:
.annotate 'line', 80
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx149_pos, rx149_off
    set rx149_rep, 0
    sub $I12, rx149_eos, rx149_pos
  rxenumcharlistq162_loop:
    le $I12, 0, rxenumcharlistq162_done
    substr $S10, rx149_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq162_done
    inc rx149_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq162_loop
  rxenumcharlistq162_done:
    lt rx149_rep, 1, rx149_fail
    add rx149_pos, rx149_pos, rx149_rep
  alt153_end:
.annotate 'line', 75
  # rx pass
    rx149_cur."!cursor_pass"(rx149_pos, "unv")
    if_null rx149_debug, debug_639
    rx149_cur."!cursor_debug"("PASS", "unv", " at pos=", rx149_pos)
  debug_639:
    .return (rx149_cur)
  rx149_restart:
.annotate 'line', 10
    if_null rx149_debug, debug_640
    rx149_cur."!cursor_debug"("NEXT", "unv")
  debug_640:
  rx149_fail:
    (rx149_rep, rx149_pos, $I10, $P10) = rx149_cur."!mark_fail"(0)
    lt rx149_pos, -1, rx149_done
    eq rx149_pos, -1, rx149_fail
    jump $I10
  rx149_done:
    rx149_cur."!cursor_fail"()
    if_null rx149_debug, debug_641
    rx149_cur."!cursor_debug"("FAIL", "unv")
  debug_641:
    .return (rx149_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__unv"  :nsentry("!PREFIX__unv") :subid("25_1303401201.841") :method
.annotate 'line', 10
    new $P151, "ResizablePMCArray"
    push $P151, ""
    push $P151, ""
    push $P151, ""
    .return ($P151)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block155"  :anon :subid("26_1303401201.841") :method :outer("24_1303401201.841")
.annotate 'line', 78
    .local string rx157_tgt
    .local int rx157_pos
    .local int rx157_off
    .local int rx157_eos
    .local int rx157_rep
    .local pmc rx157_cur
    .local pmc rx157_debug
    (rx157_cur, rx157_pos, rx157_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx157_cur
    .local pmc match
    .lex "$/", match
    length rx157_eos, rx157_tgt
    gt rx157_pos, rx157_eos, rx157_done
    set rx157_off, 0
    lt rx157_pos, 2, rx157_start
    sub rx157_off, rx157_pos, 1
    substr rx157_tgt, rx157_tgt, rx157_off
  rx157_start:
    eq $I10, 1, rx157_restart
    if_null rx157_debug, debug_635
    rx157_cur."!cursor_debug"("START", "")
  debug_635:
    $I10 = self.'from'()
    ne $I10, -1, rxscan158_done
    goto rxscan158_scan
  rxscan158_loop:
    (rx157_pos) = rx157_cur."from"()
    inc rx157_pos
    rx157_cur."!cursor_from"(rx157_pos)
    ge rx157_pos, rx157_eos, rxscan158_done
  rxscan158_scan:
    set_addr $I10, rxscan158_loop
    rx157_cur."!mark_push"(0, rx157_pos, $I10)
  rxscan158_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx157_pos, rx157_off
    set rx157_rep, 0
    sub $I12, rx157_eos, rx157_pos
  rxenumcharlistq159_loop:
    le $I12, 0, rxenumcharlistq159_done
    substr $S10, rx157_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq159_done
    inc rx157_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq159_loop
  rxenumcharlistq159_done:
    add rx157_pos, rx157_pos, rx157_rep
  # rx literal  "="
    add $I11, rx157_pos, 1
    gt $I11, rx157_eos, rx157_fail
    sub $I11, rx157_pos, rx157_off
    ord $I11, rx157_tgt, $I11
    ne $I11, 61, rx157_fail
    add rx157_pos, 1
  alt160_0:
    set_addr $I10, alt160_1
    rx157_cur."!mark_push"(0, rx157_pos, $I10)
  # rx charclass w
    ge rx157_pos, rx157_eos, rx157_fail
    sub $I10, rx157_pos, rx157_off
    is_cclass $I11, 8192, rx157_tgt, $I10
    unless $I11, rx157_fail
    inc rx157_pos
    goto alt160_end
  alt160_1:
  # rx literal  "\\"
    add $I11, rx157_pos, 1
    gt $I11, rx157_eos, rx157_fail
    sub $I11, rx157_pos, rx157_off
    ord $I11, rx157_tgt, $I11
    ne $I11, 92, rx157_fail
    add rx157_pos, 1
  alt160_end:
  # rx pass
    rx157_cur."!cursor_pass"(rx157_pos, "")
    if_null rx157_debug, debug_636
    rx157_cur."!cursor_debug"("PASS", "", " at pos=", rx157_pos)
  debug_636:
    .return (rx157_cur)
  rx157_restart:
    if_null rx157_debug, debug_637
    rx157_cur."!cursor_debug"("NEXT", "")
  debug_637:
  rx157_fail:
    (rx157_rep, rx157_pos, $I10, $P10) = rx157_cur."!mark_fail"(0)
    lt rx157_pos, -1, rx157_done
    eq rx157_pos, -1, rx157_fail
    jump $I10
  rx157_done:
    rx157_cur."!cursor_fail"()
    if_null rx157_debug, debug_638
    rx157_cur."!cursor_debug"("FAIL", "")
  debug_638:
    .return (rx157_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pod_comment"  :subid("27_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .const 'Sub' $P195 = "29_1303401201.841" 
    capture_lex $P195
    .local string rx164_tgt
    .local int rx164_pos
    .local int rx164_off
    .local int rx164_eos
    .local int rx164_rep
    .local pmc rx164_cur
    .local pmc rx164_debug
    (rx164_cur, rx164_pos, rx164_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx164_cur
    .local pmc match
    .lex "$/", match
    length rx164_eos, rx164_tgt
    gt rx164_pos, rx164_eos, rx164_done
    set rx164_off, 0
    lt rx164_pos, 2, rx164_start
    sub rx164_off, rx164_pos, 1
    substr rx164_tgt, rx164_tgt, rx164_off
  rx164_start:
    eq $I10, 1, rx164_restart
    if_null rx164_debug, debug_642
    rx164_cur."!cursor_debug"("START", "pod_comment")
  debug_642:
    $I10 = self.'from'()
    ne $I10, -1, rxscan167_done
    goto rxscan167_scan
  rxscan167_loop:
    (rx164_pos) = rx164_cur."from"()
    inc rx164_pos
    rx164_cur."!cursor_from"(rx164_pos)
    ge rx164_pos, rx164_eos, rxscan167_done
  rxscan167_scan:
    set_addr $I10, rxscan167_loop
    rx164_cur."!mark_push"(0, rx164_pos, $I10)
  rxscan167_done:
.annotate 'line', 85
  # rxanchor bol
    eq rx164_pos, 0, rxanchor168_done
    ge rx164_pos, rx164_eos, rx164_fail
    sub $I10, rx164_pos, rx164_off
    dec $I10
    is_cclass $I11, 4096, rx164_tgt, $I10
    unless $I11, rx164_fail
  rxanchor168_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx164_pos, rx164_off
    set rx164_rep, 0
    sub $I12, rx164_eos, rx164_pos
  rxenumcharlistq169_loop:
    le $I12, 0, rxenumcharlistq169_done
    substr $S10, rx164_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq169_done
    inc rx164_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq169_loop
  rxenumcharlistq169_done:
    add rx164_pos, rx164_pos, rx164_rep
  # rx literal  "="
    add $I11, rx164_pos, 1
    gt $I11, rx164_eos, rx164_fail
    sub $I11, rx164_pos, rx164_off
    ord $I11, rx164_tgt, $I11
    ne $I11, 61, rx164_fail
    add rx164_pos, 1
  alt170_0:
.annotate 'line', 86
    set_addr $I10, alt170_1
    rx164_cur."!mark_push"(0, rx164_pos, $I10)
.annotate 'line', 87
  # rx literal  "begin"
    add $I11, rx164_pos, 5
    gt $I11, rx164_eos, rx164_fail
    sub $I11, rx164_pos, rx164_off
    substr $S10, rx164_tgt, $I11, 5
    ne $S10, "begin", rx164_fail
    add rx164_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx164_pos, rx164_off
    set rx164_rep, 0
    sub $I12, rx164_eos, rx164_pos
  rxenumcharlistq171_loop:
    le $I12, 0, rxenumcharlistq171_done
    substr $S10, rx164_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq171_done
    inc rx164_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq171_loop
  rxenumcharlistq171_done:
    lt rx164_rep, 1, rx164_fail
    add rx164_pos, rx164_pos, rx164_rep
  # rx literal  "END"
    add $I11, rx164_pos, 3
    gt $I11, rx164_eos, rx164_fail
    sub $I11, rx164_pos, rx164_off
    substr $S10, rx164_tgt, $I11, 3
    ne $S10, "END", rx164_fail
    add rx164_pos, 3
  # rxanchor rwb
    le rx164_pos, 0, rx164_fail
    sub $I10, rx164_pos, rx164_off
    is_cclass $I11, 8192, rx164_tgt, $I10
    if $I11, rx164_fail
    dec $I10
    is_cclass $I11, 8192, rx164_tgt, $I10
    unless $I11, rx164_fail
  alt172_0:
.annotate 'line', 88
    set_addr $I10, alt172_1
    rx164_cur."!mark_push"(0, rx164_pos, $I10)
  # rx rxquantf173 ** 0..*
    set_addr $I10, rxquantf173_loop
    rx164_cur."!mark_push"(0, rx164_pos, $I10)
    goto rxquantf173_done
  rxquantf173_loop:
  # rx charclass .
    ge rx164_pos, rx164_eos, rx164_fail
    inc rx164_pos
    set_addr $I10, rxquantf173_loop
    rx164_cur."!mark_push"(rx164_rep, rx164_pos, $I10)
  rxquantf173_done:
  # rx charclass nl
    ge rx164_pos, rx164_eos, rx164_fail
    sub $I10, rx164_pos, rx164_off
    is_cclass $I11, 4096, rx164_tgt, $I10
    unless $I11, rx164_fail
    substr $S10, rx164_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx164_pos, $I11
    inc rx164_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx164_pos, rx164_off
    set rx164_rep, 0
    sub $I12, rx164_eos, rx164_pos
  rxenumcharlistq175_loop:
    le $I12, 0, rxenumcharlistq175_done
    substr $S10, rx164_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq175_done
    inc rx164_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq175_loop
  rxenumcharlistq175_done:
    add rx164_pos, rx164_pos, rx164_rep
  # rx literal  "=end"
    add $I11, rx164_pos, 4
    gt $I11, rx164_eos, rx164_fail
    sub $I11, rx164_pos, rx164_off
    substr $S10, rx164_tgt, $I11, 4
    ne $S10, "=end", rx164_fail
    add rx164_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx164_pos, rx164_off
    set rx164_rep, 0
    sub $I12, rx164_eos, rx164_pos
  rxenumcharlistq176_loop:
    le $I12, 0, rxenumcharlistq176_done
    substr $S10, rx164_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq176_done
    inc rx164_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq176_loop
  rxenumcharlistq176_done:
    lt rx164_rep, 1, rx164_fail
    add rx164_pos, rx164_pos, rx164_rep
  # rx literal  "END"
    add $I11, rx164_pos, 3
    gt $I11, rx164_eos, rx164_fail
    sub $I11, rx164_pos, rx164_off
    substr $S10, rx164_tgt, $I11, 3
    ne $S10, "END", rx164_fail
    add rx164_pos, 3
  # rxanchor rwb
    le rx164_pos, 0, rx164_fail
    sub $I10, rx164_pos, rx164_off
    is_cclass $I11, 8192, rx164_tgt, $I10
    if $I11, rx164_fail
    dec $I10
    is_cclass $I11, 8192, rx164_tgt, $I10
    unless $I11, rx164_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx164_pos, rx164_off
    find_cclass $I11, 4096, rx164_tgt, $I10, rx164_eos
    add rx164_pos, rx164_off, $I11
    goto alt172_end
  alt172_1:
  # rx charclass_q . r 0..-1
    sub $I10, rx164_pos, rx164_off
    find_not_cclass $I11, 65535, rx164_tgt, $I10, rx164_eos
    add rx164_pos, rx164_off, $I11
  alt172_end:
.annotate 'line', 87
    goto alt170_end
  alt170_1:
    set_addr $I10, alt170_2
    rx164_cur."!mark_push"(0, rx164_pos, $I10)
.annotate 'line', 89
  # rx literal  "begin"
    add $I11, rx164_pos, 5
    gt $I11, rx164_eos, rx164_fail
    sub $I11, rx164_pos, rx164_off
    substr $S10, rx164_tgt, $I11, 5
    ne $S10, "begin", rx164_fail
    add rx164_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx164_pos, rx164_off
    set rx164_rep, 0
    sub $I12, rx164_eos, rx164_pos
  rxenumcharlistq177_loop:
    le $I12, 0, rxenumcharlistq177_done
    substr $S10, rx164_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq177_done
    inc rx164_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq177_loop
  rxenumcharlistq177_done:
    lt rx164_rep, 1, rx164_fail
    add rx164_pos, rx164_pos, rx164_rep
  # rx subrule "identifier" subtype=capture negate=
    rx164_cur."!cursor_pos"(rx164_pos)
    $P10 = rx164_cur."identifier"()
    unless $P10, rx164_fail
    rx164_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx164_pos = $P10."pos"()
  alt178_0:
.annotate 'line', 90
    set_addr $I10, alt178_1
    rx164_cur."!mark_push"(0, rx164_pos, $I10)
.annotate 'line', 91
  # rx rxquantf179 ** 0..*
    set_addr $I10, rxquantf179_loop
    rx164_cur."!mark_push"(0, rx164_pos, $I10)
    goto rxquantf179_done
  rxquantf179_loop:
  # rx charclass .
    ge rx164_pos, rx164_eos, rx164_fail
    inc rx164_pos
    set_addr $I10, rxquantf179_loop
    rx164_cur."!mark_push"(rx164_rep, rx164_pos, $I10)
  rxquantf179_done:
  # rx charclass nl
    ge rx164_pos, rx164_eos, rx164_fail
    sub $I10, rx164_pos, rx164_off
    is_cclass $I11, 4096, rx164_tgt, $I10
    unless $I11, rx164_fail
    substr $S10, rx164_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx164_pos, $I11
    inc rx164_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx164_pos, rx164_off
    set rx164_rep, 0
    sub $I12, rx164_eos, rx164_pos
  rxenumcharlistq181_loop:
    le $I12, 0, rxenumcharlistq181_done
    substr $S10, rx164_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq181_done
    inc rx164_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq181_loop
  rxenumcharlistq181_done:
    add rx164_pos, rx164_pos, rx164_rep
  # rx literal  "=end"
    add $I11, rx164_pos, 4
    gt $I11, rx164_eos, rx164_fail
    sub $I11, rx164_pos, rx164_off
    substr $S10, rx164_tgt, $I11, 4
    ne $S10, "=end", rx164_fail
    add rx164_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx164_pos, rx164_off
    set rx164_rep, 0
    sub $I12, rx164_eos, rx164_pos
  rxenumcharlistq182_loop:
    le $I12, 0, rxenumcharlistq182_done
    substr $S10, rx164_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq182_done
    inc rx164_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq182_loop
  rxenumcharlistq182_done:
    lt rx164_rep, 1, rx164_fail
    add rx164_pos, rx164_pos, rx164_rep
  # rx subrule "!BACKREF" subtype=method negate=
    rx164_cur."!cursor_pos"(rx164_pos)
    $P10 = rx164_cur."!BACKREF"("identifier")
    unless $P10, rx164_fail
    rx164_pos = $P10."pos"()
  # rxanchor rwb
    le rx164_pos, 0, rx164_fail
    sub $I10, rx164_pos, rx164_off
    is_cclass $I11, 8192, rx164_tgt, $I10
    if $I11, rx164_fail
    dec $I10
    is_cclass $I11, 8192, rx164_tgt, $I10
    unless $I11, rx164_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx164_pos, rx164_off
    find_cclass $I11, 4096, rx164_tgt, $I10, rx164_eos
    add rx164_pos, rx164_off, $I11
    goto alt178_end
  alt178_1:
.annotate 'line', 92
  # rx subrule "panic" subtype=method negate=
    rx164_cur."!cursor_pos"(rx164_pos)
    $P10 = rx164_cur."panic"("=begin without matching =end")
    unless $P10, rx164_fail
    rx164_pos = $P10."pos"()
  alt178_end:
.annotate 'line', 89
    goto alt170_end
  alt170_2:
    set_addr $I10, alt170_3
    rx164_cur."!mark_push"(0, rx164_pos, $I10)
.annotate 'line', 94
  # rx literal  "begin"
    add $I11, rx164_pos, 5
    gt $I11, rx164_eos, rx164_fail
    sub $I11, rx164_pos, rx164_off
    substr $S10, rx164_tgt, $I11, 5
    ne $S10, "begin", rx164_fail
    add rx164_pos, 5
  # rxanchor rwb
    le rx164_pos, 0, rx164_fail
    sub $I10, rx164_pos, rx164_off
    is_cclass $I11, 8192, rx164_tgt, $I10
    if $I11, rx164_fail
    dec $I10
    is_cclass $I11, 8192, rx164_tgt, $I10
    unless $I11, rx164_fail
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx164_pos, rx164_off
    set rx164_rep, 0
    sub $I12, rx164_eos, rx164_pos
  rxenumcharlistq184_loop:
    le $I12, 0, rxenumcharlistq184_done
    substr $S10, rx164_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq184_done
    inc rx164_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq184_loop
  rxenumcharlistq184_done:
    add rx164_pos, rx164_pos, rx164_rep
  alt185_0:
.annotate 'line', 95
    set_addr $I10, alt185_1
    rx164_cur."!mark_push"(0, rx164_pos, $I10)
  # rxanchor eol
    sub $I10, rx164_pos, rx164_off
    is_cclass $I11, 4096, rx164_tgt, $I10
    if $I11, rxanchor186_done
    ne rx164_pos, rx164_eos, rx164_fail
    eq rx164_pos, 0, rxanchor186_done
    dec $I10
    is_cclass $I11, 4096, rx164_tgt, $I10
    if $I11, rx164_fail
  rxanchor186_done:
    goto alt185_end
  alt185_1:
    set_addr $I10, alt185_2
    rx164_cur."!mark_push"(0, rx164_pos, $I10)
  # rx literal  "#"
    add $I11, rx164_pos, 1
    gt $I11, rx164_eos, rx164_fail
    sub $I11, rx164_pos, rx164_off
    ord $I11, rx164_tgt, $I11
    ne $I11, 35, rx164_fail
    add rx164_pos, 1
    goto alt185_end
  alt185_2:
  # rx subrule "panic" subtype=method negate=
    rx164_cur."!cursor_pos"(rx164_pos)
    $P10 = rx164_cur."panic"("Unrecognized token after =begin")
    unless $P10, rx164_fail
    rx164_pos = $P10."pos"()
  alt185_end:
  alt187_0:
.annotate 'line', 96
    set_addr $I10, alt187_1
    rx164_cur."!mark_push"(0, rx164_pos, $I10)
.annotate 'line', 97
  # rx rxquantf188 ** 0..*
    set_addr $I10, rxquantf188_loop
    rx164_cur."!mark_push"(0, rx164_pos, $I10)
    goto rxquantf188_done
  rxquantf188_loop:
  # rx charclass .
    ge rx164_pos, rx164_eos, rx164_fail
    inc rx164_pos
    set_addr $I10, rxquantf188_loop
    rx164_cur."!mark_push"(rx164_rep, rx164_pos, $I10)
  rxquantf188_done:
  # rx charclass nl
    ge rx164_pos, rx164_eos, rx164_fail
    sub $I10, rx164_pos, rx164_off
    is_cclass $I11, 4096, rx164_tgt, $I10
    unless $I11, rx164_fail
    substr $S10, rx164_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx164_pos, $I11
    inc rx164_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx164_pos, rx164_off
    set rx164_rep, 0
    sub $I12, rx164_eos, rx164_pos
  rxenumcharlistq190_loop:
    le $I12, 0, rxenumcharlistq190_done
    substr $S10, rx164_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq190_done
    inc rx164_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq190_loop
  rxenumcharlistq190_done:
    add rx164_pos, rx164_pos, rx164_rep
  # rx literal  "=end"
    add $I11, rx164_pos, 4
    gt $I11, rx164_eos, rx164_fail
    sub $I11, rx164_pos, rx164_off
    substr $S10, rx164_tgt, $I11, 4
    ne $S10, "=end", rx164_fail
    add rx164_pos, 4
  # rxanchor rwb
    le rx164_pos, 0, rx164_fail
    sub $I10, rx164_pos, rx164_off
    is_cclass $I11, 8192, rx164_tgt, $I10
    if $I11, rx164_fail
    dec $I10
    is_cclass $I11, 8192, rx164_tgt, $I10
    unless $I11, rx164_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx164_pos, rx164_off
    find_cclass $I11, 4096, rx164_tgt, $I10, rx164_eos
    add rx164_pos, rx164_off, $I11
    goto alt187_end
  alt187_1:
.annotate 'line', 98
  # rx subrule "panic" subtype=method negate=
    rx164_cur."!cursor_pos"(rx164_pos)
    $P10 = rx164_cur."panic"("=begin without matching =end")
    unless $P10, rx164_fail
    rx164_pos = $P10."pos"()
  alt187_end:
.annotate 'line', 94
    goto alt170_end
  alt170_3:
    set_addr $I10, alt170_4
    rx164_cur."!mark_push"(0, rx164_pos, $I10)
.annotate 'line', 100
  # rx subrule "identifier" subtype=capture negate=
    rx164_cur."!cursor_pos"(rx164_pos)
    $P10 = rx164_cur."identifier"()
    unless $P10, rx164_fail
    rx164_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx164_pos = $P10."pos"()
.annotate 'line', 101
  # rx rxquantf191 ** 0..*
    set_addr $I10, rxquantf191_loop
    rx164_cur."!mark_push"(0, rx164_pos, $I10)
    goto rxquantf191_done
  rxquantf191_loop:
  # rx charclass .
    ge rx164_pos, rx164_eos, rx164_fail
    inc rx164_pos
    set_addr $I10, rxquantf191_loop
    rx164_cur."!mark_push"(rx164_rep, rx164_pos, $I10)
  rxquantf191_done:
  # rxanchor bol
    eq rx164_pos, 0, rxanchor193_done
    ge rx164_pos, rx164_eos, rx164_fail
    sub $I10, rx164_pos, rx164_off
    dec $I10
    is_cclass $I11, 4096, rx164_tgt, $I10
    unless $I11, rx164_fail
  rxanchor193_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx164_cur."!cursor_pos"(rx164_pos)
    .const 'Sub' $P195 = "29_1303401201.841" 
    capture_lex $P195
    $P10 = rx164_cur."before"($P195)
    unless $P10, rx164_fail
.annotate 'line', 100
    goto alt170_end
  alt170_4:
  alt201_0:
.annotate 'line', 107
    set_addr $I10, alt201_1
    rx164_cur."!mark_push"(0, rx164_pos, $I10)
  # rx charclass s
    ge rx164_pos, rx164_eos, rx164_fail
    sub $I10, rx164_pos, rx164_off
    is_cclass $I11, 32, rx164_tgt, $I10
    unless $I11, rx164_fail
    inc rx164_pos
    goto alt201_end
  alt201_1:
  # rx subrule "panic" subtype=method negate=
    rx164_cur."!cursor_pos"(rx164_pos)
    $P10 = rx164_cur."panic"("Illegal pod directive")
    unless $P10, rx164_fail
    rx164_pos = $P10."pos"()
  alt201_end:
.annotate 'line', 108
  # rx charclass_q N r 0..-1
    sub $I10, rx164_pos, rx164_off
    find_cclass $I11, 4096, rx164_tgt, $I10, rx164_eos
    add rx164_pos, rx164_off, $I11
  alt170_end:
.annotate 'line', 84
  # rx pass
    rx164_cur."!cursor_pass"(rx164_pos, "pod_comment")
    if_null rx164_debug, debug_647
    rx164_cur."!cursor_debug"("PASS", "pod_comment", " at pos=", rx164_pos)
  debug_647:
    .return (rx164_cur)
  rx164_restart:
.annotate 'line', 10
    if_null rx164_debug, debug_648
    rx164_cur."!cursor_debug"("NEXT", "pod_comment")
  debug_648:
  rx164_fail:
    (rx164_rep, rx164_pos, $I10, $P10) = rx164_cur."!mark_fail"(0)
    lt rx164_pos, -1, rx164_done
    eq rx164_pos, -1, rx164_fail
    jump $I10
  rx164_done:
    rx164_cur."!cursor_fail"()
    if_null rx164_debug, debug_649
    rx164_cur."!cursor_debug"("FAIL", "pod_comment")
  debug_649:
    .return (rx164_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pod_comment"  :nsentry("!PREFIX__pod_comment") :subid("28_1303401201.841") :method
.annotate 'line', 10
    new $P166, "ResizablePMCArray"
    push $P166, ""
    .return ($P166)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block194"  :anon :subid("29_1303401201.841") :method :outer("27_1303401201.841")
.annotate 'line', 101
    .local string rx196_tgt
    .local int rx196_pos
    .local int rx196_off
    .local int rx196_eos
    .local int rx196_rep
    .local pmc rx196_cur
    .local pmc rx196_debug
    (rx196_cur, rx196_pos, rx196_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx196_cur
    .local pmc match
    .lex "$/", match
    length rx196_eos, rx196_tgt
    gt rx196_pos, rx196_eos, rx196_done
    set rx196_off, 0
    lt rx196_pos, 2, rx196_start
    sub rx196_off, rx196_pos, 1
    substr rx196_tgt, rx196_tgt, rx196_off
  rx196_start:
    eq $I10, 1, rx196_restart
    if_null rx196_debug, debug_643
    rx196_cur."!cursor_debug"("START", "")
  debug_643:
    $I10 = self.'from'()
    ne $I10, -1, rxscan197_done
    goto rxscan197_scan
  rxscan197_loop:
    (rx196_pos) = rx196_cur."from"()
    inc rx196_pos
    rx196_cur."!cursor_from"(rx196_pos)
    ge rx196_pos, rx196_eos, rxscan197_done
  rxscan197_scan:
    set_addr $I10, rxscan197_loop
    rx196_cur."!mark_push"(0, rx196_pos, $I10)
  rxscan197_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx196_pos, rx196_off
    set rx196_rep, 0
    sub $I12, rx196_eos, rx196_pos
  rxenumcharlistq198_loop:
    le $I12, 0, rxenumcharlistq198_done
    substr $S10, rx196_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq198_done
    inc rx196_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq198_loop
  rxenumcharlistq198_done:
    add rx196_pos, rx196_pos, rx196_rep
  alt199_0:
    set_addr $I10, alt199_1
    rx196_cur."!mark_push"(0, rx196_pos, $I10)
.annotate 'line', 102
  # rx literal  "="
    add $I11, rx196_pos, 1
    gt $I11, rx196_eos, rx196_fail
    sub $I11, rx196_pos, rx196_off
    ord $I11, rx196_tgt, $I11
    ne $I11, 61, rx196_fail
    add rx196_pos, 1
.annotate 'line', 104
  # rx rxquantr200 ** 0..1
    set_addr $I10, rxquantr200_done
    rx196_cur."!mark_push"(0, rx196_pos, $I10)
  rxquantr200_loop:
.annotate 'line', 103
  # rx literal  "cut"
    add $I11, rx196_pos, 3
    gt $I11, rx196_eos, rx196_fail
    sub $I11, rx196_pos, rx196_off
    substr $S10, rx196_tgt, $I11, 3
    ne $S10, "cut", rx196_fail
    add rx196_pos, 3
  # rxanchor rwb
    le rx196_pos, 0, rx196_fail
    sub $I10, rx196_pos, rx196_off
    is_cclass $I11, 8192, rx196_tgt, $I10
    if $I11, rx196_fail
    dec $I10
    is_cclass $I11, 8192, rx196_tgt, $I10
    unless $I11, rx196_fail
.annotate 'line', 104
  # rx subrule "panic" subtype=method negate=
    rx196_cur."!cursor_pos"(rx196_pos)
    $P10 = rx196_cur."panic"("Obsolete pod format, please use =begin/=end instead")
    unless $P10, rx196_fail
    rx196_pos = $P10."pos"()
    set_addr $I10, rxquantr200_done
    (rx196_rep) = rx196_cur."!mark_commit"($I10)
  rxquantr200_done:
.annotate 'line', 101
    goto alt199_end
  alt199_1:
.annotate 'line', 105
  # rx charclass nl
    ge rx196_pos, rx196_eos, rx196_fail
    sub $I10, rx196_pos, rx196_off
    is_cclass $I11, 4096, rx196_tgt, $I10
    unless $I11, rx196_fail
    substr $S10, rx196_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx196_pos, $I11
    inc rx196_pos
  alt199_end:
.annotate 'line', 101
  # rx pass
    rx196_cur."!cursor_pass"(rx196_pos, "")
    if_null rx196_debug, debug_644
    rx196_cur."!cursor_debug"("PASS", "", " at pos=", rx196_pos)
  debug_644:
    .return (rx196_cur)
  rx196_restart:
    if_null rx196_debug, debug_645
    rx196_cur."!cursor_debug"("NEXT", "")
  debug_645:
  rx196_fail:
    (rx196_rep, rx196_pos, $I10, $P10) = rx196_cur."!mark_fail"(0)
    lt rx196_pos, -1, rx196_done
    eq rx196_pos, -1, rx196_fail
    jump $I10
  rx196_done:
    rx196_cur."!cursor_fail"()
    if_null rx196_debug, debug_646
    rx196_cur."!cursor_debug"("FAIL", "")
  debug_646:
    .return (rx196_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "comp_unit"  :subid("30_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 116
    new $P203, "Undef"
    .lex "$*HAS_YOU_ARE_HERE", $P203
.annotate 'line', 117
    new $P204, "Undef"
    .lex "$*MAIN_SUB", $P204
.annotate 'line', 121
    new $P205, "Undef"
    .lex "$*PACKAGE", $P205
.annotate 'line', 122
    new $P206, "Undef"
    .lex "$*GLOBALish", $P206
.annotate 'line', 10
    .local string rx207_tgt
    .local int rx207_pos
    .local int rx207_off
    .local int rx207_eos
    .local int rx207_rep
    .local pmc rx207_cur
    .local pmc rx207_debug
    (rx207_cur, rx207_pos, rx207_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx207_cur
    .local pmc match
    .lex "$/", match
    length rx207_eos, rx207_tgt
    gt rx207_pos, rx207_eos, rx207_done
    set rx207_off, 0
    lt rx207_pos, 2, rx207_start
    sub rx207_off, rx207_pos, 1
    substr rx207_tgt, rx207_tgt, rx207_off
  rx207_start:
    eq $I10, 1, rx207_restart
    if_null rx207_debug, debug_650
    rx207_cur."!cursor_debug"("START", "comp_unit")
  debug_650:
    $I10 = self.'from'()
    ne $I10, -1, rxscan211_done
    goto rxscan211_scan
  rxscan211_loop:
    (rx207_pos) = rx207_cur."from"()
    inc rx207_pos
    rx207_cur."!cursor_from"(rx207_pos)
    ge rx207_pos, rx207_eos, rxscan211_done
  rxscan211_scan:
    set_addr $I10, rxscan211_loop
    rx207_cur."!mark_push"(0, rx207_pos, $I10)
  rxscan211_done:
.annotate 'line', 116
    rx207_cur."!cursor_pos"(rx207_pos)
    new $P212, "Integer"
    assign $P212, 0
    store_lex "$*HAS_YOU_ARE_HERE", $P212
.annotate 'line', 117
    rx207_cur."!cursor_pos"(rx207_pos)
    find_lex $P213, "$*MAIN_SUB"
    unless_null $P213, vivify_651
    get_hll_global $P213, "$MAIN_SUB"
    unless_null $P213, vivify_652
    die "Contextual $*MAIN_SUB not found"
  vivify_652:
  vivify_651:
.annotate 'line', 118
  # rx subrule "newpad" subtype=method negate=
    rx207_cur."!cursor_pos"(rx207_pos)
    $P10 = rx207_cur."newpad"()
    unless $P10, rx207_fail
    rx207_pos = $P10."pos"()
.annotate 'line', 119
  # rx subrule "outerctx" subtype=method negate=
    rx207_cur."!cursor_pos"(rx207_pos)
    $P10 = rx207_cur."outerctx"()
    unless $P10, rx207_fail
    rx207_pos = $P10."pos"()
.annotate 'line', 121
    rx207_cur."!cursor_pos"(rx207_pos)
    find_lex $P214, "$*PACKAGE"
    unless_null $P214, vivify_653
    get_hll_global $P214, "$PACKAGE"
    unless_null $P214, vivify_654
    die "Contextual $*PACKAGE not found"
  vivify_654:
  vivify_653:
.annotate 'line', 122
    rx207_cur."!cursor_pos"(rx207_pos)
    find_lex $P215, "$*GLOBALish"
    unless_null $P215, vivify_655
    get_hll_global $P215, "$GLOBALish"
    unless_null $P215, vivify_656
    die "Contextual $*GLOBALish not found"
  vivify_656:
  vivify_655:
.annotate 'line', 123
  # rx subrule "GLOBALish" subtype=method negate=
    rx207_cur."!cursor_pos"(rx207_pos)
    $P10 = rx207_cur."GLOBALish"()
    unless $P10, rx207_fail
    rx207_pos = $P10."pos"()
.annotate 'line', 125
  # rx subrule "statementlist" subtype=capture negate=
    rx207_cur."!cursor_pos"(rx207_pos)
    $P10 = rx207_cur."statementlist"()
    unless $P10, rx207_fail
    rx207_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx207_pos = $P10."pos"()
  alt216_0:
.annotate 'line', 126
    set_addr $I10, alt216_1
    rx207_cur."!mark_push"(0, rx207_pos, $I10)
  # rxanchor eos
    ne rx207_pos, rx207_eos, rx207_fail
    goto alt216_end
  alt216_1:
  # rx subrule "panic" subtype=method negate=
    rx207_cur."!cursor_pos"(rx207_pos)
    $P10 = rx207_cur."panic"("Confused")
    unless $P10, rx207_fail
    rx207_pos = $P10."pos"()
  alt216_end:
.annotate 'line', 115
  # rx pass
    rx207_cur."!cursor_pass"(rx207_pos, "comp_unit")
    if_null rx207_debug, debug_657
    rx207_cur."!cursor_debug"("PASS", "comp_unit", " at pos=", rx207_pos)
  debug_657:
    .return (rx207_cur)
  rx207_restart:
.annotate 'line', 10
    if_null rx207_debug, debug_658
    rx207_cur."!cursor_debug"("NEXT", "comp_unit")
  debug_658:
  rx207_fail:
    (rx207_rep, rx207_pos, $I10, $P10) = rx207_cur."!mark_fail"(0)
    lt rx207_pos, -1, rx207_done
    eq rx207_pos, -1, rx207_fail
    jump $I10
  rx207_done:
    rx207_cur."!cursor_fail"()
    if_null rx207_debug, debug_659
    rx207_cur."!cursor_debug"("FAIL", "comp_unit")
  debug_659:
    .return (rx207_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__comp_unit"  :nsentry("!PREFIX__comp_unit") :subid("31_1303401201.841") :method
.annotate 'line', 10
    $P209 = self."!PREFIX__!subrule"("newpad", "")
    new $P210, "ResizablePMCArray"
    push $P210, $P209
    .return ($P210)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statementlist"  :subid("32_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx218_tgt
    .local int rx218_pos
    .local int rx218_off
    .local int rx218_eos
    .local int rx218_rep
    .local pmc rx218_cur
    .local pmc rx218_debug
    (rx218_cur, rx218_pos, rx218_tgt, $I10) = self."!cursor_start"()
    rx218_cur."!cursor_caparray"("statement")
    .lex unicode:"$\x{a2}", rx218_cur
    .local pmc match
    .lex "$/", match
    length rx218_eos, rx218_tgt
    gt rx218_pos, rx218_eos, rx218_done
    set rx218_off, 0
    lt rx218_pos, 2, rx218_start
    sub rx218_off, rx218_pos, 1
    substr rx218_tgt, rx218_tgt, rx218_off
  rx218_start:
    eq $I10, 1, rx218_restart
    if_null rx218_debug, debug_660
    rx218_cur."!cursor_debug"("START", "statementlist")
  debug_660:
    $I10 = self.'from'()
    ne $I10, -1, rxscan223_done
    goto rxscan223_scan
  rxscan223_loop:
    (rx218_pos) = rx218_cur."from"()
    inc rx218_pos
    rx218_cur."!cursor_from"(rx218_pos)
    ge rx218_pos, rx218_eos, rxscan223_done
  rxscan223_scan:
    set_addr $I10, rxscan223_loop
    rx218_cur."!mark_push"(0, rx218_pos, $I10)
  rxscan223_done:
  alt224_0:
.annotate 'line', 129
    set_addr $I10, alt224_1
    rx218_cur."!mark_push"(0, rx218_pos, $I10)
.annotate 'line', 130
  # rx subrule "ws" subtype=method negate=
    rx218_cur."!cursor_pos"(rx218_pos)
    $P10 = rx218_cur."ws"()
    unless $P10, rx218_fail
    rx218_pos = $P10."pos"()
  # rxanchor eos
    ne rx218_pos, rx218_eos, rx218_fail
  # rx subrule "ws" subtype=method negate=
    rx218_cur."!cursor_pos"(rx218_pos)
    $P10 = rx218_cur."ws"()
    unless $P10, rx218_fail
    rx218_pos = $P10."pos"()
    goto alt224_end
  alt224_1:
.annotate 'line', 131
  # rx subrule "ws" subtype=method negate=
    rx218_cur."!cursor_pos"(rx218_pos)
    $P10 = rx218_cur."ws"()
    unless $P10, rx218_fail
    rx218_pos = $P10."pos"()
  # rx rxquantr228 ** 0..*
    set_addr $I10, rxquantr228_done
    rx218_cur."!mark_push"(0, rx218_pos, $I10)
  rxquantr228_loop:
  # rx subrule "statement" subtype=capture negate=
    rx218_cur."!cursor_pos"(rx218_pos)
    $P10 = rx218_cur."statement"()
    unless $P10, rx218_fail
    rx218_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx218_pos = $P10."pos"()
  # rx subrule "eat_terminator" subtype=method negate=
    rx218_cur."!cursor_pos"(rx218_pos)
    $P10 = rx218_cur."eat_terminator"()
    unless $P10, rx218_fail
    rx218_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx218_cur."!cursor_pos"(rx218_pos)
    $P10 = rx218_cur."ws"()
    unless $P10, rx218_fail
    rx218_pos = $P10."pos"()
    set_addr $I10, rxquantr228_done
    (rx218_rep) = rx218_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr228_done
    rx218_cur."!mark_push"(rx218_rep, rx218_pos, $I10)
    goto rxquantr228_loop
  rxquantr228_done:
  # rx subrule "ws" subtype=method negate=
    rx218_cur."!cursor_pos"(rx218_pos)
    $P10 = rx218_cur."ws"()
    unless $P10, rx218_fail
    rx218_pos = $P10."pos"()
  alt224_end:
.annotate 'line', 129
  # rx pass
    rx218_cur."!cursor_pass"(rx218_pos, "statementlist")
    if_null rx218_debug, debug_661
    rx218_cur."!cursor_debug"("PASS", "statementlist", " at pos=", rx218_pos)
  debug_661:
    .return (rx218_cur)
  rx218_restart:
.annotate 'line', 10
    if_null rx218_debug, debug_662
    rx218_cur."!cursor_debug"("NEXT", "statementlist")
  debug_662:
  rx218_fail:
    (rx218_rep, rx218_pos, $I10, $P10) = rx218_cur."!mark_fail"(0)
    lt rx218_pos, -1, rx218_done
    eq rx218_pos, -1, rx218_fail
    jump $I10
  rx218_done:
    rx218_cur."!cursor_fail"()
    if_null rx218_debug, debug_663
    rx218_cur."!cursor_debug"("FAIL", "statementlist")
  debug_663:
    .return (rx218_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statementlist"  :nsentry("!PREFIX__statementlist") :subid("33_1303401201.841") :method
.annotate 'line', 10
    $P220 = self."!PREFIX__!subrule"("ws", "")
    $P221 = self."!PREFIX__!subrule"("ws", "")
    new $P222, "ResizablePMCArray"
    push $P222, $P220
    push $P222, $P221
    .return ($P222)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement"  :subid("34_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .const 'Sub' $P237 = "36_1303401201.841" 
    capture_lex $P237
    .local string rx232_tgt
    .local int rx232_pos
    .local int rx232_off
    .local int rx232_eos
    .local int rx232_rep
    .local pmc rx232_cur
    .local pmc rx232_debug
    (rx232_cur, rx232_pos, rx232_tgt, $I10) = self."!cursor_start"()
    rx232_cur."!cursor_caparray"("statement_mod_cond", "statement_mod_loop")
    .lex unicode:"$\x{a2}", rx232_cur
    .local pmc match
    .lex "$/", match
    length rx232_eos, rx232_tgt
    gt rx232_pos, rx232_eos, rx232_done
    set rx232_off, 0
    lt rx232_pos, 2, rx232_start
    sub rx232_off, rx232_pos, 1
    substr rx232_tgt, rx232_tgt, rx232_off
  rx232_start:
    eq $I10, 1, rx232_restart
    if_null rx232_debug, debug_664
    rx232_cur."!cursor_debug"("START", "statement")
  debug_664:
    $I10 = self.'from'()
    ne $I10, -1, rxscan235_done
    goto rxscan235_scan
  rxscan235_loop:
    (rx232_pos) = rx232_cur."from"()
    inc rx232_pos
    rx232_cur."!cursor_from"(rx232_pos)
    ge rx232_pos, rx232_eos, rxscan235_done
  rxscan235_scan:
    set_addr $I10, rxscan235_loop
    rx232_cur."!mark_push"(0, rx232_pos, $I10)
  rxscan235_done:
.annotate 'line', 135
  # rx subrule "before" subtype=zerowidth negate=1
    rx232_cur."!cursor_pos"(rx232_pos)
    .const 'Sub' $P237 = "36_1303401201.841" 
    capture_lex $P237
    $P10 = rx232_cur."before"($P237)
    if $P10, rx232_fail
  alt241_0:
.annotate 'line', 136
    set_addr $I10, alt241_1
    rx232_cur."!mark_push"(0, rx232_pos, $I10)
.annotate 'line', 137
  # rx subrule "statement_control" subtype=capture negate=
    rx232_cur."!cursor_pos"(rx232_pos)
    $P10 = rx232_cur."statement_control"()
    unless $P10, rx232_fail
    rx232_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_control")
    rx232_pos = $P10."pos"()
    goto alt241_end
  alt241_1:
.annotate 'line', 138
  # rx subrule "EXPR" subtype=capture negate=
    rx232_cur."!cursor_pos"(rx232_pos)
    $P10 = rx232_cur."EXPR"()
    unless $P10, rx232_fail
    rx232_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx232_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx232_cur."!cursor_pos"(rx232_pos)
    $P10 = rx232_cur."ws"()
    unless $P10, rx232_fail
    rx232_pos = $P10."pos"()
.annotate 'line', 143
  # rx rxquantr242 ** 0..1
    set_addr $I10, rxquantr242_done
    rx232_cur."!mark_push"(0, rx232_pos, $I10)
  rxquantr242_loop:
  alt243_0:
.annotate 'line', 139
    set_addr $I10, alt243_1
    rx232_cur."!mark_push"(0, rx232_pos, $I10)
.annotate 'line', 140
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx232_cur."!cursor_pos"(rx232_pos)
    $P10 = rx232_cur."MARKED"("endstmt")
    unless $P10, rx232_fail
    goto alt243_end
  alt243_1:
    set_addr $I10, alt243_2
    rx232_cur."!mark_push"(0, rx232_pos, $I10)
.annotate 'line', 141
  # rx subrule "statement_mod_cond" subtype=capture negate=
    rx232_cur."!cursor_pos"(rx232_pos)
    $P10 = rx232_cur."statement_mod_cond"()
    unless $P10, rx232_fail
    rx232_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_cond")
    rx232_pos = $P10."pos"()
  # rx rxquantr244 ** 0..1
    set_addr $I10, rxquantr244_done
    rx232_cur."!mark_push"(0, rx232_pos, $I10)
  rxquantr244_loop:
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx232_cur."!cursor_pos"(rx232_pos)
    $P10 = rx232_cur."statement_mod_loop"()
    unless $P10, rx232_fail
    goto rxsubrule245_pass
  rxsubrule245_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx232_fail
  rxsubrule245_pass:
    set_addr $I10, rxsubrule245_back
    rx232_cur."!mark_push"(0, rx232_pos, $I10, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx232_pos = $P10."pos"()
    set_addr $I10, rxquantr244_done
    (rx232_rep) = rx232_cur."!mark_commit"($I10)
  rxquantr244_done:
    goto alt243_end
  alt243_2:
.annotate 'line', 142
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx232_cur."!cursor_pos"(rx232_pos)
    $P10 = rx232_cur."statement_mod_loop"()
    unless $P10, rx232_fail
    rx232_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx232_pos = $P10."pos"()
  alt243_end:
.annotate 'line', 143
    set_addr $I10, rxquantr242_done
    (rx232_rep) = rx232_cur."!mark_commit"($I10)
  rxquantr242_done:
  alt241_end:
.annotate 'line', 134
  # rx pass
    rx232_cur."!cursor_pass"(rx232_pos, "statement")
    if_null rx232_debug, debug_669
    rx232_cur."!cursor_debug"("PASS", "statement", " at pos=", rx232_pos)
  debug_669:
    .return (rx232_cur)
  rx232_restart:
.annotate 'line', 10
    if_null rx232_debug, debug_670
    rx232_cur."!cursor_debug"("NEXT", "statement")
  debug_670:
  rx232_fail:
    (rx232_rep, rx232_pos, $I10, $P10) = rx232_cur."!mark_fail"(0)
    lt rx232_pos, -1, rx232_done
    eq rx232_pos, -1, rx232_fail
    jump $I10
  rx232_done:
    rx232_cur."!cursor_fail"()
    if_null rx232_debug, debug_671
    rx232_cur."!cursor_debug"("FAIL", "statement")
  debug_671:
    .return (rx232_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement"  :nsentry("!PREFIX__statement") :subid("35_1303401201.841") :method
.annotate 'line', 10
    new $P234, "ResizablePMCArray"
    push $P234, ""
    .return ($P234)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block236"  :anon :subid("36_1303401201.841") :method :outer("34_1303401201.841")
.annotate 'line', 135
    .local string rx238_tgt
    .local int rx238_pos
    .local int rx238_off
    .local int rx238_eos
    .local int rx238_rep
    .local pmc rx238_cur
    .local pmc rx238_debug
    (rx238_cur, rx238_pos, rx238_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx238_cur
    .local pmc match
    .lex "$/", match
    length rx238_eos, rx238_tgt
    gt rx238_pos, rx238_eos, rx238_done
    set rx238_off, 0
    lt rx238_pos, 2, rx238_start
    sub rx238_off, rx238_pos, 1
    substr rx238_tgt, rx238_tgt, rx238_off
  rx238_start:
    eq $I10, 1, rx238_restart
    if_null rx238_debug, debug_665
    rx238_cur."!cursor_debug"("START", "")
  debug_665:
    $I10 = self.'from'()
    ne $I10, -1, rxscan239_done
    goto rxscan239_scan
  rxscan239_loop:
    (rx238_pos) = rx238_cur."from"()
    inc rx238_pos
    rx238_cur."!cursor_from"(rx238_pos)
    ge rx238_pos, rx238_eos, rxscan239_done
  rxscan239_scan:
    set_addr $I10, rxscan239_loop
    rx238_cur."!mark_push"(0, rx238_pos, $I10)
  rxscan239_done:
  alt240_0:
    set_addr $I10, alt240_1
    rx238_cur."!mark_push"(0, rx238_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx238_pos, rx238_eos, rx238_fail
    sub $I10, rx238_pos, rx238_off
    substr $S10, rx238_tgt, $I10, 1
    index $I11, "])}", $S10
    lt $I11, 0, rx238_fail
    inc rx238_pos
    goto alt240_end
  alt240_1:
  # rxanchor eos
    ne rx238_pos, rx238_eos, rx238_fail
  alt240_end:
  # rx pass
    rx238_cur."!cursor_pass"(rx238_pos, "")
    if_null rx238_debug, debug_666
    rx238_cur."!cursor_debug"("PASS", "", " at pos=", rx238_pos)
  debug_666:
    .return (rx238_cur)
  rx238_restart:
    if_null rx238_debug, debug_667
    rx238_cur."!cursor_debug"("NEXT", "")
  debug_667:
  rx238_fail:
    (rx238_rep, rx238_pos, $I10, $P10) = rx238_cur."!mark_fail"(0)
    lt rx238_pos, -1, rx238_done
    eq rx238_pos, -1, rx238_fail
    jump $I10
  rx238_done:
    rx238_cur."!cursor_fail"()
    if_null rx238_debug, debug_668
    rx238_cur."!cursor_debug"("FAIL", "")
  debug_668:
    .return (rx238_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "eat_terminator"  :subid("37_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx247_tgt
    .local int rx247_pos
    .local int rx247_off
    .local int rx247_eos
    .local int rx247_rep
    .local pmc rx247_cur
    .local pmc rx247_debug
    (rx247_cur, rx247_pos, rx247_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx247_cur
    .local pmc match
    .lex "$/", match
    length rx247_eos, rx247_tgt
    gt rx247_pos, rx247_eos, rx247_done
    set rx247_off, 0
    lt rx247_pos, 2, rx247_start
    sub rx247_off, rx247_pos, 1
    substr rx247_tgt, rx247_tgt, rx247_off
  rx247_start:
    eq $I10, 1, rx247_restart
    if_null rx247_debug, debug_672
    rx247_cur."!cursor_debug"("START", "eat_terminator")
  debug_672:
    $I10 = self.'from'()
    ne $I10, -1, rxscan250_done
    goto rxscan250_scan
  rxscan250_loop:
    (rx247_pos) = rx247_cur."from"()
    inc rx247_pos
    rx247_cur."!cursor_from"(rx247_pos)
    ge rx247_pos, rx247_eos, rxscan250_done
  rxscan250_scan:
    set_addr $I10, rxscan250_loop
    rx247_cur."!mark_push"(0, rx247_pos, $I10)
  rxscan250_done:
  alt251_0:
.annotate 'line', 147
    set_addr $I10, alt251_1
    rx247_cur."!mark_push"(0, rx247_pos, $I10)
.annotate 'line', 148
  # rx literal  ";"
    add $I11, rx247_pos, 1
    gt $I11, rx247_eos, rx247_fail
    sub $I11, rx247_pos, rx247_off
    ord $I11, rx247_tgt, $I11
    ne $I11, 59, rx247_fail
    add rx247_pos, 1
    goto alt251_end
  alt251_1:
    set_addr $I10, alt251_2
    rx247_cur."!mark_push"(0, rx247_pos, $I10)
.annotate 'line', 149
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx247_cur."!cursor_pos"(rx247_pos)
    $P10 = rx247_cur."MARKED"("endstmt")
    unless $P10, rx247_fail
    goto alt251_end
  alt251_2:
    set_addr $I10, alt251_3
    rx247_cur."!mark_push"(0, rx247_pos, $I10)
.annotate 'line', 150
  # rx subrule "terminator" subtype=zerowidth negate=
    rx247_cur."!cursor_pos"(rx247_pos)
    $P10 = rx247_cur."terminator"()
    unless $P10, rx247_fail
    goto alt251_end
  alt251_3:
.annotate 'line', 151
  # rxanchor eos
    ne rx247_pos, rx247_eos, rx247_fail
  alt251_end:
.annotate 'line', 147
  # rx pass
    rx247_cur."!cursor_pass"(rx247_pos, "eat_terminator")
    if_null rx247_debug, debug_673
    rx247_cur."!cursor_debug"("PASS", "eat_terminator", " at pos=", rx247_pos)
  debug_673:
    .return (rx247_cur)
  rx247_restart:
.annotate 'line', 10
    if_null rx247_debug, debug_674
    rx247_cur."!cursor_debug"("NEXT", "eat_terminator")
  debug_674:
  rx247_fail:
    (rx247_rep, rx247_pos, $I10, $P10) = rx247_cur."!mark_fail"(0)
    lt rx247_pos, -1, rx247_done
    eq rx247_pos, -1, rx247_fail
    jump $I10
  rx247_done:
    rx247_cur."!cursor_fail"()
    if_null rx247_debug, debug_675
    rx247_cur."!cursor_debug"("FAIL", "eat_terminator")
  debug_675:
    .return (rx247_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__eat_terminator"  :nsentry("!PREFIX__eat_terminator") :subid("38_1303401201.841") :method
.annotate 'line', 10
    new $P249, "ResizablePMCArray"
    push $P249, ""
    push $P249, ""
    push $P249, ""
    push $P249, ";"
    .return ($P249)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "xblock"  :subid("39_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx253_tgt
    .local int rx253_pos
    .local int rx253_off
    .local int rx253_eos
    .local int rx253_rep
    .local pmc rx253_cur
    .local pmc rx253_debug
    (rx253_cur, rx253_pos, rx253_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx253_cur
    .local pmc match
    .lex "$/", match
    length rx253_eos, rx253_tgt
    gt rx253_pos, rx253_eos, rx253_done
    set rx253_off, 0
    lt rx253_pos, 2, rx253_start
    sub rx253_off, rx253_pos, 1
    substr rx253_tgt, rx253_tgt, rx253_off
  rx253_start:
    eq $I10, 1, rx253_restart
    if_null rx253_debug, debug_676
    rx253_cur."!cursor_debug"("START", "xblock")
  debug_676:
    $I10 = self.'from'()
    ne $I10, -1, rxscan257_done
    goto rxscan257_scan
  rxscan257_loop:
    (rx253_pos) = rx253_cur."from"()
    inc rx253_pos
    rx253_cur."!cursor_from"(rx253_pos)
    ge rx253_pos, rx253_eos, rxscan257_done
  rxscan257_scan:
    set_addr $I10, rxscan257_loop
    rx253_cur."!mark_push"(0, rx253_pos, $I10)
  rxscan257_done:
.annotate 'line', 155
  # rx subrule "EXPR" subtype=capture negate=
    rx253_cur."!cursor_pos"(rx253_pos)
    $P10 = rx253_cur."EXPR"()
    unless $P10, rx253_fail
    rx253_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx253_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx253_cur."!cursor_pos"(rx253_pos)
    $P10 = rx253_cur."ws"()
    unless $P10, rx253_fail
    rx253_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx253_cur."!cursor_pos"(rx253_pos)
    $P10 = rx253_cur."pblock"()
    unless $P10, rx253_fail
    rx253_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx253_pos = $P10."pos"()
.annotate 'line', 154
  # rx pass
    rx253_cur."!cursor_pass"(rx253_pos, "xblock")
    if_null rx253_debug, debug_677
    rx253_cur."!cursor_debug"("PASS", "xblock", " at pos=", rx253_pos)
  debug_677:
    .return (rx253_cur)
  rx253_restart:
.annotate 'line', 10
    if_null rx253_debug, debug_678
    rx253_cur."!cursor_debug"("NEXT", "xblock")
  debug_678:
  rx253_fail:
    (rx253_rep, rx253_pos, $I10, $P10) = rx253_cur."!mark_fail"(0)
    lt rx253_pos, -1, rx253_done
    eq rx253_pos, -1, rx253_fail
    jump $I10
  rx253_done:
    rx253_cur."!cursor_fail"()
    if_null rx253_debug, debug_679
    rx253_cur."!cursor_debug"("FAIL", "xblock")
  debug_679:
    .return (rx253_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__xblock"  :nsentry("!PREFIX__xblock") :subid("40_1303401201.841") :method
.annotate 'line', 10
    $P255 = self."!PREFIX__!subrule"("EXPR", "")
    new $P256, "ResizablePMCArray"
    push $P256, $P255
    .return ($P256)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pblock"  :subid("41_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx259_tgt
    .local int rx259_pos
    .local int rx259_off
    .local int rx259_eos
    .local int rx259_rep
    .local pmc rx259_cur
    .local pmc rx259_debug
    (rx259_cur, rx259_pos, rx259_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx259_cur
    .local pmc match
    .lex "$/", match
    length rx259_eos, rx259_tgt
    gt rx259_pos, rx259_eos, rx259_done
    set rx259_off, 0
    lt rx259_pos, 2, rx259_start
    sub rx259_off, rx259_pos, 1
    substr rx259_tgt, rx259_tgt, rx259_off
  rx259_start:
    eq $I10, 1, rx259_restart
    if_null rx259_debug, debug_680
    rx259_cur."!cursor_debug"("START", "pblock")
  debug_680:
    $I10 = self.'from'()
    ne $I10, -1, rxscan264_done
    goto rxscan264_scan
  rxscan264_loop:
    (rx259_pos) = rx259_cur."from"()
    inc rx259_pos
    rx259_cur."!cursor_from"(rx259_pos)
    ge rx259_pos, rx259_eos, rxscan264_done
  rxscan264_scan:
    set_addr $I10, rxscan264_loop
    rx259_cur."!mark_push"(0, rx259_pos, $I10)
  rxscan264_done:
  alt265_0:
.annotate 'line', 158
    set_addr $I10, alt265_1
    rx259_cur."!mark_push"(0, rx259_pos, $I10)
.annotate 'line', 159
  # rx subrule "lambda" subtype=method negate=
    rx259_cur."!cursor_pos"(rx259_pos)
    $P10 = rx259_cur."lambda"()
    unless $P10, rx259_fail
    rx259_pos = $P10."pos"()
.annotate 'line', 160
  # rx subrule "newpad" subtype=method negate=
    rx259_cur."!cursor_pos"(rx259_pos)
    $P10 = rx259_cur."newpad"()
    unless $P10, rx259_fail
    rx259_pos = $P10."pos"()
.annotate 'line', 161
  # rx subrule "signature" subtype=capture negate=
    rx259_cur."!cursor_pos"(rx259_pos)
    $P10 = rx259_cur."signature"()
    unless $P10, rx259_fail
    rx259_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx259_pos = $P10."pos"()
.annotate 'line', 162
  # rx subrule "blockoid" subtype=capture negate=
    rx259_cur."!cursor_pos"(rx259_pos)
    $P10 = rx259_cur."blockoid"()
    unless $P10, rx259_fail
    rx259_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx259_pos = $P10."pos"()
.annotate 'line', 159
    goto alt265_end
  alt265_1:
    set_addr $I10, alt265_2
    rx259_cur."!mark_push"(0, rx259_pos, $I10)
.annotate 'line', 163
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx259_pos, rx259_off
    substr $S10, rx259_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx259_fail
.annotate 'line', 164
  # rx subrule "newpad" subtype=method negate=
    rx259_cur."!cursor_pos"(rx259_pos)
    $P10 = rx259_cur."newpad"()
    unless $P10, rx259_fail
    rx259_pos = $P10."pos"()
.annotate 'line', 165
  # rx subrule "blockoid" subtype=capture negate=
    rx259_cur."!cursor_pos"(rx259_pos)
    $P10 = rx259_cur."blockoid"()
    unless $P10, rx259_fail
    rx259_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx259_pos = $P10."pos"()
.annotate 'line', 163
    goto alt265_end
  alt265_2:
.annotate 'line', 166
  # rx subrule "panic" subtype=method negate=
    rx259_cur."!cursor_pos"(rx259_pos)
    $P10 = rx259_cur."panic"("Missing block")
    unless $P10, rx259_fail
    rx259_pos = $P10."pos"()
  alt265_end:
.annotate 'line', 158
  # rx pass
    rx259_cur."!cursor_pass"(rx259_pos, "pblock")
    if_null rx259_debug, debug_681
    rx259_cur."!cursor_debug"("PASS", "pblock", " at pos=", rx259_pos)
  debug_681:
    .return (rx259_cur)
  rx259_restart:
.annotate 'line', 10
    if_null rx259_debug, debug_682
    rx259_cur."!cursor_debug"("NEXT", "pblock")
  debug_682:
  rx259_fail:
    (rx259_rep, rx259_pos, $I10, $P10) = rx259_cur."!mark_fail"(0)
    lt rx259_pos, -1, rx259_done
    eq rx259_pos, -1, rx259_fail
    jump $I10
  rx259_done:
    rx259_cur."!cursor_fail"()
    if_null rx259_debug, debug_683
    rx259_cur."!cursor_debug"("FAIL", "pblock")
  debug_683:
    .return (rx259_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pblock"  :nsentry("!PREFIX__pblock") :subid("42_1303401201.841") :method
.annotate 'line', 10
    $P261 = self."!PREFIX__!subrule"("panic", "")
    $P262 = self."!PREFIX__!subrule"("lambda", "")
    new $P263, "ResizablePMCArray"
    push $P263, $P261
    push $P263, "{"
    push $P263, $P262
    .return ($P263)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "lambda"  :subid("43_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx267_tgt
    .local int rx267_pos
    .local int rx267_off
    .local int rx267_eos
    .local int rx267_rep
    .local pmc rx267_cur
    .local pmc rx267_debug
    (rx267_cur, rx267_pos, rx267_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx267_cur
    .local pmc match
    .lex "$/", match
    length rx267_eos, rx267_tgt
    gt rx267_pos, rx267_eos, rx267_done
    set rx267_off, 0
    lt rx267_pos, 2, rx267_start
    sub rx267_off, rx267_pos, 1
    substr rx267_tgt, rx267_tgt, rx267_off
  rx267_start:
    eq $I10, 1, rx267_restart
    if_null rx267_debug, debug_684
    rx267_cur."!cursor_debug"("START", "lambda")
  debug_684:
    $I10 = self.'from'()
    ne $I10, -1, rxscan270_done
    goto rxscan270_scan
  rxscan270_loop:
    (rx267_pos) = rx267_cur."from"()
    inc rx267_pos
    rx267_cur."!cursor_from"(rx267_pos)
    ge rx267_pos, rx267_eos, rxscan270_done
  rxscan270_scan:
    set_addr $I10, rxscan270_loop
    rx267_cur."!mark_push"(0, rx267_pos, $I10)
  rxscan270_done:
  alt271_0:
.annotate 'line', 169
    set_addr $I10, alt271_1
    rx267_cur."!mark_push"(0, rx267_pos, $I10)
  # rx literal  "->"
    add $I11, rx267_pos, 2
    gt $I11, rx267_eos, rx267_fail
    sub $I11, rx267_pos, rx267_off
    substr $S10, rx267_tgt, $I11, 2
    ne $S10, "->", rx267_fail
    add rx267_pos, 2
    goto alt271_end
  alt271_1:
  # rx literal  "<->"
    add $I11, rx267_pos, 3
    gt $I11, rx267_eos, rx267_fail
    sub $I11, rx267_pos, rx267_off
    substr $S10, rx267_tgt, $I11, 3
    ne $S10, "<->", rx267_fail
    add rx267_pos, 3
  alt271_end:
  # rx pass
    rx267_cur."!cursor_pass"(rx267_pos, "lambda")
    if_null rx267_debug, debug_685
    rx267_cur."!cursor_debug"("PASS", "lambda", " at pos=", rx267_pos)
  debug_685:
    .return (rx267_cur)
  rx267_restart:
.annotate 'line', 10
    if_null rx267_debug, debug_686
    rx267_cur."!cursor_debug"("NEXT", "lambda")
  debug_686:
  rx267_fail:
    (rx267_rep, rx267_pos, $I10, $P10) = rx267_cur."!mark_fail"(0)
    lt rx267_pos, -1, rx267_done
    eq rx267_pos, -1, rx267_fail
    jump $I10
  rx267_done:
    rx267_cur."!cursor_fail"()
    if_null rx267_debug, debug_687
    rx267_cur."!cursor_debug"("FAIL", "lambda")
  debug_687:
    .return (rx267_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__lambda"  :nsentry("!PREFIX__lambda") :subid("44_1303401201.841") :method
.annotate 'line', 10
    new $P269, "ResizablePMCArray"
    push $P269, "<->"
    push $P269, "->"
    .return ($P269)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "block"  :subid("45_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx273_tgt
    .local int rx273_pos
    .local int rx273_off
    .local int rx273_eos
    .local int rx273_rep
    .local pmc rx273_cur
    .local pmc rx273_debug
    (rx273_cur, rx273_pos, rx273_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx273_cur
    .local pmc match
    .lex "$/", match
    length rx273_eos, rx273_tgt
    gt rx273_pos, rx273_eos, rx273_done
    set rx273_off, 0
    lt rx273_pos, 2, rx273_start
    sub rx273_off, rx273_pos, 1
    substr rx273_tgt, rx273_tgt, rx273_off
  rx273_start:
    eq $I10, 1, rx273_restart
    if_null rx273_debug, debug_688
    rx273_cur."!cursor_debug"("START", "block")
  debug_688:
    $I10 = self.'from'()
    ne $I10, -1, rxscan277_done
    goto rxscan277_scan
  rxscan277_loop:
    (rx273_pos) = rx273_cur."from"()
    inc rx273_pos
    rx273_cur."!cursor_from"(rx273_pos)
    ge rx273_pos, rx273_eos, rxscan277_done
  rxscan277_scan:
    set_addr $I10, rxscan277_loop
    rx273_cur."!mark_push"(0, rx273_pos, $I10)
  rxscan277_done:
  alt278_0:
.annotate 'line', 172
    set_addr $I10, alt278_1
    rx273_cur."!mark_push"(0, rx273_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx273_pos, rx273_off
    substr $S10, rx273_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx273_fail
    goto alt278_end
  alt278_1:
  # rx subrule "panic" subtype=method negate=
    rx273_cur."!cursor_pos"(rx273_pos)
    $P10 = rx273_cur."panic"("Missing block")
    unless $P10, rx273_fail
    rx273_pos = $P10."pos"()
  alt278_end:
.annotate 'line', 173
  # rx subrule "newpad" subtype=method negate=
    rx273_cur."!cursor_pos"(rx273_pos)
    $P10 = rx273_cur."newpad"()
    unless $P10, rx273_fail
    rx273_pos = $P10."pos"()
.annotate 'line', 174
  # rx subrule "blockoid" subtype=capture negate=
    rx273_cur."!cursor_pos"(rx273_pos)
    $P10 = rx273_cur."blockoid"()
    unless $P10, rx273_fail
    rx273_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx273_pos = $P10."pos"()
.annotate 'line', 171
  # rx pass
    rx273_cur."!cursor_pass"(rx273_pos, "block")
    if_null rx273_debug, debug_689
    rx273_cur."!cursor_debug"("PASS", "block", " at pos=", rx273_pos)
  debug_689:
    .return (rx273_cur)
  rx273_restart:
.annotate 'line', 10
    if_null rx273_debug, debug_690
    rx273_cur."!cursor_debug"("NEXT", "block")
  debug_690:
  rx273_fail:
    (rx273_rep, rx273_pos, $I10, $P10) = rx273_cur."!mark_fail"(0)
    lt rx273_pos, -1, rx273_done
    eq rx273_pos, -1, rx273_fail
    jump $I10
  rx273_done:
    rx273_cur."!cursor_fail"()
    if_null rx273_debug, debug_691
    rx273_cur."!cursor_debug"("FAIL", "block")
  debug_691:
    .return (rx273_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__block"  :nsentry("!PREFIX__block") :subid("46_1303401201.841") :method
.annotate 'line', 10
    $P275 = self."!PREFIX__!subrule"("panic", "")
    new $P276, "ResizablePMCArray"
    push $P276, $P275
    push $P276, "{"
    .return ($P276)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blockoid"  :subid("47_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx280_tgt
    .local int rx280_pos
    .local int rx280_off
    .local int rx280_eos
    .local int rx280_rep
    .local pmc rx280_cur
    .local pmc rx280_debug
    (rx280_cur, rx280_pos, rx280_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx280_cur
    .local pmc match
    .lex "$/", match
    length rx280_eos, rx280_tgt
    gt rx280_pos, rx280_eos, rx280_done
    set rx280_off, 0
    lt rx280_pos, 2, rx280_start
    sub rx280_off, rx280_pos, 1
    substr rx280_tgt, rx280_tgt, rx280_off
  rx280_start:
    eq $I10, 1, rx280_restart
    if_null rx280_debug, debug_692
    rx280_cur."!cursor_debug"("START", "blockoid")
  debug_692:
    $I10 = self.'from'()
    ne $I10, -1, rxscan284_done
    goto rxscan284_scan
  rxscan284_loop:
    (rx280_pos) = rx280_cur."from"()
    inc rx280_pos
    rx280_cur."!cursor_from"(rx280_pos)
    ge rx280_pos, rx280_eos, rxscan284_done
  rxscan284_scan:
    set_addr $I10, rxscan284_loop
    rx280_cur."!mark_push"(0, rx280_pos, $I10)
  rxscan284_done:
.annotate 'line', 178
  # rx subrule "finishpad" subtype=method negate=
    rx280_cur."!cursor_pos"(rx280_pos)
    $P10 = rx280_cur."finishpad"()
    unless $P10, rx280_fail
    rx280_pos = $P10."pos"()
  alt285_0:
.annotate 'line', 179
    set_addr $I10, alt285_1
    rx280_cur."!mark_push"(0, rx280_pos, $I10)
.annotate 'line', 180
  # rx literal  "{YOU_ARE_HERE}"
    add $I11, rx280_pos, 14
    gt $I11, rx280_eos, rx280_fail
    sub $I11, rx280_pos, rx280_off
    substr $S10, rx280_tgt, $I11, 14
    ne $S10, "{YOU_ARE_HERE}", rx280_fail
    add rx280_pos, 14
  # rx subrule "you_are_here" subtype=capture negate=
    rx280_cur."!cursor_pos"(rx280_pos)
    $P10 = rx280_cur."you_are_here"()
    unless $P10, rx280_fail
    rx280_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("you_are_here")
    rx280_pos = $P10."pos"()
    goto alt285_end
  alt285_1:
.annotate 'line', 181
  # rx literal  "{"
    add $I11, rx280_pos, 1
    gt $I11, rx280_eos, rx280_fail
    sub $I11, rx280_pos, rx280_off
    ord $I11, rx280_tgt, $I11
    ne $I11, 123, rx280_fail
    add rx280_pos, 1
  # rx subrule "statementlist" subtype=capture negate=
    rx280_cur."!cursor_pos"(rx280_pos)
    $P10 = rx280_cur."statementlist"()
    unless $P10, rx280_fail
    rx280_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx280_pos = $P10."pos"()
  alt286_0:
    set_addr $I10, alt286_1
    rx280_cur."!mark_push"(0, rx280_pos, $I10)
  # rx literal  "}"
    add $I11, rx280_pos, 1
    gt $I11, rx280_eos, rx280_fail
    sub $I11, rx280_pos, rx280_off
    ord $I11, rx280_tgt, $I11
    ne $I11, 125, rx280_fail
    add rx280_pos, 1
    goto alt286_end
  alt286_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx280_cur."!cursor_pos"(rx280_pos)
    $P10 = rx280_cur."FAILGOAL"("'}'")
    unless $P10, rx280_fail
    goto rxsubrule288_pass
  rxsubrule288_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx280_fail
  rxsubrule288_pass:
    set_addr $I10, rxsubrule288_back
    rx280_cur."!mark_push"(0, rx280_pos, $I10, $P10)
    rx280_pos = $P10."pos"()
  alt286_end:
  alt285_end:
.annotate 'line', 183
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx280_cur."!cursor_pos"(rx280_pos)
    $P10 = rx280_cur."ENDSTMT"()
    unless $P10, rx280_fail
.annotate 'line', 177
  # rx pass
    rx280_cur."!cursor_pass"(rx280_pos, "blockoid")
    if_null rx280_debug, debug_693
    rx280_cur."!cursor_debug"("PASS", "blockoid", " at pos=", rx280_pos)
  debug_693:
    .return (rx280_cur)
  rx280_restart:
.annotate 'line', 10
    if_null rx280_debug, debug_694
    rx280_cur."!cursor_debug"("NEXT", "blockoid")
  debug_694:
  rx280_fail:
    (rx280_rep, rx280_pos, $I10, $P10) = rx280_cur."!mark_fail"(0)
    lt rx280_pos, -1, rx280_done
    eq rx280_pos, -1, rx280_fail
    jump $I10
  rx280_done:
    rx280_cur."!cursor_fail"()
    if_null rx280_debug, debug_695
    rx280_cur."!cursor_debug"("FAIL", "blockoid")
  debug_695:
    .return (rx280_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blockoid"  :nsentry("!PREFIX__blockoid") :subid("48_1303401201.841") :method
.annotate 'line', 10
    $P282 = self."!PREFIX__!subrule"("finishpad", "")
    new $P283, "ResizablePMCArray"
    push $P283, $P282
    .return ($P283)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "newpad"  :subid("49_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx290_tgt
    .local int rx290_pos
    .local int rx290_off
    .local int rx290_eos
    .local int rx290_rep
    .local pmc rx290_cur
    .local pmc rx290_debug
    (rx290_cur, rx290_pos, rx290_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx290_cur
    .local pmc match
    .lex "$/", match
    length rx290_eos, rx290_tgt
    gt rx290_pos, rx290_eos, rx290_done
    set rx290_off, 0
    lt rx290_pos, 2, rx290_start
    sub rx290_off, rx290_pos, 1
    substr rx290_tgt, rx290_tgt, rx290_off
  rx290_start:
    eq $I10, 1, rx290_restart
    if_null rx290_debug, debug_696
    rx290_cur."!cursor_debug"("START", "newpad")
  debug_696:
    $I10 = self.'from'()
    ne $I10, -1, rxscan293_done
    goto rxscan293_scan
  rxscan293_loop:
    (rx290_pos) = rx290_cur."from"()
    inc rx290_pos
    rx290_cur."!cursor_from"(rx290_pos)
    ge rx290_pos, rx290_eos, rxscan293_done
  rxscan293_scan:
    set_addr $I10, rxscan293_loop
    rx290_cur."!mark_push"(0, rx290_pos, $I10)
  rxscan293_done:
.annotate 'line', 186
  # rx pass
    rx290_cur."!cursor_pass"(rx290_pos, "newpad")
    if_null rx290_debug, debug_697
    rx290_cur."!cursor_debug"("PASS", "newpad", " at pos=", rx290_pos)
  debug_697:
    .return (rx290_cur)
  rx290_restart:
.annotate 'line', 10
    if_null rx290_debug, debug_698
    rx290_cur."!cursor_debug"("NEXT", "newpad")
  debug_698:
  rx290_fail:
    (rx290_rep, rx290_pos, $I10, $P10) = rx290_cur."!mark_fail"(0)
    lt rx290_pos, -1, rx290_done
    eq rx290_pos, -1, rx290_fail
    jump $I10
  rx290_done:
    rx290_cur."!cursor_fail"()
    if_null rx290_debug, debug_699
    rx290_cur."!cursor_debug"("FAIL", "newpad")
  debug_699:
    .return (rx290_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__newpad"  :nsentry("!PREFIX__newpad") :subid("50_1303401201.841") :method
.annotate 'line', 10
    new $P292, "ResizablePMCArray"
    push $P292, ""
    .return ($P292)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "outerctx"  :subid("51_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx295_tgt
    .local int rx295_pos
    .local int rx295_off
    .local int rx295_eos
    .local int rx295_rep
    .local pmc rx295_cur
    .local pmc rx295_debug
    (rx295_cur, rx295_pos, rx295_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx295_cur
    .local pmc match
    .lex "$/", match
    length rx295_eos, rx295_tgt
    gt rx295_pos, rx295_eos, rx295_done
    set rx295_off, 0
    lt rx295_pos, 2, rx295_start
    sub rx295_off, rx295_pos, 1
    substr rx295_tgt, rx295_tgt, rx295_off
  rx295_start:
    eq $I10, 1, rx295_restart
    if_null rx295_debug, debug_700
    rx295_cur."!cursor_debug"("START", "outerctx")
  debug_700:
    $I10 = self.'from'()
    ne $I10, -1, rxscan298_done
    goto rxscan298_scan
  rxscan298_loop:
    (rx295_pos) = rx295_cur."from"()
    inc rx295_pos
    rx295_cur."!cursor_from"(rx295_pos)
    ge rx295_pos, rx295_eos, rxscan298_done
  rxscan298_scan:
    set_addr $I10, rxscan298_loop
    rx295_cur."!mark_push"(0, rx295_pos, $I10)
  rxscan298_done:
.annotate 'line', 187
  # rx pass
    rx295_cur."!cursor_pass"(rx295_pos, "outerctx")
    if_null rx295_debug, debug_701
    rx295_cur."!cursor_debug"("PASS", "outerctx", " at pos=", rx295_pos)
  debug_701:
    .return (rx295_cur)
  rx295_restart:
.annotate 'line', 10
    if_null rx295_debug, debug_702
    rx295_cur."!cursor_debug"("NEXT", "outerctx")
  debug_702:
  rx295_fail:
    (rx295_rep, rx295_pos, $I10, $P10) = rx295_cur."!mark_fail"(0)
    lt rx295_pos, -1, rx295_done
    eq rx295_pos, -1, rx295_fail
    jump $I10
  rx295_done:
    rx295_cur."!cursor_fail"()
    if_null rx295_debug, debug_703
    rx295_cur."!cursor_debug"("FAIL", "outerctx")
  debug_703:
    .return (rx295_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__outerctx"  :nsentry("!PREFIX__outerctx") :subid("52_1303401201.841") :method
.annotate 'line', 10
    new $P297, "ResizablePMCArray"
    push $P297, ""
    .return ($P297)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "GLOBALish"  :subid("53_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx300_tgt
    .local int rx300_pos
    .local int rx300_off
    .local int rx300_eos
    .local int rx300_rep
    .local pmc rx300_cur
    .local pmc rx300_debug
    (rx300_cur, rx300_pos, rx300_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx300_cur
    .local pmc match
    .lex "$/", match
    length rx300_eos, rx300_tgt
    gt rx300_pos, rx300_eos, rx300_done
    set rx300_off, 0
    lt rx300_pos, 2, rx300_start
    sub rx300_off, rx300_pos, 1
    substr rx300_tgt, rx300_tgt, rx300_off
  rx300_start:
    eq $I10, 1, rx300_restart
    if_null rx300_debug, debug_704
    rx300_cur."!cursor_debug"("START", "GLOBALish")
  debug_704:
    $I10 = self.'from'()
    ne $I10, -1, rxscan303_done
    goto rxscan303_scan
  rxscan303_loop:
    (rx300_pos) = rx300_cur."from"()
    inc rx300_pos
    rx300_cur."!cursor_from"(rx300_pos)
    ge rx300_pos, rx300_eos, rxscan303_done
  rxscan303_scan:
    set_addr $I10, rxscan303_loop
    rx300_cur."!mark_push"(0, rx300_pos, $I10)
  rxscan303_done:
.annotate 'line', 188
  # rx pass
    rx300_cur."!cursor_pass"(rx300_pos, "GLOBALish")
    if_null rx300_debug, debug_705
    rx300_cur."!cursor_debug"("PASS", "GLOBALish", " at pos=", rx300_pos)
  debug_705:
    .return (rx300_cur)
  rx300_restart:
.annotate 'line', 10
    if_null rx300_debug, debug_706
    rx300_cur."!cursor_debug"("NEXT", "GLOBALish")
  debug_706:
  rx300_fail:
    (rx300_rep, rx300_pos, $I10, $P10) = rx300_cur."!mark_fail"(0)
    lt rx300_pos, -1, rx300_done
    eq rx300_pos, -1, rx300_fail
    jump $I10
  rx300_done:
    rx300_cur."!cursor_fail"()
    if_null rx300_debug, debug_707
    rx300_cur."!cursor_debug"("FAIL", "GLOBALish")
  debug_707:
    .return (rx300_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__GLOBALish"  :nsentry("!PREFIX__GLOBALish") :subid("54_1303401201.841") :method
.annotate 'line', 10
    new $P302, "ResizablePMCArray"
    push $P302, ""
    .return ($P302)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "finishpad"  :subid("55_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx305_tgt
    .local int rx305_pos
    .local int rx305_off
    .local int rx305_eos
    .local int rx305_rep
    .local pmc rx305_cur
    .local pmc rx305_debug
    (rx305_cur, rx305_pos, rx305_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx305_cur
    .local pmc match
    .lex "$/", match
    length rx305_eos, rx305_tgt
    gt rx305_pos, rx305_eos, rx305_done
    set rx305_off, 0
    lt rx305_pos, 2, rx305_start
    sub rx305_off, rx305_pos, 1
    substr rx305_tgt, rx305_tgt, rx305_off
  rx305_start:
    eq $I10, 1, rx305_restart
    if_null rx305_debug, debug_708
    rx305_cur."!cursor_debug"("START", "finishpad")
  debug_708:
    $I10 = self.'from'()
    ne $I10, -1, rxscan308_done
    goto rxscan308_scan
  rxscan308_loop:
    (rx305_pos) = rx305_cur."from"()
    inc rx305_pos
    rx305_cur."!cursor_from"(rx305_pos)
    ge rx305_pos, rx305_eos, rxscan308_done
  rxscan308_scan:
    set_addr $I10, rxscan308_loop
    rx305_cur."!mark_push"(0, rx305_pos, $I10)
  rxscan308_done:
.annotate 'line', 189
  # rx pass
    rx305_cur."!cursor_pass"(rx305_pos, "finishpad")
    if_null rx305_debug, debug_709
    rx305_cur."!cursor_debug"("PASS", "finishpad", " at pos=", rx305_pos)
  debug_709:
    .return (rx305_cur)
  rx305_restart:
.annotate 'line', 10
    if_null rx305_debug, debug_710
    rx305_cur."!cursor_debug"("NEXT", "finishpad")
  debug_710:
  rx305_fail:
    (rx305_rep, rx305_pos, $I10, $P10) = rx305_cur."!mark_fail"(0)
    lt rx305_pos, -1, rx305_done
    eq rx305_pos, -1, rx305_fail
    jump $I10
  rx305_done:
    rx305_cur."!cursor_fail"()
    if_null rx305_debug, debug_711
    rx305_cur."!cursor_debug"("FAIL", "finishpad")
  debug_711:
    .return (rx305_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__finishpad"  :nsentry("!PREFIX__finishpad") :subid("56_1303401201.841") :method
.annotate 'line', 10
    new $P307, "ResizablePMCArray"
    push $P307, ""
    .return ($P307)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "you_are_here"  :subid("57_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx310_tgt
    .local int rx310_pos
    .local int rx310_off
    .local int rx310_eos
    .local int rx310_rep
    .local pmc rx310_cur
    .local pmc rx310_debug
    (rx310_cur, rx310_pos, rx310_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx310_cur
    .local pmc match
    .lex "$/", match
    length rx310_eos, rx310_tgt
    gt rx310_pos, rx310_eos, rx310_done
    set rx310_off, 0
    lt rx310_pos, 2, rx310_start
    sub rx310_off, rx310_pos, 1
    substr rx310_tgt, rx310_tgt, rx310_off
  rx310_start:
    eq $I10, 1, rx310_restart
    if_null rx310_debug, debug_712
    rx310_cur."!cursor_debug"("START", "you_are_here")
  debug_712:
    $I10 = self.'from'()
    ne $I10, -1, rxscan313_done
    goto rxscan313_scan
  rxscan313_loop:
    (rx310_pos) = rx310_cur."from"()
    inc rx310_pos
    rx310_cur."!cursor_from"(rx310_pos)
    ge rx310_pos, rx310_eos, rxscan313_done
  rxscan313_scan:
    set_addr $I10, rxscan313_loop
    rx310_cur."!mark_push"(0, rx310_pos, $I10)
  rxscan313_done:
.annotate 'line', 190
  # rx pass
    rx310_cur."!cursor_pass"(rx310_pos, "you_are_here")
    if_null rx310_debug, debug_713
    rx310_cur."!cursor_debug"("PASS", "you_are_here", " at pos=", rx310_pos)
  debug_713:
    .return (rx310_cur)
  rx310_restart:
.annotate 'line', 10
    if_null rx310_debug, debug_714
    rx310_cur."!cursor_debug"("NEXT", "you_are_here")
  debug_714:
  rx310_fail:
    (rx310_rep, rx310_pos, $I10, $P10) = rx310_cur."!mark_fail"(0)
    lt rx310_pos, -1, rx310_done
    eq rx310_pos, -1, rx310_fail
    jump $I10
  rx310_done:
    rx310_cur."!cursor_fail"()
    if_null rx310_debug, debug_715
    rx310_cur."!cursor_debug"("FAIL", "you_are_here")
  debug_715:
    .return (rx310_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__you_are_here"  :nsentry("!PREFIX__you_are_here") :subid("58_1303401201.841") :method
.annotate 'line', 10
    new $P312, "ResizablePMCArray"
    push $P312, ""
    .return ($P312)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator"  :subid("59_1303401201.841")
    .param pmc param_315
.annotate 'line', 192
    .lex "self", param_315
    $P316 = param_315."!protoregex"("terminator")
    .return ($P316)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator"  :subid("60_1303401201.841")
    .param pmc param_318
.annotate 'line', 192
    .lex "self", param_318
    $P319 = param_318."!PREFIX__!protoregex"("terminator")
    .return ($P319)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<;>"  :subid("61_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx321_tgt
    .local int rx321_pos
    .local int rx321_off
    .local int rx321_eos
    .local int rx321_rep
    .local pmc rx321_cur
    .local pmc rx321_debug
    (rx321_cur, rx321_pos, rx321_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx321_cur
    .local pmc match
    .lex "$/", match
    length rx321_eos, rx321_tgt
    gt rx321_pos, rx321_eos, rx321_done
    set rx321_off, 0
    lt rx321_pos, 2, rx321_start
    sub rx321_off, rx321_pos, 1
    substr rx321_tgt, rx321_tgt, rx321_off
  rx321_start:
    eq $I10, 1, rx321_restart
    if_null rx321_debug, debug_716
    rx321_cur."!cursor_debug"("START", "terminator:sym<;>")
  debug_716:
    $I10 = self.'from'()
    ne $I10, -1, rxscan324_done
    goto rxscan324_scan
  rxscan324_loop:
    (rx321_pos) = rx321_cur."from"()
    inc rx321_pos
    rx321_cur."!cursor_from"(rx321_pos)
    ge rx321_pos, rx321_eos, rxscan324_done
  rxscan324_scan:
    set_addr $I10, rxscan324_loop
    rx321_cur."!mark_push"(0, rx321_pos, $I10)
  rxscan324_done:
.annotate 'line', 194
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx321_pos, rx321_off
    substr $S10, rx321_tgt, $I10, 1
    index $I11, ";", $S10
    lt $I11, 0, rx321_fail
  # rx pass
    rx321_cur."!cursor_pass"(rx321_pos, "terminator:sym<;>")
    if_null rx321_debug, debug_717
    rx321_cur."!cursor_debug"("PASS", "terminator:sym<;>", " at pos=", rx321_pos)
  debug_717:
    .return (rx321_cur)
  rx321_restart:
.annotate 'line', 10
    if_null rx321_debug, debug_718
    rx321_cur."!cursor_debug"("NEXT", "terminator:sym<;>")
  debug_718:
  rx321_fail:
    (rx321_rep, rx321_pos, $I10, $P10) = rx321_cur."!mark_fail"(0)
    lt rx321_pos, -1, rx321_done
    eq rx321_pos, -1, rx321_fail
    jump $I10
  rx321_done:
    rx321_cur."!cursor_fail"()
    if_null rx321_debug, debug_719
    rx321_cur."!cursor_debug"("FAIL", "terminator:sym<;>")
  debug_719:
    .return (rx321_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<;>"  :nsentry("!PREFIX__terminator:sym<;>") :subid("62_1303401201.841") :method
.annotate 'line', 10
    new $P323, "ResizablePMCArray"
    push $P323, ";"
    .return ($P323)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<}>"  :subid("63_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx326_tgt
    .local int rx326_pos
    .local int rx326_off
    .local int rx326_eos
    .local int rx326_rep
    .local pmc rx326_cur
    .local pmc rx326_debug
    (rx326_cur, rx326_pos, rx326_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx326_cur
    .local pmc match
    .lex "$/", match
    length rx326_eos, rx326_tgt
    gt rx326_pos, rx326_eos, rx326_done
    set rx326_off, 0
    lt rx326_pos, 2, rx326_start
    sub rx326_off, rx326_pos, 1
    substr rx326_tgt, rx326_tgt, rx326_off
  rx326_start:
    eq $I10, 1, rx326_restart
    if_null rx326_debug, debug_720
    rx326_cur."!cursor_debug"("START", "terminator:sym<}>")
  debug_720:
    $I10 = self.'from'()
    ne $I10, -1, rxscan329_done
    goto rxscan329_scan
  rxscan329_loop:
    (rx326_pos) = rx326_cur."from"()
    inc rx326_pos
    rx326_cur."!cursor_from"(rx326_pos)
    ge rx326_pos, rx326_eos, rxscan329_done
  rxscan329_scan:
    set_addr $I10, rxscan329_loop
    rx326_cur."!mark_push"(0, rx326_pos, $I10)
  rxscan329_done:
.annotate 'line', 195
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx326_pos, rx326_off
    substr $S10, rx326_tgt, $I10, 1
    index $I11, "}", $S10
    lt $I11, 0, rx326_fail
  # rx pass
    rx326_cur."!cursor_pass"(rx326_pos, "terminator:sym<}>")
    if_null rx326_debug, debug_721
    rx326_cur."!cursor_debug"("PASS", "terminator:sym<}>", " at pos=", rx326_pos)
  debug_721:
    .return (rx326_cur)
  rx326_restart:
.annotate 'line', 10
    if_null rx326_debug, debug_722
    rx326_cur."!cursor_debug"("NEXT", "terminator:sym<}>")
  debug_722:
  rx326_fail:
    (rx326_rep, rx326_pos, $I10, $P10) = rx326_cur."!mark_fail"(0)
    lt rx326_pos, -1, rx326_done
    eq rx326_pos, -1, rx326_fail
    jump $I10
  rx326_done:
    rx326_cur."!cursor_fail"()
    if_null rx326_debug, debug_723
    rx326_cur."!cursor_debug"("FAIL", "terminator:sym<}>")
  debug_723:
    .return (rx326_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<}>"  :nsentry("!PREFIX__terminator:sym<}>") :subid("64_1303401201.841") :method
.annotate 'line', 10
    new $P328, "ResizablePMCArray"
    push $P328, "}"
    .return ($P328)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control"  :subid("65_1303401201.841")
    .param pmc param_331
.annotate 'line', 199
    .lex "self", param_331
    $P332 = param_331."!protoregex"("statement_control")
    .return ($P332)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control"  :subid("66_1303401201.841")
    .param pmc param_334
.annotate 'line', 199
    .lex "self", param_334
    $P335 = param_334."!PREFIX__!protoregex"("statement_control")
    .return ($P335)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<use>"  :subid("67_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx337_tgt
    .local int rx337_pos
    .local int rx337_off
    .local int rx337_eos
    .local int rx337_rep
    .local pmc rx337_cur
    .local pmc rx337_debug
    (rx337_cur, rx337_pos, rx337_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx337_cur
    .local pmc match
    .lex "$/", match
    length rx337_eos, rx337_tgt
    gt rx337_pos, rx337_eos, rx337_done
    set rx337_off, 0
    lt rx337_pos, 2, rx337_start
    sub rx337_off, rx337_pos, 1
    substr rx337_tgt, rx337_tgt, rx337_off
  rx337_start:
    eq $I10, 1, rx337_restart
    if_null rx337_debug, debug_724
    rx337_cur."!cursor_debug"("START", "statement_control:sym<use>")
  debug_724:
    $I10 = self.'from'()
    ne $I10, -1, rxscan340_done
    goto rxscan340_scan
  rxscan340_loop:
    (rx337_pos) = rx337_cur."from"()
    inc rx337_pos
    rx337_cur."!cursor_from"(rx337_pos)
    ge rx337_pos, rx337_eos, rxscan340_done
  rxscan340_scan:
    set_addr $I10, rxscan340_loop
    rx337_cur."!mark_push"(0, rx337_pos, $I10)
  rxscan340_done:
.annotate 'line', 202
  # rx subcapture "sym"
    set_addr $I10, rxcap_341_fail
    rx337_cur."!mark_push"(0, rx337_pos, $I10)
  # rx literal  "use"
    add $I11, rx337_pos, 3
    gt $I11, rx337_eos, rx337_fail
    sub $I11, rx337_pos, rx337_off
    substr $S10, rx337_tgt, $I11, 3
    ne $S10, "use", rx337_fail
    add rx337_pos, 3
    set_addr $I10, rxcap_341_fail
    ($I12, $I11) = rx337_cur."!mark_peek"($I10)
    rx337_cur."!cursor_pos"($I11)
    ($P10) = rx337_cur."!cursor_start"()
    $P10."!cursor_pass"(rx337_pos, "")
    rx337_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_341_done
  rxcap_341_fail:
    goto rx337_fail
  rxcap_341_done:
  # rx charclass s
    ge rx337_pos, rx337_eos, rx337_fail
    sub $I10, rx337_pos, rx337_off
    is_cclass $I11, 32, rx337_tgt, $I10
    unless $I11, rx337_fail
    inc rx337_pos
  # rx subrule "ws" subtype=method negate=
    rx337_cur."!cursor_pos"(rx337_pos)
    $P10 = rx337_cur."ws"()
    unless $P10, rx337_fail
    rx337_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx337_cur."!cursor_pos"(rx337_pos)
    $P10 = rx337_cur."name"()
    unless $P10, rx337_fail
    rx337_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx337_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx337_cur."!cursor_pos"(rx337_pos)
    $P10 = rx337_cur."ws"()
    unless $P10, rx337_fail
    rx337_pos = $P10."pos"()
.annotate 'line', 201
  # rx pass
    rx337_cur."!cursor_pass"(rx337_pos, "statement_control:sym<use>")
    if_null rx337_debug, debug_725
    rx337_cur."!cursor_debug"("PASS", "statement_control:sym<use>", " at pos=", rx337_pos)
  debug_725:
    .return (rx337_cur)
  rx337_restart:
.annotate 'line', 10
    if_null rx337_debug, debug_726
    rx337_cur."!cursor_debug"("NEXT", "statement_control:sym<use>")
  debug_726:
  rx337_fail:
    (rx337_rep, rx337_pos, $I10, $P10) = rx337_cur."!mark_fail"(0)
    lt rx337_pos, -1, rx337_done
    eq rx337_pos, -1, rx337_fail
    jump $I10
  rx337_done:
    rx337_cur."!cursor_fail"()
    if_null rx337_debug, debug_727
    rx337_cur."!cursor_debug"("FAIL", "statement_control:sym<use>")
  debug_727:
    .return (rx337_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<use>"  :nsentry("!PREFIX__statement_control:sym<use>") :subid("68_1303401201.841") :method
.annotate 'line', 10
    new $P339, "ResizablePMCArray"
    push $P339, "use"
    .return ($P339)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<if>"  :subid("69_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx345_tgt
    .local int rx345_pos
    .local int rx345_off
    .local int rx345_eos
    .local int rx345_rep
    .local pmc rx345_cur
    .local pmc rx345_debug
    (rx345_cur, rx345_pos, rx345_tgt, $I10) = self."!cursor_start"()
    rx345_cur."!cursor_caparray"("xblock", "else")
    .lex unicode:"$\x{a2}", rx345_cur
    .local pmc match
    .lex "$/", match
    length rx345_eos, rx345_tgt
    gt rx345_pos, rx345_eos, rx345_done
    set rx345_off, 0
    lt rx345_pos, 2, rx345_start
    sub rx345_off, rx345_pos, 1
    substr rx345_tgt, rx345_tgt, rx345_off
  rx345_start:
    eq $I10, 1, rx345_restart
    if_null rx345_debug, debug_728
    rx345_cur."!cursor_debug"("START", "statement_control:sym<if>")
  debug_728:
    $I10 = self.'from'()
    ne $I10, -1, rxscan348_done
    goto rxscan348_scan
  rxscan348_loop:
    (rx345_pos) = rx345_cur."from"()
    inc rx345_pos
    rx345_cur."!cursor_from"(rx345_pos)
    ge rx345_pos, rx345_eos, rxscan348_done
  rxscan348_scan:
    set_addr $I10, rxscan348_loop
    rx345_cur."!mark_push"(0, rx345_pos, $I10)
  rxscan348_done:
.annotate 'line', 206
  # rx subcapture "sym"
    set_addr $I10, rxcap_349_fail
    rx345_cur."!mark_push"(0, rx345_pos, $I10)
  # rx literal  "if"
    add $I11, rx345_pos, 2
    gt $I11, rx345_eos, rx345_fail
    sub $I11, rx345_pos, rx345_off
    substr $S10, rx345_tgt, $I11, 2
    ne $S10, "if", rx345_fail
    add rx345_pos, 2
    set_addr $I10, rxcap_349_fail
    ($I12, $I11) = rx345_cur."!mark_peek"($I10)
    rx345_cur."!cursor_pos"($I11)
    ($P10) = rx345_cur."!cursor_start"()
    $P10."!cursor_pass"(rx345_pos, "")
    rx345_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_349_done
  rxcap_349_fail:
    goto rx345_fail
  rxcap_349_done:
  # rx charclass s
    ge rx345_pos, rx345_eos, rx345_fail
    sub $I10, rx345_pos, rx345_off
    is_cclass $I11, 32, rx345_tgt, $I10
    unless $I11, rx345_fail
    inc rx345_pos
  # rx subrule "ws" subtype=method negate=
    rx345_cur."!cursor_pos"(rx345_pos)
    $P10 = rx345_cur."ws"()
    unless $P10, rx345_fail
    rx345_pos = $P10."pos"()
.annotate 'line', 207
  # rx subrule "xblock" subtype=capture negate=
    rx345_cur."!cursor_pos"(rx345_pos)
    $P10 = rx345_cur."xblock"()
    unless $P10, rx345_fail
    rx345_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx345_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx345_cur."!cursor_pos"(rx345_pos)
    $P10 = rx345_cur."ws"()
    unless $P10, rx345_fail
    rx345_pos = $P10."pos"()
.annotate 'line', 208
  # rx rxquantr352 ** 0..*
    set_addr $I10, rxquantr352_done
    rx345_cur."!mark_push"(0, rx345_pos, $I10)
  rxquantr352_loop:
  # rx subrule "ws" subtype=method negate=
    rx345_cur."!cursor_pos"(rx345_pos)
    $P10 = rx345_cur."ws"()
    unless $P10, rx345_fail
    rx345_pos = $P10."pos"()
  # rx literal  "elsif"
    add $I11, rx345_pos, 5
    gt $I11, rx345_eos, rx345_fail
    sub $I11, rx345_pos, rx345_off
    substr $S10, rx345_tgt, $I11, 5
    ne $S10, "elsif", rx345_fail
    add rx345_pos, 5
  # rx charclass s
    ge rx345_pos, rx345_eos, rx345_fail
    sub $I10, rx345_pos, rx345_off
    is_cclass $I11, 32, rx345_tgt, $I10
    unless $I11, rx345_fail
    inc rx345_pos
  # rx subrule "ws" subtype=method negate=
    rx345_cur."!cursor_pos"(rx345_pos)
    $P10 = rx345_cur."ws"()
    unless $P10, rx345_fail
    rx345_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx345_cur."!cursor_pos"(rx345_pos)
    $P10 = rx345_cur."xblock"()
    unless $P10, rx345_fail
    rx345_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx345_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx345_cur."!cursor_pos"(rx345_pos)
    $P10 = rx345_cur."ws"()
    unless $P10, rx345_fail
    rx345_pos = $P10."pos"()
    set_addr $I10, rxquantr352_done
    (rx345_rep) = rx345_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr352_done
    rx345_cur."!mark_push"(rx345_rep, rx345_pos, $I10)
    goto rxquantr352_loop
  rxquantr352_done:
  # rx subrule "ws" subtype=method negate=
    rx345_cur."!cursor_pos"(rx345_pos)
    $P10 = rx345_cur."ws"()
    unless $P10, rx345_fail
    rx345_pos = $P10."pos"()
.annotate 'line', 209
  # rx rxquantr357 ** 0..1
    set_addr $I10, rxquantr357_done
    rx345_cur."!mark_push"(0, rx345_pos, $I10)
  rxquantr357_loop:
  # rx subrule "ws" subtype=method negate=
    rx345_cur."!cursor_pos"(rx345_pos)
    $P10 = rx345_cur."ws"()
    unless $P10, rx345_fail
    rx345_pos = $P10."pos"()
  # rx literal  "else"
    add $I11, rx345_pos, 4
    gt $I11, rx345_eos, rx345_fail
    sub $I11, rx345_pos, rx345_off
    substr $S10, rx345_tgt, $I11, 4
    ne $S10, "else", rx345_fail
    add rx345_pos, 4
  # rx charclass s
    ge rx345_pos, rx345_eos, rx345_fail
    sub $I10, rx345_pos, rx345_off
    is_cclass $I11, 32, rx345_tgt, $I10
    unless $I11, rx345_fail
    inc rx345_pos
  # rx subrule "ws" subtype=method negate=
    rx345_cur."!cursor_pos"(rx345_pos)
    $P10 = rx345_cur."ws"()
    unless $P10, rx345_fail
    rx345_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx345_cur."!cursor_pos"(rx345_pos)
    $P10 = rx345_cur."pblock"()
    unless $P10, rx345_fail
    rx345_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("else")
    rx345_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx345_cur."!cursor_pos"(rx345_pos)
    $P10 = rx345_cur."ws"()
    unless $P10, rx345_fail
    rx345_pos = $P10."pos"()
    set_addr $I10, rxquantr357_done
    (rx345_rep) = rx345_cur."!mark_commit"($I10)
  rxquantr357_done:
  # rx subrule "ws" subtype=method negate=
    rx345_cur."!cursor_pos"(rx345_pos)
    $P10 = rx345_cur."ws"()
    unless $P10, rx345_fail
    rx345_pos = $P10."pos"()
.annotate 'line', 205
  # rx pass
    rx345_cur."!cursor_pass"(rx345_pos, "statement_control:sym<if>")
    if_null rx345_debug, debug_729
    rx345_cur."!cursor_debug"("PASS", "statement_control:sym<if>", " at pos=", rx345_pos)
  debug_729:
    .return (rx345_cur)
  rx345_restart:
.annotate 'line', 10
    if_null rx345_debug, debug_730
    rx345_cur."!cursor_debug"("NEXT", "statement_control:sym<if>")
  debug_730:
  rx345_fail:
    (rx345_rep, rx345_pos, $I10, $P10) = rx345_cur."!mark_fail"(0)
    lt rx345_pos, -1, rx345_done
    eq rx345_pos, -1, rx345_fail
    jump $I10
  rx345_done:
    rx345_cur."!cursor_fail"()
    if_null rx345_debug, debug_731
    rx345_cur."!cursor_debug"("FAIL", "statement_control:sym<if>")
  debug_731:
    .return (rx345_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<if>"  :nsentry("!PREFIX__statement_control:sym<if>") :subid("70_1303401201.841") :method
.annotate 'line', 10
    new $P347, "ResizablePMCArray"
    push $P347, "if"
    .return ($P347)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<unless>"  :subid("71_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .const 'Sub' $P373 = "73_1303401201.841" 
    capture_lex $P373
    .local string rx363_tgt
    .local int rx363_pos
    .local int rx363_off
    .local int rx363_eos
    .local int rx363_rep
    .local pmc rx363_cur
    .local pmc rx363_debug
    (rx363_cur, rx363_pos, rx363_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx363_cur
    .local pmc match
    .lex "$/", match
    length rx363_eos, rx363_tgt
    gt rx363_pos, rx363_eos, rx363_done
    set rx363_off, 0
    lt rx363_pos, 2, rx363_start
    sub rx363_off, rx363_pos, 1
    substr rx363_tgt, rx363_tgt, rx363_off
  rx363_start:
    eq $I10, 1, rx363_restart
    if_null rx363_debug, debug_732
    rx363_cur."!cursor_debug"("START", "statement_control:sym<unless>")
  debug_732:
    $I10 = self.'from'()
    ne $I10, -1, rxscan366_done
    goto rxscan366_scan
  rxscan366_loop:
    (rx363_pos) = rx363_cur."from"()
    inc rx363_pos
    rx363_cur."!cursor_from"(rx363_pos)
    ge rx363_pos, rx363_eos, rxscan366_done
  rxscan366_scan:
    set_addr $I10, rxscan366_loop
    rx363_cur."!mark_push"(0, rx363_pos, $I10)
  rxscan366_done:
.annotate 'line', 213
  # rx subcapture "sym"
    set_addr $I10, rxcap_367_fail
    rx363_cur."!mark_push"(0, rx363_pos, $I10)
  # rx literal  "unless"
    add $I11, rx363_pos, 6
    gt $I11, rx363_eos, rx363_fail
    sub $I11, rx363_pos, rx363_off
    substr $S10, rx363_tgt, $I11, 6
    ne $S10, "unless", rx363_fail
    add rx363_pos, 6
    set_addr $I10, rxcap_367_fail
    ($I12, $I11) = rx363_cur."!mark_peek"($I10)
    rx363_cur."!cursor_pos"($I11)
    ($P10) = rx363_cur."!cursor_start"()
    $P10."!cursor_pass"(rx363_pos, "")
    rx363_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_367_done
  rxcap_367_fail:
    goto rx363_fail
  rxcap_367_done:
  # rx charclass s
    ge rx363_pos, rx363_eos, rx363_fail
    sub $I10, rx363_pos, rx363_off
    is_cclass $I11, 32, rx363_tgt, $I10
    unless $I11, rx363_fail
    inc rx363_pos
  # rx subrule "ws" subtype=method negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."ws"()
    unless $P10, rx363_fail
    rx363_pos = $P10."pos"()
.annotate 'line', 214
  # rx subrule "xblock" subtype=capture negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."xblock"()
    unless $P10, rx363_fail
    rx363_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx363_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."ws"()
    unless $P10, rx363_fail
    rx363_pos = $P10."pos"()
  alt370_0:
.annotate 'line', 215
    set_addr $I10, alt370_1
    rx363_cur."!mark_push"(0, rx363_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."ws"()
    unless $P10, rx363_fail
    rx363_pos = $P10."pos"()
  # rx subrule "before" subtype=zerowidth negate=1
    rx363_cur."!cursor_pos"(rx363_pos)
    .const 'Sub' $P373 = "73_1303401201.841" 
    capture_lex $P373
    $P10 = rx363_cur."before"($P373)
    if $P10, rx363_fail
  # rx subrule "ws" subtype=method negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."ws"()
    unless $P10, rx363_fail
    rx363_pos = $P10."pos"()
    goto alt370_end
  alt370_1:
  # rx subrule "ws" subtype=method negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."ws"()
    unless $P10, rx363_fail
    rx363_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."panic"("unless does not take \"else\", please rewrite using \"if\"")
    unless $P10, rx363_fail
    rx363_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."ws"()
    unless $P10, rx363_fail
    rx363_pos = $P10."pos"()
  alt370_end:
  # rx subrule "ws" subtype=method negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."ws"()
    unless $P10, rx363_fail
    rx363_pos = $P10."pos"()
.annotate 'line', 212
  # rx pass
    rx363_cur."!cursor_pass"(rx363_pos, "statement_control:sym<unless>")
    if_null rx363_debug, debug_737
    rx363_cur."!cursor_debug"("PASS", "statement_control:sym<unless>", " at pos=", rx363_pos)
  debug_737:
    .return (rx363_cur)
  rx363_restart:
.annotate 'line', 10
    if_null rx363_debug, debug_738
    rx363_cur."!cursor_debug"("NEXT", "statement_control:sym<unless>")
  debug_738:
  rx363_fail:
    (rx363_rep, rx363_pos, $I10, $P10) = rx363_cur."!mark_fail"(0)
    lt rx363_pos, -1, rx363_done
    eq rx363_pos, -1, rx363_fail
    jump $I10
  rx363_done:
    rx363_cur."!cursor_fail"()
    if_null rx363_debug, debug_739
    rx363_cur."!cursor_debug"("FAIL", "statement_control:sym<unless>")
  debug_739:
    .return (rx363_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<unless>"  :nsentry("!PREFIX__statement_control:sym<unless>") :subid("72_1303401201.841") :method
.annotate 'line', 10
    new $P365, "ResizablePMCArray"
    push $P365, "unless"
    .return ($P365)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block372"  :anon :subid("73_1303401201.841") :method :outer("71_1303401201.841")
.annotate 'line', 215
    .local string rx374_tgt
    .local int rx374_pos
    .local int rx374_off
    .local int rx374_eos
    .local int rx374_rep
    .local pmc rx374_cur
    .local pmc rx374_debug
    (rx374_cur, rx374_pos, rx374_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx374_cur
    .local pmc match
    .lex "$/", match
    length rx374_eos, rx374_tgt
    gt rx374_pos, rx374_eos, rx374_done
    set rx374_off, 0
    lt rx374_pos, 2, rx374_start
    sub rx374_off, rx374_pos, 1
    substr rx374_tgt, rx374_tgt, rx374_off
  rx374_start:
    eq $I10, 1, rx374_restart
    if_null rx374_debug, debug_733
    rx374_cur."!cursor_debug"("START", "")
  debug_733:
    $I10 = self.'from'()
    ne $I10, -1, rxscan375_done
    goto rxscan375_scan
  rxscan375_loop:
    (rx374_pos) = rx374_cur."from"()
    inc rx374_pos
    rx374_cur."!cursor_from"(rx374_pos)
    ge rx374_pos, rx374_eos, rxscan375_done
  rxscan375_scan:
    set_addr $I10, rxscan375_loop
    rx374_cur."!mark_push"(0, rx374_pos, $I10)
  rxscan375_done:
  # rx literal  "else"
    add $I11, rx374_pos, 4
    gt $I11, rx374_eos, rx374_fail
    sub $I11, rx374_pos, rx374_off
    substr $S10, rx374_tgt, $I11, 4
    ne $S10, "else", rx374_fail
    add rx374_pos, 4
  # rx pass
    rx374_cur."!cursor_pass"(rx374_pos, "")
    if_null rx374_debug, debug_734
    rx374_cur."!cursor_debug"("PASS", "", " at pos=", rx374_pos)
  debug_734:
    .return (rx374_cur)
  rx374_restart:
    if_null rx374_debug, debug_735
    rx374_cur."!cursor_debug"("NEXT", "")
  debug_735:
  rx374_fail:
    (rx374_rep, rx374_pos, $I10, $P10) = rx374_cur."!mark_fail"(0)
    lt rx374_pos, -1, rx374_done
    eq rx374_pos, -1, rx374_fail
    jump $I10
  rx374_done:
    rx374_cur."!cursor_fail"()
    if_null rx374_debug, debug_736
    rx374_cur."!cursor_debug"("FAIL", "")
  debug_736:
    .return (rx374_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<while>"  :subid("74_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx381_tgt
    .local int rx381_pos
    .local int rx381_off
    .local int rx381_eos
    .local int rx381_rep
    .local pmc rx381_cur
    .local pmc rx381_debug
    (rx381_cur, rx381_pos, rx381_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx381_cur
    .local pmc match
    .lex "$/", match
    length rx381_eos, rx381_tgt
    gt rx381_pos, rx381_eos, rx381_done
    set rx381_off, 0
    lt rx381_pos, 2, rx381_start
    sub rx381_off, rx381_pos, 1
    substr rx381_tgt, rx381_tgt, rx381_off
  rx381_start:
    eq $I10, 1, rx381_restart
    if_null rx381_debug, debug_740
    rx381_cur."!cursor_debug"("START", "statement_control:sym<while>")
  debug_740:
    $I10 = self.'from'()
    ne $I10, -1, rxscan384_done
    goto rxscan384_scan
  rxscan384_loop:
    (rx381_pos) = rx381_cur."from"()
    inc rx381_pos
    rx381_cur."!cursor_from"(rx381_pos)
    ge rx381_pos, rx381_eos, rxscan384_done
  rxscan384_scan:
    set_addr $I10, rxscan384_loop
    rx381_cur."!mark_push"(0, rx381_pos, $I10)
  rxscan384_done:
.annotate 'line', 219
  # rx subcapture "sym"
    set_addr $I10, rxcap_386_fail
    rx381_cur."!mark_push"(0, rx381_pos, $I10)
  alt385_0:
    set_addr $I10, alt385_1
    rx381_cur."!mark_push"(0, rx381_pos, $I10)
  # rx literal  "while"
    add $I11, rx381_pos, 5
    gt $I11, rx381_eos, rx381_fail
    sub $I11, rx381_pos, rx381_off
    substr $S10, rx381_tgt, $I11, 5
    ne $S10, "while", rx381_fail
    add rx381_pos, 5
    goto alt385_end
  alt385_1:
  # rx literal  "until"
    add $I11, rx381_pos, 5
    gt $I11, rx381_eos, rx381_fail
    sub $I11, rx381_pos, rx381_off
    substr $S10, rx381_tgt, $I11, 5
    ne $S10, "until", rx381_fail
    add rx381_pos, 5
  alt385_end:
    set_addr $I10, rxcap_386_fail
    ($I12, $I11) = rx381_cur."!mark_peek"($I10)
    rx381_cur."!cursor_pos"($I11)
    ($P10) = rx381_cur."!cursor_start"()
    $P10."!cursor_pass"(rx381_pos, "")
    rx381_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_386_done
  rxcap_386_fail:
    goto rx381_fail
  rxcap_386_done:
  # rx charclass s
    ge rx381_pos, rx381_eos, rx381_fail
    sub $I10, rx381_pos, rx381_off
    is_cclass $I11, 32, rx381_tgt, $I10
    unless $I11, rx381_fail
    inc rx381_pos
  # rx subrule "ws" subtype=method negate=
    rx381_cur."!cursor_pos"(rx381_pos)
    $P10 = rx381_cur."ws"()
    unless $P10, rx381_fail
    rx381_pos = $P10."pos"()
.annotate 'line', 220
  # rx subrule "xblock" subtype=capture negate=
    rx381_cur."!cursor_pos"(rx381_pos)
    $P10 = rx381_cur."xblock"()
    unless $P10, rx381_fail
    rx381_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx381_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx381_cur."!cursor_pos"(rx381_pos)
    $P10 = rx381_cur."ws"()
    unless $P10, rx381_fail
    rx381_pos = $P10."pos"()
.annotate 'line', 218
  # rx pass
    rx381_cur."!cursor_pass"(rx381_pos, "statement_control:sym<while>")
    if_null rx381_debug, debug_741
    rx381_cur."!cursor_debug"("PASS", "statement_control:sym<while>", " at pos=", rx381_pos)
  debug_741:
    .return (rx381_cur)
  rx381_restart:
.annotate 'line', 10
    if_null rx381_debug, debug_742
    rx381_cur."!cursor_debug"("NEXT", "statement_control:sym<while>")
  debug_742:
  rx381_fail:
    (rx381_rep, rx381_pos, $I10, $P10) = rx381_cur."!mark_fail"(0)
    lt rx381_pos, -1, rx381_done
    eq rx381_pos, -1, rx381_fail
    jump $I10
  rx381_done:
    rx381_cur."!cursor_fail"()
    if_null rx381_debug, debug_743
    rx381_cur."!cursor_debug"("FAIL", "statement_control:sym<while>")
  debug_743:
    .return (rx381_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<while>"  :nsentry("!PREFIX__statement_control:sym<while>") :subid("75_1303401201.841") :method
.annotate 'line', 10
    new $P383, "ResizablePMCArray"
    push $P383, "until"
    push $P383, "while"
    .return ($P383)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<repeat>"  :subid("76_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx390_tgt
    .local int rx390_pos
    .local int rx390_off
    .local int rx390_eos
    .local int rx390_rep
    .local pmc rx390_cur
    .local pmc rx390_debug
    (rx390_cur, rx390_pos, rx390_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx390_cur
    .local pmc match
    .lex "$/", match
    length rx390_eos, rx390_tgt
    gt rx390_pos, rx390_eos, rx390_done
    set rx390_off, 0
    lt rx390_pos, 2, rx390_start
    sub rx390_off, rx390_pos, 1
    substr rx390_tgt, rx390_tgt, rx390_off
  rx390_start:
    eq $I10, 1, rx390_restart
    if_null rx390_debug, debug_744
    rx390_cur."!cursor_debug"("START", "statement_control:sym<repeat>")
  debug_744:
    $I10 = self.'from'()
    ne $I10, -1, rxscan393_done
    goto rxscan393_scan
  rxscan393_loop:
    (rx390_pos) = rx390_cur."from"()
    inc rx390_pos
    rx390_cur."!cursor_from"(rx390_pos)
    ge rx390_pos, rx390_eos, rxscan393_done
  rxscan393_scan:
    set_addr $I10, rxscan393_loop
    rx390_cur."!mark_push"(0, rx390_pos, $I10)
  rxscan393_done:
.annotate 'line', 224
  # rx subcapture "sym"
    set_addr $I10, rxcap_394_fail
    rx390_cur."!mark_push"(0, rx390_pos, $I10)
  # rx literal  "repeat"
    add $I11, rx390_pos, 6
    gt $I11, rx390_eos, rx390_fail
    sub $I11, rx390_pos, rx390_off
    substr $S10, rx390_tgt, $I11, 6
    ne $S10, "repeat", rx390_fail
    add rx390_pos, 6
    set_addr $I10, rxcap_394_fail
    ($I12, $I11) = rx390_cur."!mark_peek"($I10)
    rx390_cur."!cursor_pos"($I11)
    ($P10) = rx390_cur."!cursor_start"()
    $P10."!cursor_pass"(rx390_pos, "")
    rx390_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_394_done
  rxcap_394_fail:
    goto rx390_fail
  rxcap_394_done:
  # rx charclass s
    ge rx390_pos, rx390_eos, rx390_fail
    sub $I10, rx390_pos, rx390_off
    is_cclass $I11, 32, rx390_tgt, $I10
    unless $I11, rx390_fail
    inc rx390_pos
  # rx subrule "ws" subtype=method negate=
    rx390_cur."!cursor_pos"(rx390_pos)
    $P10 = rx390_cur."ws"()
    unless $P10, rx390_fail
    rx390_pos = $P10."pos"()
  alt396_0:
.annotate 'line', 225
    set_addr $I10, alt396_1
    rx390_cur."!mark_push"(0, rx390_pos, $I10)
.annotate 'line', 226
  # rx subrule "ws" subtype=method negate=
    rx390_cur."!cursor_pos"(rx390_pos)
    $P10 = rx390_cur."ws"()
    unless $P10, rx390_fail
    rx390_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_399_fail
    rx390_cur."!mark_push"(0, rx390_pos, $I10)
  alt398_0:
    set_addr $I10, alt398_1
    rx390_cur."!mark_push"(0, rx390_pos, $I10)
  # rx literal  "while"
    add $I11, rx390_pos, 5
    gt $I11, rx390_eos, rx390_fail
    sub $I11, rx390_pos, rx390_off
    substr $S10, rx390_tgt, $I11, 5
    ne $S10, "while", rx390_fail
    add rx390_pos, 5
    goto alt398_end
  alt398_1:
  # rx literal  "until"
    add $I11, rx390_pos, 5
    gt $I11, rx390_eos, rx390_fail
    sub $I11, rx390_pos, rx390_off
    substr $S10, rx390_tgt, $I11, 5
    ne $S10, "until", rx390_fail
    add rx390_pos, 5
  alt398_end:
    set_addr $I10, rxcap_399_fail
    ($I12, $I11) = rx390_cur."!mark_peek"($I10)
    rx390_cur."!cursor_pos"($I11)
    ($P10) = rx390_cur."!cursor_start"()
    $P10."!cursor_pass"(rx390_pos, "")
    rx390_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_399_done
  rxcap_399_fail:
    goto rx390_fail
  rxcap_399_done:
  # rx charclass s
    ge rx390_pos, rx390_eos, rx390_fail
    sub $I10, rx390_pos, rx390_off
    is_cclass $I11, 32, rx390_tgt, $I10
    unless $I11, rx390_fail
    inc rx390_pos
  # rx subrule "ws" subtype=method negate=
    rx390_cur."!cursor_pos"(rx390_pos)
    $P10 = rx390_cur."ws"()
    unless $P10, rx390_fail
    rx390_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx390_cur."!cursor_pos"(rx390_pos)
    $P10 = rx390_cur."xblock"()
    unless $P10, rx390_fail
    rx390_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx390_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx390_cur."!cursor_pos"(rx390_pos)
    $P10 = rx390_cur."ws"()
    unless $P10, rx390_fail
    rx390_pos = $P10."pos"()
    goto alt396_end
  alt396_1:
.annotate 'line', 227
  # rx subrule "ws" subtype=method negate=
    rx390_cur."!cursor_pos"(rx390_pos)
    $P10 = rx390_cur."ws"()
    unless $P10, rx390_fail
    rx390_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx390_cur."!cursor_pos"(rx390_pos)
    $P10 = rx390_cur."pblock"()
    unless $P10, rx390_fail
    rx390_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx390_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx390_cur."!cursor_pos"(rx390_pos)
    $P10 = rx390_cur."ws"()
    unless $P10, rx390_fail
    rx390_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_405_fail
    rx390_cur."!mark_push"(0, rx390_pos, $I10)
  alt404_0:
    set_addr $I10, alt404_1
    rx390_cur."!mark_push"(0, rx390_pos, $I10)
  # rx literal  "while"
    add $I11, rx390_pos, 5
    gt $I11, rx390_eos, rx390_fail
    sub $I11, rx390_pos, rx390_off
    substr $S10, rx390_tgt, $I11, 5
    ne $S10, "while", rx390_fail
    add rx390_pos, 5
    goto alt404_end
  alt404_1:
  # rx literal  "until"
    add $I11, rx390_pos, 5
    gt $I11, rx390_eos, rx390_fail
    sub $I11, rx390_pos, rx390_off
    substr $S10, rx390_tgt, $I11, 5
    ne $S10, "until", rx390_fail
    add rx390_pos, 5
  alt404_end:
    set_addr $I10, rxcap_405_fail
    ($I12, $I11) = rx390_cur."!mark_peek"($I10)
    rx390_cur."!cursor_pos"($I11)
    ($P10) = rx390_cur."!cursor_start"()
    $P10."!cursor_pass"(rx390_pos, "")
    rx390_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_405_done
  rxcap_405_fail:
    goto rx390_fail
  rxcap_405_done:
  # rx charclass s
    ge rx390_pos, rx390_eos, rx390_fail
    sub $I10, rx390_pos, rx390_off
    is_cclass $I11, 32, rx390_tgt, $I10
    unless $I11, rx390_fail
    inc rx390_pos
  # rx subrule "ws" subtype=method negate=
    rx390_cur."!cursor_pos"(rx390_pos)
    $P10 = rx390_cur."ws"()
    unless $P10, rx390_fail
    rx390_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx390_cur."!cursor_pos"(rx390_pos)
    $P10 = rx390_cur."EXPR"()
    unless $P10, rx390_fail
    rx390_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx390_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx390_cur."!cursor_pos"(rx390_pos)
    $P10 = rx390_cur."ws"()
    unless $P10, rx390_fail
    rx390_pos = $P10."pos"()
  alt396_end:
.annotate 'line', 228
  # rx subrule "ws" subtype=method negate=
    rx390_cur."!cursor_pos"(rx390_pos)
    $P10 = rx390_cur."ws"()
    unless $P10, rx390_fail
    rx390_pos = $P10."pos"()
.annotate 'line', 223
  # rx pass
    rx390_cur."!cursor_pass"(rx390_pos, "statement_control:sym<repeat>")
    if_null rx390_debug, debug_745
    rx390_cur."!cursor_debug"("PASS", "statement_control:sym<repeat>", " at pos=", rx390_pos)
  debug_745:
    .return (rx390_cur)
  rx390_restart:
.annotate 'line', 10
    if_null rx390_debug, debug_746
    rx390_cur."!cursor_debug"("NEXT", "statement_control:sym<repeat>")
  debug_746:
  rx390_fail:
    (rx390_rep, rx390_pos, $I10, $P10) = rx390_cur."!mark_fail"(0)
    lt rx390_pos, -1, rx390_done
    eq rx390_pos, -1, rx390_fail
    jump $I10
  rx390_done:
    rx390_cur."!cursor_fail"()
    if_null rx390_debug, debug_747
    rx390_cur."!cursor_debug"("FAIL", "statement_control:sym<repeat>")
  debug_747:
    .return (rx390_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<repeat>"  :nsentry("!PREFIX__statement_control:sym<repeat>") :subid("77_1303401201.841") :method
.annotate 'line', 10
    new $P392, "ResizablePMCArray"
    push $P392, "repeat"
    .return ($P392)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<for>"  :subid("78_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx410_tgt
    .local int rx410_pos
    .local int rx410_off
    .local int rx410_eos
    .local int rx410_rep
    .local pmc rx410_cur
    .local pmc rx410_debug
    (rx410_cur, rx410_pos, rx410_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx410_cur
    .local pmc match
    .lex "$/", match
    length rx410_eos, rx410_tgt
    gt rx410_pos, rx410_eos, rx410_done
    set rx410_off, 0
    lt rx410_pos, 2, rx410_start
    sub rx410_off, rx410_pos, 1
    substr rx410_tgt, rx410_tgt, rx410_off
  rx410_start:
    eq $I10, 1, rx410_restart
    if_null rx410_debug, debug_748
    rx410_cur."!cursor_debug"("START", "statement_control:sym<for>")
  debug_748:
    $I10 = self.'from'()
    ne $I10, -1, rxscan413_done
    goto rxscan413_scan
  rxscan413_loop:
    (rx410_pos) = rx410_cur."from"()
    inc rx410_pos
    rx410_cur."!cursor_from"(rx410_pos)
    ge rx410_pos, rx410_eos, rxscan413_done
  rxscan413_scan:
    set_addr $I10, rxscan413_loop
    rx410_cur."!mark_push"(0, rx410_pos, $I10)
  rxscan413_done:
.annotate 'line', 232
  # rx subcapture "sym"
    set_addr $I10, rxcap_414_fail
    rx410_cur."!mark_push"(0, rx410_pos, $I10)
  # rx literal  "for"
    add $I11, rx410_pos, 3
    gt $I11, rx410_eos, rx410_fail
    sub $I11, rx410_pos, rx410_off
    substr $S10, rx410_tgt, $I11, 3
    ne $S10, "for", rx410_fail
    add rx410_pos, 3
    set_addr $I10, rxcap_414_fail
    ($I12, $I11) = rx410_cur."!mark_peek"($I10)
    rx410_cur."!cursor_pos"($I11)
    ($P10) = rx410_cur."!cursor_start"()
    $P10."!cursor_pass"(rx410_pos, "")
    rx410_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_414_done
  rxcap_414_fail:
    goto rx410_fail
  rxcap_414_done:
  # rx charclass s
    ge rx410_pos, rx410_eos, rx410_fail
    sub $I10, rx410_pos, rx410_off
    is_cclass $I11, 32, rx410_tgt, $I10
    unless $I11, rx410_fail
    inc rx410_pos
  # rx subrule "ws" subtype=method negate=
    rx410_cur."!cursor_pos"(rx410_pos)
    $P10 = rx410_cur."ws"()
    unless $P10, rx410_fail
    rx410_pos = $P10."pos"()
.annotate 'line', 233
  # rx subrule "xblock" subtype=capture negate=
    rx410_cur."!cursor_pos"(rx410_pos)
    $P10 = rx410_cur."xblock"()
    unless $P10, rx410_fail
    rx410_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx410_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx410_cur."!cursor_pos"(rx410_pos)
    $P10 = rx410_cur."ws"()
    unless $P10, rx410_fail
    rx410_pos = $P10."pos"()
.annotate 'line', 231
  # rx pass
    rx410_cur."!cursor_pass"(rx410_pos, "statement_control:sym<for>")
    if_null rx410_debug, debug_749
    rx410_cur."!cursor_debug"("PASS", "statement_control:sym<for>", " at pos=", rx410_pos)
  debug_749:
    .return (rx410_cur)
  rx410_restart:
.annotate 'line', 10
    if_null rx410_debug, debug_750
    rx410_cur."!cursor_debug"("NEXT", "statement_control:sym<for>")
  debug_750:
  rx410_fail:
    (rx410_rep, rx410_pos, $I10, $P10) = rx410_cur."!mark_fail"(0)
    lt rx410_pos, -1, rx410_done
    eq rx410_pos, -1, rx410_fail
    jump $I10
  rx410_done:
    rx410_cur."!cursor_fail"()
    if_null rx410_debug, debug_751
    rx410_cur."!cursor_debug"("FAIL", "statement_control:sym<for>")
  debug_751:
    .return (rx410_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<for>"  :nsentry("!PREFIX__statement_control:sym<for>") :subid("79_1303401201.841") :method
.annotate 'line', 10
    new $P412, "ResizablePMCArray"
    push $P412, "for"
    .return ($P412)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CATCH>"  :subid("80_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx418_tgt
    .local int rx418_pos
    .local int rx418_off
    .local int rx418_eos
    .local int rx418_rep
    .local pmc rx418_cur
    .local pmc rx418_debug
    (rx418_cur, rx418_pos, rx418_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx418_cur
    .local pmc match
    .lex "$/", match
    length rx418_eos, rx418_tgt
    gt rx418_pos, rx418_eos, rx418_done
    set rx418_off, 0
    lt rx418_pos, 2, rx418_start
    sub rx418_off, rx418_pos, 1
    substr rx418_tgt, rx418_tgt, rx418_off
  rx418_start:
    eq $I10, 1, rx418_restart
    if_null rx418_debug, debug_752
    rx418_cur."!cursor_debug"("START", "statement_control:sym<CATCH>")
  debug_752:
    $I10 = self.'from'()
    ne $I10, -1, rxscan421_done
    goto rxscan421_scan
  rxscan421_loop:
    (rx418_pos) = rx418_cur."from"()
    inc rx418_pos
    rx418_cur."!cursor_from"(rx418_pos)
    ge rx418_pos, rx418_eos, rxscan421_done
  rxscan421_scan:
    set_addr $I10, rxscan421_loop
    rx418_cur."!mark_push"(0, rx418_pos, $I10)
  rxscan421_done:
.annotate 'line', 237
  # rx subcapture "sym"
    set_addr $I10, rxcap_422_fail
    rx418_cur."!mark_push"(0, rx418_pos, $I10)
  # rx literal  "CATCH"
    add $I11, rx418_pos, 5
    gt $I11, rx418_eos, rx418_fail
    sub $I11, rx418_pos, rx418_off
    substr $S10, rx418_tgt, $I11, 5
    ne $S10, "CATCH", rx418_fail
    add rx418_pos, 5
    set_addr $I10, rxcap_422_fail
    ($I12, $I11) = rx418_cur."!mark_peek"($I10)
    rx418_cur."!cursor_pos"($I11)
    ($P10) = rx418_cur."!cursor_start"()
    $P10."!cursor_pass"(rx418_pos, "")
    rx418_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_422_done
  rxcap_422_fail:
    goto rx418_fail
  rxcap_422_done:
  # rx charclass s
    ge rx418_pos, rx418_eos, rx418_fail
    sub $I10, rx418_pos, rx418_off
    is_cclass $I11, 32, rx418_tgt, $I10
    unless $I11, rx418_fail
    inc rx418_pos
  # rx subrule "ws" subtype=method negate=
    rx418_cur."!cursor_pos"(rx418_pos)
    $P10 = rx418_cur."ws"()
    unless $P10, rx418_fail
    rx418_pos = $P10."pos"()
.annotate 'line', 238
  # rx subrule "block" subtype=capture negate=
    rx418_cur."!cursor_pos"(rx418_pos)
    $P10 = rx418_cur."block"()
    unless $P10, rx418_fail
    rx418_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx418_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx418_cur."!cursor_pos"(rx418_pos)
    $P10 = rx418_cur."ws"()
    unless $P10, rx418_fail
    rx418_pos = $P10."pos"()
.annotate 'line', 236
  # rx pass
    rx418_cur."!cursor_pass"(rx418_pos, "statement_control:sym<CATCH>")
    if_null rx418_debug, debug_753
    rx418_cur."!cursor_debug"("PASS", "statement_control:sym<CATCH>", " at pos=", rx418_pos)
  debug_753:
    .return (rx418_cur)
  rx418_restart:
.annotate 'line', 10
    if_null rx418_debug, debug_754
    rx418_cur."!cursor_debug"("NEXT", "statement_control:sym<CATCH>")
  debug_754:
  rx418_fail:
    (rx418_rep, rx418_pos, $I10, $P10) = rx418_cur."!mark_fail"(0)
    lt rx418_pos, -1, rx418_done
    eq rx418_pos, -1, rx418_fail
    jump $I10
  rx418_done:
    rx418_cur."!cursor_fail"()
    if_null rx418_debug, debug_755
    rx418_cur."!cursor_debug"("FAIL", "statement_control:sym<CATCH>")
  debug_755:
    .return (rx418_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CATCH>"  :nsentry("!PREFIX__statement_control:sym<CATCH>") :subid("81_1303401201.841") :method
.annotate 'line', 10
    new $P420, "ResizablePMCArray"
    push $P420, "CATCH"
    .return ($P420)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CONTROL>"  :subid("82_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx426_tgt
    .local int rx426_pos
    .local int rx426_off
    .local int rx426_eos
    .local int rx426_rep
    .local pmc rx426_cur
    .local pmc rx426_debug
    (rx426_cur, rx426_pos, rx426_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx426_cur
    .local pmc match
    .lex "$/", match
    length rx426_eos, rx426_tgt
    gt rx426_pos, rx426_eos, rx426_done
    set rx426_off, 0
    lt rx426_pos, 2, rx426_start
    sub rx426_off, rx426_pos, 1
    substr rx426_tgt, rx426_tgt, rx426_off
  rx426_start:
    eq $I10, 1, rx426_restart
    if_null rx426_debug, debug_756
    rx426_cur."!cursor_debug"("START", "statement_control:sym<CONTROL>")
  debug_756:
    $I10 = self.'from'()
    ne $I10, -1, rxscan429_done
    goto rxscan429_scan
  rxscan429_loop:
    (rx426_pos) = rx426_cur."from"()
    inc rx426_pos
    rx426_cur."!cursor_from"(rx426_pos)
    ge rx426_pos, rx426_eos, rxscan429_done
  rxscan429_scan:
    set_addr $I10, rxscan429_loop
    rx426_cur."!mark_push"(0, rx426_pos, $I10)
  rxscan429_done:
.annotate 'line', 242
  # rx subcapture "sym"
    set_addr $I10, rxcap_430_fail
    rx426_cur."!mark_push"(0, rx426_pos, $I10)
  # rx literal  "CONTROL"
    add $I11, rx426_pos, 7
    gt $I11, rx426_eos, rx426_fail
    sub $I11, rx426_pos, rx426_off
    substr $S10, rx426_tgt, $I11, 7
    ne $S10, "CONTROL", rx426_fail
    add rx426_pos, 7
    set_addr $I10, rxcap_430_fail
    ($I12, $I11) = rx426_cur."!mark_peek"($I10)
    rx426_cur."!cursor_pos"($I11)
    ($P10) = rx426_cur."!cursor_start"()
    $P10."!cursor_pass"(rx426_pos, "")
    rx426_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_430_done
  rxcap_430_fail:
    goto rx426_fail
  rxcap_430_done:
  # rx charclass s
    ge rx426_pos, rx426_eos, rx426_fail
    sub $I10, rx426_pos, rx426_off
    is_cclass $I11, 32, rx426_tgt, $I10
    unless $I11, rx426_fail
    inc rx426_pos
  # rx subrule "ws" subtype=method negate=
    rx426_cur."!cursor_pos"(rx426_pos)
    $P10 = rx426_cur."ws"()
    unless $P10, rx426_fail
    rx426_pos = $P10."pos"()
.annotate 'line', 243
  # rx subrule "block" subtype=capture negate=
    rx426_cur."!cursor_pos"(rx426_pos)
    $P10 = rx426_cur."block"()
    unless $P10, rx426_fail
    rx426_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx426_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx426_cur."!cursor_pos"(rx426_pos)
    $P10 = rx426_cur."ws"()
    unless $P10, rx426_fail
    rx426_pos = $P10."pos"()
.annotate 'line', 241
  # rx pass
    rx426_cur."!cursor_pass"(rx426_pos, "statement_control:sym<CONTROL>")
    if_null rx426_debug, debug_757
    rx426_cur."!cursor_debug"("PASS", "statement_control:sym<CONTROL>", " at pos=", rx426_pos)
  debug_757:
    .return (rx426_cur)
  rx426_restart:
.annotate 'line', 10
    if_null rx426_debug, debug_758
    rx426_cur."!cursor_debug"("NEXT", "statement_control:sym<CONTROL>")
  debug_758:
  rx426_fail:
    (rx426_rep, rx426_pos, $I10, $P10) = rx426_cur."!mark_fail"(0)
    lt rx426_pos, -1, rx426_done
    eq rx426_pos, -1, rx426_fail
    jump $I10
  rx426_done:
    rx426_cur."!cursor_fail"()
    if_null rx426_debug, debug_759
    rx426_cur."!cursor_debug"("FAIL", "statement_control:sym<CONTROL>")
  debug_759:
    .return (rx426_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CONTROL>"  :nsentry("!PREFIX__statement_control:sym<CONTROL>") :subid("83_1303401201.841") :method
.annotate 'line', 10
    new $P428, "ResizablePMCArray"
    push $P428, "CONTROL"
    .return ($P428)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix"  :subid("84_1303401201.841")
    .param pmc param_434
.annotate 'line', 246
    .lex "self", param_434
    $P435 = param_434."!protoregex"("statement_prefix")
    .return ($P435)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix"  :subid("85_1303401201.841")
    .param pmc param_437
.annotate 'line', 246
    .lex "self", param_437
    $P438 = param_437."!PREFIX__!protoregex"("statement_prefix")
    .return ($P438)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<INIT>"  :subid("86_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx440_tgt
    .local int rx440_pos
    .local int rx440_off
    .local int rx440_eos
    .local int rx440_rep
    .local pmc rx440_cur
    .local pmc rx440_debug
    (rx440_cur, rx440_pos, rx440_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx440_cur
    .local pmc match
    .lex "$/", match
    length rx440_eos, rx440_tgt
    gt rx440_pos, rx440_eos, rx440_done
    set rx440_off, 0
    lt rx440_pos, 2, rx440_start
    sub rx440_off, rx440_pos, 1
    substr rx440_tgt, rx440_tgt, rx440_off
  rx440_start:
    eq $I10, 1, rx440_restart
    if_null rx440_debug, debug_760
    rx440_cur."!cursor_debug"("START", "statement_prefix:sym<INIT>")
  debug_760:
    $I10 = self.'from'()
    ne $I10, -1, rxscan444_done
    goto rxscan444_scan
  rxscan444_loop:
    (rx440_pos) = rx440_cur."from"()
    inc rx440_pos
    rx440_cur."!cursor_from"(rx440_pos)
    ge rx440_pos, rx440_eos, rxscan444_done
  rxscan444_scan:
    set_addr $I10, rxscan444_loop
    rx440_cur."!mark_push"(0, rx440_pos, $I10)
  rxscan444_done:
.annotate 'line', 247
  # rx subcapture "sym"
    set_addr $I10, rxcap_445_fail
    rx440_cur."!mark_push"(0, rx440_pos, $I10)
  # rx literal  "INIT"
    add $I11, rx440_pos, 4
    gt $I11, rx440_eos, rx440_fail
    sub $I11, rx440_pos, rx440_off
    substr $S10, rx440_tgt, $I11, 4
    ne $S10, "INIT", rx440_fail
    add rx440_pos, 4
    set_addr $I10, rxcap_445_fail
    ($I12, $I11) = rx440_cur."!mark_peek"($I10)
    rx440_cur."!cursor_pos"($I11)
    ($P10) = rx440_cur."!cursor_start"()
    $P10."!cursor_pass"(rx440_pos, "")
    rx440_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_445_done
  rxcap_445_fail:
    goto rx440_fail
  rxcap_445_done:
  # rx subrule "blorst" subtype=capture negate=
    rx440_cur."!cursor_pos"(rx440_pos)
    $P10 = rx440_cur."blorst"()
    unless $P10, rx440_fail
    rx440_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx440_pos = $P10."pos"()
  # rx pass
    rx440_cur."!cursor_pass"(rx440_pos, "statement_prefix:sym<INIT>")
    if_null rx440_debug, debug_761
    rx440_cur."!cursor_debug"("PASS", "statement_prefix:sym<INIT>", " at pos=", rx440_pos)
  debug_761:
    .return (rx440_cur)
  rx440_restart:
.annotate 'line', 10
    if_null rx440_debug, debug_762
    rx440_cur."!cursor_debug"("NEXT", "statement_prefix:sym<INIT>")
  debug_762:
  rx440_fail:
    (rx440_rep, rx440_pos, $I10, $P10) = rx440_cur."!mark_fail"(0)
    lt rx440_pos, -1, rx440_done
    eq rx440_pos, -1, rx440_fail
    jump $I10
  rx440_done:
    rx440_cur."!cursor_fail"()
    if_null rx440_debug, debug_763
    rx440_cur."!cursor_debug"("FAIL", "statement_prefix:sym<INIT>")
  debug_763:
    .return (rx440_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<INIT>"  :nsentry("!PREFIX__statement_prefix:sym<INIT>") :subid("87_1303401201.841") :method
.annotate 'line', 10
    $P442 = self."!PREFIX__!subrule"("blorst", "INIT")
    new $P443, "ResizablePMCArray"
    push $P443, $P442
    .return ($P443)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<try>"  :subid("88_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx447_tgt
    .local int rx447_pos
    .local int rx447_off
    .local int rx447_eos
    .local int rx447_rep
    .local pmc rx447_cur
    .local pmc rx447_debug
    (rx447_cur, rx447_pos, rx447_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx447_cur
    .local pmc match
    .lex "$/", match
    length rx447_eos, rx447_tgt
    gt rx447_pos, rx447_eos, rx447_done
    set rx447_off, 0
    lt rx447_pos, 2, rx447_start
    sub rx447_off, rx447_pos, 1
    substr rx447_tgt, rx447_tgt, rx447_off
  rx447_start:
    eq $I10, 1, rx447_restart
    if_null rx447_debug, debug_764
    rx447_cur."!cursor_debug"("START", "statement_prefix:sym<try>")
  debug_764:
    $I10 = self.'from'()
    ne $I10, -1, rxscan451_done
    goto rxscan451_scan
  rxscan451_loop:
    (rx447_pos) = rx447_cur."from"()
    inc rx447_pos
    rx447_cur."!cursor_from"(rx447_pos)
    ge rx447_pos, rx447_eos, rxscan451_done
  rxscan451_scan:
    set_addr $I10, rxscan451_loop
    rx447_cur."!mark_push"(0, rx447_pos, $I10)
  rxscan451_done:
.annotate 'line', 250
  # rx subcapture "sym"
    set_addr $I10, rxcap_452_fail
    rx447_cur."!mark_push"(0, rx447_pos, $I10)
  # rx literal  "try"
    add $I11, rx447_pos, 3
    gt $I11, rx447_eos, rx447_fail
    sub $I11, rx447_pos, rx447_off
    substr $S10, rx447_tgt, $I11, 3
    ne $S10, "try", rx447_fail
    add rx447_pos, 3
    set_addr $I10, rxcap_452_fail
    ($I12, $I11) = rx447_cur."!mark_peek"($I10)
    rx447_cur."!cursor_pos"($I11)
    ($P10) = rx447_cur."!cursor_start"()
    $P10."!cursor_pass"(rx447_pos, "")
    rx447_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_452_done
  rxcap_452_fail:
    goto rx447_fail
  rxcap_452_done:
.annotate 'line', 251
  # rx subrule "blorst" subtype=capture negate=
    rx447_cur."!cursor_pos"(rx447_pos)
    $P10 = rx447_cur."blorst"()
    unless $P10, rx447_fail
    rx447_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx447_pos = $P10."pos"()
.annotate 'line', 249
  # rx pass
    rx447_cur."!cursor_pass"(rx447_pos, "statement_prefix:sym<try>")
    if_null rx447_debug, debug_765
    rx447_cur."!cursor_debug"("PASS", "statement_prefix:sym<try>", " at pos=", rx447_pos)
  debug_765:
    .return (rx447_cur)
  rx447_restart:
.annotate 'line', 10
    if_null rx447_debug, debug_766
    rx447_cur."!cursor_debug"("NEXT", "statement_prefix:sym<try>")
  debug_766:
  rx447_fail:
    (rx447_rep, rx447_pos, $I10, $P10) = rx447_cur."!mark_fail"(0)
    lt rx447_pos, -1, rx447_done
    eq rx447_pos, -1, rx447_fail
    jump $I10
  rx447_done:
    rx447_cur."!cursor_fail"()
    if_null rx447_debug, debug_767
    rx447_cur."!cursor_debug"("FAIL", "statement_prefix:sym<try>")
  debug_767:
    .return (rx447_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<try>"  :nsentry("!PREFIX__statement_prefix:sym<try>") :subid("89_1303401201.841") :method
.annotate 'line', 10
    $P449 = self."!PREFIX__!subrule"("blorst", "try")
    new $P450, "ResizablePMCArray"
    push $P450, $P449
    .return ($P450)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blorst"  :subid("90_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx454_tgt
    .local int rx454_pos
    .local int rx454_off
    .local int rx454_eos
    .local int rx454_rep
    .local pmc rx454_cur
    .local pmc rx454_debug
    (rx454_cur, rx454_pos, rx454_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx454_cur
    .local pmc match
    .lex "$/", match
    length rx454_eos, rx454_tgt
    gt rx454_pos, rx454_eos, rx454_done
    set rx454_off, 0
    lt rx454_pos, 2, rx454_start
    sub rx454_off, rx454_pos, 1
    substr rx454_tgt, rx454_tgt, rx454_off
  rx454_start:
    eq $I10, 1, rx454_restart
    if_null rx454_debug, debug_768
    rx454_cur."!cursor_debug"("START", "blorst")
  debug_768:
    $I10 = self.'from'()
    ne $I10, -1, rxscan457_done
    goto rxscan457_scan
  rxscan457_loop:
    (rx454_pos) = rx454_cur."from"()
    inc rx454_pos
    rx454_cur."!cursor_from"(rx454_pos)
    ge rx454_pos, rx454_eos, rxscan457_done
  rxscan457_scan:
    set_addr $I10, rxscan457_loop
    rx454_cur."!mark_push"(0, rx454_pos, $I10)
  rxscan457_done:
.annotate 'line', 255
  # rx charclass s
    ge rx454_pos, rx454_eos, rx454_fail
    sub $I10, rx454_pos, rx454_off
    is_cclass $I11, 32, rx454_tgt, $I10
    unless $I11, rx454_fail
    inc rx454_pos
  # rx subrule "ws" subtype=method negate=
    rx454_cur."!cursor_pos"(rx454_pos)
    $P10 = rx454_cur."ws"()
    unless $P10, rx454_fail
    rx454_pos = $P10."pos"()
  alt458_0:
    set_addr $I10, alt458_1
    rx454_cur."!mark_push"(0, rx454_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx454_pos, rx454_off
    substr $S10, rx454_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx454_fail
  # rx subrule "block" subtype=capture negate=
    rx454_cur."!cursor_pos"(rx454_pos)
    $P10 = rx454_cur."block"()
    unless $P10, rx454_fail
    rx454_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx454_pos = $P10."pos"()
    goto alt458_end
  alt458_1:
  # rx subrule "statement" subtype=capture negate=
    rx454_cur."!cursor_pos"(rx454_pos)
    $P10 = rx454_cur."statement"()
    unless $P10, rx454_fail
    rx454_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx454_pos = $P10."pos"()
  alt458_end:
.annotate 'line', 254
  # rx pass
    rx454_cur."!cursor_pass"(rx454_pos, "blorst")
    if_null rx454_debug, debug_769
    rx454_cur."!cursor_debug"("PASS", "blorst", " at pos=", rx454_pos)
  debug_769:
    .return (rx454_cur)
  rx454_restart:
.annotate 'line', 10
    if_null rx454_debug, debug_770
    rx454_cur."!cursor_debug"("NEXT", "blorst")
  debug_770:
  rx454_fail:
    (rx454_rep, rx454_pos, $I10, $P10) = rx454_cur."!mark_fail"(0)
    lt rx454_pos, -1, rx454_done
    eq rx454_pos, -1, rx454_fail
    jump $I10
  rx454_done:
    rx454_cur."!cursor_fail"()
    if_null rx454_debug, debug_771
    rx454_cur."!cursor_debug"("FAIL", "blorst")
  debug_771:
    .return (rx454_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blorst"  :nsentry("!PREFIX__blorst") :subid("91_1303401201.841") :method
.annotate 'line', 10
    new $P456, "ResizablePMCArray"
    push $P456, ""
    .return ($P456)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond"  :subid("92_1303401201.841")
    .param pmc param_460
.annotate 'line', 260
    .lex "self", param_460
    $P461 = param_460."!protoregex"("statement_mod_cond")
    .return ($P461)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond"  :subid("93_1303401201.841")
    .param pmc param_463
.annotate 'line', 260
    .lex "self", param_463
    $P464 = param_463."!PREFIX__!protoregex"("statement_mod_cond")
    .return ($P464)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<if>"  :subid("94_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx466_tgt
    .local int rx466_pos
    .local int rx466_off
    .local int rx466_eos
    .local int rx466_rep
    .local pmc rx466_cur
    .local pmc rx466_debug
    (rx466_cur, rx466_pos, rx466_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx466_cur
    .local pmc match
    .lex "$/", match
    length rx466_eos, rx466_tgt
    gt rx466_pos, rx466_eos, rx466_done
    set rx466_off, 0
    lt rx466_pos, 2, rx466_start
    sub rx466_off, rx466_pos, 1
    substr rx466_tgt, rx466_tgt, rx466_off
  rx466_start:
    eq $I10, 1, rx466_restart
    if_null rx466_debug, debug_772
    rx466_cur."!cursor_debug"("START", "statement_mod_cond:sym<if>")
  debug_772:
    $I10 = self.'from'()
    ne $I10, -1, rxscan470_done
    goto rxscan470_scan
  rxscan470_loop:
    (rx466_pos) = rx466_cur."from"()
    inc rx466_pos
    rx466_cur."!cursor_from"(rx466_pos)
    ge rx466_pos, rx466_eos, rxscan470_done
  rxscan470_scan:
    set_addr $I10, rxscan470_loop
    rx466_cur."!mark_push"(0, rx466_pos, $I10)
  rxscan470_done:
.annotate 'line', 262
  # rx subcapture "sym"
    set_addr $I10, rxcap_471_fail
    rx466_cur."!mark_push"(0, rx466_pos, $I10)
  # rx literal  "if"
    add $I11, rx466_pos, 2
    gt $I11, rx466_eos, rx466_fail
    sub $I11, rx466_pos, rx466_off
    substr $S10, rx466_tgt, $I11, 2
    ne $S10, "if", rx466_fail
    add rx466_pos, 2
    set_addr $I10, rxcap_471_fail
    ($I12, $I11) = rx466_cur."!mark_peek"($I10)
    rx466_cur."!cursor_pos"($I11)
    ($P10) = rx466_cur."!cursor_start"()
    $P10."!cursor_pass"(rx466_pos, "")
    rx466_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_471_done
  rxcap_471_fail:
    goto rx466_fail
  rxcap_471_done:
  # rx subrule "ws" subtype=method negate=
    rx466_cur."!cursor_pos"(rx466_pos)
    $P10 = rx466_cur."ws"()
    unless $P10, rx466_fail
    rx466_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx466_cur."!cursor_pos"(rx466_pos)
    $P10 = rx466_cur."EXPR"()
    unless $P10, rx466_fail
    rx466_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx466_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx466_cur."!cursor_pos"(rx466_pos)
    $P10 = rx466_cur."ws"()
    unless $P10, rx466_fail
    rx466_pos = $P10."pos"()
  # rx pass
    rx466_cur."!cursor_pass"(rx466_pos, "statement_mod_cond:sym<if>")
    if_null rx466_debug, debug_773
    rx466_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<if>", " at pos=", rx466_pos)
  debug_773:
    .return (rx466_cur)
  rx466_restart:
.annotate 'line', 10
    if_null rx466_debug, debug_774
    rx466_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<if>")
  debug_774:
  rx466_fail:
    (rx466_rep, rx466_pos, $I10, $P10) = rx466_cur."!mark_fail"(0)
    lt rx466_pos, -1, rx466_done
    eq rx466_pos, -1, rx466_fail
    jump $I10
  rx466_done:
    rx466_cur."!cursor_fail"()
    if_null rx466_debug, debug_775
    rx466_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<if>")
  debug_775:
    .return (rx466_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<if>"  :nsentry("!PREFIX__statement_mod_cond:sym<if>") :subid("95_1303401201.841") :method
.annotate 'line', 10
    $P468 = self."!PREFIX__!subrule"("ws", "if")
    new $P469, "ResizablePMCArray"
    push $P469, $P468
    .return ($P469)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<unless>"  :subid("96_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx475_tgt
    .local int rx475_pos
    .local int rx475_off
    .local int rx475_eos
    .local int rx475_rep
    .local pmc rx475_cur
    .local pmc rx475_debug
    (rx475_cur, rx475_pos, rx475_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx475_cur
    .local pmc match
    .lex "$/", match
    length rx475_eos, rx475_tgt
    gt rx475_pos, rx475_eos, rx475_done
    set rx475_off, 0
    lt rx475_pos, 2, rx475_start
    sub rx475_off, rx475_pos, 1
    substr rx475_tgt, rx475_tgt, rx475_off
  rx475_start:
    eq $I10, 1, rx475_restart
    if_null rx475_debug, debug_776
    rx475_cur."!cursor_debug"("START", "statement_mod_cond:sym<unless>")
  debug_776:
    $I10 = self.'from'()
    ne $I10, -1, rxscan479_done
    goto rxscan479_scan
  rxscan479_loop:
    (rx475_pos) = rx475_cur."from"()
    inc rx475_pos
    rx475_cur."!cursor_from"(rx475_pos)
    ge rx475_pos, rx475_eos, rxscan479_done
  rxscan479_scan:
    set_addr $I10, rxscan479_loop
    rx475_cur."!mark_push"(0, rx475_pos, $I10)
  rxscan479_done:
.annotate 'line', 263
  # rx subcapture "sym"
    set_addr $I10, rxcap_480_fail
    rx475_cur."!mark_push"(0, rx475_pos, $I10)
  # rx literal  "unless"
    add $I11, rx475_pos, 6
    gt $I11, rx475_eos, rx475_fail
    sub $I11, rx475_pos, rx475_off
    substr $S10, rx475_tgt, $I11, 6
    ne $S10, "unless", rx475_fail
    add rx475_pos, 6
    set_addr $I10, rxcap_480_fail
    ($I12, $I11) = rx475_cur."!mark_peek"($I10)
    rx475_cur."!cursor_pos"($I11)
    ($P10) = rx475_cur."!cursor_start"()
    $P10."!cursor_pass"(rx475_pos, "")
    rx475_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_480_done
  rxcap_480_fail:
    goto rx475_fail
  rxcap_480_done:
  # rx subrule "ws" subtype=method negate=
    rx475_cur."!cursor_pos"(rx475_pos)
    $P10 = rx475_cur."ws"()
    unless $P10, rx475_fail
    rx475_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx475_cur."!cursor_pos"(rx475_pos)
    $P10 = rx475_cur."EXPR"()
    unless $P10, rx475_fail
    rx475_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx475_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx475_cur."!cursor_pos"(rx475_pos)
    $P10 = rx475_cur."ws"()
    unless $P10, rx475_fail
    rx475_pos = $P10."pos"()
  # rx pass
    rx475_cur."!cursor_pass"(rx475_pos, "statement_mod_cond:sym<unless>")
    if_null rx475_debug, debug_777
    rx475_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<unless>", " at pos=", rx475_pos)
  debug_777:
    .return (rx475_cur)
  rx475_restart:
.annotate 'line', 10
    if_null rx475_debug, debug_778
    rx475_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<unless>")
  debug_778:
  rx475_fail:
    (rx475_rep, rx475_pos, $I10, $P10) = rx475_cur."!mark_fail"(0)
    lt rx475_pos, -1, rx475_done
    eq rx475_pos, -1, rx475_fail
    jump $I10
  rx475_done:
    rx475_cur."!cursor_fail"()
    if_null rx475_debug, debug_779
    rx475_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<unless>")
  debug_779:
    .return (rx475_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<unless>"  :nsentry("!PREFIX__statement_mod_cond:sym<unless>") :subid("97_1303401201.841") :method
.annotate 'line', 10
    $P477 = self."!PREFIX__!subrule"("ws", "unless")
    new $P478, "ResizablePMCArray"
    push $P478, $P477
    .return ($P478)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop"  :subid("98_1303401201.841")
    .param pmc param_484
.annotate 'line', 265
    .lex "self", param_484
    $P485 = param_484."!protoregex"("statement_mod_loop")
    .return ($P485)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop"  :subid("99_1303401201.841")
    .param pmc param_487
.annotate 'line', 265
    .lex "self", param_487
    $P488 = param_487."!PREFIX__!protoregex"("statement_mod_loop")
    .return ($P488)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<while>"  :subid("100_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx490_tgt
    .local int rx490_pos
    .local int rx490_off
    .local int rx490_eos
    .local int rx490_rep
    .local pmc rx490_cur
    .local pmc rx490_debug
    (rx490_cur, rx490_pos, rx490_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx490_cur
    .local pmc match
    .lex "$/", match
    length rx490_eos, rx490_tgt
    gt rx490_pos, rx490_eos, rx490_done
    set rx490_off, 0
    lt rx490_pos, 2, rx490_start
    sub rx490_off, rx490_pos, 1
    substr rx490_tgt, rx490_tgt, rx490_off
  rx490_start:
    eq $I10, 1, rx490_restart
    if_null rx490_debug, debug_780
    rx490_cur."!cursor_debug"("START", "statement_mod_loop:sym<while>")
  debug_780:
    $I10 = self.'from'()
    ne $I10, -1, rxscan494_done
    goto rxscan494_scan
  rxscan494_loop:
    (rx490_pos) = rx490_cur."from"()
    inc rx490_pos
    rx490_cur."!cursor_from"(rx490_pos)
    ge rx490_pos, rx490_eos, rxscan494_done
  rxscan494_scan:
    set_addr $I10, rxscan494_loop
    rx490_cur."!mark_push"(0, rx490_pos, $I10)
  rxscan494_done:
.annotate 'line', 267
  # rx subcapture "sym"
    set_addr $I10, rxcap_495_fail
    rx490_cur."!mark_push"(0, rx490_pos, $I10)
  # rx literal  "while"
    add $I11, rx490_pos, 5
    gt $I11, rx490_eos, rx490_fail
    sub $I11, rx490_pos, rx490_off
    substr $S10, rx490_tgt, $I11, 5
    ne $S10, "while", rx490_fail
    add rx490_pos, 5
    set_addr $I10, rxcap_495_fail
    ($I12, $I11) = rx490_cur."!mark_peek"($I10)
    rx490_cur."!cursor_pos"($I11)
    ($P10) = rx490_cur."!cursor_start"()
    $P10."!cursor_pass"(rx490_pos, "")
    rx490_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_495_done
  rxcap_495_fail:
    goto rx490_fail
  rxcap_495_done:
  # rx subrule "ws" subtype=method negate=
    rx490_cur."!cursor_pos"(rx490_pos)
    $P10 = rx490_cur."ws"()
    unless $P10, rx490_fail
    rx490_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx490_cur."!cursor_pos"(rx490_pos)
    $P10 = rx490_cur."EXPR"()
    unless $P10, rx490_fail
    rx490_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx490_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx490_cur."!cursor_pos"(rx490_pos)
    $P10 = rx490_cur."ws"()
    unless $P10, rx490_fail
    rx490_pos = $P10."pos"()
  # rx pass
    rx490_cur."!cursor_pass"(rx490_pos, "statement_mod_loop:sym<while>")
    if_null rx490_debug, debug_781
    rx490_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<while>", " at pos=", rx490_pos)
  debug_781:
    .return (rx490_cur)
  rx490_restart:
.annotate 'line', 10
    if_null rx490_debug, debug_782
    rx490_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<while>")
  debug_782:
  rx490_fail:
    (rx490_rep, rx490_pos, $I10, $P10) = rx490_cur."!mark_fail"(0)
    lt rx490_pos, -1, rx490_done
    eq rx490_pos, -1, rx490_fail
    jump $I10
  rx490_done:
    rx490_cur."!cursor_fail"()
    if_null rx490_debug, debug_783
    rx490_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<while>")
  debug_783:
    .return (rx490_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<while>"  :nsentry("!PREFIX__statement_mod_loop:sym<while>") :subid("101_1303401201.841") :method
.annotate 'line', 10
    $P492 = self."!PREFIX__!subrule"("ws", "while")
    new $P493, "ResizablePMCArray"
    push $P493, $P492
    .return ($P493)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<until>"  :subid("102_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx499_tgt
    .local int rx499_pos
    .local int rx499_off
    .local int rx499_eos
    .local int rx499_rep
    .local pmc rx499_cur
    .local pmc rx499_debug
    (rx499_cur, rx499_pos, rx499_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx499_cur
    .local pmc match
    .lex "$/", match
    length rx499_eos, rx499_tgt
    gt rx499_pos, rx499_eos, rx499_done
    set rx499_off, 0
    lt rx499_pos, 2, rx499_start
    sub rx499_off, rx499_pos, 1
    substr rx499_tgt, rx499_tgt, rx499_off
  rx499_start:
    eq $I10, 1, rx499_restart
    if_null rx499_debug, debug_784
    rx499_cur."!cursor_debug"("START", "statement_mod_loop:sym<until>")
  debug_784:
    $I10 = self.'from'()
    ne $I10, -1, rxscan503_done
    goto rxscan503_scan
  rxscan503_loop:
    (rx499_pos) = rx499_cur."from"()
    inc rx499_pos
    rx499_cur."!cursor_from"(rx499_pos)
    ge rx499_pos, rx499_eos, rxscan503_done
  rxscan503_scan:
    set_addr $I10, rxscan503_loop
    rx499_cur."!mark_push"(0, rx499_pos, $I10)
  rxscan503_done:
.annotate 'line', 268
  # rx subcapture "sym"
    set_addr $I10, rxcap_504_fail
    rx499_cur."!mark_push"(0, rx499_pos, $I10)
  # rx literal  "until"
    add $I11, rx499_pos, 5
    gt $I11, rx499_eos, rx499_fail
    sub $I11, rx499_pos, rx499_off
    substr $S10, rx499_tgt, $I11, 5
    ne $S10, "until", rx499_fail
    add rx499_pos, 5
    set_addr $I10, rxcap_504_fail
    ($I12, $I11) = rx499_cur."!mark_peek"($I10)
    rx499_cur."!cursor_pos"($I11)
    ($P10) = rx499_cur."!cursor_start"()
    $P10."!cursor_pass"(rx499_pos, "")
    rx499_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_504_done
  rxcap_504_fail:
    goto rx499_fail
  rxcap_504_done:
  # rx subrule "ws" subtype=method negate=
    rx499_cur."!cursor_pos"(rx499_pos)
    $P10 = rx499_cur."ws"()
    unless $P10, rx499_fail
    rx499_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx499_cur."!cursor_pos"(rx499_pos)
    $P10 = rx499_cur."EXPR"()
    unless $P10, rx499_fail
    rx499_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx499_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx499_cur."!cursor_pos"(rx499_pos)
    $P10 = rx499_cur."ws"()
    unless $P10, rx499_fail
    rx499_pos = $P10."pos"()
  # rx pass
    rx499_cur."!cursor_pass"(rx499_pos, "statement_mod_loop:sym<until>")
    if_null rx499_debug, debug_785
    rx499_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<until>", " at pos=", rx499_pos)
  debug_785:
    .return (rx499_cur)
  rx499_restart:
.annotate 'line', 10
    if_null rx499_debug, debug_786
    rx499_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<until>")
  debug_786:
  rx499_fail:
    (rx499_rep, rx499_pos, $I10, $P10) = rx499_cur."!mark_fail"(0)
    lt rx499_pos, -1, rx499_done
    eq rx499_pos, -1, rx499_fail
    jump $I10
  rx499_done:
    rx499_cur."!cursor_fail"()
    if_null rx499_debug, debug_787
    rx499_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<until>")
  debug_787:
    .return (rx499_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<until>"  :nsentry("!PREFIX__statement_mod_loop:sym<until>") :subid("103_1303401201.841") :method
.annotate 'line', 10
    $P501 = self."!PREFIX__!subrule"("ws", "until")
    new $P502, "ResizablePMCArray"
    push $P502, $P501
    .return ($P502)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<for>"  :subid("104_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx508_tgt
    .local int rx508_pos
    .local int rx508_off
    .local int rx508_eos
    .local int rx508_rep
    .local pmc rx508_cur
    .local pmc rx508_debug
    (rx508_cur, rx508_pos, rx508_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx508_cur
    .local pmc match
    .lex "$/", match
    length rx508_eos, rx508_tgt
    gt rx508_pos, rx508_eos, rx508_done
    set rx508_off, 0
    lt rx508_pos, 2, rx508_start
    sub rx508_off, rx508_pos, 1
    substr rx508_tgt, rx508_tgt, rx508_off
  rx508_start:
    eq $I10, 1, rx508_restart
    if_null rx508_debug, debug_788
    rx508_cur."!cursor_debug"("START", "statement_mod_loop:sym<for>")
  debug_788:
    $I10 = self.'from'()
    ne $I10, -1, rxscan512_done
    goto rxscan512_scan
  rxscan512_loop:
    (rx508_pos) = rx508_cur."from"()
    inc rx508_pos
    rx508_cur."!cursor_from"(rx508_pos)
    ge rx508_pos, rx508_eos, rxscan512_done
  rxscan512_scan:
    set_addr $I10, rxscan512_loop
    rx508_cur."!mark_push"(0, rx508_pos, $I10)
  rxscan512_done:
.annotate 'line', 269
  # rx subcapture "sym"
    set_addr $I10, rxcap_513_fail
    rx508_cur."!mark_push"(0, rx508_pos, $I10)
  # rx literal  "for"
    add $I11, rx508_pos, 3
    gt $I11, rx508_eos, rx508_fail
    sub $I11, rx508_pos, rx508_off
    substr $S10, rx508_tgt, $I11, 3
    ne $S10, "for", rx508_fail
    add rx508_pos, 3
    set_addr $I10, rxcap_513_fail
    ($I12, $I11) = rx508_cur."!mark_peek"($I10)
    rx508_cur."!cursor_pos"($I11)
    ($P10) = rx508_cur."!cursor_start"()
    $P10."!cursor_pass"(rx508_pos, "")
    rx508_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_513_done
  rxcap_513_fail:
    goto rx508_fail
  rxcap_513_done:
  # rx subrule "ws" subtype=method negate=
    rx508_cur."!cursor_pos"(rx508_pos)
    $P10 = rx508_cur."ws"()
    unless $P10, rx508_fail
    rx508_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx508_cur."!cursor_pos"(rx508_pos)
    $P10 = rx508_cur."EXPR"()
    unless $P10, rx508_fail
    rx508_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx508_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx508_cur."!cursor_pos"(rx508_pos)
    $P10 = rx508_cur."ws"()
    unless $P10, rx508_fail
    rx508_pos = $P10."pos"()
  # rx pass
    rx508_cur."!cursor_pass"(rx508_pos, "statement_mod_loop:sym<for>")
    if_null rx508_debug, debug_789
    rx508_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<for>", " at pos=", rx508_pos)
  debug_789:
    .return (rx508_cur)
  rx508_restart:
.annotate 'line', 10
    if_null rx508_debug, debug_790
    rx508_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<for>")
  debug_790:
  rx508_fail:
    (rx508_rep, rx508_pos, $I10, $P10) = rx508_cur."!mark_fail"(0)
    lt rx508_pos, -1, rx508_done
    eq rx508_pos, -1, rx508_fail
    jump $I10
  rx508_done:
    rx508_cur."!cursor_fail"()
    if_null rx508_debug, debug_791
    rx508_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<for>")
  debug_791:
    .return (rx508_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<for>"  :nsentry("!PREFIX__statement_mod_loop:sym<for>") :subid("105_1303401201.841") :method
.annotate 'line', 10
    $P510 = self."!PREFIX__!subrule"("ws", "for")
    new $P511, "ResizablePMCArray"
    push $P511, $P510
    .return ($P511)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<fatarrow>"  :subid("106_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx517_tgt
    .local int rx517_pos
    .local int rx517_off
    .local int rx517_eos
    .local int rx517_rep
    .local pmc rx517_cur
    .local pmc rx517_debug
    (rx517_cur, rx517_pos, rx517_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx517_cur
    .local pmc match
    .lex "$/", match
    length rx517_eos, rx517_tgt
    gt rx517_pos, rx517_eos, rx517_done
    set rx517_off, 0
    lt rx517_pos, 2, rx517_start
    sub rx517_off, rx517_pos, 1
    substr rx517_tgt, rx517_tgt, rx517_off
  rx517_start:
    eq $I10, 1, rx517_restart
    if_null rx517_debug, debug_792
    rx517_cur."!cursor_debug"("START", "term:sym<fatarrow>")
  debug_792:
    $I10 = self.'from'()
    ne $I10, -1, rxscan521_done
    goto rxscan521_scan
  rxscan521_loop:
    (rx517_pos) = rx517_cur."from"()
    inc rx517_pos
    rx517_cur."!cursor_from"(rx517_pos)
    ge rx517_pos, rx517_eos, rxscan521_done
  rxscan521_scan:
    set_addr $I10, rxscan521_loop
    rx517_cur."!mark_push"(0, rx517_pos, $I10)
  rxscan521_done:
.annotate 'line', 273
  # rx subrule "fatarrow" subtype=capture negate=
    rx517_cur."!cursor_pos"(rx517_pos)
    $P10 = rx517_cur."fatarrow"()
    unless $P10, rx517_fail
    rx517_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("fatarrow")
    rx517_pos = $P10."pos"()
  # rx pass
    rx517_cur."!cursor_pass"(rx517_pos, "term:sym<fatarrow>")
    if_null rx517_debug, debug_793
    rx517_cur."!cursor_debug"("PASS", "term:sym<fatarrow>", " at pos=", rx517_pos)
  debug_793:
    .return (rx517_cur)
  rx517_restart:
.annotate 'line', 10
    if_null rx517_debug, debug_794
    rx517_cur."!cursor_debug"("NEXT", "term:sym<fatarrow>")
  debug_794:
  rx517_fail:
    (rx517_rep, rx517_pos, $I10, $P10) = rx517_cur."!mark_fail"(0)
    lt rx517_pos, -1, rx517_done
    eq rx517_pos, -1, rx517_fail
    jump $I10
  rx517_done:
    rx517_cur."!cursor_fail"()
    if_null rx517_debug, debug_795
    rx517_cur."!cursor_debug"("FAIL", "term:sym<fatarrow>")
  debug_795:
    .return (rx517_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<fatarrow>"  :nsentry("!PREFIX__term:sym<fatarrow>") :subid("107_1303401201.841") :method
.annotate 'line', 10
    $P519 = self."!PREFIX__!subrule"("fatarrow", "")
    new $P520, "ResizablePMCArray"
    push $P520, $P519
    .return ($P520)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<colonpair>"  :subid("108_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx523_tgt
    .local int rx523_pos
    .local int rx523_off
    .local int rx523_eos
    .local int rx523_rep
    .local pmc rx523_cur
    .local pmc rx523_debug
    (rx523_cur, rx523_pos, rx523_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx523_cur
    .local pmc match
    .lex "$/", match
    length rx523_eos, rx523_tgt
    gt rx523_pos, rx523_eos, rx523_done
    set rx523_off, 0
    lt rx523_pos, 2, rx523_start
    sub rx523_off, rx523_pos, 1
    substr rx523_tgt, rx523_tgt, rx523_off
  rx523_start:
    eq $I10, 1, rx523_restart
    if_null rx523_debug, debug_796
    rx523_cur."!cursor_debug"("START", "term:sym<colonpair>")
  debug_796:
    $I10 = self.'from'()
    ne $I10, -1, rxscan527_done
    goto rxscan527_scan
  rxscan527_loop:
    (rx523_pos) = rx523_cur."from"()
    inc rx523_pos
    rx523_cur."!cursor_from"(rx523_pos)
    ge rx523_pos, rx523_eos, rxscan527_done
  rxscan527_scan:
    set_addr $I10, rxscan527_loop
    rx523_cur."!mark_push"(0, rx523_pos, $I10)
  rxscan527_done:
.annotate 'line', 274
  # rx subrule "colonpair" subtype=capture negate=
    rx523_cur."!cursor_pos"(rx523_pos)
    $P10 = rx523_cur."colonpair"()
    unless $P10, rx523_fail
    rx523_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("colonpair")
    rx523_pos = $P10."pos"()
  # rx pass
    rx523_cur."!cursor_pass"(rx523_pos, "term:sym<colonpair>")
    if_null rx523_debug, debug_797
    rx523_cur."!cursor_debug"("PASS", "term:sym<colonpair>", " at pos=", rx523_pos)
  debug_797:
    .return (rx523_cur)
  rx523_restart:
.annotate 'line', 10
    if_null rx523_debug, debug_798
    rx523_cur."!cursor_debug"("NEXT", "term:sym<colonpair>")
  debug_798:
  rx523_fail:
    (rx523_rep, rx523_pos, $I10, $P10) = rx523_cur."!mark_fail"(0)
    lt rx523_pos, -1, rx523_done
    eq rx523_pos, -1, rx523_fail
    jump $I10
  rx523_done:
    rx523_cur."!cursor_fail"()
    if_null rx523_debug, debug_799
    rx523_cur."!cursor_debug"("FAIL", "term:sym<colonpair>")
  debug_799:
    .return (rx523_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<colonpair>"  :nsentry("!PREFIX__term:sym<colonpair>") :subid("109_1303401201.841") :method
.annotate 'line', 10
    $P525 = self."!PREFIX__!subrule"("colonpair", "")
    new $P526, "ResizablePMCArray"
    push $P526, $P525
    .return ($P526)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<variable>"  :subid("110_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx529_tgt
    .local int rx529_pos
    .local int rx529_off
    .local int rx529_eos
    .local int rx529_rep
    .local pmc rx529_cur
    .local pmc rx529_debug
    (rx529_cur, rx529_pos, rx529_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx529_cur
    .local pmc match
    .lex "$/", match
    length rx529_eos, rx529_tgt
    gt rx529_pos, rx529_eos, rx529_done
    set rx529_off, 0
    lt rx529_pos, 2, rx529_start
    sub rx529_off, rx529_pos, 1
    substr rx529_tgt, rx529_tgt, rx529_off
  rx529_start:
    eq $I10, 1, rx529_restart
    if_null rx529_debug, debug_800
    rx529_cur."!cursor_debug"("START", "term:sym<variable>")
  debug_800:
    $I10 = self.'from'()
    ne $I10, -1, rxscan533_done
    goto rxscan533_scan
  rxscan533_loop:
    (rx529_pos) = rx529_cur."from"()
    inc rx529_pos
    rx529_cur."!cursor_from"(rx529_pos)
    ge rx529_pos, rx529_eos, rxscan533_done
  rxscan533_scan:
    set_addr $I10, rxscan533_loop
    rx529_cur."!mark_push"(0, rx529_pos, $I10)
  rxscan533_done:
.annotate 'line', 275
  # rx subrule "variable" subtype=capture negate=
    rx529_cur."!cursor_pos"(rx529_pos)
    $P10 = rx529_cur."variable"()
    unless $P10, rx529_fail
    rx529_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx529_pos = $P10."pos"()
  # rx pass
    rx529_cur."!cursor_pass"(rx529_pos, "term:sym<variable>")
    if_null rx529_debug, debug_801
    rx529_cur."!cursor_debug"("PASS", "term:sym<variable>", " at pos=", rx529_pos)
  debug_801:
    .return (rx529_cur)
  rx529_restart:
.annotate 'line', 10
    if_null rx529_debug, debug_802
    rx529_cur."!cursor_debug"("NEXT", "term:sym<variable>")
  debug_802:
  rx529_fail:
    (rx529_rep, rx529_pos, $I10, $P10) = rx529_cur."!mark_fail"(0)
    lt rx529_pos, -1, rx529_done
    eq rx529_pos, -1, rx529_fail
    jump $I10
  rx529_done:
    rx529_cur."!cursor_fail"()
    if_null rx529_debug, debug_803
    rx529_cur."!cursor_debug"("FAIL", "term:sym<variable>")
  debug_803:
    .return (rx529_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<variable>"  :nsentry("!PREFIX__term:sym<variable>") :subid("111_1303401201.841") :method
.annotate 'line', 10
    $P531 = self."!PREFIX__!subrule"("variable", "")
    new $P532, "ResizablePMCArray"
    push $P532, $P531
    .return ($P532)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<package_declarator>"  :subid("112_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx535_tgt
    .local int rx535_pos
    .local int rx535_off
    .local int rx535_eos
    .local int rx535_rep
    .local pmc rx535_cur
    .local pmc rx535_debug
    (rx535_cur, rx535_pos, rx535_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx535_cur
    .local pmc match
    .lex "$/", match
    length rx535_eos, rx535_tgt
    gt rx535_pos, rx535_eos, rx535_done
    set rx535_off, 0
    lt rx535_pos, 2, rx535_start
    sub rx535_off, rx535_pos, 1
    substr rx535_tgt, rx535_tgt, rx535_off
  rx535_start:
    eq $I10, 1, rx535_restart
    if_null rx535_debug, debug_804
    rx535_cur."!cursor_debug"("START", "term:sym<package_declarator>")
  debug_804:
    $I10 = self.'from'()
    ne $I10, -1, rxscan539_done
    goto rxscan539_scan
  rxscan539_loop:
    (rx535_pos) = rx535_cur."from"()
    inc rx535_pos
    rx535_cur."!cursor_from"(rx535_pos)
    ge rx535_pos, rx535_eos, rxscan539_done
  rxscan539_scan:
    set_addr $I10, rxscan539_loop
    rx535_cur."!mark_push"(0, rx535_pos, $I10)
  rxscan539_done:
.annotate 'line', 276
  # rx subrule "package_declarator" subtype=capture negate=
    rx535_cur."!cursor_pos"(rx535_pos)
    $P10 = rx535_cur."package_declarator"()
    unless $P10, rx535_fail
    rx535_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx535_pos = $P10."pos"()
  # rx pass
    rx535_cur."!cursor_pass"(rx535_pos, "term:sym<package_declarator>")
    if_null rx535_debug, debug_805
    rx535_cur."!cursor_debug"("PASS", "term:sym<package_declarator>", " at pos=", rx535_pos)
  debug_805:
    .return (rx535_cur)
  rx535_restart:
.annotate 'line', 10
    if_null rx535_debug, debug_806
    rx535_cur."!cursor_debug"("NEXT", "term:sym<package_declarator>")
  debug_806:
  rx535_fail:
    (rx535_rep, rx535_pos, $I10, $P10) = rx535_cur."!mark_fail"(0)
    lt rx535_pos, -1, rx535_done
    eq rx535_pos, -1, rx535_fail
    jump $I10
  rx535_done:
    rx535_cur."!cursor_fail"()
    if_null rx535_debug, debug_807
    rx535_cur."!cursor_debug"("FAIL", "term:sym<package_declarator>")
  debug_807:
    .return (rx535_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<package_declarator>"  :nsentry("!PREFIX__term:sym<package_declarator>") :subid("113_1303401201.841") :method
.annotate 'line', 10
    $P537 = self."!PREFIX__!subrule"("package_declarator", "")
    new $P538, "ResizablePMCArray"
    push $P538, $P537
    .return ($P538)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<scope_declarator>"  :subid("114_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx541_tgt
    .local int rx541_pos
    .local int rx541_off
    .local int rx541_eos
    .local int rx541_rep
    .local pmc rx541_cur
    .local pmc rx541_debug
    (rx541_cur, rx541_pos, rx541_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx541_cur
    .local pmc match
    .lex "$/", match
    length rx541_eos, rx541_tgt
    gt rx541_pos, rx541_eos, rx541_done
    set rx541_off, 0
    lt rx541_pos, 2, rx541_start
    sub rx541_off, rx541_pos, 1
    substr rx541_tgt, rx541_tgt, rx541_off
  rx541_start:
    eq $I10, 1, rx541_restart
    if_null rx541_debug, debug_808
    rx541_cur."!cursor_debug"("START", "term:sym<scope_declarator>")
  debug_808:
    $I10 = self.'from'()
    ne $I10, -1, rxscan545_done
    goto rxscan545_scan
  rxscan545_loop:
    (rx541_pos) = rx541_cur."from"()
    inc rx541_pos
    rx541_cur."!cursor_from"(rx541_pos)
    ge rx541_pos, rx541_eos, rxscan545_done
  rxscan545_scan:
    set_addr $I10, rxscan545_loop
    rx541_cur."!mark_push"(0, rx541_pos, $I10)
  rxscan545_done:
.annotate 'line', 277
  # rx subrule "scope_declarator" subtype=capture negate=
    rx541_cur."!cursor_pos"(rx541_pos)
    $P10 = rx541_cur."scope_declarator"()
    unless $P10, rx541_fail
    rx541_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scope_declarator")
    rx541_pos = $P10."pos"()
  # rx pass
    rx541_cur."!cursor_pass"(rx541_pos, "term:sym<scope_declarator>")
    if_null rx541_debug, debug_809
    rx541_cur."!cursor_debug"("PASS", "term:sym<scope_declarator>", " at pos=", rx541_pos)
  debug_809:
    .return (rx541_cur)
  rx541_restart:
.annotate 'line', 10
    if_null rx541_debug, debug_810
    rx541_cur."!cursor_debug"("NEXT", "term:sym<scope_declarator>")
  debug_810:
  rx541_fail:
    (rx541_rep, rx541_pos, $I10, $P10) = rx541_cur."!mark_fail"(0)
    lt rx541_pos, -1, rx541_done
    eq rx541_pos, -1, rx541_fail
    jump $I10
  rx541_done:
    rx541_cur."!cursor_fail"()
    if_null rx541_debug, debug_811
    rx541_cur."!cursor_debug"("FAIL", "term:sym<scope_declarator>")
  debug_811:
    .return (rx541_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<scope_declarator>"  :nsentry("!PREFIX__term:sym<scope_declarator>") :subid("115_1303401201.841") :method
.annotate 'line', 10
    $P543 = self."!PREFIX__!subrule"("scope_declarator", "")
    new $P544, "ResizablePMCArray"
    push $P544, $P543
    .return ($P544)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<routine_declarator>"  :subid("116_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx547_tgt
    .local int rx547_pos
    .local int rx547_off
    .local int rx547_eos
    .local int rx547_rep
    .local pmc rx547_cur
    .local pmc rx547_debug
    (rx547_cur, rx547_pos, rx547_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx547_cur
    .local pmc match
    .lex "$/", match
    length rx547_eos, rx547_tgt
    gt rx547_pos, rx547_eos, rx547_done
    set rx547_off, 0
    lt rx547_pos, 2, rx547_start
    sub rx547_off, rx547_pos, 1
    substr rx547_tgt, rx547_tgt, rx547_off
  rx547_start:
    eq $I10, 1, rx547_restart
    if_null rx547_debug, debug_812
    rx547_cur."!cursor_debug"("START", "term:sym<routine_declarator>")
  debug_812:
    $I10 = self.'from'()
    ne $I10, -1, rxscan551_done
    goto rxscan551_scan
  rxscan551_loop:
    (rx547_pos) = rx547_cur."from"()
    inc rx547_pos
    rx547_cur."!cursor_from"(rx547_pos)
    ge rx547_pos, rx547_eos, rxscan551_done
  rxscan551_scan:
    set_addr $I10, rxscan551_loop
    rx547_cur."!mark_push"(0, rx547_pos, $I10)
  rxscan551_done:
.annotate 'line', 278
  # rx subrule "routine_declarator" subtype=capture negate=
    rx547_cur."!cursor_pos"(rx547_pos)
    $P10 = rx547_cur."routine_declarator"()
    unless $P10, rx547_fail
    rx547_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx547_pos = $P10."pos"()
  # rx pass
    rx547_cur."!cursor_pass"(rx547_pos, "term:sym<routine_declarator>")
    if_null rx547_debug, debug_813
    rx547_cur."!cursor_debug"("PASS", "term:sym<routine_declarator>", " at pos=", rx547_pos)
  debug_813:
    .return (rx547_cur)
  rx547_restart:
.annotate 'line', 10
    if_null rx547_debug, debug_814
    rx547_cur."!cursor_debug"("NEXT", "term:sym<routine_declarator>")
  debug_814:
  rx547_fail:
    (rx547_rep, rx547_pos, $I10, $P10) = rx547_cur."!mark_fail"(0)
    lt rx547_pos, -1, rx547_done
    eq rx547_pos, -1, rx547_fail
    jump $I10
  rx547_done:
    rx547_cur."!cursor_fail"()
    if_null rx547_debug, debug_815
    rx547_cur."!cursor_debug"("FAIL", "term:sym<routine_declarator>")
  debug_815:
    .return (rx547_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<routine_declarator>"  :nsentry("!PREFIX__term:sym<routine_declarator>") :subid("117_1303401201.841") :method
.annotate 'line', 10
    $P549 = self."!PREFIX__!subrule"("routine_declarator", "")
    new $P550, "ResizablePMCArray"
    push $P550, $P549
    .return ($P550)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<multi_declarator>"  :subid("118_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .const 'Sub' $P563 = "121_1303401201.841" 
    capture_lex $P563
    .const 'Sub' $P558 = "120_1303401201.841" 
    capture_lex $P558
    .local string rx553_tgt
    .local int rx553_pos
    .local int rx553_off
    .local int rx553_eos
    .local int rx553_rep
    .local pmc rx553_cur
    .local pmc rx553_debug
    (rx553_cur, rx553_pos, rx553_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx553_cur
    .local pmc match
    .lex "$/", match
    length rx553_eos, rx553_tgt
    gt rx553_pos, rx553_eos, rx553_done
    set rx553_off, 0
    lt rx553_pos, 2, rx553_start
    sub rx553_off, rx553_pos, 1
    substr rx553_tgt, rx553_tgt, rx553_off
  rx553_start:
    eq $I10, 1, rx553_restart
    if_null rx553_debug, debug_816
    rx553_cur."!cursor_debug"("START", "term:sym<multi_declarator>")
  debug_816:
    $I10 = self.'from'()
    ne $I10, -1, rxscan556_done
    goto rxscan556_scan
  rxscan556_loop:
    (rx553_pos) = rx553_cur."from"()
    inc rx553_pos
    rx553_cur."!cursor_from"(rx553_pos)
    ge rx553_pos, rx553_eos, rxscan556_done
  rxscan556_scan:
    set_addr $I10, rxscan556_loop
    rx553_cur."!mark_push"(0, rx553_pos, $I10)
  rxscan556_done:
.annotate 'line', 280
  # rx subrule "before" subtype=zerowidth negate=
    rx553_cur."!cursor_pos"(rx553_pos)
    .const 'Sub' $P558 = "120_1303401201.841" 
    capture_lex $P558
    $P10 = rx553_cur."before"($P558)
    unless $P10, rx553_fail
.annotate 'line', 281
  # rx subrule "before" subtype=zerowidth negate=1
    rx553_cur."!cursor_pos"(rx553_pos)
    .const 'Sub' $P563 = "121_1303401201.841" 
    capture_lex $P563
    $P10 = rx553_cur."before"($P563)
    if $P10, rx553_fail
.annotate 'line', 282
  # rx subrule "multi_declarator" subtype=capture negate=
    rx553_cur."!cursor_pos"(rx553_pos)
    $P10 = rx553_cur."multi_declarator"()
    unless $P10, rx553_fail
    rx553_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx553_pos = $P10."pos"()
.annotate 'line', 279
  # rx pass
    rx553_cur."!cursor_pass"(rx553_pos, "term:sym<multi_declarator>")
    if_null rx553_debug, debug_825
    rx553_cur."!cursor_debug"("PASS", "term:sym<multi_declarator>", " at pos=", rx553_pos)
  debug_825:
    .return (rx553_cur)
  rx553_restart:
.annotate 'line', 10
    if_null rx553_debug, debug_826
    rx553_cur."!cursor_debug"("NEXT", "term:sym<multi_declarator>")
  debug_826:
  rx553_fail:
    (rx553_rep, rx553_pos, $I10, $P10) = rx553_cur."!mark_fail"(0)
    lt rx553_pos, -1, rx553_done
    eq rx553_pos, -1, rx553_fail
    jump $I10
  rx553_done:
    rx553_cur."!cursor_fail"()
    if_null rx553_debug, debug_827
    rx553_cur."!cursor_debug"("FAIL", "term:sym<multi_declarator>")
  debug_827:
    .return (rx553_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<multi_declarator>"  :nsentry("!PREFIX__term:sym<multi_declarator>") :subid("119_1303401201.841") :method
.annotate 'line', 10
    new $P555, "ResizablePMCArray"
    push $P555, ""
    .return ($P555)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block557"  :anon :subid("120_1303401201.841") :method :outer("118_1303401201.841")
.annotate 'line', 280
    .local string rx559_tgt
    .local int rx559_pos
    .local int rx559_off
    .local int rx559_eos
    .local int rx559_rep
    .local pmc rx559_cur
    .local pmc rx559_debug
    (rx559_cur, rx559_pos, rx559_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx559_cur
    .local pmc match
    .lex "$/", match
    length rx559_eos, rx559_tgt
    gt rx559_pos, rx559_eos, rx559_done
    set rx559_off, 0
    lt rx559_pos, 2, rx559_start
    sub rx559_off, rx559_pos, 1
    substr rx559_tgt, rx559_tgt, rx559_off
  rx559_start:
    eq $I10, 1, rx559_restart
    if_null rx559_debug, debug_817
    rx559_cur."!cursor_debug"("START", "")
  debug_817:
    $I10 = self.'from'()
    ne $I10, -1, rxscan560_done
    goto rxscan560_scan
  rxscan560_loop:
    (rx559_pos) = rx559_cur."from"()
    inc rx559_pos
    rx559_cur."!cursor_from"(rx559_pos)
    ge rx559_pos, rx559_eos, rxscan560_done
  rxscan560_scan:
    set_addr $I10, rxscan560_loop
    rx559_cur."!mark_push"(0, rx559_pos, $I10)
  rxscan560_done:
  alt561_0:
    set_addr $I10, alt561_1
    rx559_cur."!mark_push"(0, rx559_pos, $I10)
  # rx literal  "multi"
    add $I11, rx559_pos, 5
    gt $I11, rx559_eos, rx559_fail
    sub $I11, rx559_pos, rx559_off
    substr $S10, rx559_tgt, $I11, 5
    ne $S10, "multi", rx559_fail
    add rx559_pos, 5
    goto alt561_end
  alt561_1:
    set_addr $I10, alt561_2
    rx559_cur."!mark_push"(0, rx559_pos, $I10)
  # rx literal  "proto"
    add $I11, rx559_pos, 5
    gt $I11, rx559_eos, rx559_fail
    sub $I11, rx559_pos, rx559_off
    substr $S10, rx559_tgt, $I11, 5
    ne $S10, "proto", rx559_fail
    add rx559_pos, 5
    goto alt561_end
  alt561_2:
  # rx literal  "only"
    add $I11, rx559_pos, 4
    gt $I11, rx559_eos, rx559_fail
    sub $I11, rx559_pos, rx559_off
    substr $S10, rx559_tgt, $I11, 4
    ne $S10, "only", rx559_fail
    add rx559_pos, 4
  alt561_end:
  # rx pass
    rx559_cur."!cursor_pass"(rx559_pos, "")
    if_null rx559_debug, debug_818
    rx559_cur."!cursor_debug"("PASS", "", " at pos=", rx559_pos)
  debug_818:
    .return (rx559_cur)
  rx559_restart:
    if_null rx559_debug, debug_819
    rx559_cur."!cursor_debug"("NEXT", "")
  debug_819:
  rx559_fail:
    (rx559_rep, rx559_pos, $I10, $P10) = rx559_cur."!mark_fail"(0)
    lt rx559_pos, -1, rx559_done
    eq rx559_pos, -1, rx559_fail
    jump $I10
  rx559_done:
    rx559_cur."!cursor_fail"()
    if_null rx559_debug, debug_820
    rx559_cur."!cursor_debug"("FAIL", "")
  debug_820:
    .return (rx559_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block562"  :anon :subid("121_1303401201.841") :method :outer("118_1303401201.841")
.annotate 'line', 281
    .local string rx564_tgt
    .local int rx564_pos
    .local int rx564_off
    .local int rx564_eos
    .local int rx564_rep
    .local pmc rx564_cur
    .local pmc rx564_debug
    (rx564_cur, rx564_pos, rx564_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx564_cur
    .local pmc match
    .lex "$/", match
    length rx564_eos, rx564_tgt
    gt rx564_pos, rx564_eos, rx564_done
    set rx564_off, 0
    lt rx564_pos, 2, rx564_start
    sub rx564_off, rx564_pos, 1
    substr rx564_tgt, rx564_tgt, rx564_off
  rx564_start:
    eq $I10, 1, rx564_restart
    if_null rx564_debug, debug_821
    rx564_cur."!cursor_debug"("START", "")
  debug_821:
    $I10 = self.'from'()
    ne $I10, -1, rxscan565_done
    goto rxscan565_scan
  rxscan565_loop:
    (rx564_pos) = rx564_cur."from"()
    inc rx564_pos
    rx564_cur."!cursor_from"(rx564_pos)
    ge rx564_pos, rx564_eos, rxscan565_done
  rxscan565_scan:
    set_addr $I10, rxscan565_loop
    rx564_cur."!mark_push"(0, rx564_pos, $I10)
  rxscan565_done:
  # rx literal  "proto"
    add $I11, rx564_pos, 5
    gt $I11, rx564_eos, rx564_fail
    sub $I11, rx564_pos, rx564_off
    substr $S10, rx564_tgt, $I11, 5
    ne $S10, "proto", rx564_fail
    add rx564_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx564_cur."!cursor_pos"(rx564_pos)
    $P10 = rx564_cur."ws"()
    unless $P10, rx564_fail
    rx564_pos = $P10."pos"()
  alt566_0:
    set_addr $I10, alt566_1
    rx564_cur."!mark_push"(0, rx564_pos, $I10)
  # rx literal  "regex"
    add $I11, rx564_pos, 5
    gt $I11, rx564_eos, rx564_fail
    sub $I11, rx564_pos, rx564_off
    substr $S10, rx564_tgt, $I11, 5
    ne $S10, "regex", rx564_fail
    add rx564_pos, 5
    goto alt566_end
  alt566_1:
    set_addr $I10, alt566_2
    rx564_cur."!mark_push"(0, rx564_pos, $I10)
  # rx literal  "token"
    add $I11, rx564_pos, 5
    gt $I11, rx564_eos, rx564_fail
    sub $I11, rx564_pos, rx564_off
    substr $S10, rx564_tgt, $I11, 5
    ne $S10, "token", rx564_fail
    add rx564_pos, 5
    goto alt566_end
  alt566_2:
  # rx literal  "rule"
    add $I11, rx564_pos, 4
    gt $I11, rx564_eos, rx564_fail
    sub $I11, rx564_pos, rx564_off
    substr $S10, rx564_tgt, $I11, 4
    ne $S10, "rule", rx564_fail
    add rx564_pos, 4
  alt566_end:
  # rx pass
    rx564_cur."!cursor_pass"(rx564_pos, "")
    if_null rx564_debug, debug_822
    rx564_cur."!cursor_debug"("PASS", "", " at pos=", rx564_pos)
  debug_822:
    .return (rx564_cur)
  rx564_restart:
    if_null rx564_debug, debug_823
    rx564_cur."!cursor_debug"("NEXT", "")
  debug_823:
  rx564_fail:
    (rx564_rep, rx564_pos, $I10, $P10) = rx564_cur."!mark_fail"(0)
    lt rx564_pos, -1, rx564_done
    eq rx564_pos, -1, rx564_fail
    jump $I10
  rx564_done:
    rx564_cur."!cursor_fail"()
    if_null rx564_debug, debug_824
    rx564_cur."!cursor_debug"("FAIL", "")
  debug_824:
    .return (rx564_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<regex_declarator>"  :subid("122_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx568_tgt
    .local int rx568_pos
    .local int rx568_off
    .local int rx568_eos
    .local int rx568_rep
    .local pmc rx568_cur
    .local pmc rx568_debug
    (rx568_cur, rx568_pos, rx568_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx568_cur
    .local pmc match
    .lex "$/", match
    length rx568_eos, rx568_tgt
    gt rx568_pos, rx568_eos, rx568_done
    set rx568_off, 0
    lt rx568_pos, 2, rx568_start
    sub rx568_off, rx568_pos, 1
    substr rx568_tgt, rx568_tgt, rx568_off
  rx568_start:
    eq $I10, 1, rx568_restart
    if_null rx568_debug, debug_828
    rx568_cur."!cursor_debug"("START", "term:sym<regex_declarator>")
  debug_828:
    $I10 = self.'from'()
    ne $I10, -1, rxscan572_done
    goto rxscan572_scan
  rxscan572_loop:
    (rx568_pos) = rx568_cur."from"()
    inc rx568_pos
    rx568_cur."!cursor_from"(rx568_pos)
    ge rx568_pos, rx568_eos, rxscan572_done
  rxscan572_scan:
    set_addr $I10, rxscan572_loop
    rx568_cur."!mark_push"(0, rx568_pos, $I10)
  rxscan572_done:
.annotate 'line', 284
  # rx subrule "regex_declarator" subtype=capture negate=
    rx568_cur."!cursor_pos"(rx568_pos)
    $P10 = rx568_cur."regex_declarator"()
    unless $P10, rx568_fail
    rx568_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("regex_declarator")
    rx568_pos = $P10."pos"()
  # rx pass
    rx568_cur."!cursor_pass"(rx568_pos, "term:sym<regex_declarator>")
    if_null rx568_debug, debug_829
    rx568_cur."!cursor_debug"("PASS", "term:sym<regex_declarator>", " at pos=", rx568_pos)
  debug_829:
    .return (rx568_cur)
  rx568_restart:
.annotate 'line', 10
    if_null rx568_debug, debug_830
    rx568_cur."!cursor_debug"("NEXT", "term:sym<regex_declarator>")
  debug_830:
  rx568_fail:
    (rx568_rep, rx568_pos, $I10, $P10) = rx568_cur."!mark_fail"(0)
    lt rx568_pos, -1, rx568_done
    eq rx568_pos, -1, rx568_fail
    jump $I10
  rx568_done:
    rx568_cur."!cursor_fail"()
    if_null rx568_debug, debug_831
    rx568_cur."!cursor_debug"("FAIL", "term:sym<regex_declarator>")
  debug_831:
    .return (rx568_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<regex_declarator>"  :nsentry("!PREFIX__term:sym<regex_declarator>") :subid("123_1303401201.841") :method
.annotate 'line', 10
    $P570 = self."!PREFIX__!subrule"("regex_declarator", "")
    new $P571, "ResizablePMCArray"
    push $P571, $P570
    .return ($P571)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<statement_prefix>"  :subid("124_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx574_tgt
    .local int rx574_pos
    .local int rx574_off
    .local int rx574_eos
    .local int rx574_rep
    .local pmc rx574_cur
    .local pmc rx574_debug
    (rx574_cur, rx574_pos, rx574_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx574_cur
    .local pmc match
    .lex "$/", match
    length rx574_eos, rx574_tgt
    gt rx574_pos, rx574_eos, rx574_done
    set rx574_off, 0
    lt rx574_pos, 2, rx574_start
    sub rx574_off, rx574_pos, 1
    substr rx574_tgt, rx574_tgt, rx574_off
  rx574_start:
    eq $I10, 1, rx574_restart
    if_null rx574_debug, debug_832
    rx574_cur."!cursor_debug"("START", "term:sym<statement_prefix>")
  debug_832:
    $I10 = self.'from'()
    ne $I10, -1, rxscan578_done
    goto rxscan578_scan
  rxscan578_loop:
    (rx574_pos) = rx574_cur."from"()
    inc rx574_pos
    rx574_cur."!cursor_from"(rx574_pos)
    ge rx574_pos, rx574_eos, rxscan578_done
  rxscan578_scan:
    set_addr $I10, rxscan578_loop
    rx574_cur."!mark_push"(0, rx574_pos, $I10)
  rxscan578_done:
.annotate 'line', 285
  # rx subrule "statement_prefix" subtype=capture negate=
    rx574_cur."!cursor_pos"(rx574_pos)
    $P10 = rx574_cur."statement_prefix"()
    unless $P10, rx574_fail
    rx574_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_prefix")
    rx574_pos = $P10."pos"()
  # rx pass
    rx574_cur."!cursor_pass"(rx574_pos, "term:sym<statement_prefix>")
    if_null rx574_debug, debug_833
    rx574_cur."!cursor_debug"("PASS", "term:sym<statement_prefix>", " at pos=", rx574_pos)
  debug_833:
    .return (rx574_cur)
  rx574_restart:
.annotate 'line', 10
    if_null rx574_debug, debug_834
    rx574_cur."!cursor_debug"("NEXT", "term:sym<statement_prefix>")
  debug_834:
  rx574_fail:
    (rx574_rep, rx574_pos, $I10, $P10) = rx574_cur."!mark_fail"(0)
    lt rx574_pos, -1, rx574_done
    eq rx574_pos, -1, rx574_fail
    jump $I10
  rx574_done:
    rx574_cur."!cursor_fail"()
    if_null rx574_debug, debug_835
    rx574_cur."!cursor_debug"("FAIL", "term:sym<statement_prefix>")
  debug_835:
    .return (rx574_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<statement_prefix>"  :nsentry("!PREFIX__term:sym<statement_prefix>") :subid("125_1303401201.841") :method
.annotate 'line', 10
    $P576 = self."!PREFIX__!subrule"("statement_prefix", "")
    new $P577, "ResizablePMCArray"
    push $P577, $P576
    .return ($P577)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<lambda>"  :subid("126_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx580_tgt
    .local int rx580_pos
    .local int rx580_off
    .local int rx580_eos
    .local int rx580_rep
    .local pmc rx580_cur
    .local pmc rx580_debug
    (rx580_cur, rx580_pos, rx580_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx580_cur
    .local pmc match
    .lex "$/", match
    length rx580_eos, rx580_tgt
    gt rx580_pos, rx580_eos, rx580_done
    set rx580_off, 0
    lt rx580_pos, 2, rx580_start
    sub rx580_off, rx580_pos, 1
    substr rx580_tgt, rx580_tgt, rx580_off
  rx580_start:
    eq $I10, 1, rx580_restart
    if_null rx580_debug, debug_836
    rx580_cur."!cursor_debug"("START", "term:sym<lambda>")
  debug_836:
    $I10 = self.'from'()
    ne $I10, -1, rxscan583_done
    goto rxscan583_scan
  rxscan583_loop:
    (rx580_pos) = rx580_cur."from"()
    inc rx580_pos
    rx580_cur."!cursor_from"(rx580_pos)
    ge rx580_pos, rx580_eos, rxscan583_done
  rxscan583_scan:
    set_addr $I10, rxscan583_loop
    rx580_cur."!mark_push"(0, rx580_pos, $I10)
  rxscan583_done:
.annotate 'line', 286
  # rx subrule "lambda" subtype=zerowidth negate=
    rx580_cur."!cursor_pos"(rx580_pos)
    $P10 = rx580_cur."lambda"()
    unless $P10, rx580_fail
  # rx subrule "pblock" subtype=capture negate=
    rx580_cur."!cursor_pos"(rx580_pos)
    $P10 = rx580_cur."pblock"()
    unless $P10, rx580_fail
    rx580_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx580_pos = $P10."pos"()
  # rx pass
    rx580_cur."!cursor_pass"(rx580_pos, "term:sym<lambda>")
    if_null rx580_debug, debug_837
    rx580_cur."!cursor_debug"("PASS", "term:sym<lambda>", " at pos=", rx580_pos)
  debug_837:
    .return (rx580_cur)
  rx580_restart:
.annotate 'line', 10
    if_null rx580_debug, debug_838
    rx580_cur."!cursor_debug"("NEXT", "term:sym<lambda>")
  debug_838:
  rx580_fail:
    (rx580_rep, rx580_pos, $I10, $P10) = rx580_cur."!mark_fail"(0)
    lt rx580_pos, -1, rx580_done
    eq rx580_pos, -1, rx580_fail
    jump $I10
  rx580_done:
    rx580_cur."!cursor_fail"()
    if_null rx580_debug, debug_839
    rx580_cur."!cursor_debug"("FAIL", "term:sym<lambda>")
  debug_839:
    .return (rx580_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<lambda>"  :nsentry("!PREFIX__term:sym<lambda>") :subid("127_1303401201.841") :method
.annotate 'line', 10
    new $P582, "ResizablePMCArray"
    push $P582, ""
    .return ($P582)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "fatarrow"  :subid("128_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx585_tgt
    .local int rx585_pos
    .local int rx585_off
    .local int rx585_eos
    .local int rx585_rep
    .local pmc rx585_cur
    .local pmc rx585_debug
    (rx585_cur, rx585_pos, rx585_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx585_cur
    .local pmc match
    .lex "$/", match
    length rx585_eos, rx585_tgt
    gt rx585_pos, rx585_eos, rx585_done
    set rx585_off, 0
    lt rx585_pos, 2, rx585_start
    sub rx585_off, rx585_pos, 1
    substr rx585_tgt, rx585_tgt, rx585_off
  rx585_start:
    eq $I10, 1, rx585_restart
    if_null rx585_debug, debug_840
    rx585_cur."!cursor_debug"("START", "fatarrow")
  debug_840:
    $I10 = self.'from'()
    ne $I10, -1, rxscan589_done
    goto rxscan589_scan
  rxscan589_loop:
    (rx585_pos) = rx585_cur."from"()
    inc rx585_pos
    rx585_cur."!cursor_from"(rx585_pos)
    ge rx585_pos, rx585_eos, rxscan589_done
  rxscan589_scan:
    set_addr $I10, rxscan589_loop
    rx585_cur."!mark_push"(0, rx585_pos, $I10)
  rxscan589_done:
.annotate 'line', 289
  # rx subrule "identifier" subtype=capture negate=
    rx585_cur."!cursor_pos"(rx585_pos)
    $P10 = rx585_cur."identifier"()
    unless $P10, rx585_fail
    rx585_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("key")
    rx585_pos = $P10."pos"()
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx585_pos, rx585_off
    set rx585_rep, 0
    sub $I12, rx585_eos, rx585_pos
  rxenumcharlistq590_loop:
    le $I12, 0, rxenumcharlistq590_done
    substr $S10, rx585_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq590_done
    inc rx585_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq590_loop
  rxenumcharlistq590_done:
    add rx585_pos, rx585_pos, rx585_rep
  # rx literal  "=>"
    add $I11, rx585_pos, 2
    gt $I11, rx585_eos, rx585_fail
    sub $I11, rx585_pos, rx585_off
    substr $S10, rx585_tgt, $I11, 2
    ne $S10, "=>", rx585_fail
    add rx585_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx585_cur."!cursor_pos"(rx585_pos)
    $P10 = rx585_cur."ws"()
    unless $P10, rx585_fail
    rx585_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx585_cur."!cursor_pos"(rx585_pos)
    $P10 = rx585_cur."EXPR"("i=")
    unless $P10, rx585_fail
    rx585_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("val")
    rx585_pos = $P10."pos"()
.annotate 'line', 288
  # rx pass
    rx585_cur."!cursor_pass"(rx585_pos, "fatarrow")
    if_null rx585_debug, debug_841
    rx585_cur."!cursor_debug"("PASS", "fatarrow", " at pos=", rx585_pos)
  debug_841:
    .return (rx585_cur)
  rx585_restart:
.annotate 'line', 10
    if_null rx585_debug, debug_842
    rx585_cur."!cursor_debug"("NEXT", "fatarrow")
  debug_842:
  rx585_fail:
    (rx585_rep, rx585_pos, $I10, $P10) = rx585_cur."!mark_fail"(0)
    lt rx585_pos, -1, rx585_done
    eq rx585_pos, -1, rx585_fail
    jump $I10
  rx585_done:
    rx585_cur."!cursor_fail"()
    if_null rx585_debug, debug_843
    rx585_cur."!cursor_debug"("FAIL", "fatarrow")
  debug_843:
    .return (rx585_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__fatarrow"  :nsentry("!PREFIX__fatarrow") :subid("129_1303401201.841") :method
.annotate 'line', 10
    $P587 = self."!PREFIX__!subrule"("identifier", "")
    new $P588, "ResizablePMCArray"
    push $P588, $P587
    .return ($P588)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "colonpair"  :subid("130_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx592_tgt
    .local int rx592_pos
    .local int rx592_off
    .local int rx592_eos
    .local int rx592_rep
    .local pmc rx592_cur
    .local pmc rx592_debug
    (rx592_cur, rx592_pos, rx592_tgt, $I10) = self."!cursor_start"()
    rx592_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx592_cur
    .local pmc match
    .lex "$/", match
    length rx592_eos, rx592_tgt
    gt rx592_pos, rx592_eos, rx592_done
    set rx592_off, 0
    lt rx592_pos, 2, rx592_start
    sub rx592_off, rx592_pos, 1
    substr rx592_tgt, rx592_tgt, rx592_off
  rx592_start:
    eq $I10, 1, rx592_restart
    if_null rx592_debug, debug_844
    rx592_cur."!cursor_debug"("START", "colonpair")
  debug_844:
    $I10 = self.'from'()
    ne $I10, -1, rxscan598_done
    goto rxscan598_scan
  rxscan598_loop:
    (rx592_pos) = rx592_cur."from"()
    inc rx592_pos
    rx592_cur."!cursor_from"(rx592_pos)
    ge rx592_pos, rx592_eos, rxscan598_done
  rxscan598_scan:
    set_addr $I10, rxscan598_loop
    rx592_cur."!mark_push"(0, rx592_pos, $I10)
  rxscan598_done:
.annotate 'line', 293
  # rx literal  ":"
    add $I11, rx592_pos, 1
    gt $I11, rx592_eos, rx592_fail
    sub $I11, rx592_pos, rx592_off
    ord $I11, rx592_tgt, $I11
    ne $I11, 58, rx592_fail
    add rx592_pos, 1
  alt599_0:
.annotate 'line', 294
    set_addr $I10, alt599_1
    rx592_cur."!mark_push"(0, rx592_pos, $I10)
.annotate 'line', 295
  # rx subcapture "not"
    set_addr $I10, rxcap_600_fail
    rx592_cur."!mark_push"(0, rx592_pos, $I10)
  # rx literal  "!"
    add $I11, rx592_pos, 1
    gt $I11, rx592_eos, rx592_fail
    sub $I11, rx592_pos, rx592_off
    ord $I11, rx592_tgt, $I11
    ne $I11, 33, rx592_fail
    add rx592_pos, 1
    set_addr $I10, rxcap_600_fail
    ($I12, $I11) = rx592_cur."!mark_peek"($I10)
    rx592_cur."!cursor_pos"($I11)
    ($P10) = rx592_cur."!cursor_start"()
    $P10."!cursor_pass"(rx592_pos, "")
    rx592_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("not")
    goto rxcap_600_done
  rxcap_600_fail:
    goto rx592_fail
  rxcap_600_done:
  # rx subrule "identifier" subtype=capture negate=
    rx592_cur."!cursor_pos"(rx592_pos)
    $P10 = rx592_cur."identifier"()
    unless $P10, rx592_fail
    rx592_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx592_pos = $P10."pos"()
    goto alt599_end
  alt599_1:
    set_addr $I10, alt599_2
    rx592_cur."!mark_push"(0, rx592_pos, $I10)
.annotate 'line', 296
  # rx subrule "identifier" subtype=capture negate=
    rx592_cur."!cursor_pos"(rx592_pos)
    $P10 = rx592_cur."identifier"()
    unless $P10, rx592_fail
    rx592_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx592_pos = $P10."pos"()
  # rx rxquantr601 ** 0..1
    set_addr $I10, rxquantr601_done
    rx592_cur."!mark_push"(0, rx592_pos, $I10)
  rxquantr601_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx592_cur."!cursor_pos"(rx592_pos)
    $P10 = rx592_cur."circumfix"()
    unless $P10, rx592_fail
    goto rxsubrule602_pass
  rxsubrule602_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx592_fail
  rxsubrule602_pass:
    set_addr $I10, rxsubrule602_back
    rx592_cur."!mark_push"(0, rx592_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx592_pos = $P10."pos"()
    set_addr $I10, rxquantr601_done
    (rx592_rep) = rx592_cur."!mark_commit"($I10)
  rxquantr601_done:
    goto alt599_end
  alt599_2:
.annotate 'line', 297
  # rx subrule "circumfix" subtype=capture negate=
    rx592_cur."!cursor_pos"(rx592_pos)
    $P10 = rx592_cur."circumfix"()
    unless $P10, rx592_fail
    rx592_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("circumfix")
    rx592_pos = $P10."pos"()
  alt599_end:
.annotate 'line', 292
  # rx pass
    rx592_cur."!cursor_pass"(rx592_pos, "colonpair")
    if_null rx592_debug, debug_845
    rx592_cur."!cursor_debug"("PASS", "colonpair", " at pos=", rx592_pos)
  debug_845:
    .return (rx592_cur)
  rx592_restart:
.annotate 'line', 10
    if_null rx592_debug, debug_846
    rx592_cur."!cursor_debug"("NEXT", "colonpair")
  debug_846:
  rx592_fail:
    (rx592_rep, rx592_pos, $I10, $P10) = rx592_cur."!mark_fail"(0)
    lt rx592_pos, -1, rx592_done
    eq rx592_pos, -1, rx592_fail
    jump $I10
  rx592_done:
    rx592_cur."!cursor_fail"()
    if_null rx592_debug, debug_847
    rx592_cur."!cursor_debug"("FAIL", "colonpair")
  debug_847:
    .return (rx592_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__colonpair"  :nsentry("!PREFIX__colonpair") :subid("131_1303401201.841") :method
.annotate 'line', 10
    $P594 = self."!PREFIX__!subrule"("circumfix", ":")
    $P595 = self."!PREFIX__!subrule"("identifier", ":")
    $P596 = self."!PREFIX__!subrule"("identifier", ":!")
    new $P597, "ResizablePMCArray"
    push $P597, $P594
    push $P597, $P595
    push $P597, $P596
    .return ($P597)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable"  :subid("132_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx604_tgt
    .local int rx604_pos
    .local int rx604_off
    .local int rx604_eos
    .local int rx604_rep
    .local pmc rx604_cur
    .local pmc rx604_debug
    (rx604_cur, rx604_pos, rx604_tgt, $I10) = self."!cursor_start"()
    rx604_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx604_cur
    .local pmc match
    .lex "$/", match
    length rx604_eos, rx604_tgt
    gt rx604_pos, rx604_eos, rx604_done
    set rx604_off, 0
    lt rx604_pos, 2, rx604_start
    sub rx604_off, rx604_pos, 1
    substr rx604_tgt, rx604_tgt, rx604_off
  rx604_start:
    eq $I10, 1, rx604_restart
    if_null rx604_debug, debug_848
    rx604_cur."!cursor_debug"("START", "variable")
  debug_848:
    $I10 = self.'from'()
    ne $I10, -1, rxscan609_done
    goto rxscan609_scan
  rxscan609_loop:
    (rx604_pos) = rx604_cur."from"()
    inc rx604_pos
    rx604_cur."!cursor_from"(rx604_pos)
    ge rx604_pos, rx604_eos, rxscan609_done
  rxscan609_scan:
    set_addr $I10, rxscan609_loop
    rx604_cur."!mark_push"(0, rx604_pos, $I10)
  rxscan609_done:
  alt610_0:
.annotate 'line', 301
    set_addr $I10, alt610_1
    rx604_cur."!mark_push"(0, rx604_pos, $I10)
.annotate 'line', 302
  # rx subrule "sigil" subtype=capture negate=
    rx604_cur."!cursor_pos"(rx604_pos)
    $P10 = rx604_cur."sigil"()
    unless $P10, rx604_fail
    rx604_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx604_pos = $P10."pos"()
  # rx rxquantr611 ** 0..1
    set_addr $I10, rxquantr611_done
    rx604_cur."!mark_push"(0, rx604_pos, $I10)
  rxquantr611_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx604_cur."!cursor_pos"(rx604_pos)
    $P10 = rx604_cur."twigil"()
    unless $P10, rx604_fail
    goto rxsubrule612_pass
  rxsubrule612_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx604_fail
  rxsubrule612_pass:
    set_addr $I10, rxsubrule612_back
    rx604_cur."!mark_push"(0, rx604_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx604_pos = $P10."pos"()
    set_addr $I10, rxquantr611_done
    (rx604_rep) = rx604_cur."!mark_commit"($I10)
  rxquantr611_done:
  # rx subrule "name" subtype=capture negate=
    rx604_cur."!cursor_pos"(rx604_pos)
    $P10 = rx604_cur."name"()
    unless $P10, rx604_fail
    rx604_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    rx604_pos = $P10."pos"()
    goto alt610_end
  alt610_1:
    set_addr $I10, alt610_2
    rx604_cur."!mark_push"(0, rx604_pos, $I10)
.annotate 'line', 303
  # rx subrule "sigil" subtype=capture negate=
    rx604_cur."!cursor_pos"(rx604_pos)
    $P10 = rx604_cur."sigil"()
    unless $P10, rx604_fail
    rx604_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx604_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx604_pos, rx604_off
    substr $S10, rx604_tgt, $I10, 1
    index $I11, "<[", $S10
    lt $I11, 0, rx604_fail
  # rx subrule "postcircumfix" subtype=capture negate=
    rx604_cur."!cursor_pos"(rx604_pos)
    $P10 = rx604_cur."postcircumfix"()
    unless $P10, rx604_fail
    rx604_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("postcircumfix")
    rx604_pos = $P10."pos"()
    goto alt610_end
  alt610_2:
.annotate 'line', 304
  # rx subcapture "sigil"
    set_addr $I10, rxcap_613_fail
    rx604_cur."!mark_push"(0, rx604_pos, $I10)
  # rx literal  "$"
    add $I11, rx604_pos, 1
    gt $I11, rx604_eos, rx604_fail
    sub $I11, rx604_pos, rx604_off
    ord $I11, rx604_tgt, $I11
    ne $I11, 36, rx604_fail
    add rx604_pos, 1
    set_addr $I10, rxcap_613_fail
    ($I12, $I11) = rx604_cur."!mark_peek"($I10)
    rx604_cur."!cursor_pos"($I11)
    ($P10) = rx604_cur."!cursor_start"()
    $P10."!cursor_pass"(rx604_pos, "")
    rx604_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_613_done
  rxcap_613_fail:
    goto rx604_fail
  rxcap_613_done:
  # rx subcapture "desigilname"
    set_addr $I10, rxcap_614_fail
    rx604_cur."!mark_push"(0, rx604_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx604_pos, rx604_eos, rx604_fail
    sub $I10, rx604_pos, rx604_off
    substr $S10, rx604_tgt, $I10, 1
    index $I11, "/_!", $S10
    lt $I11, 0, rx604_fail
    inc rx604_pos
    set_addr $I10, rxcap_614_fail
    ($I12, $I11) = rx604_cur."!mark_peek"($I10)
    rx604_cur."!cursor_pos"($I11)
    ($P10) = rx604_cur."!cursor_start"()
    $P10."!cursor_pass"(rx604_pos, "")
    rx604_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    goto rxcap_614_done
  rxcap_614_fail:
    goto rx604_fail
  rxcap_614_done:
  alt610_end:
.annotate 'line', 301
  # rx pass
    rx604_cur."!cursor_pass"(rx604_pos, "variable")
    if_null rx604_debug, debug_849
    rx604_cur."!cursor_debug"("PASS", "variable", " at pos=", rx604_pos)
  debug_849:
    .return (rx604_cur)
  rx604_restart:
.annotate 'line', 10
    if_null rx604_debug, debug_850
    rx604_cur."!cursor_debug"("NEXT", "variable")
  debug_850:
  rx604_fail:
    (rx604_rep, rx604_pos, $I10, $P10) = rx604_cur."!mark_fail"(0)
    lt rx604_pos, -1, rx604_done
    eq rx604_pos, -1, rx604_fail
    jump $I10
  rx604_done:
    rx604_cur."!cursor_fail"()
    if_null rx604_debug, debug_851
    rx604_cur."!cursor_debug"("FAIL", "variable")
  debug_851:
    .return (rx604_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable"  :nsentry("!PREFIX__variable") :subid("133_1303401201.841") :method
.annotate 'line', 10
    $P606 = self."!PREFIX__!subrule"("sigil", "")
    $P607 = self."!PREFIX__!subrule"("sigil", "")
    new $P608, "ResizablePMCArray"
    push $P608, "$!"
    push $P608, "$_"
    push $P608, "$/"
    push $P608, $P606
    push $P608, $P607
    .return ($P608)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "sigil"  :subid("134_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx616_tgt
    .local int rx616_pos
    .local int rx616_off
    .local int rx616_eos
    .local int rx616_rep
    .local pmc rx616_cur
    .local pmc rx616_debug
    (rx616_cur, rx616_pos, rx616_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx616_cur
    .local pmc match
    .lex "$/", match
    length rx616_eos, rx616_tgt
    gt rx616_pos, rx616_eos, rx616_done
    set rx616_off, 0
    lt rx616_pos, 2, rx616_start
    sub rx616_off, rx616_pos, 1
    substr rx616_tgt, rx616_tgt, rx616_off
  rx616_start:
    eq $I10, 1, rx616_restart
    if_null rx616_debug, debug_852
    rx616_cur."!cursor_debug"("START", "sigil")
  debug_852:
    $I10 = self.'from'()
    ne $I10, -1, rxscan619_done
    goto rxscan619_scan
  rxscan619_loop:
    (rx616_pos) = rx616_cur."from"()
    inc rx616_pos
    rx616_cur."!cursor_from"(rx616_pos)
    ge rx616_pos, rx616_eos, rxscan619_done
  rxscan619_scan:
    set_addr $I10, rxscan619_loop
    rx616_cur."!mark_push"(0, rx616_pos, $I10)
  rxscan619_done:
.annotate 'line', 307
  # rx enumcharlist negate=0 
    ge rx616_pos, rx616_eos, rx616_fail
    sub $I10, rx616_pos, rx616_off
    substr $S10, rx616_tgt, $I10, 1
    index $I11, "$@%&", $S10
    lt $I11, 0, rx616_fail
    inc rx616_pos
  # rx pass
    rx616_cur."!cursor_pass"(rx616_pos, "sigil")
    if_null rx616_debug, debug_853
    rx616_cur."!cursor_debug"("PASS", "sigil", " at pos=", rx616_pos)
  debug_853:
    .return (rx616_cur)
  rx616_restart:
.annotate 'line', 10
    if_null rx616_debug, debug_854
    rx616_cur."!cursor_debug"("NEXT", "sigil")
  debug_854:
  rx616_fail:
    (rx616_rep, rx616_pos, $I10, $P10) = rx616_cur."!mark_fail"(0)
    lt rx616_pos, -1, rx616_done
    eq rx616_pos, -1, rx616_fail
    jump $I10
  rx616_done:
    rx616_cur."!cursor_fail"()
    if_null rx616_debug, debug_855
    rx616_cur."!cursor_debug"("FAIL", "sigil")
  debug_855:
    .return (rx616_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__sigil"  :nsentry("!PREFIX__sigil") :subid("135_1303401201.841") :method
.annotate 'line', 10
    new $P618, "ResizablePMCArray"
    push $P618, "&"
    push $P618, "%"
    push $P618, "@"
    push $P618, "$"
    .return ($P618)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "twigil"  :subid("136_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx621_tgt
    .local int rx621_pos
    .local int rx621_off
    .local int rx621_eos
    .local int rx621_rep
    .local pmc rx621_cur
    .local pmc rx621_debug
    (rx621_cur, rx621_pos, rx621_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx621_cur
    .local pmc match
    .lex "$/", match
    length rx621_eos, rx621_tgt
    gt rx621_pos, rx621_eos, rx621_done
    set rx621_off, 0
    lt rx621_pos, 2, rx621_start
    sub rx621_off, rx621_pos, 1
    substr rx621_tgt, rx621_tgt, rx621_off
  rx621_start:
    eq $I10, 1, rx621_restart
    if_null rx621_debug, debug_856
    rx621_cur."!cursor_debug"("START", "twigil")
  debug_856:
    $I10 = self.'from'()
    ne $I10, -1, rxscan624_done
    goto rxscan624_scan
  rxscan624_loop:
    (rx621_pos) = rx621_cur."from"()
    inc rx621_pos
    rx621_cur."!cursor_from"(rx621_pos)
    ge rx621_pos, rx621_eos, rxscan624_done
  rxscan624_scan:
    set_addr $I10, rxscan624_loop
    rx621_cur."!mark_push"(0, rx621_pos, $I10)
  rxscan624_done:
.annotate 'line', 309
  # rx enumcharlist negate=0 
    ge rx621_pos, rx621_eos, rx621_fail
    sub $I10, rx621_pos, rx621_off
    substr $S10, rx621_tgt, $I10, 1
    index $I11, "*!?", $S10
    lt $I11, 0, rx621_fail
    inc rx621_pos
  # rx pass
    rx621_cur."!cursor_pass"(rx621_pos, "twigil")
    if_null rx621_debug, debug_857
    rx621_cur."!cursor_debug"("PASS", "twigil", " at pos=", rx621_pos)
  debug_857:
    .return (rx621_cur)
  rx621_restart:
.annotate 'line', 10
    if_null rx621_debug, debug_858
    rx621_cur."!cursor_debug"("NEXT", "twigil")
  debug_858:
  rx621_fail:
    (rx621_rep, rx621_pos, $I10, $P10) = rx621_cur."!mark_fail"(0)
    lt rx621_pos, -1, rx621_done
    eq rx621_pos, -1, rx621_fail
    jump $I10
  rx621_done:
    rx621_cur."!cursor_fail"()
    if_null rx621_debug, debug_859
    rx621_cur."!cursor_debug"("FAIL", "twigil")
  debug_859:
    .return (rx621_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__twigil"  :nsentry("!PREFIX__twigil") :subid("137_1303401201.841") :method
.annotate 'line', 10
    new $P623, "ResizablePMCArray"
    push $P623, "?"
    push $P623, "!"
    push $P623, "*"
    .return ($P623)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator"  :subid("138_1303401201.841")
    .param pmc param_626
.annotate 'line', 311
    .lex "self", param_626
    $P627 = param_626."!protoregex"("package_declarator")
    .return ($P627)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator"  :subid("139_1303401201.841")
    .param pmc param_629
.annotate 'line', 311
    .lex "self", param_629
    $P630 = param_629."!PREFIX__!protoregex"("package_declarator")
    .return ($P630)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<module>"  :subid("140_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 313
    new $P632, "Undef"
    .lex "$*OUTERPACKAGE", $P632
.annotate 'line', 314
    new $P633, "Undef"
    .lex "$*PACKAGE-SETUP", $P633
.annotate 'line', 315
    new $P634, "Undef"
    .lex "$*PKGDECL", $P634
.annotate 'line', 10
    .local string rx635_tgt
    .local int rx635_pos
    .local int rx635_off
    .local int rx635_eos
    .local int rx635_rep
    .local pmc rx635_cur
    .local pmc rx635_debug
    (rx635_cur, rx635_pos, rx635_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx635_cur
    .local pmc match
    .lex "$/", match
    length rx635_eos, rx635_tgt
    gt rx635_pos, rx635_eos, rx635_done
    set rx635_off, 0
    lt rx635_pos, 2, rx635_start
    sub rx635_off, rx635_pos, 1
    substr rx635_tgt, rx635_tgt, rx635_off
  rx635_start:
    eq $I10, 1, rx635_restart
    if_null rx635_debug, debug_860
    rx635_cur."!cursor_debug"("START", "package_declarator:sym<module>")
  debug_860:
    $I10 = self.'from'()
    ne $I10, -1, rxscan639_done
    goto rxscan639_scan
  rxscan639_loop:
    (rx635_pos) = rx635_cur."from"()
    inc rx635_pos
    rx635_cur."!cursor_from"(rx635_pos)
    ge rx635_pos, rx635_eos, rxscan639_done
  rxscan639_scan:
    set_addr $I10, rxscan639_loop
    rx635_cur."!mark_push"(0, rx635_pos, $I10)
  rxscan639_done:
.annotate 'line', 313
    rx635_cur."!cursor_pos"(rx635_pos)
    find_dynamic_lex $P640, "$*PACKAGE"
    unless_null $P640, vivify_861
    get_hll_global $P640, "$PACKAGE"
    unless_null $P640, vivify_862
    die "Contextual $*PACKAGE not found"
  vivify_862:
  vivify_861:
    store_lex "$*OUTERPACKAGE", $P640
.annotate 'line', 314
    rx635_cur."!cursor_pos"(rx635_pos)
    get_hll_global $P641, ["PAST"], "Stmts"
    $P642 = $P641."new"()
    store_lex "$*PACKAGE-SETUP", $P642
.annotate 'line', 315
    rx635_cur."!cursor_pos"(rx635_pos)
    new $P643, "String"
    assign $P643, "module"
    store_lex "$*PKGDECL", $P643
.annotate 'line', 316
  # rx subcapture "sym"
    set_addr $I10, rxcap_644_fail
    rx635_cur."!mark_push"(0, rx635_pos, $I10)
  # rx literal  "module"
    add $I11, rx635_pos, 6
    gt $I11, rx635_eos, rx635_fail
    sub $I11, rx635_pos, rx635_off
    substr $S10, rx635_tgt, $I11, 6
    ne $S10, "module", rx635_fail
    add rx635_pos, 6
    set_addr $I10, rxcap_644_fail
    ($I12, $I11) = rx635_cur."!mark_peek"($I10)
    rx635_cur."!cursor_pos"($I11)
    ($P10) = rx635_cur."!cursor_start"()
    $P10."!cursor_pass"(rx635_pos, "")
    rx635_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_644_done
  rxcap_644_fail:
    goto rx635_fail
  rxcap_644_done:
  # rx subrule "package_def" subtype=capture negate=
    rx635_cur."!cursor_pos"(rx635_pos)
    $P10 = rx635_cur."package_def"()
    unless $P10, rx635_fail
    rx635_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx635_pos = $P10."pos"()
.annotate 'line', 312
  # rx pass
    rx635_cur."!cursor_pass"(rx635_pos, "package_declarator:sym<module>")
    if_null rx635_debug, debug_863
    rx635_cur."!cursor_debug"("PASS", "package_declarator:sym<module>", " at pos=", rx635_pos)
  debug_863:
    .return (rx635_cur)
  rx635_restart:
.annotate 'line', 10
    if_null rx635_debug, debug_864
    rx635_cur."!cursor_debug"("NEXT", "package_declarator:sym<module>")
  debug_864:
  rx635_fail:
    (rx635_rep, rx635_pos, $I10, $P10) = rx635_cur."!mark_fail"(0)
    lt rx635_pos, -1, rx635_done
    eq rx635_pos, -1, rx635_fail
    jump $I10
  rx635_done:
    rx635_cur."!cursor_fail"()
    if_null rx635_debug, debug_865
    rx635_cur."!cursor_debug"("FAIL", "package_declarator:sym<module>")
  debug_865:
    .return (rx635_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<module>"  :nsentry("!PREFIX__package_declarator:sym<module>") :subid("141_1303401201.841") :method
.annotate 'line', 10
    $P637 = self."!PREFIX__!subrule"("package_def", "module")
    new $P638, "ResizablePMCArray"
    push $P638, $P637
    .return ($P638)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<knowhow>"  :subid("142_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 319
    new $P646, "Undef"
    .lex "$*OUTERPACKAGE", $P646
.annotate 'line', 320
    new $P647, "Undef"
    .lex "$*PACKAGE-SETUP", $P647
.annotate 'line', 321
    new $P648, "Undef"
    .lex "$*PKGDECL", $P648
.annotate 'line', 10
    .local string rx649_tgt
    .local int rx649_pos
    .local int rx649_off
    .local int rx649_eos
    .local int rx649_rep
    .local pmc rx649_cur
    .local pmc rx649_debug
    (rx649_cur, rx649_pos, rx649_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx649_cur
    .local pmc match
    .lex "$/", match
    length rx649_eos, rx649_tgt
    gt rx649_pos, rx649_eos, rx649_done
    set rx649_off, 0
    lt rx649_pos, 2, rx649_start
    sub rx649_off, rx649_pos, 1
    substr rx649_tgt, rx649_tgt, rx649_off
  rx649_start:
    eq $I10, 1, rx649_restart
    if_null rx649_debug, debug_866
    rx649_cur."!cursor_debug"("START", "package_declarator:sym<knowhow>")
  debug_866:
    $I10 = self.'from'()
    ne $I10, -1, rxscan653_done
    goto rxscan653_scan
  rxscan653_loop:
    (rx649_pos) = rx649_cur."from"()
    inc rx649_pos
    rx649_cur."!cursor_from"(rx649_pos)
    ge rx649_pos, rx649_eos, rxscan653_done
  rxscan653_scan:
    set_addr $I10, rxscan653_loop
    rx649_cur."!mark_push"(0, rx649_pos, $I10)
  rxscan653_done:
.annotate 'line', 319
    rx649_cur."!cursor_pos"(rx649_pos)
    find_dynamic_lex $P654, "$*PACKAGE"
    unless_null $P654, vivify_867
    get_hll_global $P654, "$PACKAGE"
    unless_null $P654, vivify_868
    die "Contextual $*PACKAGE not found"
  vivify_868:
  vivify_867:
    store_lex "$*OUTERPACKAGE", $P654
.annotate 'line', 320
    rx649_cur."!cursor_pos"(rx649_pos)
    get_hll_global $P655, ["PAST"], "Stmts"
    $P656 = $P655."new"()
    store_lex "$*PACKAGE-SETUP", $P656
.annotate 'line', 321
    rx649_cur."!cursor_pos"(rx649_pos)
    new $P657, "String"
    assign $P657, "knowhow"
    store_lex "$*PKGDECL", $P657
.annotate 'line', 322
  # rx subcapture "sym"
    set_addr $I10, rxcap_658_fail
    rx649_cur."!mark_push"(0, rx649_pos, $I10)
  # rx literal  "knowhow"
    add $I11, rx649_pos, 7
    gt $I11, rx649_eos, rx649_fail
    sub $I11, rx649_pos, rx649_off
    substr $S10, rx649_tgt, $I11, 7
    ne $S10, "knowhow", rx649_fail
    add rx649_pos, 7
    set_addr $I10, rxcap_658_fail
    ($I12, $I11) = rx649_cur."!mark_peek"($I10)
    rx649_cur."!cursor_pos"($I11)
    ($P10) = rx649_cur."!cursor_start"()
    $P10."!cursor_pass"(rx649_pos, "")
    rx649_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_658_done
  rxcap_658_fail:
    goto rx649_fail
  rxcap_658_done:
  # rx subrule "package_def" subtype=capture negate=
    rx649_cur."!cursor_pos"(rx649_pos)
    $P10 = rx649_cur."package_def"()
    unless $P10, rx649_fail
    rx649_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx649_pos = $P10."pos"()
.annotate 'line', 318
  # rx pass
    rx649_cur."!cursor_pass"(rx649_pos, "package_declarator:sym<knowhow>")
    if_null rx649_debug, debug_869
    rx649_cur."!cursor_debug"("PASS", "package_declarator:sym<knowhow>", " at pos=", rx649_pos)
  debug_869:
    .return (rx649_cur)
  rx649_restart:
.annotate 'line', 10
    if_null rx649_debug, debug_870
    rx649_cur."!cursor_debug"("NEXT", "package_declarator:sym<knowhow>")
  debug_870:
  rx649_fail:
    (rx649_rep, rx649_pos, $I10, $P10) = rx649_cur."!mark_fail"(0)
    lt rx649_pos, -1, rx649_done
    eq rx649_pos, -1, rx649_fail
    jump $I10
  rx649_done:
    rx649_cur."!cursor_fail"()
    if_null rx649_debug, debug_871
    rx649_cur."!cursor_debug"("FAIL", "package_declarator:sym<knowhow>")
  debug_871:
    .return (rx649_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<knowhow>"  :nsentry("!PREFIX__package_declarator:sym<knowhow>") :subid("143_1303401201.841") :method
.annotate 'line', 10
    $P651 = self."!PREFIX__!subrule"("package_def", "knowhow")
    new $P652, "ResizablePMCArray"
    push $P652, $P651
    .return ($P652)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<class>"  :subid("144_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 325
    new $P660, "Undef"
    .lex "$*OUTERPACKAGE", $P660
.annotate 'line', 326
    new $P661, "Undef"
    .lex "$*PACKAGE-SETUP", $P661
.annotate 'line', 327
    new $P662, "Undef"
    .lex "$*PKGDECL", $P662
.annotate 'line', 10
    .local string rx663_tgt
    .local int rx663_pos
    .local int rx663_off
    .local int rx663_eos
    .local int rx663_rep
    .local pmc rx663_cur
    .local pmc rx663_debug
    (rx663_cur, rx663_pos, rx663_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx663_cur
    .local pmc match
    .lex "$/", match
    length rx663_eos, rx663_tgt
    gt rx663_pos, rx663_eos, rx663_done
    set rx663_off, 0
    lt rx663_pos, 2, rx663_start
    sub rx663_off, rx663_pos, 1
    substr rx663_tgt, rx663_tgt, rx663_off
  rx663_start:
    eq $I10, 1, rx663_restart
    if_null rx663_debug, debug_872
    rx663_cur."!cursor_debug"("START", "package_declarator:sym<class>")
  debug_872:
    $I10 = self.'from'()
    ne $I10, -1, rxscan667_done
    goto rxscan667_scan
  rxscan667_loop:
    (rx663_pos) = rx663_cur."from"()
    inc rx663_pos
    rx663_cur."!cursor_from"(rx663_pos)
    ge rx663_pos, rx663_eos, rxscan667_done
  rxscan667_scan:
    set_addr $I10, rxscan667_loop
    rx663_cur."!mark_push"(0, rx663_pos, $I10)
  rxscan667_done:
.annotate 'line', 325
    rx663_cur."!cursor_pos"(rx663_pos)
    find_dynamic_lex $P668, "$*PACKAGE"
    unless_null $P668, vivify_873
    get_hll_global $P668, "$PACKAGE"
    unless_null $P668, vivify_874
    die "Contextual $*PACKAGE not found"
  vivify_874:
  vivify_873:
    store_lex "$*OUTERPACKAGE", $P668
.annotate 'line', 326
    rx663_cur."!cursor_pos"(rx663_pos)
    get_hll_global $P669, ["PAST"], "Stmts"
    $P670 = $P669."new"()
    store_lex "$*PACKAGE-SETUP", $P670
.annotate 'line', 327
    rx663_cur."!cursor_pos"(rx663_pos)
    new $P671, "String"
    assign $P671, "class"
    store_lex "$*PKGDECL", $P671
.annotate 'line', 328
  # rx subcapture "sym"
    set_addr $I10, rxcap_672_fail
    rx663_cur."!mark_push"(0, rx663_pos, $I10)
  # rx literal  "class"
    add $I11, rx663_pos, 5
    gt $I11, rx663_eos, rx663_fail
    sub $I11, rx663_pos, rx663_off
    substr $S10, rx663_tgt, $I11, 5
    ne $S10, "class", rx663_fail
    add rx663_pos, 5
    set_addr $I10, rxcap_672_fail
    ($I12, $I11) = rx663_cur."!mark_peek"($I10)
    rx663_cur."!cursor_pos"($I11)
    ($P10) = rx663_cur."!cursor_start"()
    $P10."!cursor_pass"(rx663_pos, "")
    rx663_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_672_done
  rxcap_672_fail:
    goto rx663_fail
  rxcap_672_done:
  # rx subrule "package_def" subtype=capture negate=
    rx663_cur."!cursor_pos"(rx663_pos)
    $P10 = rx663_cur."package_def"()
    unless $P10, rx663_fail
    rx663_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx663_pos = $P10."pos"()
.annotate 'line', 324
  # rx pass
    rx663_cur."!cursor_pass"(rx663_pos, "package_declarator:sym<class>")
    if_null rx663_debug, debug_875
    rx663_cur."!cursor_debug"("PASS", "package_declarator:sym<class>", " at pos=", rx663_pos)
  debug_875:
    .return (rx663_cur)
  rx663_restart:
.annotate 'line', 10
    if_null rx663_debug, debug_876
    rx663_cur."!cursor_debug"("NEXT", "package_declarator:sym<class>")
  debug_876:
  rx663_fail:
    (rx663_rep, rx663_pos, $I10, $P10) = rx663_cur."!mark_fail"(0)
    lt rx663_pos, -1, rx663_done
    eq rx663_pos, -1, rx663_fail
    jump $I10
  rx663_done:
    rx663_cur."!cursor_fail"()
    if_null rx663_debug, debug_877
    rx663_cur."!cursor_debug"("FAIL", "package_declarator:sym<class>")
  debug_877:
    .return (rx663_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<class>"  :nsentry("!PREFIX__package_declarator:sym<class>") :subid("145_1303401201.841") :method
.annotate 'line', 10
    $P665 = self."!PREFIX__!subrule"("package_def", "class")
    new $P666, "ResizablePMCArray"
    push $P666, $P665
    .return ($P666)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<grammar>"  :subid("146_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 331
    new $P674, "Undef"
    .lex "$*OUTERPACKAGE", $P674
.annotate 'line', 332
    new $P675, "Undef"
    .lex "$*PACKAGE-SETUP", $P675
.annotate 'line', 333
    new $P676, "Undef"
    .lex "$*PKGDECL", $P676
.annotate 'line', 10
    .local string rx677_tgt
    .local int rx677_pos
    .local int rx677_off
    .local int rx677_eos
    .local int rx677_rep
    .local pmc rx677_cur
    .local pmc rx677_debug
    (rx677_cur, rx677_pos, rx677_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx677_cur
    .local pmc match
    .lex "$/", match
    length rx677_eos, rx677_tgt
    gt rx677_pos, rx677_eos, rx677_done
    set rx677_off, 0
    lt rx677_pos, 2, rx677_start
    sub rx677_off, rx677_pos, 1
    substr rx677_tgt, rx677_tgt, rx677_off
  rx677_start:
    eq $I10, 1, rx677_restart
    if_null rx677_debug, debug_878
    rx677_cur."!cursor_debug"("START", "package_declarator:sym<grammar>")
  debug_878:
    $I10 = self.'from'()
    ne $I10, -1, rxscan681_done
    goto rxscan681_scan
  rxscan681_loop:
    (rx677_pos) = rx677_cur."from"()
    inc rx677_pos
    rx677_cur."!cursor_from"(rx677_pos)
    ge rx677_pos, rx677_eos, rxscan681_done
  rxscan681_scan:
    set_addr $I10, rxscan681_loop
    rx677_cur."!mark_push"(0, rx677_pos, $I10)
  rxscan681_done:
.annotate 'line', 331
    rx677_cur."!cursor_pos"(rx677_pos)
    find_dynamic_lex $P682, "$*PACKAGE"
    unless_null $P682, vivify_879
    get_hll_global $P682, "$PACKAGE"
    unless_null $P682, vivify_880
    die "Contextual $*PACKAGE not found"
  vivify_880:
  vivify_879:
    store_lex "$*OUTERPACKAGE", $P682
.annotate 'line', 332
    rx677_cur."!cursor_pos"(rx677_pos)
    get_hll_global $P683, ["PAST"], "Stmts"
    $P684 = $P683."new"()
    store_lex "$*PACKAGE-SETUP", $P684
.annotate 'line', 333
    rx677_cur."!cursor_pos"(rx677_pos)
    new $P685, "String"
    assign $P685, "grammar"
    store_lex "$*PKGDECL", $P685
.annotate 'line', 334
  # rx subcapture "sym"
    set_addr $I10, rxcap_686_fail
    rx677_cur."!mark_push"(0, rx677_pos, $I10)
  # rx literal  "grammar"
    add $I11, rx677_pos, 7
    gt $I11, rx677_eos, rx677_fail
    sub $I11, rx677_pos, rx677_off
    substr $S10, rx677_tgt, $I11, 7
    ne $S10, "grammar", rx677_fail
    add rx677_pos, 7
    set_addr $I10, rxcap_686_fail
    ($I12, $I11) = rx677_cur."!mark_peek"($I10)
    rx677_cur."!cursor_pos"($I11)
    ($P10) = rx677_cur."!cursor_start"()
    $P10."!cursor_pass"(rx677_pos, "")
    rx677_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_686_done
  rxcap_686_fail:
    goto rx677_fail
  rxcap_686_done:
  # rx subrule "package_def" subtype=capture negate=
    rx677_cur."!cursor_pos"(rx677_pos)
    $P10 = rx677_cur."package_def"()
    unless $P10, rx677_fail
    rx677_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx677_pos = $P10."pos"()
.annotate 'line', 330
  # rx pass
    rx677_cur."!cursor_pass"(rx677_pos, "package_declarator:sym<grammar>")
    if_null rx677_debug, debug_881
    rx677_cur."!cursor_debug"("PASS", "package_declarator:sym<grammar>", " at pos=", rx677_pos)
  debug_881:
    .return (rx677_cur)
  rx677_restart:
.annotate 'line', 10
    if_null rx677_debug, debug_882
    rx677_cur."!cursor_debug"("NEXT", "package_declarator:sym<grammar>")
  debug_882:
  rx677_fail:
    (rx677_rep, rx677_pos, $I10, $P10) = rx677_cur."!mark_fail"(0)
    lt rx677_pos, -1, rx677_done
    eq rx677_pos, -1, rx677_fail
    jump $I10
  rx677_done:
    rx677_cur."!cursor_fail"()
    if_null rx677_debug, debug_883
    rx677_cur."!cursor_debug"("FAIL", "package_declarator:sym<grammar>")
  debug_883:
    .return (rx677_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<grammar>"  :nsentry("!PREFIX__package_declarator:sym<grammar>") :subid("147_1303401201.841") :method
.annotate 'line', 10
    $P679 = self."!PREFIX__!subrule"("package_def", "grammar")
    new $P680, "ResizablePMCArray"
    push $P680, $P679
    .return ($P680)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<role>"  :subid("148_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 337
    new $P688, "Undef"
    .lex "$*OUTERPACKAGE", $P688
.annotate 'line', 338
    new $P689, "Undef"
    .lex "$*PACKAGE-SETUP", $P689
.annotate 'line', 339
    new $P690, "Undef"
    .lex "$*PKGDECL", $P690
.annotate 'line', 10
    .local string rx691_tgt
    .local int rx691_pos
    .local int rx691_off
    .local int rx691_eos
    .local int rx691_rep
    .local pmc rx691_cur
    .local pmc rx691_debug
    (rx691_cur, rx691_pos, rx691_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx691_cur
    .local pmc match
    .lex "$/", match
    length rx691_eos, rx691_tgt
    gt rx691_pos, rx691_eos, rx691_done
    set rx691_off, 0
    lt rx691_pos, 2, rx691_start
    sub rx691_off, rx691_pos, 1
    substr rx691_tgt, rx691_tgt, rx691_off
  rx691_start:
    eq $I10, 1, rx691_restart
    if_null rx691_debug, debug_884
    rx691_cur."!cursor_debug"("START", "package_declarator:sym<role>")
  debug_884:
    $I10 = self.'from'()
    ne $I10, -1, rxscan695_done
    goto rxscan695_scan
  rxscan695_loop:
    (rx691_pos) = rx691_cur."from"()
    inc rx691_pos
    rx691_cur."!cursor_from"(rx691_pos)
    ge rx691_pos, rx691_eos, rxscan695_done
  rxscan695_scan:
    set_addr $I10, rxscan695_loop
    rx691_cur."!mark_push"(0, rx691_pos, $I10)
  rxscan695_done:
.annotate 'line', 337
    rx691_cur."!cursor_pos"(rx691_pos)
    find_dynamic_lex $P696, "$*PACKAGE"
    unless_null $P696, vivify_885
    get_hll_global $P696, "$PACKAGE"
    unless_null $P696, vivify_886
    die "Contextual $*PACKAGE not found"
  vivify_886:
  vivify_885:
    store_lex "$*OUTERPACKAGE", $P696
.annotate 'line', 338
    rx691_cur."!cursor_pos"(rx691_pos)
    get_hll_global $P697, ["PAST"], "Stmts"
    $P698 = $P697."new"()
    store_lex "$*PACKAGE-SETUP", $P698
.annotate 'line', 339
    rx691_cur."!cursor_pos"(rx691_pos)
    new $P699, "String"
    assign $P699, "role"
    store_lex "$*PKGDECL", $P699
.annotate 'line', 340
  # rx subcapture "sym"
    set_addr $I10, rxcap_700_fail
    rx691_cur."!mark_push"(0, rx691_pos, $I10)
  # rx literal  "role"
    add $I11, rx691_pos, 4
    gt $I11, rx691_eos, rx691_fail
    sub $I11, rx691_pos, rx691_off
    substr $S10, rx691_tgt, $I11, 4
    ne $S10, "role", rx691_fail
    add rx691_pos, 4
    set_addr $I10, rxcap_700_fail
    ($I12, $I11) = rx691_cur."!mark_peek"($I10)
    rx691_cur."!cursor_pos"($I11)
    ($P10) = rx691_cur."!cursor_start"()
    $P10."!cursor_pass"(rx691_pos, "")
    rx691_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_700_done
  rxcap_700_fail:
    goto rx691_fail
  rxcap_700_done:
  # rx subrule "package_def" subtype=capture negate=
    rx691_cur."!cursor_pos"(rx691_pos)
    $P10 = rx691_cur."package_def"()
    unless $P10, rx691_fail
    rx691_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx691_pos = $P10."pos"()
.annotate 'line', 336
  # rx pass
    rx691_cur."!cursor_pass"(rx691_pos, "package_declarator:sym<role>")
    if_null rx691_debug, debug_887
    rx691_cur."!cursor_debug"("PASS", "package_declarator:sym<role>", " at pos=", rx691_pos)
  debug_887:
    .return (rx691_cur)
  rx691_restart:
.annotate 'line', 10
    if_null rx691_debug, debug_888
    rx691_cur."!cursor_debug"("NEXT", "package_declarator:sym<role>")
  debug_888:
  rx691_fail:
    (rx691_rep, rx691_pos, $I10, $P10) = rx691_cur."!mark_fail"(0)
    lt rx691_pos, -1, rx691_done
    eq rx691_pos, -1, rx691_fail
    jump $I10
  rx691_done:
    rx691_cur."!cursor_fail"()
    if_null rx691_debug, debug_889
    rx691_cur."!cursor_debug"("FAIL", "package_declarator:sym<role>")
  debug_889:
    .return (rx691_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<role>"  :nsentry("!PREFIX__package_declarator:sym<role>") :subid("149_1303401201.841") :method
.annotate 'line', 10
    $P693 = self."!PREFIX__!subrule"("package_def", "role")
    new $P694, "ResizablePMCArray"
    push $P694, $P693
    .return ($P694)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<native>"  :subid("150_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 343
    new $P702, "Undef"
    .lex "$*OUTERPACKAGE", $P702
.annotate 'line', 344
    new $P703, "Undef"
    .lex "$*PACKAGE-SETUP", $P703
.annotate 'line', 345
    new $P704, "Undef"
    .lex "$*PKGDECL", $P704
.annotate 'line', 10
    .local string rx705_tgt
    .local int rx705_pos
    .local int rx705_off
    .local int rx705_eos
    .local int rx705_rep
    .local pmc rx705_cur
    .local pmc rx705_debug
    (rx705_cur, rx705_pos, rx705_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx705_cur
    .local pmc match
    .lex "$/", match
    length rx705_eos, rx705_tgt
    gt rx705_pos, rx705_eos, rx705_done
    set rx705_off, 0
    lt rx705_pos, 2, rx705_start
    sub rx705_off, rx705_pos, 1
    substr rx705_tgt, rx705_tgt, rx705_off
  rx705_start:
    eq $I10, 1, rx705_restart
    if_null rx705_debug, debug_890
    rx705_cur."!cursor_debug"("START", "package_declarator:sym<native>")
  debug_890:
    $I10 = self.'from'()
    ne $I10, -1, rxscan709_done
    goto rxscan709_scan
  rxscan709_loop:
    (rx705_pos) = rx705_cur."from"()
    inc rx705_pos
    rx705_cur."!cursor_from"(rx705_pos)
    ge rx705_pos, rx705_eos, rxscan709_done
  rxscan709_scan:
    set_addr $I10, rxscan709_loop
    rx705_cur."!mark_push"(0, rx705_pos, $I10)
  rxscan709_done:
.annotate 'line', 343
    rx705_cur."!cursor_pos"(rx705_pos)
    find_dynamic_lex $P710, "$*PACKAGE"
    unless_null $P710, vivify_891
    get_hll_global $P710, "$PACKAGE"
    unless_null $P710, vivify_892
    die "Contextual $*PACKAGE not found"
  vivify_892:
  vivify_891:
    store_lex "$*OUTERPACKAGE", $P710
.annotate 'line', 344
    rx705_cur."!cursor_pos"(rx705_pos)
    get_hll_global $P711, ["PAST"], "Stmts"
    $P712 = $P711."new"()
    store_lex "$*PACKAGE-SETUP", $P712
.annotate 'line', 345
    rx705_cur."!cursor_pos"(rx705_pos)
    new $P713, "String"
    assign $P713, "native"
    store_lex "$*PKGDECL", $P713
.annotate 'line', 346
  # rx subcapture "sym"
    set_addr $I10, rxcap_714_fail
    rx705_cur."!mark_push"(0, rx705_pos, $I10)
  # rx literal  "native"
    add $I11, rx705_pos, 6
    gt $I11, rx705_eos, rx705_fail
    sub $I11, rx705_pos, rx705_off
    substr $S10, rx705_tgt, $I11, 6
    ne $S10, "native", rx705_fail
    add rx705_pos, 6
    set_addr $I10, rxcap_714_fail
    ($I12, $I11) = rx705_cur."!mark_peek"($I10)
    rx705_cur."!cursor_pos"($I11)
    ($P10) = rx705_cur."!cursor_start"()
    $P10."!cursor_pass"(rx705_pos, "")
    rx705_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_714_done
  rxcap_714_fail:
    goto rx705_fail
  rxcap_714_done:
  # rx subrule "package_def" subtype=capture negate=
    rx705_cur."!cursor_pos"(rx705_pos)
    $P10 = rx705_cur."package_def"()
    unless $P10, rx705_fail
    rx705_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx705_pos = $P10."pos"()
.annotate 'line', 342
  # rx pass
    rx705_cur."!cursor_pass"(rx705_pos, "package_declarator:sym<native>")
    if_null rx705_debug, debug_893
    rx705_cur."!cursor_debug"("PASS", "package_declarator:sym<native>", " at pos=", rx705_pos)
  debug_893:
    .return (rx705_cur)
  rx705_restart:
.annotate 'line', 10
    if_null rx705_debug, debug_894
    rx705_cur."!cursor_debug"("NEXT", "package_declarator:sym<native>")
  debug_894:
  rx705_fail:
    (rx705_rep, rx705_pos, $I10, $P10) = rx705_cur."!mark_fail"(0)
    lt rx705_pos, -1, rx705_done
    eq rx705_pos, -1, rx705_fail
    jump $I10
  rx705_done:
    rx705_cur."!cursor_fail"()
    if_null rx705_debug, debug_895
    rx705_cur."!cursor_debug"("FAIL", "package_declarator:sym<native>")
  debug_895:
    .return (rx705_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<native>"  :nsentry("!PREFIX__package_declarator:sym<native>") :subid("151_1303401201.841") :method
.annotate 'line', 10
    $P707 = self."!PREFIX__!subrule"("package_def", "native")
    new $P708, "ResizablePMCArray"
    push $P708, $P707
    .return ($P708)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_def"  :subid("152_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .const 'Sub' $P739 = "154_1303401201.841" 
    capture_lex $P739
.annotate 'line', 350
    new $P716, "Undef"
    .lex "$*PACKAGE", $P716
.annotate 'line', 351
    $P717 = root_new ['parrot';'Hash']
    .lex "%*ATTR-CHECK", $P717
.annotate 'line', 10
    .local string rx718_tgt
    .local int rx718_pos
    .local int rx718_off
    .local int rx718_eos
    .local int rx718_rep
    .local pmc rx718_cur
    .local pmc rx718_debug
    (rx718_cur, rx718_pos, rx718_tgt, $I10) = self."!cursor_start"()
    rx718_cur."!cursor_caparray"("repr", "parent", "role")
    .lex unicode:"$\x{a2}", rx718_cur
    .local pmc match
    .lex "$/", match
    length rx718_eos, rx718_tgt
    gt rx718_pos, rx718_eos, rx718_done
    set rx718_off, 0
    lt rx718_pos, 2, rx718_start
    sub rx718_off, rx718_pos, 1
    substr rx718_tgt, rx718_tgt, rx718_off
  rx718_start:
    eq $I10, 1, rx718_restart
    if_null rx718_debug, debug_896
    rx718_cur."!cursor_debug"("START", "package_def")
  debug_896:
    $I10 = self.'from'()
    ne $I10, -1, rxscan722_done
    goto rxscan722_scan
  rxscan722_loop:
    (rx718_pos) = rx718_cur."from"()
    inc rx718_pos
    rx718_cur."!cursor_from"(rx718_pos)
    ge rx718_pos, rx718_eos, rxscan722_done
  rxscan722_scan:
    set_addr $I10, rxscan722_loop
    rx718_cur."!mark_push"(0, rx718_pos, $I10)
  rxscan722_done:
.annotate 'line', 349
  # rx subrule "ws" subtype=method negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."ws"()
    unless $P10, rx718_fail
    rx718_pos = $P10."pos"()
.annotate 'line', 350
    rx718_cur."!cursor_pos"(rx718_pos)
    find_lex $P724, "$*PACKAGE"
    unless_null $P724, vivify_897
    get_hll_global $P724, "$PACKAGE"
    unless_null $P724, vivify_898
    die "Contextual $*PACKAGE not found"
  vivify_898:
  vivify_897:
  # rx subrule "ws" subtype=method negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."ws"()
    unless $P10, rx718_fail
    rx718_pos = $P10."pos"()
.annotate 'line', 351
    rx718_cur."!cursor_pos"(rx718_pos)
    find_lex $P726, "%*ATTR-CHECK"
    unless_null $P726, vivify_899
    get_hll_global $P726, "%ATTR-CHECK"
    unless_null $P726, vivify_900
    die "Contextual %*ATTR-CHECK not found"
  vivify_900:
  vivify_899:
  # rx subrule "ws" subtype=method negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."ws"()
    unless $P10, rx718_fail
    rx718_pos = $P10."pos"()
.annotate 'line', 353
  # rx subrule "name" subtype=capture negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."name"()
    unless $P10, rx718_fail
    rx718_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx718_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."ws"()
    unless $P10, rx718_fail
    rx718_pos = $P10."pos"()
.annotate 'line', 354
  # rx rxquantr729 ** 0..1
    set_addr $I10, rxquantr729_done
    rx718_cur."!mark_push"(0, rx718_pos, $I10)
  rxquantr729_loop:
  # rx subrule "ws" subtype=method negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."ws"()
    unless $P10, rx718_fail
    rx718_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx718_pos, 2
    gt $I11, rx718_eos, rx718_fail
    sub $I11, rx718_pos, rx718_off
    substr $S10, rx718_tgt, $I11, 2
    ne $S10, "is", rx718_fail
    add rx718_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."ws"()
    unless $P10, rx718_fail
    rx718_pos = $P10."pos"()
  # rx literal  "repr("
    add $I11, rx718_pos, 5
    gt $I11, rx718_eos, rx718_fail
    sub $I11, rx718_pos, rx718_off
    substr $S10, rx718_tgt, $I11, 5
    ne $S10, "repr(", rx718_fail
    add rx718_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."ws"()
    unless $P10, rx718_fail
    rx718_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."quote_EXPR"()
    unless $P10, rx718_fail
    rx718_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("repr")
    rx718_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."ws"()
    unless $P10, rx718_fail
    rx718_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx718_pos, 1
    gt $I11, rx718_eos, rx718_fail
    sub $I11, rx718_pos, rx718_off
    ord $I11, rx718_tgt, $I11
    ne $I11, 41, rx718_fail
    add rx718_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."ws"()
    unless $P10, rx718_fail
    rx718_pos = $P10."pos"()
    set_addr $I10, rxquantr729_done
    (rx718_rep) = rx718_cur."!mark_commit"($I10)
  rxquantr729_done:
  # rx subrule "ws" subtype=method negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."ws"()
    unless $P10, rx718_fail
    rx718_pos = $P10."pos"()
.annotate 'line', 356
    rx718_cur."!cursor_pos"(rx718_pos)
    find_lex $P736, unicode:"$\x{a2}"
    $P737 = $P736."MATCH"()
    store_lex "$/", $P737
    .const 'Sub' $P739 = "154_1303401201.841" 
    capture_lex $P739
    $P829 = $P739()
.annotate 'line', 382
  # rx subrule "ws" subtype=method negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."ws"()
    unless $P10, rx718_fail
    rx718_pos = $P10."pos"()
.annotate 'line', 384
  # rx rxquantr831 ** 0..1
    set_addr $I10, rxquantr831_done
    rx718_cur."!mark_push"(0, rx718_pos, $I10)
  rxquantr831_loop:
  # rx subrule "ws" subtype=method negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."ws"()
    unless $P10, rx718_fail
    rx718_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx718_pos, 2
    gt $I11, rx718_eos, rx718_fail
    sub $I11, rx718_pos, rx718_off
    substr $S10, rx718_tgt, $I11, 2
    ne $S10, "is", rx718_fail
    add rx718_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."ws"()
    unless $P10, rx718_fail
    rx718_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."name"()
    unless $P10, rx718_fail
    rx718_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parent")
    rx718_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."ws"()
    unless $P10, rx718_fail
    rx718_pos = $P10."pos"()
    set_addr $I10, rxquantr831_done
    (rx718_rep) = rx718_cur."!mark_commit"($I10)
  rxquantr831_done:
  # rx subrule "ws" subtype=method negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."ws"()
    unless $P10, rx718_fail
    rx718_pos = $P10."pos"()
.annotate 'line', 385
  # rx rxquantr836 ** 0..*
    set_addr $I10, rxquantr836_done
    rx718_cur."!mark_push"(0, rx718_pos, $I10)
  rxquantr836_loop:
  # rx subrule "ws" subtype=method negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."ws"()
    unless $P10, rx718_fail
    rx718_pos = $P10."pos"()
  # rx literal  "does"
    add $I11, rx718_pos, 4
    gt $I11, rx718_eos, rx718_fail
    sub $I11, rx718_pos, rx718_off
    substr $S10, rx718_tgt, $I11, 4
    ne $S10, "does", rx718_fail
    add rx718_pos, 4
  # rx subrule "ws" subtype=method negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."ws"()
    unless $P10, rx718_fail
    rx718_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."name"()
    unless $P10, rx718_fail
    rx718_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("role")
    rx718_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."ws"()
    unless $P10, rx718_fail
    rx718_pos = $P10."pos"()
    set_addr $I10, rxquantr836_done
    (rx718_rep) = rx718_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr836_done
    rx718_cur."!mark_push"(rx718_rep, rx718_pos, $I10)
    goto rxquantr836_loop
  rxquantr836_done:
  # rx subrule "ws" subtype=method negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."ws"()
    unless $P10, rx718_fail
    rx718_pos = $P10."pos"()
  alt841_0:
.annotate 'line', 386
    set_addr $I10, alt841_1
    rx718_cur."!mark_push"(0, rx718_pos, $I10)
.annotate 'line', 387
  # rx subrule "ws" subtype=method negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."ws"()
    unless $P10, rx718_fail
    rx718_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx718_pos, 1
    gt $I11, rx718_eos, rx718_fail
    sub $I11, rx718_pos, rx718_off
    ord $I11, rx718_tgt, $I11
    ne $I11, 59, rx718_fail
    add rx718_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."ws"()
    unless $P10, rx718_fail
    rx718_pos = $P10."pos"()
  # rx subrule "comp_unit" subtype=capture negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."comp_unit"()
    unless $P10, rx718_fail
    rx718_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("comp_unit")
    rx718_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."ws"()
    unless $P10, rx718_fail
    rx718_pos = $P10."pos"()
    goto alt841_end
  alt841_1:
    set_addr $I10, alt841_2
    rx718_cur."!mark_push"(0, rx718_pos, $I10)
.annotate 'line', 388
  # rx subrule "ws" subtype=method negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."ws"()
    unless $P10, rx718_fail
    rx718_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx718_pos, rx718_off
    substr $S10, rx718_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx718_fail
  # rx subrule "ws" subtype=method negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."ws"()
    unless $P10, rx718_fail
    rx718_pos = $P10."pos"()
  # rx subrule "block" subtype=capture negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."block"()
    unless $P10, rx718_fail
    rx718_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx718_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."ws"()
    unless $P10, rx718_fail
    rx718_pos = $P10."pos"()
    goto alt841_end
  alt841_2:
.annotate 'line', 389
  # rx subrule "ws" subtype=method negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."ws"()
    unless $P10, rx718_fail
    rx718_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."panic"("Malformed package declaration")
    unless $P10, rx718_fail
    rx718_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."ws"()
    unless $P10, rx718_fail
    rx718_pos = $P10."pos"()
  alt841_end:
.annotate 'line', 390
  # rx subrule "ws" subtype=method negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."ws"()
    unless $P10, rx718_fail
    rx718_pos = $P10."pos"()
.annotate 'line', 349
  # rx pass
    rx718_cur."!cursor_pass"(rx718_pos, "package_def")
    if_null rx718_debug, debug_968
    rx718_cur."!cursor_debug"("PASS", "package_def", " at pos=", rx718_pos)
  debug_968:
    .return (rx718_cur)
  rx718_restart:
.annotate 'line', 10
    if_null rx718_debug, debug_969
    rx718_cur."!cursor_debug"("NEXT", "package_def")
  debug_969:
  rx718_fail:
    (rx718_rep, rx718_pos, $I10, $P10) = rx718_cur."!mark_fail"(0)
    lt rx718_pos, -1, rx718_done
    eq rx718_pos, -1, rx718_fail
    jump $I10
  rx718_done:
    rx718_cur."!cursor_fail"()
    if_null rx718_debug, debug_970
    rx718_cur."!cursor_debug"("FAIL", "package_def")
  debug_970:
    .return (rx718_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_def"  :nsentry("!PREFIX__package_def") :subid("153_1303401201.841") :method
.annotate 'line', 10
    $P720 = self."!PREFIX__!subrule"("ws", "")
    new $P721, "ResizablePMCArray"
    push $P721, $P720
    .return ($P721)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block738"  :anon :subid("154_1303401201.841") :outer("152_1303401201.841")
.annotate 'line', 359
    $P740 = root_new ['parrot';'Hash']
    .lex "%args", $P740
.annotate 'line', 356
    find_lex $P741, "%args"
    unless_null $P741, vivify_901
    $P741 = root_new ['parrot';'Hash']
  vivify_901:
.annotate 'line', 360
    find_lex $P742, "$/"
    unless_null $P742, vivify_902
    $P742 = root_new ['parrot';'Hash']
  vivify_902:
    set $P743, $P742["name"]
    unless_null $P743, vivify_903
    new $P743, "Undef"
  vivify_903:
    set $S744, $P743
    new $P745, 'String'
    set $P745, $S744
    find_lex $P746, "%args"
    unless_null $P746, vivify_904
    $P746 = root_new ['parrot';'Hash']
    store_lex "%args", $P746
  vivify_904:
    set $P746["name"], $P745
.annotate 'line', 361
    find_lex $P748, "$/"
    unless_null $P748, vivify_905
    $P748 = root_new ['parrot';'Hash']
  vivify_905:
    set $P749, $P748["repr"]
    unless_null $P749, vivify_906
    new $P749, "Undef"
  vivify_906:
    unless $P749, if_747_end
.annotate 'line', 362
    find_lex $P750, "$/"
    unless_null $P750, vivify_907
    $P750 = root_new ['parrot';'Hash']
  vivify_907:
    set $P751, $P750["repr"]
    unless_null $P751, vivify_908
    $P751 = root_new ['parrot';'ResizablePMCArray']
  vivify_908:
    set $P752, $P751[0]
    unless_null $P752, vivify_909
    $P752 = root_new ['parrot';'Hash']
  vivify_909:
    set $P753, $P752["quote_delimited"]
    unless_null $P753, vivify_910
    $P753 = root_new ['parrot';'Hash']
  vivify_910:
    set $P754, $P753["quote_atom"]
    unless_null $P754, vivify_911
    $P754 = root_new ['parrot';'ResizablePMCArray']
  vivify_911:
    set $P755, $P754[0]
    unless_null $P755, vivify_912
    new $P755, "Undef"
  vivify_912:
    set $S756, $P755
    new $P757, 'String'
    set $P757, $S756
    find_lex $P758, "%args"
    unless_null $P758, vivify_913
    $P758 = root_new ['parrot';'Hash']
    store_lex "%args", $P758
  vivify_913:
    set $P758["repr"], $P757
  if_747_end:
.annotate 'line', 364
    find_dynamic_lex $P759, "$*SC"
    unless_null $P759, vivify_914
    get_hll_global $P759, "$SC"
    unless_null $P759, vivify_915
    die "Contextual $*SC not found"
  vivify_915:
  vivify_914:
    find_dynamic_lex $P760, "$*PKGDECL"
    unless_null $P760, vivify_916
    get_hll_global $P760, "$PKGDECL"
    unless_null $P760, vivify_917
    die "Contextual $*PKGDECL not found"
  vivify_917:
  vivify_916:
    find_dynamic_lex $P761, "%*HOW"
    unless_null $P761, vivify_918
    get_hll_global $P761, "%HOW"
    unless_null $P761, vivify_919
    die "Contextual %*HOW not found"
  vivify_919:
  vivify_918:
    set $P762, $P761[$P760]
    unless_null $P762, vivify_920
    new $P762, "Undef"
  vivify_920:
    find_lex $P763, "%args"
    unless_null $P763, vivify_921
    $P763 = root_new ['parrot';'Hash']
  vivify_921:
    $P764 = $P759."pkg_create_mo"($P762, $P763 :flat)
    store_dynamic_lex "$*PACKAGE", $P764
.annotate 'line', 367
    find_dynamic_lex $P769, "$*SCOPE"
    unless_null $P769, vivify_922
    get_hll_global $P769, "$SCOPE"
    unless_null $P769, vivify_923
    die "Contextual $*SCOPE not found"
  vivify_923:
  vivify_922:
    set $S770, $P769
    iseq $I771, $S770, "our"
    unless $I771, unless_768
    new $P767, 'Integer'
    set $P767, $I771
    goto unless_768_end
  unless_768:
    find_dynamic_lex $P772, "$*SCOPE"
    unless_null $P772, vivify_924
    get_hll_global $P772, "$SCOPE"
    unless_null $P772, vivify_925
    die "Contextual $*SCOPE not found"
  vivify_925:
  vivify_924:
    set $S773, $P772
    iseq $I774, $S773, ""
    new $P767, 'Integer'
    set $P767, $I774
  unless_768_end:
    if $P767, if_766
.annotate 'line', 373
    find_dynamic_lex $P801, "$*SCOPE"
    unless_null $P801, vivify_926
    get_hll_global $P801, "$SCOPE"
    unless_null $P801, vivify_927
    die "Contextual $*SCOPE not found"
  vivify_927:
  vivify_926:
    set $S802, $P801
    iseq $I803, $S802, "my"
    if $I803, if_800
.annotate 'line', 380
    find_lex $P824, "$/"
    unless_null $P824, vivify_928
    new $P824, "Undef"
  vivify_928:
    $P825 = $P824."CURSOR"()
    find_dynamic_lex $P826, "$*SCOPE"
    unless_null $P826, vivify_929
    get_hll_global $P826, "$SCOPE"
    unless_null $P826, vivify_930
    die "Contextual $*SCOPE not found"
  vivify_930:
  vivify_929:
    concat $P827, $P826, " scoped packages are not supported"
    $P828 = $P825."panic"($P827)
.annotate 'line', 379
    set $P799, $P828
.annotate 'line', 373
    goto if_800_end
  if_800:
.annotate 'line', 374
    find_lex $P805, "$/"
    unless_null $P805, vivify_931
    $P805 = root_new ['parrot';'Hash']
  vivify_931:
    set $P806, $P805["name"]
    unless_null $P806, vivify_932
    $P806 = root_new ['parrot';'Hash']
  vivify_932:
    set $P807, $P806["identifier"]
    unless_null $P807, vivify_933
    new $P807, "Undef"
  vivify_933:
    set $N808, $P807
    isne $I809, $N808, 1.0
    unless $I809, if_804_end
.annotate 'line', 375
    find_lex $P810, "$/"
    unless_null $P810, vivify_934
    $P810 = root_new ['parrot';'Hash']
  vivify_934:
    set $P811, $P810["name"]
    unless_null $P811, vivify_935
    new $P811, "Undef"
  vivify_935:
    $P812 = $P811."CURSOR"()
    $P812."panic"("A my scoped package cannot have a multi-part name yet")
  if_804_end:
.annotate 'line', 377
    find_dynamic_lex $P813, "$*SC"
    unless_null $P813, vivify_936
    get_hll_global $P813, "$SC"
    unless_null $P813, vivify_937
    die "Contextual $*SC not found"
  vivify_937:
  vivify_936:
    get_hll_global $P814, ["NQP"], "Actions"
    get_who $P815, $P814
    set $P816, $P815["@BLOCK"]
    unless_null $P816, vivify_938
    $P816 = root_new ['parrot';'ResizablePMCArray']
  vivify_938:
    set $P817, $P816[0]
    unless_null $P817, vivify_939
    new $P817, "Undef"
  vivify_939:
    find_lex $P818, "$/"
    unless_null $P818, vivify_940
    $P818 = root_new ['parrot';'Hash']
  vivify_940:
    set $P819, $P818["name"]
    unless_null $P819, vivify_941
    $P819 = root_new ['parrot';'Hash']
  vivify_941:
    set $P820, $P819["identifier"]
    unless_null $P820, vivify_942
    $P820 = root_new ['parrot';'ResizablePMCArray']
  vivify_942:
    set $P821, $P820[0]
    unless_null $P821, vivify_943
    new $P821, "Undef"
  vivify_943:
    find_dynamic_lex $P822, "$*PACKAGE"
    unless_null $P822, vivify_944
    get_hll_global $P822, "$PACKAGE"
    unless_null $P822, vivify_945
    die "Contextual $*PACKAGE not found"
  vivify_945:
  vivify_944:
    $P823 = $P813."install_lexical_symbol"($P817, $P821, $P822)
.annotate 'line', 373
    set $P799, $P823
  if_800_end:
    set $P765, $P799
.annotate 'line', 367
    goto if_766_end
  if_766:
.annotate 'line', 368
    find_dynamic_lex $P775, "$*SC"
    unless_null $P775, vivify_946
    get_hll_global $P775, "$SC"
    unless_null $P775, vivify_947
    die "Contextual $*SC not found"
  vivify_947:
  vivify_946:
    find_dynamic_lex $P776, "$*OUTERPACKAGE"
    unless_null $P776, vivify_948
    get_hll_global $P776, "$OUTERPACKAGE"
    unless_null $P776, vivify_949
    die "Contextual $*OUTERPACKAGE not found"
  vivify_949:
  vivify_948:
    find_lex $P777, "$/"
    unless_null $P777, vivify_950
    $P777 = root_new ['parrot';'Hash']
  vivify_950:
    set $P778, $P777["name"]
    unless_null $P778, vivify_951
    $P778 = root_new ['parrot';'Hash']
  vivify_951:
    set $P779, $P778["identifier"]
    unless_null $P779, vivify_952
    new $P779, "Undef"
  vivify_952:
    find_dynamic_lex $P780, "$*PACKAGE"
    unless_null $P780, vivify_953
    get_hll_global $P780, "$PACKAGE"
    unless_null $P780, vivify_954
    die "Contextual $*PACKAGE not found"
  vivify_954:
  vivify_953:
    $P775."install_package_symbol"($P776, $P779, $P780)
.annotate 'line', 369
    find_lex $P783, "$/"
    unless_null $P783, vivify_955
    $P783 = root_new ['parrot';'Hash']
  vivify_955:
    set $P784, $P783["name"]
    unless_null $P784, vivify_956
    $P784 = root_new ['parrot';'Hash']
  vivify_956:
    set $P785, $P784["identifier"]
    unless_null $P785, vivify_957
    new $P785, "Undef"
  vivify_957:
    set $N786, $P785
    iseq $I787, $N786, 1.0
    if $I787, if_782
    new $P781, 'Integer'
    set $P781, $I787
    goto if_782_end
  if_782:
.annotate 'line', 370
    find_dynamic_lex $P788, "$*SC"
    unless_null $P788, vivify_958
    get_hll_global $P788, "$SC"
    unless_null $P788, vivify_959
    die "Contextual $*SC not found"
  vivify_959:
  vivify_958:
    get_hll_global $P789, ["NQP"], "Actions"
    get_who $P790, $P789
    set $P791, $P790["@BLOCK"]
    unless_null $P791, vivify_960
    $P791 = root_new ['parrot';'ResizablePMCArray']
  vivify_960:
    set $P792, $P791[0]
    unless_null $P792, vivify_961
    new $P792, "Undef"
  vivify_961:
    find_lex $P793, "$/"
    unless_null $P793, vivify_962
    $P793 = root_new ['parrot';'Hash']
  vivify_962:
    set $P794, $P793["name"]
    unless_null $P794, vivify_963
    $P794 = root_new ['parrot';'Hash']
  vivify_963:
    set $P795, $P794["identifier"]
    unless_null $P795, vivify_964
    $P795 = root_new ['parrot';'ResizablePMCArray']
  vivify_964:
    set $P796, $P795[0]
    unless_null $P796, vivify_965
    new $P796, "Undef"
  vivify_965:
    find_dynamic_lex $P797, "$*PACKAGE"
    unless_null $P797, vivify_966
    get_hll_global $P797, "$PACKAGE"
    unless_null $P797, vivify_967
    die "Contextual $*PACKAGE not found"
  vivify_967:
  vivify_966:
    $P798 = $P788."install_lexical_symbol"($P792, $P796, $P797)
.annotate 'line', 369
    set $P781, $P798
  if_782_end:
.annotate 'line', 367
    set $P765, $P781
  if_766_end:
.annotate 'line', 356
    .return ($P765)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator"  :subid("155_1303401201.841")
    .param pmc param_852
.annotate 'line', 393
    .lex "self", param_852
    $P853 = param_852."!protoregex"("scope_declarator")
    .return ($P853)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator"  :subid("156_1303401201.841")
    .param pmc param_855
.annotate 'line', 393
    .lex "self", param_855
    $P856 = param_855."!PREFIX__!protoregex"("scope_declarator")
    .return ($P856)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<my>"  :subid("157_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx858_tgt
    .local int rx858_pos
    .local int rx858_off
    .local int rx858_eos
    .local int rx858_rep
    .local pmc rx858_cur
    .local pmc rx858_debug
    (rx858_cur, rx858_pos, rx858_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx858_cur
    .local pmc match
    .lex "$/", match
    length rx858_eos, rx858_tgt
    gt rx858_pos, rx858_eos, rx858_done
    set rx858_off, 0
    lt rx858_pos, 2, rx858_start
    sub rx858_off, rx858_pos, 1
    substr rx858_tgt, rx858_tgt, rx858_off
  rx858_start:
    eq $I10, 1, rx858_restart
    if_null rx858_debug, debug_971
    rx858_cur."!cursor_debug"("START", "scope_declarator:sym<my>")
  debug_971:
    $I10 = self.'from'()
    ne $I10, -1, rxscan862_done
    goto rxscan862_scan
  rxscan862_loop:
    (rx858_pos) = rx858_cur."from"()
    inc rx858_pos
    rx858_cur."!cursor_from"(rx858_pos)
    ge rx858_pos, rx858_eos, rxscan862_done
  rxscan862_scan:
    set_addr $I10, rxscan862_loop
    rx858_cur."!mark_push"(0, rx858_pos, $I10)
  rxscan862_done:
.annotate 'line', 394
  # rx subcapture "sym"
    set_addr $I10, rxcap_863_fail
    rx858_cur."!mark_push"(0, rx858_pos, $I10)
  # rx literal  "my"
    add $I11, rx858_pos, 2
    gt $I11, rx858_eos, rx858_fail
    sub $I11, rx858_pos, rx858_off
    substr $S10, rx858_tgt, $I11, 2
    ne $S10, "my", rx858_fail
    add rx858_pos, 2
    set_addr $I10, rxcap_863_fail
    ($I12, $I11) = rx858_cur."!mark_peek"($I10)
    rx858_cur."!cursor_pos"($I11)
    ($P10) = rx858_cur."!cursor_start"()
    $P10."!cursor_pass"(rx858_pos, "")
    rx858_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_863_done
  rxcap_863_fail:
    goto rx858_fail
  rxcap_863_done:
  # rx subrule "scoped" subtype=capture negate=
    rx858_cur."!cursor_pos"(rx858_pos)
    $P10 = rx858_cur."scoped"("my")
    unless $P10, rx858_fail
    rx858_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx858_pos = $P10."pos"()
  # rx pass
    rx858_cur."!cursor_pass"(rx858_pos, "scope_declarator:sym<my>")
    if_null rx858_debug, debug_972
    rx858_cur."!cursor_debug"("PASS", "scope_declarator:sym<my>", " at pos=", rx858_pos)
  debug_972:
    .return (rx858_cur)
  rx858_restart:
.annotate 'line', 10
    if_null rx858_debug, debug_973
    rx858_cur."!cursor_debug"("NEXT", "scope_declarator:sym<my>")
  debug_973:
  rx858_fail:
    (rx858_rep, rx858_pos, $I10, $P10) = rx858_cur."!mark_fail"(0)
    lt rx858_pos, -1, rx858_done
    eq rx858_pos, -1, rx858_fail
    jump $I10
  rx858_done:
    rx858_cur."!cursor_fail"()
    if_null rx858_debug, debug_974
    rx858_cur."!cursor_debug"("FAIL", "scope_declarator:sym<my>")
  debug_974:
    .return (rx858_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<my>"  :nsentry("!PREFIX__scope_declarator:sym<my>") :subid("158_1303401201.841") :method
.annotate 'line', 10
    $P860 = self."!PREFIX__!subrule"("scoped", "my")
    new $P861, "ResizablePMCArray"
    push $P861, $P860
    .return ($P861)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<our>"  :subid("159_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx865_tgt
    .local int rx865_pos
    .local int rx865_off
    .local int rx865_eos
    .local int rx865_rep
    .local pmc rx865_cur
    .local pmc rx865_debug
    (rx865_cur, rx865_pos, rx865_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx865_cur
    .local pmc match
    .lex "$/", match
    length rx865_eos, rx865_tgt
    gt rx865_pos, rx865_eos, rx865_done
    set rx865_off, 0
    lt rx865_pos, 2, rx865_start
    sub rx865_off, rx865_pos, 1
    substr rx865_tgt, rx865_tgt, rx865_off
  rx865_start:
    eq $I10, 1, rx865_restart
    if_null rx865_debug, debug_975
    rx865_cur."!cursor_debug"("START", "scope_declarator:sym<our>")
  debug_975:
    $I10 = self.'from'()
    ne $I10, -1, rxscan869_done
    goto rxscan869_scan
  rxscan869_loop:
    (rx865_pos) = rx865_cur."from"()
    inc rx865_pos
    rx865_cur."!cursor_from"(rx865_pos)
    ge rx865_pos, rx865_eos, rxscan869_done
  rxscan869_scan:
    set_addr $I10, rxscan869_loop
    rx865_cur."!mark_push"(0, rx865_pos, $I10)
  rxscan869_done:
.annotate 'line', 395
  # rx subcapture "sym"
    set_addr $I10, rxcap_870_fail
    rx865_cur."!mark_push"(0, rx865_pos, $I10)
  # rx literal  "our"
    add $I11, rx865_pos, 3
    gt $I11, rx865_eos, rx865_fail
    sub $I11, rx865_pos, rx865_off
    substr $S10, rx865_tgt, $I11, 3
    ne $S10, "our", rx865_fail
    add rx865_pos, 3
    set_addr $I10, rxcap_870_fail
    ($I12, $I11) = rx865_cur."!mark_peek"($I10)
    rx865_cur."!cursor_pos"($I11)
    ($P10) = rx865_cur."!cursor_start"()
    $P10."!cursor_pass"(rx865_pos, "")
    rx865_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_870_done
  rxcap_870_fail:
    goto rx865_fail
  rxcap_870_done:
  # rx subrule "scoped" subtype=capture negate=
    rx865_cur."!cursor_pos"(rx865_pos)
    $P10 = rx865_cur."scoped"("our")
    unless $P10, rx865_fail
    rx865_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx865_pos = $P10."pos"()
  # rx pass
    rx865_cur."!cursor_pass"(rx865_pos, "scope_declarator:sym<our>")
    if_null rx865_debug, debug_976
    rx865_cur."!cursor_debug"("PASS", "scope_declarator:sym<our>", " at pos=", rx865_pos)
  debug_976:
    .return (rx865_cur)
  rx865_restart:
.annotate 'line', 10
    if_null rx865_debug, debug_977
    rx865_cur."!cursor_debug"("NEXT", "scope_declarator:sym<our>")
  debug_977:
  rx865_fail:
    (rx865_rep, rx865_pos, $I10, $P10) = rx865_cur."!mark_fail"(0)
    lt rx865_pos, -1, rx865_done
    eq rx865_pos, -1, rx865_fail
    jump $I10
  rx865_done:
    rx865_cur."!cursor_fail"()
    if_null rx865_debug, debug_978
    rx865_cur."!cursor_debug"("FAIL", "scope_declarator:sym<our>")
  debug_978:
    .return (rx865_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<our>"  :nsentry("!PREFIX__scope_declarator:sym<our>") :subid("160_1303401201.841") :method
.annotate 'line', 10
    $P867 = self."!PREFIX__!subrule"("scoped", "our")
    new $P868, "ResizablePMCArray"
    push $P868, $P867
    .return ($P868)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<has>"  :subid("161_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx872_tgt
    .local int rx872_pos
    .local int rx872_off
    .local int rx872_eos
    .local int rx872_rep
    .local pmc rx872_cur
    .local pmc rx872_debug
    (rx872_cur, rx872_pos, rx872_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx872_cur
    .local pmc match
    .lex "$/", match
    length rx872_eos, rx872_tgt
    gt rx872_pos, rx872_eos, rx872_done
    set rx872_off, 0
    lt rx872_pos, 2, rx872_start
    sub rx872_off, rx872_pos, 1
    substr rx872_tgt, rx872_tgt, rx872_off
  rx872_start:
    eq $I10, 1, rx872_restart
    if_null rx872_debug, debug_979
    rx872_cur."!cursor_debug"("START", "scope_declarator:sym<has>")
  debug_979:
    $I10 = self.'from'()
    ne $I10, -1, rxscan876_done
    goto rxscan876_scan
  rxscan876_loop:
    (rx872_pos) = rx872_cur."from"()
    inc rx872_pos
    rx872_cur."!cursor_from"(rx872_pos)
    ge rx872_pos, rx872_eos, rxscan876_done
  rxscan876_scan:
    set_addr $I10, rxscan876_loop
    rx872_cur."!mark_push"(0, rx872_pos, $I10)
  rxscan876_done:
.annotate 'line', 396
  # rx subcapture "sym"
    set_addr $I10, rxcap_877_fail
    rx872_cur."!mark_push"(0, rx872_pos, $I10)
  # rx literal  "has"
    add $I11, rx872_pos, 3
    gt $I11, rx872_eos, rx872_fail
    sub $I11, rx872_pos, rx872_off
    substr $S10, rx872_tgt, $I11, 3
    ne $S10, "has", rx872_fail
    add rx872_pos, 3
    set_addr $I10, rxcap_877_fail
    ($I12, $I11) = rx872_cur."!mark_peek"($I10)
    rx872_cur."!cursor_pos"($I11)
    ($P10) = rx872_cur."!cursor_start"()
    $P10."!cursor_pass"(rx872_pos, "")
    rx872_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_877_done
  rxcap_877_fail:
    goto rx872_fail
  rxcap_877_done:
  # rx subrule "scoped" subtype=capture negate=
    rx872_cur."!cursor_pos"(rx872_pos)
    $P10 = rx872_cur."scoped"("has")
    unless $P10, rx872_fail
    rx872_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx872_pos = $P10."pos"()
  # rx pass
    rx872_cur."!cursor_pass"(rx872_pos, "scope_declarator:sym<has>")
    if_null rx872_debug, debug_980
    rx872_cur."!cursor_debug"("PASS", "scope_declarator:sym<has>", " at pos=", rx872_pos)
  debug_980:
    .return (rx872_cur)
  rx872_restart:
.annotate 'line', 10
    if_null rx872_debug, debug_981
    rx872_cur."!cursor_debug"("NEXT", "scope_declarator:sym<has>")
  debug_981:
  rx872_fail:
    (rx872_rep, rx872_pos, $I10, $P10) = rx872_cur."!mark_fail"(0)
    lt rx872_pos, -1, rx872_done
    eq rx872_pos, -1, rx872_fail
    jump $I10
  rx872_done:
    rx872_cur."!cursor_fail"()
    if_null rx872_debug, debug_982
    rx872_cur."!cursor_debug"("FAIL", "scope_declarator:sym<has>")
  debug_982:
    .return (rx872_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<has>"  :nsentry("!PREFIX__scope_declarator:sym<has>") :subid("162_1303401201.841") :method
.annotate 'line', 10
    $P874 = self."!PREFIX__!subrule"("scoped", "has")
    new $P875, "ResizablePMCArray"
    push $P875, $P874
    .return ($P875)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scoped"  :subid("163_1303401201.841") :method :outer("12_1303401201.841")
    .param pmc param_879
.annotate 'line', 398
    .lex "$*SCOPE", param_879
.annotate 'line', 10
    .local string rx880_tgt
    .local int rx880_pos
    .local int rx880_off
    .local int rx880_eos
    .local int rx880_rep
    .local pmc rx880_cur
    .local pmc rx880_debug
    (rx880_cur, rx880_pos, rx880_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx880_cur
    .local pmc match
    .lex "$/", match
    length rx880_eos, rx880_tgt
    gt rx880_pos, rx880_eos, rx880_done
    set rx880_off, 0
    lt rx880_pos, 2, rx880_start
    sub rx880_off, rx880_pos, 1
    substr rx880_tgt, rx880_tgt, rx880_off
  rx880_start:
    eq $I10, 1, rx880_restart
    if_null rx880_debug, debug_983
    rx880_cur."!cursor_debug"("START", "scoped")
  debug_983:
    $I10 = self.'from'()
    ne $I10, -1, rxscan886_done
    goto rxscan886_scan
  rxscan886_loop:
    (rx880_pos) = rx880_cur."from"()
    inc rx880_pos
    rx880_cur."!cursor_from"(rx880_pos)
    ge rx880_pos, rx880_eos, rxscan886_done
  rxscan886_scan:
    set_addr $I10, rxscan886_loop
    rx880_cur."!mark_push"(0, rx880_pos, $I10)
  rxscan886_done:
  alt887_0:
.annotate 'line', 398
    set_addr $I10, alt887_1
    rx880_cur."!mark_push"(0, rx880_pos, $I10)
.annotate 'line', 399
  # rx subrule "ws" subtype=method negate=
    rx880_cur."!cursor_pos"(rx880_pos)
    $P10 = rx880_cur."ws"()
    unless $P10, rx880_fail
    rx880_pos = $P10."pos"()
  # rx subrule "declarator" subtype=capture negate=
    rx880_cur."!cursor_pos"(rx880_pos)
    $P10 = rx880_cur."declarator"()
    unless $P10, rx880_fail
    rx880_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx880_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx880_cur."!cursor_pos"(rx880_pos)
    $P10 = rx880_cur."ws"()
    unless $P10, rx880_fail
    rx880_pos = $P10."pos"()
    goto alt887_end
  alt887_1:
    set_addr $I10, alt887_2
    rx880_cur."!mark_push"(0, rx880_pos, $I10)
.annotate 'line', 400
  # rx subrule "ws" subtype=method negate=
    rx880_cur."!cursor_pos"(rx880_pos)
    $P10 = rx880_cur."ws"()
    unless $P10, rx880_fail
    rx880_pos = $P10."pos"()
  # rx subrule "multi_declarator" subtype=capture negate=
    rx880_cur."!cursor_pos"(rx880_pos)
    $P10 = rx880_cur."multi_declarator"()
    unless $P10, rx880_fail
    rx880_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx880_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx880_cur."!cursor_pos"(rx880_pos)
    $P10 = rx880_cur."ws"()
    unless $P10, rx880_fail
    rx880_pos = $P10."pos"()
    goto alt887_end
  alt887_2:
.annotate 'line', 401
  # rx subrule "ws" subtype=method negate=
    rx880_cur."!cursor_pos"(rx880_pos)
    $P10 = rx880_cur."ws"()
    unless $P10, rx880_fail
    rx880_pos = $P10."pos"()
  # rx subrule "package_declarator" subtype=capture negate=
    rx880_cur."!cursor_pos"(rx880_pos)
    $P10 = rx880_cur."package_declarator"()
    unless $P10, rx880_fail
    rx880_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx880_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx880_cur."!cursor_pos"(rx880_pos)
    $P10 = rx880_cur."ws"()
    unless $P10, rx880_fail
    rx880_pos = $P10."pos"()
  alt887_end:
.annotate 'line', 398
  # rx pass
    rx880_cur."!cursor_pass"(rx880_pos, "scoped")
    if_null rx880_debug, debug_984
    rx880_cur."!cursor_debug"("PASS", "scoped", " at pos=", rx880_pos)
  debug_984:
    .return (rx880_cur)
  rx880_restart:
.annotate 'line', 10
    if_null rx880_debug, debug_985
    rx880_cur."!cursor_debug"("NEXT", "scoped")
  debug_985:
  rx880_fail:
    (rx880_rep, rx880_pos, $I10, $P10) = rx880_cur."!mark_fail"(0)
    lt rx880_pos, -1, rx880_done
    eq rx880_pos, -1, rx880_fail
    jump $I10
  rx880_done:
    rx880_cur."!cursor_fail"()
    if_null rx880_debug, debug_986
    rx880_cur."!cursor_debug"("FAIL", "scoped")
  debug_986:
    .return (rx880_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scoped"  :nsentry("!PREFIX__scoped") :subid("164_1303401201.841") :method
.annotate 'line', 10
    $P882 = self."!PREFIX__!subrule"("ws", "")
    $P883 = self."!PREFIX__!subrule"("ws", "")
    $P884 = self."!PREFIX__!subrule"("ws", "")
    new $P885, "ResizablePMCArray"
    push $P885, $P882
    push $P885, $P883
    push $P885, $P884
    .return ($P885)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "typename"  :subid("165_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx895_tgt
    .local int rx895_pos
    .local int rx895_off
    .local int rx895_eos
    .local int rx895_rep
    .local pmc rx895_cur
    .local pmc rx895_debug
    (rx895_cur, rx895_pos, rx895_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx895_cur
    .local pmc match
    .lex "$/", match
    length rx895_eos, rx895_tgt
    gt rx895_pos, rx895_eos, rx895_done
    set rx895_off, 0
    lt rx895_pos, 2, rx895_start
    sub rx895_off, rx895_pos, 1
    substr rx895_tgt, rx895_tgt, rx895_off
  rx895_start:
    eq $I10, 1, rx895_restart
    if_null rx895_debug, debug_987
    rx895_cur."!cursor_debug"("START", "typename")
  debug_987:
    $I10 = self.'from'()
    ne $I10, -1, rxscan899_done
    goto rxscan899_scan
  rxscan899_loop:
    (rx895_pos) = rx895_cur."from"()
    inc rx895_pos
    rx895_cur."!cursor_from"(rx895_pos)
    ge rx895_pos, rx895_eos, rxscan899_done
  rxscan899_scan:
    set_addr $I10, rxscan899_loop
    rx895_cur."!mark_push"(0, rx895_pos, $I10)
  rxscan899_done:
.annotate 'line', 404
  # rx subrule "name" subtype=capture negate=
    rx895_cur."!cursor_pos"(rx895_pos)
    $P10 = rx895_cur."name"()
    unless $P10, rx895_fail
    rx895_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx895_pos = $P10."pos"()
  # rx pass
    rx895_cur."!cursor_pass"(rx895_pos, "typename")
    if_null rx895_debug, debug_988
    rx895_cur."!cursor_debug"("PASS", "typename", " at pos=", rx895_pos)
  debug_988:
    .return (rx895_cur)
  rx895_restart:
.annotate 'line', 10
    if_null rx895_debug, debug_989
    rx895_cur."!cursor_debug"("NEXT", "typename")
  debug_989:
  rx895_fail:
    (rx895_rep, rx895_pos, $I10, $P10) = rx895_cur."!mark_fail"(0)
    lt rx895_pos, -1, rx895_done
    eq rx895_pos, -1, rx895_fail
    jump $I10
  rx895_done:
    rx895_cur."!cursor_fail"()
    if_null rx895_debug, debug_990
    rx895_cur."!cursor_debug"("FAIL", "typename")
  debug_990:
    .return (rx895_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__typename"  :nsentry("!PREFIX__typename") :subid("166_1303401201.841") :method
.annotate 'line', 10
    $P897 = self."!PREFIX__!subrule"("name", "")
    new $P898, "ResizablePMCArray"
    push $P898, $P897
    .return ($P898)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "declarator"  :subid("167_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx901_tgt
    .local int rx901_pos
    .local int rx901_off
    .local int rx901_eos
    .local int rx901_rep
    .local pmc rx901_cur
    .local pmc rx901_debug
    (rx901_cur, rx901_pos, rx901_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx901_cur
    .local pmc match
    .lex "$/", match
    length rx901_eos, rx901_tgt
    gt rx901_pos, rx901_eos, rx901_done
    set rx901_off, 0
    lt rx901_pos, 2, rx901_start
    sub rx901_off, rx901_pos, 1
    substr rx901_tgt, rx901_tgt, rx901_off
  rx901_start:
    eq $I10, 1, rx901_restart
    if_null rx901_debug, debug_991
    rx901_cur."!cursor_debug"("START", "declarator")
  debug_991:
    $I10 = self.'from'()
    ne $I10, -1, rxscan906_done
    goto rxscan906_scan
  rxscan906_loop:
    (rx901_pos) = rx901_cur."from"()
    inc rx901_pos
    rx901_cur."!cursor_from"(rx901_pos)
    ge rx901_pos, rx901_eos, rxscan906_done
  rxscan906_scan:
    set_addr $I10, rxscan906_loop
    rx901_cur."!mark_push"(0, rx901_pos, $I10)
  rxscan906_done:
  alt907_0:
.annotate 'line', 406
    set_addr $I10, alt907_1
    rx901_cur."!mark_push"(0, rx901_pos, $I10)
.annotate 'line', 407
  # rx subrule "variable_declarator" subtype=capture negate=
    rx901_cur."!cursor_pos"(rx901_pos)
    $P10 = rx901_cur."variable_declarator"()
    unless $P10, rx901_fail
    rx901_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable_declarator")
    rx901_pos = $P10."pos"()
    goto alt907_end
  alt907_1:
.annotate 'line', 408
  # rx subrule "routine_declarator" subtype=capture negate=
    rx901_cur."!cursor_pos"(rx901_pos)
    $P10 = rx901_cur."routine_declarator"()
    unless $P10, rx901_fail
    rx901_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx901_pos = $P10."pos"()
  alt907_end:
.annotate 'line', 406
  # rx pass
    rx901_cur."!cursor_pass"(rx901_pos, "declarator")
    if_null rx901_debug, debug_992
    rx901_cur."!cursor_debug"("PASS", "declarator", " at pos=", rx901_pos)
  debug_992:
    .return (rx901_cur)
  rx901_restart:
.annotate 'line', 10
    if_null rx901_debug, debug_993
    rx901_cur."!cursor_debug"("NEXT", "declarator")
  debug_993:
  rx901_fail:
    (rx901_rep, rx901_pos, $I10, $P10) = rx901_cur."!mark_fail"(0)
    lt rx901_pos, -1, rx901_done
    eq rx901_pos, -1, rx901_fail
    jump $I10
  rx901_done:
    rx901_cur."!cursor_fail"()
    if_null rx901_debug, debug_994
    rx901_cur."!cursor_debug"("FAIL", "declarator")
  debug_994:
    .return (rx901_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__declarator"  :nsentry("!PREFIX__declarator") :subid("168_1303401201.841") :method
.annotate 'line', 10
    $P903 = self."!PREFIX__!subrule"("routine_declarator", "")
    $P904 = self."!PREFIX__!subrule"("variable_declarator", "")
    new $P905, "ResizablePMCArray"
    push $P905, $P903
    push $P905, $P904
    .return ($P905)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable_declarator"  :subid("169_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx909_tgt
    .local int rx909_pos
    .local int rx909_off
    .local int rx909_eos
    .local int rx909_rep
    .local pmc rx909_cur
    .local pmc rx909_debug
    (rx909_cur, rx909_pos, rx909_tgt, $I10) = self."!cursor_start"()
    rx909_cur."!cursor_caparray"("typename")
    .lex unicode:"$\x{a2}", rx909_cur
    .local pmc match
    .lex "$/", match
    length rx909_eos, rx909_tgt
    gt rx909_pos, rx909_eos, rx909_done
    set rx909_off, 0
    lt rx909_pos, 2, rx909_start
    sub rx909_off, rx909_pos, 1
    substr rx909_tgt, rx909_tgt, rx909_off
  rx909_start:
    eq $I10, 1, rx909_restart
    if_null rx909_debug, debug_995
    rx909_cur."!cursor_debug"("START", "variable_declarator")
  debug_995:
    $I10 = self.'from'()
    ne $I10, -1, rxscan913_done
    goto rxscan913_scan
  rxscan913_loop:
    (rx909_pos) = rx909_cur."from"()
    inc rx909_pos
    rx909_cur."!cursor_from"(rx909_pos)
    ge rx909_pos, rx909_eos, rxscan913_done
  rxscan913_scan:
    set_addr $I10, rxscan913_loop
    rx909_cur."!mark_push"(0, rx909_pos, $I10)
  rxscan913_done:
.annotate 'line', 411
  # rx subrule "ws" subtype=method negate=
    rx909_cur."!cursor_pos"(rx909_pos)
    $P10 = rx909_cur."ws"()
    unless $P10, rx909_fail
    rx909_pos = $P10."pos"()
  # rx rxquantr915 ** 0..1
    set_addr $I10, rxquantr915_done
    rx909_cur."!mark_push"(0, rx909_pos, $I10)
  rxquantr915_loop:
  # rx subrule "typename" subtype=capture negate=
    rx909_cur."!cursor_pos"(rx909_pos)
    $P10 = rx909_cur."typename"()
    unless $P10, rx909_fail
    goto rxsubrule916_pass
  rxsubrule916_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx909_fail
  rxsubrule916_pass:
    set_addr $I10, rxsubrule916_back
    rx909_cur."!mark_push"(0, rx909_pos, $I10, $P10)
    $P10."!cursor_names"("typename")
    rx909_pos = $P10."pos"()
    set_addr $I10, rxquantr915_done
    (rx909_rep) = rx909_cur."!mark_commit"($I10)
  rxquantr915_done:
  # rx subrule "ws" subtype=method negate=
    rx909_cur."!cursor_pos"(rx909_pos)
    $P10 = rx909_cur."ws"()
    unless $P10, rx909_fail
    rx909_pos = $P10."pos"()
  # rx subrule "variable" subtype=capture negate=
    rx909_cur."!cursor_pos"(rx909_pos)
    $P10 = rx909_cur."variable"()
    unless $P10, rx909_fail
    rx909_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx909_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx909_cur."!cursor_pos"(rx909_pos)
    $P10 = rx909_cur."ws"()
    unless $P10, rx909_fail
    rx909_pos = $P10."pos"()
  # rx pass
    rx909_cur."!cursor_pass"(rx909_pos, "variable_declarator")
    if_null rx909_debug, debug_996
    rx909_cur."!cursor_debug"("PASS", "variable_declarator", " at pos=", rx909_pos)
  debug_996:
    .return (rx909_cur)
  rx909_restart:
.annotate 'line', 10
    if_null rx909_debug, debug_997
    rx909_cur."!cursor_debug"("NEXT", "variable_declarator")
  debug_997:
  rx909_fail:
    (rx909_rep, rx909_pos, $I10, $P10) = rx909_cur."!mark_fail"(0)
    lt rx909_pos, -1, rx909_done
    eq rx909_pos, -1, rx909_fail
    jump $I10
  rx909_done:
    rx909_cur."!cursor_fail"()
    if_null rx909_debug, debug_998
    rx909_cur."!cursor_debug"("FAIL", "variable_declarator")
  debug_998:
    .return (rx909_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable_declarator"  :nsentry("!PREFIX__variable_declarator") :subid("170_1303401201.841") :method
.annotate 'line', 10
    $P911 = self."!PREFIX__!subrule"("ws", "")
    new $P912, "ResizablePMCArray"
    push $P912, $P911
    .return ($P912)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator"  :subid("171_1303401201.841")
    .param pmc param_920
.annotate 'line', 413
    .lex "self", param_920
    $P921 = param_920."!protoregex"("routine_declarator")
    .return ($P921)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator"  :subid("172_1303401201.841")
    .param pmc param_923
.annotate 'line', 413
    .lex "self", param_923
    $P924 = param_923."!PREFIX__!protoregex"("routine_declarator")
    .return ($P924)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<sub>"  :subid("173_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx926_tgt
    .local int rx926_pos
    .local int rx926_off
    .local int rx926_eos
    .local int rx926_rep
    .local pmc rx926_cur
    .local pmc rx926_debug
    (rx926_cur, rx926_pos, rx926_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx926_cur
    .local pmc match
    .lex "$/", match
    length rx926_eos, rx926_tgt
    gt rx926_pos, rx926_eos, rx926_done
    set rx926_off, 0
    lt rx926_pos, 2, rx926_start
    sub rx926_off, rx926_pos, 1
    substr rx926_tgt, rx926_tgt, rx926_off
  rx926_start:
    eq $I10, 1, rx926_restart
    if_null rx926_debug, debug_999
    rx926_cur."!cursor_debug"("START", "routine_declarator:sym<sub>")
  debug_999:
    $I10 = self.'from'()
    ne $I10, -1, rxscan930_done
    goto rxscan930_scan
  rxscan930_loop:
    (rx926_pos) = rx926_cur."from"()
    inc rx926_pos
    rx926_cur."!cursor_from"(rx926_pos)
    ge rx926_pos, rx926_eos, rxscan930_done
  rxscan930_scan:
    set_addr $I10, rxscan930_loop
    rx926_cur."!mark_push"(0, rx926_pos, $I10)
  rxscan930_done:
.annotate 'line', 414
  # rx subcapture "sym"
    set_addr $I10, rxcap_931_fail
    rx926_cur."!mark_push"(0, rx926_pos, $I10)
  # rx literal  "sub"
    add $I11, rx926_pos, 3
    gt $I11, rx926_eos, rx926_fail
    sub $I11, rx926_pos, rx926_off
    substr $S10, rx926_tgt, $I11, 3
    ne $S10, "sub", rx926_fail
    add rx926_pos, 3
    set_addr $I10, rxcap_931_fail
    ($I12, $I11) = rx926_cur."!mark_peek"($I10)
    rx926_cur."!cursor_pos"($I11)
    ($P10) = rx926_cur."!cursor_start"()
    $P10."!cursor_pass"(rx926_pos, "")
    rx926_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_931_done
  rxcap_931_fail:
    goto rx926_fail
  rxcap_931_done:
  # rx subrule "routine_def" subtype=capture negate=
    rx926_cur."!cursor_pos"(rx926_pos)
    $P10 = rx926_cur."routine_def"()
    unless $P10, rx926_fail
    rx926_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx926_pos = $P10."pos"()
  # rx pass
    rx926_cur."!cursor_pass"(rx926_pos, "routine_declarator:sym<sub>")
    if_null rx926_debug, debug_1000
    rx926_cur."!cursor_debug"("PASS", "routine_declarator:sym<sub>", " at pos=", rx926_pos)
  debug_1000:
    .return (rx926_cur)
  rx926_restart:
.annotate 'line', 10
    if_null rx926_debug, debug_1001
    rx926_cur."!cursor_debug"("NEXT", "routine_declarator:sym<sub>")
  debug_1001:
  rx926_fail:
    (rx926_rep, rx926_pos, $I10, $P10) = rx926_cur."!mark_fail"(0)
    lt rx926_pos, -1, rx926_done
    eq rx926_pos, -1, rx926_fail
    jump $I10
  rx926_done:
    rx926_cur."!cursor_fail"()
    if_null rx926_debug, debug_1002
    rx926_cur."!cursor_debug"("FAIL", "routine_declarator:sym<sub>")
  debug_1002:
    .return (rx926_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<sub>"  :nsentry("!PREFIX__routine_declarator:sym<sub>") :subid("174_1303401201.841") :method
.annotate 'line', 10
    $P928 = self."!PREFIX__!subrule"("routine_def", "sub")
    new $P929, "ResizablePMCArray"
    push $P929, $P928
    .return ($P929)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<method>"  :subid("175_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx933_tgt
    .local int rx933_pos
    .local int rx933_off
    .local int rx933_eos
    .local int rx933_rep
    .local pmc rx933_cur
    .local pmc rx933_debug
    (rx933_cur, rx933_pos, rx933_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx933_cur
    .local pmc match
    .lex "$/", match
    length rx933_eos, rx933_tgt
    gt rx933_pos, rx933_eos, rx933_done
    set rx933_off, 0
    lt rx933_pos, 2, rx933_start
    sub rx933_off, rx933_pos, 1
    substr rx933_tgt, rx933_tgt, rx933_off
  rx933_start:
    eq $I10, 1, rx933_restart
    if_null rx933_debug, debug_1003
    rx933_cur."!cursor_debug"("START", "routine_declarator:sym<method>")
  debug_1003:
    $I10 = self.'from'()
    ne $I10, -1, rxscan937_done
    goto rxscan937_scan
  rxscan937_loop:
    (rx933_pos) = rx933_cur."from"()
    inc rx933_pos
    rx933_cur."!cursor_from"(rx933_pos)
    ge rx933_pos, rx933_eos, rxscan937_done
  rxscan937_scan:
    set_addr $I10, rxscan937_loop
    rx933_cur."!mark_push"(0, rx933_pos, $I10)
  rxscan937_done:
.annotate 'line', 415
  # rx subcapture "sym"
    set_addr $I10, rxcap_938_fail
    rx933_cur."!mark_push"(0, rx933_pos, $I10)
  # rx literal  "method"
    add $I11, rx933_pos, 6
    gt $I11, rx933_eos, rx933_fail
    sub $I11, rx933_pos, rx933_off
    substr $S10, rx933_tgt, $I11, 6
    ne $S10, "method", rx933_fail
    add rx933_pos, 6
    set_addr $I10, rxcap_938_fail
    ($I12, $I11) = rx933_cur."!mark_peek"($I10)
    rx933_cur."!cursor_pos"($I11)
    ($P10) = rx933_cur."!cursor_start"()
    $P10."!cursor_pass"(rx933_pos, "")
    rx933_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_938_done
  rxcap_938_fail:
    goto rx933_fail
  rxcap_938_done:
  # rx subrule "method_def" subtype=capture negate=
    rx933_cur."!cursor_pos"(rx933_pos)
    $P10 = rx933_cur."method_def"()
    unless $P10, rx933_fail
    rx933_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("method_def")
    rx933_pos = $P10."pos"()
  # rx pass
    rx933_cur."!cursor_pass"(rx933_pos, "routine_declarator:sym<method>")
    if_null rx933_debug, debug_1004
    rx933_cur."!cursor_debug"("PASS", "routine_declarator:sym<method>", " at pos=", rx933_pos)
  debug_1004:
    .return (rx933_cur)
  rx933_restart:
.annotate 'line', 10
    if_null rx933_debug, debug_1005
    rx933_cur."!cursor_debug"("NEXT", "routine_declarator:sym<method>")
  debug_1005:
  rx933_fail:
    (rx933_rep, rx933_pos, $I10, $P10) = rx933_cur."!mark_fail"(0)
    lt rx933_pos, -1, rx933_done
    eq rx933_pos, -1, rx933_fail
    jump $I10
  rx933_done:
    rx933_cur."!cursor_fail"()
    if_null rx933_debug, debug_1006
    rx933_cur."!cursor_debug"("FAIL", "routine_declarator:sym<method>")
  debug_1006:
    .return (rx933_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<method>"  :nsentry("!PREFIX__routine_declarator:sym<method>") :subid("176_1303401201.841") :method
.annotate 'line', 10
    $P935 = self."!PREFIX__!subrule"("method_def", "method")
    new $P936, "ResizablePMCArray"
    push $P936, $P935
    .return ($P936)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_def"  :subid("177_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 418
    new $P940, "Undef"
    .lex "$*RETURN_USED", $P940
.annotate 'line', 10
    .local string rx941_tgt
    .local int rx941_pos
    .local int rx941_off
    .local int rx941_eos
    .local int rx941_rep
    .local pmc rx941_cur
    .local pmc rx941_debug
    (rx941_cur, rx941_pos, rx941_tgt, $I10) = self."!cursor_start"()
    rx941_cur."!cursor_caparray"("sigil", "deflongname", "trait")
    .lex unicode:"$\x{a2}", rx941_cur
    .local pmc match
    .lex "$/", match
    length rx941_eos, rx941_tgt
    gt rx941_pos, rx941_eos, rx941_done
    set rx941_off, 0
    lt rx941_pos, 2, rx941_start
    sub rx941_off, rx941_pos, 1
    substr rx941_tgt, rx941_tgt, rx941_off
  rx941_start:
    eq $I10, 1, rx941_restart
    if_null rx941_debug, debug_1007
    rx941_cur."!cursor_debug"("START", "routine_def")
  debug_1007:
    $I10 = self.'from'()
    ne $I10, -1, rxscan945_done
    goto rxscan945_scan
  rxscan945_loop:
    (rx941_pos) = rx941_cur."from"()
    inc rx941_pos
    rx941_cur."!cursor_from"(rx941_pos)
    ge rx941_pos, rx941_eos, rxscan945_done
  rxscan945_scan:
    set_addr $I10, rxscan945_loop
    rx941_cur."!mark_push"(0, rx941_pos, $I10)
  rxscan945_done:
.annotate 'line', 417
  # rx subrule "ws" subtype=method negate=
    rx941_cur."!cursor_pos"(rx941_pos)
    $P10 = rx941_cur."ws"()
    unless $P10, rx941_fail
    rx941_pos = $P10."pos"()
.annotate 'line', 418
    rx941_cur."!cursor_pos"(rx941_pos)
    new $P947, "Integer"
    assign $P947, 0
    store_lex "$*RETURN_USED", $P947
  # rx subrule "ws" subtype=method negate=
    rx941_cur."!cursor_pos"(rx941_pos)
    $P10 = rx941_cur."ws"()
    unless $P10, rx941_fail
    rx941_pos = $P10."pos"()
.annotate 'line', 419
  # rx rxquantr949 ** 0..1
    set_addr $I10, rxquantr949_done
    rx941_cur."!mark_push"(0, rx941_pos, $I10)
  rxquantr949_loop:
  # rx subrule "ws" subtype=method negate=
    rx941_cur."!cursor_pos"(rx941_pos)
    $P10 = rx941_cur."ws"()
    unless $P10, rx941_fail
    rx941_pos = $P10."pos"()
  # rx subcapture "sigil"
    set_addr $I10, rxcap_952_fail
    rx941_cur."!mark_push"(0, rx941_pos, $I10)
  # rx rxquantr951 ** 0..1
    set_addr $I10, rxquantr951_done
    rx941_cur."!mark_push"(0, rx941_pos, $I10)
  rxquantr951_loop:
  # rx literal  "&"
    add $I11, rx941_pos, 1
    gt $I11, rx941_eos, rx941_fail
    sub $I11, rx941_pos, rx941_off
    ord $I11, rx941_tgt, $I11
    ne $I11, 38, rx941_fail
    add rx941_pos, 1
    set_addr $I10, rxquantr951_done
    (rx941_rep) = rx941_cur."!mark_commit"($I10)
  rxquantr951_done:
    set_addr $I10, rxcap_952_fail
    ($I12, $I11) = rx941_cur."!mark_peek"($I10)
    rx941_cur."!cursor_pos"($I11)
    ($P10) = rx941_cur."!cursor_start"()
    $P10."!cursor_pass"(rx941_pos, "")
    rx941_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_952_done
  rxcap_952_fail:
    goto rx941_fail
  rxcap_952_done:
  # rx subrule "deflongname" subtype=capture negate=
    rx941_cur."!cursor_pos"(rx941_pos)
    $P10 = rx941_cur."deflongname"()
    unless $P10, rx941_fail
    rx941_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx941_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx941_cur."!cursor_pos"(rx941_pos)
    $P10 = rx941_cur."ws"()
    unless $P10, rx941_fail
    rx941_pos = $P10."pos"()
    set_addr $I10, rxquantr949_done
    (rx941_rep) = rx941_cur."!mark_commit"($I10)
  rxquantr949_done:
  # rx subrule "ws" subtype=method negate=
    rx941_cur."!cursor_pos"(rx941_pos)
    $P10 = rx941_cur."ws"()
    unless $P10, rx941_fail
    rx941_pos = $P10."pos"()
.annotate 'line', 420
  # rx subrule "newpad" subtype=method negate=
    rx941_cur."!cursor_pos"(rx941_pos)
    $P10 = rx941_cur."newpad"()
    unless $P10, rx941_fail
    rx941_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx941_cur."!cursor_pos"(rx941_pos)
    $P10 = rx941_cur."ws"()
    unless $P10, rx941_fail
    rx941_pos = $P10."pos"()
  alt956_0:
.annotate 'line', 421
    set_addr $I10, alt956_1
    rx941_cur."!mark_push"(0, rx941_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx941_cur."!cursor_pos"(rx941_pos)
    $P10 = rx941_cur."ws"()
    unless $P10, rx941_fail
    rx941_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx941_pos, 1
    gt $I11, rx941_eos, rx941_fail
    sub $I11, rx941_pos, rx941_off
    ord $I11, rx941_tgt, $I11
    ne $I11, 40, rx941_fail
    add rx941_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx941_cur."!cursor_pos"(rx941_pos)
    $P10 = rx941_cur."ws"()
    unless $P10, rx941_fail
    rx941_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx941_cur."!cursor_pos"(rx941_pos)
    $P10 = rx941_cur."signature"()
    unless $P10, rx941_fail
    rx941_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx941_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx941_cur."!cursor_pos"(rx941_pos)
    $P10 = rx941_cur."ws"()
    unless $P10, rx941_fail
    rx941_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx941_pos, 1
    gt $I11, rx941_eos, rx941_fail
    sub $I11, rx941_pos, rx941_off
    ord $I11, rx941_tgt, $I11
    ne $I11, 41, rx941_fail
    add rx941_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx941_cur."!cursor_pos"(rx941_pos)
    $P10 = rx941_cur."ws"()
    unless $P10, rx941_fail
    rx941_pos = $P10."pos"()
    goto alt956_end
  alt956_1:
.annotate 'line', 422
  # rx subrule "ws" subtype=method negate=
    rx941_cur."!cursor_pos"(rx941_pos)
    $P10 = rx941_cur."ws"()
    unless $P10, rx941_fail
    rx941_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx941_cur."!cursor_pos"(rx941_pos)
    $P10 = rx941_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx941_fail
    rx941_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx941_cur."!cursor_pos"(rx941_pos)
    $P10 = rx941_cur."ws"()
    unless $P10, rx941_fail
    rx941_pos = $P10."pos"()
  alt956_end:
  # rx subrule "ws" subtype=method negate=
    rx941_cur."!cursor_pos"(rx941_pos)
    $P10 = rx941_cur."ws"()
    unless $P10, rx941_fail
    rx941_pos = $P10."pos"()
.annotate 'line', 423
  # rx rxquantr964 ** 0..*
    set_addr $I10, rxquantr964_done
    rx941_cur."!mark_push"(0, rx941_pos, $I10)
  rxquantr964_loop:
  # rx subrule "trait" subtype=capture negate=
    rx941_cur."!cursor_pos"(rx941_pos)
    $P10 = rx941_cur."trait"()
    unless $P10, rx941_fail
    goto rxsubrule965_pass
  rxsubrule965_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx941_fail
  rxsubrule965_pass:
    set_addr $I10, rxsubrule965_back
    rx941_cur."!mark_push"(0, rx941_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx941_pos = $P10."pos"()
    set_addr $I10, rxquantr964_done
    (rx941_rep) = rx941_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr964_done
    rx941_cur."!mark_push"(rx941_rep, rx941_pos, $I10)
    goto rxquantr964_loop
  rxquantr964_done:
  # rx subrule "ws" subtype=method negate=
    rx941_cur."!cursor_pos"(rx941_pos)
    $P10 = rx941_cur."ws"()
    unless $P10, rx941_fail
    rx941_pos = $P10."pos"()
  alt967_0:
.annotate 'line', 424
    set_addr $I10, alt967_1
    rx941_cur."!mark_push"(0, rx941_pos, $I10)
.annotate 'line', 425
  # rx subrule "ws" subtype=method negate=
    rx941_cur."!cursor_pos"(rx941_pos)
    $P10 = rx941_cur."ws"()
    unless $P10, rx941_fail
    rx941_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx941_cur."!cursor_pos"(rx941_pos)
    $P10 = rx941_cur."onlystar"()
    unless $P10, rx941_fail
    rx941_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx941_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx941_cur."!cursor_pos"(rx941_pos)
    $P10 = rx941_cur."ws"()
    unless $P10, rx941_fail
    rx941_pos = $P10."pos"()
    goto alt967_end
  alt967_1:
.annotate 'line', 426
  # rx subrule "ws" subtype=method negate=
    rx941_cur."!cursor_pos"(rx941_pos)
    $P10 = rx941_cur."ws"()
    unless $P10, rx941_fail
    rx941_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx941_cur."!cursor_pos"(rx941_pos)
    $P10 = rx941_cur."blockoid"()
    unless $P10, rx941_fail
    rx941_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx941_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx941_cur."!cursor_pos"(rx941_pos)
    $P10 = rx941_cur."ws"()
    unless $P10, rx941_fail
    rx941_pos = $P10."pos"()
  alt967_end:
.annotate 'line', 427
  # rx subrule "ws" subtype=method negate=
    rx941_cur."!cursor_pos"(rx941_pos)
    $P10 = rx941_cur."ws"()
    unless $P10, rx941_fail
    rx941_pos = $P10."pos"()
.annotate 'line', 417
  # rx pass
    rx941_cur."!cursor_pass"(rx941_pos, "routine_def")
    if_null rx941_debug, debug_1008
    rx941_cur."!cursor_debug"("PASS", "routine_def", " at pos=", rx941_pos)
  debug_1008:
    .return (rx941_cur)
  rx941_restart:
.annotate 'line', 10
    if_null rx941_debug, debug_1009
    rx941_cur."!cursor_debug"("NEXT", "routine_def")
  debug_1009:
  rx941_fail:
    (rx941_rep, rx941_pos, $I10, $P10) = rx941_cur."!mark_fail"(0)
    lt rx941_pos, -1, rx941_done
    eq rx941_pos, -1, rx941_fail
    jump $I10
  rx941_done:
    rx941_cur."!cursor_fail"()
    if_null rx941_debug, debug_1010
    rx941_cur."!cursor_debug"("FAIL", "routine_def")
  debug_1010:
    .return (rx941_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_def"  :nsentry("!PREFIX__routine_def") :subid("178_1303401201.841") :method
.annotate 'line', 10
    $P943 = self."!PREFIX__!subrule"("ws", "")
    new $P944, "ResizablePMCArray"
    push $P944, $P943
    .return ($P944)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "method_def"  :subid("179_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .const 'Sub' $P1004 = "181_1303401201.841" 
    capture_lex $P1004
.annotate 'line', 431
    new $P974, "Undef"
    .lex "$*RETURN_USED", $P974
.annotate 'line', 432
    new $P975, "Undef"
    .lex "$*INVOCANT_OK", $P975
.annotate 'line', 10
    .local string rx976_tgt
    .local int rx976_pos
    .local int rx976_off
    .local int rx976_eos
    .local int rx976_rep
    .local pmc rx976_cur
    .local pmc rx976_debug
    (rx976_cur, rx976_pos, rx976_tgt, $I10) = self."!cursor_start"()
    rx976_cur."!cursor_caparray"("deflongname", "trait")
    .lex unicode:"$\x{a2}", rx976_cur
    .local pmc match
    .lex "$/", match
    length rx976_eos, rx976_tgt
    gt rx976_pos, rx976_eos, rx976_done
    set rx976_off, 0
    lt rx976_pos, 2, rx976_start
    sub rx976_off, rx976_pos, 1
    substr rx976_tgt, rx976_tgt, rx976_off
  rx976_start:
    eq $I10, 1, rx976_restart
    if_null rx976_debug, debug_1011
    rx976_cur."!cursor_debug"("START", "method_def")
  debug_1011:
    $I10 = self.'from'()
    ne $I10, -1, rxscan980_done
    goto rxscan980_scan
  rxscan980_loop:
    (rx976_pos) = rx976_cur."from"()
    inc rx976_pos
    rx976_cur."!cursor_from"(rx976_pos)
    ge rx976_pos, rx976_eos, rxscan980_done
  rxscan980_scan:
    set_addr $I10, rxscan980_loop
    rx976_cur."!mark_push"(0, rx976_pos, $I10)
  rxscan980_done:
.annotate 'line', 430
  # rx subrule "ws" subtype=method negate=
    rx976_cur."!cursor_pos"(rx976_pos)
    $P10 = rx976_cur."ws"()
    unless $P10, rx976_fail
    rx976_pos = $P10."pos"()
.annotate 'line', 431
    rx976_cur."!cursor_pos"(rx976_pos)
    new $P982, "Integer"
    assign $P982, 0
    store_lex "$*RETURN_USED", $P982
  # rx subrule "ws" subtype=method negate=
    rx976_cur."!cursor_pos"(rx976_pos)
    $P10 = rx976_cur."ws"()
    unless $P10, rx976_fail
    rx976_pos = $P10."pos"()
.annotate 'line', 432
    rx976_cur."!cursor_pos"(rx976_pos)
    new $P984, "Integer"
    assign $P984, 1
    store_lex "$*INVOCANT_OK", $P984
  # rx subrule "ws" subtype=method negate=
    rx976_cur."!cursor_pos"(rx976_pos)
    $P10 = rx976_cur."ws"()
    unless $P10, rx976_fail
    rx976_pos = $P10."pos"()
.annotate 'line', 433
  # rx subcapture "private"
    set_addr $I10, rxcap_987_fail
    rx976_cur."!mark_push"(0, rx976_pos, $I10)
  # rx rxquantr986 ** 0..1
    set_addr $I10, rxquantr986_done
    rx976_cur."!mark_push"(0, rx976_pos, $I10)
  rxquantr986_loop:
  # rx literal  "!"
    add $I11, rx976_pos, 1
    gt $I11, rx976_eos, rx976_fail
    sub $I11, rx976_pos, rx976_off
    ord $I11, rx976_tgt, $I11
    ne $I11, 33, rx976_fail
    add rx976_pos, 1
    set_addr $I10, rxquantr986_done
    (rx976_rep) = rx976_cur."!mark_commit"($I10)
  rxquantr986_done:
    set_addr $I10, rxcap_987_fail
    ($I12, $I11) = rx976_cur."!mark_peek"($I10)
    rx976_cur."!cursor_pos"($I11)
    ($P10) = rx976_cur."!cursor_start"()
    $P10."!cursor_pass"(rx976_pos, "")
    rx976_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("private")
    goto rxcap_987_done
  rxcap_987_fail:
    goto rx976_fail
  rxcap_987_done:
  # rx subrule "ws" subtype=method negate=
    rx976_cur."!cursor_pos"(rx976_pos)
    $P10 = rx976_cur."ws"()
    unless $P10, rx976_fail
    rx976_pos = $P10."pos"()
.annotate 'line', 434
  # rx rxquantr989 ** 0..1
    set_addr $I10, rxquantr989_done
    rx976_cur."!mark_push"(0, rx976_pos, $I10)
  rxquantr989_loop:
  # rx subrule "deflongname" subtype=capture negate=
    rx976_cur."!cursor_pos"(rx976_pos)
    $P10 = rx976_cur."deflongname"()
    unless $P10, rx976_fail
    goto rxsubrule990_pass
  rxsubrule990_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx976_fail
  rxsubrule990_pass:
    set_addr $I10, rxsubrule990_back
    rx976_cur."!mark_push"(0, rx976_pos, $I10, $P10)
    $P10."!cursor_names"("deflongname")
    rx976_pos = $P10."pos"()
    set_addr $I10, rxquantr989_done
    (rx976_rep) = rx976_cur."!mark_commit"($I10)
  rxquantr989_done:
  # rx subrule "ws" subtype=method negate=
    rx976_cur."!cursor_pos"(rx976_pos)
    $P10 = rx976_cur."ws"()
    unless $P10, rx976_fail
    rx976_pos = $P10."pos"()
.annotate 'line', 435
  # rx subrule "newpad" subtype=method negate=
    rx976_cur."!cursor_pos"(rx976_pos)
    $P10 = rx976_cur."newpad"()
    unless $P10, rx976_fail
    rx976_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx976_cur."!cursor_pos"(rx976_pos)
    $P10 = rx976_cur."ws"()
    unless $P10, rx976_fail
    rx976_pos = $P10."pos"()
  alt993_0:
.annotate 'line', 436
    set_addr $I10, alt993_1
    rx976_cur."!mark_push"(0, rx976_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx976_cur."!cursor_pos"(rx976_pos)
    $P10 = rx976_cur."ws"()
    unless $P10, rx976_fail
    rx976_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx976_pos, 1
    gt $I11, rx976_eos, rx976_fail
    sub $I11, rx976_pos, rx976_off
    ord $I11, rx976_tgt, $I11
    ne $I11, 40, rx976_fail
    add rx976_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx976_cur."!cursor_pos"(rx976_pos)
    $P10 = rx976_cur."ws"()
    unless $P10, rx976_fail
    rx976_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx976_cur."!cursor_pos"(rx976_pos)
    $P10 = rx976_cur."signature"()
    unless $P10, rx976_fail
    rx976_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx976_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx976_cur."!cursor_pos"(rx976_pos)
    $P10 = rx976_cur."ws"()
    unless $P10, rx976_fail
    rx976_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx976_pos, 1
    gt $I11, rx976_eos, rx976_fail
    sub $I11, rx976_pos, rx976_off
    ord $I11, rx976_tgt, $I11
    ne $I11, 41, rx976_fail
    add rx976_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx976_cur."!cursor_pos"(rx976_pos)
    $P10 = rx976_cur."ws"()
    unless $P10, rx976_fail
    rx976_pos = $P10."pos"()
    goto alt993_end
  alt993_1:
.annotate 'line', 437
  # rx subrule "ws" subtype=method negate=
    rx976_cur."!cursor_pos"(rx976_pos)
    $P10 = rx976_cur."ws"()
    unless $P10, rx976_fail
    rx976_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx976_cur."!cursor_pos"(rx976_pos)
    $P10 = rx976_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx976_fail
    rx976_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx976_cur."!cursor_pos"(rx976_pos)
    $P10 = rx976_cur."ws"()
    unless $P10, rx976_fail
    rx976_pos = $P10."pos"()
  alt993_end:
  # rx subrule "ws" subtype=method negate=
    rx976_cur."!cursor_pos"(rx976_pos)
    $P10 = rx976_cur."ws"()
    unless $P10, rx976_fail
    rx976_pos = $P10."pos"()
.annotate 'line', 438
    rx976_cur."!cursor_pos"(rx976_pos)
    find_lex $P1001, unicode:"$\x{a2}"
    $P1002 = $P1001."MATCH"()
    store_lex "$/", $P1002
    .const 'Sub' $P1004 = "181_1303401201.841" 
    capture_lex $P1004
    $P1006 = $P1004()
  # rx subrule "ws" subtype=method negate=
    rx976_cur."!cursor_pos"(rx976_pos)
    $P10 = rx976_cur."ws"()
    unless $P10, rx976_fail
    rx976_pos = $P10."pos"()
.annotate 'line', 439
  # rx rxquantr1008 ** 0..*
    set_addr $I10, rxquantr1008_done
    rx976_cur."!mark_push"(0, rx976_pos, $I10)
  rxquantr1008_loop:
  # rx subrule "trait" subtype=capture negate=
    rx976_cur."!cursor_pos"(rx976_pos)
    $P10 = rx976_cur."trait"()
    unless $P10, rx976_fail
    goto rxsubrule1009_pass
  rxsubrule1009_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx976_fail
  rxsubrule1009_pass:
    set_addr $I10, rxsubrule1009_back
    rx976_cur."!mark_push"(0, rx976_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx976_pos = $P10."pos"()
    set_addr $I10, rxquantr1008_done
    (rx976_rep) = rx976_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1008_done
    rx976_cur."!mark_push"(rx976_rep, rx976_pos, $I10)
    goto rxquantr1008_loop
  rxquantr1008_done:
  # rx subrule "ws" subtype=method negate=
    rx976_cur."!cursor_pos"(rx976_pos)
    $P10 = rx976_cur."ws"()
    unless $P10, rx976_fail
    rx976_pos = $P10."pos"()
  alt1011_0:
.annotate 'line', 440
    set_addr $I10, alt1011_1
    rx976_cur."!mark_push"(0, rx976_pos, $I10)
.annotate 'line', 441
  # rx subrule "ws" subtype=method negate=
    rx976_cur."!cursor_pos"(rx976_pos)
    $P10 = rx976_cur."ws"()
    unless $P10, rx976_fail
    rx976_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx976_cur."!cursor_pos"(rx976_pos)
    $P10 = rx976_cur."onlystar"()
    unless $P10, rx976_fail
    rx976_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx976_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx976_cur."!cursor_pos"(rx976_pos)
    $P10 = rx976_cur."ws"()
    unless $P10, rx976_fail
    rx976_pos = $P10."pos"()
    goto alt1011_end
  alt1011_1:
.annotate 'line', 442
  # rx subrule "ws" subtype=method negate=
    rx976_cur."!cursor_pos"(rx976_pos)
    $P10 = rx976_cur."ws"()
    unless $P10, rx976_fail
    rx976_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx976_cur."!cursor_pos"(rx976_pos)
    $P10 = rx976_cur."blockoid"()
    unless $P10, rx976_fail
    rx976_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx976_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx976_cur."!cursor_pos"(rx976_pos)
    $P10 = rx976_cur."ws"()
    unless $P10, rx976_fail
    rx976_pos = $P10."pos"()
  alt1011_end:
.annotate 'line', 443
  # rx subrule "ws" subtype=method negate=
    rx976_cur."!cursor_pos"(rx976_pos)
    $P10 = rx976_cur."ws"()
    unless $P10, rx976_fail
    rx976_pos = $P10."pos"()
.annotate 'line', 430
  # rx pass
    rx976_cur."!cursor_pass"(rx976_pos, "method_def")
    if_null rx976_debug, debug_1012
    rx976_cur."!cursor_debug"("PASS", "method_def", " at pos=", rx976_pos)
  debug_1012:
    .return (rx976_cur)
  rx976_restart:
.annotate 'line', 10
    if_null rx976_debug, debug_1013
    rx976_cur."!cursor_debug"("NEXT", "method_def")
  debug_1013:
  rx976_fail:
    (rx976_rep, rx976_pos, $I10, $P10) = rx976_cur."!mark_fail"(0)
    lt rx976_pos, -1, rx976_done
    eq rx976_pos, -1, rx976_fail
    jump $I10
  rx976_done:
    rx976_cur."!cursor_fail"()
    if_null rx976_debug, debug_1014
    rx976_cur."!cursor_debug"("FAIL", "method_def")
  debug_1014:
    .return (rx976_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__method_def"  :nsentry("!PREFIX__method_def") :subid("180_1303401201.841") :method
.annotate 'line', 10
    $P978 = self."!PREFIX__!subrule"("ws", "")
    new $P979, "ResizablePMCArray"
    push $P979, $P978
    .return ($P979)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1003"  :anon :subid("181_1303401201.841") :outer("179_1303401201.841")
.annotate 'line', 438
    new $P1005, "Integer"
    assign $P1005, 0
    store_dynamic_lex "$*INVOCANT_OK", $P1005
    .return ($P1005)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "onlystar"  :subid("182_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .const 'Sub' $P1025 = "184_1303401201.841" 
    capture_lex $P1025
    .local string rx1018_tgt
    .local int rx1018_pos
    .local int rx1018_off
    .local int rx1018_eos
    .local int rx1018_rep
    .local pmc rx1018_cur
    .local pmc rx1018_debug
    (rx1018_cur, rx1018_pos, rx1018_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1018_cur
    .local pmc match
    .lex "$/", match
    length rx1018_eos, rx1018_tgt
    gt rx1018_pos, rx1018_eos, rx1018_done
    set rx1018_off, 0
    lt rx1018_pos, 2, rx1018_start
    sub rx1018_off, rx1018_pos, 1
    substr rx1018_tgt, rx1018_tgt, rx1018_off
  rx1018_start:
    eq $I10, 1, rx1018_restart
    if_null rx1018_debug, debug_1015
    rx1018_cur."!cursor_debug"("START", "onlystar")
  debug_1015:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1021_done
    goto rxscan1021_scan
  rxscan1021_loop:
    (rx1018_pos) = rx1018_cur."from"()
    inc rx1018_pos
    rx1018_cur."!cursor_from"(rx1018_pos)
    ge rx1018_pos, rx1018_eos, rxscan1021_done
  rxscan1021_scan:
    set_addr $I10, rxscan1021_loop
    rx1018_cur."!mark_push"(0, rx1018_pos, $I10)
  rxscan1021_done:
.annotate 'line', 447
    rx1018_cur."!cursor_pos"(rx1018_pos)
    find_lex $P1022, unicode:"$\x{a2}"
    $P1023 = $P1022."MATCH"()
    store_lex "$/", $P1023
    .const 'Sub' $P1025 = "184_1303401201.841" 
    capture_lex $P1025
    $P1029 = $P1025()
    unless $P1029, rx1018_fail
.annotate 'line', 448
  # rx literal  "{"
    add $I11, rx1018_pos, 1
    gt $I11, rx1018_eos, rx1018_fail
    sub $I11, rx1018_pos, rx1018_off
    ord $I11, rx1018_tgt, $I11
    ne $I11, 123, rx1018_fail
    add rx1018_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1018_cur."!cursor_pos"(rx1018_pos)
    $P10 = rx1018_cur."ws"()
    unless $P10, rx1018_fail
    rx1018_pos = $P10."pos"()
  # rx literal  "*"
    add $I11, rx1018_pos, 1
    gt $I11, rx1018_eos, rx1018_fail
    sub $I11, rx1018_pos, rx1018_off
    ord $I11, rx1018_tgt, $I11
    ne $I11, 42, rx1018_fail
    add rx1018_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1018_cur."!cursor_pos"(rx1018_pos)
    $P10 = rx1018_cur."ws"()
    unless $P10, rx1018_fail
    rx1018_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1018_pos, 1
    gt $I11, rx1018_eos, rx1018_fail
    sub $I11, rx1018_pos, rx1018_off
    ord $I11, rx1018_tgt, $I11
    ne $I11, 125, rx1018_fail
    add rx1018_pos, 1
.annotate 'line', 449
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1018_cur."!cursor_pos"(rx1018_pos)
    $P10 = rx1018_cur."ENDSTMT"()
    unless $P10, rx1018_fail
.annotate 'line', 450
  # rx subrule "finishpad" subtype=method negate=
    rx1018_cur."!cursor_pos"(rx1018_pos)
    $P10 = rx1018_cur."finishpad"()
    unless $P10, rx1018_fail
    rx1018_pos = $P10."pos"()
.annotate 'line', 446
  # rx pass
    rx1018_cur."!cursor_pass"(rx1018_pos, "onlystar")
    if_null rx1018_debug, debug_1018
    rx1018_cur."!cursor_debug"("PASS", "onlystar", " at pos=", rx1018_pos)
  debug_1018:
    .return (rx1018_cur)
  rx1018_restart:
.annotate 'line', 10
    if_null rx1018_debug, debug_1019
    rx1018_cur."!cursor_debug"("NEXT", "onlystar")
  debug_1019:
  rx1018_fail:
    (rx1018_rep, rx1018_pos, $I10, $P10) = rx1018_cur."!mark_fail"(0)
    lt rx1018_pos, -1, rx1018_done
    eq rx1018_pos, -1, rx1018_fail
    jump $I10
  rx1018_done:
    rx1018_cur."!cursor_fail"()
    if_null rx1018_debug, debug_1020
    rx1018_cur."!cursor_debug"("FAIL", "onlystar")
  debug_1020:
    .return (rx1018_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__onlystar"  :nsentry("!PREFIX__onlystar") :subid("183_1303401201.841") :method
.annotate 'line', 10
    new $P1020, "ResizablePMCArray"
    push $P1020, ""
    .return ($P1020)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1024"  :anon :subid("184_1303401201.841") :outer("182_1303401201.841")
.annotate 'line', 447
    find_dynamic_lex $P1026, "$*MULTINESS"
    unless_null $P1026, vivify_1016
    get_hll_global $P1026, "$MULTINESS"
    unless_null $P1026, vivify_1017
    die "Contextual $*MULTINESS not found"
  vivify_1017:
  vivify_1016:
    set $S1027, $P1026
    iseq $I1028, $S1027, "proto"
    .return ($I1028)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator"  :subid("185_1303401201.841")
    .param pmc param_1031
.annotate 'line', 453
    .lex "self", param_1031
    $P1032 = param_1031."!protoregex"("multi_declarator")
    .return ($P1032)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator"  :subid("186_1303401201.841")
    .param pmc param_1034
.annotate 'line', 453
    .lex "self", param_1034
    $P1035 = param_1034."!PREFIX__!protoregex"("multi_declarator")
    .return ($P1035)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<multi>"  :subid("187_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 455
    new $P1037, "Undef"
    .lex "$*MULTINESS", $P1037
.annotate 'line', 10
    .local string rx1038_tgt
    .local int rx1038_pos
    .local int rx1038_off
    .local int rx1038_eos
    .local int rx1038_rep
    .local pmc rx1038_cur
    .local pmc rx1038_debug
    (rx1038_cur, rx1038_pos, rx1038_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1038_cur
    .local pmc match
    .lex "$/", match
    length rx1038_eos, rx1038_tgt
    gt rx1038_pos, rx1038_eos, rx1038_done
    set rx1038_off, 0
    lt rx1038_pos, 2, rx1038_start
    sub rx1038_off, rx1038_pos, 1
    substr rx1038_tgt, rx1038_tgt, rx1038_off
  rx1038_start:
    eq $I10, 1, rx1038_restart
    if_null rx1038_debug, debug_1021
    rx1038_cur."!cursor_debug"("START", "multi_declarator:sym<multi>")
  debug_1021:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1042_done
    goto rxscan1042_scan
  rxscan1042_loop:
    (rx1038_pos) = rx1038_cur."from"()
    inc rx1038_pos
    rx1038_cur."!cursor_from"(rx1038_pos)
    ge rx1038_pos, rx1038_eos, rxscan1042_done
  rxscan1042_scan:
    set_addr $I10, rxscan1042_loop
    rx1038_cur."!mark_push"(0, rx1038_pos, $I10)
  rxscan1042_done:
.annotate 'line', 455
    rx1038_cur."!cursor_pos"(rx1038_pos)
    new $P1043, "String"
    assign $P1043, "multi"
    store_lex "$*MULTINESS", $P1043
.annotate 'line', 456
  # rx subcapture "sym"
    set_addr $I10, rxcap_1044_fail
    rx1038_cur."!mark_push"(0, rx1038_pos, $I10)
  # rx literal  "multi"
    add $I11, rx1038_pos, 5
    gt $I11, rx1038_eos, rx1038_fail
    sub $I11, rx1038_pos, rx1038_off
    substr $S10, rx1038_tgt, $I11, 5
    ne $S10, "multi", rx1038_fail
    add rx1038_pos, 5
    set_addr $I10, rxcap_1044_fail
    ($I12, $I11) = rx1038_cur."!mark_peek"($I10)
    rx1038_cur."!cursor_pos"($I11)
    ($P10) = rx1038_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1038_pos, "")
    rx1038_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1044_done
  rxcap_1044_fail:
    goto rx1038_fail
  rxcap_1044_done:
.annotate 'line', 457
  # rx subrule "ws" subtype=method negate=
    rx1038_cur."!cursor_pos"(rx1038_pos)
    $P10 = rx1038_cur."ws"()
    unless $P10, rx1038_fail
    rx1038_pos = $P10."pos"()
  alt1045_0:
    set_addr $I10, alt1045_1
    rx1038_cur."!mark_push"(0, rx1038_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx1038_cur."!cursor_pos"(rx1038_pos)
    $P10 = rx1038_cur."declarator"()
    unless $P10, rx1038_fail
    rx1038_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1038_pos = $P10."pos"()
    goto alt1045_end
  alt1045_1:
    set_addr $I10, alt1045_2
    rx1038_cur."!mark_push"(0, rx1038_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx1038_cur."!cursor_pos"(rx1038_pos)
    $P10 = rx1038_cur."routine_def"()
    unless $P10, rx1038_fail
    rx1038_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx1038_pos = $P10."pos"()
    goto alt1045_end
  alt1045_2:
  # rx subrule "panic" subtype=method negate=
    rx1038_cur."!cursor_pos"(rx1038_pos)
    $P10 = rx1038_cur."panic"("Malformed multi")
    unless $P10, rx1038_fail
    rx1038_pos = $P10."pos"()
  alt1045_end:
.annotate 'line', 454
  # rx pass
    rx1038_cur."!cursor_pass"(rx1038_pos, "multi_declarator:sym<multi>")
    if_null rx1038_debug, debug_1022
    rx1038_cur."!cursor_debug"("PASS", "multi_declarator:sym<multi>", " at pos=", rx1038_pos)
  debug_1022:
    .return (rx1038_cur)
  rx1038_restart:
.annotate 'line', 10
    if_null rx1038_debug, debug_1023
    rx1038_cur."!cursor_debug"("NEXT", "multi_declarator:sym<multi>")
  debug_1023:
  rx1038_fail:
    (rx1038_rep, rx1038_pos, $I10, $P10) = rx1038_cur."!mark_fail"(0)
    lt rx1038_pos, -1, rx1038_done
    eq rx1038_pos, -1, rx1038_fail
    jump $I10
  rx1038_done:
    rx1038_cur."!cursor_fail"()
    if_null rx1038_debug, debug_1024
    rx1038_cur."!cursor_debug"("FAIL", "multi_declarator:sym<multi>")
  debug_1024:
    .return (rx1038_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<multi>"  :nsentry("!PREFIX__multi_declarator:sym<multi>") :subid("188_1303401201.841") :method
.annotate 'line', 10
    $P1040 = self."!PREFIX__!subrule"("ws", "multi")
    new $P1041, "ResizablePMCArray"
    push $P1041, $P1040
    .return ($P1041)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<proto>"  :subid("189_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 460
    new $P1047, "Undef"
    .lex "$*MULTINESS", $P1047
.annotate 'line', 10
    .local string rx1048_tgt
    .local int rx1048_pos
    .local int rx1048_off
    .local int rx1048_eos
    .local int rx1048_rep
    .local pmc rx1048_cur
    .local pmc rx1048_debug
    (rx1048_cur, rx1048_pos, rx1048_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1048_cur
    .local pmc match
    .lex "$/", match
    length rx1048_eos, rx1048_tgt
    gt rx1048_pos, rx1048_eos, rx1048_done
    set rx1048_off, 0
    lt rx1048_pos, 2, rx1048_start
    sub rx1048_off, rx1048_pos, 1
    substr rx1048_tgt, rx1048_tgt, rx1048_off
  rx1048_start:
    eq $I10, 1, rx1048_restart
    if_null rx1048_debug, debug_1025
    rx1048_cur."!cursor_debug"("START", "multi_declarator:sym<proto>")
  debug_1025:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1052_done
    goto rxscan1052_scan
  rxscan1052_loop:
    (rx1048_pos) = rx1048_cur."from"()
    inc rx1048_pos
    rx1048_cur."!cursor_from"(rx1048_pos)
    ge rx1048_pos, rx1048_eos, rxscan1052_done
  rxscan1052_scan:
    set_addr $I10, rxscan1052_loop
    rx1048_cur."!mark_push"(0, rx1048_pos, $I10)
  rxscan1052_done:
.annotate 'line', 460
    rx1048_cur."!cursor_pos"(rx1048_pos)
    new $P1053, "String"
    assign $P1053, "proto"
    store_lex "$*MULTINESS", $P1053
.annotate 'line', 461
  # rx subcapture "sym"
    set_addr $I10, rxcap_1054_fail
    rx1048_cur."!mark_push"(0, rx1048_pos, $I10)
  # rx literal  "proto"
    add $I11, rx1048_pos, 5
    gt $I11, rx1048_eos, rx1048_fail
    sub $I11, rx1048_pos, rx1048_off
    substr $S10, rx1048_tgt, $I11, 5
    ne $S10, "proto", rx1048_fail
    add rx1048_pos, 5
    set_addr $I10, rxcap_1054_fail
    ($I12, $I11) = rx1048_cur."!mark_peek"($I10)
    rx1048_cur."!cursor_pos"($I11)
    ($P10) = rx1048_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1048_pos, "")
    rx1048_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1054_done
  rxcap_1054_fail:
    goto rx1048_fail
  rxcap_1054_done:
.annotate 'line', 462
  # rx subrule "ws" subtype=method negate=
    rx1048_cur."!cursor_pos"(rx1048_pos)
    $P10 = rx1048_cur."ws"()
    unless $P10, rx1048_fail
    rx1048_pos = $P10."pos"()
  alt1055_0:
    set_addr $I10, alt1055_1
    rx1048_cur."!mark_push"(0, rx1048_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx1048_cur."!cursor_pos"(rx1048_pos)
    $P10 = rx1048_cur."declarator"()
    unless $P10, rx1048_fail
    rx1048_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1048_pos = $P10."pos"()
    goto alt1055_end
  alt1055_1:
    set_addr $I10, alt1055_2
    rx1048_cur."!mark_push"(0, rx1048_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx1048_cur."!cursor_pos"(rx1048_pos)
    $P10 = rx1048_cur."routine_def"()
    unless $P10, rx1048_fail
    rx1048_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx1048_pos = $P10."pos"()
    goto alt1055_end
  alt1055_2:
  # rx subrule "panic" subtype=method negate=
    rx1048_cur."!cursor_pos"(rx1048_pos)
    $P10 = rx1048_cur."panic"("Malformed proto")
    unless $P10, rx1048_fail
    rx1048_pos = $P10."pos"()
  alt1055_end:
.annotate 'line', 459
  # rx pass
    rx1048_cur."!cursor_pass"(rx1048_pos, "multi_declarator:sym<proto>")
    if_null rx1048_debug, debug_1026
    rx1048_cur."!cursor_debug"("PASS", "multi_declarator:sym<proto>", " at pos=", rx1048_pos)
  debug_1026:
    .return (rx1048_cur)
  rx1048_restart:
.annotate 'line', 10
    if_null rx1048_debug, debug_1027
    rx1048_cur."!cursor_debug"("NEXT", "multi_declarator:sym<proto>")
  debug_1027:
  rx1048_fail:
    (rx1048_rep, rx1048_pos, $I10, $P10) = rx1048_cur."!mark_fail"(0)
    lt rx1048_pos, -1, rx1048_done
    eq rx1048_pos, -1, rx1048_fail
    jump $I10
  rx1048_done:
    rx1048_cur."!cursor_fail"()
    if_null rx1048_debug, debug_1028
    rx1048_cur."!cursor_debug"("FAIL", "multi_declarator:sym<proto>")
  debug_1028:
    .return (rx1048_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<proto>"  :nsentry("!PREFIX__multi_declarator:sym<proto>") :subid("190_1303401201.841") :method
.annotate 'line', 10
    $P1050 = self."!PREFIX__!subrule"("ws", "proto")
    new $P1051, "ResizablePMCArray"
    push $P1051, $P1050
    .return ($P1051)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<null>"  :subid("191_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 465
    new $P1057, "Undef"
    .lex "$*MULTINESS", $P1057
.annotate 'line', 10
    .local string rx1058_tgt
    .local int rx1058_pos
    .local int rx1058_off
    .local int rx1058_eos
    .local int rx1058_rep
    .local pmc rx1058_cur
    .local pmc rx1058_debug
    (rx1058_cur, rx1058_pos, rx1058_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1058_cur
    .local pmc match
    .lex "$/", match
    length rx1058_eos, rx1058_tgt
    gt rx1058_pos, rx1058_eos, rx1058_done
    set rx1058_off, 0
    lt rx1058_pos, 2, rx1058_start
    sub rx1058_off, rx1058_pos, 1
    substr rx1058_tgt, rx1058_tgt, rx1058_off
  rx1058_start:
    eq $I10, 1, rx1058_restart
    if_null rx1058_debug, debug_1029
    rx1058_cur."!cursor_debug"("START", "multi_declarator:sym<null>")
  debug_1029:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1062_done
    goto rxscan1062_scan
  rxscan1062_loop:
    (rx1058_pos) = rx1058_cur."from"()
    inc rx1058_pos
    rx1058_cur."!cursor_from"(rx1058_pos)
    ge rx1058_pos, rx1058_eos, rxscan1062_done
  rxscan1062_scan:
    set_addr $I10, rxscan1062_loop
    rx1058_cur."!mark_push"(0, rx1058_pos, $I10)
  rxscan1062_done:
.annotate 'line', 465
    rx1058_cur."!cursor_pos"(rx1058_pos)
    new $P1063, "String"
    assign $P1063, ""
    store_lex "$*MULTINESS", $P1063
.annotate 'line', 466
  # rx subrule "declarator" subtype=capture negate=
    rx1058_cur."!cursor_pos"(rx1058_pos)
    $P10 = rx1058_cur."declarator"()
    unless $P10, rx1058_fail
    rx1058_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1058_pos = $P10."pos"()
.annotate 'line', 464
  # rx pass
    rx1058_cur."!cursor_pass"(rx1058_pos, "multi_declarator:sym<null>")
    if_null rx1058_debug, debug_1030
    rx1058_cur."!cursor_debug"("PASS", "multi_declarator:sym<null>", " at pos=", rx1058_pos)
  debug_1030:
    .return (rx1058_cur)
  rx1058_restart:
.annotate 'line', 10
    if_null rx1058_debug, debug_1031
    rx1058_cur."!cursor_debug"("NEXT", "multi_declarator:sym<null>")
  debug_1031:
  rx1058_fail:
    (rx1058_rep, rx1058_pos, $I10, $P10) = rx1058_cur."!mark_fail"(0)
    lt rx1058_pos, -1, rx1058_done
    eq rx1058_pos, -1, rx1058_fail
    jump $I10
  rx1058_done:
    rx1058_cur."!cursor_fail"()
    if_null rx1058_debug, debug_1032
    rx1058_cur."!cursor_debug"("FAIL", "multi_declarator:sym<null>")
  debug_1032:
    .return (rx1058_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<null>"  :nsentry("!PREFIX__multi_declarator:sym<null>") :subid("192_1303401201.841") :method
.annotate 'line', 10
    $P1060 = self."!PREFIX__!subrule"("declarator", "")
    new $P1061, "ResizablePMCArray"
    push $P1061, $P1060
    .return ($P1061)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "signature"  :subid("193_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .const 'Sub' $P1073 = "195_1303401201.841" 
    capture_lex $P1073
    .local string rx1065_tgt
    .local int rx1065_pos
    .local int rx1065_off
    .local int rx1065_eos
    .local int rx1065_rep
    .local pmc rx1065_cur
    .local pmc rx1065_debug
    (rx1065_cur, rx1065_pos, rx1065_tgt, $I10) = self."!cursor_start"()
    rx1065_cur."!cursor_caparray"("invocant", "parameter")
    .lex unicode:"$\x{a2}", rx1065_cur
    .local pmc match
    .lex "$/", match
    length rx1065_eos, rx1065_tgt
    gt rx1065_pos, rx1065_eos, rx1065_done
    set rx1065_off, 0
    lt rx1065_pos, 2, rx1065_start
    sub rx1065_off, rx1065_pos, 1
    substr rx1065_tgt, rx1065_tgt, rx1065_off
  rx1065_start:
    eq $I10, 1, rx1065_restart
    if_null rx1065_debug, debug_1033
    rx1065_cur."!cursor_debug"("START", "signature")
  debug_1033:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1068_done
    goto rxscan1068_scan
  rxscan1068_loop:
    (rx1065_pos) = rx1065_cur."from"()
    inc rx1065_pos
    rx1065_cur."!cursor_from"(rx1065_pos)
    ge rx1065_pos, rx1065_eos, rxscan1068_done
  rxscan1068_scan:
    set_addr $I10, rxscan1068_loop
    rx1065_cur."!mark_push"(0, rx1065_pos, $I10)
  rxscan1068_done:
.annotate 'line', 470
  # rx rxquantr1069 ** 0..1
    set_addr $I10, rxquantr1069_done
    rx1065_cur."!mark_push"(0, rx1065_pos, $I10)
  rxquantr1069_loop:
    rx1065_cur."!cursor_pos"(rx1065_pos)
    find_lex $P1070, unicode:"$\x{a2}"
    $P1071 = $P1070."MATCH"()
    store_lex "$/", $P1071
    .const 'Sub' $P1073 = "195_1303401201.841" 
    capture_lex $P1073
    $P1075 = $P1073()
    unless $P1075, rx1065_fail
  # rx subrule "ws" subtype=method negate=
    rx1065_cur."!cursor_pos"(rx1065_pos)
    $P10 = rx1065_cur."ws"()
    unless $P10, rx1065_fail
    rx1065_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx1065_cur."!cursor_pos"(rx1065_pos)
    $P10 = rx1065_cur."parameter"()
    unless $P10, rx1065_fail
    rx1065_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("invocant")
    rx1065_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1065_cur."!cursor_pos"(rx1065_pos)
    $P10 = rx1065_cur."ws"()
    unless $P10, rx1065_fail
    rx1065_pos = $P10."pos"()
  # rx literal  ":"
    add $I11, rx1065_pos, 1
    gt $I11, rx1065_eos, rx1065_fail
    sub $I11, rx1065_pos, rx1065_off
    ord $I11, rx1065_tgt, $I11
    ne $I11, 58, rx1065_fail
    add rx1065_pos, 1
    set_addr $I10, rxquantr1069_done
    (rx1065_rep) = rx1065_cur."!mark_commit"($I10)
  rxquantr1069_done:
.annotate 'line', 471
  # rx rxquantr1076 ** 0..1
    set_addr $I10, rxquantr1076_done
    rx1065_cur."!mark_push"(0, rx1065_pos, $I10)
  rxquantr1076_loop:
  # rx rxquantr1077 ** 1..*
    set_addr $I10, rxquantr1077_done
    rx1065_cur."!mark_push"(0, -1, $I10)
  rxquantr1077_loop:
  # rx subrule "ws" subtype=method negate=
    rx1065_cur."!cursor_pos"(rx1065_pos)
    $P10 = rx1065_cur."ws"()
    unless $P10, rx1065_fail
    rx1065_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx1065_cur."!cursor_pos"(rx1065_pos)
    $P10 = rx1065_cur."parameter"()
    unless $P10, rx1065_fail
    rx1065_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parameter")
    rx1065_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1065_cur."!cursor_pos"(rx1065_pos)
    $P10 = rx1065_cur."ws"()
    unless $P10, rx1065_fail
    rx1065_pos = $P10."pos"()
    set_addr $I10, rxquantr1077_done
    (rx1065_rep) = rx1065_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1077_done
    rx1065_cur."!mark_push"(rx1065_rep, rx1065_pos, $I10)
  # rx literal  ","
    add $I11, rx1065_pos, 1
    gt $I11, rx1065_eos, rx1065_fail
    sub $I11, rx1065_pos, rx1065_off
    ord $I11, rx1065_tgt, $I11
    ne $I11, 44, rx1065_fail
    add rx1065_pos, 1
    goto rxquantr1077_loop
  rxquantr1077_done:
    set_addr $I10, rxquantr1076_done
    (rx1065_rep) = rx1065_cur."!mark_commit"($I10)
  rxquantr1076_done:
.annotate 'line', 469
  # rx pass
    rx1065_cur."!cursor_pass"(rx1065_pos, "signature")
    if_null rx1065_debug, debug_1036
    rx1065_cur."!cursor_debug"("PASS", "signature", " at pos=", rx1065_pos)
  debug_1036:
    .return (rx1065_cur)
  rx1065_restart:
.annotate 'line', 10
    if_null rx1065_debug, debug_1037
    rx1065_cur."!cursor_debug"("NEXT", "signature")
  debug_1037:
  rx1065_fail:
    (rx1065_rep, rx1065_pos, $I10, $P10) = rx1065_cur."!mark_fail"(0)
    lt rx1065_pos, -1, rx1065_done
    eq rx1065_pos, -1, rx1065_fail
    jump $I10
  rx1065_done:
    rx1065_cur."!cursor_fail"()
    if_null rx1065_debug, debug_1038
    rx1065_cur."!cursor_debug"("FAIL", "signature")
  debug_1038:
    .return (rx1065_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__signature"  :nsentry("!PREFIX__signature") :subid("194_1303401201.841") :method
.annotate 'line', 10
    new $P1067, "ResizablePMCArray"
    push $P1067, ""
    .return ($P1067)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1072"  :anon :subid("195_1303401201.841") :outer("193_1303401201.841")
.annotate 'line', 470
    find_dynamic_lex $P1074, "$*INVOCANT_OK"
    unless_null $P1074, vivify_1034
    get_hll_global $P1074, "$INVOCANT_OK"
    unless_null $P1074, vivify_1035
    die "Contextual $*INVOCANT_OK not found"
  vivify_1035:
  vivify_1034:
    .return ($P1074)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "parameter"  :subid("196_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1079_tgt
    .local int rx1079_pos
    .local int rx1079_off
    .local int rx1079_eos
    .local int rx1079_rep
    .local pmc rx1079_cur
    .local pmc rx1079_debug
    (rx1079_cur, rx1079_pos, rx1079_tgt, $I10) = self."!cursor_start"()
    rx1079_cur."!cursor_caparray"("typename", "definedness", "default_value")
    .lex unicode:"$\x{a2}", rx1079_cur
    .local pmc match
    .lex "$/", match
    length rx1079_eos, rx1079_tgt
    gt rx1079_pos, rx1079_eos, rx1079_done
    set rx1079_off, 0
    lt rx1079_pos, 2, rx1079_start
    sub rx1079_off, rx1079_pos, 1
    substr rx1079_tgt, rx1079_tgt, rx1079_off
  rx1079_start:
    eq $I10, 1, rx1079_restart
    if_null rx1079_debug, debug_1039
    rx1079_cur."!cursor_debug"("START", "parameter")
  debug_1039:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1082_done
    goto rxscan1082_scan
  rxscan1082_loop:
    (rx1079_pos) = rx1079_cur."from"()
    inc rx1079_pos
    rx1079_cur."!cursor_from"(rx1079_pos)
    ge rx1079_pos, rx1079_eos, rxscan1082_done
  rxscan1082_scan:
    set_addr $I10, rxscan1082_loop
    rx1079_cur."!mark_push"(0, rx1079_pos, $I10)
  rxscan1082_done:
.annotate 'line', 475
  # rx rxquantr1083 ** 0..*
    set_addr $I10, rxquantr1083_done
    rx1079_cur."!mark_push"(0, rx1079_pos, $I10)
  rxquantr1083_loop:
  # rx subrule "typename" subtype=capture negate=
    rx1079_cur."!cursor_pos"(rx1079_pos)
    $P10 = rx1079_cur."typename"()
    unless $P10, rx1079_fail
    rx1079_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("typename")
    rx1079_pos = $P10."pos"()
  # rx rxquantr1084 ** 0..1
    set_addr $I10, rxquantr1084_done
    rx1079_cur."!mark_push"(0, rx1079_pos, $I10)
  rxquantr1084_loop:
  # rx literal  ":"
    add $I11, rx1079_pos, 1
    gt $I11, rx1079_eos, rx1079_fail
    sub $I11, rx1079_pos, rx1079_off
    ord $I11, rx1079_tgt, $I11
    ne $I11, 58, rx1079_fail
    add rx1079_pos, 1
  # rx subcapture "definedness"
    set_addr $I10, rxcap_1085_fail
    rx1079_cur."!mark_push"(0, rx1079_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1079_pos, rx1079_eos, rx1079_fail
    sub $I10, rx1079_pos, rx1079_off
    substr $S10, rx1079_tgt, $I10, 1
    index $I11, "_DU", $S10
    lt $I11, 0, rx1079_fail
    inc rx1079_pos
    set_addr $I10, rxcap_1085_fail
    ($I12, $I11) = rx1079_cur."!mark_peek"($I10)
    rx1079_cur."!cursor_pos"($I11)
    ($P10) = rx1079_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1079_pos, "")
    rx1079_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("definedness")
    goto rxcap_1085_done
  rxcap_1085_fail:
    goto rx1079_fail
  rxcap_1085_done:
    set_addr $I10, rxquantr1084_done
    (rx1079_rep) = rx1079_cur."!mark_commit"($I10)
  rxquantr1084_done:
  # rx subrule "ws" subtype=method negate=
    rx1079_cur."!cursor_pos"(rx1079_pos)
    $P10 = rx1079_cur."ws"()
    unless $P10, rx1079_fail
    rx1079_pos = $P10."pos"()
    set_addr $I10, rxquantr1083_done
    (rx1079_rep) = rx1079_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1083_done
    rx1079_cur."!mark_push"(rx1079_rep, rx1079_pos, $I10)
    goto rxquantr1083_loop
  rxquantr1083_done:
  alt1086_0:
.annotate 'line', 476
    set_addr $I10, alt1086_1
    rx1079_cur."!mark_push"(0, rx1079_pos, $I10)
.annotate 'line', 477
  # rx subcapture "quant"
    set_addr $I10, rxcap_1087_fail
    rx1079_cur."!mark_push"(0, rx1079_pos, $I10)
  # rx literal  "*"
    add $I11, rx1079_pos, 1
    gt $I11, rx1079_eos, rx1079_fail
    sub $I11, rx1079_pos, rx1079_off
    ord $I11, rx1079_tgt, $I11
    ne $I11, 42, rx1079_fail
    add rx1079_pos, 1
    set_addr $I10, rxcap_1087_fail
    ($I12, $I11) = rx1079_cur."!mark_peek"($I10)
    rx1079_cur."!cursor_pos"($I11)
    ($P10) = rx1079_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1079_pos, "")
    rx1079_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_1087_done
  rxcap_1087_fail:
    goto rx1079_fail
  rxcap_1087_done:
  # rx subrule "param_var" subtype=capture negate=
    rx1079_cur."!cursor_pos"(rx1079_pos)
    $P10 = rx1079_cur."param_var"()
    unless $P10, rx1079_fail
    rx1079_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx1079_pos = $P10."pos"()
    goto alt1086_end
  alt1086_1:
  alt1088_0:
.annotate 'line', 478
    set_addr $I10, alt1088_1
    rx1079_cur."!mark_push"(0, rx1079_pos, $I10)
  # rx subrule "param_var" subtype=capture negate=
    rx1079_cur."!cursor_pos"(rx1079_pos)
    $P10 = rx1079_cur."param_var"()
    unless $P10, rx1079_fail
    rx1079_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx1079_pos = $P10."pos"()
    goto alt1088_end
  alt1088_1:
  # rx subrule "named_param" subtype=capture negate=
    rx1079_cur."!cursor_pos"(rx1079_pos)
    $P10 = rx1079_cur."named_param"()
    unless $P10, rx1079_fail
    rx1079_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("named_param")
    rx1079_pos = $P10."pos"()
  alt1088_end:
  # rx subcapture "quant"
    set_addr $I10, rxcap_1090_fail
    rx1079_cur."!mark_push"(0, rx1079_pos, $I10)
  alt1089_0:
    set_addr $I10, alt1089_1
    rx1079_cur."!mark_push"(0, rx1079_pos, $I10)
  # rx literal  "?"
    add $I11, rx1079_pos, 1
    gt $I11, rx1079_eos, rx1079_fail
    sub $I11, rx1079_pos, rx1079_off
    ord $I11, rx1079_tgt, $I11
    ne $I11, 63, rx1079_fail
    add rx1079_pos, 1
    goto alt1089_end
  alt1089_1:
    set_addr $I10, alt1089_2
    rx1079_cur."!mark_push"(0, rx1079_pos, $I10)
  # rx literal  "!"
    add $I11, rx1079_pos, 1
    gt $I11, rx1079_eos, rx1079_fail
    sub $I11, rx1079_pos, rx1079_off
    ord $I11, rx1079_tgt, $I11
    ne $I11, 33, rx1079_fail
    add rx1079_pos, 1
    goto alt1089_end
  alt1089_2:
  alt1089_end:
    set_addr $I10, rxcap_1090_fail
    ($I12, $I11) = rx1079_cur."!mark_peek"($I10)
    rx1079_cur."!cursor_pos"($I11)
    ($P10) = rx1079_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1079_pos, "")
    rx1079_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_1090_done
  rxcap_1090_fail:
    goto rx1079_fail
  rxcap_1090_done:
  alt1086_end:
.annotate 'line', 480
  # rx rxquantr1091 ** 0..1
    set_addr $I10, rxquantr1091_done
    rx1079_cur."!mark_push"(0, rx1079_pos, $I10)
  rxquantr1091_loop:
  # rx subrule "default_value" subtype=capture negate=
    rx1079_cur."!cursor_pos"(rx1079_pos)
    $P10 = rx1079_cur."default_value"()
    unless $P10, rx1079_fail
    goto rxsubrule1092_pass
  rxsubrule1092_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1079_fail
  rxsubrule1092_pass:
    set_addr $I10, rxsubrule1092_back
    rx1079_cur."!mark_push"(0, rx1079_pos, $I10, $P10)
    $P10."!cursor_names"("default_value")
    rx1079_pos = $P10."pos"()
    set_addr $I10, rxquantr1091_done
    (rx1079_rep) = rx1079_cur."!mark_commit"($I10)
  rxquantr1091_done:
.annotate 'line', 474
  # rx pass
    rx1079_cur."!cursor_pass"(rx1079_pos, "parameter")
    if_null rx1079_debug, debug_1040
    rx1079_cur."!cursor_debug"("PASS", "parameter", " at pos=", rx1079_pos)
  debug_1040:
    .return (rx1079_cur)
  rx1079_restart:
.annotate 'line', 10
    if_null rx1079_debug, debug_1041
    rx1079_cur."!cursor_debug"("NEXT", "parameter")
  debug_1041:
  rx1079_fail:
    (rx1079_rep, rx1079_pos, $I10, $P10) = rx1079_cur."!mark_fail"(0)
    lt rx1079_pos, -1, rx1079_done
    eq rx1079_pos, -1, rx1079_fail
    jump $I10
  rx1079_done:
    rx1079_cur."!cursor_fail"()
    if_null rx1079_debug, debug_1042
    rx1079_cur."!cursor_debug"("FAIL", "parameter")
  debug_1042:
    .return (rx1079_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__parameter"  :nsentry("!PREFIX__parameter") :subid("197_1303401201.841") :method
.annotate 'line', 10
    new $P1081, "ResizablePMCArray"
    push $P1081, ""
    .return ($P1081)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "param_var"  :subid("198_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1094_tgt
    .local int rx1094_pos
    .local int rx1094_off
    .local int rx1094_eos
    .local int rx1094_rep
    .local pmc rx1094_cur
    .local pmc rx1094_debug
    (rx1094_cur, rx1094_pos, rx1094_tgt, $I10) = self."!cursor_start"()
    rx1094_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx1094_cur
    .local pmc match
    .lex "$/", match
    length rx1094_eos, rx1094_tgt
    gt rx1094_pos, rx1094_eos, rx1094_done
    set rx1094_off, 0
    lt rx1094_pos, 2, rx1094_start
    sub rx1094_off, rx1094_pos, 1
    substr rx1094_tgt, rx1094_tgt, rx1094_off
  rx1094_start:
    eq $I10, 1, rx1094_restart
    if_null rx1094_debug, debug_1043
    rx1094_cur."!cursor_debug"("START", "param_var")
  debug_1043:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1098_done
    goto rxscan1098_scan
  rxscan1098_loop:
    (rx1094_pos) = rx1094_cur."from"()
    inc rx1094_pos
    rx1094_cur."!cursor_from"(rx1094_pos)
    ge rx1094_pos, rx1094_eos, rxscan1098_done
  rxscan1098_scan:
    set_addr $I10, rxscan1098_loop
    rx1094_cur."!mark_push"(0, rx1094_pos, $I10)
  rxscan1098_done:
.annotate 'line', 484
  # rx subrule "sigil" subtype=capture negate=
    rx1094_cur."!cursor_pos"(rx1094_pos)
    $P10 = rx1094_cur."sigil"()
    unless $P10, rx1094_fail
    rx1094_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1094_pos = $P10."pos"()
  # rx rxquantr1099 ** 0..1
    set_addr $I10, rxquantr1099_done
    rx1094_cur."!mark_push"(0, rx1094_pos, $I10)
  rxquantr1099_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx1094_cur."!cursor_pos"(rx1094_pos)
    $P10 = rx1094_cur."twigil"()
    unless $P10, rx1094_fail
    goto rxsubrule1100_pass
  rxsubrule1100_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1094_fail
  rxsubrule1100_pass:
    set_addr $I10, rxsubrule1100_back
    rx1094_cur."!mark_push"(0, rx1094_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx1094_pos = $P10."pos"()
    set_addr $I10, rxquantr1099_done
    (rx1094_rep) = rx1094_cur."!mark_commit"($I10)
  rxquantr1099_done:
  alt1101_0:
.annotate 'line', 485
    set_addr $I10, alt1101_1
    rx1094_cur."!mark_push"(0, rx1094_pos, $I10)
  # rx subrule "ident" subtype=capture negate=
    rx1094_cur."!cursor_pos"(rx1094_pos)
    $P10 = rx1094_cur."ident"()
    unless $P10, rx1094_fail
    rx1094_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1094_pos = $P10."pos"()
    goto alt1101_end
  alt1101_1:
  # rx subcapture "name"
    set_addr $I10, rxcap_1102_fail
    rx1094_cur."!mark_push"(0, rx1094_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1094_pos, rx1094_eos, rx1094_fail
    sub $I10, rx1094_pos, rx1094_off
    substr $S10, rx1094_tgt, $I10, 1
    index $I11, "/!", $S10
    lt $I11, 0, rx1094_fail
    inc rx1094_pos
    set_addr $I10, rxcap_1102_fail
    ($I12, $I11) = rx1094_cur."!mark_peek"($I10)
    rx1094_cur."!cursor_pos"($I11)
    ($P10) = rx1094_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1094_pos, "")
    rx1094_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    goto rxcap_1102_done
  rxcap_1102_fail:
    goto rx1094_fail
  rxcap_1102_done:
  alt1101_end:
.annotate 'line', 483
  # rx pass
    rx1094_cur."!cursor_pass"(rx1094_pos, "param_var")
    if_null rx1094_debug, debug_1044
    rx1094_cur."!cursor_debug"("PASS", "param_var", " at pos=", rx1094_pos)
  debug_1044:
    .return (rx1094_cur)
  rx1094_restart:
.annotate 'line', 10
    if_null rx1094_debug, debug_1045
    rx1094_cur."!cursor_debug"("NEXT", "param_var")
  debug_1045:
  rx1094_fail:
    (rx1094_rep, rx1094_pos, $I10, $P10) = rx1094_cur."!mark_fail"(0)
    lt rx1094_pos, -1, rx1094_done
    eq rx1094_pos, -1, rx1094_fail
    jump $I10
  rx1094_done:
    rx1094_cur."!cursor_fail"()
    if_null rx1094_debug, debug_1046
    rx1094_cur."!cursor_debug"("FAIL", "param_var")
  debug_1046:
    .return (rx1094_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__param_var"  :nsentry("!PREFIX__param_var") :subid("199_1303401201.841") :method
.annotate 'line', 10
    $P1096 = self."!PREFIX__!subrule"("sigil", "")
    new $P1097, "ResizablePMCArray"
    push $P1097, $P1096
    .return ($P1097)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "named_param"  :subid("200_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1104_tgt
    .local int rx1104_pos
    .local int rx1104_off
    .local int rx1104_eos
    .local int rx1104_rep
    .local pmc rx1104_cur
    .local pmc rx1104_debug
    (rx1104_cur, rx1104_pos, rx1104_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1104_cur
    .local pmc match
    .lex "$/", match
    length rx1104_eos, rx1104_tgt
    gt rx1104_pos, rx1104_eos, rx1104_done
    set rx1104_off, 0
    lt rx1104_pos, 2, rx1104_start
    sub rx1104_off, rx1104_pos, 1
    substr rx1104_tgt, rx1104_tgt, rx1104_off
  rx1104_start:
    eq $I10, 1, rx1104_restart
    if_null rx1104_debug, debug_1047
    rx1104_cur."!cursor_debug"("START", "named_param")
  debug_1047:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1108_done
    goto rxscan1108_scan
  rxscan1108_loop:
    (rx1104_pos) = rx1104_cur."from"()
    inc rx1104_pos
    rx1104_cur."!cursor_from"(rx1104_pos)
    ge rx1104_pos, rx1104_eos, rxscan1108_done
  rxscan1108_scan:
    set_addr $I10, rxscan1108_loop
    rx1104_cur."!mark_push"(0, rx1104_pos, $I10)
  rxscan1108_done:
.annotate 'line', 489
  # rx literal  ":"
    add $I11, rx1104_pos, 1
    gt $I11, rx1104_eos, rx1104_fail
    sub $I11, rx1104_pos, rx1104_off
    ord $I11, rx1104_tgt, $I11
    ne $I11, 58, rx1104_fail
    add rx1104_pos, 1
  # rx subrule "param_var" subtype=capture negate=
    rx1104_cur."!cursor_pos"(rx1104_pos)
    $P10 = rx1104_cur."param_var"()
    unless $P10, rx1104_fail
    rx1104_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx1104_pos = $P10."pos"()
.annotate 'line', 488
  # rx pass
    rx1104_cur."!cursor_pass"(rx1104_pos, "named_param")
    if_null rx1104_debug, debug_1048
    rx1104_cur."!cursor_debug"("PASS", "named_param", " at pos=", rx1104_pos)
  debug_1048:
    .return (rx1104_cur)
  rx1104_restart:
.annotate 'line', 10
    if_null rx1104_debug, debug_1049
    rx1104_cur."!cursor_debug"("NEXT", "named_param")
  debug_1049:
  rx1104_fail:
    (rx1104_rep, rx1104_pos, $I10, $P10) = rx1104_cur."!mark_fail"(0)
    lt rx1104_pos, -1, rx1104_done
    eq rx1104_pos, -1, rx1104_fail
    jump $I10
  rx1104_done:
    rx1104_cur."!cursor_fail"()
    if_null rx1104_debug, debug_1050
    rx1104_cur."!cursor_debug"("FAIL", "named_param")
  debug_1050:
    .return (rx1104_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__named_param"  :nsentry("!PREFIX__named_param") :subid("201_1303401201.841") :method
.annotate 'line', 10
    $P1106 = self."!PREFIX__!subrule"("param_var", ":")
    new $P1107, "ResizablePMCArray"
    push $P1107, $P1106
    .return ($P1107)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "default_value"  :subid("202_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1110_tgt
    .local int rx1110_pos
    .local int rx1110_off
    .local int rx1110_eos
    .local int rx1110_rep
    .local pmc rx1110_cur
    .local pmc rx1110_debug
    (rx1110_cur, rx1110_pos, rx1110_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1110_cur
    .local pmc match
    .lex "$/", match
    length rx1110_eos, rx1110_tgt
    gt rx1110_pos, rx1110_eos, rx1110_done
    set rx1110_off, 0
    lt rx1110_pos, 2, rx1110_start
    sub rx1110_off, rx1110_pos, 1
    substr rx1110_tgt, rx1110_tgt, rx1110_off
  rx1110_start:
    eq $I10, 1, rx1110_restart
    if_null rx1110_debug, debug_1051
    rx1110_cur."!cursor_debug"("START", "default_value")
  debug_1051:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1114_done
    goto rxscan1114_scan
  rxscan1114_loop:
    (rx1110_pos) = rx1110_cur."from"()
    inc rx1110_pos
    rx1110_cur."!cursor_from"(rx1110_pos)
    ge rx1110_pos, rx1110_eos, rxscan1114_done
  rxscan1114_scan:
    set_addr $I10, rxscan1114_loop
    rx1110_cur."!mark_push"(0, rx1110_pos, $I10)
  rxscan1114_done:
.annotate 'line', 492
  # rx subrule "ws" subtype=method negate=
    rx1110_cur."!cursor_pos"(rx1110_pos)
    $P10 = rx1110_cur."ws"()
    unless $P10, rx1110_fail
    rx1110_pos = $P10."pos"()
  # rx literal  "="
    add $I11, rx1110_pos, 1
    gt $I11, rx1110_eos, rx1110_fail
    sub $I11, rx1110_pos, rx1110_off
    ord $I11, rx1110_tgt, $I11
    ne $I11, 61, rx1110_fail
    add rx1110_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1110_cur."!cursor_pos"(rx1110_pos)
    $P10 = rx1110_cur."ws"()
    unless $P10, rx1110_fail
    rx1110_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1110_cur."!cursor_pos"(rx1110_pos)
    $P10 = rx1110_cur."EXPR"("i=")
    unless $P10, rx1110_fail
    rx1110_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1110_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1110_cur."!cursor_pos"(rx1110_pos)
    $P10 = rx1110_cur."ws"()
    unless $P10, rx1110_fail
    rx1110_pos = $P10."pos"()
  # rx pass
    rx1110_cur."!cursor_pass"(rx1110_pos, "default_value")
    if_null rx1110_debug, debug_1052
    rx1110_cur."!cursor_debug"("PASS", "default_value", " at pos=", rx1110_pos)
  debug_1052:
    .return (rx1110_cur)
  rx1110_restart:
.annotate 'line', 10
    if_null rx1110_debug, debug_1053
    rx1110_cur."!cursor_debug"("NEXT", "default_value")
  debug_1053:
  rx1110_fail:
    (rx1110_rep, rx1110_pos, $I10, $P10) = rx1110_cur."!mark_fail"(0)
    lt rx1110_pos, -1, rx1110_done
    eq rx1110_pos, -1, rx1110_fail
    jump $I10
  rx1110_done:
    rx1110_cur."!cursor_fail"()
    if_null rx1110_debug, debug_1054
    rx1110_cur."!cursor_debug"("FAIL", "default_value")
  debug_1054:
    .return (rx1110_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__default_value"  :nsentry("!PREFIX__default_value") :subid("203_1303401201.841") :method
.annotate 'line', 10
    $P1112 = self."!PREFIX__!subrule"("ws", "")
    new $P1113, "ResizablePMCArray"
    push $P1113, $P1112
    .return ($P1113)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait"  :subid("204_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1119_tgt
    .local int rx1119_pos
    .local int rx1119_off
    .local int rx1119_eos
    .local int rx1119_rep
    .local pmc rx1119_cur
    .local pmc rx1119_debug
    (rx1119_cur, rx1119_pos, rx1119_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1119_cur
    .local pmc match
    .lex "$/", match
    length rx1119_eos, rx1119_tgt
    gt rx1119_pos, rx1119_eos, rx1119_done
    set rx1119_off, 0
    lt rx1119_pos, 2, rx1119_start
    sub rx1119_off, rx1119_pos, 1
    substr rx1119_tgt, rx1119_tgt, rx1119_off
  rx1119_start:
    eq $I10, 1, rx1119_restart
    if_null rx1119_debug, debug_1055
    rx1119_cur."!cursor_debug"("START", "trait")
  debug_1055:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1123_done
    goto rxscan1123_scan
  rxscan1123_loop:
    (rx1119_pos) = rx1119_cur."from"()
    inc rx1119_pos
    rx1119_cur."!cursor_from"(rx1119_pos)
    ge rx1119_pos, rx1119_eos, rxscan1123_done
  rxscan1123_scan:
    set_addr $I10, rxscan1123_loop
    rx1119_cur."!mark_push"(0, rx1119_pos, $I10)
  rxscan1123_done:
.annotate 'line', 494
  # rx subrule "ws" subtype=method negate=
    rx1119_cur."!cursor_pos"(rx1119_pos)
    $P10 = rx1119_cur."ws"()
    unless $P10, rx1119_fail
    rx1119_pos = $P10."pos"()
  # rx subrule "trait_mod" subtype=capture negate=
    rx1119_cur."!cursor_pos"(rx1119_pos)
    $P10 = rx1119_cur."trait_mod"()
    unless $P10, rx1119_fail
    rx1119_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("trait_mod")
    rx1119_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1119_cur."!cursor_pos"(rx1119_pos)
    $P10 = rx1119_cur."ws"()
    unless $P10, rx1119_fail
    rx1119_pos = $P10."pos"()
  # rx pass
    rx1119_cur."!cursor_pass"(rx1119_pos, "trait")
    if_null rx1119_debug, debug_1056
    rx1119_cur."!cursor_debug"("PASS", "trait", " at pos=", rx1119_pos)
  debug_1056:
    .return (rx1119_cur)
  rx1119_restart:
.annotate 'line', 10
    if_null rx1119_debug, debug_1057
    rx1119_cur."!cursor_debug"("NEXT", "trait")
  debug_1057:
  rx1119_fail:
    (rx1119_rep, rx1119_pos, $I10, $P10) = rx1119_cur."!mark_fail"(0)
    lt rx1119_pos, -1, rx1119_done
    eq rx1119_pos, -1, rx1119_fail
    jump $I10
  rx1119_done:
    rx1119_cur."!cursor_fail"()
    if_null rx1119_debug, debug_1058
    rx1119_cur."!cursor_debug"("FAIL", "trait")
  debug_1058:
    .return (rx1119_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait"  :nsentry("!PREFIX__trait") :subid("205_1303401201.841") :method
.annotate 'line', 10
    $P1121 = self."!PREFIX__!subrule"("ws", "")
    new $P1122, "ResizablePMCArray"
    push $P1122, $P1121
    .return ($P1122)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod"  :subid("206_1303401201.841")
    .param pmc param_1127
.annotate 'line', 496
    .lex "self", param_1127
    $P1128 = param_1127."!protoregex"("trait_mod")
    .return ($P1128)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod"  :subid("207_1303401201.841")
    .param pmc param_1130
.annotate 'line', 496
    .lex "self", param_1130
    $P1131 = param_1130."!PREFIX__!protoregex"("trait_mod")
    .return ($P1131)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod:sym<is>"  :subid("208_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1133_tgt
    .local int rx1133_pos
    .local int rx1133_off
    .local int rx1133_eos
    .local int rx1133_rep
    .local pmc rx1133_cur
    .local pmc rx1133_debug
    (rx1133_cur, rx1133_pos, rx1133_tgt, $I10) = self."!cursor_start"()
    rx1133_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx1133_cur
    .local pmc match
    .lex "$/", match
    length rx1133_eos, rx1133_tgt
    gt rx1133_pos, rx1133_eos, rx1133_done
    set rx1133_off, 0
    lt rx1133_pos, 2, rx1133_start
    sub rx1133_off, rx1133_pos, 1
    substr rx1133_tgt, rx1133_tgt, rx1133_off
  rx1133_start:
    eq $I10, 1, rx1133_restart
    if_null rx1133_debug, debug_1059
    rx1133_cur."!cursor_debug"("START", "trait_mod:sym<is>")
  debug_1059:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1137_done
    goto rxscan1137_scan
  rxscan1137_loop:
    (rx1133_pos) = rx1133_cur."from"()
    inc rx1133_pos
    rx1133_cur."!cursor_from"(rx1133_pos)
    ge rx1133_pos, rx1133_eos, rxscan1137_done
  rxscan1137_scan:
    set_addr $I10, rxscan1137_loop
    rx1133_cur."!mark_push"(0, rx1133_pos, $I10)
  rxscan1137_done:
.annotate 'line', 497
  # rx subcapture "sym"
    set_addr $I10, rxcap_1138_fail
    rx1133_cur."!mark_push"(0, rx1133_pos, $I10)
  # rx literal  "is"
    add $I11, rx1133_pos, 2
    gt $I11, rx1133_eos, rx1133_fail
    sub $I11, rx1133_pos, rx1133_off
    substr $S10, rx1133_tgt, $I11, 2
    ne $S10, "is", rx1133_fail
    add rx1133_pos, 2
    set_addr $I10, rxcap_1138_fail
    ($I12, $I11) = rx1133_cur."!mark_peek"($I10)
    rx1133_cur."!cursor_pos"($I11)
    ($P10) = rx1133_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1133_pos, "")
    rx1133_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1138_done
  rxcap_1138_fail:
    goto rx1133_fail
  rxcap_1138_done:
  # rx subrule "ws" subtype=method negate=
    rx1133_cur."!cursor_pos"(rx1133_pos)
    $P10 = rx1133_cur."ws"()
    unless $P10, rx1133_fail
    rx1133_pos = $P10."pos"()
  # rx subrule "deflongname" subtype=capture negate=
    rx1133_cur."!cursor_pos"(rx1133_pos)
    $P10 = rx1133_cur."deflongname"()
    unless $P10, rx1133_fail
    rx1133_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx1133_pos = $P10."pos"()
  # rx rxquantr1140 ** 0..1
    set_addr $I10, rxquantr1140_done
    rx1133_cur."!mark_push"(0, rx1133_pos, $I10)
  rxquantr1140_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx1133_cur."!cursor_pos"(rx1133_pos)
    $P10 = rx1133_cur."circumfix"()
    unless $P10, rx1133_fail
    goto rxsubrule1141_pass
  rxsubrule1141_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1133_fail
  rxsubrule1141_pass:
    set_addr $I10, rxsubrule1141_back
    rx1133_cur."!mark_push"(0, rx1133_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx1133_pos = $P10."pos"()
    set_addr $I10, rxquantr1140_done
    (rx1133_rep) = rx1133_cur."!mark_commit"($I10)
  rxquantr1140_done:
  # rx subrule "ws" subtype=method negate=
    rx1133_cur."!cursor_pos"(rx1133_pos)
    $P10 = rx1133_cur."ws"()
    unless $P10, rx1133_fail
    rx1133_pos = $P10."pos"()
  # rx pass
    rx1133_cur."!cursor_pass"(rx1133_pos, "trait_mod:sym<is>")
    if_null rx1133_debug, debug_1060
    rx1133_cur."!cursor_debug"("PASS", "trait_mod:sym<is>", " at pos=", rx1133_pos)
  debug_1060:
    .return (rx1133_cur)
  rx1133_restart:
.annotate 'line', 10
    if_null rx1133_debug, debug_1061
    rx1133_cur."!cursor_debug"("NEXT", "trait_mod:sym<is>")
  debug_1061:
  rx1133_fail:
    (rx1133_rep, rx1133_pos, $I10, $P10) = rx1133_cur."!mark_fail"(0)
    lt rx1133_pos, -1, rx1133_done
    eq rx1133_pos, -1, rx1133_fail
    jump $I10
  rx1133_done:
    rx1133_cur."!cursor_fail"()
    if_null rx1133_debug, debug_1062
    rx1133_cur."!cursor_debug"("FAIL", "trait_mod:sym<is>")
  debug_1062:
    .return (rx1133_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod:sym<is>"  :nsentry("!PREFIX__trait_mod:sym<is>") :subid("209_1303401201.841") :method
.annotate 'line', 10
    $P1135 = self."!PREFIX__!subrule"("ws", "is")
    new $P1136, "ResizablePMCArray"
    push $P1136, $P1135
    .return ($P1136)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "regex_declarator"  :subid("210_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1144_tgt
    .local int rx1144_pos
    .local int rx1144_off
    .local int rx1144_eos
    .local int rx1144_rep
    .local pmc rx1144_cur
    .local pmc rx1144_debug
    (rx1144_cur, rx1144_pos, rx1144_tgt, $I10) = self."!cursor_start"()
    rx1144_cur."!cursor_caparray"("signature")
    .lex unicode:"$\x{a2}", rx1144_cur
    .local pmc match
    .lex "$/", match
    length rx1144_eos, rx1144_tgt
    gt rx1144_pos, rx1144_eos, rx1144_done
    set rx1144_off, 0
    lt rx1144_pos, 2, rx1144_start
    sub rx1144_off, rx1144_pos, 1
    substr rx1144_tgt, rx1144_tgt, rx1144_off
  rx1144_start:
    eq $I10, 1, rx1144_restart
    if_null rx1144_debug, debug_1063
    rx1144_cur."!cursor_debug"("START", "regex_declarator")
  debug_1063:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1148_done
    goto rxscan1148_scan
  rxscan1148_loop:
    (rx1144_pos) = rx1144_cur."from"()
    inc rx1144_pos
    rx1144_cur."!cursor_from"(rx1144_pos)
    ge rx1144_pos, rx1144_eos, rxscan1148_done
  rxscan1148_scan:
    set_addr $I10, rxscan1148_loop
    rx1144_cur."!mark_push"(0, rx1144_pos, $I10)
  rxscan1148_done:
.annotate 'line', 499
  # rx subrule "ws" subtype=method negate=
    rx1144_cur."!cursor_pos"(rx1144_pos)
    $P10 = rx1144_cur."ws"()
    unless $P10, rx1144_fail
    rx1144_pos = $P10."pos"()
  alt1150_0:
.annotate 'line', 500
    set_addr $I10, alt1150_1
    rx1144_cur."!mark_push"(0, rx1144_pos, $I10)
.annotate 'line', 501
  # rx subrule "ws" subtype=method negate=
    rx1144_cur."!cursor_pos"(rx1144_pos)
    $P10 = rx1144_cur."ws"()
    unless $P10, rx1144_fail
    rx1144_pos = $P10."pos"()
  # rx subcapture "proto"
    set_addr $I10, rxcap_1152_fail
    rx1144_cur."!mark_push"(0, rx1144_pos, $I10)
  # rx literal  "proto"
    add $I11, rx1144_pos, 5
    gt $I11, rx1144_eos, rx1144_fail
    sub $I11, rx1144_pos, rx1144_off
    substr $S10, rx1144_tgt, $I11, 5
    ne $S10, "proto", rx1144_fail
    add rx1144_pos, 5
    set_addr $I10, rxcap_1152_fail
    ($I12, $I11) = rx1144_cur."!mark_peek"($I10)
    rx1144_cur."!cursor_pos"($I11)
    ($P10) = rx1144_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1144_pos, "")
    rx1144_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("proto")
    goto rxcap_1152_done
  rxcap_1152_fail:
    goto rx1144_fail
  rxcap_1152_done:
  # rx subrule "ws" subtype=method negate=
    rx1144_cur."!cursor_pos"(rx1144_pos)
    $P10 = rx1144_cur."ws"()
    unless $P10, rx1144_fail
    rx1144_pos = $P10."pos"()
  alt1154_0:
    set_addr $I10, alt1154_1
    rx1144_cur."!mark_push"(0, rx1144_pos, $I10)
  # rx literal  "regex"
    add $I11, rx1144_pos, 5
    gt $I11, rx1144_eos, rx1144_fail
    sub $I11, rx1144_pos, rx1144_off
    substr $S10, rx1144_tgt, $I11, 5
    ne $S10, "regex", rx1144_fail
    add rx1144_pos, 5
    goto alt1154_end
  alt1154_1:
    set_addr $I10, alt1154_2
    rx1144_cur."!mark_push"(0, rx1144_pos, $I10)
  # rx literal  "token"
    add $I11, rx1144_pos, 5
    gt $I11, rx1144_eos, rx1144_fail
    sub $I11, rx1144_pos, rx1144_off
    substr $S10, rx1144_tgt, $I11, 5
    ne $S10, "token", rx1144_fail
    add rx1144_pos, 5
    goto alt1154_end
  alt1154_2:
  # rx literal  "rule"
    add $I11, rx1144_pos, 4
    gt $I11, rx1144_eos, rx1144_fail
    sub $I11, rx1144_pos, rx1144_off
    substr $S10, rx1144_tgt, $I11, 4
    ne $S10, "rule", rx1144_fail
    add rx1144_pos, 4
  alt1154_end:
  # rx subrule "ws" subtype=method negate=
    rx1144_cur."!cursor_pos"(rx1144_pos)
    $P10 = rx1144_cur."ws"()
    unless $P10, rx1144_fail
    rx1144_pos = $P10."pos"()
.annotate 'line', 502
  # rx subrule "deflongname" subtype=capture negate=
    rx1144_cur."!cursor_pos"(rx1144_pos)
    $P10 = rx1144_cur."deflongname"()
    unless $P10, rx1144_fail
    rx1144_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1144_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1144_cur."!cursor_pos"(rx1144_pos)
    $P10 = rx1144_cur."ws"()
    unless $P10, rx1144_fail
    rx1144_pos = $P10."pos"()
  alt1157_0:
.annotate 'line', 503
    set_addr $I10, alt1157_1
    rx1144_cur."!mark_push"(0, rx1144_pos, $I10)
.annotate 'line', 504
  # rx subrule "ws" subtype=method negate=
    rx1144_cur."!cursor_pos"(rx1144_pos)
    $P10 = rx1144_cur."ws"()
    unless $P10, rx1144_fail
    rx1144_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx1144_pos, 1
    gt $I11, rx1144_eos, rx1144_fail
    sub $I11, rx1144_pos, rx1144_off
    ord $I11, rx1144_tgt, $I11
    ne $I11, 123, rx1144_fail
    add rx1144_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1144_cur."!cursor_pos"(rx1144_pos)
    $P10 = rx1144_cur."ws"()
    unless $P10, rx1144_fail
    rx1144_pos = $P10."pos"()
  # rx literal  "<...>"
    add $I11, rx1144_pos, 5
    gt $I11, rx1144_eos, rx1144_fail
    sub $I11, rx1144_pos, rx1144_off
    substr $S10, rx1144_tgt, $I11, 5
    ne $S10, "<...>", rx1144_fail
    add rx1144_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx1144_cur."!cursor_pos"(rx1144_pos)
    $P10 = rx1144_cur."ws"()
    unless $P10, rx1144_fail
    rx1144_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1144_pos, 1
    gt $I11, rx1144_eos, rx1144_fail
    sub $I11, rx1144_pos, rx1144_off
    ord $I11, rx1144_tgt, $I11
    ne $I11, 125, rx1144_fail
    add rx1144_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1144_cur."!cursor_pos"(rx1144_pos)
    $P10 = rx1144_cur."ENDSTMT"()
    unless $P10, rx1144_fail
  # rx subrule "ws" subtype=method negate=
    rx1144_cur."!cursor_pos"(rx1144_pos)
    $P10 = rx1144_cur."ws"()
    unless $P10, rx1144_fail
    rx1144_pos = $P10."pos"()
    goto alt1157_end
  alt1157_1:
    set_addr $I10, alt1157_2
    rx1144_cur."!mark_push"(0, rx1144_pos, $I10)
.annotate 'line', 505
  # rx subrule "ws" subtype=method negate=
    rx1144_cur."!cursor_pos"(rx1144_pos)
    $P10 = rx1144_cur."ws"()
    unless $P10, rx1144_fail
    rx1144_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx1144_pos, 1
    gt $I11, rx1144_eos, rx1144_fail
    sub $I11, rx1144_pos, rx1144_off
    ord $I11, rx1144_tgt, $I11
    ne $I11, 123, rx1144_fail
    add rx1144_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1144_cur."!cursor_pos"(rx1144_pos)
    $P10 = rx1144_cur."ws"()
    unless $P10, rx1144_fail
    rx1144_pos = $P10."pos"()
  # rx literal  "<*>"
    add $I11, rx1144_pos, 3
    gt $I11, rx1144_eos, rx1144_fail
    sub $I11, rx1144_pos, rx1144_off
    substr $S10, rx1144_tgt, $I11, 3
    ne $S10, "<*>", rx1144_fail
    add rx1144_pos, 3
  # rx subrule "ws" subtype=method negate=
    rx1144_cur."!cursor_pos"(rx1144_pos)
    $P10 = rx1144_cur."ws"()
    unless $P10, rx1144_fail
    rx1144_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1144_pos, 1
    gt $I11, rx1144_eos, rx1144_fail
    sub $I11, rx1144_pos, rx1144_off
    ord $I11, rx1144_tgt, $I11
    ne $I11, 125, rx1144_fail
    add rx1144_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1144_cur."!cursor_pos"(rx1144_pos)
    $P10 = rx1144_cur."ENDSTMT"()
    unless $P10, rx1144_fail
  # rx subrule "ws" subtype=method negate=
    rx1144_cur."!cursor_pos"(rx1144_pos)
    $P10 = rx1144_cur."ws"()
    unless $P10, rx1144_fail
    rx1144_pos = $P10."pos"()
    goto alt1157_end
  alt1157_2:
.annotate 'line', 506
  # rx subrule "ws" subtype=method negate=
    rx1144_cur."!cursor_pos"(rx1144_pos)
    $P10 = rx1144_cur."ws"()
    unless $P10, rx1144_fail
    rx1144_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1144_cur."!cursor_pos"(rx1144_pos)
    $P10 = rx1144_cur."panic"("Proto regex body must be <*> (or <...>, which is deprecated)")
    unless $P10, rx1144_fail
    rx1144_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1144_cur."!cursor_pos"(rx1144_pos)
    $P10 = rx1144_cur."ws"()
    unless $P10, rx1144_fail
    rx1144_pos = $P10."pos"()
  alt1157_end:
.annotate 'line', 507
  # rx subrule "ws" subtype=method negate=
    rx1144_cur."!cursor_pos"(rx1144_pos)
    $P10 = rx1144_cur."ws"()
    unless $P10, rx1144_fail
    rx1144_pos = $P10."pos"()
.annotate 'line', 501
    goto alt1150_end
  alt1150_1:
.annotate 'line', 508
  # rx subrule "ws" subtype=method negate=
    rx1144_cur."!cursor_pos"(rx1144_pos)
    $P10 = rx1144_cur."ws"()
    unless $P10, rx1144_fail
    rx1144_pos = $P10."pos"()
  # rx subcapture "sym"
    set_addr $I10, rxcap_1171_fail
    rx1144_cur."!mark_push"(0, rx1144_pos, $I10)
  alt1170_0:
    set_addr $I10, alt1170_1
    rx1144_cur."!mark_push"(0, rx1144_pos, $I10)
  # rx literal  "regex"
    add $I11, rx1144_pos, 5
    gt $I11, rx1144_eos, rx1144_fail
    sub $I11, rx1144_pos, rx1144_off
    substr $S10, rx1144_tgt, $I11, 5
    ne $S10, "regex", rx1144_fail
    add rx1144_pos, 5
    goto alt1170_end
  alt1170_1:
    set_addr $I10, alt1170_2
    rx1144_cur."!mark_push"(0, rx1144_pos, $I10)
  # rx literal  "token"
    add $I11, rx1144_pos, 5
    gt $I11, rx1144_eos, rx1144_fail
    sub $I11, rx1144_pos, rx1144_off
    substr $S10, rx1144_tgt, $I11, 5
    ne $S10, "token", rx1144_fail
    add rx1144_pos, 5
    goto alt1170_end
  alt1170_2:
  # rx literal  "rule"
    add $I11, rx1144_pos, 4
    gt $I11, rx1144_eos, rx1144_fail
    sub $I11, rx1144_pos, rx1144_off
    substr $S10, rx1144_tgt, $I11, 4
    ne $S10, "rule", rx1144_fail
    add rx1144_pos, 4
  alt1170_end:
    set_addr $I10, rxcap_1171_fail
    ($I12, $I11) = rx1144_cur."!mark_peek"($I10)
    rx1144_cur."!cursor_pos"($I11)
    ($P10) = rx1144_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1144_pos, "")
    rx1144_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1171_done
  rxcap_1171_fail:
    goto rx1144_fail
  rxcap_1171_done:
  # rx subrule "ws" subtype=method negate=
    rx1144_cur."!cursor_pos"(rx1144_pos)
    $P10 = rx1144_cur."ws"()
    unless $P10, rx1144_fail
    rx1144_pos = $P10."pos"()
.annotate 'line', 509
  # rx subrule "deflongname" subtype=capture negate=
    rx1144_cur."!cursor_pos"(rx1144_pos)
    $P10 = rx1144_cur."deflongname"()
    unless $P10, rx1144_fail
    rx1144_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1144_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1144_cur."!cursor_pos"(rx1144_pos)
    $P10 = rx1144_cur."ws"()
    unless $P10, rx1144_fail
    rx1144_pos = $P10."pos"()
.annotate 'line', 510
  # rx subrule "newpad" subtype=method negate=
    rx1144_cur."!cursor_pos"(rx1144_pos)
    $P10 = rx1144_cur."newpad"()
    unless $P10, rx1144_fail
    rx1144_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1144_cur."!cursor_pos"(rx1144_pos)
    $P10 = rx1144_cur."ws"()
    unless $P10, rx1144_fail
    rx1144_pos = $P10."pos"()
.annotate 'line', 511
  # rx rxquantr1175 ** 0..1
    set_addr $I10, rxquantr1175_done
    rx1144_cur."!mark_push"(0, rx1144_pos, $I10)
  rxquantr1175_loop:
  # rx subrule "ws" subtype=method negate=
    rx1144_cur."!cursor_pos"(rx1144_pos)
    $P10 = rx1144_cur."ws"()
    unless $P10, rx1144_fail
    rx1144_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1144_pos, 1
    gt $I11, rx1144_eos, rx1144_fail
    sub $I11, rx1144_pos, rx1144_off
    ord $I11, rx1144_tgt, $I11
    ne $I11, 40, rx1144_fail
    add rx1144_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1144_cur."!cursor_pos"(rx1144_pos)
    $P10 = rx1144_cur."ws"()
    unless $P10, rx1144_fail
    rx1144_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx1144_cur."!cursor_pos"(rx1144_pos)
    $P10 = rx1144_cur."signature"()
    unless $P10, rx1144_fail
    rx1144_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx1144_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1144_cur."!cursor_pos"(rx1144_pos)
    $P10 = rx1144_cur."ws"()
    unless $P10, rx1144_fail
    rx1144_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1144_pos, 1
    gt $I11, rx1144_eos, rx1144_fail
    sub $I11, rx1144_pos, rx1144_off
    ord $I11, rx1144_tgt, $I11
    ne $I11, 41, rx1144_fail
    add rx1144_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1144_cur."!cursor_pos"(rx1144_pos)
    $P10 = rx1144_cur."ws"()
    unless $P10, rx1144_fail
    rx1144_pos = $P10."pos"()
    set_addr $I10, rxquantr1175_done
    (rx1144_rep) = rx1144_cur."!mark_commit"($I10)
  rxquantr1175_done:
  # rx subrule "ws" subtype=method negate=
    rx1144_cur."!cursor_pos"(rx1144_pos)
    $P10 = rx1144_cur."ws"()
    unless $P10, rx1144_fail
    rx1144_pos = $P10."pos"()
.annotate 'line', 512
  # rx reduce name="regex_declarator" key="open"
    rx1144_cur."!cursor_pos"(rx1144_pos)
    rx1144_cur."!reduce"("regex_declarator", "open")
  # rx subrule "ws" subtype=method negate=
    rx1144_cur."!cursor_pos"(rx1144_pos)
    $P10 = rx1144_cur."ws"()
    unless $P10, rx1144_fail
    rx1144_pos = $P10."pos"()
.annotate 'line', 513
  # rx literal  "{"
    add $I11, rx1144_pos, 1
    gt $I11, rx1144_eos, rx1144_fail
    sub $I11, rx1144_pos, rx1144_off
    ord $I11, rx1144_tgt, $I11
    ne $I11, 123, rx1144_fail
    add rx1144_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx1144_cur."!cursor_pos"(rx1144_pos)
    $P10 = rx1144_cur."LANG"("Regex", "nibbler")
    unless $P10, rx1144_fail
    rx1144_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx1144_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1144_pos, 1
    gt $I11, rx1144_eos, rx1144_fail
    sub $I11, rx1144_pos, rx1144_off
    ord $I11, rx1144_tgt, $I11
    ne $I11, 125, rx1144_fail
    add rx1144_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1144_cur."!cursor_pos"(rx1144_pos)
    $P10 = rx1144_cur."ENDSTMT"()
    unless $P10, rx1144_fail
  # rx subrule "ws" subtype=method negate=
    rx1144_cur."!cursor_pos"(rx1144_pos)
    $P10 = rx1144_cur."ws"()
    unless $P10, rx1144_fail
    rx1144_pos = $P10."pos"()
  alt1150_end:
.annotate 'line', 514
  # rx subrule "ws" subtype=method negate=
    rx1144_cur."!cursor_pos"(rx1144_pos)
    $P10 = rx1144_cur."ws"()
    unless $P10, rx1144_fail
    rx1144_pos = $P10."pos"()
.annotate 'line', 499
  # rx pass
    rx1144_cur."!cursor_pass"(rx1144_pos, "regex_declarator")
    if_null rx1144_debug, debug_1064
    rx1144_cur."!cursor_debug"("PASS", "regex_declarator", " at pos=", rx1144_pos)
  debug_1064:
    .return (rx1144_cur)
  rx1144_restart:
.annotate 'line', 10
    if_null rx1144_debug, debug_1065
    rx1144_cur."!cursor_debug"("NEXT", "regex_declarator")
  debug_1065:
  rx1144_fail:
    (rx1144_rep, rx1144_pos, $I10, $P10) = rx1144_cur."!mark_fail"(0)
    lt rx1144_pos, -1, rx1144_done
    eq rx1144_pos, -1, rx1144_fail
    jump $I10
  rx1144_done:
    rx1144_cur."!cursor_fail"()
    if_null rx1144_debug, debug_1066
    rx1144_cur."!cursor_debug"("FAIL", "regex_declarator")
  debug_1066:
    .return (rx1144_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__regex_declarator"  :nsentry("!PREFIX__regex_declarator") :subid("211_1303401201.841") :method
.annotate 'line', 10
    $P1146 = self."!PREFIX__!subrule"("ws", "")
    new $P1147, "ResizablePMCArray"
    push $P1147, $P1146
    .return ($P1147)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "dotty"  :subid("212_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1185_tgt
    .local int rx1185_pos
    .local int rx1185_off
    .local int rx1185_eos
    .local int rx1185_rep
    .local pmc rx1185_cur
    .local pmc rx1185_debug
    (rx1185_cur, rx1185_pos, rx1185_tgt, $I10) = self."!cursor_start"()
    rx1185_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1185_cur
    .local pmc match
    .lex "$/", match
    length rx1185_eos, rx1185_tgt
    gt rx1185_pos, rx1185_eos, rx1185_done
    set rx1185_off, 0
    lt rx1185_pos, 2, rx1185_start
    sub rx1185_off, rx1185_pos, 1
    substr rx1185_tgt, rx1185_tgt, rx1185_off
  rx1185_start:
    eq $I10, 1, rx1185_restart
    if_null rx1185_debug, debug_1067
    rx1185_cur."!cursor_debug"("START", "dotty")
  debug_1067:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1189_done
    goto rxscan1189_scan
  rxscan1189_loop:
    (rx1185_pos) = rx1185_cur."from"()
    inc rx1185_pos
    rx1185_cur."!cursor_from"(rx1185_pos)
    ge rx1185_pos, rx1185_eos, rxscan1189_done
  rxscan1189_scan:
    set_addr $I10, rxscan1189_loop
    rx1185_cur."!mark_push"(0, rx1185_pos, $I10)
  rxscan1189_done:
.annotate 'line', 518
  # rx literal  "."
    add $I11, rx1185_pos, 1
    gt $I11, rx1185_eos, rx1185_fail
    sub $I11, rx1185_pos, rx1185_off
    ord $I11, rx1185_tgt, $I11
    ne $I11, 46, rx1185_fail
    add rx1185_pos, 1
  alt1190_0:
.annotate 'line', 519
    set_addr $I10, alt1190_1
    rx1185_cur."!mark_push"(0, rx1185_pos, $I10)
  # rx subrule "deflongname" subtype=capture negate=
    rx1185_cur."!cursor_pos"(rx1185_pos)
    $P10 = rx1185_cur."deflongname"()
    unless $P10, rx1185_fail
    rx1185_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname=deflongname")
    rx1185_pos = $P10."pos"()
    goto alt1190_end
  alt1190_1:
.annotate 'line', 520
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1185_pos, rx1185_off
    substr $S10, rx1185_tgt, $I10, 1
    index $I11, "'\"", $S10
    lt $I11, 0, rx1185_fail
  # rx subrule "quote" subtype=capture negate=
    rx1185_cur."!cursor_pos"(rx1185_pos)
    $P10 = rx1185_cur."quote"()
    unless $P10, rx1185_fail
    rx1185_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1185_pos = $P10."pos"()
  alt1191_0:
.annotate 'line', 521
    set_addr $I10, alt1191_1
    rx1185_cur."!mark_push"(0, rx1185_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1185_pos, rx1185_off
    substr $S10, rx1185_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1185_fail
    goto alt1191_end
  alt1191_1:
  # rx subrule "panic" subtype=method negate=
    rx1185_cur."!cursor_pos"(rx1185_pos)
    $P10 = rx1185_cur."panic"("Quoted method name requires parenthesized arguments")
    unless $P10, rx1185_fail
    rx1185_pos = $P10."pos"()
  alt1191_end:
  alt1190_end:
.annotate 'line', 527
  # rx rxquantr1192 ** 0..1
    set_addr $I10, rxquantr1192_done
    rx1185_cur."!mark_push"(0, rx1185_pos, $I10)
  rxquantr1192_loop:
  alt1193_0:
.annotate 'line', 524
    set_addr $I10, alt1193_1
    rx1185_cur."!mark_push"(0, rx1185_pos, $I10)
.annotate 'line', 525
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1185_pos, rx1185_off
    substr $S10, rx1185_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1185_fail
  # rx subrule "args" subtype=capture negate=
    rx1185_cur."!cursor_pos"(rx1185_pos)
    $P10 = rx1185_cur."args"()
    unless $P10, rx1185_fail
    rx1185_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1185_pos = $P10."pos"()
    goto alt1193_end
  alt1193_1:
.annotate 'line', 526
  # rx literal  ":"
    add $I11, rx1185_pos, 1
    gt $I11, rx1185_eos, rx1185_fail
    sub $I11, rx1185_pos, rx1185_off
    ord $I11, rx1185_tgt, $I11
    ne $I11, 58, rx1185_fail
    add rx1185_pos, 1
  # rx charclass s
    ge rx1185_pos, rx1185_eos, rx1185_fail
    sub $I10, rx1185_pos, rx1185_off
    is_cclass $I11, 32, rx1185_tgt, $I10
    unless $I11, rx1185_fail
    inc rx1185_pos
  # rx subrule "arglist" subtype=capture negate=
    rx1185_cur."!cursor_pos"(rx1185_pos)
    $P10 = rx1185_cur."arglist"()
    unless $P10, rx1185_fail
    rx1185_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1185_pos = $P10."pos"()
  alt1193_end:
.annotate 'line', 527
    set_addr $I10, rxquantr1192_done
    (rx1185_rep) = rx1185_cur."!mark_commit"($I10)
  rxquantr1192_done:
.annotate 'line', 517
  # rx pass
    rx1185_cur."!cursor_pass"(rx1185_pos, "dotty")
    if_null rx1185_debug, debug_1068
    rx1185_cur."!cursor_debug"("PASS", "dotty", " at pos=", rx1185_pos)
  debug_1068:
    .return (rx1185_cur)
  rx1185_restart:
.annotate 'line', 10
    if_null rx1185_debug, debug_1069
    rx1185_cur."!cursor_debug"("NEXT", "dotty")
  debug_1069:
  rx1185_fail:
    (rx1185_rep, rx1185_pos, $I10, $P10) = rx1185_cur."!mark_fail"(0)
    lt rx1185_pos, -1, rx1185_done
    eq rx1185_pos, -1, rx1185_fail
    jump $I10
  rx1185_done:
    rx1185_cur."!cursor_fail"()
    if_null rx1185_debug, debug_1070
    rx1185_cur."!cursor_debug"("FAIL", "dotty")
  debug_1070:
    .return (rx1185_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__dotty"  :nsentry("!PREFIX__dotty") :subid("213_1303401201.841") :method
.annotate 'line', 10
    $P1187 = self."!PREFIX__!subrule"("deflongname", ".")
    new $P1188, "ResizablePMCArray"
    push $P1188, "'"
    push $P1188, "\""
    push $P1188, $P1187
    .return ($P1188)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term"  :subid("214_1303401201.841")
    .param pmc param_1195
.annotate 'line', 531
    .lex "self", param_1195
    $P1196 = param_1195."!protoregex"("term")
    .return ($P1196)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term"  :subid("215_1303401201.841")
    .param pmc param_1198
.annotate 'line', 531
    .lex "self", param_1198
    $P1199 = param_1198."!PREFIX__!protoregex"("term")
    .return ($P1199)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<self>"  :subid("216_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1201_tgt
    .local int rx1201_pos
    .local int rx1201_off
    .local int rx1201_eos
    .local int rx1201_rep
    .local pmc rx1201_cur
    .local pmc rx1201_debug
    (rx1201_cur, rx1201_pos, rx1201_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1201_cur
    .local pmc match
    .lex "$/", match
    length rx1201_eos, rx1201_tgt
    gt rx1201_pos, rx1201_eos, rx1201_done
    set rx1201_off, 0
    lt rx1201_pos, 2, rx1201_start
    sub rx1201_off, rx1201_pos, 1
    substr rx1201_tgt, rx1201_tgt, rx1201_off
  rx1201_start:
    eq $I10, 1, rx1201_restart
    if_null rx1201_debug, debug_1071
    rx1201_cur."!cursor_debug"("START", "term:sym<self>")
  debug_1071:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1204_done
    goto rxscan1204_scan
  rxscan1204_loop:
    (rx1201_pos) = rx1201_cur."from"()
    inc rx1201_pos
    rx1201_cur."!cursor_from"(rx1201_pos)
    ge rx1201_pos, rx1201_eos, rxscan1204_done
  rxscan1204_scan:
    set_addr $I10, rxscan1204_loop
    rx1201_cur."!mark_push"(0, rx1201_pos, $I10)
  rxscan1204_done:
.annotate 'line', 533
  # rx subcapture "sym"
    set_addr $I10, rxcap_1205_fail
    rx1201_cur."!mark_push"(0, rx1201_pos, $I10)
  # rx literal  "self"
    add $I11, rx1201_pos, 4
    gt $I11, rx1201_eos, rx1201_fail
    sub $I11, rx1201_pos, rx1201_off
    substr $S10, rx1201_tgt, $I11, 4
    ne $S10, "self", rx1201_fail
    add rx1201_pos, 4
    set_addr $I10, rxcap_1205_fail
    ($I12, $I11) = rx1201_cur."!mark_peek"($I10)
    rx1201_cur."!cursor_pos"($I11)
    ($P10) = rx1201_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1201_pos, "")
    rx1201_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1205_done
  rxcap_1205_fail:
    goto rx1201_fail
  rxcap_1205_done:
  # rxanchor rwb
    le rx1201_pos, 0, rx1201_fail
    sub $I10, rx1201_pos, rx1201_off
    is_cclass $I11, 8192, rx1201_tgt, $I10
    if $I11, rx1201_fail
    dec $I10
    is_cclass $I11, 8192, rx1201_tgt, $I10
    unless $I11, rx1201_fail
  # rx pass
    rx1201_cur."!cursor_pass"(rx1201_pos, "term:sym<self>")
    if_null rx1201_debug, debug_1072
    rx1201_cur."!cursor_debug"("PASS", "term:sym<self>", " at pos=", rx1201_pos)
  debug_1072:
    .return (rx1201_cur)
  rx1201_restart:
.annotate 'line', 10
    if_null rx1201_debug, debug_1073
    rx1201_cur."!cursor_debug"("NEXT", "term:sym<self>")
  debug_1073:
  rx1201_fail:
    (rx1201_rep, rx1201_pos, $I10, $P10) = rx1201_cur."!mark_fail"(0)
    lt rx1201_pos, -1, rx1201_done
    eq rx1201_pos, -1, rx1201_fail
    jump $I10
  rx1201_done:
    rx1201_cur."!cursor_fail"()
    if_null rx1201_debug, debug_1074
    rx1201_cur."!cursor_debug"("FAIL", "term:sym<self>")
  debug_1074:
    .return (rx1201_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<self>"  :nsentry("!PREFIX__term:sym<self>") :subid("217_1303401201.841") :method
.annotate 'line', 10
    new $P1203, "ResizablePMCArray"
    push $P1203, "self"
    .return ($P1203)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<identifier>"  :subid("218_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1207_tgt
    .local int rx1207_pos
    .local int rx1207_off
    .local int rx1207_eos
    .local int rx1207_rep
    .local pmc rx1207_cur
    .local pmc rx1207_debug
    (rx1207_cur, rx1207_pos, rx1207_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1207_cur
    .local pmc match
    .lex "$/", match
    length rx1207_eos, rx1207_tgt
    gt rx1207_pos, rx1207_eos, rx1207_done
    set rx1207_off, 0
    lt rx1207_pos, 2, rx1207_start
    sub rx1207_off, rx1207_pos, 1
    substr rx1207_tgt, rx1207_tgt, rx1207_off
  rx1207_start:
    eq $I10, 1, rx1207_restart
    if_null rx1207_debug, debug_1075
    rx1207_cur."!cursor_debug"("START", "term:sym<identifier>")
  debug_1075:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1211_done
    goto rxscan1211_scan
  rxscan1211_loop:
    (rx1207_pos) = rx1207_cur."from"()
    inc rx1207_pos
    rx1207_cur."!cursor_from"(rx1207_pos)
    ge rx1207_pos, rx1207_eos, rxscan1211_done
  rxscan1211_scan:
    set_addr $I10, rxscan1211_loop
    rx1207_cur."!mark_push"(0, rx1207_pos, $I10)
  rxscan1211_done:
.annotate 'line', 536
  # rx subrule "deflongname" subtype=capture negate=
    rx1207_cur."!cursor_pos"(rx1207_pos)
    $P10 = rx1207_cur."deflongname"()
    unless $P10, rx1207_fail
    rx1207_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1207_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1207_pos, rx1207_off
    substr $S10, rx1207_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1207_fail
  # rx subrule "args" subtype=capture negate=
    rx1207_cur."!cursor_pos"(rx1207_pos)
    $P10 = rx1207_cur."args"()
    unless $P10, rx1207_fail
    rx1207_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1207_pos = $P10."pos"()
.annotate 'line', 535
  # rx pass
    rx1207_cur."!cursor_pass"(rx1207_pos, "term:sym<identifier>")
    if_null rx1207_debug, debug_1076
    rx1207_cur."!cursor_debug"("PASS", "term:sym<identifier>", " at pos=", rx1207_pos)
  debug_1076:
    .return (rx1207_cur)
  rx1207_restart:
.annotate 'line', 10
    if_null rx1207_debug, debug_1077
    rx1207_cur."!cursor_debug"("NEXT", "term:sym<identifier>")
  debug_1077:
  rx1207_fail:
    (rx1207_rep, rx1207_pos, $I10, $P10) = rx1207_cur."!mark_fail"(0)
    lt rx1207_pos, -1, rx1207_done
    eq rx1207_pos, -1, rx1207_fail
    jump $I10
  rx1207_done:
    rx1207_cur."!cursor_fail"()
    if_null rx1207_debug, debug_1078
    rx1207_cur."!cursor_debug"("FAIL", "term:sym<identifier>")
  debug_1078:
    .return (rx1207_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<identifier>"  :nsentry("!PREFIX__term:sym<identifier>") :subid("219_1303401201.841") :method
.annotate 'line', 10
    $P1209 = self."!PREFIX__!subrule"("deflongname", "")
    new $P1210, "ResizablePMCArray"
    push $P1210, $P1209
    .return ($P1210)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<name>"  :subid("220_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1213_tgt
    .local int rx1213_pos
    .local int rx1213_off
    .local int rx1213_eos
    .local int rx1213_rep
    .local pmc rx1213_cur
    .local pmc rx1213_debug
    (rx1213_cur, rx1213_pos, rx1213_tgt, $I10) = self."!cursor_start"()
    rx1213_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1213_cur
    .local pmc match
    .lex "$/", match
    length rx1213_eos, rx1213_tgt
    gt rx1213_pos, rx1213_eos, rx1213_done
    set rx1213_off, 0
    lt rx1213_pos, 2, rx1213_start
    sub rx1213_off, rx1213_pos, 1
    substr rx1213_tgt, rx1213_tgt, rx1213_off
  rx1213_start:
    eq $I10, 1, rx1213_restart
    if_null rx1213_debug, debug_1079
    rx1213_cur."!cursor_debug"("START", "term:sym<name>")
  debug_1079:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1217_done
    goto rxscan1217_scan
  rxscan1217_loop:
    (rx1213_pos) = rx1213_cur."from"()
    inc rx1213_pos
    rx1213_cur."!cursor_from"(rx1213_pos)
    ge rx1213_pos, rx1213_eos, rxscan1217_done
  rxscan1217_scan:
    set_addr $I10, rxscan1217_loop
    rx1213_cur."!mark_push"(0, rx1213_pos, $I10)
  rxscan1217_done:
.annotate 'line', 540
  # rx subrule "name" subtype=capture negate=
    rx1213_cur."!cursor_pos"(rx1213_pos)
    $P10 = rx1213_cur."name"()
    unless $P10, rx1213_fail
    rx1213_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1213_pos = $P10."pos"()
  # rx rxquantr1218 ** 0..1
    set_addr $I10, rxquantr1218_done
    rx1213_cur."!mark_push"(0, rx1213_pos, $I10)
  rxquantr1218_loop:
  # rx subrule "args" subtype=capture negate=
    rx1213_cur."!cursor_pos"(rx1213_pos)
    $P10 = rx1213_cur."args"()
    unless $P10, rx1213_fail
    goto rxsubrule1219_pass
  rxsubrule1219_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1213_fail
  rxsubrule1219_pass:
    set_addr $I10, rxsubrule1219_back
    rx1213_cur."!mark_push"(0, rx1213_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1213_pos = $P10."pos"()
    set_addr $I10, rxquantr1218_done
    (rx1213_rep) = rx1213_cur."!mark_commit"($I10)
  rxquantr1218_done:
.annotate 'line', 539
  # rx pass
    rx1213_cur."!cursor_pass"(rx1213_pos, "term:sym<name>")
    if_null rx1213_debug, debug_1080
    rx1213_cur."!cursor_debug"("PASS", "term:sym<name>", " at pos=", rx1213_pos)
  debug_1080:
    .return (rx1213_cur)
  rx1213_restart:
.annotate 'line', 10
    if_null rx1213_debug, debug_1081
    rx1213_cur."!cursor_debug"("NEXT", "term:sym<name>")
  debug_1081:
  rx1213_fail:
    (rx1213_rep, rx1213_pos, $I10, $P10) = rx1213_cur."!mark_fail"(0)
    lt rx1213_pos, -1, rx1213_done
    eq rx1213_pos, -1, rx1213_fail
    jump $I10
  rx1213_done:
    rx1213_cur."!cursor_fail"()
    if_null rx1213_debug, debug_1082
    rx1213_cur."!cursor_debug"("FAIL", "term:sym<name>")
  debug_1082:
    .return (rx1213_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<name>"  :nsentry("!PREFIX__term:sym<name>") :subid("221_1303401201.841") :method
.annotate 'line', 10
    $P1215 = self."!PREFIX__!subrule"("name", "")
    new $P1216, "ResizablePMCArray"
    push $P1216, $P1215
    .return ($P1216)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<pir::op>"  :subid("222_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1221_tgt
    .local int rx1221_pos
    .local int rx1221_off
    .local int rx1221_eos
    .local int rx1221_rep
    .local pmc rx1221_cur
    .local pmc rx1221_debug
    (rx1221_cur, rx1221_pos, rx1221_tgt, $I10) = self."!cursor_start"()
    rx1221_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1221_cur
    .local pmc match
    .lex "$/", match
    length rx1221_eos, rx1221_tgt
    gt rx1221_pos, rx1221_eos, rx1221_done
    set rx1221_off, 0
    lt rx1221_pos, 2, rx1221_start
    sub rx1221_off, rx1221_pos, 1
    substr rx1221_tgt, rx1221_tgt, rx1221_off
  rx1221_start:
    eq $I10, 1, rx1221_restart
    if_null rx1221_debug, debug_1083
    rx1221_cur."!cursor_debug"("START", "term:sym<pir::op>")
  debug_1083:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1224_done
    goto rxscan1224_scan
  rxscan1224_loop:
    (rx1221_pos) = rx1221_cur."from"()
    inc rx1221_pos
    rx1221_cur."!cursor_from"(rx1221_pos)
    ge rx1221_pos, rx1221_eos, rxscan1224_done
  rxscan1224_scan:
    set_addr $I10, rxscan1224_loop
    rx1221_cur."!mark_push"(0, rx1221_pos, $I10)
  rxscan1224_done:
.annotate 'line', 544
  # rx literal  "pir::"
    add $I11, rx1221_pos, 5
    gt $I11, rx1221_eos, rx1221_fail
    sub $I11, rx1221_pos, rx1221_off
    substr $S10, rx1221_tgt, $I11, 5
    ne $S10, "pir::", rx1221_fail
    add rx1221_pos, 5
  # rx subcapture "op"
    set_addr $I10, rxcap_1225_fail
    rx1221_cur."!mark_push"(0, rx1221_pos, $I10)
  # rx charclass_q w r 1..-1
    sub $I10, rx1221_pos, rx1221_off
    find_not_cclass $I11, 8192, rx1221_tgt, $I10, rx1221_eos
    add $I12, $I10, 1
    lt $I11, $I12, rx1221_fail
    add rx1221_pos, rx1221_off, $I11
    set_addr $I10, rxcap_1225_fail
    ($I12, $I11) = rx1221_cur."!mark_peek"($I10)
    rx1221_cur."!cursor_pos"($I11)
    ($P10) = rx1221_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1221_pos, "")
    rx1221_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("op")
    goto rxcap_1225_done
  rxcap_1225_fail:
    goto rx1221_fail
  rxcap_1225_done:
  # rx rxquantr1226 ** 0..1
    set_addr $I10, rxquantr1226_done
    rx1221_cur."!mark_push"(0, rx1221_pos, $I10)
  rxquantr1226_loop:
  # rx subrule "args" subtype=capture negate=
    rx1221_cur."!cursor_pos"(rx1221_pos)
    $P10 = rx1221_cur."args"()
    unless $P10, rx1221_fail
    goto rxsubrule1227_pass
  rxsubrule1227_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1221_fail
  rxsubrule1227_pass:
    set_addr $I10, rxsubrule1227_back
    rx1221_cur."!mark_push"(0, rx1221_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1221_pos = $P10."pos"()
    set_addr $I10, rxquantr1226_done
    (rx1221_rep) = rx1221_cur."!mark_commit"($I10)
  rxquantr1226_done:
.annotate 'line', 543
  # rx pass
    rx1221_cur."!cursor_pass"(rx1221_pos, "term:sym<pir::op>")
    if_null rx1221_debug, debug_1084
    rx1221_cur."!cursor_debug"("PASS", "term:sym<pir::op>", " at pos=", rx1221_pos)
  debug_1084:
    .return (rx1221_cur)
  rx1221_restart:
.annotate 'line', 10
    if_null rx1221_debug, debug_1085
    rx1221_cur."!cursor_debug"("NEXT", "term:sym<pir::op>")
  debug_1085:
  rx1221_fail:
    (rx1221_rep, rx1221_pos, $I10, $P10) = rx1221_cur."!mark_fail"(0)
    lt rx1221_pos, -1, rx1221_done
    eq rx1221_pos, -1, rx1221_fail
    jump $I10
  rx1221_done:
    rx1221_cur."!cursor_fail"()
    if_null rx1221_debug, debug_1086
    rx1221_cur."!cursor_debug"("FAIL", "term:sym<pir::op>")
  debug_1086:
    .return (rx1221_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<pir::op>"  :nsentry("!PREFIX__term:sym<pir::op>") :subid("223_1303401201.841") :method
.annotate 'line', 10
    new $P1223, "ResizablePMCArray"
    push $P1223, "pir::"
    .return ($P1223)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<onlystar>"  :subid("224_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .const 'Sub' $P1237 = "226_1303401201.841" 
    capture_lex $P1237
    .local string rx1229_tgt
    .local int rx1229_pos
    .local int rx1229_off
    .local int rx1229_eos
    .local int rx1229_rep
    .local pmc rx1229_cur
    .local pmc rx1229_debug
    (rx1229_cur, rx1229_pos, rx1229_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1229_cur
    .local pmc match
    .lex "$/", match
    length rx1229_eos, rx1229_tgt
    gt rx1229_pos, rx1229_eos, rx1229_done
    set rx1229_off, 0
    lt rx1229_pos, 2, rx1229_start
    sub rx1229_off, rx1229_pos, 1
    substr rx1229_tgt, rx1229_tgt, rx1229_off
  rx1229_start:
    eq $I10, 1, rx1229_restart
    if_null rx1229_debug, debug_1087
    rx1229_cur."!cursor_debug"("START", "term:sym<onlystar>")
  debug_1087:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1232_done
    goto rxscan1232_scan
  rxscan1232_loop:
    (rx1229_pos) = rx1229_cur."from"()
    inc rx1229_pos
    rx1229_cur."!cursor_from"(rx1229_pos)
    ge rx1229_pos, rx1229_eos, rxscan1232_done
  rxscan1232_scan:
    set_addr $I10, rxscan1232_loop
    rx1229_cur."!mark_push"(0, rx1229_pos, $I10)
  rxscan1232_done:
.annotate 'line', 548
  # rx literal  "{*}"
    add $I11, rx1229_pos, 3
    gt $I11, rx1229_eos, rx1229_fail
    sub $I11, rx1229_pos, rx1229_off
    substr $S10, rx1229_tgt, $I11, 3
    ne $S10, "{*}", rx1229_fail
    add rx1229_pos, 3
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1229_cur."!cursor_pos"(rx1229_pos)
    $P10 = rx1229_cur."ENDSTMT"()
    unless $P10, rx1229_fail
  alt1233_0:
.annotate 'line', 549
    set_addr $I10, alt1233_1
    rx1229_cur."!mark_push"(0, rx1229_pos, $I10)
    rx1229_cur."!cursor_pos"(rx1229_pos)
    find_lex $P1234, unicode:"$\x{a2}"
    $P1235 = $P1234."MATCH"()
    store_lex "$/", $P1235
    .const 'Sub' $P1237 = "226_1303401201.841" 
    capture_lex $P1237
    $P1241 = $P1237()
    unless $P1241, rx1229_fail
    goto alt1233_end
  alt1233_1:
  # rx subrule "panic" subtype=method negate=
    rx1229_cur."!cursor_pos"(rx1229_pos)
    $P10 = rx1229_cur."panic"("{*} may only appear in proto")
    unless $P10, rx1229_fail
    rx1229_pos = $P10."pos"()
  alt1233_end:
.annotate 'line', 547
  # rx pass
    rx1229_cur."!cursor_pass"(rx1229_pos, "term:sym<onlystar>")
    if_null rx1229_debug, debug_1090
    rx1229_cur."!cursor_debug"("PASS", "term:sym<onlystar>", " at pos=", rx1229_pos)
  debug_1090:
    .return (rx1229_cur)
  rx1229_restart:
.annotate 'line', 10
    if_null rx1229_debug, debug_1091
    rx1229_cur."!cursor_debug"("NEXT", "term:sym<onlystar>")
  debug_1091:
  rx1229_fail:
    (rx1229_rep, rx1229_pos, $I10, $P10) = rx1229_cur."!mark_fail"(0)
    lt rx1229_pos, -1, rx1229_done
    eq rx1229_pos, -1, rx1229_fail
    jump $I10
  rx1229_done:
    rx1229_cur."!cursor_fail"()
    if_null rx1229_debug, debug_1092
    rx1229_cur."!cursor_debug"("FAIL", "term:sym<onlystar>")
  debug_1092:
    .return (rx1229_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<onlystar>"  :nsentry("!PREFIX__term:sym<onlystar>") :subid("225_1303401201.841") :method
.annotate 'line', 10
    new $P1231, "ResizablePMCArray"
    push $P1231, "{*}"
    .return ($P1231)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1236"  :anon :subid("226_1303401201.841") :outer("224_1303401201.841")
.annotate 'line', 549
    find_dynamic_lex $P1238, "$*MULTINESS"
    unless_null $P1238, vivify_1088
    get_hll_global $P1238, "$MULTINESS"
    unless_null $P1238, vivify_1089
    die "Contextual $*MULTINESS not found"
  vivify_1089:
  vivify_1088:
    set $S1239, $P1238
    iseq $I1240, $S1239, "proto"
    .return ($I1240)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "args"  :subid("227_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1243_tgt
    .local int rx1243_pos
    .local int rx1243_off
    .local int rx1243_eos
    .local int rx1243_rep
    .local pmc rx1243_cur
    .local pmc rx1243_debug
    (rx1243_cur, rx1243_pos, rx1243_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1243_cur
    .local pmc match
    .lex "$/", match
    length rx1243_eos, rx1243_tgt
    gt rx1243_pos, rx1243_eos, rx1243_done
    set rx1243_off, 0
    lt rx1243_pos, 2, rx1243_start
    sub rx1243_off, rx1243_pos, 1
    substr rx1243_tgt, rx1243_tgt, rx1243_off
  rx1243_start:
    eq $I10, 1, rx1243_restart
    if_null rx1243_debug, debug_1093
    rx1243_cur."!cursor_debug"("START", "args")
  debug_1093:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1247_done
    goto rxscan1247_scan
  rxscan1247_loop:
    (rx1243_pos) = rx1243_cur."from"()
    inc rx1243_pos
    rx1243_cur."!cursor_from"(rx1243_pos)
    ge rx1243_pos, rx1243_eos, rxscan1247_done
  rxscan1247_scan:
    set_addr $I10, rxscan1247_loop
    rx1243_cur."!mark_push"(0, rx1243_pos, $I10)
  rxscan1247_done:
.annotate 'line', 553
  # rx literal  "("
    add $I11, rx1243_pos, 1
    gt $I11, rx1243_eos, rx1243_fail
    sub $I11, rx1243_pos, rx1243_off
    ord $I11, rx1243_tgt, $I11
    ne $I11, 40, rx1243_fail
    add rx1243_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx1243_cur."!cursor_pos"(rx1243_pos)
    $P10 = rx1243_cur."arglist"()
    unless $P10, rx1243_fail
    rx1243_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1243_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1243_pos, 1
    gt $I11, rx1243_eos, rx1243_fail
    sub $I11, rx1243_pos, rx1243_off
    ord $I11, rx1243_tgt, $I11
    ne $I11, 41, rx1243_fail
    add rx1243_pos, 1
  # rx pass
    rx1243_cur."!cursor_pass"(rx1243_pos, "args")
    if_null rx1243_debug, debug_1094
    rx1243_cur."!cursor_debug"("PASS", "args", " at pos=", rx1243_pos)
  debug_1094:
    .return (rx1243_cur)
  rx1243_restart:
.annotate 'line', 10
    if_null rx1243_debug, debug_1095
    rx1243_cur."!cursor_debug"("NEXT", "args")
  debug_1095:
  rx1243_fail:
    (rx1243_rep, rx1243_pos, $I10, $P10) = rx1243_cur."!mark_fail"(0)
    lt rx1243_pos, -1, rx1243_done
    eq rx1243_pos, -1, rx1243_fail
    jump $I10
  rx1243_done:
    rx1243_cur."!cursor_fail"()
    if_null rx1243_debug, debug_1096
    rx1243_cur."!cursor_debug"("FAIL", "args")
  debug_1096:
    .return (rx1243_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__args"  :nsentry("!PREFIX__args") :subid("228_1303401201.841") :method
.annotate 'line', 10
    $P1245 = self."!PREFIX__!subrule"("arglist", "(")
    new $P1246, "ResizablePMCArray"
    push $P1246, $P1245
    .return ($P1246)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "arglist"  :subid("229_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1249_tgt
    .local int rx1249_pos
    .local int rx1249_off
    .local int rx1249_eos
    .local int rx1249_rep
    .local pmc rx1249_cur
    .local pmc rx1249_debug
    (rx1249_cur, rx1249_pos, rx1249_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1249_cur
    .local pmc match
    .lex "$/", match
    length rx1249_eos, rx1249_tgt
    gt rx1249_pos, rx1249_eos, rx1249_done
    set rx1249_off, 0
    lt rx1249_pos, 2, rx1249_start
    sub rx1249_off, rx1249_pos, 1
    substr rx1249_tgt, rx1249_tgt, rx1249_off
  rx1249_start:
    eq $I10, 1, rx1249_restart
    if_null rx1249_debug, debug_1097
    rx1249_cur."!cursor_debug"("START", "arglist")
  debug_1097:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1253_done
    goto rxscan1253_scan
  rxscan1253_loop:
    (rx1249_pos) = rx1249_cur."from"()
    inc rx1249_pos
    rx1249_cur."!cursor_from"(rx1249_pos)
    ge rx1249_pos, rx1249_eos, rxscan1253_done
  rxscan1253_scan:
    set_addr $I10, rxscan1253_loop
    rx1249_cur."!mark_push"(0, rx1249_pos, $I10)
  rxscan1253_done:
.annotate 'line', 557
  # rx subrule "ws" subtype=method negate=
    rx1249_cur."!cursor_pos"(rx1249_pos)
    $P10 = rx1249_cur."ws"()
    unless $P10, rx1249_fail
    rx1249_pos = $P10."pos"()
  alt1254_0:
.annotate 'line', 558
    set_addr $I10, alt1254_1
    rx1249_cur."!mark_push"(0, rx1249_pos, $I10)
.annotate 'line', 559
  # rx subrule "EXPR" subtype=capture negate=
    rx1249_cur."!cursor_pos"(rx1249_pos)
    $P10 = rx1249_cur."EXPR"("f=")
    unless $P10, rx1249_fail
    rx1249_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1249_pos = $P10."pos"()
    goto alt1254_end
  alt1254_1:
  alt1254_end:
.annotate 'line', 556
  # rx pass
    rx1249_cur."!cursor_pass"(rx1249_pos, "arglist")
    if_null rx1249_debug, debug_1098
    rx1249_cur."!cursor_debug"("PASS", "arglist", " at pos=", rx1249_pos)
  debug_1098:
    .return (rx1249_cur)
  rx1249_restart:
.annotate 'line', 10
    if_null rx1249_debug, debug_1099
    rx1249_cur."!cursor_debug"("NEXT", "arglist")
  debug_1099:
  rx1249_fail:
    (rx1249_rep, rx1249_pos, $I10, $P10) = rx1249_cur."!mark_fail"(0)
    lt rx1249_pos, -1, rx1249_done
    eq rx1249_pos, -1, rx1249_fail
    jump $I10
  rx1249_done:
    rx1249_cur."!cursor_fail"()
    if_null rx1249_debug, debug_1100
    rx1249_cur."!cursor_debug"("FAIL", "arglist")
  debug_1100:
    .return (rx1249_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__arglist"  :nsentry("!PREFIX__arglist") :subid("230_1303401201.841") :method
.annotate 'line', 10
    $P1251 = self."!PREFIX__!subrule"("ws", "")
    new $P1252, "ResizablePMCArray"
    push $P1252, $P1251
    .return ($P1252)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<value>"  :subid("231_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1256_tgt
    .local int rx1256_pos
    .local int rx1256_off
    .local int rx1256_eos
    .local int rx1256_rep
    .local pmc rx1256_cur
    .local pmc rx1256_debug
    (rx1256_cur, rx1256_pos, rx1256_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1256_cur
    .local pmc match
    .lex "$/", match
    length rx1256_eos, rx1256_tgt
    gt rx1256_pos, rx1256_eos, rx1256_done
    set rx1256_off, 0
    lt rx1256_pos, 2, rx1256_start
    sub rx1256_off, rx1256_pos, 1
    substr rx1256_tgt, rx1256_tgt, rx1256_off
  rx1256_start:
    eq $I10, 1, rx1256_restart
    if_null rx1256_debug, debug_1101
    rx1256_cur."!cursor_debug"("START", "term:sym<value>")
  debug_1101:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1260_done
    goto rxscan1260_scan
  rxscan1260_loop:
    (rx1256_pos) = rx1256_cur."from"()
    inc rx1256_pos
    rx1256_cur."!cursor_from"(rx1256_pos)
    ge rx1256_pos, rx1256_eos, rxscan1260_done
  rxscan1260_scan:
    set_addr $I10, rxscan1260_loop
    rx1256_cur."!mark_push"(0, rx1256_pos, $I10)
  rxscan1260_done:
.annotate 'line', 565
  # rx subrule "value" subtype=capture negate=
    rx1256_cur."!cursor_pos"(rx1256_pos)
    $P10 = rx1256_cur."value"()
    unless $P10, rx1256_fail
    rx1256_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("value")
    rx1256_pos = $P10."pos"()
  # rx pass
    rx1256_cur."!cursor_pass"(rx1256_pos, "term:sym<value>")
    if_null rx1256_debug, debug_1102
    rx1256_cur."!cursor_debug"("PASS", "term:sym<value>", " at pos=", rx1256_pos)
  debug_1102:
    .return (rx1256_cur)
  rx1256_restart:
.annotate 'line', 10
    if_null rx1256_debug, debug_1103
    rx1256_cur."!cursor_debug"("NEXT", "term:sym<value>")
  debug_1103:
  rx1256_fail:
    (rx1256_rep, rx1256_pos, $I10, $P10) = rx1256_cur."!mark_fail"(0)
    lt rx1256_pos, -1, rx1256_done
    eq rx1256_pos, -1, rx1256_fail
    jump $I10
  rx1256_done:
    rx1256_cur."!cursor_fail"()
    if_null rx1256_debug, debug_1104
    rx1256_cur."!cursor_debug"("FAIL", "term:sym<value>")
  debug_1104:
    .return (rx1256_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<value>"  :nsentry("!PREFIX__term:sym<value>") :subid("232_1303401201.841") :method
.annotate 'line', 10
    $P1258 = self."!PREFIX__!subrule"("value", "")
    new $P1259, "ResizablePMCArray"
    push $P1259, $P1258
    .return ($P1259)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "value"  :subid("233_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1262_tgt
    .local int rx1262_pos
    .local int rx1262_off
    .local int rx1262_eos
    .local int rx1262_rep
    .local pmc rx1262_cur
    .local pmc rx1262_debug
    (rx1262_cur, rx1262_pos, rx1262_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1262_cur
    .local pmc match
    .lex "$/", match
    length rx1262_eos, rx1262_tgt
    gt rx1262_pos, rx1262_eos, rx1262_done
    set rx1262_off, 0
    lt rx1262_pos, 2, rx1262_start
    sub rx1262_off, rx1262_pos, 1
    substr rx1262_tgt, rx1262_tgt, rx1262_off
  rx1262_start:
    eq $I10, 1, rx1262_restart
    if_null rx1262_debug, debug_1105
    rx1262_cur."!cursor_debug"("START", "value")
  debug_1105:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1267_done
    goto rxscan1267_scan
  rxscan1267_loop:
    (rx1262_pos) = rx1262_cur."from"()
    inc rx1262_pos
    rx1262_cur."!cursor_from"(rx1262_pos)
    ge rx1262_pos, rx1262_eos, rxscan1267_done
  rxscan1267_scan:
    set_addr $I10, rxscan1267_loop
    rx1262_cur."!mark_push"(0, rx1262_pos, $I10)
  rxscan1267_done:
  alt1268_0:
.annotate 'line', 567
    set_addr $I10, alt1268_1
    rx1262_cur."!mark_push"(0, rx1262_pos, $I10)
.annotate 'line', 568
  # rx subrule "quote" subtype=capture negate=
    rx1262_cur."!cursor_pos"(rx1262_pos)
    $P10 = rx1262_cur."quote"()
    unless $P10, rx1262_fail
    rx1262_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1262_pos = $P10."pos"()
    goto alt1268_end
  alt1268_1:
.annotate 'line', 569
  # rx subrule "number" subtype=capture negate=
    rx1262_cur."!cursor_pos"(rx1262_pos)
    $P10 = rx1262_cur."number"()
    unless $P10, rx1262_fail
    rx1262_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("number")
    rx1262_pos = $P10."pos"()
  alt1268_end:
.annotate 'line', 567
  # rx pass
    rx1262_cur."!cursor_pass"(rx1262_pos, "value")
    if_null rx1262_debug, debug_1106
    rx1262_cur."!cursor_debug"("PASS", "value", " at pos=", rx1262_pos)
  debug_1106:
    .return (rx1262_cur)
  rx1262_restart:
.annotate 'line', 10
    if_null rx1262_debug, debug_1107
    rx1262_cur."!cursor_debug"("NEXT", "value")
  debug_1107:
  rx1262_fail:
    (rx1262_rep, rx1262_pos, $I10, $P10) = rx1262_cur."!mark_fail"(0)
    lt rx1262_pos, -1, rx1262_done
    eq rx1262_pos, -1, rx1262_fail
    jump $I10
  rx1262_done:
    rx1262_cur."!cursor_fail"()
    if_null rx1262_debug, debug_1108
    rx1262_cur."!cursor_debug"("FAIL", "value")
  debug_1108:
    .return (rx1262_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__value"  :nsentry("!PREFIX__value") :subid("234_1303401201.841") :method
.annotate 'line', 10
    $P1264 = self."!PREFIX__!subrule"("number", "")
    $P1265 = self."!PREFIX__!subrule"("quote", "")
    new $P1266, "ResizablePMCArray"
    push $P1266, $P1264
    push $P1266, $P1265
    .return ($P1266)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "number"  :subid("235_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1270_tgt
    .local int rx1270_pos
    .local int rx1270_off
    .local int rx1270_eos
    .local int rx1270_rep
    .local pmc rx1270_cur
    .local pmc rx1270_debug
    (rx1270_cur, rx1270_pos, rx1270_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1270_cur
    .local pmc match
    .lex "$/", match
    length rx1270_eos, rx1270_tgt
    gt rx1270_pos, rx1270_eos, rx1270_done
    set rx1270_off, 0
    lt rx1270_pos, 2, rx1270_start
    sub rx1270_off, rx1270_pos, 1
    substr rx1270_tgt, rx1270_tgt, rx1270_off
  rx1270_start:
    eq $I10, 1, rx1270_restart
    if_null rx1270_debug, debug_1109
    rx1270_cur."!cursor_debug"("START", "number")
  debug_1109:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1273_done
    goto rxscan1273_scan
  rxscan1273_loop:
    (rx1270_pos) = rx1270_cur."from"()
    inc rx1270_pos
    rx1270_cur."!cursor_from"(rx1270_pos)
    ge rx1270_pos, rx1270_eos, rxscan1273_done
  rxscan1273_scan:
    set_addr $I10, rxscan1273_loop
    rx1270_cur."!mark_push"(0, rx1270_pos, $I10)
  rxscan1273_done:
.annotate 'line', 573
  # rx subcapture "sign"
    set_addr $I10, rxcap_1275_fail
    rx1270_cur."!mark_push"(0, rx1270_pos, $I10)
  # rx enumcharlist_q negate=0  r 0..1
    sub $I10, rx1270_pos, rx1270_off
    set rx1270_rep, 0
    sub $I12, rx1270_eos, rx1270_pos
    le $I12, 1, rxenumcharlistq1274_loop
    set $I12, 1
  rxenumcharlistq1274_loop:
    le $I12, 0, rxenumcharlistq1274_done
    substr $S10, rx1270_tgt, $I10, 1
    index $I11, "+-", $S10
    lt $I11, 0, rxenumcharlistq1274_done
    inc rx1270_rep
  rxenumcharlistq1274_done:
    add rx1270_pos, rx1270_pos, rx1270_rep
    set_addr $I10, rxcap_1275_fail
    ($I12, $I11) = rx1270_cur."!mark_peek"($I10)
    rx1270_cur."!cursor_pos"($I11)
    ($P10) = rx1270_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1270_pos, "")
    rx1270_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sign")
    goto rxcap_1275_done
  rxcap_1275_fail:
    goto rx1270_fail
  rxcap_1275_done:
  alt1276_0:
.annotate 'line', 574
    set_addr $I10, alt1276_1
    rx1270_cur."!mark_push"(0, rx1270_pos, $I10)
  # rx subrule "dec_number" subtype=capture negate=
    rx1270_cur."!cursor_pos"(rx1270_pos)
    $P10 = rx1270_cur."dec_number"()
    unless $P10, rx1270_fail
    rx1270_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dec_number")
    rx1270_pos = $P10."pos"()
    goto alt1276_end
  alt1276_1:
  # rx subrule "integer" subtype=capture negate=
    rx1270_cur."!cursor_pos"(rx1270_pos)
    $P10 = rx1270_cur."integer"()
    unless $P10, rx1270_fail
    rx1270_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("integer")
    rx1270_pos = $P10."pos"()
  alt1276_end:
.annotate 'line', 572
  # rx pass
    rx1270_cur."!cursor_pass"(rx1270_pos, "number")
    if_null rx1270_debug, debug_1110
    rx1270_cur."!cursor_debug"("PASS", "number", " at pos=", rx1270_pos)
  debug_1110:
    .return (rx1270_cur)
  rx1270_restart:
.annotate 'line', 10
    if_null rx1270_debug, debug_1111
    rx1270_cur."!cursor_debug"("NEXT", "number")
  debug_1111:
  rx1270_fail:
    (rx1270_rep, rx1270_pos, $I10, $P10) = rx1270_cur."!mark_fail"(0)
    lt rx1270_pos, -1, rx1270_done
    eq rx1270_pos, -1, rx1270_fail
    jump $I10
  rx1270_done:
    rx1270_cur."!cursor_fail"()
    if_null rx1270_debug, debug_1112
    rx1270_cur."!cursor_debug"("FAIL", "number")
  debug_1112:
    .return (rx1270_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__number"  :nsentry("!PREFIX__number") :subid("236_1303401201.841") :method
.annotate 'line', 10
    new $P1272, "ResizablePMCArray"
    push $P1272, ""
    .return ($P1272)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote"  :subid("237_1303401201.841")
    .param pmc param_1278
.annotate 'line', 577
    .lex "self", param_1278
    $P1279 = param_1278."!protoregex"("quote")
    .return ($P1279)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote"  :subid("238_1303401201.841")
    .param pmc param_1281
.annotate 'line', 577
    .lex "self", param_1281
    $P1282 = param_1281."!PREFIX__!protoregex"("quote")
    .return ($P1282)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<apos>"  :subid("239_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1284_tgt
    .local int rx1284_pos
    .local int rx1284_off
    .local int rx1284_eos
    .local int rx1284_rep
    .local pmc rx1284_cur
    .local pmc rx1284_debug
    (rx1284_cur, rx1284_pos, rx1284_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1284_cur
    .local pmc match
    .lex "$/", match
    length rx1284_eos, rx1284_tgt
    gt rx1284_pos, rx1284_eos, rx1284_done
    set rx1284_off, 0
    lt rx1284_pos, 2, rx1284_start
    sub rx1284_off, rx1284_pos, 1
    substr rx1284_tgt, rx1284_tgt, rx1284_off
  rx1284_start:
    eq $I10, 1, rx1284_restart
    if_null rx1284_debug, debug_1113
    rx1284_cur."!cursor_debug"("START", "quote:sym<apos>")
  debug_1113:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1287_done
    goto rxscan1287_scan
  rxscan1287_loop:
    (rx1284_pos) = rx1284_cur."from"()
    inc rx1284_pos
    rx1284_cur."!cursor_from"(rx1284_pos)
    ge rx1284_pos, rx1284_eos, rxscan1287_done
  rxscan1287_scan:
    set_addr $I10, rxscan1287_loop
    rx1284_cur."!mark_push"(0, rx1284_pos, $I10)
  rxscan1287_done:
.annotate 'line', 578
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1284_pos, rx1284_off
    substr $S10, rx1284_tgt, $I10, 1
    index $I11, "'", $S10
    lt $I11, 0, rx1284_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1284_cur."!cursor_pos"(rx1284_pos)
    $P10 = rx1284_cur."quote_EXPR"(":q")
    unless $P10, rx1284_fail
    rx1284_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1284_pos = $P10."pos"()
  # rx pass
    rx1284_cur."!cursor_pass"(rx1284_pos, "quote:sym<apos>")
    if_null rx1284_debug, debug_1114
    rx1284_cur."!cursor_debug"("PASS", "quote:sym<apos>", " at pos=", rx1284_pos)
  debug_1114:
    .return (rx1284_cur)
  rx1284_restart:
.annotate 'line', 10
    if_null rx1284_debug, debug_1115
    rx1284_cur."!cursor_debug"("NEXT", "quote:sym<apos>")
  debug_1115:
  rx1284_fail:
    (rx1284_rep, rx1284_pos, $I10, $P10) = rx1284_cur."!mark_fail"(0)
    lt rx1284_pos, -1, rx1284_done
    eq rx1284_pos, -1, rx1284_fail
    jump $I10
  rx1284_done:
    rx1284_cur."!cursor_fail"()
    if_null rx1284_debug, debug_1116
    rx1284_cur."!cursor_debug"("FAIL", "quote:sym<apos>")
  debug_1116:
    .return (rx1284_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<apos>"  :nsentry("!PREFIX__quote:sym<apos>") :subid("240_1303401201.841") :method
.annotate 'line', 10
    new $P1286, "ResizablePMCArray"
    push $P1286, "'"
    .return ($P1286)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<dblq>"  :subid("241_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1289_tgt
    .local int rx1289_pos
    .local int rx1289_off
    .local int rx1289_eos
    .local int rx1289_rep
    .local pmc rx1289_cur
    .local pmc rx1289_debug
    (rx1289_cur, rx1289_pos, rx1289_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1289_cur
    .local pmc match
    .lex "$/", match
    length rx1289_eos, rx1289_tgt
    gt rx1289_pos, rx1289_eos, rx1289_done
    set rx1289_off, 0
    lt rx1289_pos, 2, rx1289_start
    sub rx1289_off, rx1289_pos, 1
    substr rx1289_tgt, rx1289_tgt, rx1289_off
  rx1289_start:
    eq $I10, 1, rx1289_restart
    if_null rx1289_debug, debug_1117
    rx1289_cur."!cursor_debug"("START", "quote:sym<dblq>")
  debug_1117:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1292_done
    goto rxscan1292_scan
  rxscan1292_loop:
    (rx1289_pos) = rx1289_cur."from"()
    inc rx1289_pos
    rx1289_cur."!cursor_from"(rx1289_pos)
    ge rx1289_pos, rx1289_eos, rxscan1292_done
  rxscan1292_scan:
    set_addr $I10, rxscan1292_loop
    rx1289_cur."!mark_push"(0, rx1289_pos, $I10)
  rxscan1292_done:
.annotate 'line', 579
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1289_pos, rx1289_off
    substr $S10, rx1289_tgt, $I10, 1
    index $I11, "\"", $S10
    lt $I11, 0, rx1289_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1289_cur."!cursor_pos"(rx1289_pos)
    $P10 = rx1289_cur."quote_EXPR"(":qq")
    unless $P10, rx1289_fail
    rx1289_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1289_pos = $P10."pos"()
  # rx pass
    rx1289_cur."!cursor_pass"(rx1289_pos, "quote:sym<dblq>")
    if_null rx1289_debug, debug_1118
    rx1289_cur."!cursor_debug"("PASS", "quote:sym<dblq>", " at pos=", rx1289_pos)
  debug_1118:
    .return (rx1289_cur)
  rx1289_restart:
.annotate 'line', 10
    if_null rx1289_debug, debug_1119
    rx1289_cur."!cursor_debug"("NEXT", "quote:sym<dblq>")
  debug_1119:
  rx1289_fail:
    (rx1289_rep, rx1289_pos, $I10, $P10) = rx1289_cur."!mark_fail"(0)
    lt rx1289_pos, -1, rx1289_done
    eq rx1289_pos, -1, rx1289_fail
    jump $I10
  rx1289_done:
    rx1289_cur."!cursor_fail"()
    if_null rx1289_debug, debug_1120
    rx1289_cur."!cursor_debug"("FAIL", "quote:sym<dblq>")
  debug_1120:
    .return (rx1289_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<dblq>"  :nsentry("!PREFIX__quote:sym<dblq>") :subid("242_1303401201.841") :method
.annotate 'line', 10
    new $P1291, "ResizablePMCArray"
    push $P1291, "\""
    .return ($P1291)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<q>"  :subid("243_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1294_tgt
    .local int rx1294_pos
    .local int rx1294_off
    .local int rx1294_eos
    .local int rx1294_rep
    .local pmc rx1294_cur
    .local pmc rx1294_debug
    (rx1294_cur, rx1294_pos, rx1294_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1294_cur
    .local pmc match
    .lex "$/", match
    length rx1294_eos, rx1294_tgt
    gt rx1294_pos, rx1294_eos, rx1294_done
    set rx1294_off, 0
    lt rx1294_pos, 2, rx1294_start
    sub rx1294_off, rx1294_pos, 1
    substr rx1294_tgt, rx1294_tgt, rx1294_off
  rx1294_start:
    eq $I10, 1, rx1294_restart
    if_null rx1294_debug, debug_1121
    rx1294_cur."!cursor_debug"("START", "quote:sym<q>")
  debug_1121:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1298_done
    goto rxscan1298_scan
  rxscan1298_loop:
    (rx1294_pos) = rx1294_cur."from"()
    inc rx1294_pos
    rx1294_cur."!cursor_from"(rx1294_pos)
    ge rx1294_pos, rx1294_eos, rxscan1298_done
  rxscan1298_scan:
    set_addr $I10, rxscan1298_loop
    rx1294_cur."!mark_push"(0, rx1294_pos, $I10)
  rxscan1298_done:
.annotate 'line', 580
  # rx subcapture "sym"
    set_addr $I10, rxcap_1299_fail
    rx1294_cur."!mark_push"(0, rx1294_pos, $I10)
  # rx literal  "q"
    add $I11, rx1294_pos, 1
    gt $I11, rx1294_eos, rx1294_fail
    sub $I11, rx1294_pos, rx1294_off
    ord $I11, rx1294_tgt, $I11
    ne $I11, 113, rx1294_fail
    add rx1294_pos, 1
    set_addr $I10, rxcap_1299_fail
    ($I12, $I11) = rx1294_cur."!mark_peek"($I10)
    rx1294_cur."!cursor_pos"($I11)
    ($P10) = rx1294_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1294_pos, "")
    rx1294_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1299_done
  rxcap_1299_fail:
    goto rx1294_fail
  rxcap_1299_done:
  # rxanchor rwb
    le rx1294_pos, 0, rx1294_fail
    sub $I10, rx1294_pos, rx1294_off
    is_cclass $I11, 8192, rx1294_tgt, $I10
    if $I11, rx1294_fail
    dec $I10
    is_cclass $I11, 8192, rx1294_tgt, $I10
    unless $I11, rx1294_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1294_pos, rx1294_off
    substr $S10, rx1294_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1294_fail
  # rx subrule "ws" subtype=method negate=
    rx1294_cur."!cursor_pos"(rx1294_pos)
    $P10 = rx1294_cur."ws"()
    unless $P10, rx1294_fail
    rx1294_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1294_cur."!cursor_pos"(rx1294_pos)
    $P10 = rx1294_cur."quote_EXPR"(":q")
    unless $P10, rx1294_fail
    rx1294_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1294_pos = $P10."pos"()
  # rx pass
    rx1294_cur."!cursor_pass"(rx1294_pos, "quote:sym<q>")
    if_null rx1294_debug, debug_1122
    rx1294_cur."!cursor_debug"("PASS", "quote:sym<q>", " at pos=", rx1294_pos)
  debug_1122:
    .return (rx1294_cur)
  rx1294_restart:
.annotate 'line', 10
    if_null rx1294_debug, debug_1123
    rx1294_cur."!cursor_debug"("NEXT", "quote:sym<q>")
  debug_1123:
  rx1294_fail:
    (rx1294_rep, rx1294_pos, $I10, $P10) = rx1294_cur."!mark_fail"(0)
    lt rx1294_pos, -1, rx1294_done
    eq rx1294_pos, -1, rx1294_fail
    jump $I10
  rx1294_done:
    rx1294_cur."!cursor_fail"()
    if_null rx1294_debug, debug_1124
    rx1294_cur."!cursor_debug"("FAIL", "quote:sym<q>")
  debug_1124:
    .return (rx1294_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<q>"  :nsentry("!PREFIX__quote:sym<q>") :subid("244_1303401201.841") :method
.annotate 'line', 10
    $P1296 = self."!PREFIX__!subrule"("ws", "q")
    new $P1297, "ResizablePMCArray"
    push $P1297, $P1296
    .return ($P1297)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<qq>"  :subid("245_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1301_tgt
    .local int rx1301_pos
    .local int rx1301_off
    .local int rx1301_eos
    .local int rx1301_rep
    .local pmc rx1301_cur
    .local pmc rx1301_debug
    (rx1301_cur, rx1301_pos, rx1301_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1301_cur
    .local pmc match
    .lex "$/", match
    length rx1301_eos, rx1301_tgt
    gt rx1301_pos, rx1301_eos, rx1301_done
    set rx1301_off, 0
    lt rx1301_pos, 2, rx1301_start
    sub rx1301_off, rx1301_pos, 1
    substr rx1301_tgt, rx1301_tgt, rx1301_off
  rx1301_start:
    eq $I10, 1, rx1301_restart
    if_null rx1301_debug, debug_1125
    rx1301_cur."!cursor_debug"("START", "quote:sym<qq>")
  debug_1125:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1305_done
    goto rxscan1305_scan
  rxscan1305_loop:
    (rx1301_pos) = rx1301_cur."from"()
    inc rx1301_pos
    rx1301_cur."!cursor_from"(rx1301_pos)
    ge rx1301_pos, rx1301_eos, rxscan1305_done
  rxscan1305_scan:
    set_addr $I10, rxscan1305_loop
    rx1301_cur."!mark_push"(0, rx1301_pos, $I10)
  rxscan1305_done:
.annotate 'line', 581
  # rx subcapture "sym"
    set_addr $I10, rxcap_1306_fail
    rx1301_cur."!mark_push"(0, rx1301_pos, $I10)
  # rx literal  "qq"
    add $I11, rx1301_pos, 2
    gt $I11, rx1301_eos, rx1301_fail
    sub $I11, rx1301_pos, rx1301_off
    substr $S10, rx1301_tgt, $I11, 2
    ne $S10, "qq", rx1301_fail
    add rx1301_pos, 2
    set_addr $I10, rxcap_1306_fail
    ($I12, $I11) = rx1301_cur."!mark_peek"($I10)
    rx1301_cur."!cursor_pos"($I11)
    ($P10) = rx1301_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1301_pos, "")
    rx1301_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1306_done
  rxcap_1306_fail:
    goto rx1301_fail
  rxcap_1306_done:
  # rxanchor rwb
    le rx1301_pos, 0, rx1301_fail
    sub $I10, rx1301_pos, rx1301_off
    is_cclass $I11, 8192, rx1301_tgt, $I10
    if $I11, rx1301_fail
    dec $I10
    is_cclass $I11, 8192, rx1301_tgt, $I10
    unless $I11, rx1301_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1301_pos, rx1301_off
    substr $S10, rx1301_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1301_fail
  # rx subrule "ws" subtype=method negate=
    rx1301_cur."!cursor_pos"(rx1301_pos)
    $P10 = rx1301_cur."ws"()
    unless $P10, rx1301_fail
    rx1301_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1301_cur."!cursor_pos"(rx1301_pos)
    $P10 = rx1301_cur."quote_EXPR"(":qq")
    unless $P10, rx1301_fail
    rx1301_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1301_pos = $P10."pos"()
  # rx pass
    rx1301_cur."!cursor_pass"(rx1301_pos, "quote:sym<qq>")
    if_null rx1301_debug, debug_1126
    rx1301_cur."!cursor_debug"("PASS", "quote:sym<qq>", " at pos=", rx1301_pos)
  debug_1126:
    .return (rx1301_cur)
  rx1301_restart:
.annotate 'line', 10
    if_null rx1301_debug, debug_1127
    rx1301_cur."!cursor_debug"("NEXT", "quote:sym<qq>")
  debug_1127:
  rx1301_fail:
    (rx1301_rep, rx1301_pos, $I10, $P10) = rx1301_cur."!mark_fail"(0)
    lt rx1301_pos, -1, rx1301_done
    eq rx1301_pos, -1, rx1301_fail
    jump $I10
  rx1301_done:
    rx1301_cur."!cursor_fail"()
    if_null rx1301_debug, debug_1128
    rx1301_cur."!cursor_debug"("FAIL", "quote:sym<qq>")
  debug_1128:
    .return (rx1301_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<qq>"  :nsentry("!PREFIX__quote:sym<qq>") :subid("246_1303401201.841") :method
.annotate 'line', 10
    $P1303 = self."!PREFIX__!subrule"("ws", "qq")
    new $P1304, "ResizablePMCArray"
    push $P1304, $P1303
    .return ($P1304)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q>"  :subid("247_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1308_tgt
    .local int rx1308_pos
    .local int rx1308_off
    .local int rx1308_eos
    .local int rx1308_rep
    .local pmc rx1308_cur
    .local pmc rx1308_debug
    (rx1308_cur, rx1308_pos, rx1308_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1308_cur
    .local pmc match
    .lex "$/", match
    length rx1308_eos, rx1308_tgt
    gt rx1308_pos, rx1308_eos, rx1308_done
    set rx1308_off, 0
    lt rx1308_pos, 2, rx1308_start
    sub rx1308_off, rx1308_pos, 1
    substr rx1308_tgt, rx1308_tgt, rx1308_off
  rx1308_start:
    eq $I10, 1, rx1308_restart
    if_null rx1308_debug, debug_1129
    rx1308_cur."!cursor_debug"("START", "quote:sym<Q>")
  debug_1129:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1312_done
    goto rxscan1312_scan
  rxscan1312_loop:
    (rx1308_pos) = rx1308_cur."from"()
    inc rx1308_pos
    rx1308_cur."!cursor_from"(rx1308_pos)
    ge rx1308_pos, rx1308_eos, rxscan1312_done
  rxscan1312_scan:
    set_addr $I10, rxscan1312_loop
    rx1308_cur."!mark_push"(0, rx1308_pos, $I10)
  rxscan1312_done:
.annotate 'line', 582
  # rx subcapture "sym"
    set_addr $I10, rxcap_1313_fail
    rx1308_cur."!mark_push"(0, rx1308_pos, $I10)
  # rx literal  "Q"
    add $I11, rx1308_pos, 1
    gt $I11, rx1308_eos, rx1308_fail
    sub $I11, rx1308_pos, rx1308_off
    ord $I11, rx1308_tgt, $I11
    ne $I11, 81, rx1308_fail
    add rx1308_pos, 1
    set_addr $I10, rxcap_1313_fail
    ($I12, $I11) = rx1308_cur."!mark_peek"($I10)
    rx1308_cur."!cursor_pos"($I11)
    ($P10) = rx1308_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1308_pos, "")
    rx1308_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1313_done
  rxcap_1313_fail:
    goto rx1308_fail
  rxcap_1313_done:
  # rxanchor rwb
    le rx1308_pos, 0, rx1308_fail
    sub $I10, rx1308_pos, rx1308_off
    is_cclass $I11, 8192, rx1308_tgt, $I10
    if $I11, rx1308_fail
    dec $I10
    is_cclass $I11, 8192, rx1308_tgt, $I10
    unless $I11, rx1308_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1308_pos, rx1308_off
    substr $S10, rx1308_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1308_fail
  # rx subrule "ws" subtype=method negate=
    rx1308_cur."!cursor_pos"(rx1308_pos)
    $P10 = rx1308_cur."ws"()
    unless $P10, rx1308_fail
    rx1308_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1308_cur."!cursor_pos"(rx1308_pos)
    $P10 = rx1308_cur."quote_EXPR"()
    unless $P10, rx1308_fail
    rx1308_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1308_pos = $P10."pos"()
  # rx pass
    rx1308_cur."!cursor_pass"(rx1308_pos, "quote:sym<Q>")
    if_null rx1308_debug, debug_1130
    rx1308_cur."!cursor_debug"("PASS", "quote:sym<Q>", " at pos=", rx1308_pos)
  debug_1130:
    .return (rx1308_cur)
  rx1308_restart:
.annotate 'line', 10
    if_null rx1308_debug, debug_1131
    rx1308_cur."!cursor_debug"("NEXT", "quote:sym<Q>")
  debug_1131:
  rx1308_fail:
    (rx1308_rep, rx1308_pos, $I10, $P10) = rx1308_cur."!mark_fail"(0)
    lt rx1308_pos, -1, rx1308_done
    eq rx1308_pos, -1, rx1308_fail
    jump $I10
  rx1308_done:
    rx1308_cur."!cursor_fail"()
    if_null rx1308_debug, debug_1132
    rx1308_cur."!cursor_debug"("FAIL", "quote:sym<Q>")
  debug_1132:
    .return (rx1308_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q>"  :nsentry("!PREFIX__quote:sym<Q>") :subid("248_1303401201.841") :method
.annotate 'line', 10
    $P1310 = self."!PREFIX__!subrule"("ws", "Q")
    new $P1311, "ResizablePMCArray"
    push $P1311, $P1310
    .return ($P1311)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q:PIR>"  :subid("249_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1315_tgt
    .local int rx1315_pos
    .local int rx1315_off
    .local int rx1315_eos
    .local int rx1315_rep
    .local pmc rx1315_cur
    .local pmc rx1315_debug
    (rx1315_cur, rx1315_pos, rx1315_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1315_cur
    .local pmc match
    .lex "$/", match
    length rx1315_eos, rx1315_tgt
    gt rx1315_pos, rx1315_eos, rx1315_done
    set rx1315_off, 0
    lt rx1315_pos, 2, rx1315_start
    sub rx1315_off, rx1315_pos, 1
    substr rx1315_tgt, rx1315_tgt, rx1315_off
  rx1315_start:
    eq $I10, 1, rx1315_restart
    if_null rx1315_debug, debug_1133
    rx1315_cur."!cursor_debug"("START", "quote:sym<Q:PIR>")
  debug_1133:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1319_done
    goto rxscan1319_scan
  rxscan1319_loop:
    (rx1315_pos) = rx1315_cur."from"()
    inc rx1315_pos
    rx1315_cur."!cursor_from"(rx1315_pos)
    ge rx1315_pos, rx1315_eos, rxscan1319_done
  rxscan1319_scan:
    set_addr $I10, rxscan1319_loop
    rx1315_cur."!mark_push"(0, rx1315_pos, $I10)
  rxscan1319_done:
.annotate 'line', 583
  # rx subcapture "sym"
    set_addr $I10, rxcap_1320_fail
    rx1315_cur."!mark_push"(0, rx1315_pos, $I10)
  # rx literal  "Q:PIR"
    add $I11, rx1315_pos, 5
    gt $I11, rx1315_eos, rx1315_fail
    sub $I11, rx1315_pos, rx1315_off
    substr $S10, rx1315_tgt, $I11, 5
    ne $S10, "Q:PIR", rx1315_fail
    add rx1315_pos, 5
    set_addr $I10, rxcap_1320_fail
    ($I12, $I11) = rx1315_cur."!mark_peek"($I10)
    rx1315_cur."!cursor_pos"($I11)
    ($P10) = rx1315_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1315_pos, "")
    rx1315_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1320_done
  rxcap_1320_fail:
    goto rx1315_fail
  rxcap_1320_done:
  # rx subrule "ws" subtype=method negate=
    rx1315_cur."!cursor_pos"(rx1315_pos)
    $P10 = rx1315_cur."ws"()
    unless $P10, rx1315_fail
    rx1315_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1315_cur."!cursor_pos"(rx1315_pos)
    $P10 = rx1315_cur."quote_EXPR"()
    unless $P10, rx1315_fail
    rx1315_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1315_pos = $P10."pos"()
  # rx pass
    rx1315_cur."!cursor_pass"(rx1315_pos, "quote:sym<Q:PIR>")
    if_null rx1315_debug, debug_1134
    rx1315_cur."!cursor_debug"("PASS", "quote:sym<Q:PIR>", " at pos=", rx1315_pos)
  debug_1134:
    .return (rx1315_cur)
  rx1315_restart:
.annotate 'line', 10
    if_null rx1315_debug, debug_1135
    rx1315_cur."!cursor_debug"("NEXT", "quote:sym<Q:PIR>")
  debug_1135:
  rx1315_fail:
    (rx1315_rep, rx1315_pos, $I10, $P10) = rx1315_cur."!mark_fail"(0)
    lt rx1315_pos, -1, rx1315_done
    eq rx1315_pos, -1, rx1315_fail
    jump $I10
  rx1315_done:
    rx1315_cur."!cursor_fail"()
    if_null rx1315_debug, debug_1136
    rx1315_cur."!cursor_debug"("FAIL", "quote:sym<Q:PIR>")
  debug_1136:
    .return (rx1315_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q:PIR>"  :nsentry("!PREFIX__quote:sym<Q:PIR>") :subid("250_1303401201.841") :method
.annotate 'line', 10
    $P1317 = self."!PREFIX__!subrule"("ws", "Q:PIR")
    new $P1318, "ResizablePMCArray"
    push $P1318, $P1317
    .return ($P1318)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym</ />"  :subid("251_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1322_tgt
    .local int rx1322_pos
    .local int rx1322_off
    .local int rx1322_eos
    .local int rx1322_rep
    .local pmc rx1322_cur
    .local pmc rx1322_debug
    (rx1322_cur, rx1322_pos, rx1322_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1322_cur
    .local pmc match
    .lex "$/", match
    length rx1322_eos, rx1322_tgt
    gt rx1322_pos, rx1322_eos, rx1322_done
    set rx1322_off, 0
    lt rx1322_pos, 2, rx1322_start
    sub rx1322_off, rx1322_pos, 1
    substr rx1322_tgt, rx1322_tgt, rx1322_off
  rx1322_start:
    eq $I10, 1, rx1322_restart
    if_null rx1322_debug, debug_1137
    rx1322_cur."!cursor_debug"("START", "quote:sym</ />")
  debug_1137:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1326_done
    goto rxscan1326_scan
  rxscan1326_loop:
    (rx1322_pos) = rx1322_cur."from"()
    inc rx1322_pos
    rx1322_cur."!cursor_from"(rx1322_pos)
    ge rx1322_pos, rx1322_eos, rxscan1326_done
  rxscan1326_scan:
    set_addr $I10, rxscan1326_loop
    rx1322_cur."!mark_push"(0, rx1322_pos, $I10)
  rxscan1326_done:
.annotate 'line', 585
  # rx literal  "/"
    add $I11, rx1322_pos, 1
    gt $I11, rx1322_eos, rx1322_fail
    sub $I11, rx1322_pos, rx1322_off
    ord $I11, rx1322_tgt, $I11
    ne $I11, 47, rx1322_fail
    add rx1322_pos, 1
.annotate 'line', 586
  # rx subrule "newpad" subtype=method negate=
    rx1322_cur."!cursor_pos"(rx1322_pos)
    $P10 = rx1322_cur."newpad"()
    unless $P10, rx1322_fail
    rx1322_pos = $P10."pos"()
.annotate 'line', 587
  # rx reduce name="quote:sym</ />" key="open"
    rx1322_cur."!cursor_pos"(rx1322_pos)
    rx1322_cur."!reduce"("quote:sym</ />", "open")
.annotate 'line', 588
  # rx subrule "LANG" subtype=capture negate=
    rx1322_cur."!cursor_pos"(rx1322_pos)
    $P10 = rx1322_cur."LANG"("Regex", "nibbler")
    unless $P10, rx1322_fail
    rx1322_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx1322_pos = $P10."pos"()
.annotate 'line', 589
  # rx literal  "/"
    add $I11, rx1322_pos, 1
    gt $I11, rx1322_eos, rx1322_fail
    sub $I11, rx1322_pos, rx1322_off
    ord $I11, rx1322_tgt, $I11
    ne $I11, 47, rx1322_fail
    add rx1322_pos, 1
.annotate 'line', 584
  # rx pass
    rx1322_cur."!cursor_pass"(rx1322_pos, "quote:sym</ />")
    if_null rx1322_debug, debug_1138
    rx1322_cur."!cursor_debug"("PASS", "quote:sym</ />", " at pos=", rx1322_pos)
  debug_1138:
    .return (rx1322_cur)
  rx1322_restart:
.annotate 'line', 10
    if_null rx1322_debug, debug_1139
    rx1322_cur."!cursor_debug"("NEXT", "quote:sym</ />")
  debug_1139:
  rx1322_fail:
    (rx1322_rep, rx1322_pos, $I10, $P10) = rx1322_cur."!mark_fail"(0)
    lt rx1322_pos, -1, rx1322_done
    eq rx1322_pos, -1, rx1322_fail
    jump $I10
  rx1322_done:
    rx1322_cur."!cursor_fail"()
    if_null rx1322_debug, debug_1140
    rx1322_cur."!cursor_debug"("FAIL", "quote:sym</ />")
  debug_1140:
    .return (rx1322_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym</ />"  :nsentry("!PREFIX__quote:sym</ />") :subid("252_1303401201.841") :method
.annotate 'line', 10
    $P1324 = self."!PREFIX__!subrule"("newpad", "/")
    new $P1325, "ResizablePMCArray"
    push $P1325, $P1324
    .return ($P1325)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<$>"  :subid("253_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1328_tgt
    .local int rx1328_pos
    .local int rx1328_off
    .local int rx1328_eos
    .local int rx1328_rep
    .local pmc rx1328_cur
    .local pmc rx1328_debug
    (rx1328_cur, rx1328_pos, rx1328_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1328_cur
    .local pmc match
    .lex "$/", match
    length rx1328_eos, rx1328_tgt
    gt rx1328_pos, rx1328_eos, rx1328_done
    set rx1328_off, 0
    lt rx1328_pos, 2, rx1328_start
    sub rx1328_off, rx1328_pos, 1
    substr rx1328_tgt, rx1328_tgt, rx1328_off
  rx1328_start:
    eq $I10, 1, rx1328_restart
    if_null rx1328_debug, debug_1141
    rx1328_cur."!cursor_debug"("START", "quote_escape:sym<$>")
  debug_1141:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1331_done
    goto rxscan1331_scan
  rxscan1331_loop:
    (rx1328_pos) = rx1328_cur."from"()
    inc rx1328_pos
    rx1328_cur."!cursor_from"(rx1328_pos)
    ge rx1328_pos, rx1328_eos, rxscan1331_done
  rxscan1331_scan:
    set_addr $I10, rxscan1331_loop
    rx1328_cur."!mark_push"(0, rx1328_pos, $I10)
  rxscan1331_done:
.annotate 'line', 592
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1328_pos, rx1328_off
    substr $S10, rx1328_tgt, $I10, 1
    index $I11, "$", $S10
    lt $I11, 0, rx1328_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1328_cur."!cursor_pos"(rx1328_pos)
    $P10 = rx1328_cur."quotemod_check"("s")
    unless $P10, rx1328_fail
  # rx subrule "variable" subtype=capture negate=
    rx1328_cur."!cursor_pos"(rx1328_pos)
    $P10 = rx1328_cur."variable"()
    unless $P10, rx1328_fail
    rx1328_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx1328_pos = $P10."pos"()
  # rx pass
    rx1328_cur."!cursor_pass"(rx1328_pos, "quote_escape:sym<$>")
    if_null rx1328_debug, debug_1142
    rx1328_cur."!cursor_debug"("PASS", "quote_escape:sym<$>", " at pos=", rx1328_pos)
  debug_1142:
    .return (rx1328_cur)
  rx1328_restart:
.annotate 'line', 10
    if_null rx1328_debug, debug_1143
    rx1328_cur."!cursor_debug"("NEXT", "quote_escape:sym<$>")
  debug_1143:
  rx1328_fail:
    (rx1328_rep, rx1328_pos, $I10, $P10) = rx1328_cur."!mark_fail"(0)
    lt rx1328_pos, -1, rx1328_done
    eq rx1328_pos, -1, rx1328_fail
    jump $I10
  rx1328_done:
    rx1328_cur."!cursor_fail"()
    if_null rx1328_debug, debug_1144
    rx1328_cur."!cursor_debug"("FAIL", "quote_escape:sym<$>")
  debug_1144:
    .return (rx1328_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<$>"  :nsentry("!PREFIX__quote_escape:sym<$>") :subid("254_1303401201.841") :method
.annotate 'line', 10
    new $P1330, "ResizablePMCArray"
    push $P1330, "$"
    .return ($P1330)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<{ }>"  :subid("255_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1333_tgt
    .local int rx1333_pos
    .local int rx1333_off
    .local int rx1333_eos
    .local int rx1333_rep
    .local pmc rx1333_cur
    .local pmc rx1333_debug
    (rx1333_cur, rx1333_pos, rx1333_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1333_cur
    .local pmc match
    .lex "$/", match
    length rx1333_eos, rx1333_tgt
    gt rx1333_pos, rx1333_eos, rx1333_done
    set rx1333_off, 0
    lt rx1333_pos, 2, rx1333_start
    sub rx1333_off, rx1333_pos, 1
    substr rx1333_tgt, rx1333_tgt, rx1333_off
  rx1333_start:
    eq $I10, 1, rx1333_restart
    if_null rx1333_debug, debug_1145
    rx1333_cur."!cursor_debug"("START", "quote_escape:sym<{ }>")
  debug_1145:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1336_done
    goto rxscan1336_scan
  rxscan1336_loop:
    (rx1333_pos) = rx1333_cur."from"()
    inc rx1333_pos
    rx1333_cur."!cursor_from"(rx1333_pos)
    ge rx1333_pos, rx1333_eos, rxscan1336_done
  rxscan1336_scan:
    set_addr $I10, rxscan1336_loop
    rx1333_cur."!mark_push"(0, rx1333_pos, $I10)
  rxscan1336_done:
.annotate 'line', 593
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1333_pos, rx1333_off
    substr $S10, rx1333_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1333_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1333_cur."!cursor_pos"(rx1333_pos)
    $P10 = rx1333_cur."quotemod_check"("c")
    unless $P10, rx1333_fail
  # rx subrule "block" subtype=capture negate=
    rx1333_cur."!cursor_pos"(rx1333_pos)
    $P10 = rx1333_cur."block"()
    unless $P10, rx1333_fail
    rx1333_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1333_pos = $P10."pos"()
  # rx pass
    rx1333_cur."!cursor_pass"(rx1333_pos, "quote_escape:sym<{ }>")
    if_null rx1333_debug, debug_1146
    rx1333_cur."!cursor_debug"("PASS", "quote_escape:sym<{ }>", " at pos=", rx1333_pos)
  debug_1146:
    .return (rx1333_cur)
  rx1333_restart:
.annotate 'line', 10
    if_null rx1333_debug, debug_1147
    rx1333_cur."!cursor_debug"("NEXT", "quote_escape:sym<{ }>")
  debug_1147:
  rx1333_fail:
    (rx1333_rep, rx1333_pos, $I10, $P10) = rx1333_cur."!mark_fail"(0)
    lt rx1333_pos, -1, rx1333_done
    eq rx1333_pos, -1, rx1333_fail
    jump $I10
  rx1333_done:
    rx1333_cur."!cursor_fail"()
    if_null rx1333_debug, debug_1148
    rx1333_cur."!cursor_debug"("FAIL", "quote_escape:sym<{ }>")
  debug_1148:
    .return (rx1333_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<{ }>"  :nsentry("!PREFIX__quote_escape:sym<{ }>") :subid("256_1303401201.841") :method
.annotate 'line', 10
    new $P1335, "ResizablePMCArray"
    push $P1335, "{"
    .return ($P1335)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<esc>"  :subid("257_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1338_tgt
    .local int rx1338_pos
    .local int rx1338_off
    .local int rx1338_eos
    .local int rx1338_rep
    .local pmc rx1338_cur
    .local pmc rx1338_debug
    (rx1338_cur, rx1338_pos, rx1338_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1338_cur
    .local pmc match
    .lex "$/", match
    length rx1338_eos, rx1338_tgt
    gt rx1338_pos, rx1338_eos, rx1338_done
    set rx1338_off, 0
    lt rx1338_pos, 2, rx1338_start
    sub rx1338_off, rx1338_pos, 1
    substr rx1338_tgt, rx1338_tgt, rx1338_off
  rx1338_start:
    eq $I10, 1, rx1338_restart
    if_null rx1338_debug, debug_1149
    rx1338_cur."!cursor_debug"("START", "quote_escape:sym<esc>")
  debug_1149:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1341_done
    goto rxscan1341_scan
  rxscan1341_loop:
    (rx1338_pos) = rx1338_cur."from"()
    inc rx1338_pos
    rx1338_cur."!cursor_from"(rx1338_pos)
    ge rx1338_pos, rx1338_eos, rxscan1341_done
  rxscan1341_scan:
    set_addr $I10, rxscan1341_loop
    rx1338_cur."!mark_push"(0, rx1338_pos, $I10)
  rxscan1341_done:
.annotate 'line', 594
  # rx literal  "\\e"
    add $I11, rx1338_pos, 2
    gt $I11, rx1338_eos, rx1338_fail
    sub $I11, rx1338_pos, rx1338_off
    substr $S10, rx1338_tgt, $I11, 2
    ne $S10, "\\e", rx1338_fail
    add rx1338_pos, 2
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1338_cur."!cursor_pos"(rx1338_pos)
    $P10 = rx1338_cur."quotemod_check"("b")
    unless $P10, rx1338_fail
  # rx pass
    rx1338_cur."!cursor_pass"(rx1338_pos, "quote_escape:sym<esc>")
    if_null rx1338_debug, debug_1150
    rx1338_cur."!cursor_debug"("PASS", "quote_escape:sym<esc>", " at pos=", rx1338_pos)
  debug_1150:
    .return (rx1338_cur)
  rx1338_restart:
.annotate 'line', 10
    if_null rx1338_debug, debug_1151
    rx1338_cur."!cursor_debug"("NEXT", "quote_escape:sym<esc>")
  debug_1151:
  rx1338_fail:
    (rx1338_rep, rx1338_pos, $I10, $P10) = rx1338_cur."!mark_fail"(0)
    lt rx1338_pos, -1, rx1338_done
    eq rx1338_pos, -1, rx1338_fail
    jump $I10
  rx1338_done:
    rx1338_cur."!cursor_fail"()
    if_null rx1338_debug, debug_1152
    rx1338_cur."!cursor_debug"("FAIL", "quote_escape:sym<esc>")
  debug_1152:
    .return (rx1338_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<esc>"  :nsentry("!PREFIX__quote_escape:sym<esc>") :subid("258_1303401201.841") :method
.annotate 'line', 10
    new $P1340, "ResizablePMCArray"
    push $P1340, "\\e"
    .return ($P1340)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<( )>"  :subid("259_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1343_tgt
    .local int rx1343_pos
    .local int rx1343_off
    .local int rx1343_eos
    .local int rx1343_rep
    .local pmc rx1343_cur
    .local pmc rx1343_debug
    (rx1343_cur, rx1343_pos, rx1343_tgt, $I10) = self."!cursor_start"()
    rx1343_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx1343_cur
    .local pmc match
    .lex "$/", match
    length rx1343_eos, rx1343_tgt
    gt rx1343_pos, rx1343_eos, rx1343_done
    set rx1343_off, 0
    lt rx1343_pos, 2, rx1343_start
    sub rx1343_off, rx1343_pos, 1
    substr rx1343_tgt, rx1343_tgt, rx1343_off
  rx1343_start:
    eq $I10, 1, rx1343_restart
    if_null rx1343_debug, debug_1153
    rx1343_cur."!cursor_debug"("START", "circumfix:sym<( )>")
  debug_1153:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1347_done
    goto rxscan1347_scan
  rxscan1347_loop:
    (rx1343_pos) = rx1343_cur."from"()
    inc rx1343_pos
    rx1343_cur."!cursor_from"(rx1343_pos)
    ge rx1343_pos, rx1343_eos, rxscan1347_done
  rxscan1347_scan:
    set_addr $I10, rxscan1347_loop
    rx1343_cur."!mark_push"(0, rx1343_pos, $I10)
  rxscan1347_done:
.annotate 'line', 596
  # rx literal  "("
    add $I11, rx1343_pos, 1
    gt $I11, rx1343_eos, rx1343_fail
    sub $I11, rx1343_pos, rx1343_off
    ord $I11, rx1343_tgt, $I11
    ne $I11, 40, rx1343_fail
    add rx1343_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1343_cur."!cursor_pos"(rx1343_pos)
    $P10 = rx1343_cur."ws"()
    unless $P10, rx1343_fail
    rx1343_pos = $P10."pos"()
  # rx rxquantr1348 ** 0..1
    set_addr $I10, rxquantr1348_done
    rx1343_cur."!mark_push"(0, rx1343_pos, $I10)
  rxquantr1348_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx1343_cur."!cursor_pos"(rx1343_pos)
    $P10 = rx1343_cur."EXPR"()
    unless $P10, rx1343_fail
    goto rxsubrule1349_pass
  rxsubrule1349_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1343_fail
  rxsubrule1349_pass:
    set_addr $I10, rxsubrule1349_back
    rx1343_cur."!mark_push"(0, rx1343_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx1343_pos = $P10."pos"()
    set_addr $I10, rxquantr1348_done
    (rx1343_rep) = rx1343_cur."!mark_commit"($I10)
  rxquantr1348_done:
  # rx literal  ")"
    add $I11, rx1343_pos, 1
    gt $I11, rx1343_eos, rx1343_fail
    sub $I11, rx1343_pos, rx1343_off
    ord $I11, rx1343_tgt, $I11
    ne $I11, 41, rx1343_fail
    add rx1343_pos, 1
  # rx pass
    rx1343_cur."!cursor_pass"(rx1343_pos, "circumfix:sym<( )>")
    if_null rx1343_debug, debug_1154
    rx1343_cur."!cursor_debug"("PASS", "circumfix:sym<( )>", " at pos=", rx1343_pos)
  debug_1154:
    .return (rx1343_cur)
  rx1343_restart:
.annotate 'line', 10
    if_null rx1343_debug, debug_1155
    rx1343_cur."!cursor_debug"("NEXT", "circumfix:sym<( )>")
  debug_1155:
  rx1343_fail:
    (rx1343_rep, rx1343_pos, $I10, $P10) = rx1343_cur."!mark_fail"(0)
    lt rx1343_pos, -1, rx1343_done
    eq rx1343_pos, -1, rx1343_fail
    jump $I10
  rx1343_done:
    rx1343_cur."!cursor_fail"()
    if_null rx1343_debug, debug_1156
    rx1343_cur."!cursor_debug"("FAIL", "circumfix:sym<( )>")
  debug_1156:
    .return (rx1343_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<( )>"  :nsentry("!PREFIX__circumfix:sym<( )>") :subid("260_1303401201.841") :method
.annotate 'line', 10
    $P1345 = self."!PREFIX__!subrule"("ws", "(")
    new $P1346, "ResizablePMCArray"
    push $P1346, $P1345
    .return ($P1346)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<[ ]>"  :subid("261_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1351_tgt
    .local int rx1351_pos
    .local int rx1351_off
    .local int rx1351_eos
    .local int rx1351_rep
    .local pmc rx1351_cur
    .local pmc rx1351_debug
    (rx1351_cur, rx1351_pos, rx1351_tgt, $I10) = self."!cursor_start"()
    rx1351_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx1351_cur
    .local pmc match
    .lex "$/", match
    length rx1351_eos, rx1351_tgt
    gt rx1351_pos, rx1351_eos, rx1351_done
    set rx1351_off, 0
    lt rx1351_pos, 2, rx1351_start
    sub rx1351_off, rx1351_pos, 1
    substr rx1351_tgt, rx1351_tgt, rx1351_off
  rx1351_start:
    eq $I10, 1, rx1351_restart
    if_null rx1351_debug, debug_1157
    rx1351_cur."!cursor_debug"("START", "circumfix:sym<[ ]>")
  debug_1157:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1355_done
    goto rxscan1355_scan
  rxscan1355_loop:
    (rx1351_pos) = rx1351_cur."from"()
    inc rx1351_pos
    rx1351_cur."!cursor_from"(rx1351_pos)
    ge rx1351_pos, rx1351_eos, rxscan1355_done
  rxscan1355_scan:
    set_addr $I10, rxscan1355_loop
    rx1351_cur."!mark_push"(0, rx1351_pos, $I10)
  rxscan1355_done:
.annotate 'line', 597
  # rx literal  "["
    add $I11, rx1351_pos, 1
    gt $I11, rx1351_eos, rx1351_fail
    sub $I11, rx1351_pos, rx1351_off
    ord $I11, rx1351_tgt, $I11
    ne $I11, 91, rx1351_fail
    add rx1351_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1351_cur."!cursor_pos"(rx1351_pos)
    $P10 = rx1351_cur."ws"()
    unless $P10, rx1351_fail
    rx1351_pos = $P10."pos"()
  # rx rxquantr1356 ** 0..1
    set_addr $I10, rxquantr1356_done
    rx1351_cur."!mark_push"(0, rx1351_pos, $I10)
  rxquantr1356_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx1351_cur."!cursor_pos"(rx1351_pos)
    $P10 = rx1351_cur."EXPR"()
    unless $P10, rx1351_fail
    goto rxsubrule1357_pass
  rxsubrule1357_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1351_fail
  rxsubrule1357_pass:
    set_addr $I10, rxsubrule1357_back
    rx1351_cur."!mark_push"(0, rx1351_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx1351_pos = $P10."pos"()
    set_addr $I10, rxquantr1356_done
    (rx1351_rep) = rx1351_cur."!mark_commit"($I10)
  rxquantr1356_done:
  # rx literal  "]"
    add $I11, rx1351_pos, 1
    gt $I11, rx1351_eos, rx1351_fail
    sub $I11, rx1351_pos, rx1351_off
    ord $I11, rx1351_tgt, $I11
    ne $I11, 93, rx1351_fail
    add rx1351_pos, 1
  # rx pass
    rx1351_cur."!cursor_pass"(rx1351_pos, "circumfix:sym<[ ]>")
    if_null rx1351_debug, debug_1158
    rx1351_cur."!cursor_debug"("PASS", "circumfix:sym<[ ]>", " at pos=", rx1351_pos)
  debug_1158:
    .return (rx1351_cur)
  rx1351_restart:
.annotate 'line', 10
    if_null rx1351_debug, debug_1159
    rx1351_cur."!cursor_debug"("NEXT", "circumfix:sym<[ ]>")
  debug_1159:
  rx1351_fail:
    (rx1351_rep, rx1351_pos, $I10, $P10) = rx1351_cur."!mark_fail"(0)
    lt rx1351_pos, -1, rx1351_done
    eq rx1351_pos, -1, rx1351_fail
    jump $I10
  rx1351_done:
    rx1351_cur."!cursor_fail"()
    if_null rx1351_debug, debug_1160
    rx1351_cur."!cursor_debug"("FAIL", "circumfix:sym<[ ]>")
  debug_1160:
    .return (rx1351_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<[ ]>"  :nsentry("!PREFIX__circumfix:sym<[ ]>") :subid("262_1303401201.841") :method
.annotate 'line', 10
    $P1353 = self."!PREFIX__!subrule"("ws", "[")
    new $P1354, "ResizablePMCArray"
    push $P1354, $P1353
    .return ($P1354)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<ang>"  :subid("263_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1359_tgt
    .local int rx1359_pos
    .local int rx1359_off
    .local int rx1359_eos
    .local int rx1359_rep
    .local pmc rx1359_cur
    .local pmc rx1359_debug
    (rx1359_cur, rx1359_pos, rx1359_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1359_cur
    .local pmc match
    .lex "$/", match
    length rx1359_eos, rx1359_tgt
    gt rx1359_pos, rx1359_eos, rx1359_done
    set rx1359_off, 0
    lt rx1359_pos, 2, rx1359_start
    sub rx1359_off, rx1359_pos, 1
    substr rx1359_tgt, rx1359_tgt, rx1359_off
  rx1359_start:
    eq $I10, 1, rx1359_restart
    if_null rx1359_debug, debug_1161
    rx1359_cur."!cursor_debug"("START", "circumfix:sym<ang>")
  debug_1161:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1362_done
    goto rxscan1362_scan
  rxscan1362_loop:
    (rx1359_pos) = rx1359_cur."from"()
    inc rx1359_pos
    rx1359_cur."!cursor_from"(rx1359_pos)
    ge rx1359_pos, rx1359_eos, rxscan1362_done
  rxscan1362_scan:
    set_addr $I10, rxscan1362_loop
    rx1359_cur."!mark_push"(0, rx1359_pos, $I10)
  rxscan1362_done:
.annotate 'line', 598
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1359_pos, rx1359_off
    substr $S10, rx1359_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx1359_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1359_cur."!cursor_pos"(rx1359_pos)
    $P10 = rx1359_cur."quote_EXPR"(":q", ":w")
    unless $P10, rx1359_fail
    rx1359_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1359_pos = $P10."pos"()
  # rx pass
    rx1359_cur."!cursor_pass"(rx1359_pos, "circumfix:sym<ang>")
    if_null rx1359_debug, debug_1162
    rx1359_cur."!cursor_debug"("PASS", "circumfix:sym<ang>", " at pos=", rx1359_pos)
  debug_1162:
    .return (rx1359_cur)
  rx1359_restart:
.annotate 'line', 10
    if_null rx1359_debug, debug_1163
    rx1359_cur."!cursor_debug"("NEXT", "circumfix:sym<ang>")
  debug_1163:
  rx1359_fail:
    (rx1359_rep, rx1359_pos, $I10, $P10) = rx1359_cur."!mark_fail"(0)
    lt rx1359_pos, -1, rx1359_done
    eq rx1359_pos, -1, rx1359_fail
    jump $I10
  rx1359_done:
    rx1359_cur."!cursor_fail"()
    if_null rx1359_debug, debug_1164
    rx1359_cur."!cursor_debug"("FAIL", "circumfix:sym<ang>")
  debug_1164:
    .return (rx1359_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<ang>"  :nsentry("!PREFIX__circumfix:sym<ang>") :subid("264_1303401201.841") :method
.annotate 'line', 10
    new $P1361, "ResizablePMCArray"
    push $P1361, "<"
    .return ($P1361)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("265_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1364_tgt
    .local int rx1364_pos
    .local int rx1364_off
    .local int rx1364_eos
    .local int rx1364_rep
    .local pmc rx1364_cur
    .local pmc rx1364_debug
    (rx1364_cur, rx1364_pos, rx1364_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1364_cur
    .local pmc match
    .lex "$/", match
    length rx1364_eos, rx1364_tgt
    gt rx1364_pos, rx1364_eos, rx1364_done
    set rx1364_off, 0
    lt rx1364_pos, 2, rx1364_start
    sub rx1364_off, rx1364_pos, 1
    substr rx1364_tgt, rx1364_tgt, rx1364_off
  rx1364_start:
    eq $I10, 1, rx1364_restart
    if_null rx1364_debug, debug_1165
    rx1364_cur."!cursor_debug"("START", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1165:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1367_done
    goto rxscan1367_scan
  rxscan1367_loop:
    (rx1364_pos) = rx1364_cur."from"()
    inc rx1364_pos
    rx1364_cur."!cursor_from"(rx1364_pos)
    ge rx1364_pos, rx1364_eos, rxscan1367_done
  rxscan1367_scan:
    set_addr $I10, rxscan1367_loop
    rx1364_cur."!mark_push"(0, rx1364_pos, $I10)
  rxscan1367_done:
.annotate 'line', 599
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1364_pos, rx1364_off
    substr $S10, rx1364_tgt, $I10, 1
    index $I11, unicode:"\x{ab}", $S10
    lt $I11, 0, rx1364_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1364_cur."!cursor_pos"(rx1364_pos)
    $P10 = rx1364_cur."quote_EXPR"(":qq", ":w")
    unless $P10, rx1364_fail
    rx1364_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1364_pos = $P10."pos"()
  # rx pass
    rx1364_cur."!cursor_pass"(rx1364_pos, unicode:"circumfix:sym<\x{ab} \x{bb}>")
    if_null rx1364_debug, debug_1166
    rx1364_cur."!cursor_debug"("PASS", unicode:"circumfix:sym<\x{ab} \x{bb}>", " at pos=", rx1364_pos)
  debug_1166:
    .return (rx1364_cur)
  rx1364_restart:
.annotate 'line', 10
    if_null rx1364_debug, debug_1167
    rx1364_cur."!cursor_debug"("NEXT", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1167:
  rx1364_fail:
    (rx1364_rep, rx1364_pos, $I10, $P10) = rx1364_cur."!mark_fail"(0)
    lt rx1364_pos, -1, rx1364_done
    eq rx1364_pos, -1, rx1364_fail
    jump $I10
  rx1364_done:
    rx1364_cur."!cursor_fail"()
    if_null rx1364_debug, debug_1168
    rx1364_cur."!cursor_debug"("FAIL", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1168:
    .return (rx1364_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"  :nsentry(unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>") :subid("266_1303401201.841") :method
.annotate 'line', 10
    new $P1366, "ResizablePMCArray"
    push $P1366, unicode:"\x{ab}"
    .return ($P1366)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<{ }>"  :subid("267_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1369_tgt
    .local int rx1369_pos
    .local int rx1369_off
    .local int rx1369_eos
    .local int rx1369_rep
    .local pmc rx1369_cur
    .local pmc rx1369_debug
    (rx1369_cur, rx1369_pos, rx1369_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1369_cur
    .local pmc match
    .lex "$/", match
    length rx1369_eos, rx1369_tgt
    gt rx1369_pos, rx1369_eos, rx1369_done
    set rx1369_off, 0
    lt rx1369_pos, 2, rx1369_start
    sub rx1369_off, rx1369_pos, 1
    substr rx1369_tgt, rx1369_tgt, rx1369_off
  rx1369_start:
    eq $I10, 1, rx1369_restart
    if_null rx1369_debug, debug_1169
    rx1369_cur."!cursor_debug"("START", "circumfix:sym<{ }>")
  debug_1169:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1372_done
    goto rxscan1372_scan
  rxscan1372_loop:
    (rx1369_pos) = rx1369_cur."from"()
    inc rx1369_pos
    rx1369_cur."!cursor_from"(rx1369_pos)
    ge rx1369_pos, rx1369_eos, rxscan1372_done
  rxscan1372_scan:
    set_addr $I10, rxscan1372_loop
    rx1369_cur."!mark_push"(0, rx1369_pos, $I10)
  rxscan1372_done:
.annotate 'line', 600
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1369_pos, rx1369_off
    substr $S10, rx1369_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1369_fail
  # rx subrule "pblock" subtype=capture negate=
    rx1369_cur."!cursor_pos"(rx1369_pos)
    $P10 = rx1369_cur."pblock"()
    unless $P10, rx1369_fail
    rx1369_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx1369_pos = $P10."pos"()
  # rx pass
    rx1369_cur."!cursor_pass"(rx1369_pos, "circumfix:sym<{ }>")
    if_null rx1369_debug, debug_1170
    rx1369_cur."!cursor_debug"("PASS", "circumfix:sym<{ }>", " at pos=", rx1369_pos)
  debug_1170:
    .return (rx1369_cur)
  rx1369_restart:
.annotate 'line', 10
    if_null rx1369_debug, debug_1171
    rx1369_cur."!cursor_debug"("NEXT", "circumfix:sym<{ }>")
  debug_1171:
  rx1369_fail:
    (rx1369_rep, rx1369_pos, $I10, $P10) = rx1369_cur."!mark_fail"(0)
    lt rx1369_pos, -1, rx1369_done
    eq rx1369_pos, -1, rx1369_fail
    jump $I10
  rx1369_done:
    rx1369_cur."!cursor_fail"()
    if_null rx1369_debug, debug_1172
    rx1369_cur."!cursor_debug"("FAIL", "circumfix:sym<{ }>")
  debug_1172:
    .return (rx1369_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<{ }>"  :nsentry("!PREFIX__circumfix:sym<{ }>") :subid("268_1303401201.841") :method
.annotate 'line', 10
    new $P1371, "ResizablePMCArray"
    push $P1371, "{"
    .return ($P1371)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<sigil>"  :subid("269_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1374_tgt
    .local int rx1374_pos
    .local int rx1374_off
    .local int rx1374_eos
    .local int rx1374_rep
    .local pmc rx1374_cur
    .local pmc rx1374_debug
    (rx1374_cur, rx1374_pos, rx1374_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1374_cur
    .local pmc match
    .lex "$/", match
    length rx1374_eos, rx1374_tgt
    gt rx1374_pos, rx1374_eos, rx1374_done
    set rx1374_off, 0
    lt rx1374_pos, 2, rx1374_start
    sub rx1374_off, rx1374_pos, 1
    substr rx1374_tgt, rx1374_tgt, rx1374_off
  rx1374_start:
    eq $I10, 1, rx1374_restart
    if_null rx1374_debug, debug_1173
    rx1374_cur."!cursor_debug"("START", "circumfix:sym<sigil>")
  debug_1173:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1378_done
    goto rxscan1378_scan
  rxscan1378_loop:
    (rx1374_pos) = rx1374_cur."from"()
    inc rx1374_pos
    rx1374_cur."!cursor_from"(rx1374_pos)
    ge rx1374_pos, rx1374_eos, rxscan1378_done
  rxscan1378_scan:
    set_addr $I10, rxscan1378_loop
    rx1374_cur."!mark_push"(0, rx1374_pos, $I10)
  rxscan1378_done:
.annotate 'line', 601
  # rx subrule "sigil" subtype=capture negate=
    rx1374_cur."!cursor_pos"(rx1374_pos)
    $P10 = rx1374_cur."sigil"()
    unless $P10, rx1374_fail
    rx1374_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1374_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1374_pos, 1
    gt $I11, rx1374_eos, rx1374_fail
    sub $I11, rx1374_pos, rx1374_off
    ord $I11, rx1374_tgt, $I11
    ne $I11, 40, rx1374_fail
    add rx1374_pos, 1
  # rx subrule "semilist" subtype=capture negate=
    rx1374_cur."!cursor_pos"(rx1374_pos)
    $P10 = rx1374_cur."semilist"()
    unless $P10, rx1374_fail
    rx1374_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("semilist")
    rx1374_pos = $P10."pos"()
  alt1379_0:
    set_addr $I10, alt1379_1
    rx1374_cur."!mark_push"(0, rx1374_pos, $I10)
  # rx literal  ")"
    add $I11, rx1374_pos, 1
    gt $I11, rx1374_eos, rx1374_fail
    sub $I11, rx1374_pos, rx1374_off
    ord $I11, rx1374_tgt, $I11
    ne $I11, 41, rx1374_fail
    add rx1374_pos, 1
    goto alt1379_end
  alt1379_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx1374_cur."!cursor_pos"(rx1374_pos)
    $P10 = rx1374_cur."FAILGOAL"("')'")
    unless $P10, rx1374_fail
    goto rxsubrule1381_pass
  rxsubrule1381_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1374_fail
  rxsubrule1381_pass:
    set_addr $I10, rxsubrule1381_back
    rx1374_cur."!mark_push"(0, rx1374_pos, $I10, $P10)
    rx1374_pos = $P10."pos"()
  alt1379_end:
  # rx pass
    rx1374_cur."!cursor_pass"(rx1374_pos, "circumfix:sym<sigil>")
    if_null rx1374_debug, debug_1174
    rx1374_cur."!cursor_debug"("PASS", "circumfix:sym<sigil>", " at pos=", rx1374_pos)
  debug_1174:
    .return (rx1374_cur)
  rx1374_restart:
.annotate 'line', 10
    if_null rx1374_debug, debug_1175
    rx1374_cur."!cursor_debug"("NEXT", "circumfix:sym<sigil>")
  debug_1175:
  rx1374_fail:
    (rx1374_rep, rx1374_pos, $I10, $P10) = rx1374_cur."!mark_fail"(0)
    lt rx1374_pos, -1, rx1374_done
    eq rx1374_pos, -1, rx1374_fail
    jump $I10
  rx1374_done:
    rx1374_cur."!cursor_fail"()
    if_null rx1374_debug, debug_1176
    rx1374_cur."!cursor_debug"("FAIL", "circumfix:sym<sigil>")
  debug_1176:
    .return (rx1374_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<sigil>"  :nsentry("!PREFIX__circumfix:sym<sigil>") :subid("270_1303401201.841") :method
.annotate 'line', 10
    $P1376 = self."!PREFIX__!subrule"("sigil", "")
    new $P1377, "ResizablePMCArray"
    push $P1377, $P1376
    .return ($P1377)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "semilist"  :subid("271_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1383_tgt
    .local int rx1383_pos
    .local int rx1383_off
    .local int rx1383_eos
    .local int rx1383_rep
    .local pmc rx1383_cur
    .local pmc rx1383_debug
    (rx1383_cur, rx1383_pos, rx1383_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1383_cur
    .local pmc match
    .lex "$/", match
    length rx1383_eos, rx1383_tgt
    gt rx1383_pos, rx1383_eos, rx1383_done
    set rx1383_off, 0
    lt rx1383_pos, 2, rx1383_start
    sub rx1383_off, rx1383_pos, 1
    substr rx1383_tgt, rx1383_tgt, rx1383_off
  rx1383_start:
    eq $I10, 1, rx1383_restart
    if_null rx1383_debug, debug_1177
    rx1383_cur."!cursor_debug"("START", "semilist")
  debug_1177:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1387_done
    goto rxscan1387_scan
  rxscan1387_loop:
    (rx1383_pos) = rx1383_cur."from"()
    inc rx1383_pos
    rx1383_cur."!cursor_from"(rx1383_pos)
    ge rx1383_pos, rx1383_eos, rxscan1387_done
  rxscan1387_scan:
    set_addr $I10, rxscan1387_loop
    rx1383_cur."!mark_push"(0, rx1383_pos, $I10)
  rxscan1387_done:
.annotate 'line', 603
  # rx subrule "ws" subtype=method negate=
    rx1383_cur."!cursor_pos"(rx1383_pos)
    $P10 = rx1383_cur."ws"()
    unless $P10, rx1383_fail
    rx1383_pos = $P10."pos"()
  # rx subrule "statement" subtype=capture negate=
    rx1383_cur."!cursor_pos"(rx1383_pos)
    $P10 = rx1383_cur."statement"()
    unless $P10, rx1383_fail
    rx1383_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx1383_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1383_cur."!cursor_pos"(rx1383_pos)
    $P10 = rx1383_cur."ws"()
    unless $P10, rx1383_fail
    rx1383_pos = $P10."pos"()
  # rx pass
    rx1383_cur."!cursor_pass"(rx1383_pos, "semilist")
    if_null rx1383_debug, debug_1178
    rx1383_cur."!cursor_debug"("PASS", "semilist", " at pos=", rx1383_pos)
  debug_1178:
    .return (rx1383_cur)
  rx1383_restart:
.annotate 'line', 10
    if_null rx1383_debug, debug_1179
    rx1383_cur."!cursor_debug"("NEXT", "semilist")
  debug_1179:
  rx1383_fail:
    (rx1383_rep, rx1383_pos, $I10, $P10) = rx1383_cur."!mark_fail"(0)
    lt rx1383_pos, -1, rx1383_done
    eq rx1383_pos, -1, rx1383_fail
    jump $I10
  rx1383_done:
    rx1383_cur."!cursor_fail"()
    if_null rx1383_debug, debug_1180
    rx1383_cur."!cursor_debug"("FAIL", "semilist")
  debug_1180:
    .return (rx1383_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__semilist"  :nsentry("!PREFIX__semilist") :subid("272_1303401201.841") :method
.annotate 'line', 10
    $P1385 = self."!PREFIX__!subrule"("ws", "")
    new $P1386, "ResizablePMCArray"
    push $P1386, $P1385
    .return ($P1386)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixish"  :subid("273_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1391_tgt
    .local int rx1391_pos
    .local int rx1391_off
    .local int rx1391_eos
    .local int rx1391_rep
    .local pmc rx1391_cur
    .local pmc rx1391_debug
    (rx1391_cur, rx1391_pos, rx1391_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1391_cur
    .local pmc match
    .lex "$/", match
    length rx1391_eos, rx1391_tgt
    gt rx1391_pos, rx1391_eos, rx1391_done
    set rx1391_off, 0
    lt rx1391_pos, 2, rx1391_start
    sub rx1391_off, rx1391_pos, 1
    substr rx1391_tgt, rx1391_tgt, rx1391_off
  rx1391_start:
    eq $I10, 1, rx1391_restart
    if_null rx1391_debug, debug_1181
    rx1391_cur."!cursor_debug"("START", "infixish")
  debug_1181:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1394_done
    goto rxscan1394_scan
  rxscan1394_loop:
    (rx1391_pos) = rx1391_cur."from"()
    inc rx1391_pos
    rx1391_cur."!cursor_from"(rx1391_pos)
    ge rx1391_pos, rx1391_eos, rxscan1394_done
  rxscan1394_scan:
    set_addr $I10, rxscan1394_loop
    rx1391_cur."!mark_push"(0, rx1391_pos, $I10)
  rxscan1394_done:
.annotate 'line', 626
  # rx subrule "infixstopper" subtype=zerowidth negate=1
    rx1391_cur."!cursor_pos"(rx1391_pos)
    $P10 = rx1391_cur."infixstopper"()
    if $P10, rx1391_fail
  # rx subrule "infix" subtype=capture negate=
    rx1391_cur."!cursor_pos"(rx1391_pos)
    $P10 = rx1391_cur."infix"()
    unless $P10, rx1391_fail
    rx1391_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("OPER=infix")
    rx1391_pos = $P10."pos"()
  # rx pass
    rx1391_cur."!cursor_pass"(rx1391_pos, "infixish")
    if_null rx1391_debug, debug_1182
    rx1391_cur."!cursor_debug"("PASS", "infixish", " at pos=", rx1391_pos)
  debug_1182:
    .return (rx1391_cur)
  rx1391_restart:
.annotate 'line', 10
    if_null rx1391_debug, debug_1183
    rx1391_cur."!cursor_debug"("NEXT", "infixish")
  debug_1183:
  rx1391_fail:
    (rx1391_rep, rx1391_pos, $I10, $P10) = rx1391_cur."!mark_fail"(0)
    lt rx1391_pos, -1, rx1391_done
    eq rx1391_pos, -1, rx1391_fail
    jump $I10
  rx1391_done:
    rx1391_cur."!cursor_fail"()
    if_null rx1391_debug, debug_1184
    rx1391_cur."!cursor_debug"("FAIL", "infixish")
  debug_1184:
    .return (rx1391_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixish"  :nsentry("!PREFIX__infixish") :subid("274_1303401201.841") :method
.annotate 'line', 10
    new $P1393, "ResizablePMCArray"
    push $P1393, ""
    .return ($P1393)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixstopper"  :subid("275_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1396_tgt
    .local int rx1396_pos
    .local int rx1396_off
    .local int rx1396_eos
    .local int rx1396_rep
    .local pmc rx1396_cur
    .local pmc rx1396_debug
    (rx1396_cur, rx1396_pos, rx1396_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1396_cur
    .local pmc match
    .lex "$/", match
    length rx1396_eos, rx1396_tgt
    gt rx1396_pos, rx1396_eos, rx1396_done
    set rx1396_off, 0
    lt rx1396_pos, 2, rx1396_start
    sub rx1396_off, rx1396_pos, 1
    substr rx1396_tgt, rx1396_tgt, rx1396_off
  rx1396_start:
    eq $I10, 1, rx1396_restart
    if_null rx1396_debug, debug_1185
    rx1396_cur."!cursor_debug"("START", "infixstopper")
  debug_1185:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1399_done
    goto rxscan1399_scan
  rxscan1399_loop:
    (rx1396_pos) = rx1396_cur."from"()
    inc rx1396_pos
    rx1396_cur."!cursor_from"(rx1396_pos)
    ge rx1396_pos, rx1396_eos, rxscan1399_done
  rxscan1399_scan:
    set_addr $I10, rxscan1399_loop
    rx1396_cur."!mark_push"(0, rx1396_pos, $I10)
  rxscan1399_done:
.annotate 'line', 627
  # rx subrule "lambda" subtype=zerowidth negate=
    rx1396_cur."!cursor_pos"(rx1396_pos)
    $P10 = rx1396_cur."lambda"()
    unless $P10, rx1396_fail
  # rx pass
    rx1396_cur."!cursor_pass"(rx1396_pos, "infixstopper")
    if_null rx1396_debug, debug_1186
    rx1396_cur."!cursor_debug"("PASS", "infixstopper", " at pos=", rx1396_pos)
  debug_1186:
    .return (rx1396_cur)
  rx1396_restart:
.annotate 'line', 10
    if_null rx1396_debug, debug_1187
    rx1396_cur."!cursor_debug"("NEXT", "infixstopper")
  debug_1187:
  rx1396_fail:
    (rx1396_rep, rx1396_pos, $I10, $P10) = rx1396_cur."!mark_fail"(0)
    lt rx1396_pos, -1, rx1396_done
    eq rx1396_pos, -1, rx1396_fail
    jump $I10
  rx1396_done:
    rx1396_cur."!cursor_fail"()
    if_null rx1396_debug, debug_1188
    rx1396_cur."!cursor_debug"("FAIL", "infixstopper")
  debug_1188:
    .return (rx1396_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixstopper"  :nsentry("!PREFIX__infixstopper") :subid("276_1303401201.841") :method
.annotate 'line', 10
    new $P1398, "ResizablePMCArray"
    push $P1398, ""
    .return ($P1398)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<[ ]>"  :subid("277_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1401_tgt
    .local int rx1401_pos
    .local int rx1401_off
    .local int rx1401_eos
    .local int rx1401_rep
    .local pmc rx1401_cur
    .local pmc rx1401_debug
    (rx1401_cur, rx1401_pos, rx1401_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1401_cur
    .local pmc match
    .lex "$/", match
    length rx1401_eos, rx1401_tgt
    gt rx1401_pos, rx1401_eos, rx1401_done
    set rx1401_off, 0
    lt rx1401_pos, 2, rx1401_start
    sub rx1401_off, rx1401_pos, 1
    substr rx1401_tgt, rx1401_tgt, rx1401_off
  rx1401_start:
    eq $I10, 1, rx1401_restart
    if_null rx1401_debug, debug_1189
    rx1401_cur."!cursor_debug"("START", "postcircumfix:sym<[ ]>")
  debug_1189:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1405_done
    goto rxscan1405_scan
  rxscan1405_loop:
    (rx1401_pos) = rx1401_cur."from"()
    inc rx1401_pos
    rx1401_cur."!cursor_from"(rx1401_pos)
    ge rx1401_pos, rx1401_eos, rxscan1405_done
  rxscan1405_scan:
    set_addr $I10, rxscan1405_loop
    rx1401_cur."!mark_push"(0, rx1401_pos, $I10)
  rxscan1405_done:
.annotate 'line', 630
  # rx literal  "["
    add $I11, rx1401_pos, 1
    gt $I11, rx1401_eos, rx1401_fail
    sub $I11, rx1401_pos, rx1401_off
    ord $I11, rx1401_tgt, $I11
    ne $I11, 91, rx1401_fail
    add rx1401_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1401_cur."!cursor_pos"(rx1401_pos)
    $P10 = rx1401_cur."ws"()
    unless $P10, rx1401_fail
    rx1401_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1401_cur."!cursor_pos"(rx1401_pos)
    $P10 = rx1401_cur."EXPR"()
    unless $P10, rx1401_fail
    rx1401_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1401_pos = $P10."pos"()
  # rx literal  "]"
    add $I11, rx1401_pos, 1
    gt $I11, rx1401_eos, rx1401_fail
    sub $I11, rx1401_pos, rx1401_off
    ord $I11, rx1401_tgt, $I11
    ne $I11, 93, rx1401_fail
    add rx1401_pos, 1
.annotate 'line', 631
  # rx subrule "O" subtype=capture negate=
    rx1401_cur."!cursor_pos"(rx1401_pos)
    $P10 = rx1401_cur."O"("%methodop")
    unless $P10, rx1401_fail
    rx1401_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1401_pos = $P10."pos"()
.annotate 'line', 629
  # rx pass
    rx1401_cur."!cursor_pass"(rx1401_pos, "postcircumfix:sym<[ ]>")
    if_null rx1401_debug, debug_1190
    rx1401_cur."!cursor_debug"("PASS", "postcircumfix:sym<[ ]>", " at pos=", rx1401_pos)
  debug_1190:
    .return (rx1401_cur)
  rx1401_restart:
.annotate 'line', 10
    if_null rx1401_debug, debug_1191
    rx1401_cur."!cursor_debug"("NEXT", "postcircumfix:sym<[ ]>")
  debug_1191:
  rx1401_fail:
    (rx1401_rep, rx1401_pos, $I10, $P10) = rx1401_cur."!mark_fail"(0)
    lt rx1401_pos, -1, rx1401_done
    eq rx1401_pos, -1, rx1401_fail
    jump $I10
  rx1401_done:
    rx1401_cur."!cursor_fail"()
    if_null rx1401_debug, debug_1192
    rx1401_cur."!cursor_debug"("FAIL", "postcircumfix:sym<[ ]>")
  debug_1192:
    .return (rx1401_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<[ ]>"  :nsentry("!PREFIX__postcircumfix:sym<[ ]>") :subid("278_1303401201.841") :method
.annotate 'line', 10
    $P1403 = self."!PREFIX__!subrule"("ws", "[")
    new $P1404, "ResizablePMCArray"
    push $P1404, $P1403
    .return ($P1404)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<{ }>"  :subid("279_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1407_tgt
    .local int rx1407_pos
    .local int rx1407_off
    .local int rx1407_eos
    .local int rx1407_rep
    .local pmc rx1407_cur
    .local pmc rx1407_debug
    (rx1407_cur, rx1407_pos, rx1407_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1407_cur
    .local pmc match
    .lex "$/", match
    length rx1407_eos, rx1407_tgt
    gt rx1407_pos, rx1407_eos, rx1407_done
    set rx1407_off, 0
    lt rx1407_pos, 2, rx1407_start
    sub rx1407_off, rx1407_pos, 1
    substr rx1407_tgt, rx1407_tgt, rx1407_off
  rx1407_start:
    eq $I10, 1, rx1407_restart
    if_null rx1407_debug, debug_1193
    rx1407_cur."!cursor_debug"("START", "postcircumfix:sym<{ }>")
  debug_1193:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1411_done
    goto rxscan1411_scan
  rxscan1411_loop:
    (rx1407_pos) = rx1407_cur."from"()
    inc rx1407_pos
    rx1407_cur."!cursor_from"(rx1407_pos)
    ge rx1407_pos, rx1407_eos, rxscan1411_done
  rxscan1411_scan:
    set_addr $I10, rxscan1411_loop
    rx1407_cur."!mark_push"(0, rx1407_pos, $I10)
  rxscan1411_done:
.annotate 'line', 635
  # rx literal  "{"
    add $I11, rx1407_pos, 1
    gt $I11, rx1407_eos, rx1407_fail
    sub $I11, rx1407_pos, rx1407_off
    ord $I11, rx1407_tgt, $I11
    ne $I11, 123, rx1407_fail
    add rx1407_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1407_cur."!cursor_pos"(rx1407_pos)
    $P10 = rx1407_cur."ws"()
    unless $P10, rx1407_fail
    rx1407_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1407_cur."!cursor_pos"(rx1407_pos)
    $P10 = rx1407_cur."EXPR"()
    unless $P10, rx1407_fail
    rx1407_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1407_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1407_pos, 1
    gt $I11, rx1407_eos, rx1407_fail
    sub $I11, rx1407_pos, rx1407_off
    ord $I11, rx1407_tgt, $I11
    ne $I11, 125, rx1407_fail
    add rx1407_pos, 1
.annotate 'line', 636
  # rx subrule "O" subtype=capture negate=
    rx1407_cur."!cursor_pos"(rx1407_pos)
    $P10 = rx1407_cur."O"("%methodop")
    unless $P10, rx1407_fail
    rx1407_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1407_pos = $P10."pos"()
.annotate 'line', 634
  # rx pass
    rx1407_cur."!cursor_pass"(rx1407_pos, "postcircumfix:sym<{ }>")
    if_null rx1407_debug, debug_1194
    rx1407_cur."!cursor_debug"("PASS", "postcircumfix:sym<{ }>", " at pos=", rx1407_pos)
  debug_1194:
    .return (rx1407_cur)
  rx1407_restart:
.annotate 'line', 10
    if_null rx1407_debug, debug_1195
    rx1407_cur."!cursor_debug"("NEXT", "postcircumfix:sym<{ }>")
  debug_1195:
  rx1407_fail:
    (rx1407_rep, rx1407_pos, $I10, $P10) = rx1407_cur."!mark_fail"(0)
    lt rx1407_pos, -1, rx1407_done
    eq rx1407_pos, -1, rx1407_fail
    jump $I10
  rx1407_done:
    rx1407_cur."!cursor_fail"()
    if_null rx1407_debug, debug_1196
    rx1407_cur."!cursor_debug"("FAIL", "postcircumfix:sym<{ }>")
  debug_1196:
    .return (rx1407_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<{ }>"  :nsentry("!PREFIX__postcircumfix:sym<{ }>") :subid("280_1303401201.841") :method
.annotate 'line', 10
    $P1409 = self."!PREFIX__!subrule"("ws", "{")
    new $P1410, "ResizablePMCArray"
    push $P1410, $P1409
    .return ($P1410)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<ang>"  :subid("281_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1413_tgt
    .local int rx1413_pos
    .local int rx1413_off
    .local int rx1413_eos
    .local int rx1413_rep
    .local pmc rx1413_cur
    .local pmc rx1413_debug
    (rx1413_cur, rx1413_pos, rx1413_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1413_cur
    .local pmc match
    .lex "$/", match
    length rx1413_eos, rx1413_tgt
    gt rx1413_pos, rx1413_eos, rx1413_done
    set rx1413_off, 0
    lt rx1413_pos, 2, rx1413_start
    sub rx1413_off, rx1413_pos, 1
    substr rx1413_tgt, rx1413_tgt, rx1413_off
  rx1413_start:
    eq $I10, 1, rx1413_restart
    if_null rx1413_debug, debug_1197
    rx1413_cur."!cursor_debug"("START", "postcircumfix:sym<ang>")
  debug_1197:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1416_done
    goto rxscan1416_scan
  rxscan1416_loop:
    (rx1413_pos) = rx1413_cur."from"()
    inc rx1413_pos
    rx1413_cur."!cursor_from"(rx1413_pos)
    ge rx1413_pos, rx1413_eos, rxscan1416_done
  rxscan1416_scan:
    set_addr $I10, rxscan1416_loop
    rx1413_cur."!mark_push"(0, rx1413_pos, $I10)
  rxscan1416_done:
.annotate 'line', 640
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1413_pos, rx1413_off
    substr $S10, rx1413_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx1413_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1413_cur."!cursor_pos"(rx1413_pos)
    $P10 = rx1413_cur."quote_EXPR"(":q")
    unless $P10, rx1413_fail
    rx1413_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1413_pos = $P10."pos"()
.annotate 'line', 641
  # rx subrule "O" subtype=capture negate=
    rx1413_cur."!cursor_pos"(rx1413_pos)
    $P10 = rx1413_cur."O"("%methodop")
    unless $P10, rx1413_fail
    rx1413_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1413_pos = $P10."pos"()
.annotate 'line', 639
  # rx pass
    rx1413_cur."!cursor_pass"(rx1413_pos, "postcircumfix:sym<ang>")
    if_null rx1413_debug, debug_1198
    rx1413_cur."!cursor_debug"("PASS", "postcircumfix:sym<ang>", " at pos=", rx1413_pos)
  debug_1198:
    .return (rx1413_cur)
  rx1413_restart:
.annotate 'line', 10
    if_null rx1413_debug, debug_1199
    rx1413_cur."!cursor_debug"("NEXT", "postcircumfix:sym<ang>")
  debug_1199:
  rx1413_fail:
    (rx1413_rep, rx1413_pos, $I10, $P10) = rx1413_cur."!mark_fail"(0)
    lt rx1413_pos, -1, rx1413_done
    eq rx1413_pos, -1, rx1413_fail
    jump $I10
  rx1413_done:
    rx1413_cur."!cursor_fail"()
    if_null rx1413_debug, debug_1200
    rx1413_cur."!cursor_debug"("FAIL", "postcircumfix:sym<ang>")
  debug_1200:
    .return (rx1413_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<ang>"  :nsentry("!PREFIX__postcircumfix:sym<ang>") :subid("282_1303401201.841") :method
.annotate 'line', 10
    new $P1415, "ResizablePMCArray"
    push $P1415, "<"
    .return ($P1415)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<( )>"  :subid("283_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1418_tgt
    .local int rx1418_pos
    .local int rx1418_off
    .local int rx1418_eos
    .local int rx1418_rep
    .local pmc rx1418_cur
    .local pmc rx1418_debug
    (rx1418_cur, rx1418_pos, rx1418_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1418_cur
    .local pmc match
    .lex "$/", match
    length rx1418_eos, rx1418_tgt
    gt rx1418_pos, rx1418_eos, rx1418_done
    set rx1418_off, 0
    lt rx1418_pos, 2, rx1418_start
    sub rx1418_off, rx1418_pos, 1
    substr rx1418_tgt, rx1418_tgt, rx1418_off
  rx1418_start:
    eq $I10, 1, rx1418_restart
    if_null rx1418_debug, debug_1201
    rx1418_cur."!cursor_debug"("START", "postcircumfix:sym<( )>")
  debug_1201:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1422_done
    goto rxscan1422_scan
  rxscan1422_loop:
    (rx1418_pos) = rx1418_cur."from"()
    inc rx1418_pos
    rx1418_cur."!cursor_from"(rx1418_pos)
    ge rx1418_pos, rx1418_eos, rxscan1422_done
  rxscan1422_scan:
    set_addr $I10, rxscan1422_loop
    rx1418_cur."!mark_push"(0, rx1418_pos, $I10)
  rxscan1422_done:
.annotate 'line', 645
  # rx literal  "("
    add $I11, rx1418_pos, 1
    gt $I11, rx1418_eos, rx1418_fail
    sub $I11, rx1418_pos, rx1418_off
    ord $I11, rx1418_tgt, $I11
    ne $I11, 40, rx1418_fail
    add rx1418_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1418_cur."!cursor_pos"(rx1418_pos)
    $P10 = rx1418_cur."ws"()
    unless $P10, rx1418_fail
    rx1418_pos = $P10."pos"()
  # rx subrule "arglist" subtype=capture negate=
    rx1418_cur."!cursor_pos"(rx1418_pos)
    $P10 = rx1418_cur."arglist"()
    unless $P10, rx1418_fail
    rx1418_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1418_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1418_pos, 1
    gt $I11, rx1418_eos, rx1418_fail
    sub $I11, rx1418_pos, rx1418_off
    ord $I11, rx1418_tgt, $I11
    ne $I11, 41, rx1418_fail
    add rx1418_pos, 1
.annotate 'line', 646
  # rx subrule "O" subtype=capture negate=
    rx1418_cur."!cursor_pos"(rx1418_pos)
    $P10 = rx1418_cur."O"("%methodop")
    unless $P10, rx1418_fail
    rx1418_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1418_pos = $P10."pos"()
.annotate 'line', 644
  # rx pass
    rx1418_cur."!cursor_pass"(rx1418_pos, "postcircumfix:sym<( )>")
    if_null rx1418_debug, debug_1202
    rx1418_cur."!cursor_debug"("PASS", "postcircumfix:sym<( )>", " at pos=", rx1418_pos)
  debug_1202:
    .return (rx1418_cur)
  rx1418_restart:
.annotate 'line', 10
    if_null rx1418_debug, debug_1203
    rx1418_cur."!cursor_debug"("NEXT", "postcircumfix:sym<( )>")
  debug_1203:
  rx1418_fail:
    (rx1418_rep, rx1418_pos, $I10, $P10) = rx1418_cur."!mark_fail"(0)
    lt rx1418_pos, -1, rx1418_done
    eq rx1418_pos, -1, rx1418_fail
    jump $I10
  rx1418_done:
    rx1418_cur."!cursor_fail"()
    if_null rx1418_debug, debug_1204
    rx1418_cur."!cursor_debug"("FAIL", "postcircumfix:sym<( )>")
  debug_1204:
    .return (rx1418_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<( )>"  :nsentry("!PREFIX__postcircumfix:sym<( )>") :subid("284_1303401201.841") :method
.annotate 'line', 10
    $P1420 = self."!PREFIX__!subrule"("ws", "(")
    new $P1421, "ResizablePMCArray"
    push $P1421, $P1420
    .return ($P1421)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<.>"  :subid("285_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1424_tgt
    .local int rx1424_pos
    .local int rx1424_off
    .local int rx1424_eos
    .local int rx1424_rep
    .local pmc rx1424_cur
    .local pmc rx1424_debug
    (rx1424_cur, rx1424_pos, rx1424_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1424_cur
    .local pmc match
    .lex "$/", match
    length rx1424_eos, rx1424_tgt
    gt rx1424_pos, rx1424_eos, rx1424_done
    set rx1424_off, 0
    lt rx1424_pos, 2, rx1424_start
    sub rx1424_off, rx1424_pos, 1
    substr rx1424_tgt, rx1424_tgt, rx1424_off
  rx1424_start:
    eq $I10, 1, rx1424_restart
    if_null rx1424_debug, debug_1205
    rx1424_cur."!cursor_debug"("START", "postfix:sym<.>")
  debug_1205:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1428_done
    goto rxscan1428_scan
  rxscan1428_loop:
    (rx1424_pos) = rx1424_cur."from"()
    inc rx1424_pos
    rx1424_cur."!cursor_from"(rx1424_pos)
    ge rx1424_pos, rx1424_eos, rxscan1428_done
  rxscan1428_scan:
    set_addr $I10, rxscan1428_loop
    rx1424_cur."!mark_push"(0, rx1424_pos, $I10)
  rxscan1428_done:
.annotate 'line', 649
  # rx subrule "dotty" subtype=capture negate=
    rx1424_cur."!cursor_pos"(rx1424_pos)
    $P10 = rx1424_cur."dotty"()
    unless $P10, rx1424_fail
    rx1424_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dotty")
    rx1424_pos = $P10."pos"()
  # rx subrule "O" subtype=capture negate=
    rx1424_cur."!cursor_pos"(rx1424_pos)
    $P10 = rx1424_cur."O"("%methodop")
    unless $P10, rx1424_fail
    rx1424_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1424_pos = $P10."pos"()
  # rx pass
    rx1424_cur."!cursor_pass"(rx1424_pos, "postfix:sym<.>")
    if_null rx1424_debug, debug_1206
    rx1424_cur."!cursor_debug"("PASS", "postfix:sym<.>", " at pos=", rx1424_pos)
  debug_1206:
    .return (rx1424_cur)
  rx1424_restart:
.annotate 'line', 10
    if_null rx1424_debug, debug_1207
    rx1424_cur."!cursor_debug"("NEXT", "postfix:sym<.>")
  debug_1207:
  rx1424_fail:
    (rx1424_rep, rx1424_pos, $I10, $P10) = rx1424_cur."!mark_fail"(0)
    lt rx1424_pos, -1, rx1424_done
    eq rx1424_pos, -1, rx1424_fail
    jump $I10
  rx1424_done:
    rx1424_cur."!cursor_fail"()
    if_null rx1424_debug, debug_1208
    rx1424_cur."!cursor_debug"("FAIL", "postfix:sym<.>")
  debug_1208:
    .return (rx1424_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<.>"  :nsentry("!PREFIX__postfix:sym<.>") :subid("286_1303401201.841") :method
.annotate 'line', 10
    $P1426 = self."!PREFIX__!subrule"("dotty", "")
    new $P1427, "ResizablePMCArray"
    push $P1427, $P1426
    .return ($P1427)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<++>"  :subid("287_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1430_tgt
    .local int rx1430_pos
    .local int rx1430_off
    .local int rx1430_eos
    .local int rx1430_rep
    .local pmc rx1430_cur
    .local pmc rx1430_debug
    (rx1430_cur, rx1430_pos, rx1430_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1430_cur
    .local pmc match
    .lex "$/", match
    length rx1430_eos, rx1430_tgt
    gt rx1430_pos, rx1430_eos, rx1430_done
    set rx1430_off, 0
    lt rx1430_pos, 2, rx1430_start
    sub rx1430_off, rx1430_pos, 1
    substr rx1430_tgt, rx1430_tgt, rx1430_off
  rx1430_start:
    eq $I10, 1, rx1430_restart
    if_null rx1430_debug, debug_1209
    rx1430_cur."!cursor_debug"("START", "prefix:sym<++>")
  debug_1209:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1434_done
    goto rxscan1434_scan
  rxscan1434_loop:
    (rx1430_pos) = rx1430_cur."from"()
    inc rx1430_pos
    rx1430_cur."!cursor_from"(rx1430_pos)
    ge rx1430_pos, rx1430_eos, rxscan1434_done
  rxscan1434_scan:
    set_addr $I10, rxscan1434_loop
    rx1430_cur."!mark_push"(0, rx1430_pos, $I10)
  rxscan1434_done:
.annotate 'line', 651
  # rx subcapture "sym"
    set_addr $I10, rxcap_1435_fail
    rx1430_cur."!mark_push"(0, rx1430_pos, $I10)
  # rx literal  "++"
    add $I11, rx1430_pos, 2
    gt $I11, rx1430_eos, rx1430_fail
    sub $I11, rx1430_pos, rx1430_off
    substr $S10, rx1430_tgt, $I11, 2
    ne $S10, "++", rx1430_fail
    add rx1430_pos, 2
    set_addr $I10, rxcap_1435_fail
    ($I12, $I11) = rx1430_cur."!mark_peek"($I10)
    rx1430_cur."!cursor_pos"($I11)
    ($P10) = rx1430_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1430_pos, "")
    rx1430_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1435_done
  rxcap_1435_fail:
    goto rx1430_fail
  rxcap_1435_done:
  # rx subrule "O" subtype=capture negate=
    rx1430_cur."!cursor_pos"(rx1430_pos)
    $P10 = rx1430_cur."O"("%autoincrement, :pirop<inc>")
    unless $P10, rx1430_fail
    rx1430_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1430_pos = $P10."pos"()
  # rx pass
    rx1430_cur."!cursor_pass"(rx1430_pos, "prefix:sym<++>")
    if_null rx1430_debug, debug_1210
    rx1430_cur."!cursor_debug"("PASS", "prefix:sym<++>", " at pos=", rx1430_pos)
  debug_1210:
    .return (rx1430_cur)
  rx1430_restart:
.annotate 'line', 10
    if_null rx1430_debug, debug_1211
    rx1430_cur."!cursor_debug"("NEXT", "prefix:sym<++>")
  debug_1211:
  rx1430_fail:
    (rx1430_rep, rx1430_pos, $I10, $P10) = rx1430_cur."!mark_fail"(0)
    lt rx1430_pos, -1, rx1430_done
    eq rx1430_pos, -1, rx1430_fail
    jump $I10
  rx1430_done:
    rx1430_cur."!cursor_fail"()
    if_null rx1430_debug, debug_1212
    rx1430_cur."!cursor_debug"("FAIL", "prefix:sym<++>")
  debug_1212:
    .return (rx1430_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<++>"  :nsentry("!PREFIX__prefix:sym<++>") :subid("288_1303401201.841") :method
.annotate 'line', 10
    $P1432 = self."!PREFIX__!subrule"("O", "++")
    new $P1433, "ResizablePMCArray"
    push $P1433, $P1432
    .return ($P1433)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<-->"  :subid("289_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1437_tgt
    .local int rx1437_pos
    .local int rx1437_off
    .local int rx1437_eos
    .local int rx1437_rep
    .local pmc rx1437_cur
    .local pmc rx1437_debug
    (rx1437_cur, rx1437_pos, rx1437_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1437_cur
    .local pmc match
    .lex "$/", match
    length rx1437_eos, rx1437_tgt
    gt rx1437_pos, rx1437_eos, rx1437_done
    set rx1437_off, 0
    lt rx1437_pos, 2, rx1437_start
    sub rx1437_off, rx1437_pos, 1
    substr rx1437_tgt, rx1437_tgt, rx1437_off
  rx1437_start:
    eq $I10, 1, rx1437_restart
    if_null rx1437_debug, debug_1213
    rx1437_cur."!cursor_debug"("START", "prefix:sym<-->")
  debug_1213:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1441_done
    goto rxscan1441_scan
  rxscan1441_loop:
    (rx1437_pos) = rx1437_cur."from"()
    inc rx1437_pos
    rx1437_cur."!cursor_from"(rx1437_pos)
    ge rx1437_pos, rx1437_eos, rxscan1441_done
  rxscan1441_scan:
    set_addr $I10, rxscan1441_loop
    rx1437_cur."!mark_push"(0, rx1437_pos, $I10)
  rxscan1441_done:
.annotate 'line', 652
  # rx subcapture "sym"
    set_addr $I10, rxcap_1442_fail
    rx1437_cur."!mark_push"(0, rx1437_pos, $I10)
  # rx literal  "--"
    add $I11, rx1437_pos, 2
    gt $I11, rx1437_eos, rx1437_fail
    sub $I11, rx1437_pos, rx1437_off
    substr $S10, rx1437_tgt, $I11, 2
    ne $S10, "--", rx1437_fail
    add rx1437_pos, 2
    set_addr $I10, rxcap_1442_fail
    ($I12, $I11) = rx1437_cur."!mark_peek"($I10)
    rx1437_cur."!cursor_pos"($I11)
    ($P10) = rx1437_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1437_pos, "")
    rx1437_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1442_done
  rxcap_1442_fail:
    goto rx1437_fail
  rxcap_1442_done:
  # rx subrule "O" subtype=capture negate=
    rx1437_cur."!cursor_pos"(rx1437_pos)
    $P10 = rx1437_cur."O"("%autoincrement, :pirop<dec>")
    unless $P10, rx1437_fail
    rx1437_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1437_pos = $P10."pos"()
  # rx pass
    rx1437_cur."!cursor_pass"(rx1437_pos, "prefix:sym<-->")
    if_null rx1437_debug, debug_1214
    rx1437_cur."!cursor_debug"("PASS", "prefix:sym<-->", " at pos=", rx1437_pos)
  debug_1214:
    .return (rx1437_cur)
  rx1437_restart:
.annotate 'line', 10
    if_null rx1437_debug, debug_1215
    rx1437_cur."!cursor_debug"("NEXT", "prefix:sym<-->")
  debug_1215:
  rx1437_fail:
    (rx1437_rep, rx1437_pos, $I10, $P10) = rx1437_cur."!mark_fail"(0)
    lt rx1437_pos, -1, rx1437_done
    eq rx1437_pos, -1, rx1437_fail
    jump $I10
  rx1437_done:
    rx1437_cur."!cursor_fail"()
    if_null rx1437_debug, debug_1216
    rx1437_cur."!cursor_debug"("FAIL", "prefix:sym<-->")
  debug_1216:
    .return (rx1437_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<-->"  :nsentry("!PREFIX__prefix:sym<-->") :subid("290_1303401201.841") :method
.annotate 'line', 10
    $P1439 = self."!PREFIX__!subrule"("O", "--")
    new $P1440, "ResizablePMCArray"
    push $P1440, $P1439
    .return ($P1440)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<++>"  :subid("291_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1444_tgt
    .local int rx1444_pos
    .local int rx1444_off
    .local int rx1444_eos
    .local int rx1444_rep
    .local pmc rx1444_cur
    .local pmc rx1444_debug
    (rx1444_cur, rx1444_pos, rx1444_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1444_cur
    .local pmc match
    .lex "$/", match
    length rx1444_eos, rx1444_tgt
    gt rx1444_pos, rx1444_eos, rx1444_done
    set rx1444_off, 0
    lt rx1444_pos, 2, rx1444_start
    sub rx1444_off, rx1444_pos, 1
    substr rx1444_tgt, rx1444_tgt, rx1444_off
  rx1444_start:
    eq $I10, 1, rx1444_restart
    if_null rx1444_debug, debug_1217
    rx1444_cur."!cursor_debug"("START", "postfix:sym<++>")
  debug_1217:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1448_done
    goto rxscan1448_scan
  rxscan1448_loop:
    (rx1444_pos) = rx1444_cur."from"()
    inc rx1444_pos
    rx1444_cur."!cursor_from"(rx1444_pos)
    ge rx1444_pos, rx1444_eos, rxscan1448_done
  rxscan1448_scan:
    set_addr $I10, rxscan1448_loop
    rx1444_cur."!mark_push"(0, rx1444_pos, $I10)
  rxscan1448_done:
.annotate 'line', 655
  # rx subcapture "sym"
    set_addr $I10, rxcap_1449_fail
    rx1444_cur."!mark_push"(0, rx1444_pos, $I10)
  # rx literal  "++"
    add $I11, rx1444_pos, 2
    gt $I11, rx1444_eos, rx1444_fail
    sub $I11, rx1444_pos, rx1444_off
    substr $S10, rx1444_tgt, $I11, 2
    ne $S10, "++", rx1444_fail
    add rx1444_pos, 2
    set_addr $I10, rxcap_1449_fail
    ($I12, $I11) = rx1444_cur."!mark_peek"($I10)
    rx1444_cur."!cursor_pos"($I11)
    ($P10) = rx1444_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1444_pos, "")
    rx1444_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1449_done
  rxcap_1449_fail:
    goto rx1444_fail
  rxcap_1449_done:
  # rx subrule "O" subtype=capture negate=
    rx1444_cur."!cursor_pos"(rx1444_pos)
    $P10 = rx1444_cur."O"("%autoincrement")
    unless $P10, rx1444_fail
    rx1444_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1444_pos = $P10."pos"()
  # rx pass
    rx1444_cur."!cursor_pass"(rx1444_pos, "postfix:sym<++>")
    if_null rx1444_debug, debug_1218
    rx1444_cur."!cursor_debug"("PASS", "postfix:sym<++>", " at pos=", rx1444_pos)
  debug_1218:
    .return (rx1444_cur)
  rx1444_restart:
.annotate 'line', 10
    if_null rx1444_debug, debug_1219
    rx1444_cur."!cursor_debug"("NEXT", "postfix:sym<++>")
  debug_1219:
  rx1444_fail:
    (rx1444_rep, rx1444_pos, $I10, $P10) = rx1444_cur."!mark_fail"(0)
    lt rx1444_pos, -1, rx1444_done
    eq rx1444_pos, -1, rx1444_fail
    jump $I10
  rx1444_done:
    rx1444_cur."!cursor_fail"()
    if_null rx1444_debug, debug_1220
    rx1444_cur."!cursor_debug"("FAIL", "postfix:sym<++>")
  debug_1220:
    .return (rx1444_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<++>"  :nsentry("!PREFIX__postfix:sym<++>") :subid("292_1303401201.841") :method
.annotate 'line', 10
    $P1446 = self."!PREFIX__!subrule"("O", "++")
    new $P1447, "ResizablePMCArray"
    push $P1447, $P1446
    .return ($P1447)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<-->"  :subid("293_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1451_tgt
    .local int rx1451_pos
    .local int rx1451_off
    .local int rx1451_eos
    .local int rx1451_rep
    .local pmc rx1451_cur
    .local pmc rx1451_debug
    (rx1451_cur, rx1451_pos, rx1451_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1451_cur
    .local pmc match
    .lex "$/", match
    length rx1451_eos, rx1451_tgt
    gt rx1451_pos, rx1451_eos, rx1451_done
    set rx1451_off, 0
    lt rx1451_pos, 2, rx1451_start
    sub rx1451_off, rx1451_pos, 1
    substr rx1451_tgt, rx1451_tgt, rx1451_off
  rx1451_start:
    eq $I10, 1, rx1451_restart
    if_null rx1451_debug, debug_1221
    rx1451_cur."!cursor_debug"("START", "postfix:sym<-->")
  debug_1221:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1455_done
    goto rxscan1455_scan
  rxscan1455_loop:
    (rx1451_pos) = rx1451_cur."from"()
    inc rx1451_pos
    rx1451_cur."!cursor_from"(rx1451_pos)
    ge rx1451_pos, rx1451_eos, rxscan1455_done
  rxscan1455_scan:
    set_addr $I10, rxscan1455_loop
    rx1451_cur."!mark_push"(0, rx1451_pos, $I10)
  rxscan1455_done:
.annotate 'line', 656
  # rx subcapture "sym"
    set_addr $I10, rxcap_1456_fail
    rx1451_cur."!mark_push"(0, rx1451_pos, $I10)
  # rx literal  "--"
    add $I11, rx1451_pos, 2
    gt $I11, rx1451_eos, rx1451_fail
    sub $I11, rx1451_pos, rx1451_off
    substr $S10, rx1451_tgt, $I11, 2
    ne $S10, "--", rx1451_fail
    add rx1451_pos, 2
    set_addr $I10, rxcap_1456_fail
    ($I12, $I11) = rx1451_cur."!mark_peek"($I10)
    rx1451_cur."!cursor_pos"($I11)
    ($P10) = rx1451_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1451_pos, "")
    rx1451_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1456_done
  rxcap_1456_fail:
    goto rx1451_fail
  rxcap_1456_done:
  # rx subrule "O" subtype=capture negate=
    rx1451_cur."!cursor_pos"(rx1451_pos)
    $P10 = rx1451_cur."O"("%autoincrement")
    unless $P10, rx1451_fail
    rx1451_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1451_pos = $P10."pos"()
  # rx pass
    rx1451_cur."!cursor_pass"(rx1451_pos, "postfix:sym<-->")
    if_null rx1451_debug, debug_1222
    rx1451_cur."!cursor_debug"("PASS", "postfix:sym<-->", " at pos=", rx1451_pos)
  debug_1222:
    .return (rx1451_cur)
  rx1451_restart:
.annotate 'line', 10
    if_null rx1451_debug, debug_1223
    rx1451_cur."!cursor_debug"("NEXT", "postfix:sym<-->")
  debug_1223:
  rx1451_fail:
    (rx1451_rep, rx1451_pos, $I10, $P10) = rx1451_cur."!mark_fail"(0)
    lt rx1451_pos, -1, rx1451_done
    eq rx1451_pos, -1, rx1451_fail
    jump $I10
  rx1451_done:
    rx1451_cur."!cursor_fail"()
    if_null rx1451_debug, debug_1224
    rx1451_cur."!cursor_debug"("FAIL", "postfix:sym<-->")
  debug_1224:
    .return (rx1451_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<-->"  :nsentry("!PREFIX__postfix:sym<-->") :subid("294_1303401201.841") :method
.annotate 'line', 10
    $P1453 = self."!PREFIX__!subrule"("O", "--")
    new $P1454, "ResizablePMCArray"
    push $P1454, $P1453
    .return ($P1454)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<**>"  :subid("295_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1458_tgt
    .local int rx1458_pos
    .local int rx1458_off
    .local int rx1458_eos
    .local int rx1458_rep
    .local pmc rx1458_cur
    .local pmc rx1458_debug
    (rx1458_cur, rx1458_pos, rx1458_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1458_cur
    .local pmc match
    .lex "$/", match
    length rx1458_eos, rx1458_tgt
    gt rx1458_pos, rx1458_eos, rx1458_done
    set rx1458_off, 0
    lt rx1458_pos, 2, rx1458_start
    sub rx1458_off, rx1458_pos, 1
    substr rx1458_tgt, rx1458_tgt, rx1458_off
  rx1458_start:
    eq $I10, 1, rx1458_restart
    if_null rx1458_debug, debug_1225
    rx1458_cur."!cursor_debug"("START", "infix:sym<**>")
  debug_1225:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1462_done
    goto rxscan1462_scan
  rxscan1462_loop:
    (rx1458_pos) = rx1458_cur."from"()
    inc rx1458_pos
    rx1458_cur."!cursor_from"(rx1458_pos)
    ge rx1458_pos, rx1458_eos, rxscan1462_done
  rxscan1462_scan:
    set_addr $I10, rxscan1462_loop
    rx1458_cur."!mark_push"(0, rx1458_pos, $I10)
  rxscan1462_done:
.annotate 'line', 658
  # rx subcapture "sym"
    set_addr $I10, rxcap_1463_fail
    rx1458_cur."!mark_push"(0, rx1458_pos, $I10)
  # rx literal  "**"
    add $I11, rx1458_pos, 2
    gt $I11, rx1458_eos, rx1458_fail
    sub $I11, rx1458_pos, rx1458_off
    substr $S10, rx1458_tgt, $I11, 2
    ne $S10, "**", rx1458_fail
    add rx1458_pos, 2
    set_addr $I10, rxcap_1463_fail
    ($I12, $I11) = rx1458_cur."!mark_peek"($I10)
    rx1458_cur."!cursor_pos"($I11)
    ($P10) = rx1458_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1458_pos, "")
    rx1458_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1463_done
  rxcap_1463_fail:
    goto rx1458_fail
  rxcap_1463_done:
  # rx subrule "O" subtype=capture negate=
    rx1458_cur."!cursor_pos"(rx1458_pos)
    $P10 = rx1458_cur."O"("%exponentiation, :pirop<pow>")
    unless $P10, rx1458_fail
    rx1458_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1458_pos = $P10."pos"()
  # rx pass
    rx1458_cur."!cursor_pass"(rx1458_pos, "infix:sym<**>")
    if_null rx1458_debug, debug_1226
    rx1458_cur."!cursor_debug"("PASS", "infix:sym<**>", " at pos=", rx1458_pos)
  debug_1226:
    .return (rx1458_cur)
  rx1458_restart:
.annotate 'line', 10
    if_null rx1458_debug, debug_1227
    rx1458_cur."!cursor_debug"("NEXT", "infix:sym<**>")
  debug_1227:
  rx1458_fail:
    (rx1458_rep, rx1458_pos, $I10, $P10) = rx1458_cur."!mark_fail"(0)
    lt rx1458_pos, -1, rx1458_done
    eq rx1458_pos, -1, rx1458_fail
    jump $I10
  rx1458_done:
    rx1458_cur."!cursor_fail"()
    if_null rx1458_debug, debug_1228
    rx1458_cur."!cursor_debug"("FAIL", "infix:sym<**>")
  debug_1228:
    .return (rx1458_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<**>"  :nsentry("!PREFIX__infix:sym<**>") :subid("296_1303401201.841") :method
.annotate 'line', 10
    $P1460 = self."!PREFIX__!subrule"("O", "**")
    new $P1461, "ResizablePMCArray"
    push $P1461, $P1460
    .return ($P1461)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<+>"  :subid("297_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1465_tgt
    .local int rx1465_pos
    .local int rx1465_off
    .local int rx1465_eos
    .local int rx1465_rep
    .local pmc rx1465_cur
    .local pmc rx1465_debug
    (rx1465_cur, rx1465_pos, rx1465_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1465_cur
    .local pmc match
    .lex "$/", match
    length rx1465_eos, rx1465_tgt
    gt rx1465_pos, rx1465_eos, rx1465_done
    set rx1465_off, 0
    lt rx1465_pos, 2, rx1465_start
    sub rx1465_off, rx1465_pos, 1
    substr rx1465_tgt, rx1465_tgt, rx1465_off
  rx1465_start:
    eq $I10, 1, rx1465_restart
    if_null rx1465_debug, debug_1229
    rx1465_cur."!cursor_debug"("START", "prefix:sym<+>")
  debug_1229:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1469_done
    goto rxscan1469_scan
  rxscan1469_loop:
    (rx1465_pos) = rx1465_cur."from"()
    inc rx1465_pos
    rx1465_cur."!cursor_from"(rx1465_pos)
    ge rx1465_pos, rx1465_eos, rxscan1469_done
  rxscan1469_scan:
    set_addr $I10, rxscan1469_loop
    rx1465_cur."!mark_push"(0, rx1465_pos, $I10)
  rxscan1469_done:
.annotate 'line', 660
  # rx subcapture "sym"
    set_addr $I10, rxcap_1470_fail
    rx1465_cur."!mark_push"(0, rx1465_pos, $I10)
  # rx literal  "+"
    add $I11, rx1465_pos, 1
    gt $I11, rx1465_eos, rx1465_fail
    sub $I11, rx1465_pos, rx1465_off
    ord $I11, rx1465_tgt, $I11
    ne $I11, 43, rx1465_fail
    add rx1465_pos, 1
    set_addr $I10, rxcap_1470_fail
    ($I12, $I11) = rx1465_cur."!mark_peek"($I10)
    rx1465_cur."!cursor_pos"($I11)
    ($P10) = rx1465_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1465_pos, "")
    rx1465_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1470_done
  rxcap_1470_fail:
    goto rx1465_fail
  rxcap_1470_done:
  # rx subrule "O" subtype=capture negate=
    rx1465_cur."!cursor_pos"(rx1465_pos)
    $P10 = rx1465_cur."O"("%symbolic_unary, :pirop<set N*>")
    unless $P10, rx1465_fail
    rx1465_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1465_pos = $P10."pos"()
  # rx pass
    rx1465_cur."!cursor_pass"(rx1465_pos, "prefix:sym<+>")
    if_null rx1465_debug, debug_1230
    rx1465_cur."!cursor_debug"("PASS", "prefix:sym<+>", " at pos=", rx1465_pos)
  debug_1230:
    .return (rx1465_cur)
  rx1465_restart:
.annotate 'line', 10
    if_null rx1465_debug, debug_1231
    rx1465_cur."!cursor_debug"("NEXT", "prefix:sym<+>")
  debug_1231:
  rx1465_fail:
    (rx1465_rep, rx1465_pos, $I10, $P10) = rx1465_cur."!mark_fail"(0)
    lt rx1465_pos, -1, rx1465_done
    eq rx1465_pos, -1, rx1465_fail
    jump $I10
  rx1465_done:
    rx1465_cur."!cursor_fail"()
    if_null rx1465_debug, debug_1232
    rx1465_cur."!cursor_debug"("FAIL", "prefix:sym<+>")
  debug_1232:
    .return (rx1465_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<+>"  :nsentry("!PREFIX__prefix:sym<+>") :subid("298_1303401201.841") :method
.annotate 'line', 10
    $P1467 = self."!PREFIX__!subrule"("O", "+")
    new $P1468, "ResizablePMCArray"
    push $P1468, $P1467
    .return ($P1468)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<~>"  :subid("299_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1472_tgt
    .local int rx1472_pos
    .local int rx1472_off
    .local int rx1472_eos
    .local int rx1472_rep
    .local pmc rx1472_cur
    .local pmc rx1472_debug
    (rx1472_cur, rx1472_pos, rx1472_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1472_cur
    .local pmc match
    .lex "$/", match
    length rx1472_eos, rx1472_tgt
    gt rx1472_pos, rx1472_eos, rx1472_done
    set rx1472_off, 0
    lt rx1472_pos, 2, rx1472_start
    sub rx1472_off, rx1472_pos, 1
    substr rx1472_tgt, rx1472_tgt, rx1472_off
  rx1472_start:
    eq $I10, 1, rx1472_restart
    if_null rx1472_debug, debug_1233
    rx1472_cur."!cursor_debug"("START", "prefix:sym<~>")
  debug_1233:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1476_done
    goto rxscan1476_scan
  rxscan1476_loop:
    (rx1472_pos) = rx1472_cur."from"()
    inc rx1472_pos
    rx1472_cur."!cursor_from"(rx1472_pos)
    ge rx1472_pos, rx1472_eos, rxscan1476_done
  rxscan1476_scan:
    set_addr $I10, rxscan1476_loop
    rx1472_cur."!mark_push"(0, rx1472_pos, $I10)
  rxscan1476_done:
.annotate 'line', 661
  # rx subcapture "sym"
    set_addr $I10, rxcap_1477_fail
    rx1472_cur."!mark_push"(0, rx1472_pos, $I10)
  # rx literal  "~"
    add $I11, rx1472_pos, 1
    gt $I11, rx1472_eos, rx1472_fail
    sub $I11, rx1472_pos, rx1472_off
    ord $I11, rx1472_tgt, $I11
    ne $I11, 126, rx1472_fail
    add rx1472_pos, 1
    set_addr $I10, rxcap_1477_fail
    ($I12, $I11) = rx1472_cur."!mark_peek"($I10)
    rx1472_cur."!cursor_pos"($I11)
    ($P10) = rx1472_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1472_pos, "")
    rx1472_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1477_done
  rxcap_1477_fail:
    goto rx1472_fail
  rxcap_1477_done:
  # rx subrule "O" subtype=capture negate=
    rx1472_cur."!cursor_pos"(rx1472_pos)
    $P10 = rx1472_cur."O"("%symbolic_unary, :pirop<set S*>")
    unless $P10, rx1472_fail
    rx1472_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1472_pos = $P10."pos"()
  # rx pass
    rx1472_cur."!cursor_pass"(rx1472_pos, "prefix:sym<~>")
    if_null rx1472_debug, debug_1234
    rx1472_cur."!cursor_debug"("PASS", "prefix:sym<~>", " at pos=", rx1472_pos)
  debug_1234:
    .return (rx1472_cur)
  rx1472_restart:
.annotate 'line', 10
    if_null rx1472_debug, debug_1235
    rx1472_cur."!cursor_debug"("NEXT", "prefix:sym<~>")
  debug_1235:
  rx1472_fail:
    (rx1472_rep, rx1472_pos, $I10, $P10) = rx1472_cur."!mark_fail"(0)
    lt rx1472_pos, -1, rx1472_done
    eq rx1472_pos, -1, rx1472_fail
    jump $I10
  rx1472_done:
    rx1472_cur."!cursor_fail"()
    if_null rx1472_debug, debug_1236
    rx1472_cur."!cursor_debug"("FAIL", "prefix:sym<~>")
  debug_1236:
    .return (rx1472_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<~>"  :nsentry("!PREFIX__prefix:sym<~>") :subid("300_1303401201.841") :method
.annotate 'line', 10
    $P1474 = self."!PREFIX__!subrule"("O", "~")
    new $P1475, "ResizablePMCArray"
    push $P1475, $P1474
    .return ($P1475)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<->"  :subid("301_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1479_tgt
    .local int rx1479_pos
    .local int rx1479_off
    .local int rx1479_eos
    .local int rx1479_rep
    .local pmc rx1479_cur
    .local pmc rx1479_debug
    (rx1479_cur, rx1479_pos, rx1479_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1479_cur
    .local pmc match
    .lex "$/", match
    length rx1479_eos, rx1479_tgt
    gt rx1479_pos, rx1479_eos, rx1479_done
    set rx1479_off, 0
    lt rx1479_pos, 2, rx1479_start
    sub rx1479_off, rx1479_pos, 1
    substr rx1479_tgt, rx1479_tgt, rx1479_off
  rx1479_start:
    eq $I10, 1, rx1479_restart
    if_null rx1479_debug, debug_1237
    rx1479_cur."!cursor_debug"("START", "prefix:sym<->")
  debug_1237:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1482_done
    goto rxscan1482_scan
  rxscan1482_loop:
    (rx1479_pos) = rx1479_cur."from"()
    inc rx1479_pos
    rx1479_cur."!cursor_from"(rx1479_pos)
    ge rx1479_pos, rx1479_eos, rxscan1482_done
  rxscan1482_scan:
    set_addr $I10, rxscan1482_loop
    rx1479_cur."!mark_push"(0, rx1479_pos, $I10)
  rxscan1482_done:
.annotate 'line', 662
  # rx subcapture "sym"
    set_addr $I10, rxcap_1483_fail
    rx1479_cur."!mark_push"(0, rx1479_pos, $I10)
  # rx literal  "-"
    add $I11, rx1479_pos, 1
    gt $I11, rx1479_eos, rx1479_fail
    sub $I11, rx1479_pos, rx1479_off
    ord $I11, rx1479_tgt, $I11
    ne $I11, 45, rx1479_fail
    add rx1479_pos, 1
    set_addr $I10, rxcap_1483_fail
    ($I12, $I11) = rx1479_cur."!mark_peek"($I10)
    rx1479_cur."!cursor_pos"($I11)
    ($P10) = rx1479_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1479_pos, "")
    rx1479_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1483_done
  rxcap_1483_fail:
    goto rx1479_fail
  rxcap_1483_done:
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1479_pos, rx1479_off
    substr $S10, rx1479_tgt, $I10, 1
    index $I11, ">", $S10
    ge $I11, 0, rx1479_fail
  # rx subrule "number" subtype=zerowidth negate=1
    rx1479_cur."!cursor_pos"(rx1479_pos)
    $P10 = rx1479_cur."number"()
    if $P10, rx1479_fail
  # rx subrule "O" subtype=capture negate=
    rx1479_cur."!cursor_pos"(rx1479_pos)
    $P10 = rx1479_cur."O"("%symbolic_unary, :pirop<neg>")
    unless $P10, rx1479_fail
    rx1479_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1479_pos = $P10."pos"()
  # rx pass
    rx1479_cur."!cursor_pass"(rx1479_pos, "prefix:sym<->")
    if_null rx1479_debug, debug_1238
    rx1479_cur."!cursor_debug"("PASS", "prefix:sym<->", " at pos=", rx1479_pos)
  debug_1238:
    .return (rx1479_cur)
  rx1479_restart:
.annotate 'line', 10
    if_null rx1479_debug, debug_1239
    rx1479_cur."!cursor_debug"("NEXT", "prefix:sym<->")
  debug_1239:
  rx1479_fail:
    (rx1479_rep, rx1479_pos, $I10, $P10) = rx1479_cur."!mark_fail"(0)
    lt rx1479_pos, -1, rx1479_done
    eq rx1479_pos, -1, rx1479_fail
    jump $I10
  rx1479_done:
    rx1479_cur."!cursor_fail"()
    if_null rx1479_debug, debug_1240
    rx1479_cur."!cursor_debug"("FAIL", "prefix:sym<->")
  debug_1240:
    .return (rx1479_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<->"  :nsentry("!PREFIX__prefix:sym<->") :subid("302_1303401201.841") :method
.annotate 'line', 10
    new $P1481, "ResizablePMCArray"
    push $P1481, "-"
    .return ($P1481)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<?>"  :subid("303_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1485_tgt
    .local int rx1485_pos
    .local int rx1485_off
    .local int rx1485_eos
    .local int rx1485_rep
    .local pmc rx1485_cur
    .local pmc rx1485_debug
    (rx1485_cur, rx1485_pos, rx1485_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1485_cur
    .local pmc match
    .lex "$/", match
    length rx1485_eos, rx1485_tgt
    gt rx1485_pos, rx1485_eos, rx1485_done
    set rx1485_off, 0
    lt rx1485_pos, 2, rx1485_start
    sub rx1485_off, rx1485_pos, 1
    substr rx1485_tgt, rx1485_tgt, rx1485_off
  rx1485_start:
    eq $I10, 1, rx1485_restart
    if_null rx1485_debug, debug_1241
    rx1485_cur."!cursor_debug"("START", "prefix:sym<?>")
  debug_1241:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1489_done
    goto rxscan1489_scan
  rxscan1489_loop:
    (rx1485_pos) = rx1485_cur."from"()
    inc rx1485_pos
    rx1485_cur."!cursor_from"(rx1485_pos)
    ge rx1485_pos, rx1485_eos, rxscan1489_done
  rxscan1489_scan:
    set_addr $I10, rxscan1489_loop
    rx1485_cur."!mark_push"(0, rx1485_pos, $I10)
  rxscan1489_done:
.annotate 'line', 663
  # rx subcapture "sym"
    set_addr $I10, rxcap_1490_fail
    rx1485_cur."!mark_push"(0, rx1485_pos, $I10)
  # rx literal  "?"
    add $I11, rx1485_pos, 1
    gt $I11, rx1485_eos, rx1485_fail
    sub $I11, rx1485_pos, rx1485_off
    ord $I11, rx1485_tgt, $I11
    ne $I11, 63, rx1485_fail
    add rx1485_pos, 1
    set_addr $I10, rxcap_1490_fail
    ($I12, $I11) = rx1485_cur."!mark_peek"($I10)
    rx1485_cur."!cursor_pos"($I11)
    ($P10) = rx1485_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1485_pos, "")
    rx1485_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1490_done
  rxcap_1490_fail:
    goto rx1485_fail
  rxcap_1490_done:
  # rx subrule "O" subtype=capture negate=
    rx1485_cur."!cursor_pos"(rx1485_pos)
    $P10 = rx1485_cur."O"("%symbolic_unary, :pirop<istrue>")
    unless $P10, rx1485_fail
    rx1485_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1485_pos = $P10."pos"()
  # rx pass
    rx1485_cur."!cursor_pass"(rx1485_pos, "prefix:sym<?>")
    if_null rx1485_debug, debug_1242
    rx1485_cur."!cursor_debug"("PASS", "prefix:sym<?>", " at pos=", rx1485_pos)
  debug_1242:
    .return (rx1485_cur)
  rx1485_restart:
.annotate 'line', 10
    if_null rx1485_debug, debug_1243
    rx1485_cur."!cursor_debug"("NEXT", "prefix:sym<?>")
  debug_1243:
  rx1485_fail:
    (rx1485_rep, rx1485_pos, $I10, $P10) = rx1485_cur."!mark_fail"(0)
    lt rx1485_pos, -1, rx1485_done
    eq rx1485_pos, -1, rx1485_fail
    jump $I10
  rx1485_done:
    rx1485_cur."!cursor_fail"()
    if_null rx1485_debug, debug_1244
    rx1485_cur."!cursor_debug"("FAIL", "prefix:sym<?>")
  debug_1244:
    .return (rx1485_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<?>"  :nsentry("!PREFIX__prefix:sym<?>") :subid("304_1303401201.841") :method
.annotate 'line', 10
    $P1487 = self."!PREFIX__!subrule"("O", "?")
    new $P1488, "ResizablePMCArray"
    push $P1488, $P1487
    .return ($P1488)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<!>"  :subid("305_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1492_tgt
    .local int rx1492_pos
    .local int rx1492_off
    .local int rx1492_eos
    .local int rx1492_rep
    .local pmc rx1492_cur
    .local pmc rx1492_debug
    (rx1492_cur, rx1492_pos, rx1492_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1492_cur
    .local pmc match
    .lex "$/", match
    length rx1492_eos, rx1492_tgt
    gt rx1492_pos, rx1492_eos, rx1492_done
    set rx1492_off, 0
    lt rx1492_pos, 2, rx1492_start
    sub rx1492_off, rx1492_pos, 1
    substr rx1492_tgt, rx1492_tgt, rx1492_off
  rx1492_start:
    eq $I10, 1, rx1492_restart
    if_null rx1492_debug, debug_1245
    rx1492_cur."!cursor_debug"("START", "prefix:sym<!>")
  debug_1245:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1496_done
    goto rxscan1496_scan
  rxscan1496_loop:
    (rx1492_pos) = rx1492_cur."from"()
    inc rx1492_pos
    rx1492_cur."!cursor_from"(rx1492_pos)
    ge rx1492_pos, rx1492_eos, rxscan1496_done
  rxscan1496_scan:
    set_addr $I10, rxscan1496_loop
    rx1492_cur."!mark_push"(0, rx1492_pos, $I10)
  rxscan1496_done:
.annotate 'line', 664
  # rx subcapture "sym"
    set_addr $I10, rxcap_1497_fail
    rx1492_cur."!mark_push"(0, rx1492_pos, $I10)
  # rx literal  "!"
    add $I11, rx1492_pos, 1
    gt $I11, rx1492_eos, rx1492_fail
    sub $I11, rx1492_pos, rx1492_off
    ord $I11, rx1492_tgt, $I11
    ne $I11, 33, rx1492_fail
    add rx1492_pos, 1
    set_addr $I10, rxcap_1497_fail
    ($I12, $I11) = rx1492_cur."!mark_peek"($I10)
    rx1492_cur."!cursor_pos"($I11)
    ($P10) = rx1492_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1492_pos, "")
    rx1492_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1497_done
  rxcap_1497_fail:
    goto rx1492_fail
  rxcap_1497_done:
  # rx subrule "O" subtype=capture negate=
    rx1492_cur."!cursor_pos"(rx1492_pos)
    $P10 = rx1492_cur."O"("%symbolic_unary, :pirop<isfalse>")
    unless $P10, rx1492_fail
    rx1492_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1492_pos = $P10."pos"()
  # rx pass
    rx1492_cur."!cursor_pass"(rx1492_pos, "prefix:sym<!>")
    if_null rx1492_debug, debug_1246
    rx1492_cur."!cursor_debug"("PASS", "prefix:sym<!>", " at pos=", rx1492_pos)
  debug_1246:
    .return (rx1492_cur)
  rx1492_restart:
.annotate 'line', 10
    if_null rx1492_debug, debug_1247
    rx1492_cur."!cursor_debug"("NEXT", "prefix:sym<!>")
  debug_1247:
  rx1492_fail:
    (rx1492_rep, rx1492_pos, $I10, $P10) = rx1492_cur."!mark_fail"(0)
    lt rx1492_pos, -1, rx1492_done
    eq rx1492_pos, -1, rx1492_fail
    jump $I10
  rx1492_done:
    rx1492_cur."!cursor_fail"()
    if_null rx1492_debug, debug_1248
    rx1492_cur."!cursor_debug"("FAIL", "prefix:sym<!>")
  debug_1248:
    .return (rx1492_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<!>"  :nsentry("!PREFIX__prefix:sym<!>") :subid("306_1303401201.841") :method
.annotate 'line', 10
    $P1494 = self."!PREFIX__!subrule"("O", "!")
    new $P1495, "ResizablePMCArray"
    push $P1495, $P1494
    .return ($P1495)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<|>"  :subid("307_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1499_tgt
    .local int rx1499_pos
    .local int rx1499_off
    .local int rx1499_eos
    .local int rx1499_rep
    .local pmc rx1499_cur
    .local pmc rx1499_debug
    (rx1499_cur, rx1499_pos, rx1499_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1499_cur
    .local pmc match
    .lex "$/", match
    length rx1499_eos, rx1499_tgt
    gt rx1499_pos, rx1499_eos, rx1499_done
    set rx1499_off, 0
    lt rx1499_pos, 2, rx1499_start
    sub rx1499_off, rx1499_pos, 1
    substr rx1499_tgt, rx1499_tgt, rx1499_off
  rx1499_start:
    eq $I10, 1, rx1499_restart
    if_null rx1499_debug, debug_1249
    rx1499_cur."!cursor_debug"("START", "prefix:sym<|>")
  debug_1249:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1503_done
    goto rxscan1503_scan
  rxscan1503_loop:
    (rx1499_pos) = rx1499_cur."from"()
    inc rx1499_pos
    rx1499_cur."!cursor_from"(rx1499_pos)
    ge rx1499_pos, rx1499_eos, rxscan1503_done
  rxscan1503_scan:
    set_addr $I10, rxscan1503_loop
    rx1499_cur."!mark_push"(0, rx1499_pos, $I10)
  rxscan1503_done:
.annotate 'line', 665
  # rx subcapture "sym"
    set_addr $I10, rxcap_1504_fail
    rx1499_cur."!mark_push"(0, rx1499_pos, $I10)
  # rx literal  "|"
    add $I11, rx1499_pos, 1
    gt $I11, rx1499_eos, rx1499_fail
    sub $I11, rx1499_pos, rx1499_off
    ord $I11, rx1499_tgt, $I11
    ne $I11, 124, rx1499_fail
    add rx1499_pos, 1
    set_addr $I10, rxcap_1504_fail
    ($I12, $I11) = rx1499_cur."!mark_peek"($I10)
    rx1499_cur."!cursor_pos"($I11)
    ($P10) = rx1499_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1499_pos, "")
    rx1499_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1504_done
  rxcap_1504_fail:
    goto rx1499_fail
  rxcap_1504_done:
  # rx subrule "O" subtype=capture negate=
    rx1499_cur."!cursor_pos"(rx1499_pos)
    $P10 = rx1499_cur."O"("%symbolic_unary")
    unless $P10, rx1499_fail
    rx1499_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1499_pos = $P10."pos"()
  # rx pass
    rx1499_cur."!cursor_pass"(rx1499_pos, "prefix:sym<|>")
    if_null rx1499_debug, debug_1250
    rx1499_cur."!cursor_debug"("PASS", "prefix:sym<|>", " at pos=", rx1499_pos)
  debug_1250:
    .return (rx1499_cur)
  rx1499_restart:
.annotate 'line', 10
    if_null rx1499_debug, debug_1251
    rx1499_cur."!cursor_debug"("NEXT", "prefix:sym<|>")
  debug_1251:
  rx1499_fail:
    (rx1499_rep, rx1499_pos, $I10, $P10) = rx1499_cur."!mark_fail"(0)
    lt rx1499_pos, -1, rx1499_done
    eq rx1499_pos, -1, rx1499_fail
    jump $I10
  rx1499_done:
    rx1499_cur."!cursor_fail"()
    if_null rx1499_debug, debug_1252
    rx1499_cur."!cursor_debug"("FAIL", "prefix:sym<|>")
  debug_1252:
    .return (rx1499_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<|>"  :nsentry("!PREFIX__prefix:sym<|>") :subid("308_1303401201.841") :method
.annotate 'line', 10
    $P1501 = self."!PREFIX__!subrule"("O", "|")
    new $P1502, "ResizablePMCArray"
    push $P1502, $P1501
    .return ($P1502)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<*>"  :subid("309_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1506_tgt
    .local int rx1506_pos
    .local int rx1506_off
    .local int rx1506_eos
    .local int rx1506_rep
    .local pmc rx1506_cur
    .local pmc rx1506_debug
    (rx1506_cur, rx1506_pos, rx1506_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1506_cur
    .local pmc match
    .lex "$/", match
    length rx1506_eos, rx1506_tgt
    gt rx1506_pos, rx1506_eos, rx1506_done
    set rx1506_off, 0
    lt rx1506_pos, 2, rx1506_start
    sub rx1506_off, rx1506_pos, 1
    substr rx1506_tgt, rx1506_tgt, rx1506_off
  rx1506_start:
    eq $I10, 1, rx1506_restart
    if_null rx1506_debug, debug_1253
    rx1506_cur."!cursor_debug"("START", "infix:sym<*>")
  debug_1253:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1510_done
    goto rxscan1510_scan
  rxscan1510_loop:
    (rx1506_pos) = rx1506_cur."from"()
    inc rx1506_pos
    rx1506_cur."!cursor_from"(rx1506_pos)
    ge rx1506_pos, rx1506_eos, rxscan1510_done
  rxscan1510_scan:
    set_addr $I10, rxscan1510_loop
    rx1506_cur."!mark_push"(0, rx1506_pos, $I10)
  rxscan1510_done:
.annotate 'line', 667
  # rx subcapture "sym"
    set_addr $I10, rxcap_1511_fail
    rx1506_cur."!mark_push"(0, rx1506_pos, $I10)
  # rx literal  "*"
    add $I11, rx1506_pos, 1
    gt $I11, rx1506_eos, rx1506_fail
    sub $I11, rx1506_pos, rx1506_off
    ord $I11, rx1506_tgt, $I11
    ne $I11, 42, rx1506_fail
    add rx1506_pos, 1
    set_addr $I10, rxcap_1511_fail
    ($I12, $I11) = rx1506_cur."!mark_peek"($I10)
    rx1506_cur."!cursor_pos"($I11)
    ($P10) = rx1506_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1506_pos, "")
    rx1506_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1511_done
  rxcap_1511_fail:
    goto rx1506_fail
  rxcap_1511_done:
  # rx subrule "O" subtype=capture negate=
    rx1506_cur."!cursor_pos"(rx1506_pos)
    $P10 = rx1506_cur."O"("%multiplicative, :pirop<mul>")
    unless $P10, rx1506_fail
    rx1506_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1506_pos = $P10."pos"()
  # rx pass
    rx1506_cur."!cursor_pass"(rx1506_pos, "infix:sym<*>")
    if_null rx1506_debug, debug_1254
    rx1506_cur."!cursor_debug"("PASS", "infix:sym<*>", " at pos=", rx1506_pos)
  debug_1254:
    .return (rx1506_cur)
  rx1506_restart:
.annotate 'line', 10
    if_null rx1506_debug, debug_1255
    rx1506_cur."!cursor_debug"("NEXT", "infix:sym<*>")
  debug_1255:
  rx1506_fail:
    (rx1506_rep, rx1506_pos, $I10, $P10) = rx1506_cur."!mark_fail"(0)
    lt rx1506_pos, -1, rx1506_done
    eq rx1506_pos, -1, rx1506_fail
    jump $I10
  rx1506_done:
    rx1506_cur."!cursor_fail"()
    if_null rx1506_debug, debug_1256
    rx1506_cur."!cursor_debug"("FAIL", "infix:sym<*>")
  debug_1256:
    .return (rx1506_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<*>"  :nsentry("!PREFIX__infix:sym<*>") :subid("310_1303401201.841") :method
.annotate 'line', 10
    $P1508 = self."!PREFIX__!subrule"("O", "*")
    new $P1509, "ResizablePMCArray"
    push $P1509, $P1508
    .return ($P1509)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym</>"  :subid("311_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1513_tgt
    .local int rx1513_pos
    .local int rx1513_off
    .local int rx1513_eos
    .local int rx1513_rep
    .local pmc rx1513_cur
    .local pmc rx1513_debug
    (rx1513_cur, rx1513_pos, rx1513_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1513_cur
    .local pmc match
    .lex "$/", match
    length rx1513_eos, rx1513_tgt
    gt rx1513_pos, rx1513_eos, rx1513_done
    set rx1513_off, 0
    lt rx1513_pos, 2, rx1513_start
    sub rx1513_off, rx1513_pos, 1
    substr rx1513_tgt, rx1513_tgt, rx1513_off
  rx1513_start:
    eq $I10, 1, rx1513_restart
    if_null rx1513_debug, debug_1257
    rx1513_cur."!cursor_debug"("START", "infix:sym</>")
  debug_1257:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1517_done
    goto rxscan1517_scan
  rxscan1517_loop:
    (rx1513_pos) = rx1513_cur."from"()
    inc rx1513_pos
    rx1513_cur."!cursor_from"(rx1513_pos)
    ge rx1513_pos, rx1513_eos, rxscan1517_done
  rxscan1517_scan:
    set_addr $I10, rxscan1517_loop
    rx1513_cur."!mark_push"(0, rx1513_pos, $I10)
  rxscan1517_done:
.annotate 'line', 668
  # rx subcapture "sym"
    set_addr $I10, rxcap_1518_fail
    rx1513_cur."!mark_push"(0, rx1513_pos, $I10)
  # rx literal  "/"
    add $I11, rx1513_pos, 1
    gt $I11, rx1513_eos, rx1513_fail
    sub $I11, rx1513_pos, rx1513_off
    ord $I11, rx1513_tgt, $I11
    ne $I11, 47, rx1513_fail
    add rx1513_pos, 1
    set_addr $I10, rxcap_1518_fail
    ($I12, $I11) = rx1513_cur."!mark_peek"($I10)
    rx1513_cur."!cursor_pos"($I11)
    ($P10) = rx1513_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1513_pos, "")
    rx1513_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1518_done
  rxcap_1518_fail:
    goto rx1513_fail
  rxcap_1518_done:
  # rx subrule "O" subtype=capture negate=
    rx1513_cur."!cursor_pos"(rx1513_pos)
    $P10 = rx1513_cur."O"("%multiplicative, :pirop<div>")
    unless $P10, rx1513_fail
    rx1513_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1513_pos = $P10."pos"()
  # rx pass
    rx1513_cur."!cursor_pass"(rx1513_pos, "infix:sym</>")
    if_null rx1513_debug, debug_1258
    rx1513_cur."!cursor_debug"("PASS", "infix:sym</>", " at pos=", rx1513_pos)
  debug_1258:
    .return (rx1513_cur)
  rx1513_restart:
.annotate 'line', 10
    if_null rx1513_debug, debug_1259
    rx1513_cur."!cursor_debug"("NEXT", "infix:sym</>")
  debug_1259:
  rx1513_fail:
    (rx1513_rep, rx1513_pos, $I10, $P10) = rx1513_cur."!mark_fail"(0)
    lt rx1513_pos, -1, rx1513_done
    eq rx1513_pos, -1, rx1513_fail
    jump $I10
  rx1513_done:
    rx1513_cur."!cursor_fail"()
    if_null rx1513_debug, debug_1260
    rx1513_cur."!cursor_debug"("FAIL", "infix:sym</>")
  debug_1260:
    .return (rx1513_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym</>"  :nsentry("!PREFIX__infix:sym</>") :subid("312_1303401201.841") :method
.annotate 'line', 10
    $P1515 = self."!PREFIX__!subrule"("O", "/")
    new $P1516, "ResizablePMCArray"
    push $P1516, $P1515
    .return ($P1516)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<%>"  :subid("313_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1520_tgt
    .local int rx1520_pos
    .local int rx1520_off
    .local int rx1520_eos
    .local int rx1520_rep
    .local pmc rx1520_cur
    .local pmc rx1520_debug
    (rx1520_cur, rx1520_pos, rx1520_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1520_cur
    .local pmc match
    .lex "$/", match
    length rx1520_eos, rx1520_tgt
    gt rx1520_pos, rx1520_eos, rx1520_done
    set rx1520_off, 0
    lt rx1520_pos, 2, rx1520_start
    sub rx1520_off, rx1520_pos, 1
    substr rx1520_tgt, rx1520_tgt, rx1520_off
  rx1520_start:
    eq $I10, 1, rx1520_restart
    if_null rx1520_debug, debug_1261
    rx1520_cur."!cursor_debug"("START", "infix:sym<%>")
  debug_1261:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1524_done
    goto rxscan1524_scan
  rxscan1524_loop:
    (rx1520_pos) = rx1520_cur."from"()
    inc rx1520_pos
    rx1520_cur."!cursor_from"(rx1520_pos)
    ge rx1520_pos, rx1520_eos, rxscan1524_done
  rxscan1524_scan:
    set_addr $I10, rxscan1524_loop
    rx1520_cur."!mark_push"(0, rx1520_pos, $I10)
  rxscan1524_done:
.annotate 'line', 669
  # rx subcapture "sym"
    set_addr $I10, rxcap_1525_fail
    rx1520_cur."!mark_push"(0, rx1520_pos, $I10)
  # rx literal  "%"
    add $I11, rx1520_pos, 1
    gt $I11, rx1520_eos, rx1520_fail
    sub $I11, rx1520_pos, rx1520_off
    ord $I11, rx1520_tgt, $I11
    ne $I11, 37, rx1520_fail
    add rx1520_pos, 1
    set_addr $I10, rxcap_1525_fail
    ($I12, $I11) = rx1520_cur."!mark_peek"($I10)
    rx1520_cur."!cursor_pos"($I11)
    ($P10) = rx1520_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1520_pos, "")
    rx1520_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1525_done
  rxcap_1525_fail:
    goto rx1520_fail
  rxcap_1525_done:
  # rx subrule "O" subtype=capture negate=
    rx1520_cur."!cursor_pos"(rx1520_pos)
    $P10 = rx1520_cur."O"("%multiplicative, :pirop<mod>")
    unless $P10, rx1520_fail
    rx1520_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1520_pos = $P10."pos"()
  # rx pass
    rx1520_cur."!cursor_pass"(rx1520_pos, "infix:sym<%>")
    if_null rx1520_debug, debug_1262
    rx1520_cur."!cursor_debug"("PASS", "infix:sym<%>", " at pos=", rx1520_pos)
  debug_1262:
    .return (rx1520_cur)
  rx1520_restart:
.annotate 'line', 10
    if_null rx1520_debug, debug_1263
    rx1520_cur."!cursor_debug"("NEXT", "infix:sym<%>")
  debug_1263:
  rx1520_fail:
    (rx1520_rep, rx1520_pos, $I10, $P10) = rx1520_cur."!mark_fail"(0)
    lt rx1520_pos, -1, rx1520_done
    eq rx1520_pos, -1, rx1520_fail
    jump $I10
  rx1520_done:
    rx1520_cur."!cursor_fail"()
    if_null rx1520_debug, debug_1264
    rx1520_cur."!cursor_debug"("FAIL", "infix:sym<%>")
  debug_1264:
    .return (rx1520_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<%>"  :nsentry("!PREFIX__infix:sym<%>") :subid("314_1303401201.841") :method
.annotate 'line', 10
    $P1522 = self."!PREFIX__!subrule"("O", "%")
    new $P1523, "ResizablePMCArray"
    push $P1523, $P1522
    .return ($P1523)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+&>"  :subid("315_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1527_tgt
    .local int rx1527_pos
    .local int rx1527_off
    .local int rx1527_eos
    .local int rx1527_rep
    .local pmc rx1527_cur
    .local pmc rx1527_debug
    (rx1527_cur, rx1527_pos, rx1527_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1527_cur
    .local pmc match
    .lex "$/", match
    length rx1527_eos, rx1527_tgt
    gt rx1527_pos, rx1527_eos, rx1527_done
    set rx1527_off, 0
    lt rx1527_pos, 2, rx1527_start
    sub rx1527_off, rx1527_pos, 1
    substr rx1527_tgt, rx1527_tgt, rx1527_off
  rx1527_start:
    eq $I10, 1, rx1527_restart
    if_null rx1527_debug, debug_1265
    rx1527_cur."!cursor_debug"("START", "infix:sym<+&>")
  debug_1265:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1531_done
    goto rxscan1531_scan
  rxscan1531_loop:
    (rx1527_pos) = rx1527_cur."from"()
    inc rx1527_pos
    rx1527_cur."!cursor_from"(rx1527_pos)
    ge rx1527_pos, rx1527_eos, rxscan1531_done
  rxscan1531_scan:
    set_addr $I10, rxscan1531_loop
    rx1527_cur."!mark_push"(0, rx1527_pos, $I10)
  rxscan1531_done:
.annotate 'line', 670
  # rx subcapture "sym"
    set_addr $I10, rxcap_1532_fail
    rx1527_cur."!mark_push"(0, rx1527_pos, $I10)
  # rx literal  "+&"
    add $I11, rx1527_pos, 2
    gt $I11, rx1527_eos, rx1527_fail
    sub $I11, rx1527_pos, rx1527_off
    substr $S10, rx1527_tgt, $I11, 2
    ne $S10, "+&", rx1527_fail
    add rx1527_pos, 2
    set_addr $I10, rxcap_1532_fail
    ($I12, $I11) = rx1527_cur."!mark_peek"($I10)
    rx1527_cur."!cursor_pos"($I11)
    ($P10) = rx1527_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1527_pos, "")
    rx1527_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1532_done
  rxcap_1532_fail:
    goto rx1527_fail
  rxcap_1532_done:
  # rx subrule "O" subtype=capture negate=
    rx1527_cur."!cursor_pos"(rx1527_pos)
    $P10 = rx1527_cur."O"("%multiplicative, :pirop<band III>")
    unless $P10, rx1527_fail
    rx1527_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1527_pos = $P10."pos"()
  # rx pass
    rx1527_cur."!cursor_pass"(rx1527_pos, "infix:sym<+&>")
    if_null rx1527_debug, debug_1266
    rx1527_cur."!cursor_debug"("PASS", "infix:sym<+&>", " at pos=", rx1527_pos)
  debug_1266:
    .return (rx1527_cur)
  rx1527_restart:
.annotate 'line', 10
    if_null rx1527_debug, debug_1267
    rx1527_cur."!cursor_debug"("NEXT", "infix:sym<+&>")
  debug_1267:
  rx1527_fail:
    (rx1527_rep, rx1527_pos, $I10, $P10) = rx1527_cur."!mark_fail"(0)
    lt rx1527_pos, -1, rx1527_done
    eq rx1527_pos, -1, rx1527_fail
    jump $I10
  rx1527_done:
    rx1527_cur."!cursor_fail"()
    if_null rx1527_debug, debug_1268
    rx1527_cur."!cursor_debug"("FAIL", "infix:sym<+&>")
  debug_1268:
    .return (rx1527_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+&>"  :nsentry("!PREFIX__infix:sym<+&>") :subid("316_1303401201.841") :method
.annotate 'line', 10
    $P1529 = self."!PREFIX__!subrule"("O", "+&")
    new $P1530, "ResizablePMCArray"
    push $P1530, $P1529
    .return ($P1530)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+>"  :subid("317_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1534_tgt
    .local int rx1534_pos
    .local int rx1534_off
    .local int rx1534_eos
    .local int rx1534_rep
    .local pmc rx1534_cur
    .local pmc rx1534_debug
    (rx1534_cur, rx1534_pos, rx1534_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1534_cur
    .local pmc match
    .lex "$/", match
    length rx1534_eos, rx1534_tgt
    gt rx1534_pos, rx1534_eos, rx1534_done
    set rx1534_off, 0
    lt rx1534_pos, 2, rx1534_start
    sub rx1534_off, rx1534_pos, 1
    substr rx1534_tgt, rx1534_tgt, rx1534_off
  rx1534_start:
    eq $I10, 1, rx1534_restart
    if_null rx1534_debug, debug_1269
    rx1534_cur."!cursor_debug"("START", "infix:sym<+>")
  debug_1269:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1538_done
    goto rxscan1538_scan
  rxscan1538_loop:
    (rx1534_pos) = rx1534_cur."from"()
    inc rx1534_pos
    rx1534_cur."!cursor_from"(rx1534_pos)
    ge rx1534_pos, rx1534_eos, rxscan1538_done
  rxscan1538_scan:
    set_addr $I10, rxscan1538_loop
    rx1534_cur."!mark_push"(0, rx1534_pos, $I10)
  rxscan1538_done:
.annotate 'line', 672
  # rx subcapture "sym"
    set_addr $I10, rxcap_1539_fail
    rx1534_cur."!mark_push"(0, rx1534_pos, $I10)
  # rx literal  "+"
    add $I11, rx1534_pos, 1
    gt $I11, rx1534_eos, rx1534_fail
    sub $I11, rx1534_pos, rx1534_off
    ord $I11, rx1534_tgt, $I11
    ne $I11, 43, rx1534_fail
    add rx1534_pos, 1
    set_addr $I10, rxcap_1539_fail
    ($I12, $I11) = rx1534_cur."!mark_peek"($I10)
    rx1534_cur."!cursor_pos"($I11)
    ($P10) = rx1534_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1534_pos, "")
    rx1534_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1539_done
  rxcap_1539_fail:
    goto rx1534_fail
  rxcap_1539_done:
  # rx subrule "O" subtype=capture negate=
    rx1534_cur."!cursor_pos"(rx1534_pos)
    $P10 = rx1534_cur."O"("%additive, :pirop<add>")
    unless $P10, rx1534_fail
    rx1534_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1534_pos = $P10."pos"()
  # rx pass
    rx1534_cur."!cursor_pass"(rx1534_pos, "infix:sym<+>")
    if_null rx1534_debug, debug_1270
    rx1534_cur."!cursor_debug"("PASS", "infix:sym<+>", " at pos=", rx1534_pos)
  debug_1270:
    .return (rx1534_cur)
  rx1534_restart:
.annotate 'line', 10
    if_null rx1534_debug, debug_1271
    rx1534_cur."!cursor_debug"("NEXT", "infix:sym<+>")
  debug_1271:
  rx1534_fail:
    (rx1534_rep, rx1534_pos, $I10, $P10) = rx1534_cur."!mark_fail"(0)
    lt rx1534_pos, -1, rx1534_done
    eq rx1534_pos, -1, rx1534_fail
    jump $I10
  rx1534_done:
    rx1534_cur."!cursor_fail"()
    if_null rx1534_debug, debug_1272
    rx1534_cur."!cursor_debug"("FAIL", "infix:sym<+>")
  debug_1272:
    .return (rx1534_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+>"  :nsentry("!PREFIX__infix:sym<+>") :subid("318_1303401201.841") :method
.annotate 'line', 10
    $P1536 = self."!PREFIX__!subrule"("O", "+")
    new $P1537, "ResizablePMCArray"
    push $P1537, $P1536
    .return ($P1537)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<->"  :subid("319_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1541_tgt
    .local int rx1541_pos
    .local int rx1541_off
    .local int rx1541_eos
    .local int rx1541_rep
    .local pmc rx1541_cur
    .local pmc rx1541_debug
    (rx1541_cur, rx1541_pos, rx1541_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1541_cur
    .local pmc match
    .lex "$/", match
    length rx1541_eos, rx1541_tgt
    gt rx1541_pos, rx1541_eos, rx1541_done
    set rx1541_off, 0
    lt rx1541_pos, 2, rx1541_start
    sub rx1541_off, rx1541_pos, 1
    substr rx1541_tgt, rx1541_tgt, rx1541_off
  rx1541_start:
    eq $I10, 1, rx1541_restart
    if_null rx1541_debug, debug_1273
    rx1541_cur."!cursor_debug"("START", "infix:sym<->")
  debug_1273:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1545_done
    goto rxscan1545_scan
  rxscan1545_loop:
    (rx1541_pos) = rx1541_cur."from"()
    inc rx1541_pos
    rx1541_cur."!cursor_from"(rx1541_pos)
    ge rx1541_pos, rx1541_eos, rxscan1545_done
  rxscan1545_scan:
    set_addr $I10, rxscan1545_loop
    rx1541_cur."!mark_push"(0, rx1541_pos, $I10)
  rxscan1545_done:
.annotate 'line', 673
  # rx subcapture "sym"
    set_addr $I10, rxcap_1546_fail
    rx1541_cur."!mark_push"(0, rx1541_pos, $I10)
  # rx literal  "-"
    add $I11, rx1541_pos, 1
    gt $I11, rx1541_eos, rx1541_fail
    sub $I11, rx1541_pos, rx1541_off
    ord $I11, rx1541_tgt, $I11
    ne $I11, 45, rx1541_fail
    add rx1541_pos, 1
    set_addr $I10, rxcap_1546_fail
    ($I12, $I11) = rx1541_cur."!mark_peek"($I10)
    rx1541_cur."!cursor_pos"($I11)
    ($P10) = rx1541_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1541_pos, "")
    rx1541_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1546_done
  rxcap_1546_fail:
    goto rx1541_fail
  rxcap_1546_done:
  # rx subrule "O" subtype=capture negate=
    rx1541_cur."!cursor_pos"(rx1541_pos)
    $P10 = rx1541_cur."O"("%additive, :pirop<sub>")
    unless $P10, rx1541_fail
    rx1541_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1541_pos = $P10."pos"()
  # rx pass
    rx1541_cur."!cursor_pass"(rx1541_pos, "infix:sym<->")
    if_null rx1541_debug, debug_1274
    rx1541_cur."!cursor_debug"("PASS", "infix:sym<->", " at pos=", rx1541_pos)
  debug_1274:
    .return (rx1541_cur)
  rx1541_restart:
.annotate 'line', 10
    if_null rx1541_debug, debug_1275
    rx1541_cur."!cursor_debug"("NEXT", "infix:sym<->")
  debug_1275:
  rx1541_fail:
    (rx1541_rep, rx1541_pos, $I10, $P10) = rx1541_cur."!mark_fail"(0)
    lt rx1541_pos, -1, rx1541_done
    eq rx1541_pos, -1, rx1541_fail
    jump $I10
  rx1541_done:
    rx1541_cur."!cursor_fail"()
    if_null rx1541_debug, debug_1276
    rx1541_cur."!cursor_debug"("FAIL", "infix:sym<->")
  debug_1276:
    .return (rx1541_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<->"  :nsentry("!PREFIX__infix:sym<->") :subid("320_1303401201.841") :method
.annotate 'line', 10
    $P1543 = self."!PREFIX__!subrule"("O", "-")
    new $P1544, "ResizablePMCArray"
    push $P1544, $P1543
    .return ($P1544)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+|>"  :subid("321_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1548_tgt
    .local int rx1548_pos
    .local int rx1548_off
    .local int rx1548_eos
    .local int rx1548_rep
    .local pmc rx1548_cur
    .local pmc rx1548_debug
    (rx1548_cur, rx1548_pos, rx1548_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1548_cur
    .local pmc match
    .lex "$/", match
    length rx1548_eos, rx1548_tgt
    gt rx1548_pos, rx1548_eos, rx1548_done
    set rx1548_off, 0
    lt rx1548_pos, 2, rx1548_start
    sub rx1548_off, rx1548_pos, 1
    substr rx1548_tgt, rx1548_tgt, rx1548_off
  rx1548_start:
    eq $I10, 1, rx1548_restart
    if_null rx1548_debug, debug_1277
    rx1548_cur."!cursor_debug"("START", "infix:sym<+|>")
  debug_1277:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1552_done
    goto rxscan1552_scan
  rxscan1552_loop:
    (rx1548_pos) = rx1548_cur."from"()
    inc rx1548_pos
    rx1548_cur."!cursor_from"(rx1548_pos)
    ge rx1548_pos, rx1548_eos, rxscan1552_done
  rxscan1552_scan:
    set_addr $I10, rxscan1552_loop
    rx1548_cur."!mark_push"(0, rx1548_pos, $I10)
  rxscan1552_done:
.annotate 'line', 674
  # rx subcapture "sym"
    set_addr $I10, rxcap_1553_fail
    rx1548_cur."!mark_push"(0, rx1548_pos, $I10)
  # rx literal  "+|"
    add $I11, rx1548_pos, 2
    gt $I11, rx1548_eos, rx1548_fail
    sub $I11, rx1548_pos, rx1548_off
    substr $S10, rx1548_tgt, $I11, 2
    ne $S10, "+|", rx1548_fail
    add rx1548_pos, 2
    set_addr $I10, rxcap_1553_fail
    ($I12, $I11) = rx1548_cur."!mark_peek"($I10)
    rx1548_cur."!cursor_pos"($I11)
    ($P10) = rx1548_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1548_pos, "")
    rx1548_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1553_done
  rxcap_1553_fail:
    goto rx1548_fail
  rxcap_1553_done:
  # rx subrule "O" subtype=capture negate=
    rx1548_cur."!cursor_pos"(rx1548_pos)
    $P10 = rx1548_cur."O"("%additive, :pirop<bor III>")
    unless $P10, rx1548_fail
    rx1548_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1548_pos = $P10."pos"()
  # rx pass
    rx1548_cur."!cursor_pass"(rx1548_pos, "infix:sym<+|>")
    if_null rx1548_debug, debug_1278
    rx1548_cur."!cursor_debug"("PASS", "infix:sym<+|>", " at pos=", rx1548_pos)
  debug_1278:
    .return (rx1548_cur)
  rx1548_restart:
.annotate 'line', 10
    if_null rx1548_debug, debug_1279
    rx1548_cur."!cursor_debug"("NEXT", "infix:sym<+|>")
  debug_1279:
  rx1548_fail:
    (rx1548_rep, rx1548_pos, $I10, $P10) = rx1548_cur."!mark_fail"(0)
    lt rx1548_pos, -1, rx1548_done
    eq rx1548_pos, -1, rx1548_fail
    jump $I10
  rx1548_done:
    rx1548_cur."!cursor_fail"()
    if_null rx1548_debug, debug_1280
    rx1548_cur."!cursor_debug"("FAIL", "infix:sym<+|>")
  debug_1280:
    .return (rx1548_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+|>"  :nsentry("!PREFIX__infix:sym<+|>") :subid("322_1303401201.841") :method
.annotate 'line', 10
    $P1550 = self."!PREFIX__!subrule"("O", "+|")
    new $P1551, "ResizablePMCArray"
    push $P1551, $P1550
    .return ($P1551)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+^>"  :subid("323_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1555_tgt
    .local int rx1555_pos
    .local int rx1555_off
    .local int rx1555_eos
    .local int rx1555_rep
    .local pmc rx1555_cur
    .local pmc rx1555_debug
    (rx1555_cur, rx1555_pos, rx1555_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1555_cur
    .local pmc match
    .lex "$/", match
    length rx1555_eos, rx1555_tgt
    gt rx1555_pos, rx1555_eos, rx1555_done
    set rx1555_off, 0
    lt rx1555_pos, 2, rx1555_start
    sub rx1555_off, rx1555_pos, 1
    substr rx1555_tgt, rx1555_tgt, rx1555_off
  rx1555_start:
    eq $I10, 1, rx1555_restart
    if_null rx1555_debug, debug_1281
    rx1555_cur."!cursor_debug"("START", "infix:sym<+^>")
  debug_1281:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1559_done
    goto rxscan1559_scan
  rxscan1559_loop:
    (rx1555_pos) = rx1555_cur."from"()
    inc rx1555_pos
    rx1555_cur."!cursor_from"(rx1555_pos)
    ge rx1555_pos, rx1555_eos, rxscan1559_done
  rxscan1559_scan:
    set_addr $I10, rxscan1559_loop
    rx1555_cur."!mark_push"(0, rx1555_pos, $I10)
  rxscan1559_done:
.annotate 'line', 675
  # rx subcapture "sym"
    set_addr $I10, rxcap_1560_fail
    rx1555_cur."!mark_push"(0, rx1555_pos, $I10)
  # rx literal  "+^"
    add $I11, rx1555_pos, 2
    gt $I11, rx1555_eos, rx1555_fail
    sub $I11, rx1555_pos, rx1555_off
    substr $S10, rx1555_tgt, $I11, 2
    ne $S10, "+^", rx1555_fail
    add rx1555_pos, 2
    set_addr $I10, rxcap_1560_fail
    ($I12, $I11) = rx1555_cur."!mark_peek"($I10)
    rx1555_cur."!cursor_pos"($I11)
    ($P10) = rx1555_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1555_pos, "")
    rx1555_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1560_done
  rxcap_1560_fail:
    goto rx1555_fail
  rxcap_1560_done:
  # rx subrule "O" subtype=capture negate=
    rx1555_cur."!cursor_pos"(rx1555_pos)
    $P10 = rx1555_cur."O"("%additive, :pirop<bxor III>")
    unless $P10, rx1555_fail
    rx1555_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1555_pos = $P10."pos"()
  # rx pass
    rx1555_cur."!cursor_pass"(rx1555_pos, "infix:sym<+^>")
    if_null rx1555_debug, debug_1282
    rx1555_cur."!cursor_debug"("PASS", "infix:sym<+^>", " at pos=", rx1555_pos)
  debug_1282:
    .return (rx1555_cur)
  rx1555_restart:
.annotate 'line', 10
    if_null rx1555_debug, debug_1283
    rx1555_cur."!cursor_debug"("NEXT", "infix:sym<+^>")
  debug_1283:
  rx1555_fail:
    (rx1555_rep, rx1555_pos, $I10, $P10) = rx1555_cur."!mark_fail"(0)
    lt rx1555_pos, -1, rx1555_done
    eq rx1555_pos, -1, rx1555_fail
    jump $I10
  rx1555_done:
    rx1555_cur."!cursor_fail"()
    if_null rx1555_debug, debug_1284
    rx1555_cur."!cursor_debug"("FAIL", "infix:sym<+^>")
  debug_1284:
    .return (rx1555_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+^>"  :nsentry("!PREFIX__infix:sym<+^>") :subid("324_1303401201.841") :method
.annotate 'line', 10
    $P1557 = self."!PREFIX__!subrule"("O", "+^")
    new $P1558, "ResizablePMCArray"
    push $P1558, $P1557
    .return ($P1558)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~>"  :subid("325_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1562_tgt
    .local int rx1562_pos
    .local int rx1562_off
    .local int rx1562_eos
    .local int rx1562_rep
    .local pmc rx1562_cur
    .local pmc rx1562_debug
    (rx1562_cur, rx1562_pos, rx1562_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1562_cur
    .local pmc match
    .lex "$/", match
    length rx1562_eos, rx1562_tgt
    gt rx1562_pos, rx1562_eos, rx1562_done
    set rx1562_off, 0
    lt rx1562_pos, 2, rx1562_start
    sub rx1562_off, rx1562_pos, 1
    substr rx1562_tgt, rx1562_tgt, rx1562_off
  rx1562_start:
    eq $I10, 1, rx1562_restart
    if_null rx1562_debug, debug_1285
    rx1562_cur."!cursor_debug"("START", "infix:sym<~>")
  debug_1285:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1566_done
    goto rxscan1566_scan
  rxscan1566_loop:
    (rx1562_pos) = rx1562_cur."from"()
    inc rx1562_pos
    rx1562_cur."!cursor_from"(rx1562_pos)
    ge rx1562_pos, rx1562_eos, rxscan1566_done
  rxscan1566_scan:
    set_addr $I10, rxscan1566_loop
    rx1562_cur."!mark_push"(0, rx1562_pos, $I10)
  rxscan1566_done:
.annotate 'line', 677
  # rx subcapture "sym"
    set_addr $I10, rxcap_1567_fail
    rx1562_cur."!mark_push"(0, rx1562_pos, $I10)
  # rx literal  "~"
    add $I11, rx1562_pos, 1
    gt $I11, rx1562_eos, rx1562_fail
    sub $I11, rx1562_pos, rx1562_off
    ord $I11, rx1562_tgt, $I11
    ne $I11, 126, rx1562_fail
    add rx1562_pos, 1
    set_addr $I10, rxcap_1567_fail
    ($I12, $I11) = rx1562_cur."!mark_peek"($I10)
    rx1562_cur."!cursor_pos"($I11)
    ($P10) = rx1562_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1562_pos, "")
    rx1562_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1567_done
  rxcap_1567_fail:
    goto rx1562_fail
  rxcap_1567_done:
  # rx subrule "O" subtype=capture negate=
    rx1562_cur."!cursor_pos"(rx1562_pos)
    $P10 = rx1562_cur."O"("%concatenation , :pirop<concat>")
    unless $P10, rx1562_fail
    rx1562_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1562_pos = $P10."pos"()
  # rx pass
    rx1562_cur."!cursor_pass"(rx1562_pos, "infix:sym<~>")
    if_null rx1562_debug, debug_1286
    rx1562_cur."!cursor_debug"("PASS", "infix:sym<~>", " at pos=", rx1562_pos)
  debug_1286:
    .return (rx1562_cur)
  rx1562_restart:
.annotate 'line', 10
    if_null rx1562_debug, debug_1287
    rx1562_cur."!cursor_debug"("NEXT", "infix:sym<~>")
  debug_1287:
  rx1562_fail:
    (rx1562_rep, rx1562_pos, $I10, $P10) = rx1562_cur."!mark_fail"(0)
    lt rx1562_pos, -1, rx1562_done
    eq rx1562_pos, -1, rx1562_fail
    jump $I10
  rx1562_done:
    rx1562_cur."!cursor_fail"()
    if_null rx1562_debug, debug_1288
    rx1562_cur."!cursor_debug"("FAIL", "infix:sym<~>")
  debug_1288:
    .return (rx1562_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~>"  :nsentry("!PREFIX__infix:sym<~>") :subid("326_1303401201.841") :method
.annotate 'line', 10
    $P1564 = self."!PREFIX__!subrule"("O", "~")
    new $P1565, "ResizablePMCArray"
    push $P1565, $P1564
    .return ($P1565)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<==>"  :subid("327_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1569_tgt
    .local int rx1569_pos
    .local int rx1569_off
    .local int rx1569_eos
    .local int rx1569_rep
    .local pmc rx1569_cur
    .local pmc rx1569_debug
    (rx1569_cur, rx1569_pos, rx1569_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1569_cur
    .local pmc match
    .lex "$/", match
    length rx1569_eos, rx1569_tgt
    gt rx1569_pos, rx1569_eos, rx1569_done
    set rx1569_off, 0
    lt rx1569_pos, 2, rx1569_start
    sub rx1569_off, rx1569_pos, 1
    substr rx1569_tgt, rx1569_tgt, rx1569_off
  rx1569_start:
    eq $I10, 1, rx1569_restart
    if_null rx1569_debug, debug_1289
    rx1569_cur."!cursor_debug"("START", "infix:sym<==>")
  debug_1289:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1573_done
    goto rxscan1573_scan
  rxscan1573_loop:
    (rx1569_pos) = rx1569_cur."from"()
    inc rx1569_pos
    rx1569_cur."!cursor_from"(rx1569_pos)
    ge rx1569_pos, rx1569_eos, rxscan1573_done
  rxscan1573_scan:
    set_addr $I10, rxscan1573_loop
    rx1569_cur."!mark_push"(0, rx1569_pos, $I10)
  rxscan1573_done:
.annotate 'line', 679
  # rx subcapture "sym"
    set_addr $I10, rxcap_1574_fail
    rx1569_cur."!mark_push"(0, rx1569_pos, $I10)
  # rx literal  "=="
    add $I11, rx1569_pos, 2
    gt $I11, rx1569_eos, rx1569_fail
    sub $I11, rx1569_pos, rx1569_off
    substr $S10, rx1569_tgt, $I11, 2
    ne $S10, "==", rx1569_fail
    add rx1569_pos, 2
    set_addr $I10, rxcap_1574_fail
    ($I12, $I11) = rx1569_cur."!mark_peek"($I10)
    rx1569_cur."!cursor_pos"($I11)
    ($P10) = rx1569_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1569_pos, "")
    rx1569_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1574_done
  rxcap_1574_fail:
    goto rx1569_fail
  rxcap_1574_done:
  # rx subrule "O" subtype=capture negate=
    rx1569_cur."!cursor_pos"(rx1569_pos)
    $P10 = rx1569_cur."O"("%relational, :pirop<iseq INn>")
    unless $P10, rx1569_fail
    rx1569_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1569_pos = $P10."pos"()
  # rx pass
    rx1569_cur."!cursor_pass"(rx1569_pos, "infix:sym<==>")
    if_null rx1569_debug, debug_1290
    rx1569_cur."!cursor_debug"("PASS", "infix:sym<==>", " at pos=", rx1569_pos)
  debug_1290:
    .return (rx1569_cur)
  rx1569_restart:
.annotate 'line', 10
    if_null rx1569_debug, debug_1291
    rx1569_cur."!cursor_debug"("NEXT", "infix:sym<==>")
  debug_1291:
  rx1569_fail:
    (rx1569_rep, rx1569_pos, $I10, $P10) = rx1569_cur."!mark_fail"(0)
    lt rx1569_pos, -1, rx1569_done
    eq rx1569_pos, -1, rx1569_fail
    jump $I10
  rx1569_done:
    rx1569_cur."!cursor_fail"()
    if_null rx1569_debug, debug_1292
    rx1569_cur."!cursor_debug"("FAIL", "infix:sym<==>")
  debug_1292:
    .return (rx1569_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<==>"  :nsentry("!PREFIX__infix:sym<==>") :subid("328_1303401201.841") :method
.annotate 'line', 10
    $P1571 = self."!PREFIX__!subrule"("O", "==")
    new $P1572, "ResizablePMCArray"
    push $P1572, $P1571
    .return ($P1572)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<!=>"  :subid("329_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1576_tgt
    .local int rx1576_pos
    .local int rx1576_off
    .local int rx1576_eos
    .local int rx1576_rep
    .local pmc rx1576_cur
    .local pmc rx1576_debug
    (rx1576_cur, rx1576_pos, rx1576_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1576_cur
    .local pmc match
    .lex "$/", match
    length rx1576_eos, rx1576_tgt
    gt rx1576_pos, rx1576_eos, rx1576_done
    set rx1576_off, 0
    lt rx1576_pos, 2, rx1576_start
    sub rx1576_off, rx1576_pos, 1
    substr rx1576_tgt, rx1576_tgt, rx1576_off
  rx1576_start:
    eq $I10, 1, rx1576_restart
    if_null rx1576_debug, debug_1293
    rx1576_cur."!cursor_debug"("START", "infix:sym<!=>")
  debug_1293:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1580_done
    goto rxscan1580_scan
  rxscan1580_loop:
    (rx1576_pos) = rx1576_cur."from"()
    inc rx1576_pos
    rx1576_cur."!cursor_from"(rx1576_pos)
    ge rx1576_pos, rx1576_eos, rxscan1580_done
  rxscan1580_scan:
    set_addr $I10, rxscan1580_loop
    rx1576_cur."!mark_push"(0, rx1576_pos, $I10)
  rxscan1580_done:
.annotate 'line', 680
  # rx subcapture "sym"
    set_addr $I10, rxcap_1581_fail
    rx1576_cur."!mark_push"(0, rx1576_pos, $I10)
  # rx literal  "!="
    add $I11, rx1576_pos, 2
    gt $I11, rx1576_eos, rx1576_fail
    sub $I11, rx1576_pos, rx1576_off
    substr $S10, rx1576_tgt, $I11, 2
    ne $S10, "!=", rx1576_fail
    add rx1576_pos, 2
    set_addr $I10, rxcap_1581_fail
    ($I12, $I11) = rx1576_cur."!mark_peek"($I10)
    rx1576_cur."!cursor_pos"($I11)
    ($P10) = rx1576_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1576_pos, "")
    rx1576_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1581_done
  rxcap_1581_fail:
    goto rx1576_fail
  rxcap_1581_done:
  # rx subrule "O" subtype=capture negate=
    rx1576_cur."!cursor_pos"(rx1576_pos)
    $P10 = rx1576_cur."O"("%relational, :pirop<isne INn>")
    unless $P10, rx1576_fail
    rx1576_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1576_pos = $P10."pos"()
  # rx pass
    rx1576_cur."!cursor_pass"(rx1576_pos, "infix:sym<!=>")
    if_null rx1576_debug, debug_1294
    rx1576_cur."!cursor_debug"("PASS", "infix:sym<!=>", " at pos=", rx1576_pos)
  debug_1294:
    .return (rx1576_cur)
  rx1576_restart:
.annotate 'line', 10
    if_null rx1576_debug, debug_1295
    rx1576_cur."!cursor_debug"("NEXT", "infix:sym<!=>")
  debug_1295:
  rx1576_fail:
    (rx1576_rep, rx1576_pos, $I10, $P10) = rx1576_cur."!mark_fail"(0)
    lt rx1576_pos, -1, rx1576_done
    eq rx1576_pos, -1, rx1576_fail
    jump $I10
  rx1576_done:
    rx1576_cur."!cursor_fail"()
    if_null rx1576_debug, debug_1296
    rx1576_cur."!cursor_debug"("FAIL", "infix:sym<!=>")
  debug_1296:
    .return (rx1576_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<!=>"  :nsentry("!PREFIX__infix:sym<!=>") :subid("330_1303401201.841") :method
.annotate 'line', 10
    $P1578 = self."!PREFIX__!subrule"("O", "!=")
    new $P1579, "ResizablePMCArray"
    push $P1579, $P1578
    .return ($P1579)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<=>"  :subid("331_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1583_tgt
    .local int rx1583_pos
    .local int rx1583_off
    .local int rx1583_eos
    .local int rx1583_rep
    .local pmc rx1583_cur
    .local pmc rx1583_debug
    (rx1583_cur, rx1583_pos, rx1583_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1583_cur
    .local pmc match
    .lex "$/", match
    length rx1583_eos, rx1583_tgt
    gt rx1583_pos, rx1583_eos, rx1583_done
    set rx1583_off, 0
    lt rx1583_pos, 2, rx1583_start
    sub rx1583_off, rx1583_pos, 1
    substr rx1583_tgt, rx1583_tgt, rx1583_off
  rx1583_start:
    eq $I10, 1, rx1583_restart
    if_null rx1583_debug, debug_1297
    rx1583_cur."!cursor_debug"("START", "infix:sym<<=>")
  debug_1297:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1587_done
    goto rxscan1587_scan
  rxscan1587_loop:
    (rx1583_pos) = rx1583_cur."from"()
    inc rx1583_pos
    rx1583_cur."!cursor_from"(rx1583_pos)
    ge rx1583_pos, rx1583_eos, rxscan1587_done
  rxscan1587_scan:
    set_addr $I10, rxscan1587_loop
    rx1583_cur."!mark_push"(0, rx1583_pos, $I10)
  rxscan1587_done:
.annotate 'line', 681
  # rx subcapture "sym"
    set_addr $I10, rxcap_1588_fail
    rx1583_cur."!mark_push"(0, rx1583_pos, $I10)
  # rx literal  "<="
    add $I11, rx1583_pos, 2
    gt $I11, rx1583_eos, rx1583_fail
    sub $I11, rx1583_pos, rx1583_off
    substr $S10, rx1583_tgt, $I11, 2
    ne $S10, "<=", rx1583_fail
    add rx1583_pos, 2
    set_addr $I10, rxcap_1588_fail
    ($I12, $I11) = rx1583_cur."!mark_peek"($I10)
    rx1583_cur."!cursor_pos"($I11)
    ($P10) = rx1583_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1583_pos, "")
    rx1583_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1588_done
  rxcap_1588_fail:
    goto rx1583_fail
  rxcap_1588_done:
  # rx subrule "O" subtype=capture negate=
    rx1583_cur."!cursor_pos"(rx1583_pos)
    $P10 = rx1583_cur."O"("%relational, :pirop<isle INn>")
    unless $P10, rx1583_fail
    rx1583_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1583_pos = $P10."pos"()
  # rx pass
    rx1583_cur."!cursor_pass"(rx1583_pos, "infix:sym<<=>")
    if_null rx1583_debug, debug_1298
    rx1583_cur."!cursor_debug"("PASS", "infix:sym<<=>", " at pos=", rx1583_pos)
  debug_1298:
    .return (rx1583_cur)
  rx1583_restart:
.annotate 'line', 10
    if_null rx1583_debug, debug_1299
    rx1583_cur."!cursor_debug"("NEXT", "infix:sym<<=>")
  debug_1299:
  rx1583_fail:
    (rx1583_rep, rx1583_pos, $I10, $P10) = rx1583_cur."!mark_fail"(0)
    lt rx1583_pos, -1, rx1583_done
    eq rx1583_pos, -1, rx1583_fail
    jump $I10
  rx1583_done:
    rx1583_cur."!cursor_fail"()
    if_null rx1583_debug, debug_1300
    rx1583_cur."!cursor_debug"("FAIL", "infix:sym<<=>")
  debug_1300:
    .return (rx1583_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<=>"  :nsentry("!PREFIX__infix:sym<<=>") :subid("332_1303401201.841") :method
.annotate 'line', 10
    $P1585 = self."!PREFIX__!subrule"("O", "<=")
    new $P1586, "ResizablePMCArray"
    push $P1586, $P1585
    .return ($P1586)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>=>"  :subid("333_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1590_tgt
    .local int rx1590_pos
    .local int rx1590_off
    .local int rx1590_eos
    .local int rx1590_rep
    .local pmc rx1590_cur
    .local pmc rx1590_debug
    (rx1590_cur, rx1590_pos, rx1590_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1590_cur
    .local pmc match
    .lex "$/", match
    length rx1590_eos, rx1590_tgt
    gt rx1590_pos, rx1590_eos, rx1590_done
    set rx1590_off, 0
    lt rx1590_pos, 2, rx1590_start
    sub rx1590_off, rx1590_pos, 1
    substr rx1590_tgt, rx1590_tgt, rx1590_off
  rx1590_start:
    eq $I10, 1, rx1590_restart
    if_null rx1590_debug, debug_1301
    rx1590_cur."!cursor_debug"("START", "infix:sym<>=>")
  debug_1301:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1594_done
    goto rxscan1594_scan
  rxscan1594_loop:
    (rx1590_pos) = rx1590_cur."from"()
    inc rx1590_pos
    rx1590_cur."!cursor_from"(rx1590_pos)
    ge rx1590_pos, rx1590_eos, rxscan1594_done
  rxscan1594_scan:
    set_addr $I10, rxscan1594_loop
    rx1590_cur."!mark_push"(0, rx1590_pos, $I10)
  rxscan1594_done:
.annotate 'line', 682
  # rx subcapture "sym"
    set_addr $I10, rxcap_1595_fail
    rx1590_cur."!mark_push"(0, rx1590_pos, $I10)
  # rx literal  ">="
    add $I11, rx1590_pos, 2
    gt $I11, rx1590_eos, rx1590_fail
    sub $I11, rx1590_pos, rx1590_off
    substr $S10, rx1590_tgt, $I11, 2
    ne $S10, ">=", rx1590_fail
    add rx1590_pos, 2
    set_addr $I10, rxcap_1595_fail
    ($I12, $I11) = rx1590_cur."!mark_peek"($I10)
    rx1590_cur."!cursor_pos"($I11)
    ($P10) = rx1590_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1590_pos, "")
    rx1590_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1595_done
  rxcap_1595_fail:
    goto rx1590_fail
  rxcap_1595_done:
  # rx subrule "O" subtype=capture negate=
    rx1590_cur."!cursor_pos"(rx1590_pos)
    $P10 = rx1590_cur."O"("%relational, :pirop<isge INn>")
    unless $P10, rx1590_fail
    rx1590_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1590_pos = $P10."pos"()
  # rx pass
    rx1590_cur."!cursor_pass"(rx1590_pos, "infix:sym<>=>")
    if_null rx1590_debug, debug_1302
    rx1590_cur."!cursor_debug"("PASS", "infix:sym<>=>", " at pos=", rx1590_pos)
  debug_1302:
    .return (rx1590_cur)
  rx1590_restart:
.annotate 'line', 10
    if_null rx1590_debug, debug_1303
    rx1590_cur."!cursor_debug"("NEXT", "infix:sym<>=>")
  debug_1303:
  rx1590_fail:
    (rx1590_rep, rx1590_pos, $I10, $P10) = rx1590_cur."!mark_fail"(0)
    lt rx1590_pos, -1, rx1590_done
    eq rx1590_pos, -1, rx1590_fail
    jump $I10
  rx1590_done:
    rx1590_cur."!cursor_fail"()
    if_null rx1590_debug, debug_1304
    rx1590_cur."!cursor_debug"("FAIL", "infix:sym<>=>")
  debug_1304:
    .return (rx1590_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>=>"  :nsentry("!PREFIX__infix:sym<>=>") :subid("334_1303401201.841") :method
.annotate 'line', 10
    $P1592 = self."!PREFIX__!subrule"("O", ">=")
    new $P1593, "ResizablePMCArray"
    push $P1593, $P1592
    .return ($P1593)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<>"  :subid("335_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1597_tgt
    .local int rx1597_pos
    .local int rx1597_off
    .local int rx1597_eos
    .local int rx1597_rep
    .local pmc rx1597_cur
    .local pmc rx1597_debug
    (rx1597_cur, rx1597_pos, rx1597_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1597_cur
    .local pmc match
    .lex "$/", match
    length rx1597_eos, rx1597_tgt
    gt rx1597_pos, rx1597_eos, rx1597_done
    set rx1597_off, 0
    lt rx1597_pos, 2, rx1597_start
    sub rx1597_off, rx1597_pos, 1
    substr rx1597_tgt, rx1597_tgt, rx1597_off
  rx1597_start:
    eq $I10, 1, rx1597_restart
    if_null rx1597_debug, debug_1305
    rx1597_cur."!cursor_debug"("START", "infix:sym<<>")
  debug_1305:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1601_done
    goto rxscan1601_scan
  rxscan1601_loop:
    (rx1597_pos) = rx1597_cur."from"()
    inc rx1597_pos
    rx1597_cur."!cursor_from"(rx1597_pos)
    ge rx1597_pos, rx1597_eos, rxscan1601_done
  rxscan1601_scan:
    set_addr $I10, rxscan1601_loop
    rx1597_cur."!mark_push"(0, rx1597_pos, $I10)
  rxscan1601_done:
.annotate 'line', 683
  # rx subcapture "sym"
    set_addr $I10, rxcap_1602_fail
    rx1597_cur."!mark_push"(0, rx1597_pos, $I10)
  # rx literal  "<"
    add $I11, rx1597_pos, 1
    gt $I11, rx1597_eos, rx1597_fail
    sub $I11, rx1597_pos, rx1597_off
    ord $I11, rx1597_tgt, $I11
    ne $I11, 60, rx1597_fail
    add rx1597_pos, 1
    set_addr $I10, rxcap_1602_fail
    ($I12, $I11) = rx1597_cur."!mark_peek"($I10)
    rx1597_cur."!cursor_pos"($I11)
    ($P10) = rx1597_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1597_pos, "")
    rx1597_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1602_done
  rxcap_1602_fail:
    goto rx1597_fail
  rxcap_1602_done:
  # rx subrule "O" subtype=capture negate=
    rx1597_cur."!cursor_pos"(rx1597_pos)
    $P10 = rx1597_cur."O"("%relational, :pirop<islt INn>")
    unless $P10, rx1597_fail
    rx1597_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1597_pos = $P10."pos"()
  # rx pass
    rx1597_cur."!cursor_pass"(rx1597_pos, "infix:sym<<>")
    if_null rx1597_debug, debug_1306
    rx1597_cur."!cursor_debug"("PASS", "infix:sym<<>", " at pos=", rx1597_pos)
  debug_1306:
    .return (rx1597_cur)
  rx1597_restart:
.annotate 'line', 10
    if_null rx1597_debug, debug_1307
    rx1597_cur."!cursor_debug"("NEXT", "infix:sym<<>")
  debug_1307:
  rx1597_fail:
    (rx1597_rep, rx1597_pos, $I10, $P10) = rx1597_cur."!mark_fail"(0)
    lt rx1597_pos, -1, rx1597_done
    eq rx1597_pos, -1, rx1597_fail
    jump $I10
  rx1597_done:
    rx1597_cur."!cursor_fail"()
    if_null rx1597_debug, debug_1308
    rx1597_cur."!cursor_debug"("FAIL", "infix:sym<<>")
  debug_1308:
    .return (rx1597_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<>"  :nsentry("!PREFIX__infix:sym<<>") :subid("336_1303401201.841") :method
.annotate 'line', 10
    $P1599 = self."!PREFIX__!subrule"("O", "<")
    new $P1600, "ResizablePMCArray"
    push $P1600, $P1599
    .return ($P1600)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>>"  :subid("337_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1604_tgt
    .local int rx1604_pos
    .local int rx1604_off
    .local int rx1604_eos
    .local int rx1604_rep
    .local pmc rx1604_cur
    .local pmc rx1604_debug
    (rx1604_cur, rx1604_pos, rx1604_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1604_cur
    .local pmc match
    .lex "$/", match
    length rx1604_eos, rx1604_tgt
    gt rx1604_pos, rx1604_eos, rx1604_done
    set rx1604_off, 0
    lt rx1604_pos, 2, rx1604_start
    sub rx1604_off, rx1604_pos, 1
    substr rx1604_tgt, rx1604_tgt, rx1604_off
  rx1604_start:
    eq $I10, 1, rx1604_restart
    if_null rx1604_debug, debug_1309
    rx1604_cur."!cursor_debug"("START", "infix:sym<>>")
  debug_1309:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1608_done
    goto rxscan1608_scan
  rxscan1608_loop:
    (rx1604_pos) = rx1604_cur."from"()
    inc rx1604_pos
    rx1604_cur."!cursor_from"(rx1604_pos)
    ge rx1604_pos, rx1604_eos, rxscan1608_done
  rxscan1608_scan:
    set_addr $I10, rxscan1608_loop
    rx1604_cur."!mark_push"(0, rx1604_pos, $I10)
  rxscan1608_done:
.annotate 'line', 684
  # rx subcapture "sym"
    set_addr $I10, rxcap_1609_fail
    rx1604_cur."!mark_push"(0, rx1604_pos, $I10)
  # rx literal  ">"
    add $I11, rx1604_pos, 1
    gt $I11, rx1604_eos, rx1604_fail
    sub $I11, rx1604_pos, rx1604_off
    ord $I11, rx1604_tgt, $I11
    ne $I11, 62, rx1604_fail
    add rx1604_pos, 1
    set_addr $I10, rxcap_1609_fail
    ($I12, $I11) = rx1604_cur."!mark_peek"($I10)
    rx1604_cur."!cursor_pos"($I11)
    ($P10) = rx1604_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1604_pos, "")
    rx1604_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1609_done
  rxcap_1609_fail:
    goto rx1604_fail
  rxcap_1609_done:
  # rx subrule "O" subtype=capture negate=
    rx1604_cur."!cursor_pos"(rx1604_pos)
    $P10 = rx1604_cur."O"("%relational, :pirop<isgt INn>")
    unless $P10, rx1604_fail
    rx1604_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1604_pos = $P10."pos"()
  # rx pass
    rx1604_cur."!cursor_pass"(rx1604_pos, "infix:sym<>>")
    if_null rx1604_debug, debug_1310
    rx1604_cur."!cursor_debug"("PASS", "infix:sym<>>", " at pos=", rx1604_pos)
  debug_1310:
    .return (rx1604_cur)
  rx1604_restart:
.annotate 'line', 10
    if_null rx1604_debug, debug_1311
    rx1604_cur."!cursor_debug"("NEXT", "infix:sym<>>")
  debug_1311:
  rx1604_fail:
    (rx1604_rep, rx1604_pos, $I10, $P10) = rx1604_cur."!mark_fail"(0)
    lt rx1604_pos, -1, rx1604_done
    eq rx1604_pos, -1, rx1604_fail
    jump $I10
  rx1604_done:
    rx1604_cur."!cursor_fail"()
    if_null rx1604_debug, debug_1312
    rx1604_cur."!cursor_debug"("FAIL", "infix:sym<>>")
  debug_1312:
    .return (rx1604_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>>"  :nsentry("!PREFIX__infix:sym<>>") :subid("338_1303401201.841") :method
.annotate 'line', 10
    $P1606 = self."!PREFIX__!subrule"("O", ">")
    new $P1607, "ResizablePMCArray"
    push $P1607, $P1606
    .return ($P1607)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<eq>"  :subid("339_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1611_tgt
    .local int rx1611_pos
    .local int rx1611_off
    .local int rx1611_eos
    .local int rx1611_rep
    .local pmc rx1611_cur
    .local pmc rx1611_debug
    (rx1611_cur, rx1611_pos, rx1611_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1611_cur
    .local pmc match
    .lex "$/", match
    length rx1611_eos, rx1611_tgt
    gt rx1611_pos, rx1611_eos, rx1611_done
    set rx1611_off, 0
    lt rx1611_pos, 2, rx1611_start
    sub rx1611_off, rx1611_pos, 1
    substr rx1611_tgt, rx1611_tgt, rx1611_off
  rx1611_start:
    eq $I10, 1, rx1611_restart
    if_null rx1611_debug, debug_1313
    rx1611_cur."!cursor_debug"("START", "infix:sym<eq>")
  debug_1313:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1615_done
    goto rxscan1615_scan
  rxscan1615_loop:
    (rx1611_pos) = rx1611_cur."from"()
    inc rx1611_pos
    rx1611_cur."!cursor_from"(rx1611_pos)
    ge rx1611_pos, rx1611_eos, rxscan1615_done
  rxscan1615_scan:
    set_addr $I10, rxscan1615_loop
    rx1611_cur."!mark_push"(0, rx1611_pos, $I10)
  rxscan1615_done:
.annotate 'line', 685
  # rx subcapture "sym"
    set_addr $I10, rxcap_1616_fail
    rx1611_cur."!mark_push"(0, rx1611_pos, $I10)
  # rx literal  "eq"
    add $I11, rx1611_pos, 2
    gt $I11, rx1611_eos, rx1611_fail
    sub $I11, rx1611_pos, rx1611_off
    substr $S10, rx1611_tgt, $I11, 2
    ne $S10, "eq", rx1611_fail
    add rx1611_pos, 2
    set_addr $I10, rxcap_1616_fail
    ($I12, $I11) = rx1611_cur."!mark_peek"($I10)
    rx1611_cur."!cursor_pos"($I11)
    ($P10) = rx1611_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1611_pos, "")
    rx1611_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1616_done
  rxcap_1616_fail:
    goto rx1611_fail
  rxcap_1616_done:
  # rx subrule "O" subtype=capture negate=
    rx1611_cur."!cursor_pos"(rx1611_pos)
    $P10 = rx1611_cur."O"("%relational, :pirop<iseq ISs>")
    unless $P10, rx1611_fail
    rx1611_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1611_pos = $P10."pos"()
  # rx pass
    rx1611_cur."!cursor_pass"(rx1611_pos, "infix:sym<eq>")
    if_null rx1611_debug, debug_1314
    rx1611_cur."!cursor_debug"("PASS", "infix:sym<eq>", " at pos=", rx1611_pos)
  debug_1314:
    .return (rx1611_cur)
  rx1611_restart:
.annotate 'line', 10
    if_null rx1611_debug, debug_1315
    rx1611_cur."!cursor_debug"("NEXT", "infix:sym<eq>")
  debug_1315:
  rx1611_fail:
    (rx1611_rep, rx1611_pos, $I10, $P10) = rx1611_cur."!mark_fail"(0)
    lt rx1611_pos, -1, rx1611_done
    eq rx1611_pos, -1, rx1611_fail
    jump $I10
  rx1611_done:
    rx1611_cur."!cursor_fail"()
    if_null rx1611_debug, debug_1316
    rx1611_cur."!cursor_debug"("FAIL", "infix:sym<eq>")
  debug_1316:
    .return (rx1611_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<eq>"  :nsentry("!PREFIX__infix:sym<eq>") :subid("340_1303401201.841") :method
.annotate 'line', 10
    $P1613 = self."!PREFIX__!subrule"("O", "eq")
    new $P1614, "ResizablePMCArray"
    push $P1614, $P1613
    .return ($P1614)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ne>"  :subid("341_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1618_tgt
    .local int rx1618_pos
    .local int rx1618_off
    .local int rx1618_eos
    .local int rx1618_rep
    .local pmc rx1618_cur
    .local pmc rx1618_debug
    (rx1618_cur, rx1618_pos, rx1618_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1618_cur
    .local pmc match
    .lex "$/", match
    length rx1618_eos, rx1618_tgt
    gt rx1618_pos, rx1618_eos, rx1618_done
    set rx1618_off, 0
    lt rx1618_pos, 2, rx1618_start
    sub rx1618_off, rx1618_pos, 1
    substr rx1618_tgt, rx1618_tgt, rx1618_off
  rx1618_start:
    eq $I10, 1, rx1618_restart
    if_null rx1618_debug, debug_1317
    rx1618_cur."!cursor_debug"("START", "infix:sym<ne>")
  debug_1317:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1622_done
    goto rxscan1622_scan
  rxscan1622_loop:
    (rx1618_pos) = rx1618_cur."from"()
    inc rx1618_pos
    rx1618_cur."!cursor_from"(rx1618_pos)
    ge rx1618_pos, rx1618_eos, rxscan1622_done
  rxscan1622_scan:
    set_addr $I10, rxscan1622_loop
    rx1618_cur."!mark_push"(0, rx1618_pos, $I10)
  rxscan1622_done:
.annotate 'line', 686
  # rx subcapture "sym"
    set_addr $I10, rxcap_1623_fail
    rx1618_cur."!mark_push"(0, rx1618_pos, $I10)
  # rx literal  "ne"
    add $I11, rx1618_pos, 2
    gt $I11, rx1618_eos, rx1618_fail
    sub $I11, rx1618_pos, rx1618_off
    substr $S10, rx1618_tgt, $I11, 2
    ne $S10, "ne", rx1618_fail
    add rx1618_pos, 2
    set_addr $I10, rxcap_1623_fail
    ($I12, $I11) = rx1618_cur."!mark_peek"($I10)
    rx1618_cur."!cursor_pos"($I11)
    ($P10) = rx1618_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1618_pos, "")
    rx1618_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1623_done
  rxcap_1623_fail:
    goto rx1618_fail
  rxcap_1623_done:
  # rx subrule "O" subtype=capture negate=
    rx1618_cur."!cursor_pos"(rx1618_pos)
    $P10 = rx1618_cur."O"("%relational, :pirop<isne ISs>")
    unless $P10, rx1618_fail
    rx1618_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1618_pos = $P10."pos"()
  # rx pass
    rx1618_cur."!cursor_pass"(rx1618_pos, "infix:sym<ne>")
    if_null rx1618_debug, debug_1318
    rx1618_cur."!cursor_debug"("PASS", "infix:sym<ne>", " at pos=", rx1618_pos)
  debug_1318:
    .return (rx1618_cur)
  rx1618_restart:
.annotate 'line', 10
    if_null rx1618_debug, debug_1319
    rx1618_cur."!cursor_debug"("NEXT", "infix:sym<ne>")
  debug_1319:
  rx1618_fail:
    (rx1618_rep, rx1618_pos, $I10, $P10) = rx1618_cur."!mark_fail"(0)
    lt rx1618_pos, -1, rx1618_done
    eq rx1618_pos, -1, rx1618_fail
    jump $I10
  rx1618_done:
    rx1618_cur."!cursor_fail"()
    if_null rx1618_debug, debug_1320
    rx1618_cur."!cursor_debug"("FAIL", "infix:sym<ne>")
  debug_1320:
    .return (rx1618_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ne>"  :nsentry("!PREFIX__infix:sym<ne>") :subid("342_1303401201.841") :method
.annotate 'line', 10
    $P1620 = self."!PREFIX__!subrule"("O", "ne")
    new $P1621, "ResizablePMCArray"
    push $P1621, $P1620
    .return ($P1621)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<le>"  :subid("343_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1625_tgt
    .local int rx1625_pos
    .local int rx1625_off
    .local int rx1625_eos
    .local int rx1625_rep
    .local pmc rx1625_cur
    .local pmc rx1625_debug
    (rx1625_cur, rx1625_pos, rx1625_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1625_cur
    .local pmc match
    .lex "$/", match
    length rx1625_eos, rx1625_tgt
    gt rx1625_pos, rx1625_eos, rx1625_done
    set rx1625_off, 0
    lt rx1625_pos, 2, rx1625_start
    sub rx1625_off, rx1625_pos, 1
    substr rx1625_tgt, rx1625_tgt, rx1625_off
  rx1625_start:
    eq $I10, 1, rx1625_restart
    if_null rx1625_debug, debug_1321
    rx1625_cur."!cursor_debug"("START", "infix:sym<le>")
  debug_1321:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1629_done
    goto rxscan1629_scan
  rxscan1629_loop:
    (rx1625_pos) = rx1625_cur."from"()
    inc rx1625_pos
    rx1625_cur."!cursor_from"(rx1625_pos)
    ge rx1625_pos, rx1625_eos, rxscan1629_done
  rxscan1629_scan:
    set_addr $I10, rxscan1629_loop
    rx1625_cur."!mark_push"(0, rx1625_pos, $I10)
  rxscan1629_done:
.annotate 'line', 687
  # rx subcapture "sym"
    set_addr $I10, rxcap_1630_fail
    rx1625_cur."!mark_push"(0, rx1625_pos, $I10)
  # rx literal  "le"
    add $I11, rx1625_pos, 2
    gt $I11, rx1625_eos, rx1625_fail
    sub $I11, rx1625_pos, rx1625_off
    substr $S10, rx1625_tgt, $I11, 2
    ne $S10, "le", rx1625_fail
    add rx1625_pos, 2
    set_addr $I10, rxcap_1630_fail
    ($I12, $I11) = rx1625_cur."!mark_peek"($I10)
    rx1625_cur."!cursor_pos"($I11)
    ($P10) = rx1625_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1625_pos, "")
    rx1625_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1630_done
  rxcap_1630_fail:
    goto rx1625_fail
  rxcap_1630_done:
  # rx subrule "O" subtype=capture negate=
    rx1625_cur."!cursor_pos"(rx1625_pos)
    $P10 = rx1625_cur."O"("%relational, :pirop<isle ISs>")
    unless $P10, rx1625_fail
    rx1625_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1625_pos = $P10."pos"()
  # rx pass
    rx1625_cur."!cursor_pass"(rx1625_pos, "infix:sym<le>")
    if_null rx1625_debug, debug_1322
    rx1625_cur."!cursor_debug"("PASS", "infix:sym<le>", " at pos=", rx1625_pos)
  debug_1322:
    .return (rx1625_cur)
  rx1625_restart:
.annotate 'line', 10
    if_null rx1625_debug, debug_1323
    rx1625_cur."!cursor_debug"("NEXT", "infix:sym<le>")
  debug_1323:
  rx1625_fail:
    (rx1625_rep, rx1625_pos, $I10, $P10) = rx1625_cur."!mark_fail"(0)
    lt rx1625_pos, -1, rx1625_done
    eq rx1625_pos, -1, rx1625_fail
    jump $I10
  rx1625_done:
    rx1625_cur."!cursor_fail"()
    if_null rx1625_debug, debug_1324
    rx1625_cur."!cursor_debug"("FAIL", "infix:sym<le>")
  debug_1324:
    .return (rx1625_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<le>"  :nsentry("!PREFIX__infix:sym<le>") :subid("344_1303401201.841") :method
.annotate 'line', 10
    $P1627 = self."!PREFIX__!subrule"("O", "le")
    new $P1628, "ResizablePMCArray"
    push $P1628, $P1627
    .return ($P1628)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ge>"  :subid("345_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1632_tgt
    .local int rx1632_pos
    .local int rx1632_off
    .local int rx1632_eos
    .local int rx1632_rep
    .local pmc rx1632_cur
    .local pmc rx1632_debug
    (rx1632_cur, rx1632_pos, rx1632_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1632_cur
    .local pmc match
    .lex "$/", match
    length rx1632_eos, rx1632_tgt
    gt rx1632_pos, rx1632_eos, rx1632_done
    set rx1632_off, 0
    lt rx1632_pos, 2, rx1632_start
    sub rx1632_off, rx1632_pos, 1
    substr rx1632_tgt, rx1632_tgt, rx1632_off
  rx1632_start:
    eq $I10, 1, rx1632_restart
    if_null rx1632_debug, debug_1325
    rx1632_cur."!cursor_debug"("START", "infix:sym<ge>")
  debug_1325:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1636_done
    goto rxscan1636_scan
  rxscan1636_loop:
    (rx1632_pos) = rx1632_cur."from"()
    inc rx1632_pos
    rx1632_cur."!cursor_from"(rx1632_pos)
    ge rx1632_pos, rx1632_eos, rxscan1636_done
  rxscan1636_scan:
    set_addr $I10, rxscan1636_loop
    rx1632_cur."!mark_push"(0, rx1632_pos, $I10)
  rxscan1636_done:
.annotate 'line', 688
  # rx subcapture "sym"
    set_addr $I10, rxcap_1637_fail
    rx1632_cur."!mark_push"(0, rx1632_pos, $I10)
  # rx literal  "ge"
    add $I11, rx1632_pos, 2
    gt $I11, rx1632_eos, rx1632_fail
    sub $I11, rx1632_pos, rx1632_off
    substr $S10, rx1632_tgt, $I11, 2
    ne $S10, "ge", rx1632_fail
    add rx1632_pos, 2
    set_addr $I10, rxcap_1637_fail
    ($I12, $I11) = rx1632_cur."!mark_peek"($I10)
    rx1632_cur."!cursor_pos"($I11)
    ($P10) = rx1632_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1632_pos, "")
    rx1632_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1637_done
  rxcap_1637_fail:
    goto rx1632_fail
  rxcap_1637_done:
  # rx subrule "O" subtype=capture negate=
    rx1632_cur."!cursor_pos"(rx1632_pos)
    $P10 = rx1632_cur."O"("%relational, :pirop<isge ISs>")
    unless $P10, rx1632_fail
    rx1632_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1632_pos = $P10."pos"()
  # rx pass
    rx1632_cur."!cursor_pass"(rx1632_pos, "infix:sym<ge>")
    if_null rx1632_debug, debug_1326
    rx1632_cur."!cursor_debug"("PASS", "infix:sym<ge>", " at pos=", rx1632_pos)
  debug_1326:
    .return (rx1632_cur)
  rx1632_restart:
.annotate 'line', 10
    if_null rx1632_debug, debug_1327
    rx1632_cur."!cursor_debug"("NEXT", "infix:sym<ge>")
  debug_1327:
  rx1632_fail:
    (rx1632_rep, rx1632_pos, $I10, $P10) = rx1632_cur."!mark_fail"(0)
    lt rx1632_pos, -1, rx1632_done
    eq rx1632_pos, -1, rx1632_fail
    jump $I10
  rx1632_done:
    rx1632_cur."!cursor_fail"()
    if_null rx1632_debug, debug_1328
    rx1632_cur."!cursor_debug"("FAIL", "infix:sym<ge>")
  debug_1328:
    .return (rx1632_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ge>"  :nsentry("!PREFIX__infix:sym<ge>") :subid("346_1303401201.841") :method
.annotate 'line', 10
    $P1634 = self."!PREFIX__!subrule"("O", "ge")
    new $P1635, "ResizablePMCArray"
    push $P1635, $P1634
    .return ($P1635)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<lt>"  :subid("347_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1639_tgt
    .local int rx1639_pos
    .local int rx1639_off
    .local int rx1639_eos
    .local int rx1639_rep
    .local pmc rx1639_cur
    .local pmc rx1639_debug
    (rx1639_cur, rx1639_pos, rx1639_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1639_cur
    .local pmc match
    .lex "$/", match
    length rx1639_eos, rx1639_tgt
    gt rx1639_pos, rx1639_eos, rx1639_done
    set rx1639_off, 0
    lt rx1639_pos, 2, rx1639_start
    sub rx1639_off, rx1639_pos, 1
    substr rx1639_tgt, rx1639_tgt, rx1639_off
  rx1639_start:
    eq $I10, 1, rx1639_restart
    if_null rx1639_debug, debug_1329
    rx1639_cur."!cursor_debug"("START", "infix:sym<lt>")
  debug_1329:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1643_done
    goto rxscan1643_scan
  rxscan1643_loop:
    (rx1639_pos) = rx1639_cur."from"()
    inc rx1639_pos
    rx1639_cur."!cursor_from"(rx1639_pos)
    ge rx1639_pos, rx1639_eos, rxscan1643_done
  rxscan1643_scan:
    set_addr $I10, rxscan1643_loop
    rx1639_cur."!mark_push"(0, rx1639_pos, $I10)
  rxscan1643_done:
.annotate 'line', 689
  # rx subcapture "sym"
    set_addr $I10, rxcap_1644_fail
    rx1639_cur."!mark_push"(0, rx1639_pos, $I10)
  # rx literal  "lt"
    add $I11, rx1639_pos, 2
    gt $I11, rx1639_eos, rx1639_fail
    sub $I11, rx1639_pos, rx1639_off
    substr $S10, rx1639_tgt, $I11, 2
    ne $S10, "lt", rx1639_fail
    add rx1639_pos, 2
    set_addr $I10, rxcap_1644_fail
    ($I12, $I11) = rx1639_cur."!mark_peek"($I10)
    rx1639_cur."!cursor_pos"($I11)
    ($P10) = rx1639_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1639_pos, "")
    rx1639_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1644_done
  rxcap_1644_fail:
    goto rx1639_fail
  rxcap_1644_done:
  # rx subrule "O" subtype=capture negate=
    rx1639_cur."!cursor_pos"(rx1639_pos)
    $P10 = rx1639_cur."O"("%relational, :pirop<islt ISs>")
    unless $P10, rx1639_fail
    rx1639_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1639_pos = $P10."pos"()
  # rx pass
    rx1639_cur."!cursor_pass"(rx1639_pos, "infix:sym<lt>")
    if_null rx1639_debug, debug_1330
    rx1639_cur."!cursor_debug"("PASS", "infix:sym<lt>", " at pos=", rx1639_pos)
  debug_1330:
    .return (rx1639_cur)
  rx1639_restart:
.annotate 'line', 10
    if_null rx1639_debug, debug_1331
    rx1639_cur."!cursor_debug"("NEXT", "infix:sym<lt>")
  debug_1331:
  rx1639_fail:
    (rx1639_rep, rx1639_pos, $I10, $P10) = rx1639_cur."!mark_fail"(0)
    lt rx1639_pos, -1, rx1639_done
    eq rx1639_pos, -1, rx1639_fail
    jump $I10
  rx1639_done:
    rx1639_cur."!cursor_fail"()
    if_null rx1639_debug, debug_1332
    rx1639_cur."!cursor_debug"("FAIL", "infix:sym<lt>")
  debug_1332:
    .return (rx1639_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<lt>"  :nsentry("!PREFIX__infix:sym<lt>") :subid("348_1303401201.841") :method
.annotate 'line', 10
    $P1641 = self."!PREFIX__!subrule"("O", "lt")
    new $P1642, "ResizablePMCArray"
    push $P1642, $P1641
    .return ($P1642)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<gt>"  :subid("349_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1646_tgt
    .local int rx1646_pos
    .local int rx1646_off
    .local int rx1646_eos
    .local int rx1646_rep
    .local pmc rx1646_cur
    .local pmc rx1646_debug
    (rx1646_cur, rx1646_pos, rx1646_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1646_cur
    .local pmc match
    .lex "$/", match
    length rx1646_eos, rx1646_tgt
    gt rx1646_pos, rx1646_eos, rx1646_done
    set rx1646_off, 0
    lt rx1646_pos, 2, rx1646_start
    sub rx1646_off, rx1646_pos, 1
    substr rx1646_tgt, rx1646_tgt, rx1646_off
  rx1646_start:
    eq $I10, 1, rx1646_restart
    if_null rx1646_debug, debug_1333
    rx1646_cur."!cursor_debug"("START", "infix:sym<gt>")
  debug_1333:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1650_done
    goto rxscan1650_scan
  rxscan1650_loop:
    (rx1646_pos) = rx1646_cur."from"()
    inc rx1646_pos
    rx1646_cur."!cursor_from"(rx1646_pos)
    ge rx1646_pos, rx1646_eos, rxscan1650_done
  rxscan1650_scan:
    set_addr $I10, rxscan1650_loop
    rx1646_cur."!mark_push"(0, rx1646_pos, $I10)
  rxscan1650_done:
.annotate 'line', 690
  # rx subcapture "sym"
    set_addr $I10, rxcap_1651_fail
    rx1646_cur."!mark_push"(0, rx1646_pos, $I10)
  # rx literal  "gt"
    add $I11, rx1646_pos, 2
    gt $I11, rx1646_eos, rx1646_fail
    sub $I11, rx1646_pos, rx1646_off
    substr $S10, rx1646_tgt, $I11, 2
    ne $S10, "gt", rx1646_fail
    add rx1646_pos, 2
    set_addr $I10, rxcap_1651_fail
    ($I12, $I11) = rx1646_cur."!mark_peek"($I10)
    rx1646_cur."!cursor_pos"($I11)
    ($P10) = rx1646_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1646_pos, "")
    rx1646_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1651_done
  rxcap_1651_fail:
    goto rx1646_fail
  rxcap_1651_done:
  # rx subrule "O" subtype=capture negate=
    rx1646_cur."!cursor_pos"(rx1646_pos)
    $P10 = rx1646_cur."O"("%relational, :pirop<isgt ISs>")
    unless $P10, rx1646_fail
    rx1646_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1646_pos = $P10."pos"()
  # rx pass
    rx1646_cur."!cursor_pass"(rx1646_pos, "infix:sym<gt>")
    if_null rx1646_debug, debug_1334
    rx1646_cur."!cursor_debug"("PASS", "infix:sym<gt>", " at pos=", rx1646_pos)
  debug_1334:
    .return (rx1646_cur)
  rx1646_restart:
.annotate 'line', 10
    if_null rx1646_debug, debug_1335
    rx1646_cur."!cursor_debug"("NEXT", "infix:sym<gt>")
  debug_1335:
  rx1646_fail:
    (rx1646_rep, rx1646_pos, $I10, $P10) = rx1646_cur."!mark_fail"(0)
    lt rx1646_pos, -1, rx1646_done
    eq rx1646_pos, -1, rx1646_fail
    jump $I10
  rx1646_done:
    rx1646_cur."!cursor_fail"()
    if_null rx1646_debug, debug_1336
    rx1646_cur."!cursor_debug"("FAIL", "infix:sym<gt>")
  debug_1336:
    .return (rx1646_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<gt>"  :nsentry("!PREFIX__infix:sym<gt>") :subid("350_1303401201.841") :method
.annotate 'line', 10
    $P1648 = self."!PREFIX__!subrule"("O", "gt")
    new $P1649, "ResizablePMCArray"
    push $P1649, $P1648
    .return ($P1649)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=:=>"  :subid("351_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1653_tgt
    .local int rx1653_pos
    .local int rx1653_off
    .local int rx1653_eos
    .local int rx1653_rep
    .local pmc rx1653_cur
    .local pmc rx1653_debug
    (rx1653_cur, rx1653_pos, rx1653_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1653_cur
    .local pmc match
    .lex "$/", match
    length rx1653_eos, rx1653_tgt
    gt rx1653_pos, rx1653_eos, rx1653_done
    set rx1653_off, 0
    lt rx1653_pos, 2, rx1653_start
    sub rx1653_off, rx1653_pos, 1
    substr rx1653_tgt, rx1653_tgt, rx1653_off
  rx1653_start:
    eq $I10, 1, rx1653_restart
    if_null rx1653_debug, debug_1337
    rx1653_cur."!cursor_debug"("START", "infix:sym<=:=>")
  debug_1337:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1657_done
    goto rxscan1657_scan
  rxscan1657_loop:
    (rx1653_pos) = rx1653_cur."from"()
    inc rx1653_pos
    rx1653_cur."!cursor_from"(rx1653_pos)
    ge rx1653_pos, rx1653_eos, rxscan1657_done
  rxscan1657_scan:
    set_addr $I10, rxscan1657_loop
    rx1653_cur."!mark_push"(0, rx1653_pos, $I10)
  rxscan1657_done:
.annotate 'line', 691
  # rx subcapture "sym"
    set_addr $I10, rxcap_1658_fail
    rx1653_cur."!mark_push"(0, rx1653_pos, $I10)
  # rx literal  "=:="
    add $I11, rx1653_pos, 3
    gt $I11, rx1653_eos, rx1653_fail
    sub $I11, rx1653_pos, rx1653_off
    substr $S10, rx1653_tgt, $I11, 3
    ne $S10, "=:=", rx1653_fail
    add rx1653_pos, 3
    set_addr $I10, rxcap_1658_fail
    ($I12, $I11) = rx1653_cur."!mark_peek"($I10)
    rx1653_cur."!cursor_pos"($I11)
    ($P10) = rx1653_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1653_pos, "")
    rx1653_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1658_done
  rxcap_1658_fail:
    goto rx1653_fail
  rxcap_1658_done:
  # rx subrule "O" subtype=capture negate=
    rx1653_cur."!cursor_pos"(rx1653_pos)
    $P10 = rx1653_cur."O"("%relational, :pirop<issame>")
    unless $P10, rx1653_fail
    rx1653_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1653_pos = $P10."pos"()
  # rx pass
    rx1653_cur."!cursor_pass"(rx1653_pos, "infix:sym<=:=>")
    if_null rx1653_debug, debug_1338
    rx1653_cur."!cursor_debug"("PASS", "infix:sym<=:=>", " at pos=", rx1653_pos)
  debug_1338:
    .return (rx1653_cur)
  rx1653_restart:
.annotate 'line', 10
    if_null rx1653_debug, debug_1339
    rx1653_cur."!cursor_debug"("NEXT", "infix:sym<=:=>")
  debug_1339:
  rx1653_fail:
    (rx1653_rep, rx1653_pos, $I10, $P10) = rx1653_cur."!mark_fail"(0)
    lt rx1653_pos, -1, rx1653_done
    eq rx1653_pos, -1, rx1653_fail
    jump $I10
  rx1653_done:
    rx1653_cur."!cursor_fail"()
    if_null rx1653_debug, debug_1340
    rx1653_cur."!cursor_debug"("FAIL", "infix:sym<=:=>")
  debug_1340:
    .return (rx1653_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=:=>"  :nsentry("!PREFIX__infix:sym<=:=>") :subid("352_1303401201.841") :method
.annotate 'line', 10
    $P1655 = self."!PREFIX__!subrule"("O", "=:=")
    new $P1656, "ResizablePMCArray"
    push $P1656, $P1655
    .return ($P1656)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~~>"  :subid("353_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1660_tgt
    .local int rx1660_pos
    .local int rx1660_off
    .local int rx1660_eos
    .local int rx1660_rep
    .local pmc rx1660_cur
    .local pmc rx1660_debug
    (rx1660_cur, rx1660_pos, rx1660_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1660_cur
    .local pmc match
    .lex "$/", match
    length rx1660_eos, rx1660_tgt
    gt rx1660_pos, rx1660_eos, rx1660_done
    set rx1660_off, 0
    lt rx1660_pos, 2, rx1660_start
    sub rx1660_off, rx1660_pos, 1
    substr rx1660_tgt, rx1660_tgt, rx1660_off
  rx1660_start:
    eq $I10, 1, rx1660_restart
    if_null rx1660_debug, debug_1341
    rx1660_cur."!cursor_debug"("START", "infix:sym<~~>")
  debug_1341:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1664_done
    goto rxscan1664_scan
  rxscan1664_loop:
    (rx1660_pos) = rx1660_cur."from"()
    inc rx1660_pos
    rx1660_cur."!cursor_from"(rx1660_pos)
    ge rx1660_pos, rx1660_eos, rxscan1664_done
  rxscan1664_scan:
    set_addr $I10, rxscan1664_loop
    rx1660_cur."!mark_push"(0, rx1660_pos, $I10)
  rxscan1664_done:
.annotate 'line', 692
  # rx subcapture "sym"
    set_addr $I10, rxcap_1665_fail
    rx1660_cur."!mark_push"(0, rx1660_pos, $I10)
  # rx literal  "~~"
    add $I11, rx1660_pos, 2
    gt $I11, rx1660_eos, rx1660_fail
    sub $I11, rx1660_pos, rx1660_off
    substr $S10, rx1660_tgt, $I11, 2
    ne $S10, "~~", rx1660_fail
    add rx1660_pos, 2
    set_addr $I10, rxcap_1665_fail
    ($I12, $I11) = rx1660_cur."!mark_peek"($I10)
    rx1660_cur."!cursor_pos"($I11)
    ($P10) = rx1660_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1660_pos, "")
    rx1660_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1665_done
  rxcap_1665_fail:
    goto rx1660_fail
  rxcap_1665_done:
  # rx subrule "O" subtype=capture negate=
    rx1660_cur."!cursor_pos"(rx1660_pos)
    $P10 = rx1660_cur."O"("%relational, :reducecheck<smartmatch>")
    unless $P10, rx1660_fail
    rx1660_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1660_pos = $P10."pos"()
  # rx pass
    rx1660_cur."!cursor_pass"(rx1660_pos, "infix:sym<~~>")
    if_null rx1660_debug, debug_1342
    rx1660_cur."!cursor_debug"("PASS", "infix:sym<~~>", " at pos=", rx1660_pos)
  debug_1342:
    .return (rx1660_cur)
  rx1660_restart:
.annotate 'line', 10
    if_null rx1660_debug, debug_1343
    rx1660_cur."!cursor_debug"("NEXT", "infix:sym<~~>")
  debug_1343:
  rx1660_fail:
    (rx1660_rep, rx1660_pos, $I10, $P10) = rx1660_cur."!mark_fail"(0)
    lt rx1660_pos, -1, rx1660_done
    eq rx1660_pos, -1, rx1660_fail
    jump $I10
  rx1660_done:
    rx1660_cur."!cursor_fail"()
    if_null rx1660_debug, debug_1344
    rx1660_cur."!cursor_debug"("FAIL", "infix:sym<~~>")
  debug_1344:
    .return (rx1660_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~~>"  :nsentry("!PREFIX__infix:sym<~~>") :subid("354_1303401201.841") :method
.annotate 'line', 10
    $P1662 = self."!PREFIX__!subrule"("O", "~~")
    new $P1663, "ResizablePMCArray"
    push $P1663, $P1662
    .return ($P1663)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<&&>"  :subid("355_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1667_tgt
    .local int rx1667_pos
    .local int rx1667_off
    .local int rx1667_eos
    .local int rx1667_rep
    .local pmc rx1667_cur
    .local pmc rx1667_debug
    (rx1667_cur, rx1667_pos, rx1667_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1667_cur
    .local pmc match
    .lex "$/", match
    length rx1667_eos, rx1667_tgt
    gt rx1667_pos, rx1667_eos, rx1667_done
    set rx1667_off, 0
    lt rx1667_pos, 2, rx1667_start
    sub rx1667_off, rx1667_pos, 1
    substr rx1667_tgt, rx1667_tgt, rx1667_off
  rx1667_start:
    eq $I10, 1, rx1667_restart
    if_null rx1667_debug, debug_1345
    rx1667_cur."!cursor_debug"("START", "infix:sym<&&>")
  debug_1345:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1671_done
    goto rxscan1671_scan
  rxscan1671_loop:
    (rx1667_pos) = rx1667_cur."from"()
    inc rx1667_pos
    rx1667_cur."!cursor_from"(rx1667_pos)
    ge rx1667_pos, rx1667_eos, rxscan1671_done
  rxscan1671_scan:
    set_addr $I10, rxscan1671_loop
    rx1667_cur."!mark_push"(0, rx1667_pos, $I10)
  rxscan1671_done:
.annotate 'line', 694
  # rx subcapture "sym"
    set_addr $I10, rxcap_1672_fail
    rx1667_cur."!mark_push"(0, rx1667_pos, $I10)
  # rx literal  "&&"
    add $I11, rx1667_pos, 2
    gt $I11, rx1667_eos, rx1667_fail
    sub $I11, rx1667_pos, rx1667_off
    substr $S10, rx1667_tgt, $I11, 2
    ne $S10, "&&", rx1667_fail
    add rx1667_pos, 2
    set_addr $I10, rxcap_1672_fail
    ($I12, $I11) = rx1667_cur."!mark_peek"($I10)
    rx1667_cur."!cursor_pos"($I11)
    ($P10) = rx1667_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1667_pos, "")
    rx1667_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1672_done
  rxcap_1672_fail:
    goto rx1667_fail
  rxcap_1672_done:
  # rx subrule "O" subtype=capture negate=
    rx1667_cur."!cursor_pos"(rx1667_pos)
    $P10 = rx1667_cur."O"("%tight_and, :pasttype<if>")
    unless $P10, rx1667_fail
    rx1667_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1667_pos = $P10."pos"()
  # rx pass
    rx1667_cur."!cursor_pass"(rx1667_pos, "infix:sym<&&>")
    if_null rx1667_debug, debug_1346
    rx1667_cur."!cursor_debug"("PASS", "infix:sym<&&>", " at pos=", rx1667_pos)
  debug_1346:
    .return (rx1667_cur)
  rx1667_restart:
.annotate 'line', 10
    if_null rx1667_debug, debug_1347
    rx1667_cur."!cursor_debug"("NEXT", "infix:sym<&&>")
  debug_1347:
  rx1667_fail:
    (rx1667_rep, rx1667_pos, $I10, $P10) = rx1667_cur."!mark_fail"(0)
    lt rx1667_pos, -1, rx1667_done
    eq rx1667_pos, -1, rx1667_fail
    jump $I10
  rx1667_done:
    rx1667_cur."!cursor_fail"()
    if_null rx1667_debug, debug_1348
    rx1667_cur."!cursor_debug"("FAIL", "infix:sym<&&>")
  debug_1348:
    .return (rx1667_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<&&>"  :nsentry("!PREFIX__infix:sym<&&>") :subid("356_1303401201.841") :method
.annotate 'line', 10
    $P1669 = self."!PREFIX__!subrule"("O", "&&")
    new $P1670, "ResizablePMCArray"
    push $P1670, $P1669
    .return ($P1670)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<||>"  :subid("357_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1674_tgt
    .local int rx1674_pos
    .local int rx1674_off
    .local int rx1674_eos
    .local int rx1674_rep
    .local pmc rx1674_cur
    .local pmc rx1674_debug
    (rx1674_cur, rx1674_pos, rx1674_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1674_cur
    .local pmc match
    .lex "$/", match
    length rx1674_eos, rx1674_tgt
    gt rx1674_pos, rx1674_eos, rx1674_done
    set rx1674_off, 0
    lt rx1674_pos, 2, rx1674_start
    sub rx1674_off, rx1674_pos, 1
    substr rx1674_tgt, rx1674_tgt, rx1674_off
  rx1674_start:
    eq $I10, 1, rx1674_restart
    if_null rx1674_debug, debug_1349
    rx1674_cur."!cursor_debug"("START", "infix:sym<||>")
  debug_1349:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1678_done
    goto rxscan1678_scan
  rxscan1678_loop:
    (rx1674_pos) = rx1674_cur."from"()
    inc rx1674_pos
    rx1674_cur."!cursor_from"(rx1674_pos)
    ge rx1674_pos, rx1674_eos, rxscan1678_done
  rxscan1678_scan:
    set_addr $I10, rxscan1678_loop
    rx1674_cur."!mark_push"(0, rx1674_pos, $I10)
  rxscan1678_done:
.annotate 'line', 696
  # rx subcapture "sym"
    set_addr $I10, rxcap_1679_fail
    rx1674_cur."!mark_push"(0, rx1674_pos, $I10)
  # rx literal  "||"
    add $I11, rx1674_pos, 2
    gt $I11, rx1674_eos, rx1674_fail
    sub $I11, rx1674_pos, rx1674_off
    substr $S10, rx1674_tgt, $I11, 2
    ne $S10, "||", rx1674_fail
    add rx1674_pos, 2
    set_addr $I10, rxcap_1679_fail
    ($I12, $I11) = rx1674_cur."!mark_peek"($I10)
    rx1674_cur."!cursor_pos"($I11)
    ($P10) = rx1674_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1674_pos, "")
    rx1674_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1679_done
  rxcap_1679_fail:
    goto rx1674_fail
  rxcap_1679_done:
  # rx subrule "O" subtype=capture negate=
    rx1674_cur."!cursor_pos"(rx1674_pos)
    $P10 = rx1674_cur."O"("%tight_or, :pasttype<unless>")
    unless $P10, rx1674_fail
    rx1674_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1674_pos = $P10."pos"()
  # rx pass
    rx1674_cur."!cursor_pass"(rx1674_pos, "infix:sym<||>")
    if_null rx1674_debug, debug_1350
    rx1674_cur."!cursor_debug"("PASS", "infix:sym<||>", " at pos=", rx1674_pos)
  debug_1350:
    .return (rx1674_cur)
  rx1674_restart:
.annotate 'line', 10
    if_null rx1674_debug, debug_1351
    rx1674_cur."!cursor_debug"("NEXT", "infix:sym<||>")
  debug_1351:
  rx1674_fail:
    (rx1674_rep, rx1674_pos, $I10, $P10) = rx1674_cur."!mark_fail"(0)
    lt rx1674_pos, -1, rx1674_done
    eq rx1674_pos, -1, rx1674_fail
    jump $I10
  rx1674_done:
    rx1674_cur."!cursor_fail"()
    if_null rx1674_debug, debug_1352
    rx1674_cur."!cursor_debug"("FAIL", "infix:sym<||>")
  debug_1352:
    .return (rx1674_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<||>"  :nsentry("!PREFIX__infix:sym<||>") :subid("358_1303401201.841") :method
.annotate 'line', 10
    $P1676 = self."!PREFIX__!subrule"("O", "||")
    new $P1677, "ResizablePMCArray"
    push $P1677, $P1676
    .return ($P1677)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<//>"  :subid("359_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1681_tgt
    .local int rx1681_pos
    .local int rx1681_off
    .local int rx1681_eos
    .local int rx1681_rep
    .local pmc rx1681_cur
    .local pmc rx1681_debug
    (rx1681_cur, rx1681_pos, rx1681_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1681_cur
    .local pmc match
    .lex "$/", match
    length rx1681_eos, rx1681_tgt
    gt rx1681_pos, rx1681_eos, rx1681_done
    set rx1681_off, 0
    lt rx1681_pos, 2, rx1681_start
    sub rx1681_off, rx1681_pos, 1
    substr rx1681_tgt, rx1681_tgt, rx1681_off
  rx1681_start:
    eq $I10, 1, rx1681_restart
    if_null rx1681_debug, debug_1353
    rx1681_cur."!cursor_debug"("START", "infix:sym<//>")
  debug_1353:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1685_done
    goto rxscan1685_scan
  rxscan1685_loop:
    (rx1681_pos) = rx1681_cur."from"()
    inc rx1681_pos
    rx1681_cur."!cursor_from"(rx1681_pos)
    ge rx1681_pos, rx1681_eos, rxscan1685_done
  rxscan1685_scan:
    set_addr $I10, rxscan1685_loop
    rx1681_cur."!mark_push"(0, rx1681_pos, $I10)
  rxscan1685_done:
.annotate 'line', 697
  # rx subcapture "sym"
    set_addr $I10, rxcap_1686_fail
    rx1681_cur."!mark_push"(0, rx1681_pos, $I10)
  # rx literal  "//"
    add $I11, rx1681_pos, 2
    gt $I11, rx1681_eos, rx1681_fail
    sub $I11, rx1681_pos, rx1681_off
    substr $S10, rx1681_tgt, $I11, 2
    ne $S10, "//", rx1681_fail
    add rx1681_pos, 2
    set_addr $I10, rxcap_1686_fail
    ($I12, $I11) = rx1681_cur."!mark_peek"($I10)
    rx1681_cur."!cursor_pos"($I11)
    ($P10) = rx1681_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1681_pos, "")
    rx1681_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1686_done
  rxcap_1686_fail:
    goto rx1681_fail
  rxcap_1686_done:
  # rx subrule "O" subtype=capture negate=
    rx1681_cur."!cursor_pos"(rx1681_pos)
    $P10 = rx1681_cur."O"("%tight_or, :pasttype<def_or>")
    unless $P10, rx1681_fail
    rx1681_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1681_pos = $P10."pos"()
  # rx pass
    rx1681_cur."!cursor_pass"(rx1681_pos, "infix:sym<//>")
    if_null rx1681_debug, debug_1354
    rx1681_cur."!cursor_debug"("PASS", "infix:sym<//>", " at pos=", rx1681_pos)
  debug_1354:
    .return (rx1681_cur)
  rx1681_restart:
.annotate 'line', 10
    if_null rx1681_debug, debug_1355
    rx1681_cur."!cursor_debug"("NEXT", "infix:sym<//>")
  debug_1355:
  rx1681_fail:
    (rx1681_rep, rx1681_pos, $I10, $P10) = rx1681_cur."!mark_fail"(0)
    lt rx1681_pos, -1, rx1681_done
    eq rx1681_pos, -1, rx1681_fail
    jump $I10
  rx1681_done:
    rx1681_cur."!cursor_fail"()
    if_null rx1681_debug, debug_1356
    rx1681_cur."!cursor_debug"("FAIL", "infix:sym<//>")
  debug_1356:
    .return (rx1681_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<//>"  :nsentry("!PREFIX__infix:sym<//>") :subid("360_1303401201.841") :method
.annotate 'line', 10
    $P1683 = self."!PREFIX__!subrule"("O", "//")
    new $P1684, "ResizablePMCArray"
    push $P1684, $P1683
    .return ($P1684)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<?? !!>"  :subid("361_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1688_tgt
    .local int rx1688_pos
    .local int rx1688_off
    .local int rx1688_eos
    .local int rx1688_rep
    .local pmc rx1688_cur
    .local pmc rx1688_debug
    (rx1688_cur, rx1688_pos, rx1688_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1688_cur
    .local pmc match
    .lex "$/", match
    length rx1688_eos, rx1688_tgt
    gt rx1688_pos, rx1688_eos, rx1688_done
    set rx1688_off, 0
    lt rx1688_pos, 2, rx1688_start
    sub rx1688_off, rx1688_pos, 1
    substr rx1688_tgt, rx1688_tgt, rx1688_off
  rx1688_start:
    eq $I10, 1, rx1688_restart
    if_null rx1688_debug, debug_1357
    rx1688_cur."!cursor_debug"("START", "infix:sym<?? !!>")
  debug_1357:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1692_done
    goto rxscan1692_scan
  rxscan1692_loop:
    (rx1688_pos) = rx1688_cur."from"()
    inc rx1688_pos
    rx1688_cur."!cursor_from"(rx1688_pos)
    ge rx1688_pos, rx1688_eos, rxscan1692_done
  rxscan1692_scan:
    set_addr $I10, rxscan1692_loop
    rx1688_cur."!mark_push"(0, rx1688_pos, $I10)
  rxscan1692_done:
.annotate 'line', 700
  # rx literal  "??"
    add $I11, rx1688_pos, 2
    gt $I11, rx1688_eos, rx1688_fail
    sub $I11, rx1688_pos, rx1688_off
    substr $S10, rx1688_tgt, $I11, 2
    ne $S10, "??", rx1688_fail
    add rx1688_pos, 2
.annotate 'line', 701
  # rx subrule "ws" subtype=method negate=
    rx1688_cur."!cursor_pos"(rx1688_pos)
    $P10 = rx1688_cur."ws"()
    unless $P10, rx1688_fail
    rx1688_pos = $P10."pos"()
.annotate 'line', 702
  # rx subrule "EXPR" subtype=capture negate=
    rx1688_cur."!cursor_pos"(rx1688_pos)
    $P10 = rx1688_cur."EXPR"("i=")
    unless $P10, rx1688_fail
    rx1688_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1688_pos = $P10."pos"()
.annotate 'line', 703
  # rx literal  "!!"
    add $I11, rx1688_pos, 2
    gt $I11, rx1688_eos, rx1688_fail
    sub $I11, rx1688_pos, rx1688_off
    substr $S10, rx1688_tgt, $I11, 2
    ne $S10, "!!", rx1688_fail
    add rx1688_pos, 2
.annotate 'line', 704
  # rx subrule "O" subtype=capture negate=
    rx1688_cur."!cursor_pos"(rx1688_pos)
    $P10 = rx1688_cur."O"("%conditional, :reducecheck<ternary>, :pasttype<if>")
    unless $P10, rx1688_fail
    rx1688_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1688_pos = $P10."pos"()
.annotate 'line', 699
  # rx pass
    rx1688_cur."!cursor_pass"(rx1688_pos, "infix:sym<?? !!>")
    if_null rx1688_debug, debug_1358
    rx1688_cur."!cursor_debug"("PASS", "infix:sym<?? !!>", " at pos=", rx1688_pos)
  debug_1358:
    .return (rx1688_cur)
  rx1688_restart:
.annotate 'line', 10
    if_null rx1688_debug, debug_1359
    rx1688_cur."!cursor_debug"("NEXT", "infix:sym<?? !!>")
  debug_1359:
  rx1688_fail:
    (rx1688_rep, rx1688_pos, $I10, $P10) = rx1688_cur."!mark_fail"(0)
    lt rx1688_pos, -1, rx1688_done
    eq rx1688_pos, -1, rx1688_fail
    jump $I10
  rx1688_done:
    rx1688_cur."!cursor_fail"()
    if_null rx1688_debug, debug_1360
    rx1688_cur."!cursor_debug"("FAIL", "infix:sym<?? !!>")
  debug_1360:
    .return (rx1688_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<?? !!>"  :nsentry("!PREFIX__infix:sym<?? !!>") :subid("362_1303401201.841") :method
.annotate 'line', 10
    $P1690 = self."!PREFIX__!subrule"("ws", "??")
    new $P1691, "ResizablePMCArray"
    push $P1691, $P1690
    .return ($P1691)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=>"  :subid("363_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1694_tgt
    .local int rx1694_pos
    .local int rx1694_off
    .local int rx1694_eos
    .local int rx1694_rep
    .local pmc rx1694_cur
    .local pmc rx1694_debug
    (rx1694_cur, rx1694_pos, rx1694_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1694_cur
    .local pmc match
    .lex "$/", match
    length rx1694_eos, rx1694_tgt
    gt rx1694_pos, rx1694_eos, rx1694_done
    set rx1694_off, 0
    lt rx1694_pos, 2, rx1694_start
    sub rx1694_off, rx1694_pos, 1
    substr rx1694_tgt, rx1694_tgt, rx1694_off
  rx1694_start:
    eq $I10, 1, rx1694_restart
    if_null rx1694_debug, debug_1361
    rx1694_cur."!cursor_debug"("START", "infix:sym<=>")
  debug_1361:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1698_done
    goto rxscan1698_scan
  rxscan1698_loop:
    (rx1694_pos) = rx1694_cur."from"()
    inc rx1694_pos
    rx1694_cur."!cursor_from"(rx1694_pos)
    ge rx1694_pos, rx1694_eos, rxscan1698_done
  rxscan1698_scan:
    set_addr $I10, rxscan1698_loop
    rx1694_cur."!mark_push"(0, rx1694_pos, $I10)
  rxscan1698_done:
.annotate 'line', 708
  # rx subcapture "sym"
    set_addr $I10, rxcap_1699_fail
    rx1694_cur."!mark_push"(0, rx1694_pos, $I10)
  # rx literal  "="
    add $I11, rx1694_pos, 1
    gt $I11, rx1694_eos, rx1694_fail
    sub $I11, rx1694_pos, rx1694_off
    ord $I11, rx1694_tgt, $I11
    ne $I11, 61, rx1694_fail
    add rx1694_pos, 1
    set_addr $I10, rxcap_1699_fail
    ($I12, $I11) = rx1694_cur."!mark_peek"($I10)
    rx1694_cur."!cursor_pos"($I11)
    ($P10) = rx1694_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1694_pos, "")
    rx1694_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1699_done
  rxcap_1699_fail:
    goto rx1694_fail
  rxcap_1699_done:
  # rx subrule "panic" subtype=method negate=
    rx1694_cur."!cursor_pos"(rx1694_pos)
    $P10 = rx1694_cur."panic"("Assignment (\"=\") not supported in NQP, use \":=\" instead")
    unless $P10, rx1694_fail
    rx1694_pos = $P10."pos"()
.annotate 'line', 707
  # rx pass
    rx1694_cur."!cursor_pass"(rx1694_pos, "infix:sym<=>")
    if_null rx1694_debug, debug_1362
    rx1694_cur."!cursor_debug"("PASS", "infix:sym<=>", " at pos=", rx1694_pos)
  debug_1362:
    .return (rx1694_cur)
  rx1694_restart:
.annotate 'line', 10
    if_null rx1694_debug, debug_1363
    rx1694_cur."!cursor_debug"("NEXT", "infix:sym<=>")
  debug_1363:
  rx1694_fail:
    (rx1694_rep, rx1694_pos, $I10, $P10) = rx1694_cur."!mark_fail"(0)
    lt rx1694_pos, -1, rx1694_done
    eq rx1694_pos, -1, rx1694_fail
    jump $I10
  rx1694_done:
    rx1694_cur."!cursor_fail"()
    if_null rx1694_debug, debug_1364
    rx1694_cur."!cursor_debug"("FAIL", "infix:sym<=>")
  debug_1364:
    .return (rx1694_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=>"  :nsentry("!PREFIX__infix:sym<=>") :subid("364_1303401201.841") :method
.annotate 'line', 10
    $P1696 = self."!PREFIX__!subrule"("panic", "=")
    new $P1697, "ResizablePMCArray"
    push $P1697, $P1696
    .return ($P1697)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<:=>"  :subid("365_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1701_tgt
    .local int rx1701_pos
    .local int rx1701_off
    .local int rx1701_eos
    .local int rx1701_rep
    .local pmc rx1701_cur
    .local pmc rx1701_debug
    (rx1701_cur, rx1701_pos, rx1701_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1701_cur
    .local pmc match
    .lex "$/", match
    length rx1701_eos, rx1701_tgt
    gt rx1701_pos, rx1701_eos, rx1701_done
    set rx1701_off, 0
    lt rx1701_pos, 2, rx1701_start
    sub rx1701_off, rx1701_pos, 1
    substr rx1701_tgt, rx1701_tgt, rx1701_off
  rx1701_start:
    eq $I10, 1, rx1701_restart
    if_null rx1701_debug, debug_1365
    rx1701_cur."!cursor_debug"("START", "infix:sym<:=>")
  debug_1365:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1705_done
    goto rxscan1705_scan
  rxscan1705_loop:
    (rx1701_pos) = rx1701_cur."from"()
    inc rx1701_pos
    rx1701_cur."!cursor_from"(rx1701_pos)
    ge rx1701_pos, rx1701_eos, rxscan1705_done
  rxscan1705_scan:
    set_addr $I10, rxscan1705_loop
    rx1701_cur."!mark_push"(0, rx1701_pos, $I10)
  rxscan1705_done:
.annotate 'line', 710
  # rx subcapture "sym"
    set_addr $I10, rxcap_1706_fail
    rx1701_cur."!mark_push"(0, rx1701_pos, $I10)
  # rx literal  ":="
    add $I11, rx1701_pos, 2
    gt $I11, rx1701_eos, rx1701_fail
    sub $I11, rx1701_pos, rx1701_off
    substr $S10, rx1701_tgt, $I11, 2
    ne $S10, ":=", rx1701_fail
    add rx1701_pos, 2
    set_addr $I10, rxcap_1706_fail
    ($I12, $I11) = rx1701_cur."!mark_peek"($I10)
    rx1701_cur."!cursor_pos"($I11)
    ($P10) = rx1701_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1701_pos, "")
    rx1701_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1706_done
  rxcap_1706_fail:
    goto rx1701_fail
  rxcap_1706_done:
  # rx subrule "O" subtype=capture negate=
    rx1701_cur."!cursor_pos"(rx1701_pos)
    $P10 = rx1701_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx1701_fail
    rx1701_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1701_pos = $P10."pos"()
  # rx pass
    rx1701_cur."!cursor_pass"(rx1701_pos, "infix:sym<:=>")
    if_null rx1701_debug, debug_1366
    rx1701_cur."!cursor_debug"("PASS", "infix:sym<:=>", " at pos=", rx1701_pos)
  debug_1366:
    .return (rx1701_cur)
  rx1701_restart:
.annotate 'line', 10
    if_null rx1701_debug, debug_1367
    rx1701_cur."!cursor_debug"("NEXT", "infix:sym<:=>")
  debug_1367:
  rx1701_fail:
    (rx1701_rep, rx1701_pos, $I10, $P10) = rx1701_cur."!mark_fail"(0)
    lt rx1701_pos, -1, rx1701_done
    eq rx1701_pos, -1, rx1701_fail
    jump $I10
  rx1701_done:
    rx1701_cur."!cursor_fail"()
    if_null rx1701_debug, debug_1368
    rx1701_cur."!cursor_debug"("FAIL", "infix:sym<:=>")
  debug_1368:
    .return (rx1701_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<:=>"  :nsentry("!PREFIX__infix:sym<:=>") :subid("366_1303401201.841") :method
.annotate 'line', 10
    $P1703 = self."!PREFIX__!subrule"("O", ":=")
    new $P1704, "ResizablePMCArray"
    push $P1704, $P1703
    .return ($P1704)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<::=>"  :subid("367_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1708_tgt
    .local int rx1708_pos
    .local int rx1708_off
    .local int rx1708_eos
    .local int rx1708_rep
    .local pmc rx1708_cur
    .local pmc rx1708_debug
    (rx1708_cur, rx1708_pos, rx1708_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1708_cur
    .local pmc match
    .lex "$/", match
    length rx1708_eos, rx1708_tgt
    gt rx1708_pos, rx1708_eos, rx1708_done
    set rx1708_off, 0
    lt rx1708_pos, 2, rx1708_start
    sub rx1708_off, rx1708_pos, 1
    substr rx1708_tgt, rx1708_tgt, rx1708_off
  rx1708_start:
    eq $I10, 1, rx1708_restart
    if_null rx1708_debug, debug_1369
    rx1708_cur."!cursor_debug"("START", "infix:sym<::=>")
  debug_1369:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1712_done
    goto rxscan1712_scan
  rxscan1712_loop:
    (rx1708_pos) = rx1708_cur."from"()
    inc rx1708_pos
    rx1708_cur."!cursor_from"(rx1708_pos)
    ge rx1708_pos, rx1708_eos, rxscan1712_done
  rxscan1712_scan:
    set_addr $I10, rxscan1712_loop
    rx1708_cur."!mark_push"(0, rx1708_pos, $I10)
  rxscan1712_done:
.annotate 'line', 711
  # rx subcapture "sym"
    set_addr $I10, rxcap_1713_fail
    rx1708_cur."!mark_push"(0, rx1708_pos, $I10)
  # rx literal  "::="
    add $I11, rx1708_pos, 3
    gt $I11, rx1708_eos, rx1708_fail
    sub $I11, rx1708_pos, rx1708_off
    substr $S10, rx1708_tgt, $I11, 3
    ne $S10, "::=", rx1708_fail
    add rx1708_pos, 3
    set_addr $I10, rxcap_1713_fail
    ($I12, $I11) = rx1708_cur."!mark_peek"($I10)
    rx1708_cur."!cursor_pos"($I11)
    ($P10) = rx1708_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1708_pos, "")
    rx1708_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1713_done
  rxcap_1713_fail:
    goto rx1708_fail
  rxcap_1713_done:
  # rx subrule "O" subtype=capture negate=
    rx1708_cur."!cursor_pos"(rx1708_pos)
    $P10 = rx1708_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx1708_fail
    rx1708_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1708_pos = $P10."pos"()
  # rx pass
    rx1708_cur."!cursor_pass"(rx1708_pos, "infix:sym<::=>")
    if_null rx1708_debug, debug_1370
    rx1708_cur."!cursor_debug"("PASS", "infix:sym<::=>", " at pos=", rx1708_pos)
  debug_1370:
    .return (rx1708_cur)
  rx1708_restart:
.annotate 'line', 10
    if_null rx1708_debug, debug_1371
    rx1708_cur."!cursor_debug"("NEXT", "infix:sym<::=>")
  debug_1371:
  rx1708_fail:
    (rx1708_rep, rx1708_pos, $I10, $P10) = rx1708_cur."!mark_fail"(0)
    lt rx1708_pos, -1, rx1708_done
    eq rx1708_pos, -1, rx1708_fail
    jump $I10
  rx1708_done:
    rx1708_cur."!cursor_fail"()
    if_null rx1708_debug, debug_1372
    rx1708_cur."!cursor_debug"("FAIL", "infix:sym<::=>")
  debug_1372:
    .return (rx1708_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<::=>"  :nsentry("!PREFIX__infix:sym<::=>") :subid("368_1303401201.841") :method
.annotate 'line', 10
    $P1710 = self."!PREFIX__!subrule"("O", "::=")
    new $P1711, "ResizablePMCArray"
    push $P1711, $P1710
    .return ($P1711)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<,>"  :subid("369_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1715_tgt
    .local int rx1715_pos
    .local int rx1715_off
    .local int rx1715_eos
    .local int rx1715_rep
    .local pmc rx1715_cur
    .local pmc rx1715_debug
    (rx1715_cur, rx1715_pos, rx1715_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1715_cur
    .local pmc match
    .lex "$/", match
    length rx1715_eos, rx1715_tgt
    gt rx1715_pos, rx1715_eos, rx1715_done
    set rx1715_off, 0
    lt rx1715_pos, 2, rx1715_start
    sub rx1715_off, rx1715_pos, 1
    substr rx1715_tgt, rx1715_tgt, rx1715_off
  rx1715_start:
    eq $I10, 1, rx1715_restart
    if_null rx1715_debug, debug_1373
    rx1715_cur."!cursor_debug"("START", "infix:sym<,>")
  debug_1373:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1719_done
    goto rxscan1719_scan
  rxscan1719_loop:
    (rx1715_pos) = rx1715_cur."from"()
    inc rx1715_pos
    rx1715_cur."!cursor_from"(rx1715_pos)
    ge rx1715_pos, rx1715_eos, rxscan1719_done
  rxscan1719_scan:
    set_addr $I10, rxscan1719_loop
    rx1715_cur."!mark_push"(0, rx1715_pos, $I10)
  rxscan1719_done:
.annotate 'line', 713
  # rx subcapture "sym"
    set_addr $I10, rxcap_1720_fail
    rx1715_cur."!mark_push"(0, rx1715_pos, $I10)
  # rx literal  ","
    add $I11, rx1715_pos, 1
    gt $I11, rx1715_eos, rx1715_fail
    sub $I11, rx1715_pos, rx1715_off
    ord $I11, rx1715_tgt, $I11
    ne $I11, 44, rx1715_fail
    add rx1715_pos, 1
    set_addr $I10, rxcap_1720_fail
    ($I12, $I11) = rx1715_cur."!mark_peek"($I10)
    rx1715_cur."!cursor_pos"($I11)
    ($P10) = rx1715_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1715_pos, "")
    rx1715_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1720_done
  rxcap_1720_fail:
    goto rx1715_fail
  rxcap_1720_done:
  # rx subrule "O" subtype=capture negate=
    rx1715_cur."!cursor_pos"(rx1715_pos)
    $P10 = rx1715_cur."O"("%comma, :pasttype<list>")
    unless $P10, rx1715_fail
    rx1715_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1715_pos = $P10."pos"()
  # rx pass
    rx1715_cur."!cursor_pass"(rx1715_pos, "infix:sym<,>")
    if_null rx1715_debug, debug_1374
    rx1715_cur."!cursor_debug"("PASS", "infix:sym<,>", " at pos=", rx1715_pos)
  debug_1374:
    .return (rx1715_cur)
  rx1715_restart:
.annotate 'line', 10
    if_null rx1715_debug, debug_1375
    rx1715_cur."!cursor_debug"("NEXT", "infix:sym<,>")
  debug_1375:
  rx1715_fail:
    (rx1715_rep, rx1715_pos, $I10, $P10) = rx1715_cur."!mark_fail"(0)
    lt rx1715_pos, -1, rx1715_done
    eq rx1715_pos, -1, rx1715_fail
    jump $I10
  rx1715_done:
    rx1715_cur."!cursor_fail"()
    if_null rx1715_debug, debug_1376
    rx1715_cur."!cursor_debug"("FAIL", "infix:sym<,>")
  debug_1376:
    .return (rx1715_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<,>"  :nsentry("!PREFIX__infix:sym<,>") :subid("370_1303401201.841") :method
.annotate 'line', 10
    $P1717 = self."!PREFIX__!subrule"("O", ",")
    new $P1718, "ResizablePMCArray"
    push $P1718, $P1717
    .return ($P1718)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<return>"  :subid("371_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .const 'Sub' $P1730 = "373_1303401201.841" 
    capture_lex $P1730
    .local string rx1722_tgt
    .local int rx1722_pos
    .local int rx1722_off
    .local int rx1722_eos
    .local int rx1722_rep
    .local pmc rx1722_cur
    .local pmc rx1722_debug
    (rx1722_cur, rx1722_pos, rx1722_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1722_cur
    .local pmc match
    .lex "$/", match
    length rx1722_eos, rx1722_tgt
    gt rx1722_pos, rx1722_eos, rx1722_done
    set rx1722_off, 0
    lt rx1722_pos, 2, rx1722_start
    sub rx1722_off, rx1722_pos, 1
    substr rx1722_tgt, rx1722_tgt, rx1722_off
  rx1722_start:
    eq $I10, 1, rx1722_restart
    if_null rx1722_debug, debug_1377
    rx1722_cur."!cursor_debug"("START", "prefix:sym<return>")
  debug_1377:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1725_done
    goto rxscan1725_scan
  rxscan1725_loop:
    (rx1722_pos) = rx1722_cur."from"()
    inc rx1722_pos
    rx1722_cur."!cursor_from"(rx1722_pos)
    ge rx1722_pos, rx1722_eos, rxscan1725_done
  rxscan1725_scan:
    set_addr $I10, rxscan1725_loop
    rx1722_cur."!mark_push"(0, rx1722_pos, $I10)
  rxscan1725_done:
.annotate 'line', 715
  # rx subcapture "sym"
    set_addr $I10, rxcap_1726_fail
    rx1722_cur."!mark_push"(0, rx1722_pos, $I10)
  # rx literal  "return"
    add $I11, rx1722_pos, 6
    gt $I11, rx1722_eos, rx1722_fail
    sub $I11, rx1722_pos, rx1722_off
    substr $S10, rx1722_tgt, $I11, 6
    ne $S10, "return", rx1722_fail
    add rx1722_pos, 6
    set_addr $I10, rxcap_1726_fail
    ($I12, $I11) = rx1722_cur."!mark_peek"($I10)
    rx1722_cur."!cursor_pos"($I11)
    ($P10) = rx1722_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1722_pos, "")
    rx1722_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1726_done
  rxcap_1726_fail:
    goto rx1722_fail
  rxcap_1726_done:
  # rx charclass s
    ge rx1722_pos, rx1722_eos, rx1722_fail
    sub $I10, rx1722_pos, rx1722_off
    is_cclass $I11, 32, rx1722_tgt, $I10
    unless $I11, rx1722_fail
    inc rx1722_pos
  # rx subrule "O" subtype=capture negate=
    rx1722_cur."!cursor_pos"(rx1722_pos)
    $P10 = rx1722_cur."O"("%list_prefix, :pasttype<return>")
    unless $P10, rx1722_fail
    rx1722_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1722_pos = $P10."pos"()
    rx1722_cur."!cursor_pos"(rx1722_pos)
    find_lex $P1727, unicode:"$\x{a2}"
    $P1728 = $P1727."MATCH"()
    store_lex "$/", $P1728
    .const 'Sub' $P1730 = "373_1303401201.841" 
    capture_lex $P1730
    $P1732 = $P1730()
  # rx pass
    rx1722_cur."!cursor_pass"(rx1722_pos, "prefix:sym<return>")
    if_null rx1722_debug, debug_1378
    rx1722_cur."!cursor_debug"("PASS", "prefix:sym<return>", " at pos=", rx1722_pos)
  debug_1378:
    .return (rx1722_cur)
  rx1722_restart:
.annotate 'line', 10
    if_null rx1722_debug, debug_1379
    rx1722_cur."!cursor_debug"("NEXT", "prefix:sym<return>")
  debug_1379:
  rx1722_fail:
    (rx1722_rep, rx1722_pos, $I10, $P10) = rx1722_cur."!mark_fail"(0)
    lt rx1722_pos, -1, rx1722_done
    eq rx1722_pos, -1, rx1722_fail
    jump $I10
  rx1722_done:
    rx1722_cur."!cursor_fail"()
    if_null rx1722_debug, debug_1380
    rx1722_cur."!cursor_debug"("FAIL", "prefix:sym<return>")
  debug_1380:
    .return (rx1722_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<return>"  :nsentry("!PREFIX__prefix:sym<return>") :subid("372_1303401201.841") :method
.annotate 'line', 10
    new $P1724, "ResizablePMCArray"
    push $P1724, "return"
    .return ($P1724)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1729"  :anon :subid("373_1303401201.841") :outer("371_1303401201.841")
.annotate 'line', 715
    new $P1731, "Integer"
    assign $P1731, 1
    store_dynamic_lex "$*RETURN_USED", $P1731
    .return ($P1731)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<make>"  :subid("374_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1734_tgt
    .local int rx1734_pos
    .local int rx1734_off
    .local int rx1734_eos
    .local int rx1734_rep
    .local pmc rx1734_cur
    .local pmc rx1734_debug
    (rx1734_cur, rx1734_pos, rx1734_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1734_cur
    .local pmc match
    .lex "$/", match
    length rx1734_eos, rx1734_tgt
    gt rx1734_pos, rx1734_eos, rx1734_done
    set rx1734_off, 0
    lt rx1734_pos, 2, rx1734_start
    sub rx1734_off, rx1734_pos, 1
    substr rx1734_tgt, rx1734_tgt, rx1734_off
  rx1734_start:
    eq $I10, 1, rx1734_restart
    if_null rx1734_debug, debug_1381
    rx1734_cur."!cursor_debug"("START", "prefix:sym<make>")
  debug_1381:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1737_done
    goto rxscan1737_scan
  rxscan1737_loop:
    (rx1734_pos) = rx1734_cur."from"()
    inc rx1734_pos
    rx1734_cur."!cursor_from"(rx1734_pos)
    ge rx1734_pos, rx1734_eos, rxscan1737_done
  rxscan1737_scan:
    set_addr $I10, rxscan1737_loop
    rx1734_cur."!mark_push"(0, rx1734_pos, $I10)
  rxscan1737_done:
.annotate 'line', 716
  # rx subcapture "sym"
    set_addr $I10, rxcap_1738_fail
    rx1734_cur."!mark_push"(0, rx1734_pos, $I10)
  # rx literal  "make"
    add $I11, rx1734_pos, 4
    gt $I11, rx1734_eos, rx1734_fail
    sub $I11, rx1734_pos, rx1734_off
    substr $S10, rx1734_tgt, $I11, 4
    ne $S10, "make", rx1734_fail
    add rx1734_pos, 4
    set_addr $I10, rxcap_1738_fail
    ($I12, $I11) = rx1734_cur."!mark_peek"($I10)
    rx1734_cur."!cursor_pos"($I11)
    ($P10) = rx1734_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1734_pos, "")
    rx1734_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1738_done
  rxcap_1738_fail:
    goto rx1734_fail
  rxcap_1738_done:
  # rx charclass s
    ge rx1734_pos, rx1734_eos, rx1734_fail
    sub $I10, rx1734_pos, rx1734_off
    is_cclass $I11, 32, rx1734_tgt, $I10
    unless $I11, rx1734_fail
    inc rx1734_pos
  # rx subrule "O" subtype=capture negate=
    rx1734_cur."!cursor_pos"(rx1734_pos)
    $P10 = rx1734_cur."O"("%list_prefix")
    unless $P10, rx1734_fail
    rx1734_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1734_pos = $P10."pos"()
  # rx pass
    rx1734_cur."!cursor_pass"(rx1734_pos, "prefix:sym<make>")
    if_null rx1734_debug, debug_1382
    rx1734_cur."!cursor_debug"("PASS", "prefix:sym<make>", " at pos=", rx1734_pos)
  debug_1382:
    .return (rx1734_cur)
  rx1734_restart:
.annotate 'line', 10
    if_null rx1734_debug, debug_1383
    rx1734_cur."!cursor_debug"("NEXT", "prefix:sym<make>")
  debug_1383:
  rx1734_fail:
    (rx1734_rep, rx1734_pos, $I10, $P10) = rx1734_cur."!mark_fail"(0)
    lt rx1734_pos, -1, rx1734_done
    eq rx1734_pos, -1, rx1734_fail
    jump $I10
  rx1734_done:
    rx1734_cur."!cursor_fail"()
    if_null rx1734_debug, debug_1384
    rx1734_cur."!cursor_debug"("FAIL", "prefix:sym<make>")
  debug_1384:
    .return (rx1734_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<make>"  :nsentry("!PREFIX__prefix:sym<make>") :subid("375_1303401201.841") :method
.annotate 'line', 10
    new $P1736, "ResizablePMCArray"
    push $P1736, "make"
    .return ($P1736)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<last>"  :subid("376_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1740_tgt
    .local int rx1740_pos
    .local int rx1740_off
    .local int rx1740_eos
    .local int rx1740_rep
    .local pmc rx1740_cur
    .local pmc rx1740_debug
    (rx1740_cur, rx1740_pos, rx1740_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1740_cur
    .local pmc match
    .lex "$/", match
    length rx1740_eos, rx1740_tgt
    gt rx1740_pos, rx1740_eos, rx1740_done
    set rx1740_off, 0
    lt rx1740_pos, 2, rx1740_start
    sub rx1740_off, rx1740_pos, 1
    substr rx1740_tgt, rx1740_tgt, rx1740_off
  rx1740_start:
    eq $I10, 1, rx1740_restart
    if_null rx1740_debug, debug_1385
    rx1740_cur."!cursor_debug"("START", "term:sym<last>")
  debug_1385:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1743_done
    goto rxscan1743_scan
  rxscan1743_loop:
    (rx1740_pos) = rx1740_cur."from"()
    inc rx1740_pos
    rx1740_cur."!cursor_from"(rx1740_pos)
    ge rx1740_pos, rx1740_eos, rxscan1743_done
  rxscan1743_scan:
    set_addr $I10, rxscan1743_loop
    rx1740_cur."!mark_push"(0, rx1740_pos, $I10)
  rxscan1743_done:
.annotate 'line', 717
  # rx subcapture "sym"
    set_addr $I10, rxcap_1744_fail
    rx1740_cur."!mark_push"(0, rx1740_pos, $I10)
  # rx literal  "last"
    add $I11, rx1740_pos, 4
    gt $I11, rx1740_eos, rx1740_fail
    sub $I11, rx1740_pos, rx1740_off
    substr $S10, rx1740_tgt, $I11, 4
    ne $S10, "last", rx1740_fail
    add rx1740_pos, 4
    set_addr $I10, rxcap_1744_fail
    ($I12, $I11) = rx1740_cur."!mark_peek"($I10)
    rx1740_cur."!cursor_pos"($I11)
    ($P10) = rx1740_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1740_pos, "")
    rx1740_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1744_done
  rxcap_1744_fail:
    goto rx1740_fail
  rxcap_1744_done:
  # rx pass
    rx1740_cur."!cursor_pass"(rx1740_pos, "term:sym<last>")
    if_null rx1740_debug, debug_1386
    rx1740_cur."!cursor_debug"("PASS", "term:sym<last>", " at pos=", rx1740_pos)
  debug_1386:
    .return (rx1740_cur)
  rx1740_restart:
.annotate 'line', 10
    if_null rx1740_debug, debug_1387
    rx1740_cur."!cursor_debug"("NEXT", "term:sym<last>")
  debug_1387:
  rx1740_fail:
    (rx1740_rep, rx1740_pos, $I10, $P10) = rx1740_cur."!mark_fail"(0)
    lt rx1740_pos, -1, rx1740_done
    eq rx1740_pos, -1, rx1740_fail
    jump $I10
  rx1740_done:
    rx1740_cur."!cursor_fail"()
    if_null rx1740_debug, debug_1388
    rx1740_cur."!cursor_debug"("FAIL", "term:sym<last>")
  debug_1388:
    .return (rx1740_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<last>"  :nsentry("!PREFIX__term:sym<last>") :subid("377_1303401201.841") :method
.annotate 'line', 10
    new $P1742, "ResizablePMCArray"
    push $P1742, "last"
    .return ($P1742)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<next>"  :subid("378_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1746_tgt
    .local int rx1746_pos
    .local int rx1746_off
    .local int rx1746_eos
    .local int rx1746_rep
    .local pmc rx1746_cur
    .local pmc rx1746_debug
    (rx1746_cur, rx1746_pos, rx1746_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1746_cur
    .local pmc match
    .lex "$/", match
    length rx1746_eos, rx1746_tgt
    gt rx1746_pos, rx1746_eos, rx1746_done
    set rx1746_off, 0
    lt rx1746_pos, 2, rx1746_start
    sub rx1746_off, rx1746_pos, 1
    substr rx1746_tgt, rx1746_tgt, rx1746_off
  rx1746_start:
    eq $I10, 1, rx1746_restart
    if_null rx1746_debug, debug_1389
    rx1746_cur."!cursor_debug"("START", "term:sym<next>")
  debug_1389:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1749_done
    goto rxscan1749_scan
  rxscan1749_loop:
    (rx1746_pos) = rx1746_cur."from"()
    inc rx1746_pos
    rx1746_cur."!cursor_from"(rx1746_pos)
    ge rx1746_pos, rx1746_eos, rxscan1749_done
  rxscan1749_scan:
    set_addr $I10, rxscan1749_loop
    rx1746_cur."!mark_push"(0, rx1746_pos, $I10)
  rxscan1749_done:
.annotate 'line', 718
  # rx subcapture "sym"
    set_addr $I10, rxcap_1750_fail
    rx1746_cur."!mark_push"(0, rx1746_pos, $I10)
  # rx literal  "next"
    add $I11, rx1746_pos, 4
    gt $I11, rx1746_eos, rx1746_fail
    sub $I11, rx1746_pos, rx1746_off
    substr $S10, rx1746_tgt, $I11, 4
    ne $S10, "next", rx1746_fail
    add rx1746_pos, 4
    set_addr $I10, rxcap_1750_fail
    ($I12, $I11) = rx1746_cur."!mark_peek"($I10)
    rx1746_cur."!cursor_pos"($I11)
    ($P10) = rx1746_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1746_pos, "")
    rx1746_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1750_done
  rxcap_1750_fail:
    goto rx1746_fail
  rxcap_1750_done:
  # rx pass
    rx1746_cur."!cursor_pass"(rx1746_pos, "term:sym<next>")
    if_null rx1746_debug, debug_1390
    rx1746_cur."!cursor_debug"("PASS", "term:sym<next>", " at pos=", rx1746_pos)
  debug_1390:
    .return (rx1746_cur)
  rx1746_restart:
.annotate 'line', 10
    if_null rx1746_debug, debug_1391
    rx1746_cur."!cursor_debug"("NEXT", "term:sym<next>")
  debug_1391:
  rx1746_fail:
    (rx1746_rep, rx1746_pos, $I10, $P10) = rx1746_cur."!mark_fail"(0)
    lt rx1746_pos, -1, rx1746_done
    eq rx1746_pos, -1, rx1746_fail
    jump $I10
  rx1746_done:
    rx1746_cur."!cursor_fail"()
    if_null rx1746_debug, debug_1392
    rx1746_cur."!cursor_debug"("FAIL", "term:sym<next>")
  debug_1392:
    .return (rx1746_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<next>"  :nsentry("!PREFIX__term:sym<next>") :subid("379_1303401201.841") :method
.annotate 'line', 10
    new $P1748, "ResizablePMCArray"
    push $P1748, "next"
    .return ($P1748)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<redo>"  :subid("380_1303401201.841") :method :outer("12_1303401201.841")
.annotate 'line', 10
    .local string rx1752_tgt
    .local int rx1752_pos
    .local int rx1752_off
    .local int rx1752_eos
    .local int rx1752_rep
    .local pmc rx1752_cur
    .local pmc rx1752_debug
    (rx1752_cur, rx1752_pos, rx1752_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1752_cur
    .local pmc match
    .lex "$/", match
    length rx1752_eos, rx1752_tgt
    gt rx1752_pos, rx1752_eos, rx1752_done
    set rx1752_off, 0
    lt rx1752_pos, 2, rx1752_start
    sub rx1752_off, rx1752_pos, 1
    substr rx1752_tgt, rx1752_tgt, rx1752_off
  rx1752_start:
    eq $I10, 1, rx1752_restart
    if_null rx1752_debug, debug_1393
    rx1752_cur."!cursor_debug"("START", "term:sym<redo>")
  debug_1393:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1755_done
    goto rxscan1755_scan
  rxscan1755_loop:
    (rx1752_pos) = rx1752_cur."from"()
    inc rx1752_pos
    rx1752_cur."!cursor_from"(rx1752_pos)
    ge rx1752_pos, rx1752_eos, rxscan1755_done
  rxscan1755_scan:
    set_addr $I10, rxscan1755_loop
    rx1752_cur."!mark_push"(0, rx1752_pos, $I10)
  rxscan1755_done:
.annotate 'line', 719
  # rx subcapture "sym"
    set_addr $I10, rxcap_1756_fail
    rx1752_cur."!mark_push"(0, rx1752_pos, $I10)
  # rx literal  "redo"
    add $I11, rx1752_pos, 4
    gt $I11, rx1752_eos, rx1752_fail
    sub $I11, rx1752_pos, rx1752_off
    substr $S10, rx1752_tgt, $I11, 4
    ne $S10, "redo", rx1752_fail
    add rx1752_pos, 4
    set_addr $I10, rxcap_1756_fail
    ($I12, $I11) = rx1752_cur."!mark_peek"($I10)
    rx1752_cur."!cursor_pos"($I11)
    ($P10) = rx1752_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1752_pos, "")
    rx1752_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1756_done
  rxcap_1756_fail:
    goto rx1752_fail
  rxcap_1756_done:
  # rx pass
    rx1752_cur."!cursor_pass"(rx1752_pos, "term:sym<redo>")
    if_null rx1752_debug, debug_1394
    rx1752_cur."!cursor_debug"("PASS", "term:sym<redo>", " at pos=", rx1752_pos)
  debug_1394:
    .return (rx1752_cur)
  rx1752_restart:
.annotate 'line', 10
    if_null rx1752_debug, debug_1395
    rx1752_cur."!cursor_debug"("NEXT", "term:sym<redo>")
  debug_1395:
  rx1752_fail:
    (rx1752_rep, rx1752_pos, $I10, $P10) = rx1752_cur."!mark_fail"(0)
    lt rx1752_pos, -1, rx1752_done
    eq rx1752_pos, -1, rx1752_fail
    jump $I10
  rx1752_done:
    rx1752_cur."!cursor_fail"()
    if_null rx1752_debug, debug_1396
    rx1752_cur."!cursor_debug"("FAIL", "term:sym<redo>")
  debug_1396:
    .return (rx1752_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<redo>"  :nsentry("!PREFIX__term:sym<redo>") :subid("381_1303401201.841") :method
.annotate 'line', 10
    new $P1754, "ResizablePMCArray"
    push $P1754, "redo"
    .return ($P1754)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "smartmatch"  :subid("382_1303401201.841") :outer("12_1303401201.841")
    .param pmc param_1758
    .param pmc param_1759
.annotate 'line', 721
    .lex "self", param_1758
    .lex "$/", param_1759
.annotate 'line', 723
    new $P1760, "Undef"
    .lex "$t", $P1760
    find_lex $P1761, "$/"
    unless_null $P1761, vivify_1397
    $P1761 = root_new ['parrot';'ResizablePMCArray']
  vivify_1397:
    set $P1762, $P1761[0]
    unless_null $P1762, vivify_1398
    new $P1762, "Undef"
  vivify_1398:
    store_lex "$t", $P1762
    find_lex $P1763, "$/"
    unless_null $P1763, vivify_1399
    $P1763 = root_new ['parrot';'ResizablePMCArray']
  vivify_1399:
    set $P1764, $P1763[1]
    unless_null $P1764, vivify_1400
    new $P1764, "Undef"
  vivify_1400:
    find_lex $P1765, "$/"
    unless_null $P1765, vivify_1401
    $P1765 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P1765
  vivify_1401:
    set $P1765[0], $P1764
    find_lex $P1766, "$t"
    unless_null $P1766, vivify_1402
    new $P1766, "Undef"
  vivify_1402:
    find_lex $P1767, "$/"
    unless_null $P1767, vivify_1403
    $P1767 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P1767
  vivify_1403:
    set $P1767[1], $P1766
.annotate 'line', 721
    .return ($P1766)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2492"  :subid("384_1303401201.841") :outer("10_1303401201.841")
.annotate 'line', 727
    .const 'Sub' $P2558 = "405_1303401201.841" 
    capture_lex $P2558
    .const 'Sub' $P2551 = "403_1303401201.841" 
    capture_lex $P2551
    .const 'Sub' $P2546 = "401_1303401201.841" 
    capture_lex $P2546
    .const 'Sub' $P2534 = "398_1303401201.841" 
    capture_lex $P2534
    .const 'Sub' $P2524 = "395_1303401201.841" 
    capture_lex $P2524
    .const 'Sub' $P2519 = "393_1303401201.841" 
    capture_lex $P2519
    .const 'Sub' $P2510 = "390_1303401201.841" 
    capture_lex $P2510
    .const 'Sub' $P2505 = "388_1303401201.841" 
    capture_lex $P2505
    .const 'Sub' $P2496 = "385_1303401201.841" 
    capture_lex $P2496
    .lex "$?PACKAGE", $P2494
    .lex "$?CLASS", $P2495
    .const 'Sub' $P2551 = "403_1303401201.841" 
    capture_lex $P2551
    .return ($P2551)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "" :load :init :subid("post1404") :outer("384_1303401201.841")
.annotate 'line', 727
    get_hll_global $P2493, ["NQP";"Regex"], "_block2492" 
    .local pmc block
    set block, $P2493
    .const 'Sub' $P2558 = "405_1303401201.841" 
    capture_lex $P2558
    $P2558()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2557"  :anon :subid("405_1303401201.841") :outer("384_1303401201.841")
.annotate 'line', 727
    nqp_get_sc_object $P2559, "1303401190.883", 2
    .local pmc type_obj
    set type_obj, $P2559
    get_how $P2560, type_obj
    .const 'Sub' $P2561 = "385_1303401201.841" 
    $P2560."add_method"(type_obj, "metachar:sym<:my>", $P2561)
    get_how $P2562, type_obj
    get_global $P2563, "!PREFIX__metachar:sym<:my>"
    $P2562."add_method"(type_obj, "!PREFIX__metachar:sym<:my>", $P2563)
    get_how $P2564, type_obj
    .const 'Sub' $P2565 = "388_1303401201.841" 
    $P2564."add_method"(type_obj, "metachar:sym<{ }>", $P2565)
    get_how $P2566, type_obj
    get_global $P2567, "!PREFIX__metachar:sym<{ }>"
    $P2566."add_method"(type_obj, "!PREFIX__metachar:sym<{ }>", $P2567)
    get_how $P2568, type_obj
    .const 'Sub' $P2569 = "390_1303401201.841" 
    $P2568."add_method"(type_obj, "metachar:sym<nqpvar>", $P2569)
    get_how $P2570, type_obj
    get_global $P2571, "!PREFIX__metachar:sym<nqpvar>"
    $P2570."add_method"(type_obj, "!PREFIX__metachar:sym<nqpvar>", $P2571)
    get_how $P2572, type_obj
    .const 'Sub' $P2573 = "393_1303401201.841" 
    $P2572."add_method"(type_obj, "assertion:sym<{ }>", $P2573)
    get_how $P2574, type_obj
    get_global $P2575, "!PREFIX__assertion:sym<{ }>"
    $P2574."add_method"(type_obj, "!PREFIX__assertion:sym<{ }>", $P2575)
    get_how $P2576, type_obj
    .const 'Sub' $P2577 = "395_1303401201.841" 
    $P2576."add_method"(type_obj, "assertion:sym<?{ }>", $P2577)
    get_how $P2578, type_obj
    get_global $P2579, "!PREFIX__assertion:sym<?{ }>"
    $P2578."add_method"(type_obj, "!PREFIX__assertion:sym<?{ }>", $P2579)
    get_how $P2580, type_obj
    .const 'Sub' $P2581 = "398_1303401201.841" 
    $P2580."add_method"(type_obj, "assertion:sym<name>", $P2581)
    get_how $P2582, type_obj
    get_global $P2583, "!PREFIX__assertion:sym<name>"
    $P2582."add_method"(type_obj, "!PREFIX__assertion:sym<name>", $P2583)
    get_how $P2584, type_obj
    .const 'Sub' $P2585 = "401_1303401201.841" 
    $P2584."add_method"(type_obj, "assertion:sym<var>", $P2585)
    get_how $P2586, type_obj
    get_global $P2587, "!PREFIX__assertion:sym<var>"
    $P2586."add_method"(type_obj, "!PREFIX__assertion:sym<var>", $P2587)
    get_how $P2588, type_obj
    .const 'Sub' $P2589 = "403_1303401201.841" 
    $P2588."add_method"(type_obj, "codeblock", $P2589)
    get_how $P2590, type_obj
    get_global $P2591, "!PREFIX__codeblock"
    $P2590."add_method"(type_obj, "!PREFIX__codeblock", $P2591)
    get_how $P2592, type_obj
    get_hll_global $P2593, ["Regex";"P6Regex"], "Grammar"
    $P2592."add_parent"(type_obj, $P2593)
    get_how $P2594, type_obj
    $P2595 = $P2594."compose"(type_obj)
    .return ($P2595)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<:my>"  :subid("385_1303401201.841") :method :outer("384_1303401201.841")
.annotate 'line', 727
    .const 'Sub' $P2502 = "387_1303401201.841" 
    capture_lex $P2502
    .local string rx2497_tgt
    .local int rx2497_pos
    .local int rx2497_off
    .local int rx2497_eos
    .local int rx2497_rep
    .local pmc rx2497_cur
    .local pmc rx2497_debug
    (rx2497_cur, rx2497_pos, rx2497_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2497_cur
    .local pmc match
    .lex "$/", match
    length rx2497_eos, rx2497_tgt
    gt rx2497_pos, rx2497_eos, rx2497_done
    set rx2497_off, 0
    lt rx2497_pos, 2, rx2497_start
    sub rx2497_off, rx2497_pos, 1
    substr rx2497_tgt, rx2497_tgt, rx2497_off
  rx2497_start:
    eq $I10, 1, rx2497_restart
    if_null rx2497_debug, debug_1405
    rx2497_cur."!cursor_debug"("START", "metachar:sym<:my>")
  debug_1405:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2500_done
    goto rxscan2500_scan
  rxscan2500_loop:
    (rx2497_pos) = rx2497_cur."from"()
    inc rx2497_pos
    rx2497_cur."!cursor_from"(rx2497_pos)
    ge rx2497_pos, rx2497_eos, rxscan2500_done
  rxscan2500_scan:
    set_addr $I10, rxscan2500_loop
    rx2497_cur."!mark_push"(0, rx2497_pos, $I10)
  rxscan2500_done:
.annotate 'line', 729
  # rx literal  ":"
    add $I11, rx2497_pos, 1
    gt $I11, rx2497_eos, rx2497_fail
    sub $I11, rx2497_pos, rx2497_off
    ord $I11, rx2497_tgt, $I11
    ne $I11, 58, rx2497_fail
    add rx2497_pos, 1
  # rx subrule "before" subtype=zerowidth negate=
    rx2497_cur."!cursor_pos"(rx2497_pos)
    .const 'Sub' $P2502 = "387_1303401201.841" 
    capture_lex $P2502
    $P10 = rx2497_cur."before"($P2502)
    unless $P10, rx2497_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2497_cur."!cursor_pos"(rx2497_pos)
    $P10 = rx2497_cur."LANG"("MAIN", "statement")
    unless $P10, rx2497_fail
    rx2497_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx2497_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2497_cur."!cursor_pos"(rx2497_pos)
    $P10 = rx2497_cur."ws"()
    unless $P10, rx2497_fail
    rx2497_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx2497_pos, 1
    gt $I11, rx2497_eos, rx2497_fail
    sub $I11, rx2497_pos, rx2497_off
    ord $I11, rx2497_tgt, $I11
    ne $I11, 59, rx2497_fail
    add rx2497_pos, 1
.annotate 'line', 728
  # rx pass
    rx2497_cur."!cursor_pass"(rx2497_pos, "metachar:sym<:my>")
    if_null rx2497_debug, debug_1410
    rx2497_cur."!cursor_debug"("PASS", "metachar:sym<:my>", " at pos=", rx2497_pos)
  debug_1410:
    .return (rx2497_cur)
  rx2497_restart:
.annotate 'line', 727
    if_null rx2497_debug, debug_1411
    rx2497_cur."!cursor_debug"("NEXT", "metachar:sym<:my>")
  debug_1411:
  rx2497_fail:
    (rx2497_rep, rx2497_pos, $I10, $P10) = rx2497_cur."!mark_fail"(0)
    lt rx2497_pos, -1, rx2497_done
    eq rx2497_pos, -1, rx2497_fail
    jump $I10
  rx2497_done:
    rx2497_cur."!cursor_fail"()
    if_null rx2497_debug, debug_1412
    rx2497_cur."!cursor_debug"("FAIL", "metachar:sym<:my>")
  debug_1412:
    .return (rx2497_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<:my>"  :nsentry("!PREFIX__metachar:sym<:my>") :subid("386_1303401201.841") :method
.annotate 'line', 727
    new $P2499, "ResizablePMCArray"
    push $P2499, ":"
    .return ($P2499)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2501"  :anon :subid("387_1303401201.841") :method :outer("385_1303401201.841")
.annotate 'line', 729
    .local string rx2503_tgt
    .local int rx2503_pos
    .local int rx2503_off
    .local int rx2503_eos
    .local int rx2503_rep
    .local pmc rx2503_cur
    .local pmc rx2503_debug
    (rx2503_cur, rx2503_pos, rx2503_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2503_cur
    .local pmc match
    .lex "$/", match
    length rx2503_eos, rx2503_tgt
    gt rx2503_pos, rx2503_eos, rx2503_done
    set rx2503_off, 0
    lt rx2503_pos, 2, rx2503_start
    sub rx2503_off, rx2503_pos, 1
    substr rx2503_tgt, rx2503_tgt, rx2503_off
  rx2503_start:
    eq $I10, 1, rx2503_restart
    if_null rx2503_debug, debug_1406
    rx2503_cur."!cursor_debug"("START", "")
  debug_1406:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2504_done
    goto rxscan2504_scan
  rxscan2504_loop:
    (rx2503_pos) = rx2503_cur."from"()
    inc rx2503_pos
    rx2503_cur."!cursor_from"(rx2503_pos)
    ge rx2503_pos, rx2503_eos, rxscan2504_done
  rxscan2504_scan:
    set_addr $I10, rxscan2504_loop
    rx2503_cur."!mark_push"(0, rx2503_pos, $I10)
  rxscan2504_done:
  # rx literal  "my"
    add $I11, rx2503_pos, 2
    gt $I11, rx2503_eos, rx2503_fail
    sub $I11, rx2503_pos, rx2503_off
    substr $S10, rx2503_tgt, $I11, 2
    ne $S10, "my", rx2503_fail
    add rx2503_pos, 2
  # rx pass
    rx2503_cur."!cursor_pass"(rx2503_pos, "")
    if_null rx2503_debug, debug_1407
    rx2503_cur."!cursor_debug"("PASS", "", " at pos=", rx2503_pos)
  debug_1407:
    .return (rx2503_cur)
  rx2503_restart:
    if_null rx2503_debug, debug_1408
    rx2503_cur."!cursor_debug"("NEXT", "")
  debug_1408:
  rx2503_fail:
    (rx2503_rep, rx2503_pos, $I10, $P10) = rx2503_cur."!mark_fail"(0)
    lt rx2503_pos, -1, rx2503_done
    eq rx2503_pos, -1, rx2503_fail
    jump $I10
  rx2503_done:
    rx2503_cur."!cursor_fail"()
    if_null rx2503_debug, debug_1409
    rx2503_cur."!cursor_debug"("FAIL", "")
  debug_1409:
    .return (rx2503_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<{ }>"  :subid("388_1303401201.841") :method :outer("384_1303401201.841")
.annotate 'line', 727
    .local string rx2506_tgt
    .local int rx2506_pos
    .local int rx2506_off
    .local int rx2506_eos
    .local int rx2506_rep
    .local pmc rx2506_cur
    .local pmc rx2506_debug
    (rx2506_cur, rx2506_pos, rx2506_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2506_cur
    .local pmc match
    .lex "$/", match
    length rx2506_eos, rx2506_tgt
    gt rx2506_pos, rx2506_eos, rx2506_done
    set rx2506_off, 0
    lt rx2506_pos, 2, rx2506_start
    sub rx2506_off, rx2506_pos, 1
    substr rx2506_tgt, rx2506_tgt, rx2506_off
  rx2506_start:
    eq $I10, 1, rx2506_restart
    if_null rx2506_debug, debug_1413
    rx2506_cur."!cursor_debug"("START", "metachar:sym<{ }>")
  debug_1413:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2509_done
    goto rxscan2509_scan
  rxscan2509_loop:
    (rx2506_pos) = rx2506_cur."from"()
    inc rx2506_pos
    rx2506_cur."!cursor_from"(rx2506_pos)
    ge rx2506_pos, rx2506_eos, rxscan2509_done
  rxscan2509_scan:
    set_addr $I10, rxscan2509_loop
    rx2506_cur."!mark_push"(0, rx2506_pos, $I10)
  rxscan2509_done:
.annotate 'line', 733
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2506_pos, rx2506_off
    substr $S10, rx2506_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2506_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx2506_cur."!cursor_pos"(rx2506_pos)
    $P10 = rx2506_cur."codeblock"()
    unless $P10, rx2506_fail
    rx2506_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2506_pos = $P10."pos"()
.annotate 'line', 732
  # rx pass
    rx2506_cur."!cursor_pass"(rx2506_pos, "metachar:sym<{ }>")
    if_null rx2506_debug, debug_1414
    rx2506_cur."!cursor_debug"("PASS", "metachar:sym<{ }>", " at pos=", rx2506_pos)
  debug_1414:
    .return (rx2506_cur)
  rx2506_restart:
.annotate 'line', 727
    if_null rx2506_debug, debug_1415
    rx2506_cur."!cursor_debug"("NEXT", "metachar:sym<{ }>")
  debug_1415:
  rx2506_fail:
    (rx2506_rep, rx2506_pos, $I10, $P10) = rx2506_cur."!mark_fail"(0)
    lt rx2506_pos, -1, rx2506_done
    eq rx2506_pos, -1, rx2506_fail
    jump $I10
  rx2506_done:
    rx2506_cur."!cursor_fail"()
    if_null rx2506_debug, debug_1416
    rx2506_cur."!cursor_debug"("FAIL", "metachar:sym<{ }>")
  debug_1416:
    .return (rx2506_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<{ }>"  :nsentry("!PREFIX__metachar:sym<{ }>") :subid("389_1303401201.841") :method
.annotate 'line', 727
    new $P2508, "ResizablePMCArray"
    push $P2508, "{"
    .return ($P2508)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<nqpvar>"  :subid("390_1303401201.841") :method :outer("384_1303401201.841")
.annotate 'line', 727
    .const 'Sub' $P2516 = "392_1303401201.841" 
    capture_lex $P2516
    .local string rx2511_tgt
    .local int rx2511_pos
    .local int rx2511_off
    .local int rx2511_eos
    .local int rx2511_rep
    .local pmc rx2511_cur
    .local pmc rx2511_debug
    (rx2511_cur, rx2511_pos, rx2511_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2511_cur
    .local pmc match
    .lex "$/", match
    length rx2511_eos, rx2511_tgt
    gt rx2511_pos, rx2511_eos, rx2511_done
    set rx2511_off, 0
    lt rx2511_pos, 2, rx2511_start
    sub rx2511_off, rx2511_pos, 1
    substr rx2511_tgt, rx2511_tgt, rx2511_off
  rx2511_start:
    eq $I10, 1, rx2511_restart
    if_null rx2511_debug, debug_1417
    rx2511_cur."!cursor_debug"("START", "metachar:sym<nqpvar>")
  debug_1417:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2514_done
    goto rxscan2514_scan
  rxscan2514_loop:
    (rx2511_pos) = rx2511_cur."from"()
    inc rx2511_pos
    rx2511_cur."!cursor_from"(rx2511_pos)
    ge rx2511_pos, rx2511_eos, rxscan2514_done
  rxscan2514_scan:
    set_addr $I10, rxscan2514_loop
    rx2511_cur."!mark_push"(0, rx2511_pos, $I10)
  rxscan2514_done:
.annotate 'line', 737
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2511_pos, rx2511_off
    substr $S10, rx2511_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx2511_fail
  # rx subrule "before" subtype=zerowidth negate=
    rx2511_cur."!cursor_pos"(rx2511_pos)
    .const 'Sub' $P2516 = "392_1303401201.841" 
    capture_lex $P2516
    $P10 = rx2511_cur."before"($P2516)
    unless $P10, rx2511_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2511_cur."!cursor_pos"(rx2511_pos)
    $P10 = rx2511_cur."LANG"("MAIN", "variable")
    unless $P10, rx2511_fail
    rx2511_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx2511_pos = $P10."pos"()
.annotate 'line', 736
  # rx pass
    rx2511_cur."!cursor_pass"(rx2511_pos, "metachar:sym<nqpvar>")
    if_null rx2511_debug, debug_1422
    rx2511_cur."!cursor_debug"("PASS", "metachar:sym<nqpvar>", " at pos=", rx2511_pos)
  debug_1422:
    .return (rx2511_cur)
  rx2511_restart:
.annotate 'line', 727
    if_null rx2511_debug, debug_1423
    rx2511_cur."!cursor_debug"("NEXT", "metachar:sym<nqpvar>")
  debug_1423:
  rx2511_fail:
    (rx2511_rep, rx2511_pos, $I10, $P10) = rx2511_cur."!mark_fail"(0)
    lt rx2511_pos, -1, rx2511_done
    eq rx2511_pos, -1, rx2511_fail
    jump $I10
  rx2511_done:
    rx2511_cur."!cursor_fail"()
    if_null rx2511_debug, debug_1424
    rx2511_cur."!cursor_debug"("FAIL", "metachar:sym<nqpvar>")
  debug_1424:
    .return (rx2511_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<nqpvar>"  :nsentry("!PREFIX__metachar:sym<nqpvar>") :subid("391_1303401201.841") :method
.annotate 'line', 727
    new $P2513, "ResizablePMCArray"
    push $P2513, "$"
    push $P2513, "@"
    .return ($P2513)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2515"  :anon :subid("392_1303401201.841") :method :outer("390_1303401201.841")
.annotate 'line', 737
    .local string rx2517_tgt
    .local int rx2517_pos
    .local int rx2517_off
    .local int rx2517_eos
    .local int rx2517_rep
    .local pmc rx2517_cur
    .local pmc rx2517_debug
    (rx2517_cur, rx2517_pos, rx2517_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2517_cur
    .local pmc match
    .lex "$/", match
    length rx2517_eos, rx2517_tgt
    gt rx2517_pos, rx2517_eos, rx2517_done
    set rx2517_off, 0
    lt rx2517_pos, 2, rx2517_start
    sub rx2517_off, rx2517_pos, 1
    substr rx2517_tgt, rx2517_tgt, rx2517_off
  rx2517_start:
    eq $I10, 1, rx2517_restart
    if_null rx2517_debug, debug_1418
    rx2517_cur."!cursor_debug"("START", "")
  debug_1418:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2518_done
    goto rxscan2518_scan
  rxscan2518_loop:
    (rx2517_pos) = rx2517_cur."from"()
    inc rx2517_pos
    rx2517_cur."!cursor_from"(rx2517_pos)
    ge rx2517_pos, rx2517_eos, rxscan2518_done
  rxscan2518_scan:
    set_addr $I10, rxscan2518_loop
    rx2517_cur."!mark_push"(0, rx2517_pos, $I10)
  rxscan2518_done:
  # rx charclass .
    ge rx2517_pos, rx2517_eos, rx2517_fail
    inc rx2517_pos
  # rx charclass w
    ge rx2517_pos, rx2517_eos, rx2517_fail
    sub $I10, rx2517_pos, rx2517_off
    is_cclass $I11, 8192, rx2517_tgt, $I10
    unless $I11, rx2517_fail
    inc rx2517_pos
  # rx pass
    rx2517_cur."!cursor_pass"(rx2517_pos, "")
    if_null rx2517_debug, debug_1419
    rx2517_cur."!cursor_debug"("PASS", "", " at pos=", rx2517_pos)
  debug_1419:
    .return (rx2517_cur)
  rx2517_restart:
    if_null rx2517_debug, debug_1420
    rx2517_cur."!cursor_debug"("NEXT", "")
  debug_1420:
  rx2517_fail:
    (rx2517_rep, rx2517_pos, $I10, $P10) = rx2517_cur."!mark_fail"(0)
    lt rx2517_pos, -1, rx2517_done
    eq rx2517_pos, -1, rx2517_fail
    jump $I10
  rx2517_done:
    rx2517_cur."!cursor_fail"()
    if_null rx2517_debug, debug_1421
    rx2517_cur."!cursor_debug"("FAIL", "")
  debug_1421:
    .return (rx2517_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<{ }>"  :subid("393_1303401201.841") :method :outer("384_1303401201.841")
.annotate 'line', 727
    .local string rx2520_tgt
    .local int rx2520_pos
    .local int rx2520_off
    .local int rx2520_eos
    .local int rx2520_rep
    .local pmc rx2520_cur
    .local pmc rx2520_debug
    (rx2520_cur, rx2520_pos, rx2520_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2520_cur
    .local pmc match
    .lex "$/", match
    length rx2520_eos, rx2520_tgt
    gt rx2520_pos, rx2520_eos, rx2520_done
    set rx2520_off, 0
    lt rx2520_pos, 2, rx2520_start
    sub rx2520_off, rx2520_pos, 1
    substr rx2520_tgt, rx2520_tgt, rx2520_off
  rx2520_start:
    eq $I10, 1, rx2520_restart
    if_null rx2520_debug, debug_1425
    rx2520_cur."!cursor_debug"("START", "assertion:sym<{ }>")
  debug_1425:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2523_done
    goto rxscan2523_scan
  rxscan2523_loop:
    (rx2520_pos) = rx2520_cur."from"()
    inc rx2520_pos
    rx2520_cur."!cursor_from"(rx2520_pos)
    ge rx2520_pos, rx2520_eos, rxscan2523_done
  rxscan2523_scan:
    set_addr $I10, rxscan2523_loop
    rx2520_cur."!mark_push"(0, rx2520_pos, $I10)
  rxscan2523_done:
.annotate 'line', 741
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2520_pos, rx2520_off
    substr $S10, rx2520_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2520_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx2520_cur."!cursor_pos"(rx2520_pos)
    $P10 = rx2520_cur."codeblock"()
    unless $P10, rx2520_fail
    rx2520_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2520_pos = $P10."pos"()
.annotate 'line', 740
  # rx pass
    rx2520_cur."!cursor_pass"(rx2520_pos, "assertion:sym<{ }>")
    if_null rx2520_debug, debug_1426
    rx2520_cur."!cursor_debug"("PASS", "assertion:sym<{ }>", " at pos=", rx2520_pos)
  debug_1426:
    .return (rx2520_cur)
  rx2520_restart:
.annotate 'line', 727
    if_null rx2520_debug, debug_1427
    rx2520_cur."!cursor_debug"("NEXT", "assertion:sym<{ }>")
  debug_1427:
  rx2520_fail:
    (rx2520_rep, rx2520_pos, $I10, $P10) = rx2520_cur."!mark_fail"(0)
    lt rx2520_pos, -1, rx2520_done
    eq rx2520_pos, -1, rx2520_fail
    jump $I10
  rx2520_done:
    rx2520_cur."!cursor_fail"()
    if_null rx2520_debug, debug_1428
    rx2520_cur."!cursor_debug"("FAIL", "assertion:sym<{ }>")
  debug_1428:
    .return (rx2520_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<{ }>"  :nsentry("!PREFIX__assertion:sym<{ }>") :subid("394_1303401201.841") :method
.annotate 'line', 727
    new $P2522, "ResizablePMCArray"
    push $P2522, "{"
    .return ($P2522)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<?{ }>"  :subid("395_1303401201.841") :method :outer("384_1303401201.841")
.annotate 'line', 727
    .const 'Sub' $P2530 = "397_1303401201.841" 
    capture_lex $P2530
    .local string rx2525_tgt
    .local int rx2525_pos
    .local int rx2525_off
    .local int rx2525_eos
    .local int rx2525_rep
    .local pmc rx2525_cur
    .local pmc rx2525_debug
    (rx2525_cur, rx2525_pos, rx2525_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2525_cur
    .local pmc match
    .lex "$/", match
    length rx2525_eos, rx2525_tgt
    gt rx2525_pos, rx2525_eos, rx2525_done
    set rx2525_off, 0
    lt rx2525_pos, 2, rx2525_start
    sub rx2525_off, rx2525_pos, 1
    substr rx2525_tgt, rx2525_tgt, rx2525_off
  rx2525_start:
    eq $I10, 1, rx2525_restart
    if_null rx2525_debug, debug_1429
    rx2525_cur."!cursor_debug"("START", "assertion:sym<?{ }>")
  debug_1429:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2528_done
    goto rxscan2528_scan
  rxscan2528_loop:
    (rx2525_pos) = rx2525_cur."from"()
    inc rx2525_pos
    rx2525_cur."!cursor_from"(rx2525_pos)
    ge rx2525_pos, rx2525_eos, rxscan2528_done
  rxscan2528_scan:
    set_addr $I10, rxscan2528_loop
    rx2525_cur."!mark_push"(0, rx2525_pos, $I10)
  rxscan2528_done:
.annotate 'line', 745
  # rx subcapture "zw"
    set_addr $I10, rxcap_2533_fail
    rx2525_cur."!mark_push"(0, rx2525_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx2525_pos, rx2525_eos, rx2525_fail
    sub $I10, rx2525_pos, rx2525_off
    substr $S10, rx2525_tgt, $I10, 1
    index $I11, "?!", $S10
    lt $I11, 0, rx2525_fail
    inc rx2525_pos
  # rx subrule "before" subtype=zerowidth negate=
    rx2525_cur."!cursor_pos"(rx2525_pos)
    .const 'Sub' $P2530 = "397_1303401201.841" 
    capture_lex $P2530
    $P10 = rx2525_cur."before"($P2530)
    unless $P10, rx2525_fail
    set_addr $I10, rxcap_2533_fail
    ($I12, $I11) = rx2525_cur."!mark_peek"($I10)
    rx2525_cur."!cursor_pos"($I11)
    ($P10) = rx2525_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2525_pos, "")
    rx2525_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("zw")
    goto rxcap_2533_done
  rxcap_2533_fail:
    goto rx2525_fail
  rxcap_2533_done:
  # rx subrule "codeblock" subtype=capture negate=
    rx2525_cur."!cursor_pos"(rx2525_pos)
    $P10 = rx2525_cur."codeblock"()
    unless $P10, rx2525_fail
    rx2525_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2525_pos = $P10."pos"()
.annotate 'line', 744
  # rx pass
    rx2525_cur."!cursor_pass"(rx2525_pos, "assertion:sym<?{ }>")
    if_null rx2525_debug, debug_1434
    rx2525_cur."!cursor_debug"("PASS", "assertion:sym<?{ }>", " at pos=", rx2525_pos)
  debug_1434:
    .return (rx2525_cur)
  rx2525_restart:
.annotate 'line', 727
    if_null rx2525_debug, debug_1435
    rx2525_cur."!cursor_debug"("NEXT", "assertion:sym<?{ }>")
  debug_1435:
  rx2525_fail:
    (rx2525_rep, rx2525_pos, $I10, $P10) = rx2525_cur."!mark_fail"(0)
    lt rx2525_pos, -1, rx2525_done
    eq rx2525_pos, -1, rx2525_fail
    jump $I10
  rx2525_done:
    rx2525_cur."!cursor_fail"()
    if_null rx2525_debug, debug_1436
    rx2525_cur."!cursor_debug"("FAIL", "assertion:sym<?{ }>")
  debug_1436:
    .return (rx2525_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<?{ }>"  :nsentry("!PREFIX__assertion:sym<?{ }>") :subid("396_1303401201.841") :method
.annotate 'line', 727
    new $P2527, "ResizablePMCArray"
    push $P2527, "!"
    push $P2527, "?"
    .return ($P2527)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2529"  :anon :subid("397_1303401201.841") :method :outer("395_1303401201.841")
.annotate 'line', 745
    .local string rx2531_tgt
    .local int rx2531_pos
    .local int rx2531_off
    .local int rx2531_eos
    .local int rx2531_rep
    .local pmc rx2531_cur
    .local pmc rx2531_debug
    (rx2531_cur, rx2531_pos, rx2531_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2531_cur
    .local pmc match
    .lex "$/", match
    length rx2531_eos, rx2531_tgt
    gt rx2531_pos, rx2531_eos, rx2531_done
    set rx2531_off, 0
    lt rx2531_pos, 2, rx2531_start
    sub rx2531_off, rx2531_pos, 1
    substr rx2531_tgt, rx2531_tgt, rx2531_off
  rx2531_start:
    eq $I10, 1, rx2531_restart
    if_null rx2531_debug, debug_1430
    rx2531_cur."!cursor_debug"("START", "")
  debug_1430:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2532_done
    goto rxscan2532_scan
  rxscan2532_loop:
    (rx2531_pos) = rx2531_cur."from"()
    inc rx2531_pos
    rx2531_cur."!cursor_from"(rx2531_pos)
    ge rx2531_pos, rx2531_eos, rxscan2532_done
  rxscan2532_scan:
    set_addr $I10, rxscan2532_loop
    rx2531_cur."!mark_push"(0, rx2531_pos, $I10)
  rxscan2532_done:
  # rx literal  "{"
    add $I11, rx2531_pos, 1
    gt $I11, rx2531_eos, rx2531_fail
    sub $I11, rx2531_pos, rx2531_off
    ord $I11, rx2531_tgt, $I11
    ne $I11, 123, rx2531_fail
    add rx2531_pos, 1
  # rx pass
    rx2531_cur."!cursor_pass"(rx2531_pos, "")
    if_null rx2531_debug, debug_1431
    rx2531_cur."!cursor_debug"("PASS", "", " at pos=", rx2531_pos)
  debug_1431:
    .return (rx2531_cur)
  rx2531_restart:
    if_null rx2531_debug, debug_1432
    rx2531_cur."!cursor_debug"("NEXT", "")
  debug_1432:
  rx2531_fail:
    (rx2531_rep, rx2531_pos, $I10, $P10) = rx2531_cur."!mark_fail"(0)
    lt rx2531_pos, -1, rx2531_done
    eq rx2531_pos, -1, rx2531_fail
    jump $I10
  rx2531_done:
    rx2531_cur."!cursor_fail"()
    if_null rx2531_debug, debug_1433
    rx2531_cur."!cursor_debug"("FAIL", "")
  debug_1433:
    .return (rx2531_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<name>"  :subid("398_1303401201.841") :method :outer("384_1303401201.841")
.annotate 'line', 727
    .const 'Sub' $P2543 = "400_1303401201.841" 
    capture_lex $P2543
    .local string rx2535_tgt
    .local int rx2535_pos
    .local int rx2535_off
    .local int rx2535_eos
    .local int rx2535_rep
    .local pmc rx2535_cur
    .local pmc rx2535_debug
    (rx2535_cur, rx2535_pos, rx2535_tgt, $I10) = self."!cursor_start"()
    rx2535_cur."!cursor_caparray"("assertion", "arglist", "nibbler")
    .lex unicode:"$\x{a2}", rx2535_cur
    .local pmc match
    .lex "$/", match
    length rx2535_eos, rx2535_tgt
    gt rx2535_pos, rx2535_eos, rx2535_done
    set rx2535_off, 0
    lt rx2535_pos, 2, rx2535_start
    sub rx2535_off, rx2535_pos, 1
    substr rx2535_tgt, rx2535_tgt, rx2535_off
  rx2535_start:
    eq $I10, 1, rx2535_restart
    if_null rx2535_debug, debug_1437
    rx2535_cur."!cursor_debug"("START", "assertion:sym<name>")
  debug_1437:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2539_done
    goto rxscan2539_scan
  rxscan2539_loop:
    (rx2535_pos) = rx2535_cur."from"()
    inc rx2535_pos
    rx2535_cur."!cursor_from"(rx2535_pos)
    ge rx2535_pos, rx2535_eos, rxscan2539_done
  rxscan2539_scan:
    set_addr $I10, rxscan2539_loop
    rx2535_cur."!mark_push"(0, rx2535_pos, $I10)
  rxscan2539_done:
.annotate 'line', 749
  # rx subrule "identifier" subtype=capture negate=
    rx2535_cur."!cursor_pos"(rx2535_pos)
    $P10 = rx2535_cur."identifier"()
    unless $P10, rx2535_fail
    rx2535_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx2535_pos = $P10."pos"()
.annotate 'line', 756
  # rx rxquantr2540 ** 0..1
    set_addr $I10, rxquantr2540_done
    rx2535_cur."!mark_push"(0, rx2535_pos, $I10)
  rxquantr2540_loop:
  alt2541_0:
.annotate 'line', 750
    set_addr $I10, alt2541_1
    rx2535_cur."!mark_push"(0, rx2535_pos, $I10)
.annotate 'line', 751
  # rx subrule "before" subtype=zerowidth negate=
    rx2535_cur."!cursor_pos"(rx2535_pos)
    .const 'Sub' $P2543 = "400_1303401201.841" 
    capture_lex $P2543
    $P10 = rx2535_cur."before"($P2543)
    unless $P10, rx2535_fail
    goto alt2541_end
  alt2541_1:
    set_addr $I10, alt2541_2
    rx2535_cur."!mark_push"(0, rx2535_pos, $I10)
.annotate 'line', 752
  # rx literal  "="
    add $I11, rx2535_pos, 1
    gt $I11, rx2535_eos, rx2535_fail
    sub $I11, rx2535_pos, rx2535_off
    ord $I11, rx2535_tgt, $I11
    ne $I11, 61, rx2535_fail
    add rx2535_pos, 1
  # rx subrule "assertion" subtype=capture negate=
    rx2535_cur."!cursor_pos"(rx2535_pos)
    $P10 = rx2535_cur."assertion"()
    unless $P10, rx2535_fail
    rx2535_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("assertion")
    rx2535_pos = $P10."pos"()
    goto alt2541_end
  alt2541_2:
    set_addr $I10, alt2541_3
    rx2535_cur."!mark_push"(0, rx2535_pos, $I10)
.annotate 'line', 753
  # rx literal  ":"
    add $I11, rx2535_pos, 1
    gt $I11, rx2535_eos, rx2535_fail
    sub $I11, rx2535_pos, rx2535_off
    ord $I11, rx2535_tgt, $I11
    ne $I11, 58, rx2535_fail
    add rx2535_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx2535_cur."!cursor_pos"(rx2535_pos)
    $P10 = rx2535_cur."arglist"()
    unless $P10, rx2535_fail
    rx2535_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2535_pos = $P10."pos"()
    goto alt2541_end
  alt2541_3:
    set_addr $I10, alt2541_4
    rx2535_cur."!mark_push"(0, rx2535_pos, $I10)
.annotate 'line', 754
  # rx literal  "("
    add $I11, rx2535_pos, 1
    gt $I11, rx2535_eos, rx2535_fail
    sub $I11, rx2535_pos, rx2535_off
    ord $I11, rx2535_tgt, $I11
    ne $I11, 40, rx2535_fail
    add rx2535_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx2535_cur."!cursor_pos"(rx2535_pos)
    $P10 = rx2535_cur."LANG"("MAIN", "arglist")
    unless $P10, rx2535_fail
    rx2535_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2535_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx2535_pos, 1
    gt $I11, rx2535_eos, rx2535_fail
    sub $I11, rx2535_pos, rx2535_off
    ord $I11, rx2535_tgt, $I11
    ne $I11, 41, rx2535_fail
    add rx2535_pos, 1
    goto alt2541_end
  alt2541_4:
.annotate 'line', 755
  # rx subrule "normspace" subtype=method negate=
    rx2535_cur."!cursor_pos"(rx2535_pos)
    $P10 = rx2535_cur."normspace"()
    unless $P10, rx2535_fail
    rx2535_pos = $P10."pos"()
  # rx subrule "nibbler" subtype=capture negate=
    rx2535_cur."!cursor_pos"(rx2535_pos)
    $P10 = rx2535_cur."nibbler"()
    unless $P10, rx2535_fail
    rx2535_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("nibbler")
    rx2535_pos = $P10."pos"()
  alt2541_end:
.annotate 'line', 756
    set_addr $I10, rxquantr2540_done
    (rx2535_rep) = rx2535_cur."!mark_commit"($I10)
  rxquantr2540_done:
.annotate 'line', 748
  # rx pass
    rx2535_cur."!cursor_pass"(rx2535_pos, "assertion:sym<name>")
    if_null rx2535_debug, debug_1442
    rx2535_cur."!cursor_debug"("PASS", "assertion:sym<name>", " at pos=", rx2535_pos)
  debug_1442:
    .return (rx2535_cur)
  rx2535_restart:
.annotate 'line', 727
    if_null rx2535_debug, debug_1443
    rx2535_cur."!cursor_debug"("NEXT", "assertion:sym<name>")
  debug_1443:
  rx2535_fail:
    (rx2535_rep, rx2535_pos, $I10, $P10) = rx2535_cur."!mark_fail"(0)
    lt rx2535_pos, -1, rx2535_done
    eq rx2535_pos, -1, rx2535_fail
    jump $I10
  rx2535_done:
    rx2535_cur."!cursor_fail"()
    if_null rx2535_debug, debug_1444
    rx2535_cur."!cursor_debug"("FAIL", "assertion:sym<name>")
  debug_1444:
    .return (rx2535_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<name>"  :nsentry("!PREFIX__assertion:sym<name>") :subid("399_1303401201.841") :method
.annotate 'line', 727
    $P2537 = self."!PREFIX__!subrule"("identifier", "")
    new $P2538, "ResizablePMCArray"
    push $P2538, $P2537
    .return ($P2538)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2542"  :anon :subid("400_1303401201.841") :method :outer("398_1303401201.841")
.annotate 'line', 751
    .local string rx2544_tgt
    .local int rx2544_pos
    .local int rx2544_off
    .local int rx2544_eos
    .local int rx2544_rep
    .local pmc rx2544_cur
    .local pmc rx2544_debug
    (rx2544_cur, rx2544_pos, rx2544_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2544_cur
    .local pmc match
    .lex "$/", match
    length rx2544_eos, rx2544_tgt
    gt rx2544_pos, rx2544_eos, rx2544_done
    set rx2544_off, 0
    lt rx2544_pos, 2, rx2544_start
    sub rx2544_off, rx2544_pos, 1
    substr rx2544_tgt, rx2544_tgt, rx2544_off
  rx2544_start:
    eq $I10, 1, rx2544_restart
    if_null rx2544_debug, debug_1438
    rx2544_cur."!cursor_debug"("START", "")
  debug_1438:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2545_done
    goto rxscan2545_scan
  rxscan2545_loop:
    (rx2544_pos) = rx2544_cur."from"()
    inc rx2544_pos
    rx2544_cur."!cursor_from"(rx2544_pos)
    ge rx2544_pos, rx2544_eos, rxscan2545_done
  rxscan2545_scan:
    set_addr $I10, rxscan2545_loop
    rx2544_cur."!mark_push"(0, rx2544_pos, $I10)
  rxscan2545_done:
  # rx literal  ">"
    add $I11, rx2544_pos, 1
    gt $I11, rx2544_eos, rx2544_fail
    sub $I11, rx2544_pos, rx2544_off
    ord $I11, rx2544_tgt, $I11
    ne $I11, 62, rx2544_fail
    add rx2544_pos, 1
  # rx pass
    rx2544_cur."!cursor_pass"(rx2544_pos, "")
    if_null rx2544_debug, debug_1439
    rx2544_cur."!cursor_debug"("PASS", "", " at pos=", rx2544_pos)
  debug_1439:
    .return (rx2544_cur)
  rx2544_restart:
    if_null rx2544_debug, debug_1440
    rx2544_cur."!cursor_debug"("NEXT", "")
  debug_1440:
  rx2544_fail:
    (rx2544_rep, rx2544_pos, $I10, $P10) = rx2544_cur."!mark_fail"(0)
    lt rx2544_pos, -1, rx2544_done
    eq rx2544_pos, -1, rx2544_fail
    jump $I10
  rx2544_done:
    rx2544_cur."!cursor_fail"()
    if_null rx2544_debug, debug_1441
    rx2544_cur."!cursor_debug"("FAIL", "")
  debug_1441:
    .return (rx2544_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<var>"  :subid("401_1303401201.841") :method :outer("384_1303401201.841")
.annotate 'line', 727
    .local string rx2547_tgt
    .local int rx2547_pos
    .local int rx2547_off
    .local int rx2547_eos
    .local int rx2547_rep
    .local pmc rx2547_cur
    .local pmc rx2547_debug
    (rx2547_cur, rx2547_pos, rx2547_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2547_cur
    .local pmc match
    .lex "$/", match
    length rx2547_eos, rx2547_tgt
    gt rx2547_pos, rx2547_eos, rx2547_done
    set rx2547_off, 0
    lt rx2547_pos, 2, rx2547_start
    sub rx2547_off, rx2547_pos, 1
    substr rx2547_tgt, rx2547_tgt, rx2547_off
  rx2547_start:
    eq $I10, 1, rx2547_restart
    if_null rx2547_debug, debug_1445
    rx2547_cur."!cursor_debug"("START", "assertion:sym<var>")
  debug_1445:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2550_done
    goto rxscan2550_scan
  rxscan2550_loop:
    (rx2547_pos) = rx2547_cur."from"()
    inc rx2547_pos
    rx2547_cur."!cursor_from"(rx2547_pos)
    ge rx2547_pos, rx2547_eos, rxscan2550_done
  rxscan2550_scan:
    set_addr $I10, rxscan2550_loop
    rx2547_cur."!mark_push"(0, rx2547_pos, $I10)
  rxscan2550_done:
.annotate 'line', 760
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2547_pos, rx2547_off
    substr $S10, rx2547_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx2547_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2547_cur."!cursor_pos"(rx2547_pos)
    $P10 = rx2547_cur."LANG"("MAIN", "variable")
    unless $P10, rx2547_fail
    rx2547_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx2547_pos = $P10."pos"()
.annotate 'line', 759
  # rx pass
    rx2547_cur."!cursor_pass"(rx2547_pos, "assertion:sym<var>")
    if_null rx2547_debug, debug_1446
    rx2547_cur."!cursor_debug"("PASS", "assertion:sym<var>", " at pos=", rx2547_pos)
  debug_1446:
    .return (rx2547_cur)
  rx2547_restart:
.annotate 'line', 727
    if_null rx2547_debug, debug_1447
    rx2547_cur."!cursor_debug"("NEXT", "assertion:sym<var>")
  debug_1447:
  rx2547_fail:
    (rx2547_rep, rx2547_pos, $I10, $P10) = rx2547_cur."!mark_fail"(0)
    lt rx2547_pos, -1, rx2547_done
    eq rx2547_pos, -1, rx2547_fail
    jump $I10
  rx2547_done:
    rx2547_cur."!cursor_fail"()
    if_null rx2547_debug, debug_1448
    rx2547_cur."!cursor_debug"("FAIL", "assertion:sym<var>")
  debug_1448:
    .return (rx2547_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<var>"  :nsentry("!PREFIX__assertion:sym<var>") :subid("402_1303401201.841") :method
.annotate 'line', 727
    new $P2549, "ResizablePMCArray"
    push $P2549, "$"
    push $P2549, "@"
    .return ($P2549)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "codeblock"  :subid("403_1303401201.841") :method :outer("384_1303401201.841")
.annotate 'line', 727
    .local string rx2552_tgt
    .local int rx2552_pos
    .local int rx2552_off
    .local int rx2552_eos
    .local int rx2552_rep
    .local pmc rx2552_cur
    .local pmc rx2552_debug
    (rx2552_cur, rx2552_pos, rx2552_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2552_cur
    .local pmc match
    .lex "$/", match
    length rx2552_eos, rx2552_tgt
    gt rx2552_pos, rx2552_eos, rx2552_done
    set rx2552_off, 0
    lt rx2552_pos, 2, rx2552_start
    sub rx2552_off, rx2552_pos, 1
    substr rx2552_tgt, rx2552_tgt, rx2552_off
  rx2552_start:
    eq $I10, 1, rx2552_restart
    if_null rx2552_debug, debug_1449
    rx2552_cur."!cursor_debug"("START", "codeblock")
  debug_1449:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2556_done
    goto rxscan2556_scan
  rxscan2556_loop:
    (rx2552_pos) = rx2552_cur."from"()
    inc rx2552_pos
    rx2552_cur."!cursor_from"(rx2552_pos)
    ge rx2552_pos, rx2552_eos, rxscan2556_done
  rxscan2556_scan:
    set_addr $I10, rxscan2556_loop
    rx2552_cur."!mark_push"(0, rx2552_pos, $I10)
  rxscan2556_done:
.annotate 'line', 764
  # rx subrule "LANG" subtype=capture negate=
    rx2552_cur."!cursor_pos"(rx2552_pos)
    $P10 = rx2552_cur."LANG"("MAIN", "pblock")
    unless $P10, rx2552_fail
    rx2552_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx2552_pos = $P10."pos"()
.annotate 'line', 763
  # rx pass
    rx2552_cur."!cursor_pass"(rx2552_pos, "codeblock")
    if_null rx2552_debug, debug_1450
    rx2552_cur."!cursor_debug"("PASS", "codeblock", " at pos=", rx2552_pos)
  debug_1450:
    .return (rx2552_cur)
  rx2552_restart:
.annotate 'line', 727
    if_null rx2552_debug, debug_1451
    rx2552_cur."!cursor_debug"("NEXT", "codeblock")
  debug_1451:
  rx2552_fail:
    (rx2552_rep, rx2552_pos, $I10, $P10) = rx2552_cur."!mark_fail"(0)
    lt rx2552_pos, -1, rx2552_done
    eq rx2552_pos, -1, rx2552_fail
    jump $I10
  rx2552_done:
    rx2552_cur."!cursor_fail"()
    if_null rx2552_debug, debug_1452
    rx2552_cur."!cursor_debug"("FAIL", "codeblock")
  debug_1452:
    .return (rx2552_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__codeblock"  :nsentry("!PREFIX__codeblock") :subid("404_1303401201.841") :method
.annotate 'line', 727
    $P2554 = self."!PREFIX__!subrule"("LANG", "")
    new $P2555, "ResizablePMCArray"
    push $P2555, $P2554
    .return ($P2555)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2596"  :subid("406_1303401201.841") :outer("10_1303401201.841")
.annotate 'line', 770
    .const 'Sub' $P5799 = "561_1303401201.841" 
    capture_lex $P5799
    .const 'Sub' $P5786 = "560_1303401201.841" 
    capture_lex $P5786
    .const 'Sub' $P5781 = "559_1303401201.841" 
    capture_lex $P5781
    .const 'Sub' $P5776 = "558_1303401201.841" 
    capture_lex $P5776
    .const 'Sub' $P5771 = "557_1303401201.841" 
    capture_lex $P5771
    .const 'Sub' $P5760 = "556_1303401201.841" 
    capture_lex $P5760
    .const 'Sub' $P5752 = "555_1303401201.841" 
    capture_lex $P5752
    .const 'Sub' $P5744 = "554_1303401201.841" 
    capture_lex $P5744
    .const 'Sub' $P5736 = "553_1303401201.841" 
    capture_lex $P5736
    .const 'Sub' $P5731 = "552_1303401201.841" 
    capture_lex $P5731
    .const 'Sub' $P5719 = "551_1303401201.841" 
    capture_lex $P5719
    .const 'Sub' $P5711 = "550_1303401201.841" 
    capture_lex $P5711
    .const 'Sub' $P5664 = "549_1303401201.841" 
    capture_lex $P5664
    .const 'Sub' $P5652 = "548_1303401201.841" 
    capture_lex $P5652
    .const 'Sub' $P5644 = "547_1303401201.841" 
    capture_lex $P5644
    .const 'Sub' $P5636 = "546_1303401201.841" 
    capture_lex $P5636
    .const 'Sub' $P5628 = "545_1303401201.841" 
    capture_lex $P5628
    .const 'Sub' $P5620 = "544_1303401201.841" 
    capture_lex $P5620
    .const 'Sub' $P5612 = "543_1303401201.841" 
    capture_lex $P5612
    .const 'Sub' $P5586 = "542_1303401201.841" 
    capture_lex $P5586
    .const 'Sub' $P5571 = "541_1303401201.841" 
    capture_lex $P5571
    .const 'Sub' $P5563 = "540_1303401201.841" 
    capture_lex $P5563
    .const 'Sub' $P5552 = "539_1303401201.841" 
    capture_lex $P5552
    .const 'Sub' $P5541 = "538_1303401201.841" 
    capture_lex $P5541
    .const 'Sub' $P5530 = "537_1303401201.841" 
    capture_lex $P5530
    .const 'Sub' $P5522 = "536_1303401201.841" 
    capture_lex $P5522
    .const 'Sub' $P5495 = "535_1303401201.841" 
    capture_lex $P5495
    .const 'Sub' $P5457 = "533_1303401201.841" 
    capture_lex $P5457
    .const 'Sub' $P5449 = "532_1303401201.841" 
    capture_lex $P5449
    .const 'Sub' $P5441 = "531_1303401201.841" 
    capture_lex $P5441
    .const 'Sub' $P5416 = "530_1303401201.841" 
    capture_lex $P5416
    .const 'Sub' $P5400 = "529_1303401201.841" 
    capture_lex $P5400
    .const 'Sub' $P5392 = "528_1303401201.841" 
    capture_lex $P5392
    .const 'Sub' $P5384 = "527_1303401201.841" 
    capture_lex $P5384
    .const 'Sub' $P5282 = "524_1303401201.841" 
    capture_lex $P5282
    .const 'Sub' $P5274 = "523_1303401201.841" 
    capture_lex $P5274
    .const 'Sub' $P5267 = "522_1303401201.841" 
    capture_lex $P5267
    .const 'Sub' $P5236 = "521_1303401201.841" 
    capture_lex $P5236
    .const 'Sub' $P5183 = "519_1303401201.841" 
    capture_lex $P5183
    .const 'Sub' $P5169 = "518_1303401201.841" 
    capture_lex $P5169
    .const 'Sub' $P5162 = "517_1303401201.841" 
    capture_lex $P5162
    .const 'Sub' $P5113 = "516_1303401201.841" 
    capture_lex $P5113
    .const 'Sub' $P4937 = "512_1303401201.841" 
    capture_lex $P4937
    .const 'Sub' $P4874 = "510_1303401201.841" 
    capture_lex $P4874
    .const 'Sub' $P4866 = "509_1303401201.841" 
    capture_lex $P4866
    .const 'Sub' $P4851 = "508_1303401201.841" 
    capture_lex $P4851
    .const 'Sub' $P4836 = "507_1303401201.841" 
    capture_lex $P4836
    .const 'Sub' $P4816 = "506_1303401201.841" 
    capture_lex $P4816
    .const 'Sub' $P4713 = "505_1303401201.841" 
    capture_lex $P4713
    .const 'Sub' $P4665 = "502_1303401201.841" 
    capture_lex $P4665
    .const 'Sub' $P4540 = "499_1303401201.841" 
    capture_lex $P4540
    .const 'Sub' $P4267 = "492_1303401201.841" 
    capture_lex $P4267
    .const 'Sub' $P4259 = "491_1303401201.841" 
    capture_lex $P4259
    .const 'Sub' $P4251 = "490_1303401201.841" 
    capture_lex $P4251
    .const 'Sub' $P4143 = "487_1303401201.841" 
    capture_lex $P4143
    .const 'Sub' $P4135 = "486_1303401201.841" 
    capture_lex $P4135
    .const 'Sub' $P4120 = "485_1303401201.841" 
    capture_lex $P4120
    .const 'Sub' $P4105 = "484_1303401201.841" 
    capture_lex $P4105
    .const 'Sub' $P4090 = "483_1303401201.841" 
    capture_lex $P4090
    .const 'Sub' $P4068 = "482_1303401201.841" 
    capture_lex $P4068
    .const 'Sub' $P4060 = "481_1303401201.841" 
    capture_lex $P4060
    .const 'Sub' $P4052 = "480_1303401201.841" 
    capture_lex $P4052
    .const 'Sub' $P4044 = "479_1303401201.841" 
    capture_lex $P4044
    .const 'Sub' $P3847 = "476_1303401201.841" 
    capture_lex $P3847
    .const 'Sub' $P3839 = "475_1303401201.841" 
    capture_lex $P3839
    .const 'Sub' $P3831 = "474_1303401201.841" 
    capture_lex $P3831
    .const 'Sub' $P3823 = "473_1303401201.841" 
    capture_lex $P3823
    .const 'Sub' $P3815 = "472_1303401201.841" 
    capture_lex $P3815
    .const 'Sub' $P3807 = "471_1303401201.841" 
    capture_lex $P3807
    .const 'Sub' $P3799 = "470_1303401201.841" 
    capture_lex $P3799
    .const 'Sub' $P3688 = "468_1303401201.841" 
    capture_lex $P3688
    .const 'Sub' $P3664 = "467_1303401201.841" 
    capture_lex $P3664
    .const 'Sub' $P3650 = "466_1303401201.841" 
    capture_lex $P3650
    .const 'Sub' $P3642 = "465_1303401201.841" 
    capture_lex $P3642
    .const 'Sub' $P3634 = "464_1303401201.841" 
    capture_lex $P3634
    .const 'Sub' $P3626 = "463_1303401201.841" 
    capture_lex $P3626
    .const 'Sub' $P3618 = "462_1303401201.841" 
    capture_lex $P3618
    .const 'Sub' $P3610 = "461_1303401201.841" 
    capture_lex $P3610
    .const 'Sub' $P3602 = "460_1303401201.841" 
    capture_lex $P3602
    .const 'Sub' $P3594 = "459_1303401201.841" 
    capture_lex $P3594
    .const 'Sub' $P3586 = "458_1303401201.841" 
    capture_lex $P3586
    .const 'Sub' $P3578 = "457_1303401201.841" 
    capture_lex $P3578
    .const 'Sub' $P3570 = "456_1303401201.841" 
    capture_lex $P3570
    .const 'Sub' $P3562 = "455_1303401201.841" 
    capture_lex $P3562
    .const 'Sub' $P3554 = "454_1303401201.841" 
    capture_lex $P3554
    .const 'Sub' $P3546 = "453_1303401201.841" 
    capture_lex $P3546
    .const 'Sub' $P3530 = "452_1303401201.841" 
    capture_lex $P3530
    .const 'Sub' $P3497 = "451_1303401201.841" 
    capture_lex $P3497
    .const 'Sub' $P3483 = "450_1303401201.841" 
    capture_lex $P3483
    .const 'Sub' $P3462 = "449_1303401201.841" 
    capture_lex $P3462
    .const 'Sub' $P3442 = "448_1303401201.841" 
    capture_lex $P3442
    .const 'Sub' $P3418 = "447_1303401201.841" 
    capture_lex $P3418
    .const 'Sub' $P3384 = "446_1303401201.841" 
    capture_lex $P3384
    .const 'Sub' $P3369 = "445_1303401201.841" 
    capture_lex $P3369
    .const 'Sub' $P3357 = "444_1303401201.841" 
    capture_lex $P3357
    .const 'Sub' $P3306 = "442_1303401201.841" 
    capture_lex $P3306
    .const 'Sub' $P3295 = "441_1303401201.841" 
    capture_lex $P3295
    .const 'Sub' $P3288 = "440_1303401201.841" 
    capture_lex $P3288
    .const 'Sub' $P3265 = "439_1303401201.841" 
    capture_lex $P3265
    .const 'Sub' $P3243 = "438_1303401201.841" 
    capture_lex $P3243
    .const 'Sub' $P3232 = "437_1303401201.841" 
    capture_lex $P3232
    .const 'Sub' $P3195 = "435_1303401201.841" 
    capture_lex $P3195
    .const 'Sub' $P3187 = "434_1303401201.841" 
    capture_lex $P3187
    .const 'Sub' $P3179 = "433_1303401201.841" 
    capture_lex $P3179
    .const 'Sub' $P3165 = "432_1303401201.841" 
    capture_lex $P3165
    .const 'Sub' $P3084 = "430_1303401201.841" 
    capture_lex $P3084
    .const 'Sub' $P3043 = "428_1303401201.841" 
    capture_lex $P3043
    .const 'Sub' $P2976 = "427_1303401201.841" 
    capture_lex $P2976
    .const 'Sub' $P2945 = "426_1303401201.841" 
    capture_lex $P2945
    .const 'Sub' $P2937 = "425_1303401201.841" 
    capture_lex $P2937
    .const 'Sub' $P2894 = "423_1303401201.841" 
    capture_lex $P2894
    .const 'Sub' $P2889 = "422_1303401201.841" 
    capture_lex $P2889
    .const 'Sub' $P2884 = "421_1303401201.841" 
    capture_lex $P2884
    .const 'Sub' $P2813 = "418_1303401201.841" 
    capture_lex $P2813
    .const 'Sub' $P2801 = "417_1303401201.841" 
    capture_lex $P2801
    .const 'Sub' $P2736 = "415_1303401201.841" 
    capture_lex $P2736
    .const 'Sub' $P2724 = "414_1303401201.841" 
    capture_lex $P2724
    .const 'Sub' $P2670 = "413_1303401201.841" 
    capture_lex $P2670
    .const 'Sub' $P2657 = "412_1303401201.841" 
    capture_lex $P2657
    .const 'Sub' $P2639 = "411_1303401201.841" 
    capture_lex $P2639
    .const 'Sub' $P2606 = "408_1303401201.841" 
    capture_lex $P2606
    .const 'Sub' $P2598 = "407_1303401201.841" 
    capture_lex $P2598
.annotate 'line', 774
    .const 'Sub' $P2598 = "407_1303401201.841" 
    newclosure $P2605, $P2598
    .lex "xblock_immediate", $P2605
.annotate 'line', 779
    .const 'Sub' $P2606 = "408_1303401201.841" 
    newclosure $P2638, $P2606
    .lex "block_immediate", $P2638
.annotate 'line', 789
    .const 'Sub' $P2639 = "411_1303401201.841" 
    newclosure $P2656, $P2639
    .lex "vivitype", $P2656
.annotate 'line', 808
    .const 'Sub' $P2657 = "412_1303401201.841" 
    newclosure $P2669, $P2657
    .lex "colonpair_str", $P2669
.annotate 'line', 1056
    .const 'Sub' $P2670 = "413_1303401201.841" 
    newclosure $P2723, $P2670
    .lex "push_block_handler", $P2723
.annotate 'line', 1613
    .const 'Sub' $P2724 = "414_1303401201.841" 
    newclosure $P2735, $P2724
    .lex "only_star_block", $P2735
.annotate 'line', 1622
    .const 'Sub' $P2736 = "415_1303401201.841" 
    newclosure $P2800, $P2736
    .lex "attach_multi_signature", $P2800
.annotate 'line', 2096
    .const 'Sub' $P2801 = "417_1303401201.841" 
    newclosure $P2812, $P2801
    .lex "control", $P2812
.annotate 'line', 2115
    .const 'Sub' $P2813 = "418_1303401201.841" 
    newclosure $P2883, $P2813
    .lex "lexical_package_lookup", $P2883
.annotate 'line', 2160
    .const 'Sub' $P2884 = "421_1303401201.841" 
    newclosure $P2888, $P2884
    .lex "is_lexical", $P2888
.annotate 'line', 2166
    .const 'Sub' $P2889 = "422_1303401201.841" 
    newclosure $P2893, $P2889
    .lex "is_package", $P2893
.annotate 'line', 2172
    .const 'Sub' $P2894 = "423_1303401201.841" 
    newclosure $P2928, $P2894
    .lex "is_scope", $P2928
.annotate 'line', 770
    .lex "$?PACKAGE", $P2929
    .lex "$?CLASS", $P2930
.annotate 'line', 772
    new $P2931, "ResizablePMCArray"
    find_lex $P2932, "$?PACKAGE"
    get_who $P2933, $P2932
    set $P2933["@BLOCK"], $P2931
    find_lex $P2934, "xblock_immediate"
    find_lex $P2935, "block_immediate"
    find_lex $P2936, "vivitype"
.annotate 'line', 800
    find_lex $P2975, "colonpair_str"
.annotate 'line', 1049
    find_lex $P3482, "push_block_handler"
.annotate 'line', 1541
    find_lex $P4663, "only_star_block"
    find_lex $P4664, "attach_multi_signature"
.annotate 'line', 2087
    find_lex $P5770, "control"
.annotate 'line', 2109
    find_lex $P5794, "lexical_package_lookup"
    find_lex $P5795, "is_lexical"
    find_lex $P5796, "is_package"
    find_lex $P5797, "is_scope"
.annotate 'line', 770
    .return ($P5797)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "" :load :init :subid("post1453") :outer("406_1303401201.841")
.annotate 'line', 770
    get_hll_global $P2597, ["NQP";"Actions"], "_block2596" 
    .local pmc block
    set block, $P2597
    .const 'Sub' $P5799 = "561_1303401201.841" 
    capture_lex $P5799
    $P5799()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5798"  :anon :subid("561_1303401201.841") :outer("406_1303401201.841")
.annotate 'line', 770
    nqp_get_sc_object $P5800, "1303401190.883", 3
    .local pmc type_obj
    set type_obj, $P5800
    get_how $P5801, type_obj
    .const 'Sub' $P5802 = "425_1303401201.841" 
    $P5801."add_method"(type_obj, "TOP", $P5802)
    get_how $P5803, type_obj
    .const 'Sub' $P5804 = "426_1303401201.841" 
    $P5803."add_method"(type_obj, "deflongname", $P5804)
    get_how $P5805, type_obj
    .const 'Sub' $P5806 = "427_1303401201.841" 
    $P5805."add_method"(type_obj, "comp_unit", $P5806)
    get_how $P5807, type_obj
    .const 'Sub' $P5808 = "428_1303401201.841" 
    $P5807."add_method"(type_obj, "statementlist", $P5808)
    get_how $P5809, type_obj
    .const 'Sub' $P5810 = "430_1303401201.841" 
    $P5809."add_method"(type_obj, "statement", $P5810)
    get_how $P5811, type_obj
    .const 'Sub' $P5812 = "432_1303401201.841" 
    $P5811."add_method"(type_obj, "xblock", $P5812)
    get_how $P5813, type_obj
    .const 'Sub' $P5814 = "433_1303401201.841" 
    $P5813."add_method"(type_obj, "pblock", $P5814)
    get_how $P5815, type_obj
    .const 'Sub' $P5816 = "434_1303401201.841" 
    $P5815."add_method"(type_obj, "block", $P5816)
    get_how $P5817, type_obj
    .const 'Sub' $P5818 = "435_1303401201.841" 
    $P5817."add_method"(type_obj, "blockoid", $P5818)
    get_how $P5819, type_obj
    .const 'Sub' $P5820 = "437_1303401201.841" 
    $P5819."add_method"(type_obj, "newpad", $P5820)
    get_how $P5821, type_obj
    .const 'Sub' $P5822 = "438_1303401201.841" 
    $P5821."add_method"(type_obj, "outerctx", $P5822)
    get_how $P5823, type_obj
    .const 'Sub' $P5824 = "439_1303401201.841" 
    $P5823."add_method"(type_obj, "GLOBALish", $P5824)
    get_how $P5825, type_obj
    .const 'Sub' $P5826 = "440_1303401201.841" 
    $P5825."add_method"(type_obj, "you_are_here", $P5826)
    get_how $P5827, type_obj
    .const 'Sub' $P5828 = "441_1303401201.841" 
    $P5827."add_method"(type_obj, "statement_control:sym<use>", $P5828)
    get_how $P5829, type_obj
    .const 'Sub' $P5830 = "442_1303401201.841" 
    $P5829."add_method"(type_obj, "statement_control:sym<if>", $P5830)
    get_how $P5831, type_obj
    .const 'Sub' $P5832 = "444_1303401201.841" 
    $P5831."add_method"(type_obj, "statement_control:sym<unless>", $P5832)
    get_how $P5833, type_obj
    .const 'Sub' $P5834 = "445_1303401201.841" 
    $P5833."add_method"(type_obj, "statement_control:sym<while>", $P5834)
    get_how $P5835, type_obj
    .const 'Sub' $P5836 = "446_1303401201.841" 
    $P5835."add_method"(type_obj, "statement_control:sym<repeat>", $P5836)
    get_how $P5837, type_obj
    .const 'Sub' $P5838 = "447_1303401201.841" 
    $P5837."add_method"(type_obj, "statement_control:sym<for>", $P5838)
    get_how $P5839, type_obj
    .const 'Sub' $P5840 = "448_1303401201.841" 
    $P5839."add_method"(type_obj, "statement_control:sym<CATCH>", $P5840)
    get_how $P5841, type_obj
    .const 'Sub' $P5842 = "449_1303401201.841" 
    $P5841."add_method"(type_obj, "statement_control:sym<CONTROL>", $P5842)
    get_how $P5843, type_obj
    .const 'Sub' $P5844 = "450_1303401201.841" 
    $P5843."add_method"(type_obj, "statement_prefix:sym<INIT>", $P5844)
    get_how $P5845, type_obj
    .const 'Sub' $P5846 = "451_1303401201.841" 
    $P5845."add_method"(type_obj, "statement_prefix:sym<try>", $P5846)
    get_how $P5847, type_obj
    .const 'Sub' $P5848 = "452_1303401201.841" 
    $P5847."add_method"(type_obj, "blorst", $P5848)
    get_how $P5849, type_obj
    .const 'Sub' $P5850 = "453_1303401201.841" 
    $P5849."add_method"(type_obj, "statement_mod_cond:sym<if>", $P5850)
    get_how $P5851, type_obj
    .const 'Sub' $P5852 = "454_1303401201.841" 
    $P5851."add_method"(type_obj, "statement_mod_cond:sym<unless>", $P5852)
    get_how $P5853, type_obj
    .const 'Sub' $P5854 = "455_1303401201.841" 
    $P5853."add_method"(type_obj, "statement_mod_loop:sym<while>", $P5854)
    get_how $P5855, type_obj
    .const 'Sub' $P5856 = "456_1303401201.841" 
    $P5855."add_method"(type_obj, "statement_mod_loop:sym<until>", $P5856)
    get_how $P5857, type_obj
    .const 'Sub' $P5858 = "457_1303401201.841" 
    $P5857."add_method"(type_obj, "term:sym<fatarrow>", $P5858)
    get_how $P5859, type_obj
    .const 'Sub' $P5860 = "458_1303401201.841" 
    $P5859."add_method"(type_obj, "term:sym<colonpair>", $P5860)
    get_how $P5861, type_obj
    .const 'Sub' $P5862 = "459_1303401201.841" 
    $P5861."add_method"(type_obj, "term:sym<variable>", $P5862)
    get_how $P5863, type_obj
    .const 'Sub' $P5864 = "460_1303401201.841" 
    $P5863."add_method"(type_obj, "term:sym<package_declarator>", $P5864)
    get_how $P5865, type_obj
    .const 'Sub' $P5866 = "461_1303401201.841" 
    $P5865."add_method"(type_obj, "term:sym<scope_declarator>", $P5866)
    get_how $P5867, type_obj
    .const 'Sub' $P5868 = "462_1303401201.841" 
    $P5867."add_method"(type_obj, "term:sym<routine_declarator>", $P5868)
    get_how $P5869, type_obj
    .const 'Sub' $P5870 = "463_1303401201.841" 
    $P5869."add_method"(type_obj, "term:sym<regex_declarator>", $P5870)
    get_how $P5871, type_obj
    .const 'Sub' $P5872 = "464_1303401201.841" 
    $P5871."add_method"(type_obj, "term:sym<statement_prefix>", $P5872)
    get_how $P5873, type_obj
    .const 'Sub' $P5874 = "465_1303401201.841" 
    $P5873."add_method"(type_obj, "term:sym<lambda>", $P5874)
    get_how $P5875, type_obj
    .const 'Sub' $P5876 = "466_1303401201.841" 
    $P5875."add_method"(type_obj, "fatarrow", $P5876)
    get_how $P5877, type_obj
    .const 'Sub' $P5878 = "467_1303401201.841" 
    $P5877."add_method"(type_obj, "colonpair", $P5878)
    get_how $P5879, type_obj
    .const 'Sub' $P5880 = "468_1303401201.841" 
    $P5879."add_method"(type_obj, "variable", $P5880)
    get_how $P5881, type_obj
    .const 'Sub' $P5882 = "470_1303401201.841" 
    $P5881."add_method"(type_obj, "package_declarator:sym<module>", $P5882)
    get_how $P5883, type_obj
    .const 'Sub' $P5884 = "471_1303401201.841" 
    $P5883."add_method"(type_obj, "package_declarator:sym<knowhow>", $P5884)
    get_how $P5885, type_obj
    .const 'Sub' $P5886 = "472_1303401201.841" 
    $P5885."add_method"(type_obj, "package_declarator:sym<class>", $P5886)
    get_how $P5887, type_obj
    .const 'Sub' $P5888 = "473_1303401201.841" 
    $P5887."add_method"(type_obj, "package_declarator:sym<grammar>", $P5888)
    get_how $P5889, type_obj
    .const 'Sub' $P5890 = "474_1303401201.841" 
    $P5889."add_method"(type_obj, "package_declarator:sym<role>", $P5890)
    get_how $P5891, type_obj
    .const 'Sub' $P5892 = "475_1303401201.841" 
    $P5891."add_method"(type_obj, "package_declarator:sym<native>", $P5892)
    get_how $P5893, type_obj
    .const 'Sub' $P5894 = "476_1303401201.841" 
    $P5893."add_method"(type_obj, "package_def", $P5894)
    get_how $P5895, type_obj
    .const 'Sub' $P5896 = "479_1303401201.841" 
    $P5895."add_method"(type_obj, "scope_declarator:sym<my>", $P5896)
    get_how $P5897, type_obj
    .const 'Sub' $P5898 = "480_1303401201.841" 
    $P5897."add_method"(type_obj, "scope_declarator:sym<our>", $P5898)
    get_how $P5899, type_obj
    .const 'Sub' $P5900 = "481_1303401201.841" 
    $P5899."add_method"(type_obj, "scope_declarator:sym<has>", $P5900)
    get_how $P5901, type_obj
    .const 'Sub' $P5902 = "482_1303401201.841" 
    $P5901."add_method"(type_obj, "scoped", $P5902)
    get_how $P5903, type_obj
    .const 'Sub' $P5904 = "483_1303401201.841" 
    $P5903."add_method"(type_obj, "declarator", $P5904)
    get_how $P5905, type_obj
    .const 'Sub' $P5906 = "484_1303401201.841" 
    $P5905."add_method"(type_obj, "multi_declarator:sym<multi>", $P5906)
    get_how $P5907, type_obj
    .const 'Sub' $P5908 = "485_1303401201.841" 
    $P5907."add_method"(type_obj, "multi_declarator:sym<proto>", $P5908)
    get_how $P5909, type_obj
    .const 'Sub' $P5910 = "486_1303401201.841" 
    $P5909."add_method"(type_obj, "multi_declarator:sym<null>", $P5910)
    get_how $P5911, type_obj
    .const 'Sub' $P5912 = "487_1303401201.841" 
    $P5911."add_method"(type_obj, "variable_declarator", $P5912)
    get_how $P5913, type_obj
    .const 'Sub' $P5914 = "490_1303401201.841" 
    $P5913."add_method"(type_obj, "routine_declarator:sym<sub>", $P5914)
    get_how $P5915, type_obj
    .const 'Sub' $P5916 = "491_1303401201.841" 
    $P5915."add_method"(type_obj, "routine_declarator:sym<method>", $P5916)
    get_how $P5917, type_obj
    .const 'Sub' $P5918 = "492_1303401201.841" 
    $P5917."add_method"(type_obj, "routine_def", $P5918)
    get_how $P5919, type_obj
    .const 'Sub' $P5920 = "499_1303401201.841" 
    $P5919."add_method"(type_obj, "method_def", $P5920)
    get_how $P5921, type_obj
    .const 'Sub' $P5922 = "502_1303401201.841" 
    $P5921."add_method"(type_obj, "signature", $P5922)
    get_how $P5923, type_obj
    .const 'Sub' $P5924 = "505_1303401201.841" 
    $P5923."add_method"(type_obj, "parameter", $P5924)
    get_how $P5925, type_obj
    .const 'Sub' $P5926 = "506_1303401201.841" 
    $P5925."add_method"(type_obj, "param_var", $P5926)
    get_how $P5927, type_obj
    .const 'Sub' $P5928 = "507_1303401201.841" 
    $P5927."add_method"(type_obj, "named_param", $P5928)
    get_how $P5929, type_obj
    .const 'Sub' $P5930 = "508_1303401201.841" 
    $P5929."add_method"(type_obj, "typename", $P5930)
    get_how $P5931, type_obj
    .const 'Sub' $P5932 = "509_1303401201.841" 
    $P5931."add_method"(type_obj, "trait", $P5932)
    get_how $P5933, type_obj
    .const 'Sub' $P5934 = "510_1303401201.841" 
    $P5933."add_method"(type_obj, "trait_mod:sym<is>", $P5934)
    get_how $P5935, type_obj
    .const 'Sub' $P5936 = "512_1303401201.841" 
    $P5935."add_method"(type_obj, "regex_declarator", $P5936)
    get_how $P5937, type_obj
    .const 'Sub' $P5938 = "516_1303401201.841" 
    $P5937."add_method"(type_obj, "dotty", $P5938)
    get_how $P5939, type_obj
    .const 'Sub' $P5940 = "517_1303401201.841" 
    $P5939."add_method"(type_obj, "term:sym<self>", $P5940)
    get_how $P5941, type_obj
    .const 'Sub' $P5942 = "518_1303401201.841" 
    $P5941."add_method"(type_obj, "term:sym<identifier>", $P5942)
    get_how $P5943, type_obj
    .const 'Sub' $P5944 = "519_1303401201.841" 
    $P5943."add_method"(type_obj, "term:sym<name>", $P5944)
    get_how $P5945, type_obj
    .const 'Sub' $P5946 = "521_1303401201.841" 
    $P5945."add_method"(type_obj, "term:sym<pir::op>", $P5946)
    get_how $P5947, type_obj
    .const 'Sub' $P5948 = "522_1303401201.841" 
    $P5947."add_method"(type_obj, "term:sym<onlystar>", $P5948)
    get_how $P5949, type_obj
    .const 'Sub' $P5950 = "523_1303401201.841" 
    $P5949."add_method"(type_obj, "args", $P5950)
    get_how $P5951, type_obj
    .const 'Sub' $P5952 = "524_1303401201.841" 
    $P5951."add_method"(type_obj, "arglist", $P5952)
    get_how $P5953, type_obj
    .const 'Sub' $P5954 = "527_1303401201.841" 
    $P5953."add_method"(type_obj, "term:sym<multi_declarator>", $P5954)
    get_how $P5955, type_obj
    .const 'Sub' $P5956 = "528_1303401201.841" 
    $P5955."add_method"(type_obj, "term:sym<value>", $P5956)
    get_how $P5957, type_obj
    .const 'Sub' $P5958 = "529_1303401201.841" 
    $P5957."add_method"(type_obj, "circumfix:sym<( )>", $P5958)
    get_how $P5959, type_obj
    .const 'Sub' $P5960 = "530_1303401201.841" 
    $P5959."add_method"(type_obj, "circumfix:sym<[ ]>", $P5960)
    get_how $P5961, type_obj
    .const 'Sub' $P5962 = "531_1303401201.841" 
    $P5961."add_method"(type_obj, "circumfix:sym<ang>", $P5962)
    get_how $P5963, type_obj
    .const 'Sub' $P5964 = "532_1303401201.841" 
    $P5963."add_method"(type_obj, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P5964)
    get_how $P5965, type_obj
    .const 'Sub' $P5966 = "533_1303401201.841" 
    $P5965."add_method"(type_obj, "circumfix:sym<{ }>", $P5966)
    get_how $P5967, type_obj
    .const 'Sub' $P5968 = "535_1303401201.841" 
    $P5967."add_method"(type_obj, "circumfix:sym<sigil>", $P5968)
    get_how $P5969, type_obj
    .const 'Sub' $P5970 = "536_1303401201.841" 
    $P5969."add_method"(type_obj, "semilist", $P5970)
    get_how $P5971, type_obj
    .const 'Sub' $P5972 = "537_1303401201.841" 
    $P5971."add_method"(type_obj, "postcircumfix:sym<[ ]>", $P5972)
    get_how $P5973, type_obj
    .const 'Sub' $P5974 = "538_1303401201.841" 
    $P5973."add_method"(type_obj, "postcircumfix:sym<{ }>", $P5974)
    get_how $P5975, type_obj
    .const 'Sub' $P5976 = "539_1303401201.841" 
    $P5975."add_method"(type_obj, "postcircumfix:sym<ang>", $P5976)
    get_how $P5977, type_obj
    .const 'Sub' $P5978 = "540_1303401201.841" 
    $P5977."add_method"(type_obj, "postcircumfix:sym<( )>", $P5978)
    get_how $P5979, type_obj
    .const 'Sub' $P5980 = "541_1303401201.841" 
    $P5979."add_method"(type_obj, "value", $P5980)
    get_how $P5981, type_obj
    .const 'Sub' $P5982 = "542_1303401201.841" 
    $P5981."add_method"(type_obj, "number", $P5982)
    get_how $P5983, type_obj
    .const 'Sub' $P5984 = "543_1303401201.841" 
    $P5983."add_method"(type_obj, "quote:sym<apos>", $P5984)
    get_how $P5985, type_obj
    .const 'Sub' $P5986 = "544_1303401201.841" 
    $P5985."add_method"(type_obj, "quote:sym<dblq>", $P5986)
    get_how $P5987, type_obj
    .const 'Sub' $P5988 = "545_1303401201.841" 
    $P5987."add_method"(type_obj, "quote:sym<qq>", $P5988)
    get_how $P5989, type_obj
    .const 'Sub' $P5990 = "546_1303401201.841" 
    $P5989."add_method"(type_obj, "quote:sym<q>", $P5990)
    get_how $P5991, type_obj
    .const 'Sub' $P5992 = "547_1303401201.841" 
    $P5991."add_method"(type_obj, "quote:sym<Q>", $P5992)
    get_how $P5993, type_obj
    .const 'Sub' $P5994 = "548_1303401201.841" 
    $P5993."add_method"(type_obj, "quote:sym<Q:PIR>", $P5994)
    get_how $P5995, type_obj
    .const 'Sub' $P5996 = "549_1303401201.841" 
    $P5995."add_method"(type_obj, "quote:sym</ />", $P5996)
    get_how $P5997, type_obj
    .const 'Sub' $P5998 = "550_1303401201.841" 
    $P5997."add_method"(type_obj, "quote_escape:sym<$>", $P5998)
    get_how $P5999, type_obj
    .const 'Sub' $P6000 = "551_1303401201.841" 
    $P5999."add_method"(type_obj, "quote_escape:sym<{ }>", $P6000)
    get_how $P6001, type_obj
    .const 'Sub' $P6002 = "552_1303401201.841" 
    $P6001."add_method"(type_obj, "quote_escape:sym<esc>", $P6002)
    get_how $P6003, type_obj
    .const 'Sub' $P6004 = "553_1303401201.841" 
    $P6003."add_method"(type_obj, "postfix:sym<.>", $P6004)
    get_how $P6005, type_obj
    .const 'Sub' $P6006 = "554_1303401201.841" 
    $P6005."add_method"(type_obj, "postfix:sym<++>", $P6006)
    get_how $P6007, type_obj
    .const 'Sub' $P6008 = "555_1303401201.841" 
    $P6007."add_method"(type_obj, "postfix:sym<-->", $P6008)
    get_how $P6009, type_obj
    .const 'Sub' $P6010 = "556_1303401201.841" 
    $P6009."add_method"(type_obj, "prefix:sym<make>", $P6010)
    get_how $P6011, type_obj
    .const 'Sub' $P6012 = "557_1303401201.841" 
    $P6011."add_method"(type_obj, "term:sym<next>", $P6012)
    get_how $P6013, type_obj
    .const 'Sub' $P6014 = "558_1303401201.841" 
    $P6013."add_method"(type_obj, "term:sym<last>", $P6014)
    get_how $P6015, type_obj
    .const 'Sub' $P6016 = "559_1303401201.841" 
    $P6015."add_method"(type_obj, "term:sym<redo>", $P6016)
    get_how $P6017, type_obj
    .const 'Sub' $P6018 = "560_1303401201.841" 
    $P6017."add_method"(type_obj, "infix:sym<~~>", $P6018)
    get_how $P6019, type_obj
    get_hll_global $P6020, ["HLL"], "Actions"
    $P6019."add_parent"(type_obj, $P6020)
    get_how $P6021, type_obj
    $P6022 = $P6021."compose"(type_obj)
    .return ($P6022)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock_immediate"  :subid("407_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_2599
.annotate 'line', 774
    .lex "$xblock", param_2599
.annotate 'line', 775
    find_lex $P2600, "$xblock"
    unless_null $P2600, vivify_1454
    $P2600 = root_new ['parrot';'ResizablePMCArray']
  vivify_1454:
    set $P2601, $P2600[1]
    unless_null $P2601, vivify_1455
    new $P2601, "Undef"
  vivify_1455:
    $P2602 = "block_immediate"($P2601)
    find_lex $P2603, "$xblock"
    unless_null $P2603, vivify_1456
    $P2603 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$xblock", $P2603
  vivify_1456:
    set $P2603[1], $P2602
    find_lex $P2604, "$xblock"
    unless_null $P2604, vivify_1457
    new $P2604, "Undef"
  vivify_1457:
.annotate 'line', 774
    .return ($P2604)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block_immediate"  :subid("408_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_2607
.annotate 'line', 779
    .const 'Sub' $P2617 = "409_1303401201.841" 
    capture_lex $P2617
    .lex "$block", param_2607
.annotate 'line', 780
    find_lex $P2608, "$block"
    unless_null $P2608, vivify_1458
    new $P2608, "Undef"
  vivify_1458:
    $P2608."blocktype"("immediate")
.annotate 'line', 781
    find_lex $P2612, "$block"
    unless_null $P2612, vivify_1459
    new $P2612, "Undef"
  vivify_1459:
    $P2613 = $P2612."symtable"()
    unless $P2613, unless_2611
    set $P2610, $P2613
    goto unless_2611_end
  unless_2611:
    find_lex $P2614, "$block"
    unless_null $P2614, vivify_1460
    new $P2614, "Undef"
  vivify_1460:
    $P2615 = $P2614."handlers"()
    set $P2610, $P2615
  unless_2611_end:
    if $P2610, unless_2609_end
    .const 'Sub' $P2617 = "409_1303401201.841" 
    capture_lex $P2617
    $P2617()
  unless_2609_end:
    find_lex $P2637, "$block"
    unless_null $P2637, vivify_1467
    new $P2637, "Undef"
  vivify_1467:
.annotate 'line', 779
    .return ($P2637)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2616"  :anon :subid("409_1303401201.841") :outer("408_1303401201.841")
.annotate 'line', 781
    .const 'Sub' $P2628 = "410_1303401201.841" 
    capture_lex $P2628
.annotate 'line', 782
    new $P2618, "Undef"
    .lex "$stmts", $P2618
    get_hll_global $P2619, ["PAST"], "Stmts"
    find_lex $P2620, "$block"
    unless_null $P2620, vivify_1461
    new $P2620, "Undef"
  vivify_1461:
    $P2621 = $P2619."new"($P2620 :named("node"))
    store_lex "$stmts", $P2621
.annotate 'line', 783
    find_lex $P2623, "$block"
    unless_null $P2623, vivify_1462
    new $P2623, "Undef"
  vivify_1462:
    $P2624 = $P2623."list"()
    defined $I2625, $P2624
    unless $I2625, for_undef_1463
    iter $P2622, $P2624
    new $P2634, 'ExceptionHandler'
    set_label $P2634, loop2633_handler
    $P2634."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2634
  loop2633_test:
    unless $P2622, loop2633_done
    shift $P2626, $P2622
  loop2633_redo:
    .const 'Sub' $P2628 = "410_1303401201.841" 
    capture_lex $P2628
    $P2628($P2626)
  loop2633_next:
    goto loop2633_test
  loop2633_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2635, exception, 'type'
    eq $P2635, .CONTROL_LOOP_NEXT, loop2633_next
    eq $P2635, .CONTROL_LOOP_REDO, loop2633_redo
  loop2633_done:
    pop_eh 
  for_undef_1463:
.annotate 'line', 784
    find_lex $P2636, "$stmts"
    unless_null $P2636, vivify_1466
    new $P2636, "Undef"
  vivify_1466:
    store_lex "$block", $P2636
.annotate 'line', 781
    .return ($P2636)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2627"  :anon :subid("410_1303401201.841") :outer("409_1303401201.841")
    .param pmc param_2629
.annotate 'line', 783
    .lex "$_", param_2629
    find_lex $P2630, "$stmts"
    unless_null $P2630, vivify_1464
    new $P2630, "Undef"
  vivify_1464:
    find_lex $P2631, "$_"
    unless_null $P2631, vivify_1465
    new $P2631, "Undef"
  vivify_1465:
    $P2632 = $P2630."push"($P2631)
    .return ($P2632)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "vivitype"  :subid("411_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_2640
.annotate 'line', 789
    .lex "$sigil", param_2640
.annotate 'line', 790
    find_lex $P2643, "$sigil"
    unless_null $P2643, vivify_1468
    new $P2643, "Undef"
  vivify_1468:
    set $S2644, $P2643
    iseq $I2645, $S2644, "%"
    if $I2645, if_2642
.annotate 'line', 792
    find_lex $P2650, "$sigil"
    unless_null $P2650, vivify_1469
    new $P2650, "Undef"
  vivify_1469:
    set $S2651, $P2650
    iseq $I2652, $S2651, "@"
    if $I2652, if_2649
    new $P2655, "String"
    assign $P2655, "Undef"
    set $P2648, $P2655
    goto if_2649_end
  if_2649:
.annotate 'line', 793
    get_hll_global $P2653, ["PAST"], "Op"
    $P2654 = $P2653."new"("    %r = root_new ['parrot';'ResizablePMCArray']" :named("inline"))
    set $P2648, $P2654
  if_2649_end:
    set $P2641, $P2648
.annotate 'line', 790
    goto if_2642_end
  if_2642:
.annotate 'line', 791
    get_hll_global $P2646, ["PAST"], "Op"
    $P2647 = $P2646."new"("    %r = root_new ['parrot';'Hash']" :named("inline"))
    set $P2641, $P2647
  if_2642_end:
.annotate 'line', 789
    .return ($P2641)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair_str"  :subid("412_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_2658
.annotate 'line', 808
    .lex "$ast", param_2658
.annotate 'line', 809
    get_hll_global $P2661, ["PAST"], "Op"
    find_lex $P2662, "$ast"
    unless_null $P2662, vivify_1470
    new $P2662, "Undef"
  vivify_1470:
    $P2663 = $P2661."ACCEPTS"($P2662)
    if $P2663, if_2660
.annotate 'line', 811
    find_lex $P2667, "$ast"
    unless_null $P2667, vivify_1471
    new $P2667, "Undef"
  vivify_1471:
    $P2668 = $P2667."value"()
    set $P2659, $P2668
.annotate 'line', 809
    goto if_2660_end
  if_2660:
.annotate 'line', 810
    find_lex $P2664, "$ast"
    unless_null $P2664, vivify_1472
    new $P2664, "Undef"
  vivify_1472:
    $P2665 = $P2664."list"()
    join $S2666, " ", $P2665
    new $P2659, 'String'
    set $P2659, $S2666
  if_2660_end:
.annotate 'line', 808
    .return ($P2659)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "push_block_handler"  :subid("413_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_2671
    .param pmc param_2672
.annotate 'line', 1056
    .lex "$/", param_2671
    .lex "$block", param_2672
.annotate 'line', 1057
    find_lex $P2674, "$?PACKAGE"
    get_who $P2675, $P2674
    set $P2676, $P2675["@BLOCK"]
    unless_null $P2676, vivify_1473
    $P2676 = root_new ['parrot';'ResizablePMCArray']
  vivify_1473:
    set $P2677, $P2676[0]
    unless_null $P2677, vivify_1474
    new $P2677, "Undef"
  vivify_1474:
    $P2678 = $P2677."handlers"()
    if $P2678, unless_2673_end
.annotate 'line', 1058
    find_lex $P2679, "$?PACKAGE"
    get_who $P2680, $P2679
    set $P2681, $P2680["@BLOCK"]
    unless_null $P2681, vivify_1475
    $P2681 = root_new ['parrot';'ResizablePMCArray']
  vivify_1475:
    set $P2682, $P2681[0]
    unless_null $P2682, vivify_1476
    new $P2682, "Undef"
  vivify_1476:
    new $P2683, "ResizablePMCArray"
    $P2682."handlers"($P2683)
  unless_2673_end:
.annotate 'line', 1060
    find_lex $P2685, "$block"
    unless_null $P2685, vivify_1477
    new $P2685, "Undef"
  vivify_1477:
    $P2686 = $P2685."arity"()
    if $P2686, unless_2684_end
.annotate 'line', 1061
    find_lex $P2687, "$block"
    unless_null $P2687, vivify_1478
    new $P2687, "Undef"
  vivify_1478:
.annotate 'line', 1062
    get_hll_global $P2688, ["PAST"], "Op"
.annotate 'line', 1063
    get_hll_global $P2689, ["PAST"], "Var"
    $P2690 = $P2689."new"("lexical" :named("scope"), "$!" :named("name"), 1 :named("isdecl"))
.annotate 'line', 1064
    get_hll_global $P2691, ["PAST"], "Var"
    $P2692 = $P2691."new"("lexical" :named("scope"), "$_" :named("name"))
    $P2693 = $P2688."new"($P2690, $P2692, "bind" :named("pasttype"))
.annotate 'line', 1062
    $P2687."unshift"($P2693)
.annotate 'line', 1067
    find_lex $P2694, "$block"
    unless_null $P2694, vivify_1479
    new $P2694, "Undef"
  vivify_1479:
    get_hll_global $P2695, ["PAST"], "Var"
    $P2696 = $P2695."new"("$_" :named("name"), "parameter" :named("scope"))
    $P2694."unshift"($P2696)
.annotate 'line', 1068
    find_lex $P2697, "$block"
    unless_null $P2697, vivify_1480
    new $P2697, "Undef"
  vivify_1480:
    $P2697."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 1069
    find_lex $P2698, "$block"
    unless_null $P2698, vivify_1481
    new $P2698, "Undef"
  vivify_1481:
    $P2698."symbol"("$!", "lexical" :named("scope"))
.annotate 'line', 1070
    find_lex $P2699, "$block"
    unless_null $P2699, vivify_1482
    new $P2699, "Undef"
  vivify_1482:
    $P2699."arity"(1)
  unless_2684_end:
.annotate 'line', 1072
    find_lex $P2700, "$block"
    unless_null $P2700, vivify_1483
    new $P2700, "Undef"
  vivify_1483:
    $P2700."blocktype"("declaration")
.annotate 'line', 1073
    find_lex $P2701, "$?PACKAGE"
    get_who $P2702, $P2701
    set $P2703, $P2702["@BLOCK"]
    unless_null $P2703, vivify_1484
    $P2703 = root_new ['parrot';'ResizablePMCArray']
  vivify_1484:
    set $P2704, $P2703[0]
    unless_null $P2704, vivify_1485
    new $P2704, "Undef"
  vivify_1485:
    $P2705 = $P2704."handlers"()
.annotate 'line', 1074
    get_hll_global $P2706, ["PAST"], "Control"
    find_lex $P2707, "$/"
    unless_null $P2707, vivify_1486
    new $P2707, "Undef"
  vivify_1486:
.annotate 'line', 1076
    get_hll_global $P2708, ["PAST"], "Stmts"
.annotate 'line', 1077
    get_hll_global $P2709, ["PAST"], "Op"
    find_lex $P2710, "$block"
    unless_null $P2710, vivify_1487
    new $P2710, "Undef"
  vivify_1487:
.annotate 'line', 1079
    get_hll_global $P2711, ["PAST"], "Var"
    $P2712 = $P2711."new"("register" :named("scope"), "exception" :named("name"))
    $P2713 = $P2709."new"($P2710, $P2712, "call" :named("pasttype"))
.annotate 'line', 1081
    get_hll_global $P2714, ["PAST"], "Op"
.annotate 'line', 1082
    get_hll_global $P2715, ["PAST"], "Var"
.annotate 'line', 1083
    get_hll_global $P2716, ["PAST"], "Var"
    $P2717 = $P2716."new"("register" :named("scope"), "exception" :named("name"))
    $P2718 = $P2715."new"($P2717, "handled", "keyed" :named("scope"))
.annotate 'line', 1082
    $P2719 = $P2714."new"($P2718, 1, "bind" :named("pasttype"))
.annotate 'line', 1081
    $P2720 = $P2708."new"($P2713, $P2719)
.annotate 'line', 1076
    $P2721 = $P2706."new"($P2720, $P2707 :named("node"))
.annotate 'line', 1074
    $P2722 = $P2705."unshift"($P2721)
.annotate 'line', 1056
    .return ($P2722)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "only_star_block"  :subid("414_1303401201.841") :outer("406_1303401201.841")
.annotate 'line', 1614
    new $P2725, "Undef"
    .lex "$past", $P2725
    find_lex $P2726, "$?PACKAGE"
    get_who $P2727, $P2726
    set $P2728, $P2727["@BLOCK"]
    unless_null $P2728, vivify_1488
    $P2728 = root_new ['parrot';'ResizablePMCArray']
  vivify_1488:
    $P2729 = $P2728."shift"()
    store_lex "$past", $P2729
.annotate 'line', 1615
    find_lex $P2730, "$past"
    unless_null $P2730, vivify_1489
    new $P2730, "Undef"
  vivify_1489:
    $P2730."closure"(1)
.annotate 'line', 1616
    find_lex $P2731, "$past"
    unless_null $P2731, vivify_1490
    new $P2731, "Undef"
  vivify_1490:
    get_hll_global $P2732, ["PAST"], "Op"
    $P2733 = $P2732."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P2731."push"($P2733)
    find_lex $P2734, "$past"
    unless_null $P2734, vivify_1491
    new $P2734, "Undef"
  vivify_1491:
.annotate 'line', 1613
    .return ($P2734)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "attach_multi_signature"  :subid("415_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_2737
.annotate 'line', 1622
    .const 'Sub' $P2751 = "416_1303401201.841" 
    capture_lex $P2751
    .lex "$routine", param_2737
.annotate 'line', 1626
    new $P2738, "Undef"
    .lex "$types", $P2738
.annotate 'line', 1627
    new $P2739, "Undef"
    .lex "$definednesses", $P2739
.annotate 'line', 1626
    get_hll_global $P2740, ["PAST"], "Op"
    $P2741 = $P2740."new"("list" :named("pasttype"))
    store_lex "$types", $P2741
.annotate 'line', 1627
    get_hll_global $P2742, ["PAST"], "Op"
    $P2743 = $P2742."new"("list" :named("pasttype"))
    store_lex "$definednesses", $P2743
.annotate 'line', 1628
    find_lex $P2745, "$routine"
    unless_null $P2745, vivify_1492
    $P2745 = root_new ['parrot';'ResizablePMCArray']
  vivify_1492:
    set $P2746, $P2745[0]
    unless_null $P2746, vivify_1493
    new $P2746, "Undef"
  vivify_1493:
    $P2747 = $P2746."list"()
    defined $I2748, $P2747
    unless $I2748, for_undef_1494
    iter $P2744, $P2747
    new $P2789, 'ExceptionHandler'
    set_label $P2789, loop2788_handler
    $P2789."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2789
  loop2788_test:
    unless $P2744, loop2788_done
    shift $P2749, $P2744
  loop2788_redo:
    .const 'Sub' $P2751 = "416_1303401201.841" 
    capture_lex $P2751
    $P2751($P2749)
  loop2788_next:
    goto loop2788_test
  loop2788_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2790, exception, 'type'
    eq $P2790, .CONTROL_LOOP_NEXT, loop2788_next
    eq $P2790, .CONTROL_LOOP_REDO, loop2788_redo
  loop2788_done:
    pop_eh 
  for_undef_1494:
.annotate 'line', 1635
    find_lex $P2791, "$routine"
    unless_null $P2791, vivify_1504
    new $P2791, "Undef"
  vivify_1504:
    $P2792 = $P2791."loadinit"()
    get_hll_global $P2793, ["PAST"], "Op"
.annotate 'line', 1636
    get_hll_global $P2794, ["PAST"], "Var"
    $P2795 = $P2794."new"("block" :named("name"), "register" :named("scope"))
    find_lex $P2796, "$types"
    unless_null $P2796, vivify_1505
    new $P2796, "Undef"
  vivify_1505:
    find_lex $P2797, "$definednesses"
    unless_null $P2797, vivify_1506
    new $P2797, "Undef"
  vivify_1506:
    $P2798 = $P2793."new"($P2795, $P2796, $P2797, "set_sub_multisig vPPP" :named("pirop"))
.annotate 'line', 1635
    $P2799 = $P2792."push"($P2798)
.annotate 'line', 1622
    .return ($P2799)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2750"  :anon :subid("416_1303401201.841") :outer("415_1303401201.841")
    .param pmc param_2752
.annotate 'line', 1628
    .lex "$_", param_2752
.annotate 'line', 1629
    get_hll_global $P2757, ["PAST"], "Var"
    find_lex $P2758, "$_"
    unless_null $P2758, vivify_1495
    new $P2758, "Undef"
  vivify_1495:
    $P2759 = $P2757."ACCEPTS"($P2758)
    if $P2759, if_2756
    set $P2755, $P2759
    goto if_2756_end
  if_2756:
    find_lex $P2760, "$_"
    unless_null $P2760, vivify_1496
    new $P2760, "Undef"
  vivify_1496:
    $S2761 = $P2760."scope"()
    iseq $I2762, $S2761, "parameter"
    new $P2755, 'Integer'
    set $P2755, $I2762
  if_2756_end:
    if $P2755, if_2754
    set $P2753, $P2755
    goto if_2754_end
  if_2754:
.annotate 'line', 1630
    find_lex $P2763, "$types"
    unless_null $P2763, vivify_1497
    new $P2763, "Undef"
  vivify_1497:
    find_lex $P2765, "$_"
    unless_null $P2765, vivify_1498
    new $P2765, "Undef"
  vivify_1498:
    $P2766 = $P2765."multitype"()
    set $P2764, $P2766
    defined $I2768, $P2764
    if $I2768, default_2767
    get_hll_global $P2769, ["PAST"], "Op"
    $P2770 = $P2769."new"("null P" :named("pirop"))
    set $P2764, $P2770
  default_2767:
    $P2763."push"($P2764)
.annotate 'line', 1631
    find_lex $P2771, "$definednesses"
    unless_null $P2771, vivify_1499
    new $P2771, "Undef"
  vivify_1499:
    find_lex $P2774, "$_"
    unless_null $P2774, vivify_1500
    $P2774 = root_new ['parrot';'Hash']
  vivify_1500:
    set $P2775, $P2774["definedness"]
    unless_null $P2775, vivify_1501
    new $P2775, "Undef"
  vivify_1501:
    set $S2776, $P2775
    iseq $I2777, $S2776, "D"
    if $I2777, if_2773
.annotate 'line', 1632
    find_lex $P2781, "$_"
    unless_null $P2781, vivify_1502
    $P2781 = root_new ['parrot';'Hash']
  vivify_1502:
    set $P2782, $P2781["definedness"]
    unless_null $P2782, vivify_1503
    new $P2782, "Undef"
  vivify_1503:
    set $S2783, $P2782
    iseq $I2784, $S2783, "U"
    if $I2784, if_2780
    new $P2786, "Integer"
    assign $P2786, 0
    set $P2779, $P2786
    goto if_2780_end
  if_2780:
    new $P2785, "Integer"
    assign $P2785, 2
    set $P2779, $P2785
  if_2780_end:
    set $P2772, $P2779
.annotate 'line', 1631
    goto if_2773_end
  if_2773:
    new $P2778, "Integer"
    assign $P2778, 1
    set $P2772, $P2778
  if_2773_end:
    $P2787 = $P2771."push"($P2772)
.annotate 'line', 1629
    set $P2753, $P2787
  if_2754_end:
.annotate 'line', 1628
    .return ($P2753)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "control"  :subid("417_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_2802
    .param pmc param_2803
.annotate 'line', 2096
    .lex "$/", param_2802
    .lex "$type", param_2803
.annotate 'line', 2097
    find_lex $P2804, "$/"
    get_hll_global $P2805, ["PAST"], "Op"
    find_lex $P2806, "$/"
    unless_null $P2806, vivify_1507
    new $P2806, "Undef"
  vivify_1507:
.annotate 'line', 2101
    get_hll_global $P2807, ["PAST"], "Val"
    find_lex $P2808, "$type"
    unless_null $P2808, vivify_1508
    new $P2808, "Undef"
  vivify_1508:
    $P2809 = $P2807."new"($P2808 :named("value"), "!except_types" :named("returns"))
    $P2810 = $P2805."new"(0, $P2809, $P2806 :named("node"), "die__vii" :named("pirop"))
.annotate 'line', 2097
    $P2811 = $P2804."!make"($P2810)
.annotate 'line', 2096
    .return ($P2811)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "lexical_package_lookup"  :subid("418_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_2816
    .param pmc param_2817
.annotate 'line', 2115
    .const 'Sub' $P2846 = "419_1303401201.841" 
    capture_lex $P2846
    new $P2815, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2815, control_2814
    push_eh $P2815
    .lex "@name", param_2816
    .lex "$/", param_2817
.annotate 'line', 2121
    new $P2818, "Undef"
    .lex "$final_name", $P2818
.annotate 'line', 2122
    new $P2819, "Undef"
    .lex "$lookup", $P2819
.annotate 'line', 2117
    find_lex $P2821, "@name"
    unless_null $P2821, vivify_1509
    $P2821 = root_new ['parrot';'ResizablePMCArray']
  vivify_1509:
    set $N2822, $P2821
    iseq $I2823, $N2822, 0.0
    unless $I2823, if_2820_end
    find_lex $P2824, "$/"
    unless_null $P2824, vivify_1510
    new $P2824, "Undef"
  vivify_1510:
    $P2825 = $P2824."CURSOR"()
    $P2825."panic"("Cannot compile empty name")
  if_2820_end:
.annotate 'line', 2121
    find_lex $P2826, "@name"
    unless_null $P2826, vivify_1511
    $P2826 = root_new ['parrot';'ResizablePMCArray']
  vivify_1511:
    $P2827 = $P2826."pop"()
    store_lex "$final_name", $P2827
.annotate 'line', 2122
    get_hll_global $P2828, ["PAST"], "Var"
    find_lex $P2829, "$final_name"
    unless_null $P2829, vivify_1512
    new $P2829, "Undef"
  vivify_1512:
    set $S2830, $P2829
    $P2831 = $P2828."new"($S2830, "keyed" :named("scope"))
    store_lex "$lookup", $P2831
.annotate 'line', 2126
    find_lex $P2833, "@name"
    unless_null $P2833, vivify_1513
    $P2833 = root_new ['parrot';'ResizablePMCArray']
  vivify_1513:
    set $N2834, $P2833
    iseq $I2835, $N2834, 0.0
    if $I2835, if_2832
.annotate 'line', 2135
    find_lex $P2842, "@name"
    unless_null $P2842, vivify_1514
    $P2842 = root_new ['parrot';'ResizablePMCArray']
  vivify_1514:
    set $P2843, $P2842[0]
    unless_null $P2843, vivify_1515
    new $P2843, "Undef"
  vivify_1515:
    $P2844 = "is_lexical"($P2843)
    if $P2844, if_2841
.annotate 'line', 2149
    find_lex $P2872, "$lookup"
    unless_null $P2872, vivify_1516
    new $P2872, "Undef"
  vivify_1516:
    get_hll_global $P2873, ["PAST"], "Op"
.annotate 'line', 2151
    get_hll_global $P2874, ["PAST"], "Var"
    find_lex $P2875, "@name"
    unless_null $P2875, vivify_1517
    $P2875 = root_new ['parrot';'ResizablePMCArray']
  vivify_1517:
    $P2876 = $P2875."pop"()
    find_lex $P2877, "@name"
    unless_null $P2877, vivify_1518
    $P2877 = root_new ['parrot';'ResizablePMCArray']
  vivify_1518:
    $P2878 = $P2874."new"($P2876 :named("name"), $P2877 :named("namespace"), "package" :named("scope"))
    $P2879 = $P2873."new"($P2878, "get_who PP" :named("pirop"))
.annotate 'line', 2149
    $P2872."unshift"($P2879)
.annotate 'line', 2144
    goto if_2841_end
  if_2841:
.annotate 'line', 2135
    .const 'Sub' $P2846 = "419_1303401201.841" 
    capture_lex $P2846
    $P2846()
  if_2841_end:
    goto if_2832_end
  if_2832:
.annotate 'line', 2127
    find_lex $P2836, "$lookup"
    unless_null $P2836, vivify_1526
    new $P2836, "Undef"
  vivify_1526:
    get_hll_global $P2837, ["PAST"], "Op"
.annotate 'line', 2129
    get_hll_global $P2838, ["PAST"], "Var"
    $P2839 = $P2838."new"("$?PACKAGE" :named("name"), "lexical" :named("scope"))
    $P2840 = $P2837."new"($P2839, "get_who PP" :named("pirop"))
.annotate 'line', 2127
    $P2836."unshift"($P2840)
  if_2832_end:
.annotate 'line', 2155
    new $P2880, "Exception"
    set $P2880['type'], .CONTROL_RETURN
    find_lex $P2881, "$lookup"
    unless_null $P2881, vivify_1527
    new $P2881, "Undef"
  vivify_1527:
    setattribute $P2880, 'payload', $P2881
    throw $P2880
.annotate 'line', 2115
    .return ()
  control_2814:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2882, exception, "payload"
    .return ($P2882)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2845"  :anon :subid("419_1303401201.841") :outer("418_1303401201.841")
.annotate 'line', 2135
    .const 'Sub' $P2857 = "420_1303401201.841" 
    capture_lex $P2857
.annotate 'line', 2136
    new $P2847, "Undef"
    .lex "$path", $P2847
    get_hll_global $P2848, ["PAST"], "Var"
    find_lex $P2849, "@name"
    unless_null $P2849, vivify_1519
    $P2849 = root_new ['parrot';'ResizablePMCArray']
  vivify_1519:
    $P2850 = $P2849."shift"()
    $P2851 = $P2848."new"($P2850 :named("name"), "lexical" :named("scope"))
    store_lex "$path", $P2851
.annotate 'line', 2137
    find_lex $P2853, "@name"
    unless_null $P2853, vivify_1520
    $P2853 = root_new ['parrot';'ResizablePMCArray']
  vivify_1520:
    defined $I2854, $P2853
    unless $I2854, for_undef_1521
    iter $P2852, $P2853
    new $P2865, 'ExceptionHandler'
    set_label $P2865, loop2864_handler
    $P2865."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2865
  loop2864_test:
    unless $P2852, loop2864_done
    shift $P2855, $P2852
  loop2864_redo:
    .const 'Sub' $P2857 = "420_1303401201.841" 
    capture_lex $P2857
    $P2857($P2855)
  loop2864_next:
    goto loop2864_test
  loop2864_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2866, exception, 'type'
    eq $P2866, .CONTROL_LOOP_NEXT, loop2864_next
    eq $P2866, .CONTROL_LOOP_REDO, loop2864_redo
  loop2864_done:
    pop_eh 
  for_undef_1521:
.annotate 'line', 2142
    find_lex $P2867, "$lookup"
    unless_null $P2867, vivify_1524
    new $P2867, "Undef"
  vivify_1524:
    get_hll_global $P2868, ["PAST"], "Op"
    find_lex $P2869, "$path"
    unless_null $P2869, vivify_1525
    new $P2869, "Undef"
  vivify_1525:
    $P2870 = $P2868."new"($P2869, "get_who PP" :named("pirop"))
    $P2871 = $P2867."unshift"($P2870)
.annotate 'line', 2135
    .return ($P2871)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2856"  :anon :subid("420_1303401201.841") :outer("419_1303401201.841")
    .param pmc param_2858
.annotate 'line', 2137
    .lex "$_", param_2858
.annotate 'line', 2138
    get_hll_global $P2859, ["PAST"], "Op"
    find_lex $P2860, "$path"
    unless_null $P2860, vivify_1522
    new $P2860, "Undef"
  vivify_1522:
.annotate 'line', 2140
    find_lex $P2861, "$_"
    unless_null $P2861, vivify_1523
    new $P2861, "Undef"
  vivify_1523:
    set $S2862, $P2861
    $P2863 = $P2859."new"($P2860, $S2862, "nqp_get_package_through_who PPs" :named("pirop"))
.annotate 'line', 2138
    store_lex "$path", $P2863
.annotate 'line', 2137
    .return ($P2863)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "is_lexical"  :subid("421_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_2885
.annotate 'line', 2160
    .lex "$name", param_2885
.annotate 'line', 2161
    find_lex $P2886, "$name"
    unless_null $P2886, vivify_1528
    new $P2886, "Undef"
  vivify_1528:
    $P2887 = "is_scope"($P2886, "lexical")
.annotate 'line', 2160
    .return ($P2887)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "is_package"  :subid("422_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_2890
.annotate 'line', 2166
    .lex "$name", param_2890
.annotate 'line', 2167
    find_lex $P2891, "$name"
    unless_null $P2891, vivify_1529
    new $P2891, "Undef"
  vivify_1529:
    $P2892 = "is_scope"($P2891, "package")
.annotate 'line', 2166
    .return ($P2892)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "is_scope"  :subid("423_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_2897
    .param pmc param_2898
.annotate 'line', 2172
    .const 'Sub' $P2906 = "424_1303401201.841" 
    capture_lex $P2906
    new $P2896, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2896, control_2895
    push_eh $P2896
    .lex "$name", param_2897
    .lex "$wanted_scope", param_2898
.annotate 'line', 2173
    find_lex $P2900, "$?PACKAGE"
    get_who $P2901, $P2900
    set $P2902, $P2901["@BLOCK"]
    unless_null $P2902, vivify_1530
    $P2902 = root_new ['parrot';'ResizablePMCArray']
  vivify_1530:
    defined $I2903, $P2902
    unless $I2903, for_undef_1531
    iter $P2899, $P2902
    new $P2925, 'ExceptionHandler'
    set_label $P2925, loop2924_handler
    $P2925."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2925
  loop2924_test:
    unless $P2899, loop2924_done
    shift $P2904, $P2899
  loop2924_redo:
    .const 'Sub' $P2906 = "424_1303401201.841" 
    capture_lex $P2906
    $P2906($P2904)
  loop2924_next:
    goto loop2924_test
  loop2924_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2926, exception, 'type'
    eq $P2926, .CONTROL_LOOP_NEXT, loop2924_next
    eq $P2926, .CONTROL_LOOP_REDO, loop2924_redo
  loop2924_done:
    pop_eh 
  for_undef_1531:
.annotate 'line', 2172
    .return (0)
  control_2895:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2927, exception, "payload"
    .return ($P2927)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2905"  :anon :subid("424_1303401201.841") :outer("423_1303401201.841")
    .param pmc param_2908
.annotate 'line', 2174
    $P2907 = root_new ['parrot';'Hash']
    .lex "%sym", $P2907
    .lex "$_", param_2908
    find_lex $P2909, "$_"
    unless_null $P2909, vivify_1532
    new $P2909, "Undef"
  vivify_1532:
    find_lex $P2910, "$name"
    unless_null $P2910, vivify_1533
    new $P2910, "Undef"
  vivify_1533:
    $P2911 = $P2909."symbol"($P2910)
    store_lex "%sym", $P2911
.annotate 'line', 2175
    find_lex $P2914, "%sym"
    unless_null $P2914, vivify_1534
    $P2914 = root_new ['parrot';'Hash']
  vivify_1534:
    set $N2915, $P2914
    if $N2915, if_2913
    new $P2912, 'Float'
    set $P2912, $N2915
    goto if_2913_end
  if_2913:
.annotate 'line', 2176
    new $P2916, "Exception"
    set $P2916['type'], .CONTROL_RETURN
    find_lex $P2917, "%sym"
    unless_null $P2917, vivify_1535
    $P2917 = root_new ['parrot';'Hash']
  vivify_1535:
    set $P2918, $P2917["scope"]
    unless_null $P2918, vivify_1536
    new $P2918, "Undef"
  vivify_1536:
    set $S2919, $P2918
    find_lex $P2920, "$wanted_scope"
    unless_null $P2920, vivify_1537
    new $P2920, "Undef"
  vivify_1537:
    set $S2921, $P2920
    iseq $I2922, $S2919, $S2921
    new $P2923, 'Integer'
    set $P2923, $I2922
    setattribute $P2916, 'payload', $P2923
    throw $P2916
  if_2913_end:
.annotate 'line', 2173
    .return ($P2912)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "TOP"  :subid("425_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_2938
    .param pmc param_2939
.annotate 'line', 798
    .lex "self", param_2938
    .lex "$/", param_2939
    find_lex $P2940, "$/"
    find_lex $P2941, "$/"
    unless_null $P2941, vivify_1538
    $P2941 = root_new ['parrot';'Hash']
  vivify_1538:
    set $P2942, $P2941["comp_unit"]
    unless_null $P2942, vivify_1539
    new $P2942, "Undef"
  vivify_1539:
    $P2943 = $P2942."ast"()
    $P2944 = $P2940."!make"($P2943)
    .return ($P2944)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "deflongname"  :subid("426_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_2946
    .param pmc param_2947
.annotate 'line', 800
    .lex "self", param_2946
    .lex "$/", param_2947
.annotate 'line', 801
    find_lex $P2948, "$/"
.annotate 'line', 802
    find_lex $P2951, "$/"
    unless_null $P2951, vivify_1540
    $P2951 = root_new ['parrot';'Hash']
  vivify_1540:
    set $P2952, $P2951["colonpair"]
    unless_null $P2952, vivify_1541
    new $P2952, "Undef"
  vivify_1541:
    if $P2952, if_2950
.annotate 'line', 804
    find_lex $P2972, "$/"
    unless_null $P2972, vivify_1542
    new $P2972, "Undef"
  vivify_1542:
    set $S2973, $P2972
    new $P2949, 'String'
    set $P2949, $S2973
.annotate 'line', 802
    goto if_2950_end
  if_2950:
    find_lex $P2953, "$/"
    unless_null $P2953, vivify_1543
    $P2953 = root_new ['parrot';'Hash']
  vivify_1543:
    set $P2954, $P2953["identifier"]
    unless_null $P2954, vivify_1544
    new $P2954, "Undef"
  vivify_1544:
    set $S2955, $P2954
    new $P2956, 'String'
    set $P2956, $S2955
    concat $P2957, $P2956, ":"
    find_lex $P2958, "$/"
    unless_null $P2958, vivify_1545
    $P2958 = root_new ['parrot';'Hash']
  vivify_1545:
    set $P2959, $P2958["colonpair"]
    unless_null $P2959, vivify_1546
    $P2959 = root_new ['parrot';'ResizablePMCArray']
  vivify_1546:
    set $P2960, $P2959[0]
    unless_null $P2960, vivify_1547
    new $P2960, "Undef"
  vivify_1547:
    $P2961 = $P2960."ast"()
    $S2962 = $P2961."named"()
    concat $P2963, $P2957, $S2962
    concat $P2964, $P2963, "<"
.annotate 'line', 803
    find_lex $P2965, "$/"
    unless_null $P2965, vivify_1548
    $P2965 = root_new ['parrot';'Hash']
  vivify_1548:
    set $P2966, $P2965["colonpair"]
    unless_null $P2966, vivify_1549
    $P2966 = root_new ['parrot';'ResizablePMCArray']
  vivify_1549:
    set $P2967, $P2966[0]
    unless_null $P2967, vivify_1550
    new $P2967, "Undef"
  vivify_1550:
    $P2968 = $P2967."ast"()
    $S2969 = "colonpair_str"($P2968)
    concat $P2970, $P2964, $S2969
    concat $P2971, $P2970, ">"
    set $P2949, $P2971
  if_2950_end:
.annotate 'line', 802
    $P2974 = $P2948."!make"($P2949)
.annotate 'line', 800
    .return ($P2974)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "comp_unit"  :subid("427_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_2977
    .param pmc param_2978
.annotate 'line', 814
    .lex "self", param_2977
    .lex "$/", param_2978
.annotate 'line', 815
    new $P2979, "Undef"
    .lex "$mainline", $P2979
.annotate 'line', 816
    new $P2980, "Undef"
    .lex "$unit", $P2980
.annotate 'line', 815
    find_lex $P2981, "$/"
    unless_null $P2981, vivify_1551
    $P2981 = root_new ['parrot';'Hash']
  vivify_1551:
    set $P2982, $P2981["statementlist"]
    unless_null $P2982, vivify_1552
    new $P2982, "Undef"
  vivify_1552:
    $P2983 = $P2982."ast"()
    store_lex "$mainline", $P2983
.annotate 'line', 816
    find_lex $P2984, "$?PACKAGE"
    get_who $P2985, $P2984
    set $P2986, $P2985["@BLOCK"]
    unless_null $P2986, vivify_1553
    $P2986 = root_new ['parrot';'ResizablePMCArray']
  vivify_1553:
    $P2987 = $P2986."shift"()
    store_lex "$unit", $P2987
.annotate 'line', 820
    find_lex $P2988, "$unit"
    unless_null $P2988, vivify_1554
    new $P2988, "Undef"
  vivify_1554:
    $P2989 = $P2988."loadinit"()
    find_dynamic_lex $P2990, "$*SC"
    unless_null $P2990, vivify_1555
    get_hll_global $P2990, "$SC"
    unless_null $P2990, vivify_1556
    die "Contextual $*SC not found"
  vivify_1556:
  vivify_1555:
    $P2991 = $P2990."to_past"()
    $P2989."push"($P2991)
.annotate 'line', 826
    find_lex $P2992, "$unit"
    unless_null $P2992, vivify_1557
    new $P2992, "Undef"
  vivify_1557:
    $P2993 = $P2992."loadinit"()
    get_hll_global $P2994, ["PAST"], "Op"
.annotate 'line', 828
    get_hll_global $P2995, ["PAST"], "Var"
    new $P2996, "ResizablePMCArray"
    $P2997 = $P2995."new"("GLOBAL" :named("name"), $P2996 :named("namespace"), "package" :named("scope"))
.annotate 'line', 829
    find_dynamic_lex $P2998, "$*SC"
    unless_null $P2998, vivify_1558
    get_hll_global $P2998, "$SC"
    unless_null $P2998, vivify_1559
    die "Contextual $*SC not found"
  vivify_1559:
  vivify_1558:
    find_dynamic_lex $P2999, "$*PACKAGE"
    unless_null $P2999, vivify_1560
    get_hll_global $P2999, "$PACKAGE"
    unless_null $P2999, vivify_1561
    die "Contextual $*PACKAGE not found"
  vivify_1561:
  vivify_1560:
    $P3000 = $P2998."get_slot_past_for_object"($P2999)
    $P3001 = $P2994."new"($P2997, $P3000, "bind" :named("pasttype"))
.annotate 'line', 826
    $P2993."push"($P3001)
.annotate 'line', 835
    find_dynamic_lex $P3003, "$*HAS_YOU_ARE_HERE"
    unless_null $P3003, vivify_1562
    get_hll_global $P3003, "$HAS_YOU_ARE_HERE"
    unless_null $P3003, vivify_1563
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_1563:
  vivify_1562:
    if $P3003, unless_3002_end
.annotate 'line', 836
    find_lex $P3004, "$unit"
    unless_null $P3004, vivify_1564
    new $P3004, "Undef"
  vivify_1564:
    find_lex $P3005, "self"
    $P3006 = $P3005."CTXSAVE"()
    $P3004."push"($P3006)
  unless_3002_end:
.annotate 'line', 840
    find_lex $P3007, "$unit"
    unless_null $P3007, vivify_1565
    new $P3007, "Undef"
  vivify_1565:
    $P3007."loadlibs"("nqp_group", "nqp_ops")
.annotate 'line', 844
    find_dynamic_lex $P3009, "$*MAIN_SUB"
    unless_null $P3009, vivify_1566
    get_hll_global $P3009, "$MAIN_SUB"
    unless_null $P3009, vivify_1567
    die "Contextual $*MAIN_SUB not found"
  vivify_1567:
  vivify_1566:
    unless $P3009, if_3008_end
.annotate 'line', 845
    find_lex $P3010, "$unit"
    unless_null $P3010, vivify_1568
    new $P3010, "Undef"
  vivify_1568:
    get_hll_global $P3011, ["PAST"], "Var"
    $P3012 = $P3011."new"("parameter" :named("scope"), "@ARGS" :named("name"), 1 :named("slurpy"))
    $P3010."unshift"($P3012)
.annotate 'line', 846
    find_lex $P3013, "$mainline"
    unless_null $P3013, vivify_1569
    new $P3013, "Undef"
  vivify_1569:
    get_hll_global $P3014, ["PAST"], "Op"
.annotate 'line', 848
    get_hll_global $P3015, ["PAST"], "Var"
    $P3016 = $P3015."new"("lexical" :named("scope"), "@ARGS" :named("name"))
.annotate 'line', 849
    get_hll_global $P3017, ["PAST"], "Op"
.annotate 'line', 850
    get_hll_global $P3018, ["PAST"], "Val"
    find_dynamic_lex $P3019, "$*MAIN_SUB"
    unless_null $P3019, vivify_1570
    get_hll_global $P3019, "$MAIN_SUB"
    unless_null $P3019, vivify_1571
    die "Contextual $*MAIN_SUB not found"
  vivify_1571:
  vivify_1570:
    $P3020 = $P3018."new"($P3019 :named("value"))
.annotate 'line', 851
    get_hll_global $P3021, ["PAST"], "Var"
    $P3022 = $P3021."new"("lexical" :named("scope"), "@ARGS" :named("name"), 1 :named("flat"))
    $P3023 = $P3017."new"($P3020, $P3022, "call" :named("pasttype"))
.annotate 'line', 849
    $P3024 = $P3014."new"($P3016, $P3023, "if" :named("pasttype"))
.annotate 'line', 846
    $P3013."push"($P3024)
  if_3008_end:
.annotate 'line', 859
    find_lex $P3025, "$unit"
    unless_null $P3025, vivify_1572
    new $P3025, "Undef"
  vivify_1572:
.annotate 'line', 860
    get_hll_global $P3026, ["PAST"], "Op"
    find_lex $P3027, "$mainline"
    unless_null $P3027, vivify_1573
    new $P3027, "Undef"
  vivify_1573:
    $P3028 = $P3026."new"($P3027, "return" :named("pirop"))
    $P3025."push"($P3028)
.annotate 'line', 865
    find_lex $P3029, "$unit"
    unless_null $P3029, vivify_1574
    new $P3029, "Undef"
  vivify_1574:
.annotate 'line', 866
    get_hll_global $P3030, ["PAST"], "Block"
.annotate 'line', 868
    get_hll_global $P3031, ["PAST"], "Op"
    get_hll_global $P3032, ["PAST"], "Val"
    find_lex $P3033, "$unit"
    unless_null $P3033, vivify_1575
    new $P3033, "Undef"
  vivify_1575:
    $P3034 = $P3032."new"($P3033 :named("value"))
    $P3035 = $P3031."new"($P3034, "call" :named("pasttype"))
    $P3036 = $P3030."new"($P3035, ":load" :named("pirflags"), 0 :named("lexical"), "" :named("namespace"))
.annotate 'line', 866
    $P3029."push"($P3036)
.annotate 'line', 871
    find_lex $P3037, "$unit"
    unless_null $P3037, vivify_1576
    new $P3037, "Undef"
  vivify_1576:
    find_lex $P3038, "$/"
    unless_null $P3038, vivify_1577
    new $P3038, "Undef"
  vivify_1577:
    $P3037."node"($P3038)
.annotate 'line', 874
    find_lex $P3039, "$unit"
    unless_null $P3039, vivify_1578
    new $P3039, "Undef"
  vivify_1578:
    $P3039."hll"("nqp")
.annotate 'line', 876
    find_lex $P3040, "$/"
    find_lex $P3041, "$unit"
    unless_null $P3041, vivify_1579
    new $P3041, "Undef"
  vivify_1579:
    $P3042 = $P3040."!make"($P3041)
.annotate 'line', 814
    .return ($P3042)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statementlist"  :subid("428_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_3044
    .param pmc param_3045
.annotate 'line', 879
    .const 'Sub' $P3059 = "429_1303401201.841" 
    capture_lex $P3059
    .lex "self", param_3044
    .lex "$/", param_3045
.annotate 'line', 880
    new $P3046, "Undef"
    .lex "$past", $P3046
    get_hll_global $P3047, ["PAST"], "Stmts"
    find_lex $P3048, "$/"
    unless_null $P3048, vivify_1580
    new $P3048, "Undef"
  vivify_1580:
    $P3049 = $P3047."new"($P3048 :named("node"))
    store_lex "$past", $P3049
.annotate 'line', 881
    find_lex $P3051, "$/"
    unless_null $P3051, vivify_1581
    $P3051 = root_new ['parrot';'Hash']
  vivify_1581:
    set $P3052, $P3051["statement"]
    unless_null $P3052, vivify_1582
    new $P3052, "Undef"
  vivify_1582:
    unless $P3052, if_3050_end
.annotate 'line', 882
    find_lex $P3054, "$/"
    unless_null $P3054, vivify_1583
    $P3054 = root_new ['parrot';'Hash']
  vivify_1583:
    set $P3055, $P3054["statement"]
    unless_null $P3055, vivify_1584
    new $P3055, "Undef"
  vivify_1584:
    defined $I3056, $P3055
    unless $I3056, for_undef_1585
    iter $P3053, $P3055
    new $P3079, 'ExceptionHandler'
    set_label $P3079, loop3078_handler
    $P3079."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3079
  loop3078_test:
    unless $P3053, loop3078_done
    shift $P3057, $P3053
  loop3078_redo:
    .const 'Sub' $P3059 = "429_1303401201.841" 
    capture_lex $P3059
    $P3059($P3057)
  loop3078_next:
    goto loop3078_test
  loop3078_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3080, exception, 'type'
    eq $P3080, .CONTROL_LOOP_NEXT, loop3078_next
    eq $P3080, .CONTROL_LOOP_REDO, loop3078_redo
  loop3078_done:
    pop_eh 
  for_undef_1585:
  if_3050_end:
.annotate 'line', 889
    find_lex $P3081, "$/"
    find_lex $P3082, "$past"
    unless_null $P3082, vivify_1596
    new $P3082, "Undef"
  vivify_1596:
    $P3083 = $P3081."!make"($P3082)
.annotate 'line', 879
    .return ($P3083)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3058"  :anon :subid("429_1303401201.841") :outer("428_1303401201.841")
    .param pmc param_3061
.annotate 'line', 883
    new $P3060, "Undef"
    .lex "$ast", $P3060
    .lex "$_", param_3061
    find_lex $P3062, "$_"
    unless_null $P3062, vivify_1586
    new $P3062, "Undef"
  vivify_1586:
    $P3063 = $P3062."ast"()
    store_lex "$ast", $P3063
.annotate 'line', 884
    find_lex $P3065, "$ast"
    unless_null $P3065, vivify_1587
    $P3065 = root_new ['parrot';'Hash']
  vivify_1587:
    set $P3066, $P3065["sink"]
    unless_null $P3066, vivify_1588
    new $P3066, "Undef"
  vivify_1588:
    defined $I3067, $P3066
    unless $I3067, if_3064_end
    find_lex $P3068, "$ast"
    unless_null $P3068, vivify_1589
    $P3068 = root_new ['parrot';'Hash']
  vivify_1589:
    set $P3069, $P3068["sink"]
    unless_null $P3069, vivify_1590
    new $P3069, "Undef"
  vivify_1590:
    store_lex "$ast", $P3069
  if_3064_end:
.annotate 'line', 885
    find_lex $P3071, "$ast"
    unless_null $P3071, vivify_1591
    $P3071 = root_new ['parrot';'Hash']
  vivify_1591:
    set $P3072, $P3071["bareblock"]
    unless_null $P3072, vivify_1592
    new $P3072, "Undef"
  vivify_1592:
    unless $P3072, if_3070_end
    find_lex $P3073, "$ast"
    unless_null $P3073, vivify_1593
    new $P3073, "Undef"
  vivify_1593:
    $P3074 = "block_immediate"($P3073)
    store_lex "$ast", $P3074
  if_3070_end:
.annotate 'line', 886
    find_lex $P3075, "$past"
    unless_null $P3075, vivify_1594
    new $P3075, "Undef"
  vivify_1594:
    find_lex $P3076, "$ast"
    unless_null $P3076, vivify_1595
    new $P3076, "Undef"
  vivify_1595:
    $P3077 = $P3075."push"($P3076)
.annotate 'line', 882
    .return ($P3077)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement"  :subid("430_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_3085
    .param pmc param_3086
    .param pmc param_3087 :optional
    .param int has_param_3087 :opt_flag
.annotate 'line', 892
    .const 'Sub' $P3095 = "431_1303401201.841" 
    capture_lex $P3095
    .lex "self", param_3085
    .lex "$/", param_3086
    if has_param_3087, optparam_1597
    new $P3088, "Undef"
    set param_3087, $P3088
  optparam_1597:
    .lex "$key", param_3087
.annotate 'line', 893
    new $P3089, "Undef"
    .lex "$past", $P3089
.annotate 'line', 892
    find_lex $P3090, "$past"
    unless_null $P3090, vivify_1598
    new $P3090, "Undef"
  vivify_1598:
.annotate 'line', 894
    find_lex $P3092, "$/"
    unless_null $P3092, vivify_1599
    $P3092 = root_new ['parrot';'Hash']
  vivify_1599:
    set $P3093, $P3092["EXPR"]
    unless_null $P3093, vivify_1600
    new $P3093, "Undef"
  vivify_1600:
    if $P3093, if_3091
.annotate 'line', 915
    find_lex $P3156, "$/"
    unless_null $P3156, vivify_1601
    $P3156 = root_new ['parrot';'Hash']
  vivify_1601:
    set $P3157, $P3156["statement_control"]
    unless_null $P3157, vivify_1602
    new $P3157, "Undef"
  vivify_1602:
    if $P3157, if_3155
.annotate 'line', 916
    new $P3161, "Integer"
    assign $P3161, 0
    store_lex "$past", $P3161
    goto if_3155_end
  if_3155:
.annotate 'line', 915
    find_lex $P3158, "$/"
    unless_null $P3158, vivify_1603
    $P3158 = root_new ['parrot';'Hash']
  vivify_1603:
    set $P3159, $P3158["statement_control"]
    unless_null $P3159, vivify_1604
    new $P3159, "Undef"
  vivify_1604:
    $P3160 = $P3159."ast"()
    store_lex "$past", $P3160
  if_3155_end:
    goto if_3091_end
  if_3091:
.annotate 'line', 894
    .const 'Sub' $P3095 = "431_1303401201.841" 
    capture_lex $P3095
    $P3095()
  if_3091_end:
.annotate 'line', 917
    find_lex $P3162, "$/"
    find_lex $P3163, "$past"
    unless_null $P3163, vivify_1638
    new $P3163, "Undef"
  vivify_1638:
    $P3164 = $P3162."!make"($P3163)
.annotate 'line', 892
    .return ($P3164)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3094"  :anon :subid("431_1303401201.841") :outer("430_1303401201.841")
.annotate 'line', 895
    new $P3096, "Undef"
    .lex "$mc", $P3096
.annotate 'line', 896
    new $P3097, "Undef"
    .lex "$ml", $P3097
.annotate 'line', 895
    find_lex $P3098, "$/"
    unless_null $P3098, vivify_1605
    $P3098 = root_new ['parrot';'Hash']
  vivify_1605:
    set $P3099, $P3098["statement_mod_cond"]
    unless_null $P3099, vivify_1606
    $P3099 = root_new ['parrot';'ResizablePMCArray']
  vivify_1606:
    set $P3100, $P3099[0]
    unless_null $P3100, vivify_1607
    new $P3100, "Undef"
  vivify_1607:
    store_lex "$mc", $P3100
.annotate 'line', 896
    find_lex $P3101, "$/"
    unless_null $P3101, vivify_1608
    $P3101 = root_new ['parrot';'Hash']
  vivify_1608:
    set $P3102, $P3101["statement_mod_loop"]
    unless_null $P3102, vivify_1609
    $P3102 = root_new ['parrot';'ResizablePMCArray']
  vivify_1609:
    set $P3103, $P3102[0]
    unless_null $P3103, vivify_1610
    new $P3103, "Undef"
  vivify_1610:
    store_lex "$ml", $P3103
.annotate 'line', 897
    find_lex $P3104, "$/"
    unless_null $P3104, vivify_1611
    $P3104 = root_new ['parrot';'Hash']
  vivify_1611:
    set $P3105, $P3104["EXPR"]
    unless_null $P3105, vivify_1612
    new $P3105, "Undef"
  vivify_1612:
    $P3106 = $P3105."ast"()
    store_lex "$past", $P3106
.annotate 'line', 898
    find_lex $P3108, "$mc"
    unless_null $P3108, vivify_1613
    new $P3108, "Undef"
  vivify_1613:
    unless $P3108, if_3107_end
.annotate 'line', 899
    get_hll_global $P3109, ["PAST"], "Op"
    find_lex $P3110, "$mc"
    unless_null $P3110, vivify_1614
    $P3110 = root_new ['parrot';'Hash']
  vivify_1614:
    set $P3111, $P3110["cond"]
    unless_null $P3111, vivify_1615
    new $P3111, "Undef"
  vivify_1615:
    $P3112 = $P3111."ast"()
    find_lex $P3113, "$past"
    unless_null $P3113, vivify_1616
    new $P3113, "Undef"
  vivify_1616:
    find_lex $P3114, "$mc"
    unless_null $P3114, vivify_1617
    $P3114 = root_new ['parrot';'Hash']
  vivify_1617:
    set $P3115, $P3114["sym"]
    unless_null $P3115, vivify_1618
    new $P3115, "Undef"
  vivify_1618:
    set $S3116, $P3115
    find_lex $P3117, "$/"
    unless_null $P3117, vivify_1619
    new $P3117, "Undef"
  vivify_1619:
    $P3118 = $P3109."new"($P3112, $P3113, $S3116 :named("pasttype"), $P3117 :named("node"))
    store_lex "$past", $P3118
  if_3107_end:
.annotate 'line', 901
    find_lex $P3121, "$ml"
    unless_null $P3121, vivify_1620
    new $P3121, "Undef"
  vivify_1620:
    if $P3121, if_3120
    set $P3119, $P3121
    goto if_3120_end
  if_3120:
.annotate 'line', 902
    find_lex $P3124, "$ml"
    unless_null $P3124, vivify_1621
    $P3124 = root_new ['parrot';'Hash']
  vivify_1621:
    set $P3125, $P3124["sym"]
    unless_null $P3125, vivify_1622
    new $P3125, "Undef"
  vivify_1622:
    set $S3126, $P3125
    iseq $I3127, $S3126, "for"
    if $I3127, if_3123
.annotate 'line', 911
    get_hll_global $P3145, ["PAST"], "Op"
    find_lex $P3146, "$ml"
    unless_null $P3146, vivify_1623
    $P3146 = root_new ['parrot';'Hash']
  vivify_1623:
    set $P3147, $P3146["cond"]
    unless_null $P3147, vivify_1624
    new $P3147, "Undef"
  vivify_1624:
    $P3148 = $P3147."ast"()
    find_lex $P3149, "$past"
    unless_null $P3149, vivify_1625
    new $P3149, "Undef"
  vivify_1625:
    find_lex $P3150, "$ml"
    unless_null $P3150, vivify_1626
    $P3150 = root_new ['parrot';'Hash']
  vivify_1626:
    set $P3151, $P3150["sym"]
    unless_null $P3151, vivify_1627
    new $P3151, "Undef"
  vivify_1627:
    set $S3152, $P3151
    find_lex $P3153, "$/"
    unless_null $P3153, vivify_1628
    new $P3153, "Undef"
  vivify_1628:
    $P3154 = $P3145."new"($P3148, $P3149, $S3152 :named("pasttype"), $P3153 :named("node"))
    store_lex "$past", $P3154
.annotate 'line', 910
    set $P3122, $P3154
.annotate 'line', 902
    goto if_3123_end
  if_3123:
.annotate 'line', 903
    get_hll_global $P3128, ["PAST"], "Block"
.annotate 'line', 904
    get_hll_global $P3129, ["PAST"], "Var"
    $P3130 = $P3129."new"("$_" :named("name"), "parameter" :named("scope"), 1 :named("isdecl"))
    find_lex $P3131, "$past"
    unless_null $P3131, vivify_1629
    new $P3131, "Undef"
  vivify_1629:
    $P3132 = $P3128."new"($P3130, $P3131, "immediate" :named("blocktype"))
.annotate 'line', 903
    store_lex "$past", $P3132
.annotate 'line', 906
    find_lex $P3133, "$past"
    unless_null $P3133, vivify_1630
    new $P3133, "Undef"
  vivify_1630:
    $P3133."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 907
    find_lex $P3134, "$past"
    unless_null $P3134, vivify_1631
    new $P3134, "Undef"
  vivify_1631:
    $P3134."arity"(1)
.annotate 'line', 908
    get_hll_global $P3135, ["PAST"], "Op"
    find_lex $P3136, "$ml"
    unless_null $P3136, vivify_1632
    $P3136 = root_new ['parrot';'Hash']
  vivify_1632:
    set $P3137, $P3136["cond"]
    unless_null $P3137, vivify_1633
    new $P3137, "Undef"
  vivify_1633:
    $P3138 = $P3137."ast"()
    find_lex $P3139, "$past"
    unless_null $P3139, vivify_1634
    new $P3139, "Undef"
  vivify_1634:
    find_lex $P3140, "$ml"
    unless_null $P3140, vivify_1635
    $P3140 = root_new ['parrot';'Hash']
  vivify_1635:
    set $P3141, $P3140["sym"]
    unless_null $P3141, vivify_1636
    new $P3141, "Undef"
  vivify_1636:
    set $S3142, $P3141
    find_lex $P3143, "$/"
    unless_null $P3143, vivify_1637
    new $P3143, "Undef"
  vivify_1637:
    $P3144 = $P3135."new"($P3138, $P3139, $S3142 :named("pasttype"), $P3143 :named("node"))
    store_lex "$past", $P3144
.annotate 'line', 902
    set $P3122, $P3144
  if_3123_end:
.annotate 'line', 901
    set $P3119, $P3122
  if_3120_end:
.annotate 'line', 894
    .return ($P3119)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock"  :subid("432_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_3166
    .param pmc param_3167
.annotate 'line', 920
    .lex "self", param_3166
    .lex "$/", param_3167
.annotate 'line', 921
    find_lex $P3168, "$/"
    get_hll_global $P3169, ["PAST"], "Op"
    find_lex $P3170, "$/"
    unless_null $P3170, vivify_1639
    $P3170 = root_new ['parrot';'Hash']
  vivify_1639:
    set $P3171, $P3170["EXPR"]
    unless_null $P3171, vivify_1640
    new $P3171, "Undef"
  vivify_1640:
    $P3172 = $P3171."ast"()
    find_lex $P3173, "$/"
    unless_null $P3173, vivify_1641
    $P3173 = root_new ['parrot';'Hash']
  vivify_1641:
    set $P3174, $P3173["pblock"]
    unless_null $P3174, vivify_1642
    new $P3174, "Undef"
  vivify_1642:
    $P3175 = $P3174."ast"()
    find_lex $P3176, "$/"
    unless_null $P3176, vivify_1643
    new $P3176, "Undef"
  vivify_1643:
    $P3177 = $P3169."new"($P3172, $P3175, "if" :named("pasttype"), $P3176 :named("node"))
    $P3178 = $P3168."!make"($P3177)
.annotate 'line', 920
    .return ($P3178)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "pblock"  :subid("433_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_3180
    .param pmc param_3181
.annotate 'line', 924
    .lex "self", param_3180
    .lex "$/", param_3181
.annotate 'line', 925
    find_lex $P3182, "$/"
    find_lex $P3183, "$/"
    unless_null $P3183, vivify_1644
    $P3183 = root_new ['parrot';'Hash']
  vivify_1644:
    set $P3184, $P3183["blockoid"]
    unless_null $P3184, vivify_1645
    new $P3184, "Undef"
  vivify_1645:
    $P3185 = $P3184."ast"()
    $P3186 = $P3182."!make"($P3185)
.annotate 'line', 924
    .return ($P3186)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block"  :subid("434_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_3188
    .param pmc param_3189
.annotate 'line', 928
    .lex "self", param_3188
    .lex "$/", param_3189
.annotate 'line', 929
    find_lex $P3190, "$/"
    find_lex $P3191, "$/"
    unless_null $P3191, vivify_1646
    $P3191 = root_new ['parrot';'Hash']
  vivify_1646:
    set $P3192, $P3191["blockoid"]
    unless_null $P3192, vivify_1647
    new $P3192, "Undef"
  vivify_1647:
    $P3193 = $P3192."ast"()
    $P3194 = $P3190."!make"($P3193)
.annotate 'line', 928
    .return ($P3194)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blockoid"  :subid("435_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_3196
    .param pmc param_3197
.annotate 'line', 932
    .const 'Sub' $P3208 = "436_1303401201.841" 
    capture_lex $P3208
    .lex "self", param_3196
    .lex "$/", param_3197
.annotate 'line', 933
    new $P3198, "Undef"
    .lex "$BLOCK", $P3198
    find_lex $P3199, "$?PACKAGE"
    get_who $P3200, $P3199
    set $P3201, $P3200["@BLOCK"]
    unless_null $P3201, vivify_1648
    $P3201 = root_new ['parrot';'ResizablePMCArray']
  vivify_1648:
    $P3202 = $P3201."shift"()
    store_lex "$BLOCK", $P3202
.annotate 'line', 934
    find_lex $P3205, "$/"
    unless_null $P3205, vivify_1649
    $P3205 = root_new ['parrot';'Hash']
  vivify_1649:
    set $P3206, $P3205["statementlist"]
    unless_null $P3206, vivify_1650
    new $P3206, "Undef"
  vivify_1650:
    if $P3206, if_3204
.annotate 'line', 942
    find_dynamic_lex $P3223, "$*HAS_YOU_ARE_HERE"
    unless_null $P3223, vivify_1651
    get_hll_global $P3223, "$HAS_YOU_ARE_HERE"
    unless_null $P3223, vivify_1652
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_1652:
  vivify_1651:
    unless $P3223, if_3222_end
.annotate 'line', 943
    find_lex $P3224, "$/"
    unless_null $P3224, vivify_1653
    new $P3224, "Undef"
  vivify_1653:
    $P3225 = $P3224."CURSOR"()
    $P3225."panic"("{YOU_ARE_HERE} may only appear once in a setting")
  if_3222_end:
.annotate 'line', 945
    new $P3226, "Integer"
    assign $P3226, 1
    store_dynamic_lex "$*HAS_YOU_ARE_HERE", $P3226
.annotate 'line', 946
    find_lex $P3227, "$/"
    find_lex $P3228, "$/"
    unless_null $P3228, vivify_1654
    $P3228 = root_new ['parrot';'Hash']
  vivify_1654:
    set $P3229, $P3228["you_are_here"]
    unless_null $P3229, vivify_1655
    new $P3229, "Undef"
  vivify_1655:
    $P3230 = $P3229."ast"()
    $P3231 = $P3227."!make"($P3230)
.annotate 'line', 941
    set $P3203, $P3231
.annotate 'line', 934
    goto if_3204_end
  if_3204:
    .const 'Sub' $P3208 = "436_1303401201.841" 
    capture_lex $P3208
    $P3221 = $P3208()
    set $P3203, $P3221
  if_3204_end:
.annotate 'line', 932
    .return ($P3203)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3207"  :anon :subid("436_1303401201.841") :outer("435_1303401201.841")
.annotate 'line', 935
    new $P3209, "Undef"
    .lex "$past", $P3209
    find_lex $P3210, "$/"
    unless_null $P3210, vivify_1656
    $P3210 = root_new ['parrot';'Hash']
  vivify_1656:
    set $P3211, $P3210["statementlist"]
    unless_null $P3211, vivify_1657
    new $P3211, "Undef"
  vivify_1657:
    $P3212 = $P3211."ast"()
    store_lex "$past", $P3212
.annotate 'line', 936
    find_lex $P3213, "$BLOCK"
    unless_null $P3213, vivify_1658
    new $P3213, "Undef"
  vivify_1658:
    find_lex $P3214, "$past"
    unless_null $P3214, vivify_1659
    new $P3214, "Undef"
  vivify_1659:
    $P3213."push"($P3214)
.annotate 'line', 937
    find_lex $P3215, "$BLOCK"
    unless_null $P3215, vivify_1660
    new $P3215, "Undef"
  vivify_1660:
    find_lex $P3216, "$/"
    unless_null $P3216, vivify_1661
    new $P3216, "Undef"
  vivify_1661:
    $P3215."node"($P3216)
.annotate 'line', 938
    find_lex $P3217, "$BLOCK"
    unless_null $P3217, vivify_1662
    new $P3217, "Undef"
  vivify_1662:
    $P3217."closure"(1)
.annotate 'line', 939
    find_dynamic_lex $P3218, "$/"
    find_lex $P3219, "$BLOCK"
    unless_null $P3219, vivify_1663
    new $P3219, "Undef"
  vivify_1663:
    $P3220 = $P3218."!make"($P3219)
.annotate 'line', 934
    .return ($P3220)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "newpad"  :subid("437_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_3233
    .param pmc param_3234
.annotate 'line', 950
    .lex "self", param_3233
    .lex "$/", param_3234
.annotate 'line', 951
    find_lex $P3235, "$?PACKAGE"
    get_who $P3236, $P3235
    set $P3237, $P3236["@BLOCK"]
    unless_null $P3237, vivify_1664
    $P3237 = root_new ['parrot';'ResizablePMCArray']
  vivify_1664:
    get_hll_global $P3238, ["PAST"], "Block"
    get_hll_global $P3239, ["PAST"], "Stmts"
    $P3240 = $P3239."new"()
    $P3241 = $P3238."new"($P3240)
    $P3242 = $P3237."unshift"($P3241)
.annotate 'line', 950
    .return ($P3242)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "outerctx"  :subid("438_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_3244
    .param pmc param_3245
.annotate 'line', 954
    .lex "self", param_3244
    .lex "$/", param_3245
.annotate 'line', 955
    find_dynamic_lex $P3247, "%*COMPILING"
    unless_null $P3247, vivify_1665
    get_hll_global $P3247, "%COMPILING"
    unless_null $P3247, vivify_1666
    die "Contextual %*COMPILING not found"
  vivify_1666:
  vivify_1665:
    set $P3248, $P3247["%?OPTIONS"]
    unless_null $P3248, vivify_1667
    $P3248 = root_new ['parrot';'Hash']
  vivify_1667:
    set $P3249, $P3248["outer_ctx"]
    unless_null $P3249, vivify_1668
    new $P3249, "Undef"
  vivify_1668:
    defined $I3250, $P3249
    if $I3250, unless_3246_end
.annotate 'line', 958
    find_dynamic_lex $P3251, "$*SC"
    unless_null $P3251, vivify_1669
    get_hll_global $P3251, "$SC"
    unless_null $P3251, vivify_1670
    die "Contextual $*SC not found"
  vivify_1670:
  vivify_1669:
    find_dynamic_lex $P3253, "%*COMPILING"
    unless_null $P3253, vivify_1671
    get_hll_global $P3253, "%COMPILING"
    unless_null $P3253, vivify_1672
    die "Contextual %*COMPILING not found"
  vivify_1672:
  vivify_1671:
    set $P3254, $P3253["%?OPTIONS"]
    unless_null $P3254, vivify_1673
    $P3254 = root_new ['parrot';'Hash']
  vivify_1673:
    set $P3255, $P3254["setting"]
    unless_null $P3255, vivify_1674
    new $P3255, "Undef"
  vivify_1674:
    set $P3252, $P3255
    defined $I3257, $P3252
    if $I3257, default_3256
    new $P3258, "String"
    assign $P3258, "NQPCORE"
    set $P3252, $P3258
  default_3256:
    $P3251."load_setting"($P3252)
  unless_3246_end:
.annotate 'line', 960
    find_lex $P3259, "self"
    find_lex $P3260, "$?PACKAGE"
    get_who $P3261, $P3260
    set $P3262, $P3261["@BLOCK"]
    unless_null $P3262, vivify_1675
    $P3262 = root_new ['parrot';'ResizablePMCArray']
  vivify_1675:
    set $P3263, $P3262[0]
    unless_null $P3263, vivify_1676
    new $P3263, "Undef"
  vivify_1676:
    $P3264 = $P3259."SET_BLOCK_OUTER_CTX"($P3263)
.annotate 'line', 954
    .return ($P3264)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "GLOBALish"  :subid("439_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_3266
    .param pmc param_3267
.annotate 'line', 963
    .lex "self", param_3266
    .lex "$/", param_3267
.annotate 'line', 967
    find_dynamic_lex $P3268, "$*SC"
    unless_null $P3268, vivify_1677
    get_hll_global $P3268, "$SC"
    unless_null $P3268, vivify_1678
    die "Contextual $*SC not found"
  vivify_1678:
  vivify_1677:
    get_hll_global $P3269, "KnowHOW"
    $P3270 = $P3268."pkg_create_mo"($P3269, "GLOBALish" :named("name"))
    store_dynamic_lex "$*GLOBALish", $P3270
.annotate 'line', 968
    find_dynamic_lex $P3271, "$*GLOBALish"
    unless_null $P3271, vivify_1679
    get_hll_global $P3271, "$GLOBALish"
    unless_null $P3271, vivify_1680
    die "Contextual $*GLOBALish not found"
  vivify_1680:
  vivify_1679:
    get_how $P3272, $P3271
    find_dynamic_lex $P3273, "$*GLOBALish"
    unless_null $P3273, vivify_1681
    get_hll_global $P3273, "$GLOBALish"
    unless_null $P3273, vivify_1682
    die "Contextual $*GLOBALish not found"
  vivify_1682:
  vivify_1681:
    $P3272."compose"($P3273)
.annotate 'line', 969
    find_dynamic_lex $P3274, "$*SC"
    unless_null $P3274, vivify_1683
    get_hll_global $P3274, "$SC"
    unless_null $P3274, vivify_1684
    die "Contextual $*SC not found"
  vivify_1684:
  vivify_1683:
    find_lex $P3275, "$?PACKAGE"
    get_who $P3276, $P3275
    set $P3277, $P3276["@BLOCK"]
    unless_null $P3277, vivify_1685
    $P3277 = root_new ['parrot';'ResizablePMCArray']
  vivify_1685:
    set $P3278, $P3277[0]
    unless_null $P3278, vivify_1686
    new $P3278, "Undef"
  vivify_1686:
    find_dynamic_lex $P3279, "$*GLOBALish"
    unless_null $P3279, vivify_1687
    get_hll_global $P3279, "$GLOBALish"
    unless_null $P3279, vivify_1688
    die "Contextual $*GLOBALish not found"
  vivify_1688:
  vivify_1687:
    $P3274."install_lexical_symbol"($P3278, "GLOBALish", $P3279)
.annotate 'line', 972
    find_dynamic_lex $P3280, "$*GLOBALish"
    unless_null $P3280, vivify_1689
    get_hll_global $P3280, "$GLOBALish"
    unless_null $P3280, vivify_1690
    die "Contextual $*GLOBALish not found"
  vivify_1690:
  vivify_1689:
    store_dynamic_lex "$*PACKAGE", $P3280
.annotate 'line', 973
    find_dynamic_lex $P3281, "$*SC"
    unless_null $P3281, vivify_1691
    get_hll_global $P3281, "$SC"
    unless_null $P3281, vivify_1692
    die "Contextual $*SC not found"
  vivify_1692:
  vivify_1691:
    find_lex $P3282, "$?PACKAGE"
    get_who $P3283, $P3282
    set $P3284, $P3283["@BLOCK"]
    unless_null $P3284, vivify_1693
    $P3284 = root_new ['parrot';'ResizablePMCArray']
  vivify_1693:
    set $P3285, $P3284[0]
    unless_null $P3285, vivify_1694
    new $P3285, "Undef"
  vivify_1694:
    find_dynamic_lex $P3286, "$*PACKAGE"
    unless_null $P3286, vivify_1695
    get_hll_global $P3286, "$PACKAGE"
    unless_null $P3286, vivify_1696
    die "Contextual $*PACKAGE not found"
  vivify_1696:
  vivify_1695:
    $P3287 = $P3281."install_lexical_symbol"($P3285, "$?PACKAGE", $P3286)
.annotate 'line', 963
    .return ($P3287)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "you_are_here"  :subid("440_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_3289
    .param pmc param_3290
.annotate 'line', 976
    .lex "self", param_3289
    .lex "$/", param_3290
.annotate 'line', 977
    find_lex $P3291, "$/"
    find_lex $P3292, "self"
    $P3293 = $P3292."CTXSAVE"()
    $P3294 = $P3291."!make"($P3293)
.annotate 'line', 976
    .return ($P3294)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<use>"  :subid("441_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_3296
    .param pmc param_3297
.annotate 'line', 982
    .lex "self", param_3296
    .lex "$/", param_3297
.annotate 'line', 983
    find_dynamic_lex $P3298, "$*SC"
    unless_null $P3298, vivify_1697
    get_hll_global $P3298, "$SC"
    unless_null $P3298, vivify_1698
    die "Contextual $*SC not found"
  vivify_1698:
  vivify_1697:
    find_lex $P3299, "$/"
    unless_null $P3299, vivify_1699
    $P3299 = root_new ['parrot';'Hash']
  vivify_1699:
    set $P3300, $P3299["name"]
    unless_null $P3300, vivify_1700
    new $P3300, "Undef"
  vivify_1700:
    set $S3301, $P3300
    $P3298."load_module"($S3301)
.annotate 'line', 984
    find_lex $P3302, "$/"
    get_hll_global $P3303, ["PAST"], "Stmts"
    $P3304 = $P3303."new"()
    $P3305 = $P3302."!make"($P3304)
.annotate 'line', 982
    .return ($P3305)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statement_control:sym<if>"  :subid("442_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_3307
    .param pmc param_3308
.annotate 'line', 987
    .const 'Sub' $P3336 = "443_1303401201.841" 
    capture_lex $P3336
    .lex "self", param_3307
    .lex "$/", param_3308
.annotate 'line', 988
    new $P3309, "Undef"
    .lex "$count", $P3309
.annotate 'line', 989
    new $P3310, "Undef"
    .lex "$past", $P3310
.annotate 'line', 988
    find_lex $P3311, "$/"
    unless_null $P3311, vivify_1701
    $P3311 = root_new ['parrot';'Hash']
  vivify_1701:
    set $P3312, $P3311["xblock"]
    unless_null $P3312, vivify_1702
    new $P3312, "Undef"
  vivify_1702:
    set $N3313, $P3312
    new $P3314, 'Float'
    set $P3314, $N3313
    sub $P3315, $P3314, 1
    store_lex "$count", $P3315
.annotate 'line', 989
    find_lex $P3316, "$count"
    unless_null $P3316, vivify_1703
    new $P3316, "Undef"
  vivify_1703:
    set $I3317, $P3316
    find_lex $P3318, "$/"
    unless_null $P3318, vivify_1704
    $P3318 = root_new ['parrot';'Hash']
  vivify_1704:
    set $P3319, $P3318["xblock"]
    unless_null $P3319, vivify_1705
    $P3319 = root_new ['parrot';'ResizablePMCArray']
  vivify_1705:
    set $P3320, $P3319[$I3317]
    unless_null $P3320, vivify_1706
    new $P3320, "Undef"
  vivify_1706:
    $P3321 = $P3320."ast"()
    $P3322 = "xblock_immediate"($P3321)
    store_lex "$past", $P3322
.annotate 'line', 990
    find_lex $P3324, "$/"
    unless_null $P3324, vivify_1707
    $P3324 = root_new ['parrot';'Hash']
  vivify_1707:
    set $P3325, $P3324["else"]
    unless_null $P3325, vivify_1708
    new $P3325, "Undef"
  vivify_1708:
    unless $P3325, if_3323_end
.annotate 'line', 991
    find_lex $P3326, "$past"
    unless_null $P3326, vivify_1709
    new $P3326, "Undef"
  vivify_1709:
    find_lex $P3327, "$/"
    unless_null $P3327, vivify_1710
    $P3327 = root_new ['parrot';'Hash']
  vivify_1710:
    set $P3328, $P3327["else"]
    unless_null $P3328, vivify_1711
    $P3328 = root_new ['parrot';'ResizablePMCArray']
  vivify_1711:
    set $P3329, $P3328[0]
    unless_null $P3329, vivify_1712
    new $P3329, "Undef"
  vivify_1712:
    $P3330 = $P3329."ast"()
    $P3331 = "block_immediate"($P3330)
    $P3326."push"($P3331)
  if_3323_end:
.annotate 'line', 994
    new $P3352, 'ExceptionHandler'
    set_label $P3352, loop3351_handler
    $P3352."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3352
  loop3351_test:
    find_lex $P3332, "$count"
    unless_null $P3332, vivify_1713
    new $P3332, "Undef"
  vivify_1713:
    set $N3333, $P3332
    isgt $I3334, $N3333, 0.0
    unless $I3334, loop3351_done
  loop3351_redo:
    .const 'Sub' $P3336 = "443_1303401201.841" 
    capture_lex $P3336
    $P3336()
  loop3351_next:
    goto loop3351_test
  loop3351_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3353, exception, 'type'
    eq $P3353, .CONTROL_LOOP_NEXT, loop3351_next
    eq $P3353, .CONTROL_LOOP_REDO, loop3351_redo
  loop3351_done:
    pop_eh 
.annotate 'line', 1000
    find_lex $P3354, "$/"
    find_lex $P3355, "$past"
    unless_null $P3355, vivify_1722
    new $P3355, "Undef"
  vivify_1722:
    $P3356 = $P3354."!make"($P3355)
.annotate 'line', 987
    .return ($P3356)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3335"  :anon :subid("443_1303401201.841") :outer("442_1303401201.841")
.annotate 'line', 996
    new $P3337, "Undef"
    .lex "$else", $P3337
.annotate 'line', 994
    find_lex $P3338, "$count"
    unless_null $P3338, vivify_1714
    new $P3338, "Undef"
  vivify_1714:
    clone $P3339, $P3338
    dec $P3338
.annotate 'line', 996
    find_lex $P3340, "$past"
    unless_null $P3340, vivify_1715
    new $P3340, "Undef"
  vivify_1715:
    store_lex "$else", $P3340
.annotate 'line', 997
    find_lex $P3341, "$count"
    unless_null $P3341, vivify_1716
    new $P3341, "Undef"
  vivify_1716:
    set $I3342, $P3341
    find_lex $P3343, "$/"
    unless_null $P3343, vivify_1717
    $P3343 = root_new ['parrot';'Hash']
  vivify_1717:
    set $P3344, $P3343["xblock"]
    unless_null $P3344, vivify_1718
    $P3344 = root_new ['parrot';'ResizablePMCArray']
  vivify_1718:
    set $P3345, $P3344[$I3342]
    unless_null $P3345, vivify_1719
    new $P3345, "Undef"
  vivify_1719:
    $P3346 = $P3345."ast"()
    $P3347 = "xblock_immediate"($P3346)
    store_lex "$past", $P3347
.annotate 'line', 998
    find_lex $P3348, "$past"
    unless_null $P3348, vivify_1720
    new $P3348, "Undef"
  vivify_1720:
    find_lex $P3349, "$else"
    unless_null $P3349, vivify_1721
    new $P3349, "Undef"
  vivify_1721:
    $P3350 = $P3348."push"($P3349)
.annotate 'line', 994
    .return ($P3350)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<unless>"  :subid("444_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_3358
    .param pmc param_3359
.annotate 'line', 1003
    .lex "self", param_3358
    .lex "$/", param_3359
.annotate 'line', 1004
    new $P3360, "Undef"
    .lex "$past", $P3360
    find_lex $P3361, "$/"
    unless_null $P3361, vivify_1723
    $P3361 = root_new ['parrot';'Hash']
  vivify_1723:
    set $P3362, $P3361["xblock"]
    unless_null $P3362, vivify_1724
    new $P3362, "Undef"
  vivify_1724:
    $P3363 = $P3362."ast"()
    $P3364 = "xblock_immediate"($P3363)
    store_lex "$past", $P3364
.annotate 'line', 1005
    find_lex $P3365, "$past"
    unless_null $P3365, vivify_1725
    new $P3365, "Undef"
  vivify_1725:
    $P3365."pasttype"("unless")
.annotate 'line', 1006
    find_lex $P3366, "$/"
    find_lex $P3367, "$past"
    unless_null $P3367, vivify_1726
    new $P3367, "Undef"
  vivify_1726:
    $P3368 = $P3366."!make"($P3367)
.annotate 'line', 1003
    .return ($P3368)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<while>"  :subid("445_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_3370
    .param pmc param_3371
.annotate 'line', 1009
    .lex "self", param_3370
    .lex "$/", param_3371
.annotate 'line', 1010
    new $P3372, "Undef"
    .lex "$past", $P3372
    find_lex $P3373, "$/"
    unless_null $P3373, vivify_1727
    $P3373 = root_new ['parrot';'Hash']
  vivify_1727:
    set $P3374, $P3373["xblock"]
    unless_null $P3374, vivify_1728
    new $P3374, "Undef"
  vivify_1728:
    $P3375 = $P3374."ast"()
    $P3376 = "xblock_immediate"($P3375)
    store_lex "$past", $P3376
.annotate 'line', 1011
    find_lex $P3377, "$past"
    unless_null $P3377, vivify_1729
    new $P3377, "Undef"
  vivify_1729:
    find_lex $P3378, "$/"
    unless_null $P3378, vivify_1730
    $P3378 = root_new ['parrot';'Hash']
  vivify_1730:
    set $P3379, $P3378["sym"]
    unless_null $P3379, vivify_1731
    new $P3379, "Undef"
  vivify_1731:
    set $S3380, $P3379
    $P3377."pasttype"($S3380)
.annotate 'line', 1012
    find_lex $P3381, "$/"
    find_lex $P3382, "$past"
    unless_null $P3382, vivify_1732
    new $P3382, "Undef"
  vivify_1732:
    $P3383 = $P3381."!make"($P3382)
.annotate 'line', 1009
    .return ($P3383)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<repeat>"  :subid("446_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_3385
    .param pmc param_3386
.annotate 'line', 1015
    .lex "self", param_3385
    .lex "$/", param_3386
.annotate 'line', 1016
    new $P3387, "Undef"
    .lex "$pasttype", $P3387
.annotate 'line', 1017
    new $P3388, "Undef"
    .lex "$past", $P3388
.annotate 'line', 1016
    new $P3389, "String"
    assign $P3389, "repeat_"
    find_lex $P3390, "$/"
    unless_null $P3390, vivify_1733
    $P3390 = root_new ['parrot';'Hash']
  vivify_1733:
    set $P3391, $P3390["wu"]
    unless_null $P3391, vivify_1734
    new $P3391, "Undef"
  vivify_1734:
    set $S3392, $P3391
    concat $P3393, $P3389, $S3392
    store_lex "$pasttype", $P3393
    find_lex $P3394, "$past"
    unless_null $P3394, vivify_1735
    new $P3394, "Undef"
  vivify_1735:
.annotate 'line', 1018
    find_lex $P3396, "$/"
    unless_null $P3396, vivify_1736
    $P3396 = root_new ['parrot';'Hash']
  vivify_1736:
    set $P3397, $P3396["xblock"]
    unless_null $P3397, vivify_1737
    new $P3397, "Undef"
  vivify_1737:
    if $P3397, if_3395
.annotate 'line', 1023
    get_hll_global $P3404, ["PAST"], "Op"
    find_lex $P3405, "$/"
    unless_null $P3405, vivify_1738
    $P3405 = root_new ['parrot';'Hash']
  vivify_1738:
    set $P3406, $P3405["EXPR"]
    unless_null $P3406, vivify_1739
    new $P3406, "Undef"
  vivify_1739:
    $P3407 = $P3406."ast"()
    find_lex $P3408, "$/"
    unless_null $P3408, vivify_1740
    $P3408 = root_new ['parrot';'Hash']
  vivify_1740:
    set $P3409, $P3408["pblock"]
    unless_null $P3409, vivify_1741
    new $P3409, "Undef"
  vivify_1741:
    $P3410 = $P3409."ast"()
    $P3411 = "block_immediate"($P3410)
    find_lex $P3412, "$pasttype"
    unless_null $P3412, vivify_1742
    new $P3412, "Undef"
  vivify_1742:
    find_lex $P3413, "$/"
    unless_null $P3413, vivify_1743
    new $P3413, "Undef"
  vivify_1743:
    $P3414 = $P3404."new"($P3407, $P3411, $P3412 :named("pasttype"), $P3413 :named("node"))
    store_lex "$past", $P3414
.annotate 'line', 1022
    goto if_3395_end
  if_3395:
.annotate 'line', 1019
    find_lex $P3398, "$/"
    unless_null $P3398, vivify_1744
    $P3398 = root_new ['parrot';'Hash']
  vivify_1744:
    set $P3399, $P3398["xblock"]
    unless_null $P3399, vivify_1745
    new $P3399, "Undef"
  vivify_1745:
    $P3400 = $P3399."ast"()
    $P3401 = "xblock_immediate"($P3400)
    store_lex "$past", $P3401
.annotate 'line', 1020
    find_lex $P3402, "$past"
    unless_null $P3402, vivify_1746
    new $P3402, "Undef"
  vivify_1746:
    find_lex $P3403, "$pasttype"
    unless_null $P3403, vivify_1747
    new $P3403, "Undef"
  vivify_1747:
    $P3402."pasttype"($P3403)
  if_3395_end:
.annotate 'line', 1026
    find_lex $P3415, "$/"
    find_lex $P3416, "$past"
    unless_null $P3416, vivify_1748
    new $P3416, "Undef"
  vivify_1748:
    $P3417 = $P3415."!make"($P3416)
.annotate 'line', 1015
    .return ($P3417)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<for>"  :subid("447_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_3419
    .param pmc param_3420
.annotate 'line', 1029
    .lex "self", param_3419
    .lex "$/", param_3420
.annotate 'line', 1030
    new $P3421, "Undef"
    .lex "$past", $P3421
.annotate 'line', 1032
    new $P3422, "Undef"
    .lex "$block", $P3422
.annotate 'line', 1030
    find_lex $P3423, "$/"
    unless_null $P3423, vivify_1749
    $P3423 = root_new ['parrot';'Hash']
  vivify_1749:
    set $P3424, $P3423["xblock"]
    unless_null $P3424, vivify_1750
    new $P3424, "Undef"
  vivify_1750:
    $P3425 = $P3424."ast"()
    store_lex "$past", $P3425
.annotate 'line', 1031
    find_lex $P3426, "$past"
    unless_null $P3426, vivify_1751
    new $P3426, "Undef"
  vivify_1751:
    $P3426."pasttype"("for")
.annotate 'line', 1032
    find_lex $P3427, "$past"
    unless_null $P3427, vivify_1752
    $P3427 = root_new ['parrot';'ResizablePMCArray']
  vivify_1752:
    set $P3428, $P3427[1]
    unless_null $P3428, vivify_1753
    new $P3428, "Undef"
  vivify_1753:
    store_lex "$block", $P3428
.annotate 'line', 1033
    find_lex $P3430, "$block"
    unless_null $P3430, vivify_1754
    new $P3430, "Undef"
  vivify_1754:
    $P3431 = $P3430."arity"()
    if $P3431, unless_3429_end
.annotate 'line', 1034
    find_lex $P3432, "$block"
    unless_null $P3432, vivify_1755
    $P3432 = root_new ['parrot';'ResizablePMCArray']
  vivify_1755:
    set $P3433, $P3432[0]
    unless_null $P3433, vivify_1756
    new $P3433, "Undef"
  vivify_1756:
    get_hll_global $P3434, ["PAST"], "Var"
    $P3435 = $P3434."new"("$_" :named("name"), "parameter" :named("scope"))
    $P3433."push"($P3435)
.annotate 'line', 1035
    find_lex $P3436, "$block"
    unless_null $P3436, vivify_1757
    new $P3436, "Undef"
  vivify_1757:
    $P3436."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 1036
    find_lex $P3437, "$block"
    unless_null $P3437, vivify_1758
    new $P3437, "Undef"
  vivify_1758:
    $P3437."arity"(1)
  unless_3429_end:
.annotate 'line', 1038
    find_lex $P3438, "$block"
    unless_null $P3438, vivify_1759
    new $P3438, "Undef"
  vivify_1759:
    $P3438."blocktype"("immediate")
.annotate 'line', 1039
    find_lex $P3439, "$/"
    find_lex $P3440, "$past"
    unless_null $P3440, vivify_1760
    new $P3440, "Undef"
  vivify_1760:
    $P3441 = $P3439."!make"($P3440)
.annotate 'line', 1029
    .return ($P3441)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CATCH>"  :subid("448_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_3443
    .param pmc param_3444
.annotate 'line', 1042
    .lex "self", param_3443
    .lex "$/", param_3444
.annotate 'line', 1043
    new $P3445, "Undef"
    .lex "$block", $P3445
    find_lex $P3446, "$/"
    unless_null $P3446, vivify_1761
    $P3446 = root_new ['parrot';'Hash']
  vivify_1761:
    set $P3447, $P3446["block"]
    unless_null $P3447, vivify_1762
    new $P3447, "Undef"
  vivify_1762:
    $P3448 = $P3447."ast"()
    store_lex "$block", $P3448
.annotate 'line', 1044
    find_lex $P3449, "$/"
    unless_null $P3449, vivify_1763
    new $P3449, "Undef"
  vivify_1763:
    find_lex $P3450, "$block"
    unless_null $P3450, vivify_1764
    new $P3450, "Undef"
  vivify_1764:
    "push_block_handler"($P3449, $P3450)
.annotate 'line', 1045
    find_lex $P3451, "$?PACKAGE"
    get_who $P3452, $P3451
    set $P3453, $P3452["@BLOCK"]
    unless_null $P3453, vivify_1765
    $P3453 = root_new ['parrot';'ResizablePMCArray']
  vivify_1765:
    set $P3454, $P3453[0]
    unless_null $P3454, vivify_1766
    new $P3454, "Undef"
  vivify_1766:
    $P3455 = $P3454."handlers"()
    set $P3456, $P3455[0]
    unless_null $P3456, vivify_1767
    new $P3456, "Undef"
  vivify_1767:
    $P3456."handle_types_except"("CONTROL")
.annotate 'line', 1046
    find_lex $P3457, "$/"
    get_hll_global $P3458, ["PAST"], "Stmts"
    find_lex $P3459, "$/"
    unless_null $P3459, vivify_1768
    new $P3459, "Undef"
  vivify_1768:
    $P3460 = $P3458."new"($P3459 :named("node"))
    $P3461 = $P3457."!make"($P3460)
.annotate 'line', 1042
    .return ($P3461)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CONTROL>"  :subid("449_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_3463
    .param pmc param_3464
.annotate 'line', 1049
    .lex "self", param_3463
    .lex "$/", param_3464
.annotate 'line', 1050
    new $P3465, "Undef"
    .lex "$block", $P3465
    find_lex $P3466, "$/"
    unless_null $P3466, vivify_1769
    $P3466 = root_new ['parrot';'Hash']
  vivify_1769:
    set $P3467, $P3466["block"]
    unless_null $P3467, vivify_1770
    new $P3467, "Undef"
  vivify_1770:
    $P3468 = $P3467."ast"()
    store_lex "$block", $P3468
.annotate 'line', 1051
    find_lex $P3469, "$/"
    unless_null $P3469, vivify_1771
    new $P3469, "Undef"
  vivify_1771:
    find_lex $P3470, "$block"
    unless_null $P3470, vivify_1772
    new $P3470, "Undef"
  vivify_1772:
    "push_block_handler"($P3469, $P3470)
.annotate 'line', 1052
    find_lex $P3471, "$?PACKAGE"
    get_who $P3472, $P3471
    set $P3473, $P3472["@BLOCK"]
    unless_null $P3473, vivify_1773
    $P3473 = root_new ['parrot';'ResizablePMCArray']
  vivify_1773:
    set $P3474, $P3473[0]
    unless_null $P3474, vivify_1774
    new $P3474, "Undef"
  vivify_1774:
    $P3475 = $P3474."handlers"()
    set $P3476, $P3475[0]
    unless_null $P3476, vivify_1775
    new $P3476, "Undef"
  vivify_1775:
    $P3476."handle_types"("CONTROL")
.annotate 'line', 1053
    find_lex $P3477, "$/"
    get_hll_global $P3478, ["PAST"], "Stmts"
    find_lex $P3479, "$/"
    unless_null $P3479, vivify_1776
    new $P3479, "Undef"
  vivify_1776:
    $P3480 = $P3478."new"($P3479 :named("node"))
    $P3481 = $P3477."!make"($P3480)
.annotate 'line', 1049
    .return ($P3481)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<INIT>"  :subid("450_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_3484
    .param pmc param_3485
.annotate 'line', 1093
    .lex "self", param_3484
    .lex "$/", param_3485
.annotate 'line', 1094
    find_lex $P3486, "$?PACKAGE"
    get_who $P3487, $P3486
    set $P3488, $P3487["@BLOCK"]
    unless_null $P3488, vivify_1777
    $P3488 = root_new ['parrot';'ResizablePMCArray']
  vivify_1777:
    set $P3489, $P3488[0]
    unless_null $P3489, vivify_1778
    new $P3489, "Undef"
  vivify_1778:
    find_lex $P3490, "$/"
    unless_null $P3490, vivify_1779
    $P3490 = root_new ['parrot';'Hash']
  vivify_1779:
    set $P3491, $P3490["blorst"]
    unless_null $P3491, vivify_1780
    new $P3491, "Undef"
  vivify_1780:
    $P3492 = $P3491."ast"()
    $P3489."push"($P3492)
.annotate 'line', 1095
    find_lex $P3493, "$/"
    get_hll_global $P3494, ["PAST"], "Stmts"
    $P3495 = $P3494."new"()
    $P3496 = $P3493."!make"($P3495)
.annotate 'line', 1093
    .return ($P3496)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<try>"  :subid("451_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_3498
    .param pmc param_3499
.annotate 'line', 1098
    .lex "self", param_3498
    .lex "$/", param_3499
.annotate 'line', 1099
    new $P3500, "Undef"
    .lex "$past", $P3500
    find_lex $P3501, "$/"
    unless_null $P3501, vivify_1781
    $P3501 = root_new ['parrot';'Hash']
  vivify_1781:
    set $P3502, $P3501["blorst"]
    unless_null $P3502, vivify_1782
    new $P3502, "Undef"
  vivify_1782:
    $P3503 = $P3502."ast"()
    store_lex "$past", $P3503
.annotate 'line', 1100
    get_hll_global $P3505, ["PAST"], "Block"
    find_lex $P3506, "$past"
    unless_null $P3506, vivify_1783
    new $P3506, "Undef"
  vivify_1783:
    $P3507 = $P3505."ACCEPTS"($P3506)
    if $P3507, unless_3504_end
.annotate 'line', 1101
    get_hll_global $P3508, ["PAST"], "Block"
    find_lex $P3509, "$past"
    unless_null $P3509, vivify_1784
    new $P3509, "Undef"
  vivify_1784:
    find_lex $P3510, "$/"
    unless_null $P3510, vivify_1785
    new $P3510, "Undef"
  vivify_1785:
    $P3511 = $P3508."new"($P3509, "immediate" :named("blocktype"), $P3510 :named("node"))
    store_lex "$past", $P3511
  unless_3504_end:
.annotate 'line', 1103
    find_lex $P3513, "$past"
    unless_null $P3513, vivify_1786
    new $P3513, "Undef"
  vivify_1786:
    $P3514 = $P3513."handlers"()
    if $P3514, unless_3512_end
.annotate 'line', 1104
    find_lex $P3515, "$past"
    unless_null $P3515, vivify_1787
    new $P3515, "Undef"
  vivify_1787:
    get_hll_global $P3516, ["PAST"], "Control"
.annotate 'line', 1106
    get_hll_global $P3517, ["PAST"], "Stmts"
.annotate 'line', 1107
    get_hll_global $P3518, ["PAST"], "Op"
.annotate 'line', 1108
    get_hll_global $P3519, ["PAST"], "Var"
.annotate 'line', 1109
    get_hll_global $P3520, ["PAST"], "Var"
    $P3521 = $P3520."new"("register" :named("scope"), "exception" :named("name"))
    $P3522 = $P3519."new"($P3521, "handled", "keyed" :named("scope"))
.annotate 'line', 1108
    $P3523 = $P3518."new"($P3522, 1, "bind" :named("pasttype"))
.annotate 'line', 1107
    $P3524 = $P3517."new"($P3523)
.annotate 'line', 1106
    $P3525 = $P3516."new"($P3524, "CONTROL" :named("handle_types_except"))
.annotate 'line', 1104
    new $P3526, "ResizablePMCArray"
    push $P3526, $P3525
    $P3515."handlers"($P3526)
  unless_3512_end:
.annotate 'line', 1118
    find_lex $P3527, "$/"
    find_lex $P3528, "$past"
    unless_null $P3528, vivify_1788
    new $P3528, "Undef"
  vivify_1788:
    $P3529 = $P3527."!make"($P3528)
.annotate 'line', 1098
    .return ($P3529)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blorst"  :subid("452_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_3531
    .param pmc param_3532
.annotate 'line', 1121
    .lex "self", param_3531
    .lex "$/", param_3532
.annotate 'line', 1122
    find_lex $P3533, "$/"
.annotate 'line', 1123
    find_lex $P3536, "$/"
    unless_null $P3536, vivify_1789
    $P3536 = root_new ['parrot';'Hash']
  vivify_1789:
    set $P3537, $P3536["block"]
    unless_null $P3537, vivify_1790
    new $P3537, "Undef"
  vivify_1790:
    if $P3537, if_3535
.annotate 'line', 1124
    find_lex $P3542, "$/"
    unless_null $P3542, vivify_1791
    $P3542 = root_new ['parrot';'Hash']
  vivify_1791:
    set $P3543, $P3542["statement"]
    unless_null $P3543, vivify_1792
    new $P3543, "Undef"
  vivify_1792:
    $P3544 = $P3543."ast"()
    set $P3534, $P3544
.annotate 'line', 1123
    goto if_3535_end
  if_3535:
    find_lex $P3538, "$/"
    unless_null $P3538, vivify_1793
    $P3538 = root_new ['parrot';'Hash']
  vivify_1793:
    set $P3539, $P3538["block"]
    unless_null $P3539, vivify_1794
    new $P3539, "Undef"
  vivify_1794:
    $P3540 = $P3539."ast"()
    $P3541 = "block_immediate"($P3540)
    set $P3534, $P3541
  if_3535_end:
    $P3545 = $P3533."!make"($P3534)
.annotate 'line', 1121
    .return ($P3545)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<if>"  :subid("453_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_3547
    .param pmc param_3548
.annotate 'line', 1129
    .lex "self", param_3547
    .lex "$/", param_3548
    find_lex $P3549, "$/"
    find_lex $P3550, "$/"
    unless_null $P3550, vivify_1795
    $P3550 = root_new ['parrot';'Hash']
  vivify_1795:
    set $P3551, $P3550["cond"]
    unless_null $P3551, vivify_1796
    new $P3551, "Undef"
  vivify_1796:
    $P3552 = $P3551."ast"()
    $P3553 = $P3549."!make"($P3552)
    .return ($P3553)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<unless>"  :subid("454_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_3555
    .param pmc param_3556
.annotate 'line', 1130
    .lex "self", param_3555
    .lex "$/", param_3556
    find_lex $P3557, "$/"
    find_lex $P3558, "$/"
    unless_null $P3558, vivify_1797
    $P3558 = root_new ['parrot';'Hash']
  vivify_1797:
    set $P3559, $P3558["cond"]
    unless_null $P3559, vivify_1798
    new $P3559, "Undef"
  vivify_1798:
    $P3560 = $P3559."ast"()
    $P3561 = $P3557."!make"($P3560)
    .return ($P3561)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<while>"  :subid("455_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_3563
    .param pmc param_3564
.annotate 'line', 1132
    .lex "self", param_3563
    .lex "$/", param_3564
    find_lex $P3565, "$/"
    find_lex $P3566, "$/"
    unless_null $P3566, vivify_1799
    $P3566 = root_new ['parrot';'Hash']
  vivify_1799:
    set $P3567, $P3566["cond"]
    unless_null $P3567, vivify_1800
    new $P3567, "Undef"
  vivify_1800:
    $P3568 = $P3567."ast"()
    $P3569 = $P3565."!make"($P3568)
    .return ($P3569)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<until>"  :subid("456_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_3571
    .param pmc param_3572
.annotate 'line', 1133
    .lex "self", param_3571
    .lex "$/", param_3572
    find_lex $P3573, "$/"
    find_lex $P3574, "$/"
    unless_null $P3574, vivify_1801
    $P3574 = root_new ['parrot';'Hash']
  vivify_1801:
    set $P3575, $P3574["cond"]
    unless_null $P3575, vivify_1802
    new $P3575, "Undef"
  vivify_1802:
    $P3576 = $P3575."ast"()
    $P3577 = $P3573."!make"($P3576)
    .return ($P3577)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<fatarrow>"  :subid("457_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_3579
    .param pmc param_3580
.annotate 'line', 1137
    .lex "self", param_3579
    .lex "$/", param_3580
    find_lex $P3581, "$/"
    find_lex $P3582, "$/"
    unless_null $P3582, vivify_1803
    $P3582 = root_new ['parrot';'Hash']
  vivify_1803:
    set $P3583, $P3582["fatarrow"]
    unless_null $P3583, vivify_1804
    new $P3583, "Undef"
  vivify_1804:
    $P3584 = $P3583."ast"()
    $P3585 = $P3581."!make"($P3584)
    .return ($P3585)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<colonpair>"  :subid("458_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_3587
    .param pmc param_3588
.annotate 'line', 1138
    .lex "self", param_3587
    .lex "$/", param_3588
    find_lex $P3589, "$/"
    find_lex $P3590, "$/"
    unless_null $P3590, vivify_1805
    $P3590 = root_new ['parrot';'Hash']
  vivify_1805:
    set $P3591, $P3590["colonpair"]
    unless_null $P3591, vivify_1806
    new $P3591, "Undef"
  vivify_1806:
    $P3592 = $P3591."ast"()
    $P3593 = $P3589."!make"($P3592)
    .return ($P3593)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<variable>"  :subid("459_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_3595
    .param pmc param_3596
.annotate 'line', 1139
    .lex "self", param_3595
    .lex "$/", param_3596
    find_lex $P3597, "$/"
    find_lex $P3598, "$/"
    unless_null $P3598, vivify_1807
    $P3598 = root_new ['parrot';'Hash']
  vivify_1807:
    set $P3599, $P3598["variable"]
    unless_null $P3599, vivify_1808
    new $P3599, "Undef"
  vivify_1808:
    $P3600 = $P3599."ast"()
    $P3601 = $P3597."!make"($P3600)
    .return ($P3601)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<package_declarator>"  :subid("460_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_3603
    .param pmc param_3604
.annotate 'line', 1140
    .lex "self", param_3603
    .lex "$/", param_3604
    find_lex $P3605, "$/"
    find_lex $P3606, "$/"
    unless_null $P3606, vivify_1809
    $P3606 = root_new ['parrot';'Hash']
  vivify_1809:
    set $P3607, $P3606["package_declarator"]
    unless_null $P3607, vivify_1810
    new $P3607, "Undef"
  vivify_1810:
    $P3608 = $P3607."ast"()
    $P3609 = $P3605."!make"($P3608)
    .return ($P3609)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<scope_declarator>"  :subid("461_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_3611
    .param pmc param_3612
.annotate 'line', 1141
    .lex "self", param_3611
    .lex "$/", param_3612
    find_lex $P3613, "$/"
    find_lex $P3614, "$/"
    unless_null $P3614, vivify_1811
    $P3614 = root_new ['parrot';'Hash']
  vivify_1811:
    set $P3615, $P3614["scope_declarator"]
    unless_null $P3615, vivify_1812
    new $P3615, "Undef"
  vivify_1812:
    $P3616 = $P3615."ast"()
    $P3617 = $P3613."!make"($P3616)
    .return ($P3617)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<routine_declarator>"  :subid("462_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_3619
    .param pmc param_3620
.annotate 'line', 1142
    .lex "self", param_3619
    .lex "$/", param_3620
    find_lex $P3621, "$/"
    find_lex $P3622, "$/"
    unless_null $P3622, vivify_1813
    $P3622 = root_new ['parrot';'Hash']
  vivify_1813:
    set $P3623, $P3622["routine_declarator"]
    unless_null $P3623, vivify_1814
    new $P3623, "Undef"
  vivify_1814:
    $P3624 = $P3623."ast"()
    $P3625 = $P3621."!make"($P3624)
    .return ($P3625)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<regex_declarator>"  :subid("463_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_3627
    .param pmc param_3628
.annotate 'line', 1143
    .lex "self", param_3627
    .lex "$/", param_3628
    find_lex $P3629, "$/"
    find_lex $P3630, "$/"
    unless_null $P3630, vivify_1815
    $P3630 = root_new ['parrot';'Hash']
  vivify_1815:
    set $P3631, $P3630["regex_declarator"]
    unless_null $P3631, vivify_1816
    new $P3631, "Undef"
  vivify_1816:
    $P3632 = $P3631."ast"()
    $P3633 = $P3629."!make"($P3632)
    .return ($P3633)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<statement_prefix>"  :subid("464_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_3635
    .param pmc param_3636
.annotate 'line', 1144
    .lex "self", param_3635
    .lex "$/", param_3636
    find_lex $P3637, "$/"
    find_lex $P3638, "$/"
    unless_null $P3638, vivify_1817
    $P3638 = root_new ['parrot';'Hash']
  vivify_1817:
    set $P3639, $P3638["statement_prefix"]
    unless_null $P3639, vivify_1818
    new $P3639, "Undef"
  vivify_1818:
    $P3640 = $P3639."ast"()
    $P3641 = $P3637."!make"($P3640)
    .return ($P3641)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<lambda>"  :subid("465_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_3643
    .param pmc param_3644
.annotate 'line', 1145
    .lex "self", param_3643
    .lex "$/", param_3644
    find_lex $P3645, "$/"
    find_lex $P3646, "$/"
    unless_null $P3646, vivify_1819
    $P3646 = root_new ['parrot';'Hash']
  vivify_1819:
    set $P3647, $P3646["pblock"]
    unless_null $P3647, vivify_1820
    new $P3647, "Undef"
  vivify_1820:
    $P3648 = $P3647."ast"()
    $P3649 = $P3645."!make"($P3648)
    .return ($P3649)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "fatarrow"  :subid("466_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_3651
    .param pmc param_3652
.annotate 'line', 1147
    .lex "self", param_3651
    .lex "$/", param_3652
.annotate 'line', 1148
    new $P3653, "Undef"
    .lex "$past", $P3653
    find_lex $P3654, "$/"
    unless_null $P3654, vivify_1821
    $P3654 = root_new ['parrot';'Hash']
  vivify_1821:
    set $P3655, $P3654["val"]
    unless_null $P3655, vivify_1822
    new $P3655, "Undef"
  vivify_1822:
    $P3656 = $P3655."ast"()
    store_lex "$past", $P3656
.annotate 'line', 1149
    find_lex $P3657, "$past"
    unless_null $P3657, vivify_1823
    new $P3657, "Undef"
  vivify_1823:
    find_lex $P3658, "$/"
    unless_null $P3658, vivify_1824
    $P3658 = root_new ['parrot';'Hash']
  vivify_1824:
    set $P3659, $P3658["key"]
    unless_null $P3659, vivify_1825
    new $P3659, "Undef"
  vivify_1825:
    $P3660 = $P3659."Str"()
    $P3657."named"($P3660)
.annotate 'line', 1150
    find_lex $P3661, "$/"
    find_lex $P3662, "$past"
    unless_null $P3662, vivify_1826
    new $P3662, "Undef"
  vivify_1826:
    $P3663 = $P3661."!make"($P3662)
.annotate 'line', 1147
    .return ($P3663)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair"  :subid("467_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_3665
    .param pmc param_3666
.annotate 'line', 1153
    .lex "self", param_3665
    .lex "$/", param_3666
.annotate 'line', 1154
    new $P3667, "Undef"
    .lex "$past", $P3667
.annotate 'line', 1155
    find_lex $P3670, "$/"
    unless_null $P3670, vivify_1827
    $P3670 = root_new ['parrot';'Hash']
  vivify_1827:
    set $P3671, $P3670["circumfix"]
    unless_null $P3671, vivify_1828
    new $P3671, "Undef"
  vivify_1828:
    if $P3671, if_3669
.annotate 'line', 1156
    get_hll_global $P3676, ["PAST"], "Val"
    find_lex $P3677, "$/"
    unless_null $P3677, vivify_1829
    $P3677 = root_new ['parrot';'Hash']
  vivify_1829:
    set $P3678, $P3677["not"]
    unless_null $P3678, vivify_1830
    new $P3678, "Undef"
  vivify_1830:
    isfalse $I3679, $P3678
    $P3680 = $P3676."new"($I3679 :named("value"))
    set $P3668, $P3680
.annotate 'line', 1155
    goto if_3669_end
  if_3669:
    find_lex $P3672, "$/"
    unless_null $P3672, vivify_1831
    $P3672 = root_new ['parrot';'Hash']
  vivify_1831:
    set $P3673, $P3672["circumfix"]
    unless_null $P3673, vivify_1832
    $P3673 = root_new ['parrot';'ResizablePMCArray']
  vivify_1832:
    set $P3674, $P3673[0]
    unless_null $P3674, vivify_1833
    new $P3674, "Undef"
  vivify_1833:
    $P3675 = $P3674."ast"()
    set $P3668, $P3675
  if_3669_end:
    store_lex "$past", $P3668
.annotate 'line', 1157
    find_lex $P3681, "$past"
    unless_null $P3681, vivify_1834
    new $P3681, "Undef"
  vivify_1834:
    find_lex $P3682, "$/"
    unless_null $P3682, vivify_1835
    $P3682 = root_new ['parrot';'Hash']
  vivify_1835:
    set $P3683, $P3682["identifier"]
    unless_null $P3683, vivify_1836
    new $P3683, "Undef"
  vivify_1836:
    set $S3684, $P3683
    $P3681."named"($S3684)
.annotate 'line', 1158
    find_lex $P3685, "$/"
    find_lex $P3686, "$past"
    unless_null $P3686, vivify_1837
    new $P3686, "Undef"
  vivify_1837:
    $P3687 = $P3685."!make"($P3686)
.annotate 'line', 1153
    .return ($P3687)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "variable"  :subid("468_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_3689
    .param pmc param_3690
.annotate 'line', 1161
    .const 'Sub' $P3703 = "469_1303401201.841" 
    capture_lex $P3703
    .lex "self", param_3689
    .lex "$/", param_3690
.annotate 'line', 1162
    new $P3691, "Undef"
    .lex "$past", $P3691
.annotate 'line', 1161
    find_lex $P3692, "$past"
    unless_null $P3692, vivify_1838
    new $P3692, "Undef"
  vivify_1838:
.annotate 'line', 1163
    find_lex $P3694, "$/"
    unless_null $P3694, vivify_1839
    $P3694 = root_new ['parrot';'Hash']
  vivify_1839:
    set $P3695, $P3694["postcircumfix"]
    unless_null $P3695, vivify_1840
    new $P3695, "Undef"
  vivify_1840:
    if $P3695, if_3693
.annotate 'line', 1167
    .const 'Sub' $P3703 = "469_1303401201.841" 
    capture_lex $P3703
    $P3703()
    goto if_3693_end
  if_3693:
.annotate 'line', 1164
    find_lex $P3696, "$/"
    unless_null $P3696, vivify_1876
    $P3696 = root_new ['parrot';'Hash']
  vivify_1876:
    set $P3697, $P3696["postcircumfix"]
    unless_null $P3697, vivify_1877
    new $P3697, "Undef"
  vivify_1877:
    $P3698 = $P3697."ast"()
    store_lex "$past", $P3698
.annotate 'line', 1165
    find_lex $P3699, "$past"
    unless_null $P3699, vivify_1878
    new $P3699, "Undef"
  vivify_1878:
    get_hll_global $P3700, ["PAST"], "Var"
    $P3701 = $P3700."new"("$/" :named("name"))
    $P3699."unshift"($P3701)
  if_3693_end:
.annotate 'line', 1209
    find_lex $P3796, "$/"
    find_lex $P3797, "$past"
    unless_null $P3797, vivify_1879
    new $P3797, "Undef"
  vivify_1879:
    $P3798 = $P3796."!make"($P3797)
.annotate 'line', 1161
    .return ($P3798)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3702"  :anon :subid("469_1303401201.841") :outer("468_1303401201.841")
.annotate 'line', 1168
    $P3704 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P3704
    get_hll_global $P3705, ["NQP"], "Compiler"
    find_lex $P3706, "$/"
    unless_null $P3706, vivify_1841
    new $P3706, "Undef"
  vivify_1841:
    set $S3707, $P3706
    $P3708 = $P3705."parse_name"($S3707)
    store_lex "@name", $P3708
.annotate 'line', 1169
    find_lex $P3711, "@name"
    unless_null $P3711, vivify_1842
    $P3711 = root_new ['parrot';'ResizablePMCArray']
  vivify_1842:
    set $N3712, $P3711
    isgt $I3713, $N3712, 1.0
    if $I3713, if_3710
.annotate 'line', 1176
    find_lex $P3729, "$/"
    unless_null $P3729, vivify_1843
    $P3729 = root_new ['parrot';'Hash']
  vivify_1843:
    set $P3730, $P3729["twigil"]
    unless_null $P3730, vivify_1844
    $P3730 = root_new ['parrot';'ResizablePMCArray']
  vivify_1844:
    set $P3731, $P3730[0]
    unless_null $P3731, vivify_1845
    new $P3731, "Undef"
  vivify_1845:
    set $S3732, $P3731
    iseq $I3733, $S3732, "*"
    if $I3733, if_3728
.annotate 'line', 1191
    find_lex $P3757, "$/"
    unless_null $P3757, vivify_1846
    $P3757 = root_new ['parrot';'Hash']
  vivify_1846:
    set $P3758, $P3757["twigil"]
    unless_null $P3758, vivify_1847
    $P3758 = root_new ['parrot';'ResizablePMCArray']
  vivify_1847:
    set $P3759, $P3758[0]
    unless_null $P3759, vivify_1848
    new $P3759, "Undef"
  vivify_1848:
    set $S3760, $P3759
    iseq $I3761, $S3760, "!"
    if $I3761, if_3756
.annotate 'line', 1199
    find_lex $P3776, "@name"
    unless_null $P3776, vivify_1849
    $P3776 = root_new ['parrot';'ResizablePMCArray']
  vivify_1849:
    set $P3777, $P3776[0]
    unless_null $P3777, vivify_1850
    new $P3777, "Undef"
  vivify_1850:
    set $S3778, $P3777
    $P3779 = "is_package"($S3778)
    if $P3779, if_3775
.annotate 'line', 1204
    get_hll_global $P3788, ["PAST"], "Var"
.annotate 'line', 1205
    find_lex $P3789, "@name"
    unless_null $P3789, vivify_1851
    $P3789 = root_new ['parrot';'ResizablePMCArray']
  vivify_1851:
    $P3790 = $P3789."pop"()
    set $S3791, $P3790
    find_lex $P3792, "$/"
    unless_null $P3792, vivify_1852
    $P3792 = root_new ['parrot';'Hash']
  vivify_1852:
    set $P3793, $P3792["sigil"]
    unless_null $P3793, vivify_1853
    new $P3793, "Undef"
  vivify_1853:
    $P3794 = "vivitype"($P3793)
    $P3795 = $P3788."new"($S3791 :named("name"), $P3794 :named("viviself"))
.annotate 'line', 1204
    store_lex "$past", $P3795
.annotate 'line', 1203
    set $P3774, $P3795
.annotate 'line', 1199
    goto if_3775_end
  if_3775:
.annotate 'line', 1200
    find_lex $P3780, "@name"
    unless_null $P3780, vivify_1854
    $P3780 = root_new ['parrot';'ResizablePMCArray']
  vivify_1854:
    find_lex $P3781, "$/"
    unless_null $P3781, vivify_1855
    new $P3781, "Undef"
  vivify_1855:
    $P3782 = "lexical_package_lookup"($P3780, $P3781)
    store_lex "$past", $P3782
.annotate 'line', 1201
    find_lex $P3783, "$past"
    unless_null $P3783, vivify_1856
    new $P3783, "Undef"
  vivify_1856:
    find_lex $P3784, "$/"
    unless_null $P3784, vivify_1857
    $P3784 = root_new ['parrot';'Hash']
  vivify_1857:
    set $P3785, $P3784["sigil"]
    unless_null $P3785, vivify_1858
    new $P3785, "Undef"
  vivify_1858:
    $P3786 = "vivitype"($P3785)
    $P3787 = $P3783."viviself"($P3786)
.annotate 'line', 1199
    set $P3774, $P3787
  if_3775_end:
    set $P3755, $P3774
.annotate 'line', 1191
    goto if_3756_end
  if_3756:
.annotate 'line', 1192
    get_hll_global $P3762, ["PAST"], "Var"
.annotate 'line', 1193
    find_lex $P3763, "@name"
    unless_null $P3763, vivify_1859
    $P3763 = root_new ['parrot';'ResizablePMCArray']
  vivify_1859:
    $P3764 = $P3763."pop"()
    set $S3765, $P3764
.annotate 'line', 1194
    find_lex $P3766, "$/"
    unless_null $P3766, vivify_1860
    $P3766 = root_new ['parrot';'Hash']
  vivify_1860:
    set $P3767, $P3766["sigil"]
    unless_null $P3767, vivify_1861
    new $P3767, "Undef"
  vivify_1861:
    $P3768 = "vivitype"($P3767)
.annotate 'line', 1195
    get_hll_global $P3769, ["PAST"], "Var"
    $P3770 = $P3769."new"("self" :named("name"))
.annotate 'line', 1196
    get_hll_global $P3771, ["PAST"], "Var"
    $P3772 = $P3771."new"("$?CLASS" :named("name"))
    $P3773 = $P3762."new"($P3770, $P3772, $S3765 :named("name"), "attribute" :named("scope"), $P3768 :named("viviself"))
.annotate 'line', 1192
    store_lex "$past", $P3773
.annotate 'line', 1191
    set $P3755, $P3773
  if_3756_end:
    set $P3727, $P3755
.annotate 'line', 1176
    goto if_3728_end
  if_3728:
.annotate 'line', 1177
    get_hll_global $P3734, ["PAST"], "Var"
.annotate 'line', 1178
    find_lex $P3735, "@name"
    unless_null $P3735, vivify_1862
    $P3735 = root_new ['parrot';'ResizablePMCArray']
  vivify_1862:
    $P3736 = $P3735."pop"()
    set $S3737, $P3736
.annotate 'line', 1180
    get_hll_global $P3738, ["PAST"], "Var"
.annotate 'line', 1182
    find_lex $P3739, "$/"
    unless_null $P3739, vivify_1863
    $P3739 = root_new ['parrot';'Hash']
  vivify_1863:
    set $P3740, $P3739["sigil"]
    unless_null $P3740, vivify_1864
    new $P3740, "Undef"
  vivify_1864:
    set $S3741, $P3740
    new $P3742, 'String'
    set $P3742, $S3741
    find_lex $P3743, "$/"
    unless_null $P3743, vivify_1865
    $P3743 = root_new ['parrot';'Hash']
  vivify_1865:
    set $P3744, $P3743["desigilname"]
    unless_null $P3744, vivify_1866
    new $P3744, "Undef"
  vivify_1866:
    concat $P3745, $P3742, $P3744
.annotate 'line', 1184
    get_hll_global $P3746, ["PAST"], "Op"
    new $P3747, "String"
    assign $P3747, "Contextual "
    find_lex $P3748, "$/"
    unless_null $P3748, vivify_1867
    new $P3748, "Undef"
  vivify_1867:
    set $S3749, $P3748
    concat $P3750, $P3747, $S3749
    concat $P3751, $P3750, " not found"
    $P3752 = $P3746."new"($P3751, "die" :named("pirop"))
    $P3753 = $P3738."new"("package" :named("scope"), "" :named("namespace"), $P3745 :named("name"), $P3752 :named("viviself"))
.annotate 'line', 1180
    $P3754 = $P3734."new"($S3737 :named("name"), "contextual" :named("scope"), $P3753 :named("viviself"))
.annotate 'line', 1177
    store_lex "$past", $P3754
.annotate 'line', 1176
    set $P3727, $P3754
  if_3728_end:
    set $P3709, $P3727
.annotate 'line', 1169
    goto if_3710_end
  if_3710:
.annotate 'line', 1170
    find_lex $P3715, "$/"
    unless_null $P3715, vivify_1868
    $P3715 = root_new ['parrot';'Hash']
  vivify_1868:
    set $P3716, $P3715["twigil"]
    unless_null $P3716, vivify_1869
    new $P3716, "Undef"
  vivify_1869:
    unless $P3716, if_3714_end
.annotate 'line', 1171
    find_lex $P3717, "$/"
    unless_null $P3717, vivify_1870
    new $P3717, "Undef"
  vivify_1870:
    $P3718 = $P3717."CURSOR"()
    $P3718."panic"("Twigil not allowed on multi-part name")
  if_3714_end:
.annotate 'line', 1173
    find_lex $P3719, "@name"
    unless_null $P3719, vivify_1871
    $P3719 = root_new ['parrot';'ResizablePMCArray']
  vivify_1871:
    find_lex $P3720, "$/"
    unless_null $P3720, vivify_1872
    new $P3720, "Undef"
  vivify_1872:
    $P3721 = "lexical_package_lookup"($P3719, $P3720)
    store_lex "$past", $P3721
.annotate 'line', 1174
    find_lex $P3722, "$past"
    unless_null $P3722, vivify_1873
    new $P3722, "Undef"
  vivify_1873:
    find_lex $P3723, "$/"
    unless_null $P3723, vivify_1874
    $P3723 = root_new ['parrot';'Hash']
  vivify_1874:
    set $P3724, $P3723["sigil"]
    unless_null $P3724, vivify_1875
    new $P3724, "Undef"
  vivify_1875:
    $P3725 = "vivitype"($P3724)
    $P3726 = $P3722."viviself"($P3725)
.annotate 'line', 1169
    set $P3709, $P3726
  if_3710_end:
.annotate 'line', 1167
    .return ($P3709)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<module>"  :subid("470_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_3800
    .param pmc param_3801
.annotate 'line', 1212
    .lex "self", param_3800
    .lex "$/", param_3801
    find_lex $P3802, "$/"
    find_lex $P3803, "$/"
    unless_null $P3803, vivify_1880
    $P3803 = root_new ['parrot';'Hash']
  vivify_1880:
    set $P3804, $P3803["package_def"]
    unless_null $P3804, vivify_1881
    new $P3804, "Undef"
  vivify_1881:
    $P3805 = $P3804."ast"()
    $P3806 = $P3802."!make"($P3805)
    .return ($P3806)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<knowhow>"  :subid("471_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_3808
    .param pmc param_3809
.annotate 'line', 1213
    .lex "self", param_3808
    .lex "$/", param_3809
    find_lex $P3810, "$/"
    find_lex $P3811, "$/"
    unless_null $P3811, vivify_1882
    $P3811 = root_new ['parrot';'Hash']
  vivify_1882:
    set $P3812, $P3811["package_def"]
    unless_null $P3812, vivify_1883
    new $P3812, "Undef"
  vivify_1883:
    $P3813 = $P3812."ast"()
    $P3814 = $P3810."!make"($P3813)
    .return ($P3814)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<class>"  :subid("472_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_3816
    .param pmc param_3817
.annotate 'line', 1214
    .lex "self", param_3816
    .lex "$/", param_3817
    find_lex $P3818, "$/"
    find_lex $P3819, "$/"
    unless_null $P3819, vivify_1884
    $P3819 = root_new ['parrot';'Hash']
  vivify_1884:
    set $P3820, $P3819["package_def"]
    unless_null $P3820, vivify_1885
    new $P3820, "Undef"
  vivify_1885:
    $P3821 = $P3820."ast"()
    $P3822 = $P3818."!make"($P3821)
    .return ($P3822)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<grammar>"  :subid("473_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_3824
    .param pmc param_3825
.annotate 'line', 1215
    .lex "self", param_3824
    .lex "$/", param_3825
    find_lex $P3826, "$/"
    find_lex $P3827, "$/"
    unless_null $P3827, vivify_1886
    $P3827 = root_new ['parrot';'Hash']
  vivify_1886:
    set $P3828, $P3827["package_def"]
    unless_null $P3828, vivify_1887
    new $P3828, "Undef"
  vivify_1887:
    $P3829 = $P3828."ast"()
    $P3830 = $P3826."!make"($P3829)
    .return ($P3830)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<role>"  :subid("474_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_3832
    .param pmc param_3833
.annotate 'line', 1216
    .lex "self", param_3832
    .lex "$/", param_3833
    find_lex $P3834, "$/"
    find_lex $P3835, "$/"
    unless_null $P3835, vivify_1888
    $P3835 = root_new ['parrot';'Hash']
  vivify_1888:
    set $P3836, $P3835["package_def"]
    unless_null $P3836, vivify_1889
    new $P3836, "Undef"
  vivify_1889:
    $P3837 = $P3836."ast"()
    $P3838 = $P3834."!make"($P3837)
    .return ($P3838)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<native>"  :subid("475_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_3840
    .param pmc param_3841
.annotate 'line', 1217
    .lex "self", param_3840
    .lex "$/", param_3841
    find_lex $P3842, "$/"
    find_lex $P3843, "$/"
    unless_null $P3843, vivify_1890
    $P3843 = root_new ['parrot';'Hash']
  vivify_1890:
    set $P3844, $P3843["package_def"]
    unless_null $P3844, vivify_1891
    new $P3844, "Undef"
  vivify_1891:
    $P3845 = $P3844."ast"()
    $P3846 = $P3842."!make"($P3845)
    .return ($P3846)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "package_def"  :subid("476_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_3848
    .param pmc param_3849
.annotate 'line', 1219
    .const 'Sub' $P3998 = "478_1303401201.841" 
    capture_lex $P3998
    .const 'Sub' $P3940 = "477_1303401201.841" 
    capture_lex $P3940
    .lex "self", param_3848
    .lex "$/", param_3849
.annotate 'line', 1221
    $P3850 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P3850
.annotate 'line', 1222
    new $P3851, "Undef"
    .lex "$name", $P3851
.annotate 'line', 1223
    new $P3852, "Undef"
    .lex "$how", $P3852
.annotate 'line', 1226
    new $P3853, "Undef"
    .lex "$past", $P3853
.annotate 'line', 1221
    find_lex $P3854, "$/"
    unless_null $P3854, vivify_1892
    $P3854 = root_new ['parrot';'Hash']
  vivify_1892:
    set $P3855, $P3854["name"]
    unless_null $P3855, vivify_1893
    $P3855 = root_new ['parrot';'Hash']
  vivify_1893:
    set $P3856, $P3855["identifier"]
    unless_null $P3856, vivify_1894
    new $P3856, "Undef"
  vivify_1894:
    clone $P3857, $P3856
    store_lex "@ns", $P3857
.annotate 'line', 1222
    find_lex $P3858, "@ns"
    unless_null $P3858, vivify_1895
    $P3858 = root_new ['parrot';'ResizablePMCArray']
  vivify_1895:
    $P3859 = $P3858."pop"()
    set $S3860, $P3859
    new $P3861, 'String'
    set $P3861, $S3860
    store_lex "$name", $P3861
.annotate 'line', 1223
    find_dynamic_lex $P3862, "$*PKGDECL"
    unless_null $P3862, vivify_1896
    get_hll_global $P3862, "$PKGDECL"
    unless_null $P3862, vivify_1897
    die "Contextual $*PKGDECL not found"
  vivify_1897:
  vivify_1896:
    find_dynamic_lex $P3863, "%*HOW"
    unless_null $P3863, vivify_1898
    get_hll_global $P3863, "%HOW"
    unless_null $P3863, vivify_1899
    die "Contextual %*HOW not found"
  vivify_1899:
  vivify_1898:
    set $P3864, $P3863[$P3862]
    unless_null $P3864, vivify_1900
    new $P3864, "Undef"
  vivify_1900:
    store_lex "$how", $P3864
.annotate 'line', 1226
    find_lex $P3867, "$/"
    unless_null $P3867, vivify_1901
    $P3867 = root_new ['parrot';'Hash']
  vivify_1901:
    set $P3868, $P3867["block"]
    unless_null $P3868, vivify_1902
    new $P3868, "Undef"
  vivify_1902:
    if $P3868, if_3866
    find_lex $P3872, "$/"
    unless_null $P3872, vivify_1903
    $P3872 = root_new ['parrot';'Hash']
  vivify_1903:
    set $P3873, $P3872["comp_unit"]
    unless_null $P3873, vivify_1904
    new $P3873, "Undef"
  vivify_1904:
    $P3874 = $P3873."ast"()
    set $P3865, $P3874
    goto if_3866_end
  if_3866:
    find_lex $P3869, "$/"
    unless_null $P3869, vivify_1905
    $P3869 = root_new ['parrot';'Hash']
  vivify_1905:
    set $P3870, $P3869["block"]
    unless_null $P3870, vivify_1906
    new $P3870, "Undef"
  vivify_1906:
    $P3871 = $P3870."ast"()
    set $P3865, $P3871
  if_3866_end:
    store_lex "$past", $P3865
.annotate 'line', 1227
    find_dynamic_lex $P3878, "$*SCOPE"
    unless_null $P3878, vivify_1907
    get_hll_global $P3878, "$SCOPE"
    unless_null $P3878, vivify_1908
    die "Contextual $*SCOPE not found"
  vivify_1908:
  vivify_1907:
    set $S3879, $P3878
    iseq $I3880, $S3879, "our"
    unless $I3880, unless_3877
    new $P3876, 'Integer'
    set $P3876, $I3880
    goto unless_3877_end
  unless_3877:
    find_dynamic_lex $P3881, "$*SCOPE"
    unless_null $P3881, vivify_1909
    get_hll_global $P3881, "$SCOPE"
    unless_null $P3881, vivify_1910
    die "Contextual $*SCOPE not found"
  vivify_1910:
  vivify_1909:
    set $S3882, $P3881
    iseq $I3883, $S3882, ""
    new $P3876, 'Integer'
    set $P3876, $I3883
  unless_3877_end:
    unless $P3876, if_3875_end
.annotate 'line', 1228
    find_lex $P3884, "$past"
    unless_null $P3884, vivify_1911
    new $P3884, "Undef"
  vivify_1911:
    find_lex $P3885, "$/"
    unless_null $P3885, vivify_1912
    $P3885 = root_new ['parrot';'Hash']
  vivify_1912:
    set $P3886, $P3885["name"]
    unless_null $P3886, vivify_1913
    $P3886 = root_new ['parrot';'Hash']
  vivify_1913:
    set $P3887, $P3886["identifier"]
    unless_null $P3887, vivify_1914
    new $P3887, "Undef"
  vivify_1914:
    $P3884."namespace"($P3887)
  if_3875_end:
.annotate 'line', 1232
    find_dynamic_lex $P3888, "$*PACKAGE-SETUP"
    unless_null $P3888, vivify_1915
    get_hll_global $P3888, "$PACKAGE-SETUP"
    unless_null $P3888, vivify_1916
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1916:
  vivify_1915:
    get_hll_global $P3889, ["PAST"], "Stmts"
.annotate 'line', 1233
    get_hll_global $P3890, ["PAST"], "Op"
.annotate 'line', 1234
    get_hll_global $P3891, ["PAST"], "Var"
    $P3892 = $P3891."new"("type_obj" :named("name"), "register" :named("scope"), 1 :named("isdecl"))
.annotate 'line', 1235
    find_dynamic_lex $P3893, "$*SC"
    unless_null $P3893, vivify_1917
    get_hll_global $P3893, "$SC"
    unless_null $P3893, vivify_1918
    die "Contextual $*SC not found"
  vivify_1918:
  vivify_1917:
    find_dynamic_lex $P3894, "$*PACKAGE"
    unless_null $P3894, vivify_1919
    get_hll_global $P3894, "$PACKAGE"
    unless_null $P3894, vivify_1920
    die "Contextual $*PACKAGE not found"
  vivify_1920:
  vivify_1919:
    $P3895 = $P3893."get_slot_past_for_object"($P3894)
    $P3896 = $P3890."new"($P3892, $P3895, "bind" :named("pasttype"))
.annotate 'line', 1233
    $P3897 = $P3889."new"($P3896)
.annotate 'line', 1232
    $P3888."unshift"($P3897)
.annotate 'line', 1244
    find_lex $P3901, "$how"
    unless_null $P3901, vivify_1921
    new $P3901, "Undef"
  vivify_1921:
    can $I3902, $P3901, "parametric"
    if $I3902, if_3900
    new $P3899, 'Integer'
    set $P3899, $I3902
    goto if_3900_end
  if_3900:
    find_lex $P3903, "$how"
    unless_null $P3903, vivify_1922
    new $P3903, "Undef"
  vivify_1922:
    find_lex $P3904, "$how"
    unless_null $P3904, vivify_1923
    new $P3904, "Undef"
  vivify_1923:
    $P3905 = $P3903."parametric"($P3904)
    set $P3899, $P3905
  if_3900_end:
    if $P3899, if_3898
.annotate 'line', 1262
    find_lex $P3929, "$past"
    unless_null $P3929, vivify_1924
    new $P3929, "Undef"
  vivify_1924:
    $P3929."blocktype"("immediate")
.annotate 'line', 1263
    find_dynamic_lex $P3930, "$*SC"
    unless_null $P3930, vivify_1925
    get_hll_global $P3930, "$SC"
    unless_null $P3930, vivify_1926
    die "Contextual $*SC not found"
  vivify_1926:
  vivify_1925:
    find_lex $P3931, "$past"
    unless_null $P3931, vivify_1927
    new $P3931, "Undef"
  vivify_1927:
    find_dynamic_lex $P3932, "$*PACKAGE"
    unless_null $P3932, vivify_1928
    get_hll_global $P3932, "$PACKAGE"
    unless_null $P3932, vivify_1929
    die "Contextual $*PACKAGE not found"
  vivify_1929:
  vivify_1928:
    $P3930."install_lexical_symbol"($P3931, "$?PACKAGE", $P3932)
.annotate 'line', 1264
    find_dynamic_lex $P3933, "$*SC"
    unless_null $P3933, vivify_1930
    get_hll_global $P3933, "$SC"
    unless_null $P3933, vivify_1931
    die "Contextual $*SC not found"
  vivify_1931:
  vivify_1930:
    find_lex $P3934, "$past"
    unless_null $P3934, vivify_1932
    new $P3934, "Undef"
  vivify_1932:
    find_dynamic_lex $P3935, "$*PACKAGE"
    unless_null $P3935, vivify_1933
    get_hll_global $P3935, "$PACKAGE"
    unless_null $P3935, vivify_1934
    die "Contextual $*PACKAGE not found"
  vivify_1934:
  vivify_1933:
    $P3933."install_lexical_symbol"($P3934, "$?CLASS", $P3935)
.annotate 'line', 1261
    goto if_3898_end
  if_3898:
.annotate 'line', 1245
    find_lex $P3906, "$past"
    unless_null $P3906, vivify_1935
    new $P3906, "Undef"
  vivify_1935:
    $P3906."blocktype"("declaration")
.annotate 'line', 1246
    find_lex $P3907, "$past"
    unless_null $P3907, vivify_1936
    new $P3907, "Undef"
  vivify_1936:
    get_hll_global $P3908, ["PAST"], "Var"
    $P3909 = $P3908."new"("$?CLASS" :named("name"), "parameter" :named("scope"))
    $P3907."unshift"($P3909)
.annotate 'line', 1247
    find_lex $P3910, "$past"
    unless_null $P3910, vivify_1937
    new $P3910, "Undef"
  vivify_1937:
    $P3910."symbol"("$?CLASS", "lexical" :named("scope"))
.annotate 'line', 1248
    find_dynamic_lex $P3911, "$*PACKAGE-SETUP"
    unless_null $P3911, vivify_1938
    get_hll_global $P3911, "$PACKAGE-SETUP"
    unless_null $P3911, vivify_1939
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1939:
  vivify_1938:
    get_hll_global $P3912, ["PAST"], "Op"
.annotate 'line', 1250
    get_hll_global $P3913, ["PAST"], "Op"
.annotate 'line', 1253
    get_hll_global $P3914, ["PAST"], "Var"
    $P3915 = $P3914."new"("type_obj" :named("name"), "register" :named("scope"))
    $P3916 = $P3913."new"($P3915, "get_how PP" :named("pirop"))
.annotate 'line', 1255
    get_hll_global $P3917, ["PAST"], "Var"
    $P3918 = $P3917."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1256
    get_hll_global $P3919, ["PAST"], "Val"
    find_lex $P3920, "$past"
    unless_null $P3920, vivify_1940
    new $P3920, "Undef"
  vivify_1940:
    $P3921 = $P3919."new"($P3920 :named("value"))
    $P3922 = $P3912."new"($P3916, $P3918, $P3921, "callmethod" :named("pasttype"), "set_body_block" :named("name"))
.annotate 'line', 1248
    $P3911."push"($P3922)
.annotate 'line', 1258
    find_dynamic_lex $P3923, "$*SC"
    unless_null $P3923, vivify_1941
    get_hll_global $P3923, "$SC"
    unless_null $P3923, vivify_1942
    die "Contextual $*SC not found"
  vivify_1942:
  vivify_1941:
    find_lex $P3924, "$past"
    unless_null $P3924, vivify_1943
    new $P3924, "Undef"
  vivify_1943:
    find_dynamic_lex $P3925, "$*PACKAGE"
    unless_null $P3925, vivify_1944
    get_hll_global $P3925, "$PACKAGE"
    unless_null $P3925, vivify_1945
    die "Contextual $*PACKAGE not found"
  vivify_1945:
  vivify_1944:
    $P3923."install_lexical_symbol"($P3924, "$?PACKAGE", $P3925)
.annotate 'line', 1259
    find_dynamic_lex $P3926, "$*SC"
    unless_null $P3926, vivify_1946
    get_hll_global $P3926, "$SC"
    unless_null $P3926, vivify_1947
    die "Contextual $*SC not found"
  vivify_1947:
  vivify_1946:
    find_lex $P3927, "$past"
    unless_null $P3927, vivify_1948
    new $P3927, "Undef"
  vivify_1948:
    find_dynamic_lex $P3928, "$*PACKAGE"
    unless_null $P3928, vivify_1949
    get_hll_global $P3928, "$PACKAGE"
    unless_null $P3928, vivify_1950
    die "Contextual $*PACKAGE not found"
  vivify_1950:
  vivify_1949:
    $P3926."install_lexical_symbol"($P3927, "$?ROLE", $P3928)
  if_3898_end:
.annotate 'line', 1269
    find_lex $P3937, "$/"
    unless_null $P3937, vivify_1951
    $P3937 = root_new ['parrot';'Hash']
  vivify_1951:
    set $P3938, $P3937["parent"]
    unless_null $P3938, vivify_1952
    new $P3938, "Undef"
  vivify_1952:
    if $P3938, if_3936
.annotate 'line', 1283
    find_lex $P3968, "$how"
    unless_null $P3968, vivify_1953
    new $P3968, "Undef"
  vivify_1953:
    can $I3969, $P3968, "set_default_parent"
    unless $I3969, if_3967_end
.annotate 'line', 1285
    find_dynamic_lex $P3970, "$*PACKAGE-SETUP"
    unless_null $P3970, vivify_1954
    get_hll_global $P3970, "$PACKAGE-SETUP"
    unless_null $P3970, vivify_1955
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1955:
  vivify_1954:
    get_hll_global $P3971, ["PAST"], "Op"
.annotate 'line', 1287
    get_hll_global $P3972, ["PAST"], "Op"
.annotate 'line', 1290
    get_hll_global $P3973, ["PAST"], "Var"
    $P3974 = $P3973."new"("type_obj" :named("name"), "register" :named("scope"))
    $P3975 = $P3972."new"($P3974, "get_how PP" :named("pirop"))
.annotate 'line', 1292
    get_hll_global $P3976, ["PAST"], "Var"
    $P3977 = $P3976."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1293
    find_dynamic_lex $P3980, "$*PKGDECL"
    unless_null $P3980, vivify_1956
    get_hll_global $P3980, "$PKGDECL"
    unless_null $P3980, vivify_1957
    die "Contextual $*PKGDECL not found"
  vivify_1957:
  vivify_1956:
    set $S3981, $P3980
    iseq $I3982, $S3981, "grammar"
    if $I3982, if_3979
.annotate 'line', 1295
    get_hll_global $P3985, ["PAST"], "Var"
    new $P3986, "ResizablePMCArray"
    $P3987 = $P3985."new"("NQPMu" :named("name"), $P3986 :named("namespace"), "package" :named("scope"))
    set $P3978, $P3987
.annotate 'line', 1293
    goto if_3979_end
  if_3979:
.annotate 'line', 1294
    get_hll_global $P3983, ["PAST"], "Var"
    $P3984 = $P3983."new"("Cursor" :named("name"), "Regex" :named("namespace"), "package" :named("scope"))
    set $P3978, $P3984
  if_3979_end:
.annotate 'line', 1293
    $P3988 = $P3971."new"($P3975, $P3977, $P3978, "callmethod" :named("pasttype"), "set_default_parent" :named("name"))
.annotate 'line', 1285
    $P3970."push"($P3988)
  if_3967_end:
.annotate 'line', 1283
    goto if_3936_end
  if_3936:
.annotate 'line', 1269
    .const 'Sub' $P3940 = "477_1303401201.841" 
    capture_lex $P3940
    $P3940()
  if_3936_end:
.annotate 'line', 1300
    find_lex $P3990, "$/"
    unless_null $P3990, vivify_1967
    $P3990 = root_new ['parrot';'Hash']
  vivify_1967:
    set $P3991, $P3990["role"]
    unless_null $P3991, vivify_1968
    new $P3991, "Undef"
  vivify_1968:
    unless $P3991, if_3989_end
.annotate 'line', 1301
    find_lex $P3993, "$/"
    unless_null $P3993, vivify_1969
    $P3993 = root_new ['parrot';'Hash']
  vivify_1969:
    set $P3994, $P3993["role"]
    unless_null $P3994, vivify_1970
    new $P3994, "Undef"
  vivify_1970:
    defined $I3995, $P3994
    unless $I3995, for_undef_1971
    iter $P3992, $P3994
    new $P4025, 'ExceptionHandler'
    set_label $P4025, loop4024_handler
    $P4025."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4025
  loop4024_test:
    unless $P3992, loop4024_done
    shift $P3996, $P3992
  loop4024_redo:
    .const 'Sub' $P3998 = "478_1303401201.841" 
    capture_lex $P3998
    $P3998($P3996)
  loop4024_next:
    goto loop4024_test
  loop4024_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4026, exception, 'type'
    eq $P4026, .CONTROL_LOOP_NEXT, loop4024_next
    eq $P4026, .CONTROL_LOOP_REDO, loop4024_redo
  loop4024_done:
    pop_eh 
  for_undef_1971:
  if_3989_end:
.annotate 'line', 1318
    find_dynamic_lex $P4027, "$*PACKAGE-SETUP"
    unless_null $P4027, vivify_1979
    get_hll_global $P4027, "$PACKAGE-SETUP"
    unless_null $P4027, vivify_1980
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1980:
  vivify_1979:
    get_hll_global $P4028, ["PAST"], "Op"
.annotate 'line', 1320
    get_hll_global $P4029, ["PAST"], "Op"
.annotate 'line', 1323
    get_hll_global $P4030, ["PAST"], "Var"
    $P4031 = $P4030."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4032 = $P4029."new"($P4031, "get_how PP" :named("pirop"))
.annotate 'line', 1325
    get_hll_global $P4033, ["PAST"], "Var"
    $P4034 = $P4033."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4035 = $P4028."new"($P4032, $P4034, "callmethod" :named("pasttype"), "compose" :named("name"))
.annotate 'line', 1318
    $P4027."push"($P4035)
.annotate 'line', 1329
    find_lex $P4036, "$past"
    unless_null $P4036, vivify_1981
    new $P4036, "Undef"
  vivify_1981:
    $P4037 = $P4036."loadinit"()
    get_hll_global $P4038, ["PAST"], "Block"
    find_dynamic_lex $P4039, "$*PACKAGE-SETUP"
    unless_null $P4039, vivify_1982
    get_hll_global $P4039, "$PACKAGE-SETUP"
    unless_null $P4039, vivify_1983
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1983:
  vivify_1982:
    $P4040 = $P4038."new"($P4039, "immediate" :named("blocktype"))
    $P4037."push"($P4040)
.annotate 'line', 1331
    find_lex $P4041, "$/"
    find_lex $P4042, "$past"
    unless_null $P4042, vivify_1984
    new $P4042, "Undef"
  vivify_1984:
    $P4043 = $P4041."!make"($P4042)
.annotate 'line', 1219
    .return ($P4043)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3939"  :anon :subid("477_1303401201.841") :outer("476_1303401201.841")
.annotate 'line', 1270
    $P3941 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P3941
.annotate 'line', 1271
    new $P3942, "Undef"
    .lex "$name", $P3942
.annotate 'line', 1270
    find_lex $P3943, "$/"
    unless_null $P3943, vivify_1958
    $P3943 = root_new ['parrot';'Hash']
  vivify_1958:
    set $P3944, $P3943["parent"]
    unless_null $P3944, vivify_1959
    $P3944 = root_new ['parrot';'ResizablePMCArray']
  vivify_1959:
    set $P3945, $P3944[0]
    unless_null $P3945, vivify_1960
    $P3945 = root_new ['parrot';'Hash']
  vivify_1960:
    set $P3946, $P3945["identifier"]
    unless_null $P3946, vivify_1961
    new $P3946, "Undef"
  vivify_1961:
    clone $P3947, $P3946
    store_lex "@ns", $P3947
.annotate 'line', 1271
    find_lex $P3948, "@ns"
    unless_null $P3948, vivify_1962
    $P3948 = root_new ['parrot';'ResizablePMCArray']
  vivify_1962:
    $P3949 = $P3948."pop"()
    set $S3950, $P3949
    new $P3951, 'String'
    set $P3951, $S3950
    store_lex "$name", $P3951
.annotate 'line', 1272
    find_dynamic_lex $P3952, "$*PACKAGE-SETUP"
    unless_null $P3952, vivify_1963
    get_hll_global $P3952, "$PACKAGE-SETUP"
    unless_null $P3952, vivify_1964
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1964:
  vivify_1963:
    get_hll_global $P3953, ["PAST"], "Op"
.annotate 'line', 1274
    get_hll_global $P3954, ["PAST"], "Op"
.annotate 'line', 1277
    get_hll_global $P3955, ["PAST"], "Var"
    $P3956 = $P3955."new"("type_obj" :named("name"), "register" :named("scope"))
    $P3957 = $P3954."new"($P3956, "get_how PP" :named("pirop"))
.annotate 'line', 1279
    get_hll_global $P3958, ["PAST"], "Var"
    $P3959 = $P3958."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1280
    get_hll_global $P3960, ["PAST"], "Var"
    find_lex $P3961, "$name"
    unless_null $P3961, vivify_1965
    new $P3961, "Undef"
  vivify_1965:
    set $S3962, $P3961
    find_lex $P3963, "@ns"
    unless_null $P3963, vivify_1966
    $P3963 = root_new ['parrot';'ResizablePMCArray']
  vivify_1966:
    $P3964 = $P3960."new"($S3962 :named("name"), $P3963 :named("namespace"), "package" :named("scope"))
    $P3965 = $P3953."new"($P3957, $P3959, $P3964, "callmethod" :named("pasttype"), "add_parent" :named("name"))
.annotate 'line', 1272
    $P3966 = $P3952."push"($P3965)
.annotate 'line', 1269
    .return ($P3966)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3997"  :anon :subid("478_1303401201.841") :outer("476_1303401201.841")
    .param pmc param_4001
.annotate 'line', 1302
    $P3999 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P3999
.annotate 'line', 1303
    new $P4000, "Undef"
    .lex "$name", $P4000
    .lex "$_", param_4001
.annotate 'line', 1302
    find_lex $P4002, "$_"
    unless_null $P4002, vivify_1972
    $P4002 = root_new ['parrot';'Hash']
  vivify_1972:
    set $P4003, $P4002["identifier"]
    unless_null $P4003, vivify_1973
    new $P4003, "Undef"
  vivify_1973:
    clone $P4004, $P4003
    store_lex "@ns", $P4004
.annotate 'line', 1303
    find_lex $P4005, "@ns"
    unless_null $P4005, vivify_1974
    $P4005 = root_new ['parrot';'ResizablePMCArray']
  vivify_1974:
    $P4006 = $P4005."pop"()
    set $S4007, $P4006
    new $P4008, 'String'
    set $P4008, $S4007
    store_lex "$name", $P4008
.annotate 'line', 1304
    find_dynamic_lex $P4009, "$*PACKAGE-SETUP"
    unless_null $P4009, vivify_1975
    get_hll_global $P4009, "$PACKAGE-SETUP"
    unless_null $P4009, vivify_1976
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1976:
  vivify_1975:
    get_hll_global $P4010, ["PAST"], "Op"
.annotate 'line', 1306
    get_hll_global $P4011, ["PAST"], "Op"
.annotate 'line', 1309
    get_hll_global $P4012, ["PAST"], "Var"
    $P4013 = $P4012."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4014 = $P4011."new"($P4013, "get_how PP" :named("pirop"))
.annotate 'line', 1311
    get_hll_global $P4015, ["PAST"], "Var"
    $P4016 = $P4015."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1312
    get_hll_global $P4017, ["PAST"], "Var"
    find_lex $P4018, "$name"
    unless_null $P4018, vivify_1977
    new $P4018, "Undef"
  vivify_1977:
    set $S4019, $P4018
    find_lex $P4020, "@ns"
    unless_null $P4020, vivify_1978
    $P4020 = root_new ['parrot';'ResizablePMCArray']
  vivify_1978:
    $P4021 = $P4017."new"($S4019 :named("name"), $P4020 :named("namespace"), "package" :named("scope"))
    $P4022 = $P4010."new"($P4014, $P4016, $P4021, "callmethod" :named("pasttype"), "add_role" :named("name"))
.annotate 'line', 1304
    $P4023 = $P4009."push"($P4022)
.annotate 'line', 1301
    .return ($P4023)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<my>"  :subid("479_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_4045
    .param pmc param_4046
.annotate 'line', 1334
    .lex "self", param_4045
    .lex "$/", param_4046
    find_lex $P4047, "$/"
    find_lex $P4048, "$/"
    unless_null $P4048, vivify_1985
    $P4048 = root_new ['parrot';'Hash']
  vivify_1985:
    set $P4049, $P4048["scoped"]
    unless_null $P4049, vivify_1986
    new $P4049, "Undef"
  vivify_1986:
    $P4050 = $P4049."ast"()
    $P4051 = $P4047."!make"($P4050)
    .return ($P4051)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<our>"  :subid("480_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_4053
    .param pmc param_4054
.annotate 'line', 1335
    .lex "self", param_4053
    .lex "$/", param_4054
    find_lex $P4055, "$/"
    find_lex $P4056, "$/"
    unless_null $P4056, vivify_1987
    $P4056 = root_new ['parrot';'Hash']
  vivify_1987:
    set $P4057, $P4056["scoped"]
    unless_null $P4057, vivify_1988
    new $P4057, "Undef"
  vivify_1988:
    $P4058 = $P4057."ast"()
    $P4059 = $P4055."!make"($P4058)
    .return ($P4059)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<has>"  :subid("481_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_4061
    .param pmc param_4062
.annotate 'line', 1336
    .lex "self", param_4061
    .lex "$/", param_4062
    find_lex $P4063, "$/"
    find_lex $P4064, "$/"
    unless_null $P4064, vivify_1989
    $P4064 = root_new ['parrot';'Hash']
  vivify_1989:
    set $P4065, $P4064["scoped"]
    unless_null $P4065, vivify_1990
    new $P4065, "Undef"
  vivify_1990:
    $P4066 = $P4065."ast"()
    $P4067 = $P4063."!make"($P4066)
    .return ($P4067)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scoped"  :subid("482_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_4069
    .param pmc param_4070
.annotate 'line', 1338
    .lex "self", param_4069
    .lex "$/", param_4070
.annotate 'line', 1339
    find_lex $P4071, "$/"
    find_lex $P4074, "$/"
    unless_null $P4074, vivify_1991
    $P4074 = root_new ['parrot';'Hash']
  vivify_1991:
    set $P4075, $P4074["declarator"]
    unless_null $P4075, vivify_1992
    new $P4075, "Undef"
  vivify_1992:
    if $P4075, if_4073
.annotate 'line', 1340
    find_lex $P4081, "$/"
    unless_null $P4081, vivify_1993
    $P4081 = root_new ['parrot';'Hash']
  vivify_1993:
    set $P4082, $P4081["multi_declarator"]
    unless_null $P4082, vivify_1994
    new $P4082, "Undef"
  vivify_1994:
    if $P4082, if_4080
.annotate 'line', 1341
    find_lex $P4086, "$/"
    unless_null $P4086, vivify_1995
    $P4086 = root_new ['parrot';'Hash']
  vivify_1995:
    set $P4087, $P4086["package_declarator"]
    unless_null $P4087, vivify_1996
    new $P4087, "Undef"
  vivify_1996:
    $P4088 = $P4087."ast"()
    set $P4079, $P4088
.annotate 'line', 1340
    goto if_4080_end
  if_4080:
    find_lex $P4083, "$/"
    unless_null $P4083, vivify_1997
    $P4083 = root_new ['parrot';'Hash']
  vivify_1997:
    set $P4084, $P4083["multi_declarator"]
    unless_null $P4084, vivify_1998
    new $P4084, "Undef"
  vivify_1998:
    $P4085 = $P4084."ast"()
    set $P4079, $P4085
  if_4080_end:
    set $P4072, $P4079
.annotate 'line', 1339
    goto if_4073_end
  if_4073:
    find_lex $P4076, "$/"
    unless_null $P4076, vivify_1999
    $P4076 = root_new ['parrot';'Hash']
  vivify_1999:
    set $P4077, $P4076["declarator"]
    unless_null $P4077, vivify_2000
    new $P4077, "Undef"
  vivify_2000:
    $P4078 = $P4077."ast"()
    set $P4072, $P4078
  if_4073_end:
    $P4089 = $P4071."!make"($P4072)
.annotate 'line', 1338
    .return ($P4089)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "declarator"  :subid("483_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_4091
    .param pmc param_4092
.annotate 'line', 1344
    .lex "self", param_4091
    .lex "$/", param_4092
.annotate 'line', 1345
    find_lex $P4093, "$/"
.annotate 'line', 1346
    find_lex $P4096, "$/"
    unless_null $P4096, vivify_2001
    $P4096 = root_new ['parrot';'Hash']
  vivify_2001:
    set $P4097, $P4096["routine_declarator"]
    unless_null $P4097, vivify_2002
    new $P4097, "Undef"
  vivify_2002:
    if $P4097, if_4095
.annotate 'line', 1347
    find_lex $P4101, "$/"
    unless_null $P4101, vivify_2003
    $P4101 = root_new ['parrot';'Hash']
  vivify_2003:
    set $P4102, $P4101["variable_declarator"]
    unless_null $P4102, vivify_2004
    new $P4102, "Undef"
  vivify_2004:
    $P4103 = $P4102."ast"()
    set $P4094, $P4103
.annotate 'line', 1346
    goto if_4095_end
  if_4095:
    find_lex $P4098, "$/"
    unless_null $P4098, vivify_2005
    $P4098 = root_new ['parrot';'Hash']
  vivify_2005:
    set $P4099, $P4098["routine_declarator"]
    unless_null $P4099, vivify_2006
    new $P4099, "Undef"
  vivify_2006:
    $P4100 = $P4099."ast"()
    set $P4094, $P4100
  if_4095_end:
    $P4104 = $P4093."!make"($P4094)
.annotate 'line', 1344
    .return ($P4104)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<multi>"  :subid("484_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_4106
    .param pmc param_4107
.annotate 'line', 1350
    .lex "self", param_4106
    .lex "$/", param_4107
    find_lex $P4108, "$/"
    find_lex $P4111, "$/"
    unless_null $P4111, vivify_2007
    $P4111 = root_new ['parrot';'Hash']
  vivify_2007:
    set $P4112, $P4111["declarator"]
    unless_null $P4112, vivify_2008
    new $P4112, "Undef"
  vivify_2008:
    if $P4112, if_4110
    find_lex $P4116, "$/"
    unless_null $P4116, vivify_2009
    $P4116 = root_new ['parrot';'Hash']
  vivify_2009:
    set $P4117, $P4116["routine_def"]
    unless_null $P4117, vivify_2010
    new $P4117, "Undef"
  vivify_2010:
    $P4118 = $P4117."ast"()
    set $P4109, $P4118
    goto if_4110_end
  if_4110:
    find_lex $P4113, "$/"
    unless_null $P4113, vivify_2011
    $P4113 = root_new ['parrot';'Hash']
  vivify_2011:
    set $P4114, $P4113["declarator"]
    unless_null $P4114, vivify_2012
    new $P4114, "Undef"
  vivify_2012:
    $P4115 = $P4114."ast"()
    set $P4109, $P4115
  if_4110_end:
    $P4119 = $P4108."!make"($P4109)
    .return ($P4119)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<proto>"  :subid("485_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_4121
    .param pmc param_4122
.annotate 'line', 1351
    .lex "self", param_4121
    .lex "$/", param_4122
    find_lex $P4123, "$/"
    find_lex $P4126, "$/"
    unless_null $P4126, vivify_2013
    $P4126 = root_new ['parrot';'Hash']
  vivify_2013:
    set $P4127, $P4126["declarator"]
    unless_null $P4127, vivify_2014
    new $P4127, "Undef"
  vivify_2014:
    if $P4127, if_4125
    find_lex $P4131, "$/"
    unless_null $P4131, vivify_2015
    $P4131 = root_new ['parrot';'Hash']
  vivify_2015:
    set $P4132, $P4131["routine_def"]
    unless_null $P4132, vivify_2016
    new $P4132, "Undef"
  vivify_2016:
    $P4133 = $P4132."ast"()
    set $P4124, $P4133
    goto if_4125_end
  if_4125:
    find_lex $P4128, "$/"
    unless_null $P4128, vivify_2017
    $P4128 = root_new ['parrot';'Hash']
  vivify_2017:
    set $P4129, $P4128["declarator"]
    unless_null $P4129, vivify_2018
    new $P4129, "Undef"
  vivify_2018:
    $P4130 = $P4129."ast"()
    set $P4124, $P4130
  if_4125_end:
    $P4134 = $P4123."!make"($P4124)
    .return ($P4134)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<null>"  :subid("486_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_4136
    .param pmc param_4137
.annotate 'line', 1352
    .lex "self", param_4136
    .lex "$/", param_4137
    find_lex $P4138, "$/"
    find_lex $P4139, "$/"
    unless_null $P4139, vivify_2019
    $P4139 = root_new ['parrot';'Hash']
  vivify_2019:
    set $P4140, $P4139["declarator"]
    unless_null $P4140, vivify_2020
    new $P4140, "Undef"
  vivify_2020:
    $P4141 = $P4140."ast"()
    $P4142 = $P4138."!make"($P4141)
    .return ($P4142)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "variable_declarator"  :subid("487_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_4144
    .param pmc param_4145
.annotate 'line', 1355
    .const 'Sub' $P4177 = "488_1303401201.841" 
    capture_lex $P4177
    .lex "self", param_4144
    .lex "$/", param_4145
.annotate 'line', 1356
    new $P4146, "Undef"
    .lex "$past", $P4146
.annotate 'line', 1357
    new $P4147, "Undef"
    .lex "$sigil", $P4147
.annotate 'line', 1358
    new $P4148, "Undef"
    .lex "$name", $P4148
.annotate 'line', 1359
    new $P4149, "Undef"
    .lex "$BLOCK", $P4149
.annotate 'line', 1356
    find_lex $P4150, "$/"
    unless_null $P4150, vivify_2021
    $P4150 = root_new ['parrot';'Hash']
  vivify_2021:
    set $P4151, $P4150["variable"]
    unless_null $P4151, vivify_2022
    new $P4151, "Undef"
  vivify_2022:
    $P4152 = $P4151."ast"()
    store_lex "$past", $P4152
.annotate 'line', 1357
    find_lex $P4153, "$/"
    unless_null $P4153, vivify_2023
    $P4153 = root_new ['parrot';'Hash']
  vivify_2023:
    set $P4154, $P4153["variable"]
    unless_null $P4154, vivify_2024
    $P4154 = root_new ['parrot';'Hash']
  vivify_2024:
    set $P4155, $P4154["sigil"]
    unless_null $P4155, vivify_2025
    new $P4155, "Undef"
  vivify_2025:
    store_lex "$sigil", $P4155
.annotate 'line', 1358
    find_lex $P4156, "$past"
    unless_null $P4156, vivify_2026
    new $P4156, "Undef"
  vivify_2026:
    $P4157 = $P4156."name"()
    store_lex "$name", $P4157
.annotate 'line', 1359
    find_lex $P4158, "$?PACKAGE"
    get_who $P4159, $P4158
    set $P4160, $P4159["@BLOCK"]
    unless_null $P4160, vivify_2027
    $P4160 = root_new ['parrot';'ResizablePMCArray']
  vivify_2027:
    set $P4161, $P4160[0]
    unless_null $P4161, vivify_2028
    new $P4161, "Undef"
  vivify_2028:
    store_lex "$BLOCK", $P4161
.annotate 'line', 1360
    find_lex $P4165, "$name"
    unless_null $P4165, vivify_2029
    new $P4165, "Undef"
  vivify_2029:
    if $P4165, if_4164
    set $P4163, $P4165
    goto if_4164_end
  if_4164:
    find_lex $P4166, "$BLOCK"
    unless_null $P4166, vivify_2030
    new $P4166, "Undef"
  vivify_2030:
    find_lex $P4167, "$name"
    unless_null $P4167, vivify_2031
    new $P4167, "Undef"
  vivify_2031:
    $P4168 = $P4166."symbol"($P4167)
    set $P4163, $P4168
  if_4164_end:
    unless $P4163, if_4162_end
.annotate 'line', 1361
    find_lex $P4169, "$/"
    unless_null $P4169, vivify_2032
    new $P4169, "Undef"
  vivify_2032:
    $P4170 = $P4169."CURSOR"()
    find_lex $P4171, "$name"
    unless_null $P4171, vivify_2033
    new $P4171, "Undef"
  vivify_2033:
    $P4170."panic"("Redeclaration of symbol ", $P4171)
  if_4162_end:
.annotate 'line', 1363
    find_dynamic_lex $P4173, "$*SCOPE"
    unless_null $P4173, vivify_2034
    get_hll_global $P4173, "$SCOPE"
    unless_null $P4173, vivify_2035
    die "Contextual $*SCOPE not found"
  vivify_2035:
  vivify_2034:
    set $S4174, $P4173
    iseq $I4175, $S4174, "has"
    if $I4175, if_4172
.annotate 'line', 1388
    find_dynamic_lex $P4222, "$*SCOPE"
    unless_null $P4222, vivify_2036
    get_hll_global $P4222, "$SCOPE"
    unless_null $P4222, vivify_2037
    die "Contextual $*SCOPE not found"
  vivify_2037:
  vivify_2036:
    set $S4223, $P4222
    iseq $I4224, $S4223, "our"
    if $I4224, if_4221
.annotate 'line', 1398
    find_lex $P4238, "$BLOCK"
    unless_null $P4238, vivify_2038
    $P4238 = root_new ['parrot';'ResizablePMCArray']
  vivify_2038:
    set $P4239, $P4238[0]
    unless_null $P4239, vivify_2039
    new $P4239, "Undef"
  vivify_2039:
    get_hll_global $P4240, ["PAST"], "Var"
    find_lex $P4241, "$name"
    unless_null $P4241, vivify_2040
    new $P4241, "Undef"
  vivify_2040:
.annotate 'line', 1400
    find_lex $P4242, "$sigil"
    unless_null $P4242, vivify_2041
    new $P4242, "Undef"
  vivify_2041:
    $P4243 = "vivitype"($P4242)
    find_lex $P4244, "$/"
    unless_null $P4244, vivify_2042
    new $P4244, "Undef"
  vivify_2042:
    $P4245 = $P4240."new"($P4241 :named("name"), "lexical" :named("scope"), 1 :named("isdecl"), 1 :named("lvalue"), $P4243 :named("viviself"), $P4244 :named("node"))
.annotate 'line', 1398
    $P4239."push"($P4245)
.annotate 'line', 1403
    find_lex $P4246, "$BLOCK"
    unless_null $P4246, vivify_2043
    new $P4246, "Undef"
  vivify_2043:
    find_lex $P4247, "$name"
    unless_null $P4247, vivify_2044
    new $P4247, "Undef"
  vivify_2044:
    $P4246."symbol"($P4247, "lexical" :named("scope"))
.annotate 'line', 1397
    goto if_4221_end
  if_4221:
.annotate 'line', 1392
    find_lex $P4225, "$/"
    unless_null $P4225, vivify_2045
    $P4225 = root_new ['parrot';'Hash']
  vivify_2045:
    set $P4226, $P4225["variable"]
    unless_null $P4226, vivify_2046
    new $P4226, "Undef"
  vivify_2046:
    set $S4227, $P4226
    new $P4228, 'String'
    set $P4228, $S4227
    store_lex "$name", $P4228
.annotate 'line', 1393
    find_lex $P4229, "$name"
    unless_null $P4229, vivify_2047
    new $P4229, "Undef"
  vivify_2047:
    new $P4230, "ResizablePMCArray"
    push $P4230, $P4229
    find_lex $P4231, "$/"
    unless_null $P4231, vivify_2048
    new $P4231, "Undef"
  vivify_2048:
    $P4232 = "lexical_package_lookup"($P4230, $P4231)
    store_lex "$past", $P4232
.annotate 'line', 1394
    find_lex $P4233, "$past"
    unless_null $P4233, vivify_2049
    new $P4233, "Undef"
  vivify_2049:
    find_lex $P4234, "$sigil"
    unless_null $P4234, vivify_2050
    new $P4234, "Undef"
  vivify_2050:
    $P4235 = "vivitype"($P4234)
    $P4233."viviself"($P4235)
.annotate 'line', 1395
    find_lex $P4236, "$BLOCK"
    unless_null $P4236, vivify_2051
    new $P4236, "Undef"
  vivify_2051:
    find_lex $P4237, "$name"
    unless_null $P4237, vivify_2052
    new $P4237, "Undef"
  vivify_2052:
    $P4236."symbol"($P4237, "package" :named("scope"))
  if_4221_end:
.annotate 'line', 1388
    goto if_4172_end
  if_4172:
.annotate 'line', 1363
    .const 'Sub' $P4177 = "488_1303401201.841" 
    capture_lex $P4177
    $P4177()
  if_4172_end:
.annotate 'line', 1405
    find_lex $P4248, "$/"
    find_lex $P4249, "$past"
    unless_null $P4249, vivify_2074
    new $P4249, "Undef"
  vivify_2074:
    $P4250 = $P4248."!make"($P4249)
.annotate 'line', 1355
    .return ($P4250)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4176"  :anon :subid("488_1303401201.841") :outer("487_1303401201.841")
.annotate 'line', 1363
    .const 'Sub' $P4207 = "489_1303401201.841" 
    capture_lex $P4207
.annotate 'line', 1365
    new $P4178, "Undef"
    .lex "$meta-attr-type", $P4178
.annotate 'line', 1373
    new $P4179, "Undef"
    .lex "$meta_args", $P4179
.annotate 'line', 1365
    find_dynamic_lex $P4182, "$*PKGDECL"
    unless_null $P4182, vivify_2053
    get_hll_global $P4182, "$PKGDECL"
    unless_null $P4182, vivify_2054
    die "Contextual $*PKGDECL not found"
  vivify_2054:
  vivify_2053:
    find_dynamic_lex $P4183, "%*HOW-METAATTR"
    unless_null $P4183, vivify_2055
    get_hll_global $P4183, "%HOW-METAATTR"
    unless_null $P4183, vivify_2056
    die "Contextual %*HOW-METAATTR not found"
  vivify_2056:
  vivify_2055:
    set $P4184, $P4183[$P4182]
    unless_null $P4184, vivify_2057
    new $P4184, "Undef"
  vivify_2057:
    unless $P4184, unless_4181
    set $P4180, $P4184
    goto unless_4181_end
  unless_4181:
    find_dynamic_lex $P4185, "$*DEFAULT-METAATTR"
    unless_null $P4185, vivify_2058
    get_hll_global $P4185, "$DEFAULT-METAATTR"
    unless_null $P4185, vivify_2059
    die "Contextual $*DEFAULT-METAATTR not found"
  vivify_2059:
  vivify_2058:
    set $P4180, $P4185
  unless_4181_end:
    store_lex "$meta-attr-type", $P4180
.annotate 'line', 1366
    find_dynamic_lex $P4186, "$*PACKAGE-SETUP"
    unless_null $P4186, vivify_2060
    get_hll_global $P4186, "$PACKAGE-SETUP"
    unless_null $P4186, vivify_2061
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2061:
  vivify_2060:
    get_hll_global $P4187, ["PAST"], "Op"
.annotate 'line', 1368
    get_hll_global $P4188, ["PAST"], "Op"
.annotate 'line', 1370
    get_hll_global $P4189, ["PAST"], "Var"
    $P4190 = $P4189."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4191 = $P4188."new"($P4190, "get_how PP" :named("pirop"))
.annotate 'line', 1372
    get_hll_global $P4192, ["PAST"], "Var"
    $P4193 = $P4192."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1373
    get_hll_global $P4194, ["PAST"], "Op"
.annotate 'line', 1375
    get_hll_global $P4195, ["PAST"], "Var"
    find_lex $P4196, "$meta-attr-type"
    unless_null $P4196, vivify_2062
    new $P4196, "Undef"
  vivify_2062:
    $P4197 = $P4195."new"($P4196 :named("name"), "" :named("namespace"), "package" :named("scope"))
.annotate 'line', 1376
    get_hll_global $P4198, ["PAST"], "Val"
    find_lex $P4199, "$name"
    unless_null $P4199, vivify_2063
    new $P4199, "Undef"
  vivify_2063:
    $P4200 = $P4198."new"($P4199 :named("value"), "name" :named("named"))
    $P4201 = $P4194."new"($P4197, $P4200, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 1373
    store_lex "$meta_args", $P4201
    $P4202 = $P4187."new"($P4191, $P4193, $P4201, "callmethod" :named("pasttype"), "add_attribute" :named("name"))
.annotate 'line', 1366
    $P4186."push"($P4202)
.annotate 'line', 1379
    find_lex $P4204, "$/"
    unless_null $P4204, vivify_2064
    $P4204 = root_new ['parrot';'Hash']
  vivify_2064:
    set $P4205, $P4204["typename"]
    unless_null $P4205, vivify_2065
    new $P4205, "Undef"
  vivify_2065:
    unless $P4205, if_4203_end
    .const 'Sub' $P4207 = "489_1303401201.841" 
    capture_lex $P4207
    $P4207()
  if_4203_end:
.annotate 'line', 1385
    find_lex $P4217, "$BLOCK"
    unless_null $P4217, vivify_2072
    new $P4217, "Undef"
  vivify_2072:
    find_lex $P4218, "$name"
    unless_null $P4218, vivify_2073
    new $P4218, "Undef"
  vivify_2073:
    $P4217."symbol"($P4218, "attribute" :named("scope"))
.annotate 'line', 1386
    get_hll_global $P4219, ["PAST"], "Stmts"
    $P4220 = $P4219."new"()
    store_lex "$past", $P4220
.annotate 'line', 1363
    .return ($P4220)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4206"  :anon :subid("489_1303401201.841") :outer("488_1303401201.841")
.annotate 'line', 1380
    new $P4208, "Undef"
    .lex "$type", $P4208
    find_lex $P4209, "$/"
    unless_null $P4209, vivify_2066
    $P4209 = root_new ['parrot';'Hash']
  vivify_2066:
    set $P4210, $P4209["typename"]
    unless_null $P4210, vivify_2067
    $P4210 = root_new ['parrot';'ResizablePMCArray']
  vivify_2067:
    set $P4211, $P4210[0]
    unless_null $P4211, vivify_2068
    new $P4211, "Undef"
  vivify_2068:
    $P4212 = $P4211."ast"()
    store_lex "$type", $P4212
.annotate 'line', 1381
    find_lex $P4213, "$type"
    unless_null $P4213, vivify_2069
    new $P4213, "Undef"
  vivify_2069:
    $P4213."named"("type")
.annotate 'line', 1382
    find_lex $P4214, "$meta_args"
    unless_null $P4214, vivify_2070
    new $P4214, "Undef"
  vivify_2070:
    find_lex $P4215, "$type"
    unless_null $P4215, vivify_2071
    new $P4215, "Undef"
  vivify_2071:
    $P4216 = $P4214."push"($P4215)
.annotate 'line', 1379
    .return ($P4216)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<sub>"  :subid("490_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_4252
    .param pmc param_4253
.annotate 'line', 1408
    .lex "self", param_4252
    .lex "$/", param_4253
    find_lex $P4254, "$/"
    find_lex $P4255, "$/"
    unless_null $P4255, vivify_2075
    $P4255 = root_new ['parrot';'Hash']
  vivify_2075:
    set $P4256, $P4255["routine_def"]
    unless_null $P4256, vivify_2076
    new $P4256, "Undef"
  vivify_2076:
    $P4257 = $P4256."ast"()
    $P4258 = $P4254."!make"($P4257)
    .return ($P4258)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<method>"  :subid("491_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_4260
    .param pmc param_4261
.annotate 'line', 1409
    .lex "self", param_4260
    .lex "$/", param_4261
    find_lex $P4262, "$/"
    find_lex $P4263, "$/"
    unless_null $P4263, vivify_2077
    $P4263 = root_new ['parrot';'Hash']
  vivify_2077:
    set $P4264, $P4263["method_def"]
    unless_null $P4264, vivify_2078
    new $P4264, "Undef"
  vivify_2078:
    $P4265 = $P4264."ast"()
    $P4266 = $P4262."!make"($P4265)
    .return ($P4266)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "routine_def"  :subid("492_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_4268
    .param pmc param_4269
.annotate 'line', 1411
    .const 'Sub' $P4528 = "498_1303401201.841" 
    capture_lex $P4528
    .const 'Sub' $P4289 = "493_1303401201.841" 
    capture_lex $P4289
    .lex "self", param_4268
    .lex "$/", param_4269
.annotate 'line', 1414
    new $P4270, "Undef"
    .lex "$past", $P4270
.annotate 'line', 1425
    new $P4271, "Undef"
    .lex "$block", $P4271
.annotate 'line', 1411
    find_lex $P4272, "$past"
    unless_null $P4272, vivify_2079
    new $P4272, "Undef"
  vivify_2079:
.annotate 'line', 1415
    find_lex $P4274, "$/"
    unless_null $P4274, vivify_2080
    $P4274 = root_new ['parrot';'Hash']
  vivify_2080:
    set $P4275, $P4274["onlystar"]
    unless_null $P4275, vivify_2081
    new $P4275, "Undef"
  vivify_2081:
    if $P4275, if_4273
.annotate 'line', 1419
    find_lex $P4277, "$/"
    unless_null $P4277, vivify_2082
    $P4277 = root_new ['parrot';'Hash']
  vivify_2082:
    set $P4278, $P4277["blockoid"]
    unless_null $P4278, vivify_2083
    new $P4278, "Undef"
  vivify_2083:
    $P4279 = $P4278."ast"()
    store_lex "$past", $P4279
.annotate 'line', 1420
    find_lex $P4280, "$past"
    unless_null $P4280, vivify_2084
    new $P4280, "Undef"
  vivify_2084:
    $P4280."blocktype"("declaration")
.annotate 'line', 1421
    find_dynamic_lex $P4282, "$*RETURN_USED"
    unless_null $P4282, vivify_2085
    get_hll_global $P4282, "$RETURN_USED"
    unless_null $P4282, vivify_2086
    die "Contextual $*RETURN_USED not found"
  vivify_2086:
  vivify_2085:
    unless $P4282, if_4281_end
.annotate 'line', 1422
    find_lex $P4283, "$past"
    unless_null $P4283, vivify_2087
    new $P4283, "Undef"
  vivify_2087:
    $P4283."control"("return_pir")
  if_4281_end:
.annotate 'line', 1418
    goto if_4273_end
  if_4273:
.annotate 'line', 1416
    $P4276 = "only_star_block"()
    store_lex "$past", $P4276
  if_4273_end:
.annotate 'line', 1425
    find_lex $P4284, "$past"
    unless_null $P4284, vivify_2088
    new $P4284, "Undef"
  vivify_2088:
    store_lex "$block", $P4284
.annotate 'line', 1427
    find_lex $P4286, "$/"
    unless_null $P4286, vivify_2089
    $P4286 = root_new ['parrot';'Hash']
  vivify_2089:
    set $P4287, $P4286["deflongname"]
    unless_null $P4287, vivify_2090
    new $P4287, "Undef"
  vivify_2090:
    unless $P4287, if_4285_end
    .const 'Sub' $P4289 = "493_1303401201.841" 
    capture_lex $P4289
    $P4289()
  if_4285_end:
.annotate 'line', 1532
    find_lex $P4517, "$block"
    unless_null $P4517, vivify_2193
    new $P4517, "Undef"
  vivify_2193:
    find_lex $P4518, "$past"
    unless_null $P4518, vivify_2194
    $P4518 = root_new ['parrot';'Hash']
    store_lex "$past", $P4518
  vivify_2194:
    set $P4518["block_past"], $P4517
.annotate 'line', 1533
    find_lex $P4520, "$/"
    unless_null $P4520, vivify_2195
    $P4520 = root_new ['parrot';'Hash']
  vivify_2195:
    set $P4521, $P4520["trait"]
    unless_null $P4521, vivify_2196
    new $P4521, "Undef"
  vivify_2196:
    unless $P4521, if_4519_end
.annotate 'line', 1534
    find_lex $P4523, "$/"
    unless_null $P4523, vivify_2197
    $P4523 = root_new ['parrot';'Hash']
  vivify_2197:
    set $P4524, $P4523["trait"]
    unless_null $P4524, vivify_2198
    new $P4524, "Undef"
  vivify_2198:
    defined $I4525, $P4524
    unless $I4525, for_undef_2199
    iter $P4522, $P4524
    new $P4535, 'ExceptionHandler'
    set_label $P4535, loop4534_handler
    $P4535."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4535
  loop4534_test:
    unless $P4522, loop4534_done
    shift $P4526, $P4522
  loop4534_redo:
    .const 'Sub' $P4528 = "498_1303401201.841" 
    capture_lex $P4528
    $P4528($P4526)
  loop4534_next:
    goto loop4534_test
  loop4534_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4536, exception, 'type'
    eq $P4536, .CONTROL_LOOP_NEXT, loop4534_next
    eq $P4536, .CONTROL_LOOP_REDO, loop4534_redo
  loop4534_done:
    pop_eh 
  for_undef_2199:
  if_4519_end:
.annotate 'line', 1537
    find_lex $P4537, "$/"
    find_lex $P4538, "$past"
    unless_null $P4538, vivify_2202
    new $P4538, "Undef"
  vivify_2202:
    $P4539 = $P4537."!make"($P4538)
.annotate 'line', 1411
    .return ($P4539)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4288"  :anon :subid("493_1303401201.841") :outer("492_1303401201.841")
.annotate 'line', 1427
    .const 'Sub' $P4419 = "497_1303401201.841" 
    capture_lex $P4419
    .const 'Sub' $P4322 = "494_1303401201.841" 
    capture_lex $P4322
.annotate 'line', 1428
    new $P4290, "Undef"
    .lex "$name", $P4290
    find_lex $P4291, "$/"
    unless_null $P4291, vivify_2091
    $P4291 = root_new ['parrot';'Hash']
  vivify_2091:
    set $P4292, $P4291["sigil"]
    unless_null $P4292, vivify_2092
    $P4292 = root_new ['parrot';'ResizablePMCArray']
  vivify_2092:
    set $P4293, $P4292[0]
    unless_null $P4293, vivify_2093
    new $P4293, "Undef"
  vivify_2093:
    set $S4294, $P4293
    new $P4295, 'String'
    set $P4295, $S4294
    find_lex $P4296, "$/"
    unless_null $P4296, vivify_2094
    $P4296 = root_new ['parrot';'Hash']
  vivify_2094:
    set $P4297, $P4296["deflongname"]
    unless_null $P4297, vivify_2095
    $P4297 = root_new ['parrot';'ResizablePMCArray']
  vivify_2095:
    set $P4298, $P4297[0]
    unless_null $P4298, vivify_2096
    new $P4298, "Undef"
  vivify_2096:
    $S4299 = $P4298."ast"()
    concat $P4300, $P4295, $S4299
    store_lex "$name", $P4300
.annotate 'line', 1429
    find_lex $P4301, "$past"
    unless_null $P4301, vivify_2097
    new $P4301, "Undef"
  vivify_2097:
    find_lex $P4302, "$name"
    unless_null $P4302, vivify_2098
    new $P4302, "Undef"
  vivify_2098:
    $P4301."name"($P4302)
.annotate 'line', 1430
    find_dynamic_lex $P4308, "$*SCOPE"
    unless_null $P4308, vivify_2099
    get_hll_global $P4308, "$SCOPE"
    unless_null $P4308, vivify_2100
    die "Contextual $*SCOPE not found"
  vivify_2100:
  vivify_2099:
    set $S4309, $P4308
    iseq $I4310, $S4309, ""
    unless $I4310, unless_4307
    new $P4306, 'Integer'
    set $P4306, $I4310
    goto unless_4307_end
  unless_4307:
    find_dynamic_lex $P4311, "$*SCOPE"
    unless_null $P4311, vivify_2101
    get_hll_global $P4311, "$SCOPE"
    unless_null $P4311, vivify_2102
    die "Contextual $*SCOPE not found"
  vivify_2102:
  vivify_2101:
    set $S4312, $P4311
    iseq $I4313, $S4312, "my"
    new $P4306, 'Integer'
    set $P4306, $I4313
  unless_4307_end:
    unless $P4306, unless_4305
    set $P4304, $P4306
    goto unless_4305_end
  unless_4305:
    find_dynamic_lex $P4314, "$*SCOPE"
    unless_null $P4314, vivify_2103
    get_hll_global $P4314, "$SCOPE"
    unless_null $P4314, vivify_2104
    die "Contextual $*SCOPE not found"
  vivify_2104:
  vivify_2103:
    set $S4315, $P4314
    iseq $I4316, $S4315, "our"
    new $P4304, 'Integer'
    set $P4304, $I4316
  unless_4305_end:
    if $P4304, if_4303
.annotate 'line', 1522
    find_lex $P4502, "$/"
    unless_null $P4502, vivify_2105
    new $P4502, "Undef"
  vivify_2105:
    $P4503 = $P4502."CURSOR"()
    find_dynamic_lex $P4504, "$*SCOPE"
    unless_null $P4504, vivify_2106
    get_hll_global $P4504, "$SCOPE"
    unless_null $P4504, vivify_2107
    die "Contextual $*SCOPE not found"
  vivify_2107:
  vivify_2106:
    concat $P4505, $P4504, " scoped routines are not supported yet"
    $P4503."panic"($P4505)
.annotate 'line', 1521
    goto if_4303_end
  if_4303:
.annotate 'line', 1431
    find_dynamic_lex $P4318, "$*MULTINESS"
    unless_null $P4318, vivify_2108
    get_hll_global $P4318, "$MULTINESS"
    unless_null $P4318, vivify_2109
    die "Contextual $*MULTINESS not found"
  vivify_2109:
  vivify_2108:
    set $S4319, $P4318
    iseq $I4320, $S4319, "multi"
    if $I4320, if_4317
.annotate 'line', 1482
    find_dynamic_lex $P4415, "$*MULTINESS"
    unless_null $P4415, vivify_2110
    get_hll_global $P4415, "$MULTINESS"
    unless_null $P4415, vivify_2111
    die "Contextual $*MULTINESS not found"
  vivify_2111:
  vivify_2110:
    set $S4416, $P4415
    iseq $I4417, $S4416, "proto"
    if $I4417, if_4414
.annotate 'line', 1501
    find_lex $P4455, "$?PACKAGE"
    get_who $P4456, $P4455
    set $P4457, $P4456["@BLOCK"]
    unless_null $P4457, vivify_2112
    $P4457 = root_new ['parrot';'ResizablePMCArray']
  vivify_2112:
    set $P4458, $P4457[0]
    unless_null $P4458, vivify_2113
    $P4458 = root_new ['parrot';'ResizablePMCArray']
  vivify_2113:
    set $P4459, $P4458[0]
    unless_null $P4459, vivify_2114
    new $P4459, "Undef"
  vivify_2114:
    get_hll_global $P4460, ["PAST"], "Var"
    find_lex $P4461, "$name"
    unless_null $P4461, vivify_2115
    new $P4461, "Undef"
  vivify_2115:
    find_lex $P4462, "$past"
    unless_null $P4462, vivify_2116
    new $P4462, "Undef"
  vivify_2116:
    $P4463 = $P4460."new"($P4461 :named("name"), 1 :named("isdecl"), $P4462 :named("viviself"), "lexical" :named("scope"))
    $P4459."push"($P4463)
.annotate 'line', 1503
    find_lex $P4464, "$?PACKAGE"
    get_who $P4465, $P4464
    set $P4466, $P4465["@BLOCK"]
    unless_null $P4466, vivify_2117
    $P4466 = root_new ['parrot';'ResizablePMCArray']
  vivify_2117:
    set $P4467, $P4466[0]
    unless_null $P4467, vivify_2118
    new $P4467, "Undef"
  vivify_2118:
    find_lex $P4468, "$name"
    unless_null $P4468, vivify_2119
    new $P4468, "Undef"
  vivify_2119:
    $P4467."symbol"($P4468, "lexical" :named("scope"))
.annotate 'line', 1504
    find_dynamic_lex $P4470, "$*SCOPE"
    unless_null $P4470, vivify_2120
    get_hll_global $P4470, "$SCOPE"
    unless_null $P4470, vivify_2121
    die "Contextual $*SCOPE not found"
  vivify_2121:
  vivify_2120:
    set $S4471, $P4470
    iseq $I4472, $S4471, "our"
    unless $I4472, if_4469_end
.annotate 'line', 1507
    find_lex $P4473, "$?PACKAGE"
    get_who $P4474, $P4473
    set $P4475, $P4474["@BLOCK"]
    unless_null $P4475, vivify_2122
    $P4475 = root_new ['parrot';'ResizablePMCArray']
  vivify_2122:
    set $P4476, $P4475[0]
    unless_null $P4476, vivify_2123
    $P4476 = root_new ['parrot';'ResizablePMCArray']
  vivify_2123:
    set $P4477, $P4476[0]
    unless_null $P4477, vivify_2124
    new $P4477, "Undef"
  vivify_2124:
    get_hll_global $P4478, ["PAST"], "Op"
.annotate 'line', 1509
    get_hll_global $P4479, ["PAST"], "Var"
    find_lex $P4480, "$name"
    unless_null $P4480, vivify_2125
    new $P4480, "Undef"
  vivify_2125:
    $P4481 = $P4479."new"($P4480 :named("name"), "package" :named("scope"))
.annotate 'line', 1510
    get_hll_global $P4482, ["PAST"], "Var"
    find_lex $P4483, "$name"
    unless_null $P4483, vivify_2126
    new $P4483, "Undef"
  vivify_2126:
    $P4484 = $P4482."new"($P4483 :named("name"), "lexical" :named("scope"))
    $P4485 = $P4478."new"($P4481, $P4484, "bind" :named("pasttype"))
.annotate 'line', 1507
    $P4477."push"($P4485)
.annotate 'line', 1512
    find_lex $P4486, "$?PACKAGE"
    get_who $P4487, $P4486
    set $P4488, $P4487["@BLOCK"]
    unless_null $P4488, vivify_2127
    $P4488 = root_new ['parrot';'ResizablePMCArray']
  vivify_2127:
    set $P4489, $P4488[0]
    unless_null $P4489, vivify_2128
    new $P4489, "Undef"
  vivify_2128:
    $P4490 = $P4489."loadinit"()
    get_hll_global $P4491, ["PAST"], "Op"
.annotate 'line', 1514
    get_hll_global $P4492, ["PAST"], "Var"
    find_lex $P4493, "$name"
    unless_null $P4493, vivify_2129
    new $P4493, "Undef"
  vivify_2129:
    $P4494 = $P4492."new"($P4493 :named("name"), "package" :named("scope"))
.annotate 'line', 1515
    get_hll_global $P4495, ["PAST"], "Val"
    find_lex $P4496, "$past"
    unless_null $P4496, vivify_2130
    new $P4496, "Undef"
  vivify_2130:
    $P4497 = $P4495."new"($P4496 :named("value"))
    $P4498 = $P4491."new"($P4494, $P4497, "bind" :named("pasttype"))
.annotate 'line', 1512
    $P4490."push"($P4498)
  if_4469_end:
.annotate 'line', 1500
    goto if_4414_end
  if_4414:
.annotate 'line', 1482
    .const 'Sub' $P4419 = "497_1303401201.841" 
    capture_lex $P4419
    $P4419()
  if_4414_end:
    goto if_4317_end
  if_4317:
.annotate 'line', 1431
    .const 'Sub' $P4322 = "494_1303401201.841" 
    capture_lex $P4322
    $P4322()
  if_4317_end:
.annotate 'line', 1519
    get_hll_global $P4499, ["PAST"], "Var"
    find_lex $P4500, "$name"
    unless_null $P4500, vivify_2188
    new $P4500, "Undef"
  vivify_2188:
    $P4501 = $P4499."new"($P4500 :named("name"))
    store_lex "$past", $P4501
  if_4303_end:
.annotate 'line', 1526
    find_lex $P4510, "$name"
    unless_null $P4510, vivify_2189
    new $P4510, "Undef"
  vivify_2189:
    set $S4511, $P4510
    iseq $I4512, $S4511, "MAIN"
    if $I4512, if_4509
    new $P4508, 'Integer'
    set $P4508, $I4512
    goto if_4509_end
  if_4509:
    find_dynamic_lex $P4513, "$*MULTINESS"
    unless_null $P4513, vivify_2190
    get_hll_global $P4513, "$MULTINESS"
    unless_null $P4513, vivify_2191
    die "Contextual $*MULTINESS not found"
  vivify_2191:
  vivify_2190:
    set $S4514, $P4513
    isne $I4515, $S4514, "multi"
    new $P4508, 'Integer'
    set $P4508, $I4515
  if_4509_end:
    if $P4508, if_4507
    set $P4506, $P4508
    goto if_4507_end
  if_4507:
.annotate 'line', 1527
    find_lex $P4516, "$block"
    unless_null $P4516, vivify_2192
    new $P4516, "Undef"
  vivify_2192:
    store_dynamic_lex "$*MAIN_SUB", $P4516
.annotate 'line', 1526
    set $P4506, $P4516
  if_4507_end:
.annotate 'line', 1427
    .return ($P4506)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4418"  :anon :subid("497_1303401201.841") :outer("493_1303401201.841")
.annotate 'line', 1487
    new $P4420, "Undef"
    .lex "$cholder", $P4420
.annotate 'line', 1486
    find_dynamic_lex $P4422, "$*SCOPE"
    unless_null $P4422, vivify_2131
    get_hll_global $P4422, "$SCOPE"
    unless_null $P4422, vivify_2132
    die "Contextual $*SCOPE not found"
  vivify_2132:
  vivify_2131:
    set $S4423, $P4422
    iseq $I4424, $S4423, "our"
    unless $I4424, if_4421_end
    die "our-scoped protos not yet implemented"
  if_4421_end:
.annotate 'line', 1487
    get_hll_global $P4425, ["PAST"], "Op"
    $P4426 = $P4425."new"("list" :named("pasttype"))
    store_lex "$cholder", $P4426
.annotate 'line', 1488
    find_lex $P4427, "$?PACKAGE"
    get_who $P4428, $P4427
    set $P4429, $P4428["@BLOCK"]
    unless_null $P4429, vivify_2133
    $P4429 = root_new ['parrot';'ResizablePMCArray']
  vivify_2133:
    set $P4430, $P4429[0]
    unless_null $P4430, vivify_2134
    $P4430 = root_new ['parrot';'ResizablePMCArray']
  vivify_2134:
    set $P4431, $P4430[0]
    unless_null $P4431, vivify_2135
    new $P4431, "Undef"
  vivify_2135:
    get_hll_global $P4432, ["PAST"], "Var"
    find_lex $P4433, "$name"
    unless_null $P4433, vivify_2136
    new $P4433, "Undef"
  vivify_2136:
    find_lex $P4434, "$past"
    unless_null $P4434, vivify_2137
    new $P4434, "Undef"
  vivify_2137:
    $P4435 = $P4432."new"($P4433 :named("name"), 1 :named("isdecl"), $P4434 :named("viviself"), "lexical" :named("scope"))
    $P4431."push"($P4435)
.annotate 'line', 1490
    find_lex $P4436, "$?PACKAGE"
    get_who $P4437, $P4436
    set $P4438, $P4437["@BLOCK"]
    unless_null $P4438, vivify_2138
    $P4438 = root_new ['parrot';'ResizablePMCArray']
  vivify_2138:
    set $P4439, $P4438[0]
    unless_null $P4439, vivify_2139
    $P4439 = root_new ['parrot';'ResizablePMCArray']
  vivify_2139:
    set $P4440, $P4439[0]
    unless_null $P4440, vivify_2140
    new $P4440, "Undef"
  vivify_2140:
    get_hll_global $P4441, ["PAST"], "Op"
.annotate 'line', 1492
    get_hll_global $P4442, ["PAST"], "Var"
    find_lex $P4443, "$name"
    unless_null $P4443, vivify_2141
    new $P4443, "Undef"
  vivify_2141:
    $P4444 = $P4442."new"($P4443 :named("name"))
    find_lex $P4445, "$cholder"
    unless_null $P4445, vivify_2142
    new $P4445, "Undef"
  vivify_2142:
    $P4446 = $P4441."new"($P4444, $P4445, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 1490
    $P4440."push"($P4446)
.annotate 'line', 1495
    find_lex $P4447, "$?PACKAGE"
    get_who $P4448, $P4447
    set $P4449, $P4448["@BLOCK"]
    unless_null $P4449, vivify_2143
    $P4449 = root_new ['parrot';'ResizablePMCArray']
  vivify_2143:
    set $P4450, $P4449[0]
    unless_null $P4450, vivify_2144
    new $P4450, "Undef"
  vivify_2144:
    find_lex $P4451, "$name"
    unless_null $P4451, vivify_2145
    new $P4451, "Undef"
  vivify_2145:
    find_lex $P4452, "$cholder"
    unless_null $P4452, vivify_2146
    new $P4452, "Undef"
  vivify_2146:
    $P4450."symbol"($P4451, "lexical" :named("scope"), 1 :named("proto"), $P4452 :named("cholder"))
.annotate 'line', 1498
    find_lex $P4453, "$past"
    unless_null $P4453, vivify_2147
    new $P4453, "Undef"
  vivify_2147:
    $P4454 = $P4453."pirflags"(":instanceof(\"DispatcherSub\")")
.annotate 'line', 1482
    .return ($P4454)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4321"  :anon :subid("494_1303401201.841") :outer("493_1303401201.841")
.annotate 'line', 1431
    .const 'Sub' $P4342 = "495_1303401201.841" 
    capture_lex $P4342
.annotate 'line', 1434
    new $P4323, "Undef"
    .lex "$cholder", $P4323
.annotate 'line', 1435
    $P4324 = root_new ['parrot';'Hash']
    .lex "%sym", $P4324
.annotate 'line', 1433
    find_dynamic_lex $P4326, "$*SCOPE"
    unless_null $P4326, vivify_2148
    get_hll_global $P4326, "$SCOPE"
    unless_null $P4326, vivify_2149
    die "Contextual $*SCOPE not found"
  vivify_2149:
  vivify_2148:
    set $S4327, $P4326
    iseq $I4328, $S4327, "our"
    unless $I4328, if_4325_end
    die "our-scoped multis not yet implemented"
  if_4325_end:
    find_lex $P4329, "$cholder"
    unless_null $P4329, vivify_2150
    new $P4329, "Undef"
  vivify_2150:
.annotate 'line', 1435
    find_lex $P4330, "$?PACKAGE"
    get_who $P4331, $P4330
    set $P4332, $P4331["@BLOCK"]
    unless_null $P4332, vivify_2151
    $P4332 = root_new ['parrot';'ResizablePMCArray']
  vivify_2151:
    set $P4333, $P4332[0]
    unless_null $P4333, vivify_2152
    new $P4333, "Undef"
  vivify_2152:
    find_lex $P4334, "$name"
    unless_null $P4334, vivify_2153
    new $P4334, "Undef"
  vivify_2153:
    $P4335 = $P4333."symbol"($P4334)
    store_lex "%sym", $P4335
.annotate 'line', 1436
    find_lex $P4337, "%sym"
    unless_null $P4337, vivify_2154
    $P4337 = root_new ['parrot';'Hash']
  vivify_2154:
    set $P4338, $P4337["cholder"]
    unless_null $P4338, vivify_2155
    new $P4338, "Undef"
  vivify_2155:
    if $P4338, if_4336
.annotate 'line', 1441
    .const 'Sub' $P4342 = "495_1303401201.841" 
    capture_lex $P4342
    $P4342()
    goto if_4336_end
  if_4336:
.annotate 'line', 1437
    find_lex $P4339, "%sym"
    unless_null $P4339, vivify_2183
    $P4339 = root_new ['parrot';'Hash']
  vivify_2183:
    set $P4340, $P4339["cholder"]
    unless_null $P4340, vivify_2184
    new $P4340, "Undef"
  vivify_2184:
    store_lex "$cholder", $P4340
  if_4336_end:
.annotate 'line', 1477
    find_lex $P4410, "$cholder"
    unless_null $P4410, vivify_2185
    new $P4410, "Undef"
  vivify_2185:
    find_lex $P4411, "$past"
    unless_null $P4411, vivify_2186
    new $P4411, "Undef"
  vivify_2186:
    $P4410."push"($P4411)
.annotate 'line', 1480
    find_lex $P4412, "$past"
    unless_null $P4412, vivify_2187
    new $P4412, "Undef"
  vivify_2187:
    $P4413 = "attach_multi_signature"($P4412)
.annotate 'line', 1431
    .return ($P4413)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block4341"  :anon :subid("495_1303401201.841") :outer("494_1303401201.841")
.annotate 'line', 1441
    .const 'Sub' $P4358 = "496_1303401201.841" 
    capture_lex $P4358
.annotate 'line', 1448
    new $P4343, "Undef"
    .lex "$found_proto", $P4343
.annotate 'line', 1466
    new $P4344, "Undef"
    .lex "$dispatch_setup", $P4344
.annotate 'line', 1443
    find_lex $P4346, "%sym"
    unless_null $P4346, vivify_2156
    $P4346 = root_new ['parrot';'Hash']
  vivify_2156:
    set $P4347, $P4346["proto"]
    unless_null $P4347, vivify_2157
    new $P4347, "Undef"
  vivify_2157:
    unless $P4347, if_4345_end
.annotate 'line', 1446
    find_lex $P4348, "$/"
    unless_null $P4348, vivify_2158
    new $P4348, "Undef"
  vivify_2158:
    $P4349 = $P4348."CURSOR"()
    $P4349."panic"("Internal Error: Current scope has a proto, but no candidate list holder was set up. (This should never happen.)")
  if_4345_end:
.annotate 'line', 1443
    find_lex $P4350, "$found_proto"
    unless_null $P4350, vivify_2159
    new $P4350, "Undef"
  vivify_2159:
.annotate 'line', 1449
    find_lex $P4352, "$?PACKAGE"
    get_who $P4353, $P4352
    set $P4354, $P4353["@BLOCK"]
    unless_null $P4354, vivify_2160
    $P4354 = root_new ['parrot';'ResizablePMCArray']
  vivify_2160:
    defined $I4355, $P4354
    unless $I4355, for_undef_2161
    iter $P4351, $P4354
    new $P4380, 'ExceptionHandler'
    set_label $P4380, loop4379_handler
    $P4380."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4380
  loop4379_test:
    unless $P4351, loop4379_done
    shift $P4356, $P4351
  loop4379_redo:
    .const 'Sub' $P4358 = "496_1303401201.841" 
    capture_lex $P4358
    $P4358($P4356)
  loop4379_next:
    goto loop4379_test
  loop4379_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4381, exception, 'type'
    eq $P4381, .CONTROL_LOOP_NEXT, loop4379_next
    eq $P4381, .CONTROL_LOOP_REDO, loop4379_redo
  loop4379_done:
    pop_eh 
  for_undef_2161:
.annotate 'line', 1460
    find_lex $P4383, "$found_proto"
    unless_null $P4383, vivify_2170
    new $P4383, "Undef"
  vivify_2170:
    if $P4383, unless_4382_end
.annotate 'line', 1461
    find_lex $P4384, "$/"
    unless_null $P4384, vivify_2171
    new $P4384, "Undef"
  vivify_2171:
    $P4385 = $P4384."CURSOR"()
    $P4385."panic"("Sorry, no proto sub in scope, and auto-generation of protos is not yet implemented.")
  unless_4382_end:
.annotate 'line', 1465
    get_hll_global $P4386, ["PAST"], "Op"
    $P4387 = $P4386."new"("list" :named("pasttype"))
    store_lex "$cholder", $P4387
.annotate 'line', 1466
    get_hll_global $P4388, ["PAST"], "Op"
.annotate 'line', 1468
    get_hll_global $P4389, ["PAST"], "Var"
    find_lex $P4390, "$name"
    unless_null $P4390, vivify_2172
    new $P4390, "Undef"
  vivify_2172:
    $P4391 = $P4389."new"($P4390 :named("name"), "outer" :named("scope"))
    find_lex $P4392, "$cholder"
    unless_null $P4392, vivify_2173
    new $P4392, "Undef"
  vivify_2173:
    $P4393 = $P4388."new"($P4391, $P4392, "create_dispatch_and_add_candidates PPP" :named("pirop"))
.annotate 'line', 1466
    store_lex "$dispatch_setup", $P4393
.annotate 'line', 1471
    find_lex $P4394, "$?PACKAGE"
    get_who $P4395, $P4394
    set $P4396, $P4395["@BLOCK"]
    unless_null $P4396, vivify_2174
    $P4396 = root_new ['parrot';'ResizablePMCArray']
  vivify_2174:
    set $P4397, $P4396[0]
    unless_null $P4397, vivify_2175
    $P4397 = root_new ['parrot';'ResizablePMCArray']
  vivify_2175:
    set $P4398, $P4397[0]
    unless_null $P4398, vivify_2176
    new $P4398, "Undef"
  vivify_2176:
    get_hll_global $P4399, ["PAST"], "Var"
    find_lex $P4400, "$name"
    unless_null $P4400, vivify_2177
    new $P4400, "Undef"
  vivify_2177:
    find_lex $P4401, "$dispatch_setup"
    unless_null $P4401, vivify_2178
    new $P4401, "Undef"
  vivify_2178:
    $P4402 = $P4399."new"($P4400 :named("name"), 1 :named("isdecl"), $P4401 :named("viviself"), "lexical" :named("scope"))
    $P4398."push"($P4402)
.annotate 'line', 1473
    find_lex $P4403, "$?PACKAGE"
    get_who $P4404, $P4403
    set $P4405, $P4404["@BLOCK"]
    unless_null $P4405, vivify_2179
    $P4405 = root_new ['parrot';'ResizablePMCArray']
  vivify_2179:
    set $P4406, $P4405[0]
    unless_null $P4406, vivify_2180
    new $P4406, "Undef"
  vivify_2180:
    find_lex $P4407, "$name"
    unless_null $P4407, vivify_2181
    new $P4407, "Undef"
  vivify_2181:
    find_lex $P4408, "$cholder"
    unless_null $P4408, vivify_2182
    new $P4408, "Undef"
  vivify_2182:
    $P4409 = $P4406."symbol"($P4407, "lexical" :named("scope"), $P4408 :named("cholder"))
.annotate 'line', 1441
    .return ($P4409)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4357"  :anon :subid("496_1303401201.841") :outer("495_1303401201.841")
    .param pmc param_4360
.annotate 'line', 1450
    $P4359 = root_new ['parrot';'Hash']
    .lex "%sym", $P4359
    .lex "$_", param_4360
    find_lex $P4361, "$_"
    unless_null $P4361, vivify_2162
    new $P4361, "Undef"
  vivify_2162:
    find_lex $P4362, "$name"
    unless_null $P4362, vivify_2163
    new $P4362, "Undef"
  vivify_2163:
    $P4363 = $P4361."symbol"($P4362)
    store_lex "%sym", $P4363
.annotate 'line', 1451
    find_lex $P4368, "%sym"
    unless_null $P4368, vivify_2164
    $P4368 = root_new ['parrot';'Hash']
  vivify_2164:
    set $P4369, $P4368["proto"]
    unless_null $P4369, vivify_2165
    new $P4369, "Undef"
  vivify_2165:
    unless $P4369, unless_4367
    set $P4366, $P4369
    goto unless_4367_end
  unless_4367:
    find_lex $P4370, "%sym"
    unless_null $P4370, vivify_2166
    $P4370 = root_new ['parrot';'Hash']
  vivify_2166:
    set $P4371, $P4370["cholder"]
    unless_null $P4371, vivify_2167
    new $P4371, "Undef"
  vivify_2167:
    set $P4366, $P4371
  unless_4367_end:
    if $P4366, if_4365
.annotate 'line', 1454
    find_lex $P4375, "%sym"
    unless_null $P4375, vivify_2168
    $P4375 = root_new ['parrot';'Hash']
  vivify_2168:
    if $P4375, if_4374
    set $P4373, $P4375
    goto if_4374_end
  if_4374:
.annotate 'line', 1455
    find_lex $P4376, "$/"
    unless_null $P4376, vivify_2169
    new $P4376, "Undef"
  vivify_2169:
    $P4377 = $P4376."CURSOR"()
    $P4378 = $P4377."panic"("Cannot declare a multi when an only is already in scope.")
.annotate 'line', 1454
    set $P4373, $P4378
  if_4374_end:
    set $P4364, $P4373
.annotate 'line', 1451
    goto if_4365_end
  if_4365:
.annotate 'line', 1452
    new $P4372, "Integer"
    assign $P4372, 1
    store_lex "$found_proto", $P4372
.annotate 'line', 1451
    set $P4364, $P4372
  if_4365_end:
.annotate 'line', 1449
    .return ($P4364)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4527"  :anon :subid("498_1303401201.841") :outer("492_1303401201.841")
    .param pmc param_4529
.annotate 'line', 1534
    .lex "$_", param_4529
    find_lex $P4530, "$_"
    unless_null $P4530, vivify_2200
    new $P4530, "Undef"
  vivify_2200:
    $P4531 = $P4530."ast"()
    find_lex $P4532, "$/"
    unless_null $P4532, vivify_2201
    new $P4532, "Undef"
  vivify_2201:
    $P4533 = $P4531($P4532)
    .return ($P4533)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "method_def"  :subid("499_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_4541
    .param pmc param_4542
.annotate 'line', 1541
    .const 'Sub' $P4654 = "501_1303401201.841" 
    capture_lex $P4654
    .const 'Sub' $P4570 = "500_1303401201.841" 
    capture_lex $P4570
    .lex "self", param_4541
    .lex "$/", param_4542
.annotate 'line', 1544
    new $P4543, "Undef"
    .lex "$past", $P4543
.annotate 'line', 1541
    find_lex $P4544, "$past"
    unless_null $P4544, vivify_2203
    new $P4544, "Undef"
  vivify_2203:
.annotate 'line', 1545
    find_lex $P4546, "$/"
    unless_null $P4546, vivify_2204
    $P4546 = root_new ['parrot';'Hash']
  vivify_2204:
    set $P4547, $P4546["onlystar"]
    unless_null $P4547, vivify_2205
    new $P4547, "Undef"
  vivify_2205:
    if $P4547, if_4545
.annotate 'line', 1549
    find_lex $P4549, "$/"
    unless_null $P4549, vivify_2206
    $P4549 = root_new ['parrot';'Hash']
  vivify_2206:
    set $P4550, $P4549["blockoid"]
    unless_null $P4550, vivify_2207
    new $P4550, "Undef"
  vivify_2207:
    $P4551 = $P4550."ast"()
    store_lex "$past", $P4551
.annotate 'line', 1550
    find_lex $P4552, "$past"
    unless_null $P4552, vivify_2208
    new $P4552, "Undef"
  vivify_2208:
    $P4552."blocktype"("declaration")
.annotate 'line', 1551
    find_dynamic_lex $P4554, "$*RETURN_USED"
    unless_null $P4554, vivify_2209
    get_hll_global $P4554, "$RETURN_USED"
    unless_null $P4554, vivify_2210
    die "Contextual $*RETURN_USED not found"
  vivify_2210:
  vivify_2209:
    unless $P4554, if_4553_end
.annotate 'line', 1552
    find_lex $P4555, "$past"
    unless_null $P4555, vivify_2211
    new $P4555, "Undef"
  vivify_2211:
    $P4555."control"("return_pir")
  if_4553_end:
.annotate 'line', 1548
    goto if_4545_end
  if_4545:
.annotate 'line', 1546
    $P4548 = "only_star_block"()
    store_lex "$past", $P4548
  if_4545_end:
.annotate 'line', 1557
    find_lex $P4557, "$past"
    unless_null $P4557, vivify_2212
    $P4557 = root_new ['parrot';'Hash']
  vivify_2212:
    set $P4558, $P4557["signature_has_invocant"]
    unless_null $P4558, vivify_2213
    new $P4558, "Undef"
  vivify_2213:
    if $P4558, unless_4556_end
.annotate 'line', 1558
    find_lex $P4559, "$past"
    unless_null $P4559, vivify_2214
    $P4559 = root_new ['parrot';'ResizablePMCArray']
  vivify_2214:
    set $P4560, $P4559[0]
    unless_null $P4560, vivify_2215
    new $P4560, "Undef"
  vivify_2215:
    get_hll_global $P4561, ["PAST"], "Var"
.annotate 'line', 1560
    get_hll_global $P4562, ["PAST"], "Var"
    $P4563 = $P4562."new"("$?CLASS" :named("name"))
    $P4564 = $P4561."new"("self" :named("name"), "parameter" :named("scope"), $P4563 :named("multitype"))
.annotate 'line', 1558
    $P4560."unshift"($P4564)
  unless_4556_end:
.annotate 'line', 1563
    find_lex $P4565, "$past"
    unless_null $P4565, vivify_2216
    new $P4565, "Undef"
  vivify_2216:
    $P4565."symbol"("self", "lexical" :named("scope"))
.annotate 'line', 1566
    find_lex $P4567, "$/"
    unless_null $P4567, vivify_2217
    $P4567 = root_new ['parrot';'Hash']
  vivify_2217:
    set $P4568, $P4567["deflongname"]
    unless_null $P4568, vivify_2218
    new $P4568, "Undef"
  vivify_2218:
    unless $P4568, if_4566_end
    .const 'Sub' $P4570 = "500_1303401201.841" 
    capture_lex $P4570
    $P4570()
  if_4566_end:
.annotate 'line', 1601
    find_dynamic_lex $P4636, "$*SCOPE"
    unless_null $P4636, vivify_2244
    get_hll_global $P4636, "$SCOPE"
    unless_null $P4636, vivify_2245
    die "Contextual $*SCOPE not found"
  vivify_2245:
  vivify_2244:
    set $S4637, $P4636
    iseq $I4638, $S4637, "our"
    unless $I4638, if_4635_end
.annotate 'line', 1602
    find_lex $P4639, "$past"
    unless_null $P4639, vivify_2246
    new $P4639, "Undef"
  vivify_2246:
    $P4639."pirflags"(":nsentry")
  if_4635_end:
.annotate 'line', 1606
    find_lex $P4640, "$/"
    find_lex $P4641, "$past"
    unless_null $P4641, vivify_2247
    new $P4641, "Undef"
  vivify_2247:
    $P4640."!make"($P4641)
.annotate 'line', 1607
    find_lex $P4642, "$past"
    unless_null $P4642, vivify_2248
    new $P4642, "Undef"
  vivify_2248:
    find_lex $P4643, "$past"
    unless_null $P4643, vivify_2249
    $P4643 = root_new ['parrot';'Hash']
    store_lex "$past", $P4643
  vivify_2249:
    set $P4643["block_past"], $P4642
.annotate 'line', 1608
    find_lex $P4646, "$/"
    unless_null $P4646, vivify_2250
    $P4646 = root_new ['parrot';'Hash']
  vivify_2250:
    set $P4647, $P4646["trait"]
    unless_null $P4647, vivify_2251
    new $P4647, "Undef"
  vivify_2251:
    if $P4647, if_4645
    set $P4644, $P4647
    goto if_4645_end
  if_4645:
.annotate 'line', 1609
    find_lex $P4649, "$/"
    unless_null $P4649, vivify_2252
    $P4649 = root_new ['parrot';'Hash']
  vivify_2252:
    set $P4650, $P4649["trait"]
    unless_null $P4650, vivify_2253
    new $P4650, "Undef"
  vivify_2253:
    defined $I4651, $P4650
    unless $I4651, for_undef_2254
    iter $P4648, $P4650
    new $P4661, 'ExceptionHandler'
    set_label $P4661, loop4660_handler
    $P4661."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4661
  loop4660_test:
    unless $P4648, loop4660_done
    shift $P4652, $P4648
  loop4660_redo:
    .const 'Sub' $P4654 = "501_1303401201.841" 
    capture_lex $P4654
    $P4654($P4652)
  loop4660_next:
    goto loop4660_test
  loop4660_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4662, exception, 'type'
    eq $P4662, .CONTROL_LOOP_NEXT, loop4660_next
    eq $P4662, .CONTROL_LOOP_REDO, loop4660_redo
  loop4660_done:
    pop_eh 
  for_undef_2254:
.annotate 'line', 1608
    set $P4644, $P4648
  if_4645_end:
.annotate 'line', 1541
    .return ($P4644)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4569"  :anon :subid("500_1303401201.841") :outer("499_1303401201.841")
.annotate 'line', 1568
    new $P4571, "Undef"
    .lex "$name", $P4571
.annotate 'line', 1573
    new $P4572, "Undef"
    .lex "$to_add", $P4572
.annotate 'line', 1568
    find_lex $P4573, "$/"
    unless_null $P4573, vivify_2219
    $P4573 = root_new ['parrot';'Hash']
  vivify_2219:
    set $P4574, $P4573["private"]
    unless_null $P4574, vivify_2220
    new $P4574, "Undef"
  vivify_2220:
    set $S4575, $P4574
    new $P4576, 'String'
    set $P4576, $S4575
    find_lex $P4577, "$/"
    unless_null $P4577, vivify_2221
    $P4577 = root_new ['parrot';'Hash']
  vivify_2221:
    set $P4578, $P4577["deflongname"]
    unless_null $P4578, vivify_2222
    $P4578 = root_new ['parrot';'ResizablePMCArray']
  vivify_2222:
    set $P4579, $P4578[0]
    unless_null $P4579, vivify_2223
    new $P4579, "Undef"
  vivify_2223:
    $P4580 = $P4579."ast"()
    set $S4581, $P4580
    concat $P4582, $P4576, $S4581
    store_lex "$name", $P4582
.annotate 'line', 1569
    find_lex $P4583, "$past"
    unless_null $P4583, vivify_2224
    new $P4583, "Undef"
  vivify_2224:
    find_lex $P4584, "$name"
    unless_null $P4584, vivify_2225
    new $P4584, "Undef"
  vivify_2225:
    $P4583."name"($P4584)
.annotate 'line', 1573
    find_dynamic_lex $P4587, "$*MULTINESS"
    unless_null $P4587, vivify_2226
    get_hll_global $P4587, "$MULTINESS"
    unless_null $P4587, vivify_2227
    die "Contextual $*MULTINESS not found"
  vivify_2227:
  vivify_2226:
    set $S4588, $P4587
    isne $I4589, $S4588, "proto"
    if $I4589, if_4586
.annotate 'line', 1575
    get_hll_global $P4593, ["PAST"], "Op"
.annotate 'line', 1577
    get_hll_global $P4594, ["PAST"], "Val"
    find_lex $P4595, "$past"
    unless_null $P4595, vivify_2228
    new $P4595, "Undef"
  vivify_2228:
    $P4596 = $P4594."new"($P4595 :named("value"))
.annotate 'line', 1578
    get_hll_global $P4597, ["PAST"], "Op"
    $P4598 = $P4597."new"("list" :named("pasttype"))
    $P4599 = $P4593."new"($P4596, $P4598, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 1575
    set $P4585, $P4599
.annotate 'line', 1573
    goto if_4586_end
  if_4586:
.annotate 'line', 1574
    get_hll_global $P4590, ["PAST"], "Val"
    find_lex $P4591, "$past"
    unless_null $P4591, vivify_2229
    new $P4591, "Undef"
  vivify_2229:
    $P4592 = $P4590."new"($P4591 :named("value"))
    set $P4585, $P4592
  if_4586_end:
.annotate 'line', 1573
    store_lex "$to_add", $P4585
.annotate 'line', 1580
    find_dynamic_lex $P4601, "$*MULTINESS"
    unless_null $P4601, vivify_2230
    get_hll_global $P4601, "$MULTINESS"
    unless_null $P4601, vivify_2231
    die "Contextual $*MULTINESS not found"
  vivify_2231:
  vivify_2230:
    set $S4602, $P4601
    iseq $I4603, $S4602, "proto"
    unless $I4603, if_4600_end
    find_lex $P4604, "$past"
    unless_null $P4604, vivify_2232
    new $P4604, "Undef"
  vivify_2232:
    $P4604."pirflags"(":instanceof(\"DispatcherSub\")")
  if_4600_end:
.annotate 'line', 1584
    find_dynamic_lex $P4606, "$*MULTINESS"
    unless_null $P4606, vivify_2233
    get_hll_global $P4606, "$MULTINESS"
    unless_null $P4606, vivify_2234
    die "Contextual $*MULTINESS not found"
  vivify_2234:
  vivify_2233:
    set $S4607, $P4606
    iseq $I4608, $S4607, "multi"
    unless $I4608, if_4605_end
    find_lex $P4609, "$past"
    unless_null $P4609, vivify_2235
    new $P4609, "Undef"
  vivify_2235:
    "attach_multi_signature"($P4609)
  if_4605_end:
.annotate 'line', 1587
    find_dynamic_lex $P4612, "$*PACKAGE-SETUP"
    unless_null $P4612, vivify_2236
    get_hll_global $P4612, "$PACKAGE-SETUP"
    unless_null $P4612, vivify_2237
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2237:
  vivify_2236:
    defined $I4613, $P4612
    if $I4613, if_4611
    new $P4610, 'Integer'
    set $P4610, $I4613
    goto if_4611_end
  if_4611:
.annotate 'line', 1588
    find_dynamic_lex $P4614, "$*PACKAGE-SETUP"
    unless_null $P4614, vivify_2238
    get_hll_global $P4614, "$PACKAGE-SETUP"
    unless_null $P4614, vivify_2239
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2239:
  vivify_2238:
    get_hll_global $P4615, ["PAST"], "Op"
.annotate 'line', 1589
    find_dynamic_lex $P4618, "$*MULTINESS"
    unless_null $P4618, vivify_2240
    get_hll_global $P4618, "$MULTINESS"
    unless_null $P4618, vivify_2241
    die "Contextual $*MULTINESS not found"
  vivify_2241:
  vivify_2240:
    set $S4619, $P4618
    iseq $I4620, $S4619, "multi"
    if $I4620, if_4617
    new $P4622, "String"
    assign $P4622, "add_method"
    set $P4616, $P4622
    goto if_4617_end
  if_4617:
    new $P4621, "String"
    assign $P4621, "add_multi_method"
    set $P4616, $P4621
  if_4617_end:
.annotate 'line', 1590
    get_hll_global $P4623, ["PAST"], "Op"
.annotate 'line', 1593
    get_hll_global $P4624, ["PAST"], "Var"
    $P4625 = $P4624."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4626 = $P4623."new"($P4625, "get_how PP" :named("pirop"))
.annotate 'line', 1595
    get_hll_global $P4627, ["PAST"], "Var"
    $P4628 = $P4627."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1596
    get_hll_global $P4629, ["PAST"], "Val"
    find_lex $P4630, "$name"
    unless_null $P4630, vivify_2242
    new $P4630, "Undef"
  vivify_2242:
    $P4631 = $P4629."new"($P4630 :named("value"))
    find_lex $P4632, "$to_add"
    unless_null $P4632, vivify_2243
    new $P4632, "Undef"
  vivify_2243:
    $P4633 = $P4615."new"($P4626, $P4628, $P4631, $P4632, "callmethod" :named("pasttype"), $P4616 :named("name"))
.annotate 'line', 1588
    $P4634 = $P4614."push"($P4633)
.annotate 'line', 1587
    set $P4610, $P4634
  if_4611_end:
.annotate 'line', 1566
    .return ($P4610)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4653"  :anon :subid("501_1303401201.841") :outer("499_1303401201.841")
    .param pmc param_4655
.annotate 'line', 1609
    .lex "$_", param_4655
    find_lex $P4656, "$_"
    unless_null $P4656, vivify_2255
    new $P4656, "Undef"
  vivify_2255:
    $P4657 = $P4656."ast"()
    find_lex $P4658, "$/"
    unless_null $P4658, vivify_2256
    new $P4658, "Undef"
  vivify_2256:
    $P4659 = $P4657($P4658)
    .return ($P4659)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "signature"  :subid("502_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_4666
    .param pmc param_4667
.annotate 'line', 1641
    .const 'Sub' $P4704 = "504_1303401201.841" 
    capture_lex $P4704
    .const 'Sub' $P4678 = "503_1303401201.841" 
    capture_lex $P4678
    .lex "self", param_4666
    .lex "$/", param_4667
.annotate 'line', 1642
    new $P4668, "Undef"
    .lex "$BLOCKINIT", $P4668
    find_lex $P4669, "$?PACKAGE"
    get_who $P4670, $P4669
    set $P4671, $P4670["@BLOCK"]
    unless_null $P4671, vivify_2257
    $P4671 = root_new ['parrot';'ResizablePMCArray']
  vivify_2257:
    set $P4672, $P4671[0]
    unless_null $P4672, vivify_2258
    $P4672 = root_new ['parrot';'ResizablePMCArray']
  vivify_2258:
    set $P4673, $P4672[0]
    unless_null $P4673, vivify_2259
    new $P4673, "Undef"
  vivify_2259:
    store_lex "$BLOCKINIT", $P4673
.annotate 'line', 1643
    find_lex $P4675, "$/"
    unless_null $P4675, vivify_2260
    $P4675 = root_new ['parrot';'Hash']
  vivify_2260:
    set $P4676, $P4675["invocant"]
    unless_null $P4676, vivify_2261
    new $P4676, "Undef"
  vivify_2261:
    unless $P4676, if_4674_end
    .const 'Sub' $P4678 = "503_1303401201.841" 
    capture_lex $P4678
    $P4678()
  if_4674_end:
.annotate 'line', 1652
    find_lex $P4699, "$/"
    unless_null $P4699, vivify_2271
    $P4699 = root_new ['parrot';'Hash']
  vivify_2271:
    set $P4700, $P4699["parameter"]
    unless_null $P4700, vivify_2272
    new $P4700, "Undef"
  vivify_2272:
    defined $I4701, $P4700
    unless $I4701, for_undef_2273
    iter $P4698, $P4700
    new $P4711, 'ExceptionHandler'
    set_label $P4711, loop4710_handler
    $P4711."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4711
  loop4710_test:
    unless $P4698, loop4710_done
    shift $P4702, $P4698
  loop4710_redo:
    .const 'Sub' $P4704 = "504_1303401201.841" 
    capture_lex $P4704
    $P4704($P4702)
  loop4710_next:
    goto loop4710_test
  loop4710_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4712, exception, 'type'
    eq $P4712, .CONTROL_LOOP_NEXT, loop4710_next
    eq $P4712, .CONTROL_LOOP_REDO, loop4710_redo
  loop4710_done:
    pop_eh 
  for_undef_2273:
.annotate 'line', 1641
    .return ($P4698)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4677"  :anon :subid("503_1303401201.841") :outer("502_1303401201.841")
.annotate 'line', 1644
    new $P4679, "Undef"
    .lex "$inv", $P4679
    find_lex $P4680, "$/"
    unless_null $P4680, vivify_2262
    $P4680 = root_new ['parrot';'Hash']
  vivify_2262:
    set $P4681, $P4680["invocant"]
    unless_null $P4681, vivify_2263
    $P4681 = root_new ['parrot';'ResizablePMCArray']
  vivify_2263:
    set $P4682, $P4681[0]
    unless_null $P4682, vivify_2264
    new $P4682, "Undef"
  vivify_2264:
    $P4683 = $P4682."ast"()
    store_lex "$inv", $P4683
.annotate 'line', 1645
    find_lex $P4684, "$BLOCKINIT"
    unless_null $P4684, vivify_2265
    new $P4684, "Undef"
  vivify_2265:
    find_lex $P4685, "$inv"
    unless_null $P4685, vivify_2266
    new $P4685, "Undef"
  vivify_2266:
    $P4684."push"($P4685)
.annotate 'line', 1646
    find_lex $P4686, "$BLOCKINIT"
    unless_null $P4686, vivify_2267
    new $P4686, "Undef"
  vivify_2267:
    get_hll_global $P4687, ["PAST"], "Var"
.annotate 'line', 1648
    get_hll_global $P4688, ["PAST"], "Var"
    find_lex $P4689, "$inv"
    unless_null $P4689, vivify_2268
    new $P4689, "Undef"
  vivify_2268:
    $P4690 = $P4689."name"()
    $P4691 = $P4688."new"("lexical" :named("scope"), $P4690 :named("name"))
    $P4692 = $P4687."new"("self" :named("name"), "lexical" :named("scope"), 1 :named("isdecl"), $P4691 :named("viviself"))
.annotate 'line', 1646
    $P4686."push"($P4692)
.annotate 'line', 1650
    new $P4693, "Integer"
    assign $P4693, 1
    find_lex $P4694, "$?PACKAGE"
    get_who $P4695, $P4694
    set $P4696, $P4695["@BLOCK"]
    unless_null $P4696, vivify_2269
    $P4696 = root_new ['parrot';'ResizablePMCArray']
    set $P4695["@BLOCK"], $P4696
  vivify_2269:
    set $P4697, $P4696[0]
    unless_null $P4697, vivify_2270
    $P4697 = root_new ['parrot';'Hash']
    set $P4696[0], $P4697
  vivify_2270:
    set $P4697["signature_has_invocant"], $P4693
.annotate 'line', 1643
    .return ($P4693)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4703"  :anon :subid("504_1303401201.841") :outer("502_1303401201.841")
    .param pmc param_4705
.annotate 'line', 1652
    .lex "$_", param_4705
    find_lex $P4706, "$BLOCKINIT"
    unless_null $P4706, vivify_2274
    new $P4706, "Undef"
  vivify_2274:
    find_lex $P4707, "$_"
    unless_null $P4707, vivify_2275
    new $P4707, "Undef"
  vivify_2275:
    $P4708 = $P4707."ast"()
    $P4709 = $P4706."push"($P4708)
    .return ($P4709)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "parameter"  :subid("505_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_4714
    .param pmc param_4715
.annotate 'line', 1655
    .lex "self", param_4714
    .lex "$/", param_4715
.annotate 'line', 1656
    new $P4716, "Undef"
    .lex "$quant", $P4716
.annotate 'line', 1657
    new $P4717, "Undef"
    .lex "$past", $P4717
.annotate 'line', 1656
    find_lex $P4718, "$/"
    unless_null $P4718, vivify_2276
    $P4718 = root_new ['parrot';'Hash']
  vivify_2276:
    set $P4719, $P4718["quant"]
    unless_null $P4719, vivify_2277
    new $P4719, "Undef"
  vivify_2277:
    store_lex "$quant", $P4719
    find_lex $P4720, "$past"
    unless_null $P4720, vivify_2278
    new $P4720, "Undef"
  vivify_2278:
.annotate 'line', 1658
    find_lex $P4722, "$/"
    unless_null $P4722, vivify_2279
    $P4722 = root_new ['parrot';'Hash']
  vivify_2279:
    set $P4723, $P4722["named_param"]
    unless_null $P4723, vivify_2280
    new $P4723, "Undef"
  vivify_2280:
    if $P4723, if_4721
.annotate 'line', 1665
    find_lex $P4737, "$/"
    unless_null $P4737, vivify_2281
    $P4737 = root_new ['parrot';'Hash']
  vivify_2281:
    set $P4738, $P4737["param_var"]
    unless_null $P4738, vivify_2282
    new $P4738, "Undef"
  vivify_2282:
    $P4739 = $P4738."ast"()
    store_lex "$past", $P4739
.annotate 'line', 1666
    find_lex $P4741, "$quant"
    unless_null $P4741, vivify_2283
    new $P4741, "Undef"
  vivify_2283:
    set $S4742, $P4741
    iseq $I4743, $S4742, "*"
    if $I4743, if_4740
.annotate 'line', 1670
    find_lex $P4752, "$quant"
    unless_null $P4752, vivify_2284
    new $P4752, "Undef"
  vivify_2284:
    set $S4753, $P4752
    iseq $I4754, $S4753, "?"
    unless $I4754, if_4751_end
.annotate 'line', 1671
    find_lex $P4755, "$past"
    unless_null $P4755, vivify_2285
    new $P4755, "Undef"
  vivify_2285:
    find_lex $P4756, "$/"
    unless_null $P4756, vivify_2286
    $P4756 = root_new ['parrot';'Hash']
  vivify_2286:
    set $P4757, $P4756["param_var"]
    unless_null $P4757, vivify_2287
    $P4757 = root_new ['parrot';'Hash']
  vivify_2287:
    set $P4758, $P4757["sigil"]
    unless_null $P4758, vivify_2288
    new $P4758, "Undef"
  vivify_2288:
    $P4759 = "vivitype"($P4758)
    $P4755."viviself"($P4759)
  if_4751_end:
.annotate 'line', 1670
    goto if_4740_end
  if_4740:
.annotate 'line', 1667
    find_lex $P4744, "$past"
    unless_null $P4744, vivify_2289
    new $P4744, "Undef"
  vivify_2289:
    $P4744."slurpy"(1)
.annotate 'line', 1668
    find_lex $P4745, "$past"
    unless_null $P4745, vivify_2290
    new $P4745, "Undef"
  vivify_2290:
    find_lex $P4746, "$/"
    unless_null $P4746, vivify_2291
    $P4746 = root_new ['parrot';'Hash']
  vivify_2291:
    set $P4747, $P4746["param_var"]
    unless_null $P4747, vivify_2292
    $P4747 = root_new ['parrot';'Hash']
  vivify_2292:
    set $P4748, $P4747["sigil"]
    unless_null $P4748, vivify_2293
    new $P4748, "Undef"
  vivify_2293:
    set $S4749, $P4748
    iseq $I4750, $S4749, "%"
    $P4745."named"($I4750)
  if_4740_end:
.annotate 'line', 1664
    goto if_4721_end
  if_4721:
.annotate 'line', 1659
    find_lex $P4724, "$/"
    unless_null $P4724, vivify_2294
    $P4724 = root_new ['parrot';'Hash']
  vivify_2294:
    set $P4725, $P4724["named_param"]
    unless_null $P4725, vivify_2295
    new $P4725, "Undef"
  vivify_2295:
    $P4726 = $P4725."ast"()
    store_lex "$past", $P4726
.annotate 'line', 1660
    find_lex $P4728, "$quant"
    unless_null $P4728, vivify_2296
    new $P4728, "Undef"
  vivify_2296:
    set $S4729, $P4728
    isne $I4730, $S4729, "!"
    unless $I4730, if_4727_end
.annotate 'line', 1661
    find_lex $P4731, "$past"
    unless_null $P4731, vivify_2297
    new $P4731, "Undef"
  vivify_2297:
    find_lex $P4732, "$/"
    unless_null $P4732, vivify_2298
    $P4732 = root_new ['parrot';'Hash']
  vivify_2298:
    set $P4733, $P4732["named_param"]
    unless_null $P4733, vivify_2299
    $P4733 = root_new ['parrot';'Hash']
  vivify_2299:
    set $P4734, $P4733["param_var"]
    unless_null $P4734, vivify_2300
    $P4734 = root_new ['parrot';'Hash']
  vivify_2300:
    set $P4735, $P4734["sigil"]
    unless_null $P4735, vivify_2301
    new $P4735, "Undef"
  vivify_2301:
    $P4736 = "vivitype"($P4735)
    $P4731."viviself"($P4736)
  if_4727_end:
  if_4721_end:
.annotate 'line', 1674
    find_lex $P4761, "$/"
    unless_null $P4761, vivify_2302
    $P4761 = root_new ['parrot';'Hash']
  vivify_2302:
    set $P4762, $P4761["default_value"]
    unless_null $P4762, vivify_2303
    new $P4762, "Undef"
  vivify_2303:
    unless $P4762, if_4760_end
.annotate 'line', 1675
    find_lex $P4764, "$quant"
    unless_null $P4764, vivify_2304
    new $P4764, "Undef"
  vivify_2304:
    set $S4765, $P4764
    iseq $I4766, $S4765, "*"
    unless $I4766, if_4763_end
.annotate 'line', 1676
    find_lex $P4767, "$/"
    unless_null $P4767, vivify_2305
    new $P4767, "Undef"
  vivify_2305:
    $P4768 = $P4767."CURSOR"()
    $P4768."panic"("Can't put default on slurpy parameter")
  if_4763_end:
.annotate 'line', 1678
    find_lex $P4770, "$quant"
    unless_null $P4770, vivify_2306
    new $P4770, "Undef"
  vivify_2306:
    set $S4771, $P4770
    iseq $I4772, $S4771, "!"
    unless $I4772, if_4769_end
.annotate 'line', 1679
    find_lex $P4773, "$/"
    unless_null $P4773, vivify_2307
    new $P4773, "Undef"
  vivify_2307:
    $P4774 = $P4773."CURSOR"()
    $P4774."panic"("Can't put default on required parameter")
  if_4769_end:
.annotate 'line', 1681
    find_lex $P4775, "$past"
    unless_null $P4775, vivify_2308
    new $P4775, "Undef"
  vivify_2308:
    find_lex $P4776, "$/"
    unless_null $P4776, vivify_2309
    $P4776 = root_new ['parrot';'Hash']
  vivify_2309:
    set $P4777, $P4776["default_value"]
    unless_null $P4777, vivify_2310
    $P4777 = root_new ['parrot';'ResizablePMCArray']
  vivify_2310:
    set $P4778, $P4777[0]
    unless_null $P4778, vivify_2311
    $P4778 = root_new ['parrot';'Hash']
  vivify_2311:
    set $P4779, $P4778["EXPR"]
    unless_null $P4779, vivify_2312
    new $P4779, "Undef"
  vivify_2312:
    $P4780 = $P4779."ast"()
    $P4775."viviself"($P4780)
  if_4760_end:
.annotate 'line', 1683
    find_lex $P4782, "$past"
    unless_null $P4782, vivify_2313
    new $P4782, "Undef"
  vivify_2313:
    $P4783 = $P4782."viviself"()
    if $P4783, unless_4781_end
    find_lex $P4784, "$?PACKAGE"
    get_who $P4785, $P4784
    set $P4786, $P4785["@BLOCK"]
    unless_null $P4786, vivify_2314
    $P4786 = root_new ['parrot';'ResizablePMCArray']
  vivify_2314:
    set $P4787, $P4786[0]
    unless_null $P4787, vivify_2315
    new $P4787, "Undef"
  vivify_2315:
    find_lex $P4788, "$?PACKAGE"
    get_who $P4789, $P4788
    set $P4790, $P4789["@BLOCK"]
    unless_null $P4790, vivify_2316
    $P4790 = root_new ['parrot';'ResizablePMCArray']
  vivify_2316:
    set $P4791, $P4790[0]
    unless_null $P4791, vivify_2317
    new $P4791, "Undef"
  vivify_2317:
    $P4792 = $P4791."arity"()
    set $N4793, $P4792
    new $P4794, 'Float'
    set $P4794, $N4793
    add $P4795, $P4794, 1
    $P4787."arity"($P4795)
  unless_4781_end:
.annotate 'line', 1687
    find_lex $P4797, "$/"
    unless_null $P4797, vivify_2318
    $P4797 = root_new ['parrot';'Hash']
  vivify_2318:
    set $P4798, $P4797["typename"]
    unless_null $P4798, vivify_2319
    new $P4798, "Undef"
  vivify_2319:
    unless $P4798, if_4796_end
.annotate 'line', 1688
    find_lex $P4799, "$past"
    unless_null $P4799, vivify_2320
    new $P4799, "Undef"
  vivify_2320:
    find_lex $P4800, "$/"
    unless_null $P4800, vivify_2321
    $P4800 = root_new ['parrot';'Hash']
  vivify_2321:
    set $P4801, $P4800["typename"]
    unless_null $P4801, vivify_2322
    $P4801 = root_new ['parrot';'ResizablePMCArray']
  vivify_2322:
    set $P4802, $P4801[0]
    unless_null $P4802, vivify_2323
    new $P4802, "Undef"
  vivify_2323:
    $P4803 = $P4802."ast"()
    $P4799."multitype"($P4803)
  if_4796_end:
.annotate 'line', 1692
    find_lex $P4805, "$/"
    unless_null $P4805, vivify_2324
    $P4805 = root_new ['parrot';'Hash']
  vivify_2324:
    set $P4806, $P4805["definedness"]
    unless_null $P4806, vivify_2325
    new $P4806, "Undef"
  vivify_2325:
    unless $P4806, if_4804_end
.annotate 'line', 1693
    find_lex $P4807, "$/"
    unless_null $P4807, vivify_2326
    $P4807 = root_new ['parrot';'Hash']
  vivify_2326:
    set $P4808, $P4807["definedness"]
    unless_null $P4808, vivify_2327
    $P4808 = root_new ['parrot';'ResizablePMCArray']
  vivify_2327:
    set $P4809, $P4808[0]
    unless_null $P4809, vivify_2328
    new $P4809, "Undef"
  vivify_2328:
    set $S4810, $P4809
    new $P4811, 'String'
    set $P4811, $S4810
    find_lex $P4812, "$past"
    unless_null $P4812, vivify_2329
    $P4812 = root_new ['parrot';'Hash']
    store_lex "$past", $P4812
  vivify_2329:
    set $P4812["definedness"], $P4811
  if_4804_end:
.annotate 'line', 1696
    find_lex $P4813, "$/"
    find_lex $P4814, "$past"
    unless_null $P4814, vivify_2330
    new $P4814, "Undef"
  vivify_2330:
    $P4815 = $P4813."!make"($P4814)
.annotate 'line', 1655
    .return ($P4815)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "param_var"  :subid("506_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_4817
    .param pmc param_4818
.annotate 'line', 1699
    .lex "self", param_4817
    .lex "$/", param_4818
.annotate 'line', 1700
    new $P4819, "Undef"
    .lex "$name", $P4819
.annotate 'line', 1701
    new $P4820, "Undef"
    .lex "$past", $P4820
.annotate 'line', 1700
    find_lex $P4821, "$/"
    unless_null $P4821, vivify_2331
    new $P4821, "Undef"
  vivify_2331:
    set $S4822, $P4821
    new $P4823, 'String'
    set $P4823, $S4822
    store_lex "$name", $P4823
.annotate 'line', 1701
    get_hll_global $P4824, ["PAST"], "Var"
    find_lex $P4825, "$name"
    unless_null $P4825, vivify_2332
    new $P4825, "Undef"
  vivify_2332:
    find_lex $P4826, "$/"
    unless_null $P4826, vivify_2333
    new $P4826, "Undef"
  vivify_2333:
    $P4827 = $P4824."new"($P4825 :named("name"), "parameter" :named("scope"), 1 :named("isdecl"), $P4826 :named("node"))
    store_lex "$past", $P4827
.annotate 'line', 1703
    find_lex $P4828, "$?PACKAGE"
    get_who $P4829, $P4828
    set $P4830, $P4829["@BLOCK"]
    unless_null $P4830, vivify_2334
    $P4830 = root_new ['parrot';'ResizablePMCArray']
  vivify_2334:
    set $P4831, $P4830[0]
    unless_null $P4831, vivify_2335
    new $P4831, "Undef"
  vivify_2335:
    find_lex $P4832, "$name"
    unless_null $P4832, vivify_2336
    new $P4832, "Undef"
  vivify_2336:
    $P4831."symbol"($P4832, "lexical" :named("scope"))
.annotate 'line', 1704
    find_lex $P4833, "$/"
    find_lex $P4834, "$past"
    unless_null $P4834, vivify_2337
    new $P4834, "Undef"
  vivify_2337:
    $P4835 = $P4833."!make"($P4834)
.annotate 'line', 1699
    .return ($P4835)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "named_param"  :subid("507_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_4837
    .param pmc param_4838
.annotate 'line', 1707
    .lex "self", param_4837
    .lex "$/", param_4838
.annotate 'line', 1708
    new $P4839, "Undef"
    .lex "$past", $P4839
    find_lex $P4840, "$/"
    unless_null $P4840, vivify_2338
    $P4840 = root_new ['parrot';'Hash']
  vivify_2338:
    set $P4841, $P4840["param_var"]
    unless_null $P4841, vivify_2339
    new $P4841, "Undef"
  vivify_2339:
    $P4842 = $P4841."ast"()
    store_lex "$past", $P4842
.annotate 'line', 1709
    find_lex $P4843, "$past"
    unless_null $P4843, vivify_2340
    new $P4843, "Undef"
  vivify_2340:
    find_lex $P4844, "$/"
    unless_null $P4844, vivify_2341
    $P4844 = root_new ['parrot';'Hash']
  vivify_2341:
    set $P4845, $P4844["param_var"]
    unless_null $P4845, vivify_2342
    $P4845 = root_new ['parrot';'Hash']
  vivify_2342:
    set $P4846, $P4845["name"]
    unless_null $P4846, vivify_2343
    new $P4846, "Undef"
  vivify_2343:
    set $S4847, $P4846
    $P4843."named"($S4847)
.annotate 'line', 1710
    find_lex $P4848, "$/"
    find_lex $P4849, "$past"
    unless_null $P4849, vivify_2344
    new $P4849, "Undef"
  vivify_2344:
    $P4850 = $P4848."!make"($P4849)
.annotate 'line', 1707
    .return ($P4850)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "typename"  :subid("508_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_4852
    .param pmc param_4853
.annotate 'line', 1713
    .lex "self", param_4852
    .lex "$/", param_4853
.annotate 'line', 1714
    $P4854 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P4854
    get_hll_global $P4855, ["HLL"], "Compiler"
    find_lex $P4856, "$/"
    unless_null $P4856, vivify_2345
    new $P4856, "Undef"
  vivify_2345:
    set $S4857, $P4856
    $P4858 = $P4855."parse_name"($S4857)
    store_lex "@name", $P4858
.annotate 'line', 1715
    find_lex $P4859, "$/"
    get_hll_global $P4860, ["PAST"], "Var"
.annotate 'line', 1716
    find_lex $P4861, "@name"
    unless_null $P4861, vivify_2346
    $P4861 = root_new ['parrot';'ResizablePMCArray']
  vivify_2346:
    $P4862 = $P4861."pop"()
    find_lex $P4863, "@name"
    unless_null $P4863, vivify_2347
    $P4863 = root_new ['parrot';'ResizablePMCArray']
  vivify_2347:
    $P4864 = $P4860."new"($P4862 :named("name"), $P4863 :named("namespace"), "package" :named("scope"))
.annotate 'line', 1715
    $P4865 = $P4859."!make"($P4864)
.annotate 'line', 1713
    .return ($P4865)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait"  :subid("509_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_4867
    .param pmc param_4868
.annotate 'line', 1722
    .lex "self", param_4867
    .lex "$/", param_4868
.annotate 'line', 1723
    find_lex $P4869, "$/"
    find_lex $P4870, "$/"
    unless_null $P4870, vivify_2348
    $P4870 = root_new ['parrot';'Hash']
  vivify_2348:
    set $P4871, $P4870["trait_mod"]
    unless_null $P4871, vivify_2349
    new $P4871, "Undef"
  vivify_2349:
    $P4872 = $P4871."ast"()
    $P4873 = $P4869."!make"($P4872)
.annotate 'line', 1722
    .return ($P4873)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait_mod:sym<is>"  :subid("510_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_4875
    .param pmc param_4876
.annotate 'line', 1726
    .const 'Sub' $P4896 = "511_1303401201.841" 
    capture_lex $P4896
    .lex "self", param_4875
    .lex "$/", param_4876
.annotate 'line', 1727
    new $P4877, "Undef"
    .lex "$cpast", $P4877
    find_lex $P4878, "$/"
    unless_null $P4878, vivify_2350
    $P4878 = root_new ['parrot';'Hash']
  vivify_2350:
    set $P4879, $P4878["circumfix"]
    unless_null $P4879, vivify_2351
    $P4879 = root_new ['parrot';'ResizablePMCArray']
  vivify_2351:
    set $P4880, $P4879[0]
    unless_null $P4880, vivify_2352
    new $P4880, "Undef"
  vivify_2352:
    $P4881 = $P4880."ast"()
    store_lex "$cpast", $P4881
.annotate 'line', 1728
    find_lex $P4884, "$/"
    unless_null $P4884, vivify_2353
    $P4884 = root_new ['parrot';'Hash']
  vivify_2353:
    set $P4885, $P4884["longname"]
    unless_null $P4885, vivify_2354
    new $P4885, "Undef"
  vivify_2354:
    set $S4886, $P4885
    iseq $I4887, $S4886, "parrot_vtable"
    if $I4887, if_4883
.annotate 'line', 1748
    find_lex $P4922, "$/"
    unless_null $P4922, vivify_2355
    $P4922 = root_new ['parrot';'Hash']
  vivify_2355:
    set $P4923, $P4922["longname"]
    unless_null $P4923, vivify_2356
    new $P4923, "Undef"
  vivify_2356:
    set $S4924, $P4923
    iseq $I4925, $S4924, "pirflags"
    if $I4925, if_4921
.annotate 'line', 1752
    find_lex $P4929, "$/"
    unless_null $P4929, vivify_2357
    new $P4929, "Undef"
  vivify_2357:
    $P4930 = $P4929."CURSOR"()
    new $P4931, 'String'
    set $P4931, "Trait '"
    find_lex $P4932, "$/"
    unless_null $P4932, vivify_2358
    $P4932 = root_new ['parrot';'Hash']
  vivify_2358:
    set $P4933, $P4932["longname"]
    unless_null $P4933, vivify_2359
    new $P4933, "Undef"
  vivify_2359:
    concat $P4934, $P4931, $P4933
    concat $P4935, $P4934, "' not implemented"
    $P4936 = $P4930."panic"($P4935)
.annotate 'line', 1751
    set $P4920, $P4936
.annotate 'line', 1748
    goto if_4921_end
  if_4921:
.annotate 'line', 1749
    find_lex $P4926, "$/"
    unless_null $P4926, vivify_2360
    new $P4926, "Undef"
  vivify_2360:
    $P4927 = $P4926."CURSOR"()
    $P4928 = $P4927."panic"("Trait 'pirflags' no longer supported; use 'is vtable'")
.annotate 'line', 1748
    set $P4920, $P4928
  if_4921_end:
    set $P4882, $P4920
.annotate 'line', 1728
    goto if_4883_end
  if_4883:
.annotate 'line', 1731
    get_hll_global $P4889, ["PAST"], "Val"
    find_lex $P4890, "$cpast"
    unless_null $P4890, vivify_2361
    new $P4890, "Undef"
  vivify_2361:
    $P4891 = $P4889."ACCEPTS"($P4890)
    if $P4891, unless_4888_end
.annotate 'line', 1730
    find_lex $P4892, "$/"
    unless_null $P4892, vivify_2362
    new $P4892, "Undef"
  vivify_2362:
    $P4893 = $P4892."CURSOR"()
    $P4893."panic"("Trait 'parrot_vtable' requires constant scalar argument")
  unless_4888_end:
.annotate 'line', 1732
    find_lex $P4894, "$/"
    .const 'Sub' $P4896 = "511_1303401201.841" 
    newclosure $P4918, $P4896
    $P4919 = $P4894."!make"($P4918)
.annotate 'line', 1728
    set $P4882, $P4919
  if_4883_end:
.annotate 'line', 1726
    .return ($P4882)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4895"  :anon :subid("511_1303401201.841") :outer("510_1303401201.841")
    .param pmc param_4897
.annotate 'line', 1732
    .lex "$match", param_4897
.annotate 'line', 1733
    new $P4898, "Undef"
    .lex "$meth", $P4898
    find_lex $P4899, "$match"
    unless_null $P4899, vivify_2363
    new $P4899, "Undef"
  vivify_2363:
    $P4900 = $P4899."ast"()
    set $P4901, $P4900["block_past"]
    unless_null $P4901, vivify_2364
    new $P4901, "Undef"
  vivify_2364:
    store_lex "$meth", $P4901
.annotate 'line', 1734
    find_dynamic_lex $P4904, "$*PACKAGE-SETUP"
    unless_null $P4904, vivify_2365
    get_hll_global $P4904, "$PACKAGE-SETUP"
    unless_null $P4904, vivify_2366
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2366:
  vivify_2365:
    defined $I4905, $P4904
    if $I4905, if_4903
    new $P4902, 'Integer'
    set $P4902, $I4905
    goto if_4903_end
  if_4903:
.annotate 'line', 1735
    find_dynamic_lex $P4906, "$*PACKAGE-SETUP"
    unless_null $P4906, vivify_2367
    get_hll_global $P4906, "$PACKAGE-SETUP"
    unless_null $P4906, vivify_2368
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2368:
  vivify_2367:
    get_hll_global $P4907, ["PAST"], "Op"
.annotate 'line', 1737
    get_hll_global $P4908, ["PAST"], "Op"
.annotate 'line', 1740
    get_hll_global $P4909, ["PAST"], "Var"
    $P4910 = $P4909."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4911 = $P4908."new"($P4910, "get_how PP" :named("pirop"))
.annotate 'line', 1742
    get_hll_global $P4912, ["PAST"], "Var"
    $P4913 = $P4912."new"("type_obj" :named("name"), "register" :named("scope"))
    find_lex $P4914, "$cpast"
    unless_null $P4914, vivify_2369
    new $P4914, "Undef"
  vivify_2369:
    find_lex $P4915, "$meth"
    unless_null $P4915, vivify_2370
    new $P4915, "Undef"
  vivify_2370:
    $P4916 = $P4907."new"($P4911, $P4913, $P4914, $P4915, "callmethod" :named("pasttype"), "add_parrot_vtable_mapping" :named("name"))
.annotate 'line', 1735
    $P4917 = $P4906."push"($P4916)
.annotate 'line', 1734
    set $P4902, $P4917
  if_4903_end:
.annotate 'line', 1732
    .return ($P4902)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "regex_declarator"  :subid("512_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_4940
    .param pmc param_4941
    .param pmc param_4942 :optional
    .param int has_param_4942 :opt_flag
.annotate 'line', 1756
    .const 'Sub' $P5049 = "515_1303401201.841" 
    capture_lex $P5049
    .const 'Sub' $P5014 = "514_1303401201.841" 
    capture_lex $P5014
    .const 'Sub' $P4987 = "513_1303401201.841" 
    capture_lex $P4987
    new $P4939, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P4939, control_4938
    push_eh $P4939
    .lex "self", param_4940
    .lex "$/", param_4941
    if has_param_4942, optparam_2371
    new $P4943, "Undef"
    set param_4942, $P4943
  optparam_2371:
    .lex "$key", param_4942
.annotate 'line', 1757
    $P4944 = root_new ['parrot';'ResizablePMCArray']
    .lex "@MODIFIERS", $P4944
.annotate 'line', 1758
    new $P4945, "Undef"
    .lex "$name", $P4945
.annotate 'line', 1759
    new $P4946, "Undef"
    .lex "$past", $P4946
.annotate 'line', 1757
    get_hll_global $P4947, ["Regex";"P6Regex"], "Actions"
    get_who $P4948, $P4947
    set $P4949, $P4948["@MODIFIERS"]
    unless_null $P4949, vivify_2372
    $P4949 = root_new ['parrot';'ResizablePMCArray']
  vivify_2372:
    store_lex "@MODIFIERS", $P4949
.annotate 'line', 1758
    find_lex $P4950, "$/"
    unless_null $P4950, vivify_2373
    $P4950 = root_new ['parrot';'Hash']
  vivify_2373:
    set $P4951, $P4950["deflongname"]
    unless_null $P4951, vivify_2374
    new $P4951, "Undef"
  vivify_2374:
    $P4952 = $P4951."ast"()
    set $S4953, $P4952
    new $P4954, 'String'
    set $P4954, $S4953
    store_lex "$name", $P4954
    find_lex $P4955, "$past"
    unless_null $P4955, vivify_2375
    new $P4955, "Undef"
  vivify_2375:
.annotate 'line', 1760
    find_lex $P4957, "$/"
    unless_null $P4957, vivify_2376
    $P4957 = root_new ['parrot';'Hash']
  vivify_2376:
    set $P4958, $P4957["proto"]
    unless_null $P4958, vivify_2377
    new $P4958, "Undef"
  vivify_2377:
    if $P4958, if_4956
.annotate 'line', 1799
    find_lex $P5010, "$key"
    unless_null $P5010, vivify_2378
    new $P5010, "Undef"
  vivify_2378:
    set $S5011, $P5010
    iseq $I5012, $S5011, "open"
    if $I5012, if_5009
.annotate 'line', 1809
    .const 'Sub' $P5049 = "515_1303401201.841" 
    capture_lex $P5049
    $P5049()
    goto if_5009_end
  if_5009:
.annotate 'line', 1799
    .const 'Sub' $P5014 = "514_1303401201.841" 
    capture_lex $P5014
    $P5014()
  if_5009_end:
    goto if_4956_end
  if_4956:
.annotate 'line', 1762
    get_hll_global $P4959, ["PAST"], "Stmts"
.annotate 'line', 1763
    get_hll_global $P4960, ["PAST"], "Block"
    find_lex $P4961, "$name"
    unless_null $P4961, vivify_2413
    new $P4961, "Undef"
  vivify_2413:
.annotate 'line', 1764
    get_hll_global $P4962, ["PAST"], "Op"
.annotate 'line', 1765
    get_hll_global $P4963, ["PAST"], "Var"
    $P4964 = $P4963."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P4965, "$name"
    unless_null $P4965, vivify_2414
    new $P4965, "Undef"
  vivify_2414:
    $P4966 = $P4962."new"($P4964, $P4965, "!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 1764
    find_lex $P4967, "$/"
    unless_null $P4967, vivify_2415
    new $P4967, "Undef"
  vivify_2415:
    $P4968 = $P4960."new"($P4966, $P4961 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P4967 :named("node"))
.annotate 'line', 1774
    get_hll_global $P4969, ["PAST"], "Block"
    new $P4970, "String"
    assign $P4970, "!PREFIX__"
    find_lex $P4971, "$name"
    unless_null $P4971, vivify_2416
    new $P4971, "Undef"
  vivify_2416:
    concat $P4972, $P4970, $P4971
.annotate 'line', 1775
    get_hll_global $P4973, ["PAST"], "Op"
.annotate 'line', 1776
    get_hll_global $P4974, ["PAST"], "Var"
    $P4975 = $P4974."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P4976, "$name"
    unless_null $P4976, vivify_2417
    new $P4976, "Undef"
  vivify_2417:
    $P4977 = $P4973."new"($P4975, $P4976, "!PREFIX__!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 1775
    find_lex $P4978, "$/"
    unless_null $P4978, vivify_2418
    new $P4978, "Undef"
  vivify_2418:
    $P4979 = $P4969."new"($P4977, $P4972 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P4978 :named("node"))
.annotate 'line', 1774
    $P4980 = $P4959."new"($P4968, $P4979)
.annotate 'line', 1762
    store_lex "$past", $P4980
.annotate 'line', 1786
    find_lex $P4982, "$past"
    unless_null $P4982, vivify_2419
    new $P4982, "Undef"
  vivify_2419:
    $P4983 = $P4982."list"()
    defined $I4984, $P4983
    unless $I4984, for_undef_2420
    iter $P4981, $P4983
    new $P5007, 'ExceptionHandler'
    set_label $P5007, loop5006_handler
    $P5007."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5007
  loop5006_test:
    unless $P4981, loop5006_done
    shift $P4985, $P4981
  loop5006_redo:
    .const 'Sub' $P4987 = "513_1303401201.841" 
    capture_lex $P4987
    $P4987($P4985)
  loop5006_next:
    goto loop5006_test
  loop5006_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5008, exception, 'type'
    eq $P5008, .CONTROL_LOOP_NEXT, loop5006_next
    eq $P5008, .CONTROL_LOOP_REDO, loop5006_redo
  loop5006_done:
    pop_eh 
  for_undef_2420:
  if_4956_end:
.annotate 'line', 1845
    find_lex $P5109, "$/"
    find_lex $P5110, "$past"
    unless_null $P5110, vivify_2425
    new $P5110, "Undef"
  vivify_2425:
    $P5111 = $P5109."!make"($P5110)
.annotate 'line', 1756
    .return ($P5111)
  control_4938:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5112, exception, "payload"
    .return ($P5112)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5048"  :anon :subid("515_1303401201.841") :outer("512_1303401201.841")
.annotate 'line', 1810
    new $P5050, "Undef"
    .lex "$regex", $P5050
.annotate 'line', 1811
    get_hll_global $P5051, ["Regex";"P6Regex";"Actions"], "buildsub"
    find_lex $P5052, "$/"
    unless_null $P5052, vivify_2379
    $P5052 = root_new ['parrot';'Hash']
  vivify_2379:
    set $P5053, $P5052["p6regex"]
    unless_null $P5053, vivify_2380
    new $P5053, "Undef"
  vivify_2380:
    $P5054 = $P5053."ast"()
    find_lex $P5055, "$?PACKAGE"
    get_who $P5056, $P5055
    set $P5057, $P5056["@BLOCK"]
    unless_null $P5057, vivify_2381
    $P5057 = root_new ['parrot';'ResizablePMCArray']
  vivify_2381:
    $P5058 = $P5057."shift"()
    $P5059 = $P5051($P5054, $P5058)
    store_lex "$regex", $P5059
.annotate 'line', 1812
    find_lex $P5060, "$regex"
    unless_null $P5060, vivify_2382
    new $P5060, "Undef"
  vivify_2382:
    find_lex $P5061, "$name"
    unless_null $P5061, vivify_2383
    new $P5061, "Undef"
  vivify_2383:
    $P5060."name"($P5061)
.annotate 'line', 1814
    get_hll_global $P5062, ["PAST"], "Op"
.annotate 'line', 1816
    get_hll_global $P5063, ["PAST"], "Var"
    new $P5064, "ResizablePMCArray"
    push $P5064, "Regex"
    $P5065 = $P5063."new"("Method" :named("name"), $P5064 :named("namespace"), "package" :named("scope"))
    find_lex $P5066, "$regex"
    unless_null $P5066, vivify_2384
    new $P5066, "Undef"
  vivify_2384:
    $P5067 = $P5062."new"($P5065, $P5066, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 1814
    store_lex "$past", $P5067
.annotate 'line', 1819
    find_dynamic_lex $P5069, "$*PACKAGE-SETUP"
    unless_null $P5069, vivify_2385
    get_hll_global $P5069, "$PACKAGE-SETUP"
    unless_null $P5069, vivify_2386
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2386:
  vivify_2385:
    defined $I5070, $P5069
    unless $I5070, if_5068_end
.annotate 'line', 1820
    find_dynamic_lex $P5071, "$*PACKAGE-SETUP"
    unless_null $P5071, vivify_2387
    get_hll_global $P5071, "$PACKAGE-SETUP"
    unless_null $P5071, vivify_2388
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2388:
  vivify_2387:
    get_hll_global $P5072, ["PAST"], "Op"
.annotate 'line', 1822
    get_hll_global $P5073, ["PAST"], "Op"
.annotate 'line', 1824
    get_hll_global $P5074, ["PAST"], "Var"
    $P5075 = $P5074."new"("type_obj" :named("name"), "register" :named("scope"))
    $P5076 = $P5073."new"($P5075, "get_how PP" :named("pirop"))
.annotate 'line', 1826
    get_hll_global $P5077, ["PAST"], "Var"
    $P5078 = $P5077."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1827
    get_hll_global $P5079, ["PAST"], "Val"
    find_lex $P5080, "$name"
    unless_null $P5080, vivify_2389
    new $P5080, "Undef"
  vivify_2389:
    $P5081 = $P5079."new"($P5080 :named("value"))
.annotate 'line', 1828
    get_hll_global $P5082, ["PAST"], "Val"
    find_lex $P5083, "$regex"
    unless_null $P5083, vivify_2390
    new $P5083, "Undef"
  vivify_2390:
    $P5084 = $P5082."new"($P5083 :named("value"))
    $P5085 = $P5072."new"($P5076, $P5078, $P5081, $P5084, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 1820
    $P5071."push"($P5085)
.annotate 'line', 1830
    find_dynamic_lex $P5086, "$*PACKAGE-SETUP"
    unless_null $P5086, vivify_2391
    get_hll_global $P5086, "$PACKAGE-SETUP"
    unless_null $P5086, vivify_2392
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2392:
  vivify_2391:
    get_hll_global $P5087, ["PAST"], "Op"
.annotate 'line', 1832
    get_hll_global $P5088, ["PAST"], "Op"
.annotate 'line', 1834
    get_hll_global $P5089, ["PAST"], "Var"
    $P5090 = $P5089."new"("type_obj" :named("name"), "register" :named("scope"))
    $P5091 = $P5088."new"($P5090, "get_how PP" :named("pirop"))
.annotate 'line', 1836
    get_hll_global $P5092, ["PAST"], "Var"
    $P5093 = $P5092."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1837
    get_hll_global $P5094, ["PAST"], "Val"
    new $P5095, "String"
    assign $P5095, "!PREFIX__"
    find_lex $P5096, "$name"
    unless_null $P5096, vivify_2393
    new $P5096, "Undef"
  vivify_2393:
    concat $P5097, $P5095, $P5096
    $P5098 = $P5094."new"($P5097 :named("value"))
.annotate 'line', 1838
    get_hll_global $P5099, ["PAST"], "Var"
    new $P5100, "String"
    assign $P5100, "!PREFIX__"
    find_lex $P5101, "$name"
    unless_null $P5101, vivify_2394
    new $P5101, "Undef"
  vivify_2394:
    concat $P5102, $P5100, $P5101
    $P5103 = $P5099."new"($P5102 :named("name"), "package" :named("scope"))
    $P5104 = $P5087."new"($P5091, $P5093, $P5098, $P5103, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 1830
    $P5086."push"($P5104)
  if_5068_end:
.annotate 'line', 1842
    find_lex $P5105, "$regex"
    unless_null $P5105, vivify_2395
    new $P5105, "Undef"
  vivify_2395:
    find_lex $P5106, "$past"
    unless_null $P5106, vivify_2396
    $P5106 = root_new ['parrot';'Hash']
    store_lex "$past", $P5106
  vivify_2396:
    set $P5106["sink"], $P5105
.annotate 'line', 1843
    find_lex $P5107, "@MODIFIERS"
    unless_null $P5107, vivify_2397
    $P5107 = root_new ['parrot';'ResizablePMCArray']
  vivify_2397:
    $P5108 = $P5107."shift"()
.annotate 'line', 1809
    .return ($P5108)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block5013"  :anon :subid("514_1303401201.841") :outer("512_1303401201.841")
.annotate 'line', 1800
    $P5015 = root_new ['parrot';'Hash']
    .lex "%h", $P5015
.annotate 'line', 1799
    find_lex $P5016, "%h"
    unless_null $P5016, vivify_2398
    $P5016 = root_new ['parrot';'Hash']
  vivify_2398:
.annotate 'line', 1801
    find_lex $P5018, "$/"
    unless_null $P5018, vivify_2399
    $P5018 = root_new ['parrot';'Hash']
  vivify_2399:
    set $P5019, $P5018["sym"]
    unless_null $P5019, vivify_2400
    new $P5019, "Undef"
  vivify_2400:
    set $S5020, $P5019
    iseq $I5021, $S5020, "token"
    unless $I5021, if_5017_end
    new $P5022, "Integer"
    assign $P5022, 1
    find_lex $P5023, "%h"
    unless_null $P5023, vivify_2401
    $P5023 = root_new ['parrot';'Hash']
    store_lex "%h", $P5023
  vivify_2401:
    set $P5023["r"], $P5022
  if_5017_end:
.annotate 'line', 1802
    find_lex $P5025, "$/"
    unless_null $P5025, vivify_2402
    $P5025 = root_new ['parrot';'Hash']
  vivify_2402:
    set $P5026, $P5025["sym"]
    unless_null $P5026, vivify_2403
    new $P5026, "Undef"
  vivify_2403:
    set $S5027, $P5026
    iseq $I5028, $S5027, "rule"
    unless $I5028, if_5024_end
    new $P5029, "Integer"
    assign $P5029, 1
    find_lex $P5030, "%h"
    unless_null $P5030, vivify_2404
    $P5030 = root_new ['parrot';'Hash']
    store_lex "%h", $P5030
  vivify_2404:
    set $P5030["r"], $P5029
    new $P5031, "Integer"
    assign $P5031, 1
    find_lex $P5032, "%h"
    unless_null $P5032, vivify_2405
    $P5032 = root_new ['parrot';'Hash']
    store_lex "%h", $P5032
  vivify_2405:
    set $P5032["s"], $P5031
  if_5024_end:
.annotate 'line', 1803
    find_lex $P5033, "@MODIFIERS"
    unless_null $P5033, vivify_2406
    $P5033 = root_new ['parrot';'ResizablePMCArray']
  vivify_2406:
    find_lex $P5034, "%h"
    unless_null $P5034, vivify_2407
    $P5034 = root_new ['parrot';'Hash']
  vivify_2407:
    $P5033."unshift"($P5034)
.annotate 'line', 1804
    find_lex $P5035, "$name"
    unless_null $P5035, vivify_2408
    new $P5035, "Undef"
  vivify_2408:
    get_hll_global $P5036, ["Regex";"P6Regex"], "Actions"
    get_who $P5037, $P5036
    set $P5037["$REGEXNAME"], $P5035
.annotate 'line', 1805
    find_lex $P5038, "$?PACKAGE"
    get_who $P5039, $P5038
    set $P5040, $P5039["@BLOCK"]
    unless_null $P5040, vivify_2409
    $P5040 = root_new ['parrot';'ResizablePMCArray']
  vivify_2409:
    set $P5041, $P5040[0]
    unless_null $P5041, vivify_2410
    new $P5041, "Undef"
  vivify_2410:
    $P5041."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 1806
    find_lex $P5042, "$?PACKAGE"
    get_who $P5043, $P5042
    set $P5044, $P5043["@BLOCK"]
    unless_null $P5044, vivify_2411
    $P5044 = root_new ['parrot';'ResizablePMCArray']
  vivify_2411:
    set $P5045, $P5044[0]
    unless_null $P5045, vivify_2412
    new $P5045, "Undef"
  vivify_2412:
    $P5045."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 1807
    new $P5046, "Exception"
    set $P5046['type'], .CONTROL_RETURN
    new $P5047, "Integer"
    assign $P5047, 0
    setattribute $P5046, 'payload', $P5047
    throw $P5046
.annotate 'line', 1799
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4986"  :anon :subid("513_1303401201.841") :outer("512_1303401201.841")
    .param pmc param_4988
.annotate 'line', 1786
    .lex "$_", param_4988
.annotate 'line', 1787
    find_dynamic_lex $P4989, "$*PACKAGE-SETUP"
    unless_null $P4989, vivify_2421
    get_hll_global $P4989, "$PACKAGE-SETUP"
    unless_null $P4989, vivify_2422
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2422:
  vivify_2421:
    get_hll_global $P4990, ["PAST"], "Op"
.annotate 'line', 1789
    get_hll_global $P4991, ["PAST"], "Op"
.annotate 'line', 1791
    get_hll_global $P4992, ["PAST"], "Var"
    $P4993 = $P4992."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4994 = $P4991."new"($P4993, "get_how PP" :named("pirop"))
.annotate 'line', 1793
    get_hll_global $P4995, ["PAST"], "Var"
    $P4996 = $P4995."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1794
    get_hll_global $P4997, ["PAST"], "Val"
    find_lex $P4998, "$_"
    unless_null $P4998, vivify_2423
    new $P4998, "Undef"
  vivify_2423:
    $P4999 = $P4998."name"()
    $P5000 = $P4997."new"($P4999 :named("value"))
.annotate 'line', 1795
    get_hll_global $P5001, ["PAST"], "Val"
    find_lex $P5002, "$_"
    unless_null $P5002, vivify_2424
    new $P5002, "Undef"
  vivify_2424:
    $P5003 = $P5001."new"($P5002 :named("value"))
    $P5004 = $P4990."new"($P4994, $P4996, $P5000, $P5003, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 1787
    $P5005 = $P4989."push"($P5004)
.annotate 'line', 1786
    .return ($P5005)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "dotty"  :subid("516_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_5114
    .param pmc param_5115
.annotate 'line', 1849
    .lex "self", param_5114
    .lex "$/", param_5115
.annotate 'line', 1850
    new $P5116, "Undef"
    .lex "$past", $P5116
    find_lex $P5119, "$/"
    unless_null $P5119, vivify_2426
    $P5119 = root_new ['parrot';'Hash']
  vivify_2426:
    set $P5120, $P5119["args"]
    unless_null $P5120, vivify_2427
    new $P5120, "Undef"
  vivify_2427:
    if $P5120, if_5118
    get_hll_global $P5125, ["PAST"], "Op"
    find_lex $P5126, "$/"
    unless_null $P5126, vivify_2428
    new $P5126, "Undef"
  vivify_2428:
    $P5127 = $P5125."new"($P5126 :named("node"))
    set $P5117, $P5127
    goto if_5118_end
  if_5118:
    find_lex $P5121, "$/"
    unless_null $P5121, vivify_2429
    $P5121 = root_new ['parrot';'Hash']
  vivify_2429:
    set $P5122, $P5121["args"]
    unless_null $P5122, vivify_2430
    $P5122 = root_new ['parrot';'ResizablePMCArray']
  vivify_2430:
    set $P5123, $P5122[0]
    unless_null $P5123, vivify_2431
    new $P5123, "Undef"
  vivify_2431:
    $P5124 = $P5123."ast"()
    set $P5117, $P5124
  if_5118_end:
    store_lex "$past", $P5117
.annotate 'line', 1851
    find_lex $P5129, "$/"
    unless_null $P5129, vivify_2432
    $P5129 = root_new ['parrot';'Hash']
  vivify_2432:
    set $P5130, $P5129["quote"]
    unless_null $P5130, vivify_2433
    new $P5130, "Undef"
  vivify_2433:
    if $P5130, if_5128
.annotate 'line', 1855
    find_lex $P5137, "$/"
    unless_null $P5137, vivify_2434
    $P5137 = root_new ['parrot';'Hash']
  vivify_2434:
    set $P5138, $P5137["longname"]
    unless_null $P5138, vivify_2435
    new $P5138, "Undef"
  vivify_2435:
    set $S5139, $P5138
    iseq $I5140, $S5139, "HOW"
    if $I5140, if_5136
.annotate 'line', 1858
    find_lex $P5143, "$/"
    unless_null $P5143, vivify_2436
    $P5143 = root_new ['parrot';'Hash']
  vivify_2436:
    set $P5144, $P5143["longname"]
    unless_null $P5144, vivify_2437
    new $P5144, "Undef"
  vivify_2437:
    set $S5145, $P5144
    iseq $I5146, $S5145, "WHAT"
    if $I5146, if_5142
.annotate 'line', 1861
    find_lex $P5149, "$/"
    unless_null $P5149, vivify_2438
    $P5149 = root_new ['parrot';'Hash']
  vivify_2438:
    set $P5150, $P5149["longname"]
    unless_null $P5150, vivify_2439
    new $P5150, "Undef"
  vivify_2439:
    set $S5151, $P5150
    iseq $I5152, $S5151, "WHO"
    if $I5152, if_5148
.annotate 'line', 1865
    find_lex $P5154, "$past"
    unless_null $P5154, vivify_2440
    new $P5154, "Undef"
  vivify_2440:
    find_lex $P5155, "$/"
    unless_null $P5155, vivify_2441
    $P5155 = root_new ['parrot';'Hash']
  vivify_2441:
    set $P5156, $P5155["longname"]
    unless_null $P5156, vivify_2442
    new $P5156, "Undef"
  vivify_2442:
    set $S5157, $P5156
    $P5154."name"($S5157)
.annotate 'line', 1866
    find_lex $P5158, "$past"
    unless_null $P5158, vivify_2443
    new $P5158, "Undef"
  vivify_2443:
    $P5158."pasttype"("callmethod")
.annotate 'line', 1864
    goto if_5148_end
  if_5148:
.annotate 'line', 1862
    find_lex $P5153, "$past"
    unless_null $P5153, vivify_2444
    new $P5153, "Undef"
  vivify_2444:
    $P5153."pirop"("get_who PP")
  if_5148_end:
.annotate 'line', 1861
    goto if_5142_end
  if_5142:
.annotate 'line', 1859
    find_lex $P5147, "$past"
    unless_null $P5147, vivify_2445
    new $P5147, "Undef"
  vivify_2445:
    $P5147."pirop"("get_what PP")
  if_5142_end:
.annotate 'line', 1858
    goto if_5136_end
  if_5136:
.annotate 'line', 1856
    find_lex $P5141, "$past"
    unless_null $P5141, vivify_2446
    new $P5141, "Undef"
  vivify_2446:
    $P5141."pirop"("get_how PP")
  if_5136_end:
.annotate 'line', 1855
    goto if_5128_end
  if_5128:
.annotate 'line', 1852
    find_lex $P5131, "$past"
    unless_null $P5131, vivify_2447
    new $P5131, "Undef"
  vivify_2447:
    find_lex $P5132, "$/"
    unless_null $P5132, vivify_2448
    $P5132 = root_new ['parrot';'Hash']
  vivify_2448:
    set $P5133, $P5132["quote"]
    unless_null $P5133, vivify_2449
    new $P5133, "Undef"
  vivify_2449:
    $P5134 = $P5133."ast"()
    $P5131."name"($P5134)
.annotate 'line', 1853
    find_lex $P5135, "$past"
    unless_null $P5135, vivify_2450
    new $P5135, "Undef"
  vivify_2450:
    $P5135."pasttype"("callmethod")
  if_5128_end:
.annotate 'line', 1868
    find_lex $P5159, "$/"
    find_lex $P5160, "$past"
    unless_null $P5160, vivify_2451
    new $P5160, "Undef"
  vivify_2451:
    $P5161 = $P5159."!make"($P5160)
.annotate 'line', 1849
    .return ($P5161)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<self>"  :subid("517_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_5163
    .param pmc param_5164
.annotate 'line', 1873
    .lex "self", param_5163
    .lex "$/", param_5164
.annotate 'line', 1874
    find_lex $P5165, "$/"
    get_hll_global $P5166, ["PAST"], "Var"
    $P5167 = $P5166."new"("self" :named("name"))
    $P5168 = $P5165."!make"($P5167)
.annotate 'line', 1873
    .return ($P5168)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<identifier>"  :subid("518_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_5170
    .param pmc param_5171
.annotate 'line', 1877
    .lex "self", param_5170
    .lex "$/", param_5171
.annotate 'line', 1878
    new $P5172, "Undef"
    .lex "$past", $P5172
    find_lex $P5173, "$/"
    unless_null $P5173, vivify_2452
    $P5173 = root_new ['parrot';'Hash']
  vivify_2452:
    set $P5174, $P5173["args"]
    unless_null $P5174, vivify_2453
    new $P5174, "Undef"
  vivify_2453:
    $P5175 = $P5174."ast"()
    store_lex "$past", $P5175
.annotate 'line', 1879
    find_lex $P5176, "$past"
    unless_null $P5176, vivify_2454
    new $P5176, "Undef"
  vivify_2454:
    find_lex $P5177, "$/"
    unless_null $P5177, vivify_2455
    $P5177 = root_new ['parrot';'Hash']
  vivify_2455:
    set $P5178, $P5177["deflongname"]
    unless_null $P5178, vivify_2456
    new $P5178, "Undef"
  vivify_2456:
    set $S5179, $P5178
    $P5176."name"($S5179)
.annotate 'line', 1880
    find_lex $P5180, "$/"
    find_lex $P5181, "$past"
    unless_null $P5181, vivify_2457
    new $P5181, "Undef"
  vivify_2457:
    $P5182 = $P5180."!make"($P5181)
.annotate 'line', 1877
    .return ($P5182)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<name>"  :subid("519_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_5184
    .param pmc param_5185
.annotate 'line', 1883
    .const 'Sub' $P5200 = "520_1303401201.841" 
    capture_lex $P5200
    .lex "self", param_5184
    .lex "$/", param_5185
.annotate 'line', 1885
    new $P5186, "Undef"
    .lex "$var", $P5186
.annotate 'line', 1899
    new $P5187, "Undef"
    .lex "$past", $P5187
.annotate 'line', 1883
    find_lex $P5188, "$var"
    unless_null $P5188, vivify_2458
    new $P5188, "Undef"
  vivify_2458:
.annotate 'line', 1886
    find_lex $P5190, "$/"
    unless_null $P5190, vivify_2459
    $P5190 = root_new ['parrot';'Hash']
  vivify_2459:
    set $P5191, $P5190["name"]
    unless_null $P5191, vivify_2460
    new $P5191, "Undef"
  vivify_2460:
    set $S5192, $P5191
    $P5193 = "is_lexical"($S5192)
    if $P5193, if_5189
.annotate 'line', 1889
    .const 'Sub' $P5200 = "520_1303401201.841" 
    capture_lex $P5200
    $P5200()
    goto if_5189_end
  if_5189:
.annotate 'line', 1887
    get_hll_global $P5194, ["PAST"], "Var"
    find_lex $P5195, "$/"
    unless_null $P5195, vivify_2471
    $P5195 = root_new ['parrot';'Hash']
  vivify_2471:
    set $P5196, $P5195["name"]
    unless_null $P5196, vivify_2472
    new $P5196, "Undef"
  vivify_2472:
    set $S5197, $P5196
    $P5198 = $P5194."new"($S5197 :named("name"), "lexical" :named("scope"))
    store_lex "$var", $P5198
  if_5189_end:
.annotate 'line', 1899
    find_lex $P5223, "$var"
    unless_null $P5223, vivify_2473
    new $P5223, "Undef"
  vivify_2473:
    store_lex "$past", $P5223
.annotate 'line', 1900
    find_lex $P5225, "$/"
    unless_null $P5225, vivify_2474
    $P5225 = root_new ['parrot';'Hash']
  vivify_2474:
    set $P5226, $P5225["args"]
    unless_null $P5226, vivify_2475
    new $P5226, "Undef"
  vivify_2475:
    unless $P5226, if_5224_end
.annotate 'line', 1901
    find_lex $P5227, "$/"
    unless_null $P5227, vivify_2476
    $P5227 = root_new ['parrot';'Hash']
  vivify_2476:
    set $P5228, $P5227["args"]
    unless_null $P5228, vivify_2477
    $P5228 = root_new ['parrot';'ResizablePMCArray']
  vivify_2477:
    set $P5229, $P5228[0]
    unless_null $P5229, vivify_2478
    new $P5229, "Undef"
  vivify_2478:
    $P5230 = $P5229."ast"()
    store_lex "$past", $P5230
.annotate 'line', 1902
    find_lex $P5231, "$past"
    unless_null $P5231, vivify_2479
    new $P5231, "Undef"
  vivify_2479:
    find_lex $P5232, "$var"
    unless_null $P5232, vivify_2480
    new $P5232, "Undef"
  vivify_2480:
    $P5231."unshift"($P5232)
  if_5224_end:
.annotate 'line', 1904
    find_lex $P5233, "$/"
    find_lex $P5234, "$past"
    unless_null $P5234, vivify_2481
    new $P5234, "Undef"
  vivify_2481:
    $P5235 = $P5233."!make"($P5234)
.annotate 'line', 1883
    .return ($P5235)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5199"  :anon :subid("520_1303401201.841") :outer("519_1303401201.841")
.annotate 'line', 1890
    $P5201 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P5201
.annotate 'line', 1891
    new $P5202, "Undef"
    .lex "$name", $P5202
.annotate 'line', 1890
    find_lex $P5203, "$/"
    unless_null $P5203, vivify_2461
    $P5203 = root_new ['parrot';'Hash']
  vivify_2461:
    set $P5204, $P5203["name"]
    unless_null $P5204, vivify_2462
    $P5204 = root_new ['parrot';'Hash']
  vivify_2462:
    set $P5205, $P5204["identifier"]
    unless_null $P5205, vivify_2463
    new $P5205, "Undef"
  vivify_2463:
    clone $P5206, $P5205
    store_lex "@ns", $P5206
.annotate 'line', 1891
    find_lex $P5207, "@ns"
    unless_null $P5207, vivify_2464
    $P5207 = root_new ['parrot';'ResizablePMCArray']
  vivify_2464:
    $P5208 = $P5207."pop"()
    store_lex "$name", $P5208
.annotate 'line', 1892
    find_lex $P5212, "@ns"
    unless_null $P5212, vivify_2465
    $P5212 = root_new ['parrot';'ResizablePMCArray']
  vivify_2465:
    if $P5212, if_5211
    set $P5210, $P5212
    goto if_5211_end
  if_5211:
    find_lex $P5213, "@ns"
    unless_null $P5213, vivify_2466
    $P5213 = root_new ['parrot';'ResizablePMCArray']
  vivify_2466:
    set $P5214, $P5213[0]
    unless_null $P5214, vivify_2467
    new $P5214, "Undef"
  vivify_2467:
    set $S5215, $P5214
    iseq $I5216, $S5215, "GLOBAL"
    new $P5210, 'Integer'
    set $P5210, $I5216
  if_5211_end:
    unless $P5210, if_5209_end
    find_lex $P5217, "@ns"
    unless_null $P5217, vivify_2468
    $P5217 = root_new ['parrot';'ResizablePMCArray']
  vivify_2468:
    $P5217."shift"()
  if_5209_end:
.annotate 'line', 1893
    get_hll_global $P5218, ["PAST"], "Var"
    find_lex $P5219, "$name"
    unless_null $P5219, vivify_2469
    new $P5219, "Undef"
  vivify_2469:
    set $S5220, $P5219
    find_lex $P5221, "@ns"
    unless_null $P5221, vivify_2470
    $P5221 = root_new ['parrot';'ResizablePMCArray']
  vivify_2470:
    $P5222 = $P5218."new"($S5220 :named("name"), $P5221 :named("namespace"), "package" :named("scope"))
    store_lex "$var", $P5222
.annotate 'line', 1889
    .return ($P5222)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<pir::op>"  :subid("521_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_5237
    .param pmc param_5238
.annotate 'line', 1907
    .lex "self", param_5237
    .lex "$/", param_5238
.annotate 'line', 1908
    new $P5239, "Undef"
    .lex "$past", $P5239
.annotate 'line', 1909
    new $P5240, "Undef"
    .lex "$pirop", $P5240
.annotate 'line', 1908
    find_lex $P5243, "$/"
    unless_null $P5243, vivify_2482
    $P5243 = root_new ['parrot';'Hash']
  vivify_2482:
    set $P5244, $P5243["args"]
    unless_null $P5244, vivify_2483
    new $P5244, "Undef"
  vivify_2483:
    if $P5244, if_5242
    get_hll_global $P5249, ["PAST"], "Op"
    find_lex $P5250, "$/"
    unless_null $P5250, vivify_2484
    new $P5250, "Undef"
  vivify_2484:
    $P5251 = $P5249."new"($P5250 :named("node"))
    set $P5241, $P5251
    goto if_5242_end
  if_5242:
    find_lex $P5245, "$/"
    unless_null $P5245, vivify_2485
    $P5245 = root_new ['parrot';'Hash']
  vivify_2485:
    set $P5246, $P5245["args"]
    unless_null $P5246, vivify_2486
    $P5246 = root_new ['parrot';'ResizablePMCArray']
  vivify_2486:
    set $P5247, $P5246[0]
    unless_null $P5247, vivify_2487
    new $P5247, "Undef"
  vivify_2487:
    $P5248 = $P5247."ast"()
    set $P5241, $P5248
  if_5242_end:
    store_lex "$past", $P5241
.annotate 'line', 1909
    find_lex $P5252, "$/"
    unless_null $P5252, vivify_2488
    $P5252 = root_new ['parrot';'Hash']
  vivify_2488:
    set $P5253, $P5252["op"]
    unless_null $P5253, vivify_2489
    new $P5253, "Undef"
  vivify_2489:
    set $S5254, $P5253
    new $P5255, 'String'
    set $P5255, $S5254
    store_lex "$pirop", $P5255
.annotate 'line', 1910
    find_lex $P5256, "$pirop"
    unless_null $P5256, vivify_2490
    new $P5256, "Undef"
  vivify_2490:
    set $S5257, $P5256
    split $P5258, "__", $S5257
    join $S5259, " ", $P5258
    new $P5260, 'String'
    set $P5260, $S5259
    store_lex "$pirop", $P5260
.annotate 'line', 1911
    find_lex $P5261, "$past"
    unless_null $P5261, vivify_2491
    new $P5261, "Undef"
  vivify_2491:
    find_lex $P5262, "$pirop"
    unless_null $P5262, vivify_2492
    new $P5262, "Undef"
  vivify_2492:
    $P5261."pirop"($P5262)
.annotate 'line', 1912
    find_lex $P5263, "$past"
    unless_null $P5263, vivify_2493
    new $P5263, "Undef"
  vivify_2493:
    $P5263."pasttype"("pirop")
.annotate 'line', 1913
    find_lex $P5264, "$/"
    find_lex $P5265, "$past"
    unless_null $P5265, vivify_2494
    new $P5265, "Undef"
  vivify_2494:
    $P5266 = $P5264."!make"($P5265)
.annotate 'line', 1907
    .return ($P5266)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<onlystar>"  :subid("522_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_5268
    .param pmc param_5269
.annotate 'line', 1916
    .lex "self", param_5268
    .lex "$/", param_5269
.annotate 'line', 1917
    find_lex $P5270, "$/"
    get_hll_global $P5271, ["PAST"], "Op"
    $P5272 = $P5271."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P5273 = $P5270."!make"($P5272)
.annotate 'line', 1916
    .return ($P5273)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "args"  :subid("523_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_5275
    .param pmc param_5276
.annotate 'line', 1922
    .lex "self", param_5275
    .lex "$/", param_5276
    find_lex $P5277, "$/"
    find_lex $P5278, "$/"
    unless_null $P5278, vivify_2495
    $P5278 = root_new ['parrot';'Hash']
  vivify_2495:
    set $P5279, $P5278["arglist"]
    unless_null $P5279, vivify_2496
    new $P5279, "Undef"
  vivify_2496:
    $P5280 = $P5279."ast"()
    $P5281 = $P5277."!make"($P5280)
    .return ($P5281)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "arglist"  :subid("524_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_5283
    .param pmc param_5284
.annotate 'line', 1924
    .const 'Sub' $P5295 = "525_1303401201.841" 
    capture_lex $P5295
    .lex "self", param_5283
    .lex "$/", param_5284
.annotate 'line', 1925
    new $P5285, "Undef"
    .lex "$past", $P5285
.annotate 'line', 1933
    new $P5286, "Undef"
    .lex "$i", $P5286
.annotate 'line', 1934
    new $P5287, "Undef"
    .lex "$n", $P5287
.annotate 'line', 1925
    get_hll_global $P5288, ["PAST"], "Op"
    find_lex $P5289, "$/"
    unless_null $P5289, vivify_2497
    new $P5289, "Undef"
  vivify_2497:
    $P5290 = $P5288."new"("call" :named("pasttype"), $P5289 :named("node"))
    store_lex "$past", $P5290
.annotate 'line', 1926
    find_lex $P5292, "$/"
    unless_null $P5292, vivify_2498
    $P5292 = root_new ['parrot';'Hash']
  vivify_2498:
    set $P5293, $P5292["EXPR"]
    unless_null $P5293, vivify_2499
    new $P5293, "Undef"
  vivify_2499:
    unless $P5293, if_5291_end
    .const 'Sub' $P5295 = "525_1303401201.841" 
    capture_lex $P5295
    $P5295()
  if_5291_end:
.annotate 'line', 1933
    new $P5327, "Integer"
    assign $P5327, 0
    store_lex "$i", $P5327
.annotate 'line', 1934
    find_lex $P5328, "$past"
    unless_null $P5328, vivify_2510
    new $P5328, "Undef"
  vivify_2510:
    $P5329 = $P5328."list"()
    set $N5330, $P5329
    new $P5331, 'Float'
    set $P5331, $N5330
    store_lex "$n", $P5331
.annotate 'line', 1935
    new $P5379, 'ExceptionHandler'
    set_label $P5379, loop5378_handler
    $P5379."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5379
  loop5378_test:
    find_lex $P5332, "$i"
    unless_null $P5332, vivify_2511
    new $P5332, "Undef"
  vivify_2511:
    set $N5333, $P5332
    find_lex $P5334, "$n"
    unless_null $P5334, vivify_2512
    new $P5334, "Undef"
  vivify_2512:
    set $N5335, $P5334
    islt $I5336, $N5333, $N5335
    unless $I5336, loop5378_done
  loop5378_redo:
.annotate 'line', 1936
    find_lex $P5338, "$i"
    unless_null $P5338, vivify_2513
    new $P5338, "Undef"
  vivify_2513:
    set $I5339, $P5338
    find_lex $P5340, "$past"
    unless_null $P5340, vivify_2514
    $P5340 = root_new ['parrot';'ResizablePMCArray']
  vivify_2514:
    set $P5341, $P5340[$I5339]
    unless_null $P5341, vivify_2515
    new $P5341, "Undef"
  vivify_2515:
    $S5342 = $P5341."name"()
    iseq $I5343, $S5342, "&prefix:<|>"
    unless $I5343, if_5337_end
.annotate 'line', 1937
    find_lex $P5344, "$i"
    unless_null $P5344, vivify_2516
    new $P5344, "Undef"
  vivify_2516:
    set $I5345, $P5344
    find_lex $P5346, "$past"
    unless_null $P5346, vivify_2517
    $P5346 = root_new ['parrot';'ResizablePMCArray']
  vivify_2517:
    set $P5347, $P5346[$I5345]
    unless_null $P5347, vivify_2518
    $P5347 = root_new ['parrot';'ResizablePMCArray']
  vivify_2518:
    set $P5348, $P5347[0]
    unless_null $P5348, vivify_2519
    new $P5348, "Undef"
  vivify_2519:
    find_lex $P5349, "$i"
    unless_null $P5349, vivify_2520
    new $P5349, "Undef"
  vivify_2520:
    set $I5350, $P5349
    find_lex $P5351, "$past"
    unless_null $P5351, vivify_2521
    $P5351 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$past", $P5351
  vivify_2521:
    set $P5351[$I5350], $P5348
.annotate 'line', 1938
    find_lex $P5352, "$i"
    unless_null $P5352, vivify_2522
    new $P5352, "Undef"
  vivify_2522:
    set $I5353, $P5352
    find_lex $P5354, "$past"
    unless_null $P5354, vivify_2523
    $P5354 = root_new ['parrot';'ResizablePMCArray']
  vivify_2523:
    set $P5355, $P5354[$I5353]
    unless_null $P5355, vivify_2524
    new $P5355, "Undef"
  vivify_2524:
    $P5355."flat"(1)
.annotate 'line', 1939
    find_lex $P5359, "$i"
    unless_null $P5359, vivify_2525
    new $P5359, "Undef"
  vivify_2525:
    set $I5360, $P5359
    find_lex $P5361, "$past"
    unless_null $P5361, vivify_2526
    $P5361 = root_new ['parrot';'ResizablePMCArray']
  vivify_2526:
    set $P5362, $P5361[$I5360]
    unless_null $P5362, vivify_2527
    new $P5362, "Undef"
  vivify_2527:
    get_hll_global $P5363, ["PAST"], "Val"
    $P5364 = $P5362."isa"($P5363)
    if $P5364, if_5358
    set $P5357, $P5364
    goto if_5358_end
  if_5358:
.annotate 'line', 1940
    find_lex $P5365, "$i"
    unless_null $P5365, vivify_2528
    new $P5365, "Undef"
  vivify_2528:
    set $I5366, $P5365
    find_lex $P5367, "$past"
    unless_null $P5367, vivify_2529
    $P5367 = root_new ['parrot';'ResizablePMCArray']
  vivify_2529:
    set $P5368, $P5367[$I5366]
    unless_null $P5368, vivify_2530
    new $P5368, "Undef"
  vivify_2530:
    $S5369 = $P5368."name"()
    substr $S5370, $S5369, 0, 1
    iseq $I5371, $S5370, "%"
    new $P5357, 'Integer'
    set $P5357, $I5371
  if_5358_end:
    unless $P5357, if_5356_end
.annotate 'line', 1941
    find_lex $P5372, "$i"
    unless_null $P5372, vivify_2531
    new $P5372, "Undef"
  vivify_2531:
    set $I5373, $P5372
    find_lex $P5374, "$past"
    unless_null $P5374, vivify_2532
    $P5374 = root_new ['parrot';'ResizablePMCArray']
  vivify_2532:
    set $P5375, $P5374[$I5373]
    unless_null $P5375, vivify_2533
    new $P5375, "Undef"
  vivify_2533:
    $P5375."named"(1)
  if_5356_end:
  if_5337_end:
.annotate 'line', 1936
    find_lex $P5376, "$i"
    unless_null $P5376, vivify_2534
    new $P5376, "Undef"
  vivify_2534:
    clone $P5377, $P5376
    inc $P5376
  loop5378_next:
.annotate 'line', 1935
    goto loop5378_test
  loop5378_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5380, exception, 'type'
    eq $P5380, .CONTROL_LOOP_NEXT, loop5378_next
    eq $P5380, .CONTROL_LOOP_REDO, loop5378_redo
  loop5378_done:
    pop_eh 
.annotate 'line', 1946
    find_lex $P5381, "$/"
    find_lex $P5382, "$past"
    unless_null $P5382, vivify_2535
    new $P5382, "Undef"
  vivify_2535:
    $P5383 = $P5381."!make"($P5382)
.annotate 'line', 1924
    .return ($P5383)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block5294"  :anon :subid("525_1303401201.841") :outer("524_1303401201.841")
.annotate 'line', 1926
    .const 'Sub' $P5316 = "526_1303401201.841" 
    capture_lex $P5316
.annotate 'line', 1927
    new $P5296, "Undef"
    .lex "$expr", $P5296
    find_lex $P5297, "$/"
    unless_null $P5297, vivify_2500
    $P5297 = root_new ['parrot';'Hash']
  vivify_2500:
    set $P5298, $P5297["EXPR"]
    unless_null $P5298, vivify_2501
    new $P5298, "Undef"
  vivify_2501:
    $P5299 = $P5298."ast"()
    store_lex "$expr", $P5299
.annotate 'line', 1928
    find_lex $P5304, "$expr"
    unless_null $P5304, vivify_2502
    new $P5304, "Undef"
  vivify_2502:
    $S5305 = $P5304."name"()
    iseq $I5306, $S5305, "&infix:<,>"
    if $I5306, if_5303
    new $P5302, 'Integer'
    set $P5302, $I5306
    goto if_5303_end
  if_5303:
    find_lex $P5307, "$expr"
    unless_null $P5307, vivify_2503
    new $P5307, "Undef"
  vivify_2503:
    $P5308 = $P5307."named"()
    isfalse $I5309, $P5308
    new $P5302, 'Integer'
    set $P5302, $I5309
  if_5303_end:
    if $P5302, if_5301
.annotate 'line', 1931
    find_lex $P5324, "$past"
    unless_null $P5324, vivify_2504
    new $P5324, "Undef"
  vivify_2504:
    find_lex $P5325, "$expr"
    unless_null $P5325, vivify_2505
    new $P5325, "Undef"
  vivify_2505:
    $P5326 = $P5324."push"($P5325)
    set $P5300, $P5326
.annotate 'line', 1928
    goto if_5301_end
  if_5301:
.annotate 'line', 1929
    find_lex $P5311, "$expr"
    unless_null $P5311, vivify_2506
    new $P5311, "Undef"
  vivify_2506:
    $P5312 = $P5311."list"()
    defined $I5313, $P5312
    unless $I5313, for_undef_2507
    iter $P5310, $P5312
    new $P5322, 'ExceptionHandler'
    set_label $P5322, loop5321_handler
    $P5322."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5322
  loop5321_test:
    unless $P5310, loop5321_done
    shift $P5314, $P5310
  loop5321_redo:
    .const 'Sub' $P5316 = "526_1303401201.841" 
    capture_lex $P5316
    $P5316($P5314)
  loop5321_next:
    goto loop5321_test
  loop5321_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5323, exception, 'type'
    eq $P5323, .CONTROL_LOOP_NEXT, loop5321_next
    eq $P5323, .CONTROL_LOOP_REDO, loop5321_redo
  loop5321_done:
    pop_eh 
  for_undef_2507:
.annotate 'line', 1928
    set $P5300, $P5310
  if_5301_end:
.annotate 'line', 1926
    .return ($P5300)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5315"  :anon :subid("526_1303401201.841") :outer("525_1303401201.841")
    .param pmc param_5317
.annotate 'line', 1929
    .lex "$_", param_5317
    find_lex $P5318, "$past"
    unless_null $P5318, vivify_2508
    new $P5318, "Undef"
  vivify_2508:
    find_lex $P5319, "$_"
    unless_null $P5319, vivify_2509
    new $P5319, "Undef"
  vivify_2509:
    $P5320 = $P5318."push"($P5319)
    .return ($P5320)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<multi_declarator>"  :subid("527_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_5385
    .param pmc param_5386
.annotate 'line', 1949
    .lex "self", param_5385
    .lex "$/", param_5386
    find_lex $P5387, "$/"
    find_lex $P5388, "$/"
    unless_null $P5388, vivify_2536
    $P5388 = root_new ['parrot';'Hash']
  vivify_2536:
    set $P5389, $P5388["multi_declarator"]
    unless_null $P5389, vivify_2537
    new $P5389, "Undef"
  vivify_2537:
    $P5390 = $P5389."ast"()
    $P5391 = $P5387."!make"($P5390)
    .return ($P5391)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<value>"  :subid("528_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_5393
    .param pmc param_5394
.annotate 'line', 1951
    .lex "self", param_5393
    .lex "$/", param_5394
    find_lex $P5395, "$/"
    find_lex $P5396, "$/"
    unless_null $P5396, vivify_2538
    $P5396 = root_new ['parrot';'Hash']
  vivify_2538:
    set $P5397, $P5396["value"]
    unless_null $P5397, vivify_2539
    new $P5397, "Undef"
  vivify_2539:
    $P5398 = $P5397."ast"()
    $P5399 = $P5395."!make"($P5398)
    .return ($P5399)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<( )>"  :subid("529_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_5401
    .param pmc param_5402
.annotate 'line', 1953
    .lex "self", param_5401
    .lex "$/", param_5402
.annotate 'line', 1954
    find_lex $P5403, "$/"
.annotate 'line', 1955
    find_lex $P5406, "$/"
    unless_null $P5406, vivify_2540
    $P5406 = root_new ['parrot';'Hash']
  vivify_2540:
    set $P5407, $P5406["EXPR"]
    unless_null $P5407, vivify_2541
    new $P5407, "Undef"
  vivify_2541:
    if $P5407, if_5405
.annotate 'line', 1956
    get_hll_global $P5412, ["PAST"], "Op"
    find_lex $P5413, "$/"
    unless_null $P5413, vivify_2542
    new $P5413, "Undef"
  vivify_2542:
    $P5414 = $P5412."new"("list" :named("pasttype"), $P5413 :named("node"))
    set $P5404, $P5414
.annotate 'line', 1955
    goto if_5405_end
  if_5405:
    find_lex $P5408, "$/"
    unless_null $P5408, vivify_2543
    $P5408 = root_new ['parrot';'Hash']
  vivify_2543:
    set $P5409, $P5408["EXPR"]
    unless_null $P5409, vivify_2544
    $P5409 = root_new ['parrot';'ResizablePMCArray']
  vivify_2544:
    set $P5410, $P5409[0]
    unless_null $P5410, vivify_2545
    new $P5410, "Undef"
  vivify_2545:
    $P5411 = $P5410."ast"()
    set $P5404, $P5411
  if_5405_end:
    $P5415 = $P5403."!make"($P5404)
.annotate 'line', 1953
    .return ($P5415)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<[ ]>"  :subid("530_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_5417
    .param pmc param_5418
.annotate 'line', 1959
    .lex "self", param_5417
    .lex "$/", param_5418
.annotate 'line', 1960
    new $P5419, "Undef"
    .lex "$past", $P5419
.annotate 'line', 1959
    find_lex $P5420, "$past"
    unless_null $P5420, vivify_2546
    new $P5420, "Undef"
  vivify_2546:
.annotate 'line', 1961
    find_lex $P5422, "$/"
    unless_null $P5422, vivify_2547
    $P5422 = root_new ['parrot';'Hash']
  vivify_2547:
    set $P5423, $P5422["EXPR"]
    unless_null $P5423, vivify_2548
    new $P5423, "Undef"
  vivify_2548:
    if $P5423, if_5421
.annotate 'line', 1968
    get_hll_global $P5435, ["PAST"], "Op"
    $P5436 = $P5435."new"("list" :named("pasttype"))
    store_lex "$past", $P5436
.annotate 'line', 1967
    goto if_5421_end
  if_5421:
.annotate 'line', 1962
    find_lex $P5424, "$/"
    unless_null $P5424, vivify_2549
    $P5424 = root_new ['parrot';'Hash']
  vivify_2549:
    set $P5425, $P5424["EXPR"]
    unless_null $P5425, vivify_2550
    $P5425 = root_new ['parrot';'ResizablePMCArray']
  vivify_2550:
    set $P5426, $P5425[0]
    unless_null $P5426, vivify_2551
    new $P5426, "Undef"
  vivify_2551:
    $P5427 = $P5426."ast"()
    store_lex "$past", $P5427
.annotate 'line', 1963
    find_lex $P5429, "$past"
    unless_null $P5429, vivify_2552
    new $P5429, "Undef"
  vivify_2552:
    $S5430 = $P5429."name"()
    isne $I5431, $S5430, "&infix:<,>"
    unless $I5431, if_5428_end
.annotate 'line', 1964
    get_hll_global $P5432, ["PAST"], "Op"
    find_lex $P5433, "$past"
    unless_null $P5433, vivify_2553
    new $P5433, "Undef"
  vivify_2553:
    $P5434 = $P5432."new"($P5433, "list" :named("pasttype"))
    store_lex "$past", $P5434
  if_5428_end:
  if_5421_end:
.annotate 'line', 1970
    find_lex $P5437, "$past"
    unless_null $P5437, vivify_2554
    new $P5437, "Undef"
  vivify_2554:
    $P5437."name"("&circumfix:<[ ]>")
.annotate 'line', 1971
    find_lex $P5438, "$/"
    find_lex $P5439, "$past"
    unless_null $P5439, vivify_2555
    new $P5439, "Undef"
  vivify_2555:
    $P5440 = $P5438."!make"($P5439)
.annotate 'line', 1959
    .return ($P5440)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<ang>"  :subid("531_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_5442
    .param pmc param_5443
.annotate 'line', 1974
    .lex "self", param_5442
    .lex "$/", param_5443
    find_lex $P5444, "$/"
    find_lex $P5445, "$/"
    unless_null $P5445, vivify_2556
    $P5445 = root_new ['parrot';'Hash']
  vivify_2556:
    set $P5446, $P5445["quote_EXPR"]
    unless_null $P5446, vivify_2557
    new $P5446, "Undef"
  vivify_2557:
    $P5447 = $P5446."ast"()
    $P5448 = $P5444."!make"($P5447)
    .return ($P5448)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("532_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_5450
    .param pmc param_5451
.annotate 'line', 1975
    .lex "self", param_5450
    .lex "$/", param_5451
    find_lex $P5452, "$/"
    find_lex $P5453, "$/"
    unless_null $P5453, vivify_2558
    $P5453 = root_new ['parrot';'Hash']
  vivify_2558:
    set $P5454, $P5453["quote_EXPR"]
    unless_null $P5454, vivify_2559
    new $P5454, "Undef"
  vivify_2559:
    $P5455 = $P5454."ast"()
    $P5456 = $P5452."!make"($P5455)
    .return ($P5456)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<{ }>"  :subid("533_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_5458
    .param pmc param_5459
.annotate 'line', 1977
    .const 'Sub' $P5470 = "534_1303401201.841" 
    capture_lex $P5470
    .lex "self", param_5458
    .lex "$/", param_5459
.annotate 'line', 1978
    find_lex $P5462, "$/"
    unless_null $P5462, vivify_2560
    $P5462 = root_new ['parrot';'Hash']
  vivify_2560:
    set $P5463, $P5462["pblock"]
    unless_null $P5463, vivify_2561
    $P5463 = root_new ['parrot';'Hash']
  vivify_2561:
    set $P5464, $P5463["blockoid"]
    unless_null $P5464, vivify_2562
    $P5464 = root_new ['parrot';'Hash']
  vivify_2562:
    set $P5465, $P5464["statementlist"]
    unless_null $P5465, vivify_2563
    $P5465 = root_new ['parrot';'Hash']
  vivify_2563:
    set $P5466, $P5465["statement"]
    unless_null $P5466, vivify_2564
    new $P5466, "Undef"
  vivify_2564:
    set $N5467, $P5466
    isgt $I5468, $N5467, 0.0
    if $I5468, if_5461
.annotate 'line', 1983
    find_lex $P5483, "$/"
    unless_null $P5483, vivify_2565
    $P5483 = root_new ['parrot';'Hash']
  vivify_2565:
    set $P5484, $P5483["pblock"]
    unless_null $P5484, vivify_2566
    $P5484 = root_new ['parrot';'Hash']
  vivify_2566:
    set $P5485, $P5484["blockoid"]
    unless_null $P5485, vivify_2567
    $P5485 = root_new ['parrot';'Hash']
  vivify_2567:
    set $P5486, $P5485["you_are_here"]
    unless_null $P5486, vivify_2568
    new $P5486, "Undef"
  vivify_2568:
    if $P5486, if_5482
.annotate 'line', 1987
    find_lex $P5492, "$/"
    $P5493 = "vivitype"("%")
    $P5494 = $P5492."!make"($P5493)
.annotate 'line', 1986
    set $P5481, $P5494
.annotate 'line', 1983
    goto if_5482_end
  if_5482:
.annotate 'line', 1984
    find_lex $P5487, "$/"
    find_lex $P5488, "$/"
    unless_null $P5488, vivify_2569
    $P5488 = root_new ['parrot';'Hash']
  vivify_2569:
    set $P5489, $P5488["pblock"]
    unless_null $P5489, vivify_2570
    new $P5489, "Undef"
  vivify_2570:
    $P5490 = $P5489."ast"()
    $P5491 = $P5487."!make"($P5490)
.annotate 'line', 1983
    set $P5481, $P5491
  if_5482_end:
    set $P5460, $P5481
.annotate 'line', 1978
    goto if_5461_end
  if_5461:
    .const 'Sub' $P5470 = "534_1303401201.841" 
    capture_lex $P5470
    $P5480 = $P5470()
    set $P5460, $P5480
  if_5461_end:
.annotate 'line', 1977
    .return ($P5460)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5469"  :anon :subid("534_1303401201.841") :outer("533_1303401201.841")
.annotate 'line', 1979
    new $P5471, "Undef"
    .lex "$past", $P5471
    find_lex $P5472, "$/"
    unless_null $P5472, vivify_2571
    $P5472 = root_new ['parrot';'Hash']
  vivify_2571:
    set $P5473, $P5472["pblock"]
    unless_null $P5473, vivify_2572
    new $P5473, "Undef"
  vivify_2572:
    $P5474 = $P5473."ast"()
    store_lex "$past", $P5474
.annotate 'line', 1980
    new $P5475, "Integer"
    assign $P5475, 1
    find_lex $P5476, "$past"
    unless_null $P5476, vivify_2573
    $P5476 = root_new ['parrot';'Hash']
    store_lex "$past", $P5476
  vivify_2573:
    set $P5476["bareblock"], $P5475
.annotate 'line', 1981
    find_dynamic_lex $P5477, "$/"
    find_lex $P5478, "$past"
    unless_null $P5478, vivify_2574
    new $P5478, "Undef"
  vivify_2574:
    $P5479 = $P5477."!make"($P5478)
.annotate 'line', 1978
    .return ($P5479)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<sigil>"  :subid("535_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_5496
    .param pmc param_5497
.annotate 'line', 1991
    .lex "self", param_5496
    .lex "$/", param_5497
.annotate 'line', 1992
    new $P5498, "Undef"
    .lex "$name", $P5498
    find_lex $P5501, "$/"
    unless_null $P5501, vivify_2575
    $P5501 = root_new ['parrot';'Hash']
  vivify_2575:
    set $P5502, $P5501["sigil"]
    unless_null $P5502, vivify_2576
    new $P5502, "Undef"
  vivify_2576:
    set $S5503, $P5502
    iseq $I5504, $S5503, "@"
    if $I5504, if_5500
.annotate 'line', 1993
    find_lex $P5508, "$/"
    unless_null $P5508, vivify_2577
    $P5508 = root_new ['parrot';'Hash']
  vivify_2577:
    set $P5509, $P5508["sigil"]
    unless_null $P5509, vivify_2578
    new $P5509, "Undef"
  vivify_2578:
    set $S5510, $P5509
    iseq $I5511, $S5510, "%"
    if $I5511, if_5507
    new $P5513, "String"
    assign $P5513, "item"
    set $P5506, $P5513
    goto if_5507_end
  if_5507:
    new $P5512, "String"
    assign $P5512, "hash"
    set $P5506, $P5512
  if_5507_end:
    set $P5499, $P5506
.annotate 'line', 1992
    goto if_5500_end
  if_5500:
    new $P5505, "String"
    assign $P5505, "list"
    set $P5499, $P5505
  if_5500_end:
    store_lex "$name", $P5499
.annotate 'line', 1995
    find_lex $P5514, "$/"
    get_hll_global $P5515, ["PAST"], "Op"
    find_lex $P5516, "$name"
    unless_null $P5516, vivify_2579
    new $P5516, "Undef"
  vivify_2579:
    find_lex $P5517, "$/"
    unless_null $P5517, vivify_2580
    $P5517 = root_new ['parrot';'Hash']
  vivify_2580:
    set $P5518, $P5517["semilist"]
    unless_null $P5518, vivify_2581
    new $P5518, "Undef"
  vivify_2581:
    $P5519 = $P5518."ast"()
    $P5520 = $P5515."new"($P5519, "callmethod" :named("pasttype"), $P5516 :named("name"))
    $P5521 = $P5514."!make"($P5520)
.annotate 'line', 1991
    .return ($P5521)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "semilist"  :subid("536_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_5523
    .param pmc param_5524
.annotate 'line', 1998
    .lex "self", param_5523
    .lex "$/", param_5524
    find_lex $P5525, "$/"
    find_lex $P5526, "$/"
    unless_null $P5526, vivify_2582
    $P5526 = root_new ['parrot';'Hash']
  vivify_2582:
    set $P5527, $P5526["statement"]
    unless_null $P5527, vivify_2583
    new $P5527, "Undef"
  vivify_2583:
    $P5528 = $P5527."ast"()
    $P5529 = $P5525."!make"($P5528)
    .return ($P5529)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<[ ]>"  :subid("537_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_5531
    .param pmc param_5532
.annotate 'line', 2000
    .lex "self", param_5531
    .lex "$/", param_5532
.annotate 'line', 2001
    find_lex $P5533, "$/"
    get_hll_global $P5534, ["PAST"], "Var"
    find_lex $P5535, "$/"
    unless_null $P5535, vivify_2584
    $P5535 = root_new ['parrot';'Hash']
  vivify_2584:
    set $P5536, $P5535["EXPR"]
    unless_null $P5536, vivify_2585
    new $P5536, "Undef"
  vivify_2585:
    $P5537 = $P5536."ast"()
.annotate 'line', 2003
    $P5538 = "vivitype"("@")
    $P5539 = $P5534."new"($P5537, "keyed_int" :named("scope"), "Undef" :named("viviself"), $P5538 :named("vivibase"))
.annotate 'line', 2001
    $P5540 = $P5533."!make"($P5539)
.annotate 'line', 2000
    .return ($P5540)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<{ }>"  :subid("538_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_5542
    .param pmc param_5543
.annotate 'line', 2006
    .lex "self", param_5542
    .lex "$/", param_5543
.annotate 'line', 2007
    find_lex $P5544, "$/"
    get_hll_global $P5545, ["PAST"], "Var"
    find_lex $P5546, "$/"
    unless_null $P5546, vivify_2586
    $P5546 = root_new ['parrot';'Hash']
  vivify_2586:
    set $P5547, $P5546["EXPR"]
    unless_null $P5547, vivify_2587
    new $P5547, "Undef"
  vivify_2587:
    $P5548 = $P5547."ast"()
.annotate 'line', 2009
    $P5549 = "vivitype"("%")
    $P5550 = $P5545."new"($P5548, "keyed" :named("scope"), "Undef" :named("viviself"), $P5549 :named("vivibase"))
.annotate 'line', 2007
    $P5551 = $P5544."!make"($P5550)
.annotate 'line', 2006
    .return ($P5551)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<ang>"  :subid("539_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_5553
    .param pmc param_5554
.annotate 'line', 2012
    .lex "self", param_5553
    .lex "$/", param_5554
.annotate 'line', 2013
    find_lex $P5555, "$/"
    get_hll_global $P5556, ["PAST"], "Var"
    find_lex $P5557, "$/"
    unless_null $P5557, vivify_2588
    $P5557 = root_new ['parrot';'Hash']
  vivify_2588:
    set $P5558, $P5557["quote_EXPR"]
    unless_null $P5558, vivify_2589
    new $P5558, "Undef"
  vivify_2589:
    $P5559 = $P5558."ast"()
.annotate 'line', 2015
    $P5560 = "vivitype"("%")
    $P5561 = $P5556."new"($P5559, "keyed" :named("scope"), "Undef" :named("viviself"), $P5560 :named("vivibase"))
.annotate 'line', 2013
    $P5562 = $P5555."!make"($P5561)
.annotate 'line', 2012
    .return ($P5562)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<( )>"  :subid("540_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_5564
    .param pmc param_5565
.annotate 'line', 2018
    .lex "self", param_5564
    .lex "$/", param_5565
.annotate 'line', 2019
    find_lex $P5566, "$/"
    find_lex $P5567, "$/"
    unless_null $P5567, vivify_2590
    $P5567 = root_new ['parrot';'Hash']
  vivify_2590:
    set $P5568, $P5567["arglist"]
    unless_null $P5568, vivify_2591
    new $P5568, "Undef"
  vivify_2591:
    $P5569 = $P5568."ast"()
    $P5570 = $P5566."!make"($P5569)
.annotate 'line', 2018
    .return ($P5570)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "value"  :subid("541_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_5572
    .param pmc param_5573
.annotate 'line', 2022
    .lex "self", param_5572
    .lex "$/", param_5573
.annotate 'line', 2023
    find_lex $P5574, "$/"
    find_lex $P5577, "$/"
    unless_null $P5577, vivify_2592
    $P5577 = root_new ['parrot';'Hash']
  vivify_2592:
    set $P5578, $P5577["quote"]
    unless_null $P5578, vivify_2593
    new $P5578, "Undef"
  vivify_2593:
    if $P5578, if_5576
    find_lex $P5582, "$/"
    unless_null $P5582, vivify_2594
    $P5582 = root_new ['parrot';'Hash']
  vivify_2594:
    set $P5583, $P5582["number"]
    unless_null $P5583, vivify_2595
    new $P5583, "Undef"
  vivify_2595:
    $P5584 = $P5583."ast"()
    set $P5575, $P5584
    goto if_5576_end
  if_5576:
    find_lex $P5579, "$/"
    unless_null $P5579, vivify_2596
    $P5579 = root_new ['parrot';'Hash']
  vivify_2596:
    set $P5580, $P5579["quote"]
    unless_null $P5580, vivify_2597
    new $P5580, "Undef"
  vivify_2597:
    $P5581 = $P5580."ast"()
    set $P5575, $P5581
  if_5576_end:
    $P5585 = $P5574."!make"($P5575)
.annotate 'line', 2022
    .return ($P5585)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "number"  :subid("542_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_5587
    .param pmc param_5588
.annotate 'line', 2026
    .lex "self", param_5587
    .lex "$/", param_5588
.annotate 'line', 2027
    new $P5589, "Undef"
    .lex "$value", $P5589
    find_lex $P5592, "$/"
    unless_null $P5592, vivify_2598
    $P5592 = root_new ['parrot';'Hash']
  vivify_2598:
    set $P5593, $P5592["dec_number"]
    unless_null $P5593, vivify_2599
    new $P5593, "Undef"
  vivify_2599:
    if $P5593, if_5591
    find_lex $P5597, "$/"
    unless_null $P5597, vivify_2600
    $P5597 = root_new ['parrot';'Hash']
  vivify_2600:
    set $P5598, $P5597["integer"]
    unless_null $P5598, vivify_2601
    new $P5598, "Undef"
  vivify_2601:
    $P5599 = $P5598."ast"()
    set $P5590, $P5599
    goto if_5591_end
  if_5591:
    find_lex $P5594, "$/"
    unless_null $P5594, vivify_2602
    $P5594 = root_new ['parrot';'Hash']
  vivify_2602:
    set $P5595, $P5594["dec_number"]
    unless_null $P5595, vivify_2603
    new $P5595, "Undef"
  vivify_2603:
    $P5596 = $P5595."ast"()
    set $P5590, $P5596
  if_5591_end:
    store_lex "$value", $P5590
.annotate 'line', 2028
    find_lex $P5601, "$/"
    unless_null $P5601, vivify_2604
    $P5601 = root_new ['parrot';'Hash']
  vivify_2604:
    set $P5602, $P5601["sign"]
    unless_null $P5602, vivify_2605
    new $P5602, "Undef"
  vivify_2605:
    set $S5603, $P5602
    iseq $I5604, $S5603, "-"
    unless $I5604, if_5600_end
    find_lex $P5605, "$value"
    unless_null $P5605, vivify_2606
    new $P5605, "Undef"
  vivify_2606:
    neg $P5606, $P5605
    store_lex "$value", $P5606
  if_5600_end:
.annotate 'line', 2029
    find_lex $P5607, "$/"
    get_hll_global $P5608, ["PAST"], "Val"
    find_lex $P5609, "$value"
    unless_null $P5609, vivify_2607
    new $P5609, "Undef"
  vivify_2607:
    $P5610 = $P5608."new"($P5609 :named("value"))
    $P5611 = $P5607."!make"($P5610)
.annotate 'line', 2026
    .return ($P5611)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<apos>"  :subid("543_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_5613
    .param pmc param_5614
.annotate 'line', 2032
    .lex "self", param_5613
    .lex "$/", param_5614
    find_lex $P5615, "$/"
    find_lex $P5616, "$/"
    unless_null $P5616, vivify_2608
    $P5616 = root_new ['parrot';'Hash']
  vivify_2608:
    set $P5617, $P5616["quote_EXPR"]
    unless_null $P5617, vivify_2609
    new $P5617, "Undef"
  vivify_2609:
    $P5618 = $P5617."ast"()
    $P5619 = $P5615."!make"($P5618)
    .return ($P5619)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<dblq>"  :subid("544_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_5621
    .param pmc param_5622
.annotate 'line', 2033
    .lex "self", param_5621
    .lex "$/", param_5622
    find_lex $P5623, "$/"
    find_lex $P5624, "$/"
    unless_null $P5624, vivify_2610
    $P5624 = root_new ['parrot';'Hash']
  vivify_2610:
    set $P5625, $P5624["quote_EXPR"]
    unless_null $P5625, vivify_2611
    new $P5625, "Undef"
  vivify_2611:
    $P5626 = $P5625."ast"()
    $P5627 = $P5623."!make"($P5626)
    .return ($P5627)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<qq>"  :subid("545_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_5629
    .param pmc param_5630
.annotate 'line', 2034
    .lex "self", param_5629
    .lex "$/", param_5630
    find_lex $P5631, "$/"
    find_lex $P5632, "$/"
    unless_null $P5632, vivify_2612
    $P5632 = root_new ['parrot';'Hash']
  vivify_2612:
    set $P5633, $P5632["quote_EXPR"]
    unless_null $P5633, vivify_2613
    new $P5633, "Undef"
  vivify_2613:
    $P5634 = $P5633."ast"()
    $P5635 = $P5631."!make"($P5634)
    .return ($P5635)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<q>"  :subid("546_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_5637
    .param pmc param_5638
.annotate 'line', 2035
    .lex "self", param_5637
    .lex "$/", param_5638
    find_lex $P5639, "$/"
    find_lex $P5640, "$/"
    unless_null $P5640, vivify_2614
    $P5640 = root_new ['parrot';'Hash']
  vivify_2614:
    set $P5641, $P5640["quote_EXPR"]
    unless_null $P5641, vivify_2615
    new $P5641, "Undef"
  vivify_2615:
    $P5642 = $P5641."ast"()
    $P5643 = $P5639."!make"($P5642)
    .return ($P5643)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q>"  :subid("547_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_5645
    .param pmc param_5646
.annotate 'line', 2036
    .lex "self", param_5645
    .lex "$/", param_5646
    find_lex $P5647, "$/"
    find_lex $P5648, "$/"
    unless_null $P5648, vivify_2616
    $P5648 = root_new ['parrot';'Hash']
  vivify_2616:
    set $P5649, $P5648["quote_EXPR"]
    unless_null $P5649, vivify_2617
    new $P5649, "Undef"
  vivify_2617:
    $P5650 = $P5649."ast"()
    $P5651 = $P5647."!make"($P5650)
    .return ($P5651)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q:PIR>"  :subid("548_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_5653
    .param pmc param_5654
.annotate 'line', 2037
    .lex "self", param_5653
    .lex "$/", param_5654
.annotate 'line', 2038
    find_lex $P5655, "$/"
    get_hll_global $P5656, ["PAST"], "Op"
    find_lex $P5657, "$/"
    unless_null $P5657, vivify_2618
    $P5657 = root_new ['parrot';'Hash']
  vivify_2618:
    set $P5658, $P5657["quote_EXPR"]
    unless_null $P5658, vivify_2619
    new $P5658, "Undef"
  vivify_2619:
    $P5659 = $P5658."ast"()
    $P5660 = $P5659."value"()
    find_lex $P5661, "$/"
    unless_null $P5661, vivify_2620
    new $P5661, "Undef"
  vivify_2620:
    $P5662 = $P5656."new"($P5660 :named("inline"), "inline" :named("pasttype"), $P5661 :named("node"))
    $P5663 = $P5655."!make"($P5662)
.annotate 'line', 2037
    .return ($P5663)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "quote:sym</ />"  :subid("549_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_5667
    .param pmc param_5668
    .param pmc param_5669 :optional
    .param int has_param_5669 :opt_flag
.annotate 'line', 2043
    new $P5666, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P5666, control_5665
    push_eh $P5666
    .lex "self", param_5667
    .lex "$/", param_5668
    if has_param_5669, optparam_2621
    new $P5670, "Undef"
    set param_5669, $P5670
  optparam_2621:
    .lex "$key", param_5669
.annotate 'line', 2050
    new $P5671, "Undef"
    .lex "$regex", $P5671
.annotate 'line', 2052
    new $P5672, "Undef"
    .lex "$past", $P5672
.annotate 'line', 2044
    find_lex $P5674, "$key"
    unless_null $P5674, vivify_2622
    new $P5674, "Undef"
  vivify_2622:
    set $S5675, $P5674
    iseq $I5676, $S5675, "open"
    unless $I5676, if_5673_end
.annotate 'line', 2045
    null $P5677
    get_hll_global $P5678, ["Regex";"P6Regex"], "Actions"
    get_who $P5679, $P5678
    set $P5679["$REGEXNAME"], $P5677
.annotate 'line', 2046
    find_lex $P5680, "$?PACKAGE"
    get_who $P5681, $P5680
    set $P5682, $P5681["@BLOCK"]
    unless_null $P5682, vivify_2623
    $P5682 = root_new ['parrot';'ResizablePMCArray']
  vivify_2623:
    set $P5683, $P5682[0]
    unless_null $P5683, vivify_2624
    new $P5683, "Undef"
  vivify_2624:
    $P5683."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 2047
    find_lex $P5684, "$?PACKAGE"
    get_who $P5685, $P5684
    set $P5686, $P5685["@BLOCK"]
    unless_null $P5686, vivify_2625
    $P5686 = root_new ['parrot';'ResizablePMCArray']
  vivify_2625:
    set $P5687, $P5686[0]
    unless_null $P5687, vivify_2626
    new $P5687, "Undef"
  vivify_2626:
    $P5687."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 2048
    new $P5688, "Exception"
    set $P5688['type'], .CONTROL_RETURN
    new $P5689, "Integer"
    assign $P5689, 0
    setattribute $P5688, 'payload', $P5689
    throw $P5688
  if_5673_end:
.annotate 'line', 2051
    get_hll_global $P5690, ["Regex";"P6Regex";"Actions"], "buildsub"
    find_lex $P5691, "$/"
    unless_null $P5691, vivify_2627
    $P5691 = root_new ['parrot';'Hash']
  vivify_2627:
    set $P5692, $P5691["p6regex"]
    unless_null $P5692, vivify_2628
    new $P5692, "Undef"
  vivify_2628:
    $P5693 = $P5692."ast"()
    find_lex $P5694, "$?PACKAGE"
    get_who $P5695, $P5694
    set $P5696, $P5695["@BLOCK"]
    unless_null $P5696, vivify_2629
    $P5696 = root_new ['parrot';'ResizablePMCArray']
  vivify_2629:
    $P5697 = $P5696."shift"()
    $P5698 = $P5690($P5693, $P5697)
    store_lex "$regex", $P5698
.annotate 'line', 2053
    get_hll_global $P5699, ["PAST"], "Op"
.annotate 'line', 2055
    get_hll_global $P5700, ["PAST"], "Var"
    new $P5701, "ResizablePMCArray"
    push $P5701, "Regex"
    $P5702 = $P5700."new"("Regex" :named("name"), $P5701 :named("namespace"), "package" :named("scope"))
    find_lex $P5703, "$regex"
    unless_null $P5703, vivify_2630
    new $P5703, "Undef"
  vivify_2630:
    $P5704 = $P5699."new"($P5702, $P5703, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 2053
    store_lex "$past", $P5704
.annotate 'line', 2059
    find_lex $P5705, "$regex"
    unless_null $P5705, vivify_2631
    new $P5705, "Undef"
  vivify_2631:
    find_lex $P5706, "$past"
    unless_null $P5706, vivify_2632
    $P5706 = root_new ['parrot';'Hash']
    store_lex "$past", $P5706
  vivify_2632:
    set $P5706["sink"], $P5705
.annotate 'line', 2060
    find_lex $P5707, "$/"
    find_lex $P5708, "$past"
    unless_null $P5708, vivify_2633
    new $P5708, "Undef"
  vivify_2633:
    $P5709 = $P5707."!make"($P5708)
.annotate 'line', 2043
    .return ($P5709)
  control_5665:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5710, exception, "payload"
    .return ($P5710)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<$>"  :subid("550_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_5712
    .param pmc param_5713
.annotate 'line', 2063
    .lex "self", param_5712
    .lex "$/", param_5713
    find_lex $P5714, "$/"
    find_lex $P5715, "$/"
    unless_null $P5715, vivify_2634
    $P5715 = root_new ['parrot';'Hash']
  vivify_2634:
    set $P5716, $P5715["variable"]
    unless_null $P5716, vivify_2635
    new $P5716, "Undef"
  vivify_2635:
    $P5717 = $P5716."ast"()
    $P5718 = $P5714."!make"($P5717)
    .return ($P5718)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<{ }>"  :subid("551_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_5720
    .param pmc param_5721
.annotate 'line', 2064
    .lex "self", param_5720
    .lex "$/", param_5721
.annotate 'line', 2065
    find_lex $P5722, "$/"
    get_hll_global $P5723, ["PAST"], "Op"
.annotate 'line', 2066
    find_lex $P5724, "$/"
    unless_null $P5724, vivify_2636
    $P5724 = root_new ['parrot';'Hash']
  vivify_2636:
    set $P5725, $P5724["block"]
    unless_null $P5725, vivify_2637
    new $P5725, "Undef"
  vivify_2637:
    $P5726 = $P5725."ast"()
    $P5727 = "block_immediate"($P5726)
    find_lex $P5728, "$/"
    unless_null $P5728, vivify_2638
    new $P5728, "Undef"
  vivify_2638:
    $P5729 = $P5723."new"($P5727, "set S*" :named("pirop"), $P5728 :named("node"))
.annotate 'line', 2065
    $P5730 = $P5722."!make"($P5729)
.annotate 'line', 2064
    .return ($P5730)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<esc>"  :subid("552_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_5732
    .param pmc param_5733
.annotate 'line', 2069
    .lex "self", param_5732
    .lex "$/", param_5733
    find_lex $P5734, "$/"
    $P5735 = $P5734."!make"("\e")
    .return ($P5735)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<.>"  :subid("553_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_5737
    .param pmc param_5738
.annotate 'line', 2073
    .lex "self", param_5737
    .lex "$/", param_5738
    find_lex $P5739, "$/"
    find_lex $P5740, "$/"
    unless_null $P5740, vivify_2639
    $P5740 = root_new ['parrot';'Hash']
  vivify_2639:
    set $P5741, $P5740["dotty"]
    unless_null $P5741, vivify_2640
    new $P5741, "Undef"
  vivify_2640:
    $P5742 = $P5741."ast"()
    $P5743 = $P5739."!make"($P5742)
    .return ($P5743)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<++>"  :subid("554_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_5745
    .param pmc param_5746
.annotate 'line', 2075
    .lex "self", param_5745
    .lex "$/", param_5746
.annotate 'line', 2076
    find_lex $P5747, "$/"
    get_hll_global $P5748, ["PAST"], "Op"
.annotate 'line', 2077
    new $P5749, "ResizablePMCArray"
    push $P5749, "    clone %r, %0"
    push $P5749, "    inc %0"
    $P5750 = $P5748."new"("postfix:<++>" :named("name"), $P5749 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 2076
    $P5751 = $P5747."!make"($P5750)
.annotate 'line', 2075
    .return ($P5751)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<-->"  :subid("555_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_5753
    .param pmc param_5754
.annotate 'line', 2081
    .lex "self", param_5753
    .lex "$/", param_5754
.annotate 'line', 2082
    find_lex $P5755, "$/"
    get_hll_global $P5756, ["PAST"], "Op"
.annotate 'line', 2083
    new $P5757, "ResizablePMCArray"
    push $P5757, "    clone %r, %0"
    push $P5757, "    dec %0"
    $P5758 = $P5756."new"("postfix:<-->" :named("name"), $P5757 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 2082
    $P5759 = $P5755."!make"($P5758)
.annotate 'line', 2081
    .return ($P5759)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "prefix:sym<make>"  :subid("556_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_5761
    .param pmc param_5762
.annotate 'line', 2087
    .lex "self", param_5761
    .lex "$/", param_5762
.annotate 'line', 2088
    find_lex $P5763, "$/"
    get_hll_global $P5764, ["PAST"], "Op"
.annotate 'line', 2089
    get_hll_global $P5765, ["PAST"], "Var"
    $P5766 = $P5765."new"("$/" :named("name"), "contextual" :named("scope"))
    find_lex $P5767, "$/"
    unless_null $P5767, vivify_2641
    new $P5767, "Undef"
  vivify_2641:
    $P5768 = $P5764."new"($P5766, "callmethod" :named("pasttype"), "!make" :named("name"), $P5767 :named("node"))
.annotate 'line', 2088
    $P5769 = $P5763."!make"($P5768)
.annotate 'line', 2087
    .return ($P5769)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<next>"  :subid("557_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_5772
    .param pmc param_5773
.annotate 'line', 2105
    .lex "self", param_5772
    .lex "$/", param_5773
    find_lex $P5774, "$/"
    unless_null $P5774, vivify_2642
    new $P5774, "Undef"
  vivify_2642:
    $P5775 = "control"($P5774, "CONTROL_LOOP_NEXT")
    .return ($P5775)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<last>"  :subid("558_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_5777
    .param pmc param_5778
.annotate 'line', 2106
    .lex "self", param_5777
    .lex "$/", param_5778
    find_lex $P5779, "$/"
    unless_null $P5779, vivify_2643
    new $P5779, "Undef"
  vivify_2643:
    $P5780 = "control"($P5779, "CONTROL_LOOP_LAST")
    .return ($P5780)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<redo>"  :subid("559_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_5782
    .param pmc param_5783
.annotate 'line', 2107
    .lex "self", param_5782
    .lex "$/", param_5783
    find_lex $P5784, "$/"
    unless_null $P5784, vivify_2644
    new $P5784, "Undef"
  vivify_2644:
    $P5785 = "control"($P5784, "CONTROL_LOOP_REDO")
    .return ($P5785)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "infix:sym<~~>"  :subid("560_1303401201.841") :outer("406_1303401201.841")
    .param pmc param_5787
    .param pmc param_5788
.annotate 'line', 2109
    .lex "self", param_5787
    .lex "$/", param_5788
.annotate 'line', 2110
    find_lex $P5789, "$/"
    get_hll_global $P5790, ["PAST"], "Op"
    find_lex $P5791, "$/"
    unless_null $P5791, vivify_2645
    new $P5791, "Undef"
  vivify_2645:
    $P5792 = $P5790."new"("callmethod" :named("pasttype"), "ACCEPTS" :named("name"), $P5791 :named("node"))
    $P5793 = $P5789."!make"($P5792)
.annotate 'line', 2109
    .return ($P5793)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "_block6023"  :subid("562_1303401201.841") :outer("10_1303401201.841")
.annotate 'line', 2183
    .const 'Sub' $P6124 = "570_1303401201.841" 
    capture_lex $P6124
    .const 'Sub' $P6099 = "569_1303401201.841" 
    capture_lex $P6099
    .const 'Sub' $P6088 = "568_1303401201.841" 
    capture_lex $P6088
    .const 'Sub' $P6073 = "567_1303401201.841" 
    capture_lex $P6073
    .const 'Sub' $P6062 = "566_1303401201.841" 
    capture_lex $P6062
    .const 'Sub' $P6051 = "565_1303401201.841" 
    capture_lex $P6051
    .const 'Sub' $P6040 = "564_1303401201.841" 
    capture_lex $P6040
    .const 'Sub' $P6027 = "563_1303401201.841" 
    capture_lex $P6027
    .lex "$?PACKAGE", $P6025
    .lex "$?CLASS", $P6026
.annotate 'line', 2217
    .const 'Sub' $P6099 = "569_1303401201.841" 
    newclosure $P6122, $P6099
.annotate 'line', 2183
    .return ($P6122)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "" :load :init :subid("post2646") :outer("562_1303401201.841")
.annotate 'line', 2183
    get_hll_global $P6024, ["NQP";"RegexActions"], "_block6023" 
    .local pmc block
    set block, $P6024
    .const 'Sub' $P6124 = "570_1303401201.841" 
    capture_lex $P6124
    $P6124()
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "_block6123"  :anon :subid("570_1303401201.841") :outer("562_1303401201.841")
.annotate 'line', 2183
    nqp_get_sc_object $P6125, "1303401190.883", 4
    .local pmc type_obj
    set type_obj, $P6125
    get_how $P6126, type_obj
    .const 'Sub' $P6127 = "563_1303401201.841" 
    $P6126."add_method"(type_obj, "metachar:sym<:my>", $P6127)
    get_how $P6128, type_obj
    .const 'Sub' $P6129 = "564_1303401201.841" 
    $P6128."add_method"(type_obj, "metachar:sym<{ }>", $P6129)
    get_how $P6130, type_obj
    .const 'Sub' $P6131 = "565_1303401201.841" 
    $P6130."add_method"(type_obj, "metachar:sym<nqpvar>", $P6131)
    get_how $P6132, type_obj
    .const 'Sub' $P6133 = "566_1303401201.841" 
    $P6132."add_method"(type_obj, "assertion:sym<{ }>", $P6133)
    get_how $P6134, type_obj
    .const 'Sub' $P6135 = "567_1303401201.841" 
    $P6134."add_method"(type_obj, "assertion:sym<?{ }>", $P6135)
    get_how $P6136, type_obj
    .const 'Sub' $P6137 = "568_1303401201.841" 
    $P6136."add_method"(type_obj, "assertion:sym<var>", $P6137)
    get_how $P6138, type_obj
    .const 'Sub' $P6139 = "569_1303401201.841" 
    $P6138."add_method"(type_obj, "codeblock", $P6139)
    get_how $P6140, type_obj
    get_hll_global $P6141, ["Regex";"P6Regex"], "Actions"
    $P6140."add_parent"(type_obj, $P6141)
    get_how $P6142, type_obj
    $P6143 = $P6142."compose"(type_obj)
    .return ($P6143)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<:my>"  :subid("563_1303401201.841") :outer("562_1303401201.841")
    .param pmc param_6028
    .param pmc param_6029
.annotate 'line', 2185
    .lex "self", param_6028
    .lex "$/", param_6029
.annotate 'line', 2186
    new $P6030, "Undef"
    .lex "$past", $P6030
    find_lex $P6031, "$/"
    unless_null $P6031, vivify_2647
    $P6031 = root_new ['parrot';'Hash']
  vivify_2647:
    set $P6032, $P6031["statement"]
    unless_null $P6032, vivify_2648
    new $P6032, "Undef"
  vivify_2648:
    $P6033 = $P6032."ast"()
    store_lex "$past", $P6033
.annotate 'line', 2187
    find_lex $P6034, "$/"
    get_hll_global $P6035, ["PAST"], "Regex"
    find_lex $P6036, "$past"
    unless_null $P6036, vivify_2649
    new $P6036, "Undef"
  vivify_2649:
    find_lex $P6037, "$/"
    unless_null $P6037, vivify_2650
    new $P6037, "Undef"
  vivify_2650:
    $P6038 = $P6035."new"($P6036, "pastnode" :named("pasttype"), "declarative" :named("subtype"), $P6037 :named("node"))
    $P6039 = $P6034."!make"($P6038)
.annotate 'line', 2185
    .return ($P6039)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<{ }>"  :subid("564_1303401201.841") :outer("562_1303401201.841")
    .param pmc param_6041
    .param pmc param_6042
.annotate 'line', 2191
    .lex "self", param_6041
    .lex "$/", param_6042
.annotate 'line', 2192
    find_lex $P6043, "$/"
    get_hll_global $P6044, ["PAST"], "Regex"
    find_lex $P6045, "$/"
    unless_null $P6045, vivify_2651
    $P6045 = root_new ['parrot';'Hash']
  vivify_2651:
    set $P6046, $P6045["codeblock"]
    unless_null $P6046, vivify_2652
    new $P6046, "Undef"
  vivify_2652:
    $P6047 = $P6046."ast"()
    find_lex $P6048, "$/"
    unless_null $P6048, vivify_2653
    new $P6048, "Undef"
  vivify_2653:
    $P6049 = $P6044."new"($P6047, "pastnode" :named("pasttype"), $P6048 :named("node"))
    $P6050 = $P6043."!make"($P6049)
.annotate 'line', 2191
    .return ($P6050)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<nqpvar>"  :subid("565_1303401201.841") :outer("562_1303401201.841")
    .param pmc param_6052
    .param pmc param_6053
.annotate 'line', 2196
    .lex "self", param_6052
    .lex "$/", param_6053
.annotate 'line', 2197
    find_lex $P6054, "$/"
    get_hll_global $P6055, ["PAST"], "Regex"
    find_lex $P6056, "$/"
    unless_null $P6056, vivify_2654
    $P6056 = root_new ['parrot';'Hash']
  vivify_2654:
    set $P6057, $P6056["var"]
    unless_null $P6057, vivify_2655
    new $P6057, "Undef"
  vivify_2655:
    $P6058 = $P6057."ast"()
    find_lex $P6059, "$/"
    unless_null $P6059, vivify_2656
    new $P6059, "Undef"
  vivify_2656:
    $P6060 = $P6055."new"("!INTERPOLATE", $P6058, "subrule" :named("pasttype"), "method" :named("subtype"), $P6059 :named("node"))
    $P6061 = $P6054."!make"($P6060)
.annotate 'line', 2196
    .return ($P6061)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<{ }>"  :subid("566_1303401201.841") :outer("562_1303401201.841")
    .param pmc param_6063
    .param pmc param_6064
.annotate 'line', 2201
    .lex "self", param_6063
    .lex "$/", param_6064
.annotate 'line', 2202
    find_lex $P6065, "$/"
    get_hll_global $P6066, ["PAST"], "Regex"
    find_lex $P6067, "$/"
    unless_null $P6067, vivify_2657
    $P6067 = root_new ['parrot';'Hash']
  vivify_2657:
    set $P6068, $P6067["codeblock"]
    unless_null $P6068, vivify_2658
    new $P6068, "Undef"
  vivify_2658:
    $P6069 = $P6068."ast"()
    find_lex $P6070, "$/"
    unless_null $P6070, vivify_2659
    new $P6070, "Undef"
  vivify_2659:
    $P6071 = $P6066."new"("!INTERPOLATE_REGEX", $P6069, "subrule" :named("pasttype"), "method" :named("subtype"), $P6070 :named("node"))
    $P6072 = $P6065."!make"($P6071)
.annotate 'line', 2201
    .return ($P6072)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<?{ }>"  :subid("567_1303401201.841") :outer("562_1303401201.841")
    .param pmc param_6074
    .param pmc param_6075
.annotate 'line', 2206
    .lex "self", param_6074
    .lex "$/", param_6075
.annotate 'line', 2207
    find_lex $P6076, "$/"
    get_hll_global $P6077, ["PAST"], "Regex"
    find_lex $P6078, "$/"
    unless_null $P6078, vivify_2660
    $P6078 = root_new ['parrot';'Hash']
  vivify_2660:
    set $P6079, $P6078["codeblock"]
    unless_null $P6079, vivify_2661
    new $P6079, "Undef"
  vivify_2661:
    $P6080 = $P6079."ast"()
.annotate 'line', 2208
    find_lex $P6081, "$/"
    unless_null $P6081, vivify_2662
    $P6081 = root_new ['parrot';'Hash']
  vivify_2662:
    set $P6082, $P6081["zw"]
    unless_null $P6082, vivify_2663
    new $P6082, "Undef"
  vivify_2663:
    set $S6083, $P6082
    iseq $I6084, $S6083, "!"
    find_lex $P6085, "$/"
    unless_null $P6085, vivify_2664
    new $P6085, "Undef"
  vivify_2664:
    $P6086 = $P6077."new"($P6080, "zerowidth" :named("subtype"), $I6084 :named("negate"), "pastnode" :named("pasttype"), $P6085 :named("node"))
.annotate 'line', 2207
    $P6087 = $P6076."!make"($P6086)
.annotate 'line', 2206
    .return ($P6087)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<var>"  :subid("568_1303401201.841") :outer("562_1303401201.841")
    .param pmc param_6089
    .param pmc param_6090
.annotate 'line', 2212
    .lex "self", param_6089
    .lex "$/", param_6090
.annotate 'line', 2213
    find_lex $P6091, "$/"
    get_hll_global $P6092, ["PAST"], "Regex"
    find_lex $P6093, "$/"
    unless_null $P6093, vivify_2665
    $P6093 = root_new ['parrot';'Hash']
  vivify_2665:
    set $P6094, $P6093["var"]
    unless_null $P6094, vivify_2666
    new $P6094, "Undef"
  vivify_2666:
    $P6095 = $P6094."ast"()
    find_lex $P6096, "$/"
    unless_null $P6096, vivify_2667
    new $P6096, "Undef"
  vivify_2667:
    $P6097 = $P6092."new"("!INTERPOLATE_REGEX", $P6095, "subrule" :named("pasttype"), "method" :named("subtype"), $P6096 :named("node"))
    $P6098 = $P6091."!make"($P6097)
.annotate 'line', 2212
    .return ($P6098)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "codeblock"  :subid("569_1303401201.841") :outer("562_1303401201.841")
    .param pmc param_6100
    .param pmc param_6101
.annotate 'line', 2217
    .lex "self", param_6100
    .lex "$/", param_6101
.annotate 'line', 2218
    new $P6102, "Undef"
    .lex "$block", $P6102
.annotate 'line', 2220
    new $P6103, "Undef"
    .lex "$past", $P6103
.annotate 'line', 2218
    find_lex $P6104, "$/"
    unless_null $P6104, vivify_2668
    $P6104 = root_new ['parrot';'Hash']
  vivify_2668:
    set $P6105, $P6104["block"]
    unless_null $P6105, vivify_2669
    new $P6105, "Undef"
  vivify_2669:
    $P6106 = $P6105."ast"()
    store_lex "$block", $P6106
.annotate 'line', 2219
    find_lex $P6107, "$block"
    unless_null $P6107, vivify_2670
    new $P6107, "Undef"
  vivify_2670:
    $P6107."blocktype"("immediate")
.annotate 'line', 2221
    get_hll_global $P6108, ["PAST"], "Stmts"
.annotate 'line', 2222
    get_hll_global $P6109, ["PAST"], "Op"
.annotate 'line', 2223
    get_hll_global $P6110, ["PAST"], "Var"
    $P6111 = $P6110."new"("$/" :named("name"))
.annotate 'line', 2224
    get_hll_global $P6112, ["PAST"], "Op"
.annotate 'line', 2225
    get_hll_global $P6113, ["PAST"], "Var"
    $P6114 = $P6113."new"(unicode:"$\x{a2}" :named("name"))
    $P6115 = $P6112."new"($P6114, "MATCH" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 2224
    $P6116 = $P6109."new"($P6111, $P6115, "bind" :named("pasttype"))
.annotate 'line', 2222
    find_lex $P6117, "$block"
    unless_null $P6117, vivify_2671
    new $P6117, "Undef"
  vivify_2671:
    $P6118 = $P6108."new"($P6116, $P6117)
.annotate 'line', 2221
    store_lex "$past", $P6118
.annotate 'line', 2233
    find_lex $P6119, "$/"
    find_lex $P6120, "$past"
    unless_null $P6120, vivify_2672
    new $P6120, "Undef"
  vivify_2672:
    $P6121 = $P6119."!make"($P6120)
.annotate 'line', 2217
    .return ($P6121)
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "_block6144"  :subid("571_1303401201.841") :outer("10_1303401201.841")
.annotate 'line', 2238
    .const 'Sub' $P6149 = "572_1303401201.841" 
    capture_lex $P6149
    .lex "$?PACKAGE", $P6146
    .lex "$?CLASS", $P6147
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "" :load :init :subid("post2673") :outer("571_1303401201.841")
.annotate 'line', 2238
    get_hll_global $P6145, ["NQP";"Compiler"], "_block6144" 
    .local pmc block
    set block, $P6145
    .const 'Sub' $P6149 = "572_1303401201.841" 
    capture_lex $P6149
    $P6149()
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "_block6148"  :anon :subid("572_1303401201.841") :outer("571_1303401201.841")
.annotate 'line', 2238
    nqp_get_sc_object $P6150, "1303401190.883", 5
    .local pmc type_obj
    set type_obj, $P6150
    get_how $P6151, type_obj
    get_hll_global $P6152, ["HLL"], "Compiler"
    $P6151."add_parent"(type_obj, $P6152)
    get_how $P6153, type_obj
    $P6154 = $P6153."compose"(type_obj)
    .return ($P6154)
.end


.HLL "nqp"

.namespace []
.sub "_block6162" :load :anon :subid("573_1303401201.841")
.annotate 'line', 1
    .const 'Sub' $P6164 = "10_1303401201.841" 
    $P6165 = $P6164()
    .return ($P6165)
.end

