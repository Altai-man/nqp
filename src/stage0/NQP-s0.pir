
.HLL "nqp"

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1303340952.947")
    .param pmc param_13 :slurpy
.annotate 'line', 0
    get_hll_global $P6068, ["NQP";"Compiler"], "_block6067" 
    capture_lex $P6068
    get_hll_global $P5947, ["NQP";"RegexActions"], "_block5946" 
    capture_lex $P5947
    get_hll_global $P2516, ["NQP";"Actions"], "_block2515" 
    capture_lex $P2516
    get_hll_global $P2412, ["NQP";"Regex"], "_block2411" 
    capture_lex $P2412
    get_hll_global $P35, ["NQP";"Grammar"], "_block34" 
    capture_lex $P35
    .const 'Sub' $P15 = "11_1303340952.947" 
    capture_lex $P15
.annotate 'line', 1
    .lex "@ARGS", param_13
    .lex "GLOBALish", $P14
.annotate 'line', 2217
    .const 'Sub' $P15 = "11_1303340952.947" 
    newclosure $P33, $P15
    .lex "MAIN", $P33
.annotate 'line', 1
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
.annotate 'line', 9
    get_hll_global $P35, ["NQP";"Grammar"], "_block34" 
    capture_lex $P35
    $P35()
.annotate 'line', 703
    get_hll_global $P2412, ["NQP";"Regex"], "_block2411" 
    capture_lex $P2412
    $P2412()
.annotate 'line', 746
    get_hll_global $P2516, ["NQP";"Actions"], "_block2515" 
    capture_lex $P2516
    $P2516()
.annotate 'line', 2159
    get_hll_global $P5947, ["NQP";"RegexActions"], "_block5946" 
    capture_lex $P5947
    $P5947()
.annotate 'line', 2214
    get_hll_global $P6068, ["NQP";"Compiler"], "_block6067" 
    capture_lex $P6068
    $P6068()
    find_lex $P6078, "MAIN"
    find_lex $P6081, "@ARGS"
    if $P6081, if_6080
    set $P6079, $P6081
    goto if_6080_end
  if_6080:
    .const 'Sub' $P6082 = "11_1303340952.947" 
    find_lex $P6083, "@ARGS"
    $P6084 = $P6082($P6083 :flat)
    set $P6079, $P6084
  if_6080_end:
.annotate 'line', 1
    .return ($P6079)
    .const 'Sub' $P6086 = "574_1303340952.947" 
    .return ($P6086)
.end


.HLL "nqp"

.namespace []
.sub "" :load :init :subid("post575") :outer("10_1303340952.947")
.annotate 'line', 0
    .const 'Sub' $P12 = "10_1303340952.947" 
    .local pmc block
    set block, $P12
    nqp_get_sc $P6090, "1303340942.153"
    isnull $I6091, $P6090
    if $I6091, if_6089
    .const 'Sub' $P6170 = "10_1303340952.947" 
    $P6171 = $P6170."get_lexinfo"()
    nqp_get_sc_object $P6172, "1303340942.153", 0
    $P6171."set_static_lexpad_value"("GLOBALish", $P6172)
    .const 'Sub' $P6173 = "10_1303340952.947" 
    $P6174 = $P6173."get_lexinfo"()
    $P6174."finish_static_lexpad"()
    nqp_get_sc_object $P6175, "1303340942.153", 1
    set_hll_global ["NQP"], "Grammar", $P6175
    .const 'Sub' $P6176 = "12_1303340952.947" 
    $P6177 = $P6176."get_lexinfo"()
    nqp_get_sc_object $P6178, "1303340942.153", 1
    $P6177."set_static_lexpad_value"("$?PACKAGE", $P6178)
    .const 'Sub' $P6179 = "12_1303340952.947" 
    $P6180 = $P6179."get_lexinfo"()
    $P6180."finish_static_lexpad"()
    .const 'Sub' $P6181 = "12_1303340952.947" 
    $P6182 = $P6181."get_lexinfo"()
    nqp_get_sc_object $P6183, "1303340942.153", 1
    $P6182."set_static_lexpad_value"("$?CLASS", $P6183)
    .const 'Sub' $P6184 = "12_1303340952.947" 
    $P6185 = $P6184."get_lexinfo"()
    $P6185."finish_static_lexpad"()
    nqp_get_sc_object $P6186, "1303340942.153", 2
    set_hll_global ["NQP"], "Regex", $P6186
    .const 'Sub' $P6187 = "385_1303340952.947" 
    $P6188 = $P6187."get_lexinfo"()
    nqp_get_sc_object $P6189, "1303340942.153", 2
    $P6188."set_static_lexpad_value"("$?PACKAGE", $P6189)
    .const 'Sub' $P6190 = "385_1303340952.947" 
    $P6191 = $P6190."get_lexinfo"()
    $P6191."finish_static_lexpad"()
    .const 'Sub' $P6192 = "385_1303340952.947" 
    $P6193 = $P6192."get_lexinfo"()
    nqp_get_sc_object $P6194, "1303340942.153", 2
    $P6193."set_static_lexpad_value"("$?CLASS", $P6194)
    .const 'Sub' $P6195 = "385_1303340952.947" 
    $P6196 = $P6195."get_lexinfo"()
    $P6196."finish_static_lexpad"()
    nqp_get_sc_object $P6197, "1303340942.153", 3
    set_hll_global ["NQP"], "Actions", $P6197
    .const 'Sub' $P6198 = "407_1303340952.947" 
    $P6199 = $P6198."get_lexinfo"()
    nqp_get_sc_object $P6200, "1303340942.153", 3
    $P6199."set_static_lexpad_value"("$?PACKAGE", $P6200)
    .const 'Sub' $P6201 = "407_1303340952.947" 
    $P6202 = $P6201."get_lexinfo"()
    $P6202."finish_static_lexpad"()
    .const 'Sub' $P6203 = "407_1303340952.947" 
    $P6204 = $P6203."get_lexinfo"()
    nqp_get_sc_object $P6205, "1303340942.153", 3
    $P6204."set_static_lexpad_value"("$?CLASS", $P6205)
    .const 'Sub' $P6206 = "407_1303340952.947" 
    $P6207 = $P6206."get_lexinfo"()
    $P6207."finish_static_lexpad"()
    nqp_get_sc_object $P6208, "1303340942.153", 4
    set_hll_global ["NQP"], "RegexActions", $P6208
    .const 'Sub' $P6209 = "563_1303340952.947" 
    $P6210 = $P6209."get_lexinfo"()
    nqp_get_sc_object $P6211, "1303340942.153", 4
    $P6210."set_static_lexpad_value"("$?PACKAGE", $P6211)
    .const 'Sub' $P6212 = "563_1303340952.947" 
    $P6213 = $P6212."get_lexinfo"()
    $P6213."finish_static_lexpad"()
    .const 'Sub' $P6214 = "563_1303340952.947" 
    $P6215 = $P6214."get_lexinfo"()
    nqp_get_sc_object $P6216, "1303340942.153", 4
    $P6215."set_static_lexpad_value"("$?CLASS", $P6216)
    .const 'Sub' $P6217 = "563_1303340952.947" 
    $P6218 = $P6217."get_lexinfo"()
    $P6218."finish_static_lexpad"()
    nqp_get_sc_object $P6219, "1303340942.153", 5
    set_hll_global ["NQP"], "Compiler", $P6219
    .const 'Sub' $P6220 = "572_1303340952.947" 
    $P6221 = $P6220."get_lexinfo"()
    nqp_get_sc_object $P6222, "1303340942.153", 5
    $P6221."set_static_lexpad_value"("$?PACKAGE", $P6222)
    .const 'Sub' $P6223 = "572_1303340952.947" 
    $P6224 = $P6223."get_lexinfo"()
    $P6224."finish_static_lexpad"()
    .const 'Sub' $P6225 = "572_1303340952.947" 
    $P6226 = $P6225."get_lexinfo"()
    nqp_get_sc_object $P6227, "1303340942.153", 5
    $P6226."set_static_lexpad_value"("$?CLASS", $P6227)
    .const 'Sub' $P6228 = "572_1303340952.947" 
    $P6229 = $P6228."get_lexinfo"()
    $P6229."finish_static_lexpad"()
    goto if_6089_end
  if_6089:
    nqp_dynop_setup 
    getinterp $P6092
    get_class $P6093, "LexPad"
    get_class $P6094, "NQPLexPad"
    $P6092."hll_map"($P6093, $P6094)
    load_bytecode "nqpmo.pbc"
    nqp_create_sc $P6095, "1303340942.153"
    .local pmc cur_sc
    set cur_sc, $P6095
    load_bytecode "SettingManager.pbc"
    get_hll_global $P6096, ["HLL"], "SettingManager"
    $P6097 = $P6096."load_setting"("NQPCORE")
    block."set_outer_ctx"($P6097)
    get_hll_global $P6098, "KnowHOW"
    $P6099 = $P6098."new_type"("GLOBALish" :named("name"))
    nqp_set_sc_for_object $P6099, cur_sc
    nqp_set_sc_object "1303340942.153", 0, $P6099
    .const 'Sub' $P6100 = "10_1303340952.947" 
    $P6101 = $P6100."get_lexinfo"()
    nqp_get_sc_object $P6102, "1303340942.153", 0
    $P6101."set_static_lexpad_value"("GLOBALish", $P6102)
    .const 'Sub' $P6103 = "10_1303340952.947" 
    $P6104 = $P6103."get_lexinfo"()
    $P6104."finish_static_lexpad"()
    load_bytecode "P6Regex.pbc"
    get_hll_global $P6105, "NQPClassHOW"
    $P6106 = $P6105."new_type"("NQP::Grammar" :named("name"))
    nqp_set_sc_for_object $P6106, cur_sc
    nqp_set_sc_object "1303340942.153", 1, $P6106
    nqp_get_sc_object $P6107, "1303340942.153", 1
    set_hll_global ["NQP"], "Grammar", $P6107
    .const 'Sub' $P6108 = "12_1303340952.947" 
    $P6109 = $P6108."get_lexinfo"()
    nqp_get_sc_object $P6110, "1303340942.153", 1
    $P6109."set_static_lexpad_value"("$?PACKAGE", $P6110)
    .const 'Sub' $P6111 = "12_1303340952.947" 
    $P6112 = $P6111."get_lexinfo"()
    $P6112."finish_static_lexpad"()
    .const 'Sub' $P6113 = "12_1303340952.947" 
    $P6114 = $P6113."get_lexinfo"()
    nqp_get_sc_object $P6115, "1303340942.153", 1
    $P6114."set_static_lexpad_value"("$?CLASS", $P6115)
    .const 'Sub' $P6116 = "12_1303340952.947" 
    $P6117 = $P6116."get_lexinfo"()
    $P6117."finish_static_lexpad"()
    get_hll_global $P6118, "NQPClassHOW"
    $P6119 = $P6118."new_type"("NQP::Regex" :named("name"))
    nqp_set_sc_for_object $P6119, cur_sc
    nqp_set_sc_object "1303340942.153", 2, $P6119
    nqp_get_sc_object $P6120, "1303340942.153", 2
    set_hll_global ["NQP"], "Regex", $P6120
    .const 'Sub' $P6121 = "385_1303340952.947" 
    $P6122 = $P6121."get_lexinfo"()
    nqp_get_sc_object $P6123, "1303340942.153", 2
    $P6122."set_static_lexpad_value"("$?PACKAGE", $P6123)
    .const 'Sub' $P6124 = "385_1303340952.947" 
    $P6125 = $P6124."get_lexinfo"()
    $P6125."finish_static_lexpad"()
    .const 'Sub' $P6126 = "385_1303340952.947" 
    $P6127 = $P6126."get_lexinfo"()
    nqp_get_sc_object $P6128, "1303340942.153", 2
    $P6127."set_static_lexpad_value"("$?CLASS", $P6128)
    .const 'Sub' $P6129 = "385_1303340952.947" 
    $P6130 = $P6129."get_lexinfo"()
    $P6130."finish_static_lexpad"()
    get_hll_global $P6131, "NQPClassHOW"
    $P6132 = $P6131."new_type"("NQP::Actions" :named("name"))
    nqp_set_sc_for_object $P6132, cur_sc
    nqp_set_sc_object "1303340942.153", 3, $P6132
    nqp_get_sc_object $P6133, "1303340942.153", 3
    set_hll_global ["NQP"], "Actions", $P6133
    .const 'Sub' $P6134 = "407_1303340952.947" 
    $P6135 = $P6134."get_lexinfo"()
    nqp_get_sc_object $P6136, "1303340942.153", 3
    $P6135."set_static_lexpad_value"("$?PACKAGE", $P6136)
    .const 'Sub' $P6137 = "407_1303340952.947" 
    $P6138 = $P6137."get_lexinfo"()
    $P6138."finish_static_lexpad"()
    .const 'Sub' $P6139 = "407_1303340952.947" 
    $P6140 = $P6139."get_lexinfo"()
    nqp_get_sc_object $P6141, "1303340942.153", 3
    $P6140."set_static_lexpad_value"("$?CLASS", $P6141)
    .const 'Sub' $P6142 = "407_1303340952.947" 
    $P6143 = $P6142."get_lexinfo"()
    $P6143."finish_static_lexpad"()
    get_hll_global $P6144, "NQPClassHOW"
    $P6145 = $P6144."new_type"("NQP::RegexActions" :named("name"))
    nqp_set_sc_for_object $P6145, cur_sc
    nqp_set_sc_object "1303340942.153", 4, $P6145
    nqp_get_sc_object $P6146, "1303340942.153", 4
    set_hll_global ["NQP"], "RegexActions", $P6146
    .const 'Sub' $P6147 = "563_1303340952.947" 
    $P6148 = $P6147."get_lexinfo"()
    nqp_get_sc_object $P6149, "1303340942.153", 4
    $P6148."set_static_lexpad_value"("$?PACKAGE", $P6149)
    .const 'Sub' $P6150 = "563_1303340952.947" 
    $P6151 = $P6150."get_lexinfo"()
    $P6151."finish_static_lexpad"()
    .const 'Sub' $P6152 = "563_1303340952.947" 
    $P6153 = $P6152."get_lexinfo"()
    nqp_get_sc_object $P6154, "1303340942.153", 4
    $P6153."set_static_lexpad_value"("$?CLASS", $P6154)
    .const 'Sub' $P6155 = "563_1303340952.947" 
    $P6156 = $P6155."get_lexinfo"()
    $P6156."finish_static_lexpad"()
    get_hll_global $P6157, "NQPClassHOW"
    $P6158 = $P6157."new_type"("NQP::Compiler" :named("name"))
    nqp_set_sc_for_object $P6158, cur_sc
    nqp_set_sc_object "1303340942.153", 5, $P6158
    nqp_get_sc_object $P6159, "1303340942.153", 5
    set_hll_global ["NQP"], "Compiler", $P6159
    .const 'Sub' $P6160 = "572_1303340952.947" 
    $P6161 = $P6160."get_lexinfo"()
    nqp_get_sc_object $P6162, "1303340942.153", 5
    $P6161."set_static_lexpad_value"("$?PACKAGE", $P6162)
    .const 'Sub' $P6163 = "572_1303340952.947" 
    $P6164 = $P6163."get_lexinfo"()
    $P6164."finish_static_lexpad"()
    .const 'Sub' $P6165 = "572_1303340952.947" 
    $P6166 = $P6165."get_lexinfo"()
    nqp_get_sc_object $P6167, "1303340942.153", 5
    $P6166."set_static_lexpad_value"("$?CLASS", $P6167)
    .const 'Sub' $P6168 = "572_1303340952.947" 
    $P6169 = $P6168."get_lexinfo"()
    $P6169."finish_static_lexpad"()
  if_6089_end:
.end


.HLL "nqp"

.namespace []
.sub "MAIN"  :subid("11_1303340952.947") :outer("10_1303340952.947")
    .param pmc param_16
.annotate 'line', 2217
    .lex "@ARGS", param_16
.annotate 'line', 2219
    new $P17, "Undef"
    .lex "$nqpcomp", $P17
.annotate 'line', 2225
    $P18 = root_new ['parrot';'ResizablePMCArray']
    .lex "@clo", $P18
.annotate 'line', 2219
    get_hll_global $P19, ["NQP"], "Compiler"
    $P20 = $P19."new"()
    store_lex "$nqpcomp", $P20
.annotate 'line', 2220
    find_lex $P21, "$nqpcomp"
    unless_null $P21, vivify_576
    new $P21, "Undef"
  vivify_576:
    $P21."language"("nqp")
.annotate 'line', 2221
    find_lex $P22, "$nqpcomp"
    unless_null $P22, vivify_577
    new $P22, "Undef"
  vivify_577:
    get_hll_global $P23, ["NQP"], "Grammar"
    $P22."parsegrammar"($P23)
.annotate 'line', 2222
    find_lex $P24, "$nqpcomp"
    unless_null $P24, vivify_578
    new $P24, "Undef"
  vivify_578:
    get_hll_global $P25, ["NQP"], "Actions"
    $P24."parseactions"($P25)
.annotate 'line', 2225
    find_lex $P26, "$nqpcomp"
    unless_null $P26, vivify_579
    new $P26, "Undef"
  vivify_579:
    $P27 = $P26."commandline_options"()
    store_lex "@clo", $P27
.annotate 'line', 2226
    find_lex $P28, "@clo"
    unless_null $P28, vivify_580
    $P28 = root_new ['parrot';'ResizablePMCArray']
  vivify_580:
    $P28."push"("parsetrace")
.annotate 'line', 2227
    find_lex $P29, "@clo"
    unless_null $P29, vivify_581
    $P29 = root_new ['parrot';'ResizablePMCArray']
  vivify_581:
    $P29."push"("setting=s")
.annotate 'line', 2230
    find_lex $P30, "$nqpcomp"
    unless_null $P30, vivify_582
    new $P30, "Undef"
  vivify_582:
    find_lex $P31, "@ARGS"
    unless_null $P31, vivify_583
    $P31 = root_new ['parrot';'ResizablePMCArray']
  vivify_583:
    $P32 = $P30."command_line"($P31, "utf8" :named("encoding"), "ascii iso-8859-1" :named("transcode"))
.annotate 'line', 2217
    .return ($P32)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block34"  :subid("12_1303340952.947") :outer("10_1303340952.947")
.annotate 'line', 9
    .const 'Sub' $P1689 = "384_1303340952.947" 
    capture_lex $P1689
    .const 'Sub' $P1676 = "383_1303340952.947" 
    capture_lex $P1676
    .const 'Sub' $P1670 = "381_1303340952.947" 
    capture_lex $P1670
    .const 'Sub' $P1664 = "379_1303340952.947" 
    capture_lex $P1664
    .const 'Sub' $P1658 = "377_1303340952.947" 
    capture_lex $P1658
    .const 'Sub' $P1652 = "375_1303340952.947" 
    capture_lex $P1652
    .const 'Sub' $P1640 = "372_1303340952.947" 
    capture_lex $P1640
    .const 'Sub' $P1633 = "370_1303340952.947" 
    capture_lex $P1633
    .const 'Sub' $P1626 = "368_1303340952.947" 
    capture_lex $P1626
    .const 'Sub' $P1619 = "366_1303340952.947" 
    capture_lex $P1619
    .const 'Sub' $P1612 = "364_1303340952.947" 
    capture_lex $P1612
    .const 'Sub' $P1606 = "362_1303340952.947" 
    capture_lex $P1606
    .const 'Sub' $P1599 = "360_1303340952.947" 
    capture_lex $P1599
    .const 'Sub' $P1592 = "358_1303340952.947" 
    capture_lex $P1592
    .const 'Sub' $P1585 = "356_1303340952.947" 
    capture_lex $P1585
    .const 'Sub' $P1578 = "354_1303340952.947" 
    capture_lex $P1578
    .const 'Sub' $P1571 = "352_1303340952.947" 
    capture_lex $P1571
    .const 'Sub' $P1564 = "350_1303340952.947" 
    capture_lex $P1564
    .const 'Sub' $P1557 = "348_1303340952.947" 
    capture_lex $P1557
    .const 'Sub' $P1550 = "346_1303340952.947" 
    capture_lex $P1550
    .const 'Sub' $P1543 = "344_1303340952.947" 
    capture_lex $P1543
    .const 'Sub' $P1536 = "342_1303340952.947" 
    capture_lex $P1536
    .const 'Sub' $P1529 = "340_1303340952.947" 
    capture_lex $P1529
    .const 'Sub' $P1522 = "338_1303340952.947" 
    capture_lex $P1522
    .const 'Sub' $P1515 = "336_1303340952.947" 
    capture_lex $P1515
    .const 'Sub' $P1508 = "334_1303340952.947" 
    capture_lex $P1508
    .const 'Sub' $P1501 = "332_1303340952.947" 
    capture_lex $P1501
    .const 'Sub' $P1494 = "330_1303340952.947" 
    capture_lex $P1494
    .const 'Sub' $P1487 = "328_1303340952.947" 
    capture_lex $P1487
    .const 'Sub' $P1480 = "326_1303340952.947" 
    capture_lex $P1480
    .const 'Sub' $P1473 = "324_1303340952.947" 
    capture_lex $P1473
    .const 'Sub' $P1466 = "322_1303340952.947" 
    capture_lex $P1466
    .const 'Sub' $P1459 = "320_1303340952.947" 
    capture_lex $P1459
    .const 'Sub' $P1452 = "318_1303340952.947" 
    capture_lex $P1452
    .const 'Sub' $P1445 = "316_1303340952.947" 
    capture_lex $P1445
    .const 'Sub' $P1438 = "314_1303340952.947" 
    capture_lex $P1438
    .const 'Sub' $P1431 = "312_1303340952.947" 
    capture_lex $P1431
    .const 'Sub' $P1424 = "310_1303340952.947" 
    capture_lex $P1424
    .const 'Sub' $P1417 = "308_1303340952.947" 
    capture_lex $P1417
    .const 'Sub' $P1410 = "306_1303340952.947" 
    capture_lex $P1410
    .const 'Sub' $P1403 = "304_1303340952.947" 
    capture_lex $P1403
    .const 'Sub' $P1397 = "302_1303340952.947" 
    capture_lex $P1397
    .const 'Sub' $P1390 = "300_1303340952.947" 
    capture_lex $P1390
    .const 'Sub' $P1383 = "298_1303340952.947" 
    capture_lex $P1383
    .const 'Sub' $P1376 = "296_1303340952.947" 
    capture_lex $P1376
    .const 'Sub' $P1369 = "294_1303340952.947" 
    capture_lex $P1369
    .const 'Sub' $P1362 = "292_1303340952.947" 
    capture_lex $P1362
    .const 'Sub' $P1355 = "290_1303340952.947" 
    capture_lex $P1355
    .const 'Sub' $P1348 = "288_1303340952.947" 
    capture_lex $P1348
    .const 'Sub' $P1342 = "286_1303340952.947" 
    capture_lex $P1342
    .const 'Sub' $P1336 = "284_1303340952.947" 
    capture_lex $P1336
    .const 'Sub' $P1331 = "282_1303340952.947" 
    capture_lex $P1331
    .const 'Sub' $P1325 = "280_1303340952.947" 
    capture_lex $P1325
    .const 'Sub' $P1319 = "278_1303340952.947" 
    capture_lex $P1319
    .const 'Sub' $P1314 = "276_1303340952.947" 
    capture_lex $P1314
    .const 'Sub' $P1309 = "274_1303340952.947" 
    capture_lex $P1309
    .const 'Sub' $P1293 = "273_1303340952.947" 
    capture_lex $P1293
    .const 'Sub' $P1284 = "271_1303340952.947" 
    capture_lex $P1284
    .const 'Sub' $P1275 = "269_1303340952.947" 
    capture_lex $P1275
    .const 'Sub' $P1270 = "267_1303340952.947" 
    capture_lex $P1270
    .const 'Sub' $P1265 = "265_1303340952.947" 
    capture_lex $P1265
    .const 'Sub' $P1260 = "263_1303340952.947" 
    capture_lex $P1260
    .const 'Sub' $P1252 = "261_1303340952.947" 
    capture_lex $P1252
    .const 'Sub' $P1244 = "259_1303340952.947" 
    capture_lex $P1244
    .const 'Sub' $P1239 = "257_1303340952.947" 
    capture_lex $P1239
    .const 'Sub' $P1234 = "255_1303340952.947" 
    capture_lex $P1234
    .const 'Sub' $P1229 = "253_1303340952.947" 
    capture_lex $P1229
    .const 'Sub' $P1223 = "251_1303340952.947" 
    capture_lex $P1223
    .const 'Sub' $P1217 = "249_1303340952.947" 
    capture_lex $P1217
    .const 'Sub' $P1211 = "247_1303340952.947" 
    capture_lex $P1211
    .const 'Sub' $P1205 = "245_1303340952.947" 
    capture_lex $P1205
    .const 'Sub' $P1199 = "243_1303340952.947" 
    capture_lex $P1199
    .const 'Sub' $P1194 = "241_1303340952.947" 
    capture_lex $P1194
    .const 'Sub' $P1189 = "239_1303340952.947" 
    capture_lex $P1189
    .const 'Sub' $P1175 = "235_1303340952.947" 
    capture_lex $P1175
    .const 'Sub' $P1167 = "233_1303340952.947" 
    capture_lex $P1167
    .const 'Sub' $P1161 = "231_1303340952.947" 
    capture_lex $P1161
    .const 'Sub' $P1154 = "229_1303340952.947" 
    capture_lex $P1154
    .const 'Sub' $P1148 = "227_1303340952.947" 
    capture_lex $P1148
    .const 'Sub' $P1134 = "224_1303340952.947" 
    capture_lex $P1134
    .const 'Sub' $P1126 = "222_1303340952.947" 
    capture_lex $P1126
    .const 'Sub' $P1118 = "220_1303340952.947" 
    capture_lex $P1118
    .const 'Sub' $P1112 = "218_1303340952.947" 
    capture_lex $P1112
    .const 'Sub' $P1106 = "216_1303340952.947" 
    capture_lex $P1106
    .const 'Sub' $P1090 = "212_1303340952.947" 
    capture_lex $P1090
    .const 'Sub' $P1049 = "210_1303340952.947" 
    capture_lex $P1049
    .const 'Sub' $P1038 = "208_1303340952.947" 
    capture_lex $P1038
    .const 'Sub' $P1024 = "204_1303340952.947" 
    capture_lex $P1024
    .const 'Sub' $P1015 = "202_1303340952.947" 
    capture_lex $P1015
    .const 'Sub' $P1009 = "200_1303340952.947" 
    capture_lex $P1009
    .const 'Sub' $P999 = "198_1303340952.947" 
    capture_lex $P999
    .const 'Sub' $P984 = "196_1303340952.947" 
    capture_lex $P984
    .const 'Sub' $P970 = "193_1303340952.947" 
    capture_lex $P970
    .const 'Sub' $P962 = "191_1303340952.947" 
    capture_lex $P962
    .const 'Sub' $P952 = "189_1303340952.947" 
    capture_lex $P952
    .const 'Sub' $P942 = "187_1303340952.947" 
    capture_lex $P942
    .const 'Sub' $P923 = "182_1303340952.947" 
    capture_lex $P923
    .const 'Sub' $P879 = "179_1303340952.947" 
    capture_lex $P879
    .const 'Sub' $P845 = "177_1303340952.947" 
    capture_lex $P845
    .const 'Sub' $P838 = "175_1303340952.947" 
    capture_lex $P838
    .const 'Sub' $P831 = "173_1303340952.947" 
    capture_lex $P831
    .const 'Sub' $P814 = "169_1303340952.947" 
    capture_lex $P814
    .const 'Sub' $P806 = "167_1303340952.947" 
    capture_lex $P806
    .const 'Sub' $P800 = "165_1303340952.947" 
    capture_lex $P800
    .const 'Sub' $P784 = "163_1303340952.947" 
    capture_lex $P784
    .const 'Sub' $P777 = "161_1303340952.947" 
    capture_lex $P777
    .const 'Sub' $P770 = "159_1303340952.947" 
    capture_lex $P770
    .const 'Sub' $P763 = "157_1303340952.947" 
    capture_lex $P763
    .const 'Sub' $P685 = "152_1303340952.947" 
    capture_lex $P685
    .const 'Sub' $P673 = "150_1303340952.947" 
    capture_lex $P673
    .const 'Sub' $P661 = "148_1303340952.947" 
    capture_lex $P661
    .const 'Sub' $P649 = "146_1303340952.947" 
    capture_lex $P649
    .const 'Sub' $P637 = "144_1303340952.947" 
    capture_lex $P637
    .const 'Sub' $P625 = "142_1303340952.947" 
    capture_lex $P625
    .const 'Sub' $P613 = "140_1303340952.947" 
    capture_lex $P613
    .const 'Sub' $P602 = "136_1303340952.947" 
    capture_lex $P602
    .const 'Sub' $P597 = "134_1303340952.947" 
    capture_lex $P597
    .const 'Sub' $P585 = "132_1303340952.947" 
    capture_lex $P585
    .const 'Sub' $P573 = "130_1303340952.947" 
    capture_lex $P573
    .const 'Sub' $P566 = "128_1303340952.947" 
    capture_lex $P566
    .const 'Sub' $P561 = "126_1303340952.947" 
    capture_lex $P561
    .const 'Sub' $P555 = "124_1303340952.947" 
    capture_lex $P555
    .const 'Sub' $P549 = "122_1303340952.947" 
    capture_lex $P549
    .const 'Sub' $P534 = "118_1303340952.947" 
    capture_lex $P534
    .const 'Sub' $P528 = "116_1303340952.947" 
    capture_lex $P528
    .const 'Sub' $P522 = "114_1303340952.947" 
    capture_lex $P522
    .const 'Sub' $P516 = "112_1303340952.947" 
    capture_lex $P516
    .const 'Sub' $P510 = "110_1303340952.947" 
    capture_lex $P510
    .const 'Sub' $P504 = "108_1303340952.947" 
    capture_lex $P504
    .const 'Sub' $P498 = "106_1303340952.947" 
    capture_lex $P498
    .const 'Sub' $P489 = "104_1303340952.947" 
    capture_lex $P489
    .const 'Sub' $P480 = "102_1303340952.947" 
    capture_lex $P480
    .const 'Sub' $P471 = "100_1303340952.947" 
    capture_lex $P471
    .const 'Sub' $P456 = "96_1303340952.947" 
    capture_lex $P456
    .const 'Sub' $P447 = "94_1303340952.947" 
    capture_lex $P447
    .const 'Sub' $P435 = "90_1303340952.947" 
    capture_lex $P435
    .const 'Sub' $P428 = "88_1303340952.947" 
    capture_lex $P428
    .const 'Sub' $P421 = "86_1303340952.947" 
    capture_lex $P421
    .const 'Sub' $P407 = "82_1303340952.947" 
    capture_lex $P407
    .const 'Sub' $P399 = "80_1303340952.947" 
    capture_lex $P399
    .const 'Sub' $P391 = "78_1303340952.947" 
    capture_lex $P391
    .const 'Sub' $P371 = "76_1303340952.947" 
    capture_lex $P371
    .const 'Sub' $P362 = "74_1303340952.947" 
    capture_lex $P362
    .const 'Sub' $P344 = "71_1303340952.947" 
    capture_lex $P344
    .const 'Sub' $P326 = "69_1303340952.947" 
    capture_lex $P326
    .const 'Sub' $P318 = "67_1303340952.947" 
    capture_lex $P318
    .const 'Sub' $P307 = "63_1303340952.947" 
    capture_lex $P307
    .const 'Sub' $P302 = "61_1303340952.947" 
    capture_lex $P302
    .const 'Sub' $P291 = "57_1303340952.947" 
    capture_lex $P291
    .const 'Sub' $P286 = "55_1303340952.947" 
    capture_lex $P286
    .const 'Sub' $P281 = "53_1303340952.947" 
    capture_lex $P281
    .const 'Sub' $P276 = "51_1303340952.947" 
    capture_lex $P276
    .const 'Sub' $P271 = "49_1303340952.947" 
    capture_lex $P271
    .const 'Sub' $P261 = "47_1303340952.947" 
    capture_lex $P261
    .const 'Sub' $P254 = "45_1303340952.947" 
    capture_lex $P254
    .const 'Sub' $P248 = "43_1303340952.947" 
    capture_lex $P248
    .const 'Sub' $P240 = "41_1303340952.947" 
    capture_lex $P240
    .const 'Sub' $P234 = "39_1303340952.947" 
    capture_lex $P234
    .const 'Sub' $P228 = "37_1303340952.947" 
    capture_lex $P228
    .const 'Sub' $P213 = "34_1303340952.947" 
    capture_lex $P213
    .const 'Sub' $P199 = "32_1303340952.947" 
    capture_lex $P199
    .const 'Sub' $P186 = "30_1303340952.947" 
    capture_lex $P186
    .const 'Sub' $P147 = "27_1303340952.947" 
    capture_lex $P147
    .const 'Sub' $P132 = "24_1303340952.947" 
    capture_lex $P132
    .const 'Sub' $P121 = "22_1303340952.947" 
    capture_lex $P121
    .const 'Sub' $P109 = "20_1303340952.947" 
    capture_lex $P109
    .const 'Sub' $P101 = "18_1303340952.947" 
    capture_lex $P101
    .const 'Sub' $P94 = "16_1303340952.947" 
    capture_lex $P94
    .const 'Sub' $P87 = "14_1303340952.947" 
    capture_lex $P87
    .const 'Sub' $P38 = "13_1303340952.947" 
    capture_lex $P38
    .lex "$?PACKAGE", $P36
    .lex "$?CLASS", $P37
.annotate 'line', 10
    .const 'Sub' $P1293 = "273_1303340952.947" 
    capture_lex $P1293
    $P1293()
.annotate 'line', 697
    .const 'Sub' $P1676 = "383_1303340952.947" 
    newclosure $P1687, $P1676
.annotate 'line', 9
    .return ($P1687)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "" :load :init :subid("post584") :outer("12_1303340952.947")
.annotate 'line', 9
    get_hll_global $P35, ["NQP";"Grammar"], "_block34" 
    .local pmc block
    set block, $P35
    .const 'Sub' $P1689 = "384_1303340952.947" 
    capture_lex $P1689
    $P1689()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1688"  :anon :subid("384_1303340952.947") :outer("12_1303340952.947")
.annotate 'line', 9
    nqp_get_sc_object $P1690, "1303340942.153", 1
    .local pmc type_obj
    set type_obj, $P1690
    get_how $P1691, type_obj
    .const 'Sub' $P1692 = "13_1303340952.947" 
    $P1691."add_method"(type_obj, "TOP", $P1692)
    get_how $P1693, type_obj
    .const 'Sub' $P1694 = "14_1303340952.947" 
    $P1693."add_method"(type_obj, "identifier", $P1694)
    get_how $P1695, type_obj
    get_global $P1696, "!PREFIX__identifier"
    $P1695."add_method"(type_obj, "!PREFIX__identifier", $P1696)
    get_how $P1697, type_obj
    .const 'Sub' $P1698 = "16_1303340952.947" 
    $P1697."add_method"(type_obj, "name", $P1698)
    get_how $P1699, type_obj
    get_global $P1700, "!PREFIX__name"
    $P1699."add_method"(type_obj, "!PREFIX__name", $P1700)
    get_how $P1701, type_obj
    .const 'Sub' $P1702 = "18_1303340952.947" 
    $P1701."add_method"(type_obj, "deflongname", $P1702)
    get_how $P1703, type_obj
    get_global $P1704, "!PREFIX__deflongname"
    $P1703."add_method"(type_obj, "!PREFIX__deflongname", $P1704)
    get_how $P1705, type_obj
    .const 'Sub' $P1706 = "20_1303340952.947" 
    $P1705."add_method"(type_obj, "ENDSTMT", $P1706)
    get_how $P1707, type_obj
    get_global $P1708, "!PREFIX__ENDSTMT"
    $P1707."add_method"(type_obj, "!PREFIX__ENDSTMT", $P1708)
    get_how $P1709, type_obj
    .const 'Sub' $P1710 = "22_1303340952.947" 
    $P1709."add_method"(type_obj, "ws", $P1710)
    get_how $P1711, type_obj
    get_global $P1712, "!PREFIX__ws"
    $P1711."add_method"(type_obj, "!PREFIX__ws", $P1712)
    get_how $P1713, type_obj
    .const 'Sub' $P1714 = "24_1303340952.947" 
    $P1713."add_method"(type_obj, "unv", $P1714)
    get_how $P1715, type_obj
    get_global $P1716, "!PREFIX__unv"
    $P1715."add_method"(type_obj, "!PREFIX__unv", $P1716)
    get_how $P1717, type_obj
    .const 'Sub' $P1718 = "27_1303340952.947" 
    $P1717."add_method"(type_obj, "pod_comment", $P1718)
    get_how $P1719, type_obj
    get_global $P1720, "!PREFIX__pod_comment"
    $P1719."add_method"(type_obj, "!PREFIX__pod_comment", $P1720)
    get_how $P1721, type_obj
    .const 'Sub' $P1722 = "30_1303340952.947" 
    $P1721."add_method"(type_obj, "comp_unit", $P1722)
    get_how $P1723, type_obj
    get_global $P1724, "!PREFIX__comp_unit"
    $P1723."add_method"(type_obj, "!PREFIX__comp_unit", $P1724)
    get_how $P1725, type_obj
    .const 'Sub' $P1726 = "32_1303340952.947" 
    $P1725."add_method"(type_obj, "statementlist", $P1726)
    get_how $P1727, type_obj
    get_global $P1728, "!PREFIX__statementlist"
    $P1727."add_method"(type_obj, "!PREFIX__statementlist", $P1728)
    get_how $P1729, type_obj
    .const 'Sub' $P1730 = "34_1303340952.947" 
    $P1729."add_method"(type_obj, "statement", $P1730)
    get_how $P1731, type_obj
    get_global $P1732, "!PREFIX__statement"
    $P1731."add_method"(type_obj, "!PREFIX__statement", $P1732)
    get_how $P1733, type_obj
    .const 'Sub' $P1734 = "37_1303340952.947" 
    $P1733."add_method"(type_obj, "eat_terminator", $P1734)
    get_how $P1735, type_obj
    get_global $P1736, "!PREFIX__eat_terminator"
    $P1735."add_method"(type_obj, "!PREFIX__eat_terminator", $P1736)
    get_how $P1737, type_obj
    .const 'Sub' $P1738 = "39_1303340952.947" 
    $P1737."add_method"(type_obj, "xblock", $P1738)
    get_how $P1739, type_obj
    get_global $P1740, "!PREFIX__xblock"
    $P1739."add_method"(type_obj, "!PREFIX__xblock", $P1740)
    get_how $P1741, type_obj
    .const 'Sub' $P1742 = "41_1303340952.947" 
    $P1741."add_method"(type_obj, "pblock", $P1742)
    get_how $P1743, type_obj
    get_global $P1744, "!PREFIX__pblock"
    $P1743."add_method"(type_obj, "!PREFIX__pblock", $P1744)
    get_how $P1745, type_obj
    .const 'Sub' $P1746 = "43_1303340952.947" 
    $P1745."add_method"(type_obj, "lambda", $P1746)
    get_how $P1747, type_obj
    get_global $P1748, "!PREFIX__lambda"
    $P1747."add_method"(type_obj, "!PREFIX__lambda", $P1748)
    get_how $P1749, type_obj
    .const 'Sub' $P1750 = "45_1303340952.947" 
    $P1749."add_method"(type_obj, "block", $P1750)
    get_how $P1751, type_obj
    get_global $P1752, "!PREFIX__block"
    $P1751."add_method"(type_obj, "!PREFIX__block", $P1752)
    get_how $P1753, type_obj
    .const 'Sub' $P1754 = "47_1303340952.947" 
    $P1753."add_method"(type_obj, "blockoid", $P1754)
    get_how $P1755, type_obj
    get_global $P1756, "!PREFIX__blockoid"
    $P1755."add_method"(type_obj, "!PREFIX__blockoid", $P1756)
    get_how $P1757, type_obj
    .const 'Sub' $P1758 = "49_1303340952.947" 
    $P1757."add_method"(type_obj, "newpad", $P1758)
    get_how $P1759, type_obj
    get_global $P1760, "!PREFIX__newpad"
    $P1759."add_method"(type_obj, "!PREFIX__newpad", $P1760)
    get_how $P1761, type_obj
    .const 'Sub' $P1762 = "51_1303340952.947" 
    $P1761."add_method"(type_obj, "outerctx", $P1762)
    get_how $P1763, type_obj
    get_global $P1764, "!PREFIX__outerctx"
    $P1763."add_method"(type_obj, "!PREFIX__outerctx", $P1764)
    get_how $P1765, type_obj
    .const 'Sub' $P1766 = "53_1303340952.947" 
    $P1765."add_method"(type_obj, "GLOBALish", $P1766)
    get_how $P1767, type_obj
    get_global $P1768, "!PREFIX__GLOBALish"
    $P1767."add_method"(type_obj, "!PREFIX__GLOBALish", $P1768)
    get_how $P1769, type_obj
    .const 'Sub' $P1770 = "55_1303340952.947" 
    $P1769."add_method"(type_obj, "finishpad", $P1770)
    get_how $P1771, type_obj
    get_global $P1772, "!PREFIX__finishpad"
    $P1771."add_method"(type_obj, "!PREFIX__finishpad", $P1772)
    get_how $P1773, type_obj
    .const 'Sub' $P1774 = "57_1303340952.947" 
    $P1773."add_method"(type_obj, "you_are_here", $P1774)
    get_how $P1775, type_obj
    get_global $P1776, "!PREFIX__you_are_here"
    $P1775."add_method"(type_obj, "!PREFIX__you_are_here", $P1776)
    get_how $P1777, type_obj
    .const 'Sub' $P1778 = "59_1303340952.947" 
    $P1777."add_method"(type_obj, "terminator", $P1778)
    get_how $P1779, type_obj
    .const 'Sub' $P1780 = "60_1303340952.947" 
    $P1779."add_method"(type_obj, "!PREFIX__terminator", $P1780)
    get_how $P1781, type_obj
    .const 'Sub' $P1782 = "61_1303340952.947" 
    $P1781."add_method"(type_obj, "terminator:sym<;>", $P1782)
    get_how $P1783, type_obj
    get_global $P1784, "!PREFIX__terminator:sym<;>"
    $P1783."add_method"(type_obj, "!PREFIX__terminator:sym<;>", $P1784)
    get_how $P1785, type_obj
    .const 'Sub' $P1786 = "63_1303340952.947" 
    $P1785."add_method"(type_obj, "terminator:sym<}>", $P1786)
    get_how $P1787, type_obj
    get_global $P1788, "!PREFIX__terminator:sym<}>"
    $P1787."add_method"(type_obj, "!PREFIX__terminator:sym<}>", $P1788)
    get_how $P1789, type_obj
    .const 'Sub' $P1790 = "65_1303340952.947" 
    $P1789."add_method"(type_obj, "statement_control", $P1790)
    get_how $P1791, type_obj
    .const 'Sub' $P1792 = "66_1303340952.947" 
    $P1791."add_method"(type_obj, "!PREFIX__statement_control", $P1792)
    get_how $P1793, type_obj
    .const 'Sub' $P1794 = "67_1303340952.947" 
    $P1793."add_method"(type_obj, "statement_control:sym<use>", $P1794)
    get_how $P1795, type_obj
    get_global $P1796, "!PREFIX__statement_control:sym<use>"
    $P1795."add_method"(type_obj, "!PREFIX__statement_control:sym<use>", $P1796)
    get_how $P1797, type_obj
    .const 'Sub' $P1798 = "69_1303340952.947" 
    $P1797."add_method"(type_obj, "statement_control:sym<if>", $P1798)
    get_how $P1799, type_obj
    get_global $P1800, "!PREFIX__statement_control:sym<if>"
    $P1799."add_method"(type_obj, "!PREFIX__statement_control:sym<if>", $P1800)
    get_how $P1801, type_obj
    .const 'Sub' $P1802 = "71_1303340952.947" 
    $P1801."add_method"(type_obj, "statement_control:sym<unless>", $P1802)
    get_how $P1803, type_obj
    get_global $P1804, "!PREFIX__statement_control:sym<unless>"
    $P1803."add_method"(type_obj, "!PREFIX__statement_control:sym<unless>", $P1804)
    get_how $P1805, type_obj
    .const 'Sub' $P1806 = "74_1303340952.947" 
    $P1805."add_method"(type_obj, "statement_control:sym<while>", $P1806)
    get_how $P1807, type_obj
    get_global $P1808, "!PREFIX__statement_control:sym<while>"
    $P1807."add_method"(type_obj, "!PREFIX__statement_control:sym<while>", $P1808)
    get_how $P1809, type_obj
    .const 'Sub' $P1810 = "76_1303340952.947" 
    $P1809."add_method"(type_obj, "statement_control:sym<repeat>", $P1810)
    get_how $P1811, type_obj
    get_global $P1812, "!PREFIX__statement_control:sym<repeat>"
    $P1811."add_method"(type_obj, "!PREFIX__statement_control:sym<repeat>", $P1812)
    get_how $P1813, type_obj
    .const 'Sub' $P1814 = "78_1303340952.947" 
    $P1813."add_method"(type_obj, "statement_control:sym<for>", $P1814)
    get_how $P1815, type_obj
    get_global $P1816, "!PREFIX__statement_control:sym<for>"
    $P1815."add_method"(type_obj, "!PREFIX__statement_control:sym<for>", $P1816)
    get_how $P1817, type_obj
    .const 'Sub' $P1818 = "80_1303340952.947" 
    $P1817."add_method"(type_obj, "statement_control:sym<CATCH>", $P1818)
    get_how $P1819, type_obj
    get_global $P1820, "!PREFIX__statement_control:sym<CATCH>"
    $P1819."add_method"(type_obj, "!PREFIX__statement_control:sym<CATCH>", $P1820)
    get_how $P1821, type_obj
    .const 'Sub' $P1822 = "82_1303340952.947" 
    $P1821."add_method"(type_obj, "statement_control:sym<CONTROL>", $P1822)
    get_how $P1823, type_obj
    get_global $P1824, "!PREFIX__statement_control:sym<CONTROL>"
    $P1823."add_method"(type_obj, "!PREFIX__statement_control:sym<CONTROL>", $P1824)
    get_how $P1825, type_obj
    .const 'Sub' $P1826 = "84_1303340952.947" 
    $P1825."add_method"(type_obj, "statement_prefix", $P1826)
    get_how $P1827, type_obj
    .const 'Sub' $P1828 = "85_1303340952.947" 
    $P1827."add_method"(type_obj, "!PREFIX__statement_prefix", $P1828)
    get_how $P1829, type_obj
    .const 'Sub' $P1830 = "86_1303340952.947" 
    $P1829."add_method"(type_obj, "statement_prefix:sym<INIT>", $P1830)
    get_how $P1831, type_obj
    get_global $P1832, "!PREFIX__statement_prefix:sym<INIT>"
    $P1831."add_method"(type_obj, "!PREFIX__statement_prefix:sym<INIT>", $P1832)
    get_how $P1833, type_obj
    .const 'Sub' $P1834 = "88_1303340952.947" 
    $P1833."add_method"(type_obj, "statement_prefix:sym<try>", $P1834)
    get_how $P1835, type_obj
    get_global $P1836, "!PREFIX__statement_prefix:sym<try>"
    $P1835."add_method"(type_obj, "!PREFIX__statement_prefix:sym<try>", $P1836)
    get_how $P1837, type_obj
    .const 'Sub' $P1838 = "90_1303340952.947" 
    $P1837."add_method"(type_obj, "blorst", $P1838)
    get_how $P1839, type_obj
    get_global $P1840, "!PREFIX__blorst"
    $P1839."add_method"(type_obj, "!PREFIX__blorst", $P1840)
    get_how $P1841, type_obj
    .const 'Sub' $P1842 = "92_1303340952.947" 
    $P1841."add_method"(type_obj, "statement_mod_cond", $P1842)
    get_how $P1843, type_obj
    .const 'Sub' $P1844 = "93_1303340952.947" 
    $P1843."add_method"(type_obj, "!PREFIX__statement_mod_cond", $P1844)
    get_how $P1845, type_obj
    .const 'Sub' $P1846 = "94_1303340952.947" 
    $P1845."add_method"(type_obj, "statement_mod_cond:sym<if>", $P1846)
    get_how $P1847, type_obj
    get_global $P1848, "!PREFIX__statement_mod_cond:sym<if>"
    $P1847."add_method"(type_obj, "!PREFIX__statement_mod_cond:sym<if>", $P1848)
    get_how $P1849, type_obj
    .const 'Sub' $P1850 = "96_1303340952.947" 
    $P1849."add_method"(type_obj, "statement_mod_cond:sym<unless>", $P1850)
    get_how $P1851, type_obj
    get_global $P1852, "!PREFIX__statement_mod_cond:sym<unless>"
    $P1851."add_method"(type_obj, "!PREFIX__statement_mod_cond:sym<unless>", $P1852)
    get_how $P1853, type_obj
    .const 'Sub' $P1854 = "98_1303340952.947" 
    $P1853."add_method"(type_obj, "statement_mod_loop", $P1854)
    get_how $P1855, type_obj
    .const 'Sub' $P1856 = "99_1303340952.947" 
    $P1855."add_method"(type_obj, "!PREFIX__statement_mod_loop", $P1856)
    get_how $P1857, type_obj
    .const 'Sub' $P1858 = "100_1303340952.947" 
    $P1857."add_method"(type_obj, "statement_mod_loop:sym<while>", $P1858)
    get_how $P1859, type_obj
    get_global $P1860, "!PREFIX__statement_mod_loop:sym<while>"
    $P1859."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<while>", $P1860)
    get_how $P1861, type_obj
    .const 'Sub' $P1862 = "102_1303340952.947" 
    $P1861."add_method"(type_obj, "statement_mod_loop:sym<until>", $P1862)
    get_how $P1863, type_obj
    get_global $P1864, "!PREFIX__statement_mod_loop:sym<until>"
    $P1863."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<until>", $P1864)
    get_how $P1865, type_obj
    .const 'Sub' $P1866 = "104_1303340952.947" 
    $P1865."add_method"(type_obj, "statement_mod_loop:sym<for>", $P1866)
    get_how $P1867, type_obj
    get_global $P1868, "!PREFIX__statement_mod_loop:sym<for>"
    $P1867."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<for>", $P1868)
    get_how $P1869, type_obj
    .const 'Sub' $P1870 = "106_1303340952.947" 
    $P1869."add_method"(type_obj, "term:sym<fatarrow>", $P1870)
    get_how $P1871, type_obj
    get_global $P1872, "!PREFIX__term:sym<fatarrow>"
    $P1871."add_method"(type_obj, "!PREFIX__term:sym<fatarrow>", $P1872)
    get_how $P1873, type_obj
    .const 'Sub' $P1874 = "108_1303340952.947" 
    $P1873."add_method"(type_obj, "term:sym<colonpair>", $P1874)
    get_how $P1875, type_obj
    get_global $P1876, "!PREFIX__term:sym<colonpair>"
    $P1875."add_method"(type_obj, "!PREFIX__term:sym<colonpair>", $P1876)
    get_how $P1877, type_obj
    .const 'Sub' $P1878 = "110_1303340952.947" 
    $P1877."add_method"(type_obj, "term:sym<variable>", $P1878)
    get_how $P1879, type_obj
    get_global $P1880, "!PREFIX__term:sym<variable>"
    $P1879."add_method"(type_obj, "!PREFIX__term:sym<variable>", $P1880)
    get_how $P1881, type_obj
    .const 'Sub' $P1882 = "112_1303340952.947" 
    $P1881."add_method"(type_obj, "term:sym<package_declarator>", $P1882)
    get_how $P1883, type_obj
    get_global $P1884, "!PREFIX__term:sym<package_declarator>"
    $P1883."add_method"(type_obj, "!PREFIX__term:sym<package_declarator>", $P1884)
    get_how $P1885, type_obj
    .const 'Sub' $P1886 = "114_1303340952.947" 
    $P1885."add_method"(type_obj, "term:sym<scope_declarator>", $P1886)
    get_how $P1887, type_obj
    get_global $P1888, "!PREFIX__term:sym<scope_declarator>"
    $P1887."add_method"(type_obj, "!PREFIX__term:sym<scope_declarator>", $P1888)
    get_how $P1889, type_obj
    .const 'Sub' $P1890 = "116_1303340952.947" 
    $P1889."add_method"(type_obj, "term:sym<routine_declarator>", $P1890)
    get_how $P1891, type_obj
    get_global $P1892, "!PREFIX__term:sym<routine_declarator>"
    $P1891."add_method"(type_obj, "!PREFIX__term:sym<routine_declarator>", $P1892)
    get_how $P1893, type_obj
    .const 'Sub' $P1894 = "118_1303340952.947" 
    $P1893."add_method"(type_obj, "term:sym<multi_declarator>", $P1894)
    get_how $P1895, type_obj
    get_global $P1896, "!PREFIX__term:sym<multi_declarator>"
    $P1895."add_method"(type_obj, "!PREFIX__term:sym<multi_declarator>", $P1896)
    get_how $P1897, type_obj
    .const 'Sub' $P1898 = "122_1303340952.947" 
    $P1897."add_method"(type_obj, "term:sym<regex_declarator>", $P1898)
    get_how $P1899, type_obj
    get_global $P1900, "!PREFIX__term:sym<regex_declarator>"
    $P1899."add_method"(type_obj, "!PREFIX__term:sym<regex_declarator>", $P1900)
    get_how $P1901, type_obj
    .const 'Sub' $P1902 = "124_1303340952.947" 
    $P1901."add_method"(type_obj, "term:sym<statement_prefix>", $P1902)
    get_how $P1903, type_obj
    get_global $P1904, "!PREFIX__term:sym<statement_prefix>"
    $P1903."add_method"(type_obj, "!PREFIX__term:sym<statement_prefix>", $P1904)
    get_how $P1905, type_obj
    .const 'Sub' $P1906 = "126_1303340952.947" 
    $P1905."add_method"(type_obj, "term:sym<lambda>", $P1906)
    get_how $P1907, type_obj
    get_global $P1908, "!PREFIX__term:sym<lambda>"
    $P1907."add_method"(type_obj, "!PREFIX__term:sym<lambda>", $P1908)
    get_how $P1909, type_obj
    .const 'Sub' $P1910 = "128_1303340952.947" 
    $P1909."add_method"(type_obj, "fatarrow", $P1910)
    get_how $P1911, type_obj
    get_global $P1912, "!PREFIX__fatarrow"
    $P1911."add_method"(type_obj, "!PREFIX__fatarrow", $P1912)
    get_how $P1913, type_obj
    .const 'Sub' $P1914 = "130_1303340952.947" 
    $P1913."add_method"(type_obj, "colonpair", $P1914)
    get_how $P1915, type_obj
    get_global $P1916, "!PREFIX__colonpair"
    $P1915."add_method"(type_obj, "!PREFIX__colonpair", $P1916)
    get_how $P1917, type_obj
    .const 'Sub' $P1918 = "132_1303340952.947" 
    $P1917."add_method"(type_obj, "variable", $P1918)
    get_how $P1919, type_obj
    get_global $P1920, "!PREFIX__variable"
    $P1919."add_method"(type_obj, "!PREFIX__variable", $P1920)
    get_how $P1921, type_obj
    .const 'Sub' $P1922 = "134_1303340952.947" 
    $P1921."add_method"(type_obj, "sigil", $P1922)
    get_how $P1923, type_obj
    get_global $P1924, "!PREFIX__sigil"
    $P1923."add_method"(type_obj, "!PREFIX__sigil", $P1924)
    get_how $P1925, type_obj
    .const 'Sub' $P1926 = "136_1303340952.947" 
    $P1925."add_method"(type_obj, "twigil", $P1926)
    get_how $P1927, type_obj
    get_global $P1928, "!PREFIX__twigil"
    $P1927."add_method"(type_obj, "!PREFIX__twigil", $P1928)
    get_how $P1929, type_obj
    .const 'Sub' $P1930 = "138_1303340952.947" 
    $P1929."add_method"(type_obj, "package_declarator", $P1930)
    get_how $P1931, type_obj
    .const 'Sub' $P1932 = "139_1303340952.947" 
    $P1931."add_method"(type_obj, "!PREFIX__package_declarator", $P1932)
    get_how $P1933, type_obj
    .const 'Sub' $P1934 = "140_1303340952.947" 
    $P1933."add_method"(type_obj, "package_declarator:sym<module>", $P1934)
    get_how $P1935, type_obj
    get_global $P1936, "!PREFIX__package_declarator:sym<module>"
    $P1935."add_method"(type_obj, "!PREFIX__package_declarator:sym<module>", $P1936)
    get_how $P1937, type_obj
    .const 'Sub' $P1938 = "142_1303340952.947" 
    $P1937."add_method"(type_obj, "package_declarator:sym<knowhow>", $P1938)
    get_how $P1939, type_obj
    get_global $P1940, "!PREFIX__package_declarator:sym<knowhow>"
    $P1939."add_method"(type_obj, "!PREFIX__package_declarator:sym<knowhow>", $P1940)
    get_how $P1941, type_obj
    .const 'Sub' $P1942 = "144_1303340952.947" 
    $P1941."add_method"(type_obj, "package_declarator:sym<class>", $P1942)
    get_how $P1943, type_obj
    get_global $P1944, "!PREFIX__package_declarator:sym<class>"
    $P1943."add_method"(type_obj, "!PREFIX__package_declarator:sym<class>", $P1944)
    get_how $P1945, type_obj
    .const 'Sub' $P1946 = "146_1303340952.947" 
    $P1945."add_method"(type_obj, "package_declarator:sym<grammar>", $P1946)
    get_how $P1947, type_obj
    get_global $P1948, "!PREFIX__package_declarator:sym<grammar>"
    $P1947."add_method"(type_obj, "!PREFIX__package_declarator:sym<grammar>", $P1948)
    get_how $P1949, type_obj
    .const 'Sub' $P1950 = "148_1303340952.947" 
    $P1949."add_method"(type_obj, "package_declarator:sym<role>", $P1950)
    get_how $P1951, type_obj
    get_global $P1952, "!PREFIX__package_declarator:sym<role>"
    $P1951."add_method"(type_obj, "!PREFIX__package_declarator:sym<role>", $P1952)
    get_how $P1953, type_obj
    .const 'Sub' $P1954 = "150_1303340952.947" 
    $P1953."add_method"(type_obj, "package_declarator:sym<native>", $P1954)
    get_how $P1955, type_obj
    get_global $P1956, "!PREFIX__package_declarator:sym<native>"
    $P1955."add_method"(type_obj, "!PREFIX__package_declarator:sym<native>", $P1956)
    get_how $P1957, type_obj
    .const 'Sub' $P1958 = "152_1303340952.947" 
    $P1957."add_method"(type_obj, "package_def", $P1958)
    get_how $P1959, type_obj
    get_global $P1960, "!PREFIX__package_def"
    $P1959."add_method"(type_obj, "!PREFIX__package_def", $P1960)
    get_how $P1961, type_obj
    .const 'Sub' $P1962 = "155_1303340952.947" 
    $P1961."add_method"(type_obj, "scope_declarator", $P1962)
    get_how $P1963, type_obj
    .const 'Sub' $P1964 = "156_1303340952.947" 
    $P1963."add_method"(type_obj, "!PREFIX__scope_declarator", $P1964)
    get_how $P1965, type_obj
    .const 'Sub' $P1966 = "157_1303340952.947" 
    $P1965."add_method"(type_obj, "scope_declarator:sym<my>", $P1966)
    get_how $P1967, type_obj
    get_global $P1968, "!PREFIX__scope_declarator:sym<my>"
    $P1967."add_method"(type_obj, "!PREFIX__scope_declarator:sym<my>", $P1968)
    get_how $P1969, type_obj
    .const 'Sub' $P1970 = "159_1303340952.947" 
    $P1969."add_method"(type_obj, "scope_declarator:sym<our>", $P1970)
    get_how $P1971, type_obj
    get_global $P1972, "!PREFIX__scope_declarator:sym<our>"
    $P1971."add_method"(type_obj, "!PREFIX__scope_declarator:sym<our>", $P1972)
    get_how $P1973, type_obj
    .const 'Sub' $P1974 = "161_1303340952.947" 
    $P1973."add_method"(type_obj, "scope_declarator:sym<has>", $P1974)
    get_how $P1975, type_obj
    get_global $P1976, "!PREFIX__scope_declarator:sym<has>"
    $P1975."add_method"(type_obj, "!PREFIX__scope_declarator:sym<has>", $P1976)
    get_how $P1977, type_obj
    .const 'Sub' $P1978 = "163_1303340952.947" 
    $P1977."add_method"(type_obj, "scoped", $P1978)
    get_how $P1979, type_obj
    get_global $P1980, "!PREFIX__scoped"
    $P1979."add_method"(type_obj, "!PREFIX__scoped", $P1980)
    get_how $P1981, type_obj
    .const 'Sub' $P1982 = "165_1303340952.947" 
    $P1981."add_method"(type_obj, "typename", $P1982)
    get_how $P1983, type_obj
    get_global $P1984, "!PREFIX__typename"
    $P1983."add_method"(type_obj, "!PREFIX__typename", $P1984)
    get_how $P1985, type_obj
    .const 'Sub' $P1986 = "167_1303340952.947" 
    $P1985."add_method"(type_obj, "declarator", $P1986)
    get_how $P1987, type_obj
    get_global $P1988, "!PREFIX__declarator"
    $P1987."add_method"(type_obj, "!PREFIX__declarator", $P1988)
    get_how $P1989, type_obj
    .const 'Sub' $P1990 = "169_1303340952.947" 
    $P1989."add_method"(type_obj, "variable_declarator", $P1990)
    get_how $P1991, type_obj
    get_global $P1992, "!PREFIX__variable_declarator"
    $P1991."add_method"(type_obj, "!PREFIX__variable_declarator", $P1992)
    get_how $P1993, type_obj
    .const 'Sub' $P1994 = "171_1303340952.947" 
    $P1993."add_method"(type_obj, "routine_declarator", $P1994)
    get_how $P1995, type_obj
    .const 'Sub' $P1996 = "172_1303340952.947" 
    $P1995."add_method"(type_obj, "!PREFIX__routine_declarator", $P1996)
    get_how $P1997, type_obj
    .const 'Sub' $P1998 = "173_1303340952.947" 
    $P1997."add_method"(type_obj, "routine_declarator:sym<sub>", $P1998)
    get_how $P1999, type_obj
    get_global $P2000, "!PREFIX__routine_declarator:sym<sub>"
    $P1999."add_method"(type_obj, "!PREFIX__routine_declarator:sym<sub>", $P2000)
    get_how $P2001, type_obj
    .const 'Sub' $P2002 = "175_1303340952.947" 
    $P2001."add_method"(type_obj, "routine_declarator:sym<method>", $P2002)
    get_how $P2003, type_obj
    get_global $P2004, "!PREFIX__routine_declarator:sym<method>"
    $P2003."add_method"(type_obj, "!PREFIX__routine_declarator:sym<method>", $P2004)
    get_how $P2005, type_obj
    .const 'Sub' $P2006 = "177_1303340952.947" 
    $P2005."add_method"(type_obj, "routine_def", $P2006)
    get_how $P2007, type_obj
    get_global $P2008, "!PREFIX__routine_def"
    $P2007."add_method"(type_obj, "!PREFIX__routine_def", $P2008)
    get_how $P2009, type_obj
    .const 'Sub' $P2010 = "179_1303340952.947" 
    $P2009."add_method"(type_obj, "method_def", $P2010)
    get_how $P2011, type_obj
    get_global $P2012, "!PREFIX__method_def"
    $P2011."add_method"(type_obj, "!PREFIX__method_def", $P2012)
    get_how $P2013, type_obj
    .const 'Sub' $P2014 = "182_1303340952.947" 
    $P2013."add_method"(type_obj, "onlystar", $P2014)
    get_how $P2015, type_obj
    get_global $P2016, "!PREFIX__onlystar"
    $P2015."add_method"(type_obj, "!PREFIX__onlystar", $P2016)
    get_how $P2017, type_obj
    .const 'Sub' $P2018 = "185_1303340952.947" 
    $P2017."add_method"(type_obj, "multi_declarator", $P2018)
    get_how $P2019, type_obj
    .const 'Sub' $P2020 = "186_1303340952.947" 
    $P2019."add_method"(type_obj, "!PREFIX__multi_declarator", $P2020)
    get_how $P2021, type_obj
    .const 'Sub' $P2022 = "187_1303340952.947" 
    $P2021."add_method"(type_obj, "multi_declarator:sym<multi>", $P2022)
    get_how $P2023, type_obj
    get_global $P2024, "!PREFIX__multi_declarator:sym<multi>"
    $P2023."add_method"(type_obj, "!PREFIX__multi_declarator:sym<multi>", $P2024)
    get_how $P2025, type_obj
    .const 'Sub' $P2026 = "189_1303340952.947" 
    $P2025."add_method"(type_obj, "multi_declarator:sym<proto>", $P2026)
    get_how $P2027, type_obj
    get_global $P2028, "!PREFIX__multi_declarator:sym<proto>"
    $P2027."add_method"(type_obj, "!PREFIX__multi_declarator:sym<proto>", $P2028)
    get_how $P2029, type_obj
    .const 'Sub' $P2030 = "191_1303340952.947" 
    $P2029."add_method"(type_obj, "multi_declarator:sym<null>", $P2030)
    get_how $P2031, type_obj
    get_global $P2032, "!PREFIX__multi_declarator:sym<null>"
    $P2031."add_method"(type_obj, "!PREFIX__multi_declarator:sym<null>", $P2032)
    get_how $P2033, type_obj
    .const 'Sub' $P2034 = "193_1303340952.947" 
    $P2033."add_method"(type_obj, "signature", $P2034)
    get_how $P2035, type_obj
    get_global $P2036, "!PREFIX__signature"
    $P2035."add_method"(type_obj, "!PREFIX__signature", $P2036)
    get_how $P2037, type_obj
    .const 'Sub' $P2038 = "196_1303340952.947" 
    $P2037."add_method"(type_obj, "parameter", $P2038)
    get_how $P2039, type_obj
    get_global $P2040, "!PREFIX__parameter"
    $P2039."add_method"(type_obj, "!PREFIX__parameter", $P2040)
    get_how $P2041, type_obj
    .const 'Sub' $P2042 = "198_1303340952.947" 
    $P2041."add_method"(type_obj, "param_var", $P2042)
    get_how $P2043, type_obj
    get_global $P2044, "!PREFIX__param_var"
    $P2043."add_method"(type_obj, "!PREFIX__param_var", $P2044)
    get_how $P2045, type_obj
    .const 'Sub' $P2046 = "200_1303340952.947" 
    $P2045."add_method"(type_obj, "named_param", $P2046)
    get_how $P2047, type_obj
    get_global $P2048, "!PREFIX__named_param"
    $P2047."add_method"(type_obj, "!PREFIX__named_param", $P2048)
    get_how $P2049, type_obj
    .const 'Sub' $P2050 = "202_1303340952.947" 
    $P2049."add_method"(type_obj, "default_value", $P2050)
    get_how $P2051, type_obj
    get_global $P2052, "!PREFIX__default_value"
    $P2051."add_method"(type_obj, "!PREFIX__default_value", $P2052)
    get_how $P2053, type_obj
    .const 'Sub' $P2054 = "204_1303340952.947" 
    $P2053."add_method"(type_obj, "trait", $P2054)
    get_how $P2055, type_obj
    get_global $P2056, "!PREFIX__trait"
    $P2055."add_method"(type_obj, "!PREFIX__trait", $P2056)
    get_how $P2057, type_obj
    .const 'Sub' $P2058 = "206_1303340952.947" 
    $P2057."add_method"(type_obj, "trait_mod", $P2058)
    get_how $P2059, type_obj
    .const 'Sub' $P2060 = "207_1303340952.947" 
    $P2059."add_method"(type_obj, "!PREFIX__trait_mod", $P2060)
    get_how $P2061, type_obj
    .const 'Sub' $P2062 = "208_1303340952.947" 
    $P2061."add_method"(type_obj, "trait_mod:sym<is>", $P2062)
    get_how $P2063, type_obj
    get_global $P2064, "!PREFIX__trait_mod:sym<is>"
    $P2063."add_method"(type_obj, "!PREFIX__trait_mod:sym<is>", $P2064)
    get_how $P2065, type_obj
    .const 'Sub' $P2066 = "210_1303340952.947" 
    $P2065."add_method"(type_obj, "regex_declarator", $P2066)
    get_how $P2067, type_obj
    get_global $P2068, "!PREFIX__regex_declarator"
    $P2067."add_method"(type_obj, "!PREFIX__regex_declarator", $P2068)
    get_how $P2069, type_obj
    .const 'Sub' $P2070 = "212_1303340952.947" 
    $P2069."add_method"(type_obj, "dotty", $P2070)
    get_how $P2071, type_obj
    get_global $P2072, "!PREFIX__dotty"
    $P2071."add_method"(type_obj, "!PREFIX__dotty", $P2072)
    get_how $P2073, type_obj
    .const 'Sub' $P2074 = "214_1303340952.947" 
    $P2073."add_method"(type_obj, "term", $P2074)
    get_how $P2075, type_obj
    .const 'Sub' $P2076 = "215_1303340952.947" 
    $P2075."add_method"(type_obj, "!PREFIX__term", $P2076)
    get_how $P2077, type_obj
    .const 'Sub' $P2078 = "216_1303340952.947" 
    $P2077."add_method"(type_obj, "term:sym<self>", $P2078)
    get_how $P2079, type_obj
    get_global $P2080, "!PREFIX__term:sym<self>"
    $P2079."add_method"(type_obj, "!PREFIX__term:sym<self>", $P2080)
    get_how $P2081, type_obj
    .const 'Sub' $P2082 = "218_1303340952.947" 
    $P2081."add_method"(type_obj, "term:sym<identifier>", $P2082)
    get_how $P2083, type_obj
    get_global $P2084, "!PREFIX__term:sym<identifier>"
    $P2083."add_method"(type_obj, "!PREFIX__term:sym<identifier>", $P2084)
    get_how $P2085, type_obj
    .const 'Sub' $P2086 = "220_1303340952.947" 
    $P2085."add_method"(type_obj, "term:sym<name>", $P2086)
    get_how $P2087, type_obj
    get_global $P2088, "!PREFIX__term:sym<name>"
    $P2087."add_method"(type_obj, "!PREFIX__term:sym<name>", $P2088)
    get_how $P2089, type_obj
    .const 'Sub' $P2090 = "222_1303340952.947" 
    $P2089."add_method"(type_obj, "term:sym<pir::op>", $P2090)
    get_how $P2091, type_obj
    get_global $P2092, "!PREFIX__term:sym<pir::op>"
    $P2091."add_method"(type_obj, "!PREFIX__term:sym<pir::op>", $P2092)
    get_how $P2093, type_obj
    .const 'Sub' $P2094 = "224_1303340952.947" 
    $P2093."add_method"(type_obj, "term:sym<onlystar>", $P2094)
    get_how $P2095, type_obj
    get_global $P2096, "!PREFIX__term:sym<onlystar>"
    $P2095."add_method"(type_obj, "!PREFIX__term:sym<onlystar>", $P2096)
    get_how $P2097, type_obj
    .const 'Sub' $P2098 = "227_1303340952.947" 
    $P2097."add_method"(type_obj, "args", $P2098)
    get_how $P2099, type_obj
    get_global $P2100, "!PREFIX__args"
    $P2099."add_method"(type_obj, "!PREFIX__args", $P2100)
    get_how $P2101, type_obj
    .const 'Sub' $P2102 = "229_1303340952.947" 
    $P2101."add_method"(type_obj, "arglist", $P2102)
    get_how $P2103, type_obj
    get_global $P2104, "!PREFIX__arglist"
    $P2103."add_method"(type_obj, "!PREFIX__arglist", $P2104)
    get_how $P2105, type_obj
    .const 'Sub' $P2106 = "231_1303340952.947" 
    $P2105."add_method"(type_obj, "term:sym<value>", $P2106)
    get_how $P2107, type_obj
    get_global $P2108, "!PREFIX__term:sym<value>"
    $P2107."add_method"(type_obj, "!PREFIX__term:sym<value>", $P2108)
    get_how $P2109, type_obj
    .const 'Sub' $P2110 = "233_1303340952.947" 
    $P2109."add_method"(type_obj, "value", $P2110)
    get_how $P2111, type_obj
    get_global $P2112, "!PREFIX__value"
    $P2111."add_method"(type_obj, "!PREFIX__value", $P2112)
    get_how $P2113, type_obj
    .const 'Sub' $P2114 = "235_1303340952.947" 
    $P2113."add_method"(type_obj, "number", $P2114)
    get_how $P2115, type_obj
    get_global $P2116, "!PREFIX__number"
    $P2115."add_method"(type_obj, "!PREFIX__number", $P2116)
    get_how $P2117, type_obj
    .const 'Sub' $P2118 = "237_1303340952.947" 
    $P2117."add_method"(type_obj, "quote", $P2118)
    get_how $P2119, type_obj
    .const 'Sub' $P2120 = "238_1303340952.947" 
    $P2119."add_method"(type_obj, "!PREFIX__quote", $P2120)
    get_how $P2121, type_obj
    .const 'Sub' $P2122 = "239_1303340952.947" 
    $P2121."add_method"(type_obj, "quote:sym<apos>", $P2122)
    get_how $P2123, type_obj
    get_global $P2124, "!PREFIX__quote:sym<apos>"
    $P2123."add_method"(type_obj, "!PREFIX__quote:sym<apos>", $P2124)
    get_how $P2125, type_obj
    .const 'Sub' $P2126 = "241_1303340952.947" 
    $P2125."add_method"(type_obj, "quote:sym<dblq>", $P2126)
    get_how $P2127, type_obj
    get_global $P2128, "!PREFIX__quote:sym<dblq>"
    $P2127."add_method"(type_obj, "!PREFIX__quote:sym<dblq>", $P2128)
    get_how $P2129, type_obj
    .const 'Sub' $P2130 = "243_1303340952.947" 
    $P2129."add_method"(type_obj, "quote:sym<q>", $P2130)
    get_how $P2131, type_obj
    get_global $P2132, "!PREFIX__quote:sym<q>"
    $P2131."add_method"(type_obj, "!PREFIX__quote:sym<q>", $P2132)
    get_how $P2133, type_obj
    .const 'Sub' $P2134 = "245_1303340952.947" 
    $P2133."add_method"(type_obj, "quote:sym<qq>", $P2134)
    get_how $P2135, type_obj
    get_global $P2136, "!PREFIX__quote:sym<qq>"
    $P2135."add_method"(type_obj, "!PREFIX__quote:sym<qq>", $P2136)
    get_how $P2137, type_obj
    .const 'Sub' $P2138 = "247_1303340952.947" 
    $P2137."add_method"(type_obj, "quote:sym<Q>", $P2138)
    get_how $P2139, type_obj
    get_global $P2140, "!PREFIX__quote:sym<Q>"
    $P2139."add_method"(type_obj, "!PREFIX__quote:sym<Q>", $P2140)
    get_how $P2141, type_obj
    .const 'Sub' $P2142 = "249_1303340952.947" 
    $P2141."add_method"(type_obj, "quote:sym<Q:PIR>", $P2142)
    get_how $P2143, type_obj
    get_global $P2144, "!PREFIX__quote:sym<Q:PIR>"
    $P2143."add_method"(type_obj, "!PREFIX__quote:sym<Q:PIR>", $P2144)
    get_how $P2145, type_obj
    .const 'Sub' $P2146 = "251_1303340952.947" 
    $P2145."add_method"(type_obj, "quote:sym</ />", $P2146)
    get_how $P2147, type_obj
    get_global $P2148, "!PREFIX__quote:sym</ />"
    $P2147."add_method"(type_obj, "!PREFIX__quote:sym</ />", $P2148)
    get_how $P2149, type_obj
    .const 'Sub' $P2150 = "253_1303340952.947" 
    $P2149."add_method"(type_obj, "quote_escape:sym<$>", $P2150)
    get_how $P2151, type_obj
    get_global $P2152, "!PREFIX__quote_escape:sym<$>"
    $P2151."add_method"(type_obj, "!PREFIX__quote_escape:sym<$>", $P2152)
    get_how $P2153, type_obj
    .const 'Sub' $P2154 = "255_1303340952.947" 
    $P2153."add_method"(type_obj, "quote_escape:sym<{ }>", $P2154)
    get_how $P2155, type_obj
    get_global $P2156, "!PREFIX__quote_escape:sym<{ }>"
    $P2155."add_method"(type_obj, "!PREFIX__quote_escape:sym<{ }>", $P2156)
    get_how $P2157, type_obj
    .const 'Sub' $P2158 = "257_1303340952.947" 
    $P2157."add_method"(type_obj, "quote_escape:sym<esc>", $P2158)
    get_how $P2159, type_obj
    get_global $P2160, "!PREFIX__quote_escape:sym<esc>"
    $P2159."add_method"(type_obj, "!PREFIX__quote_escape:sym<esc>", $P2160)
    get_how $P2161, type_obj
    .const 'Sub' $P2162 = "259_1303340952.947" 
    $P2161."add_method"(type_obj, "circumfix:sym<( )>", $P2162)
    get_how $P2163, type_obj
    get_global $P2164, "!PREFIX__circumfix:sym<( )>"
    $P2163."add_method"(type_obj, "!PREFIX__circumfix:sym<( )>", $P2164)
    get_how $P2165, type_obj
    .const 'Sub' $P2166 = "261_1303340952.947" 
    $P2165."add_method"(type_obj, "circumfix:sym<[ ]>", $P2166)
    get_how $P2167, type_obj
    get_global $P2168, "!PREFIX__circumfix:sym<[ ]>"
    $P2167."add_method"(type_obj, "!PREFIX__circumfix:sym<[ ]>", $P2168)
    get_how $P2169, type_obj
    .const 'Sub' $P2170 = "263_1303340952.947" 
    $P2169."add_method"(type_obj, "circumfix:sym<ang>", $P2170)
    get_how $P2171, type_obj
    get_global $P2172, "!PREFIX__circumfix:sym<ang>"
    $P2171."add_method"(type_obj, "!PREFIX__circumfix:sym<ang>", $P2172)
    get_how $P2173, type_obj
    .const 'Sub' $P2174 = "265_1303340952.947" 
    $P2173."add_method"(type_obj, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P2174)
    get_how $P2175, type_obj
    get_global $P2176, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"
    $P2175."add_method"(type_obj, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>", $P2176)
    get_how $P2177, type_obj
    .const 'Sub' $P2178 = "267_1303340952.947" 
    $P2177."add_method"(type_obj, "circumfix:sym<{ }>", $P2178)
    get_how $P2179, type_obj
    get_global $P2180, "!PREFIX__circumfix:sym<{ }>"
    $P2179."add_method"(type_obj, "!PREFIX__circumfix:sym<{ }>", $P2180)
    get_how $P2181, type_obj
    .const 'Sub' $P2182 = "269_1303340952.947" 
    $P2181."add_method"(type_obj, "circumfix:sym<sigil>", $P2182)
    get_how $P2183, type_obj
    get_global $P2184, "!PREFIX__circumfix:sym<sigil>"
    $P2183."add_method"(type_obj, "!PREFIX__circumfix:sym<sigil>", $P2184)
    get_how $P2185, type_obj
    .const 'Sub' $P2186 = "271_1303340952.947" 
    $P2185."add_method"(type_obj, "semilist", $P2186)
    get_how $P2187, type_obj
    get_global $P2188, "!PREFIX__semilist"
    $P2187."add_method"(type_obj, "!PREFIX__semilist", $P2188)
    get_how $P2189, type_obj
    .const 'Sub' $P2190 = "274_1303340952.947" 
    $P2189."add_method"(type_obj, "infixish", $P2190)
    get_how $P2191, type_obj
    get_global $P2192, "!PREFIX__infixish"
    $P2191."add_method"(type_obj, "!PREFIX__infixish", $P2192)
    get_how $P2193, type_obj
    .const 'Sub' $P2194 = "276_1303340952.947" 
    $P2193."add_method"(type_obj, "infixstopper", $P2194)
    get_how $P2195, type_obj
    get_global $P2196, "!PREFIX__infixstopper"
    $P2195."add_method"(type_obj, "!PREFIX__infixstopper", $P2196)
    get_how $P2197, type_obj
    .const 'Sub' $P2198 = "278_1303340952.947" 
    $P2197."add_method"(type_obj, "postcircumfix:sym<[ ]>", $P2198)
    get_how $P2199, type_obj
    get_global $P2200, "!PREFIX__postcircumfix:sym<[ ]>"
    $P2199."add_method"(type_obj, "!PREFIX__postcircumfix:sym<[ ]>", $P2200)
    get_how $P2201, type_obj
    .const 'Sub' $P2202 = "280_1303340952.947" 
    $P2201."add_method"(type_obj, "postcircumfix:sym<{ }>", $P2202)
    get_how $P2203, type_obj
    get_global $P2204, "!PREFIX__postcircumfix:sym<{ }>"
    $P2203."add_method"(type_obj, "!PREFIX__postcircumfix:sym<{ }>", $P2204)
    get_how $P2205, type_obj
    .const 'Sub' $P2206 = "282_1303340952.947" 
    $P2205."add_method"(type_obj, "postcircumfix:sym<ang>", $P2206)
    get_how $P2207, type_obj
    get_global $P2208, "!PREFIX__postcircumfix:sym<ang>"
    $P2207."add_method"(type_obj, "!PREFIX__postcircumfix:sym<ang>", $P2208)
    get_how $P2209, type_obj
    .const 'Sub' $P2210 = "284_1303340952.947" 
    $P2209."add_method"(type_obj, "postcircumfix:sym<( )>", $P2210)
    get_how $P2211, type_obj
    get_global $P2212, "!PREFIX__postcircumfix:sym<( )>"
    $P2211."add_method"(type_obj, "!PREFIX__postcircumfix:sym<( )>", $P2212)
    get_how $P2213, type_obj
    .const 'Sub' $P2214 = "286_1303340952.947" 
    $P2213."add_method"(type_obj, "postfix:sym<.>", $P2214)
    get_how $P2215, type_obj
    get_global $P2216, "!PREFIX__postfix:sym<.>"
    $P2215."add_method"(type_obj, "!PREFIX__postfix:sym<.>", $P2216)
    get_how $P2217, type_obj
    .const 'Sub' $P2218 = "288_1303340952.947" 
    $P2217."add_method"(type_obj, "prefix:sym<++>", $P2218)
    get_how $P2219, type_obj
    get_global $P2220, "!PREFIX__prefix:sym<++>"
    $P2219."add_method"(type_obj, "!PREFIX__prefix:sym<++>", $P2220)
    get_how $P2221, type_obj
    .const 'Sub' $P2222 = "290_1303340952.947" 
    $P2221."add_method"(type_obj, "prefix:sym<-->", $P2222)
    get_how $P2223, type_obj
    get_global $P2224, "!PREFIX__prefix:sym<-->"
    $P2223."add_method"(type_obj, "!PREFIX__prefix:sym<-->", $P2224)
    get_how $P2225, type_obj
    .const 'Sub' $P2226 = "292_1303340952.947" 
    $P2225."add_method"(type_obj, "postfix:sym<++>", $P2226)
    get_how $P2227, type_obj
    get_global $P2228, "!PREFIX__postfix:sym<++>"
    $P2227."add_method"(type_obj, "!PREFIX__postfix:sym<++>", $P2228)
    get_how $P2229, type_obj
    .const 'Sub' $P2230 = "294_1303340952.947" 
    $P2229."add_method"(type_obj, "postfix:sym<-->", $P2230)
    get_how $P2231, type_obj
    get_global $P2232, "!PREFIX__postfix:sym<-->"
    $P2231."add_method"(type_obj, "!PREFIX__postfix:sym<-->", $P2232)
    get_how $P2233, type_obj
    .const 'Sub' $P2234 = "296_1303340952.947" 
    $P2233."add_method"(type_obj, "infix:sym<**>", $P2234)
    get_how $P2235, type_obj
    get_global $P2236, "!PREFIX__infix:sym<**>"
    $P2235."add_method"(type_obj, "!PREFIX__infix:sym<**>", $P2236)
    get_how $P2237, type_obj
    .const 'Sub' $P2238 = "298_1303340952.947" 
    $P2237."add_method"(type_obj, "prefix:sym<+>", $P2238)
    get_how $P2239, type_obj
    get_global $P2240, "!PREFIX__prefix:sym<+>"
    $P2239."add_method"(type_obj, "!PREFIX__prefix:sym<+>", $P2240)
    get_how $P2241, type_obj
    .const 'Sub' $P2242 = "300_1303340952.947" 
    $P2241."add_method"(type_obj, "prefix:sym<~>", $P2242)
    get_how $P2243, type_obj
    get_global $P2244, "!PREFIX__prefix:sym<~>"
    $P2243."add_method"(type_obj, "!PREFIX__prefix:sym<~>", $P2244)
    get_how $P2245, type_obj
    .const 'Sub' $P2246 = "302_1303340952.947" 
    $P2245."add_method"(type_obj, "prefix:sym<->", $P2246)
    get_how $P2247, type_obj
    get_global $P2248, "!PREFIX__prefix:sym<->"
    $P2247."add_method"(type_obj, "!PREFIX__prefix:sym<->", $P2248)
    get_how $P2249, type_obj
    .const 'Sub' $P2250 = "304_1303340952.947" 
    $P2249."add_method"(type_obj, "prefix:sym<?>", $P2250)
    get_how $P2251, type_obj
    get_global $P2252, "!PREFIX__prefix:sym<?>"
    $P2251."add_method"(type_obj, "!PREFIX__prefix:sym<?>", $P2252)
    get_how $P2253, type_obj
    .const 'Sub' $P2254 = "306_1303340952.947" 
    $P2253."add_method"(type_obj, "prefix:sym<!>", $P2254)
    get_how $P2255, type_obj
    get_global $P2256, "!PREFIX__prefix:sym<!>"
    $P2255."add_method"(type_obj, "!PREFIX__prefix:sym<!>", $P2256)
    get_how $P2257, type_obj
    .const 'Sub' $P2258 = "308_1303340952.947" 
    $P2257."add_method"(type_obj, "prefix:sym<|>", $P2258)
    get_how $P2259, type_obj
    get_global $P2260, "!PREFIX__prefix:sym<|>"
    $P2259."add_method"(type_obj, "!PREFIX__prefix:sym<|>", $P2260)
    get_how $P2261, type_obj
    .const 'Sub' $P2262 = "310_1303340952.947" 
    $P2261."add_method"(type_obj, "infix:sym<*>", $P2262)
    get_how $P2263, type_obj
    get_global $P2264, "!PREFIX__infix:sym<*>"
    $P2263."add_method"(type_obj, "!PREFIX__infix:sym<*>", $P2264)
    get_how $P2265, type_obj
    .const 'Sub' $P2266 = "312_1303340952.947" 
    $P2265."add_method"(type_obj, "infix:sym</>", $P2266)
    get_how $P2267, type_obj
    get_global $P2268, "!PREFIX__infix:sym</>"
    $P2267."add_method"(type_obj, "!PREFIX__infix:sym</>", $P2268)
    get_how $P2269, type_obj
    .const 'Sub' $P2270 = "314_1303340952.947" 
    $P2269."add_method"(type_obj, "infix:sym<%>", $P2270)
    get_how $P2271, type_obj
    get_global $P2272, "!PREFIX__infix:sym<%>"
    $P2271."add_method"(type_obj, "!PREFIX__infix:sym<%>", $P2272)
    get_how $P2273, type_obj
    .const 'Sub' $P2274 = "316_1303340952.947" 
    $P2273."add_method"(type_obj, "infix:sym<+&>", $P2274)
    get_how $P2275, type_obj
    get_global $P2276, "!PREFIX__infix:sym<+&>"
    $P2275."add_method"(type_obj, "!PREFIX__infix:sym<+&>", $P2276)
    get_how $P2277, type_obj
    .const 'Sub' $P2278 = "318_1303340952.947" 
    $P2277."add_method"(type_obj, "infix:sym<+>", $P2278)
    get_how $P2279, type_obj
    get_global $P2280, "!PREFIX__infix:sym<+>"
    $P2279."add_method"(type_obj, "!PREFIX__infix:sym<+>", $P2280)
    get_how $P2281, type_obj
    .const 'Sub' $P2282 = "320_1303340952.947" 
    $P2281."add_method"(type_obj, "infix:sym<->", $P2282)
    get_how $P2283, type_obj
    get_global $P2284, "!PREFIX__infix:sym<->"
    $P2283."add_method"(type_obj, "!PREFIX__infix:sym<->", $P2284)
    get_how $P2285, type_obj
    .const 'Sub' $P2286 = "322_1303340952.947" 
    $P2285."add_method"(type_obj, "infix:sym<+|>", $P2286)
    get_how $P2287, type_obj
    get_global $P2288, "!PREFIX__infix:sym<+|>"
    $P2287."add_method"(type_obj, "!PREFIX__infix:sym<+|>", $P2288)
    get_how $P2289, type_obj
    .const 'Sub' $P2290 = "324_1303340952.947" 
    $P2289."add_method"(type_obj, "infix:sym<+^>", $P2290)
    get_how $P2291, type_obj
    get_global $P2292, "!PREFIX__infix:sym<+^>"
    $P2291."add_method"(type_obj, "!PREFIX__infix:sym<+^>", $P2292)
    get_how $P2293, type_obj
    .const 'Sub' $P2294 = "326_1303340952.947" 
    $P2293."add_method"(type_obj, "infix:sym<~>", $P2294)
    get_how $P2295, type_obj
    get_global $P2296, "!PREFIX__infix:sym<~>"
    $P2295."add_method"(type_obj, "!PREFIX__infix:sym<~>", $P2296)
    get_how $P2297, type_obj
    .const 'Sub' $P2298 = "328_1303340952.947" 
    $P2297."add_method"(type_obj, "infix:sym<==>", $P2298)
    get_how $P2299, type_obj
    get_global $P2300, "!PREFIX__infix:sym<==>"
    $P2299."add_method"(type_obj, "!PREFIX__infix:sym<==>", $P2300)
    get_how $P2301, type_obj
    .const 'Sub' $P2302 = "330_1303340952.947" 
    $P2301."add_method"(type_obj, "infix:sym<!=>", $P2302)
    get_how $P2303, type_obj
    get_global $P2304, "!PREFIX__infix:sym<!=>"
    $P2303."add_method"(type_obj, "!PREFIX__infix:sym<!=>", $P2304)
    get_how $P2305, type_obj
    .const 'Sub' $P2306 = "332_1303340952.947" 
    $P2305."add_method"(type_obj, "infix:sym<<=>", $P2306)
    get_how $P2307, type_obj
    get_global $P2308, "!PREFIX__infix:sym<<=>"
    $P2307."add_method"(type_obj, "!PREFIX__infix:sym<<=>", $P2308)
    get_how $P2309, type_obj
    .const 'Sub' $P2310 = "334_1303340952.947" 
    $P2309."add_method"(type_obj, "infix:sym<>=>", $P2310)
    get_how $P2311, type_obj
    get_global $P2312, "!PREFIX__infix:sym<>=>"
    $P2311."add_method"(type_obj, "!PREFIX__infix:sym<>=>", $P2312)
    get_how $P2313, type_obj
    .const 'Sub' $P2314 = "336_1303340952.947" 
    $P2313."add_method"(type_obj, "infix:sym<<>", $P2314)
    get_how $P2315, type_obj
    get_global $P2316, "!PREFIX__infix:sym<<>"
    $P2315."add_method"(type_obj, "!PREFIX__infix:sym<<>", $P2316)
    get_how $P2317, type_obj
    .const 'Sub' $P2318 = "338_1303340952.947" 
    $P2317."add_method"(type_obj, "infix:sym<>>", $P2318)
    get_how $P2319, type_obj
    get_global $P2320, "!PREFIX__infix:sym<>>"
    $P2319."add_method"(type_obj, "!PREFIX__infix:sym<>>", $P2320)
    get_how $P2321, type_obj
    .const 'Sub' $P2322 = "340_1303340952.947" 
    $P2321."add_method"(type_obj, "infix:sym<eq>", $P2322)
    get_how $P2323, type_obj
    get_global $P2324, "!PREFIX__infix:sym<eq>"
    $P2323."add_method"(type_obj, "!PREFIX__infix:sym<eq>", $P2324)
    get_how $P2325, type_obj
    .const 'Sub' $P2326 = "342_1303340952.947" 
    $P2325."add_method"(type_obj, "infix:sym<ne>", $P2326)
    get_how $P2327, type_obj
    get_global $P2328, "!PREFIX__infix:sym<ne>"
    $P2327."add_method"(type_obj, "!PREFIX__infix:sym<ne>", $P2328)
    get_how $P2329, type_obj
    .const 'Sub' $P2330 = "344_1303340952.947" 
    $P2329."add_method"(type_obj, "infix:sym<le>", $P2330)
    get_how $P2331, type_obj
    get_global $P2332, "!PREFIX__infix:sym<le>"
    $P2331."add_method"(type_obj, "!PREFIX__infix:sym<le>", $P2332)
    get_how $P2333, type_obj
    .const 'Sub' $P2334 = "346_1303340952.947" 
    $P2333."add_method"(type_obj, "infix:sym<ge>", $P2334)
    get_how $P2335, type_obj
    get_global $P2336, "!PREFIX__infix:sym<ge>"
    $P2335."add_method"(type_obj, "!PREFIX__infix:sym<ge>", $P2336)
    get_how $P2337, type_obj
    .const 'Sub' $P2338 = "348_1303340952.947" 
    $P2337."add_method"(type_obj, "infix:sym<lt>", $P2338)
    get_how $P2339, type_obj
    get_global $P2340, "!PREFIX__infix:sym<lt>"
    $P2339."add_method"(type_obj, "!PREFIX__infix:sym<lt>", $P2340)
    get_how $P2341, type_obj
    .const 'Sub' $P2342 = "350_1303340952.947" 
    $P2341."add_method"(type_obj, "infix:sym<gt>", $P2342)
    get_how $P2343, type_obj
    get_global $P2344, "!PREFIX__infix:sym<gt>"
    $P2343."add_method"(type_obj, "!PREFIX__infix:sym<gt>", $P2344)
    get_how $P2345, type_obj
    .const 'Sub' $P2346 = "352_1303340952.947" 
    $P2345."add_method"(type_obj, "infix:sym<=:=>", $P2346)
    get_how $P2347, type_obj
    get_global $P2348, "!PREFIX__infix:sym<=:=>"
    $P2347."add_method"(type_obj, "!PREFIX__infix:sym<=:=>", $P2348)
    get_how $P2349, type_obj
    .const 'Sub' $P2350 = "354_1303340952.947" 
    $P2349."add_method"(type_obj, "infix:sym<~~>", $P2350)
    get_how $P2351, type_obj
    get_global $P2352, "!PREFIX__infix:sym<~~>"
    $P2351."add_method"(type_obj, "!PREFIX__infix:sym<~~>", $P2352)
    get_how $P2353, type_obj
    .const 'Sub' $P2354 = "356_1303340952.947" 
    $P2353."add_method"(type_obj, "infix:sym<&&>", $P2354)
    get_how $P2355, type_obj
    get_global $P2356, "!PREFIX__infix:sym<&&>"
    $P2355."add_method"(type_obj, "!PREFIX__infix:sym<&&>", $P2356)
    get_how $P2357, type_obj
    .const 'Sub' $P2358 = "358_1303340952.947" 
    $P2357."add_method"(type_obj, "infix:sym<||>", $P2358)
    get_how $P2359, type_obj
    get_global $P2360, "!PREFIX__infix:sym<||>"
    $P2359."add_method"(type_obj, "!PREFIX__infix:sym<||>", $P2360)
    get_how $P2361, type_obj
    .const 'Sub' $P2362 = "360_1303340952.947" 
    $P2361."add_method"(type_obj, "infix:sym<//>", $P2362)
    get_how $P2363, type_obj
    get_global $P2364, "!PREFIX__infix:sym<//>"
    $P2363."add_method"(type_obj, "!PREFIX__infix:sym<//>", $P2364)
    get_how $P2365, type_obj
    .const 'Sub' $P2366 = "362_1303340952.947" 
    $P2365."add_method"(type_obj, "infix:sym<?? !!>", $P2366)
    get_how $P2367, type_obj
    get_global $P2368, "!PREFIX__infix:sym<?? !!>"
    $P2367."add_method"(type_obj, "!PREFIX__infix:sym<?? !!>", $P2368)
    get_how $P2369, type_obj
    .const 'Sub' $P2370 = "364_1303340952.947" 
    $P2369."add_method"(type_obj, "infix:sym<=>", $P2370)
    get_how $P2371, type_obj
    get_global $P2372, "!PREFIX__infix:sym<=>"
    $P2371."add_method"(type_obj, "!PREFIX__infix:sym<=>", $P2372)
    get_how $P2373, type_obj
    .const 'Sub' $P2374 = "366_1303340952.947" 
    $P2373."add_method"(type_obj, "infix:sym<:=>", $P2374)
    get_how $P2375, type_obj
    get_global $P2376, "!PREFIX__infix:sym<:=>"
    $P2375."add_method"(type_obj, "!PREFIX__infix:sym<:=>", $P2376)
    get_how $P2377, type_obj
    .const 'Sub' $P2378 = "368_1303340952.947" 
    $P2377."add_method"(type_obj, "infix:sym<::=>", $P2378)
    get_how $P2379, type_obj
    get_global $P2380, "!PREFIX__infix:sym<::=>"
    $P2379."add_method"(type_obj, "!PREFIX__infix:sym<::=>", $P2380)
    get_how $P2381, type_obj
    .const 'Sub' $P2382 = "370_1303340952.947" 
    $P2381."add_method"(type_obj, "infix:sym<,>", $P2382)
    get_how $P2383, type_obj
    get_global $P2384, "!PREFIX__infix:sym<,>"
    $P2383."add_method"(type_obj, "!PREFIX__infix:sym<,>", $P2384)
    get_how $P2385, type_obj
    .const 'Sub' $P2386 = "372_1303340952.947" 
    $P2385."add_method"(type_obj, "prefix:sym<return>", $P2386)
    get_how $P2387, type_obj
    get_global $P2388, "!PREFIX__prefix:sym<return>"
    $P2387."add_method"(type_obj, "!PREFIX__prefix:sym<return>", $P2388)
    get_how $P2389, type_obj
    .const 'Sub' $P2390 = "375_1303340952.947" 
    $P2389."add_method"(type_obj, "prefix:sym<make>", $P2390)
    get_how $P2391, type_obj
    get_global $P2392, "!PREFIX__prefix:sym<make>"
    $P2391."add_method"(type_obj, "!PREFIX__prefix:sym<make>", $P2392)
    get_how $P2393, type_obj
    .const 'Sub' $P2394 = "377_1303340952.947" 
    $P2393."add_method"(type_obj, "term:sym<last>", $P2394)
    get_how $P2395, type_obj
    get_global $P2396, "!PREFIX__term:sym<last>"
    $P2395."add_method"(type_obj, "!PREFIX__term:sym<last>", $P2396)
    get_how $P2397, type_obj
    .const 'Sub' $P2398 = "379_1303340952.947" 
    $P2397."add_method"(type_obj, "term:sym<next>", $P2398)
    get_how $P2399, type_obj
    get_global $P2400, "!PREFIX__term:sym<next>"
    $P2399."add_method"(type_obj, "!PREFIX__term:sym<next>", $P2400)
    get_how $P2401, type_obj
    .const 'Sub' $P2402 = "381_1303340952.947" 
    $P2401."add_method"(type_obj, "term:sym<redo>", $P2402)
    get_how $P2403, type_obj
    get_global $P2404, "!PREFIX__term:sym<redo>"
    $P2403."add_method"(type_obj, "!PREFIX__term:sym<redo>", $P2404)
    get_how $P2405, type_obj
    .const 'Sub' $P2406 = "383_1303340952.947" 
    $P2405."add_method"(type_obj, "smartmatch", $P2406)
    get_how $P2407, type_obj
    get_hll_global $P2408, ["HLL"], "Grammar"
    $P2407."add_parent"(type_obj, $P2408)
    get_how $P2409, type_obj
    $P2410 = $P2409."compose"(type_obj)
    .return ($P2410)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "TOP"  :subid("13_1303340952.947") :outer("12_1303340952.947")
    .param pmc param_39
.annotate 'line', 10
    .lex "self", param_39
.annotate 'line', 12
    $P40 = root_new ['parrot';'Hash']
    .lex "%*LANG", $P40
.annotate 'line', 19
    $P41 = root_new ['parrot';'Hash']
    .lex "%*HOW", $P41
.annotate 'line', 28
    new $P42, "Undef"
    .lex "$*DEFAULT-METAATTR", $P42
.annotate 'line', 29
    $P43 = root_new ['parrot';'Hash']
    .lex "%*HOW-METAATTR", $P43
.annotate 'line', 35
    new $P44, "Undef"
    .lex "$*SC", $P44
.annotate 'line', 39
    new $P45, "Undef"
    .lex "$*SCOPE", $P45
.annotate 'line', 40
    new $P46, "Undef"
    .lex "$*MULTINESS", $P46
.annotate 'line', 41
    new $P47, "Undef"
    .lex "$*INVOCANT_OK", $P47
.annotate 'line', 42
    new $P48, "Undef"
    .lex "$*RETURN_USED", $P48
.annotate 'line', 43
    new $P49, "Undef"
    .lex "$*PACKAGE-SETUP", $P49
.annotate 'line', 10
    find_lex $P50, "%*LANG"
    unless_null $P50, vivify_585
    get_hll_global $P50, "%LANG"
    unless_null $P50, vivify_586
    die "Contextual %*LANG not found"
  vivify_586:
  vivify_585:
.annotate 'line', 13
    get_hll_global $P51, ["NQP"], "Regex"
    find_lex $P52, "%*LANG"
    unless_null $P52, vivify_587
    get_hll_global $P52, "%LANG"
    unless_null $P52, vivify_588
    die "Contextual %*LANG not found"
  vivify_588:
    store_lex "%*LANG", $P52
  vivify_587:
    set $P52["Regex"], $P51
.annotate 'line', 14
    get_hll_global $P53, ["NQP"], "RegexActions"
    find_lex $P54, "%*LANG"
    unless_null $P54, vivify_589
    get_hll_global $P54, "%LANG"
    unless_null $P54, vivify_590
    die "Contextual %*LANG not found"
  vivify_590:
    store_lex "%*LANG", $P54
  vivify_589:
    set $P54["Regex-actions"], $P53
.annotate 'line', 15
    get_hll_global $P55, ["NQP"], "Grammar"
    find_lex $P56, "%*LANG"
    unless_null $P56, vivify_591
    get_hll_global $P56, "%LANG"
    unless_null $P56, vivify_592
    die "Contextual %*LANG not found"
  vivify_592:
    store_lex "%*LANG", $P56
  vivify_591:
    set $P56["MAIN"], $P55
.annotate 'line', 16
    get_hll_global $P57, ["NQP"], "Actions"
    find_lex $P58, "%*LANG"
    unless_null $P58, vivify_593
    get_hll_global $P58, "%LANG"
    unless_null $P58, vivify_594
    die "Contextual %*LANG not found"
  vivify_594:
    store_lex "%*LANG", $P58
  vivify_593:
    set $P58["MAIN-actions"], $P57
    find_lex $P59, "%*HOW"
    unless_null $P59, vivify_595
    get_hll_global $P59, "%HOW"
    unless_null $P59, vivify_596
    die "Contextual %*HOW not found"
  vivify_596:
  vivify_595:
.annotate 'line', 20
    get_hll_global $P60, "KnowHOW"
    find_lex $P61, "%*HOW"
    unless_null $P61, vivify_597
    get_hll_global $P61, "%HOW"
    unless_null $P61, vivify_598
    die "Contextual %*HOW not found"
  vivify_598:
    store_lex "%*HOW", $P61
  vivify_597:
    set $P61["knowhow"], $P60
.annotate 'line', 21
    get_hll_global $P62, "NQPModuleHOW"
    find_lex $P63, "%*HOW"
    unless_null $P63, vivify_599
    get_hll_global $P63, "%HOW"
    unless_null $P63, vivify_600
    die "Contextual %*HOW not found"
  vivify_600:
    store_lex "%*HOW", $P63
  vivify_599:
    set $P63["module"], $P62
.annotate 'line', 22
    get_hll_global $P64, "NQPClassHOW"
    find_lex $P65, "%*HOW"
    unless_null $P65, vivify_601
    get_hll_global $P65, "%HOW"
    unless_null $P65, vivify_602
    die "Contextual %*HOW not found"
  vivify_602:
    store_lex "%*HOW", $P65
  vivify_601:
    set $P65["class"], $P64
.annotate 'line', 23
    get_hll_global $P66, "NQPClassHOW"
    find_lex $P67, "%*HOW"
    unless_null $P67, vivify_603
    get_hll_global $P67, "%HOW"
    unless_null $P67, vivify_604
    die "Contextual %*HOW not found"
  vivify_604:
    store_lex "%*HOW", $P67
  vivify_603:
    set $P67["grammar"], $P66
.annotate 'line', 24
    get_hll_global $P68, "NQPParametricRoleHOW"
    find_lex $P69, "%*HOW"
    unless_null $P69, vivify_605
    get_hll_global $P69, "%HOW"
    unless_null $P69, vivify_606
    die "Contextual %*HOW not found"
  vivify_606:
    store_lex "%*HOW", $P69
  vivify_605:
    set $P69["role"], $P68
.annotate 'line', 25
    get_hll_global $P70, "NQPNativeHOW"
    find_lex $P71, "%*HOW"
    unless_null $P71, vivify_607
    get_hll_global $P71, "%HOW"
    unless_null $P71, vivify_608
    die "Contextual %*HOW not found"
  vivify_608:
    store_lex "%*HOW", $P71
  vivify_607:
    set $P71["native"], $P70
.annotate 'line', 28
    new $P72, "String"
    assign $P72, "NQPAttribute"
    store_lex "$*DEFAULT-METAATTR", $P72
    find_lex $P73, "%*HOW-METAATTR"
    unless_null $P73, vivify_609
    get_hll_global $P73, "%HOW-METAATTR"
    unless_null $P73, vivify_610
    die "Contextual %*HOW-METAATTR not found"
  vivify_610:
  vivify_609:
.annotate 'line', 30
    new $P74, "String"
    assign $P74, "KnowHOWAttribute"
    find_lex $P75, "%*HOW-METAATTR"
    unless_null $P75, vivify_611
    get_hll_global $P75, "%HOW-METAATTR"
    unless_null $P75, vivify_612
    die "Contextual %*HOW-METAATTR not found"
  vivify_612:
    store_lex "%*HOW-METAATTR", $P75
  vivify_611:
    set $P75["knowhow"], $P74
.annotate 'line', 35
    get_hll_global $P76, ["HLL";"Compiler"], "SerializationContextBuilder"
.annotate 'line', 37
    time $N77
    set $S78, $N77
    $P79 = $P76."new"($S78 :named("handle"))
.annotate 'line', 35
    store_lex "$*SC", $P79
.annotate 'line', 39
    new $P80, "String"
    assign $P80, ""
    store_lex "$*SCOPE", $P80
.annotate 'line', 40
    new $P81, "String"
    assign $P81, ""
    store_lex "$*MULTINESS", $P81
.annotate 'line', 41
    new $P82, "Integer"
    assign $P82, 0
    store_lex "$*INVOCANT_OK", $P82
.annotate 'line', 42
    new $P83, "Integer"
    assign $P83, 0
    store_lex "$*RETURN_USED", $P83
    find_lex $P84, "$*PACKAGE-SETUP"
    unless_null $P84, vivify_613
    get_hll_global $P84, "$PACKAGE-SETUP"
    unless_null $P84, vivify_614
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_614:
  vivify_613:
.annotate 'line', 44
    find_lex $P85, "self"
    $P86 = $P85."comp_unit"()
.annotate 'line', 10
    .return ($P86)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "identifier"  :subid("14_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx88_tgt
    .local int rx88_pos
    .local int rx88_off
    .local int rx88_eos
    .local int rx88_rep
    .local pmc rx88_cur
    .local pmc rx88_debug
    (rx88_cur, rx88_pos, rx88_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx88_cur
    .local pmc match
    .lex "$/", match
    length rx88_eos, rx88_tgt
    gt rx88_pos, rx88_eos, rx88_done
    set rx88_off, 0
    lt rx88_pos, 2, rx88_start
    sub rx88_off, rx88_pos, 1
    substr rx88_tgt, rx88_tgt, rx88_off
  rx88_start:
    eq $I10, 1, rx88_restart
    if_null rx88_debug, debug_615
    rx88_cur."!cursor_debug"("START", "identifier")
  debug_615:
    $I10 = self.'from'()
    ne $I10, -1, rxscan92_done
    goto rxscan92_scan
  rxscan92_loop:
    (rx88_pos) = rx88_cur."from"()
    inc rx88_pos
    rx88_cur."!cursor_from"(rx88_pos)
    ge rx88_pos, rx88_eos, rxscan92_done
  rxscan92_scan:
    set_addr $I10, rxscan92_loop
    rx88_cur."!mark_push"(0, rx88_pos, $I10)
  rxscan92_done:
.annotate 'line', 49
  # rx subrule "ident" subtype=method negate=
    rx88_cur."!cursor_pos"(rx88_pos)
    $P10 = rx88_cur."ident"()
    unless $P10, rx88_fail
    rx88_pos = $P10."pos"()
  # rx rxquantr93 ** 0..*
    set_addr $I10, rxquantr93_done
    rx88_cur."!mark_push"(0, rx88_pos, $I10)
  rxquantr93_loop:
  # rx enumcharlist negate=0 
    ge rx88_pos, rx88_eos, rx88_fail
    sub $I10, rx88_pos, rx88_off
    substr $S10, rx88_tgt, $I10, 1
    index $I11, "-'", $S10
    lt $I11, 0, rx88_fail
    inc rx88_pos
  # rx subrule "ident" subtype=method negate=
    rx88_cur."!cursor_pos"(rx88_pos)
    $P10 = rx88_cur."ident"()
    unless $P10, rx88_fail
    rx88_pos = $P10."pos"()
    set_addr $I10, rxquantr93_done
    (rx88_rep) = rx88_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr93_done
    rx88_cur."!mark_push"(rx88_rep, rx88_pos, $I10)
    goto rxquantr93_loop
  rxquantr93_done:
  # rx pass
    rx88_cur."!cursor_pass"(rx88_pos, "identifier")
    if_null rx88_debug, debug_616
    rx88_cur."!cursor_debug"("PASS", "identifier", " at pos=", rx88_pos)
  debug_616:
    .return (rx88_cur)
  rx88_restart:
.annotate 'line', 10
    if_null rx88_debug, debug_617
    rx88_cur."!cursor_debug"("NEXT", "identifier")
  debug_617:
  rx88_fail:
    (rx88_rep, rx88_pos, $I10, $P10) = rx88_cur."!mark_fail"(0)
    lt rx88_pos, -1, rx88_done
    eq rx88_pos, -1, rx88_fail
    jump $I10
  rx88_done:
    rx88_cur."!cursor_fail"()
    if_null rx88_debug, debug_618
    rx88_cur."!cursor_debug"("FAIL", "identifier")
  debug_618:
    .return (rx88_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__identifier"  :nsentry("!PREFIX__identifier") :subid("15_1303340952.947") :method
.annotate 'line', 10
    $P90 = self."!PREFIX__!subrule"("ident", "")
    new $P91, "ResizablePMCArray"
    push $P91, $P90
    .return ($P91)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "name"  :subid("16_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx95_tgt
    .local int rx95_pos
    .local int rx95_off
    .local int rx95_eos
    .local int rx95_rep
    .local pmc rx95_cur
    .local pmc rx95_debug
    (rx95_cur, rx95_pos, rx95_tgt, $I10) = self."!cursor_start"()
    rx95_cur."!cursor_caparray"("identifier")
    .lex unicode:"$\x{a2}", rx95_cur
    .local pmc match
    .lex "$/", match
    length rx95_eos, rx95_tgt
    gt rx95_pos, rx95_eos, rx95_done
    set rx95_off, 0
    lt rx95_pos, 2, rx95_start
    sub rx95_off, rx95_pos, 1
    substr rx95_tgt, rx95_tgt, rx95_off
  rx95_start:
    eq $I10, 1, rx95_restart
    if_null rx95_debug, debug_619
    rx95_cur."!cursor_debug"("START", "name")
  debug_619:
    $I10 = self.'from'()
    ne $I10, -1, rxscan98_done
    goto rxscan98_scan
  rxscan98_loop:
    (rx95_pos) = rx95_cur."from"()
    inc rx95_pos
    rx95_cur."!cursor_from"(rx95_pos)
    ge rx95_pos, rx95_eos, rxscan98_done
  rxscan98_scan:
    set_addr $I10, rxscan98_loop
    rx95_cur."!mark_push"(0, rx95_pos, $I10)
  rxscan98_done:
.annotate 'line', 51
  # rx rxquantr99 ** 1..*
    set_addr $I10, rxquantr99_done
    rx95_cur."!mark_push"(0, -1, $I10)
  rxquantr99_loop:
  # rx subrule "identifier" subtype=capture negate=
    rx95_cur."!cursor_pos"(rx95_pos)
    $P10 = rx95_cur."identifier"()
    unless $P10, rx95_fail
    goto rxsubrule100_pass
  rxsubrule100_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx95_fail
  rxsubrule100_pass:
    set_addr $I10, rxsubrule100_back
    rx95_cur."!mark_push"(0, rx95_pos, $I10, $P10)
    $P10."!cursor_names"("identifier")
    rx95_pos = $P10."pos"()
    set_addr $I10, rxquantr99_done
    (rx95_rep) = rx95_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr99_done
    rx95_cur."!mark_push"(rx95_rep, rx95_pos, $I10)
  # rx literal  "::"
    add $I11, rx95_pos, 2
    gt $I11, rx95_eos, rx95_fail
    sub $I11, rx95_pos, rx95_off
    substr $S10, rx95_tgt, $I11, 2
    ne $S10, "::", rx95_fail
    add rx95_pos, 2
    goto rxquantr99_loop
  rxquantr99_done:
  # rx pass
    rx95_cur."!cursor_pass"(rx95_pos, "name")
    if_null rx95_debug, debug_620
    rx95_cur."!cursor_debug"("PASS", "name", " at pos=", rx95_pos)
  debug_620:
    .return (rx95_cur)
  rx95_restart:
.annotate 'line', 10
    if_null rx95_debug, debug_621
    rx95_cur."!cursor_debug"("NEXT", "name")
  debug_621:
  rx95_fail:
    (rx95_rep, rx95_pos, $I10, $P10) = rx95_cur."!mark_fail"(0)
    lt rx95_pos, -1, rx95_done
    eq rx95_pos, -1, rx95_fail
    jump $I10
  rx95_done:
    rx95_cur."!cursor_fail"()
    if_null rx95_debug, debug_622
    rx95_cur."!cursor_debug"("FAIL", "name")
  debug_622:
    .return (rx95_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__name"  :nsentry("!PREFIX__name") :subid("17_1303340952.947") :method
.annotate 'line', 10
    new $P97, "ResizablePMCArray"
    push $P97, ""
    .return ($P97)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "deflongname"  :subid("18_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx102_tgt
    .local int rx102_pos
    .local int rx102_off
    .local int rx102_eos
    .local int rx102_rep
    .local pmc rx102_cur
    .local pmc rx102_debug
    (rx102_cur, rx102_pos, rx102_tgt, $I10) = self."!cursor_start"()
    rx102_cur."!cursor_caparray"("colonpair")
    .lex unicode:"$\x{a2}", rx102_cur
    .local pmc match
    .lex "$/", match
    length rx102_eos, rx102_tgt
    gt rx102_pos, rx102_eos, rx102_done
    set rx102_off, 0
    lt rx102_pos, 2, rx102_start
    sub rx102_off, rx102_pos, 1
    substr rx102_tgt, rx102_tgt, rx102_off
  rx102_start:
    eq $I10, 1, rx102_restart
    if_null rx102_debug, debug_623
    rx102_cur."!cursor_debug"("START", "deflongname")
  debug_623:
    $I10 = self.'from'()
    ne $I10, -1, rxscan106_done
    goto rxscan106_scan
  rxscan106_loop:
    (rx102_pos) = rx102_cur."from"()
    inc rx102_pos
    rx102_cur."!cursor_from"(rx102_pos)
    ge rx102_pos, rx102_eos, rxscan106_done
  rxscan106_scan:
    set_addr $I10, rxscan106_loop
    rx102_cur."!mark_push"(0, rx102_pos, $I10)
  rxscan106_done:
.annotate 'line', 54
  # rx subrule "identifier" subtype=capture negate=
    rx102_cur."!cursor_pos"(rx102_pos)
    $P10 = rx102_cur."identifier"()
    unless $P10, rx102_fail
    rx102_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx102_pos = $P10."pos"()
  # rx rxquantr107 ** 0..1
    set_addr $I10, rxquantr107_done
    rx102_cur."!mark_push"(0, rx102_pos, $I10)
  rxquantr107_loop:
  # rx subrule "colonpair" subtype=capture negate=
    rx102_cur."!cursor_pos"(rx102_pos)
    $P10 = rx102_cur."colonpair"()
    unless $P10, rx102_fail
    goto rxsubrule108_pass
  rxsubrule108_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx102_fail
  rxsubrule108_pass:
    set_addr $I10, rxsubrule108_back
    rx102_cur."!mark_push"(0, rx102_pos, $I10, $P10)
    $P10."!cursor_names"("colonpair")
    rx102_pos = $P10."pos"()
    set_addr $I10, rxquantr107_done
    (rx102_rep) = rx102_cur."!mark_commit"($I10)
  rxquantr107_done:
.annotate 'line', 53
  # rx pass
    rx102_cur."!cursor_pass"(rx102_pos, "deflongname")
    if_null rx102_debug, debug_624
    rx102_cur."!cursor_debug"("PASS", "deflongname", " at pos=", rx102_pos)
  debug_624:
    .return (rx102_cur)
  rx102_restart:
.annotate 'line', 10
    if_null rx102_debug, debug_625
    rx102_cur."!cursor_debug"("NEXT", "deflongname")
  debug_625:
  rx102_fail:
    (rx102_rep, rx102_pos, $I10, $P10) = rx102_cur."!mark_fail"(0)
    lt rx102_pos, -1, rx102_done
    eq rx102_pos, -1, rx102_fail
    jump $I10
  rx102_done:
    rx102_cur."!cursor_fail"()
    if_null rx102_debug, debug_626
    rx102_cur."!cursor_debug"("FAIL", "deflongname")
  debug_626:
    .return (rx102_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__deflongname"  :nsentry("!PREFIX__deflongname") :subid("19_1303340952.947") :method
.annotate 'line', 10
    $P104 = self."!PREFIX__!subrule"("identifier", "")
    new $P105, "ResizablePMCArray"
    push $P105, $P104
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ENDSTMT"  :subid("20_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx110_tgt
    .local int rx110_pos
    .local int rx110_off
    .local int rx110_eos
    .local int rx110_rep
    .local pmc rx110_cur
    .local pmc rx110_debug
    (rx110_cur, rx110_pos, rx110_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx110_cur
    .local pmc match
    .lex "$/", match
    length rx110_eos, rx110_tgt
    gt rx110_pos, rx110_eos, rx110_done
    set rx110_off, 0
    lt rx110_pos, 2, rx110_start
    sub rx110_off, rx110_pos, 1
    substr rx110_tgt, rx110_tgt, rx110_off
  rx110_start:
    eq $I10, 1, rx110_restart
    if_null rx110_debug, debug_627
    rx110_cur."!cursor_debug"("START", "ENDSTMT")
  debug_627:
    $I10 = self.'from'()
    ne $I10, -1, rxscan113_done
    goto rxscan113_scan
  rxscan113_loop:
    (rx110_pos) = rx110_cur."from"()
    inc rx110_pos
    rx110_cur."!cursor_from"(rx110_pos)
    ge rx110_pos, rx110_eos, rxscan113_done
  rxscan113_scan:
    set_addr $I10, rxscan113_loop
    rx110_cur."!mark_push"(0, rx110_pos, $I10)
  rxscan113_done:
.annotate 'line', 61
  # rx rxquantr114 ** 0..1
    set_addr $I10, rxquantr114_done
    rx110_cur."!mark_push"(0, rx110_pos, $I10)
  rxquantr114_loop:
  alt115_0:
.annotate 'line', 58
    set_addr $I10, alt115_1
    rx110_cur."!mark_push"(0, rx110_pos, $I10)
.annotate 'line', 59
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx110_pos, rx110_off
    set rx110_rep, 0
    sub $I12, rx110_eos, rx110_pos
  rxenumcharlistq116_loop:
    le $I12, 0, rxenumcharlistq116_done
    substr $S10, rx110_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq116_done
    inc rx110_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq116_loop
  rxenumcharlistq116_done:
    add rx110_pos, rx110_pos, rx110_rep
  # rxanchor eol
    sub $I10, rx110_pos, rx110_off
    is_cclass $I11, 4096, rx110_tgt, $I10
    if $I11, rxanchor117_done
    ne rx110_pos, rx110_eos, rx110_fail
    eq rx110_pos, 0, rxanchor117_done
    dec $I10
    is_cclass $I11, 4096, rx110_tgt, $I10
    if $I11, rx110_fail
  rxanchor117_done:
  # rx subrule "ws" subtype=method negate=
    rx110_cur."!cursor_pos"(rx110_pos)
    $P10 = rx110_cur."ws"()
    unless $P10, rx110_fail
    rx110_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx110_cur."!cursor_pos"(rx110_pos)
    $P10 = rx110_cur."MARKER"("endstmt")
    unless $P10, rx110_fail
    goto alt115_end
  alt115_1:
.annotate 'line', 60
  # rx rxquantr118 ** 0..1
    set_addr $I10, rxquantr118_done
    rx110_cur."!mark_push"(0, rx110_pos, $I10)
  rxquantr118_loop:
  # rx subrule "unv" subtype=method negate=
    rx110_cur."!cursor_pos"(rx110_pos)
    $P10 = rx110_cur."unv"()
    unless $P10, rx110_fail
    goto rxsubrule119_pass
  rxsubrule119_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx110_fail
  rxsubrule119_pass:
    set_addr $I10, rxsubrule119_back
    rx110_cur."!mark_push"(0, rx110_pos, $I10, $P10)
    rx110_pos = $P10."pos"()
    set_addr $I10, rxquantr118_done
    (rx110_rep) = rx110_cur."!mark_commit"($I10)
  rxquantr118_done:
  # rxanchor eol
    sub $I10, rx110_pos, rx110_off
    is_cclass $I11, 4096, rx110_tgt, $I10
    if $I11, rxanchor120_done
    ne rx110_pos, rx110_eos, rx110_fail
    eq rx110_pos, 0, rxanchor120_done
    dec $I10
    is_cclass $I11, 4096, rx110_tgt, $I10
    if $I11, rx110_fail
  rxanchor120_done:
  # rx subrule "ws" subtype=method negate=
    rx110_cur."!cursor_pos"(rx110_pos)
    $P10 = rx110_cur."ws"()
    unless $P10, rx110_fail
    rx110_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx110_cur."!cursor_pos"(rx110_pos)
    $P10 = rx110_cur."MARKER"("endstmt")
    unless $P10, rx110_fail
  alt115_end:
.annotate 'line', 61
    set_addr $I10, rxquantr114_done
    (rx110_rep) = rx110_cur."!mark_commit"($I10)
  rxquantr114_done:
.annotate 'line', 57
  # rx pass
    rx110_cur."!cursor_pass"(rx110_pos, "ENDSTMT")
    if_null rx110_debug, debug_628
    rx110_cur."!cursor_debug"("PASS", "ENDSTMT", " at pos=", rx110_pos)
  debug_628:
    .return (rx110_cur)
  rx110_restart:
.annotate 'line', 10
    if_null rx110_debug, debug_629
    rx110_cur."!cursor_debug"("NEXT", "ENDSTMT")
  debug_629:
  rx110_fail:
    (rx110_rep, rx110_pos, $I10, $P10) = rx110_cur."!mark_fail"(0)
    lt rx110_pos, -1, rx110_done
    eq rx110_pos, -1, rx110_fail
    jump $I10
  rx110_done:
    rx110_cur."!cursor_fail"()
    if_null rx110_debug, debug_630
    rx110_cur."!cursor_debug"("FAIL", "ENDSTMT")
  debug_630:
    .return (rx110_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ENDSTMT"  :nsentry("!PREFIX__ENDSTMT") :subid("21_1303340952.947") :method
.annotate 'line', 10
    new $P112, "ResizablePMCArray"
    push $P112, ""
    .return ($P112)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ws"  :subid("22_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx122_tgt
    .local int rx122_pos
    .local int rx122_off
    .local int rx122_eos
    .local int rx122_rep
    .local pmc rx122_cur
    .local pmc rx122_debug
    (rx122_cur, rx122_pos, rx122_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx122_cur
    .local pmc match
    .lex "$/", match
    length rx122_eos, rx122_tgt
    gt rx122_pos, rx122_eos, rx122_done
    set rx122_off, 0
    lt rx122_pos, 2, rx122_start
    sub rx122_off, rx122_pos, 1
    substr rx122_tgt, rx122_tgt, rx122_off
  rx122_start:
    eq $I10, 1, rx122_restart
    if_null rx122_debug, debug_631
    rx122_cur."!cursor_debug"("START", "ws")
  debug_631:
    $I10 = self.'from'()
    ne $I10, -1, rxscan125_done
    goto rxscan125_scan
  rxscan125_loop:
    (rx122_pos) = rx122_cur."from"()
    inc rx122_pos
    rx122_cur."!cursor_from"(rx122_pos)
    ge rx122_pos, rx122_eos, rxscan125_done
  rxscan125_scan:
    set_addr $I10, rxscan125_loop
    rx122_cur."!mark_push"(0, rx122_pos, $I10)
  rxscan125_done:
  alt126_0:
.annotate 'line', 64
    set_addr $I10, alt126_1
    rx122_cur."!mark_push"(0, rx122_pos, $I10)
.annotate 'line', 65
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx122_cur."!cursor_pos"(rx122_pos)
    $P10 = rx122_cur."MARKED"("ws")
    unless $P10, rx122_fail
    goto alt126_end
  alt126_1:
.annotate 'line', 66
  # rx subrule "ww" subtype=zerowidth negate=1
    rx122_cur."!cursor_pos"(rx122_pos)
    $P10 = rx122_cur."ww"()
    if $P10, rx122_fail
.annotate 'line', 71
  # rx rxquantr127 ** 0..*
    set_addr $I10, rxquantr127_done
    rx122_cur."!mark_push"(0, rx122_pos, $I10)
  rxquantr127_loop:
  alt128_0:
.annotate 'line', 67
    set_addr $I10, alt128_1
    rx122_cur."!mark_push"(0, rx122_pos, $I10)
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx122_pos, rx122_off
    set rx122_rep, 0
    sub $I12, rx122_eos, rx122_pos
  rxenumcharlistq129_loop:
    le $I12, 0, rxenumcharlistq129_done
    substr $S10, rx122_tgt, $I10, 1
    index $I11, unicode:"\n\x{b}\f\r\x{85}\u2028\u2029", $S10
    lt $I11, 0, rxenumcharlistq129_done
    inc rx122_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq129_loop
  rxenumcharlistq129_done:
    lt rx122_rep, 1, rx122_fail
    add rx122_pos, rx122_pos, rx122_rep
    goto alt128_end
  alt128_1:
    set_addr $I10, alt128_2
    rx122_cur."!mark_push"(0, rx122_pos, $I10)
.annotate 'line', 68
  # rx literal  "#"
    add $I11, rx122_pos, 1
    gt $I11, rx122_eos, rx122_fail
    sub $I11, rx122_pos, rx122_off
    ord $I11, rx122_tgt, $I11
    ne $I11, 35, rx122_fail
    add rx122_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx122_pos, rx122_off
    find_cclass $I11, 4096, rx122_tgt, $I10, rx122_eos
    add rx122_pos, rx122_off, $I11
    goto alt128_end
  alt128_2:
    set_addr $I10, alt128_3
    rx122_cur."!mark_push"(0, rx122_pos, $I10)
.annotate 'line', 69
  # rxanchor bol
    eq rx122_pos, 0, rxanchor130_done
    ge rx122_pos, rx122_eos, rx122_fail
    sub $I10, rx122_pos, rx122_off
    dec $I10
    is_cclass $I11, 4096, rx122_tgt, $I10
    unless $I11, rx122_fail
  rxanchor130_done:
  # rx subrule "pod_comment" subtype=method negate=
    rx122_cur."!cursor_pos"(rx122_pos)
    $P10 = rx122_cur."pod_comment"()
    unless $P10, rx122_fail
    rx122_pos = $P10."pos"()
    goto alt128_end
  alt128_3:
.annotate 'line', 70
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx122_pos, rx122_off
    set rx122_rep, 0
    sub $I12, rx122_eos, rx122_pos
  rxenumcharlistq131_loop:
    le $I12, 0, rxenumcharlistq131_done
    substr $S10, rx122_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq131_done
    inc rx122_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq131_loop
  rxenumcharlistq131_done:
    lt rx122_rep, 1, rx122_fail
    add rx122_pos, rx122_pos, rx122_rep
  alt128_end:
.annotate 'line', 71
    set_addr $I10, rxquantr127_done
    (rx122_rep) = rx122_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr127_done
    rx122_cur."!mark_push"(rx122_rep, rx122_pos, $I10)
    goto rxquantr127_loop
  rxquantr127_done:
.annotate 'line', 72
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx122_cur."!cursor_pos"(rx122_pos)
    $P10 = rx122_cur."MARKER"("ws")
    unless $P10, rx122_fail
  alt126_end:
.annotate 'line', 64
  # rx pass
    rx122_cur."!cursor_pass"(rx122_pos, "ws")
    if_null rx122_debug, debug_632
    rx122_cur."!cursor_debug"("PASS", "ws", " at pos=", rx122_pos)
  debug_632:
    .return (rx122_cur)
  rx122_restart:
.annotate 'line', 10
    if_null rx122_debug, debug_633
    rx122_cur."!cursor_debug"("NEXT", "ws")
  debug_633:
  rx122_fail:
    (rx122_rep, rx122_pos, $I10, $P10) = rx122_cur."!mark_fail"(0)
    lt rx122_pos, -1, rx122_done
    eq rx122_pos, -1, rx122_fail
    jump $I10
  rx122_done:
    rx122_cur."!cursor_fail"()
    if_null rx122_debug, debug_634
    rx122_cur."!cursor_debug"("FAIL", "ws")
  debug_634:
    .return (rx122_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ws"  :nsentry("!PREFIX__ws") :subid("23_1303340952.947") :method
.annotate 'line', 10
    new $P124, "ResizablePMCArray"
    push $P124, ""
    push $P124, ""
    .return ($P124)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "unv"  :subid("24_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .const 'Sub' $P140 = "26_1303340952.947" 
    capture_lex $P140
    .local string rx133_tgt
    .local int rx133_pos
    .local int rx133_off
    .local int rx133_eos
    .local int rx133_rep
    .local pmc rx133_cur
    .local pmc rx133_debug
    (rx133_cur, rx133_pos, rx133_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx133_cur
    .local pmc match
    .lex "$/", match
    length rx133_eos, rx133_tgt
    gt rx133_pos, rx133_eos, rx133_done
    set rx133_off, 0
    lt rx133_pos, 2, rx133_start
    sub rx133_off, rx133_pos, 1
    substr rx133_tgt, rx133_tgt, rx133_off
  rx133_start:
    eq $I10, 1, rx133_restart
    if_null rx133_debug, debug_635
    rx133_cur."!cursor_debug"("START", "unv")
  debug_635:
    $I10 = self.'from'()
    ne $I10, -1, rxscan136_done
    goto rxscan136_scan
  rxscan136_loop:
    (rx133_pos) = rx133_cur."from"()
    inc rx133_pos
    rx133_cur."!cursor_from"(rx133_pos)
    ge rx133_pos, rx133_eos, rxscan136_done
  rxscan136_scan:
    set_addr $I10, rxscan136_loop
    rx133_cur."!mark_push"(0, rx133_pos, $I10)
  rxscan136_done:
  alt137_0:
.annotate 'line', 77
    set_addr $I10, alt137_1
    rx133_cur."!mark_push"(0, rx133_pos, $I10)
.annotate 'line', 78
  # rxanchor bol
    eq rx133_pos, 0, rxanchor138_done
    ge rx133_pos, rx133_eos, rx133_fail
    sub $I10, rx133_pos, rx133_off
    dec $I10
    is_cclass $I11, 4096, rx133_tgt, $I10
    unless $I11, rx133_fail
  rxanchor138_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx133_cur."!cursor_pos"(rx133_pos)
    .const 'Sub' $P140 = "26_1303340952.947" 
    capture_lex $P140
    $P10 = rx133_cur."before"($P140)
    unless $P10, rx133_fail
  # rx subrule "pod_comment" subtype=method negate=
    rx133_cur."!cursor_pos"(rx133_pos)
    $P10 = rx133_cur."pod_comment"()
    unless $P10, rx133_fail
    rx133_pos = $P10."pos"()
    goto alt137_end
  alt137_1:
    set_addr $I10, alt137_2
    rx133_cur."!mark_push"(0, rx133_pos, $I10)
.annotate 'line', 79
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx133_pos, rx133_off
    set rx133_rep, 0
    sub $I12, rx133_eos, rx133_pos
  rxenumcharlistq145_loop:
    le $I12, 0, rxenumcharlistq145_done
    substr $S10, rx133_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq145_done
    inc rx133_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq145_loop
  rxenumcharlistq145_done:
    add rx133_pos, rx133_pos, rx133_rep
  # rx literal  "#"
    add $I11, rx133_pos, 1
    gt $I11, rx133_eos, rx133_fail
    sub $I11, rx133_pos, rx133_off
    ord $I11, rx133_tgt, $I11
    ne $I11, 35, rx133_fail
    add rx133_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx133_pos, rx133_off
    find_cclass $I11, 4096, rx133_tgt, $I10, rx133_eos
    add rx133_pos, rx133_off, $I11
    goto alt137_end
  alt137_2:
.annotate 'line', 80
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx133_pos, rx133_off
    set rx133_rep, 0
    sub $I12, rx133_eos, rx133_pos
  rxenumcharlistq146_loop:
    le $I12, 0, rxenumcharlistq146_done
    substr $S10, rx133_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq146_done
    inc rx133_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq146_loop
  rxenumcharlistq146_done:
    lt rx133_rep, 1, rx133_fail
    add rx133_pos, rx133_pos, rx133_rep
  alt137_end:
.annotate 'line', 75
  # rx pass
    rx133_cur."!cursor_pass"(rx133_pos, "unv")
    if_null rx133_debug, debug_640
    rx133_cur."!cursor_debug"("PASS", "unv", " at pos=", rx133_pos)
  debug_640:
    .return (rx133_cur)
  rx133_restart:
.annotate 'line', 10
    if_null rx133_debug, debug_641
    rx133_cur."!cursor_debug"("NEXT", "unv")
  debug_641:
  rx133_fail:
    (rx133_rep, rx133_pos, $I10, $P10) = rx133_cur."!mark_fail"(0)
    lt rx133_pos, -1, rx133_done
    eq rx133_pos, -1, rx133_fail
    jump $I10
  rx133_done:
    rx133_cur."!cursor_fail"()
    if_null rx133_debug, debug_642
    rx133_cur."!cursor_debug"("FAIL", "unv")
  debug_642:
    .return (rx133_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__unv"  :nsentry("!PREFIX__unv") :subid("25_1303340952.947") :method
.annotate 'line', 10
    new $P135, "ResizablePMCArray"
    push $P135, ""
    push $P135, ""
    push $P135, ""
    .return ($P135)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block139"  :anon :subid("26_1303340952.947") :method :outer("24_1303340952.947")
.annotate 'line', 78
    .local string rx141_tgt
    .local int rx141_pos
    .local int rx141_off
    .local int rx141_eos
    .local int rx141_rep
    .local pmc rx141_cur
    .local pmc rx141_debug
    (rx141_cur, rx141_pos, rx141_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx141_cur
    .local pmc match
    .lex "$/", match
    length rx141_eos, rx141_tgt
    gt rx141_pos, rx141_eos, rx141_done
    set rx141_off, 0
    lt rx141_pos, 2, rx141_start
    sub rx141_off, rx141_pos, 1
    substr rx141_tgt, rx141_tgt, rx141_off
  rx141_start:
    eq $I10, 1, rx141_restart
    if_null rx141_debug, debug_636
    rx141_cur."!cursor_debug"("START", "")
  debug_636:
    $I10 = self.'from'()
    ne $I10, -1, rxscan142_done
    goto rxscan142_scan
  rxscan142_loop:
    (rx141_pos) = rx141_cur."from"()
    inc rx141_pos
    rx141_cur."!cursor_from"(rx141_pos)
    ge rx141_pos, rx141_eos, rxscan142_done
  rxscan142_scan:
    set_addr $I10, rxscan142_loop
    rx141_cur."!mark_push"(0, rx141_pos, $I10)
  rxscan142_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx141_pos, rx141_off
    set rx141_rep, 0
    sub $I12, rx141_eos, rx141_pos
  rxenumcharlistq143_loop:
    le $I12, 0, rxenumcharlistq143_done
    substr $S10, rx141_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq143_done
    inc rx141_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq143_loop
  rxenumcharlistq143_done:
    add rx141_pos, rx141_pos, rx141_rep
  # rx literal  "="
    add $I11, rx141_pos, 1
    gt $I11, rx141_eos, rx141_fail
    sub $I11, rx141_pos, rx141_off
    ord $I11, rx141_tgt, $I11
    ne $I11, 61, rx141_fail
    add rx141_pos, 1
  alt144_0:
    set_addr $I10, alt144_1
    rx141_cur."!mark_push"(0, rx141_pos, $I10)
  # rx charclass w
    ge rx141_pos, rx141_eos, rx141_fail
    sub $I10, rx141_pos, rx141_off
    is_cclass $I11, 8192, rx141_tgt, $I10
    unless $I11, rx141_fail
    inc rx141_pos
    goto alt144_end
  alt144_1:
  # rx literal  "\\"
    add $I11, rx141_pos, 1
    gt $I11, rx141_eos, rx141_fail
    sub $I11, rx141_pos, rx141_off
    ord $I11, rx141_tgt, $I11
    ne $I11, 92, rx141_fail
    add rx141_pos, 1
  alt144_end:
  # rx pass
    rx141_cur."!cursor_pass"(rx141_pos, "")
    if_null rx141_debug, debug_637
    rx141_cur."!cursor_debug"("PASS", "", " at pos=", rx141_pos)
  debug_637:
    .return (rx141_cur)
  rx141_restart:
    if_null rx141_debug, debug_638
    rx141_cur."!cursor_debug"("NEXT", "")
  debug_638:
  rx141_fail:
    (rx141_rep, rx141_pos, $I10, $P10) = rx141_cur."!mark_fail"(0)
    lt rx141_pos, -1, rx141_done
    eq rx141_pos, -1, rx141_fail
    jump $I10
  rx141_done:
    rx141_cur."!cursor_fail"()
    if_null rx141_debug, debug_639
    rx141_cur."!cursor_debug"("FAIL", "")
  debug_639:
    .return (rx141_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pod_comment"  :subid("27_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .const 'Sub' $P179 = "29_1303340952.947" 
    capture_lex $P179
    .local string rx148_tgt
    .local int rx148_pos
    .local int rx148_off
    .local int rx148_eos
    .local int rx148_rep
    .local pmc rx148_cur
    .local pmc rx148_debug
    (rx148_cur, rx148_pos, rx148_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx148_cur
    .local pmc match
    .lex "$/", match
    length rx148_eos, rx148_tgt
    gt rx148_pos, rx148_eos, rx148_done
    set rx148_off, 0
    lt rx148_pos, 2, rx148_start
    sub rx148_off, rx148_pos, 1
    substr rx148_tgt, rx148_tgt, rx148_off
  rx148_start:
    eq $I10, 1, rx148_restart
    if_null rx148_debug, debug_643
    rx148_cur."!cursor_debug"("START", "pod_comment")
  debug_643:
    $I10 = self.'from'()
    ne $I10, -1, rxscan151_done
    goto rxscan151_scan
  rxscan151_loop:
    (rx148_pos) = rx148_cur."from"()
    inc rx148_pos
    rx148_cur."!cursor_from"(rx148_pos)
    ge rx148_pos, rx148_eos, rxscan151_done
  rxscan151_scan:
    set_addr $I10, rxscan151_loop
    rx148_cur."!mark_push"(0, rx148_pos, $I10)
  rxscan151_done:
.annotate 'line', 85
  # rxanchor bol
    eq rx148_pos, 0, rxanchor152_done
    ge rx148_pos, rx148_eos, rx148_fail
    sub $I10, rx148_pos, rx148_off
    dec $I10
    is_cclass $I11, 4096, rx148_tgt, $I10
    unless $I11, rx148_fail
  rxanchor152_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx148_pos, rx148_off
    set rx148_rep, 0
    sub $I12, rx148_eos, rx148_pos
  rxenumcharlistq153_loop:
    le $I12, 0, rxenumcharlistq153_done
    substr $S10, rx148_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq153_done
    inc rx148_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq153_loop
  rxenumcharlistq153_done:
    add rx148_pos, rx148_pos, rx148_rep
  # rx literal  "="
    add $I11, rx148_pos, 1
    gt $I11, rx148_eos, rx148_fail
    sub $I11, rx148_pos, rx148_off
    ord $I11, rx148_tgt, $I11
    ne $I11, 61, rx148_fail
    add rx148_pos, 1
  alt154_0:
.annotate 'line', 86
    set_addr $I10, alt154_1
    rx148_cur."!mark_push"(0, rx148_pos, $I10)
.annotate 'line', 87
  # rx literal  "begin"
    add $I11, rx148_pos, 5
    gt $I11, rx148_eos, rx148_fail
    sub $I11, rx148_pos, rx148_off
    substr $S10, rx148_tgt, $I11, 5
    ne $S10, "begin", rx148_fail
    add rx148_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx148_pos, rx148_off
    set rx148_rep, 0
    sub $I12, rx148_eos, rx148_pos
  rxenumcharlistq155_loop:
    le $I12, 0, rxenumcharlistq155_done
    substr $S10, rx148_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq155_done
    inc rx148_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq155_loop
  rxenumcharlistq155_done:
    lt rx148_rep, 1, rx148_fail
    add rx148_pos, rx148_pos, rx148_rep
  # rx literal  "END"
    add $I11, rx148_pos, 3
    gt $I11, rx148_eos, rx148_fail
    sub $I11, rx148_pos, rx148_off
    substr $S10, rx148_tgt, $I11, 3
    ne $S10, "END", rx148_fail
    add rx148_pos, 3
  # rxanchor rwb
    le rx148_pos, 0, rx148_fail
    sub $I10, rx148_pos, rx148_off
    is_cclass $I11, 8192, rx148_tgt, $I10
    if $I11, rx148_fail
    dec $I10
    is_cclass $I11, 8192, rx148_tgt, $I10
    unless $I11, rx148_fail
  alt156_0:
.annotate 'line', 88
    set_addr $I10, alt156_1
    rx148_cur."!mark_push"(0, rx148_pos, $I10)
  # rx rxquantf157 ** 0..*
    set_addr $I10, rxquantf157_loop
    rx148_cur."!mark_push"(0, rx148_pos, $I10)
    goto rxquantf157_done
  rxquantf157_loop:
  # rx charclass .
    ge rx148_pos, rx148_eos, rx148_fail
    inc rx148_pos
    set_addr $I10, rxquantf157_loop
    rx148_cur."!mark_push"(rx148_rep, rx148_pos, $I10)
  rxquantf157_done:
  # rx charclass nl
    ge rx148_pos, rx148_eos, rx148_fail
    sub $I10, rx148_pos, rx148_off
    is_cclass $I11, 4096, rx148_tgt, $I10
    unless $I11, rx148_fail
    substr $S10, rx148_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx148_pos, $I11
    inc rx148_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx148_pos, rx148_off
    set rx148_rep, 0
    sub $I12, rx148_eos, rx148_pos
  rxenumcharlistq159_loop:
    le $I12, 0, rxenumcharlistq159_done
    substr $S10, rx148_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq159_done
    inc rx148_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq159_loop
  rxenumcharlistq159_done:
    add rx148_pos, rx148_pos, rx148_rep
  # rx literal  "=end"
    add $I11, rx148_pos, 4
    gt $I11, rx148_eos, rx148_fail
    sub $I11, rx148_pos, rx148_off
    substr $S10, rx148_tgt, $I11, 4
    ne $S10, "=end", rx148_fail
    add rx148_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx148_pos, rx148_off
    set rx148_rep, 0
    sub $I12, rx148_eos, rx148_pos
  rxenumcharlistq160_loop:
    le $I12, 0, rxenumcharlistq160_done
    substr $S10, rx148_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq160_done
    inc rx148_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq160_loop
  rxenumcharlistq160_done:
    lt rx148_rep, 1, rx148_fail
    add rx148_pos, rx148_pos, rx148_rep
  # rx literal  "END"
    add $I11, rx148_pos, 3
    gt $I11, rx148_eos, rx148_fail
    sub $I11, rx148_pos, rx148_off
    substr $S10, rx148_tgt, $I11, 3
    ne $S10, "END", rx148_fail
    add rx148_pos, 3
  # rxanchor rwb
    le rx148_pos, 0, rx148_fail
    sub $I10, rx148_pos, rx148_off
    is_cclass $I11, 8192, rx148_tgt, $I10
    if $I11, rx148_fail
    dec $I10
    is_cclass $I11, 8192, rx148_tgt, $I10
    unless $I11, rx148_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx148_pos, rx148_off
    find_cclass $I11, 4096, rx148_tgt, $I10, rx148_eos
    add rx148_pos, rx148_off, $I11
    goto alt156_end
  alt156_1:
  # rx charclass_q . r 0..-1
    sub $I10, rx148_pos, rx148_off
    find_not_cclass $I11, 65535, rx148_tgt, $I10, rx148_eos
    add rx148_pos, rx148_off, $I11
  alt156_end:
.annotate 'line', 87
    goto alt154_end
  alt154_1:
    set_addr $I10, alt154_2
    rx148_cur."!mark_push"(0, rx148_pos, $I10)
.annotate 'line', 89
  # rx literal  "begin"
    add $I11, rx148_pos, 5
    gt $I11, rx148_eos, rx148_fail
    sub $I11, rx148_pos, rx148_off
    substr $S10, rx148_tgt, $I11, 5
    ne $S10, "begin", rx148_fail
    add rx148_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx148_pos, rx148_off
    set rx148_rep, 0
    sub $I12, rx148_eos, rx148_pos
  rxenumcharlistq161_loop:
    le $I12, 0, rxenumcharlistq161_done
    substr $S10, rx148_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq161_done
    inc rx148_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq161_loop
  rxenumcharlistq161_done:
    lt rx148_rep, 1, rx148_fail
    add rx148_pos, rx148_pos, rx148_rep
  # rx subrule "identifier" subtype=capture negate=
    rx148_cur."!cursor_pos"(rx148_pos)
    $P10 = rx148_cur."identifier"()
    unless $P10, rx148_fail
    rx148_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx148_pos = $P10."pos"()
  alt162_0:
.annotate 'line', 90
    set_addr $I10, alt162_1
    rx148_cur."!mark_push"(0, rx148_pos, $I10)
.annotate 'line', 91
  # rx rxquantf163 ** 0..*
    set_addr $I10, rxquantf163_loop
    rx148_cur."!mark_push"(0, rx148_pos, $I10)
    goto rxquantf163_done
  rxquantf163_loop:
  # rx charclass .
    ge rx148_pos, rx148_eos, rx148_fail
    inc rx148_pos
    set_addr $I10, rxquantf163_loop
    rx148_cur."!mark_push"(rx148_rep, rx148_pos, $I10)
  rxquantf163_done:
  # rx charclass nl
    ge rx148_pos, rx148_eos, rx148_fail
    sub $I10, rx148_pos, rx148_off
    is_cclass $I11, 4096, rx148_tgt, $I10
    unless $I11, rx148_fail
    substr $S10, rx148_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx148_pos, $I11
    inc rx148_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx148_pos, rx148_off
    set rx148_rep, 0
    sub $I12, rx148_eos, rx148_pos
  rxenumcharlistq165_loop:
    le $I12, 0, rxenumcharlistq165_done
    substr $S10, rx148_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq165_done
    inc rx148_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq165_loop
  rxenumcharlistq165_done:
    add rx148_pos, rx148_pos, rx148_rep
  # rx literal  "=end"
    add $I11, rx148_pos, 4
    gt $I11, rx148_eos, rx148_fail
    sub $I11, rx148_pos, rx148_off
    substr $S10, rx148_tgt, $I11, 4
    ne $S10, "=end", rx148_fail
    add rx148_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx148_pos, rx148_off
    set rx148_rep, 0
    sub $I12, rx148_eos, rx148_pos
  rxenumcharlistq166_loop:
    le $I12, 0, rxenumcharlistq166_done
    substr $S10, rx148_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq166_done
    inc rx148_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq166_loop
  rxenumcharlistq166_done:
    lt rx148_rep, 1, rx148_fail
    add rx148_pos, rx148_pos, rx148_rep
  # rx subrule "!BACKREF" subtype=method negate=
    rx148_cur."!cursor_pos"(rx148_pos)
    $P10 = rx148_cur."!BACKREF"("identifier")
    unless $P10, rx148_fail
    rx148_pos = $P10."pos"()
  # rxanchor rwb
    le rx148_pos, 0, rx148_fail
    sub $I10, rx148_pos, rx148_off
    is_cclass $I11, 8192, rx148_tgt, $I10
    if $I11, rx148_fail
    dec $I10
    is_cclass $I11, 8192, rx148_tgt, $I10
    unless $I11, rx148_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx148_pos, rx148_off
    find_cclass $I11, 4096, rx148_tgt, $I10, rx148_eos
    add rx148_pos, rx148_off, $I11
    goto alt162_end
  alt162_1:
.annotate 'line', 92
  # rx subrule "panic" subtype=method negate=
    rx148_cur."!cursor_pos"(rx148_pos)
    $P10 = rx148_cur."panic"("=begin without matching =end")
    unless $P10, rx148_fail
    rx148_pos = $P10."pos"()
  alt162_end:
.annotate 'line', 89
    goto alt154_end
  alt154_2:
    set_addr $I10, alt154_3
    rx148_cur."!mark_push"(0, rx148_pos, $I10)
.annotate 'line', 94
  # rx literal  "begin"
    add $I11, rx148_pos, 5
    gt $I11, rx148_eos, rx148_fail
    sub $I11, rx148_pos, rx148_off
    substr $S10, rx148_tgt, $I11, 5
    ne $S10, "begin", rx148_fail
    add rx148_pos, 5
  # rxanchor rwb
    le rx148_pos, 0, rx148_fail
    sub $I10, rx148_pos, rx148_off
    is_cclass $I11, 8192, rx148_tgt, $I10
    if $I11, rx148_fail
    dec $I10
    is_cclass $I11, 8192, rx148_tgt, $I10
    unless $I11, rx148_fail
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx148_pos, rx148_off
    set rx148_rep, 0
    sub $I12, rx148_eos, rx148_pos
  rxenumcharlistq168_loop:
    le $I12, 0, rxenumcharlistq168_done
    substr $S10, rx148_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq168_done
    inc rx148_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq168_loop
  rxenumcharlistq168_done:
    add rx148_pos, rx148_pos, rx148_rep
  alt169_0:
.annotate 'line', 95
    set_addr $I10, alt169_1
    rx148_cur."!mark_push"(0, rx148_pos, $I10)
  # rxanchor eol
    sub $I10, rx148_pos, rx148_off
    is_cclass $I11, 4096, rx148_tgt, $I10
    if $I11, rxanchor170_done
    ne rx148_pos, rx148_eos, rx148_fail
    eq rx148_pos, 0, rxanchor170_done
    dec $I10
    is_cclass $I11, 4096, rx148_tgt, $I10
    if $I11, rx148_fail
  rxanchor170_done:
    goto alt169_end
  alt169_1:
    set_addr $I10, alt169_2
    rx148_cur."!mark_push"(0, rx148_pos, $I10)
  # rx literal  "#"
    add $I11, rx148_pos, 1
    gt $I11, rx148_eos, rx148_fail
    sub $I11, rx148_pos, rx148_off
    ord $I11, rx148_tgt, $I11
    ne $I11, 35, rx148_fail
    add rx148_pos, 1
    goto alt169_end
  alt169_2:
  # rx subrule "panic" subtype=method negate=
    rx148_cur."!cursor_pos"(rx148_pos)
    $P10 = rx148_cur."panic"("Unrecognized token after =begin")
    unless $P10, rx148_fail
    rx148_pos = $P10."pos"()
  alt169_end:
  alt171_0:
.annotate 'line', 96
    set_addr $I10, alt171_1
    rx148_cur."!mark_push"(0, rx148_pos, $I10)
.annotate 'line', 97
  # rx rxquantf172 ** 0..*
    set_addr $I10, rxquantf172_loop
    rx148_cur."!mark_push"(0, rx148_pos, $I10)
    goto rxquantf172_done
  rxquantf172_loop:
  # rx charclass .
    ge rx148_pos, rx148_eos, rx148_fail
    inc rx148_pos
    set_addr $I10, rxquantf172_loop
    rx148_cur."!mark_push"(rx148_rep, rx148_pos, $I10)
  rxquantf172_done:
  # rx charclass nl
    ge rx148_pos, rx148_eos, rx148_fail
    sub $I10, rx148_pos, rx148_off
    is_cclass $I11, 4096, rx148_tgt, $I10
    unless $I11, rx148_fail
    substr $S10, rx148_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx148_pos, $I11
    inc rx148_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx148_pos, rx148_off
    set rx148_rep, 0
    sub $I12, rx148_eos, rx148_pos
  rxenumcharlistq174_loop:
    le $I12, 0, rxenumcharlistq174_done
    substr $S10, rx148_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq174_done
    inc rx148_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq174_loop
  rxenumcharlistq174_done:
    add rx148_pos, rx148_pos, rx148_rep
  # rx literal  "=end"
    add $I11, rx148_pos, 4
    gt $I11, rx148_eos, rx148_fail
    sub $I11, rx148_pos, rx148_off
    substr $S10, rx148_tgt, $I11, 4
    ne $S10, "=end", rx148_fail
    add rx148_pos, 4
  # rxanchor rwb
    le rx148_pos, 0, rx148_fail
    sub $I10, rx148_pos, rx148_off
    is_cclass $I11, 8192, rx148_tgt, $I10
    if $I11, rx148_fail
    dec $I10
    is_cclass $I11, 8192, rx148_tgt, $I10
    unless $I11, rx148_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx148_pos, rx148_off
    find_cclass $I11, 4096, rx148_tgt, $I10, rx148_eos
    add rx148_pos, rx148_off, $I11
    goto alt171_end
  alt171_1:
.annotate 'line', 98
  # rx subrule "panic" subtype=method negate=
    rx148_cur."!cursor_pos"(rx148_pos)
    $P10 = rx148_cur."panic"("=begin without matching =end")
    unless $P10, rx148_fail
    rx148_pos = $P10."pos"()
  alt171_end:
.annotate 'line', 94
    goto alt154_end
  alt154_3:
    set_addr $I10, alt154_4
    rx148_cur."!mark_push"(0, rx148_pos, $I10)
.annotate 'line', 100
  # rx subrule "identifier" subtype=capture negate=
    rx148_cur."!cursor_pos"(rx148_pos)
    $P10 = rx148_cur."identifier"()
    unless $P10, rx148_fail
    rx148_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx148_pos = $P10."pos"()
.annotate 'line', 101
  # rx rxquantf175 ** 0..*
    set_addr $I10, rxquantf175_loop
    rx148_cur."!mark_push"(0, rx148_pos, $I10)
    goto rxquantf175_done
  rxquantf175_loop:
  # rx charclass .
    ge rx148_pos, rx148_eos, rx148_fail
    inc rx148_pos
    set_addr $I10, rxquantf175_loop
    rx148_cur."!mark_push"(rx148_rep, rx148_pos, $I10)
  rxquantf175_done:
  # rxanchor bol
    eq rx148_pos, 0, rxanchor177_done
    ge rx148_pos, rx148_eos, rx148_fail
    sub $I10, rx148_pos, rx148_off
    dec $I10
    is_cclass $I11, 4096, rx148_tgt, $I10
    unless $I11, rx148_fail
  rxanchor177_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx148_cur."!cursor_pos"(rx148_pos)
    .const 'Sub' $P179 = "29_1303340952.947" 
    capture_lex $P179
    $P10 = rx148_cur."before"($P179)
    unless $P10, rx148_fail
.annotate 'line', 100
    goto alt154_end
  alt154_4:
  alt185_0:
.annotate 'line', 107
    set_addr $I10, alt185_1
    rx148_cur."!mark_push"(0, rx148_pos, $I10)
  # rx charclass s
    ge rx148_pos, rx148_eos, rx148_fail
    sub $I10, rx148_pos, rx148_off
    is_cclass $I11, 32, rx148_tgt, $I10
    unless $I11, rx148_fail
    inc rx148_pos
    goto alt185_end
  alt185_1:
  # rx subrule "panic" subtype=method negate=
    rx148_cur."!cursor_pos"(rx148_pos)
    $P10 = rx148_cur."panic"("Illegal pod directive")
    unless $P10, rx148_fail
    rx148_pos = $P10."pos"()
  alt185_end:
.annotate 'line', 108
  # rx charclass_q N r 0..-1
    sub $I10, rx148_pos, rx148_off
    find_cclass $I11, 4096, rx148_tgt, $I10, rx148_eos
    add rx148_pos, rx148_off, $I11
  alt154_end:
.annotate 'line', 84
  # rx pass
    rx148_cur."!cursor_pass"(rx148_pos, "pod_comment")
    if_null rx148_debug, debug_648
    rx148_cur."!cursor_debug"("PASS", "pod_comment", " at pos=", rx148_pos)
  debug_648:
    .return (rx148_cur)
  rx148_restart:
.annotate 'line', 10
    if_null rx148_debug, debug_649
    rx148_cur."!cursor_debug"("NEXT", "pod_comment")
  debug_649:
  rx148_fail:
    (rx148_rep, rx148_pos, $I10, $P10) = rx148_cur."!mark_fail"(0)
    lt rx148_pos, -1, rx148_done
    eq rx148_pos, -1, rx148_fail
    jump $I10
  rx148_done:
    rx148_cur."!cursor_fail"()
    if_null rx148_debug, debug_650
    rx148_cur."!cursor_debug"("FAIL", "pod_comment")
  debug_650:
    .return (rx148_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pod_comment"  :nsentry("!PREFIX__pod_comment") :subid("28_1303340952.947") :method
.annotate 'line', 10
    new $P150, "ResizablePMCArray"
    push $P150, ""
    .return ($P150)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block178"  :anon :subid("29_1303340952.947") :method :outer("27_1303340952.947")
.annotate 'line', 101
    .local string rx180_tgt
    .local int rx180_pos
    .local int rx180_off
    .local int rx180_eos
    .local int rx180_rep
    .local pmc rx180_cur
    .local pmc rx180_debug
    (rx180_cur, rx180_pos, rx180_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx180_cur
    .local pmc match
    .lex "$/", match
    length rx180_eos, rx180_tgt
    gt rx180_pos, rx180_eos, rx180_done
    set rx180_off, 0
    lt rx180_pos, 2, rx180_start
    sub rx180_off, rx180_pos, 1
    substr rx180_tgt, rx180_tgt, rx180_off
  rx180_start:
    eq $I10, 1, rx180_restart
    if_null rx180_debug, debug_644
    rx180_cur."!cursor_debug"("START", "")
  debug_644:
    $I10 = self.'from'()
    ne $I10, -1, rxscan181_done
    goto rxscan181_scan
  rxscan181_loop:
    (rx180_pos) = rx180_cur."from"()
    inc rx180_pos
    rx180_cur."!cursor_from"(rx180_pos)
    ge rx180_pos, rx180_eos, rxscan181_done
  rxscan181_scan:
    set_addr $I10, rxscan181_loop
    rx180_cur."!mark_push"(0, rx180_pos, $I10)
  rxscan181_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx180_pos, rx180_off
    set rx180_rep, 0
    sub $I12, rx180_eos, rx180_pos
  rxenumcharlistq182_loop:
    le $I12, 0, rxenumcharlistq182_done
    substr $S10, rx180_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq182_done
    inc rx180_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq182_loop
  rxenumcharlistq182_done:
    add rx180_pos, rx180_pos, rx180_rep
  alt183_0:
    set_addr $I10, alt183_1
    rx180_cur."!mark_push"(0, rx180_pos, $I10)
.annotate 'line', 102
  # rx literal  "="
    add $I11, rx180_pos, 1
    gt $I11, rx180_eos, rx180_fail
    sub $I11, rx180_pos, rx180_off
    ord $I11, rx180_tgt, $I11
    ne $I11, 61, rx180_fail
    add rx180_pos, 1
.annotate 'line', 104
  # rx rxquantr184 ** 0..1
    set_addr $I10, rxquantr184_done
    rx180_cur."!mark_push"(0, rx180_pos, $I10)
  rxquantr184_loop:
.annotate 'line', 103
  # rx literal  "cut"
    add $I11, rx180_pos, 3
    gt $I11, rx180_eos, rx180_fail
    sub $I11, rx180_pos, rx180_off
    substr $S10, rx180_tgt, $I11, 3
    ne $S10, "cut", rx180_fail
    add rx180_pos, 3
  # rxanchor rwb
    le rx180_pos, 0, rx180_fail
    sub $I10, rx180_pos, rx180_off
    is_cclass $I11, 8192, rx180_tgt, $I10
    if $I11, rx180_fail
    dec $I10
    is_cclass $I11, 8192, rx180_tgt, $I10
    unless $I11, rx180_fail
.annotate 'line', 104
  # rx subrule "panic" subtype=method negate=
    rx180_cur."!cursor_pos"(rx180_pos)
    $P10 = rx180_cur."panic"("Obsolete pod format, please use =begin/=end instead")
    unless $P10, rx180_fail
    rx180_pos = $P10."pos"()
    set_addr $I10, rxquantr184_done
    (rx180_rep) = rx180_cur."!mark_commit"($I10)
  rxquantr184_done:
.annotate 'line', 101
    goto alt183_end
  alt183_1:
.annotate 'line', 105
  # rx charclass nl
    ge rx180_pos, rx180_eos, rx180_fail
    sub $I10, rx180_pos, rx180_off
    is_cclass $I11, 4096, rx180_tgt, $I10
    unless $I11, rx180_fail
    substr $S10, rx180_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx180_pos, $I11
    inc rx180_pos
  alt183_end:
.annotate 'line', 101
  # rx pass
    rx180_cur."!cursor_pass"(rx180_pos, "")
    if_null rx180_debug, debug_645
    rx180_cur."!cursor_debug"("PASS", "", " at pos=", rx180_pos)
  debug_645:
    .return (rx180_cur)
  rx180_restart:
    if_null rx180_debug, debug_646
    rx180_cur."!cursor_debug"("NEXT", "")
  debug_646:
  rx180_fail:
    (rx180_rep, rx180_pos, $I10, $P10) = rx180_cur."!mark_fail"(0)
    lt rx180_pos, -1, rx180_done
    eq rx180_pos, -1, rx180_fail
    jump $I10
  rx180_done:
    rx180_cur."!cursor_fail"()
    if_null rx180_debug, debug_647
    rx180_cur."!cursor_debug"("FAIL", "")
  debug_647:
    .return (rx180_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "comp_unit"  :subid("30_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 116
    new $P187, "Undef"
    .lex "$*HAS_YOU_ARE_HERE", $P187
.annotate 'line', 117
    new $P188, "Undef"
    .lex "$*MAIN_SUB", $P188
.annotate 'line', 121
    new $P189, "Undef"
    .lex "$*PACKAGE", $P189
.annotate 'line', 10
    .local string rx190_tgt
    .local int rx190_pos
    .local int rx190_off
    .local int rx190_eos
    .local int rx190_rep
    .local pmc rx190_cur
    .local pmc rx190_debug
    (rx190_cur, rx190_pos, rx190_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx190_cur
    .local pmc match
    .lex "$/", match
    length rx190_eos, rx190_tgt
    gt rx190_pos, rx190_eos, rx190_done
    set rx190_off, 0
    lt rx190_pos, 2, rx190_start
    sub rx190_off, rx190_pos, 1
    substr rx190_tgt, rx190_tgt, rx190_off
  rx190_start:
    eq $I10, 1, rx190_restart
    if_null rx190_debug, debug_651
    rx190_cur."!cursor_debug"("START", "comp_unit")
  debug_651:
    $I10 = self.'from'()
    ne $I10, -1, rxscan194_done
    goto rxscan194_scan
  rxscan194_loop:
    (rx190_pos) = rx190_cur."from"()
    inc rx190_pos
    rx190_cur."!cursor_from"(rx190_pos)
    ge rx190_pos, rx190_eos, rxscan194_done
  rxscan194_scan:
    set_addr $I10, rxscan194_loop
    rx190_cur."!mark_push"(0, rx190_pos, $I10)
  rxscan194_done:
.annotate 'line', 116
    rx190_cur."!cursor_pos"(rx190_pos)
    new $P195, "Integer"
    assign $P195, 0
    store_lex "$*HAS_YOU_ARE_HERE", $P195
.annotate 'line', 117
    rx190_cur."!cursor_pos"(rx190_pos)
    find_lex $P196, "$*MAIN_SUB"
    unless_null $P196, vivify_652
    get_hll_global $P196, "$MAIN_SUB"
    unless_null $P196, vivify_653
    die "Contextual $*MAIN_SUB not found"
  vivify_653:
  vivify_652:
.annotate 'line', 118
  # rx subrule "newpad" subtype=method negate=
    rx190_cur."!cursor_pos"(rx190_pos)
    $P10 = rx190_cur."newpad"()
    unless $P10, rx190_fail
    rx190_pos = $P10."pos"()
.annotate 'line', 119
  # rx subrule "outerctx" subtype=method negate=
    rx190_cur."!cursor_pos"(rx190_pos)
    $P10 = rx190_cur."outerctx"()
    unless $P10, rx190_fail
    rx190_pos = $P10."pos"()
.annotate 'line', 121
    rx190_cur."!cursor_pos"(rx190_pos)
    find_lex $P197, "$*PACKAGE"
    unless_null $P197, vivify_654
    get_hll_global $P197, "$PACKAGE"
    unless_null $P197, vivify_655
    die "Contextual $*PACKAGE not found"
  vivify_655:
  vivify_654:
.annotate 'line', 122
  # rx subrule "GLOBALish" subtype=method negate=
    rx190_cur."!cursor_pos"(rx190_pos)
    $P10 = rx190_cur."GLOBALish"()
    unless $P10, rx190_fail
    rx190_pos = $P10."pos"()
.annotate 'line', 124
  # rx subrule "statementlist" subtype=capture negate=
    rx190_cur."!cursor_pos"(rx190_pos)
    $P10 = rx190_cur."statementlist"()
    unless $P10, rx190_fail
    rx190_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx190_pos = $P10."pos"()
  alt198_0:
.annotate 'line', 125
    set_addr $I10, alt198_1
    rx190_cur."!mark_push"(0, rx190_pos, $I10)
  # rxanchor eos
    ne rx190_pos, rx190_eos, rx190_fail
    goto alt198_end
  alt198_1:
  # rx subrule "panic" subtype=method negate=
    rx190_cur."!cursor_pos"(rx190_pos)
    $P10 = rx190_cur."panic"("Confused")
    unless $P10, rx190_fail
    rx190_pos = $P10."pos"()
  alt198_end:
.annotate 'line', 115
  # rx pass
    rx190_cur."!cursor_pass"(rx190_pos, "comp_unit")
    if_null rx190_debug, debug_656
    rx190_cur."!cursor_debug"("PASS", "comp_unit", " at pos=", rx190_pos)
  debug_656:
    .return (rx190_cur)
  rx190_restart:
.annotate 'line', 10
    if_null rx190_debug, debug_657
    rx190_cur."!cursor_debug"("NEXT", "comp_unit")
  debug_657:
  rx190_fail:
    (rx190_rep, rx190_pos, $I10, $P10) = rx190_cur."!mark_fail"(0)
    lt rx190_pos, -1, rx190_done
    eq rx190_pos, -1, rx190_fail
    jump $I10
  rx190_done:
    rx190_cur."!cursor_fail"()
    if_null rx190_debug, debug_658
    rx190_cur."!cursor_debug"("FAIL", "comp_unit")
  debug_658:
    .return (rx190_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__comp_unit"  :nsentry("!PREFIX__comp_unit") :subid("31_1303340952.947") :method
.annotate 'line', 10
    $P192 = self."!PREFIX__!subrule"("newpad", "")
    new $P193, "ResizablePMCArray"
    push $P193, $P192
    .return ($P193)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statementlist"  :subid("32_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx200_tgt
    .local int rx200_pos
    .local int rx200_off
    .local int rx200_eos
    .local int rx200_rep
    .local pmc rx200_cur
    .local pmc rx200_debug
    (rx200_cur, rx200_pos, rx200_tgt, $I10) = self."!cursor_start"()
    rx200_cur."!cursor_caparray"("statement")
    .lex unicode:"$\x{a2}", rx200_cur
    .local pmc match
    .lex "$/", match
    length rx200_eos, rx200_tgt
    gt rx200_pos, rx200_eos, rx200_done
    set rx200_off, 0
    lt rx200_pos, 2, rx200_start
    sub rx200_off, rx200_pos, 1
    substr rx200_tgt, rx200_tgt, rx200_off
  rx200_start:
    eq $I10, 1, rx200_restart
    if_null rx200_debug, debug_659
    rx200_cur."!cursor_debug"("START", "statementlist")
  debug_659:
    $I10 = self.'from'()
    ne $I10, -1, rxscan205_done
    goto rxscan205_scan
  rxscan205_loop:
    (rx200_pos) = rx200_cur."from"()
    inc rx200_pos
    rx200_cur."!cursor_from"(rx200_pos)
    ge rx200_pos, rx200_eos, rxscan205_done
  rxscan205_scan:
    set_addr $I10, rxscan205_loop
    rx200_cur."!mark_push"(0, rx200_pos, $I10)
  rxscan205_done:
  alt206_0:
.annotate 'line', 128
    set_addr $I10, alt206_1
    rx200_cur."!mark_push"(0, rx200_pos, $I10)
.annotate 'line', 129
  # rx subrule "ws" subtype=method negate=
    rx200_cur."!cursor_pos"(rx200_pos)
    $P10 = rx200_cur."ws"()
    unless $P10, rx200_fail
    rx200_pos = $P10."pos"()
  # rxanchor eos
    ne rx200_pos, rx200_eos, rx200_fail
  # rx subrule "ws" subtype=method negate=
    rx200_cur."!cursor_pos"(rx200_pos)
    $P10 = rx200_cur."ws"()
    unless $P10, rx200_fail
    rx200_pos = $P10."pos"()
    goto alt206_end
  alt206_1:
.annotate 'line', 130
  # rx subrule "ws" subtype=method negate=
    rx200_cur."!cursor_pos"(rx200_pos)
    $P10 = rx200_cur."ws"()
    unless $P10, rx200_fail
    rx200_pos = $P10."pos"()
  # rx rxquantr210 ** 0..*
    set_addr $I10, rxquantr210_done
    rx200_cur."!mark_push"(0, rx200_pos, $I10)
  rxquantr210_loop:
  # rx subrule "statement" subtype=capture negate=
    rx200_cur."!cursor_pos"(rx200_pos)
    $P10 = rx200_cur."statement"()
    unless $P10, rx200_fail
    rx200_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx200_pos = $P10."pos"()
  # rx subrule "eat_terminator" subtype=method negate=
    rx200_cur."!cursor_pos"(rx200_pos)
    $P10 = rx200_cur."eat_terminator"()
    unless $P10, rx200_fail
    rx200_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx200_cur."!cursor_pos"(rx200_pos)
    $P10 = rx200_cur."ws"()
    unless $P10, rx200_fail
    rx200_pos = $P10."pos"()
    set_addr $I10, rxquantr210_done
    (rx200_rep) = rx200_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr210_done
    rx200_cur."!mark_push"(rx200_rep, rx200_pos, $I10)
    goto rxquantr210_loop
  rxquantr210_done:
  # rx subrule "ws" subtype=method negate=
    rx200_cur."!cursor_pos"(rx200_pos)
    $P10 = rx200_cur."ws"()
    unless $P10, rx200_fail
    rx200_pos = $P10."pos"()
  alt206_end:
.annotate 'line', 128
  # rx pass
    rx200_cur."!cursor_pass"(rx200_pos, "statementlist")
    if_null rx200_debug, debug_660
    rx200_cur."!cursor_debug"("PASS", "statementlist", " at pos=", rx200_pos)
  debug_660:
    .return (rx200_cur)
  rx200_restart:
.annotate 'line', 10
    if_null rx200_debug, debug_661
    rx200_cur."!cursor_debug"("NEXT", "statementlist")
  debug_661:
  rx200_fail:
    (rx200_rep, rx200_pos, $I10, $P10) = rx200_cur."!mark_fail"(0)
    lt rx200_pos, -1, rx200_done
    eq rx200_pos, -1, rx200_fail
    jump $I10
  rx200_done:
    rx200_cur."!cursor_fail"()
    if_null rx200_debug, debug_662
    rx200_cur."!cursor_debug"("FAIL", "statementlist")
  debug_662:
    .return (rx200_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statementlist"  :nsentry("!PREFIX__statementlist") :subid("33_1303340952.947") :method
.annotate 'line', 10
    $P202 = self."!PREFIX__!subrule"("ws", "")
    $P203 = self."!PREFIX__!subrule"("ws", "")
    new $P204, "ResizablePMCArray"
    push $P204, $P202
    push $P204, $P203
    .return ($P204)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement"  :subid("34_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .const 'Sub' $P219 = "36_1303340952.947" 
    capture_lex $P219
    .local string rx214_tgt
    .local int rx214_pos
    .local int rx214_off
    .local int rx214_eos
    .local int rx214_rep
    .local pmc rx214_cur
    .local pmc rx214_debug
    (rx214_cur, rx214_pos, rx214_tgt, $I10) = self."!cursor_start"()
    rx214_cur."!cursor_caparray"("statement_mod_cond", "statement_mod_loop")
    .lex unicode:"$\x{a2}", rx214_cur
    .local pmc match
    .lex "$/", match
    length rx214_eos, rx214_tgt
    gt rx214_pos, rx214_eos, rx214_done
    set rx214_off, 0
    lt rx214_pos, 2, rx214_start
    sub rx214_off, rx214_pos, 1
    substr rx214_tgt, rx214_tgt, rx214_off
  rx214_start:
    eq $I10, 1, rx214_restart
    if_null rx214_debug, debug_663
    rx214_cur."!cursor_debug"("START", "statement")
  debug_663:
    $I10 = self.'from'()
    ne $I10, -1, rxscan217_done
    goto rxscan217_scan
  rxscan217_loop:
    (rx214_pos) = rx214_cur."from"()
    inc rx214_pos
    rx214_cur."!cursor_from"(rx214_pos)
    ge rx214_pos, rx214_eos, rxscan217_done
  rxscan217_scan:
    set_addr $I10, rxscan217_loop
    rx214_cur."!mark_push"(0, rx214_pos, $I10)
  rxscan217_done:
.annotate 'line', 134
  # rx subrule "before" subtype=zerowidth negate=1
    rx214_cur."!cursor_pos"(rx214_pos)
    .const 'Sub' $P219 = "36_1303340952.947" 
    capture_lex $P219
    $P10 = rx214_cur."before"($P219)
    if $P10, rx214_fail
  alt223_0:
.annotate 'line', 135
    set_addr $I10, alt223_1
    rx214_cur."!mark_push"(0, rx214_pos, $I10)
.annotate 'line', 136
  # rx subrule "statement_control" subtype=capture negate=
    rx214_cur."!cursor_pos"(rx214_pos)
    $P10 = rx214_cur."statement_control"()
    unless $P10, rx214_fail
    rx214_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_control")
    rx214_pos = $P10."pos"()
    goto alt223_end
  alt223_1:
.annotate 'line', 137
  # rx subrule "EXPR" subtype=capture negate=
    rx214_cur."!cursor_pos"(rx214_pos)
    $P10 = rx214_cur."EXPR"()
    unless $P10, rx214_fail
    rx214_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx214_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx214_cur."!cursor_pos"(rx214_pos)
    $P10 = rx214_cur."ws"()
    unless $P10, rx214_fail
    rx214_pos = $P10."pos"()
.annotate 'line', 142
  # rx rxquantr224 ** 0..1
    set_addr $I10, rxquantr224_done
    rx214_cur."!mark_push"(0, rx214_pos, $I10)
  rxquantr224_loop:
  alt225_0:
.annotate 'line', 138
    set_addr $I10, alt225_1
    rx214_cur."!mark_push"(0, rx214_pos, $I10)
.annotate 'line', 139
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx214_cur."!cursor_pos"(rx214_pos)
    $P10 = rx214_cur."MARKED"("endstmt")
    unless $P10, rx214_fail
    goto alt225_end
  alt225_1:
    set_addr $I10, alt225_2
    rx214_cur."!mark_push"(0, rx214_pos, $I10)
.annotate 'line', 140
  # rx subrule "statement_mod_cond" subtype=capture negate=
    rx214_cur."!cursor_pos"(rx214_pos)
    $P10 = rx214_cur."statement_mod_cond"()
    unless $P10, rx214_fail
    rx214_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_cond")
    rx214_pos = $P10."pos"()
  # rx rxquantr226 ** 0..1
    set_addr $I10, rxquantr226_done
    rx214_cur."!mark_push"(0, rx214_pos, $I10)
  rxquantr226_loop:
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx214_cur."!cursor_pos"(rx214_pos)
    $P10 = rx214_cur."statement_mod_loop"()
    unless $P10, rx214_fail
    goto rxsubrule227_pass
  rxsubrule227_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx214_fail
  rxsubrule227_pass:
    set_addr $I10, rxsubrule227_back
    rx214_cur."!mark_push"(0, rx214_pos, $I10, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx214_pos = $P10."pos"()
    set_addr $I10, rxquantr226_done
    (rx214_rep) = rx214_cur."!mark_commit"($I10)
  rxquantr226_done:
    goto alt225_end
  alt225_2:
.annotate 'line', 141
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx214_cur."!cursor_pos"(rx214_pos)
    $P10 = rx214_cur."statement_mod_loop"()
    unless $P10, rx214_fail
    rx214_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx214_pos = $P10."pos"()
  alt225_end:
.annotate 'line', 142
    set_addr $I10, rxquantr224_done
    (rx214_rep) = rx214_cur."!mark_commit"($I10)
  rxquantr224_done:
  alt223_end:
.annotate 'line', 133
  # rx pass
    rx214_cur."!cursor_pass"(rx214_pos, "statement")
    if_null rx214_debug, debug_668
    rx214_cur."!cursor_debug"("PASS", "statement", " at pos=", rx214_pos)
  debug_668:
    .return (rx214_cur)
  rx214_restart:
.annotate 'line', 10
    if_null rx214_debug, debug_669
    rx214_cur."!cursor_debug"("NEXT", "statement")
  debug_669:
  rx214_fail:
    (rx214_rep, rx214_pos, $I10, $P10) = rx214_cur."!mark_fail"(0)
    lt rx214_pos, -1, rx214_done
    eq rx214_pos, -1, rx214_fail
    jump $I10
  rx214_done:
    rx214_cur."!cursor_fail"()
    if_null rx214_debug, debug_670
    rx214_cur."!cursor_debug"("FAIL", "statement")
  debug_670:
    .return (rx214_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement"  :nsentry("!PREFIX__statement") :subid("35_1303340952.947") :method
.annotate 'line', 10
    new $P216, "ResizablePMCArray"
    push $P216, ""
    .return ($P216)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block218"  :anon :subid("36_1303340952.947") :method :outer("34_1303340952.947")
.annotate 'line', 134
    .local string rx220_tgt
    .local int rx220_pos
    .local int rx220_off
    .local int rx220_eos
    .local int rx220_rep
    .local pmc rx220_cur
    .local pmc rx220_debug
    (rx220_cur, rx220_pos, rx220_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx220_cur
    .local pmc match
    .lex "$/", match
    length rx220_eos, rx220_tgt
    gt rx220_pos, rx220_eos, rx220_done
    set rx220_off, 0
    lt rx220_pos, 2, rx220_start
    sub rx220_off, rx220_pos, 1
    substr rx220_tgt, rx220_tgt, rx220_off
  rx220_start:
    eq $I10, 1, rx220_restart
    if_null rx220_debug, debug_664
    rx220_cur."!cursor_debug"("START", "")
  debug_664:
    $I10 = self.'from'()
    ne $I10, -1, rxscan221_done
    goto rxscan221_scan
  rxscan221_loop:
    (rx220_pos) = rx220_cur."from"()
    inc rx220_pos
    rx220_cur."!cursor_from"(rx220_pos)
    ge rx220_pos, rx220_eos, rxscan221_done
  rxscan221_scan:
    set_addr $I10, rxscan221_loop
    rx220_cur."!mark_push"(0, rx220_pos, $I10)
  rxscan221_done:
  alt222_0:
    set_addr $I10, alt222_1
    rx220_cur."!mark_push"(0, rx220_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx220_pos, rx220_eos, rx220_fail
    sub $I10, rx220_pos, rx220_off
    substr $S10, rx220_tgt, $I10, 1
    index $I11, "])}", $S10
    lt $I11, 0, rx220_fail
    inc rx220_pos
    goto alt222_end
  alt222_1:
  # rxanchor eos
    ne rx220_pos, rx220_eos, rx220_fail
  alt222_end:
  # rx pass
    rx220_cur."!cursor_pass"(rx220_pos, "")
    if_null rx220_debug, debug_665
    rx220_cur."!cursor_debug"("PASS", "", " at pos=", rx220_pos)
  debug_665:
    .return (rx220_cur)
  rx220_restart:
    if_null rx220_debug, debug_666
    rx220_cur."!cursor_debug"("NEXT", "")
  debug_666:
  rx220_fail:
    (rx220_rep, rx220_pos, $I10, $P10) = rx220_cur."!mark_fail"(0)
    lt rx220_pos, -1, rx220_done
    eq rx220_pos, -1, rx220_fail
    jump $I10
  rx220_done:
    rx220_cur."!cursor_fail"()
    if_null rx220_debug, debug_667
    rx220_cur."!cursor_debug"("FAIL", "")
  debug_667:
    .return (rx220_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "eat_terminator"  :subid("37_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx229_tgt
    .local int rx229_pos
    .local int rx229_off
    .local int rx229_eos
    .local int rx229_rep
    .local pmc rx229_cur
    .local pmc rx229_debug
    (rx229_cur, rx229_pos, rx229_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx229_cur
    .local pmc match
    .lex "$/", match
    length rx229_eos, rx229_tgt
    gt rx229_pos, rx229_eos, rx229_done
    set rx229_off, 0
    lt rx229_pos, 2, rx229_start
    sub rx229_off, rx229_pos, 1
    substr rx229_tgt, rx229_tgt, rx229_off
  rx229_start:
    eq $I10, 1, rx229_restart
    if_null rx229_debug, debug_671
    rx229_cur."!cursor_debug"("START", "eat_terminator")
  debug_671:
    $I10 = self.'from'()
    ne $I10, -1, rxscan232_done
    goto rxscan232_scan
  rxscan232_loop:
    (rx229_pos) = rx229_cur."from"()
    inc rx229_pos
    rx229_cur."!cursor_from"(rx229_pos)
    ge rx229_pos, rx229_eos, rxscan232_done
  rxscan232_scan:
    set_addr $I10, rxscan232_loop
    rx229_cur."!mark_push"(0, rx229_pos, $I10)
  rxscan232_done:
  alt233_0:
.annotate 'line', 146
    set_addr $I10, alt233_1
    rx229_cur."!mark_push"(0, rx229_pos, $I10)
.annotate 'line', 147
  # rx literal  ";"
    add $I11, rx229_pos, 1
    gt $I11, rx229_eos, rx229_fail
    sub $I11, rx229_pos, rx229_off
    ord $I11, rx229_tgt, $I11
    ne $I11, 59, rx229_fail
    add rx229_pos, 1
    goto alt233_end
  alt233_1:
    set_addr $I10, alt233_2
    rx229_cur."!mark_push"(0, rx229_pos, $I10)
.annotate 'line', 148
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx229_cur."!cursor_pos"(rx229_pos)
    $P10 = rx229_cur."MARKED"("endstmt")
    unless $P10, rx229_fail
    goto alt233_end
  alt233_2:
    set_addr $I10, alt233_3
    rx229_cur."!mark_push"(0, rx229_pos, $I10)
.annotate 'line', 149
  # rx subrule "terminator" subtype=zerowidth negate=
    rx229_cur."!cursor_pos"(rx229_pos)
    $P10 = rx229_cur."terminator"()
    unless $P10, rx229_fail
    goto alt233_end
  alt233_3:
.annotate 'line', 150
  # rxanchor eos
    ne rx229_pos, rx229_eos, rx229_fail
  alt233_end:
.annotate 'line', 146
  # rx pass
    rx229_cur."!cursor_pass"(rx229_pos, "eat_terminator")
    if_null rx229_debug, debug_672
    rx229_cur."!cursor_debug"("PASS", "eat_terminator", " at pos=", rx229_pos)
  debug_672:
    .return (rx229_cur)
  rx229_restart:
.annotate 'line', 10
    if_null rx229_debug, debug_673
    rx229_cur."!cursor_debug"("NEXT", "eat_terminator")
  debug_673:
  rx229_fail:
    (rx229_rep, rx229_pos, $I10, $P10) = rx229_cur."!mark_fail"(0)
    lt rx229_pos, -1, rx229_done
    eq rx229_pos, -1, rx229_fail
    jump $I10
  rx229_done:
    rx229_cur."!cursor_fail"()
    if_null rx229_debug, debug_674
    rx229_cur."!cursor_debug"("FAIL", "eat_terminator")
  debug_674:
    .return (rx229_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__eat_terminator"  :nsentry("!PREFIX__eat_terminator") :subid("38_1303340952.947") :method
.annotate 'line', 10
    new $P231, "ResizablePMCArray"
    push $P231, ""
    push $P231, ""
    push $P231, ""
    push $P231, ";"
    .return ($P231)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "xblock"  :subid("39_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx235_tgt
    .local int rx235_pos
    .local int rx235_off
    .local int rx235_eos
    .local int rx235_rep
    .local pmc rx235_cur
    .local pmc rx235_debug
    (rx235_cur, rx235_pos, rx235_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx235_cur
    .local pmc match
    .lex "$/", match
    length rx235_eos, rx235_tgt
    gt rx235_pos, rx235_eos, rx235_done
    set rx235_off, 0
    lt rx235_pos, 2, rx235_start
    sub rx235_off, rx235_pos, 1
    substr rx235_tgt, rx235_tgt, rx235_off
  rx235_start:
    eq $I10, 1, rx235_restart
    if_null rx235_debug, debug_675
    rx235_cur."!cursor_debug"("START", "xblock")
  debug_675:
    $I10 = self.'from'()
    ne $I10, -1, rxscan239_done
    goto rxscan239_scan
  rxscan239_loop:
    (rx235_pos) = rx235_cur."from"()
    inc rx235_pos
    rx235_cur."!cursor_from"(rx235_pos)
    ge rx235_pos, rx235_eos, rxscan239_done
  rxscan239_scan:
    set_addr $I10, rxscan239_loop
    rx235_cur."!mark_push"(0, rx235_pos, $I10)
  rxscan239_done:
.annotate 'line', 154
  # rx subrule "EXPR" subtype=capture negate=
    rx235_cur."!cursor_pos"(rx235_pos)
    $P10 = rx235_cur."EXPR"()
    unless $P10, rx235_fail
    rx235_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx235_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx235_cur."!cursor_pos"(rx235_pos)
    $P10 = rx235_cur."ws"()
    unless $P10, rx235_fail
    rx235_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx235_cur."!cursor_pos"(rx235_pos)
    $P10 = rx235_cur."pblock"()
    unless $P10, rx235_fail
    rx235_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx235_pos = $P10."pos"()
.annotate 'line', 153
  # rx pass
    rx235_cur."!cursor_pass"(rx235_pos, "xblock")
    if_null rx235_debug, debug_676
    rx235_cur."!cursor_debug"("PASS", "xblock", " at pos=", rx235_pos)
  debug_676:
    .return (rx235_cur)
  rx235_restart:
.annotate 'line', 10
    if_null rx235_debug, debug_677
    rx235_cur."!cursor_debug"("NEXT", "xblock")
  debug_677:
  rx235_fail:
    (rx235_rep, rx235_pos, $I10, $P10) = rx235_cur."!mark_fail"(0)
    lt rx235_pos, -1, rx235_done
    eq rx235_pos, -1, rx235_fail
    jump $I10
  rx235_done:
    rx235_cur."!cursor_fail"()
    if_null rx235_debug, debug_678
    rx235_cur."!cursor_debug"("FAIL", "xblock")
  debug_678:
    .return (rx235_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__xblock"  :nsentry("!PREFIX__xblock") :subid("40_1303340952.947") :method
.annotate 'line', 10
    $P237 = self."!PREFIX__!subrule"("EXPR", "")
    new $P238, "ResizablePMCArray"
    push $P238, $P237
    .return ($P238)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pblock"  :subid("41_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx241_tgt
    .local int rx241_pos
    .local int rx241_off
    .local int rx241_eos
    .local int rx241_rep
    .local pmc rx241_cur
    .local pmc rx241_debug
    (rx241_cur, rx241_pos, rx241_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx241_cur
    .local pmc match
    .lex "$/", match
    length rx241_eos, rx241_tgt
    gt rx241_pos, rx241_eos, rx241_done
    set rx241_off, 0
    lt rx241_pos, 2, rx241_start
    sub rx241_off, rx241_pos, 1
    substr rx241_tgt, rx241_tgt, rx241_off
  rx241_start:
    eq $I10, 1, rx241_restart
    if_null rx241_debug, debug_679
    rx241_cur."!cursor_debug"("START", "pblock")
  debug_679:
    $I10 = self.'from'()
    ne $I10, -1, rxscan246_done
    goto rxscan246_scan
  rxscan246_loop:
    (rx241_pos) = rx241_cur."from"()
    inc rx241_pos
    rx241_cur."!cursor_from"(rx241_pos)
    ge rx241_pos, rx241_eos, rxscan246_done
  rxscan246_scan:
    set_addr $I10, rxscan246_loop
    rx241_cur."!mark_push"(0, rx241_pos, $I10)
  rxscan246_done:
  alt247_0:
.annotate 'line', 157
    set_addr $I10, alt247_1
    rx241_cur."!mark_push"(0, rx241_pos, $I10)
.annotate 'line', 158
  # rx subrule "lambda" subtype=method negate=
    rx241_cur."!cursor_pos"(rx241_pos)
    $P10 = rx241_cur."lambda"()
    unless $P10, rx241_fail
    rx241_pos = $P10."pos"()
.annotate 'line', 159
  # rx subrule "newpad" subtype=method negate=
    rx241_cur."!cursor_pos"(rx241_pos)
    $P10 = rx241_cur."newpad"()
    unless $P10, rx241_fail
    rx241_pos = $P10."pos"()
.annotate 'line', 160
  # rx subrule "signature" subtype=capture negate=
    rx241_cur."!cursor_pos"(rx241_pos)
    $P10 = rx241_cur."signature"()
    unless $P10, rx241_fail
    rx241_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx241_pos = $P10."pos"()
.annotate 'line', 161
  # rx subrule "blockoid" subtype=capture negate=
    rx241_cur."!cursor_pos"(rx241_pos)
    $P10 = rx241_cur."blockoid"()
    unless $P10, rx241_fail
    rx241_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx241_pos = $P10."pos"()
.annotate 'line', 158
    goto alt247_end
  alt247_1:
    set_addr $I10, alt247_2
    rx241_cur."!mark_push"(0, rx241_pos, $I10)
.annotate 'line', 162
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx241_pos, rx241_off
    substr $S10, rx241_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx241_fail
.annotate 'line', 163
  # rx subrule "newpad" subtype=method negate=
    rx241_cur."!cursor_pos"(rx241_pos)
    $P10 = rx241_cur."newpad"()
    unless $P10, rx241_fail
    rx241_pos = $P10."pos"()
.annotate 'line', 164
  # rx subrule "blockoid" subtype=capture negate=
    rx241_cur."!cursor_pos"(rx241_pos)
    $P10 = rx241_cur."blockoid"()
    unless $P10, rx241_fail
    rx241_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx241_pos = $P10."pos"()
.annotate 'line', 162
    goto alt247_end
  alt247_2:
.annotate 'line', 165
  # rx subrule "panic" subtype=method negate=
    rx241_cur."!cursor_pos"(rx241_pos)
    $P10 = rx241_cur."panic"("Missing block")
    unless $P10, rx241_fail
    rx241_pos = $P10."pos"()
  alt247_end:
.annotate 'line', 157
  # rx pass
    rx241_cur."!cursor_pass"(rx241_pos, "pblock")
    if_null rx241_debug, debug_680
    rx241_cur."!cursor_debug"("PASS", "pblock", " at pos=", rx241_pos)
  debug_680:
    .return (rx241_cur)
  rx241_restart:
.annotate 'line', 10
    if_null rx241_debug, debug_681
    rx241_cur."!cursor_debug"("NEXT", "pblock")
  debug_681:
  rx241_fail:
    (rx241_rep, rx241_pos, $I10, $P10) = rx241_cur."!mark_fail"(0)
    lt rx241_pos, -1, rx241_done
    eq rx241_pos, -1, rx241_fail
    jump $I10
  rx241_done:
    rx241_cur."!cursor_fail"()
    if_null rx241_debug, debug_682
    rx241_cur."!cursor_debug"("FAIL", "pblock")
  debug_682:
    .return (rx241_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pblock"  :nsentry("!PREFIX__pblock") :subid("42_1303340952.947") :method
.annotate 'line', 10
    $P243 = self."!PREFIX__!subrule"("panic", "")
    $P244 = self."!PREFIX__!subrule"("lambda", "")
    new $P245, "ResizablePMCArray"
    push $P245, $P243
    push $P245, "{"
    push $P245, $P244
    .return ($P245)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "lambda"  :subid("43_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx249_tgt
    .local int rx249_pos
    .local int rx249_off
    .local int rx249_eos
    .local int rx249_rep
    .local pmc rx249_cur
    .local pmc rx249_debug
    (rx249_cur, rx249_pos, rx249_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx249_cur
    .local pmc match
    .lex "$/", match
    length rx249_eos, rx249_tgt
    gt rx249_pos, rx249_eos, rx249_done
    set rx249_off, 0
    lt rx249_pos, 2, rx249_start
    sub rx249_off, rx249_pos, 1
    substr rx249_tgt, rx249_tgt, rx249_off
  rx249_start:
    eq $I10, 1, rx249_restart
    if_null rx249_debug, debug_683
    rx249_cur."!cursor_debug"("START", "lambda")
  debug_683:
    $I10 = self.'from'()
    ne $I10, -1, rxscan252_done
    goto rxscan252_scan
  rxscan252_loop:
    (rx249_pos) = rx249_cur."from"()
    inc rx249_pos
    rx249_cur."!cursor_from"(rx249_pos)
    ge rx249_pos, rx249_eos, rxscan252_done
  rxscan252_scan:
    set_addr $I10, rxscan252_loop
    rx249_cur."!mark_push"(0, rx249_pos, $I10)
  rxscan252_done:
  alt253_0:
.annotate 'line', 168
    set_addr $I10, alt253_1
    rx249_cur."!mark_push"(0, rx249_pos, $I10)
  # rx literal  "->"
    add $I11, rx249_pos, 2
    gt $I11, rx249_eos, rx249_fail
    sub $I11, rx249_pos, rx249_off
    substr $S10, rx249_tgt, $I11, 2
    ne $S10, "->", rx249_fail
    add rx249_pos, 2
    goto alt253_end
  alt253_1:
  # rx literal  "<->"
    add $I11, rx249_pos, 3
    gt $I11, rx249_eos, rx249_fail
    sub $I11, rx249_pos, rx249_off
    substr $S10, rx249_tgt, $I11, 3
    ne $S10, "<->", rx249_fail
    add rx249_pos, 3
  alt253_end:
  # rx pass
    rx249_cur."!cursor_pass"(rx249_pos, "lambda")
    if_null rx249_debug, debug_684
    rx249_cur."!cursor_debug"("PASS", "lambda", " at pos=", rx249_pos)
  debug_684:
    .return (rx249_cur)
  rx249_restart:
.annotate 'line', 10
    if_null rx249_debug, debug_685
    rx249_cur."!cursor_debug"("NEXT", "lambda")
  debug_685:
  rx249_fail:
    (rx249_rep, rx249_pos, $I10, $P10) = rx249_cur."!mark_fail"(0)
    lt rx249_pos, -1, rx249_done
    eq rx249_pos, -1, rx249_fail
    jump $I10
  rx249_done:
    rx249_cur."!cursor_fail"()
    if_null rx249_debug, debug_686
    rx249_cur."!cursor_debug"("FAIL", "lambda")
  debug_686:
    .return (rx249_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__lambda"  :nsentry("!PREFIX__lambda") :subid("44_1303340952.947") :method
.annotate 'line', 10
    new $P251, "ResizablePMCArray"
    push $P251, "<->"
    push $P251, "->"
    .return ($P251)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "block"  :subid("45_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx255_tgt
    .local int rx255_pos
    .local int rx255_off
    .local int rx255_eos
    .local int rx255_rep
    .local pmc rx255_cur
    .local pmc rx255_debug
    (rx255_cur, rx255_pos, rx255_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx255_cur
    .local pmc match
    .lex "$/", match
    length rx255_eos, rx255_tgt
    gt rx255_pos, rx255_eos, rx255_done
    set rx255_off, 0
    lt rx255_pos, 2, rx255_start
    sub rx255_off, rx255_pos, 1
    substr rx255_tgt, rx255_tgt, rx255_off
  rx255_start:
    eq $I10, 1, rx255_restart
    if_null rx255_debug, debug_687
    rx255_cur."!cursor_debug"("START", "block")
  debug_687:
    $I10 = self.'from'()
    ne $I10, -1, rxscan259_done
    goto rxscan259_scan
  rxscan259_loop:
    (rx255_pos) = rx255_cur."from"()
    inc rx255_pos
    rx255_cur."!cursor_from"(rx255_pos)
    ge rx255_pos, rx255_eos, rxscan259_done
  rxscan259_scan:
    set_addr $I10, rxscan259_loop
    rx255_cur."!mark_push"(0, rx255_pos, $I10)
  rxscan259_done:
  alt260_0:
.annotate 'line', 171
    set_addr $I10, alt260_1
    rx255_cur."!mark_push"(0, rx255_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx255_pos, rx255_off
    substr $S10, rx255_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx255_fail
    goto alt260_end
  alt260_1:
  # rx subrule "panic" subtype=method negate=
    rx255_cur."!cursor_pos"(rx255_pos)
    $P10 = rx255_cur."panic"("Missing block")
    unless $P10, rx255_fail
    rx255_pos = $P10."pos"()
  alt260_end:
.annotate 'line', 172
  # rx subrule "newpad" subtype=method negate=
    rx255_cur."!cursor_pos"(rx255_pos)
    $P10 = rx255_cur."newpad"()
    unless $P10, rx255_fail
    rx255_pos = $P10."pos"()
.annotate 'line', 173
  # rx subrule "blockoid" subtype=capture negate=
    rx255_cur."!cursor_pos"(rx255_pos)
    $P10 = rx255_cur."blockoid"()
    unless $P10, rx255_fail
    rx255_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx255_pos = $P10."pos"()
.annotate 'line', 170
  # rx pass
    rx255_cur."!cursor_pass"(rx255_pos, "block")
    if_null rx255_debug, debug_688
    rx255_cur."!cursor_debug"("PASS", "block", " at pos=", rx255_pos)
  debug_688:
    .return (rx255_cur)
  rx255_restart:
.annotate 'line', 10
    if_null rx255_debug, debug_689
    rx255_cur."!cursor_debug"("NEXT", "block")
  debug_689:
  rx255_fail:
    (rx255_rep, rx255_pos, $I10, $P10) = rx255_cur."!mark_fail"(0)
    lt rx255_pos, -1, rx255_done
    eq rx255_pos, -1, rx255_fail
    jump $I10
  rx255_done:
    rx255_cur."!cursor_fail"()
    if_null rx255_debug, debug_690
    rx255_cur."!cursor_debug"("FAIL", "block")
  debug_690:
    .return (rx255_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__block"  :nsentry("!PREFIX__block") :subid("46_1303340952.947") :method
.annotate 'line', 10
    $P257 = self."!PREFIX__!subrule"("panic", "")
    new $P258, "ResizablePMCArray"
    push $P258, $P257
    push $P258, "{"
    .return ($P258)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blockoid"  :subid("47_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx262_tgt
    .local int rx262_pos
    .local int rx262_off
    .local int rx262_eos
    .local int rx262_rep
    .local pmc rx262_cur
    .local pmc rx262_debug
    (rx262_cur, rx262_pos, rx262_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx262_cur
    .local pmc match
    .lex "$/", match
    length rx262_eos, rx262_tgt
    gt rx262_pos, rx262_eos, rx262_done
    set rx262_off, 0
    lt rx262_pos, 2, rx262_start
    sub rx262_off, rx262_pos, 1
    substr rx262_tgt, rx262_tgt, rx262_off
  rx262_start:
    eq $I10, 1, rx262_restart
    if_null rx262_debug, debug_691
    rx262_cur."!cursor_debug"("START", "blockoid")
  debug_691:
    $I10 = self.'from'()
    ne $I10, -1, rxscan266_done
    goto rxscan266_scan
  rxscan266_loop:
    (rx262_pos) = rx262_cur."from"()
    inc rx262_pos
    rx262_cur."!cursor_from"(rx262_pos)
    ge rx262_pos, rx262_eos, rxscan266_done
  rxscan266_scan:
    set_addr $I10, rxscan266_loop
    rx262_cur."!mark_push"(0, rx262_pos, $I10)
  rxscan266_done:
.annotate 'line', 177
  # rx subrule "finishpad" subtype=method negate=
    rx262_cur."!cursor_pos"(rx262_pos)
    $P10 = rx262_cur."finishpad"()
    unless $P10, rx262_fail
    rx262_pos = $P10."pos"()
  alt267_0:
.annotate 'line', 178
    set_addr $I10, alt267_1
    rx262_cur."!mark_push"(0, rx262_pos, $I10)
.annotate 'line', 179
  # rx literal  "{YOU_ARE_HERE}"
    add $I11, rx262_pos, 14
    gt $I11, rx262_eos, rx262_fail
    sub $I11, rx262_pos, rx262_off
    substr $S10, rx262_tgt, $I11, 14
    ne $S10, "{YOU_ARE_HERE}", rx262_fail
    add rx262_pos, 14
  # rx subrule "you_are_here" subtype=capture negate=
    rx262_cur."!cursor_pos"(rx262_pos)
    $P10 = rx262_cur."you_are_here"()
    unless $P10, rx262_fail
    rx262_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("you_are_here")
    rx262_pos = $P10."pos"()
    goto alt267_end
  alt267_1:
.annotate 'line', 180
  # rx literal  "{"
    add $I11, rx262_pos, 1
    gt $I11, rx262_eos, rx262_fail
    sub $I11, rx262_pos, rx262_off
    ord $I11, rx262_tgt, $I11
    ne $I11, 123, rx262_fail
    add rx262_pos, 1
  # rx subrule "statementlist" subtype=capture negate=
    rx262_cur."!cursor_pos"(rx262_pos)
    $P10 = rx262_cur."statementlist"()
    unless $P10, rx262_fail
    rx262_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx262_pos = $P10."pos"()
  alt268_0:
    set_addr $I10, alt268_1
    rx262_cur."!mark_push"(0, rx262_pos, $I10)
  # rx literal  "}"
    add $I11, rx262_pos, 1
    gt $I11, rx262_eos, rx262_fail
    sub $I11, rx262_pos, rx262_off
    ord $I11, rx262_tgt, $I11
    ne $I11, 125, rx262_fail
    add rx262_pos, 1
    goto alt268_end
  alt268_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx262_cur."!cursor_pos"(rx262_pos)
    $P10 = rx262_cur."FAILGOAL"("'}'")
    unless $P10, rx262_fail
    goto rxsubrule270_pass
  rxsubrule270_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx262_fail
  rxsubrule270_pass:
    set_addr $I10, rxsubrule270_back
    rx262_cur."!mark_push"(0, rx262_pos, $I10, $P10)
    rx262_pos = $P10."pos"()
  alt268_end:
  alt267_end:
.annotate 'line', 182
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx262_cur."!cursor_pos"(rx262_pos)
    $P10 = rx262_cur."ENDSTMT"()
    unless $P10, rx262_fail
.annotate 'line', 176
  # rx pass
    rx262_cur."!cursor_pass"(rx262_pos, "blockoid")
    if_null rx262_debug, debug_692
    rx262_cur."!cursor_debug"("PASS", "blockoid", " at pos=", rx262_pos)
  debug_692:
    .return (rx262_cur)
  rx262_restart:
.annotate 'line', 10
    if_null rx262_debug, debug_693
    rx262_cur."!cursor_debug"("NEXT", "blockoid")
  debug_693:
  rx262_fail:
    (rx262_rep, rx262_pos, $I10, $P10) = rx262_cur."!mark_fail"(0)
    lt rx262_pos, -1, rx262_done
    eq rx262_pos, -1, rx262_fail
    jump $I10
  rx262_done:
    rx262_cur."!cursor_fail"()
    if_null rx262_debug, debug_694
    rx262_cur."!cursor_debug"("FAIL", "blockoid")
  debug_694:
    .return (rx262_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blockoid"  :nsentry("!PREFIX__blockoid") :subid("48_1303340952.947") :method
.annotate 'line', 10
    $P264 = self."!PREFIX__!subrule"("finishpad", "")
    new $P265, "ResizablePMCArray"
    push $P265, $P264
    .return ($P265)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "newpad"  :subid("49_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx272_tgt
    .local int rx272_pos
    .local int rx272_off
    .local int rx272_eos
    .local int rx272_rep
    .local pmc rx272_cur
    .local pmc rx272_debug
    (rx272_cur, rx272_pos, rx272_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx272_cur
    .local pmc match
    .lex "$/", match
    length rx272_eos, rx272_tgt
    gt rx272_pos, rx272_eos, rx272_done
    set rx272_off, 0
    lt rx272_pos, 2, rx272_start
    sub rx272_off, rx272_pos, 1
    substr rx272_tgt, rx272_tgt, rx272_off
  rx272_start:
    eq $I10, 1, rx272_restart
    if_null rx272_debug, debug_695
    rx272_cur."!cursor_debug"("START", "newpad")
  debug_695:
    $I10 = self.'from'()
    ne $I10, -1, rxscan275_done
    goto rxscan275_scan
  rxscan275_loop:
    (rx272_pos) = rx272_cur."from"()
    inc rx272_pos
    rx272_cur."!cursor_from"(rx272_pos)
    ge rx272_pos, rx272_eos, rxscan275_done
  rxscan275_scan:
    set_addr $I10, rxscan275_loop
    rx272_cur."!mark_push"(0, rx272_pos, $I10)
  rxscan275_done:
.annotate 'line', 185
  # rx pass
    rx272_cur."!cursor_pass"(rx272_pos, "newpad")
    if_null rx272_debug, debug_696
    rx272_cur."!cursor_debug"("PASS", "newpad", " at pos=", rx272_pos)
  debug_696:
    .return (rx272_cur)
  rx272_restart:
.annotate 'line', 10
    if_null rx272_debug, debug_697
    rx272_cur."!cursor_debug"("NEXT", "newpad")
  debug_697:
  rx272_fail:
    (rx272_rep, rx272_pos, $I10, $P10) = rx272_cur."!mark_fail"(0)
    lt rx272_pos, -1, rx272_done
    eq rx272_pos, -1, rx272_fail
    jump $I10
  rx272_done:
    rx272_cur."!cursor_fail"()
    if_null rx272_debug, debug_698
    rx272_cur."!cursor_debug"("FAIL", "newpad")
  debug_698:
    .return (rx272_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__newpad"  :nsentry("!PREFIX__newpad") :subid("50_1303340952.947") :method
.annotate 'line', 10
    new $P274, "ResizablePMCArray"
    push $P274, ""
    .return ($P274)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "outerctx"  :subid("51_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx277_tgt
    .local int rx277_pos
    .local int rx277_off
    .local int rx277_eos
    .local int rx277_rep
    .local pmc rx277_cur
    .local pmc rx277_debug
    (rx277_cur, rx277_pos, rx277_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx277_cur
    .local pmc match
    .lex "$/", match
    length rx277_eos, rx277_tgt
    gt rx277_pos, rx277_eos, rx277_done
    set rx277_off, 0
    lt rx277_pos, 2, rx277_start
    sub rx277_off, rx277_pos, 1
    substr rx277_tgt, rx277_tgt, rx277_off
  rx277_start:
    eq $I10, 1, rx277_restart
    if_null rx277_debug, debug_699
    rx277_cur."!cursor_debug"("START", "outerctx")
  debug_699:
    $I10 = self.'from'()
    ne $I10, -1, rxscan280_done
    goto rxscan280_scan
  rxscan280_loop:
    (rx277_pos) = rx277_cur."from"()
    inc rx277_pos
    rx277_cur."!cursor_from"(rx277_pos)
    ge rx277_pos, rx277_eos, rxscan280_done
  rxscan280_scan:
    set_addr $I10, rxscan280_loop
    rx277_cur."!mark_push"(0, rx277_pos, $I10)
  rxscan280_done:
.annotate 'line', 186
  # rx pass
    rx277_cur."!cursor_pass"(rx277_pos, "outerctx")
    if_null rx277_debug, debug_700
    rx277_cur."!cursor_debug"("PASS", "outerctx", " at pos=", rx277_pos)
  debug_700:
    .return (rx277_cur)
  rx277_restart:
.annotate 'line', 10
    if_null rx277_debug, debug_701
    rx277_cur."!cursor_debug"("NEXT", "outerctx")
  debug_701:
  rx277_fail:
    (rx277_rep, rx277_pos, $I10, $P10) = rx277_cur."!mark_fail"(0)
    lt rx277_pos, -1, rx277_done
    eq rx277_pos, -1, rx277_fail
    jump $I10
  rx277_done:
    rx277_cur."!cursor_fail"()
    if_null rx277_debug, debug_702
    rx277_cur."!cursor_debug"("FAIL", "outerctx")
  debug_702:
    .return (rx277_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__outerctx"  :nsentry("!PREFIX__outerctx") :subid("52_1303340952.947") :method
.annotate 'line', 10
    new $P279, "ResizablePMCArray"
    push $P279, ""
    .return ($P279)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "GLOBALish"  :subid("53_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx282_tgt
    .local int rx282_pos
    .local int rx282_off
    .local int rx282_eos
    .local int rx282_rep
    .local pmc rx282_cur
    .local pmc rx282_debug
    (rx282_cur, rx282_pos, rx282_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx282_cur
    .local pmc match
    .lex "$/", match
    length rx282_eos, rx282_tgt
    gt rx282_pos, rx282_eos, rx282_done
    set rx282_off, 0
    lt rx282_pos, 2, rx282_start
    sub rx282_off, rx282_pos, 1
    substr rx282_tgt, rx282_tgt, rx282_off
  rx282_start:
    eq $I10, 1, rx282_restart
    if_null rx282_debug, debug_703
    rx282_cur."!cursor_debug"("START", "GLOBALish")
  debug_703:
    $I10 = self.'from'()
    ne $I10, -1, rxscan285_done
    goto rxscan285_scan
  rxscan285_loop:
    (rx282_pos) = rx282_cur."from"()
    inc rx282_pos
    rx282_cur."!cursor_from"(rx282_pos)
    ge rx282_pos, rx282_eos, rxscan285_done
  rxscan285_scan:
    set_addr $I10, rxscan285_loop
    rx282_cur."!mark_push"(0, rx282_pos, $I10)
  rxscan285_done:
.annotate 'line', 187
  # rx pass
    rx282_cur."!cursor_pass"(rx282_pos, "GLOBALish")
    if_null rx282_debug, debug_704
    rx282_cur."!cursor_debug"("PASS", "GLOBALish", " at pos=", rx282_pos)
  debug_704:
    .return (rx282_cur)
  rx282_restart:
.annotate 'line', 10
    if_null rx282_debug, debug_705
    rx282_cur."!cursor_debug"("NEXT", "GLOBALish")
  debug_705:
  rx282_fail:
    (rx282_rep, rx282_pos, $I10, $P10) = rx282_cur."!mark_fail"(0)
    lt rx282_pos, -1, rx282_done
    eq rx282_pos, -1, rx282_fail
    jump $I10
  rx282_done:
    rx282_cur."!cursor_fail"()
    if_null rx282_debug, debug_706
    rx282_cur."!cursor_debug"("FAIL", "GLOBALish")
  debug_706:
    .return (rx282_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__GLOBALish"  :nsentry("!PREFIX__GLOBALish") :subid("54_1303340952.947") :method
.annotate 'line', 10
    new $P284, "ResizablePMCArray"
    push $P284, ""
    .return ($P284)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "finishpad"  :subid("55_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx287_tgt
    .local int rx287_pos
    .local int rx287_off
    .local int rx287_eos
    .local int rx287_rep
    .local pmc rx287_cur
    .local pmc rx287_debug
    (rx287_cur, rx287_pos, rx287_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx287_cur
    .local pmc match
    .lex "$/", match
    length rx287_eos, rx287_tgt
    gt rx287_pos, rx287_eos, rx287_done
    set rx287_off, 0
    lt rx287_pos, 2, rx287_start
    sub rx287_off, rx287_pos, 1
    substr rx287_tgt, rx287_tgt, rx287_off
  rx287_start:
    eq $I10, 1, rx287_restart
    if_null rx287_debug, debug_707
    rx287_cur."!cursor_debug"("START", "finishpad")
  debug_707:
    $I10 = self.'from'()
    ne $I10, -1, rxscan290_done
    goto rxscan290_scan
  rxscan290_loop:
    (rx287_pos) = rx287_cur."from"()
    inc rx287_pos
    rx287_cur."!cursor_from"(rx287_pos)
    ge rx287_pos, rx287_eos, rxscan290_done
  rxscan290_scan:
    set_addr $I10, rxscan290_loop
    rx287_cur."!mark_push"(0, rx287_pos, $I10)
  rxscan290_done:
.annotate 'line', 188
  # rx pass
    rx287_cur."!cursor_pass"(rx287_pos, "finishpad")
    if_null rx287_debug, debug_708
    rx287_cur."!cursor_debug"("PASS", "finishpad", " at pos=", rx287_pos)
  debug_708:
    .return (rx287_cur)
  rx287_restart:
.annotate 'line', 10
    if_null rx287_debug, debug_709
    rx287_cur."!cursor_debug"("NEXT", "finishpad")
  debug_709:
  rx287_fail:
    (rx287_rep, rx287_pos, $I10, $P10) = rx287_cur."!mark_fail"(0)
    lt rx287_pos, -1, rx287_done
    eq rx287_pos, -1, rx287_fail
    jump $I10
  rx287_done:
    rx287_cur."!cursor_fail"()
    if_null rx287_debug, debug_710
    rx287_cur."!cursor_debug"("FAIL", "finishpad")
  debug_710:
    .return (rx287_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__finishpad"  :nsentry("!PREFIX__finishpad") :subid("56_1303340952.947") :method
.annotate 'line', 10
    new $P289, "ResizablePMCArray"
    push $P289, ""
    .return ($P289)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "you_are_here"  :subid("57_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx292_tgt
    .local int rx292_pos
    .local int rx292_off
    .local int rx292_eos
    .local int rx292_rep
    .local pmc rx292_cur
    .local pmc rx292_debug
    (rx292_cur, rx292_pos, rx292_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx292_cur
    .local pmc match
    .lex "$/", match
    length rx292_eos, rx292_tgt
    gt rx292_pos, rx292_eos, rx292_done
    set rx292_off, 0
    lt rx292_pos, 2, rx292_start
    sub rx292_off, rx292_pos, 1
    substr rx292_tgt, rx292_tgt, rx292_off
  rx292_start:
    eq $I10, 1, rx292_restart
    if_null rx292_debug, debug_711
    rx292_cur."!cursor_debug"("START", "you_are_here")
  debug_711:
    $I10 = self.'from'()
    ne $I10, -1, rxscan295_done
    goto rxscan295_scan
  rxscan295_loop:
    (rx292_pos) = rx292_cur."from"()
    inc rx292_pos
    rx292_cur."!cursor_from"(rx292_pos)
    ge rx292_pos, rx292_eos, rxscan295_done
  rxscan295_scan:
    set_addr $I10, rxscan295_loop
    rx292_cur."!mark_push"(0, rx292_pos, $I10)
  rxscan295_done:
.annotate 'line', 189
  # rx pass
    rx292_cur."!cursor_pass"(rx292_pos, "you_are_here")
    if_null rx292_debug, debug_712
    rx292_cur."!cursor_debug"("PASS", "you_are_here", " at pos=", rx292_pos)
  debug_712:
    .return (rx292_cur)
  rx292_restart:
.annotate 'line', 10
    if_null rx292_debug, debug_713
    rx292_cur."!cursor_debug"("NEXT", "you_are_here")
  debug_713:
  rx292_fail:
    (rx292_rep, rx292_pos, $I10, $P10) = rx292_cur."!mark_fail"(0)
    lt rx292_pos, -1, rx292_done
    eq rx292_pos, -1, rx292_fail
    jump $I10
  rx292_done:
    rx292_cur."!cursor_fail"()
    if_null rx292_debug, debug_714
    rx292_cur."!cursor_debug"("FAIL", "you_are_here")
  debug_714:
    .return (rx292_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__you_are_here"  :nsentry("!PREFIX__you_are_here") :subid("58_1303340952.947") :method
.annotate 'line', 10
    new $P294, "ResizablePMCArray"
    push $P294, ""
    .return ($P294)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator"  :subid("59_1303340952.947")
    .param pmc param_297
.annotate 'line', 191
    .lex "self", param_297
    $P298 = param_297."!protoregex"("terminator")
    .return ($P298)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator"  :subid("60_1303340952.947")
    .param pmc param_300
.annotate 'line', 191
    .lex "self", param_300
    $P301 = param_300."!PREFIX__!protoregex"("terminator")
    .return ($P301)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<;>"  :subid("61_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx303_tgt
    .local int rx303_pos
    .local int rx303_off
    .local int rx303_eos
    .local int rx303_rep
    .local pmc rx303_cur
    .local pmc rx303_debug
    (rx303_cur, rx303_pos, rx303_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx303_cur
    .local pmc match
    .lex "$/", match
    length rx303_eos, rx303_tgt
    gt rx303_pos, rx303_eos, rx303_done
    set rx303_off, 0
    lt rx303_pos, 2, rx303_start
    sub rx303_off, rx303_pos, 1
    substr rx303_tgt, rx303_tgt, rx303_off
  rx303_start:
    eq $I10, 1, rx303_restart
    if_null rx303_debug, debug_715
    rx303_cur."!cursor_debug"("START", "terminator:sym<;>")
  debug_715:
    $I10 = self.'from'()
    ne $I10, -1, rxscan306_done
    goto rxscan306_scan
  rxscan306_loop:
    (rx303_pos) = rx303_cur."from"()
    inc rx303_pos
    rx303_cur."!cursor_from"(rx303_pos)
    ge rx303_pos, rx303_eos, rxscan306_done
  rxscan306_scan:
    set_addr $I10, rxscan306_loop
    rx303_cur."!mark_push"(0, rx303_pos, $I10)
  rxscan306_done:
.annotate 'line', 193
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx303_pos, rx303_off
    substr $S10, rx303_tgt, $I10, 1
    index $I11, ";", $S10
    lt $I11, 0, rx303_fail
  # rx pass
    rx303_cur."!cursor_pass"(rx303_pos, "terminator:sym<;>")
    if_null rx303_debug, debug_716
    rx303_cur."!cursor_debug"("PASS", "terminator:sym<;>", " at pos=", rx303_pos)
  debug_716:
    .return (rx303_cur)
  rx303_restart:
.annotate 'line', 10
    if_null rx303_debug, debug_717
    rx303_cur."!cursor_debug"("NEXT", "terminator:sym<;>")
  debug_717:
  rx303_fail:
    (rx303_rep, rx303_pos, $I10, $P10) = rx303_cur."!mark_fail"(0)
    lt rx303_pos, -1, rx303_done
    eq rx303_pos, -1, rx303_fail
    jump $I10
  rx303_done:
    rx303_cur."!cursor_fail"()
    if_null rx303_debug, debug_718
    rx303_cur."!cursor_debug"("FAIL", "terminator:sym<;>")
  debug_718:
    .return (rx303_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<;>"  :nsentry("!PREFIX__terminator:sym<;>") :subid("62_1303340952.947") :method
.annotate 'line', 10
    new $P305, "ResizablePMCArray"
    push $P305, ";"
    .return ($P305)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<}>"  :subid("63_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx308_tgt
    .local int rx308_pos
    .local int rx308_off
    .local int rx308_eos
    .local int rx308_rep
    .local pmc rx308_cur
    .local pmc rx308_debug
    (rx308_cur, rx308_pos, rx308_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx308_cur
    .local pmc match
    .lex "$/", match
    length rx308_eos, rx308_tgt
    gt rx308_pos, rx308_eos, rx308_done
    set rx308_off, 0
    lt rx308_pos, 2, rx308_start
    sub rx308_off, rx308_pos, 1
    substr rx308_tgt, rx308_tgt, rx308_off
  rx308_start:
    eq $I10, 1, rx308_restart
    if_null rx308_debug, debug_719
    rx308_cur."!cursor_debug"("START", "terminator:sym<}>")
  debug_719:
    $I10 = self.'from'()
    ne $I10, -1, rxscan311_done
    goto rxscan311_scan
  rxscan311_loop:
    (rx308_pos) = rx308_cur."from"()
    inc rx308_pos
    rx308_cur."!cursor_from"(rx308_pos)
    ge rx308_pos, rx308_eos, rxscan311_done
  rxscan311_scan:
    set_addr $I10, rxscan311_loop
    rx308_cur."!mark_push"(0, rx308_pos, $I10)
  rxscan311_done:
.annotate 'line', 194
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx308_pos, rx308_off
    substr $S10, rx308_tgt, $I10, 1
    index $I11, "}", $S10
    lt $I11, 0, rx308_fail
  # rx pass
    rx308_cur."!cursor_pass"(rx308_pos, "terminator:sym<}>")
    if_null rx308_debug, debug_720
    rx308_cur."!cursor_debug"("PASS", "terminator:sym<}>", " at pos=", rx308_pos)
  debug_720:
    .return (rx308_cur)
  rx308_restart:
.annotate 'line', 10
    if_null rx308_debug, debug_721
    rx308_cur."!cursor_debug"("NEXT", "terminator:sym<}>")
  debug_721:
  rx308_fail:
    (rx308_rep, rx308_pos, $I10, $P10) = rx308_cur."!mark_fail"(0)
    lt rx308_pos, -1, rx308_done
    eq rx308_pos, -1, rx308_fail
    jump $I10
  rx308_done:
    rx308_cur."!cursor_fail"()
    if_null rx308_debug, debug_722
    rx308_cur."!cursor_debug"("FAIL", "terminator:sym<}>")
  debug_722:
    .return (rx308_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<}>"  :nsentry("!PREFIX__terminator:sym<}>") :subid("64_1303340952.947") :method
.annotate 'line', 10
    new $P310, "ResizablePMCArray"
    push $P310, "}"
    .return ($P310)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control"  :subid("65_1303340952.947")
    .param pmc param_313
.annotate 'line', 198
    .lex "self", param_313
    $P314 = param_313."!protoregex"("statement_control")
    .return ($P314)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control"  :subid("66_1303340952.947")
    .param pmc param_316
.annotate 'line', 198
    .lex "self", param_316
    $P317 = param_316."!PREFIX__!protoregex"("statement_control")
    .return ($P317)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<use>"  :subid("67_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx319_tgt
    .local int rx319_pos
    .local int rx319_off
    .local int rx319_eos
    .local int rx319_rep
    .local pmc rx319_cur
    .local pmc rx319_debug
    (rx319_cur, rx319_pos, rx319_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx319_cur
    .local pmc match
    .lex "$/", match
    length rx319_eos, rx319_tgt
    gt rx319_pos, rx319_eos, rx319_done
    set rx319_off, 0
    lt rx319_pos, 2, rx319_start
    sub rx319_off, rx319_pos, 1
    substr rx319_tgt, rx319_tgt, rx319_off
  rx319_start:
    eq $I10, 1, rx319_restart
    if_null rx319_debug, debug_723
    rx319_cur."!cursor_debug"("START", "statement_control:sym<use>")
  debug_723:
    $I10 = self.'from'()
    ne $I10, -1, rxscan322_done
    goto rxscan322_scan
  rxscan322_loop:
    (rx319_pos) = rx319_cur."from"()
    inc rx319_pos
    rx319_cur."!cursor_from"(rx319_pos)
    ge rx319_pos, rx319_eos, rxscan322_done
  rxscan322_scan:
    set_addr $I10, rxscan322_loop
    rx319_cur."!mark_push"(0, rx319_pos, $I10)
  rxscan322_done:
.annotate 'line', 201
  # rx subcapture "sym"
    set_addr $I10, rxcap_323_fail
    rx319_cur."!mark_push"(0, rx319_pos, $I10)
  # rx literal  "use"
    add $I11, rx319_pos, 3
    gt $I11, rx319_eos, rx319_fail
    sub $I11, rx319_pos, rx319_off
    substr $S10, rx319_tgt, $I11, 3
    ne $S10, "use", rx319_fail
    add rx319_pos, 3
    set_addr $I10, rxcap_323_fail
    ($I12, $I11) = rx319_cur."!mark_peek"($I10)
    rx319_cur."!cursor_pos"($I11)
    ($P10) = rx319_cur."!cursor_start"()
    $P10."!cursor_pass"(rx319_pos, "")
    rx319_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_323_done
  rxcap_323_fail:
    goto rx319_fail
  rxcap_323_done:
  # rx charclass s
    ge rx319_pos, rx319_eos, rx319_fail
    sub $I10, rx319_pos, rx319_off
    is_cclass $I11, 32, rx319_tgt, $I10
    unless $I11, rx319_fail
    inc rx319_pos
  # rx subrule "ws" subtype=method negate=
    rx319_cur."!cursor_pos"(rx319_pos)
    $P10 = rx319_cur."ws"()
    unless $P10, rx319_fail
    rx319_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx319_cur."!cursor_pos"(rx319_pos)
    $P10 = rx319_cur."name"()
    unless $P10, rx319_fail
    rx319_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx319_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx319_cur."!cursor_pos"(rx319_pos)
    $P10 = rx319_cur."ws"()
    unless $P10, rx319_fail
    rx319_pos = $P10."pos"()
.annotate 'line', 200
  # rx pass
    rx319_cur."!cursor_pass"(rx319_pos, "statement_control:sym<use>")
    if_null rx319_debug, debug_724
    rx319_cur."!cursor_debug"("PASS", "statement_control:sym<use>", " at pos=", rx319_pos)
  debug_724:
    .return (rx319_cur)
  rx319_restart:
.annotate 'line', 10
    if_null rx319_debug, debug_725
    rx319_cur."!cursor_debug"("NEXT", "statement_control:sym<use>")
  debug_725:
  rx319_fail:
    (rx319_rep, rx319_pos, $I10, $P10) = rx319_cur."!mark_fail"(0)
    lt rx319_pos, -1, rx319_done
    eq rx319_pos, -1, rx319_fail
    jump $I10
  rx319_done:
    rx319_cur."!cursor_fail"()
    if_null rx319_debug, debug_726
    rx319_cur."!cursor_debug"("FAIL", "statement_control:sym<use>")
  debug_726:
    .return (rx319_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<use>"  :nsentry("!PREFIX__statement_control:sym<use>") :subid("68_1303340952.947") :method
.annotate 'line', 10
    new $P321, "ResizablePMCArray"
    push $P321, "use"
    .return ($P321)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<if>"  :subid("69_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx327_tgt
    .local int rx327_pos
    .local int rx327_off
    .local int rx327_eos
    .local int rx327_rep
    .local pmc rx327_cur
    .local pmc rx327_debug
    (rx327_cur, rx327_pos, rx327_tgt, $I10) = self."!cursor_start"()
    rx327_cur."!cursor_caparray"("xblock", "else")
    .lex unicode:"$\x{a2}", rx327_cur
    .local pmc match
    .lex "$/", match
    length rx327_eos, rx327_tgt
    gt rx327_pos, rx327_eos, rx327_done
    set rx327_off, 0
    lt rx327_pos, 2, rx327_start
    sub rx327_off, rx327_pos, 1
    substr rx327_tgt, rx327_tgt, rx327_off
  rx327_start:
    eq $I10, 1, rx327_restart
    if_null rx327_debug, debug_727
    rx327_cur."!cursor_debug"("START", "statement_control:sym<if>")
  debug_727:
    $I10 = self.'from'()
    ne $I10, -1, rxscan330_done
    goto rxscan330_scan
  rxscan330_loop:
    (rx327_pos) = rx327_cur."from"()
    inc rx327_pos
    rx327_cur."!cursor_from"(rx327_pos)
    ge rx327_pos, rx327_eos, rxscan330_done
  rxscan330_scan:
    set_addr $I10, rxscan330_loop
    rx327_cur."!mark_push"(0, rx327_pos, $I10)
  rxscan330_done:
.annotate 'line', 205
  # rx subcapture "sym"
    set_addr $I10, rxcap_331_fail
    rx327_cur."!mark_push"(0, rx327_pos, $I10)
  # rx literal  "if"
    add $I11, rx327_pos, 2
    gt $I11, rx327_eos, rx327_fail
    sub $I11, rx327_pos, rx327_off
    substr $S10, rx327_tgt, $I11, 2
    ne $S10, "if", rx327_fail
    add rx327_pos, 2
    set_addr $I10, rxcap_331_fail
    ($I12, $I11) = rx327_cur."!mark_peek"($I10)
    rx327_cur."!cursor_pos"($I11)
    ($P10) = rx327_cur."!cursor_start"()
    $P10."!cursor_pass"(rx327_pos, "")
    rx327_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_331_done
  rxcap_331_fail:
    goto rx327_fail
  rxcap_331_done:
  # rx charclass s
    ge rx327_pos, rx327_eos, rx327_fail
    sub $I10, rx327_pos, rx327_off
    is_cclass $I11, 32, rx327_tgt, $I10
    unless $I11, rx327_fail
    inc rx327_pos
  # rx subrule "ws" subtype=method negate=
    rx327_cur."!cursor_pos"(rx327_pos)
    $P10 = rx327_cur."ws"()
    unless $P10, rx327_fail
    rx327_pos = $P10."pos"()
.annotate 'line', 206
  # rx subrule "xblock" subtype=capture negate=
    rx327_cur."!cursor_pos"(rx327_pos)
    $P10 = rx327_cur."xblock"()
    unless $P10, rx327_fail
    rx327_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx327_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx327_cur."!cursor_pos"(rx327_pos)
    $P10 = rx327_cur."ws"()
    unless $P10, rx327_fail
    rx327_pos = $P10."pos"()
.annotate 'line', 207
  # rx rxquantr334 ** 0..*
    set_addr $I10, rxquantr334_done
    rx327_cur."!mark_push"(0, rx327_pos, $I10)
  rxquantr334_loop:
  # rx subrule "ws" subtype=method negate=
    rx327_cur."!cursor_pos"(rx327_pos)
    $P10 = rx327_cur."ws"()
    unless $P10, rx327_fail
    rx327_pos = $P10."pos"()
  # rx literal  "elsif"
    add $I11, rx327_pos, 5
    gt $I11, rx327_eos, rx327_fail
    sub $I11, rx327_pos, rx327_off
    substr $S10, rx327_tgt, $I11, 5
    ne $S10, "elsif", rx327_fail
    add rx327_pos, 5
  # rx charclass s
    ge rx327_pos, rx327_eos, rx327_fail
    sub $I10, rx327_pos, rx327_off
    is_cclass $I11, 32, rx327_tgt, $I10
    unless $I11, rx327_fail
    inc rx327_pos
  # rx subrule "ws" subtype=method negate=
    rx327_cur."!cursor_pos"(rx327_pos)
    $P10 = rx327_cur."ws"()
    unless $P10, rx327_fail
    rx327_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx327_cur."!cursor_pos"(rx327_pos)
    $P10 = rx327_cur."xblock"()
    unless $P10, rx327_fail
    rx327_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx327_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx327_cur."!cursor_pos"(rx327_pos)
    $P10 = rx327_cur."ws"()
    unless $P10, rx327_fail
    rx327_pos = $P10."pos"()
    set_addr $I10, rxquantr334_done
    (rx327_rep) = rx327_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr334_done
    rx327_cur."!mark_push"(rx327_rep, rx327_pos, $I10)
    goto rxquantr334_loop
  rxquantr334_done:
  # rx subrule "ws" subtype=method negate=
    rx327_cur."!cursor_pos"(rx327_pos)
    $P10 = rx327_cur."ws"()
    unless $P10, rx327_fail
    rx327_pos = $P10."pos"()
.annotate 'line', 208
  # rx rxquantr339 ** 0..1
    set_addr $I10, rxquantr339_done
    rx327_cur."!mark_push"(0, rx327_pos, $I10)
  rxquantr339_loop:
  # rx subrule "ws" subtype=method negate=
    rx327_cur."!cursor_pos"(rx327_pos)
    $P10 = rx327_cur."ws"()
    unless $P10, rx327_fail
    rx327_pos = $P10."pos"()
  # rx literal  "else"
    add $I11, rx327_pos, 4
    gt $I11, rx327_eos, rx327_fail
    sub $I11, rx327_pos, rx327_off
    substr $S10, rx327_tgt, $I11, 4
    ne $S10, "else", rx327_fail
    add rx327_pos, 4
  # rx charclass s
    ge rx327_pos, rx327_eos, rx327_fail
    sub $I10, rx327_pos, rx327_off
    is_cclass $I11, 32, rx327_tgt, $I10
    unless $I11, rx327_fail
    inc rx327_pos
  # rx subrule "ws" subtype=method negate=
    rx327_cur."!cursor_pos"(rx327_pos)
    $P10 = rx327_cur."ws"()
    unless $P10, rx327_fail
    rx327_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx327_cur."!cursor_pos"(rx327_pos)
    $P10 = rx327_cur."pblock"()
    unless $P10, rx327_fail
    rx327_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("else")
    rx327_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx327_cur."!cursor_pos"(rx327_pos)
    $P10 = rx327_cur."ws"()
    unless $P10, rx327_fail
    rx327_pos = $P10."pos"()
    set_addr $I10, rxquantr339_done
    (rx327_rep) = rx327_cur."!mark_commit"($I10)
  rxquantr339_done:
  # rx subrule "ws" subtype=method negate=
    rx327_cur."!cursor_pos"(rx327_pos)
    $P10 = rx327_cur."ws"()
    unless $P10, rx327_fail
    rx327_pos = $P10."pos"()
.annotate 'line', 204
  # rx pass
    rx327_cur."!cursor_pass"(rx327_pos, "statement_control:sym<if>")
    if_null rx327_debug, debug_728
    rx327_cur."!cursor_debug"("PASS", "statement_control:sym<if>", " at pos=", rx327_pos)
  debug_728:
    .return (rx327_cur)
  rx327_restart:
.annotate 'line', 10
    if_null rx327_debug, debug_729
    rx327_cur."!cursor_debug"("NEXT", "statement_control:sym<if>")
  debug_729:
  rx327_fail:
    (rx327_rep, rx327_pos, $I10, $P10) = rx327_cur."!mark_fail"(0)
    lt rx327_pos, -1, rx327_done
    eq rx327_pos, -1, rx327_fail
    jump $I10
  rx327_done:
    rx327_cur."!cursor_fail"()
    if_null rx327_debug, debug_730
    rx327_cur."!cursor_debug"("FAIL", "statement_control:sym<if>")
  debug_730:
    .return (rx327_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<if>"  :nsentry("!PREFIX__statement_control:sym<if>") :subid("70_1303340952.947") :method
.annotate 'line', 10
    new $P329, "ResizablePMCArray"
    push $P329, "if"
    .return ($P329)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<unless>"  :subid("71_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .const 'Sub' $P355 = "73_1303340952.947" 
    capture_lex $P355
    .local string rx345_tgt
    .local int rx345_pos
    .local int rx345_off
    .local int rx345_eos
    .local int rx345_rep
    .local pmc rx345_cur
    .local pmc rx345_debug
    (rx345_cur, rx345_pos, rx345_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx345_cur
    .local pmc match
    .lex "$/", match
    length rx345_eos, rx345_tgt
    gt rx345_pos, rx345_eos, rx345_done
    set rx345_off, 0
    lt rx345_pos, 2, rx345_start
    sub rx345_off, rx345_pos, 1
    substr rx345_tgt, rx345_tgt, rx345_off
  rx345_start:
    eq $I10, 1, rx345_restart
    if_null rx345_debug, debug_731
    rx345_cur."!cursor_debug"("START", "statement_control:sym<unless>")
  debug_731:
    $I10 = self.'from'()
    ne $I10, -1, rxscan348_done
    goto rxscan348_scan
  rxscan348_loop:
    (rx345_pos) = rx345_cur."from"()
    inc rx345_pos
    rx345_cur."!cursor_from"(rx345_pos)
    ge rx345_pos, rx345_eos, rxscan348_done
  rxscan348_scan:
    set_addr $I10, rxscan348_loop
    rx345_cur."!mark_push"(0, rx345_pos, $I10)
  rxscan348_done:
.annotate 'line', 212
  # rx subcapture "sym"
    set_addr $I10, rxcap_349_fail
    rx345_cur."!mark_push"(0, rx345_pos, $I10)
  # rx literal  "unless"
    add $I11, rx345_pos, 6
    gt $I11, rx345_eos, rx345_fail
    sub $I11, rx345_pos, rx345_off
    substr $S10, rx345_tgt, $I11, 6
    ne $S10, "unless", rx345_fail
    add rx345_pos, 6
    set_addr $I10, rxcap_349_fail
    ($I12, $I11) = rx345_cur."!mark_peek"($I10)
    rx345_cur."!cursor_pos"($I11)
    ($P10) = rx345_cur."!cursor_start"()
    $P10."!cursor_pass"(rx345_pos, "")
    rx345_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_349_done
  rxcap_349_fail:
    goto rx345_fail
  rxcap_349_done:
  # rx charclass s
    ge rx345_pos, rx345_eos, rx345_fail
    sub $I10, rx345_pos, rx345_off
    is_cclass $I11, 32, rx345_tgt, $I10
    unless $I11, rx345_fail
    inc rx345_pos
  # rx subrule "ws" subtype=method negate=
    rx345_cur."!cursor_pos"(rx345_pos)
    $P10 = rx345_cur."ws"()
    unless $P10, rx345_fail
    rx345_pos = $P10."pos"()
.annotate 'line', 213
  # rx subrule "xblock" subtype=capture negate=
    rx345_cur."!cursor_pos"(rx345_pos)
    $P10 = rx345_cur."xblock"()
    unless $P10, rx345_fail
    rx345_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx345_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx345_cur."!cursor_pos"(rx345_pos)
    $P10 = rx345_cur."ws"()
    unless $P10, rx345_fail
    rx345_pos = $P10."pos"()
  alt352_0:
.annotate 'line', 214
    set_addr $I10, alt352_1
    rx345_cur."!mark_push"(0, rx345_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx345_cur."!cursor_pos"(rx345_pos)
    $P10 = rx345_cur."ws"()
    unless $P10, rx345_fail
    rx345_pos = $P10."pos"()
  # rx subrule "before" subtype=zerowidth negate=1
    rx345_cur."!cursor_pos"(rx345_pos)
    .const 'Sub' $P355 = "73_1303340952.947" 
    capture_lex $P355
    $P10 = rx345_cur."before"($P355)
    if $P10, rx345_fail
  # rx subrule "ws" subtype=method negate=
    rx345_cur."!cursor_pos"(rx345_pos)
    $P10 = rx345_cur."ws"()
    unless $P10, rx345_fail
    rx345_pos = $P10."pos"()
    goto alt352_end
  alt352_1:
  # rx subrule "ws" subtype=method negate=
    rx345_cur."!cursor_pos"(rx345_pos)
    $P10 = rx345_cur."ws"()
    unless $P10, rx345_fail
    rx345_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx345_cur."!cursor_pos"(rx345_pos)
    $P10 = rx345_cur."panic"("unless does not take \"else\", please rewrite using \"if\"")
    unless $P10, rx345_fail
    rx345_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx345_cur."!cursor_pos"(rx345_pos)
    $P10 = rx345_cur."ws"()
    unless $P10, rx345_fail
    rx345_pos = $P10."pos"()
  alt352_end:
  # rx subrule "ws" subtype=method negate=
    rx345_cur."!cursor_pos"(rx345_pos)
    $P10 = rx345_cur."ws"()
    unless $P10, rx345_fail
    rx345_pos = $P10."pos"()
.annotate 'line', 211
  # rx pass
    rx345_cur."!cursor_pass"(rx345_pos, "statement_control:sym<unless>")
    if_null rx345_debug, debug_736
    rx345_cur."!cursor_debug"("PASS", "statement_control:sym<unless>", " at pos=", rx345_pos)
  debug_736:
    .return (rx345_cur)
  rx345_restart:
.annotate 'line', 10
    if_null rx345_debug, debug_737
    rx345_cur."!cursor_debug"("NEXT", "statement_control:sym<unless>")
  debug_737:
  rx345_fail:
    (rx345_rep, rx345_pos, $I10, $P10) = rx345_cur."!mark_fail"(0)
    lt rx345_pos, -1, rx345_done
    eq rx345_pos, -1, rx345_fail
    jump $I10
  rx345_done:
    rx345_cur."!cursor_fail"()
    if_null rx345_debug, debug_738
    rx345_cur."!cursor_debug"("FAIL", "statement_control:sym<unless>")
  debug_738:
    .return (rx345_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<unless>"  :nsentry("!PREFIX__statement_control:sym<unless>") :subid("72_1303340952.947") :method
.annotate 'line', 10
    new $P347, "ResizablePMCArray"
    push $P347, "unless"
    .return ($P347)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block354"  :anon :subid("73_1303340952.947") :method :outer("71_1303340952.947")
.annotate 'line', 214
    .local string rx356_tgt
    .local int rx356_pos
    .local int rx356_off
    .local int rx356_eos
    .local int rx356_rep
    .local pmc rx356_cur
    .local pmc rx356_debug
    (rx356_cur, rx356_pos, rx356_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx356_cur
    .local pmc match
    .lex "$/", match
    length rx356_eos, rx356_tgt
    gt rx356_pos, rx356_eos, rx356_done
    set rx356_off, 0
    lt rx356_pos, 2, rx356_start
    sub rx356_off, rx356_pos, 1
    substr rx356_tgt, rx356_tgt, rx356_off
  rx356_start:
    eq $I10, 1, rx356_restart
    if_null rx356_debug, debug_732
    rx356_cur."!cursor_debug"("START", "")
  debug_732:
    $I10 = self.'from'()
    ne $I10, -1, rxscan357_done
    goto rxscan357_scan
  rxscan357_loop:
    (rx356_pos) = rx356_cur."from"()
    inc rx356_pos
    rx356_cur."!cursor_from"(rx356_pos)
    ge rx356_pos, rx356_eos, rxscan357_done
  rxscan357_scan:
    set_addr $I10, rxscan357_loop
    rx356_cur."!mark_push"(0, rx356_pos, $I10)
  rxscan357_done:
  # rx literal  "else"
    add $I11, rx356_pos, 4
    gt $I11, rx356_eos, rx356_fail
    sub $I11, rx356_pos, rx356_off
    substr $S10, rx356_tgt, $I11, 4
    ne $S10, "else", rx356_fail
    add rx356_pos, 4
  # rx pass
    rx356_cur."!cursor_pass"(rx356_pos, "")
    if_null rx356_debug, debug_733
    rx356_cur."!cursor_debug"("PASS", "", " at pos=", rx356_pos)
  debug_733:
    .return (rx356_cur)
  rx356_restart:
    if_null rx356_debug, debug_734
    rx356_cur."!cursor_debug"("NEXT", "")
  debug_734:
  rx356_fail:
    (rx356_rep, rx356_pos, $I10, $P10) = rx356_cur."!mark_fail"(0)
    lt rx356_pos, -1, rx356_done
    eq rx356_pos, -1, rx356_fail
    jump $I10
  rx356_done:
    rx356_cur."!cursor_fail"()
    if_null rx356_debug, debug_735
    rx356_cur."!cursor_debug"("FAIL", "")
  debug_735:
    .return (rx356_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<while>"  :subid("74_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx363_tgt
    .local int rx363_pos
    .local int rx363_off
    .local int rx363_eos
    .local int rx363_rep
    .local pmc rx363_cur
    .local pmc rx363_debug
    (rx363_cur, rx363_pos, rx363_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx363_cur
    .local pmc match
    .lex "$/", match
    length rx363_eos, rx363_tgt
    gt rx363_pos, rx363_eos, rx363_done
    set rx363_off, 0
    lt rx363_pos, 2, rx363_start
    sub rx363_off, rx363_pos, 1
    substr rx363_tgt, rx363_tgt, rx363_off
  rx363_start:
    eq $I10, 1, rx363_restart
    if_null rx363_debug, debug_739
    rx363_cur."!cursor_debug"("START", "statement_control:sym<while>")
  debug_739:
    $I10 = self.'from'()
    ne $I10, -1, rxscan366_done
    goto rxscan366_scan
  rxscan366_loop:
    (rx363_pos) = rx363_cur."from"()
    inc rx363_pos
    rx363_cur."!cursor_from"(rx363_pos)
    ge rx363_pos, rx363_eos, rxscan366_done
  rxscan366_scan:
    set_addr $I10, rxscan366_loop
    rx363_cur."!mark_push"(0, rx363_pos, $I10)
  rxscan366_done:
.annotate 'line', 218
  # rx subcapture "sym"
    set_addr $I10, rxcap_368_fail
    rx363_cur."!mark_push"(0, rx363_pos, $I10)
  alt367_0:
    set_addr $I10, alt367_1
    rx363_cur."!mark_push"(0, rx363_pos, $I10)
  # rx literal  "while"
    add $I11, rx363_pos, 5
    gt $I11, rx363_eos, rx363_fail
    sub $I11, rx363_pos, rx363_off
    substr $S10, rx363_tgt, $I11, 5
    ne $S10, "while", rx363_fail
    add rx363_pos, 5
    goto alt367_end
  alt367_1:
  # rx literal  "until"
    add $I11, rx363_pos, 5
    gt $I11, rx363_eos, rx363_fail
    sub $I11, rx363_pos, rx363_off
    substr $S10, rx363_tgt, $I11, 5
    ne $S10, "until", rx363_fail
    add rx363_pos, 5
  alt367_end:
    set_addr $I10, rxcap_368_fail
    ($I12, $I11) = rx363_cur."!mark_peek"($I10)
    rx363_cur."!cursor_pos"($I11)
    ($P10) = rx363_cur."!cursor_start"()
    $P10."!cursor_pass"(rx363_pos, "")
    rx363_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_368_done
  rxcap_368_fail:
    goto rx363_fail
  rxcap_368_done:
  # rx charclass s
    ge rx363_pos, rx363_eos, rx363_fail
    sub $I10, rx363_pos, rx363_off
    is_cclass $I11, 32, rx363_tgt, $I10
    unless $I11, rx363_fail
    inc rx363_pos
  # rx subrule "ws" subtype=method negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."ws"()
    unless $P10, rx363_fail
    rx363_pos = $P10."pos"()
.annotate 'line', 219
  # rx subrule "xblock" subtype=capture negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."xblock"()
    unless $P10, rx363_fail
    rx363_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx363_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."ws"()
    unless $P10, rx363_fail
    rx363_pos = $P10."pos"()
.annotate 'line', 217
  # rx pass
    rx363_cur."!cursor_pass"(rx363_pos, "statement_control:sym<while>")
    if_null rx363_debug, debug_740
    rx363_cur."!cursor_debug"("PASS", "statement_control:sym<while>", " at pos=", rx363_pos)
  debug_740:
    .return (rx363_cur)
  rx363_restart:
.annotate 'line', 10
    if_null rx363_debug, debug_741
    rx363_cur."!cursor_debug"("NEXT", "statement_control:sym<while>")
  debug_741:
  rx363_fail:
    (rx363_rep, rx363_pos, $I10, $P10) = rx363_cur."!mark_fail"(0)
    lt rx363_pos, -1, rx363_done
    eq rx363_pos, -1, rx363_fail
    jump $I10
  rx363_done:
    rx363_cur."!cursor_fail"()
    if_null rx363_debug, debug_742
    rx363_cur."!cursor_debug"("FAIL", "statement_control:sym<while>")
  debug_742:
    .return (rx363_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<while>"  :nsentry("!PREFIX__statement_control:sym<while>") :subid("75_1303340952.947") :method
.annotate 'line', 10
    new $P365, "ResizablePMCArray"
    push $P365, "until"
    push $P365, "while"
    .return ($P365)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<repeat>"  :subid("76_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx372_tgt
    .local int rx372_pos
    .local int rx372_off
    .local int rx372_eos
    .local int rx372_rep
    .local pmc rx372_cur
    .local pmc rx372_debug
    (rx372_cur, rx372_pos, rx372_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx372_cur
    .local pmc match
    .lex "$/", match
    length rx372_eos, rx372_tgt
    gt rx372_pos, rx372_eos, rx372_done
    set rx372_off, 0
    lt rx372_pos, 2, rx372_start
    sub rx372_off, rx372_pos, 1
    substr rx372_tgt, rx372_tgt, rx372_off
  rx372_start:
    eq $I10, 1, rx372_restart
    if_null rx372_debug, debug_743
    rx372_cur."!cursor_debug"("START", "statement_control:sym<repeat>")
  debug_743:
    $I10 = self.'from'()
    ne $I10, -1, rxscan375_done
    goto rxscan375_scan
  rxscan375_loop:
    (rx372_pos) = rx372_cur."from"()
    inc rx372_pos
    rx372_cur."!cursor_from"(rx372_pos)
    ge rx372_pos, rx372_eos, rxscan375_done
  rxscan375_scan:
    set_addr $I10, rxscan375_loop
    rx372_cur."!mark_push"(0, rx372_pos, $I10)
  rxscan375_done:
.annotate 'line', 223
  # rx subcapture "sym"
    set_addr $I10, rxcap_376_fail
    rx372_cur."!mark_push"(0, rx372_pos, $I10)
  # rx literal  "repeat"
    add $I11, rx372_pos, 6
    gt $I11, rx372_eos, rx372_fail
    sub $I11, rx372_pos, rx372_off
    substr $S10, rx372_tgt, $I11, 6
    ne $S10, "repeat", rx372_fail
    add rx372_pos, 6
    set_addr $I10, rxcap_376_fail
    ($I12, $I11) = rx372_cur."!mark_peek"($I10)
    rx372_cur."!cursor_pos"($I11)
    ($P10) = rx372_cur."!cursor_start"()
    $P10."!cursor_pass"(rx372_pos, "")
    rx372_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_376_done
  rxcap_376_fail:
    goto rx372_fail
  rxcap_376_done:
  # rx charclass s
    ge rx372_pos, rx372_eos, rx372_fail
    sub $I10, rx372_pos, rx372_off
    is_cclass $I11, 32, rx372_tgt, $I10
    unless $I11, rx372_fail
    inc rx372_pos
  # rx subrule "ws" subtype=method negate=
    rx372_cur."!cursor_pos"(rx372_pos)
    $P10 = rx372_cur."ws"()
    unless $P10, rx372_fail
    rx372_pos = $P10."pos"()
  alt378_0:
.annotate 'line', 224
    set_addr $I10, alt378_1
    rx372_cur."!mark_push"(0, rx372_pos, $I10)
.annotate 'line', 225
  # rx subrule "ws" subtype=method negate=
    rx372_cur."!cursor_pos"(rx372_pos)
    $P10 = rx372_cur."ws"()
    unless $P10, rx372_fail
    rx372_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_381_fail
    rx372_cur."!mark_push"(0, rx372_pos, $I10)
  alt380_0:
    set_addr $I10, alt380_1
    rx372_cur."!mark_push"(0, rx372_pos, $I10)
  # rx literal  "while"
    add $I11, rx372_pos, 5
    gt $I11, rx372_eos, rx372_fail
    sub $I11, rx372_pos, rx372_off
    substr $S10, rx372_tgt, $I11, 5
    ne $S10, "while", rx372_fail
    add rx372_pos, 5
    goto alt380_end
  alt380_1:
  # rx literal  "until"
    add $I11, rx372_pos, 5
    gt $I11, rx372_eos, rx372_fail
    sub $I11, rx372_pos, rx372_off
    substr $S10, rx372_tgt, $I11, 5
    ne $S10, "until", rx372_fail
    add rx372_pos, 5
  alt380_end:
    set_addr $I10, rxcap_381_fail
    ($I12, $I11) = rx372_cur."!mark_peek"($I10)
    rx372_cur."!cursor_pos"($I11)
    ($P10) = rx372_cur."!cursor_start"()
    $P10."!cursor_pass"(rx372_pos, "")
    rx372_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_381_done
  rxcap_381_fail:
    goto rx372_fail
  rxcap_381_done:
  # rx charclass s
    ge rx372_pos, rx372_eos, rx372_fail
    sub $I10, rx372_pos, rx372_off
    is_cclass $I11, 32, rx372_tgt, $I10
    unless $I11, rx372_fail
    inc rx372_pos
  # rx subrule "ws" subtype=method negate=
    rx372_cur."!cursor_pos"(rx372_pos)
    $P10 = rx372_cur."ws"()
    unless $P10, rx372_fail
    rx372_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx372_cur."!cursor_pos"(rx372_pos)
    $P10 = rx372_cur."xblock"()
    unless $P10, rx372_fail
    rx372_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx372_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx372_cur."!cursor_pos"(rx372_pos)
    $P10 = rx372_cur."ws"()
    unless $P10, rx372_fail
    rx372_pos = $P10."pos"()
    goto alt378_end
  alt378_1:
.annotate 'line', 226
  # rx subrule "ws" subtype=method negate=
    rx372_cur."!cursor_pos"(rx372_pos)
    $P10 = rx372_cur."ws"()
    unless $P10, rx372_fail
    rx372_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx372_cur."!cursor_pos"(rx372_pos)
    $P10 = rx372_cur."pblock"()
    unless $P10, rx372_fail
    rx372_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx372_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx372_cur."!cursor_pos"(rx372_pos)
    $P10 = rx372_cur."ws"()
    unless $P10, rx372_fail
    rx372_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_387_fail
    rx372_cur."!mark_push"(0, rx372_pos, $I10)
  alt386_0:
    set_addr $I10, alt386_1
    rx372_cur."!mark_push"(0, rx372_pos, $I10)
  # rx literal  "while"
    add $I11, rx372_pos, 5
    gt $I11, rx372_eos, rx372_fail
    sub $I11, rx372_pos, rx372_off
    substr $S10, rx372_tgt, $I11, 5
    ne $S10, "while", rx372_fail
    add rx372_pos, 5
    goto alt386_end
  alt386_1:
  # rx literal  "until"
    add $I11, rx372_pos, 5
    gt $I11, rx372_eos, rx372_fail
    sub $I11, rx372_pos, rx372_off
    substr $S10, rx372_tgt, $I11, 5
    ne $S10, "until", rx372_fail
    add rx372_pos, 5
  alt386_end:
    set_addr $I10, rxcap_387_fail
    ($I12, $I11) = rx372_cur."!mark_peek"($I10)
    rx372_cur."!cursor_pos"($I11)
    ($P10) = rx372_cur."!cursor_start"()
    $P10."!cursor_pass"(rx372_pos, "")
    rx372_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_387_done
  rxcap_387_fail:
    goto rx372_fail
  rxcap_387_done:
  # rx charclass s
    ge rx372_pos, rx372_eos, rx372_fail
    sub $I10, rx372_pos, rx372_off
    is_cclass $I11, 32, rx372_tgt, $I10
    unless $I11, rx372_fail
    inc rx372_pos
  # rx subrule "ws" subtype=method negate=
    rx372_cur."!cursor_pos"(rx372_pos)
    $P10 = rx372_cur."ws"()
    unless $P10, rx372_fail
    rx372_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx372_cur."!cursor_pos"(rx372_pos)
    $P10 = rx372_cur."EXPR"()
    unless $P10, rx372_fail
    rx372_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx372_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx372_cur."!cursor_pos"(rx372_pos)
    $P10 = rx372_cur."ws"()
    unless $P10, rx372_fail
    rx372_pos = $P10."pos"()
  alt378_end:
.annotate 'line', 227
  # rx subrule "ws" subtype=method negate=
    rx372_cur."!cursor_pos"(rx372_pos)
    $P10 = rx372_cur."ws"()
    unless $P10, rx372_fail
    rx372_pos = $P10."pos"()
.annotate 'line', 222
  # rx pass
    rx372_cur."!cursor_pass"(rx372_pos, "statement_control:sym<repeat>")
    if_null rx372_debug, debug_744
    rx372_cur."!cursor_debug"("PASS", "statement_control:sym<repeat>", " at pos=", rx372_pos)
  debug_744:
    .return (rx372_cur)
  rx372_restart:
.annotate 'line', 10
    if_null rx372_debug, debug_745
    rx372_cur."!cursor_debug"("NEXT", "statement_control:sym<repeat>")
  debug_745:
  rx372_fail:
    (rx372_rep, rx372_pos, $I10, $P10) = rx372_cur."!mark_fail"(0)
    lt rx372_pos, -1, rx372_done
    eq rx372_pos, -1, rx372_fail
    jump $I10
  rx372_done:
    rx372_cur."!cursor_fail"()
    if_null rx372_debug, debug_746
    rx372_cur."!cursor_debug"("FAIL", "statement_control:sym<repeat>")
  debug_746:
    .return (rx372_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<repeat>"  :nsentry("!PREFIX__statement_control:sym<repeat>") :subid("77_1303340952.947") :method
.annotate 'line', 10
    new $P374, "ResizablePMCArray"
    push $P374, "repeat"
    .return ($P374)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<for>"  :subid("78_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx392_tgt
    .local int rx392_pos
    .local int rx392_off
    .local int rx392_eos
    .local int rx392_rep
    .local pmc rx392_cur
    .local pmc rx392_debug
    (rx392_cur, rx392_pos, rx392_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx392_cur
    .local pmc match
    .lex "$/", match
    length rx392_eos, rx392_tgt
    gt rx392_pos, rx392_eos, rx392_done
    set rx392_off, 0
    lt rx392_pos, 2, rx392_start
    sub rx392_off, rx392_pos, 1
    substr rx392_tgt, rx392_tgt, rx392_off
  rx392_start:
    eq $I10, 1, rx392_restart
    if_null rx392_debug, debug_747
    rx392_cur."!cursor_debug"("START", "statement_control:sym<for>")
  debug_747:
    $I10 = self.'from'()
    ne $I10, -1, rxscan395_done
    goto rxscan395_scan
  rxscan395_loop:
    (rx392_pos) = rx392_cur."from"()
    inc rx392_pos
    rx392_cur."!cursor_from"(rx392_pos)
    ge rx392_pos, rx392_eos, rxscan395_done
  rxscan395_scan:
    set_addr $I10, rxscan395_loop
    rx392_cur."!mark_push"(0, rx392_pos, $I10)
  rxscan395_done:
.annotate 'line', 231
  # rx subcapture "sym"
    set_addr $I10, rxcap_396_fail
    rx392_cur."!mark_push"(0, rx392_pos, $I10)
  # rx literal  "for"
    add $I11, rx392_pos, 3
    gt $I11, rx392_eos, rx392_fail
    sub $I11, rx392_pos, rx392_off
    substr $S10, rx392_tgt, $I11, 3
    ne $S10, "for", rx392_fail
    add rx392_pos, 3
    set_addr $I10, rxcap_396_fail
    ($I12, $I11) = rx392_cur."!mark_peek"($I10)
    rx392_cur."!cursor_pos"($I11)
    ($P10) = rx392_cur."!cursor_start"()
    $P10."!cursor_pass"(rx392_pos, "")
    rx392_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_396_done
  rxcap_396_fail:
    goto rx392_fail
  rxcap_396_done:
  # rx charclass s
    ge rx392_pos, rx392_eos, rx392_fail
    sub $I10, rx392_pos, rx392_off
    is_cclass $I11, 32, rx392_tgt, $I10
    unless $I11, rx392_fail
    inc rx392_pos
  # rx subrule "ws" subtype=method negate=
    rx392_cur."!cursor_pos"(rx392_pos)
    $P10 = rx392_cur."ws"()
    unless $P10, rx392_fail
    rx392_pos = $P10."pos"()
.annotate 'line', 232
  # rx subrule "xblock" subtype=capture negate=
    rx392_cur."!cursor_pos"(rx392_pos)
    $P10 = rx392_cur."xblock"()
    unless $P10, rx392_fail
    rx392_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx392_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx392_cur."!cursor_pos"(rx392_pos)
    $P10 = rx392_cur."ws"()
    unless $P10, rx392_fail
    rx392_pos = $P10."pos"()
.annotate 'line', 230
  # rx pass
    rx392_cur."!cursor_pass"(rx392_pos, "statement_control:sym<for>")
    if_null rx392_debug, debug_748
    rx392_cur."!cursor_debug"("PASS", "statement_control:sym<for>", " at pos=", rx392_pos)
  debug_748:
    .return (rx392_cur)
  rx392_restart:
.annotate 'line', 10
    if_null rx392_debug, debug_749
    rx392_cur."!cursor_debug"("NEXT", "statement_control:sym<for>")
  debug_749:
  rx392_fail:
    (rx392_rep, rx392_pos, $I10, $P10) = rx392_cur."!mark_fail"(0)
    lt rx392_pos, -1, rx392_done
    eq rx392_pos, -1, rx392_fail
    jump $I10
  rx392_done:
    rx392_cur."!cursor_fail"()
    if_null rx392_debug, debug_750
    rx392_cur."!cursor_debug"("FAIL", "statement_control:sym<for>")
  debug_750:
    .return (rx392_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<for>"  :nsentry("!PREFIX__statement_control:sym<for>") :subid("79_1303340952.947") :method
.annotate 'line', 10
    new $P394, "ResizablePMCArray"
    push $P394, "for"
    .return ($P394)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CATCH>"  :subid("80_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx400_tgt
    .local int rx400_pos
    .local int rx400_off
    .local int rx400_eos
    .local int rx400_rep
    .local pmc rx400_cur
    .local pmc rx400_debug
    (rx400_cur, rx400_pos, rx400_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx400_cur
    .local pmc match
    .lex "$/", match
    length rx400_eos, rx400_tgt
    gt rx400_pos, rx400_eos, rx400_done
    set rx400_off, 0
    lt rx400_pos, 2, rx400_start
    sub rx400_off, rx400_pos, 1
    substr rx400_tgt, rx400_tgt, rx400_off
  rx400_start:
    eq $I10, 1, rx400_restart
    if_null rx400_debug, debug_751
    rx400_cur."!cursor_debug"("START", "statement_control:sym<CATCH>")
  debug_751:
    $I10 = self.'from'()
    ne $I10, -1, rxscan403_done
    goto rxscan403_scan
  rxscan403_loop:
    (rx400_pos) = rx400_cur."from"()
    inc rx400_pos
    rx400_cur."!cursor_from"(rx400_pos)
    ge rx400_pos, rx400_eos, rxscan403_done
  rxscan403_scan:
    set_addr $I10, rxscan403_loop
    rx400_cur."!mark_push"(0, rx400_pos, $I10)
  rxscan403_done:
.annotate 'line', 236
  # rx subcapture "sym"
    set_addr $I10, rxcap_404_fail
    rx400_cur."!mark_push"(0, rx400_pos, $I10)
  # rx literal  "CATCH"
    add $I11, rx400_pos, 5
    gt $I11, rx400_eos, rx400_fail
    sub $I11, rx400_pos, rx400_off
    substr $S10, rx400_tgt, $I11, 5
    ne $S10, "CATCH", rx400_fail
    add rx400_pos, 5
    set_addr $I10, rxcap_404_fail
    ($I12, $I11) = rx400_cur."!mark_peek"($I10)
    rx400_cur."!cursor_pos"($I11)
    ($P10) = rx400_cur."!cursor_start"()
    $P10."!cursor_pass"(rx400_pos, "")
    rx400_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_404_done
  rxcap_404_fail:
    goto rx400_fail
  rxcap_404_done:
  # rx charclass s
    ge rx400_pos, rx400_eos, rx400_fail
    sub $I10, rx400_pos, rx400_off
    is_cclass $I11, 32, rx400_tgt, $I10
    unless $I11, rx400_fail
    inc rx400_pos
  # rx subrule "ws" subtype=method negate=
    rx400_cur."!cursor_pos"(rx400_pos)
    $P10 = rx400_cur."ws"()
    unless $P10, rx400_fail
    rx400_pos = $P10."pos"()
.annotate 'line', 237
  # rx subrule "block" subtype=capture negate=
    rx400_cur."!cursor_pos"(rx400_pos)
    $P10 = rx400_cur."block"()
    unless $P10, rx400_fail
    rx400_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx400_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx400_cur."!cursor_pos"(rx400_pos)
    $P10 = rx400_cur."ws"()
    unless $P10, rx400_fail
    rx400_pos = $P10."pos"()
.annotate 'line', 235
  # rx pass
    rx400_cur."!cursor_pass"(rx400_pos, "statement_control:sym<CATCH>")
    if_null rx400_debug, debug_752
    rx400_cur."!cursor_debug"("PASS", "statement_control:sym<CATCH>", " at pos=", rx400_pos)
  debug_752:
    .return (rx400_cur)
  rx400_restart:
.annotate 'line', 10
    if_null rx400_debug, debug_753
    rx400_cur."!cursor_debug"("NEXT", "statement_control:sym<CATCH>")
  debug_753:
  rx400_fail:
    (rx400_rep, rx400_pos, $I10, $P10) = rx400_cur."!mark_fail"(0)
    lt rx400_pos, -1, rx400_done
    eq rx400_pos, -1, rx400_fail
    jump $I10
  rx400_done:
    rx400_cur."!cursor_fail"()
    if_null rx400_debug, debug_754
    rx400_cur."!cursor_debug"("FAIL", "statement_control:sym<CATCH>")
  debug_754:
    .return (rx400_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CATCH>"  :nsentry("!PREFIX__statement_control:sym<CATCH>") :subid("81_1303340952.947") :method
.annotate 'line', 10
    new $P402, "ResizablePMCArray"
    push $P402, "CATCH"
    .return ($P402)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CONTROL>"  :subid("82_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx408_tgt
    .local int rx408_pos
    .local int rx408_off
    .local int rx408_eos
    .local int rx408_rep
    .local pmc rx408_cur
    .local pmc rx408_debug
    (rx408_cur, rx408_pos, rx408_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx408_cur
    .local pmc match
    .lex "$/", match
    length rx408_eos, rx408_tgt
    gt rx408_pos, rx408_eos, rx408_done
    set rx408_off, 0
    lt rx408_pos, 2, rx408_start
    sub rx408_off, rx408_pos, 1
    substr rx408_tgt, rx408_tgt, rx408_off
  rx408_start:
    eq $I10, 1, rx408_restart
    if_null rx408_debug, debug_755
    rx408_cur."!cursor_debug"("START", "statement_control:sym<CONTROL>")
  debug_755:
    $I10 = self.'from'()
    ne $I10, -1, rxscan411_done
    goto rxscan411_scan
  rxscan411_loop:
    (rx408_pos) = rx408_cur."from"()
    inc rx408_pos
    rx408_cur."!cursor_from"(rx408_pos)
    ge rx408_pos, rx408_eos, rxscan411_done
  rxscan411_scan:
    set_addr $I10, rxscan411_loop
    rx408_cur."!mark_push"(0, rx408_pos, $I10)
  rxscan411_done:
.annotate 'line', 241
  # rx subcapture "sym"
    set_addr $I10, rxcap_412_fail
    rx408_cur."!mark_push"(0, rx408_pos, $I10)
  # rx literal  "CONTROL"
    add $I11, rx408_pos, 7
    gt $I11, rx408_eos, rx408_fail
    sub $I11, rx408_pos, rx408_off
    substr $S10, rx408_tgt, $I11, 7
    ne $S10, "CONTROL", rx408_fail
    add rx408_pos, 7
    set_addr $I10, rxcap_412_fail
    ($I12, $I11) = rx408_cur."!mark_peek"($I10)
    rx408_cur."!cursor_pos"($I11)
    ($P10) = rx408_cur."!cursor_start"()
    $P10."!cursor_pass"(rx408_pos, "")
    rx408_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_412_done
  rxcap_412_fail:
    goto rx408_fail
  rxcap_412_done:
  # rx charclass s
    ge rx408_pos, rx408_eos, rx408_fail
    sub $I10, rx408_pos, rx408_off
    is_cclass $I11, 32, rx408_tgt, $I10
    unless $I11, rx408_fail
    inc rx408_pos
  # rx subrule "ws" subtype=method negate=
    rx408_cur."!cursor_pos"(rx408_pos)
    $P10 = rx408_cur."ws"()
    unless $P10, rx408_fail
    rx408_pos = $P10."pos"()
.annotate 'line', 242
  # rx subrule "block" subtype=capture negate=
    rx408_cur."!cursor_pos"(rx408_pos)
    $P10 = rx408_cur."block"()
    unless $P10, rx408_fail
    rx408_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx408_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx408_cur."!cursor_pos"(rx408_pos)
    $P10 = rx408_cur."ws"()
    unless $P10, rx408_fail
    rx408_pos = $P10."pos"()
.annotate 'line', 240
  # rx pass
    rx408_cur."!cursor_pass"(rx408_pos, "statement_control:sym<CONTROL>")
    if_null rx408_debug, debug_756
    rx408_cur."!cursor_debug"("PASS", "statement_control:sym<CONTROL>", " at pos=", rx408_pos)
  debug_756:
    .return (rx408_cur)
  rx408_restart:
.annotate 'line', 10
    if_null rx408_debug, debug_757
    rx408_cur."!cursor_debug"("NEXT", "statement_control:sym<CONTROL>")
  debug_757:
  rx408_fail:
    (rx408_rep, rx408_pos, $I10, $P10) = rx408_cur."!mark_fail"(0)
    lt rx408_pos, -1, rx408_done
    eq rx408_pos, -1, rx408_fail
    jump $I10
  rx408_done:
    rx408_cur."!cursor_fail"()
    if_null rx408_debug, debug_758
    rx408_cur."!cursor_debug"("FAIL", "statement_control:sym<CONTROL>")
  debug_758:
    .return (rx408_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CONTROL>"  :nsentry("!PREFIX__statement_control:sym<CONTROL>") :subid("83_1303340952.947") :method
.annotate 'line', 10
    new $P410, "ResizablePMCArray"
    push $P410, "CONTROL"
    .return ($P410)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix"  :subid("84_1303340952.947")
    .param pmc param_416
.annotate 'line', 245
    .lex "self", param_416
    $P417 = param_416."!protoregex"("statement_prefix")
    .return ($P417)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix"  :subid("85_1303340952.947")
    .param pmc param_419
.annotate 'line', 245
    .lex "self", param_419
    $P420 = param_419."!PREFIX__!protoregex"("statement_prefix")
    .return ($P420)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<INIT>"  :subid("86_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx422_tgt
    .local int rx422_pos
    .local int rx422_off
    .local int rx422_eos
    .local int rx422_rep
    .local pmc rx422_cur
    .local pmc rx422_debug
    (rx422_cur, rx422_pos, rx422_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx422_cur
    .local pmc match
    .lex "$/", match
    length rx422_eos, rx422_tgt
    gt rx422_pos, rx422_eos, rx422_done
    set rx422_off, 0
    lt rx422_pos, 2, rx422_start
    sub rx422_off, rx422_pos, 1
    substr rx422_tgt, rx422_tgt, rx422_off
  rx422_start:
    eq $I10, 1, rx422_restart
    if_null rx422_debug, debug_759
    rx422_cur."!cursor_debug"("START", "statement_prefix:sym<INIT>")
  debug_759:
    $I10 = self.'from'()
    ne $I10, -1, rxscan426_done
    goto rxscan426_scan
  rxscan426_loop:
    (rx422_pos) = rx422_cur."from"()
    inc rx422_pos
    rx422_cur."!cursor_from"(rx422_pos)
    ge rx422_pos, rx422_eos, rxscan426_done
  rxscan426_scan:
    set_addr $I10, rxscan426_loop
    rx422_cur."!mark_push"(0, rx422_pos, $I10)
  rxscan426_done:
.annotate 'line', 246
  # rx subcapture "sym"
    set_addr $I10, rxcap_427_fail
    rx422_cur."!mark_push"(0, rx422_pos, $I10)
  # rx literal  "INIT"
    add $I11, rx422_pos, 4
    gt $I11, rx422_eos, rx422_fail
    sub $I11, rx422_pos, rx422_off
    substr $S10, rx422_tgt, $I11, 4
    ne $S10, "INIT", rx422_fail
    add rx422_pos, 4
    set_addr $I10, rxcap_427_fail
    ($I12, $I11) = rx422_cur."!mark_peek"($I10)
    rx422_cur."!cursor_pos"($I11)
    ($P10) = rx422_cur."!cursor_start"()
    $P10."!cursor_pass"(rx422_pos, "")
    rx422_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_427_done
  rxcap_427_fail:
    goto rx422_fail
  rxcap_427_done:
  # rx subrule "blorst" subtype=capture negate=
    rx422_cur."!cursor_pos"(rx422_pos)
    $P10 = rx422_cur."blorst"()
    unless $P10, rx422_fail
    rx422_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx422_pos = $P10."pos"()
  # rx pass
    rx422_cur."!cursor_pass"(rx422_pos, "statement_prefix:sym<INIT>")
    if_null rx422_debug, debug_760
    rx422_cur."!cursor_debug"("PASS", "statement_prefix:sym<INIT>", " at pos=", rx422_pos)
  debug_760:
    .return (rx422_cur)
  rx422_restart:
.annotate 'line', 10
    if_null rx422_debug, debug_761
    rx422_cur."!cursor_debug"("NEXT", "statement_prefix:sym<INIT>")
  debug_761:
  rx422_fail:
    (rx422_rep, rx422_pos, $I10, $P10) = rx422_cur."!mark_fail"(0)
    lt rx422_pos, -1, rx422_done
    eq rx422_pos, -1, rx422_fail
    jump $I10
  rx422_done:
    rx422_cur."!cursor_fail"()
    if_null rx422_debug, debug_762
    rx422_cur."!cursor_debug"("FAIL", "statement_prefix:sym<INIT>")
  debug_762:
    .return (rx422_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<INIT>"  :nsentry("!PREFIX__statement_prefix:sym<INIT>") :subid("87_1303340952.947") :method
.annotate 'line', 10
    $P424 = self."!PREFIX__!subrule"("blorst", "INIT")
    new $P425, "ResizablePMCArray"
    push $P425, $P424
    .return ($P425)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<try>"  :subid("88_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx429_tgt
    .local int rx429_pos
    .local int rx429_off
    .local int rx429_eos
    .local int rx429_rep
    .local pmc rx429_cur
    .local pmc rx429_debug
    (rx429_cur, rx429_pos, rx429_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx429_cur
    .local pmc match
    .lex "$/", match
    length rx429_eos, rx429_tgt
    gt rx429_pos, rx429_eos, rx429_done
    set rx429_off, 0
    lt rx429_pos, 2, rx429_start
    sub rx429_off, rx429_pos, 1
    substr rx429_tgt, rx429_tgt, rx429_off
  rx429_start:
    eq $I10, 1, rx429_restart
    if_null rx429_debug, debug_763
    rx429_cur."!cursor_debug"("START", "statement_prefix:sym<try>")
  debug_763:
    $I10 = self.'from'()
    ne $I10, -1, rxscan433_done
    goto rxscan433_scan
  rxscan433_loop:
    (rx429_pos) = rx429_cur."from"()
    inc rx429_pos
    rx429_cur."!cursor_from"(rx429_pos)
    ge rx429_pos, rx429_eos, rxscan433_done
  rxscan433_scan:
    set_addr $I10, rxscan433_loop
    rx429_cur."!mark_push"(0, rx429_pos, $I10)
  rxscan433_done:
.annotate 'line', 249
  # rx subcapture "sym"
    set_addr $I10, rxcap_434_fail
    rx429_cur."!mark_push"(0, rx429_pos, $I10)
  # rx literal  "try"
    add $I11, rx429_pos, 3
    gt $I11, rx429_eos, rx429_fail
    sub $I11, rx429_pos, rx429_off
    substr $S10, rx429_tgt, $I11, 3
    ne $S10, "try", rx429_fail
    add rx429_pos, 3
    set_addr $I10, rxcap_434_fail
    ($I12, $I11) = rx429_cur."!mark_peek"($I10)
    rx429_cur."!cursor_pos"($I11)
    ($P10) = rx429_cur."!cursor_start"()
    $P10."!cursor_pass"(rx429_pos, "")
    rx429_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_434_done
  rxcap_434_fail:
    goto rx429_fail
  rxcap_434_done:
.annotate 'line', 250
  # rx subrule "blorst" subtype=capture negate=
    rx429_cur."!cursor_pos"(rx429_pos)
    $P10 = rx429_cur."blorst"()
    unless $P10, rx429_fail
    rx429_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx429_pos = $P10."pos"()
.annotate 'line', 248
  # rx pass
    rx429_cur."!cursor_pass"(rx429_pos, "statement_prefix:sym<try>")
    if_null rx429_debug, debug_764
    rx429_cur."!cursor_debug"("PASS", "statement_prefix:sym<try>", " at pos=", rx429_pos)
  debug_764:
    .return (rx429_cur)
  rx429_restart:
.annotate 'line', 10
    if_null rx429_debug, debug_765
    rx429_cur."!cursor_debug"("NEXT", "statement_prefix:sym<try>")
  debug_765:
  rx429_fail:
    (rx429_rep, rx429_pos, $I10, $P10) = rx429_cur."!mark_fail"(0)
    lt rx429_pos, -1, rx429_done
    eq rx429_pos, -1, rx429_fail
    jump $I10
  rx429_done:
    rx429_cur."!cursor_fail"()
    if_null rx429_debug, debug_766
    rx429_cur."!cursor_debug"("FAIL", "statement_prefix:sym<try>")
  debug_766:
    .return (rx429_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<try>"  :nsentry("!PREFIX__statement_prefix:sym<try>") :subid("89_1303340952.947") :method
.annotate 'line', 10
    $P431 = self."!PREFIX__!subrule"("blorst", "try")
    new $P432, "ResizablePMCArray"
    push $P432, $P431
    .return ($P432)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blorst"  :subid("90_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx436_tgt
    .local int rx436_pos
    .local int rx436_off
    .local int rx436_eos
    .local int rx436_rep
    .local pmc rx436_cur
    .local pmc rx436_debug
    (rx436_cur, rx436_pos, rx436_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx436_cur
    .local pmc match
    .lex "$/", match
    length rx436_eos, rx436_tgt
    gt rx436_pos, rx436_eos, rx436_done
    set rx436_off, 0
    lt rx436_pos, 2, rx436_start
    sub rx436_off, rx436_pos, 1
    substr rx436_tgt, rx436_tgt, rx436_off
  rx436_start:
    eq $I10, 1, rx436_restart
    if_null rx436_debug, debug_767
    rx436_cur."!cursor_debug"("START", "blorst")
  debug_767:
    $I10 = self.'from'()
    ne $I10, -1, rxscan439_done
    goto rxscan439_scan
  rxscan439_loop:
    (rx436_pos) = rx436_cur."from"()
    inc rx436_pos
    rx436_cur."!cursor_from"(rx436_pos)
    ge rx436_pos, rx436_eos, rxscan439_done
  rxscan439_scan:
    set_addr $I10, rxscan439_loop
    rx436_cur."!mark_push"(0, rx436_pos, $I10)
  rxscan439_done:
.annotate 'line', 254
  # rx charclass s
    ge rx436_pos, rx436_eos, rx436_fail
    sub $I10, rx436_pos, rx436_off
    is_cclass $I11, 32, rx436_tgt, $I10
    unless $I11, rx436_fail
    inc rx436_pos
  # rx subrule "ws" subtype=method negate=
    rx436_cur."!cursor_pos"(rx436_pos)
    $P10 = rx436_cur."ws"()
    unless $P10, rx436_fail
    rx436_pos = $P10."pos"()
  alt440_0:
    set_addr $I10, alt440_1
    rx436_cur."!mark_push"(0, rx436_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx436_pos, rx436_off
    substr $S10, rx436_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx436_fail
  # rx subrule "block" subtype=capture negate=
    rx436_cur."!cursor_pos"(rx436_pos)
    $P10 = rx436_cur."block"()
    unless $P10, rx436_fail
    rx436_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx436_pos = $P10."pos"()
    goto alt440_end
  alt440_1:
  # rx subrule "statement" subtype=capture negate=
    rx436_cur."!cursor_pos"(rx436_pos)
    $P10 = rx436_cur."statement"()
    unless $P10, rx436_fail
    rx436_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx436_pos = $P10."pos"()
  alt440_end:
.annotate 'line', 253
  # rx pass
    rx436_cur."!cursor_pass"(rx436_pos, "blorst")
    if_null rx436_debug, debug_768
    rx436_cur."!cursor_debug"("PASS", "blorst", " at pos=", rx436_pos)
  debug_768:
    .return (rx436_cur)
  rx436_restart:
.annotate 'line', 10
    if_null rx436_debug, debug_769
    rx436_cur."!cursor_debug"("NEXT", "blorst")
  debug_769:
  rx436_fail:
    (rx436_rep, rx436_pos, $I10, $P10) = rx436_cur."!mark_fail"(0)
    lt rx436_pos, -1, rx436_done
    eq rx436_pos, -1, rx436_fail
    jump $I10
  rx436_done:
    rx436_cur."!cursor_fail"()
    if_null rx436_debug, debug_770
    rx436_cur."!cursor_debug"("FAIL", "blorst")
  debug_770:
    .return (rx436_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blorst"  :nsentry("!PREFIX__blorst") :subid("91_1303340952.947") :method
.annotate 'line', 10
    new $P438, "ResizablePMCArray"
    push $P438, ""
    .return ($P438)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond"  :subid("92_1303340952.947")
    .param pmc param_442
.annotate 'line', 259
    .lex "self", param_442
    $P443 = param_442."!protoregex"("statement_mod_cond")
    .return ($P443)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond"  :subid("93_1303340952.947")
    .param pmc param_445
.annotate 'line', 259
    .lex "self", param_445
    $P446 = param_445."!PREFIX__!protoregex"("statement_mod_cond")
    .return ($P446)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<if>"  :subid("94_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx448_tgt
    .local int rx448_pos
    .local int rx448_off
    .local int rx448_eos
    .local int rx448_rep
    .local pmc rx448_cur
    .local pmc rx448_debug
    (rx448_cur, rx448_pos, rx448_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx448_cur
    .local pmc match
    .lex "$/", match
    length rx448_eos, rx448_tgt
    gt rx448_pos, rx448_eos, rx448_done
    set rx448_off, 0
    lt rx448_pos, 2, rx448_start
    sub rx448_off, rx448_pos, 1
    substr rx448_tgt, rx448_tgt, rx448_off
  rx448_start:
    eq $I10, 1, rx448_restart
    if_null rx448_debug, debug_771
    rx448_cur."!cursor_debug"("START", "statement_mod_cond:sym<if>")
  debug_771:
    $I10 = self.'from'()
    ne $I10, -1, rxscan452_done
    goto rxscan452_scan
  rxscan452_loop:
    (rx448_pos) = rx448_cur."from"()
    inc rx448_pos
    rx448_cur."!cursor_from"(rx448_pos)
    ge rx448_pos, rx448_eos, rxscan452_done
  rxscan452_scan:
    set_addr $I10, rxscan452_loop
    rx448_cur."!mark_push"(0, rx448_pos, $I10)
  rxscan452_done:
.annotate 'line', 261
  # rx subcapture "sym"
    set_addr $I10, rxcap_453_fail
    rx448_cur."!mark_push"(0, rx448_pos, $I10)
  # rx literal  "if"
    add $I11, rx448_pos, 2
    gt $I11, rx448_eos, rx448_fail
    sub $I11, rx448_pos, rx448_off
    substr $S10, rx448_tgt, $I11, 2
    ne $S10, "if", rx448_fail
    add rx448_pos, 2
    set_addr $I10, rxcap_453_fail
    ($I12, $I11) = rx448_cur."!mark_peek"($I10)
    rx448_cur."!cursor_pos"($I11)
    ($P10) = rx448_cur."!cursor_start"()
    $P10."!cursor_pass"(rx448_pos, "")
    rx448_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_453_done
  rxcap_453_fail:
    goto rx448_fail
  rxcap_453_done:
  # rx subrule "ws" subtype=method negate=
    rx448_cur."!cursor_pos"(rx448_pos)
    $P10 = rx448_cur."ws"()
    unless $P10, rx448_fail
    rx448_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx448_cur."!cursor_pos"(rx448_pos)
    $P10 = rx448_cur."EXPR"()
    unless $P10, rx448_fail
    rx448_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx448_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx448_cur."!cursor_pos"(rx448_pos)
    $P10 = rx448_cur."ws"()
    unless $P10, rx448_fail
    rx448_pos = $P10."pos"()
  # rx pass
    rx448_cur."!cursor_pass"(rx448_pos, "statement_mod_cond:sym<if>")
    if_null rx448_debug, debug_772
    rx448_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<if>", " at pos=", rx448_pos)
  debug_772:
    .return (rx448_cur)
  rx448_restart:
.annotate 'line', 10
    if_null rx448_debug, debug_773
    rx448_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<if>")
  debug_773:
  rx448_fail:
    (rx448_rep, rx448_pos, $I10, $P10) = rx448_cur."!mark_fail"(0)
    lt rx448_pos, -1, rx448_done
    eq rx448_pos, -1, rx448_fail
    jump $I10
  rx448_done:
    rx448_cur."!cursor_fail"()
    if_null rx448_debug, debug_774
    rx448_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<if>")
  debug_774:
    .return (rx448_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<if>"  :nsentry("!PREFIX__statement_mod_cond:sym<if>") :subid("95_1303340952.947") :method
.annotate 'line', 10
    $P450 = self."!PREFIX__!subrule"("ws", "if")
    new $P451, "ResizablePMCArray"
    push $P451, $P450
    .return ($P451)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<unless>"  :subid("96_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx457_tgt
    .local int rx457_pos
    .local int rx457_off
    .local int rx457_eos
    .local int rx457_rep
    .local pmc rx457_cur
    .local pmc rx457_debug
    (rx457_cur, rx457_pos, rx457_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx457_cur
    .local pmc match
    .lex "$/", match
    length rx457_eos, rx457_tgt
    gt rx457_pos, rx457_eos, rx457_done
    set rx457_off, 0
    lt rx457_pos, 2, rx457_start
    sub rx457_off, rx457_pos, 1
    substr rx457_tgt, rx457_tgt, rx457_off
  rx457_start:
    eq $I10, 1, rx457_restart
    if_null rx457_debug, debug_775
    rx457_cur."!cursor_debug"("START", "statement_mod_cond:sym<unless>")
  debug_775:
    $I10 = self.'from'()
    ne $I10, -1, rxscan461_done
    goto rxscan461_scan
  rxscan461_loop:
    (rx457_pos) = rx457_cur."from"()
    inc rx457_pos
    rx457_cur."!cursor_from"(rx457_pos)
    ge rx457_pos, rx457_eos, rxscan461_done
  rxscan461_scan:
    set_addr $I10, rxscan461_loop
    rx457_cur."!mark_push"(0, rx457_pos, $I10)
  rxscan461_done:
.annotate 'line', 262
  # rx subcapture "sym"
    set_addr $I10, rxcap_462_fail
    rx457_cur."!mark_push"(0, rx457_pos, $I10)
  # rx literal  "unless"
    add $I11, rx457_pos, 6
    gt $I11, rx457_eos, rx457_fail
    sub $I11, rx457_pos, rx457_off
    substr $S10, rx457_tgt, $I11, 6
    ne $S10, "unless", rx457_fail
    add rx457_pos, 6
    set_addr $I10, rxcap_462_fail
    ($I12, $I11) = rx457_cur."!mark_peek"($I10)
    rx457_cur."!cursor_pos"($I11)
    ($P10) = rx457_cur."!cursor_start"()
    $P10."!cursor_pass"(rx457_pos, "")
    rx457_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_462_done
  rxcap_462_fail:
    goto rx457_fail
  rxcap_462_done:
  # rx subrule "ws" subtype=method negate=
    rx457_cur."!cursor_pos"(rx457_pos)
    $P10 = rx457_cur."ws"()
    unless $P10, rx457_fail
    rx457_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx457_cur."!cursor_pos"(rx457_pos)
    $P10 = rx457_cur."EXPR"()
    unless $P10, rx457_fail
    rx457_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx457_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx457_cur."!cursor_pos"(rx457_pos)
    $P10 = rx457_cur."ws"()
    unless $P10, rx457_fail
    rx457_pos = $P10."pos"()
  # rx pass
    rx457_cur."!cursor_pass"(rx457_pos, "statement_mod_cond:sym<unless>")
    if_null rx457_debug, debug_776
    rx457_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<unless>", " at pos=", rx457_pos)
  debug_776:
    .return (rx457_cur)
  rx457_restart:
.annotate 'line', 10
    if_null rx457_debug, debug_777
    rx457_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<unless>")
  debug_777:
  rx457_fail:
    (rx457_rep, rx457_pos, $I10, $P10) = rx457_cur."!mark_fail"(0)
    lt rx457_pos, -1, rx457_done
    eq rx457_pos, -1, rx457_fail
    jump $I10
  rx457_done:
    rx457_cur."!cursor_fail"()
    if_null rx457_debug, debug_778
    rx457_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<unless>")
  debug_778:
    .return (rx457_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<unless>"  :nsentry("!PREFIX__statement_mod_cond:sym<unless>") :subid("97_1303340952.947") :method
.annotate 'line', 10
    $P459 = self."!PREFIX__!subrule"("ws", "unless")
    new $P460, "ResizablePMCArray"
    push $P460, $P459
    .return ($P460)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop"  :subid("98_1303340952.947")
    .param pmc param_466
.annotate 'line', 264
    .lex "self", param_466
    $P467 = param_466."!protoregex"("statement_mod_loop")
    .return ($P467)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop"  :subid("99_1303340952.947")
    .param pmc param_469
.annotate 'line', 264
    .lex "self", param_469
    $P470 = param_469."!PREFIX__!protoregex"("statement_mod_loop")
    .return ($P470)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<while>"  :subid("100_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx472_tgt
    .local int rx472_pos
    .local int rx472_off
    .local int rx472_eos
    .local int rx472_rep
    .local pmc rx472_cur
    .local pmc rx472_debug
    (rx472_cur, rx472_pos, rx472_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx472_cur
    .local pmc match
    .lex "$/", match
    length rx472_eos, rx472_tgt
    gt rx472_pos, rx472_eos, rx472_done
    set rx472_off, 0
    lt rx472_pos, 2, rx472_start
    sub rx472_off, rx472_pos, 1
    substr rx472_tgt, rx472_tgt, rx472_off
  rx472_start:
    eq $I10, 1, rx472_restart
    if_null rx472_debug, debug_779
    rx472_cur."!cursor_debug"("START", "statement_mod_loop:sym<while>")
  debug_779:
    $I10 = self.'from'()
    ne $I10, -1, rxscan476_done
    goto rxscan476_scan
  rxscan476_loop:
    (rx472_pos) = rx472_cur."from"()
    inc rx472_pos
    rx472_cur."!cursor_from"(rx472_pos)
    ge rx472_pos, rx472_eos, rxscan476_done
  rxscan476_scan:
    set_addr $I10, rxscan476_loop
    rx472_cur."!mark_push"(0, rx472_pos, $I10)
  rxscan476_done:
.annotate 'line', 266
  # rx subcapture "sym"
    set_addr $I10, rxcap_477_fail
    rx472_cur."!mark_push"(0, rx472_pos, $I10)
  # rx literal  "while"
    add $I11, rx472_pos, 5
    gt $I11, rx472_eos, rx472_fail
    sub $I11, rx472_pos, rx472_off
    substr $S10, rx472_tgt, $I11, 5
    ne $S10, "while", rx472_fail
    add rx472_pos, 5
    set_addr $I10, rxcap_477_fail
    ($I12, $I11) = rx472_cur."!mark_peek"($I10)
    rx472_cur."!cursor_pos"($I11)
    ($P10) = rx472_cur."!cursor_start"()
    $P10."!cursor_pass"(rx472_pos, "")
    rx472_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_477_done
  rxcap_477_fail:
    goto rx472_fail
  rxcap_477_done:
  # rx subrule "ws" subtype=method negate=
    rx472_cur."!cursor_pos"(rx472_pos)
    $P10 = rx472_cur."ws"()
    unless $P10, rx472_fail
    rx472_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx472_cur."!cursor_pos"(rx472_pos)
    $P10 = rx472_cur."EXPR"()
    unless $P10, rx472_fail
    rx472_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx472_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx472_cur."!cursor_pos"(rx472_pos)
    $P10 = rx472_cur."ws"()
    unless $P10, rx472_fail
    rx472_pos = $P10."pos"()
  # rx pass
    rx472_cur."!cursor_pass"(rx472_pos, "statement_mod_loop:sym<while>")
    if_null rx472_debug, debug_780
    rx472_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<while>", " at pos=", rx472_pos)
  debug_780:
    .return (rx472_cur)
  rx472_restart:
.annotate 'line', 10
    if_null rx472_debug, debug_781
    rx472_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<while>")
  debug_781:
  rx472_fail:
    (rx472_rep, rx472_pos, $I10, $P10) = rx472_cur."!mark_fail"(0)
    lt rx472_pos, -1, rx472_done
    eq rx472_pos, -1, rx472_fail
    jump $I10
  rx472_done:
    rx472_cur."!cursor_fail"()
    if_null rx472_debug, debug_782
    rx472_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<while>")
  debug_782:
    .return (rx472_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<while>"  :nsentry("!PREFIX__statement_mod_loop:sym<while>") :subid("101_1303340952.947") :method
.annotate 'line', 10
    $P474 = self."!PREFIX__!subrule"("ws", "while")
    new $P475, "ResizablePMCArray"
    push $P475, $P474
    .return ($P475)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<until>"  :subid("102_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx481_tgt
    .local int rx481_pos
    .local int rx481_off
    .local int rx481_eos
    .local int rx481_rep
    .local pmc rx481_cur
    .local pmc rx481_debug
    (rx481_cur, rx481_pos, rx481_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx481_cur
    .local pmc match
    .lex "$/", match
    length rx481_eos, rx481_tgt
    gt rx481_pos, rx481_eos, rx481_done
    set rx481_off, 0
    lt rx481_pos, 2, rx481_start
    sub rx481_off, rx481_pos, 1
    substr rx481_tgt, rx481_tgt, rx481_off
  rx481_start:
    eq $I10, 1, rx481_restart
    if_null rx481_debug, debug_783
    rx481_cur."!cursor_debug"("START", "statement_mod_loop:sym<until>")
  debug_783:
    $I10 = self.'from'()
    ne $I10, -1, rxscan485_done
    goto rxscan485_scan
  rxscan485_loop:
    (rx481_pos) = rx481_cur."from"()
    inc rx481_pos
    rx481_cur."!cursor_from"(rx481_pos)
    ge rx481_pos, rx481_eos, rxscan485_done
  rxscan485_scan:
    set_addr $I10, rxscan485_loop
    rx481_cur."!mark_push"(0, rx481_pos, $I10)
  rxscan485_done:
.annotate 'line', 267
  # rx subcapture "sym"
    set_addr $I10, rxcap_486_fail
    rx481_cur."!mark_push"(0, rx481_pos, $I10)
  # rx literal  "until"
    add $I11, rx481_pos, 5
    gt $I11, rx481_eos, rx481_fail
    sub $I11, rx481_pos, rx481_off
    substr $S10, rx481_tgt, $I11, 5
    ne $S10, "until", rx481_fail
    add rx481_pos, 5
    set_addr $I10, rxcap_486_fail
    ($I12, $I11) = rx481_cur."!mark_peek"($I10)
    rx481_cur."!cursor_pos"($I11)
    ($P10) = rx481_cur."!cursor_start"()
    $P10."!cursor_pass"(rx481_pos, "")
    rx481_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_486_done
  rxcap_486_fail:
    goto rx481_fail
  rxcap_486_done:
  # rx subrule "ws" subtype=method negate=
    rx481_cur."!cursor_pos"(rx481_pos)
    $P10 = rx481_cur."ws"()
    unless $P10, rx481_fail
    rx481_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx481_cur."!cursor_pos"(rx481_pos)
    $P10 = rx481_cur."EXPR"()
    unless $P10, rx481_fail
    rx481_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx481_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx481_cur."!cursor_pos"(rx481_pos)
    $P10 = rx481_cur."ws"()
    unless $P10, rx481_fail
    rx481_pos = $P10."pos"()
  # rx pass
    rx481_cur."!cursor_pass"(rx481_pos, "statement_mod_loop:sym<until>")
    if_null rx481_debug, debug_784
    rx481_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<until>", " at pos=", rx481_pos)
  debug_784:
    .return (rx481_cur)
  rx481_restart:
.annotate 'line', 10
    if_null rx481_debug, debug_785
    rx481_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<until>")
  debug_785:
  rx481_fail:
    (rx481_rep, rx481_pos, $I10, $P10) = rx481_cur."!mark_fail"(0)
    lt rx481_pos, -1, rx481_done
    eq rx481_pos, -1, rx481_fail
    jump $I10
  rx481_done:
    rx481_cur."!cursor_fail"()
    if_null rx481_debug, debug_786
    rx481_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<until>")
  debug_786:
    .return (rx481_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<until>"  :nsentry("!PREFIX__statement_mod_loop:sym<until>") :subid("103_1303340952.947") :method
.annotate 'line', 10
    $P483 = self."!PREFIX__!subrule"("ws", "until")
    new $P484, "ResizablePMCArray"
    push $P484, $P483
    .return ($P484)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<for>"  :subid("104_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx490_tgt
    .local int rx490_pos
    .local int rx490_off
    .local int rx490_eos
    .local int rx490_rep
    .local pmc rx490_cur
    .local pmc rx490_debug
    (rx490_cur, rx490_pos, rx490_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx490_cur
    .local pmc match
    .lex "$/", match
    length rx490_eos, rx490_tgt
    gt rx490_pos, rx490_eos, rx490_done
    set rx490_off, 0
    lt rx490_pos, 2, rx490_start
    sub rx490_off, rx490_pos, 1
    substr rx490_tgt, rx490_tgt, rx490_off
  rx490_start:
    eq $I10, 1, rx490_restart
    if_null rx490_debug, debug_787
    rx490_cur."!cursor_debug"("START", "statement_mod_loop:sym<for>")
  debug_787:
    $I10 = self.'from'()
    ne $I10, -1, rxscan494_done
    goto rxscan494_scan
  rxscan494_loop:
    (rx490_pos) = rx490_cur."from"()
    inc rx490_pos
    rx490_cur."!cursor_from"(rx490_pos)
    ge rx490_pos, rx490_eos, rxscan494_done
  rxscan494_scan:
    set_addr $I10, rxscan494_loop
    rx490_cur."!mark_push"(0, rx490_pos, $I10)
  rxscan494_done:
.annotate 'line', 268
  # rx subcapture "sym"
    set_addr $I10, rxcap_495_fail
    rx490_cur."!mark_push"(0, rx490_pos, $I10)
  # rx literal  "for"
    add $I11, rx490_pos, 3
    gt $I11, rx490_eos, rx490_fail
    sub $I11, rx490_pos, rx490_off
    substr $S10, rx490_tgt, $I11, 3
    ne $S10, "for", rx490_fail
    add rx490_pos, 3
    set_addr $I10, rxcap_495_fail
    ($I12, $I11) = rx490_cur."!mark_peek"($I10)
    rx490_cur."!cursor_pos"($I11)
    ($P10) = rx490_cur."!cursor_start"()
    $P10."!cursor_pass"(rx490_pos, "")
    rx490_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_495_done
  rxcap_495_fail:
    goto rx490_fail
  rxcap_495_done:
  # rx subrule "ws" subtype=method negate=
    rx490_cur."!cursor_pos"(rx490_pos)
    $P10 = rx490_cur."ws"()
    unless $P10, rx490_fail
    rx490_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx490_cur."!cursor_pos"(rx490_pos)
    $P10 = rx490_cur."EXPR"()
    unless $P10, rx490_fail
    rx490_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx490_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx490_cur."!cursor_pos"(rx490_pos)
    $P10 = rx490_cur."ws"()
    unless $P10, rx490_fail
    rx490_pos = $P10."pos"()
  # rx pass
    rx490_cur."!cursor_pass"(rx490_pos, "statement_mod_loop:sym<for>")
    if_null rx490_debug, debug_788
    rx490_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<for>", " at pos=", rx490_pos)
  debug_788:
    .return (rx490_cur)
  rx490_restart:
.annotate 'line', 10
    if_null rx490_debug, debug_789
    rx490_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<for>")
  debug_789:
  rx490_fail:
    (rx490_rep, rx490_pos, $I10, $P10) = rx490_cur."!mark_fail"(0)
    lt rx490_pos, -1, rx490_done
    eq rx490_pos, -1, rx490_fail
    jump $I10
  rx490_done:
    rx490_cur."!cursor_fail"()
    if_null rx490_debug, debug_790
    rx490_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<for>")
  debug_790:
    .return (rx490_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<for>"  :nsentry("!PREFIX__statement_mod_loop:sym<for>") :subid("105_1303340952.947") :method
.annotate 'line', 10
    $P492 = self."!PREFIX__!subrule"("ws", "for")
    new $P493, "ResizablePMCArray"
    push $P493, $P492
    .return ($P493)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<fatarrow>"  :subid("106_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx499_tgt
    .local int rx499_pos
    .local int rx499_off
    .local int rx499_eos
    .local int rx499_rep
    .local pmc rx499_cur
    .local pmc rx499_debug
    (rx499_cur, rx499_pos, rx499_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx499_cur
    .local pmc match
    .lex "$/", match
    length rx499_eos, rx499_tgt
    gt rx499_pos, rx499_eos, rx499_done
    set rx499_off, 0
    lt rx499_pos, 2, rx499_start
    sub rx499_off, rx499_pos, 1
    substr rx499_tgt, rx499_tgt, rx499_off
  rx499_start:
    eq $I10, 1, rx499_restart
    if_null rx499_debug, debug_791
    rx499_cur."!cursor_debug"("START", "term:sym<fatarrow>")
  debug_791:
    $I10 = self.'from'()
    ne $I10, -1, rxscan503_done
    goto rxscan503_scan
  rxscan503_loop:
    (rx499_pos) = rx499_cur."from"()
    inc rx499_pos
    rx499_cur."!cursor_from"(rx499_pos)
    ge rx499_pos, rx499_eos, rxscan503_done
  rxscan503_scan:
    set_addr $I10, rxscan503_loop
    rx499_cur."!mark_push"(0, rx499_pos, $I10)
  rxscan503_done:
.annotate 'line', 272
  # rx subrule "fatarrow" subtype=capture negate=
    rx499_cur."!cursor_pos"(rx499_pos)
    $P10 = rx499_cur."fatarrow"()
    unless $P10, rx499_fail
    rx499_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("fatarrow")
    rx499_pos = $P10."pos"()
  # rx pass
    rx499_cur."!cursor_pass"(rx499_pos, "term:sym<fatarrow>")
    if_null rx499_debug, debug_792
    rx499_cur."!cursor_debug"("PASS", "term:sym<fatarrow>", " at pos=", rx499_pos)
  debug_792:
    .return (rx499_cur)
  rx499_restart:
.annotate 'line', 10
    if_null rx499_debug, debug_793
    rx499_cur."!cursor_debug"("NEXT", "term:sym<fatarrow>")
  debug_793:
  rx499_fail:
    (rx499_rep, rx499_pos, $I10, $P10) = rx499_cur."!mark_fail"(0)
    lt rx499_pos, -1, rx499_done
    eq rx499_pos, -1, rx499_fail
    jump $I10
  rx499_done:
    rx499_cur."!cursor_fail"()
    if_null rx499_debug, debug_794
    rx499_cur."!cursor_debug"("FAIL", "term:sym<fatarrow>")
  debug_794:
    .return (rx499_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<fatarrow>"  :nsentry("!PREFIX__term:sym<fatarrow>") :subid("107_1303340952.947") :method
.annotate 'line', 10
    $P501 = self."!PREFIX__!subrule"("fatarrow", "")
    new $P502, "ResizablePMCArray"
    push $P502, $P501
    .return ($P502)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<colonpair>"  :subid("108_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx505_tgt
    .local int rx505_pos
    .local int rx505_off
    .local int rx505_eos
    .local int rx505_rep
    .local pmc rx505_cur
    .local pmc rx505_debug
    (rx505_cur, rx505_pos, rx505_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx505_cur
    .local pmc match
    .lex "$/", match
    length rx505_eos, rx505_tgt
    gt rx505_pos, rx505_eos, rx505_done
    set rx505_off, 0
    lt rx505_pos, 2, rx505_start
    sub rx505_off, rx505_pos, 1
    substr rx505_tgt, rx505_tgt, rx505_off
  rx505_start:
    eq $I10, 1, rx505_restart
    if_null rx505_debug, debug_795
    rx505_cur."!cursor_debug"("START", "term:sym<colonpair>")
  debug_795:
    $I10 = self.'from'()
    ne $I10, -1, rxscan509_done
    goto rxscan509_scan
  rxscan509_loop:
    (rx505_pos) = rx505_cur."from"()
    inc rx505_pos
    rx505_cur."!cursor_from"(rx505_pos)
    ge rx505_pos, rx505_eos, rxscan509_done
  rxscan509_scan:
    set_addr $I10, rxscan509_loop
    rx505_cur."!mark_push"(0, rx505_pos, $I10)
  rxscan509_done:
.annotate 'line', 273
  # rx subrule "colonpair" subtype=capture negate=
    rx505_cur."!cursor_pos"(rx505_pos)
    $P10 = rx505_cur."colonpair"()
    unless $P10, rx505_fail
    rx505_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("colonpair")
    rx505_pos = $P10."pos"()
  # rx pass
    rx505_cur."!cursor_pass"(rx505_pos, "term:sym<colonpair>")
    if_null rx505_debug, debug_796
    rx505_cur."!cursor_debug"("PASS", "term:sym<colonpair>", " at pos=", rx505_pos)
  debug_796:
    .return (rx505_cur)
  rx505_restart:
.annotate 'line', 10
    if_null rx505_debug, debug_797
    rx505_cur."!cursor_debug"("NEXT", "term:sym<colonpair>")
  debug_797:
  rx505_fail:
    (rx505_rep, rx505_pos, $I10, $P10) = rx505_cur."!mark_fail"(0)
    lt rx505_pos, -1, rx505_done
    eq rx505_pos, -1, rx505_fail
    jump $I10
  rx505_done:
    rx505_cur."!cursor_fail"()
    if_null rx505_debug, debug_798
    rx505_cur."!cursor_debug"("FAIL", "term:sym<colonpair>")
  debug_798:
    .return (rx505_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<colonpair>"  :nsentry("!PREFIX__term:sym<colonpair>") :subid("109_1303340952.947") :method
.annotate 'line', 10
    $P507 = self."!PREFIX__!subrule"("colonpair", "")
    new $P508, "ResizablePMCArray"
    push $P508, $P507
    .return ($P508)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<variable>"  :subid("110_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx511_tgt
    .local int rx511_pos
    .local int rx511_off
    .local int rx511_eos
    .local int rx511_rep
    .local pmc rx511_cur
    .local pmc rx511_debug
    (rx511_cur, rx511_pos, rx511_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx511_cur
    .local pmc match
    .lex "$/", match
    length rx511_eos, rx511_tgt
    gt rx511_pos, rx511_eos, rx511_done
    set rx511_off, 0
    lt rx511_pos, 2, rx511_start
    sub rx511_off, rx511_pos, 1
    substr rx511_tgt, rx511_tgt, rx511_off
  rx511_start:
    eq $I10, 1, rx511_restart
    if_null rx511_debug, debug_799
    rx511_cur."!cursor_debug"("START", "term:sym<variable>")
  debug_799:
    $I10 = self.'from'()
    ne $I10, -1, rxscan515_done
    goto rxscan515_scan
  rxscan515_loop:
    (rx511_pos) = rx511_cur."from"()
    inc rx511_pos
    rx511_cur."!cursor_from"(rx511_pos)
    ge rx511_pos, rx511_eos, rxscan515_done
  rxscan515_scan:
    set_addr $I10, rxscan515_loop
    rx511_cur."!mark_push"(0, rx511_pos, $I10)
  rxscan515_done:
.annotate 'line', 274
  # rx subrule "variable" subtype=capture negate=
    rx511_cur."!cursor_pos"(rx511_pos)
    $P10 = rx511_cur."variable"()
    unless $P10, rx511_fail
    rx511_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx511_pos = $P10."pos"()
  # rx pass
    rx511_cur."!cursor_pass"(rx511_pos, "term:sym<variable>")
    if_null rx511_debug, debug_800
    rx511_cur."!cursor_debug"("PASS", "term:sym<variable>", " at pos=", rx511_pos)
  debug_800:
    .return (rx511_cur)
  rx511_restart:
.annotate 'line', 10
    if_null rx511_debug, debug_801
    rx511_cur."!cursor_debug"("NEXT", "term:sym<variable>")
  debug_801:
  rx511_fail:
    (rx511_rep, rx511_pos, $I10, $P10) = rx511_cur."!mark_fail"(0)
    lt rx511_pos, -1, rx511_done
    eq rx511_pos, -1, rx511_fail
    jump $I10
  rx511_done:
    rx511_cur."!cursor_fail"()
    if_null rx511_debug, debug_802
    rx511_cur."!cursor_debug"("FAIL", "term:sym<variable>")
  debug_802:
    .return (rx511_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<variable>"  :nsentry("!PREFIX__term:sym<variable>") :subid("111_1303340952.947") :method
.annotate 'line', 10
    $P513 = self."!PREFIX__!subrule"("variable", "")
    new $P514, "ResizablePMCArray"
    push $P514, $P513
    .return ($P514)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<package_declarator>"  :subid("112_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx517_tgt
    .local int rx517_pos
    .local int rx517_off
    .local int rx517_eos
    .local int rx517_rep
    .local pmc rx517_cur
    .local pmc rx517_debug
    (rx517_cur, rx517_pos, rx517_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx517_cur
    .local pmc match
    .lex "$/", match
    length rx517_eos, rx517_tgt
    gt rx517_pos, rx517_eos, rx517_done
    set rx517_off, 0
    lt rx517_pos, 2, rx517_start
    sub rx517_off, rx517_pos, 1
    substr rx517_tgt, rx517_tgt, rx517_off
  rx517_start:
    eq $I10, 1, rx517_restart
    if_null rx517_debug, debug_803
    rx517_cur."!cursor_debug"("START", "term:sym<package_declarator>")
  debug_803:
    $I10 = self.'from'()
    ne $I10, -1, rxscan521_done
    goto rxscan521_scan
  rxscan521_loop:
    (rx517_pos) = rx517_cur."from"()
    inc rx517_pos
    rx517_cur."!cursor_from"(rx517_pos)
    ge rx517_pos, rx517_eos, rxscan521_done
  rxscan521_scan:
    set_addr $I10, rxscan521_loop
    rx517_cur."!mark_push"(0, rx517_pos, $I10)
  rxscan521_done:
.annotate 'line', 275
  # rx subrule "package_declarator" subtype=capture negate=
    rx517_cur."!cursor_pos"(rx517_pos)
    $P10 = rx517_cur."package_declarator"()
    unless $P10, rx517_fail
    rx517_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx517_pos = $P10."pos"()
  # rx pass
    rx517_cur."!cursor_pass"(rx517_pos, "term:sym<package_declarator>")
    if_null rx517_debug, debug_804
    rx517_cur."!cursor_debug"("PASS", "term:sym<package_declarator>", " at pos=", rx517_pos)
  debug_804:
    .return (rx517_cur)
  rx517_restart:
.annotate 'line', 10
    if_null rx517_debug, debug_805
    rx517_cur."!cursor_debug"("NEXT", "term:sym<package_declarator>")
  debug_805:
  rx517_fail:
    (rx517_rep, rx517_pos, $I10, $P10) = rx517_cur."!mark_fail"(0)
    lt rx517_pos, -1, rx517_done
    eq rx517_pos, -1, rx517_fail
    jump $I10
  rx517_done:
    rx517_cur."!cursor_fail"()
    if_null rx517_debug, debug_806
    rx517_cur."!cursor_debug"("FAIL", "term:sym<package_declarator>")
  debug_806:
    .return (rx517_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<package_declarator>"  :nsentry("!PREFIX__term:sym<package_declarator>") :subid("113_1303340952.947") :method
.annotate 'line', 10
    $P519 = self."!PREFIX__!subrule"("package_declarator", "")
    new $P520, "ResizablePMCArray"
    push $P520, $P519
    .return ($P520)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<scope_declarator>"  :subid("114_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx523_tgt
    .local int rx523_pos
    .local int rx523_off
    .local int rx523_eos
    .local int rx523_rep
    .local pmc rx523_cur
    .local pmc rx523_debug
    (rx523_cur, rx523_pos, rx523_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx523_cur
    .local pmc match
    .lex "$/", match
    length rx523_eos, rx523_tgt
    gt rx523_pos, rx523_eos, rx523_done
    set rx523_off, 0
    lt rx523_pos, 2, rx523_start
    sub rx523_off, rx523_pos, 1
    substr rx523_tgt, rx523_tgt, rx523_off
  rx523_start:
    eq $I10, 1, rx523_restart
    if_null rx523_debug, debug_807
    rx523_cur."!cursor_debug"("START", "term:sym<scope_declarator>")
  debug_807:
    $I10 = self.'from'()
    ne $I10, -1, rxscan527_done
    goto rxscan527_scan
  rxscan527_loop:
    (rx523_pos) = rx523_cur."from"()
    inc rx523_pos
    rx523_cur."!cursor_from"(rx523_pos)
    ge rx523_pos, rx523_eos, rxscan527_done
  rxscan527_scan:
    set_addr $I10, rxscan527_loop
    rx523_cur."!mark_push"(0, rx523_pos, $I10)
  rxscan527_done:
.annotate 'line', 276
  # rx subrule "scope_declarator" subtype=capture negate=
    rx523_cur."!cursor_pos"(rx523_pos)
    $P10 = rx523_cur."scope_declarator"()
    unless $P10, rx523_fail
    rx523_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scope_declarator")
    rx523_pos = $P10."pos"()
  # rx pass
    rx523_cur."!cursor_pass"(rx523_pos, "term:sym<scope_declarator>")
    if_null rx523_debug, debug_808
    rx523_cur."!cursor_debug"("PASS", "term:sym<scope_declarator>", " at pos=", rx523_pos)
  debug_808:
    .return (rx523_cur)
  rx523_restart:
.annotate 'line', 10
    if_null rx523_debug, debug_809
    rx523_cur."!cursor_debug"("NEXT", "term:sym<scope_declarator>")
  debug_809:
  rx523_fail:
    (rx523_rep, rx523_pos, $I10, $P10) = rx523_cur."!mark_fail"(0)
    lt rx523_pos, -1, rx523_done
    eq rx523_pos, -1, rx523_fail
    jump $I10
  rx523_done:
    rx523_cur."!cursor_fail"()
    if_null rx523_debug, debug_810
    rx523_cur."!cursor_debug"("FAIL", "term:sym<scope_declarator>")
  debug_810:
    .return (rx523_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<scope_declarator>"  :nsentry("!PREFIX__term:sym<scope_declarator>") :subid("115_1303340952.947") :method
.annotate 'line', 10
    $P525 = self."!PREFIX__!subrule"("scope_declarator", "")
    new $P526, "ResizablePMCArray"
    push $P526, $P525
    .return ($P526)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<routine_declarator>"  :subid("116_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx529_tgt
    .local int rx529_pos
    .local int rx529_off
    .local int rx529_eos
    .local int rx529_rep
    .local pmc rx529_cur
    .local pmc rx529_debug
    (rx529_cur, rx529_pos, rx529_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx529_cur
    .local pmc match
    .lex "$/", match
    length rx529_eos, rx529_tgt
    gt rx529_pos, rx529_eos, rx529_done
    set rx529_off, 0
    lt rx529_pos, 2, rx529_start
    sub rx529_off, rx529_pos, 1
    substr rx529_tgt, rx529_tgt, rx529_off
  rx529_start:
    eq $I10, 1, rx529_restart
    if_null rx529_debug, debug_811
    rx529_cur."!cursor_debug"("START", "term:sym<routine_declarator>")
  debug_811:
    $I10 = self.'from'()
    ne $I10, -1, rxscan533_done
    goto rxscan533_scan
  rxscan533_loop:
    (rx529_pos) = rx529_cur."from"()
    inc rx529_pos
    rx529_cur."!cursor_from"(rx529_pos)
    ge rx529_pos, rx529_eos, rxscan533_done
  rxscan533_scan:
    set_addr $I10, rxscan533_loop
    rx529_cur."!mark_push"(0, rx529_pos, $I10)
  rxscan533_done:
.annotate 'line', 277
  # rx subrule "routine_declarator" subtype=capture negate=
    rx529_cur."!cursor_pos"(rx529_pos)
    $P10 = rx529_cur."routine_declarator"()
    unless $P10, rx529_fail
    rx529_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx529_pos = $P10."pos"()
  # rx pass
    rx529_cur."!cursor_pass"(rx529_pos, "term:sym<routine_declarator>")
    if_null rx529_debug, debug_812
    rx529_cur."!cursor_debug"("PASS", "term:sym<routine_declarator>", " at pos=", rx529_pos)
  debug_812:
    .return (rx529_cur)
  rx529_restart:
.annotate 'line', 10
    if_null rx529_debug, debug_813
    rx529_cur."!cursor_debug"("NEXT", "term:sym<routine_declarator>")
  debug_813:
  rx529_fail:
    (rx529_rep, rx529_pos, $I10, $P10) = rx529_cur."!mark_fail"(0)
    lt rx529_pos, -1, rx529_done
    eq rx529_pos, -1, rx529_fail
    jump $I10
  rx529_done:
    rx529_cur."!cursor_fail"()
    if_null rx529_debug, debug_814
    rx529_cur."!cursor_debug"("FAIL", "term:sym<routine_declarator>")
  debug_814:
    .return (rx529_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<routine_declarator>"  :nsentry("!PREFIX__term:sym<routine_declarator>") :subid("117_1303340952.947") :method
.annotate 'line', 10
    $P531 = self."!PREFIX__!subrule"("routine_declarator", "")
    new $P532, "ResizablePMCArray"
    push $P532, $P531
    .return ($P532)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<multi_declarator>"  :subid("118_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .const 'Sub' $P545 = "121_1303340952.947" 
    capture_lex $P545
    .const 'Sub' $P540 = "120_1303340952.947" 
    capture_lex $P540
    .local string rx535_tgt
    .local int rx535_pos
    .local int rx535_off
    .local int rx535_eos
    .local int rx535_rep
    .local pmc rx535_cur
    .local pmc rx535_debug
    (rx535_cur, rx535_pos, rx535_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx535_cur
    .local pmc match
    .lex "$/", match
    length rx535_eos, rx535_tgt
    gt rx535_pos, rx535_eos, rx535_done
    set rx535_off, 0
    lt rx535_pos, 2, rx535_start
    sub rx535_off, rx535_pos, 1
    substr rx535_tgt, rx535_tgt, rx535_off
  rx535_start:
    eq $I10, 1, rx535_restart
    if_null rx535_debug, debug_815
    rx535_cur."!cursor_debug"("START", "term:sym<multi_declarator>")
  debug_815:
    $I10 = self.'from'()
    ne $I10, -1, rxscan538_done
    goto rxscan538_scan
  rxscan538_loop:
    (rx535_pos) = rx535_cur."from"()
    inc rx535_pos
    rx535_cur."!cursor_from"(rx535_pos)
    ge rx535_pos, rx535_eos, rxscan538_done
  rxscan538_scan:
    set_addr $I10, rxscan538_loop
    rx535_cur."!mark_push"(0, rx535_pos, $I10)
  rxscan538_done:
.annotate 'line', 279
  # rx subrule "before" subtype=zerowidth negate=
    rx535_cur."!cursor_pos"(rx535_pos)
    .const 'Sub' $P540 = "120_1303340952.947" 
    capture_lex $P540
    $P10 = rx535_cur."before"($P540)
    unless $P10, rx535_fail
.annotate 'line', 280
  # rx subrule "before" subtype=zerowidth negate=1
    rx535_cur."!cursor_pos"(rx535_pos)
    .const 'Sub' $P545 = "121_1303340952.947" 
    capture_lex $P545
    $P10 = rx535_cur."before"($P545)
    if $P10, rx535_fail
.annotate 'line', 281
  # rx subrule "multi_declarator" subtype=capture negate=
    rx535_cur."!cursor_pos"(rx535_pos)
    $P10 = rx535_cur."multi_declarator"()
    unless $P10, rx535_fail
    rx535_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx535_pos = $P10."pos"()
.annotate 'line', 278
  # rx pass
    rx535_cur."!cursor_pass"(rx535_pos, "term:sym<multi_declarator>")
    if_null rx535_debug, debug_824
    rx535_cur."!cursor_debug"("PASS", "term:sym<multi_declarator>", " at pos=", rx535_pos)
  debug_824:
    .return (rx535_cur)
  rx535_restart:
.annotate 'line', 10
    if_null rx535_debug, debug_825
    rx535_cur."!cursor_debug"("NEXT", "term:sym<multi_declarator>")
  debug_825:
  rx535_fail:
    (rx535_rep, rx535_pos, $I10, $P10) = rx535_cur."!mark_fail"(0)
    lt rx535_pos, -1, rx535_done
    eq rx535_pos, -1, rx535_fail
    jump $I10
  rx535_done:
    rx535_cur."!cursor_fail"()
    if_null rx535_debug, debug_826
    rx535_cur."!cursor_debug"("FAIL", "term:sym<multi_declarator>")
  debug_826:
    .return (rx535_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<multi_declarator>"  :nsentry("!PREFIX__term:sym<multi_declarator>") :subid("119_1303340952.947") :method
.annotate 'line', 10
    new $P537, "ResizablePMCArray"
    push $P537, ""
    .return ($P537)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block539"  :anon :subid("120_1303340952.947") :method :outer("118_1303340952.947")
.annotate 'line', 279
    .local string rx541_tgt
    .local int rx541_pos
    .local int rx541_off
    .local int rx541_eos
    .local int rx541_rep
    .local pmc rx541_cur
    .local pmc rx541_debug
    (rx541_cur, rx541_pos, rx541_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx541_cur
    .local pmc match
    .lex "$/", match
    length rx541_eos, rx541_tgt
    gt rx541_pos, rx541_eos, rx541_done
    set rx541_off, 0
    lt rx541_pos, 2, rx541_start
    sub rx541_off, rx541_pos, 1
    substr rx541_tgt, rx541_tgt, rx541_off
  rx541_start:
    eq $I10, 1, rx541_restart
    if_null rx541_debug, debug_816
    rx541_cur."!cursor_debug"("START", "")
  debug_816:
    $I10 = self.'from'()
    ne $I10, -1, rxscan542_done
    goto rxscan542_scan
  rxscan542_loop:
    (rx541_pos) = rx541_cur."from"()
    inc rx541_pos
    rx541_cur."!cursor_from"(rx541_pos)
    ge rx541_pos, rx541_eos, rxscan542_done
  rxscan542_scan:
    set_addr $I10, rxscan542_loop
    rx541_cur."!mark_push"(0, rx541_pos, $I10)
  rxscan542_done:
  alt543_0:
    set_addr $I10, alt543_1
    rx541_cur."!mark_push"(0, rx541_pos, $I10)
  # rx literal  "multi"
    add $I11, rx541_pos, 5
    gt $I11, rx541_eos, rx541_fail
    sub $I11, rx541_pos, rx541_off
    substr $S10, rx541_tgt, $I11, 5
    ne $S10, "multi", rx541_fail
    add rx541_pos, 5
    goto alt543_end
  alt543_1:
    set_addr $I10, alt543_2
    rx541_cur."!mark_push"(0, rx541_pos, $I10)
  # rx literal  "proto"
    add $I11, rx541_pos, 5
    gt $I11, rx541_eos, rx541_fail
    sub $I11, rx541_pos, rx541_off
    substr $S10, rx541_tgt, $I11, 5
    ne $S10, "proto", rx541_fail
    add rx541_pos, 5
    goto alt543_end
  alt543_2:
  # rx literal  "only"
    add $I11, rx541_pos, 4
    gt $I11, rx541_eos, rx541_fail
    sub $I11, rx541_pos, rx541_off
    substr $S10, rx541_tgt, $I11, 4
    ne $S10, "only", rx541_fail
    add rx541_pos, 4
  alt543_end:
  # rx pass
    rx541_cur."!cursor_pass"(rx541_pos, "")
    if_null rx541_debug, debug_817
    rx541_cur."!cursor_debug"("PASS", "", " at pos=", rx541_pos)
  debug_817:
    .return (rx541_cur)
  rx541_restart:
    if_null rx541_debug, debug_818
    rx541_cur."!cursor_debug"("NEXT", "")
  debug_818:
  rx541_fail:
    (rx541_rep, rx541_pos, $I10, $P10) = rx541_cur."!mark_fail"(0)
    lt rx541_pos, -1, rx541_done
    eq rx541_pos, -1, rx541_fail
    jump $I10
  rx541_done:
    rx541_cur."!cursor_fail"()
    if_null rx541_debug, debug_819
    rx541_cur."!cursor_debug"("FAIL", "")
  debug_819:
    .return (rx541_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block544"  :anon :subid("121_1303340952.947") :method :outer("118_1303340952.947")
.annotate 'line', 280
    .local string rx546_tgt
    .local int rx546_pos
    .local int rx546_off
    .local int rx546_eos
    .local int rx546_rep
    .local pmc rx546_cur
    .local pmc rx546_debug
    (rx546_cur, rx546_pos, rx546_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx546_cur
    .local pmc match
    .lex "$/", match
    length rx546_eos, rx546_tgt
    gt rx546_pos, rx546_eos, rx546_done
    set rx546_off, 0
    lt rx546_pos, 2, rx546_start
    sub rx546_off, rx546_pos, 1
    substr rx546_tgt, rx546_tgt, rx546_off
  rx546_start:
    eq $I10, 1, rx546_restart
    if_null rx546_debug, debug_820
    rx546_cur."!cursor_debug"("START", "")
  debug_820:
    $I10 = self.'from'()
    ne $I10, -1, rxscan547_done
    goto rxscan547_scan
  rxscan547_loop:
    (rx546_pos) = rx546_cur."from"()
    inc rx546_pos
    rx546_cur."!cursor_from"(rx546_pos)
    ge rx546_pos, rx546_eos, rxscan547_done
  rxscan547_scan:
    set_addr $I10, rxscan547_loop
    rx546_cur."!mark_push"(0, rx546_pos, $I10)
  rxscan547_done:
  # rx literal  "proto"
    add $I11, rx546_pos, 5
    gt $I11, rx546_eos, rx546_fail
    sub $I11, rx546_pos, rx546_off
    substr $S10, rx546_tgt, $I11, 5
    ne $S10, "proto", rx546_fail
    add rx546_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx546_cur."!cursor_pos"(rx546_pos)
    $P10 = rx546_cur."ws"()
    unless $P10, rx546_fail
    rx546_pos = $P10."pos"()
  alt548_0:
    set_addr $I10, alt548_1
    rx546_cur."!mark_push"(0, rx546_pos, $I10)
  # rx literal  "regex"
    add $I11, rx546_pos, 5
    gt $I11, rx546_eos, rx546_fail
    sub $I11, rx546_pos, rx546_off
    substr $S10, rx546_tgt, $I11, 5
    ne $S10, "regex", rx546_fail
    add rx546_pos, 5
    goto alt548_end
  alt548_1:
    set_addr $I10, alt548_2
    rx546_cur."!mark_push"(0, rx546_pos, $I10)
  # rx literal  "token"
    add $I11, rx546_pos, 5
    gt $I11, rx546_eos, rx546_fail
    sub $I11, rx546_pos, rx546_off
    substr $S10, rx546_tgt, $I11, 5
    ne $S10, "token", rx546_fail
    add rx546_pos, 5
    goto alt548_end
  alt548_2:
  # rx literal  "rule"
    add $I11, rx546_pos, 4
    gt $I11, rx546_eos, rx546_fail
    sub $I11, rx546_pos, rx546_off
    substr $S10, rx546_tgt, $I11, 4
    ne $S10, "rule", rx546_fail
    add rx546_pos, 4
  alt548_end:
  # rx pass
    rx546_cur."!cursor_pass"(rx546_pos, "")
    if_null rx546_debug, debug_821
    rx546_cur."!cursor_debug"("PASS", "", " at pos=", rx546_pos)
  debug_821:
    .return (rx546_cur)
  rx546_restart:
    if_null rx546_debug, debug_822
    rx546_cur."!cursor_debug"("NEXT", "")
  debug_822:
  rx546_fail:
    (rx546_rep, rx546_pos, $I10, $P10) = rx546_cur."!mark_fail"(0)
    lt rx546_pos, -1, rx546_done
    eq rx546_pos, -1, rx546_fail
    jump $I10
  rx546_done:
    rx546_cur."!cursor_fail"()
    if_null rx546_debug, debug_823
    rx546_cur."!cursor_debug"("FAIL", "")
  debug_823:
    .return (rx546_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<regex_declarator>"  :subid("122_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx550_tgt
    .local int rx550_pos
    .local int rx550_off
    .local int rx550_eos
    .local int rx550_rep
    .local pmc rx550_cur
    .local pmc rx550_debug
    (rx550_cur, rx550_pos, rx550_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx550_cur
    .local pmc match
    .lex "$/", match
    length rx550_eos, rx550_tgt
    gt rx550_pos, rx550_eos, rx550_done
    set rx550_off, 0
    lt rx550_pos, 2, rx550_start
    sub rx550_off, rx550_pos, 1
    substr rx550_tgt, rx550_tgt, rx550_off
  rx550_start:
    eq $I10, 1, rx550_restart
    if_null rx550_debug, debug_827
    rx550_cur."!cursor_debug"("START", "term:sym<regex_declarator>")
  debug_827:
    $I10 = self.'from'()
    ne $I10, -1, rxscan554_done
    goto rxscan554_scan
  rxscan554_loop:
    (rx550_pos) = rx550_cur."from"()
    inc rx550_pos
    rx550_cur."!cursor_from"(rx550_pos)
    ge rx550_pos, rx550_eos, rxscan554_done
  rxscan554_scan:
    set_addr $I10, rxscan554_loop
    rx550_cur."!mark_push"(0, rx550_pos, $I10)
  rxscan554_done:
.annotate 'line', 283
  # rx subrule "regex_declarator" subtype=capture negate=
    rx550_cur."!cursor_pos"(rx550_pos)
    $P10 = rx550_cur."regex_declarator"()
    unless $P10, rx550_fail
    rx550_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("regex_declarator")
    rx550_pos = $P10."pos"()
  # rx pass
    rx550_cur."!cursor_pass"(rx550_pos, "term:sym<regex_declarator>")
    if_null rx550_debug, debug_828
    rx550_cur."!cursor_debug"("PASS", "term:sym<regex_declarator>", " at pos=", rx550_pos)
  debug_828:
    .return (rx550_cur)
  rx550_restart:
.annotate 'line', 10
    if_null rx550_debug, debug_829
    rx550_cur."!cursor_debug"("NEXT", "term:sym<regex_declarator>")
  debug_829:
  rx550_fail:
    (rx550_rep, rx550_pos, $I10, $P10) = rx550_cur."!mark_fail"(0)
    lt rx550_pos, -1, rx550_done
    eq rx550_pos, -1, rx550_fail
    jump $I10
  rx550_done:
    rx550_cur."!cursor_fail"()
    if_null rx550_debug, debug_830
    rx550_cur."!cursor_debug"("FAIL", "term:sym<regex_declarator>")
  debug_830:
    .return (rx550_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<regex_declarator>"  :nsentry("!PREFIX__term:sym<regex_declarator>") :subid("123_1303340952.947") :method
.annotate 'line', 10
    $P552 = self."!PREFIX__!subrule"("regex_declarator", "")
    new $P553, "ResizablePMCArray"
    push $P553, $P552
    .return ($P553)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<statement_prefix>"  :subid("124_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx556_tgt
    .local int rx556_pos
    .local int rx556_off
    .local int rx556_eos
    .local int rx556_rep
    .local pmc rx556_cur
    .local pmc rx556_debug
    (rx556_cur, rx556_pos, rx556_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx556_cur
    .local pmc match
    .lex "$/", match
    length rx556_eos, rx556_tgt
    gt rx556_pos, rx556_eos, rx556_done
    set rx556_off, 0
    lt rx556_pos, 2, rx556_start
    sub rx556_off, rx556_pos, 1
    substr rx556_tgt, rx556_tgt, rx556_off
  rx556_start:
    eq $I10, 1, rx556_restart
    if_null rx556_debug, debug_831
    rx556_cur."!cursor_debug"("START", "term:sym<statement_prefix>")
  debug_831:
    $I10 = self.'from'()
    ne $I10, -1, rxscan560_done
    goto rxscan560_scan
  rxscan560_loop:
    (rx556_pos) = rx556_cur."from"()
    inc rx556_pos
    rx556_cur."!cursor_from"(rx556_pos)
    ge rx556_pos, rx556_eos, rxscan560_done
  rxscan560_scan:
    set_addr $I10, rxscan560_loop
    rx556_cur."!mark_push"(0, rx556_pos, $I10)
  rxscan560_done:
.annotate 'line', 284
  # rx subrule "statement_prefix" subtype=capture negate=
    rx556_cur."!cursor_pos"(rx556_pos)
    $P10 = rx556_cur."statement_prefix"()
    unless $P10, rx556_fail
    rx556_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_prefix")
    rx556_pos = $P10."pos"()
  # rx pass
    rx556_cur."!cursor_pass"(rx556_pos, "term:sym<statement_prefix>")
    if_null rx556_debug, debug_832
    rx556_cur."!cursor_debug"("PASS", "term:sym<statement_prefix>", " at pos=", rx556_pos)
  debug_832:
    .return (rx556_cur)
  rx556_restart:
.annotate 'line', 10
    if_null rx556_debug, debug_833
    rx556_cur."!cursor_debug"("NEXT", "term:sym<statement_prefix>")
  debug_833:
  rx556_fail:
    (rx556_rep, rx556_pos, $I10, $P10) = rx556_cur."!mark_fail"(0)
    lt rx556_pos, -1, rx556_done
    eq rx556_pos, -1, rx556_fail
    jump $I10
  rx556_done:
    rx556_cur."!cursor_fail"()
    if_null rx556_debug, debug_834
    rx556_cur."!cursor_debug"("FAIL", "term:sym<statement_prefix>")
  debug_834:
    .return (rx556_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<statement_prefix>"  :nsentry("!PREFIX__term:sym<statement_prefix>") :subid("125_1303340952.947") :method
.annotate 'line', 10
    $P558 = self."!PREFIX__!subrule"("statement_prefix", "")
    new $P559, "ResizablePMCArray"
    push $P559, $P558
    .return ($P559)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<lambda>"  :subid("126_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx562_tgt
    .local int rx562_pos
    .local int rx562_off
    .local int rx562_eos
    .local int rx562_rep
    .local pmc rx562_cur
    .local pmc rx562_debug
    (rx562_cur, rx562_pos, rx562_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx562_cur
    .local pmc match
    .lex "$/", match
    length rx562_eos, rx562_tgt
    gt rx562_pos, rx562_eos, rx562_done
    set rx562_off, 0
    lt rx562_pos, 2, rx562_start
    sub rx562_off, rx562_pos, 1
    substr rx562_tgt, rx562_tgt, rx562_off
  rx562_start:
    eq $I10, 1, rx562_restart
    if_null rx562_debug, debug_835
    rx562_cur."!cursor_debug"("START", "term:sym<lambda>")
  debug_835:
    $I10 = self.'from'()
    ne $I10, -1, rxscan565_done
    goto rxscan565_scan
  rxscan565_loop:
    (rx562_pos) = rx562_cur."from"()
    inc rx562_pos
    rx562_cur."!cursor_from"(rx562_pos)
    ge rx562_pos, rx562_eos, rxscan565_done
  rxscan565_scan:
    set_addr $I10, rxscan565_loop
    rx562_cur."!mark_push"(0, rx562_pos, $I10)
  rxscan565_done:
.annotate 'line', 285
  # rx subrule "lambda" subtype=zerowidth negate=
    rx562_cur."!cursor_pos"(rx562_pos)
    $P10 = rx562_cur."lambda"()
    unless $P10, rx562_fail
  # rx subrule "pblock" subtype=capture negate=
    rx562_cur."!cursor_pos"(rx562_pos)
    $P10 = rx562_cur."pblock"()
    unless $P10, rx562_fail
    rx562_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx562_pos = $P10."pos"()
  # rx pass
    rx562_cur."!cursor_pass"(rx562_pos, "term:sym<lambda>")
    if_null rx562_debug, debug_836
    rx562_cur."!cursor_debug"("PASS", "term:sym<lambda>", " at pos=", rx562_pos)
  debug_836:
    .return (rx562_cur)
  rx562_restart:
.annotate 'line', 10
    if_null rx562_debug, debug_837
    rx562_cur."!cursor_debug"("NEXT", "term:sym<lambda>")
  debug_837:
  rx562_fail:
    (rx562_rep, rx562_pos, $I10, $P10) = rx562_cur."!mark_fail"(0)
    lt rx562_pos, -1, rx562_done
    eq rx562_pos, -1, rx562_fail
    jump $I10
  rx562_done:
    rx562_cur."!cursor_fail"()
    if_null rx562_debug, debug_838
    rx562_cur."!cursor_debug"("FAIL", "term:sym<lambda>")
  debug_838:
    .return (rx562_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<lambda>"  :nsentry("!PREFIX__term:sym<lambda>") :subid("127_1303340952.947") :method
.annotate 'line', 10
    new $P564, "ResizablePMCArray"
    push $P564, ""
    .return ($P564)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "fatarrow"  :subid("128_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx567_tgt
    .local int rx567_pos
    .local int rx567_off
    .local int rx567_eos
    .local int rx567_rep
    .local pmc rx567_cur
    .local pmc rx567_debug
    (rx567_cur, rx567_pos, rx567_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx567_cur
    .local pmc match
    .lex "$/", match
    length rx567_eos, rx567_tgt
    gt rx567_pos, rx567_eos, rx567_done
    set rx567_off, 0
    lt rx567_pos, 2, rx567_start
    sub rx567_off, rx567_pos, 1
    substr rx567_tgt, rx567_tgt, rx567_off
  rx567_start:
    eq $I10, 1, rx567_restart
    if_null rx567_debug, debug_839
    rx567_cur."!cursor_debug"("START", "fatarrow")
  debug_839:
    $I10 = self.'from'()
    ne $I10, -1, rxscan571_done
    goto rxscan571_scan
  rxscan571_loop:
    (rx567_pos) = rx567_cur."from"()
    inc rx567_pos
    rx567_cur."!cursor_from"(rx567_pos)
    ge rx567_pos, rx567_eos, rxscan571_done
  rxscan571_scan:
    set_addr $I10, rxscan571_loop
    rx567_cur."!mark_push"(0, rx567_pos, $I10)
  rxscan571_done:
.annotate 'line', 288
  # rx subrule "identifier" subtype=capture negate=
    rx567_cur."!cursor_pos"(rx567_pos)
    $P10 = rx567_cur."identifier"()
    unless $P10, rx567_fail
    rx567_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("key")
    rx567_pos = $P10."pos"()
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx567_pos, rx567_off
    set rx567_rep, 0
    sub $I12, rx567_eos, rx567_pos
  rxenumcharlistq572_loop:
    le $I12, 0, rxenumcharlistq572_done
    substr $S10, rx567_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq572_done
    inc rx567_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq572_loop
  rxenumcharlistq572_done:
    add rx567_pos, rx567_pos, rx567_rep
  # rx literal  "=>"
    add $I11, rx567_pos, 2
    gt $I11, rx567_eos, rx567_fail
    sub $I11, rx567_pos, rx567_off
    substr $S10, rx567_tgt, $I11, 2
    ne $S10, "=>", rx567_fail
    add rx567_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx567_cur."!cursor_pos"(rx567_pos)
    $P10 = rx567_cur."ws"()
    unless $P10, rx567_fail
    rx567_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx567_cur."!cursor_pos"(rx567_pos)
    $P10 = rx567_cur."EXPR"("i=")
    unless $P10, rx567_fail
    rx567_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("val")
    rx567_pos = $P10."pos"()
.annotate 'line', 287
  # rx pass
    rx567_cur."!cursor_pass"(rx567_pos, "fatarrow")
    if_null rx567_debug, debug_840
    rx567_cur."!cursor_debug"("PASS", "fatarrow", " at pos=", rx567_pos)
  debug_840:
    .return (rx567_cur)
  rx567_restart:
.annotate 'line', 10
    if_null rx567_debug, debug_841
    rx567_cur."!cursor_debug"("NEXT", "fatarrow")
  debug_841:
  rx567_fail:
    (rx567_rep, rx567_pos, $I10, $P10) = rx567_cur."!mark_fail"(0)
    lt rx567_pos, -1, rx567_done
    eq rx567_pos, -1, rx567_fail
    jump $I10
  rx567_done:
    rx567_cur."!cursor_fail"()
    if_null rx567_debug, debug_842
    rx567_cur."!cursor_debug"("FAIL", "fatarrow")
  debug_842:
    .return (rx567_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__fatarrow"  :nsentry("!PREFIX__fatarrow") :subid("129_1303340952.947") :method
.annotate 'line', 10
    $P569 = self."!PREFIX__!subrule"("identifier", "")
    new $P570, "ResizablePMCArray"
    push $P570, $P569
    .return ($P570)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "colonpair"  :subid("130_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx574_tgt
    .local int rx574_pos
    .local int rx574_off
    .local int rx574_eos
    .local int rx574_rep
    .local pmc rx574_cur
    .local pmc rx574_debug
    (rx574_cur, rx574_pos, rx574_tgt, $I10) = self."!cursor_start"()
    rx574_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx574_cur
    .local pmc match
    .lex "$/", match
    length rx574_eos, rx574_tgt
    gt rx574_pos, rx574_eos, rx574_done
    set rx574_off, 0
    lt rx574_pos, 2, rx574_start
    sub rx574_off, rx574_pos, 1
    substr rx574_tgt, rx574_tgt, rx574_off
  rx574_start:
    eq $I10, 1, rx574_restart
    if_null rx574_debug, debug_843
    rx574_cur."!cursor_debug"("START", "colonpair")
  debug_843:
    $I10 = self.'from'()
    ne $I10, -1, rxscan580_done
    goto rxscan580_scan
  rxscan580_loop:
    (rx574_pos) = rx574_cur."from"()
    inc rx574_pos
    rx574_cur."!cursor_from"(rx574_pos)
    ge rx574_pos, rx574_eos, rxscan580_done
  rxscan580_scan:
    set_addr $I10, rxscan580_loop
    rx574_cur."!mark_push"(0, rx574_pos, $I10)
  rxscan580_done:
.annotate 'line', 292
  # rx literal  ":"
    add $I11, rx574_pos, 1
    gt $I11, rx574_eos, rx574_fail
    sub $I11, rx574_pos, rx574_off
    ord $I11, rx574_tgt, $I11
    ne $I11, 58, rx574_fail
    add rx574_pos, 1
  alt581_0:
.annotate 'line', 293
    set_addr $I10, alt581_1
    rx574_cur."!mark_push"(0, rx574_pos, $I10)
.annotate 'line', 294
  # rx subcapture "not"
    set_addr $I10, rxcap_582_fail
    rx574_cur."!mark_push"(0, rx574_pos, $I10)
  # rx literal  "!"
    add $I11, rx574_pos, 1
    gt $I11, rx574_eos, rx574_fail
    sub $I11, rx574_pos, rx574_off
    ord $I11, rx574_tgt, $I11
    ne $I11, 33, rx574_fail
    add rx574_pos, 1
    set_addr $I10, rxcap_582_fail
    ($I12, $I11) = rx574_cur."!mark_peek"($I10)
    rx574_cur."!cursor_pos"($I11)
    ($P10) = rx574_cur."!cursor_start"()
    $P10."!cursor_pass"(rx574_pos, "")
    rx574_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("not")
    goto rxcap_582_done
  rxcap_582_fail:
    goto rx574_fail
  rxcap_582_done:
  # rx subrule "identifier" subtype=capture negate=
    rx574_cur."!cursor_pos"(rx574_pos)
    $P10 = rx574_cur."identifier"()
    unless $P10, rx574_fail
    rx574_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx574_pos = $P10."pos"()
    goto alt581_end
  alt581_1:
    set_addr $I10, alt581_2
    rx574_cur."!mark_push"(0, rx574_pos, $I10)
.annotate 'line', 295
  # rx subrule "identifier" subtype=capture negate=
    rx574_cur."!cursor_pos"(rx574_pos)
    $P10 = rx574_cur."identifier"()
    unless $P10, rx574_fail
    rx574_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx574_pos = $P10."pos"()
  # rx rxquantr583 ** 0..1
    set_addr $I10, rxquantr583_done
    rx574_cur."!mark_push"(0, rx574_pos, $I10)
  rxquantr583_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx574_cur."!cursor_pos"(rx574_pos)
    $P10 = rx574_cur."circumfix"()
    unless $P10, rx574_fail
    goto rxsubrule584_pass
  rxsubrule584_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx574_fail
  rxsubrule584_pass:
    set_addr $I10, rxsubrule584_back
    rx574_cur."!mark_push"(0, rx574_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx574_pos = $P10."pos"()
    set_addr $I10, rxquantr583_done
    (rx574_rep) = rx574_cur."!mark_commit"($I10)
  rxquantr583_done:
    goto alt581_end
  alt581_2:
.annotate 'line', 296
  # rx subrule "circumfix" subtype=capture negate=
    rx574_cur."!cursor_pos"(rx574_pos)
    $P10 = rx574_cur."circumfix"()
    unless $P10, rx574_fail
    rx574_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("circumfix")
    rx574_pos = $P10."pos"()
  alt581_end:
.annotate 'line', 291
  # rx pass
    rx574_cur."!cursor_pass"(rx574_pos, "colonpair")
    if_null rx574_debug, debug_844
    rx574_cur."!cursor_debug"("PASS", "colonpair", " at pos=", rx574_pos)
  debug_844:
    .return (rx574_cur)
  rx574_restart:
.annotate 'line', 10
    if_null rx574_debug, debug_845
    rx574_cur."!cursor_debug"("NEXT", "colonpair")
  debug_845:
  rx574_fail:
    (rx574_rep, rx574_pos, $I10, $P10) = rx574_cur."!mark_fail"(0)
    lt rx574_pos, -1, rx574_done
    eq rx574_pos, -1, rx574_fail
    jump $I10
  rx574_done:
    rx574_cur."!cursor_fail"()
    if_null rx574_debug, debug_846
    rx574_cur."!cursor_debug"("FAIL", "colonpair")
  debug_846:
    .return (rx574_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__colonpair"  :nsentry("!PREFIX__colonpair") :subid("131_1303340952.947") :method
.annotate 'line', 10
    $P576 = self."!PREFIX__!subrule"("circumfix", ":")
    $P577 = self."!PREFIX__!subrule"("identifier", ":")
    $P578 = self."!PREFIX__!subrule"("identifier", ":!")
    new $P579, "ResizablePMCArray"
    push $P579, $P576
    push $P579, $P577
    push $P579, $P578
    .return ($P579)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable"  :subid("132_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx586_tgt
    .local int rx586_pos
    .local int rx586_off
    .local int rx586_eos
    .local int rx586_rep
    .local pmc rx586_cur
    .local pmc rx586_debug
    (rx586_cur, rx586_pos, rx586_tgt, $I10) = self."!cursor_start"()
    rx586_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx586_cur
    .local pmc match
    .lex "$/", match
    length rx586_eos, rx586_tgt
    gt rx586_pos, rx586_eos, rx586_done
    set rx586_off, 0
    lt rx586_pos, 2, rx586_start
    sub rx586_off, rx586_pos, 1
    substr rx586_tgt, rx586_tgt, rx586_off
  rx586_start:
    eq $I10, 1, rx586_restart
    if_null rx586_debug, debug_847
    rx586_cur."!cursor_debug"("START", "variable")
  debug_847:
    $I10 = self.'from'()
    ne $I10, -1, rxscan591_done
    goto rxscan591_scan
  rxscan591_loop:
    (rx586_pos) = rx586_cur."from"()
    inc rx586_pos
    rx586_cur."!cursor_from"(rx586_pos)
    ge rx586_pos, rx586_eos, rxscan591_done
  rxscan591_scan:
    set_addr $I10, rxscan591_loop
    rx586_cur."!mark_push"(0, rx586_pos, $I10)
  rxscan591_done:
  alt592_0:
.annotate 'line', 300
    set_addr $I10, alt592_1
    rx586_cur."!mark_push"(0, rx586_pos, $I10)
.annotate 'line', 301
  # rx subrule "sigil" subtype=capture negate=
    rx586_cur."!cursor_pos"(rx586_pos)
    $P10 = rx586_cur."sigil"()
    unless $P10, rx586_fail
    rx586_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx586_pos = $P10."pos"()
  # rx rxquantr593 ** 0..1
    set_addr $I10, rxquantr593_done
    rx586_cur."!mark_push"(0, rx586_pos, $I10)
  rxquantr593_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx586_cur."!cursor_pos"(rx586_pos)
    $P10 = rx586_cur."twigil"()
    unless $P10, rx586_fail
    goto rxsubrule594_pass
  rxsubrule594_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx586_fail
  rxsubrule594_pass:
    set_addr $I10, rxsubrule594_back
    rx586_cur."!mark_push"(0, rx586_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx586_pos = $P10."pos"()
    set_addr $I10, rxquantr593_done
    (rx586_rep) = rx586_cur."!mark_commit"($I10)
  rxquantr593_done:
  # rx subrule "name" subtype=capture negate=
    rx586_cur."!cursor_pos"(rx586_pos)
    $P10 = rx586_cur."name"()
    unless $P10, rx586_fail
    rx586_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    rx586_pos = $P10."pos"()
    goto alt592_end
  alt592_1:
    set_addr $I10, alt592_2
    rx586_cur."!mark_push"(0, rx586_pos, $I10)
.annotate 'line', 302
  # rx subrule "sigil" subtype=capture negate=
    rx586_cur."!cursor_pos"(rx586_pos)
    $P10 = rx586_cur."sigil"()
    unless $P10, rx586_fail
    rx586_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx586_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx586_pos, rx586_off
    substr $S10, rx586_tgt, $I10, 1
    index $I11, "<[", $S10
    lt $I11, 0, rx586_fail
  # rx subrule "postcircumfix" subtype=capture negate=
    rx586_cur."!cursor_pos"(rx586_pos)
    $P10 = rx586_cur."postcircumfix"()
    unless $P10, rx586_fail
    rx586_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("postcircumfix")
    rx586_pos = $P10."pos"()
    goto alt592_end
  alt592_2:
.annotate 'line', 303
  # rx subcapture "sigil"
    set_addr $I10, rxcap_595_fail
    rx586_cur."!mark_push"(0, rx586_pos, $I10)
  # rx literal  "$"
    add $I11, rx586_pos, 1
    gt $I11, rx586_eos, rx586_fail
    sub $I11, rx586_pos, rx586_off
    ord $I11, rx586_tgt, $I11
    ne $I11, 36, rx586_fail
    add rx586_pos, 1
    set_addr $I10, rxcap_595_fail
    ($I12, $I11) = rx586_cur."!mark_peek"($I10)
    rx586_cur."!cursor_pos"($I11)
    ($P10) = rx586_cur."!cursor_start"()
    $P10."!cursor_pass"(rx586_pos, "")
    rx586_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_595_done
  rxcap_595_fail:
    goto rx586_fail
  rxcap_595_done:
  # rx subcapture "desigilname"
    set_addr $I10, rxcap_596_fail
    rx586_cur."!mark_push"(0, rx586_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx586_pos, rx586_eos, rx586_fail
    sub $I10, rx586_pos, rx586_off
    substr $S10, rx586_tgt, $I10, 1
    index $I11, "/_!", $S10
    lt $I11, 0, rx586_fail
    inc rx586_pos
    set_addr $I10, rxcap_596_fail
    ($I12, $I11) = rx586_cur."!mark_peek"($I10)
    rx586_cur."!cursor_pos"($I11)
    ($P10) = rx586_cur."!cursor_start"()
    $P10."!cursor_pass"(rx586_pos, "")
    rx586_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    goto rxcap_596_done
  rxcap_596_fail:
    goto rx586_fail
  rxcap_596_done:
  alt592_end:
.annotate 'line', 300
  # rx pass
    rx586_cur."!cursor_pass"(rx586_pos, "variable")
    if_null rx586_debug, debug_848
    rx586_cur."!cursor_debug"("PASS", "variable", " at pos=", rx586_pos)
  debug_848:
    .return (rx586_cur)
  rx586_restart:
.annotate 'line', 10
    if_null rx586_debug, debug_849
    rx586_cur."!cursor_debug"("NEXT", "variable")
  debug_849:
  rx586_fail:
    (rx586_rep, rx586_pos, $I10, $P10) = rx586_cur."!mark_fail"(0)
    lt rx586_pos, -1, rx586_done
    eq rx586_pos, -1, rx586_fail
    jump $I10
  rx586_done:
    rx586_cur."!cursor_fail"()
    if_null rx586_debug, debug_850
    rx586_cur."!cursor_debug"("FAIL", "variable")
  debug_850:
    .return (rx586_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable"  :nsentry("!PREFIX__variable") :subid("133_1303340952.947") :method
.annotate 'line', 10
    $P588 = self."!PREFIX__!subrule"("sigil", "")
    $P589 = self."!PREFIX__!subrule"("sigil", "")
    new $P590, "ResizablePMCArray"
    push $P590, "$!"
    push $P590, "$_"
    push $P590, "$/"
    push $P590, $P588
    push $P590, $P589
    .return ($P590)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "sigil"  :subid("134_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx598_tgt
    .local int rx598_pos
    .local int rx598_off
    .local int rx598_eos
    .local int rx598_rep
    .local pmc rx598_cur
    .local pmc rx598_debug
    (rx598_cur, rx598_pos, rx598_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx598_cur
    .local pmc match
    .lex "$/", match
    length rx598_eos, rx598_tgt
    gt rx598_pos, rx598_eos, rx598_done
    set rx598_off, 0
    lt rx598_pos, 2, rx598_start
    sub rx598_off, rx598_pos, 1
    substr rx598_tgt, rx598_tgt, rx598_off
  rx598_start:
    eq $I10, 1, rx598_restart
    if_null rx598_debug, debug_851
    rx598_cur."!cursor_debug"("START", "sigil")
  debug_851:
    $I10 = self.'from'()
    ne $I10, -1, rxscan601_done
    goto rxscan601_scan
  rxscan601_loop:
    (rx598_pos) = rx598_cur."from"()
    inc rx598_pos
    rx598_cur."!cursor_from"(rx598_pos)
    ge rx598_pos, rx598_eos, rxscan601_done
  rxscan601_scan:
    set_addr $I10, rxscan601_loop
    rx598_cur."!mark_push"(0, rx598_pos, $I10)
  rxscan601_done:
.annotate 'line', 306
  # rx enumcharlist negate=0 
    ge rx598_pos, rx598_eos, rx598_fail
    sub $I10, rx598_pos, rx598_off
    substr $S10, rx598_tgt, $I10, 1
    index $I11, "$@%&", $S10
    lt $I11, 0, rx598_fail
    inc rx598_pos
  # rx pass
    rx598_cur."!cursor_pass"(rx598_pos, "sigil")
    if_null rx598_debug, debug_852
    rx598_cur."!cursor_debug"("PASS", "sigil", " at pos=", rx598_pos)
  debug_852:
    .return (rx598_cur)
  rx598_restart:
.annotate 'line', 10
    if_null rx598_debug, debug_853
    rx598_cur."!cursor_debug"("NEXT", "sigil")
  debug_853:
  rx598_fail:
    (rx598_rep, rx598_pos, $I10, $P10) = rx598_cur."!mark_fail"(0)
    lt rx598_pos, -1, rx598_done
    eq rx598_pos, -1, rx598_fail
    jump $I10
  rx598_done:
    rx598_cur."!cursor_fail"()
    if_null rx598_debug, debug_854
    rx598_cur."!cursor_debug"("FAIL", "sigil")
  debug_854:
    .return (rx598_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__sigil"  :nsentry("!PREFIX__sigil") :subid("135_1303340952.947") :method
.annotate 'line', 10
    new $P600, "ResizablePMCArray"
    push $P600, "&"
    push $P600, "%"
    push $P600, "@"
    push $P600, "$"
    .return ($P600)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "twigil"  :subid("136_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx603_tgt
    .local int rx603_pos
    .local int rx603_off
    .local int rx603_eos
    .local int rx603_rep
    .local pmc rx603_cur
    .local pmc rx603_debug
    (rx603_cur, rx603_pos, rx603_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx603_cur
    .local pmc match
    .lex "$/", match
    length rx603_eos, rx603_tgt
    gt rx603_pos, rx603_eos, rx603_done
    set rx603_off, 0
    lt rx603_pos, 2, rx603_start
    sub rx603_off, rx603_pos, 1
    substr rx603_tgt, rx603_tgt, rx603_off
  rx603_start:
    eq $I10, 1, rx603_restart
    if_null rx603_debug, debug_855
    rx603_cur."!cursor_debug"("START", "twigil")
  debug_855:
    $I10 = self.'from'()
    ne $I10, -1, rxscan606_done
    goto rxscan606_scan
  rxscan606_loop:
    (rx603_pos) = rx603_cur."from"()
    inc rx603_pos
    rx603_cur."!cursor_from"(rx603_pos)
    ge rx603_pos, rx603_eos, rxscan606_done
  rxscan606_scan:
    set_addr $I10, rxscan606_loop
    rx603_cur."!mark_push"(0, rx603_pos, $I10)
  rxscan606_done:
.annotate 'line', 308
  # rx enumcharlist negate=0 
    ge rx603_pos, rx603_eos, rx603_fail
    sub $I10, rx603_pos, rx603_off
    substr $S10, rx603_tgt, $I10, 1
    index $I11, "*!?", $S10
    lt $I11, 0, rx603_fail
    inc rx603_pos
  # rx pass
    rx603_cur."!cursor_pass"(rx603_pos, "twigil")
    if_null rx603_debug, debug_856
    rx603_cur."!cursor_debug"("PASS", "twigil", " at pos=", rx603_pos)
  debug_856:
    .return (rx603_cur)
  rx603_restart:
.annotate 'line', 10
    if_null rx603_debug, debug_857
    rx603_cur."!cursor_debug"("NEXT", "twigil")
  debug_857:
  rx603_fail:
    (rx603_rep, rx603_pos, $I10, $P10) = rx603_cur."!mark_fail"(0)
    lt rx603_pos, -1, rx603_done
    eq rx603_pos, -1, rx603_fail
    jump $I10
  rx603_done:
    rx603_cur."!cursor_fail"()
    if_null rx603_debug, debug_858
    rx603_cur."!cursor_debug"("FAIL", "twigil")
  debug_858:
    .return (rx603_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__twigil"  :nsentry("!PREFIX__twigil") :subid("137_1303340952.947") :method
.annotate 'line', 10
    new $P605, "ResizablePMCArray"
    push $P605, "?"
    push $P605, "!"
    push $P605, "*"
    .return ($P605)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator"  :subid("138_1303340952.947")
    .param pmc param_608
.annotate 'line', 310
    .lex "self", param_608
    $P609 = param_608."!protoregex"("package_declarator")
    .return ($P609)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator"  :subid("139_1303340952.947")
    .param pmc param_611
.annotate 'line', 310
    .lex "self", param_611
    $P612 = param_611."!PREFIX__!protoregex"("package_declarator")
    .return ($P612)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<module>"  :subid("140_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 312
    new $P614, "Undef"
    .lex "$*PACKAGE-SETUP", $P614
.annotate 'line', 313
    new $P615, "Undef"
    .lex "$*PKGDECL", $P615
.annotate 'line', 10
    .local string rx616_tgt
    .local int rx616_pos
    .local int rx616_off
    .local int rx616_eos
    .local int rx616_rep
    .local pmc rx616_cur
    .local pmc rx616_debug
    (rx616_cur, rx616_pos, rx616_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx616_cur
    .local pmc match
    .lex "$/", match
    length rx616_eos, rx616_tgt
    gt rx616_pos, rx616_eos, rx616_done
    set rx616_off, 0
    lt rx616_pos, 2, rx616_start
    sub rx616_off, rx616_pos, 1
    substr rx616_tgt, rx616_tgt, rx616_off
  rx616_start:
    eq $I10, 1, rx616_restart
    if_null rx616_debug, debug_859
    rx616_cur."!cursor_debug"("START", "package_declarator:sym<module>")
  debug_859:
    $I10 = self.'from'()
    ne $I10, -1, rxscan620_done
    goto rxscan620_scan
  rxscan620_loop:
    (rx616_pos) = rx616_cur."from"()
    inc rx616_pos
    rx616_cur."!cursor_from"(rx616_pos)
    ge rx616_pos, rx616_eos, rxscan620_done
  rxscan620_scan:
    set_addr $I10, rxscan620_loop
    rx616_cur."!mark_push"(0, rx616_pos, $I10)
  rxscan620_done:
.annotate 'line', 312
    rx616_cur."!cursor_pos"(rx616_pos)
    get_hll_global $P621, ["PAST"], "Stmts"
    $P622 = $P621."new"()
    store_lex "$*PACKAGE-SETUP", $P622
.annotate 'line', 313
    rx616_cur."!cursor_pos"(rx616_pos)
    new $P623, "String"
    assign $P623, "module"
    store_lex "$*PKGDECL", $P623
.annotate 'line', 314
  # rx subcapture "sym"
    set_addr $I10, rxcap_624_fail
    rx616_cur."!mark_push"(0, rx616_pos, $I10)
  # rx literal  "module"
    add $I11, rx616_pos, 6
    gt $I11, rx616_eos, rx616_fail
    sub $I11, rx616_pos, rx616_off
    substr $S10, rx616_tgt, $I11, 6
    ne $S10, "module", rx616_fail
    add rx616_pos, 6
    set_addr $I10, rxcap_624_fail
    ($I12, $I11) = rx616_cur."!mark_peek"($I10)
    rx616_cur."!cursor_pos"($I11)
    ($P10) = rx616_cur."!cursor_start"()
    $P10."!cursor_pass"(rx616_pos, "")
    rx616_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_624_done
  rxcap_624_fail:
    goto rx616_fail
  rxcap_624_done:
  # rx subrule "package_def" subtype=capture negate=
    rx616_cur."!cursor_pos"(rx616_pos)
    $P10 = rx616_cur."package_def"()
    unless $P10, rx616_fail
    rx616_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx616_pos = $P10."pos"()
.annotate 'line', 311
  # rx pass
    rx616_cur."!cursor_pass"(rx616_pos, "package_declarator:sym<module>")
    if_null rx616_debug, debug_860
    rx616_cur."!cursor_debug"("PASS", "package_declarator:sym<module>", " at pos=", rx616_pos)
  debug_860:
    .return (rx616_cur)
  rx616_restart:
.annotate 'line', 10
    if_null rx616_debug, debug_861
    rx616_cur."!cursor_debug"("NEXT", "package_declarator:sym<module>")
  debug_861:
  rx616_fail:
    (rx616_rep, rx616_pos, $I10, $P10) = rx616_cur."!mark_fail"(0)
    lt rx616_pos, -1, rx616_done
    eq rx616_pos, -1, rx616_fail
    jump $I10
  rx616_done:
    rx616_cur."!cursor_fail"()
    if_null rx616_debug, debug_862
    rx616_cur."!cursor_debug"("FAIL", "package_declarator:sym<module>")
  debug_862:
    .return (rx616_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<module>"  :nsentry("!PREFIX__package_declarator:sym<module>") :subid("141_1303340952.947") :method
.annotate 'line', 10
    $P618 = self."!PREFIX__!subrule"("package_def", "module")
    new $P619, "ResizablePMCArray"
    push $P619, $P618
    .return ($P619)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<knowhow>"  :subid("142_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 317
    new $P626, "Undef"
    .lex "$*PACKAGE-SETUP", $P626
.annotate 'line', 318
    new $P627, "Undef"
    .lex "$*PKGDECL", $P627
.annotate 'line', 10
    .local string rx628_tgt
    .local int rx628_pos
    .local int rx628_off
    .local int rx628_eos
    .local int rx628_rep
    .local pmc rx628_cur
    .local pmc rx628_debug
    (rx628_cur, rx628_pos, rx628_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx628_cur
    .local pmc match
    .lex "$/", match
    length rx628_eos, rx628_tgt
    gt rx628_pos, rx628_eos, rx628_done
    set rx628_off, 0
    lt rx628_pos, 2, rx628_start
    sub rx628_off, rx628_pos, 1
    substr rx628_tgt, rx628_tgt, rx628_off
  rx628_start:
    eq $I10, 1, rx628_restart
    if_null rx628_debug, debug_863
    rx628_cur."!cursor_debug"("START", "package_declarator:sym<knowhow>")
  debug_863:
    $I10 = self.'from'()
    ne $I10, -1, rxscan632_done
    goto rxscan632_scan
  rxscan632_loop:
    (rx628_pos) = rx628_cur."from"()
    inc rx628_pos
    rx628_cur."!cursor_from"(rx628_pos)
    ge rx628_pos, rx628_eos, rxscan632_done
  rxscan632_scan:
    set_addr $I10, rxscan632_loop
    rx628_cur."!mark_push"(0, rx628_pos, $I10)
  rxscan632_done:
.annotate 'line', 317
    rx628_cur."!cursor_pos"(rx628_pos)
    get_hll_global $P633, ["PAST"], "Stmts"
    $P634 = $P633."new"()
    store_lex "$*PACKAGE-SETUP", $P634
.annotate 'line', 318
    rx628_cur."!cursor_pos"(rx628_pos)
    new $P635, "String"
    assign $P635, "knowhow"
    store_lex "$*PKGDECL", $P635
.annotate 'line', 319
  # rx subcapture "sym"
    set_addr $I10, rxcap_636_fail
    rx628_cur."!mark_push"(0, rx628_pos, $I10)
  # rx literal  "knowhow"
    add $I11, rx628_pos, 7
    gt $I11, rx628_eos, rx628_fail
    sub $I11, rx628_pos, rx628_off
    substr $S10, rx628_tgt, $I11, 7
    ne $S10, "knowhow", rx628_fail
    add rx628_pos, 7
    set_addr $I10, rxcap_636_fail
    ($I12, $I11) = rx628_cur."!mark_peek"($I10)
    rx628_cur."!cursor_pos"($I11)
    ($P10) = rx628_cur."!cursor_start"()
    $P10."!cursor_pass"(rx628_pos, "")
    rx628_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_636_done
  rxcap_636_fail:
    goto rx628_fail
  rxcap_636_done:
  # rx subrule "package_def" subtype=capture negate=
    rx628_cur."!cursor_pos"(rx628_pos)
    $P10 = rx628_cur."package_def"()
    unless $P10, rx628_fail
    rx628_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx628_pos = $P10."pos"()
.annotate 'line', 316
  # rx pass
    rx628_cur."!cursor_pass"(rx628_pos, "package_declarator:sym<knowhow>")
    if_null rx628_debug, debug_864
    rx628_cur."!cursor_debug"("PASS", "package_declarator:sym<knowhow>", " at pos=", rx628_pos)
  debug_864:
    .return (rx628_cur)
  rx628_restart:
.annotate 'line', 10
    if_null rx628_debug, debug_865
    rx628_cur."!cursor_debug"("NEXT", "package_declarator:sym<knowhow>")
  debug_865:
  rx628_fail:
    (rx628_rep, rx628_pos, $I10, $P10) = rx628_cur."!mark_fail"(0)
    lt rx628_pos, -1, rx628_done
    eq rx628_pos, -1, rx628_fail
    jump $I10
  rx628_done:
    rx628_cur."!cursor_fail"()
    if_null rx628_debug, debug_866
    rx628_cur."!cursor_debug"("FAIL", "package_declarator:sym<knowhow>")
  debug_866:
    .return (rx628_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<knowhow>"  :nsentry("!PREFIX__package_declarator:sym<knowhow>") :subid("143_1303340952.947") :method
.annotate 'line', 10
    $P630 = self."!PREFIX__!subrule"("package_def", "knowhow")
    new $P631, "ResizablePMCArray"
    push $P631, $P630
    .return ($P631)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<class>"  :subid("144_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 322
    new $P638, "Undef"
    .lex "$*PACKAGE-SETUP", $P638
.annotate 'line', 323
    new $P639, "Undef"
    .lex "$*PKGDECL", $P639
.annotate 'line', 10
    .local string rx640_tgt
    .local int rx640_pos
    .local int rx640_off
    .local int rx640_eos
    .local int rx640_rep
    .local pmc rx640_cur
    .local pmc rx640_debug
    (rx640_cur, rx640_pos, rx640_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx640_cur
    .local pmc match
    .lex "$/", match
    length rx640_eos, rx640_tgt
    gt rx640_pos, rx640_eos, rx640_done
    set rx640_off, 0
    lt rx640_pos, 2, rx640_start
    sub rx640_off, rx640_pos, 1
    substr rx640_tgt, rx640_tgt, rx640_off
  rx640_start:
    eq $I10, 1, rx640_restart
    if_null rx640_debug, debug_867
    rx640_cur."!cursor_debug"("START", "package_declarator:sym<class>")
  debug_867:
    $I10 = self.'from'()
    ne $I10, -1, rxscan644_done
    goto rxscan644_scan
  rxscan644_loop:
    (rx640_pos) = rx640_cur."from"()
    inc rx640_pos
    rx640_cur."!cursor_from"(rx640_pos)
    ge rx640_pos, rx640_eos, rxscan644_done
  rxscan644_scan:
    set_addr $I10, rxscan644_loop
    rx640_cur."!mark_push"(0, rx640_pos, $I10)
  rxscan644_done:
.annotate 'line', 322
    rx640_cur."!cursor_pos"(rx640_pos)
    get_hll_global $P645, ["PAST"], "Stmts"
    $P646 = $P645."new"()
    store_lex "$*PACKAGE-SETUP", $P646
.annotate 'line', 323
    rx640_cur."!cursor_pos"(rx640_pos)
    new $P647, "String"
    assign $P647, "class"
    store_lex "$*PKGDECL", $P647
.annotate 'line', 324
  # rx subcapture "sym"
    set_addr $I10, rxcap_648_fail
    rx640_cur."!mark_push"(0, rx640_pos, $I10)
  # rx literal  "class"
    add $I11, rx640_pos, 5
    gt $I11, rx640_eos, rx640_fail
    sub $I11, rx640_pos, rx640_off
    substr $S10, rx640_tgt, $I11, 5
    ne $S10, "class", rx640_fail
    add rx640_pos, 5
    set_addr $I10, rxcap_648_fail
    ($I12, $I11) = rx640_cur."!mark_peek"($I10)
    rx640_cur."!cursor_pos"($I11)
    ($P10) = rx640_cur."!cursor_start"()
    $P10."!cursor_pass"(rx640_pos, "")
    rx640_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_648_done
  rxcap_648_fail:
    goto rx640_fail
  rxcap_648_done:
  # rx subrule "package_def" subtype=capture negate=
    rx640_cur."!cursor_pos"(rx640_pos)
    $P10 = rx640_cur."package_def"()
    unless $P10, rx640_fail
    rx640_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx640_pos = $P10."pos"()
.annotate 'line', 321
  # rx pass
    rx640_cur."!cursor_pass"(rx640_pos, "package_declarator:sym<class>")
    if_null rx640_debug, debug_868
    rx640_cur."!cursor_debug"("PASS", "package_declarator:sym<class>", " at pos=", rx640_pos)
  debug_868:
    .return (rx640_cur)
  rx640_restart:
.annotate 'line', 10
    if_null rx640_debug, debug_869
    rx640_cur."!cursor_debug"("NEXT", "package_declarator:sym<class>")
  debug_869:
  rx640_fail:
    (rx640_rep, rx640_pos, $I10, $P10) = rx640_cur."!mark_fail"(0)
    lt rx640_pos, -1, rx640_done
    eq rx640_pos, -1, rx640_fail
    jump $I10
  rx640_done:
    rx640_cur."!cursor_fail"()
    if_null rx640_debug, debug_870
    rx640_cur."!cursor_debug"("FAIL", "package_declarator:sym<class>")
  debug_870:
    .return (rx640_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<class>"  :nsentry("!PREFIX__package_declarator:sym<class>") :subid("145_1303340952.947") :method
.annotate 'line', 10
    $P642 = self."!PREFIX__!subrule"("package_def", "class")
    new $P643, "ResizablePMCArray"
    push $P643, $P642
    .return ($P643)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<grammar>"  :subid("146_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 327
    new $P650, "Undef"
    .lex "$*PACKAGE-SETUP", $P650
.annotate 'line', 328
    new $P651, "Undef"
    .lex "$*PKGDECL", $P651
.annotate 'line', 10
    .local string rx652_tgt
    .local int rx652_pos
    .local int rx652_off
    .local int rx652_eos
    .local int rx652_rep
    .local pmc rx652_cur
    .local pmc rx652_debug
    (rx652_cur, rx652_pos, rx652_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx652_cur
    .local pmc match
    .lex "$/", match
    length rx652_eos, rx652_tgt
    gt rx652_pos, rx652_eos, rx652_done
    set rx652_off, 0
    lt rx652_pos, 2, rx652_start
    sub rx652_off, rx652_pos, 1
    substr rx652_tgt, rx652_tgt, rx652_off
  rx652_start:
    eq $I10, 1, rx652_restart
    if_null rx652_debug, debug_871
    rx652_cur."!cursor_debug"("START", "package_declarator:sym<grammar>")
  debug_871:
    $I10 = self.'from'()
    ne $I10, -1, rxscan656_done
    goto rxscan656_scan
  rxscan656_loop:
    (rx652_pos) = rx652_cur."from"()
    inc rx652_pos
    rx652_cur."!cursor_from"(rx652_pos)
    ge rx652_pos, rx652_eos, rxscan656_done
  rxscan656_scan:
    set_addr $I10, rxscan656_loop
    rx652_cur."!mark_push"(0, rx652_pos, $I10)
  rxscan656_done:
.annotate 'line', 327
    rx652_cur."!cursor_pos"(rx652_pos)
    get_hll_global $P657, ["PAST"], "Stmts"
    $P658 = $P657."new"()
    store_lex "$*PACKAGE-SETUP", $P658
.annotate 'line', 328
    rx652_cur."!cursor_pos"(rx652_pos)
    new $P659, "String"
    assign $P659, "grammar"
    store_lex "$*PKGDECL", $P659
.annotate 'line', 329
  # rx subcapture "sym"
    set_addr $I10, rxcap_660_fail
    rx652_cur."!mark_push"(0, rx652_pos, $I10)
  # rx literal  "grammar"
    add $I11, rx652_pos, 7
    gt $I11, rx652_eos, rx652_fail
    sub $I11, rx652_pos, rx652_off
    substr $S10, rx652_tgt, $I11, 7
    ne $S10, "grammar", rx652_fail
    add rx652_pos, 7
    set_addr $I10, rxcap_660_fail
    ($I12, $I11) = rx652_cur."!mark_peek"($I10)
    rx652_cur."!cursor_pos"($I11)
    ($P10) = rx652_cur."!cursor_start"()
    $P10."!cursor_pass"(rx652_pos, "")
    rx652_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_660_done
  rxcap_660_fail:
    goto rx652_fail
  rxcap_660_done:
  # rx subrule "package_def" subtype=capture negate=
    rx652_cur."!cursor_pos"(rx652_pos)
    $P10 = rx652_cur."package_def"()
    unless $P10, rx652_fail
    rx652_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx652_pos = $P10."pos"()
.annotate 'line', 326
  # rx pass
    rx652_cur."!cursor_pass"(rx652_pos, "package_declarator:sym<grammar>")
    if_null rx652_debug, debug_872
    rx652_cur."!cursor_debug"("PASS", "package_declarator:sym<grammar>", " at pos=", rx652_pos)
  debug_872:
    .return (rx652_cur)
  rx652_restart:
.annotate 'line', 10
    if_null rx652_debug, debug_873
    rx652_cur."!cursor_debug"("NEXT", "package_declarator:sym<grammar>")
  debug_873:
  rx652_fail:
    (rx652_rep, rx652_pos, $I10, $P10) = rx652_cur."!mark_fail"(0)
    lt rx652_pos, -1, rx652_done
    eq rx652_pos, -1, rx652_fail
    jump $I10
  rx652_done:
    rx652_cur."!cursor_fail"()
    if_null rx652_debug, debug_874
    rx652_cur."!cursor_debug"("FAIL", "package_declarator:sym<grammar>")
  debug_874:
    .return (rx652_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<grammar>"  :nsentry("!PREFIX__package_declarator:sym<grammar>") :subid("147_1303340952.947") :method
.annotate 'line', 10
    $P654 = self."!PREFIX__!subrule"("package_def", "grammar")
    new $P655, "ResizablePMCArray"
    push $P655, $P654
    .return ($P655)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<role>"  :subid("148_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 332
    new $P662, "Undef"
    .lex "$*PACKAGE-SETUP", $P662
.annotate 'line', 333
    new $P663, "Undef"
    .lex "$*PKGDECL", $P663
.annotate 'line', 10
    .local string rx664_tgt
    .local int rx664_pos
    .local int rx664_off
    .local int rx664_eos
    .local int rx664_rep
    .local pmc rx664_cur
    .local pmc rx664_debug
    (rx664_cur, rx664_pos, rx664_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx664_cur
    .local pmc match
    .lex "$/", match
    length rx664_eos, rx664_tgt
    gt rx664_pos, rx664_eos, rx664_done
    set rx664_off, 0
    lt rx664_pos, 2, rx664_start
    sub rx664_off, rx664_pos, 1
    substr rx664_tgt, rx664_tgt, rx664_off
  rx664_start:
    eq $I10, 1, rx664_restart
    if_null rx664_debug, debug_875
    rx664_cur."!cursor_debug"("START", "package_declarator:sym<role>")
  debug_875:
    $I10 = self.'from'()
    ne $I10, -1, rxscan668_done
    goto rxscan668_scan
  rxscan668_loop:
    (rx664_pos) = rx664_cur."from"()
    inc rx664_pos
    rx664_cur."!cursor_from"(rx664_pos)
    ge rx664_pos, rx664_eos, rxscan668_done
  rxscan668_scan:
    set_addr $I10, rxscan668_loop
    rx664_cur."!mark_push"(0, rx664_pos, $I10)
  rxscan668_done:
.annotate 'line', 332
    rx664_cur."!cursor_pos"(rx664_pos)
    get_hll_global $P669, ["PAST"], "Stmts"
    $P670 = $P669."new"()
    store_lex "$*PACKAGE-SETUP", $P670
.annotate 'line', 333
    rx664_cur."!cursor_pos"(rx664_pos)
    new $P671, "String"
    assign $P671, "role"
    store_lex "$*PKGDECL", $P671
.annotate 'line', 334
  # rx subcapture "sym"
    set_addr $I10, rxcap_672_fail
    rx664_cur."!mark_push"(0, rx664_pos, $I10)
  # rx literal  "role"
    add $I11, rx664_pos, 4
    gt $I11, rx664_eos, rx664_fail
    sub $I11, rx664_pos, rx664_off
    substr $S10, rx664_tgt, $I11, 4
    ne $S10, "role", rx664_fail
    add rx664_pos, 4
    set_addr $I10, rxcap_672_fail
    ($I12, $I11) = rx664_cur."!mark_peek"($I10)
    rx664_cur."!cursor_pos"($I11)
    ($P10) = rx664_cur."!cursor_start"()
    $P10."!cursor_pass"(rx664_pos, "")
    rx664_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_672_done
  rxcap_672_fail:
    goto rx664_fail
  rxcap_672_done:
  # rx subrule "package_def" subtype=capture negate=
    rx664_cur."!cursor_pos"(rx664_pos)
    $P10 = rx664_cur."package_def"()
    unless $P10, rx664_fail
    rx664_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx664_pos = $P10."pos"()
.annotate 'line', 331
  # rx pass
    rx664_cur."!cursor_pass"(rx664_pos, "package_declarator:sym<role>")
    if_null rx664_debug, debug_876
    rx664_cur."!cursor_debug"("PASS", "package_declarator:sym<role>", " at pos=", rx664_pos)
  debug_876:
    .return (rx664_cur)
  rx664_restart:
.annotate 'line', 10
    if_null rx664_debug, debug_877
    rx664_cur."!cursor_debug"("NEXT", "package_declarator:sym<role>")
  debug_877:
  rx664_fail:
    (rx664_rep, rx664_pos, $I10, $P10) = rx664_cur."!mark_fail"(0)
    lt rx664_pos, -1, rx664_done
    eq rx664_pos, -1, rx664_fail
    jump $I10
  rx664_done:
    rx664_cur."!cursor_fail"()
    if_null rx664_debug, debug_878
    rx664_cur."!cursor_debug"("FAIL", "package_declarator:sym<role>")
  debug_878:
    .return (rx664_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<role>"  :nsentry("!PREFIX__package_declarator:sym<role>") :subid("149_1303340952.947") :method
.annotate 'line', 10
    $P666 = self."!PREFIX__!subrule"("package_def", "role")
    new $P667, "ResizablePMCArray"
    push $P667, $P666
    .return ($P667)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<native>"  :subid("150_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 337
    new $P674, "Undef"
    .lex "$*PACKAGE-SETUP", $P674
.annotate 'line', 338
    new $P675, "Undef"
    .lex "$*PKGDECL", $P675
.annotate 'line', 10
    .local string rx676_tgt
    .local int rx676_pos
    .local int rx676_off
    .local int rx676_eos
    .local int rx676_rep
    .local pmc rx676_cur
    .local pmc rx676_debug
    (rx676_cur, rx676_pos, rx676_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx676_cur
    .local pmc match
    .lex "$/", match
    length rx676_eos, rx676_tgt
    gt rx676_pos, rx676_eos, rx676_done
    set rx676_off, 0
    lt rx676_pos, 2, rx676_start
    sub rx676_off, rx676_pos, 1
    substr rx676_tgt, rx676_tgt, rx676_off
  rx676_start:
    eq $I10, 1, rx676_restart
    if_null rx676_debug, debug_879
    rx676_cur."!cursor_debug"("START", "package_declarator:sym<native>")
  debug_879:
    $I10 = self.'from'()
    ne $I10, -1, rxscan680_done
    goto rxscan680_scan
  rxscan680_loop:
    (rx676_pos) = rx676_cur."from"()
    inc rx676_pos
    rx676_cur."!cursor_from"(rx676_pos)
    ge rx676_pos, rx676_eos, rxscan680_done
  rxscan680_scan:
    set_addr $I10, rxscan680_loop
    rx676_cur."!mark_push"(0, rx676_pos, $I10)
  rxscan680_done:
.annotate 'line', 337
    rx676_cur."!cursor_pos"(rx676_pos)
    get_hll_global $P681, ["PAST"], "Stmts"
    $P682 = $P681."new"()
    store_lex "$*PACKAGE-SETUP", $P682
.annotate 'line', 338
    rx676_cur."!cursor_pos"(rx676_pos)
    new $P683, "String"
    assign $P683, "native"
    store_lex "$*PKGDECL", $P683
.annotate 'line', 339
  # rx subcapture "sym"
    set_addr $I10, rxcap_684_fail
    rx676_cur."!mark_push"(0, rx676_pos, $I10)
  # rx literal  "native"
    add $I11, rx676_pos, 6
    gt $I11, rx676_eos, rx676_fail
    sub $I11, rx676_pos, rx676_off
    substr $S10, rx676_tgt, $I11, 6
    ne $S10, "native", rx676_fail
    add rx676_pos, 6
    set_addr $I10, rxcap_684_fail
    ($I12, $I11) = rx676_cur."!mark_peek"($I10)
    rx676_cur."!cursor_pos"($I11)
    ($P10) = rx676_cur."!cursor_start"()
    $P10."!cursor_pass"(rx676_pos, "")
    rx676_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_684_done
  rxcap_684_fail:
    goto rx676_fail
  rxcap_684_done:
  # rx subrule "package_def" subtype=capture negate=
    rx676_cur."!cursor_pos"(rx676_pos)
    $P10 = rx676_cur."package_def"()
    unless $P10, rx676_fail
    rx676_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx676_pos = $P10."pos"()
.annotate 'line', 336
  # rx pass
    rx676_cur."!cursor_pass"(rx676_pos, "package_declarator:sym<native>")
    if_null rx676_debug, debug_880
    rx676_cur."!cursor_debug"("PASS", "package_declarator:sym<native>", " at pos=", rx676_pos)
  debug_880:
    .return (rx676_cur)
  rx676_restart:
.annotate 'line', 10
    if_null rx676_debug, debug_881
    rx676_cur."!cursor_debug"("NEXT", "package_declarator:sym<native>")
  debug_881:
  rx676_fail:
    (rx676_rep, rx676_pos, $I10, $P10) = rx676_cur."!mark_fail"(0)
    lt rx676_pos, -1, rx676_done
    eq rx676_pos, -1, rx676_fail
    jump $I10
  rx676_done:
    rx676_cur."!cursor_fail"()
    if_null rx676_debug, debug_882
    rx676_cur."!cursor_debug"("FAIL", "package_declarator:sym<native>")
  debug_882:
    .return (rx676_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<native>"  :nsentry("!PREFIX__package_declarator:sym<native>") :subid("151_1303340952.947") :method
.annotate 'line', 10
    $P678 = self."!PREFIX__!subrule"("package_def", "native")
    new $P679, "ResizablePMCArray"
    push $P679, $P678
    .return ($P679)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_def"  :subid("152_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .const 'Sub' $P709 = "154_1303340952.947" 
    capture_lex $P709
.annotate 'line', 343
    new $P686, "Undef"
    .lex "$*PACKAGE", $P686
.annotate 'line', 344
    $P687 = root_new ['parrot';'Hash']
    .lex "%*ATTR-CHECK", $P687
.annotate 'line', 10
    .local string rx688_tgt
    .local int rx688_pos
    .local int rx688_off
    .local int rx688_eos
    .local int rx688_rep
    .local pmc rx688_cur
    .local pmc rx688_debug
    (rx688_cur, rx688_pos, rx688_tgt, $I10) = self."!cursor_start"()
    rx688_cur."!cursor_caparray"("repr", "parent", "role")
    .lex unicode:"$\x{a2}", rx688_cur
    .local pmc match
    .lex "$/", match
    length rx688_eos, rx688_tgt
    gt rx688_pos, rx688_eos, rx688_done
    set rx688_off, 0
    lt rx688_pos, 2, rx688_start
    sub rx688_off, rx688_pos, 1
    substr rx688_tgt, rx688_tgt, rx688_off
  rx688_start:
    eq $I10, 1, rx688_restart
    if_null rx688_debug, debug_883
    rx688_cur."!cursor_debug"("START", "package_def")
  debug_883:
    $I10 = self.'from'()
    ne $I10, -1, rxscan692_done
    goto rxscan692_scan
  rxscan692_loop:
    (rx688_pos) = rx688_cur."from"()
    inc rx688_pos
    rx688_cur."!cursor_from"(rx688_pos)
    ge rx688_pos, rx688_eos, rxscan692_done
  rxscan692_scan:
    set_addr $I10, rxscan692_loop
    rx688_cur."!mark_push"(0, rx688_pos, $I10)
  rxscan692_done:
.annotate 'line', 342
  # rx subrule "ws" subtype=method negate=
    rx688_cur."!cursor_pos"(rx688_pos)
    $P10 = rx688_cur."ws"()
    unless $P10, rx688_fail
    rx688_pos = $P10."pos"()
.annotate 'line', 343
    rx688_cur."!cursor_pos"(rx688_pos)
    find_lex $P694, "$*PACKAGE"
    unless_null $P694, vivify_884
    get_hll_global $P694, "$PACKAGE"
    unless_null $P694, vivify_885
    die "Contextual $*PACKAGE not found"
  vivify_885:
  vivify_884:
  # rx subrule "ws" subtype=method negate=
    rx688_cur."!cursor_pos"(rx688_pos)
    $P10 = rx688_cur."ws"()
    unless $P10, rx688_fail
    rx688_pos = $P10."pos"()
.annotate 'line', 344
    rx688_cur."!cursor_pos"(rx688_pos)
    find_lex $P696, "%*ATTR-CHECK"
    unless_null $P696, vivify_886
    get_hll_global $P696, "%ATTR-CHECK"
    unless_null $P696, vivify_887
    die "Contextual %*ATTR-CHECK not found"
  vivify_887:
  vivify_886:
  # rx subrule "ws" subtype=method negate=
    rx688_cur."!cursor_pos"(rx688_pos)
    $P10 = rx688_cur."ws"()
    unless $P10, rx688_fail
    rx688_pos = $P10."pos"()
.annotate 'line', 346
  # rx subrule "name" subtype=capture negate=
    rx688_cur."!cursor_pos"(rx688_pos)
    $P10 = rx688_cur."name"()
    unless $P10, rx688_fail
    rx688_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx688_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx688_cur."!cursor_pos"(rx688_pos)
    $P10 = rx688_cur."ws"()
    unless $P10, rx688_fail
    rx688_pos = $P10."pos"()
.annotate 'line', 347
  # rx rxquantr699 ** 0..1
    set_addr $I10, rxquantr699_done
    rx688_cur."!mark_push"(0, rx688_pos, $I10)
  rxquantr699_loop:
  # rx subrule "ws" subtype=method negate=
    rx688_cur."!cursor_pos"(rx688_pos)
    $P10 = rx688_cur."ws"()
    unless $P10, rx688_fail
    rx688_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx688_pos, 2
    gt $I11, rx688_eos, rx688_fail
    sub $I11, rx688_pos, rx688_off
    substr $S10, rx688_tgt, $I11, 2
    ne $S10, "is", rx688_fail
    add rx688_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx688_cur."!cursor_pos"(rx688_pos)
    $P10 = rx688_cur."ws"()
    unless $P10, rx688_fail
    rx688_pos = $P10."pos"()
  # rx literal  "repr("
    add $I11, rx688_pos, 5
    gt $I11, rx688_eos, rx688_fail
    sub $I11, rx688_pos, rx688_off
    substr $S10, rx688_tgt, $I11, 5
    ne $S10, "repr(", rx688_fail
    add rx688_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx688_cur."!cursor_pos"(rx688_pos)
    $P10 = rx688_cur."ws"()
    unless $P10, rx688_fail
    rx688_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx688_cur."!cursor_pos"(rx688_pos)
    $P10 = rx688_cur."quote_EXPR"()
    unless $P10, rx688_fail
    rx688_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("repr")
    rx688_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx688_cur."!cursor_pos"(rx688_pos)
    $P10 = rx688_cur."ws"()
    unless $P10, rx688_fail
    rx688_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx688_pos, 1
    gt $I11, rx688_eos, rx688_fail
    sub $I11, rx688_pos, rx688_off
    ord $I11, rx688_tgt, $I11
    ne $I11, 41, rx688_fail
    add rx688_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx688_cur."!cursor_pos"(rx688_pos)
    $P10 = rx688_cur."ws"()
    unless $P10, rx688_fail
    rx688_pos = $P10."pos"()
    set_addr $I10, rxquantr699_done
    (rx688_rep) = rx688_cur."!mark_commit"($I10)
  rxquantr699_done:
  # rx subrule "ws" subtype=method negate=
    rx688_cur."!cursor_pos"(rx688_pos)
    $P10 = rx688_cur."ws"()
    unless $P10, rx688_fail
    rx688_pos = $P10."pos"()
.annotate 'line', 349
    rx688_cur."!cursor_pos"(rx688_pos)
    find_lex $P706, unicode:"$\x{a2}"
    $P707 = $P706."MATCH"()
    store_lex "$/", $P707
    .const 'Sub' $P709 = "154_1303340952.947" 
    capture_lex $P709
    $P735 = $P709()
.annotate 'line', 358
  # rx subrule "ws" subtype=method negate=
    rx688_cur."!cursor_pos"(rx688_pos)
    $P10 = rx688_cur."ws"()
    unless $P10, rx688_fail
    rx688_pos = $P10."pos"()
.annotate 'line', 360
  # rx rxquantr737 ** 0..1
    set_addr $I10, rxquantr737_done
    rx688_cur."!mark_push"(0, rx688_pos, $I10)
  rxquantr737_loop:
  # rx subrule "ws" subtype=method negate=
    rx688_cur."!cursor_pos"(rx688_pos)
    $P10 = rx688_cur."ws"()
    unless $P10, rx688_fail
    rx688_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx688_pos, 2
    gt $I11, rx688_eos, rx688_fail
    sub $I11, rx688_pos, rx688_off
    substr $S10, rx688_tgt, $I11, 2
    ne $S10, "is", rx688_fail
    add rx688_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx688_cur."!cursor_pos"(rx688_pos)
    $P10 = rx688_cur."ws"()
    unless $P10, rx688_fail
    rx688_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx688_cur."!cursor_pos"(rx688_pos)
    $P10 = rx688_cur."name"()
    unless $P10, rx688_fail
    rx688_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parent")
    rx688_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx688_cur."!cursor_pos"(rx688_pos)
    $P10 = rx688_cur."ws"()
    unless $P10, rx688_fail
    rx688_pos = $P10."pos"()
    set_addr $I10, rxquantr737_done
    (rx688_rep) = rx688_cur."!mark_commit"($I10)
  rxquantr737_done:
  # rx subrule "ws" subtype=method negate=
    rx688_cur."!cursor_pos"(rx688_pos)
    $P10 = rx688_cur."ws"()
    unless $P10, rx688_fail
    rx688_pos = $P10."pos"()
.annotate 'line', 361
  # rx rxquantr742 ** 0..*
    set_addr $I10, rxquantr742_done
    rx688_cur."!mark_push"(0, rx688_pos, $I10)
  rxquantr742_loop:
  # rx subrule "ws" subtype=method negate=
    rx688_cur."!cursor_pos"(rx688_pos)
    $P10 = rx688_cur."ws"()
    unless $P10, rx688_fail
    rx688_pos = $P10."pos"()
  # rx literal  "does"
    add $I11, rx688_pos, 4
    gt $I11, rx688_eos, rx688_fail
    sub $I11, rx688_pos, rx688_off
    substr $S10, rx688_tgt, $I11, 4
    ne $S10, "does", rx688_fail
    add rx688_pos, 4
  # rx subrule "ws" subtype=method negate=
    rx688_cur."!cursor_pos"(rx688_pos)
    $P10 = rx688_cur."ws"()
    unless $P10, rx688_fail
    rx688_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx688_cur."!cursor_pos"(rx688_pos)
    $P10 = rx688_cur."name"()
    unless $P10, rx688_fail
    rx688_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("role")
    rx688_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx688_cur."!cursor_pos"(rx688_pos)
    $P10 = rx688_cur."ws"()
    unless $P10, rx688_fail
    rx688_pos = $P10."pos"()
    set_addr $I10, rxquantr742_done
    (rx688_rep) = rx688_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr742_done
    rx688_cur."!mark_push"(rx688_rep, rx688_pos, $I10)
    goto rxquantr742_loop
  rxquantr742_done:
  # rx subrule "ws" subtype=method negate=
    rx688_cur."!cursor_pos"(rx688_pos)
    $P10 = rx688_cur."ws"()
    unless $P10, rx688_fail
    rx688_pos = $P10."pos"()
  alt747_0:
.annotate 'line', 362
    set_addr $I10, alt747_1
    rx688_cur."!mark_push"(0, rx688_pos, $I10)
.annotate 'line', 363
  # rx subrule "ws" subtype=method negate=
    rx688_cur."!cursor_pos"(rx688_pos)
    $P10 = rx688_cur."ws"()
    unless $P10, rx688_fail
    rx688_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx688_pos, 1
    gt $I11, rx688_eos, rx688_fail
    sub $I11, rx688_pos, rx688_off
    ord $I11, rx688_tgt, $I11
    ne $I11, 59, rx688_fail
    add rx688_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx688_cur."!cursor_pos"(rx688_pos)
    $P10 = rx688_cur."ws"()
    unless $P10, rx688_fail
    rx688_pos = $P10."pos"()
  # rx subrule "comp_unit" subtype=capture negate=
    rx688_cur."!cursor_pos"(rx688_pos)
    $P10 = rx688_cur."comp_unit"()
    unless $P10, rx688_fail
    rx688_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("comp_unit")
    rx688_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx688_cur."!cursor_pos"(rx688_pos)
    $P10 = rx688_cur."ws"()
    unless $P10, rx688_fail
    rx688_pos = $P10."pos"()
    goto alt747_end
  alt747_1:
    set_addr $I10, alt747_2
    rx688_cur."!mark_push"(0, rx688_pos, $I10)
.annotate 'line', 364
  # rx subrule "ws" subtype=method negate=
    rx688_cur."!cursor_pos"(rx688_pos)
    $P10 = rx688_cur."ws"()
    unless $P10, rx688_fail
    rx688_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx688_pos, rx688_off
    substr $S10, rx688_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx688_fail
  # rx subrule "ws" subtype=method negate=
    rx688_cur."!cursor_pos"(rx688_pos)
    $P10 = rx688_cur."ws"()
    unless $P10, rx688_fail
    rx688_pos = $P10."pos"()
  # rx subrule "block" subtype=capture negate=
    rx688_cur."!cursor_pos"(rx688_pos)
    $P10 = rx688_cur."block"()
    unless $P10, rx688_fail
    rx688_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx688_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx688_cur."!cursor_pos"(rx688_pos)
    $P10 = rx688_cur."ws"()
    unless $P10, rx688_fail
    rx688_pos = $P10."pos"()
    goto alt747_end
  alt747_2:
.annotate 'line', 365
  # rx subrule "ws" subtype=method negate=
    rx688_cur."!cursor_pos"(rx688_pos)
    $P10 = rx688_cur."ws"()
    unless $P10, rx688_fail
    rx688_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx688_cur."!cursor_pos"(rx688_pos)
    $P10 = rx688_cur."panic"("Malformed package declaration")
    unless $P10, rx688_fail
    rx688_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx688_cur."!cursor_pos"(rx688_pos)
    $P10 = rx688_cur."ws"()
    unless $P10, rx688_fail
    rx688_pos = $P10."pos"()
  alt747_end:
.annotate 'line', 366
  # rx subrule "ws" subtype=method negate=
    rx688_cur."!cursor_pos"(rx688_pos)
    $P10 = rx688_cur."ws"()
    unless $P10, rx688_fail
    rx688_pos = $P10."pos"()
.annotate 'line', 342
  # rx pass
    rx688_cur."!cursor_pass"(rx688_pos, "package_def")
    if_null rx688_debug, debug_909
    rx688_cur."!cursor_debug"("PASS", "package_def", " at pos=", rx688_pos)
  debug_909:
    .return (rx688_cur)
  rx688_restart:
.annotate 'line', 10
    if_null rx688_debug, debug_910
    rx688_cur."!cursor_debug"("NEXT", "package_def")
  debug_910:
  rx688_fail:
    (rx688_rep, rx688_pos, $I10, $P10) = rx688_cur."!mark_fail"(0)
    lt rx688_pos, -1, rx688_done
    eq rx688_pos, -1, rx688_fail
    jump $I10
  rx688_done:
    rx688_cur."!cursor_fail"()
    if_null rx688_debug, debug_911
    rx688_cur."!cursor_debug"("FAIL", "package_def")
  debug_911:
    .return (rx688_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_def"  :nsentry("!PREFIX__package_def") :subid("153_1303340952.947") :method
.annotate 'line', 10
    $P690 = self."!PREFIX__!subrule"("ws", "")
    new $P691, "ResizablePMCArray"
    push $P691, $P690
    .return ($P691)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block708"  :anon :subid("154_1303340952.947") :outer("152_1303340952.947")
.annotate 'line', 352
    $P710 = root_new ['parrot';'Hash']
    .lex "%args", $P710
.annotate 'line', 349
    find_lex $P711, "%args"
    unless_null $P711, vivify_888
    $P711 = root_new ['parrot';'Hash']
  vivify_888:
.annotate 'line', 353
    find_lex $P712, "$/"
    unless_null $P712, vivify_889
    $P712 = root_new ['parrot';'Hash']
  vivify_889:
    set $P713, $P712["name"]
    unless_null $P713, vivify_890
    new $P713, "Undef"
  vivify_890:
    set $S714, $P713
    new $P715, 'String'
    set $P715, $S714
    find_lex $P716, "%args"
    unless_null $P716, vivify_891
    $P716 = root_new ['parrot';'Hash']
    store_lex "%args", $P716
  vivify_891:
    set $P716["name"], $P715
.annotate 'line', 354
    find_lex $P718, "$/"
    unless_null $P718, vivify_892
    $P718 = root_new ['parrot';'Hash']
  vivify_892:
    set $P719, $P718["repr"]
    unless_null $P719, vivify_893
    new $P719, "Undef"
  vivify_893:
    unless $P719, if_717_end
.annotate 'line', 355
    find_lex $P720, "$/"
    unless_null $P720, vivify_894
    $P720 = root_new ['parrot';'Hash']
  vivify_894:
    set $P721, $P720["repr"]
    unless_null $P721, vivify_895
    $P721 = root_new ['parrot';'ResizablePMCArray']
  vivify_895:
    set $P722, $P721[0]
    unless_null $P722, vivify_896
    $P722 = root_new ['parrot';'Hash']
  vivify_896:
    set $P723, $P722["quote_delimited"]
    unless_null $P723, vivify_897
    $P723 = root_new ['parrot';'Hash']
  vivify_897:
    set $P724, $P723["quote_atom"]
    unless_null $P724, vivify_898
    $P724 = root_new ['parrot';'ResizablePMCArray']
  vivify_898:
    set $P725, $P724[0]
    unless_null $P725, vivify_899
    new $P725, "Undef"
  vivify_899:
    set $S726, $P725
    new $P727, 'String'
    set $P727, $S726
    find_lex $P728, "%args"
    unless_null $P728, vivify_900
    $P728 = root_new ['parrot';'Hash']
    store_lex "%args", $P728
  vivify_900:
    set $P728["repr"], $P727
  if_717_end:
.annotate 'line', 357
    find_dynamic_lex $P729, "$*SC"
    unless_null $P729, vivify_901
    get_hll_global $P729, "$SC"
    unless_null $P729, vivify_902
    die "Contextual $*SC not found"
  vivify_902:
  vivify_901:
    find_dynamic_lex $P730, "$*PKGDECL"
    unless_null $P730, vivify_903
    get_hll_global $P730, "$PKGDECL"
    unless_null $P730, vivify_904
    die "Contextual $*PKGDECL not found"
  vivify_904:
  vivify_903:
    find_dynamic_lex $P731, "%*HOW"
    unless_null $P731, vivify_905
    get_hll_global $P731, "%HOW"
    unless_null $P731, vivify_906
    die "Contextual %*HOW not found"
  vivify_906:
  vivify_905:
    set $P732, $P731[$P730]
    unless_null $P732, vivify_907
    new $P732, "Undef"
  vivify_907:
    find_lex $P733, "%args"
    unless_null $P733, vivify_908
    $P733 = root_new ['parrot';'Hash']
  vivify_908:
    $P734 = $P729."pkg_create_mo"($P732, $P733 :flat)
    store_dynamic_lex "$*PACKAGE", $P734
.annotate 'line', 349
    .return ($P734)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator"  :subid("155_1303340952.947")
    .param pmc param_758
.annotate 'line', 369
    .lex "self", param_758
    $P759 = param_758."!protoregex"("scope_declarator")
    .return ($P759)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator"  :subid("156_1303340952.947")
    .param pmc param_761
.annotate 'line', 369
    .lex "self", param_761
    $P762 = param_761."!PREFIX__!protoregex"("scope_declarator")
    .return ($P762)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<my>"  :subid("157_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx764_tgt
    .local int rx764_pos
    .local int rx764_off
    .local int rx764_eos
    .local int rx764_rep
    .local pmc rx764_cur
    .local pmc rx764_debug
    (rx764_cur, rx764_pos, rx764_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx764_cur
    .local pmc match
    .lex "$/", match
    length rx764_eos, rx764_tgt
    gt rx764_pos, rx764_eos, rx764_done
    set rx764_off, 0
    lt rx764_pos, 2, rx764_start
    sub rx764_off, rx764_pos, 1
    substr rx764_tgt, rx764_tgt, rx764_off
  rx764_start:
    eq $I10, 1, rx764_restart
    if_null rx764_debug, debug_912
    rx764_cur."!cursor_debug"("START", "scope_declarator:sym<my>")
  debug_912:
    $I10 = self.'from'()
    ne $I10, -1, rxscan768_done
    goto rxscan768_scan
  rxscan768_loop:
    (rx764_pos) = rx764_cur."from"()
    inc rx764_pos
    rx764_cur."!cursor_from"(rx764_pos)
    ge rx764_pos, rx764_eos, rxscan768_done
  rxscan768_scan:
    set_addr $I10, rxscan768_loop
    rx764_cur."!mark_push"(0, rx764_pos, $I10)
  rxscan768_done:
.annotate 'line', 370
  # rx subcapture "sym"
    set_addr $I10, rxcap_769_fail
    rx764_cur."!mark_push"(0, rx764_pos, $I10)
  # rx literal  "my"
    add $I11, rx764_pos, 2
    gt $I11, rx764_eos, rx764_fail
    sub $I11, rx764_pos, rx764_off
    substr $S10, rx764_tgt, $I11, 2
    ne $S10, "my", rx764_fail
    add rx764_pos, 2
    set_addr $I10, rxcap_769_fail
    ($I12, $I11) = rx764_cur."!mark_peek"($I10)
    rx764_cur."!cursor_pos"($I11)
    ($P10) = rx764_cur."!cursor_start"()
    $P10."!cursor_pass"(rx764_pos, "")
    rx764_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_769_done
  rxcap_769_fail:
    goto rx764_fail
  rxcap_769_done:
  # rx subrule "scoped" subtype=capture negate=
    rx764_cur."!cursor_pos"(rx764_pos)
    $P10 = rx764_cur."scoped"("my")
    unless $P10, rx764_fail
    rx764_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx764_pos = $P10."pos"()
  # rx pass
    rx764_cur."!cursor_pass"(rx764_pos, "scope_declarator:sym<my>")
    if_null rx764_debug, debug_913
    rx764_cur."!cursor_debug"("PASS", "scope_declarator:sym<my>", " at pos=", rx764_pos)
  debug_913:
    .return (rx764_cur)
  rx764_restart:
.annotate 'line', 10
    if_null rx764_debug, debug_914
    rx764_cur."!cursor_debug"("NEXT", "scope_declarator:sym<my>")
  debug_914:
  rx764_fail:
    (rx764_rep, rx764_pos, $I10, $P10) = rx764_cur."!mark_fail"(0)
    lt rx764_pos, -1, rx764_done
    eq rx764_pos, -1, rx764_fail
    jump $I10
  rx764_done:
    rx764_cur."!cursor_fail"()
    if_null rx764_debug, debug_915
    rx764_cur."!cursor_debug"("FAIL", "scope_declarator:sym<my>")
  debug_915:
    .return (rx764_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<my>"  :nsentry("!PREFIX__scope_declarator:sym<my>") :subid("158_1303340952.947") :method
.annotate 'line', 10
    $P766 = self."!PREFIX__!subrule"("scoped", "my")
    new $P767, "ResizablePMCArray"
    push $P767, $P766
    .return ($P767)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<our>"  :subid("159_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx771_tgt
    .local int rx771_pos
    .local int rx771_off
    .local int rx771_eos
    .local int rx771_rep
    .local pmc rx771_cur
    .local pmc rx771_debug
    (rx771_cur, rx771_pos, rx771_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx771_cur
    .local pmc match
    .lex "$/", match
    length rx771_eos, rx771_tgt
    gt rx771_pos, rx771_eos, rx771_done
    set rx771_off, 0
    lt rx771_pos, 2, rx771_start
    sub rx771_off, rx771_pos, 1
    substr rx771_tgt, rx771_tgt, rx771_off
  rx771_start:
    eq $I10, 1, rx771_restart
    if_null rx771_debug, debug_916
    rx771_cur."!cursor_debug"("START", "scope_declarator:sym<our>")
  debug_916:
    $I10 = self.'from'()
    ne $I10, -1, rxscan775_done
    goto rxscan775_scan
  rxscan775_loop:
    (rx771_pos) = rx771_cur."from"()
    inc rx771_pos
    rx771_cur."!cursor_from"(rx771_pos)
    ge rx771_pos, rx771_eos, rxscan775_done
  rxscan775_scan:
    set_addr $I10, rxscan775_loop
    rx771_cur."!mark_push"(0, rx771_pos, $I10)
  rxscan775_done:
.annotate 'line', 371
  # rx subcapture "sym"
    set_addr $I10, rxcap_776_fail
    rx771_cur."!mark_push"(0, rx771_pos, $I10)
  # rx literal  "our"
    add $I11, rx771_pos, 3
    gt $I11, rx771_eos, rx771_fail
    sub $I11, rx771_pos, rx771_off
    substr $S10, rx771_tgt, $I11, 3
    ne $S10, "our", rx771_fail
    add rx771_pos, 3
    set_addr $I10, rxcap_776_fail
    ($I12, $I11) = rx771_cur."!mark_peek"($I10)
    rx771_cur."!cursor_pos"($I11)
    ($P10) = rx771_cur."!cursor_start"()
    $P10."!cursor_pass"(rx771_pos, "")
    rx771_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_776_done
  rxcap_776_fail:
    goto rx771_fail
  rxcap_776_done:
  # rx subrule "scoped" subtype=capture negate=
    rx771_cur."!cursor_pos"(rx771_pos)
    $P10 = rx771_cur."scoped"("our")
    unless $P10, rx771_fail
    rx771_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx771_pos = $P10."pos"()
  # rx pass
    rx771_cur."!cursor_pass"(rx771_pos, "scope_declarator:sym<our>")
    if_null rx771_debug, debug_917
    rx771_cur."!cursor_debug"("PASS", "scope_declarator:sym<our>", " at pos=", rx771_pos)
  debug_917:
    .return (rx771_cur)
  rx771_restart:
.annotate 'line', 10
    if_null rx771_debug, debug_918
    rx771_cur."!cursor_debug"("NEXT", "scope_declarator:sym<our>")
  debug_918:
  rx771_fail:
    (rx771_rep, rx771_pos, $I10, $P10) = rx771_cur."!mark_fail"(0)
    lt rx771_pos, -1, rx771_done
    eq rx771_pos, -1, rx771_fail
    jump $I10
  rx771_done:
    rx771_cur."!cursor_fail"()
    if_null rx771_debug, debug_919
    rx771_cur."!cursor_debug"("FAIL", "scope_declarator:sym<our>")
  debug_919:
    .return (rx771_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<our>"  :nsentry("!PREFIX__scope_declarator:sym<our>") :subid("160_1303340952.947") :method
.annotate 'line', 10
    $P773 = self."!PREFIX__!subrule"("scoped", "our")
    new $P774, "ResizablePMCArray"
    push $P774, $P773
    .return ($P774)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<has>"  :subid("161_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx778_tgt
    .local int rx778_pos
    .local int rx778_off
    .local int rx778_eos
    .local int rx778_rep
    .local pmc rx778_cur
    .local pmc rx778_debug
    (rx778_cur, rx778_pos, rx778_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx778_cur
    .local pmc match
    .lex "$/", match
    length rx778_eos, rx778_tgt
    gt rx778_pos, rx778_eos, rx778_done
    set rx778_off, 0
    lt rx778_pos, 2, rx778_start
    sub rx778_off, rx778_pos, 1
    substr rx778_tgt, rx778_tgt, rx778_off
  rx778_start:
    eq $I10, 1, rx778_restart
    if_null rx778_debug, debug_920
    rx778_cur."!cursor_debug"("START", "scope_declarator:sym<has>")
  debug_920:
    $I10 = self.'from'()
    ne $I10, -1, rxscan782_done
    goto rxscan782_scan
  rxscan782_loop:
    (rx778_pos) = rx778_cur."from"()
    inc rx778_pos
    rx778_cur."!cursor_from"(rx778_pos)
    ge rx778_pos, rx778_eos, rxscan782_done
  rxscan782_scan:
    set_addr $I10, rxscan782_loop
    rx778_cur."!mark_push"(0, rx778_pos, $I10)
  rxscan782_done:
.annotate 'line', 372
  # rx subcapture "sym"
    set_addr $I10, rxcap_783_fail
    rx778_cur."!mark_push"(0, rx778_pos, $I10)
  # rx literal  "has"
    add $I11, rx778_pos, 3
    gt $I11, rx778_eos, rx778_fail
    sub $I11, rx778_pos, rx778_off
    substr $S10, rx778_tgt, $I11, 3
    ne $S10, "has", rx778_fail
    add rx778_pos, 3
    set_addr $I10, rxcap_783_fail
    ($I12, $I11) = rx778_cur."!mark_peek"($I10)
    rx778_cur."!cursor_pos"($I11)
    ($P10) = rx778_cur."!cursor_start"()
    $P10."!cursor_pass"(rx778_pos, "")
    rx778_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_783_done
  rxcap_783_fail:
    goto rx778_fail
  rxcap_783_done:
  # rx subrule "scoped" subtype=capture negate=
    rx778_cur."!cursor_pos"(rx778_pos)
    $P10 = rx778_cur."scoped"("has")
    unless $P10, rx778_fail
    rx778_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx778_pos = $P10."pos"()
  # rx pass
    rx778_cur."!cursor_pass"(rx778_pos, "scope_declarator:sym<has>")
    if_null rx778_debug, debug_921
    rx778_cur."!cursor_debug"("PASS", "scope_declarator:sym<has>", " at pos=", rx778_pos)
  debug_921:
    .return (rx778_cur)
  rx778_restart:
.annotate 'line', 10
    if_null rx778_debug, debug_922
    rx778_cur."!cursor_debug"("NEXT", "scope_declarator:sym<has>")
  debug_922:
  rx778_fail:
    (rx778_rep, rx778_pos, $I10, $P10) = rx778_cur."!mark_fail"(0)
    lt rx778_pos, -1, rx778_done
    eq rx778_pos, -1, rx778_fail
    jump $I10
  rx778_done:
    rx778_cur."!cursor_fail"()
    if_null rx778_debug, debug_923
    rx778_cur."!cursor_debug"("FAIL", "scope_declarator:sym<has>")
  debug_923:
    .return (rx778_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<has>"  :nsentry("!PREFIX__scope_declarator:sym<has>") :subid("162_1303340952.947") :method
.annotate 'line', 10
    $P780 = self."!PREFIX__!subrule"("scoped", "has")
    new $P781, "ResizablePMCArray"
    push $P781, $P780
    .return ($P781)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scoped"  :subid("163_1303340952.947") :method :outer("12_1303340952.947")
    .param pmc param_785
.annotate 'line', 374
    .lex "$*SCOPE", param_785
.annotate 'line', 10
    .local string rx786_tgt
    .local int rx786_pos
    .local int rx786_off
    .local int rx786_eos
    .local int rx786_rep
    .local pmc rx786_cur
    .local pmc rx786_debug
    (rx786_cur, rx786_pos, rx786_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx786_cur
    .local pmc match
    .lex "$/", match
    length rx786_eos, rx786_tgt
    gt rx786_pos, rx786_eos, rx786_done
    set rx786_off, 0
    lt rx786_pos, 2, rx786_start
    sub rx786_off, rx786_pos, 1
    substr rx786_tgt, rx786_tgt, rx786_off
  rx786_start:
    eq $I10, 1, rx786_restart
    if_null rx786_debug, debug_924
    rx786_cur."!cursor_debug"("START", "scoped")
  debug_924:
    $I10 = self.'from'()
    ne $I10, -1, rxscan792_done
    goto rxscan792_scan
  rxscan792_loop:
    (rx786_pos) = rx786_cur."from"()
    inc rx786_pos
    rx786_cur."!cursor_from"(rx786_pos)
    ge rx786_pos, rx786_eos, rxscan792_done
  rxscan792_scan:
    set_addr $I10, rxscan792_loop
    rx786_cur."!mark_push"(0, rx786_pos, $I10)
  rxscan792_done:
  alt793_0:
.annotate 'line', 374
    set_addr $I10, alt793_1
    rx786_cur."!mark_push"(0, rx786_pos, $I10)
.annotate 'line', 375
  # rx subrule "ws" subtype=method negate=
    rx786_cur."!cursor_pos"(rx786_pos)
    $P10 = rx786_cur."ws"()
    unless $P10, rx786_fail
    rx786_pos = $P10."pos"()
  # rx subrule "declarator" subtype=capture negate=
    rx786_cur."!cursor_pos"(rx786_pos)
    $P10 = rx786_cur."declarator"()
    unless $P10, rx786_fail
    rx786_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx786_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx786_cur."!cursor_pos"(rx786_pos)
    $P10 = rx786_cur."ws"()
    unless $P10, rx786_fail
    rx786_pos = $P10."pos"()
    goto alt793_end
  alt793_1:
    set_addr $I10, alt793_2
    rx786_cur."!mark_push"(0, rx786_pos, $I10)
.annotate 'line', 376
  # rx subrule "ws" subtype=method negate=
    rx786_cur."!cursor_pos"(rx786_pos)
    $P10 = rx786_cur."ws"()
    unless $P10, rx786_fail
    rx786_pos = $P10."pos"()
  # rx subrule "multi_declarator" subtype=capture negate=
    rx786_cur."!cursor_pos"(rx786_pos)
    $P10 = rx786_cur."multi_declarator"()
    unless $P10, rx786_fail
    rx786_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx786_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx786_cur."!cursor_pos"(rx786_pos)
    $P10 = rx786_cur."ws"()
    unless $P10, rx786_fail
    rx786_pos = $P10."pos"()
    goto alt793_end
  alt793_2:
.annotate 'line', 377
  # rx subrule "ws" subtype=method negate=
    rx786_cur."!cursor_pos"(rx786_pos)
    $P10 = rx786_cur."ws"()
    unless $P10, rx786_fail
    rx786_pos = $P10."pos"()
  # rx subrule "package_declarator" subtype=capture negate=
    rx786_cur."!cursor_pos"(rx786_pos)
    $P10 = rx786_cur."package_declarator"()
    unless $P10, rx786_fail
    rx786_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx786_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx786_cur."!cursor_pos"(rx786_pos)
    $P10 = rx786_cur."ws"()
    unless $P10, rx786_fail
    rx786_pos = $P10."pos"()
  alt793_end:
.annotate 'line', 374
  # rx pass
    rx786_cur."!cursor_pass"(rx786_pos, "scoped")
    if_null rx786_debug, debug_925
    rx786_cur."!cursor_debug"("PASS", "scoped", " at pos=", rx786_pos)
  debug_925:
    .return (rx786_cur)
  rx786_restart:
.annotate 'line', 10
    if_null rx786_debug, debug_926
    rx786_cur."!cursor_debug"("NEXT", "scoped")
  debug_926:
  rx786_fail:
    (rx786_rep, rx786_pos, $I10, $P10) = rx786_cur."!mark_fail"(0)
    lt rx786_pos, -1, rx786_done
    eq rx786_pos, -1, rx786_fail
    jump $I10
  rx786_done:
    rx786_cur."!cursor_fail"()
    if_null rx786_debug, debug_927
    rx786_cur."!cursor_debug"("FAIL", "scoped")
  debug_927:
    .return (rx786_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scoped"  :nsentry("!PREFIX__scoped") :subid("164_1303340952.947") :method
.annotate 'line', 10
    $P788 = self."!PREFIX__!subrule"("ws", "")
    $P789 = self."!PREFIX__!subrule"("ws", "")
    $P790 = self."!PREFIX__!subrule"("ws", "")
    new $P791, "ResizablePMCArray"
    push $P791, $P788
    push $P791, $P789
    push $P791, $P790
    .return ($P791)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "typename"  :subid("165_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx801_tgt
    .local int rx801_pos
    .local int rx801_off
    .local int rx801_eos
    .local int rx801_rep
    .local pmc rx801_cur
    .local pmc rx801_debug
    (rx801_cur, rx801_pos, rx801_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx801_cur
    .local pmc match
    .lex "$/", match
    length rx801_eos, rx801_tgt
    gt rx801_pos, rx801_eos, rx801_done
    set rx801_off, 0
    lt rx801_pos, 2, rx801_start
    sub rx801_off, rx801_pos, 1
    substr rx801_tgt, rx801_tgt, rx801_off
  rx801_start:
    eq $I10, 1, rx801_restart
    if_null rx801_debug, debug_928
    rx801_cur."!cursor_debug"("START", "typename")
  debug_928:
    $I10 = self.'from'()
    ne $I10, -1, rxscan805_done
    goto rxscan805_scan
  rxscan805_loop:
    (rx801_pos) = rx801_cur."from"()
    inc rx801_pos
    rx801_cur."!cursor_from"(rx801_pos)
    ge rx801_pos, rx801_eos, rxscan805_done
  rxscan805_scan:
    set_addr $I10, rxscan805_loop
    rx801_cur."!mark_push"(0, rx801_pos, $I10)
  rxscan805_done:
.annotate 'line', 380
  # rx subrule "name" subtype=capture negate=
    rx801_cur."!cursor_pos"(rx801_pos)
    $P10 = rx801_cur."name"()
    unless $P10, rx801_fail
    rx801_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx801_pos = $P10."pos"()
  # rx pass
    rx801_cur."!cursor_pass"(rx801_pos, "typename")
    if_null rx801_debug, debug_929
    rx801_cur."!cursor_debug"("PASS", "typename", " at pos=", rx801_pos)
  debug_929:
    .return (rx801_cur)
  rx801_restart:
.annotate 'line', 10
    if_null rx801_debug, debug_930
    rx801_cur."!cursor_debug"("NEXT", "typename")
  debug_930:
  rx801_fail:
    (rx801_rep, rx801_pos, $I10, $P10) = rx801_cur."!mark_fail"(0)
    lt rx801_pos, -1, rx801_done
    eq rx801_pos, -1, rx801_fail
    jump $I10
  rx801_done:
    rx801_cur."!cursor_fail"()
    if_null rx801_debug, debug_931
    rx801_cur."!cursor_debug"("FAIL", "typename")
  debug_931:
    .return (rx801_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__typename"  :nsentry("!PREFIX__typename") :subid("166_1303340952.947") :method
.annotate 'line', 10
    $P803 = self."!PREFIX__!subrule"("name", "")
    new $P804, "ResizablePMCArray"
    push $P804, $P803
    .return ($P804)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "declarator"  :subid("167_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx807_tgt
    .local int rx807_pos
    .local int rx807_off
    .local int rx807_eos
    .local int rx807_rep
    .local pmc rx807_cur
    .local pmc rx807_debug
    (rx807_cur, rx807_pos, rx807_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx807_cur
    .local pmc match
    .lex "$/", match
    length rx807_eos, rx807_tgt
    gt rx807_pos, rx807_eos, rx807_done
    set rx807_off, 0
    lt rx807_pos, 2, rx807_start
    sub rx807_off, rx807_pos, 1
    substr rx807_tgt, rx807_tgt, rx807_off
  rx807_start:
    eq $I10, 1, rx807_restart
    if_null rx807_debug, debug_932
    rx807_cur."!cursor_debug"("START", "declarator")
  debug_932:
    $I10 = self.'from'()
    ne $I10, -1, rxscan812_done
    goto rxscan812_scan
  rxscan812_loop:
    (rx807_pos) = rx807_cur."from"()
    inc rx807_pos
    rx807_cur."!cursor_from"(rx807_pos)
    ge rx807_pos, rx807_eos, rxscan812_done
  rxscan812_scan:
    set_addr $I10, rxscan812_loop
    rx807_cur."!mark_push"(0, rx807_pos, $I10)
  rxscan812_done:
  alt813_0:
.annotate 'line', 382
    set_addr $I10, alt813_1
    rx807_cur."!mark_push"(0, rx807_pos, $I10)
.annotate 'line', 383
  # rx subrule "variable_declarator" subtype=capture negate=
    rx807_cur."!cursor_pos"(rx807_pos)
    $P10 = rx807_cur."variable_declarator"()
    unless $P10, rx807_fail
    rx807_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable_declarator")
    rx807_pos = $P10."pos"()
    goto alt813_end
  alt813_1:
.annotate 'line', 384
  # rx subrule "routine_declarator" subtype=capture negate=
    rx807_cur."!cursor_pos"(rx807_pos)
    $P10 = rx807_cur."routine_declarator"()
    unless $P10, rx807_fail
    rx807_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx807_pos = $P10."pos"()
  alt813_end:
.annotate 'line', 382
  # rx pass
    rx807_cur."!cursor_pass"(rx807_pos, "declarator")
    if_null rx807_debug, debug_933
    rx807_cur."!cursor_debug"("PASS", "declarator", " at pos=", rx807_pos)
  debug_933:
    .return (rx807_cur)
  rx807_restart:
.annotate 'line', 10
    if_null rx807_debug, debug_934
    rx807_cur."!cursor_debug"("NEXT", "declarator")
  debug_934:
  rx807_fail:
    (rx807_rep, rx807_pos, $I10, $P10) = rx807_cur."!mark_fail"(0)
    lt rx807_pos, -1, rx807_done
    eq rx807_pos, -1, rx807_fail
    jump $I10
  rx807_done:
    rx807_cur."!cursor_fail"()
    if_null rx807_debug, debug_935
    rx807_cur."!cursor_debug"("FAIL", "declarator")
  debug_935:
    .return (rx807_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__declarator"  :nsentry("!PREFIX__declarator") :subid("168_1303340952.947") :method
.annotate 'line', 10
    $P809 = self."!PREFIX__!subrule"("routine_declarator", "")
    $P810 = self."!PREFIX__!subrule"("variable_declarator", "")
    new $P811, "ResizablePMCArray"
    push $P811, $P809
    push $P811, $P810
    .return ($P811)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable_declarator"  :subid("169_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx815_tgt
    .local int rx815_pos
    .local int rx815_off
    .local int rx815_eos
    .local int rx815_rep
    .local pmc rx815_cur
    .local pmc rx815_debug
    (rx815_cur, rx815_pos, rx815_tgt, $I10) = self."!cursor_start"()
    rx815_cur."!cursor_caparray"("typename")
    .lex unicode:"$\x{a2}", rx815_cur
    .local pmc match
    .lex "$/", match
    length rx815_eos, rx815_tgt
    gt rx815_pos, rx815_eos, rx815_done
    set rx815_off, 0
    lt rx815_pos, 2, rx815_start
    sub rx815_off, rx815_pos, 1
    substr rx815_tgt, rx815_tgt, rx815_off
  rx815_start:
    eq $I10, 1, rx815_restart
    if_null rx815_debug, debug_936
    rx815_cur."!cursor_debug"("START", "variable_declarator")
  debug_936:
    $I10 = self.'from'()
    ne $I10, -1, rxscan819_done
    goto rxscan819_scan
  rxscan819_loop:
    (rx815_pos) = rx815_cur."from"()
    inc rx815_pos
    rx815_cur."!cursor_from"(rx815_pos)
    ge rx815_pos, rx815_eos, rxscan819_done
  rxscan819_scan:
    set_addr $I10, rxscan819_loop
    rx815_cur."!mark_push"(0, rx815_pos, $I10)
  rxscan819_done:
.annotate 'line', 387
  # rx subrule "ws" subtype=method negate=
    rx815_cur."!cursor_pos"(rx815_pos)
    $P10 = rx815_cur."ws"()
    unless $P10, rx815_fail
    rx815_pos = $P10."pos"()
  # rx rxquantr821 ** 0..1
    set_addr $I10, rxquantr821_done
    rx815_cur."!mark_push"(0, rx815_pos, $I10)
  rxquantr821_loop:
  # rx subrule "typename" subtype=capture negate=
    rx815_cur."!cursor_pos"(rx815_pos)
    $P10 = rx815_cur."typename"()
    unless $P10, rx815_fail
    goto rxsubrule822_pass
  rxsubrule822_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx815_fail
  rxsubrule822_pass:
    set_addr $I10, rxsubrule822_back
    rx815_cur."!mark_push"(0, rx815_pos, $I10, $P10)
    $P10."!cursor_names"("typename")
    rx815_pos = $P10."pos"()
    set_addr $I10, rxquantr821_done
    (rx815_rep) = rx815_cur."!mark_commit"($I10)
  rxquantr821_done:
  # rx subrule "ws" subtype=method negate=
    rx815_cur."!cursor_pos"(rx815_pos)
    $P10 = rx815_cur."ws"()
    unless $P10, rx815_fail
    rx815_pos = $P10."pos"()
  # rx subrule "variable" subtype=capture negate=
    rx815_cur."!cursor_pos"(rx815_pos)
    $P10 = rx815_cur."variable"()
    unless $P10, rx815_fail
    rx815_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx815_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx815_cur."!cursor_pos"(rx815_pos)
    $P10 = rx815_cur."ws"()
    unless $P10, rx815_fail
    rx815_pos = $P10."pos"()
  # rx pass
    rx815_cur."!cursor_pass"(rx815_pos, "variable_declarator")
    if_null rx815_debug, debug_937
    rx815_cur."!cursor_debug"("PASS", "variable_declarator", " at pos=", rx815_pos)
  debug_937:
    .return (rx815_cur)
  rx815_restart:
.annotate 'line', 10
    if_null rx815_debug, debug_938
    rx815_cur."!cursor_debug"("NEXT", "variable_declarator")
  debug_938:
  rx815_fail:
    (rx815_rep, rx815_pos, $I10, $P10) = rx815_cur."!mark_fail"(0)
    lt rx815_pos, -1, rx815_done
    eq rx815_pos, -1, rx815_fail
    jump $I10
  rx815_done:
    rx815_cur."!cursor_fail"()
    if_null rx815_debug, debug_939
    rx815_cur."!cursor_debug"("FAIL", "variable_declarator")
  debug_939:
    .return (rx815_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable_declarator"  :nsentry("!PREFIX__variable_declarator") :subid("170_1303340952.947") :method
.annotate 'line', 10
    $P817 = self."!PREFIX__!subrule"("ws", "")
    new $P818, "ResizablePMCArray"
    push $P818, $P817
    .return ($P818)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator"  :subid("171_1303340952.947")
    .param pmc param_826
.annotate 'line', 389
    .lex "self", param_826
    $P827 = param_826."!protoregex"("routine_declarator")
    .return ($P827)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator"  :subid("172_1303340952.947")
    .param pmc param_829
.annotate 'line', 389
    .lex "self", param_829
    $P830 = param_829."!PREFIX__!protoregex"("routine_declarator")
    .return ($P830)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<sub>"  :subid("173_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx832_tgt
    .local int rx832_pos
    .local int rx832_off
    .local int rx832_eos
    .local int rx832_rep
    .local pmc rx832_cur
    .local pmc rx832_debug
    (rx832_cur, rx832_pos, rx832_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx832_cur
    .local pmc match
    .lex "$/", match
    length rx832_eos, rx832_tgt
    gt rx832_pos, rx832_eos, rx832_done
    set rx832_off, 0
    lt rx832_pos, 2, rx832_start
    sub rx832_off, rx832_pos, 1
    substr rx832_tgt, rx832_tgt, rx832_off
  rx832_start:
    eq $I10, 1, rx832_restart
    if_null rx832_debug, debug_940
    rx832_cur."!cursor_debug"("START", "routine_declarator:sym<sub>")
  debug_940:
    $I10 = self.'from'()
    ne $I10, -1, rxscan836_done
    goto rxscan836_scan
  rxscan836_loop:
    (rx832_pos) = rx832_cur."from"()
    inc rx832_pos
    rx832_cur."!cursor_from"(rx832_pos)
    ge rx832_pos, rx832_eos, rxscan836_done
  rxscan836_scan:
    set_addr $I10, rxscan836_loop
    rx832_cur."!mark_push"(0, rx832_pos, $I10)
  rxscan836_done:
.annotate 'line', 390
  # rx subcapture "sym"
    set_addr $I10, rxcap_837_fail
    rx832_cur."!mark_push"(0, rx832_pos, $I10)
  # rx literal  "sub"
    add $I11, rx832_pos, 3
    gt $I11, rx832_eos, rx832_fail
    sub $I11, rx832_pos, rx832_off
    substr $S10, rx832_tgt, $I11, 3
    ne $S10, "sub", rx832_fail
    add rx832_pos, 3
    set_addr $I10, rxcap_837_fail
    ($I12, $I11) = rx832_cur."!mark_peek"($I10)
    rx832_cur."!cursor_pos"($I11)
    ($P10) = rx832_cur."!cursor_start"()
    $P10."!cursor_pass"(rx832_pos, "")
    rx832_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_837_done
  rxcap_837_fail:
    goto rx832_fail
  rxcap_837_done:
  # rx subrule "routine_def" subtype=capture negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."routine_def"()
    unless $P10, rx832_fail
    rx832_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx832_pos = $P10."pos"()
  # rx pass
    rx832_cur."!cursor_pass"(rx832_pos, "routine_declarator:sym<sub>")
    if_null rx832_debug, debug_941
    rx832_cur."!cursor_debug"("PASS", "routine_declarator:sym<sub>", " at pos=", rx832_pos)
  debug_941:
    .return (rx832_cur)
  rx832_restart:
.annotate 'line', 10
    if_null rx832_debug, debug_942
    rx832_cur."!cursor_debug"("NEXT", "routine_declarator:sym<sub>")
  debug_942:
  rx832_fail:
    (rx832_rep, rx832_pos, $I10, $P10) = rx832_cur."!mark_fail"(0)
    lt rx832_pos, -1, rx832_done
    eq rx832_pos, -1, rx832_fail
    jump $I10
  rx832_done:
    rx832_cur."!cursor_fail"()
    if_null rx832_debug, debug_943
    rx832_cur."!cursor_debug"("FAIL", "routine_declarator:sym<sub>")
  debug_943:
    .return (rx832_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<sub>"  :nsentry("!PREFIX__routine_declarator:sym<sub>") :subid("174_1303340952.947") :method
.annotate 'line', 10
    $P834 = self."!PREFIX__!subrule"("routine_def", "sub")
    new $P835, "ResizablePMCArray"
    push $P835, $P834
    .return ($P835)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<method>"  :subid("175_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx839_tgt
    .local int rx839_pos
    .local int rx839_off
    .local int rx839_eos
    .local int rx839_rep
    .local pmc rx839_cur
    .local pmc rx839_debug
    (rx839_cur, rx839_pos, rx839_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx839_cur
    .local pmc match
    .lex "$/", match
    length rx839_eos, rx839_tgt
    gt rx839_pos, rx839_eos, rx839_done
    set rx839_off, 0
    lt rx839_pos, 2, rx839_start
    sub rx839_off, rx839_pos, 1
    substr rx839_tgt, rx839_tgt, rx839_off
  rx839_start:
    eq $I10, 1, rx839_restart
    if_null rx839_debug, debug_944
    rx839_cur."!cursor_debug"("START", "routine_declarator:sym<method>")
  debug_944:
    $I10 = self.'from'()
    ne $I10, -1, rxscan843_done
    goto rxscan843_scan
  rxscan843_loop:
    (rx839_pos) = rx839_cur."from"()
    inc rx839_pos
    rx839_cur."!cursor_from"(rx839_pos)
    ge rx839_pos, rx839_eos, rxscan843_done
  rxscan843_scan:
    set_addr $I10, rxscan843_loop
    rx839_cur."!mark_push"(0, rx839_pos, $I10)
  rxscan843_done:
.annotate 'line', 391
  # rx subcapture "sym"
    set_addr $I10, rxcap_844_fail
    rx839_cur."!mark_push"(0, rx839_pos, $I10)
  # rx literal  "method"
    add $I11, rx839_pos, 6
    gt $I11, rx839_eos, rx839_fail
    sub $I11, rx839_pos, rx839_off
    substr $S10, rx839_tgt, $I11, 6
    ne $S10, "method", rx839_fail
    add rx839_pos, 6
    set_addr $I10, rxcap_844_fail
    ($I12, $I11) = rx839_cur."!mark_peek"($I10)
    rx839_cur."!cursor_pos"($I11)
    ($P10) = rx839_cur."!cursor_start"()
    $P10."!cursor_pass"(rx839_pos, "")
    rx839_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_844_done
  rxcap_844_fail:
    goto rx839_fail
  rxcap_844_done:
  # rx subrule "method_def" subtype=capture negate=
    rx839_cur."!cursor_pos"(rx839_pos)
    $P10 = rx839_cur."method_def"()
    unless $P10, rx839_fail
    rx839_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("method_def")
    rx839_pos = $P10."pos"()
  # rx pass
    rx839_cur."!cursor_pass"(rx839_pos, "routine_declarator:sym<method>")
    if_null rx839_debug, debug_945
    rx839_cur."!cursor_debug"("PASS", "routine_declarator:sym<method>", " at pos=", rx839_pos)
  debug_945:
    .return (rx839_cur)
  rx839_restart:
.annotate 'line', 10
    if_null rx839_debug, debug_946
    rx839_cur."!cursor_debug"("NEXT", "routine_declarator:sym<method>")
  debug_946:
  rx839_fail:
    (rx839_rep, rx839_pos, $I10, $P10) = rx839_cur."!mark_fail"(0)
    lt rx839_pos, -1, rx839_done
    eq rx839_pos, -1, rx839_fail
    jump $I10
  rx839_done:
    rx839_cur."!cursor_fail"()
    if_null rx839_debug, debug_947
    rx839_cur."!cursor_debug"("FAIL", "routine_declarator:sym<method>")
  debug_947:
    .return (rx839_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<method>"  :nsentry("!PREFIX__routine_declarator:sym<method>") :subid("176_1303340952.947") :method
.annotate 'line', 10
    $P841 = self."!PREFIX__!subrule"("method_def", "method")
    new $P842, "ResizablePMCArray"
    push $P842, $P841
    .return ($P842)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_def"  :subid("177_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 394
    new $P846, "Undef"
    .lex "$*RETURN_USED", $P846
.annotate 'line', 10
    .local string rx847_tgt
    .local int rx847_pos
    .local int rx847_off
    .local int rx847_eos
    .local int rx847_rep
    .local pmc rx847_cur
    .local pmc rx847_debug
    (rx847_cur, rx847_pos, rx847_tgt, $I10) = self."!cursor_start"()
    rx847_cur."!cursor_caparray"("sigil", "deflongname", "trait")
    .lex unicode:"$\x{a2}", rx847_cur
    .local pmc match
    .lex "$/", match
    length rx847_eos, rx847_tgt
    gt rx847_pos, rx847_eos, rx847_done
    set rx847_off, 0
    lt rx847_pos, 2, rx847_start
    sub rx847_off, rx847_pos, 1
    substr rx847_tgt, rx847_tgt, rx847_off
  rx847_start:
    eq $I10, 1, rx847_restart
    if_null rx847_debug, debug_948
    rx847_cur."!cursor_debug"("START", "routine_def")
  debug_948:
    $I10 = self.'from'()
    ne $I10, -1, rxscan851_done
    goto rxscan851_scan
  rxscan851_loop:
    (rx847_pos) = rx847_cur."from"()
    inc rx847_pos
    rx847_cur."!cursor_from"(rx847_pos)
    ge rx847_pos, rx847_eos, rxscan851_done
  rxscan851_scan:
    set_addr $I10, rxscan851_loop
    rx847_cur."!mark_push"(0, rx847_pos, $I10)
  rxscan851_done:
.annotate 'line', 393
  # rx subrule "ws" subtype=method negate=
    rx847_cur."!cursor_pos"(rx847_pos)
    $P10 = rx847_cur."ws"()
    unless $P10, rx847_fail
    rx847_pos = $P10."pos"()
.annotate 'line', 394
    rx847_cur."!cursor_pos"(rx847_pos)
    new $P853, "Integer"
    assign $P853, 0
    store_lex "$*RETURN_USED", $P853
  # rx subrule "ws" subtype=method negate=
    rx847_cur."!cursor_pos"(rx847_pos)
    $P10 = rx847_cur."ws"()
    unless $P10, rx847_fail
    rx847_pos = $P10."pos"()
.annotate 'line', 395
  # rx rxquantr855 ** 0..1
    set_addr $I10, rxquantr855_done
    rx847_cur."!mark_push"(0, rx847_pos, $I10)
  rxquantr855_loop:
  # rx subrule "ws" subtype=method negate=
    rx847_cur."!cursor_pos"(rx847_pos)
    $P10 = rx847_cur."ws"()
    unless $P10, rx847_fail
    rx847_pos = $P10."pos"()
  # rx subcapture "sigil"
    set_addr $I10, rxcap_858_fail
    rx847_cur."!mark_push"(0, rx847_pos, $I10)
  # rx rxquantr857 ** 0..1
    set_addr $I10, rxquantr857_done
    rx847_cur."!mark_push"(0, rx847_pos, $I10)
  rxquantr857_loop:
  # rx literal  "&"
    add $I11, rx847_pos, 1
    gt $I11, rx847_eos, rx847_fail
    sub $I11, rx847_pos, rx847_off
    ord $I11, rx847_tgt, $I11
    ne $I11, 38, rx847_fail
    add rx847_pos, 1
    set_addr $I10, rxquantr857_done
    (rx847_rep) = rx847_cur."!mark_commit"($I10)
  rxquantr857_done:
    set_addr $I10, rxcap_858_fail
    ($I12, $I11) = rx847_cur."!mark_peek"($I10)
    rx847_cur."!cursor_pos"($I11)
    ($P10) = rx847_cur."!cursor_start"()
    $P10."!cursor_pass"(rx847_pos, "")
    rx847_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_858_done
  rxcap_858_fail:
    goto rx847_fail
  rxcap_858_done:
  # rx subrule "deflongname" subtype=capture negate=
    rx847_cur."!cursor_pos"(rx847_pos)
    $P10 = rx847_cur."deflongname"()
    unless $P10, rx847_fail
    rx847_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx847_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx847_cur."!cursor_pos"(rx847_pos)
    $P10 = rx847_cur."ws"()
    unless $P10, rx847_fail
    rx847_pos = $P10."pos"()
    set_addr $I10, rxquantr855_done
    (rx847_rep) = rx847_cur."!mark_commit"($I10)
  rxquantr855_done:
  # rx subrule "ws" subtype=method negate=
    rx847_cur."!cursor_pos"(rx847_pos)
    $P10 = rx847_cur."ws"()
    unless $P10, rx847_fail
    rx847_pos = $P10."pos"()
.annotate 'line', 396
  # rx subrule "newpad" subtype=method negate=
    rx847_cur."!cursor_pos"(rx847_pos)
    $P10 = rx847_cur."newpad"()
    unless $P10, rx847_fail
    rx847_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx847_cur."!cursor_pos"(rx847_pos)
    $P10 = rx847_cur."ws"()
    unless $P10, rx847_fail
    rx847_pos = $P10."pos"()
  alt862_0:
.annotate 'line', 397
    set_addr $I10, alt862_1
    rx847_cur."!mark_push"(0, rx847_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx847_cur."!cursor_pos"(rx847_pos)
    $P10 = rx847_cur."ws"()
    unless $P10, rx847_fail
    rx847_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx847_pos, 1
    gt $I11, rx847_eos, rx847_fail
    sub $I11, rx847_pos, rx847_off
    ord $I11, rx847_tgt, $I11
    ne $I11, 40, rx847_fail
    add rx847_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx847_cur."!cursor_pos"(rx847_pos)
    $P10 = rx847_cur."ws"()
    unless $P10, rx847_fail
    rx847_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx847_cur."!cursor_pos"(rx847_pos)
    $P10 = rx847_cur."signature"()
    unless $P10, rx847_fail
    rx847_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx847_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx847_cur."!cursor_pos"(rx847_pos)
    $P10 = rx847_cur."ws"()
    unless $P10, rx847_fail
    rx847_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx847_pos, 1
    gt $I11, rx847_eos, rx847_fail
    sub $I11, rx847_pos, rx847_off
    ord $I11, rx847_tgt, $I11
    ne $I11, 41, rx847_fail
    add rx847_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx847_cur."!cursor_pos"(rx847_pos)
    $P10 = rx847_cur."ws"()
    unless $P10, rx847_fail
    rx847_pos = $P10."pos"()
    goto alt862_end
  alt862_1:
.annotate 'line', 398
  # rx subrule "ws" subtype=method negate=
    rx847_cur."!cursor_pos"(rx847_pos)
    $P10 = rx847_cur."ws"()
    unless $P10, rx847_fail
    rx847_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx847_cur."!cursor_pos"(rx847_pos)
    $P10 = rx847_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx847_fail
    rx847_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx847_cur."!cursor_pos"(rx847_pos)
    $P10 = rx847_cur."ws"()
    unless $P10, rx847_fail
    rx847_pos = $P10."pos"()
  alt862_end:
  # rx subrule "ws" subtype=method negate=
    rx847_cur."!cursor_pos"(rx847_pos)
    $P10 = rx847_cur."ws"()
    unless $P10, rx847_fail
    rx847_pos = $P10."pos"()
.annotate 'line', 399
  # rx rxquantr870 ** 0..*
    set_addr $I10, rxquantr870_done
    rx847_cur."!mark_push"(0, rx847_pos, $I10)
  rxquantr870_loop:
  # rx subrule "trait" subtype=capture negate=
    rx847_cur."!cursor_pos"(rx847_pos)
    $P10 = rx847_cur."trait"()
    unless $P10, rx847_fail
    goto rxsubrule871_pass
  rxsubrule871_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx847_fail
  rxsubrule871_pass:
    set_addr $I10, rxsubrule871_back
    rx847_cur."!mark_push"(0, rx847_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx847_pos = $P10."pos"()
    set_addr $I10, rxquantr870_done
    (rx847_rep) = rx847_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr870_done
    rx847_cur."!mark_push"(rx847_rep, rx847_pos, $I10)
    goto rxquantr870_loop
  rxquantr870_done:
  # rx subrule "ws" subtype=method negate=
    rx847_cur."!cursor_pos"(rx847_pos)
    $P10 = rx847_cur."ws"()
    unless $P10, rx847_fail
    rx847_pos = $P10."pos"()
  alt873_0:
.annotate 'line', 400
    set_addr $I10, alt873_1
    rx847_cur."!mark_push"(0, rx847_pos, $I10)
.annotate 'line', 401
  # rx subrule "ws" subtype=method negate=
    rx847_cur."!cursor_pos"(rx847_pos)
    $P10 = rx847_cur."ws"()
    unless $P10, rx847_fail
    rx847_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx847_cur."!cursor_pos"(rx847_pos)
    $P10 = rx847_cur."onlystar"()
    unless $P10, rx847_fail
    rx847_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx847_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx847_cur."!cursor_pos"(rx847_pos)
    $P10 = rx847_cur."ws"()
    unless $P10, rx847_fail
    rx847_pos = $P10."pos"()
    goto alt873_end
  alt873_1:
.annotate 'line', 402
  # rx subrule "ws" subtype=method negate=
    rx847_cur."!cursor_pos"(rx847_pos)
    $P10 = rx847_cur."ws"()
    unless $P10, rx847_fail
    rx847_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx847_cur."!cursor_pos"(rx847_pos)
    $P10 = rx847_cur."blockoid"()
    unless $P10, rx847_fail
    rx847_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx847_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx847_cur."!cursor_pos"(rx847_pos)
    $P10 = rx847_cur."ws"()
    unless $P10, rx847_fail
    rx847_pos = $P10."pos"()
  alt873_end:
.annotate 'line', 403
  # rx subrule "ws" subtype=method negate=
    rx847_cur."!cursor_pos"(rx847_pos)
    $P10 = rx847_cur."ws"()
    unless $P10, rx847_fail
    rx847_pos = $P10."pos"()
.annotate 'line', 393
  # rx pass
    rx847_cur."!cursor_pass"(rx847_pos, "routine_def")
    if_null rx847_debug, debug_949
    rx847_cur."!cursor_debug"("PASS", "routine_def", " at pos=", rx847_pos)
  debug_949:
    .return (rx847_cur)
  rx847_restart:
.annotate 'line', 10
    if_null rx847_debug, debug_950
    rx847_cur."!cursor_debug"("NEXT", "routine_def")
  debug_950:
  rx847_fail:
    (rx847_rep, rx847_pos, $I10, $P10) = rx847_cur."!mark_fail"(0)
    lt rx847_pos, -1, rx847_done
    eq rx847_pos, -1, rx847_fail
    jump $I10
  rx847_done:
    rx847_cur."!cursor_fail"()
    if_null rx847_debug, debug_951
    rx847_cur."!cursor_debug"("FAIL", "routine_def")
  debug_951:
    .return (rx847_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_def"  :nsentry("!PREFIX__routine_def") :subid("178_1303340952.947") :method
.annotate 'line', 10
    $P849 = self."!PREFIX__!subrule"("ws", "")
    new $P850, "ResizablePMCArray"
    push $P850, $P849
    .return ($P850)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "method_def"  :subid("179_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .const 'Sub' $P910 = "181_1303340952.947" 
    capture_lex $P910
.annotate 'line', 407
    new $P880, "Undef"
    .lex "$*RETURN_USED", $P880
.annotate 'line', 408
    new $P881, "Undef"
    .lex "$*INVOCANT_OK", $P881
.annotate 'line', 10
    .local string rx882_tgt
    .local int rx882_pos
    .local int rx882_off
    .local int rx882_eos
    .local int rx882_rep
    .local pmc rx882_cur
    .local pmc rx882_debug
    (rx882_cur, rx882_pos, rx882_tgt, $I10) = self."!cursor_start"()
    rx882_cur."!cursor_caparray"("deflongname", "trait")
    .lex unicode:"$\x{a2}", rx882_cur
    .local pmc match
    .lex "$/", match
    length rx882_eos, rx882_tgt
    gt rx882_pos, rx882_eos, rx882_done
    set rx882_off, 0
    lt rx882_pos, 2, rx882_start
    sub rx882_off, rx882_pos, 1
    substr rx882_tgt, rx882_tgt, rx882_off
  rx882_start:
    eq $I10, 1, rx882_restart
    if_null rx882_debug, debug_952
    rx882_cur."!cursor_debug"("START", "method_def")
  debug_952:
    $I10 = self.'from'()
    ne $I10, -1, rxscan886_done
    goto rxscan886_scan
  rxscan886_loop:
    (rx882_pos) = rx882_cur."from"()
    inc rx882_pos
    rx882_cur."!cursor_from"(rx882_pos)
    ge rx882_pos, rx882_eos, rxscan886_done
  rxscan886_scan:
    set_addr $I10, rxscan886_loop
    rx882_cur."!mark_push"(0, rx882_pos, $I10)
  rxscan886_done:
.annotate 'line', 406
  # rx subrule "ws" subtype=method negate=
    rx882_cur."!cursor_pos"(rx882_pos)
    $P10 = rx882_cur."ws"()
    unless $P10, rx882_fail
    rx882_pos = $P10."pos"()
.annotate 'line', 407
    rx882_cur."!cursor_pos"(rx882_pos)
    new $P888, "Integer"
    assign $P888, 0
    store_lex "$*RETURN_USED", $P888
  # rx subrule "ws" subtype=method negate=
    rx882_cur."!cursor_pos"(rx882_pos)
    $P10 = rx882_cur."ws"()
    unless $P10, rx882_fail
    rx882_pos = $P10."pos"()
.annotate 'line', 408
    rx882_cur."!cursor_pos"(rx882_pos)
    new $P890, "Integer"
    assign $P890, 1
    store_lex "$*INVOCANT_OK", $P890
  # rx subrule "ws" subtype=method negate=
    rx882_cur."!cursor_pos"(rx882_pos)
    $P10 = rx882_cur."ws"()
    unless $P10, rx882_fail
    rx882_pos = $P10."pos"()
.annotate 'line', 409
  # rx subcapture "private"
    set_addr $I10, rxcap_893_fail
    rx882_cur."!mark_push"(0, rx882_pos, $I10)
  # rx rxquantr892 ** 0..1
    set_addr $I10, rxquantr892_done
    rx882_cur."!mark_push"(0, rx882_pos, $I10)
  rxquantr892_loop:
  # rx literal  "!"
    add $I11, rx882_pos, 1
    gt $I11, rx882_eos, rx882_fail
    sub $I11, rx882_pos, rx882_off
    ord $I11, rx882_tgt, $I11
    ne $I11, 33, rx882_fail
    add rx882_pos, 1
    set_addr $I10, rxquantr892_done
    (rx882_rep) = rx882_cur."!mark_commit"($I10)
  rxquantr892_done:
    set_addr $I10, rxcap_893_fail
    ($I12, $I11) = rx882_cur."!mark_peek"($I10)
    rx882_cur."!cursor_pos"($I11)
    ($P10) = rx882_cur."!cursor_start"()
    $P10."!cursor_pass"(rx882_pos, "")
    rx882_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("private")
    goto rxcap_893_done
  rxcap_893_fail:
    goto rx882_fail
  rxcap_893_done:
  # rx subrule "ws" subtype=method negate=
    rx882_cur."!cursor_pos"(rx882_pos)
    $P10 = rx882_cur."ws"()
    unless $P10, rx882_fail
    rx882_pos = $P10."pos"()
.annotate 'line', 410
  # rx rxquantr895 ** 0..1
    set_addr $I10, rxquantr895_done
    rx882_cur."!mark_push"(0, rx882_pos, $I10)
  rxquantr895_loop:
  # rx subrule "deflongname" subtype=capture negate=
    rx882_cur."!cursor_pos"(rx882_pos)
    $P10 = rx882_cur."deflongname"()
    unless $P10, rx882_fail
    goto rxsubrule896_pass
  rxsubrule896_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx882_fail
  rxsubrule896_pass:
    set_addr $I10, rxsubrule896_back
    rx882_cur."!mark_push"(0, rx882_pos, $I10, $P10)
    $P10."!cursor_names"("deflongname")
    rx882_pos = $P10."pos"()
    set_addr $I10, rxquantr895_done
    (rx882_rep) = rx882_cur."!mark_commit"($I10)
  rxquantr895_done:
  # rx subrule "ws" subtype=method negate=
    rx882_cur."!cursor_pos"(rx882_pos)
    $P10 = rx882_cur."ws"()
    unless $P10, rx882_fail
    rx882_pos = $P10."pos"()
.annotate 'line', 411
  # rx subrule "newpad" subtype=method negate=
    rx882_cur."!cursor_pos"(rx882_pos)
    $P10 = rx882_cur."newpad"()
    unless $P10, rx882_fail
    rx882_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx882_cur."!cursor_pos"(rx882_pos)
    $P10 = rx882_cur."ws"()
    unless $P10, rx882_fail
    rx882_pos = $P10."pos"()
  alt899_0:
.annotate 'line', 412
    set_addr $I10, alt899_1
    rx882_cur."!mark_push"(0, rx882_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx882_cur."!cursor_pos"(rx882_pos)
    $P10 = rx882_cur."ws"()
    unless $P10, rx882_fail
    rx882_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx882_pos, 1
    gt $I11, rx882_eos, rx882_fail
    sub $I11, rx882_pos, rx882_off
    ord $I11, rx882_tgt, $I11
    ne $I11, 40, rx882_fail
    add rx882_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx882_cur."!cursor_pos"(rx882_pos)
    $P10 = rx882_cur."ws"()
    unless $P10, rx882_fail
    rx882_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx882_cur."!cursor_pos"(rx882_pos)
    $P10 = rx882_cur."signature"()
    unless $P10, rx882_fail
    rx882_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx882_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx882_cur."!cursor_pos"(rx882_pos)
    $P10 = rx882_cur."ws"()
    unless $P10, rx882_fail
    rx882_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx882_pos, 1
    gt $I11, rx882_eos, rx882_fail
    sub $I11, rx882_pos, rx882_off
    ord $I11, rx882_tgt, $I11
    ne $I11, 41, rx882_fail
    add rx882_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx882_cur."!cursor_pos"(rx882_pos)
    $P10 = rx882_cur."ws"()
    unless $P10, rx882_fail
    rx882_pos = $P10."pos"()
    goto alt899_end
  alt899_1:
.annotate 'line', 413
  # rx subrule "ws" subtype=method negate=
    rx882_cur."!cursor_pos"(rx882_pos)
    $P10 = rx882_cur."ws"()
    unless $P10, rx882_fail
    rx882_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx882_cur."!cursor_pos"(rx882_pos)
    $P10 = rx882_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx882_fail
    rx882_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx882_cur."!cursor_pos"(rx882_pos)
    $P10 = rx882_cur."ws"()
    unless $P10, rx882_fail
    rx882_pos = $P10."pos"()
  alt899_end:
  # rx subrule "ws" subtype=method negate=
    rx882_cur."!cursor_pos"(rx882_pos)
    $P10 = rx882_cur."ws"()
    unless $P10, rx882_fail
    rx882_pos = $P10."pos"()
.annotate 'line', 414
    rx882_cur."!cursor_pos"(rx882_pos)
    find_lex $P907, unicode:"$\x{a2}"
    $P908 = $P907."MATCH"()
    store_lex "$/", $P908
    .const 'Sub' $P910 = "181_1303340952.947" 
    capture_lex $P910
    $P912 = $P910()
  # rx subrule "ws" subtype=method negate=
    rx882_cur."!cursor_pos"(rx882_pos)
    $P10 = rx882_cur."ws"()
    unless $P10, rx882_fail
    rx882_pos = $P10."pos"()
.annotate 'line', 415
  # rx rxquantr914 ** 0..*
    set_addr $I10, rxquantr914_done
    rx882_cur."!mark_push"(0, rx882_pos, $I10)
  rxquantr914_loop:
  # rx subrule "trait" subtype=capture negate=
    rx882_cur."!cursor_pos"(rx882_pos)
    $P10 = rx882_cur."trait"()
    unless $P10, rx882_fail
    goto rxsubrule915_pass
  rxsubrule915_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx882_fail
  rxsubrule915_pass:
    set_addr $I10, rxsubrule915_back
    rx882_cur."!mark_push"(0, rx882_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx882_pos = $P10."pos"()
    set_addr $I10, rxquantr914_done
    (rx882_rep) = rx882_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr914_done
    rx882_cur."!mark_push"(rx882_rep, rx882_pos, $I10)
    goto rxquantr914_loop
  rxquantr914_done:
  # rx subrule "ws" subtype=method negate=
    rx882_cur."!cursor_pos"(rx882_pos)
    $P10 = rx882_cur."ws"()
    unless $P10, rx882_fail
    rx882_pos = $P10."pos"()
  alt917_0:
.annotate 'line', 416
    set_addr $I10, alt917_1
    rx882_cur."!mark_push"(0, rx882_pos, $I10)
.annotate 'line', 417
  # rx subrule "ws" subtype=method negate=
    rx882_cur."!cursor_pos"(rx882_pos)
    $P10 = rx882_cur."ws"()
    unless $P10, rx882_fail
    rx882_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx882_cur."!cursor_pos"(rx882_pos)
    $P10 = rx882_cur."onlystar"()
    unless $P10, rx882_fail
    rx882_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx882_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx882_cur."!cursor_pos"(rx882_pos)
    $P10 = rx882_cur."ws"()
    unless $P10, rx882_fail
    rx882_pos = $P10."pos"()
    goto alt917_end
  alt917_1:
.annotate 'line', 418
  # rx subrule "ws" subtype=method negate=
    rx882_cur."!cursor_pos"(rx882_pos)
    $P10 = rx882_cur."ws"()
    unless $P10, rx882_fail
    rx882_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx882_cur."!cursor_pos"(rx882_pos)
    $P10 = rx882_cur."blockoid"()
    unless $P10, rx882_fail
    rx882_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx882_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx882_cur."!cursor_pos"(rx882_pos)
    $P10 = rx882_cur."ws"()
    unless $P10, rx882_fail
    rx882_pos = $P10."pos"()
  alt917_end:
.annotate 'line', 419
  # rx subrule "ws" subtype=method negate=
    rx882_cur."!cursor_pos"(rx882_pos)
    $P10 = rx882_cur."ws"()
    unless $P10, rx882_fail
    rx882_pos = $P10."pos"()
.annotate 'line', 406
  # rx pass
    rx882_cur."!cursor_pass"(rx882_pos, "method_def")
    if_null rx882_debug, debug_953
    rx882_cur."!cursor_debug"("PASS", "method_def", " at pos=", rx882_pos)
  debug_953:
    .return (rx882_cur)
  rx882_restart:
.annotate 'line', 10
    if_null rx882_debug, debug_954
    rx882_cur."!cursor_debug"("NEXT", "method_def")
  debug_954:
  rx882_fail:
    (rx882_rep, rx882_pos, $I10, $P10) = rx882_cur."!mark_fail"(0)
    lt rx882_pos, -1, rx882_done
    eq rx882_pos, -1, rx882_fail
    jump $I10
  rx882_done:
    rx882_cur."!cursor_fail"()
    if_null rx882_debug, debug_955
    rx882_cur."!cursor_debug"("FAIL", "method_def")
  debug_955:
    .return (rx882_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__method_def"  :nsentry("!PREFIX__method_def") :subid("180_1303340952.947") :method
.annotate 'line', 10
    $P884 = self."!PREFIX__!subrule"("ws", "")
    new $P885, "ResizablePMCArray"
    push $P885, $P884
    .return ($P885)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block909"  :anon :subid("181_1303340952.947") :outer("179_1303340952.947")
.annotate 'line', 414
    new $P911, "Integer"
    assign $P911, 0
    store_dynamic_lex "$*INVOCANT_OK", $P911
    .return ($P911)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "onlystar"  :subid("182_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .const 'Sub' $P931 = "184_1303340952.947" 
    capture_lex $P931
    .local string rx924_tgt
    .local int rx924_pos
    .local int rx924_off
    .local int rx924_eos
    .local int rx924_rep
    .local pmc rx924_cur
    .local pmc rx924_debug
    (rx924_cur, rx924_pos, rx924_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx924_cur
    .local pmc match
    .lex "$/", match
    length rx924_eos, rx924_tgt
    gt rx924_pos, rx924_eos, rx924_done
    set rx924_off, 0
    lt rx924_pos, 2, rx924_start
    sub rx924_off, rx924_pos, 1
    substr rx924_tgt, rx924_tgt, rx924_off
  rx924_start:
    eq $I10, 1, rx924_restart
    if_null rx924_debug, debug_956
    rx924_cur."!cursor_debug"("START", "onlystar")
  debug_956:
    $I10 = self.'from'()
    ne $I10, -1, rxscan927_done
    goto rxscan927_scan
  rxscan927_loop:
    (rx924_pos) = rx924_cur."from"()
    inc rx924_pos
    rx924_cur."!cursor_from"(rx924_pos)
    ge rx924_pos, rx924_eos, rxscan927_done
  rxscan927_scan:
    set_addr $I10, rxscan927_loop
    rx924_cur."!mark_push"(0, rx924_pos, $I10)
  rxscan927_done:
.annotate 'line', 423
    rx924_cur."!cursor_pos"(rx924_pos)
    find_lex $P928, unicode:"$\x{a2}"
    $P929 = $P928."MATCH"()
    store_lex "$/", $P929
    .const 'Sub' $P931 = "184_1303340952.947" 
    capture_lex $P931
    $P935 = $P931()
    unless $P935, rx924_fail
.annotate 'line', 424
  # rx literal  "{"
    add $I11, rx924_pos, 1
    gt $I11, rx924_eos, rx924_fail
    sub $I11, rx924_pos, rx924_off
    ord $I11, rx924_tgt, $I11
    ne $I11, 123, rx924_fail
    add rx924_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx924_cur."!cursor_pos"(rx924_pos)
    $P10 = rx924_cur."ws"()
    unless $P10, rx924_fail
    rx924_pos = $P10."pos"()
  # rx literal  "*"
    add $I11, rx924_pos, 1
    gt $I11, rx924_eos, rx924_fail
    sub $I11, rx924_pos, rx924_off
    ord $I11, rx924_tgt, $I11
    ne $I11, 42, rx924_fail
    add rx924_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx924_cur."!cursor_pos"(rx924_pos)
    $P10 = rx924_cur."ws"()
    unless $P10, rx924_fail
    rx924_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx924_pos, 1
    gt $I11, rx924_eos, rx924_fail
    sub $I11, rx924_pos, rx924_off
    ord $I11, rx924_tgt, $I11
    ne $I11, 125, rx924_fail
    add rx924_pos, 1
.annotate 'line', 425
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx924_cur."!cursor_pos"(rx924_pos)
    $P10 = rx924_cur."ENDSTMT"()
    unless $P10, rx924_fail
.annotate 'line', 426
  # rx subrule "finishpad" subtype=method negate=
    rx924_cur."!cursor_pos"(rx924_pos)
    $P10 = rx924_cur."finishpad"()
    unless $P10, rx924_fail
    rx924_pos = $P10."pos"()
.annotate 'line', 422
  # rx pass
    rx924_cur."!cursor_pass"(rx924_pos, "onlystar")
    if_null rx924_debug, debug_959
    rx924_cur."!cursor_debug"("PASS", "onlystar", " at pos=", rx924_pos)
  debug_959:
    .return (rx924_cur)
  rx924_restart:
.annotate 'line', 10
    if_null rx924_debug, debug_960
    rx924_cur."!cursor_debug"("NEXT", "onlystar")
  debug_960:
  rx924_fail:
    (rx924_rep, rx924_pos, $I10, $P10) = rx924_cur."!mark_fail"(0)
    lt rx924_pos, -1, rx924_done
    eq rx924_pos, -1, rx924_fail
    jump $I10
  rx924_done:
    rx924_cur."!cursor_fail"()
    if_null rx924_debug, debug_961
    rx924_cur."!cursor_debug"("FAIL", "onlystar")
  debug_961:
    .return (rx924_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__onlystar"  :nsentry("!PREFIX__onlystar") :subid("183_1303340952.947") :method
.annotate 'line', 10
    new $P926, "ResizablePMCArray"
    push $P926, ""
    .return ($P926)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block930"  :anon :subid("184_1303340952.947") :outer("182_1303340952.947")
.annotate 'line', 423
    find_dynamic_lex $P932, "$*MULTINESS"
    unless_null $P932, vivify_957
    get_hll_global $P932, "$MULTINESS"
    unless_null $P932, vivify_958
    die "Contextual $*MULTINESS not found"
  vivify_958:
  vivify_957:
    set $S933, $P932
    iseq $I934, $S933, "proto"
    .return ($I934)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator"  :subid("185_1303340952.947")
    .param pmc param_937
.annotate 'line', 429
    .lex "self", param_937
    $P938 = param_937."!protoregex"("multi_declarator")
    .return ($P938)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator"  :subid("186_1303340952.947")
    .param pmc param_940
.annotate 'line', 429
    .lex "self", param_940
    $P941 = param_940."!PREFIX__!protoregex"("multi_declarator")
    .return ($P941)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<multi>"  :subid("187_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 431
    new $P943, "Undef"
    .lex "$*MULTINESS", $P943
.annotate 'line', 10
    .local string rx944_tgt
    .local int rx944_pos
    .local int rx944_off
    .local int rx944_eos
    .local int rx944_rep
    .local pmc rx944_cur
    .local pmc rx944_debug
    (rx944_cur, rx944_pos, rx944_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx944_cur
    .local pmc match
    .lex "$/", match
    length rx944_eos, rx944_tgt
    gt rx944_pos, rx944_eos, rx944_done
    set rx944_off, 0
    lt rx944_pos, 2, rx944_start
    sub rx944_off, rx944_pos, 1
    substr rx944_tgt, rx944_tgt, rx944_off
  rx944_start:
    eq $I10, 1, rx944_restart
    if_null rx944_debug, debug_962
    rx944_cur."!cursor_debug"("START", "multi_declarator:sym<multi>")
  debug_962:
    $I10 = self.'from'()
    ne $I10, -1, rxscan948_done
    goto rxscan948_scan
  rxscan948_loop:
    (rx944_pos) = rx944_cur."from"()
    inc rx944_pos
    rx944_cur."!cursor_from"(rx944_pos)
    ge rx944_pos, rx944_eos, rxscan948_done
  rxscan948_scan:
    set_addr $I10, rxscan948_loop
    rx944_cur."!mark_push"(0, rx944_pos, $I10)
  rxscan948_done:
.annotate 'line', 431
    rx944_cur."!cursor_pos"(rx944_pos)
    new $P949, "String"
    assign $P949, "multi"
    store_lex "$*MULTINESS", $P949
.annotate 'line', 432
  # rx subcapture "sym"
    set_addr $I10, rxcap_950_fail
    rx944_cur."!mark_push"(0, rx944_pos, $I10)
  # rx literal  "multi"
    add $I11, rx944_pos, 5
    gt $I11, rx944_eos, rx944_fail
    sub $I11, rx944_pos, rx944_off
    substr $S10, rx944_tgt, $I11, 5
    ne $S10, "multi", rx944_fail
    add rx944_pos, 5
    set_addr $I10, rxcap_950_fail
    ($I12, $I11) = rx944_cur."!mark_peek"($I10)
    rx944_cur."!cursor_pos"($I11)
    ($P10) = rx944_cur."!cursor_start"()
    $P10."!cursor_pass"(rx944_pos, "")
    rx944_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_950_done
  rxcap_950_fail:
    goto rx944_fail
  rxcap_950_done:
.annotate 'line', 433
  # rx subrule "ws" subtype=method negate=
    rx944_cur."!cursor_pos"(rx944_pos)
    $P10 = rx944_cur."ws"()
    unless $P10, rx944_fail
    rx944_pos = $P10."pos"()
  alt951_0:
    set_addr $I10, alt951_1
    rx944_cur."!mark_push"(0, rx944_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx944_cur."!cursor_pos"(rx944_pos)
    $P10 = rx944_cur."declarator"()
    unless $P10, rx944_fail
    rx944_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx944_pos = $P10."pos"()
    goto alt951_end
  alt951_1:
    set_addr $I10, alt951_2
    rx944_cur."!mark_push"(0, rx944_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx944_cur."!cursor_pos"(rx944_pos)
    $P10 = rx944_cur."routine_def"()
    unless $P10, rx944_fail
    rx944_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx944_pos = $P10."pos"()
    goto alt951_end
  alt951_2:
  # rx subrule "panic" subtype=method negate=
    rx944_cur."!cursor_pos"(rx944_pos)
    $P10 = rx944_cur."panic"("Malformed multi")
    unless $P10, rx944_fail
    rx944_pos = $P10."pos"()
  alt951_end:
.annotate 'line', 430
  # rx pass
    rx944_cur."!cursor_pass"(rx944_pos, "multi_declarator:sym<multi>")
    if_null rx944_debug, debug_963
    rx944_cur."!cursor_debug"("PASS", "multi_declarator:sym<multi>", " at pos=", rx944_pos)
  debug_963:
    .return (rx944_cur)
  rx944_restart:
.annotate 'line', 10
    if_null rx944_debug, debug_964
    rx944_cur."!cursor_debug"("NEXT", "multi_declarator:sym<multi>")
  debug_964:
  rx944_fail:
    (rx944_rep, rx944_pos, $I10, $P10) = rx944_cur."!mark_fail"(0)
    lt rx944_pos, -1, rx944_done
    eq rx944_pos, -1, rx944_fail
    jump $I10
  rx944_done:
    rx944_cur."!cursor_fail"()
    if_null rx944_debug, debug_965
    rx944_cur."!cursor_debug"("FAIL", "multi_declarator:sym<multi>")
  debug_965:
    .return (rx944_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<multi>"  :nsentry("!PREFIX__multi_declarator:sym<multi>") :subid("188_1303340952.947") :method
.annotate 'line', 10
    $P946 = self."!PREFIX__!subrule"("ws", "multi")
    new $P947, "ResizablePMCArray"
    push $P947, $P946
    .return ($P947)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<proto>"  :subid("189_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 436
    new $P953, "Undef"
    .lex "$*MULTINESS", $P953
.annotate 'line', 10
    .local string rx954_tgt
    .local int rx954_pos
    .local int rx954_off
    .local int rx954_eos
    .local int rx954_rep
    .local pmc rx954_cur
    .local pmc rx954_debug
    (rx954_cur, rx954_pos, rx954_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx954_cur
    .local pmc match
    .lex "$/", match
    length rx954_eos, rx954_tgt
    gt rx954_pos, rx954_eos, rx954_done
    set rx954_off, 0
    lt rx954_pos, 2, rx954_start
    sub rx954_off, rx954_pos, 1
    substr rx954_tgt, rx954_tgt, rx954_off
  rx954_start:
    eq $I10, 1, rx954_restart
    if_null rx954_debug, debug_966
    rx954_cur."!cursor_debug"("START", "multi_declarator:sym<proto>")
  debug_966:
    $I10 = self.'from'()
    ne $I10, -1, rxscan958_done
    goto rxscan958_scan
  rxscan958_loop:
    (rx954_pos) = rx954_cur."from"()
    inc rx954_pos
    rx954_cur."!cursor_from"(rx954_pos)
    ge rx954_pos, rx954_eos, rxscan958_done
  rxscan958_scan:
    set_addr $I10, rxscan958_loop
    rx954_cur."!mark_push"(0, rx954_pos, $I10)
  rxscan958_done:
.annotate 'line', 436
    rx954_cur."!cursor_pos"(rx954_pos)
    new $P959, "String"
    assign $P959, "proto"
    store_lex "$*MULTINESS", $P959
.annotate 'line', 437
  # rx subcapture "sym"
    set_addr $I10, rxcap_960_fail
    rx954_cur."!mark_push"(0, rx954_pos, $I10)
  # rx literal  "proto"
    add $I11, rx954_pos, 5
    gt $I11, rx954_eos, rx954_fail
    sub $I11, rx954_pos, rx954_off
    substr $S10, rx954_tgt, $I11, 5
    ne $S10, "proto", rx954_fail
    add rx954_pos, 5
    set_addr $I10, rxcap_960_fail
    ($I12, $I11) = rx954_cur."!mark_peek"($I10)
    rx954_cur."!cursor_pos"($I11)
    ($P10) = rx954_cur."!cursor_start"()
    $P10."!cursor_pass"(rx954_pos, "")
    rx954_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_960_done
  rxcap_960_fail:
    goto rx954_fail
  rxcap_960_done:
.annotate 'line', 438
  # rx subrule "ws" subtype=method negate=
    rx954_cur."!cursor_pos"(rx954_pos)
    $P10 = rx954_cur."ws"()
    unless $P10, rx954_fail
    rx954_pos = $P10."pos"()
  alt961_0:
    set_addr $I10, alt961_1
    rx954_cur."!mark_push"(0, rx954_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx954_cur."!cursor_pos"(rx954_pos)
    $P10 = rx954_cur."declarator"()
    unless $P10, rx954_fail
    rx954_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx954_pos = $P10."pos"()
    goto alt961_end
  alt961_1:
    set_addr $I10, alt961_2
    rx954_cur."!mark_push"(0, rx954_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx954_cur."!cursor_pos"(rx954_pos)
    $P10 = rx954_cur."routine_def"()
    unless $P10, rx954_fail
    rx954_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx954_pos = $P10."pos"()
    goto alt961_end
  alt961_2:
  # rx subrule "panic" subtype=method negate=
    rx954_cur."!cursor_pos"(rx954_pos)
    $P10 = rx954_cur."panic"("Malformed proto")
    unless $P10, rx954_fail
    rx954_pos = $P10."pos"()
  alt961_end:
.annotate 'line', 435
  # rx pass
    rx954_cur."!cursor_pass"(rx954_pos, "multi_declarator:sym<proto>")
    if_null rx954_debug, debug_967
    rx954_cur."!cursor_debug"("PASS", "multi_declarator:sym<proto>", " at pos=", rx954_pos)
  debug_967:
    .return (rx954_cur)
  rx954_restart:
.annotate 'line', 10
    if_null rx954_debug, debug_968
    rx954_cur."!cursor_debug"("NEXT", "multi_declarator:sym<proto>")
  debug_968:
  rx954_fail:
    (rx954_rep, rx954_pos, $I10, $P10) = rx954_cur."!mark_fail"(0)
    lt rx954_pos, -1, rx954_done
    eq rx954_pos, -1, rx954_fail
    jump $I10
  rx954_done:
    rx954_cur."!cursor_fail"()
    if_null rx954_debug, debug_969
    rx954_cur."!cursor_debug"("FAIL", "multi_declarator:sym<proto>")
  debug_969:
    .return (rx954_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<proto>"  :nsentry("!PREFIX__multi_declarator:sym<proto>") :subid("190_1303340952.947") :method
.annotate 'line', 10
    $P956 = self."!PREFIX__!subrule"("ws", "proto")
    new $P957, "ResizablePMCArray"
    push $P957, $P956
    .return ($P957)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<null>"  :subid("191_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 441
    new $P963, "Undef"
    .lex "$*MULTINESS", $P963
.annotate 'line', 10
    .local string rx964_tgt
    .local int rx964_pos
    .local int rx964_off
    .local int rx964_eos
    .local int rx964_rep
    .local pmc rx964_cur
    .local pmc rx964_debug
    (rx964_cur, rx964_pos, rx964_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx964_cur
    .local pmc match
    .lex "$/", match
    length rx964_eos, rx964_tgt
    gt rx964_pos, rx964_eos, rx964_done
    set rx964_off, 0
    lt rx964_pos, 2, rx964_start
    sub rx964_off, rx964_pos, 1
    substr rx964_tgt, rx964_tgt, rx964_off
  rx964_start:
    eq $I10, 1, rx964_restart
    if_null rx964_debug, debug_970
    rx964_cur."!cursor_debug"("START", "multi_declarator:sym<null>")
  debug_970:
    $I10 = self.'from'()
    ne $I10, -1, rxscan968_done
    goto rxscan968_scan
  rxscan968_loop:
    (rx964_pos) = rx964_cur."from"()
    inc rx964_pos
    rx964_cur."!cursor_from"(rx964_pos)
    ge rx964_pos, rx964_eos, rxscan968_done
  rxscan968_scan:
    set_addr $I10, rxscan968_loop
    rx964_cur."!mark_push"(0, rx964_pos, $I10)
  rxscan968_done:
.annotate 'line', 441
    rx964_cur."!cursor_pos"(rx964_pos)
    new $P969, "String"
    assign $P969, ""
    store_lex "$*MULTINESS", $P969
.annotate 'line', 442
  # rx subrule "declarator" subtype=capture negate=
    rx964_cur."!cursor_pos"(rx964_pos)
    $P10 = rx964_cur."declarator"()
    unless $P10, rx964_fail
    rx964_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx964_pos = $P10."pos"()
.annotate 'line', 440
  # rx pass
    rx964_cur."!cursor_pass"(rx964_pos, "multi_declarator:sym<null>")
    if_null rx964_debug, debug_971
    rx964_cur."!cursor_debug"("PASS", "multi_declarator:sym<null>", " at pos=", rx964_pos)
  debug_971:
    .return (rx964_cur)
  rx964_restart:
.annotate 'line', 10
    if_null rx964_debug, debug_972
    rx964_cur."!cursor_debug"("NEXT", "multi_declarator:sym<null>")
  debug_972:
  rx964_fail:
    (rx964_rep, rx964_pos, $I10, $P10) = rx964_cur."!mark_fail"(0)
    lt rx964_pos, -1, rx964_done
    eq rx964_pos, -1, rx964_fail
    jump $I10
  rx964_done:
    rx964_cur."!cursor_fail"()
    if_null rx964_debug, debug_973
    rx964_cur."!cursor_debug"("FAIL", "multi_declarator:sym<null>")
  debug_973:
    .return (rx964_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<null>"  :nsentry("!PREFIX__multi_declarator:sym<null>") :subid("192_1303340952.947") :method
.annotate 'line', 10
    $P966 = self."!PREFIX__!subrule"("declarator", "")
    new $P967, "ResizablePMCArray"
    push $P967, $P966
    .return ($P967)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "signature"  :subid("193_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .const 'Sub' $P979 = "195_1303340952.947" 
    capture_lex $P979
    .local string rx971_tgt
    .local int rx971_pos
    .local int rx971_off
    .local int rx971_eos
    .local int rx971_rep
    .local pmc rx971_cur
    .local pmc rx971_debug
    (rx971_cur, rx971_pos, rx971_tgt, $I10) = self."!cursor_start"()
    rx971_cur."!cursor_caparray"("invocant", "parameter")
    .lex unicode:"$\x{a2}", rx971_cur
    .local pmc match
    .lex "$/", match
    length rx971_eos, rx971_tgt
    gt rx971_pos, rx971_eos, rx971_done
    set rx971_off, 0
    lt rx971_pos, 2, rx971_start
    sub rx971_off, rx971_pos, 1
    substr rx971_tgt, rx971_tgt, rx971_off
  rx971_start:
    eq $I10, 1, rx971_restart
    if_null rx971_debug, debug_974
    rx971_cur."!cursor_debug"("START", "signature")
  debug_974:
    $I10 = self.'from'()
    ne $I10, -1, rxscan974_done
    goto rxscan974_scan
  rxscan974_loop:
    (rx971_pos) = rx971_cur."from"()
    inc rx971_pos
    rx971_cur."!cursor_from"(rx971_pos)
    ge rx971_pos, rx971_eos, rxscan974_done
  rxscan974_scan:
    set_addr $I10, rxscan974_loop
    rx971_cur."!mark_push"(0, rx971_pos, $I10)
  rxscan974_done:
.annotate 'line', 446
  # rx rxquantr975 ** 0..1
    set_addr $I10, rxquantr975_done
    rx971_cur."!mark_push"(0, rx971_pos, $I10)
  rxquantr975_loop:
    rx971_cur."!cursor_pos"(rx971_pos)
    find_lex $P976, unicode:"$\x{a2}"
    $P977 = $P976."MATCH"()
    store_lex "$/", $P977
    .const 'Sub' $P979 = "195_1303340952.947" 
    capture_lex $P979
    $P981 = $P979()
    unless $P981, rx971_fail
  # rx subrule "ws" subtype=method negate=
    rx971_cur."!cursor_pos"(rx971_pos)
    $P10 = rx971_cur."ws"()
    unless $P10, rx971_fail
    rx971_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx971_cur."!cursor_pos"(rx971_pos)
    $P10 = rx971_cur."parameter"()
    unless $P10, rx971_fail
    rx971_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("invocant")
    rx971_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx971_cur."!cursor_pos"(rx971_pos)
    $P10 = rx971_cur."ws"()
    unless $P10, rx971_fail
    rx971_pos = $P10."pos"()
  # rx literal  ":"
    add $I11, rx971_pos, 1
    gt $I11, rx971_eos, rx971_fail
    sub $I11, rx971_pos, rx971_off
    ord $I11, rx971_tgt, $I11
    ne $I11, 58, rx971_fail
    add rx971_pos, 1
    set_addr $I10, rxquantr975_done
    (rx971_rep) = rx971_cur."!mark_commit"($I10)
  rxquantr975_done:
.annotate 'line', 447
  # rx rxquantr982 ** 0..1
    set_addr $I10, rxquantr982_done
    rx971_cur."!mark_push"(0, rx971_pos, $I10)
  rxquantr982_loop:
  # rx rxquantr983 ** 1..*
    set_addr $I10, rxquantr983_done
    rx971_cur."!mark_push"(0, -1, $I10)
  rxquantr983_loop:
  # rx subrule "ws" subtype=method negate=
    rx971_cur."!cursor_pos"(rx971_pos)
    $P10 = rx971_cur."ws"()
    unless $P10, rx971_fail
    rx971_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx971_cur."!cursor_pos"(rx971_pos)
    $P10 = rx971_cur."parameter"()
    unless $P10, rx971_fail
    rx971_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parameter")
    rx971_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx971_cur."!cursor_pos"(rx971_pos)
    $P10 = rx971_cur."ws"()
    unless $P10, rx971_fail
    rx971_pos = $P10."pos"()
    set_addr $I10, rxquantr983_done
    (rx971_rep) = rx971_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr983_done
    rx971_cur."!mark_push"(rx971_rep, rx971_pos, $I10)
  # rx literal  ","
    add $I11, rx971_pos, 1
    gt $I11, rx971_eos, rx971_fail
    sub $I11, rx971_pos, rx971_off
    ord $I11, rx971_tgt, $I11
    ne $I11, 44, rx971_fail
    add rx971_pos, 1
    goto rxquantr983_loop
  rxquantr983_done:
    set_addr $I10, rxquantr982_done
    (rx971_rep) = rx971_cur."!mark_commit"($I10)
  rxquantr982_done:
.annotate 'line', 445
  # rx pass
    rx971_cur."!cursor_pass"(rx971_pos, "signature")
    if_null rx971_debug, debug_977
    rx971_cur."!cursor_debug"("PASS", "signature", " at pos=", rx971_pos)
  debug_977:
    .return (rx971_cur)
  rx971_restart:
.annotate 'line', 10
    if_null rx971_debug, debug_978
    rx971_cur."!cursor_debug"("NEXT", "signature")
  debug_978:
  rx971_fail:
    (rx971_rep, rx971_pos, $I10, $P10) = rx971_cur."!mark_fail"(0)
    lt rx971_pos, -1, rx971_done
    eq rx971_pos, -1, rx971_fail
    jump $I10
  rx971_done:
    rx971_cur."!cursor_fail"()
    if_null rx971_debug, debug_979
    rx971_cur."!cursor_debug"("FAIL", "signature")
  debug_979:
    .return (rx971_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__signature"  :nsentry("!PREFIX__signature") :subid("194_1303340952.947") :method
.annotate 'line', 10
    new $P973, "ResizablePMCArray"
    push $P973, ""
    .return ($P973)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block978"  :anon :subid("195_1303340952.947") :outer("193_1303340952.947")
.annotate 'line', 446
    find_dynamic_lex $P980, "$*INVOCANT_OK"
    unless_null $P980, vivify_975
    get_hll_global $P980, "$INVOCANT_OK"
    unless_null $P980, vivify_976
    die "Contextual $*INVOCANT_OK not found"
  vivify_976:
  vivify_975:
    .return ($P980)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "parameter"  :subid("196_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx985_tgt
    .local int rx985_pos
    .local int rx985_off
    .local int rx985_eos
    .local int rx985_rep
    .local pmc rx985_cur
    .local pmc rx985_debug
    (rx985_cur, rx985_pos, rx985_tgt, $I10) = self."!cursor_start"()
    rx985_cur."!cursor_caparray"("typename", "definedness", "default_value")
    .lex unicode:"$\x{a2}", rx985_cur
    .local pmc match
    .lex "$/", match
    length rx985_eos, rx985_tgt
    gt rx985_pos, rx985_eos, rx985_done
    set rx985_off, 0
    lt rx985_pos, 2, rx985_start
    sub rx985_off, rx985_pos, 1
    substr rx985_tgt, rx985_tgt, rx985_off
  rx985_start:
    eq $I10, 1, rx985_restart
    if_null rx985_debug, debug_980
    rx985_cur."!cursor_debug"("START", "parameter")
  debug_980:
    $I10 = self.'from'()
    ne $I10, -1, rxscan988_done
    goto rxscan988_scan
  rxscan988_loop:
    (rx985_pos) = rx985_cur."from"()
    inc rx985_pos
    rx985_cur."!cursor_from"(rx985_pos)
    ge rx985_pos, rx985_eos, rxscan988_done
  rxscan988_scan:
    set_addr $I10, rxscan988_loop
    rx985_cur."!mark_push"(0, rx985_pos, $I10)
  rxscan988_done:
.annotate 'line', 451
  # rx rxquantr989 ** 0..*
    set_addr $I10, rxquantr989_done
    rx985_cur."!mark_push"(0, rx985_pos, $I10)
  rxquantr989_loop:
  # rx subrule "typename" subtype=capture negate=
    rx985_cur."!cursor_pos"(rx985_pos)
    $P10 = rx985_cur."typename"()
    unless $P10, rx985_fail
    rx985_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("typename")
    rx985_pos = $P10."pos"()
  # rx rxquantr990 ** 0..1
    set_addr $I10, rxquantr990_done
    rx985_cur."!mark_push"(0, rx985_pos, $I10)
  rxquantr990_loop:
  # rx literal  ":"
    add $I11, rx985_pos, 1
    gt $I11, rx985_eos, rx985_fail
    sub $I11, rx985_pos, rx985_off
    ord $I11, rx985_tgt, $I11
    ne $I11, 58, rx985_fail
    add rx985_pos, 1
  # rx subcapture "definedness"
    set_addr $I10, rxcap_991_fail
    rx985_cur."!mark_push"(0, rx985_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx985_pos, rx985_eos, rx985_fail
    sub $I10, rx985_pos, rx985_off
    substr $S10, rx985_tgt, $I10, 1
    index $I11, "_DU", $S10
    lt $I11, 0, rx985_fail
    inc rx985_pos
    set_addr $I10, rxcap_991_fail
    ($I12, $I11) = rx985_cur."!mark_peek"($I10)
    rx985_cur."!cursor_pos"($I11)
    ($P10) = rx985_cur."!cursor_start"()
    $P10."!cursor_pass"(rx985_pos, "")
    rx985_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("definedness")
    goto rxcap_991_done
  rxcap_991_fail:
    goto rx985_fail
  rxcap_991_done:
    set_addr $I10, rxquantr990_done
    (rx985_rep) = rx985_cur."!mark_commit"($I10)
  rxquantr990_done:
  # rx subrule "ws" subtype=method negate=
    rx985_cur."!cursor_pos"(rx985_pos)
    $P10 = rx985_cur."ws"()
    unless $P10, rx985_fail
    rx985_pos = $P10."pos"()
    set_addr $I10, rxquantr989_done
    (rx985_rep) = rx985_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr989_done
    rx985_cur."!mark_push"(rx985_rep, rx985_pos, $I10)
    goto rxquantr989_loop
  rxquantr989_done:
  alt992_0:
.annotate 'line', 452
    set_addr $I10, alt992_1
    rx985_cur."!mark_push"(0, rx985_pos, $I10)
.annotate 'line', 453
  # rx subcapture "quant"
    set_addr $I10, rxcap_993_fail
    rx985_cur."!mark_push"(0, rx985_pos, $I10)
  # rx literal  "*"
    add $I11, rx985_pos, 1
    gt $I11, rx985_eos, rx985_fail
    sub $I11, rx985_pos, rx985_off
    ord $I11, rx985_tgt, $I11
    ne $I11, 42, rx985_fail
    add rx985_pos, 1
    set_addr $I10, rxcap_993_fail
    ($I12, $I11) = rx985_cur."!mark_peek"($I10)
    rx985_cur."!cursor_pos"($I11)
    ($P10) = rx985_cur."!cursor_start"()
    $P10."!cursor_pass"(rx985_pos, "")
    rx985_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_993_done
  rxcap_993_fail:
    goto rx985_fail
  rxcap_993_done:
  # rx subrule "param_var" subtype=capture negate=
    rx985_cur."!cursor_pos"(rx985_pos)
    $P10 = rx985_cur."param_var"()
    unless $P10, rx985_fail
    rx985_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx985_pos = $P10."pos"()
    goto alt992_end
  alt992_1:
  alt994_0:
.annotate 'line', 454
    set_addr $I10, alt994_1
    rx985_cur."!mark_push"(0, rx985_pos, $I10)
  # rx subrule "param_var" subtype=capture negate=
    rx985_cur."!cursor_pos"(rx985_pos)
    $P10 = rx985_cur."param_var"()
    unless $P10, rx985_fail
    rx985_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx985_pos = $P10."pos"()
    goto alt994_end
  alt994_1:
  # rx subrule "named_param" subtype=capture negate=
    rx985_cur."!cursor_pos"(rx985_pos)
    $P10 = rx985_cur."named_param"()
    unless $P10, rx985_fail
    rx985_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("named_param")
    rx985_pos = $P10."pos"()
  alt994_end:
  # rx subcapture "quant"
    set_addr $I10, rxcap_996_fail
    rx985_cur."!mark_push"(0, rx985_pos, $I10)
  alt995_0:
    set_addr $I10, alt995_1
    rx985_cur."!mark_push"(0, rx985_pos, $I10)
  # rx literal  "?"
    add $I11, rx985_pos, 1
    gt $I11, rx985_eos, rx985_fail
    sub $I11, rx985_pos, rx985_off
    ord $I11, rx985_tgt, $I11
    ne $I11, 63, rx985_fail
    add rx985_pos, 1
    goto alt995_end
  alt995_1:
    set_addr $I10, alt995_2
    rx985_cur."!mark_push"(0, rx985_pos, $I10)
  # rx literal  "!"
    add $I11, rx985_pos, 1
    gt $I11, rx985_eos, rx985_fail
    sub $I11, rx985_pos, rx985_off
    ord $I11, rx985_tgt, $I11
    ne $I11, 33, rx985_fail
    add rx985_pos, 1
    goto alt995_end
  alt995_2:
  alt995_end:
    set_addr $I10, rxcap_996_fail
    ($I12, $I11) = rx985_cur."!mark_peek"($I10)
    rx985_cur."!cursor_pos"($I11)
    ($P10) = rx985_cur."!cursor_start"()
    $P10."!cursor_pass"(rx985_pos, "")
    rx985_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_996_done
  rxcap_996_fail:
    goto rx985_fail
  rxcap_996_done:
  alt992_end:
.annotate 'line', 456
  # rx rxquantr997 ** 0..1
    set_addr $I10, rxquantr997_done
    rx985_cur."!mark_push"(0, rx985_pos, $I10)
  rxquantr997_loop:
  # rx subrule "default_value" subtype=capture negate=
    rx985_cur."!cursor_pos"(rx985_pos)
    $P10 = rx985_cur."default_value"()
    unless $P10, rx985_fail
    goto rxsubrule998_pass
  rxsubrule998_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx985_fail
  rxsubrule998_pass:
    set_addr $I10, rxsubrule998_back
    rx985_cur."!mark_push"(0, rx985_pos, $I10, $P10)
    $P10."!cursor_names"("default_value")
    rx985_pos = $P10."pos"()
    set_addr $I10, rxquantr997_done
    (rx985_rep) = rx985_cur."!mark_commit"($I10)
  rxquantr997_done:
.annotate 'line', 450
  # rx pass
    rx985_cur."!cursor_pass"(rx985_pos, "parameter")
    if_null rx985_debug, debug_981
    rx985_cur."!cursor_debug"("PASS", "parameter", " at pos=", rx985_pos)
  debug_981:
    .return (rx985_cur)
  rx985_restart:
.annotate 'line', 10
    if_null rx985_debug, debug_982
    rx985_cur."!cursor_debug"("NEXT", "parameter")
  debug_982:
  rx985_fail:
    (rx985_rep, rx985_pos, $I10, $P10) = rx985_cur."!mark_fail"(0)
    lt rx985_pos, -1, rx985_done
    eq rx985_pos, -1, rx985_fail
    jump $I10
  rx985_done:
    rx985_cur."!cursor_fail"()
    if_null rx985_debug, debug_983
    rx985_cur."!cursor_debug"("FAIL", "parameter")
  debug_983:
    .return (rx985_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__parameter"  :nsentry("!PREFIX__parameter") :subid("197_1303340952.947") :method
.annotate 'line', 10
    new $P987, "ResizablePMCArray"
    push $P987, ""
    .return ($P987)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "param_var"  :subid("198_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1000_tgt
    .local int rx1000_pos
    .local int rx1000_off
    .local int rx1000_eos
    .local int rx1000_rep
    .local pmc rx1000_cur
    .local pmc rx1000_debug
    (rx1000_cur, rx1000_pos, rx1000_tgt, $I10) = self."!cursor_start"()
    rx1000_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx1000_cur
    .local pmc match
    .lex "$/", match
    length rx1000_eos, rx1000_tgt
    gt rx1000_pos, rx1000_eos, rx1000_done
    set rx1000_off, 0
    lt rx1000_pos, 2, rx1000_start
    sub rx1000_off, rx1000_pos, 1
    substr rx1000_tgt, rx1000_tgt, rx1000_off
  rx1000_start:
    eq $I10, 1, rx1000_restart
    if_null rx1000_debug, debug_984
    rx1000_cur."!cursor_debug"("START", "param_var")
  debug_984:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1004_done
    goto rxscan1004_scan
  rxscan1004_loop:
    (rx1000_pos) = rx1000_cur."from"()
    inc rx1000_pos
    rx1000_cur."!cursor_from"(rx1000_pos)
    ge rx1000_pos, rx1000_eos, rxscan1004_done
  rxscan1004_scan:
    set_addr $I10, rxscan1004_loop
    rx1000_cur."!mark_push"(0, rx1000_pos, $I10)
  rxscan1004_done:
.annotate 'line', 460
  # rx subrule "sigil" subtype=capture negate=
    rx1000_cur."!cursor_pos"(rx1000_pos)
    $P10 = rx1000_cur."sigil"()
    unless $P10, rx1000_fail
    rx1000_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1000_pos = $P10."pos"()
  # rx rxquantr1005 ** 0..1
    set_addr $I10, rxquantr1005_done
    rx1000_cur."!mark_push"(0, rx1000_pos, $I10)
  rxquantr1005_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx1000_cur."!cursor_pos"(rx1000_pos)
    $P10 = rx1000_cur."twigil"()
    unless $P10, rx1000_fail
    goto rxsubrule1006_pass
  rxsubrule1006_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1000_fail
  rxsubrule1006_pass:
    set_addr $I10, rxsubrule1006_back
    rx1000_cur."!mark_push"(0, rx1000_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx1000_pos = $P10."pos"()
    set_addr $I10, rxquantr1005_done
    (rx1000_rep) = rx1000_cur."!mark_commit"($I10)
  rxquantr1005_done:
  alt1007_0:
.annotate 'line', 461
    set_addr $I10, alt1007_1
    rx1000_cur."!mark_push"(0, rx1000_pos, $I10)
  # rx subrule "ident" subtype=capture negate=
    rx1000_cur."!cursor_pos"(rx1000_pos)
    $P10 = rx1000_cur."ident"()
    unless $P10, rx1000_fail
    rx1000_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1000_pos = $P10."pos"()
    goto alt1007_end
  alt1007_1:
  # rx subcapture "name"
    set_addr $I10, rxcap_1008_fail
    rx1000_cur."!mark_push"(0, rx1000_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1000_pos, rx1000_eos, rx1000_fail
    sub $I10, rx1000_pos, rx1000_off
    substr $S10, rx1000_tgt, $I10, 1
    index $I11, "/!", $S10
    lt $I11, 0, rx1000_fail
    inc rx1000_pos
    set_addr $I10, rxcap_1008_fail
    ($I12, $I11) = rx1000_cur."!mark_peek"($I10)
    rx1000_cur."!cursor_pos"($I11)
    ($P10) = rx1000_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1000_pos, "")
    rx1000_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    goto rxcap_1008_done
  rxcap_1008_fail:
    goto rx1000_fail
  rxcap_1008_done:
  alt1007_end:
.annotate 'line', 459
  # rx pass
    rx1000_cur."!cursor_pass"(rx1000_pos, "param_var")
    if_null rx1000_debug, debug_985
    rx1000_cur."!cursor_debug"("PASS", "param_var", " at pos=", rx1000_pos)
  debug_985:
    .return (rx1000_cur)
  rx1000_restart:
.annotate 'line', 10
    if_null rx1000_debug, debug_986
    rx1000_cur."!cursor_debug"("NEXT", "param_var")
  debug_986:
  rx1000_fail:
    (rx1000_rep, rx1000_pos, $I10, $P10) = rx1000_cur."!mark_fail"(0)
    lt rx1000_pos, -1, rx1000_done
    eq rx1000_pos, -1, rx1000_fail
    jump $I10
  rx1000_done:
    rx1000_cur."!cursor_fail"()
    if_null rx1000_debug, debug_987
    rx1000_cur."!cursor_debug"("FAIL", "param_var")
  debug_987:
    .return (rx1000_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__param_var"  :nsentry("!PREFIX__param_var") :subid("199_1303340952.947") :method
.annotate 'line', 10
    $P1002 = self."!PREFIX__!subrule"("sigil", "")
    new $P1003, "ResizablePMCArray"
    push $P1003, $P1002
    .return ($P1003)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "named_param"  :subid("200_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1010_tgt
    .local int rx1010_pos
    .local int rx1010_off
    .local int rx1010_eos
    .local int rx1010_rep
    .local pmc rx1010_cur
    .local pmc rx1010_debug
    (rx1010_cur, rx1010_pos, rx1010_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1010_cur
    .local pmc match
    .lex "$/", match
    length rx1010_eos, rx1010_tgt
    gt rx1010_pos, rx1010_eos, rx1010_done
    set rx1010_off, 0
    lt rx1010_pos, 2, rx1010_start
    sub rx1010_off, rx1010_pos, 1
    substr rx1010_tgt, rx1010_tgt, rx1010_off
  rx1010_start:
    eq $I10, 1, rx1010_restart
    if_null rx1010_debug, debug_988
    rx1010_cur."!cursor_debug"("START", "named_param")
  debug_988:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1014_done
    goto rxscan1014_scan
  rxscan1014_loop:
    (rx1010_pos) = rx1010_cur."from"()
    inc rx1010_pos
    rx1010_cur."!cursor_from"(rx1010_pos)
    ge rx1010_pos, rx1010_eos, rxscan1014_done
  rxscan1014_scan:
    set_addr $I10, rxscan1014_loop
    rx1010_cur."!mark_push"(0, rx1010_pos, $I10)
  rxscan1014_done:
.annotate 'line', 465
  # rx literal  ":"
    add $I11, rx1010_pos, 1
    gt $I11, rx1010_eos, rx1010_fail
    sub $I11, rx1010_pos, rx1010_off
    ord $I11, rx1010_tgt, $I11
    ne $I11, 58, rx1010_fail
    add rx1010_pos, 1
  # rx subrule "param_var" subtype=capture negate=
    rx1010_cur."!cursor_pos"(rx1010_pos)
    $P10 = rx1010_cur."param_var"()
    unless $P10, rx1010_fail
    rx1010_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx1010_pos = $P10."pos"()
.annotate 'line', 464
  # rx pass
    rx1010_cur."!cursor_pass"(rx1010_pos, "named_param")
    if_null rx1010_debug, debug_989
    rx1010_cur."!cursor_debug"("PASS", "named_param", " at pos=", rx1010_pos)
  debug_989:
    .return (rx1010_cur)
  rx1010_restart:
.annotate 'line', 10
    if_null rx1010_debug, debug_990
    rx1010_cur."!cursor_debug"("NEXT", "named_param")
  debug_990:
  rx1010_fail:
    (rx1010_rep, rx1010_pos, $I10, $P10) = rx1010_cur."!mark_fail"(0)
    lt rx1010_pos, -1, rx1010_done
    eq rx1010_pos, -1, rx1010_fail
    jump $I10
  rx1010_done:
    rx1010_cur."!cursor_fail"()
    if_null rx1010_debug, debug_991
    rx1010_cur."!cursor_debug"("FAIL", "named_param")
  debug_991:
    .return (rx1010_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__named_param"  :nsentry("!PREFIX__named_param") :subid("201_1303340952.947") :method
.annotate 'line', 10
    $P1012 = self."!PREFIX__!subrule"("param_var", ":")
    new $P1013, "ResizablePMCArray"
    push $P1013, $P1012
    .return ($P1013)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "default_value"  :subid("202_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1016_tgt
    .local int rx1016_pos
    .local int rx1016_off
    .local int rx1016_eos
    .local int rx1016_rep
    .local pmc rx1016_cur
    .local pmc rx1016_debug
    (rx1016_cur, rx1016_pos, rx1016_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1016_cur
    .local pmc match
    .lex "$/", match
    length rx1016_eos, rx1016_tgt
    gt rx1016_pos, rx1016_eos, rx1016_done
    set rx1016_off, 0
    lt rx1016_pos, 2, rx1016_start
    sub rx1016_off, rx1016_pos, 1
    substr rx1016_tgt, rx1016_tgt, rx1016_off
  rx1016_start:
    eq $I10, 1, rx1016_restart
    if_null rx1016_debug, debug_992
    rx1016_cur."!cursor_debug"("START", "default_value")
  debug_992:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1020_done
    goto rxscan1020_scan
  rxscan1020_loop:
    (rx1016_pos) = rx1016_cur."from"()
    inc rx1016_pos
    rx1016_cur."!cursor_from"(rx1016_pos)
    ge rx1016_pos, rx1016_eos, rxscan1020_done
  rxscan1020_scan:
    set_addr $I10, rxscan1020_loop
    rx1016_cur."!mark_push"(0, rx1016_pos, $I10)
  rxscan1020_done:
.annotate 'line', 468
  # rx subrule "ws" subtype=method negate=
    rx1016_cur."!cursor_pos"(rx1016_pos)
    $P10 = rx1016_cur."ws"()
    unless $P10, rx1016_fail
    rx1016_pos = $P10."pos"()
  # rx literal  "="
    add $I11, rx1016_pos, 1
    gt $I11, rx1016_eos, rx1016_fail
    sub $I11, rx1016_pos, rx1016_off
    ord $I11, rx1016_tgt, $I11
    ne $I11, 61, rx1016_fail
    add rx1016_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1016_cur."!cursor_pos"(rx1016_pos)
    $P10 = rx1016_cur."ws"()
    unless $P10, rx1016_fail
    rx1016_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1016_cur."!cursor_pos"(rx1016_pos)
    $P10 = rx1016_cur."EXPR"("i=")
    unless $P10, rx1016_fail
    rx1016_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1016_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1016_cur."!cursor_pos"(rx1016_pos)
    $P10 = rx1016_cur."ws"()
    unless $P10, rx1016_fail
    rx1016_pos = $P10."pos"()
  # rx pass
    rx1016_cur."!cursor_pass"(rx1016_pos, "default_value")
    if_null rx1016_debug, debug_993
    rx1016_cur."!cursor_debug"("PASS", "default_value", " at pos=", rx1016_pos)
  debug_993:
    .return (rx1016_cur)
  rx1016_restart:
.annotate 'line', 10
    if_null rx1016_debug, debug_994
    rx1016_cur."!cursor_debug"("NEXT", "default_value")
  debug_994:
  rx1016_fail:
    (rx1016_rep, rx1016_pos, $I10, $P10) = rx1016_cur."!mark_fail"(0)
    lt rx1016_pos, -1, rx1016_done
    eq rx1016_pos, -1, rx1016_fail
    jump $I10
  rx1016_done:
    rx1016_cur."!cursor_fail"()
    if_null rx1016_debug, debug_995
    rx1016_cur."!cursor_debug"("FAIL", "default_value")
  debug_995:
    .return (rx1016_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__default_value"  :nsentry("!PREFIX__default_value") :subid("203_1303340952.947") :method
.annotate 'line', 10
    $P1018 = self."!PREFIX__!subrule"("ws", "")
    new $P1019, "ResizablePMCArray"
    push $P1019, $P1018
    .return ($P1019)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait"  :subid("204_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1025_tgt
    .local int rx1025_pos
    .local int rx1025_off
    .local int rx1025_eos
    .local int rx1025_rep
    .local pmc rx1025_cur
    .local pmc rx1025_debug
    (rx1025_cur, rx1025_pos, rx1025_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1025_cur
    .local pmc match
    .lex "$/", match
    length rx1025_eos, rx1025_tgt
    gt rx1025_pos, rx1025_eos, rx1025_done
    set rx1025_off, 0
    lt rx1025_pos, 2, rx1025_start
    sub rx1025_off, rx1025_pos, 1
    substr rx1025_tgt, rx1025_tgt, rx1025_off
  rx1025_start:
    eq $I10, 1, rx1025_restart
    if_null rx1025_debug, debug_996
    rx1025_cur."!cursor_debug"("START", "trait")
  debug_996:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1029_done
    goto rxscan1029_scan
  rxscan1029_loop:
    (rx1025_pos) = rx1025_cur."from"()
    inc rx1025_pos
    rx1025_cur."!cursor_from"(rx1025_pos)
    ge rx1025_pos, rx1025_eos, rxscan1029_done
  rxscan1029_scan:
    set_addr $I10, rxscan1029_loop
    rx1025_cur."!mark_push"(0, rx1025_pos, $I10)
  rxscan1029_done:
.annotate 'line', 470
  # rx subrule "ws" subtype=method negate=
    rx1025_cur."!cursor_pos"(rx1025_pos)
    $P10 = rx1025_cur."ws"()
    unless $P10, rx1025_fail
    rx1025_pos = $P10."pos"()
  # rx subrule "trait_mod" subtype=capture negate=
    rx1025_cur."!cursor_pos"(rx1025_pos)
    $P10 = rx1025_cur."trait_mod"()
    unless $P10, rx1025_fail
    rx1025_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("trait_mod")
    rx1025_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1025_cur."!cursor_pos"(rx1025_pos)
    $P10 = rx1025_cur."ws"()
    unless $P10, rx1025_fail
    rx1025_pos = $P10."pos"()
  # rx pass
    rx1025_cur."!cursor_pass"(rx1025_pos, "trait")
    if_null rx1025_debug, debug_997
    rx1025_cur."!cursor_debug"("PASS", "trait", " at pos=", rx1025_pos)
  debug_997:
    .return (rx1025_cur)
  rx1025_restart:
.annotate 'line', 10
    if_null rx1025_debug, debug_998
    rx1025_cur."!cursor_debug"("NEXT", "trait")
  debug_998:
  rx1025_fail:
    (rx1025_rep, rx1025_pos, $I10, $P10) = rx1025_cur."!mark_fail"(0)
    lt rx1025_pos, -1, rx1025_done
    eq rx1025_pos, -1, rx1025_fail
    jump $I10
  rx1025_done:
    rx1025_cur."!cursor_fail"()
    if_null rx1025_debug, debug_999
    rx1025_cur."!cursor_debug"("FAIL", "trait")
  debug_999:
    .return (rx1025_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait"  :nsentry("!PREFIX__trait") :subid("205_1303340952.947") :method
.annotate 'line', 10
    $P1027 = self."!PREFIX__!subrule"("ws", "")
    new $P1028, "ResizablePMCArray"
    push $P1028, $P1027
    .return ($P1028)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod"  :subid("206_1303340952.947")
    .param pmc param_1033
.annotate 'line', 472
    .lex "self", param_1033
    $P1034 = param_1033."!protoregex"("trait_mod")
    .return ($P1034)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod"  :subid("207_1303340952.947")
    .param pmc param_1036
.annotate 'line', 472
    .lex "self", param_1036
    $P1037 = param_1036."!PREFIX__!protoregex"("trait_mod")
    .return ($P1037)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod:sym<is>"  :subid("208_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1039_tgt
    .local int rx1039_pos
    .local int rx1039_off
    .local int rx1039_eos
    .local int rx1039_rep
    .local pmc rx1039_cur
    .local pmc rx1039_debug
    (rx1039_cur, rx1039_pos, rx1039_tgt, $I10) = self."!cursor_start"()
    rx1039_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx1039_cur
    .local pmc match
    .lex "$/", match
    length rx1039_eos, rx1039_tgt
    gt rx1039_pos, rx1039_eos, rx1039_done
    set rx1039_off, 0
    lt rx1039_pos, 2, rx1039_start
    sub rx1039_off, rx1039_pos, 1
    substr rx1039_tgt, rx1039_tgt, rx1039_off
  rx1039_start:
    eq $I10, 1, rx1039_restart
    if_null rx1039_debug, debug_1000
    rx1039_cur."!cursor_debug"("START", "trait_mod:sym<is>")
  debug_1000:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1043_done
    goto rxscan1043_scan
  rxscan1043_loop:
    (rx1039_pos) = rx1039_cur."from"()
    inc rx1039_pos
    rx1039_cur."!cursor_from"(rx1039_pos)
    ge rx1039_pos, rx1039_eos, rxscan1043_done
  rxscan1043_scan:
    set_addr $I10, rxscan1043_loop
    rx1039_cur."!mark_push"(0, rx1039_pos, $I10)
  rxscan1043_done:
.annotate 'line', 473
  # rx subcapture "sym"
    set_addr $I10, rxcap_1044_fail
    rx1039_cur."!mark_push"(0, rx1039_pos, $I10)
  # rx literal  "is"
    add $I11, rx1039_pos, 2
    gt $I11, rx1039_eos, rx1039_fail
    sub $I11, rx1039_pos, rx1039_off
    substr $S10, rx1039_tgt, $I11, 2
    ne $S10, "is", rx1039_fail
    add rx1039_pos, 2
    set_addr $I10, rxcap_1044_fail
    ($I12, $I11) = rx1039_cur."!mark_peek"($I10)
    rx1039_cur."!cursor_pos"($I11)
    ($P10) = rx1039_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1039_pos, "")
    rx1039_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1044_done
  rxcap_1044_fail:
    goto rx1039_fail
  rxcap_1044_done:
  # rx subrule "ws" subtype=method negate=
    rx1039_cur."!cursor_pos"(rx1039_pos)
    $P10 = rx1039_cur."ws"()
    unless $P10, rx1039_fail
    rx1039_pos = $P10."pos"()
  # rx subrule "deflongname" subtype=capture negate=
    rx1039_cur."!cursor_pos"(rx1039_pos)
    $P10 = rx1039_cur."deflongname"()
    unless $P10, rx1039_fail
    rx1039_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx1039_pos = $P10."pos"()
  # rx rxquantr1046 ** 0..1
    set_addr $I10, rxquantr1046_done
    rx1039_cur."!mark_push"(0, rx1039_pos, $I10)
  rxquantr1046_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx1039_cur."!cursor_pos"(rx1039_pos)
    $P10 = rx1039_cur."circumfix"()
    unless $P10, rx1039_fail
    goto rxsubrule1047_pass
  rxsubrule1047_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1039_fail
  rxsubrule1047_pass:
    set_addr $I10, rxsubrule1047_back
    rx1039_cur."!mark_push"(0, rx1039_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx1039_pos = $P10."pos"()
    set_addr $I10, rxquantr1046_done
    (rx1039_rep) = rx1039_cur."!mark_commit"($I10)
  rxquantr1046_done:
  # rx subrule "ws" subtype=method negate=
    rx1039_cur."!cursor_pos"(rx1039_pos)
    $P10 = rx1039_cur."ws"()
    unless $P10, rx1039_fail
    rx1039_pos = $P10."pos"()
  # rx pass
    rx1039_cur."!cursor_pass"(rx1039_pos, "trait_mod:sym<is>")
    if_null rx1039_debug, debug_1001
    rx1039_cur."!cursor_debug"("PASS", "trait_mod:sym<is>", " at pos=", rx1039_pos)
  debug_1001:
    .return (rx1039_cur)
  rx1039_restart:
.annotate 'line', 10
    if_null rx1039_debug, debug_1002
    rx1039_cur."!cursor_debug"("NEXT", "trait_mod:sym<is>")
  debug_1002:
  rx1039_fail:
    (rx1039_rep, rx1039_pos, $I10, $P10) = rx1039_cur."!mark_fail"(0)
    lt rx1039_pos, -1, rx1039_done
    eq rx1039_pos, -1, rx1039_fail
    jump $I10
  rx1039_done:
    rx1039_cur."!cursor_fail"()
    if_null rx1039_debug, debug_1003
    rx1039_cur."!cursor_debug"("FAIL", "trait_mod:sym<is>")
  debug_1003:
    .return (rx1039_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod:sym<is>"  :nsentry("!PREFIX__trait_mod:sym<is>") :subid("209_1303340952.947") :method
.annotate 'line', 10
    $P1041 = self."!PREFIX__!subrule"("ws", "is")
    new $P1042, "ResizablePMCArray"
    push $P1042, $P1041
    .return ($P1042)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "regex_declarator"  :subid("210_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1050_tgt
    .local int rx1050_pos
    .local int rx1050_off
    .local int rx1050_eos
    .local int rx1050_rep
    .local pmc rx1050_cur
    .local pmc rx1050_debug
    (rx1050_cur, rx1050_pos, rx1050_tgt, $I10) = self."!cursor_start"()
    rx1050_cur."!cursor_caparray"("signature")
    .lex unicode:"$\x{a2}", rx1050_cur
    .local pmc match
    .lex "$/", match
    length rx1050_eos, rx1050_tgt
    gt rx1050_pos, rx1050_eos, rx1050_done
    set rx1050_off, 0
    lt rx1050_pos, 2, rx1050_start
    sub rx1050_off, rx1050_pos, 1
    substr rx1050_tgt, rx1050_tgt, rx1050_off
  rx1050_start:
    eq $I10, 1, rx1050_restart
    if_null rx1050_debug, debug_1004
    rx1050_cur."!cursor_debug"("START", "regex_declarator")
  debug_1004:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1054_done
    goto rxscan1054_scan
  rxscan1054_loop:
    (rx1050_pos) = rx1050_cur."from"()
    inc rx1050_pos
    rx1050_cur."!cursor_from"(rx1050_pos)
    ge rx1050_pos, rx1050_eos, rxscan1054_done
  rxscan1054_scan:
    set_addr $I10, rxscan1054_loop
    rx1050_cur."!mark_push"(0, rx1050_pos, $I10)
  rxscan1054_done:
.annotate 'line', 475
  # rx subrule "ws" subtype=method negate=
    rx1050_cur."!cursor_pos"(rx1050_pos)
    $P10 = rx1050_cur."ws"()
    unless $P10, rx1050_fail
    rx1050_pos = $P10."pos"()
  alt1056_0:
.annotate 'line', 476
    set_addr $I10, alt1056_1
    rx1050_cur."!mark_push"(0, rx1050_pos, $I10)
.annotate 'line', 477
  # rx subrule "ws" subtype=method negate=
    rx1050_cur."!cursor_pos"(rx1050_pos)
    $P10 = rx1050_cur."ws"()
    unless $P10, rx1050_fail
    rx1050_pos = $P10."pos"()
  # rx subcapture "proto"
    set_addr $I10, rxcap_1058_fail
    rx1050_cur."!mark_push"(0, rx1050_pos, $I10)
  # rx literal  "proto"
    add $I11, rx1050_pos, 5
    gt $I11, rx1050_eos, rx1050_fail
    sub $I11, rx1050_pos, rx1050_off
    substr $S10, rx1050_tgt, $I11, 5
    ne $S10, "proto", rx1050_fail
    add rx1050_pos, 5
    set_addr $I10, rxcap_1058_fail
    ($I12, $I11) = rx1050_cur."!mark_peek"($I10)
    rx1050_cur."!cursor_pos"($I11)
    ($P10) = rx1050_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1050_pos, "")
    rx1050_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("proto")
    goto rxcap_1058_done
  rxcap_1058_fail:
    goto rx1050_fail
  rxcap_1058_done:
  # rx subrule "ws" subtype=method negate=
    rx1050_cur."!cursor_pos"(rx1050_pos)
    $P10 = rx1050_cur."ws"()
    unless $P10, rx1050_fail
    rx1050_pos = $P10."pos"()
  alt1060_0:
    set_addr $I10, alt1060_1
    rx1050_cur."!mark_push"(0, rx1050_pos, $I10)
  # rx literal  "regex"
    add $I11, rx1050_pos, 5
    gt $I11, rx1050_eos, rx1050_fail
    sub $I11, rx1050_pos, rx1050_off
    substr $S10, rx1050_tgt, $I11, 5
    ne $S10, "regex", rx1050_fail
    add rx1050_pos, 5
    goto alt1060_end
  alt1060_1:
    set_addr $I10, alt1060_2
    rx1050_cur."!mark_push"(0, rx1050_pos, $I10)
  # rx literal  "token"
    add $I11, rx1050_pos, 5
    gt $I11, rx1050_eos, rx1050_fail
    sub $I11, rx1050_pos, rx1050_off
    substr $S10, rx1050_tgt, $I11, 5
    ne $S10, "token", rx1050_fail
    add rx1050_pos, 5
    goto alt1060_end
  alt1060_2:
  # rx literal  "rule"
    add $I11, rx1050_pos, 4
    gt $I11, rx1050_eos, rx1050_fail
    sub $I11, rx1050_pos, rx1050_off
    substr $S10, rx1050_tgt, $I11, 4
    ne $S10, "rule", rx1050_fail
    add rx1050_pos, 4
  alt1060_end:
  # rx subrule "ws" subtype=method negate=
    rx1050_cur."!cursor_pos"(rx1050_pos)
    $P10 = rx1050_cur."ws"()
    unless $P10, rx1050_fail
    rx1050_pos = $P10."pos"()
.annotate 'line', 478
  # rx subrule "deflongname" subtype=capture negate=
    rx1050_cur."!cursor_pos"(rx1050_pos)
    $P10 = rx1050_cur."deflongname"()
    unless $P10, rx1050_fail
    rx1050_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1050_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1050_cur."!cursor_pos"(rx1050_pos)
    $P10 = rx1050_cur."ws"()
    unless $P10, rx1050_fail
    rx1050_pos = $P10."pos"()
  alt1063_0:
.annotate 'line', 479
    set_addr $I10, alt1063_1
    rx1050_cur."!mark_push"(0, rx1050_pos, $I10)
.annotate 'line', 480
  # rx subrule "ws" subtype=method negate=
    rx1050_cur."!cursor_pos"(rx1050_pos)
    $P10 = rx1050_cur."ws"()
    unless $P10, rx1050_fail
    rx1050_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx1050_pos, 1
    gt $I11, rx1050_eos, rx1050_fail
    sub $I11, rx1050_pos, rx1050_off
    ord $I11, rx1050_tgt, $I11
    ne $I11, 123, rx1050_fail
    add rx1050_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1050_cur."!cursor_pos"(rx1050_pos)
    $P10 = rx1050_cur."ws"()
    unless $P10, rx1050_fail
    rx1050_pos = $P10."pos"()
  # rx literal  "<...>"
    add $I11, rx1050_pos, 5
    gt $I11, rx1050_eos, rx1050_fail
    sub $I11, rx1050_pos, rx1050_off
    substr $S10, rx1050_tgt, $I11, 5
    ne $S10, "<...>", rx1050_fail
    add rx1050_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx1050_cur."!cursor_pos"(rx1050_pos)
    $P10 = rx1050_cur."ws"()
    unless $P10, rx1050_fail
    rx1050_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1050_pos, 1
    gt $I11, rx1050_eos, rx1050_fail
    sub $I11, rx1050_pos, rx1050_off
    ord $I11, rx1050_tgt, $I11
    ne $I11, 125, rx1050_fail
    add rx1050_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1050_cur."!cursor_pos"(rx1050_pos)
    $P10 = rx1050_cur."ENDSTMT"()
    unless $P10, rx1050_fail
  # rx subrule "ws" subtype=method negate=
    rx1050_cur."!cursor_pos"(rx1050_pos)
    $P10 = rx1050_cur."ws"()
    unless $P10, rx1050_fail
    rx1050_pos = $P10."pos"()
    goto alt1063_end
  alt1063_1:
    set_addr $I10, alt1063_2
    rx1050_cur."!mark_push"(0, rx1050_pos, $I10)
.annotate 'line', 481
  # rx subrule "ws" subtype=method negate=
    rx1050_cur."!cursor_pos"(rx1050_pos)
    $P10 = rx1050_cur."ws"()
    unless $P10, rx1050_fail
    rx1050_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx1050_pos, 1
    gt $I11, rx1050_eos, rx1050_fail
    sub $I11, rx1050_pos, rx1050_off
    ord $I11, rx1050_tgt, $I11
    ne $I11, 123, rx1050_fail
    add rx1050_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1050_cur."!cursor_pos"(rx1050_pos)
    $P10 = rx1050_cur."ws"()
    unless $P10, rx1050_fail
    rx1050_pos = $P10."pos"()
  # rx literal  "<*>"
    add $I11, rx1050_pos, 3
    gt $I11, rx1050_eos, rx1050_fail
    sub $I11, rx1050_pos, rx1050_off
    substr $S10, rx1050_tgt, $I11, 3
    ne $S10, "<*>", rx1050_fail
    add rx1050_pos, 3
  # rx subrule "ws" subtype=method negate=
    rx1050_cur."!cursor_pos"(rx1050_pos)
    $P10 = rx1050_cur."ws"()
    unless $P10, rx1050_fail
    rx1050_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1050_pos, 1
    gt $I11, rx1050_eos, rx1050_fail
    sub $I11, rx1050_pos, rx1050_off
    ord $I11, rx1050_tgt, $I11
    ne $I11, 125, rx1050_fail
    add rx1050_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1050_cur."!cursor_pos"(rx1050_pos)
    $P10 = rx1050_cur."ENDSTMT"()
    unless $P10, rx1050_fail
  # rx subrule "ws" subtype=method negate=
    rx1050_cur."!cursor_pos"(rx1050_pos)
    $P10 = rx1050_cur."ws"()
    unless $P10, rx1050_fail
    rx1050_pos = $P10."pos"()
    goto alt1063_end
  alt1063_2:
.annotate 'line', 482
  # rx subrule "ws" subtype=method negate=
    rx1050_cur."!cursor_pos"(rx1050_pos)
    $P10 = rx1050_cur."ws"()
    unless $P10, rx1050_fail
    rx1050_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1050_cur."!cursor_pos"(rx1050_pos)
    $P10 = rx1050_cur."panic"("Proto regex body must be <*> (or <...>, which is deprecated)")
    unless $P10, rx1050_fail
    rx1050_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1050_cur."!cursor_pos"(rx1050_pos)
    $P10 = rx1050_cur."ws"()
    unless $P10, rx1050_fail
    rx1050_pos = $P10."pos"()
  alt1063_end:
.annotate 'line', 483
  # rx subrule "ws" subtype=method negate=
    rx1050_cur."!cursor_pos"(rx1050_pos)
    $P10 = rx1050_cur."ws"()
    unless $P10, rx1050_fail
    rx1050_pos = $P10."pos"()
.annotate 'line', 477
    goto alt1056_end
  alt1056_1:
.annotate 'line', 484
  # rx subrule "ws" subtype=method negate=
    rx1050_cur."!cursor_pos"(rx1050_pos)
    $P10 = rx1050_cur."ws"()
    unless $P10, rx1050_fail
    rx1050_pos = $P10."pos"()
  # rx subcapture "sym"
    set_addr $I10, rxcap_1077_fail
    rx1050_cur."!mark_push"(0, rx1050_pos, $I10)
  alt1076_0:
    set_addr $I10, alt1076_1
    rx1050_cur."!mark_push"(0, rx1050_pos, $I10)
  # rx literal  "regex"
    add $I11, rx1050_pos, 5
    gt $I11, rx1050_eos, rx1050_fail
    sub $I11, rx1050_pos, rx1050_off
    substr $S10, rx1050_tgt, $I11, 5
    ne $S10, "regex", rx1050_fail
    add rx1050_pos, 5
    goto alt1076_end
  alt1076_1:
    set_addr $I10, alt1076_2
    rx1050_cur."!mark_push"(0, rx1050_pos, $I10)
  # rx literal  "token"
    add $I11, rx1050_pos, 5
    gt $I11, rx1050_eos, rx1050_fail
    sub $I11, rx1050_pos, rx1050_off
    substr $S10, rx1050_tgt, $I11, 5
    ne $S10, "token", rx1050_fail
    add rx1050_pos, 5
    goto alt1076_end
  alt1076_2:
  # rx literal  "rule"
    add $I11, rx1050_pos, 4
    gt $I11, rx1050_eos, rx1050_fail
    sub $I11, rx1050_pos, rx1050_off
    substr $S10, rx1050_tgt, $I11, 4
    ne $S10, "rule", rx1050_fail
    add rx1050_pos, 4
  alt1076_end:
    set_addr $I10, rxcap_1077_fail
    ($I12, $I11) = rx1050_cur."!mark_peek"($I10)
    rx1050_cur."!cursor_pos"($I11)
    ($P10) = rx1050_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1050_pos, "")
    rx1050_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1077_done
  rxcap_1077_fail:
    goto rx1050_fail
  rxcap_1077_done:
  # rx subrule "ws" subtype=method negate=
    rx1050_cur."!cursor_pos"(rx1050_pos)
    $P10 = rx1050_cur."ws"()
    unless $P10, rx1050_fail
    rx1050_pos = $P10."pos"()
.annotate 'line', 485
  # rx subrule "deflongname" subtype=capture negate=
    rx1050_cur."!cursor_pos"(rx1050_pos)
    $P10 = rx1050_cur."deflongname"()
    unless $P10, rx1050_fail
    rx1050_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1050_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1050_cur."!cursor_pos"(rx1050_pos)
    $P10 = rx1050_cur."ws"()
    unless $P10, rx1050_fail
    rx1050_pos = $P10."pos"()
.annotate 'line', 486
  # rx subrule "newpad" subtype=method negate=
    rx1050_cur."!cursor_pos"(rx1050_pos)
    $P10 = rx1050_cur."newpad"()
    unless $P10, rx1050_fail
    rx1050_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1050_cur."!cursor_pos"(rx1050_pos)
    $P10 = rx1050_cur."ws"()
    unless $P10, rx1050_fail
    rx1050_pos = $P10."pos"()
.annotate 'line', 487
  # rx rxquantr1081 ** 0..1
    set_addr $I10, rxquantr1081_done
    rx1050_cur."!mark_push"(0, rx1050_pos, $I10)
  rxquantr1081_loop:
  # rx subrule "ws" subtype=method negate=
    rx1050_cur."!cursor_pos"(rx1050_pos)
    $P10 = rx1050_cur."ws"()
    unless $P10, rx1050_fail
    rx1050_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1050_pos, 1
    gt $I11, rx1050_eos, rx1050_fail
    sub $I11, rx1050_pos, rx1050_off
    ord $I11, rx1050_tgt, $I11
    ne $I11, 40, rx1050_fail
    add rx1050_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1050_cur."!cursor_pos"(rx1050_pos)
    $P10 = rx1050_cur."ws"()
    unless $P10, rx1050_fail
    rx1050_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx1050_cur."!cursor_pos"(rx1050_pos)
    $P10 = rx1050_cur."signature"()
    unless $P10, rx1050_fail
    rx1050_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx1050_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1050_cur."!cursor_pos"(rx1050_pos)
    $P10 = rx1050_cur."ws"()
    unless $P10, rx1050_fail
    rx1050_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1050_pos, 1
    gt $I11, rx1050_eos, rx1050_fail
    sub $I11, rx1050_pos, rx1050_off
    ord $I11, rx1050_tgt, $I11
    ne $I11, 41, rx1050_fail
    add rx1050_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1050_cur."!cursor_pos"(rx1050_pos)
    $P10 = rx1050_cur."ws"()
    unless $P10, rx1050_fail
    rx1050_pos = $P10."pos"()
    set_addr $I10, rxquantr1081_done
    (rx1050_rep) = rx1050_cur."!mark_commit"($I10)
  rxquantr1081_done:
  # rx subrule "ws" subtype=method negate=
    rx1050_cur."!cursor_pos"(rx1050_pos)
    $P10 = rx1050_cur."ws"()
    unless $P10, rx1050_fail
    rx1050_pos = $P10."pos"()
.annotate 'line', 488
  # rx reduce name="regex_declarator" key="open"
    rx1050_cur."!cursor_pos"(rx1050_pos)
    rx1050_cur."!reduce"("regex_declarator", "open")
  # rx subrule "ws" subtype=method negate=
    rx1050_cur."!cursor_pos"(rx1050_pos)
    $P10 = rx1050_cur."ws"()
    unless $P10, rx1050_fail
    rx1050_pos = $P10."pos"()
.annotate 'line', 489
  # rx literal  "{"
    add $I11, rx1050_pos, 1
    gt $I11, rx1050_eos, rx1050_fail
    sub $I11, rx1050_pos, rx1050_off
    ord $I11, rx1050_tgt, $I11
    ne $I11, 123, rx1050_fail
    add rx1050_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx1050_cur."!cursor_pos"(rx1050_pos)
    $P10 = rx1050_cur."LANG"("Regex", "nibbler")
    unless $P10, rx1050_fail
    rx1050_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx1050_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1050_pos, 1
    gt $I11, rx1050_eos, rx1050_fail
    sub $I11, rx1050_pos, rx1050_off
    ord $I11, rx1050_tgt, $I11
    ne $I11, 125, rx1050_fail
    add rx1050_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1050_cur."!cursor_pos"(rx1050_pos)
    $P10 = rx1050_cur."ENDSTMT"()
    unless $P10, rx1050_fail
  # rx subrule "ws" subtype=method negate=
    rx1050_cur."!cursor_pos"(rx1050_pos)
    $P10 = rx1050_cur."ws"()
    unless $P10, rx1050_fail
    rx1050_pos = $P10."pos"()
  alt1056_end:
.annotate 'line', 490
  # rx subrule "ws" subtype=method negate=
    rx1050_cur."!cursor_pos"(rx1050_pos)
    $P10 = rx1050_cur."ws"()
    unless $P10, rx1050_fail
    rx1050_pos = $P10."pos"()
.annotate 'line', 475
  # rx pass
    rx1050_cur."!cursor_pass"(rx1050_pos, "regex_declarator")
    if_null rx1050_debug, debug_1005
    rx1050_cur."!cursor_debug"("PASS", "regex_declarator", " at pos=", rx1050_pos)
  debug_1005:
    .return (rx1050_cur)
  rx1050_restart:
.annotate 'line', 10
    if_null rx1050_debug, debug_1006
    rx1050_cur."!cursor_debug"("NEXT", "regex_declarator")
  debug_1006:
  rx1050_fail:
    (rx1050_rep, rx1050_pos, $I10, $P10) = rx1050_cur."!mark_fail"(0)
    lt rx1050_pos, -1, rx1050_done
    eq rx1050_pos, -1, rx1050_fail
    jump $I10
  rx1050_done:
    rx1050_cur."!cursor_fail"()
    if_null rx1050_debug, debug_1007
    rx1050_cur."!cursor_debug"("FAIL", "regex_declarator")
  debug_1007:
    .return (rx1050_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__regex_declarator"  :nsentry("!PREFIX__regex_declarator") :subid("211_1303340952.947") :method
.annotate 'line', 10
    $P1052 = self."!PREFIX__!subrule"("ws", "")
    new $P1053, "ResizablePMCArray"
    push $P1053, $P1052
    .return ($P1053)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "dotty"  :subid("212_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1091_tgt
    .local int rx1091_pos
    .local int rx1091_off
    .local int rx1091_eos
    .local int rx1091_rep
    .local pmc rx1091_cur
    .local pmc rx1091_debug
    (rx1091_cur, rx1091_pos, rx1091_tgt, $I10) = self."!cursor_start"()
    rx1091_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1091_cur
    .local pmc match
    .lex "$/", match
    length rx1091_eos, rx1091_tgt
    gt rx1091_pos, rx1091_eos, rx1091_done
    set rx1091_off, 0
    lt rx1091_pos, 2, rx1091_start
    sub rx1091_off, rx1091_pos, 1
    substr rx1091_tgt, rx1091_tgt, rx1091_off
  rx1091_start:
    eq $I10, 1, rx1091_restart
    if_null rx1091_debug, debug_1008
    rx1091_cur."!cursor_debug"("START", "dotty")
  debug_1008:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1095_done
    goto rxscan1095_scan
  rxscan1095_loop:
    (rx1091_pos) = rx1091_cur."from"()
    inc rx1091_pos
    rx1091_cur."!cursor_from"(rx1091_pos)
    ge rx1091_pos, rx1091_eos, rxscan1095_done
  rxscan1095_scan:
    set_addr $I10, rxscan1095_loop
    rx1091_cur."!mark_push"(0, rx1091_pos, $I10)
  rxscan1095_done:
.annotate 'line', 494
  # rx literal  "."
    add $I11, rx1091_pos, 1
    gt $I11, rx1091_eos, rx1091_fail
    sub $I11, rx1091_pos, rx1091_off
    ord $I11, rx1091_tgt, $I11
    ne $I11, 46, rx1091_fail
    add rx1091_pos, 1
  alt1096_0:
.annotate 'line', 495
    set_addr $I10, alt1096_1
    rx1091_cur."!mark_push"(0, rx1091_pos, $I10)
  # rx subrule "deflongname" subtype=capture negate=
    rx1091_cur."!cursor_pos"(rx1091_pos)
    $P10 = rx1091_cur."deflongname"()
    unless $P10, rx1091_fail
    rx1091_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname=deflongname")
    rx1091_pos = $P10."pos"()
    goto alt1096_end
  alt1096_1:
.annotate 'line', 496
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1091_pos, rx1091_off
    substr $S10, rx1091_tgt, $I10, 1
    index $I11, "'\"", $S10
    lt $I11, 0, rx1091_fail
  # rx subrule "quote" subtype=capture negate=
    rx1091_cur."!cursor_pos"(rx1091_pos)
    $P10 = rx1091_cur."quote"()
    unless $P10, rx1091_fail
    rx1091_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1091_pos = $P10."pos"()
  alt1097_0:
.annotate 'line', 497
    set_addr $I10, alt1097_1
    rx1091_cur."!mark_push"(0, rx1091_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1091_pos, rx1091_off
    substr $S10, rx1091_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1091_fail
    goto alt1097_end
  alt1097_1:
  # rx subrule "panic" subtype=method negate=
    rx1091_cur."!cursor_pos"(rx1091_pos)
    $P10 = rx1091_cur."panic"("Quoted method name requires parenthesized arguments")
    unless $P10, rx1091_fail
    rx1091_pos = $P10."pos"()
  alt1097_end:
  alt1096_end:
.annotate 'line', 503
  # rx rxquantr1098 ** 0..1
    set_addr $I10, rxquantr1098_done
    rx1091_cur."!mark_push"(0, rx1091_pos, $I10)
  rxquantr1098_loop:
  alt1099_0:
.annotate 'line', 500
    set_addr $I10, alt1099_1
    rx1091_cur."!mark_push"(0, rx1091_pos, $I10)
.annotate 'line', 501
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1091_pos, rx1091_off
    substr $S10, rx1091_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1091_fail
  # rx subrule "args" subtype=capture negate=
    rx1091_cur."!cursor_pos"(rx1091_pos)
    $P10 = rx1091_cur."args"()
    unless $P10, rx1091_fail
    rx1091_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1091_pos = $P10."pos"()
    goto alt1099_end
  alt1099_1:
.annotate 'line', 502
  # rx literal  ":"
    add $I11, rx1091_pos, 1
    gt $I11, rx1091_eos, rx1091_fail
    sub $I11, rx1091_pos, rx1091_off
    ord $I11, rx1091_tgt, $I11
    ne $I11, 58, rx1091_fail
    add rx1091_pos, 1
  # rx charclass s
    ge rx1091_pos, rx1091_eos, rx1091_fail
    sub $I10, rx1091_pos, rx1091_off
    is_cclass $I11, 32, rx1091_tgt, $I10
    unless $I11, rx1091_fail
    inc rx1091_pos
  # rx subrule "arglist" subtype=capture negate=
    rx1091_cur."!cursor_pos"(rx1091_pos)
    $P10 = rx1091_cur."arglist"()
    unless $P10, rx1091_fail
    rx1091_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1091_pos = $P10."pos"()
  alt1099_end:
.annotate 'line', 503
    set_addr $I10, rxquantr1098_done
    (rx1091_rep) = rx1091_cur."!mark_commit"($I10)
  rxquantr1098_done:
.annotate 'line', 493
  # rx pass
    rx1091_cur."!cursor_pass"(rx1091_pos, "dotty")
    if_null rx1091_debug, debug_1009
    rx1091_cur."!cursor_debug"("PASS", "dotty", " at pos=", rx1091_pos)
  debug_1009:
    .return (rx1091_cur)
  rx1091_restart:
.annotate 'line', 10
    if_null rx1091_debug, debug_1010
    rx1091_cur."!cursor_debug"("NEXT", "dotty")
  debug_1010:
  rx1091_fail:
    (rx1091_rep, rx1091_pos, $I10, $P10) = rx1091_cur."!mark_fail"(0)
    lt rx1091_pos, -1, rx1091_done
    eq rx1091_pos, -1, rx1091_fail
    jump $I10
  rx1091_done:
    rx1091_cur."!cursor_fail"()
    if_null rx1091_debug, debug_1011
    rx1091_cur."!cursor_debug"("FAIL", "dotty")
  debug_1011:
    .return (rx1091_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__dotty"  :nsentry("!PREFIX__dotty") :subid("213_1303340952.947") :method
.annotate 'line', 10
    $P1093 = self."!PREFIX__!subrule"("deflongname", ".")
    new $P1094, "ResizablePMCArray"
    push $P1094, "'"
    push $P1094, "\""
    push $P1094, $P1093
    .return ($P1094)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term"  :subid("214_1303340952.947")
    .param pmc param_1101
.annotate 'line', 507
    .lex "self", param_1101
    $P1102 = param_1101."!protoregex"("term")
    .return ($P1102)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term"  :subid("215_1303340952.947")
    .param pmc param_1104
.annotate 'line', 507
    .lex "self", param_1104
    $P1105 = param_1104."!PREFIX__!protoregex"("term")
    .return ($P1105)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<self>"  :subid("216_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1107_tgt
    .local int rx1107_pos
    .local int rx1107_off
    .local int rx1107_eos
    .local int rx1107_rep
    .local pmc rx1107_cur
    .local pmc rx1107_debug
    (rx1107_cur, rx1107_pos, rx1107_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1107_cur
    .local pmc match
    .lex "$/", match
    length rx1107_eos, rx1107_tgt
    gt rx1107_pos, rx1107_eos, rx1107_done
    set rx1107_off, 0
    lt rx1107_pos, 2, rx1107_start
    sub rx1107_off, rx1107_pos, 1
    substr rx1107_tgt, rx1107_tgt, rx1107_off
  rx1107_start:
    eq $I10, 1, rx1107_restart
    if_null rx1107_debug, debug_1012
    rx1107_cur."!cursor_debug"("START", "term:sym<self>")
  debug_1012:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1110_done
    goto rxscan1110_scan
  rxscan1110_loop:
    (rx1107_pos) = rx1107_cur."from"()
    inc rx1107_pos
    rx1107_cur."!cursor_from"(rx1107_pos)
    ge rx1107_pos, rx1107_eos, rxscan1110_done
  rxscan1110_scan:
    set_addr $I10, rxscan1110_loop
    rx1107_cur."!mark_push"(0, rx1107_pos, $I10)
  rxscan1110_done:
.annotate 'line', 509
  # rx subcapture "sym"
    set_addr $I10, rxcap_1111_fail
    rx1107_cur."!mark_push"(0, rx1107_pos, $I10)
  # rx literal  "self"
    add $I11, rx1107_pos, 4
    gt $I11, rx1107_eos, rx1107_fail
    sub $I11, rx1107_pos, rx1107_off
    substr $S10, rx1107_tgt, $I11, 4
    ne $S10, "self", rx1107_fail
    add rx1107_pos, 4
    set_addr $I10, rxcap_1111_fail
    ($I12, $I11) = rx1107_cur."!mark_peek"($I10)
    rx1107_cur."!cursor_pos"($I11)
    ($P10) = rx1107_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1107_pos, "")
    rx1107_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1111_done
  rxcap_1111_fail:
    goto rx1107_fail
  rxcap_1111_done:
  # rxanchor rwb
    le rx1107_pos, 0, rx1107_fail
    sub $I10, rx1107_pos, rx1107_off
    is_cclass $I11, 8192, rx1107_tgt, $I10
    if $I11, rx1107_fail
    dec $I10
    is_cclass $I11, 8192, rx1107_tgt, $I10
    unless $I11, rx1107_fail
  # rx pass
    rx1107_cur."!cursor_pass"(rx1107_pos, "term:sym<self>")
    if_null rx1107_debug, debug_1013
    rx1107_cur."!cursor_debug"("PASS", "term:sym<self>", " at pos=", rx1107_pos)
  debug_1013:
    .return (rx1107_cur)
  rx1107_restart:
.annotate 'line', 10
    if_null rx1107_debug, debug_1014
    rx1107_cur."!cursor_debug"("NEXT", "term:sym<self>")
  debug_1014:
  rx1107_fail:
    (rx1107_rep, rx1107_pos, $I10, $P10) = rx1107_cur."!mark_fail"(0)
    lt rx1107_pos, -1, rx1107_done
    eq rx1107_pos, -1, rx1107_fail
    jump $I10
  rx1107_done:
    rx1107_cur."!cursor_fail"()
    if_null rx1107_debug, debug_1015
    rx1107_cur."!cursor_debug"("FAIL", "term:sym<self>")
  debug_1015:
    .return (rx1107_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<self>"  :nsentry("!PREFIX__term:sym<self>") :subid("217_1303340952.947") :method
.annotate 'line', 10
    new $P1109, "ResizablePMCArray"
    push $P1109, "self"
    .return ($P1109)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<identifier>"  :subid("218_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1113_tgt
    .local int rx1113_pos
    .local int rx1113_off
    .local int rx1113_eos
    .local int rx1113_rep
    .local pmc rx1113_cur
    .local pmc rx1113_debug
    (rx1113_cur, rx1113_pos, rx1113_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1113_cur
    .local pmc match
    .lex "$/", match
    length rx1113_eos, rx1113_tgt
    gt rx1113_pos, rx1113_eos, rx1113_done
    set rx1113_off, 0
    lt rx1113_pos, 2, rx1113_start
    sub rx1113_off, rx1113_pos, 1
    substr rx1113_tgt, rx1113_tgt, rx1113_off
  rx1113_start:
    eq $I10, 1, rx1113_restart
    if_null rx1113_debug, debug_1016
    rx1113_cur."!cursor_debug"("START", "term:sym<identifier>")
  debug_1016:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1117_done
    goto rxscan1117_scan
  rxscan1117_loop:
    (rx1113_pos) = rx1113_cur."from"()
    inc rx1113_pos
    rx1113_cur."!cursor_from"(rx1113_pos)
    ge rx1113_pos, rx1113_eos, rxscan1117_done
  rxscan1117_scan:
    set_addr $I10, rxscan1117_loop
    rx1113_cur."!mark_push"(0, rx1113_pos, $I10)
  rxscan1117_done:
.annotate 'line', 512
  # rx subrule "deflongname" subtype=capture negate=
    rx1113_cur."!cursor_pos"(rx1113_pos)
    $P10 = rx1113_cur."deflongname"()
    unless $P10, rx1113_fail
    rx1113_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1113_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1113_pos, rx1113_off
    substr $S10, rx1113_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1113_fail
  # rx subrule "args" subtype=capture negate=
    rx1113_cur."!cursor_pos"(rx1113_pos)
    $P10 = rx1113_cur."args"()
    unless $P10, rx1113_fail
    rx1113_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1113_pos = $P10."pos"()
.annotate 'line', 511
  # rx pass
    rx1113_cur."!cursor_pass"(rx1113_pos, "term:sym<identifier>")
    if_null rx1113_debug, debug_1017
    rx1113_cur."!cursor_debug"("PASS", "term:sym<identifier>", " at pos=", rx1113_pos)
  debug_1017:
    .return (rx1113_cur)
  rx1113_restart:
.annotate 'line', 10
    if_null rx1113_debug, debug_1018
    rx1113_cur."!cursor_debug"("NEXT", "term:sym<identifier>")
  debug_1018:
  rx1113_fail:
    (rx1113_rep, rx1113_pos, $I10, $P10) = rx1113_cur."!mark_fail"(0)
    lt rx1113_pos, -1, rx1113_done
    eq rx1113_pos, -1, rx1113_fail
    jump $I10
  rx1113_done:
    rx1113_cur."!cursor_fail"()
    if_null rx1113_debug, debug_1019
    rx1113_cur."!cursor_debug"("FAIL", "term:sym<identifier>")
  debug_1019:
    .return (rx1113_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<identifier>"  :nsentry("!PREFIX__term:sym<identifier>") :subid("219_1303340952.947") :method
.annotate 'line', 10
    $P1115 = self."!PREFIX__!subrule"("deflongname", "")
    new $P1116, "ResizablePMCArray"
    push $P1116, $P1115
    .return ($P1116)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<name>"  :subid("220_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1119_tgt
    .local int rx1119_pos
    .local int rx1119_off
    .local int rx1119_eos
    .local int rx1119_rep
    .local pmc rx1119_cur
    .local pmc rx1119_debug
    (rx1119_cur, rx1119_pos, rx1119_tgt, $I10) = self."!cursor_start"()
    rx1119_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1119_cur
    .local pmc match
    .lex "$/", match
    length rx1119_eos, rx1119_tgt
    gt rx1119_pos, rx1119_eos, rx1119_done
    set rx1119_off, 0
    lt rx1119_pos, 2, rx1119_start
    sub rx1119_off, rx1119_pos, 1
    substr rx1119_tgt, rx1119_tgt, rx1119_off
  rx1119_start:
    eq $I10, 1, rx1119_restart
    if_null rx1119_debug, debug_1020
    rx1119_cur."!cursor_debug"("START", "term:sym<name>")
  debug_1020:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1123_done
    goto rxscan1123_scan
  rxscan1123_loop:
    (rx1119_pos) = rx1119_cur."from"()
    inc rx1119_pos
    rx1119_cur."!cursor_from"(rx1119_pos)
    ge rx1119_pos, rx1119_eos, rxscan1123_done
  rxscan1123_scan:
    set_addr $I10, rxscan1123_loop
    rx1119_cur."!mark_push"(0, rx1119_pos, $I10)
  rxscan1123_done:
.annotate 'line', 516
  # rx subrule "name" subtype=capture negate=
    rx1119_cur."!cursor_pos"(rx1119_pos)
    $P10 = rx1119_cur."name"()
    unless $P10, rx1119_fail
    rx1119_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1119_pos = $P10."pos"()
  # rx rxquantr1124 ** 0..1
    set_addr $I10, rxquantr1124_done
    rx1119_cur."!mark_push"(0, rx1119_pos, $I10)
  rxquantr1124_loop:
  # rx subrule "args" subtype=capture negate=
    rx1119_cur."!cursor_pos"(rx1119_pos)
    $P10 = rx1119_cur."args"()
    unless $P10, rx1119_fail
    goto rxsubrule1125_pass
  rxsubrule1125_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1119_fail
  rxsubrule1125_pass:
    set_addr $I10, rxsubrule1125_back
    rx1119_cur."!mark_push"(0, rx1119_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1119_pos = $P10."pos"()
    set_addr $I10, rxquantr1124_done
    (rx1119_rep) = rx1119_cur."!mark_commit"($I10)
  rxquantr1124_done:
.annotate 'line', 515
  # rx pass
    rx1119_cur."!cursor_pass"(rx1119_pos, "term:sym<name>")
    if_null rx1119_debug, debug_1021
    rx1119_cur."!cursor_debug"("PASS", "term:sym<name>", " at pos=", rx1119_pos)
  debug_1021:
    .return (rx1119_cur)
  rx1119_restart:
.annotate 'line', 10
    if_null rx1119_debug, debug_1022
    rx1119_cur."!cursor_debug"("NEXT", "term:sym<name>")
  debug_1022:
  rx1119_fail:
    (rx1119_rep, rx1119_pos, $I10, $P10) = rx1119_cur."!mark_fail"(0)
    lt rx1119_pos, -1, rx1119_done
    eq rx1119_pos, -1, rx1119_fail
    jump $I10
  rx1119_done:
    rx1119_cur."!cursor_fail"()
    if_null rx1119_debug, debug_1023
    rx1119_cur."!cursor_debug"("FAIL", "term:sym<name>")
  debug_1023:
    .return (rx1119_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<name>"  :nsentry("!PREFIX__term:sym<name>") :subid("221_1303340952.947") :method
.annotate 'line', 10
    $P1121 = self."!PREFIX__!subrule"("name", "")
    new $P1122, "ResizablePMCArray"
    push $P1122, $P1121
    .return ($P1122)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<pir::op>"  :subid("222_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1127_tgt
    .local int rx1127_pos
    .local int rx1127_off
    .local int rx1127_eos
    .local int rx1127_rep
    .local pmc rx1127_cur
    .local pmc rx1127_debug
    (rx1127_cur, rx1127_pos, rx1127_tgt, $I10) = self."!cursor_start"()
    rx1127_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1127_cur
    .local pmc match
    .lex "$/", match
    length rx1127_eos, rx1127_tgt
    gt rx1127_pos, rx1127_eos, rx1127_done
    set rx1127_off, 0
    lt rx1127_pos, 2, rx1127_start
    sub rx1127_off, rx1127_pos, 1
    substr rx1127_tgt, rx1127_tgt, rx1127_off
  rx1127_start:
    eq $I10, 1, rx1127_restart
    if_null rx1127_debug, debug_1024
    rx1127_cur."!cursor_debug"("START", "term:sym<pir::op>")
  debug_1024:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1130_done
    goto rxscan1130_scan
  rxscan1130_loop:
    (rx1127_pos) = rx1127_cur."from"()
    inc rx1127_pos
    rx1127_cur."!cursor_from"(rx1127_pos)
    ge rx1127_pos, rx1127_eos, rxscan1130_done
  rxscan1130_scan:
    set_addr $I10, rxscan1130_loop
    rx1127_cur."!mark_push"(0, rx1127_pos, $I10)
  rxscan1130_done:
.annotate 'line', 520
  # rx literal  "pir::"
    add $I11, rx1127_pos, 5
    gt $I11, rx1127_eos, rx1127_fail
    sub $I11, rx1127_pos, rx1127_off
    substr $S10, rx1127_tgt, $I11, 5
    ne $S10, "pir::", rx1127_fail
    add rx1127_pos, 5
  # rx subcapture "op"
    set_addr $I10, rxcap_1131_fail
    rx1127_cur."!mark_push"(0, rx1127_pos, $I10)
  # rx charclass_q w r 1..-1
    sub $I10, rx1127_pos, rx1127_off
    find_not_cclass $I11, 8192, rx1127_tgt, $I10, rx1127_eos
    add $I12, $I10, 1
    lt $I11, $I12, rx1127_fail
    add rx1127_pos, rx1127_off, $I11
    set_addr $I10, rxcap_1131_fail
    ($I12, $I11) = rx1127_cur."!mark_peek"($I10)
    rx1127_cur."!cursor_pos"($I11)
    ($P10) = rx1127_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1127_pos, "")
    rx1127_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("op")
    goto rxcap_1131_done
  rxcap_1131_fail:
    goto rx1127_fail
  rxcap_1131_done:
  # rx rxquantr1132 ** 0..1
    set_addr $I10, rxquantr1132_done
    rx1127_cur."!mark_push"(0, rx1127_pos, $I10)
  rxquantr1132_loop:
  # rx subrule "args" subtype=capture negate=
    rx1127_cur."!cursor_pos"(rx1127_pos)
    $P10 = rx1127_cur."args"()
    unless $P10, rx1127_fail
    goto rxsubrule1133_pass
  rxsubrule1133_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1127_fail
  rxsubrule1133_pass:
    set_addr $I10, rxsubrule1133_back
    rx1127_cur."!mark_push"(0, rx1127_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1127_pos = $P10."pos"()
    set_addr $I10, rxquantr1132_done
    (rx1127_rep) = rx1127_cur."!mark_commit"($I10)
  rxquantr1132_done:
.annotate 'line', 519
  # rx pass
    rx1127_cur."!cursor_pass"(rx1127_pos, "term:sym<pir::op>")
    if_null rx1127_debug, debug_1025
    rx1127_cur."!cursor_debug"("PASS", "term:sym<pir::op>", " at pos=", rx1127_pos)
  debug_1025:
    .return (rx1127_cur)
  rx1127_restart:
.annotate 'line', 10
    if_null rx1127_debug, debug_1026
    rx1127_cur."!cursor_debug"("NEXT", "term:sym<pir::op>")
  debug_1026:
  rx1127_fail:
    (rx1127_rep, rx1127_pos, $I10, $P10) = rx1127_cur."!mark_fail"(0)
    lt rx1127_pos, -1, rx1127_done
    eq rx1127_pos, -1, rx1127_fail
    jump $I10
  rx1127_done:
    rx1127_cur."!cursor_fail"()
    if_null rx1127_debug, debug_1027
    rx1127_cur."!cursor_debug"("FAIL", "term:sym<pir::op>")
  debug_1027:
    .return (rx1127_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<pir::op>"  :nsentry("!PREFIX__term:sym<pir::op>") :subid("223_1303340952.947") :method
.annotate 'line', 10
    new $P1129, "ResizablePMCArray"
    push $P1129, "pir::"
    .return ($P1129)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<onlystar>"  :subid("224_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .const 'Sub' $P1143 = "226_1303340952.947" 
    capture_lex $P1143
    .local string rx1135_tgt
    .local int rx1135_pos
    .local int rx1135_off
    .local int rx1135_eos
    .local int rx1135_rep
    .local pmc rx1135_cur
    .local pmc rx1135_debug
    (rx1135_cur, rx1135_pos, rx1135_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1135_cur
    .local pmc match
    .lex "$/", match
    length rx1135_eos, rx1135_tgt
    gt rx1135_pos, rx1135_eos, rx1135_done
    set rx1135_off, 0
    lt rx1135_pos, 2, rx1135_start
    sub rx1135_off, rx1135_pos, 1
    substr rx1135_tgt, rx1135_tgt, rx1135_off
  rx1135_start:
    eq $I10, 1, rx1135_restart
    if_null rx1135_debug, debug_1028
    rx1135_cur."!cursor_debug"("START", "term:sym<onlystar>")
  debug_1028:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1138_done
    goto rxscan1138_scan
  rxscan1138_loop:
    (rx1135_pos) = rx1135_cur."from"()
    inc rx1135_pos
    rx1135_cur."!cursor_from"(rx1135_pos)
    ge rx1135_pos, rx1135_eos, rxscan1138_done
  rxscan1138_scan:
    set_addr $I10, rxscan1138_loop
    rx1135_cur."!mark_push"(0, rx1135_pos, $I10)
  rxscan1138_done:
.annotate 'line', 524
  # rx literal  "{*}"
    add $I11, rx1135_pos, 3
    gt $I11, rx1135_eos, rx1135_fail
    sub $I11, rx1135_pos, rx1135_off
    substr $S10, rx1135_tgt, $I11, 3
    ne $S10, "{*}", rx1135_fail
    add rx1135_pos, 3
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1135_cur."!cursor_pos"(rx1135_pos)
    $P10 = rx1135_cur."ENDSTMT"()
    unless $P10, rx1135_fail
  alt1139_0:
.annotate 'line', 525
    set_addr $I10, alt1139_1
    rx1135_cur."!mark_push"(0, rx1135_pos, $I10)
    rx1135_cur."!cursor_pos"(rx1135_pos)
    find_lex $P1140, unicode:"$\x{a2}"
    $P1141 = $P1140."MATCH"()
    store_lex "$/", $P1141
    .const 'Sub' $P1143 = "226_1303340952.947" 
    capture_lex $P1143
    $P1147 = $P1143()
    unless $P1147, rx1135_fail
    goto alt1139_end
  alt1139_1:
  # rx subrule "panic" subtype=method negate=
    rx1135_cur."!cursor_pos"(rx1135_pos)
    $P10 = rx1135_cur."panic"("{*} may only appear in proto")
    unless $P10, rx1135_fail
    rx1135_pos = $P10."pos"()
  alt1139_end:
.annotate 'line', 523
  # rx pass
    rx1135_cur."!cursor_pass"(rx1135_pos, "term:sym<onlystar>")
    if_null rx1135_debug, debug_1031
    rx1135_cur."!cursor_debug"("PASS", "term:sym<onlystar>", " at pos=", rx1135_pos)
  debug_1031:
    .return (rx1135_cur)
  rx1135_restart:
.annotate 'line', 10
    if_null rx1135_debug, debug_1032
    rx1135_cur."!cursor_debug"("NEXT", "term:sym<onlystar>")
  debug_1032:
  rx1135_fail:
    (rx1135_rep, rx1135_pos, $I10, $P10) = rx1135_cur."!mark_fail"(0)
    lt rx1135_pos, -1, rx1135_done
    eq rx1135_pos, -1, rx1135_fail
    jump $I10
  rx1135_done:
    rx1135_cur."!cursor_fail"()
    if_null rx1135_debug, debug_1033
    rx1135_cur."!cursor_debug"("FAIL", "term:sym<onlystar>")
  debug_1033:
    .return (rx1135_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<onlystar>"  :nsentry("!PREFIX__term:sym<onlystar>") :subid("225_1303340952.947") :method
.annotate 'line', 10
    new $P1137, "ResizablePMCArray"
    push $P1137, "{*}"
    .return ($P1137)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1142"  :anon :subid("226_1303340952.947") :outer("224_1303340952.947")
.annotate 'line', 525
    find_dynamic_lex $P1144, "$*MULTINESS"
    unless_null $P1144, vivify_1029
    get_hll_global $P1144, "$MULTINESS"
    unless_null $P1144, vivify_1030
    die "Contextual $*MULTINESS not found"
  vivify_1030:
  vivify_1029:
    set $S1145, $P1144
    iseq $I1146, $S1145, "proto"
    .return ($I1146)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "args"  :subid("227_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1149_tgt
    .local int rx1149_pos
    .local int rx1149_off
    .local int rx1149_eos
    .local int rx1149_rep
    .local pmc rx1149_cur
    .local pmc rx1149_debug
    (rx1149_cur, rx1149_pos, rx1149_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1149_cur
    .local pmc match
    .lex "$/", match
    length rx1149_eos, rx1149_tgt
    gt rx1149_pos, rx1149_eos, rx1149_done
    set rx1149_off, 0
    lt rx1149_pos, 2, rx1149_start
    sub rx1149_off, rx1149_pos, 1
    substr rx1149_tgt, rx1149_tgt, rx1149_off
  rx1149_start:
    eq $I10, 1, rx1149_restart
    if_null rx1149_debug, debug_1034
    rx1149_cur."!cursor_debug"("START", "args")
  debug_1034:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1153_done
    goto rxscan1153_scan
  rxscan1153_loop:
    (rx1149_pos) = rx1149_cur."from"()
    inc rx1149_pos
    rx1149_cur."!cursor_from"(rx1149_pos)
    ge rx1149_pos, rx1149_eos, rxscan1153_done
  rxscan1153_scan:
    set_addr $I10, rxscan1153_loop
    rx1149_cur."!mark_push"(0, rx1149_pos, $I10)
  rxscan1153_done:
.annotate 'line', 529
  # rx literal  "("
    add $I11, rx1149_pos, 1
    gt $I11, rx1149_eos, rx1149_fail
    sub $I11, rx1149_pos, rx1149_off
    ord $I11, rx1149_tgt, $I11
    ne $I11, 40, rx1149_fail
    add rx1149_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx1149_cur."!cursor_pos"(rx1149_pos)
    $P10 = rx1149_cur."arglist"()
    unless $P10, rx1149_fail
    rx1149_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1149_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1149_pos, 1
    gt $I11, rx1149_eos, rx1149_fail
    sub $I11, rx1149_pos, rx1149_off
    ord $I11, rx1149_tgt, $I11
    ne $I11, 41, rx1149_fail
    add rx1149_pos, 1
  # rx pass
    rx1149_cur."!cursor_pass"(rx1149_pos, "args")
    if_null rx1149_debug, debug_1035
    rx1149_cur."!cursor_debug"("PASS", "args", " at pos=", rx1149_pos)
  debug_1035:
    .return (rx1149_cur)
  rx1149_restart:
.annotate 'line', 10
    if_null rx1149_debug, debug_1036
    rx1149_cur."!cursor_debug"("NEXT", "args")
  debug_1036:
  rx1149_fail:
    (rx1149_rep, rx1149_pos, $I10, $P10) = rx1149_cur."!mark_fail"(0)
    lt rx1149_pos, -1, rx1149_done
    eq rx1149_pos, -1, rx1149_fail
    jump $I10
  rx1149_done:
    rx1149_cur."!cursor_fail"()
    if_null rx1149_debug, debug_1037
    rx1149_cur."!cursor_debug"("FAIL", "args")
  debug_1037:
    .return (rx1149_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__args"  :nsentry("!PREFIX__args") :subid("228_1303340952.947") :method
.annotate 'line', 10
    $P1151 = self."!PREFIX__!subrule"("arglist", "(")
    new $P1152, "ResizablePMCArray"
    push $P1152, $P1151
    .return ($P1152)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "arglist"  :subid("229_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1155_tgt
    .local int rx1155_pos
    .local int rx1155_off
    .local int rx1155_eos
    .local int rx1155_rep
    .local pmc rx1155_cur
    .local pmc rx1155_debug
    (rx1155_cur, rx1155_pos, rx1155_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1155_cur
    .local pmc match
    .lex "$/", match
    length rx1155_eos, rx1155_tgt
    gt rx1155_pos, rx1155_eos, rx1155_done
    set rx1155_off, 0
    lt rx1155_pos, 2, rx1155_start
    sub rx1155_off, rx1155_pos, 1
    substr rx1155_tgt, rx1155_tgt, rx1155_off
  rx1155_start:
    eq $I10, 1, rx1155_restart
    if_null rx1155_debug, debug_1038
    rx1155_cur."!cursor_debug"("START", "arglist")
  debug_1038:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1159_done
    goto rxscan1159_scan
  rxscan1159_loop:
    (rx1155_pos) = rx1155_cur."from"()
    inc rx1155_pos
    rx1155_cur."!cursor_from"(rx1155_pos)
    ge rx1155_pos, rx1155_eos, rxscan1159_done
  rxscan1159_scan:
    set_addr $I10, rxscan1159_loop
    rx1155_cur."!mark_push"(0, rx1155_pos, $I10)
  rxscan1159_done:
.annotate 'line', 533
  # rx subrule "ws" subtype=method negate=
    rx1155_cur."!cursor_pos"(rx1155_pos)
    $P10 = rx1155_cur."ws"()
    unless $P10, rx1155_fail
    rx1155_pos = $P10."pos"()
  alt1160_0:
.annotate 'line', 534
    set_addr $I10, alt1160_1
    rx1155_cur."!mark_push"(0, rx1155_pos, $I10)
.annotate 'line', 535
  # rx subrule "EXPR" subtype=capture negate=
    rx1155_cur."!cursor_pos"(rx1155_pos)
    $P10 = rx1155_cur."EXPR"("f=")
    unless $P10, rx1155_fail
    rx1155_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1155_pos = $P10."pos"()
    goto alt1160_end
  alt1160_1:
  alt1160_end:
.annotate 'line', 532
  # rx pass
    rx1155_cur."!cursor_pass"(rx1155_pos, "arglist")
    if_null rx1155_debug, debug_1039
    rx1155_cur."!cursor_debug"("PASS", "arglist", " at pos=", rx1155_pos)
  debug_1039:
    .return (rx1155_cur)
  rx1155_restart:
.annotate 'line', 10
    if_null rx1155_debug, debug_1040
    rx1155_cur."!cursor_debug"("NEXT", "arglist")
  debug_1040:
  rx1155_fail:
    (rx1155_rep, rx1155_pos, $I10, $P10) = rx1155_cur."!mark_fail"(0)
    lt rx1155_pos, -1, rx1155_done
    eq rx1155_pos, -1, rx1155_fail
    jump $I10
  rx1155_done:
    rx1155_cur."!cursor_fail"()
    if_null rx1155_debug, debug_1041
    rx1155_cur."!cursor_debug"("FAIL", "arglist")
  debug_1041:
    .return (rx1155_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__arglist"  :nsentry("!PREFIX__arglist") :subid("230_1303340952.947") :method
.annotate 'line', 10
    $P1157 = self."!PREFIX__!subrule"("ws", "")
    new $P1158, "ResizablePMCArray"
    push $P1158, $P1157
    .return ($P1158)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<value>"  :subid("231_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1162_tgt
    .local int rx1162_pos
    .local int rx1162_off
    .local int rx1162_eos
    .local int rx1162_rep
    .local pmc rx1162_cur
    .local pmc rx1162_debug
    (rx1162_cur, rx1162_pos, rx1162_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1162_cur
    .local pmc match
    .lex "$/", match
    length rx1162_eos, rx1162_tgt
    gt rx1162_pos, rx1162_eos, rx1162_done
    set rx1162_off, 0
    lt rx1162_pos, 2, rx1162_start
    sub rx1162_off, rx1162_pos, 1
    substr rx1162_tgt, rx1162_tgt, rx1162_off
  rx1162_start:
    eq $I10, 1, rx1162_restart
    if_null rx1162_debug, debug_1042
    rx1162_cur."!cursor_debug"("START", "term:sym<value>")
  debug_1042:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1166_done
    goto rxscan1166_scan
  rxscan1166_loop:
    (rx1162_pos) = rx1162_cur."from"()
    inc rx1162_pos
    rx1162_cur."!cursor_from"(rx1162_pos)
    ge rx1162_pos, rx1162_eos, rxscan1166_done
  rxscan1166_scan:
    set_addr $I10, rxscan1166_loop
    rx1162_cur."!mark_push"(0, rx1162_pos, $I10)
  rxscan1166_done:
.annotate 'line', 541
  # rx subrule "value" subtype=capture negate=
    rx1162_cur."!cursor_pos"(rx1162_pos)
    $P10 = rx1162_cur."value"()
    unless $P10, rx1162_fail
    rx1162_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("value")
    rx1162_pos = $P10."pos"()
  # rx pass
    rx1162_cur."!cursor_pass"(rx1162_pos, "term:sym<value>")
    if_null rx1162_debug, debug_1043
    rx1162_cur."!cursor_debug"("PASS", "term:sym<value>", " at pos=", rx1162_pos)
  debug_1043:
    .return (rx1162_cur)
  rx1162_restart:
.annotate 'line', 10
    if_null rx1162_debug, debug_1044
    rx1162_cur."!cursor_debug"("NEXT", "term:sym<value>")
  debug_1044:
  rx1162_fail:
    (rx1162_rep, rx1162_pos, $I10, $P10) = rx1162_cur."!mark_fail"(0)
    lt rx1162_pos, -1, rx1162_done
    eq rx1162_pos, -1, rx1162_fail
    jump $I10
  rx1162_done:
    rx1162_cur."!cursor_fail"()
    if_null rx1162_debug, debug_1045
    rx1162_cur."!cursor_debug"("FAIL", "term:sym<value>")
  debug_1045:
    .return (rx1162_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<value>"  :nsentry("!PREFIX__term:sym<value>") :subid("232_1303340952.947") :method
.annotate 'line', 10
    $P1164 = self."!PREFIX__!subrule"("value", "")
    new $P1165, "ResizablePMCArray"
    push $P1165, $P1164
    .return ($P1165)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "value"  :subid("233_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1168_tgt
    .local int rx1168_pos
    .local int rx1168_off
    .local int rx1168_eos
    .local int rx1168_rep
    .local pmc rx1168_cur
    .local pmc rx1168_debug
    (rx1168_cur, rx1168_pos, rx1168_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1168_cur
    .local pmc match
    .lex "$/", match
    length rx1168_eos, rx1168_tgt
    gt rx1168_pos, rx1168_eos, rx1168_done
    set rx1168_off, 0
    lt rx1168_pos, 2, rx1168_start
    sub rx1168_off, rx1168_pos, 1
    substr rx1168_tgt, rx1168_tgt, rx1168_off
  rx1168_start:
    eq $I10, 1, rx1168_restart
    if_null rx1168_debug, debug_1046
    rx1168_cur."!cursor_debug"("START", "value")
  debug_1046:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1173_done
    goto rxscan1173_scan
  rxscan1173_loop:
    (rx1168_pos) = rx1168_cur."from"()
    inc rx1168_pos
    rx1168_cur."!cursor_from"(rx1168_pos)
    ge rx1168_pos, rx1168_eos, rxscan1173_done
  rxscan1173_scan:
    set_addr $I10, rxscan1173_loop
    rx1168_cur."!mark_push"(0, rx1168_pos, $I10)
  rxscan1173_done:
  alt1174_0:
.annotate 'line', 543
    set_addr $I10, alt1174_1
    rx1168_cur."!mark_push"(0, rx1168_pos, $I10)
.annotate 'line', 544
  # rx subrule "quote" subtype=capture negate=
    rx1168_cur."!cursor_pos"(rx1168_pos)
    $P10 = rx1168_cur."quote"()
    unless $P10, rx1168_fail
    rx1168_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1168_pos = $P10."pos"()
    goto alt1174_end
  alt1174_1:
.annotate 'line', 545
  # rx subrule "number" subtype=capture negate=
    rx1168_cur."!cursor_pos"(rx1168_pos)
    $P10 = rx1168_cur."number"()
    unless $P10, rx1168_fail
    rx1168_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("number")
    rx1168_pos = $P10."pos"()
  alt1174_end:
.annotate 'line', 543
  # rx pass
    rx1168_cur."!cursor_pass"(rx1168_pos, "value")
    if_null rx1168_debug, debug_1047
    rx1168_cur."!cursor_debug"("PASS", "value", " at pos=", rx1168_pos)
  debug_1047:
    .return (rx1168_cur)
  rx1168_restart:
.annotate 'line', 10
    if_null rx1168_debug, debug_1048
    rx1168_cur."!cursor_debug"("NEXT", "value")
  debug_1048:
  rx1168_fail:
    (rx1168_rep, rx1168_pos, $I10, $P10) = rx1168_cur."!mark_fail"(0)
    lt rx1168_pos, -1, rx1168_done
    eq rx1168_pos, -1, rx1168_fail
    jump $I10
  rx1168_done:
    rx1168_cur."!cursor_fail"()
    if_null rx1168_debug, debug_1049
    rx1168_cur."!cursor_debug"("FAIL", "value")
  debug_1049:
    .return (rx1168_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__value"  :nsentry("!PREFIX__value") :subid("234_1303340952.947") :method
.annotate 'line', 10
    $P1170 = self."!PREFIX__!subrule"("number", "")
    $P1171 = self."!PREFIX__!subrule"("quote", "")
    new $P1172, "ResizablePMCArray"
    push $P1172, $P1170
    push $P1172, $P1171
    .return ($P1172)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "number"  :subid("235_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1176_tgt
    .local int rx1176_pos
    .local int rx1176_off
    .local int rx1176_eos
    .local int rx1176_rep
    .local pmc rx1176_cur
    .local pmc rx1176_debug
    (rx1176_cur, rx1176_pos, rx1176_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1176_cur
    .local pmc match
    .lex "$/", match
    length rx1176_eos, rx1176_tgt
    gt rx1176_pos, rx1176_eos, rx1176_done
    set rx1176_off, 0
    lt rx1176_pos, 2, rx1176_start
    sub rx1176_off, rx1176_pos, 1
    substr rx1176_tgt, rx1176_tgt, rx1176_off
  rx1176_start:
    eq $I10, 1, rx1176_restart
    if_null rx1176_debug, debug_1050
    rx1176_cur."!cursor_debug"("START", "number")
  debug_1050:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1179_done
    goto rxscan1179_scan
  rxscan1179_loop:
    (rx1176_pos) = rx1176_cur."from"()
    inc rx1176_pos
    rx1176_cur."!cursor_from"(rx1176_pos)
    ge rx1176_pos, rx1176_eos, rxscan1179_done
  rxscan1179_scan:
    set_addr $I10, rxscan1179_loop
    rx1176_cur."!mark_push"(0, rx1176_pos, $I10)
  rxscan1179_done:
.annotate 'line', 549
  # rx subcapture "sign"
    set_addr $I10, rxcap_1181_fail
    rx1176_cur."!mark_push"(0, rx1176_pos, $I10)
  # rx enumcharlist_q negate=0  r 0..1
    sub $I10, rx1176_pos, rx1176_off
    set rx1176_rep, 0
    sub $I12, rx1176_eos, rx1176_pos
    le $I12, 1, rxenumcharlistq1180_loop
    set $I12, 1
  rxenumcharlistq1180_loop:
    le $I12, 0, rxenumcharlistq1180_done
    substr $S10, rx1176_tgt, $I10, 1
    index $I11, "+-", $S10
    lt $I11, 0, rxenumcharlistq1180_done
    inc rx1176_rep
  rxenumcharlistq1180_done:
    add rx1176_pos, rx1176_pos, rx1176_rep
    set_addr $I10, rxcap_1181_fail
    ($I12, $I11) = rx1176_cur."!mark_peek"($I10)
    rx1176_cur."!cursor_pos"($I11)
    ($P10) = rx1176_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1176_pos, "")
    rx1176_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sign")
    goto rxcap_1181_done
  rxcap_1181_fail:
    goto rx1176_fail
  rxcap_1181_done:
  alt1182_0:
.annotate 'line', 550
    set_addr $I10, alt1182_1
    rx1176_cur."!mark_push"(0, rx1176_pos, $I10)
  # rx subrule "dec_number" subtype=capture negate=
    rx1176_cur."!cursor_pos"(rx1176_pos)
    $P10 = rx1176_cur."dec_number"()
    unless $P10, rx1176_fail
    rx1176_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dec_number")
    rx1176_pos = $P10."pos"()
    goto alt1182_end
  alt1182_1:
  # rx subrule "integer" subtype=capture negate=
    rx1176_cur."!cursor_pos"(rx1176_pos)
    $P10 = rx1176_cur."integer"()
    unless $P10, rx1176_fail
    rx1176_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("integer")
    rx1176_pos = $P10."pos"()
  alt1182_end:
.annotate 'line', 548
  # rx pass
    rx1176_cur."!cursor_pass"(rx1176_pos, "number")
    if_null rx1176_debug, debug_1051
    rx1176_cur."!cursor_debug"("PASS", "number", " at pos=", rx1176_pos)
  debug_1051:
    .return (rx1176_cur)
  rx1176_restart:
.annotate 'line', 10
    if_null rx1176_debug, debug_1052
    rx1176_cur."!cursor_debug"("NEXT", "number")
  debug_1052:
  rx1176_fail:
    (rx1176_rep, rx1176_pos, $I10, $P10) = rx1176_cur."!mark_fail"(0)
    lt rx1176_pos, -1, rx1176_done
    eq rx1176_pos, -1, rx1176_fail
    jump $I10
  rx1176_done:
    rx1176_cur."!cursor_fail"()
    if_null rx1176_debug, debug_1053
    rx1176_cur."!cursor_debug"("FAIL", "number")
  debug_1053:
    .return (rx1176_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__number"  :nsentry("!PREFIX__number") :subid("236_1303340952.947") :method
.annotate 'line', 10
    new $P1178, "ResizablePMCArray"
    push $P1178, ""
    .return ($P1178)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote"  :subid("237_1303340952.947")
    .param pmc param_1184
.annotate 'line', 553
    .lex "self", param_1184
    $P1185 = param_1184."!protoregex"("quote")
    .return ($P1185)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote"  :subid("238_1303340952.947")
    .param pmc param_1187
.annotate 'line', 553
    .lex "self", param_1187
    $P1188 = param_1187."!PREFIX__!protoregex"("quote")
    .return ($P1188)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<apos>"  :subid("239_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1190_tgt
    .local int rx1190_pos
    .local int rx1190_off
    .local int rx1190_eos
    .local int rx1190_rep
    .local pmc rx1190_cur
    .local pmc rx1190_debug
    (rx1190_cur, rx1190_pos, rx1190_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1190_cur
    .local pmc match
    .lex "$/", match
    length rx1190_eos, rx1190_tgt
    gt rx1190_pos, rx1190_eos, rx1190_done
    set rx1190_off, 0
    lt rx1190_pos, 2, rx1190_start
    sub rx1190_off, rx1190_pos, 1
    substr rx1190_tgt, rx1190_tgt, rx1190_off
  rx1190_start:
    eq $I10, 1, rx1190_restart
    if_null rx1190_debug, debug_1054
    rx1190_cur."!cursor_debug"("START", "quote:sym<apos>")
  debug_1054:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1193_done
    goto rxscan1193_scan
  rxscan1193_loop:
    (rx1190_pos) = rx1190_cur."from"()
    inc rx1190_pos
    rx1190_cur."!cursor_from"(rx1190_pos)
    ge rx1190_pos, rx1190_eos, rxscan1193_done
  rxscan1193_scan:
    set_addr $I10, rxscan1193_loop
    rx1190_cur."!mark_push"(0, rx1190_pos, $I10)
  rxscan1193_done:
.annotate 'line', 554
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1190_pos, rx1190_off
    substr $S10, rx1190_tgt, $I10, 1
    index $I11, "'", $S10
    lt $I11, 0, rx1190_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1190_cur."!cursor_pos"(rx1190_pos)
    $P10 = rx1190_cur."quote_EXPR"(":q")
    unless $P10, rx1190_fail
    rx1190_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1190_pos = $P10."pos"()
  # rx pass
    rx1190_cur."!cursor_pass"(rx1190_pos, "quote:sym<apos>")
    if_null rx1190_debug, debug_1055
    rx1190_cur."!cursor_debug"("PASS", "quote:sym<apos>", " at pos=", rx1190_pos)
  debug_1055:
    .return (rx1190_cur)
  rx1190_restart:
.annotate 'line', 10
    if_null rx1190_debug, debug_1056
    rx1190_cur."!cursor_debug"("NEXT", "quote:sym<apos>")
  debug_1056:
  rx1190_fail:
    (rx1190_rep, rx1190_pos, $I10, $P10) = rx1190_cur."!mark_fail"(0)
    lt rx1190_pos, -1, rx1190_done
    eq rx1190_pos, -1, rx1190_fail
    jump $I10
  rx1190_done:
    rx1190_cur."!cursor_fail"()
    if_null rx1190_debug, debug_1057
    rx1190_cur."!cursor_debug"("FAIL", "quote:sym<apos>")
  debug_1057:
    .return (rx1190_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<apos>"  :nsentry("!PREFIX__quote:sym<apos>") :subid("240_1303340952.947") :method
.annotate 'line', 10
    new $P1192, "ResizablePMCArray"
    push $P1192, "'"
    .return ($P1192)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<dblq>"  :subid("241_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1195_tgt
    .local int rx1195_pos
    .local int rx1195_off
    .local int rx1195_eos
    .local int rx1195_rep
    .local pmc rx1195_cur
    .local pmc rx1195_debug
    (rx1195_cur, rx1195_pos, rx1195_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1195_cur
    .local pmc match
    .lex "$/", match
    length rx1195_eos, rx1195_tgt
    gt rx1195_pos, rx1195_eos, rx1195_done
    set rx1195_off, 0
    lt rx1195_pos, 2, rx1195_start
    sub rx1195_off, rx1195_pos, 1
    substr rx1195_tgt, rx1195_tgt, rx1195_off
  rx1195_start:
    eq $I10, 1, rx1195_restart
    if_null rx1195_debug, debug_1058
    rx1195_cur."!cursor_debug"("START", "quote:sym<dblq>")
  debug_1058:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1198_done
    goto rxscan1198_scan
  rxscan1198_loop:
    (rx1195_pos) = rx1195_cur."from"()
    inc rx1195_pos
    rx1195_cur."!cursor_from"(rx1195_pos)
    ge rx1195_pos, rx1195_eos, rxscan1198_done
  rxscan1198_scan:
    set_addr $I10, rxscan1198_loop
    rx1195_cur."!mark_push"(0, rx1195_pos, $I10)
  rxscan1198_done:
.annotate 'line', 555
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1195_pos, rx1195_off
    substr $S10, rx1195_tgt, $I10, 1
    index $I11, "\"", $S10
    lt $I11, 0, rx1195_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1195_cur."!cursor_pos"(rx1195_pos)
    $P10 = rx1195_cur."quote_EXPR"(":qq")
    unless $P10, rx1195_fail
    rx1195_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1195_pos = $P10."pos"()
  # rx pass
    rx1195_cur."!cursor_pass"(rx1195_pos, "quote:sym<dblq>")
    if_null rx1195_debug, debug_1059
    rx1195_cur."!cursor_debug"("PASS", "quote:sym<dblq>", " at pos=", rx1195_pos)
  debug_1059:
    .return (rx1195_cur)
  rx1195_restart:
.annotate 'line', 10
    if_null rx1195_debug, debug_1060
    rx1195_cur."!cursor_debug"("NEXT", "quote:sym<dblq>")
  debug_1060:
  rx1195_fail:
    (rx1195_rep, rx1195_pos, $I10, $P10) = rx1195_cur."!mark_fail"(0)
    lt rx1195_pos, -1, rx1195_done
    eq rx1195_pos, -1, rx1195_fail
    jump $I10
  rx1195_done:
    rx1195_cur."!cursor_fail"()
    if_null rx1195_debug, debug_1061
    rx1195_cur."!cursor_debug"("FAIL", "quote:sym<dblq>")
  debug_1061:
    .return (rx1195_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<dblq>"  :nsentry("!PREFIX__quote:sym<dblq>") :subid("242_1303340952.947") :method
.annotate 'line', 10
    new $P1197, "ResizablePMCArray"
    push $P1197, "\""
    .return ($P1197)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<q>"  :subid("243_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1200_tgt
    .local int rx1200_pos
    .local int rx1200_off
    .local int rx1200_eos
    .local int rx1200_rep
    .local pmc rx1200_cur
    .local pmc rx1200_debug
    (rx1200_cur, rx1200_pos, rx1200_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1200_cur
    .local pmc match
    .lex "$/", match
    length rx1200_eos, rx1200_tgt
    gt rx1200_pos, rx1200_eos, rx1200_done
    set rx1200_off, 0
    lt rx1200_pos, 2, rx1200_start
    sub rx1200_off, rx1200_pos, 1
    substr rx1200_tgt, rx1200_tgt, rx1200_off
  rx1200_start:
    eq $I10, 1, rx1200_restart
    if_null rx1200_debug, debug_1062
    rx1200_cur."!cursor_debug"("START", "quote:sym<q>")
  debug_1062:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1204_done
    goto rxscan1204_scan
  rxscan1204_loop:
    (rx1200_pos) = rx1200_cur."from"()
    inc rx1200_pos
    rx1200_cur."!cursor_from"(rx1200_pos)
    ge rx1200_pos, rx1200_eos, rxscan1204_done
  rxscan1204_scan:
    set_addr $I10, rxscan1204_loop
    rx1200_cur."!mark_push"(0, rx1200_pos, $I10)
  rxscan1204_done:
.annotate 'line', 556
  # rx literal  "q"
    add $I11, rx1200_pos, 1
    gt $I11, rx1200_eos, rx1200_fail
    sub $I11, rx1200_pos, rx1200_off
    ord $I11, rx1200_tgt, $I11
    ne $I11, 113, rx1200_fail
    add rx1200_pos, 1
  # rxanchor rwb
    le rx1200_pos, 0, rx1200_fail
    sub $I10, rx1200_pos, rx1200_off
    is_cclass $I11, 8192, rx1200_tgt, $I10
    if $I11, rx1200_fail
    dec $I10
    is_cclass $I11, 8192, rx1200_tgt, $I10
    unless $I11, rx1200_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1200_pos, rx1200_off
    substr $S10, rx1200_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1200_fail
  # rx subrule "ws" subtype=method negate=
    rx1200_cur."!cursor_pos"(rx1200_pos)
    $P10 = rx1200_cur."ws"()
    unless $P10, rx1200_fail
    rx1200_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1200_cur."!cursor_pos"(rx1200_pos)
    $P10 = rx1200_cur."quote_EXPR"(":q")
    unless $P10, rx1200_fail
    rx1200_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1200_pos = $P10."pos"()
  # rx pass
    rx1200_cur."!cursor_pass"(rx1200_pos, "quote:sym<q>")
    if_null rx1200_debug, debug_1063
    rx1200_cur."!cursor_debug"("PASS", "quote:sym<q>", " at pos=", rx1200_pos)
  debug_1063:
    .return (rx1200_cur)
  rx1200_restart:
.annotate 'line', 10
    if_null rx1200_debug, debug_1064
    rx1200_cur."!cursor_debug"("NEXT", "quote:sym<q>")
  debug_1064:
  rx1200_fail:
    (rx1200_rep, rx1200_pos, $I10, $P10) = rx1200_cur."!mark_fail"(0)
    lt rx1200_pos, -1, rx1200_done
    eq rx1200_pos, -1, rx1200_fail
    jump $I10
  rx1200_done:
    rx1200_cur."!cursor_fail"()
    if_null rx1200_debug, debug_1065
    rx1200_cur."!cursor_debug"("FAIL", "quote:sym<q>")
  debug_1065:
    .return (rx1200_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<q>"  :nsentry("!PREFIX__quote:sym<q>") :subid("244_1303340952.947") :method
.annotate 'line', 10
    $P1202 = self."!PREFIX__!subrule"("ws", "q")
    new $P1203, "ResizablePMCArray"
    push $P1203, $P1202
    .return ($P1203)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<qq>"  :subid("245_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1206_tgt
    .local int rx1206_pos
    .local int rx1206_off
    .local int rx1206_eos
    .local int rx1206_rep
    .local pmc rx1206_cur
    .local pmc rx1206_debug
    (rx1206_cur, rx1206_pos, rx1206_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1206_cur
    .local pmc match
    .lex "$/", match
    length rx1206_eos, rx1206_tgt
    gt rx1206_pos, rx1206_eos, rx1206_done
    set rx1206_off, 0
    lt rx1206_pos, 2, rx1206_start
    sub rx1206_off, rx1206_pos, 1
    substr rx1206_tgt, rx1206_tgt, rx1206_off
  rx1206_start:
    eq $I10, 1, rx1206_restart
    if_null rx1206_debug, debug_1066
    rx1206_cur."!cursor_debug"("START", "quote:sym<qq>")
  debug_1066:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1210_done
    goto rxscan1210_scan
  rxscan1210_loop:
    (rx1206_pos) = rx1206_cur."from"()
    inc rx1206_pos
    rx1206_cur."!cursor_from"(rx1206_pos)
    ge rx1206_pos, rx1206_eos, rxscan1210_done
  rxscan1210_scan:
    set_addr $I10, rxscan1210_loop
    rx1206_cur."!mark_push"(0, rx1206_pos, $I10)
  rxscan1210_done:
.annotate 'line', 557
  # rx literal  "qq"
    add $I11, rx1206_pos, 2
    gt $I11, rx1206_eos, rx1206_fail
    sub $I11, rx1206_pos, rx1206_off
    substr $S10, rx1206_tgt, $I11, 2
    ne $S10, "qq", rx1206_fail
    add rx1206_pos, 2
  # rxanchor rwb
    le rx1206_pos, 0, rx1206_fail
    sub $I10, rx1206_pos, rx1206_off
    is_cclass $I11, 8192, rx1206_tgt, $I10
    if $I11, rx1206_fail
    dec $I10
    is_cclass $I11, 8192, rx1206_tgt, $I10
    unless $I11, rx1206_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1206_pos, rx1206_off
    substr $S10, rx1206_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1206_fail
  # rx subrule "ws" subtype=method negate=
    rx1206_cur."!cursor_pos"(rx1206_pos)
    $P10 = rx1206_cur."ws"()
    unless $P10, rx1206_fail
    rx1206_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1206_cur."!cursor_pos"(rx1206_pos)
    $P10 = rx1206_cur."quote_EXPR"(":qq")
    unless $P10, rx1206_fail
    rx1206_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1206_pos = $P10."pos"()
  # rx pass
    rx1206_cur."!cursor_pass"(rx1206_pos, "quote:sym<qq>")
    if_null rx1206_debug, debug_1067
    rx1206_cur."!cursor_debug"("PASS", "quote:sym<qq>", " at pos=", rx1206_pos)
  debug_1067:
    .return (rx1206_cur)
  rx1206_restart:
.annotate 'line', 10
    if_null rx1206_debug, debug_1068
    rx1206_cur."!cursor_debug"("NEXT", "quote:sym<qq>")
  debug_1068:
  rx1206_fail:
    (rx1206_rep, rx1206_pos, $I10, $P10) = rx1206_cur."!mark_fail"(0)
    lt rx1206_pos, -1, rx1206_done
    eq rx1206_pos, -1, rx1206_fail
    jump $I10
  rx1206_done:
    rx1206_cur."!cursor_fail"()
    if_null rx1206_debug, debug_1069
    rx1206_cur."!cursor_debug"("FAIL", "quote:sym<qq>")
  debug_1069:
    .return (rx1206_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<qq>"  :nsentry("!PREFIX__quote:sym<qq>") :subid("246_1303340952.947") :method
.annotate 'line', 10
    $P1208 = self."!PREFIX__!subrule"("ws", "qq")
    new $P1209, "ResizablePMCArray"
    push $P1209, $P1208
    .return ($P1209)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q>"  :subid("247_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1212_tgt
    .local int rx1212_pos
    .local int rx1212_off
    .local int rx1212_eos
    .local int rx1212_rep
    .local pmc rx1212_cur
    .local pmc rx1212_debug
    (rx1212_cur, rx1212_pos, rx1212_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1212_cur
    .local pmc match
    .lex "$/", match
    length rx1212_eos, rx1212_tgt
    gt rx1212_pos, rx1212_eos, rx1212_done
    set rx1212_off, 0
    lt rx1212_pos, 2, rx1212_start
    sub rx1212_off, rx1212_pos, 1
    substr rx1212_tgt, rx1212_tgt, rx1212_off
  rx1212_start:
    eq $I10, 1, rx1212_restart
    if_null rx1212_debug, debug_1070
    rx1212_cur."!cursor_debug"("START", "quote:sym<Q>")
  debug_1070:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1216_done
    goto rxscan1216_scan
  rxscan1216_loop:
    (rx1212_pos) = rx1212_cur."from"()
    inc rx1212_pos
    rx1212_cur."!cursor_from"(rx1212_pos)
    ge rx1212_pos, rx1212_eos, rxscan1216_done
  rxscan1216_scan:
    set_addr $I10, rxscan1216_loop
    rx1212_cur."!mark_push"(0, rx1212_pos, $I10)
  rxscan1216_done:
.annotate 'line', 558
  # rx literal  "Q"
    add $I11, rx1212_pos, 1
    gt $I11, rx1212_eos, rx1212_fail
    sub $I11, rx1212_pos, rx1212_off
    ord $I11, rx1212_tgt, $I11
    ne $I11, 81, rx1212_fail
    add rx1212_pos, 1
  # rxanchor rwb
    le rx1212_pos, 0, rx1212_fail
    sub $I10, rx1212_pos, rx1212_off
    is_cclass $I11, 8192, rx1212_tgt, $I10
    if $I11, rx1212_fail
    dec $I10
    is_cclass $I11, 8192, rx1212_tgt, $I10
    unless $I11, rx1212_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1212_pos, rx1212_off
    substr $S10, rx1212_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1212_fail
  # rx subrule "ws" subtype=method negate=
    rx1212_cur."!cursor_pos"(rx1212_pos)
    $P10 = rx1212_cur."ws"()
    unless $P10, rx1212_fail
    rx1212_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1212_cur."!cursor_pos"(rx1212_pos)
    $P10 = rx1212_cur."quote_EXPR"()
    unless $P10, rx1212_fail
    rx1212_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1212_pos = $P10."pos"()
  # rx pass
    rx1212_cur."!cursor_pass"(rx1212_pos, "quote:sym<Q>")
    if_null rx1212_debug, debug_1071
    rx1212_cur."!cursor_debug"("PASS", "quote:sym<Q>", " at pos=", rx1212_pos)
  debug_1071:
    .return (rx1212_cur)
  rx1212_restart:
.annotate 'line', 10
    if_null rx1212_debug, debug_1072
    rx1212_cur."!cursor_debug"("NEXT", "quote:sym<Q>")
  debug_1072:
  rx1212_fail:
    (rx1212_rep, rx1212_pos, $I10, $P10) = rx1212_cur."!mark_fail"(0)
    lt rx1212_pos, -1, rx1212_done
    eq rx1212_pos, -1, rx1212_fail
    jump $I10
  rx1212_done:
    rx1212_cur."!cursor_fail"()
    if_null rx1212_debug, debug_1073
    rx1212_cur."!cursor_debug"("FAIL", "quote:sym<Q>")
  debug_1073:
    .return (rx1212_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q>"  :nsentry("!PREFIX__quote:sym<Q>") :subid("248_1303340952.947") :method
.annotate 'line', 10
    $P1214 = self."!PREFIX__!subrule"("ws", "Q")
    new $P1215, "ResizablePMCArray"
    push $P1215, $P1214
    .return ($P1215)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q:PIR>"  :subid("249_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1218_tgt
    .local int rx1218_pos
    .local int rx1218_off
    .local int rx1218_eos
    .local int rx1218_rep
    .local pmc rx1218_cur
    .local pmc rx1218_debug
    (rx1218_cur, rx1218_pos, rx1218_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1218_cur
    .local pmc match
    .lex "$/", match
    length rx1218_eos, rx1218_tgt
    gt rx1218_pos, rx1218_eos, rx1218_done
    set rx1218_off, 0
    lt rx1218_pos, 2, rx1218_start
    sub rx1218_off, rx1218_pos, 1
    substr rx1218_tgt, rx1218_tgt, rx1218_off
  rx1218_start:
    eq $I10, 1, rx1218_restart
    if_null rx1218_debug, debug_1074
    rx1218_cur."!cursor_debug"("START", "quote:sym<Q:PIR>")
  debug_1074:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1222_done
    goto rxscan1222_scan
  rxscan1222_loop:
    (rx1218_pos) = rx1218_cur."from"()
    inc rx1218_pos
    rx1218_cur."!cursor_from"(rx1218_pos)
    ge rx1218_pos, rx1218_eos, rxscan1222_done
  rxscan1222_scan:
    set_addr $I10, rxscan1222_loop
    rx1218_cur."!mark_push"(0, rx1218_pos, $I10)
  rxscan1222_done:
.annotate 'line', 559
  # rx literal  "Q:PIR"
    add $I11, rx1218_pos, 5
    gt $I11, rx1218_eos, rx1218_fail
    sub $I11, rx1218_pos, rx1218_off
    substr $S10, rx1218_tgt, $I11, 5
    ne $S10, "Q:PIR", rx1218_fail
    add rx1218_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx1218_cur."!cursor_pos"(rx1218_pos)
    $P10 = rx1218_cur."ws"()
    unless $P10, rx1218_fail
    rx1218_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1218_cur."!cursor_pos"(rx1218_pos)
    $P10 = rx1218_cur."quote_EXPR"()
    unless $P10, rx1218_fail
    rx1218_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1218_pos = $P10."pos"()
  # rx pass
    rx1218_cur."!cursor_pass"(rx1218_pos, "quote:sym<Q:PIR>")
    if_null rx1218_debug, debug_1075
    rx1218_cur."!cursor_debug"("PASS", "quote:sym<Q:PIR>", " at pos=", rx1218_pos)
  debug_1075:
    .return (rx1218_cur)
  rx1218_restart:
.annotate 'line', 10
    if_null rx1218_debug, debug_1076
    rx1218_cur."!cursor_debug"("NEXT", "quote:sym<Q:PIR>")
  debug_1076:
  rx1218_fail:
    (rx1218_rep, rx1218_pos, $I10, $P10) = rx1218_cur."!mark_fail"(0)
    lt rx1218_pos, -1, rx1218_done
    eq rx1218_pos, -1, rx1218_fail
    jump $I10
  rx1218_done:
    rx1218_cur."!cursor_fail"()
    if_null rx1218_debug, debug_1077
    rx1218_cur."!cursor_debug"("FAIL", "quote:sym<Q:PIR>")
  debug_1077:
    .return (rx1218_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q:PIR>"  :nsentry("!PREFIX__quote:sym<Q:PIR>") :subid("250_1303340952.947") :method
.annotate 'line', 10
    $P1220 = self."!PREFIX__!subrule"("ws", "Q:PIR")
    new $P1221, "ResizablePMCArray"
    push $P1221, $P1220
    .return ($P1221)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym</ />"  :subid("251_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1224_tgt
    .local int rx1224_pos
    .local int rx1224_off
    .local int rx1224_eos
    .local int rx1224_rep
    .local pmc rx1224_cur
    .local pmc rx1224_debug
    (rx1224_cur, rx1224_pos, rx1224_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1224_cur
    .local pmc match
    .lex "$/", match
    length rx1224_eos, rx1224_tgt
    gt rx1224_pos, rx1224_eos, rx1224_done
    set rx1224_off, 0
    lt rx1224_pos, 2, rx1224_start
    sub rx1224_off, rx1224_pos, 1
    substr rx1224_tgt, rx1224_tgt, rx1224_off
  rx1224_start:
    eq $I10, 1, rx1224_restart
    if_null rx1224_debug, debug_1078
    rx1224_cur."!cursor_debug"("START", "quote:sym</ />")
  debug_1078:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1228_done
    goto rxscan1228_scan
  rxscan1228_loop:
    (rx1224_pos) = rx1224_cur."from"()
    inc rx1224_pos
    rx1224_cur."!cursor_from"(rx1224_pos)
    ge rx1224_pos, rx1224_eos, rxscan1228_done
  rxscan1228_scan:
    set_addr $I10, rxscan1228_loop
    rx1224_cur."!mark_push"(0, rx1224_pos, $I10)
  rxscan1228_done:
.annotate 'line', 561
  # rx literal  "/"
    add $I11, rx1224_pos, 1
    gt $I11, rx1224_eos, rx1224_fail
    sub $I11, rx1224_pos, rx1224_off
    ord $I11, rx1224_tgt, $I11
    ne $I11, 47, rx1224_fail
    add rx1224_pos, 1
.annotate 'line', 562
  # rx subrule "newpad" subtype=method negate=
    rx1224_cur."!cursor_pos"(rx1224_pos)
    $P10 = rx1224_cur."newpad"()
    unless $P10, rx1224_fail
    rx1224_pos = $P10."pos"()
.annotate 'line', 563
  # rx reduce name="quote:sym</ />" key="open"
    rx1224_cur."!cursor_pos"(rx1224_pos)
    rx1224_cur."!reduce"("quote:sym</ />", "open")
.annotate 'line', 564
  # rx subrule "LANG" subtype=capture negate=
    rx1224_cur."!cursor_pos"(rx1224_pos)
    $P10 = rx1224_cur."LANG"("Regex", "nibbler")
    unless $P10, rx1224_fail
    rx1224_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx1224_pos = $P10."pos"()
.annotate 'line', 565
  # rx literal  "/"
    add $I11, rx1224_pos, 1
    gt $I11, rx1224_eos, rx1224_fail
    sub $I11, rx1224_pos, rx1224_off
    ord $I11, rx1224_tgt, $I11
    ne $I11, 47, rx1224_fail
    add rx1224_pos, 1
.annotate 'line', 560
  # rx pass
    rx1224_cur."!cursor_pass"(rx1224_pos, "quote:sym</ />")
    if_null rx1224_debug, debug_1079
    rx1224_cur."!cursor_debug"("PASS", "quote:sym</ />", " at pos=", rx1224_pos)
  debug_1079:
    .return (rx1224_cur)
  rx1224_restart:
.annotate 'line', 10
    if_null rx1224_debug, debug_1080
    rx1224_cur."!cursor_debug"("NEXT", "quote:sym</ />")
  debug_1080:
  rx1224_fail:
    (rx1224_rep, rx1224_pos, $I10, $P10) = rx1224_cur."!mark_fail"(0)
    lt rx1224_pos, -1, rx1224_done
    eq rx1224_pos, -1, rx1224_fail
    jump $I10
  rx1224_done:
    rx1224_cur."!cursor_fail"()
    if_null rx1224_debug, debug_1081
    rx1224_cur."!cursor_debug"("FAIL", "quote:sym</ />")
  debug_1081:
    .return (rx1224_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym</ />"  :nsentry("!PREFIX__quote:sym</ />") :subid("252_1303340952.947") :method
.annotate 'line', 10
    $P1226 = self."!PREFIX__!subrule"("newpad", "/")
    new $P1227, "ResizablePMCArray"
    push $P1227, $P1226
    .return ($P1227)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<$>"  :subid("253_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1230_tgt
    .local int rx1230_pos
    .local int rx1230_off
    .local int rx1230_eos
    .local int rx1230_rep
    .local pmc rx1230_cur
    .local pmc rx1230_debug
    (rx1230_cur, rx1230_pos, rx1230_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1230_cur
    .local pmc match
    .lex "$/", match
    length rx1230_eos, rx1230_tgt
    gt rx1230_pos, rx1230_eos, rx1230_done
    set rx1230_off, 0
    lt rx1230_pos, 2, rx1230_start
    sub rx1230_off, rx1230_pos, 1
    substr rx1230_tgt, rx1230_tgt, rx1230_off
  rx1230_start:
    eq $I10, 1, rx1230_restart
    if_null rx1230_debug, debug_1082
    rx1230_cur."!cursor_debug"("START", "quote_escape:sym<$>")
  debug_1082:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1233_done
    goto rxscan1233_scan
  rxscan1233_loop:
    (rx1230_pos) = rx1230_cur."from"()
    inc rx1230_pos
    rx1230_cur."!cursor_from"(rx1230_pos)
    ge rx1230_pos, rx1230_eos, rxscan1233_done
  rxscan1233_scan:
    set_addr $I10, rxscan1233_loop
    rx1230_cur."!mark_push"(0, rx1230_pos, $I10)
  rxscan1233_done:
.annotate 'line', 568
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1230_pos, rx1230_off
    substr $S10, rx1230_tgt, $I10, 1
    index $I11, "$", $S10
    lt $I11, 0, rx1230_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1230_cur."!cursor_pos"(rx1230_pos)
    $P10 = rx1230_cur."quotemod_check"("s")
    unless $P10, rx1230_fail
  # rx subrule "variable" subtype=capture negate=
    rx1230_cur."!cursor_pos"(rx1230_pos)
    $P10 = rx1230_cur."variable"()
    unless $P10, rx1230_fail
    rx1230_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx1230_pos = $P10."pos"()
  # rx pass
    rx1230_cur."!cursor_pass"(rx1230_pos, "quote_escape:sym<$>")
    if_null rx1230_debug, debug_1083
    rx1230_cur."!cursor_debug"("PASS", "quote_escape:sym<$>", " at pos=", rx1230_pos)
  debug_1083:
    .return (rx1230_cur)
  rx1230_restart:
.annotate 'line', 10
    if_null rx1230_debug, debug_1084
    rx1230_cur."!cursor_debug"("NEXT", "quote_escape:sym<$>")
  debug_1084:
  rx1230_fail:
    (rx1230_rep, rx1230_pos, $I10, $P10) = rx1230_cur."!mark_fail"(0)
    lt rx1230_pos, -1, rx1230_done
    eq rx1230_pos, -1, rx1230_fail
    jump $I10
  rx1230_done:
    rx1230_cur."!cursor_fail"()
    if_null rx1230_debug, debug_1085
    rx1230_cur."!cursor_debug"("FAIL", "quote_escape:sym<$>")
  debug_1085:
    .return (rx1230_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<$>"  :nsentry("!PREFIX__quote_escape:sym<$>") :subid("254_1303340952.947") :method
.annotate 'line', 10
    new $P1232, "ResizablePMCArray"
    push $P1232, "$"
    .return ($P1232)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<{ }>"  :subid("255_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1235_tgt
    .local int rx1235_pos
    .local int rx1235_off
    .local int rx1235_eos
    .local int rx1235_rep
    .local pmc rx1235_cur
    .local pmc rx1235_debug
    (rx1235_cur, rx1235_pos, rx1235_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1235_cur
    .local pmc match
    .lex "$/", match
    length rx1235_eos, rx1235_tgt
    gt rx1235_pos, rx1235_eos, rx1235_done
    set rx1235_off, 0
    lt rx1235_pos, 2, rx1235_start
    sub rx1235_off, rx1235_pos, 1
    substr rx1235_tgt, rx1235_tgt, rx1235_off
  rx1235_start:
    eq $I10, 1, rx1235_restart
    if_null rx1235_debug, debug_1086
    rx1235_cur."!cursor_debug"("START", "quote_escape:sym<{ }>")
  debug_1086:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1238_done
    goto rxscan1238_scan
  rxscan1238_loop:
    (rx1235_pos) = rx1235_cur."from"()
    inc rx1235_pos
    rx1235_cur."!cursor_from"(rx1235_pos)
    ge rx1235_pos, rx1235_eos, rxscan1238_done
  rxscan1238_scan:
    set_addr $I10, rxscan1238_loop
    rx1235_cur."!mark_push"(0, rx1235_pos, $I10)
  rxscan1238_done:
.annotate 'line', 569
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1235_pos, rx1235_off
    substr $S10, rx1235_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1235_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1235_cur."!cursor_pos"(rx1235_pos)
    $P10 = rx1235_cur."quotemod_check"("c")
    unless $P10, rx1235_fail
  # rx subrule "block" subtype=capture negate=
    rx1235_cur."!cursor_pos"(rx1235_pos)
    $P10 = rx1235_cur."block"()
    unless $P10, rx1235_fail
    rx1235_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1235_pos = $P10."pos"()
  # rx pass
    rx1235_cur."!cursor_pass"(rx1235_pos, "quote_escape:sym<{ }>")
    if_null rx1235_debug, debug_1087
    rx1235_cur."!cursor_debug"("PASS", "quote_escape:sym<{ }>", " at pos=", rx1235_pos)
  debug_1087:
    .return (rx1235_cur)
  rx1235_restart:
.annotate 'line', 10
    if_null rx1235_debug, debug_1088
    rx1235_cur."!cursor_debug"("NEXT", "quote_escape:sym<{ }>")
  debug_1088:
  rx1235_fail:
    (rx1235_rep, rx1235_pos, $I10, $P10) = rx1235_cur."!mark_fail"(0)
    lt rx1235_pos, -1, rx1235_done
    eq rx1235_pos, -1, rx1235_fail
    jump $I10
  rx1235_done:
    rx1235_cur."!cursor_fail"()
    if_null rx1235_debug, debug_1089
    rx1235_cur."!cursor_debug"("FAIL", "quote_escape:sym<{ }>")
  debug_1089:
    .return (rx1235_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<{ }>"  :nsentry("!PREFIX__quote_escape:sym<{ }>") :subid("256_1303340952.947") :method
.annotate 'line', 10
    new $P1237, "ResizablePMCArray"
    push $P1237, "{"
    .return ($P1237)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<esc>"  :subid("257_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1240_tgt
    .local int rx1240_pos
    .local int rx1240_off
    .local int rx1240_eos
    .local int rx1240_rep
    .local pmc rx1240_cur
    .local pmc rx1240_debug
    (rx1240_cur, rx1240_pos, rx1240_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1240_cur
    .local pmc match
    .lex "$/", match
    length rx1240_eos, rx1240_tgt
    gt rx1240_pos, rx1240_eos, rx1240_done
    set rx1240_off, 0
    lt rx1240_pos, 2, rx1240_start
    sub rx1240_off, rx1240_pos, 1
    substr rx1240_tgt, rx1240_tgt, rx1240_off
  rx1240_start:
    eq $I10, 1, rx1240_restart
    if_null rx1240_debug, debug_1090
    rx1240_cur."!cursor_debug"("START", "quote_escape:sym<esc>")
  debug_1090:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1243_done
    goto rxscan1243_scan
  rxscan1243_loop:
    (rx1240_pos) = rx1240_cur."from"()
    inc rx1240_pos
    rx1240_cur."!cursor_from"(rx1240_pos)
    ge rx1240_pos, rx1240_eos, rxscan1243_done
  rxscan1243_scan:
    set_addr $I10, rxscan1243_loop
    rx1240_cur."!mark_push"(0, rx1240_pos, $I10)
  rxscan1243_done:
.annotate 'line', 570
  # rx literal  "\\e"
    add $I11, rx1240_pos, 2
    gt $I11, rx1240_eos, rx1240_fail
    sub $I11, rx1240_pos, rx1240_off
    substr $S10, rx1240_tgt, $I11, 2
    ne $S10, "\\e", rx1240_fail
    add rx1240_pos, 2
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1240_cur."!cursor_pos"(rx1240_pos)
    $P10 = rx1240_cur."quotemod_check"("b")
    unless $P10, rx1240_fail
  # rx pass
    rx1240_cur."!cursor_pass"(rx1240_pos, "quote_escape:sym<esc>")
    if_null rx1240_debug, debug_1091
    rx1240_cur."!cursor_debug"("PASS", "quote_escape:sym<esc>", " at pos=", rx1240_pos)
  debug_1091:
    .return (rx1240_cur)
  rx1240_restart:
.annotate 'line', 10
    if_null rx1240_debug, debug_1092
    rx1240_cur."!cursor_debug"("NEXT", "quote_escape:sym<esc>")
  debug_1092:
  rx1240_fail:
    (rx1240_rep, rx1240_pos, $I10, $P10) = rx1240_cur."!mark_fail"(0)
    lt rx1240_pos, -1, rx1240_done
    eq rx1240_pos, -1, rx1240_fail
    jump $I10
  rx1240_done:
    rx1240_cur."!cursor_fail"()
    if_null rx1240_debug, debug_1093
    rx1240_cur."!cursor_debug"("FAIL", "quote_escape:sym<esc>")
  debug_1093:
    .return (rx1240_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<esc>"  :nsentry("!PREFIX__quote_escape:sym<esc>") :subid("258_1303340952.947") :method
.annotate 'line', 10
    new $P1242, "ResizablePMCArray"
    push $P1242, "\\e"
    .return ($P1242)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<( )>"  :subid("259_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1245_tgt
    .local int rx1245_pos
    .local int rx1245_off
    .local int rx1245_eos
    .local int rx1245_rep
    .local pmc rx1245_cur
    .local pmc rx1245_debug
    (rx1245_cur, rx1245_pos, rx1245_tgt, $I10) = self."!cursor_start"()
    rx1245_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx1245_cur
    .local pmc match
    .lex "$/", match
    length rx1245_eos, rx1245_tgt
    gt rx1245_pos, rx1245_eos, rx1245_done
    set rx1245_off, 0
    lt rx1245_pos, 2, rx1245_start
    sub rx1245_off, rx1245_pos, 1
    substr rx1245_tgt, rx1245_tgt, rx1245_off
  rx1245_start:
    eq $I10, 1, rx1245_restart
    if_null rx1245_debug, debug_1094
    rx1245_cur."!cursor_debug"("START", "circumfix:sym<( )>")
  debug_1094:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1249_done
    goto rxscan1249_scan
  rxscan1249_loop:
    (rx1245_pos) = rx1245_cur."from"()
    inc rx1245_pos
    rx1245_cur."!cursor_from"(rx1245_pos)
    ge rx1245_pos, rx1245_eos, rxscan1249_done
  rxscan1249_scan:
    set_addr $I10, rxscan1249_loop
    rx1245_cur."!mark_push"(0, rx1245_pos, $I10)
  rxscan1249_done:
.annotate 'line', 572
  # rx literal  "("
    add $I11, rx1245_pos, 1
    gt $I11, rx1245_eos, rx1245_fail
    sub $I11, rx1245_pos, rx1245_off
    ord $I11, rx1245_tgt, $I11
    ne $I11, 40, rx1245_fail
    add rx1245_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1245_cur."!cursor_pos"(rx1245_pos)
    $P10 = rx1245_cur."ws"()
    unless $P10, rx1245_fail
    rx1245_pos = $P10."pos"()
  # rx rxquantr1250 ** 0..1
    set_addr $I10, rxquantr1250_done
    rx1245_cur."!mark_push"(0, rx1245_pos, $I10)
  rxquantr1250_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx1245_cur."!cursor_pos"(rx1245_pos)
    $P10 = rx1245_cur."EXPR"()
    unless $P10, rx1245_fail
    goto rxsubrule1251_pass
  rxsubrule1251_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1245_fail
  rxsubrule1251_pass:
    set_addr $I10, rxsubrule1251_back
    rx1245_cur."!mark_push"(0, rx1245_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx1245_pos = $P10."pos"()
    set_addr $I10, rxquantr1250_done
    (rx1245_rep) = rx1245_cur."!mark_commit"($I10)
  rxquantr1250_done:
  # rx literal  ")"
    add $I11, rx1245_pos, 1
    gt $I11, rx1245_eos, rx1245_fail
    sub $I11, rx1245_pos, rx1245_off
    ord $I11, rx1245_tgt, $I11
    ne $I11, 41, rx1245_fail
    add rx1245_pos, 1
  # rx pass
    rx1245_cur."!cursor_pass"(rx1245_pos, "circumfix:sym<( )>")
    if_null rx1245_debug, debug_1095
    rx1245_cur."!cursor_debug"("PASS", "circumfix:sym<( )>", " at pos=", rx1245_pos)
  debug_1095:
    .return (rx1245_cur)
  rx1245_restart:
.annotate 'line', 10
    if_null rx1245_debug, debug_1096
    rx1245_cur."!cursor_debug"("NEXT", "circumfix:sym<( )>")
  debug_1096:
  rx1245_fail:
    (rx1245_rep, rx1245_pos, $I10, $P10) = rx1245_cur."!mark_fail"(0)
    lt rx1245_pos, -1, rx1245_done
    eq rx1245_pos, -1, rx1245_fail
    jump $I10
  rx1245_done:
    rx1245_cur."!cursor_fail"()
    if_null rx1245_debug, debug_1097
    rx1245_cur."!cursor_debug"("FAIL", "circumfix:sym<( )>")
  debug_1097:
    .return (rx1245_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<( )>"  :nsentry("!PREFIX__circumfix:sym<( )>") :subid("260_1303340952.947") :method
.annotate 'line', 10
    $P1247 = self."!PREFIX__!subrule"("ws", "(")
    new $P1248, "ResizablePMCArray"
    push $P1248, $P1247
    .return ($P1248)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<[ ]>"  :subid("261_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1253_tgt
    .local int rx1253_pos
    .local int rx1253_off
    .local int rx1253_eos
    .local int rx1253_rep
    .local pmc rx1253_cur
    .local pmc rx1253_debug
    (rx1253_cur, rx1253_pos, rx1253_tgt, $I10) = self."!cursor_start"()
    rx1253_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx1253_cur
    .local pmc match
    .lex "$/", match
    length rx1253_eos, rx1253_tgt
    gt rx1253_pos, rx1253_eos, rx1253_done
    set rx1253_off, 0
    lt rx1253_pos, 2, rx1253_start
    sub rx1253_off, rx1253_pos, 1
    substr rx1253_tgt, rx1253_tgt, rx1253_off
  rx1253_start:
    eq $I10, 1, rx1253_restart
    if_null rx1253_debug, debug_1098
    rx1253_cur."!cursor_debug"("START", "circumfix:sym<[ ]>")
  debug_1098:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1257_done
    goto rxscan1257_scan
  rxscan1257_loop:
    (rx1253_pos) = rx1253_cur."from"()
    inc rx1253_pos
    rx1253_cur."!cursor_from"(rx1253_pos)
    ge rx1253_pos, rx1253_eos, rxscan1257_done
  rxscan1257_scan:
    set_addr $I10, rxscan1257_loop
    rx1253_cur."!mark_push"(0, rx1253_pos, $I10)
  rxscan1257_done:
.annotate 'line', 573
  # rx literal  "["
    add $I11, rx1253_pos, 1
    gt $I11, rx1253_eos, rx1253_fail
    sub $I11, rx1253_pos, rx1253_off
    ord $I11, rx1253_tgt, $I11
    ne $I11, 91, rx1253_fail
    add rx1253_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1253_cur."!cursor_pos"(rx1253_pos)
    $P10 = rx1253_cur."ws"()
    unless $P10, rx1253_fail
    rx1253_pos = $P10."pos"()
  # rx rxquantr1258 ** 0..1
    set_addr $I10, rxquantr1258_done
    rx1253_cur."!mark_push"(0, rx1253_pos, $I10)
  rxquantr1258_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx1253_cur."!cursor_pos"(rx1253_pos)
    $P10 = rx1253_cur."EXPR"()
    unless $P10, rx1253_fail
    goto rxsubrule1259_pass
  rxsubrule1259_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1253_fail
  rxsubrule1259_pass:
    set_addr $I10, rxsubrule1259_back
    rx1253_cur."!mark_push"(0, rx1253_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx1253_pos = $P10."pos"()
    set_addr $I10, rxquantr1258_done
    (rx1253_rep) = rx1253_cur."!mark_commit"($I10)
  rxquantr1258_done:
  # rx literal  "]"
    add $I11, rx1253_pos, 1
    gt $I11, rx1253_eos, rx1253_fail
    sub $I11, rx1253_pos, rx1253_off
    ord $I11, rx1253_tgt, $I11
    ne $I11, 93, rx1253_fail
    add rx1253_pos, 1
  # rx pass
    rx1253_cur."!cursor_pass"(rx1253_pos, "circumfix:sym<[ ]>")
    if_null rx1253_debug, debug_1099
    rx1253_cur."!cursor_debug"("PASS", "circumfix:sym<[ ]>", " at pos=", rx1253_pos)
  debug_1099:
    .return (rx1253_cur)
  rx1253_restart:
.annotate 'line', 10
    if_null rx1253_debug, debug_1100
    rx1253_cur."!cursor_debug"("NEXT", "circumfix:sym<[ ]>")
  debug_1100:
  rx1253_fail:
    (rx1253_rep, rx1253_pos, $I10, $P10) = rx1253_cur."!mark_fail"(0)
    lt rx1253_pos, -1, rx1253_done
    eq rx1253_pos, -1, rx1253_fail
    jump $I10
  rx1253_done:
    rx1253_cur."!cursor_fail"()
    if_null rx1253_debug, debug_1101
    rx1253_cur."!cursor_debug"("FAIL", "circumfix:sym<[ ]>")
  debug_1101:
    .return (rx1253_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<[ ]>"  :nsentry("!PREFIX__circumfix:sym<[ ]>") :subid("262_1303340952.947") :method
.annotate 'line', 10
    $P1255 = self."!PREFIX__!subrule"("ws", "[")
    new $P1256, "ResizablePMCArray"
    push $P1256, $P1255
    .return ($P1256)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<ang>"  :subid("263_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1261_tgt
    .local int rx1261_pos
    .local int rx1261_off
    .local int rx1261_eos
    .local int rx1261_rep
    .local pmc rx1261_cur
    .local pmc rx1261_debug
    (rx1261_cur, rx1261_pos, rx1261_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1261_cur
    .local pmc match
    .lex "$/", match
    length rx1261_eos, rx1261_tgt
    gt rx1261_pos, rx1261_eos, rx1261_done
    set rx1261_off, 0
    lt rx1261_pos, 2, rx1261_start
    sub rx1261_off, rx1261_pos, 1
    substr rx1261_tgt, rx1261_tgt, rx1261_off
  rx1261_start:
    eq $I10, 1, rx1261_restart
    if_null rx1261_debug, debug_1102
    rx1261_cur."!cursor_debug"("START", "circumfix:sym<ang>")
  debug_1102:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1264_done
    goto rxscan1264_scan
  rxscan1264_loop:
    (rx1261_pos) = rx1261_cur."from"()
    inc rx1261_pos
    rx1261_cur."!cursor_from"(rx1261_pos)
    ge rx1261_pos, rx1261_eos, rxscan1264_done
  rxscan1264_scan:
    set_addr $I10, rxscan1264_loop
    rx1261_cur."!mark_push"(0, rx1261_pos, $I10)
  rxscan1264_done:
.annotate 'line', 574
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1261_pos, rx1261_off
    substr $S10, rx1261_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx1261_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1261_cur."!cursor_pos"(rx1261_pos)
    $P10 = rx1261_cur."quote_EXPR"(":q", ":w")
    unless $P10, rx1261_fail
    rx1261_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1261_pos = $P10."pos"()
  # rx pass
    rx1261_cur."!cursor_pass"(rx1261_pos, "circumfix:sym<ang>")
    if_null rx1261_debug, debug_1103
    rx1261_cur."!cursor_debug"("PASS", "circumfix:sym<ang>", " at pos=", rx1261_pos)
  debug_1103:
    .return (rx1261_cur)
  rx1261_restart:
.annotate 'line', 10
    if_null rx1261_debug, debug_1104
    rx1261_cur."!cursor_debug"("NEXT", "circumfix:sym<ang>")
  debug_1104:
  rx1261_fail:
    (rx1261_rep, rx1261_pos, $I10, $P10) = rx1261_cur."!mark_fail"(0)
    lt rx1261_pos, -1, rx1261_done
    eq rx1261_pos, -1, rx1261_fail
    jump $I10
  rx1261_done:
    rx1261_cur."!cursor_fail"()
    if_null rx1261_debug, debug_1105
    rx1261_cur."!cursor_debug"("FAIL", "circumfix:sym<ang>")
  debug_1105:
    .return (rx1261_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<ang>"  :nsentry("!PREFIX__circumfix:sym<ang>") :subid("264_1303340952.947") :method
.annotate 'line', 10
    new $P1263, "ResizablePMCArray"
    push $P1263, "<"
    .return ($P1263)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("265_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1266_tgt
    .local int rx1266_pos
    .local int rx1266_off
    .local int rx1266_eos
    .local int rx1266_rep
    .local pmc rx1266_cur
    .local pmc rx1266_debug
    (rx1266_cur, rx1266_pos, rx1266_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1266_cur
    .local pmc match
    .lex "$/", match
    length rx1266_eos, rx1266_tgt
    gt rx1266_pos, rx1266_eos, rx1266_done
    set rx1266_off, 0
    lt rx1266_pos, 2, rx1266_start
    sub rx1266_off, rx1266_pos, 1
    substr rx1266_tgt, rx1266_tgt, rx1266_off
  rx1266_start:
    eq $I10, 1, rx1266_restart
    if_null rx1266_debug, debug_1106
    rx1266_cur."!cursor_debug"("START", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1106:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1269_done
    goto rxscan1269_scan
  rxscan1269_loop:
    (rx1266_pos) = rx1266_cur."from"()
    inc rx1266_pos
    rx1266_cur."!cursor_from"(rx1266_pos)
    ge rx1266_pos, rx1266_eos, rxscan1269_done
  rxscan1269_scan:
    set_addr $I10, rxscan1269_loop
    rx1266_cur."!mark_push"(0, rx1266_pos, $I10)
  rxscan1269_done:
.annotate 'line', 575
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1266_pos, rx1266_off
    substr $S10, rx1266_tgt, $I10, 1
    index $I11, unicode:"\x{ab}", $S10
    lt $I11, 0, rx1266_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1266_cur."!cursor_pos"(rx1266_pos)
    $P10 = rx1266_cur."quote_EXPR"(":qq", ":w")
    unless $P10, rx1266_fail
    rx1266_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1266_pos = $P10."pos"()
  # rx pass
    rx1266_cur."!cursor_pass"(rx1266_pos, unicode:"circumfix:sym<\x{ab} \x{bb}>")
    if_null rx1266_debug, debug_1107
    rx1266_cur."!cursor_debug"("PASS", unicode:"circumfix:sym<\x{ab} \x{bb}>", " at pos=", rx1266_pos)
  debug_1107:
    .return (rx1266_cur)
  rx1266_restart:
.annotate 'line', 10
    if_null rx1266_debug, debug_1108
    rx1266_cur."!cursor_debug"("NEXT", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1108:
  rx1266_fail:
    (rx1266_rep, rx1266_pos, $I10, $P10) = rx1266_cur."!mark_fail"(0)
    lt rx1266_pos, -1, rx1266_done
    eq rx1266_pos, -1, rx1266_fail
    jump $I10
  rx1266_done:
    rx1266_cur."!cursor_fail"()
    if_null rx1266_debug, debug_1109
    rx1266_cur."!cursor_debug"("FAIL", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1109:
    .return (rx1266_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"  :nsentry(unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>") :subid("266_1303340952.947") :method
.annotate 'line', 10
    new $P1268, "ResizablePMCArray"
    push $P1268, unicode:"\x{ab}"
    .return ($P1268)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<{ }>"  :subid("267_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1271_tgt
    .local int rx1271_pos
    .local int rx1271_off
    .local int rx1271_eos
    .local int rx1271_rep
    .local pmc rx1271_cur
    .local pmc rx1271_debug
    (rx1271_cur, rx1271_pos, rx1271_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1271_cur
    .local pmc match
    .lex "$/", match
    length rx1271_eos, rx1271_tgt
    gt rx1271_pos, rx1271_eos, rx1271_done
    set rx1271_off, 0
    lt rx1271_pos, 2, rx1271_start
    sub rx1271_off, rx1271_pos, 1
    substr rx1271_tgt, rx1271_tgt, rx1271_off
  rx1271_start:
    eq $I10, 1, rx1271_restart
    if_null rx1271_debug, debug_1110
    rx1271_cur."!cursor_debug"("START", "circumfix:sym<{ }>")
  debug_1110:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1274_done
    goto rxscan1274_scan
  rxscan1274_loop:
    (rx1271_pos) = rx1271_cur."from"()
    inc rx1271_pos
    rx1271_cur."!cursor_from"(rx1271_pos)
    ge rx1271_pos, rx1271_eos, rxscan1274_done
  rxscan1274_scan:
    set_addr $I10, rxscan1274_loop
    rx1271_cur."!mark_push"(0, rx1271_pos, $I10)
  rxscan1274_done:
.annotate 'line', 576
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1271_pos, rx1271_off
    substr $S10, rx1271_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1271_fail
  # rx subrule "pblock" subtype=capture negate=
    rx1271_cur."!cursor_pos"(rx1271_pos)
    $P10 = rx1271_cur."pblock"()
    unless $P10, rx1271_fail
    rx1271_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx1271_pos = $P10."pos"()
  # rx pass
    rx1271_cur."!cursor_pass"(rx1271_pos, "circumfix:sym<{ }>")
    if_null rx1271_debug, debug_1111
    rx1271_cur."!cursor_debug"("PASS", "circumfix:sym<{ }>", " at pos=", rx1271_pos)
  debug_1111:
    .return (rx1271_cur)
  rx1271_restart:
.annotate 'line', 10
    if_null rx1271_debug, debug_1112
    rx1271_cur."!cursor_debug"("NEXT", "circumfix:sym<{ }>")
  debug_1112:
  rx1271_fail:
    (rx1271_rep, rx1271_pos, $I10, $P10) = rx1271_cur."!mark_fail"(0)
    lt rx1271_pos, -1, rx1271_done
    eq rx1271_pos, -1, rx1271_fail
    jump $I10
  rx1271_done:
    rx1271_cur."!cursor_fail"()
    if_null rx1271_debug, debug_1113
    rx1271_cur."!cursor_debug"("FAIL", "circumfix:sym<{ }>")
  debug_1113:
    .return (rx1271_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<{ }>"  :nsentry("!PREFIX__circumfix:sym<{ }>") :subid("268_1303340952.947") :method
.annotate 'line', 10
    new $P1273, "ResizablePMCArray"
    push $P1273, "{"
    .return ($P1273)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<sigil>"  :subid("269_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1276_tgt
    .local int rx1276_pos
    .local int rx1276_off
    .local int rx1276_eos
    .local int rx1276_rep
    .local pmc rx1276_cur
    .local pmc rx1276_debug
    (rx1276_cur, rx1276_pos, rx1276_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1276_cur
    .local pmc match
    .lex "$/", match
    length rx1276_eos, rx1276_tgt
    gt rx1276_pos, rx1276_eos, rx1276_done
    set rx1276_off, 0
    lt rx1276_pos, 2, rx1276_start
    sub rx1276_off, rx1276_pos, 1
    substr rx1276_tgt, rx1276_tgt, rx1276_off
  rx1276_start:
    eq $I10, 1, rx1276_restart
    if_null rx1276_debug, debug_1114
    rx1276_cur."!cursor_debug"("START", "circumfix:sym<sigil>")
  debug_1114:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1280_done
    goto rxscan1280_scan
  rxscan1280_loop:
    (rx1276_pos) = rx1276_cur."from"()
    inc rx1276_pos
    rx1276_cur."!cursor_from"(rx1276_pos)
    ge rx1276_pos, rx1276_eos, rxscan1280_done
  rxscan1280_scan:
    set_addr $I10, rxscan1280_loop
    rx1276_cur."!mark_push"(0, rx1276_pos, $I10)
  rxscan1280_done:
.annotate 'line', 577
  # rx subrule "sigil" subtype=capture negate=
    rx1276_cur."!cursor_pos"(rx1276_pos)
    $P10 = rx1276_cur."sigil"()
    unless $P10, rx1276_fail
    rx1276_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1276_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1276_pos, 1
    gt $I11, rx1276_eos, rx1276_fail
    sub $I11, rx1276_pos, rx1276_off
    ord $I11, rx1276_tgt, $I11
    ne $I11, 40, rx1276_fail
    add rx1276_pos, 1
  # rx subrule "semilist" subtype=capture negate=
    rx1276_cur."!cursor_pos"(rx1276_pos)
    $P10 = rx1276_cur."semilist"()
    unless $P10, rx1276_fail
    rx1276_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("semilist")
    rx1276_pos = $P10."pos"()
  alt1281_0:
    set_addr $I10, alt1281_1
    rx1276_cur."!mark_push"(0, rx1276_pos, $I10)
  # rx literal  ")"
    add $I11, rx1276_pos, 1
    gt $I11, rx1276_eos, rx1276_fail
    sub $I11, rx1276_pos, rx1276_off
    ord $I11, rx1276_tgt, $I11
    ne $I11, 41, rx1276_fail
    add rx1276_pos, 1
    goto alt1281_end
  alt1281_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx1276_cur."!cursor_pos"(rx1276_pos)
    $P10 = rx1276_cur."FAILGOAL"("')'")
    unless $P10, rx1276_fail
    goto rxsubrule1283_pass
  rxsubrule1283_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1276_fail
  rxsubrule1283_pass:
    set_addr $I10, rxsubrule1283_back
    rx1276_cur."!mark_push"(0, rx1276_pos, $I10, $P10)
    rx1276_pos = $P10."pos"()
  alt1281_end:
  # rx pass
    rx1276_cur."!cursor_pass"(rx1276_pos, "circumfix:sym<sigil>")
    if_null rx1276_debug, debug_1115
    rx1276_cur."!cursor_debug"("PASS", "circumfix:sym<sigil>", " at pos=", rx1276_pos)
  debug_1115:
    .return (rx1276_cur)
  rx1276_restart:
.annotate 'line', 10
    if_null rx1276_debug, debug_1116
    rx1276_cur."!cursor_debug"("NEXT", "circumfix:sym<sigil>")
  debug_1116:
  rx1276_fail:
    (rx1276_rep, rx1276_pos, $I10, $P10) = rx1276_cur."!mark_fail"(0)
    lt rx1276_pos, -1, rx1276_done
    eq rx1276_pos, -1, rx1276_fail
    jump $I10
  rx1276_done:
    rx1276_cur."!cursor_fail"()
    if_null rx1276_debug, debug_1117
    rx1276_cur."!cursor_debug"("FAIL", "circumfix:sym<sigil>")
  debug_1117:
    .return (rx1276_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<sigil>"  :nsentry("!PREFIX__circumfix:sym<sigil>") :subid("270_1303340952.947") :method
.annotate 'line', 10
    $P1278 = self."!PREFIX__!subrule"("sigil", "")
    new $P1279, "ResizablePMCArray"
    push $P1279, $P1278
    .return ($P1279)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "semilist"  :subid("271_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1285_tgt
    .local int rx1285_pos
    .local int rx1285_off
    .local int rx1285_eos
    .local int rx1285_rep
    .local pmc rx1285_cur
    .local pmc rx1285_debug
    (rx1285_cur, rx1285_pos, rx1285_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1285_cur
    .local pmc match
    .lex "$/", match
    length rx1285_eos, rx1285_tgt
    gt rx1285_pos, rx1285_eos, rx1285_done
    set rx1285_off, 0
    lt rx1285_pos, 2, rx1285_start
    sub rx1285_off, rx1285_pos, 1
    substr rx1285_tgt, rx1285_tgt, rx1285_off
  rx1285_start:
    eq $I10, 1, rx1285_restart
    if_null rx1285_debug, debug_1118
    rx1285_cur."!cursor_debug"("START", "semilist")
  debug_1118:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1289_done
    goto rxscan1289_scan
  rxscan1289_loop:
    (rx1285_pos) = rx1285_cur."from"()
    inc rx1285_pos
    rx1285_cur."!cursor_from"(rx1285_pos)
    ge rx1285_pos, rx1285_eos, rxscan1289_done
  rxscan1289_scan:
    set_addr $I10, rxscan1289_loop
    rx1285_cur."!mark_push"(0, rx1285_pos, $I10)
  rxscan1289_done:
.annotate 'line', 579
  # rx subrule "ws" subtype=method negate=
    rx1285_cur."!cursor_pos"(rx1285_pos)
    $P10 = rx1285_cur."ws"()
    unless $P10, rx1285_fail
    rx1285_pos = $P10."pos"()
  # rx subrule "statement" subtype=capture negate=
    rx1285_cur."!cursor_pos"(rx1285_pos)
    $P10 = rx1285_cur."statement"()
    unless $P10, rx1285_fail
    rx1285_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx1285_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1285_cur."!cursor_pos"(rx1285_pos)
    $P10 = rx1285_cur."ws"()
    unless $P10, rx1285_fail
    rx1285_pos = $P10."pos"()
  # rx pass
    rx1285_cur."!cursor_pass"(rx1285_pos, "semilist")
    if_null rx1285_debug, debug_1119
    rx1285_cur."!cursor_debug"("PASS", "semilist", " at pos=", rx1285_pos)
  debug_1119:
    .return (rx1285_cur)
  rx1285_restart:
.annotate 'line', 10
    if_null rx1285_debug, debug_1120
    rx1285_cur."!cursor_debug"("NEXT", "semilist")
  debug_1120:
  rx1285_fail:
    (rx1285_rep, rx1285_pos, $I10, $P10) = rx1285_cur."!mark_fail"(0)
    lt rx1285_pos, -1, rx1285_done
    eq rx1285_pos, -1, rx1285_fail
    jump $I10
  rx1285_done:
    rx1285_cur."!cursor_fail"()
    if_null rx1285_debug, debug_1121
    rx1285_cur."!cursor_debug"("FAIL", "semilist")
  debug_1121:
    .return (rx1285_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__semilist"  :nsentry("!PREFIX__semilist") :subid("272_1303340952.947") :method
.annotate 'line', 10
    $P1287 = self."!PREFIX__!subrule"("ws", "")
    new $P1288, "ResizablePMCArray"
    push $P1288, $P1287
    .return ($P1288)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1292"  :anon :subid("273_1303340952.947") :outer("12_1303340952.947")
.annotate 'line', 10
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "" :load :init :subid("post1122") :outer("273_1303340952.947")
.annotate 'line', 10
    .const 'Sub' $P1293 = "273_1303340952.947" 
    .local pmc block
    set block, $P1293
.annotate 'line', 584
    get_hll_global $P1294, ["NQP"], "Grammar"
    $P1294."O"(":prec<y=>, :assoc<unary>", "%methodop")
.annotate 'line', 585
    get_hll_global $P1295, ["NQP"], "Grammar"
    $P1295."O"(":prec<x=>, :assoc<unary>", "%autoincrement")
.annotate 'line', 586
    get_hll_global $P1296, ["NQP"], "Grammar"
    $P1296."O"(":prec<w=>, :assoc<left>", "%exponentiation")
.annotate 'line', 587
    get_hll_global $P1297, ["NQP"], "Grammar"
    $P1297."O"(":prec<v=>, :assoc<unary>", "%symbolic_unary")
.annotate 'line', 588
    get_hll_global $P1298, ["NQP"], "Grammar"
    $P1298."O"(":prec<u=>, :assoc<left>", "%multiplicative")
.annotate 'line', 589
    get_hll_global $P1299, ["NQP"], "Grammar"
    $P1299."O"(":prec<t=>, :assoc<left>", "%additive")
.annotate 'line', 590
    get_hll_global $P1300, ["NQP"], "Grammar"
    $P1300."O"(":prec<r=>, :assoc<left>", "%concatenation")
.annotate 'line', 591
    get_hll_global $P1301, ["NQP"], "Grammar"
    $P1301."O"(":prec<m=>, :assoc<left>", "%relational")
.annotate 'line', 592
    get_hll_global $P1302, ["NQP"], "Grammar"
    $P1302."O"(":prec<l=>, :assoc<left>", "%tight_and")
.annotate 'line', 593
    get_hll_global $P1303, ["NQP"], "Grammar"
    $P1303."O"(":prec<k=>, :assoc<left>", "%tight_or")
.annotate 'line', 594
    get_hll_global $P1304, ["NQP"], "Grammar"
    $P1304."O"(":prec<j=>, :assoc<right>", "%conditional")
.annotate 'line', 595
    get_hll_global $P1305, ["NQP"], "Grammar"
    $P1305."O"(":prec<i=>, :assoc<right>", "%assignment")
.annotate 'line', 596
    get_hll_global $P1306, ["NQP"], "Grammar"
    $P1306."O"(":prec<g=>, :assoc<list>, :nextterm<nulltermish>", "%comma")
.annotate 'line', 597
    get_hll_global $P1307, ["NQP"], "Grammar"
    $P1307."O"(":prec<f=>, :assoc<list>", "%list_infix")
.annotate 'line', 598
    get_hll_global $P1308, ["NQP"], "Grammar"
    $P1308."O"(":prec<e=>, :assoc<unary>", "%list_prefix")
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixish"  :subid("274_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1310_tgt
    .local int rx1310_pos
    .local int rx1310_off
    .local int rx1310_eos
    .local int rx1310_rep
    .local pmc rx1310_cur
    .local pmc rx1310_debug
    (rx1310_cur, rx1310_pos, rx1310_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1310_cur
    .local pmc match
    .lex "$/", match
    length rx1310_eos, rx1310_tgt
    gt rx1310_pos, rx1310_eos, rx1310_done
    set rx1310_off, 0
    lt rx1310_pos, 2, rx1310_start
    sub rx1310_off, rx1310_pos, 1
    substr rx1310_tgt, rx1310_tgt, rx1310_off
  rx1310_start:
    eq $I10, 1, rx1310_restart
    if_null rx1310_debug, debug_1123
    rx1310_cur."!cursor_debug"("START", "infixish")
  debug_1123:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1313_done
    goto rxscan1313_scan
  rxscan1313_loop:
    (rx1310_pos) = rx1310_cur."from"()
    inc rx1310_pos
    rx1310_cur."!cursor_from"(rx1310_pos)
    ge rx1310_pos, rx1310_eos, rxscan1313_done
  rxscan1313_scan:
    set_addr $I10, rxscan1313_loop
    rx1310_cur."!mark_push"(0, rx1310_pos, $I10)
  rxscan1313_done:
.annotate 'line', 602
  # rx subrule "infixstopper" subtype=zerowidth negate=1
    rx1310_cur."!cursor_pos"(rx1310_pos)
    $P10 = rx1310_cur."infixstopper"()
    if $P10, rx1310_fail
  # rx subrule "infix" subtype=capture negate=
    rx1310_cur."!cursor_pos"(rx1310_pos)
    $P10 = rx1310_cur."infix"()
    unless $P10, rx1310_fail
    rx1310_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("OPER=infix")
    rx1310_pos = $P10."pos"()
  # rx pass
    rx1310_cur."!cursor_pass"(rx1310_pos, "infixish")
    if_null rx1310_debug, debug_1124
    rx1310_cur."!cursor_debug"("PASS", "infixish", " at pos=", rx1310_pos)
  debug_1124:
    .return (rx1310_cur)
  rx1310_restart:
.annotate 'line', 10
    if_null rx1310_debug, debug_1125
    rx1310_cur."!cursor_debug"("NEXT", "infixish")
  debug_1125:
  rx1310_fail:
    (rx1310_rep, rx1310_pos, $I10, $P10) = rx1310_cur."!mark_fail"(0)
    lt rx1310_pos, -1, rx1310_done
    eq rx1310_pos, -1, rx1310_fail
    jump $I10
  rx1310_done:
    rx1310_cur."!cursor_fail"()
    if_null rx1310_debug, debug_1126
    rx1310_cur."!cursor_debug"("FAIL", "infixish")
  debug_1126:
    .return (rx1310_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixish"  :nsentry("!PREFIX__infixish") :subid("275_1303340952.947") :method
.annotate 'line', 10
    new $P1312, "ResizablePMCArray"
    push $P1312, ""
    .return ($P1312)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixstopper"  :subid("276_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1315_tgt
    .local int rx1315_pos
    .local int rx1315_off
    .local int rx1315_eos
    .local int rx1315_rep
    .local pmc rx1315_cur
    .local pmc rx1315_debug
    (rx1315_cur, rx1315_pos, rx1315_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1315_cur
    .local pmc match
    .lex "$/", match
    length rx1315_eos, rx1315_tgt
    gt rx1315_pos, rx1315_eos, rx1315_done
    set rx1315_off, 0
    lt rx1315_pos, 2, rx1315_start
    sub rx1315_off, rx1315_pos, 1
    substr rx1315_tgt, rx1315_tgt, rx1315_off
  rx1315_start:
    eq $I10, 1, rx1315_restart
    if_null rx1315_debug, debug_1127
    rx1315_cur."!cursor_debug"("START", "infixstopper")
  debug_1127:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1318_done
    goto rxscan1318_scan
  rxscan1318_loop:
    (rx1315_pos) = rx1315_cur."from"()
    inc rx1315_pos
    rx1315_cur."!cursor_from"(rx1315_pos)
    ge rx1315_pos, rx1315_eos, rxscan1318_done
  rxscan1318_scan:
    set_addr $I10, rxscan1318_loop
    rx1315_cur."!mark_push"(0, rx1315_pos, $I10)
  rxscan1318_done:
.annotate 'line', 603
  # rx subrule "lambda" subtype=zerowidth negate=
    rx1315_cur."!cursor_pos"(rx1315_pos)
    $P10 = rx1315_cur."lambda"()
    unless $P10, rx1315_fail
  # rx pass
    rx1315_cur."!cursor_pass"(rx1315_pos, "infixstopper")
    if_null rx1315_debug, debug_1128
    rx1315_cur."!cursor_debug"("PASS", "infixstopper", " at pos=", rx1315_pos)
  debug_1128:
    .return (rx1315_cur)
  rx1315_restart:
.annotate 'line', 10
    if_null rx1315_debug, debug_1129
    rx1315_cur."!cursor_debug"("NEXT", "infixstopper")
  debug_1129:
  rx1315_fail:
    (rx1315_rep, rx1315_pos, $I10, $P10) = rx1315_cur."!mark_fail"(0)
    lt rx1315_pos, -1, rx1315_done
    eq rx1315_pos, -1, rx1315_fail
    jump $I10
  rx1315_done:
    rx1315_cur."!cursor_fail"()
    if_null rx1315_debug, debug_1130
    rx1315_cur."!cursor_debug"("FAIL", "infixstopper")
  debug_1130:
    .return (rx1315_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixstopper"  :nsentry("!PREFIX__infixstopper") :subid("277_1303340952.947") :method
.annotate 'line', 10
    new $P1317, "ResizablePMCArray"
    push $P1317, ""
    .return ($P1317)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<[ ]>"  :subid("278_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1320_tgt
    .local int rx1320_pos
    .local int rx1320_off
    .local int rx1320_eos
    .local int rx1320_rep
    .local pmc rx1320_cur
    .local pmc rx1320_debug
    (rx1320_cur, rx1320_pos, rx1320_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1320_cur
    .local pmc match
    .lex "$/", match
    length rx1320_eos, rx1320_tgt
    gt rx1320_pos, rx1320_eos, rx1320_done
    set rx1320_off, 0
    lt rx1320_pos, 2, rx1320_start
    sub rx1320_off, rx1320_pos, 1
    substr rx1320_tgt, rx1320_tgt, rx1320_off
  rx1320_start:
    eq $I10, 1, rx1320_restart
    if_null rx1320_debug, debug_1131
    rx1320_cur."!cursor_debug"("START", "postcircumfix:sym<[ ]>")
  debug_1131:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1324_done
    goto rxscan1324_scan
  rxscan1324_loop:
    (rx1320_pos) = rx1320_cur."from"()
    inc rx1320_pos
    rx1320_cur."!cursor_from"(rx1320_pos)
    ge rx1320_pos, rx1320_eos, rxscan1324_done
  rxscan1324_scan:
    set_addr $I10, rxscan1324_loop
    rx1320_cur."!mark_push"(0, rx1320_pos, $I10)
  rxscan1324_done:
.annotate 'line', 606
  # rx literal  "["
    add $I11, rx1320_pos, 1
    gt $I11, rx1320_eos, rx1320_fail
    sub $I11, rx1320_pos, rx1320_off
    ord $I11, rx1320_tgt, $I11
    ne $I11, 91, rx1320_fail
    add rx1320_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1320_cur."!cursor_pos"(rx1320_pos)
    $P10 = rx1320_cur."ws"()
    unless $P10, rx1320_fail
    rx1320_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1320_cur."!cursor_pos"(rx1320_pos)
    $P10 = rx1320_cur."EXPR"()
    unless $P10, rx1320_fail
    rx1320_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1320_pos = $P10."pos"()
  # rx literal  "]"
    add $I11, rx1320_pos, 1
    gt $I11, rx1320_eos, rx1320_fail
    sub $I11, rx1320_pos, rx1320_off
    ord $I11, rx1320_tgt, $I11
    ne $I11, 93, rx1320_fail
    add rx1320_pos, 1
.annotate 'line', 607
  # rx subrule "O" subtype=capture negate=
    rx1320_cur."!cursor_pos"(rx1320_pos)
    $P10 = rx1320_cur."O"("%methodop")
    unless $P10, rx1320_fail
    rx1320_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1320_pos = $P10."pos"()
.annotate 'line', 605
  # rx pass
    rx1320_cur."!cursor_pass"(rx1320_pos, "postcircumfix:sym<[ ]>")
    if_null rx1320_debug, debug_1132
    rx1320_cur."!cursor_debug"("PASS", "postcircumfix:sym<[ ]>", " at pos=", rx1320_pos)
  debug_1132:
    .return (rx1320_cur)
  rx1320_restart:
.annotate 'line', 10
    if_null rx1320_debug, debug_1133
    rx1320_cur."!cursor_debug"("NEXT", "postcircumfix:sym<[ ]>")
  debug_1133:
  rx1320_fail:
    (rx1320_rep, rx1320_pos, $I10, $P10) = rx1320_cur."!mark_fail"(0)
    lt rx1320_pos, -1, rx1320_done
    eq rx1320_pos, -1, rx1320_fail
    jump $I10
  rx1320_done:
    rx1320_cur."!cursor_fail"()
    if_null rx1320_debug, debug_1134
    rx1320_cur."!cursor_debug"("FAIL", "postcircumfix:sym<[ ]>")
  debug_1134:
    .return (rx1320_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<[ ]>"  :nsentry("!PREFIX__postcircumfix:sym<[ ]>") :subid("279_1303340952.947") :method
.annotate 'line', 10
    $P1322 = self."!PREFIX__!subrule"("ws", "[")
    new $P1323, "ResizablePMCArray"
    push $P1323, $P1322
    .return ($P1323)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<{ }>"  :subid("280_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1326_tgt
    .local int rx1326_pos
    .local int rx1326_off
    .local int rx1326_eos
    .local int rx1326_rep
    .local pmc rx1326_cur
    .local pmc rx1326_debug
    (rx1326_cur, rx1326_pos, rx1326_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1326_cur
    .local pmc match
    .lex "$/", match
    length rx1326_eos, rx1326_tgt
    gt rx1326_pos, rx1326_eos, rx1326_done
    set rx1326_off, 0
    lt rx1326_pos, 2, rx1326_start
    sub rx1326_off, rx1326_pos, 1
    substr rx1326_tgt, rx1326_tgt, rx1326_off
  rx1326_start:
    eq $I10, 1, rx1326_restart
    if_null rx1326_debug, debug_1135
    rx1326_cur."!cursor_debug"("START", "postcircumfix:sym<{ }>")
  debug_1135:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1330_done
    goto rxscan1330_scan
  rxscan1330_loop:
    (rx1326_pos) = rx1326_cur."from"()
    inc rx1326_pos
    rx1326_cur."!cursor_from"(rx1326_pos)
    ge rx1326_pos, rx1326_eos, rxscan1330_done
  rxscan1330_scan:
    set_addr $I10, rxscan1330_loop
    rx1326_cur."!mark_push"(0, rx1326_pos, $I10)
  rxscan1330_done:
.annotate 'line', 611
  # rx literal  "{"
    add $I11, rx1326_pos, 1
    gt $I11, rx1326_eos, rx1326_fail
    sub $I11, rx1326_pos, rx1326_off
    ord $I11, rx1326_tgt, $I11
    ne $I11, 123, rx1326_fail
    add rx1326_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1326_cur."!cursor_pos"(rx1326_pos)
    $P10 = rx1326_cur."ws"()
    unless $P10, rx1326_fail
    rx1326_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1326_cur."!cursor_pos"(rx1326_pos)
    $P10 = rx1326_cur."EXPR"()
    unless $P10, rx1326_fail
    rx1326_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1326_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1326_pos, 1
    gt $I11, rx1326_eos, rx1326_fail
    sub $I11, rx1326_pos, rx1326_off
    ord $I11, rx1326_tgt, $I11
    ne $I11, 125, rx1326_fail
    add rx1326_pos, 1
.annotate 'line', 612
  # rx subrule "O" subtype=capture negate=
    rx1326_cur."!cursor_pos"(rx1326_pos)
    $P10 = rx1326_cur."O"("%methodop")
    unless $P10, rx1326_fail
    rx1326_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1326_pos = $P10."pos"()
.annotate 'line', 610
  # rx pass
    rx1326_cur."!cursor_pass"(rx1326_pos, "postcircumfix:sym<{ }>")
    if_null rx1326_debug, debug_1136
    rx1326_cur."!cursor_debug"("PASS", "postcircumfix:sym<{ }>", " at pos=", rx1326_pos)
  debug_1136:
    .return (rx1326_cur)
  rx1326_restart:
.annotate 'line', 10
    if_null rx1326_debug, debug_1137
    rx1326_cur."!cursor_debug"("NEXT", "postcircumfix:sym<{ }>")
  debug_1137:
  rx1326_fail:
    (rx1326_rep, rx1326_pos, $I10, $P10) = rx1326_cur."!mark_fail"(0)
    lt rx1326_pos, -1, rx1326_done
    eq rx1326_pos, -1, rx1326_fail
    jump $I10
  rx1326_done:
    rx1326_cur."!cursor_fail"()
    if_null rx1326_debug, debug_1138
    rx1326_cur."!cursor_debug"("FAIL", "postcircumfix:sym<{ }>")
  debug_1138:
    .return (rx1326_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<{ }>"  :nsentry("!PREFIX__postcircumfix:sym<{ }>") :subid("281_1303340952.947") :method
.annotate 'line', 10
    $P1328 = self."!PREFIX__!subrule"("ws", "{")
    new $P1329, "ResizablePMCArray"
    push $P1329, $P1328
    .return ($P1329)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<ang>"  :subid("282_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1332_tgt
    .local int rx1332_pos
    .local int rx1332_off
    .local int rx1332_eos
    .local int rx1332_rep
    .local pmc rx1332_cur
    .local pmc rx1332_debug
    (rx1332_cur, rx1332_pos, rx1332_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1332_cur
    .local pmc match
    .lex "$/", match
    length rx1332_eos, rx1332_tgt
    gt rx1332_pos, rx1332_eos, rx1332_done
    set rx1332_off, 0
    lt rx1332_pos, 2, rx1332_start
    sub rx1332_off, rx1332_pos, 1
    substr rx1332_tgt, rx1332_tgt, rx1332_off
  rx1332_start:
    eq $I10, 1, rx1332_restart
    if_null rx1332_debug, debug_1139
    rx1332_cur."!cursor_debug"("START", "postcircumfix:sym<ang>")
  debug_1139:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1335_done
    goto rxscan1335_scan
  rxscan1335_loop:
    (rx1332_pos) = rx1332_cur."from"()
    inc rx1332_pos
    rx1332_cur."!cursor_from"(rx1332_pos)
    ge rx1332_pos, rx1332_eos, rxscan1335_done
  rxscan1335_scan:
    set_addr $I10, rxscan1335_loop
    rx1332_cur."!mark_push"(0, rx1332_pos, $I10)
  rxscan1335_done:
.annotate 'line', 616
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1332_pos, rx1332_off
    substr $S10, rx1332_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx1332_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1332_cur."!cursor_pos"(rx1332_pos)
    $P10 = rx1332_cur."quote_EXPR"(":q")
    unless $P10, rx1332_fail
    rx1332_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1332_pos = $P10."pos"()
.annotate 'line', 617
  # rx subrule "O" subtype=capture negate=
    rx1332_cur."!cursor_pos"(rx1332_pos)
    $P10 = rx1332_cur."O"("%methodop")
    unless $P10, rx1332_fail
    rx1332_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1332_pos = $P10."pos"()
.annotate 'line', 615
  # rx pass
    rx1332_cur."!cursor_pass"(rx1332_pos, "postcircumfix:sym<ang>")
    if_null rx1332_debug, debug_1140
    rx1332_cur."!cursor_debug"("PASS", "postcircumfix:sym<ang>", " at pos=", rx1332_pos)
  debug_1140:
    .return (rx1332_cur)
  rx1332_restart:
.annotate 'line', 10
    if_null rx1332_debug, debug_1141
    rx1332_cur."!cursor_debug"("NEXT", "postcircumfix:sym<ang>")
  debug_1141:
  rx1332_fail:
    (rx1332_rep, rx1332_pos, $I10, $P10) = rx1332_cur."!mark_fail"(0)
    lt rx1332_pos, -1, rx1332_done
    eq rx1332_pos, -1, rx1332_fail
    jump $I10
  rx1332_done:
    rx1332_cur."!cursor_fail"()
    if_null rx1332_debug, debug_1142
    rx1332_cur."!cursor_debug"("FAIL", "postcircumfix:sym<ang>")
  debug_1142:
    .return (rx1332_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<ang>"  :nsentry("!PREFIX__postcircumfix:sym<ang>") :subid("283_1303340952.947") :method
.annotate 'line', 10
    new $P1334, "ResizablePMCArray"
    push $P1334, "<"
    .return ($P1334)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<( )>"  :subid("284_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1337_tgt
    .local int rx1337_pos
    .local int rx1337_off
    .local int rx1337_eos
    .local int rx1337_rep
    .local pmc rx1337_cur
    .local pmc rx1337_debug
    (rx1337_cur, rx1337_pos, rx1337_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1337_cur
    .local pmc match
    .lex "$/", match
    length rx1337_eos, rx1337_tgt
    gt rx1337_pos, rx1337_eos, rx1337_done
    set rx1337_off, 0
    lt rx1337_pos, 2, rx1337_start
    sub rx1337_off, rx1337_pos, 1
    substr rx1337_tgt, rx1337_tgt, rx1337_off
  rx1337_start:
    eq $I10, 1, rx1337_restart
    if_null rx1337_debug, debug_1143
    rx1337_cur."!cursor_debug"("START", "postcircumfix:sym<( )>")
  debug_1143:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1341_done
    goto rxscan1341_scan
  rxscan1341_loop:
    (rx1337_pos) = rx1337_cur."from"()
    inc rx1337_pos
    rx1337_cur."!cursor_from"(rx1337_pos)
    ge rx1337_pos, rx1337_eos, rxscan1341_done
  rxscan1341_scan:
    set_addr $I10, rxscan1341_loop
    rx1337_cur."!mark_push"(0, rx1337_pos, $I10)
  rxscan1341_done:
.annotate 'line', 621
  # rx literal  "("
    add $I11, rx1337_pos, 1
    gt $I11, rx1337_eos, rx1337_fail
    sub $I11, rx1337_pos, rx1337_off
    ord $I11, rx1337_tgt, $I11
    ne $I11, 40, rx1337_fail
    add rx1337_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1337_cur."!cursor_pos"(rx1337_pos)
    $P10 = rx1337_cur."ws"()
    unless $P10, rx1337_fail
    rx1337_pos = $P10."pos"()
  # rx subrule "arglist" subtype=capture negate=
    rx1337_cur."!cursor_pos"(rx1337_pos)
    $P10 = rx1337_cur."arglist"()
    unless $P10, rx1337_fail
    rx1337_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1337_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1337_pos, 1
    gt $I11, rx1337_eos, rx1337_fail
    sub $I11, rx1337_pos, rx1337_off
    ord $I11, rx1337_tgt, $I11
    ne $I11, 41, rx1337_fail
    add rx1337_pos, 1
.annotate 'line', 622
  # rx subrule "O" subtype=capture negate=
    rx1337_cur."!cursor_pos"(rx1337_pos)
    $P10 = rx1337_cur."O"("%methodop")
    unless $P10, rx1337_fail
    rx1337_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1337_pos = $P10."pos"()
.annotate 'line', 620
  # rx pass
    rx1337_cur."!cursor_pass"(rx1337_pos, "postcircumfix:sym<( )>")
    if_null rx1337_debug, debug_1144
    rx1337_cur."!cursor_debug"("PASS", "postcircumfix:sym<( )>", " at pos=", rx1337_pos)
  debug_1144:
    .return (rx1337_cur)
  rx1337_restart:
.annotate 'line', 10
    if_null rx1337_debug, debug_1145
    rx1337_cur."!cursor_debug"("NEXT", "postcircumfix:sym<( )>")
  debug_1145:
  rx1337_fail:
    (rx1337_rep, rx1337_pos, $I10, $P10) = rx1337_cur."!mark_fail"(0)
    lt rx1337_pos, -1, rx1337_done
    eq rx1337_pos, -1, rx1337_fail
    jump $I10
  rx1337_done:
    rx1337_cur."!cursor_fail"()
    if_null rx1337_debug, debug_1146
    rx1337_cur."!cursor_debug"("FAIL", "postcircumfix:sym<( )>")
  debug_1146:
    .return (rx1337_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<( )>"  :nsentry("!PREFIX__postcircumfix:sym<( )>") :subid("285_1303340952.947") :method
.annotate 'line', 10
    $P1339 = self."!PREFIX__!subrule"("ws", "(")
    new $P1340, "ResizablePMCArray"
    push $P1340, $P1339
    .return ($P1340)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<.>"  :subid("286_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1343_tgt
    .local int rx1343_pos
    .local int rx1343_off
    .local int rx1343_eos
    .local int rx1343_rep
    .local pmc rx1343_cur
    .local pmc rx1343_debug
    (rx1343_cur, rx1343_pos, rx1343_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1343_cur
    .local pmc match
    .lex "$/", match
    length rx1343_eos, rx1343_tgt
    gt rx1343_pos, rx1343_eos, rx1343_done
    set rx1343_off, 0
    lt rx1343_pos, 2, rx1343_start
    sub rx1343_off, rx1343_pos, 1
    substr rx1343_tgt, rx1343_tgt, rx1343_off
  rx1343_start:
    eq $I10, 1, rx1343_restart
    if_null rx1343_debug, debug_1147
    rx1343_cur."!cursor_debug"("START", "postfix:sym<.>")
  debug_1147:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1347_done
    goto rxscan1347_scan
  rxscan1347_loop:
    (rx1343_pos) = rx1343_cur."from"()
    inc rx1343_pos
    rx1343_cur."!cursor_from"(rx1343_pos)
    ge rx1343_pos, rx1343_eos, rxscan1347_done
  rxscan1347_scan:
    set_addr $I10, rxscan1347_loop
    rx1343_cur."!mark_push"(0, rx1343_pos, $I10)
  rxscan1347_done:
.annotate 'line', 625
  # rx subrule "dotty" subtype=capture negate=
    rx1343_cur."!cursor_pos"(rx1343_pos)
    $P10 = rx1343_cur."dotty"()
    unless $P10, rx1343_fail
    rx1343_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dotty")
    rx1343_pos = $P10."pos"()
  # rx subrule "O" subtype=capture negate=
    rx1343_cur."!cursor_pos"(rx1343_pos)
    $P10 = rx1343_cur."O"("%methodop")
    unless $P10, rx1343_fail
    rx1343_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1343_pos = $P10."pos"()
  # rx pass
    rx1343_cur."!cursor_pass"(rx1343_pos, "postfix:sym<.>")
    if_null rx1343_debug, debug_1148
    rx1343_cur."!cursor_debug"("PASS", "postfix:sym<.>", " at pos=", rx1343_pos)
  debug_1148:
    .return (rx1343_cur)
  rx1343_restart:
.annotate 'line', 10
    if_null rx1343_debug, debug_1149
    rx1343_cur."!cursor_debug"("NEXT", "postfix:sym<.>")
  debug_1149:
  rx1343_fail:
    (rx1343_rep, rx1343_pos, $I10, $P10) = rx1343_cur."!mark_fail"(0)
    lt rx1343_pos, -1, rx1343_done
    eq rx1343_pos, -1, rx1343_fail
    jump $I10
  rx1343_done:
    rx1343_cur."!cursor_fail"()
    if_null rx1343_debug, debug_1150
    rx1343_cur."!cursor_debug"("FAIL", "postfix:sym<.>")
  debug_1150:
    .return (rx1343_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<.>"  :nsentry("!PREFIX__postfix:sym<.>") :subid("287_1303340952.947") :method
.annotate 'line', 10
    $P1345 = self."!PREFIX__!subrule"("dotty", "")
    new $P1346, "ResizablePMCArray"
    push $P1346, $P1345
    .return ($P1346)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<++>"  :subid("288_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1349_tgt
    .local int rx1349_pos
    .local int rx1349_off
    .local int rx1349_eos
    .local int rx1349_rep
    .local pmc rx1349_cur
    .local pmc rx1349_debug
    (rx1349_cur, rx1349_pos, rx1349_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1349_cur
    .local pmc match
    .lex "$/", match
    length rx1349_eos, rx1349_tgt
    gt rx1349_pos, rx1349_eos, rx1349_done
    set rx1349_off, 0
    lt rx1349_pos, 2, rx1349_start
    sub rx1349_off, rx1349_pos, 1
    substr rx1349_tgt, rx1349_tgt, rx1349_off
  rx1349_start:
    eq $I10, 1, rx1349_restart
    if_null rx1349_debug, debug_1151
    rx1349_cur."!cursor_debug"("START", "prefix:sym<++>")
  debug_1151:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1353_done
    goto rxscan1353_scan
  rxscan1353_loop:
    (rx1349_pos) = rx1349_cur."from"()
    inc rx1349_pos
    rx1349_cur."!cursor_from"(rx1349_pos)
    ge rx1349_pos, rx1349_eos, rxscan1353_done
  rxscan1353_scan:
    set_addr $I10, rxscan1353_loop
    rx1349_cur."!mark_push"(0, rx1349_pos, $I10)
  rxscan1353_done:
.annotate 'line', 627
  # rx subcapture "sym"
    set_addr $I10, rxcap_1354_fail
    rx1349_cur."!mark_push"(0, rx1349_pos, $I10)
  # rx literal  "++"
    add $I11, rx1349_pos, 2
    gt $I11, rx1349_eos, rx1349_fail
    sub $I11, rx1349_pos, rx1349_off
    substr $S10, rx1349_tgt, $I11, 2
    ne $S10, "++", rx1349_fail
    add rx1349_pos, 2
    set_addr $I10, rxcap_1354_fail
    ($I12, $I11) = rx1349_cur."!mark_peek"($I10)
    rx1349_cur."!cursor_pos"($I11)
    ($P10) = rx1349_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1349_pos, "")
    rx1349_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1354_done
  rxcap_1354_fail:
    goto rx1349_fail
  rxcap_1354_done:
  # rx subrule "O" subtype=capture negate=
    rx1349_cur."!cursor_pos"(rx1349_pos)
    $P10 = rx1349_cur."O"("%autoincrement, :pirop<inc>")
    unless $P10, rx1349_fail
    rx1349_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1349_pos = $P10."pos"()
  # rx pass
    rx1349_cur."!cursor_pass"(rx1349_pos, "prefix:sym<++>")
    if_null rx1349_debug, debug_1152
    rx1349_cur."!cursor_debug"("PASS", "prefix:sym<++>", " at pos=", rx1349_pos)
  debug_1152:
    .return (rx1349_cur)
  rx1349_restart:
.annotate 'line', 10
    if_null rx1349_debug, debug_1153
    rx1349_cur."!cursor_debug"("NEXT", "prefix:sym<++>")
  debug_1153:
  rx1349_fail:
    (rx1349_rep, rx1349_pos, $I10, $P10) = rx1349_cur."!mark_fail"(0)
    lt rx1349_pos, -1, rx1349_done
    eq rx1349_pos, -1, rx1349_fail
    jump $I10
  rx1349_done:
    rx1349_cur."!cursor_fail"()
    if_null rx1349_debug, debug_1154
    rx1349_cur."!cursor_debug"("FAIL", "prefix:sym<++>")
  debug_1154:
    .return (rx1349_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<++>"  :nsentry("!PREFIX__prefix:sym<++>") :subid("289_1303340952.947") :method
.annotate 'line', 10
    $P1351 = self."!PREFIX__!subrule"("O", "++")
    new $P1352, "ResizablePMCArray"
    push $P1352, $P1351
    .return ($P1352)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<-->"  :subid("290_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1356_tgt
    .local int rx1356_pos
    .local int rx1356_off
    .local int rx1356_eos
    .local int rx1356_rep
    .local pmc rx1356_cur
    .local pmc rx1356_debug
    (rx1356_cur, rx1356_pos, rx1356_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1356_cur
    .local pmc match
    .lex "$/", match
    length rx1356_eos, rx1356_tgt
    gt rx1356_pos, rx1356_eos, rx1356_done
    set rx1356_off, 0
    lt rx1356_pos, 2, rx1356_start
    sub rx1356_off, rx1356_pos, 1
    substr rx1356_tgt, rx1356_tgt, rx1356_off
  rx1356_start:
    eq $I10, 1, rx1356_restart
    if_null rx1356_debug, debug_1155
    rx1356_cur."!cursor_debug"("START", "prefix:sym<-->")
  debug_1155:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1360_done
    goto rxscan1360_scan
  rxscan1360_loop:
    (rx1356_pos) = rx1356_cur."from"()
    inc rx1356_pos
    rx1356_cur."!cursor_from"(rx1356_pos)
    ge rx1356_pos, rx1356_eos, rxscan1360_done
  rxscan1360_scan:
    set_addr $I10, rxscan1360_loop
    rx1356_cur."!mark_push"(0, rx1356_pos, $I10)
  rxscan1360_done:
.annotate 'line', 628
  # rx subcapture "sym"
    set_addr $I10, rxcap_1361_fail
    rx1356_cur."!mark_push"(0, rx1356_pos, $I10)
  # rx literal  "--"
    add $I11, rx1356_pos, 2
    gt $I11, rx1356_eos, rx1356_fail
    sub $I11, rx1356_pos, rx1356_off
    substr $S10, rx1356_tgt, $I11, 2
    ne $S10, "--", rx1356_fail
    add rx1356_pos, 2
    set_addr $I10, rxcap_1361_fail
    ($I12, $I11) = rx1356_cur."!mark_peek"($I10)
    rx1356_cur."!cursor_pos"($I11)
    ($P10) = rx1356_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1356_pos, "")
    rx1356_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1361_done
  rxcap_1361_fail:
    goto rx1356_fail
  rxcap_1361_done:
  # rx subrule "O" subtype=capture negate=
    rx1356_cur."!cursor_pos"(rx1356_pos)
    $P10 = rx1356_cur."O"("%autoincrement, :pirop<dec>")
    unless $P10, rx1356_fail
    rx1356_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1356_pos = $P10."pos"()
  # rx pass
    rx1356_cur."!cursor_pass"(rx1356_pos, "prefix:sym<-->")
    if_null rx1356_debug, debug_1156
    rx1356_cur."!cursor_debug"("PASS", "prefix:sym<-->", " at pos=", rx1356_pos)
  debug_1156:
    .return (rx1356_cur)
  rx1356_restart:
.annotate 'line', 10
    if_null rx1356_debug, debug_1157
    rx1356_cur."!cursor_debug"("NEXT", "prefix:sym<-->")
  debug_1157:
  rx1356_fail:
    (rx1356_rep, rx1356_pos, $I10, $P10) = rx1356_cur."!mark_fail"(0)
    lt rx1356_pos, -1, rx1356_done
    eq rx1356_pos, -1, rx1356_fail
    jump $I10
  rx1356_done:
    rx1356_cur."!cursor_fail"()
    if_null rx1356_debug, debug_1158
    rx1356_cur."!cursor_debug"("FAIL", "prefix:sym<-->")
  debug_1158:
    .return (rx1356_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<-->"  :nsentry("!PREFIX__prefix:sym<-->") :subid("291_1303340952.947") :method
.annotate 'line', 10
    $P1358 = self."!PREFIX__!subrule"("O", "--")
    new $P1359, "ResizablePMCArray"
    push $P1359, $P1358
    .return ($P1359)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<++>"  :subid("292_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1363_tgt
    .local int rx1363_pos
    .local int rx1363_off
    .local int rx1363_eos
    .local int rx1363_rep
    .local pmc rx1363_cur
    .local pmc rx1363_debug
    (rx1363_cur, rx1363_pos, rx1363_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1363_cur
    .local pmc match
    .lex "$/", match
    length rx1363_eos, rx1363_tgt
    gt rx1363_pos, rx1363_eos, rx1363_done
    set rx1363_off, 0
    lt rx1363_pos, 2, rx1363_start
    sub rx1363_off, rx1363_pos, 1
    substr rx1363_tgt, rx1363_tgt, rx1363_off
  rx1363_start:
    eq $I10, 1, rx1363_restart
    if_null rx1363_debug, debug_1159
    rx1363_cur."!cursor_debug"("START", "postfix:sym<++>")
  debug_1159:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1367_done
    goto rxscan1367_scan
  rxscan1367_loop:
    (rx1363_pos) = rx1363_cur."from"()
    inc rx1363_pos
    rx1363_cur."!cursor_from"(rx1363_pos)
    ge rx1363_pos, rx1363_eos, rxscan1367_done
  rxscan1367_scan:
    set_addr $I10, rxscan1367_loop
    rx1363_cur."!mark_push"(0, rx1363_pos, $I10)
  rxscan1367_done:
.annotate 'line', 631
  # rx subcapture "sym"
    set_addr $I10, rxcap_1368_fail
    rx1363_cur."!mark_push"(0, rx1363_pos, $I10)
  # rx literal  "++"
    add $I11, rx1363_pos, 2
    gt $I11, rx1363_eos, rx1363_fail
    sub $I11, rx1363_pos, rx1363_off
    substr $S10, rx1363_tgt, $I11, 2
    ne $S10, "++", rx1363_fail
    add rx1363_pos, 2
    set_addr $I10, rxcap_1368_fail
    ($I12, $I11) = rx1363_cur."!mark_peek"($I10)
    rx1363_cur."!cursor_pos"($I11)
    ($P10) = rx1363_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1363_pos, "")
    rx1363_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1368_done
  rxcap_1368_fail:
    goto rx1363_fail
  rxcap_1368_done:
  # rx subrule "O" subtype=capture negate=
    rx1363_cur."!cursor_pos"(rx1363_pos)
    $P10 = rx1363_cur."O"("%autoincrement")
    unless $P10, rx1363_fail
    rx1363_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1363_pos = $P10."pos"()
  # rx pass
    rx1363_cur."!cursor_pass"(rx1363_pos, "postfix:sym<++>")
    if_null rx1363_debug, debug_1160
    rx1363_cur."!cursor_debug"("PASS", "postfix:sym<++>", " at pos=", rx1363_pos)
  debug_1160:
    .return (rx1363_cur)
  rx1363_restart:
.annotate 'line', 10
    if_null rx1363_debug, debug_1161
    rx1363_cur."!cursor_debug"("NEXT", "postfix:sym<++>")
  debug_1161:
  rx1363_fail:
    (rx1363_rep, rx1363_pos, $I10, $P10) = rx1363_cur."!mark_fail"(0)
    lt rx1363_pos, -1, rx1363_done
    eq rx1363_pos, -1, rx1363_fail
    jump $I10
  rx1363_done:
    rx1363_cur."!cursor_fail"()
    if_null rx1363_debug, debug_1162
    rx1363_cur."!cursor_debug"("FAIL", "postfix:sym<++>")
  debug_1162:
    .return (rx1363_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<++>"  :nsentry("!PREFIX__postfix:sym<++>") :subid("293_1303340952.947") :method
.annotate 'line', 10
    $P1365 = self."!PREFIX__!subrule"("O", "++")
    new $P1366, "ResizablePMCArray"
    push $P1366, $P1365
    .return ($P1366)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<-->"  :subid("294_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1370_tgt
    .local int rx1370_pos
    .local int rx1370_off
    .local int rx1370_eos
    .local int rx1370_rep
    .local pmc rx1370_cur
    .local pmc rx1370_debug
    (rx1370_cur, rx1370_pos, rx1370_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1370_cur
    .local pmc match
    .lex "$/", match
    length rx1370_eos, rx1370_tgt
    gt rx1370_pos, rx1370_eos, rx1370_done
    set rx1370_off, 0
    lt rx1370_pos, 2, rx1370_start
    sub rx1370_off, rx1370_pos, 1
    substr rx1370_tgt, rx1370_tgt, rx1370_off
  rx1370_start:
    eq $I10, 1, rx1370_restart
    if_null rx1370_debug, debug_1163
    rx1370_cur."!cursor_debug"("START", "postfix:sym<-->")
  debug_1163:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1374_done
    goto rxscan1374_scan
  rxscan1374_loop:
    (rx1370_pos) = rx1370_cur."from"()
    inc rx1370_pos
    rx1370_cur."!cursor_from"(rx1370_pos)
    ge rx1370_pos, rx1370_eos, rxscan1374_done
  rxscan1374_scan:
    set_addr $I10, rxscan1374_loop
    rx1370_cur."!mark_push"(0, rx1370_pos, $I10)
  rxscan1374_done:
.annotate 'line', 632
  # rx subcapture "sym"
    set_addr $I10, rxcap_1375_fail
    rx1370_cur."!mark_push"(0, rx1370_pos, $I10)
  # rx literal  "--"
    add $I11, rx1370_pos, 2
    gt $I11, rx1370_eos, rx1370_fail
    sub $I11, rx1370_pos, rx1370_off
    substr $S10, rx1370_tgt, $I11, 2
    ne $S10, "--", rx1370_fail
    add rx1370_pos, 2
    set_addr $I10, rxcap_1375_fail
    ($I12, $I11) = rx1370_cur."!mark_peek"($I10)
    rx1370_cur."!cursor_pos"($I11)
    ($P10) = rx1370_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1370_pos, "")
    rx1370_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1375_done
  rxcap_1375_fail:
    goto rx1370_fail
  rxcap_1375_done:
  # rx subrule "O" subtype=capture negate=
    rx1370_cur."!cursor_pos"(rx1370_pos)
    $P10 = rx1370_cur."O"("%autoincrement")
    unless $P10, rx1370_fail
    rx1370_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1370_pos = $P10."pos"()
  # rx pass
    rx1370_cur."!cursor_pass"(rx1370_pos, "postfix:sym<-->")
    if_null rx1370_debug, debug_1164
    rx1370_cur."!cursor_debug"("PASS", "postfix:sym<-->", " at pos=", rx1370_pos)
  debug_1164:
    .return (rx1370_cur)
  rx1370_restart:
.annotate 'line', 10
    if_null rx1370_debug, debug_1165
    rx1370_cur."!cursor_debug"("NEXT", "postfix:sym<-->")
  debug_1165:
  rx1370_fail:
    (rx1370_rep, rx1370_pos, $I10, $P10) = rx1370_cur."!mark_fail"(0)
    lt rx1370_pos, -1, rx1370_done
    eq rx1370_pos, -1, rx1370_fail
    jump $I10
  rx1370_done:
    rx1370_cur."!cursor_fail"()
    if_null rx1370_debug, debug_1166
    rx1370_cur."!cursor_debug"("FAIL", "postfix:sym<-->")
  debug_1166:
    .return (rx1370_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<-->"  :nsentry("!PREFIX__postfix:sym<-->") :subid("295_1303340952.947") :method
.annotate 'line', 10
    $P1372 = self."!PREFIX__!subrule"("O", "--")
    new $P1373, "ResizablePMCArray"
    push $P1373, $P1372
    .return ($P1373)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<**>"  :subid("296_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1377_tgt
    .local int rx1377_pos
    .local int rx1377_off
    .local int rx1377_eos
    .local int rx1377_rep
    .local pmc rx1377_cur
    .local pmc rx1377_debug
    (rx1377_cur, rx1377_pos, rx1377_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1377_cur
    .local pmc match
    .lex "$/", match
    length rx1377_eos, rx1377_tgt
    gt rx1377_pos, rx1377_eos, rx1377_done
    set rx1377_off, 0
    lt rx1377_pos, 2, rx1377_start
    sub rx1377_off, rx1377_pos, 1
    substr rx1377_tgt, rx1377_tgt, rx1377_off
  rx1377_start:
    eq $I10, 1, rx1377_restart
    if_null rx1377_debug, debug_1167
    rx1377_cur."!cursor_debug"("START", "infix:sym<**>")
  debug_1167:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1381_done
    goto rxscan1381_scan
  rxscan1381_loop:
    (rx1377_pos) = rx1377_cur."from"()
    inc rx1377_pos
    rx1377_cur."!cursor_from"(rx1377_pos)
    ge rx1377_pos, rx1377_eos, rxscan1381_done
  rxscan1381_scan:
    set_addr $I10, rxscan1381_loop
    rx1377_cur."!mark_push"(0, rx1377_pos, $I10)
  rxscan1381_done:
.annotate 'line', 634
  # rx subcapture "sym"
    set_addr $I10, rxcap_1382_fail
    rx1377_cur."!mark_push"(0, rx1377_pos, $I10)
  # rx literal  "**"
    add $I11, rx1377_pos, 2
    gt $I11, rx1377_eos, rx1377_fail
    sub $I11, rx1377_pos, rx1377_off
    substr $S10, rx1377_tgt, $I11, 2
    ne $S10, "**", rx1377_fail
    add rx1377_pos, 2
    set_addr $I10, rxcap_1382_fail
    ($I12, $I11) = rx1377_cur."!mark_peek"($I10)
    rx1377_cur."!cursor_pos"($I11)
    ($P10) = rx1377_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1377_pos, "")
    rx1377_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1382_done
  rxcap_1382_fail:
    goto rx1377_fail
  rxcap_1382_done:
  # rx subrule "O" subtype=capture negate=
    rx1377_cur."!cursor_pos"(rx1377_pos)
    $P10 = rx1377_cur."O"("%exponentiation, :pirop<pow>")
    unless $P10, rx1377_fail
    rx1377_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1377_pos = $P10."pos"()
  # rx pass
    rx1377_cur."!cursor_pass"(rx1377_pos, "infix:sym<**>")
    if_null rx1377_debug, debug_1168
    rx1377_cur."!cursor_debug"("PASS", "infix:sym<**>", " at pos=", rx1377_pos)
  debug_1168:
    .return (rx1377_cur)
  rx1377_restart:
.annotate 'line', 10
    if_null rx1377_debug, debug_1169
    rx1377_cur."!cursor_debug"("NEXT", "infix:sym<**>")
  debug_1169:
  rx1377_fail:
    (rx1377_rep, rx1377_pos, $I10, $P10) = rx1377_cur."!mark_fail"(0)
    lt rx1377_pos, -1, rx1377_done
    eq rx1377_pos, -1, rx1377_fail
    jump $I10
  rx1377_done:
    rx1377_cur."!cursor_fail"()
    if_null rx1377_debug, debug_1170
    rx1377_cur."!cursor_debug"("FAIL", "infix:sym<**>")
  debug_1170:
    .return (rx1377_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<**>"  :nsentry("!PREFIX__infix:sym<**>") :subid("297_1303340952.947") :method
.annotate 'line', 10
    $P1379 = self."!PREFIX__!subrule"("O", "**")
    new $P1380, "ResizablePMCArray"
    push $P1380, $P1379
    .return ($P1380)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<+>"  :subid("298_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1384_tgt
    .local int rx1384_pos
    .local int rx1384_off
    .local int rx1384_eos
    .local int rx1384_rep
    .local pmc rx1384_cur
    .local pmc rx1384_debug
    (rx1384_cur, rx1384_pos, rx1384_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1384_cur
    .local pmc match
    .lex "$/", match
    length rx1384_eos, rx1384_tgt
    gt rx1384_pos, rx1384_eos, rx1384_done
    set rx1384_off, 0
    lt rx1384_pos, 2, rx1384_start
    sub rx1384_off, rx1384_pos, 1
    substr rx1384_tgt, rx1384_tgt, rx1384_off
  rx1384_start:
    eq $I10, 1, rx1384_restart
    if_null rx1384_debug, debug_1171
    rx1384_cur."!cursor_debug"("START", "prefix:sym<+>")
  debug_1171:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1388_done
    goto rxscan1388_scan
  rxscan1388_loop:
    (rx1384_pos) = rx1384_cur."from"()
    inc rx1384_pos
    rx1384_cur."!cursor_from"(rx1384_pos)
    ge rx1384_pos, rx1384_eos, rxscan1388_done
  rxscan1388_scan:
    set_addr $I10, rxscan1388_loop
    rx1384_cur."!mark_push"(0, rx1384_pos, $I10)
  rxscan1388_done:
.annotate 'line', 636
  # rx subcapture "sym"
    set_addr $I10, rxcap_1389_fail
    rx1384_cur."!mark_push"(0, rx1384_pos, $I10)
  # rx literal  "+"
    add $I11, rx1384_pos, 1
    gt $I11, rx1384_eos, rx1384_fail
    sub $I11, rx1384_pos, rx1384_off
    ord $I11, rx1384_tgt, $I11
    ne $I11, 43, rx1384_fail
    add rx1384_pos, 1
    set_addr $I10, rxcap_1389_fail
    ($I12, $I11) = rx1384_cur."!mark_peek"($I10)
    rx1384_cur."!cursor_pos"($I11)
    ($P10) = rx1384_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1384_pos, "")
    rx1384_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1389_done
  rxcap_1389_fail:
    goto rx1384_fail
  rxcap_1389_done:
  # rx subrule "O" subtype=capture negate=
    rx1384_cur."!cursor_pos"(rx1384_pos)
    $P10 = rx1384_cur."O"("%symbolic_unary, :pirop<set N*>")
    unless $P10, rx1384_fail
    rx1384_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1384_pos = $P10."pos"()
  # rx pass
    rx1384_cur."!cursor_pass"(rx1384_pos, "prefix:sym<+>")
    if_null rx1384_debug, debug_1172
    rx1384_cur."!cursor_debug"("PASS", "prefix:sym<+>", " at pos=", rx1384_pos)
  debug_1172:
    .return (rx1384_cur)
  rx1384_restart:
.annotate 'line', 10
    if_null rx1384_debug, debug_1173
    rx1384_cur."!cursor_debug"("NEXT", "prefix:sym<+>")
  debug_1173:
  rx1384_fail:
    (rx1384_rep, rx1384_pos, $I10, $P10) = rx1384_cur."!mark_fail"(0)
    lt rx1384_pos, -1, rx1384_done
    eq rx1384_pos, -1, rx1384_fail
    jump $I10
  rx1384_done:
    rx1384_cur."!cursor_fail"()
    if_null rx1384_debug, debug_1174
    rx1384_cur."!cursor_debug"("FAIL", "prefix:sym<+>")
  debug_1174:
    .return (rx1384_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<+>"  :nsentry("!PREFIX__prefix:sym<+>") :subid("299_1303340952.947") :method
.annotate 'line', 10
    $P1386 = self."!PREFIX__!subrule"("O", "+")
    new $P1387, "ResizablePMCArray"
    push $P1387, $P1386
    .return ($P1387)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<~>"  :subid("300_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1391_tgt
    .local int rx1391_pos
    .local int rx1391_off
    .local int rx1391_eos
    .local int rx1391_rep
    .local pmc rx1391_cur
    .local pmc rx1391_debug
    (rx1391_cur, rx1391_pos, rx1391_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1391_cur
    .local pmc match
    .lex "$/", match
    length rx1391_eos, rx1391_tgt
    gt rx1391_pos, rx1391_eos, rx1391_done
    set rx1391_off, 0
    lt rx1391_pos, 2, rx1391_start
    sub rx1391_off, rx1391_pos, 1
    substr rx1391_tgt, rx1391_tgt, rx1391_off
  rx1391_start:
    eq $I10, 1, rx1391_restart
    if_null rx1391_debug, debug_1175
    rx1391_cur."!cursor_debug"("START", "prefix:sym<~>")
  debug_1175:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1395_done
    goto rxscan1395_scan
  rxscan1395_loop:
    (rx1391_pos) = rx1391_cur."from"()
    inc rx1391_pos
    rx1391_cur."!cursor_from"(rx1391_pos)
    ge rx1391_pos, rx1391_eos, rxscan1395_done
  rxscan1395_scan:
    set_addr $I10, rxscan1395_loop
    rx1391_cur."!mark_push"(0, rx1391_pos, $I10)
  rxscan1395_done:
.annotate 'line', 637
  # rx subcapture "sym"
    set_addr $I10, rxcap_1396_fail
    rx1391_cur."!mark_push"(0, rx1391_pos, $I10)
  # rx literal  "~"
    add $I11, rx1391_pos, 1
    gt $I11, rx1391_eos, rx1391_fail
    sub $I11, rx1391_pos, rx1391_off
    ord $I11, rx1391_tgt, $I11
    ne $I11, 126, rx1391_fail
    add rx1391_pos, 1
    set_addr $I10, rxcap_1396_fail
    ($I12, $I11) = rx1391_cur."!mark_peek"($I10)
    rx1391_cur."!cursor_pos"($I11)
    ($P10) = rx1391_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1391_pos, "")
    rx1391_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1396_done
  rxcap_1396_fail:
    goto rx1391_fail
  rxcap_1396_done:
  # rx subrule "O" subtype=capture negate=
    rx1391_cur."!cursor_pos"(rx1391_pos)
    $P10 = rx1391_cur."O"("%symbolic_unary, :pirop<set S*>")
    unless $P10, rx1391_fail
    rx1391_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1391_pos = $P10."pos"()
  # rx pass
    rx1391_cur."!cursor_pass"(rx1391_pos, "prefix:sym<~>")
    if_null rx1391_debug, debug_1176
    rx1391_cur."!cursor_debug"("PASS", "prefix:sym<~>", " at pos=", rx1391_pos)
  debug_1176:
    .return (rx1391_cur)
  rx1391_restart:
.annotate 'line', 10
    if_null rx1391_debug, debug_1177
    rx1391_cur."!cursor_debug"("NEXT", "prefix:sym<~>")
  debug_1177:
  rx1391_fail:
    (rx1391_rep, rx1391_pos, $I10, $P10) = rx1391_cur."!mark_fail"(0)
    lt rx1391_pos, -1, rx1391_done
    eq rx1391_pos, -1, rx1391_fail
    jump $I10
  rx1391_done:
    rx1391_cur."!cursor_fail"()
    if_null rx1391_debug, debug_1178
    rx1391_cur."!cursor_debug"("FAIL", "prefix:sym<~>")
  debug_1178:
    .return (rx1391_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<~>"  :nsentry("!PREFIX__prefix:sym<~>") :subid("301_1303340952.947") :method
.annotate 'line', 10
    $P1393 = self."!PREFIX__!subrule"("O", "~")
    new $P1394, "ResizablePMCArray"
    push $P1394, $P1393
    .return ($P1394)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<->"  :subid("302_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1398_tgt
    .local int rx1398_pos
    .local int rx1398_off
    .local int rx1398_eos
    .local int rx1398_rep
    .local pmc rx1398_cur
    .local pmc rx1398_debug
    (rx1398_cur, rx1398_pos, rx1398_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1398_cur
    .local pmc match
    .lex "$/", match
    length rx1398_eos, rx1398_tgt
    gt rx1398_pos, rx1398_eos, rx1398_done
    set rx1398_off, 0
    lt rx1398_pos, 2, rx1398_start
    sub rx1398_off, rx1398_pos, 1
    substr rx1398_tgt, rx1398_tgt, rx1398_off
  rx1398_start:
    eq $I10, 1, rx1398_restart
    if_null rx1398_debug, debug_1179
    rx1398_cur."!cursor_debug"("START", "prefix:sym<->")
  debug_1179:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1401_done
    goto rxscan1401_scan
  rxscan1401_loop:
    (rx1398_pos) = rx1398_cur."from"()
    inc rx1398_pos
    rx1398_cur."!cursor_from"(rx1398_pos)
    ge rx1398_pos, rx1398_eos, rxscan1401_done
  rxscan1401_scan:
    set_addr $I10, rxscan1401_loop
    rx1398_cur."!mark_push"(0, rx1398_pos, $I10)
  rxscan1401_done:
.annotate 'line', 638
  # rx subcapture "sym"
    set_addr $I10, rxcap_1402_fail
    rx1398_cur."!mark_push"(0, rx1398_pos, $I10)
  # rx literal  "-"
    add $I11, rx1398_pos, 1
    gt $I11, rx1398_eos, rx1398_fail
    sub $I11, rx1398_pos, rx1398_off
    ord $I11, rx1398_tgt, $I11
    ne $I11, 45, rx1398_fail
    add rx1398_pos, 1
    set_addr $I10, rxcap_1402_fail
    ($I12, $I11) = rx1398_cur."!mark_peek"($I10)
    rx1398_cur."!cursor_pos"($I11)
    ($P10) = rx1398_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1398_pos, "")
    rx1398_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1402_done
  rxcap_1402_fail:
    goto rx1398_fail
  rxcap_1402_done:
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1398_pos, rx1398_off
    substr $S10, rx1398_tgt, $I10, 1
    index $I11, ">", $S10
    ge $I11, 0, rx1398_fail
  # rx subrule "number" subtype=zerowidth negate=1
    rx1398_cur."!cursor_pos"(rx1398_pos)
    $P10 = rx1398_cur."number"()
    if $P10, rx1398_fail
  # rx subrule "O" subtype=capture negate=
    rx1398_cur."!cursor_pos"(rx1398_pos)
    $P10 = rx1398_cur."O"("%symbolic_unary, :pirop<neg>")
    unless $P10, rx1398_fail
    rx1398_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1398_pos = $P10."pos"()
  # rx pass
    rx1398_cur."!cursor_pass"(rx1398_pos, "prefix:sym<->")
    if_null rx1398_debug, debug_1180
    rx1398_cur."!cursor_debug"("PASS", "prefix:sym<->", " at pos=", rx1398_pos)
  debug_1180:
    .return (rx1398_cur)
  rx1398_restart:
.annotate 'line', 10
    if_null rx1398_debug, debug_1181
    rx1398_cur."!cursor_debug"("NEXT", "prefix:sym<->")
  debug_1181:
  rx1398_fail:
    (rx1398_rep, rx1398_pos, $I10, $P10) = rx1398_cur."!mark_fail"(0)
    lt rx1398_pos, -1, rx1398_done
    eq rx1398_pos, -1, rx1398_fail
    jump $I10
  rx1398_done:
    rx1398_cur."!cursor_fail"()
    if_null rx1398_debug, debug_1182
    rx1398_cur."!cursor_debug"("FAIL", "prefix:sym<->")
  debug_1182:
    .return (rx1398_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<->"  :nsentry("!PREFIX__prefix:sym<->") :subid("303_1303340952.947") :method
.annotate 'line', 10
    new $P1400, "ResizablePMCArray"
    push $P1400, "-"
    .return ($P1400)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<?>"  :subid("304_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1404_tgt
    .local int rx1404_pos
    .local int rx1404_off
    .local int rx1404_eos
    .local int rx1404_rep
    .local pmc rx1404_cur
    .local pmc rx1404_debug
    (rx1404_cur, rx1404_pos, rx1404_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1404_cur
    .local pmc match
    .lex "$/", match
    length rx1404_eos, rx1404_tgt
    gt rx1404_pos, rx1404_eos, rx1404_done
    set rx1404_off, 0
    lt rx1404_pos, 2, rx1404_start
    sub rx1404_off, rx1404_pos, 1
    substr rx1404_tgt, rx1404_tgt, rx1404_off
  rx1404_start:
    eq $I10, 1, rx1404_restart
    if_null rx1404_debug, debug_1183
    rx1404_cur."!cursor_debug"("START", "prefix:sym<?>")
  debug_1183:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1408_done
    goto rxscan1408_scan
  rxscan1408_loop:
    (rx1404_pos) = rx1404_cur."from"()
    inc rx1404_pos
    rx1404_cur."!cursor_from"(rx1404_pos)
    ge rx1404_pos, rx1404_eos, rxscan1408_done
  rxscan1408_scan:
    set_addr $I10, rxscan1408_loop
    rx1404_cur."!mark_push"(0, rx1404_pos, $I10)
  rxscan1408_done:
.annotate 'line', 639
  # rx subcapture "sym"
    set_addr $I10, rxcap_1409_fail
    rx1404_cur."!mark_push"(0, rx1404_pos, $I10)
  # rx literal  "?"
    add $I11, rx1404_pos, 1
    gt $I11, rx1404_eos, rx1404_fail
    sub $I11, rx1404_pos, rx1404_off
    ord $I11, rx1404_tgt, $I11
    ne $I11, 63, rx1404_fail
    add rx1404_pos, 1
    set_addr $I10, rxcap_1409_fail
    ($I12, $I11) = rx1404_cur."!mark_peek"($I10)
    rx1404_cur."!cursor_pos"($I11)
    ($P10) = rx1404_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1404_pos, "")
    rx1404_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1409_done
  rxcap_1409_fail:
    goto rx1404_fail
  rxcap_1409_done:
  # rx subrule "O" subtype=capture negate=
    rx1404_cur."!cursor_pos"(rx1404_pos)
    $P10 = rx1404_cur."O"("%symbolic_unary, :pirop<istrue>")
    unless $P10, rx1404_fail
    rx1404_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1404_pos = $P10."pos"()
  # rx pass
    rx1404_cur."!cursor_pass"(rx1404_pos, "prefix:sym<?>")
    if_null rx1404_debug, debug_1184
    rx1404_cur."!cursor_debug"("PASS", "prefix:sym<?>", " at pos=", rx1404_pos)
  debug_1184:
    .return (rx1404_cur)
  rx1404_restart:
.annotate 'line', 10
    if_null rx1404_debug, debug_1185
    rx1404_cur."!cursor_debug"("NEXT", "prefix:sym<?>")
  debug_1185:
  rx1404_fail:
    (rx1404_rep, rx1404_pos, $I10, $P10) = rx1404_cur."!mark_fail"(0)
    lt rx1404_pos, -1, rx1404_done
    eq rx1404_pos, -1, rx1404_fail
    jump $I10
  rx1404_done:
    rx1404_cur."!cursor_fail"()
    if_null rx1404_debug, debug_1186
    rx1404_cur."!cursor_debug"("FAIL", "prefix:sym<?>")
  debug_1186:
    .return (rx1404_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<?>"  :nsentry("!PREFIX__prefix:sym<?>") :subid("305_1303340952.947") :method
.annotate 'line', 10
    $P1406 = self."!PREFIX__!subrule"("O", "?")
    new $P1407, "ResizablePMCArray"
    push $P1407, $P1406
    .return ($P1407)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<!>"  :subid("306_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1411_tgt
    .local int rx1411_pos
    .local int rx1411_off
    .local int rx1411_eos
    .local int rx1411_rep
    .local pmc rx1411_cur
    .local pmc rx1411_debug
    (rx1411_cur, rx1411_pos, rx1411_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1411_cur
    .local pmc match
    .lex "$/", match
    length rx1411_eos, rx1411_tgt
    gt rx1411_pos, rx1411_eos, rx1411_done
    set rx1411_off, 0
    lt rx1411_pos, 2, rx1411_start
    sub rx1411_off, rx1411_pos, 1
    substr rx1411_tgt, rx1411_tgt, rx1411_off
  rx1411_start:
    eq $I10, 1, rx1411_restart
    if_null rx1411_debug, debug_1187
    rx1411_cur."!cursor_debug"("START", "prefix:sym<!>")
  debug_1187:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1415_done
    goto rxscan1415_scan
  rxscan1415_loop:
    (rx1411_pos) = rx1411_cur."from"()
    inc rx1411_pos
    rx1411_cur."!cursor_from"(rx1411_pos)
    ge rx1411_pos, rx1411_eos, rxscan1415_done
  rxscan1415_scan:
    set_addr $I10, rxscan1415_loop
    rx1411_cur."!mark_push"(0, rx1411_pos, $I10)
  rxscan1415_done:
.annotate 'line', 640
  # rx subcapture "sym"
    set_addr $I10, rxcap_1416_fail
    rx1411_cur."!mark_push"(0, rx1411_pos, $I10)
  # rx literal  "!"
    add $I11, rx1411_pos, 1
    gt $I11, rx1411_eos, rx1411_fail
    sub $I11, rx1411_pos, rx1411_off
    ord $I11, rx1411_tgt, $I11
    ne $I11, 33, rx1411_fail
    add rx1411_pos, 1
    set_addr $I10, rxcap_1416_fail
    ($I12, $I11) = rx1411_cur."!mark_peek"($I10)
    rx1411_cur."!cursor_pos"($I11)
    ($P10) = rx1411_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1411_pos, "")
    rx1411_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1416_done
  rxcap_1416_fail:
    goto rx1411_fail
  rxcap_1416_done:
  # rx subrule "O" subtype=capture negate=
    rx1411_cur."!cursor_pos"(rx1411_pos)
    $P10 = rx1411_cur."O"("%symbolic_unary, :pirop<isfalse>")
    unless $P10, rx1411_fail
    rx1411_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1411_pos = $P10."pos"()
  # rx pass
    rx1411_cur."!cursor_pass"(rx1411_pos, "prefix:sym<!>")
    if_null rx1411_debug, debug_1188
    rx1411_cur."!cursor_debug"("PASS", "prefix:sym<!>", " at pos=", rx1411_pos)
  debug_1188:
    .return (rx1411_cur)
  rx1411_restart:
.annotate 'line', 10
    if_null rx1411_debug, debug_1189
    rx1411_cur."!cursor_debug"("NEXT", "prefix:sym<!>")
  debug_1189:
  rx1411_fail:
    (rx1411_rep, rx1411_pos, $I10, $P10) = rx1411_cur."!mark_fail"(0)
    lt rx1411_pos, -1, rx1411_done
    eq rx1411_pos, -1, rx1411_fail
    jump $I10
  rx1411_done:
    rx1411_cur."!cursor_fail"()
    if_null rx1411_debug, debug_1190
    rx1411_cur."!cursor_debug"("FAIL", "prefix:sym<!>")
  debug_1190:
    .return (rx1411_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<!>"  :nsentry("!PREFIX__prefix:sym<!>") :subid("307_1303340952.947") :method
.annotate 'line', 10
    $P1413 = self."!PREFIX__!subrule"("O", "!")
    new $P1414, "ResizablePMCArray"
    push $P1414, $P1413
    .return ($P1414)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<|>"  :subid("308_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1418_tgt
    .local int rx1418_pos
    .local int rx1418_off
    .local int rx1418_eos
    .local int rx1418_rep
    .local pmc rx1418_cur
    .local pmc rx1418_debug
    (rx1418_cur, rx1418_pos, rx1418_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1418_cur
    .local pmc match
    .lex "$/", match
    length rx1418_eos, rx1418_tgt
    gt rx1418_pos, rx1418_eos, rx1418_done
    set rx1418_off, 0
    lt rx1418_pos, 2, rx1418_start
    sub rx1418_off, rx1418_pos, 1
    substr rx1418_tgt, rx1418_tgt, rx1418_off
  rx1418_start:
    eq $I10, 1, rx1418_restart
    if_null rx1418_debug, debug_1191
    rx1418_cur."!cursor_debug"("START", "prefix:sym<|>")
  debug_1191:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1422_done
    goto rxscan1422_scan
  rxscan1422_loop:
    (rx1418_pos) = rx1418_cur."from"()
    inc rx1418_pos
    rx1418_cur."!cursor_from"(rx1418_pos)
    ge rx1418_pos, rx1418_eos, rxscan1422_done
  rxscan1422_scan:
    set_addr $I10, rxscan1422_loop
    rx1418_cur."!mark_push"(0, rx1418_pos, $I10)
  rxscan1422_done:
.annotate 'line', 641
  # rx subcapture "sym"
    set_addr $I10, rxcap_1423_fail
    rx1418_cur."!mark_push"(0, rx1418_pos, $I10)
  # rx literal  "|"
    add $I11, rx1418_pos, 1
    gt $I11, rx1418_eos, rx1418_fail
    sub $I11, rx1418_pos, rx1418_off
    ord $I11, rx1418_tgt, $I11
    ne $I11, 124, rx1418_fail
    add rx1418_pos, 1
    set_addr $I10, rxcap_1423_fail
    ($I12, $I11) = rx1418_cur."!mark_peek"($I10)
    rx1418_cur."!cursor_pos"($I11)
    ($P10) = rx1418_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1418_pos, "")
    rx1418_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1423_done
  rxcap_1423_fail:
    goto rx1418_fail
  rxcap_1423_done:
  # rx subrule "O" subtype=capture negate=
    rx1418_cur."!cursor_pos"(rx1418_pos)
    $P10 = rx1418_cur."O"("%symbolic_unary")
    unless $P10, rx1418_fail
    rx1418_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1418_pos = $P10."pos"()
  # rx pass
    rx1418_cur."!cursor_pass"(rx1418_pos, "prefix:sym<|>")
    if_null rx1418_debug, debug_1192
    rx1418_cur."!cursor_debug"("PASS", "prefix:sym<|>", " at pos=", rx1418_pos)
  debug_1192:
    .return (rx1418_cur)
  rx1418_restart:
.annotate 'line', 10
    if_null rx1418_debug, debug_1193
    rx1418_cur."!cursor_debug"("NEXT", "prefix:sym<|>")
  debug_1193:
  rx1418_fail:
    (rx1418_rep, rx1418_pos, $I10, $P10) = rx1418_cur."!mark_fail"(0)
    lt rx1418_pos, -1, rx1418_done
    eq rx1418_pos, -1, rx1418_fail
    jump $I10
  rx1418_done:
    rx1418_cur."!cursor_fail"()
    if_null rx1418_debug, debug_1194
    rx1418_cur."!cursor_debug"("FAIL", "prefix:sym<|>")
  debug_1194:
    .return (rx1418_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<|>"  :nsentry("!PREFIX__prefix:sym<|>") :subid("309_1303340952.947") :method
.annotate 'line', 10
    $P1420 = self."!PREFIX__!subrule"("O", "|")
    new $P1421, "ResizablePMCArray"
    push $P1421, $P1420
    .return ($P1421)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<*>"  :subid("310_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1425_tgt
    .local int rx1425_pos
    .local int rx1425_off
    .local int rx1425_eos
    .local int rx1425_rep
    .local pmc rx1425_cur
    .local pmc rx1425_debug
    (rx1425_cur, rx1425_pos, rx1425_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1425_cur
    .local pmc match
    .lex "$/", match
    length rx1425_eos, rx1425_tgt
    gt rx1425_pos, rx1425_eos, rx1425_done
    set rx1425_off, 0
    lt rx1425_pos, 2, rx1425_start
    sub rx1425_off, rx1425_pos, 1
    substr rx1425_tgt, rx1425_tgt, rx1425_off
  rx1425_start:
    eq $I10, 1, rx1425_restart
    if_null rx1425_debug, debug_1195
    rx1425_cur."!cursor_debug"("START", "infix:sym<*>")
  debug_1195:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1429_done
    goto rxscan1429_scan
  rxscan1429_loop:
    (rx1425_pos) = rx1425_cur."from"()
    inc rx1425_pos
    rx1425_cur."!cursor_from"(rx1425_pos)
    ge rx1425_pos, rx1425_eos, rxscan1429_done
  rxscan1429_scan:
    set_addr $I10, rxscan1429_loop
    rx1425_cur."!mark_push"(0, rx1425_pos, $I10)
  rxscan1429_done:
.annotate 'line', 643
  # rx subcapture "sym"
    set_addr $I10, rxcap_1430_fail
    rx1425_cur."!mark_push"(0, rx1425_pos, $I10)
  # rx literal  "*"
    add $I11, rx1425_pos, 1
    gt $I11, rx1425_eos, rx1425_fail
    sub $I11, rx1425_pos, rx1425_off
    ord $I11, rx1425_tgt, $I11
    ne $I11, 42, rx1425_fail
    add rx1425_pos, 1
    set_addr $I10, rxcap_1430_fail
    ($I12, $I11) = rx1425_cur."!mark_peek"($I10)
    rx1425_cur."!cursor_pos"($I11)
    ($P10) = rx1425_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1425_pos, "")
    rx1425_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1430_done
  rxcap_1430_fail:
    goto rx1425_fail
  rxcap_1430_done:
  # rx subrule "O" subtype=capture negate=
    rx1425_cur."!cursor_pos"(rx1425_pos)
    $P10 = rx1425_cur."O"("%multiplicative, :pirop<mul>")
    unless $P10, rx1425_fail
    rx1425_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1425_pos = $P10."pos"()
  # rx pass
    rx1425_cur."!cursor_pass"(rx1425_pos, "infix:sym<*>")
    if_null rx1425_debug, debug_1196
    rx1425_cur."!cursor_debug"("PASS", "infix:sym<*>", " at pos=", rx1425_pos)
  debug_1196:
    .return (rx1425_cur)
  rx1425_restart:
.annotate 'line', 10
    if_null rx1425_debug, debug_1197
    rx1425_cur."!cursor_debug"("NEXT", "infix:sym<*>")
  debug_1197:
  rx1425_fail:
    (rx1425_rep, rx1425_pos, $I10, $P10) = rx1425_cur."!mark_fail"(0)
    lt rx1425_pos, -1, rx1425_done
    eq rx1425_pos, -1, rx1425_fail
    jump $I10
  rx1425_done:
    rx1425_cur."!cursor_fail"()
    if_null rx1425_debug, debug_1198
    rx1425_cur."!cursor_debug"("FAIL", "infix:sym<*>")
  debug_1198:
    .return (rx1425_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<*>"  :nsentry("!PREFIX__infix:sym<*>") :subid("311_1303340952.947") :method
.annotate 'line', 10
    $P1427 = self."!PREFIX__!subrule"("O", "*")
    new $P1428, "ResizablePMCArray"
    push $P1428, $P1427
    .return ($P1428)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym</>"  :subid("312_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1432_tgt
    .local int rx1432_pos
    .local int rx1432_off
    .local int rx1432_eos
    .local int rx1432_rep
    .local pmc rx1432_cur
    .local pmc rx1432_debug
    (rx1432_cur, rx1432_pos, rx1432_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1432_cur
    .local pmc match
    .lex "$/", match
    length rx1432_eos, rx1432_tgt
    gt rx1432_pos, rx1432_eos, rx1432_done
    set rx1432_off, 0
    lt rx1432_pos, 2, rx1432_start
    sub rx1432_off, rx1432_pos, 1
    substr rx1432_tgt, rx1432_tgt, rx1432_off
  rx1432_start:
    eq $I10, 1, rx1432_restart
    if_null rx1432_debug, debug_1199
    rx1432_cur."!cursor_debug"("START", "infix:sym</>")
  debug_1199:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1436_done
    goto rxscan1436_scan
  rxscan1436_loop:
    (rx1432_pos) = rx1432_cur."from"()
    inc rx1432_pos
    rx1432_cur."!cursor_from"(rx1432_pos)
    ge rx1432_pos, rx1432_eos, rxscan1436_done
  rxscan1436_scan:
    set_addr $I10, rxscan1436_loop
    rx1432_cur."!mark_push"(0, rx1432_pos, $I10)
  rxscan1436_done:
.annotate 'line', 644
  # rx subcapture "sym"
    set_addr $I10, rxcap_1437_fail
    rx1432_cur."!mark_push"(0, rx1432_pos, $I10)
  # rx literal  "/"
    add $I11, rx1432_pos, 1
    gt $I11, rx1432_eos, rx1432_fail
    sub $I11, rx1432_pos, rx1432_off
    ord $I11, rx1432_tgt, $I11
    ne $I11, 47, rx1432_fail
    add rx1432_pos, 1
    set_addr $I10, rxcap_1437_fail
    ($I12, $I11) = rx1432_cur."!mark_peek"($I10)
    rx1432_cur."!cursor_pos"($I11)
    ($P10) = rx1432_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1432_pos, "")
    rx1432_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1437_done
  rxcap_1437_fail:
    goto rx1432_fail
  rxcap_1437_done:
  # rx subrule "O" subtype=capture negate=
    rx1432_cur."!cursor_pos"(rx1432_pos)
    $P10 = rx1432_cur."O"("%multiplicative, :pirop<div>")
    unless $P10, rx1432_fail
    rx1432_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1432_pos = $P10."pos"()
  # rx pass
    rx1432_cur."!cursor_pass"(rx1432_pos, "infix:sym</>")
    if_null rx1432_debug, debug_1200
    rx1432_cur."!cursor_debug"("PASS", "infix:sym</>", " at pos=", rx1432_pos)
  debug_1200:
    .return (rx1432_cur)
  rx1432_restart:
.annotate 'line', 10
    if_null rx1432_debug, debug_1201
    rx1432_cur."!cursor_debug"("NEXT", "infix:sym</>")
  debug_1201:
  rx1432_fail:
    (rx1432_rep, rx1432_pos, $I10, $P10) = rx1432_cur."!mark_fail"(0)
    lt rx1432_pos, -1, rx1432_done
    eq rx1432_pos, -1, rx1432_fail
    jump $I10
  rx1432_done:
    rx1432_cur."!cursor_fail"()
    if_null rx1432_debug, debug_1202
    rx1432_cur."!cursor_debug"("FAIL", "infix:sym</>")
  debug_1202:
    .return (rx1432_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym</>"  :nsentry("!PREFIX__infix:sym</>") :subid("313_1303340952.947") :method
.annotate 'line', 10
    $P1434 = self."!PREFIX__!subrule"("O", "/")
    new $P1435, "ResizablePMCArray"
    push $P1435, $P1434
    .return ($P1435)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<%>"  :subid("314_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1439_tgt
    .local int rx1439_pos
    .local int rx1439_off
    .local int rx1439_eos
    .local int rx1439_rep
    .local pmc rx1439_cur
    .local pmc rx1439_debug
    (rx1439_cur, rx1439_pos, rx1439_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1439_cur
    .local pmc match
    .lex "$/", match
    length rx1439_eos, rx1439_tgt
    gt rx1439_pos, rx1439_eos, rx1439_done
    set rx1439_off, 0
    lt rx1439_pos, 2, rx1439_start
    sub rx1439_off, rx1439_pos, 1
    substr rx1439_tgt, rx1439_tgt, rx1439_off
  rx1439_start:
    eq $I10, 1, rx1439_restart
    if_null rx1439_debug, debug_1203
    rx1439_cur."!cursor_debug"("START", "infix:sym<%>")
  debug_1203:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1443_done
    goto rxscan1443_scan
  rxscan1443_loop:
    (rx1439_pos) = rx1439_cur."from"()
    inc rx1439_pos
    rx1439_cur."!cursor_from"(rx1439_pos)
    ge rx1439_pos, rx1439_eos, rxscan1443_done
  rxscan1443_scan:
    set_addr $I10, rxscan1443_loop
    rx1439_cur."!mark_push"(0, rx1439_pos, $I10)
  rxscan1443_done:
.annotate 'line', 645
  # rx subcapture "sym"
    set_addr $I10, rxcap_1444_fail
    rx1439_cur."!mark_push"(0, rx1439_pos, $I10)
  # rx literal  "%"
    add $I11, rx1439_pos, 1
    gt $I11, rx1439_eos, rx1439_fail
    sub $I11, rx1439_pos, rx1439_off
    ord $I11, rx1439_tgt, $I11
    ne $I11, 37, rx1439_fail
    add rx1439_pos, 1
    set_addr $I10, rxcap_1444_fail
    ($I12, $I11) = rx1439_cur."!mark_peek"($I10)
    rx1439_cur."!cursor_pos"($I11)
    ($P10) = rx1439_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1439_pos, "")
    rx1439_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1444_done
  rxcap_1444_fail:
    goto rx1439_fail
  rxcap_1444_done:
  # rx subrule "O" subtype=capture negate=
    rx1439_cur."!cursor_pos"(rx1439_pos)
    $P10 = rx1439_cur."O"("%multiplicative, :pirop<mod>")
    unless $P10, rx1439_fail
    rx1439_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1439_pos = $P10."pos"()
  # rx pass
    rx1439_cur."!cursor_pass"(rx1439_pos, "infix:sym<%>")
    if_null rx1439_debug, debug_1204
    rx1439_cur."!cursor_debug"("PASS", "infix:sym<%>", " at pos=", rx1439_pos)
  debug_1204:
    .return (rx1439_cur)
  rx1439_restart:
.annotate 'line', 10
    if_null rx1439_debug, debug_1205
    rx1439_cur."!cursor_debug"("NEXT", "infix:sym<%>")
  debug_1205:
  rx1439_fail:
    (rx1439_rep, rx1439_pos, $I10, $P10) = rx1439_cur."!mark_fail"(0)
    lt rx1439_pos, -1, rx1439_done
    eq rx1439_pos, -1, rx1439_fail
    jump $I10
  rx1439_done:
    rx1439_cur."!cursor_fail"()
    if_null rx1439_debug, debug_1206
    rx1439_cur."!cursor_debug"("FAIL", "infix:sym<%>")
  debug_1206:
    .return (rx1439_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<%>"  :nsentry("!PREFIX__infix:sym<%>") :subid("315_1303340952.947") :method
.annotate 'line', 10
    $P1441 = self."!PREFIX__!subrule"("O", "%")
    new $P1442, "ResizablePMCArray"
    push $P1442, $P1441
    .return ($P1442)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+&>"  :subid("316_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1446_tgt
    .local int rx1446_pos
    .local int rx1446_off
    .local int rx1446_eos
    .local int rx1446_rep
    .local pmc rx1446_cur
    .local pmc rx1446_debug
    (rx1446_cur, rx1446_pos, rx1446_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1446_cur
    .local pmc match
    .lex "$/", match
    length rx1446_eos, rx1446_tgt
    gt rx1446_pos, rx1446_eos, rx1446_done
    set rx1446_off, 0
    lt rx1446_pos, 2, rx1446_start
    sub rx1446_off, rx1446_pos, 1
    substr rx1446_tgt, rx1446_tgt, rx1446_off
  rx1446_start:
    eq $I10, 1, rx1446_restart
    if_null rx1446_debug, debug_1207
    rx1446_cur."!cursor_debug"("START", "infix:sym<+&>")
  debug_1207:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1450_done
    goto rxscan1450_scan
  rxscan1450_loop:
    (rx1446_pos) = rx1446_cur."from"()
    inc rx1446_pos
    rx1446_cur."!cursor_from"(rx1446_pos)
    ge rx1446_pos, rx1446_eos, rxscan1450_done
  rxscan1450_scan:
    set_addr $I10, rxscan1450_loop
    rx1446_cur."!mark_push"(0, rx1446_pos, $I10)
  rxscan1450_done:
.annotate 'line', 646
  # rx subcapture "sym"
    set_addr $I10, rxcap_1451_fail
    rx1446_cur."!mark_push"(0, rx1446_pos, $I10)
  # rx literal  "+&"
    add $I11, rx1446_pos, 2
    gt $I11, rx1446_eos, rx1446_fail
    sub $I11, rx1446_pos, rx1446_off
    substr $S10, rx1446_tgt, $I11, 2
    ne $S10, "+&", rx1446_fail
    add rx1446_pos, 2
    set_addr $I10, rxcap_1451_fail
    ($I12, $I11) = rx1446_cur."!mark_peek"($I10)
    rx1446_cur."!cursor_pos"($I11)
    ($P10) = rx1446_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1446_pos, "")
    rx1446_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1451_done
  rxcap_1451_fail:
    goto rx1446_fail
  rxcap_1451_done:
  # rx subrule "O" subtype=capture negate=
    rx1446_cur."!cursor_pos"(rx1446_pos)
    $P10 = rx1446_cur."O"("%multiplicative, :pirop<band III>")
    unless $P10, rx1446_fail
    rx1446_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1446_pos = $P10."pos"()
  # rx pass
    rx1446_cur."!cursor_pass"(rx1446_pos, "infix:sym<+&>")
    if_null rx1446_debug, debug_1208
    rx1446_cur."!cursor_debug"("PASS", "infix:sym<+&>", " at pos=", rx1446_pos)
  debug_1208:
    .return (rx1446_cur)
  rx1446_restart:
.annotate 'line', 10
    if_null rx1446_debug, debug_1209
    rx1446_cur."!cursor_debug"("NEXT", "infix:sym<+&>")
  debug_1209:
  rx1446_fail:
    (rx1446_rep, rx1446_pos, $I10, $P10) = rx1446_cur."!mark_fail"(0)
    lt rx1446_pos, -1, rx1446_done
    eq rx1446_pos, -1, rx1446_fail
    jump $I10
  rx1446_done:
    rx1446_cur."!cursor_fail"()
    if_null rx1446_debug, debug_1210
    rx1446_cur."!cursor_debug"("FAIL", "infix:sym<+&>")
  debug_1210:
    .return (rx1446_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+&>"  :nsentry("!PREFIX__infix:sym<+&>") :subid("317_1303340952.947") :method
.annotate 'line', 10
    $P1448 = self."!PREFIX__!subrule"("O", "+&")
    new $P1449, "ResizablePMCArray"
    push $P1449, $P1448
    .return ($P1449)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+>"  :subid("318_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1453_tgt
    .local int rx1453_pos
    .local int rx1453_off
    .local int rx1453_eos
    .local int rx1453_rep
    .local pmc rx1453_cur
    .local pmc rx1453_debug
    (rx1453_cur, rx1453_pos, rx1453_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1453_cur
    .local pmc match
    .lex "$/", match
    length rx1453_eos, rx1453_tgt
    gt rx1453_pos, rx1453_eos, rx1453_done
    set rx1453_off, 0
    lt rx1453_pos, 2, rx1453_start
    sub rx1453_off, rx1453_pos, 1
    substr rx1453_tgt, rx1453_tgt, rx1453_off
  rx1453_start:
    eq $I10, 1, rx1453_restart
    if_null rx1453_debug, debug_1211
    rx1453_cur."!cursor_debug"("START", "infix:sym<+>")
  debug_1211:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1457_done
    goto rxscan1457_scan
  rxscan1457_loop:
    (rx1453_pos) = rx1453_cur."from"()
    inc rx1453_pos
    rx1453_cur."!cursor_from"(rx1453_pos)
    ge rx1453_pos, rx1453_eos, rxscan1457_done
  rxscan1457_scan:
    set_addr $I10, rxscan1457_loop
    rx1453_cur."!mark_push"(0, rx1453_pos, $I10)
  rxscan1457_done:
.annotate 'line', 648
  # rx subcapture "sym"
    set_addr $I10, rxcap_1458_fail
    rx1453_cur."!mark_push"(0, rx1453_pos, $I10)
  # rx literal  "+"
    add $I11, rx1453_pos, 1
    gt $I11, rx1453_eos, rx1453_fail
    sub $I11, rx1453_pos, rx1453_off
    ord $I11, rx1453_tgt, $I11
    ne $I11, 43, rx1453_fail
    add rx1453_pos, 1
    set_addr $I10, rxcap_1458_fail
    ($I12, $I11) = rx1453_cur."!mark_peek"($I10)
    rx1453_cur."!cursor_pos"($I11)
    ($P10) = rx1453_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1453_pos, "")
    rx1453_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1458_done
  rxcap_1458_fail:
    goto rx1453_fail
  rxcap_1458_done:
  # rx subrule "O" subtype=capture negate=
    rx1453_cur."!cursor_pos"(rx1453_pos)
    $P10 = rx1453_cur."O"("%additive, :pirop<add>")
    unless $P10, rx1453_fail
    rx1453_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1453_pos = $P10."pos"()
  # rx pass
    rx1453_cur."!cursor_pass"(rx1453_pos, "infix:sym<+>")
    if_null rx1453_debug, debug_1212
    rx1453_cur."!cursor_debug"("PASS", "infix:sym<+>", " at pos=", rx1453_pos)
  debug_1212:
    .return (rx1453_cur)
  rx1453_restart:
.annotate 'line', 10
    if_null rx1453_debug, debug_1213
    rx1453_cur."!cursor_debug"("NEXT", "infix:sym<+>")
  debug_1213:
  rx1453_fail:
    (rx1453_rep, rx1453_pos, $I10, $P10) = rx1453_cur."!mark_fail"(0)
    lt rx1453_pos, -1, rx1453_done
    eq rx1453_pos, -1, rx1453_fail
    jump $I10
  rx1453_done:
    rx1453_cur."!cursor_fail"()
    if_null rx1453_debug, debug_1214
    rx1453_cur."!cursor_debug"("FAIL", "infix:sym<+>")
  debug_1214:
    .return (rx1453_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+>"  :nsentry("!PREFIX__infix:sym<+>") :subid("319_1303340952.947") :method
.annotate 'line', 10
    $P1455 = self."!PREFIX__!subrule"("O", "+")
    new $P1456, "ResizablePMCArray"
    push $P1456, $P1455
    .return ($P1456)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<->"  :subid("320_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1460_tgt
    .local int rx1460_pos
    .local int rx1460_off
    .local int rx1460_eos
    .local int rx1460_rep
    .local pmc rx1460_cur
    .local pmc rx1460_debug
    (rx1460_cur, rx1460_pos, rx1460_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1460_cur
    .local pmc match
    .lex "$/", match
    length rx1460_eos, rx1460_tgt
    gt rx1460_pos, rx1460_eos, rx1460_done
    set rx1460_off, 0
    lt rx1460_pos, 2, rx1460_start
    sub rx1460_off, rx1460_pos, 1
    substr rx1460_tgt, rx1460_tgt, rx1460_off
  rx1460_start:
    eq $I10, 1, rx1460_restart
    if_null rx1460_debug, debug_1215
    rx1460_cur."!cursor_debug"("START", "infix:sym<->")
  debug_1215:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1464_done
    goto rxscan1464_scan
  rxscan1464_loop:
    (rx1460_pos) = rx1460_cur."from"()
    inc rx1460_pos
    rx1460_cur."!cursor_from"(rx1460_pos)
    ge rx1460_pos, rx1460_eos, rxscan1464_done
  rxscan1464_scan:
    set_addr $I10, rxscan1464_loop
    rx1460_cur."!mark_push"(0, rx1460_pos, $I10)
  rxscan1464_done:
.annotate 'line', 649
  # rx subcapture "sym"
    set_addr $I10, rxcap_1465_fail
    rx1460_cur."!mark_push"(0, rx1460_pos, $I10)
  # rx literal  "-"
    add $I11, rx1460_pos, 1
    gt $I11, rx1460_eos, rx1460_fail
    sub $I11, rx1460_pos, rx1460_off
    ord $I11, rx1460_tgt, $I11
    ne $I11, 45, rx1460_fail
    add rx1460_pos, 1
    set_addr $I10, rxcap_1465_fail
    ($I12, $I11) = rx1460_cur."!mark_peek"($I10)
    rx1460_cur."!cursor_pos"($I11)
    ($P10) = rx1460_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1460_pos, "")
    rx1460_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1465_done
  rxcap_1465_fail:
    goto rx1460_fail
  rxcap_1465_done:
  # rx subrule "O" subtype=capture negate=
    rx1460_cur."!cursor_pos"(rx1460_pos)
    $P10 = rx1460_cur."O"("%additive, :pirop<sub>")
    unless $P10, rx1460_fail
    rx1460_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1460_pos = $P10."pos"()
  # rx pass
    rx1460_cur."!cursor_pass"(rx1460_pos, "infix:sym<->")
    if_null rx1460_debug, debug_1216
    rx1460_cur."!cursor_debug"("PASS", "infix:sym<->", " at pos=", rx1460_pos)
  debug_1216:
    .return (rx1460_cur)
  rx1460_restart:
.annotate 'line', 10
    if_null rx1460_debug, debug_1217
    rx1460_cur."!cursor_debug"("NEXT", "infix:sym<->")
  debug_1217:
  rx1460_fail:
    (rx1460_rep, rx1460_pos, $I10, $P10) = rx1460_cur."!mark_fail"(0)
    lt rx1460_pos, -1, rx1460_done
    eq rx1460_pos, -1, rx1460_fail
    jump $I10
  rx1460_done:
    rx1460_cur."!cursor_fail"()
    if_null rx1460_debug, debug_1218
    rx1460_cur."!cursor_debug"("FAIL", "infix:sym<->")
  debug_1218:
    .return (rx1460_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<->"  :nsentry("!PREFIX__infix:sym<->") :subid("321_1303340952.947") :method
.annotate 'line', 10
    $P1462 = self."!PREFIX__!subrule"("O", "-")
    new $P1463, "ResizablePMCArray"
    push $P1463, $P1462
    .return ($P1463)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+|>"  :subid("322_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1467_tgt
    .local int rx1467_pos
    .local int rx1467_off
    .local int rx1467_eos
    .local int rx1467_rep
    .local pmc rx1467_cur
    .local pmc rx1467_debug
    (rx1467_cur, rx1467_pos, rx1467_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1467_cur
    .local pmc match
    .lex "$/", match
    length rx1467_eos, rx1467_tgt
    gt rx1467_pos, rx1467_eos, rx1467_done
    set rx1467_off, 0
    lt rx1467_pos, 2, rx1467_start
    sub rx1467_off, rx1467_pos, 1
    substr rx1467_tgt, rx1467_tgt, rx1467_off
  rx1467_start:
    eq $I10, 1, rx1467_restart
    if_null rx1467_debug, debug_1219
    rx1467_cur."!cursor_debug"("START", "infix:sym<+|>")
  debug_1219:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1471_done
    goto rxscan1471_scan
  rxscan1471_loop:
    (rx1467_pos) = rx1467_cur."from"()
    inc rx1467_pos
    rx1467_cur."!cursor_from"(rx1467_pos)
    ge rx1467_pos, rx1467_eos, rxscan1471_done
  rxscan1471_scan:
    set_addr $I10, rxscan1471_loop
    rx1467_cur."!mark_push"(0, rx1467_pos, $I10)
  rxscan1471_done:
.annotate 'line', 650
  # rx subcapture "sym"
    set_addr $I10, rxcap_1472_fail
    rx1467_cur."!mark_push"(0, rx1467_pos, $I10)
  # rx literal  "+|"
    add $I11, rx1467_pos, 2
    gt $I11, rx1467_eos, rx1467_fail
    sub $I11, rx1467_pos, rx1467_off
    substr $S10, rx1467_tgt, $I11, 2
    ne $S10, "+|", rx1467_fail
    add rx1467_pos, 2
    set_addr $I10, rxcap_1472_fail
    ($I12, $I11) = rx1467_cur."!mark_peek"($I10)
    rx1467_cur."!cursor_pos"($I11)
    ($P10) = rx1467_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1467_pos, "")
    rx1467_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1472_done
  rxcap_1472_fail:
    goto rx1467_fail
  rxcap_1472_done:
  # rx subrule "O" subtype=capture negate=
    rx1467_cur."!cursor_pos"(rx1467_pos)
    $P10 = rx1467_cur."O"("%additive, :pirop<bor III>")
    unless $P10, rx1467_fail
    rx1467_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1467_pos = $P10."pos"()
  # rx pass
    rx1467_cur."!cursor_pass"(rx1467_pos, "infix:sym<+|>")
    if_null rx1467_debug, debug_1220
    rx1467_cur."!cursor_debug"("PASS", "infix:sym<+|>", " at pos=", rx1467_pos)
  debug_1220:
    .return (rx1467_cur)
  rx1467_restart:
.annotate 'line', 10
    if_null rx1467_debug, debug_1221
    rx1467_cur."!cursor_debug"("NEXT", "infix:sym<+|>")
  debug_1221:
  rx1467_fail:
    (rx1467_rep, rx1467_pos, $I10, $P10) = rx1467_cur."!mark_fail"(0)
    lt rx1467_pos, -1, rx1467_done
    eq rx1467_pos, -1, rx1467_fail
    jump $I10
  rx1467_done:
    rx1467_cur."!cursor_fail"()
    if_null rx1467_debug, debug_1222
    rx1467_cur."!cursor_debug"("FAIL", "infix:sym<+|>")
  debug_1222:
    .return (rx1467_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+|>"  :nsentry("!PREFIX__infix:sym<+|>") :subid("323_1303340952.947") :method
.annotate 'line', 10
    $P1469 = self."!PREFIX__!subrule"("O", "+|")
    new $P1470, "ResizablePMCArray"
    push $P1470, $P1469
    .return ($P1470)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+^>"  :subid("324_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1474_tgt
    .local int rx1474_pos
    .local int rx1474_off
    .local int rx1474_eos
    .local int rx1474_rep
    .local pmc rx1474_cur
    .local pmc rx1474_debug
    (rx1474_cur, rx1474_pos, rx1474_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1474_cur
    .local pmc match
    .lex "$/", match
    length rx1474_eos, rx1474_tgt
    gt rx1474_pos, rx1474_eos, rx1474_done
    set rx1474_off, 0
    lt rx1474_pos, 2, rx1474_start
    sub rx1474_off, rx1474_pos, 1
    substr rx1474_tgt, rx1474_tgt, rx1474_off
  rx1474_start:
    eq $I10, 1, rx1474_restart
    if_null rx1474_debug, debug_1223
    rx1474_cur."!cursor_debug"("START", "infix:sym<+^>")
  debug_1223:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1478_done
    goto rxscan1478_scan
  rxscan1478_loop:
    (rx1474_pos) = rx1474_cur."from"()
    inc rx1474_pos
    rx1474_cur."!cursor_from"(rx1474_pos)
    ge rx1474_pos, rx1474_eos, rxscan1478_done
  rxscan1478_scan:
    set_addr $I10, rxscan1478_loop
    rx1474_cur."!mark_push"(0, rx1474_pos, $I10)
  rxscan1478_done:
.annotate 'line', 651
  # rx subcapture "sym"
    set_addr $I10, rxcap_1479_fail
    rx1474_cur."!mark_push"(0, rx1474_pos, $I10)
  # rx literal  "+^"
    add $I11, rx1474_pos, 2
    gt $I11, rx1474_eos, rx1474_fail
    sub $I11, rx1474_pos, rx1474_off
    substr $S10, rx1474_tgt, $I11, 2
    ne $S10, "+^", rx1474_fail
    add rx1474_pos, 2
    set_addr $I10, rxcap_1479_fail
    ($I12, $I11) = rx1474_cur."!mark_peek"($I10)
    rx1474_cur."!cursor_pos"($I11)
    ($P10) = rx1474_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1474_pos, "")
    rx1474_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1479_done
  rxcap_1479_fail:
    goto rx1474_fail
  rxcap_1479_done:
  # rx subrule "O" subtype=capture negate=
    rx1474_cur."!cursor_pos"(rx1474_pos)
    $P10 = rx1474_cur."O"("%additive, :pirop<bxor III>")
    unless $P10, rx1474_fail
    rx1474_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1474_pos = $P10."pos"()
  # rx pass
    rx1474_cur."!cursor_pass"(rx1474_pos, "infix:sym<+^>")
    if_null rx1474_debug, debug_1224
    rx1474_cur."!cursor_debug"("PASS", "infix:sym<+^>", " at pos=", rx1474_pos)
  debug_1224:
    .return (rx1474_cur)
  rx1474_restart:
.annotate 'line', 10
    if_null rx1474_debug, debug_1225
    rx1474_cur."!cursor_debug"("NEXT", "infix:sym<+^>")
  debug_1225:
  rx1474_fail:
    (rx1474_rep, rx1474_pos, $I10, $P10) = rx1474_cur."!mark_fail"(0)
    lt rx1474_pos, -1, rx1474_done
    eq rx1474_pos, -1, rx1474_fail
    jump $I10
  rx1474_done:
    rx1474_cur."!cursor_fail"()
    if_null rx1474_debug, debug_1226
    rx1474_cur."!cursor_debug"("FAIL", "infix:sym<+^>")
  debug_1226:
    .return (rx1474_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+^>"  :nsentry("!PREFIX__infix:sym<+^>") :subid("325_1303340952.947") :method
.annotate 'line', 10
    $P1476 = self."!PREFIX__!subrule"("O", "+^")
    new $P1477, "ResizablePMCArray"
    push $P1477, $P1476
    .return ($P1477)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~>"  :subid("326_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1481_tgt
    .local int rx1481_pos
    .local int rx1481_off
    .local int rx1481_eos
    .local int rx1481_rep
    .local pmc rx1481_cur
    .local pmc rx1481_debug
    (rx1481_cur, rx1481_pos, rx1481_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1481_cur
    .local pmc match
    .lex "$/", match
    length rx1481_eos, rx1481_tgt
    gt rx1481_pos, rx1481_eos, rx1481_done
    set rx1481_off, 0
    lt rx1481_pos, 2, rx1481_start
    sub rx1481_off, rx1481_pos, 1
    substr rx1481_tgt, rx1481_tgt, rx1481_off
  rx1481_start:
    eq $I10, 1, rx1481_restart
    if_null rx1481_debug, debug_1227
    rx1481_cur."!cursor_debug"("START", "infix:sym<~>")
  debug_1227:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1485_done
    goto rxscan1485_scan
  rxscan1485_loop:
    (rx1481_pos) = rx1481_cur."from"()
    inc rx1481_pos
    rx1481_cur."!cursor_from"(rx1481_pos)
    ge rx1481_pos, rx1481_eos, rxscan1485_done
  rxscan1485_scan:
    set_addr $I10, rxscan1485_loop
    rx1481_cur."!mark_push"(0, rx1481_pos, $I10)
  rxscan1485_done:
.annotate 'line', 653
  # rx subcapture "sym"
    set_addr $I10, rxcap_1486_fail
    rx1481_cur."!mark_push"(0, rx1481_pos, $I10)
  # rx literal  "~"
    add $I11, rx1481_pos, 1
    gt $I11, rx1481_eos, rx1481_fail
    sub $I11, rx1481_pos, rx1481_off
    ord $I11, rx1481_tgt, $I11
    ne $I11, 126, rx1481_fail
    add rx1481_pos, 1
    set_addr $I10, rxcap_1486_fail
    ($I12, $I11) = rx1481_cur."!mark_peek"($I10)
    rx1481_cur."!cursor_pos"($I11)
    ($P10) = rx1481_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1481_pos, "")
    rx1481_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1486_done
  rxcap_1486_fail:
    goto rx1481_fail
  rxcap_1486_done:
  # rx subrule "O" subtype=capture negate=
    rx1481_cur."!cursor_pos"(rx1481_pos)
    $P10 = rx1481_cur."O"("%concatenation , :pirop<concat>")
    unless $P10, rx1481_fail
    rx1481_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1481_pos = $P10."pos"()
  # rx pass
    rx1481_cur."!cursor_pass"(rx1481_pos, "infix:sym<~>")
    if_null rx1481_debug, debug_1228
    rx1481_cur."!cursor_debug"("PASS", "infix:sym<~>", " at pos=", rx1481_pos)
  debug_1228:
    .return (rx1481_cur)
  rx1481_restart:
.annotate 'line', 10
    if_null rx1481_debug, debug_1229
    rx1481_cur."!cursor_debug"("NEXT", "infix:sym<~>")
  debug_1229:
  rx1481_fail:
    (rx1481_rep, rx1481_pos, $I10, $P10) = rx1481_cur."!mark_fail"(0)
    lt rx1481_pos, -1, rx1481_done
    eq rx1481_pos, -1, rx1481_fail
    jump $I10
  rx1481_done:
    rx1481_cur."!cursor_fail"()
    if_null rx1481_debug, debug_1230
    rx1481_cur."!cursor_debug"("FAIL", "infix:sym<~>")
  debug_1230:
    .return (rx1481_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~>"  :nsentry("!PREFIX__infix:sym<~>") :subid("327_1303340952.947") :method
.annotate 'line', 10
    $P1483 = self."!PREFIX__!subrule"("O", "~")
    new $P1484, "ResizablePMCArray"
    push $P1484, $P1483
    .return ($P1484)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<==>"  :subid("328_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1488_tgt
    .local int rx1488_pos
    .local int rx1488_off
    .local int rx1488_eos
    .local int rx1488_rep
    .local pmc rx1488_cur
    .local pmc rx1488_debug
    (rx1488_cur, rx1488_pos, rx1488_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1488_cur
    .local pmc match
    .lex "$/", match
    length rx1488_eos, rx1488_tgt
    gt rx1488_pos, rx1488_eos, rx1488_done
    set rx1488_off, 0
    lt rx1488_pos, 2, rx1488_start
    sub rx1488_off, rx1488_pos, 1
    substr rx1488_tgt, rx1488_tgt, rx1488_off
  rx1488_start:
    eq $I10, 1, rx1488_restart
    if_null rx1488_debug, debug_1231
    rx1488_cur."!cursor_debug"("START", "infix:sym<==>")
  debug_1231:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1492_done
    goto rxscan1492_scan
  rxscan1492_loop:
    (rx1488_pos) = rx1488_cur."from"()
    inc rx1488_pos
    rx1488_cur."!cursor_from"(rx1488_pos)
    ge rx1488_pos, rx1488_eos, rxscan1492_done
  rxscan1492_scan:
    set_addr $I10, rxscan1492_loop
    rx1488_cur."!mark_push"(0, rx1488_pos, $I10)
  rxscan1492_done:
.annotate 'line', 655
  # rx subcapture "sym"
    set_addr $I10, rxcap_1493_fail
    rx1488_cur."!mark_push"(0, rx1488_pos, $I10)
  # rx literal  "=="
    add $I11, rx1488_pos, 2
    gt $I11, rx1488_eos, rx1488_fail
    sub $I11, rx1488_pos, rx1488_off
    substr $S10, rx1488_tgt, $I11, 2
    ne $S10, "==", rx1488_fail
    add rx1488_pos, 2
    set_addr $I10, rxcap_1493_fail
    ($I12, $I11) = rx1488_cur."!mark_peek"($I10)
    rx1488_cur."!cursor_pos"($I11)
    ($P10) = rx1488_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1488_pos, "")
    rx1488_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1493_done
  rxcap_1493_fail:
    goto rx1488_fail
  rxcap_1493_done:
  # rx subrule "O" subtype=capture negate=
    rx1488_cur."!cursor_pos"(rx1488_pos)
    $P10 = rx1488_cur."O"("%relational, :pirop<iseq INn>")
    unless $P10, rx1488_fail
    rx1488_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1488_pos = $P10."pos"()
  # rx pass
    rx1488_cur."!cursor_pass"(rx1488_pos, "infix:sym<==>")
    if_null rx1488_debug, debug_1232
    rx1488_cur."!cursor_debug"("PASS", "infix:sym<==>", " at pos=", rx1488_pos)
  debug_1232:
    .return (rx1488_cur)
  rx1488_restart:
.annotate 'line', 10
    if_null rx1488_debug, debug_1233
    rx1488_cur."!cursor_debug"("NEXT", "infix:sym<==>")
  debug_1233:
  rx1488_fail:
    (rx1488_rep, rx1488_pos, $I10, $P10) = rx1488_cur."!mark_fail"(0)
    lt rx1488_pos, -1, rx1488_done
    eq rx1488_pos, -1, rx1488_fail
    jump $I10
  rx1488_done:
    rx1488_cur."!cursor_fail"()
    if_null rx1488_debug, debug_1234
    rx1488_cur."!cursor_debug"("FAIL", "infix:sym<==>")
  debug_1234:
    .return (rx1488_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<==>"  :nsentry("!PREFIX__infix:sym<==>") :subid("329_1303340952.947") :method
.annotate 'line', 10
    $P1490 = self."!PREFIX__!subrule"("O", "==")
    new $P1491, "ResizablePMCArray"
    push $P1491, $P1490
    .return ($P1491)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<!=>"  :subid("330_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1495_tgt
    .local int rx1495_pos
    .local int rx1495_off
    .local int rx1495_eos
    .local int rx1495_rep
    .local pmc rx1495_cur
    .local pmc rx1495_debug
    (rx1495_cur, rx1495_pos, rx1495_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1495_cur
    .local pmc match
    .lex "$/", match
    length rx1495_eos, rx1495_tgt
    gt rx1495_pos, rx1495_eos, rx1495_done
    set rx1495_off, 0
    lt rx1495_pos, 2, rx1495_start
    sub rx1495_off, rx1495_pos, 1
    substr rx1495_tgt, rx1495_tgt, rx1495_off
  rx1495_start:
    eq $I10, 1, rx1495_restart
    if_null rx1495_debug, debug_1235
    rx1495_cur."!cursor_debug"("START", "infix:sym<!=>")
  debug_1235:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1499_done
    goto rxscan1499_scan
  rxscan1499_loop:
    (rx1495_pos) = rx1495_cur."from"()
    inc rx1495_pos
    rx1495_cur."!cursor_from"(rx1495_pos)
    ge rx1495_pos, rx1495_eos, rxscan1499_done
  rxscan1499_scan:
    set_addr $I10, rxscan1499_loop
    rx1495_cur."!mark_push"(0, rx1495_pos, $I10)
  rxscan1499_done:
.annotate 'line', 656
  # rx subcapture "sym"
    set_addr $I10, rxcap_1500_fail
    rx1495_cur."!mark_push"(0, rx1495_pos, $I10)
  # rx literal  "!="
    add $I11, rx1495_pos, 2
    gt $I11, rx1495_eos, rx1495_fail
    sub $I11, rx1495_pos, rx1495_off
    substr $S10, rx1495_tgt, $I11, 2
    ne $S10, "!=", rx1495_fail
    add rx1495_pos, 2
    set_addr $I10, rxcap_1500_fail
    ($I12, $I11) = rx1495_cur."!mark_peek"($I10)
    rx1495_cur."!cursor_pos"($I11)
    ($P10) = rx1495_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1495_pos, "")
    rx1495_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1500_done
  rxcap_1500_fail:
    goto rx1495_fail
  rxcap_1500_done:
  # rx subrule "O" subtype=capture negate=
    rx1495_cur."!cursor_pos"(rx1495_pos)
    $P10 = rx1495_cur."O"("%relational, :pirop<isne INn>")
    unless $P10, rx1495_fail
    rx1495_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1495_pos = $P10."pos"()
  # rx pass
    rx1495_cur."!cursor_pass"(rx1495_pos, "infix:sym<!=>")
    if_null rx1495_debug, debug_1236
    rx1495_cur."!cursor_debug"("PASS", "infix:sym<!=>", " at pos=", rx1495_pos)
  debug_1236:
    .return (rx1495_cur)
  rx1495_restart:
.annotate 'line', 10
    if_null rx1495_debug, debug_1237
    rx1495_cur."!cursor_debug"("NEXT", "infix:sym<!=>")
  debug_1237:
  rx1495_fail:
    (rx1495_rep, rx1495_pos, $I10, $P10) = rx1495_cur."!mark_fail"(0)
    lt rx1495_pos, -1, rx1495_done
    eq rx1495_pos, -1, rx1495_fail
    jump $I10
  rx1495_done:
    rx1495_cur."!cursor_fail"()
    if_null rx1495_debug, debug_1238
    rx1495_cur."!cursor_debug"("FAIL", "infix:sym<!=>")
  debug_1238:
    .return (rx1495_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<!=>"  :nsentry("!PREFIX__infix:sym<!=>") :subid("331_1303340952.947") :method
.annotate 'line', 10
    $P1497 = self."!PREFIX__!subrule"("O", "!=")
    new $P1498, "ResizablePMCArray"
    push $P1498, $P1497
    .return ($P1498)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<=>"  :subid("332_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1502_tgt
    .local int rx1502_pos
    .local int rx1502_off
    .local int rx1502_eos
    .local int rx1502_rep
    .local pmc rx1502_cur
    .local pmc rx1502_debug
    (rx1502_cur, rx1502_pos, rx1502_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1502_cur
    .local pmc match
    .lex "$/", match
    length rx1502_eos, rx1502_tgt
    gt rx1502_pos, rx1502_eos, rx1502_done
    set rx1502_off, 0
    lt rx1502_pos, 2, rx1502_start
    sub rx1502_off, rx1502_pos, 1
    substr rx1502_tgt, rx1502_tgt, rx1502_off
  rx1502_start:
    eq $I10, 1, rx1502_restart
    if_null rx1502_debug, debug_1239
    rx1502_cur."!cursor_debug"("START", "infix:sym<<=>")
  debug_1239:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1506_done
    goto rxscan1506_scan
  rxscan1506_loop:
    (rx1502_pos) = rx1502_cur."from"()
    inc rx1502_pos
    rx1502_cur."!cursor_from"(rx1502_pos)
    ge rx1502_pos, rx1502_eos, rxscan1506_done
  rxscan1506_scan:
    set_addr $I10, rxscan1506_loop
    rx1502_cur."!mark_push"(0, rx1502_pos, $I10)
  rxscan1506_done:
.annotate 'line', 657
  # rx subcapture "sym"
    set_addr $I10, rxcap_1507_fail
    rx1502_cur."!mark_push"(0, rx1502_pos, $I10)
  # rx literal  "<="
    add $I11, rx1502_pos, 2
    gt $I11, rx1502_eos, rx1502_fail
    sub $I11, rx1502_pos, rx1502_off
    substr $S10, rx1502_tgt, $I11, 2
    ne $S10, "<=", rx1502_fail
    add rx1502_pos, 2
    set_addr $I10, rxcap_1507_fail
    ($I12, $I11) = rx1502_cur."!mark_peek"($I10)
    rx1502_cur."!cursor_pos"($I11)
    ($P10) = rx1502_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1502_pos, "")
    rx1502_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1507_done
  rxcap_1507_fail:
    goto rx1502_fail
  rxcap_1507_done:
  # rx subrule "O" subtype=capture negate=
    rx1502_cur."!cursor_pos"(rx1502_pos)
    $P10 = rx1502_cur."O"("%relational, :pirop<isle INn>")
    unless $P10, rx1502_fail
    rx1502_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1502_pos = $P10."pos"()
  # rx pass
    rx1502_cur."!cursor_pass"(rx1502_pos, "infix:sym<<=>")
    if_null rx1502_debug, debug_1240
    rx1502_cur."!cursor_debug"("PASS", "infix:sym<<=>", " at pos=", rx1502_pos)
  debug_1240:
    .return (rx1502_cur)
  rx1502_restart:
.annotate 'line', 10
    if_null rx1502_debug, debug_1241
    rx1502_cur."!cursor_debug"("NEXT", "infix:sym<<=>")
  debug_1241:
  rx1502_fail:
    (rx1502_rep, rx1502_pos, $I10, $P10) = rx1502_cur."!mark_fail"(0)
    lt rx1502_pos, -1, rx1502_done
    eq rx1502_pos, -1, rx1502_fail
    jump $I10
  rx1502_done:
    rx1502_cur."!cursor_fail"()
    if_null rx1502_debug, debug_1242
    rx1502_cur."!cursor_debug"("FAIL", "infix:sym<<=>")
  debug_1242:
    .return (rx1502_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<=>"  :nsentry("!PREFIX__infix:sym<<=>") :subid("333_1303340952.947") :method
.annotate 'line', 10
    $P1504 = self."!PREFIX__!subrule"("O", "<=")
    new $P1505, "ResizablePMCArray"
    push $P1505, $P1504
    .return ($P1505)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>=>"  :subid("334_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1509_tgt
    .local int rx1509_pos
    .local int rx1509_off
    .local int rx1509_eos
    .local int rx1509_rep
    .local pmc rx1509_cur
    .local pmc rx1509_debug
    (rx1509_cur, rx1509_pos, rx1509_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1509_cur
    .local pmc match
    .lex "$/", match
    length rx1509_eos, rx1509_tgt
    gt rx1509_pos, rx1509_eos, rx1509_done
    set rx1509_off, 0
    lt rx1509_pos, 2, rx1509_start
    sub rx1509_off, rx1509_pos, 1
    substr rx1509_tgt, rx1509_tgt, rx1509_off
  rx1509_start:
    eq $I10, 1, rx1509_restart
    if_null rx1509_debug, debug_1243
    rx1509_cur."!cursor_debug"("START", "infix:sym<>=>")
  debug_1243:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1513_done
    goto rxscan1513_scan
  rxscan1513_loop:
    (rx1509_pos) = rx1509_cur."from"()
    inc rx1509_pos
    rx1509_cur."!cursor_from"(rx1509_pos)
    ge rx1509_pos, rx1509_eos, rxscan1513_done
  rxscan1513_scan:
    set_addr $I10, rxscan1513_loop
    rx1509_cur."!mark_push"(0, rx1509_pos, $I10)
  rxscan1513_done:
.annotate 'line', 658
  # rx subcapture "sym"
    set_addr $I10, rxcap_1514_fail
    rx1509_cur."!mark_push"(0, rx1509_pos, $I10)
  # rx literal  ">="
    add $I11, rx1509_pos, 2
    gt $I11, rx1509_eos, rx1509_fail
    sub $I11, rx1509_pos, rx1509_off
    substr $S10, rx1509_tgt, $I11, 2
    ne $S10, ">=", rx1509_fail
    add rx1509_pos, 2
    set_addr $I10, rxcap_1514_fail
    ($I12, $I11) = rx1509_cur."!mark_peek"($I10)
    rx1509_cur."!cursor_pos"($I11)
    ($P10) = rx1509_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1509_pos, "")
    rx1509_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1514_done
  rxcap_1514_fail:
    goto rx1509_fail
  rxcap_1514_done:
  # rx subrule "O" subtype=capture negate=
    rx1509_cur."!cursor_pos"(rx1509_pos)
    $P10 = rx1509_cur."O"("%relational, :pirop<isge INn>")
    unless $P10, rx1509_fail
    rx1509_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1509_pos = $P10."pos"()
  # rx pass
    rx1509_cur."!cursor_pass"(rx1509_pos, "infix:sym<>=>")
    if_null rx1509_debug, debug_1244
    rx1509_cur."!cursor_debug"("PASS", "infix:sym<>=>", " at pos=", rx1509_pos)
  debug_1244:
    .return (rx1509_cur)
  rx1509_restart:
.annotate 'line', 10
    if_null rx1509_debug, debug_1245
    rx1509_cur."!cursor_debug"("NEXT", "infix:sym<>=>")
  debug_1245:
  rx1509_fail:
    (rx1509_rep, rx1509_pos, $I10, $P10) = rx1509_cur."!mark_fail"(0)
    lt rx1509_pos, -1, rx1509_done
    eq rx1509_pos, -1, rx1509_fail
    jump $I10
  rx1509_done:
    rx1509_cur."!cursor_fail"()
    if_null rx1509_debug, debug_1246
    rx1509_cur."!cursor_debug"("FAIL", "infix:sym<>=>")
  debug_1246:
    .return (rx1509_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>=>"  :nsentry("!PREFIX__infix:sym<>=>") :subid("335_1303340952.947") :method
.annotate 'line', 10
    $P1511 = self."!PREFIX__!subrule"("O", ">=")
    new $P1512, "ResizablePMCArray"
    push $P1512, $P1511
    .return ($P1512)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<>"  :subid("336_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1516_tgt
    .local int rx1516_pos
    .local int rx1516_off
    .local int rx1516_eos
    .local int rx1516_rep
    .local pmc rx1516_cur
    .local pmc rx1516_debug
    (rx1516_cur, rx1516_pos, rx1516_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1516_cur
    .local pmc match
    .lex "$/", match
    length rx1516_eos, rx1516_tgt
    gt rx1516_pos, rx1516_eos, rx1516_done
    set rx1516_off, 0
    lt rx1516_pos, 2, rx1516_start
    sub rx1516_off, rx1516_pos, 1
    substr rx1516_tgt, rx1516_tgt, rx1516_off
  rx1516_start:
    eq $I10, 1, rx1516_restart
    if_null rx1516_debug, debug_1247
    rx1516_cur."!cursor_debug"("START", "infix:sym<<>")
  debug_1247:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1520_done
    goto rxscan1520_scan
  rxscan1520_loop:
    (rx1516_pos) = rx1516_cur."from"()
    inc rx1516_pos
    rx1516_cur."!cursor_from"(rx1516_pos)
    ge rx1516_pos, rx1516_eos, rxscan1520_done
  rxscan1520_scan:
    set_addr $I10, rxscan1520_loop
    rx1516_cur."!mark_push"(0, rx1516_pos, $I10)
  rxscan1520_done:
.annotate 'line', 659
  # rx subcapture "sym"
    set_addr $I10, rxcap_1521_fail
    rx1516_cur."!mark_push"(0, rx1516_pos, $I10)
  # rx literal  "<"
    add $I11, rx1516_pos, 1
    gt $I11, rx1516_eos, rx1516_fail
    sub $I11, rx1516_pos, rx1516_off
    ord $I11, rx1516_tgt, $I11
    ne $I11, 60, rx1516_fail
    add rx1516_pos, 1
    set_addr $I10, rxcap_1521_fail
    ($I12, $I11) = rx1516_cur."!mark_peek"($I10)
    rx1516_cur."!cursor_pos"($I11)
    ($P10) = rx1516_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1516_pos, "")
    rx1516_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1521_done
  rxcap_1521_fail:
    goto rx1516_fail
  rxcap_1521_done:
  # rx subrule "O" subtype=capture negate=
    rx1516_cur."!cursor_pos"(rx1516_pos)
    $P10 = rx1516_cur."O"("%relational, :pirop<islt INn>")
    unless $P10, rx1516_fail
    rx1516_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1516_pos = $P10."pos"()
  # rx pass
    rx1516_cur."!cursor_pass"(rx1516_pos, "infix:sym<<>")
    if_null rx1516_debug, debug_1248
    rx1516_cur."!cursor_debug"("PASS", "infix:sym<<>", " at pos=", rx1516_pos)
  debug_1248:
    .return (rx1516_cur)
  rx1516_restart:
.annotate 'line', 10
    if_null rx1516_debug, debug_1249
    rx1516_cur."!cursor_debug"("NEXT", "infix:sym<<>")
  debug_1249:
  rx1516_fail:
    (rx1516_rep, rx1516_pos, $I10, $P10) = rx1516_cur."!mark_fail"(0)
    lt rx1516_pos, -1, rx1516_done
    eq rx1516_pos, -1, rx1516_fail
    jump $I10
  rx1516_done:
    rx1516_cur."!cursor_fail"()
    if_null rx1516_debug, debug_1250
    rx1516_cur."!cursor_debug"("FAIL", "infix:sym<<>")
  debug_1250:
    .return (rx1516_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<>"  :nsentry("!PREFIX__infix:sym<<>") :subid("337_1303340952.947") :method
.annotate 'line', 10
    $P1518 = self."!PREFIX__!subrule"("O", "<")
    new $P1519, "ResizablePMCArray"
    push $P1519, $P1518
    .return ($P1519)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>>"  :subid("338_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1523_tgt
    .local int rx1523_pos
    .local int rx1523_off
    .local int rx1523_eos
    .local int rx1523_rep
    .local pmc rx1523_cur
    .local pmc rx1523_debug
    (rx1523_cur, rx1523_pos, rx1523_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1523_cur
    .local pmc match
    .lex "$/", match
    length rx1523_eos, rx1523_tgt
    gt rx1523_pos, rx1523_eos, rx1523_done
    set rx1523_off, 0
    lt rx1523_pos, 2, rx1523_start
    sub rx1523_off, rx1523_pos, 1
    substr rx1523_tgt, rx1523_tgt, rx1523_off
  rx1523_start:
    eq $I10, 1, rx1523_restart
    if_null rx1523_debug, debug_1251
    rx1523_cur."!cursor_debug"("START", "infix:sym<>>")
  debug_1251:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1527_done
    goto rxscan1527_scan
  rxscan1527_loop:
    (rx1523_pos) = rx1523_cur."from"()
    inc rx1523_pos
    rx1523_cur."!cursor_from"(rx1523_pos)
    ge rx1523_pos, rx1523_eos, rxscan1527_done
  rxscan1527_scan:
    set_addr $I10, rxscan1527_loop
    rx1523_cur."!mark_push"(0, rx1523_pos, $I10)
  rxscan1527_done:
.annotate 'line', 660
  # rx subcapture "sym"
    set_addr $I10, rxcap_1528_fail
    rx1523_cur."!mark_push"(0, rx1523_pos, $I10)
  # rx literal  ">"
    add $I11, rx1523_pos, 1
    gt $I11, rx1523_eos, rx1523_fail
    sub $I11, rx1523_pos, rx1523_off
    ord $I11, rx1523_tgt, $I11
    ne $I11, 62, rx1523_fail
    add rx1523_pos, 1
    set_addr $I10, rxcap_1528_fail
    ($I12, $I11) = rx1523_cur."!mark_peek"($I10)
    rx1523_cur."!cursor_pos"($I11)
    ($P10) = rx1523_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1523_pos, "")
    rx1523_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1528_done
  rxcap_1528_fail:
    goto rx1523_fail
  rxcap_1528_done:
  # rx subrule "O" subtype=capture negate=
    rx1523_cur."!cursor_pos"(rx1523_pos)
    $P10 = rx1523_cur."O"("%relational, :pirop<isgt INn>")
    unless $P10, rx1523_fail
    rx1523_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1523_pos = $P10."pos"()
  # rx pass
    rx1523_cur."!cursor_pass"(rx1523_pos, "infix:sym<>>")
    if_null rx1523_debug, debug_1252
    rx1523_cur."!cursor_debug"("PASS", "infix:sym<>>", " at pos=", rx1523_pos)
  debug_1252:
    .return (rx1523_cur)
  rx1523_restart:
.annotate 'line', 10
    if_null rx1523_debug, debug_1253
    rx1523_cur."!cursor_debug"("NEXT", "infix:sym<>>")
  debug_1253:
  rx1523_fail:
    (rx1523_rep, rx1523_pos, $I10, $P10) = rx1523_cur."!mark_fail"(0)
    lt rx1523_pos, -1, rx1523_done
    eq rx1523_pos, -1, rx1523_fail
    jump $I10
  rx1523_done:
    rx1523_cur."!cursor_fail"()
    if_null rx1523_debug, debug_1254
    rx1523_cur."!cursor_debug"("FAIL", "infix:sym<>>")
  debug_1254:
    .return (rx1523_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>>"  :nsentry("!PREFIX__infix:sym<>>") :subid("339_1303340952.947") :method
.annotate 'line', 10
    $P1525 = self."!PREFIX__!subrule"("O", ">")
    new $P1526, "ResizablePMCArray"
    push $P1526, $P1525
    .return ($P1526)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<eq>"  :subid("340_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1530_tgt
    .local int rx1530_pos
    .local int rx1530_off
    .local int rx1530_eos
    .local int rx1530_rep
    .local pmc rx1530_cur
    .local pmc rx1530_debug
    (rx1530_cur, rx1530_pos, rx1530_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1530_cur
    .local pmc match
    .lex "$/", match
    length rx1530_eos, rx1530_tgt
    gt rx1530_pos, rx1530_eos, rx1530_done
    set rx1530_off, 0
    lt rx1530_pos, 2, rx1530_start
    sub rx1530_off, rx1530_pos, 1
    substr rx1530_tgt, rx1530_tgt, rx1530_off
  rx1530_start:
    eq $I10, 1, rx1530_restart
    if_null rx1530_debug, debug_1255
    rx1530_cur."!cursor_debug"("START", "infix:sym<eq>")
  debug_1255:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1534_done
    goto rxscan1534_scan
  rxscan1534_loop:
    (rx1530_pos) = rx1530_cur."from"()
    inc rx1530_pos
    rx1530_cur."!cursor_from"(rx1530_pos)
    ge rx1530_pos, rx1530_eos, rxscan1534_done
  rxscan1534_scan:
    set_addr $I10, rxscan1534_loop
    rx1530_cur."!mark_push"(0, rx1530_pos, $I10)
  rxscan1534_done:
.annotate 'line', 661
  # rx subcapture "sym"
    set_addr $I10, rxcap_1535_fail
    rx1530_cur."!mark_push"(0, rx1530_pos, $I10)
  # rx literal  "eq"
    add $I11, rx1530_pos, 2
    gt $I11, rx1530_eos, rx1530_fail
    sub $I11, rx1530_pos, rx1530_off
    substr $S10, rx1530_tgt, $I11, 2
    ne $S10, "eq", rx1530_fail
    add rx1530_pos, 2
    set_addr $I10, rxcap_1535_fail
    ($I12, $I11) = rx1530_cur."!mark_peek"($I10)
    rx1530_cur."!cursor_pos"($I11)
    ($P10) = rx1530_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1530_pos, "")
    rx1530_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1535_done
  rxcap_1535_fail:
    goto rx1530_fail
  rxcap_1535_done:
  # rx subrule "O" subtype=capture negate=
    rx1530_cur."!cursor_pos"(rx1530_pos)
    $P10 = rx1530_cur."O"("%relational, :pirop<iseq ISs>")
    unless $P10, rx1530_fail
    rx1530_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1530_pos = $P10."pos"()
  # rx pass
    rx1530_cur."!cursor_pass"(rx1530_pos, "infix:sym<eq>")
    if_null rx1530_debug, debug_1256
    rx1530_cur."!cursor_debug"("PASS", "infix:sym<eq>", " at pos=", rx1530_pos)
  debug_1256:
    .return (rx1530_cur)
  rx1530_restart:
.annotate 'line', 10
    if_null rx1530_debug, debug_1257
    rx1530_cur."!cursor_debug"("NEXT", "infix:sym<eq>")
  debug_1257:
  rx1530_fail:
    (rx1530_rep, rx1530_pos, $I10, $P10) = rx1530_cur."!mark_fail"(0)
    lt rx1530_pos, -1, rx1530_done
    eq rx1530_pos, -1, rx1530_fail
    jump $I10
  rx1530_done:
    rx1530_cur."!cursor_fail"()
    if_null rx1530_debug, debug_1258
    rx1530_cur."!cursor_debug"("FAIL", "infix:sym<eq>")
  debug_1258:
    .return (rx1530_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<eq>"  :nsentry("!PREFIX__infix:sym<eq>") :subid("341_1303340952.947") :method
.annotate 'line', 10
    $P1532 = self."!PREFIX__!subrule"("O", "eq")
    new $P1533, "ResizablePMCArray"
    push $P1533, $P1532
    .return ($P1533)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ne>"  :subid("342_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1537_tgt
    .local int rx1537_pos
    .local int rx1537_off
    .local int rx1537_eos
    .local int rx1537_rep
    .local pmc rx1537_cur
    .local pmc rx1537_debug
    (rx1537_cur, rx1537_pos, rx1537_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1537_cur
    .local pmc match
    .lex "$/", match
    length rx1537_eos, rx1537_tgt
    gt rx1537_pos, rx1537_eos, rx1537_done
    set rx1537_off, 0
    lt rx1537_pos, 2, rx1537_start
    sub rx1537_off, rx1537_pos, 1
    substr rx1537_tgt, rx1537_tgt, rx1537_off
  rx1537_start:
    eq $I10, 1, rx1537_restart
    if_null rx1537_debug, debug_1259
    rx1537_cur."!cursor_debug"("START", "infix:sym<ne>")
  debug_1259:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1541_done
    goto rxscan1541_scan
  rxscan1541_loop:
    (rx1537_pos) = rx1537_cur."from"()
    inc rx1537_pos
    rx1537_cur."!cursor_from"(rx1537_pos)
    ge rx1537_pos, rx1537_eos, rxscan1541_done
  rxscan1541_scan:
    set_addr $I10, rxscan1541_loop
    rx1537_cur."!mark_push"(0, rx1537_pos, $I10)
  rxscan1541_done:
.annotate 'line', 662
  # rx subcapture "sym"
    set_addr $I10, rxcap_1542_fail
    rx1537_cur."!mark_push"(0, rx1537_pos, $I10)
  # rx literal  "ne"
    add $I11, rx1537_pos, 2
    gt $I11, rx1537_eos, rx1537_fail
    sub $I11, rx1537_pos, rx1537_off
    substr $S10, rx1537_tgt, $I11, 2
    ne $S10, "ne", rx1537_fail
    add rx1537_pos, 2
    set_addr $I10, rxcap_1542_fail
    ($I12, $I11) = rx1537_cur."!mark_peek"($I10)
    rx1537_cur."!cursor_pos"($I11)
    ($P10) = rx1537_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1537_pos, "")
    rx1537_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1542_done
  rxcap_1542_fail:
    goto rx1537_fail
  rxcap_1542_done:
  # rx subrule "O" subtype=capture negate=
    rx1537_cur."!cursor_pos"(rx1537_pos)
    $P10 = rx1537_cur."O"("%relational, :pirop<isne ISs>")
    unless $P10, rx1537_fail
    rx1537_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1537_pos = $P10."pos"()
  # rx pass
    rx1537_cur."!cursor_pass"(rx1537_pos, "infix:sym<ne>")
    if_null rx1537_debug, debug_1260
    rx1537_cur."!cursor_debug"("PASS", "infix:sym<ne>", " at pos=", rx1537_pos)
  debug_1260:
    .return (rx1537_cur)
  rx1537_restart:
.annotate 'line', 10
    if_null rx1537_debug, debug_1261
    rx1537_cur."!cursor_debug"("NEXT", "infix:sym<ne>")
  debug_1261:
  rx1537_fail:
    (rx1537_rep, rx1537_pos, $I10, $P10) = rx1537_cur."!mark_fail"(0)
    lt rx1537_pos, -1, rx1537_done
    eq rx1537_pos, -1, rx1537_fail
    jump $I10
  rx1537_done:
    rx1537_cur."!cursor_fail"()
    if_null rx1537_debug, debug_1262
    rx1537_cur."!cursor_debug"("FAIL", "infix:sym<ne>")
  debug_1262:
    .return (rx1537_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ne>"  :nsentry("!PREFIX__infix:sym<ne>") :subid("343_1303340952.947") :method
.annotate 'line', 10
    $P1539 = self."!PREFIX__!subrule"("O", "ne")
    new $P1540, "ResizablePMCArray"
    push $P1540, $P1539
    .return ($P1540)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<le>"  :subid("344_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1544_tgt
    .local int rx1544_pos
    .local int rx1544_off
    .local int rx1544_eos
    .local int rx1544_rep
    .local pmc rx1544_cur
    .local pmc rx1544_debug
    (rx1544_cur, rx1544_pos, rx1544_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1544_cur
    .local pmc match
    .lex "$/", match
    length rx1544_eos, rx1544_tgt
    gt rx1544_pos, rx1544_eos, rx1544_done
    set rx1544_off, 0
    lt rx1544_pos, 2, rx1544_start
    sub rx1544_off, rx1544_pos, 1
    substr rx1544_tgt, rx1544_tgt, rx1544_off
  rx1544_start:
    eq $I10, 1, rx1544_restart
    if_null rx1544_debug, debug_1263
    rx1544_cur."!cursor_debug"("START", "infix:sym<le>")
  debug_1263:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1548_done
    goto rxscan1548_scan
  rxscan1548_loop:
    (rx1544_pos) = rx1544_cur."from"()
    inc rx1544_pos
    rx1544_cur."!cursor_from"(rx1544_pos)
    ge rx1544_pos, rx1544_eos, rxscan1548_done
  rxscan1548_scan:
    set_addr $I10, rxscan1548_loop
    rx1544_cur."!mark_push"(0, rx1544_pos, $I10)
  rxscan1548_done:
.annotate 'line', 663
  # rx subcapture "sym"
    set_addr $I10, rxcap_1549_fail
    rx1544_cur."!mark_push"(0, rx1544_pos, $I10)
  # rx literal  "le"
    add $I11, rx1544_pos, 2
    gt $I11, rx1544_eos, rx1544_fail
    sub $I11, rx1544_pos, rx1544_off
    substr $S10, rx1544_tgt, $I11, 2
    ne $S10, "le", rx1544_fail
    add rx1544_pos, 2
    set_addr $I10, rxcap_1549_fail
    ($I12, $I11) = rx1544_cur."!mark_peek"($I10)
    rx1544_cur."!cursor_pos"($I11)
    ($P10) = rx1544_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1544_pos, "")
    rx1544_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1549_done
  rxcap_1549_fail:
    goto rx1544_fail
  rxcap_1549_done:
  # rx subrule "O" subtype=capture negate=
    rx1544_cur."!cursor_pos"(rx1544_pos)
    $P10 = rx1544_cur."O"("%relational, :pirop<isle ISs>")
    unless $P10, rx1544_fail
    rx1544_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1544_pos = $P10."pos"()
  # rx pass
    rx1544_cur."!cursor_pass"(rx1544_pos, "infix:sym<le>")
    if_null rx1544_debug, debug_1264
    rx1544_cur."!cursor_debug"("PASS", "infix:sym<le>", " at pos=", rx1544_pos)
  debug_1264:
    .return (rx1544_cur)
  rx1544_restart:
.annotate 'line', 10
    if_null rx1544_debug, debug_1265
    rx1544_cur."!cursor_debug"("NEXT", "infix:sym<le>")
  debug_1265:
  rx1544_fail:
    (rx1544_rep, rx1544_pos, $I10, $P10) = rx1544_cur."!mark_fail"(0)
    lt rx1544_pos, -1, rx1544_done
    eq rx1544_pos, -1, rx1544_fail
    jump $I10
  rx1544_done:
    rx1544_cur."!cursor_fail"()
    if_null rx1544_debug, debug_1266
    rx1544_cur."!cursor_debug"("FAIL", "infix:sym<le>")
  debug_1266:
    .return (rx1544_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<le>"  :nsentry("!PREFIX__infix:sym<le>") :subid("345_1303340952.947") :method
.annotate 'line', 10
    $P1546 = self."!PREFIX__!subrule"("O", "le")
    new $P1547, "ResizablePMCArray"
    push $P1547, $P1546
    .return ($P1547)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ge>"  :subid("346_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1551_tgt
    .local int rx1551_pos
    .local int rx1551_off
    .local int rx1551_eos
    .local int rx1551_rep
    .local pmc rx1551_cur
    .local pmc rx1551_debug
    (rx1551_cur, rx1551_pos, rx1551_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1551_cur
    .local pmc match
    .lex "$/", match
    length rx1551_eos, rx1551_tgt
    gt rx1551_pos, rx1551_eos, rx1551_done
    set rx1551_off, 0
    lt rx1551_pos, 2, rx1551_start
    sub rx1551_off, rx1551_pos, 1
    substr rx1551_tgt, rx1551_tgt, rx1551_off
  rx1551_start:
    eq $I10, 1, rx1551_restart
    if_null rx1551_debug, debug_1267
    rx1551_cur."!cursor_debug"("START", "infix:sym<ge>")
  debug_1267:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1555_done
    goto rxscan1555_scan
  rxscan1555_loop:
    (rx1551_pos) = rx1551_cur."from"()
    inc rx1551_pos
    rx1551_cur."!cursor_from"(rx1551_pos)
    ge rx1551_pos, rx1551_eos, rxscan1555_done
  rxscan1555_scan:
    set_addr $I10, rxscan1555_loop
    rx1551_cur."!mark_push"(0, rx1551_pos, $I10)
  rxscan1555_done:
.annotate 'line', 664
  # rx subcapture "sym"
    set_addr $I10, rxcap_1556_fail
    rx1551_cur."!mark_push"(0, rx1551_pos, $I10)
  # rx literal  "ge"
    add $I11, rx1551_pos, 2
    gt $I11, rx1551_eos, rx1551_fail
    sub $I11, rx1551_pos, rx1551_off
    substr $S10, rx1551_tgt, $I11, 2
    ne $S10, "ge", rx1551_fail
    add rx1551_pos, 2
    set_addr $I10, rxcap_1556_fail
    ($I12, $I11) = rx1551_cur."!mark_peek"($I10)
    rx1551_cur."!cursor_pos"($I11)
    ($P10) = rx1551_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1551_pos, "")
    rx1551_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1556_done
  rxcap_1556_fail:
    goto rx1551_fail
  rxcap_1556_done:
  # rx subrule "O" subtype=capture negate=
    rx1551_cur."!cursor_pos"(rx1551_pos)
    $P10 = rx1551_cur."O"("%relational, :pirop<isge ISs>")
    unless $P10, rx1551_fail
    rx1551_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1551_pos = $P10."pos"()
  # rx pass
    rx1551_cur."!cursor_pass"(rx1551_pos, "infix:sym<ge>")
    if_null rx1551_debug, debug_1268
    rx1551_cur."!cursor_debug"("PASS", "infix:sym<ge>", " at pos=", rx1551_pos)
  debug_1268:
    .return (rx1551_cur)
  rx1551_restart:
.annotate 'line', 10
    if_null rx1551_debug, debug_1269
    rx1551_cur."!cursor_debug"("NEXT", "infix:sym<ge>")
  debug_1269:
  rx1551_fail:
    (rx1551_rep, rx1551_pos, $I10, $P10) = rx1551_cur."!mark_fail"(0)
    lt rx1551_pos, -1, rx1551_done
    eq rx1551_pos, -1, rx1551_fail
    jump $I10
  rx1551_done:
    rx1551_cur."!cursor_fail"()
    if_null rx1551_debug, debug_1270
    rx1551_cur."!cursor_debug"("FAIL", "infix:sym<ge>")
  debug_1270:
    .return (rx1551_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ge>"  :nsentry("!PREFIX__infix:sym<ge>") :subid("347_1303340952.947") :method
.annotate 'line', 10
    $P1553 = self."!PREFIX__!subrule"("O", "ge")
    new $P1554, "ResizablePMCArray"
    push $P1554, $P1553
    .return ($P1554)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<lt>"  :subid("348_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1558_tgt
    .local int rx1558_pos
    .local int rx1558_off
    .local int rx1558_eos
    .local int rx1558_rep
    .local pmc rx1558_cur
    .local pmc rx1558_debug
    (rx1558_cur, rx1558_pos, rx1558_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1558_cur
    .local pmc match
    .lex "$/", match
    length rx1558_eos, rx1558_tgt
    gt rx1558_pos, rx1558_eos, rx1558_done
    set rx1558_off, 0
    lt rx1558_pos, 2, rx1558_start
    sub rx1558_off, rx1558_pos, 1
    substr rx1558_tgt, rx1558_tgt, rx1558_off
  rx1558_start:
    eq $I10, 1, rx1558_restart
    if_null rx1558_debug, debug_1271
    rx1558_cur."!cursor_debug"("START", "infix:sym<lt>")
  debug_1271:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1562_done
    goto rxscan1562_scan
  rxscan1562_loop:
    (rx1558_pos) = rx1558_cur."from"()
    inc rx1558_pos
    rx1558_cur."!cursor_from"(rx1558_pos)
    ge rx1558_pos, rx1558_eos, rxscan1562_done
  rxscan1562_scan:
    set_addr $I10, rxscan1562_loop
    rx1558_cur."!mark_push"(0, rx1558_pos, $I10)
  rxscan1562_done:
.annotate 'line', 665
  # rx subcapture "sym"
    set_addr $I10, rxcap_1563_fail
    rx1558_cur."!mark_push"(0, rx1558_pos, $I10)
  # rx literal  "lt"
    add $I11, rx1558_pos, 2
    gt $I11, rx1558_eos, rx1558_fail
    sub $I11, rx1558_pos, rx1558_off
    substr $S10, rx1558_tgt, $I11, 2
    ne $S10, "lt", rx1558_fail
    add rx1558_pos, 2
    set_addr $I10, rxcap_1563_fail
    ($I12, $I11) = rx1558_cur."!mark_peek"($I10)
    rx1558_cur."!cursor_pos"($I11)
    ($P10) = rx1558_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1558_pos, "")
    rx1558_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1563_done
  rxcap_1563_fail:
    goto rx1558_fail
  rxcap_1563_done:
  # rx subrule "O" subtype=capture negate=
    rx1558_cur."!cursor_pos"(rx1558_pos)
    $P10 = rx1558_cur."O"("%relational, :pirop<islt ISs>")
    unless $P10, rx1558_fail
    rx1558_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1558_pos = $P10."pos"()
  # rx pass
    rx1558_cur."!cursor_pass"(rx1558_pos, "infix:sym<lt>")
    if_null rx1558_debug, debug_1272
    rx1558_cur."!cursor_debug"("PASS", "infix:sym<lt>", " at pos=", rx1558_pos)
  debug_1272:
    .return (rx1558_cur)
  rx1558_restart:
.annotate 'line', 10
    if_null rx1558_debug, debug_1273
    rx1558_cur."!cursor_debug"("NEXT", "infix:sym<lt>")
  debug_1273:
  rx1558_fail:
    (rx1558_rep, rx1558_pos, $I10, $P10) = rx1558_cur."!mark_fail"(0)
    lt rx1558_pos, -1, rx1558_done
    eq rx1558_pos, -1, rx1558_fail
    jump $I10
  rx1558_done:
    rx1558_cur."!cursor_fail"()
    if_null rx1558_debug, debug_1274
    rx1558_cur."!cursor_debug"("FAIL", "infix:sym<lt>")
  debug_1274:
    .return (rx1558_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<lt>"  :nsentry("!PREFIX__infix:sym<lt>") :subid("349_1303340952.947") :method
.annotate 'line', 10
    $P1560 = self."!PREFIX__!subrule"("O", "lt")
    new $P1561, "ResizablePMCArray"
    push $P1561, $P1560
    .return ($P1561)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<gt>"  :subid("350_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1565_tgt
    .local int rx1565_pos
    .local int rx1565_off
    .local int rx1565_eos
    .local int rx1565_rep
    .local pmc rx1565_cur
    .local pmc rx1565_debug
    (rx1565_cur, rx1565_pos, rx1565_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1565_cur
    .local pmc match
    .lex "$/", match
    length rx1565_eos, rx1565_tgt
    gt rx1565_pos, rx1565_eos, rx1565_done
    set rx1565_off, 0
    lt rx1565_pos, 2, rx1565_start
    sub rx1565_off, rx1565_pos, 1
    substr rx1565_tgt, rx1565_tgt, rx1565_off
  rx1565_start:
    eq $I10, 1, rx1565_restart
    if_null rx1565_debug, debug_1275
    rx1565_cur."!cursor_debug"("START", "infix:sym<gt>")
  debug_1275:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1569_done
    goto rxscan1569_scan
  rxscan1569_loop:
    (rx1565_pos) = rx1565_cur."from"()
    inc rx1565_pos
    rx1565_cur."!cursor_from"(rx1565_pos)
    ge rx1565_pos, rx1565_eos, rxscan1569_done
  rxscan1569_scan:
    set_addr $I10, rxscan1569_loop
    rx1565_cur."!mark_push"(0, rx1565_pos, $I10)
  rxscan1569_done:
.annotate 'line', 666
  # rx subcapture "sym"
    set_addr $I10, rxcap_1570_fail
    rx1565_cur."!mark_push"(0, rx1565_pos, $I10)
  # rx literal  "gt"
    add $I11, rx1565_pos, 2
    gt $I11, rx1565_eos, rx1565_fail
    sub $I11, rx1565_pos, rx1565_off
    substr $S10, rx1565_tgt, $I11, 2
    ne $S10, "gt", rx1565_fail
    add rx1565_pos, 2
    set_addr $I10, rxcap_1570_fail
    ($I12, $I11) = rx1565_cur."!mark_peek"($I10)
    rx1565_cur."!cursor_pos"($I11)
    ($P10) = rx1565_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1565_pos, "")
    rx1565_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1570_done
  rxcap_1570_fail:
    goto rx1565_fail
  rxcap_1570_done:
  # rx subrule "O" subtype=capture negate=
    rx1565_cur."!cursor_pos"(rx1565_pos)
    $P10 = rx1565_cur."O"("%relational, :pirop<isgt ISs>")
    unless $P10, rx1565_fail
    rx1565_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1565_pos = $P10."pos"()
  # rx pass
    rx1565_cur."!cursor_pass"(rx1565_pos, "infix:sym<gt>")
    if_null rx1565_debug, debug_1276
    rx1565_cur."!cursor_debug"("PASS", "infix:sym<gt>", " at pos=", rx1565_pos)
  debug_1276:
    .return (rx1565_cur)
  rx1565_restart:
.annotate 'line', 10
    if_null rx1565_debug, debug_1277
    rx1565_cur."!cursor_debug"("NEXT", "infix:sym<gt>")
  debug_1277:
  rx1565_fail:
    (rx1565_rep, rx1565_pos, $I10, $P10) = rx1565_cur."!mark_fail"(0)
    lt rx1565_pos, -1, rx1565_done
    eq rx1565_pos, -1, rx1565_fail
    jump $I10
  rx1565_done:
    rx1565_cur."!cursor_fail"()
    if_null rx1565_debug, debug_1278
    rx1565_cur."!cursor_debug"("FAIL", "infix:sym<gt>")
  debug_1278:
    .return (rx1565_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<gt>"  :nsentry("!PREFIX__infix:sym<gt>") :subid("351_1303340952.947") :method
.annotate 'line', 10
    $P1567 = self."!PREFIX__!subrule"("O", "gt")
    new $P1568, "ResizablePMCArray"
    push $P1568, $P1567
    .return ($P1568)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=:=>"  :subid("352_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1572_tgt
    .local int rx1572_pos
    .local int rx1572_off
    .local int rx1572_eos
    .local int rx1572_rep
    .local pmc rx1572_cur
    .local pmc rx1572_debug
    (rx1572_cur, rx1572_pos, rx1572_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1572_cur
    .local pmc match
    .lex "$/", match
    length rx1572_eos, rx1572_tgt
    gt rx1572_pos, rx1572_eos, rx1572_done
    set rx1572_off, 0
    lt rx1572_pos, 2, rx1572_start
    sub rx1572_off, rx1572_pos, 1
    substr rx1572_tgt, rx1572_tgt, rx1572_off
  rx1572_start:
    eq $I10, 1, rx1572_restart
    if_null rx1572_debug, debug_1279
    rx1572_cur."!cursor_debug"("START", "infix:sym<=:=>")
  debug_1279:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1576_done
    goto rxscan1576_scan
  rxscan1576_loop:
    (rx1572_pos) = rx1572_cur."from"()
    inc rx1572_pos
    rx1572_cur."!cursor_from"(rx1572_pos)
    ge rx1572_pos, rx1572_eos, rxscan1576_done
  rxscan1576_scan:
    set_addr $I10, rxscan1576_loop
    rx1572_cur."!mark_push"(0, rx1572_pos, $I10)
  rxscan1576_done:
.annotate 'line', 667
  # rx subcapture "sym"
    set_addr $I10, rxcap_1577_fail
    rx1572_cur."!mark_push"(0, rx1572_pos, $I10)
  # rx literal  "=:="
    add $I11, rx1572_pos, 3
    gt $I11, rx1572_eos, rx1572_fail
    sub $I11, rx1572_pos, rx1572_off
    substr $S10, rx1572_tgt, $I11, 3
    ne $S10, "=:=", rx1572_fail
    add rx1572_pos, 3
    set_addr $I10, rxcap_1577_fail
    ($I12, $I11) = rx1572_cur."!mark_peek"($I10)
    rx1572_cur."!cursor_pos"($I11)
    ($P10) = rx1572_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1572_pos, "")
    rx1572_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1577_done
  rxcap_1577_fail:
    goto rx1572_fail
  rxcap_1577_done:
  # rx subrule "O" subtype=capture negate=
    rx1572_cur."!cursor_pos"(rx1572_pos)
    $P10 = rx1572_cur."O"("%relational, :pirop<issame>")
    unless $P10, rx1572_fail
    rx1572_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1572_pos = $P10."pos"()
  # rx pass
    rx1572_cur."!cursor_pass"(rx1572_pos, "infix:sym<=:=>")
    if_null rx1572_debug, debug_1280
    rx1572_cur."!cursor_debug"("PASS", "infix:sym<=:=>", " at pos=", rx1572_pos)
  debug_1280:
    .return (rx1572_cur)
  rx1572_restart:
.annotate 'line', 10
    if_null rx1572_debug, debug_1281
    rx1572_cur."!cursor_debug"("NEXT", "infix:sym<=:=>")
  debug_1281:
  rx1572_fail:
    (rx1572_rep, rx1572_pos, $I10, $P10) = rx1572_cur."!mark_fail"(0)
    lt rx1572_pos, -1, rx1572_done
    eq rx1572_pos, -1, rx1572_fail
    jump $I10
  rx1572_done:
    rx1572_cur."!cursor_fail"()
    if_null rx1572_debug, debug_1282
    rx1572_cur."!cursor_debug"("FAIL", "infix:sym<=:=>")
  debug_1282:
    .return (rx1572_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=:=>"  :nsentry("!PREFIX__infix:sym<=:=>") :subid("353_1303340952.947") :method
.annotate 'line', 10
    $P1574 = self."!PREFIX__!subrule"("O", "=:=")
    new $P1575, "ResizablePMCArray"
    push $P1575, $P1574
    .return ($P1575)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~~>"  :subid("354_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1579_tgt
    .local int rx1579_pos
    .local int rx1579_off
    .local int rx1579_eos
    .local int rx1579_rep
    .local pmc rx1579_cur
    .local pmc rx1579_debug
    (rx1579_cur, rx1579_pos, rx1579_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1579_cur
    .local pmc match
    .lex "$/", match
    length rx1579_eos, rx1579_tgt
    gt rx1579_pos, rx1579_eos, rx1579_done
    set rx1579_off, 0
    lt rx1579_pos, 2, rx1579_start
    sub rx1579_off, rx1579_pos, 1
    substr rx1579_tgt, rx1579_tgt, rx1579_off
  rx1579_start:
    eq $I10, 1, rx1579_restart
    if_null rx1579_debug, debug_1283
    rx1579_cur."!cursor_debug"("START", "infix:sym<~~>")
  debug_1283:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1583_done
    goto rxscan1583_scan
  rxscan1583_loop:
    (rx1579_pos) = rx1579_cur."from"()
    inc rx1579_pos
    rx1579_cur."!cursor_from"(rx1579_pos)
    ge rx1579_pos, rx1579_eos, rxscan1583_done
  rxscan1583_scan:
    set_addr $I10, rxscan1583_loop
    rx1579_cur."!mark_push"(0, rx1579_pos, $I10)
  rxscan1583_done:
.annotate 'line', 668
  # rx subcapture "sym"
    set_addr $I10, rxcap_1584_fail
    rx1579_cur."!mark_push"(0, rx1579_pos, $I10)
  # rx literal  "~~"
    add $I11, rx1579_pos, 2
    gt $I11, rx1579_eos, rx1579_fail
    sub $I11, rx1579_pos, rx1579_off
    substr $S10, rx1579_tgt, $I11, 2
    ne $S10, "~~", rx1579_fail
    add rx1579_pos, 2
    set_addr $I10, rxcap_1584_fail
    ($I12, $I11) = rx1579_cur."!mark_peek"($I10)
    rx1579_cur."!cursor_pos"($I11)
    ($P10) = rx1579_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1579_pos, "")
    rx1579_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1584_done
  rxcap_1584_fail:
    goto rx1579_fail
  rxcap_1584_done:
  # rx subrule "O" subtype=capture negate=
    rx1579_cur."!cursor_pos"(rx1579_pos)
    $P10 = rx1579_cur."O"("%relational, :reducecheck<smartmatch>")
    unless $P10, rx1579_fail
    rx1579_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1579_pos = $P10."pos"()
  # rx pass
    rx1579_cur."!cursor_pass"(rx1579_pos, "infix:sym<~~>")
    if_null rx1579_debug, debug_1284
    rx1579_cur."!cursor_debug"("PASS", "infix:sym<~~>", " at pos=", rx1579_pos)
  debug_1284:
    .return (rx1579_cur)
  rx1579_restart:
.annotate 'line', 10
    if_null rx1579_debug, debug_1285
    rx1579_cur."!cursor_debug"("NEXT", "infix:sym<~~>")
  debug_1285:
  rx1579_fail:
    (rx1579_rep, rx1579_pos, $I10, $P10) = rx1579_cur."!mark_fail"(0)
    lt rx1579_pos, -1, rx1579_done
    eq rx1579_pos, -1, rx1579_fail
    jump $I10
  rx1579_done:
    rx1579_cur."!cursor_fail"()
    if_null rx1579_debug, debug_1286
    rx1579_cur."!cursor_debug"("FAIL", "infix:sym<~~>")
  debug_1286:
    .return (rx1579_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~~>"  :nsentry("!PREFIX__infix:sym<~~>") :subid("355_1303340952.947") :method
.annotate 'line', 10
    $P1581 = self."!PREFIX__!subrule"("O", "~~")
    new $P1582, "ResizablePMCArray"
    push $P1582, $P1581
    .return ($P1582)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<&&>"  :subid("356_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1586_tgt
    .local int rx1586_pos
    .local int rx1586_off
    .local int rx1586_eos
    .local int rx1586_rep
    .local pmc rx1586_cur
    .local pmc rx1586_debug
    (rx1586_cur, rx1586_pos, rx1586_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1586_cur
    .local pmc match
    .lex "$/", match
    length rx1586_eos, rx1586_tgt
    gt rx1586_pos, rx1586_eos, rx1586_done
    set rx1586_off, 0
    lt rx1586_pos, 2, rx1586_start
    sub rx1586_off, rx1586_pos, 1
    substr rx1586_tgt, rx1586_tgt, rx1586_off
  rx1586_start:
    eq $I10, 1, rx1586_restart
    if_null rx1586_debug, debug_1287
    rx1586_cur."!cursor_debug"("START", "infix:sym<&&>")
  debug_1287:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1590_done
    goto rxscan1590_scan
  rxscan1590_loop:
    (rx1586_pos) = rx1586_cur."from"()
    inc rx1586_pos
    rx1586_cur."!cursor_from"(rx1586_pos)
    ge rx1586_pos, rx1586_eos, rxscan1590_done
  rxscan1590_scan:
    set_addr $I10, rxscan1590_loop
    rx1586_cur."!mark_push"(0, rx1586_pos, $I10)
  rxscan1590_done:
.annotate 'line', 670
  # rx subcapture "sym"
    set_addr $I10, rxcap_1591_fail
    rx1586_cur."!mark_push"(0, rx1586_pos, $I10)
  # rx literal  "&&"
    add $I11, rx1586_pos, 2
    gt $I11, rx1586_eos, rx1586_fail
    sub $I11, rx1586_pos, rx1586_off
    substr $S10, rx1586_tgt, $I11, 2
    ne $S10, "&&", rx1586_fail
    add rx1586_pos, 2
    set_addr $I10, rxcap_1591_fail
    ($I12, $I11) = rx1586_cur."!mark_peek"($I10)
    rx1586_cur."!cursor_pos"($I11)
    ($P10) = rx1586_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1586_pos, "")
    rx1586_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1591_done
  rxcap_1591_fail:
    goto rx1586_fail
  rxcap_1591_done:
  # rx subrule "O" subtype=capture negate=
    rx1586_cur."!cursor_pos"(rx1586_pos)
    $P10 = rx1586_cur."O"("%tight_and, :pasttype<if>")
    unless $P10, rx1586_fail
    rx1586_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1586_pos = $P10."pos"()
  # rx pass
    rx1586_cur."!cursor_pass"(rx1586_pos, "infix:sym<&&>")
    if_null rx1586_debug, debug_1288
    rx1586_cur."!cursor_debug"("PASS", "infix:sym<&&>", " at pos=", rx1586_pos)
  debug_1288:
    .return (rx1586_cur)
  rx1586_restart:
.annotate 'line', 10
    if_null rx1586_debug, debug_1289
    rx1586_cur."!cursor_debug"("NEXT", "infix:sym<&&>")
  debug_1289:
  rx1586_fail:
    (rx1586_rep, rx1586_pos, $I10, $P10) = rx1586_cur."!mark_fail"(0)
    lt rx1586_pos, -1, rx1586_done
    eq rx1586_pos, -1, rx1586_fail
    jump $I10
  rx1586_done:
    rx1586_cur."!cursor_fail"()
    if_null rx1586_debug, debug_1290
    rx1586_cur."!cursor_debug"("FAIL", "infix:sym<&&>")
  debug_1290:
    .return (rx1586_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<&&>"  :nsentry("!PREFIX__infix:sym<&&>") :subid("357_1303340952.947") :method
.annotate 'line', 10
    $P1588 = self."!PREFIX__!subrule"("O", "&&")
    new $P1589, "ResizablePMCArray"
    push $P1589, $P1588
    .return ($P1589)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<||>"  :subid("358_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1593_tgt
    .local int rx1593_pos
    .local int rx1593_off
    .local int rx1593_eos
    .local int rx1593_rep
    .local pmc rx1593_cur
    .local pmc rx1593_debug
    (rx1593_cur, rx1593_pos, rx1593_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1593_cur
    .local pmc match
    .lex "$/", match
    length rx1593_eos, rx1593_tgt
    gt rx1593_pos, rx1593_eos, rx1593_done
    set rx1593_off, 0
    lt rx1593_pos, 2, rx1593_start
    sub rx1593_off, rx1593_pos, 1
    substr rx1593_tgt, rx1593_tgt, rx1593_off
  rx1593_start:
    eq $I10, 1, rx1593_restart
    if_null rx1593_debug, debug_1291
    rx1593_cur."!cursor_debug"("START", "infix:sym<||>")
  debug_1291:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1597_done
    goto rxscan1597_scan
  rxscan1597_loop:
    (rx1593_pos) = rx1593_cur."from"()
    inc rx1593_pos
    rx1593_cur."!cursor_from"(rx1593_pos)
    ge rx1593_pos, rx1593_eos, rxscan1597_done
  rxscan1597_scan:
    set_addr $I10, rxscan1597_loop
    rx1593_cur."!mark_push"(0, rx1593_pos, $I10)
  rxscan1597_done:
.annotate 'line', 672
  # rx subcapture "sym"
    set_addr $I10, rxcap_1598_fail
    rx1593_cur."!mark_push"(0, rx1593_pos, $I10)
  # rx literal  "||"
    add $I11, rx1593_pos, 2
    gt $I11, rx1593_eos, rx1593_fail
    sub $I11, rx1593_pos, rx1593_off
    substr $S10, rx1593_tgt, $I11, 2
    ne $S10, "||", rx1593_fail
    add rx1593_pos, 2
    set_addr $I10, rxcap_1598_fail
    ($I12, $I11) = rx1593_cur."!mark_peek"($I10)
    rx1593_cur."!cursor_pos"($I11)
    ($P10) = rx1593_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1593_pos, "")
    rx1593_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1598_done
  rxcap_1598_fail:
    goto rx1593_fail
  rxcap_1598_done:
  # rx subrule "O" subtype=capture negate=
    rx1593_cur."!cursor_pos"(rx1593_pos)
    $P10 = rx1593_cur."O"("%tight_or, :pasttype<unless>")
    unless $P10, rx1593_fail
    rx1593_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1593_pos = $P10."pos"()
  # rx pass
    rx1593_cur."!cursor_pass"(rx1593_pos, "infix:sym<||>")
    if_null rx1593_debug, debug_1292
    rx1593_cur."!cursor_debug"("PASS", "infix:sym<||>", " at pos=", rx1593_pos)
  debug_1292:
    .return (rx1593_cur)
  rx1593_restart:
.annotate 'line', 10
    if_null rx1593_debug, debug_1293
    rx1593_cur."!cursor_debug"("NEXT", "infix:sym<||>")
  debug_1293:
  rx1593_fail:
    (rx1593_rep, rx1593_pos, $I10, $P10) = rx1593_cur."!mark_fail"(0)
    lt rx1593_pos, -1, rx1593_done
    eq rx1593_pos, -1, rx1593_fail
    jump $I10
  rx1593_done:
    rx1593_cur."!cursor_fail"()
    if_null rx1593_debug, debug_1294
    rx1593_cur."!cursor_debug"("FAIL", "infix:sym<||>")
  debug_1294:
    .return (rx1593_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<||>"  :nsentry("!PREFIX__infix:sym<||>") :subid("359_1303340952.947") :method
.annotate 'line', 10
    $P1595 = self."!PREFIX__!subrule"("O", "||")
    new $P1596, "ResizablePMCArray"
    push $P1596, $P1595
    .return ($P1596)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<//>"  :subid("360_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1600_tgt
    .local int rx1600_pos
    .local int rx1600_off
    .local int rx1600_eos
    .local int rx1600_rep
    .local pmc rx1600_cur
    .local pmc rx1600_debug
    (rx1600_cur, rx1600_pos, rx1600_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1600_cur
    .local pmc match
    .lex "$/", match
    length rx1600_eos, rx1600_tgt
    gt rx1600_pos, rx1600_eos, rx1600_done
    set rx1600_off, 0
    lt rx1600_pos, 2, rx1600_start
    sub rx1600_off, rx1600_pos, 1
    substr rx1600_tgt, rx1600_tgt, rx1600_off
  rx1600_start:
    eq $I10, 1, rx1600_restart
    if_null rx1600_debug, debug_1295
    rx1600_cur."!cursor_debug"("START", "infix:sym<//>")
  debug_1295:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1604_done
    goto rxscan1604_scan
  rxscan1604_loop:
    (rx1600_pos) = rx1600_cur."from"()
    inc rx1600_pos
    rx1600_cur."!cursor_from"(rx1600_pos)
    ge rx1600_pos, rx1600_eos, rxscan1604_done
  rxscan1604_scan:
    set_addr $I10, rxscan1604_loop
    rx1600_cur."!mark_push"(0, rx1600_pos, $I10)
  rxscan1604_done:
.annotate 'line', 673
  # rx subcapture "sym"
    set_addr $I10, rxcap_1605_fail
    rx1600_cur."!mark_push"(0, rx1600_pos, $I10)
  # rx literal  "//"
    add $I11, rx1600_pos, 2
    gt $I11, rx1600_eos, rx1600_fail
    sub $I11, rx1600_pos, rx1600_off
    substr $S10, rx1600_tgt, $I11, 2
    ne $S10, "//", rx1600_fail
    add rx1600_pos, 2
    set_addr $I10, rxcap_1605_fail
    ($I12, $I11) = rx1600_cur."!mark_peek"($I10)
    rx1600_cur."!cursor_pos"($I11)
    ($P10) = rx1600_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1600_pos, "")
    rx1600_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1605_done
  rxcap_1605_fail:
    goto rx1600_fail
  rxcap_1605_done:
  # rx subrule "O" subtype=capture negate=
    rx1600_cur."!cursor_pos"(rx1600_pos)
    $P10 = rx1600_cur."O"("%tight_or, :pasttype<def_or>")
    unless $P10, rx1600_fail
    rx1600_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1600_pos = $P10."pos"()
  # rx pass
    rx1600_cur."!cursor_pass"(rx1600_pos, "infix:sym<//>")
    if_null rx1600_debug, debug_1296
    rx1600_cur."!cursor_debug"("PASS", "infix:sym<//>", " at pos=", rx1600_pos)
  debug_1296:
    .return (rx1600_cur)
  rx1600_restart:
.annotate 'line', 10
    if_null rx1600_debug, debug_1297
    rx1600_cur."!cursor_debug"("NEXT", "infix:sym<//>")
  debug_1297:
  rx1600_fail:
    (rx1600_rep, rx1600_pos, $I10, $P10) = rx1600_cur."!mark_fail"(0)
    lt rx1600_pos, -1, rx1600_done
    eq rx1600_pos, -1, rx1600_fail
    jump $I10
  rx1600_done:
    rx1600_cur."!cursor_fail"()
    if_null rx1600_debug, debug_1298
    rx1600_cur."!cursor_debug"("FAIL", "infix:sym<//>")
  debug_1298:
    .return (rx1600_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<//>"  :nsentry("!PREFIX__infix:sym<//>") :subid("361_1303340952.947") :method
.annotate 'line', 10
    $P1602 = self."!PREFIX__!subrule"("O", "//")
    new $P1603, "ResizablePMCArray"
    push $P1603, $P1602
    .return ($P1603)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<?? !!>"  :subid("362_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1607_tgt
    .local int rx1607_pos
    .local int rx1607_off
    .local int rx1607_eos
    .local int rx1607_rep
    .local pmc rx1607_cur
    .local pmc rx1607_debug
    (rx1607_cur, rx1607_pos, rx1607_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1607_cur
    .local pmc match
    .lex "$/", match
    length rx1607_eos, rx1607_tgt
    gt rx1607_pos, rx1607_eos, rx1607_done
    set rx1607_off, 0
    lt rx1607_pos, 2, rx1607_start
    sub rx1607_off, rx1607_pos, 1
    substr rx1607_tgt, rx1607_tgt, rx1607_off
  rx1607_start:
    eq $I10, 1, rx1607_restart
    if_null rx1607_debug, debug_1299
    rx1607_cur."!cursor_debug"("START", "infix:sym<?? !!>")
  debug_1299:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1611_done
    goto rxscan1611_scan
  rxscan1611_loop:
    (rx1607_pos) = rx1607_cur."from"()
    inc rx1607_pos
    rx1607_cur."!cursor_from"(rx1607_pos)
    ge rx1607_pos, rx1607_eos, rxscan1611_done
  rxscan1611_scan:
    set_addr $I10, rxscan1611_loop
    rx1607_cur."!mark_push"(0, rx1607_pos, $I10)
  rxscan1611_done:
.annotate 'line', 676
  # rx literal  "??"
    add $I11, rx1607_pos, 2
    gt $I11, rx1607_eos, rx1607_fail
    sub $I11, rx1607_pos, rx1607_off
    substr $S10, rx1607_tgt, $I11, 2
    ne $S10, "??", rx1607_fail
    add rx1607_pos, 2
.annotate 'line', 677
  # rx subrule "ws" subtype=method negate=
    rx1607_cur."!cursor_pos"(rx1607_pos)
    $P10 = rx1607_cur."ws"()
    unless $P10, rx1607_fail
    rx1607_pos = $P10."pos"()
.annotate 'line', 678
  # rx subrule "EXPR" subtype=capture negate=
    rx1607_cur."!cursor_pos"(rx1607_pos)
    $P10 = rx1607_cur."EXPR"("i=")
    unless $P10, rx1607_fail
    rx1607_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1607_pos = $P10."pos"()
.annotate 'line', 679
  # rx literal  "!!"
    add $I11, rx1607_pos, 2
    gt $I11, rx1607_eos, rx1607_fail
    sub $I11, rx1607_pos, rx1607_off
    substr $S10, rx1607_tgt, $I11, 2
    ne $S10, "!!", rx1607_fail
    add rx1607_pos, 2
.annotate 'line', 680
  # rx subrule "O" subtype=capture negate=
    rx1607_cur."!cursor_pos"(rx1607_pos)
    $P10 = rx1607_cur."O"("%conditional, :reducecheck<ternary>, :pasttype<if>")
    unless $P10, rx1607_fail
    rx1607_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1607_pos = $P10."pos"()
.annotate 'line', 675
  # rx pass
    rx1607_cur."!cursor_pass"(rx1607_pos, "infix:sym<?? !!>")
    if_null rx1607_debug, debug_1300
    rx1607_cur."!cursor_debug"("PASS", "infix:sym<?? !!>", " at pos=", rx1607_pos)
  debug_1300:
    .return (rx1607_cur)
  rx1607_restart:
.annotate 'line', 10
    if_null rx1607_debug, debug_1301
    rx1607_cur."!cursor_debug"("NEXT", "infix:sym<?? !!>")
  debug_1301:
  rx1607_fail:
    (rx1607_rep, rx1607_pos, $I10, $P10) = rx1607_cur."!mark_fail"(0)
    lt rx1607_pos, -1, rx1607_done
    eq rx1607_pos, -1, rx1607_fail
    jump $I10
  rx1607_done:
    rx1607_cur."!cursor_fail"()
    if_null rx1607_debug, debug_1302
    rx1607_cur."!cursor_debug"("FAIL", "infix:sym<?? !!>")
  debug_1302:
    .return (rx1607_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<?? !!>"  :nsentry("!PREFIX__infix:sym<?? !!>") :subid("363_1303340952.947") :method
.annotate 'line', 10
    $P1609 = self."!PREFIX__!subrule"("ws", "??")
    new $P1610, "ResizablePMCArray"
    push $P1610, $P1609
    .return ($P1610)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=>"  :subid("364_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1613_tgt
    .local int rx1613_pos
    .local int rx1613_off
    .local int rx1613_eos
    .local int rx1613_rep
    .local pmc rx1613_cur
    .local pmc rx1613_debug
    (rx1613_cur, rx1613_pos, rx1613_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1613_cur
    .local pmc match
    .lex "$/", match
    length rx1613_eos, rx1613_tgt
    gt rx1613_pos, rx1613_eos, rx1613_done
    set rx1613_off, 0
    lt rx1613_pos, 2, rx1613_start
    sub rx1613_off, rx1613_pos, 1
    substr rx1613_tgt, rx1613_tgt, rx1613_off
  rx1613_start:
    eq $I10, 1, rx1613_restart
    if_null rx1613_debug, debug_1303
    rx1613_cur."!cursor_debug"("START", "infix:sym<=>")
  debug_1303:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1617_done
    goto rxscan1617_scan
  rxscan1617_loop:
    (rx1613_pos) = rx1613_cur."from"()
    inc rx1613_pos
    rx1613_cur."!cursor_from"(rx1613_pos)
    ge rx1613_pos, rx1613_eos, rxscan1617_done
  rxscan1617_scan:
    set_addr $I10, rxscan1617_loop
    rx1613_cur."!mark_push"(0, rx1613_pos, $I10)
  rxscan1617_done:
.annotate 'line', 684
  # rx subcapture "sym"
    set_addr $I10, rxcap_1618_fail
    rx1613_cur."!mark_push"(0, rx1613_pos, $I10)
  # rx literal  "="
    add $I11, rx1613_pos, 1
    gt $I11, rx1613_eos, rx1613_fail
    sub $I11, rx1613_pos, rx1613_off
    ord $I11, rx1613_tgt, $I11
    ne $I11, 61, rx1613_fail
    add rx1613_pos, 1
    set_addr $I10, rxcap_1618_fail
    ($I12, $I11) = rx1613_cur."!mark_peek"($I10)
    rx1613_cur."!cursor_pos"($I11)
    ($P10) = rx1613_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1613_pos, "")
    rx1613_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1618_done
  rxcap_1618_fail:
    goto rx1613_fail
  rxcap_1618_done:
  # rx subrule "panic" subtype=method negate=
    rx1613_cur."!cursor_pos"(rx1613_pos)
    $P10 = rx1613_cur."panic"("Assignment (\"=\") not supported in NQP, use \":=\" instead")
    unless $P10, rx1613_fail
    rx1613_pos = $P10."pos"()
.annotate 'line', 683
  # rx pass
    rx1613_cur."!cursor_pass"(rx1613_pos, "infix:sym<=>")
    if_null rx1613_debug, debug_1304
    rx1613_cur."!cursor_debug"("PASS", "infix:sym<=>", " at pos=", rx1613_pos)
  debug_1304:
    .return (rx1613_cur)
  rx1613_restart:
.annotate 'line', 10
    if_null rx1613_debug, debug_1305
    rx1613_cur."!cursor_debug"("NEXT", "infix:sym<=>")
  debug_1305:
  rx1613_fail:
    (rx1613_rep, rx1613_pos, $I10, $P10) = rx1613_cur."!mark_fail"(0)
    lt rx1613_pos, -1, rx1613_done
    eq rx1613_pos, -1, rx1613_fail
    jump $I10
  rx1613_done:
    rx1613_cur."!cursor_fail"()
    if_null rx1613_debug, debug_1306
    rx1613_cur."!cursor_debug"("FAIL", "infix:sym<=>")
  debug_1306:
    .return (rx1613_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=>"  :nsentry("!PREFIX__infix:sym<=>") :subid("365_1303340952.947") :method
.annotate 'line', 10
    $P1615 = self."!PREFIX__!subrule"("panic", "=")
    new $P1616, "ResizablePMCArray"
    push $P1616, $P1615
    .return ($P1616)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<:=>"  :subid("366_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1620_tgt
    .local int rx1620_pos
    .local int rx1620_off
    .local int rx1620_eos
    .local int rx1620_rep
    .local pmc rx1620_cur
    .local pmc rx1620_debug
    (rx1620_cur, rx1620_pos, rx1620_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1620_cur
    .local pmc match
    .lex "$/", match
    length rx1620_eos, rx1620_tgt
    gt rx1620_pos, rx1620_eos, rx1620_done
    set rx1620_off, 0
    lt rx1620_pos, 2, rx1620_start
    sub rx1620_off, rx1620_pos, 1
    substr rx1620_tgt, rx1620_tgt, rx1620_off
  rx1620_start:
    eq $I10, 1, rx1620_restart
    if_null rx1620_debug, debug_1307
    rx1620_cur."!cursor_debug"("START", "infix:sym<:=>")
  debug_1307:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1624_done
    goto rxscan1624_scan
  rxscan1624_loop:
    (rx1620_pos) = rx1620_cur."from"()
    inc rx1620_pos
    rx1620_cur."!cursor_from"(rx1620_pos)
    ge rx1620_pos, rx1620_eos, rxscan1624_done
  rxscan1624_scan:
    set_addr $I10, rxscan1624_loop
    rx1620_cur."!mark_push"(0, rx1620_pos, $I10)
  rxscan1624_done:
.annotate 'line', 686
  # rx subcapture "sym"
    set_addr $I10, rxcap_1625_fail
    rx1620_cur."!mark_push"(0, rx1620_pos, $I10)
  # rx literal  ":="
    add $I11, rx1620_pos, 2
    gt $I11, rx1620_eos, rx1620_fail
    sub $I11, rx1620_pos, rx1620_off
    substr $S10, rx1620_tgt, $I11, 2
    ne $S10, ":=", rx1620_fail
    add rx1620_pos, 2
    set_addr $I10, rxcap_1625_fail
    ($I12, $I11) = rx1620_cur."!mark_peek"($I10)
    rx1620_cur."!cursor_pos"($I11)
    ($P10) = rx1620_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1620_pos, "")
    rx1620_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1625_done
  rxcap_1625_fail:
    goto rx1620_fail
  rxcap_1625_done:
  # rx subrule "O" subtype=capture negate=
    rx1620_cur."!cursor_pos"(rx1620_pos)
    $P10 = rx1620_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx1620_fail
    rx1620_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1620_pos = $P10."pos"()
  # rx pass
    rx1620_cur."!cursor_pass"(rx1620_pos, "infix:sym<:=>")
    if_null rx1620_debug, debug_1308
    rx1620_cur."!cursor_debug"("PASS", "infix:sym<:=>", " at pos=", rx1620_pos)
  debug_1308:
    .return (rx1620_cur)
  rx1620_restart:
.annotate 'line', 10
    if_null rx1620_debug, debug_1309
    rx1620_cur."!cursor_debug"("NEXT", "infix:sym<:=>")
  debug_1309:
  rx1620_fail:
    (rx1620_rep, rx1620_pos, $I10, $P10) = rx1620_cur."!mark_fail"(0)
    lt rx1620_pos, -1, rx1620_done
    eq rx1620_pos, -1, rx1620_fail
    jump $I10
  rx1620_done:
    rx1620_cur."!cursor_fail"()
    if_null rx1620_debug, debug_1310
    rx1620_cur."!cursor_debug"("FAIL", "infix:sym<:=>")
  debug_1310:
    .return (rx1620_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<:=>"  :nsentry("!PREFIX__infix:sym<:=>") :subid("367_1303340952.947") :method
.annotate 'line', 10
    $P1622 = self."!PREFIX__!subrule"("O", ":=")
    new $P1623, "ResizablePMCArray"
    push $P1623, $P1622
    .return ($P1623)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<::=>"  :subid("368_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1627_tgt
    .local int rx1627_pos
    .local int rx1627_off
    .local int rx1627_eos
    .local int rx1627_rep
    .local pmc rx1627_cur
    .local pmc rx1627_debug
    (rx1627_cur, rx1627_pos, rx1627_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1627_cur
    .local pmc match
    .lex "$/", match
    length rx1627_eos, rx1627_tgt
    gt rx1627_pos, rx1627_eos, rx1627_done
    set rx1627_off, 0
    lt rx1627_pos, 2, rx1627_start
    sub rx1627_off, rx1627_pos, 1
    substr rx1627_tgt, rx1627_tgt, rx1627_off
  rx1627_start:
    eq $I10, 1, rx1627_restart
    if_null rx1627_debug, debug_1311
    rx1627_cur."!cursor_debug"("START", "infix:sym<::=>")
  debug_1311:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1631_done
    goto rxscan1631_scan
  rxscan1631_loop:
    (rx1627_pos) = rx1627_cur."from"()
    inc rx1627_pos
    rx1627_cur."!cursor_from"(rx1627_pos)
    ge rx1627_pos, rx1627_eos, rxscan1631_done
  rxscan1631_scan:
    set_addr $I10, rxscan1631_loop
    rx1627_cur."!mark_push"(0, rx1627_pos, $I10)
  rxscan1631_done:
.annotate 'line', 687
  # rx subcapture "sym"
    set_addr $I10, rxcap_1632_fail
    rx1627_cur."!mark_push"(0, rx1627_pos, $I10)
  # rx literal  "::="
    add $I11, rx1627_pos, 3
    gt $I11, rx1627_eos, rx1627_fail
    sub $I11, rx1627_pos, rx1627_off
    substr $S10, rx1627_tgt, $I11, 3
    ne $S10, "::=", rx1627_fail
    add rx1627_pos, 3
    set_addr $I10, rxcap_1632_fail
    ($I12, $I11) = rx1627_cur."!mark_peek"($I10)
    rx1627_cur."!cursor_pos"($I11)
    ($P10) = rx1627_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1627_pos, "")
    rx1627_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1632_done
  rxcap_1632_fail:
    goto rx1627_fail
  rxcap_1632_done:
  # rx subrule "O" subtype=capture negate=
    rx1627_cur."!cursor_pos"(rx1627_pos)
    $P10 = rx1627_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx1627_fail
    rx1627_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1627_pos = $P10."pos"()
  # rx pass
    rx1627_cur."!cursor_pass"(rx1627_pos, "infix:sym<::=>")
    if_null rx1627_debug, debug_1312
    rx1627_cur."!cursor_debug"("PASS", "infix:sym<::=>", " at pos=", rx1627_pos)
  debug_1312:
    .return (rx1627_cur)
  rx1627_restart:
.annotate 'line', 10
    if_null rx1627_debug, debug_1313
    rx1627_cur."!cursor_debug"("NEXT", "infix:sym<::=>")
  debug_1313:
  rx1627_fail:
    (rx1627_rep, rx1627_pos, $I10, $P10) = rx1627_cur."!mark_fail"(0)
    lt rx1627_pos, -1, rx1627_done
    eq rx1627_pos, -1, rx1627_fail
    jump $I10
  rx1627_done:
    rx1627_cur."!cursor_fail"()
    if_null rx1627_debug, debug_1314
    rx1627_cur."!cursor_debug"("FAIL", "infix:sym<::=>")
  debug_1314:
    .return (rx1627_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<::=>"  :nsentry("!PREFIX__infix:sym<::=>") :subid("369_1303340952.947") :method
.annotate 'line', 10
    $P1629 = self."!PREFIX__!subrule"("O", "::=")
    new $P1630, "ResizablePMCArray"
    push $P1630, $P1629
    .return ($P1630)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<,>"  :subid("370_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1634_tgt
    .local int rx1634_pos
    .local int rx1634_off
    .local int rx1634_eos
    .local int rx1634_rep
    .local pmc rx1634_cur
    .local pmc rx1634_debug
    (rx1634_cur, rx1634_pos, rx1634_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1634_cur
    .local pmc match
    .lex "$/", match
    length rx1634_eos, rx1634_tgt
    gt rx1634_pos, rx1634_eos, rx1634_done
    set rx1634_off, 0
    lt rx1634_pos, 2, rx1634_start
    sub rx1634_off, rx1634_pos, 1
    substr rx1634_tgt, rx1634_tgt, rx1634_off
  rx1634_start:
    eq $I10, 1, rx1634_restart
    if_null rx1634_debug, debug_1315
    rx1634_cur."!cursor_debug"("START", "infix:sym<,>")
  debug_1315:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1638_done
    goto rxscan1638_scan
  rxscan1638_loop:
    (rx1634_pos) = rx1634_cur."from"()
    inc rx1634_pos
    rx1634_cur."!cursor_from"(rx1634_pos)
    ge rx1634_pos, rx1634_eos, rxscan1638_done
  rxscan1638_scan:
    set_addr $I10, rxscan1638_loop
    rx1634_cur."!mark_push"(0, rx1634_pos, $I10)
  rxscan1638_done:
.annotate 'line', 689
  # rx subcapture "sym"
    set_addr $I10, rxcap_1639_fail
    rx1634_cur."!mark_push"(0, rx1634_pos, $I10)
  # rx literal  ","
    add $I11, rx1634_pos, 1
    gt $I11, rx1634_eos, rx1634_fail
    sub $I11, rx1634_pos, rx1634_off
    ord $I11, rx1634_tgt, $I11
    ne $I11, 44, rx1634_fail
    add rx1634_pos, 1
    set_addr $I10, rxcap_1639_fail
    ($I12, $I11) = rx1634_cur."!mark_peek"($I10)
    rx1634_cur."!cursor_pos"($I11)
    ($P10) = rx1634_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1634_pos, "")
    rx1634_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1639_done
  rxcap_1639_fail:
    goto rx1634_fail
  rxcap_1639_done:
  # rx subrule "O" subtype=capture negate=
    rx1634_cur."!cursor_pos"(rx1634_pos)
    $P10 = rx1634_cur."O"("%comma, :pasttype<list>")
    unless $P10, rx1634_fail
    rx1634_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1634_pos = $P10."pos"()
  # rx pass
    rx1634_cur."!cursor_pass"(rx1634_pos, "infix:sym<,>")
    if_null rx1634_debug, debug_1316
    rx1634_cur."!cursor_debug"("PASS", "infix:sym<,>", " at pos=", rx1634_pos)
  debug_1316:
    .return (rx1634_cur)
  rx1634_restart:
.annotate 'line', 10
    if_null rx1634_debug, debug_1317
    rx1634_cur."!cursor_debug"("NEXT", "infix:sym<,>")
  debug_1317:
  rx1634_fail:
    (rx1634_rep, rx1634_pos, $I10, $P10) = rx1634_cur."!mark_fail"(0)
    lt rx1634_pos, -1, rx1634_done
    eq rx1634_pos, -1, rx1634_fail
    jump $I10
  rx1634_done:
    rx1634_cur."!cursor_fail"()
    if_null rx1634_debug, debug_1318
    rx1634_cur."!cursor_debug"("FAIL", "infix:sym<,>")
  debug_1318:
    .return (rx1634_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<,>"  :nsentry("!PREFIX__infix:sym<,>") :subid("371_1303340952.947") :method
.annotate 'line', 10
    $P1636 = self."!PREFIX__!subrule"("O", ",")
    new $P1637, "ResizablePMCArray"
    push $P1637, $P1636
    .return ($P1637)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<return>"  :subid("372_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .const 'Sub' $P1649 = "374_1303340952.947" 
    capture_lex $P1649
    .local string rx1641_tgt
    .local int rx1641_pos
    .local int rx1641_off
    .local int rx1641_eos
    .local int rx1641_rep
    .local pmc rx1641_cur
    .local pmc rx1641_debug
    (rx1641_cur, rx1641_pos, rx1641_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1641_cur
    .local pmc match
    .lex "$/", match
    length rx1641_eos, rx1641_tgt
    gt rx1641_pos, rx1641_eos, rx1641_done
    set rx1641_off, 0
    lt rx1641_pos, 2, rx1641_start
    sub rx1641_off, rx1641_pos, 1
    substr rx1641_tgt, rx1641_tgt, rx1641_off
  rx1641_start:
    eq $I10, 1, rx1641_restart
    if_null rx1641_debug, debug_1319
    rx1641_cur."!cursor_debug"("START", "prefix:sym<return>")
  debug_1319:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1644_done
    goto rxscan1644_scan
  rxscan1644_loop:
    (rx1641_pos) = rx1641_cur."from"()
    inc rx1641_pos
    rx1641_cur."!cursor_from"(rx1641_pos)
    ge rx1641_pos, rx1641_eos, rxscan1644_done
  rxscan1644_scan:
    set_addr $I10, rxscan1644_loop
    rx1641_cur."!mark_push"(0, rx1641_pos, $I10)
  rxscan1644_done:
.annotate 'line', 691
  # rx subcapture "sym"
    set_addr $I10, rxcap_1645_fail
    rx1641_cur."!mark_push"(0, rx1641_pos, $I10)
  # rx literal  "return"
    add $I11, rx1641_pos, 6
    gt $I11, rx1641_eos, rx1641_fail
    sub $I11, rx1641_pos, rx1641_off
    substr $S10, rx1641_tgt, $I11, 6
    ne $S10, "return", rx1641_fail
    add rx1641_pos, 6
    set_addr $I10, rxcap_1645_fail
    ($I12, $I11) = rx1641_cur."!mark_peek"($I10)
    rx1641_cur."!cursor_pos"($I11)
    ($P10) = rx1641_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1641_pos, "")
    rx1641_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1645_done
  rxcap_1645_fail:
    goto rx1641_fail
  rxcap_1645_done:
  # rx charclass s
    ge rx1641_pos, rx1641_eos, rx1641_fail
    sub $I10, rx1641_pos, rx1641_off
    is_cclass $I11, 32, rx1641_tgt, $I10
    unless $I11, rx1641_fail
    inc rx1641_pos
  # rx subrule "O" subtype=capture negate=
    rx1641_cur."!cursor_pos"(rx1641_pos)
    $P10 = rx1641_cur."O"("%list_prefix, :pasttype<return>")
    unless $P10, rx1641_fail
    rx1641_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1641_pos = $P10."pos"()
    rx1641_cur."!cursor_pos"(rx1641_pos)
    find_lex $P1646, unicode:"$\x{a2}"
    $P1647 = $P1646."MATCH"()
    store_lex "$/", $P1647
    .const 'Sub' $P1649 = "374_1303340952.947" 
    capture_lex $P1649
    $P1651 = $P1649()
  # rx pass
    rx1641_cur."!cursor_pass"(rx1641_pos, "prefix:sym<return>")
    if_null rx1641_debug, debug_1320
    rx1641_cur."!cursor_debug"("PASS", "prefix:sym<return>", " at pos=", rx1641_pos)
  debug_1320:
    .return (rx1641_cur)
  rx1641_restart:
.annotate 'line', 10
    if_null rx1641_debug, debug_1321
    rx1641_cur."!cursor_debug"("NEXT", "prefix:sym<return>")
  debug_1321:
  rx1641_fail:
    (rx1641_rep, rx1641_pos, $I10, $P10) = rx1641_cur."!mark_fail"(0)
    lt rx1641_pos, -1, rx1641_done
    eq rx1641_pos, -1, rx1641_fail
    jump $I10
  rx1641_done:
    rx1641_cur."!cursor_fail"()
    if_null rx1641_debug, debug_1322
    rx1641_cur."!cursor_debug"("FAIL", "prefix:sym<return>")
  debug_1322:
    .return (rx1641_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<return>"  :nsentry("!PREFIX__prefix:sym<return>") :subid("373_1303340952.947") :method
.annotate 'line', 10
    new $P1643, "ResizablePMCArray"
    push $P1643, "return"
    .return ($P1643)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1648"  :anon :subid("374_1303340952.947") :outer("372_1303340952.947")
.annotate 'line', 691
    new $P1650, "Integer"
    assign $P1650, 1
    store_dynamic_lex "$*RETURN_USED", $P1650
    .return ($P1650)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<make>"  :subid("375_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1653_tgt
    .local int rx1653_pos
    .local int rx1653_off
    .local int rx1653_eos
    .local int rx1653_rep
    .local pmc rx1653_cur
    .local pmc rx1653_debug
    (rx1653_cur, rx1653_pos, rx1653_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1653_cur
    .local pmc match
    .lex "$/", match
    length rx1653_eos, rx1653_tgt
    gt rx1653_pos, rx1653_eos, rx1653_done
    set rx1653_off, 0
    lt rx1653_pos, 2, rx1653_start
    sub rx1653_off, rx1653_pos, 1
    substr rx1653_tgt, rx1653_tgt, rx1653_off
  rx1653_start:
    eq $I10, 1, rx1653_restart
    if_null rx1653_debug, debug_1323
    rx1653_cur."!cursor_debug"("START", "prefix:sym<make>")
  debug_1323:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1656_done
    goto rxscan1656_scan
  rxscan1656_loop:
    (rx1653_pos) = rx1653_cur."from"()
    inc rx1653_pos
    rx1653_cur."!cursor_from"(rx1653_pos)
    ge rx1653_pos, rx1653_eos, rxscan1656_done
  rxscan1656_scan:
    set_addr $I10, rxscan1656_loop
    rx1653_cur."!mark_push"(0, rx1653_pos, $I10)
  rxscan1656_done:
.annotate 'line', 692
  # rx subcapture "sym"
    set_addr $I10, rxcap_1657_fail
    rx1653_cur."!mark_push"(0, rx1653_pos, $I10)
  # rx literal  "make"
    add $I11, rx1653_pos, 4
    gt $I11, rx1653_eos, rx1653_fail
    sub $I11, rx1653_pos, rx1653_off
    substr $S10, rx1653_tgt, $I11, 4
    ne $S10, "make", rx1653_fail
    add rx1653_pos, 4
    set_addr $I10, rxcap_1657_fail
    ($I12, $I11) = rx1653_cur."!mark_peek"($I10)
    rx1653_cur."!cursor_pos"($I11)
    ($P10) = rx1653_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1653_pos, "")
    rx1653_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1657_done
  rxcap_1657_fail:
    goto rx1653_fail
  rxcap_1657_done:
  # rx charclass s
    ge rx1653_pos, rx1653_eos, rx1653_fail
    sub $I10, rx1653_pos, rx1653_off
    is_cclass $I11, 32, rx1653_tgt, $I10
    unless $I11, rx1653_fail
    inc rx1653_pos
  # rx subrule "O" subtype=capture negate=
    rx1653_cur."!cursor_pos"(rx1653_pos)
    $P10 = rx1653_cur."O"("%list_prefix")
    unless $P10, rx1653_fail
    rx1653_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1653_pos = $P10."pos"()
  # rx pass
    rx1653_cur."!cursor_pass"(rx1653_pos, "prefix:sym<make>")
    if_null rx1653_debug, debug_1324
    rx1653_cur."!cursor_debug"("PASS", "prefix:sym<make>", " at pos=", rx1653_pos)
  debug_1324:
    .return (rx1653_cur)
  rx1653_restart:
.annotate 'line', 10
    if_null rx1653_debug, debug_1325
    rx1653_cur."!cursor_debug"("NEXT", "prefix:sym<make>")
  debug_1325:
  rx1653_fail:
    (rx1653_rep, rx1653_pos, $I10, $P10) = rx1653_cur."!mark_fail"(0)
    lt rx1653_pos, -1, rx1653_done
    eq rx1653_pos, -1, rx1653_fail
    jump $I10
  rx1653_done:
    rx1653_cur."!cursor_fail"()
    if_null rx1653_debug, debug_1326
    rx1653_cur."!cursor_debug"("FAIL", "prefix:sym<make>")
  debug_1326:
    .return (rx1653_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<make>"  :nsentry("!PREFIX__prefix:sym<make>") :subid("376_1303340952.947") :method
.annotate 'line', 10
    new $P1655, "ResizablePMCArray"
    push $P1655, "make"
    .return ($P1655)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<last>"  :subid("377_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1659_tgt
    .local int rx1659_pos
    .local int rx1659_off
    .local int rx1659_eos
    .local int rx1659_rep
    .local pmc rx1659_cur
    .local pmc rx1659_debug
    (rx1659_cur, rx1659_pos, rx1659_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1659_cur
    .local pmc match
    .lex "$/", match
    length rx1659_eos, rx1659_tgt
    gt rx1659_pos, rx1659_eos, rx1659_done
    set rx1659_off, 0
    lt rx1659_pos, 2, rx1659_start
    sub rx1659_off, rx1659_pos, 1
    substr rx1659_tgt, rx1659_tgt, rx1659_off
  rx1659_start:
    eq $I10, 1, rx1659_restart
    if_null rx1659_debug, debug_1327
    rx1659_cur."!cursor_debug"("START", "term:sym<last>")
  debug_1327:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1662_done
    goto rxscan1662_scan
  rxscan1662_loop:
    (rx1659_pos) = rx1659_cur."from"()
    inc rx1659_pos
    rx1659_cur."!cursor_from"(rx1659_pos)
    ge rx1659_pos, rx1659_eos, rxscan1662_done
  rxscan1662_scan:
    set_addr $I10, rxscan1662_loop
    rx1659_cur."!mark_push"(0, rx1659_pos, $I10)
  rxscan1662_done:
.annotate 'line', 693
  # rx subcapture "sym"
    set_addr $I10, rxcap_1663_fail
    rx1659_cur."!mark_push"(0, rx1659_pos, $I10)
  # rx literal  "last"
    add $I11, rx1659_pos, 4
    gt $I11, rx1659_eos, rx1659_fail
    sub $I11, rx1659_pos, rx1659_off
    substr $S10, rx1659_tgt, $I11, 4
    ne $S10, "last", rx1659_fail
    add rx1659_pos, 4
    set_addr $I10, rxcap_1663_fail
    ($I12, $I11) = rx1659_cur."!mark_peek"($I10)
    rx1659_cur."!cursor_pos"($I11)
    ($P10) = rx1659_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1659_pos, "")
    rx1659_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1663_done
  rxcap_1663_fail:
    goto rx1659_fail
  rxcap_1663_done:
  # rx pass
    rx1659_cur."!cursor_pass"(rx1659_pos, "term:sym<last>")
    if_null rx1659_debug, debug_1328
    rx1659_cur."!cursor_debug"("PASS", "term:sym<last>", " at pos=", rx1659_pos)
  debug_1328:
    .return (rx1659_cur)
  rx1659_restart:
.annotate 'line', 10
    if_null rx1659_debug, debug_1329
    rx1659_cur."!cursor_debug"("NEXT", "term:sym<last>")
  debug_1329:
  rx1659_fail:
    (rx1659_rep, rx1659_pos, $I10, $P10) = rx1659_cur."!mark_fail"(0)
    lt rx1659_pos, -1, rx1659_done
    eq rx1659_pos, -1, rx1659_fail
    jump $I10
  rx1659_done:
    rx1659_cur."!cursor_fail"()
    if_null rx1659_debug, debug_1330
    rx1659_cur."!cursor_debug"("FAIL", "term:sym<last>")
  debug_1330:
    .return (rx1659_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<last>"  :nsentry("!PREFIX__term:sym<last>") :subid("378_1303340952.947") :method
.annotate 'line', 10
    new $P1661, "ResizablePMCArray"
    push $P1661, "last"
    .return ($P1661)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<next>"  :subid("379_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1665_tgt
    .local int rx1665_pos
    .local int rx1665_off
    .local int rx1665_eos
    .local int rx1665_rep
    .local pmc rx1665_cur
    .local pmc rx1665_debug
    (rx1665_cur, rx1665_pos, rx1665_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1665_cur
    .local pmc match
    .lex "$/", match
    length rx1665_eos, rx1665_tgt
    gt rx1665_pos, rx1665_eos, rx1665_done
    set rx1665_off, 0
    lt rx1665_pos, 2, rx1665_start
    sub rx1665_off, rx1665_pos, 1
    substr rx1665_tgt, rx1665_tgt, rx1665_off
  rx1665_start:
    eq $I10, 1, rx1665_restart
    if_null rx1665_debug, debug_1331
    rx1665_cur."!cursor_debug"("START", "term:sym<next>")
  debug_1331:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1668_done
    goto rxscan1668_scan
  rxscan1668_loop:
    (rx1665_pos) = rx1665_cur."from"()
    inc rx1665_pos
    rx1665_cur."!cursor_from"(rx1665_pos)
    ge rx1665_pos, rx1665_eos, rxscan1668_done
  rxscan1668_scan:
    set_addr $I10, rxscan1668_loop
    rx1665_cur."!mark_push"(0, rx1665_pos, $I10)
  rxscan1668_done:
.annotate 'line', 694
  # rx subcapture "sym"
    set_addr $I10, rxcap_1669_fail
    rx1665_cur."!mark_push"(0, rx1665_pos, $I10)
  # rx literal  "next"
    add $I11, rx1665_pos, 4
    gt $I11, rx1665_eos, rx1665_fail
    sub $I11, rx1665_pos, rx1665_off
    substr $S10, rx1665_tgt, $I11, 4
    ne $S10, "next", rx1665_fail
    add rx1665_pos, 4
    set_addr $I10, rxcap_1669_fail
    ($I12, $I11) = rx1665_cur."!mark_peek"($I10)
    rx1665_cur."!cursor_pos"($I11)
    ($P10) = rx1665_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1665_pos, "")
    rx1665_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1669_done
  rxcap_1669_fail:
    goto rx1665_fail
  rxcap_1669_done:
  # rx pass
    rx1665_cur."!cursor_pass"(rx1665_pos, "term:sym<next>")
    if_null rx1665_debug, debug_1332
    rx1665_cur."!cursor_debug"("PASS", "term:sym<next>", " at pos=", rx1665_pos)
  debug_1332:
    .return (rx1665_cur)
  rx1665_restart:
.annotate 'line', 10
    if_null rx1665_debug, debug_1333
    rx1665_cur."!cursor_debug"("NEXT", "term:sym<next>")
  debug_1333:
  rx1665_fail:
    (rx1665_rep, rx1665_pos, $I10, $P10) = rx1665_cur."!mark_fail"(0)
    lt rx1665_pos, -1, rx1665_done
    eq rx1665_pos, -1, rx1665_fail
    jump $I10
  rx1665_done:
    rx1665_cur."!cursor_fail"()
    if_null rx1665_debug, debug_1334
    rx1665_cur."!cursor_debug"("FAIL", "term:sym<next>")
  debug_1334:
    .return (rx1665_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<next>"  :nsentry("!PREFIX__term:sym<next>") :subid("380_1303340952.947") :method
.annotate 'line', 10
    new $P1667, "ResizablePMCArray"
    push $P1667, "next"
    .return ($P1667)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<redo>"  :subid("381_1303340952.947") :method :outer("12_1303340952.947")
.annotate 'line', 10
    .local string rx1671_tgt
    .local int rx1671_pos
    .local int rx1671_off
    .local int rx1671_eos
    .local int rx1671_rep
    .local pmc rx1671_cur
    .local pmc rx1671_debug
    (rx1671_cur, rx1671_pos, rx1671_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1671_cur
    .local pmc match
    .lex "$/", match
    length rx1671_eos, rx1671_tgt
    gt rx1671_pos, rx1671_eos, rx1671_done
    set rx1671_off, 0
    lt rx1671_pos, 2, rx1671_start
    sub rx1671_off, rx1671_pos, 1
    substr rx1671_tgt, rx1671_tgt, rx1671_off
  rx1671_start:
    eq $I10, 1, rx1671_restart
    if_null rx1671_debug, debug_1335
    rx1671_cur."!cursor_debug"("START", "term:sym<redo>")
  debug_1335:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1674_done
    goto rxscan1674_scan
  rxscan1674_loop:
    (rx1671_pos) = rx1671_cur."from"()
    inc rx1671_pos
    rx1671_cur."!cursor_from"(rx1671_pos)
    ge rx1671_pos, rx1671_eos, rxscan1674_done
  rxscan1674_scan:
    set_addr $I10, rxscan1674_loop
    rx1671_cur."!mark_push"(0, rx1671_pos, $I10)
  rxscan1674_done:
.annotate 'line', 695
  # rx subcapture "sym"
    set_addr $I10, rxcap_1675_fail
    rx1671_cur."!mark_push"(0, rx1671_pos, $I10)
  # rx literal  "redo"
    add $I11, rx1671_pos, 4
    gt $I11, rx1671_eos, rx1671_fail
    sub $I11, rx1671_pos, rx1671_off
    substr $S10, rx1671_tgt, $I11, 4
    ne $S10, "redo", rx1671_fail
    add rx1671_pos, 4
    set_addr $I10, rxcap_1675_fail
    ($I12, $I11) = rx1671_cur."!mark_peek"($I10)
    rx1671_cur."!cursor_pos"($I11)
    ($P10) = rx1671_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1671_pos, "")
    rx1671_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1675_done
  rxcap_1675_fail:
    goto rx1671_fail
  rxcap_1675_done:
  # rx pass
    rx1671_cur."!cursor_pass"(rx1671_pos, "term:sym<redo>")
    if_null rx1671_debug, debug_1336
    rx1671_cur."!cursor_debug"("PASS", "term:sym<redo>", " at pos=", rx1671_pos)
  debug_1336:
    .return (rx1671_cur)
  rx1671_restart:
.annotate 'line', 10
    if_null rx1671_debug, debug_1337
    rx1671_cur."!cursor_debug"("NEXT", "term:sym<redo>")
  debug_1337:
  rx1671_fail:
    (rx1671_rep, rx1671_pos, $I10, $P10) = rx1671_cur."!mark_fail"(0)
    lt rx1671_pos, -1, rx1671_done
    eq rx1671_pos, -1, rx1671_fail
    jump $I10
  rx1671_done:
    rx1671_cur."!cursor_fail"()
    if_null rx1671_debug, debug_1338
    rx1671_cur."!cursor_debug"("FAIL", "term:sym<redo>")
  debug_1338:
    .return (rx1671_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<redo>"  :nsentry("!PREFIX__term:sym<redo>") :subid("382_1303340952.947") :method
.annotate 'line', 10
    new $P1673, "ResizablePMCArray"
    push $P1673, "redo"
    .return ($P1673)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "smartmatch"  :subid("383_1303340952.947") :outer("12_1303340952.947")
    .param pmc param_1677
    .param pmc param_1678
.annotate 'line', 697
    .lex "self", param_1677
    .lex "$/", param_1678
.annotate 'line', 699
    new $P1679, "Undef"
    .lex "$t", $P1679
    find_lex $P1680, "$/"
    unless_null $P1680, vivify_1339
    $P1680 = root_new ['parrot';'ResizablePMCArray']
  vivify_1339:
    set $P1681, $P1680[0]
    unless_null $P1681, vivify_1340
    new $P1681, "Undef"
  vivify_1340:
    store_lex "$t", $P1681
    find_lex $P1682, "$/"
    unless_null $P1682, vivify_1341
    $P1682 = root_new ['parrot';'ResizablePMCArray']
  vivify_1341:
    set $P1683, $P1682[1]
    unless_null $P1683, vivify_1342
    new $P1683, "Undef"
  vivify_1342:
    find_lex $P1684, "$/"
    unless_null $P1684, vivify_1343
    $P1684 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P1684
  vivify_1343:
    set $P1684[0], $P1683
    find_lex $P1685, "$t"
    unless_null $P1685, vivify_1344
    new $P1685, "Undef"
  vivify_1344:
    find_lex $P1686, "$/"
    unless_null $P1686, vivify_1345
    $P1686 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P1686
  vivify_1345:
    set $P1686[1], $P1685
.annotate 'line', 697
    .return ($P1685)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2411"  :subid("385_1303340952.947") :outer("10_1303340952.947")
.annotate 'line', 703
    .const 'Sub' $P2477 = "406_1303340952.947" 
    capture_lex $P2477
    .const 'Sub' $P2470 = "404_1303340952.947" 
    capture_lex $P2470
    .const 'Sub' $P2465 = "402_1303340952.947" 
    capture_lex $P2465
    .const 'Sub' $P2453 = "399_1303340952.947" 
    capture_lex $P2453
    .const 'Sub' $P2443 = "396_1303340952.947" 
    capture_lex $P2443
    .const 'Sub' $P2438 = "394_1303340952.947" 
    capture_lex $P2438
    .const 'Sub' $P2429 = "391_1303340952.947" 
    capture_lex $P2429
    .const 'Sub' $P2424 = "389_1303340952.947" 
    capture_lex $P2424
    .const 'Sub' $P2415 = "386_1303340952.947" 
    capture_lex $P2415
    .lex "$?PACKAGE", $P2413
    .lex "$?CLASS", $P2414
    .const 'Sub' $P2470 = "404_1303340952.947" 
    capture_lex $P2470
    .return ($P2470)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "" :load :init :subid("post1346") :outer("385_1303340952.947")
.annotate 'line', 703
    get_hll_global $P2412, ["NQP";"Regex"], "_block2411" 
    .local pmc block
    set block, $P2412
    .const 'Sub' $P2477 = "406_1303340952.947" 
    capture_lex $P2477
    $P2477()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2476"  :anon :subid("406_1303340952.947") :outer("385_1303340952.947")
.annotate 'line', 703
    nqp_get_sc_object $P2478, "1303340942.153", 2
    .local pmc type_obj
    set type_obj, $P2478
    get_how $P2479, type_obj
    .const 'Sub' $P2480 = "386_1303340952.947" 
    $P2479."add_method"(type_obj, "metachar:sym<:my>", $P2480)
    get_how $P2481, type_obj
    get_global $P2482, "!PREFIX__metachar:sym<:my>"
    $P2481."add_method"(type_obj, "!PREFIX__metachar:sym<:my>", $P2482)
    get_how $P2483, type_obj
    .const 'Sub' $P2484 = "389_1303340952.947" 
    $P2483."add_method"(type_obj, "metachar:sym<{ }>", $P2484)
    get_how $P2485, type_obj
    get_global $P2486, "!PREFIX__metachar:sym<{ }>"
    $P2485."add_method"(type_obj, "!PREFIX__metachar:sym<{ }>", $P2486)
    get_how $P2487, type_obj
    .const 'Sub' $P2488 = "391_1303340952.947" 
    $P2487."add_method"(type_obj, "metachar:sym<nqpvar>", $P2488)
    get_how $P2489, type_obj
    get_global $P2490, "!PREFIX__metachar:sym<nqpvar>"
    $P2489."add_method"(type_obj, "!PREFIX__metachar:sym<nqpvar>", $P2490)
    get_how $P2491, type_obj
    .const 'Sub' $P2492 = "394_1303340952.947" 
    $P2491."add_method"(type_obj, "assertion:sym<{ }>", $P2492)
    get_how $P2493, type_obj
    get_global $P2494, "!PREFIX__assertion:sym<{ }>"
    $P2493."add_method"(type_obj, "!PREFIX__assertion:sym<{ }>", $P2494)
    get_how $P2495, type_obj
    .const 'Sub' $P2496 = "396_1303340952.947" 
    $P2495."add_method"(type_obj, "assertion:sym<?{ }>", $P2496)
    get_how $P2497, type_obj
    get_global $P2498, "!PREFIX__assertion:sym<?{ }>"
    $P2497."add_method"(type_obj, "!PREFIX__assertion:sym<?{ }>", $P2498)
    get_how $P2499, type_obj
    .const 'Sub' $P2500 = "399_1303340952.947" 
    $P2499."add_method"(type_obj, "assertion:sym<name>", $P2500)
    get_how $P2501, type_obj
    get_global $P2502, "!PREFIX__assertion:sym<name>"
    $P2501."add_method"(type_obj, "!PREFIX__assertion:sym<name>", $P2502)
    get_how $P2503, type_obj
    .const 'Sub' $P2504 = "402_1303340952.947" 
    $P2503."add_method"(type_obj, "assertion:sym<var>", $P2504)
    get_how $P2505, type_obj
    get_global $P2506, "!PREFIX__assertion:sym<var>"
    $P2505."add_method"(type_obj, "!PREFIX__assertion:sym<var>", $P2506)
    get_how $P2507, type_obj
    .const 'Sub' $P2508 = "404_1303340952.947" 
    $P2507."add_method"(type_obj, "codeblock", $P2508)
    get_how $P2509, type_obj
    get_global $P2510, "!PREFIX__codeblock"
    $P2509."add_method"(type_obj, "!PREFIX__codeblock", $P2510)
    get_how $P2511, type_obj
    get_hll_global $P2512, ["Regex";"P6Regex"], "Grammar"
    $P2511."add_parent"(type_obj, $P2512)
    get_how $P2513, type_obj
    $P2514 = $P2513."compose"(type_obj)
    .return ($P2514)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<:my>"  :subid("386_1303340952.947") :method :outer("385_1303340952.947")
.annotate 'line', 703
    .const 'Sub' $P2421 = "388_1303340952.947" 
    capture_lex $P2421
    .local string rx2416_tgt
    .local int rx2416_pos
    .local int rx2416_off
    .local int rx2416_eos
    .local int rx2416_rep
    .local pmc rx2416_cur
    .local pmc rx2416_debug
    (rx2416_cur, rx2416_pos, rx2416_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2416_cur
    .local pmc match
    .lex "$/", match
    length rx2416_eos, rx2416_tgt
    gt rx2416_pos, rx2416_eos, rx2416_done
    set rx2416_off, 0
    lt rx2416_pos, 2, rx2416_start
    sub rx2416_off, rx2416_pos, 1
    substr rx2416_tgt, rx2416_tgt, rx2416_off
  rx2416_start:
    eq $I10, 1, rx2416_restart
    if_null rx2416_debug, debug_1347
    rx2416_cur."!cursor_debug"("START", "metachar:sym<:my>")
  debug_1347:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2419_done
    goto rxscan2419_scan
  rxscan2419_loop:
    (rx2416_pos) = rx2416_cur."from"()
    inc rx2416_pos
    rx2416_cur."!cursor_from"(rx2416_pos)
    ge rx2416_pos, rx2416_eos, rxscan2419_done
  rxscan2419_scan:
    set_addr $I10, rxscan2419_loop
    rx2416_cur."!mark_push"(0, rx2416_pos, $I10)
  rxscan2419_done:
.annotate 'line', 705
  # rx literal  ":"
    add $I11, rx2416_pos, 1
    gt $I11, rx2416_eos, rx2416_fail
    sub $I11, rx2416_pos, rx2416_off
    ord $I11, rx2416_tgt, $I11
    ne $I11, 58, rx2416_fail
    add rx2416_pos, 1
  # rx subrule "before" subtype=zerowidth negate=
    rx2416_cur."!cursor_pos"(rx2416_pos)
    .const 'Sub' $P2421 = "388_1303340952.947" 
    capture_lex $P2421
    $P10 = rx2416_cur."before"($P2421)
    unless $P10, rx2416_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2416_cur."!cursor_pos"(rx2416_pos)
    $P10 = rx2416_cur."LANG"("MAIN", "statement")
    unless $P10, rx2416_fail
    rx2416_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx2416_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2416_cur."!cursor_pos"(rx2416_pos)
    $P10 = rx2416_cur."ws"()
    unless $P10, rx2416_fail
    rx2416_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx2416_pos, 1
    gt $I11, rx2416_eos, rx2416_fail
    sub $I11, rx2416_pos, rx2416_off
    ord $I11, rx2416_tgt, $I11
    ne $I11, 59, rx2416_fail
    add rx2416_pos, 1
.annotate 'line', 704
  # rx pass
    rx2416_cur."!cursor_pass"(rx2416_pos, "metachar:sym<:my>")
    if_null rx2416_debug, debug_1352
    rx2416_cur."!cursor_debug"("PASS", "metachar:sym<:my>", " at pos=", rx2416_pos)
  debug_1352:
    .return (rx2416_cur)
  rx2416_restart:
.annotate 'line', 703
    if_null rx2416_debug, debug_1353
    rx2416_cur."!cursor_debug"("NEXT", "metachar:sym<:my>")
  debug_1353:
  rx2416_fail:
    (rx2416_rep, rx2416_pos, $I10, $P10) = rx2416_cur."!mark_fail"(0)
    lt rx2416_pos, -1, rx2416_done
    eq rx2416_pos, -1, rx2416_fail
    jump $I10
  rx2416_done:
    rx2416_cur."!cursor_fail"()
    if_null rx2416_debug, debug_1354
    rx2416_cur."!cursor_debug"("FAIL", "metachar:sym<:my>")
  debug_1354:
    .return (rx2416_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<:my>"  :nsentry("!PREFIX__metachar:sym<:my>") :subid("387_1303340952.947") :method
.annotate 'line', 703
    new $P2418, "ResizablePMCArray"
    push $P2418, ":"
    .return ($P2418)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2420"  :anon :subid("388_1303340952.947") :method :outer("386_1303340952.947")
.annotate 'line', 705
    .local string rx2422_tgt
    .local int rx2422_pos
    .local int rx2422_off
    .local int rx2422_eos
    .local int rx2422_rep
    .local pmc rx2422_cur
    .local pmc rx2422_debug
    (rx2422_cur, rx2422_pos, rx2422_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2422_cur
    .local pmc match
    .lex "$/", match
    length rx2422_eos, rx2422_tgt
    gt rx2422_pos, rx2422_eos, rx2422_done
    set rx2422_off, 0
    lt rx2422_pos, 2, rx2422_start
    sub rx2422_off, rx2422_pos, 1
    substr rx2422_tgt, rx2422_tgt, rx2422_off
  rx2422_start:
    eq $I10, 1, rx2422_restart
    if_null rx2422_debug, debug_1348
    rx2422_cur."!cursor_debug"("START", "")
  debug_1348:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2423_done
    goto rxscan2423_scan
  rxscan2423_loop:
    (rx2422_pos) = rx2422_cur."from"()
    inc rx2422_pos
    rx2422_cur."!cursor_from"(rx2422_pos)
    ge rx2422_pos, rx2422_eos, rxscan2423_done
  rxscan2423_scan:
    set_addr $I10, rxscan2423_loop
    rx2422_cur."!mark_push"(0, rx2422_pos, $I10)
  rxscan2423_done:
  # rx literal  "my"
    add $I11, rx2422_pos, 2
    gt $I11, rx2422_eos, rx2422_fail
    sub $I11, rx2422_pos, rx2422_off
    substr $S10, rx2422_tgt, $I11, 2
    ne $S10, "my", rx2422_fail
    add rx2422_pos, 2
  # rx pass
    rx2422_cur."!cursor_pass"(rx2422_pos, "")
    if_null rx2422_debug, debug_1349
    rx2422_cur."!cursor_debug"("PASS", "", " at pos=", rx2422_pos)
  debug_1349:
    .return (rx2422_cur)
  rx2422_restart:
    if_null rx2422_debug, debug_1350
    rx2422_cur."!cursor_debug"("NEXT", "")
  debug_1350:
  rx2422_fail:
    (rx2422_rep, rx2422_pos, $I10, $P10) = rx2422_cur."!mark_fail"(0)
    lt rx2422_pos, -1, rx2422_done
    eq rx2422_pos, -1, rx2422_fail
    jump $I10
  rx2422_done:
    rx2422_cur."!cursor_fail"()
    if_null rx2422_debug, debug_1351
    rx2422_cur."!cursor_debug"("FAIL", "")
  debug_1351:
    .return (rx2422_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<{ }>"  :subid("389_1303340952.947") :method :outer("385_1303340952.947")
.annotate 'line', 703
    .local string rx2425_tgt
    .local int rx2425_pos
    .local int rx2425_off
    .local int rx2425_eos
    .local int rx2425_rep
    .local pmc rx2425_cur
    .local pmc rx2425_debug
    (rx2425_cur, rx2425_pos, rx2425_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2425_cur
    .local pmc match
    .lex "$/", match
    length rx2425_eos, rx2425_tgt
    gt rx2425_pos, rx2425_eos, rx2425_done
    set rx2425_off, 0
    lt rx2425_pos, 2, rx2425_start
    sub rx2425_off, rx2425_pos, 1
    substr rx2425_tgt, rx2425_tgt, rx2425_off
  rx2425_start:
    eq $I10, 1, rx2425_restart
    if_null rx2425_debug, debug_1355
    rx2425_cur."!cursor_debug"("START", "metachar:sym<{ }>")
  debug_1355:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2428_done
    goto rxscan2428_scan
  rxscan2428_loop:
    (rx2425_pos) = rx2425_cur."from"()
    inc rx2425_pos
    rx2425_cur."!cursor_from"(rx2425_pos)
    ge rx2425_pos, rx2425_eos, rxscan2428_done
  rxscan2428_scan:
    set_addr $I10, rxscan2428_loop
    rx2425_cur."!mark_push"(0, rx2425_pos, $I10)
  rxscan2428_done:
.annotate 'line', 709
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2425_pos, rx2425_off
    substr $S10, rx2425_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2425_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx2425_cur."!cursor_pos"(rx2425_pos)
    $P10 = rx2425_cur."codeblock"()
    unless $P10, rx2425_fail
    rx2425_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2425_pos = $P10."pos"()
.annotate 'line', 708
  # rx pass
    rx2425_cur."!cursor_pass"(rx2425_pos, "metachar:sym<{ }>")
    if_null rx2425_debug, debug_1356
    rx2425_cur."!cursor_debug"("PASS", "metachar:sym<{ }>", " at pos=", rx2425_pos)
  debug_1356:
    .return (rx2425_cur)
  rx2425_restart:
.annotate 'line', 703
    if_null rx2425_debug, debug_1357
    rx2425_cur."!cursor_debug"("NEXT", "metachar:sym<{ }>")
  debug_1357:
  rx2425_fail:
    (rx2425_rep, rx2425_pos, $I10, $P10) = rx2425_cur."!mark_fail"(0)
    lt rx2425_pos, -1, rx2425_done
    eq rx2425_pos, -1, rx2425_fail
    jump $I10
  rx2425_done:
    rx2425_cur."!cursor_fail"()
    if_null rx2425_debug, debug_1358
    rx2425_cur."!cursor_debug"("FAIL", "metachar:sym<{ }>")
  debug_1358:
    .return (rx2425_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<{ }>"  :nsentry("!PREFIX__metachar:sym<{ }>") :subid("390_1303340952.947") :method
.annotate 'line', 703
    new $P2427, "ResizablePMCArray"
    push $P2427, "{"
    .return ($P2427)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<nqpvar>"  :subid("391_1303340952.947") :method :outer("385_1303340952.947")
.annotate 'line', 703
    .const 'Sub' $P2435 = "393_1303340952.947" 
    capture_lex $P2435
    .local string rx2430_tgt
    .local int rx2430_pos
    .local int rx2430_off
    .local int rx2430_eos
    .local int rx2430_rep
    .local pmc rx2430_cur
    .local pmc rx2430_debug
    (rx2430_cur, rx2430_pos, rx2430_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2430_cur
    .local pmc match
    .lex "$/", match
    length rx2430_eos, rx2430_tgt
    gt rx2430_pos, rx2430_eos, rx2430_done
    set rx2430_off, 0
    lt rx2430_pos, 2, rx2430_start
    sub rx2430_off, rx2430_pos, 1
    substr rx2430_tgt, rx2430_tgt, rx2430_off
  rx2430_start:
    eq $I10, 1, rx2430_restart
    if_null rx2430_debug, debug_1359
    rx2430_cur."!cursor_debug"("START", "metachar:sym<nqpvar>")
  debug_1359:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2433_done
    goto rxscan2433_scan
  rxscan2433_loop:
    (rx2430_pos) = rx2430_cur."from"()
    inc rx2430_pos
    rx2430_cur."!cursor_from"(rx2430_pos)
    ge rx2430_pos, rx2430_eos, rxscan2433_done
  rxscan2433_scan:
    set_addr $I10, rxscan2433_loop
    rx2430_cur."!mark_push"(0, rx2430_pos, $I10)
  rxscan2433_done:
.annotate 'line', 713
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2430_pos, rx2430_off
    substr $S10, rx2430_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx2430_fail
  # rx subrule "before" subtype=zerowidth negate=
    rx2430_cur."!cursor_pos"(rx2430_pos)
    .const 'Sub' $P2435 = "393_1303340952.947" 
    capture_lex $P2435
    $P10 = rx2430_cur."before"($P2435)
    unless $P10, rx2430_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2430_cur."!cursor_pos"(rx2430_pos)
    $P10 = rx2430_cur."LANG"("MAIN", "variable")
    unless $P10, rx2430_fail
    rx2430_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx2430_pos = $P10."pos"()
.annotate 'line', 712
  # rx pass
    rx2430_cur."!cursor_pass"(rx2430_pos, "metachar:sym<nqpvar>")
    if_null rx2430_debug, debug_1364
    rx2430_cur."!cursor_debug"("PASS", "metachar:sym<nqpvar>", " at pos=", rx2430_pos)
  debug_1364:
    .return (rx2430_cur)
  rx2430_restart:
.annotate 'line', 703
    if_null rx2430_debug, debug_1365
    rx2430_cur."!cursor_debug"("NEXT", "metachar:sym<nqpvar>")
  debug_1365:
  rx2430_fail:
    (rx2430_rep, rx2430_pos, $I10, $P10) = rx2430_cur."!mark_fail"(0)
    lt rx2430_pos, -1, rx2430_done
    eq rx2430_pos, -1, rx2430_fail
    jump $I10
  rx2430_done:
    rx2430_cur."!cursor_fail"()
    if_null rx2430_debug, debug_1366
    rx2430_cur."!cursor_debug"("FAIL", "metachar:sym<nqpvar>")
  debug_1366:
    .return (rx2430_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<nqpvar>"  :nsentry("!PREFIX__metachar:sym<nqpvar>") :subid("392_1303340952.947") :method
.annotate 'line', 703
    new $P2432, "ResizablePMCArray"
    push $P2432, "$"
    push $P2432, "@"
    .return ($P2432)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2434"  :anon :subid("393_1303340952.947") :method :outer("391_1303340952.947")
.annotate 'line', 713
    .local string rx2436_tgt
    .local int rx2436_pos
    .local int rx2436_off
    .local int rx2436_eos
    .local int rx2436_rep
    .local pmc rx2436_cur
    .local pmc rx2436_debug
    (rx2436_cur, rx2436_pos, rx2436_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2436_cur
    .local pmc match
    .lex "$/", match
    length rx2436_eos, rx2436_tgt
    gt rx2436_pos, rx2436_eos, rx2436_done
    set rx2436_off, 0
    lt rx2436_pos, 2, rx2436_start
    sub rx2436_off, rx2436_pos, 1
    substr rx2436_tgt, rx2436_tgt, rx2436_off
  rx2436_start:
    eq $I10, 1, rx2436_restart
    if_null rx2436_debug, debug_1360
    rx2436_cur."!cursor_debug"("START", "")
  debug_1360:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2437_done
    goto rxscan2437_scan
  rxscan2437_loop:
    (rx2436_pos) = rx2436_cur."from"()
    inc rx2436_pos
    rx2436_cur."!cursor_from"(rx2436_pos)
    ge rx2436_pos, rx2436_eos, rxscan2437_done
  rxscan2437_scan:
    set_addr $I10, rxscan2437_loop
    rx2436_cur."!mark_push"(0, rx2436_pos, $I10)
  rxscan2437_done:
  # rx charclass .
    ge rx2436_pos, rx2436_eos, rx2436_fail
    inc rx2436_pos
  # rx charclass w
    ge rx2436_pos, rx2436_eos, rx2436_fail
    sub $I10, rx2436_pos, rx2436_off
    is_cclass $I11, 8192, rx2436_tgt, $I10
    unless $I11, rx2436_fail
    inc rx2436_pos
  # rx pass
    rx2436_cur."!cursor_pass"(rx2436_pos, "")
    if_null rx2436_debug, debug_1361
    rx2436_cur."!cursor_debug"("PASS", "", " at pos=", rx2436_pos)
  debug_1361:
    .return (rx2436_cur)
  rx2436_restart:
    if_null rx2436_debug, debug_1362
    rx2436_cur."!cursor_debug"("NEXT", "")
  debug_1362:
  rx2436_fail:
    (rx2436_rep, rx2436_pos, $I10, $P10) = rx2436_cur."!mark_fail"(0)
    lt rx2436_pos, -1, rx2436_done
    eq rx2436_pos, -1, rx2436_fail
    jump $I10
  rx2436_done:
    rx2436_cur."!cursor_fail"()
    if_null rx2436_debug, debug_1363
    rx2436_cur."!cursor_debug"("FAIL", "")
  debug_1363:
    .return (rx2436_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<{ }>"  :subid("394_1303340952.947") :method :outer("385_1303340952.947")
.annotate 'line', 703
    .local string rx2439_tgt
    .local int rx2439_pos
    .local int rx2439_off
    .local int rx2439_eos
    .local int rx2439_rep
    .local pmc rx2439_cur
    .local pmc rx2439_debug
    (rx2439_cur, rx2439_pos, rx2439_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2439_cur
    .local pmc match
    .lex "$/", match
    length rx2439_eos, rx2439_tgt
    gt rx2439_pos, rx2439_eos, rx2439_done
    set rx2439_off, 0
    lt rx2439_pos, 2, rx2439_start
    sub rx2439_off, rx2439_pos, 1
    substr rx2439_tgt, rx2439_tgt, rx2439_off
  rx2439_start:
    eq $I10, 1, rx2439_restart
    if_null rx2439_debug, debug_1367
    rx2439_cur."!cursor_debug"("START", "assertion:sym<{ }>")
  debug_1367:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2442_done
    goto rxscan2442_scan
  rxscan2442_loop:
    (rx2439_pos) = rx2439_cur."from"()
    inc rx2439_pos
    rx2439_cur."!cursor_from"(rx2439_pos)
    ge rx2439_pos, rx2439_eos, rxscan2442_done
  rxscan2442_scan:
    set_addr $I10, rxscan2442_loop
    rx2439_cur."!mark_push"(0, rx2439_pos, $I10)
  rxscan2442_done:
.annotate 'line', 717
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2439_pos, rx2439_off
    substr $S10, rx2439_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2439_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx2439_cur."!cursor_pos"(rx2439_pos)
    $P10 = rx2439_cur."codeblock"()
    unless $P10, rx2439_fail
    rx2439_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2439_pos = $P10."pos"()
.annotate 'line', 716
  # rx pass
    rx2439_cur."!cursor_pass"(rx2439_pos, "assertion:sym<{ }>")
    if_null rx2439_debug, debug_1368
    rx2439_cur."!cursor_debug"("PASS", "assertion:sym<{ }>", " at pos=", rx2439_pos)
  debug_1368:
    .return (rx2439_cur)
  rx2439_restart:
.annotate 'line', 703
    if_null rx2439_debug, debug_1369
    rx2439_cur."!cursor_debug"("NEXT", "assertion:sym<{ }>")
  debug_1369:
  rx2439_fail:
    (rx2439_rep, rx2439_pos, $I10, $P10) = rx2439_cur."!mark_fail"(0)
    lt rx2439_pos, -1, rx2439_done
    eq rx2439_pos, -1, rx2439_fail
    jump $I10
  rx2439_done:
    rx2439_cur."!cursor_fail"()
    if_null rx2439_debug, debug_1370
    rx2439_cur."!cursor_debug"("FAIL", "assertion:sym<{ }>")
  debug_1370:
    .return (rx2439_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<{ }>"  :nsentry("!PREFIX__assertion:sym<{ }>") :subid("395_1303340952.947") :method
.annotate 'line', 703
    new $P2441, "ResizablePMCArray"
    push $P2441, "{"
    .return ($P2441)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<?{ }>"  :subid("396_1303340952.947") :method :outer("385_1303340952.947")
.annotate 'line', 703
    .const 'Sub' $P2449 = "398_1303340952.947" 
    capture_lex $P2449
    .local string rx2444_tgt
    .local int rx2444_pos
    .local int rx2444_off
    .local int rx2444_eos
    .local int rx2444_rep
    .local pmc rx2444_cur
    .local pmc rx2444_debug
    (rx2444_cur, rx2444_pos, rx2444_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2444_cur
    .local pmc match
    .lex "$/", match
    length rx2444_eos, rx2444_tgt
    gt rx2444_pos, rx2444_eos, rx2444_done
    set rx2444_off, 0
    lt rx2444_pos, 2, rx2444_start
    sub rx2444_off, rx2444_pos, 1
    substr rx2444_tgt, rx2444_tgt, rx2444_off
  rx2444_start:
    eq $I10, 1, rx2444_restart
    if_null rx2444_debug, debug_1371
    rx2444_cur."!cursor_debug"("START", "assertion:sym<?{ }>")
  debug_1371:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2447_done
    goto rxscan2447_scan
  rxscan2447_loop:
    (rx2444_pos) = rx2444_cur."from"()
    inc rx2444_pos
    rx2444_cur."!cursor_from"(rx2444_pos)
    ge rx2444_pos, rx2444_eos, rxscan2447_done
  rxscan2447_scan:
    set_addr $I10, rxscan2447_loop
    rx2444_cur."!mark_push"(0, rx2444_pos, $I10)
  rxscan2447_done:
.annotate 'line', 721
  # rx subcapture "zw"
    set_addr $I10, rxcap_2452_fail
    rx2444_cur."!mark_push"(0, rx2444_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx2444_pos, rx2444_eos, rx2444_fail
    sub $I10, rx2444_pos, rx2444_off
    substr $S10, rx2444_tgt, $I10, 1
    index $I11, "?!", $S10
    lt $I11, 0, rx2444_fail
    inc rx2444_pos
  # rx subrule "before" subtype=zerowidth negate=
    rx2444_cur."!cursor_pos"(rx2444_pos)
    .const 'Sub' $P2449 = "398_1303340952.947" 
    capture_lex $P2449
    $P10 = rx2444_cur."before"($P2449)
    unless $P10, rx2444_fail
    set_addr $I10, rxcap_2452_fail
    ($I12, $I11) = rx2444_cur."!mark_peek"($I10)
    rx2444_cur."!cursor_pos"($I11)
    ($P10) = rx2444_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2444_pos, "")
    rx2444_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("zw")
    goto rxcap_2452_done
  rxcap_2452_fail:
    goto rx2444_fail
  rxcap_2452_done:
  # rx subrule "codeblock" subtype=capture negate=
    rx2444_cur."!cursor_pos"(rx2444_pos)
    $P10 = rx2444_cur."codeblock"()
    unless $P10, rx2444_fail
    rx2444_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2444_pos = $P10."pos"()
.annotate 'line', 720
  # rx pass
    rx2444_cur."!cursor_pass"(rx2444_pos, "assertion:sym<?{ }>")
    if_null rx2444_debug, debug_1376
    rx2444_cur."!cursor_debug"("PASS", "assertion:sym<?{ }>", " at pos=", rx2444_pos)
  debug_1376:
    .return (rx2444_cur)
  rx2444_restart:
.annotate 'line', 703
    if_null rx2444_debug, debug_1377
    rx2444_cur."!cursor_debug"("NEXT", "assertion:sym<?{ }>")
  debug_1377:
  rx2444_fail:
    (rx2444_rep, rx2444_pos, $I10, $P10) = rx2444_cur."!mark_fail"(0)
    lt rx2444_pos, -1, rx2444_done
    eq rx2444_pos, -1, rx2444_fail
    jump $I10
  rx2444_done:
    rx2444_cur."!cursor_fail"()
    if_null rx2444_debug, debug_1378
    rx2444_cur."!cursor_debug"("FAIL", "assertion:sym<?{ }>")
  debug_1378:
    .return (rx2444_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<?{ }>"  :nsentry("!PREFIX__assertion:sym<?{ }>") :subid("397_1303340952.947") :method
.annotate 'line', 703
    new $P2446, "ResizablePMCArray"
    push $P2446, "!"
    push $P2446, "?"
    .return ($P2446)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2448"  :anon :subid("398_1303340952.947") :method :outer("396_1303340952.947")
.annotate 'line', 721
    .local string rx2450_tgt
    .local int rx2450_pos
    .local int rx2450_off
    .local int rx2450_eos
    .local int rx2450_rep
    .local pmc rx2450_cur
    .local pmc rx2450_debug
    (rx2450_cur, rx2450_pos, rx2450_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2450_cur
    .local pmc match
    .lex "$/", match
    length rx2450_eos, rx2450_tgt
    gt rx2450_pos, rx2450_eos, rx2450_done
    set rx2450_off, 0
    lt rx2450_pos, 2, rx2450_start
    sub rx2450_off, rx2450_pos, 1
    substr rx2450_tgt, rx2450_tgt, rx2450_off
  rx2450_start:
    eq $I10, 1, rx2450_restart
    if_null rx2450_debug, debug_1372
    rx2450_cur."!cursor_debug"("START", "")
  debug_1372:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2451_done
    goto rxscan2451_scan
  rxscan2451_loop:
    (rx2450_pos) = rx2450_cur."from"()
    inc rx2450_pos
    rx2450_cur."!cursor_from"(rx2450_pos)
    ge rx2450_pos, rx2450_eos, rxscan2451_done
  rxscan2451_scan:
    set_addr $I10, rxscan2451_loop
    rx2450_cur."!mark_push"(0, rx2450_pos, $I10)
  rxscan2451_done:
  # rx literal  "{"
    add $I11, rx2450_pos, 1
    gt $I11, rx2450_eos, rx2450_fail
    sub $I11, rx2450_pos, rx2450_off
    ord $I11, rx2450_tgt, $I11
    ne $I11, 123, rx2450_fail
    add rx2450_pos, 1
  # rx pass
    rx2450_cur."!cursor_pass"(rx2450_pos, "")
    if_null rx2450_debug, debug_1373
    rx2450_cur."!cursor_debug"("PASS", "", " at pos=", rx2450_pos)
  debug_1373:
    .return (rx2450_cur)
  rx2450_restart:
    if_null rx2450_debug, debug_1374
    rx2450_cur."!cursor_debug"("NEXT", "")
  debug_1374:
  rx2450_fail:
    (rx2450_rep, rx2450_pos, $I10, $P10) = rx2450_cur."!mark_fail"(0)
    lt rx2450_pos, -1, rx2450_done
    eq rx2450_pos, -1, rx2450_fail
    jump $I10
  rx2450_done:
    rx2450_cur."!cursor_fail"()
    if_null rx2450_debug, debug_1375
    rx2450_cur."!cursor_debug"("FAIL", "")
  debug_1375:
    .return (rx2450_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<name>"  :subid("399_1303340952.947") :method :outer("385_1303340952.947")
.annotate 'line', 703
    .const 'Sub' $P2462 = "401_1303340952.947" 
    capture_lex $P2462
    .local string rx2454_tgt
    .local int rx2454_pos
    .local int rx2454_off
    .local int rx2454_eos
    .local int rx2454_rep
    .local pmc rx2454_cur
    .local pmc rx2454_debug
    (rx2454_cur, rx2454_pos, rx2454_tgt, $I10) = self."!cursor_start"()
    rx2454_cur."!cursor_caparray"("assertion", "arglist", "nibbler")
    .lex unicode:"$\x{a2}", rx2454_cur
    .local pmc match
    .lex "$/", match
    length rx2454_eos, rx2454_tgt
    gt rx2454_pos, rx2454_eos, rx2454_done
    set rx2454_off, 0
    lt rx2454_pos, 2, rx2454_start
    sub rx2454_off, rx2454_pos, 1
    substr rx2454_tgt, rx2454_tgt, rx2454_off
  rx2454_start:
    eq $I10, 1, rx2454_restart
    if_null rx2454_debug, debug_1379
    rx2454_cur."!cursor_debug"("START", "assertion:sym<name>")
  debug_1379:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2458_done
    goto rxscan2458_scan
  rxscan2458_loop:
    (rx2454_pos) = rx2454_cur."from"()
    inc rx2454_pos
    rx2454_cur."!cursor_from"(rx2454_pos)
    ge rx2454_pos, rx2454_eos, rxscan2458_done
  rxscan2458_scan:
    set_addr $I10, rxscan2458_loop
    rx2454_cur."!mark_push"(0, rx2454_pos, $I10)
  rxscan2458_done:
.annotate 'line', 725
  # rx subrule "identifier" subtype=capture negate=
    rx2454_cur."!cursor_pos"(rx2454_pos)
    $P10 = rx2454_cur."identifier"()
    unless $P10, rx2454_fail
    rx2454_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx2454_pos = $P10."pos"()
.annotate 'line', 732
  # rx rxquantr2459 ** 0..1
    set_addr $I10, rxquantr2459_done
    rx2454_cur."!mark_push"(0, rx2454_pos, $I10)
  rxquantr2459_loop:
  alt2460_0:
.annotate 'line', 726
    set_addr $I10, alt2460_1
    rx2454_cur."!mark_push"(0, rx2454_pos, $I10)
.annotate 'line', 727
  # rx subrule "before" subtype=zerowidth negate=
    rx2454_cur."!cursor_pos"(rx2454_pos)
    .const 'Sub' $P2462 = "401_1303340952.947" 
    capture_lex $P2462
    $P10 = rx2454_cur."before"($P2462)
    unless $P10, rx2454_fail
    goto alt2460_end
  alt2460_1:
    set_addr $I10, alt2460_2
    rx2454_cur."!mark_push"(0, rx2454_pos, $I10)
.annotate 'line', 728
  # rx literal  "="
    add $I11, rx2454_pos, 1
    gt $I11, rx2454_eos, rx2454_fail
    sub $I11, rx2454_pos, rx2454_off
    ord $I11, rx2454_tgt, $I11
    ne $I11, 61, rx2454_fail
    add rx2454_pos, 1
  # rx subrule "assertion" subtype=capture negate=
    rx2454_cur."!cursor_pos"(rx2454_pos)
    $P10 = rx2454_cur."assertion"()
    unless $P10, rx2454_fail
    rx2454_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("assertion")
    rx2454_pos = $P10."pos"()
    goto alt2460_end
  alt2460_2:
    set_addr $I10, alt2460_3
    rx2454_cur."!mark_push"(0, rx2454_pos, $I10)
.annotate 'line', 729
  # rx literal  ":"
    add $I11, rx2454_pos, 1
    gt $I11, rx2454_eos, rx2454_fail
    sub $I11, rx2454_pos, rx2454_off
    ord $I11, rx2454_tgt, $I11
    ne $I11, 58, rx2454_fail
    add rx2454_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx2454_cur."!cursor_pos"(rx2454_pos)
    $P10 = rx2454_cur."arglist"()
    unless $P10, rx2454_fail
    rx2454_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2454_pos = $P10."pos"()
    goto alt2460_end
  alt2460_3:
    set_addr $I10, alt2460_4
    rx2454_cur."!mark_push"(0, rx2454_pos, $I10)
.annotate 'line', 730
  # rx literal  "("
    add $I11, rx2454_pos, 1
    gt $I11, rx2454_eos, rx2454_fail
    sub $I11, rx2454_pos, rx2454_off
    ord $I11, rx2454_tgt, $I11
    ne $I11, 40, rx2454_fail
    add rx2454_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx2454_cur."!cursor_pos"(rx2454_pos)
    $P10 = rx2454_cur."LANG"("MAIN", "arglist")
    unless $P10, rx2454_fail
    rx2454_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2454_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx2454_pos, 1
    gt $I11, rx2454_eos, rx2454_fail
    sub $I11, rx2454_pos, rx2454_off
    ord $I11, rx2454_tgt, $I11
    ne $I11, 41, rx2454_fail
    add rx2454_pos, 1
    goto alt2460_end
  alt2460_4:
.annotate 'line', 731
  # rx subrule "normspace" subtype=method negate=
    rx2454_cur."!cursor_pos"(rx2454_pos)
    $P10 = rx2454_cur."normspace"()
    unless $P10, rx2454_fail
    rx2454_pos = $P10."pos"()
  # rx subrule "nibbler" subtype=capture negate=
    rx2454_cur."!cursor_pos"(rx2454_pos)
    $P10 = rx2454_cur."nibbler"()
    unless $P10, rx2454_fail
    rx2454_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("nibbler")
    rx2454_pos = $P10."pos"()
  alt2460_end:
.annotate 'line', 732
    set_addr $I10, rxquantr2459_done
    (rx2454_rep) = rx2454_cur."!mark_commit"($I10)
  rxquantr2459_done:
.annotate 'line', 724
  # rx pass
    rx2454_cur."!cursor_pass"(rx2454_pos, "assertion:sym<name>")
    if_null rx2454_debug, debug_1384
    rx2454_cur."!cursor_debug"("PASS", "assertion:sym<name>", " at pos=", rx2454_pos)
  debug_1384:
    .return (rx2454_cur)
  rx2454_restart:
.annotate 'line', 703
    if_null rx2454_debug, debug_1385
    rx2454_cur."!cursor_debug"("NEXT", "assertion:sym<name>")
  debug_1385:
  rx2454_fail:
    (rx2454_rep, rx2454_pos, $I10, $P10) = rx2454_cur."!mark_fail"(0)
    lt rx2454_pos, -1, rx2454_done
    eq rx2454_pos, -1, rx2454_fail
    jump $I10
  rx2454_done:
    rx2454_cur."!cursor_fail"()
    if_null rx2454_debug, debug_1386
    rx2454_cur."!cursor_debug"("FAIL", "assertion:sym<name>")
  debug_1386:
    .return (rx2454_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<name>"  :nsentry("!PREFIX__assertion:sym<name>") :subid("400_1303340952.947") :method
.annotate 'line', 703
    $P2456 = self."!PREFIX__!subrule"("identifier", "")
    new $P2457, "ResizablePMCArray"
    push $P2457, $P2456
    .return ($P2457)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2461"  :anon :subid("401_1303340952.947") :method :outer("399_1303340952.947")
.annotate 'line', 727
    .local string rx2463_tgt
    .local int rx2463_pos
    .local int rx2463_off
    .local int rx2463_eos
    .local int rx2463_rep
    .local pmc rx2463_cur
    .local pmc rx2463_debug
    (rx2463_cur, rx2463_pos, rx2463_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2463_cur
    .local pmc match
    .lex "$/", match
    length rx2463_eos, rx2463_tgt
    gt rx2463_pos, rx2463_eos, rx2463_done
    set rx2463_off, 0
    lt rx2463_pos, 2, rx2463_start
    sub rx2463_off, rx2463_pos, 1
    substr rx2463_tgt, rx2463_tgt, rx2463_off
  rx2463_start:
    eq $I10, 1, rx2463_restart
    if_null rx2463_debug, debug_1380
    rx2463_cur."!cursor_debug"("START", "")
  debug_1380:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2464_done
    goto rxscan2464_scan
  rxscan2464_loop:
    (rx2463_pos) = rx2463_cur."from"()
    inc rx2463_pos
    rx2463_cur."!cursor_from"(rx2463_pos)
    ge rx2463_pos, rx2463_eos, rxscan2464_done
  rxscan2464_scan:
    set_addr $I10, rxscan2464_loop
    rx2463_cur."!mark_push"(0, rx2463_pos, $I10)
  rxscan2464_done:
  # rx literal  ">"
    add $I11, rx2463_pos, 1
    gt $I11, rx2463_eos, rx2463_fail
    sub $I11, rx2463_pos, rx2463_off
    ord $I11, rx2463_tgt, $I11
    ne $I11, 62, rx2463_fail
    add rx2463_pos, 1
  # rx pass
    rx2463_cur."!cursor_pass"(rx2463_pos, "")
    if_null rx2463_debug, debug_1381
    rx2463_cur."!cursor_debug"("PASS", "", " at pos=", rx2463_pos)
  debug_1381:
    .return (rx2463_cur)
  rx2463_restart:
    if_null rx2463_debug, debug_1382
    rx2463_cur."!cursor_debug"("NEXT", "")
  debug_1382:
  rx2463_fail:
    (rx2463_rep, rx2463_pos, $I10, $P10) = rx2463_cur."!mark_fail"(0)
    lt rx2463_pos, -1, rx2463_done
    eq rx2463_pos, -1, rx2463_fail
    jump $I10
  rx2463_done:
    rx2463_cur."!cursor_fail"()
    if_null rx2463_debug, debug_1383
    rx2463_cur."!cursor_debug"("FAIL", "")
  debug_1383:
    .return (rx2463_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<var>"  :subid("402_1303340952.947") :method :outer("385_1303340952.947")
.annotate 'line', 703
    .local string rx2466_tgt
    .local int rx2466_pos
    .local int rx2466_off
    .local int rx2466_eos
    .local int rx2466_rep
    .local pmc rx2466_cur
    .local pmc rx2466_debug
    (rx2466_cur, rx2466_pos, rx2466_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2466_cur
    .local pmc match
    .lex "$/", match
    length rx2466_eos, rx2466_tgt
    gt rx2466_pos, rx2466_eos, rx2466_done
    set rx2466_off, 0
    lt rx2466_pos, 2, rx2466_start
    sub rx2466_off, rx2466_pos, 1
    substr rx2466_tgt, rx2466_tgt, rx2466_off
  rx2466_start:
    eq $I10, 1, rx2466_restart
    if_null rx2466_debug, debug_1387
    rx2466_cur."!cursor_debug"("START", "assertion:sym<var>")
  debug_1387:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2469_done
    goto rxscan2469_scan
  rxscan2469_loop:
    (rx2466_pos) = rx2466_cur."from"()
    inc rx2466_pos
    rx2466_cur."!cursor_from"(rx2466_pos)
    ge rx2466_pos, rx2466_eos, rxscan2469_done
  rxscan2469_scan:
    set_addr $I10, rxscan2469_loop
    rx2466_cur."!mark_push"(0, rx2466_pos, $I10)
  rxscan2469_done:
.annotate 'line', 736
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2466_pos, rx2466_off
    substr $S10, rx2466_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx2466_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2466_cur."!cursor_pos"(rx2466_pos)
    $P10 = rx2466_cur."LANG"("MAIN", "variable")
    unless $P10, rx2466_fail
    rx2466_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx2466_pos = $P10."pos"()
.annotate 'line', 735
  # rx pass
    rx2466_cur."!cursor_pass"(rx2466_pos, "assertion:sym<var>")
    if_null rx2466_debug, debug_1388
    rx2466_cur."!cursor_debug"("PASS", "assertion:sym<var>", " at pos=", rx2466_pos)
  debug_1388:
    .return (rx2466_cur)
  rx2466_restart:
.annotate 'line', 703
    if_null rx2466_debug, debug_1389
    rx2466_cur."!cursor_debug"("NEXT", "assertion:sym<var>")
  debug_1389:
  rx2466_fail:
    (rx2466_rep, rx2466_pos, $I10, $P10) = rx2466_cur."!mark_fail"(0)
    lt rx2466_pos, -1, rx2466_done
    eq rx2466_pos, -1, rx2466_fail
    jump $I10
  rx2466_done:
    rx2466_cur."!cursor_fail"()
    if_null rx2466_debug, debug_1390
    rx2466_cur."!cursor_debug"("FAIL", "assertion:sym<var>")
  debug_1390:
    .return (rx2466_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<var>"  :nsentry("!PREFIX__assertion:sym<var>") :subid("403_1303340952.947") :method
.annotate 'line', 703
    new $P2468, "ResizablePMCArray"
    push $P2468, "$"
    push $P2468, "@"
    .return ($P2468)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "codeblock"  :subid("404_1303340952.947") :method :outer("385_1303340952.947")
.annotate 'line', 703
    .local string rx2471_tgt
    .local int rx2471_pos
    .local int rx2471_off
    .local int rx2471_eos
    .local int rx2471_rep
    .local pmc rx2471_cur
    .local pmc rx2471_debug
    (rx2471_cur, rx2471_pos, rx2471_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2471_cur
    .local pmc match
    .lex "$/", match
    length rx2471_eos, rx2471_tgt
    gt rx2471_pos, rx2471_eos, rx2471_done
    set rx2471_off, 0
    lt rx2471_pos, 2, rx2471_start
    sub rx2471_off, rx2471_pos, 1
    substr rx2471_tgt, rx2471_tgt, rx2471_off
  rx2471_start:
    eq $I10, 1, rx2471_restart
    if_null rx2471_debug, debug_1391
    rx2471_cur."!cursor_debug"("START", "codeblock")
  debug_1391:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2475_done
    goto rxscan2475_scan
  rxscan2475_loop:
    (rx2471_pos) = rx2471_cur."from"()
    inc rx2471_pos
    rx2471_cur."!cursor_from"(rx2471_pos)
    ge rx2471_pos, rx2471_eos, rxscan2475_done
  rxscan2475_scan:
    set_addr $I10, rxscan2475_loop
    rx2471_cur."!mark_push"(0, rx2471_pos, $I10)
  rxscan2475_done:
.annotate 'line', 740
  # rx subrule "LANG" subtype=capture negate=
    rx2471_cur."!cursor_pos"(rx2471_pos)
    $P10 = rx2471_cur."LANG"("MAIN", "pblock")
    unless $P10, rx2471_fail
    rx2471_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx2471_pos = $P10."pos"()
.annotate 'line', 739
  # rx pass
    rx2471_cur."!cursor_pass"(rx2471_pos, "codeblock")
    if_null rx2471_debug, debug_1392
    rx2471_cur."!cursor_debug"("PASS", "codeblock", " at pos=", rx2471_pos)
  debug_1392:
    .return (rx2471_cur)
  rx2471_restart:
.annotate 'line', 703
    if_null rx2471_debug, debug_1393
    rx2471_cur."!cursor_debug"("NEXT", "codeblock")
  debug_1393:
  rx2471_fail:
    (rx2471_rep, rx2471_pos, $I10, $P10) = rx2471_cur."!mark_fail"(0)
    lt rx2471_pos, -1, rx2471_done
    eq rx2471_pos, -1, rx2471_fail
    jump $I10
  rx2471_done:
    rx2471_cur."!cursor_fail"()
    if_null rx2471_debug, debug_1394
    rx2471_cur."!cursor_debug"("FAIL", "codeblock")
  debug_1394:
    .return (rx2471_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__codeblock"  :nsentry("!PREFIX__codeblock") :subid("405_1303340952.947") :method
.annotate 'line', 703
    $P2473 = self."!PREFIX__!subrule"("LANG", "")
    new $P2474, "ResizablePMCArray"
    push $P2474, $P2473
    .return ($P2474)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2515"  :subid("407_1303340952.947") :outer("10_1303340952.947")
.annotate 'line', 746
    .const 'Sub' $P5722 = "562_1303340952.947" 
    capture_lex $P5722
    .const 'Sub' $P5709 = "561_1303340952.947" 
    capture_lex $P5709
    .const 'Sub' $P5704 = "560_1303340952.947" 
    capture_lex $P5704
    .const 'Sub' $P5699 = "559_1303340952.947" 
    capture_lex $P5699
    .const 'Sub' $P5694 = "558_1303340952.947" 
    capture_lex $P5694
    .const 'Sub' $P5683 = "557_1303340952.947" 
    capture_lex $P5683
    .const 'Sub' $P5675 = "556_1303340952.947" 
    capture_lex $P5675
    .const 'Sub' $P5667 = "555_1303340952.947" 
    capture_lex $P5667
    .const 'Sub' $P5659 = "554_1303340952.947" 
    capture_lex $P5659
    .const 'Sub' $P5654 = "553_1303340952.947" 
    capture_lex $P5654
    .const 'Sub' $P5642 = "552_1303340952.947" 
    capture_lex $P5642
    .const 'Sub' $P5634 = "551_1303340952.947" 
    capture_lex $P5634
    .const 'Sub' $P5587 = "550_1303340952.947" 
    capture_lex $P5587
    .const 'Sub' $P5575 = "549_1303340952.947" 
    capture_lex $P5575
    .const 'Sub' $P5567 = "548_1303340952.947" 
    capture_lex $P5567
    .const 'Sub' $P5559 = "547_1303340952.947" 
    capture_lex $P5559
    .const 'Sub' $P5551 = "546_1303340952.947" 
    capture_lex $P5551
    .const 'Sub' $P5543 = "545_1303340952.947" 
    capture_lex $P5543
    .const 'Sub' $P5535 = "544_1303340952.947" 
    capture_lex $P5535
    .const 'Sub' $P5509 = "543_1303340952.947" 
    capture_lex $P5509
    .const 'Sub' $P5494 = "542_1303340952.947" 
    capture_lex $P5494
    .const 'Sub' $P5486 = "541_1303340952.947" 
    capture_lex $P5486
    .const 'Sub' $P5475 = "540_1303340952.947" 
    capture_lex $P5475
    .const 'Sub' $P5464 = "539_1303340952.947" 
    capture_lex $P5464
    .const 'Sub' $P5453 = "538_1303340952.947" 
    capture_lex $P5453
    .const 'Sub' $P5445 = "537_1303340952.947" 
    capture_lex $P5445
    .const 'Sub' $P5418 = "536_1303340952.947" 
    capture_lex $P5418
    .const 'Sub' $P5380 = "534_1303340952.947" 
    capture_lex $P5380
    .const 'Sub' $P5372 = "533_1303340952.947" 
    capture_lex $P5372
    .const 'Sub' $P5364 = "532_1303340952.947" 
    capture_lex $P5364
    .const 'Sub' $P5339 = "531_1303340952.947" 
    capture_lex $P5339
    .const 'Sub' $P5323 = "530_1303340952.947" 
    capture_lex $P5323
    .const 'Sub' $P5315 = "529_1303340952.947" 
    capture_lex $P5315
    .const 'Sub' $P5307 = "528_1303340952.947" 
    capture_lex $P5307
    .const 'Sub' $P5205 = "525_1303340952.947" 
    capture_lex $P5205
    .const 'Sub' $P5197 = "524_1303340952.947" 
    capture_lex $P5197
    .const 'Sub' $P5190 = "523_1303340952.947" 
    capture_lex $P5190
    .const 'Sub' $P5163 = "522_1303340952.947" 
    capture_lex $P5163
    .const 'Sub' $P5110 = "520_1303340952.947" 
    capture_lex $P5110
    .const 'Sub' $P5096 = "519_1303340952.947" 
    capture_lex $P5096
    .const 'Sub' $P5089 = "518_1303340952.947" 
    capture_lex $P5089
    .const 'Sub' $P5040 = "517_1303340952.947" 
    capture_lex $P5040
    .const 'Sub' $P4864 = "513_1303340952.947" 
    capture_lex $P4864
    .const 'Sub' $P4801 = "511_1303340952.947" 
    capture_lex $P4801
    .const 'Sub' $P4793 = "510_1303340952.947" 
    capture_lex $P4793
    .const 'Sub' $P4778 = "509_1303340952.947" 
    capture_lex $P4778
    .const 'Sub' $P4763 = "508_1303340952.947" 
    capture_lex $P4763
    .const 'Sub' $P4743 = "507_1303340952.947" 
    capture_lex $P4743
    .const 'Sub' $P4640 = "506_1303340952.947" 
    capture_lex $P4640
    .const 'Sub' $P4592 = "503_1303340952.947" 
    capture_lex $P4592
    .const 'Sub' $P4467 = "500_1303340952.947" 
    capture_lex $P4467
    .const 'Sub' $P4194 = "493_1303340952.947" 
    capture_lex $P4194
    .const 'Sub' $P4186 = "492_1303340952.947" 
    capture_lex $P4186
    .const 'Sub' $P4178 = "491_1303340952.947" 
    capture_lex $P4178
    .const 'Sub' $P4074 = "488_1303340952.947" 
    capture_lex $P4074
    .const 'Sub' $P4066 = "487_1303340952.947" 
    capture_lex $P4066
    .const 'Sub' $P4051 = "486_1303340952.947" 
    capture_lex $P4051
    .const 'Sub' $P4036 = "485_1303340952.947" 
    capture_lex $P4036
    .const 'Sub' $P4021 = "484_1303340952.947" 
    capture_lex $P4021
    .const 'Sub' $P3999 = "483_1303340952.947" 
    capture_lex $P3999
    .const 'Sub' $P3991 = "482_1303340952.947" 
    capture_lex $P3991
    .const 'Sub' $P3983 = "481_1303340952.947" 
    capture_lex $P3983
    .const 'Sub' $P3975 = "480_1303340952.947" 
    capture_lex $P3975
    .const 'Sub' $P3753 = "477_1303340952.947" 
    capture_lex $P3753
    .const 'Sub' $P3745 = "476_1303340952.947" 
    capture_lex $P3745
    .const 'Sub' $P3737 = "475_1303340952.947" 
    capture_lex $P3737
    .const 'Sub' $P3729 = "474_1303340952.947" 
    capture_lex $P3729
    .const 'Sub' $P3721 = "473_1303340952.947" 
    capture_lex $P3721
    .const 'Sub' $P3713 = "472_1303340952.947" 
    capture_lex $P3713
    .const 'Sub' $P3705 = "471_1303340952.947" 
    capture_lex $P3705
    .const 'Sub' $P3594 = "469_1303340952.947" 
    capture_lex $P3594
    .const 'Sub' $P3570 = "468_1303340952.947" 
    capture_lex $P3570
    .const 'Sub' $P3556 = "467_1303340952.947" 
    capture_lex $P3556
    .const 'Sub' $P3548 = "466_1303340952.947" 
    capture_lex $P3548
    .const 'Sub' $P3540 = "465_1303340952.947" 
    capture_lex $P3540
    .const 'Sub' $P3532 = "464_1303340952.947" 
    capture_lex $P3532
    .const 'Sub' $P3524 = "463_1303340952.947" 
    capture_lex $P3524
    .const 'Sub' $P3516 = "462_1303340952.947" 
    capture_lex $P3516
    .const 'Sub' $P3508 = "461_1303340952.947" 
    capture_lex $P3508
    .const 'Sub' $P3500 = "460_1303340952.947" 
    capture_lex $P3500
    .const 'Sub' $P3492 = "459_1303340952.947" 
    capture_lex $P3492
    .const 'Sub' $P3484 = "458_1303340952.947" 
    capture_lex $P3484
    .const 'Sub' $P3476 = "457_1303340952.947" 
    capture_lex $P3476
    .const 'Sub' $P3468 = "456_1303340952.947" 
    capture_lex $P3468
    .const 'Sub' $P3460 = "455_1303340952.947" 
    capture_lex $P3460
    .const 'Sub' $P3452 = "454_1303340952.947" 
    capture_lex $P3452
    .const 'Sub' $P3436 = "453_1303340952.947" 
    capture_lex $P3436
    .const 'Sub' $P3403 = "452_1303340952.947" 
    capture_lex $P3403
    .const 'Sub' $P3389 = "451_1303340952.947" 
    capture_lex $P3389
    .const 'Sub' $P3368 = "450_1303340952.947" 
    capture_lex $P3368
    .const 'Sub' $P3348 = "449_1303340952.947" 
    capture_lex $P3348
    .const 'Sub' $P3324 = "448_1303340952.947" 
    capture_lex $P3324
    .const 'Sub' $P3290 = "447_1303340952.947" 
    capture_lex $P3290
    .const 'Sub' $P3275 = "446_1303340952.947" 
    capture_lex $P3275
    .const 'Sub' $P3263 = "445_1303340952.947" 
    capture_lex $P3263
    .const 'Sub' $P3212 = "443_1303340952.947" 
    capture_lex $P3212
    .const 'Sub' $P3201 = "442_1303340952.947" 
    capture_lex $P3201
    .const 'Sub' $P3194 = "441_1303340952.947" 
    capture_lex $P3194
    .const 'Sub' $P3178 = "440_1303340952.947" 
    capture_lex $P3178
    .const 'Sub' $P3156 = "439_1303340952.947" 
    capture_lex $P3156
    .const 'Sub' $P3145 = "438_1303340952.947" 
    capture_lex $P3145
    .const 'Sub' $P3108 = "436_1303340952.947" 
    capture_lex $P3108
    .const 'Sub' $P3100 = "435_1303340952.947" 
    capture_lex $P3100
    .const 'Sub' $P3092 = "434_1303340952.947" 
    capture_lex $P3092
    .const 'Sub' $P3078 = "433_1303340952.947" 
    capture_lex $P3078
    .const 'Sub' $P2997 = "431_1303340952.947" 
    capture_lex $P2997
    .const 'Sub' $P2956 = "429_1303340952.947" 
    capture_lex $P2956
    .const 'Sub' $P2899 = "428_1303340952.947" 
    capture_lex $P2899
    .const 'Sub' $P2868 = "427_1303340952.947" 
    capture_lex $P2868
    .const 'Sub' $P2860 = "426_1303340952.947" 
    capture_lex $P2860
    .const 'Sub' $P2817 = "424_1303340952.947" 
    capture_lex $P2817
    .const 'Sub' $P2812 = "423_1303340952.947" 
    capture_lex $P2812
    .const 'Sub' $P2807 = "422_1303340952.947" 
    capture_lex $P2807
    .const 'Sub' $P2732 = "419_1303340952.947" 
    capture_lex $P2732
    .const 'Sub' $P2720 = "418_1303340952.947" 
    capture_lex $P2720
    .const 'Sub' $P2655 = "416_1303340952.947" 
    capture_lex $P2655
    .const 'Sub' $P2643 = "415_1303340952.947" 
    capture_lex $P2643
    .const 'Sub' $P2589 = "414_1303340952.947" 
    capture_lex $P2589
    .const 'Sub' $P2576 = "413_1303340952.947" 
    capture_lex $P2576
    .const 'Sub' $P2558 = "412_1303340952.947" 
    capture_lex $P2558
    .const 'Sub' $P2525 = "409_1303340952.947" 
    capture_lex $P2525
    .const 'Sub' $P2517 = "408_1303340952.947" 
    capture_lex $P2517
.annotate 'line', 750
    .const 'Sub' $P2517 = "408_1303340952.947" 
    newclosure $P2524, $P2517
    .lex "xblock_immediate", $P2524
.annotate 'line', 755
    .const 'Sub' $P2525 = "409_1303340952.947" 
    newclosure $P2557, $P2525
    .lex "block_immediate", $P2557
.annotate 'line', 765
    .const 'Sub' $P2558 = "412_1303340952.947" 
    newclosure $P2575, $P2558
    .lex "vivitype", $P2575
.annotate 'line', 784
    .const 'Sub' $P2576 = "413_1303340952.947" 
    newclosure $P2588, $P2576
    .lex "colonpair_str", $P2588
.annotate 'line', 1018
    .const 'Sub' $P2589 = "414_1303340952.947" 
    newclosure $P2642, $P2589
    .lex "push_block_handler", $P2642
.annotate 'line', 1581
    .const 'Sub' $P2643 = "415_1303340952.947" 
    newclosure $P2654, $P2643
    .lex "only_star_block", $P2654
.annotate 'line', 1590
    .const 'Sub' $P2655 = "416_1303340952.947" 
    newclosure $P2719, $P2655
    .lex "attach_multi_signature", $P2719
.annotate 'line', 2068
    .const 'Sub' $P2720 = "418_1303340952.947" 
    newclosure $P2731, $P2720
    .lex "control", $P2731
.annotate 'line', 2087
    .const 'Sub' $P2732 = "419_1303340952.947" 
    newclosure $P2806, $P2732
    .lex "lexical_package_lookup", $P2806
.annotate 'line', 2136
    .const 'Sub' $P2807 = "422_1303340952.947" 
    newclosure $P2811, $P2807
    .lex "is_lexical", $P2811
.annotate 'line', 2142
    .const 'Sub' $P2812 = "423_1303340952.947" 
    newclosure $P2816, $P2812
    .lex "is_package", $P2816
.annotate 'line', 2148
    .const 'Sub' $P2817 = "424_1303340952.947" 
    newclosure $P2851, $P2817
    .lex "is_scope", $P2851
.annotate 'line', 746
    .lex "$?PACKAGE", $P2852
    .lex "$?CLASS", $P2853
.annotate 'line', 748
 $P2854 = new ['ResizablePMCArray'] 
    find_lex $P2855, "$?PACKAGE"
    get_who $P2856, $P2855
    set $P2856["@BLOCK"], $P2854
    find_lex $P2857, "xblock_immediate"
    find_lex $P2858, "block_immediate"
    find_lex $P2859, "vivitype"
.annotate 'line', 776
    find_lex $P2898, "colonpair_str"
.annotate 'line', 1011
    find_lex $P3388, "push_block_handler"
.annotate 'line', 1509
    find_lex $P4590, "only_star_block"
    find_lex $P4591, "attach_multi_signature"
.annotate 'line', 2059
    find_lex $P5693, "control"
.annotate 'line', 2081
    find_lex $P5717, "lexical_package_lookup"
    find_lex $P5718, "is_lexical"
    find_lex $P5719, "is_package"
    find_lex $P5720, "is_scope"
.annotate 'line', 746
    .return ($P5720)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "" :load :init :subid("post1395") :outer("407_1303340952.947")
.annotate 'line', 746
    get_hll_global $P2516, ["NQP";"Actions"], "_block2515" 
    .local pmc block
    set block, $P2516
    .const 'Sub' $P5722 = "562_1303340952.947" 
    capture_lex $P5722
    $P5722()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5721"  :anon :subid("562_1303340952.947") :outer("407_1303340952.947")
.annotate 'line', 746
    nqp_get_sc_object $P5723, "1303340942.153", 3
    .local pmc type_obj
    set type_obj, $P5723
    get_how $P5724, type_obj
    .const 'Sub' $P5725 = "426_1303340952.947" 
    $P5724."add_method"(type_obj, "TOP", $P5725)
    get_how $P5726, type_obj
    .const 'Sub' $P5727 = "427_1303340952.947" 
    $P5726."add_method"(type_obj, "deflongname", $P5727)
    get_how $P5728, type_obj
    .const 'Sub' $P5729 = "428_1303340952.947" 
    $P5728."add_method"(type_obj, "comp_unit", $P5729)
    get_how $P5730, type_obj
    .const 'Sub' $P5731 = "429_1303340952.947" 
    $P5730."add_method"(type_obj, "statementlist", $P5731)
    get_how $P5732, type_obj
    .const 'Sub' $P5733 = "431_1303340952.947" 
    $P5732."add_method"(type_obj, "statement", $P5733)
    get_how $P5734, type_obj
    .const 'Sub' $P5735 = "433_1303340952.947" 
    $P5734."add_method"(type_obj, "xblock", $P5735)
    get_how $P5736, type_obj
    .const 'Sub' $P5737 = "434_1303340952.947" 
    $P5736."add_method"(type_obj, "pblock", $P5737)
    get_how $P5738, type_obj
    .const 'Sub' $P5739 = "435_1303340952.947" 
    $P5738."add_method"(type_obj, "block", $P5739)
    get_how $P5740, type_obj
    .const 'Sub' $P5741 = "436_1303340952.947" 
    $P5740."add_method"(type_obj, "blockoid", $P5741)
    get_how $P5742, type_obj
    .const 'Sub' $P5743 = "438_1303340952.947" 
    $P5742."add_method"(type_obj, "newpad", $P5743)
    get_how $P5744, type_obj
    .const 'Sub' $P5745 = "439_1303340952.947" 
    $P5744."add_method"(type_obj, "outerctx", $P5745)
    get_how $P5746, type_obj
    .const 'Sub' $P5747 = "440_1303340952.947" 
    $P5746."add_method"(type_obj, "GLOBALish", $P5747)
    get_how $P5748, type_obj
    .const 'Sub' $P5749 = "441_1303340952.947" 
    $P5748."add_method"(type_obj, "you_are_here", $P5749)
    get_how $P5750, type_obj
    .const 'Sub' $P5751 = "442_1303340952.947" 
    $P5750."add_method"(type_obj, "statement_control:sym<use>", $P5751)
    get_how $P5752, type_obj
    .const 'Sub' $P5753 = "443_1303340952.947" 
    $P5752."add_method"(type_obj, "statement_control:sym<if>", $P5753)
    get_how $P5754, type_obj
    .const 'Sub' $P5755 = "445_1303340952.947" 
    $P5754."add_method"(type_obj, "statement_control:sym<unless>", $P5755)
    get_how $P5756, type_obj
    .const 'Sub' $P5757 = "446_1303340952.947" 
    $P5756."add_method"(type_obj, "statement_control:sym<while>", $P5757)
    get_how $P5758, type_obj
    .const 'Sub' $P5759 = "447_1303340952.947" 
    $P5758."add_method"(type_obj, "statement_control:sym<repeat>", $P5759)
    get_how $P5760, type_obj
    .const 'Sub' $P5761 = "448_1303340952.947" 
    $P5760."add_method"(type_obj, "statement_control:sym<for>", $P5761)
    get_how $P5762, type_obj
    .const 'Sub' $P5763 = "449_1303340952.947" 
    $P5762."add_method"(type_obj, "statement_control:sym<CATCH>", $P5763)
    get_how $P5764, type_obj
    .const 'Sub' $P5765 = "450_1303340952.947" 
    $P5764."add_method"(type_obj, "statement_control:sym<CONTROL>", $P5765)
    get_how $P5766, type_obj
    .const 'Sub' $P5767 = "451_1303340952.947" 
    $P5766."add_method"(type_obj, "statement_prefix:sym<INIT>", $P5767)
    get_how $P5768, type_obj
    .const 'Sub' $P5769 = "452_1303340952.947" 
    $P5768."add_method"(type_obj, "statement_prefix:sym<try>", $P5769)
    get_how $P5770, type_obj
    .const 'Sub' $P5771 = "453_1303340952.947" 
    $P5770."add_method"(type_obj, "blorst", $P5771)
    get_how $P5772, type_obj
    .const 'Sub' $P5773 = "454_1303340952.947" 
    $P5772."add_method"(type_obj, "statement_mod_cond:sym<if>", $P5773)
    get_how $P5774, type_obj
    .const 'Sub' $P5775 = "455_1303340952.947" 
    $P5774."add_method"(type_obj, "statement_mod_cond:sym<unless>", $P5775)
    get_how $P5776, type_obj
    .const 'Sub' $P5777 = "456_1303340952.947" 
    $P5776."add_method"(type_obj, "statement_mod_loop:sym<while>", $P5777)
    get_how $P5778, type_obj
    .const 'Sub' $P5779 = "457_1303340952.947" 
    $P5778."add_method"(type_obj, "statement_mod_loop:sym<until>", $P5779)
    get_how $P5780, type_obj
    .const 'Sub' $P5781 = "458_1303340952.947" 
    $P5780."add_method"(type_obj, "term:sym<fatarrow>", $P5781)
    get_how $P5782, type_obj
    .const 'Sub' $P5783 = "459_1303340952.947" 
    $P5782."add_method"(type_obj, "term:sym<colonpair>", $P5783)
    get_how $P5784, type_obj
    .const 'Sub' $P5785 = "460_1303340952.947" 
    $P5784."add_method"(type_obj, "term:sym<variable>", $P5785)
    get_how $P5786, type_obj
    .const 'Sub' $P5787 = "461_1303340952.947" 
    $P5786."add_method"(type_obj, "term:sym<package_declarator>", $P5787)
    get_how $P5788, type_obj
    .const 'Sub' $P5789 = "462_1303340952.947" 
    $P5788."add_method"(type_obj, "term:sym<scope_declarator>", $P5789)
    get_how $P5790, type_obj
    .const 'Sub' $P5791 = "463_1303340952.947" 
    $P5790."add_method"(type_obj, "term:sym<routine_declarator>", $P5791)
    get_how $P5792, type_obj
    .const 'Sub' $P5793 = "464_1303340952.947" 
    $P5792."add_method"(type_obj, "term:sym<regex_declarator>", $P5793)
    get_how $P5794, type_obj
    .const 'Sub' $P5795 = "465_1303340952.947" 
    $P5794."add_method"(type_obj, "term:sym<statement_prefix>", $P5795)
    get_how $P5796, type_obj
    .const 'Sub' $P5797 = "466_1303340952.947" 
    $P5796."add_method"(type_obj, "term:sym<lambda>", $P5797)
    get_how $P5798, type_obj
    .const 'Sub' $P5799 = "467_1303340952.947" 
    $P5798."add_method"(type_obj, "fatarrow", $P5799)
    get_how $P5800, type_obj
    .const 'Sub' $P5801 = "468_1303340952.947" 
    $P5800."add_method"(type_obj, "colonpair", $P5801)
    get_how $P5802, type_obj
    .const 'Sub' $P5803 = "469_1303340952.947" 
    $P5802."add_method"(type_obj, "variable", $P5803)
    get_how $P5804, type_obj
    .const 'Sub' $P5805 = "471_1303340952.947" 
    $P5804."add_method"(type_obj, "package_declarator:sym<module>", $P5805)
    get_how $P5806, type_obj
    .const 'Sub' $P5807 = "472_1303340952.947" 
    $P5806."add_method"(type_obj, "package_declarator:sym<knowhow>", $P5807)
    get_how $P5808, type_obj
    .const 'Sub' $P5809 = "473_1303340952.947" 
    $P5808."add_method"(type_obj, "package_declarator:sym<class>", $P5809)
    get_how $P5810, type_obj
    .const 'Sub' $P5811 = "474_1303340952.947" 
    $P5810."add_method"(type_obj, "package_declarator:sym<grammar>", $P5811)
    get_how $P5812, type_obj
    .const 'Sub' $P5813 = "475_1303340952.947" 
    $P5812."add_method"(type_obj, "package_declarator:sym<role>", $P5813)
    get_how $P5814, type_obj
    .const 'Sub' $P5815 = "476_1303340952.947" 
    $P5814."add_method"(type_obj, "package_declarator:sym<native>", $P5815)
    get_how $P5816, type_obj
    .const 'Sub' $P5817 = "477_1303340952.947" 
    $P5816."add_method"(type_obj, "package_def", $P5817)
    get_how $P5818, type_obj
    .const 'Sub' $P5819 = "480_1303340952.947" 
    $P5818."add_method"(type_obj, "scope_declarator:sym<my>", $P5819)
    get_how $P5820, type_obj
    .const 'Sub' $P5821 = "481_1303340952.947" 
    $P5820."add_method"(type_obj, "scope_declarator:sym<our>", $P5821)
    get_how $P5822, type_obj
    .const 'Sub' $P5823 = "482_1303340952.947" 
    $P5822."add_method"(type_obj, "scope_declarator:sym<has>", $P5823)
    get_how $P5824, type_obj
    .const 'Sub' $P5825 = "483_1303340952.947" 
    $P5824."add_method"(type_obj, "scoped", $P5825)
    get_how $P5826, type_obj
    .const 'Sub' $P5827 = "484_1303340952.947" 
    $P5826."add_method"(type_obj, "declarator", $P5827)
    get_how $P5828, type_obj
    .const 'Sub' $P5829 = "485_1303340952.947" 
    $P5828."add_method"(type_obj, "multi_declarator:sym<multi>", $P5829)
    get_how $P5830, type_obj
    .const 'Sub' $P5831 = "486_1303340952.947" 
    $P5830."add_method"(type_obj, "multi_declarator:sym<proto>", $P5831)
    get_how $P5832, type_obj
    .const 'Sub' $P5833 = "487_1303340952.947" 
    $P5832."add_method"(type_obj, "multi_declarator:sym<null>", $P5833)
    get_how $P5834, type_obj
    .const 'Sub' $P5835 = "488_1303340952.947" 
    $P5834."add_method"(type_obj, "variable_declarator", $P5835)
    get_how $P5836, type_obj
    .const 'Sub' $P5837 = "491_1303340952.947" 
    $P5836."add_method"(type_obj, "routine_declarator:sym<sub>", $P5837)
    get_how $P5838, type_obj
    .const 'Sub' $P5839 = "492_1303340952.947" 
    $P5838."add_method"(type_obj, "routine_declarator:sym<method>", $P5839)
    get_how $P5840, type_obj
    .const 'Sub' $P5841 = "493_1303340952.947" 
    $P5840."add_method"(type_obj, "routine_def", $P5841)
    get_how $P5842, type_obj
    .const 'Sub' $P5843 = "500_1303340952.947" 
    $P5842."add_method"(type_obj, "method_def", $P5843)
    get_how $P5844, type_obj
    .const 'Sub' $P5845 = "503_1303340952.947" 
    $P5844."add_method"(type_obj, "signature", $P5845)
    get_how $P5846, type_obj
    .const 'Sub' $P5847 = "506_1303340952.947" 
    $P5846."add_method"(type_obj, "parameter", $P5847)
    get_how $P5848, type_obj
    .const 'Sub' $P5849 = "507_1303340952.947" 
    $P5848."add_method"(type_obj, "param_var", $P5849)
    get_how $P5850, type_obj
    .const 'Sub' $P5851 = "508_1303340952.947" 
    $P5850."add_method"(type_obj, "named_param", $P5851)
    get_how $P5852, type_obj
    .const 'Sub' $P5853 = "509_1303340952.947" 
    $P5852."add_method"(type_obj, "typename", $P5853)
    get_how $P5854, type_obj
    .const 'Sub' $P5855 = "510_1303340952.947" 
    $P5854."add_method"(type_obj, "trait", $P5855)
    get_how $P5856, type_obj
    .const 'Sub' $P5857 = "511_1303340952.947" 
    $P5856."add_method"(type_obj, "trait_mod:sym<is>", $P5857)
    get_how $P5858, type_obj
    .const 'Sub' $P5859 = "513_1303340952.947" 
    $P5858."add_method"(type_obj, "regex_declarator", $P5859)
    get_how $P5860, type_obj
    .const 'Sub' $P5861 = "517_1303340952.947" 
    $P5860."add_method"(type_obj, "dotty", $P5861)
    get_how $P5862, type_obj
    .const 'Sub' $P5863 = "518_1303340952.947" 
    $P5862."add_method"(type_obj, "term:sym<self>", $P5863)
    get_how $P5864, type_obj
    .const 'Sub' $P5865 = "519_1303340952.947" 
    $P5864."add_method"(type_obj, "term:sym<identifier>", $P5865)
    get_how $P5866, type_obj
    .const 'Sub' $P5867 = "520_1303340952.947" 
    $P5866."add_method"(type_obj, "term:sym<name>", $P5867)
    get_how $P5868, type_obj
    .const 'Sub' $P5869 = "522_1303340952.947" 
    $P5868."add_method"(type_obj, "term:sym<pir::op>", $P5869)
    get_how $P5870, type_obj
    .const 'Sub' $P5871 = "523_1303340952.947" 
    $P5870."add_method"(type_obj, "term:sym<onlystar>", $P5871)
    get_how $P5872, type_obj
    .const 'Sub' $P5873 = "524_1303340952.947" 
    $P5872."add_method"(type_obj, "args", $P5873)
    get_how $P5874, type_obj
    .const 'Sub' $P5875 = "525_1303340952.947" 
    $P5874."add_method"(type_obj, "arglist", $P5875)
    get_how $P5876, type_obj
    .const 'Sub' $P5877 = "528_1303340952.947" 
    $P5876."add_method"(type_obj, "term:sym<multi_declarator>", $P5877)
    get_how $P5878, type_obj
    .const 'Sub' $P5879 = "529_1303340952.947" 
    $P5878."add_method"(type_obj, "term:sym<value>", $P5879)
    get_how $P5880, type_obj
    .const 'Sub' $P5881 = "530_1303340952.947" 
    $P5880."add_method"(type_obj, "circumfix:sym<( )>", $P5881)
    get_how $P5882, type_obj
    .const 'Sub' $P5883 = "531_1303340952.947" 
    $P5882."add_method"(type_obj, "circumfix:sym<[ ]>", $P5883)
    get_how $P5884, type_obj
    .const 'Sub' $P5885 = "532_1303340952.947" 
    $P5884."add_method"(type_obj, "circumfix:sym<ang>", $P5885)
    get_how $P5886, type_obj
    .const 'Sub' $P5887 = "533_1303340952.947" 
    $P5886."add_method"(type_obj, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P5887)
    get_how $P5888, type_obj
    .const 'Sub' $P5889 = "534_1303340952.947" 
    $P5888."add_method"(type_obj, "circumfix:sym<{ }>", $P5889)
    get_how $P5890, type_obj
    .const 'Sub' $P5891 = "536_1303340952.947" 
    $P5890."add_method"(type_obj, "circumfix:sym<sigil>", $P5891)
    get_how $P5892, type_obj
    .const 'Sub' $P5893 = "537_1303340952.947" 
    $P5892."add_method"(type_obj, "semilist", $P5893)
    get_how $P5894, type_obj
    .const 'Sub' $P5895 = "538_1303340952.947" 
    $P5894."add_method"(type_obj, "postcircumfix:sym<[ ]>", $P5895)
    get_how $P5896, type_obj
    .const 'Sub' $P5897 = "539_1303340952.947" 
    $P5896."add_method"(type_obj, "postcircumfix:sym<{ }>", $P5897)
    get_how $P5898, type_obj
    .const 'Sub' $P5899 = "540_1303340952.947" 
    $P5898."add_method"(type_obj, "postcircumfix:sym<ang>", $P5899)
    get_how $P5900, type_obj
    .const 'Sub' $P5901 = "541_1303340952.947" 
    $P5900."add_method"(type_obj, "postcircumfix:sym<( )>", $P5901)
    get_how $P5902, type_obj
    .const 'Sub' $P5903 = "542_1303340952.947" 
    $P5902."add_method"(type_obj, "value", $P5903)
    get_how $P5904, type_obj
    .const 'Sub' $P5905 = "543_1303340952.947" 
    $P5904."add_method"(type_obj, "number", $P5905)
    get_how $P5906, type_obj
    .const 'Sub' $P5907 = "544_1303340952.947" 
    $P5906."add_method"(type_obj, "quote:sym<apos>", $P5907)
    get_how $P5908, type_obj
    .const 'Sub' $P5909 = "545_1303340952.947" 
    $P5908."add_method"(type_obj, "quote:sym<dblq>", $P5909)
    get_how $P5910, type_obj
    .const 'Sub' $P5911 = "546_1303340952.947" 
    $P5910."add_method"(type_obj, "quote:sym<qq>", $P5911)
    get_how $P5912, type_obj
    .const 'Sub' $P5913 = "547_1303340952.947" 
    $P5912."add_method"(type_obj, "quote:sym<q>", $P5913)
    get_how $P5914, type_obj
    .const 'Sub' $P5915 = "548_1303340952.947" 
    $P5914."add_method"(type_obj, "quote:sym<Q>", $P5915)
    get_how $P5916, type_obj
    .const 'Sub' $P5917 = "549_1303340952.947" 
    $P5916."add_method"(type_obj, "quote:sym<Q:PIR>", $P5917)
    get_how $P5918, type_obj
    .const 'Sub' $P5919 = "550_1303340952.947" 
    $P5918."add_method"(type_obj, "quote:sym</ />", $P5919)
    get_how $P5920, type_obj
    .const 'Sub' $P5921 = "551_1303340952.947" 
    $P5920."add_method"(type_obj, "quote_escape:sym<$>", $P5921)
    get_how $P5922, type_obj
    .const 'Sub' $P5923 = "552_1303340952.947" 
    $P5922."add_method"(type_obj, "quote_escape:sym<{ }>", $P5923)
    get_how $P5924, type_obj
    .const 'Sub' $P5925 = "553_1303340952.947" 
    $P5924."add_method"(type_obj, "quote_escape:sym<esc>", $P5925)
    get_how $P5926, type_obj
    .const 'Sub' $P5927 = "554_1303340952.947" 
    $P5926."add_method"(type_obj, "postfix:sym<.>", $P5927)
    get_how $P5928, type_obj
    .const 'Sub' $P5929 = "555_1303340952.947" 
    $P5928."add_method"(type_obj, "postfix:sym<++>", $P5929)
    get_how $P5930, type_obj
    .const 'Sub' $P5931 = "556_1303340952.947" 
    $P5930."add_method"(type_obj, "postfix:sym<-->", $P5931)
    get_how $P5932, type_obj
    .const 'Sub' $P5933 = "557_1303340952.947" 
    $P5932."add_method"(type_obj, "prefix:sym<make>", $P5933)
    get_how $P5934, type_obj
    .const 'Sub' $P5935 = "558_1303340952.947" 
    $P5934."add_method"(type_obj, "term:sym<next>", $P5935)
    get_how $P5936, type_obj
    .const 'Sub' $P5937 = "559_1303340952.947" 
    $P5936."add_method"(type_obj, "term:sym<last>", $P5937)
    get_how $P5938, type_obj
    .const 'Sub' $P5939 = "560_1303340952.947" 
    $P5938."add_method"(type_obj, "term:sym<redo>", $P5939)
    get_how $P5940, type_obj
    .const 'Sub' $P5941 = "561_1303340952.947" 
    $P5940."add_method"(type_obj, "infix:sym<~~>", $P5941)
    get_how $P5942, type_obj
    get_hll_global $P5943, ["HLL"], "Actions"
    $P5942."add_parent"(type_obj, $P5943)
    get_how $P5944, type_obj
    $P5945 = $P5944."compose"(type_obj)
    .return ($P5945)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock_immediate"  :subid("408_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_2518
.annotate 'line', 750
    .lex "$xblock", param_2518
.annotate 'line', 751
    find_lex $P2519, "$xblock"
    unless_null $P2519, vivify_1396
    $P2519 = root_new ['parrot';'ResizablePMCArray']
  vivify_1396:
    set $P2520, $P2519[1]
    unless_null $P2520, vivify_1397
    new $P2520, "Undef"
  vivify_1397:
    $P2521 = "block_immediate"($P2520)
    find_lex $P2522, "$xblock"
    unless_null $P2522, vivify_1398
    $P2522 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$xblock", $P2522
  vivify_1398:
    set $P2522[1], $P2521
    find_lex $P2523, "$xblock"
    unless_null $P2523, vivify_1399
    new $P2523, "Undef"
  vivify_1399:
.annotate 'line', 750
    .return ($P2523)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block_immediate"  :subid("409_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_2526
.annotate 'line', 755
    .const 'Sub' $P2536 = "410_1303340952.947" 
    capture_lex $P2536
    .lex "$block", param_2526
.annotate 'line', 756
    find_lex $P2527, "$block"
    unless_null $P2527, vivify_1400
    new $P2527, "Undef"
  vivify_1400:
    $P2527."blocktype"("immediate")
.annotate 'line', 757
    find_lex $P2531, "$block"
    unless_null $P2531, vivify_1401
    new $P2531, "Undef"
  vivify_1401:
    $P2532 = $P2531."symtable"()
    unless $P2532, unless_2530
    set $P2529, $P2532
    goto unless_2530_end
  unless_2530:
    find_lex $P2533, "$block"
    unless_null $P2533, vivify_1402
    new $P2533, "Undef"
  vivify_1402:
    $P2534 = $P2533."handlers"()
    set $P2529, $P2534
  unless_2530_end:
    if $P2529, unless_2528_end
    .const 'Sub' $P2536 = "410_1303340952.947" 
    capture_lex $P2536
    $P2536()
  unless_2528_end:
    find_lex $P2556, "$block"
    unless_null $P2556, vivify_1409
    new $P2556, "Undef"
  vivify_1409:
.annotate 'line', 755
    .return ($P2556)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2535"  :anon :subid("410_1303340952.947") :outer("409_1303340952.947")
.annotate 'line', 757
    .const 'Sub' $P2547 = "411_1303340952.947" 
    capture_lex $P2547
.annotate 'line', 758
    new $P2537, "Undef"
    .lex "$stmts", $P2537
    get_hll_global $P2538, ["PAST"], "Stmts"
    find_lex $P2539, "$block"
    unless_null $P2539, vivify_1403
    new $P2539, "Undef"
  vivify_1403:
    $P2540 = $P2538."new"($P2539 :named("node"))
    store_lex "$stmts", $P2540
.annotate 'line', 759
    find_lex $P2542, "$block"
    unless_null $P2542, vivify_1404
    new $P2542, "Undef"
  vivify_1404:
    $P2543 = $P2542."list"()
    defined $I2544, $P2543
    unless $I2544, for_undef_1405
    iter $P2541, $P2543
    new $P2553, 'ExceptionHandler'
    set_label $P2553, loop2552_handler
    $P2553."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2553
  loop2552_test:
    unless $P2541, loop2552_done
    shift $P2545, $P2541
  loop2552_redo:
    .const 'Sub' $P2547 = "411_1303340952.947" 
    capture_lex $P2547
    $P2547($P2545)
  loop2552_next:
    goto loop2552_test
  loop2552_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2554, exception, 'type'
    eq $P2554, .CONTROL_LOOP_NEXT, loop2552_next
    eq $P2554, .CONTROL_LOOP_REDO, loop2552_redo
  loop2552_done:
    pop_eh 
  for_undef_1405:
.annotate 'line', 760
    find_lex $P2555, "$stmts"
    unless_null $P2555, vivify_1408
    new $P2555, "Undef"
  vivify_1408:
    store_lex "$block", $P2555
.annotate 'line', 757
    .return ($P2555)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2546"  :anon :subid("411_1303340952.947") :outer("410_1303340952.947")
    .param pmc param_2548
.annotate 'line', 759
    .lex "$_", param_2548
    find_lex $P2549, "$stmts"
    unless_null $P2549, vivify_1406
    new $P2549, "Undef"
  vivify_1406:
    find_lex $P2550, "$_"
    unless_null $P2550, vivify_1407
    new $P2550, "Undef"
  vivify_1407:
    $P2551 = $P2549."push"($P2550)
    .return ($P2551)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "vivitype"  :subid("412_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_2559
.annotate 'line', 765
    .lex "$sigil", param_2559
.annotate 'line', 766
    find_lex $P2562, "$sigil"
    unless_null $P2562, vivify_1410
    new $P2562, "Undef"
  vivify_1410:
    set $S2563, $P2562
    iseq $I2564, $S2563, "%"
    if $I2564, if_2561
.annotate 'line', 768
    find_lex $P2569, "$sigil"
    unless_null $P2569, vivify_1411
    new $P2569, "Undef"
  vivify_1411:
    set $S2570, $P2569
    iseq $I2571, $S2570, "@"
    if $I2571, if_2568
    new $P2574, "String"
    assign $P2574, "Undef"
    set $P2567, $P2574
    goto if_2568_end
  if_2568:
.annotate 'line', 769
    get_hll_global $P2572, ["PAST"], "Op"
    $P2573 = $P2572."new"("    %r = root_new ['parrot';'ResizablePMCArray']" :named("inline"))
    set $P2567, $P2573
  if_2568_end:
    set $P2560, $P2567
.annotate 'line', 766
    goto if_2561_end
  if_2561:
.annotate 'line', 767
    get_hll_global $P2565, ["PAST"], "Op"
    $P2566 = $P2565."new"("    %r = root_new ['parrot';'Hash']" :named("inline"))
    set $P2560, $P2566
  if_2561_end:
.annotate 'line', 765
    .return ($P2560)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair_str"  :subid("413_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_2577
.annotate 'line', 784
    .lex "$ast", param_2577
.annotate 'line', 785
    get_hll_global $P2580, ["PAST"], "Op"
    find_lex $P2581, "$ast"
    unless_null $P2581, vivify_1412
    new $P2581, "Undef"
  vivify_1412:
    $P2582 = $P2580."ACCEPTS"($P2581)
    if $P2582, if_2579
.annotate 'line', 787
    find_lex $P2586, "$ast"
    unless_null $P2586, vivify_1413
    new $P2586, "Undef"
  vivify_1413:
    $P2587 = $P2586."value"()
    set $P2578, $P2587
.annotate 'line', 785
    goto if_2579_end
  if_2579:
.annotate 'line', 786
    find_lex $P2583, "$ast"
    unless_null $P2583, vivify_1414
    new $P2583, "Undef"
  vivify_1414:
    $P2584 = $P2583."list"()
    join $S2585, " ", $P2584
    new $P2578, 'String'
    set $P2578, $S2585
  if_2579_end:
.annotate 'line', 784
    .return ($P2578)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "push_block_handler"  :subid("414_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_2590
    .param pmc param_2591
.annotate 'line', 1018
    .lex "$/", param_2590
    .lex "$block", param_2591
.annotate 'line', 1019
    find_lex $P2593, "$?PACKAGE"
    get_who $P2594, $P2593
    set $P2595, $P2594["@BLOCK"]
    unless_null $P2595, vivify_1415
    $P2595 = root_new ['parrot';'ResizablePMCArray']
  vivify_1415:
    set $P2596, $P2595[0]
    unless_null $P2596, vivify_1416
    new $P2596, "Undef"
  vivify_1416:
    $P2597 = $P2596."handlers"()
    if $P2597, unless_2592_end
.annotate 'line', 1020
    find_lex $P2598, "$?PACKAGE"
    get_who $P2599, $P2598
    set $P2600, $P2599["@BLOCK"]
    unless_null $P2600, vivify_1417
    $P2600 = root_new ['parrot';'ResizablePMCArray']
  vivify_1417:
    set $P2601, $P2600[0]
    unless_null $P2601, vivify_1418
    new $P2601, "Undef"
  vivify_1418:
    new $P2602, "ResizablePMCArray"
    $P2601."handlers"($P2602)
  unless_2592_end:
.annotate 'line', 1022
    find_lex $P2604, "$block"
    unless_null $P2604, vivify_1419
    new $P2604, "Undef"
  vivify_1419:
    $P2605 = $P2604."arity"()
    if $P2605, unless_2603_end
.annotate 'line', 1023
    find_lex $P2606, "$block"
    unless_null $P2606, vivify_1420
    new $P2606, "Undef"
  vivify_1420:
.annotate 'line', 1024
    get_hll_global $P2607, ["PAST"], "Op"
.annotate 'line', 1025
    get_hll_global $P2608, ["PAST"], "Var"
    $P2609 = $P2608."new"("lexical" :named("scope"), "$!" :named("name"), 1 :named("isdecl"))
.annotate 'line', 1026
    get_hll_global $P2610, ["PAST"], "Var"
    $P2611 = $P2610."new"("lexical" :named("scope"), "$_" :named("name"))
    $P2612 = $P2607."new"($P2609, $P2611, "bind" :named("pasttype"))
.annotate 'line', 1024
    $P2606."unshift"($P2612)
.annotate 'line', 1029
    find_lex $P2613, "$block"
    unless_null $P2613, vivify_1421
    new $P2613, "Undef"
  vivify_1421:
    get_hll_global $P2614, ["PAST"], "Var"
    $P2615 = $P2614."new"("$_" :named("name"), "parameter" :named("scope"))
    $P2613."unshift"($P2615)
.annotate 'line', 1030
    find_lex $P2616, "$block"
    unless_null $P2616, vivify_1422
    new $P2616, "Undef"
  vivify_1422:
    $P2616."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 1031
    find_lex $P2617, "$block"
    unless_null $P2617, vivify_1423
    new $P2617, "Undef"
  vivify_1423:
    $P2617."symbol"("$!", "lexical" :named("scope"))
.annotate 'line', 1032
    find_lex $P2618, "$block"
    unless_null $P2618, vivify_1424
    new $P2618, "Undef"
  vivify_1424:
    $P2618."arity"(1)
  unless_2603_end:
.annotate 'line', 1034
    find_lex $P2619, "$block"
    unless_null $P2619, vivify_1425
    new $P2619, "Undef"
  vivify_1425:
    $P2619."blocktype"("declaration")
.annotate 'line', 1035
    find_lex $P2620, "$?PACKAGE"
    get_who $P2621, $P2620
    set $P2622, $P2621["@BLOCK"]
    unless_null $P2622, vivify_1426
    $P2622 = root_new ['parrot';'ResizablePMCArray']
  vivify_1426:
    set $P2623, $P2622[0]
    unless_null $P2623, vivify_1427
    new $P2623, "Undef"
  vivify_1427:
    $P2624 = $P2623."handlers"()
.annotate 'line', 1036
    get_hll_global $P2625, ["PAST"], "Control"
    find_lex $P2626, "$/"
    unless_null $P2626, vivify_1428
    new $P2626, "Undef"
  vivify_1428:
.annotate 'line', 1038
    get_hll_global $P2627, ["PAST"], "Stmts"
.annotate 'line', 1039
    get_hll_global $P2628, ["PAST"], "Op"
    find_lex $P2629, "$block"
    unless_null $P2629, vivify_1429
    new $P2629, "Undef"
  vivify_1429:
.annotate 'line', 1041
    get_hll_global $P2630, ["PAST"], "Var"
    $P2631 = $P2630."new"("register" :named("scope"), "exception" :named("name"))
    $P2632 = $P2628."new"($P2629, $P2631, "call" :named("pasttype"))
.annotate 'line', 1043
    get_hll_global $P2633, ["PAST"], "Op"
.annotate 'line', 1044
    get_hll_global $P2634, ["PAST"], "Var"
.annotate 'line', 1045
    get_hll_global $P2635, ["PAST"], "Var"
    $P2636 = $P2635."new"("register" :named("scope"), "exception" :named("name"))
    $P2637 = $P2634."new"($P2636, "handled", "keyed" :named("scope"))
.annotate 'line', 1044
    $P2638 = $P2633."new"($P2637, 1, "bind" :named("pasttype"))
.annotate 'line', 1043
    $P2639 = $P2627."new"($P2632, $P2638)
.annotate 'line', 1038
    $P2640 = $P2625."new"($P2639, $P2626 :named("node"))
.annotate 'line', 1036
    $P2641 = $P2624."unshift"($P2640)
.annotate 'line', 1018
    .return ($P2641)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "only_star_block"  :subid("415_1303340952.947") :outer("407_1303340952.947")
.annotate 'line', 1582
    new $P2644, "Undef"
    .lex "$past", $P2644
    find_lex $P2645, "$?PACKAGE"
    get_who $P2646, $P2645
    set $P2647, $P2646["@BLOCK"]
    unless_null $P2647, vivify_1430
    $P2647 = root_new ['parrot';'ResizablePMCArray']
  vivify_1430:
    $P2648 = $P2647."shift"()
    store_lex "$past", $P2648
.annotate 'line', 1583
    find_lex $P2649, "$past"
    unless_null $P2649, vivify_1431
    new $P2649, "Undef"
  vivify_1431:
    $P2649."closure"(1)
.annotate 'line', 1584
    find_lex $P2650, "$past"
    unless_null $P2650, vivify_1432
    new $P2650, "Undef"
  vivify_1432:
    get_hll_global $P2651, ["PAST"], "Op"
    $P2652 = $P2651."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P2650."push"($P2652)
    find_lex $P2653, "$past"
    unless_null $P2653, vivify_1433
    new $P2653, "Undef"
  vivify_1433:
.annotate 'line', 1581
    .return ($P2653)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "attach_multi_signature"  :subid("416_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_2656
.annotate 'line', 1590
    .const 'Sub' $P2670 = "417_1303340952.947" 
    capture_lex $P2670
    .lex "$routine", param_2656
.annotate 'line', 1594
    new $P2657, "Undef"
    .lex "$types", $P2657
.annotate 'line', 1595
    new $P2658, "Undef"
    .lex "$definednesses", $P2658
.annotate 'line', 1594
    get_hll_global $P2659, ["PAST"], "Op"
    $P2660 = $P2659."new"("list" :named("pasttype"))
    store_lex "$types", $P2660
.annotate 'line', 1595
    get_hll_global $P2661, ["PAST"], "Op"
    $P2662 = $P2661."new"("list" :named("pasttype"))
    store_lex "$definednesses", $P2662
.annotate 'line', 1596
    find_lex $P2664, "$routine"
    unless_null $P2664, vivify_1434
    $P2664 = root_new ['parrot';'ResizablePMCArray']
  vivify_1434:
    set $P2665, $P2664[0]
    unless_null $P2665, vivify_1435
    new $P2665, "Undef"
  vivify_1435:
    $P2666 = $P2665."list"()
    defined $I2667, $P2666
    unless $I2667, for_undef_1436
    iter $P2663, $P2666
    new $P2708, 'ExceptionHandler'
    set_label $P2708, loop2707_handler
    $P2708."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2708
  loop2707_test:
    unless $P2663, loop2707_done
    shift $P2668, $P2663
  loop2707_redo:
    .const 'Sub' $P2670 = "417_1303340952.947" 
    capture_lex $P2670
    $P2670($P2668)
  loop2707_next:
    goto loop2707_test
  loop2707_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2709, exception, 'type'
    eq $P2709, .CONTROL_LOOP_NEXT, loop2707_next
    eq $P2709, .CONTROL_LOOP_REDO, loop2707_redo
  loop2707_done:
    pop_eh 
  for_undef_1436:
.annotate 'line', 1603
    find_lex $P2710, "$routine"
    unless_null $P2710, vivify_1446
    new $P2710, "Undef"
  vivify_1446:
    $P2711 = $P2710."loadinit"()
    get_hll_global $P2712, ["PAST"], "Op"
.annotate 'line', 1604
    get_hll_global $P2713, ["PAST"], "Var"
    $P2714 = $P2713."new"("block" :named("name"), "register" :named("scope"))
    find_lex $P2715, "$types"
    unless_null $P2715, vivify_1447
    new $P2715, "Undef"
  vivify_1447:
    find_lex $P2716, "$definednesses"
    unless_null $P2716, vivify_1448
    new $P2716, "Undef"
  vivify_1448:
    $P2717 = $P2712."new"($P2714, $P2715, $P2716, "set_sub_multisig vPPP" :named("pirop"))
.annotate 'line', 1603
    $P2718 = $P2711."push"($P2717)
.annotate 'line', 1590
    .return ($P2718)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2669"  :anon :subid("417_1303340952.947") :outer("416_1303340952.947")
    .param pmc param_2671
.annotate 'line', 1596
    .lex "$_", param_2671
.annotate 'line', 1597
    get_hll_global $P2676, ["PAST"], "Var"
    find_lex $P2677, "$_"
    unless_null $P2677, vivify_1437
    new $P2677, "Undef"
  vivify_1437:
    $P2678 = $P2676."ACCEPTS"($P2677)
    if $P2678, if_2675
    set $P2674, $P2678
    goto if_2675_end
  if_2675:
    find_lex $P2679, "$_"
    unless_null $P2679, vivify_1438
    new $P2679, "Undef"
  vivify_1438:
    $S2680 = $P2679."scope"()
    iseq $I2681, $S2680, "parameter"
    new $P2674, 'Integer'
    set $P2674, $I2681
  if_2675_end:
    if $P2674, if_2673
    set $P2672, $P2674
    goto if_2673_end
  if_2673:
.annotate 'line', 1598
    find_lex $P2682, "$types"
    unless_null $P2682, vivify_1439
    new $P2682, "Undef"
  vivify_1439:
    find_lex $P2684, "$_"
    unless_null $P2684, vivify_1440
    new $P2684, "Undef"
  vivify_1440:
    $P2685 = $P2684."multitype"()
    set $P2683, $P2685
    defined $I2687, $P2683
    if $I2687, default_2686
    get_hll_global $P2688, ["PAST"], "Op"
    $P2689 = $P2688."new"("null P" :named("pirop"))
    set $P2683, $P2689
  default_2686:
    $P2682."push"($P2683)
.annotate 'line', 1599
    find_lex $P2690, "$definednesses"
    unless_null $P2690, vivify_1441
    new $P2690, "Undef"
  vivify_1441:
    find_lex $P2693, "$_"
    unless_null $P2693, vivify_1442
    $P2693 = root_new ['parrot';'Hash']
  vivify_1442:
    set $P2694, $P2693["definedness"]
    unless_null $P2694, vivify_1443
    new $P2694, "Undef"
  vivify_1443:
    set $S2695, $P2694
    iseq $I2696, $S2695, "D"
    if $I2696, if_2692
.annotate 'line', 1600
    find_lex $P2700, "$_"
    unless_null $P2700, vivify_1444
    $P2700 = root_new ['parrot';'Hash']
  vivify_1444:
    set $P2701, $P2700["definedness"]
    unless_null $P2701, vivify_1445
    new $P2701, "Undef"
  vivify_1445:
    set $S2702, $P2701
    iseq $I2703, $S2702, "U"
    if $I2703, if_2699
    new $P2705, "Integer"
    assign $P2705, 0
    set $P2698, $P2705
    goto if_2699_end
  if_2699:
    new $P2704, "Integer"
    assign $P2704, 2
    set $P2698, $P2704
  if_2699_end:
    set $P2691, $P2698
.annotate 'line', 1599
    goto if_2692_end
  if_2692:
    new $P2697, "Integer"
    assign $P2697, 1
    set $P2691, $P2697
  if_2692_end:
    $P2706 = $P2690."push"($P2691)
.annotate 'line', 1597
    set $P2672, $P2706
  if_2673_end:
.annotate 'line', 1596
    .return ($P2672)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "control"  :subid("418_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_2721
    .param pmc param_2722
.annotate 'line', 2068
    .lex "$/", param_2721
    .lex "$type", param_2722
.annotate 'line', 2069
    find_lex $P2723, "$/"
    get_hll_global $P2724, ["PAST"], "Op"
    find_lex $P2725, "$/"
    unless_null $P2725, vivify_1449
    new $P2725, "Undef"
  vivify_1449:
.annotate 'line', 2073
    get_hll_global $P2726, ["PAST"], "Val"
    find_lex $P2727, "$type"
    unless_null $P2727, vivify_1450
    new $P2727, "Undef"
  vivify_1450:
    $P2728 = $P2726."new"($P2727 :named("value"), "!except_types" :named("returns"))
    $P2729 = $P2724."new"(0, $P2728, $P2725 :named("node"), "die__vii" :named("pirop"))
.annotate 'line', 2069
    $P2730 = $P2723."!make"($P2729)
.annotate 'line', 2068
    .return ($P2730)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "lexical_package_lookup"  :subid("419_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_2735
    .param pmc param_2736
.annotate 'line', 2087
    .const 'Sub' $P2786 = "421_1303340952.947" 
    capture_lex $P2786
    .const 'Sub' $P2773 = "420_1303340952.947" 
    capture_lex $P2773
    new $P2734, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2734, control_2733
    push_eh $P2734
    .lex "@name", param_2735
    .lex "$/", param_2736
.annotate 'line', 2105
    new $P2737, "Undef"
    .lex "$lookup", $P2737
.annotate 'line', 2089
    find_lex $P2739, "@name"
    unless_null $P2739, vivify_1451
    $P2739 = root_new ['parrot';'ResizablePMCArray']
  vivify_1451:
    set $N2740, $P2739
    iseq $I2741, $N2740, 0.0
    unless $I2741, if_2738_end
    find_lex $P2742, "$/"
    unless_null $P2742, vivify_1452
    new $P2742, "Undef"
  vivify_1452:
    $P2743 = $P2742."CURSOR"()
    $P2743."panic"("Cannot compile empty name")
  if_2738_end:
.annotate 'line', 2093
    find_lex $P2745, "@name"
    unless_null $P2745, vivify_1453
    $P2745 = root_new ['parrot';'ResizablePMCArray']
  vivify_1453:
    set $N2746, $P2745
    iseq $I2747, $N2746, 1.0
    unless $I2747, if_2744_end
.annotate 'line', 2094
    new $P2748, "Exception"
    set $P2748['type'], .CONTROL_RETURN
    get_hll_global $P2749, ["PAST"], "Var"
    find_lex $P2750, "$/"
    unless_null $P2750, vivify_1454
    new $P2750, "Undef"
  vivify_1454:
.annotate 'line', 2096
    get_hll_global $P2751, ["PAST"], "Op"
.annotate 'line', 2098
    get_hll_global $P2752, ["PAST"], "Var"
    $P2753 = $P2752."new"("$?PACKAGE" :named("name"), "lexical" :named("scope"))
    $P2754 = $P2751."new"($P2753, "get_who PP" :named("pirop"))
.annotate 'line', 2100
    find_lex $P2755, "@name"
    unless_null $P2755, vivify_1455
    $P2755 = root_new ['parrot';'ResizablePMCArray']
  vivify_1455:
    set $P2756, $P2755[0]
    unless_null $P2756, vivify_1456
    new $P2756, "Undef"
  vivify_1456:
    set $S2757, $P2756
    $P2758 = $P2749."new"($P2754, $S2757, "keyed" :named("scope"), $P2750 :named("node"))
.annotate 'line', 2094
    setattribute $P2748, 'payload', $P2758
    throw $P2748
  if_2744_end:
.annotate 'line', 2093
    find_lex $P2759, "$lookup"
    unless_null $P2759, vivify_1457
    new $P2759, "Undef"
  vivify_1457:
.annotate 'line', 2106
    find_lex $P2761, "@name"
    unless_null $P2761, vivify_1458
    $P2761 = root_new ['parrot';'ResizablePMCArray']
  vivify_1458:
    set $P2762, $P2761[0]
    unless_null $P2762, vivify_1459
    new $P2762, "Undef"
  vivify_1459:
    $P2763 = "is_lexical"($P2762)
    if $P2763, if_2760
.annotate 'line', 2115
    .const 'Sub' $P2786 = "421_1303340952.947" 
    capture_lex $P2786
    $P2786()
    goto if_2760_end
  if_2760:
.annotate 'line', 2107
    get_hll_global $P2764, ["PAST"], "Var"
    find_lex $P2765, "@name"
    unless_null $P2765, vivify_1464
    $P2765 = root_new ['parrot';'ResizablePMCArray']
  vivify_1464:
    $P2766 = $P2765."shift"()
    $P2767 = $P2764."new"($P2766 :named("name"), "lexical" :named("scope"))
    store_lex "$lookup", $P2767
.annotate 'line', 2108
    find_lex $P2769, "@name"
    unless_null $P2769, vivify_1465
    $P2769 = root_new ['parrot';'ResizablePMCArray']
  vivify_1465:
    defined $I2770, $P2769
    unless $I2770, for_undef_1466
    iter $P2768, $P2769
    new $P2783, 'ExceptionHandler'
    set_label $P2783, loop2782_handler
    $P2783."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2783
  loop2782_test:
    unless $P2768, loop2782_done
    shift $P2771, $P2768
  loop2782_redo:
    .const 'Sub' $P2773 = "420_1303340952.947" 
    capture_lex $P2773
    $P2773($P2771)
  loop2782_next:
    goto loop2782_test
  loop2782_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2784, exception, 'type'
    eq $P2784, .CONTROL_LOOP_NEXT, loop2782_next
    eq $P2784, .CONTROL_LOOP_REDO, loop2782_redo
  loop2782_done:
    pop_eh 
  for_undef_1466:
  if_2760_end:
.annotate 'line', 2130
    find_lex $P2801, "$lookup"
    unless_null $P2801, vivify_1469
    new $P2801, "Undef"
  vivify_1469:
    find_lex $P2802, "$/"
    unless_null $P2802, vivify_1470
    new $P2802, "Undef"
  vivify_1470:
    $P2801."node"($P2802)
.annotate 'line', 2131
    new $P2803, "Exception"
    set $P2803['type'], .CONTROL_RETURN
    find_lex $P2804, "$lookup"
    unless_null $P2804, vivify_1471
    new $P2804, "Undef"
  vivify_1471:
    setattribute $P2803, 'payload', $P2804
    throw $P2803
.annotate 'line', 2087
    .return ()
  control_2733:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2805, exception, "payload"
    .return ($P2805)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2785"  :anon :subid("421_1303340952.947") :outer("419_1303340952.947")
.annotate 'line', 2120
    new $P2787, "Undef"
    .lex "$name", $P2787
    find_lex $P2788, "@name"
    unless_null $P2788, vivify_1460
    $P2788 = root_new ['parrot';'ResizablePMCArray']
  vivify_1460:
    $P2789 = $P2788."pop"()
    store_lex "$name", $P2789
.annotate 'line', 2121
    get_hll_global $P2790, ["PAST"], "Var"
.annotate 'line', 2123
    get_hll_global $P2791, ["PAST"], "Op"
.annotate 'line', 2125
    get_hll_global $P2792, ["PAST"], "Var"
    find_lex $P2793, "@name"
    unless_null $P2793, vivify_1461
    $P2793 = root_new ['parrot';'ResizablePMCArray']
  vivify_1461:
    $P2794 = $P2793."pop"()
    find_lex $P2795, "@name"
    unless_null $P2795, vivify_1462
    $P2795 = root_new ['parrot';'ResizablePMCArray']
  vivify_1462:
    $P2796 = $P2792."new"($P2794 :named("name"), $P2795 :named("namespace"), "package" :named("scope"))
    $P2797 = $P2791."new"($P2796, "get_who PP" :named("pirop"))
.annotate 'line', 2127
    find_lex $P2798, "$name"
    unless_null $P2798, vivify_1463
    new $P2798, "Undef"
  vivify_1463:
    set $S2799, $P2798
    $P2800 = $P2790."new"($P2797, $S2799, "keyed" :named("scope"))
.annotate 'line', 2121
    store_lex "$lookup", $P2800
.annotate 'line', 2115
    .return ($P2800)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2772"  :anon :subid("420_1303340952.947") :outer("419_1303340952.947")
    .param pmc param_2774
.annotate 'line', 2108
    .lex "$_", param_2774
.annotate 'line', 2109
    get_hll_global $P2775, ["PAST"], "Var"
.annotate 'line', 2111
    get_hll_global $P2776, ["PAST"], "Op"
    find_lex $P2777, "$lookup"
    unless_null $P2777, vivify_1467
    new $P2777, "Undef"
  vivify_1467:
    $P2778 = $P2776."new"($P2777, "get_who PP" :named("pirop"))
.annotate 'line', 2112
    find_lex $P2779, "$_"
    unless_null $P2779, vivify_1468
    new $P2779, "Undef"
  vivify_1468:
    set $S2780, $P2779
    $P2781 = $P2775."new"($P2778, $S2780, "keyed" :named("scope"))
.annotate 'line', 2109
    store_lex "$lookup", $P2781
.annotate 'line', 2108
    .return ($P2781)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "is_lexical"  :subid("422_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_2808
.annotate 'line', 2136
    .lex "$name", param_2808
.annotate 'line', 2137
    find_lex $P2809, "$name"
    unless_null $P2809, vivify_1472
    new $P2809, "Undef"
  vivify_1472:
    $P2810 = "is_scope"($P2809, "lexical")
.annotate 'line', 2136
    .return ($P2810)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "is_package"  :subid("423_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_2813
.annotate 'line', 2142
    .lex "$name", param_2813
.annotate 'line', 2143
    find_lex $P2814, "$name"
    unless_null $P2814, vivify_1473
    new $P2814, "Undef"
  vivify_1473:
    $P2815 = "is_scope"($P2814, "package")
.annotate 'line', 2142
    .return ($P2815)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "is_scope"  :subid("424_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_2820
    .param pmc param_2821
.annotate 'line', 2148
    .const 'Sub' $P2829 = "425_1303340952.947" 
    capture_lex $P2829
    new $P2819, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2819, control_2818
    push_eh $P2819
    .lex "$name", param_2820
    .lex "$wanted_scope", param_2821
.annotate 'line', 2149
    find_lex $P2823, "$?PACKAGE"
    get_who $P2824, $P2823
    set $P2825, $P2824["@BLOCK"]
    unless_null $P2825, vivify_1474
    $P2825 = root_new ['parrot';'ResizablePMCArray']
  vivify_1474:
    defined $I2826, $P2825
    unless $I2826, for_undef_1475
    iter $P2822, $P2825
    new $P2848, 'ExceptionHandler'
    set_label $P2848, loop2847_handler
    $P2848."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2848
  loop2847_test:
    unless $P2822, loop2847_done
    shift $P2827, $P2822
  loop2847_redo:
    .const 'Sub' $P2829 = "425_1303340952.947" 
    capture_lex $P2829
    $P2829($P2827)
  loop2847_next:
    goto loop2847_test
  loop2847_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2849, exception, 'type'
    eq $P2849, .CONTROL_LOOP_NEXT, loop2847_next
    eq $P2849, .CONTROL_LOOP_REDO, loop2847_redo
  loop2847_done:
    pop_eh 
  for_undef_1475:
.annotate 'line', 2148
    .return (0)
  control_2818:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2850, exception, "payload"
    .return ($P2850)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2828"  :anon :subid("425_1303340952.947") :outer("424_1303340952.947")
    .param pmc param_2831
.annotate 'line', 2150
    $P2830 = root_new ['parrot';'Hash']
    .lex "%sym", $P2830
    .lex "$_", param_2831
    find_lex $P2832, "$_"
    unless_null $P2832, vivify_1476
    new $P2832, "Undef"
  vivify_1476:
    find_lex $P2833, "$name"
    unless_null $P2833, vivify_1477
    new $P2833, "Undef"
  vivify_1477:
    $P2834 = $P2832."symbol"($P2833)
    store_lex "%sym", $P2834
.annotate 'line', 2151
    find_lex $P2837, "%sym"
    unless_null $P2837, vivify_1478
    $P2837 = root_new ['parrot';'Hash']
  vivify_1478:
    set $N2838, $P2837
    if $N2838, if_2836
    new $P2835, 'Float'
    set $P2835, $N2838
    goto if_2836_end
  if_2836:
.annotate 'line', 2152
    new $P2839, "Exception"
    set $P2839['type'], .CONTROL_RETURN
    find_lex $P2840, "%sym"
    unless_null $P2840, vivify_1479
    $P2840 = root_new ['parrot';'Hash']
  vivify_1479:
    set $P2841, $P2840["scope"]
    unless_null $P2841, vivify_1480
    new $P2841, "Undef"
  vivify_1480:
    set $S2842, $P2841
    find_lex $P2843, "$wanted_scope"
    unless_null $P2843, vivify_1481
    new $P2843, "Undef"
  vivify_1481:
    set $S2844, $P2843
    iseq $I2845, $S2842, $S2844
    new $P2846, 'Integer'
    set $P2846, $I2845
    setattribute $P2839, 'payload', $P2846
    throw $P2839
  if_2836_end:
.annotate 'line', 2149
    .return ($P2835)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "TOP"  :subid("426_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_2861
    .param pmc param_2862
.annotate 'line', 774
    .lex "self", param_2861
    .lex "$/", param_2862
    find_lex $P2863, "$/"
    find_lex $P2864, "$/"
    unless_null $P2864, vivify_1482
    $P2864 = root_new ['parrot';'Hash']
  vivify_1482:
    set $P2865, $P2864["comp_unit"]
    unless_null $P2865, vivify_1483
    new $P2865, "Undef"
  vivify_1483:
    $P2866 = $P2865."ast"()
    $P2867 = $P2863."!make"($P2866)
    .return ($P2867)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "deflongname"  :subid("427_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_2869
    .param pmc param_2870
.annotate 'line', 776
    .lex "self", param_2869
    .lex "$/", param_2870
.annotate 'line', 777
    find_lex $P2871, "$/"
.annotate 'line', 778
    find_lex $P2874, "$/"
    unless_null $P2874, vivify_1484
    $P2874 = root_new ['parrot';'Hash']
  vivify_1484:
    set $P2875, $P2874["colonpair"]
    unless_null $P2875, vivify_1485
    new $P2875, "Undef"
  vivify_1485:
    if $P2875, if_2873
.annotate 'line', 780
    find_lex $P2895, "$/"
    unless_null $P2895, vivify_1486
    new $P2895, "Undef"
  vivify_1486:
    set $S2896, $P2895
    new $P2872, 'String'
    set $P2872, $S2896
.annotate 'line', 778
    goto if_2873_end
  if_2873:
    find_lex $P2876, "$/"
    unless_null $P2876, vivify_1487
    $P2876 = root_new ['parrot';'Hash']
  vivify_1487:
    set $P2877, $P2876["identifier"]
    unless_null $P2877, vivify_1488
    new $P2877, "Undef"
  vivify_1488:
    set $S2878, $P2877
    new $P2879, 'String'
    set $P2879, $S2878
    concat $P2880, $P2879, ":"
    find_lex $P2881, "$/"
    unless_null $P2881, vivify_1489
    $P2881 = root_new ['parrot';'Hash']
  vivify_1489:
    set $P2882, $P2881["colonpair"]
    unless_null $P2882, vivify_1490
    $P2882 = root_new ['parrot';'ResizablePMCArray']
  vivify_1490:
    set $P2883, $P2882[0]
    unless_null $P2883, vivify_1491
    new $P2883, "Undef"
  vivify_1491:
    $P2884 = $P2883."ast"()
    $S2885 = $P2884."named"()
    concat $P2886, $P2880, $S2885
    concat $P2887, $P2886, "<"
.annotate 'line', 779
    find_lex $P2888, "$/"
    unless_null $P2888, vivify_1492
    $P2888 = root_new ['parrot';'Hash']
  vivify_1492:
    set $P2889, $P2888["colonpair"]
    unless_null $P2889, vivify_1493
    $P2889 = root_new ['parrot';'ResizablePMCArray']
  vivify_1493:
    set $P2890, $P2889[0]
    unless_null $P2890, vivify_1494
    new $P2890, "Undef"
  vivify_1494:
    $P2891 = $P2890."ast"()
    $S2892 = "colonpair_str"($P2891)
    concat $P2893, $P2887, $S2892
    concat $P2894, $P2893, ">"
    set $P2872, $P2894
  if_2873_end:
.annotate 'line', 778
    $P2897 = $P2871."!make"($P2872)
.annotate 'line', 776
    .return ($P2897)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "comp_unit"  :subid("428_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_2900
    .param pmc param_2901
.annotate 'line', 790
    .lex "self", param_2900
    .lex "$/", param_2901
.annotate 'line', 791
    new $P2902, "Undef"
    .lex "$mainline", $P2902
.annotate 'line', 792
    new $P2903, "Undef"
    .lex "$unit", $P2903
.annotate 'line', 791
    find_lex $P2904, "$/"
    unless_null $P2904, vivify_1495
    $P2904 = root_new ['parrot';'Hash']
  vivify_1495:
    set $P2905, $P2904["statementlist"]
    unless_null $P2905, vivify_1496
    new $P2905, "Undef"
  vivify_1496:
    $P2906 = $P2905."ast"()
    store_lex "$mainline", $P2906
.annotate 'line', 792
    find_lex $P2907, "$?PACKAGE"
    get_who $P2908, $P2907
    set $P2909, $P2908["@BLOCK"]
    unless_null $P2909, vivify_1497
    $P2909 = root_new ['parrot';'ResizablePMCArray']
  vivify_1497:
    $P2910 = $P2909."shift"()
    store_lex "$unit", $P2910
.annotate 'line', 796
    find_lex $P2911, "$unit"
    unless_null $P2911, vivify_1498
    new $P2911, "Undef"
  vivify_1498:
    $P2912 = $P2911."loadinit"()
    find_dynamic_lex $P2913, "$*SC"
    unless_null $P2913, vivify_1499
    get_hll_global $P2913, "$SC"
    unless_null $P2913, vivify_1500
    die "Contextual $*SC not found"
  vivify_1500:
  vivify_1499:
    $P2914 = $P2913."to_past"()
    $P2912."push"($P2914)
.annotate 'line', 801
    find_dynamic_lex $P2916, "$*HAS_YOU_ARE_HERE"
    unless_null $P2916, vivify_1501
    get_hll_global $P2916, "$HAS_YOU_ARE_HERE"
    unless_null $P2916, vivify_1502
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_1502:
  vivify_1501:
    if $P2916, unless_2915_end
.annotate 'line', 802
    find_lex $P2917, "$unit"
    unless_null $P2917, vivify_1503
    new $P2917, "Undef"
  vivify_1503:
    find_lex $P2918, "self"
    $P2919 = $P2918."CTXSAVE"()
    $P2917."push"($P2919)
  unless_2915_end:
.annotate 'line', 806
    find_lex $P2920, "$unit"
    unless_null $P2920, vivify_1504
    new $P2920, "Undef"
  vivify_1504:
    $P2920."loadlibs"("nqp_group", "nqp_ops")
.annotate 'line', 810
    find_dynamic_lex $P2922, "$*MAIN_SUB"
    unless_null $P2922, vivify_1505
    get_hll_global $P2922, "$MAIN_SUB"
    unless_null $P2922, vivify_1506
    die "Contextual $*MAIN_SUB not found"
  vivify_1506:
  vivify_1505:
    unless $P2922, if_2921_end
.annotate 'line', 811
    find_lex $P2923, "$unit"
    unless_null $P2923, vivify_1507
    new $P2923, "Undef"
  vivify_1507:
    get_hll_global $P2924, ["PAST"], "Var"
    $P2925 = $P2924."new"("parameter" :named("scope"), "@ARGS" :named("name"), 1 :named("slurpy"))
    $P2923."unshift"($P2925)
.annotate 'line', 812
    find_lex $P2926, "$mainline"
    unless_null $P2926, vivify_1508
    new $P2926, "Undef"
  vivify_1508:
    get_hll_global $P2927, ["PAST"], "Op"
.annotate 'line', 814
    get_hll_global $P2928, ["PAST"], "Var"
    $P2929 = $P2928."new"("lexical" :named("scope"), "@ARGS" :named("name"))
.annotate 'line', 815
    get_hll_global $P2930, ["PAST"], "Op"
.annotate 'line', 816
    get_hll_global $P2931, ["PAST"], "Val"
    find_dynamic_lex $P2932, "$*MAIN_SUB"
    unless_null $P2932, vivify_1509
    get_hll_global $P2932, "$MAIN_SUB"
    unless_null $P2932, vivify_1510
    die "Contextual $*MAIN_SUB not found"
  vivify_1510:
  vivify_1509:
    $P2933 = $P2931."new"($P2932 :named("value"))
.annotate 'line', 817
    get_hll_global $P2934, ["PAST"], "Var"
    $P2935 = $P2934."new"("lexical" :named("scope"), "@ARGS" :named("name"), 1 :named("flat"))
    $P2936 = $P2930."new"($P2933, $P2935, "call" :named("pasttype"))
.annotate 'line', 815
    $P2937 = $P2927."new"($P2929, $P2936, "if" :named("pasttype"))
.annotate 'line', 812
    $P2926."push"($P2937)
  if_2921_end:
.annotate 'line', 825
    find_lex $P2938, "$unit"
    unless_null $P2938, vivify_1511
    new $P2938, "Undef"
  vivify_1511:
.annotate 'line', 826
    get_hll_global $P2939, ["PAST"], "Op"
    find_lex $P2940, "$mainline"
    unless_null $P2940, vivify_1512
    new $P2940, "Undef"
  vivify_1512:
    $P2941 = $P2939."new"($P2940, "return" :named("pirop"))
    $P2938."push"($P2941)
.annotate 'line', 831
    find_lex $P2942, "$unit"
    unless_null $P2942, vivify_1513
    new $P2942, "Undef"
  vivify_1513:
.annotate 'line', 832
    get_hll_global $P2943, ["PAST"], "Block"
.annotate 'line', 834
    get_hll_global $P2944, ["PAST"], "Op"
    get_hll_global $P2945, ["PAST"], "Val"
    find_lex $P2946, "$unit"
    unless_null $P2946, vivify_1514
    new $P2946, "Undef"
  vivify_1514:
    $P2947 = $P2945."new"($P2946 :named("value"))
    $P2948 = $P2944."new"($P2947, "call" :named("pasttype"))
    $P2949 = $P2943."new"($P2948, ":load" :named("pirflags"), 0 :named("lexical"), "" :named("namespace"))
.annotate 'line', 832
    $P2942."push"($P2949)
.annotate 'line', 837
    find_lex $P2950, "$unit"
    unless_null $P2950, vivify_1515
    new $P2950, "Undef"
  vivify_1515:
    find_lex $P2951, "$/"
    unless_null $P2951, vivify_1516
    new $P2951, "Undef"
  vivify_1516:
    $P2950."node"($P2951)
.annotate 'line', 840
    find_lex $P2952, "$unit"
    unless_null $P2952, vivify_1517
    new $P2952, "Undef"
  vivify_1517:
    $P2952."hll"("nqp")
.annotate 'line', 842
    find_lex $P2953, "$/"
    find_lex $P2954, "$unit"
    unless_null $P2954, vivify_1518
    new $P2954, "Undef"
  vivify_1518:
    $P2955 = $P2953."!make"($P2954)
.annotate 'line', 790
    .return ($P2955)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statementlist"  :subid("429_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_2957
    .param pmc param_2958
.annotate 'line', 845
    .const 'Sub' $P2972 = "430_1303340952.947" 
    capture_lex $P2972
    .lex "self", param_2957
    .lex "$/", param_2958
.annotate 'line', 846
    new $P2959, "Undef"
    .lex "$past", $P2959
    get_hll_global $P2960, ["PAST"], "Stmts"
    find_lex $P2961, "$/"
    unless_null $P2961, vivify_1519
    new $P2961, "Undef"
  vivify_1519:
    $P2962 = $P2960."new"($P2961 :named("node"))
    store_lex "$past", $P2962
.annotate 'line', 847
    find_lex $P2964, "$/"
    unless_null $P2964, vivify_1520
    $P2964 = root_new ['parrot';'Hash']
  vivify_1520:
    set $P2965, $P2964["statement"]
    unless_null $P2965, vivify_1521
    new $P2965, "Undef"
  vivify_1521:
    unless $P2965, if_2963_end
.annotate 'line', 848
    find_lex $P2967, "$/"
    unless_null $P2967, vivify_1522
    $P2967 = root_new ['parrot';'Hash']
  vivify_1522:
    set $P2968, $P2967["statement"]
    unless_null $P2968, vivify_1523
    new $P2968, "Undef"
  vivify_1523:
    defined $I2969, $P2968
    unless $I2969, for_undef_1524
    iter $P2966, $P2968
    new $P2992, 'ExceptionHandler'
    set_label $P2992, loop2991_handler
    $P2992."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2992
  loop2991_test:
    unless $P2966, loop2991_done
    shift $P2970, $P2966
  loop2991_redo:
    .const 'Sub' $P2972 = "430_1303340952.947" 
    capture_lex $P2972
    $P2972($P2970)
  loop2991_next:
    goto loop2991_test
  loop2991_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2993, exception, 'type'
    eq $P2993, .CONTROL_LOOP_NEXT, loop2991_next
    eq $P2993, .CONTROL_LOOP_REDO, loop2991_redo
  loop2991_done:
    pop_eh 
  for_undef_1524:
  if_2963_end:
.annotate 'line', 855
    find_lex $P2994, "$/"
    find_lex $P2995, "$past"
    unless_null $P2995, vivify_1535
    new $P2995, "Undef"
  vivify_1535:
    $P2996 = $P2994."!make"($P2995)
.annotate 'line', 845
    .return ($P2996)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2971"  :anon :subid("430_1303340952.947") :outer("429_1303340952.947")
    .param pmc param_2974
.annotate 'line', 849
    new $P2973, "Undef"
    .lex "$ast", $P2973
    .lex "$_", param_2974
    find_lex $P2975, "$_"
    unless_null $P2975, vivify_1525
    new $P2975, "Undef"
  vivify_1525:
    $P2976 = $P2975."ast"()
    store_lex "$ast", $P2976
.annotate 'line', 850
    find_lex $P2978, "$ast"
    unless_null $P2978, vivify_1526
    $P2978 = root_new ['parrot';'Hash']
  vivify_1526:
    set $P2979, $P2978["sink"]
    unless_null $P2979, vivify_1527
    new $P2979, "Undef"
  vivify_1527:
    defined $I2980, $P2979
    unless $I2980, if_2977_end
    find_lex $P2981, "$ast"
    unless_null $P2981, vivify_1528
    $P2981 = root_new ['parrot';'Hash']
  vivify_1528:
    set $P2982, $P2981["sink"]
    unless_null $P2982, vivify_1529
    new $P2982, "Undef"
  vivify_1529:
    store_lex "$ast", $P2982
  if_2977_end:
.annotate 'line', 851
    find_lex $P2984, "$ast"
    unless_null $P2984, vivify_1530
    $P2984 = root_new ['parrot';'Hash']
  vivify_1530:
    set $P2985, $P2984["bareblock"]
    unless_null $P2985, vivify_1531
    new $P2985, "Undef"
  vivify_1531:
    unless $P2985, if_2983_end
    find_lex $P2986, "$ast"
    unless_null $P2986, vivify_1532
    new $P2986, "Undef"
  vivify_1532:
    $P2987 = "block_immediate"($P2986)
    store_lex "$ast", $P2987
  if_2983_end:
.annotate 'line', 852
    find_lex $P2988, "$past"
    unless_null $P2988, vivify_1533
    new $P2988, "Undef"
  vivify_1533:
    find_lex $P2989, "$ast"
    unless_null $P2989, vivify_1534
    new $P2989, "Undef"
  vivify_1534:
    $P2990 = $P2988."push"($P2989)
.annotate 'line', 848
    .return ($P2990)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement"  :subid("431_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_2998
    .param pmc param_2999
    .param pmc param_3000 :optional
    .param int has_param_3000 :opt_flag
.annotate 'line', 858
    .const 'Sub' $P3008 = "432_1303340952.947" 
    capture_lex $P3008
    .lex "self", param_2998
    .lex "$/", param_2999
    if has_param_3000, optparam_1536
    new $P3001, "Undef"
    set param_3000, $P3001
  optparam_1536:
    .lex "$key", param_3000
.annotate 'line', 859
    new $P3002, "Undef"
    .lex "$past", $P3002
.annotate 'line', 858
    find_lex $P3003, "$past"
    unless_null $P3003, vivify_1537
    new $P3003, "Undef"
  vivify_1537:
.annotate 'line', 860
    find_lex $P3005, "$/"
    unless_null $P3005, vivify_1538
    $P3005 = root_new ['parrot';'Hash']
  vivify_1538:
    set $P3006, $P3005["EXPR"]
    unless_null $P3006, vivify_1539
    new $P3006, "Undef"
  vivify_1539:
    if $P3006, if_3004
.annotate 'line', 881
    find_lex $P3069, "$/"
    unless_null $P3069, vivify_1540
    $P3069 = root_new ['parrot';'Hash']
  vivify_1540:
    set $P3070, $P3069["statement_control"]
    unless_null $P3070, vivify_1541
    new $P3070, "Undef"
  vivify_1541:
    if $P3070, if_3068
.annotate 'line', 882
    new $P3074, "Integer"
    assign $P3074, 0
    store_lex "$past", $P3074
    goto if_3068_end
  if_3068:
.annotate 'line', 881
    find_lex $P3071, "$/"
    unless_null $P3071, vivify_1542
    $P3071 = root_new ['parrot';'Hash']
  vivify_1542:
    set $P3072, $P3071["statement_control"]
    unless_null $P3072, vivify_1543
    new $P3072, "Undef"
  vivify_1543:
    $P3073 = $P3072."ast"()
    store_lex "$past", $P3073
  if_3068_end:
    goto if_3004_end
  if_3004:
.annotate 'line', 860
    .const 'Sub' $P3008 = "432_1303340952.947" 
    capture_lex $P3008
    $P3008()
  if_3004_end:
.annotate 'line', 883
    find_lex $P3075, "$/"
    find_lex $P3076, "$past"
    unless_null $P3076, vivify_1577
    new $P3076, "Undef"
  vivify_1577:
    $P3077 = $P3075."!make"($P3076)
.annotate 'line', 858
    .return ($P3077)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3007"  :anon :subid("432_1303340952.947") :outer("431_1303340952.947")
.annotate 'line', 861
    new $P3009, "Undef"
    .lex "$mc", $P3009
.annotate 'line', 862
    new $P3010, "Undef"
    .lex "$ml", $P3010
.annotate 'line', 861
    find_lex $P3011, "$/"
    unless_null $P3011, vivify_1544
    $P3011 = root_new ['parrot';'Hash']
  vivify_1544:
    set $P3012, $P3011["statement_mod_cond"]
    unless_null $P3012, vivify_1545
    $P3012 = root_new ['parrot';'ResizablePMCArray']
  vivify_1545:
    set $P3013, $P3012[0]
    unless_null $P3013, vivify_1546
    new $P3013, "Undef"
  vivify_1546:
    store_lex "$mc", $P3013
.annotate 'line', 862
    find_lex $P3014, "$/"
    unless_null $P3014, vivify_1547
    $P3014 = root_new ['parrot';'Hash']
  vivify_1547:
    set $P3015, $P3014["statement_mod_loop"]
    unless_null $P3015, vivify_1548
    $P3015 = root_new ['parrot';'ResizablePMCArray']
  vivify_1548:
    set $P3016, $P3015[0]
    unless_null $P3016, vivify_1549
    new $P3016, "Undef"
  vivify_1549:
    store_lex "$ml", $P3016
.annotate 'line', 863
    find_lex $P3017, "$/"
    unless_null $P3017, vivify_1550
    $P3017 = root_new ['parrot';'Hash']
  vivify_1550:
    set $P3018, $P3017["EXPR"]
    unless_null $P3018, vivify_1551
    new $P3018, "Undef"
  vivify_1551:
    $P3019 = $P3018."ast"()
    store_lex "$past", $P3019
.annotate 'line', 864
    find_lex $P3021, "$mc"
    unless_null $P3021, vivify_1552
    new $P3021, "Undef"
  vivify_1552:
    unless $P3021, if_3020_end
.annotate 'line', 865
    get_hll_global $P3022, ["PAST"], "Op"
    find_lex $P3023, "$mc"
    unless_null $P3023, vivify_1553
    $P3023 = root_new ['parrot';'Hash']
  vivify_1553:
    set $P3024, $P3023["cond"]
    unless_null $P3024, vivify_1554
    new $P3024, "Undef"
  vivify_1554:
    $P3025 = $P3024."ast"()
    find_lex $P3026, "$past"
    unless_null $P3026, vivify_1555
    new $P3026, "Undef"
  vivify_1555:
    find_lex $P3027, "$mc"
    unless_null $P3027, vivify_1556
    $P3027 = root_new ['parrot';'Hash']
  vivify_1556:
    set $P3028, $P3027["sym"]
    unless_null $P3028, vivify_1557
    new $P3028, "Undef"
  vivify_1557:
    set $S3029, $P3028
    find_lex $P3030, "$/"
    unless_null $P3030, vivify_1558
    new $P3030, "Undef"
  vivify_1558:
    $P3031 = $P3022."new"($P3025, $P3026, $S3029 :named("pasttype"), $P3030 :named("node"))
    store_lex "$past", $P3031
  if_3020_end:
.annotate 'line', 867
    find_lex $P3034, "$ml"
    unless_null $P3034, vivify_1559
    new $P3034, "Undef"
  vivify_1559:
    if $P3034, if_3033
    set $P3032, $P3034
    goto if_3033_end
  if_3033:
.annotate 'line', 868
    find_lex $P3037, "$ml"
    unless_null $P3037, vivify_1560
    $P3037 = root_new ['parrot';'Hash']
  vivify_1560:
    set $P3038, $P3037["sym"]
    unless_null $P3038, vivify_1561
    new $P3038, "Undef"
  vivify_1561:
    set $S3039, $P3038
    iseq $I3040, $S3039, "for"
    if $I3040, if_3036
.annotate 'line', 877
    get_hll_global $P3058, ["PAST"], "Op"
    find_lex $P3059, "$ml"
    unless_null $P3059, vivify_1562
    $P3059 = root_new ['parrot';'Hash']
  vivify_1562:
    set $P3060, $P3059["cond"]
    unless_null $P3060, vivify_1563
    new $P3060, "Undef"
  vivify_1563:
    $P3061 = $P3060."ast"()
    find_lex $P3062, "$past"
    unless_null $P3062, vivify_1564
    new $P3062, "Undef"
  vivify_1564:
    find_lex $P3063, "$ml"
    unless_null $P3063, vivify_1565
    $P3063 = root_new ['parrot';'Hash']
  vivify_1565:
    set $P3064, $P3063["sym"]
    unless_null $P3064, vivify_1566
    new $P3064, "Undef"
  vivify_1566:
    set $S3065, $P3064
    find_lex $P3066, "$/"
    unless_null $P3066, vivify_1567
    new $P3066, "Undef"
  vivify_1567:
    $P3067 = $P3058."new"($P3061, $P3062, $S3065 :named("pasttype"), $P3066 :named("node"))
    store_lex "$past", $P3067
.annotate 'line', 876
    set $P3035, $P3067
.annotate 'line', 868
    goto if_3036_end
  if_3036:
.annotate 'line', 869
    get_hll_global $P3041, ["PAST"], "Block"
.annotate 'line', 870
    get_hll_global $P3042, ["PAST"], "Var"
    $P3043 = $P3042."new"("$_" :named("name"), "parameter" :named("scope"), 1 :named("isdecl"))
    find_lex $P3044, "$past"
    unless_null $P3044, vivify_1568
    new $P3044, "Undef"
  vivify_1568:
    $P3045 = $P3041."new"($P3043, $P3044, "immediate" :named("blocktype"))
.annotate 'line', 869
    store_lex "$past", $P3045
.annotate 'line', 872
    find_lex $P3046, "$past"
    unless_null $P3046, vivify_1569
    new $P3046, "Undef"
  vivify_1569:
    $P3046."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 873
    find_lex $P3047, "$past"
    unless_null $P3047, vivify_1570
    new $P3047, "Undef"
  vivify_1570:
    $P3047."arity"(1)
.annotate 'line', 874
    get_hll_global $P3048, ["PAST"], "Op"
    find_lex $P3049, "$ml"
    unless_null $P3049, vivify_1571
    $P3049 = root_new ['parrot';'Hash']
  vivify_1571:
    set $P3050, $P3049["cond"]
    unless_null $P3050, vivify_1572
    new $P3050, "Undef"
  vivify_1572:
    $P3051 = $P3050."ast"()
    find_lex $P3052, "$past"
    unless_null $P3052, vivify_1573
    new $P3052, "Undef"
  vivify_1573:
    find_lex $P3053, "$ml"
    unless_null $P3053, vivify_1574
    $P3053 = root_new ['parrot';'Hash']
  vivify_1574:
    set $P3054, $P3053["sym"]
    unless_null $P3054, vivify_1575
    new $P3054, "Undef"
  vivify_1575:
    set $S3055, $P3054
    find_lex $P3056, "$/"
    unless_null $P3056, vivify_1576
    new $P3056, "Undef"
  vivify_1576:
    $P3057 = $P3048."new"($P3051, $P3052, $S3055 :named("pasttype"), $P3056 :named("node"))
    store_lex "$past", $P3057
.annotate 'line', 868
    set $P3035, $P3057
  if_3036_end:
.annotate 'line', 867
    set $P3032, $P3035
  if_3033_end:
.annotate 'line', 860
    .return ($P3032)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock"  :subid("433_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_3079
    .param pmc param_3080
.annotate 'line', 886
    .lex "self", param_3079
    .lex "$/", param_3080
.annotate 'line', 887
    find_lex $P3081, "$/"
    get_hll_global $P3082, ["PAST"], "Op"
    find_lex $P3083, "$/"
    unless_null $P3083, vivify_1578
    $P3083 = root_new ['parrot';'Hash']
  vivify_1578:
    set $P3084, $P3083["EXPR"]
    unless_null $P3084, vivify_1579
    new $P3084, "Undef"
  vivify_1579:
    $P3085 = $P3084."ast"()
    find_lex $P3086, "$/"
    unless_null $P3086, vivify_1580
    $P3086 = root_new ['parrot';'Hash']
  vivify_1580:
    set $P3087, $P3086["pblock"]
    unless_null $P3087, vivify_1581
    new $P3087, "Undef"
  vivify_1581:
    $P3088 = $P3087."ast"()
    find_lex $P3089, "$/"
    unless_null $P3089, vivify_1582
    new $P3089, "Undef"
  vivify_1582:
    $P3090 = $P3082."new"($P3085, $P3088, "if" :named("pasttype"), $P3089 :named("node"))
    $P3091 = $P3081."!make"($P3090)
.annotate 'line', 886
    .return ($P3091)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "pblock"  :subid("434_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_3093
    .param pmc param_3094
.annotate 'line', 890
    .lex "self", param_3093
    .lex "$/", param_3094
.annotate 'line', 891
    find_lex $P3095, "$/"
    find_lex $P3096, "$/"
    unless_null $P3096, vivify_1583
    $P3096 = root_new ['parrot';'Hash']
  vivify_1583:
    set $P3097, $P3096["blockoid"]
    unless_null $P3097, vivify_1584
    new $P3097, "Undef"
  vivify_1584:
    $P3098 = $P3097."ast"()
    $P3099 = $P3095."!make"($P3098)
.annotate 'line', 890
    .return ($P3099)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block"  :subid("435_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_3101
    .param pmc param_3102
.annotate 'line', 894
    .lex "self", param_3101
    .lex "$/", param_3102
.annotate 'line', 895
    find_lex $P3103, "$/"
    find_lex $P3104, "$/"
    unless_null $P3104, vivify_1585
    $P3104 = root_new ['parrot';'Hash']
  vivify_1585:
    set $P3105, $P3104["blockoid"]
    unless_null $P3105, vivify_1586
    new $P3105, "Undef"
  vivify_1586:
    $P3106 = $P3105."ast"()
    $P3107 = $P3103."!make"($P3106)
.annotate 'line', 894
    .return ($P3107)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blockoid"  :subid("436_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_3109
    .param pmc param_3110
.annotate 'line', 898
    .const 'Sub' $P3121 = "437_1303340952.947" 
    capture_lex $P3121
    .lex "self", param_3109
    .lex "$/", param_3110
.annotate 'line', 899
    new $P3111, "Undef"
    .lex "$BLOCK", $P3111
    find_lex $P3112, "$?PACKAGE"
    get_who $P3113, $P3112
    set $P3114, $P3113["@BLOCK"]
    unless_null $P3114, vivify_1587
    $P3114 = root_new ['parrot';'ResizablePMCArray']
  vivify_1587:
    $P3115 = $P3114."shift"()
    store_lex "$BLOCK", $P3115
.annotate 'line', 900
    find_lex $P3118, "$/"
    unless_null $P3118, vivify_1588
    $P3118 = root_new ['parrot';'Hash']
  vivify_1588:
    set $P3119, $P3118["statementlist"]
    unless_null $P3119, vivify_1589
    new $P3119, "Undef"
  vivify_1589:
    if $P3119, if_3117
.annotate 'line', 908
    find_dynamic_lex $P3136, "$*HAS_YOU_ARE_HERE"
    unless_null $P3136, vivify_1590
    get_hll_global $P3136, "$HAS_YOU_ARE_HERE"
    unless_null $P3136, vivify_1591
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_1591:
  vivify_1590:
    unless $P3136, if_3135_end
.annotate 'line', 909
    find_lex $P3137, "$/"
    unless_null $P3137, vivify_1592
    new $P3137, "Undef"
  vivify_1592:
    $P3138 = $P3137."CURSOR"()
    $P3138."panic"("{YOU_ARE_HERE} may only appear once in a setting")
  if_3135_end:
.annotate 'line', 911
    new $P3139, "Integer"
    assign $P3139, 1
    store_dynamic_lex "$*HAS_YOU_ARE_HERE", $P3139
.annotate 'line', 912
    find_lex $P3140, "$/"
    find_lex $P3141, "$/"
    unless_null $P3141, vivify_1593
    $P3141 = root_new ['parrot';'Hash']
  vivify_1593:
    set $P3142, $P3141["you_are_here"]
    unless_null $P3142, vivify_1594
    new $P3142, "Undef"
  vivify_1594:
    $P3143 = $P3142."ast"()
    $P3144 = $P3140."!make"($P3143)
.annotate 'line', 907
    set $P3116, $P3144
.annotate 'line', 900
    goto if_3117_end
  if_3117:
    .const 'Sub' $P3121 = "437_1303340952.947" 
    capture_lex $P3121
    $P3134 = $P3121()
    set $P3116, $P3134
  if_3117_end:
.annotate 'line', 898
    .return ($P3116)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3120"  :anon :subid("437_1303340952.947") :outer("436_1303340952.947")
.annotate 'line', 901
    new $P3122, "Undef"
    .lex "$past", $P3122
    find_lex $P3123, "$/"
    unless_null $P3123, vivify_1595
    $P3123 = root_new ['parrot';'Hash']
  vivify_1595:
    set $P3124, $P3123["statementlist"]
    unless_null $P3124, vivify_1596
    new $P3124, "Undef"
  vivify_1596:
    $P3125 = $P3124."ast"()
    store_lex "$past", $P3125
.annotate 'line', 902
    find_lex $P3126, "$BLOCK"
    unless_null $P3126, vivify_1597
    new $P3126, "Undef"
  vivify_1597:
    find_lex $P3127, "$past"
    unless_null $P3127, vivify_1598
    new $P3127, "Undef"
  vivify_1598:
    $P3126."push"($P3127)
.annotate 'line', 903
    find_lex $P3128, "$BLOCK"
    unless_null $P3128, vivify_1599
    new $P3128, "Undef"
  vivify_1599:
    find_lex $P3129, "$/"
    unless_null $P3129, vivify_1600
    new $P3129, "Undef"
  vivify_1600:
    $P3128."node"($P3129)
.annotate 'line', 904
    find_lex $P3130, "$BLOCK"
    unless_null $P3130, vivify_1601
    new $P3130, "Undef"
  vivify_1601:
    $P3130."closure"(1)
.annotate 'line', 905
    find_dynamic_lex $P3131, "$/"
    find_lex $P3132, "$BLOCK"
    unless_null $P3132, vivify_1602
    new $P3132, "Undef"
  vivify_1602:
    $P3133 = $P3131."!make"($P3132)
.annotate 'line', 900
    .return ($P3133)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "newpad"  :subid("438_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_3146
    .param pmc param_3147
.annotate 'line', 916
    .lex "self", param_3146
    .lex "$/", param_3147
.annotate 'line', 917
    find_lex $P3148, "$?PACKAGE"
    get_who $P3149, $P3148
    set $P3150, $P3149["@BLOCK"]
    unless_null $P3150, vivify_1603
    $P3150 = root_new ['parrot';'ResizablePMCArray']
  vivify_1603:
    get_hll_global $P3151, ["PAST"], "Block"
    get_hll_global $P3152, ["PAST"], "Stmts"
    $P3153 = $P3152."new"()
    $P3154 = $P3151."new"($P3153)
    $P3155 = $P3150."unshift"($P3154)
.annotate 'line', 916
    .return ($P3155)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "outerctx"  :subid("439_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_3157
    .param pmc param_3158
.annotate 'line', 920
    .lex "self", param_3157
    .lex "$/", param_3158
.annotate 'line', 921
    find_dynamic_lex $P3160, "%*COMPILING"
    unless_null $P3160, vivify_1604
    get_hll_global $P3160, "%COMPILING"
    unless_null $P3160, vivify_1605
    die "Contextual %*COMPILING not found"
  vivify_1605:
  vivify_1604:
    set $P3161, $P3160["%?OPTIONS"]
    unless_null $P3161, vivify_1606
    $P3161 = root_new ['parrot';'Hash']
  vivify_1606:
    set $P3162, $P3161["outer_ctx"]
    unless_null $P3162, vivify_1607
    new $P3162, "Undef"
  vivify_1607:
    defined $I3163, $P3162
    if $I3163, unless_3159_end
.annotate 'line', 924
    find_dynamic_lex $P3164, "$*SC"
    unless_null $P3164, vivify_1608
    get_hll_global $P3164, "$SC"
    unless_null $P3164, vivify_1609
    die "Contextual $*SC not found"
  vivify_1609:
  vivify_1608:
    find_dynamic_lex $P3166, "%*COMPILING"
    unless_null $P3166, vivify_1610
    get_hll_global $P3166, "%COMPILING"
    unless_null $P3166, vivify_1611
    die "Contextual %*COMPILING not found"
  vivify_1611:
  vivify_1610:
    set $P3167, $P3166["%?OPTIONS"]
    unless_null $P3167, vivify_1612
    $P3167 = root_new ['parrot';'Hash']
  vivify_1612:
    set $P3168, $P3167["setting"]
    unless_null $P3168, vivify_1613
    new $P3168, "Undef"
  vivify_1613:
    set $P3165, $P3168
    defined $I3170, $P3165
    if $I3170, default_3169
    new $P3171, "String"
    assign $P3171, "NQPCORE"
    set $P3165, $P3171
  default_3169:
    $P3164."load_setting"($P3165)
  unless_3159_end:
.annotate 'line', 926
    find_lex $P3172, "self"
    find_lex $P3173, "$?PACKAGE"
    get_who $P3174, $P3173
    set $P3175, $P3174["@BLOCK"]
    unless_null $P3175, vivify_1614
    $P3175 = root_new ['parrot';'ResizablePMCArray']
  vivify_1614:
    set $P3176, $P3175[0]
    unless_null $P3176, vivify_1615
    new $P3176, "Undef"
  vivify_1615:
    $P3177 = $P3172."SET_BLOCK_OUTER_CTX"($P3176)
.annotate 'line', 920
    .return ($P3177)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "GLOBALish"  :subid("440_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_3179
    .param pmc param_3180
.annotate 'line', 929
    .lex "self", param_3179
    .lex "$/", param_3180
.annotate 'line', 933
    find_dynamic_lex $P3181, "$*SC"
    unless_null $P3181, vivify_1616
    get_hll_global $P3181, "$SC"
    unless_null $P3181, vivify_1617
    die "Contextual $*SC not found"
  vivify_1617:
  vivify_1616:
    get_hll_global $P3182, "KnowHOW"
    $P3183 = $P3181."pkg_create_mo"($P3182, "GLOBALish" :named("name"))
    store_dynamic_lex "$*PACKAGE", $P3183
.annotate 'line', 934
    find_dynamic_lex $P3184, "$*PACKAGE"
    unless_null $P3184, vivify_1618
    get_hll_global $P3184, "$PACKAGE"
    unless_null $P3184, vivify_1619
    die "Contextual $*PACKAGE not found"
  vivify_1619:
  vivify_1618:
    get_how $P3185, $P3184
    find_dynamic_lex $P3186, "$*PACKAGE"
    unless_null $P3186, vivify_1620
    get_hll_global $P3186, "$PACKAGE"
    unless_null $P3186, vivify_1621
    die "Contextual $*PACKAGE not found"
  vivify_1621:
  vivify_1620:
    $P3185."compose"($P3186)
.annotate 'line', 935
    find_dynamic_lex $P3187, "$*SC"
    unless_null $P3187, vivify_1622
    get_hll_global $P3187, "$SC"
    unless_null $P3187, vivify_1623
    die "Contextual $*SC not found"
  vivify_1623:
  vivify_1622:
    find_lex $P3188, "$?PACKAGE"
    get_who $P3189, $P3188
    set $P3190, $P3189["@BLOCK"]
    unless_null $P3190, vivify_1624
    $P3190 = root_new ['parrot';'ResizablePMCArray']
  vivify_1624:
    set $P3191, $P3190[0]
    unless_null $P3191, vivify_1625
    new $P3191, "Undef"
  vivify_1625:
    find_dynamic_lex $P3192, "$*PACKAGE"
    unless_null $P3192, vivify_1626
    get_hll_global $P3192, "$PACKAGE"
    unless_null $P3192, vivify_1627
    die "Contextual $*PACKAGE not found"
  vivify_1627:
  vivify_1626:
    $P3193 = $P3187."install_lexical_symbol"($P3191, "GLOBALish", $P3192)
.annotate 'line', 929
    .return ($P3193)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "you_are_here"  :subid("441_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_3195
    .param pmc param_3196
.annotate 'line', 938
    .lex "self", param_3195
    .lex "$/", param_3196
.annotate 'line', 939
    find_lex $P3197, "$/"
    find_lex $P3198, "self"
    $P3199 = $P3198."CTXSAVE"()
    $P3200 = $P3197."!make"($P3199)
.annotate 'line', 938
    .return ($P3200)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<use>"  :subid("442_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_3202
    .param pmc param_3203
.annotate 'line', 944
    .lex "self", param_3202
    .lex "$/", param_3203
.annotate 'line', 945
    find_dynamic_lex $P3204, "$*SC"
    unless_null $P3204, vivify_1628
    get_hll_global $P3204, "$SC"
    unless_null $P3204, vivify_1629
    die "Contextual $*SC not found"
  vivify_1629:
  vivify_1628:
    find_lex $P3205, "$/"
    unless_null $P3205, vivify_1630
    $P3205 = root_new ['parrot';'Hash']
  vivify_1630:
    set $P3206, $P3205["name"]
    unless_null $P3206, vivify_1631
    new $P3206, "Undef"
  vivify_1631:
    set $S3207, $P3206
    $P3204."load_module"($S3207)
.annotate 'line', 946
    find_lex $P3208, "$/"
    get_hll_global $P3209, ["PAST"], "Stmts"
    $P3210 = $P3209."new"()
    $P3211 = $P3208."!make"($P3210)
.annotate 'line', 944
    .return ($P3211)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statement_control:sym<if>"  :subid("443_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_3213
    .param pmc param_3214
.annotate 'line', 949
    .const 'Sub' $P3242 = "444_1303340952.947" 
    capture_lex $P3242
    .lex "self", param_3213
    .lex "$/", param_3214
.annotate 'line', 950
    new $P3215, "Undef"
    .lex "$count", $P3215
.annotate 'line', 951
    new $P3216, "Undef"
    .lex "$past", $P3216
.annotate 'line', 950
    find_lex $P3217, "$/"
    unless_null $P3217, vivify_1632
    $P3217 = root_new ['parrot';'Hash']
  vivify_1632:
    set $P3218, $P3217["xblock"]
    unless_null $P3218, vivify_1633
    new $P3218, "Undef"
  vivify_1633:
    set $N3219, $P3218
    new $P3220, 'Float'
    set $P3220, $N3219
    sub $P3221, $P3220, 1
    store_lex "$count", $P3221
.annotate 'line', 951
    find_lex $P3222, "$count"
    unless_null $P3222, vivify_1634
    new $P3222, "Undef"
  vivify_1634:
    set $I3223, $P3222
    find_lex $P3224, "$/"
    unless_null $P3224, vivify_1635
    $P3224 = root_new ['parrot';'Hash']
  vivify_1635:
    set $P3225, $P3224["xblock"]
    unless_null $P3225, vivify_1636
    $P3225 = root_new ['parrot';'ResizablePMCArray']
  vivify_1636:
    set $P3226, $P3225[$I3223]
    unless_null $P3226, vivify_1637
    new $P3226, "Undef"
  vivify_1637:
    $P3227 = $P3226."ast"()
    $P3228 = "xblock_immediate"($P3227)
    store_lex "$past", $P3228
.annotate 'line', 952
    find_lex $P3230, "$/"
    unless_null $P3230, vivify_1638
    $P3230 = root_new ['parrot';'Hash']
  vivify_1638:
    set $P3231, $P3230["else"]
    unless_null $P3231, vivify_1639
    new $P3231, "Undef"
  vivify_1639:
    unless $P3231, if_3229_end
.annotate 'line', 953
    find_lex $P3232, "$past"
    unless_null $P3232, vivify_1640
    new $P3232, "Undef"
  vivify_1640:
    find_lex $P3233, "$/"
    unless_null $P3233, vivify_1641
    $P3233 = root_new ['parrot';'Hash']
  vivify_1641:
    set $P3234, $P3233["else"]
    unless_null $P3234, vivify_1642
    $P3234 = root_new ['parrot';'ResizablePMCArray']
  vivify_1642:
    set $P3235, $P3234[0]
    unless_null $P3235, vivify_1643
    new $P3235, "Undef"
  vivify_1643:
    $P3236 = $P3235."ast"()
    $P3237 = "block_immediate"($P3236)
    $P3232."push"($P3237)
  if_3229_end:
.annotate 'line', 956
    new $P3258, 'ExceptionHandler'
    set_label $P3258, loop3257_handler
    $P3258."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3258
  loop3257_test:
    find_lex $P3238, "$count"
    unless_null $P3238, vivify_1644
    new $P3238, "Undef"
  vivify_1644:
    set $N3239, $P3238
    isgt $I3240, $N3239, 0.0
    unless $I3240, loop3257_done
  loop3257_redo:
    .const 'Sub' $P3242 = "444_1303340952.947" 
    capture_lex $P3242
    $P3242()
  loop3257_next:
    goto loop3257_test
  loop3257_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3259, exception, 'type'
    eq $P3259, .CONTROL_LOOP_NEXT, loop3257_next
    eq $P3259, .CONTROL_LOOP_REDO, loop3257_redo
  loop3257_done:
    pop_eh 
.annotate 'line', 962
    find_lex $P3260, "$/"
    find_lex $P3261, "$past"
    unless_null $P3261, vivify_1653
    new $P3261, "Undef"
  vivify_1653:
    $P3262 = $P3260."!make"($P3261)
.annotate 'line', 949
    .return ($P3262)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3241"  :anon :subid("444_1303340952.947") :outer("443_1303340952.947")
.annotate 'line', 958
    new $P3243, "Undef"
    .lex "$else", $P3243
.annotate 'line', 956
    find_lex $P3244, "$count"
    unless_null $P3244, vivify_1645
    new $P3244, "Undef"
  vivify_1645:
    clone $P3245, $P3244
    dec $P3244
.annotate 'line', 958
    find_lex $P3246, "$past"
    unless_null $P3246, vivify_1646
    new $P3246, "Undef"
  vivify_1646:
    store_lex "$else", $P3246
.annotate 'line', 959
    find_lex $P3247, "$count"
    unless_null $P3247, vivify_1647
    new $P3247, "Undef"
  vivify_1647:
    set $I3248, $P3247
    find_lex $P3249, "$/"
    unless_null $P3249, vivify_1648
    $P3249 = root_new ['parrot';'Hash']
  vivify_1648:
    set $P3250, $P3249["xblock"]
    unless_null $P3250, vivify_1649
    $P3250 = root_new ['parrot';'ResizablePMCArray']
  vivify_1649:
    set $P3251, $P3250[$I3248]
    unless_null $P3251, vivify_1650
    new $P3251, "Undef"
  vivify_1650:
    $P3252 = $P3251."ast"()
    $P3253 = "xblock_immediate"($P3252)
    store_lex "$past", $P3253
.annotate 'line', 960
    find_lex $P3254, "$past"
    unless_null $P3254, vivify_1651
    new $P3254, "Undef"
  vivify_1651:
    find_lex $P3255, "$else"
    unless_null $P3255, vivify_1652
    new $P3255, "Undef"
  vivify_1652:
    $P3256 = $P3254."push"($P3255)
.annotate 'line', 956
    .return ($P3256)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<unless>"  :subid("445_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_3264
    .param pmc param_3265
.annotate 'line', 965
    .lex "self", param_3264
    .lex "$/", param_3265
.annotate 'line', 966
    new $P3266, "Undef"
    .lex "$past", $P3266
    find_lex $P3267, "$/"
    unless_null $P3267, vivify_1654
    $P3267 = root_new ['parrot';'Hash']
  vivify_1654:
    set $P3268, $P3267["xblock"]
    unless_null $P3268, vivify_1655
    new $P3268, "Undef"
  vivify_1655:
    $P3269 = $P3268."ast"()
    $P3270 = "xblock_immediate"($P3269)
    store_lex "$past", $P3270
.annotate 'line', 967
    find_lex $P3271, "$past"
    unless_null $P3271, vivify_1656
    new $P3271, "Undef"
  vivify_1656:
    $P3271."pasttype"("unless")
.annotate 'line', 968
    find_lex $P3272, "$/"
    find_lex $P3273, "$past"
    unless_null $P3273, vivify_1657
    new $P3273, "Undef"
  vivify_1657:
    $P3274 = $P3272."!make"($P3273)
.annotate 'line', 965
    .return ($P3274)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<while>"  :subid("446_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_3276
    .param pmc param_3277
.annotate 'line', 971
    .lex "self", param_3276
    .lex "$/", param_3277
.annotate 'line', 972
    new $P3278, "Undef"
    .lex "$past", $P3278
    find_lex $P3279, "$/"
    unless_null $P3279, vivify_1658
    $P3279 = root_new ['parrot';'Hash']
  vivify_1658:
    set $P3280, $P3279["xblock"]
    unless_null $P3280, vivify_1659
    new $P3280, "Undef"
  vivify_1659:
    $P3281 = $P3280."ast"()
    $P3282 = "xblock_immediate"($P3281)
    store_lex "$past", $P3282
.annotate 'line', 973
    find_lex $P3283, "$past"
    unless_null $P3283, vivify_1660
    new $P3283, "Undef"
  vivify_1660:
    find_lex $P3284, "$/"
    unless_null $P3284, vivify_1661
    $P3284 = root_new ['parrot';'Hash']
  vivify_1661:
    set $P3285, $P3284["sym"]
    unless_null $P3285, vivify_1662
    new $P3285, "Undef"
  vivify_1662:
    set $S3286, $P3285
    $P3283."pasttype"($S3286)
.annotate 'line', 974
    find_lex $P3287, "$/"
    find_lex $P3288, "$past"
    unless_null $P3288, vivify_1663
    new $P3288, "Undef"
  vivify_1663:
    $P3289 = $P3287."!make"($P3288)
.annotate 'line', 971
    .return ($P3289)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<repeat>"  :subid("447_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_3291
    .param pmc param_3292
.annotate 'line', 977
    .lex "self", param_3291
    .lex "$/", param_3292
.annotate 'line', 978
    new $P3293, "Undef"
    .lex "$pasttype", $P3293
.annotate 'line', 979
    new $P3294, "Undef"
    .lex "$past", $P3294
.annotate 'line', 978
    new $P3295, "String"
    assign $P3295, "repeat_"
    find_lex $P3296, "$/"
    unless_null $P3296, vivify_1664
    $P3296 = root_new ['parrot';'Hash']
  vivify_1664:
    set $P3297, $P3296["wu"]
    unless_null $P3297, vivify_1665
    new $P3297, "Undef"
  vivify_1665:
    set $S3298, $P3297
    concat $P3299, $P3295, $S3298
    store_lex "$pasttype", $P3299
    find_lex $P3300, "$past"
    unless_null $P3300, vivify_1666
    new $P3300, "Undef"
  vivify_1666:
.annotate 'line', 980
    find_lex $P3302, "$/"
    unless_null $P3302, vivify_1667
    $P3302 = root_new ['parrot';'Hash']
  vivify_1667:
    set $P3303, $P3302["xblock"]
    unless_null $P3303, vivify_1668
    new $P3303, "Undef"
  vivify_1668:
    if $P3303, if_3301
.annotate 'line', 985
    get_hll_global $P3310, ["PAST"], "Op"
    find_lex $P3311, "$/"
    unless_null $P3311, vivify_1669
    $P3311 = root_new ['parrot';'Hash']
  vivify_1669:
    set $P3312, $P3311["EXPR"]
    unless_null $P3312, vivify_1670
    new $P3312, "Undef"
  vivify_1670:
    $P3313 = $P3312."ast"()
    find_lex $P3314, "$/"
    unless_null $P3314, vivify_1671
    $P3314 = root_new ['parrot';'Hash']
  vivify_1671:
    set $P3315, $P3314["pblock"]
    unless_null $P3315, vivify_1672
    new $P3315, "Undef"
  vivify_1672:
    $P3316 = $P3315."ast"()
    $P3317 = "block_immediate"($P3316)
    find_lex $P3318, "$pasttype"
    unless_null $P3318, vivify_1673
    new $P3318, "Undef"
  vivify_1673:
    find_lex $P3319, "$/"
    unless_null $P3319, vivify_1674
    new $P3319, "Undef"
  vivify_1674:
    $P3320 = $P3310."new"($P3313, $P3317, $P3318 :named("pasttype"), $P3319 :named("node"))
    store_lex "$past", $P3320
.annotate 'line', 984
    goto if_3301_end
  if_3301:
.annotate 'line', 981
    find_lex $P3304, "$/"
    unless_null $P3304, vivify_1675
    $P3304 = root_new ['parrot';'Hash']
  vivify_1675:
    set $P3305, $P3304["xblock"]
    unless_null $P3305, vivify_1676
    new $P3305, "Undef"
  vivify_1676:
    $P3306 = $P3305."ast"()
    $P3307 = "xblock_immediate"($P3306)
    store_lex "$past", $P3307
.annotate 'line', 982
    find_lex $P3308, "$past"
    unless_null $P3308, vivify_1677
    new $P3308, "Undef"
  vivify_1677:
    find_lex $P3309, "$pasttype"
    unless_null $P3309, vivify_1678
    new $P3309, "Undef"
  vivify_1678:
    $P3308."pasttype"($P3309)
  if_3301_end:
.annotate 'line', 988
    find_lex $P3321, "$/"
    find_lex $P3322, "$past"
    unless_null $P3322, vivify_1679
    new $P3322, "Undef"
  vivify_1679:
    $P3323 = $P3321."!make"($P3322)
.annotate 'line', 977
    .return ($P3323)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<for>"  :subid("448_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_3325
    .param pmc param_3326
.annotate 'line', 991
    .lex "self", param_3325
    .lex "$/", param_3326
.annotate 'line', 992
    new $P3327, "Undef"
    .lex "$past", $P3327
.annotate 'line', 994
    new $P3328, "Undef"
    .lex "$block", $P3328
.annotate 'line', 992
    find_lex $P3329, "$/"
    unless_null $P3329, vivify_1680
    $P3329 = root_new ['parrot';'Hash']
  vivify_1680:
    set $P3330, $P3329["xblock"]
    unless_null $P3330, vivify_1681
    new $P3330, "Undef"
  vivify_1681:
    $P3331 = $P3330."ast"()
    store_lex "$past", $P3331
.annotate 'line', 993
    find_lex $P3332, "$past"
    unless_null $P3332, vivify_1682
    new $P3332, "Undef"
  vivify_1682:
    $P3332."pasttype"("for")
.annotate 'line', 994
    find_lex $P3333, "$past"
    unless_null $P3333, vivify_1683
    $P3333 = root_new ['parrot';'ResizablePMCArray']
  vivify_1683:
    set $P3334, $P3333[1]
    unless_null $P3334, vivify_1684
    new $P3334, "Undef"
  vivify_1684:
    store_lex "$block", $P3334
.annotate 'line', 995
    find_lex $P3336, "$block"
    unless_null $P3336, vivify_1685
    new $P3336, "Undef"
  vivify_1685:
    $P3337 = $P3336."arity"()
    if $P3337, unless_3335_end
.annotate 'line', 996
    find_lex $P3338, "$block"
    unless_null $P3338, vivify_1686
    $P3338 = root_new ['parrot';'ResizablePMCArray']
  vivify_1686:
    set $P3339, $P3338[0]
    unless_null $P3339, vivify_1687
    new $P3339, "Undef"
  vivify_1687:
    get_hll_global $P3340, ["PAST"], "Var"
    $P3341 = $P3340."new"("$_" :named("name"), "parameter" :named("scope"))
    $P3339."push"($P3341)
.annotate 'line', 997
    find_lex $P3342, "$block"
    unless_null $P3342, vivify_1688
    new $P3342, "Undef"
  vivify_1688:
    $P3342."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 998
    find_lex $P3343, "$block"
    unless_null $P3343, vivify_1689
    new $P3343, "Undef"
  vivify_1689:
    $P3343."arity"(1)
  unless_3335_end:
.annotate 'line', 1000
    find_lex $P3344, "$block"
    unless_null $P3344, vivify_1690
    new $P3344, "Undef"
  vivify_1690:
    $P3344."blocktype"("immediate")
.annotate 'line', 1001
    find_lex $P3345, "$/"
    find_lex $P3346, "$past"
    unless_null $P3346, vivify_1691
    new $P3346, "Undef"
  vivify_1691:
    $P3347 = $P3345."!make"($P3346)
.annotate 'line', 991
    .return ($P3347)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CATCH>"  :subid("449_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_3349
    .param pmc param_3350
.annotate 'line', 1004
    .lex "self", param_3349
    .lex "$/", param_3350
.annotate 'line', 1005
    new $P3351, "Undef"
    .lex "$block", $P3351
    find_lex $P3352, "$/"
    unless_null $P3352, vivify_1692
    $P3352 = root_new ['parrot';'Hash']
  vivify_1692:
    set $P3353, $P3352["block"]
    unless_null $P3353, vivify_1693
    new $P3353, "Undef"
  vivify_1693:
    $P3354 = $P3353."ast"()
    store_lex "$block", $P3354
.annotate 'line', 1006
    find_lex $P3355, "$/"
    unless_null $P3355, vivify_1694
    new $P3355, "Undef"
  vivify_1694:
    find_lex $P3356, "$block"
    unless_null $P3356, vivify_1695
    new $P3356, "Undef"
  vivify_1695:
    "push_block_handler"($P3355, $P3356)
.annotate 'line', 1007
    find_lex $P3357, "$?PACKAGE"
    get_who $P3358, $P3357
    set $P3359, $P3358["@BLOCK"]
    unless_null $P3359, vivify_1696
    $P3359 = root_new ['parrot';'ResizablePMCArray']
  vivify_1696:
    set $P3360, $P3359[0]
    unless_null $P3360, vivify_1697
    new $P3360, "Undef"
  vivify_1697:
    $P3361 = $P3360."handlers"()
    set $P3362, $P3361[0]
    unless_null $P3362, vivify_1698
    new $P3362, "Undef"
  vivify_1698:
    $P3362."handle_types_except"("CONTROL")
.annotate 'line', 1008
    find_lex $P3363, "$/"
    get_hll_global $P3364, ["PAST"], "Stmts"
    find_lex $P3365, "$/"
    unless_null $P3365, vivify_1699
    new $P3365, "Undef"
  vivify_1699:
    $P3366 = $P3364."new"($P3365 :named("node"))
    $P3367 = $P3363."!make"($P3366)
.annotate 'line', 1004
    .return ($P3367)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CONTROL>"  :subid("450_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_3369
    .param pmc param_3370
.annotate 'line', 1011
    .lex "self", param_3369
    .lex "$/", param_3370
.annotate 'line', 1012
    new $P3371, "Undef"
    .lex "$block", $P3371
    find_lex $P3372, "$/"
    unless_null $P3372, vivify_1700
    $P3372 = root_new ['parrot';'Hash']
  vivify_1700:
    set $P3373, $P3372["block"]
    unless_null $P3373, vivify_1701
    new $P3373, "Undef"
  vivify_1701:
    $P3374 = $P3373."ast"()
    store_lex "$block", $P3374
.annotate 'line', 1013
    find_lex $P3375, "$/"
    unless_null $P3375, vivify_1702
    new $P3375, "Undef"
  vivify_1702:
    find_lex $P3376, "$block"
    unless_null $P3376, vivify_1703
    new $P3376, "Undef"
  vivify_1703:
    "push_block_handler"($P3375, $P3376)
.annotate 'line', 1014
    find_lex $P3377, "$?PACKAGE"
    get_who $P3378, $P3377
    set $P3379, $P3378["@BLOCK"]
    unless_null $P3379, vivify_1704
    $P3379 = root_new ['parrot';'ResizablePMCArray']
  vivify_1704:
    set $P3380, $P3379[0]
    unless_null $P3380, vivify_1705
    new $P3380, "Undef"
  vivify_1705:
    $P3381 = $P3380."handlers"()
    set $P3382, $P3381[0]
    unless_null $P3382, vivify_1706
    new $P3382, "Undef"
  vivify_1706:
    $P3382."handle_types"("CONTROL")
.annotate 'line', 1015
    find_lex $P3383, "$/"
    get_hll_global $P3384, ["PAST"], "Stmts"
    find_lex $P3385, "$/"
    unless_null $P3385, vivify_1707
    new $P3385, "Undef"
  vivify_1707:
    $P3386 = $P3384."new"($P3385 :named("node"))
    $P3387 = $P3383."!make"($P3386)
.annotate 'line', 1011
    .return ($P3387)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<INIT>"  :subid("451_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_3390
    .param pmc param_3391
.annotate 'line', 1055
    .lex "self", param_3390
    .lex "$/", param_3391
.annotate 'line', 1056
    new $P3392, "Undef"
    .lex "$init_block", $P3392
    get_hll_global $P3393, ["PAST"], "Block"
    $P3394 = $P3393."new"("immediate" :named("blocktype"))
    store_lex "$init_block", $P3394
.annotate 'line', 1057
    find_lex $P3395, "$init_block"
    unless_null $P3395, vivify_1708
    new $P3395, "Undef"
  vivify_1708:
    $P3396 = $P3395."loadinit"()
    find_lex $P3397, "$/"
    unless_null $P3397, vivify_1709
    $P3397 = root_new ['parrot';'Hash']
  vivify_1709:
    set $P3398, $P3397["blorst"]
    unless_null $P3398, vivify_1710
    new $P3398, "Undef"
  vivify_1710:
    $P3399 = $P3398."ast"()
    $P3396."push"($P3399)
.annotate 'line', 1058
    find_lex $P3400, "$/"
    find_lex $P3401, "$init_block"
    unless_null $P3401, vivify_1711
    new $P3401, "Undef"
  vivify_1711:
    $P3402 = $P3400."!make"($P3401)
.annotate 'line', 1055
    .return ($P3402)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<try>"  :subid("452_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_3404
    .param pmc param_3405
.annotate 'line', 1061
    .lex "self", param_3404
    .lex "$/", param_3405
.annotate 'line', 1062
    new $P3406, "Undef"
    .lex "$past", $P3406
    find_lex $P3407, "$/"
    unless_null $P3407, vivify_1712
    $P3407 = root_new ['parrot';'Hash']
  vivify_1712:
    set $P3408, $P3407["blorst"]
    unless_null $P3408, vivify_1713
    new $P3408, "Undef"
  vivify_1713:
    $P3409 = $P3408."ast"()
    store_lex "$past", $P3409
.annotate 'line', 1063
    get_hll_global $P3411, ["PAST"], "Block"
    find_lex $P3412, "$past"
    unless_null $P3412, vivify_1714
    new $P3412, "Undef"
  vivify_1714:
    $P3413 = $P3411."ACCEPTS"($P3412)
    if $P3413, unless_3410_end
.annotate 'line', 1064
    get_hll_global $P3414, ["PAST"], "Block"
    find_lex $P3415, "$past"
    unless_null $P3415, vivify_1715
    new $P3415, "Undef"
  vivify_1715:
    find_lex $P3416, "$/"
    unless_null $P3416, vivify_1716
    new $P3416, "Undef"
  vivify_1716:
    $P3417 = $P3414."new"($P3415, "immediate" :named("blocktype"), $P3416 :named("node"))
    store_lex "$past", $P3417
  unless_3410_end:
.annotate 'line', 1066
    find_lex $P3419, "$past"
    unless_null $P3419, vivify_1717
    new $P3419, "Undef"
  vivify_1717:
    $P3420 = $P3419."handlers"()
    if $P3420, unless_3418_end
.annotate 'line', 1067
    find_lex $P3421, "$past"
    unless_null $P3421, vivify_1718
    new $P3421, "Undef"
  vivify_1718:
    get_hll_global $P3422, ["PAST"], "Control"
.annotate 'line', 1069
    get_hll_global $P3423, ["PAST"], "Stmts"
.annotate 'line', 1070
    get_hll_global $P3424, ["PAST"], "Op"
.annotate 'line', 1071
    get_hll_global $P3425, ["PAST"], "Var"
.annotate 'line', 1072
    get_hll_global $P3426, ["PAST"], "Var"
    $P3427 = $P3426."new"("register" :named("scope"), "exception" :named("name"))
    $P3428 = $P3425."new"($P3427, "handled", "keyed" :named("scope"))
.annotate 'line', 1071
    $P3429 = $P3424."new"($P3428, 1, "bind" :named("pasttype"))
.annotate 'line', 1070
    $P3430 = $P3423."new"($P3429)
.annotate 'line', 1069
    $P3431 = $P3422."new"($P3430, "CONTROL" :named("handle_types_except"))
.annotate 'line', 1067
    new $P3432, "ResizablePMCArray"
    push $P3432, $P3431
    $P3421."handlers"($P3432)
  unless_3418_end:
.annotate 'line', 1081
    find_lex $P3433, "$/"
    find_lex $P3434, "$past"
    unless_null $P3434, vivify_1719
    new $P3434, "Undef"
  vivify_1719:
    $P3435 = $P3433."!make"($P3434)
.annotate 'line', 1061
    .return ($P3435)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blorst"  :subid("453_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_3437
    .param pmc param_3438
.annotate 'line', 1084
    .lex "self", param_3437
    .lex "$/", param_3438
.annotate 'line', 1085
    find_lex $P3439, "$/"
.annotate 'line', 1086
    find_lex $P3442, "$/"
    unless_null $P3442, vivify_1720
    $P3442 = root_new ['parrot';'Hash']
  vivify_1720:
    set $P3443, $P3442["block"]
    unless_null $P3443, vivify_1721
    new $P3443, "Undef"
  vivify_1721:
    if $P3443, if_3441
.annotate 'line', 1087
    find_lex $P3448, "$/"
    unless_null $P3448, vivify_1722
    $P3448 = root_new ['parrot';'Hash']
  vivify_1722:
    set $P3449, $P3448["statement"]
    unless_null $P3449, vivify_1723
    new $P3449, "Undef"
  vivify_1723:
    $P3450 = $P3449."ast"()
    set $P3440, $P3450
.annotate 'line', 1086
    goto if_3441_end
  if_3441:
    find_lex $P3444, "$/"
    unless_null $P3444, vivify_1724
    $P3444 = root_new ['parrot';'Hash']
  vivify_1724:
    set $P3445, $P3444["block"]
    unless_null $P3445, vivify_1725
    new $P3445, "Undef"
  vivify_1725:
    $P3446 = $P3445."ast"()
    $P3447 = "block_immediate"($P3446)
    set $P3440, $P3447
  if_3441_end:
    $P3451 = $P3439."!make"($P3440)
.annotate 'line', 1084
    .return ($P3451)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<if>"  :subid("454_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_3453
    .param pmc param_3454
.annotate 'line', 1092
    .lex "self", param_3453
    .lex "$/", param_3454
    find_lex $P3455, "$/"
    find_lex $P3456, "$/"
    unless_null $P3456, vivify_1726
    $P3456 = root_new ['parrot';'Hash']
  vivify_1726:
    set $P3457, $P3456["cond"]
    unless_null $P3457, vivify_1727
    new $P3457, "Undef"
  vivify_1727:
    $P3458 = $P3457."ast"()
    $P3459 = $P3455."!make"($P3458)
    .return ($P3459)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<unless>"  :subid("455_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_3461
    .param pmc param_3462
.annotate 'line', 1093
    .lex "self", param_3461
    .lex "$/", param_3462
    find_lex $P3463, "$/"
    find_lex $P3464, "$/"
    unless_null $P3464, vivify_1728
    $P3464 = root_new ['parrot';'Hash']
  vivify_1728:
    set $P3465, $P3464["cond"]
    unless_null $P3465, vivify_1729
    new $P3465, "Undef"
  vivify_1729:
    $P3466 = $P3465."ast"()
    $P3467 = $P3463."!make"($P3466)
    .return ($P3467)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<while>"  :subid("456_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_3469
    .param pmc param_3470
.annotate 'line', 1095
    .lex "self", param_3469
    .lex "$/", param_3470
    find_lex $P3471, "$/"
    find_lex $P3472, "$/"
    unless_null $P3472, vivify_1730
    $P3472 = root_new ['parrot';'Hash']
  vivify_1730:
    set $P3473, $P3472["cond"]
    unless_null $P3473, vivify_1731
    new $P3473, "Undef"
  vivify_1731:
    $P3474 = $P3473."ast"()
    $P3475 = $P3471."!make"($P3474)
    .return ($P3475)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<until>"  :subid("457_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_3477
    .param pmc param_3478
.annotate 'line', 1096
    .lex "self", param_3477
    .lex "$/", param_3478
    find_lex $P3479, "$/"
    find_lex $P3480, "$/"
    unless_null $P3480, vivify_1732
    $P3480 = root_new ['parrot';'Hash']
  vivify_1732:
    set $P3481, $P3480["cond"]
    unless_null $P3481, vivify_1733
    new $P3481, "Undef"
  vivify_1733:
    $P3482 = $P3481."ast"()
    $P3483 = $P3479."!make"($P3482)
    .return ($P3483)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<fatarrow>"  :subid("458_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_3485
    .param pmc param_3486
.annotate 'line', 1100
    .lex "self", param_3485
    .lex "$/", param_3486
    find_lex $P3487, "$/"
    find_lex $P3488, "$/"
    unless_null $P3488, vivify_1734
    $P3488 = root_new ['parrot';'Hash']
  vivify_1734:
    set $P3489, $P3488["fatarrow"]
    unless_null $P3489, vivify_1735
    new $P3489, "Undef"
  vivify_1735:
    $P3490 = $P3489."ast"()
    $P3491 = $P3487."!make"($P3490)
    .return ($P3491)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<colonpair>"  :subid("459_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_3493
    .param pmc param_3494
.annotate 'line', 1101
    .lex "self", param_3493
    .lex "$/", param_3494
    find_lex $P3495, "$/"
    find_lex $P3496, "$/"
    unless_null $P3496, vivify_1736
    $P3496 = root_new ['parrot';'Hash']
  vivify_1736:
    set $P3497, $P3496["colonpair"]
    unless_null $P3497, vivify_1737
    new $P3497, "Undef"
  vivify_1737:
    $P3498 = $P3497."ast"()
    $P3499 = $P3495."!make"($P3498)
    .return ($P3499)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<variable>"  :subid("460_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_3501
    .param pmc param_3502
.annotate 'line', 1102
    .lex "self", param_3501
    .lex "$/", param_3502
    find_lex $P3503, "$/"
    find_lex $P3504, "$/"
    unless_null $P3504, vivify_1738
    $P3504 = root_new ['parrot';'Hash']
  vivify_1738:
    set $P3505, $P3504["variable"]
    unless_null $P3505, vivify_1739
    new $P3505, "Undef"
  vivify_1739:
    $P3506 = $P3505."ast"()
    $P3507 = $P3503."!make"($P3506)
    .return ($P3507)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<package_declarator>"  :subid("461_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_3509
    .param pmc param_3510
.annotate 'line', 1103
    .lex "self", param_3509
    .lex "$/", param_3510
    find_lex $P3511, "$/"
    find_lex $P3512, "$/"
    unless_null $P3512, vivify_1740
    $P3512 = root_new ['parrot';'Hash']
  vivify_1740:
    set $P3513, $P3512["package_declarator"]
    unless_null $P3513, vivify_1741
    new $P3513, "Undef"
  vivify_1741:
    $P3514 = $P3513."ast"()
    $P3515 = $P3511."!make"($P3514)
    .return ($P3515)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<scope_declarator>"  :subid("462_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_3517
    .param pmc param_3518
.annotate 'line', 1104
    .lex "self", param_3517
    .lex "$/", param_3518
    find_lex $P3519, "$/"
    find_lex $P3520, "$/"
    unless_null $P3520, vivify_1742
    $P3520 = root_new ['parrot';'Hash']
  vivify_1742:
    set $P3521, $P3520["scope_declarator"]
    unless_null $P3521, vivify_1743
    new $P3521, "Undef"
  vivify_1743:
    $P3522 = $P3521."ast"()
    $P3523 = $P3519."!make"($P3522)
    .return ($P3523)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<routine_declarator>"  :subid("463_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_3525
    .param pmc param_3526
.annotate 'line', 1105
    .lex "self", param_3525
    .lex "$/", param_3526
    find_lex $P3527, "$/"
    find_lex $P3528, "$/"
    unless_null $P3528, vivify_1744
    $P3528 = root_new ['parrot';'Hash']
  vivify_1744:
    set $P3529, $P3528["routine_declarator"]
    unless_null $P3529, vivify_1745
    new $P3529, "Undef"
  vivify_1745:
    $P3530 = $P3529."ast"()
    $P3531 = $P3527."!make"($P3530)
    .return ($P3531)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<regex_declarator>"  :subid("464_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_3533
    .param pmc param_3534
.annotate 'line', 1106
    .lex "self", param_3533
    .lex "$/", param_3534
    find_lex $P3535, "$/"
    find_lex $P3536, "$/"
    unless_null $P3536, vivify_1746
    $P3536 = root_new ['parrot';'Hash']
  vivify_1746:
    set $P3537, $P3536["regex_declarator"]
    unless_null $P3537, vivify_1747
    new $P3537, "Undef"
  vivify_1747:
    $P3538 = $P3537."ast"()
    $P3539 = $P3535."!make"($P3538)
    .return ($P3539)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<statement_prefix>"  :subid("465_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_3541
    .param pmc param_3542
.annotate 'line', 1107
    .lex "self", param_3541
    .lex "$/", param_3542
    find_lex $P3543, "$/"
    find_lex $P3544, "$/"
    unless_null $P3544, vivify_1748
    $P3544 = root_new ['parrot';'Hash']
  vivify_1748:
    set $P3545, $P3544["statement_prefix"]
    unless_null $P3545, vivify_1749
    new $P3545, "Undef"
  vivify_1749:
    $P3546 = $P3545."ast"()
    $P3547 = $P3543."!make"($P3546)
    .return ($P3547)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<lambda>"  :subid("466_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_3549
    .param pmc param_3550
.annotate 'line', 1108
    .lex "self", param_3549
    .lex "$/", param_3550
    find_lex $P3551, "$/"
    find_lex $P3552, "$/"
    unless_null $P3552, vivify_1750
    $P3552 = root_new ['parrot';'Hash']
  vivify_1750:
    set $P3553, $P3552["pblock"]
    unless_null $P3553, vivify_1751
    new $P3553, "Undef"
  vivify_1751:
    $P3554 = $P3553."ast"()
    $P3555 = $P3551."!make"($P3554)
    .return ($P3555)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "fatarrow"  :subid("467_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_3557
    .param pmc param_3558
.annotate 'line', 1110
    .lex "self", param_3557
    .lex "$/", param_3558
.annotate 'line', 1111
    new $P3559, "Undef"
    .lex "$past", $P3559
    find_lex $P3560, "$/"
    unless_null $P3560, vivify_1752
    $P3560 = root_new ['parrot';'Hash']
  vivify_1752:
    set $P3561, $P3560["val"]
    unless_null $P3561, vivify_1753
    new $P3561, "Undef"
  vivify_1753:
    $P3562 = $P3561."ast"()
    store_lex "$past", $P3562
.annotate 'line', 1112
    find_lex $P3563, "$past"
    unless_null $P3563, vivify_1754
    new $P3563, "Undef"
  vivify_1754:
    find_lex $P3564, "$/"
    unless_null $P3564, vivify_1755
    $P3564 = root_new ['parrot';'Hash']
  vivify_1755:
    set $P3565, $P3564["key"]
    unless_null $P3565, vivify_1756
    new $P3565, "Undef"
  vivify_1756:
    $P3566 = $P3565."Str"()
    $P3563."named"($P3566)
.annotate 'line', 1113
    find_lex $P3567, "$/"
    find_lex $P3568, "$past"
    unless_null $P3568, vivify_1757
    new $P3568, "Undef"
  vivify_1757:
    $P3569 = $P3567."!make"($P3568)
.annotate 'line', 1110
    .return ($P3569)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair"  :subid("468_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_3571
    .param pmc param_3572
.annotate 'line', 1116
    .lex "self", param_3571
    .lex "$/", param_3572
.annotate 'line', 1117
    new $P3573, "Undef"
    .lex "$past", $P3573
.annotate 'line', 1118
    find_lex $P3576, "$/"
    unless_null $P3576, vivify_1758
    $P3576 = root_new ['parrot';'Hash']
  vivify_1758:
    set $P3577, $P3576["circumfix"]
    unless_null $P3577, vivify_1759
    new $P3577, "Undef"
  vivify_1759:
    if $P3577, if_3575
.annotate 'line', 1119
    get_hll_global $P3582, ["PAST"], "Val"
    find_lex $P3583, "$/"
    unless_null $P3583, vivify_1760
    $P3583 = root_new ['parrot';'Hash']
  vivify_1760:
    set $P3584, $P3583["not"]
    unless_null $P3584, vivify_1761
    new $P3584, "Undef"
  vivify_1761:
    isfalse $I3585, $P3584
    $P3586 = $P3582."new"($I3585 :named("value"))
    set $P3574, $P3586
.annotate 'line', 1118
    goto if_3575_end
  if_3575:
    find_lex $P3578, "$/"
    unless_null $P3578, vivify_1762
    $P3578 = root_new ['parrot';'Hash']
  vivify_1762:
    set $P3579, $P3578["circumfix"]
    unless_null $P3579, vivify_1763
    $P3579 = root_new ['parrot';'ResizablePMCArray']
  vivify_1763:
    set $P3580, $P3579[0]
    unless_null $P3580, vivify_1764
    new $P3580, "Undef"
  vivify_1764:
    $P3581 = $P3580."ast"()
    set $P3574, $P3581
  if_3575_end:
    store_lex "$past", $P3574
.annotate 'line', 1120
    find_lex $P3587, "$past"
    unless_null $P3587, vivify_1765
    new $P3587, "Undef"
  vivify_1765:
    find_lex $P3588, "$/"
    unless_null $P3588, vivify_1766
    $P3588 = root_new ['parrot';'Hash']
  vivify_1766:
    set $P3589, $P3588["identifier"]
    unless_null $P3589, vivify_1767
    new $P3589, "Undef"
  vivify_1767:
    set $S3590, $P3589
    $P3587."named"($S3590)
.annotate 'line', 1121
    find_lex $P3591, "$/"
    find_lex $P3592, "$past"
    unless_null $P3592, vivify_1768
    new $P3592, "Undef"
  vivify_1768:
    $P3593 = $P3591."!make"($P3592)
.annotate 'line', 1116
    .return ($P3593)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "variable"  :subid("469_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_3595
    .param pmc param_3596
.annotate 'line', 1124
    .const 'Sub' $P3609 = "470_1303340952.947" 
    capture_lex $P3609
    .lex "self", param_3595
    .lex "$/", param_3596
.annotate 'line', 1125
    new $P3597, "Undef"
    .lex "$past", $P3597
.annotate 'line', 1124
    find_lex $P3598, "$past"
    unless_null $P3598, vivify_1769
    new $P3598, "Undef"
  vivify_1769:
.annotate 'line', 1126
    find_lex $P3600, "$/"
    unless_null $P3600, vivify_1770
    $P3600 = root_new ['parrot';'Hash']
  vivify_1770:
    set $P3601, $P3600["postcircumfix"]
    unless_null $P3601, vivify_1771
    new $P3601, "Undef"
  vivify_1771:
    if $P3601, if_3599
.annotate 'line', 1130
    .const 'Sub' $P3609 = "470_1303340952.947" 
    capture_lex $P3609
    $P3609()
    goto if_3599_end
  if_3599:
.annotate 'line', 1127
    find_lex $P3602, "$/"
    unless_null $P3602, vivify_1807
    $P3602 = root_new ['parrot';'Hash']
  vivify_1807:
    set $P3603, $P3602["postcircumfix"]
    unless_null $P3603, vivify_1808
    new $P3603, "Undef"
  vivify_1808:
    $P3604 = $P3603."ast"()
    store_lex "$past", $P3604
.annotate 'line', 1128
    find_lex $P3605, "$past"
    unless_null $P3605, vivify_1809
    new $P3605, "Undef"
  vivify_1809:
    get_hll_global $P3606, ["PAST"], "Var"
    $P3607 = $P3606."new"("$/" :named("name"))
    $P3605."unshift"($P3607)
  if_3599_end:
.annotate 'line', 1172
    find_lex $P3702, "$/"
    find_lex $P3703, "$past"
    unless_null $P3703, vivify_1810
    new $P3703, "Undef"
  vivify_1810:
    $P3704 = $P3702."!make"($P3703)
.annotate 'line', 1124
    .return ($P3704)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3608"  :anon :subid("470_1303340952.947") :outer("469_1303340952.947")
.annotate 'line', 1131
    $P3610 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P3610
    get_hll_global $P3611, ["NQP"], "Compiler"
    find_lex $P3612, "$/"
    unless_null $P3612, vivify_1772
    new $P3612, "Undef"
  vivify_1772:
    set $S3613, $P3612
    $P3614 = $P3611."parse_name"($S3613)
    store_lex "@name", $P3614
.annotate 'line', 1132
    find_lex $P3617, "@name"
    unless_null $P3617, vivify_1773
    $P3617 = root_new ['parrot';'ResizablePMCArray']
  vivify_1773:
    set $N3618, $P3617
    isgt $I3619, $N3618, 1.0
    if $I3619, if_3616
.annotate 'line', 1139
    find_lex $P3635, "$/"
    unless_null $P3635, vivify_1774
    $P3635 = root_new ['parrot';'Hash']
  vivify_1774:
    set $P3636, $P3635["twigil"]
    unless_null $P3636, vivify_1775
    $P3636 = root_new ['parrot';'ResizablePMCArray']
  vivify_1775:
    set $P3637, $P3636[0]
    unless_null $P3637, vivify_1776
    new $P3637, "Undef"
  vivify_1776:
    set $S3638, $P3637
    iseq $I3639, $S3638, "*"
    if $I3639, if_3634
.annotate 'line', 1154
    find_lex $P3663, "$/"
    unless_null $P3663, vivify_1777
    $P3663 = root_new ['parrot';'Hash']
  vivify_1777:
    set $P3664, $P3663["twigil"]
    unless_null $P3664, vivify_1778
    $P3664 = root_new ['parrot';'ResizablePMCArray']
  vivify_1778:
    set $P3665, $P3664[0]
    unless_null $P3665, vivify_1779
    new $P3665, "Undef"
  vivify_1779:
    set $S3666, $P3665
    iseq $I3667, $S3666, "!"
    if $I3667, if_3662
.annotate 'line', 1162
    find_lex $P3682, "@name"
    unless_null $P3682, vivify_1780
    $P3682 = root_new ['parrot';'ResizablePMCArray']
  vivify_1780:
    set $P3683, $P3682[0]
    unless_null $P3683, vivify_1781
    new $P3683, "Undef"
  vivify_1781:
    set $S3684, $P3683
    $P3685 = "is_package"($S3684)
    if $P3685, if_3681
.annotate 'line', 1167
    get_hll_global $P3694, ["PAST"], "Var"
.annotate 'line', 1168
    find_lex $P3695, "@name"
    unless_null $P3695, vivify_1782
    $P3695 = root_new ['parrot';'ResizablePMCArray']
  vivify_1782:
    $P3696 = $P3695."pop"()
    set $S3697, $P3696
    find_lex $P3698, "$/"
    unless_null $P3698, vivify_1783
    $P3698 = root_new ['parrot';'Hash']
  vivify_1783:
    set $P3699, $P3698["sigil"]
    unless_null $P3699, vivify_1784
    new $P3699, "Undef"
  vivify_1784:
    $P3700 = "vivitype"($P3699)
    $P3701 = $P3694."new"($S3697 :named("name"), $P3700 :named("viviself"))
.annotate 'line', 1167
    store_lex "$past", $P3701
.annotate 'line', 1166
    set $P3680, $P3701
.annotate 'line', 1162
    goto if_3681_end
  if_3681:
.annotate 'line', 1163
    find_lex $P3686, "@name"
    unless_null $P3686, vivify_1785
    $P3686 = root_new ['parrot';'ResizablePMCArray']
  vivify_1785:
    find_lex $P3687, "$/"
    unless_null $P3687, vivify_1786
    new $P3687, "Undef"
  vivify_1786:
    $P3688 = "lexical_package_lookup"($P3686, $P3687)
    store_lex "$past", $P3688
.annotate 'line', 1164
    find_lex $P3689, "$past"
    unless_null $P3689, vivify_1787
    new $P3689, "Undef"
  vivify_1787:
    find_lex $P3690, "$/"
    unless_null $P3690, vivify_1788
    $P3690 = root_new ['parrot';'Hash']
  vivify_1788:
    set $P3691, $P3690["sigil"]
    unless_null $P3691, vivify_1789
    new $P3691, "Undef"
  vivify_1789:
    $P3692 = "vivitype"($P3691)
    $P3693 = $P3689."viviself"($P3692)
.annotate 'line', 1162
    set $P3680, $P3693
  if_3681_end:
    set $P3661, $P3680
.annotate 'line', 1154
    goto if_3662_end
  if_3662:
.annotate 'line', 1155
    get_hll_global $P3668, ["PAST"], "Var"
.annotate 'line', 1156
    find_lex $P3669, "@name"
    unless_null $P3669, vivify_1790
    $P3669 = root_new ['parrot';'ResizablePMCArray']
  vivify_1790:
    $P3670 = $P3669."pop"()
    set $S3671, $P3670
.annotate 'line', 1157
    find_lex $P3672, "$/"
    unless_null $P3672, vivify_1791
    $P3672 = root_new ['parrot';'Hash']
  vivify_1791:
    set $P3673, $P3672["sigil"]
    unless_null $P3673, vivify_1792
    new $P3673, "Undef"
  vivify_1792:
    $P3674 = "vivitype"($P3673)
.annotate 'line', 1158
    get_hll_global $P3675, ["PAST"], "Var"
    $P3676 = $P3675."new"("self" :named("name"))
.annotate 'line', 1159
    get_hll_global $P3677, ["PAST"], "Var"
    $P3678 = $P3677."new"("$?CLASS" :named("name"))
    $P3679 = $P3668."new"($P3676, $P3678, $S3671 :named("name"), "attribute" :named("scope"), $P3674 :named("viviself"))
.annotate 'line', 1155
    store_lex "$past", $P3679
.annotate 'line', 1154
    set $P3661, $P3679
  if_3662_end:
    set $P3633, $P3661
.annotate 'line', 1139
    goto if_3634_end
  if_3634:
.annotate 'line', 1140
    get_hll_global $P3640, ["PAST"], "Var"
.annotate 'line', 1141
    find_lex $P3641, "@name"
    unless_null $P3641, vivify_1793
    $P3641 = root_new ['parrot';'ResizablePMCArray']
  vivify_1793:
    $P3642 = $P3641."pop"()
    set $S3643, $P3642
.annotate 'line', 1143
    get_hll_global $P3644, ["PAST"], "Var"
.annotate 'line', 1145
    find_lex $P3645, "$/"
    unless_null $P3645, vivify_1794
    $P3645 = root_new ['parrot';'Hash']
  vivify_1794:
    set $P3646, $P3645["sigil"]
    unless_null $P3646, vivify_1795
    new $P3646, "Undef"
  vivify_1795:
    set $S3647, $P3646
    new $P3648, 'String'
    set $P3648, $S3647
    find_lex $P3649, "$/"
    unless_null $P3649, vivify_1796
    $P3649 = root_new ['parrot';'Hash']
  vivify_1796:
    set $P3650, $P3649["desigilname"]
    unless_null $P3650, vivify_1797
    new $P3650, "Undef"
  vivify_1797:
    concat $P3651, $P3648, $P3650
.annotate 'line', 1147
    get_hll_global $P3652, ["PAST"], "Op"
    new $P3653, "String"
    assign $P3653, "Contextual "
    find_lex $P3654, "$/"
    unless_null $P3654, vivify_1798
    new $P3654, "Undef"
  vivify_1798:
    set $S3655, $P3654
    concat $P3656, $P3653, $S3655
    concat $P3657, $P3656, " not found"
    $P3658 = $P3652."new"($P3657, "die" :named("pirop"))
    $P3659 = $P3644."new"("package" :named("scope"), "" :named("namespace"), $P3651 :named("name"), $P3658 :named("viviself"))
.annotate 'line', 1143
    $P3660 = $P3640."new"($S3643 :named("name"), "contextual" :named("scope"), $P3659 :named("viviself"))
.annotate 'line', 1140
    store_lex "$past", $P3660
.annotate 'line', 1139
    set $P3633, $P3660
  if_3634_end:
    set $P3615, $P3633
.annotate 'line', 1132
    goto if_3616_end
  if_3616:
.annotate 'line', 1133
    find_lex $P3621, "$/"
    unless_null $P3621, vivify_1799
    $P3621 = root_new ['parrot';'Hash']
  vivify_1799:
    set $P3622, $P3621["twigil"]
    unless_null $P3622, vivify_1800
    new $P3622, "Undef"
  vivify_1800:
    unless $P3622, if_3620_end
.annotate 'line', 1134
    find_lex $P3623, "$/"
    unless_null $P3623, vivify_1801
    new $P3623, "Undef"
  vivify_1801:
    $P3624 = $P3623."CURSOR"()
    $P3624."panic"("Twigil not allowed on multi-part name")
  if_3620_end:
.annotate 'line', 1136
    find_lex $P3625, "@name"
    unless_null $P3625, vivify_1802
    $P3625 = root_new ['parrot';'ResizablePMCArray']
  vivify_1802:
    find_lex $P3626, "$/"
    unless_null $P3626, vivify_1803
    new $P3626, "Undef"
  vivify_1803:
    $P3627 = "lexical_package_lookup"($P3625, $P3626)
    store_lex "$past", $P3627
.annotate 'line', 1137
    find_lex $P3628, "$past"
    unless_null $P3628, vivify_1804
    new $P3628, "Undef"
  vivify_1804:
    find_lex $P3629, "$/"
    unless_null $P3629, vivify_1805
    $P3629 = root_new ['parrot';'Hash']
  vivify_1805:
    set $P3630, $P3629["sigil"]
    unless_null $P3630, vivify_1806
    new $P3630, "Undef"
  vivify_1806:
    $P3631 = "vivitype"($P3630)
    $P3632 = $P3628."viviself"($P3631)
.annotate 'line', 1132
    set $P3615, $P3632
  if_3616_end:
.annotate 'line', 1130
    .return ($P3615)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<module>"  :subid("471_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_3706
    .param pmc param_3707
.annotate 'line', 1175
    .lex "self", param_3706
    .lex "$/", param_3707
    find_lex $P3708, "$/"
    find_lex $P3709, "$/"
    unless_null $P3709, vivify_1811
    $P3709 = root_new ['parrot';'Hash']
  vivify_1811:
    set $P3710, $P3709["package_def"]
    unless_null $P3710, vivify_1812
    new $P3710, "Undef"
  vivify_1812:
    $P3711 = $P3710."ast"()
    $P3712 = $P3708."!make"($P3711)
    .return ($P3712)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<knowhow>"  :subid("472_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_3714
    .param pmc param_3715
.annotate 'line', 1176
    .lex "self", param_3714
    .lex "$/", param_3715
    find_lex $P3716, "$/"
    find_lex $P3717, "$/"
    unless_null $P3717, vivify_1813
    $P3717 = root_new ['parrot';'Hash']
  vivify_1813:
    set $P3718, $P3717["package_def"]
    unless_null $P3718, vivify_1814
    new $P3718, "Undef"
  vivify_1814:
    $P3719 = $P3718."ast"()
    $P3720 = $P3716."!make"($P3719)
    .return ($P3720)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<class>"  :subid("473_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_3722
    .param pmc param_3723
.annotate 'line', 1177
    .lex "self", param_3722
    .lex "$/", param_3723
    find_lex $P3724, "$/"
    find_lex $P3725, "$/"
    unless_null $P3725, vivify_1815
    $P3725 = root_new ['parrot';'Hash']
  vivify_1815:
    set $P3726, $P3725["package_def"]
    unless_null $P3726, vivify_1816
    new $P3726, "Undef"
  vivify_1816:
    $P3727 = $P3726."ast"()
    $P3728 = $P3724."!make"($P3727)
    .return ($P3728)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<grammar>"  :subid("474_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_3730
    .param pmc param_3731
.annotate 'line', 1178
    .lex "self", param_3730
    .lex "$/", param_3731
    find_lex $P3732, "$/"
    find_lex $P3733, "$/"
    unless_null $P3733, vivify_1817
    $P3733 = root_new ['parrot';'Hash']
  vivify_1817:
    set $P3734, $P3733["package_def"]
    unless_null $P3734, vivify_1818
    new $P3734, "Undef"
  vivify_1818:
    $P3735 = $P3734."ast"()
    $P3736 = $P3732."!make"($P3735)
    .return ($P3736)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<role>"  :subid("475_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_3738
    .param pmc param_3739
.annotate 'line', 1179
    .lex "self", param_3738
    .lex "$/", param_3739
    find_lex $P3740, "$/"
    find_lex $P3741, "$/"
    unless_null $P3741, vivify_1819
    $P3741 = root_new ['parrot';'Hash']
  vivify_1819:
    set $P3742, $P3741["package_def"]
    unless_null $P3742, vivify_1820
    new $P3742, "Undef"
  vivify_1820:
    $P3743 = $P3742."ast"()
    $P3744 = $P3740."!make"($P3743)
    .return ($P3744)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<native>"  :subid("476_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_3746
    .param pmc param_3747
.annotate 'line', 1180
    .lex "self", param_3746
    .lex "$/", param_3747
    find_lex $P3748, "$/"
    find_lex $P3749, "$/"
    unless_null $P3749, vivify_1821
    $P3749 = root_new ['parrot';'Hash']
  vivify_1821:
    set $P3750, $P3749["package_def"]
    unless_null $P3750, vivify_1822
    new $P3750, "Undef"
  vivify_1822:
    $P3751 = $P3750."ast"()
    $P3752 = $P3748."!make"($P3751)
    .return ($P3752)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "package_def"  :subid("477_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_3754
    .param pmc param_3755
.annotate 'line', 1182
    .const 'Sub' $P3929 = "479_1303340952.947" 
    capture_lex $P3929
    .const 'Sub' $P3878 = "478_1303340952.947" 
    capture_lex $P3878
    .lex "self", param_3754
    .lex "$/", param_3755
.annotate 'line', 1184
    $P3756 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P3756
.annotate 'line', 1185
    new $P3757, "Undef"
    .lex "$name", $P3757
.annotate 'line', 1186
    new $P3758, "Undef"
    .lex "$how", $P3758
.annotate 'line', 1189
    new $P3759, "Undef"
    .lex "$past", $P3759
.annotate 'line', 1184
    find_lex $P3760, "$/"
    unless_null $P3760, vivify_1823
    $P3760 = root_new ['parrot';'Hash']
  vivify_1823:
    set $P3761, $P3760["name"]
    unless_null $P3761, vivify_1824
    $P3761 = root_new ['parrot';'Hash']
  vivify_1824:
    set $P3762, $P3761["identifier"]
    unless_null $P3762, vivify_1825
    new $P3762, "Undef"
  vivify_1825:
    clone $P3763, $P3762
    store_lex "@ns", $P3763
.annotate 'line', 1185
    find_lex $P3764, "@ns"
    unless_null $P3764, vivify_1826
    $P3764 = root_new ['parrot';'ResizablePMCArray']
  vivify_1826:
    $P3765 = $P3764."pop"()
    set $S3766, $P3765
    new $P3767, 'String'
    set $P3767, $S3766
    store_lex "$name", $P3767
.annotate 'line', 1186
    find_dynamic_lex $P3768, "$*PKGDECL"
    unless_null $P3768, vivify_1827
    get_hll_global $P3768, "$PKGDECL"
    unless_null $P3768, vivify_1828
    die "Contextual $*PKGDECL not found"
  vivify_1828:
  vivify_1827:
    find_dynamic_lex $P3769, "%*HOW"
    unless_null $P3769, vivify_1829
    get_hll_global $P3769, "%HOW"
    unless_null $P3769, vivify_1830
    die "Contextual %*HOW not found"
  vivify_1830:
  vivify_1829:
    set $P3770, $P3769[$P3768]
    unless_null $P3770, vivify_1831
    new $P3770, "Undef"
  vivify_1831:
    store_lex "$how", $P3770
.annotate 'line', 1189
    find_lex $P3773, "$/"
    unless_null $P3773, vivify_1832
    $P3773 = root_new ['parrot';'Hash']
  vivify_1832:
    set $P3774, $P3773["block"]
    unless_null $P3774, vivify_1833
    new $P3774, "Undef"
  vivify_1833:
    if $P3774, if_3772
    find_lex $P3778, "$/"
    unless_null $P3778, vivify_1834
    $P3778 = root_new ['parrot';'Hash']
  vivify_1834:
    set $P3779, $P3778["comp_unit"]
    unless_null $P3779, vivify_1835
    new $P3779, "Undef"
  vivify_1835:
    $P3780 = $P3779."ast"()
    set $P3771, $P3780
    goto if_3772_end
  if_3772:
    find_lex $P3775, "$/"
    unless_null $P3775, vivify_1836
    $P3775 = root_new ['parrot';'Hash']
  vivify_1836:
    set $P3776, $P3775["block"]
    unless_null $P3776, vivify_1837
    new $P3776, "Undef"
  vivify_1837:
    $P3777 = $P3776."ast"()
    set $P3771, $P3777
  if_3772_end:
    store_lex "$past", $P3771
.annotate 'line', 1192
    find_dynamic_lex $P3784, "$*SCOPE"
    unless_null $P3784, vivify_1838
    get_hll_global $P3784, "$SCOPE"
    unless_null $P3784, vivify_1839
    die "Contextual $*SCOPE not found"
  vivify_1839:
  vivify_1838:
    set $S3785, $P3784
    iseq $I3786, $S3785, "our"
    unless $I3786, unless_3783
    new $P3782, 'Integer'
    set $P3782, $I3786
    goto unless_3783_end
  unless_3783:
    find_dynamic_lex $P3787, "$*SCOPE"
    unless_null $P3787, vivify_1840
    get_hll_global $P3787, "$SCOPE"
    unless_null $P3787, vivify_1841
    die "Contextual $*SCOPE not found"
  vivify_1841:
  vivify_1840:
    set $S3788, $P3787
    iseq $I3789, $S3788, ""
    new $P3782, 'Integer'
    set $P3782, $I3789
  unless_3783_end:
    if $P3782, if_3781
.annotate 'line', 1196
    find_dynamic_lex $P3800, "$*SCOPE"
    unless_null $P3800, vivify_1842
    get_hll_global $P3800, "$SCOPE"
    unless_null $P3800, vivify_1843
    die "Contextual $*SCOPE not found"
  vivify_1843:
  vivify_1842:
    set $S3801, $P3800
    iseq $I3802, $S3801, "my"
    if $I3802, if_3799
.annotate 'line', 1203
    find_lex $P3822, "$/"
    unless_null $P3822, vivify_1844
    new $P3822, "Undef"
  vivify_1844:
    $P3823 = $P3822."CURSOR"()
    find_dynamic_lex $P3824, "$*SCOPE"
    unless_null $P3824, vivify_1845
    get_hll_global $P3824, "$SCOPE"
    unless_null $P3824, vivify_1846
    die "Contextual $*SCOPE not found"
  vivify_1846:
  vivify_1845:
    concat $P3825, $P3824, " scoped packages are not supported"
    $P3823."panic"($P3825)
.annotate 'line', 1202
    goto if_3799_end
  if_3799:
.annotate 'line', 1197
    find_lex $P3804, "$/"
    unless_null $P3804, vivify_1847
    $P3804 = root_new ['parrot';'Hash']
  vivify_1847:
    set $P3805, $P3804["name"]
    unless_null $P3805, vivify_1848
    $P3805 = root_new ['parrot';'Hash']
  vivify_1848:
    set $P3806, $P3805["identifier"]
    unless_null $P3806, vivify_1849
    new $P3806, "Undef"
  vivify_1849:
    set $N3807, $P3806
    isne $I3808, $N3807, 1.0
    unless $I3808, if_3803_end
.annotate 'line', 1198
    find_lex $P3809, "$/"
    unless_null $P3809, vivify_1850
    $P3809 = root_new ['parrot';'Hash']
  vivify_1850:
    set $P3810, $P3809["name"]
    unless_null $P3810, vivify_1851
    new $P3810, "Undef"
  vivify_1851:
    $P3811 = $P3810."CURSOR"()
    $P3811."panic"("A my scoped package cannot have a multi-part name yet")
  if_3803_end:
.annotate 'line', 1200
    find_dynamic_lex $P3812, "$*SC"
    unless_null $P3812, vivify_1852
    get_hll_global $P3812, "$SC"
    unless_null $P3812, vivify_1853
    die "Contextual $*SC not found"
  vivify_1853:
  vivify_1852:
    find_lex $P3813, "$?PACKAGE"
    get_who $P3814, $P3813
    set $P3815, $P3814["@BLOCK"]
    unless_null $P3815, vivify_1854
    $P3815 = root_new ['parrot';'ResizablePMCArray']
  vivify_1854:
    set $P3816, $P3815[0]
    unless_null $P3816, vivify_1855
    new $P3816, "Undef"
  vivify_1855:
    find_lex $P3817, "$/"
    unless_null $P3817, vivify_1856
    $P3817 = root_new ['parrot';'Hash']
  vivify_1856:
    set $P3818, $P3817["name"]
    unless_null $P3818, vivify_1857
    $P3818 = root_new ['parrot';'Hash']
  vivify_1857:
    set $P3819, $P3818["identifier"]
    unless_null $P3819, vivify_1858
    $P3819 = root_new ['parrot';'ResizablePMCArray']
  vivify_1858:
    set $P3820, $P3819[0]
    unless_null $P3820, vivify_1859
    new $P3820, "Undef"
  vivify_1859:
    find_dynamic_lex $P3821, "$*PACKAGE"
    unless_null $P3821, vivify_1860
    get_hll_global $P3821, "$PACKAGE"
    unless_null $P3821, vivify_1861
    die "Contextual $*PACKAGE not found"
  vivify_1861:
  vivify_1860:
    $P3812."install_lexical_symbol"($P3816, $P3820, $P3821)
  if_3799_end:
.annotate 'line', 1196
    goto if_3781_end
  if_3781:
.annotate 'line', 1193
    find_lex $P3790, "$past"
    unless_null $P3790, vivify_1862
    new $P3790, "Undef"
  vivify_1862:
    find_lex $P3791, "$/"
    unless_null $P3791, vivify_1863
    $P3791 = root_new ['parrot';'Hash']
  vivify_1863:
    set $P3792, $P3791["name"]
    unless_null $P3792, vivify_1864
    $P3792 = root_new ['parrot';'Hash']
  vivify_1864:
    set $P3793, $P3792["identifier"]
    unless_null $P3793, vivify_1865
    new $P3793, "Undef"
  vivify_1865:
    $P3790."namespace"($P3793)
.annotate 'line', 1194
    find_dynamic_lex $P3794, "$*SC"
    unless_null $P3794, vivify_1866
    get_hll_global $P3794, "$SC"
    unless_null $P3794, vivify_1867
    die "Contextual $*SC not found"
  vivify_1867:
  vivify_1866:
    find_lex $P3795, "$/"
    unless_null $P3795, vivify_1868
    $P3795 = root_new ['parrot';'Hash']
  vivify_1868:
    set $P3796, $P3795["name"]
    unless_null $P3796, vivify_1869
    $P3796 = root_new ['parrot';'Hash']
  vivify_1869:
    set $P3797, $P3796["identifier"]
    unless_null $P3797, vivify_1870
    new $P3797, "Undef"
  vivify_1870:
    find_dynamic_lex $P3798, "$*PACKAGE"
    unless_null $P3798, vivify_1871
    get_hll_global $P3798, "$PACKAGE"
    unless_null $P3798, vivify_1872
    die "Contextual $*PACKAGE not found"
  vivify_1872:
  vivify_1871:
    $P3794."install_package_symbol"($P3797, $P3798)
  if_3781_end:
.annotate 'line', 1207
    find_dynamic_lex $P3826, "$*PACKAGE-SETUP"
    unless_null $P3826, vivify_1873
    get_hll_global $P3826, "$PACKAGE-SETUP"
    unless_null $P3826, vivify_1874
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1874:
  vivify_1873:
    get_hll_global $P3827, ["PAST"], "Stmts"
.annotate 'line', 1208
    get_hll_global $P3828, ["PAST"], "Op"
.annotate 'line', 1209
    get_hll_global $P3829, ["PAST"], "Var"
    $P3830 = $P3829."new"("type_obj" :named("name"), "register" :named("scope"), 1 :named("isdecl"))
.annotate 'line', 1210
    find_dynamic_lex $P3831, "$*SC"
    unless_null $P3831, vivify_1875
    get_hll_global $P3831, "$SC"
    unless_null $P3831, vivify_1876
    die "Contextual $*SC not found"
  vivify_1876:
  vivify_1875:
    find_dynamic_lex $P3832, "$*PACKAGE"
    unless_null $P3832, vivify_1877
    get_hll_global $P3832, "$PACKAGE"
    unless_null $P3832, vivify_1878
    die "Contextual $*PACKAGE not found"
  vivify_1878:
  vivify_1877:
    $P3833 = $P3831."get_slot_past_for_object"($P3832)
    $P3834 = $P3828."new"($P3830, $P3833, "bind" :named("pasttype"))
.annotate 'line', 1208
    $P3835 = $P3827."new"($P3834)
.annotate 'line', 1207
    $P3826."unshift"($P3835)
.annotate 'line', 1219
    find_lex $P3839, "$how"
    unless_null $P3839, vivify_1879
    new $P3839, "Undef"
  vivify_1879:
    can $I3840, $P3839, "parametric"
    if $I3840, if_3838
    new $P3837, 'Integer'
    set $P3837, $I3840
    goto if_3838_end
  if_3838:
    find_lex $P3841, "$how"
    unless_null $P3841, vivify_1880
    new $P3841, "Undef"
  vivify_1880:
    find_lex $P3842, "$how"
    unless_null $P3842, vivify_1881
    new $P3842, "Undef"
  vivify_1881:
    $P3843 = $P3841."parametric"($P3842)
    set $P3837, $P3843
  if_3838_end:
    if $P3837, if_3836
.annotate 'line', 1237
    find_lex $P3867, "$past"
    unless_null $P3867, vivify_1882
    new $P3867, "Undef"
  vivify_1882:
    $P3867."blocktype"("immediate")
.annotate 'line', 1238
    find_dynamic_lex $P3868, "$*SC"
    unless_null $P3868, vivify_1883
    get_hll_global $P3868, "$SC"
    unless_null $P3868, vivify_1884
    die "Contextual $*SC not found"
  vivify_1884:
  vivify_1883:
    find_lex $P3869, "$past"
    unless_null $P3869, vivify_1885
    new $P3869, "Undef"
  vivify_1885:
    find_dynamic_lex $P3870, "$*PACKAGE"
    unless_null $P3870, vivify_1886
    get_hll_global $P3870, "$PACKAGE"
    unless_null $P3870, vivify_1887
    die "Contextual $*PACKAGE not found"
  vivify_1887:
  vivify_1886:
    $P3868."install_lexical_symbol"($P3869, "$?PACKAGE", $P3870)
.annotate 'line', 1239
    find_dynamic_lex $P3871, "$*SC"
    unless_null $P3871, vivify_1888
    get_hll_global $P3871, "$SC"
    unless_null $P3871, vivify_1889
    die "Contextual $*SC not found"
  vivify_1889:
  vivify_1888:
    find_lex $P3872, "$past"
    unless_null $P3872, vivify_1890
    new $P3872, "Undef"
  vivify_1890:
    find_dynamic_lex $P3873, "$*PACKAGE"
    unless_null $P3873, vivify_1891
    get_hll_global $P3873, "$PACKAGE"
    unless_null $P3873, vivify_1892
    die "Contextual $*PACKAGE not found"
  vivify_1892:
  vivify_1891:
    $P3871."install_lexical_symbol"($P3872, "$?CLASS", $P3873)
.annotate 'line', 1236
    goto if_3836_end
  if_3836:
.annotate 'line', 1220
    find_lex $P3844, "$past"
    unless_null $P3844, vivify_1893
    new $P3844, "Undef"
  vivify_1893:
    $P3844."blocktype"("declaration")
.annotate 'line', 1221
    find_lex $P3845, "$past"
    unless_null $P3845, vivify_1894
    new $P3845, "Undef"
  vivify_1894:
    get_hll_global $P3846, ["PAST"], "Var"
    $P3847 = $P3846."new"("$?CLASS" :named("name"), "parameter" :named("scope"))
    $P3845."unshift"($P3847)
.annotate 'line', 1222
    find_lex $P3848, "$past"
    unless_null $P3848, vivify_1895
    new $P3848, "Undef"
  vivify_1895:
    $P3848."symbol"("$?CLASS", "lexical" :named("scope"))
.annotate 'line', 1223
    find_dynamic_lex $P3849, "$*PACKAGE-SETUP"
    unless_null $P3849, vivify_1896
    get_hll_global $P3849, "$PACKAGE-SETUP"
    unless_null $P3849, vivify_1897
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1897:
  vivify_1896:
    get_hll_global $P3850, ["PAST"], "Op"
.annotate 'line', 1225
    get_hll_global $P3851, ["PAST"], "Op"
.annotate 'line', 1228
    get_hll_global $P3852, ["PAST"], "Var"
    $P3853 = $P3852."new"("type_obj" :named("name"), "register" :named("scope"))
    $P3854 = $P3851."new"($P3853, "get_how PP" :named("pirop"))
.annotate 'line', 1230
    get_hll_global $P3855, ["PAST"], "Var"
    $P3856 = $P3855."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1231
    get_hll_global $P3857, ["PAST"], "Val"
    find_lex $P3858, "$past"
    unless_null $P3858, vivify_1898
    new $P3858, "Undef"
  vivify_1898:
    $P3859 = $P3857."new"($P3858 :named("value"))
    $P3860 = $P3850."new"($P3854, $P3856, $P3859, "callmethod" :named("pasttype"), "set_body_block" :named("name"))
.annotate 'line', 1223
    $P3849."push"($P3860)
.annotate 'line', 1233
    find_dynamic_lex $P3861, "$*SC"
    unless_null $P3861, vivify_1899
    get_hll_global $P3861, "$SC"
    unless_null $P3861, vivify_1900
    die "Contextual $*SC not found"
  vivify_1900:
  vivify_1899:
    find_lex $P3862, "$past"
    unless_null $P3862, vivify_1901
    new $P3862, "Undef"
  vivify_1901:
    find_dynamic_lex $P3863, "$*PACKAGE"
    unless_null $P3863, vivify_1902
    get_hll_global $P3863, "$PACKAGE"
    unless_null $P3863, vivify_1903
    die "Contextual $*PACKAGE not found"
  vivify_1903:
  vivify_1902:
    $P3861."install_lexical_symbol"($P3862, "$?PACKAGE", $P3863)
.annotate 'line', 1234
    find_dynamic_lex $P3864, "$*SC"
    unless_null $P3864, vivify_1904
    get_hll_global $P3864, "$SC"
    unless_null $P3864, vivify_1905
    die "Contextual $*SC not found"
  vivify_1905:
  vivify_1904:
    find_lex $P3865, "$past"
    unless_null $P3865, vivify_1906
    new $P3865, "Undef"
  vivify_1906:
    find_dynamic_lex $P3866, "$*PACKAGE"
    unless_null $P3866, vivify_1907
    get_hll_global $P3866, "$PACKAGE"
    unless_null $P3866, vivify_1908
    die "Contextual $*PACKAGE not found"
  vivify_1908:
  vivify_1907:
    $P3864."install_lexical_symbol"($P3865, "$?ROLE", $P3866)
  if_3836_end:
.annotate 'line', 1244
    find_lex $P3875, "$/"
    unless_null $P3875, vivify_1909
    $P3875 = root_new ['parrot';'Hash']
  vivify_1909:
    set $P3876, $P3875["parent"]
    unless_null $P3876, vivify_1910
    new $P3876, "Undef"
  vivify_1910:
    if $P3876, if_3874
.annotate 'line', 1258
    find_dynamic_lex $P3906, "$*PKGDECL"
    unless_null $P3906, vivify_1911
    get_hll_global $P3906, "$PKGDECL"
    unless_null $P3906, vivify_1912
    die "Contextual $*PKGDECL not found"
  vivify_1912:
  vivify_1911:
    set $S3907, $P3906
    iseq $I3908, $S3907, "grammar"
    unless $I3908, if_3905_end
.annotate 'line', 1259
    find_dynamic_lex $P3909, "$*PACKAGE-SETUP"
    unless_null $P3909, vivify_1913
    get_hll_global $P3909, "$PACKAGE-SETUP"
    unless_null $P3909, vivify_1914
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1914:
  vivify_1913:
    get_hll_global $P3910, ["PAST"], "Op"
.annotate 'line', 1261
    get_hll_global $P3911, ["PAST"], "Op"
.annotate 'line', 1264
    get_hll_global $P3912, ["PAST"], "Var"
    $P3913 = $P3912."new"("type_obj" :named("name"), "register" :named("scope"))
    $P3914 = $P3911."new"($P3913, "get_how PP" :named("pirop"))
.annotate 'line', 1266
    get_hll_global $P3915, ["PAST"], "Var"
    $P3916 = $P3915."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1267
    get_hll_global $P3917, ["PAST"], "Var"
    $P3918 = $P3917."new"("Cursor" :named("name"), "Regex" :named("namespace"), "package" :named("scope"))
    $P3919 = $P3910."new"($P3914, $P3916, $P3918, "callmethod" :named("pasttype"), "add_parent" :named("name"))
.annotate 'line', 1259
    $P3909."push"($P3919)
  if_3905_end:
.annotate 'line', 1258
    goto if_3874_end
  if_3874:
.annotate 'line', 1244
    .const 'Sub' $P3878 = "478_1303340952.947" 
    capture_lex $P3878
    $P3878()
  if_3874_end:
.annotate 'line', 1272
    find_lex $P3921, "$/"
    unless_null $P3921, vivify_1924
    $P3921 = root_new ['parrot';'Hash']
  vivify_1924:
    set $P3922, $P3921["role"]
    unless_null $P3922, vivify_1925
    new $P3922, "Undef"
  vivify_1925:
    unless $P3922, if_3920_end
.annotate 'line', 1273
    find_lex $P3924, "$/"
    unless_null $P3924, vivify_1926
    $P3924 = root_new ['parrot';'Hash']
  vivify_1926:
    set $P3925, $P3924["role"]
    unless_null $P3925, vivify_1927
    new $P3925, "Undef"
  vivify_1927:
    defined $I3926, $P3925
    unless $I3926, for_undef_1928
    iter $P3923, $P3925
    new $P3956, 'ExceptionHandler'
    set_label $P3956, loop3955_handler
    $P3956."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3956
  loop3955_test:
    unless $P3923, loop3955_done
    shift $P3927, $P3923
  loop3955_redo:
    .const 'Sub' $P3929 = "479_1303340952.947" 
    capture_lex $P3929
    $P3929($P3927)
  loop3955_next:
    goto loop3955_test
  loop3955_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3957, exception, 'type'
    eq $P3957, .CONTROL_LOOP_NEXT, loop3955_next
    eq $P3957, .CONTROL_LOOP_REDO, loop3955_redo
  loop3955_done:
    pop_eh 
  for_undef_1928:
  if_3920_end:
.annotate 'line', 1290
    find_dynamic_lex $P3958, "$*PACKAGE-SETUP"
    unless_null $P3958, vivify_1936
    get_hll_global $P3958, "$PACKAGE-SETUP"
    unless_null $P3958, vivify_1937
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1937:
  vivify_1936:
    get_hll_global $P3959, ["PAST"], "Op"
.annotate 'line', 1292
    get_hll_global $P3960, ["PAST"], "Op"
.annotate 'line', 1295
    get_hll_global $P3961, ["PAST"], "Var"
    $P3962 = $P3961."new"("type_obj" :named("name"), "register" :named("scope"))
    $P3963 = $P3960."new"($P3962, "get_how PP" :named("pirop"))
.annotate 'line', 1297
    get_hll_global $P3964, ["PAST"], "Var"
    $P3965 = $P3964."new"("type_obj" :named("name"), "register" :named("scope"))
    $P3966 = $P3959."new"($P3963, $P3965, "callmethod" :named("pasttype"), "compose" :named("name"))
.annotate 'line', 1290
    $P3958."push"($P3966)
.annotate 'line', 1301
    find_lex $P3967, "$past"
    unless_null $P3967, vivify_1938
    new $P3967, "Undef"
  vivify_1938:
    $P3968 = $P3967."loadinit"()
    get_hll_global $P3969, ["PAST"], "Block"
    find_dynamic_lex $P3970, "$*PACKAGE-SETUP"
    unless_null $P3970, vivify_1939
    get_hll_global $P3970, "$PACKAGE-SETUP"
    unless_null $P3970, vivify_1940
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1940:
  vivify_1939:
    $P3971 = $P3969."new"($P3970, "immediate" :named("blocktype"))
    $P3968."push"($P3971)
.annotate 'line', 1303
    find_lex $P3972, "$/"
    find_lex $P3973, "$past"
    unless_null $P3973, vivify_1941
    new $P3973, "Undef"
  vivify_1941:
    $P3974 = $P3972."!make"($P3973)
.annotate 'line', 1182
    .return ($P3974)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3877"  :anon :subid("478_1303340952.947") :outer("477_1303340952.947")
.annotate 'line', 1245
    $P3879 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P3879
.annotate 'line', 1246
    new $P3880, "Undef"
    .lex "$name", $P3880
.annotate 'line', 1245
    find_lex $P3881, "$/"
    unless_null $P3881, vivify_1915
    $P3881 = root_new ['parrot';'Hash']
  vivify_1915:
    set $P3882, $P3881["parent"]
    unless_null $P3882, vivify_1916
    $P3882 = root_new ['parrot';'ResizablePMCArray']
  vivify_1916:
    set $P3883, $P3882[0]
    unless_null $P3883, vivify_1917
    $P3883 = root_new ['parrot';'Hash']
  vivify_1917:
    set $P3884, $P3883["identifier"]
    unless_null $P3884, vivify_1918
    new $P3884, "Undef"
  vivify_1918:
    clone $P3885, $P3884
    store_lex "@ns", $P3885
.annotate 'line', 1246
    find_lex $P3886, "@ns"
    unless_null $P3886, vivify_1919
    $P3886 = root_new ['parrot';'ResizablePMCArray']
  vivify_1919:
    $P3887 = $P3886."pop"()
    set $S3888, $P3887
    new $P3889, 'String'
    set $P3889, $S3888
    store_lex "$name", $P3889
.annotate 'line', 1247
    find_dynamic_lex $P3890, "$*PACKAGE-SETUP"
    unless_null $P3890, vivify_1920
    get_hll_global $P3890, "$PACKAGE-SETUP"
    unless_null $P3890, vivify_1921
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1921:
  vivify_1920:
    get_hll_global $P3891, ["PAST"], "Op"
.annotate 'line', 1249
    get_hll_global $P3892, ["PAST"], "Op"
.annotate 'line', 1252
    get_hll_global $P3893, ["PAST"], "Var"
    $P3894 = $P3893."new"("type_obj" :named("name"), "register" :named("scope"))
    $P3895 = $P3892."new"($P3894, "get_how PP" :named("pirop"))
.annotate 'line', 1254
    get_hll_global $P3896, ["PAST"], "Var"
    $P3897 = $P3896."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1255
    get_hll_global $P3898, ["PAST"], "Var"
    find_lex $P3899, "$name"
    unless_null $P3899, vivify_1922
    new $P3899, "Undef"
  vivify_1922:
    set $S3900, $P3899
    find_lex $P3901, "@ns"
    unless_null $P3901, vivify_1923
    $P3901 = root_new ['parrot';'ResizablePMCArray']
  vivify_1923:
    $P3902 = $P3898."new"($S3900 :named("name"), $P3901 :named("namespace"), "package" :named("scope"))
    $P3903 = $P3891."new"($P3895, $P3897, $P3902, "callmethod" :named("pasttype"), "add_parent" :named("name"))
.annotate 'line', 1247
    $P3904 = $P3890."push"($P3903)
.annotate 'line', 1244
    .return ($P3904)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3928"  :anon :subid("479_1303340952.947") :outer("477_1303340952.947")
    .param pmc param_3932
.annotate 'line', 1274
    $P3930 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P3930
.annotate 'line', 1275
    new $P3931, "Undef"
    .lex "$name", $P3931
    .lex "$_", param_3932
.annotate 'line', 1274
    find_lex $P3933, "$_"
    unless_null $P3933, vivify_1929
    $P3933 = root_new ['parrot';'Hash']
  vivify_1929:
    set $P3934, $P3933["identifier"]
    unless_null $P3934, vivify_1930
    new $P3934, "Undef"
  vivify_1930:
    clone $P3935, $P3934
    store_lex "@ns", $P3935
.annotate 'line', 1275
    find_lex $P3936, "@ns"
    unless_null $P3936, vivify_1931
    $P3936 = root_new ['parrot';'ResizablePMCArray']
  vivify_1931:
    $P3937 = $P3936."pop"()
    set $S3938, $P3937
    new $P3939, 'String'
    set $P3939, $S3938
    store_lex "$name", $P3939
.annotate 'line', 1276
    find_dynamic_lex $P3940, "$*PACKAGE-SETUP"
    unless_null $P3940, vivify_1932
    get_hll_global $P3940, "$PACKAGE-SETUP"
    unless_null $P3940, vivify_1933
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1933:
  vivify_1932:
    get_hll_global $P3941, ["PAST"], "Op"
.annotate 'line', 1278
    get_hll_global $P3942, ["PAST"], "Op"
.annotate 'line', 1281
    get_hll_global $P3943, ["PAST"], "Var"
    $P3944 = $P3943."new"("type_obj" :named("name"), "register" :named("scope"))
    $P3945 = $P3942."new"($P3944, "get_how PP" :named("pirop"))
.annotate 'line', 1283
    get_hll_global $P3946, ["PAST"], "Var"
    $P3947 = $P3946."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1284
    get_hll_global $P3948, ["PAST"], "Var"
    find_lex $P3949, "$name"
    unless_null $P3949, vivify_1934
    new $P3949, "Undef"
  vivify_1934:
    set $S3950, $P3949
    find_lex $P3951, "@ns"
    unless_null $P3951, vivify_1935
    $P3951 = root_new ['parrot';'ResizablePMCArray']
  vivify_1935:
    $P3952 = $P3948."new"($S3950 :named("name"), $P3951 :named("namespace"), "package" :named("scope"))
    $P3953 = $P3941."new"($P3945, $P3947, $P3952, "callmethod" :named("pasttype"), "add_role" :named("name"))
.annotate 'line', 1276
    $P3954 = $P3940."push"($P3953)
.annotate 'line', 1273
    .return ($P3954)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<my>"  :subid("480_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_3976
    .param pmc param_3977
.annotate 'line', 1306
    .lex "self", param_3976
    .lex "$/", param_3977
    find_lex $P3978, "$/"
    find_lex $P3979, "$/"
    unless_null $P3979, vivify_1942
    $P3979 = root_new ['parrot';'Hash']
  vivify_1942:
    set $P3980, $P3979["scoped"]
    unless_null $P3980, vivify_1943
    new $P3980, "Undef"
  vivify_1943:
    $P3981 = $P3980."ast"()
    $P3982 = $P3978."!make"($P3981)
    .return ($P3982)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<our>"  :subid("481_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_3984
    .param pmc param_3985
.annotate 'line', 1307
    .lex "self", param_3984
    .lex "$/", param_3985
    find_lex $P3986, "$/"
    find_lex $P3987, "$/"
    unless_null $P3987, vivify_1944
    $P3987 = root_new ['parrot';'Hash']
  vivify_1944:
    set $P3988, $P3987["scoped"]
    unless_null $P3988, vivify_1945
    new $P3988, "Undef"
  vivify_1945:
    $P3989 = $P3988."ast"()
    $P3990 = $P3986."!make"($P3989)
    .return ($P3990)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<has>"  :subid("482_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_3992
    .param pmc param_3993
.annotate 'line', 1308
    .lex "self", param_3992
    .lex "$/", param_3993
    find_lex $P3994, "$/"
    find_lex $P3995, "$/"
    unless_null $P3995, vivify_1946
    $P3995 = root_new ['parrot';'Hash']
  vivify_1946:
    set $P3996, $P3995["scoped"]
    unless_null $P3996, vivify_1947
    new $P3996, "Undef"
  vivify_1947:
    $P3997 = $P3996."ast"()
    $P3998 = $P3994."!make"($P3997)
    .return ($P3998)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scoped"  :subid("483_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_4000
    .param pmc param_4001
.annotate 'line', 1310
    .lex "self", param_4000
    .lex "$/", param_4001
.annotate 'line', 1311
    find_lex $P4002, "$/"
    find_lex $P4005, "$/"
    unless_null $P4005, vivify_1948
    $P4005 = root_new ['parrot';'Hash']
  vivify_1948:
    set $P4006, $P4005["declarator"]
    unless_null $P4006, vivify_1949
    new $P4006, "Undef"
  vivify_1949:
    if $P4006, if_4004
.annotate 'line', 1312
    find_lex $P4012, "$/"
    unless_null $P4012, vivify_1950
    $P4012 = root_new ['parrot';'Hash']
  vivify_1950:
    set $P4013, $P4012["multi_declarator"]
    unless_null $P4013, vivify_1951
    new $P4013, "Undef"
  vivify_1951:
    if $P4013, if_4011
.annotate 'line', 1313
    find_lex $P4017, "$/"
    unless_null $P4017, vivify_1952
    $P4017 = root_new ['parrot';'Hash']
  vivify_1952:
    set $P4018, $P4017["package_declarator"]
    unless_null $P4018, vivify_1953
    new $P4018, "Undef"
  vivify_1953:
    $P4019 = $P4018."ast"()
    set $P4010, $P4019
.annotate 'line', 1312
    goto if_4011_end
  if_4011:
    find_lex $P4014, "$/"
    unless_null $P4014, vivify_1954
    $P4014 = root_new ['parrot';'Hash']
  vivify_1954:
    set $P4015, $P4014["multi_declarator"]
    unless_null $P4015, vivify_1955
    new $P4015, "Undef"
  vivify_1955:
    $P4016 = $P4015."ast"()
    set $P4010, $P4016
  if_4011_end:
    set $P4003, $P4010
.annotate 'line', 1311
    goto if_4004_end
  if_4004:
    find_lex $P4007, "$/"
    unless_null $P4007, vivify_1956
    $P4007 = root_new ['parrot';'Hash']
  vivify_1956:
    set $P4008, $P4007["declarator"]
    unless_null $P4008, vivify_1957
    new $P4008, "Undef"
  vivify_1957:
    $P4009 = $P4008."ast"()
    set $P4003, $P4009
  if_4004_end:
    $P4020 = $P4002."!make"($P4003)
.annotate 'line', 1310
    .return ($P4020)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "declarator"  :subid("484_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_4022
    .param pmc param_4023
.annotate 'line', 1316
    .lex "self", param_4022
    .lex "$/", param_4023
.annotate 'line', 1317
    find_lex $P4024, "$/"
.annotate 'line', 1318
    find_lex $P4027, "$/"
    unless_null $P4027, vivify_1958
    $P4027 = root_new ['parrot';'Hash']
  vivify_1958:
    set $P4028, $P4027["routine_declarator"]
    unless_null $P4028, vivify_1959
    new $P4028, "Undef"
  vivify_1959:
    if $P4028, if_4026
.annotate 'line', 1319
    find_lex $P4032, "$/"
    unless_null $P4032, vivify_1960
    $P4032 = root_new ['parrot';'Hash']
  vivify_1960:
    set $P4033, $P4032["variable_declarator"]
    unless_null $P4033, vivify_1961
    new $P4033, "Undef"
  vivify_1961:
    $P4034 = $P4033."ast"()
    set $P4025, $P4034
.annotate 'line', 1318
    goto if_4026_end
  if_4026:
    find_lex $P4029, "$/"
    unless_null $P4029, vivify_1962
    $P4029 = root_new ['parrot';'Hash']
  vivify_1962:
    set $P4030, $P4029["routine_declarator"]
    unless_null $P4030, vivify_1963
    new $P4030, "Undef"
  vivify_1963:
    $P4031 = $P4030."ast"()
    set $P4025, $P4031
  if_4026_end:
    $P4035 = $P4024."!make"($P4025)
.annotate 'line', 1316
    .return ($P4035)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<multi>"  :subid("485_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_4037
    .param pmc param_4038
.annotate 'line', 1322
    .lex "self", param_4037
    .lex "$/", param_4038
    find_lex $P4039, "$/"
    find_lex $P4042, "$/"
    unless_null $P4042, vivify_1964
    $P4042 = root_new ['parrot';'Hash']
  vivify_1964:
    set $P4043, $P4042["declarator"]
    unless_null $P4043, vivify_1965
    new $P4043, "Undef"
  vivify_1965:
    if $P4043, if_4041
    find_lex $P4047, "$/"
    unless_null $P4047, vivify_1966
    $P4047 = root_new ['parrot';'Hash']
  vivify_1966:
    set $P4048, $P4047["routine_def"]
    unless_null $P4048, vivify_1967
    new $P4048, "Undef"
  vivify_1967:
    $P4049 = $P4048."ast"()
    set $P4040, $P4049
    goto if_4041_end
  if_4041:
    find_lex $P4044, "$/"
    unless_null $P4044, vivify_1968
    $P4044 = root_new ['parrot';'Hash']
  vivify_1968:
    set $P4045, $P4044["declarator"]
    unless_null $P4045, vivify_1969
    new $P4045, "Undef"
  vivify_1969:
    $P4046 = $P4045."ast"()
    set $P4040, $P4046
  if_4041_end:
    $P4050 = $P4039."!make"($P4040)
    .return ($P4050)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<proto>"  :subid("486_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_4052
    .param pmc param_4053
.annotate 'line', 1323
    .lex "self", param_4052
    .lex "$/", param_4053
    find_lex $P4054, "$/"
    find_lex $P4057, "$/"
    unless_null $P4057, vivify_1970
    $P4057 = root_new ['parrot';'Hash']
  vivify_1970:
    set $P4058, $P4057["declarator"]
    unless_null $P4058, vivify_1971
    new $P4058, "Undef"
  vivify_1971:
    if $P4058, if_4056
    find_lex $P4062, "$/"
    unless_null $P4062, vivify_1972
    $P4062 = root_new ['parrot';'Hash']
  vivify_1972:
    set $P4063, $P4062["routine_def"]
    unless_null $P4063, vivify_1973
    new $P4063, "Undef"
  vivify_1973:
    $P4064 = $P4063."ast"()
    set $P4055, $P4064
    goto if_4056_end
  if_4056:
    find_lex $P4059, "$/"
    unless_null $P4059, vivify_1974
    $P4059 = root_new ['parrot';'Hash']
  vivify_1974:
    set $P4060, $P4059["declarator"]
    unless_null $P4060, vivify_1975
    new $P4060, "Undef"
  vivify_1975:
    $P4061 = $P4060."ast"()
    set $P4055, $P4061
  if_4056_end:
    $P4065 = $P4054."!make"($P4055)
    .return ($P4065)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<null>"  :subid("487_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_4067
    .param pmc param_4068
.annotate 'line', 1324
    .lex "self", param_4067
    .lex "$/", param_4068
    find_lex $P4069, "$/"
    find_lex $P4070, "$/"
    unless_null $P4070, vivify_1976
    $P4070 = root_new ['parrot';'Hash']
  vivify_1976:
    set $P4071, $P4070["declarator"]
    unless_null $P4071, vivify_1977
    new $P4071, "Undef"
  vivify_1977:
    $P4072 = $P4071."ast"()
    $P4073 = $P4069."!make"($P4072)
    .return ($P4073)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "variable_declarator"  :subid("488_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_4075
    .param pmc param_4076
.annotate 'line', 1327
    .const 'Sub' $P4108 = "489_1303340952.947" 
    capture_lex $P4108
    .lex "self", param_4075
    .lex "$/", param_4076
.annotate 'line', 1328
    new $P4077, "Undef"
    .lex "$past", $P4077
.annotate 'line', 1329
    new $P4078, "Undef"
    .lex "$sigil", $P4078
.annotate 'line', 1330
    new $P4079, "Undef"
    .lex "$name", $P4079
.annotate 'line', 1331
    new $P4080, "Undef"
    .lex "$BLOCK", $P4080
.annotate 'line', 1328
    find_lex $P4081, "$/"
    unless_null $P4081, vivify_1978
    $P4081 = root_new ['parrot';'Hash']
  vivify_1978:
    set $P4082, $P4081["variable"]
    unless_null $P4082, vivify_1979
    new $P4082, "Undef"
  vivify_1979:
    $P4083 = $P4082."ast"()
    store_lex "$past", $P4083
.annotate 'line', 1329
    find_lex $P4084, "$/"
    unless_null $P4084, vivify_1980
    $P4084 = root_new ['parrot';'Hash']
  vivify_1980:
    set $P4085, $P4084["variable"]
    unless_null $P4085, vivify_1981
    $P4085 = root_new ['parrot';'Hash']
  vivify_1981:
    set $P4086, $P4085["sigil"]
    unless_null $P4086, vivify_1982
    new $P4086, "Undef"
  vivify_1982:
    store_lex "$sigil", $P4086
.annotate 'line', 1330
    find_lex $P4087, "$past"
    unless_null $P4087, vivify_1983
    new $P4087, "Undef"
  vivify_1983:
    $P4088 = $P4087."name"()
    store_lex "$name", $P4088
.annotate 'line', 1331
    find_lex $P4089, "$?PACKAGE"
    get_who $P4090, $P4089
    set $P4091, $P4090["@BLOCK"]
    unless_null $P4091, vivify_1984
    $P4091 = root_new ['parrot';'ResizablePMCArray']
  vivify_1984:
    set $P4092, $P4091[0]
    unless_null $P4092, vivify_1985
    new $P4092, "Undef"
  vivify_1985:
    store_lex "$BLOCK", $P4092
.annotate 'line', 1332
    find_lex $P4096, "$name"
    unless_null $P4096, vivify_1986
    new $P4096, "Undef"
  vivify_1986:
    if $P4096, if_4095
    set $P4094, $P4096
    goto if_4095_end
  if_4095:
    find_lex $P4097, "$BLOCK"
    unless_null $P4097, vivify_1987
    new $P4097, "Undef"
  vivify_1987:
    find_lex $P4098, "$name"
    unless_null $P4098, vivify_1988
    new $P4098, "Undef"
  vivify_1988:
    $P4099 = $P4097."symbol"($P4098)
    set $P4094, $P4099
  if_4095_end:
    unless $P4094, if_4093_end
.annotate 'line', 1333
    find_lex $P4100, "$/"
    unless_null $P4100, vivify_1989
    new $P4100, "Undef"
  vivify_1989:
    $P4101 = $P4100."CURSOR"()
    find_lex $P4102, "$name"
    unless_null $P4102, vivify_1990
    new $P4102, "Undef"
  vivify_1990:
    $P4101."panic"("Redeclaration of symbol ", $P4102)
  if_4093_end:
.annotate 'line', 1335
    find_dynamic_lex $P4104, "$*SCOPE"
    unless_null $P4104, vivify_1991
    get_hll_global $P4104, "$SCOPE"
    unless_null $P4104, vivify_1992
    die "Contextual $*SCOPE not found"
  vivify_1992:
  vivify_1991:
    set $S4105, $P4104
    iseq $I4106, $S4105, "has"
    if $I4106, if_4103
.annotate 'line', 1360
    find_dynamic_lex $P4153, "$*SCOPE"
    unless_null $P4153, vivify_1993
    get_hll_global $P4153, "$SCOPE"
    unless_null $P4153, vivify_1994
    die "Contextual $*SCOPE not found"
  vivify_1994:
  vivify_1993:
    set $S4154, $P4153
    iseq $I4155, $S4154, "our"
    if $I4155, if_4152
.annotate 'line', 1366
    find_lex $P4165, "$BLOCK"
    unless_null $P4165, vivify_1995
    $P4165 = root_new ['parrot';'ResizablePMCArray']
  vivify_1995:
    set $P4166, $P4165[0]
    unless_null $P4166, vivify_1996
    new $P4166, "Undef"
  vivify_1996:
    get_hll_global $P4167, ["PAST"], "Var"
    find_lex $P4168, "$name"
    unless_null $P4168, vivify_1997
    new $P4168, "Undef"
  vivify_1997:
.annotate 'line', 1368
    find_lex $P4169, "$sigil"
    unless_null $P4169, vivify_1998
    new $P4169, "Undef"
  vivify_1998:
    $P4170 = "vivitype"($P4169)
    find_lex $P4171, "$/"
    unless_null $P4171, vivify_1999
    new $P4171, "Undef"
  vivify_1999:
    $P4172 = $P4167."new"($P4168 :named("name"), "lexical" :named("scope"), 1 :named("isdecl"), 1 :named("lvalue"), $P4170 :named("viviself"), $P4171 :named("node"))
.annotate 'line', 1366
    $P4166."push"($P4172)
.annotate 'line', 1371
    find_lex $P4173, "$BLOCK"
    unless_null $P4173, vivify_2000
    new $P4173, "Undef"
  vivify_2000:
    find_lex $P4174, "$name"
    unless_null $P4174, vivify_2001
    new $P4174, "Undef"
  vivify_2001:
    $P4173."symbol"($P4174, "lexical" :named("scope"))
.annotate 'line', 1365
    goto if_4152_end
  if_4152:
.annotate 'line', 1361
    find_lex $P4156, "$name"
    unless_null $P4156, vivify_2002
    new $P4156, "Undef"
  vivify_2002:
    new $P4157, "ResizablePMCArray"
    push $P4157, $P4156
    find_lex $P4158, "$/"
    unless_null $P4158, vivify_2003
    new $P4158, "Undef"
  vivify_2003:
    $P4159 = "lexical_package_lookup"($P4157, $P4158)
    store_lex "$past", $P4159
.annotate 'line', 1362
    find_lex $P4160, "$past"
    unless_null $P4160, vivify_2004
    new $P4160, "Undef"
  vivify_2004:
    find_lex $P4161, "$sigil"
    unless_null $P4161, vivify_2005
    new $P4161, "Undef"
  vivify_2005:
    $P4162 = "vivitype"($P4161)
    $P4160."viviself"($P4162)
.annotate 'line', 1363
    find_lex $P4163, "$BLOCK"
    unless_null $P4163, vivify_2006
    new $P4163, "Undef"
  vivify_2006:
    find_lex $P4164, "$name"
    unless_null $P4164, vivify_2007
    new $P4164, "Undef"
  vivify_2007:
    $P4163."symbol"($P4164, "package" :named("scope"))
  if_4152_end:
.annotate 'line', 1360
    goto if_4103_end
  if_4103:
.annotate 'line', 1335
    .const 'Sub' $P4108 = "489_1303340952.947" 
    capture_lex $P4108
    $P4108()
  if_4103_end:
.annotate 'line', 1373
    find_lex $P4175, "$/"
    find_lex $P4176, "$past"
    unless_null $P4176, vivify_2029
    new $P4176, "Undef"
  vivify_2029:
    $P4177 = $P4175."!make"($P4176)
.annotate 'line', 1327
    .return ($P4177)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4107"  :anon :subid("489_1303340952.947") :outer("488_1303340952.947")
.annotate 'line', 1335
    .const 'Sub' $P4138 = "490_1303340952.947" 
    capture_lex $P4138
.annotate 'line', 1337
    new $P4109, "Undef"
    .lex "$meta-attr-type", $P4109
.annotate 'line', 1345
    new $P4110, "Undef"
    .lex "$meta_args", $P4110
.annotate 'line', 1337
    find_dynamic_lex $P4113, "$*PKGDECL"
    unless_null $P4113, vivify_2008
    get_hll_global $P4113, "$PKGDECL"
    unless_null $P4113, vivify_2009
    die "Contextual $*PKGDECL not found"
  vivify_2009:
  vivify_2008:
    find_dynamic_lex $P4114, "%*HOW-METAATTR"
    unless_null $P4114, vivify_2010
    get_hll_global $P4114, "%HOW-METAATTR"
    unless_null $P4114, vivify_2011
    die "Contextual %*HOW-METAATTR not found"
  vivify_2011:
  vivify_2010:
    set $P4115, $P4114[$P4113]
    unless_null $P4115, vivify_2012
    new $P4115, "Undef"
  vivify_2012:
    unless $P4115, unless_4112
    set $P4111, $P4115
    goto unless_4112_end
  unless_4112:
    find_dynamic_lex $P4116, "$*DEFAULT-METAATTR"
    unless_null $P4116, vivify_2013
    get_hll_global $P4116, "$DEFAULT-METAATTR"
    unless_null $P4116, vivify_2014
    die "Contextual $*DEFAULT-METAATTR not found"
  vivify_2014:
  vivify_2013:
    set $P4111, $P4116
  unless_4112_end:
    store_lex "$meta-attr-type", $P4111
.annotate 'line', 1338
    find_dynamic_lex $P4117, "$*PACKAGE-SETUP"
    unless_null $P4117, vivify_2015
    get_hll_global $P4117, "$PACKAGE-SETUP"
    unless_null $P4117, vivify_2016
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2016:
  vivify_2015:
    get_hll_global $P4118, ["PAST"], "Op"
.annotate 'line', 1340
    get_hll_global $P4119, ["PAST"], "Op"
.annotate 'line', 1342
    get_hll_global $P4120, ["PAST"], "Var"
    $P4121 = $P4120."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4122 = $P4119."new"($P4121, "get_how PP" :named("pirop"))
.annotate 'line', 1344
    get_hll_global $P4123, ["PAST"], "Var"
    $P4124 = $P4123."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1345
    get_hll_global $P4125, ["PAST"], "Op"
.annotate 'line', 1347
    get_hll_global $P4126, ["PAST"], "Var"
    find_lex $P4127, "$meta-attr-type"
    unless_null $P4127, vivify_2017
    new $P4127, "Undef"
  vivify_2017:
    $P4128 = $P4126."new"($P4127 :named("name"), "" :named("namespace"), "package" :named("scope"))
.annotate 'line', 1348
    get_hll_global $P4129, ["PAST"], "Val"
    find_lex $P4130, "$name"
    unless_null $P4130, vivify_2018
    new $P4130, "Undef"
  vivify_2018:
    $P4131 = $P4129."new"($P4130 :named("value"), "name" :named("named"))
    $P4132 = $P4125."new"($P4128, $P4131, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 1345
    store_lex "$meta_args", $P4132
    $P4133 = $P4118."new"($P4122, $P4124, $P4132, "callmethod" :named("pasttype"), "add_attribute" :named("name"))
.annotate 'line', 1338
    $P4117."push"($P4133)
.annotate 'line', 1351
    find_lex $P4135, "$/"
    unless_null $P4135, vivify_2019
    $P4135 = root_new ['parrot';'Hash']
  vivify_2019:
    set $P4136, $P4135["typename"]
    unless_null $P4136, vivify_2020
    new $P4136, "Undef"
  vivify_2020:
    unless $P4136, if_4134_end
    .const 'Sub' $P4138 = "490_1303340952.947" 
    capture_lex $P4138
    $P4138()
  if_4134_end:
.annotate 'line', 1357
    find_lex $P4148, "$BLOCK"
    unless_null $P4148, vivify_2027
    new $P4148, "Undef"
  vivify_2027:
    find_lex $P4149, "$name"
    unless_null $P4149, vivify_2028
    new $P4149, "Undef"
  vivify_2028:
    $P4148."symbol"($P4149, "attribute" :named("scope"))
.annotate 'line', 1358
    get_hll_global $P4150, ["PAST"], "Stmts"
    $P4151 = $P4150."new"()
    store_lex "$past", $P4151
.annotate 'line', 1335
    .return ($P4151)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4137"  :anon :subid("490_1303340952.947") :outer("489_1303340952.947")
.annotate 'line', 1352
    new $P4139, "Undef"
    .lex "$type", $P4139
    find_lex $P4140, "$/"
    unless_null $P4140, vivify_2021
    $P4140 = root_new ['parrot';'Hash']
  vivify_2021:
    set $P4141, $P4140["typename"]
    unless_null $P4141, vivify_2022
    $P4141 = root_new ['parrot';'ResizablePMCArray']
  vivify_2022:
    set $P4142, $P4141[0]
    unless_null $P4142, vivify_2023
    new $P4142, "Undef"
  vivify_2023:
    $P4143 = $P4142."ast"()
    store_lex "$type", $P4143
.annotate 'line', 1353
    find_lex $P4144, "$type"
    unless_null $P4144, vivify_2024
    new $P4144, "Undef"
  vivify_2024:
    $P4144."named"("type")
.annotate 'line', 1354
    find_lex $P4145, "$meta_args"
    unless_null $P4145, vivify_2025
    new $P4145, "Undef"
  vivify_2025:
    find_lex $P4146, "$type"
    unless_null $P4146, vivify_2026
    new $P4146, "Undef"
  vivify_2026:
    $P4147 = $P4145."push"($P4146)
.annotate 'line', 1351
    .return ($P4147)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<sub>"  :subid("491_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_4179
    .param pmc param_4180
.annotate 'line', 1376
    .lex "self", param_4179
    .lex "$/", param_4180
    find_lex $P4181, "$/"
    find_lex $P4182, "$/"
    unless_null $P4182, vivify_2030
    $P4182 = root_new ['parrot';'Hash']
  vivify_2030:
    set $P4183, $P4182["routine_def"]
    unless_null $P4183, vivify_2031
    new $P4183, "Undef"
  vivify_2031:
    $P4184 = $P4183."ast"()
    $P4185 = $P4181."!make"($P4184)
    .return ($P4185)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<method>"  :subid("492_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_4187
    .param pmc param_4188
.annotate 'line', 1377
    .lex "self", param_4187
    .lex "$/", param_4188
    find_lex $P4189, "$/"
    find_lex $P4190, "$/"
    unless_null $P4190, vivify_2032
    $P4190 = root_new ['parrot';'Hash']
  vivify_2032:
    set $P4191, $P4190["method_def"]
    unless_null $P4191, vivify_2033
    new $P4191, "Undef"
  vivify_2033:
    $P4192 = $P4191."ast"()
    $P4193 = $P4189."!make"($P4192)
    .return ($P4193)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "routine_def"  :subid("493_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_4195
    .param pmc param_4196
.annotate 'line', 1379
    .const 'Sub' $P4455 = "499_1303340952.947" 
    capture_lex $P4455
    .const 'Sub' $P4216 = "494_1303340952.947" 
    capture_lex $P4216
    .lex "self", param_4195
    .lex "$/", param_4196
.annotate 'line', 1382
    new $P4197, "Undef"
    .lex "$past", $P4197
.annotate 'line', 1393
    new $P4198, "Undef"
    .lex "$block", $P4198
.annotate 'line', 1379
    find_lex $P4199, "$past"
    unless_null $P4199, vivify_2034
    new $P4199, "Undef"
  vivify_2034:
.annotate 'line', 1383
    find_lex $P4201, "$/"
    unless_null $P4201, vivify_2035
    $P4201 = root_new ['parrot';'Hash']
  vivify_2035:
    set $P4202, $P4201["onlystar"]
    unless_null $P4202, vivify_2036
    new $P4202, "Undef"
  vivify_2036:
    if $P4202, if_4200
.annotate 'line', 1387
    find_lex $P4204, "$/"
    unless_null $P4204, vivify_2037
    $P4204 = root_new ['parrot';'Hash']
  vivify_2037:
    set $P4205, $P4204["blockoid"]
    unless_null $P4205, vivify_2038
    new $P4205, "Undef"
  vivify_2038:
    $P4206 = $P4205."ast"()
    store_lex "$past", $P4206
.annotate 'line', 1388
    find_lex $P4207, "$past"
    unless_null $P4207, vivify_2039
    new $P4207, "Undef"
  vivify_2039:
    $P4207."blocktype"("declaration")
.annotate 'line', 1389
    find_dynamic_lex $P4209, "$*RETURN_USED"
    unless_null $P4209, vivify_2040
    get_hll_global $P4209, "$RETURN_USED"
    unless_null $P4209, vivify_2041
    die "Contextual $*RETURN_USED not found"
  vivify_2041:
  vivify_2040:
    unless $P4209, if_4208_end
.annotate 'line', 1390
    find_lex $P4210, "$past"
    unless_null $P4210, vivify_2042
    new $P4210, "Undef"
  vivify_2042:
    $P4210."control"("return_pir")
  if_4208_end:
.annotate 'line', 1386
    goto if_4200_end
  if_4200:
.annotate 'line', 1384
    $P4203 = "only_star_block"()
    store_lex "$past", $P4203
  if_4200_end:
.annotate 'line', 1393
    find_lex $P4211, "$past"
    unless_null $P4211, vivify_2043
    new $P4211, "Undef"
  vivify_2043:
    store_lex "$block", $P4211
.annotate 'line', 1395
    find_lex $P4213, "$/"
    unless_null $P4213, vivify_2044
    $P4213 = root_new ['parrot';'Hash']
  vivify_2044:
    set $P4214, $P4213["deflongname"]
    unless_null $P4214, vivify_2045
    new $P4214, "Undef"
  vivify_2045:
    unless $P4214, if_4212_end
    .const 'Sub' $P4216 = "494_1303340952.947" 
    capture_lex $P4216
    $P4216()
  if_4212_end:
.annotate 'line', 1500
    find_lex $P4444, "$block"
    unless_null $P4444, vivify_2148
    new $P4444, "Undef"
  vivify_2148:
    find_lex $P4445, "$past"
    unless_null $P4445, vivify_2149
    $P4445 = root_new ['parrot';'Hash']
    store_lex "$past", $P4445
  vivify_2149:
    set $P4445["block_past"], $P4444
.annotate 'line', 1501
    find_lex $P4447, "$/"
    unless_null $P4447, vivify_2150
    $P4447 = root_new ['parrot';'Hash']
  vivify_2150:
    set $P4448, $P4447["trait"]
    unless_null $P4448, vivify_2151
    new $P4448, "Undef"
  vivify_2151:
    unless $P4448, if_4446_end
.annotate 'line', 1502
    find_lex $P4450, "$/"
    unless_null $P4450, vivify_2152
    $P4450 = root_new ['parrot';'Hash']
  vivify_2152:
    set $P4451, $P4450["trait"]
    unless_null $P4451, vivify_2153
    new $P4451, "Undef"
  vivify_2153:
    defined $I4452, $P4451
    unless $I4452, for_undef_2154
    iter $P4449, $P4451
    new $P4462, 'ExceptionHandler'
    set_label $P4462, loop4461_handler
    $P4462."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4462
  loop4461_test:
    unless $P4449, loop4461_done
    shift $P4453, $P4449
  loop4461_redo:
    .const 'Sub' $P4455 = "499_1303340952.947" 
    capture_lex $P4455
    $P4455($P4453)
  loop4461_next:
    goto loop4461_test
  loop4461_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4463, exception, 'type'
    eq $P4463, .CONTROL_LOOP_NEXT, loop4461_next
    eq $P4463, .CONTROL_LOOP_REDO, loop4461_redo
  loop4461_done:
    pop_eh 
  for_undef_2154:
  if_4446_end:
.annotate 'line', 1505
    find_lex $P4464, "$/"
    find_lex $P4465, "$past"
    unless_null $P4465, vivify_2157
    new $P4465, "Undef"
  vivify_2157:
    $P4466 = $P4464."!make"($P4465)
.annotate 'line', 1379
    .return ($P4466)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4215"  :anon :subid("494_1303340952.947") :outer("493_1303340952.947")
.annotate 'line', 1395
    .const 'Sub' $P4346 = "498_1303340952.947" 
    capture_lex $P4346
    .const 'Sub' $P4249 = "495_1303340952.947" 
    capture_lex $P4249
.annotate 'line', 1396
    new $P4217, "Undef"
    .lex "$name", $P4217
    find_lex $P4218, "$/"
    unless_null $P4218, vivify_2046
    $P4218 = root_new ['parrot';'Hash']
  vivify_2046:
    set $P4219, $P4218["sigil"]
    unless_null $P4219, vivify_2047
    $P4219 = root_new ['parrot';'ResizablePMCArray']
  vivify_2047:
    set $P4220, $P4219[0]
    unless_null $P4220, vivify_2048
    new $P4220, "Undef"
  vivify_2048:
    set $S4221, $P4220
    new $P4222, 'String'
    set $P4222, $S4221
    find_lex $P4223, "$/"
    unless_null $P4223, vivify_2049
    $P4223 = root_new ['parrot';'Hash']
  vivify_2049:
    set $P4224, $P4223["deflongname"]
    unless_null $P4224, vivify_2050
    $P4224 = root_new ['parrot';'ResizablePMCArray']
  vivify_2050:
    set $P4225, $P4224[0]
    unless_null $P4225, vivify_2051
    new $P4225, "Undef"
  vivify_2051:
    $S4226 = $P4225."ast"()
    concat $P4227, $P4222, $S4226
    store_lex "$name", $P4227
.annotate 'line', 1397
    find_lex $P4228, "$past"
    unless_null $P4228, vivify_2052
    new $P4228, "Undef"
  vivify_2052:
    find_lex $P4229, "$name"
    unless_null $P4229, vivify_2053
    new $P4229, "Undef"
  vivify_2053:
    $P4228."name"($P4229)
.annotate 'line', 1398
    find_dynamic_lex $P4235, "$*SCOPE"
    unless_null $P4235, vivify_2054
    get_hll_global $P4235, "$SCOPE"
    unless_null $P4235, vivify_2055
    die "Contextual $*SCOPE not found"
  vivify_2055:
  vivify_2054:
    set $S4236, $P4235
    iseq $I4237, $S4236, ""
    unless $I4237, unless_4234
    new $P4233, 'Integer'
    set $P4233, $I4237
    goto unless_4234_end
  unless_4234:
    find_dynamic_lex $P4238, "$*SCOPE"
    unless_null $P4238, vivify_2056
    get_hll_global $P4238, "$SCOPE"
    unless_null $P4238, vivify_2057
    die "Contextual $*SCOPE not found"
  vivify_2057:
  vivify_2056:
    set $S4239, $P4238
    iseq $I4240, $S4239, "my"
    new $P4233, 'Integer'
    set $P4233, $I4240
  unless_4234_end:
    unless $P4233, unless_4232
    set $P4231, $P4233
    goto unless_4232_end
  unless_4232:
    find_dynamic_lex $P4241, "$*SCOPE"
    unless_null $P4241, vivify_2058
    get_hll_global $P4241, "$SCOPE"
    unless_null $P4241, vivify_2059
    die "Contextual $*SCOPE not found"
  vivify_2059:
  vivify_2058:
    set $S4242, $P4241
    iseq $I4243, $S4242, "our"
    new $P4231, 'Integer'
    set $P4231, $I4243
  unless_4232_end:
    if $P4231, if_4230
.annotate 'line', 1490
    find_lex $P4429, "$/"
    unless_null $P4429, vivify_2060
    new $P4429, "Undef"
  vivify_2060:
    $P4430 = $P4429."CURSOR"()
    find_dynamic_lex $P4431, "$*SCOPE"
    unless_null $P4431, vivify_2061
    get_hll_global $P4431, "$SCOPE"
    unless_null $P4431, vivify_2062
    die "Contextual $*SCOPE not found"
  vivify_2062:
  vivify_2061:
    concat $P4432, $P4431, " scoped routines are not supported yet"
    $P4430."panic"($P4432)
.annotate 'line', 1489
    goto if_4230_end
  if_4230:
.annotate 'line', 1399
    find_dynamic_lex $P4245, "$*MULTINESS"
    unless_null $P4245, vivify_2063
    get_hll_global $P4245, "$MULTINESS"
    unless_null $P4245, vivify_2064
    die "Contextual $*MULTINESS not found"
  vivify_2064:
  vivify_2063:
    set $S4246, $P4245
    iseq $I4247, $S4246, "multi"
    if $I4247, if_4244
.annotate 'line', 1450
    find_dynamic_lex $P4342, "$*MULTINESS"
    unless_null $P4342, vivify_2065
    get_hll_global $P4342, "$MULTINESS"
    unless_null $P4342, vivify_2066
    die "Contextual $*MULTINESS not found"
  vivify_2066:
  vivify_2065:
    set $S4343, $P4342
    iseq $I4344, $S4343, "proto"
    if $I4344, if_4341
.annotate 'line', 1469
    find_lex $P4382, "$?PACKAGE"
    get_who $P4383, $P4382
    set $P4384, $P4383["@BLOCK"]
    unless_null $P4384, vivify_2067
    $P4384 = root_new ['parrot';'ResizablePMCArray']
  vivify_2067:
    set $P4385, $P4384[0]
    unless_null $P4385, vivify_2068
    $P4385 = root_new ['parrot';'ResizablePMCArray']
  vivify_2068:
    set $P4386, $P4385[0]
    unless_null $P4386, vivify_2069
    new $P4386, "Undef"
  vivify_2069:
    get_hll_global $P4387, ["PAST"], "Var"
    find_lex $P4388, "$name"
    unless_null $P4388, vivify_2070
    new $P4388, "Undef"
  vivify_2070:
    find_lex $P4389, "$past"
    unless_null $P4389, vivify_2071
    new $P4389, "Undef"
  vivify_2071:
    $P4390 = $P4387."new"($P4388 :named("name"), 1 :named("isdecl"), $P4389 :named("viviself"), "lexical" :named("scope"))
    $P4386."push"($P4390)
.annotate 'line', 1471
    find_lex $P4391, "$?PACKAGE"
    get_who $P4392, $P4391
    set $P4393, $P4392["@BLOCK"]
    unless_null $P4393, vivify_2072
    $P4393 = root_new ['parrot';'ResizablePMCArray']
  vivify_2072:
    set $P4394, $P4393[0]
    unless_null $P4394, vivify_2073
    new $P4394, "Undef"
  vivify_2073:
    find_lex $P4395, "$name"
    unless_null $P4395, vivify_2074
    new $P4395, "Undef"
  vivify_2074:
    $P4394."symbol"($P4395, "lexical" :named("scope"))
.annotate 'line', 1472
    find_dynamic_lex $P4397, "$*SCOPE"
    unless_null $P4397, vivify_2075
    get_hll_global $P4397, "$SCOPE"
    unless_null $P4397, vivify_2076
    die "Contextual $*SCOPE not found"
  vivify_2076:
  vivify_2075:
    set $S4398, $P4397
    iseq $I4399, $S4398, "our"
    unless $I4399, if_4396_end
.annotate 'line', 1475
    find_lex $P4400, "$?PACKAGE"
    get_who $P4401, $P4400
    set $P4402, $P4401["@BLOCK"]
    unless_null $P4402, vivify_2077
    $P4402 = root_new ['parrot';'ResizablePMCArray']
  vivify_2077:
    set $P4403, $P4402[0]
    unless_null $P4403, vivify_2078
    $P4403 = root_new ['parrot';'ResizablePMCArray']
  vivify_2078:
    set $P4404, $P4403[0]
    unless_null $P4404, vivify_2079
    new $P4404, "Undef"
  vivify_2079:
    get_hll_global $P4405, ["PAST"], "Op"
.annotate 'line', 1477
    get_hll_global $P4406, ["PAST"], "Var"
    find_lex $P4407, "$name"
    unless_null $P4407, vivify_2080
    new $P4407, "Undef"
  vivify_2080:
    $P4408 = $P4406."new"($P4407 :named("name"), "package" :named("scope"))
.annotate 'line', 1478
    get_hll_global $P4409, ["PAST"], "Var"
    find_lex $P4410, "$name"
    unless_null $P4410, vivify_2081
    new $P4410, "Undef"
  vivify_2081:
    $P4411 = $P4409."new"($P4410 :named("name"), "lexical" :named("scope"))
    $P4412 = $P4405."new"($P4408, $P4411, "bind" :named("pasttype"))
.annotate 'line', 1475
    $P4404."push"($P4412)
.annotate 'line', 1480
    find_lex $P4413, "$?PACKAGE"
    get_who $P4414, $P4413
    set $P4415, $P4414["@BLOCK"]
    unless_null $P4415, vivify_2082
    $P4415 = root_new ['parrot';'ResizablePMCArray']
  vivify_2082:
    set $P4416, $P4415[0]
    unless_null $P4416, vivify_2083
    new $P4416, "Undef"
  vivify_2083:
    $P4417 = $P4416."loadinit"()
    get_hll_global $P4418, ["PAST"], "Op"
.annotate 'line', 1482
    get_hll_global $P4419, ["PAST"], "Var"
    find_lex $P4420, "$name"
    unless_null $P4420, vivify_2084
    new $P4420, "Undef"
  vivify_2084:
    $P4421 = $P4419."new"($P4420 :named("name"), "package" :named("scope"))
.annotate 'line', 1483
    get_hll_global $P4422, ["PAST"], "Val"
    find_lex $P4423, "$past"
    unless_null $P4423, vivify_2085
    new $P4423, "Undef"
  vivify_2085:
    $P4424 = $P4422."new"($P4423 :named("value"))
    $P4425 = $P4418."new"($P4421, $P4424, "bind" :named("pasttype"))
.annotate 'line', 1480
    $P4417."push"($P4425)
  if_4396_end:
.annotate 'line', 1468
    goto if_4341_end
  if_4341:
.annotate 'line', 1450
    .const 'Sub' $P4346 = "498_1303340952.947" 
    capture_lex $P4346
    $P4346()
  if_4341_end:
    goto if_4244_end
  if_4244:
.annotate 'line', 1399
    .const 'Sub' $P4249 = "495_1303340952.947" 
    capture_lex $P4249
    $P4249()
  if_4244_end:
.annotate 'line', 1487
    get_hll_global $P4426, ["PAST"], "Var"
    find_lex $P4427, "$name"
    unless_null $P4427, vivify_2143
    new $P4427, "Undef"
  vivify_2143:
    $P4428 = $P4426."new"($P4427 :named("name"))
    store_lex "$past", $P4428
  if_4230_end:
.annotate 'line', 1494
    find_lex $P4437, "$name"
    unless_null $P4437, vivify_2144
    new $P4437, "Undef"
  vivify_2144:
    set $S4438, $P4437
    iseq $I4439, $S4438, "MAIN"
    if $I4439, if_4436
    new $P4435, 'Integer'
    set $P4435, $I4439
    goto if_4436_end
  if_4436:
    find_dynamic_lex $P4440, "$*MULTINESS"
    unless_null $P4440, vivify_2145
    get_hll_global $P4440, "$MULTINESS"
    unless_null $P4440, vivify_2146
    die "Contextual $*MULTINESS not found"
  vivify_2146:
  vivify_2145:
    set $S4441, $P4440
    isne $I4442, $S4441, "multi"
    new $P4435, 'Integer'
    set $P4435, $I4442
  if_4436_end:
    if $P4435, if_4434
    set $P4433, $P4435
    goto if_4434_end
  if_4434:
.annotate 'line', 1495
    find_lex $P4443, "$block"
    unless_null $P4443, vivify_2147
    new $P4443, "Undef"
  vivify_2147:
    store_dynamic_lex "$*MAIN_SUB", $P4443
.annotate 'line', 1494
    set $P4433, $P4443
  if_4434_end:
.annotate 'line', 1395
    .return ($P4433)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4345"  :anon :subid("498_1303340952.947") :outer("494_1303340952.947")
.annotate 'line', 1455
    new $P4347, "Undef"
    .lex "$cholder", $P4347
.annotate 'line', 1454
    find_dynamic_lex $P4349, "$*SCOPE"
    unless_null $P4349, vivify_2086
    get_hll_global $P4349, "$SCOPE"
    unless_null $P4349, vivify_2087
    die "Contextual $*SCOPE not found"
  vivify_2087:
  vivify_2086:
    set $S4350, $P4349
    iseq $I4351, $S4350, "our"
    unless $I4351, if_4348_end
    die "our-scoped protos not yet implemented"
  if_4348_end:
.annotate 'line', 1455
    get_hll_global $P4352, ["PAST"], "Op"
    $P4353 = $P4352."new"("list" :named("pasttype"))
    store_lex "$cholder", $P4353
.annotate 'line', 1456
    find_lex $P4354, "$?PACKAGE"
    get_who $P4355, $P4354
    set $P4356, $P4355["@BLOCK"]
    unless_null $P4356, vivify_2088
    $P4356 = root_new ['parrot';'ResizablePMCArray']
  vivify_2088:
    set $P4357, $P4356[0]
    unless_null $P4357, vivify_2089
    $P4357 = root_new ['parrot';'ResizablePMCArray']
  vivify_2089:
    set $P4358, $P4357[0]
    unless_null $P4358, vivify_2090
    new $P4358, "Undef"
  vivify_2090:
    get_hll_global $P4359, ["PAST"], "Var"
    find_lex $P4360, "$name"
    unless_null $P4360, vivify_2091
    new $P4360, "Undef"
  vivify_2091:
    find_lex $P4361, "$past"
    unless_null $P4361, vivify_2092
    new $P4361, "Undef"
  vivify_2092:
    $P4362 = $P4359."new"($P4360 :named("name"), 1 :named("isdecl"), $P4361 :named("viviself"), "lexical" :named("scope"))
    $P4358."push"($P4362)
.annotate 'line', 1458
    find_lex $P4363, "$?PACKAGE"
    get_who $P4364, $P4363
    set $P4365, $P4364["@BLOCK"]
    unless_null $P4365, vivify_2093
    $P4365 = root_new ['parrot';'ResizablePMCArray']
  vivify_2093:
    set $P4366, $P4365[0]
    unless_null $P4366, vivify_2094
    $P4366 = root_new ['parrot';'ResizablePMCArray']
  vivify_2094:
    set $P4367, $P4366[0]
    unless_null $P4367, vivify_2095
    new $P4367, "Undef"
  vivify_2095:
    get_hll_global $P4368, ["PAST"], "Op"
.annotate 'line', 1460
    get_hll_global $P4369, ["PAST"], "Var"
    find_lex $P4370, "$name"
    unless_null $P4370, vivify_2096
    new $P4370, "Undef"
  vivify_2096:
    $P4371 = $P4369."new"($P4370 :named("name"))
    find_lex $P4372, "$cholder"
    unless_null $P4372, vivify_2097
    new $P4372, "Undef"
  vivify_2097:
    $P4373 = $P4368."new"($P4371, $P4372, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 1458
    $P4367."push"($P4373)
.annotate 'line', 1463
    find_lex $P4374, "$?PACKAGE"
    get_who $P4375, $P4374
    set $P4376, $P4375["@BLOCK"]
    unless_null $P4376, vivify_2098
    $P4376 = root_new ['parrot';'ResizablePMCArray']
  vivify_2098:
    set $P4377, $P4376[0]
    unless_null $P4377, vivify_2099
    new $P4377, "Undef"
  vivify_2099:
    find_lex $P4378, "$name"
    unless_null $P4378, vivify_2100
    new $P4378, "Undef"
  vivify_2100:
    find_lex $P4379, "$cholder"
    unless_null $P4379, vivify_2101
    new $P4379, "Undef"
  vivify_2101:
    $P4377."symbol"($P4378, "lexical" :named("scope"), 1 :named("proto"), $P4379 :named("cholder"))
.annotate 'line', 1466
    find_lex $P4380, "$past"
    unless_null $P4380, vivify_2102
    new $P4380, "Undef"
  vivify_2102:
    $P4381 = $P4380."pirflags"(":instanceof(\"DispatcherSub\")")
.annotate 'line', 1450
    .return ($P4381)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4248"  :anon :subid("495_1303340952.947") :outer("494_1303340952.947")
.annotate 'line', 1399
    .const 'Sub' $P4269 = "496_1303340952.947" 
    capture_lex $P4269
.annotate 'line', 1402
    new $P4250, "Undef"
    .lex "$cholder", $P4250
.annotate 'line', 1403
    $P4251 = root_new ['parrot';'Hash']
    .lex "%sym", $P4251
.annotate 'line', 1401
    find_dynamic_lex $P4253, "$*SCOPE"
    unless_null $P4253, vivify_2103
    get_hll_global $P4253, "$SCOPE"
    unless_null $P4253, vivify_2104
    die "Contextual $*SCOPE not found"
  vivify_2104:
  vivify_2103:
    set $S4254, $P4253
    iseq $I4255, $S4254, "our"
    unless $I4255, if_4252_end
    die "our-scoped multis not yet implemented"
  if_4252_end:
    find_lex $P4256, "$cholder"
    unless_null $P4256, vivify_2105
    new $P4256, "Undef"
  vivify_2105:
.annotate 'line', 1403
    find_lex $P4257, "$?PACKAGE"
    get_who $P4258, $P4257
    set $P4259, $P4258["@BLOCK"]
    unless_null $P4259, vivify_2106
    $P4259 = root_new ['parrot';'ResizablePMCArray']
  vivify_2106:
    set $P4260, $P4259[0]
    unless_null $P4260, vivify_2107
    new $P4260, "Undef"
  vivify_2107:
    find_lex $P4261, "$name"
    unless_null $P4261, vivify_2108
    new $P4261, "Undef"
  vivify_2108:
    $P4262 = $P4260."symbol"($P4261)
    store_lex "%sym", $P4262
.annotate 'line', 1404
    find_lex $P4264, "%sym"
    unless_null $P4264, vivify_2109
    $P4264 = root_new ['parrot';'Hash']
  vivify_2109:
    set $P4265, $P4264["cholder"]
    unless_null $P4265, vivify_2110
    new $P4265, "Undef"
  vivify_2110:
    if $P4265, if_4263
.annotate 'line', 1409
    .const 'Sub' $P4269 = "496_1303340952.947" 
    capture_lex $P4269
    $P4269()
    goto if_4263_end
  if_4263:
.annotate 'line', 1405
    find_lex $P4266, "%sym"
    unless_null $P4266, vivify_2138
    $P4266 = root_new ['parrot';'Hash']
  vivify_2138:
    set $P4267, $P4266["cholder"]
    unless_null $P4267, vivify_2139
    new $P4267, "Undef"
  vivify_2139:
    store_lex "$cholder", $P4267
  if_4263_end:
.annotate 'line', 1445
    find_lex $P4337, "$cholder"
    unless_null $P4337, vivify_2140
    new $P4337, "Undef"
  vivify_2140:
    find_lex $P4338, "$past"
    unless_null $P4338, vivify_2141
    new $P4338, "Undef"
  vivify_2141:
    $P4337."push"($P4338)
.annotate 'line', 1448
    find_lex $P4339, "$past"
    unless_null $P4339, vivify_2142
    new $P4339, "Undef"
  vivify_2142:
    $P4340 = "attach_multi_signature"($P4339)
.annotate 'line', 1399
    .return ($P4340)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block4268"  :anon :subid("496_1303340952.947") :outer("495_1303340952.947")
.annotate 'line', 1409
    .const 'Sub' $P4285 = "497_1303340952.947" 
    capture_lex $P4285
.annotate 'line', 1416
    new $P4270, "Undef"
    .lex "$found_proto", $P4270
.annotate 'line', 1434
    new $P4271, "Undef"
    .lex "$dispatch_setup", $P4271
.annotate 'line', 1411
    find_lex $P4273, "%sym"
    unless_null $P4273, vivify_2111
    $P4273 = root_new ['parrot';'Hash']
  vivify_2111:
    set $P4274, $P4273["proto"]
    unless_null $P4274, vivify_2112
    new $P4274, "Undef"
  vivify_2112:
    unless $P4274, if_4272_end
.annotate 'line', 1414
    find_lex $P4275, "$/"
    unless_null $P4275, vivify_2113
    new $P4275, "Undef"
  vivify_2113:
    $P4276 = $P4275."CURSOR"()
    $P4276."panic"("Internal Error: Current scope has a proto, but no candidate list holder was set up. (This should never happen.)")
  if_4272_end:
.annotate 'line', 1411
    find_lex $P4277, "$found_proto"
    unless_null $P4277, vivify_2114
    new $P4277, "Undef"
  vivify_2114:
.annotate 'line', 1417
    find_lex $P4279, "$?PACKAGE"
    get_who $P4280, $P4279
    set $P4281, $P4280["@BLOCK"]
    unless_null $P4281, vivify_2115
    $P4281 = root_new ['parrot';'ResizablePMCArray']
  vivify_2115:
    defined $I4282, $P4281
    unless $I4282, for_undef_2116
    iter $P4278, $P4281
    new $P4307, 'ExceptionHandler'
    set_label $P4307, loop4306_handler
    $P4307."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4307
  loop4306_test:
    unless $P4278, loop4306_done
    shift $P4283, $P4278
  loop4306_redo:
    .const 'Sub' $P4285 = "497_1303340952.947" 
    capture_lex $P4285
    $P4285($P4283)
  loop4306_next:
    goto loop4306_test
  loop4306_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4308, exception, 'type'
    eq $P4308, .CONTROL_LOOP_NEXT, loop4306_next
    eq $P4308, .CONTROL_LOOP_REDO, loop4306_redo
  loop4306_done:
    pop_eh 
  for_undef_2116:
.annotate 'line', 1428
    find_lex $P4310, "$found_proto"
    unless_null $P4310, vivify_2125
    new $P4310, "Undef"
  vivify_2125:
    if $P4310, unless_4309_end
.annotate 'line', 1429
    find_lex $P4311, "$/"
    unless_null $P4311, vivify_2126
    new $P4311, "Undef"
  vivify_2126:
    $P4312 = $P4311."CURSOR"()
    $P4312."panic"("Sorry, no proto sub in scope, and auto-generation of protos is not yet implemented.")
  unless_4309_end:
.annotate 'line', 1433
    get_hll_global $P4313, ["PAST"], "Op"
    $P4314 = $P4313."new"("list" :named("pasttype"))
    store_lex "$cholder", $P4314
.annotate 'line', 1434
    get_hll_global $P4315, ["PAST"], "Op"
.annotate 'line', 1436
    get_hll_global $P4316, ["PAST"], "Var"
    find_lex $P4317, "$name"
    unless_null $P4317, vivify_2127
    new $P4317, "Undef"
  vivify_2127:
    $P4318 = $P4316."new"($P4317 :named("name"), "outer" :named("scope"))
    find_lex $P4319, "$cholder"
    unless_null $P4319, vivify_2128
    new $P4319, "Undef"
  vivify_2128:
    $P4320 = $P4315."new"($P4318, $P4319, "create_dispatch_and_add_candidates PPP" :named("pirop"))
.annotate 'line', 1434
    store_lex "$dispatch_setup", $P4320
.annotate 'line', 1439
    find_lex $P4321, "$?PACKAGE"
    get_who $P4322, $P4321
    set $P4323, $P4322["@BLOCK"]
    unless_null $P4323, vivify_2129
    $P4323 = root_new ['parrot';'ResizablePMCArray']
  vivify_2129:
    set $P4324, $P4323[0]
    unless_null $P4324, vivify_2130
    $P4324 = root_new ['parrot';'ResizablePMCArray']
  vivify_2130:
    set $P4325, $P4324[0]
    unless_null $P4325, vivify_2131
    new $P4325, "Undef"
  vivify_2131:
    get_hll_global $P4326, ["PAST"], "Var"
    find_lex $P4327, "$name"
    unless_null $P4327, vivify_2132
    new $P4327, "Undef"
  vivify_2132:
    find_lex $P4328, "$dispatch_setup"
    unless_null $P4328, vivify_2133
    new $P4328, "Undef"
  vivify_2133:
    $P4329 = $P4326."new"($P4327 :named("name"), 1 :named("isdecl"), $P4328 :named("viviself"), "lexical" :named("scope"))
    $P4325."push"($P4329)
.annotate 'line', 1441
    find_lex $P4330, "$?PACKAGE"
    get_who $P4331, $P4330
    set $P4332, $P4331["@BLOCK"]
    unless_null $P4332, vivify_2134
    $P4332 = root_new ['parrot';'ResizablePMCArray']
  vivify_2134:
    set $P4333, $P4332[0]
    unless_null $P4333, vivify_2135
    new $P4333, "Undef"
  vivify_2135:
    find_lex $P4334, "$name"
    unless_null $P4334, vivify_2136
    new $P4334, "Undef"
  vivify_2136:
    find_lex $P4335, "$cholder"
    unless_null $P4335, vivify_2137
    new $P4335, "Undef"
  vivify_2137:
    $P4336 = $P4333."symbol"($P4334, "lexical" :named("scope"), $P4335 :named("cholder"))
.annotate 'line', 1409
    .return ($P4336)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4284"  :anon :subid("497_1303340952.947") :outer("496_1303340952.947")
    .param pmc param_4287
.annotate 'line', 1418
    $P4286 = root_new ['parrot';'Hash']
    .lex "%sym", $P4286
    .lex "$_", param_4287
    find_lex $P4288, "$_"
    unless_null $P4288, vivify_2117
    new $P4288, "Undef"
  vivify_2117:
    find_lex $P4289, "$name"
    unless_null $P4289, vivify_2118
    new $P4289, "Undef"
  vivify_2118:
    $P4290 = $P4288."symbol"($P4289)
    store_lex "%sym", $P4290
.annotate 'line', 1419
    find_lex $P4295, "%sym"
    unless_null $P4295, vivify_2119
    $P4295 = root_new ['parrot';'Hash']
  vivify_2119:
    set $P4296, $P4295["proto"]
    unless_null $P4296, vivify_2120
    new $P4296, "Undef"
  vivify_2120:
    unless $P4296, unless_4294
    set $P4293, $P4296
    goto unless_4294_end
  unless_4294:
    find_lex $P4297, "%sym"
    unless_null $P4297, vivify_2121
    $P4297 = root_new ['parrot';'Hash']
  vivify_2121:
    set $P4298, $P4297["cholder"]
    unless_null $P4298, vivify_2122
    new $P4298, "Undef"
  vivify_2122:
    set $P4293, $P4298
  unless_4294_end:
    if $P4293, if_4292
.annotate 'line', 1422
    find_lex $P4302, "%sym"
    unless_null $P4302, vivify_2123
    $P4302 = root_new ['parrot';'Hash']
  vivify_2123:
    if $P4302, if_4301
    set $P4300, $P4302
    goto if_4301_end
  if_4301:
.annotate 'line', 1423
    find_lex $P4303, "$/"
    unless_null $P4303, vivify_2124
    new $P4303, "Undef"
  vivify_2124:
    $P4304 = $P4303."CURSOR"()
    $P4305 = $P4304."panic"("Cannot declare a multi when an only is already in scope.")
.annotate 'line', 1422
    set $P4300, $P4305
  if_4301_end:
    set $P4291, $P4300
.annotate 'line', 1419
    goto if_4292_end
  if_4292:
.annotate 'line', 1420
    new $P4299, "Integer"
    assign $P4299, 1
    store_lex "$found_proto", $P4299
.annotate 'line', 1419
    set $P4291, $P4299
  if_4292_end:
.annotate 'line', 1417
    .return ($P4291)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4454"  :anon :subid("499_1303340952.947") :outer("493_1303340952.947")
    .param pmc param_4456
.annotate 'line', 1502
    .lex "$_", param_4456
    find_lex $P4457, "$_"
    unless_null $P4457, vivify_2155
    new $P4457, "Undef"
  vivify_2155:
    $P4458 = $P4457."ast"()
    find_lex $P4459, "$/"
    unless_null $P4459, vivify_2156
    new $P4459, "Undef"
  vivify_2156:
    $P4460 = $P4458($P4459)
    .return ($P4460)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "method_def"  :subid("500_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_4468
    .param pmc param_4469
.annotate 'line', 1509
    .const 'Sub' $P4581 = "502_1303340952.947" 
    capture_lex $P4581
    .const 'Sub' $P4497 = "501_1303340952.947" 
    capture_lex $P4497
    .lex "self", param_4468
    .lex "$/", param_4469
.annotate 'line', 1512
    new $P4470, "Undef"
    .lex "$past", $P4470
.annotate 'line', 1509
    find_lex $P4471, "$past"
    unless_null $P4471, vivify_2158
    new $P4471, "Undef"
  vivify_2158:
.annotate 'line', 1513
    find_lex $P4473, "$/"
    unless_null $P4473, vivify_2159
    $P4473 = root_new ['parrot';'Hash']
  vivify_2159:
    set $P4474, $P4473["onlystar"]
    unless_null $P4474, vivify_2160
    new $P4474, "Undef"
  vivify_2160:
    if $P4474, if_4472
.annotate 'line', 1517
    find_lex $P4476, "$/"
    unless_null $P4476, vivify_2161
    $P4476 = root_new ['parrot';'Hash']
  vivify_2161:
    set $P4477, $P4476["blockoid"]
    unless_null $P4477, vivify_2162
    new $P4477, "Undef"
  vivify_2162:
    $P4478 = $P4477."ast"()
    store_lex "$past", $P4478
.annotate 'line', 1518
    find_lex $P4479, "$past"
    unless_null $P4479, vivify_2163
    new $P4479, "Undef"
  vivify_2163:
    $P4479."blocktype"("declaration")
.annotate 'line', 1519
    find_dynamic_lex $P4481, "$*RETURN_USED"
    unless_null $P4481, vivify_2164
    get_hll_global $P4481, "$RETURN_USED"
    unless_null $P4481, vivify_2165
    die "Contextual $*RETURN_USED not found"
  vivify_2165:
  vivify_2164:
    unless $P4481, if_4480_end
.annotate 'line', 1520
    find_lex $P4482, "$past"
    unless_null $P4482, vivify_2166
    new $P4482, "Undef"
  vivify_2166:
    $P4482."control"("return_pir")
  if_4480_end:
.annotate 'line', 1516
    goto if_4472_end
  if_4472:
.annotate 'line', 1514
    $P4475 = "only_star_block"()
    store_lex "$past", $P4475
  if_4472_end:
.annotate 'line', 1525
    find_lex $P4484, "$past"
    unless_null $P4484, vivify_2167
    $P4484 = root_new ['parrot';'Hash']
  vivify_2167:
    set $P4485, $P4484["signature_has_invocant"]
    unless_null $P4485, vivify_2168
    new $P4485, "Undef"
  vivify_2168:
    if $P4485, unless_4483_end
.annotate 'line', 1526
    find_lex $P4486, "$past"
    unless_null $P4486, vivify_2169
    $P4486 = root_new ['parrot';'ResizablePMCArray']
  vivify_2169:
    set $P4487, $P4486[0]
    unless_null $P4487, vivify_2170
    new $P4487, "Undef"
  vivify_2170:
    get_hll_global $P4488, ["PAST"], "Var"
.annotate 'line', 1528
    get_hll_global $P4489, ["PAST"], "Var"
    $P4490 = $P4489."new"("$?CLASS" :named("name"))
    $P4491 = $P4488."new"("self" :named("name"), "parameter" :named("scope"), $P4490 :named("multitype"))
.annotate 'line', 1526
    $P4487."unshift"($P4491)
  unless_4483_end:
.annotate 'line', 1531
    find_lex $P4492, "$past"
    unless_null $P4492, vivify_2171
    new $P4492, "Undef"
  vivify_2171:
    $P4492."symbol"("self", "lexical" :named("scope"))
.annotate 'line', 1534
    find_lex $P4494, "$/"
    unless_null $P4494, vivify_2172
    $P4494 = root_new ['parrot';'Hash']
  vivify_2172:
    set $P4495, $P4494["deflongname"]
    unless_null $P4495, vivify_2173
    new $P4495, "Undef"
  vivify_2173:
    unless $P4495, if_4493_end
    .const 'Sub' $P4497 = "501_1303340952.947" 
    capture_lex $P4497
    $P4497()
  if_4493_end:
.annotate 'line', 1569
    find_dynamic_lex $P4563, "$*SCOPE"
    unless_null $P4563, vivify_2199
    get_hll_global $P4563, "$SCOPE"
    unless_null $P4563, vivify_2200
    die "Contextual $*SCOPE not found"
  vivify_2200:
  vivify_2199:
    set $S4564, $P4563
    iseq $I4565, $S4564, "our"
    unless $I4565, if_4562_end
.annotate 'line', 1570
    find_lex $P4566, "$past"
    unless_null $P4566, vivify_2201
    new $P4566, "Undef"
  vivify_2201:
    $P4566."pirflags"(":nsentry")
  if_4562_end:
.annotate 'line', 1574
    find_lex $P4567, "$/"
    find_lex $P4568, "$past"
    unless_null $P4568, vivify_2202
    new $P4568, "Undef"
  vivify_2202:
    $P4567."!make"($P4568)
.annotate 'line', 1575
    find_lex $P4569, "$past"
    unless_null $P4569, vivify_2203
    new $P4569, "Undef"
  vivify_2203:
    find_lex $P4570, "$past"
    unless_null $P4570, vivify_2204
    $P4570 = root_new ['parrot';'Hash']
    store_lex "$past", $P4570
  vivify_2204:
    set $P4570["block_past"], $P4569
.annotate 'line', 1576
    find_lex $P4573, "$/"
    unless_null $P4573, vivify_2205
    $P4573 = root_new ['parrot';'Hash']
  vivify_2205:
    set $P4574, $P4573["trait"]
    unless_null $P4574, vivify_2206
    new $P4574, "Undef"
  vivify_2206:
    if $P4574, if_4572
    set $P4571, $P4574
    goto if_4572_end
  if_4572:
.annotate 'line', 1577
    find_lex $P4576, "$/"
    unless_null $P4576, vivify_2207
    $P4576 = root_new ['parrot';'Hash']
  vivify_2207:
    set $P4577, $P4576["trait"]
    unless_null $P4577, vivify_2208
    new $P4577, "Undef"
  vivify_2208:
    defined $I4578, $P4577
    unless $I4578, for_undef_2209
    iter $P4575, $P4577
    new $P4588, 'ExceptionHandler'
    set_label $P4588, loop4587_handler
    $P4588."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4588
  loop4587_test:
    unless $P4575, loop4587_done
    shift $P4579, $P4575
  loop4587_redo:
    .const 'Sub' $P4581 = "502_1303340952.947" 
    capture_lex $P4581
    $P4581($P4579)
  loop4587_next:
    goto loop4587_test
  loop4587_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4589, exception, 'type'
    eq $P4589, .CONTROL_LOOP_NEXT, loop4587_next
    eq $P4589, .CONTROL_LOOP_REDO, loop4587_redo
  loop4587_done:
    pop_eh 
  for_undef_2209:
.annotate 'line', 1576
    set $P4571, $P4575
  if_4572_end:
.annotate 'line', 1509
    .return ($P4571)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4496"  :anon :subid("501_1303340952.947") :outer("500_1303340952.947")
.annotate 'line', 1536
    new $P4498, "Undef"
    .lex "$name", $P4498
.annotate 'line', 1541
    new $P4499, "Undef"
    .lex "$to_add", $P4499
.annotate 'line', 1536
    find_lex $P4500, "$/"
    unless_null $P4500, vivify_2174
    $P4500 = root_new ['parrot';'Hash']
  vivify_2174:
    set $P4501, $P4500["private"]
    unless_null $P4501, vivify_2175
    new $P4501, "Undef"
  vivify_2175:
    set $S4502, $P4501
    new $P4503, 'String'
    set $P4503, $S4502
    find_lex $P4504, "$/"
    unless_null $P4504, vivify_2176
    $P4504 = root_new ['parrot';'Hash']
  vivify_2176:
    set $P4505, $P4504["deflongname"]
    unless_null $P4505, vivify_2177
    $P4505 = root_new ['parrot';'ResizablePMCArray']
  vivify_2177:
    set $P4506, $P4505[0]
    unless_null $P4506, vivify_2178
    new $P4506, "Undef"
  vivify_2178:
    $P4507 = $P4506."ast"()
    set $S4508, $P4507
    concat $P4509, $P4503, $S4508
    store_lex "$name", $P4509
.annotate 'line', 1537
    find_lex $P4510, "$past"
    unless_null $P4510, vivify_2179
    new $P4510, "Undef"
  vivify_2179:
    find_lex $P4511, "$name"
    unless_null $P4511, vivify_2180
    new $P4511, "Undef"
  vivify_2180:
    $P4510."name"($P4511)
.annotate 'line', 1541
    find_dynamic_lex $P4514, "$*MULTINESS"
    unless_null $P4514, vivify_2181
    get_hll_global $P4514, "$MULTINESS"
    unless_null $P4514, vivify_2182
    die "Contextual $*MULTINESS not found"
  vivify_2182:
  vivify_2181:
    set $S4515, $P4514
    isne $I4516, $S4515, "proto"
    if $I4516, if_4513
.annotate 'line', 1543
    get_hll_global $P4520, ["PAST"], "Op"
.annotate 'line', 1545
    get_hll_global $P4521, ["PAST"], "Val"
    find_lex $P4522, "$past"
    unless_null $P4522, vivify_2183
    new $P4522, "Undef"
  vivify_2183:
    $P4523 = $P4521."new"($P4522 :named("value"))
.annotate 'line', 1546
    get_hll_global $P4524, ["PAST"], "Op"
    $P4525 = $P4524."new"("list" :named("pasttype"))
    $P4526 = $P4520."new"($P4523, $P4525, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 1543
    set $P4512, $P4526
.annotate 'line', 1541
    goto if_4513_end
  if_4513:
.annotate 'line', 1542
    get_hll_global $P4517, ["PAST"], "Val"
    find_lex $P4518, "$past"
    unless_null $P4518, vivify_2184
    new $P4518, "Undef"
  vivify_2184:
    $P4519 = $P4517."new"($P4518 :named("value"))
    set $P4512, $P4519
  if_4513_end:
.annotate 'line', 1541
    store_lex "$to_add", $P4512
.annotate 'line', 1548
    find_dynamic_lex $P4528, "$*MULTINESS"
    unless_null $P4528, vivify_2185
    get_hll_global $P4528, "$MULTINESS"
    unless_null $P4528, vivify_2186
    die "Contextual $*MULTINESS not found"
  vivify_2186:
  vivify_2185:
    set $S4529, $P4528
    iseq $I4530, $S4529, "proto"
    unless $I4530, if_4527_end
    find_lex $P4531, "$past"
    unless_null $P4531, vivify_2187
    new $P4531, "Undef"
  vivify_2187:
    $P4531."pirflags"(":instanceof(\"DispatcherSub\")")
  if_4527_end:
.annotate 'line', 1552
    find_dynamic_lex $P4533, "$*MULTINESS"
    unless_null $P4533, vivify_2188
    get_hll_global $P4533, "$MULTINESS"
    unless_null $P4533, vivify_2189
    die "Contextual $*MULTINESS not found"
  vivify_2189:
  vivify_2188:
    set $S4534, $P4533
    iseq $I4535, $S4534, "multi"
    unless $I4535, if_4532_end
    find_lex $P4536, "$past"
    unless_null $P4536, vivify_2190
    new $P4536, "Undef"
  vivify_2190:
    "attach_multi_signature"($P4536)
  if_4532_end:
.annotate 'line', 1555
    find_dynamic_lex $P4539, "$*PACKAGE-SETUP"
    unless_null $P4539, vivify_2191
    get_hll_global $P4539, "$PACKAGE-SETUP"
    unless_null $P4539, vivify_2192
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2192:
  vivify_2191:
    defined $I4540, $P4539
    if $I4540, if_4538
    new $P4537, 'Integer'
    set $P4537, $I4540
    goto if_4538_end
  if_4538:
.annotate 'line', 1556
    find_dynamic_lex $P4541, "$*PACKAGE-SETUP"
    unless_null $P4541, vivify_2193
    get_hll_global $P4541, "$PACKAGE-SETUP"
    unless_null $P4541, vivify_2194
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2194:
  vivify_2193:
    get_hll_global $P4542, ["PAST"], "Op"
.annotate 'line', 1557
    find_dynamic_lex $P4545, "$*MULTINESS"
    unless_null $P4545, vivify_2195
    get_hll_global $P4545, "$MULTINESS"
    unless_null $P4545, vivify_2196
    die "Contextual $*MULTINESS not found"
  vivify_2196:
  vivify_2195:
    set $S4546, $P4545
    iseq $I4547, $S4546, "multi"
    if $I4547, if_4544
    new $P4549, "String"
    assign $P4549, "add_method"
    set $P4543, $P4549
    goto if_4544_end
  if_4544:
    new $P4548, "String"
    assign $P4548, "add_multi_method"
    set $P4543, $P4548
  if_4544_end:
.annotate 'line', 1558
    get_hll_global $P4550, ["PAST"], "Op"
.annotate 'line', 1561
    get_hll_global $P4551, ["PAST"], "Var"
    $P4552 = $P4551."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4553 = $P4550."new"($P4552, "get_how PP" :named("pirop"))
.annotate 'line', 1563
    get_hll_global $P4554, ["PAST"], "Var"
    $P4555 = $P4554."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1564
    get_hll_global $P4556, ["PAST"], "Val"
    find_lex $P4557, "$name"
    unless_null $P4557, vivify_2197
    new $P4557, "Undef"
  vivify_2197:
    $P4558 = $P4556."new"($P4557 :named("value"))
    find_lex $P4559, "$to_add"
    unless_null $P4559, vivify_2198
    new $P4559, "Undef"
  vivify_2198:
    $P4560 = $P4542."new"($P4553, $P4555, $P4558, $P4559, "callmethod" :named("pasttype"), $P4543 :named("name"))
.annotate 'line', 1556
    $P4561 = $P4541."push"($P4560)
.annotate 'line', 1555
    set $P4537, $P4561
  if_4538_end:
.annotate 'line', 1534
    .return ($P4537)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4580"  :anon :subid("502_1303340952.947") :outer("500_1303340952.947")
    .param pmc param_4582
.annotate 'line', 1577
    .lex "$_", param_4582
    find_lex $P4583, "$_"
    unless_null $P4583, vivify_2210
    new $P4583, "Undef"
  vivify_2210:
    $P4584 = $P4583."ast"()
    find_lex $P4585, "$/"
    unless_null $P4585, vivify_2211
    new $P4585, "Undef"
  vivify_2211:
    $P4586 = $P4584($P4585)
    .return ($P4586)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "signature"  :subid("503_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_4593
    .param pmc param_4594
.annotate 'line', 1609
    .const 'Sub' $P4631 = "505_1303340952.947" 
    capture_lex $P4631
    .const 'Sub' $P4605 = "504_1303340952.947" 
    capture_lex $P4605
    .lex "self", param_4593
    .lex "$/", param_4594
.annotate 'line', 1610
    new $P4595, "Undef"
    .lex "$BLOCKINIT", $P4595
    find_lex $P4596, "$?PACKAGE"
    get_who $P4597, $P4596
    set $P4598, $P4597["@BLOCK"]
    unless_null $P4598, vivify_2212
    $P4598 = root_new ['parrot';'ResizablePMCArray']
  vivify_2212:
    set $P4599, $P4598[0]
    unless_null $P4599, vivify_2213
    $P4599 = root_new ['parrot';'ResizablePMCArray']
  vivify_2213:
    set $P4600, $P4599[0]
    unless_null $P4600, vivify_2214
    new $P4600, "Undef"
  vivify_2214:
    store_lex "$BLOCKINIT", $P4600
.annotate 'line', 1611
    find_lex $P4602, "$/"
    unless_null $P4602, vivify_2215
    $P4602 = root_new ['parrot';'Hash']
  vivify_2215:
    set $P4603, $P4602["invocant"]
    unless_null $P4603, vivify_2216
    new $P4603, "Undef"
  vivify_2216:
    unless $P4603, if_4601_end
    .const 'Sub' $P4605 = "504_1303340952.947" 
    capture_lex $P4605
    $P4605()
  if_4601_end:
.annotate 'line', 1620
    find_lex $P4626, "$/"
    unless_null $P4626, vivify_2226
    $P4626 = root_new ['parrot';'Hash']
  vivify_2226:
    set $P4627, $P4626["parameter"]
    unless_null $P4627, vivify_2227
    new $P4627, "Undef"
  vivify_2227:
    defined $I4628, $P4627
    unless $I4628, for_undef_2228
    iter $P4625, $P4627
    new $P4638, 'ExceptionHandler'
    set_label $P4638, loop4637_handler
    $P4638."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4638
  loop4637_test:
    unless $P4625, loop4637_done
    shift $P4629, $P4625
  loop4637_redo:
    .const 'Sub' $P4631 = "505_1303340952.947" 
    capture_lex $P4631
    $P4631($P4629)
  loop4637_next:
    goto loop4637_test
  loop4637_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4639, exception, 'type'
    eq $P4639, .CONTROL_LOOP_NEXT, loop4637_next
    eq $P4639, .CONTROL_LOOP_REDO, loop4637_redo
  loop4637_done:
    pop_eh 
  for_undef_2228:
.annotate 'line', 1609
    .return ($P4625)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4604"  :anon :subid("504_1303340952.947") :outer("503_1303340952.947")
.annotate 'line', 1612
    new $P4606, "Undef"
    .lex "$inv", $P4606
    find_lex $P4607, "$/"
    unless_null $P4607, vivify_2217
    $P4607 = root_new ['parrot';'Hash']
  vivify_2217:
    set $P4608, $P4607["invocant"]
    unless_null $P4608, vivify_2218
    $P4608 = root_new ['parrot';'ResizablePMCArray']
  vivify_2218:
    set $P4609, $P4608[0]
    unless_null $P4609, vivify_2219
    new $P4609, "Undef"
  vivify_2219:
    $P4610 = $P4609."ast"()
    store_lex "$inv", $P4610
.annotate 'line', 1613
    find_lex $P4611, "$BLOCKINIT"
    unless_null $P4611, vivify_2220
    new $P4611, "Undef"
  vivify_2220:
    find_lex $P4612, "$inv"
    unless_null $P4612, vivify_2221
    new $P4612, "Undef"
  vivify_2221:
    $P4611."push"($P4612)
.annotate 'line', 1614
    find_lex $P4613, "$BLOCKINIT"
    unless_null $P4613, vivify_2222
    new $P4613, "Undef"
  vivify_2222:
    get_hll_global $P4614, ["PAST"], "Var"
.annotate 'line', 1616
    get_hll_global $P4615, ["PAST"], "Var"
    find_lex $P4616, "$inv"
    unless_null $P4616, vivify_2223
    new $P4616, "Undef"
  vivify_2223:
    $P4617 = $P4616."name"()
    $P4618 = $P4615."new"("lexical" :named("scope"), $P4617 :named("name"))
    $P4619 = $P4614."new"("self" :named("name"), "lexical" :named("scope"), 1 :named("isdecl"), $P4618 :named("viviself"))
.annotate 'line', 1614
    $P4613."push"($P4619)
.annotate 'line', 1618
    new $P4620, "Integer"
    assign $P4620, 1
    find_lex $P4621, "$?PACKAGE"
    get_who $P4622, $P4621
    set $P4623, $P4622["@BLOCK"]
    unless_null $P4623, vivify_2224
    $P4623 = root_new ['parrot';'ResizablePMCArray']
    set $P4622["@BLOCK"], $P4623
  vivify_2224:
    set $P4624, $P4623[0]
    unless_null $P4624, vivify_2225
    $P4624 = root_new ['parrot';'Hash']
    set $P4623[0], $P4624
  vivify_2225:
    set $P4624["signature_has_invocant"], $P4620
.annotate 'line', 1611
    .return ($P4620)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4630"  :anon :subid("505_1303340952.947") :outer("503_1303340952.947")
    .param pmc param_4632
.annotate 'line', 1620
    .lex "$_", param_4632
    find_lex $P4633, "$BLOCKINIT"
    unless_null $P4633, vivify_2229
    new $P4633, "Undef"
  vivify_2229:
    find_lex $P4634, "$_"
    unless_null $P4634, vivify_2230
    new $P4634, "Undef"
  vivify_2230:
    $P4635 = $P4634."ast"()
    $P4636 = $P4633."push"($P4635)
    .return ($P4636)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "parameter"  :subid("506_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_4641
    .param pmc param_4642
.annotate 'line', 1623
    .lex "self", param_4641
    .lex "$/", param_4642
.annotate 'line', 1624
    new $P4643, "Undef"
    .lex "$quant", $P4643
.annotate 'line', 1625
    new $P4644, "Undef"
    .lex "$past", $P4644
.annotate 'line', 1624
    find_lex $P4645, "$/"
    unless_null $P4645, vivify_2231
    $P4645 = root_new ['parrot';'Hash']
  vivify_2231:
    set $P4646, $P4645["quant"]
    unless_null $P4646, vivify_2232
    new $P4646, "Undef"
  vivify_2232:
    store_lex "$quant", $P4646
    find_lex $P4647, "$past"
    unless_null $P4647, vivify_2233
    new $P4647, "Undef"
  vivify_2233:
.annotate 'line', 1626
    find_lex $P4649, "$/"
    unless_null $P4649, vivify_2234
    $P4649 = root_new ['parrot';'Hash']
  vivify_2234:
    set $P4650, $P4649["named_param"]
    unless_null $P4650, vivify_2235
    new $P4650, "Undef"
  vivify_2235:
    if $P4650, if_4648
.annotate 'line', 1633
    find_lex $P4664, "$/"
    unless_null $P4664, vivify_2236
    $P4664 = root_new ['parrot';'Hash']
  vivify_2236:
    set $P4665, $P4664["param_var"]
    unless_null $P4665, vivify_2237
    new $P4665, "Undef"
  vivify_2237:
    $P4666 = $P4665."ast"()
    store_lex "$past", $P4666
.annotate 'line', 1634
    find_lex $P4668, "$quant"
    unless_null $P4668, vivify_2238
    new $P4668, "Undef"
  vivify_2238:
    set $S4669, $P4668
    iseq $I4670, $S4669, "*"
    if $I4670, if_4667
.annotate 'line', 1638
    find_lex $P4679, "$quant"
    unless_null $P4679, vivify_2239
    new $P4679, "Undef"
  vivify_2239:
    set $S4680, $P4679
    iseq $I4681, $S4680, "?"
    unless $I4681, if_4678_end
.annotate 'line', 1639
    find_lex $P4682, "$past"
    unless_null $P4682, vivify_2240
    new $P4682, "Undef"
  vivify_2240:
    find_lex $P4683, "$/"
    unless_null $P4683, vivify_2241
    $P4683 = root_new ['parrot';'Hash']
  vivify_2241:
    set $P4684, $P4683["param_var"]
    unless_null $P4684, vivify_2242
    $P4684 = root_new ['parrot';'Hash']
  vivify_2242:
    set $P4685, $P4684["sigil"]
    unless_null $P4685, vivify_2243
    new $P4685, "Undef"
  vivify_2243:
    $P4686 = "vivitype"($P4685)
    $P4682."viviself"($P4686)
  if_4678_end:
.annotate 'line', 1638
    goto if_4667_end
  if_4667:
.annotate 'line', 1635
    find_lex $P4671, "$past"
    unless_null $P4671, vivify_2244
    new $P4671, "Undef"
  vivify_2244:
    $P4671."slurpy"(1)
.annotate 'line', 1636
    find_lex $P4672, "$past"
    unless_null $P4672, vivify_2245
    new $P4672, "Undef"
  vivify_2245:
    find_lex $P4673, "$/"
    unless_null $P4673, vivify_2246
    $P4673 = root_new ['parrot';'Hash']
  vivify_2246:
    set $P4674, $P4673["param_var"]
    unless_null $P4674, vivify_2247
    $P4674 = root_new ['parrot';'Hash']
  vivify_2247:
    set $P4675, $P4674["sigil"]
    unless_null $P4675, vivify_2248
    new $P4675, "Undef"
  vivify_2248:
    set $S4676, $P4675
    iseq $I4677, $S4676, "%"
    $P4672."named"($I4677)
  if_4667_end:
.annotate 'line', 1632
    goto if_4648_end
  if_4648:
.annotate 'line', 1627
    find_lex $P4651, "$/"
    unless_null $P4651, vivify_2249
    $P4651 = root_new ['parrot';'Hash']
  vivify_2249:
    set $P4652, $P4651["named_param"]
    unless_null $P4652, vivify_2250
    new $P4652, "Undef"
  vivify_2250:
    $P4653 = $P4652."ast"()
    store_lex "$past", $P4653
.annotate 'line', 1628
    find_lex $P4655, "$quant"
    unless_null $P4655, vivify_2251
    new $P4655, "Undef"
  vivify_2251:
    set $S4656, $P4655
    isne $I4657, $S4656, "!"
    unless $I4657, if_4654_end
.annotate 'line', 1629
    find_lex $P4658, "$past"
    unless_null $P4658, vivify_2252
    new $P4658, "Undef"
  vivify_2252:
    find_lex $P4659, "$/"
    unless_null $P4659, vivify_2253
    $P4659 = root_new ['parrot';'Hash']
  vivify_2253:
    set $P4660, $P4659["named_param"]
    unless_null $P4660, vivify_2254
    $P4660 = root_new ['parrot';'Hash']
  vivify_2254:
    set $P4661, $P4660["param_var"]
    unless_null $P4661, vivify_2255
    $P4661 = root_new ['parrot';'Hash']
  vivify_2255:
    set $P4662, $P4661["sigil"]
    unless_null $P4662, vivify_2256
    new $P4662, "Undef"
  vivify_2256:
    $P4663 = "vivitype"($P4662)
    $P4658."viviself"($P4663)
  if_4654_end:
  if_4648_end:
.annotate 'line', 1642
    find_lex $P4688, "$/"
    unless_null $P4688, vivify_2257
    $P4688 = root_new ['parrot';'Hash']
  vivify_2257:
    set $P4689, $P4688["default_value"]
    unless_null $P4689, vivify_2258
    new $P4689, "Undef"
  vivify_2258:
    unless $P4689, if_4687_end
.annotate 'line', 1643
    find_lex $P4691, "$quant"
    unless_null $P4691, vivify_2259
    new $P4691, "Undef"
  vivify_2259:
    set $S4692, $P4691
    iseq $I4693, $S4692, "*"
    unless $I4693, if_4690_end
.annotate 'line', 1644
    find_lex $P4694, "$/"
    unless_null $P4694, vivify_2260
    new $P4694, "Undef"
  vivify_2260:
    $P4695 = $P4694."CURSOR"()
    $P4695."panic"("Can't put default on slurpy parameter")
  if_4690_end:
.annotate 'line', 1646
    find_lex $P4697, "$quant"
    unless_null $P4697, vivify_2261
    new $P4697, "Undef"
  vivify_2261:
    set $S4698, $P4697
    iseq $I4699, $S4698, "!"
    unless $I4699, if_4696_end
.annotate 'line', 1647
    find_lex $P4700, "$/"
    unless_null $P4700, vivify_2262
    new $P4700, "Undef"
  vivify_2262:
    $P4701 = $P4700."CURSOR"()
    $P4701."panic"("Can't put default on required parameter")
  if_4696_end:
.annotate 'line', 1649
    find_lex $P4702, "$past"
    unless_null $P4702, vivify_2263
    new $P4702, "Undef"
  vivify_2263:
    find_lex $P4703, "$/"
    unless_null $P4703, vivify_2264
    $P4703 = root_new ['parrot';'Hash']
  vivify_2264:
    set $P4704, $P4703["default_value"]
    unless_null $P4704, vivify_2265
    $P4704 = root_new ['parrot';'ResizablePMCArray']
  vivify_2265:
    set $P4705, $P4704[0]
    unless_null $P4705, vivify_2266
    $P4705 = root_new ['parrot';'Hash']
  vivify_2266:
    set $P4706, $P4705["EXPR"]
    unless_null $P4706, vivify_2267
    new $P4706, "Undef"
  vivify_2267:
    $P4707 = $P4706."ast"()
    $P4702."viviself"($P4707)
  if_4687_end:
.annotate 'line', 1651
    find_lex $P4709, "$past"
    unless_null $P4709, vivify_2268
    new $P4709, "Undef"
  vivify_2268:
    $P4710 = $P4709."viviself"()
    if $P4710, unless_4708_end
    find_lex $P4711, "$?PACKAGE"
    get_who $P4712, $P4711
    set $P4713, $P4712["@BLOCK"]
    unless_null $P4713, vivify_2269
    $P4713 = root_new ['parrot';'ResizablePMCArray']
  vivify_2269:
    set $P4714, $P4713[0]
    unless_null $P4714, vivify_2270
    new $P4714, "Undef"
  vivify_2270:
    find_lex $P4715, "$?PACKAGE"
    get_who $P4716, $P4715
    set $P4717, $P4716["@BLOCK"]
    unless_null $P4717, vivify_2271
    $P4717 = root_new ['parrot';'ResizablePMCArray']
  vivify_2271:
    set $P4718, $P4717[0]
    unless_null $P4718, vivify_2272
    new $P4718, "Undef"
  vivify_2272:
    $P4719 = $P4718."arity"()
    set $N4720, $P4719
    new $P4721, 'Float'
    set $P4721, $N4720
    add $P4722, $P4721, 1
    $P4714."arity"($P4722)
  unless_4708_end:
.annotate 'line', 1655
    find_lex $P4724, "$/"
    unless_null $P4724, vivify_2273
    $P4724 = root_new ['parrot';'Hash']
  vivify_2273:
    set $P4725, $P4724["typename"]
    unless_null $P4725, vivify_2274
    new $P4725, "Undef"
  vivify_2274:
    unless $P4725, if_4723_end
.annotate 'line', 1656
    find_lex $P4726, "$past"
    unless_null $P4726, vivify_2275
    new $P4726, "Undef"
  vivify_2275:
    find_lex $P4727, "$/"
    unless_null $P4727, vivify_2276
    $P4727 = root_new ['parrot';'Hash']
  vivify_2276:
    set $P4728, $P4727["typename"]
    unless_null $P4728, vivify_2277
    $P4728 = root_new ['parrot';'ResizablePMCArray']
  vivify_2277:
    set $P4729, $P4728[0]
    unless_null $P4729, vivify_2278
    new $P4729, "Undef"
  vivify_2278:
    $P4730 = $P4729."ast"()
    $P4726."multitype"($P4730)
  if_4723_end:
.annotate 'line', 1660
    find_lex $P4732, "$/"
    unless_null $P4732, vivify_2279
    $P4732 = root_new ['parrot';'Hash']
  vivify_2279:
    set $P4733, $P4732["definedness"]
    unless_null $P4733, vivify_2280
    new $P4733, "Undef"
  vivify_2280:
    unless $P4733, if_4731_end
.annotate 'line', 1661
    find_lex $P4734, "$/"
    unless_null $P4734, vivify_2281
    $P4734 = root_new ['parrot';'Hash']
  vivify_2281:
    set $P4735, $P4734["definedness"]
    unless_null $P4735, vivify_2282
    $P4735 = root_new ['parrot';'ResizablePMCArray']
  vivify_2282:
    set $P4736, $P4735[0]
    unless_null $P4736, vivify_2283
    new $P4736, "Undef"
  vivify_2283:
    set $S4737, $P4736
    new $P4738, 'String'
    set $P4738, $S4737
    find_lex $P4739, "$past"
    unless_null $P4739, vivify_2284
    $P4739 = root_new ['parrot';'Hash']
    store_lex "$past", $P4739
  vivify_2284:
    set $P4739["definedness"], $P4738
  if_4731_end:
.annotate 'line', 1664
    find_lex $P4740, "$/"
    find_lex $P4741, "$past"
    unless_null $P4741, vivify_2285
    new $P4741, "Undef"
  vivify_2285:
    $P4742 = $P4740."!make"($P4741)
.annotate 'line', 1623
    .return ($P4742)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "param_var"  :subid("507_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_4744
    .param pmc param_4745
.annotate 'line', 1667
    .lex "self", param_4744
    .lex "$/", param_4745
.annotate 'line', 1668
    new $P4746, "Undef"
    .lex "$name", $P4746
.annotate 'line', 1669
    new $P4747, "Undef"
    .lex "$past", $P4747
.annotate 'line', 1668
    find_lex $P4748, "$/"
    unless_null $P4748, vivify_2286
    new $P4748, "Undef"
  vivify_2286:
    set $S4749, $P4748
    new $P4750, 'String'
    set $P4750, $S4749
    store_lex "$name", $P4750
.annotate 'line', 1669
    get_hll_global $P4751, ["PAST"], "Var"
    find_lex $P4752, "$name"
    unless_null $P4752, vivify_2287
    new $P4752, "Undef"
  vivify_2287:
    find_lex $P4753, "$/"
    unless_null $P4753, vivify_2288
    new $P4753, "Undef"
  vivify_2288:
    $P4754 = $P4751."new"($P4752 :named("name"), "parameter" :named("scope"), 1 :named("isdecl"), $P4753 :named("node"))
    store_lex "$past", $P4754
.annotate 'line', 1671
    find_lex $P4755, "$?PACKAGE"
    get_who $P4756, $P4755
    set $P4757, $P4756["@BLOCK"]
    unless_null $P4757, vivify_2289
    $P4757 = root_new ['parrot';'ResizablePMCArray']
  vivify_2289:
    set $P4758, $P4757[0]
    unless_null $P4758, vivify_2290
    new $P4758, "Undef"
  vivify_2290:
    find_lex $P4759, "$name"
    unless_null $P4759, vivify_2291
    new $P4759, "Undef"
  vivify_2291:
    $P4758."symbol"($P4759, "lexical" :named("scope"))
.annotate 'line', 1672
    find_lex $P4760, "$/"
    find_lex $P4761, "$past"
    unless_null $P4761, vivify_2292
    new $P4761, "Undef"
  vivify_2292:
    $P4762 = $P4760."!make"($P4761)
.annotate 'line', 1667
    .return ($P4762)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "named_param"  :subid("508_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_4764
    .param pmc param_4765
.annotate 'line', 1675
    .lex "self", param_4764
    .lex "$/", param_4765
.annotate 'line', 1676
    new $P4766, "Undef"
    .lex "$past", $P4766
    find_lex $P4767, "$/"
    unless_null $P4767, vivify_2293
    $P4767 = root_new ['parrot';'Hash']
  vivify_2293:
    set $P4768, $P4767["param_var"]
    unless_null $P4768, vivify_2294
    new $P4768, "Undef"
  vivify_2294:
    $P4769 = $P4768."ast"()
    store_lex "$past", $P4769
.annotate 'line', 1677
    find_lex $P4770, "$past"
    unless_null $P4770, vivify_2295
    new $P4770, "Undef"
  vivify_2295:
    find_lex $P4771, "$/"
    unless_null $P4771, vivify_2296
    $P4771 = root_new ['parrot';'Hash']
  vivify_2296:
    set $P4772, $P4771["param_var"]
    unless_null $P4772, vivify_2297
    $P4772 = root_new ['parrot';'Hash']
  vivify_2297:
    set $P4773, $P4772["name"]
    unless_null $P4773, vivify_2298
    new $P4773, "Undef"
  vivify_2298:
    set $S4774, $P4773
    $P4770."named"($S4774)
.annotate 'line', 1678
    find_lex $P4775, "$/"
    find_lex $P4776, "$past"
    unless_null $P4776, vivify_2299
    new $P4776, "Undef"
  vivify_2299:
    $P4777 = $P4775."!make"($P4776)
.annotate 'line', 1675
    .return ($P4777)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "typename"  :subid("509_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_4779
    .param pmc param_4780
.annotate 'line', 1681
    .lex "self", param_4779
    .lex "$/", param_4780
.annotate 'line', 1682
    $P4781 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P4781
    get_hll_global $P4782, ["HLL"], "Compiler"
    find_lex $P4783, "$/"
    unless_null $P4783, vivify_2300
    new $P4783, "Undef"
  vivify_2300:
    set $S4784, $P4783
    $P4785 = $P4782."parse_name"($S4784)
    store_lex "@name", $P4785
.annotate 'line', 1683
    find_lex $P4786, "$/"
    get_hll_global $P4787, ["PAST"], "Var"
.annotate 'line', 1684
    find_lex $P4788, "@name"
    unless_null $P4788, vivify_2301
    $P4788 = root_new ['parrot';'ResizablePMCArray']
  vivify_2301:
    $P4789 = $P4788."pop"()
    find_lex $P4790, "@name"
    unless_null $P4790, vivify_2302
    $P4790 = root_new ['parrot';'ResizablePMCArray']
  vivify_2302:
    $P4791 = $P4787."new"($P4789 :named("name"), $P4790 :named("namespace"), "package" :named("scope"))
.annotate 'line', 1683
    $P4792 = $P4786."!make"($P4791)
.annotate 'line', 1681
    .return ($P4792)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait"  :subid("510_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_4794
    .param pmc param_4795
.annotate 'line', 1690
    .lex "self", param_4794
    .lex "$/", param_4795
.annotate 'line', 1691
    find_lex $P4796, "$/"
    find_lex $P4797, "$/"
    unless_null $P4797, vivify_2303
    $P4797 = root_new ['parrot';'Hash']
  vivify_2303:
    set $P4798, $P4797["trait_mod"]
    unless_null $P4798, vivify_2304
    new $P4798, "Undef"
  vivify_2304:
    $P4799 = $P4798."ast"()
    $P4800 = $P4796."!make"($P4799)
.annotate 'line', 1690
    .return ($P4800)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait_mod:sym<is>"  :subid("511_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_4802
    .param pmc param_4803
.annotate 'line', 1694
    .const 'Sub' $P4823 = "512_1303340952.947" 
    capture_lex $P4823
    .lex "self", param_4802
    .lex "$/", param_4803
.annotate 'line', 1695
    new $P4804, "Undef"
    .lex "$cpast", $P4804
    find_lex $P4805, "$/"
    unless_null $P4805, vivify_2305
    $P4805 = root_new ['parrot';'Hash']
  vivify_2305:
    set $P4806, $P4805["circumfix"]
    unless_null $P4806, vivify_2306
    $P4806 = root_new ['parrot';'ResizablePMCArray']
  vivify_2306:
    set $P4807, $P4806[0]
    unless_null $P4807, vivify_2307
    new $P4807, "Undef"
  vivify_2307:
    $P4808 = $P4807."ast"()
    store_lex "$cpast", $P4808
.annotate 'line', 1696
    find_lex $P4811, "$/"
    unless_null $P4811, vivify_2308
    $P4811 = root_new ['parrot';'Hash']
  vivify_2308:
    set $P4812, $P4811["longname"]
    unless_null $P4812, vivify_2309
    new $P4812, "Undef"
  vivify_2309:
    set $S4813, $P4812
    iseq $I4814, $S4813, "parrot_vtable"
    if $I4814, if_4810
.annotate 'line', 1716
    find_lex $P4849, "$/"
    unless_null $P4849, vivify_2310
    $P4849 = root_new ['parrot';'Hash']
  vivify_2310:
    set $P4850, $P4849["longname"]
    unless_null $P4850, vivify_2311
    new $P4850, "Undef"
  vivify_2311:
    set $S4851, $P4850
    iseq $I4852, $S4851, "pirflags"
    if $I4852, if_4848
.annotate 'line', 1720
    find_lex $P4856, "$/"
    unless_null $P4856, vivify_2312
    new $P4856, "Undef"
  vivify_2312:
    $P4857 = $P4856."CURSOR"()
    new $P4858, 'String'
    set $P4858, "Trait '"
    find_lex $P4859, "$/"
    unless_null $P4859, vivify_2313
    $P4859 = root_new ['parrot';'Hash']
  vivify_2313:
    set $P4860, $P4859["longname"]
    unless_null $P4860, vivify_2314
    new $P4860, "Undef"
  vivify_2314:
    concat $P4861, $P4858, $P4860
    concat $P4862, $P4861, "' not implemented"
    $P4863 = $P4857."panic"($P4862)
.annotate 'line', 1719
    set $P4847, $P4863
.annotate 'line', 1716
    goto if_4848_end
  if_4848:
.annotate 'line', 1717
    find_lex $P4853, "$/"
    unless_null $P4853, vivify_2315
    new $P4853, "Undef"
  vivify_2315:
    $P4854 = $P4853."CURSOR"()
    $P4855 = $P4854."panic"("Trait 'pirflags' no longer supported; use 'is vtable'")
.annotate 'line', 1716
    set $P4847, $P4855
  if_4848_end:
    set $P4809, $P4847
.annotate 'line', 1696
    goto if_4810_end
  if_4810:
.annotate 'line', 1699
    get_hll_global $P4816, ["PAST"], "Val"
    find_lex $P4817, "$cpast"
    unless_null $P4817, vivify_2316
    new $P4817, "Undef"
  vivify_2316:
    $P4818 = $P4816."ACCEPTS"($P4817)
    if $P4818, unless_4815_end
.annotate 'line', 1698
    find_lex $P4819, "$/"
    unless_null $P4819, vivify_2317
    new $P4819, "Undef"
  vivify_2317:
    $P4820 = $P4819."CURSOR"()
    $P4820."panic"("Trait 'parrot_vtable' requires constant scalar argument")
  unless_4815_end:
.annotate 'line', 1700
    find_lex $P4821, "$/"
    .const 'Sub' $P4823 = "512_1303340952.947" 
    newclosure $P4845, $P4823
    $P4846 = $P4821."!make"($P4845)
.annotate 'line', 1696
    set $P4809, $P4846
  if_4810_end:
.annotate 'line', 1694
    .return ($P4809)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4822"  :anon :subid("512_1303340952.947") :outer("511_1303340952.947")
    .param pmc param_4824
.annotate 'line', 1700
    .lex "$match", param_4824
.annotate 'line', 1701
    new $P4825, "Undef"
    .lex "$meth", $P4825
    find_lex $P4826, "$match"
    unless_null $P4826, vivify_2318
    new $P4826, "Undef"
  vivify_2318:
    $P4827 = $P4826."ast"()
    set $P4828, $P4827["block_past"]
    unless_null $P4828, vivify_2319
    new $P4828, "Undef"
  vivify_2319:
    store_lex "$meth", $P4828
.annotate 'line', 1702
    find_dynamic_lex $P4831, "$*PACKAGE-SETUP"
    unless_null $P4831, vivify_2320
    get_hll_global $P4831, "$PACKAGE-SETUP"
    unless_null $P4831, vivify_2321
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2321:
  vivify_2320:
    defined $I4832, $P4831
    if $I4832, if_4830
    new $P4829, 'Integer'
    set $P4829, $I4832
    goto if_4830_end
  if_4830:
.annotate 'line', 1703
    find_dynamic_lex $P4833, "$*PACKAGE-SETUP"
    unless_null $P4833, vivify_2322
    get_hll_global $P4833, "$PACKAGE-SETUP"
    unless_null $P4833, vivify_2323
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2323:
  vivify_2322:
    get_hll_global $P4834, ["PAST"], "Op"
.annotate 'line', 1705
    get_hll_global $P4835, ["PAST"], "Op"
.annotate 'line', 1708
    get_hll_global $P4836, ["PAST"], "Var"
    $P4837 = $P4836."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4838 = $P4835."new"($P4837, "get_how PP" :named("pirop"))
.annotate 'line', 1710
    get_hll_global $P4839, ["PAST"], "Var"
    $P4840 = $P4839."new"("type_obj" :named("name"), "register" :named("scope"))
    find_lex $P4841, "$cpast"
    unless_null $P4841, vivify_2324
    new $P4841, "Undef"
  vivify_2324:
    find_lex $P4842, "$meth"
    unless_null $P4842, vivify_2325
    new $P4842, "Undef"
  vivify_2325:
    $P4843 = $P4834."new"($P4838, $P4840, $P4841, $P4842, "callmethod" :named("pasttype"), "add_parrot_vtable_mapping" :named("name"))
.annotate 'line', 1703
    $P4844 = $P4833."push"($P4843)
.annotate 'line', 1702
    set $P4829, $P4844
  if_4830_end:
.annotate 'line', 1700
    .return ($P4829)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "regex_declarator"  :subid("513_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_4867
    .param pmc param_4868
    .param pmc param_4869 :optional
    .param int has_param_4869 :opt_flag
.annotate 'line', 1724
    .const 'Sub' $P4976 = "516_1303340952.947" 
    capture_lex $P4976
    .const 'Sub' $P4941 = "515_1303340952.947" 
    capture_lex $P4941
    .const 'Sub' $P4914 = "514_1303340952.947" 
    capture_lex $P4914
    new $P4866, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P4866, control_4865
    push_eh $P4866
    .lex "self", param_4867
    .lex "$/", param_4868
    if has_param_4869, optparam_2326
    new $P4870, "Undef"
    set param_4869, $P4870
  optparam_2326:
    .lex "$key", param_4869
.annotate 'line', 1725
    $P4871 = root_new ['parrot';'ResizablePMCArray']
    .lex "@MODIFIERS", $P4871
.annotate 'line', 1726
    new $P4872, "Undef"
    .lex "$name", $P4872
.annotate 'line', 1727
    new $P4873, "Undef"
    .lex "$past", $P4873
.annotate 'line', 1725
    get_hll_global $P4874, ["Regex";"P6Regex"], "Actions"
    get_who $P4875, $P4874
    set $P4876, $P4875["@MODIFIERS"]
    unless_null $P4876, vivify_2327
    $P4876 = root_new ['parrot';'ResizablePMCArray']
  vivify_2327:
    store_lex "@MODIFIERS", $P4876
.annotate 'line', 1726
    find_lex $P4877, "$/"
    unless_null $P4877, vivify_2328
    $P4877 = root_new ['parrot';'Hash']
  vivify_2328:
    set $P4878, $P4877["deflongname"]
    unless_null $P4878, vivify_2329
    new $P4878, "Undef"
  vivify_2329:
    $P4879 = $P4878."ast"()
    set $S4880, $P4879
    new $P4881, 'String'
    set $P4881, $S4880
    store_lex "$name", $P4881
    find_lex $P4882, "$past"
    unless_null $P4882, vivify_2330
    new $P4882, "Undef"
  vivify_2330:
.annotate 'line', 1728
    find_lex $P4884, "$/"
    unless_null $P4884, vivify_2331
    $P4884 = root_new ['parrot';'Hash']
  vivify_2331:
    set $P4885, $P4884["proto"]
    unless_null $P4885, vivify_2332
    new $P4885, "Undef"
  vivify_2332:
    if $P4885, if_4883
.annotate 'line', 1767
    find_lex $P4937, "$key"
    unless_null $P4937, vivify_2333
    new $P4937, "Undef"
  vivify_2333:
    set $S4938, $P4937
    iseq $I4939, $S4938, "open"
    if $I4939, if_4936
.annotate 'line', 1777
    .const 'Sub' $P4976 = "516_1303340952.947" 
    capture_lex $P4976
    $P4976()
    goto if_4936_end
  if_4936:
.annotate 'line', 1767
    .const 'Sub' $P4941 = "515_1303340952.947" 
    capture_lex $P4941
    $P4941()
  if_4936_end:
    goto if_4883_end
  if_4883:
.annotate 'line', 1730
    get_hll_global $P4886, ["PAST"], "Stmts"
.annotate 'line', 1731
    get_hll_global $P4887, ["PAST"], "Block"
    find_lex $P4888, "$name"
    unless_null $P4888, vivify_2368
    new $P4888, "Undef"
  vivify_2368:
.annotate 'line', 1732
    get_hll_global $P4889, ["PAST"], "Op"
.annotate 'line', 1733
    get_hll_global $P4890, ["PAST"], "Var"
    $P4891 = $P4890."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P4892, "$name"
    unless_null $P4892, vivify_2369
    new $P4892, "Undef"
  vivify_2369:
    $P4893 = $P4889."new"($P4891, $P4892, "!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 1732
    find_lex $P4894, "$/"
    unless_null $P4894, vivify_2370
    new $P4894, "Undef"
  vivify_2370:
    $P4895 = $P4887."new"($P4893, $P4888 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P4894 :named("node"))
.annotate 'line', 1742
    get_hll_global $P4896, ["PAST"], "Block"
    new $P4897, "String"
    assign $P4897, "!PREFIX__"
    find_lex $P4898, "$name"
    unless_null $P4898, vivify_2371
    new $P4898, "Undef"
  vivify_2371:
    concat $P4899, $P4897, $P4898
.annotate 'line', 1743
    get_hll_global $P4900, ["PAST"], "Op"
.annotate 'line', 1744
    get_hll_global $P4901, ["PAST"], "Var"
    $P4902 = $P4901."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P4903, "$name"
    unless_null $P4903, vivify_2372
    new $P4903, "Undef"
  vivify_2372:
    $P4904 = $P4900."new"($P4902, $P4903, "!PREFIX__!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 1743
    find_lex $P4905, "$/"
    unless_null $P4905, vivify_2373
    new $P4905, "Undef"
  vivify_2373:
    $P4906 = $P4896."new"($P4904, $P4899 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P4905 :named("node"))
.annotate 'line', 1742
    $P4907 = $P4886."new"($P4895, $P4906)
.annotate 'line', 1730
    store_lex "$past", $P4907
.annotate 'line', 1754
    find_lex $P4909, "$past"
    unless_null $P4909, vivify_2374
    new $P4909, "Undef"
  vivify_2374:
    $P4910 = $P4909."list"()
    defined $I4911, $P4910
    unless $I4911, for_undef_2375
    iter $P4908, $P4910
    new $P4934, 'ExceptionHandler'
    set_label $P4934, loop4933_handler
    $P4934."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4934
  loop4933_test:
    unless $P4908, loop4933_done
    shift $P4912, $P4908
  loop4933_redo:
    .const 'Sub' $P4914 = "514_1303340952.947" 
    capture_lex $P4914
    $P4914($P4912)
  loop4933_next:
    goto loop4933_test
  loop4933_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4935, exception, 'type'
    eq $P4935, .CONTROL_LOOP_NEXT, loop4933_next
    eq $P4935, .CONTROL_LOOP_REDO, loop4933_redo
  loop4933_done:
    pop_eh 
  for_undef_2375:
  if_4883_end:
.annotate 'line', 1813
    find_lex $P5036, "$/"
    find_lex $P5037, "$past"
    unless_null $P5037, vivify_2380
    new $P5037, "Undef"
  vivify_2380:
    $P5038 = $P5036."!make"($P5037)
.annotate 'line', 1724
    .return ($P5038)
  control_4865:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5039, exception, "payload"
    .return ($P5039)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4975"  :anon :subid("516_1303340952.947") :outer("513_1303340952.947")
.annotate 'line', 1778
    new $P4977, "Undef"
    .lex "$regex", $P4977
.annotate 'line', 1779
    get_hll_global $P4978, ["Regex";"P6Regex";"Actions"], "buildsub"
    find_lex $P4979, "$/"
    unless_null $P4979, vivify_2334
    $P4979 = root_new ['parrot';'Hash']
  vivify_2334:
    set $P4980, $P4979["p6regex"]
    unless_null $P4980, vivify_2335
    new $P4980, "Undef"
  vivify_2335:
    $P4981 = $P4980."ast"()
    find_lex $P4982, "$?PACKAGE"
    get_who $P4983, $P4982
    set $P4984, $P4983["@BLOCK"]
    unless_null $P4984, vivify_2336
    $P4984 = root_new ['parrot';'ResizablePMCArray']
  vivify_2336:
    $P4985 = $P4984."shift"()
    $P4986 = $P4978($P4981, $P4985)
    store_lex "$regex", $P4986
.annotate 'line', 1780
    find_lex $P4987, "$regex"
    unless_null $P4987, vivify_2337
    new $P4987, "Undef"
  vivify_2337:
    find_lex $P4988, "$name"
    unless_null $P4988, vivify_2338
    new $P4988, "Undef"
  vivify_2338:
    $P4987."name"($P4988)
.annotate 'line', 1782
    get_hll_global $P4989, ["PAST"], "Op"
.annotate 'line', 1784
    get_hll_global $P4990, ["PAST"], "Var"
    new $P4991, "ResizablePMCArray"
    push $P4991, "Regex"
    $P4992 = $P4990."new"("Method" :named("name"), $P4991 :named("namespace"), "package" :named("scope"))
    find_lex $P4993, "$regex"
    unless_null $P4993, vivify_2339
    new $P4993, "Undef"
  vivify_2339:
    $P4994 = $P4989."new"($P4992, $P4993, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 1782
    store_lex "$past", $P4994
.annotate 'line', 1787
    find_dynamic_lex $P4996, "$*PACKAGE-SETUP"
    unless_null $P4996, vivify_2340
    get_hll_global $P4996, "$PACKAGE-SETUP"
    unless_null $P4996, vivify_2341
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2341:
  vivify_2340:
    defined $I4997, $P4996
    unless $I4997, if_4995_end
.annotate 'line', 1788
    find_dynamic_lex $P4998, "$*PACKAGE-SETUP"
    unless_null $P4998, vivify_2342
    get_hll_global $P4998, "$PACKAGE-SETUP"
    unless_null $P4998, vivify_2343
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2343:
  vivify_2342:
    get_hll_global $P4999, ["PAST"], "Op"
.annotate 'line', 1790
    get_hll_global $P5000, ["PAST"], "Op"
.annotate 'line', 1792
    get_hll_global $P5001, ["PAST"], "Var"
    $P5002 = $P5001."new"("type_obj" :named("name"), "register" :named("scope"))
    $P5003 = $P5000."new"($P5002, "get_how PP" :named("pirop"))
.annotate 'line', 1794
    get_hll_global $P5004, ["PAST"], "Var"
    $P5005 = $P5004."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1795
    get_hll_global $P5006, ["PAST"], "Val"
    find_lex $P5007, "$name"
    unless_null $P5007, vivify_2344
    new $P5007, "Undef"
  vivify_2344:
    $P5008 = $P5006."new"($P5007 :named("value"))
.annotate 'line', 1796
    get_hll_global $P5009, ["PAST"], "Val"
    find_lex $P5010, "$regex"
    unless_null $P5010, vivify_2345
    new $P5010, "Undef"
  vivify_2345:
    $P5011 = $P5009."new"($P5010 :named("value"))
    $P5012 = $P4999."new"($P5003, $P5005, $P5008, $P5011, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 1788
    $P4998."push"($P5012)
.annotate 'line', 1798
    find_dynamic_lex $P5013, "$*PACKAGE-SETUP"
    unless_null $P5013, vivify_2346
    get_hll_global $P5013, "$PACKAGE-SETUP"
    unless_null $P5013, vivify_2347
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2347:
  vivify_2346:
    get_hll_global $P5014, ["PAST"], "Op"
.annotate 'line', 1800
    get_hll_global $P5015, ["PAST"], "Op"
.annotate 'line', 1802
    get_hll_global $P5016, ["PAST"], "Var"
    $P5017 = $P5016."new"("type_obj" :named("name"), "register" :named("scope"))
    $P5018 = $P5015."new"($P5017, "get_how PP" :named("pirop"))
.annotate 'line', 1804
    get_hll_global $P5019, ["PAST"], "Var"
    $P5020 = $P5019."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1805
    get_hll_global $P5021, ["PAST"], "Val"
    new $P5022, "String"
    assign $P5022, "!PREFIX__"
    find_lex $P5023, "$name"
    unless_null $P5023, vivify_2348
    new $P5023, "Undef"
  vivify_2348:
    concat $P5024, $P5022, $P5023
    $P5025 = $P5021."new"($P5024 :named("value"))
.annotate 'line', 1806
    get_hll_global $P5026, ["PAST"], "Var"
    new $P5027, "String"
    assign $P5027, "!PREFIX__"
    find_lex $P5028, "$name"
    unless_null $P5028, vivify_2349
    new $P5028, "Undef"
  vivify_2349:
    concat $P5029, $P5027, $P5028
    $P5030 = $P5026."new"($P5029 :named("name"), "package" :named("scope"))
    $P5031 = $P5014."new"($P5018, $P5020, $P5025, $P5030, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 1798
    $P5013."push"($P5031)
  if_4995_end:
.annotate 'line', 1810
    find_lex $P5032, "$regex"
    unless_null $P5032, vivify_2350
    new $P5032, "Undef"
  vivify_2350:
    find_lex $P5033, "$past"
    unless_null $P5033, vivify_2351
    $P5033 = root_new ['parrot';'Hash']
    store_lex "$past", $P5033
  vivify_2351:
    set $P5033["sink"], $P5032
.annotate 'line', 1811
    find_lex $P5034, "@MODIFIERS"
    unless_null $P5034, vivify_2352
    $P5034 = root_new ['parrot';'ResizablePMCArray']
  vivify_2352:
    $P5035 = $P5034."shift"()
.annotate 'line', 1777
    .return ($P5035)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block4940"  :anon :subid("515_1303340952.947") :outer("513_1303340952.947")
.annotate 'line', 1768
    $P4942 = root_new ['parrot';'Hash']
    .lex "%h", $P4942
.annotate 'line', 1767
    find_lex $P4943, "%h"
    unless_null $P4943, vivify_2353
    $P4943 = root_new ['parrot';'Hash']
  vivify_2353:
.annotate 'line', 1769
    find_lex $P4945, "$/"
    unless_null $P4945, vivify_2354
    $P4945 = root_new ['parrot';'Hash']
  vivify_2354:
    set $P4946, $P4945["sym"]
    unless_null $P4946, vivify_2355
    new $P4946, "Undef"
  vivify_2355:
    set $S4947, $P4946
    iseq $I4948, $S4947, "token"
    unless $I4948, if_4944_end
    new $P4949, "Integer"
    assign $P4949, 1
    find_lex $P4950, "%h"
    unless_null $P4950, vivify_2356
    $P4950 = root_new ['parrot';'Hash']
    store_lex "%h", $P4950
  vivify_2356:
    set $P4950["r"], $P4949
  if_4944_end:
.annotate 'line', 1770
    find_lex $P4952, "$/"
    unless_null $P4952, vivify_2357
    $P4952 = root_new ['parrot';'Hash']
  vivify_2357:
    set $P4953, $P4952["sym"]
    unless_null $P4953, vivify_2358
    new $P4953, "Undef"
  vivify_2358:
    set $S4954, $P4953
    iseq $I4955, $S4954, "rule"
    unless $I4955, if_4951_end
    new $P4956, "Integer"
    assign $P4956, 1
    find_lex $P4957, "%h"
    unless_null $P4957, vivify_2359
    $P4957 = root_new ['parrot';'Hash']
    store_lex "%h", $P4957
  vivify_2359:
    set $P4957["r"], $P4956
    new $P4958, "Integer"
    assign $P4958, 1
    find_lex $P4959, "%h"
    unless_null $P4959, vivify_2360
    $P4959 = root_new ['parrot';'Hash']
    store_lex "%h", $P4959
  vivify_2360:
    set $P4959["s"], $P4958
  if_4951_end:
.annotate 'line', 1771
    find_lex $P4960, "@MODIFIERS"
    unless_null $P4960, vivify_2361
    $P4960 = root_new ['parrot';'ResizablePMCArray']
  vivify_2361:
    find_lex $P4961, "%h"
    unless_null $P4961, vivify_2362
    $P4961 = root_new ['parrot';'Hash']
  vivify_2362:
    $P4960."unshift"($P4961)
.annotate 'line', 1772
    find_lex $P4962, "$name"
    unless_null $P4962, vivify_2363
    new $P4962, "Undef"
  vivify_2363:
    get_hll_global $P4963, ["Regex";"P6Regex"], "Actions"
    get_who $P4964, $P4963
    set $P4964["$REGEXNAME"], $P4962
.annotate 'line', 1773
    find_lex $P4965, "$?PACKAGE"
    get_who $P4966, $P4965
    set $P4967, $P4966["@BLOCK"]
    unless_null $P4967, vivify_2364
    $P4967 = root_new ['parrot';'ResizablePMCArray']
  vivify_2364:
    set $P4968, $P4967[0]
    unless_null $P4968, vivify_2365
    new $P4968, "Undef"
  vivify_2365:
    $P4968."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 1774
    find_lex $P4969, "$?PACKAGE"
    get_who $P4970, $P4969
    set $P4971, $P4970["@BLOCK"]
    unless_null $P4971, vivify_2366
    $P4971 = root_new ['parrot';'ResizablePMCArray']
  vivify_2366:
    set $P4972, $P4971[0]
    unless_null $P4972, vivify_2367
    new $P4972, "Undef"
  vivify_2367:
    $P4972."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 1775
    new $P4973, "Exception"
    set $P4973['type'], .CONTROL_RETURN
    new $P4974, "Integer"
    assign $P4974, 0
    setattribute $P4973, 'payload', $P4974
    throw $P4973
.annotate 'line', 1767
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4913"  :anon :subid("514_1303340952.947") :outer("513_1303340952.947")
    .param pmc param_4915
.annotate 'line', 1754
    .lex "$_", param_4915
.annotate 'line', 1755
    find_dynamic_lex $P4916, "$*PACKAGE-SETUP"
    unless_null $P4916, vivify_2376
    get_hll_global $P4916, "$PACKAGE-SETUP"
    unless_null $P4916, vivify_2377
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2377:
  vivify_2376:
    get_hll_global $P4917, ["PAST"], "Op"
.annotate 'line', 1757
    get_hll_global $P4918, ["PAST"], "Op"
.annotate 'line', 1759
    get_hll_global $P4919, ["PAST"], "Var"
    $P4920 = $P4919."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4921 = $P4918."new"($P4920, "get_how PP" :named("pirop"))
.annotate 'line', 1761
    get_hll_global $P4922, ["PAST"], "Var"
    $P4923 = $P4922."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1762
    get_hll_global $P4924, ["PAST"], "Val"
    find_lex $P4925, "$_"
    unless_null $P4925, vivify_2378
    new $P4925, "Undef"
  vivify_2378:
    $P4926 = $P4925."name"()
    $P4927 = $P4924."new"($P4926 :named("value"))
.annotate 'line', 1763
    get_hll_global $P4928, ["PAST"], "Val"
    find_lex $P4929, "$_"
    unless_null $P4929, vivify_2379
    new $P4929, "Undef"
  vivify_2379:
    $P4930 = $P4928."new"($P4929 :named("value"))
    $P4931 = $P4917."new"($P4921, $P4923, $P4927, $P4930, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 1755
    $P4932 = $P4916."push"($P4931)
.annotate 'line', 1754
    .return ($P4932)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "dotty"  :subid("517_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_5041
    .param pmc param_5042
.annotate 'line', 1817
    .lex "self", param_5041
    .lex "$/", param_5042
.annotate 'line', 1818
    new $P5043, "Undef"
    .lex "$past", $P5043
    find_lex $P5046, "$/"
    unless_null $P5046, vivify_2381
    $P5046 = root_new ['parrot';'Hash']
  vivify_2381:
    set $P5047, $P5046["args"]
    unless_null $P5047, vivify_2382
    new $P5047, "Undef"
  vivify_2382:
    if $P5047, if_5045
    get_hll_global $P5052, ["PAST"], "Op"
    find_lex $P5053, "$/"
    unless_null $P5053, vivify_2383
    new $P5053, "Undef"
  vivify_2383:
    $P5054 = $P5052."new"($P5053 :named("node"))
    set $P5044, $P5054
    goto if_5045_end
  if_5045:
    find_lex $P5048, "$/"
    unless_null $P5048, vivify_2384
    $P5048 = root_new ['parrot';'Hash']
  vivify_2384:
    set $P5049, $P5048["args"]
    unless_null $P5049, vivify_2385
    $P5049 = root_new ['parrot';'ResizablePMCArray']
  vivify_2385:
    set $P5050, $P5049[0]
    unless_null $P5050, vivify_2386
    new $P5050, "Undef"
  vivify_2386:
    $P5051 = $P5050."ast"()
    set $P5044, $P5051
  if_5045_end:
    store_lex "$past", $P5044
.annotate 'line', 1819
    find_lex $P5056, "$/"
    unless_null $P5056, vivify_2387
    $P5056 = root_new ['parrot';'Hash']
  vivify_2387:
    set $P5057, $P5056["quote"]
    unless_null $P5057, vivify_2388
    new $P5057, "Undef"
  vivify_2388:
    if $P5057, if_5055
.annotate 'line', 1823
    find_lex $P5064, "$/"
    unless_null $P5064, vivify_2389
    $P5064 = root_new ['parrot';'Hash']
  vivify_2389:
    set $P5065, $P5064["longname"]
    unless_null $P5065, vivify_2390
    new $P5065, "Undef"
  vivify_2390:
    set $S5066, $P5065
    iseq $I5067, $S5066, "HOW"
    if $I5067, if_5063
.annotate 'line', 1826
    find_lex $P5070, "$/"
    unless_null $P5070, vivify_2391
    $P5070 = root_new ['parrot';'Hash']
  vivify_2391:
    set $P5071, $P5070["longname"]
    unless_null $P5071, vivify_2392
    new $P5071, "Undef"
  vivify_2392:
    set $S5072, $P5071
    iseq $I5073, $S5072, "WHAT"
    if $I5073, if_5069
.annotate 'line', 1829
    find_lex $P5076, "$/"
    unless_null $P5076, vivify_2393
    $P5076 = root_new ['parrot';'Hash']
  vivify_2393:
    set $P5077, $P5076["longname"]
    unless_null $P5077, vivify_2394
    new $P5077, "Undef"
  vivify_2394:
    set $S5078, $P5077
    iseq $I5079, $S5078, "WHO"
    if $I5079, if_5075
.annotate 'line', 1833
    find_lex $P5081, "$past"
    unless_null $P5081, vivify_2395
    new $P5081, "Undef"
  vivify_2395:
    find_lex $P5082, "$/"
    unless_null $P5082, vivify_2396
    $P5082 = root_new ['parrot';'Hash']
  vivify_2396:
    set $P5083, $P5082["longname"]
    unless_null $P5083, vivify_2397
    new $P5083, "Undef"
  vivify_2397:
    set $S5084, $P5083
    $P5081."name"($S5084)
.annotate 'line', 1834
    find_lex $P5085, "$past"
    unless_null $P5085, vivify_2398
    new $P5085, "Undef"
  vivify_2398:
    $P5085."pasttype"("callmethod")
.annotate 'line', 1832
    goto if_5075_end
  if_5075:
.annotate 'line', 1830
    find_lex $P5080, "$past"
    unless_null $P5080, vivify_2399
    new $P5080, "Undef"
  vivify_2399:
    $P5080."pirop"("get_who PP")
  if_5075_end:
.annotate 'line', 1829
    goto if_5069_end
  if_5069:
.annotate 'line', 1827
    find_lex $P5074, "$past"
    unless_null $P5074, vivify_2400
    new $P5074, "Undef"
  vivify_2400:
    $P5074."pirop"("get_what PP")
  if_5069_end:
.annotate 'line', 1826
    goto if_5063_end
  if_5063:
.annotate 'line', 1824
    find_lex $P5068, "$past"
    unless_null $P5068, vivify_2401
    new $P5068, "Undef"
  vivify_2401:
    $P5068."pirop"("get_how PP")
  if_5063_end:
.annotate 'line', 1823
    goto if_5055_end
  if_5055:
.annotate 'line', 1820
    find_lex $P5058, "$past"
    unless_null $P5058, vivify_2402
    new $P5058, "Undef"
  vivify_2402:
    find_lex $P5059, "$/"
    unless_null $P5059, vivify_2403
    $P5059 = root_new ['parrot';'Hash']
  vivify_2403:
    set $P5060, $P5059["quote"]
    unless_null $P5060, vivify_2404
    new $P5060, "Undef"
  vivify_2404:
    $P5061 = $P5060."ast"()
    $P5058."name"($P5061)
.annotate 'line', 1821
    find_lex $P5062, "$past"
    unless_null $P5062, vivify_2405
    new $P5062, "Undef"
  vivify_2405:
    $P5062."pasttype"("callmethod")
  if_5055_end:
.annotate 'line', 1836
    find_lex $P5086, "$/"
    find_lex $P5087, "$past"
    unless_null $P5087, vivify_2406
    new $P5087, "Undef"
  vivify_2406:
    $P5088 = $P5086."!make"($P5087)
.annotate 'line', 1817
    .return ($P5088)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<self>"  :subid("518_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_5090
    .param pmc param_5091
.annotate 'line', 1841
    .lex "self", param_5090
    .lex "$/", param_5091
.annotate 'line', 1842
    find_lex $P5092, "$/"
    get_hll_global $P5093, ["PAST"], "Var"
    $P5094 = $P5093."new"("self" :named("name"))
    $P5095 = $P5092."!make"($P5094)
.annotate 'line', 1841
    .return ($P5095)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<identifier>"  :subid("519_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_5097
    .param pmc param_5098
.annotate 'line', 1845
    .lex "self", param_5097
    .lex "$/", param_5098
.annotate 'line', 1846
    new $P5099, "Undef"
    .lex "$past", $P5099
    find_lex $P5100, "$/"
    unless_null $P5100, vivify_2407
    $P5100 = root_new ['parrot';'Hash']
  vivify_2407:
    set $P5101, $P5100["args"]
    unless_null $P5101, vivify_2408
    new $P5101, "Undef"
  vivify_2408:
    $P5102 = $P5101."ast"()
    store_lex "$past", $P5102
.annotate 'line', 1847
    find_lex $P5103, "$past"
    unless_null $P5103, vivify_2409
    new $P5103, "Undef"
  vivify_2409:
    find_lex $P5104, "$/"
    unless_null $P5104, vivify_2410
    $P5104 = root_new ['parrot';'Hash']
  vivify_2410:
    set $P5105, $P5104["deflongname"]
    unless_null $P5105, vivify_2411
    new $P5105, "Undef"
  vivify_2411:
    set $S5106, $P5105
    $P5103."name"($S5106)
.annotate 'line', 1848
    find_lex $P5107, "$/"
    find_lex $P5108, "$past"
    unless_null $P5108, vivify_2412
    new $P5108, "Undef"
  vivify_2412:
    $P5109 = $P5107."!make"($P5108)
.annotate 'line', 1845
    .return ($P5109)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<name>"  :subid("520_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_5111
    .param pmc param_5112
.annotate 'line', 1851
    .const 'Sub' $P5127 = "521_1303340952.947" 
    capture_lex $P5127
    .lex "self", param_5111
    .lex "$/", param_5112
.annotate 'line', 1853
    new $P5113, "Undef"
    .lex "$var", $P5113
.annotate 'line', 1865
    new $P5114, "Undef"
    .lex "$past", $P5114
.annotate 'line', 1851
    find_lex $P5115, "$var"
    unless_null $P5115, vivify_2413
    new $P5115, "Undef"
  vivify_2413:
.annotate 'line', 1854
    find_lex $P5117, "$/"
    unless_null $P5117, vivify_2414
    $P5117 = root_new ['parrot';'Hash']
  vivify_2414:
    set $P5118, $P5117["name"]
    unless_null $P5118, vivify_2415
    new $P5118, "Undef"
  vivify_2415:
    set $S5119, $P5118
    $P5120 = "is_lexical"($S5119)
    if $P5120, if_5116
.annotate 'line', 1857
    .const 'Sub' $P5127 = "521_1303340952.947" 
    capture_lex $P5127
    $P5127()
    goto if_5116_end
  if_5116:
.annotate 'line', 1855
    get_hll_global $P5121, ["PAST"], "Var"
    find_lex $P5122, "$/"
    unless_null $P5122, vivify_2426
    $P5122 = root_new ['parrot';'Hash']
  vivify_2426:
    set $P5123, $P5122["name"]
    unless_null $P5123, vivify_2427
    new $P5123, "Undef"
  vivify_2427:
    set $S5124, $P5123
    $P5125 = $P5121."new"($S5124 :named("name"), "lexical" :named("scope"))
    store_lex "$var", $P5125
  if_5116_end:
.annotate 'line', 1865
    find_lex $P5150, "$var"
    unless_null $P5150, vivify_2428
    new $P5150, "Undef"
  vivify_2428:
    store_lex "$past", $P5150
.annotate 'line', 1866
    find_lex $P5152, "$/"
    unless_null $P5152, vivify_2429
    $P5152 = root_new ['parrot';'Hash']
  vivify_2429:
    set $P5153, $P5152["args"]
    unless_null $P5153, vivify_2430
    new $P5153, "Undef"
  vivify_2430:
    unless $P5153, if_5151_end
.annotate 'line', 1867
    find_lex $P5154, "$/"
    unless_null $P5154, vivify_2431
    $P5154 = root_new ['parrot';'Hash']
  vivify_2431:
    set $P5155, $P5154["args"]
    unless_null $P5155, vivify_2432
    $P5155 = root_new ['parrot';'ResizablePMCArray']
  vivify_2432:
    set $P5156, $P5155[0]
    unless_null $P5156, vivify_2433
    new $P5156, "Undef"
  vivify_2433:
    $P5157 = $P5156."ast"()
    store_lex "$past", $P5157
.annotate 'line', 1868
    find_lex $P5158, "$past"
    unless_null $P5158, vivify_2434
    new $P5158, "Undef"
  vivify_2434:
    find_lex $P5159, "$var"
    unless_null $P5159, vivify_2435
    new $P5159, "Undef"
  vivify_2435:
    $P5158."unshift"($P5159)
  if_5151_end:
.annotate 'line', 1870
    find_lex $P5160, "$/"
    find_lex $P5161, "$past"
    unless_null $P5161, vivify_2436
    new $P5161, "Undef"
  vivify_2436:
    $P5162 = $P5160."!make"($P5161)
.annotate 'line', 1851
    .return ($P5162)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5126"  :anon :subid("521_1303340952.947") :outer("520_1303340952.947")
.annotate 'line', 1858
    $P5128 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P5128
.annotate 'line', 1859
    new $P5129, "Undef"
    .lex "$name", $P5129
.annotate 'line', 1858
    find_lex $P5130, "$/"
    unless_null $P5130, vivify_2416
    $P5130 = root_new ['parrot';'Hash']
  vivify_2416:
    set $P5131, $P5130["name"]
    unless_null $P5131, vivify_2417
    $P5131 = root_new ['parrot';'Hash']
  vivify_2417:
    set $P5132, $P5131["identifier"]
    unless_null $P5132, vivify_2418
    new $P5132, "Undef"
  vivify_2418:
    clone $P5133, $P5132
    store_lex "@ns", $P5133
.annotate 'line', 1859
    find_lex $P5134, "@ns"
    unless_null $P5134, vivify_2419
    $P5134 = root_new ['parrot';'ResizablePMCArray']
  vivify_2419:
    $P5135 = $P5134."pop"()
    store_lex "$name", $P5135
.annotate 'line', 1860
    find_lex $P5139, "@ns"
    unless_null $P5139, vivify_2420
    $P5139 = root_new ['parrot';'ResizablePMCArray']
  vivify_2420:
    if $P5139, if_5138
    set $P5137, $P5139
    goto if_5138_end
  if_5138:
    find_lex $P5140, "@ns"
    unless_null $P5140, vivify_2421
    $P5140 = root_new ['parrot';'ResizablePMCArray']
  vivify_2421:
    set $P5141, $P5140[0]
    unless_null $P5141, vivify_2422
    new $P5141, "Undef"
  vivify_2422:
    set $S5142, $P5141
    iseq $I5143, $S5142, "GLOBAL"
    new $P5137, 'Integer'
    set $P5137, $I5143
  if_5138_end:
    unless $P5137, if_5136_end
    find_lex $P5144, "@ns"
    unless_null $P5144, vivify_2423
    $P5144 = root_new ['parrot';'ResizablePMCArray']
  vivify_2423:
    $P5144."shift"()
  if_5136_end:
.annotate 'line', 1861
    get_hll_global $P5145, ["PAST"], "Var"
    find_lex $P5146, "$name"
    unless_null $P5146, vivify_2424
    new $P5146, "Undef"
  vivify_2424:
    set $S5147, $P5146
    find_lex $P5148, "@ns"
    unless_null $P5148, vivify_2425
    $P5148 = root_new ['parrot';'ResizablePMCArray']
  vivify_2425:
    $P5149 = $P5145."new"($S5147 :named("name"), $P5148 :named("namespace"), "package" :named("scope"))
    store_lex "$var", $P5149
.annotate 'line', 1857
    .return ($P5149)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<pir::op>"  :subid("522_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_5164
    .param pmc param_5165
.annotate 'line', 1873
    .lex "self", param_5164
    .lex "$/", param_5165
.annotate 'line', 1874
    new $P5166, "Undef"
    .lex "$past", $P5166
.annotate 'line', 1875
    new $P5167, "Undef"
    .lex "$pirop", $P5167
.annotate 'line', 1874
    find_lex $P5170, "$/"
    unless_null $P5170, vivify_2437
    $P5170 = root_new ['parrot';'Hash']
  vivify_2437:
    set $P5171, $P5170["args"]
    unless_null $P5171, vivify_2438
    new $P5171, "Undef"
  vivify_2438:
    if $P5171, if_5169
    get_hll_global $P5176, ["PAST"], "Op"
    find_lex $P5177, "$/"
    unless_null $P5177, vivify_2439
    new $P5177, "Undef"
  vivify_2439:
    $P5178 = $P5176."new"($P5177 :named("node"))
    set $P5168, $P5178
    goto if_5169_end
  if_5169:
    find_lex $P5172, "$/"
    unless_null $P5172, vivify_2440
    $P5172 = root_new ['parrot';'Hash']
  vivify_2440:
    set $P5173, $P5172["args"]
    unless_null $P5173, vivify_2441
    $P5173 = root_new ['parrot';'ResizablePMCArray']
  vivify_2441:
    set $P5174, $P5173[0]
    unless_null $P5174, vivify_2442
    new $P5174, "Undef"
  vivify_2442:
    $P5175 = $P5174."ast"()
    set $P5168, $P5175
  if_5169_end:
    store_lex "$past", $P5168
.annotate 'line', 1875
    find_lex $P5179, "$/"
    unless_null $P5179, vivify_2443
    $P5179 = root_new ['parrot';'Hash']
  vivify_2443:
    set $P5180, $P5179["op"]
    unless_null $P5180, vivify_2444
    new $P5180, "Undef"
  vivify_2444:
    set $S5181, $P5180
    new $P5182, 'String'
    set $P5182, $S5181
    store_lex "$pirop", $P5182
.annotate 'line', 1876

            $P0 = find_lex '$pirop'
            $S0 = $P0
            $P0 = split '__', $S0
            $S0 = join ' ', $P0
            $P5183 = box $S0
        
    store_lex "$pirop", $P5183
.annotate 'line', 1883
    find_lex $P5184, "$past"
    unless_null $P5184, vivify_2445
    new $P5184, "Undef"
  vivify_2445:
    find_lex $P5185, "$pirop"
    unless_null $P5185, vivify_2446
    new $P5185, "Undef"
  vivify_2446:
    $P5184."pirop"($P5185)
.annotate 'line', 1884
    find_lex $P5186, "$past"
    unless_null $P5186, vivify_2447
    new $P5186, "Undef"
  vivify_2447:
    $P5186."pasttype"("pirop")
.annotate 'line', 1885
    find_lex $P5187, "$/"
    find_lex $P5188, "$past"
    unless_null $P5188, vivify_2448
    new $P5188, "Undef"
  vivify_2448:
    $P5189 = $P5187."!make"($P5188)
.annotate 'line', 1873
    .return ($P5189)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<onlystar>"  :subid("523_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_5191
    .param pmc param_5192
.annotate 'line', 1888
    .lex "self", param_5191
    .lex "$/", param_5192
.annotate 'line', 1889
    find_lex $P5193, "$/"
    get_hll_global $P5194, ["PAST"], "Op"
    $P5195 = $P5194."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P5196 = $P5193."!make"($P5195)
.annotate 'line', 1888
    .return ($P5196)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "args"  :subid("524_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_5198
    .param pmc param_5199
.annotate 'line', 1894
    .lex "self", param_5198
    .lex "$/", param_5199
    find_lex $P5200, "$/"
    find_lex $P5201, "$/"
    unless_null $P5201, vivify_2449
    $P5201 = root_new ['parrot';'Hash']
  vivify_2449:
    set $P5202, $P5201["arglist"]
    unless_null $P5202, vivify_2450
    new $P5202, "Undef"
  vivify_2450:
    $P5203 = $P5202."ast"()
    $P5204 = $P5200."!make"($P5203)
    .return ($P5204)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "arglist"  :subid("525_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_5206
    .param pmc param_5207
.annotate 'line', 1896
    .const 'Sub' $P5218 = "526_1303340952.947" 
    capture_lex $P5218
    .lex "self", param_5206
    .lex "$/", param_5207
.annotate 'line', 1897
    new $P5208, "Undef"
    .lex "$past", $P5208
.annotate 'line', 1905
    new $P5209, "Undef"
    .lex "$i", $P5209
.annotate 'line', 1906
    new $P5210, "Undef"
    .lex "$n", $P5210
.annotate 'line', 1897
    get_hll_global $P5211, ["PAST"], "Op"
    find_lex $P5212, "$/"
    unless_null $P5212, vivify_2451
    new $P5212, "Undef"
  vivify_2451:
    $P5213 = $P5211."new"("call" :named("pasttype"), $P5212 :named("node"))
    store_lex "$past", $P5213
.annotate 'line', 1898
    find_lex $P5215, "$/"
    unless_null $P5215, vivify_2452
    $P5215 = root_new ['parrot';'Hash']
  vivify_2452:
    set $P5216, $P5215["EXPR"]
    unless_null $P5216, vivify_2453
    new $P5216, "Undef"
  vivify_2453:
    unless $P5216, if_5214_end
    .const 'Sub' $P5218 = "526_1303340952.947" 
    capture_lex $P5218
    $P5218()
  if_5214_end:
.annotate 'line', 1905
    new $P5250, "Integer"
    assign $P5250, 0
    store_lex "$i", $P5250
.annotate 'line', 1906
    find_lex $P5251, "$past"
    unless_null $P5251, vivify_2464
    new $P5251, "Undef"
  vivify_2464:
    $P5252 = $P5251."list"()
    set $N5253, $P5252
    new $P5254, 'Float'
    set $P5254, $N5253
    store_lex "$n", $P5254
.annotate 'line', 1907
    new $P5302, 'ExceptionHandler'
    set_label $P5302, loop5301_handler
    $P5302."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5302
  loop5301_test:
    find_lex $P5255, "$i"
    unless_null $P5255, vivify_2465
    new $P5255, "Undef"
  vivify_2465:
    set $N5256, $P5255
    find_lex $P5257, "$n"
    unless_null $P5257, vivify_2466
    new $P5257, "Undef"
  vivify_2466:
    set $N5258, $P5257
    islt $I5259, $N5256, $N5258
    unless $I5259, loop5301_done
  loop5301_redo:
.annotate 'line', 1908
    find_lex $P5261, "$i"
    unless_null $P5261, vivify_2467
    new $P5261, "Undef"
  vivify_2467:
    set $I5262, $P5261
    find_lex $P5263, "$past"
    unless_null $P5263, vivify_2468
    $P5263 = root_new ['parrot';'ResizablePMCArray']
  vivify_2468:
    set $P5264, $P5263[$I5262]
    unless_null $P5264, vivify_2469
    new $P5264, "Undef"
  vivify_2469:
    $S5265 = $P5264."name"()
    iseq $I5266, $S5265, "&prefix:<|>"
    unless $I5266, if_5260_end
.annotate 'line', 1909
    find_lex $P5267, "$i"
    unless_null $P5267, vivify_2470
    new $P5267, "Undef"
  vivify_2470:
    set $I5268, $P5267
    find_lex $P5269, "$past"
    unless_null $P5269, vivify_2471
    $P5269 = root_new ['parrot';'ResizablePMCArray']
  vivify_2471:
    set $P5270, $P5269[$I5268]
    unless_null $P5270, vivify_2472
    $P5270 = root_new ['parrot';'ResizablePMCArray']
  vivify_2472:
    set $P5271, $P5270[0]
    unless_null $P5271, vivify_2473
    new $P5271, "Undef"
  vivify_2473:
    find_lex $P5272, "$i"
    unless_null $P5272, vivify_2474
    new $P5272, "Undef"
  vivify_2474:
    set $I5273, $P5272
    find_lex $P5274, "$past"
    unless_null $P5274, vivify_2475
    $P5274 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$past", $P5274
  vivify_2475:
    set $P5274[$I5273], $P5271
.annotate 'line', 1910
    find_lex $P5275, "$i"
    unless_null $P5275, vivify_2476
    new $P5275, "Undef"
  vivify_2476:
    set $I5276, $P5275
    find_lex $P5277, "$past"
    unless_null $P5277, vivify_2477
    $P5277 = root_new ['parrot';'ResizablePMCArray']
  vivify_2477:
    set $P5278, $P5277[$I5276]
    unless_null $P5278, vivify_2478
    new $P5278, "Undef"
  vivify_2478:
    $P5278."flat"(1)
.annotate 'line', 1911
    find_lex $P5282, "$i"
    unless_null $P5282, vivify_2479
    new $P5282, "Undef"
  vivify_2479:
    set $I5283, $P5282
    find_lex $P5284, "$past"
    unless_null $P5284, vivify_2480
    $P5284 = root_new ['parrot';'ResizablePMCArray']
  vivify_2480:
    set $P5285, $P5284[$I5283]
    unless_null $P5285, vivify_2481
    new $P5285, "Undef"
  vivify_2481:
    get_hll_global $P5286, ["PAST"], "Val"
    $P5287 = $P5285."isa"($P5286)
    if $P5287, if_5281
    set $P5280, $P5287
    goto if_5281_end
  if_5281:
.annotate 'line', 1912
    find_lex $P5288, "$i"
    unless_null $P5288, vivify_2482
    new $P5288, "Undef"
  vivify_2482:
    set $I5289, $P5288
    find_lex $P5290, "$past"
    unless_null $P5290, vivify_2483
    $P5290 = root_new ['parrot';'ResizablePMCArray']
  vivify_2483:
    set $P5291, $P5290[$I5289]
    unless_null $P5291, vivify_2484
    new $P5291, "Undef"
  vivify_2484:
    $S5292 = $P5291."name"()
    substr $S5293, $S5292, 0, 1
    iseq $I5294, $S5293, "%"
    new $P5280, 'Integer'
    set $P5280, $I5294
  if_5281_end:
    unless $P5280, if_5279_end
.annotate 'line', 1913
    find_lex $P5295, "$i"
    unless_null $P5295, vivify_2485
    new $P5295, "Undef"
  vivify_2485:
    set $I5296, $P5295
    find_lex $P5297, "$past"
    unless_null $P5297, vivify_2486
    $P5297 = root_new ['parrot';'ResizablePMCArray']
  vivify_2486:
    set $P5298, $P5297[$I5296]
    unless_null $P5298, vivify_2487
    new $P5298, "Undef"
  vivify_2487:
    $P5298."named"(1)
  if_5279_end:
  if_5260_end:
.annotate 'line', 1908
    find_lex $P5299, "$i"
    unless_null $P5299, vivify_2488
    new $P5299, "Undef"
  vivify_2488:
    clone $P5300, $P5299
    inc $P5299
  loop5301_next:
.annotate 'line', 1907
    goto loop5301_test
  loop5301_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5303, exception, 'type'
    eq $P5303, .CONTROL_LOOP_NEXT, loop5301_next
    eq $P5303, .CONTROL_LOOP_REDO, loop5301_redo
  loop5301_done:
    pop_eh 
.annotate 'line', 1918
    find_lex $P5304, "$/"
    find_lex $P5305, "$past"
    unless_null $P5305, vivify_2489
    new $P5305, "Undef"
  vivify_2489:
    $P5306 = $P5304."!make"($P5305)
.annotate 'line', 1896
    .return ($P5306)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block5217"  :anon :subid("526_1303340952.947") :outer("525_1303340952.947")
.annotate 'line', 1898
    .const 'Sub' $P5239 = "527_1303340952.947" 
    capture_lex $P5239
.annotate 'line', 1899
    new $P5219, "Undef"
    .lex "$expr", $P5219
    find_lex $P5220, "$/"
    unless_null $P5220, vivify_2454
    $P5220 = root_new ['parrot';'Hash']
  vivify_2454:
    set $P5221, $P5220["EXPR"]
    unless_null $P5221, vivify_2455
    new $P5221, "Undef"
  vivify_2455:
    $P5222 = $P5221."ast"()
    store_lex "$expr", $P5222
.annotate 'line', 1900
    find_lex $P5227, "$expr"
    unless_null $P5227, vivify_2456
    new $P5227, "Undef"
  vivify_2456:
    $S5228 = $P5227."name"()
    iseq $I5229, $S5228, "&infix:<,>"
    if $I5229, if_5226
    new $P5225, 'Integer'
    set $P5225, $I5229
    goto if_5226_end
  if_5226:
    find_lex $P5230, "$expr"
    unless_null $P5230, vivify_2457
    new $P5230, "Undef"
  vivify_2457:
    $P5231 = $P5230."named"()
    isfalse $I5232, $P5231
    new $P5225, 'Integer'
    set $P5225, $I5232
  if_5226_end:
    if $P5225, if_5224
.annotate 'line', 1903
    find_lex $P5247, "$past"
    unless_null $P5247, vivify_2458
    new $P5247, "Undef"
  vivify_2458:
    find_lex $P5248, "$expr"
    unless_null $P5248, vivify_2459
    new $P5248, "Undef"
  vivify_2459:
    $P5249 = $P5247."push"($P5248)
    set $P5223, $P5249
.annotate 'line', 1900
    goto if_5224_end
  if_5224:
.annotate 'line', 1901
    find_lex $P5234, "$expr"
    unless_null $P5234, vivify_2460
    new $P5234, "Undef"
  vivify_2460:
    $P5235 = $P5234."list"()
    defined $I5236, $P5235
    unless $I5236, for_undef_2461
    iter $P5233, $P5235
    new $P5245, 'ExceptionHandler'
    set_label $P5245, loop5244_handler
    $P5245."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5245
  loop5244_test:
    unless $P5233, loop5244_done
    shift $P5237, $P5233
  loop5244_redo:
    .const 'Sub' $P5239 = "527_1303340952.947" 
    capture_lex $P5239
    $P5239($P5237)
  loop5244_next:
    goto loop5244_test
  loop5244_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5246, exception, 'type'
    eq $P5246, .CONTROL_LOOP_NEXT, loop5244_next
    eq $P5246, .CONTROL_LOOP_REDO, loop5244_redo
  loop5244_done:
    pop_eh 
  for_undef_2461:
.annotate 'line', 1900
    set $P5223, $P5233
  if_5224_end:
.annotate 'line', 1898
    .return ($P5223)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5238"  :anon :subid("527_1303340952.947") :outer("526_1303340952.947")
    .param pmc param_5240
.annotate 'line', 1901
    .lex "$_", param_5240
    find_lex $P5241, "$past"
    unless_null $P5241, vivify_2462
    new $P5241, "Undef"
  vivify_2462:
    find_lex $P5242, "$_"
    unless_null $P5242, vivify_2463
    new $P5242, "Undef"
  vivify_2463:
    $P5243 = $P5241."push"($P5242)
    .return ($P5243)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<multi_declarator>"  :subid("528_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_5308
    .param pmc param_5309
.annotate 'line', 1921
    .lex "self", param_5308
    .lex "$/", param_5309
    find_lex $P5310, "$/"
    find_lex $P5311, "$/"
    unless_null $P5311, vivify_2490
    $P5311 = root_new ['parrot';'Hash']
  vivify_2490:
    set $P5312, $P5311["multi_declarator"]
    unless_null $P5312, vivify_2491
    new $P5312, "Undef"
  vivify_2491:
    $P5313 = $P5312."ast"()
    $P5314 = $P5310."!make"($P5313)
    .return ($P5314)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<value>"  :subid("529_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_5316
    .param pmc param_5317
.annotate 'line', 1923
    .lex "self", param_5316
    .lex "$/", param_5317
    find_lex $P5318, "$/"
    find_lex $P5319, "$/"
    unless_null $P5319, vivify_2492
    $P5319 = root_new ['parrot';'Hash']
  vivify_2492:
    set $P5320, $P5319["value"]
    unless_null $P5320, vivify_2493
    new $P5320, "Undef"
  vivify_2493:
    $P5321 = $P5320."ast"()
    $P5322 = $P5318."!make"($P5321)
    .return ($P5322)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<( )>"  :subid("530_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_5324
    .param pmc param_5325
.annotate 'line', 1925
    .lex "self", param_5324
    .lex "$/", param_5325
.annotate 'line', 1926
    find_lex $P5326, "$/"
.annotate 'line', 1927
    find_lex $P5329, "$/"
    unless_null $P5329, vivify_2494
    $P5329 = root_new ['parrot';'Hash']
  vivify_2494:
    set $P5330, $P5329["EXPR"]
    unless_null $P5330, vivify_2495
    new $P5330, "Undef"
  vivify_2495:
    if $P5330, if_5328
.annotate 'line', 1928
    get_hll_global $P5335, ["PAST"], "Op"
    find_lex $P5336, "$/"
    unless_null $P5336, vivify_2496
    new $P5336, "Undef"
  vivify_2496:
    $P5337 = $P5335."new"("list" :named("pasttype"), $P5336 :named("node"))
    set $P5327, $P5337
.annotate 'line', 1927
    goto if_5328_end
  if_5328:
    find_lex $P5331, "$/"
    unless_null $P5331, vivify_2497
    $P5331 = root_new ['parrot';'Hash']
  vivify_2497:
    set $P5332, $P5331["EXPR"]
    unless_null $P5332, vivify_2498
    $P5332 = root_new ['parrot';'ResizablePMCArray']
  vivify_2498:
    set $P5333, $P5332[0]
    unless_null $P5333, vivify_2499
    new $P5333, "Undef"
  vivify_2499:
    $P5334 = $P5333."ast"()
    set $P5327, $P5334
  if_5328_end:
    $P5338 = $P5326."!make"($P5327)
.annotate 'line', 1925
    .return ($P5338)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<[ ]>"  :subid("531_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_5340
    .param pmc param_5341
.annotate 'line', 1931
    .lex "self", param_5340
    .lex "$/", param_5341
.annotate 'line', 1932
    new $P5342, "Undef"
    .lex "$past", $P5342
.annotate 'line', 1931
    find_lex $P5343, "$past"
    unless_null $P5343, vivify_2500
    new $P5343, "Undef"
  vivify_2500:
.annotate 'line', 1933
    find_lex $P5345, "$/"
    unless_null $P5345, vivify_2501
    $P5345 = root_new ['parrot';'Hash']
  vivify_2501:
    set $P5346, $P5345["EXPR"]
    unless_null $P5346, vivify_2502
    new $P5346, "Undef"
  vivify_2502:
    if $P5346, if_5344
.annotate 'line', 1940
    get_hll_global $P5358, ["PAST"], "Op"
    $P5359 = $P5358."new"("list" :named("pasttype"))
    store_lex "$past", $P5359
.annotate 'line', 1939
    goto if_5344_end
  if_5344:
.annotate 'line', 1934
    find_lex $P5347, "$/"
    unless_null $P5347, vivify_2503
    $P5347 = root_new ['parrot';'Hash']
  vivify_2503:
    set $P5348, $P5347["EXPR"]
    unless_null $P5348, vivify_2504
    $P5348 = root_new ['parrot';'ResizablePMCArray']
  vivify_2504:
    set $P5349, $P5348[0]
    unless_null $P5349, vivify_2505
    new $P5349, "Undef"
  vivify_2505:
    $P5350 = $P5349."ast"()
    store_lex "$past", $P5350
.annotate 'line', 1935
    find_lex $P5352, "$past"
    unless_null $P5352, vivify_2506
    new $P5352, "Undef"
  vivify_2506:
    $S5353 = $P5352."name"()
    isne $I5354, $S5353, "&infix:<,>"
    unless $I5354, if_5351_end
.annotate 'line', 1936
    get_hll_global $P5355, ["PAST"], "Op"
    find_lex $P5356, "$past"
    unless_null $P5356, vivify_2507
    new $P5356, "Undef"
  vivify_2507:
    $P5357 = $P5355."new"($P5356, "list" :named("pasttype"))
    store_lex "$past", $P5357
  if_5351_end:
  if_5344_end:
.annotate 'line', 1942
    find_lex $P5360, "$past"
    unless_null $P5360, vivify_2508
    new $P5360, "Undef"
  vivify_2508:
    $P5360."name"("&circumfix:<[ ]>")
.annotate 'line', 1943
    find_lex $P5361, "$/"
    find_lex $P5362, "$past"
    unless_null $P5362, vivify_2509
    new $P5362, "Undef"
  vivify_2509:
    $P5363 = $P5361."!make"($P5362)
.annotate 'line', 1931
    .return ($P5363)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<ang>"  :subid("532_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_5365
    .param pmc param_5366
.annotate 'line', 1946
    .lex "self", param_5365
    .lex "$/", param_5366
    find_lex $P5367, "$/"
    find_lex $P5368, "$/"
    unless_null $P5368, vivify_2510
    $P5368 = root_new ['parrot';'Hash']
  vivify_2510:
    set $P5369, $P5368["quote_EXPR"]
    unless_null $P5369, vivify_2511
    new $P5369, "Undef"
  vivify_2511:
    $P5370 = $P5369."ast"()
    $P5371 = $P5367."!make"($P5370)
    .return ($P5371)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("533_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_5373
    .param pmc param_5374
.annotate 'line', 1947
    .lex "self", param_5373
    .lex "$/", param_5374
    find_lex $P5375, "$/"
    find_lex $P5376, "$/"
    unless_null $P5376, vivify_2512
    $P5376 = root_new ['parrot';'Hash']
  vivify_2512:
    set $P5377, $P5376["quote_EXPR"]
    unless_null $P5377, vivify_2513
    new $P5377, "Undef"
  vivify_2513:
    $P5378 = $P5377."ast"()
    $P5379 = $P5375."!make"($P5378)
    .return ($P5379)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<{ }>"  :subid("534_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_5381
    .param pmc param_5382
.annotate 'line', 1949
    .const 'Sub' $P5393 = "535_1303340952.947" 
    capture_lex $P5393
    .lex "self", param_5381
    .lex "$/", param_5382
.annotate 'line', 1950
    find_lex $P5385, "$/"
    unless_null $P5385, vivify_2514
    $P5385 = root_new ['parrot';'Hash']
  vivify_2514:
    set $P5386, $P5385["pblock"]
    unless_null $P5386, vivify_2515
    $P5386 = root_new ['parrot';'Hash']
  vivify_2515:
    set $P5387, $P5386["blockoid"]
    unless_null $P5387, vivify_2516
    $P5387 = root_new ['parrot';'Hash']
  vivify_2516:
    set $P5388, $P5387["statementlist"]
    unless_null $P5388, vivify_2517
    $P5388 = root_new ['parrot';'Hash']
  vivify_2517:
    set $P5389, $P5388["statement"]
    unless_null $P5389, vivify_2518
    new $P5389, "Undef"
  vivify_2518:
    set $N5390, $P5389
    isgt $I5391, $N5390, 0.0
    if $I5391, if_5384
.annotate 'line', 1955
    find_lex $P5406, "$/"
    unless_null $P5406, vivify_2519
    $P5406 = root_new ['parrot';'Hash']
  vivify_2519:
    set $P5407, $P5406["pblock"]
    unless_null $P5407, vivify_2520
    $P5407 = root_new ['parrot';'Hash']
  vivify_2520:
    set $P5408, $P5407["blockoid"]
    unless_null $P5408, vivify_2521
    $P5408 = root_new ['parrot';'Hash']
  vivify_2521:
    set $P5409, $P5408["you_are_here"]
    unless_null $P5409, vivify_2522
    new $P5409, "Undef"
  vivify_2522:
    if $P5409, if_5405
.annotate 'line', 1959
    find_lex $P5415, "$/"
    $P5416 = "vivitype"("%")
    $P5417 = $P5415."!make"($P5416)
.annotate 'line', 1958
    set $P5404, $P5417
.annotate 'line', 1955
    goto if_5405_end
  if_5405:
.annotate 'line', 1956
    find_lex $P5410, "$/"
    find_lex $P5411, "$/"
    unless_null $P5411, vivify_2523
    $P5411 = root_new ['parrot';'Hash']
  vivify_2523:
    set $P5412, $P5411["pblock"]
    unless_null $P5412, vivify_2524
    new $P5412, "Undef"
  vivify_2524:
    $P5413 = $P5412."ast"()
    $P5414 = $P5410."!make"($P5413)
.annotate 'line', 1955
    set $P5404, $P5414
  if_5405_end:
    set $P5383, $P5404
.annotate 'line', 1950
    goto if_5384_end
  if_5384:
    .const 'Sub' $P5393 = "535_1303340952.947" 
    capture_lex $P5393
    $P5403 = $P5393()
    set $P5383, $P5403
  if_5384_end:
.annotate 'line', 1949
    .return ($P5383)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5392"  :anon :subid("535_1303340952.947") :outer("534_1303340952.947")
.annotate 'line', 1951
    new $P5394, "Undef"
    .lex "$past", $P5394
    find_lex $P5395, "$/"
    unless_null $P5395, vivify_2525
    $P5395 = root_new ['parrot';'Hash']
  vivify_2525:
    set $P5396, $P5395["pblock"]
    unless_null $P5396, vivify_2526
    new $P5396, "Undef"
  vivify_2526:
    $P5397 = $P5396."ast"()
    store_lex "$past", $P5397
.annotate 'line', 1952
    new $P5398, "Integer"
    assign $P5398, 1
    find_lex $P5399, "$past"
    unless_null $P5399, vivify_2527
    $P5399 = root_new ['parrot';'Hash']
    store_lex "$past", $P5399
  vivify_2527:
    set $P5399["bareblock"], $P5398
.annotate 'line', 1953
    find_dynamic_lex $P5400, "$/"
    find_lex $P5401, "$past"
    unless_null $P5401, vivify_2528
    new $P5401, "Undef"
  vivify_2528:
    $P5402 = $P5400."!make"($P5401)
.annotate 'line', 1950
    .return ($P5402)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<sigil>"  :subid("536_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_5419
    .param pmc param_5420
.annotate 'line', 1963
    .lex "self", param_5419
    .lex "$/", param_5420
.annotate 'line', 1964
    new $P5421, "Undef"
    .lex "$name", $P5421
    find_lex $P5424, "$/"
    unless_null $P5424, vivify_2529
    $P5424 = root_new ['parrot';'Hash']
  vivify_2529:
    set $P5425, $P5424["sigil"]
    unless_null $P5425, vivify_2530
    new $P5425, "Undef"
  vivify_2530:
    set $S5426, $P5425
    iseq $I5427, $S5426, "@"
    if $I5427, if_5423
.annotate 'line', 1965
    find_lex $P5431, "$/"
    unless_null $P5431, vivify_2531
    $P5431 = root_new ['parrot';'Hash']
  vivify_2531:
    set $P5432, $P5431["sigil"]
    unless_null $P5432, vivify_2532
    new $P5432, "Undef"
  vivify_2532:
    set $S5433, $P5432
    iseq $I5434, $S5433, "%"
    if $I5434, if_5430
    new $P5436, "String"
    assign $P5436, "item"
    set $P5429, $P5436
    goto if_5430_end
  if_5430:
    new $P5435, "String"
    assign $P5435, "hash"
    set $P5429, $P5435
  if_5430_end:
    set $P5422, $P5429
.annotate 'line', 1964
    goto if_5423_end
  if_5423:
    new $P5428, "String"
    assign $P5428, "list"
    set $P5422, $P5428
  if_5423_end:
    store_lex "$name", $P5422
.annotate 'line', 1967
    find_lex $P5437, "$/"
    get_hll_global $P5438, ["PAST"], "Op"
    find_lex $P5439, "$name"
    unless_null $P5439, vivify_2533
    new $P5439, "Undef"
  vivify_2533:
    find_lex $P5440, "$/"
    unless_null $P5440, vivify_2534
    $P5440 = root_new ['parrot';'Hash']
  vivify_2534:
    set $P5441, $P5440["semilist"]
    unless_null $P5441, vivify_2535
    new $P5441, "Undef"
  vivify_2535:
    $P5442 = $P5441."ast"()
    $P5443 = $P5438."new"($P5442, "callmethod" :named("pasttype"), $P5439 :named("name"))
    $P5444 = $P5437."!make"($P5443)
.annotate 'line', 1963
    .return ($P5444)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "semilist"  :subid("537_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_5446
    .param pmc param_5447
.annotate 'line', 1970
    .lex "self", param_5446
    .lex "$/", param_5447
    find_lex $P5448, "$/"
    find_lex $P5449, "$/"
    unless_null $P5449, vivify_2536
    $P5449 = root_new ['parrot';'Hash']
  vivify_2536:
    set $P5450, $P5449["statement"]
    unless_null $P5450, vivify_2537
    new $P5450, "Undef"
  vivify_2537:
    $P5451 = $P5450."ast"()
    $P5452 = $P5448."!make"($P5451)
    .return ($P5452)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<[ ]>"  :subid("538_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_5454
    .param pmc param_5455
.annotate 'line', 1972
    .lex "self", param_5454
    .lex "$/", param_5455
.annotate 'line', 1973
    find_lex $P5456, "$/"
    get_hll_global $P5457, ["PAST"], "Var"
    find_lex $P5458, "$/"
    unless_null $P5458, vivify_2538
    $P5458 = root_new ['parrot';'Hash']
  vivify_2538:
    set $P5459, $P5458["EXPR"]
    unless_null $P5459, vivify_2539
    new $P5459, "Undef"
  vivify_2539:
    $P5460 = $P5459."ast"()
.annotate 'line', 1975
    $P5461 = "vivitype"("@")
    $P5462 = $P5457."new"($P5460, "keyed_int" :named("scope"), "Undef" :named("viviself"), $P5461 :named("vivibase"))
.annotate 'line', 1973
    $P5463 = $P5456."!make"($P5462)
.annotate 'line', 1972
    .return ($P5463)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<{ }>"  :subid("539_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_5465
    .param pmc param_5466
.annotate 'line', 1978
    .lex "self", param_5465
    .lex "$/", param_5466
.annotate 'line', 1979
    find_lex $P5467, "$/"
    get_hll_global $P5468, ["PAST"], "Var"
    find_lex $P5469, "$/"
    unless_null $P5469, vivify_2540
    $P5469 = root_new ['parrot';'Hash']
  vivify_2540:
    set $P5470, $P5469["EXPR"]
    unless_null $P5470, vivify_2541
    new $P5470, "Undef"
  vivify_2541:
    $P5471 = $P5470."ast"()
.annotate 'line', 1981
    $P5472 = "vivitype"("%")
    $P5473 = $P5468."new"($P5471, "keyed" :named("scope"), "Undef" :named("viviself"), $P5472 :named("vivibase"))
.annotate 'line', 1979
    $P5474 = $P5467."!make"($P5473)
.annotate 'line', 1978
    .return ($P5474)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<ang>"  :subid("540_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_5476
    .param pmc param_5477
.annotate 'line', 1984
    .lex "self", param_5476
    .lex "$/", param_5477
.annotate 'line', 1985
    find_lex $P5478, "$/"
    get_hll_global $P5479, ["PAST"], "Var"
    find_lex $P5480, "$/"
    unless_null $P5480, vivify_2542
    $P5480 = root_new ['parrot';'Hash']
  vivify_2542:
    set $P5481, $P5480["quote_EXPR"]
    unless_null $P5481, vivify_2543
    new $P5481, "Undef"
  vivify_2543:
    $P5482 = $P5481."ast"()
.annotate 'line', 1987
    $P5483 = "vivitype"("%")
    $P5484 = $P5479."new"($P5482, "keyed" :named("scope"), "Undef" :named("viviself"), $P5483 :named("vivibase"))
.annotate 'line', 1985
    $P5485 = $P5478."!make"($P5484)
.annotate 'line', 1984
    .return ($P5485)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<( )>"  :subid("541_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_5487
    .param pmc param_5488
.annotate 'line', 1990
    .lex "self", param_5487
    .lex "$/", param_5488
.annotate 'line', 1991
    find_lex $P5489, "$/"
    find_lex $P5490, "$/"
    unless_null $P5490, vivify_2544
    $P5490 = root_new ['parrot';'Hash']
  vivify_2544:
    set $P5491, $P5490["arglist"]
    unless_null $P5491, vivify_2545
    new $P5491, "Undef"
  vivify_2545:
    $P5492 = $P5491."ast"()
    $P5493 = $P5489."!make"($P5492)
.annotate 'line', 1990
    .return ($P5493)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "value"  :subid("542_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_5495
    .param pmc param_5496
.annotate 'line', 1994
    .lex "self", param_5495
    .lex "$/", param_5496
.annotate 'line', 1995
    find_lex $P5497, "$/"
    find_lex $P5500, "$/"
    unless_null $P5500, vivify_2546
    $P5500 = root_new ['parrot';'Hash']
  vivify_2546:
    set $P5501, $P5500["quote"]
    unless_null $P5501, vivify_2547
    new $P5501, "Undef"
  vivify_2547:
    if $P5501, if_5499
    find_lex $P5505, "$/"
    unless_null $P5505, vivify_2548
    $P5505 = root_new ['parrot';'Hash']
  vivify_2548:
    set $P5506, $P5505["number"]
    unless_null $P5506, vivify_2549
    new $P5506, "Undef"
  vivify_2549:
    $P5507 = $P5506."ast"()
    set $P5498, $P5507
    goto if_5499_end
  if_5499:
    find_lex $P5502, "$/"
    unless_null $P5502, vivify_2550
    $P5502 = root_new ['parrot';'Hash']
  vivify_2550:
    set $P5503, $P5502["quote"]
    unless_null $P5503, vivify_2551
    new $P5503, "Undef"
  vivify_2551:
    $P5504 = $P5503."ast"()
    set $P5498, $P5504
  if_5499_end:
    $P5508 = $P5497."!make"($P5498)
.annotate 'line', 1994
    .return ($P5508)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "number"  :subid("543_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_5510
    .param pmc param_5511
.annotate 'line', 1998
    .lex "self", param_5510
    .lex "$/", param_5511
.annotate 'line', 1999
    new $P5512, "Undef"
    .lex "$value", $P5512
    find_lex $P5515, "$/"
    unless_null $P5515, vivify_2552
    $P5515 = root_new ['parrot';'Hash']
  vivify_2552:
    set $P5516, $P5515["dec_number"]
    unless_null $P5516, vivify_2553
    new $P5516, "Undef"
  vivify_2553:
    if $P5516, if_5514
    find_lex $P5520, "$/"
    unless_null $P5520, vivify_2554
    $P5520 = root_new ['parrot';'Hash']
  vivify_2554:
    set $P5521, $P5520["integer"]
    unless_null $P5521, vivify_2555
    new $P5521, "Undef"
  vivify_2555:
    $P5522 = $P5521."ast"()
    set $P5513, $P5522
    goto if_5514_end
  if_5514:
    find_lex $P5517, "$/"
    unless_null $P5517, vivify_2556
    $P5517 = root_new ['parrot';'Hash']
  vivify_2556:
    set $P5518, $P5517["dec_number"]
    unless_null $P5518, vivify_2557
    new $P5518, "Undef"
  vivify_2557:
    $P5519 = $P5518."ast"()
    set $P5513, $P5519
  if_5514_end:
    store_lex "$value", $P5513
.annotate 'line', 2000
    find_lex $P5524, "$/"
    unless_null $P5524, vivify_2558
    $P5524 = root_new ['parrot';'Hash']
  vivify_2558:
    set $P5525, $P5524["sign"]
    unless_null $P5525, vivify_2559
    new $P5525, "Undef"
  vivify_2559:
    set $S5526, $P5525
    iseq $I5527, $S5526, "-"
    unless $I5527, if_5523_end
    find_lex $P5528, "$value"
    unless_null $P5528, vivify_2560
    new $P5528, "Undef"
  vivify_2560:
    neg $P5529, $P5528
    store_lex "$value", $P5529
  if_5523_end:
.annotate 'line', 2001
    find_lex $P5530, "$/"
    get_hll_global $P5531, ["PAST"], "Val"
    find_lex $P5532, "$value"
    unless_null $P5532, vivify_2561
    new $P5532, "Undef"
  vivify_2561:
    $P5533 = $P5531."new"($P5532 :named("value"))
    $P5534 = $P5530."!make"($P5533)
.annotate 'line', 1998
    .return ($P5534)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<apos>"  :subid("544_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_5536
    .param pmc param_5537
.annotate 'line', 2004
    .lex "self", param_5536
    .lex "$/", param_5537
    find_lex $P5538, "$/"
    find_lex $P5539, "$/"
    unless_null $P5539, vivify_2562
    $P5539 = root_new ['parrot';'Hash']
  vivify_2562:
    set $P5540, $P5539["quote_EXPR"]
    unless_null $P5540, vivify_2563
    new $P5540, "Undef"
  vivify_2563:
    $P5541 = $P5540."ast"()
    $P5542 = $P5538."!make"($P5541)
    .return ($P5542)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<dblq>"  :subid("545_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_5544
    .param pmc param_5545
.annotate 'line', 2005
    .lex "self", param_5544
    .lex "$/", param_5545
    find_lex $P5546, "$/"
    find_lex $P5547, "$/"
    unless_null $P5547, vivify_2564
    $P5547 = root_new ['parrot';'Hash']
  vivify_2564:
    set $P5548, $P5547["quote_EXPR"]
    unless_null $P5548, vivify_2565
    new $P5548, "Undef"
  vivify_2565:
    $P5549 = $P5548."ast"()
    $P5550 = $P5546."!make"($P5549)
    .return ($P5550)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<qq>"  :subid("546_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_5552
    .param pmc param_5553
.annotate 'line', 2006
    .lex "self", param_5552
    .lex "$/", param_5553
    find_lex $P5554, "$/"
    find_lex $P5555, "$/"
    unless_null $P5555, vivify_2566
    $P5555 = root_new ['parrot';'Hash']
  vivify_2566:
    set $P5556, $P5555["quote_EXPR"]
    unless_null $P5556, vivify_2567
    new $P5556, "Undef"
  vivify_2567:
    $P5557 = $P5556."ast"()
    $P5558 = $P5554."!make"($P5557)
    .return ($P5558)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<q>"  :subid("547_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_5560
    .param pmc param_5561
.annotate 'line', 2007
    .lex "self", param_5560
    .lex "$/", param_5561
    find_lex $P5562, "$/"
    find_lex $P5563, "$/"
    unless_null $P5563, vivify_2568
    $P5563 = root_new ['parrot';'Hash']
  vivify_2568:
    set $P5564, $P5563["quote_EXPR"]
    unless_null $P5564, vivify_2569
    new $P5564, "Undef"
  vivify_2569:
    $P5565 = $P5564."ast"()
    $P5566 = $P5562."!make"($P5565)
    .return ($P5566)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q>"  :subid("548_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_5568
    .param pmc param_5569
.annotate 'line', 2008
    .lex "self", param_5568
    .lex "$/", param_5569
    find_lex $P5570, "$/"
    find_lex $P5571, "$/"
    unless_null $P5571, vivify_2570
    $P5571 = root_new ['parrot';'Hash']
  vivify_2570:
    set $P5572, $P5571["quote_EXPR"]
    unless_null $P5572, vivify_2571
    new $P5572, "Undef"
  vivify_2571:
    $P5573 = $P5572."ast"()
    $P5574 = $P5570."!make"($P5573)
    .return ($P5574)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q:PIR>"  :subid("549_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_5576
    .param pmc param_5577
.annotate 'line', 2009
    .lex "self", param_5576
    .lex "$/", param_5577
.annotate 'line', 2010
    find_lex $P5578, "$/"
    get_hll_global $P5579, ["PAST"], "Op"
    find_lex $P5580, "$/"
    unless_null $P5580, vivify_2572
    $P5580 = root_new ['parrot';'Hash']
  vivify_2572:
    set $P5581, $P5580["quote_EXPR"]
    unless_null $P5581, vivify_2573
    new $P5581, "Undef"
  vivify_2573:
    $P5582 = $P5581."ast"()
    $P5583 = $P5582."value"()
    find_lex $P5584, "$/"
    unless_null $P5584, vivify_2574
    new $P5584, "Undef"
  vivify_2574:
    $P5585 = $P5579."new"($P5583 :named("inline"), "inline" :named("pasttype"), $P5584 :named("node"))
    $P5586 = $P5578."!make"($P5585)
.annotate 'line', 2009
    .return ($P5586)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "quote:sym</ />"  :subid("550_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_5590
    .param pmc param_5591
    .param pmc param_5592 :optional
    .param int has_param_5592 :opt_flag
.annotate 'line', 2015
    new $P5589, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P5589, control_5588
    push_eh $P5589
    .lex "self", param_5590
    .lex "$/", param_5591
    if has_param_5592, optparam_2575
    new $P5593, "Undef"
    set param_5592, $P5593
  optparam_2575:
    .lex "$key", param_5592
.annotate 'line', 2022
    new $P5594, "Undef"
    .lex "$regex", $P5594
.annotate 'line', 2024
    new $P5595, "Undef"
    .lex "$past", $P5595
.annotate 'line', 2016
    find_lex $P5597, "$key"
    unless_null $P5597, vivify_2576
    new $P5597, "Undef"
  vivify_2576:
    set $S5598, $P5597
    iseq $I5599, $S5598, "open"
    unless $I5599, if_5596_end
.annotate 'line', 2017
    null $P5600
    get_hll_global $P5601, ["Regex";"P6Regex"], "Actions"
    get_who $P5602, $P5601
    set $P5602["$REGEXNAME"], $P5600
.annotate 'line', 2018
    find_lex $P5603, "$?PACKAGE"
    get_who $P5604, $P5603
    set $P5605, $P5604["@BLOCK"]
    unless_null $P5605, vivify_2577
    $P5605 = root_new ['parrot';'ResizablePMCArray']
  vivify_2577:
    set $P5606, $P5605[0]
    unless_null $P5606, vivify_2578
    new $P5606, "Undef"
  vivify_2578:
    $P5606."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 2019
    find_lex $P5607, "$?PACKAGE"
    get_who $P5608, $P5607
    set $P5609, $P5608["@BLOCK"]
    unless_null $P5609, vivify_2579
    $P5609 = root_new ['parrot';'ResizablePMCArray']
  vivify_2579:
    set $P5610, $P5609[0]
    unless_null $P5610, vivify_2580
    new $P5610, "Undef"
  vivify_2580:
    $P5610."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 2020
    new $P5611, "Exception"
    set $P5611['type'], .CONTROL_RETURN
    new $P5612, "Integer"
    assign $P5612, 0
    setattribute $P5611, 'payload', $P5612
    throw $P5611
  if_5596_end:
.annotate 'line', 2023
    get_hll_global $P5613, ["Regex";"P6Regex";"Actions"], "buildsub"
    find_lex $P5614, "$/"
    unless_null $P5614, vivify_2581
    $P5614 = root_new ['parrot';'Hash']
  vivify_2581:
    set $P5615, $P5614["p6regex"]
    unless_null $P5615, vivify_2582
    new $P5615, "Undef"
  vivify_2582:
    $P5616 = $P5615."ast"()
    find_lex $P5617, "$?PACKAGE"
    get_who $P5618, $P5617
    set $P5619, $P5618["@BLOCK"]
    unless_null $P5619, vivify_2583
    $P5619 = root_new ['parrot';'ResizablePMCArray']
  vivify_2583:
    $P5620 = $P5619."shift"()
    $P5621 = $P5613($P5616, $P5620)
    store_lex "$regex", $P5621
.annotate 'line', 2025
    get_hll_global $P5622, ["PAST"], "Op"
.annotate 'line', 2027
    get_hll_global $P5623, ["PAST"], "Var"
    new $P5624, "ResizablePMCArray"
    push $P5624, "Regex"
    $P5625 = $P5623."new"("Regex" :named("name"), $P5624 :named("namespace"), "package" :named("scope"))
    find_lex $P5626, "$regex"
    unless_null $P5626, vivify_2584
    new $P5626, "Undef"
  vivify_2584:
    $P5627 = $P5622."new"($P5625, $P5626, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 2025
    store_lex "$past", $P5627
.annotate 'line', 2031
    find_lex $P5628, "$regex"
    unless_null $P5628, vivify_2585
    new $P5628, "Undef"
  vivify_2585:
    find_lex $P5629, "$past"
    unless_null $P5629, vivify_2586
    $P5629 = root_new ['parrot';'Hash']
    store_lex "$past", $P5629
  vivify_2586:
    set $P5629["sink"], $P5628
.annotate 'line', 2032
    find_lex $P5630, "$/"
    find_lex $P5631, "$past"
    unless_null $P5631, vivify_2587
    new $P5631, "Undef"
  vivify_2587:
    $P5632 = $P5630."!make"($P5631)
.annotate 'line', 2015
    .return ($P5632)
  control_5588:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5633, exception, "payload"
    .return ($P5633)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<$>"  :subid("551_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_5635
    .param pmc param_5636
.annotate 'line', 2035
    .lex "self", param_5635
    .lex "$/", param_5636
    find_lex $P5637, "$/"
    find_lex $P5638, "$/"
    unless_null $P5638, vivify_2588
    $P5638 = root_new ['parrot';'Hash']
  vivify_2588:
    set $P5639, $P5638["variable"]
    unless_null $P5639, vivify_2589
    new $P5639, "Undef"
  vivify_2589:
    $P5640 = $P5639."ast"()
    $P5641 = $P5637."!make"($P5640)
    .return ($P5641)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<{ }>"  :subid("552_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_5643
    .param pmc param_5644
.annotate 'line', 2036
    .lex "self", param_5643
    .lex "$/", param_5644
.annotate 'line', 2037
    find_lex $P5645, "$/"
    get_hll_global $P5646, ["PAST"], "Op"
.annotate 'line', 2038
    find_lex $P5647, "$/"
    unless_null $P5647, vivify_2590
    $P5647 = root_new ['parrot';'Hash']
  vivify_2590:
    set $P5648, $P5647["block"]
    unless_null $P5648, vivify_2591
    new $P5648, "Undef"
  vivify_2591:
    $P5649 = $P5648."ast"()
    $P5650 = "block_immediate"($P5649)
    find_lex $P5651, "$/"
    unless_null $P5651, vivify_2592
    new $P5651, "Undef"
  vivify_2592:
    $P5652 = $P5646."new"($P5650, "set S*" :named("pirop"), $P5651 :named("node"))
.annotate 'line', 2037
    $P5653 = $P5645."!make"($P5652)
.annotate 'line', 2036
    .return ($P5653)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<esc>"  :subid("553_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_5655
    .param pmc param_5656
.annotate 'line', 2041
    .lex "self", param_5655
    .lex "$/", param_5656
    find_lex $P5657, "$/"
    $P5658 = $P5657."!make"("\e")
    .return ($P5658)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<.>"  :subid("554_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_5660
    .param pmc param_5661
.annotate 'line', 2045
    .lex "self", param_5660
    .lex "$/", param_5661
    find_lex $P5662, "$/"
    find_lex $P5663, "$/"
    unless_null $P5663, vivify_2593
    $P5663 = root_new ['parrot';'Hash']
  vivify_2593:
    set $P5664, $P5663["dotty"]
    unless_null $P5664, vivify_2594
    new $P5664, "Undef"
  vivify_2594:
    $P5665 = $P5664."ast"()
    $P5666 = $P5662."!make"($P5665)
    .return ($P5666)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<++>"  :subid("555_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_5668
    .param pmc param_5669
.annotate 'line', 2047
    .lex "self", param_5668
    .lex "$/", param_5669
.annotate 'line', 2048
    find_lex $P5670, "$/"
    get_hll_global $P5671, ["PAST"], "Op"
.annotate 'line', 2049
    new $P5672, "ResizablePMCArray"
    push $P5672, "    clone %r, %0"
    push $P5672, "    inc %0"
    $P5673 = $P5671."new"("postfix:<++>" :named("name"), $P5672 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 2048
    $P5674 = $P5670."!make"($P5673)
.annotate 'line', 2047
    .return ($P5674)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<-->"  :subid("556_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_5676
    .param pmc param_5677
.annotate 'line', 2053
    .lex "self", param_5676
    .lex "$/", param_5677
.annotate 'line', 2054
    find_lex $P5678, "$/"
    get_hll_global $P5679, ["PAST"], "Op"
.annotate 'line', 2055
    new $P5680, "ResizablePMCArray"
    push $P5680, "    clone %r, %0"
    push $P5680, "    dec %0"
    $P5681 = $P5679."new"("postfix:<-->" :named("name"), $P5680 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 2054
    $P5682 = $P5678."!make"($P5681)
.annotate 'line', 2053
    .return ($P5682)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "prefix:sym<make>"  :subid("557_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_5684
    .param pmc param_5685
.annotate 'line', 2059
    .lex "self", param_5684
    .lex "$/", param_5685
.annotate 'line', 2060
    find_lex $P5686, "$/"
    get_hll_global $P5687, ["PAST"], "Op"
.annotate 'line', 2061
    get_hll_global $P5688, ["PAST"], "Var"
    $P5689 = $P5688."new"("$/" :named("name"), "contextual" :named("scope"))
    find_lex $P5690, "$/"
    unless_null $P5690, vivify_2595
    new $P5690, "Undef"
  vivify_2595:
    $P5691 = $P5687."new"($P5689, "callmethod" :named("pasttype"), "!make" :named("name"), $P5690 :named("node"))
.annotate 'line', 2060
    $P5692 = $P5686."!make"($P5691)
.annotate 'line', 2059
    .return ($P5692)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<next>"  :subid("558_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_5695
    .param pmc param_5696
.annotate 'line', 2077
    .lex "self", param_5695
    .lex "$/", param_5696
    find_lex $P5697, "$/"
    unless_null $P5697, vivify_2596
    new $P5697, "Undef"
  vivify_2596:
    $P5698 = "control"($P5697, "CONTROL_LOOP_NEXT")
    .return ($P5698)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<last>"  :subid("559_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_5700
    .param pmc param_5701
.annotate 'line', 2078
    .lex "self", param_5700
    .lex "$/", param_5701
    find_lex $P5702, "$/"
    unless_null $P5702, vivify_2597
    new $P5702, "Undef"
  vivify_2597:
    $P5703 = "control"($P5702, "CONTROL_LOOP_LAST")
    .return ($P5703)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<redo>"  :subid("560_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_5705
    .param pmc param_5706
.annotate 'line', 2079
    .lex "self", param_5705
    .lex "$/", param_5706
    find_lex $P5707, "$/"
    unless_null $P5707, vivify_2598
    new $P5707, "Undef"
  vivify_2598:
    $P5708 = "control"($P5707, "CONTROL_LOOP_REDO")
    .return ($P5708)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "infix:sym<~~>"  :subid("561_1303340952.947") :outer("407_1303340952.947")
    .param pmc param_5710
    .param pmc param_5711
.annotate 'line', 2081
    .lex "self", param_5710
    .lex "$/", param_5711
.annotate 'line', 2082
    find_lex $P5712, "$/"
    get_hll_global $P5713, ["PAST"], "Op"
    find_lex $P5714, "$/"
    unless_null $P5714, vivify_2599
    new $P5714, "Undef"
  vivify_2599:
    $P5715 = $P5713."new"("callmethod" :named("pasttype"), "ACCEPTS" :named("name"), $P5714 :named("node"))
    $P5716 = $P5712."!make"($P5715)
.annotate 'line', 2081
    .return ($P5716)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "_block5946"  :subid("563_1303340952.947") :outer("10_1303340952.947")
.annotate 'line', 2159
    .const 'Sub' $P6047 = "571_1303340952.947" 
    capture_lex $P6047
    .const 'Sub' $P6022 = "570_1303340952.947" 
    capture_lex $P6022
    .const 'Sub' $P6011 = "569_1303340952.947" 
    capture_lex $P6011
    .const 'Sub' $P5996 = "568_1303340952.947" 
    capture_lex $P5996
    .const 'Sub' $P5985 = "567_1303340952.947" 
    capture_lex $P5985
    .const 'Sub' $P5974 = "566_1303340952.947" 
    capture_lex $P5974
    .const 'Sub' $P5963 = "565_1303340952.947" 
    capture_lex $P5963
    .const 'Sub' $P5950 = "564_1303340952.947" 
    capture_lex $P5950
    .lex "$?PACKAGE", $P5948
    .lex "$?CLASS", $P5949
.annotate 'line', 2193
    .const 'Sub' $P6022 = "570_1303340952.947" 
    newclosure $P6045, $P6022
.annotate 'line', 2159
    .return ($P6045)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "" :load :init :subid("post2600") :outer("563_1303340952.947")
.annotate 'line', 2159
    get_hll_global $P5947, ["NQP";"RegexActions"], "_block5946" 
    .local pmc block
    set block, $P5947
    .const 'Sub' $P6047 = "571_1303340952.947" 
    capture_lex $P6047
    $P6047()
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "_block6046"  :anon :subid("571_1303340952.947") :outer("563_1303340952.947")
.annotate 'line', 2159
    nqp_get_sc_object $P6048, "1303340942.153", 4
    .local pmc type_obj
    set type_obj, $P6048
    get_how $P6049, type_obj
    .const 'Sub' $P6050 = "564_1303340952.947" 
    $P6049."add_method"(type_obj, "metachar:sym<:my>", $P6050)
    get_how $P6051, type_obj
    .const 'Sub' $P6052 = "565_1303340952.947" 
    $P6051."add_method"(type_obj, "metachar:sym<{ }>", $P6052)
    get_how $P6053, type_obj
    .const 'Sub' $P6054 = "566_1303340952.947" 
    $P6053."add_method"(type_obj, "metachar:sym<nqpvar>", $P6054)
    get_how $P6055, type_obj
    .const 'Sub' $P6056 = "567_1303340952.947" 
    $P6055."add_method"(type_obj, "assertion:sym<{ }>", $P6056)
    get_how $P6057, type_obj
    .const 'Sub' $P6058 = "568_1303340952.947" 
    $P6057."add_method"(type_obj, "assertion:sym<?{ }>", $P6058)
    get_how $P6059, type_obj
    .const 'Sub' $P6060 = "569_1303340952.947" 
    $P6059."add_method"(type_obj, "assertion:sym<var>", $P6060)
    get_how $P6061, type_obj
    .const 'Sub' $P6062 = "570_1303340952.947" 
    $P6061."add_method"(type_obj, "codeblock", $P6062)
    get_how $P6063, type_obj
    get_hll_global $P6064, ["Regex";"P6Regex"], "Actions"
    $P6063."add_parent"(type_obj, $P6064)
    get_how $P6065, type_obj
    $P6066 = $P6065."compose"(type_obj)
    .return ($P6066)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<:my>"  :subid("564_1303340952.947") :outer("563_1303340952.947")
    .param pmc param_5951
    .param pmc param_5952
.annotate 'line', 2161
    .lex "self", param_5951
    .lex "$/", param_5952
.annotate 'line', 2162
    new $P5953, "Undef"
    .lex "$past", $P5953
    find_lex $P5954, "$/"
    unless_null $P5954, vivify_2601
    $P5954 = root_new ['parrot';'Hash']
  vivify_2601:
    set $P5955, $P5954["statement"]
    unless_null $P5955, vivify_2602
    new $P5955, "Undef"
  vivify_2602:
    $P5956 = $P5955."ast"()
    store_lex "$past", $P5956
.annotate 'line', 2163
    find_lex $P5957, "$/"
    get_hll_global $P5958, ["PAST"], "Regex"
    find_lex $P5959, "$past"
    unless_null $P5959, vivify_2603
    new $P5959, "Undef"
  vivify_2603:
    find_lex $P5960, "$/"
    unless_null $P5960, vivify_2604
    new $P5960, "Undef"
  vivify_2604:
    $P5961 = $P5958."new"($P5959, "pastnode" :named("pasttype"), "declarative" :named("subtype"), $P5960 :named("node"))
    $P5962 = $P5957."!make"($P5961)
.annotate 'line', 2161
    .return ($P5962)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<{ }>"  :subid("565_1303340952.947") :outer("563_1303340952.947")
    .param pmc param_5964
    .param pmc param_5965
.annotate 'line', 2167
    .lex "self", param_5964
    .lex "$/", param_5965
.annotate 'line', 2168
    find_lex $P5966, "$/"
    get_hll_global $P5967, ["PAST"], "Regex"
    find_lex $P5968, "$/"
    unless_null $P5968, vivify_2605
    $P5968 = root_new ['parrot';'Hash']
  vivify_2605:
    set $P5969, $P5968["codeblock"]
    unless_null $P5969, vivify_2606
    new $P5969, "Undef"
  vivify_2606:
    $P5970 = $P5969."ast"()
    find_lex $P5971, "$/"
    unless_null $P5971, vivify_2607
    new $P5971, "Undef"
  vivify_2607:
    $P5972 = $P5967."new"($P5970, "pastnode" :named("pasttype"), $P5971 :named("node"))
    $P5973 = $P5966."!make"($P5972)
.annotate 'line', 2167
    .return ($P5973)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<nqpvar>"  :subid("566_1303340952.947") :outer("563_1303340952.947")
    .param pmc param_5975
    .param pmc param_5976
.annotate 'line', 2172
    .lex "self", param_5975
    .lex "$/", param_5976
.annotate 'line', 2173
    find_lex $P5977, "$/"
    get_hll_global $P5978, ["PAST"], "Regex"
    find_lex $P5979, "$/"
    unless_null $P5979, vivify_2608
    $P5979 = root_new ['parrot';'Hash']
  vivify_2608:
    set $P5980, $P5979["var"]
    unless_null $P5980, vivify_2609
    new $P5980, "Undef"
  vivify_2609:
    $P5981 = $P5980."ast"()
    find_lex $P5982, "$/"
    unless_null $P5982, vivify_2610
    new $P5982, "Undef"
  vivify_2610:
    $P5983 = $P5978."new"("!INTERPOLATE", $P5981, "subrule" :named("pasttype"), "method" :named("subtype"), $P5982 :named("node"))
    $P5984 = $P5977."!make"($P5983)
.annotate 'line', 2172
    .return ($P5984)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<{ }>"  :subid("567_1303340952.947") :outer("563_1303340952.947")
    .param pmc param_5986
    .param pmc param_5987
.annotate 'line', 2177
    .lex "self", param_5986
    .lex "$/", param_5987
.annotate 'line', 2178
    find_lex $P5988, "$/"
    get_hll_global $P5989, ["PAST"], "Regex"
    find_lex $P5990, "$/"
    unless_null $P5990, vivify_2611
    $P5990 = root_new ['parrot';'Hash']
  vivify_2611:
    set $P5991, $P5990["codeblock"]
    unless_null $P5991, vivify_2612
    new $P5991, "Undef"
  vivify_2612:
    $P5992 = $P5991."ast"()
    find_lex $P5993, "$/"
    unless_null $P5993, vivify_2613
    new $P5993, "Undef"
  vivify_2613:
    $P5994 = $P5989."new"("!INTERPOLATE_REGEX", $P5992, "subrule" :named("pasttype"), "method" :named("subtype"), $P5993 :named("node"))
    $P5995 = $P5988."!make"($P5994)
.annotate 'line', 2177
    .return ($P5995)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<?{ }>"  :subid("568_1303340952.947") :outer("563_1303340952.947")
    .param pmc param_5997
    .param pmc param_5998
.annotate 'line', 2182
    .lex "self", param_5997
    .lex "$/", param_5998
.annotate 'line', 2183
    find_lex $P5999, "$/"
    get_hll_global $P6000, ["PAST"], "Regex"
    find_lex $P6001, "$/"
    unless_null $P6001, vivify_2614
    $P6001 = root_new ['parrot';'Hash']
  vivify_2614:
    set $P6002, $P6001["codeblock"]
    unless_null $P6002, vivify_2615
    new $P6002, "Undef"
  vivify_2615:
    $P6003 = $P6002."ast"()
.annotate 'line', 2184
    find_lex $P6004, "$/"
    unless_null $P6004, vivify_2616
    $P6004 = root_new ['parrot';'Hash']
  vivify_2616:
    set $P6005, $P6004["zw"]
    unless_null $P6005, vivify_2617
    new $P6005, "Undef"
  vivify_2617:
    set $S6006, $P6005
    iseq $I6007, $S6006, "!"
    find_lex $P6008, "$/"
    unless_null $P6008, vivify_2618
    new $P6008, "Undef"
  vivify_2618:
    $P6009 = $P6000."new"($P6003, "zerowidth" :named("subtype"), $I6007 :named("negate"), "pastnode" :named("pasttype"), $P6008 :named("node"))
.annotate 'line', 2183
    $P6010 = $P5999."!make"($P6009)
.annotate 'line', 2182
    .return ($P6010)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<var>"  :subid("569_1303340952.947") :outer("563_1303340952.947")
    .param pmc param_6012
    .param pmc param_6013
.annotate 'line', 2188
    .lex "self", param_6012
    .lex "$/", param_6013
.annotate 'line', 2189
    find_lex $P6014, "$/"
    get_hll_global $P6015, ["PAST"], "Regex"
    find_lex $P6016, "$/"
    unless_null $P6016, vivify_2619
    $P6016 = root_new ['parrot';'Hash']
  vivify_2619:
    set $P6017, $P6016["var"]
    unless_null $P6017, vivify_2620
    new $P6017, "Undef"
  vivify_2620:
    $P6018 = $P6017."ast"()
    find_lex $P6019, "$/"
    unless_null $P6019, vivify_2621
    new $P6019, "Undef"
  vivify_2621:
    $P6020 = $P6015."new"("!INTERPOLATE_REGEX", $P6018, "subrule" :named("pasttype"), "method" :named("subtype"), $P6019 :named("node"))
    $P6021 = $P6014."!make"($P6020)
.annotate 'line', 2188
    .return ($P6021)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "codeblock"  :subid("570_1303340952.947") :outer("563_1303340952.947")
    .param pmc param_6023
    .param pmc param_6024
.annotate 'line', 2193
    .lex "self", param_6023
    .lex "$/", param_6024
.annotate 'line', 2194
    new $P6025, "Undef"
    .lex "$block", $P6025
.annotate 'line', 2196
    new $P6026, "Undef"
    .lex "$past", $P6026
.annotate 'line', 2194
    find_lex $P6027, "$/"
    unless_null $P6027, vivify_2622
    $P6027 = root_new ['parrot';'Hash']
  vivify_2622:
    set $P6028, $P6027["block"]
    unless_null $P6028, vivify_2623
    new $P6028, "Undef"
  vivify_2623:
    $P6029 = $P6028."ast"()
    store_lex "$block", $P6029
.annotate 'line', 2195
    find_lex $P6030, "$block"
    unless_null $P6030, vivify_2624
    new $P6030, "Undef"
  vivify_2624:
    $P6030."blocktype"("immediate")
.annotate 'line', 2197
    get_hll_global $P6031, ["PAST"], "Stmts"
.annotate 'line', 2198
    get_hll_global $P6032, ["PAST"], "Op"
.annotate 'line', 2199
    get_hll_global $P6033, ["PAST"], "Var"
    $P6034 = $P6033."new"("$/" :named("name"))
.annotate 'line', 2200
    get_hll_global $P6035, ["PAST"], "Op"
.annotate 'line', 2201
    get_hll_global $P6036, ["PAST"], "Var"
    $P6037 = $P6036."new"(unicode:"$\x{a2}" :named("name"))
    $P6038 = $P6035."new"($P6037, "MATCH" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 2200
    $P6039 = $P6032."new"($P6034, $P6038, "bind" :named("pasttype"))
.annotate 'line', 2198
    find_lex $P6040, "$block"
    unless_null $P6040, vivify_2625
    new $P6040, "Undef"
  vivify_2625:
    $P6041 = $P6031."new"($P6039, $P6040)
.annotate 'line', 2197
    store_lex "$past", $P6041
.annotate 'line', 2209
    find_lex $P6042, "$/"
    find_lex $P6043, "$past"
    unless_null $P6043, vivify_2626
    new $P6043, "Undef"
  vivify_2626:
    $P6044 = $P6042."!make"($P6043)
.annotate 'line', 2193
    .return ($P6044)
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "_block6067"  :subid("572_1303340952.947") :outer("10_1303340952.947")
.annotate 'line', 2214
    .const 'Sub' $P6072 = "573_1303340952.947" 
    capture_lex $P6072
    .lex "$?PACKAGE", $P6069
    .lex "$?CLASS", $P6070
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "" :load :init :subid("post2627") :outer("572_1303340952.947")
.annotate 'line', 2214
    get_hll_global $P6068, ["NQP";"Compiler"], "_block6067" 
    .local pmc block
    set block, $P6068
    .const 'Sub' $P6072 = "573_1303340952.947" 
    capture_lex $P6072
    $P6072()
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "_block6071"  :anon :subid("573_1303340952.947") :outer("572_1303340952.947")
.annotate 'line', 2214
    nqp_get_sc_object $P6073, "1303340942.153", 5
    .local pmc type_obj
    set type_obj, $P6073
    get_how $P6074, type_obj
    get_hll_global $P6075, ["HLL"], "Compiler"
    $P6074."add_parent"(type_obj, $P6075)
    get_how $P6076, type_obj
    $P6077 = $P6076."compose"(type_obj)
    .return ($P6077)
.end


.HLL "nqp"

.namespace []
.sub "_block6085" :load :anon :subid("574_1303340952.947")
.annotate 'line', 1
    .const 'Sub' $P6087 = "10_1303340952.947" 
    $P6088 = $P6087()
    .return ($P6088)
.end

