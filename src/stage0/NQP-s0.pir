# Copyright (C) 2009, The Perl Foundation.

=head1 NAME

NQP::Compiler - NQP compiler

=head1 DESCRIPTION

=cut

# Initialize meta-model.
.loadlib "nqp_group"
.loadlib "nqp_ops"
.sub '' :anon :load :init
    nqp_dynop_setup
.end
### .include 'gen/nqp-how.pir'

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1298325424.79949")
.annotate 'line', 0
    get_hll_global $P2796, ["str"], "_block2795" 
    capture_lex $P2796
    get_hll_global $P2787, ["num"], "_block2786" 
    capture_lex $P2787
    get_hll_global $P2778, ["int"], "_block2777" 
    capture_lex $P2778
    get_hll_global $P2624, ["NQPMu"], "_block2623" 
    capture_lex $P2624
    get_hll_global $P2535, ["NQPModuleHOW"], "_block2534" 
    capture_lex $P2535
    get_hll_global $P2305, ["RoleToRoleApplier"], "_block2304" 
    capture_lex $P2305
    get_hll_global $P2089, ["RoleToClassApplier"], "_block2088" 
    capture_lex $P2089
    get_hll_global $P1733, ["NQPParametricRoleHOW"], "_block1732" 
    capture_lex $P1733
    get_hll_global $P1411, ["NQPConcreteRoleHOW"], "_block1410" 
    capture_lex $P1411
    get_hll_global $P1199, ["NQPAttribute"], "_block1198" 
    capture_lex $P1199
    get_hll_global $P1111, ["NQPNativeHOW"], "_block1110" 
    capture_lex $P1111
    get_hll_global $P53, ["NQPClassHOW"], "_block52" 
    capture_lex $P53
    get_hll_global $P27, ["KnowHOWAttribute"], "_block26" 
    capture_lex $P27
.annotate 'line', 1
    nqp_dynop_setup 
    get_hll_global $P13, "str"
    get_hll_global $P14, "num"
    get_hll_global $P15, "int"
    get_hll_global $P16, "NQPMu"
    get_hll_global $P17, "NQPModuleHOW"
    get_hll_global $P18, "RoleToRoleApplier"
    get_hll_global $P19, "RoleToClassApplier"
    get_hll_global $P20, "NQPParametricRoleHOW"
    get_hll_global $P21, "NQPConcreteRoleHOW"
    get_hll_global $P22, "NQPAttribute"
    get_hll_global $P23, "NQPNativeHOW"
    get_hll_global $P24, "NQPClassHOW"
    get_hll_global $P25, "KnowHOWAttribute"
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
.annotate 'line', 10
    get_hll_global $P27, ["KnowHOWAttribute"], "_block26" 
    capture_lex $P27
    $P27()
.annotate 'line', 26
    get_hll_global $P53, ["NQPClassHOW"], "_block52" 
    capture_lex $P53
    $P53()
.annotate 'line', 454
    get_hll_global $P1111, ["NQPNativeHOW"], "_block1110" 
    capture_lex $P1111
    $P1111()
.annotate 'line', 498
    get_hll_global $P1199, ["NQPAttribute"], "_block1198" 
    capture_lex $P1199
    $P1199()
.annotate 'line', 571
    get_hll_global $P1411, ["NQPConcreteRoleHOW"], "_block1410" 
    capture_lex $P1411
    $P1411()
.annotate 'line', 720
    get_hll_global $P1733, ["NQPParametricRoleHOW"], "_block1732" 
    capture_lex $P1733
    $P1733()
.annotate 'line', 886
    get_hll_global $P2089, ["RoleToClassApplier"], "_block2088" 
    capture_lex $P2089
    $P2089()
.annotate 'line', 958
    get_hll_global $P2305, ["RoleToRoleApplier"], "_block2304" 
    capture_lex $P2305
    $P2305()
.annotate 'line', 1048
    get_hll_global $P2535, ["NQPModuleHOW"], "_block2534" 
    capture_lex $P2535
    $P2535()
.annotate 'line', 1093
    get_hll_global $P2624, ["NQPMu"], "_block2623" 
    capture_lex $P2624
    $P2624()
.annotate 'line', 1142
    get_hll_global $P2778, ["int"], "_block2777" 
    capture_lex $P2778
    $P2778()
.annotate 'line', 1144
    get_hll_global $P2787, ["num"], "_block2786" 
    capture_lex $P2787
    $P2787()
.annotate 'line', 1146
    get_hll_global $P2796, ["str"], "_block2795" 
    capture_lex $P2796
    $P2804 = $P2796()
.annotate 'line', 1
    .return ($P2804)
    .const 'Sub' $P2806 = "194_1298325424.79949" 
    .return ($P2806)
.end


.namespace ["KnowHOWAttribute"]
.sub "_block26"  :subid("11_1298325424.79949") :outer("10_1298325424.79949")
.annotate 'line', 10
    .const 'Sub' $P43 = "14_1298325424.79949" 
    capture_lex $P43
    .const 'Sub' $P37 = "13_1298325424.79949" 
    capture_lex $P37
    .const 'Sub' $P29 = "12_1298325424.79949" 
    capture_lex $P29
    get_global $P28, "$?CLASS"
.annotate 'line', 14
    .const 'Sub' $P37 = "13_1298325424.79949" 
    newclosure $P41, $P37
.annotate 'line', 10
    .return ($P41)
.end


.namespace ["KnowHOWAttribute"]
.sub "" :load :init :subid("post195") :outer("11_1298325424.79949")
.annotate 'line', 10
    get_hll_global $P27, ["KnowHOWAttribute"], "_block26" 
    .local pmc block
    set block, $P27
    .const 'Sub' $P43 = "14_1298325424.79949" 
    capture_lex $P43
    $P43()
.end


.namespace ["KnowHOWAttribute"]
.sub "_block42"  :anon :subid("14_1298325424.79949") :outer("11_1298325424.79949")
.annotate 'line', 10
    get_hll_global $P44, "KnowHOW"
    $P45 = $P44."new_type"("KnowHOWAttribute" :named("name"), "P6str" :named("repr"))
    .local pmc type_obj
    set type_obj, $P45
    set_hll_global "KnowHOWAttribute", type_obj
    set_global "$?CLASS", type_obj
    get_how $P46, type_obj
    .const 'Sub' $P47 = "12_1298325424.79949" 
    $P46."add_method"(type_obj, "new", $P47)
    get_how $P48, type_obj
    .const 'Sub' $P49 = "13_1298325424.79949" 
    $P48."add_method"(type_obj, "name", $P49)
    get_how $P50, type_obj
    $P51 = $P50."compose"(type_obj)
    .return ($P51)
.end


.namespace ["KnowHOWAttribute"]
.sub "new"  :subid("12_1298325424.79949") :outer("11_1298325424.79949")
    .param pmc param_30
    .param pmc param_31 :optional :named("name")
    .param int has_param_31 :opt_flag
.annotate 'line', 11
    .lex "self", param_30
    if has_param_31, optparam_196
    new $P32, "Undef"
    set param_31, $P32
  optparam_196:
    .lex "$name", param_31
.annotate 'line', 12
    find_lex $P33, "$name"
    set $S34, $P33
    get_hll_global $P35, "KnowHOWAttribute"
    repr_box_str $P36, $S34, $P35
.annotate 'line', 11
    .return ($P36)
.end


.namespace ["KnowHOWAttribute"]
.sub "name"  :subid("13_1298325424.79949") :outer("11_1298325424.79949")
    .param pmc param_38
.annotate 'line', 14
    .lex "self", param_38
.annotate 'line', 15
    find_lex $P39, "self"
    repr_unbox_str $S40, $P39
.annotate 'line', 14
    .return ($S40)
.end


.namespace ["NQPClassHOW"]
.sub "_block52"  :subid("15_1298325424.79949") :outer("10_1298325424.79949")
.annotate 'line', 26
    .const 'Sub' $P1019 = "70_1298325424.79949" 
    capture_lex $P1019
    .const 'Sub' $P982 = "68_1298325424.79949" 
    capture_lex $P982
    .const 'Sub' $P946 = "66_1298325424.79949" 
    capture_lex $P946
    .const 'Sub' $P912 = "65_1298325424.79949" 
    capture_lex $P912
    .const 'Sub' $P875 = "64_1298325424.79949" 
    capture_lex $P875
    .const 'Sub' $P868 = "63_1298325424.79949" 
    capture_lex $P868
    .const 'Sub' $P845 = "61_1298325424.79949" 
    capture_lex $P845
    .const 'Sub' $P839 = "60_1298325424.79949" 
    capture_lex $P839
    .const 'Sub' $P833 = "59_1298325424.79949" 
    capture_lex $P833
    .const 'Sub' $P810 = "57_1298325424.79949" 
    capture_lex $P810
    .const 'Sub' $P803 = "56_1298325424.79949" 
    capture_lex $P803
    .const 'Sub' $P789 = "55_1298325424.79949" 
    capture_lex $P789
    .const 'Sub' $P740 = "52_1298325424.79949" 
    capture_lex $P740
    .const 'Sub' $P695 = "49_1298325424.79949" 
    capture_lex $P695
    .const 'Sub' $P658 = "46_1298325424.79949" 
    capture_lex $P658
    .const 'Sub' $P528 = "41_1298325424.79949" 
    capture_lex $P528
    .const 'Sub' $P424 = "37_1298325424.79949" 
    capture_lex $P424
    .const 'Sub' $P398 = "36_1298325424.79949" 
    capture_lex $P398
    .const 'Sub' $P364 = "34_1298325424.79949" 
    capture_lex $P364
    .const 'Sub' $P326 = "32_1298325424.79949" 
    capture_lex $P326
    .const 'Sub' $P305 = "31_1298325424.79949" 
    capture_lex $P305
    .const 'Sub' $P284 = "30_1298325424.79949" 
    capture_lex $P284
    .const 'Sub' $P265 = "29_1298325424.79949" 
    capture_lex $P265
    .const 'Sub' $P251 = "28_1298325424.79949" 
    capture_lex $P251
    .const 'Sub' $P244 = "27_1298325424.79949" 
    capture_lex $P244
    .const 'Sub' $P234 = "26_1298325424.79949" 
    capture_lex $P234
    .const 'Sub' $P97 = "19_1298325424.79949" 
    capture_lex $P97
    .const 'Sub' $P55 = "16_1298325424.79949" 
    capture_lex $P55
    get_global $P54, "$?CLASS"
.annotate 'line', 235
    .const 'Sub' $P55 = "16_1298325424.79949" 
    newclosure $P96, $P55
    .lex "compute_c3_mro", $P96
.annotate 'line', 257
    .const 'Sub' $P97 = "19_1298325424.79949" 
    newclosure $P233, $P97
    .lex "c3_merge", $P233
.annotate 'line', 181
    find_lex $P656, "compute_c3_mro"
    find_lex $P657, "c3_merge"
.annotate 'line', 441
    .const 'Sub' $P982 = "68_1298325424.79949" 
    newclosure $P1017, $P982
.annotate 'line', 26
    .return ($P1017)
.end


.namespace ["NQPClassHOW"]
.sub "" :load :init :subid("post197") :outer("15_1298325424.79949")
.annotate 'line', 26
    get_hll_global $P53, ["NQPClassHOW"], "_block52" 
    .local pmc block
    set block, $P53
    .const 'Sub' $P1019 = "70_1298325424.79949" 
    capture_lex $P1019
    $P1019()
.end


.namespace ["NQPClassHOW"]
.sub "_block1018"  :anon :subid("70_1298325424.79949") :outer("15_1298325424.79949")
.annotate 'line', 26
    get_hll_global $P1020, "KnowHOW"
    $P1021 = $P1020."new_type"("NQPClassHOW" :named("name"))
    .local pmc type_obj
    set type_obj, $P1021
    set_hll_global "NQPClassHOW", type_obj
    set_global "$?CLASS", type_obj
    get_how $P1022, type_obj
    get_hll_global $P1023, "KnowHOWAttribute"
    $P1024 = $P1023."new"("$!name" :named("name"))
    $P1022."add_attribute"(type_obj, $P1024)
    get_how $P1025, type_obj
    get_hll_global $P1026, "KnowHOWAttribute"
    $P1027 = $P1026."new"("%!attributes" :named("name"))
    $P1025."add_attribute"(type_obj, $P1027)
    get_how $P1028, type_obj
    get_hll_global $P1029, "KnowHOWAttribute"
    $P1030 = $P1029."new"("%!methods" :named("name"))
    $P1028."add_attribute"(type_obj, $P1030)
    get_how $P1031, type_obj
    get_hll_global $P1032, "KnowHOWAttribute"
    $P1033 = $P1032."new"("@!multi_methods_to_incorporate" :named("name"))
    $P1031."add_attribute"(type_obj, $P1033)
    get_how $P1034, type_obj
    get_hll_global $P1035, "KnowHOWAttribute"
    $P1036 = $P1035."new"("@!parents" :named("name"))
    $P1034."add_attribute"(type_obj, $P1036)
    get_how $P1037, type_obj
    get_hll_global $P1038, "KnowHOWAttribute"
    $P1039 = $P1038."new"("@!roles" :named("name"))
    $P1037."add_attribute"(type_obj, $P1039)
    get_how $P1040, type_obj
    get_hll_global $P1041, "KnowHOWAttribute"
    $P1042 = $P1041."new"("@!vtable" :named("name"))
    $P1040."add_attribute"(type_obj, $P1042)
    get_how $P1043, type_obj
    get_hll_global $P1044, "KnowHOWAttribute"
    $P1045 = $P1044."new"("%!method-vtable-slots" :named("name"))
    $P1043."add_attribute"(type_obj, $P1045)
    get_how $P1046, type_obj
    get_hll_global $P1047, "KnowHOWAttribute"
    $P1048 = $P1047."new"("$!composed" :named("name"))
    $P1046."add_attribute"(type_obj, $P1048)
    get_how $P1049, type_obj
    get_hll_global $P1050, "KnowHOWAttribute"
    $P1051 = $P1050."new"("@!mro" :named("name"))
    $P1049."add_attribute"(type_obj, $P1051)
    get_how $P1052, type_obj
    get_hll_global $P1053, "KnowHOWAttribute"
    $P1054 = $P1053."new"("@!done" :named("name"))
    $P1052."add_attribute"(type_obj, $P1054)
    get_how $P1055, type_obj
    get_hll_global $P1056, "KnowHOWAttribute"
    $P1057 = $P1056."new"("%!parrot_vtable_mapping" :named("name"))
    $P1055."add_attribute"(type_obj, $P1057)
    get_how $P1058, type_obj
    .const 'Sub' $P1059 = "26_1298325424.79949" 
    $P1058."add_method"(type_obj, "new", $P1059)
    get_how $P1060, type_obj
    .const 'Sub' $P1061 = "27_1298325424.79949" 
    $P1060."add_method"(type_obj, "BUILD", $P1061)
    get_how $P1062, type_obj
    .const 'Sub' $P1063 = "28_1298325424.79949" 
    $P1062."add_method"(type_obj, "new_type", $P1063)
    get_how $P1064, type_obj
    .const 'Sub' $P1065 = "29_1298325424.79949" 
    $P1064."add_method"(type_obj, "add_method", $P1065)
    get_how $P1066, type_obj
    .const 'Sub' $P1067 = "30_1298325424.79949" 
    $P1066."add_method"(type_obj, "add_multi_method", $P1067)
    get_how $P1068, type_obj
    .const 'Sub' $P1069 = "31_1298325424.79949" 
    $P1068."add_method"(type_obj, "add_attribute", $P1069)
    get_how $P1070, type_obj
    .const 'Sub' $P1071 = "32_1298325424.79949" 
    $P1070."add_method"(type_obj, "add_parent", $P1071)
    get_how $P1072, type_obj
    .const 'Sub' $P1073 = "34_1298325424.79949" 
    $P1072."add_method"(type_obj, "add_role", $P1073)
    get_how $P1074, type_obj
    .const 'Sub' $P1075 = "36_1298325424.79949" 
    $P1074."add_method"(type_obj, "add_parrot_vtable_mapping", $P1075)
    get_how $P1076, type_obj
    .const 'Sub' $P1077 = "37_1298325424.79949" 
    $P1076."add_method"(type_obj, "compose", $P1077)
    get_how $P1078, type_obj
    .const 'Sub' $P1079 = "41_1298325424.79949" 
    $P1078."add_method"(type_obj, "incorporate_multi_candidates", $P1079)
    get_how $P1080, type_obj
    .const 'Sub' $P1081 = "46_1298325424.79949" 
    $P1080."add_method"(type_obj, "publish_type_cache", $P1081)
    get_how $P1082, type_obj
    .const 'Sub' $P1083 = "49_1298325424.79949" 
    $P1082."add_method"(type_obj, "publish_method_cache", $P1083)
    get_how $P1084, type_obj
    .const 'Sub' $P1085 = "52_1298325424.79949" 
    $P1084."add_method"(type_obj, "publish_parrot_vtable_mapping", $P1085)
    get_how $P1086, type_obj
    .const 'Sub' $P1087 = "55_1298325424.79949" 
    $P1086."add_method"(type_obj, "parents", $P1087)
    get_how $P1088, type_obj
    .const 'Sub' $P1089 = "56_1298325424.79949" 
    $P1088."add_method"(type_obj, "roles", $P1089)
    get_how $P1090, type_obj
    .const 'Sub' $P1091 = "57_1298325424.79949" 
    $P1090."add_method"(type_obj, "methods", $P1091)
    get_how $P1092, type_obj
    .const 'Sub' $P1093 = "59_1298325424.79949" 
    $P1092."add_method"(type_obj, "method_table", $P1093)
    get_how $P1094, type_obj
    .const 'Sub' $P1095 = "60_1298325424.79949" 
    $P1094."add_method"(type_obj, "name", $P1095)
    get_how $P1096, type_obj
    .const 'Sub' $P1097 = "61_1298325424.79949" 
    $P1096."add_method"(type_obj, "attributes", $P1097)
    get_how $P1098, type_obj
    .const 'Sub' $P1099 = "63_1298325424.79949" 
    $P1098."add_method"(type_obj, "parrot_vtable_mappings", $P1099)
    get_how $P1100, type_obj
    .const 'Sub' $P1101 = "64_1298325424.79949" 
    $P1100."add_method"(type_obj, "isa", $P1101)
    get_how $P1102, type_obj
    .const 'Sub' $P1103 = "65_1298325424.79949" 
    $P1102."add_method"(type_obj, "does", $P1103)
    get_how $P1104, type_obj
    .const 'Sub' $P1105 = "66_1298325424.79949" 
    $P1104."add_method"(type_obj, "can", $P1105)
    get_how $P1106, type_obj
    .const 'Sub' $P1107 = "68_1298325424.79949" 
    $P1106."add_method"(type_obj, "find_method", $P1107)
    get_how $P1108, type_obj
    $P1109 = $P1108."compose"(type_obj)
    .return ($P1109)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "compute_c3_mro"  :subid("16_1298325424.79949") :outer("15_1298325424.79949")
    .param pmc param_58
.annotate 'line', 235
    .const 'Sub' $P70 = "17_1298325424.79949" 
    capture_lex $P70
    new $P57, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P57, control_56
    push_eh $P57
    .lex "$class", param_58
.annotate 'line', 236
    $P59 = root_new ['parrot';'ResizablePMCArray']
    .lex "@immediate_parents", $P59
.annotate 'line', 239
    $P60 = root_new ['parrot';'ResizablePMCArray']
    .lex "@result", $P60
.annotate 'line', 236
    find_lex $P61, "$class"
    get_how $P62, $P61
    find_lex $P63, "$class"
    $P64 = $P62."parents"($P63, 1 :named("local"))
    store_lex "@immediate_parents", $P64
    find_lex $P65, "@result"
.annotate 'line', 240
    find_lex $P67, "@immediate_parents"
    set $N68, $P67
    unless $N68, if_66_end
    .const 'Sub' $P70 = "17_1298325424.79949" 
    capture_lex $P70
    $P70()
  if_66_end:
.annotate 'line', 252
    find_lex $P91, "@result"
    find_lex $P92, "$class"
    $P91."unshift"($P92)
.annotate 'line', 253
    new $P93, "Exception"
    set $P93['type'], .CONTROL_RETURN
    find_lex $P94, "@result"
    setattribute $P93, 'payload', $P94
    throw $P93
.annotate 'line', 235
    .return ()
  control_56:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P95, exception, "payload"
    .return ($P95)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block69"  :anon :subid("17_1298325424.79949") :outer("16_1298325424.79949")
.annotate 'line', 240
    .const 'Sub' $P78 = "18_1298325424.79949" 
    capture_lex $P78
.annotate 'line', 243
    $P71 = root_new ['parrot';'ResizablePMCArray']
    .lex "@merge_list", $P71
.annotate 'line', 240
    find_lex $P72, "@merge_list"
.annotate 'line', 244
    find_lex $P74, "@immediate_parents"
    defined $I75, $P74
    unless $I75, for_undef_198
    iter $P73, $P74
    new $P85, 'ExceptionHandler'
    set_label $P85, loop84_handler
    $P85."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P85
  loop84_test:
    unless $P73, loop84_done
    shift $P76, $P73
  loop84_redo:
    .const 'Sub' $P78 = "18_1298325424.79949" 
    capture_lex $P78
    $P78($P76)
  loop84_next:
    goto loop84_test
  loop84_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P86, exception, 'type'
    eq $P86, .CONTROL_LOOP_NEXT, loop84_next
    eq $P86, .CONTROL_LOOP_REDO, loop84_redo
  loop84_done:
    pop_eh 
  for_undef_198:
.annotate 'line', 247
    find_lex $P87, "@merge_list"
    find_lex $P88, "@immediate_parents"
    $P87."push"($P88)
.annotate 'line', 248
    find_lex $P89, "@merge_list"
    $P90 = "c3_merge"($P89)
    store_lex "@result", $P90
.annotate 'line', 240
    .return ($P90)
.end


.namespace ["NQPClassHOW"]
.sub "_block77"  :anon :subid("18_1298325424.79949") :outer("17_1298325424.79949")
    .param pmc param_79
.annotate 'line', 244
    .lex "$_", param_79
.annotate 'line', 245
    find_lex $P80, "@merge_list"
    find_lex $P81, "$_"
    $P82 = "compute_c3_mro"($P81)
    $P83 = $P80."push"($P82)
.annotate 'line', 244
    .return ($P83)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "c3_merge"  :subid("19_1298325424.79949") :outer("15_1298325424.79949")
    .param pmc param_100
.annotate 'line', 257
    .const 'Sub' $P193 = "24_1298325424.79949" 
    capture_lex $P193
    .const 'Sub' $P115 = "20_1298325424.79949" 
    capture_lex $P115
    new $P99, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P99, control_98
    push_eh $P99
    .lex "@merge_list", param_100
.annotate 'line', 258
    $P101 = root_new ['parrot';'ResizablePMCArray']
    .lex "@result", $P101
.annotate 'line', 259
    new $P102, "Undef"
    .lex "$accepted", $P102
.annotate 'line', 260
    new $P103, "Undef"
    .lex "$something_accepted", $P103
.annotate 'line', 261
    new $P104, "Undef"
    .lex "$cand_count", $P104
.annotate 'line', 304
    new $P105, "Undef"
    .lex "$i", $P105
.annotate 'line', 257
    find_lex $P106, "@result"
    find_lex $P107, "$accepted"
.annotate 'line', 260
    new $P108, "Integer"
    assign $P108, 0
    store_lex "$something_accepted", $P108
.annotate 'line', 261
    new $P109, "Integer"
    assign $P109, 0
    store_lex "$cand_count", $P109
.annotate 'line', 264
    find_lex $P111, "@merge_list"
    defined $I112, $P111
    unless $I112, for_undef_199
    iter $P110, $P111
    new $P176, 'ExceptionHandler'
    set_label $P176, loop175_handler
    $P176."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P176
  loop175_test:
    unless $P110, loop175_done
    shift $P113, $P110
  loop175_redo:
    .const 'Sub' $P115 = "20_1298325424.79949" 
    capture_lex $P115
    $P115($P113)
  loop175_next:
    goto loop175_test
  loop175_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P177, exception, 'type'
    eq $P177, .CONTROL_LOOP_NEXT, loop175_next
    eq $P177, .CONTROL_LOOP_REDO, loop175_redo
  loop175_done:
    pop_eh 
  for_undef_199:
.annotate 'line', 294
    find_lex $P179, "$cand_count"
    set $N180, $P179
    iseq $I181, $N180, 0.0
    unless $I181, if_178_end
.annotate 'line', 295
    new $P182, "Exception"
    set $P182['type'], .CONTROL_RETURN
    find_lex $P183, "@result"
    setattribute $P182, 'payload', $P183
    throw $P182
  if_178_end:
.annotate 'line', 299
    find_lex $P185, "$something_accepted"
    if $P185, unless_184_end
.annotate 'line', 300
    die "Could not build C3 linearization: ambiguous hierarchy"
  unless_184_end:
.annotate 'line', 304
    new $P186, "Integer"
    assign $P186, 0
    store_lex "$i", $P186
.annotate 'line', 305
    new $P224, 'ExceptionHandler'
    set_label $P224, loop223_handler
    $P224."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P224
  loop223_test:
    find_lex $P187, "$i"
    set $N188, $P187
    find_lex $P189, "@merge_list"
    set $N190, $P189
    islt $I191, $N188, $N190
    unless $I191, loop223_done
  loop223_redo:
    .const 'Sub' $P193 = "24_1298325424.79949" 
    capture_lex $P193
    $P193()
  loop223_next:
    goto loop223_test
  loop223_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P225, exception, 'type'
    eq $P225, .CONTROL_LOOP_NEXT, loop223_next
    eq $P225, .CONTROL_LOOP_REDO, loop223_redo
  loop223_done:
    pop_eh 
.annotate 'line', 318
    find_lex $P226, "@merge_list"
    $P227 = "c3_merge"($P226)
    store_lex "@result", $P227
.annotate 'line', 319
    find_lex $P228, "@result"
    find_lex $P229, "$accepted"
    $P228."unshift"($P229)
.annotate 'line', 320
    new $P230, "Exception"
    set $P230['type'], .CONTROL_RETURN
    find_lex $P231, "@result"
    setattribute $P230, 'payload', $P231
    throw $P230
.annotate 'line', 257
    .return ()
  control_98:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P232, exception, "payload"
    .return ($P232)
.end


.namespace ["NQPClassHOW"]
.sub "_block114"  :anon :subid("20_1298325424.79949") :outer("19_1298325424.79949")
    .param pmc param_117
.annotate 'line', 264
    .const 'Sub' $P124 = "21_1298325424.79949" 
    capture_lex $P124
.annotate 'line', 265
    $P116 = root_new ['parrot';'ResizablePMCArray']
    .lex "@cand_list", $P116
    .lex "$_", param_117
    find_lex $P118, "$_"
    store_lex "@cand_list", $P118
.annotate 'line', 266
    find_lex $P121, "@cand_list"
    set $N122, $P121
    if $N122, if_120
    new $P119, 'Float'
    set $P119, $N122
    goto if_120_end
  if_120:
    .const 'Sub' $P124 = "21_1298325424.79949" 
    capture_lex $P124
    $P174 = $P124()
    set $P119, $P174
  if_120_end:
.annotate 'line', 264
    .return ($P119)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block123"  :anon :subid("21_1298325424.79949") :outer("20_1298325424.79949")
.annotate 'line', 266
    .const 'Sub' $P137 = "22_1298325424.79949" 
    capture_lex $P137
.annotate 'line', 267
    new $P125, "Undef"
    .lex "$rejected", $P125
.annotate 'line', 268
    new $P126, "Undef"
    .lex "$cand_class", $P126
.annotate 'line', 267
    new $P127, "Integer"
    assign $P127, 0
    store_lex "$rejected", $P127
.annotate 'line', 268
    find_lex $P128, "@cand_list"
    unless_null $P128, vivify_200
    $P128 = root_new ['parrot';'ResizablePMCArray']
  vivify_200:
    set $P129, $P128[0]
    unless_null $P129, vivify_201
    new $P129, "Undef"
  vivify_201:
    store_lex "$cand_class", $P129
.annotate 'line', 269
    find_lex $P130, "$cand_count"
    add $P131, $P130, 1
    store_lex "$cand_count", $P131
.annotate 'line', 270
    find_lex $P133, "@merge_list"
    defined $I134, $P133
    unless $I134, for_undef_202
    iter $P132, $P133
    new $P172, 'ExceptionHandler'
    set_label $P172, loop171_handler
    $P172."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P172
  loop171_test:
    unless $P132, loop171_done
    shift $P135, $P132
  loop171_redo:
    .const 'Sub' $P137 = "22_1298325424.79949" 
    capture_lex $P137
    $P137($P135)
  loop171_next:
    goto loop171_test
  loop171_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P173, exception, 'type'
    eq $P173, .CONTROL_LOOP_NEXT, loop171_next
    eq $P173, .CONTROL_LOOP_REDO, loop171_redo
  loop171_done:
    pop_eh 
  for_undef_202:
.annotate 'line', 266
    .return ($P132)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block136"  :anon :subid("22_1298325424.79949") :outer("21_1298325424.79949")
    .param pmc param_138
.annotate 'line', 270
    .const 'Sub' $P144 = "23_1298325424.79949" 
    capture_lex $P144
    .lex "$_", param_138
.annotate 'line', 272
    find_lex $P140, "$_"
    find_lex $P141, "@cand_list"
    issame $I142, $P140, $P141
    if $I142, unless_139_end
    .const 'Sub' $P144 = "23_1298325424.79949" 
    capture_lex $P144
    $P144()
  unless_139_end:
.annotate 'line', 284
    find_lex $P167, "$rejected"
    unless $P167, unless_166
    set $P165, $P167
    goto unless_166_end
  unless_166:
.annotate 'line', 285
    find_lex $P168, "$cand_class"
    store_lex "$accepted", $P168
.annotate 'line', 286
    new $P169, "Integer"
    assign $P169, 1
    store_lex "$something_accepted", $P169
.annotate 'line', 287
    set $I170, .CONTROL_LOOP_LAST
    die 0, $I170
  unless_166_end:
.annotate 'line', 270
    .return ($P165)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block143"  :anon :subid("23_1298325424.79949") :outer("22_1298325424.79949")
.annotate 'line', 274
    new $P145, "Undef"
    .lex "$cur_pos", $P145
    new $P146, "Integer"
    assign $P146, 1
    store_lex "$cur_pos", $P146
.annotate 'line', 275
    new $P163, 'ExceptionHandler'
    set_label $P163, loop162_handler
    $P163."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P163
  loop162_test:
    find_lex $P147, "$cur_pos"
    set $N148, $P147
    find_lex $P149, "$_"
    set $N150, $P149
    isle $I151, $N148, $N150
    unless $I151, loop162_done
  loop162_redo:
.annotate 'line', 276
    find_lex $P153, "$cur_pos"
    set $I154, $P153
    find_lex $P155, "$_"
    unless_null $P155, vivify_203
    $P155 = root_new ['parrot';'ResizablePMCArray']
  vivify_203:
    set $P156, $P155[$I154]
    unless_null $P156, vivify_204
    new $P156, "Undef"
  vivify_204:
    find_lex $P157, "$cand_class"
    issame $I158, $P156, $P157
    unless $I158, if_152_end
.annotate 'line', 277
    new $P159, "Integer"
    assign $P159, 1
    store_lex "$rejected", $P159
  if_152_end:
.annotate 'line', 279
    find_lex $P160, "$cur_pos"
    add $P161, $P160, 1
    store_lex "$cur_pos", $P161
  loop162_next:
.annotate 'line', 275
    goto loop162_test
  loop162_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P164, exception, 'type'
    eq $P164, .CONTROL_LOOP_NEXT, loop162_next
    eq $P164, .CONTROL_LOOP_REDO, loop162_redo
  loop162_done:
    pop_eh 
.annotate 'line', 272
    .return ($I151)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block192"  :anon :subid("24_1298325424.79949") :outer("19_1298325424.79949")
.annotate 'line', 305
    .const 'Sub' $P204 = "25_1298325424.79949" 
    capture_lex $P204
.annotate 'line', 306
    $P194 = root_new ['parrot';'ResizablePMCArray']
    .lex "@new_list", $P194
.annotate 'line', 305
    find_lex $P195, "@new_list"
.annotate 'line', 307
    find_lex $P197, "$i"
    set $I198, $P197
    find_lex $P199, "@merge_list"
    unless_null $P199, vivify_205
    $P199 = root_new ['parrot';'ResizablePMCArray']
  vivify_205:
    set $P200, $P199[$I198]
    unless_null $P200, vivify_206
    new $P200, "Undef"
  vivify_206:
    defined $I201, $P200
    unless $I201, for_undef_207
    iter $P196, $P200
    new $P215, 'ExceptionHandler'
    set_label $P215, loop214_handler
    $P215."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P215
  loop214_test:
    unless $P196, loop214_done
    shift $P202, $P196
  loop214_redo:
    .const 'Sub' $P204 = "25_1298325424.79949" 
    capture_lex $P204
    $P204($P202)
  loop214_next:
    goto loop214_test
  loop214_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P216, exception, 'type'
    eq $P216, .CONTROL_LOOP_NEXT, loop214_next
    eq $P216, .CONTROL_LOOP_REDO, loop214_redo
  loop214_done:
    pop_eh 
  for_undef_207:
.annotate 'line', 312
    find_lex $P217, "@new_list"
    find_lex $P218, "$i"
    set $I219, $P218
    find_lex $P220, "@merge_list"
    unless_null $P220, vivify_208
    $P220 = root_new ['parrot';'ResizablePMCArray']
    store_lex "@merge_list", $P220
  vivify_208:
    set $P220[$I219], $P217
.annotate 'line', 313
    find_lex $P221, "$i"
    add $P222, $P221, 1
    store_lex "$i", $P222
.annotate 'line', 305
    .return ($P222)
.end


.namespace ["NQPClassHOW"]
.sub "_block203"  :anon :subid("25_1298325424.79949") :outer("24_1298325424.79949")
    .param pmc param_205
.annotate 'line', 307
    .lex "$_", param_205
.annotate 'line', 308
    find_lex $P208, "$_"
    find_lex $P209, "$accepted"
    issame $I210, $P208, $P209
    unless $I210, unless_207
    new $P206, 'Integer'
    set $P206, $I210
    goto unless_207_end
  unless_207:
.annotate 'line', 309
    find_lex $P211, "@new_list"
    find_lex $P212, "$_"
    $P213 = $P211."push"($P212)
.annotate 'line', 308
    set $P206, $P213
  unless_207_end:
.annotate 'line', 307
    .return ($P206)
.end


.namespace ["NQPClassHOW"]
.sub "new"  :subid("26_1298325424.79949") :outer("15_1298325424.79949")
    .param pmc param_235
    .param pmc param_236 :optional :named("name")
    .param int has_param_236 :opt_flag
.annotate 'line', 62
    .lex "self", param_235
    if has_param_236, optparam_209
    new $P237, "Undef"
    set param_236, $P237
  optparam_209:
    .lex "$name", param_236
.annotate 'line', 63
    new $P238, "Undef"
    .lex "$obj", $P238
    find_lex $P239, "self"
    repr_instance_of $P240, $P239
    store_lex "$obj", $P240
.annotate 'line', 64
    find_lex $P241, "$obj"
    find_lex $P242, "$name"
    $P241."BUILD"($P242 :named("name"))
    find_lex $P243, "$obj"
.annotate 'line', 62
    .return ($P243)
.end


.namespace ["NQPClassHOW"]
.sub "BUILD"  :subid("27_1298325424.79949") :outer("15_1298325424.79949")
    .param pmc param_245
    .param pmc param_246 :optional :named("name")
    .param int has_param_246 :opt_flag
.annotate 'line', 68
    .lex "self", param_245
    if has_param_246, optparam_210
    new $P247, "Undef"
    set param_246, $P247
  optparam_210:
    .lex "$name", param_246
.annotate 'line', 69
    find_lex $P248, "$name"
    find_lex $P249, "self"
    get_global $P250, "$?CLASS"
    setattribute $P249, $P250, "$!name", $P248
.annotate 'line', 68
    .return ($P248)
.end


.namespace ["NQPClassHOW"]
.sub "new_type"  :subid("28_1298325424.79949") :outer("15_1298325424.79949")
    .param pmc param_252
    .param pmc param_253 :optional :named("name")
    .param int has_param_253 :opt_flag
    .param pmc param_255 :optional :named("repr")
    .param int has_param_255 :opt_flag
.annotate 'line', 74
    .lex "self", param_252
    if has_param_253, optparam_211
    new $P254, "String"
    assign $P254, "<anon>"
    set param_253, $P254
  optparam_211:
    .lex "$name", param_253
    if has_param_255, optparam_212
    new $P256, "String"
    assign $P256, "P6opaque"
    set param_255, $P256
  optparam_212:
    .lex "$repr", param_255
.annotate 'line', 75
    new $P257, "Undef"
    .lex "$metaclass", $P257
    find_lex $P258, "self"
    find_lex $P259, "$name"
    $P260 = $P258."new"($P259 :named("name"))
    store_lex "$metaclass", $P260
.annotate 'line', 76
    find_lex $P261, "$metaclass"
    find_lex $P262, "$repr"
    set $S263, $P262
    repr_type_object_for $P264, $P261, $S263
.annotate 'line', 74
    .return ($P264)
.end


.namespace ["NQPClassHOW"]
.sub "add_method"  :subid("29_1298325424.79949") :outer("15_1298325424.79949")
    .param pmc param_266
    .param pmc param_267
    .param pmc param_268
    .param pmc param_269
.annotate 'line', 79
    .lex "self", param_266
    .lex "$obj", param_267
    .lex "$name", param_268
    .lex "$code_obj", param_269
.annotate 'line', 80
    find_lex $P271, "$name"
    find_lex $P272, "self"
    get_global $P273, "$?CLASS"
    getattribute $P274, $P272, $P273, "%!methods"
    unless_null $P274, vivify_213
    $P274 = root_new ['parrot';'Hash']
  vivify_213:
    set $P275, $P274[$P271]
    unless_null $P275, vivify_214
    new $P275, "Undef"
  vivify_214:
    unless $P275, if_270_end
.annotate 'line', 81
    new $P276, "String"
    assign $P276, "This class already has a method named "
    find_lex $P277, "$name"
    concat $P278, $P276, $P277
    die $P278
  if_270_end:
.annotate 'line', 83
    find_lex $P279, "$code_obj"
    find_lex $P280, "$name"
    find_lex $P281, "self"
    get_global $P282, "$?CLASS"
    getattribute $P283, $P281, $P282, "%!methods"
    unless_null $P283, vivify_215
    $P283 = root_new ['parrot';'Hash']
    setattribute $P281, $P282, "%!methods", $P283
  vivify_215:
    set $P283[$P280], $P279
.annotate 'line', 79
    .return ($P279)
.end


.namespace ["NQPClassHOW"]
.sub "add_multi_method"  :subid("30_1298325424.79949") :outer("15_1298325424.79949")
    .param pmc param_285
    .param pmc param_286
    .param pmc param_287
    .param pmc param_288
.annotate 'line', 86
    .lex "self", param_285
    .lex "$obj", param_286
    .lex "$name", param_287
    .lex "$code_obj", param_288
.annotate 'line', 92
    $P289 = root_new ['parrot';'Hash']
    .lex "%todo", $P289
.annotate 'line', 86
    find_lex $P290, "%todo"
.annotate 'line', 93
    find_lex $P291, "$name"
    find_lex $P292, "%todo"
    unless_null $P292, vivify_216
    $P292 = root_new ['parrot';'Hash']
    store_lex "%todo", $P292
  vivify_216:
    set $P292["name"], $P291
.annotate 'line', 94
    find_lex $P293, "$code_obj"
    find_lex $P294, "%todo"
    unless_null $P294, vivify_217
    $P294 = root_new ['parrot';'Hash']
    store_lex "%todo", $P294
  vivify_217:
    set $P294["code"], $P293
.annotate 'line', 95
    find_lex $P295, "%todo"
    find_lex $P296, "self"
    get_global $P297, "$?CLASS"
    getattribute $P298, $P296, $P297, "@!multi_methods_to_incorporate"
    unless_null $P298, vivify_218
    $P298 = root_new ['parrot';'ResizablePMCArray']
  vivify_218:
    set $N299, $P298
    set $I300, $N299
    find_lex $P301, "self"
    get_global $P302, "$?CLASS"
    getattribute $P303, $P301, $P302, "@!multi_methods_to_incorporate"
    unless_null $P303, vivify_219
    $P303 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P301, $P302, "@!multi_methods_to_incorporate", $P303
  vivify_219:
    set $P303[$I300], $P295
    find_lex $P304, "$code_obj"
.annotate 'line', 86
    .return ($P304)
.end


.namespace ["NQPClassHOW"]
.sub "add_attribute"  :subid("31_1298325424.79949") :outer("15_1298325424.79949")
    .param pmc param_306
    .param pmc param_307
    .param pmc param_308
.annotate 'line', 99
    .lex "self", param_306
    .lex "$obj", param_307
    .lex "$meta_attr", param_308
.annotate 'line', 100
    new $P309, "Undef"
    .lex "$name", $P309
    find_lex $P310, "$meta_attr"
    $P311 = $P310."name"()
    store_lex "$name", $P311
.annotate 'line', 101
    find_lex $P313, "$name"
    find_lex $P314, "self"
    get_global $P315, "$?CLASS"
    getattribute $P316, $P314, $P315, "%!attributes"
    unless_null $P316, vivify_220
    $P316 = root_new ['parrot';'Hash']
  vivify_220:
    set $P317, $P316[$P313]
    unless_null $P317, vivify_221
    new $P317, "Undef"
  vivify_221:
    unless $P317, if_312_end
.annotate 'line', 102
    new $P318, "String"
    assign $P318, "This class already has an attribute named "
    find_lex $P319, "$name"
    concat $P320, $P318, $P319
    die $P320
  if_312_end:
.annotate 'line', 104
    find_lex $P321, "$meta_attr"
    find_lex $P322, "$name"
    find_lex $P323, "self"
    get_global $P324, "$?CLASS"
    getattribute $P325, $P323, $P324, "%!attributes"
    unless_null $P325, vivify_222
    $P325 = root_new ['parrot';'Hash']
    setattribute $P323, $P324, "%!attributes", $P325
  vivify_222:
    set $P325[$P322], $P321
.annotate 'line', 99
    .return ($P321)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "add_parent"  :subid("32_1298325424.79949") :outer("15_1298325424.79949")
    .param pmc param_327
    .param pmc param_328
    .param pmc param_329
.annotate 'line', 107
    .const 'Sub' $P341 = "33_1298325424.79949" 
    capture_lex $P341
    .lex "self", param_327
    .lex "$obj", param_328
    .lex "$parent", param_329
.annotate 'line', 108
    find_lex $P331, "self"
    get_global $P332, "$?CLASS"
    getattribute $P333, $P331, $P332, "$!composed"
    unless_null $P333, vivify_223
    new $P333, "Undef"
  vivify_223:
    unless $P333, if_330_end
.annotate 'line', 109
    die "NQPClassHOW does not support adding parents after being composed."
  if_330_end:
.annotate 'line', 111
    find_lex $P335, "self"
    get_global $P336, "$?CLASS"
    getattribute $P337, $P335, $P336, "@!parents"
    unless_null $P337, vivify_224
    $P337 = root_new ['parrot';'ResizablePMCArray']
  vivify_224:
    defined $I338, $P337
    unless $I338, for_undef_225
    iter $P334, $P337
    new $P353, 'ExceptionHandler'
    set_label $P353, loop352_handler
    $P353."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P353
  loop352_test:
    unless $P334, loop352_done
    shift $P339, $P334
  loop352_redo:
    .const 'Sub' $P341 = "33_1298325424.79949" 
    capture_lex $P341
    $P341($P339)
  loop352_next:
    goto loop352_test
  loop352_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P354, exception, 'type'
    eq $P354, .CONTROL_LOOP_NEXT, loop352_next
    eq $P354, .CONTROL_LOOP_REDO, loop352_redo
  loop352_done:
    pop_eh 
  for_undef_225:
.annotate 'line', 116
    find_lex $P355, "$parent"
    find_lex $P356, "self"
    get_global $P357, "$?CLASS"
    getattribute $P358, $P356, $P357, "@!parents"
    unless_null $P358, vivify_226
    $P358 = root_new ['parrot';'ResizablePMCArray']
  vivify_226:
    set $N359, $P358
    set $I360, $N359
    find_lex $P361, "self"
    get_global $P362, "$?CLASS"
    getattribute $P363, $P361, $P362, "@!parents"
    unless_null $P363, vivify_227
    $P363 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P361, $P362, "@!parents", $P363
  vivify_227:
    set $P363[$I360], $P355
.annotate 'line', 107
    .return ($P355)
.end


.namespace ["NQPClassHOW"]
.sub "_block340"  :anon :subid("33_1298325424.79949") :outer("32_1298325424.79949")
    .param pmc param_342
.annotate 'line', 111
    .lex "$_", param_342
.annotate 'line', 112
    find_lex $P345, "$_"
    find_lex $P346, "$parent"
    issame $I347, $P345, $P346
    if $I347, if_344
    new $P343, 'Integer'
    set $P343, $I347
    goto if_344_end
  if_344:
.annotate 'line', 113
    new $P348, "String"
    assign $P348, "Already have "
    find_lex $P349, "$parent"
    concat $P350, $P348, $P349
    concat $P351, $P350, " as a parent class."
    die $P351
  if_344_end:
.annotate 'line', 111
    .return ($P343)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "add_role"  :subid("34_1298325424.79949") :outer("15_1298325424.79949")
    .param pmc param_365
    .param pmc param_366
    .param pmc param_367
.annotate 'line', 119
    .const 'Sub' $P375 = "35_1298325424.79949" 
    capture_lex $P375
    .lex "self", param_365
    .lex "$obj", param_366
    .lex "$role", param_367
.annotate 'line', 120
    find_lex $P369, "self"
    get_global $P370, "$?CLASS"
    getattribute $P371, $P369, $P370, "@!roles"
    unless_null $P371, vivify_228
    $P371 = root_new ['parrot';'ResizablePMCArray']
  vivify_228:
    defined $I372, $P371
    unless $I372, for_undef_229
    iter $P368, $P371
    new $P387, 'ExceptionHandler'
    set_label $P387, loop386_handler
    $P387."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P387
  loop386_test:
    unless $P368, loop386_done
    shift $P373, $P368
  loop386_redo:
    .const 'Sub' $P375 = "35_1298325424.79949" 
    capture_lex $P375
    $P375($P373)
  loop386_next:
    goto loop386_test
  loop386_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P388, exception, 'type'
    eq $P388, .CONTROL_LOOP_NEXT, loop386_next
    eq $P388, .CONTROL_LOOP_REDO, loop386_redo
  loop386_done:
    pop_eh 
  for_undef_229:
.annotate 'line', 125
    find_lex $P389, "$role"
    find_lex $P390, "self"
    get_global $P391, "$?CLASS"
    getattribute $P392, $P390, $P391, "@!roles"
    unless_null $P392, vivify_230
    $P392 = root_new ['parrot';'ResizablePMCArray']
  vivify_230:
    set $N393, $P392
    set $I394, $N393
    find_lex $P395, "self"
    get_global $P396, "$?CLASS"
    getattribute $P397, $P395, $P396, "@!roles"
    unless_null $P397, vivify_231
    $P397 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P395, $P396, "@!roles", $P397
  vivify_231:
    set $P397[$I394], $P389
.annotate 'line', 119
    .return ($P389)
.end


.namespace ["NQPClassHOW"]
.sub "_block374"  :anon :subid("35_1298325424.79949") :outer("34_1298325424.79949")
    .param pmc param_376
.annotate 'line', 120
    .lex "$_", param_376
.annotate 'line', 121
    find_lex $P379, "$_"
    find_lex $P380, "$role"
    issame $I381, $P379, $P380
    if $I381, if_378
    new $P377, 'Integer'
    set $P377, $I381
    goto if_378_end
  if_378:
.annotate 'line', 122
    new $P382, "String"
    assign $P382, "The role "
    find_lex $P383, "$role"
    concat $P384, $P382, $P383
    concat $P385, $P384, " has already been added."
    die $P385
  if_378_end:
.annotate 'line', 120
    .return ($P377)
.end


.namespace ["NQPClassHOW"]
.sub "add_parrot_vtable_mapping"  :subid("36_1298325424.79949") :outer("15_1298325424.79949")
    .param pmc param_399
    .param pmc param_400
    .param pmc param_401
    .param pmc param_402
.annotate 'line', 128
    .lex "self", param_399
    .lex "$obj", param_400
    .lex "$name", param_401
    .lex "$meth", param_402
.annotate 'line', 129
    find_lex $P404, "$name"
    find_lex $P405, "self"
    get_global $P406, "$?CLASS"
    getattribute $P407, $P405, $P406, "%!parrot_vtable_mapping"
    unless_null $P407, vivify_232
    $P407 = root_new ['parrot';'Hash']
  vivify_232:
    set $P408, $P407[$P404]
    unless_null $P408, vivify_233
    new $P408, "Undef"
  vivify_233:
    defined $I409, $P408
    unless $I409, if_403_end
.annotate 'line', 130
    new $P410, "String"
    assign $P410, "Class '"
    find_lex $P411, "self"
    get_global $P412, "$?CLASS"
    getattribute $P413, $P411, $P412, "$!name"
    unless_null $P413, vivify_234
    new $P413, "Undef"
  vivify_234:
    concat $P414, $P410, $P413
    concat $P415, $P414, "' already has a Parrot v-table override for '"
    find_lex $P416, "$name"
    concat $P417, $P415, $P416
.annotate 'line', 131
    concat $P418, $P417, "'"
.annotate 'line', 132
    die $P418
  if_403_end:
.annotate 'line', 134
    find_lex $P419, "$meth"
    find_lex $P420, "$name"
    find_lex $P421, "self"
    get_global $P422, "$?CLASS"
    getattribute $P423, $P421, $P422, "%!parrot_vtable_mapping"
    unless_null $P423, vivify_235
    $P423 = root_new ['parrot';'Hash']
    setattribute $P421, $P422, "%!parrot_vtable_mapping", $P423
  vivify_235:
    set $P423[$P420], $P419
.annotate 'line', 128
    .return ($P419)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "compose"  :subid("37_1298325424.79949") :outer("15_1298325424.79949")
    .param pmc param_425
    .param pmc param_426
.annotate 'line', 137
    .const 'Sub' $P513 = "40_1298325424.79949" 
    capture_lex $P513
    .const 'Sub' $P432 = "38_1298325424.79949" 
    capture_lex $P432
    .lex "self", param_425
    .lex "$obj", param_426
.annotate 'line', 141
    find_lex $P428, "self"
    get_global $P429, "$?CLASS"
    getattribute $P430, $P428, $P429, "@!roles"
    unless_null $P430, vivify_236
    $P430 = root_new ['parrot';'ResizablePMCArray']
  vivify_236:
    unless $P430, if_427_end
    .const 'Sub' $P432 = "38_1298325424.79949" 
    capture_lex $P432
    $P432()
  if_427_end:
.annotate 'line', 154
    find_lex $P480, "self"
    get_global $P481, "$?CLASS"
    getattribute $P482, $P480, $P481, "@!parents"
    unless_null $P482, vivify_243
    $P482 = root_new ['parrot';'ResizablePMCArray']
  vivify_243:
    set $N483, $P482
    iseq $I484, $N483, 0.0
    if $I484, if_479
    new $P478, 'Integer'
    set $P478, $I484
    goto if_479_end
  if_479:
    find_lex $P485, "self"
    get_global $P486, "$?CLASS"
    getattribute $P487, $P485, $P486, "$!name"
    unless_null $P487, vivify_244
    new $P487, "Undef"
  vivify_244:
    set $S488, $P487
    isne $I489, $S488, "NQPMu"
    new $P478, 'Integer'
    set $P478, $I489
  if_479_end:
    unless $P478, if_477_end
.annotate 'line', 155
    find_lex $P490, "self"
    find_lex $P491, "$obj"
    get_hll_global $P492, "NQPMu"
    $P490."add_parent"($P491, $P492)
  if_477_end:
.annotate 'line', 160
    find_lex $P494, "self"
    get_global $P495, "$?CLASS"
    getattribute $P496, $P494, $P495, "$!composed"
    unless_null $P496, vivify_245
    new $P496, "Undef"
  vivify_245:
    if $P496, unless_493_end
.annotate 'line', 161
    find_lex $P497, "$obj"
    $P498 = "compute_c3_mro"($P497)
    find_lex $P499, "self"
    get_global $P500, "$?CLASS"
    setattribute $P499, $P500, "@!mro", $P498
.annotate 'line', 162
    new $P501, "Integer"
    assign $P501, 1
    find_lex $P502, "self"
    get_global $P503, "$?CLASS"
    setattribute $P502, $P503, "$!composed", $P501
  unless_493_end:
.annotate 'line', 166
    find_lex $P504, "self"
    find_lex $P505, "$obj"
    $P504."incorporate_multi_candidates"($P505)
.annotate 'line', 169
    find_lex $P507, "self"
    find_lex $P508, "$obj"
    $P509 = $P507."attributes"($P508, "0" :named("local"))
    defined $I510, $P509
    unless $I510, for_undef_246
    iter $P506, $P509
    new $P519, 'ExceptionHandler'
    set_label $P519, loop518_handler
    $P519."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P519
  loop518_test:
    unless $P506, loop518_done
    shift $P511, $P506
  loop518_redo:
    .const 'Sub' $P513 = "40_1298325424.79949" 
    capture_lex $P513
    $P513($P511)
  loop518_next:
    goto loop518_test
  loop518_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P520, exception, 'type'
    eq $P520, .CONTROL_LOOP_NEXT, loop518_next
    eq $P520, .CONTROL_LOOP_REDO, loop518_redo
  loop518_done:
    pop_eh 
  for_undef_246:
.annotate 'line', 172
    find_lex $P521, "self"
    find_lex $P522, "$obj"
    $P521."publish_type_cache"($P522)
.annotate 'line', 173
    find_lex $P523, "self"
    find_lex $P524, "$obj"
    $P523."publish_method_cache"($P524)
.annotate 'line', 176
    find_lex $P525, "self"
    find_lex $P526, "$obj"
    $P525."publish_parrot_vtable_mapping"($P526)
    find_lex $P527, "$obj"
.annotate 'line', 137
    .return ($P527)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block431"  :anon :subid("38_1298325424.79949") :outer("37_1298325424.79949")
.annotate 'line', 141
    .const 'Sub' $P442 = "39_1298325424.79949" 
    capture_lex $P442
.annotate 'line', 142
    $P433 = root_new ['parrot';'ResizablePMCArray']
    .lex "@instantiated_roles", $P433
.annotate 'line', 141
    find_lex $P434, "@instantiated_roles"
.annotate 'line', 143
    find_lex $P436, "self"
    get_global $P437, "$?CLASS"
    getattribute $P438, $P436, $P437, "@!roles"
    unless_null $P438, vivify_237
    $P438 = root_new ['parrot';'ResizablePMCArray']
  vivify_237:
    defined $I439, $P438
    unless $I439, for_undef_238
    iter $P435, $P438
    new $P471, 'ExceptionHandler'
    set_label $P471, loop470_handler
    $P471."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P471
  loop470_test:
    unless $P435, loop470_done
    shift $P440, $P435
  loop470_redo:
    .const 'Sub' $P442 = "39_1298325424.79949" 
    capture_lex $P442
    $P442($P440)
  loop470_next:
    goto loop470_test
  loop470_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P472, exception, 'type'
    eq $P472, .CONTROL_LOOP_NEXT, loop470_next
    eq $P472, .CONTROL_LOOP_REDO, loop470_redo
  loop470_done:
    pop_eh 
  for_undef_238:
.annotate 'line', 149
    get_hll_global $P473, "RoleToClassApplier"
    find_lex $P474, "$obj"
    find_lex $P475, "@instantiated_roles"
    $P476 = $P473."apply"($P474, $P475)
.annotate 'line', 141
    .return ($P476)
.end


.namespace ["NQPClassHOW"]
.sub "_block441"  :anon :subid("39_1298325424.79949") :outer("38_1298325424.79949")
    .param pmc param_444
.annotate 'line', 144
    new $P443, "Undef"
    .lex "$ins", $P443
    .lex "$_", param_444
    find_lex $P445, "$_"
    get_how $P446, $P445
    find_lex $P447, "$_"
    find_lex $P448, "$obj"
    $P449 = $P446."instantiate"($P447, $P448)
    store_lex "$ins", $P449
.annotate 'line', 145
    find_lex $P450, "@instantiated_roles"
    find_lex $P451, "$ins"
    $P450."push"($P451)
.annotate 'line', 146
    find_lex $P452, "$_"
    find_lex $P453, "self"
    get_global $P454, "$?CLASS"
    getattribute $P455, $P453, $P454, "@!done"
    unless_null $P455, vivify_239
    $P455 = root_new ['parrot';'ResizablePMCArray']
  vivify_239:
    set $N456, $P455
    set $I457, $N456
    find_lex $P458, "self"
    get_global $P459, "$?CLASS"
    getattribute $P460, $P458, $P459, "@!done"
    unless_null $P460, vivify_240
    $P460 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P458, $P459, "@!done", $P460
  vivify_240:
    set $P460[$I457], $P452
.annotate 'line', 147
    find_lex $P461, "$ins"
    find_lex $P462, "self"
    get_global $P463, "$?CLASS"
    getattribute $P464, $P462, $P463, "@!done"
    unless_null $P464, vivify_241
    $P464 = root_new ['parrot';'ResizablePMCArray']
  vivify_241:
    set $N465, $P464
    set $I466, $N465
    find_lex $P467, "self"
    get_global $P468, "$?CLASS"
    getattribute $P469, $P467, $P468, "@!done"
    unless_null $P469, vivify_242
    $P469 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P467, $P468, "@!done", $P469
  vivify_242:
    set $P469[$I466], $P461
.annotate 'line', 143
    .return ($P461)
.end


.namespace ["NQPClassHOW"]
.sub "_block512"  :anon :subid("40_1298325424.79949") :outer("37_1298325424.79949")
    .param pmc param_514
.annotate 'line', 169
    .lex "$_", param_514
    find_lex $P515, "$_"
    find_lex $P516, "$obj"
    $P517 = $P515."compose"($P516)
    .return ($P517)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "incorporate_multi_candidates"  :subid("41_1298325424.79949") :outer("15_1298325424.79949")
    .param pmc param_529
    .param pmc param_530
.annotate 'line', 181
    .const 'Sub' $P545 = "42_1298325424.79949" 
    capture_lex $P545
    .lex "self", param_529
    .lex "$obj", param_530
.annotate 'line', 182
    new $P531, "Undef"
    .lex "$num_todo", $P531
.annotate 'line', 183
    new $P532, "Undef"
    .lex "$i", $P532
.annotate 'line', 182
    find_lex $P533, "self"
    get_global $P534, "$?CLASS"
    getattribute $P535, $P533, $P534, "@!multi_methods_to_incorporate"
    unless_null $P535, vivify_247
    $P535 = root_new ['parrot';'ResizablePMCArray']
  vivify_247:
    set $N536, $P535
    new $P537, 'Float'
    set $P537, $N536
    store_lex "$num_todo", $P537
.annotate 'line', 183
    new $P538, "Integer"
    assign $P538, 0
    store_lex "$i", $P538
.annotate 'line', 184
    new $P654, 'ExceptionHandler'
    set_label $P654, loop653_handler
    $P654."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P654
  loop653_test:
    find_lex $P539, "$i"
    set $N540, $P539
    find_lex $P541, "$num_todo"
    set $N542, $P541
    isne $I543, $N540, $N542
    unless $I543, loop653_done
  loop653_redo:
    .const 'Sub' $P545 = "42_1298325424.79949" 
    capture_lex $P545
    $P545()
  loop653_next:
    goto loop653_test
  loop653_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P655, exception, 'type'
    eq $P655, .CONTROL_LOOP_NEXT, loop653_next
    eq $P655, .CONTROL_LOOP_REDO, loop653_redo
  loop653_done:
    pop_eh 
.annotate 'line', 181
    .return ($I543)
.end


.namespace ["NQPClassHOW"]
.sub "_block544"  :anon :subid("42_1298325424.79949") :outer("41_1298325424.79949")
.annotate 'line', 184
    .const 'Sub' $P581 = "43_1298325424.79949" 
    capture_lex $P581
.annotate 'line', 186
    new $P546, "Undef"
    .lex "$name", $P546
.annotate 'line', 187
    new $P547, "Undef"
    .lex "$code", $P547
.annotate 'line', 191
    new $P548, "Undef"
    .lex "$dispatcher", $P548
.annotate 'line', 186
    find_lex $P549, "$i"
    set $I550, $P549
    find_lex $P551, "self"
    get_global $P552, "$?CLASS"
    getattribute $P553, $P551, $P552, "@!multi_methods_to_incorporate"
    unless_null $P553, vivify_248
    $P553 = root_new ['parrot';'ResizablePMCArray']
  vivify_248:
    set $P554, $P553[$I550]
    unless_null $P554, vivify_249
    $P554 = root_new ['parrot';'Hash']
  vivify_249:
    set $P555, $P554["name"]
    unless_null $P555, vivify_250
    new $P555, "Undef"
  vivify_250:
    store_lex "$name", $P555
.annotate 'line', 187
    find_lex $P556, "$i"
    set $I557, $P556
    find_lex $P558, "self"
    get_global $P559, "$?CLASS"
    getattribute $P560, $P558, $P559, "@!multi_methods_to_incorporate"
    unless_null $P560, vivify_251
    $P560 = root_new ['parrot';'ResizablePMCArray']
  vivify_251:
    set $P561, $P560[$I557]
    unless_null $P561, vivify_252
    $P561 = root_new ['parrot';'Hash']
  vivify_252:
    set $P562, $P561["code"]
    unless_null $P562, vivify_253
    new $P562, "Undef"
  vivify_253:
    store_lex "$code", $P562
.annotate 'line', 191
    find_lex $P563, "$name"
    find_lex $P564, "self"
    get_global $P565, "$?CLASS"
    getattribute $P566, $P564, $P565, "%!methods"
    unless_null $P566, vivify_254
    $P566 = root_new ['parrot';'Hash']
  vivify_254:
    set $P567, $P566[$P563]
    unless_null $P567, vivify_255
    new $P567, "Undef"
  vivify_255:
    store_lex "$dispatcher", $P567
.annotate 'line', 192
    find_lex $P569, "$dispatcher"
    defined $I570, $P569
    if $I570, if_568
.annotate 'line', 202
    .const 'Sub' $P581 = "43_1298325424.79949" 
    capture_lex $P581
    $P581()
    goto if_568_end
  if_568:
.annotate 'line', 195
    find_lex $P572, "$dispatcher"
    is_dispatcher $I573, $P572
    if $I573, if_571
.annotate 'line', 199
    new $P576, 'String'
    set $P576, "Cannot have a multi candidate for "
    find_lex $P577, "$name"
    concat $P578, $P576, $P577
    concat $P579, $P578, " when an only method is also in the class"
    die $P579
.annotate 'line', 198
    goto if_571_end
  if_571:
.annotate 'line', 196
    find_lex $P574, "$dispatcher"
    find_lex $P575, "$code"
    push_dispatchee $P574, $P575
  if_571_end:
  if_568_end:
.annotate 'line', 230
    find_lex $P651, "$i"
    add $P652, $P651, 1
    store_lex "$i", $P652
.annotate 'line', 184
    .return ($P652)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block580"  :anon :subid("43_1298325424.79949") :outer("42_1298325424.79949")
.annotate 'line', 202
    .const 'Sub' $P598 = "44_1298325424.79949" 
    capture_lex $P598
.annotate 'line', 204
    new $P582, "Undef"
    .lex "$j", $P582
.annotate 'line', 205
    new $P583, "Undef"
    .lex "$found", $P583
.annotate 'line', 204
    new $P584, "Integer"
    assign $P584, 1
    store_lex "$j", $P584
.annotate 'line', 205
    new $P585, "Integer"
    assign $P585, 0
    store_lex "$found", $P585
.annotate 'line', 206
    new $P642, 'ExceptionHandler'
    set_label $P642, loop641_handler
    $P642."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P642
  loop641_test:
    find_lex $P588, "$j"
    set $N589, $P588
    find_lex $P590, "self"
    get_global $P591, "$?CLASS"
    getattribute $P592, $P590, $P591, "@!mro"
    unless_null $P592, vivify_256
    $P592 = root_new ['parrot';'ResizablePMCArray']
  vivify_256:
    set $N593, $P592
    isne $I594, $N589, $N593
    if $I594, if_587
    new $P586, 'Integer'
    set $P586, $I594
    goto if_587_end
  if_587:
    find_lex $P595, "$found"
    isfalse $I596, $P595
    new $P586, 'Integer'
    set $P586, $I596
  if_587_end:
    unless $P586, loop641_done
  loop641_redo:
    .const 'Sub' $P598 = "44_1298325424.79949" 
    capture_lex $P598
    $P598()
  loop641_next:
    goto loop641_test
  loop641_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P643, exception, 'type'
    eq $P643, .CONTROL_LOOP_NEXT, loop641_next
    eq $P643, .CONTROL_LOOP_REDO, loop641_redo
  loop641_done:
    pop_eh 
.annotate 'line', 226
    find_lex $P646, "$found"
    unless $P646, unless_645
    set $P644, $P646
    goto unless_645_end
  unless_645:
.annotate 'line', 227
    new $P647, 'String'
    set $P647, "Could not find a proto for multi "
    find_lex $P648, "$name"
    concat $P649, $P647, $P648
    concat $P650, $P649, ", and proto generation is NYI"
    die $P650
  unless_645_end:
.annotate 'line', 202
    .return ($P644)
.end


.namespace ["NQPClassHOW"]
.sub "_block597"  :anon :subid("44_1298325424.79949") :outer("43_1298325424.79949")
.annotate 'line', 206
    .const 'Sub' $P622 = "45_1298325424.79949" 
    capture_lex $P622
.annotate 'line', 207
    new $P599, "Undef"
    .lex "$parent", $P599
.annotate 'line', 208
    $P600 = root_new ['parrot';'Hash']
    .lex "%meths", $P600
.annotate 'line', 209
    new $P601, "Undef"
    .lex "$dispatcher", $P601
.annotate 'line', 207
    find_lex $P602, "$j"
    set $I603, $P602
    find_lex $P604, "self"
    get_global $P605, "$?CLASS"
    getattribute $P606, $P604, $P605, "@!mro"
    unless_null $P606, vivify_257
    $P606 = root_new ['parrot';'ResizablePMCArray']
  vivify_257:
    set $P607, $P606[$I603]
    unless_null $P607, vivify_258
    new $P607, "Undef"
  vivify_258:
    store_lex "$parent", $P607
.annotate 'line', 208
    find_lex $P608, "$parent"
    get_how $P609, $P608
    find_lex $P610, "$parent"
    $P611 = $P609."method_table"($P610)
    store_lex "%meths", $P611
.annotate 'line', 209
    find_lex $P612, "$name"
    find_lex $P613, "%meths"
    unless_null $P613, vivify_259
    $P613 = root_new ['parrot';'Hash']
  vivify_259:
    set $P614, $P613[$P612]
    unless_null $P614, vivify_260
    new $P614, "Undef"
  vivify_260:
    store_lex "$dispatcher", $P614
.annotate 'line', 210
    find_lex $P616, "$dispatcher"
    defined $I617, $P616
    unless $I617, if_615_end
.annotate 'line', 213
    find_lex $P619, "$dispatcher"
    is_dispatcher $I620, $P619
    if $I620, if_618
.annotate 'line', 221
    new $P635, 'String'
    set $P635, "Could not find a proto for multi "
    find_lex $P636, "$name"
    concat $P637, $P635, $P636
    concat $P638, $P637, " (it may exist, but an only is hiding it if so)"
    die $P638
.annotate 'line', 220
    goto if_618_end
  if_618:
.annotate 'line', 213
    .const 'Sub' $P622 = "45_1298325424.79949" 
    capture_lex $P622
    $P622()
  if_618_end:
  if_615_end:
.annotate 'line', 224
    find_lex $P639, "$j"
    add $P640, $P639, 1
    store_lex "$j", $P640
.annotate 'line', 206
    .return ($P640)
.end


.namespace ["NQPClassHOW"]
.sub "_block621"  :anon :subid("45_1298325424.79949") :outer("44_1298325424.79949")
.annotate 'line', 215
    $P623 = root_new ['parrot';'ResizablePMCArray']
    .lex "@new_dispatchees", $P623
.annotate 'line', 213
    find_lex $P624, "@new_dispatchees"
.annotate 'line', 216
    find_lex $P625, "$code"
    find_lex $P626, "@new_dispatchees"
    unless_null $P626, vivify_261
    $P626 = root_new ['parrot';'ResizablePMCArray']
    store_lex "@new_dispatchees", $P626
  vivify_261:
    set $P626[0], $P625
.annotate 'line', 217
    find_lex $P627, "$dispatcher"
    find_lex $P628, "@new_dispatchees"
    create_dispatch_and_add_candidates $P629, $P627, $P628
    find_lex $P630, "$name"
    find_lex $P631, "self"
    get_global $P632, "$?CLASS"
    getattribute $P633, $P631, $P632, "%!methods"
    unless_null $P633, vivify_262
    $P633 = root_new ['parrot';'Hash']
    setattribute $P631, $P632, "%!methods", $P633
  vivify_262:
    set $P633[$P630], $P629
.annotate 'line', 218
    new $P634, "Integer"
    assign $P634, 1
    store_lex "$found", $P634
.annotate 'line', 213
    .return ($P634)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "publish_type_cache"  :subid("46_1298325424.79949") :outer("15_1298325424.79949")
    .param pmc param_659
    .param pmc param_660
.annotate 'line', 323
    .const 'Sub' $P685 = "48_1298325424.79949" 
    capture_lex $P685
    .const 'Sub' $P670 = "47_1298325424.79949" 
    capture_lex $P670
    .lex "self", param_659
    .lex "$obj", param_660
.annotate 'line', 324
    $P661 = root_new ['parrot';'ResizablePMCArray']
    .lex "@tc", $P661
.annotate 'line', 323
    find_lex $P662, "@tc"
.annotate 'line', 325
    find_lex $P664, "self"
    get_global $P665, "$?CLASS"
    getattribute $P666, $P664, $P665, "@!mro"
    unless_null $P666, vivify_263
    $P666 = root_new ['parrot';'ResizablePMCArray']
  vivify_263:
    defined $I667, $P666
    unless $I667, for_undef_264
    iter $P663, $P666
    new $P676, 'ExceptionHandler'
    set_label $P676, loop675_handler
    $P676."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P676
  loop675_test:
    unless $P663, loop675_done
    shift $P668, $P663
  loop675_redo:
    .const 'Sub' $P670 = "47_1298325424.79949" 
    capture_lex $P670
    $P670($P668)
  loop675_next:
    goto loop675_test
  loop675_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P677, exception, 'type'
    eq $P677, .CONTROL_LOOP_NEXT, loop675_next
    eq $P677, .CONTROL_LOOP_REDO, loop675_redo
  loop675_done:
    pop_eh 
  for_undef_264:
.annotate 'line', 326
    find_lex $P679, "self"
    get_global $P680, "$?CLASS"
    getattribute $P681, $P679, $P680, "@!done"
    unless_null $P681, vivify_265
    $P681 = root_new ['parrot';'ResizablePMCArray']
  vivify_265:
    defined $I682, $P681
    unless $I682, for_undef_266
    iter $P678, $P681
    new $P691, 'ExceptionHandler'
    set_label $P691, loop690_handler
    $P691."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P691
  loop690_test:
    unless $P678, loop690_done
    shift $P683, $P678
  loop690_redo:
    .const 'Sub' $P685 = "48_1298325424.79949" 
    capture_lex $P685
    $P685($P683)
  loop690_next:
    goto loop690_test
  loop690_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P692, exception, 'type'
    eq $P692, .CONTROL_LOOP_NEXT, loop690_next
    eq $P692, .CONTROL_LOOP_REDO, loop690_redo
  loop690_done:
    pop_eh 
  for_undef_266:
.annotate 'line', 327
    find_lex $P693, "$obj"
    find_lex $P694, "@tc"
    publish_type_check_cache $P693, $P694
.annotate 'line', 323
    .return ()
.end


.namespace ["NQPClassHOW"]
.sub "_block669"  :anon :subid("47_1298325424.79949") :outer("46_1298325424.79949")
    .param pmc param_671
.annotate 'line', 325
    .lex "$_", param_671
    find_lex $P672, "@tc"
    find_lex $P673, "$_"
    $P674 = $P672."push"($P673)
    .return ($P674)
.end


.namespace ["NQPClassHOW"]
.sub "_block684"  :anon :subid("48_1298325424.79949") :outer("46_1298325424.79949")
    .param pmc param_686
.annotate 'line', 326
    .lex "$_", param_686
    find_lex $P687, "@tc"
    find_lex $P688, "$_"
    $P689 = $P687."push"($P688)
    .return ($P689)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "publish_method_cache"  :subid("49_1298325424.79949") :outer("15_1298325424.79949")
    .param pmc param_696
    .param pmc param_697
.annotate 'line', 330
    .const 'Sub' $P707 = "50_1298325424.79949" 
    capture_lex $P707
    .lex "self", param_696
    .lex "$obj", param_697
.annotate 'line', 333
    $P698 = root_new ['parrot';'Hash']
    .lex "%cache", $P698
.annotate 'line', 330
    find_lex $P699, "%cache"
.annotate 'line', 334
    find_lex $P701, "self"
    get_global $P702, "$?CLASS"
    getattribute $P703, $P701, $P702, "@!mro"
    unless_null $P703, vivify_267
    $P703 = root_new ['parrot';'ResizablePMCArray']
  vivify_267:
    defined $I704, $P703
    unless $I704, for_undef_268
    iter $P700, $P703
    new $P736, 'ExceptionHandler'
    set_label $P736, loop735_handler
    $P736."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P736
  loop735_test:
    unless $P700, loop735_done
    shift $P705, $P700
  loop735_redo:
    .const 'Sub' $P707 = "50_1298325424.79949" 
    capture_lex $P707
    $P707($P705)
  loop735_next:
    goto loop735_test
  loop735_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P737, exception, 'type'
    eq $P737, .CONTROL_LOOP_NEXT, loop735_next
    eq $P737, .CONTROL_LOOP_REDO, loop735_redo
  loop735_done:
    pop_eh 
  for_undef_268:
.annotate 'line', 342
    find_lex $P738, "$obj"
    find_lex $P739, "%cache"
    publish_method_cache $P738, $P739
.annotate 'line', 330
    .return ()
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block706"  :anon :subid("50_1298325424.79949") :outer("49_1298325424.79949")
    .param pmc param_709
.annotate 'line', 334
    .const 'Sub' $P719 = "51_1298325424.79949" 
    capture_lex $P719
.annotate 'line', 335
    $P708 = root_new ['parrot';'Hash']
    .lex "%methods", $P708
    .lex "$_", param_709
    find_lex $P710, "$_"
    get_how $P711, $P710
    find_lex $P712, "$_"
    $P713 = $P711."method_table"($P712)
    store_lex "%methods", $P713
.annotate 'line', 336
    find_lex $P715, "%methods"
    defined $I716, $P715
    unless $I716, for_undef_269
    iter $P714, $P715
    new $P733, 'ExceptionHandler'
    set_label $P733, loop732_handler
    $P733."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P733
  loop732_test:
    unless $P714, loop732_done
    shift $P717, $P714
  loop732_redo:
    .const 'Sub' $P719 = "51_1298325424.79949" 
    capture_lex $P719
    $P719($P717)
  loop732_next:
    goto loop732_test
  loop732_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P734, exception, 'type'
    eq $P734, .CONTROL_LOOP_NEXT, loop732_next
    eq $P734, .CONTROL_LOOP_REDO, loop732_redo
  loop732_done:
    pop_eh 
  for_undef_269:
.annotate 'line', 334
    .return ($P714)
.end


.namespace ["NQPClassHOW"]
.sub "_block718"  :anon :subid("51_1298325424.79949") :outer("50_1298325424.79949")
    .param pmc param_720
.annotate 'line', 336
    .lex "$_", param_720
.annotate 'line', 337
    find_lex $P723, "$_"
    $P724 = $P723."key"()
    find_lex $P725, "%cache"
    unless_null $P725, vivify_270
    $P725 = root_new ['parrot';'Hash']
  vivify_270:
    set $P726, $P725[$P724]
    unless_null $P726, vivify_271
    new $P726, "Undef"
  vivify_271:
    unless $P726, unless_722
    set $P721, $P726
    goto unless_722_end
  unless_722:
.annotate 'line', 338
    find_lex $P727, "$_"
    $P728 = $P727."value"()
    find_lex $P729, "$_"
    $P730 = $P729."key"()
    find_lex $P731, "%cache"
    unless_null $P731, vivify_272
    $P731 = root_new ['parrot';'Hash']
    store_lex "%cache", $P731
  vivify_272:
    set $P731[$P730], $P728
.annotate 'line', 337
    set $P721, $P728
  unless_722_end:
.annotate 'line', 336
    .return ($P721)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "publish_parrot_vtable_mapping"  :subid("52_1298325424.79949") :outer("15_1298325424.79949")
    .param pmc param_741
    .param pmc param_742
.annotate 'line', 345
    .const 'Sub' $P752 = "53_1298325424.79949" 
    capture_lex $P752
    .lex "self", param_741
    .lex "$obj", param_742
.annotate 'line', 346
    $P743 = root_new ['parrot';'Hash']
    .lex "%mapping", $P743
.annotate 'line', 345
    find_lex $P744, "%mapping"
.annotate 'line', 347
    find_lex $P746, "self"
    get_global $P747, "$?CLASS"
    getattribute $P748, $P746, $P747, "@!mro"
    unless_null $P748, vivify_273
    $P748 = root_new ['parrot';'ResizablePMCArray']
  vivify_273:
    defined $I749, $P748
    unless $I749, for_undef_274
    iter $P745, $P748
    new $P781, 'ExceptionHandler'
    set_label $P781, loop780_handler
    $P781."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P781
  loop780_test:
    unless $P745, loop780_done
    shift $P750, $P745
  loop780_redo:
    .const 'Sub' $P752 = "53_1298325424.79949" 
    capture_lex $P752
    $P752($P750)
  loop780_next:
    goto loop780_test
  loop780_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P782, exception, 'type'
    eq $P782, .CONTROL_LOOP_NEXT, loop780_next
    eq $P782, .CONTROL_LOOP_REDO, loop780_redo
  loop780_done:
    pop_eh 
  for_undef_274:
.annotate 'line', 355
    find_lex $P785, "%mapping"
    set $N786, $P785
    if $N786, if_784
    new $P783, 'Float'
    set $P783, $N786
    goto if_784_end
  if_784:
.annotate 'line', 356
    find_lex $P787, "$obj"
    find_lex $P788, "%mapping"
    stable_publish_vtable_mapping $P787, $P788
  if_784_end:
.annotate 'line', 345
    .return ($P783)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block751"  :anon :subid("53_1298325424.79949") :outer("52_1298325424.79949")
    .param pmc param_754
.annotate 'line', 347
    .const 'Sub' $P764 = "54_1298325424.79949" 
    capture_lex $P764
.annotate 'line', 348
    $P753 = root_new ['parrot';'Hash']
    .lex "%map", $P753
    .lex "$_", param_754
    find_lex $P755, "$_"
    get_how $P756, $P755
    find_lex $P757, "$_"
    $P758 = $P756."parrot_vtable_mappings"($P757, 1 :named("local"))
    store_lex "%map", $P758
.annotate 'line', 349
    find_lex $P760, "%map"
    defined $I761, $P760
    unless $I761, for_undef_275
    iter $P759, $P760
    new $P778, 'ExceptionHandler'
    set_label $P778, loop777_handler
    $P778."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P778
  loop777_test:
    unless $P759, loop777_done
    shift $P762, $P759
  loop777_redo:
    .const 'Sub' $P764 = "54_1298325424.79949" 
    capture_lex $P764
    $P764($P762)
  loop777_next:
    goto loop777_test
  loop777_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P779, exception, 'type'
    eq $P779, .CONTROL_LOOP_NEXT, loop777_next
    eq $P779, .CONTROL_LOOP_REDO, loop777_redo
  loop777_done:
    pop_eh 
  for_undef_275:
.annotate 'line', 347
    .return ($P759)
.end


.namespace ["NQPClassHOW"]
.sub "_block763"  :anon :subid("54_1298325424.79949") :outer("53_1298325424.79949")
    .param pmc param_765
.annotate 'line', 349
    .lex "$_", param_765
.annotate 'line', 350
    find_lex $P768, "$_"
    $P769 = $P768."key"()
    find_lex $P770, "%mapping"
    unless_null $P770, vivify_276
    $P770 = root_new ['parrot';'Hash']
  vivify_276:
    set $P771, $P770[$P769]
    unless_null $P771, vivify_277
    new $P771, "Undef"
  vivify_277:
    unless $P771, unless_767
    set $P766, $P771
    goto unless_767_end
  unless_767:
.annotate 'line', 351
    find_lex $P772, "$_"
    $P773 = $P772."value"()
    find_lex $P774, "$_"
    $P775 = $P774."key"()
    find_lex $P776, "%mapping"
    unless_null $P776, vivify_278
    $P776 = root_new ['parrot';'Hash']
    store_lex "%mapping", $P776
  vivify_278:
    set $P776[$P775], $P773
.annotate 'line', 350
    set $P766, $P773
  unless_767_end:
.annotate 'line', 349
    .return ($P766)
.end


.namespace ["NQPClassHOW"]
.sub "parents"  :subid("55_1298325424.79949") :outer("15_1298325424.79949")
    .param pmc param_790
    .param pmc param_791
    .param pmc param_792 :optional :named("local")
    .param int has_param_792 :opt_flag
.annotate 'line', 364
    .lex "self", param_790
    .lex "$obj", param_791
    if has_param_792, optparam_279
    new $P793, "Undef"
    set param_792, $P793
  optparam_279:
    .lex "$local", param_792
.annotate 'line', 365
    find_lex $P796, "$local"
    if $P796, if_795
    find_lex $P800, "self"
    get_global $P801, "$?CLASS"
    getattribute $P802, $P800, $P801, "@!mro"
    unless_null $P802, vivify_280
    $P802 = root_new ['parrot';'ResizablePMCArray']
  vivify_280:
    set $P794, $P802
    goto if_795_end
  if_795:
    find_lex $P797, "self"
    get_global $P798, "$?CLASS"
    getattribute $P799, $P797, $P798, "@!parents"
    unless_null $P799, vivify_281
    $P799 = root_new ['parrot';'ResizablePMCArray']
  vivify_281:
    set $P794, $P799
  if_795_end:
.annotate 'line', 364
    .return ($P794)
.end


.namespace ["NQPClassHOW"]
.sub "roles"  :subid("56_1298325424.79949") :outer("15_1298325424.79949")
    .param pmc param_804
    .param pmc param_805
    .param pmc param_806 :named("local")
.annotate 'line', 368
    .lex "self", param_804
    .lex "$obj", param_805
    .lex "$local", param_806
    find_lex $P807, "self"
    get_global $P808, "$?CLASS"
    getattribute $P809, $P807, $P808, "@!roles"
    unless_null $P809, vivify_282
    $P809 = root_new ['parrot';'ResizablePMCArray']
  vivify_282:
    .return ($P809)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "methods"  :subid("57_1298325424.79949") :outer("15_1298325424.79949")
    .param pmc param_811
    .param pmc param_812
    .param pmc param_813 :named("local")
.annotate 'line', 372
    .const 'Sub' $P823 = "58_1298325424.79949" 
    capture_lex $P823
    .lex "self", param_811
    .lex "$obj", param_812
    .lex "$local", param_813
.annotate 'line', 373
    $P814 = root_new ['parrot';'ResizablePMCArray']
    .lex "@meths", $P814
.annotate 'line', 372
    find_lex $P815, "@meths"
.annotate 'line', 374
    find_lex $P817, "self"
    get_global $P818, "$?CLASS"
    getattribute $P819, $P817, $P818, "%!methods"
    unless_null $P819, vivify_283
    $P819 = root_new ['parrot';'Hash']
  vivify_283:
    defined $I820, $P819
    unless $I820, for_undef_284
    iter $P816, $P819
    new $P830, 'ExceptionHandler'
    set_label $P830, loop829_handler
    $P830."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P830
  loop829_test:
    unless $P816, loop829_done
    shift $P821, $P816
  loop829_redo:
    .const 'Sub' $P823 = "58_1298325424.79949" 
    capture_lex $P823
    $P823($P821)
  loop829_next:
    goto loop829_test
  loop829_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P831, exception, 'type'
    eq $P831, .CONTROL_LOOP_NEXT, loop829_next
    eq $P831, .CONTROL_LOOP_REDO, loop829_redo
  loop829_done:
    pop_eh 
  for_undef_284:
    find_lex $P832, "@meths"
.annotate 'line', 372
    .return ($P832)
.end


.namespace ["NQPClassHOW"]
.sub "_block822"  :anon :subid("58_1298325424.79949") :outer("57_1298325424.79949")
    .param pmc param_824
.annotate 'line', 374
    .lex "$_", param_824
.annotate 'line', 375
    find_lex $P825, "@meths"
    find_lex $P826, "$_"
    $P827 = $P826."value"()
    $P828 = $P825."push"($P827)
.annotate 'line', 374
    .return ($P828)
.end


.namespace ["NQPClassHOW"]
.sub "method_table"  :subid("59_1298325424.79949") :outer("15_1298325424.79949")
    .param pmc param_834
    .param pmc param_835
.annotate 'line', 380
    .lex "self", param_834
    .lex "$obj", param_835
    find_lex $P836, "self"
    get_global $P837, "$?CLASS"
    getattribute $P838, $P836, $P837, "%!methods"
    unless_null $P838, vivify_285
    $P838 = root_new ['parrot';'Hash']
  vivify_285:
    .return ($P838)
.end


.namespace ["NQPClassHOW"]
.sub "name"  :subid("60_1298325424.79949") :outer("15_1298325424.79949")
    .param pmc param_840
    .param pmc param_841
.annotate 'line', 384
    .lex "self", param_840
    .lex "$obj", param_841
    find_lex $P842, "self"
    get_global $P843, "$?CLASS"
    getattribute $P844, $P842, $P843, "$!name"
    unless_null $P844, vivify_286
    new $P844, "Undef"
  vivify_286:
    .return ($P844)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "attributes"  :subid("61_1298325424.79949") :outer("15_1298325424.79949")
    .param pmc param_846
    .param pmc param_847
    .param pmc param_848 :named("local")
.annotate 'line', 388
    .const 'Sub' $P858 = "62_1298325424.79949" 
    capture_lex $P858
    .lex "self", param_846
    .lex "$obj", param_847
    .lex "$local", param_848
.annotate 'line', 389
    $P849 = root_new ['parrot';'ResizablePMCArray']
    .lex "@attrs", $P849
.annotate 'line', 388
    find_lex $P850, "@attrs"
.annotate 'line', 390
    find_lex $P852, "self"
    get_global $P853, "$?CLASS"
    getattribute $P854, $P852, $P853, "%!attributes"
    unless_null $P854, vivify_287
    $P854 = root_new ['parrot';'Hash']
  vivify_287:
    defined $I855, $P854
    unless $I855, for_undef_288
    iter $P851, $P854
    new $P865, 'ExceptionHandler'
    set_label $P865, loop864_handler
    $P865."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P865
  loop864_test:
    unless $P851, loop864_done
    shift $P856, $P851
  loop864_redo:
    .const 'Sub' $P858 = "62_1298325424.79949" 
    capture_lex $P858
    $P858($P856)
  loop864_next:
    goto loop864_test
  loop864_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P866, exception, 'type'
    eq $P866, .CONTROL_LOOP_NEXT, loop864_next
    eq $P866, .CONTROL_LOOP_REDO, loop864_redo
  loop864_done:
    pop_eh 
  for_undef_288:
    find_lex $P867, "@attrs"
.annotate 'line', 388
    .return ($P867)
.end


.namespace ["NQPClassHOW"]
.sub "_block857"  :anon :subid("62_1298325424.79949") :outer("61_1298325424.79949")
    .param pmc param_859
.annotate 'line', 390
    .lex "$_", param_859
.annotate 'line', 391
    find_lex $P860, "@attrs"
    find_lex $P861, "$_"
    $P862 = $P861."value"()
    $P863 = $P860."push"($P862)
.annotate 'line', 390
    .return ($P863)
.end


.namespace ["NQPClassHOW"]
.sub "parrot_vtable_mappings"  :subid("63_1298325424.79949") :outer("15_1298325424.79949")
    .param pmc param_869
    .param pmc param_870
    .param pmc param_871 :named("local")
.annotate 'line', 396
    .lex "self", param_869
    .lex "$obj", param_870
    .lex "$local", param_871
    find_lex $P872, "self"
    get_global $P873, "$?CLASS"
    getattribute $P874, $P872, $P873, "%!parrot_vtable_mapping"
    unless_null $P874, vivify_289
    $P874 = root_new ['parrot';'Hash']
  vivify_289:
    .return ($P874)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "isa"  :subid("64_1298325424.79949") :outer("15_1298325424.79949")
    .param pmc param_878
    .param pmc param_879
    .param pmc param_880
.annotate 'line', 404
    new $P877, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P877, control_876
    push_eh $P877
    .lex "self", param_878
    .lex "$obj", param_879
    .lex "$check", param_880
.annotate 'line', 405
    new $P881, "Undef"
    .lex "$check-class", $P881
.annotate 'line', 406
    new $P882, "Undef"
    .lex "$i", $P882
.annotate 'line', 405
    find_lex $P883, "$check"
    get_what $P884, $P883
    store_lex "$check-class", $P884
.annotate 'line', 406
    find_lex $P885, "self"
    get_global $P886, "$?CLASS"
    getattribute $P887, $P885, $P886, "@!mro"
    unless_null $P887, vivify_290
    $P887 = root_new ['parrot';'ResizablePMCArray']
  vivify_290:
    set $N888, $P887
    new $P889, 'Float'
    set $P889, $N888
    store_lex "$i", $P889
.annotate 'line', 407
    new $P907, 'ExceptionHandler'
    set_label $P907, loop906_handler
    $P907."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P907
  loop906_test:
    find_lex $P890, "$i"
    set $N891, $P890
    isgt $I892, $N891, 0.0
    unless $I892, loop906_done
  loop906_redo:
.annotate 'line', 408
    find_lex $P893, "$i"
    sub $P894, $P893, 1
    store_lex "$i", $P894
.annotate 'line', 409
    find_lex $P896, "$i"
    set $I897, $P896
    find_lex $P898, "self"
    get_global $P899, "$?CLASS"
    getattribute $P900, $P898, $P899, "@!mro"
    unless_null $P900, vivify_291
    $P900 = root_new ['parrot';'ResizablePMCArray']
  vivify_291:
    set $P901, $P900[$I897]
    unless_null $P901, vivify_292
    new $P901, "Undef"
  vivify_292:
    find_lex $P902, "$check-class"
    issame $I903, $P901, $P902
    unless $I903, if_895_end
.annotate 'line', 410
    new $P904, "Exception"
    set $P904['type'], .CONTROL_RETURN
    new $P905, "Integer"
    assign $P905, 1
    setattribute $P904, 'payload', $P905
    throw $P904
  if_895_end:
  loop906_next:
.annotate 'line', 407
    goto loop906_test
  loop906_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P908, exception, 'type'
    eq $P908, .CONTROL_LOOP_NEXT, loop906_next
    eq $P908, .CONTROL_LOOP_REDO, loop906_redo
  loop906_done:
    pop_eh 
.annotate 'line', 413
    new $P909, "Exception"
    set $P909['type'], .CONTROL_RETURN
    new $P910, "Integer"
    assign $P910, 0
    setattribute $P909, 'payload', $P910
    throw $P909
.annotate 'line', 404
    .return ()
  control_876:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P911, exception, "payload"
    .return ($P911)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "does"  :subid("65_1298325424.79949") :outer("15_1298325424.79949")
    .param pmc param_915
    .param pmc param_916
    .param pmc param_917
.annotate 'line', 416
    new $P914, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P914, control_913
    push_eh $P914
    .lex "self", param_915
    .lex "$obj", param_916
    .lex "$check", param_917
.annotate 'line', 417
    new $P918, "Undef"
    .lex "$i", $P918
    find_lex $P919, "self"
    get_global $P920, "$?CLASS"
    getattribute $P921, $P919, $P920, "@!done"
    unless_null $P921, vivify_293
    $P921 = root_new ['parrot';'ResizablePMCArray']
  vivify_293:
    set $N922, $P921
    new $P923, 'Float'
    set $P923, $N922
    store_lex "$i", $P923
.annotate 'line', 418
    new $P941, 'ExceptionHandler'
    set_label $P941, loop940_handler
    $P941."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P941
  loop940_test:
    find_lex $P924, "$i"
    set $N925, $P924
    isgt $I926, $N925, 0.0
    unless $I926, loop940_done
  loop940_redo:
.annotate 'line', 419
    find_lex $P927, "$i"
    sub $P928, $P927, 1
    store_lex "$i", $P928
.annotate 'line', 420
    find_lex $P930, "$i"
    set $I931, $P930
    find_lex $P932, "self"
    get_global $P933, "$?CLASS"
    getattribute $P934, $P932, $P933, "@!done"
    unless_null $P934, vivify_294
    $P934 = root_new ['parrot';'ResizablePMCArray']
  vivify_294:
    set $P935, $P934[$I931]
    unless_null $P935, vivify_295
    new $P935, "Undef"
  vivify_295:
    find_lex $P936, "$check"
    issame $I937, $P935, $P936
    unless $I937, if_929_end
.annotate 'line', 421
    new $P938, "Exception"
    set $P938['type'], .CONTROL_RETURN
    new $P939, "Integer"
    assign $P939, 1
    setattribute $P938, 'payload', $P939
    throw $P938
  if_929_end:
  loop940_next:
.annotate 'line', 418
    goto loop940_test
  loop940_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P942, exception, 'type'
    eq $P942, .CONTROL_LOOP_NEXT, loop940_next
    eq $P942, .CONTROL_LOOP_REDO, loop940_redo
  loop940_done:
    pop_eh 
.annotate 'line', 424
    new $P943, "Exception"
    set $P943['type'], .CONTROL_RETURN
    new $P944, "Integer"
    assign $P944, 0
    setattribute $P943, 'payload', $P944
    throw $P943
.annotate 'line', 416
    .return ()
  control_913:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P945, exception, "payload"
    .return ($P945)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "can"  :subid("66_1298325424.79949") :outer("15_1298325424.79949")
    .param pmc param_949
    .param pmc param_950
    .param pmc param_951
.annotate 'line', 427
    .const 'Sub' $P959 = "67_1298325424.79949" 
    capture_lex $P959
    new $P948, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P948, control_947
    push_eh $P948
    .lex "self", param_949
    .lex "$obj", param_950
    .lex "$name", param_951
.annotate 'line', 428
    find_lex $P953, "self"
    get_global $P954, "$?CLASS"
    getattribute $P955, $P953, $P954, "@!mro"
    unless_null $P955, vivify_296
    $P955 = root_new ['parrot';'ResizablePMCArray']
  vivify_296:
    defined $I956, $P955
    unless $I956, for_undef_297
    iter $P952, $P955
    new $P977, 'ExceptionHandler'
    set_label $P977, loop976_handler
    $P977."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P977
  loop976_test:
    unless $P952, loop976_done
    shift $P957, $P952
  loop976_redo:
    .const 'Sub' $P959 = "67_1298325424.79949" 
    capture_lex $P959
    $P959($P957)
  loop976_next:
    goto loop976_test
  loop976_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P978, exception, 'type'
    eq $P978, .CONTROL_LOOP_NEXT, loop976_next
    eq $P978, .CONTROL_LOOP_REDO, loop976_redo
  loop976_done:
    pop_eh 
  for_undef_297:
.annotate 'line', 435
    new $P979, "Exception"
    set $P979['type'], .CONTROL_RETURN
    new $P980, "Integer"
    assign $P980, 0
    setattribute $P979, 'payload', $P980
    throw $P979
.annotate 'line', 427
    .return ()
  control_947:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P981, exception, "payload"
    .return ($P981)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block958"  :anon :subid("67_1298325424.79949") :outer("66_1298325424.79949")
    .param pmc param_962
.annotate 'line', 429
    $P960 = root_new ['parrot';'Hash']
    .lex "%meths", $P960
.annotate 'line', 430
    new $P961, "Undef"
    .lex "$can", $P961
    .lex "$_", param_962
.annotate 'line', 429
    find_lex $P963, "$_"
    get_how $P964, $P963
    find_lex $P965, "$obj"
    $P966 = $P964."method_table"($P965)
    store_lex "%meths", $P966
.annotate 'line', 430
    find_lex $P967, "$name"
    find_lex $P968, "%meths"
    unless_null $P968, vivify_298
    $P968 = root_new ['parrot';'Hash']
  vivify_298:
    set $P969, $P968[$P967]
    unless_null $P969, vivify_299
    new $P969, "Undef"
  vivify_299:
    store_lex "$can", $P969
.annotate 'line', 431
    find_lex $P972, "$can"
    defined $I973, $P972
    if $I973, if_971
    new $P970, 'Integer'
    set $P970, $I973
    goto if_971_end
  if_971:
.annotate 'line', 432
    new $P974, "Exception"
    set $P974['type'], .CONTROL_RETURN
    find_lex $P975, "$can"
    setattribute $P974, 'payload', $P975
    throw $P974
  if_971_end:
.annotate 'line', 428
    .return ($P970)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "find_method"  :subid("68_1298325424.79949") :outer("15_1298325424.79949")
    .param pmc param_985
    .param pmc param_986
    .param pmc param_987
.annotate 'line', 441
    .const 'Sub' $P995 = "69_1298325424.79949" 
    capture_lex $P995
    new $P984, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P984, control_983
    push_eh $P984
    .lex "self", param_985
    .lex "$obj", param_986
    .lex "$name", param_987
.annotate 'line', 442
    find_lex $P989, "self"
    get_global $P990, "$?CLASS"
    getattribute $P991, $P989, $P990, "@!mro"
    unless_null $P991, vivify_300
    $P991 = root_new ['parrot';'ResizablePMCArray']
  vivify_300:
    defined $I992, $P991
    unless $I992, for_undef_301
    iter $P988, $P991
    new $P1013, 'ExceptionHandler'
    set_label $P1013, loop1012_handler
    $P1013."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1013
  loop1012_test:
    unless $P988, loop1012_done
    shift $P993, $P988
  loop1012_redo:
    .const 'Sub' $P995 = "69_1298325424.79949" 
    capture_lex $P995
    $P995($P993)
  loop1012_next:
    goto loop1012_test
  loop1012_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1014, exception, 'type'
    eq $P1014, .CONTROL_LOOP_NEXT, loop1012_next
    eq $P1014, .CONTROL_LOOP_REDO, loop1012_redo
  loop1012_done:
    pop_eh 
  for_undef_301:
.annotate 'line', 449
    null $P1015
.annotate 'line', 441
    .return ($P1015)
  control_983:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1016, exception, "payload"
    .return ($P1016)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block994"  :anon :subid("69_1298325424.79949") :outer("68_1298325424.79949")
    .param pmc param_998
.annotate 'line', 443
    $P996 = root_new ['parrot';'Hash']
    .lex "%meths", $P996
.annotate 'line', 444
    new $P997, "Undef"
    .lex "$found", $P997
    .lex "$_", param_998
.annotate 'line', 443
    find_lex $P999, "$_"
    get_how $P1000, $P999
    find_lex $P1001, "$obj"
    $P1002 = $P1000."method_table"($P1001)
    store_lex "%meths", $P1002
.annotate 'line', 444
    find_lex $P1003, "$name"
    find_lex $P1004, "%meths"
    unless_null $P1004, vivify_302
    $P1004 = root_new ['parrot';'Hash']
  vivify_302:
    set $P1005, $P1004[$P1003]
    unless_null $P1005, vivify_303
    new $P1005, "Undef"
  vivify_303:
    store_lex "$found", $P1005
.annotate 'line', 445
    find_lex $P1008, "$found"
    defined $I1009, $P1008
    if $I1009, if_1007
    new $P1006, 'Integer'
    set $P1006, $I1009
    goto if_1007_end
  if_1007:
.annotate 'line', 446
    new $P1010, "Exception"
    set $P1010['type'], .CONTROL_RETURN
    find_lex $P1011, "$found"
    setattribute $P1010, 'payload', $P1011
    throw $P1010
  if_1007_end:
.annotate 'line', 442
    .return ($P1006)
.end


.namespace ["NQPNativeHOW"]
.sub "_block1110"  :subid("71_1298325424.79949") :outer("10_1298325424.79949")
.annotate 'line', 454
    .const 'Sub' $P1171 = "80_1298325424.79949" 
    capture_lex $P1171
    .const 'Sub' $P1163 = "79_1298325424.79949" 
    capture_lex $P1163
    .const 'Sub' $P1157 = "78_1298325424.79949" 
    capture_lex $P1157
    .const 'Sub' $P1153 = "77_1298325424.79949" 
    capture_lex $P1153
    .const 'Sub' $P1148 = "76_1298325424.79949" 
    capture_lex $P1148
    .const 'Sub' $P1143 = "75_1298325424.79949" 
    capture_lex $P1143
    .const 'Sub' $P1130 = "74_1298325424.79949" 
    capture_lex $P1130
    .const 'Sub' $P1123 = "73_1298325424.79949" 
    capture_lex $P1123
    .const 'Sub' $P1113 = "72_1298325424.79949" 
    capture_lex $P1113
    get_global $P1112, "$?CLASS"
.annotate 'line', 492
    .const 'Sub' $P1163 = "79_1298325424.79949" 
    newclosure $P1169, $P1163
.annotate 'line', 454
    .return ($P1169)
.end


.namespace ["NQPNativeHOW"]
.sub "" :load :init :subid("post304") :outer("71_1298325424.79949")
.annotate 'line', 454
    get_hll_global $P1111, ["NQPNativeHOW"], "_block1110" 
    .local pmc block
    set block, $P1111
    .const 'Sub' $P1171 = "80_1298325424.79949" 
    capture_lex $P1171
    $P1171()
.end


.namespace ["NQPNativeHOW"]
.sub "_block1170"  :anon :subid("80_1298325424.79949") :outer("71_1298325424.79949")
.annotate 'line', 454
    get_hll_global $P1172, "KnowHOW"
    $P1173 = $P1172."new_type"("NQPNativeHOW" :named("name"))
    .local pmc type_obj
    set type_obj, $P1173
    set_hll_global "NQPNativeHOW", type_obj
    set_global "$?CLASS", type_obj
    get_how $P1174, type_obj
    get_hll_global $P1175, "KnowHOWAttribute"
    $P1176 = $P1175."new"("$!name" :named("name"))
    $P1174."add_attribute"(type_obj, $P1176)
    get_how $P1177, type_obj
    get_hll_global $P1178, "KnowHOWAttribute"
    $P1179 = $P1178."new"("$!composed" :named("name"))
    $P1177."add_attribute"(type_obj, $P1179)
    get_how $P1180, type_obj
    .const 'Sub' $P1181 = "72_1298325424.79949" 
    $P1180."add_method"(type_obj, "new", $P1181)
    get_how $P1182, type_obj
    .const 'Sub' $P1183 = "73_1298325424.79949" 
    $P1182."add_method"(type_obj, "BUILD", $P1183)
    get_how $P1184, type_obj
    .const 'Sub' $P1185 = "74_1298325424.79949" 
    $P1184."add_method"(type_obj, "new_type", $P1185)
    get_how $P1186, type_obj
    .const 'Sub' $P1187 = "75_1298325424.79949" 
    $P1186."add_method"(type_obj, "add_method", $P1187)
    get_how $P1188, type_obj
    .const 'Sub' $P1189 = "76_1298325424.79949" 
    $P1188."add_method"(type_obj, "add_multi_method", $P1189)
    get_how $P1190, type_obj
    .const 'Sub' $P1191 = "77_1298325424.79949" 
    $P1190."add_method"(type_obj, "add_attribute", $P1191)
    get_how $P1192, type_obj
    .const 'Sub' $P1193 = "78_1298325424.79949" 
    $P1192."add_method"(type_obj, "compose", $P1193)
    get_how $P1194, type_obj
    .const 'Sub' $P1195 = "79_1298325424.79949" 
    $P1194."add_method"(type_obj, "name", $P1195)
    get_how $P1196, type_obj
    $P1197 = $P1196."compose"(type_obj)
    .return ($P1197)
.end


.namespace ["NQPNativeHOW"]
.sub "new"  :subid("72_1298325424.79949") :outer("71_1298325424.79949")
    .param pmc param_1114
    .param pmc param_1115 :optional :named("name")
    .param int has_param_1115 :opt_flag
.annotate 'line', 458
    .lex "self", param_1114
    if has_param_1115, optparam_305
    new $P1116, "Undef"
    set param_1115, $P1116
  optparam_305:
    .lex "$name", param_1115
.annotate 'line', 459
    new $P1117, "Undef"
    .lex "$obj", $P1117
    find_lex $P1118, "self"
    repr_instance_of $P1119, $P1118
    store_lex "$obj", $P1119
.annotate 'line', 460
    find_lex $P1120, "$obj"
    find_lex $P1121, "$name"
    $P1120."BUILD"($P1121 :named("name"))
    find_lex $P1122, "$obj"
.annotate 'line', 458
    .return ($P1122)
.end


.namespace ["NQPNativeHOW"]
.sub "BUILD"  :subid("73_1298325424.79949") :outer("71_1298325424.79949")
    .param pmc param_1124
    .param pmc param_1125 :optional :named("name")
    .param int has_param_1125 :opt_flag
.annotate 'line', 464
    .lex "self", param_1124
    if has_param_1125, optparam_306
    new $P1126, "Undef"
    set param_1125, $P1126
  optparam_306:
    .lex "$name", param_1125
.annotate 'line', 465
    find_lex $P1127, "$name"
    find_lex $P1128, "self"
    get_global $P1129, "$?CLASS"
    setattribute $P1128, $P1129, "$!name", $P1127
.annotate 'line', 464
    .return ($P1127)
.end


.namespace ["NQPNativeHOW"]
.sub "new_type"  :subid("74_1298325424.79949") :outer("71_1298325424.79949")
    .param pmc param_1131
    .param pmc param_1134 :named("repr")
    .param pmc param_1132 :optional :named("name")
    .param int has_param_1132 :opt_flag
.annotate 'line', 471
    .lex "self", param_1131
    if has_param_1132, optparam_307
    new $P1133, "String"
    assign $P1133, "<anon>"
    set param_1132, $P1133
  optparam_307:
    .lex "$name", param_1132
    .lex "$repr", param_1134
.annotate 'line', 472
    new $P1135, "Undef"
    .lex "$metaclass", $P1135
    find_lex $P1136, "self"
    find_lex $P1137, "$name"
    $P1138 = $P1136."new"($P1137 :named("name"))
    store_lex "$metaclass", $P1138
.annotate 'line', 473
    find_lex $P1139, "$metaclass"
    find_lex $P1140, "$repr"
    set $S1141, $P1140
    repr_type_object_for $P1142, $P1139, $S1141
.annotate 'line', 471
    .return ($P1142)
.end


.namespace ["NQPNativeHOW"]
.sub "add_method"  :subid("75_1298325424.79949") :outer("71_1298325424.79949")
    .param pmc param_1144
    .param pmc param_1145
    .param pmc param_1146
    .param pmc param_1147
.annotate 'line', 476
    .lex "self", param_1144
    .lex "$obj", param_1145
    .lex "$name", param_1146
    .lex "$code_obj", param_1147
.annotate 'line', 477
    die "Native types may not have methods (must be boxed to call method)"
.annotate 'line', 476
    .return ()
.end


.namespace ["NQPNativeHOW"]
.sub "add_multi_method"  :subid("76_1298325424.79949") :outer("71_1298325424.79949")
    .param pmc param_1149
    .param pmc param_1150
    .param pmc param_1151
    .param pmc param_1152
.annotate 'line', 480
    .lex "self", param_1149
    .lex "$obj", param_1150
    .lex "$name", param_1151
    .lex "$code_obj", param_1152
.annotate 'line', 481
    die "Native types may not have methods (must be boxed to call method)"
.annotate 'line', 480
    .return ()
.end


.namespace ["NQPNativeHOW"]
.sub "add_attribute"  :subid("77_1298325424.79949") :outer("71_1298325424.79949")
    .param pmc param_1154
    .param pmc param_1155
    .param pmc param_1156
.annotate 'line', 484
    .lex "self", param_1154
    .lex "$obj", param_1155
    .lex "$meta_attr", param_1156
.annotate 'line', 485
    die "Native types may not have attributes"
.annotate 'line', 484
    .return ()
.end


.namespace ["NQPNativeHOW"]
.sub "compose"  :subid("78_1298325424.79949") :outer("71_1298325424.79949")
    .param pmc param_1158
    .param pmc param_1159
.annotate 'line', 488
    .lex "self", param_1158
    .lex "$obj", param_1159
.annotate 'line', 489
    new $P1160, "Integer"
    assign $P1160, 1
    find_lex $P1161, "self"
    get_global $P1162, "$?CLASS"
    setattribute $P1161, $P1162, "$!composed", $P1160
.annotate 'line', 488
    .return ($P1160)
.end


.namespace ["NQPNativeHOW"]
.sub "name"  :subid("79_1298325424.79949") :outer("71_1298325424.79949")
    .param pmc param_1164
    .param pmc param_1165
.annotate 'line', 492
    .lex "self", param_1164
    .lex "$obj", param_1165
    find_lex $P1166, "self"
    get_global $P1167, "$?CLASS"
    getattribute $P1168, $P1166, $P1167, "$!name"
    unless_null $P1168, vivify_308
    new $P1168, "Undef"
  vivify_308:
    .return ($P1168)
.end


.namespace ["NQPAttribute"]
.sub "_block1198"  :subid("81_1298325424.79949") :outer("10_1298325424.79949")
.annotate 'line', 498
    .const 'Sub' $P1382 = "95_1298325424.79949" 
    capture_lex $P1382
    .const 'Sub' $P1372 = "94_1298325424.79949" 
    capture_lex $P1372
    .const 'Sub' $P1291 = "89_1298325424.79949" 
    capture_lex $P1291
    .const 'Sub' $P1282 = "88_1298325424.79949" 
    capture_lex $P1282
    .const 'Sub' $P1273 = "87_1298325424.79949" 
    capture_lex $P1273
    .const 'Sub' $P1268 = "86_1298325424.79949" 
    capture_lex $P1268
    .const 'Sub' $P1251 = "85_1298325424.79949" 
    capture_lex $P1251
    .const 'Sub' $P1236 = "84_1298325424.79949" 
    capture_lex $P1236
    .const 'Sub' $P1201 = "82_1298325424.79949" 
    capture_lex $P1201
    get_global $P1200, "$?CLASS"
.annotate 'line', 558
    .const 'Sub' $P1201 = "82_1298325424.79949" 
    newclosure $P1235, $P1201
    .lex "has_method", $P1235
.annotate 'line', 554
    find_lex $P1380, "has_method"
.annotate 'line', 498
    .return ($P1380)
.end


.namespace ["NQPAttribute"]
.sub "" :load :init :subid("post309") :outer("81_1298325424.79949")
.annotate 'line', 498
    get_hll_global $P1199, ["NQPAttribute"], "_block1198" 
    .local pmc block
    set block, $P1199
    .const 'Sub' $P1382 = "95_1298325424.79949" 
    capture_lex $P1382
    $P1382()
.end


.namespace ["NQPAttribute"]
.sub "_block1381"  :anon :subid("95_1298325424.79949") :outer("81_1298325424.79949")
.annotate 'line', 498
    get_hll_global $P1383, "KnowHOW"
    $P1384 = $P1383."new_type"("NQPAttribute" :named("name"))
    .local pmc type_obj
    set type_obj, $P1384
    set_hll_global "NQPAttribute", type_obj
    set_global "$?CLASS", type_obj
    get_how $P1385, type_obj
    get_hll_global $P1386, "KnowHOWAttribute"
    $P1387 = $P1386."new"("$!name" :named("name"))
    $P1385."add_attribute"(type_obj, $P1387)
    get_how $P1388, type_obj
    get_hll_global $P1389, "KnowHOWAttribute"
    $P1390 = $P1389."new"("$!type" :named("name"))
    $P1388."add_attribute"(type_obj, $P1390)
    get_how $P1391, type_obj
    get_hll_global $P1392, "KnowHOWAttribute"
    $P1393 = $P1392."new"("$!box_target" :named("name"))
    $P1391."add_attribute"(type_obj, $P1393)
    get_how $P1394, type_obj
    .const 'Sub' $P1395 = "84_1298325424.79949" 
    $P1394."add_method"(type_obj, "new", $P1395)
    get_how $P1396, type_obj
    .const 'Sub' $P1397 = "85_1298325424.79949" 
    $P1396."add_method"(type_obj, "BUILD", $P1397)
    get_how $P1398, type_obj
    .const 'Sub' $P1399 = "86_1298325424.79949" 
    $P1398."add_method"(type_obj, "name", $P1399)
    get_how $P1400, type_obj
    .const 'Sub' $P1401 = "87_1298325424.79949" 
    $P1400."add_method"(type_obj, "type", $P1401)
    get_how $P1402, type_obj
    .const 'Sub' $P1403 = "88_1298325424.79949" 
    $P1402."add_method"(type_obj, "box_target", $P1403)
    get_how $P1404, type_obj
    .const 'Sub' $P1405 = "89_1298325424.79949" 
    $P1404."add_method"(type_obj, "compose", $P1405)
    get_how $P1406, type_obj
    .const 'Sub' $P1407 = "94_1298325424.79949" 
    $P1406."add_method"(type_obj, "has_mutator", $P1407)
    get_how $P1408, type_obj
    $P1409 = $P1408."compose"(type_obj)
    .return ($P1409)
.end


.namespace ["NQPAttribute"]
.include "except_types.pasm"
.sub "has_method"  :subid("82_1298325424.79949") :outer("81_1298325424.79949")
    .param pmc param_1204
    .param pmc param_1205
    .param pmc param_1206
.annotate 'line', 558
    .const 'Sub' $P1218 = "83_1298325424.79949" 
    capture_lex $P1218
    new $P1203, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P1203, control_1202
    push_eh $P1203
    .lex "$target", param_1204
    .lex "$name", param_1205
    .lex "$local", param_1206
.annotate 'line', 559
    $P1207 = root_new ['parrot';'ResizablePMCArray']
    .lex "@methods", $P1207
    find_lex $P1208, "$target"
    get_how $P1209, $P1208
    find_lex $P1210, "$target"
    find_lex $P1211, "$local"
    $P1212 = $P1209."methods"($P1210, $P1211 :named("local"))
    store_lex "@methods", $P1212
.annotate 'line', 560
    find_lex $P1214, "@methods"
    defined $I1215, $P1214
    unless $I1215, for_undef_310
    iter $P1213, $P1214
    new $P1230, 'ExceptionHandler'
    set_label $P1230, loop1229_handler
    $P1230."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1230
  loop1229_test:
    unless $P1213, loop1229_done
    shift $P1216, $P1213
  loop1229_redo:
    .const 'Sub' $P1218 = "83_1298325424.79949" 
    capture_lex $P1218
    $P1218($P1216)
  loop1229_next:
    goto loop1229_test
  loop1229_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1231, exception, 'type'
    eq $P1231, .CONTROL_LOOP_NEXT, loop1229_next
    eq $P1231, .CONTROL_LOOP_REDO, loop1229_redo
  loop1229_done:
    pop_eh 
  for_undef_310:
.annotate 'line', 563
    new $P1232, "Exception"
    set $P1232['type'], .CONTROL_RETURN
    new $P1233, "Integer"
    assign $P1233, 0
    setattribute $P1232, 'payload', $P1233
    throw $P1232
.annotate 'line', 558
    .return ()
  control_1202:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1234, exception, "payload"
    .return ($P1234)
.end


.namespace ["NQPAttribute"]
.include "except_types.pasm"
.sub "_block1217"  :anon :subid("83_1298325424.79949") :outer("82_1298325424.79949")
    .param pmc param_1219
.annotate 'line', 560
    .lex "$_", param_1219
.annotate 'line', 561
    find_lex $P1222, "$_"
    set $S1223, $P1222
    find_lex $P1224, "$name"
    set $S1225, $P1224
    iseq $I1226, $S1223, $S1225
    if $I1226, if_1221
    new $P1220, 'Integer'
    set $P1220, $I1226
    goto if_1221_end
  if_1221:
    new $P1227, "Exception"
    set $P1227['type'], .CONTROL_RETURN
    new $P1228, "Integer"
    assign $P1228, 1
    setattribute $P1227, 'payload', $P1228
    throw $P1227
  if_1221_end:
.annotate 'line', 560
    .return ($P1220)
.end


.namespace ["NQPAttribute"]
.sub "new"  :subid("84_1298325424.79949") :outer("81_1298325424.79949")
    .param pmc param_1237
    .param pmc param_1238 :named("name")
    .param pmc param_1239 :optional :named("type")
    .param int has_param_1239 :opt_flag
    .param pmc param_1241 :optional :named("box_target")
    .param int has_param_1241 :opt_flag
.annotate 'line', 503
    .lex "self", param_1237
    .lex "$name", param_1238
    if has_param_1239, optparam_311
    new $P1240, "Undef"
    set param_1239, $P1240
  optparam_311:
    .lex "$type", param_1239
    if has_param_1241, optparam_312
    new $P1242, "Undef"
    set param_1241, $P1242
  optparam_312:
    .lex "$box_target", param_1241
.annotate 'line', 504
    new $P1243, "Undef"
    .lex "$attr", $P1243
    find_lex $P1244, "self"
    repr_instance_of $P1245, $P1244
    store_lex "$attr", $P1245
.annotate 'line', 505
    find_lex $P1246, "$attr"
    find_lex $P1247, "$name"
    find_lex $P1248, "$type"
    find_lex $P1249, "$box_target"
    $P1246."BUILD"($P1247 :named("name"), $P1248 :named("type"), $P1249 :named("box_target"))
    find_lex $P1250, "$attr"
.annotate 'line', 503
    .return ($P1250)
.end


.namespace ["NQPAttribute"]
.sub "BUILD"  :subid("85_1298325424.79949") :outer("81_1298325424.79949")
    .param pmc param_1252
    .param pmc param_1253 :optional :named("name")
    .param int has_param_1253 :opt_flag
    .param pmc param_1255 :optional :named("type")
    .param int has_param_1255 :opt_flag
    .param pmc param_1257 :optional :named("box_target")
    .param int has_param_1257 :opt_flag
.annotate 'line', 509
    .lex "self", param_1252
    if has_param_1253, optparam_313
    new $P1254, "Undef"
    set param_1253, $P1254
  optparam_313:
    .lex "$name", param_1253
    if has_param_1255, optparam_314
    new $P1256, "Undef"
    set param_1255, $P1256
  optparam_314:
    .lex "$type", param_1255
    if has_param_1257, optparam_315
    new $P1258, "Undef"
    set param_1257, $P1258
  optparam_315:
    .lex "$box_target", param_1257
.annotate 'line', 510
    find_lex $P1259, "$name"
    find_lex $P1260, "self"
    get_global $P1261, "$?CLASS"
    setattribute $P1260, $P1261, "$!name", $P1259
.annotate 'line', 511
    find_lex $P1262, "$type"
    find_lex $P1263, "self"
    get_global $P1264, "$?CLASS"
    setattribute $P1263, $P1264, "$!type", $P1262
.annotate 'line', 512
    find_lex $P1265, "$box_target"
    find_lex $P1266, "self"
    get_global $P1267, "$?CLASS"
    setattribute $P1266, $P1267, "$!box_target", $P1265
.annotate 'line', 509
    .return ($P1265)
.end


.namespace ["NQPAttribute"]
.sub "name"  :subid("86_1298325424.79949") :outer("81_1298325424.79949")
    .param pmc param_1269
.annotate 'line', 515
    .lex "self", param_1269
    find_lex $P1270, "self"
    get_global $P1271, "$?CLASS"
    getattribute $P1272, $P1270, $P1271, "$!name"
    unless_null $P1272, vivify_316
    new $P1272, "Undef"
  vivify_316:
    .return ($P1272)
.end


.namespace ["NQPAttribute"]
.sub "type"  :subid("87_1298325424.79949") :outer("81_1298325424.79949")
    .param pmc param_1274
.annotate 'line', 519
    .lex "self", param_1274
.annotate 'line', 520
    find_lex $P1276, "self"
    get_global $P1277, "$?CLASS"
    getattribute $P1278, $P1276, $P1277, "$!type"
    unless_null $P1278, vivify_317
    new $P1278, "Undef"
  vivify_317:
    set $P1275, $P1278
    defined $I1280, $P1275
    if $I1280, default_1279
    null $P1281
    set $P1275, $P1281
  default_1279:
.annotate 'line', 519
    .return ($P1275)
.end


.namespace ["NQPAttribute"]
.sub "box_target"  :subid("88_1298325424.79949") :outer("81_1298325424.79949")
    .param pmc param_1283
.annotate 'line', 523
    .lex "self", param_1283
.annotate 'line', 524
    find_lex $P1286, "self"
    get_global $P1287, "$?CLASS"
    getattribute $P1288, $P1286, $P1287, "$!box_target"
    unless_null $P1288, vivify_318
    new $P1288, "Undef"
  vivify_318:
    if $P1288, if_1285
    new $P1290, "Integer"
    assign $P1290, 0
    set $P1284, $P1290
    goto if_1285_end
  if_1285:
    new $P1289, "Integer"
    assign $P1289, 1
    set $P1284, $P1289
  if_1285_end:
.annotate 'line', 523
    .return ($P1284)
.end


.namespace ["NQPAttribute"]
.sub "compose"  :subid("89_1298325424.79949") :outer("81_1298325424.79949")
    .param pmc param_1292
    .param pmc param_1293
.annotate 'line', 527
    .const 'Sub' $P1345 = "92_1298325424.79949" 
    capture_lex $P1345
    .const 'Sub' $P1305 = "90_1298325424.79949" 
    capture_lex $P1305
    .lex "self", param_1292
    .lex "$obj", param_1293
.annotate 'line', 528
    new $P1294, "Undef"
    .lex "$long_name", $P1294
    find_lex $P1295, "self"
    get_global $P1296, "$?CLASS"
    getattribute $P1297, $P1295, $P1296, "$!name"
    unless_null $P1297, vivify_319
    new $P1297, "Undef"
  vivify_319:
    set $S1298, $P1297
    new $P1299, 'String'
    set $P1299, $S1298
    store_lex "$long_name", $P1299
.annotate 'line', 529
    find_lex $P1302, "self"
    $P1303 = $P1302."has_mutator"()
    if $P1303, if_1301
.annotate 'line', 541
    .const 'Sub' $P1345 = "92_1298325424.79949" 
    capture_lex $P1345
    $P1371 = $P1345()
    set $P1300, $P1371
.annotate 'line', 529
    goto if_1301_end
  if_1301:
    .const 'Sub' $P1305 = "90_1298325424.79949" 
    capture_lex $P1305
    $P1343 = $P1305()
    set $P1300, $P1343
  if_1301_end:
.annotate 'line', 527
    .return ($P1300)
.end


.namespace ["NQPAttribute"]
.sub "_block1344"  :anon :subid("92_1298325424.79949") :outer("89_1298325424.79949")
.annotate 'line', 541
    .const 'Sub' $P1361 = "93_1298325424.79949" 
    capture_lex $P1361
.annotate 'line', 542
    new $P1346, "Undef"
    .lex "$method", $P1346
    find_lex $P1347, "$long_name"
    set $S1348, $P1347
    substr $S1349, $S1348, 2
    new $P1350, 'String'
    set $P1350, $S1349
    store_lex "$method", $P1350
.annotate 'line', 543
    find_lex $P1353, "$obj"
    find_lex $P1354, "$method"
    $P1355 = "has_method"($P1353, $P1354, 0)
    unless $P1355, unless_1352
    set $P1351, $P1355
    goto unless_1352_end
  unless_1352:
.annotate 'line', 544
    find_lex $P1356, "$obj"
    get_how $P1357, $P1356
    find_lex $P1358, "$obj"
    find_lex $P1359, "$method"
.annotate 'line', 545
    .const 'Sub' $P1361 = "93_1298325424.79949" 
    newclosure $P1369, $P1361
    $P1370 = $P1357."add_method"($P1358, $P1359, $P1369)
.annotate 'line', 543
    set $P1351, $P1370
  unless_1352_end:
.annotate 'line', 541
    .return ($P1351)
.end


.namespace ["NQPAttribute"]
.sub "_block1360"  :anon :subid("93_1298325424.79949") :outer("92_1298325424.79949")
    .param pmc param_1362
.annotate 'line', 545
    .lex "self", param_1362
.annotate 'line', 546
    find_lex $P1363, "self"
    find_lex $P1364, "$obj"
    get_what $P1365, $P1364
    find_lex $P1366, "$long_name"
    set $S1367, $P1366
    getattribute $P1368, $P1363, $P1365, $S1367
.annotate 'line', 545
    .return ($P1368)
.end


.namespace ["NQPAttribute"]
.sub "_block1304"  :anon :subid("90_1298325424.79949") :outer("89_1298325424.79949")
.annotate 'line', 529
    .const 'Sub' $P1322 = "91_1298325424.79949" 
    capture_lex $P1322
.annotate 'line', 530
    new $P1306, "Undef"
    .lex "$method", $P1306
    find_lex $P1307, "$long_name"
    set $S1308, $P1307
    substr $S1309, $S1308, 1
    new $P1310, 'String'
    set $P1310, $S1309
    store_lex "$method", $P1310
.annotate 'line', 531
    find_lex $P1313, "$obj"
    find_lex $P1314, "$method"
    $P1315 = "has_method"($P1313, $P1314, 0)
    unless $P1315, unless_1312
    set $P1311, $P1315
    goto unless_1312_end
  unless_1312:
.annotate 'line', 532
    find_lex $P1316, "$obj"
    get_how $P1317, $P1316
    find_lex $P1318, "$obj"
    get_what $P1319, $P1318
    find_lex $P1320, "$method"
    .const 'Sub' $P1322 = "91_1298325424.79949" 
    newclosure $P1341, $P1322
    $P1342 = $P1317."add_method"($P1319, $P1320, $P1341)
.annotate 'line', 531
    set $P1311, $P1342
  unless_1312_end:
.annotate 'line', 529
    .return ($P1311)
.end


.namespace ["NQPAttribute"]
.sub "_block1321"  :anon :subid("91_1298325424.79949") :outer("90_1298325424.79949")
    .param pmc param_1323
    .param pmc param_1324 :optional
    .param int has_param_1324 :opt_flag
.annotate 'line', 532
    .lex "self", param_1323
    if has_param_1324, optparam_320
    new $P1325, "Undef"
    set param_1324, $P1325
  optparam_320:
    .lex "$value", param_1324
.annotate 'line', 534
    find_lex $P1327, "$value"
    defined $I1328, $P1327
    unless $I1328, if_1326_end
.annotate 'line', 533
    find_lex $P1329, "self"
    find_lex $P1330, "$obj"
    get_what $P1331, $P1330
    find_lex $P1332, "$long_name"
    set $S1333, $P1332
    find_lex $P1334, "$value"
    setattribute $P1329, $P1331, $S1333, $P1334
  if_1326_end:
.annotate 'line', 536
    find_lex $P1335, "self"
    find_lex $P1336, "$obj"
    get_what $P1337, $P1336
    find_lex $P1338, "$long_name"
    set $S1339, $P1338
    getattribute $P1340, $P1335, $P1337, $S1339
.annotate 'line', 532
    .return ($P1340)
.end


.namespace ["NQPAttribute"]
.sub "has_mutator"  :subid("94_1298325424.79949") :outer("81_1298325424.79949")
    .param pmc param_1373
.annotate 'line', 554
    .lex "self", param_1373
.annotate 'line', 555
    find_lex $P1374, "self"
    get_global $P1375, "$?CLASS"
    getattribute $P1376, $P1374, $P1375, "$!name"
    unless_null $P1376, vivify_321
    new $P1376, "Undef"
  vivify_321:
    set $S1377, $P1376
    substr $S1378, $S1377, 1, 1
    isne $I1379, $S1378, "!"
.annotate 'line', 554
    .return ($I1379)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "_block1410"  :subid("96_1298325424.79949") :outer("10_1298325424.79949")
.annotate 'line', 571
    .const 'Sub' $P1666 = "117_1298325424.79949" 
    capture_lex $P1666
    .const 'Sub' $P1658 = "116_1298325424.79949" 
    capture_lex $P1658
    .const 'Sub' $P1652 = "115_1298325424.79949" 
    capture_lex $P1652
    .const 'Sub' $P1630 = "113_1298325424.79949" 
    capture_lex $P1630
    .const 'Sub' $P1624 = "112_1298325424.79949" 
    capture_lex $P1624
    .const 'Sub' $P1618 = "111_1298325424.79949" 
    capture_lex $P1618
    .const 'Sub' $P1612 = "110_1298325424.79949" 
    capture_lex $P1612
    .const 'Sub' $P1590 = "108_1298325424.79949" 
    capture_lex $P1590
    .const 'Sub' $P1541 = "106_1298325424.79949" 
    capture_lex $P1541
    .const 'Sub' $P1528 = "105_1298325424.79949" 
    capture_lex $P1528
    .const 'Sub' $P1515 = "104_1298325424.79949" 
    capture_lex $P1515
    .const 'Sub' $P1511 = "103_1298325424.79949" 
    capture_lex $P1511
    .const 'Sub' $P1490 = "102_1298325424.79949" 
    capture_lex $P1490
    .const 'Sub' $P1469 = "101_1298325424.79949" 
    capture_lex $P1469
    .const 'Sub' $P1450 = "100_1298325424.79949" 
    capture_lex $P1450
    .const 'Sub' $P1434 = "99_1298325424.79949" 
    capture_lex $P1434
    .const 'Sub' $P1424 = "98_1298325424.79949" 
    capture_lex $P1424
    .const 'Sub' $P1413 = "97_1298325424.79949" 
    capture_lex $P1413
    get_global $P1412, "$?CLASS"
.annotate 'line', 710
    .const 'Sub' $P1658 = "116_1298325424.79949" 
    newclosure $P1664, $P1658
.annotate 'line', 571
    .return ($P1664)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "" :load :init :subid("post322") :outer("96_1298325424.79949")
.annotate 'line', 571
    get_hll_global $P1411, ["NQPConcreteRoleHOW"], "_block1410" 
    .local pmc block
    set block, $P1411
    .const 'Sub' $P1666 = "117_1298325424.79949" 
    capture_lex $P1666
    $P1666()
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "_block1665"  :anon :subid("117_1298325424.79949") :outer("96_1298325424.79949")
.annotate 'line', 571
    get_hll_global $P1667, "KnowHOW"
    $P1668 = $P1667."new_type"("NQPConcreteRoleHOW" :named("name"))
    .local pmc type_obj
    set type_obj, $P1668
    set_hll_global "NQPConcreteRoleHOW", type_obj
    set_global "$?CLASS", type_obj
    get_how $P1669, type_obj
    get_hll_global $P1670, "KnowHOWAttribute"
    $P1671 = $P1670."new"("$!name" :named("name"))
    $P1669."add_attribute"(type_obj, $P1671)
    get_how $P1672, type_obj
    get_hll_global $P1673, "KnowHOWAttribute"
    $P1674 = $P1673."new"("$!instance_of" :named("name"))
    $P1672."add_attribute"(type_obj, $P1674)
    get_how $P1675, type_obj
    get_hll_global $P1676, "KnowHOWAttribute"
    $P1677 = $P1676."new"("%!attributes" :named("name"))
    $P1675."add_attribute"(type_obj, $P1677)
    get_how $P1678, type_obj
    get_hll_global $P1679, "KnowHOWAttribute"
    $P1680 = $P1679."new"("%!methods" :named("name"))
    $P1678."add_attribute"(type_obj, $P1680)
    get_how $P1681, type_obj
    get_hll_global $P1682, "KnowHOWAttribute"
    $P1683 = $P1682."new"("@!multi_methods_to_incorporate" :named("name"))
    $P1681."add_attribute"(type_obj, $P1683)
    get_how $P1684, type_obj
    get_hll_global $P1685, "KnowHOWAttribute"
    $P1686 = $P1685."new"("@!collisions" :named("name"))
    $P1684."add_attribute"(type_obj, $P1686)
    get_how $P1687, type_obj
    get_hll_global $P1688, "KnowHOWAttribute"
    $P1689 = $P1688."new"("@!roles" :named("name"))
    $P1687."add_attribute"(type_obj, $P1689)
    get_how $P1690, type_obj
    get_hll_global $P1691, "KnowHOWAttribute"
    $P1692 = $P1691."new"("@!done" :named("name"))
    $P1690."add_attribute"(type_obj, $P1692)
    get_how $P1693, type_obj
    get_hll_global $P1694, "KnowHOWAttribute"
    $P1695 = $P1694."new"("$!composed" :named("name"))
    $P1693."add_attribute"(type_obj, $P1695)
    get_how $P1696, type_obj
    .const 'Sub' $P1697 = "97_1298325424.79949" 
    $P1696."add_method"(type_obj, "new", $P1697)
    get_how $P1698, type_obj
    .const 'Sub' $P1699 = "98_1298325424.79949" 
    $P1698."add_method"(type_obj, "BUILD", $P1699)
    get_how $P1700, type_obj
    .const 'Sub' $P1701 = "99_1298325424.79949" 
    $P1700."add_method"(type_obj, "new_type", $P1701)
    get_how $P1702, type_obj
    .const 'Sub' $P1703 = "100_1298325424.79949" 
    $P1702."add_method"(type_obj, "add_method", $P1703)
    get_how $P1704, type_obj
    .const 'Sub' $P1705 = "101_1298325424.79949" 
    $P1704."add_method"(type_obj, "add_multi_method", $P1705)
    get_how $P1706, type_obj
    .const 'Sub' $P1707 = "102_1298325424.79949" 
    $P1706."add_method"(type_obj, "add_attribute", $P1707)
    get_how $P1708, type_obj
    .const 'Sub' $P1709 = "103_1298325424.79949" 
    $P1708."add_method"(type_obj, "add_parent", $P1709)
    get_how $P1710, type_obj
    .const 'Sub' $P1711 = "104_1298325424.79949" 
    $P1710."add_method"(type_obj, "add_role", $P1711)
    get_how $P1712, type_obj
    .const 'Sub' $P1713 = "105_1298325424.79949" 
    $P1712."add_method"(type_obj, "add_collision", $P1713)
    get_how $P1714, type_obj
    .const 'Sub' $P1715 = "106_1298325424.79949" 
    $P1714."add_method"(type_obj, "compose", $P1715)
    get_how $P1716, type_obj
    .const 'Sub' $P1717 = "108_1298325424.79949" 
    $P1716."add_method"(type_obj, "methods", $P1717)
    get_how $P1718, type_obj
    .const 'Sub' $P1719 = "110_1298325424.79949" 
    $P1718."add_method"(type_obj, "method_table", $P1719)
    get_how $P1720, type_obj
    .const 'Sub' $P1721 = "111_1298325424.79949" 
    $P1720."add_method"(type_obj, "collisions", $P1721)
    get_how $P1722, type_obj
    .const 'Sub' $P1723 = "112_1298325424.79949" 
    $P1722."add_method"(type_obj, "name", $P1723)
    get_how $P1724, type_obj
    .const 'Sub' $P1725 = "113_1298325424.79949" 
    $P1724."add_method"(type_obj, "attributes", $P1725)
    get_how $P1726, type_obj
    .const 'Sub' $P1727 = "115_1298325424.79949" 
    $P1726."add_method"(type_obj, "roles", $P1727)
    get_how $P1728, type_obj
    .const 'Sub' $P1729 = "116_1298325424.79949" 
    $P1728."add_method"(type_obj, "instance_of", $P1729)
    get_how $P1730, type_obj
    $P1731 = $P1730."compose"(type_obj)
    .return ($P1731)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "new"  :subid("97_1298325424.79949") :outer("96_1298325424.79949")
    .param pmc param_1414
    .param pmc param_1415 :named("name")
    .param pmc param_1416 :named("instance_of")
.annotate 'line', 603
    .lex "self", param_1414
    .lex "$name", param_1415
    .lex "$instance_of", param_1416
.annotate 'line', 604
    new $P1417, "Undef"
    .lex "$obj", $P1417
    find_lex $P1418, "self"
    repr_instance_of $P1419, $P1418
    store_lex "$obj", $P1419
.annotate 'line', 605
    find_lex $P1420, "$obj"
    find_lex $P1421, "$name"
    find_lex $P1422, "$instance_of"
    $P1420."BUILD"($P1421 :named("name"), $P1422 :named("instance_of"))
    find_lex $P1423, "$obj"
.annotate 'line', 603
    .return ($P1423)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "BUILD"  :subid("98_1298325424.79949") :outer("96_1298325424.79949")
    .param pmc param_1425
    .param pmc param_1426 :named("name")
    .param pmc param_1427 :named("instance_of")
.annotate 'line', 609
    .lex "self", param_1425
    .lex "$name", param_1426
    .lex "$instance_of", param_1427
.annotate 'line', 610
    find_lex $P1428, "$name"
    find_lex $P1429, "self"
    get_global $P1430, "$?CLASS"
    setattribute $P1429, $P1430, "$!name", $P1428
.annotate 'line', 611
    find_lex $P1431, "$instance_of"
    find_lex $P1432, "self"
    get_global $P1433, "$?CLASS"
    setattribute $P1432, $P1433, "$!instance_of", $P1431
.annotate 'line', 609
    .return ($P1431)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "new_type"  :subid("99_1298325424.79949") :outer("96_1298325424.79949")
    .param pmc param_1435
    .param pmc param_1440 :named("instance_of")
    .param pmc param_1436 :optional :named("name")
    .param int has_param_1436 :opt_flag
    .param pmc param_1438 :optional :named("repr")
    .param int has_param_1438 :opt_flag
.annotate 'line', 616
    .lex "self", param_1435
    if has_param_1436, optparam_323
    new $P1437, "String"
    assign $P1437, "<anon>"
    set param_1436, $P1437
  optparam_323:
    .lex "$name", param_1436
    if has_param_1438, optparam_324
    new $P1439, "String"
    assign $P1439, "P6opaque"
    set param_1438, $P1439
  optparam_324:
    .lex "$repr", param_1438
    .lex "$instance_of", param_1440
.annotate 'line', 617
    new $P1441, "Undef"
    .lex "$metarole", $P1441
    find_lex $P1442, "self"
    find_lex $P1443, "$name"
    find_lex $P1444, "$instance_of"
    $P1445 = $P1442."new"($P1443 :named("name"), $P1444 :named("instance_of"))
    store_lex "$metarole", $P1445
.annotate 'line', 618
    find_lex $P1446, "$metarole"
    find_lex $P1447, "$repr"
    set $S1448, $P1447
    repr_type_object_for $P1449, $P1446, $S1448
.annotate 'line', 616
    .return ($P1449)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "add_method"  :subid("100_1298325424.79949") :outer("96_1298325424.79949")
    .param pmc param_1451
    .param pmc param_1452
    .param pmc param_1453
    .param pmc param_1454
.annotate 'line', 621
    .lex "self", param_1451
    .lex "$obj", param_1452
    .lex "$name", param_1453
    .lex "$code_obj", param_1454
.annotate 'line', 622
    find_lex $P1456, "$name"
    find_lex $P1457, "self"
    get_global $P1458, "$?CLASS"
    getattribute $P1459, $P1457, $P1458, "%!methods"
    unless_null $P1459, vivify_325
    $P1459 = root_new ['parrot';'Hash']
  vivify_325:
    set $P1460, $P1459[$P1456]
    unless_null $P1460, vivify_326
    new $P1460, "Undef"
  vivify_326:
    unless $P1460, if_1455_end
.annotate 'line', 623
    new $P1461, "String"
    assign $P1461, "This role already has a method named "
    find_lex $P1462, "$name"
    concat $P1463, $P1461, $P1462
    die $P1463
  if_1455_end:
.annotate 'line', 625
    find_lex $P1464, "$code_obj"
    find_lex $P1465, "$name"
    find_lex $P1466, "self"
    get_global $P1467, "$?CLASS"
    getattribute $P1468, $P1466, $P1467, "%!methods"
    unless_null $P1468, vivify_327
    $P1468 = root_new ['parrot';'Hash']
    setattribute $P1466, $P1467, "%!methods", $P1468
  vivify_327:
    set $P1468[$P1465], $P1464
.annotate 'line', 621
    .return ($P1464)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "add_multi_method"  :subid("101_1298325424.79949") :outer("96_1298325424.79949")
    .param pmc param_1470
    .param pmc param_1471
    .param pmc param_1472
    .param pmc param_1473
.annotate 'line', 628
    .lex "self", param_1470
    .lex "$obj", param_1471
    .lex "$name", param_1472
    .lex "$code_obj", param_1473
.annotate 'line', 629
    $P1474 = root_new ['parrot';'Hash']
    .lex "%todo", $P1474
.annotate 'line', 628
    find_lex $P1475, "%todo"
.annotate 'line', 630
    find_lex $P1476, "$name"
    find_lex $P1477, "%todo"
    unless_null $P1477, vivify_328
    $P1477 = root_new ['parrot';'Hash']
    store_lex "%todo", $P1477
  vivify_328:
    set $P1477["name"], $P1476
.annotate 'line', 631
    find_lex $P1478, "$code_obj"
    find_lex $P1479, "%todo"
    unless_null $P1479, vivify_329
    $P1479 = root_new ['parrot';'Hash']
    store_lex "%todo", $P1479
  vivify_329:
    set $P1479["code"], $P1478
.annotate 'line', 632
    find_lex $P1480, "%todo"
    find_lex $P1481, "self"
    get_global $P1482, "$?CLASS"
    getattribute $P1483, $P1481, $P1482, "@!multi_methods_to_incorporate"
    unless_null $P1483, vivify_330
    $P1483 = root_new ['parrot';'ResizablePMCArray']
  vivify_330:
    set $N1484, $P1483
    set $I1485, $N1484
    find_lex $P1486, "self"
    get_global $P1487, "$?CLASS"
    getattribute $P1488, $P1486, $P1487, "@!multi_methods_to_incorporate"
    unless_null $P1488, vivify_331
    $P1488 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P1486, $P1487, "@!multi_methods_to_incorporate", $P1488
  vivify_331:
    set $P1488[$I1485], $P1480
    find_lex $P1489, "$code_obj"
.annotate 'line', 628
    .return ($P1489)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "add_attribute"  :subid("102_1298325424.79949") :outer("96_1298325424.79949")
    .param pmc param_1491
    .param pmc param_1492
    .param pmc param_1493
.annotate 'line', 636
    .lex "self", param_1491
    .lex "$obj", param_1492
    .lex "$meta_attr", param_1493
.annotate 'line', 637
    new $P1494, "Undef"
    .lex "$name", $P1494
    find_lex $P1495, "$meta_attr"
    $P1496 = $P1495."name"()
    store_lex "$name", $P1496
.annotate 'line', 638
    find_lex $P1498, "$name"
    find_lex $P1499, "self"
    get_global $P1500, "$?CLASS"
    getattribute $P1501, $P1499, $P1500, "%!attributes"
    unless_null $P1501, vivify_332
    $P1501 = root_new ['parrot';'Hash']
  vivify_332:
    set $P1502, $P1501[$P1498]
    unless_null $P1502, vivify_333
    new $P1502, "Undef"
  vivify_333:
    unless $P1502, if_1497_end
.annotate 'line', 639
    new $P1503, "String"
    assign $P1503, "This role already has an attribute named "
    find_lex $P1504, "$name"
    concat $P1505, $P1503, $P1504
    die $P1505
  if_1497_end:
.annotate 'line', 641
    find_lex $P1506, "$meta_attr"
    find_lex $P1507, "$name"
    find_lex $P1508, "self"
    get_global $P1509, "$?CLASS"
    getattribute $P1510, $P1508, $P1509, "%!attributes"
    unless_null $P1510, vivify_334
    $P1510 = root_new ['parrot';'Hash']
    setattribute $P1508, $P1509, "%!attributes", $P1510
  vivify_334:
    set $P1510[$P1507], $P1506
.annotate 'line', 636
    .return ($P1506)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "add_parent"  :subid("103_1298325424.79949") :outer("96_1298325424.79949")
    .param pmc param_1512
    .param pmc param_1513
    .param pmc param_1514
.annotate 'line', 644
    .lex "self", param_1512
    .lex "$obj", param_1513
    .lex "$parent", param_1514
.annotate 'line', 645
    die "A role cannot inherit from a class in NQP"
.annotate 'line', 644
    .return ()
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "add_role"  :subid("104_1298325424.79949") :outer("96_1298325424.79949")
    .param pmc param_1516
    .param pmc param_1517
    .param pmc param_1518
.annotate 'line', 648
    .lex "self", param_1516
    .lex "$obj", param_1517
    .lex "$role", param_1518
.annotate 'line', 649
    find_lex $P1519, "$role"
    find_lex $P1520, "self"
    get_global $P1521, "$?CLASS"
    getattribute $P1522, $P1520, $P1521, "@!roles"
    unless_null $P1522, vivify_335
    $P1522 = root_new ['parrot';'ResizablePMCArray']
  vivify_335:
    set $N1523, $P1522
    set $I1524, $N1523
    find_lex $P1525, "self"
    get_global $P1526, "$?CLASS"
    getattribute $P1527, $P1525, $P1526, "@!roles"
    unless_null $P1527, vivify_336
    $P1527 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P1525, $P1526, "@!roles", $P1527
  vivify_336:
    set $P1527[$I1524], $P1519
.annotate 'line', 648
    .return ($P1519)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "add_collision"  :subid("105_1298325424.79949") :outer("96_1298325424.79949")
    .param pmc param_1529
    .param pmc param_1530
    .param pmc param_1531
.annotate 'line', 652
    .lex "self", param_1529
    .lex "$obj", param_1530
    .lex "$colliding_name", param_1531
.annotate 'line', 653
    find_lex $P1532, "$colliding_name"
    find_lex $P1533, "self"
    get_global $P1534, "$?CLASS"
    getattribute $P1535, $P1533, $P1534, "@!collisions"
    unless_null $P1535, vivify_337
    $P1535 = root_new ['parrot';'ResizablePMCArray']
  vivify_337:
    set $N1536, $P1535
    set $I1537, $N1536
    find_lex $P1538, "self"
    get_global $P1539, "$?CLASS"
    getattribute $P1540, $P1538, $P1539, "@!collisions"
    unless_null $P1540, vivify_338
    $P1540 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P1538, $P1539, "@!collisions", $P1540
  vivify_338:
    set $P1540[$I1537], $P1532
.annotate 'line', 652
    .return ($P1532)
.end


.namespace ["NQPConcreteRoleHOW"]
.include "except_types.pasm"
.sub "compose"  :subid("106_1298325424.79949") :outer("96_1298325424.79949")
    .param pmc param_1542
    .param pmc param_1543
.annotate 'line', 657
    .const 'Sub' $P1555 = "107_1298325424.79949" 
    capture_lex $P1555
    .lex "self", param_1542
    .lex "$obj", param_1543
.annotate 'line', 660
    find_lex $P1545, "self"
    get_global $P1546, "$?CLASS"
    getattribute $P1547, $P1545, $P1546, "@!roles"
    unless_null $P1547, vivify_339
    $P1547 = root_new ['parrot';'ResizablePMCArray']
  vivify_339:
    unless $P1547, if_1544_end
.annotate 'line', 661
    find_lex $P1549, "self"
    get_global $P1550, "$?CLASS"
    getattribute $P1551, $P1549, $P1550, "@!roles"
    unless_null $P1551, vivify_340
    $P1551 = root_new ['parrot';'ResizablePMCArray']
  vivify_340:
    defined $I1552, $P1551
    unless $I1552, for_undef_341
    iter $P1548, $P1551
    new $P1579, 'ExceptionHandler'
    set_label $P1579, loop1578_handler
    $P1579."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1579
  loop1578_test:
    unless $P1548, loop1578_done
    shift $P1553, $P1548
  loop1578_redo:
    .const 'Sub' $P1555 = "107_1298325424.79949" 
    capture_lex $P1555
    $P1555($P1553)
  loop1578_next:
    goto loop1578_test
  loop1578_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1580, exception, 'type'
    eq $P1580, .CONTROL_LOOP_NEXT, loop1578_next
    eq $P1580, .CONTROL_LOOP_REDO, loop1578_redo
  loop1578_done:
    pop_eh 
  for_undef_341:
.annotate 'line', 665
    get_hll_global $P1581, "RoleToRoleApplier"
    find_lex $P1582, "$obj"
    find_lex $P1583, "self"
    get_global $P1584, "$?CLASS"
    getattribute $P1585, $P1583, $P1584, "@!roles"
    unless_null $P1585, vivify_346
    $P1585 = root_new ['parrot';'ResizablePMCArray']
  vivify_346:
    $P1581."apply"($P1582, $P1585)
  if_1544_end:
.annotate 'line', 669
    new $P1586, "Integer"
    assign $P1586, 1
    find_lex $P1587, "self"
    get_global $P1588, "$?CLASS"
    setattribute $P1587, $P1588, "$!composed", $P1586
    find_lex $P1589, "$obj"
.annotate 'line', 657
    .return ($P1589)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "_block1554"  :anon :subid("107_1298325424.79949") :outer("106_1298325424.79949")
    .param pmc param_1556
.annotate 'line', 661
    .lex "$_", param_1556
.annotate 'line', 662
    find_lex $P1557, "$_"
    find_lex $P1558, "self"
    get_global $P1559, "$?CLASS"
    getattribute $P1560, $P1558, $P1559, "@!done"
    unless_null $P1560, vivify_342
    $P1560 = root_new ['parrot';'ResizablePMCArray']
  vivify_342:
    set $N1561, $P1560
    set $I1562, $N1561
    find_lex $P1563, "self"
    get_global $P1564, "$?CLASS"
    getattribute $P1565, $P1563, $P1564, "@!done"
    unless_null $P1565, vivify_343
    $P1565 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P1563, $P1564, "@!done", $P1565
  vivify_343:
    set $P1565[$I1562], $P1557
.annotate 'line', 663
    find_lex $P1566, "$_"
    get_how $P1567, $P1566
    find_lex $P1568, "$_"
    $P1569 = $P1567."instance_of"($P1568)
    find_lex $P1570, "self"
    get_global $P1571, "$?CLASS"
    getattribute $P1572, $P1570, $P1571, "@!done"
    unless_null $P1572, vivify_344
    $P1572 = root_new ['parrot';'ResizablePMCArray']
  vivify_344:
    set $N1573, $P1572
    set $I1574, $N1573
    find_lex $P1575, "self"
    get_global $P1576, "$?CLASS"
    getattribute $P1577, $P1575, $P1576, "@!done"
    unless_null $P1577, vivify_345
    $P1577 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P1575, $P1576, "@!done", $P1577
  vivify_345:
    set $P1577[$I1574], $P1569
.annotate 'line', 661
    .return ($P1569)
.end


.namespace ["NQPConcreteRoleHOW"]
.include "except_types.pasm"
.sub "methods"  :subid("108_1298325424.79949") :outer("96_1298325424.79949")
    .param pmc param_1591
    .param pmc param_1592
.annotate 'line', 678
    .const 'Sub' $P1602 = "109_1298325424.79949" 
    capture_lex $P1602
    .lex "self", param_1591
    .lex "$obj", param_1592
.annotate 'line', 679
    $P1593 = root_new ['parrot';'ResizablePMCArray']
    .lex "@meths", $P1593
.annotate 'line', 678
    find_lex $P1594, "@meths"
.annotate 'line', 680
    find_lex $P1596, "self"
    get_global $P1597, "$?CLASS"
    getattribute $P1598, $P1596, $P1597, "%!methods"
    unless_null $P1598, vivify_347
    $P1598 = root_new ['parrot';'Hash']
  vivify_347:
    defined $I1599, $P1598
    unless $I1599, for_undef_348
    iter $P1595, $P1598
    new $P1609, 'ExceptionHandler'
    set_label $P1609, loop1608_handler
    $P1609."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1609
  loop1608_test:
    unless $P1595, loop1608_done
    shift $P1600, $P1595
  loop1608_redo:
    .const 'Sub' $P1602 = "109_1298325424.79949" 
    capture_lex $P1602
    $P1602($P1600)
  loop1608_next:
    goto loop1608_test
  loop1608_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1610, exception, 'type'
    eq $P1610, .CONTROL_LOOP_NEXT, loop1608_next
    eq $P1610, .CONTROL_LOOP_REDO, loop1608_redo
  loop1608_done:
    pop_eh 
  for_undef_348:
    find_lex $P1611, "@meths"
.annotate 'line', 678
    .return ($P1611)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "_block1601"  :anon :subid("109_1298325424.79949") :outer("108_1298325424.79949")
    .param pmc param_1603
.annotate 'line', 680
    .lex "$_", param_1603
.annotate 'line', 681
    find_lex $P1604, "@meths"
    find_lex $P1605, "$_"
    $P1606 = $P1605."value"()
    $P1607 = $P1604."push"($P1606)
.annotate 'line', 680
    .return ($P1607)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "method_table"  :subid("110_1298325424.79949") :outer("96_1298325424.79949")
    .param pmc param_1613
    .param pmc param_1614
.annotate 'line', 686
    .lex "self", param_1613
    .lex "$obj", param_1614
    find_lex $P1615, "self"
    get_global $P1616, "$?CLASS"
    getattribute $P1617, $P1615, $P1616, "%!methods"
    unless_null $P1617, vivify_349
    $P1617 = root_new ['parrot';'Hash']
  vivify_349:
    .return ($P1617)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "collisions"  :subid("111_1298325424.79949") :outer("96_1298325424.79949")
    .param pmc param_1619
    .param pmc param_1620
.annotate 'line', 690
    .lex "self", param_1619
    .lex "$obj", param_1620
    find_lex $P1621, "self"
    get_global $P1622, "$?CLASS"
    getattribute $P1623, $P1621, $P1622, "@!collisions"
    unless_null $P1623, vivify_350
    $P1623 = root_new ['parrot';'ResizablePMCArray']
  vivify_350:
    .return ($P1623)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "name"  :subid("112_1298325424.79949") :outer("96_1298325424.79949")
    .param pmc param_1625
    .param pmc param_1626
.annotate 'line', 694
    .lex "self", param_1625
    .lex "$obj", param_1626
    find_lex $P1627, "self"
    get_global $P1628, "$?CLASS"
    getattribute $P1629, $P1627, $P1628, "$!name"
    unless_null $P1629, vivify_351
    new $P1629, "Undef"
  vivify_351:
    .return ($P1629)
.end


.namespace ["NQPConcreteRoleHOW"]
.include "except_types.pasm"
.sub "attributes"  :subid("113_1298325424.79949") :outer("96_1298325424.79949")
    .param pmc param_1631
    .param pmc param_1632
.annotate 'line', 698
    .const 'Sub' $P1642 = "114_1298325424.79949" 
    capture_lex $P1642
    .lex "self", param_1631
    .lex "$obj", param_1632
.annotate 'line', 699
    $P1633 = root_new ['parrot';'ResizablePMCArray']
    .lex "@attrs", $P1633
.annotate 'line', 698
    find_lex $P1634, "@attrs"
.annotate 'line', 700
    find_lex $P1636, "self"
    get_global $P1637, "$?CLASS"
    getattribute $P1638, $P1636, $P1637, "%!attributes"
    unless_null $P1638, vivify_352
    $P1638 = root_new ['parrot';'Hash']
  vivify_352:
    defined $I1639, $P1638
    unless $I1639, for_undef_353
    iter $P1635, $P1638
    new $P1649, 'ExceptionHandler'
    set_label $P1649, loop1648_handler
    $P1649."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1649
  loop1648_test:
    unless $P1635, loop1648_done
    shift $P1640, $P1635
  loop1648_redo:
    .const 'Sub' $P1642 = "114_1298325424.79949" 
    capture_lex $P1642
    $P1642($P1640)
  loop1648_next:
    goto loop1648_test
  loop1648_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1650, exception, 'type'
    eq $P1650, .CONTROL_LOOP_NEXT, loop1648_next
    eq $P1650, .CONTROL_LOOP_REDO, loop1648_redo
  loop1648_done:
    pop_eh 
  for_undef_353:
    find_lex $P1651, "@attrs"
.annotate 'line', 698
    .return ($P1651)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "_block1641"  :anon :subid("114_1298325424.79949") :outer("113_1298325424.79949")
    .param pmc param_1643
.annotate 'line', 700
    .lex "$_", param_1643
.annotate 'line', 701
    find_lex $P1644, "@attrs"
    find_lex $P1645, "$_"
    $P1646 = $P1645."value"()
    $P1647 = $P1644."push"($P1646)
.annotate 'line', 700
    .return ($P1647)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "roles"  :subid("115_1298325424.79949") :outer("96_1298325424.79949")
    .param pmc param_1653
    .param pmc param_1654
.annotate 'line', 706
    .lex "self", param_1653
    .lex "$obj", param_1654
    find_lex $P1655, "self"
    get_global $P1656, "$?CLASS"
    getattribute $P1657, $P1655, $P1656, "@!roles"
    unless_null $P1657, vivify_354
    $P1657 = root_new ['parrot';'ResizablePMCArray']
  vivify_354:
    .return ($P1657)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "instance_of"  :subid("116_1298325424.79949") :outer("96_1298325424.79949")
    .param pmc param_1659
    .param pmc param_1660
.annotate 'line', 710
    .lex "self", param_1659
    .lex "$obj", param_1660
    find_lex $P1661, "self"
    get_global $P1662, "$?CLASS"
    getattribute $P1663, $P1661, $P1662, "$!instance_of"
    unless_null $P1663, vivify_355
    new $P1663, "Undef"
  vivify_355:
    .return ($P1663)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "_block1732"  :subid("118_1298325424.79949") :outer("10_1298325424.79949")
.annotate 'line', 720
    .const 'Sub' $P2030 = "141_1298325424.79949" 
    capture_lex $P2030
    .const 'Sub' $P2022 = "140_1298325424.79949" 
    capture_lex $P2022
    .const 'Sub' $P2000 = "138_1298325424.79949" 
    capture_lex $P2000
    .const 'Sub' $P1994 = "137_1298325424.79949" 
    capture_lex $P1994
    .const 'Sub' $P1988 = "136_1298325424.79949" 
    capture_lex $P1988
    .const 'Sub' $P1966 = "134_1298325424.79949" 
    capture_lex $P1966
    .const 'Sub' $P1860 = "129_1298325424.79949" 
    capture_lex $P1860
    .const 'Sub' $P1857 = "128_1298325424.79949" 
    capture_lex $P1857
    .const 'Sub' $P1850 = "127_1298325424.79949" 
    capture_lex $P1850
    .const 'Sub' $P1837 = "126_1298325424.79949" 
    capture_lex $P1837
    .const 'Sub' $P1833 = "125_1298325424.79949" 
    capture_lex $P1833
    .const 'Sub' $P1812 = "124_1298325424.79949" 
    capture_lex $P1812
    .const 'Sub' $P1791 = "123_1298325424.79949" 
    capture_lex $P1791
    .const 'Sub' $P1772 = "122_1298325424.79949" 
    capture_lex $P1772
    .const 'Sub' $P1756 = "121_1298325424.79949" 
    capture_lex $P1756
    .const 'Sub' $P1746 = "120_1298325424.79949" 
    capture_lex $P1746
    .const 'Sub' $P1735 = "119_1298325424.79949" 
    capture_lex $P1735
    get_global $P1734, "$?CLASS"
.annotate 'line', 880
    .const 'Sub' $P2022 = "140_1298325424.79949" 
    newclosure $P2028, $P2022
.annotate 'line', 720
    .return ($P2028)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "" :load :init :subid("post356") :outer("118_1298325424.79949")
.annotate 'line', 720
    get_hll_global $P1733, ["NQPParametricRoleHOW"], "_block1732" 
    .local pmc block
    set block, $P1733
    .const 'Sub' $P2030 = "141_1298325424.79949" 
    capture_lex $P2030
    $P2030()
.end


.namespace ["NQPParametricRoleHOW"]
.sub "_block2029"  :anon :subid("141_1298325424.79949") :outer("118_1298325424.79949")
.annotate 'line', 720
    get_hll_global $P2031, "KnowHOW"
    $P2032 = $P2031."new_type"("NQPParametricRoleHOW" :named("name"))
    .local pmc type_obj
    set type_obj, $P2032
    set_hll_global "NQPParametricRoleHOW", type_obj
    set_global "$?CLASS", type_obj
    get_how $P2033, type_obj
    get_hll_global $P2034, "KnowHOWAttribute"
    $P2035 = $P2034."new"("$!name" :named("name"))
    $P2033."add_attribute"(type_obj, $P2035)
    get_how $P2036, type_obj
    get_hll_global $P2037, "KnowHOWAttribute"
    $P2038 = $P2037."new"("%!attributes" :named("name"))
    $P2036."add_attribute"(type_obj, $P2038)
    get_how $P2039, type_obj
    get_hll_global $P2040, "KnowHOWAttribute"
    $P2041 = $P2040."new"("%!methods" :named("name"))
    $P2039."add_attribute"(type_obj, $P2041)
    get_how $P2042, type_obj
    get_hll_global $P2043, "KnowHOWAttribute"
    $P2044 = $P2043."new"("@!multi_methods_to_incorporate" :named("name"))
    $P2042."add_attribute"(type_obj, $P2044)
    get_how $P2045, type_obj
    get_hll_global $P2046, "KnowHOWAttribute"
    $P2047 = $P2046."new"("@!roles" :named("name"))
    $P2045."add_attribute"(type_obj, $P2047)
    get_how $P2048, type_obj
    get_hll_global $P2049, "KnowHOWAttribute"
    $P2050 = $P2049."new"("$!composed" :named("name"))
    $P2048."add_attribute"(type_obj, $P2050)
    get_how $P2051, type_obj
    get_hll_global $P2052, "KnowHOWAttribute"
    $P2053 = $P2052."new"("$!body_block" :named("name"))
    $P2051."add_attribute"(type_obj, $P2053)
    get_how $P2054, type_obj
    .const 'Sub' $P2055 = "119_1298325424.79949" 
    $P2054."add_method"(type_obj, "new", $P2055)
    get_how $P2056, type_obj
    .const 'Sub' $P2057 = "120_1298325424.79949" 
    $P2056."add_method"(type_obj, "BUILD", $P2057)
    get_how $P2058, type_obj
    .const 'Sub' $P2059 = "121_1298325424.79949" 
    $P2058."add_method"(type_obj, "new_type", $P2059)
    get_how $P2060, type_obj
    .const 'Sub' $P2061 = "122_1298325424.79949" 
    $P2060."add_method"(type_obj, "add_method", $P2061)
    get_how $P2062, type_obj
    .const 'Sub' $P2063 = "123_1298325424.79949" 
    $P2062."add_method"(type_obj, "add_multi_method", $P2063)
    get_how $P2064, type_obj
    .const 'Sub' $P2065 = "124_1298325424.79949" 
    $P2064."add_method"(type_obj, "add_attribute", $P2065)
    get_how $P2066, type_obj
    .const 'Sub' $P2067 = "125_1298325424.79949" 
    $P2066."add_method"(type_obj, "add_parent", $P2067)
    get_how $P2068, type_obj
    .const 'Sub' $P2069 = "126_1298325424.79949" 
    $P2068."add_method"(type_obj, "add_role", $P2069)
    get_how $P2070, type_obj
    .const 'Sub' $P2071 = "127_1298325424.79949" 
    $P2070."add_method"(type_obj, "compose", $P2071)
    get_how $P2072, type_obj
    .const 'Sub' $P2073 = "128_1298325424.79949" 
    $P2072."add_method"(type_obj, "parametric", $P2073)
    get_how $P2074, type_obj
    .const 'Sub' $P2075 = "129_1298325424.79949" 
    $P2074."add_method"(type_obj, "instantiate", $P2075)
    get_how $P2076, type_obj
    .const 'Sub' $P2077 = "134_1298325424.79949" 
    $P2076."add_method"(type_obj, "methods", $P2077)
    get_how $P2078, type_obj
    .const 'Sub' $P2079 = "136_1298325424.79949" 
    $P2078."add_method"(type_obj, "method_table", $P2079)
    get_how $P2080, type_obj
    .const 'Sub' $P2081 = "137_1298325424.79949" 
    $P2080."add_method"(type_obj, "name", $P2081)
    get_how $P2082, type_obj
    .const 'Sub' $P2083 = "138_1298325424.79949" 
    $P2082."add_method"(type_obj, "attributes", $P2083)
    get_how $P2084, type_obj
    .const 'Sub' $P2085 = "140_1298325424.79949" 
    $P2084."add_method"(type_obj, "roles", $P2085)
    get_how $P2086, type_obj
    $P2087 = $P2086."compose"(type_obj)
    .return ($P2087)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "new"  :subid("119_1298325424.79949") :outer("118_1298325424.79949")
    .param pmc param_1736
    .param pmc param_1737 :named("name")
    .param pmc param_1738 :named("body_block")
.annotate 'line', 750
    .lex "self", param_1736
    .lex "$name", param_1737
    .lex "$body_block", param_1738
.annotate 'line', 751
    new $P1739, "Undef"
    .lex "$obj", $P1739
    find_lex $P1740, "self"
    repr_instance_of $P1741, $P1740
    store_lex "$obj", $P1741
.annotate 'line', 752
    find_lex $P1742, "$obj"
    find_lex $P1743, "$name"
    find_lex $P1744, "$body_block"
    $P1742."BUILD"($P1743 :named("name"), $P1744 :named("body_block"))
    find_lex $P1745, "$obj"
.annotate 'line', 750
    .return ($P1745)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "BUILD"  :subid("120_1298325424.79949") :outer("118_1298325424.79949")
    .param pmc param_1747
    .param pmc param_1748 :named("name")
    .param pmc param_1749 :named("body_block")
.annotate 'line', 756
    .lex "self", param_1747
    .lex "$name", param_1748
    .lex "$body_block", param_1749
.annotate 'line', 757
    find_lex $P1750, "$name"
    find_lex $P1751, "self"
    get_global $P1752, "$?CLASS"
    setattribute $P1751, $P1752, "$!name", $P1750
.annotate 'line', 758
    find_lex $P1753, "$body_block"
    find_lex $P1754, "self"
    get_global $P1755, "$?CLASS"
    setattribute $P1754, $P1755, "$!body_block", $P1753
.annotate 'line', 756
    .return ($P1753)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "new_type"  :subid("121_1298325424.79949") :outer("118_1298325424.79949")
    .param pmc param_1757
    .param pmc param_1758 :named("body_block")
    .param pmc param_1759 :optional :named("name")
    .param int has_param_1759 :opt_flag
    .param pmc param_1761 :optional :named("repr")
    .param int has_param_1761 :opt_flag
.annotate 'line', 763
    .lex "self", param_1757
    .lex "$body_block", param_1758
    if has_param_1759, optparam_357
    new $P1760, "String"
    assign $P1760, "<anon>"
    set param_1759, $P1760
  optparam_357:
    .lex "$name", param_1759
    if has_param_1761, optparam_358
    new $P1762, "String"
    assign $P1762, "P6opaque"
    set param_1761, $P1762
  optparam_358:
    .lex "$repr", param_1761
.annotate 'line', 764
    new $P1763, "Undef"
    .lex "$metarole", $P1763
    find_lex $P1764, "self"
    find_lex $P1765, "$name"
    find_lex $P1766, "$body_block"
    $P1767 = $P1764."new"($P1765 :named("name"), $P1766 :named("body_block"))
    store_lex "$metarole", $P1767
.annotate 'line', 765
    find_lex $P1768, "$metarole"
    find_lex $P1769, "$repr"
    set $S1770, $P1769
    repr_type_object_for $P1771, $P1768, $S1770
.annotate 'line', 763
    .return ($P1771)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "add_method"  :subid("122_1298325424.79949") :outer("118_1298325424.79949")
    .param pmc param_1773
    .param pmc param_1774
    .param pmc param_1775
    .param pmc param_1776
.annotate 'line', 768
    .lex "self", param_1773
    .lex "$obj", param_1774
    .lex "$name", param_1775
    .lex "$code_obj", param_1776
.annotate 'line', 769
    find_lex $P1778, "$name"
    find_lex $P1779, "self"
    get_global $P1780, "$?CLASS"
    getattribute $P1781, $P1779, $P1780, "%!methods"
    unless_null $P1781, vivify_359
    $P1781 = root_new ['parrot';'Hash']
  vivify_359:
    set $P1782, $P1781[$P1778]
    unless_null $P1782, vivify_360
    new $P1782, "Undef"
  vivify_360:
    unless $P1782, if_1777_end
.annotate 'line', 770
    new $P1783, "String"
    assign $P1783, "This role already has a method named "
    find_lex $P1784, "$name"
    concat $P1785, $P1783, $P1784
    die $P1785
  if_1777_end:
.annotate 'line', 772
    find_lex $P1786, "$code_obj"
    find_lex $P1787, "$name"
    find_lex $P1788, "self"
    get_global $P1789, "$?CLASS"
    getattribute $P1790, $P1788, $P1789, "%!methods"
    unless_null $P1790, vivify_361
    $P1790 = root_new ['parrot';'Hash']
    setattribute $P1788, $P1789, "%!methods", $P1790
  vivify_361:
    set $P1790[$P1787], $P1786
.annotate 'line', 768
    .return ($P1786)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "add_multi_method"  :subid("123_1298325424.79949") :outer("118_1298325424.79949")
    .param pmc param_1792
    .param pmc param_1793
    .param pmc param_1794
    .param pmc param_1795
.annotate 'line', 775
    .lex "self", param_1792
    .lex "$obj", param_1793
    .lex "$name", param_1794
    .lex "$code_obj", param_1795
.annotate 'line', 776
    $P1796 = root_new ['parrot';'Hash']
    .lex "%todo", $P1796
.annotate 'line', 775
    find_lex $P1797, "%todo"
.annotate 'line', 777
    find_lex $P1798, "$name"
    find_lex $P1799, "%todo"
    unless_null $P1799, vivify_362
    $P1799 = root_new ['parrot';'Hash']
    store_lex "%todo", $P1799
  vivify_362:
    set $P1799["name"], $P1798
.annotate 'line', 778
    find_lex $P1800, "$code_obj"
    find_lex $P1801, "%todo"
    unless_null $P1801, vivify_363
    $P1801 = root_new ['parrot';'Hash']
    store_lex "%todo", $P1801
  vivify_363:
    set $P1801["code"], $P1800
.annotate 'line', 779
    find_lex $P1802, "%todo"
    find_lex $P1803, "self"
    get_global $P1804, "$?CLASS"
    getattribute $P1805, $P1803, $P1804, "@!multi_methods_to_incorporate"
    unless_null $P1805, vivify_364
    $P1805 = root_new ['parrot';'ResizablePMCArray']
  vivify_364:
    set $N1806, $P1805
    set $I1807, $N1806
    find_lex $P1808, "self"
    get_global $P1809, "$?CLASS"
    getattribute $P1810, $P1808, $P1809, "@!multi_methods_to_incorporate"
    unless_null $P1810, vivify_365
    $P1810 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P1808, $P1809, "@!multi_methods_to_incorporate", $P1810
  vivify_365:
    set $P1810[$I1807], $P1802
    find_lex $P1811, "$code_obj"
.annotate 'line', 775
    .return ($P1811)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "add_attribute"  :subid("124_1298325424.79949") :outer("118_1298325424.79949")
    .param pmc param_1813
    .param pmc param_1814
    .param pmc param_1815
.annotate 'line', 783
    .lex "self", param_1813
    .lex "$obj", param_1814
    .lex "$meta_attr", param_1815
.annotate 'line', 784
    new $P1816, "Undef"
    .lex "$name", $P1816
    find_lex $P1817, "$meta_attr"
    $P1818 = $P1817."name"()
    store_lex "$name", $P1818
.annotate 'line', 785
    find_lex $P1820, "$name"
    find_lex $P1821, "self"
    get_global $P1822, "$?CLASS"
    getattribute $P1823, $P1821, $P1822, "%!attributes"
    unless_null $P1823, vivify_366
    $P1823 = root_new ['parrot';'Hash']
  vivify_366:
    set $P1824, $P1823[$P1820]
    unless_null $P1824, vivify_367
    new $P1824, "Undef"
  vivify_367:
    unless $P1824, if_1819_end
.annotate 'line', 786
    new $P1825, "String"
    assign $P1825, "This role already has an attribute named "
    find_lex $P1826, "$name"
    concat $P1827, $P1825, $P1826
    die $P1827
  if_1819_end:
.annotate 'line', 788
    find_lex $P1828, "$meta_attr"
    find_lex $P1829, "$name"
    find_lex $P1830, "self"
    get_global $P1831, "$?CLASS"
    getattribute $P1832, $P1830, $P1831, "%!attributes"
    unless_null $P1832, vivify_368
    $P1832 = root_new ['parrot';'Hash']
    setattribute $P1830, $P1831, "%!attributes", $P1832
  vivify_368:
    set $P1832[$P1829], $P1828
.annotate 'line', 783
    .return ($P1828)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "add_parent"  :subid("125_1298325424.79949") :outer("118_1298325424.79949")
    .param pmc param_1834
    .param pmc param_1835
    .param pmc param_1836
.annotate 'line', 791
    .lex "self", param_1834
    .lex "$obj", param_1835
    .lex "$parent", param_1836
.annotate 'line', 792
    die "A role cannot inherit from a class"
.annotate 'line', 791
    .return ()
.end


.namespace ["NQPParametricRoleHOW"]
.sub "add_role"  :subid("126_1298325424.79949") :outer("118_1298325424.79949")
    .param pmc param_1838
    .param pmc param_1839
    .param pmc param_1840
.annotate 'line', 795
    .lex "self", param_1838
    .lex "$obj", param_1839
    .lex "$role", param_1840
.annotate 'line', 796
    find_lex $P1841, "$role"
    find_lex $P1842, "self"
    get_global $P1843, "$?CLASS"
    getattribute $P1844, $P1842, $P1843, "@!roles"
    unless_null $P1844, vivify_369
    $P1844 = root_new ['parrot';'ResizablePMCArray']
  vivify_369:
    set $N1845, $P1844
    set $I1846, $N1845
    find_lex $P1847, "self"
    get_global $P1848, "$?CLASS"
    getattribute $P1849, $P1847, $P1848, "@!roles"
    unless_null $P1849, vivify_370
    $P1849 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P1847, $P1848, "@!roles", $P1849
  vivify_370:
    set $P1849[$I1846], $P1841
.annotate 'line', 795
    .return ($P1841)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "compose"  :subid("127_1298325424.79949") :outer("118_1298325424.79949")
    .param pmc param_1851
    .param pmc param_1852
.annotate 'line', 800
    .lex "self", param_1851
    .lex "$obj", param_1852
.annotate 'line', 801
    new $P1853, "Integer"
    assign $P1853, 1
    find_lex $P1854, "self"
    get_global $P1855, "$?CLASS"
    setattribute $P1854, $P1855, "$!composed", $P1853
    find_lex $P1856, "$obj"
.annotate 'line', 800
    .return ($P1856)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "parametric"  :subid("128_1298325424.79949") :outer("118_1298325424.79949")
    .param pmc param_1858
    .param pmc param_1859
.annotate 'line', 811
    .lex "self", param_1858
    .lex "$obj", param_1859
    .return (1)
.end


.namespace ["NQPParametricRoleHOW"]
.include "except_types.pasm"
.sub "instantiate"  :subid("129_1298325424.79949") :outer("118_1298325424.79949")
    .param pmc param_1863
    .param pmc param_1864
    .param pmc param_1865
.annotate 'line', 817
    .const 'Sub' $P1944 = "133_1298325424.79949" 
    capture_lex $P1944
    .const 'Sub' $P1923 = "132_1298325424.79949" 
    capture_lex $P1923
    .const 'Sub' $P1902 = "131_1298325424.79949" 
    capture_lex $P1902
    .const 'Sub' $P1884 = "130_1298325424.79949" 
    capture_lex $P1884
    new $P1862, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P1862, control_1861
    push_eh $P1862
    .lex "self", param_1863
    .lex "$obj", param_1864
    .lex "$class_arg", param_1865
.annotate 'line', 823
    new $P1866, "Undef"
    .lex "$irole", $P1866
.annotate 'line', 820
    find_lex $P1867, "self"
    get_global $P1868, "$?CLASS"
    getattribute $P1869, $P1867, $P1868, "$!body_block"
    unless_null $P1869, vivify_371
    new $P1869, "Undef"
  vivify_371:
    find_lex $P1870, "$class_arg"
    $P1869($P1870)
.annotate 'line', 823
    get_hll_global $P1871, "NQPConcreteRoleHOW"
    find_lex $P1872, "self"
    get_global $P1873, "$?CLASS"
    getattribute $P1874, $P1872, $P1873, "$!name"
    unless_null $P1874, vivify_372
    new $P1874, "Undef"
  vivify_372:
    find_lex $P1875, "$obj"
    $P1876 = $P1871."new_type"($P1874 :named("name"), $P1875 :named("instance_of"))
    store_lex "$irole", $P1876
.annotate 'line', 827
    find_lex $P1878, "self"
    get_global $P1879, "$?CLASS"
    getattribute $P1880, $P1878, $P1879, "%!attributes"
    unless_null $P1880, vivify_373
    $P1880 = root_new ['parrot';'Hash']
  vivify_373:
    defined $I1881, $P1880
    unless $I1881, for_undef_374
    iter $P1877, $P1880
    new $P1893, 'ExceptionHandler'
    set_label $P1893, loop1892_handler
    $P1893."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1893
  loop1892_test:
    unless $P1877, loop1892_done
    shift $P1882, $P1877
  loop1892_redo:
    .const 'Sub' $P1884 = "130_1298325424.79949" 
    capture_lex $P1884
    $P1884($P1882)
  loop1892_next:
    goto loop1892_test
  loop1892_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1894, exception, 'type'
    eq $P1894, .CONTROL_LOOP_NEXT, loop1892_next
    eq $P1894, .CONTROL_LOOP_REDO, loop1892_redo
  loop1892_done:
    pop_eh 
  for_undef_374:
.annotate 'line', 833
    find_lex $P1896, "self"
    get_global $P1897, "$?CLASS"
    getattribute $P1898, $P1896, $P1897, "%!methods"
    unless_null $P1898, vivify_375
    $P1898 = root_new ['parrot';'Hash']
  vivify_375:
    defined $I1899, $P1898
    unless $I1899, for_undef_376
    iter $P1895, $P1898
    new $P1914, 'ExceptionHandler'
    set_label $P1914, loop1913_handler
    $P1914."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1914
  loop1913_test:
    unless $P1895, loop1913_done
    shift $P1900, $P1895
  loop1913_redo:
    .const 'Sub' $P1902 = "131_1298325424.79949" 
    capture_lex $P1902
    $P1902($P1900)
  loop1913_next:
    goto loop1913_test
  loop1913_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1915, exception, 'type'
    eq $P1915, .CONTROL_LOOP_NEXT, loop1913_next
    eq $P1915, .CONTROL_LOOP_REDO, loop1913_redo
  loop1913_done:
    pop_eh 
  for_undef_376:
.annotate 'line', 836
    find_lex $P1917, "self"
    get_global $P1918, "$?CLASS"
    getattribute $P1919, $P1917, $P1918, "@!multi_methods_to_incorporate"
    unless_null $P1919, vivify_377
    $P1919 = root_new ['parrot';'ResizablePMCArray']
  vivify_377:
    defined $I1920, $P1919
    unless $I1920, for_undef_378
    iter $P1916, $P1919
    new $P1935, 'ExceptionHandler'
    set_label $P1935, loop1934_handler
    $P1935."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1935
  loop1934_test:
    unless $P1916, loop1934_done
    shift $P1921, $P1916
  loop1934_redo:
    .const 'Sub' $P1923 = "132_1298325424.79949" 
    capture_lex $P1923
    $P1923($P1921)
  loop1934_next:
    goto loop1934_test
  loop1934_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1936, exception, 'type'
    eq $P1936, .CONTROL_LOOP_NEXT, loop1934_next
    eq $P1936, .CONTROL_LOOP_REDO, loop1934_redo
  loop1934_done:
    pop_eh 
  for_undef_378:
.annotate 'line', 841
    find_lex $P1938, "self"
    get_global $P1939, "$?CLASS"
    getattribute $P1940, $P1938, $P1939, "@!roles"
    unless_null $P1940, vivify_383
    $P1940 = root_new ['parrot';'ResizablePMCArray']
  vivify_383:
    defined $I1941, $P1940
    unless $I1941, for_undef_384
    iter $P1937, $P1940
    new $P1958, 'ExceptionHandler'
    set_label $P1958, loop1957_handler
    $P1958."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1958
  loop1957_test:
    unless $P1937, loop1957_done
    shift $P1942, $P1937
  loop1957_redo:
    .const 'Sub' $P1944 = "133_1298325424.79949" 
    capture_lex $P1944
    $P1944($P1942)
  loop1957_next:
    goto loop1957_test
  loop1957_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1959, exception, 'type'
    eq $P1959, .CONTROL_LOOP_NEXT, loop1957_next
    eq $P1959, .CONTROL_LOOP_REDO, loop1957_redo
  loop1957_done:
    pop_eh 
  for_undef_384:
.annotate 'line', 847
    find_lex $P1960, "$irole"
    get_how $P1961, $P1960
    find_lex $P1962, "$irole"
    $P1961."compose"($P1962)
.annotate 'line', 848
    new $P1963, "Exception"
    set $P1963['type'], .CONTROL_RETURN
    find_lex $P1964, "$irole"
    setattribute $P1963, 'payload', $P1964
    throw $P1963
.annotate 'line', 817
    .return ()
  control_1861:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1965, exception, "payload"
    .return ($P1965)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "_block1883"  :anon :subid("130_1298325424.79949") :outer("129_1298325424.79949")
    .param pmc param_1885
.annotate 'line', 827
    .lex "$_", param_1885
.annotate 'line', 828
    find_lex $P1886, "$irole"
    get_how $P1887, $P1886
    find_lex $P1888, "$irole"
    find_lex $P1889, "$_"
    $P1890 = $P1889."value"()
    $P1891 = $P1887."add_attribute"($P1888, $P1890)
.annotate 'line', 827
    .return ($P1891)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "_block1901"  :anon :subid("131_1298325424.79949") :outer("129_1298325424.79949")
    .param pmc param_1903
.annotate 'line', 833
    .lex "$_", param_1903
.annotate 'line', 834
    find_lex $P1904, "$irole"
    get_how $P1905, $P1904
    find_lex $P1906, "$irole"
    find_lex $P1907, "$_"
    $P1908 = $P1907."key"()
    find_lex $P1909, "$_"
    $P1910 = $P1909."value"()
    clone $P1911, $P1910
    $P1912 = $P1905."add_method"($P1906, $P1908, $P1911)
.annotate 'line', 833
    .return ($P1912)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "_block1922"  :anon :subid("132_1298325424.79949") :outer("129_1298325424.79949")
    .param pmc param_1924
.annotate 'line', 836
    .lex "$_", param_1924
.annotate 'line', 837
    find_lex $P1925, "$irole"
    get_how $P1926, $P1925
    find_lex $P1927, "$irole"
    find_lex $P1928, "$_"
    unless_null $P1928, vivify_379
    $P1928 = root_new ['parrot';'Hash']
  vivify_379:
    set $P1929, $P1928["name"]
    unless_null $P1929, vivify_380
    new $P1929, "Undef"
  vivify_380:
    find_lex $P1930, "$_"
    unless_null $P1930, vivify_381
    $P1930 = root_new ['parrot';'Hash']
  vivify_381:
    set $P1931, $P1930["code"]
    unless_null $P1931, vivify_382
    new $P1931, "Undef"
  vivify_382:
    clone $P1932, $P1931
    $P1933 = $P1926."add_multi_method"($P1927, $P1929, $P1932)
.annotate 'line', 836
    .return ($P1933)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "_block1943"  :anon :subid("133_1298325424.79949") :outer("129_1298325424.79949")
    .param pmc param_1946
.annotate 'line', 842
    new $P1945, "Undef"
    .lex "$instantiated", $P1945
    .lex "$_", param_1946
    find_lex $P1947, "$irole"
    get_how $P1948, $P1947
    find_lex $P1949, "$irole"
    find_lex $P1950, "$class_arg"
    $P1951 = $P1948."instantiate"($P1949, $P1950)
    store_lex "$instantiated", $P1951
.annotate 'line', 843
    find_lex $P1952, "$irole"
    get_how $P1953, $P1952
    find_lex $P1954, "$irole"
    find_lex $P1955, "$instantiated"
    $P1956 = $P1953."add_role"($P1954, $P1955)
.annotate 'line', 841
    .return ($P1956)
.end


.namespace ["NQPParametricRoleHOW"]
.include "except_types.pasm"
.sub "methods"  :subid("134_1298325424.79949") :outer("118_1298325424.79949")
    .param pmc param_1967
    .param pmc param_1968
.annotate 'line', 856
    .const 'Sub' $P1978 = "135_1298325424.79949" 
    capture_lex $P1978
    .lex "self", param_1967
    .lex "$obj", param_1968
.annotate 'line', 857
    $P1969 = root_new ['parrot';'ResizablePMCArray']
    .lex "@meths", $P1969
.annotate 'line', 856
    find_lex $P1970, "@meths"
.annotate 'line', 858
    find_lex $P1972, "self"
    get_global $P1973, "$?CLASS"
    getattribute $P1974, $P1972, $P1973, "%!methods"
    unless_null $P1974, vivify_385
    $P1974 = root_new ['parrot';'Hash']
  vivify_385:
    defined $I1975, $P1974
    unless $I1975, for_undef_386
    iter $P1971, $P1974
    new $P1985, 'ExceptionHandler'
    set_label $P1985, loop1984_handler
    $P1985."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1985
  loop1984_test:
    unless $P1971, loop1984_done
    shift $P1976, $P1971
  loop1984_redo:
    .const 'Sub' $P1978 = "135_1298325424.79949" 
    capture_lex $P1978
    $P1978($P1976)
  loop1984_next:
    goto loop1984_test
  loop1984_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1986, exception, 'type'
    eq $P1986, .CONTROL_LOOP_NEXT, loop1984_next
    eq $P1986, .CONTROL_LOOP_REDO, loop1984_redo
  loop1984_done:
    pop_eh 
  for_undef_386:
    find_lex $P1987, "@meths"
.annotate 'line', 856
    .return ($P1987)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "_block1977"  :anon :subid("135_1298325424.79949") :outer("134_1298325424.79949")
    .param pmc param_1979
.annotate 'line', 858
    .lex "$_", param_1979
.annotate 'line', 859
    find_lex $P1980, "@meths"
    find_lex $P1981, "$_"
    $P1982 = $P1981."value"()
    $P1983 = $P1980."push"($P1982)
.annotate 'line', 858
    .return ($P1983)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "method_table"  :subid("136_1298325424.79949") :outer("118_1298325424.79949")
    .param pmc param_1989
    .param pmc param_1990
.annotate 'line', 864
    .lex "self", param_1989
    .lex "$obj", param_1990
    find_lex $P1991, "self"
    get_global $P1992, "$?CLASS"
    getattribute $P1993, $P1991, $P1992, "%!methods"
    unless_null $P1993, vivify_387
    $P1993 = root_new ['parrot';'Hash']
  vivify_387:
    .return ($P1993)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "name"  :subid("137_1298325424.79949") :outer("118_1298325424.79949")
    .param pmc param_1995
    .param pmc param_1996
.annotate 'line', 868
    .lex "self", param_1995
    .lex "$obj", param_1996
    find_lex $P1997, "self"
    get_global $P1998, "$?CLASS"
    getattribute $P1999, $P1997, $P1998, "$!name"
    unless_null $P1999, vivify_388
    new $P1999, "Undef"
  vivify_388:
    .return ($P1999)
.end


.namespace ["NQPParametricRoleHOW"]
.include "except_types.pasm"
.sub "attributes"  :subid("138_1298325424.79949") :outer("118_1298325424.79949")
    .param pmc param_2001
    .param pmc param_2002
.annotate 'line', 872
    .const 'Sub' $P2012 = "139_1298325424.79949" 
    capture_lex $P2012
    .lex "self", param_2001
    .lex "$obj", param_2002
.annotate 'line', 873
    $P2003 = root_new ['parrot';'ResizablePMCArray']
    .lex "@attrs", $P2003
.annotate 'line', 872
    find_lex $P2004, "@attrs"
.annotate 'line', 874
    find_lex $P2006, "self"
    get_global $P2007, "$?CLASS"
    getattribute $P2008, $P2006, $P2007, "%!attributes"
    unless_null $P2008, vivify_389
    $P2008 = root_new ['parrot';'Hash']
  vivify_389:
    defined $I2009, $P2008
    unless $I2009, for_undef_390
    iter $P2005, $P2008
    new $P2019, 'ExceptionHandler'
    set_label $P2019, loop2018_handler
    $P2019."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2019
  loop2018_test:
    unless $P2005, loop2018_done
    shift $P2010, $P2005
  loop2018_redo:
    .const 'Sub' $P2012 = "139_1298325424.79949" 
    capture_lex $P2012
    $P2012($P2010)
  loop2018_next:
    goto loop2018_test
  loop2018_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2020, exception, 'type'
    eq $P2020, .CONTROL_LOOP_NEXT, loop2018_next
    eq $P2020, .CONTROL_LOOP_REDO, loop2018_redo
  loop2018_done:
    pop_eh 
  for_undef_390:
    find_lex $P2021, "@attrs"
.annotate 'line', 872
    .return ($P2021)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "_block2011"  :anon :subid("139_1298325424.79949") :outer("138_1298325424.79949")
    .param pmc param_2013
.annotate 'line', 874
    .lex "$_", param_2013
.annotate 'line', 875
    find_lex $P2014, "@attrs"
    find_lex $P2015, "$_"
    $P2016 = $P2015."value"()
    $P2017 = $P2014."push"($P2016)
.annotate 'line', 874
    .return ($P2017)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "roles"  :subid("140_1298325424.79949") :outer("118_1298325424.79949")
    .param pmc param_2023
    .param pmc param_2024
.annotate 'line', 880
    .lex "self", param_2023
    .lex "$obj", param_2024
    find_lex $P2025, "self"
    get_global $P2026, "$?CLASS"
    getattribute $P2027, $P2025, $P2026, "@!roles"
    unless_null $P2027, vivify_391
    $P2027 = root_new ['parrot';'ResizablePMCArray']
  vivify_391:
    .return ($P2027)
.end


.namespace ["RoleToClassApplier"]
.sub "_block2088"  :subid("142_1298325424.79949") :outer("10_1298325424.79949")
.annotate 'line', 886
    .const 'Sub' $P2297 = "152_1298325424.79949" 
    capture_lex $P2297
    .const 'Sub' $P2161 = "147_1298325424.79949" 
    capture_lex $P2161
    .const 'Sub' $P2126 = "145_1298325424.79949" 
    capture_lex $P2126
    .const 'Sub' $P2091 = "143_1298325424.79949" 
    capture_lex $P2091
    get_global $P2090, "$?CLASS"
.annotate 'line', 888
    .const 'Sub' $P2091 = "143_1298325424.79949" 
    newclosure $P2125, $P2091
    .lex "has_method", $P2125
.annotate 'line', 896
    .const 'Sub' $P2126 = "145_1298325424.79949" 
    newclosure $P2158, $P2126
    .lex "has_attribute", $P2158
.annotate 'line', 886
    find_lex $P2159, "has_method"
    find_lex $P2160, "has_attribute"
.annotate 'line', 904
    .const 'Sub' $P2161 = "147_1298325424.79949" 
    newclosure $P2295, $P2161
.annotate 'line', 886
    .return ($P2295)
.end


.namespace ["RoleToClassApplier"]
.sub "" :load :init :subid("post392") :outer("142_1298325424.79949")
.annotate 'line', 886
    get_hll_global $P2089, ["RoleToClassApplier"], "_block2088" 
    .local pmc block
    set block, $P2089
    .const 'Sub' $P2297 = "152_1298325424.79949" 
    capture_lex $P2297
    $P2297()
.end


.namespace ["RoleToClassApplier"]
.sub "_block2296"  :anon :subid("152_1298325424.79949") :outer("142_1298325424.79949")
.annotate 'line', 886
    get_hll_global $P2298, "KnowHOW"
    $P2299 = $P2298."new_type"("RoleToClassApplier" :named("name"))
    .local pmc type_obj
    set type_obj, $P2299
    set_hll_global "RoleToClassApplier", type_obj
    set_global "$?CLASS", type_obj
    get_how $P2300, type_obj
    .const 'Sub' $P2301 = "147_1298325424.79949" 
    $P2300."add_method"(type_obj, "apply", $P2301)
    get_how $P2302, type_obj
    $P2303 = $P2302."compose"(type_obj)
    .return ($P2303)
.end


.namespace ["RoleToClassApplier"]
.include "except_types.pasm"
.sub "has_method"  :subid("143_1298325424.79949") :outer("142_1298325424.79949")
    .param pmc param_2094
    .param pmc param_2095
    .param pmc param_2096
.annotate 'line', 888
    .const 'Sub' $P2108 = "144_1298325424.79949" 
    capture_lex $P2108
    new $P2093, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2093, control_2092
    push_eh $P2093
    .lex "$target", param_2094
    .lex "$name", param_2095
    .lex "$local", param_2096
.annotate 'line', 889
    $P2097 = root_new ['parrot';'ResizablePMCArray']
    .lex "@methods", $P2097
    find_lex $P2098, "$target"
    get_how $P2099, $P2098
    find_lex $P2100, "$target"
    find_lex $P2101, "$local"
    $P2102 = $P2099."methods"($P2100, $P2101 :named("local"))
    store_lex "@methods", $P2102
.annotate 'line', 890
    find_lex $P2104, "@methods"
    defined $I2105, $P2104
    unless $I2105, for_undef_393
    iter $P2103, $P2104
    new $P2120, 'ExceptionHandler'
    set_label $P2120, loop2119_handler
    $P2120."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2120
  loop2119_test:
    unless $P2103, loop2119_done
    shift $P2106, $P2103
  loop2119_redo:
    .const 'Sub' $P2108 = "144_1298325424.79949" 
    capture_lex $P2108
    $P2108($P2106)
  loop2119_next:
    goto loop2119_test
  loop2119_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2121, exception, 'type'
    eq $P2121, .CONTROL_LOOP_NEXT, loop2119_next
    eq $P2121, .CONTROL_LOOP_REDO, loop2119_redo
  loop2119_done:
    pop_eh 
  for_undef_393:
.annotate 'line', 893
    new $P2122, "Exception"
    set $P2122['type'], .CONTROL_RETURN
    new $P2123, "Integer"
    assign $P2123, 0
    setattribute $P2122, 'payload', $P2123
    throw $P2122
.annotate 'line', 888
    .return ()
  control_2092:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2124, exception, "payload"
    .return ($P2124)
.end


.namespace ["RoleToClassApplier"]
.include "except_types.pasm"
.sub "_block2107"  :anon :subid("144_1298325424.79949") :outer("143_1298325424.79949")
    .param pmc param_2109
.annotate 'line', 890
    .lex "$_", param_2109
.annotate 'line', 891
    find_lex $P2112, "$_"
    set $S2113, $P2112
    find_lex $P2114, "$name"
    set $S2115, $P2114
    iseq $I2116, $S2113, $S2115
    if $I2116, if_2111
    new $P2110, 'Integer'
    set $P2110, $I2116
    goto if_2111_end
  if_2111:
    new $P2117, "Exception"
    set $P2117['type'], .CONTROL_RETURN
    new $P2118, "Integer"
    assign $P2118, 1
    setattribute $P2117, 'payload', $P2118
    throw $P2117
  if_2111_end:
.annotate 'line', 890
    .return ($P2110)
.end


.namespace ["RoleToClassApplier"]
.include "except_types.pasm"
.sub "has_attribute"  :subid("145_1298325424.79949") :outer("142_1298325424.79949")
    .param pmc param_2129
    .param pmc param_2130
.annotate 'line', 896
    .const 'Sub' $P2141 = "146_1298325424.79949" 
    capture_lex $P2141
    new $P2128, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2128, control_2127
    push_eh $P2128
    .lex "$target", param_2129
    .lex "$name", param_2130
.annotate 'line', 897
    $P2131 = root_new ['parrot';'ResizablePMCArray']
    .lex "@attributes", $P2131
    find_lex $P2132, "$target"
    get_how $P2133, $P2132
    find_lex $P2134, "$target"
    $P2135 = $P2133."attributes"($P2134, 1 :named("local"))
    store_lex "@attributes", $P2135
.annotate 'line', 898
    find_lex $P2137, "@attributes"
    defined $I2138, $P2137
    unless $I2138, for_undef_394
    iter $P2136, $P2137
    new $P2153, 'ExceptionHandler'
    set_label $P2153, loop2152_handler
    $P2153."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2153
  loop2152_test:
    unless $P2136, loop2152_done
    shift $P2139, $P2136
  loop2152_redo:
    .const 'Sub' $P2141 = "146_1298325424.79949" 
    capture_lex $P2141
    $P2141($P2139)
  loop2152_next:
    goto loop2152_test
  loop2152_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2154, exception, 'type'
    eq $P2154, .CONTROL_LOOP_NEXT, loop2152_next
    eq $P2154, .CONTROL_LOOP_REDO, loop2152_redo
  loop2152_done:
    pop_eh 
  for_undef_394:
.annotate 'line', 901
    new $P2155, "Exception"
    set $P2155['type'], .CONTROL_RETURN
    new $P2156, "Integer"
    assign $P2156, 0
    setattribute $P2155, 'payload', $P2156
    throw $P2155
.annotate 'line', 896
    .return ()
  control_2127:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2157, exception, "payload"
    .return ($P2157)
.end


.namespace ["RoleToClassApplier"]
.include "except_types.pasm"
.sub "_block2140"  :anon :subid("146_1298325424.79949") :outer("145_1298325424.79949")
    .param pmc param_2142
.annotate 'line', 898
    .lex "$_", param_2142
.annotate 'line', 899
    find_lex $P2145, "$_"
    $S2146 = $P2145."name"()
    find_lex $P2147, "$name"
    set $S2148, $P2147
    iseq $I2149, $S2146, $S2148
    if $I2149, if_2144
    new $P2143, 'Integer'
    set $P2143, $I2149
    goto if_2144_end
  if_2144:
    new $P2150, "Exception"
    set $P2150['type'], .CONTROL_RETURN
    new $P2151, "Integer"
    assign $P2151, 1
    setattribute $P2150, 'payload', $P2151
    throw $P2150
  if_2144_end:
.annotate 'line', 898
    .return ($P2143)
.end


.namespace ["RoleToClassApplier"]
.include "except_types.pasm"
.sub "apply"  :subid("147_1298325424.79949") :outer("142_1298325424.79949")
    .param pmc param_2162
    .param pmc param_2163
    .param pmc param_2164
.annotate 'line', 904
    .const 'Sub' $P2266 = "151_1298325424.79949" 
    capture_lex $P2266
    .const 'Sub' $P2240 = "150_1298325424.79949" 
    capture_lex $P2240
    .const 'Sub' $P2211 = "149_1298325424.79949" 
    capture_lex $P2211
    .const 'Sub' $P2191 = "148_1298325424.79949" 
    capture_lex $P2191
    .lex "self", param_2162
    .lex "$target", param_2163
    .lex "@roles", param_2164
.annotate 'line', 907
    new $P2165, "Undef"
    .lex "$to_compose", $P2165
.annotate 'line', 908
    new $P2166, "Undef"
    .lex "$to_compose_meta", $P2166
.annotate 'line', 923
    $P2167 = root_new ['parrot';'ResizablePMCArray']
    .lex "@collisions", $P2167
.annotate 'line', 932
    $P2168 = root_new ['parrot';'ResizablePMCArray']
    .lex "@methods", $P2168
.annotate 'line', 940
    $P2169 = root_new ['parrot';'ResizablePMCArray']
    .lex "@attributes", $P2169
.annotate 'line', 952
    $P2170 = root_new ['parrot';'ResizablePMCArray']
    .lex "@done", $P2170
.annotate 'line', 904
    find_lex $P2171, "$to_compose"
    find_lex $P2172, "$to_compose_meta"
.annotate 'line', 909
    find_lex $P2174, "@roles"
    set $N2175, $P2174
    iseq $I2176, $N2175, 1.0
    if $I2176, if_2173
.annotate 'line', 914
    get_hll_global $P2181, "NQPConcreteRoleHOW"
    get_hll_global $P2182, "NQPMu"
    $P2183 = $P2181."new_type"($P2182 :named("instance_of"))
    store_lex "$to_compose", $P2183
.annotate 'line', 915
    find_lex $P2184, "$to_compose"
    get_how $P2185, $P2184
    store_lex "$to_compose_meta", $P2185
.annotate 'line', 916
    find_lex $P2187, "@roles"
    defined $I2188, $P2187
    unless $I2188, for_undef_395
    iter $P2186, $P2187
    new $P2198, 'ExceptionHandler'
    set_label $P2198, loop2197_handler
    $P2198."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2198
  loop2197_test:
    unless $P2186, loop2197_done
    shift $P2189, $P2186
  loop2197_redo:
    .const 'Sub' $P2191 = "148_1298325424.79949" 
    capture_lex $P2191
    $P2191($P2189)
  loop2197_next:
    goto loop2197_test
  loop2197_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2199, exception, 'type'
    eq $P2199, .CONTROL_LOOP_NEXT, loop2197_next
    eq $P2199, .CONTROL_LOOP_REDO, loop2197_redo
  loop2197_done:
    pop_eh 
  for_undef_395:
.annotate 'line', 919
    find_lex $P2200, "$to_compose_meta"
    find_lex $P2201, "$to_compose"
    $P2202 = $P2200."compose"($P2201)
    store_lex "$to_compose", $P2202
.annotate 'line', 913
    goto if_2173_end
  if_2173:
.annotate 'line', 910
    find_lex $P2177, "@roles"
    unless_null $P2177, vivify_396
    $P2177 = root_new ['parrot';'ResizablePMCArray']
  vivify_396:
    set $P2178, $P2177[0]
    unless_null $P2178, vivify_397
    new $P2178, "Undef"
  vivify_397:
    store_lex "$to_compose", $P2178
.annotate 'line', 911
    find_lex $P2179, "$to_compose"
    get_how $P2180, $P2179
    store_lex "$to_compose_meta", $P2180
  if_2173_end:
.annotate 'line', 923
    find_lex $P2203, "$to_compose_meta"
    find_lex $P2204, "$to_compose"
    $P2205 = $P2203."collisions"($P2204)
    store_lex "@collisions", $P2205
.annotate 'line', 924
    find_lex $P2207, "@collisions"
    defined $I2208, $P2207
    unless $I2208, for_undef_398
    iter $P2206, $P2207
    new $P2230, 'ExceptionHandler'
    set_label $P2230, loop2229_handler
    $P2230."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2230
  loop2229_test:
    unless $P2206, loop2229_done
    shift $P2209, $P2206
  loop2229_redo:
    .const 'Sub' $P2211 = "149_1298325424.79949" 
    capture_lex $P2211
    $P2211($P2209)
  loop2229_next:
    goto loop2229_test
  loop2229_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2231, exception, 'type'
    eq $P2231, .CONTROL_LOOP_NEXT, loop2229_next
    eq $P2231, .CONTROL_LOOP_REDO, loop2229_redo
  loop2229_done:
    pop_eh 
  for_undef_398:
.annotate 'line', 932
    find_lex $P2232, "$to_compose_meta"
    find_lex $P2233, "$to_compose"
    $P2234 = $P2232."methods"($P2233)
    store_lex "@methods", $P2234
.annotate 'line', 933
    find_lex $P2236, "@methods"
    defined $I2237, $P2236
    unless $I2237, for_undef_399
    iter $P2235, $P2236
    new $P2256, 'ExceptionHandler'
    set_label $P2256, loop2255_handler
    $P2256."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2256
  loop2255_test:
    unless $P2235, loop2255_done
    shift $P2238, $P2235
  loop2255_redo:
    .const 'Sub' $P2240 = "150_1298325424.79949" 
    capture_lex $P2240
    $P2240($P2238)
  loop2255_next:
    goto loop2255_test
  loop2255_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2257, exception, 'type'
    eq $P2257, .CONTROL_LOOP_NEXT, loop2255_next
    eq $P2257, .CONTROL_LOOP_REDO, loop2255_redo
  loop2255_done:
    pop_eh 
  for_undef_399:
.annotate 'line', 940
    find_lex $P2258, "$to_compose_meta"
    find_lex $P2259, "$to_compose"
    $P2260 = $P2258."attributes"($P2259)
    store_lex "@attributes", $P2260
.annotate 'line', 941
    find_lex $P2262, "@attributes"
    defined $I2263, $P2262
    unless $I2263, for_undef_400
    iter $P2261, $P2262
    new $P2290, 'ExceptionHandler'
    set_label $P2290, loop2289_handler
    $P2290."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2290
  loop2289_test:
    unless $P2261, loop2289_done
    shift $P2264, $P2261
  loop2289_redo:
    .const 'Sub' $P2266 = "151_1298325424.79949" 
    capture_lex $P2266
    $P2266($P2264)
  loop2289_next:
    goto loop2289_test
  loop2289_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2291, exception, 'type'
    eq $P2291, .CONTROL_LOOP_NEXT, loop2289_next
    eq $P2291, .CONTROL_LOOP_REDO, loop2289_redo
  loop2289_done:
    pop_eh 
  for_undef_400:
    find_lex $P2292, "@done"
.annotate 'line', 953
    find_lex $P2293, "$to_compose"
    find_lex $P2294, "@done"
    unless_null $P2294, vivify_401
    $P2294 = root_new ['parrot';'ResizablePMCArray']
    store_lex "@done", $P2294
  vivify_401:
    set $P2294[0], $P2293
.annotate 'line', 904
    .return ($P2293)
.end


.namespace ["RoleToClassApplier"]
.sub "_block2190"  :anon :subid("148_1298325424.79949") :outer("147_1298325424.79949")
    .param pmc param_2192
.annotate 'line', 916
    .lex "$_", param_2192
.annotate 'line', 917
    find_lex $P2193, "$to_compose_meta"
    find_lex $P2194, "$to_compose"
    find_lex $P2195, "$_"
    $P2196 = $P2193."add_role"($P2194, $P2195)
.annotate 'line', 916
    .return ($P2196)
.end


.namespace ["RoleToClassApplier"]
.sub "_block2210"  :anon :subid("149_1298325424.79949") :outer("147_1298325424.79949")
    .param pmc param_2212
.annotate 'line', 924
    .lex "$_", param_2212
.annotate 'line', 925
    find_lex $P2215, "$target"
    find_lex $P2216, "$_"
    set $S2217, $P2216
    $P2218 = "has_method"($P2215, $S2217, 1)
    unless $P2218, unless_2214
    set $P2213, $P2218
    goto unless_2214_end
  unless_2214:
.annotate 'line', 926
    new $P2219, 'String'
    set $P2219, "Method '"
    find_lex $P2220, "$_"
    concat $P2221, $P2219, $P2220
    concat $P2222, $P2221, "' collides and a resolution must be provided by the class '"
.annotate 'line', 927
    find_lex $P2223, "$target"
    get_how $P2224, $P2223
    find_lex $P2225, "$target"
    $S2226 = $P2224."name"($P2225)
    concat $P2227, $P2222, $S2226
.annotate 'line', 926
    concat $P2228, $P2227, "'"
.annotate 'line', 927
    die $P2228
  unless_2214_end:
.annotate 'line', 924
    .return ($P2213)
.end


.namespace ["RoleToClassApplier"]
.sub "_block2239"  :anon :subid("150_1298325424.79949") :outer("147_1298325424.79949")
    .param pmc param_2241
.annotate 'line', 933
    .lex "$_", param_2241
.annotate 'line', 934
    find_lex $P2244, "$target"
    find_lex $P2245, "$_"
    set $S2246, $P2245
    $P2247 = "has_method"($P2244, $S2246, 0)
    unless $P2247, unless_2243
    set $P2242, $P2247
    goto unless_2243_end
  unless_2243:
.annotate 'line', 935
    find_lex $P2248, "$target"
    get_how $P2249, $P2248
    find_lex $P2250, "$target"
    find_lex $P2251, "$_"
    set $S2252, $P2251
    find_lex $P2253, "$_"
    $P2254 = $P2249."add_method"($P2250, $S2252, $P2253)
.annotate 'line', 934
    set $P2242, $P2254
  unless_2243_end:
.annotate 'line', 933
    .return ($P2242)
.end


.namespace ["RoleToClassApplier"]
.sub "_block2265"  :anon :subid("151_1298325424.79949") :outer("147_1298325424.79949")
    .param pmc param_2267
.annotate 'line', 941
    .lex "$_", param_2267
.annotate 'line', 942
    find_lex $P2269, "$target"
    find_lex $P2270, "$_"
    $P2271 = $P2270."name"()
    $P2272 = "has_attribute"($P2269, $P2271)
    unless $P2272, if_2268_end
.annotate 'line', 943
    new $P2273, "String"
    assign $P2273, "Attribute '"
    find_lex $P2274, "$_"
    $S2275 = $P2274."name"()
    concat $P2276, $P2273, $S2275
    concat $P2277, $P2276, "' already exists in the class '"
.annotate 'line', 944
    find_lex $P2278, "$target"
    get_how $P2279, $P2278
    find_lex $P2280, "$target"
    $S2281 = $P2279."name"($P2280)
    concat $P2282, $P2277, $S2281
.annotate 'line', 943
    concat $P2283, $P2282, "', but a role also wishes to compose it"
.annotate 'line', 944
    die $P2283
  if_2268_end:
.annotate 'line', 946
    find_lex $P2284, "$target"
    get_how $P2285, $P2284
    find_lex $P2286, "$target"
    find_lex $P2287, "$_"
    $P2288 = $P2285."add_attribute"($P2286, $P2287)
.annotate 'line', 941
    .return ($P2288)
.end


.namespace ["RoleToRoleApplier"]
.sub "_block2304"  :subid("153_1298325424.79949") :outer("10_1298325424.79949")
.annotate 'line', 958
    .const 'Sub' $P2527 = "163_1298325424.79949" 
    capture_lex $P2527
    .const 'Sub' $P2307 = "154_1298325424.79949" 
    capture_lex $P2307
    get_global $P2306, "$?CLASS"
.annotate 'line', 959
    .const 'Sub' $P2307 = "154_1298325424.79949" 
    newclosure $P2525, $P2307
.annotate 'line', 958
    .return ($P2525)
.end


.namespace ["RoleToRoleApplier"]
.sub "" :load :init :subid("post402") :outer("153_1298325424.79949")
.annotate 'line', 958
    get_hll_global $P2305, ["RoleToRoleApplier"], "_block2304" 
    .local pmc block
    set block, $P2305
    .const 'Sub' $P2527 = "163_1298325424.79949" 
    capture_lex $P2527
    $P2527()
.end


.namespace ["RoleToRoleApplier"]
.sub "_block2526"  :anon :subid("163_1298325424.79949") :outer("153_1298325424.79949")
.annotate 'line', 958
    get_hll_global $P2528, "KnowHOW"
    $P2529 = $P2528."new_type"("RoleToRoleApplier" :named("name"))
    .local pmc type_obj
    set type_obj, $P2529
    set_hll_global "RoleToRoleApplier", type_obj
    set_global "$?CLASS", type_obj
    get_how $P2530, type_obj
    .const 'Sub' $P2531 = "154_1298325424.79949" 
    $P2530."add_method"(type_obj, "apply", $P2531)
    get_how $P2532, type_obj
    $P2533 = $P2532."compose"(type_obj)
    .return ($P2533)
.end


.namespace ["RoleToRoleApplier"]
.include "except_types.pasm"
.sub "apply"  :subid("154_1298325424.79949") :outer("153_1298325424.79949")
    .param pmc param_2310
    .param pmc param_2311
    .param pmc param_2312
.annotate 'line', 959
    .const 'Sub' $P2452 = "160_1298325424.79949" 
    capture_lex $P2452
    .const 'Sub' $P2410 = "159_1298325424.79949" 
    capture_lex $P2410
    .const 'Sub' $P2396 = "158_1298325424.79949" 
    capture_lex $P2396
    .const 'Sub' $P2323 = "155_1298325424.79949" 
    capture_lex $P2323
    new $P2309, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2309, control_2308
    push_eh $P2309
    .lex "self", param_2310
    .lex "$target", param_2311
    .lex "@roles", param_2312
.annotate 'line', 961
    $P2313 = root_new ['parrot';'Hash']
    .lex "%meth_info", $P2313
.annotate 'line', 987
    $P2314 = root_new ['parrot';'Hash']
    .lex "%target_meth_info", $P2314
.annotate 'line', 988
    $P2315 = root_new ['parrot';'ResizablePMCArray']
    .lex "@target_meths", $P2315
.annotate 'line', 1013
    $P2316 = root_new ['parrot';'ResizablePMCArray']
    .lex "@all_roles", $P2316
.annotate 'line', 959
    find_lex $P2317, "%meth_info"
.annotate 'line', 962
    find_lex $P2319, "@roles"
    defined $I2320, $P2319
    unless $I2320, for_undef_403
    iter $P2318, $P2319
    new $P2384, 'ExceptionHandler'
    set_label $P2384, loop2383_handler
    $P2384."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2384
  loop2383_test:
    unless $P2318, loop2383_done
    shift $P2321, $P2318
  loop2383_redo:
    .const 'Sub' $P2323 = "155_1298325424.79949" 
    capture_lex $P2323
    $P2323($P2321)
  loop2383_next:
    goto loop2383_test
  loop2383_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2385, exception, 'type'
    eq $P2385, .CONTROL_LOOP_NEXT, loop2383_next
    eq $P2385, .CONTROL_LOOP_REDO, loop2383_redo
  loop2383_done:
    pop_eh 
  for_undef_403:
    find_lex $P2386, "%target_meth_info"
.annotate 'line', 988
    find_lex $P2387, "$target"
    get_how $P2388, $P2387
    find_lex $P2389, "$target"
    $P2390 = $P2388."methods"($P2389)
    store_lex "@target_meths", $P2390
.annotate 'line', 989
    find_lex $P2392, "@target_meths"
    defined $I2393, $P2392
    unless $I2393, for_undef_411
    iter $P2391, $P2392
    new $P2403, 'ExceptionHandler'
    set_label $P2403, loop2402_handler
    $P2403."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2403
  loop2402_test:
    unless $P2391, loop2402_done
    shift $P2394, $P2391
  loop2402_redo:
    .const 'Sub' $P2396 = "158_1298325424.79949" 
    capture_lex $P2396
    $P2396($P2394)
  loop2402_next:
    goto loop2402_test
  loop2402_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2404, exception, 'type'
    eq $P2404, .CONTROL_LOOP_NEXT, loop2402_next
    eq $P2404, .CONTROL_LOOP_REDO, loop2402_redo
  loop2402_done:
    pop_eh 
  for_undef_411:
.annotate 'line', 994
    find_lex $P2406, "%meth_info"
    defined $I2407, $P2406
    unless $I2407, for_undef_413
    iter $P2405, $P2406
    new $P2444, 'ExceptionHandler'
    set_label $P2444, loop2443_handler
    $P2444."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2444
  loop2443_test:
    unless $P2405, loop2443_done
    shift $P2408, $P2405
  loop2443_redo:
    .const 'Sub' $P2410 = "159_1298325424.79949" 
    capture_lex $P2410
    $P2410($P2408)
  loop2443_next:
    goto loop2443_test
  loop2443_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2445, exception, 'type'
    eq $P2445, .CONTROL_LOOP_NEXT, loop2443_next
    eq $P2445, .CONTROL_LOOP_REDO, loop2443_redo
  loop2443_done:
    pop_eh 
  for_undef_413:
    find_lex $P2446, "@all_roles"
.annotate 'line', 1014
    find_lex $P2448, "@roles"
    defined $I2449, $P2448
    unless $I2449, for_undef_420
    iter $P2447, $P2448
    new $P2520, 'ExceptionHandler'
    set_label $P2520, loop2519_handler
    $P2520."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2520
  loop2519_test:
    unless $P2447, loop2519_done
    shift $P2450, $P2447
  loop2519_redo:
    .const 'Sub' $P2452 = "160_1298325424.79949" 
    capture_lex $P2452
    $P2452($P2450)
  loop2519_next:
    goto loop2519_test
  loop2519_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2521, exception, 'type'
    eq $P2521, .CONTROL_LOOP_NEXT, loop2519_next
    eq $P2521, .CONTROL_LOOP_REDO, loop2519_redo
  loop2519_done:
    pop_eh 
  for_undef_420:
.annotate 'line', 1043
    new $P2522, "Exception"
    set $P2522['type'], .CONTROL_RETURN
    find_lex $P2523, "@all_roles"
    setattribute $P2522, 'payload', $P2523
    throw $P2522
.annotate 'line', 959
    .return ()
  control_2308:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2524, exception, "payload"
    .return ($P2524)
.end


.namespace ["RoleToRoleApplier"]
.include "except_types.pasm"
.sub "_block2322"  :anon :subid("155_1298325424.79949") :outer("154_1298325424.79949")
    .param pmc param_2325
.annotate 'line', 962
    .const 'Sub' $P2335 = "156_1298325424.79949" 
    capture_lex $P2335
.annotate 'line', 963
    $P2324 = root_new ['parrot';'ResizablePMCArray']
    .lex "@methods", $P2324
    .lex "$_", param_2325
    find_lex $P2326, "$_"
    get_how $P2327, $P2326
    find_lex $P2328, "$_"
    $P2329 = $P2327."methods"($P2328)
    store_lex "@methods", $P2329
.annotate 'line', 964
    find_lex $P2331, "@methods"
    defined $I2332, $P2331
    unless $I2332, for_undef_404
    iter $P2330, $P2331
    new $P2381, 'ExceptionHandler'
    set_label $P2381, loop2380_handler
    $P2381."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2381
  loop2380_test:
    unless $P2330, loop2380_done
    shift $P2333, $P2330
  loop2380_redo:
    .const 'Sub' $P2335 = "156_1298325424.79949" 
    capture_lex $P2335
    $P2335($P2333)
  loop2380_next:
    goto loop2380_test
  loop2380_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2382, exception, 'type'
    eq $P2382, .CONTROL_LOOP_NEXT, loop2380_next
    eq $P2382, .CONTROL_LOOP_REDO, loop2380_redo
  loop2380_done:
    pop_eh 
  for_undef_404:
.annotate 'line', 962
    .return ($P2330)
.end


.namespace ["RoleToRoleApplier"]
.include "except_types.pasm"
.sub "_block2334"  :anon :subid("156_1298325424.79949") :outer("155_1298325424.79949")
    .param pmc param_2340
.annotate 'line', 964
    .const 'Sub' $P2363 = "157_1298325424.79949" 
    capture_lex $P2363
.annotate 'line', 965
    new $P2336, "Undef"
    .lex "$name", $P2336
.annotate 'line', 966
    new $P2337, "Undef"
    .lex "$meth", $P2337
.annotate 'line', 967
    $P2338 = root_new ['parrot';'ResizablePMCArray']
    .lex "@meth_list", $P2338
.annotate 'line', 974
    new $P2339, "Undef"
    .lex "$found", $P2339
    .lex "$_", param_2340
.annotate 'line', 965
    find_lex $P2341, "$_"
    set $S2342, $P2341
    new $P2343, 'String'
    set $P2343, $S2342
    store_lex "$name", $P2343
.annotate 'line', 966
    find_lex $P2344, "$_"
    store_lex "$meth", $P2344
    find_lex $P2345, "@meth_list"
.annotate 'line', 968
    find_lex $P2347, "$name"
    find_lex $P2348, "%meth_info"
    unless_null $P2348, vivify_405
    $P2348 = root_new ['parrot';'Hash']
  vivify_405:
    set $P2349, $P2348[$P2347]
    unless_null $P2349, vivify_406
    new $P2349, "Undef"
  vivify_406:
    defined $I2350, $P2349
    if $I2350, if_2346
.annotate 'line', 972
    find_lex $P2354, "@meth_list"
    find_lex $P2355, "$name"
    find_lex $P2356, "%meth_info"
    unless_null $P2356, vivify_407
    $P2356 = root_new ['parrot';'Hash']
    store_lex "%meth_info", $P2356
  vivify_407:
    set $P2356[$P2355], $P2354
.annotate 'line', 971
    goto if_2346_end
  if_2346:
.annotate 'line', 969
    find_lex $P2351, "$name"
    find_lex $P2352, "%meth_info"
    unless_null $P2352, vivify_408
    $P2352 = root_new ['parrot';'Hash']
  vivify_408:
    set $P2353, $P2352[$P2351]
    unless_null $P2353, vivify_409
    new $P2353, "Undef"
  vivify_409:
    store_lex "@meth_list", $P2353
  if_2346_end:
.annotate 'line', 974
    new $P2357, "Integer"
    assign $P2357, 0
    store_lex "$found", $P2357
.annotate 'line', 975
    find_lex $P2359, "@meth_list"
    defined $I2360, $P2359
    unless $I2360, for_undef_410
    iter $P2358, $P2359
    new $P2372, 'ExceptionHandler'
    set_label $P2372, loop2371_handler
    $P2372."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2372
  loop2371_test:
    unless $P2358, loop2371_done
    shift $P2361, $P2358
  loop2371_redo:
    .const 'Sub' $P2363 = "157_1298325424.79949" 
    capture_lex $P2363
    $P2363($P2361)
  loop2371_next:
    goto loop2371_test
  loop2371_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2373, exception, 'type'
    eq $P2373, .CONTROL_LOOP_NEXT, loop2371_next
    eq $P2373, .CONTROL_LOOP_REDO, loop2371_redo
  loop2371_done:
    pop_eh 
  for_undef_410:
.annotate 'line', 980
    find_lex $P2376, "$found"
    unless $P2376, unless_2375
    set $P2374, $P2376
    goto unless_2375_end
  unless_2375:
.annotate 'line', 981
    find_lex $P2377, "@meth_list"
    find_lex $P2378, "$meth"
    $P2379 = $P2377."push"($P2378)
.annotate 'line', 980
    set $P2374, $P2379
  unless_2375_end:
.annotate 'line', 964
    .return ($P2374)
.end


.namespace ["RoleToRoleApplier"]
.sub "_block2362"  :anon :subid("157_1298325424.79949") :outer("156_1298325424.79949")
    .param pmc param_2364
.annotate 'line', 975
    .lex "$_", param_2364
.annotate 'line', 976
    find_lex $P2367, "$meth"
    find_lex $P2368, "$_"
    issame $I2369, $P2367, $P2368
    if $I2369, if_2366
    new $P2365, 'Integer'
    set $P2365, $I2369
    goto if_2366_end
  if_2366:
.annotate 'line', 977
    new $P2370, "Integer"
    assign $P2370, 1
    store_lex "$found", $P2370
.annotate 'line', 976
    set $P2365, $P2370
  if_2366_end:
.annotate 'line', 975
    .return ($P2365)
.end


.namespace ["RoleToRoleApplier"]
.sub "_block2395"  :anon :subid("158_1298325424.79949") :outer("154_1298325424.79949")
    .param pmc param_2397
.annotate 'line', 989
    .lex "$_", param_2397
.annotate 'line', 990
    find_lex $P2398, "$_"
    find_lex $P2399, "$_"
    set $S2400, $P2399
    find_lex $P2401, "%target_meth_info"
    unless_null $P2401, vivify_412
    $P2401 = root_new ['parrot';'Hash']
    store_lex "%target_meth_info", $P2401
  vivify_412:
    set $P2401[$S2400], $P2398
.annotate 'line', 989
    .return ($P2398)
.end


.namespace ["RoleToRoleApplier"]
.sub "_block2409"  :anon :subid("159_1298325424.79949") :outer("154_1298325424.79949")
    .param pmc param_2413
.annotate 'line', 995
    new $P2411, "Undef"
    .lex "$name", $P2411
.annotate 'line', 996
    $P2412 = root_new ['parrot';'ResizablePMCArray']
    .lex "@add_meths", $P2412
    .lex "$_", param_2413
.annotate 'line', 995
    find_lex $P2414, "$_"
    set $S2415, $P2414
    new $P2416, 'String'
    set $P2416, $S2415
    store_lex "$name", $P2416
.annotate 'line', 996
    find_lex $P2417, "$name"
    find_lex $P2418, "%meth_info"
    unless_null $P2418, vivify_414
    $P2418 = root_new ['parrot';'Hash']
  vivify_414:
    set $P2419, $P2418[$P2417]
    unless_null $P2419, vivify_415
    new $P2419, "Undef"
  vivify_415:
    store_lex "@add_meths", $P2419
.annotate 'line', 1000
    find_lex $P2422, "$name"
    find_lex $P2423, "%target_meth_info"
    unless_null $P2423, vivify_416
    $P2423 = root_new ['parrot';'Hash']
  vivify_416:
    set $P2424, $P2423[$P2422]
    unless_null $P2424, vivify_417
    new $P2424, "Undef"
  vivify_417:
    defined $I2425, $P2424
    unless $I2425, unless_2421
    new $P2420, 'Integer'
    set $P2420, $I2425
    goto unless_2421_end
  unless_2421:
.annotate 'line', 1002
    find_lex $P2428, "@add_meths"
    set $N2429, $P2428
    iseq $I2430, $N2429, 1.0
    if $I2430, if_2427
.annotate 'line', 1007
    find_lex $P2438, "$target"
    get_how $P2439, $P2438
    find_lex $P2440, "$target"
    find_lex $P2441, "$name"
    $P2442 = $P2439."add_collision"($P2440, $P2441)
.annotate 'line', 1005
    set $P2426, $P2442
.annotate 'line', 1002
    goto if_2427_end
  if_2427:
.annotate 'line', 1003
    find_lex $P2431, "$target"
    get_how $P2432, $P2431
    find_lex $P2433, "$target"
    find_lex $P2434, "$name"
    find_lex $P2435, "@add_meths"
    unless_null $P2435, vivify_418
    $P2435 = root_new ['parrot';'ResizablePMCArray']
  vivify_418:
    set $P2436, $P2435[0]
    unless_null $P2436, vivify_419
    new $P2436, "Undef"
  vivify_419:
    $P2437 = $P2432."add_method"($P2433, $P2434, $P2436)
.annotate 'line', 1002
    set $P2426, $P2437
  if_2427_end:
.annotate 'line', 1000
    set $P2420, $P2426
  unless_2421_end:
.annotate 'line', 994
    .return ($P2420)
.end


.namespace ["RoleToRoleApplier"]
.include "except_types.pasm"
.sub "_block2451"  :anon :subid("160_1298325424.79949") :outer("154_1298325424.79949")
    .param pmc param_2455
.annotate 'line', 1014
    .const 'Sub' $P2466 = "161_1298325424.79949" 
    capture_lex $P2466
.annotate 'line', 1015
    new $P2453, "Undef"
    .lex "$how", $P2453
.annotate 'line', 1018
    $P2454 = root_new ['parrot';'ResizablePMCArray']
    .lex "@attributes", $P2454
    .lex "$_", param_2455
.annotate 'line', 1015
    find_lex $P2456, "$_"
    get_how $P2457, $P2456
    store_lex "$how", $P2457
.annotate 'line', 1018
    find_lex $P2458, "$how"
    find_lex $P2459, "$_"
    $P2460 = $P2458."attributes"($P2459)
    store_lex "@attributes", $P2460
.annotate 'line', 1019
    find_lex $P2462, "@attributes"
    defined $I2463, $P2462
    unless $I2463, for_undef_421
    iter $P2461, $P2462
    new $P2514, 'ExceptionHandler'
    set_label $P2514, loop2513_handler
    $P2514."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2514
  loop2513_test:
    unless $P2461, loop2513_done
    shift $P2464, $P2461
  loop2513_redo:
    .const 'Sub' $P2466 = "161_1298325424.79949" 
    capture_lex $P2466
    $P2466($P2464)
  loop2513_next:
    goto loop2513_test
  loop2513_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2515, exception, 'type'
    eq $P2515, .CONTROL_LOOP_NEXT, loop2513_next
    eq $P2515, .CONTROL_LOOP_REDO, loop2513_redo
  loop2513_done:
    pop_eh 
  for_undef_421:
.annotate 'line', 1040
    find_lex $P2516, "@all_roles"
    find_lex $P2517, "$_"
    $P2518 = $P2516."push"($P2517)
.annotate 'line', 1014
    .return ($P2518)
.end


.namespace ["RoleToRoleApplier"]
.include "except_types.pasm"
.sub "_block2465"  :anon :subid("161_1298325424.79949") :outer("160_1298325424.79949")
    .param pmc param_2470
.annotate 'line', 1019
    .const 'Sub' $P2482 = "162_1298325424.79949" 
    capture_lex $P2482
.annotate 'line', 1020
    new $P2467, "Undef"
    .lex "$add_attr", $P2467
.annotate 'line', 1021
    new $P2468, "Undef"
    .lex "$skip", $P2468
.annotate 'line', 1022
    $P2469 = root_new ['parrot';'ResizablePMCArray']
    .lex "@cur_attrs", $P2469
    .lex "$_", param_2470
.annotate 'line', 1020
    find_lex $P2471, "$_"
    store_lex "$add_attr", $P2471
.annotate 'line', 1021
    new $P2472, "Integer"
    assign $P2472, 0
    store_lex "$skip", $P2472
.annotate 'line', 1022
    find_lex $P2473, "$target"
    get_how $P2474, $P2473
    find_lex $P2475, "$target"
    $P2476 = $P2474."attributes"($P2475)
    store_lex "@cur_attrs", $P2476
.annotate 'line', 1023
    find_lex $P2478, "@cur_attrs"
    defined $I2479, $P2478
    unless $I2479, for_undef_422
    iter $P2477, $P2478
    new $P2503, 'ExceptionHandler'
    set_label $P2503, loop2502_handler
    $P2503."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2503
  loop2502_test:
    unless $P2477, loop2502_done
    shift $P2480, $P2477
  loop2502_redo:
    .const 'Sub' $P2482 = "162_1298325424.79949" 
    capture_lex $P2482
    $P2482($P2480)
  loop2502_next:
    goto loop2502_test
  loop2502_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2504, exception, 'type'
    eq $P2504, .CONTROL_LOOP_NEXT, loop2502_next
    eq $P2504, .CONTROL_LOOP_REDO, loop2502_redo
  loop2502_done:
    pop_eh 
  for_undef_422:
.annotate 'line', 1033
    find_lex $P2507, "$skip"
    unless $P2507, unless_2506
    set $P2505, $P2507
    goto unless_2506_end
  unless_2506:
.annotate 'line', 1034
    find_lex $P2508, "$target"
    get_how $P2509, $P2508
    find_lex $P2510, "$target"
    find_lex $P2511, "$add_attr"
    $P2512 = $P2509."add_attribute"($P2510, $P2511)
.annotate 'line', 1033
    set $P2505, $P2512
  unless_2506_end:
.annotate 'line', 1019
    .return ($P2505)
.end


.namespace ["RoleToRoleApplier"]
.sub "_block2481"  :anon :subid("162_1298325424.79949") :outer("161_1298325424.79949")
    .param pmc param_2483
.annotate 'line', 1023
    .lex "$_", param_2483
.annotate 'line', 1024
    find_lex $P2486, "$_"
    find_lex $P2487, "$add_attr"
    issame $I2488, $P2486, $P2487
    if $I2488, if_2485
.annotate 'line', 1028
    find_lex $P2492, "$_"
    $S2493 = $P2492."name"()
    find_lex $P2494, "$add_attr"
    $S2495 = $P2494."name"()
    iseq $I2496, $S2493, $S2495
    if $I2496, if_2491
    new $P2490, 'Integer'
    set $P2490, $I2496
    goto if_2491_end
  if_2491:
.annotate 'line', 1029
    new $P2497, "String"
    assign $P2497, "Attribute '"
    find_lex $P2498, "$_"
    $S2499 = $P2498."name"()
    concat $P2500, $P2497, $S2499
    concat $P2501, $P2500, "' conflicts in role composition"
    die $P2501
  if_2491_end:
.annotate 'line', 1027
    set $P2484, $P2490
.annotate 'line', 1024
    goto if_2485_end
  if_2485:
.annotate 'line', 1025
    new $P2489, "Integer"
    assign $P2489, 1
    store_lex "$skip", $P2489
.annotate 'line', 1024
    set $P2484, $P2489
  if_2485_end:
.annotate 'line', 1023
    .return ($P2484)
.end


.namespace ["NQPModuleHOW"]
.sub "_block2534"  :subid("164_1298325424.79949") :outer("10_1298325424.79949")
.annotate 'line', 1048
    .const 'Sub' $P2596 = "173_1298325424.79949" 
    capture_lex $P2596
    .const 'Sub' $P2588 = "172_1298325424.79949" 
    capture_lex $P2588
    .const 'Sub' $P2582 = "171_1298325424.79949" 
    capture_lex $P2582
    .const 'Sub' $P2578 = "170_1298325424.79949" 
    capture_lex $P2578
    .const 'Sub' $P2573 = "169_1298325424.79949" 
    capture_lex $P2573
    .const 'Sub' $P2568 = "168_1298325424.79949" 
    capture_lex $P2568
    .const 'Sub' $P2554 = "167_1298325424.79949" 
    capture_lex $P2554
    .const 'Sub' $P2547 = "166_1298325424.79949" 
    capture_lex $P2547
    .const 'Sub' $P2537 = "165_1298325424.79949" 
    capture_lex $P2537
    get_global $P2536, "$?CLASS"
.annotate 'line', 1087
    .const 'Sub' $P2588 = "172_1298325424.79949" 
    newclosure $P2594, $P2588
.annotate 'line', 1048
    .return ($P2594)
.end


.namespace ["NQPModuleHOW"]
.sub "" :load :init :subid("post423") :outer("164_1298325424.79949")
.annotate 'line', 1048
    get_hll_global $P2535, ["NQPModuleHOW"], "_block2534" 
    .local pmc block
    set block, $P2535
    .const 'Sub' $P2596 = "173_1298325424.79949" 
    capture_lex $P2596
    $P2596()
.end


.namespace ["NQPModuleHOW"]
.sub "_block2595"  :anon :subid("173_1298325424.79949") :outer("164_1298325424.79949")
.annotate 'line', 1048
    get_hll_global $P2597, "KnowHOW"
    $P2598 = $P2597."new_type"("NQPModuleHOW" :named("name"))
    .local pmc type_obj
    set type_obj, $P2598
    set_hll_global "NQPModuleHOW", type_obj
    set_global "$?CLASS", type_obj
    get_how $P2599, type_obj
    get_hll_global $P2600, "KnowHOWAttribute"
    $P2601 = $P2600."new"("$!name" :named("name"))
    $P2599."add_attribute"(type_obj, $P2601)
    get_how $P2602, type_obj
    get_hll_global $P2603, "KnowHOWAttribute"
    $P2604 = $P2603."new"("$!composed" :named("name"))
    $P2602."add_attribute"(type_obj, $P2604)
    get_how $P2605, type_obj
    .const 'Sub' $P2606 = "165_1298325424.79949" 
    $P2605."add_method"(type_obj, "new", $P2606)
    get_how $P2607, type_obj
    .const 'Sub' $P2608 = "166_1298325424.79949" 
    $P2607."add_method"(type_obj, "BUILD", $P2608)
    get_how $P2609, type_obj
    .const 'Sub' $P2610 = "167_1298325424.79949" 
    $P2609."add_method"(type_obj, "new_type", $P2610)
    get_how $P2611, type_obj
    .const 'Sub' $P2612 = "168_1298325424.79949" 
    $P2611."add_method"(type_obj, "add_method", $P2612)
    get_how $P2613, type_obj
    .const 'Sub' $P2614 = "169_1298325424.79949" 
    $P2613."add_method"(type_obj, "add_multi_method", $P2614)
    get_how $P2615, type_obj
    .const 'Sub' $P2616 = "170_1298325424.79949" 
    $P2615."add_method"(type_obj, "add_attribute", $P2616)
    get_how $P2617, type_obj
    .const 'Sub' $P2618 = "171_1298325424.79949" 
    $P2617."add_method"(type_obj, "compose", $P2618)
    get_how $P2619, type_obj
    .const 'Sub' $P2620 = "172_1298325424.79949" 
    $P2619."add_method"(type_obj, "name", $P2620)
    get_how $P2621, type_obj
    $P2622 = $P2621."compose"(type_obj)
    .return ($P2622)
.end


.namespace ["NQPModuleHOW"]
.sub "new"  :subid("165_1298325424.79949") :outer("164_1298325424.79949")
    .param pmc param_2538
    .param pmc param_2539 :optional :named("name")
    .param int has_param_2539 :opt_flag
.annotate 'line', 1052
    .lex "self", param_2538
    if has_param_2539, optparam_424
    new $P2540, "Undef"
    set param_2539, $P2540
  optparam_424:
    .lex "$name", param_2539
.annotate 'line', 1053
    new $P2541, "Undef"
    .lex "$obj", $P2541
    find_lex $P2542, "self"
    repr_instance_of $P2543, $P2542
    store_lex "$obj", $P2543
.annotate 'line', 1054
    find_lex $P2544, "$obj"
    find_lex $P2545, "$name"
    $P2544."BUILD"($P2545 :named("name"))
    find_lex $P2546, "$obj"
.annotate 'line', 1052
    .return ($P2546)
.end


.namespace ["NQPModuleHOW"]
.sub "BUILD"  :subid("166_1298325424.79949") :outer("164_1298325424.79949")
    .param pmc param_2548
    .param pmc param_2549 :optional :named("name")
    .param int has_param_2549 :opt_flag
.annotate 'line', 1058
    .lex "self", param_2548
    if has_param_2549, optparam_425
    new $P2550, "Undef"
    set param_2549, $P2550
  optparam_425:
    .lex "$name", param_2549
.annotate 'line', 1059
    find_lex $P2551, "$name"
    find_lex $P2552, "self"
    get_global $P2553, "$?CLASS"
    setattribute $P2552, $P2553, "$!name", $P2551
.annotate 'line', 1058
    .return ($P2551)
.end


.namespace ["NQPModuleHOW"]
.sub "new_type"  :subid("167_1298325424.79949") :outer("164_1298325424.79949")
    .param pmc param_2555
    .param pmc param_2556 :optional :named("name")
    .param int has_param_2556 :opt_flag
    .param pmc param_2558 :optional :named("repr")
    .param int has_param_2558 :opt_flag
.annotate 'line', 1064
    .lex "self", param_2555
    if has_param_2556, optparam_426
    new $P2557, "String"
    assign $P2557, "<anon>"
    set param_2556, $P2557
  optparam_426:
    .lex "$name", param_2556
    if has_param_2558, optparam_427
    new $P2559, "String"
    assign $P2559, "P6opaque"
    set param_2558, $P2559
  optparam_427:
    .lex "$repr", param_2558
.annotate 'line', 1065
    new $P2560, "Undef"
    .lex "$metaclass", $P2560
    find_lex $P2561, "self"
    find_lex $P2562, "$name"
    $P2563 = $P2561."new"($P2562 :named("name"))
    store_lex "$metaclass", $P2563
.annotate 'line', 1066
    find_lex $P2564, "$metaclass"
    find_lex $P2565, "$repr"
    set $S2566, $P2565
    repr_type_object_for $P2567, $P2564, $S2566
.annotate 'line', 1064
    .return ($P2567)
.end


.namespace ["NQPModuleHOW"]
.sub "add_method"  :subid("168_1298325424.79949") :outer("164_1298325424.79949")
    .param pmc param_2569
    .param pmc param_2570
    .param pmc param_2571
    .param pmc param_2572
.annotate 'line', 1069
    .lex "self", param_2569
    .lex "$obj", param_2570
    .lex "$name", param_2571
    .lex "$code_obj", param_2572
    .return ()
.end


.namespace ["NQPModuleHOW"]
.sub "add_multi_method"  :subid("169_1298325424.79949") :outer("164_1298325424.79949")
    .param pmc param_2574
    .param pmc param_2575
    .param pmc param_2576
    .param pmc param_2577
.annotate 'line', 1075
    .lex "self", param_2574
    .lex "$obj", param_2575
    .lex "$name", param_2576
    .lex "$code_obj", param_2577
.annotate 'line', 1076
    die "Modules may not have methods"
.annotate 'line', 1075
    .return ()
.end


.namespace ["NQPModuleHOW"]
.sub "add_attribute"  :subid("170_1298325424.79949") :outer("164_1298325424.79949")
    .param pmc param_2579
    .param pmc param_2580
    .param pmc param_2581
.annotate 'line', 1079
    .lex "self", param_2579
    .lex "$obj", param_2580
    .lex "$meta_attr", param_2581
.annotate 'line', 1080
    die "Modules may not have attributes"
.annotate 'line', 1079
    .return ()
.end


.namespace ["NQPModuleHOW"]
.sub "compose"  :subid("171_1298325424.79949") :outer("164_1298325424.79949")
    .param pmc param_2583
    .param pmc param_2584
.annotate 'line', 1083
    .lex "self", param_2583
    .lex "$obj", param_2584
.annotate 'line', 1084
    new $P2585, "Integer"
    assign $P2585, 1
    find_lex $P2586, "self"
    get_global $P2587, "$?CLASS"
    setattribute $P2586, $P2587, "$!composed", $P2585
.annotate 'line', 1083
    .return ($P2585)
.end


.namespace ["NQPModuleHOW"]
.sub "name"  :subid("172_1298325424.79949") :outer("164_1298325424.79949")
    .param pmc param_2589
    .param pmc param_2590
.annotate 'line', 1087
    .lex "self", param_2589
    .lex "$obj", param_2590
    find_lex $P2591, "self"
    get_global $P2592, "$?CLASS"
    getattribute $P2593, $P2591, $P2592, "$!name"
    unless_null $P2593, vivify_428
    new $P2593, "Undef"
  vivify_428:
    .return ($P2593)
.end


.namespace ["NQPMu"]
.sub "_block2623"  :subid("174_1298325424.79949") :outer("10_1298325424.79949")
.annotate 'line', 1093
    .const 'Sub' $P2745 = "187_1298325424.79949" 
    capture_lex $P2745
    .const 'Sub' $P2735 = "186_1298325424.79949" 
    capture_lex $P2735
    .const 'Sub' $P2723 = "185_1298325424.79949" 
    capture_lex $P2723
    .const 'Sub' $P2719 = "184_1298325424.79949" 
    capture_lex $P2719
    .const 'Sub' $P2708 = "183_1298325424.79949" 
    capture_lex $P2708
    .const 'Sub' $P2705 = "182_1298325424.79949" 
    capture_lex $P2705
    .const 'Sub' $P2699 = "181_1298325424.79949" 
    capture_lex $P2699
    .const 'Sub' $P2661 = "179_1298325424.79949" 
    capture_lex $P2661
    .const 'Sub' $P2640 = "177_1298325424.79949" 
    capture_lex $P2640
    .const 'Sub' $P2630 = "176_1298325424.79949" 
    capture_lex $P2630
    .const 'Sub' $P2626 = "175_1298325424.79949" 
    capture_lex $P2626
    get_global $P2625, "$?CLASS"
.annotate 'line', 1135
    .const 'Sub' $P2735 = "186_1298325424.79949" 
    newclosure $P2743, $P2735
.annotate 'line', 1093
    .return ($P2743)
.end


.namespace ["NQPMu"]
.sub "" :load :init :subid("post429") :outer("174_1298325424.79949")
.annotate 'line', 1093
    get_hll_global $P2624, ["NQPMu"], "_block2623" 
    .local pmc block
    set block, $P2624
    .const 'Sub' $P2745 = "187_1298325424.79949" 
    capture_lex $P2745
    $P2745()
.end


.namespace ["NQPMu"]
.sub "_block2744"  :anon :subid("187_1298325424.79949") :outer("174_1298325424.79949")
.annotate 'line', 1093
    .const 'Sub' $P2762 = "182_1298325424.79949" 
    capture_lex $P2762
    get_hll_global $P2746, "NQPClassHOW"
    $P2747 = $P2746."new_type"("NQPMu" :named("name"))
    .local pmc type_obj
    set type_obj, $P2747
    set_hll_global "NQPMu", type_obj
    set_global "$?CLASS", type_obj
    get_how $P2748, type_obj
    .const 'Sub' $P2749 = "175_1298325424.79949" 
    $P2748."add_method"(type_obj, "CREATE", $P2749)
    get_how $P2750, type_obj
    .const 'Sub' $P2751 = "176_1298325424.79949" 
    $P2750."add_method"(type_obj, "bless", $P2751)
    get_how $P2752, type_obj
    .const 'Sub' $P2753 = "177_1298325424.79949" 
    $P2752."add_method"(type_obj, "BUILDALL", $P2753)
    get_how $P2754, type_obj
    .const 'Sub' $P2755 = "179_1298325424.79949" 
    $P2754."add_method"(type_obj, "BUILD_MAGIC", $P2755)
    get_how $P2756, type_obj
    .const 'Sub' $P2757 = "181_1298325424.79949" 
    $P2756."add_method"(type_obj, "new", $P2757)
    get_how $P2758, type_obj
    .const 'Sub' $P2759 = "182_1298325424.79949" 
    new $P2760, "ResizablePMCArray"
    set_dispatchees $P2759, $P2760
    $P2758."add_method"(type_obj, "Str", $P2759)
    get_how $P2761, type_obj
    .const 'Sub' $P2762 = "182_1298325424.79949" 
    newclosure $P2765, $P2762
    $P2761."add_parrot_vtable_mapping"(type_obj, "get_string", $P2765)
    get_how $P2766, type_obj
    .const 'Sub' $P2767 = "183_1298325424.79949" 
    $P2766."add_multi_method"(type_obj, "Str", $P2767)
    get_how $P2768, type_obj
    .const 'Sub' $P2769 = "184_1298325424.79949" 
    new $P2770, "ResizablePMCArray"
    set_dispatchees $P2769, $P2770
    $P2768."add_method"(type_obj, "ACCEPTS", $P2769)
    get_how $P2771, type_obj
    .const 'Sub' $P2772 = "185_1298325424.79949" 
    $P2771."add_multi_method"(type_obj, "ACCEPTS", $P2772)
    get_how $P2773, type_obj
    .const 'Sub' $P2774 = "186_1298325424.79949" 
    $P2773."add_method"(type_obj, "isa", $P2774)
    get_how $P2775, type_obj
    $P2776 = $P2775."compose"(type_obj)
    .return ($P2776)
.end


.namespace ["NQPMu"]
.sub "Str" :instanceof("DispatcherSub") :subid("182_1298325424.79949") :outer("187_1298325424.79949")
    .param pmc param_2763
.annotate 'line', 1093
    .lex "self", param_2763
    multi_dispatch_over_lexical_candidates $P2764
    .return ($P2764)
.end


.namespace ["NQPMu"]
.sub "CREATE"  :subid("175_1298325424.79949") :outer("174_1298325424.79949")
    .param pmc param_2627
.annotate 'line', 1094
    .lex "self", param_2627
.annotate 'line', 1095
    find_lex $P2628, "self"
    repr_instance_of $P2629, $P2628
.annotate 'line', 1094
    .return ($P2629)
.end


.namespace ["NQPMu"]
.sub "bless"  :subid("176_1298325424.79949") :outer("174_1298325424.79949")
    .param pmc param_2631
    .param pmc param_2633 :slurpy :named
.annotate 'line', 1099
    .lex "$self", param_2631
    find_lex $P2632, "$self"
    .lex "self", $P2632
    .lex "%attributes", param_2633
.annotate 'line', 1100
    new $P2634, "Undef"
    .lex "$instance", $P2634
    find_lex $P2635, "self"
    $P2636 = $P2635."CREATE"()
    store_lex "$instance", $P2636
.annotate 'line', 1101
    find_lex $P2637, "$instance"
    find_lex $P2638, "%attributes"
    $P2637."BUILDALL"($P2638 :flat)
    find_lex $P2639, "$instance"
.annotate 'line', 1099
    .return ($P2639)
.end


.namespace ["NQPMu"]
.include "except_types.pasm"
.sub "BUILDALL"  :subid("177_1298325424.79949") :outer("174_1298325424.79949")
    .param pmc param_2641
    .param pmc param_2643 :slurpy :named
.annotate 'line', 1105
    .const 'Sub' $P2652 = "178_1298325424.79949" 
    capture_lex $P2652
    .lex "$self", param_2641
    find_lex $P2642, "$self"
    .lex "self", $P2642
    .lex "%attributes", param_2643
.annotate 'line', 1106
    find_lex $P2645, "$self"
    get_how $P2646, $P2645
    find_lex $P2647, "$self"
    $P2648 = $P2646."parents"($P2647)
    defined $I2649, $P2648
    unless $I2649, for_undef_430
    iter $P2644, $P2648
    new $P2659, 'ExceptionHandler'
    set_label $P2659, loop2658_handler
    $P2659."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2659
  loop2658_test:
    unless $P2644, loop2658_done
    shift $P2650, $P2644
  loop2658_redo:
    .const 'Sub' $P2652 = "178_1298325424.79949" 
    capture_lex $P2652
    $P2652($P2650)
  loop2658_next:
    goto loop2658_test
  loop2658_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2660, exception, 'type'
    eq $P2660, .CONTROL_LOOP_NEXT, loop2658_next
    eq $P2660, .CONTROL_LOOP_REDO, loop2658_redo
  loop2658_done:
    pop_eh 
  for_undef_430:
.annotate 'line', 1105
    .return ($P2644)
.end


.namespace ["NQPMu"]
.sub "_block2651"  :anon :subid("178_1298325424.79949") :outer("177_1298325424.79949")
    .param pmc param_2653
.annotate 'line', 1106
    .lex "$class", param_2653
.annotate 'line', 1107
    find_lex $P2654, "$self"
    find_lex $P2655, "$class"
    find_lex $P2656, "%attributes"
    $P2657 = $P2654."BUILD_MAGIC"($P2655, $P2656 :flat)
.annotate 'line', 1106
    .return ($P2657)
.end


.namespace ["NQPMu"]
.include "except_types.pasm"
.sub "BUILD_MAGIC"  :subid("179_1298325424.79949") :outer("174_1298325424.79949")
    .param pmc param_2662
    .param pmc param_2664
    .param pmc param_2665 :slurpy :named
.annotate 'line', 1111
    .const 'Sub' $P2674 = "180_1298325424.79949" 
    capture_lex $P2674
    .lex "$self", param_2662
    find_lex $P2663, "$self"
    .lex "self", $P2663
    .lex "$type", param_2664
    .lex "%attributes", param_2665
.annotate 'line', 1112
    find_lex $P2667, "$type"
    get_how $P2668, $P2667
    find_lex $P2669, "$type"
    $P2670 = $P2668."attributes"($P2669, 1 :named("local"))
    defined $I2671, $P2670
    unless $I2671, for_undef_431
    iter $P2666, $P2670
    new $P2697, 'ExceptionHandler'
    set_label $P2697, loop2696_handler
    $P2697."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2697
  loop2696_test:
    unless $P2666, loop2696_done
    shift $P2672, $P2666
  loop2696_redo:
    .const 'Sub' $P2674 = "180_1298325424.79949" 
    capture_lex $P2674
    $P2674($P2672)
  loop2696_next:
    goto loop2696_test
  loop2696_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2698, exception, 'type'
    eq $P2698, .CONTROL_LOOP_NEXT, loop2696_next
    eq $P2698, .CONTROL_LOOP_REDO, loop2696_redo
  loop2696_done:
    pop_eh 
  for_undef_431:
.annotate 'line', 1111
    .return ($P2666)
.end


.namespace ["NQPMu"]
.sub "_block2673"  :anon :subid("180_1298325424.79949") :outer("179_1298325424.79949")
    .param pmc param_2677
.annotate 'line', 1113
    new $P2675, "Undef"
    .lex "$name", $P2675
.annotate 'line', 1114
    new $P2676, "Undef"
    .lex "$shortname", $P2676
    .lex "$_", param_2677
.annotate 'line', 1113
    find_lex $P2678, "$_"
    $P2679 = $P2678."name"()
    store_lex "$name", $P2679
.annotate 'line', 1114
    find_lex $P2680, "$name"
    set $S2681, $P2680
    substr $S2682, $S2681, 2
    new $P2683, 'String'
    set $P2683, $S2682
    store_lex "$shortname", $P2683
.annotate 'line', 1115
    find_lex $P2687, "$shortname"
    find_lex $P2686, "%attributes"
    exists $I2688, $P2686[$P2687]
    if $I2688, if_2685
    new $P2684, 'Integer'
    set $P2684, $I2688
    goto if_2685_end
  if_2685:
.annotate 'line', 1116
    find_lex $P2689, "$self"
    find_lex $P2690, "$type"
    find_lex $P2691, "$name"
    set $S2692, $P2691
    find_lex $P2693, "$shortname"
    find_lex $P2694, "%attributes"
    unless_null $P2694, vivify_432
    $P2694 = root_new ['parrot';'Hash']
  vivify_432:
    set $P2695, $P2694[$P2693]
    unless_null $P2695, vivify_433
    new $P2695, "Undef"
  vivify_433:
    setattribute $P2689, $P2690, $S2692, $P2695
  if_2685_end:
.annotate 'line', 1112
    .return ($P2684)
.end


.namespace ["NQPMu"]
.sub "new"  :subid("181_1298325424.79949") :outer("174_1298325424.79949")
    .param pmc param_2700
    .param pmc param_2701 :slurpy :named
.annotate 'line', 1121
    .lex "self", param_2700
    .lex "%attributes", param_2701
.annotate 'line', 1122
    find_lex $P2702, "self"
    find_lex $P2703, "%attributes"
    $P2704 = $P2702."bless"($P2703 :flat)
.annotate 'line', 1121
    .return ($P2704)
.end


.namespace ["NQPMu"]
.sub "Str" :instanceof("DispatcherSub") :subid("182_1298325424.79949") :outer("174_1298325424.79949")
    .param pmc param_2706
.annotate 'line', 1121
    .lex "self", param_2706
    multi_dispatch_over_lexical_candidates $P2707
    .return ($P2707)
.end


.namespace ["NQPMu"]
.sub "Str"  :subid("183_1298325424.79949") :outer("174_1298325424.79949")
    .param pmc param_2709
.annotate 'line', 1126
    .lex "$self", param_2709
    find_lex $P2710, "$self"
    .lex "self", $P2710
.annotate 'line', 1127
    find_lex $P2711, "self"
    get_how $P2712, $P2711
    find_lex $P2713, "self"
    $P2714 = $P2712."name"($P2713)
    concat $P2715, $P2714, "()"
.annotate 'line', 1126
    .return ($P2715)
.end


.namespace ["NQPMu"]
.sub "" :load :init :subid("post434") :outer("183_1298325424.79949")
.annotate 'line', 1126
    .const 'Sub' $P2708 = "183_1298325424.79949" 
    .local pmc block
    set block, $P2708
    get_hll_global $P2716, "Mu"
    new $P2717, "ResizablePMCArray"
    push $P2717, $P2716
    new $P2718, "ResizablePMCArray"
    push $P2718, 2
    set_sub_multisig block, $P2717, $P2718
.end


.namespace ["NQPMu"]
.sub "ACCEPTS" :instanceof("DispatcherSub") :subid("184_1298325424.79949") :outer("174_1298325424.79949")
    .param pmc param_2720
    .param pmc param_2721
.annotate 'line', 1126
    .lex "self", param_2720
.annotate 'line', 1130
    .lex "$topic", param_2721
.annotate 'line', 1126
    multi_dispatch_over_lexical_candidates $P2722
    .return ($P2722)
.end


.namespace ["NQPMu"]
.sub "ACCEPTS"  :subid("185_1298325424.79949") :outer("174_1298325424.79949")
    .param pmc param_2724
    .param pmc param_2726
.annotate 'line', 1131
    .lex "$self", param_2724
    find_lex $P2725, "$self"
    .lex "self", $P2725
    .lex "$topic", param_2726
.annotate 'line', 1132
    find_lex $P2727, "$topic"
    find_lex $P2728, "self"
    get_what $P2729, $P2728
    type_check $I2730, $P2727, $P2729
.annotate 'line', 1131
    .return ($I2730)
.end


.namespace ["NQPMu"]
.sub "" :load :init :subid("post435") :outer("185_1298325424.79949")
.annotate 'line', 1131
    .const 'Sub' $P2723 = "185_1298325424.79949" 
    .local pmc block
    set block, $P2723
    get_hll_global $P2731, "NQPMu"
    null $P2732
    new $P2733, "ResizablePMCArray"
    push $P2733, $P2731
    push $P2733, $P2732
    new $P2734, "ResizablePMCArray"
    push $P2734, 2
    push $P2734, 0
    set_sub_multisig block, $P2733, $P2734
.end


.namespace ["NQPMu"]
.sub "isa"  :subid("186_1298325424.79949") :outer("174_1298325424.79949")
    .param pmc param_2736
    .param pmc param_2737
.annotate 'line', 1135
    .lex "self", param_2736
    .lex "$type", param_2737
.annotate 'line', 1136
    find_lex $P2738, "self"
    get_how $P2739, $P2738
    find_lex $P2740, "self"
    find_lex $P2741, "$type"
    $P2742 = $P2739."isa"($P2740, $P2741)
.annotate 'line', 1135
    .return ($P2742)
.end


.namespace ["int"]
.sub "_block2777"  :subid("188_1298325424.79949") :outer("10_1298325424.79949")
.annotate 'line', 1142
    .const 'Sub' $P2781 = "189_1298325424.79949" 
    capture_lex $P2781
    get_global $P2779, "$?CLASS"
    .return ()
.end


.namespace ["int"]
.sub "" :load :init :subid("post436") :outer("188_1298325424.79949")
.annotate 'line', 1142
    get_hll_global $P2778, ["int"], "_block2777" 
    .local pmc block
    set block, $P2778
    .const 'Sub' $P2781 = "189_1298325424.79949" 
    capture_lex $P2781
    $P2781()
.end


.namespace ["int"]
.sub "_block2780"  :anon :subid("189_1298325424.79949") :outer("188_1298325424.79949")
.annotate 'line', 1142
    get_hll_global $P2782, "NQPNativeHOW"
    $P2783 = $P2782."new_type"("int" :named("name"), "P6int" :named("repr"))
    .local pmc type_obj
    set type_obj, $P2783
    set_hll_global "int", type_obj
    set_global "$?CLASS", type_obj
    get_how $P2784, type_obj
    $P2785 = $P2784."compose"(type_obj)
    .return ($P2785)
.end


.namespace ["num"]
.sub "_block2786"  :subid("190_1298325424.79949") :outer("10_1298325424.79949")
.annotate 'line', 1144
    .const 'Sub' $P2790 = "191_1298325424.79949" 
    capture_lex $P2790
    get_global $P2788, "$?CLASS"
    .return ()
.end


.namespace ["num"]
.sub "" :load :init :subid("post437") :outer("190_1298325424.79949")
.annotate 'line', 1144
    get_hll_global $P2787, ["num"], "_block2786" 
    .local pmc block
    set block, $P2787
    .const 'Sub' $P2790 = "191_1298325424.79949" 
    capture_lex $P2790
    $P2790()
.end


.namespace ["num"]
.sub "_block2789"  :anon :subid("191_1298325424.79949") :outer("190_1298325424.79949")
.annotate 'line', 1144
    get_hll_global $P2791, "NQPNativeHOW"
    $P2792 = $P2791."new_type"("num" :named("name"), "P6num" :named("repr"))
    .local pmc type_obj
    set type_obj, $P2792
    set_hll_global "num", type_obj
    set_global "$?CLASS", type_obj
    get_how $P2793, type_obj
    $P2794 = $P2793."compose"(type_obj)
    .return ($P2794)
.end


.namespace ["str"]
.sub "_block2795"  :subid("192_1298325424.79949") :outer("10_1298325424.79949")
.annotate 'line', 1146
    .const 'Sub' $P2799 = "193_1298325424.79949" 
    capture_lex $P2799
    get_global $P2797, "$?CLASS"
    .return ()
.end


.namespace ["str"]
.sub "" :load :init :subid("post438") :outer("192_1298325424.79949")
.annotate 'line', 1146
    get_hll_global $P2796, ["str"], "_block2795" 
    .local pmc block
    set block, $P2796
    .const 'Sub' $P2799 = "193_1298325424.79949" 
    capture_lex $P2799
    $P2799()
.end


.namespace ["str"]
.sub "_block2798"  :anon :subid("193_1298325424.79949") :outer("192_1298325424.79949")
.annotate 'line', 1146
    get_hll_global $P2800, "NQPNativeHOW"
    $P2801 = $P2800."new_type"("str" :named("name"), "P6str" :named("repr"))
    .local pmc type_obj
    set type_obj, $P2801
    set_hll_global "str", type_obj
    set_global "$?CLASS", type_obj
    get_how $P2802, type_obj
    $P2803 = $P2802."compose"(type_obj)
    .return ($P2803)
.end


.namespace []
.sub "_block2805" :load :anon :subid("194_1298325424.79949")
.annotate 'line', 1
    .const 'Sub' $P2807 = "10_1298325424.79949" 
    $P2808 = $P2807()
    .return ($P2808)
.end


.sub '' :anon :load :init
    load_bytecode 'P6Regex.pbc'
.end

### .include 'gen/nqp-grammar.pir'

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1298325448.42642")
.annotate 'line', 0
    get_hll_global $P15, ["NQP";"Grammar"], "_block14" 
    capture_lex $P15
.annotate 'line', 1
    nqp_dynop_setup 
    get_hll_global $P13, ["NQP"], "Grammar"
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
.annotate 'line', 4
    get_hll_global $P15, ["NQP";"Grammar"], "_block14" 
    capture_lex $P15
    $P2418 = $P15()
.annotate 'line', 1
    .return ($P2418)
    .const 'Sub' $P2420 = "400_1298325448.42642" 
    .return ($P2420)
.end


.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace ["NQP";"Grammar"]
.sub "_block14"  :subid("11_1298325448.42642") :outer("10_1298325448.42642")
.annotate 'line', 4
    .const 'Sub' $P1707 = "399_1298325448.42642" 
    capture_lex $P1707
    get_hll_global $P1598, ["NQP";"Regex"], "_block1597" 
    capture_lex $P1598
    .const 'Sub' $P1586 = "375_1298325448.42642" 
    capture_lex $P1586
    .const 'Sub' $P1580 = "373_1298325448.42642" 
    capture_lex $P1580
    .const 'Sub' $P1574 = "371_1298325448.42642" 
    capture_lex $P1574
    .const 'Sub' $P1568 = "369_1298325448.42642" 
    capture_lex $P1568
    .const 'Sub' $P1562 = "367_1298325448.42642" 
    capture_lex $P1562
    .const 'Sub' $P1550 = "364_1298325448.42642" 
    capture_lex $P1550
    .const 'Sub' $P1543 = "362_1298325448.42642" 
    capture_lex $P1543
    .const 'Sub' $P1536 = "360_1298325448.42642" 
    capture_lex $P1536
    .const 'Sub' $P1529 = "358_1298325448.42642" 
    capture_lex $P1529
    .const 'Sub' $P1522 = "356_1298325448.42642" 
    capture_lex $P1522
    .const 'Sub' $P1516 = "354_1298325448.42642" 
    capture_lex $P1516
    .const 'Sub' $P1509 = "352_1298325448.42642" 
    capture_lex $P1509
    .const 'Sub' $P1502 = "350_1298325448.42642" 
    capture_lex $P1502
    .const 'Sub' $P1495 = "348_1298325448.42642" 
    capture_lex $P1495
    .const 'Sub' $P1488 = "346_1298325448.42642" 
    capture_lex $P1488
    .const 'Sub' $P1481 = "344_1298325448.42642" 
    capture_lex $P1481
    .const 'Sub' $P1474 = "342_1298325448.42642" 
    capture_lex $P1474
    .const 'Sub' $P1467 = "340_1298325448.42642" 
    capture_lex $P1467
    .const 'Sub' $P1460 = "338_1298325448.42642" 
    capture_lex $P1460
    .const 'Sub' $P1453 = "336_1298325448.42642" 
    capture_lex $P1453
    .const 'Sub' $P1446 = "334_1298325448.42642" 
    capture_lex $P1446
    .const 'Sub' $P1439 = "332_1298325448.42642" 
    capture_lex $P1439
    .const 'Sub' $P1432 = "330_1298325448.42642" 
    capture_lex $P1432
    .const 'Sub' $P1425 = "328_1298325448.42642" 
    capture_lex $P1425
    .const 'Sub' $P1418 = "326_1298325448.42642" 
    capture_lex $P1418
    .const 'Sub' $P1411 = "324_1298325448.42642" 
    capture_lex $P1411
    .const 'Sub' $P1404 = "322_1298325448.42642" 
    capture_lex $P1404
    .const 'Sub' $P1397 = "320_1298325448.42642" 
    capture_lex $P1397
    .const 'Sub' $P1390 = "318_1298325448.42642" 
    capture_lex $P1390
    .const 'Sub' $P1383 = "316_1298325448.42642" 
    capture_lex $P1383
    .const 'Sub' $P1376 = "314_1298325448.42642" 
    capture_lex $P1376
    .const 'Sub' $P1369 = "312_1298325448.42642" 
    capture_lex $P1369
    .const 'Sub' $P1362 = "310_1298325448.42642" 
    capture_lex $P1362
    .const 'Sub' $P1355 = "308_1298325448.42642" 
    capture_lex $P1355
    .const 'Sub' $P1348 = "306_1298325448.42642" 
    capture_lex $P1348
    .const 'Sub' $P1341 = "304_1298325448.42642" 
    capture_lex $P1341
    .const 'Sub' $P1334 = "302_1298325448.42642" 
    capture_lex $P1334
    .const 'Sub' $P1327 = "300_1298325448.42642" 
    capture_lex $P1327
    .const 'Sub' $P1320 = "298_1298325448.42642" 
    capture_lex $P1320
    .const 'Sub' $P1313 = "296_1298325448.42642" 
    capture_lex $P1313
    .const 'Sub' $P1307 = "294_1298325448.42642" 
    capture_lex $P1307
    .const 'Sub' $P1300 = "292_1298325448.42642" 
    capture_lex $P1300
    .const 'Sub' $P1293 = "290_1298325448.42642" 
    capture_lex $P1293
    .const 'Sub' $P1286 = "288_1298325448.42642" 
    capture_lex $P1286
    .const 'Sub' $P1279 = "286_1298325448.42642" 
    capture_lex $P1279
    .const 'Sub' $P1272 = "284_1298325448.42642" 
    capture_lex $P1272
    .const 'Sub' $P1265 = "282_1298325448.42642" 
    capture_lex $P1265
    .const 'Sub' $P1258 = "280_1298325448.42642" 
    capture_lex $P1258
    .const 'Sub' $P1252 = "278_1298325448.42642" 
    capture_lex $P1252
    .const 'Sub' $P1246 = "276_1298325448.42642" 
    capture_lex $P1246
    .const 'Sub' $P1241 = "274_1298325448.42642" 
    capture_lex $P1241
    .const 'Sub' $P1235 = "272_1298325448.42642" 
    capture_lex $P1235
    .const 'Sub' $P1229 = "270_1298325448.42642" 
    capture_lex $P1229
    .const 'Sub' $P1224 = "268_1298325448.42642" 
    capture_lex $P1224
    .const 'Sub' $P1219 = "266_1298325448.42642" 
    capture_lex $P1219
    .const 'Sub' $P1203 = "265_1298325448.42642" 
    capture_lex $P1203
    .const 'Sub' $P1194 = "263_1298325448.42642" 
    capture_lex $P1194
    .const 'Sub' $P1185 = "261_1298325448.42642" 
    capture_lex $P1185
    .const 'Sub' $P1180 = "259_1298325448.42642" 
    capture_lex $P1180
    .const 'Sub' $P1175 = "257_1298325448.42642" 
    capture_lex $P1175
    .const 'Sub' $P1170 = "255_1298325448.42642" 
    capture_lex $P1170
    .const 'Sub' $P1162 = "253_1298325448.42642" 
    capture_lex $P1162
    .const 'Sub' $P1154 = "251_1298325448.42642" 
    capture_lex $P1154
    .const 'Sub' $P1149 = "249_1298325448.42642" 
    capture_lex $P1149
    .const 'Sub' $P1144 = "247_1298325448.42642" 
    capture_lex $P1144
    .const 'Sub' $P1139 = "245_1298325448.42642" 
    capture_lex $P1139
    .const 'Sub' $P1133 = "243_1298325448.42642" 
    capture_lex $P1133
    .const 'Sub' $P1127 = "241_1298325448.42642" 
    capture_lex $P1127
    .const 'Sub' $P1121 = "239_1298325448.42642" 
    capture_lex $P1121
    .const 'Sub' $P1115 = "237_1298325448.42642" 
    capture_lex $P1115
    .const 'Sub' $P1109 = "235_1298325448.42642" 
    capture_lex $P1109
    .const 'Sub' $P1104 = "233_1298325448.42642" 
    capture_lex $P1104
    .const 'Sub' $P1099 = "231_1298325448.42642" 
    capture_lex $P1099
    .const 'Sub' $P1085 = "227_1298325448.42642" 
    capture_lex $P1085
    .const 'Sub' $P1077 = "225_1298325448.42642" 
    capture_lex $P1077
    .const 'Sub' $P1071 = "223_1298325448.42642" 
    capture_lex $P1071
    .const 'Sub' $P1064 = "221_1298325448.42642" 
    capture_lex $P1064
    .const 'Sub' $P1058 = "219_1298325448.42642" 
    capture_lex $P1058
    .const 'Sub' $P1044 = "216_1298325448.42642" 
    capture_lex $P1044
    .const 'Sub' $P1036 = "214_1298325448.42642" 
    capture_lex $P1036
    .const 'Sub' $P1028 = "212_1298325448.42642" 
    capture_lex $P1028
    .const 'Sub' $P1022 = "210_1298325448.42642" 
    capture_lex $P1022
    .const 'Sub' $P1016 = "208_1298325448.42642" 
    capture_lex $P1016
    .const 'Sub' $P1000 = "204_1298325448.42642" 
    capture_lex $P1000
    .const 'Sub' $P959 = "202_1298325448.42642" 
    capture_lex $P959
    .const 'Sub' $P948 = "200_1298325448.42642" 
    capture_lex $P948
    .const 'Sub' $P934 = "196_1298325448.42642" 
    capture_lex $P934
    .const 'Sub' $P925 = "194_1298325448.42642" 
    capture_lex $P925
    .const 'Sub' $P919 = "192_1298325448.42642" 
    capture_lex $P919
    .const 'Sub' $P909 = "190_1298325448.42642" 
    capture_lex $P909
    .const 'Sub' $P894 = "188_1298325448.42642" 
    capture_lex $P894
    .const 'Sub' $P880 = "185_1298325448.42642" 
    capture_lex $P880
    .const 'Sub' $P872 = "183_1298325448.42642" 
    capture_lex $P872
    .const 'Sub' $P862 = "181_1298325448.42642" 
    capture_lex $P862
    .const 'Sub' $P852 = "179_1298325448.42642" 
    capture_lex $P852
    .const 'Sub' $P833 = "174_1298325448.42642" 
    capture_lex $P833
    .const 'Sub' $P789 = "171_1298325448.42642" 
    capture_lex $P789
    .const 'Sub' $P755 = "169_1298325448.42642" 
    capture_lex $P755
    .const 'Sub' $P748 = "167_1298325448.42642" 
    capture_lex $P748
    .const 'Sub' $P741 = "165_1298325448.42642" 
    capture_lex $P741
    .const 'Sub' $P724 = "161_1298325448.42642" 
    capture_lex $P724
    .const 'Sub' $P716 = "159_1298325448.42642" 
    capture_lex $P716
    .const 'Sub' $P710 = "157_1298325448.42642" 
    capture_lex $P710
    .const 'Sub' $P697 = "155_1298325448.42642" 
    capture_lex $P697
    .const 'Sub' $P690 = "153_1298325448.42642" 
    capture_lex $P690
    .const 'Sub' $P683 = "151_1298325448.42642" 
    capture_lex $P683
    .const 'Sub' $P676 = "149_1298325448.42642" 
    capture_lex $P676
    .const 'Sub' $P635 = "145_1298325448.42642" 
    capture_lex $P635
    .const 'Sub' $P623 = "143_1298325448.42642" 
    capture_lex $P623
    .const 'Sub' $P611 = "141_1298325448.42642" 
    capture_lex $P611
    .const 'Sub' $P599 = "139_1298325448.42642" 
    capture_lex $P599
    .const 'Sub' $P587 = "137_1298325448.42642" 
    capture_lex $P587
    .const 'Sub' $P575 = "135_1298325448.42642" 
    capture_lex $P575
    .const 'Sub' $P563 = "133_1298325448.42642" 
    capture_lex $P563
    .const 'Sub' $P552 = "129_1298325448.42642" 
    capture_lex $P552
    .const 'Sub' $P547 = "127_1298325448.42642" 
    capture_lex $P547
    .const 'Sub' $P535 = "125_1298325448.42642" 
    capture_lex $P535
    .const 'Sub' $P523 = "123_1298325448.42642" 
    capture_lex $P523
    .const 'Sub' $P516 = "121_1298325448.42642" 
    capture_lex $P516
    .const 'Sub' $P511 = "119_1298325448.42642" 
    capture_lex $P511
    .const 'Sub' $P505 = "117_1298325448.42642" 
    capture_lex $P505
    .const 'Sub' $P499 = "115_1298325448.42642" 
    capture_lex $P499
    .const 'Sub' $P484 = "111_1298325448.42642" 
    capture_lex $P484
    .const 'Sub' $P478 = "109_1298325448.42642" 
    capture_lex $P478
    .const 'Sub' $P472 = "107_1298325448.42642" 
    capture_lex $P472
    .const 'Sub' $P466 = "105_1298325448.42642" 
    capture_lex $P466
    .const 'Sub' $P460 = "103_1298325448.42642" 
    capture_lex $P460
    .const 'Sub' $P454 = "101_1298325448.42642" 
    capture_lex $P454
    .const 'Sub' $P448 = "99_1298325448.42642" 
    capture_lex $P448
    .const 'Sub' $P439 = "97_1298325448.42642" 
    capture_lex $P439
    .const 'Sub' $P430 = "95_1298325448.42642" 
    capture_lex $P430
    .const 'Sub' $P421 = "93_1298325448.42642" 
    capture_lex $P421
    .const 'Sub' $P406 = "89_1298325448.42642" 
    capture_lex $P406
    .const 'Sub' $P397 = "87_1298325448.42642" 
    capture_lex $P397
    .const 'Sub' $P385 = "83_1298325448.42642" 
    capture_lex $P385
    .const 'Sub' $P378 = "81_1298325448.42642" 
    capture_lex $P378
    .const 'Sub' $P371 = "79_1298325448.42642" 
    capture_lex $P371
    .const 'Sub' $P357 = "75_1298325448.42642" 
    capture_lex $P357
    .const 'Sub' $P349 = "73_1298325448.42642" 
    capture_lex $P349
    .const 'Sub' $P341 = "71_1298325448.42642" 
    capture_lex $P341
    .const 'Sub' $P321 = "69_1298325448.42642" 
    capture_lex $P321
    .const 'Sub' $P312 = "67_1298325448.42642" 
    capture_lex $P312
    .const 'Sub' $P294 = "64_1298325448.42642" 
    capture_lex $P294
    .const 'Sub' $P276 = "62_1298325448.42642" 
    capture_lex $P276
    .const 'Sub' $P265 = "58_1298325448.42642" 
    capture_lex $P265
    .const 'Sub' $P260 = "56_1298325448.42642" 
    capture_lex $P260
    .const 'Sub' $P249 = "52_1298325448.42642" 
    capture_lex $P249
    .const 'Sub' $P244 = "50_1298325448.42642" 
    capture_lex $P244
    .const 'Sub' $P239 = "48_1298325448.42642" 
    capture_lex $P239
    .const 'Sub' $P230 = "46_1298325448.42642" 
    capture_lex $P230
    .const 'Sub' $P223 = "44_1298325448.42642" 
    capture_lex $P223
    .const 'Sub' $P217 = "42_1298325448.42642" 
    capture_lex $P217
    .const 'Sub' $P209 = "40_1298325448.42642" 
    capture_lex $P209
    .const 'Sub' $P203 = "38_1298325448.42642" 
    capture_lex $P203
    .const 'Sub' $P197 = "36_1298325448.42642" 
    capture_lex $P197
    .const 'Sub' $P182 = "33_1298325448.42642" 
    capture_lex $P182
    .const 'Sub' $P168 = "31_1298325448.42642" 
    capture_lex $P168
    .const 'Sub' $P161 = "29_1298325448.42642" 
    capture_lex $P161
    .const 'Sub' $P122 = "26_1298325448.42642" 
    capture_lex $P122
    .const 'Sub' $P107 = "23_1298325448.42642" 
    capture_lex $P107
    .const 'Sub' $P96 = "21_1298325448.42642" 
    capture_lex $P96
    .const 'Sub' $P84 = "19_1298325448.42642" 
    capture_lex $P84
    .const 'Sub' $P76 = "17_1298325448.42642" 
    capture_lex $P76
    .const 'Sub' $P69 = "15_1298325448.42642" 
    capture_lex $P69
    .const 'Sub' $P62 = "13_1298325448.42642" 
    capture_lex $P62
    .const 'Sub' $P18 = "12_1298325448.42642" 
    capture_lex $P18
    get_global $P16, "$?CLASS"
    nqp_dynop_setup 
    get_hll_global $P17, ["NQP"], "Regex"
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
    .const 'Sub' $P1203 = "265_1298325448.42642" 
    capture_lex $P1203
    $P1203()
.annotate 'line', 658
    get_hll_global $P1598, ["NQP";"Regex"], "_block1597" 
    capture_lex $P1598
    $P1701 = $P1598()
.annotate 'line', 4
    .return ($P1701)
    .const 'Sub' $P1703 = "398_1298325448.42642" 
    .return ($P1703)
.end


.namespace ["NQP";"Grammar"]
.sub "" :load :init :subid("post401") :outer("11_1298325448.42642")
.annotate 'line', 4
    get_hll_global $P15, ["NQP";"Grammar"], "_block14" 
    .local pmc block
    set block, $P15
    .const 'Sub' $P1707 = "399_1298325448.42642" 
    capture_lex $P1707
    $P1707()
.end


.namespace ["NQP";"Grammar"]
.sub "_block1706"  :anon :subid("399_1298325448.42642") :outer("11_1298325448.42642")
.annotate 'line', 4
    get_hll_global $P1708, "NQPClassHOW"
    $P1709 = $P1708."new_type"("Grammar" :named("name"))
    .local pmc type_obj
    set type_obj, $P1709
    set_hll_global ["NQP"], "Grammar", type_obj
    set_global "$?CLASS", type_obj
    get_how $P1710, type_obj
    .const 'Sub' $P1711 = "12_1298325448.42642" 
    $P1710."add_method"(type_obj, "TOP", $P1711)
    get_how $P1712, type_obj
    .const 'Sub' $P1713 = "13_1298325448.42642" 
    $P1712."add_method"(type_obj, "identifier", $P1713)
    get_how $P1714, type_obj
    get_global $P1715, "!PREFIX__identifier"
    $P1714."add_method"(type_obj, "!PREFIX__identifier", $P1715)
    get_how $P1716, type_obj
    .const 'Sub' $P1717 = "15_1298325448.42642" 
    $P1716."add_method"(type_obj, "name", $P1717)
    get_how $P1718, type_obj
    get_global $P1719, "!PREFIX__name"
    $P1718."add_method"(type_obj, "!PREFIX__name", $P1719)
    get_how $P1720, type_obj
    .const 'Sub' $P1721 = "17_1298325448.42642" 
    $P1720."add_method"(type_obj, "deflongname", $P1721)
    get_how $P1722, type_obj
    get_global $P1723, "!PREFIX__deflongname"
    $P1722."add_method"(type_obj, "!PREFIX__deflongname", $P1723)
    get_how $P1724, type_obj
    .const 'Sub' $P1725 = "19_1298325448.42642" 
    $P1724."add_method"(type_obj, "ENDSTMT", $P1725)
    get_how $P1726, type_obj
    get_global $P1727, "!PREFIX__ENDSTMT"
    $P1726."add_method"(type_obj, "!PREFIX__ENDSTMT", $P1727)
    get_how $P1728, type_obj
    .const 'Sub' $P1729 = "21_1298325448.42642" 
    $P1728."add_method"(type_obj, "ws", $P1729)
    get_how $P1730, type_obj
    get_global $P1731, "!PREFIX__ws"
    $P1730."add_method"(type_obj, "!PREFIX__ws", $P1731)
    get_how $P1732, type_obj
    .const 'Sub' $P1733 = "23_1298325448.42642" 
    $P1732."add_method"(type_obj, "unv", $P1733)
    get_how $P1734, type_obj
    get_global $P1735, "!PREFIX__unv"
    $P1734."add_method"(type_obj, "!PREFIX__unv", $P1735)
    get_how $P1736, type_obj
    .const 'Sub' $P1737 = "26_1298325448.42642" 
    $P1736."add_method"(type_obj, "pod_comment", $P1737)
    get_how $P1738, type_obj
    get_global $P1739, "!PREFIX__pod_comment"
    $P1738."add_method"(type_obj, "!PREFIX__pod_comment", $P1739)
    get_how $P1740, type_obj
    .const 'Sub' $P1741 = "29_1298325448.42642" 
    $P1740."add_method"(type_obj, "comp_unit", $P1741)
    get_how $P1742, type_obj
    get_global $P1743, "!PREFIX__comp_unit"
    $P1742."add_method"(type_obj, "!PREFIX__comp_unit", $P1743)
    get_how $P1744, type_obj
    .const 'Sub' $P1745 = "31_1298325448.42642" 
    $P1744."add_method"(type_obj, "statementlist", $P1745)
    get_how $P1746, type_obj
    get_global $P1747, "!PREFIX__statementlist"
    $P1746."add_method"(type_obj, "!PREFIX__statementlist", $P1747)
    get_how $P1748, type_obj
    .const 'Sub' $P1749 = "33_1298325448.42642" 
    $P1748."add_method"(type_obj, "statement", $P1749)
    get_how $P1750, type_obj
    get_global $P1751, "!PREFIX__statement"
    $P1750."add_method"(type_obj, "!PREFIX__statement", $P1751)
    get_how $P1752, type_obj
    .const 'Sub' $P1753 = "36_1298325448.42642" 
    $P1752."add_method"(type_obj, "eat_terminator", $P1753)
    get_how $P1754, type_obj
    get_global $P1755, "!PREFIX__eat_terminator"
    $P1754."add_method"(type_obj, "!PREFIX__eat_terminator", $P1755)
    get_how $P1756, type_obj
    .const 'Sub' $P1757 = "38_1298325448.42642" 
    $P1756."add_method"(type_obj, "xblock", $P1757)
    get_how $P1758, type_obj
    get_global $P1759, "!PREFIX__xblock"
    $P1758."add_method"(type_obj, "!PREFIX__xblock", $P1759)
    get_how $P1760, type_obj
    .const 'Sub' $P1761 = "40_1298325448.42642" 
    $P1760."add_method"(type_obj, "pblock", $P1761)
    get_how $P1762, type_obj
    get_global $P1763, "!PREFIX__pblock"
    $P1762."add_method"(type_obj, "!PREFIX__pblock", $P1763)
    get_how $P1764, type_obj
    .const 'Sub' $P1765 = "42_1298325448.42642" 
    $P1764."add_method"(type_obj, "lambda", $P1765)
    get_how $P1766, type_obj
    get_global $P1767, "!PREFIX__lambda"
    $P1766."add_method"(type_obj, "!PREFIX__lambda", $P1767)
    get_how $P1768, type_obj
    .const 'Sub' $P1769 = "44_1298325448.42642" 
    $P1768."add_method"(type_obj, "block", $P1769)
    get_how $P1770, type_obj
    get_global $P1771, "!PREFIX__block"
    $P1770."add_method"(type_obj, "!PREFIX__block", $P1771)
    get_how $P1772, type_obj
    .const 'Sub' $P1773 = "46_1298325448.42642" 
    $P1772."add_method"(type_obj, "blockoid", $P1773)
    get_how $P1774, type_obj
    get_global $P1775, "!PREFIX__blockoid"
    $P1774."add_method"(type_obj, "!PREFIX__blockoid", $P1775)
    get_how $P1776, type_obj
    .const 'Sub' $P1777 = "48_1298325448.42642" 
    $P1776."add_method"(type_obj, "newpad", $P1777)
    get_how $P1778, type_obj
    get_global $P1779, "!PREFIX__newpad"
    $P1778."add_method"(type_obj, "!PREFIX__newpad", $P1779)
    get_how $P1780, type_obj
    .const 'Sub' $P1781 = "50_1298325448.42642" 
    $P1780."add_method"(type_obj, "outerctx", $P1781)
    get_how $P1782, type_obj
    get_global $P1783, "!PREFIX__outerctx"
    $P1782."add_method"(type_obj, "!PREFIX__outerctx", $P1783)
    get_how $P1784, type_obj
    .const 'Sub' $P1785 = "52_1298325448.42642" 
    $P1784."add_method"(type_obj, "finishpad", $P1785)
    get_how $P1786, type_obj
    get_global $P1787, "!PREFIX__finishpad"
    $P1786."add_method"(type_obj, "!PREFIX__finishpad", $P1787)
    get_how $P1788, type_obj
    .const 'Sub' $P1789 = "54_1298325448.42642" 
    $P1788."add_method"(type_obj, "terminator", $P1789)
    get_how $P1790, type_obj
    .const 'Sub' $P1791 = "55_1298325448.42642" 
    $P1790."add_method"(type_obj, "!PREFIX__terminator", $P1791)
    get_how $P1792, type_obj
    .const 'Sub' $P1793 = "56_1298325448.42642" 
    $P1792."add_method"(type_obj, "terminator:sym<;>", $P1793)
    get_how $P1794, type_obj
    get_global $P1795, "!PREFIX__terminator:sym<;>"
    $P1794."add_method"(type_obj, "!PREFIX__terminator:sym<;>", $P1795)
    get_how $P1796, type_obj
    .const 'Sub' $P1797 = "58_1298325448.42642" 
    $P1796."add_method"(type_obj, "terminator:sym<}>", $P1797)
    get_how $P1798, type_obj
    get_global $P1799, "!PREFIX__terminator:sym<}>"
    $P1798."add_method"(type_obj, "!PREFIX__terminator:sym<}>", $P1799)
    get_how $P1800, type_obj
    .const 'Sub' $P1801 = "60_1298325448.42642" 
    $P1800."add_method"(type_obj, "statement_control", $P1801)
    get_how $P1802, type_obj
    .const 'Sub' $P1803 = "61_1298325448.42642" 
    $P1802."add_method"(type_obj, "!PREFIX__statement_control", $P1803)
    get_how $P1804, type_obj
    .const 'Sub' $P1805 = "62_1298325448.42642" 
    $P1804."add_method"(type_obj, "statement_control:sym<if>", $P1805)
    get_how $P1806, type_obj
    get_global $P1807, "!PREFIX__statement_control:sym<if>"
    $P1806."add_method"(type_obj, "!PREFIX__statement_control:sym<if>", $P1807)
    get_how $P1808, type_obj
    .const 'Sub' $P1809 = "64_1298325448.42642" 
    $P1808."add_method"(type_obj, "statement_control:sym<unless>", $P1809)
    get_how $P1810, type_obj
    get_global $P1811, "!PREFIX__statement_control:sym<unless>"
    $P1810."add_method"(type_obj, "!PREFIX__statement_control:sym<unless>", $P1811)
    get_how $P1812, type_obj
    .const 'Sub' $P1813 = "67_1298325448.42642" 
    $P1812."add_method"(type_obj, "statement_control:sym<while>", $P1813)
    get_how $P1814, type_obj
    get_global $P1815, "!PREFIX__statement_control:sym<while>"
    $P1814."add_method"(type_obj, "!PREFIX__statement_control:sym<while>", $P1815)
    get_how $P1816, type_obj
    .const 'Sub' $P1817 = "69_1298325448.42642" 
    $P1816."add_method"(type_obj, "statement_control:sym<repeat>", $P1817)
    get_how $P1818, type_obj
    get_global $P1819, "!PREFIX__statement_control:sym<repeat>"
    $P1818."add_method"(type_obj, "!PREFIX__statement_control:sym<repeat>", $P1819)
    get_how $P1820, type_obj
    .const 'Sub' $P1821 = "71_1298325448.42642" 
    $P1820."add_method"(type_obj, "statement_control:sym<for>", $P1821)
    get_how $P1822, type_obj
    get_global $P1823, "!PREFIX__statement_control:sym<for>"
    $P1822."add_method"(type_obj, "!PREFIX__statement_control:sym<for>", $P1823)
    get_how $P1824, type_obj
    .const 'Sub' $P1825 = "73_1298325448.42642" 
    $P1824."add_method"(type_obj, "statement_control:sym<CATCH>", $P1825)
    get_how $P1826, type_obj
    get_global $P1827, "!PREFIX__statement_control:sym<CATCH>"
    $P1826."add_method"(type_obj, "!PREFIX__statement_control:sym<CATCH>", $P1827)
    get_how $P1828, type_obj
    .const 'Sub' $P1829 = "75_1298325448.42642" 
    $P1828."add_method"(type_obj, "statement_control:sym<CONTROL>", $P1829)
    get_how $P1830, type_obj
    get_global $P1831, "!PREFIX__statement_control:sym<CONTROL>"
    $P1830."add_method"(type_obj, "!PREFIX__statement_control:sym<CONTROL>", $P1831)
    get_how $P1832, type_obj
    .const 'Sub' $P1833 = "77_1298325448.42642" 
    $P1832."add_method"(type_obj, "statement_prefix", $P1833)
    get_how $P1834, type_obj
    .const 'Sub' $P1835 = "78_1298325448.42642" 
    $P1834."add_method"(type_obj, "!PREFIX__statement_prefix", $P1835)
    get_how $P1836, type_obj
    .const 'Sub' $P1837 = "79_1298325448.42642" 
    $P1836."add_method"(type_obj, "statement_prefix:sym<INIT>", $P1837)
    get_how $P1838, type_obj
    get_global $P1839, "!PREFIX__statement_prefix:sym<INIT>"
    $P1838."add_method"(type_obj, "!PREFIX__statement_prefix:sym<INIT>", $P1839)
    get_how $P1840, type_obj
    .const 'Sub' $P1841 = "81_1298325448.42642" 
    $P1840."add_method"(type_obj, "statement_prefix:sym<try>", $P1841)
    get_how $P1842, type_obj
    get_global $P1843, "!PREFIX__statement_prefix:sym<try>"
    $P1842."add_method"(type_obj, "!PREFIX__statement_prefix:sym<try>", $P1843)
    get_how $P1844, type_obj
    .const 'Sub' $P1845 = "83_1298325448.42642" 
    $P1844."add_method"(type_obj, "blorst", $P1845)
    get_how $P1846, type_obj
    get_global $P1847, "!PREFIX__blorst"
    $P1846."add_method"(type_obj, "!PREFIX__blorst", $P1847)
    get_how $P1848, type_obj
    .const 'Sub' $P1849 = "85_1298325448.42642" 
    $P1848."add_method"(type_obj, "statement_mod_cond", $P1849)
    get_how $P1850, type_obj
    .const 'Sub' $P1851 = "86_1298325448.42642" 
    $P1850."add_method"(type_obj, "!PREFIX__statement_mod_cond", $P1851)
    get_how $P1852, type_obj
    .const 'Sub' $P1853 = "87_1298325448.42642" 
    $P1852."add_method"(type_obj, "statement_mod_cond:sym<if>", $P1853)
    get_how $P1854, type_obj
    get_global $P1855, "!PREFIX__statement_mod_cond:sym<if>"
    $P1854."add_method"(type_obj, "!PREFIX__statement_mod_cond:sym<if>", $P1855)
    get_how $P1856, type_obj
    .const 'Sub' $P1857 = "89_1298325448.42642" 
    $P1856."add_method"(type_obj, "statement_mod_cond:sym<unless>", $P1857)
    get_how $P1858, type_obj
    get_global $P1859, "!PREFIX__statement_mod_cond:sym<unless>"
    $P1858."add_method"(type_obj, "!PREFIX__statement_mod_cond:sym<unless>", $P1859)
    get_how $P1860, type_obj
    .const 'Sub' $P1861 = "91_1298325448.42642" 
    $P1860."add_method"(type_obj, "statement_mod_loop", $P1861)
    get_how $P1862, type_obj
    .const 'Sub' $P1863 = "92_1298325448.42642" 
    $P1862."add_method"(type_obj, "!PREFIX__statement_mod_loop", $P1863)
    get_how $P1864, type_obj
    .const 'Sub' $P1865 = "93_1298325448.42642" 
    $P1864."add_method"(type_obj, "statement_mod_loop:sym<while>", $P1865)
    get_how $P1866, type_obj
    get_global $P1867, "!PREFIX__statement_mod_loop:sym<while>"
    $P1866."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<while>", $P1867)
    get_how $P1868, type_obj
    .const 'Sub' $P1869 = "95_1298325448.42642" 
    $P1868."add_method"(type_obj, "statement_mod_loop:sym<until>", $P1869)
    get_how $P1870, type_obj
    get_global $P1871, "!PREFIX__statement_mod_loop:sym<until>"
    $P1870."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<until>", $P1871)
    get_how $P1872, type_obj
    .const 'Sub' $P1873 = "97_1298325448.42642" 
    $P1872."add_method"(type_obj, "statement_mod_loop:sym<for>", $P1873)
    get_how $P1874, type_obj
    get_global $P1875, "!PREFIX__statement_mod_loop:sym<for>"
    $P1874."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<for>", $P1875)
    get_how $P1876, type_obj
    .const 'Sub' $P1877 = "99_1298325448.42642" 
    $P1876."add_method"(type_obj, "term:sym<fatarrow>", $P1877)
    get_how $P1878, type_obj
    get_global $P1879, "!PREFIX__term:sym<fatarrow>"
    $P1878."add_method"(type_obj, "!PREFIX__term:sym<fatarrow>", $P1879)
    get_how $P1880, type_obj
    .const 'Sub' $P1881 = "101_1298325448.42642" 
    $P1880."add_method"(type_obj, "term:sym<colonpair>", $P1881)
    get_how $P1882, type_obj
    get_global $P1883, "!PREFIX__term:sym<colonpair>"
    $P1882."add_method"(type_obj, "!PREFIX__term:sym<colonpair>", $P1883)
    get_how $P1884, type_obj
    .const 'Sub' $P1885 = "103_1298325448.42642" 
    $P1884."add_method"(type_obj, "term:sym<variable>", $P1885)
    get_how $P1886, type_obj
    get_global $P1887, "!PREFIX__term:sym<variable>"
    $P1886."add_method"(type_obj, "!PREFIX__term:sym<variable>", $P1887)
    get_how $P1888, type_obj
    .const 'Sub' $P1889 = "105_1298325448.42642" 
    $P1888."add_method"(type_obj, "term:sym<package_declarator>", $P1889)
    get_how $P1890, type_obj
    get_global $P1891, "!PREFIX__term:sym<package_declarator>"
    $P1890."add_method"(type_obj, "!PREFIX__term:sym<package_declarator>", $P1891)
    get_how $P1892, type_obj
    .const 'Sub' $P1893 = "107_1298325448.42642" 
    $P1892."add_method"(type_obj, "term:sym<scope_declarator>", $P1893)
    get_how $P1894, type_obj
    get_global $P1895, "!PREFIX__term:sym<scope_declarator>"
    $P1894."add_method"(type_obj, "!PREFIX__term:sym<scope_declarator>", $P1895)
    get_how $P1896, type_obj
    .const 'Sub' $P1897 = "109_1298325448.42642" 
    $P1896."add_method"(type_obj, "term:sym<routine_declarator>", $P1897)
    get_how $P1898, type_obj
    get_global $P1899, "!PREFIX__term:sym<routine_declarator>"
    $P1898."add_method"(type_obj, "!PREFIX__term:sym<routine_declarator>", $P1899)
    get_how $P1900, type_obj
    .const 'Sub' $P1901 = "111_1298325448.42642" 
    $P1900."add_method"(type_obj, "term:sym<multi_declarator>", $P1901)
    get_how $P1902, type_obj
    get_global $P1903, "!PREFIX__term:sym<multi_declarator>"
    $P1902."add_method"(type_obj, "!PREFIX__term:sym<multi_declarator>", $P1903)
    get_how $P1904, type_obj
    .const 'Sub' $P1905 = "115_1298325448.42642" 
    $P1904."add_method"(type_obj, "term:sym<regex_declarator>", $P1905)
    get_how $P1906, type_obj
    get_global $P1907, "!PREFIX__term:sym<regex_declarator>"
    $P1906."add_method"(type_obj, "!PREFIX__term:sym<regex_declarator>", $P1907)
    get_how $P1908, type_obj
    .const 'Sub' $P1909 = "117_1298325448.42642" 
    $P1908."add_method"(type_obj, "term:sym<statement_prefix>", $P1909)
    get_how $P1910, type_obj
    get_global $P1911, "!PREFIX__term:sym<statement_prefix>"
    $P1910."add_method"(type_obj, "!PREFIX__term:sym<statement_prefix>", $P1911)
    get_how $P1912, type_obj
    .const 'Sub' $P1913 = "119_1298325448.42642" 
    $P1912."add_method"(type_obj, "term:sym<lambda>", $P1913)
    get_how $P1914, type_obj
    get_global $P1915, "!PREFIX__term:sym<lambda>"
    $P1914."add_method"(type_obj, "!PREFIX__term:sym<lambda>", $P1915)
    get_how $P1916, type_obj
    .const 'Sub' $P1917 = "121_1298325448.42642" 
    $P1916."add_method"(type_obj, "fatarrow", $P1917)
    get_how $P1918, type_obj
    get_global $P1919, "!PREFIX__fatarrow"
    $P1918."add_method"(type_obj, "!PREFIX__fatarrow", $P1919)
    get_how $P1920, type_obj
    .const 'Sub' $P1921 = "123_1298325448.42642" 
    $P1920."add_method"(type_obj, "colonpair", $P1921)
    get_how $P1922, type_obj
    get_global $P1923, "!PREFIX__colonpair"
    $P1922."add_method"(type_obj, "!PREFIX__colonpair", $P1923)
    get_how $P1924, type_obj
    .const 'Sub' $P1925 = "125_1298325448.42642" 
    $P1924."add_method"(type_obj, "variable", $P1925)
    get_how $P1926, type_obj
    get_global $P1927, "!PREFIX__variable"
    $P1926."add_method"(type_obj, "!PREFIX__variable", $P1927)
    get_how $P1928, type_obj
    .const 'Sub' $P1929 = "127_1298325448.42642" 
    $P1928."add_method"(type_obj, "sigil", $P1929)
    get_how $P1930, type_obj
    get_global $P1931, "!PREFIX__sigil"
    $P1930."add_method"(type_obj, "!PREFIX__sigil", $P1931)
    get_how $P1932, type_obj
    .const 'Sub' $P1933 = "129_1298325448.42642" 
    $P1932."add_method"(type_obj, "twigil", $P1933)
    get_how $P1934, type_obj
    get_global $P1935, "!PREFIX__twigil"
    $P1934."add_method"(type_obj, "!PREFIX__twigil", $P1935)
    get_how $P1936, type_obj
    .const 'Sub' $P1937 = "131_1298325448.42642" 
    $P1936."add_method"(type_obj, "package_declarator", $P1937)
    get_how $P1938, type_obj
    .const 'Sub' $P1939 = "132_1298325448.42642" 
    $P1938."add_method"(type_obj, "!PREFIX__package_declarator", $P1939)
    get_how $P1940, type_obj
    .const 'Sub' $P1941 = "133_1298325448.42642" 
    $P1940."add_method"(type_obj, "package_declarator:sym<module>", $P1941)
    get_how $P1942, type_obj
    get_global $P1943, "!PREFIX__package_declarator:sym<module>"
    $P1942."add_method"(type_obj, "!PREFIX__package_declarator:sym<module>", $P1943)
    get_how $P1944, type_obj
    .const 'Sub' $P1945 = "135_1298325448.42642" 
    $P1944."add_method"(type_obj, "package_declarator:sym<knowhow>", $P1945)
    get_how $P1946, type_obj
    get_global $P1947, "!PREFIX__package_declarator:sym<knowhow>"
    $P1946."add_method"(type_obj, "!PREFIX__package_declarator:sym<knowhow>", $P1947)
    get_how $P1948, type_obj
    .const 'Sub' $P1949 = "137_1298325448.42642" 
    $P1948."add_method"(type_obj, "package_declarator:sym<class>", $P1949)
    get_how $P1950, type_obj
    get_global $P1951, "!PREFIX__package_declarator:sym<class>"
    $P1950."add_method"(type_obj, "!PREFIX__package_declarator:sym<class>", $P1951)
    get_how $P1952, type_obj
    .const 'Sub' $P1953 = "139_1298325448.42642" 
    $P1952."add_method"(type_obj, "package_declarator:sym<grammar>", $P1953)
    get_how $P1954, type_obj
    get_global $P1955, "!PREFIX__package_declarator:sym<grammar>"
    $P1954."add_method"(type_obj, "!PREFIX__package_declarator:sym<grammar>", $P1955)
    get_how $P1956, type_obj
    .const 'Sub' $P1957 = "141_1298325448.42642" 
    $P1956."add_method"(type_obj, "package_declarator:sym<role>", $P1957)
    get_how $P1958, type_obj
    get_global $P1959, "!PREFIX__package_declarator:sym<role>"
    $P1958."add_method"(type_obj, "!PREFIX__package_declarator:sym<role>", $P1959)
    get_how $P1960, type_obj
    .const 'Sub' $P1961 = "143_1298325448.42642" 
    $P1960."add_method"(type_obj, "package_declarator:sym<native>", $P1961)
    get_how $P1962, type_obj
    get_global $P1963, "!PREFIX__package_declarator:sym<native>"
    $P1962."add_method"(type_obj, "!PREFIX__package_declarator:sym<native>", $P1963)
    get_how $P1964, type_obj
    .const 'Sub' $P1965 = "145_1298325448.42642" 
    $P1964."add_method"(type_obj, "package_def", $P1965)
    get_how $P1966, type_obj
    get_global $P1967, "!PREFIX__package_def"
    $P1966."add_method"(type_obj, "!PREFIX__package_def", $P1967)
    get_how $P1968, type_obj
    .const 'Sub' $P1969 = "147_1298325448.42642" 
    $P1968."add_method"(type_obj, "scope_declarator", $P1969)
    get_how $P1970, type_obj
    .const 'Sub' $P1971 = "148_1298325448.42642" 
    $P1970."add_method"(type_obj, "!PREFIX__scope_declarator", $P1971)
    get_how $P1972, type_obj
    .const 'Sub' $P1973 = "149_1298325448.42642" 
    $P1972."add_method"(type_obj, "scope_declarator:sym<my>", $P1973)
    get_how $P1974, type_obj
    get_global $P1975, "!PREFIX__scope_declarator:sym<my>"
    $P1974."add_method"(type_obj, "!PREFIX__scope_declarator:sym<my>", $P1975)
    get_how $P1976, type_obj
    .const 'Sub' $P1977 = "151_1298325448.42642" 
    $P1976."add_method"(type_obj, "scope_declarator:sym<our>", $P1977)
    get_how $P1978, type_obj
    get_global $P1979, "!PREFIX__scope_declarator:sym<our>"
    $P1978."add_method"(type_obj, "!PREFIX__scope_declarator:sym<our>", $P1979)
    get_how $P1980, type_obj
    .const 'Sub' $P1981 = "153_1298325448.42642" 
    $P1980."add_method"(type_obj, "scope_declarator:sym<has>", $P1981)
    get_how $P1982, type_obj
    get_global $P1983, "!PREFIX__scope_declarator:sym<has>"
    $P1982."add_method"(type_obj, "!PREFIX__scope_declarator:sym<has>", $P1983)
    get_how $P1984, type_obj
    .const 'Sub' $P1985 = "155_1298325448.42642" 
    $P1984."add_method"(type_obj, "scoped", $P1985)
    get_how $P1986, type_obj
    get_global $P1987, "!PREFIX__scoped"
    $P1986."add_method"(type_obj, "!PREFIX__scoped", $P1987)
    get_how $P1988, type_obj
    .const 'Sub' $P1989 = "157_1298325448.42642" 
    $P1988."add_method"(type_obj, "typename", $P1989)
    get_how $P1990, type_obj
    get_global $P1991, "!PREFIX__typename"
    $P1990."add_method"(type_obj, "!PREFIX__typename", $P1991)
    get_how $P1992, type_obj
    .const 'Sub' $P1993 = "159_1298325448.42642" 
    $P1992."add_method"(type_obj, "declarator", $P1993)
    get_how $P1994, type_obj
    get_global $P1995, "!PREFIX__declarator"
    $P1994."add_method"(type_obj, "!PREFIX__declarator", $P1995)
    get_how $P1996, type_obj
    .const 'Sub' $P1997 = "161_1298325448.42642" 
    $P1996."add_method"(type_obj, "variable_declarator", $P1997)
    get_how $P1998, type_obj
    get_global $P1999, "!PREFIX__variable_declarator"
    $P1998."add_method"(type_obj, "!PREFIX__variable_declarator", $P1999)
    get_how $P2000, type_obj
    .const 'Sub' $P2001 = "163_1298325448.42642" 
    $P2000."add_method"(type_obj, "routine_declarator", $P2001)
    get_how $P2002, type_obj
    .const 'Sub' $P2003 = "164_1298325448.42642" 
    $P2002."add_method"(type_obj, "!PREFIX__routine_declarator", $P2003)
    get_how $P2004, type_obj
    .const 'Sub' $P2005 = "165_1298325448.42642" 
    $P2004."add_method"(type_obj, "routine_declarator:sym<sub>", $P2005)
    get_how $P2006, type_obj
    get_global $P2007, "!PREFIX__routine_declarator:sym<sub>"
    $P2006."add_method"(type_obj, "!PREFIX__routine_declarator:sym<sub>", $P2007)
    get_how $P2008, type_obj
    .const 'Sub' $P2009 = "167_1298325448.42642" 
    $P2008."add_method"(type_obj, "routine_declarator:sym<method>", $P2009)
    get_how $P2010, type_obj
    get_global $P2011, "!PREFIX__routine_declarator:sym<method>"
    $P2010."add_method"(type_obj, "!PREFIX__routine_declarator:sym<method>", $P2011)
    get_how $P2012, type_obj
    .const 'Sub' $P2013 = "169_1298325448.42642" 
    $P2012."add_method"(type_obj, "routine_def", $P2013)
    get_how $P2014, type_obj
    get_global $P2015, "!PREFIX__routine_def"
    $P2014."add_method"(type_obj, "!PREFIX__routine_def", $P2015)
    get_how $P2016, type_obj
    .const 'Sub' $P2017 = "171_1298325448.42642" 
    $P2016."add_method"(type_obj, "method_def", $P2017)
    get_how $P2018, type_obj
    get_global $P2019, "!PREFIX__method_def"
    $P2018."add_method"(type_obj, "!PREFIX__method_def", $P2019)
    get_how $P2020, type_obj
    .const 'Sub' $P2021 = "174_1298325448.42642" 
    $P2020."add_method"(type_obj, "onlystar", $P2021)
    get_how $P2022, type_obj
    get_global $P2023, "!PREFIX__onlystar"
    $P2022."add_method"(type_obj, "!PREFIX__onlystar", $P2023)
    get_how $P2024, type_obj
    .const 'Sub' $P2025 = "177_1298325448.42642" 
    $P2024."add_method"(type_obj, "multi_declarator", $P2025)
    get_how $P2026, type_obj
    .const 'Sub' $P2027 = "178_1298325448.42642" 
    $P2026."add_method"(type_obj, "!PREFIX__multi_declarator", $P2027)
    get_how $P2028, type_obj
    .const 'Sub' $P2029 = "179_1298325448.42642" 
    $P2028."add_method"(type_obj, "multi_declarator:sym<multi>", $P2029)
    get_how $P2030, type_obj
    get_global $P2031, "!PREFIX__multi_declarator:sym<multi>"
    $P2030."add_method"(type_obj, "!PREFIX__multi_declarator:sym<multi>", $P2031)
    get_how $P2032, type_obj
    .const 'Sub' $P2033 = "181_1298325448.42642" 
    $P2032."add_method"(type_obj, "multi_declarator:sym<proto>", $P2033)
    get_how $P2034, type_obj
    get_global $P2035, "!PREFIX__multi_declarator:sym<proto>"
    $P2034."add_method"(type_obj, "!PREFIX__multi_declarator:sym<proto>", $P2035)
    get_how $P2036, type_obj
    .const 'Sub' $P2037 = "183_1298325448.42642" 
    $P2036."add_method"(type_obj, "multi_declarator:sym<null>", $P2037)
    get_how $P2038, type_obj
    get_global $P2039, "!PREFIX__multi_declarator:sym<null>"
    $P2038."add_method"(type_obj, "!PREFIX__multi_declarator:sym<null>", $P2039)
    get_how $P2040, type_obj
    .const 'Sub' $P2041 = "185_1298325448.42642" 
    $P2040."add_method"(type_obj, "signature", $P2041)
    get_how $P2042, type_obj
    get_global $P2043, "!PREFIX__signature"
    $P2042."add_method"(type_obj, "!PREFIX__signature", $P2043)
    get_how $P2044, type_obj
    .const 'Sub' $P2045 = "188_1298325448.42642" 
    $P2044."add_method"(type_obj, "parameter", $P2045)
    get_how $P2046, type_obj
    get_global $P2047, "!PREFIX__parameter"
    $P2046."add_method"(type_obj, "!PREFIX__parameter", $P2047)
    get_how $P2048, type_obj
    .const 'Sub' $P2049 = "190_1298325448.42642" 
    $P2048."add_method"(type_obj, "param_var", $P2049)
    get_how $P2050, type_obj
    get_global $P2051, "!PREFIX__param_var"
    $P2050."add_method"(type_obj, "!PREFIX__param_var", $P2051)
    get_how $P2052, type_obj
    .const 'Sub' $P2053 = "192_1298325448.42642" 
    $P2052."add_method"(type_obj, "named_param", $P2053)
    get_how $P2054, type_obj
    get_global $P2055, "!PREFIX__named_param"
    $P2054."add_method"(type_obj, "!PREFIX__named_param", $P2055)
    get_how $P2056, type_obj
    .const 'Sub' $P2057 = "194_1298325448.42642" 
    $P2056."add_method"(type_obj, "default_value", $P2057)
    get_how $P2058, type_obj
    get_global $P2059, "!PREFIX__default_value"
    $P2058."add_method"(type_obj, "!PREFIX__default_value", $P2059)
    get_how $P2060, type_obj
    .const 'Sub' $P2061 = "196_1298325448.42642" 
    $P2060."add_method"(type_obj, "trait", $P2061)
    get_how $P2062, type_obj
    get_global $P2063, "!PREFIX__trait"
    $P2062."add_method"(type_obj, "!PREFIX__trait", $P2063)
    get_how $P2064, type_obj
    .const 'Sub' $P2065 = "198_1298325448.42642" 
    $P2064."add_method"(type_obj, "trait_mod", $P2065)
    get_how $P2066, type_obj
    .const 'Sub' $P2067 = "199_1298325448.42642" 
    $P2066."add_method"(type_obj, "!PREFIX__trait_mod", $P2067)
    get_how $P2068, type_obj
    .const 'Sub' $P2069 = "200_1298325448.42642" 
    $P2068."add_method"(type_obj, "trait_mod:sym<is>", $P2069)
    get_how $P2070, type_obj
    get_global $P2071, "!PREFIX__trait_mod:sym<is>"
    $P2070."add_method"(type_obj, "!PREFIX__trait_mod:sym<is>", $P2071)
    get_how $P2072, type_obj
    .const 'Sub' $P2073 = "202_1298325448.42642" 
    $P2072."add_method"(type_obj, "regex_declarator", $P2073)
    get_how $P2074, type_obj
    get_global $P2075, "!PREFIX__regex_declarator"
    $P2074."add_method"(type_obj, "!PREFIX__regex_declarator", $P2075)
    get_how $P2076, type_obj
    .const 'Sub' $P2077 = "204_1298325448.42642" 
    $P2076."add_method"(type_obj, "dotty", $P2077)
    get_how $P2078, type_obj
    get_global $P2079, "!PREFIX__dotty"
    $P2078."add_method"(type_obj, "!PREFIX__dotty", $P2079)
    get_how $P2080, type_obj
    .const 'Sub' $P2081 = "206_1298325448.42642" 
    $P2080."add_method"(type_obj, "term", $P2081)
    get_how $P2082, type_obj
    .const 'Sub' $P2083 = "207_1298325448.42642" 
    $P2082."add_method"(type_obj, "!PREFIX__term", $P2083)
    get_how $P2084, type_obj
    .const 'Sub' $P2085 = "208_1298325448.42642" 
    $P2084."add_method"(type_obj, "term:sym<self>", $P2085)
    get_how $P2086, type_obj
    get_global $P2087, "!PREFIX__term:sym<self>"
    $P2086."add_method"(type_obj, "!PREFIX__term:sym<self>", $P2087)
    get_how $P2088, type_obj
    .const 'Sub' $P2089 = "210_1298325448.42642" 
    $P2088."add_method"(type_obj, "term:sym<identifier>", $P2089)
    get_how $P2090, type_obj
    get_global $P2091, "!PREFIX__term:sym<identifier>"
    $P2090."add_method"(type_obj, "!PREFIX__term:sym<identifier>", $P2091)
    get_how $P2092, type_obj
    .const 'Sub' $P2093 = "212_1298325448.42642" 
    $P2092."add_method"(type_obj, "term:sym<name>", $P2093)
    get_how $P2094, type_obj
    get_global $P2095, "!PREFIX__term:sym<name>"
    $P2094."add_method"(type_obj, "!PREFIX__term:sym<name>", $P2095)
    get_how $P2096, type_obj
    .const 'Sub' $P2097 = "214_1298325448.42642" 
    $P2096."add_method"(type_obj, "term:sym<pir::op>", $P2097)
    get_how $P2098, type_obj
    get_global $P2099, "!PREFIX__term:sym<pir::op>"
    $P2098."add_method"(type_obj, "!PREFIX__term:sym<pir::op>", $P2099)
    get_how $P2100, type_obj
    .const 'Sub' $P2101 = "216_1298325448.42642" 
    $P2100."add_method"(type_obj, "term:sym<onlystar>", $P2101)
    get_how $P2102, type_obj
    get_global $P2103, "!PREFIX__term:sym<onlystar>"
    $P2102."add_method"(type_obj, "!PREFIX__term:sym<onlystar>", $P2103)
    get_how $P2104, type_obj
    .const 'Sub' $P2105 = "219_1298325448.42642" 
    $P2104."add_method"(type_obj, "args", $P2105)
    get_how $P2106, type_obj
    get_global $P2107, "!PREFIX__args"
    $P2106."add_method"(type_obj, "!PREFIX__args", $P2107)
    get_how $P2108, type_obj
    .const 'Sub' $P2109 = "221_1298325448.42642" 
    $P2108."add_method"(type_obj, "arglist", $P2109)
    get_how $P2110, type_obj
    get_global $P2111, "!PREFIX__arglist"
    $P2110."add_method"(type_obj, "!PREFIX__arglist", $P2111)
    get_how $P2112, type_obj
    .const 'Sub' $P2113 = "223_1298325448.42642" 
    $P2112."add_method"(type_obj, "term:sym<value>", $P2113)
    get_how $P2114, type_obj
    get_global $P2115, "!PREFIX__term:sym<value>"
    $P2114."add_method"(type_obj, "!PREFIX__term:sym<value>", $P2115)
    get_how $P2116, type_obj
    .const 'Sub' $P2117 = "225_1298325448.42642" 
    $P2116."add_method"(type_obj, "value", $P2117)
    get_how $P2118, type_obj
    get_global $P2119, "!PREFIX__value"
    $P2118."add_method"(type_obj, "!PREFIX__value", $P2119)
    get_how $P2120, type_obj
    .const 'Sub' $P2121 = "227_1298325448.42642" 
    $P2120."add_method"(type_obj, "number", $P2121)
    get_how $P2122, type_obj
    get_global $P2123, "!PREFIX__number"
    $P2122."add_method"(type_obj, "!PREFIX__number", $P2123)
    get_how $P2124, type_obj
    .const 'Sub' $P2125 = "229_1298325448.42642" 
    $P2124."add_method"(type_obj, "quote", $P2125)
    get_how $P2126, type_obj
    .const 'Sub' $P2127 = "230_1298325448.42642" 
    $P2126."add_method"(type_obj, "!PREFIX__quote", $P2127)
    get_how $P2128, type_obj
    .const 'Sub' $P2129 = "231_1298325448.42642" 
    $P2128."add_method"(type_obj, "quote:sym<apos>", $P2129)
    get_how $P2130, type_obj
    get_global $P2131, "!PREFIX__quote:sym<apos>"
    $P2130."add_method"(type_obj, "!PREFIX__quote:sym<apos>", $P2131)
    get_how $P2132, type_obj
    .const 'Sub' $P2133 = "233_1298325448.42642" 
    $P2132."add_method"(type_obj, "quote:sym<dblq>", $P2133)
    get_how $P2134, type_obj
    get_global $P2135, "!PREFIX__quote:sym<dblq>"
    $P2134."add_method"(type_obj, "!PREFIX__quote:sym<dblq>", $P2135)
    get_how $P2136, type_obj
    .const 'Sub' $P2137 = "235_1298325448.42642" 
    $P2136."add_method"(type_obj, "quote:sym<q>", $P2137)
    get_how $P2138, type_obj
    get_global $P2139, "!PREFIX__quote:sym<q>"
    $P2138."add_method"(type_obj, "!PREFIX__quote:sym<q>", $P2139)
    get_how $P2140, type_obj
    .const 'Sub' $P2141 = "237_1298325448.42642" 
    $P2140."add_method"(type_obj, "quote:sym<qq>", $P2141)
    get_how $P2142, type_obj
    get_global $P2143, "!PREFIX__quote:sym<qq>"
    $P2142."add_method"(type_obj, "!PREFIX__quote:sym<qq>", $P2143)
    get_how $P2144, type_obj
    .const 'Sub' $P2145 = "239_1298325448.42642" 
    $P2144."add_method"(type_obj, "quote:sym<Q>", $P2145)
    get_how $P2146, type_obj
    get_global $P2147, "!PREFIX__quote:sym<Q>"
    $P2146."add_method"(type_obj, "!PREFIX__quote:sym<Q>", $P2147)
    get_how $P2148, type_obj
    .const 'Sub' $P2149 = "241_1298325448.42642" 
    $P2148."add_method"(type_obj, "quote:sym<Q:PIR>", $P2149)
    get_how $P2150, type_obj
    get_global $P2151, "!PREFIX__quote:sym<Q:PIR>"
    $P2150."add_method"(type_obj, "!PREFIX__quote:sym<Q:PIR>", $P2151)
    get_how $P2152, type_obj
    .const 'Sub' $P2153 = "243_1298325448.42642" 
    $P2152."add_method"(type_obj, "quote:sym</ />", $P2153)
    get_how $P2154, type_obj
    get_global $P2155, "!PREFIX__quote:sym</ />"
    $P2154."add_method"(type_obj, "!PREFIX__quote:sym</ />", $P2155)
    get_how $P2156, type_obj
    .const 'Sub' $P2157 = "245_1298325448.42642" 
    $P2156."add_method"(type_obj, "quote_escape:sym<$>", $P2157)
    get_how $P2158, type_obj
    get_global $P2159, "!PREFIX__quote_escape:sym<$>"
    $P2158."add_method"(type_obj, "!PREFIX__quote_escape:sym<$>", $P2159)
    get_how $P2160, type_obj
    .const 'Sub' $P2161 = "247_1298325448.42642" 
    $P2160."add_method"(type_obj, "quote_escape:sym<{ }>", $P2161)
    get_how $P2162, type_obj
    get_global $P2163, "!PREFIX__quote_escape:sym<{ }>"
    $P2162."add_method"(type_obj, "!PREFIX__quote_escape:sym<{ }>", $P2163)
    get_how $P2164, type_obj
    .const 'Sub' $P2165 = "249_1298325448.42642" 
    $P2164."add_method"(type_obj, "quote_escape:sym<esc>", $P2165)
    get_how $P2166, type_obj
    get_global $P2167, "!PREFIX__quote_escape:sym<esc>"
    $P2166."add_method"(type_obj, "!PREFIX__quote_escape:sym<esc>", $P2167)
    get_how $P2168, type_obj
    .const 'Sub' $P2169 = "251_1298325448.42642" 
    $P2168."add_method"(type_obj, "circumfix:sym<( )>", $P2169)
    get_how $P2170, type_obj
    get_global $P2171, "!PREFIX__circumfix:sym<( )>"
    $P2170."add_method"(type_obj, "!PREFIX__circumfix:sym<( )>", $P2171)
    get_how $P2172, type_obj
    .const 'Sub' $P2173 = "253_1298325448.42642" 
    $P2172."add_method"(type_obj, "circumfix:sym<[ ]>", $P2173)
    get_how $P2174, type_obj
    get_global $P2175, "!PREFIX__circumfix:sym<[ ]>"
    $P2174."add_method"(type_obj, "!PREFIX__circumfix:sym<[ ]>", $P2175)
    get_how $P2176, type_obj
    .const 'Sub' $P2177 = "255_1298325448.42642" 
    $P2176."add_method"(type_obj, "circumfix:sym<ang>", $P2177)
    get_how $P2178, type_obj
    get_global $P2179, "!PREFIX__circumfix:sym<ang>"
    $P2178."add_method"(type_obj, "!PREFIX__circumfix:sym<ang>", $P2179)
    get_how $P2180, type_obj
    .const 'Sub' $P2181 = "257_1298325448.42642" 
    $P2180."add_method"(type_obj, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P2181)
    get_how $P2182, type_obj
    get_global $P2183, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"
    $P2182."add_method"(type_obj, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>", $P2183)
    get_how $P2184, type_obj
    .const 'Sub' $P2185 = "259_1298325448.42642" 
    $P2184."add_method"(type_obj, "circumfix:sym<{ }>", $P2185)
    get_how $P2186, type_obj
    get_global $P2187, "!PREFIX__circumfix:sym<{ }>"
    $P2186."add_method"(type_obj, "!PREFIX__circumfix:sym<{ }>", $P2187)
    get_how $P2188, type_obj
    .const 'Sub' $P2189 = "261_1298325448.42642" 
    $P2188."add_method"(type_obj, "circumfix:sym<sigil>", $P2189)
    get_how $P2190, type_obj
    get_global $P2191, "!PREFIX__circumfix:sym<sigil>"
    $P2190."add_method"(type_obj, "!PREFIX__circumfix:sym<sigil>", $P2191)
    get_how $P2192, type_obj
    .const 'Sub' $P2193 = "263_1298325448.42642" 
    $P2192."add_method"(type_obj, "semilist", $P2193)
    get_how $P2194, type_obj
    get_global $P2195, "!PREFIX__semilist"
    $P2194."add_method"(type_obj, "!PREFIX__semilist", $P2195)
    get_how $P2196, type_obj
    .const 'Sub' $P2197 = "266_1298325448.42642" 
    $P2196."add_method"(type_obj, "infixish", $P2197)
    get_how $P2198, type_obj
    get_global $P2199, "!PREFIX__infixish"
    $P2198."add_method"(type_obj, "!PREFIX__infixish", $P2199)
    get_how $P2200, type_obj
    .const 'Sub' $P2201 = "268_1298325448.42642" 
    $P2200."add_method"(type_obj, "infixstopper", $P2201)
    get_how $P2202, type_obj
    get_global $P2203, "!PREFIX__infixstopper"
    $P2202."add_method"(type_obj, "!PREFIX__infixstopper", $P2203)
    get_how $P2204, type_obj
    .const 'Sub' $P2205 = "270_1298325448.42642" 
    $P2204."add_method"(type_obj, "postcircumfix:sym<[ ]>", $P2205)
    get_how $P2206, type_obj
    get_global $P2207, "!PREFIX__postcircumfix:sym<[ ]>"
    $P2206."add_method"(type_obj, "!PREFIX__postcircumfix:sym<[ ]>", $P2207)
    get_how $P2208, type_obj
    .const 'Sub' $P2209 = "272_1298325448.42642" 
    $P2208."add_method"(type_obj, "postcircumfix:sym<{ }>", $P2209)
    get_how $P2210, type_obj
    get_global $P2211, "!PREFIX__postcircumfix:sym<{ }>"
    $P2210."add_method"(type_obj, "!PREFIX__postcircumfix:sym<{ }>", $P2211)
    get_how $P2212, type_obj
    .const 'Sub' $P2213 = "274_1298325448.42642" 
    $P2212."add_method"(type_obj, "postcircumfix:sym<ang>", $P2213)
    get_how $P2214, type_obj
    get_global $P2215, "!PREFIX__postcircumfix:sym<ang>"
    $P2214."add_method"(type_obj, "!PREFIX__postcircumfix:sym<ang>", $P2215)
    get_how $P2216, type_obj
    .const 'Sub' $P2217 = "276_1298325448.42642" 
    $P2216."add_method"(type_obj, "postcircumfix:sym<( )>", $P2217)
    get_how $P2218, type_obj
    get_global $P2219, "!PREFIX__postcircumfix:sym<( )>"
    $P2218."add_method"(type_obj, "!PREFIX__postcircumfix:sym<( )>", $P2219)
    get_how $P2220, type_obj
    .const 'Sub' $P2221 = "278_1298325448.42642" 
    $P2220."add_method"(type_obj, "postfix:sym<.>", $P2221)
    get_how $P2222, type_obj
    get_global $P2223, "!PREFIX__postfix:sym<.>"
    $P2222."add_method"(type_obj, "!PREFIX__postfix:sym<.>", $P2223)
    get_how $P2224, type_obj
    .const 'Sub' $P2225 = "280_1298325448.42642" 
    $P2224."add_method"(type_obj, "prefix:sym<++>", $P2225)
    get_how $P2226, type_obj
    get_global $P2227, "!PREFIX__prefix:sym<++>"
    $P2226."add_method"(type_obj, "!PREFIX__prefix:sym<++>", $P2227)
    get_how $P2228, type_obj
    .const 'Sub' $P2229 = "282_1298325448.42642" 
    $P2228."add_method"(type_obj, "prefix:sym<-->", $P2229)
    get_how $P2230, type_obj
    get_global $P2231, "!PREFIX__prefix:sym<-->"
    $P2230."add_method"(type_obj, "!PREFIX__prefix:sym<-->", $P2231)
    get_how $P2232, type_obj
    .const 'Sub' $P2233 = "284_1298325448.42642" 
    $P2232."add_method"(type_obj, "postfix:sym<++>", $P2233)
    get_how $P2234, type_obj
    get_global $P2235, "!PREFIX__postfix:sym<++>"
    $P2234."add_method"(type_obj, "!PREFIX__postfix:sym<++>", $P2235)
    get_how $P2236, type_obj
    .const 'Sub' $P2237 = "286_1298325448.42642" 
    $P2236."add_method"(type_obj, "postfix:sym<-->", $P2237)
    get_how $P2238, type_obj
    get_global $P2239, "!PREFIX__postfix:sym<-->"
    $P2238."add_method"(type_obj, "!PREFIX__postfix:sym<-->", $P2239)
    get_how $P2240, type_obj
    .const 'Sub' $P2241 = "288_1298325448.42642" 
    $P2240."add_method"(type_obj, "infix:sym<**>", $P2241)
    get_how $P2242, type_obj
    get_global $P2243, "!PREFIX__infix:sym<**>"
    $P2242."add_method"(type_obj, "!PREFIX__infix:sym<**>", $P2243)
    get_how $P2244, type_obj
    .const 'Sub' $P2245 = "290_1298325448.42642" 
    $P2244."add_method"(type_obj, "prefix:sym<+>", $P2245)
    get_how $P2246, type_obj
    get_global $P2247, "!PREFIX__prefix:sym<+>"
    $P2246."add_method"(type_obj, "!PREFIX__prefix:sym<+>", $P2247)
    get_how $P2248, type_obj
    .const 'Sub' $P2249 = "292_1298325448.42642" 
    $P2248."add_method"(type_obj, "prefix:sym<~>", $P2249)
    get_how $P2250, type_obj
    get_global $P2251, "!PREFIX__prefix:sym<~>"
    $P2250."add_method"(type_obj, "!PREFIX__prefix:sym<~>", $P2251)
    get_how $P2252, type_obj
    .const 'Sub' $P2253 = "294_1298325448.42642" 
    $P2252."add_method"(type_obj, "prefix:sym<->", $P2253)
    get_how $P2254, type_obj
    get_global $P2255, "!PREFIX__prefix:sym<->"
    $P2254."add_method"(type_obj, "!PREFIX__prefix:sym<->", $P2255)
    get_how $P2256, type_obj
    .const 'Sub' $P2257 = "296_1298325448.42642" 
    $P2256."add_method"(type_obj, "prefix:sym<?>", $P2257)
    get_how $P2258, type_obj
    get_global $P2259, "!PREFIX__prefix:sym<?>"
    $P2258."add_method"(type_obj, "!PREFIX__prefix:sym<?>", $P2259)
    get_how $P2260, type_obj
    .const 'Sub' $P2261 = "298_1298325448.42642" 
    $P2260."add_method"(type_obj, "prefix:sym<!>", $P2261)
    get_how $P2262, type_obj
    get_global $P2263, "!PREFIX__prefix:sym<!>"
    $P2262."add_method"(type_obj, "!PREFIX__prefix:sym<!>", $P2263)
    get_how $P2264, type_obj
    .const 'Sub' $P2265 = "300_1298325448.42642" 
    $P2264."add_method"(type_obj, "prefix:sym<|>", $P2265)
    get_how $P2266, type_obj
    get_global $P2267, "!PREFIX__prefix:sym<|>"
    $P2266."add_method"(type_obj, "!PREFIX__prefix:sym<|>", $P2267)
    get_how $P2268, type_obj
    .const 'Sub' $P2269 = "302_1298325448.42642" 
    $P2268."add_method"(type_obj, "infix:sym<*>", $P2269)
    get_how $P2270, type_obj
    get_global $P2271, "!PREFIX__infix:sym<*>"
    $P2270."add_method"(type_obj, "!PREFIX__infix:sym<*>", $P2271)
    get_how $P2272, type_obj
    .const 'Sub' $P2273 = "304_1298325448.42642" 
    $P2272."add_method"(type_obj, "infix:sym</>", $P2273)
    get_how $P2274, type_obj
    get_global $P2275, "!PREFIX__infix:sym</>"
    $P2274."add_method"(type_obj, "!PREFIX__infix:sym</>", $P2275)
    get_how $P2276, type_obj
    .const 'Sub' $P2277 = "306_1298325448.42642" 
    $P2276."add_method"(type_obj, "infix:sym<%>", $P2277)
    get_how $P2278, type_obj
    get_global $P2279, "!PREFIX__infix:sym<%>"
    $P2278."add_method"(type_obj, "!PREFIX__infix:sym<%>", $P2279)
    get_how $P2280, type_obj
    .const 'Sub' $P2281 = "308_1298325448.42642" 
    $P2280."add_method"(type_obj, "infix:sym<+&>", $P2281)
    get_how $P2282, type_obj
    get_global $P2283, "!PREFIX__infix:sym<+&>"
    $P2282."add_method"(type_obj, "!PREFIX__infix:sym<+&>", $P2283)
    get_how $P2284, type_obj
    .const 'Sub' $P2285 = "310_1298325448.42642" 
    $P2284."add_method"(type_obj, "infix:sym<+>", $P2285)
    get_how $P2286, type_obj
    get_global $P2287, "!PREFIX__infix:sym<+>"
    $P2286."add_method"(type_obj, "!PREFIX__infix:sym<+>", $P2287)
    get_how $P2288, type_obj
    .const 'Sub' $P2289 = "312_1298325448.42642" 
    $P2288."add_method"(type_obj, "infix:sym<->", $P2289)
    get_how $P2290, type_obj
    get_global $P2291, "!PREFIX__infix:sym<->"
    $P2290."add_method"(type_obj, "!PREFIX__infix:sym<->", $P2291)
    get_how $P2292, type_obj
    .const 'Sub' $P2293 = "314_1298325448.42642" 
    $P2292."add_method"(type_obj, "infix:sym<+|>", $P2293)
    get_how $P2294, type_obj
    get_global $P2295, "!PREFIX__infix:sym<+|>"
    $P2294."add_method"(type_obj, "!PREFIX__infix:sym<+|>", $P2295)
    get_how $P2296, type_obj
    .const 'Sub' $P2297 = "316_1298325448.42642" 
    $P2296."add_method"(type_obj, "infix:sym<+^>", $P2297)
    get_how $P2298, type_obj
    get_global $P2299, "!PREFIX__infix:sym<+^>"
    $P2298."add_method"(type_obj, "!PREFIX__infix:sym<+^>", $P2299)
    get_how $P2300, type_obj
    .const 'Sub' $P2301 = "318_1298325448.42642" 
    $P2300."add_method"(type_obj, "infix:sym<~>", $P2301)
    get_how $P2302, type_obj
    get_global $P2303, "!PREFIX__infix:sym<~>"
    $P2302."add_method"(type_obj, "!PREFIX__infix:sym<~>", $P2303)
    get_how $P2304, type_obj
    .const 'Sub' $P2305 = "320_1298325448.42642" 
    $P2304."add_method"(type_obj, "infix:sym<==>", $P2305)
    get_how $P2306, type_obj
    get_global $P2307, "!PREFIX__infix:sym<==>"
    $P2306."add_method"(type_obj, "!PREFIX__infix:sym<==>", $P2307)
    get_how $P2308, type_obj
    .const 'Sub' $P2309 = "322_1298325448.42642" 
    $P2308."add_method"(type_obj, "infix:sym<!=>", $P2309)
    get_how $P2310, type_obj
    get_global $P2311, "!PREFIX__infix:sym<!=>"
    $P2310."add_method"(type_obj, "!PREFIX__infix:sym<!=>", $P2311)
    get_how $P2312, type_obj
    .const 'Sub' $P2313 = "324_1298325448.42642" 
    $P2312."add_method"(type_obj, "infix:sym<<=>", $P2313)
    get_how $P2314, type_obj
    get_global $P2315, "!PREFIX__infix:sym<<=>"
    $P2314."add_method"(type_obj, "!PREFIX__infix:sym<<=>", $P2315)
    get_how $P2316, type_obj
    .const 'Sub' $P2317 = "326_1298325448.42642" 
    $P2316."add_method"(type_obj, "infix:sym<>=>", $P2317)
    get_how $P2318, type_obj
    get_global $P2319, "!PREFIX__infix:sym<>=>"
    $P2318."add_method"(type_obj, "!PREFIX__infix:sym<>=>", $P2319)
    get_how $P2320, type_obj
    .const 'Sub' $P2321 = "328_1298325448.42642" 
    $P2320."add_method"(type_obj, "infix:sym<<>", $P2321)
    get_how $P2322, type_obj
    get_global $P2323, "!PREFIX__infix:sym<<>"
    $P2322."add_method"(type_obj, "!PREFIX__infix:sym<<>", $P2323)
    get_how $P2324, type_obj
    .const 'Sub' $P2325 = "330_1298325448.42642" 
    $P2324."add_method"(type_obj, "infix:sym<>>", $P2325)
    get_how $P2326, type_obj
    get_global $P2327, "!PREFIX__infix:sym<>>"
    $P2326."add_method"(type_obj, "!PREFIX__infix:sym<>>", $P2327)
    get_how $P2328, type_obj
    .const 'Sub' $P2329 = "332_1298325448.42642" 
    $P2328."add_method"(type_obj, "infix:sym<eq>", $P2329)
    get_how $P2330, type_obj
    get_global $P2331, "!PREFIX__infix:sym<eq>"
    $P2330."add_method"(type_obj, "!PREFIX__infix:sym<eq>", $P2331)
    get_how $P2332, type_obj
    .const 'Sub' $P2333 = "334_1298325448.42642" 
    $P2332."add_method"(type_obj, "infix:sym<ne>", $P2333)
    get_how $P2334, type_obj
    get_global $P2335, "!PREFIX__infix:sym<ne>"
    $P2334."add_method"(type_obj, "!PREFIX__infix:sym<ne>", $P2335)
    get_how $P2336, type_obj
    .const 'Sub' $P2337 = "336_1298325448.42642" 
    $P2336."add_method"(type_obj, "infix:sym<le>", $P2337)
    get_how $P2338, type_obj
    get_global $P2339, "!PREFIX__infix:sym<le>"
    $P2338."add_method"(type_obj, "!PREFIX__infix:sym<le>", $P2339)
    get_how $P2340, type_obj
    .const 'Sub' $P2341 = "338_1298325448.42642" 
    $P2340."add_method"(type_obj, "infix:sym<ge>", $P2341)
    get_how $P2342, type_obj
    get_global $P2343, "!PREFIX__infix:sym<ge>"
    $P2342."add_method"(type_obj, "!PREFIX__infix:sym<ge>", $P2343)
    get_how $P2344, type_obj
    .const 'Sub' $P2345 = "340_1298325448.42642" 
    $P2344."add_method"(type_obj, "infix:sym<lt>", $P2345)
    get_how $P2346, type_obj
    get_global $P2347, "!PREFIX__infix:sym<lt>"
    $P2346."add_method"(type_obj, "!PREFIX__infix:sym<lt>", $P2347)
    get_how $P2348, type_obj
    .const 'Sub' $P2349 = "342_1298325448.42642" 
    $P2348."add_method"(type_obj, "infix:sym<gt>", $P2349)
    get_how $P2350, type_obj
    get_global $P2351, "!PREFIX__infix:sym<gt>"
    $P2350."add_method"(type_obj, "!PREFIX__infix:sym<gt>", $P2351)
    get_how $P2352, type_obj
    .const 'Sub' $P2353 = "344_1298325448.42642" 
    $P2352."add_method"(type_obj, "infix:sym<=:=>", $P2353)
    get_how $P2354, type_obj
    get_global $P2355, "!PREFIX__infix:sym<=:=>"
    $P2354."add_method"(type_obj, "!PREFIX__infix:sym<=:=>", $P2355)
    get_how $P2356, type_obj
    .const 'Sub' $P2357 = "346_1298325448.42642" 
    $P2356."add_method"(type_obj, "infix:sym<~~>", $P2357)
    get_how $P2358, type_obj
    get_global $P2359, "!PREFIX__infix:sym<~~>"
    $P2358."add_method"(type_obj, "!PREFIX__infix:sym<~~>", $P2359)
    get_how $P2360, type_obj
    .const 'Sub' $P2361 = "348_1298325448.42642" 
    $P2360."add_method"(type_obj, "infix:sym<&&>", $P2361)
    get_how $P2362, type_obj
    get_global $P2363, "!PREFIX__infix:sym<&&>"
    $P2362."add_method"(type_obj, "!PREFIX__infix:sym<&&>", $P2363)
    get_how $P2364, type_obj
    .const 'Sub' $P2365 = "350_1298325448.42642" 
    $P2364."add_method"(type_obj, "infix:sym<||>", $P2365)
    get_how $P2366, type_obj
    get_global $P2367, "!PREFIX__infix:sym<||>"
    $P2366."add_method"(type_obj, "!PREFIX__infix:sym<||>", $P2367)
    get_how $P2368, type_obj
    .const 'Sub' $P2369 = "352_1298325448.42642" 
    $P2368."add_method"(type_obj, "infix:sym<//>", $P2369)
    get_how $P2370, type_obj
    get_global $P2371, "!PREFIX__infix:sym<//>"
    $P2370."add_method"(type_obj, "!PREFIX__infix:sym<//>", $P2371)
    get_how $P2372, type_obj
    .const 'Sub' $P2373 = "354_1298325448.42642" 
    $P2372."add_method"(type_obj, "infix:sym<?? !!>", $P2373)
    get_how $P2374, type_obj
    get_global $P2375, "!PREFIX__infix:sym<?? !!>"
    $P2374."add_method"(type_obj, "!PREFIX__infix:sym<?? !!>", $P2375)
    get_how $P2376, type_obj
    .const 'Sub' $P2377 = "356_1298325448.42642" 
    $P2376."add_method"(type_obj, "infix:sym<=>", $P2377)
    get_how $P2378, type_obj
    get_global $P2379, "!PREFIX__infix:sym<=>"
    $P2378."add_method"(type_obj, "!PREFIX__infix:sym<=>", $P2379)
    get_how $P2380, type_obj
    .const 'Sub' $P2381 = "358_1298325448.42642" 
    $P2380."add_method"(type_obj, "infix:sym<:=>", $P2381)
    get_how $P2382, type_obj
    get_global $P2383, "!PREFIX__infix:sym<:=>"
    $P2382."add_method"(type_obj, "!PREFIX__infix:sym<:=>", $P2383)
    get_how $P2384, type_obj
    .const 'Sub' $P2385 = "360_1298325448.42642" 
    $P2384."add_method"(type_obj, "infix:sym<::=>", $P2385)
    get_how $P2386, type_obj
    get_global $P2387, "!PREFIX__infix:sym<::=>"
    $P2386."add_method"(type_obj, "!PREFIX__infix:sym<::=>", $P2387)
    get_how $P2388, type_obj
    .const 'Sub' $P2389 = "362_1298325448.42642" 
    $P2388."add_method"(type_obj, "infix:sym<,>", $P2389)
    get_how $P2390, type_obj
    get_global $P2391, "!PREFIX__infix:sym<,>"
    $P2390."add_method"(type_obj, "!PREFIX__infix:sym<,>", $P2391)
    get_how $P2392, type_obj
    .const 'Sub' $P2393 = "364_1298325448.42642" 
    $P2392."add_method"(type_obj, "prefix:sym<return>", $P2393)
    get_how $P2394, type_obj
    get_global $P2395, "!PREFIX__prefix:sym<return>"
    $P2394."add_method"(type_obj, "!PREFIX__prefix:sym<return>", $P2395)
    get_how $P2396, type_obj
    .const 'Sub' $P2397 = "367_1298325448.42642" 
    $P2396."add_method"(type_obj, "prefix:sym<make>", $P2397)
    get_how $P2398, type_obj
    get_global $P2399, "!PREFIX__prefix:sym<make>"
    $P2398."add_method"(type_obj, "!PREFIX__prefix:sym<make>", $P2399)
    get_how $P2400, type_obj
    .const 'Sub' $P2401 = "369_1298325448.42642" 
    $P2400."add_method"(type_obj, "term:sym<last>", $P2401)
    get_how $P2402, type_obj
    get_global $P2403, "!PREFIX__term:sym<last>"
    $P2402."add_method"(type_obj, "!PREFIX__term:sym<last>", $P2403)
    get_how $P2404, type_obj
    .const 'Sub' $P2405 = "371_1298325448.42642" 
    $P2404."add_method"(type_obj, "term:sym<next>", $P2405)
    get_how $P2406, type_obj
    get_global $P2407, "!PREFIX__term:sym<next>"
    $P2406."add_method"(type_obj, "!PREFIX__term:sym<next>", $P2407)
    get_how $P2408, type_obj
    .const 'Sub' $P2409 = "373_1298325448.42642" 
    $P2408."add_method"(type_obj, "term:sym<redo>", $P2409)
    get_how $P2410, type_obj
    get_global $P2411, "!PREFIX__term:sym<redo>"
    $P2410."add_method"(type_obj, "!PREFIX__term:sym<redo>", $P2411)
    get_how $P2412, type_obj
    .const 'Sub' $P2413 = "375_1298325448.42642" 
    $P2412."add_method"(type_obj, "smartmatch", $P2413)
    get_how $P2414, type_obj
    get_hll_global $P2415, ["HLL"], "Grammar"
    $P2414."add_parent"(type_obj, $P2415)
    get_how $P2416, type_obj
    $P2417 = $P2416."compose"(type_obj)
    .return ($P2417)
.end


.namespace ["NQP";"Grammar"]
.sub "TOP"  :subid("12_1298325448.42642") :outer("11_1298325448.42642")
    .param pmc param_19
.annotate 'line', 4
    .lex "self", param_19
.annotate 'line', 5
    $P20 = root_new ['parrot';'Hash']
    .lex "%*LANG", $P20
.annotate 'line', 12
    $P21 = root_new ['parrot';'Hash']
    .lex "%*HOW", $P21
.annotate 'line', 21
    new $P22, "Undef"
    .lex "$*DEFAULT-METAATTR", $P22
.annotate 'line', 22
    $P23 = root_new ['parrot';'Hash']
    .lex "%*HOW-METAATTR", $P23
.annotate 'line', 25
    new $P24, "Undef"
    .lex "$*SCOPE", $P24
.annotate 'line', 26
    new $P25, "Undef"
    .lex "$*MULTINESS", $P25
.annotate 'line', 27
    new $P26, "Undef"
    .lex "$*INVOCANT_OK", $P26
.annotate 'line', 28
    new $P27, "Undef"
    .lex "$*RETURN_USED", $P27
.annotate 'line', 29
    new $P28, "Undef"
    .lex "$*PACKAGE-SETUP", $P28
.annotate 'line', 4
    find_lex $P29, "%*LANG"
    unless_null $P29, vivify_402
    get_hll_global $P29, "%LANG"
    unless_null $P29, vivify_403
    die "Contextual %*LANG not found"
  vivify_403:
  vivify_402:
.annotate 'line', 6
    get_hll_global $P30, ["NQP"], "Regex"
    find_lex $P31, "%*LANG"
    unless_null $P31, vivify_404
    get_hll_global $P31, "%LANG"
    unless_null $P31, vivify_405
    die "Contextual %*LANG not found"
  vivify_405:
    store_lex "%*LANG", $P31
  vivify_404:
    set $P31["Regex"], $P30
.annotate 'line', 7
    get_hll_global $P32, ["NQP"], "RegexActions"
    find_lex $P33, "%*LANG"
    unless_null $P33, vivify_406
    get_hll_global $P33, "%LANG"
    unless_null $P33, vivify_407
    die "Contextual %*LANG not found"
  vivify_407:
    store_lex "%*LANG", $P33
  vivify_406:
    set $P33["Regex-actions"], $P32
.annotate 'line', 8
    get_hll_global $P34, ["NQP"], "Grammar"
    find_lex $P35, "%*LANG"
    unless_null $P35, vivify_408
    get_hll_global $P35, "%LANG"
    unless_null $P35, vivify_409
    die "Contextual %*LANG not found"
  vivify_409:
    store_lex "%*LANG", $P35
  vivify_408:
    set $P35["MAIN"], $P34
.annotate 'line', 9
    get_hll_global $P36, ["NQP"], "Actions"
    find_lex $P37, "%*LANG"
    unless_null $P37, vivify_410
    get_hll_global $P37, "%LANG"
    unless_null $P37, vivify_411
    die "Contextual %*LANG not found"
  vivify_411:
    store_lex "%*LANG", $P37
  vivify_410:
    set $P37["MAIN-actions"], $P36
    find_lex $P38, "%*HOW"
    unless_null $P38, vivify_412
    get_hll_global $P38, "%HOW"
    unless_null $P38, vivify_413
    die "Contextual %*HOW not found"
  vivify_413:
  vivify_412:
.annotate 'line', 13
    get_hll_global $P39, "KnowHOW"
    find_lex $P40, "%*HOW"
    unless_null $P40, vivify_414
    get_hll_global $P40, "%HOW"
    unless_null $P40, vivify_415
    die "Contextual %*HOW not found"
  vivify_415:
    store_lex "%*HOW", $P40
  vivify_414:
    set $P40["knowhow"], $P39
.annotate 'line', 14
    get_hll_global $P41, "NQPModuleHOW"
    find_lex $P42, "%*HOW"
    unless_null $P42, vivify_416
    get_hll_global $P42, "%HOW"
    unless_null $P42, vivify_417
    die "Contextual %*HOW not found"
  vivify_417:
    store_lex "%*HOW", $P42
  vivify_416:
    set $P42["module"], $P41
.annotate 'line', 15
    get_hll_global $P43, "NQPClassHOW"
    find_lex $P44, "%*HOW"
    unless_null $P44, vivify_418
    get_hll_global $P44, "%HOW"
    unless_null $P44, vivify_419
    die "Contextual %*HOW not found"
  vivify_419:
    store_lex "%*HOW", $P44
  vivify_418:
    set $P44["class"], $P43
.annotate 'line', 16
    get_hll_global $P45, "NQPClassHOW"
    find_lex $P46, "%*HOW"
    unless_null $P46, vivify_420
    get_hll_global $P46, "%HOW"
    unless_null $P46, vivify_421
    die "Contextual %*HOW not found"
  vivify_421:
    store_lex "%*HOW", $P46
  vivify_420:
    set $P46["grammar"], $P45
.annotate 'line', 17
    get_hll_global $P47, "NQPParametricRoleHOW"
    find_lex $P48, "%*HOW"
    unless_null $P48, vivify_422
    get_hll_global $P48, "%HOW"
    unless_null $P48, vivify_423
    die "Contextual %*HOW not found"
  vivify_423:
    store_lex "%*HOW", $P48
  vivify_422:
    set $P48["role"], $P47
.annotate 'line', 18
    get_hll_global $P49, "NQPNativeHOW"
    find_lex $P50, "%*HOW"
    unless_null $P50, vivify_424
    get_hll_global $P50, "%HOW"
    unless_null $P50, vivify_425
    die "Contextual %*HOW not found"
  vivify_425:
    store_lex "%*HOW", $P50
  vivify_424:
    set $P50["native"], $P49
.annotate 'line', 21
    new $P51, "String"
    assign $P51, "NQPAttribute"
    store_lex "$*DEFAULT-METAATTR", $P51
    find_lex $P52, "%*HOW-METAATTR"
    unless_null $P52, vivify_426
    get_hll_global $P52, "%HOW-METAATTR"
    unless_null $P52, vivify_427
    die "Contextual %*HOW-METAATTR not found"
  vivify_427:
  vivify_426:
.annotate 'line', 23
    new $P53, "String"
    assign $P53, "KnowHOWAttribute"
    find_lex $P54, "%*HOW-METAATTR"
    unless_null $P54, vivify_428
    get_hll_global $P54, "%HOW-METAATTR"
    unless_null $P54, vivify_429
    die "Contextual %*HOW-METAATTR not found"
  vivify_429:
    store_lex "%*HOW-METAATTR", $P54
  vivify_428:
    set $P54["knowhow"], $P53
.annotate 'line', 25
    new $P55, "String"
    assign $P55, ""
    store_lex "$*SCOPE", $P55
.annotate 'line', 26
    new $P56, "String"
    assign $P56, ""
    store_lex "$*MULTINESS", $P56
.annotate 'line', 27
    new $P57, "Integer"
    assign $P57, 0
    store_lex "$*INVOCANT_OK", $P57
.annotate 'line', 28
    new $P58, "Integer"
    assign $P58, 0
    store_lex "$*RETURN_USED", $P58
    find_lex $P59, "$*PACKAGE-SETUP"
    unless_null $P59, vivify_430
    get_hll_global $P59, "$PACKAGE-SETUP"
    unless_null $P59, vivify_431
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_431:
  vivify_430:
.annotate 'line', 30
    find_lex $P60, "self"
    $P61 = $P60."comp_unit"()
.annotate 'line', 4
    .return ($P61)
.end


.namespace ["NQP";"Grammar"]
.sub "identifier"  :subid("13_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx63_tgt
    .local int rx63_pos
    .local int rx63_off
    .local int rx63_eos
    .local int rx63_rep
    .local pmc rx63_cur
    .local pmc rx63_debug
    (rx63_cur, rx63_pos, rx63_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx63_cur
    .local pmc match
    .lex "$/", match
    length rx63_eos, rx63_tgt
    gt rx63_pos, rx63_eos, rx63_done
    set rx63_off, 0
    lt rx63_pos, 2, rx63_start
    sub rx63_off, rx63_pos, 1
    substr rx63_tgt, rx63_tgt, rx63_off
  rx63_start:
    eq $I10, 1, rx63_restart
    if_null rx63_debug, debug_432
    rx63_cur."!cursor_debug"("START", "identifier")
  debug_432:
    $I10 = self.'from'()
    ne $I10, -1, rxscan67_done
    goto rxscan67_scan
  rxscan67_loop:
    (rx63_pos) = rx63_cur."from"()
    inc rx63_pos
    rx63_cur."!cursor_from"(rx63_pos)
    ge rx63_pos, rx63_eos, rxscan67_done
  rxscan67_scan:
    set_addr $I10, rxscan67_loop
    rx63_cur."!mark_push"(0, rx63_pos, $I10)
  rxscan67_done:
.annotate 'line', 35
  # rx subrule "ident" subtype=method negate=
    rx63_cur."!cursor_pos"(rx63_pos)
    $P10 = rx63_cur."ident"()
    unless $P10, rx63_fail
    rx63_pos = $P10."pos"()
  # rx rxquantr68 ** 0..*
    set_addr $I10, rxquantr68_done
    rx63_cur."!mark_push"(0, rx63_pos, $I10)
  rxquantr68_loop:
  # rx enumcharlist negate=0 
    ge rx63_pos, rx63_eos, rx63_fail
    sub $I10, rx63_pos, rx63_off
    substr $S10, rx63_tgt, $I10, 1
    index $I11, "-'", $S10
    lt $I11, 0, rx63_fail
    inc rx63_pos
  # rx subrule "ident" subtype=method negate=
    rx63_cur."!cursor_pos"(rx63_pos)
    $P10 = rx63_cur."ident"()
    unless $P10, rx63_fail
    rx63_pos = $P10."pos"()
    set_addr $I10, rxquantr68_done
    (rx63_rep) = rx63_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr68_done
    rx63_cur."!mark_push"(rx63_rep, rx63_pos, $I10)
    goto rxquantr68_loop
  rxquantr68_done:
  # rx pass
    rx63_cur."!cursor_pass"(rx63_pos, "identifier")
    if_null rx63_debug, debug_433
    rx63_cur."!cursor_debug"("PASS", "identifier", " at pos=", rx63_pos)
  debug_433:
    .return (rx63_cur)
  rx63_restart:
.annotate 'line', 4
    if_null rx63_debug, debug_434
    rx63_cur."!cursor_debug"("NEXT", "identifier")
  debug_434:
  rx63_fail:
    (rx63_rep, rx63_pos, $I10, $P10) = rx63_cur."!mark_fail"(0)
    lt rx63_pos, -1, rx63_done
    eq rx63_pos, -1, rx63_fail
    jump $I10
  rx63_done:
    rx63_cur."!cursor_fail"()
    if_null rx63_debug, debug_435
    rx63_cur."!cursor_debug"("FAIL", "identifier")
  debug_435:
    .return (rx63_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__identifier"  :nsentry("!PREFIX__identifier") :subid("14_1298325448.42642") :method
.annotate 'line', 4
    $P65 = self."!PREFIX__!subrule"("ident", "")
    new $P66, "ResizablePMCArray"
    push $P66, $P65
    .return ($P66)
.end


.namespace ["NQP";"Grammar"]
.sub "name"  :subid("15_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx70_tgt
    .local int rx70_pos
    .local int rx70_off
    .local int rx70_eos
    .local int rx70_rep
    .local pmc rx70_cur
    .local pmc rx70_debug
    (rx70_cur, rx70_pos, rx70_tgt, $I10) = self."!cursor_start"()
    rx70_cur."!cursor_caparray"("identifier")
    .lex unicode:"$\x{a2}", rx70_cur
    .local pmc match
    .lex "$/", match
    length rx70_eos, rx70_tgt
    gt rx70_pos, rx70_eos, rx70_done
    set rx70_off, 0
    lt rx70_pos, 2, rx70_start
    sub rx70_off, rx70_pos, 1
    substr rx70_tgt, rx70_tgt, rx70_off
  rx70_start:
    eq $I10, 1, rx70_restart
    if_null rx70_debug, debug_436
    rx70_cur."!cursor_debug"("START", "name")
  debug_436:
    $I10 = self.'from'()
    ne $I10, -1, rxscan73_done
    goto rxscan73_scan
  rxscan73_loop:
    (rx70_pos) = rx70_cur."from"()
    inc rx70_pos
    rx70_cur."!cursor_from"(rx70_pos)
    ge rx70_pos, rx70_eos, rxscan73_done
  rxscan73_scan:
    set_addr $I10, rxscan73_loop
    rx70_cur."!mark_push"(0, rx70_pos, $I10)
  rxscan73_done:
.annotate 'line', 37
  # rx rxquantr74 ** 1..*
    set_addr $I10, rxquantr74_done
    rx70_cur."!mark_push"(0, -1, $I10)
  rxquantr74_loop:
  # rx subrule "identifier" subtype=capture negate=
    rx70_cur."!cursor_pos"(rx70_pos)
    $P10 = rx70_cur."identifier"()
    unless $P10, rx70_fail
    goto rxsubrule75_pass
  rxsubrule75_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx70_fail
  rxsubrule75_pass:
    set_addr $I10, rxsubrule75_back
    rx70_cur."!mark_push"(0, rx70_pos, $I10, $P10)
    $P10."!cursor_names"("identifier")
    rx70_pos = $P10."pos"()
    set_addr $I10, rxquantr74_done
    (rx70_rep) = rx70_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr74_done
    rx70_cur."!mark_push"(rx70_rep, rx70_pos, $I10)
  # rx literal  "::"
    add $I11, rx70_pos, 2
    gt $I11, rx70_eos, rx70_fail
    sub $I11, rx70_pos, rx70_off
    substr $S10, rx70_tgt, $I11, 2
    ne $S10, "::", rx70_fail
    add rx70_pos, 2
    goto rxquantr74_loop
  rxquantr74_done:
  # rx pass
    rx70_cur."!cursor_pass"(rx70_pos, "name")
    if_null rx70_debug, debug_437
    rx70_cur."!cursor_debug"("PASS", "name", " at pos=", rx70_pos)
  debug_437:
    .return (rx70_cur)
  rx70_restart:
.annotate 'line', 4
    if_null rx70_debug, debug_438
    rx70_cur."!cursor_debug"("NEXT", "name")
  debug_438:
  rx70_fail:
    (rx70_rep, rx70_pos, $I10, $P10) = rx70_cur."!mark_fail"(0)
    lt rx70_pos, -1, rx70_done
    eq rx70_pos, -1, rx70_fail
    jump $I10
  rx70_done:
    rx70_cur."!cursor_fail"()
    if_null rx70_debug, debug_439
    rx70_cur."!cursor_debug"("FAIL", "name")
  debug_439:
    .return (rx70_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__name"  :nsentry("!PREFIX__name") :subid("16_1298325448.42642") :method
.annotate 'line', 4
    new $P72, "ResizablePMCArray"
    push $P72, ""
    .return ($P72)
.end


.namespace ["NQP";"Grammar"]
.sub "deflongname"  :subid("17_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx77_tgt
    .local int rx77_pos
    .local int rx77_off
    .local int rx77_eos
    .local int rx77_rep
    .local pmc rx77_cur
    .local pmc rx77_debug
    (rx77_cur, rx77_pos, rx77_tgt, $I10) = self."!cursor_start"()
    rx77_cur."!cursor_caparray"("colonpair")
    .lex unicode:"$\x{a2}", rx77_cur
    .local pmc match
    .lex "$/", match
    length rx77_eos, rx77_tgt
    gt rx77_pos, rx77_eos, rx77_done
    set rx77_off, 0
    lt rx77_pos, 2, rx77_start
    sub rx77_off, rx77_pos, 1
    substr rx77_tgt, rx77_tgt, rx77_off
  rx77_start:
    eq $I10, 1, rx77_restart
    if_null rx77_debug, debug_440
    rx77_cur."!cursor_debug"("START", "deflongname")
  debug_440:
    $I10 = self.'from'()
    ne $I10, -1, rxscan81_done
    goto rxscan81_scan
  rxscan81_loop:
    (rx77_pos) = rx77_cur."from"()
    inc rx77_pos
    rx77_cur."!cursor_from"(rx77_pos)
    ge rx77_pos, rx77_eos, rxscan81_done
  rxscan81_scan:
    set_addr $I10, rxscan81_loop
    rx77_cur."!mark_push"(0, rx77_pos, $I10)
  rxscan81_done:
.annotate 'line', 40
  # rx subrule "identifier" subtype=capture negate=
    rx77_cur."!cursor_pos"(rx77_pos)
    $P10 = rx77_cur."identifier"()
    unless $P10, rx77_fail
    rx77_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx77_pos = $P10."pos"()
  # rx rxquantr82 ** 0..1
    set_addr $I10, rxquantr82_done
    rx77_cur."!mark_push"(0, rx77_pos, $I10)
  rxquantr82_loop:
  # rx subrule "colonpair" subtype=capture negate=
    rx77_cur."!cursor_pos"(rx77_pos)
    $P10 = rx77_cur."colonpair"()
    unless $P10, rx77_fail
    goto rxsubrule83_pass
  rxsubrule83_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx77_fail
  rxsubrule83_pass:
    set_addr $I10, rxsubrule83_back
    rx77_cur."!mark_push"(0, rx77_pos, $I10, $P10)
    $P10."!cursor_names"("colonpair")
    rx77_pos = $P10."pos"()
    set_addr $I10, rxquantr82_done
    (rx77_rep) = rx77_cur."!mark_commit"($I10)
  rxquantr82_done:
.annotate 'line', 39
  # rx pass
    rx77_cur."!cursor_pass"(rx77_pos, "deflongname")
    if_null rx77_debug, debug_441
    rx77_cur."!cursor_debug"("PASS", "deflongname", " at pos=", rx77_pos)
  debug_441:
    .return (rx77_cur)
  rx77_restart:
.annotate 'line', 4
    if_null rx77_debug, debug_442
    rx77_cur."!cursor_debug"("NEXT", "deflongname")
  debug_442:
  rx77_fail:
    (rx77_rep, rx77_pos, $I10, $P10) = rx77_cur."!mark_fail"(0)
    lt rx77_pos, -1, rx77_done
    eq rx77_pos, -1, rx77_fail
    jump $I10
  rx77_done:
    rx77_cur."!cursor_fail"()
    if_null rx77_debug, debug_443
    rx77_cur."!cursor_debug"("FAIL", "deflongname")
  debug_443:
    .return (rx77_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__deflongname"  :nsentry("!PREFIX__deflongname") :subid("18_1298325448.42642") :method
.annotate 'line', 4
    $P79 = self."!PREFIX__!subrule"("identifier", "")
    new $P80, "ResizablePMCArray"
    push $P80, $P79
    .return ($P80)
.end


.namespace ["NQP";"Grammar"]
.sub "ENDSTMT"  :subid("19_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx85_tgt
    .local int rx85_pos
    .local int rx85_off
    .local int rx85_eos
    .local int rx85_rep
    .local pmc rx85_cur
    .local pmc rx85_debug
    (rx85_cur, rx85_pos, rx85_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx85_cur
    .local pmc match
    .lex "$/", match
    length rx85_eos, rx85_tgt
    gt rx85_pos, rx85_eos, rx85_done
    set rx85_off, 0
    lt rx85_pos, 2, rx85_start
    sub rx85_off, rx85_pos, 1
    substr rx85_tgt, rx85_tgt, rx85_off
  rx85_start:
    eq $I10, 1, rx85_restart
    if_null rx85_debug, debug_444
    rx85_cur."!cursor_debug"("START", "ENDSTMT")
  debug_444:
    $I10 = self.'from'()
    ne $I10, -1, rxscan88_done
    goto rxscan88_scan
  rxscan88_loop:
    (rx85_pos) = rx85_cur."from"()
    inc rx85_pos
    rx85_cur."!cursor_from"(rx85_pos)
    ge rx85_pos, rx85_eos, rxscan88_done
  rxscan88_scan:
    set_addr $I10, rxscan88_loop
    rx85_cur."!mark_push"(0, rx85_pos, $I10)
  rxscan88_done:
.annotate 'line', 47
  # rx rxquantr89 ** 0..1
    set_addr $I10, rxquantr89_done
    rx85_cur."!mark_push"(0, rx85_pos, $I10)
  rxquantr89_loop:
  alt90_0:
.annotate 'line', 44
    set_addr $I10, alt90_1
    rx85_cur."!mark_push"(0, rx85_pos, $I10)
.annotate 'line', 45
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx85_pos, rx85_off
    set rx85_rep, 0
    sub $I12, rx85_eos, rx85_pos
  rxenumcharlistq91_loop:
    le $I12, 0, rxenumcharlistq91_done
    substr $S10, rx85_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq91_done
    inc rx85_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq91_loop
  rxenumcharlistq91_done:
    add rx85_pos, rx85_pos, rx85_rep
  # rxanchor eol
    sub $I10, rx85_pos, rx85_off
    is_cclass $I11, 4096, rx85_tgt, $I10
    if $I11, rxanchor92_done
    ne rx85_pos, rx85_eos, rx85_fail
    eq rx85_pos, 0, rxanchor92_done
    dec $I10
    is_cclass $I11, 4096, rx85_tgt, $I10
    if $I11, rx85_fail
  rxanchor92_done:
  # rx subrule "ws" subtype=method negate=
    rx85_cur."!cursor_pos"(rx85_pos)
    $P10 = rx85_cur."ws"()
    unless $P10, rx85_fail
    rx85_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx85_cur."!cursor_pos"(rx85_pos)
    $P10 = rx85_cur."MARKER"("endstmt")
    unless $P10, rx85_fail
    goto alt90_end
  alt90_1:
.annotate 'line', 46
  # rx rxquantr93 ** 0..1
    set_addr $I10, rxquantr93_done
    rx85_cur."!mark_push"(0, rx85_pos, $I10)
  rxquantr93_loop:
  # rx subrule "unv" subtype=method negate=
    rx85_cur."!cursor_pos"(rx85_pos)
    $P10 = rx85_cur."unv"()
    unless $P10, rx85_fail
    goto rxsubrule94_pass
  rxsubrule94_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx85_fail
  rxsubrule94_pass:
    set_addr $I10, rxsubrule94_back
    rx85_cur."!mark_push"(0, rx85_pos, $I10, $P10)
    rx85_pos = $P10."pos"()
    set_addr $I10, rxquantr93_done
    (rx85_rep) = rx85_cur."!mark_commit"($I10)
  rxquantr93_done:
  # rxanchor eol
    sub $I10, rx85_pos, rx85_off
    is_cclass $I11, 4096, rx85_tgt, $I10
    if $I11, rxanchor95_done
    ne rx85_pos, rx85_eos, rx85_fail
    eq rx85_pos, 0, rxanchor95_done
    dec $I10
    is_cclass $I11, 4096, rx85_tgt, $I10
    if $I11, rx85_fail
  rxanchor95_done:
  # rx subrule "ws" subtype=method negate=
    rx85_cur."!cursor_pos"(rx85_pos)
    $P10 = rx85_cur."ws"()
    unless $P10, rx85_fail
    rx85_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx85_cur."!cursor_pos"(rx85_pos)
    $P10 = rx85_cur."MARKER"("endstmt")
    unless $P10, rx85_fail
  alt90_end:
.annotate 'line', 47
    set_addr $I10, rxquantr89_done
    (rx85_rep) = rx85_cur."!mark_commit"($I10)
  rxquantr89_done:
.annotate 'line', 43
  # rx pass
    rx85_cur."!cursor_pass"(rx85_pos, "ENDSTMT")
    if_null rx85_debug, debug_445
    rx85_cur."!cursor_debug"("PASS", "ENDSTMT", " at pos=", rx85_pos)
  debug_445:
    .return (rx85_cur)
  rx85_restart:
.annotate 'line', 4
    if_null rx85_debug, debug_446
    rx85_cur."!cursor_debug"("NEXT", "ENDSTMT")
  debug_446:
  rx85_fail:
    (rx85_rep, rx85_pos, $I10, $P10) = rx85_cur."!mark_fail"(0)
    lt rx85_pos, -1, rx85_done
    eq rx85_pos, -1, rx85_fail
    jump $I10
  rx85_done:
    rx85_cur."!cursor_fail"()
    if_null rx85_debug, debug_447
    rx85_cur."!cursor_debug"("FAIL", "ENDSTMT")
  debug_447:
    .return (rx85_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ENDSTMT"  :nsentry("!PREFIX__ENDSTMT") :subid("20_1298325448.42642") :method
.annotate 'line', 4
    new $P87, "ResizablePMCArray"
    push $P87, ""
    .return ($P87)
.end


.namespace ["NQP";"Grammar"]
.sub "ws"  :subid("21_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx97_tgt
    .local int rx97_pos
    .local int rx97_off
    .local int rx97_eos
    .local int rx97_rep
    .local pmc rx97_cur
    .local pmc rx97_debug
    (rx97_cur, rx97_pos, rx97_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx97_cur
    .local pmc match
    .lex "$/", match
    length rx97_eos, rx97_tgt
    gt rx97_pos, rx97_eos, rx97_done
    set rx97_off, 0
    lt rx97_pos, 2, rx97_start
    sub rx97_off, rx97_pos, 1
    substr rx97_tgt, rx97_tgt, rx97_off
  rx97_start:
    eq $I10, 1, rx97_restart
    if_null rx97_debug, debug_448
    rx97_cur."!cursor_debug"("START", "ws")
  debug_448:
    $I10 = self.'from'()
    ne $I10, -1, rxscan100_done
    goto rxscan100_scan
  rxscan100_loop:
    (rx97_pos) = rx97_cur."from"()
    inc rx97_pos
    rx97_cur."!cursor_from"(rx97_pos)
    ge rx97_pos, rx97_eos, rxscan100_done
  rxscan100_scan:
    set_addr $I10, rxscan100_loop
    rx97_cur."!mark_push"(0, rx97_pos, $I10)
  rxscan100_done:
  alt101_0:
.annotate 'line', 50
    set_addr $I10, alt101_1
    rx97_cur."!mark_push"(0, rx97_pos, $I10)
.annotate 'line', 51
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx97_cur."!cursor_pos"(rx97_pos)
    $P10 = rx97_cur."MARKED"("ws")
    unless $P10, rx97_fail
    goto alt101_end
  alt101_1:
.annotate 'line', 52
  # rx subrule "ww" subtype=zerowidth negate=1
    rx97_cur."!cursor_pos"(rx97_pos)
    $P10 = rx97_cur."ww"()
    if $P10, rx97_fail
.annotate 'line', 57
  # rx rxquantr102 ** 0..*
    set_addr $I10, rxquantr102_done
    rx97_cur."!mark_push"(0, rx97_pos, $I10)
  rxquantr102_loop:
  alt103_0:
.annotate 'line', 53
    set_addr $I10, alt103_1
    rx97_cur."!mark_push"(0, rx97_pos, $I10)
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx97_pos, rx97_off
    set rx97_rep, 0
    sub $I12, rx97_eos, rx97_pos
  rxenumcharlistq104_loop:
    le $I12, 0, rxenumcharlistq104_done
    substr $S10, rx97_tgt, $I10, 1
    index $I11, unicode:"\n\x{b}\f\r\x{85}\u2028\u2029", $S10
    lt $I11, 0, rxenumcharlistq104_done
    inc rx97_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq104_loop
  rxenumcharlistq104_done:
    lt rx97_rep, 1, rx97_fail
    add rx97_pos, rx97_pos, rx97_rep
    goto alt103_end
  alt103_1:
    set_addr $I10, alt103_2
    rx97_cur."!mark_push"(0, rx97_pos, $I10)
.annotate 'line', 54
  # rx literal  "#"
    add $I11, rx97_pos, 1
    gt $I11, rx97_eos, rx97_fail
    sub $I11, rx97_pos, rx97_off
    ord $I11, rx97_tgt, $I11
    ne $I11, 35, rx97_fail
    add rx97_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx97_pos, rx97_off
    find_cclass $I11, 4096, rx97_tgt, $I10, rx97_eos
    add rx97_pos, rx97_off, $I11
    goto alt103_end
  alt103_2:
    set_addr $I10, alt103_3
    rx97_cur."!mark_push"(0, rx97_pos, $I10)
.annotate 'line', 55
  # rxanchor bol
    eq rx97_pos, 0, rxanchor105_done
    ge rx97_pos, rx97_eos, rx97_fail
    sub $I10, rx97_pos, rx97_off
    dec $I10
    is_cclass $I11, 4096, rx97_tgt, $I10
    unless $I11, rx97_fail
  rxanchor105_done:
  # rx subrule "pod_comment" subtype=method negate=
    rx97_cur."!cursor_pos"(rx97_pos)
    $P10 = rx97_cur."pod_comment"()
    unless $P10, rx97_fail
    rx97_pos = $P10."pos"()
    goto alt103_end
  alt103_3:
.annotate 'line', 56
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx97_pos, rx97_off
    set rx97_rep, 0
    sub $I12, rx97_eos, rx97_pos
  rxenumcharlistq106_loop:
    le $I12, 0, rxenumcharlistq106_done
    substr $S10, rx97_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq106_done
    inc rx97_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq106_loop
  rxenumcharlistq106_done:
    lt rx97_rep, 1, rx97_fail
    add rx97_pos, rx97_pos, rx97_rep
  alt103_end:
.annotate 'line', 57
    set_addr $I10, rxquantr102_done
    (rx97_rep) = rx97_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr102_done
    rx97_cur."!mark_push"(rx97_rep, rx97_pos, $I10)
    goto rxquantr102_loop
  rxquantr102_done:
.annotate 'line', 58
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx97_cur."!cursor_pos"(rx97_pos)
    $P10 = rx97_cur."MARKER"("ws")
    unless $P10, rx97_fail
  alt101_end:
.annotate 'line', 50
  # rx pass
    rx97_cur."!cursor_pass"(rx97_pos, "ws")
    if_null rx97_debug, debug_449
    rx97_cur."!cursor_debug"("PASS", "ws", " at pos=", rx97_pos)
  debug_449:
    .return (rx97_cur)
  rx97_restart:
.annotate 'line', 4
    if_null rx97_debug, debug_450
    rx97_cur."!cursor_debug"("NEXT", "ws")
  debug_450:
  rx97_fail:
    (rx97_rep, rx97_pos, $I10, $P10) = rx97_cur."!mark_fail"(0)
    lt rx97_pos, -1, rx97_done
    eq rx97_pos, -1, rx97_fail
    jump $I10
  rx97_done:
    rx97_cur."!cursor_fail"()
    if_null rx97_debug, debug_451
    rx97_cur."!cursor_debug"("FAIL", "ws")
  debug_451:
    .return (rx97_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ws"  :nsentry("!PREFIX__ws") :subid("22_1298325448.42642") :method
.annotate 'line', 4
    new $P99, "ResizablePMCArray"
    push $P99, ""
    push $P99, ""
    .return ($P99)
.end


.namespace ["NQP";"Grammar"]
.sub "unv"  :subid("23_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .const 'Sub' $P115 = "25_1298325448.42642" 
    capture_lex $P115
    .local string rx108_tgt
    .local int rx108_pos
    .local int rx108_off
    .local int rx108_eos
    .local int rx108_rep
    .local pmc rx108_cur
    .local pmc rx108_debug
    (rx108_cur, rx108_pos, rx108_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx108_cur
    .local pmc match
    .lex "$/", match
    length rx108_eos, rx108_tgt
    gt rx108_pos, rx108_eos, rx108_done
    set rx108_off, 0
    lt rx108_pos, 2, rx108_start
    sub rx108_off, rx108_pos, 1
    substr rx108_tgt, rx108_tgt, rx108_off
  rx108_start:
    eq $I10, 1, rx108_restart
    if_null rx108_debug, debug_452
    rx108_cur."!cursor_debug"("START", "unv")
  debug_452:
    $I10 = self.'from'()
    ne $I10, -1, rxscan111_done
    goto rxscan111_scan
  rxscan111_loop:
    (rx108_pos) = rx108_cur."from"()
    inc rx108_pos
    rx108_cur."!cursor_from"(rx108_pos)
    ge rx108_pos, rx108_eos, rxscan111_done
  rxscan111_scan:
    set_addr $I10, rxscan111_loop
    rx108_cur."!mark_push"(0, rx108_pos, $I10)
  rxscan111_done:
  alt112_0:
.annotate 'line', 63
    set_addr $I10, alt112_1
    rx108_cur."!mark_push"(0, rx108_pos, $I10)
.annotate 'line', 64
  # rxanchor bol
    eq rx108_pos, 0, rxanchor113_done
    ge rx108_pos, rx108_eos, rx108_fail
    sub $I10, rx108_pos, rx108_off
    dec $I10
    is_cclass $I11, 4096, rx108_tgt, $I10
    unless $I11, rx108_fail
  rxanchor113_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx108_cur."!cursor_pos"(rx108_pos)
    .const 'Sub' $P115 = "25_1298325448.42642" 
    capture_lex $P115
    $P10 = rx108_cur."before"($P115)
    unless $P10, rx108_fail
  # rx subrule "pod_comment" subtype=method negate=
    rx108_cur."!cursor_pos"(rx108_pos)
    $P10 = rx108_cur."pod_comment"()
    unless $P10, rx108_fail
    rx108_pos = $P10."pos"()
    goto alt112_end
  alt112_1:
    set_addr $I10, alt112_2
    rx108_cur."!mark_push"(0, rx108_pos, $I10)
.annotate 'line', 65
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx108_pos, rx108_off
    set rx108_rep, 0
    sub $I12, rx108_eos, rx108_pos
  rxenumcharlistq120_loop:
    le $I12, 0, rxenumcharlistq120_done
    substr $S10, rx108_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq120_done
    inc rx108_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq120_loop
  rxenumcharlistq120_done:
    add rx108_pos, rx108_pos, rx108_rep
  # rx literal  "#"
    add $I11, rx108_pos, 1
    gt $I11, rx108_eos, rx108_fail
    sub $I11, rx108_pos, rx108_off
    ord $I11, rx108_tgt, $I11
    ne $I11, 35, rx108_fail
    add rx108_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx108_pos, rx108_off
    find_cclass $I11, 4096, rx108_tgt, $I10, rx108_eos
    add rx108_pos, rx108_off, $I11
    goto alt112_end
  alt112_2:
.annotate 'line', 66
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx108_pos, rx108_off
    set rx108_rep, 0
    sub $I12, rx108_eos, rx108_pos
  rxenumcharlistq121_loop:
    le $I12, 0, rxenumcharlistq121_done
    substr $S10, rx108_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq121_done
    inc rx108_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq121_loop
  rxenumcharlistq121_done:
    lt rx108_rep, 1, rx108_fail
    add rx108_pos, rx108_pos, rx108_rep
  alt112_end:
.annotate 'line', 61
  # rx pass
    rx108_cur."!cursor_pass"(rx108_pos, "unv")
    if_null rx108_debug, debug_457
    rx108_cur."!cursor_debug"("PASS", "unv", " at pos=", rx108_pos)
  debug_457:
    .return (rx108_cur)
  rx108_restart:
.annotate 'line', 4
    if_null rx108_debug, debug_458
    rx108_cur."!cursor_debug"("NEXT", "unv")
  debug_458:
  rx108_fail:
    (rx108_rep, rx108_pos, $I10, $P10) = rx108_cur."!mark_fail"(0)
    lt rx108_pos, -1, rx108_done
    eq rx108_pos, -1, rx108_fail
    jump $I10
  rx108_done:
    rx108_cur."!cursor_fail"()
    if_null rx108_debug, debug_459
    rx108_cur."!cursor_debug"("FAIL", "unv")
  debug_459:
    .return (rx108_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__unv"  :nsentry("!PREFIX__unv") :subid("24_1298325448.42642") :method
.annotate 'line', 4
    new $P110, "ResizablePMCArray"
    push $P110, ""
    push $P110, ""
    push $P110, ""
    .return ($P110)
.end


.namespace ["NQP";"Grammar"]
.sub "_block114"  :anon :subid("25_1298325448.42642") :method :outer("23_1298325448.42642")
.annotate 'line', 64
    .local string rx116_tgt
    .local int rx116_pos
    .local int rx116_off
    .local int rx116_eos
    .local int rx116_rep
    .local pmc rx116_cur
    .local pmc rx116_debug
    (rx116_cur, rx116_pos, rx116_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx116_cur
    .local pmc match
    .lex "$/", match
    length rx116_eos, rx116_tgt
    gt rx116_pos, rx116_eos, rx116_done
    set rx116_off, 0
    lt rx116_pos, 2, rx116_start
    sub rx116_off, rx116_pos, 1
    substr rx116_tgt, rx116_tgt, rx116_off
  rx116_start:
    eq $I10, 1, rx116_restart
    if_null rx116_debug, debug_453
    rx116_cur."!cursor_debug"("START", "")
  debug_453:
    $I10 = self.'from'()
    ne $I10, -1, rxscan117_done
    goto rxscan117_scan
  rxscan117_loop:
    (rx116_pos) = rx116_cur."from"()
    inc rx116_pos
    rx116_cur."!cursor_from"(rx116_pos)
    ge rx116_pos, rx116_eos, rxscan117_done
  rxscan117_scan:
    set_addr $I10, rxscan117_loop
    rx116_cur."!mark_push"(0, rx116_pos, $I10)
  rxscan117_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx116_pos, rx116_off
    set rx116_rep, 0
    sub $I12, rx116_eos, rx116_pos
  rxenumcharlistq118_loop:
    le $I12, 0, rxenumcharlistq118_done
    substr $S10, rx116_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq118_done
    inc rx116_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq118_loop
  rxenumcharlistq118_done:
    add rx116_pos, rx116_pos, rx116_rep
  # rx literal  "="
    add $I11, rx116_pos, 1
    gt $I11, rx116_eos, rx116_fail
    sub $I11, rx116_pos, rx116_off
    ord $I11, rx116_tgt, $I11
    ne $I11, 61, rx116_fail
    add rx116_pos, 1
  alt119_0:
    set_addr $I10, alt119_1
    rx116_cur."!mark_push"(0, rx116_pos, $I10)
  # rx charclass w
    ge rx116_pos, rx116_eos, rx116_fail
    sub $I10, rx116_pos, rx116_off
    is_cclass $I11, 8192, rx116_tgt, $I10
    unless $I11, rx116_fail
    inc rx116_pos
    goto alt119_end
  alt119_1:
  # rx literal  "\\"
    add $I11, rx116_pos, 1
    gt $I11, rx116_eos, rx116_fail
    sub $I11, rx116_pos, rx116_off
    ord $I11, rx116_tgt, $I11
    ne $I11, 92, rx116_fail
    add rx116_pos, 1
  alt119_end:
  # rx pass
    rx116_cur."!cursor_pass"(rx116_pos, "")
    if_null rx116_debug, debug_454
    rx116_cur."!cursor_debug"("PASS", "", " at pos=", rx116_pos)
  debug_454:
    .return (rx116_cur)
  rx116_restart:
    if_null rx116_debug, debug_455
    rx116_cur."!cursor_debug"("NEXT", "")
  debug_455:
  rx116_fail:
    (rx116_rep, rx116_pos, $I10, $P10) = rx116_cur."!mark_fail"(0)
    lt rx116_pos, -1, rx116_done
    eq rx116_pos, -1, rx116_fail
    jump $I10
  rx116_done:
    rx116_cur."!cursor_fail"()
    if_null rx116_debug, debug_456
    rx116_cur."!cursor_debug"("FAIL", "")
  debug_456:
    .return (rx116_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "pod_comment"  :subid("26_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .const 'Sub' $P154 = "28_1298325448.42642" 
    capture_lex $P154
    .local string rx123_tgt
    .local int rx123_pos
    .local int rx123_off
    .local int rx123_eos
    .local int rx123_rep
    .local pmc rx123_cur
    .local pmc rx123_debug
    (rx123_cur, rx123_pos, rx123_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx123_cur
    .local pmc match
    .lex "$/", match
    length rx123_eos, rx123_tgt
    gt rx123_pos, rx123_eos, rx123_done
    set rx123_off, 0
    lt rx123_pos, 2, rx123_start
    sub rx123_off, rx123_pos, 1
    substr rx123_tgt, rx123_tgt, rx123_off
  rx123_start:
    eq $I10, 1, rx123_restart
    if_null rx123_debug, debug_460
    rx123_cur."!cursor_debug"("START", "pod_comment")
  debug_460:
    $I10 = self.'from'()
    ne $I10, -1, rxscan126_done
    goto rxscan126_scan
  rxscan126_loop:
    (rx123_pos) = rx123_cur."from"()
    inc rx123_pos
    rx123_cur."!cursor_from"(rx123_pos)
    ge rx123_pos, rx123_eos, rxscan126_done
  rxscan126_scan:
    set_addr $I10, rxscan126_loop
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
  rxscan126_done:
.annotate 'line', 71
  # rxanchor bol
    eq rx123_pos, 0, rxanchor127_done
    ge rx123_pos, rx123_eos, rx123_fail
    sub $I10, rx123_pos, rx123_off
    dec $I10
    is_cclass $I11, 4096, rx123_tgt, $I10
    unless $I11, rx123_fail
  rxanchor127_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx123_pos, rx123_off
    set rx123_rep, 0
    sub $I12, rx123_eos, rx123_pos
  rxenumcharlistq128_loop:
    le $I12, 0, rxenumcharlistq128_done
    substr $S10, rx123_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq128_done
    inc rx123_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq128_loop
  rxenumcharlistq128_done:
    add rx123_pos, rx123_pos, rx123_rep
  # rx literal  "="
    add $I11, rx123_pos, 1
    gt $I11, rx123_eos, rx123_fail
    sub $I11, rx123_pos, rx123_off
    ord $I11, rx123_tgt, $I11
    ne $I11, 61, rx123_fail
    add rx123_pos, 1
  alt129_0:
.annotate 'line', 72
    set_addr $I10, alt129_1
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
.annotate 'line', 73
  # rx literal  "begin"
    add $I11, rx123_pos, 5
    gt $I11, rx123_eos, rx123_fail
    sub $I11, rx123_pos, rx123_off
    substr $S10, rx123_tgt, $I11, 5
    ne $S10, "begin", rx123_fail
    add rx123_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx123_pos, rx123_off
    set rx123_rep, 0
    sub $I12, rx123_eos, rx123_pos
  rxenumcharlistq130_loop:
    le $I12, 0, rxenumcharlistq130_done
    substr $S10, rx123_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq130_done
    inc rx123_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq130_loop
  rxenumcharlistq130_done:
    lt rx123_rep, 1, rx123_fail
    add rx123_pos, rx123_pos, rx123_rep
  # rx literal  "END"
    add $I11, rx123_pos, 3
    gt $I11, rx123_eos, rx123_fail
    sub $I11, rx123_pos, rx123_off
    substr $S10, rx123_tgt, $I11, 3
    ne $S10, "END", rx123_fail
    add rx123_pos, 3
  # rxanchor rwb
    le rx123_pos, 0, rx123_fail
    sub $I10, rx123_pos, rx123_off
    is_cclass $I11, 8192, rx123_tgt, $I10
    if $I11, rx123_fail
    dec $I10
    is_cclass $I11, 8192, rx123_tgt, $I10
    unless $I11, rx123_fail
  alt131_0:
.annotate 'line', 74
    set_addr $I10, alt131_1
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
  # rx rxquantf132 ** 0..*
    set_addr $I10, rxquantf132_loop
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
    goto rxquantf132_done
  rxquantf132_loop:
  # rx charclass .
    ge rx123_pos, rx123_eos, rx123_fail
    inc rx123_pos
    set_addr $I10, rxquantf132_loop
    rx123_cur."!mark_push"(rx123_rep, rx123_pos, $I10)
  rxquantf132_done:
  # rx charclass nl
    ge rx123_pos, rx123_eos, rx123_fail
    sub $I10, rx123_pos, rx123_off
    is_cclass $I11, 4096, rx123_tgt, $I10
    unless $I11, rx123_fail
    substr $S10, rx123_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx123_pos, $I11
    inc rx123_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx123_pos, rx123_off
    set rx123_rep, 0
    sub $I12, rx123_eos, rx123_pos
  rxenumcharlistq134_loop:
    le $I12, 0, rxenumcharlistq134_done
    substr $S10, rx123_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq134_done
    inc rx123_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq134_loop
  rxenumcharlistq134_done:
    add rx123_pos, rx123_pos, rx123_rep
  # rx literal  "=end"
    add $I11, rx123_pos, 4
    gt $I11, rx123_eos, rx123_fail
    sub $I11, rx123_pos, rx123_off
    substr $S10, rx123_tgt, $I11, 4
    ne $S10, "=end", rx123_fail
    add rx123_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx123_pos, rx123_off
    set rx123_rep, 0
    sub $I12, rx123_eos, rx123_pos
  rxenumcharlistq135_loop:
    le $I12, 0, rxenumcharlistq135_done
    substr $S10, rx123_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq135_done
    inc rx123_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq135_loop
  rxenumcharlistq135_done:
    lt rx123_rep, 1, rx123_fail
    add rx123_pos, rx123_pos, rx123_rep
  # rx literal  "END"
    add $I11, rx123_pos, 3
    gt $I11, rx123_eos, rx123_fail
    sub $I11, rx123_pos, rx123_off
    substr $S10, rx123_tgt, $I11, 3
    ne $S10, "END", rx123_fail
    add rx123_pos, 3
  # rxanchor rwb
    le rx123_pos, 0, rx123_fail
    sub $I10, rx123_pos, rx123_off
    is_cclass $I11, 8192, rx123_tgt, $I10
    if $I11, rx123_fail
    dec $I10
    is_cclass $I11, 8192, rx123_tgt, $I10
    unless $I11, rx123_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx123_pos, rx123_off
    find_cclass $I11, 4096, rx123_tgt, $I10, rx123_eos
    add rx123_pos, rx123_off, $I11
    goto alt131_end
  alt131_1:
  # rx charclass_q . r 0..-1
    sub $I10, rx123_pos, rx123_off
    find_not_cclass $I11, 65535, rx123_tgt, $I10, rx123_eos
    add rx123_pos, rx123_off, $I11
  alt131_end:
.annotate 'line', 73
    goto alt129_end
  alt129_1:
    set_addr $I10, alt129_2
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
.annotate 'line', 75
  # rx literal  "begin"
    add $I11, rx123_pos, 5
    gt $I11, rx123_eos, rx123_fail
    sub $I11, rx123_pos, rx123_off
    substr $S10, rx123_tgt, $I11, 5
    ne $S10, "begin", rx123_fail
    add rx123_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx123_pos, rx123_off
    set rx123_rep, 0
    sub $I12, rx123_eos, rx123_pos
  rxenumcharlistq136_loop:
    le $I12, 0, rxenumcharlistq136_done
    substr $S10, rx123_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq136_done
    inc rx123_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq136_loop
  rxenumcharlistq136_done:
    lt rx123_rep, 1, rx123_fail
    add rx123_pos, rx123_pos, rx123_rep
  # rx subrule "identifier" subtype=capture negate=
    rx123_cur."!cursor_pos"(rx123_pos)
    $P10 = rx123_cur."identifier"()
    unless $P10, rx123_fail
    rx123_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx123_pos = $P10."pos"()
  alt137_0:
.annotate 'line', 76
    set_addr $I10, alt137_1
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
.annotate 'line', 77
  # rx rxquantf138 ** 0..*
    set_addr $I10, rxquantf138_loop
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
    goto rxquantf138_done
  rxquantf138_loop:
  # rx charclass .
    ge rx123_pos, rx123_eos, rx123_fail
    inc rx123_pos
    set_addr $I10, rxquantf138_loop
    rx123_cur."!mark_push"(rx123_rep, rx123_pos, $I10)
  rxquantf138_done:
  # rx charclass nl
    ge rx123_pos, rx123_eos, rx123_fail
    sub $I10, rx123_pos, rx123_off
    is_cclass $I11, 4096, rx123_tgt, $I10
    unless $I11, rx123_fail
    substr $S10, rx123_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx123_pos, $I11
    inc rx123_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx123_pos, rx123_off
    set rx123_rep, 0
    sub $I12, rx123_eos, rx123_pos
  rxenumcharlistq140_loop:
    le $I12, 0, rxenumcharlistq140_done
    substr $S10, rx123_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq140_done
    inc rx123_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq140_loop
  rxenumcharlistq140_done:
    add rx123_pos, rx123_pos, rx123_rep
  # rx literal  "=end"
    add $I11, rx123_pos, 4
    gt $I11, rx123_eos, rx123_fail
    sub $I11, rx123_pos, rx123_off
    substr $S10, rx123_tgt, $I11, 4
    ne $S10, "=end", rx123_fail
    add rx123_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx123_pos, rx123_off
    set rx123_rep, 0
    sub $I12, rx123_eos, rx123_pos
  rxenumcharlistq141_loop:
    le $I12, 0, rxenumcharlistq141_done
    substr $S10, rx123_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq141_done
    inc rx123_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq141_loop
  rxenumcharlistq141_done:
    lt rx123_rep, 1, rx123_fail
    add rx123_pos, rx123_pos, rx123_rep
  # rx subrule "!BACKREF" subtype=method negate=
    rx123_cur."!cursor_pos"(rx123_pos)
    $P10 = rx123_cur."!BACKREF"("identifier")
    unless $P10, rx123_fail
    rx123_pos = $P10."pos"()
  # rxanchor rwb
    le rx123_pos, 0, rx123_fail
    sub $I10, rx123_pos, rx123_off
    is_cclass $I11, 8192, rx123_tgt, $I10
    if $I11, rx123_fail
    dec $I10
    is_cclass $I11, 8192, rx123_tgt, $I10
    unless $I11, rx123_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx123_pos, rx123_off
    find_cclass $I11, 4096, rx123_tgt, $I10, rx123_eos
    add rx123_pos, rx123_off, $I11
    goto alt137_end
  alt137_1:
.annotate 'line', 78
  # rx subrule "panic" subtype=method negate=
    rx123_cur."!cursor_pos"(rx123_pos)
    $P10 = rx123_cur."panic"("=begin without matching =end")
    unless $P10, rx123_fail
    rx123_pos = $P10."pos"()
  alt137_end:
.annotate 'line', 75
    goto alt129_end
  alt129_2:
    set_addr $I10, alt129_3
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
.annotate 'line', 80
  # rx literal  "begin"
    add $I11, rx123_pos, 5
    gt $I11, rx123_eos, rx123_fail
    sub $I11, rx123_pos, rx123_off
    substr $S10, rx123_tgt, $I11, 5
    ne $S10, "begin", rx123_fail
    add rx123_pos, 5
  # rxanchor rwb
    le rx123_pos, 0, rx123_fail
    sub $I10, rx123_pos, rx123_off
    is_cclass $I11, 8192, rx123_tgt, $I10
    if $I11, rx123_fail
    dec $I10
    is_cclass $I11, 8192, rx123_tgt, $I10
    unless $I11, rx123_fail
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx123_pos, rx123_off
    set rx123_rep, 0
    sub $I12, rx123_eos, rx123_pos
  rxenumcharlistq143_loop:
    le $I12, 0, rxenumcharlistq143_done
    substr $S10, rx123_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq143_done
    inc rx123_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq143_loop
  rxenumcharlistq143_done:
    add rx123_pos, rx123_pos, rx123_rep
  alt144_0:
.annotate 'line', 81
    set_addr $I10, alt144_1
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
  # rxanchor eol
    sub $I10, rx123_pos, rx123_off
    is_cclass $I11, 4096, rx123_tgt, $I10
    if $I11, rxanchor145_done
    ne rx123_pos, rx123_eos, rx123_fail
    eq rx123_pos, 0, rxanchor145_done
    dec $I10
    is_cclass $I11, 4096, rx123_tgt, $I10
    if $I11, rx123_fail
  rxanchor145_done:
    goto alt144_end
  alt144_1:
    set_addr $I10, alt144_2
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
  # rx literal  "#"
    add $I11, rx123_pos, 1
    gt $I11, rx123_eos, rx123_fail
    sub $I11, rx123_pos, rx123_off
    ord $I11, rx123_tgt, $I11
    ne $I11, 35, rx123_fail
    add rx123_pos, 1
    goto alt144_end
  alt144_2:
  # rx subrule "panic" subtype=method negate=
    rx123_cur."!cursor_pos"(rx123_pos)
    $P10 = rx123_cur."panic"("Unrecognized token after =begin")
    unless $P10, rx123_fail
    rx123_pos = $P10."pos"()
  alt144_end:
  alt146_0:
.annotate 'line', 82
    set_addr $I10, alt146_1
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
.annotate 'line', 83
  # rx rxquantf147 ** 0..*
    set_addr $I10, rxquantf147_loop
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
    goto rxquantf147_done
  rxquantf147_loop:
  # rx charclass .
    ge rx123_pos, rx123_eos, rx123_fail
    inc rx123_pos
    set_addr $I10, rxquantf147_loop
    rx123_cur."!mark_push"(rx123_rep, rx123_pos, $I10)
  rxquantf147_done:
  # rx charclass nl
    ge rx123_pos, rx123_eos, rx123_fail
    sub $I10, rx123_pos, rx123_off
    is_cclass $I11, 4096, rx123_tgt, $I10
    unless $I11, rx123_fail
    substr $S10, rx123_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx123_pos, $I11
    inc rx123_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx123_pos, rx123_off
    set rx123_rep, 0
    sub $I12, rx123_eos, rx123_pos
  rxenumcharlistq149_loop:
    le $I12, 0, rxenumcharlistq149_done
    substr $S10, rx123_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq149_done
    inc rx123_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq149_loop
  rxenumcharlistq149_done:
    add rx123_pos, rx123_pos, rx123_rep
  # rx literal  "=end"
    add $I11, rx123_pos, 4
    gt $I11, rx123_eos, rx123_fail
    sub $I11, rx123_pos, rx123_off
    substr $S10, rx123_tgt, $I11, 4
    ne $S10, "=end", rx123_fail
    add rx123_pos, 4
  # rxanchor rwb
    le rx123_pos, 0, rx123_fail
    sub $I10, rx123_pos, rx123_off
    is_cclass $I11, 8192, rx123_tgt, $I10
    if $I11, rx123_fail
    dec $I10
    is_cclass $I11, 8192, rx123_tgt, $I10
    unless $I11, rx123_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx123_pos, rx123_off
    find_cclass $I11, 4096, rx123_tgt, $I10, rx123_eos
    add rx123_pos, rx123_off, $I11
    goto alt146_end
  alt146_1:
.annotate 'line', 84
  # rx subrule "panic" subtype=method negate=
    rx123_cur."!cursor_pos"(rx123_pos)
    $P10 = rx123_cur."panic"("=begin without matching =end")
    unless $P10, rx123_fail
    rx123_pos = $P10."pos"()
  alt146_end:
.annotate 'line', 80
    goto alt129_end
  alt129_3:
    set_addr $I10, alt129_4
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
.annotate 'line', 86
  # rx subrule "identifier" subtype=capture negate=
    rx123_cur."!cursor_pos"(rx123_pos)
    $P10 = rx123_cur."identifier"()
    unless $P10, rx123_fail
    rx123_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx123_pos = $P10."pos"()
.annotate 'line', 87
  # rx rxquantf150 ** 0..*
    set_addr $I10, rxquantf150_loop
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
    goto rxquantf150_done
  rxquantf150_loop:
  # rx charclass .
    ge rx123_pos, rx123_eos, rx123_fail
    inc rx123_pos
    set_addr $I10, rxquantf150_loop
    rx123_cur."!mark_push"(rx123_rep, rx123_pos, $I10)
  rxquantf150_done:
  # rxanchor bol
    eq rx123_pos, 0, rxanchor152_done
    ge rx123_pos, rx123_eos, rx123_fail
    sub $I10, rx123_pos, rx123_off
    dec $I10
    is_cclass $I11, 4096, rx123_tgt, $I10
    unless $I11, rx123_fail
  rxanchor152_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx123_cur."!cursor_pos"(rx123_pos)
    .const 'Sub' $P154 = "28_1298325448.42642" 
    capture_lex $P154
    $P10 = rx123_cur."before"($P154)
    unless $P10, rx123_fail
.annotate 'line', 86
    goto alt129_end
  alt129_4:
  alt160_0:
.annotate 'line', 93
    set_addr $I10, alt160_1
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
  # rx charclass s
    ge rx123_pos, rx123_eos, rx123_fail
    sub $I10, rx123_pos, rx123_off
    is_cclass $I11, 32, rx123_tgt, $I10
    unless $I11, rx123_fail
    inc rx123_pos
    goto alt160_end
  alt160_1:
  # rx subrule "panic" subtype=method negate=
    rx123_cur."!cursor_pos"(rx123_pos)
    $P10 = rx123_cur."panic"("Illegal pod directive")
    unless $P10, rx123_fail
    rx123_pos = $P10."pos"()
  alt160_end:
.annotate 'line', 94
  # rx charclass_q N r 0..-1
    sub $I10, rx123_pos, rx123_off
    find_cclass $I11, 4096, rx123_tgt, $I10, rx123_eos
    add rx123_pos, rx123_off, $I11
  alt129_end:
.annotate 'line', 70
  # rx pass
    rx123_cur."!cursor_pass"(rx123_pos, "pod_comment")
    if_null rx123_debug, debug_465
    rx123_cur."!cursor_debug"("PASS", "pod_comment", " at pos=", rx123_pos)
  debug_465:
    .return (rx123_cur)
  rx123_restart:
.annotate 'line', 4
    if_null rx123_debug, debug_466
    rx123_cur."!cursor_debug"("NEXT", "pod_comment")
  debug_466:
  rx123_fail:
    (rx123_rep, rx123_pos, $I10, $P10) = rx123_cur."!mark_fail"(0)
    lt rx123_pos, -1, rx123_done
    eq rx123_pos, -1, rx123_fail
    jump $I10
  rx123_done:
    rx123_cur."!cursor_fail"()
    if_null rx123_debug, debug_467
    rx123_cur."!cursor_debug"("FAIL", "pod_comment")
  debug_467:
    .return (rx123_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pod_comment"  :nsentry("!PREFIX__pod_comment") :subid("27_1298325448.42642") :method
.annotate 'line', 4
    new $P125, "ResizablePMCArray"
    push $P125, ""
    .return ($P125)
.end


.namespace ["NQP";"Grammar"]
.sub "_block153"  :anon :subid("28_1298325448.42642") :method :outer("26_1298325448.42642")
.annotate 'line', 87
    .local string rx155_tgt
    .local int rx155_pos
    .local int rx155_off
    .local int rx155_eos
    .local int rx155_rep
    .local pmc rx155_cur
    .local pmc rx155_debug
    (rx155_cur, rx155_pos, rx155_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx155_cur
    .local pmc match
    .lex "$/", match
    length rx155_eos, rx155_tgt
    gt rx155_pos, rx155_eos, rx155_done
    set rx155_off, 0
    lt rx155_pos, 2, rx155_start
    sub rx155_off, rx155_pos, 1
    substr rx155_tgt, rx155_tgt, rx155_off
  rx155_start:
    eq $I10, 1, rx155_restart
    if_null rx155_debug, debug_461
    rx155_cur."!cursor_debug"("START", "")
  debug_461:
    $I10 = self.'from'()
    ne $I10, -1, rxscan156_done
    goto rxscan156_scan
  rxscan156_loop:
    (rx155_pos) = rx155_cur."from"()
    inc rx155_pos
    rx155_cur."!cursor_from"(rx155_pos)
    ge rx155_pos, rx155_eos, rxscan156_done
  rxscan156_scan:
    set_addr $I10, rxscan156_loop
    rx155_cur."!mark_push"(0, rx155_pos, $I10)
  rxscan156_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx155_pos, rx155_off
    set rx155_rep, 0
    sub $I12, rx155_eos, rx155_pos
  rxenumcharlistq157_loop:
    le $I12, 0, rxenumcharlistq157_done
    substr $S10, rx155_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq157_done
    inc rx155_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq157_loop
  rxenumcharlistq157_done:
    add rx155_pos, rx155_pos, rx155_rep
  alt158_0:
    set_addr $I10, alt158_1
    rx155_cur."!mark_push"(0, rx155_pos, $I10)
.annotate 'line', 88
  # rx literal  "="
    add $I11, rx155_pos, 1
    gt $I11, rx155_eos, rx155_fail
    sub $I11, rx155_pos, rx155_off
    ord $I11, rx155_tgt, $I11
    ne $I11, 61, rx155_fail
    add rx155_pos, 1
.annotate 'line', 90
  # rx rxquantr159 ** 0..1
    set_addr $I10, rxquantr159_done
    rx155_cur."!mark_push"(0, rx155_pos, $I10)
  rxquantr159_loop:
.annotate 'line', 89
  # rx literal  "cut"
    add $I11, rx155_pos, 3
    gt $I11, rx155_eos, rx155_fail
    sub $I11, rx155_pos, rx155_off
    substr $S10, rx155_tgt, $I11, 3
    ne $S10, "cut", rx155_fail
    add rx155_pos, 3
  # rxanchor rwb
    le rx155_pos, 0, rx155_fail
    sub $I10, rx155_pos, rx155_off
    is_cclass $I11, 8192, rx155_tgt, $I10
    if $I11, rx155_fail
    dec $I10
    is_cclass $I11, 8192, rx155_tgt, $I10
    unless $I11, rx155_fail
.annotate 'line', 90
  # rx subrule "panic" subtype=method negate=
    rx155_cur."!cursor_pos"(rx155_pos)
    $P10 = rx155_cur."panic"("Obsolete pod format, please use =begin/=end instead")
    unless $P10, rx155_fail
    rx155_pos = $P10."pos"()
    set_addr $I10, rxquantr159_done
    (rx155_rep) = rx155_cur."!mark_commit"($I10)
  rxquantr159_done:
.annotate 'line', 87
    goto alt158_end
  alt158_1:
.annotate 'line', 91
  # rx charclass nl
    ge rx155_pos, rx155_eos, rx155_fail
    sub $I10, rx155_pos, rx155_off
    is_cclass $I11, 4096, rx155_tgt, $I10
    unless $I11, rx155_fail
    substr $S10, rx155_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx155_pos, $I11
    inc rx155_pos
  alt158_end:
.annotate 'line', 87
  # rx pass
    rx155_cur."!cursor_pass"(rx155_pos, "")
    if_null rx155_debug, debug_462
    rx155_cur."!cursor_debug"("PASS", "", " at pos=", rx155_pos)
  debug_462:
    .return (rx155_cur)
  rx155_restart:
    if_null rx155_debug, debug_463
    rx155_cur."!cursor_debug"("NEXT", "")
  debug_463:
  rx155_fail:
    (rx155_rep, rx155_pos, $I10, $P10) = rx155_cur."!mark_fail"(0)
    lt rx155_pos, -1, rx155_done
    eq rx155_pos, -1, rx155_fail
    jump $I10
  rx155_done:
    rx155_cur."!cursor_fail"()
    if_null rx155_debug, debug_464
    rx155_cur."!cursor_debug"("FAIL", "")
  debug_464:
    .return (rx155_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "comp_unit"  :subid("29_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx162_tgt
    .local int rx162_pos
    .local int rx162_off
    .local int rx162_eos
    .local int rx162_rep
    .local pmc rx162_cur
    .local pmc rx162_debug
    (rx162_cur, rx162_pos, rx162_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx162_cur
    .local pmc match
    .lex "$/", match
    length rx162_eos, rx162_tgt
    gt rx162_pos, rx162_eos, rx162_done
    set rx162_off, 0
    lt rx162_pos, 2, rx162_start
    sub rx162_off, rx162_pos, 1
    substr rx162_tgt, rx162_tgt, rx162_off
  rx162_start:
    eq $I10, 1, rx162_restart
    if_null rx162_debug, debug_468
    rx162_cur."!cursor_debug"("START", "comp_unit")
  debug_468:
    $I10 = self.'from'()
    ne $I10, -1, rxscan166_done
    goto rxscan166_scan
  rxscan166_loop:
    (rx162_pos) = rx162_cur."from"()
    inc rx162_pos
    rx162_cur."!cursor_from"(rx162_pos)
    ge rx162_pos, rx162_eos, rxscan166_done
  rxscan166_scan:
    set_addr $I10, rxscan166_loop
    rx162_cur."!mark_push"(0, rx162_pos, $I10)
  rxscan166_done:
.annotate 'line', 102
  # rx subrule "newpad" subtype=method negate=
    rx162_cur."!cursor_pos"(rx162_pos)
    $P10 = rx162_cur."newpad"()
    unless $P10, rx162_fail
    rx162_pos = $P10."pos"()
.annotate 'line', 103
  # rx subrule "outerctx" subtype=method negate=
    rx162_cur."!cursor_pos"(rx162_pos)
    $P10 = rx162_cur."outerctx"()
    unless $P10, rx162_fail
    rx162_pos = $P10."pos"()
.annotate 'line', 104
  # rx subrule "statementlist" subtype=capture negate=
    rx162_cur."!cursor_pos"(rx162_pos)
    $P10 = rx162_cur."statementlist"()
    unless $P10, rx162_fail
    rx162_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx162_pos = $P10."pos"()
  alt167_0:
.annotate 'line', 105
    set_addr $I10, alt167_1
    rx162_cur."!mark_push"(0, rx162_pos, $I10)
  # rxanchor eos
    ne rx162_pos, rx162_eos, rx162_fail
    goto alt167_end
  alt167_1:
  # rx subrule "panic" subtype=method negate=
    rx162_cur."!cursor_pos"(rx162_pos)
    $P10 = rx162_cur."panic"("Confused")
    unless $P10, rx162_fail
    rx162_pos = $P10."pos"()
  alt167_end:
.annotate 'line', 101
  # rx pass
    rx162_cur."!cursor_pass"(rx162_pos, "comp_unit")
    if_null rx162_debug, debug_469
    rx162_cur."!cursor_debug"("PASS", "comp_unit", " at pos=", rx162_pos)
  debug_469:
    .return (rx162_cur)
  rx162_restart:
.annotate 'line', 4
    if_null rx162_debug, debug_470
    rx162_cur."!cursor_debug"("NEXT", "comp_unit")
  debug_470:
  rx162_fail:
    (rx162_rep, rx162_pos, $I10, $P10) = rx162_cur."!mark_fail"(0)
    lt rx162_pos, -1, rx162_done
    eq rx162_pos, -1, rx162_fail
    jump $I10
  rx162_done:
    rx162_cur."!cursor_fail"()
    if_null rx162_debug, debug_471
    rx162_cur."!cursor_debug"("FAIL", "comp_unit")
  debug_471:
    .return (rx162_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__comp_unit"  :nsentry("!PREFIX__comp_unit") :subid("30_1298325448.42642") :method
.annotate 'line', 4
    $P164 = self."!PREFIX__!subrule"("newpad", "")
    new $P165, "ResizablePMCArray"
    push $P165, $P164
    .return ($P165)
.end


.namespace ["NQP";"Grammar"]
.sub "statementlist"  :subid("31_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx169_tgt
    .local int rx169_pos
    .local int rx169_off
    .local int rx169_eos
    .local int rx169_rep
    .local pmc rx169_cur
    .local pmc rx169_debug
    (rx169_cur, rx169_pos, rx169_tgt, $I10) = self."!cursor_start"()
    rx169_cur."!cursor_caparray"("statement")
    .lex unicode:"$\x{a2}", rx169_cur
    .local pmc match
    .lex "$/", match
    length rx169_eos, rx169_tgt
    gt rx169_pos, rx169_eos, rx169_done
    set rx169_off, 0
    lt rx169_pos, 2, rx169_start
    sub rx169_off, rx169_pos, 1
    substr rx169_tgt, rx169_tgt, rx169_off
  rx169_start:
    eq $I10, 1, rx169_restart
    if_null rx169_debug, debug_472
    rx169_cur."!cursor_debug"("START", "statementlist")
  debug_472:
    $I10 = self.'from'()
    ne $I10, -1, rxscan174_done
    goto rxscan174_scan
  rxscan174_loop:
    (rx169_pos) = rx169_cur."from"()
    inc rx169_pos
    rx169_cur."!cursor_from"(rx169_pos)
    ge rx169_pos, rx169_eos, rxscan174_done
  rxscan174_scan:
    set_addr $I10, rxscan174_loop
    rx169_cur."!mark_push"(0, rx169_pos, $I10)
  rxscan174_done:
  alt175_0:
.annotate 'line', 108
    set_addr $I10, alt175_1
    rx169_cur."!mark_push"(0, rx169_pos, $I10)
.annotate 'line', 109
  # rx subrule "ws" subtype=method negate=
    rx169_cur."!cursor_pos"(rx169_pos)
    $P10 = rx169_cur."ws"()
    unless $P10, rx169_fail
    rx169_pos = $P10."pos"()
  # rxanchor eos
    ne rx169_pos, rx169_eos, rx169_fail
  # rx subrule "ws" subtype=method negate=
    rx169_cur."!cursor_pos"(rx169_pos)
    $P10 = rx169_cur."ws"()
    unless $P10, rx169_fail
    rx169_pos = $P10."pos"()
    goto alt175_end
  alt175_1:
.annotate 'line', 110
  # rx subrule "ws" subtype=method negate=
    rx169_cur."!cursor_pos"(rx169_pos)
    $P10 = rx169_cur."ws"()
    unless $P10, rx169_fail
    rx169_pos = $P10."pos"()
  # rx rxquantr179 ** 0..*
    set_addr $I10, rxquantr179_done
    rx169_cur."!mark_push"(0, rx169_pos, $I10)
  rxquantr179_loop:
  # rx subrule "statement" subtype=capture negate=
    rx169_cur."!cursor_pos"(rx169_pos)
    $P10 = rx169_cur."statement"()
    unless $P10, rx169_fail
    rx169_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx169_pos = $P10."pos"()
  # rx subrule "eat_terminator" subtype=method negate=
    rx169_cur."!cursor_pos"(rx169_pos)
    $P10 = rx169_cur."eat_terminator"()
    unless $P10, rx169_fail
    rx169_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx169_cur."!cursor_pos"(rx169_pos)
    $P10 = rx169_cur."ws"()
    unless $P10, rx169_fail
    rx169_pos = $P10."pos"()
    set_addr $I10, rxquantr179_done
    (rx169_rep) = rx169_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr179_done
    rx169_cur."!mark_push"(rx169_rep, rx169_pos, $I10)
    goto rxquantr179_loop
  rxquantr179_done:
  # rx subrule "ws" subtype=method negate=
    rx169_cur."!cursor_pos"(rx169_pos)
    $P10 = rx169_cur."ws"()
    unless $P10, rx169_fail
    rx169_pos = $P10."pos"()
  alt175_end:
.annotate 'line', 108
  # rx pass
    rx169_cur."!cursor_pass"(rx169_pos, "statementlist")
    if_null rx169_debug, debug_473
    rx169_cur."!cursor_debug"("PASS", "statementlist", " at pos=", rx169_pos)
  debug_473:
    .return (rx169_cur)
  rx169_restart:
.annotate 'line', 4
    if_null rx169_debug, debug_474
    rx169_cur."!cursor_debug"("NEXT", "statementlist")
  debug_474:
  rx169_fail:
    (rx169_rep, rx169_pos, $I10, $P10) = rx169_cur."!mark_fail"(0)
    lt rx169_pos, -1, rx169_done
    eq rx169_pos, -1, rx169_fail
    jump $I10
  rx169_done:
    rx169_cur."!cursor_fail"()
    if_null rx169_debug, debug_475
    rx169_cur."!cursor_debug"("FAIL", "statementlist")
  debug_475:
    .return (rx169_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statementlist"  :nsentry("!PREFIX__statementlist") :subid("32_1298325448.42642") :method
.annotate 'line', 4
    $P171 = self."!PREFIX__!subrule"("ws", "")
    $P172 = self."!PREFIX__!subrule"("ws", "")
    new $P173, "ResizablePMCArray"
    push $P173, $P171
    push $P173, $P172
    .return ($P173)
.end


.namespace ["NQP";"Grammar"]
.sub "statement"  :subid("33_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .const 'Sub' $P188 = "35_1298325448.42642" 
    capture_lex $P188
    .local string rx183_tgt
    .local int rx183_pos
    .local int rx183_off
    .local int rx183_eos
    .local int rx183_rep
    .local pmc rx183_cur
    .local pmc rx183_debug
    (rx183_cur, rx183_pos, rx183_tgt, $I10) = self."!cursor_start"()
    rx183_cur."!cursor_caparray"("statement_mod_cond", "statement_mod_loop")
    .lex unicode:"$\x{a2}", rx183_cur
    .local pmc match
    .lex "$/", match
    length rx183_eos, rx183_tgt
    gt rx183_pos, rx183_eos, rx183_done
    set rx183_off, 0
    lt rx183_pos, 2, rx183_start
    sub rx183_off, rx183_pos, 1
    substr rx183_tgt, rx183_tgt, rx183_off
  rx183_start:
    eq $I10, 1, rx183_restart
    if_null rx183_debug, debug_476
    rx183_cur."!cursor_debug"("START", "statement")
  debug_476:
    $I10 = self.'from'()
    ne $I10, -1, rxscan186_done
    goto rxscan186_scan
  rxscan186_loop:
    (rx183_pos) = rx183_cur."from"()
    inc rx183_pos
    rx183_cur."!cursor_from"(rx183_pos)
    ge rx183_pos, rx183_eos, rxscan186_done
  rxscan186_scan:
    set_addr $I10, rxscan186_loop
    rx183_cur."!mark_push"(0, rx183_pos, $I10)
  rxscan186_done:
.annotate 'line', 114
  # rx subrule "before" subtype=zerowidth negate=1
    rx183_cur."!cursor_pos"(rx183_pos)
    .const 'Sub' $P188 = "35_1298325448.42642" 
    capture_lex $P188
    $P10 = rx183_cur."before"($P188)
    if $P10, rx183_fail
  alt192_0:
.annotate 'line', 115
    set_addr $I10, alt192_1
    rx183_cur."!mark_push"(0, rx183_pos, $I10)
.annotate 'line', 116
  # rx subrule "statement_control" subtype=capture negate=
    rx183_cur."!cursor_pos"(rx183_pos)
    $P10 = rx183_cur."statement_control"()
    unless $P10, rx183_fail
    rx183_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_control")
    rx183_pos = $P10."pos"()
    goto alt192_end
  alt192_1:
.annotate 'line', 117
  # rx subrule "EXPR" subtype=capture negate=
    rx183_cur."!cursor_pos"(rx183_pos)
    $P10 = rx183_cur."EXPR"()
    unless $P10, rx183_fail
    rx183_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx183_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx183_cur."!cursor_pos"(rx183_pos)
    $P10 = rx183_cur."ws"()
    unless $P10, rx183_fail
    rx183_pos = $P10."pos"()
.annotate 'line', 122
  # rx rxquantr193 ** 0..1
    set_addr $I10, rxquantr193_done
    rx183_cur."!mark_push"(0, rx183_pos, $I10)
  rxquantr193_loop:
  alt194_0:
.annotate 'line', 118
    set_addr $I10, alt194_1
    rx183_cur."!mark_push"(0, rx183_pos, $I10)
.annotate 'line', 119
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx183_cur."!cursor_pos"(rx183_pos)
    $P10 = rx183_cur."MARKED"("endstmt")
    unless $P10, rx183_fail
    goto alt194_end
  alt194_1:
    set_addr $I10, alt194_2
    rx183_cur."!mark_push"(0, rx183_pos, $I10)
.annotate 'line', 120
  # rx subrule "statement_mod_cond" subtype=capture negate=
    rx183_cur."!cursor_pos"(rx183_pos)
    $P10 = rx183_cur."statement_mod_cond"()
    unless $P10, rx183_fail
    rx183_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_cond")
    rx183_pos = $P10."pos"()
  # rx rxquantr195 ** 0..1
    set_addr $I10, rxquantr195_done
    rx183_cur."!mark_push"(0, rx183_pos, $I10)
  rxquantr195_loop:
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx183_cur."!cursor_pos"(rx183_pos)
    $P10 = rx183_cur."statement_mod_loop"()
    unless $P10, rx183_fail
    goto rxsubrule196_pass
  rxsubrule196_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx183_fail
  rxsubrule196_pass:
    set_addr $I10, rxsubrule196_back
    rx183_cur."!mark_push"(0, rx183_pos, $I10, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx183_pos = $P10."pos"()
    set_addr $I10, rxquantr195_done
    (rx183_rep) = rx183_cur."!mark_commit"($I10)
  rxquantr195_done:
    goto alt194_end
  alt194_2:
.annotate 'line', 121
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx183_cur."!cursor_pos"(rx183_pos)
    $P10 = rx183_cur."statement_mod_loop"()
    unless $P10, rx183_fail
    rx183_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx183_pos = $P10."pos"()
  alt194_end:
.annotate 'line', 122
    set_addr $I10, rxquantr193_done
    (rx183_rep) = rx183_cur."!mark_commit"($I10)
  rxquantr193_done:
  alt192_end:
.annotate 'line', 113
  # rx pass
    rx183_cur."!cursor_pass"(rx183_pos, "statement")
    if_null rx183_debug, debug_481
    rx183_cur."!cursor_debug"("PASS", "statement", " at pos=", rx183_pos)
  debug_481:
    .return (rx183_cur)
  rx183_restart:
.annotate 'line', 4
    if_null rx183_debug, debug_482
    rx183_cur."!cursor_debug"("NEXT", "statement")
  debug_482:
  rx183_fail:
    (rx183_rep, rx183_pos, $I10, $P10) = rx183_cur."!mark_fail"(0)
    lt rx183_pos, -1, rx183_done
    eq rx183_pos, -1, rx183_fail
    jump $I10
  rx183_done:
    rx183_cur."!cursor_fail"()
    if_null rx183_debug, debug_483
    rx183_cur."!cursor_debug"("FAIL", "statement")
  debug_483:
    .return (rx183_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement"  :nsentry("!PREFIX__statement") :subid("34_1298325448.42642") :method
.annotate 'line', 4
    new $P185, "ResizablePMCArray"
    push $P185, ""
    .return ($P185)
.end


.namespace ["NQP";"Grammar"]
.sub "_block187"  :anon :subid("35_1298325448.42642") :method :outer("33_1298325448.42642")
.annotate 'line', 114
    .local string rx189_tgt
    .local int rx189_pos
    .local int rx189_off
    .local int rx189_eos
    .local int rx189_rep
    .local pmc rx189_cur
    .local pmc rx189_debug
    (rx189_cur, rx189_pos, rx189_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx189_cur
    .local pmc match
    .lex "$/", match
    length rx189_eos, rx189_tgt
    gt rx189_pos, rx189_eos, rx189_done
    set rx189_off, 0
    lt rx189_pos, 2, rx189_start
    sub rx189_off, rx189_pos, 1
    substr rx189_tgt, rx189_tgt, rx189_off
  rx189_start:
    eq $I10, 1, rx189_restart
    if_null rx189_debug, debug_477
    rx189_cur."!cursor_debug"("START", "")
  debug_477:
    $I10 = self.'from'()
    ne $I10, -1, rxscan190_done
    goto rxscan190_scan
  rxscan190_loop:
    (rx189_pos) = rx189_cur."from"()
    inc rx189_pos
    rx189_cur."!cursor_from"(rx189_pos)
    ge rx189_pos, rx189_eos, rxscan190_done
  rxscan190_scan:
    set_addr $I10, rxscan190_loop
    rx189_cur."!mark_push"(0, rx189_pos, $I10)
  rxscan190_done:
  alt191_0:
    set_addr $I10, alt191_1
    rx189_cur."!mark_push"(0, rx189_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx189_pos, rx189_eos, rx189_fail
    sub $I10, rx189_pos, rx189_off
    substr $S10, rx189_tgt, $I10, 1
    index $I11, "])}", $S10
    lt $I11, 0, rx189_fail
    inc rx189_pos
    goto alt191_end
  alt191_1:
  # rxanchor eos
    ne rx189_pos, rx189_eos, rx189_fail
  alt191_end:
  # rx pass
    rx189_cur."!cursor_pass"(rx189_pos, "")
    if_null rx189_debug, debug_478
    rx189_cur."!cursor_debug"("PASS", "", " at pos=", rx189_pos)
  debug_478:
    .return (rx189_cur)
  rx189_restart:
    if_null rx189_debug, debug_479
    rx189_cur."!cursor_debug"("NEXT", "")
  debug_479:
  rx189_fail:
    (rx189_rep, rx189_pos, $I10, $P10) = rx189_cur."!mark_fail"(0)
    lt rx189_pos, -1, rx189_done
    eq rx189_pos, -1, rx189_fail
    jump $I10
  rx189_done:
    rx189_cur."!cursor_fail"()
    if_null rx189_debug, debug_480
    rx189_cur."!cursor_debug"("FAIL", "")
  debug_480:
    .return (rx189_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "eat_terminator"  :subid("36_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx198_tgt
    .local int rx198_pos
    .local int rx198_off
    .local int rx198_eos
    .local int rx198_rep
    .local pmc rx198_cur
    .local pmc rx198_debug
    (rx198_cur, rx198_pos, rx198_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx198_cur
    .local pmc match
    .lex "$/", match
    length rx198_eos, rx198_tgt
    gt rx198_pos, rx198_eos, rx198_done
    set rx198_off, 0
    lt rx198_pos, 2, rx198_start
    sub rx198_off, rx198_pos, 1
    substr rx198_tgt, rx198_tgt, rx198_off
  rx198_start:
    eq $I10, 1, rx198_restart
    if_null rx198_debug, debug_484
    rx198_cur."!cursor_debug"("START", "eat_terminator")
  debug_484:
    $I10 = self.'from'()
    ne $I10, -1, rxscan201_done
    goto rxscan201_scan
  rxscan201_loop:
    (rx198_pos) = rx198_cur."from"()
    inc rx198_pos
    rx198_cur."!cursor_from"(rx198_pos)
    ge rx198_pos, rx198_eos, rxscan201_done
  rxscan201_scan:
    set_addr $I10, rxscan201_loop
    rx198_cur."!mark_push"(0, rx198_pos, $I10)
  rxscan201_done:
  alt202_0:
.annotate 'line', 126
    set_addr $I10, alt202_1
    rx198_cur."!mark_push"(0, rx198_pos, $I10)
.annotate 'line', 127
  # rx literal  ";"
    add $I11, rx198_pos, 1
    gt $I11, rx198_eos, rx198_fail
    sub $I11, rx198_pos, rx198_off
    ord $I11, rx198_tgt, $I11
    ne $I11, 59, rx198_fail
    add rx198_pos, 1
    goto alt202_end
  alt202_1:
    set_addr $I10, alt202_2
    rx198_cur."!mark_push"(0, rx198_pos, $I10)
.annotate 'line', 128
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx198_cur."!cursor_pos"(rx198_pos)
    $P10 = rx198_cur."MARKED"("endstmt")
    unless $P10, rx198_fail
    goto alt202_end
  alt202_2:
    set_addr $I10, alt202_3
    rx198_cur."!mark_push"(0, rx198_pos, $I10)
.annotate 'line', 129
  # rx subrule "terminator" subtype=zerowidth negate=
    rx198_cur."!cursor_pos"(rx198_pos)
    $P10 = rx198_cur."terminator"()
    unless $P10, rx198_fail
    goto alt202_end
  alt202_3:
.annotate 'line', 130
  # rxanchor eos
    ne rx198_pos, rx198_eos, rx198_fail
  alt202_end:
.annotate 'line', 126
  # rx pass
    rx198_cur."!cursor_pass"(rx198_pos, "eat_terminator")
    if_null rx198_debug, debug_485
    rx198_cur."!cursor_debug"("PASS", "eat_terminator", " at pos=", rx198_pos)
  debug_485:
    .return (rx198_cur)
  rx198_restart:
.annotate 'line', 4
    if_null rx198_debug, debug_486
    rx198_cur."!cursor_debug"("NEXT", "eat_terminator")
  debug_486:
  rx198_fail:
    (rx198_rep, rx198_pos, $I10, $P10) = rx198_cur."!mark_fail"(0)
    lt rx198_pos, -1, rx198_done
    eq rx198_pos, -1, rx198_fail
    jump $I10
  rx198_done:
    rx198_cur."!cursor_fail"()
    if_null rx198_debug, debug_487
    rx198_cur."!cursor_debug"("FAIL", "eat_terminator")
  debug_487:
    .return (rx198_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__eat_terminator"  :nsentry("!PREFIX__eat_terminator") :subid("37_1298325448.42642") :method
.annotate 'line', 4
    new $P200, "ResizablePMCArray"
    push $P200, ""
    push $P200, ""
    push $P200, ""
    push $P200, ";"
    .return ($P200)
.end


.namespace ["NQP";"Grammar"]
.sub "xblock"  :subid("38_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx204_tgt
    .local int rx204_pos
    .local int rx204_off
    .local int rx204_eos
    .local int rx204_rep
    .local pmc rx204_cur
    .local pmc rx204_debug
    (rx204_cur, rx204_pos, rx204_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx204_cur
    .local pmc match
    .lex "$/", match
    length rx204_eos, rx204_tgt
    gt rx204_pos, rx204_eos, rx204_done
    set rx204_off, 0
    lt rx204_pos, 2, rx204_start
    sub rx204_off, rx204_pos, 1
    substr rx204_tgt, rx204_tgt, rx204_off
  rx204_start:
    eq $I10, 1, rx204_restart
    if_null rx204_debug, debug_488
    rx204_cur."!cursor_debug"("START", "xblock")
  debug_488:
    $I10 = self.'from'()
    ne $I10, -1, rxscan208_done
    goto rxscan208_scan
  rxscan208_loop:
    (rx204_pos) = rx204_cur."from"()
    inc rx204_pos
    rx204_cur."!cursor_from"(rx204_pos)
    ge rx204_pos, rx204_eos, rxscan208_done
  rxscan208_scan:
    set_addr $I10, rxscan208_loop
    rx204_cur."!mark_push"(0, rx204_pos, $I10)
  rxscan208_done:
.annotate 'line', 134
  # rx subrule "EXPR" subtype=capture negate=
    rx204_cur."!cursor_pos"(rx204_pos)
    $P10 = rx204_cur."EXPR"()
    unless $P10, rx204_fail
    rx204_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx204_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx204_cur."!cursor_pos"(rx204_pos)
    $P10 = rx204_cur."ws"()
    unless $P10, rx204_fail
    rx204_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx204_cur."!cursor_pos"(rx204_pos)
    $P10 = rx204_cur."pblock"()
    unless $P10, rx204_fail
    rx204_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx204_pos = $P10."pos"()
.annotate 'line', 133
  # rx pass
    rx204_cur."!cursor_pass"(rx204_pos, "xblock")
    if_null rx204_debug, debug_489
    rx204_cur."!cursor_debug"("PASS", "xblock", " at pos=", rx204_pos)
  debug_489:
    .return (rx204_cur)
  rx204_restart:
.annotate 'line', 4
    if_null rx204_debug, debug_490
    rx204_cur."!cursor_debug"("NEXT", "xblock")
  debug_490:
  rx204_fail:
    (rx204_rep, rx204_pos, $I10, $P10) = rx204_cur."!mark_fail"(0)
    lt rx204_pos, -1, rx204_done
    eq rx204_pos, -1, rx204_fail
    jump $I10
  rx204_done:
    rx204_cur."!cursor_fail"()
    if_null rx204_debug, debug_491
    rx204_cur."!cursor_debug"("FAIL", "xblock")
  debug_491:
    .return (rx204_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__xblock"  :nsentry("!PREFIX__xblock") :subid("39_1298325448.42642") :method
.annotate 'line', 4
    $P206 = self."!PREFIX__!subrule"("EXPR", "")
    new $P207, "ResizablePMCArray"
    push $P207, $P206
    .return ($P207)
.end


.namespace ["NQP";"Grammar"]
.sub "pblock"  :subid("40_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx210_tgt
    .local int rx210_pos
    .local int rx210_off
    .local int rx210_eos
    .local int rx210_rep
    .local pmc rx210_cur
    .local pmc rx210_debug
    (rx210_cur, rx210_pos, rx210_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx210_cur
    .local pmc match
    .lex "$/", match
    length rx210_eos, rx210_tgt
    gt rx210_pos, rx210_eos, rx210_done
    set rx210_off, 0
    lt rx210_pos, 2, rx210_start
    sub rx210_off, rx210_pos, 1
    substr rx210_tgt, rx210_tgt, rx210_off
  rx210_start:
    eq $I10, 1, rx210_restart
    if_null rx210_debug, debug_492
    rx210_cur."!cursor_debug"("START", "pblock")
  debug_492:
    $I10 = self.'from'()
    ne $I10, -1, rxscan215_done
    goto rxscan215_scan
  rxscan215_loop:
    (rx210_pos) = rx210_cur."from"()
    inc rx210_pos
    rx210_cur."!cursor_from"(rx210_pos)
    ge rx210_pos, rx210_eos, rxscan215_done
  rxscan215_scan:
    set_addr $I10, rxscan215_loop
    rx210_cur."!mark_push"(0, rx210_pos, $I10)
  rxscan215_done:
  alt216_0:
.annotate 'line', 137
    set_addr $I10, alt216_1
    rx210_cur."!mark_push"(0, rx210_pos, $I10)
.annotate 'line', 138
  # rx subrule "lambda" subtype=method negate=
    rx210_cur."!cursor_pos"(rx210_pos)
    $P10 = rx210_cur."lambda"()
    unless $P10, rx210_fail
    rx210_pos = $P10."pos"()
.annotate 'line', 139
  # rx subrule "newpad" subtype=method negate=
    rx210_cur."!cursor_pos"(rx210_pos)
    $P10 = rx210_cur."newpad"()
    unless $P10, rx210_fail
    rx210_pos = $P10."pos"()
.annotate 'line', 140
  # rx subrule "signature" subtype=capture negate=
    rx210_cur."!cursor_pos"(rx210_pos)
    $P10 = rx210_cur."signature"()
    unless $P10, rx210_fail
    rx210_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx210_pos = $P10."pos"()
.annotate 'line', 141
  # rx subrule "blockoid" subtype=capture negate=
    rx210_cur."!cursor_pos"(rx210_pos)
    $P10 = rx210_cur."blockoid"()
    unless $P10, rx210_fail
    rx210_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx210_pos = $P10."pos"()
.annotate 'line', 138
    goto alt216_end
  alt216_1:
    set_addr $I10, alt216_2
    rx210_cur."!mark_push"(0, rx210_pos, $I10)
.annotate 'line', 142
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx210_pos, rx210_off
    substr $S10, rx210_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx210_fail
.annotate 'line', 143
  # rx subrule "newpad" subtype=method negate=
    rx210_cur."!cursor_pos"(rx210_pos)
    $P10 = rx210_cur."newpad"()
    unless $P10, rx210_fail
    rx210_pos = $P10."pos"()
.annotate 'line', 144
  # rx subrule "blockoid" subtype=capture negate=
    rx210_cur."!cursor_pos"(rx210_pos)
    $P10 = rx210_cur."blockoid"()
    unless $P10, rx210_fail
    rx210_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx210_pos = $P10."pos"()
.annotate 'line', 142
    goto alt216_end
  alt216_2:
.annotate 'line', 145
  # rx subrule "panic" subtype=method negate=
    rx210_cur."!cursor_pos"(rx210_pos)
    $P10 = rx210_cur."panic"("Missing block")
    unless $P10, rx210_fail
    rx210_pos = $P10."pos"()
  alt216_end:
.annotate 'line', 137
  # rx pass
    rx210_cur."!cursor_pass"(rx210_pos, "pblock")
    if_null rx210_debug, debug_493
    rx210_cur."!cursor_debug"("PASS", "pblock", " at pos=", rx210_pos)
  debug_493:
    .return (rx210_cur)
  rx210_restart:
.annotate 'line', 4
    if_null rx210_debug, debug_494
    rx210_cur."!cursor_debug"("NEXT", "pblock")
  debug_494:
  rx210_fail:
    (rx210_rep, rx210_pos, $I10, $P10) = rx210_cur."!mark_fail"(0)
    lt rx210_pos, -1, rx210_done
    eq rx210_pos, -1, rx210_fail
    jump $I10
  rx210_done:
    rx210_cur."!cursor_fail"()
    if_null rx210_debug, debug_495
    rx210_cur."!cursor_debug"("FAIL", "pblock")
  debug_495:
    .return (rx210_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pblock"  :nsentry("!PREFIX__pblock") :subid("41_1298325448.42642") :method
.annotate 'line', 4
    $P212 = self."!PREFIX__!subrule"("panic", "")
    $P213 = self."!PREFIX__!subrule"("lambda", "")
    new $P214, "ResizablePMCArray"
    push $P214, $P212
    push $P214, "{"
    push $P214, $P213
    .return ($P214)
.end


.namespace ["NQP";"Grammar"]
.sub "lambda"  :subid("42_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx218_tgt
    .local int rx218_pos
    .local int rx218_off
    .local int rx218_eos
    .local int rx218_rep
    .local pmc rx218_cur
    .local pmc rx218_debug
    (rx218_cur, rx218_pos, rx218_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx218_cur
    .local pmc match
    .lex "$/", match
    length rx218_eos, rx218_tgt
    gt rx218_pos, rx218_eos, rx218_done
    set rx218_off, 0
    lt rx218_pos, 2, rx218_start
    sub rx218_off, rx218_pos, 1
    substr rx218_tgt, rx218_tgt, rx218_off
  rx218_start:
    eq $I10, 1, rx218_restart
    if_null rx218_debug, debug_496
    rx218_cur."!cursor_debug"("START", "lambda")
  debug_496:
    $I10 = self.'from'()
    ne $I10, -1, rxscan221_done
    goto rxscan221_scan
  rxscan221_loop:
    (rx218_pos) = rx218_cur."from"()
    inc rx218_pos
    rx218_cur."!cursor_from"(rx218_pos)
    ge rx218_pos, rx218_eos, rxscan221_done
  rxscan221_scan:
    set_addr $I10, rxscan221_loop
    rx218_cur."!mark_push"(0, rx218_pos, $I10)
  rxscan221_done:
  alt222_0:
.annotate 'line', 148
    set_addr $I10, alt222_1
    rx218_cur."!mark_push"(0, rx218_pos, $I10)
  # rx literal  "->"
    add $I11, rx218_pos, 2
    gt $I11, rx218_eos, rx218_fail
    sub $I11, rx218_pos, rx218_off
    substr $S10, rx218_tgt, $I11, 2
    ne $S10, "->", rx218_fail
    add rx218_pos, 2
    goto alt222_end
  alt222_1:
  # rx literal  "<->"
    add $I11, rx218_pos, 3
    gt $I11, rx218_eos, rx218_fail
    sub $I11, rx218_pos, rx218_off
    substr $S10, rx218_tgt, $I11, 3
    ne $S10, "<->", rx218_fail
    add rx218_pos, 3
  alt222_end:
  # rx pass
    rx218_cur."!cursor_pass"(rx218_pos, "lambda")
    if_null rx218_debug, debug_497
    rx218_cur."!cursor_debug"("PASS", "lambda", " at pos=", rx218_pos)
  debug_497:
    .return (rx218_cur)
  rx218_restart:
.annotate 'line', 4
    if_null rx218_debug, debug_498
    rx218_cur."!cursor_debug"("NEXT", "lambda")
  debug_498:
  rx218_fail:
    (rx218_rep, rx218_pos, $I10, $P10) = rx218_cur."!mark_fail"(0)
    lt rx218_pos, -1, rx218_done
    eq rx218_pos, -1, rx218_fail
    jump $I10
  rx218_done:
    rx218_cur."!cursor_fail"()
    if_null rx218_debug, debug_499
    rx218_cur."!cursor_debug"("FAIL", "lambda")
  debug_499:
    .return (rx218_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__lambda"  :nsentry("!PREFIX__lambda") :subid("43_1298325448.42642") :method
.annotate 'line', 4
    new $P220, "ResizablePMCArray"
    push $P220, "<->"
    push $P220, "->"
    .return ($P220)
.end


.namespace ["NQP";"Grammar"]
.sub "block"  :subid("44_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx224_tgt
    .local int rx224_pos
    .local int rx224_off
    .local int rx224_eos
    .local int rx224_rep
    .local pmc rx224_cur
    .local pmc rx224_debug
    (rx224_cur, rx224_pos, rx224_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx224_cur
    .local pmc match
    .lex "$/", match
    length rx224_eos, rx224_tgt
    gt rx224_pos, rx224_eos, rx224_done
    set rx224_off, 0
    lt rx224_pos, 2, rx224_start
    sub rx224_off, rx224_pos, 1
    substr rx224_tgt, rx224_tgt, rx224_off
  rx224_start:
    eq $I10, 1, rx224_restart
    if_null rx224_debug, debug_500
    rx224_cur."!cursor_debug"("START", "block")
  debug_500:
    $I10 = self.'from'()
    ne $I10, -1, rxscan228_done
    goto rxscan228_scan
  rxscan228_loop:
    (rx224_pos) = rx224_cur."from"()
    inc rx224_pos
    rx224_cur."!cursor_from"(rx224_pos)
    ge rx224_pos, rx224_eos, rxscan228_done
  rxscan228_scan:
    set_addr $I10, rxscan228_loop
    rx224_cur."!mark_push"(0, rx224_pos, $I10)
  rxscan228_done:
  alt229_0:
.annotate 'line', 151
    set_addr $I10, alt229_1
    rx224_cur."!mark_push"(0, rx224_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx224_pos, rx224_off
    substr $S10, rx224_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx224_fail
    goto alt229_end
  alt229_1:
  # rx subrule "panic" subtype=method negate=
    rx224_cur."!cursor_pos"(rx224_pos)
    $P10 = rx224_cur."panic"("Missing block")
    unless $P10, rx224_fail
    rx224_pos = $P10."pos"()
  alt229_end:
.annotate 'line', 152
  # rx subrule "newpad" subtype=method negate=
    rx224_cur."!cursor_pos"(rx224_pos)
    $P10 = rx224_cur."newpad"()
    unless $P10, rx224_fail
    rx224_pos = $P10."pos"()
.annotate 'line', 153
  # rx subrule "blockoid" subtype=capture negate=
    rx224_cur."!cursor_pos"(rx224_pos)
    $P10 = rx224_cur."blockoid"()
    unless $P10, rx224_fail
    rx224_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx224_pos = $P10."pos"()
.annotate 'line', 150
  # rx pass
    rx224_cur."!cursor_pass"(rx224_pos, "block")
    if_null rx224_debug, debug_501
    rx224_cur."!cursor_debug"("PASS", "block", " at pos=", rx224_pos)
  debug_501:
    .return (rx224_cur)
  rx224_restart:
.annotate 'line', 4
    if_null rx224_debug, debug_502
    rx224_cur."!cursor_debug"("NEXT", "block")
  debug_502:
  rx224_fail:
    (rx224_rep, rx224_pos, $I10, $P10) = rx224_cur."!mark_fail"(0)
    lt rx224_pos, -1, rx224_done
    eq rx224_pos, -1, rx224_fail
    jump $I10
  rx224_done:
    rx224_cur."!cursor_fail"()
    if_null rx224_debug, debug_503
    rx224_cur."!cursor_debug"("FAIL", "block")
  debug_503:
    .return (rx224_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__block"  :nsentry("!PREFIX__block") :subid("45_1298325448.42642") :method
.annotate 'line', 4
    $P226 = self."!PREFIX__!subrule"("panic", "")
    new $P227, "ResizablePMCArray"
    push $P227, $P226
    push $P227, "{"
    .return ($P227)
.end


.namespace ["NQP";"Grammar"]
.sub "blockoid"  :subid("46_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx231_tgt
    .local int rx231_pos
    .local int rx231_off
    .local int rx231_eos
    .local int rx231_rep
    .local pmc rx231_cur
    .local pmc rx231_debug
    (rx231_cur, rx231_pos, rx231_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx231_cur
    .local pmc match
    .lex "$/", match
    length rx231_eos, rx231_tgt
    gt rx231_pos, rx231_eos, rx231_done
    set rx231_off, 0
    lt rx231_pos, 2, rx231_start
    sub rx231_off, rx231_pos, 1
    substr rx231_tgt, rx231_tgt, rx231_off
  rx231_start:
    eq $I10, 1, rx231_restart
    if_null rx231_debug, debug_504
    rx231_cur."!cursor_debug"("START", "blockoid")
  debug_504:
    $I10 = self.'from'()
    ne $I10, -1, rxscan235_done
    goto rxscan235_scan
  rxscan235_loop:
    (rx231_pos) = rx231_cur."from"()
    inc rx231_pos
    rx231_cur."!cursor_from"(rx231_pos)
    ge rx231_pos, rx231_eos, rxscan235_done
  rxscan235_scan:
    set_addr $I10, rxscan235_loop
    rx231_cur."!mark_push"(0, rx231_pos, $I10)
  rxscan235_done:
.annotate 'line', 157
  # rx subrule "finishpad" subtype=method negate=
    rx231_cur."!cursor_pos"(rx231_pos)
    $P10 = rx231_cur."finishpad"()
    unless $P10, rx231_fail
    rx231_pos = $P10."pos"()
.annotate 'line', 158
  # rx literal  "{"
    add $I11, rx231_pos, 1
    gt $I11, rx231_eos, rx231_fail
    sub $I11, rx231_pos, rx231_off
    ord $I11, rx231_tgt, $I11
    ne $I11, 123, rx231_fail
    add rx231_pos, 1
  # rx subrule "statementlist" subtype=capture negate=
    rx231_cur."!cursor_pos"(rx231_pos)
    $P10 = rx231_cur."statementlist"()
    unless $P10, rx231_fail
    rx231_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx231_pos = $P10."pos"()
  alt236_0:
    set_addr $I10, alt236_1
    rx231_cur."!mark_push"(0, rx231_pos, $I10)
  # rx literal  "}"
    add $I11, rx231_pos, 1
    gt $I11, rx231_eos, rx231_fail
    sub $I11, rx231_pos, rx231_off
    ord $I11, rx231_tgt, $I11
    ne $I11, 125, rx231_fail
    add rx231_pos, 1
    goto alt236_end
  alt236_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx231_cur."!cursor_pos"(rx231_pos)
    $P10 = rx231_cur."FAILGOAL"("'}'")
    unless $P10, rx231_fail
    goto rxsubrule238_pass
  rxsubrule238_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx231_fail
  rxsubrule238_pass:
    set_addr $I10, rxsubrule238_back
    rx231_cur."!mark_push"(0, rx231_pos, $I10, $P10)
    rx231_pos = $P10."pos"()
  alt236_end:
.annotate 'line', 159
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx231_cur."!cursor_pos"(rx231_pos)
    $P10 = rx231_cur."ENDSTMT"()
    unless $P10, rx231_fail
.annotate 'line', 156
  # rx pass
    rx231_cur."!cursor_pass"(rx231_pos, "blockoid")
    if_null rx231_debug, debug_505
    rx231_cur."!cursor_debug"("PASS", "blockoid", " at pos=", rx231_pos)
  debug_505:
    .return (rx231_cur)
  rx231_restart:
.annotate 'line', 4
    if_null rx231_debug, debug_506
    rx231_cur."!cursor_debug"("NEXT", "blockoid")
  debug_506:
  rx231_fail:
    (rx231_rep, rx231_pos, $I10, $P10) = rx231_cur."!mark_fail"(0)
    lt rx231_pos, -1, rx231_done
    eq rx231_pos, -1, rx231_fail
    jump $I10
  rx231_done:
    rx231_cur."!cursor_fail"()
    if_null rx231_debug, debug_507
    rx231_cur."!cursor_debug"("FAIL", "blockoid")
  debug_507:
    .return (rx231_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blockoid"  :nsentry("!PREFIX__blockoid") :subid("47_1298325448.42642") :method
.annotate 'line', 4
    $P233 = self."!PREFIX__!subrule"("finishpad", "")
    new $P234, "ResizablePMCArray"
    push $P234, $P233
    .return ($P234)
.end


.namespace ["NQP";"Grammar"]
.sub "newpad"  :subid("48_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx240_tgt
    .local int rx240_pos
    .local int rx240_off
    .local int rx240_eos
    .local int rx240_rep
    .local pmc rx240_cur
    .local pmc rx240_debug
    (rx240_cur, rx240_pos, rx240_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx240_cur
    .local pmc match
    .lex "$/", match
    length rx240_eos, rx240_tgt
    gt rx240_pos, rx240_eos, rx240_done
    set rx240_off, 0
    lt rx240_pos, 2, rx240_start
    sub rx240_off, rx240_pos, 1
    substr rx240_tgt, rx240_tgt, rx240_off
  rx240_start:
    eq $I10, 1, rx240_restart
    if_null rx240_debug, debug_508
    rx240_cur."!cursor_debug"("START", "newpad")
  debug_508:
    $I10 = self.'from'()
    ne $I10, -1, rxscan243_done
    goto rxscan243_scan
  rxscan243_loop:
    (rx240_pos) = rx240_cur."from"()
    inc rx240_pos
    rx240_cur."!cursor_from"(rx240_pos)
    ge rx240_pos, rx240_eos, rxscan243_done
  rxscan243_scan:
    set_addr $I10, rxscan243_loop
    rx240_cur."!mark_push"(0, rx240_pos, $I10)
  rxscan243_done:
.annotate 'line', 162
  # rx pass
    rx240_cur."!cursor_pass"(rx240_pos, "newpad")
    if_null rx240_debug, debug_509
    rx240_cur."!cursor_debug"("PASS", "newpad", " at pos=", rx240_pos)
  debug_509:
    .return (rx240_cur)
  rx240_restart:
.annotate 'line', 4
    if_null rx240_debug, debug_510
    rx240_cur."!cursor_debug"("NEXT", "newpad")
  debug_510:
  rx240_fail:
    (rx240_rep, rx240_pos, $I10, $P10) = rx240_cur."!mark_fail"(0)
    lt rx240_pos, -1, rx240_done
    eq rx240_pos, -1, rx240_fail
    jump $I10
  rx240_done:
    rx240_cur."!cursor_fail"()
    if_null rx240_debug, debug_511
    rx240_cur."!cursor_debug"("FAIL", "newpad")
  debug_511:
    .return (rx240_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__newpad"  :nsentry("!PREFIX__newpad") :subid("49_1298325448.42642") :method
.annotate 'line', 4
    new $P242, "ResizablePMCArray"
    push $P242, ""
    .return ($P242)
.end


.namespace ["NQP";"Grammar"]
.sub "outerctx"  :subid("50_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx245_tgt
    .local int rx245_pos
    .local int rx245_off
    .local int rx245_eos
    .local int rx245_rep
    .local pmc rx245_cur
    .local pmc rx245_debug
    (rx245_cur, rx245_pos, rx245_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx245_cur
    .local pmc match
    .lex "$/", match
    length rx245_eos, rx245_tgt
    gt rx245_pos, rx245_eos, rx245_done
    set rx245_off, 0
    lt rx245_pos, 2, rx245_start
    sub rx245_off, rx245_pos, 1
    substr rx245_tgt, rx245_tgt, rx245_off
  rx245_start:
    eq $I10, 1, rx245_restart
    if_null rx245_debug, debug_512
    rx245_cur."!cursor_debug"("START", "outerctx")
  debug_512:
    $I10 = self.'from'()
    ne $I10, -1, rxscan248_done
    goto rxscan248_scan
  rxscan248_loop:
    (rx245_pos) = rx245_cur."from"()
    inc rx245_pos
    rx245_cur."!cursor_from"(rx245_pos)
    ge rx245_pos, rx245_eos, rxscan248_done
  rxscan248_scan:
    set_addr $I10, rxscan248_loop
    rx245_cur."!mark_push"(0, rx245_pos, $I10)
  rxscan248_done:
.annotate 'line', 163
  # rx pass
    rx245_cur."!cursor_pass"(rx245_pos, "outerctx")
    if_null rx245_debug, debug_513
    rx245_cur."!cursor_debug"("PASS", "outerctx", " at pos=", rx245_pos)
  debug_513:
    .return (rx245_cur)
  rx245_restart:
.annotate 'line', 4
    if_null rx245_debug, debug_514
    rx245_cur."!cursor_debug"("NEXT", "outerctx")
  debug_514:
  rx245_fail:
    (rx245_rep, rx245_pos, $I10, $P10) = rx245_cur."!mark_fail"(0)
    lt rx245_pos, -1, rx245_done
    eq rx245_pos, -1, rx245_fail
    jump $I10
  rx245_done:
    rx245_cur."!cursor_fail"()
    if_null rx245_debug, debug_515
    rx245_cur."!cursor_debug"("FAIL", "outerctx")
  debug_515:
    .return (rx245_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__outerctx"  :nsentry("!PREFIX__outerctx") :subid("51_1298325448.42642") :method
.annotate 'line', 4
    new $P247, "ResizablePMCArray"
    push $P247, ""
    .return ($P247)
.end


.namespace ["NQP";"Grammar"]
.sub "finishpad"  :subid("52_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx250_tgt
    .local int rx250_pos
    .local int rx250_off
    .local int rx250_eos
    .local int rx250_rep
    .local pmc rx250_cur
    .local pmc rx250_debug
    (rx250_cur, rx250_pos, rx250_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx250_cur
    .local pmc match
    .lex "$/", match
    length rx250_eos, rx250_tgt
    gt rx250_pos, rx250_eos, rx250_done
    set rx250_off, 0
    lt rx250_pos, 2, rx250_start
    sub rx250_off, rx250_pos, 1
    substr rx250_tgt, rx250_tgt, rx250_off
  rx250_start:
    eq $I10, 1, rx250_restart
    if_null rx250_debug, debug_516
    rx250_cur."!cursor_debug"("START", "finishpad")
  debug_516:
    $I10 = self.'from'()
    ne $I10, -1, rxscan253_done
    goto rxscan253_scan
  rxscan253_loop:
    (rx250_pos) = rx250_cur."from"()
    inc rx250_pos
    rx250_cur."!cursor_from"(rx250_pos)
    ge rx250_pos, rx250_eos, rxscan253_done
  rxscan253_scan:
    set_addr $I10, rxscan253_loop
    rx250_cur."!mark_push"(0, rx250_pos, $I10)
  rxscan253_done:
.annotate 'line', 164
  # rx pass
    rx250_cur."!cursor_pass"(rx250_pos, "finishpad")
    if_null rx250_debug, debug_517
    rx250_cur."!cursor_debug"("PASS", "finishpad", " at pos=", rx250_pos)
  debug_517:
    .return (rx250_cur)
  rx250_restart:
.annotate 'line', 4
    if_null rx250_debug, debug_518
    rx250_cur."!cursor_debug"("NEXT", "finishpad")
  debug_518:
  rx250_fail:
    (rx250_rep, rx250_pos, $I10, $P10) = rx250_cur."!mark_fail"(0)
    lt rx250_pos, -1, rx250_done
    eq rx250_pos, -1, rx250_fail
    jump $I10
  rx250_done:
    rx250_cur."!cursor_fail"()
    if_null rx250_debug, debug_519
    rx250_cur."!cursor_debug"("FAIL", "finishpad")
  debug_519:
    .return (rx250_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__finishpad"  :nsentry("!PREFIX__finishpad") :subid("53_1298325448.42642") :method
.annotate 'line', 4
    new $P252, "ResizablePMCArray"
    push $P252, ""
    .return ($P252)
.end


.namespace ["NQP";"Grammar"]
.sub "terminator"  :subid("54_1298325448.42642")
    .param pmc param_255
.annotate 'line', 166
    .lex "self", param_255
    $P256 = param_255."!protoregex"("terminator")
    .return ($P256)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator"  :subid("55_1298325448.42642")
    .param pmc param_258
.annotate 'line', 166
    .lex "self", param_258
    $P259 = param_258."!PREFIX__!protoregex"("terminator")
    .return ($P259)
.end


.namespace ["NQP";"Grammar"]
.sub "terminator:sym<;>"  :subid("56_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx261_tgt
    .local int rx261_pos
    .local int rx261_off
    .local int rx261_eos
    .local int rx261_rep
    .local pmc rx261_cur
    .local pmc rx261_debug
    (rx261_cur, rx261_pos, rx261_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx261_cur
    .local pmc match
    .lex "$/", match
    length rx261_eos, rx261_tgt
    gt rx261_pos, rx261_eos, rx261_done
    set rx261_off, 0
    lt rx261_pos, 2, rx261_start
    sub rx261_off, rx261_pos, 1
    substr rx261_tgt, rx261_tgt, rx261_off
  rx261_start:
    eq $I10, 1, rx261_restart
    if_null rx261_debug, debug_520
    rx261_cur."!cursor_debug"("START", "terminator:sym<;>")
  debug_520:
    $I10 = self.'from'()
    ne $I10, -1, rxscan264_done
    goto rxscan264_scan
  rxscan264_loop:
    (rx261_pos) = rx261_cur."from"()
    inc rx261_pos
    rx261_cur."!cursor_from"(rx261_pos)
    ge rx261_pos, rx261_eos, rxscan264_done
  rxscan264_scan:
    set_addr $I10, rxscan264_loop
    rx261_cur."!mark_push"(0, rx261_pos, $I10)
  rxscan264_done:
.annotate 'line', 168
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx261_pos, rx261_off
    substr $S10, rx261_tgt, $I10, 1
    index $I11, ";", $S10
    lt $I11, 0, rx261_fail
  # rx pass
    rx261_cur."!cursor_pass"(rx261_pos, "terminator:sym<;>")
    if_null rx261_debug, debug_521
    rx261_cur."!cursor_debug"("PASS", "terminator:sym<;>", " at pos=", rx261_pos)
  debug_521:
    .return (rx261_cur)
  rx261_restart:
.annotate 'line', 4
    if_null rx261_debug, debug_522
    rx261_cur."!cursor_debug"("NEXT", "terminator:sym<;>")
  debug_522:
  rx261_fail:
    (rx261_rep, rx261_pos, $I10, $P10) = rx261_cur."!mark_fail"(0)
    lt rx261_pos, -1, rx261_done
    eq rx261_pos, -1, rx261_fail
    jump $I10
  rx261_done:
    rx261_cur."!cursor_fail"()
    if_null rx261_debug, debug_523
    rx261_cur."!cursor_debug"("FAIL", "terminator:sym<;>")
  debug_523:
    .return (rx261_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<;>"  :nsentry("!PREFIX__terminator:sym<;>") :subid("57_1298325448.42642") :method
.annotate 'line', 4
    new $P263, "ResizablePMCArray"
    push $P263, ";"
    .return ($P263)
.end


.namespace ["NQP";"Grammar"]
.sub "terminator:sym<}>"  :subid("58_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx266_tgt
    .local int rx266_pos
    .local int rx266_off
    .local int rx266_eos
    .local int rx266_rep
    .local pmc rx266_cur
    .local pmc rx266_debug
    (rx266_cur, rx266_pos, rx266_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx266_cur
    .local pmc match
    .lex "$/", match
    length rx266_eos, rx266_tgt
    gt rx266_pos, rx266_eos, rx266_done
    set rx266_off, 0
    lt rx266_pos, 2, rx266_start
    sub rx266_off, rx266_pos, 1
    substr rx266_tgt, rx266_tgt, rx266_off
  rx266_start:
    eq $I10, 1, rx266_restart
    if_null rx266_debug, debug_524
    rx266_cur."!cursor_debug"("START", "terminator:sym<}>")
  debug_524:
    $I10 = self.'from'()
    ne $I10, -1, rxscan269_done
    goto rxscan269_scan
  rxscan269_loop:
    (rx266_pos) = rx266_cur."from"()
    inc rx266_pos
    rx266_cur."!cursor_from"(rx266_pos)
    ge rx266_pos, rx266_eos, rxscan269_done
  rxscan269_scan:
    set_addr $I10, rxscan269_loop
    rx266_cur."!mark_push"(0, rx266_pos, $I10)
  rxscan269_done:
.annotate 'line', 169
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx266_pos, rx266_off
    substr $S10, rx266_tgt, $I10, 1
    index $I11, "}", $S10
    lt $I11, 0, rx266_fail
  # rx pass
    rx266_cur."!cursor_pass"(rx266_pos, "terminator:sym<}>")
    if_null rx266_debug, debug_525
    rx266_cur."!cursor_debug"("PASS", "terminator:sym<}>", " at pos=", rx266_pos)
  debug_525:
    .return (rx266_cur)
  rx266_restart:
.annotate 'line', 4
    if_null rx266_debug, debug_526
    rx266_cur."!cursor_debug"("NEXT", "terminator:sym<}>")
  debug_526:
  rx266_fail:
    (rx266_rep, rx266_pos, $I10, $P10) = rx266_cur."!mark_fail"(0)
    lt rx266_pos, -1, rx266_done
    eq rx266_pos, -1, rx266_fail
    jump $I10
  rx266_done:
    rx266_cur."!cursor_fail"()
    if_null rx266_debug, debug_527
    rx266_cur."!cursor_debug"("FAIL", "terminator:sym<}>")
  debug_527:
    .return (rx266_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<}>"  :nsentry("!PREFIX__terminator:sym<}>") :subid("59_1298325448.42642") :method
.annotate 'line', 4
    new $P268, "ResizablePMCArray"
    push $P268, "}"
    .return ($P268)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_control"  :subid("60_1298325448.42642")
    .param pmc param_271
.annotate 'line', 173
    .lex "self", param_271
    $P272 = param_271."!protoregex"("statement_control")
    .return ($P272)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control"  :subid("61_1298325448.42642")
    .param pmc param_274
.annotate 'line', 173
    .lex "self", param_274
    $P275 = param_274."!PREFIX__!protoregex"("statement_control")
    .return ($P275)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<if>"  :subid("62_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx277_tgt
    .local int rx277_pos
    .local int rx277_off
    .local int rx277_eos
    .local int rx277_rep
    .local pmc rx277_cur
    .local pmc rx277_debug
    (rx277_cur, rx277_pos, rx277_tgt, $I10) = self."!cursor_start"()
    rx277_cur."!cursor_caparray"("xblock", "else")
    .lex unicode:"$\x{a2}", rx277_cur
    .local pmc match
    .lex "$/", match
    length rx277_eos, rx277_tgt
    gt rx277_pos, rx277_eos, rx277_done
    set rx277_off, 0
    lt rx277_pos, 2, rx277_start
    sub rx277_off, rx277_pos, 1
    substr rx277_tgt, rx277_tgt, rx277_off
  rx277_start:
    eq $I10, 1, rx277_restart
    if_null rx277_debug, debug_528
    rx277_cur."!cursor_debug"("START", "statement_control:sym<if>")
  debug_528:
    $I10 = self.'from'()
    ne $I10, -1, rxscan280_done
    goto rxscan280_scan
  rxscan280_loop:
    (rx277_pos) = rx277_cur."from"()
    inc rx277_pos
    rx277_cur."!cursor_from"(rx277_pos)
    ge rx277_pos, rx277_eos, rxscan280_done
  rxscan280_scan:
    set_addr $I10, rxscan280_loop
    rx277_cur."!mark_push"(0, rx277_pos, $I10)
  rxscan280_done:
.annotate 'line', 176
  # rx subcapture "sym"
    set_addr $I10, rxcap_281_fail
    rx277_cur."!mark_push"(0, rx277_pos, $I10)
  # rx literal  "if"
    add $I11, rx277_pos, 2
    gt $I11, rx277_eos, rx277_fail
    sub $I11, rx277_pos, rx277_off
    substr $S10, rx277_tgt, $I11, 2
    ne $S10, "if", rx277_fail
    add rx277_pos, 2
    set_addr $I10, rxcap_281_fail
    ($I12, $I11) = rx277_cur."!mark_peek"($I10)
    rx277_cur."!cursor_pos"($I11)
    ($P10) = rx277_cur."!cursor_start"()
    $P10."!cursor_pass"(rx277_pos, "")
    rx277_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_281_done
  rxcap_281_fail:
    goto rx277_fail
  rxcap_281_done:
  # rx charclass s
    ge rx277_pos, rx277_eos, rx277_fail
    sub $I10, rx277_pos, rx277_off
    is_cclass $I11, 32, rx277_tgt, $I10
    unless $I11, rx277_fail
    inc rx277_pos
  # rx subrule "ws" subtype=method negate=
    rx277_cur."!cursor_pos"(rx277_pos)
    $P10 = rx277_cur."ws"()
    unless $P10, rx277_fail
    rx277_pos = $P10."pos"()
.annotate 'line', 177
  # rx subrule "xblock" subtype=capture negate=
    rx277_cur."!cursor_pos"(rx277_pos)
    $P10 = rx277_cur."xblock"()
    unless $P10, rx277_fail
    rx277_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx277_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx277_cur."!cursor_pos"(rx277_pos)
    $P10 = rx277_cur."ws"()
    unless $P10, rx277_fail
    rx277_pos = $P10."pos"()
.annotate 'line', 178
  # rx rxquantr284 ** 0..*
    set_addr $I10, rxquantr284_done
    rx277_cur."!mark_push"(0, rx277_pos, $I10)
  rxquantr284_loop:
  # rx subrule "ws" subtype=method negate=
    rx277_cur."!cursor_pos"(rx277_pos)
    $P10 = rx277_cur."ws"()
    unless $P10, rx277_fail
    rx277_pos = $P10."pos"()
  # rx literal  "elsif"
    add $I11, rx277_pos, 5
    gt $I11, rx277_eos, rx277_fail
    sub $I11, rx277_pos, rx277_off
    substr $S10, rx277_tgt, $I11, 5
    ne $S10, "elsif", rx277_fail
    add rx277_pos, 5
  # rx charclass s
    ge rx277_pos, rx277_eos, rx277_fail
    sub $I10, rx277_pos, rx277_off
    is_cclass $I11, 32, rx277_tgt, $I10
    unless $I11, rx277_fail
    inc rx277_pos
  # rx subrule "ws" subtype=method negate=
    rx277_cur."!cursor_pos"(rx277_pos)
    $P10 = rx277_cur."ws"()
    unless $P10, rx277_fail
    rx277_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx277_cur."!cursor_pos"(rx277_pos)
    $P10 = rx277_cur."xblock"()
    unless $P10, rx277_fail
    rx277_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx277_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx277_cur."!cursor_pos"(rx277_pos)
    $P10 = rx277_cur."ws"()
    unless $P10, rx277_fail
    rx277_pos = $P10."pos"()
    set_addr $I10, rxquantr284_done
    (rx277_rep) = rx277_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr284_done
    rx277_cur."!mark_push"(rx277_rep, rx277_pos, $I10)
    goto rxquantr284_loop
  rxquantr284_done:
  # rx subrule "ws" subtype=method negate=
    rx277_cur."!cursor_pos"(rx277_pos)
    $P10 = rx277_cur."ws"()
    unless $P10, rx277_fail
    rx277_pos = $P10."pos"()
.annotate 'line', 179
  # rx rxquantr289 ** 0..1
    set_addr $I10, rxquantr289_done
    rx277_cur."!mark_push"(0, rx277_pos, $I10)
  rxquantr289_loop:
  # rx subrule "ws" subtype=method negate=
    rx277_cur."!cursor_pos"(rx277_pos)
    $P10 = rx277_cur."ws"()
    unless $P10, rx277_fail
    rx277_pos = $P10."pos"()
  # rx literal  "else"
    add $I11, rx277_pos, 4
    gt $I11, rx277_eos, rx277_fail
    sub $I11, rx277_pos, rx277_off
    substr $S10, rx277_tgt, $I11, 4
    ne $S10, "else", rx277_fail
    add rx277_pos, 4
  # rx charclass s
    ge rx277_pos, rx277_eos, rx277_fail
    sub $I10, rx277_pos, rx277_off
    is_cclass $I11, 32, rx277_tgt, $I10
    unless $I11, rx277_fail
    inc rx277_pos
  # rx subrule "ws" subtype=method negate=
    rx277_cur."!cursor_pos"(rx277_pos)
    $P10 = rx277_cur."ws"()
    unless $P10, rx277_fail
    rx277_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx277_cur."!cursor_pos"(rx277_pos)
    $P10 = rx277_cur."pblock"()
    unless $P10, rx277_fail
    rx277_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("else")
    rx277_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx277_cur."!cursor_pos"(rx277_pos)
    $P10 = rx277_cur."ws"()
    unless $P10, rx277_fail
    rx277_pos = $P10."pos"()
    set_addr $I10, rxquantr289_done
    (rx277_rep) = rx277_cur."!mark_commit"($I10)
  rxquantr289_done:
  # rx subrule "ws" subtype=method negate=
    rx277_cur."!cursor_pos"(rx277_pos)
    $P10 = rx277_cur."ws"()
    unless $P10, rx277_fail
    rx277_pos = $P10."pos"()
.annotate 'line', 175
  # rx pass
    rx277_cur."!cursor_pass"(rx277_pos, "statement_control:sym<if>")
    if_null rx277_debug, debug_529
    rx277_cur."!cursor_debug"("PASS", "statement_control:sym<if>", " at pos=", rx277_pos)
  debug_529:
    .return (rx277_cur)
  rx277_restart:
.annotate 'line', 4
    if_null rx277_debug, debug_530
    rx277_cur."!cursor_debug"("NEXT", "statement_control:sym<if>")
  debug_530:
  rx277_fail:
    (rx277_rep, rx277_pos, $I10, $P10) = rx277_cur."!mark_fail"(0)
    lt rx277_pos, -1, rx277_done
    eq rx277_pos, -1, rx277_fail
    jump $I10
  rx277_done:
    rx277_cur."!cursor_fail"()
    if_null rx277_debug, debug_531
    rx277_cur."!cursor_debug"("FAIL", "statement_control:sym<if>")
  debug_531:
    .return (rx277_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<if>"  :nsentry("!PREFIX__statement_control:sym<if>") :subid("63_1298325448.42642") :method
.annotate 'line', 4
    new $P279, "ResizablePMCArray"
    push $P279, "if"
    .return ($P279)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<unless>"  :subid("64_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .const 'Sub' $P305 = "66_1298325448.42642" 
    capture_lex $P305
    .local string rx295_tgt
    .local int rx295_pos
    .local int rx295_off
    .local int rx295_eos
    .local int rx295_rep
    .local pmc rx295_cur
    .local pmc rx295_debug
    (rx295_cur, rx295_pos, rx295_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx295_cur
    .local pmc match
    .lex "$/", match
    length rx295_eos, rx295_tgt
    gt rx295_pos, rx295_eos, rx295_done
    set rx295_off, 0
    lt rx295_pos, 2, rx295_start
    sub rx295_off, rx295_pos, 1
    substr rx295_tgt, rx295_tgt, rx295_off
  rx295_start:
    eq $I10, 1, rx295_restart
    if_null rx295_debug, debug_532
    rx295_cur."!cursor_debug"("START", "statement_control:sym<unless>")
  debug_532:
    $I10 = self.'from'()
    ne $I10, -1, rxscan298_done
    goto rxscan298_scan
  rxscan298_loop:
    (rx295_pos) = rx295_cur."from"()
    inc rx295_pos
    rx295_cur."!cursor_from"(rx295_pos)
    ge rx295_pos, rx295_eos, rxscan298_done
  rxscan298_scan:
    set_addr $I10, rxscan298_loop
    rx295_cur."!mark_push"(0, rx295_pos, $I10)
  rxscan298_done:
.annotate 'line', 183
  # rx subcapture "sym"
    set_addr $I10, rxcap_299_fail
    rx295_cur."!mark_push"(0, rx295_pos, $I10)
  # rx literal  "unless"
    add $I11, rx295_pos, 6
    gt $I11, rx295_eos, rx295_fail
    sub $I11, rx295_pos, rx295_off
    substr $S10, rx295_tgt, $I11, 6
    ne $S10, "unless", rx295_fail
    add rx295_pos, 6
    set_addr $I10, rxcap_299_fail
    ($I12, $I11) = rx295_cur."!mark_peek"($I10)
    rx295_cur."!cursor_pos"($I11)
    ($P10) = rx295_cur."!cursor_start"()
    $P10."!cursor_pass"(rx295_pos, "")
    rx295_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_299_done
  rxcap_299_fail:
    goto rx295_fail
  rxcap_299_done:
  # rx charclass s
    ge rx295_pos, rx295_eos, rx295_fail
    sub $I10, rx295_pos, rx295_off
    is_cclass $I11, 32, rx295_tgt, $I10
    unless $I11, rx295_fail
    inc rx295_pos
  # rx subrule "ws" subtype=method negate=
    rx295_cur."!cursor_pos"(rx295_pos)
    $P10 = rx295_cur."ws"()
    unless $P10, rx295_fail
    rx295_pos = $P10."pos"()
.annotate 'line', 184
  # rx subrule "xblock" subtype=capture negate=
    rx295_cur."!cursor_pos"(rx295_pos)
    $P10 = rx295_cur."xblock"()
    unless $P10, rx295_fail
    rx295_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx295_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx295_cur."!cursor_pos"(rx295_pos)
    $P10 = rx295_cur."ws"()
    unless $P10, rx295_fail
    rx295_pos = $P10."pos"()
  alt302_0:
.annotate 'line', 185
    set_addr $I10, alt302_1
    rx295_cur."!mark_push"(0, rx295_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx295_cur."!cursor_pos"(rx295_pos)
    $P10 = rx295_cur."ws"()
    unless $P10, rx295_fail
    rx295_pos = $P10."pos"()
  # rx subrule "before" subtype=zerowidth negate=1
    rx295_cur."!cursor_pos"(rx295_pos)
    .const 'Sub' $P305 = "66_1298325448.42642" 
    capture_lex $P305
    $P10 = rx295_cur."before"($P305)
    if $P10, rx295_fail
  # rx subrule "ws" subtype=method negate=
    rx295_cur."!cursor_pos"(rx295_pos)
    $P10 = rx295_cur."ws"()
    unless $P10, rx295_fail
    rx295_pos = $P10."pos"()
    goto alt302_end
  alt302_1:
  # rx subrule "ws" subtype=method negate=
    rx295_cur."!cursor_pos"(rx295_pos)
    $P10 = rx295_cur."ws"()
    unless $P10, rx295_fail
    rx295_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx295_cur."!cursor_pos"(rx295_pos)
    $P10 = rx295_cur."panic"("unless does not take \"else\", please rewrite using \"if\"")
    unless $P10, rx295_fail
    rx295_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx295_cur."!cursor_pos"(rx295_pos)
    $P10 = rx295_cur."ws"()
    unless $P10, rx295_fail
    rx295_pos = $P10."pos"()
  alt302_end:
  # rx subrule "ws" subtype=method negate=
    rx295_cur."!cursor_pos"(rx295_pos)
    $P10 = rx295_cur."ws"()
    unless $P10, rx295_fail
    rx295_pos = $P10."pos"()
.annotate 'line', 182
  # rx pass
    rx295_cur."!cursor_pass"(rx295_pos, "statement_control:sym<unless>")
    if_null rx295_debug, debug_537
    rx295_cur."!cursor_debug"("PASS", "statement_control:sym<unless>", " at pos=", rx295_pos)
  debug_537:
    .return (rx295_cur)
  rx295_restart:
.annotate 'line', 4
    if_null rx295_debug, debug_538
    rx295_cur."!cursor_debug"("NEXT", "statement_control:sym<unless>")
  debug_538:
  rx295_fail:
    (rx295_rep, rx295_pos, $I10, $P10) = rx295_cur."!mark_fail"(0)
    lt rx295_pos, -1, rx295_done
    eq rx295_pos, -1, rx295_fail
    jump $I10
  rx295_done:
    rx295_cur."!cursor_fail"()
    if_null rx295_debug, debug_539
    rx295_cur."!cursor_debug"("FAIL", "statement_control:sym<unless>")
  debug_539:
    .return (rx295_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<unless>"  :nsentry("!PREFIX__statement_control:sym<unless>") :subid("65_1298325448.42642") :method
.annotate 'line', 4
    new $P297, "ResizablePMCArray"
    push $P297, "unless"
    .return ($P297)
.end


.namespace ["NQP";"Grammar"]
.sub "_block304"  :anon :subid("66_1298325448.42642") :method :outer("64_1298325448.42642")
.annotate 'line', 185
    .local string rx306_tgt
    .local int rx306_pos
    .local int rx306_off
    .local int rx306_eos
    .local int rx306_rep
    .local pmc rx306_cur
    .local pmc rx306_debug
    (rx306_cur, rx306_pos, rx306_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx306_cur
    .local pmc match
    .lex "$/", match
    length rx306_eos, rx306_tgt
    gt rx306_pos, rx306_eos, rx306_done
    set rx306_off, 0
    lt rx306_pos, 2, rx306_start
    sub rx306_off, rx306_pos, 1
    substr rx306_tgt, rx306_tgt, rx306_off
  rx306_start:
    eq $I10, 1, rx306_restart
    if_null rx306_debug, debug_533
    rx306_cur."!cursor_debug"("START", "")
  debug_533:
    $I10 = self.'from'()
    ne $I10, -1, rxscan307_done
    goto rxscan307_scan
  rxscan307_loop:
    (rx306_pos) = rx306_cur."from"()
    inc rx306_pos
    rx306_cur."!cursor_from"(rx306_pos)
    ge rx306_pos, rx306_eos, rxscan307_done
  rxscan307_scan:
    set_addr $I10, rxscan307_loop
    rx306_cur."!mark_push"(0, rx306_pos, $I10)
  rxscan307_done:
  # rx literal  "else"
    add $I11, rx306_pos, 4
    gt $I11, rx306_eos, rx306_fail
    sub $I11, rx306_pos, rx306_off
    substr $S10, rx306_tgt, $I11, 4
    ne $S10, "else", rx306_fail
    add rx306_pos, 4
  # rx pass
    rx306_cur."!cursor_pass"(rx306_pos, "")
    if_null rx306_debug, debug_534
    rx306_cur."!cursor_debug"("PASS", "", " at pos=", rx306_pos)
  debug_534:
    .return (rx306_cur)
  rx306_restart:
    if_null rx306_debug, debug_535
    rx306_cur."!cursor_debug"("NEXT", "")
  debug_535:
  rx306_fail:
    (rx306_rep, rx306_pos, $I10, $P10) = rx306_cur."!mark_fail"(0)
    lt rx306_pos, -1, rx306_done
    eq rx306_pos, -1, rx306_fail
    jump $I10
  rx306_done:
    rx306_cur."!cursor_fail"()
    if_null rx306_debug, debug_536
    rx306_cur."!cursor_debug"("FAIL", "")
  debug_536:
    .return (rx306_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<while>"  :subid("67_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx313_tgt
    .local int rx313_pos
    .local int rx313_off
    .local int rx313_eos
    .local int rx313_rep
    .local pmc rx313_cur
    .local pmc rx313_debug
    (rx313_cur, rx313_pos, rx313_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx313_cur
    .local pmc match
    .lex "$/", match
    length rx313_eos, rx313_tgt
    gt rx313_pos, rx313_eos, rx313_done
    set rx313_off, 0
    lt rx313_pos, 2, rx313_start
    sub rx313_off, rx313_pos, 1
    substr rx313_tgt, rx313_tgt, rx313_off
  rx313_start:
    eq $I10, 1, rx313_restart
    if_null rx313_debug, debug_540
    rx313_cur."!cursor_debug"("START", "statement_control:sym<while>")
  debug_540:
    $I10 = self.'from'()
    ne $I10, -1, rxscan316_done
    goto rxscan316_scan
  rxscan316_loop:
    (rx313_pos) = rx313_cur."from"()
    inc rx313_pos
    rx313_cur."!cursor_from"(rx313_pos)
    ge rx313_pos, rx313_eos, rxscan316_done
  rxscan316_scan:
    set_addr $I10, rxscan316_loop
    rx313_cur."!mark_push"(0, rx313_pos, $I10)
  rxscan316_done:
.annotate 'line', 189
  # rx subcapture "sym"
    set_addr $I10, rxcap_318_fail
    rx313_cur."!mark_push"(0, rx313_pos, $I10)
  alt317_0:
    set_addr $I10, alt317_1
    rx313_cur."!mark_push"(0, rx313_pos, $I10)
  # rx literal  "while"
    add $I11, rx313_pos, 5
    gt $I11, rx313_eos, rx313_fail
    sub $I11, rx313_pos, rx313_off
    substr $S10, rx313_tgt, $I11, 5
    ne $S10, "while", rx313_fail
    add rx313_pos, 5
    goto alt317_end
  alt317_1:
  # rx literal  "until"
    add $I11, rx313_pos, 5
    gt $I11, rx313_eos, rx313_fail
    sub $I11, rx313_pos, rx313_off
    substr $S10, rx313_tgt, $I11, 5
    ne $S10, "until", rx313_fail
    add rx313_pos, 5
  alt317_end:
    set_addr $I10, rxcap_318_fail
    ($I12, $I11) = rx313_cur."!mark_peek"($I10)
    rx313_cur."!cursor_pos"($I11)
    ($P10) = rx313_cur."!cursor_start"()
    $P10."!cursor_pass"(rx313_pos, "")
    rx313_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_318_done
  rxcap_318_fail:
    goto rx313_fail
  rxcap_318_done:
  # rx charclass s
    ge rx313_pos, rx313_eos, rx313_fail
    sub $I10, rx313_pos, rx313_off
    is_cclass $I11, 32, rx313_tgt, $I10
    unless $I11, rx313_fail
    inc rx313_pos
  # rx subrule "ws" subtype=method negate=
    rx313_cur."!cursor_pos"(rx313_pos)
    $P10 = rx313_cur."ws"()
    unless $P10, rx313_fail
    rx313_pos = $P10."pos"()
.annotate 'line', 190
  # rx subrule "xblock" subtype=capture negate=
    rx313_cur."!cursor_pos"(rx313_pos)
    $P10 = rx313_cur."xblock"()
    unless $P10, rx313_fail
    rx313_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx313_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx313_cur."!cursor_pos"(rx313_pos)
    $P10 = rx313_cur."ws"()
    unless $P10, rx313_fail
    rx313_pos = $P10."pos"()
.annotate 'line', 188
  # rx pass
    rx313_cur."!cursor_pass"(rx313_pos, "statement_control:sym<while>")
    if_null rx313_debug, debug_541
    rx313_cur."!cursor_debug"("PASS", "statement_control:sym<while>", " at pos=", rx313_pos)
  debug_541:
    .return (rx313_cur)
  rx313_restart:
.annotate 'line', 4
    if_null rx313_debug, debug_542
    rx313_cur."!cursor_debug"("NEXT", "statement_control:sym<while>")
  debug_542:
  rx313_fail:
    (rx313_rep, rx313_pos, $I10, $P10) = rx313_cur."!mark_fail"(0)
    lt rx313_pos, -1, rx313_done
    eq rx313_pos, -1, rx313_fail
    jump $I10
  rx313_done:
    rx313_cur."!cursor_fail"()
    if_null rx313_debug, debug_543
    rx313_cur."!cursor_debug"("FAIL", "statement_control:sym<while>")
  debug_543:
    .return (rx313_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<while>"  :nsentry("!PREFIX__statement_control:sym<while>") :subid("68_1298325448.42642") :method
.annotate 'line', 4
    new $P315, "ResizablePMCArray"
    push $P315, "until"
    push $P315, "while"
    .return ($P315)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<repeat>"  :subid("69_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx322_tgt
    .local int rx322_pos
    .local int rx322_off
    .local int rx322_eos
    .local int rx322_rep
    .local pmc rx322_cur
    .local pmc rx322_debug
    (rx322_cur, rx322_pos, rx322_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx322_cur
    .local pmc match
    .lex "$/", match
    length rx322_eos, rx322_tgt
    gt rx322_pos, rx322_eos, rx322_done
    set rx322_off, 0
    lt rx322_pos, 2, rx322_start
    sub rx322_off, rx322_pos, 1
    substr rx322_tgt, rx322_tgt, rx322_off
  rx322_start:
    eq $I10, 1, rx322_restart
    if_null rx322_debug, debug_544
    rx322_cur."!cursor_debug"("START", "statement_control:sym<repeat>")
  debug_544:
    $I10 = self.'from'()
    ne $I10, -1, rxscan325_done
    goto rxscan325_scan
  rxscan325_loop:
    (rx322_pos) = rx322_cur."from"()
    inc rx322_pos
    rx322_cur."!cursor_from"(rx322_pos)
    ge rx322_pos, rx322_eos, rxscan325_done
  rxscan325_scan:
    set_addr $I10, rxscan325_loop
    rx322_cur."!mark_push"(0, rx322_pos, $I10)
  rxscan325_done:
.annotate 'line', 194
  # rx subcapture "sym"
    set_addr $I10, rxcap_326_fail
    rx322_cur."!mark_push"(0, rx322_pos, $I10)
  # rx literal  "repeat"
    add $I11, rx322_pos, 6
    gt $I11, rx322_eos, rx322_fail
    sub $I11, rx322_pos, rx322_off
    substr $S10, rx322_tgt, $I11, 6
    ne $S10, "repeat", rx322_fail
    add rx322_pos, 6
    set_addr $I10, rxcap_326_fail
    ($I12, $I11) = rx322_cur."!mark_peek"($I10)
    rx322_cur."!cursor_pos"($I11)
    ($P10) = rx322_cur."!cursor_start"()
    $P10."!cursor_pass"(rx322_pos, "")
    rx322_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_326_done
  rxcap_326_fail:
    goto rx322_fail
  rxcap_326_done:
  # rx charclass s
    ge rx322_pos, rx322_eos, rx322_fail
    sub $I10, rx322_pos, rx322_off
    is_cclass $I11, 32, rx322_tgt, $I10
    unless $I11, rx322_fail
    inc rx322_pos
  # rx subrule "ws" subtype=method negate=
    rx322_cur."!cursor_pos"(rx322_pos)
    $P10 = rx322_cur."ws"()
    unless $P10, rx322_fail
    rx322_pos = $P10."pos"()
  alt328_0:
.annotate 'line', 195
    set_addr $I10, alt328_1
    rx322_cur."!mark_push"(0, rx322_pos, $I10)
.annotate 'line', 196
  # rx subrule "ws" subtype=method negate=
    rx322_cur."!cursor_pos"(rx322_pos)
    $P10 = rx322_cur."ws"()
    unless $P10, rx322_fail
    rx322_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_331_fail
    rx322_cur."!mark_push"(0, rx322_pos, $I10)
  alt330_0:
    set_addr $I10, alt330_1
    rx322_cur."!mark_push"(0, rx322_pos, $I10)
  # rx literal  "while"
    add $I11, rx322_pos, 5
    gt $I11, rx322_eos, rx322_fail
    sub $I11, rx322_pos, rx322_off
    substr $S10, rx322_tgt, $I11, 5
    ne $S10, "while", rx322_fail
    add rx322_pos, 5
    goto alt330_end
  alt330_1:
  # rx literal  "until"
    add $I11, rx322_pos, 5
    gt $I11, rx322_eos, rx322_fail
    sub $I11, rx322_pos, rx322_off
    substr $S10, rx322_tgt, $I11, 5
    ne $S10, "until", rx322_fail
    add rx322_pos, 5
  alt330_end:
    set_addr $I10, rxcap_331_fail
    ($I12, $I11) = rx322_cur."!mark_peek"($I10)
    rx322_cur."!cursor_pos"($I11)
    ($P10) = rx322_cur."!cursor_start"()
    $P10."!cursor_pass"(rx322_pos, "")
    rx322_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_331_done
  rxcap_331_fail:
    goto rx322_fail
  rxcap_331_done:
  # rx charclass s
    ge rx322_pos, rx322_eos, rx322_fail
    sub $I10, rx322_pos, rx322_off
    is_cclass $I11, 32, rx322_tgt, $I10
    unless $I11, rx322_fail
    inc rx322_pos
  # rx subrule "ws" subtype=method negate=
    rx322_cur."!cursor_pos"(rx322_pos)
    $P10 = rx322_cur."ws"()
    unless $P10, rx322_fail
    rx322_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx322_cur."!cursor_pos"(rx322_pos)
    $P10 = rx322_cur."xblock"()
    unless $P10, rx322_fail
    rx322_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx322_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx322_cur."!cursor_pos"(rx322_pos)
    $P10 = rx322_cur."ws"()
    unless $P10, rx322_fail
    rx322_pos = $P10."pos"()
    goto alt328_end
  alt328_1:
.annotate 'line', 197
  # rx subrule "ws" subtype=method negate=
    rx322_cur."!cursor_pos"(rx322_pos)
    $P10 = rx322_cur."ws"()
    unless $P10, rx322_fail
    rx322_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx322_cur."!cursor_pos"(rx322_pos)
    $P10 = rx322_cur."pblock"()
    unless $P10, rx322_fail
    rx322_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx322_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx322_cur."!cursor_pos"(rx322_pos)
    $P10 = rx322_cur."ws"()
    unless $P10, rx322_fail
    rx322_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_337_fail
    rx322_cur."!mark_push"(0, rx322_pos, $I10)
  alt336_0:
    set_addr $I10, alt336_1
    rx322_cur."!mark_push"(0, rx322_pos, $I10)
  # rx literal  "while"
    add $I11, rx322_pos, 5
    gt $I11, rx322_eos, rx322_fail
    sub $I11, rx322_pos, rx322_off
    substr $S10, rx322_tgt, $I11, 5
    ne $S10, "while", rx322_fail
    add rx322_pos, 5
    goto alt336_end
  alt336_1:
  # rx literal  "until"
    add $I11, rx322_pos, 5
    gt $I11, rx322_eos, rx322_fail
    sub $I11, rx322_pos, rx322_off
    substr $S10, rx322_tgt, $I11, 5
    ne $S10, "until", rx322_fail
    add rx322_pos, 5
  alt336_end:
    set_addr $I10, rxcap_337_fail
    ($I12, $I11) = rx322_cur."!mark_peek"($I10)
    rx322_cur."!cursor_pos"($I11)
    ($P10) = rx322_cur."!cursor_start"()
    $P10."!cursor_pass"(rx322_pos, "")
    rx322_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_337_done
  rxcap_337_fail:
    goto rx322_fail
  rxcap_337_done:
  # rx charclass s
    ge rx322_pos, rx322_eos, rx322_fail
    sub $I10, rx322_pos, rx322_off
    is_cclass $I11, 32, rx322_tgt, $I10
    unless $I11, rx322_fail
    inc rx322_pos
  # rx subrule "ws" subtype=method negate=
    rx322_cur."!cursor_pos"(rx322_pos)
    $P10 = rx322_cur."ws"()
    unless $P10, rx322_fail
    rx322_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx322_cur."!cursor_pos"(rx322_pos)
    $P10 = rx322_cur."EXPR"()
    unless $P10, rx322_fail
    rx322_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx322_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx322_cur."!cursor_pos"(rx322_pos)
    $P10 = rx322_cur."ws"()
    unless $P10, rx322_fail
    rx322_pos = $P10."pos"()
  alt328_end:
.annotate 'line', 198
  # rx subrule "ws" subtype=method negate=
    rx322_cur."!cursor_pos"(rx322_pos)
    $P10 = rx322_cur."ws"()
    unless $P10, rx322_fail
    rx322_pos = $P10."pos"()
.annotate 'line', 193
  # rx pass
    rx322_cur."!cursor_pass"(rx322_pos, "statement_control:sym<repeat>")
    if_null rx322_debug, debug_545
    rx322_cur."!cursor_debug"("PASS", "statement_control:sym<repeat>", " at pos=", rx322_pos)
  debug_545:
    .return (rx322_cur)
  rx322_restart:
.annotate 'line', 4
    if_null rx322_debug, debug_546
    rx322_cur."!cursor_debug"("NEXT", "statement_control:sym<repeat>")
  debug_546:
  rx322_fail:
    (rx322_rep, rx322_pos, $I10, $P10) = rx322_cur."!mark_fail"(0)
    lt rx322_pos, -1, rx322_done
    eq rx322_pos, -1, rx322_fail
    jump $I10
  rx322_done:
    rx322_cur."!cursor_fail"()
    if_null rx322_debug, debug_547
    rx322_cur."!cursor_debug"("FAIL", "statement_control:sym<repeat>")
  debug_547:
    .return (rx322_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<repeat>"  :nsentry("!PREFIX__statement_control:sym<repeat>") :subid("70_1298325448.42642") :method
.annotate 'line', 4
    new $P324, "ResizablePMCArray"
    push $P324, "repeat"
    .return ($P324)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<for>"  :subid("71_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx342_tgt
    .local int rx342_pos
    .local int rx342_off
    .local int rx342_eos
    .local int rx342_rep
    .local pmc rx342_cur
    .local pmc rx342_debug
    (rx342_cur, rx342_pos, rx342_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx342_cur
    .local pmc match
    .lex "$/", match
    length rx342_eos, rx342_tgt
    gt rx342_pos, rx342_eos, rx342_done
    set rx342_off, 0
    lt rx342_pos, 2, rx342_start
    sub rx342_off, rx342_pos, 1
    substr rx342_tgt, rx342_tgt, rx342_off
  rx342_start:
    eq $I10, 1, rx342_restart
    if_null rx342_debug, debug_548
    rx342_cur."!cursor_debug"("START", "statement_control:sym<for>")
  debug_548:
    $I10 = self.'from'()
    ne $I10, -1, rxscan345_done
    goto rxscan345_scan
  rxscan345_loop:
    (rx342_pos) = rx342_cur."from"()
    inc rx342_pos
    rx342_cur."!cursor_from"(rx342_pos)
    ge rx342_pos, rx342_eos, rxscan345_done
  rxscan345_scan:
    set_addr $I10, rxscan345_loop
    rx342_cur."!mark_push"(0, rx342_pos, $I10)
  rxscan345_done:
.annotate 'line', 202
  # rx subcapture "sym"
    set_addr $I10, rxcap_346_fail
    rx342_cur."!mark_push"(0, rx342_pos, $I10)
  # rx literal  "for"
    add $I11, rx342_pos, 3
    gt $I11, rx342_eos, rx342_fail
    sub $I11, rx342_pos, rx342_off
    substr $S10, rx342_tgt, $I11, 3
    ne $S10, "for", rx342_fail
    add rx342_pos, 3
    set_addr $I10, rxcap_346_fail
    ($I12, $I11) = rx342_cur."!mark_peek"($I10)
    rx342_cur."!cursor_pos"($I11)
    ($P10) = rx342_cur."!cursor_start"()
    $P10."!cursor_pass"(rx342_pos, "")
    rx342_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_346_done
  rxcap_346_fail:
    goto rx342_fail
  rxcap_346_done:
  # rx charclass s
    ge rx342_pos, rx342_eos, rx342_fail
    sub $I10, rx342_pos, rx342_off
    is_cclass $I11, 32, rx342_tgt, $I10
    unless $I11, rx342_fail
    inc rx342_pos
  # rx subrule "ws" subtype=method negate=
    rx342_cur."!cursor_pos"(rx342_pos)
    $P10 = rx342_cur."ws"()
    unless $P10, rx342_fail
    rx342_pos = $P10."pos"()
.annotate 'line', 203
  # rx subrule "xblock" subtype=capture negate=
    rx342_cur."!cursor_pos"(rx342_pos)
    $P10 = rx342_cur."xblock"()
    unless $P10, rx342_fail
    rx342_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx342_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx342_cur."!cursor_pos"(rx342_pos)
    $P10 = rx342_cur."ws"()
    unless $P10, rx342_fail
    rx342_pos = $P10."pos"()
.annotate 'line', 201
  # rx pass
    rx342_cur."!cursor_pass"(rx342_pos, "statement_control:sym<for>")
    if_null rx342_debug, debug_549
    rx342_cur."!cursor_debug"("PASS", "statement_control:sym<for>", " at pos=", rx342_pos)
  debug_549:
    .return (rx342_cur)
  rx342_restart:
.annotate 'line', 4
    if_null rx342_debug, debug_550
    rx342_cur."!cursor_debug"("NEXT", "statement_control:sym<for>")
  debug_550:
  rx342_fail:
    (rx342_rep, rx342_pos, $I10, $P10) = rx342_cur."!mark_fail"(0)
    lt rx342_pos, -1, rx342_done
    eq rx342_pos, -1, rx342_fail
    jump $I10
  rx342_done:
    rx342_cur."!cursor_fail"()
    if_null rx342_debug, debug_551
    rx342_cur."!cursor_debug"("FAIL", "statement_control:sym<for>")
  debug_551:
    .return (rx342_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<for>"  :nsentry("!PREFIX__statement_control:sym<for>") :subid("72_1298325448.42642") :method
.annotate 'line', 4
    new $P344, "ResizablePMCArray"
    push $P344, "for"
    .return ($P344)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CATCH>"  :subid("73_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx350_tgt
    .local int rx350_pos
    .local int rx350_off
    .local int rx350_eos
    .local int rx350_rep
    .local pmc rx350_cur
    .local pmc rx350_debug
    (rx350_cur, rx350_pos, rx350_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx350_cur
    .local pmc match
    .lex "$/", match
    length rx350_eos, rx350_tgt
    gt rx350_pos, rx350_eos, rx350_done
    set rx350_off, 0
    lt rx350_pos, 2, rx350_start
    sub rx350_off, rx350_pos, 1
    substr rx350_tgt, rx350_tgt, rx350_off
  rx350_start:
    eq $I10, 1, rx350_restart
    if_null rx350_debug, debug_552
    rx350_cur."!cursor_debug"("START", "statement_control:sym<CATCH>")
  debug_552:
    $I10 = self.'from'()
    ne $I10, -1, rxscan353_done
    goto rxscan353_scan
  rxscan353_loop:
    (rx350_pos) = rx350_cur."from"()
    inc rx350_pos
    rx350_cur."!cursor_from"(rx350_pos)
    ge rx350_pos, rx350_eos, rxscan353_done
  rxscan353_scan:
    set_addr $I10, rxscan353_loop
    rx350_cur."!mark_push"(0, rx350_pos, $I10)
  rxscan353_done:
.annotate 'line', 207
  # rx subcapture "sym"
    set_addr $I10, rxcap_354_fail
    rx350_cur."!mark_push"(0, rx350_pos, $I10)
  # rx literal  "CATCH"
    add $I11, rx350_pos, 5
    gt $I11, rx350_eos, rx350_fail
    sub $I11, rx350_pos, rx350_off
    substr $S10, rx350_tgt, $I11, 5
    ne $S10, "CATCH", rx350_fail
    add rx350_pos, 5
    set_addr $I10, rxcap_354_fail
    ($I12, $I11) = rx350_cur."!mark_peek"($I10)
    rx350_cur."!cursor_pos"($I11)
    ($P10) = rx350_cur."!cursor_start"()
    $P10."!cursor_pass"(rx350_pos, "")
    rx350_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_354_done
  rxcap_354_fail:
    goto rx350_fail
  rxcap_354_done:
  # rx charclass s
    ge rx350_pos, rx350_eos, rx350_fail
    sub $I10, rx350_pos, rx350_off
    is_cclass $I11, 32, rx350_tgt, $I10
    unless $I11, rx350_fail
    inc rx350_pos
  # rx subrule "ws" subtype=method negate=
    rx350_cur."!cursor_pos"(rx350_pos)
    $P10 = rx350_cur."ws"()
    unless $P10, rx350_fail
    rx350_pos = $P10."pos"()
.annotate 'line', 208
  # rx subrule "block" subtype=capture negate=
    rx350_cur."!cursor_pos"(rx350_pos)
    $P10 = rx350_cur."block"()
    unless $P10, rx350_fail
    rx350_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx350_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx350_cur."!cursor_pos"(rx350_pos)
    $P10 = rx350_cur."ws"()
    unless $P10, rx350_fail
    rx350_pos = $P10."pos"()
.annotate 'line', 206
  # rx pass
    rx350_cur."!cursor_pass"(rx350_pos, "statement_control:sym<CATCH>")
    if_null rx350_debug, debug_553
    rx350_cur."!cursor_debug"("PASS", "statement_control:sym<CATCH>", " at pos=", rx350_pos)
  debug_553:
    .return (rx350_cur)
  rx350_restart:
.annotate 'line', 4
    if_null rx350_debug, debug_554
    rx350_cur."!cursor_debug"("NEXT", "statement_control:sym<CATCH>")
  debug_554:
  rx350_fail:
    (rx350_rep, rx350_pos, $I10, $P10) = rx350_cur."!mark_fail"(0)
    lt rx350_pos, -1, rx350_done
    eq rx350_pos, -1, rx350_fail
    jump $I10
  rx350_done:
    rx350_cur."!cursor_fail"()
    if_null rx350_debug, debug_555
    rx350_cur."!cursor_debug"("FAIL", "statement_control:sym<CATCH>")
  debug_555:
    .return (rx350_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CATCH>"  :nsentry("!PREFIX__statement_control:sym<CATCH>") :subid("74_1298325448.42642") :method
.annotate 'line', 4
    new $P352, "ResizablePMCArray"
    push $P352, "CATCH"
    .return ($P352)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CONTROL>"  :subid("75_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx358_tgt
    .local int rx358_pos
    .local int rx358_off
    .local int rx358_eos
    .local int rx358_rep
    .local pmc rx358_cur
    .local pmc rx358_debug
    (rx358_cur, rx358_pos, rx358_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx358_cur
    .local pmc match
    .lex "$/", match
    length rx358_eos, rx358_tgt
    gt rx358_pos, rx358_eos, rx358_done
    set rx358_off, 0
    lt rx358_pos, 2, rx358_start
    sub rx358_off, rx358_pos, 1
    substr rx358_tgt, rx358_tgt, rx358_off
  rx358_start:
    eq $I10, 1, rx358_restart
    if_null rx358_debug, debug_556
    rx358_cur."!cursor_debug"("START", "statement_control:sym<CONTROL>")
  debug_556:
    $I10 = self.'from'()
    ne $I10, -1, rxscan361_done
    goto rxscan361_scan
  rxscan361_loop:
    (rx358_pos) = rx358_cur."from"()
    inc rx358_pos
    rx358_cur."!cursor_from"(rx358_pos)
    ge rx358_pos, rx358_eos, rxscan361_done
  rxscan361_scan:
    set_addr $I10, rxscan361_loop
    rx358_cur."!mark_push"(0, rx358_pos, $I10)
  rxscan361_done:
.annotate 'line', 212
  # rx subcapture "sym"
    set_addr $I10, rxcap_362_fail
    rx358_cur."!mark_push"(0, rx358_pos, $I10)
  # rx literal  "CONTROL"
    add $I11, rx358_pos, 7
    gt $I11, rx358_eos, rx358_fail
    sub $I11, rx358_pos, rx358_off
    substr $S10, rx358_tgt, $I11, 7
    ne $S10, "CONTROL", rx358_fail
    add rx358_pos, 7
    set_addr $I10, rxcap_362_fail
    ($I12, $I11) = rx358_cur."!mark_peek"($I10)
    rx358_cur."!cursor_pos"($I11)
    ($P10) = rx358_cur."!cursor_start"()
    $P10."!cursor_pass"(rx358_pos, "")
    rx358_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_362_done
  rxcap_362_fail:
    goto rx358_fail
  rxcap_362_done:
  # rx charclass s
    ge rx358_pos, rx358_eos, rx358_fail
    sub $I10, rx358_pos, rx358_off
    is_cclass $I11, 32, rx358_tgt, $I10
    unless $I11, rx358_fail
    inc rx358_pos
  # rx subrule "ws" subtype=method negate=
    rx358_cur."!cursor_pos"(rx358_pos)
    $P10 = rx358_cur."ws"()
    unless $P10, rx358_fail
    rx358_pos = $P10."pos"()
.annotate 'line', 213
  # rx subrule "block" subtype=capture negate=
    rx358_cur."!cursor_pos"(rx358_pos)
    $P10 = rx358_cur."block"()
    unless $P10, rx358_fail
    rx358_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx358_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx358_cur."!cursor_pos"(rx358_pos)
    $P10 = rx358_cur."ws"()
    unless $P10, rx358_fail
    rx358_pos = $P10."pos"()
.annotate 'line', 211
  # rx pass
    rx358_cur."!cursor_pass"(rx358_pos, "statement_control:sym<CONTROL>")
    if_null rx358_debug, debug_557
    rx358_cur."!cursor_debug"("PASS", "statement_control:sym<CONTROL>", " at pos=", rx358_pos)
  debug_557:
    .return (rx358_cur)
  rx358_restart:
.annotate 'line', 4
    if_null rx358_debug, debug_558
    rx358_cur."!cursor_debug"("NEXT", "statement_control:sym<CONTROL>")
  debug_558:
  rx358_fail:
    (rx358_rep, rx358_pos, $I10, $P10) = rx358_cur."!mark_fail"(0)
    lt rx358_pos, -1, rx358_done
    eq rx358_pos, -1, rx358_fail
    jump $I10
  rx358_done:
    rx358_cur."!cursor_fail"()
    if_null rx358_debug, debug_559
    rx358_cur."!cursor_debug"("FAIL", "statement_control:sym<CONTROL>")
  debug_559:
    .return (rx358_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CONTROL>"  :nsentry("!PREFIX__statement_control:sym<CONTROL>") :subid("76_1298325448.42642") :method
.annotate 'line', 4
    new $P360, "ResizablePMCArray"
    push $P360, "CONTROL"
    .return ($P360)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_prefix"  :subid("77_1298325448.42642")
    .param pmc param_366
.annotate 'line', 216
    .lex "self", param_366
    $P367 = param_366."!protoregex"("statement_prefix")
    .return ($P367)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix"  :subid("78_1298325448.42642")
    .param pmc param_369
.annotate 'line', 216
    .lex "self", param_369
    $P370 = param_369."!PREFIX__!protoregex"("statement_prefix")
    .return ($P370)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<INIT>"  :subid("79_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx372_tgt
    .local int rx372_pos
    .local int rx372_off
    .local int rx372_eos
    .local int rx372_rep
    .local pmc rx372_cur
    .local pmc rx372_debug
    (rx372_cur, rx372_pos, rx372_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx372_cur
    .local pmc match
    .lex "$/", match
    length rx372_eos, rx372_tgt
    gt rx372_pos, rx372_eos, rx372_done
    set rx372_off, 0
    lt rx372_pos, 2, rx372_start
    sub rx372_off, rx372_pos, 1
    substr rx372_tgt, rx372_tgt, rx372_off
  rx372_start:
    eq $I10, 1, rx372_restart
    if_null rx372_debug, debug_560
    rx372_cur."!cursor_debug"("START", "statement_prefix:sym<INIT>")
  debug_560:
    $I10 = self.'from'()
    ne $I10, -1, rxscan376_done
    goto rxscan376_scan
  rxscan376_loop:
    (rx372_pos) = rx372_cur."from"()
    inc rx372_pos
    rx372_cur."!cursor_from"(rx372_pos)
    ge rx372_pos, rx372_eos, rxscan376_done
  rxscan376_scan:
    set_addr $I10, rxscan376_loop
    rx372_cur."!mark_push"(0, rx372_pos, $I10)
  rxscan376_done:
.annotate 'line', 217
  # rx subcapture "sym"
    set_addr $I10, rxcap_377_fail
    rx372_cur."!mark_push"(0, rx372_pos, $I10)
  # rx literal  "INIT"
    add $I11, rx372_pos, 4
    gt $I11, rx372_eos, rx372_fail
    sub $I11, rx372_pos, rx372_off
    substr $S10, rx372_tgt, $I11, 4
    ne $S10, "INIT", rx372_fail
    add rx372_pos, 4
    set_addr $I10, rxcap_377_fail
    ($I12, $I11) = rx372_cur."!mark_peek"($I10)
    rx372_cur."!cursor_pos"($I11)
    ($P10) = rx372_cur."!cursor_start"()
    $P10."!cursor_pass"(rx372_pos, "")
    rx372_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_377_done
  rxcap_377_fail:
    goto rx372_fail
  rxcap_377_done:
  # rx subrule "blorst" subtype=capture negate=
    rx372_cur."!cursor_pos"(rx372_pos)
    $P10 = rx372_cur."blorst"()
    unless $P10, rx372_fail
    rx372_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx372_pos = $P10."pos"()
  # rx pass
    rx372_cur."!cursor_pass"(rx372_pos, "statement_prefix:sym<INIT>")
    if_null rx372_debug, debug_561
    rx372_cur."!cursor_debug"("PASS", "statement_prefix:sym<INIT>", " at pos=", rx372_pos)
  debug_561:
    .return (rx372_cur)
  rx372_restart:
.annotate 'line', 4
    if_null rx372_debug, debug_562
    rx372_cur."!cursor_debug"("NEXT", "statement_prefix:sym<INIT>")
  debug_562:
  rx372_fail:
    (rx372_rep, rx372_pos, $I10, $P10) = rx372_cur."!mark_fail"(0)
    lt rx372_pos, -1, rx372_done
    eq rx372_pos, -1, rx372_fail
    jump $I10
  rx372_done:
    rx372_cur."!cursor_fail"()
    if_null rx372_debug, debug_563
    rx372_cur."!cursor_debug"("FAIL", "statement_prefix:sym<INIT>")
  debug_563:
    .return (rx372_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<INIT>"  :nsentry("!PREFIX__statement_prefix:sym<INIT>") :subid("80_1298325448.42642") :method
.annotate 'line', 4
    $P374 = self."!PREFIX__!subrule"("blorst", "INIT")
    new $P375, "ResizablePMCArray"
    push $P375, $P374
    .return ($P375)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<try>"  :subid("81_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx379_tgt
    .local int rx379_pos
    .local int rx379_off
    .local int rx379_eos
    .local int rx379_rep
    .local pmc rx379_cur
    .local pmc rx379_debug
    (rx379_cur, rx379_pos, rx379_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx379_cur
    .local pmc match
    .lex "$/", match
    length rx379_eos, rx379_tgt
    gt rx379_pos, rx379_eos, rx379_done
    set rx379_off, 0
    lt rx379_pos, 2, rx379_start
    sub rx379_off, rx379_pos, 1
    substr rx379_tgt, rx379_tgt, rx379_off
  rx379_start:
    eq $I10, 1, rx379_restart
    if_null rx379_debug, debug_564
    rx379_cur."!cursor_debug"("START", "statement_prefix:sym<try>")
  debug_564:
    $I10 = self.'from'()
    ne $I10, -1, rxscan383_done
    goto rxscan383_scan
  rxscan383_loop:
    (rx379_pos) = rx379_cur."from"()
    inc rx379_pos
    rx379_cur."!cursor_from"(rx379_pos)
    ge rx379_pos, rx379_eos, rxscan383_done
  rxscan383_scan:
    set_addr $I10, rxscan383_loop
    rx379_cur."!mark_push"(0, rx379_pos, $I10)
  rxscan383_done:
.annotate 'line', 220
  # rx subcapture "sym"
    set_addr $I10, rxcap_384_fail
    rx379_cur."!mark_push"(0, rx379_pos, $I10)
  # rx literal  "try"
    add $I11, rx379_pos, 3
    gt $I11, rx379_eos, rx379_fail
    sub $I11, rx379_pos, rx379_off
    substr $S10, rx379_tgt, $I11, 3
    ne $S10, "try", rx379_fail
    add rx379_pos, 3
    set_addr $I10, rxcap_384_fail
    ($I12, $I11) = rx379_cur."!mark_peek"($I10)
    rx379_cur."!cursor_pos"($I11)
    ($P10) = rx379_cur."!cursor_start"()
    $P10."!cursor_pass"(rx379_pos, "")
    rx379_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_384_done
  rxcap_384_fail:
    goto rx379_fail
  rxcap_384_done:
.annotate 'line', 221
  # rx subrule "blorst" subtype=capture negate=
    rx379_cur."!cursor_pos"(rx379_pos)
    $P10 = rx379_cur."blorst"()
    unless $P10, rx379_fail
    rx379_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx379_pos = $P10."pos"()
.annotate 'line', 219
  # rx pass
    rx379_cur."!cursor_pass"(rx379_pos, "statement_prefix:sym<try>")
    if_null rx379_debug, debug_565
    rx379_cur."!cursor_debug"("PASS", "statement_prefix:sym<try>", " at pos=", rx379_pos)
  debug_565:
    .return (rx379_cur)
  rx379_restart:
.annotate 'line', 4
    if_null rx379_debug, debug_566
    rx379_cur."!cursor_debug"("NEXT", "statement_prefix:sym<try>")
  debug_566:
  rx379_fail:
    (rx379_rep, rx379_pos, $I10, $P10) = rx379_cur."!mark_fail"(0)
    lt rx379_pos, -1, rx379_done
    eq rx379_pos, -1, rx379_fail
    jump $I10
  rx379_done:
    rx379_cur."!cursor_fail"()
    if_null rx379_debug, debug_567
    rx379_cur."!cursor_debug"("FAIL", "statement_prefix:sym<try>")
  debug_567:
    .return (rx379_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<try>"  :nsentry("!PREFIX__statement_prefix:sym<try>") :subid("82_1298325448.42642") :method
.annotate 'line', 4
    $P381 = self."!PREFIX__!subrule"("blorst", "try")
    new $P382, "ResizablePMCArray"
    push $P382, $P381
    .return ($P382)
.end


.namespace ["NQP";"Grammar"]
.sub "blorst"  :subid("83_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx386_tgt
    .local int rx386_pos
    .local int rx386_off
    .local int rx386_eos
    .local int rx386_rep
    .local pmc rx386_cur
    .local pmc rx386_debug
    (rx386_cur, rx386_pos, rx386_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx386_cur
    .local pmc match
    .lex "$/", match
    length rx386_eos, rx386_tgt
    gt rx386_pos, rx386_eos, rx386_done
    set rx386_off, 0
    lt rx386_pos, 2, rx386_start
    sub rx386_off, rx386_pos, 1
    substr rx386_tgt, rx386_tgt, rx386_off
  rx386_start:
    eq $I10, 1, rx386_restart
    if_null rx386_debug, debug_568
    rx386_cur."!cursor_debug"("START", "blorst")
  debug_568:
    $I10 = self.'from'()
    ne $I10, -1, rxscan389_done
    goto rxscan389_scan
  rxscan389_loop:
    (rx386_pos) = rx386_cur."from"()
    inc rx386_pos
    rx386_cur."!cursor_from"(rx386_pos)
    ge rx386_pos, rx386_eos, rxscan389_done
  rxscan389_scan:
    set_addr $I10, rxscan389_loop
    rx386_cur."!mark_push"(0, rx386_pos, $I10)
  rxscan389_done:
.annotate 'line', 225
  # rx charclass s
    ge rx386_pos, rx386_eos, rx386_fail
    sub $I10, rx386_pos, rx386_off
    is_cclass $I11, 32, rx386_tgt, $I10
    unless $I11, rx386_fail
    inc rx386_pos
  # rx subrule "ws" subtype=method negate=
    rx386_cur."!cursor_pos"(rx386_pos)
    $P10 = rx386_cur."ws"()
    unless $P10, rx386_fail
    rx386_pos = $P10."pos"()
  alt390_0:
    set_addr $I10, alt390_1
    rx386_cur."!mark_push"(0, rx386_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx386_pos, rx386_off
    substr $S10, rx386_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx386_fail
  # rx subrule "block" subtype=capture negate=
    rx386_cur."!cursor_pos"(rx386_pos)
    $P10 = rx386_cur."block"()
    unless $P10, rx386_fail
    rx386_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx386_pos = $P10."pos"()
    goto alt390_end
  alt390_1:
  # rx subrule "statement" subtype=capture negate=
    rx386_cur."!cursor_pos"(rx386_pos)
    $P10 = rx386_cur."statement"()
    unless $P10, rx386_fail
    rx386_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx386_pos = $P10."pos"()
  alt390_end:
.annotate 'line', 224
  # rx pass
    rx386_cur."!cursor_pass"(rx386_pos, "blorst")
    if_null rx386_debug, debug_569
    rx386_cur."!cursor_debug"("PASS", "blorst", " at pos=", rx386_pos)
  debug_569:
    .return (rx386_cur)
  rx386_restart:
.annotate 'line', 4
    if_null rx386_debug, debug_570
    rx386_cur."!cursor_debug"("NEXT", "blorst")
  debug_570:
  rx386_fail:
    (rx386_rep, rx386_pos, $I10, $P10) = rx386_cur."!mark_fail"(0)
    lt rx386_pos, -1, rx386_done
    eq rx386_pos, -1, rx386_fail
    jump $I10
  rx386_done:
    rx386_cur."!cursor_fail"()
    if_null rx386_debug, debug_571
    rx386_cur."!cursor_debug"("FAIL", "blorst")
  debug_571:
    .return (rx386_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blorst"  :nsentry("!PREFIX__blorst") :subid("84_1298325448.42642") :method
.annotate 'line', 4
    new $P388, "ResizablePMCArray"
    push $P388, ""
    .return ($P388)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond"  :subid("85_1298325448.42642")
    .param pmc param_392
.annotate 'line', 230
    .lex "self", param_392
    $P393 = param_392."!protoregex"("statement_mod_cond")
    .return ($P393)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond"  :subid("86_1298325448.42642")
    .param pmc param_395
.annotate 'line', 230
    .lex "self", param_395
    $P396 = param_395."!PREFIX__!protoregex"("statement_mod_cond")
    .return ($P396)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<if>"  :subid("87_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx398_tgt
    .local int rx398_pos
    .local int rx398_off
    .local int rx398_eos
    .local int rx398_rep
    .local pmc rx398_cur
    .local pmc rx398_debug
    (rx398_cur, rx398_pos, rx398_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx398_cur
    .local pmc match
    .lex "$/", match
    length rx398_eos, rx398_tgt
    gt rx398_pos, rx398_eos, rx398_done
    set rx398_off, 0
    lt rx398_pos, 2, rx398_start
    sub rx398_off, rx398_pos, 1
    substr rx398_tgt, rx398_tgt, rx398_off
  rx398_start:
    eq $I10, 1, rx398_restart
    if_null rx398_debug, debug_572
    rx398_cur."!cursor_debug"("START", "statement_mod_cond:sym<if>")
  debug_572:
    $I10 = self.'from'()
    ne $I10, -1, rxscan402_done
    goto rxscan402_scan
  rxscan402_loop:
    (rx398_pos) = rx398_cur."from"()
    inc rx398_pos
    rx398_cur."!cursor_from"(rx398_pos)
    ge rx398_pos, rx398_eos, rxscan402_done
  rxscan402_scan:
    set_addr $I10, rxscan402_loop
    rx398_cur."!mark_push"(0, rx398_pos, $I10)
  rxscan402_done:
.annotate 'line', 232
  # rx subcapture "sym"
    set_addr $I10, rxcap_403_fail
    rx398_cur."!mark_push"(0, rx398_pos, $I10)
  # rx literal  "if"
    add $I11, rx398_pos, 2
    gt $I11, rx398_eos, rx398_fail
    sub $I11, rx398_pos, rx398_off
    substr $S10, rx398_tgt, $I11, 2
    ne $S10, "if", rx398_fail
    add rx398_pos, 2
    set_addr $I10, rxcap_403_fail
    ($I12, $I11) = rx398_cur."!mark_peek"($I10)
    rx398_cur."!cursor_pos"($I11)
    ($P10) = rx398_cur."!cursor_start"()
    $P10."!cursor_pass"(rx398_pos, "")
    rx398_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_403_done
  rxcap_403_fail:
    goto rx398_fail
  rxcap_403_done:
  # rx subrule "ws" subtype=method negate=
    rx398_cur."!cursor_pos"(rx398_pos)
    $P10 = rx398_cur."ws"()
    unless $P10, rx398_fail
    rx398_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx398_cur."!cursor_pos"(rx398_pos)
    $P10 = rx398_cur."EXPR"()
    unless $P10, rx398_fail
    rx398_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx398_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx398_cur."!cursor_pos"(rx398_pos)
    $P10 = rx398_cur."ws"()
    unless $P10, rx398_fail
    rx398_pos = $P10."pos"()
  # rx pass
    rx398_cur."!cursor_pass"(rx398_pos, "statement_mod_cond:sym<if>")
    if_null rx398_debug, debug_573
    rx398_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<if>", " at pos=", rx398_pos)
  debug_573:
    .return (rx398_cur)
  rx398_restart:
.annotate 'line', 4
    if_null rx398_debug, debug_574
    rx398_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<if>")
  debug_574:
  rx398_fail:
    (rx398_rep, rx398_pos, $I10, $P10) = rx398_cur."!mark_fail"(0)
    lt rx398_pos, -1, rx398_done
    eq rx398_pos, -1, rx398_fail
    jump $I10
  rx398_done:
    rx398_cur."!cursor_fail"()
    if_null rx398_debug, debug_575
    rx398_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<if>")
  debug_575:
    .return (rx398_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<if>"  :nsentry("!PREFIX__statement_mod_cond:sym<if>") :subid("88_1298325448.42642") :method
.annotate 'line', 4
    $P400 = self."!PREFIX__!subrule"("ws", "if")
    new $P401, "ResizablePMCArray"
    push $P401, $P400
    .return ($P401)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<unless>"  :subid("89_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx407_tgt
    .local int rx407_pos
    .local int rx407_off
    .local int rx407_eos
    .local int rx407_rep
    .local pmc rx407_cur
    .local pmc rx407_debug
    (rx407_cur, rx407_pos, rx407_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx407_cur
    .local pmc match
    .lex "$/", match
    length rx407_eos, rx407_tgt
    gt rx407_pos, rx407_eos, rx407_done
    set rx407_off, 0
    lt rx407_pos, 2, rx407_start
    sub rx407_off, rx407_pos, 1
    substr rx407_tgt, rx407_tgt, rx407_off
  rx407_start:
    eq $I10, 1, rx407_restart
    if_null rx407_debug, debug_576
    rx407_cur."!cursor_debug"("START", "statement_mod_cond:sym<unless>")
  debug_576:
    $I10 = self.'from'()
    ne $I10, -1, rxscan411_done
    goto rxscan411_scan
  rxscan411_loop:
    (rx407_pos) = rx407_cur."from"()
    inc rx407_pos
    rx407_cur."!cursor_from"(rx407_pos)
    ge rx407_pos, rx407_eos, rxscan411_done
  rxscan411_scan:
    set_addr $I10, rxscan411_loop
    rx407_cur."!mark_push"(0, rx407_pos, $I10)
  rxscan411_done:
.annotate 'line', 233
  # rx subcapture "sym"
    set_addr $I10, rxcap_412_fail
    rx407_cur."!mark_push"(0, rx407_pos, $I10)
  # rx literal  "unless"
    add $I11, rx407_pos, 6
    gt $I11, rx407_eos, rx407_fail
    sub $I11, rx407_pos, rx407_off
    substr $S10, rx407_tgt, $I11, 6
    ne $S10, "unless", rx407_fail
    add rx407_pos, 6
    set_addr $I10, rxcap_412_fail
    ($I12, $I11) = rx407_cur."!mark_peek"($I10)
    rx407_cur."!cursor_pos"($I11)
    ($P10) = rx407_cur."!cursor_start"()
    $P10."!cursor_pass"(rx407_pos, "")
    rx407_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_412_done
  rxcap_412_fail:
    goto rx407_fail
  rxcap_412_done:
  # rx subrule "ws" subtype=method negate=
    rx407_cur."!cursor_pos"(rx407_pos)
    $P10 = rx407_cur."ws"()
    unless $P10, rx407_fail
    rx407_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx407_cur."!cursor_pos"(rx407_pos)
    $P10 = rx407_cur."EXPR"()
    unless $P10, rx407_fail
    rx407_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx407_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx407_cur."!cursor_pos"(rx407_pos)
    $P10 = rx407_cur."ws"()
    unless $P10, rx407_fail
    rx407_pos = $P10."pos"()
  # rx pass
    rx407_cur."!cursor_pass"(rx407_pos, "statement_mod_cond:sym<unless>")
    if_null rx407_debug, debug_577
    rx407_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<unless>", " at pos=", rx407_pos)
  debug_577:
    .return (rx407_cur)
  rx407_restart:
.annotate 'line', 4
    if_null rx407_debug, debug_578
    rx407_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<unless>")
  debug_578:
  rx407_fail:
    (rx407_rep, rx407_pos, $I10, $P10) = rx407_cur."!mark_fail"(0)
    lt rx407_pos, -1, rx407_done
    eq rx407_pos, -1, rx407_fail
    jump $I10
  rx407_done:
    rx407_cur."!cursor_fail"()
    if_null rx407_debug, debug_579
    rx407_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<unless>")
  debug_579:
    .return (rx407_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<unless>"  :nsentry("!PREFIX__statement_mod_cond:sym<unless>") :subid("90_1298325448.42642") :method
.annotate 'line', 4
    $P409 = self."!PREFIX__!subrule"("ws", "unless")
    new $P410, "ResizablePMCArray"
    push $P410, $P409
    .return ($P410)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop"  :subid("91_1298325448.42642")
    .param pmc param_416
.annotate 'line', 235
    .lex "self", param_416
    $P417 = param_416."!protoregex"("statement_mod_loop")
    .return ($P417)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop"  :subid("92_1298325448.42642")
    .param pmc param_419
.annotate 'line', 235
    .lex "self", param_419
    $P420 = param_419."!PREFIX__!protoregex"("statement_mod_loop")
    .return ($P420)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<while>"  :subid("93_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx422_tgt
    .local int rx422_pos
    .local int rx422_off
    .local int rx422_eos
    .local int rx422_rep
    .local pmc rx422_cur
    .local pmc rx422_debug
    (rx422_cur, rx422_pos, rx422_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx422_cur
    .local pmc match
    .lex "$/", match
    length rx422_eos, rx422_tgt
    gt rx422_pos, rx422_eos, rx422_done
    set rx422_off, 0
    lt rx422_pos, 2, rx422_start
    sub rx422_off, rx422_pos, 1
    substr rx422_tgt, rx422_tgt, rx422_off
  rx422_start:
    eq $I10, 1, rx422_restart
    if_null rx422_debug, debug_580
    rx422_cur."!cursor_debug"("START", "statement_mod_loop:sym<while>")
  debug_580:
    $I10 = self.'from'()
    ne $I10, -1, rxscan426_done
    goto rxscan426_scan
  rxscan426_loop:
    (rx422_pos) = rx422_cur."from"()
    inc rx422_pos
    rx422_cur."!cursor_from"(rx422_pos)
    ge rx422_pos, rx422_eos, rxscan426_done
  rxscan426_scan:
    set_addr $I10, rxscan426_loop
    rx422_cur."!mark_push"(0, rx422_pos, $I10)
  rxscan426_done:
.annotate 'line', 237
  # rx subcapture "sym"
    set_addr $I10, rxcap_427_fail
    rx422_cur."!mark_push"(0, rx422_pos, $I10)
  # rx literal  "while"
    add $I11, rx422_pos, 5
    gt $I11, rx422_eos, rx422_fail
    sub $I11, rx422_pos, rx422_off
    substr $S10, rx422_tgt, $I11, 5
    ne $S10, "while", rx422_fail
    add rx422_pos, 5
    set_addr $I10, rxcap_427_fail
    ($I12, $I11) = rx422_cur."!mark_peek"($I10)
    rx422_cur."!cursor_pos"($I11)
    ($P10) = rx422_cur."!cursor_start"()
    $P10."!cursor_pass"(rx422_pos, "")
    rx422_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_427_done
  rxcap_427_fail:
    goto rx422_fail
  rxcap_427_done:
  # rx subrule "ws" subtype=method negate=
    rx422_cur."!cursor_pos"(rx422_pos)
    $P10 = rx422_cur."ws"()
    unless $P10, rx422_fail
    rx422_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx422_cur."!cursor_pos"(rx422_pos)
    $P10 = rx422_cur."EXPR"()
    unless $P10, rx422_fail
    rx422_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx422_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx422_cur."!cursor_pos"(rx422_pos)
    $P10 = rx422_cur."ws"()
    unless $P10, rx422_fail
    rx422_pos = $P10."pos"()
  # rx pass
    rx422_cur."!cursor_pass"(rx422_pos, "statement_mod_loop:sym<while>")
    if_null rx422_debug, debug_581
    rx422_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<while>", " at pos=", rx422_pos)
  debug_581:
    .return (rx422_cur)
  rx422_restart:
.annotate 'line', 4
    if_null rx422_debug, debug_582
    rx422_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<while>")
  debug_582:
  rx422_fail:
    (rx422_rep, rx422_pos, $I10, $P10) = rx422_cur."!mark_fail"(0)
    lt rx422_pos, -1, rx422_done
    eq rx422_pos, -1, rx422_fail
    jump $I10
  rx422_done:
    rx422_cur."!cursor_fail"()
    if_null rx422_debug, debug_583
    rx422_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<while>")
  debug_583:
    .return (rx422_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<while>"  :nsentry("!PREFIX__statement_mod_loop:sym<while>") :subid("94_1298325448.42642") :method
.annotate 'line', 4
    $P424 = self."!PREFIX__!subrule"("ws", "while")
    new $P425, "ResizablePMCArray"
    push $P425, $P424
    .return ($P425)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<until>"  :subid("95_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx431_tgt
    .local int rx431_pos
    .local int rx431_off
    .local int rx431_eos
    .local int rx431_rep
    .local pmc rx431_cur
    .local pmc rx431_debug
    (rx431_cur, rx431_pos, rx431_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx431_cur
    .local pmc match
    .lex "$/", match
    length rx431_eos, rx431_tgt
    gt rx431_pos, rx431_eos, rx431_done
    set rx431_off, 0
    lt rx431_pos, 2, rx431_start
    sub rx431_off, rx431_pos, 1
    substr rx431_tgt, rx431_tgt, rx431_off
  rx431_start:
    eq $I10, 1, rx431_restart
    if_null rx431_debug, debug_584
    rx431_cur."!cursor_debug"("START", "statement_mod_loop:sym<until>")
  debug_584:
    $I10 = self.'from'()
    ne $I10, -1, rxscan435_done
    goto rxscan435_scan
  rxscan435_loop:
    (rx431_pos) = rx431_cur."from"()
    inc rx431_pos
    rx431_cur."!cursor_from"(rx431_pos)
    ge rx431_pos, rx431_eos, rxscan435_done
  rxscan435_scan:
    set_addr $I10, rxscan435_loop
    rx431_cur."!mark_push"(0, rx431_pos, $I10)
  rxscan435_done:
.annotate 'line', 238
  # rx subcapture "sym"
    set_addr $I10, rxcap_436_fail
    rx431_cur."!mark_push"(0, rx431_pos, $I10)
  # rx literal  "until"
    add $I11, rx431_pos, 5
    gt $I11, rx431_eos, rx431_fail
    sub $I11, rx431_pos, rx431_off
    substr $S10, rx431_tgt, $I11, 5
    ne $S10, "until", rx431_fail
    add rx431_pos, 5
    set_addr $I10, rxcap_436_fail
    ($I12, $I11) = rx431_cur."!mark_peek"($I10)
    rx431_cur."!cursor_pos"($I11)
    ($P10) = rx431_cur."!cursor_start"()
    $P10."!cursor_pass"(rx431_pos, "")
    rx431_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_436_done
  rxcap_436_fail:
    goto rx431_fail
  rxcap_436_done:
  # rx subrule "ws" subtype=method negate=
    rx431_cur."!cursor_pos"(rx431_pos)
    $P10 = rx431_cur."ws"()
    unless $P10, rx431_fail
    rx431_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx431_cur."!cursor_pos"(rx431_pos)
    $P10 = rx431_cur."EXPR"()
    unless $P10, rx431_fail
    rx431_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx431_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx431_cur."!cursor_pos"(rx431_pos)
    $P10 = rx431_cur."ws"()
    unless $P10, rx431_fail
    rx431_pos = $P10."pos"()
  # rx pass
    rx431_cur."!cursor_pass"(rx431_pos, "statement_mod_loop:sym<until>")
    if_null rx431_debug, debug_585
    rx431_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<until>", " at pos=", rx431_pos)
  debug_585:
    .return (rx431_cur)
  rx431_restart:
.annotate 'line', 4
    if_null rx431_debug, debug_586
    rx431_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<until>")
  debug_586:
  rx431_fail:
    (rx431_rep, rx431_pos, $I10, $P10) = rx431_cur."!mark_fail"(0)
    lt rx431_pos, -1, rx431_done
    eq rx431_pos, -1, rx431_fail
    jump $I10
  rx431_done:
    rx431_cur."!cursor_fail"()
    if_null rx431_debug, debug_587
    rx431_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<until>")
  debug_587:
    .return (rx431_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<until>"  :nsentry("!PREFIX__statement_mod_loop:sym<until>") :subid("96_1298325448.42642") :method
.annotate 'line', 4
    $P433 = self."!PREFIX__!subrule"("ws", "until")
    new $P434, "ResizablePMCArray"
    push $P434, $P433
    .return ($P434)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<for>"  :subid("97_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx440_tgt
    .local int rx440_pos
    .local int rx440_off
    .local int rx440_eos
    .local int rx440_rep
    .local pmc rx440_cur
    .local pmc rx440_debug
    (rx440_cur, rx440_pos, rx440_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx440_cur
    .local pmc match
    .lex "$/", match
    length rx440_eos, rx440_tgt
    gt rx440_pos, rx440_eos, rx440_done
    set rx440_off, 0
    lt rx440_pos, 2, rx440_start
    sub rx440_off, rx440_pos, 1
    substr rx440_tgt, rx440_tgt, rx440_off
  rx440_start:
    eq $I10, 1, rx440_restart
    if_null rx440_debug, debug_588
    rx440_cur."!cursor_debug"("START", "statement_mod_loop:sym<for>")
  debug_588:
    $I10 = self.'from'()
    ne $I10, -1, rxscan444_done
    goto rxscan444_scan
  rxscan444_loop:
    (rx440_pos) = rx440_cur."from"()
    inc rx440_pos
    rx440_cur."!cursor_from"(rx440_pos)
    ge rx440_pos, rx440_eos, rxscan444_done
  rxscan444_scan:
    set_addr $I10, rxscan444_loop
    rx440_cur."!mark_push"(0, rx440_pos, $I10)
  rxscan444_done:
.annotate 'line', 239
  # rx subcapture "sym"
    set_addr $I10, rxcap_445_fail
    rx440_cur."!mark_push"(0, rx440_pos, $I10)
  # rx literal  "for"
    add $I11, rx440_pos, 3
    gt $I11, rx440_eos, rx440_fail
    sub $I11, rx440_pos, rx440_off
    substr $S10, rx440_tgt, $I11, 3
    ne $S10, "for", rx440_fail
    add rx440_pos, 3
    set_addr $I10, rxcap_445_fail
    ($I12, $I11) = rx440_cur."!mark_peek"($I10)
    rx440_cur."!cursor_pos"($I11)
    ($P10) = rx440_cur."!cursor_start"()
    $P10."!cursor_pass"(rx440_pos, "")
    rx440_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_445_done
  rxcap_445_fail:
    goto rx440_fail
  rxcap_445_done:
  # rx subrule "ws" subtype=method negate=
    rx440_cur."!cursor_pos"(rx440_pos)
    $P10 = rx440_cur."ws"()
    unless $P10, rx440_fail
    rx440_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx440_cur."!cursor_pos"(rx440_pos)
    $P10 = rx440_cur."EXPR"()
    unless $P10, rx440_fail
    rx440_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx440_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx440_cur."!cursor_pos"(rx440_pos)
    $P10 = rx440_cur."ws"()
    unless $P10, rx440_fail
    rx440_pos = $P10."pos"()
  # rx pass
    rx440_cur."!cursor_pass"(rx440_pos, "statement_mod_loop:sym<for>")
    if_null rx440_debug, debug_589
    rx440_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<for>", " at pos=", rx440_pos)
  debug_589:
    .return (rx440_cur)
  rx440_restart:
.annotate 'line', 4
    if_null rx440_debug, debug_590
    rx440_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<for>")
  debug_590:
  rx440_fail:
    (rx440_rep, rx440_pos, $I10, $P10) = rx440_cur."!mark_fail"(0)
    lt rx440_pos, -1, rx440_done
    eq rx440_pos, -1, rx440_fail
    jump $I10
  rx440_done:
    rx440_cur."!cursor_fail"()
    if_null rx440_debug, debug_591
    rx440_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<for>")
  debug_591:
    .return (rx440_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<for>"  :nsentry("!PREFIX__statement_mod_loop:sym<for>") :subid("98_1298325448.42642") :method
.annotate 'line', 4
    $P442 = self."!PREFIX__!subrule"("ws", "for")
    new $P443, "ResizablePMCArray"
    push $P443, $P442
    .return ($P443)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<fatarrow>"  :subid("99_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx449_tgt
    .local int rx449_pos
    .local int rx449_off
    .local int rx449_eos
    .local int rx449_rep
    .local pmc rx449_cur
    .local pmc rx449_debug
    (rx449_cur, rx449_pos, rx449_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx449_cur
    .local pmc match
    .lex "$/", match
    length rx449_eos, rx449_tgt
    gt rx449_pos, rx449_eos, rx449_done
    set rx449_off, 0
    lt rx449_pos, 2, rx449_start
    sub rx449_off, rx449_pos, 1
    substr rx449_tgt, rx449_tgt, rx449_off
  rx449_start:
    eq $I10, 1, rx449_restart
    if_null rx449_debug, debug_592
    rx449_cur."!cursor_debug"("START", "term:sym<fatarrow>")
  debug_592:
    $I10 = self.'from'()
    ne $I10, -1, rxscan453_done
    goto rxscan453_scan
  rxscan453_loop:
    (rx449_pos) = rx449_cur."from"()
    inc rx449_pos
    rx449_cur."!cursor_from"(rx449_pos)
    ge rx449_pos, rx449_eos, rxscan453_done
  rxscan453_scan:
    set_addr $I10, rxscan453_loop
    rx449_cur."!mark_push"(0, rx449_pos, $I10)
  rxscan453_done:
.annotate 'line', 243
  # rx subrule "fatarrow" subtype=capture negate=
    rx449_cur."!cursor_pos"(rx449_pos)
    $P10 = rx449_cur."fatarrow"()
    unless $P10, rx449_fail
    rx449_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("fatarrow")
    rx449_pos = $P10."pos"()
  # rx pass
    rx449_cur."!cursor_pass"(rx449_pos, "term:sym<fatarrow>")
    if_null rx449_debug, debug_593
    rx449_cur."!cursor_debug"("PASS", "term:sym<fatarrow>", " at pos=", rx449_pos)
  debug_593:
    .return (rx449_cur)
  rx449_restart:
.annotate 'line', 4
    if_null rx449_debug, debug_594
    rx449_cur."!cursor_debug"("NEXT", "term:sym<fatarrow>")
  debug_594:
  rx449_fail:
    (rx449_rep, rx449_pos, $I10, $P10) = rx449_cur."!mark_fail"(0)
    lt rx449_pos, -1, rx449_done
    eq rx449_pos, -1, rx449_fail
    jump $I10
  rx449_done:
    rx449_cur."!cursor_fail"()
    if_null rx449_debug, debug_595
    rx449_cur."!cursor_debug"("FAIL", "term:sym<fatarrow>")
  debug_595:
    .return (rx449_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<fatarrow>"  :nsentry("!PREFIX__term:sym<fatarrow>") :subid("100_1298325448.42642") :method
.annotate 'line', 4
    $P451 = self."!PREFIX__!subrule"("fatarrow", "")
    new $P452, "ResizablePMCArray"
    push $P452, $P451
    .return ($P452)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<colonpair>"  :subid("101_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx455_tgt
    .local int rx455_pos
    .local int rx455_off
    .local int rx455_eos
    .local int rx455_rep
    .local pmc rx455_cur
    .local pmc rx455_debug
    (rx455_cur, rx455_pos, rx455_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx455_cur
    .local pmc match
    .lex "$/", match
    length rx455_eos, rx455_tgt
    gt rx455_pos, rx455_eos, rx455_done
    set rx455_off, 0
    lt rx455_pos, 2, rx455_start
    sub rx455_off, rx455_pos, 1
    substr rx455_tgt, rx455_tgt, rx455_off
  rx455_start:
    eq $I10, 1, rx455_restart
    if_null rx455_debug, debug_596
    rx455_cur."!cursor_debug"("START", "term:sym<colonpair>")
  debug_596:
    $I10 = self.'from'()
    ne $I10, -1, rxscan459_done
    goto rxscan459_scan
  rxscan459_loop:
    (rx455_pos) = rx455_cur."from"()
    inc rx455_pos
    rx455_cur."!cursor_from"(rx455_pos)
    ge rx455_pos, rx455_eos, rxscan459_done
  rxscan459_scan:
    set_addr $I10, rxscan459_loop
    rx455_cur."!mark_push"(0, rx455_pos, $I10)
  rxscan459_done:
.annotate 'line', 244
  # rx subrule "colonpair" subtype=capture negate=
    rx455_cur."!cursor_pos"(rx455_pos)
    $P10 = rx455_cur."colonpair"()
    unless $P10, rx455_fail
    rx455_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("colonpair")
    rx455_pos = $P10."pos"()
  # rx pass
    rx455_cur."!cursor_pass"(rx455_pos, "term:sym<colonpair>")
    if_null rx455_debug, debug_597
    rx455_cur."!cursor_debug"("PASS", "term:sym<colonpair>", " at pos=", rx455_pos)
  debug_597:
    .return (rx455_cur)
  rx455_restart:
.annotate 'line', 4
    if_null rx455_debug, debug_598
    rx455_cur."!cursor_debug"("NEXT", "term:sym<colonpair>")
  debug_598:
  rx455_fail:
    (rx455_rep, rx455_pos, $I10, $P10) = rx455_cur."!mark_fail"(0)
    lt rx455_pos, -1, rx455_done
    eq rx455_pos, -1, rx455_fail
    jump $I10
  rx455_done:
    rx455_cur."!cursor_fail"()
    if_null rx455_debug, debug_599
    rx455_cur."!cursor_debug"("FAIL", "term:sym<colonpair>")
  debug_599:
    .return (rx455_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<colonpair>"  :nsentry("!PREFIX__term:sym<colonpair>") :subid("102_1298325448.42642") :method
.annotate 'line', 4
    $P457 = self."!PREFIX__!subrule"("colonpair", "")
    new $P458, "ResizablePMCArray"
    push $P458, $P457
    .return ($P458)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<variable>"  :subid("103_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx461_tgt
    .local int rx461_pos
    .local int rx461_off
    .local int rx461_eos
    .local int rx461_rep
    .local pmc rx461_cur
    .local pmc rx461_debug
    (rx461_cur, rx461_pos, rx461_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx461_cur
    .local pmc match
    .lex "$/", match
    length rx461_eos, rx461_tgt
    gt rx461_pos, rx461_eos, rx461_done
    set rx461_off, 0
    lt rx461_pos, 2, rx461_start
    sub rx461_off, rx461_pos, 1
    substr rx461_tgt, rx461_tgt, rx461_off
  rx461_start:
    eq $I10, 1, rx461_restart
    if_null rx461_debug, debug_600
    rx461_cur."!cursor_debug"("START", "term:sym<variable>")
  debug_600:
    $I10 = self.'from'()
    ne $I10, -1, rxscan465_done
    goto rxscan465_scan
  rxscan465_loop:
    (rx461_pos) = rx461_cur."from"()
    inc rx461_pos
    rx461_cur."!cursor_from"(rx461_pos)
    ge rx461_pos, rx461_eos, rxscan465_done
  rxscan465_scan:
    set_addr $I10, rxscan465_loop
    rx461_cur."!mark_push"(0, rx461_pos, $I10)
  rxscan465_done:
.annotate 'line', 245
  # rx subrule "variable" subtype=capture negate=
    rx461_cur."!cursor_pos"(rx461_pos)
    $P10 = rx461_cur."variable"()
    unless $P10, rx461_fail
    rx461_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx461_pos = $P10."pos"()
  # rx pass
    rx461_cur."!cursor_pass"(rx461_pos, "term:sym<variable>")
    if_null rx461_debug, debug_601
    rx461_cur."!cursor_debug"("PASS", "term:sym<variable>", " at pos=", rx461_pos)
  debug_601:
    .return (rx461_cur)
  rx461_restart:
.annotate 'line', 4
    if_null rx461_debug, debug_602
    rx461_cur."!cursor_debug"("NEXT", "term:sym<variable>")
  debug_602:
  rx461_fail:
    (rx461_rep, rx461_pos, $I10, $P10) = rx461_cur."!mark_fail"(0)
    lt rx461_pos, -1, rx461_done
    eq rx461_pos, -1, rx461_fail
    jump $I10
  rx461_done:
    rx461_cur."!cursor_fail"()
    if_null rx461_debug, debug_603
    rx461_cur."!cursor_debug"("FAIL", "term:sym<variable>")
  debug_603:
    .return (rx461_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<variable>"  :nsentry("!PREFIX__term:sym<variable>") :subid("104_1298325448.42642") :method
.annotate 'line', 4
    $P463 = self."!PREFIX__!subrule"("variable", "")
    new $P464, "ResizablePMCArray"
    push $P464, $P463
    .return ($P464)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<package_declarator>"  :subid("105_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx467_tgt
    .local int rx467_pos
    .local int rx467_off
    .local int rx467_eos
    .local int rx467_rep
    .local pmc rx467_cur
    .local pmc rx467_debug
    (rx467_cur, rx467_pos, rx467_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx467_cur
    .local pmc match
    .lex "$/", match
    length rx467_eos, rx467_tgt
    gt rx467_pos, rx467_eos, rx467_done
    set rx467_off, 0
    lt rx467_pos, 2, rx467_start
    sub rx467_off, rx467_pos, 1
    substr rx467_tgt, rx467_tgt, rx467_off
  rx467_start:
    eq $I10, 1, rx467_restart
    if_null rx467_debug, debug_604
    rx467_cur."!cursor_debug"("START", "term:sym<package_declarator>")
  debug_604:
    $I10 = self.'from'()
    ne $I10, -1, rxscan471_done
    goto rxscan471_scan
  rxscan471_loop:
    (rx467_pos) = rx467_cur."from"()
    inc rx467_pos
    rx467_cur."!cursor_from"(rx467_pos)
    ge rx467_pos, rx467_eos, rxscan471_done
  rxscan471_scan:
    set_addr $I10, rxscan471_loop
    rx467_cur."!mark_push"(0, rx467_pos, $I10)
  rxscan471_done:
.annotate 'line', 246
  # rx subrule "package_declarator" subtype=capture negate=
    rx467_cur."!cursor_pos"(rx467_pos)
    $P10 = rx467_cur."package_declarator"()
    unless $P10, rx467_fail
    rx467_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx467_pos = $P10."pos"()
  # rx pass
    rx467_cur."!cursor_pass"(rx467_pos, "term:sym<package_declarator>")
    if_null rx467_debug, debug_605
    rx467_cur."!cursor_debug"("PASS", "term:sym<package_declarator>", " at pos=", rx467_pos)
  debug_605:
    .return (rx467_cur)
  rx467_restart:
.annotate 'line', 4
    if_null rx467_debug, debug_606
    rx467_cur."!cursor_debug"("NEXT", "term:sym<package_declarator>")
  debug_606:
  rx467_fail:
    (rx467_rep, rx467_pos, $I10, $P10) = rx467_cur."!mark_fail"(0)
    lt rx467_pos, -1, rx467_done
    eq rx467_pos, -1, rx467_fail
    jump $I10
  rx467_done:
    rx467_cur."!cursor_fail"()
    if_null rx467_debug, debug_607
    rx467_cur."!cursor_debug"("FAIL", "term:sym<package_declarator>")
  debug_607:
    .return (rx467_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<package_declarator>"  :nsentry("!PREFIX__term:sym<package_declarator>") :subid("106_1298325448.42642") :method
.annotate 'line', 4
    $P469 = self."!PREFIX__!subrule"("package_declarator", "")
    new $P470, "ResizablePMCArray"
    push $P470, $P469
    .return ($P470)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<scope_declarator>"  :subid("107_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx473_tgt
    .local int rx473_pos
    .local int rx473_off
    .local int rx473_eos
    .local int rx473_rep
    .local pmc rx473_cur
    .local pmc rx473_debug
    (rx473_cur, rx473_pos, rx473_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx473_cur
    .local pmc match
    .lex "$/", match
    length rx473_eos, rx473_tgt
    gt rx473_pos, rx473_eos, rx473_done
    set rx473_off, 0
    lt rx473_pos, 2, rx473_start
    sub rx473_off, rx473_pos, 1
    substr rx473_tgt, rx473_tgt, rx473_off
  rx473_start:
    eq $I10, 1, rx473_restart
    if_null rx473_debug, debug_608
    rx473_cur."!cursor_debug"("START", "term:sym<scope_declarator>")
  debug_608:
    $I10 = self.'from'()
    ne $I10, -1, rxscan477_done
    goto rxscan477_scan
  rxscan477_loop:
    (rx473_pos) = rx473_cur."from"()
    inc rx473_pos
    rx473_cur."!cursor_from"(rx473_pos)
    ge rx473_pos, rx473_eos, rxscan477_done
  rxscan477_scan:
    set_addr $I10, rxscan477_loop
    rx473_cur."!mark_push"(0, rx473_pos, $I10)
  rxscan477_done:
.annotate 'line', 247
  # rx subrule "scope_declarator" subtype=capture negate=
    rx473_cur."!cursor_pos"(rx473_pos)
    $P10 = rx473_cur."scope_declarator"()
    unless $P10, rx473_fail
    rx473_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scope_declarator")
    rx473_pos = $P10."pos"()
  # rx pass
    rx473_cur."!cursor_pass"(rx473_pos, "term:sym<scope_declarator>")
    if_null rx473_debug, debug_609
    rx473_cur."!cursor_debug"("PASS", "term:sym<scope_declarator>", " at pos=", rx473_pos)
  debug_609:
    .return (rx473_cur)
  rx473_restart:
.annotate 'line', 4
    if_null rx473_debug, debug_610
    rx473_cur."!cursor_debug"("NEXT", "term:sym<scope_declarator>")
  debug_610:
  rx473_fail:
    (rx473_rep, rx473_pos, $I10, $P10) = rx473_cur."!mark_fail"(0)
    lt rx473_pos, -1, rx473_done
    eq rx473_pos, -1, rx473_fail
    jump $I10
  rx473_done:
    rx473_cur."!cursor_fail"()
    if_null rx473_debug, debug_611
    rx473_cur."!cursor_debug"("FAIL", "term:sym<scope_declarator>")
  debug_611:
    .return (rx473_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<scope_declarator>"  :nsentry("!PREFIX__term:sym<scope_declarator>") :subid("108_1298325448.42642") :method
.annotate 'line', 4
    $P475 = self."!PREFIX__!subrule"("scope_declarator", "")
    new $P476, "ResizablePMCArray"
    push $P476, $P475
    .return ($P476)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<routine_declarator>"  :subid("109_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx479_tgt
    .local int rx479_pos
    .local int rx479_off
    .local int rx479_eos
    .local int rx479_rep
    .local pmc rx479_cur
    .local pmc rx479_debug
    (rx479_cur, rx479_pos, rx479_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx479_cur
    .local pmc match
    .lex "$/", match
    length rx479_eos, rx479_tgt
    gt rx479_pos, rx479_eos, rx479_done
    set rx479_off, 0
    lt rx479_pos, 2, rx479_start
    sub rx479_off, rx479_pos, 1
    substr rx479_tgt, rx479_tgt, rx479_off
  rx479_start:
    eq $I10, 1, rx479_restart
    if_null rx479_debug, debug_612
    rx479_cur."!cursor_debug"("START", "term:sym<routine_declarator>")
  debug_612:
    $I10 = self.'from'()
    ne $I10, -1, rxscan483_done
    goto rxscan483_scan
  rxscan483_loop:
    (rx479_pos) = rx479_cur."from"()
    inc rx479_pos
    rx479_cur."!cursor_from"(rx479_pos)
    ge rx479_pos, rx479_eos, rxscan483_done
  rxscan483_scan:
    set_addr $I10, rxscan483_loop
    rx479_cur."!mark_push"(0, rx479_pos, $I10)
  rxscan483_done:
.annotate 'line', 248
  # rx subrule "routine_declarator" subtype=capture negate=
    rx479_cur."!cursor_pos"(rx479_pos)
    $P10 = rx479_cur."routine_declarator"()
    unless $P10, rx479_fail
    rx479_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx479_pos = $P10."pos"()
  # rx pass
    rx479_cur."!cursor_pass"(rx479_pos, "term:sym<routine_declarator>")
    if_null rx479_debug, debug_613
    rx479_cur."!cursor_debug"("PASS", "term:sym<routine_declarator>", " at pos=", rx479_pos)
  debug_613:
    .return (rx479_cur)
  rx479_restart:
.annotate 'line', 4
    if_null rx479_debug, debug_614
    rx479_cur."!cursor_debug"("NEXT", "term:sym<routine_declarator>")
  debug_614:
  rx479_fail:
    (rx479_rep, rx479_pos, $I10, $P10) = rx479_cur."!mark_fail"(0)
    lt rx479_pos, -1, rx479_done
    eq rx479_pos, -1, rx479_fail
    jump $I10
  rx479_done:
    rx479_cur."!cursor_fail"()
    if_null rx479_debug, debug_615
    rx479_cur."!cursor_debug"("FAIL", "term:sym<routine_declarator>")
  debug_615:
    .return (rx479_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<routine_declarator>"  :nsentry("!PREFIX__term:sym<routine_declarator>") :subid("110_1298325448.42642") :method
.annotate 'line', 4
    $P481 = self."!PREFIX__!subrule"("routine_declarator", "")
    new $P482, "ResizablePMCArray"
    push $P482, $P481
    .return ($P482)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<multi_declarator>"  :subid("111_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .const 'Sub' $P495 = "114_1298325448.42642" 
    capture_lex $P495
    .const 'Sub' $P490 = "113_1298325448.42642" 
    capture_lex $P490
    .local string rx485_tgt
    .local int rx485_pos
    .local int rx485_off
    .local int rx485_eos
    .local int rx485_rep
    .local pmc rx485_cur
    .local pmc rx485_debug
    (rx485_cur, rx485_pos, rx485_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx485_cur
    .local pmc match
    .lex "$/", match
    length rx485_eos, rx485_tgt
    gt rx485_pos, rx485_eos, rx485_done
    set rx485_off, 0
    lt rx485_pos, 2, rx485_start
    sub rx485_off, rx485_pos, 1
    substr rx485_tgt, rx485_tgt, rx485_off
  rx485_start:
    eq $I10, 1, rx485_restart
    if_null rx485_debug, debug_616
    rx485_cur."!cursor_debug"("START", "term:sym<multi_declarator>")
  debug_616:
    $I10 = self.'from'()
    ne $I10, -1, rxscan488_done
    goto rxscan488_scan
  rxscan488_loop:
    (rx485_pos) = rx485_cur."from"()
    inc rx485_pos
    rx485_cur."!cursor_from"(rx485_pos)
    ge rx485_pos, rx485_eos, rxscan488_done
  rxscan488_scan:
    set_addr $I10, rxscan488_loop
    rx485_cur."!mark_push"(0, rx485_pos, $I10)
  rxscan488_done:
.annotate 'line', 250
  # rx subrule "before" subtype=zerowidth negate=
    rx485_cur."!cursor_pos"(rx485_pos)
    .const 'Sub' $P490 = "113_1298325448.42642" 
    capture_lex $P490
    $P10 = rx485_cur."before"($P490)
    unless $P10, rx485_fail
.annotate 'line', 251
  # rx subrule "before" subtype=zerowidth negate=1
    rx485_cur."!cursor_pos"(rx485_pos)
    .const 'Sub' $P495 = "114_1298325448.42642" 
    capture_lex $P495
    $P10 = rx485_cur."before"($P495)
    if $P10, rx485_fail
.annotate 'line', 252
  # rx subrule "multi_declarator" subtype=capture negate=
    rx485_cur."!cursor_pos"(rx485_pos)
    $P10 = rx485_cur."multi_declarator"()
    unless $P10, rx485_fail
    rx485_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx485_pos = $P10."pos"()
.annotate 'line', 249
  # rx pass
    rx485_cur."!cursor_pass"(rx485_pos, "term:sym<multi_declarator>")
    if_null rx485_debug, debug_625
    rx485_cur."!cursor_debug"("PASS", "term:sym<multi_declarator>", " at pos=", rx485_pos)
  debug_625:
    .return (rx485_cur)
  rx485_restart:
.annotate 'line', 4
    if_null rx485_debug, debug_626
    rx485_cur."!cursor_debug"("NEXT", "term:sym<multi_declarator>")
  debug_626:
  rx485_fail:
    (rx485_rep, rx485_pos, $I10, $P10) = rx485_cur."!mark_fail"(0)
    lt rx485_pos, -1, rx485_done
    eq rx485_pos, -1, rx485_fail
    jump $I10
  rx485_done:
    rx485_cur."!cursor_fail"()
    if_null rx485_debug, debug_627
    rx485_cur."!cursor_debug"("FAIL", "term:sym<multi_declarator>")
  debug_627:
    .return (rx485_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<multi_declarator>"  :nsentry("!PREFIX__term:sym<multi_declarator>") :subid("112_1298325448.42642") :method
.annotate 'line', 4
    new $P487, "ResizablePMCArray"
    push $P487, ""
    .return ($P487)
.end


.namespace ["NQP";"Grammar"]
.sub "_block489"  :anon :subid("113_1298325448.42642") :method :outer("111_1298325448.42642")
.annotate 'line', 250
    .local string rx491_tgt
    .local int rx491_pos
    .local int rx491_off
    .local int rx491_eos
    .local int rx491_rep
    .local pmc rx491_cur
    .local pmc rx491_debug
    (rx491_cur, rx491_pos, rx491_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx491_cur
    .local pmc match
    .lex "$/", match
    length rx491_eos, rx491_tgt
    gt rx491_pos, rx491_eos, rx491_done
    set rx491_off, 0
    lt rx491_pos, 2, rx491_start
    sub rx491_off, rx491_pos, 1
    substr rx491_tgt, rx491_tgt, rx491_off
  rx491_start:
    eq $I10, 1, rx491_restart
    if_null rx491_debug, debug_617
    rx491_cur."!cursor_debug"("START", "")
  debug_617:
    $I10 = self.'from'()
    ne $I10, -1, rxscan492_done
    goto rxscan492_scan
  rxscan492_loop:
    (rx491_pos) = rx491_cur."from"()
    inc rx491_pos
    rx491_cur."!cursor_from"(rx491_pos)
    ge rx491_pos, rx491_eos, rxscan492_done
  rxscan492_scan:
    set_addr $I10, rxscan492_loop
    rx491_cur."!mark_push"(0, rx491_pos, $I10)
  rxscan492_done:
  alt493_0:
    set_addr $I10, alt493_1
    rx491_cur."!mark_push"(0, rx491_pos, $I10)
  # rx literal  "multi"
    add $I11, rx491_pos, 5
    gt $I11, rx491_eos, rx491_fail
    sub $I11, rx491_pos, rx491_off
    substr $S10, rx491_tgt, $I11, 5
    ne $S10, "multi", rx491_fail
    add rx491_pos, 5
    goto alt493_end
  alt493_1:
    set_addr $I10, alt493_2
    rx491_cur."!mark_push"(0, rx491_pos, $I10)
  # rx literal  "proto"
    add $I11, rx491_pos, 5
    gt $I11, rx491_eos, rx491_fail
    sub $I11, rx491_pos, rx491_off
    substr $S10, rx491_tgt, $I11, 5
    ne $S10, "proto", rx491_fail
    add rx491_pos, 5
    goto alt493_end
  alt493_2:
  # rx literal  "only"
    add $I11, rx491_pos, 4
    gt $I11, rx491_eos, rx491_fail
    sub $I11, rx491_pos, rx491_off
    substr $S10, rx491_tgt, $I11, 4
    ne $S10, "only", rx491_fail
    add rx491_pos, 4
  alt493_end:
  # rx pass
    rx491_cur."!cursor_pass"(rx491_pos, "")
    if_null rx491_debug, debug_618
    rx491_cur."!cursor_debug"("PASS", "", " at pos=", rx491_pos)
  debug_618:
    .return (rx491_cur)
  rx491_restart:
    if_null rx491_debug, debug_619
    rx491_cur."!cursor_debug"("NEXT", "")
  debug_619:
  rx491_fail:
    (rx491_rep, rx491_pos, $I10, $P10) = rx491_cur."!mark_fail"(0)
    lt rx491_pos, -1, rx491_done
    eq rx491_pos, -1, rx491_fail
    jump $I10
  rx491_done:
    rx491_cur."!cursor_fail"()
    if_null rx491_debug, debug_620
    rx491_cur."!cursor_debug"("FAIL", "")
  debug_620:
    .return (rx491_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "_block494"  :anon :subid("114_1298325448.42642") :method :outer("111_1298325448.42642")
.annotate 'line', 251
    .local string rx496_tgt
    .local int rx496_pos
    .local int rx496_off
    .local int rx496_eos
    .local int rx496_rep
    .local pmc rx496_cur
    .local pmc rx496_debug
    (rx496_cur, rx496_pos, rx496_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx496_cur
    .local pmc match
    .lex "$/", match
    length rx496_eos, rx496_tgt
    gt rx496_pos, rx496_eos, rx496_done
    set rx496_off, 0
    lt rx496_pos, 2, rx496_start
    sub rx496_off, rx496_pos, 1
    substr rx496_tgt, rx496_tgt, rx496_off
  rx496_start:
    eq $I10, 1, rx496_restart
    if_null rx496_debug, debug_621
    rx496_cur."!cursor_debug"("START", "")
  debug_621:
    $I10 = self.'from'()
    ne $I10, -1, rxscan497_done
    goto rxscan497_scan
  rxscan497_loop:
    (rx496_pos) = rx496_cur."from"()
    inc rx496_pos
    rx496_cur."!cursor_from"(rx496_pos)
    ge rx496_pos, rx496_eos, rxscan497_done
  rxscan497_scan:
    set_addr $I10, rxscan497_loop
    rx496_cur."!mark_push"(0, rx496_pos, $I10)
  rxscan497_done:
  # rx literal  "proto"
    add $I11, rx496_pos, 5
    gt $I11, rx496_eos, rx496_fail
    sub $I11, rx496_pos, rx496_off
    substr $S10, rx496_tgt, $I11, 5
    ne $S10, "proto", rx496_fail
    add rx496_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx496_cur."!cursor_pos"(rx496_pos)
    $P10 = rx496_cur."ws"()
    unless $P10, rx496_fail
    rx496_pos = $P10."pos"()
  alt498_0:
    set_addr $I10, alt498_1
    rx496_cur."!mark_push"(0, rx496_pos, $I10)
  # rx literal  "regex"
    add $I11, rx496_pos, 5
    gt $I11, rx496_eos, rx496_fail
    sub $I11, rx496_pos, rx496_off
    substr $S10, rx496_tgt, $I11, 5
    ne $S10, "regex", rx496_fail
    add rx496_pos, 5
    goto alt498_end
  alt498_1:
    set_addr $I10, alt498_2
    rx496_cur."!mark_push"(0, rx496_pos, $I10)
  # rx literal  "token"
    add $I11, rx496_pos, 5
    gt $I11, rx496_eos, rx496_fail
    sub $I11, rx496_pos, rx496_off
    substr $S10, rx496_tgt, $I11, 5
    ne $S10, "token", rx496_fail
    add rx496_pos, 5
    goto alt498_end
  alt498_2:
  # rx literal  "rule"
    add $I11, rx496_pos, 4
    gt $I11, rx496_eos, rx496_fail
    sub $I11, rx496_pos, rx496_off
    substr $S10, rx496_tgt, $I11, 4
    ne $S10, "rule", rx496_fail
    add rx496_pos, 4
  alt498_end:
  # rx pass
    rx496_cur."!cursor_pass"(rx496_pos, "")
    if_null rx496_debug, debug_622
    rx496_cur."!cursor_debug"("PASS", "", " at pos=", rx496_pos)
  debug_622:
    .return (rx496_cur)
  rx496_restart:
    if_null rx496_debug, debug_623
    rx496_cur."!cursor_debug"("NEXT", "")
  debug_623:
  rx496_fail:
    (rx496_rep, rx496_pos, $I10, $P10) = rx496_cur."!mark_fail"(0)
    lt rx496_pos, -1, rx496_done
    eq rx496_pos, -1, rx496_fail
    jump $I10
  rx496_done:
    rx496_cur."!cursor_fail"()
    if_null rx496_debug, debug_624
    rx496_cur."!cursor_debug"("FAIL", "")
  debug_624:
    .return (rx496_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<regex_declarator>"  :subid("115_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx500_tgt
    .local int rx500_pos
    .local int rx500_off
    .local int rx500_eos
    .local int rx500_rep
    .local pmc rx500_cur
    .local pmc rx500_debug
    (rx500_cur, rx500_pos, rx500_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx500_cur
    .local pmc match
    .lex "$/", match
    length rx500_eos, rx500_tgt
    gt rx500_pos, rx500_eos, rx500_done
    set rx500_off, 0
    lt rx500_pos, 2, rx500_start
    sub rx500_off, rx500_pos, 1
    substr rx500_tgt, rx500_tgt, rx500_off
  rx500_start:
    eq $I10, 1, rx500_restart
    if_null rx500_debug, debug_628
    rx500_cur."!cursor_debug"("START", "term:sym<regex_declarator>")
  debug_628:
    $I10 = self.'from'()
    ne $I10, -1, rxscan504_done
    goto rxscan504_scan
  rxscan504_loop:
    (rx500_pos) = rx500_cur."from"()
    inc rx500_pos
    rx500_cur."!cursor_from"(rx500_pos)
    ge rx500_pos, rx500_eos, rxscan504_done
  rxscan504_scan:
    set_addr $I10, rxscan504_loop
    rx500_cur."!mark_push"(0, rx500_pos, $I10)
  rxscan504_done:
.annotate 'line', 254
  # rx subrule "regex_declarator" subtype=capture negate=
    rx500_cur."!cursor_pos"(rx500_pos)
    $P10 = rx500_cur."regex_declarator"()
    unless $P10, rx500_fail
    rx500_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("regex_declarator")
    rx500_pos = $P10."pos"()
  # rx pass
    rx500_cur."!cursor_pass"(rx500_pos, "term:sym<regex_declarator>")
    if_null rx500_debug, debug_629
    rx500_cur."!cursor_debug"("PASS", "term:sym<regex_declarator>", " at pos=", rx500_pos)
  debug_629:
    .return (rx500_cur)
  rx500_restart:
.annotate 'line', 4
    if_null rx500_debug, debug_630
    rx500_cur."!cursor_debug"("NEXT", "term:sym<regex_declarator>")
  debug_630:
  rx500_fail:
    (rx500_rep, rx500_pos, $I10, $P10) = rx500_cur."!mark_fail"(0)
    lt rx500_pos, -1, rx500_done
    eq rx500_pos, -1, rx500_fail
    jump $I10
  rx500_done:
    rx500_cur."!cursor_fail"()
    if_null rx500_debug, debug_631
    rx500_cur."!cursor_debug"("FAIL", "term:sym<regex_declarator>")
  debug_631:
    .return (rx500_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<regex_declarator>"  :nsentry("!PREFIX__term:sym<regex_declarator>") :subid("116_1298325448.42642") :method
.annotate 'line', 4
    $P502 = self."!PREFIX__!subrule"("regex_declarator", "")
    new $P503, "ResizablePMCArray"
    push $P503, $P502
    .return ($P503)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<statement_prefix>"  :subid("117_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx506_tgt
    .local int rx506_pos
    .local int rx506_off
    .local int rx506_eos
    .local int rx506_rep
    .local pmc rx506_cur
    .local pmc rx506_debug
    (rx506_cur, rx506_pos, rx506_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx506_cur
    .local pmc match
    .lex "$/", match
    length rx506_eos, rx506_tgt
    gt rx506_pos, rx506_eos, rx506_done
    set rx506_off, 0
    lt rx506_pos, 2, rx506_start
    sub rx506_off, rx506_pos, 1
    substr rx506_tgt, rx506_tgt, rx506_off
  rx506_start:
    eq $I10, 1, rx506_restart
    if_null rx506_debug, debug_632
    rx506_cur."!cursor_debug"("START", "term:sym<statement_prefix>")
  debug_632:
    $I10 = self.'from'()
    ne $I10, -1, rxscan510_done
    goto rxscan510_scan
  rxscan510_loop:
    (rx506_pos) = rx506_cur."from"()
    inc rx506_pos
    rx506_cur."!cursor_from"(rx506_pos)
    ge rx506_pos, rx506_eos, rxscan510_done
  rxscan510_scan:
    set_addr $I10, rxscan510_loop
    rx506_cur."!mark_push"(0, rx506_pos, $I10)
  rxscan510_done:
.annotate 'line', 255
  # rx subrule "statement_prefix" subtype=capture negate=
    rx506_cur."!cursor_pos"(rx506_pos)
    $P10 = rx506_cur."statement_prefix"()
    unless $P10, rx506_fail
    rx506_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_prefix")
    rx506_pos = $P10."pos"()
  # rx pass
    rx506_cur."!cursor_pass"(rx506_pos, "term:sym<statement_prefix>")
    if_null rx506_debug, debug_633
    rx506_cur."!cursor_debug"("PASS", "term:sym<statement_prefix>", " at pos=", rx506_pos)
  debug_633:
    .return (rx506_cur)
  rx506_restart:
.annotate 'line', 4
    if_null rx506_debug, debug_634
    rx506_cur."!cursor_debug"("NEXT", "term:sym<statement_prefix>")
  debug_634:
  rx506_fail:
    (rx506_rep, rx506_pos, $I10, $P10) = rx506_cur."!mark_fail"(0)
    lt rx506_pos, -1, rx506_done
    eq rx506_pos, -1, rx506_fail
    jump $I10
  rx506_done:
    rx506_cur."!cursor_fail"()
    if_null rx506_debug, debug_635
    rx506_cur."!cursor_debug"("FAIL", "term:sym<statement_prefix>")
  debug_635:
    .return (rx506_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<statement_prefix>"  :nsentry("!PREFIX__term:sym<statement_prefix>") :subid("118_1298325448.42642") :method
.annotate 'line', 4
    $P508 = self."!PREFIX__!subrule"("statement_prefix", "")
    new $P509, "ResizablePMCArray"
    push $P509, $P508
    .return ($P509)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<lambda>"  :subid("119_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx512_tgt
    .local int rx512_pos
    .local int rx512_off
    .local int rx512_eos
    .local int rx512_rep
    .local pmc rx512_cur
    .local pmc rx512_debug
    (rx512_cur, rx512_pos, rx512_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx512_cur
    .local pmc match
    .lex "$/", match
    length rx512_eos, rx512_tgt
    gt rx512_pos, rx512_eos, rx512_done
    set rx512_off, 0
    lt rx512_pos, 2, rx512_start
    sub rx512_off, rx512_pos, 1
    substr rx512_tgt, rx512_tgt, rx512_off
  rx512_start:
    eq $I10, 1, rx512_restart
    if_null rx512_debug, debug_636
    rx512_cur."!cursor_debug"("START", "term:sym<lambda>")
  debug_636:
    $I10 = self.'from'()
    ne $I10, -1, rxscan515_done
    goto rxscan515_scan
  rxscan515_loop:
    (rx512_pos) = rx512_cur."from"()
    inc rx512_pos
    rx512_cur."!cursor_from"(rx512_pos)
    ge rx512_pos, rx512_eos, rxscan515_done
  rxscan515_scan:
    set_addr $I10, rxscan515_loop
    rx512_cur."!mark_push"(0, rx512_pos, $I10)
  rxscan515_done:
.annotate 'line', 256
  # rx subrule "lambda" subtype=zerowidth negate=
    rx512_cur."!cursor_pos"(rx512_pos)
    $P10 = rx512_cur."lambda"()
    unless $P10, rx512_fail
  # rx subrule "pblock" subtype=capture negate=
    rx512_cur."!cursor_pos"(rx512_pos)
    $P10 = rx512_cur."pblock"()
    unless $P10, rx512_fail
    rx512_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx512_pos = $P10."pos"()
  # rx pass
    rx512_cur."!cursor_pass"(rx512_pos, "term:sym<lambda>")
    if_null rx512_debug, debug_637
    rx512_cur."!cursor_debug"("PASS", "term:sym<lambda>", " at pos=", rx512_pos)
  debug_637:
    .return (rx512_cur)
  rx512_restart:
.annotate 'line', 4
    if_null rx512_debug, debug_638
    rx512_cur."!cursor_debug"("NEXT", "term:sym<lambda>")
  debug_638:
  rx512_fail:
    (rx512_rep, rx512_pos, $I10, $P10) = rx512_cur."!mark_fail"(0)
    lt rx512_pos, -1, rx512_done
    eq rx512_pos, -1, rx512_fail
    jump $I10
  rx512_done:
    rx512_cur."!cursor_fail"()
    if_null rx512_debug, debug_639
    rx512_cur."!cursor_debug"("FAIL", "term:sym<lambda>")
  debug_639:
    .return (rx512_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<lambda>"  :nsentry("!PREFIX__term:sym<lambda>") :subid("120_1298325448.42642") :method
.annotate 'line', 4
    new $P514, "ResizablePMCArray"
    push $P514, ""
    .return ($P514)
.end


.namespace ["NQP";"Grammar"]
.sub "fatarrow"  :subid("121_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx517_tgt
    .local int rx517_pos
    .local int rx517_off
    .local int rx517_eos
    .local int rx517_rep
    .local pmc rx517_cur
    .local pmc rx517_debug
    (rx517_cur, rx517_pos, rx517_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx517_cur
    .local pmc match
    .lex "$/", match
    length rx517_eos, rx517_tgt
    gt rx517_pos, rx517_eos, rx517_done
    set rx517_off, 0
    lt rx517_pos, 2, rx517_start
    sub rx517_off, rx517_pos, 1
    substr rx517_tgt, rx517_tgt, rx517_off
  rx517_start:
    eq $I10, 1, rx517_restart
    if_null rx517_debug, debug_640
    rx517_cur."!cursor_debug"("START", "fatarrow")
  debug_640:
    $I10 = self.'from'()
    ne $I10, -1, rxscan521_done
    goto rxscan521_scan
  rxscan521_loop:
    (rx517_pos) = rx517_cur."from"()
    inc rx517_pos
    rx517_cur."!cursor_from"(rx517_pos)
    ge rx517_pos, rx517_eos, rxscan521_done
  rxscan521_scan:
    set_addr $I10, rxscan521_loop
    rx517_cur."!mark_push"(0, rx517_pos, $I10)
  rxscan521_done:
.annotate 'line', 259
  # rx subrule "identifier" subtype=capture negate=
    rx517_cur."!cursor_pos"(rx517_pos)
    $P10 = rx517_cur."identifier"()
    unless $P10, rx517_fail
    rx517_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("key")
    rx517_pos = $P10."pos"()
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx517_pos, rx517_off
    set rx517_rep, 0
    sub $I12, rx517_eos, rx517_pos
  rxenumcharlistq522_loop:
    le $I12, 0, rxenumcharlistq522_done
    substr $S10, rx517_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq522_done
    inc rx517_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq522_loop
  rxenumcharlistq522_done:
    add rx517_pos, rx517_pos, rx517_rep
  # rx literal  "=>"
    add $I11, rx517_pos, 2
    gt $I11, rx517_eos, rx517_fail
    sub $I11, rx517_pos, rx517_off
    substr $S10, rx517_tgt, $I11, 2
    ne $S10, "=>", rx517_fail
    add rx517_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx517_cur."!cursor_pos"(rx517_pos)
    $P10 = rx517_cur."ws"()
    unless $P10, rx517_fail
    rx517_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx517_cur."!cursor_pos"(rx517_pos)
    $P10 = rx517_cur."EXPR"("i=")
    unless $P10, rx517_fail
    rx517_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("val")
    rx517_pos = $P10."pos"()
.annotate 'line', 258
  # rx pass
    rx517_cur."!cursor_pass"(rx517_pos, "fatarrow")
    if_null rx517_debug, debug_641
    rx517_cur."!cursor_debug"("PASS", "fatarrow", " at pos=", rx517_pos)
  debug_641:
    .return (rx517_cur)
  rx517_restart:
.annotate 'line', 4
    if_null rx517_debug, debug_642
    rx517_cur."!cursor_debug"("NEXT", "fatarrow")
  debug_642:
  rx517_fail:
    (rx517_rep, rx517_pos, $I10, $P10) = rx517_cur."!mark_fail"(0)
    lt rx517_pos, -1, rx517_done
    eq rx517_pos, -1, rx517_fail
    jump $I10
  rx517_done:
    rx517_cur."!cursor_fail"()
    if_null rx517_debug, debug_643
    rx517_cur."!cursor_debug"("FAIL", "fatarrow")
  debug_643:
    .return (rx517_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__fatarrow"  :nsentry("!PREFIX__fatarrow") :subid("122_1298325448.42642") :method
.annotate 'line', 4
    $P519 = self."!PREFIX__!subrule"("identifier", "")
    new $P520, "ResizablePMCArray"
    push $P520, $P519
    .return ($P520)
.end


.namespace ["NQP";"Grammar"]
.sub "colonpair"  :subid("123_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx524_tgt
    .local int rx524_pos
    .local int rx524_off
    .local int rx524_eos
    .local int rx524_rep
    .local pmc rx524_cur
    .local pmc rx524_debug
    (rx524_cur, rx524_pos, rx524_tgt, $I10) = self."!cursor_start"()
    rx524_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx524_cur
    .local pmc match
    .lex "$/", match
    length rx524_eos, rx524_tgt
    gt rx524_pos, rx524_eos, rx524_done
    set rx524_off, 0
    lt rx524_pos, 2, rx524_start
    sub rx524_off, rx524_pos, 1
    substr rx524_tgt, rx524_tgt, rx524_off
  rx524_start:
    eq $I10, 1, rx524_restart
    if_null rx524_debug, debug_644
    rx524_cur."!cursor_debug"("START", "colonpair")
  debug_644:
    $I10 = self.'from'()
    ne $I10, -1, rxscan530_done
    goto rxscan530_scan
  rxscan530_loop:
    (rx524_pos) = rx524_cur."from"()
    inc rx524_pos
    rx524_cur."!cursor_from"(rx524_pos)
    ge rx524_pos, rx524_eos, rxscan530_done
  rxscan530_scan:
    set_addr $I10, rxscan530_loop
    rx524_cur."!mark_push"(0, rx524_pos, $I10)
  rxscan530_done:
.annotate 'line', 263
  # rx literal  ":"
    add $I11, rx524_pos, 1
    gt $I11, rx524_eos, rx524_fail
    sub $I11, rx524_pos, rx524_off
    ord $I11, rx524_tgt, $I11
    ne $I11, 58, rx524_fail
    add rx524_pos, 1
  alt531_0:
.annotate 'line', 264
    set_addr $I10, alt531_1
    rx524_cur."!mark_push"(0, rx524_pos, $I10)
.annotate 'line', 265
  # rx subcapture "not"
    set_addr $I10, rxcap_532_fail
    rx524_cur."!mark_push"(0, rx524_pos, $I10)
  # rx literal  "!"
    add $I11, rx524_pos, 1
    gt $I11, rx524_eos, rx524_fail
    sub $I11, rx524_pos, rx524_off
    ord $I11, rx524_tgt, $I11
    ne $I11, 33, rx524_fail
    add rx524_pos, 1
    set_addr $I10, rxcap_532_fail
    ($I12, $I11) = rx524_cur."!mark_peek"($I10)
    rx524_cur."!cursor_pos"($I11)
    ($P10) = rx524_cur."!cursor_start"()
    $P10."!cursor_pass"(rx524_pos, "")
    rx524_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("not")
    goto rxcap_532_done
  rxcap_532_fail:
    goto rx524_fail
  rxcap_532_done:
  # rx subrule "identifier" subtype=capture negate=
    rx524_cur."!cursor_pos"(rx524_pos)
    $P10 = rx524_cur."identifier"()
    unless $P10, rx524_fail
    rx524_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx524_pos = $P10."pos"()
    goto alt531_end
  alt531_1:
    set_addr $I10, alt531_2
    rx524_cur."!mark_push"(0, rx524_pos, $I10)
.annotate 'line', 266
  # rx subrule "identifier" subtype=capture negate=
    rx524_cur."!cursor_pos"(rx524_pos)
    $P10 = rx524_cur."identifier"()
    unless $P10, rx524_fail
    rx524_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx524_pos = $P10."pos"()
  # rx rxquantr533 ** 0..1
    set_addr $I10, rxquantr533_done
    rx524_cur."!mark_push"(0, rx524_pos, $I10)
  rxquantr533_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx524_cur."!cursor_pos"(rx524_pos)
    $P10 = rx524_cur."circumfix"()
    unless $P10, rx524_fail
    goto rxsubrule534_pass
  rxsubrule534_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx524_fail
  rxsubrule534_pass:
    set_addr $I10, rxsubrule534_back
    rx524_cur."!mark_push"(0, rx524_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx524_pos = $P10."pos"()
    set_addr $I10, rxquantr533_done
    (rx524_rep) = rx524_cur."!mark_commit"($I10)
  rxquantr533_done:
    goto alt531_end
  alt531_2:
.annotate 'line', 267
  # rx subrule "circumfix" subtype=capture negate=
    rx524_cur."!cursor_pos"(rx524_pos)
    $P10 = rx524_cur."circumfix"()
    unless $P10, rx524_fail
    rx524_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("circumfix")
    rx524_pos = $P10."pos"()
  alt531_end:
.annotate 'line', 262
  # rx pass
    rx524_cur."!cursor_pass"(rx524_pos, "colonpair")
    if_null rx524_debug, debug_645
    rx524_cur."!cursor_debug"("PASS", "colonpair", " at pos=", rx524_pos)
  debug_645:
    .return (rx524_cur)
  rx524_restart:
.annotate 'line', 4
    if_null rx524_debug, debug_646
    rx524_cur."!cursor_debug"("NEXT", "colonpair")
  debug_646:
  rx524_fail:
    (rx524_rep, rx524_pos, $I10, $P10) = rx524_cur."!mark_fail"(0)
    lt rx524_pos, -1, rx524_done
    eq rx524_pos, -1, rx524_fail
    jump $I10
  rx524_done:
    rx524_cur."!cursor_fail"()
    if_null rx524_debug, debug_647
    rx524_cur."!cursor_debug"("FAIL", "colonpair")
  debug_647:
    .return (rx524_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__colonpair"  :nsentry("!PREFIX__colonpair") :subid("124_1298325448.42642") :method
.annotate 'line', 4
    $P526 = self."!PREFIX__!subrule"("circumfix", ":")
    $P527 = self."!PREFIX__!subrule"("identifier", ":")
    $P528 = self."!PREFIX__!subrule"("identifier", ":!")
    new $P529, "ResizablePMCArray"
    push $P529, $P526
    push $P529, $P527
    push $P529, $P528
    .return ($P529)
.end


.namespace ["NQP";"Grammar"]
.sub "variable"  :subid("125_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx536_tgt
    .local int rx536_pos
    .local int rx536_off
    .local int rx536_eos
    .local int rx536_rep
    .local pmc rx536_cur
    .local pmc rx536_debug
    (rx536_cur, rx536_pos, rx536_tgt, $I10) = self."!cursor_start"()
    rx536_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx536_cur
    .local pmc match
    .lex "$/", match
    length rx536_eos, rx536_tgt
    gt rx536_pos, rx536_eos, rx536_done
    set rx536_off, 0
    lt rx536_pos, 2, rx536_start
    sub rx536_off, rx536_pos, 1
    substr rx536_tgt, rx536_tgt, rx536_off
  rx536_start:
    eq $I10, 1, rx536_restart
    if_null rx536_debug, debug_648
    rx536_cur."!cursor_debug"("START", "variable")
  debug_648:
    $I10 = self.'from'()
    ne $I10, -1, rxscan541_done
    goto rxscan541_scan
  rxscan541_loop:
    (rx536_pos) = rx536_cur."from"()
    inc rx536_pos
    rx536_cur."!cursor_from"(rx536_pos)
    ge rx536_pos, rx536_eos, rxscan541_done
  rxscan541_scan:
    set_addr $I10, rxscan541_loop
    rx536_cur."!mark_push"(0, rx536_pos, $I10)
  rxscan541_done:
  alt542_0:
.annotate 'line', 271
    set_addr $I10, alt542_1
    rx536_cur."!mark_push"(0, rx536_pos, $I10)
.annotate 'line', 272
  # rx subrule "sigil" subtype=capture negate=
    rx536_cur."!cursor_pos"(rx536_pos)
    $P10 = rx536_cur."sigil"()
    unless $P10, rx536_fail
    rx536_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx536_pos = $P10."pos"()
  # rx rxquantr543 ** 0..1
    set_addr $I10, rxquantr543_done
    rx536_cur."!mark_push"(0, rx536_pos, $I10)
  rxquantr543_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx536_cur."!cursor_pos"(rx536_pos)
    $P10 = rx536_cur."twigil"()
    unless $P10, rx536_fail
    goto rxsubrule544_pass
  rxsubrule544_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx536_fail
  rxsubrule544_pass:
    set_addr $I10, rxsubrule544_back
    rx536_cur."!mark_push"(0, rx536_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx536_pos = $P10."pos"()
    set_addr $I10, rxquantr543_done
    (rx536_rep) = rx536_cur."!mark_commit"($I10)
  rxquantr543_done:
  # rx subrule "name" subtype=capture negate=
    rx536_cur."!cursor_pos"(rx536_pos)
    $P10 = rx536_cur."name"()
    unless $P10, rx536_fail
    rx536_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    rx536_pos = $P10."pos"()
    goto alt542_end
  alt542_1:
    set_addr $I10, alt542_2
    rx536_cur."!mark_push"(0, rx536_pos, $I10)
.annotate 'line', 273
  # rx subrule "sigil" subtype=capture negate=
    rx536_cur."!cursor_pos"(rx536_pos)
    $P10 = rx536_cur."sigil"()
    unless $P10, rx536_fail
    rx536_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx536_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx536_pos, rx536_off
    substr $S10, rx536_tgt, $I10, 1
    index $I11, "<[", $S10
    lt $I11, 0, rx536_fail
  # rx subrule "postcircumfix" subtype=capture negate=
    rx536_cur."!cursor_pos"(rx536_pos)
    $P10 = rx536_cur."postcircumfix"()
    unless $P10, rx536_fail
    rx536_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("postcircumfix")
    rx536_pos = $P10."pos"()
    goto alt542_end
  alt542_2:
.annotate 'line', 274
  # rx subcapture "sigil"
    set_addr $I10, rxcap_545_fail
    rx536_cur."!mark_push"(0, rx536_pos, $I10)
  # rx literal  "$"
    add $I11, rx536_pos, 1
    gt $I11, rx536_eos, rx536_fail
    sub $I11, rx536_pos, rx536_off
    ord $I11, rx536_tgt, $I11
    ne $I11, 36, rx536_fail
    add rx536_pos, 1
    set_addr $I10, rxcap_545_fail
    ($I12, $I11) = rx536_cur."!mark_peek"($I10)
    rx536_cur."!cursor_pos"($I11)
    ($P10) = rx536_cur."!cursor_start"()
    $P10."!cursor_pass"(rx536_pos, "")
    rx536_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_545_done
  rxcap_545_fail:
    goto rx536_fail
  rxcap_545_done:
  # rx subcapture "desigilname"
    set_addr $I10, rxcap_546_fail
    rx536_cur."!mark_push"(0, rx536_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx536_pos, rx536_eos, rx536_fail
    sub $I10, rx536_pos, rx536_off
    substr $S10, rx536_tgt, $I10, 1
    index $I11, "/_!", $S10
    lt $I11, 0, rx536_fail
    inc rx536_pos
    set_addr $I10, rxcap_546_fail
    ($I12, $I11) = rx536_cur."!mark_peek"($I10)
    rx536_cur."!cursor_pos"($I11)
    ($P10) = rx536_cur."!cursor_start"()
    $P10."!cursor_pass"(rx536_pos, "")
    rx536_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    goto rxcap_546_done
  rxcap_546_fail:
    goto rx536_fail
  rxcap_546_done:
  alt542_end:
.annotate 'line', 271
  # rx pass
    rx536_cur."!cursor_pass"(rx536_pos, "variable")
    if_null rx536_debug, debug_649
    rx536_cur."!cursor_debug"("PASS", "variable", " at pos=", rx536_pos)
  debug_649:
    .return (rx536_cur)
  rx536_restart:
.annotate 'line', 4
    if_null rx536_debug, debug_650
    rx536_cur."!cursor_debug"("NEXT", "variable")
  debug_650:
  rx536_fail:
    (rx536_rep, rx536_pos, $I10, $P10) = rx536_cur."!mark_fail"(0)
    lt rx536_pos, -1, rx536_done
    eq rx536_pos, -1, rx536_fail
    jump $I10
  rx536_done:
    rx536_cur."!cursor_fail"()
    if_null rx536_debug, debug_651
    rx536_cur."!cursor_debug"("FAIL", "variable")
  debug_651:
    .return (rx536_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable"  :nsentry("!PREFIX__variable") :subid("126_1298325448.42642") :method
.annotate 'line', 4
    $P538 = self."!PREFIX__!subrule"("sigil", "")
    $P539 = self."!PREFIX__!subrule"("sigil", "")
    new $P540, "ResizablePMCArray"
    push $P540, "$!"
    push $P540, "$_"
    push $P540, "$/"
    push $P540, $P538
    push $P540, $P539
    .return ($P540)
.end


.namespace ["NQP";"Grammar"]
.sub "sigil"  :subid("127_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx548_tgt
    .local int rx548_pos
    .local int rx548_off
    .local int rx548_eos
    .local int rx548_rep
    .local pmc rx548_cur
    .local pmc rx548_debug
    (rx548_cur, rx548_pos, rx548_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx548_cur
    .local pmc match
    .lex "$/", match
    length rx548_eos, rx548_tgt
    gt rx548_pos, rx548_eos, rx548_done
    set rx548_off, 0
    lt rx548_pos, 2, rx548_start
    sub rx548_off, rx548_pos, 1
    substr rx548_tgt, rx548_tgt, rx548_off
  rx548_start:
    eq $I10, 1, rx548_restart
    if_null rx548_debug, debug_652
    rx548_cur."!cursor_debug"("START", "sigil")
  debug_652:
    $I10 = self.'from'()
    ne $I10, -1, rxscan551_done
    goto rxscan551_scan
  rxscan551_loop:
    (rx548_pos) = rx548_cur."from"()
    inc rx548_pos
    rx548_cur."!cursor_from"(rx548_pos)
    ge rx548_pos, rx548_eos, rxscan551_done
  rxscan551_scan:
    set_addr $I10, rxscan551_loop
    rx548_cur."!mark_push"(0, rx548_pos, $I10)
  rxscan551_done:
.annotate 'line', 277
  # rx enumcharlist negate=0 
    ge rx548_pos, rx548_eos, rx548_fail
    sub $I10, rx548_pos, rx548_off
    substr $S10, rx548_tgt, $I10, 1
    index $I11, "$@%&", $S10
    lt $I11, 0, rx548_fail
    inc rx548_pos
  # rx pass
    rx548_cur."!cursor_pass"(rx548_pos, "sigil")
    if_null rx548_debug, debug_653
    rx548_cur."!cursor_debug"("PASS", "sigil", " at pos=", rx548_pos)
  debug_653:
    .return (rx548_cur)
  rx548_restart:
.annotate 'line', 4
    if_null rx548_debug, debug_654
    rx548_cur."!cursor_debug"("NEXT", "sigil")
  debug_654:
  rx548_fail:
    (rx548_rep, rx548_pos, $I10, $P10) = rx548_cur."!mark_fail"(0)
    lt rx548_pos, -1, rx548_done
    eq rx548_pos, -1, rx548_fail
    jump $I10
  rx548_done:
    rx548_cur."!cursor_fail"()
    if_null rx548_debug, debug_655
    rx548_cur."!cursor_debug"("FAIL", "sigil")
  debug_655:
    .return (rx548_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__sigil"  :nsentry("!PREFIX__sigil") :subid("128_1298325448.42642") :method
.annotate 'line', 4
    new $P550, "ResizablePMCArray"
    push $P550, "&"
    push $P550, "%"
    push $P550, "@"
    push $P550, "$"
    .return ($P550)
.end


.namespace ["NQP";"Grammar"]
.sub "twigil"  :subid("129_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx553_tgt
    .local int rx553_pos
    .local int rx553_off
    .local int rx553_eos
    .local int rx553_rep
    .local pmc rx553_cur
    .local pmc rx553_debug
    (rx553_cur, rx553_pos, rx553_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx553_cur
    .local pmc match
    .lex "$/", match
    length rx553_eos, rx553_tgt
    gt rx553_pos, rx553_eos, rx553_done
    set rx553_off, 0
    lt rx553_pos, 2, rx553_start
    sub rx553_off, rx553_pos, 1
    substr rx553_tgt, rx553_tgt, rx553_off
  rx553_start:
    eq $I10, 1, rx553_restart
    if_null rx553_debug, debug_656
    rx553_cur."!cursor_debug"("START", "twigil")
  debug_656:
    $I10 = self.'from'()
    ne $I10, -1, rxscan556_done
    goto rxscan556_scan
  rxscan556_loop:
    (rx553_pos) = rx553_cur."from"()
    inc rx553_pos
    rx553_cur."!cursor_from"(rx553_pos)
    ge rx553_pos, rx553_eos, rxscan556_done
  rxscan556_scan:
    set_addr $I10, rxscan556_loop
    rx553_cur."!mark_push"(0, rx553_pos, $I10)
  rxscan556_done:
.annotate 'line', 279
  # rx enumcharlist negate=0 
    ge rx553_pos, rx553_eos, rx553_fail
    sub $I10, rx553_pos, rx553_off
    substr $S10, rx553_tgt, $I10, 1
    index $I11, "*!?", $S10
    lt $I11, 0, rx553_fail
    inc rx553_pos
  # rx pass
    rx553_cur."!cursor_pass"(rx553_pos, "twigil")
    if_null rx553_debug, debug_657
    rx553_cur."!cursor_debug"("PASS", "twigil", " at pos=", rx553_pos)
  debug_657:
    .return (rx553_cur)
  rx553_restart:
.annotate 'line', 4
    if_null rx553_debug, debug_658
    rx553_cur."!cursor_debug"("NEXT", "twigil")
  debug_658:
  rx553_fail:
    (rx553_rep, rx553_pos, $I10, $P10) = rx553_cur."!mark_fail"(0)
    lt rx553_pos, -1, rx553_done
    eq rx553_pos, -1, rx553_fail
    jump $I10
  rx553_done:
    rx553_cur."!cursor_fail"()
    if_null rx553_debug, debug_659
    rx553_cur."!cursor_debug"("FAIL", "twigil")
  debug_659:
    .return (rx553_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__twigil"  :nsentry("!PREFIX__twigil") :subid("130_1298325448.42642") :method
.annotate 'line', 4
    new $P555, "ResizablePMCArray"
    push $P555, "?"
    push $P555, "!"
    push $P555, "*"
    .return ($P555)
.end


.namespace ["NQP";"Grammar"]
.sub "package_declarator"  :subid("131_1298325448.42642")
    .param pmc param_558
.annotate 'line', 281
    .lex "self", param_558
    $P559 = param_558."!protoregex"("package_declarator")
    .return ($P559)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator"  :subid("132_1298325448.42642")
    .param pmc param_561
.annotate 'line', 281
    .lex "self", param_561
    $P562 = param_561."!PREFIX__!protoregex"("package_declarator")
    .return ($P562)
.end


.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<module>"  :subid("133_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 283
    new $P564, "Undef"
    .lex "$*PACKAGE-SETUP", $P564
.annotate 'line', 284
    new $P565, "Undef"
    .lex "$*PKGDECL", $P565
.annotate 'line', 4
    .local string rx566_tgt
    .local int rx566_pos
    .local int rx566_off
    .local int rx566_eos
    .local int rx566_rep
    .local pmc rx566_cur
    .local pmc rx566_debug
    (rx566_cur, rx566_pos, rx566_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx566_cur
    .local pmc match
    .lex "$/", match
    length rx566_eos, rx566_tgt
    gt rx566_pos, rx566_eos, rx566_done
    set rx566_off, 0
    lt rx566_pos, 2, rx566_start
    sub rx566_off, rx566_pos, 1
    substr rx566_tgt, rx566_tgt, rx566_off
  rx566_start:
    eq $I10, 1, rx566_restart
    if_null rx566_debug, debug_660
    rx566_cur."!cursor_debug"("START", "package_declarator:sym<module>")
  debug_660:
    $I10 = self.'from'()
    ne $I10, -1, rxscan570_done
    goto rxscan570_scan
  rxscan570_loop:
    (rx566_pos) = rx566_cur."from"()
    inc rx566_pos
    rx566_cur."!cursor_from"(rx566_pos)
    ge rx566_pos, rx566_eos, rxscan570_done
  rxscan570_scan:
    set_addr $I10, rxscan570_loop
    rx566_cur."!mark_push"(0, rx566_pos, $I10)
  rxscan570_done:
.annotate 'line', 283
    rx566_cur."!cursor_pos"(rx566_pos)
    get_hll_global $P571, ["PAST"], "Stmts"
    $P572 = $P571."new"()
    store_lex "$*PACKAGE-SETUP", $P572
.annotate 'line', 284
    rx566_cur."!cursor_pos"(rx566_pos)
    new $P573, "String"
    assign $P573, "module"
    store_lex "$*PKGDECL", $P573
.annotate 'line', 285
  # rx subcapture "sym"
    set_addr $I10, rxcap_574_fail
    rx566_cur."!mark_push"(0, rx566_pos, $I10)
  # rx literal  "module"
    add $I11, rx566_pos, 6
    gt $I11, rx566_eos, rx566_fail
    sub $I11, rx566_pos, rx566_off
    substr $S10, rx566_tgt, $I11, 6
    ne $S10, "module", rx566_fail
    add rx566_pos, 6
    set_addr $I10, rxcap_574_fail
    ($I12, $I11) = rx566_cur."!mark_peek"($I10)
    rx566_cur."!cursor_pos"($I11)
    ($P10) = rx566_cur."!cursor_start"()
    $P10."!cursor_pass"(rx566_pos, "")
    rx566_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_574_done
  rxcap_574_fail:
    goto rx566_fail
  rxcap_574_done:
  # rx subrule "package_def" subtype=capture negate=
    rx566_cur."!cursor_pos"(rx566_pos)
    $P10 = rx566_cur."package_def"()
    unless $P10, rx566_fail
    rx566_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx566_pos = $P10."pos"()
.annotate 'line', 282
  # rx pass
    rx566_cur."!cursor_pass"(rx566_pos, "package_declarator:sym<module>")
    if_null rx566_debug, debug_661
    rx566_cur."!cursor_debug"("PASS", "package_declarator:sym<module>", " at pos=", rx566_pos)
  debug_661:
    .return (rx566_cur)
  rx566_restart:
.annotate 'line', 4
    if_null rx566_debug, debug_662
    rx566_cur."!cursor_debug"("NEXT", "package_declarator:sym<module>")
  debug_662:
  rx566_fail:
    (rx566_rep, rx566_pos, $I10, $P10) = rx566_cur."!mark_fail"(0)
    lt rx566_pos, -1, rx566_done
    eq rx566_pos, -1, rx566_fail
    jump $I10
  rx566_done:
    rx566_cur."!cursor_fail"()
    if_null rx566_debug, debug_663
    rx566_cur."!cursor_debug"("FAIL", "package_declarator:sym<module>")
  debug_663:
    .return (rx566_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<module>"  :nsentry("!PREFIX__package_declarator:sym<module>") :subid("134_1298325448.42642") :method
.annotate 'line', 4
    $P568 = self."!PREFIX__!subrule"("package_def", "module")
    new $P569, "ResizablePMCArray"
    push $P569, $P568
    .return ($P569)
.end


.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<knowhow>"  :subid("135_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 288
    new $P576, "Undef"
    .lex "$*PACKAGE-SETUP", $P576
.annotate 'line', 289
    new $P577, "Undef"
    .lex "$*PKGDECL", $P577
.annotate 'line', 4
    .local string rx578_tgt
    .local int rx578_pos
    .local int rx578_off
    .local int rx578_eos
    .local int rx578_rep
    .local pmc rx578_cur
    .local pmc rx578_debug
    (rx578_cur, rx578_pos, rx578_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx578_cur
    .local pmc match
    .lex "$/", match
    length rx578_eos, rx578_tgt
    gt rx578_pos, rx578_eos, rx578_done
    set rx578_off, 0
    lt rx578_pos, 2, rx578_start
    sub rx578_off, rx578_pos, 1
    substr rx578_tgt, rx578_tgt, rx578_off
  rx578_start:
    eq $I10, 1, rx578_restart
    if_null rx578_debug, debug_664
    rx578_cur."!cursor_debug"("START", "package_declarator:sym<knowhow>")
  debug_664:
    $I10 = self.'from'()
    ne $I10, -1, rxscan582_done
    goto rxscan582_scan
  rxscan582_loop:
    (rx578_pos) = rx578_cur."from"()
    inc rx578_pos
    rx578_cur."!cursor_from"(rx578_pos)
    ge rx578_pos, rx578_eos, rxscan582_done
  rxscan582_scan:
    set_addr $I10, rxscan582_loop
    rx578_cur."!mark_push"(0, rx578_pos, $I10)
  rxscan582_done:
.annotate 'line', 288
    rx578_cur."!cursor_pos"(rx578_pos)
    get_hll_global $P583, ["PAST"], "Stmts"
    $P584 = $P583."new"()
    store_lex "$*PACKAGE-SETUP", $P584
.annotate 'line', 289
    rx578_cur."!cursor_pos"(rx578_pos)
    new $P585, "String"
    assign $P585, "knowhow"
    store_lex "$*PKGDECL", $P585
.annotate 'line', 290
  # rx subcapture "sym"
    set_addr $I10, rxcap_586_fail
    rx578_cur."!mark_push"(0, rx578_pos, $I10)
  # rx literal  "knowhow"
    add $I11, rx578_pos, 7
    gt $I11, rx578_eos, rx578_fail
    sub $I11, rx578_pos, rx578_off
    substr $S10, rx578_tgt, $I11, 7
    ne $S10, "knowhow", rx578_fail
    add rx578_pos, 7
    set_addr $I10, rxcap_586_fail
    ($I12, $I11) = rx578_cur."!mark_peek"($I10)
    rx578_cur."!cursor_pos"($I11)
    ($P10) = rx578_cur."!cursor_start"()
    $P10."!cursor_pass"(rx578_pos, "")
    rx578_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_586_done
  rxcap_586_fail:
    goto rx578_fail
  rxcap_586_done:
  # rx subrule "package_def" subtype=capture negate=
    rx578_cur."!cursor_pos"(rx578_pos)
    $P10 = rx578_cur."package_def"()
    unless $P10, rx578_fail
    rx578_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx578_pos = $P10."pos"()
.annotate 'line', 287
  # rx pass
    rx578_cur."!cursor_pass"(rx578_pos, "package_declarator:sym<knowhow>")
    if_null rx578_debug, debug_665
    rx578_cur."!cursor_debug"("PASS", "package_declarator:sym<knowhow>", " at pos=", rx578_pos)
  debug_665:
    .return (rx578_cur)
  rx578_restart:
.annotate 'line', 4
    if_null rx578_debug, debug_666
    rx578_cur."!cursor_debug"("NEXT", "package_declarator:sym<knowhow>")
  debug_666:
  rx578_fail:
    (rx578_rep, rx578_pos, $I10, $P10) = rx578_cur."!mark_fail"(0)
    lt rx578_pos, -1, rx578_done
    eq rx578_pos, -1, rx578_fail
    jump $I10
  rx578_done:
    rx578_cur."!cursor_fail"()
    if_null rx578_debug, debug_667
    rx578_cur."!cursor_debug"("FAIL", "package_declarator:sym<knowhow>")
  debug_667:
    .return (rx578_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<knowhow>"  :nsentry("!PREFIX__package_declarator:sym<knowhow>") :subid("136_1298325448.42642") :method
.annotate 'line', 4
    $P580 = self."!PREFIX__!subrule"("package_def", "knowhow")
    new $P581, "ResizablePMCArray"
    push $P581, $P580
    .return ($P581)
.end


.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<class>"  :subid("137_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 293
    new $P588, "Undef"
    .lex "$*PACKAGE-SETUP", $P588
.annotate 'line', 294
    new $P589, "Undef"
    .lex "$*PKGDECL", $P589
.annotate 'line', 4
    .local string rx590_tgt
    .local int rx590_pos
    .local int rx590_off
    .local int rx590_eos
    .local int rx590_rep
    .local pmc rx590_cur
    .local pmc rx590_debug
    (rx590_cur, rx590_pos, rx590_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx590_cur
    .local pmc match
    .lex "$/", match
    length rx590_eos, rx590_tgt
    gt rx590_pos, rx590_eos, rx590_done
    set rx590_off, 0
    lt rx590_pos, 2, rx590_start
    sub rx590_off, rx590_pos, 1
    substr rx590_tgt, rx590_tgt, rx590_off
  rx590_start:
    eq $I10, 1, rx590_restart
    if_null rx590_debug, debug_668
    rx590_cur."!cursor_debug"("START", "package_declarator:sym<class>")
  debug_668:
    $I10 = self.'from'()
    ne $I10, -1, rxscan594_done
    goto rxscan594_scan
  rxscan594_loop:
    (rx590_pos) = rx590_cur."from"()
    inc rx590_pos
    rx590_cur."!cursor_from"(rx590_pos)
    ge rx590_pos, rx590_eos, rxscan594_done
  rxscan594_scan:
    set_addr $I10, rxscan594_loop
    rx590_cur."!mark_push"(0, rx590_pos, $I10)
  rxscan594_done:
.annotate 'line', 293
    rx590_cur."!cursor_pos"(rx590_pos)
    get_hll_global $P595, ["PAST"], "Stmts"
    $P596 = $P595."new"()
    store_lex "$*PACKAGE-SETUP", $P596
.annotate 'line', 294
    rx590_cur."!cursor_pos"(rx590_pos)
    new $P597, "String"
    assign $P597, "class"
    store_lex "$*PKGDECL", $P597
.annotate 'line', 295
  # rx subcapture "sym"
    set_addr $I10, rxcap_598_fail
    rx590_cur."!mark_push"(0, rx590_pos, $I10)
  # rx literal  "class"
    add $I11, rx590_pos, 5
    gt $I11, rx590_eos, rx590_fail
    sub $I11, rx590_pos, rx590_off
    substr $S10, rx590_tgt, $I11, 5
    ne $S10, "class", rx590_fail
    add rx590_pos, 5
    set_addr $I10, rxcap_598_fail
    ($I12, $I11) = rx590_cur."!mark_peek"($I10)
    rx590_cur."!cursor_pos"($I11)
    ($P10) = rx590_cur."!cursor_start"()
    $P10."!cursor_pass"(rx590_pos, "")
    rx590_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_598_done
  rxcap_598_fail:
    goto rx590_fail
  rxcap_598_done:
  # rx subrule "package_def" subtype=capture negate=
    rx590_cur."!cursor_pos"(rx590_pos)
    $P10 = rx590_cur."package_def"()
    unless $P10, rx590_fail
    rx590_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx590_pos = $P10."pos"()
.annotate 'line', 292
  # rx pass
    rx590_cur."!cursor_pass"(rx590_pos, "package_declarator:sym<class>")
    if_null rx590_debug, debug_669
    rx590_cur."!cursor_debug"("PASS", "package_declarator:sym<class>", " at pos=", rx590_pos)
  debug_669:
    .return (rx590_cur)
  rx590_restart:
.annotate 'line', 4
    if_null rx590_debug, debug_670
    rx590_cur."!cursor_debug"("NEXT", "package_declarator:sym<class>")
  debug_670:
  rx590_fail:
    (rx590_rep, rx590_pos, $I10, $P10) = rx590_cur."!mark_fail"(0)
    lt rx590_pos, -1, rx590_done
    eq rx590_pos, -1, rx590_fail
    jump $I10
  rx590_done:
    rx590_cur."!cursor_fail"()
    if_null rx590_debug, debug_671
    rx590_cur."!cursor_debug"("FAIL", "package_declarator:sym<class>")
  debug_671:
    .return (rx590_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<class>"  :nsentry("!PREFIX__package_declarator:sym<class>") :subid("138_1298325448.42642") :method
.annotate 'line', 4
    $P592 = self."!PREFIX__!subrule"("package_def", "class")
    new $P593, "ResizablePMCArray"
    push $P593, $P592
    .return ($P593)
.end


.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<grammar>"  :subid("139_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 298
    new $P600, "Undef"
    .lex "$*PACKAGE-SETUP", $P600
.annotate 'line', 299
    new $P601, "Undef"
    .lex "$*PKGDECL", $P601
.annotate 'line', 4
    .local string rx602_tgt
    .local int rx602_pos
    .local int rx602_off
    .local int rx602_eos
    .local int rx602_rep
    .local pmc rx602_cur
    .local pmc rx602_debug
    (rx602_cur, rx602_pos, rx602_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx602_cur
    .local pmc match
    .lex "$/", match
    length rx602_eos, rx602_tgt
    gt rx602_pos, rx602_eos, rx602_done
    set rx602_off, 0
    lt rx602_pos, 2, rx602_start
    sub rx602_off, rx602_pos, 1
    substr rx602_tgt, rx602_tgt, rx602_off
  rx602_start:
    eq $I10, 1, rx602_restart
    if_null rx602_debug, debug_672
    rx602_cur."!cursor_debug"("START", "package_declarator:sym<grammar>")
  debug_672:
    $I10 = self.'from'()
    ne $I10, -1, rxscan606_done
    goto rxscan606_scan
  rxscan606_loop:
    (rx602_pos) = rx602_cur."from"()
    inc rx602_pos
    rx602_cur."!cursor_from"(rx602_pos)
    ge rx602_pos, rx602_eos, rxscan606_done
  rxscan606_scan:
    set_addr $I10, rxscan606_loop
    rx602_cur."!mark_push"(0, rx602_pos, $I10)
  rxscan606_done:
.annotate 'line', 298
    rx602_cur."!cursor_pos"(rx602_pos)
    get_hll_global $P607, ["PAST"], "Stmts"
    $P608 = $P607."new"()
    store_lex "$*PACKAGE-SETUP", $P608
.annotate 'line', 299
    rx602_cur."!cursor_pos"(rx602_pos)
    new $P609, "String"
    assign $P609, "grammar"
    store_lex "$*PKGDECL", $P609
.annotate 'line', 300
  # rx subcapture "sym"
    set_addr $I10, rxcap_610_fail
    rx602_cur."!mark_push"(0, rx602_pos, $I10)
  # rx literal  "grammar"
    add $I11, rx602_pos, 7
    gt $I11, rx602_eos, rx602_fail
    sub $I11, rx602_pos, rx602_off
    substr $S10, rx602_tgt, $I11, 7
    ne $S10, "grammar", rx602_fail
    add rx602_pos, 7
    set_addr $I10, rxcap_610_fail
    ($I12, $I11) = rx602_cur."!mark_peek"($I10)
    rx602_cur."!cursor_pos"($I11)
    ($P10) = rx602_cur."!cursor_start"()
    $P10."!cursor_pass"(rx602_pos, "")
    rx602_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_610_done
  rxcap_610_fail:
    goto rx602_fail
  rxcap_610_done:
  # rx subrule "package_def" subtype=capture negate=
    rx602_cur."!cursor_pos"(rx602_pos)
    $P10 = rx602_cur."package_def"()
    unless $P10, rx602_fail
    rx602_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx602_pos = $P10."pos"()
.annotate 'line', 297
  # rx pass
    rx602_cur."!cursor_pass"(rx602_pos, "package_declarator:sym<grammar>")
    if_null rx602_debug, debug_673
    rx602_cur."!cursor_debug"("PASS", "package_declarator:sym<grammar>", " at pos=", rx602_pos)
  debug_673:
    .return (rx602_cur)
  rx602_restart:
.annotate 'line', 4
    if_null rx602_debug, debug_674
    rx602_cur."!cursor_debug"("NEXT", "package_declarator:sym<grammar>")
  debug_674:
  rx602_fail:
    (rx602_rep, rx602_pos, $I10, $P10) = rx602_cur."!mark_fail"(0)
    lt rx602_pos, -1, rx602_done
    eq rx602_pos, -1, rx602_fail
    jump $I10
  rx602_done:
    rx602_cur."!cursor_fail"()
    if_null rx602_debug, debug_675
    rx602_cur."!cursor_debug"("FAIL", "package_declarator:sym<grammar>")
  debug_675:
    .return (rx602_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<grammar>"  :nsentry("!PREFIX__package_declarator:sym<grammar>") :subid("140_1298325448.42642") :method
.annotate 'line', 4
    $P604 = self."!PREFIX__!subrule"("package_def", "grammar")
    new $P605, "ResizablePMCArray"
    push $P605, $P604
    .return ($P605)
.end


.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<role>"  :subid("141_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 303
    new $P612, "Undef"
    .lex "$*PACKAGE-SETUP", $P612
.annotate 'line', 304
    new $P613, "Undef"
    .lex "$*PKGDECL", $P613
.annotate 'line', 4
    .local string rx614_tgt
    .local int rx614_pos
    .local int rx614_off
    .local int rx614_eos
    .local int rx614_rep
    .local pmc rx614_cur
    .local pmc rx614_debug
    (rx614_cur, rx614_pos, rx614_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx614_cur
    .local pmc match
    .lex "$/", match
    length rx614_eos, rx614_tgt
    gt rx614_pos, rx614_eos, rx614_done
    set rx614_off, 0
    lt rx614_pos, 2, rx614_start
    sub rx614_off, rx614_pos, 1
    substr rx614_tgt, rx614_tgt, rx614_off
  rx614_start:
    eq $I10, 1, rx614_restart
    if_null rx614_debug, debug_676
    rx614_cur."!cursor_debug"("START", "package_declarator:sym<role>")
  debug_676:
    $I10 = self.'from'()
    ne $I10, -1, rxscan618_done
    goto rxscan618_scan
  rxscan618_loop:
    (rx614_pos) = rx614_cur."from"()
    inc rx614_pos
    rx614_cur."!cursor_from"(rx614_pos)
    ge rx614_pos, rx614_eos, rxscan618_done
  rxscan618_scan:
    set_addr $I10, rxscan618_loop
    rx614_cur."!mark_push"(0, rx614_pos, $I10)
  rxscan618_done:
.annotate 'line', 303
    rx614_cur."!cursor_pos"(rx614_pos)
    get_hll_global $P619, ["PAST"], "Stmts"
    $P620 = $P619."new"()
    store_lex "$*PACKAGE-SETUP", $P620
.annotate 'line', 304
    rx614_cur."!cursor_pos"(rx614_pos)
    new $P621, "String"
    assign $P621, "role"
    store_lex "$*PKGDECL", $P621
.annotate 'line', 305
  # rx subcapture "sym"
    set_addr $I10, rxcap_622_fail
    rx614_cur."!mark_push"(0, rx614_pos, $I10)
  # rx literal  "role"
    add $I11, rx614_pos, 4
    gt $I11, rx614_eos, rx614_fail
    sub $I11, rx614_pos, rx614_off
    substr $S10, rx614_tgt, $I11, 4
    ne $S10, "role", rx614_fail
    add rx614_pos, 4
    set_addr $I10, rxcap_622_fail
    ($I12, $I11) = rx614_cur."!mark_peek"($I10)
    rx614_cur."!cursor_pos"($I11)
    ($P10) = rx614_cur."!cursor_start"()
    $P10."!cursor_pass"(rx614_pos, "")
    rx614_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_622_done
  rxcap_622_fail:
    goto rx614_fail
  rxcap_622_done:
  # rx subrule "package_def" subtype=capture negate=
    rx614_cur."!cursor_pos"(rx614_pos)
    $P10 = rx614_cur."package_def"()
    unless $P10, rx614_fail
    rx614_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx614_pos = $P10."pos"()
.annotate 'line', 302
  # rx pass
    rx614_cur."!cursor_pass"(rx614_pos, "package_declarator:sym<role>")
    if_null rx614_debug, debug_677
    rx614_cur."!cursor_debug"("PASS", "package_declarator:sym<role>", " at pos=", rx614_pos)
  debug_677:
    .return (rx614_cur)
  rx614_restart:
.annotate 'line', 4
    if_null rx614_debug, debug_678
    rx614_cur."!cursor_debug"("NEXT", "package_declarator:sym<role>")
  debug_678:
  rx614_fail:
    (rx614_rep, rx614_pos, $I10, $P10) = rx614_cur."!mark_fail"(0)
    lt rx614_pos, -1, rx614_done
    eq rx614_pos, -1, rx614_fail
    jump $I10
  rx614_done:
    rx614_cur."!cursor_fail"()
    if_null rx614_debug, debug_679
    rx614_cur."!cursor_debug"("FAIL", "package_declarator:sym<role>")
  debug_679:
    .return (rx614_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<role>"  :nsentry("!PREFIX__package_declarator:sym<role>") :subid("142_1298325448.42642") :method
.annotate 'line', 4
    $P616 = self."!PREFIX__!subrule"("package_def", "role")
    new $P617, "ResizablePMCArray"
    push $P617, $P616
    .return ($P617)
.end


.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<native>"  :subid("143_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 308
    new $P624, "Undef"
    .lex "$*PACKAGE-SETUP", $P624
.annotate 'line', 309
    new $P625, "Undef"
    .lex "$*PKGDECL", $P625
.annotate 'line', 4
    .local string rx626_tgt
    .local int rx626_pos
    .local int rx626_off
    .local int rx626_eos
    .local int rx626_rep
    .local pmc rx626_cur
    .local pmc rx626_debug
    (rx626_cur, rx626_pos, rx626_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx626_cur
    .local pmc match
    .lex "$/", match
    length rx626_eos, rx626_tgt
    gt rx626_pos, rx626_eos, rx626_done
    set rx626_off, 0
    lt rx626_pos, 2, rx626_start
    sub rx626_off, rx626_pos, 1
    substr rx626_tgt, rx626_tgt, rx626_off
  rx626_start:
    eq $I10, 1, rx626_restart
    if_null rx626_debug, debug_680
    rx626_cur."!cursor_debug"("START", "package_declarator:sym<native>")
  debug_680:
    $I10 = self.'from'()
    ne $I10, -1, rxscan630_done
    goto rxscan630_scan
  rxscan630_loop:
    (rx626_pos) = rx626_cur."from"()
    inc rx626_pos
    rx626_cur."!cursor_from"(rx626_pos)
    ge rx626_pos, rx626_eos, rxscan630_done
  rxscan630_scan:
    set_addr $I10, rxscan630_loop
    rx626_cur."!mark_push"(0, rx626_pos, $I10)
  rxscan630_done:
.annotate 'line', 308
    rx626_cur."!cursor_pos"(rx626_pos)
    get_hll_global $P631, ["PAST"], "Stmts"
    $P632 = $P631."new"()
    store_lex "$*PACKAGE-SETUP", $P632
.annotate 'line', 309
    rx626_cur."!cursor_pos"(rx626_pos)
    new $P633, "String"
    assign $P633, "native"
    store_lex "$*PKGDECL", $P633
.annotate 'line', 310
  # rx subcapture "sym"
    set_addr $I10, rxcap_634_fail
    rx626_cur."!mark_push"(0, rx626_pos, $I10)
  # rx literal  "native"
    add $I11, rx626_pos, 6
    gt $I11, rx626_eos, rx626_fail
    sub $I11, rx626_pos, rx626_off
    substr $S10, rx626_tgt, $I11, 6
    ne $S10, "native", rx626_fail
    add rx626_pos, 6
    set_addr $I10, rxcap_634_fail
    ($I12, $I11) = rx626_cur."!mark_peek"($I10)
    rx626_cur."!cursor_pos"($I11)
    ($P10) = rx626_cur."!cursor_start"()
    $P10."!cursor_pass"(rx626_pos, "")
    rx626_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_634_done
  rxcap_634_fail:
    goto rx626_fail
  rxcap_634_done:
  # rx subrule "package_def" subtype=capture negate=
    rx626_cur."!cursor_pos"(rx626_pos)
    $P10 = rx626_cur."package_def"()
    unless $P10, rx626_fail
    rx626_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx626_pos = $P10."pos"()
.annotate 'line', 307
  # rx pass
    rx626_cur."!cursor_pass"(rx626_pos, "package_declarator:sym<native>")
    if_null rx626_debug, debug_681
    rx626_cur."!cursor_debug"("PASS", "package_declarator:sym<native>", " at pos=", rx626_pos)
  debug_681:
    .return (rx626_cur)
  rx626_restart:
.annotate 'line', 4
    if_null rx626_debug, debug_682
    rx626_cur."!cursor_debug"("NEXT", "package_declarator:sym<native>")
  debug_682:
  rx626_fail:
    (rx626_rep, rx626_pos, $I10, $P10) = rx626_cur."!mark_fail"(0)
    lt rx626_pos, -1, rx626_done
    eq rx626_pos, -1, rx626_fail
    jump $I10
  rx626_done:
    rx626_cur."!cursor_fail"()
    if_null rx626_debug, debug_683
    rx626_cur."!cursor_debug"("FAIL", "package_declarator:sym<native>")
  debug_683:
    .return (rx626_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<native>"  :nsentry("!PREFIX__package_declarator:sym<native>") :subid("144_1298325448.42642") :method
.annotate 'line', 4
    $P628 = self."!PREFIX__!subrule"("package_def", "native")
    new $P629, "ResizablePMCArray"
    push $P629, $P628
    .return ($P629)
.end


.namespace ["NQP";"Grammar"]
.sub "package_def"  :subid("145_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx636_tgt
    .local int rx636_pos
    .local int rx636_off
    .local int rx636_eos
    .local int rx636_rep
    .local pmc rx636_cur
    .local pmc rx636_debug
    (rx636_cur, rx636_pos, rx636_tgt, $I10) = self."!cursor_start"()
    rx636_cur."!cursor_caparray"("repr", "parent", "role")
    .lex unicode:"$\x{a2}", rx636_cur
    .local pmc match
    .lex "$/", match
    length rx636_eos, rx636_tgt
    gt rx636_pos, rx636_eos, rx636_done
    set rx636_off, 0
    lt rx636_pos, 2, rx636_start
    sub rx636_off, rx636_pos, 1
    substr rx636_tgt, rx636_tgt, rx636_off
  rx636_start:
    eq $I10, 1, rx636_restart
    if_null rx636_debug, debug_684
    rx636_cur."!cursor_debug"("START", "package_def")
  debug_684:
    $I10 = self.'from'()
    ne $I10, -1, rxscan640_done
    goto rxscan640_scan
  rxscan640_loop:
    (rx636_pos) = rx636_cur."from"()
    inc rx636_pos
    rx636_cur."!cursor_from"(rx636_pos)
    ge rx636_pos, rx636_eos, rxscan640_done
  rxscan640_scan:
    set_addr $I10, rxscan640_loop
    rx636_cur."!mark_push"(0, rx636_pos, $I10)
  rxscan640_done:
.annotate 'line', 313
  # rx subrule "ws" subtype=method negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."ws"()
    unless $P10, rx636_fail
    rx636_pos = $P10."pos"()
.annotate 'line', 314
  # rx subrule "name" subtype=capture negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."name"()
    unless $P10, rx636_fail
    rx636_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx636_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."ws"()
    unless $P10, rx636_fail
    rx636_pos = $P10."pos"()
.annotate 'line', 315
  # rx rxquantr643 ** 0..1
    set_addr $I10, rxquantr643_done
    rx636_cur."!mark_push"(0, rx636_pos, $I10)
  rxquantr643_loop:
  # rx subrule "ws" subtype=method negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."ws"()
    unless $P10, rx636_fail
    rx636_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx636_pos, 2
    gt $I11, rx636_eos, rx636_fail
    sub $I11, rx636_pos, rx636_off
    substr $S10, rx636_tgt, $I11, 2
    ne $S10, "is", rx636_fail
    add rx636_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."ws"()
    unless $P10, rx636_fail
    rx636_pos = $P10."pos"()
  # rx literal  "repr("
    add $I11, rx636_pos, 5
    gt $I11, rx636_eos, rx636_fail
    sub $I11, rx636_pos, rx636_off
    substr $S10, rx636_tgt, $I11, 5
    ne $S10, "repr(", rx636_fail
    add rx636_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."ws"()
    unless $P10, rx636_fail
    rx636_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."quote_EXPR"()
    unless $P10, rx636_fail
    rx636_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("repr")
    rx636_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."ws"()
    unless $P10, rx636_fail
    rx636_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx636_pos, 1
    gt $I11, rx636_eos, rx636_fail
    sub $I11, rx636_pos, rx636_off
    ord $I11, rx636_tgt, $I11
    ne $I11, 41, rx636_fail
    add rx636_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."ws"()
    unless $P10, rx636_fail
    rx636_pos = $P10."pos"()
    set_addr $I10, rxquantr643_done
    (rx636_rep) = rx636_cur."!mark_commit"($I10)
  rxquantr643_done:
  # rx subrule "ws" subtype=method negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."ws"()
    unless $P10, rx636_fail
    rx636_pos = $P10."pos"()
.annotate 'line', 316
  # rx rxquantr650 ** 0..1
    set_addr $I10, rxquantr650_done
    rx636_cur."!mark_push"(0, rx636_pos, $I10)
  rxquantr650_loop:
  # rx subrule "ws" subtype=method negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."ws"()
    unless $P10, rx636_fail
    rx636_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx636_pos, 2
    gt $I11, rx636_eos, rx636_fail
    sub $I11, rx636_pos, rx636_off
    substr $S10, rx636_tgt, $I11, 2
    ne $S10, "is", rx636_fail
    add rx636_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."ws"()
    unless $P10, rx636_fail
    rx636_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."name"()
    unless $P10, rx636_fail
    rx636_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parent")
    rx636_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."ws"()
    unless $P10, rx636_fail
    rx636_pos = $P10."pos"()
    set_addr $I10, rxquantr650_done
    (rx636_rep) = rx636_cur."!mark_commit"($I10)
  rxquantr650_done:
  # rx subrule "ws" subtype=method negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."ws"()
    unless $P10, rx636_fail
    rx636_pos = $P10."pos"()
.annotate 'line', 317
  # rx rxquantr655 ** 0..*
    set_addr $I10, rxquantr655_done
    rx636_cur."!mark_push"(0, rx636_pos, $I10)
  rxquantr655_loop:
  # rx subrule "ws" subtype=method negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."ws"()
    unless $P10, rx636_fail
    rx636_pos = $P10."pos"()
  # rx literal  "does"
    add $I11, rx636_pos, 4
    gt $I11, rx636_eos, rx636_fail
    sub $I11, rx636_pos, rx636_off
    substr $S10, rx636_tgt, $I11, 4
    ne $S10, "does", rx636_fail
    add rx636_pos, 4
  # rx subrule "ws" subtype=method negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."ws"()
    unless $P10, rx636_fail
    rx636_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."name"()
    unless $P10, rx636_fail
    rx636_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("role")
    rx636_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."ws"()
    unless $P10, rx636_fail
    rx636_pos = $P10."pos"()
    set_addr $I10, rxquantr655_done
    (rx636_rep) = rx636_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr655_done
    rx636_cur."!mark_push"(rx636_rep, rx636_pos, $I10)
    goto rxquantr655_loop
  rxquantr655_done:
  # rx subrule "ws" subtype=method negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."ws"()
    unless $P10, rx636_fail
    rx636_pos = $P10."pos"()
  alt660_0:
.annotate 'line', 318
    set_addr $I10, alt660_1
    rx636_cur."!mark_push"(0, rx636_pos, $I10)
.annotate 'line', 319
  # rx subrule "ws" subtype=method negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."ws"()
    unless $P10, rx636_fail
    rx636_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx636_pos, 1
    gt $I11, rx636_eos, rx636_fail
    sub $I11, rx636_pos, rx636_off
    ord $I11, rx636_tgt, $I11
    ne $I11, 59, rx636_fail
    add rx636_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."ws"()
    unless $P10, rx636_fail
    rx636_pos = $P10."pos"()
  # rx subrule "comp_unit" subtype=capture negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."comp_unit"()
    unless $P10, rx636_fail
    rx636_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("comp_unit")
    rx636_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."ws"()
    unless $P10, rx636_fail
    rx636_pos = $P10."pos"()
    goto alt660_end
  alt660_1:
    set_addr $I10, alt660_2
    rx636_cur."!mark_push"(0, rx636_pos, $I10)
.annotate 'line', 320
  # rx subrule "ws" subtype=method negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."ws"()
    unless $P10, rx636_fail
    rx636_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx636_pos, rx636_off
    substr $S10, rx636_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx636_fail
  # rx subrule "ws" subtype=method negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."ws"()
    unless $P10, rx636_fail
    rx636_pos = $P10."pos"()
  # rx subrule "block" subtype=capture negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."block"()
    unless $P10, rx636_fail
    rx636_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx636_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."ws"()
    unless $P10, rx636_fail
    rx636_pos = $P10."pos"()
    goto alt660_end
  alt660_2:
.annotate 'line', 321
  # rx subrule "ws" subtype=method negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."ws"()
    unless $P10, rx636_fail
    rx636_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."panic"("Malformed package declaration")
    unless $P10, rx636_fail
    rx636_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."ws"()
    unless $P10, rx636_fail
    rx636_pos = $P10."pos"()
  alt660_end:
.annotate 'line', 322
  # rx subrule "ws" subtype=method negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."ws"()
    unless $P10, rx636_fail
    rx636_pos = $P10."pos"()
.annotate 'line', 313
  # rx pass
    rx636_cur."!cursor_pass"(rx636_pos, "package_def")
    if_null rx636_debug, debug_685
    rx636_cur."!cursor_debug"("PASS", "package_def", " at pos=", rx636_pos)
  debug_685:
    .return (rx636_cur)
  rx636_restart:
.annotate 'line', 4
    if_null rx636_debug, debug_686
    rx636_cur."!cursor_debug"("NEXT", "package_def")
  debug_686:
  rx636_fail:
    (rx636_rep, rx636_pos, $I10, $P10) = rx636_cur."!mark_fail"(0)
    lt rx636_pos, -1, rx636_done
    eq rx636_pos, -1, rx636_fail
    jump $I10
  rx636_done:
    rx636_cur."!cursor_fail"()
    if_null rx636_debug, debug_687
    rx636_cur."!cursor_debug"("FAIL", "package_def")
  debug_687:
    .return (rx636_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_def"  :nsentry("!PREFIX__package_def") :subid("146_1298325448.42642") :method
.annotate 'line', 4
    $P638 = self."!PREFIX__!subrule"("ws", "")
    new $P639, "ResizablePMCArray"
    push $P639, $P638
    .return ($P639)
.end


.namespace ["NQP";"Grammar"]
.sub "scope_declarator"  :subid("147_1298325448.42642")
    .param pmc param_671
.annotate 'line', 325
    .lex "self", param_671
    $P672 = param_671."!protoregex"("scope_declarator")
    .return ($P672)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator"  :subid("148_1298325448.42642")
    .param pmc param_674
.annotate 'line', 325
    .lex "self", param_674
    $P675 = param_674."!PREFIX__!protoregex"("scope_declarator")
    .return ($P675)
.end


.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<my>"  :subid("149_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx677_tgt
    .local int rx677_pos
    .local int rx677_off
    .local int rx677_eos
    .local int rx677_rep
    .local pmc rx677_cur
    .local pmc rx677_debug
    (rx677_cur, rx677_pos, rx677_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx677_cur
    .local pmc match
    .lex "$/", match
    length rx677_eos, rx677_tgt
    gt rx677_pos, rx677_eos, rx677_done
    set rx677_off, 0
    lt rx677_pos, 2, rx677_start
    sub rx677_off, rx677_pos, 1
    substr rx677_tgt, rx677_tgt, rx677_off
  rx677_start:
    eq $I10, 1, rx677_restart
    if_null rx677_debug, debug_688
    rx677_cur."!cursor_debug"("START", "scope_declarator:sym<my>")
  debug_688:
    $I10 = self.'from'()
    ne $I10, -1, rxscan681_done
    goto rxscan681_scan
  rxscan681_loop:
    (rx677_pos) = rx677_cur."from"()
    inc rx677_pos
    rx677_cur."!cursor_from"(rx677_pos)
    ge rx677_pos, rx677_eos, rxscan681_done
  rxscan681_scan:
    set_addr $I10, rxscan681_loop
    rx677_cur."!mark_push"(0, rx677_pos, $I10)
  rxscan681_done:
.annotate 'line', 326
  # rx subcapture "sym"
    set_addr $I10, rxcap_682_fail
    rx677_cur."!mark_push"(0, rx677_pos, $I10)
  # rx literal  "my"
    add $I11, rx677_pos, 2
    gt $I11, rx677_eos, rx677_fail
    sub $I11, rx677_pos, rx677_off
    substr $S10, rx677_tgt, $I11, 2
    ne $S10, "my", rx677_fail
    add rx677_pos, 2
    set_addr $I10, rxcap_682_fail
    ($I12, $I11) = rx677_cur."!mark_peek"($I10)
    rx677_cur."!cursor_pos"($I11)
    ($P10) = rx677_cur."!cursor_start"()
    $P10."!cursor_pass"(rx677_pos, "")
    rx677_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_682_done
  rxcap_682_fail:
    goto rx677_fail
  rxcap_682_done:
  # rx subrule "scoped" subtype=capture negate=
    rx677_cur."!cursor_pos"(rx677_pos)
    $P10 = rx677_cur."scoped"("my")
    unless $P10, rx677_fail
    rx677_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx677_pos = $P10."pos"()
  # rx pass
    rx677_cur."!cursor_pass"(rx677_pos, "scope_declarator:sym<my>")
    if_null rx677_debug, debug_689
    rx677_cur."!cursor_debug"("PASS", "scope_declarator:sym<my>", " at pos=", rx677_pos)
  debug_689:
    .return (rx677_cur)
  rx677_restart:
.annotate 'line', 4
    if_null rx677_debug, debug_690
    rx677_cur."!cursor_debug"("NEXT", "scope_declarator:sym<my>")
  debug_690:
  rx677_fail:
    (rx677_rep, rx677_pos, $I10, $P10) = rx677_cur."!mark_fail"(0)
    lt rx677_pos, -1, rx677_done
    eq rx677_pos, -1, rx677_fail
    jump $I10
  rx677_done:
    rx677_cur."!cursor_fail"()
    if_null rx677_debug, debug_691
    rx677_cur."!cursor_debug"("FAIL", "scope_declarator:sym<my>")
  debug_691:
    .return (rx677_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<my>"  :nsentry("!PREFIX__scope_declarator:sym<my>") :subid("150_1298325448.42642") :method
.annotate 'line', 4
    $P679 = self."!PREFIX__!subrule"("scoped", "my")
    new $P680, "ResizablePMCArray"
    push $P680, $P679
    .return ($P680)
.end


.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<our>"  :subid("151_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx684_tgt
    .local int rx684_pos
    .local int rx684_off
    .local int rx684_eos
    .local int rx684_rep
    .local pmc rx684_cur
    .local pmc rx684_debug
    (rx684_cur, rx684_pos, rx684_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx684_cur
    .local pmc match
    .lex "$/", match
    length rx684_eos, rx684_tgt
    gt rx684_pos, rx684_eos, rx684_done
    set rx684_off, 0
    lt rx684_pos, 2, rx684_start
    sub rx684_off, rx684_pos, 1
    substr rx684_tgt, rx684_tgt, rx684_off
  rx684_start:
    eq $I10, 1, rx684_restart
    if_null rx684_debug, debug_692
    rx684_cur."!cursor_debug"("START", "scope_declarator:sym<our>")
  debug_692:
    $I10 = self.'from'()
    ne $I10, -1, rxscan688_done
    goto rxscan688_scan
  rxscan688_loop:
    (rx684_pos) = rx684_cur."from"()
    inc rx684_pos
    rx684_cur."!cursor_from"(rx684_pos)
    ge rx684_pos, rx684_eos, rxscan688_done
  rxscan688_scan:
    set_addr $I10, rxscan688_loop
    rx684_cur."!mark_push"(0, rx684_pos, $I10)
  rxscan688_done:
.annotate 'line', 327
  # rx subcapture "sym"
    set_addr $I10, rxcap_689_fail
    rx684_cur."!mark_push"(0, rx684_pos, $I10)
  # rx literal  "our"
    add $I11, rx684_pos, 3
    gt $I11, rx684_eos, rx684_fail
    sub $I11, rx684_pos, rx684_off
    substr $S10, rx684_tgt, $I11, 3
    ne $S10, "our", rx684_fail
    add rx684_pos, 3
    set_addr $I10, rxcap_689_fail
    ($I12, $I11) = rx684_cur."!mark_peek"($I10)
    rx684_cur."!cursor_pos"($I11)
    ($P10) = rx684_cur."!cursor_start"()
    $P10."!cursor_pass"(rx684_pos, "")
    rx684_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_689_done
  rxcap_689_fail:
    goto rx684_fail
  rxcap_689_done:
  # rx subrule "scoped" subtype=capture negate=
    rx684_cur."!cursor_pos"(rx684_pos)
    $P10 = rx684_cur."scoped"("our")
    unless $P10, rx684_fail
    rx684_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx684_pos = $P10."pos"()
  # rx pass
    rx684_cur."!cursor_pass"(rx684_pos, "scope_declarator:sym<our>")
    if_null rx684_debug, debug_693
    rx684_cur."!cursor_debug"("PASS", "scope_declarator:sym<our>", " at pos=", rx684_pos)
  debug_693:
    .return (rx684_cur)
  rx684_restart:
.annotate 'line', 4
    if_null rx684_debug, debug_694
    rx684_cur."!cursor_debug"("NEXT", "scope_declarator:sym<our>")
  debug_694:
  rx684_fail:
    (rx684_rep, rx684_pos, $I10, $P10) = rx684_cur."!mark_fail"(0)
    lt rx684_pos, -1, rx684_done
    eq rx684_pos, -1, rx684_fail
    jump $I10
  rx684_done:
    rx684_cur."!cursor_fail"()
    if_null rx684_debug, debug_695
    rx684_cur."!cursor_debug"("FAIL", "scope_declarator:sym<our>")
  debug_695:
    .return (rx684_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<our>"  :nsentry("!PREFIX__scope_declarator:sym<our>") :subid("152_1298325448.42642") :method
.annotate 'line', 4
    $P686 = self."!PREFIX__!subrule"("scoped", "our")
    new $P687, "ResizablePMCArray"
    push $P687, $P686
    .return ($P687)
.end


.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<has>"  :subid("153_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx691_tgt
    .local int rx691_pos
    .local int rx691_off
    .local int rx691_eos
    .local int rx691_rep
    .local pmc rx691_cur
    .local pmc rx691_debug
    (rx691_cur, rx691_pos, rx691_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx691_cur
    .local pmc match
    .lex "$/", match
    length rx691_eos, rx691_tgt
    gt rx691_pos, rx691_eos, rx691_done
    set rx691_off, 0
    lt rx691_pos, 2, rx691_start
    sub rx691_off, rx691_pos, 1
    substr rx691_tgt, rx691_tgt, rx691_off
  rx691_start:
    eq $I10, 1, rx691_restart
    if_null rx691_debug, debug_696
    rx691_cur."!cursor_debug"("START", "scope_declarator:sym<has>")
  debug_696:
    $I10 = self.'from'()
    ne $I10, -1, rxscan695_done
    goto rxscan695_scan
  rxscan695_loop:
    (rx691_pos) = rx691_cur."from"()
    inc rx691_pos
    rx691_cur."!cursor_from"(rx691_pos)
    ge rx691_pos, rx691_eos, rxscan695_done
  rxscan695_scan:
    set_addr $I10, rxscan695_loop
    rx691_cur."!mark_push"(0, rx691_pos, $I10)
  rxscan695_done:
.annotate 'line', 328
  # rx subcapture "sym"
    set_addr $I10, rxcap_696_fail
    rx691_cur."!mark_push"(0, rx691_pos, $I10)
  # rx literal  "has"
    add $I11, rx691_pos, 3
    gt $I11, rx691_eos, rx691_fail
    sub $I11, rx691_pos, rx691_off
    substr $S10, rx691_tgt, $I11, 3
    ne $S10, "has", rx691_fail
    add rx691_pos, 3
    set_addr $I10, rxcap_696_fail
    ($I12, $I11) = rx691_cur."!mark_peek"($I10)
    rx691_cur."!cursor_pos"($I11)
    ($P10) = rx691_cur."!cursor_start"()
    $P10."!cursor_pass"(rx691_pos, "")
    rx691_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_696_done
  rxcap_696_fail:
    goto rx691_fail
  rxcap_696_done:
  # rx subrule "scoped" subtype=capture negate=
    rx691_cur."!cursor_pos"(rx691_pos)
    $P10 = rx691_cur."scoped"("has")
    unless $P10, rx691_fail
    rx691_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx691_pos = $P10."pos"()
  # rx pass
    rx691_cur."!cursor_pass"(rx691_pos, "scope_declarator:sym<has>")
    if_null rx691_debug, debug_697
    rx691_cur."!cursor_debug"("PASS", "scope_declarator:sym<has>", " at pos=", rx691_pos)
  debug_697:
    .return (rx691_cur)
  rx691_restart:
.annotate 'line', 4
    if_null rx691_debug, debug_698
    rx691_cur."!cursor_debug"("NEXT", "scope_declarator:sym<has>")
  debug_698:
  rx691_fail:
    (rx691_rep, rx691_pos, $I10, $P10) = rx691_cur."!mark_fail"(0)
    lt rx691_pos, -1, rx691_done
    eq rx691_pos, -1, rx691_fail
    jump $I10
  rx691_done:
    rx691_cur."!cursor_fail"()
    if_null rx691_debug, debug_699
    rx691_cur."!cursor_debug"("FAIL", "scope_declarator:sym<has>")
  debug_699:
    .return (rx691_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<has>"  :nsentry("!PREFIX__scope_declarator:sym<has>") :subid("154_1298325448.42642") :method
.annotate 'line', 4
    $P693 = self."!PREFIX__!subrule"("scoped", "has")
    new $P694, "ResizablePMCArray"
    push $P694, $P693
    .return ($P694)
.end


.namespace ["NQP";"Grammar"]
.sub "scoped"  :subid("155_1298325448.42642") :method :outer("11_1298325448.42642")
    .param pmc param_698
.annotate 'line', 330
    .lex "$*SCOPE", param_698
.annotate 'line', 4
    .local string rx699_tgt
    .local int rx699_pos
    .local int rx699_off
    .local int rx699_eos
    .local int rx699_rep
    .local pmc rx699_cur
    .local pmc rx699_debug
    (rx699_cur, rx699_pos, rx699_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx699_cur
    .local pmc match
    .lex "$/", match
    length rx699_eos, rx699_tgt
    gt rx699_pos, rx699_eos, rx699_done
    set rx699_off, 0
    lt rx699_pos, 2, rx699_start
    sub rx699_off, rx699_pos, 1
    substr rx699_tgt, rx699_tgt, rx699_off
  rx699_start:
    eq $I10, 1, rx699_restart
    if_null rx699_debug, debug_700
    rx699_cur."!cursor_debug"("START", "scoped")
  debug_700:
    $I10 = self.'from'()
    ne $I10, -1, rxscan704_done
    goto rxscan704_scan
  rxscan704_loop:
    (rx699_pos) = rx699_cur."from"()
    inc rx699_pos
    rx699_cur."!cursor_from"(rx699_pos)
    ge rx699_pos, rx699_eos, rxscan704_done
  rxscan704_scan:
    set_addr $I10, rxscan704_loop
    rx699_cur."!mark_push"(0, rx699_pos, $I10)
  rxscan704_done:
  alt705_0:
.annotate 'line', 330
    set_addr $I10, alt705_1
    rx699_cur."!mark_push"(0, rx699_pos, $I10)
.annotate 'line', 331
  # rx subrule "ws" subtype=method negate=
    rx699_cur."!cursor_pos"(rx699_pos)
    $P10 = rx699_cur."ws"()
    unless $P10, rx699_fail
    rx699_pos = $P10."pos"()
  # rx subrule "declarator" subtype=capture negate=
    rx699_cur."!cursor_pos"(rx699_pos)
    $P10 = rx699_cur."declarator"()
    unless $P10, rx699_fail
    rx699_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx699_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx699_cur."!cursor_pos"(rx699_pos)
    $P10 = rx699_cur."ws"()
    unless $P10, rx699_fail
    rx699_pos = $P10."pos"()
    goto alt705_end
  alt705_1:
.annotate 'line', 332
  # rx subrule "ws" subtype=method negate=
    rx699_cur."!cursor_pos"(rx699_pos)
    $P10 = rx699_cur."ws"()
    unless $P10, rx699_fail
    rx699_pos = $P10."pos"()
  # rx subrule "multi_declarator" subtype=capture negate=
    rx699_cur."!cursor_pos"(rx699_pos)
    $P10 = rx699_cur."multi_declarator"()
    unless $P10, rx699_fail
    rx699_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx699_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx699_cur."!cursor_pos"(rx699_pos)
    $P10 = rx699_cur."ws"()
    unless $P10, rx699_fail
    rx699_pos = $P10."pos"()
  alt705_end:
.annotate 'line', 330
  # rx pass
    rx699_cur."!cursor_pass"(rx699_pos, "scoped")
    if_null rx699_debug, debug_701
    rx699_cur."!cursor_debug"("PASS", "scoped", " at pos=", rx699_pos)
  debug_701:
    .return (rx699_cur)
  rx699_restart:
.annotate 'line', 4
    if_null rx699_debug, debug_702
    rx699_cur."!cursor_debug"("NEXT", "scoped")
  debug_702:
  rx699_fail:
    (rx699_rep, rx699_pos, $I10, $P10) = rx699_cur."!mark_fail"(0)
    lt rx699_pos, -1, rx699_done
    eq rx699_pos, -1, rx699_fail
    jump $I10
  rx699_done:
    rx699_cur."!cursor_fail"()
    if_null rx699_debug, debug_703
    rx699_cur."!cursor_debug"("FAIL", "scoped")
  debug_703:
    .return (rx699_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scoped"  :nsentry("!PREFIX__scoped") :subid("156_1298325448.42642") :method
.annotate 'line', 4
    $P701 = self."!PREFIX__!subrule"("ws", "")
    $P702 = self."!PREFIX__!subrule"("ws", "")
    new $P703, "ResizablePMCArray"
    push $P703, $P701
    push $P703, $P702
    .return ($P703)
.end


.namespace ["NQP";"Grammar"]
.sub "typename"  :subid("157_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx711_tgt
    .local int rx711_pos
    .local int rx711_off
    .local int rx711_eos
    .local int rx711_rep
    .local pmc rx711_cur
    .local pmc rx711_debug
    (rx711_cur, rx711_pos, rx711_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx711_cur
    .local pmc match
    .lex "$/", match
    length rx711_eos, rx711_tgt
    gt rx711_pos, rx711_eos, rx711_done
    set rx711_off, 0
    lt rx711_pos, 2, rx711_start
    sub rx711_off, rx711_pos, 1
    substr rx711_tgt, rx711_tgt, rx711_off
  rx711_start:
    eq $I10, 1, rx711_restart
    if_null rx711_debug, debug_704
    rx711_cur."!cursor_debug"("START", "typename")
  debug_704:
    $I10 = self.'from'()
    ne $I10, -1, rxscan715_done
    goto rxscan715_scan
  rxscan715_loop:
    (rx711_pos) = rx711_cur."from"()
    inc rx711_pos
    rx711_cur."!cursor_from"(rx711_pos)
    ge rx711_pos, rx711_eos, rxscan715_done
  rxscan715_scan:
    set_addr $I10, rxscan715_loop
    rx711_cur."!mark_push"(0, rx711_pos, $I10)
  rxscan715_done:
.annotate 'line', 335
  # rx subrule "name" subtype=capture negate=
    rx711_cur."!cursor_pos"(rx711_pos)
    $P10 = rx711_cur."name"()
    unless $P10, rx711_fail
    rx711_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx711_pos = $P10."pos"()
  # rx pass
    rx711_cur."!cursor_pass"(rx711_pos, "typename")
    if_null rx711_debug, debug_705
    rx711_cur."!cursor_debug"("PASS", "typename", " at pos=", rx711_pos)
  debug_705:
    .return (rx711_cur)
  rx711_restart:
.annotate 'line', 4
    if_null rx711_debug, debug_706
    rx711_cur."!cursor_debug"("NEXT", "typename")
  debug_706:
  rx711_fail:
    (rx711_rep, rx711_pos, $I10, $P10) = rx711_cur."!mark_fail"(0)
    lt rx711_pos, -1, rx711_done
    eq rx711_pos, -1, rx711_fail
    jump $I10
  rx711_done:
    rx711_cur."!cursor_fail"()
    if_null rx711_debug, debug_707
    rx711_cur."!cursor_debug"("FAIL", "typename")
  debug_707:
    .return (rx711_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__typename"  :nsentry("!PREFIX__typename") :subid("158_1298325448.42642") :method
.annotate 'line', 4
    $P713 = self."!PREFIX__!subrule"("name", "")
    new $P714, "ResizablePMCArray"
    push $P714, $P713
    .return ($P714)
.end


.namespace ["NQP";"Grammar"]
.sub "declarator"  :subid("159_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx717_tgt
    .local int rx717_pos
    .local int rx717_off
    .local int rx717_eos
    .local int rx717_rep
    .local pmc rx717_cur
    .local pmc rx717_debug
    (rx717_cur, rx717_pos, rx717_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx717_cur
    .local pmc match
    .lex "$/", match
    length rx717_eos, rx717_tgt
    gt rx717_pos, rx717_eos, rx717_done
    set rx717_off, 0
    lt rx717_pos, 2, rx717_start
    sub rx717_off, rx717_pos, 1
    substr rx717_tgt, rx717_tgt, rx717_off
  rx717_start:
    eq $I10, 1, rx717_restart
    if_null rx717_debug, debug_708
    rx717_cur."!cursor_debug"("START", "declarator")
  debug_708:
    $I10 = self.'from'()
    ne $I10, -1, rxscan722_done
    goto rxscan722_scan
  rxscan722_loop:
    (rx717_pos) = rx717_cur."from"()
    inc rx717_pos
    rx717_cur."!cursor_from"(rx717_pos)
    ge rx717_pos, rx717_eos, rxscan722_done
  rxscan722_scan:
    set_addr $I10, rxscan722_loop
    rx717_cur."!mark_push"(0, rx717_pos, $I10)
  rxscan722_done:
  alt723_0:
.annotate 'line', 337
    set_addr $I10, alt723_1
    rx717_cur."!mark_push"(0, rx717_pos, $I10)
.annotate 'line', 338
  # rx subrule "variable_declarator" subtype=capture negate=
    rx717_cur."!cursor_pos"(rx717_pos)
    $P10 = rx717_cur."variable_declarator"()
    unless $P10, rx717_fail
    rx717_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable_declarator")
    rx717_pos = $P10."pos"()
    goto alt723_end
  alt723_1:
.annotate 'line', 339
  # rx subrule "routine_declarator" subtype=capture negate=
    rx717_cur."!cursor_pos"(rx717_pos)
    $P10 = rx717_cur."routine_declarator"()
    unless $P10, rx717_fail
    rx717_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx717_pos = $P10."pos"()
  alt723_end:
.annotate 'line', 337
  # rx pass
    rx717_cur."!cursor_pass"(rx717_pos, "declarator")
    if_null rx717_debug, debug_709
    rx717_cur."!cursor_debug"("PASS", "declarator", " at pos=", rx717_pos)
  debug_709:
    .return (rx717_cur)
  rx717_restart:
.annotate 'line', 4
    if_null rx717_debug, debug_710
    rx717_cur."!cursor_debug"("NEXT", "declarator")
  debug_710:
  rx717_fail:
    (rx717_rep, rx717_pos, $I10, $P10) = rx717_cur."!mark_fail"(0)
    lt rx717_pos, -1, rx717_done
    eq rx717_pos, -1, rx717_fail
    jump $I10
  rx717_done:
    rx717_cur."!cursor_fail"()
    if_null rx717_debug, debug_711
    rx717_cur."!cursor_debug"("FAIL", "declarator")
  debug_711:
    .return (rx717_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__declarator"  :nsentry("!PREFIX__declarator") :subid("160_1298325448.42642") :method
.annotate 'line', 4
    $P719 = self."!PREFIX__!subrule"("routine_declarator", "")
    $P720 = self."!PREFIX__!subrule"("variable_declarator", "")
    new $P721, "ResizablePMCArray"
    push $P721, $P719
    push $P721, $P720
    .return ($P721)
.end


.namespace ["NQP";"Grammar"]
.sub "variable_declarator"  :subid("161_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx725_tgt
    .local int rx725_pos
    .local int rx725_off
    .local int rx725_eos
    .local int rx725_rep
    .local pmc rx725_cur
    .local pmc rx725_debug
    (rx725_cur, rx725_pos, rx725_tgt, $I10) = self."!cursor_start"()
    rx725_cur."!cursor_caparray"("typename")
    .lex unicode:"$\x{a2}", rx725_cur
    .local pmc match
    .lex "$/", match
    length rx725_eos, rx725_tgt
    gt rx725_pos, rx725_eos, rx725_done
    set rx725_off, 0
    lt rx725_pos, 2, rx725_start
    sub rx725_off, rx725_pos, 1
    substr rx725_tgt, rx725_tgt, rx725_off
  rx725_start:
    eq $I10, 1, rx725_restart
    if_null rx725_debug, debug_712
    rx725_cur."!cursor_debug"("START", "variable_declarator")
  debug_712:
    $I10 = self.'from'()
    ne $I10, -1, rxscan729_done
    goto rxscan729_scan
  rxscan729_loop:
    (rx725_pos) = rx725_cur."from"()
    inc rx725_pos
    rx725_cur."!cursor_from"(rx725_pos)
    ge rx725_pos, rx725_eos, rxscan729_done
  rxscan729_scan:
    set_addr $I10, rxscan729_loop
    rx725_cur."!mark_push"(0, rx725_pos, $I10)
  rxscan729_done:
.annotate 'line', 342
  # rx subrule "ws" subtype=method negate=
    rx725_cur."!cursor_pos"(rx725_pos)
    $P10 = rx725_cur."ws"()
    unless $P10, rx725_fail
    rx725_pos = $P10."pos"()
  # rx rxquantr731 ** 0..1
    set_addr $I10, rxquantr731_done
    rx725_cur."!mark_push"(0, rx725_pos, $I10)
  rxquantr731_loop:
  # rx subrule "typename" subtype=capture negate=
    rx725_cur."!cursor_pos"(rx725_pos)
    $P10 = rx725_cur."typename"()
    unless $P10, rx725_fail
    goto rxsubrule732_pass
  rxsubrule732_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx725_fail
  rxsubrule732_pass:
    set_addr $I10, rxsubrule732_back
    rx725_cur."!mark_push"(0, rx725_pos, $I10, $P10)
    $P10."!cursor_names"("typename")
    rx725_pos = $P10."pos"()
    set_addr $I10, rxquantr731_done
    (rx725_rep) = rx725_cur."!mark_commit"($I10)
  rxquantr731_done:
  # rx subrule "ws" subtype=method negate=
    rx725_cur."!cursor_pos"(rx725_pos)
    $P10 = rx725_cur."ws"()
    unless $P10, rx725_fail
    rx725_pos = $P10."pos"()
  # rx subrule "variable" subtype=capture negate=
    rx725_cur."!cursor_pos"(rx725_pos)
    $P10 = rx725_cur."variable"()
    unless $P10, rx725_fail
    rx725_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx725_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx725_cur."!cursor_pos"(rx725_pos)
    $P10 = rx725_cur."ws"()
    unless $P10, rx725_fail
    rx725_pos = $P10."pos"()
  # rx pass
    rx725_cur."!cursor_pass"(rx725_pos, "variable_declarator")
    if_null rx725_debug, debug_713
    rx725_cur."!cursor_debug"("PASS", "variable_declarator", " at pos=", rx725_pos)
  debug_713:
    .return (rx725_cur)
  rx725_restart:
.annotate 'line', 4
    if_null rx725_debug, debug_714
    rx725_cur."!cursor_debug"("NEXT", "variable_declarator")
  debug_714:
  rx725_fail:
    (rx725_rep, rx725_pos, $I10, $P10) = rx725_cur."!mark_fail"(0)
    lt rx725_pos, -1, rx725_done
    eq rx725_pos, -1, rx725_fail
    jump $I10
  rx725_done:
    rx725_cur."!cursor_fail"()
    if_null rx725_debug, debug_715
    rx725_cur."!cursor_debug"("FAIL", "variable_declarator")
  debug_715:
    .return (rx725_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable_declarator"  :nsentry("!PREFIX__variable_declarator") :subid("162_1298325448.42642") :method
.annotate 'line', 4
    $P727 = self."!PREFIX__!subrule"("ws", "")
    new $P728, "ResizablePMCArray"
    push $P728, $P727
    .return ($P728)
.end


.namespace ["NQP";"Grammar"]
.sub "routine_declarator"  :subid("163_1298325448.42642")
    .param pmc param_736
.annotate 'line', 344
    .lex "self", param_736
    $P737 = param_736."!protoregex"("routine_declarator")
    .return ($P737)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator"  :subid("164_1298325448.42642")
    .param pmc param_739
.annotate 'line', 344
    .lex "self", param_739
    $P740 = param_739."!PREFIX__!protoregex"("routine_declarator")
    .return ($P740)
.end


.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<sub>"  :subid("165_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx742_tgt
    .local int rx742_pos
    .local int rx742_off
    .local int rx742_eos
    .local int rx742_rep
    .local pmc rx742_cur
    .local pmc rx742_debug
    (rx742_cur, rx742_pos, rx742_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx742_cur
    .local pmc match
    .lex "$/", match
    length rx742_eos, rx742_tgt
    gt rx742_pos, rx742_eos, rx742_done
    set rx742_off, 0
    lt rx742_pos, 2, rx742_start
    sub rx742_off, rx742_pos, 1
    substr rx742_tgt, rx742_tgt, rx742_off
  rx742_start:
    eq $I10, 1, rx742_restart
    if_null rx742_debug, debug_716
    rx742_cur."!cursor_debug"("START", "routine_declarator:sym<sub>")
  debug_716:
    $I10 = self.'from'()
    ne $I10, -1, rxscan746_done
    goto rxscan746_scan
  rxscan746_loop:
    (rx742_pos) = rx742_cur."from"()
    inc rx742_pos
    rx742_cur."!cursor_from"(rx742_pos)
    ge rx742_pos, rx742_eos, rxscan746_done
  rxscan746_scan:
    set_addr $I10, rxscan746_loop
    rx742_cur."!mark_push"(0, rx742_pos, $I10)
  rxscan746_done:
.annotate 'line', 345
  # rx subcapture "sym"
    set_addr $I10, rxcap_747_fail
    rx742_cur."!mark_push"(0, rx742_pos, $I10)
  # rx literal  "sub"
    add $I11, rx742_pos, 3
    gt $I11, rx742_eos, rx742_fail
    sub $I11, rx742_pos, rx742_off
    substr $S10, rx742_tgt, $I11, 3
    ne $S10, "sub", rx742_fail
    add rx742_pos, 3
    set_addr $I10, rxcap_747_fail
    ($I12, $I11) = rx742_cur."!mark_peek"($I10)
    rx742_cur."!cursor_pos"($I11)
    ($P10) = rx742_cur."!cursor_start"()
    $P10."!cursor_pass"(rx742_pos, "")
    rx742_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_747_done
  rxcap_747_fail:
    goto rx742_fail
  rxcap_747_done:
  # rx subrule "routine_def" subtype=capture negate=
    rx742_cur."!cursor_pos"(rx742_pos)
    $P10 = rx742_cur."routine_def"()
    unless $P10, rx742_fail
    rx742_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx742_pos = $P10."pos"()
  # rx pass
    rx742_cur."!cursor_pass"(rx742_pos, "routine_declarator:sym<sub>")
    if_null rx742_debug, debug_717
    rx742_cur."!cursor_debug"("PASS", "routine_declarator:sym<sub>", " at pos=", rx742_pos)
  debug_717:
    .return (rx742_cur)
  rx742_restart:
.annotate 'line', 4
    if_null rx742_debug, debug_718
    rx742_cur."!cursor_debug"("NEXT", "routine_declarator:sym<sub>")
  debug_718:
  rx742_fail:
    (rx742_rep, rx742_pos, $I10, $P10) = rx742_cur."!mark_fail"(0)
    lt rx742_pos, -1, rx742_done
    eq rx742_pos, -1, rx742_fail
    jump $I10
  rx742_done:
    rx742_cur."!cursor_fail"()
    if_null rx742_debug, debug_719
    rx742_cur."!cursor_debug"("FAIL", "routine_declarator:sym<sub>")
  debug_719:
    .return (rx742_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<sub>"  :nsentry("!PREFIX__routine_declarator:sym<sub>") :subid("166_1298325448.42642") :method
.annotate 'line', 4
    $P744 = self."!PREFIX__!subrule"("routine_def", "sub")
    new $P745, "ResizablePMCArray"
    push $P745, $P744
    .return ($P745)
.end


.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<method>"  :subid("167_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx749_tgt
    .local int rx749_pos
    .local int rx749_off
    .local int rx749_eos
    .local int rx749_rep
    .local pmc rx749_cur
    .local pmc rx749_debug
    (rx749_cur, rx749_pos, rx749_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx749_cur
    .local pmc match
    .lex "$/", match
    length rx749_eos, rx749_tgt
    gt rx749_pos, rx749_eos, rx749_done
    set rx749_off, 0
    lt rx749_pos, 2, rx749_start
    sub rx749_off, rx749_pos, 1
    substr rx749_tgt, rx749_tgt, rx749_off
  rx749_start:
    eq $I10, 1, rx749_restart
    if_null rx749_debug, debug_720
    rx749_cur."!cursor_debug"("START", "routine_declarator:sym<method>")
  debug_720:
    $I10 = self.'from'()
    ne $I10, -1, rxscan753_done
    goto rxscan753_scan
  rxscan753_loop:
    (rx749_pos) = rx749_cur."from"()
    inc rx749_pos
    rx749_cur."!cursor_from"(rx749_pos)
    ge rx749_pos, rx749_eos, rxscan753_done
  rxscan753_scan:
    set_addr $I10, rxscan753_loop
    rx749_cur."!mark_push"(0, rx749_pos, $I10)
  rxscan753_done:
.annotate 'line', 346
  # rx subcapture "sym"
    set_addr $I10, rxcap_754_fail
    rx749_cur."!mark_push"(0, rx749_pos, $I10)
  # rx literal  "method"
    add $I11, rx749_pos, 6
    gt $I11, rx749_eos, rx749_fail
    sub $I11, rx749_pos, rx749_off
    substr $S10, rx749_tgt, $I11, 6
    ne $S10, "method", rx749_fail
    add rx749_pos, 6
    set_addr $I10, rxcap_754_fail
    ($I12, $I11) = rx749_cur."!mark_peek"($I10)
    rx749_cur."!cursor_pos"($I11)
    ($P10) = rx749_cur."!cursor_start"()
    $P10."!cursor_pass"(rx749_pos, "")
    rx749_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_754_done
  rxcap_754_fail:
    goto rx749_fail
  rxcap_754_done:
  # rx subrule "method_def" subtype=capture negate=
    rx749_cur."!cursor_pos"(rx749_pos)
    $P10 = rx749_cur."method_def"()
    unless $P10, rx749_fail
    rx749_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("method_def")
    rx749_pos = $P10."pos"()
  # rx pass
    rx749_cur."!cursor_pass"(rx749_pos, "routine_declarator:sym<method>")
    if_null rx749_debug, debug_721
    rx749_cur."!cursor_debug"("PASS", "routine_declarator:sym<method>", " at pos=", rx749_pos)
  debug_721:
    .return (rx749_cur)
  rx749_restart:
.annotate 'line', 4
    if_null rx749_debug, debug_722
    rx749_cur."!cursor_debug"("NEXT", "routine_declarator:sym<method>")
  debug_722:
  rx749_fail:
    (rx749_rep, rx749_pos, $I10, $P10) = rx749_cur."!mark_fail"(0)
    lt rx749_pos, -1, rx749_done
    eq rx749_pos, -1, rx749_fail
    jump $I10
  rx749_done:
    rx749_cur."!cursor_fail"()
    if_null rx749_debug, debug_723
    rx749_cur."!cursor_debug"("FAIL", "routine_declarator:sym<method>")
  debug_723:
    .return (rx749_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<method>"  :nsentry("!PREFIX__routine_declarator:sym<method>") :subid("168_1298325448.42642") :method
.annotate 'line', 4
    $P751 = self."!PREFIX__!subrule"("method_def", "method")
    new $P752, "ResizablePMCArray"
    push $P752, $P751
    .return ($P752)
.end


.namespace ["NQP";"Grammar"]
.sub "routine_def"  :subid("169_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 349
    new $P756, "Undef"
    .lex "$*RETURN_USED", $P756
.annotate 'line', 4
    .local string rx757_tgt
    .local int rx757_pos
    .local int rx757_off
    .local int rx757_eos
    .local int rx757_rep
    .local pmc rx757_cur
    .local pmc rx757_debug
    (rx757_cur, rx757_pos, rx757_tgt, $I10) = self."!cursor_start"()
    rx757_cur."!cursor_caparray"("sigil", "deflongname", "trait")
    .lex unicode:"$\x{a2}", rx757_cur
    .local pmc match
    .lex "$/", match
    length rx757_eos, rx757_tgt
    gt rx757_pos, rx757_eos, rx757_done
    set rx757_off, 0
    lt rx757_pos, 2, rx757_start
    sub rx757_off, rx757_pos, 1
    substr rx757_tgt, rx757_tgt, rx757_off
  rx757_start:
    eq $I10, 1, rx757_restart
    if_null rx757_debug, debug_724
    rx757_cur."!cursor_debug"("START", "routine_def")
  debug_724:
    $I10 = self.'from'()
    ne $I10, -1, rxscan761_done
    goto rxscan761_scan
  rxscan761_loop:
    (rx757_pos) = rx757_cur."from"()
    inc rx757_pos
    rx757_cur."!cursor_from"(rx757_pos)
    ge rx757_pos, rx757_eos, rxscan761_done
  rxscan761_scan:
    set_addr $I10, rxscan761_loop
    rx757_cur."!mark_push"(0, rx757_pos, $I10)
  rxscan761_done:
.annotate 'line', 348
  # rx subrule "ws" subtype=method negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."ws"()
    unless $P10, rx757_fail
    rx757_pos = $P10."pos"()
.annotate 'line', 349
    rx757_cur."!cursor_pos"(rx757_pos)
    new $P763, "Integer"
    assign $P763, 0
    store_lex "$*RETURN_USED", $P763
  # rx subrule "ws" subtype=method negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."ws"()
    unless $P10, rx757_fail
    rx757_pos = $P10."pos"()
.annotate 'line', 350
  # rx rxquantr765 ** 0..1
    set_addr $I10, rxquantr765_done
    rx757_cur."!mark_push"(0, rx757_pos, $I10)
  rxquantr765_loop:
  # rx subrule "ws" subtype=method negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."ws"()
    unless $P10, rx757_fail
    rx757_pos = $P10."pos"()
  # rx subcapture "sigil"
    set_addr $I10, rxcap_768_fail
    rx757_cur."!mark_push"(0, rx757_pos, $I10)
  # rx rxquantr767 ** 0..1
    set_addr $I10, rxquantr767_done
    rx757_cur."!mark_push"(0, rx757_pos, $I10)
  rxquantr767_loop:
  # rx literal  "&"
    add $I11, rx757_pos, 1
    gt $I11, rx757_eos, rx757_fail
    sub $I11, rx757_pos, rx757_off
    ord $I11, rx757_tgt, $I11
    ne $I11, 38, rx757_fail
    add rx757_pos, 1
    set_addr $I10, rxquantr767_done
    (rx757_rep) = rx757_cur."!mark_commit"($I10)
  rxquantr767_done:
    set_addr $I10, rxcap_768_fail
    ($I12, $I11) = rx757_cur."!mark_peek"($I10)
    rx757_cur."!cursor_pos"($I11)
    ($P10) = rx757_cur."!cursor_start"()
    $P10."!cursor_pass"(rx757_pos, "")
    rx757_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_768_done
  rxcap_768_fail:
    goto rx757_fail
  rxcap_768_done:
  # rx subrule "deflongname" subtype=capture negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."deflongname"()
    unless $P10, rx757_fail
    rx757_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx757_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."ws"()
    unless $P10, rx757_fail
    rx757_pos = $P10."pos"()
    set_addr $I10, rxquantr765_done
    (rx757_rep) = rx757_cur."!mark_commit"($I10)
  rxquantr765_done:
  # rx subrule "ws" subtype=method negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."ws"()
    unless $P10, rx757_fail
    rx757_pos = $P10."pos"()
.annotate 'line', 351
  # rx subrule "newpad" subtype=method negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."newpad"()
    unless $P10, rx757_fail
    rx757_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."ws"()
    unless $P10, rx757_fail
    rx757_pos = $P10."pos"()
  alt772_0:
.annotate 'line', 352
    set_addr $I10, alt772_1
    rx757_cur."!mark_push"(0, rx757_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."ws"()
    unless $P10, rx757_fail
    rx757_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx757_pos, 1
    gt $I11, rx757_eos, rx757_fail
    sub $I11, rx757_pos, rx757_off
    ord $I11, rx757_tgt, $I11
    ne $I11, 40, rx757_fail
    add rx757_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."ws"()
    unless $P10, rx757_fail
    rx757_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."signature"()
    unless $P10, rx757_fail
    rx757_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx757_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."ws"()
    unless $P10, rx757_fail
    rx757_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx757_pos, 1
    gt $I11, rx757_eos, rx757_fail
    sub $I11, rx757_pos, rx757_off
    ord $I11, rx757_tgt, $I11
    ne $I11, 41, rx757_fail
    add rx757_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."ws"()
    unless $P10, rx757_fail
    rx757_pos = $P10."pos"()
    goto alt772_end
  alt772_1:
.annotate 'line', 353
  # rx subrule "ws" subtype=method negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."ws"()
    unless $P10, rx757_fail
    rx757_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx757_fail
    rx757_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."ws"()
    unless $P10, rx757_fail
    rx757_pos = $P10."pos"()
  alt772_end:
  # rx subrule "ws" subtype=method negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."ws"()
    unless $P10, rx757_fail
    rx757_pos = $P10."pos"()
.annotate 'line', 354
  # rx rxquantr780 ** 0..*
    set_addr $I10, rxquantr780_done
    rx757_cur."!mark_push"(0, rx757_pos, $I10)
  rxquantr780_loop:
  # rx subrule "trait" subtype=capture negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."trait"()
    unless $P10, rx757_fail
    goto rxsubrule781_pass
  rxsubrule781_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx757_fail
  rxsubrule781_pass:
    set_addr $I10, rxsubrule781_back
    rx757_cur."!mark_push"(0, rx757_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx757_pos = $P10."pos"()
    set_addr $I10, rxquantr780_done
    (rx757_rep) = rx757_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr780_done
    rx757_cur."!mark_push"(rx757_rep, rx757_pos, $I10)
    goto rxquantr780_loop
  rxquantr780_done:
  # rx subrule "ws" subtype=method negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."ws"()
    unless $P10, rx757_fail
    rx757_pos = $P10."pos"()
  alt783_0:
.annotate 'line', 355
    set_addr $I10, alt783_1
    rx757_cur."!mark_push"(0, rx757_pos, $I10)
.annotate 'line', 356
  # rx subrule "ws" subtype=method negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."ws"()
    unless $P10, rx757_fail
    rx757_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."onlystar"()
    unless $P10, rx757_fail
    rx757_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx757_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."ws"()
    unless $P10, rx757_fail
    rx757_pos = $P10."pos"()
    goto alt783_end
  alt783_1:
.annotate 'line', 357
  # rx subrule "ws" subtype=method negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."ws"()
    unless $P10, rx757_fail
    rx757_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."blockoid"()
    unless $P10, rx757_fail
    rx757_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx757_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."ws"()
    unless $P10, rx757_fail
    rx757_pos = $P10."pos"()
  alt783_end:
.annotate 'line', 358
  # rx subrule "ws" subtype=method negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."ws"()
    unless $P10, rx757_fail
    rx757_pos = $P10."pos"()
.annotate 'line', 348
  # rx pass
    rx757_cur."!cursor_pass"(rx757_pos, "routine_def")
    if_null rx757_debug, debug_725
    rx757_cur."!cursor_debug"("PASS", "routine_def", " at pos=", rx757_pos)
  debug_725:
    .return (rx757_cur)
  rx757_restart:
.annotate 'line', 4
    if_null rx757_debug, debug_726
    rx757_cur."!cursor_debug"("NEXT", "routine_def")
  debug_726:
  rx757_fail:
    (rx757_rep, rx757_pos, $I10, $P10) = rx757_cur."!mark_fail"(0)
    lt rx757_pos, -1, rx757_done
    eq rx757_pos, -1, rx757_fail
    jump $I10
  rx757_done:
    rx757_cur."!cursor_fail"()
    if_null rx757_debug, debug_727
    rx757_cur."!cursor_debug"("FAIL", "routine_def")
  debug_727:
    .return (rx757_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_def"  :nsentry("!PREFIX__routine_def") :subid("170_1298325448.42642") :method
.annotate 'line', 4
    $P759 = self."!PREFIX__!subrule"("ws", "")
    new $P760, "ResizablePMCArray"
    push $P760, $P759
    .return ($P760)
.end


.namespace ["NQP";"Grammar"]
.sub "method_def"  :subid("171_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .const 'Sub' $P820 = "173_1298325448.42642" 
    capture_lex $P820
.annotate 'line', 362
    new $P790, "Undef"
    .lex "$*RETURN_USED", $P790
.annotate 'line', 363
    new $P791, "Undef"
    .lex "$*INVOCANT_OK", $P791
.annotate 'line', 4
    .local string rx792_tgt
    .local int rx792_pos
    .local int rx792_off
    .local int rx792_eos
    .local int rx792_rep
    .local pmc rx792_cur
    .local pmc rx792_debug
    (rx792_cur, rx792_pos, rx792_tgt, $I10) = self."!cursor_start"()
    rx792_cur."!cursor_caparray"("deflongname", "trait")
    .lex unicode:"$\x{a2}", rx792_cur
    .local pmc match
    .lex "$/", match
    length rx792_eos, rx792_tgt
    gt rx792_pos, rx792_eos, rx792_done
    set rx792_off, 0
    lt rx792_pos, 2, rx792_start
    sub rx792_off, rx792_pos, 1
    substr rx792_tgt, rx792_tgt, rx792_off
  rx792_start:
    eq $I10, 1, rx792_restart
    if_null rx792_debug, debug_728
    rx792_cur."!cursor_debug"("START", "method_def")
  debug_728:
    $I10 = self.'from'()
    ne $I10, -1, rxscan796_done
    goto rxscan796_scan
  rxscan796_loop:
    (rx792_pos) = rx792_cur."from"()
    inc rx792_pos
    rx792_cur."!cursor_from"(rx792_pos)
    ge rx792_pos, rx792_eos, rxscan796_done
  rxscan796_scan:
    set_addr $I10, rxscan796_loop
    rx792_cur."!mark_push"(0, rx792_pos, $I10)
  rxscan796_done:
.annotate 'line', 361
  # rx subrule "ws" subtype=method negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."ws"()
    unless $P10, rx792_fail
    rx792_pos = $P10."pos"()
.annotate 'line', 362
    rx792_cur."!cursor_pos"(rx792_pos)
    new $P798, "Integer"
    assign $P798, 0
    store_lex "$*RETURN_USED", $P798
  # rx subrule "ws" subtype=method negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."ws"()
    unless $P10, rx792_fail
    rx792_pos = $P10."pos"()
.annotate 'line', 363
    rx792_cur."!cursor_pos"(rx792_pos)
    new $P800, "Integer"
    assign $P800, 1
    store_lex "$*INVOCANT_OK", $P800
  # rx subrule "ws" subtype=method negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."ws"()
    unless $P10, rx792_fail
    rx792_pos = $P10."pos"()
.annotate 'line', 364
  # rx subcapture "private"
    set_addr $I10, rxcap_803_fail
    rx792_cur."!mark_push"(0, rx792_pos, $I10)
  # rx rxquantr802 ** 0..1
    set_addr $I10, rxquantr802_done
    rx792_cur."!mark_push"(0, rx792_pos, $I10)
  rxquantr802_loop:
  # rx literal  "!"
    add $I11, rx792_pos, 1
    gt $I11, rx792_eos, rx792_fail
    sub $I11, rx792_pos, rx792_off
    ord $I11, rx792_tgt, $I11
    ne $I11, 33, rx792_fail
    add rx792_pos, 1
    set_addr $I10, rxquantr802_done
    (rx792_rep) = rx792_cur."!mark_commit"($I10)
  rxquantr802_done:
    set_addr $I10, rxcap_803_fail
    ($I12, $I11) = rx792_cur."!mark_peek"($I10)
    rx792_cur."!cursor_pos"($I11)
    ($P10) = rx792_cur."!cursor_start"()
    $P10."!cursor_pass"(rx792_pos, "")
    rx792_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("private")
    goto rxcap_803_done
  rxcap_803_fail:
    goto rx792_fail
  rxcap_803_done:
  # rx subrule "ws" subtype=method negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."ws"()
    unless $P10, rx792_fail
    rx792_pos = $P10."pos"()
.annotate 'line', 365
  # rx rxquantr805 ** 0..1
    set_addr $I10, rxquantr805_done
    rx792_cur."!mark_push"(0, rx792_pos, $I10)
  rxquantr805_loop:
  # rx subrule "deflongname" subtype=capture negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."deflongname"()
    unless $P10, rx792_fail
    goto rxsubrule806_pass
  rxsubrule806_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx792_fail
  rxsubrule806_pass:
    set_addr $I10, rxsubrule806_back
    rx792_cur."!mark_push"(0, rx792_pos, $I10, $P10)
    $P10."!cursor_names"("deflongname")
    rx792_pos = $P10."pos"()
    set_addr $I10, rxquantr805_done
    (rx792_rep) = rx792_cur."!mark_commit"($I10)
  rxquantr805_done:
  # rx subrule "ws" subtype=method negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."ws"()
    unless $P10, rx792_fail
    rx792_pos = $P10."pos"()
.annotate 'line', 366
  # rx subrule "newpad" subtype=method negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."newpad"()
    unless $P10, rx792_fail
    rx792_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."ws"()
    unless $P10, rx792_fail
    rx792_pos = $P10."pos"()
  alt809_0:
.annotate 'line', 367
    set_addr $I10, alt809_1
    rx792_cur."!mark_push"(0, rx792_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."ws"()
    unless $P10, rx792_fail
    rx792_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx792_pos, 1
    gt $I11, rx792_eos, rx792_fail
    sub $I11, rx792_pos, rx792_off
    ord $I11, rx792_tgt, $I11
    ne $I11, 40, rx792_fail
    add rx792_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."ws"()
    unless $P10, rx792_fail
    rx792_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."signature"()
    unless $P10, rx792_fail
    rx792_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx792_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."ws"()
    unless $P10, rx792_fail
    rx792_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx792_pos, 1
    gt $I11, rx792_eos, rx792_fail
    sub $I11, rx792_pos, rx792_off
    ord $I11, rx792_tgt, $I11
    ne $I11, 41, rx792_fail
    add rx792_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."ws"()
    unless $P10, rx792_fail
    rx792_pos = $P10."pos"()
    goto alt809_end
  alt809_1:
.annotate 'line', 368
  # rx subrule "ws" subtype=method negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."ws"()
    unless $P10, rx792_fail
    rx792_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx792_fail
    rx792_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."ws"()
    unless $P10, rx792_fail
    rx792_pos = $P10."pos"()
  alt809_end:
  # rx subrule "ws" subtype=method negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."ws"()
    unless $P10, rx792_fail
    rx792_pos = $P10."pos"()
.annotate 'line', 369
    rx792_cur."!cursor_pos"(rx792_pos)
    find_lex $P817, unicode:"$\x{a2}"
    $P818 = $P817."MATCH"()
    store_lex "$/", $P818
    .const 'Sub' $P820 = "173_1298325448.42642" 
    capture_lex $P820
    $P822 = $P820()
  # rx subrule "ws" subtype=method negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."ws"()
    unless $P10, rx792_fail
    rx792_pos = $P10."pos"()
.annotate 'line', 370
  # rx rxquantr824 ** 0..*
    set_addr $I10, rxquantr824_done
    rx792_cur."!mark_push"(0, rx792_pos, $I10)
  rxquantr824_loop:
  # rx subrule "trait" subtype=capture negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."trait"()
    unless $P10, rx792_fail
    goto rxsubrule825_pass
  rxsubrule825_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx792_fail
  rxsubrule825_pass:
    set_addr $I10, rxsubrule825_back
    rx792_cur."!mark_push"(0, rx792_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx792_pos = $P10."pos"()
    set_addr $I10, rxquantr824_done
    (rx792_rep) = rx792_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr824_done
    rx792_cur."!mark_push"(rx792_rep, rx792_pos, $I10)
    goto rxquantr824_loop
  rxquantr824_done:
  # rx subrule "ws" subtype=method negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."ws"()
    unless $P10, rx792_fail
    rx792_pos = $P10."pos"()
  alt827_0:
.annotate 'line', 371
    set_addr $I10, alt827_1
    rx792_cur."!mark_push"(0, rx792_pos, $I10)
.annotate 'line', 372
  # rx subrule "ws" subtype=method negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."ws"()
    unless $P10, rx792_fail
    rx792_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."onlystar"()
    unless $P10, rx792_fail
    rx792_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx792_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."ws"()
    unless $P10, rx792_fail
    rx792_pos = $P10."pos"()
    goto alt827_end
  alt827_1:
.annotate 'line', 373
  # rx subrule "ws" subtype=method negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."ws"()
    unless $P10, rx792_fail
    rx792_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."blockoid"()
    unless $P10, rx792_fail
    rx792_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx792_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."ws"()
    unless $P10, rx792_fail
    rx792_pos = $P10."pos"()
  alt827_end:
.annotate 'line', 374
  # rx subrule "ws" subtype=method negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."ws"()
    unless $P10, rx792_fail
    rx792_pos = $P10."pos"()
.annotate 'line', 361
  # rx pass
    rx792_cur."!cursor_pass"(rx792_pos, "method_def")
    if_null rx792_debug, debug_729
    rx792_cur."!cursor_debug"("PASS", "method_def", " at pos=", rx792_pos)
  debug_729:
    .return (rx792_cur)
  rx792_restart:
.annotate 'line', 4
    if_null rx792_debug, debug_730
    rx792_cur."!cursor_debug"("NEXT", "method_def")
  debug_730:
  rx792_fail:
    (rx792_rep, rx792_pos, $I10, $P10) = rx792_cur."!mark_fail"(0)
    lt rx792_pos, -1, rx792_done
    eq rx792_pos, -1, rx792_fail
    jump $I10
  rx792_done:
    rx792_cur."!cursor_fail"()
    if_null rx792_debug, debug_731
    rx792_cur."!cursor_debug"("FAIL", "method_def")
  debug_731:
    .return (rx792_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__method_def"  :nsentry("!PREFIX__method_def") :subid("172_1298325448.42642") :method
.annotate 'line', 4
    $P794 = self."!PREFIX__!subrule"("ws", "")
    new $P795, "ResizablePMCArray"
    push $P795, $P794
    .return ($P795)
.end


.namespace ["NQP";"Grammar"]
.sub "_block819"  :anon :subid("173_1298325448.42642") :outer("171_1298325448.42642")
.annotate 'line', 369
    new $P821, "Integer"
    assign $P821, 0
    store_dynamic_lex "$*INVOCANT_OK", $P821
    .return ($P821)
.end


.namespace ["NQP";"Grammar"]
.sub "onlystar"  :subid("174_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .const 'Sub' $P841 = "176_1298325448.42642" 
    capture_lex $P841
    .local string rx834_tgt
    .local int rx834_pos
    .local int rx834_off
    .local int rx834_eos
    .local int rx834_rep
    .local pmc rx834_cur
    .local pmc rx834_debug
    (rx834_cur, rx834_pos, rx834_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx834_cur
    .local pmc match
    .lex "$/", match
    length rx834_eos, rx834_tgt
    gt rx834_pos, rx834_eos, rx834_done
    set rx834_off, 0
    lt rx834_pos, 2, rx834_start
    sub rx834_off, rx834_pos, 1
    substr rx834_tgt, rx834_tgt, rx834_off
  rx834_start:
    eq $I10, 1, rx834_restart
    if_null rx834_debug, debug_732
    rx834_cur."!cursor_debug"("START", "onlystar")
  debug_732:
    $I10 = self.'from'()
    ne $I10, -1, rxscan837_done
    goto rxscan837_scan
  rxscan837_loop:
    (rx834_pos) = rx834_cur."from"()
    inc rx834_pos
    rx834_cur."!cursor_from"(rx834_pos)
    ge rx834_pos, rx834_eos, rxscan837_done
  rxscan837_scan:
    set_addr $I10, rxscan837_loop
    rx834_cur."!mark_push"(0, rx834_pos, $I10)
  rxscan837_done:
.annotate 'line', 378
    rx834_cur."!cursor_pos"(rx834_pos)
    find_lex $P838, unicode:"$\x{a2}"
    $P839 = $P838."MATCH"()
    store_lex "$/", $P839
    .const 'Sub' $P841 = "176_1298325448.42642" 
    capture_lex $P841
    $P845 = $P841()
    unless $P845, rx834_fail
.annotate 'line', 379
  # rx literal  "{"
    add $I11, rx834_pos, 1
    gt $I11, rx834_eos, rx834_fail
    sub $I11, rx834_pos, rx834_off
    ord $I11, rx834_tgt, $I11
    ne $I11, 123, rx834_fail
    add rx834_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx834_cur."!cursor_pos"(rx834_pos)
    $P10 = rx834_cur."ws"()
    unless $P10, rx834_fail
    rx834_pos = $P10."pos"()
  # rx literal  "*"
    add $I11, rx834_pos, 1
    gt $I11, rx834_eos, rx834_fail
    sub $I11, rx834_pos, rx834_off
    ord $I11, rx834_tgt, $I11
    ne $I11, 42, rx834_fail
    add rx834_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx834_cur."!cursor_pos"(rx834_pos)
    $P10 = rx834_cur."ws"()
    unless $P10, rx834_fail
    rx834_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx834_pos, 1
    gt $I11, rx834_eos, rx834_fail
    sub $I11, rx834_pos, rx834_off
    ord $I11, rx834_tgt, $I11
    ne $I11, 125, rx834_fail
    add rx834_pos, 1
.annotate 'line', 380
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx834_cur."!cursor_pos"(rx834_pos)
    $P10 = rx834_cur."ENDSTMT"()
    unless $P10, rx834_fail
.annotate 'line', 381
  # rx subrule "finishpad" subtype=method negate=
    rx834_cur."!cursor_pos"(rx834_pos)
    $P10 = rx834_cur."finishpad"()
    unless $P10, rx834_fail
    rx834_pos = $P10."pos"()
.annotate 'line', 377
  # rx pass
    rx834_cur."!cursor_pass"(rx834_pos, "onlystar")
    if_null rx834_debug, debug_735
    rx834_cur."!cursor_debug"("PASS", "onlystar", " at pos=", rx834_pos)
  debug_735:
    .return (rx834_cur)
  rx834_restart:
.annotate 'line', 4
    if_null rx834_debug, debug_736
    rx834_cur."!cursor_debug"("NEXT", "onlystar")
  debug_736:
  rx834_fail:
    (rx834_rep, rx834_pos, $I10, $P10) = rx834_cur."!mark_fail"(0)
    lt rx834_pos, -1, rx834_done
    eq rx834_pos, -1, rx834_fail
    jump $I10
  rx834_done:
    rx834_cur."!cursor_fail"()
    if_null rx834_debug, debug_737
    rx834_cur."!cursor_debug"("FAIL", "onlystar")
  debug_737:
    .return (rx834_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__onlystar"  :nsentry("!PREFIX__onlystar") :subid("175_1298325448.42642") :method
.annotate 'line', 4
    new $P836, "ResizablePMCArray"
    push $P836, ""
    .return ($P836)
.end


.namespace ["NQP";"Grammar"]
.sub "_block840"  :anon :subid("176_1298325448.42642") :outer("174_1298325448.42642")
.annotate 'line', 378
    find_dynamic_lex $P842, "$*MULTINESS"
    unless_null $P842, vivify_733
    get_hll_global $P842, "$MULTINESS"
    unless_null $P842, vivify_734
    die "Contextual $*MULTINESS not found"
  vivify_734:
  vivify_733:
    set $S843, $P842
    iseq $I844, $S843, "proto"
    .return ($I844)
.end


.namespace ["NQP";"Grammar"]
.sub "multi_declarator"  :subid("177_1298325448.42642")
    .param pmc param_847
.annotate 'line', 384
    .lex "self", param_847
    $P848 = param_847."!protoregex"("multi_declarator")
    .return ($P848)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator"  :subid("178_1298325448.42642")
    .param pmc param_850
.annotate 'line', 384
    .lex "self", param_850
    $P851 = param_850."!PREFIX__!protoregex"("multi_declarator")
    .return ($P851)
.end


.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<multi>"  :subid("179_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 386
    new $P853, "Undef"
    .lex "$*MULTINESS", $P853
.annotate 'line', 4
    .local string rx854_tgt
    .local int rx854_pos
    .local int rx854_off
    .local int rx854_eos
    .local int rx854_rep
    .local pmc rx854_cur
    .local pmc rx854_debug
    (rx854_cur, rx854_pos, rx854_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx854_cur
    .local pmc match
    .lex "$/", match
    length rx854_eos, rx854_tgt
    gt rx854_pos, rx854_eos, rx854_done
    set rx854_off, 0
    lt rx854_pos, 2, rx854_start
    sub rx854_off, rx854_pos, 1
    substr rx854_tgt, rx854_tgt, rx854_off
  rx854_start:
    eq $I10, 1, rx854_restart
    if_null rx854_debug, debug_738
    rx854_cur."!cursor_debug"("START", "multi_declarator:sym<multi>")
  debug_738:
    $I10 = self.'from'()
    ne $I10, -1, rxscan858_done
    goto rxscan858_scan
  rxscan858_loop:
    (rx854_pos) = rx854_cur."from"()
    inc rx854_pos
    rx854_cur."!cursor_from"(rx854_pos)
    ge rx854_pos, rx854_eos, rxscan858_done
  rxscan858_scan:
    set_addr $I10, rxscan858_loop
    rx854_cur."!mark_push"(0, rx854_pos, $I10)
  rxscan858_done:
.annotate 'line', 386
    rx854_cur."!cursor_pos"(rx854_pos)
    new $P859, "String"
    assign $P859, "multi"
    store_lex "$*MULTINESS", $P859
.annotate 'line', 387
  # rx subcapture "sym"
    set_addr $I10, rxcap_860_fail
    rx854_cur."!mark_push"(0, rx854_pos, $I10)
  # rx literal  "multi"
    add $I11, rx854_pos, 5
    gt $I11, rx854_eos, rx854_fail
    sub $I11, rx854_pos, rx854_off
    substr $S10, rx854_tgt, $I11, 5
    ne $S10, "multi", rx854_fail
    add rx854_pos, 5
    set_addr $I10, rxcap_860_fail
    ($I12, $I11) = rx854_cur."!mark_peek"($I10)
    rx854_cur."!cursor_pos"($I11)
    ($P10) = rx854_cur."!cursor_start"()
    $P10."!cursor_pass"(rx854_pos, "")
    rx854_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_860_done
  rxcap_860_fail:
    goto rx854_fail
  rxcap_860_done:
.annotate 'line', 388
  # rx subrule "ws" subtype=method negate=
    rx854_cur."!cursor_pos"(rx854_pos)
    $P10 = rx854_cur."ws"()
    unless $P10, rx854_fail
    rx854_pos = $P10."pos"()
  alt861_0:
    set_addr $I10, alt861_1
    rx854_cur."!mark_push"(0, rx854_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx854_cur."!cursor_pos"(rx854_pos)
    $P10 = rx854_cur."declarator"()
    unless $P10, rx854_fail
    rx854_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx854_pos = $P10."pos"()
    goto alt861_end
  alt861_1:
    set_addr $I10, alt861_2
    rx854_cur."!mark_push"(0, rx854_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx854_cur."!cursor_pos"(rx854_pos)
    $P10 = rx854_cur."routine_def"()
    unless $P10, rx854_fail
    rx854_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx854_pos = $P10."pos"()
    goto alt861_end
  alt861_2:
  # rx subrule "panic" subtype=method negate=
    rx854_cur."!cursor_pos"(rx854_pos)
    $P10 = rx854_cur."panic"("Malformed multi")
    unless $P10, rx854_fail
    rx854_pos = $P10."pos"()
  alt861_end:
.annotate 'line', 385
  # rx pass
    rx854_cur."!cursor_pass"(rx854_pos, "multi_declarator:sym<multi>")
    if_null rx854_debug, debug_739
    rx854_cur."!cursor_debug"("PASS", "multi_declarator:sym<multi>", " at pos=", rx854_pos)
  debug_739:
    .return (rx854_cur)
  rx854_restart:
.annotate 'line', 4
    if_null rx854_debug, debug_740
    rx854_cur."!cursor_debug"("NEXT", "multi_declarator:sym<multi>")
  debug_740:
  rx854_fail:
    (rx854_rep, rx854_pos, $I10, $P10) = rx854_cur."!mark_fail"(0)
    lt rx854_pos, -1, rx854_done
    eq rx854_pos, -1, rx854_fail
    jump $I10
  rx854_done:
    rx854_cur."!cursor_fail"()
    if_null rx854_debug, debug_741
    rx854_cur."!cursor_debug"("FAIL", "multi_declarator:sym<multi>")
  debug_741:
    .return (rx854_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<multi>"  :nsentry("!PREFIX__multi_declarator:sym<multi>") :subid("180_1298325448.42642") :method
.annotate 'line', 4
    $P856 = self."!PREFIX__!subrule"("ws", "multi")
    new $P857, "ResizablePMCArray"
    push $P857, $P856
    .return ($P857)
.end


.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<proto>"  :subid("181_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 391
    new $P863, "Undef"
    .lex "$*MULTINESS", $P863
.annotate 'line', 4
    .local string rx864_tgt
    .local int rx864_pos
    .local int rx864_off
    .local int rx864_eos
    .local int rx864_rep
    .local pmc rx864_cur
    .local pmc rx864_debug
    (rx864_cur, rx864_pos, rx864_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx864_cur
    .local pmc match
    .lex "$/", match
    length rx864_eos, rx864_tgt
    gt rx864_pos, rx864_eos, rx864_done
    set rx864_off, 0
    lt rx864_pos, 2, rx864_start
    sub rx864_off, rx864_pos, 1
    substr rx864_tgt, rx864_tgt, rx864_off
  rx864_start:
    eq $I10, 1, rx864_restart
    if_null rx864_debug, debug_742
    rx864_cur."!cursor_debug"("START", "multi_declarator:sym<proto>")
  debug_742:
    $I10 = self.'from'()
    ne $I10, -1, rxscan868_done
    goto rxscan868_scan
  rxscan868_loop:
    (rx864_pos) = rx864_cur."from"()
    inc rx864_pos
    rx864_cur."!cursor_from"(rx864_pos)
    ge rx864_pos, rx864_eos, rxscan868_done
  rxscan868_scan:
    set_addr $I10, rxscan868_loop
    rx864_cur."!mark_push"(0, rx864_pos, $I10)
  rxscan868_done:
.annotate 'line', 391
    rx864_cur."!cursor_pos"(rx864_pos)
    new $P869, "String"
    assign $P869, "proto"
    store_lex "$*MULTINESS", $P869
.annotate 'line', 392
  # rx subcapture "sym"
    set_addr $I10, rxcap_870_fail
    rx864_cur."!mark_push"(0, rx864_pos, $I10)
  # rx literal  "proto"
    add $I11, rx864_pos, 5
    gt $I11, rx864_eos, rx864_fail
    sub $I11, rx864_pos, rx864_off
    substr $S10, rx864_tgt, $I11, 5
    ne $S10, "proto", rx864_fail
    add rx864_pos, 5
    set_addr $I10, rxcap_870_fail
    ($I12, $I11) = rx864_cur."!mark_peek"($I10)
    rx864_cur."!cursor_pos"($I11)
    ($P10) = rx864_cur."!cursor_start"()
    $P10."!cursor_pass"(rx864_pos, "")
    rx864_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_870_done
  rxcap_870_fail:
    goto rx864_fail
  rxcap_870_done:
.annotate 'line', 393
  # rx subrule "ws" subtype=method negate=
    rx864_cur."!cursor_pos"(rx864_pos)
    $P10 = rx864_cur."ws"()
    unless $P10, rx864_fail
    rx864_pos = $P10."pos"()
  alt871_0:
    set_addr $I10, alt871_1
    rx864_cur."!mark_push"(0, rx864_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx864_cur."!cursor_pos"(rx864_pos)
    $P10 = rx864_cur."declarator"()
    unless $P10, rx864_fail
    rx864_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx864_pos = $P10."pos"()
    goto alt871_end
  alt871_1:
    set_addr $I10, alt871_2
    rx864_cur."!mark_push"(0, rx864_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx864_cur."!cursor_pos"(rx864_pos)
    $P10 = rx864_cur."routine_def"()
    unless $P10, rx864_fail
    rx864_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx864_pos = $P10."pos"()
    goto alt871_end
  alt871_2:
  # rx subrule "panic" subtype=method negate=
    rx864_cur."!cursor_pos"(rx864_pos)
    $P10 = rx864_cur."panic"("Malformed proto")
    unless $P10, rx864_fail
    rx864_pos = $P10."pos"()
  alt871_end:
.annotate 'line', 390
  # rx pass
    rx864_cur."!cursor_pass"(rx864_pos, "multi_declarator:sym<proto>")
    if_null rx864_debug, debug_743
    rx864_cur."!cursor_debug"("PASS", "multi_declarator:sym<proto>", " at pos=", rx864_pos)
  debug_743:
    .return (rx864_cur)
  rx864_restart:
.annotate 'line', 4
    if_null rx864_debug, debug_744
    rx864_cur."!cursor_debug"("NEXT", "multi_declarator:sym<proto>")
  debug_744:
  rx864_fail:
    (rx864_rep, rx864_pos, $I10, $P10) = rx864_cur."!mark_fail"(0)
    lt rx864_pos, -1, rx864_done
    eq rx864_pos, -1, rx864_fail
    jump $I10
  rx864_done:
    rx864_cur."!cursor_fail"()
    if_null rx864_debug, debug_745
    rx864_cur."!cursor_debug"("FAIL", "multi_declarator:sym<proto>")
  debug_745:
    .return (rx864_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<proto>"  :nsentry("!PREFIX__multi_declarator:sym<proto>") :subid("182_1298325448.42642") :method
.annotate 'line', 4
    $P866 = self."!PREFIX__!subrule"("ws", "proto")
    new $P867, "ResizablePMCArray"
    push $P867, $P866
    .return ($P867)
.end


.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<null>"  :subid("183_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 396
    new $P873, "Undef"
    .lex "$*MULTINESS", $P873
.annotate 'line', 4
    .local string rx874_tgt
    .local int rx874_pos
    .local int rx874_off
    .local int rx874_eos
    .local int rx874_rep
    .local pmc rx874_cur
    .local pmc rx874_debug
    (rx874_cur, rx874_pos, rx874_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx874_cur
    .local pmc match
    .lex "$/", match
    length rx874_eos, rx874_tgt
    gt rx874_pos, rx874_eos, rx874_done
    set rx874_off, 0
    lt rx874_pos, 2, rx874_start
    sub rx874_off, rx874_pos, 1
    substr rx874_tgt, rx874_tgt, rx874_off
  rx874_start:
    eq $I10, 1, rx874_restart
    if_null rx874_debug, debug_746
    rx874_cur."!cursor_debug"("START", "multi_declarator:sym<null>")
  debug_746:
    $I10 = self.'from'()
    ne $I10, -1, rxscan878_done
    goto rxscan878_scan
  rxscan878_loop:
    (rx874_pos) = rx874_cur."from"()
    inc rx874_pos
    rx874_cur."!cursor_from"(rx874_pos)
    ge rx874_pos, rx874_eos, rxscan878_done
  rxscan878_scan:
    set_addr $I10, rxscan878_loop
    rx874_cur."!mark_push"(0, rx874_pos, $I10)
  rxscan878_done:
.annotate 'line', 396
    rx874_cur."!cursor_pos"(rx874_pos)
    new $P879, "String"
    assign $P879, ""
    store_lex "$*MULTINESS", $P879
.annotate 'line', 397
  # rx subrule "declarator" subtype=capture negate=
    rx874_cur."!cursor_pos"(rx874_pos)
    $P10 = rx874_cur."declarator"()
    unless $P10, rx874_fail
    rx874_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx874_pos = $P10."pos"()
.annotate 'line', 395
  # rx pass
    rx874_cur."!cursor_pass"(rx874_pos, "multi_declarator:sym<null>")
    if_null rx874_debug, debug_747
    rx874_cur."!cursor_debug"("PASS", "multi_declarator:sym<null>", " at pos=", rx874_pos)
  debug_747:
    .return (rx874_cur)
  rx874_restart:
.annotate 'line', 4
    if_null rx874_debug, debug_748
    rx874_cur."!cursor_debug"("NEXT", "multi_declarator:sym<null>")
  debug_748:
  rx874_fail:
    (rx874_rep, rx874_pos, $I10, $P10) = rx874_cur."!mark_fail"(0)
    lt rx874_pos, -1, rx874_done
    eq rx874_pos, -1, rx874_fail
    jump $I10
  rx874_done:
    rx874_cur."!cursor_fail"()
    if_null rx874_debug, debug_749
    rx874_cur."!cursor_debug"("FAIL", "multi_declarator:sym<null>")
  debug_749:
    .return (rx874_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<null>"  :nsentry("!PREFIX__multi_declarator:sym<null>") :subid("184_1298325448.42642") :method
.annotate 'line', 4
    $P876 = self."!PREFIX__!subrule"("declarator", "")
    new $P877, "ResizablePMCArray"
    push $P877, $P876
    .return ($P877)
.end


.namespace ["NQP";"Grammar"]
.sub "signature"  :subid("185_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .const 'Sub' $P889 = "187_1298325448.42642" 
    capture_lex $P889
    .local string rx881_tgt
    .local int rx881_pos
    .local int rx881_off
    .local int rx881_eos
    .local int rx881_rep
    .local pmc rx881_cur
    .local pmc rx881_debug
    (rx881_cur, rx881_pos, rx881_tgt, $I10) = self."!cursor_start"()
    rx881_cur."!cursor_caparray"("invocant", "parameter")
    .lex unicode:"$\x{a2}", rx881_cur
    .local pmc match
    .lex "$/", match
    length rx881_eos, rx881_tgt
    gt rx881_pos, rx881_eos, rx881_done
    set rx881_off, 0
    lt rx881_pos, 2, rx881_start
    sub rx881_off, rx881_pos, 1
    substr rx881_tgt, rx881_tgt, rx881_off
  rx881_start:
    eq $I10, 1, rx881_restart
    if_null rx881_debug, debug_750
    rx881_cur."!cursor_debug"("START", "signature")
  debug_750:
    $I10 = self.'from'()
    ne $I10, -1, rxscan884_done
    goto rxscan884_scan
  rxscan884_loop:
    (rx881_pos) = rx881_cur."from"()
    inc rx881_pos
    rx881_cur."!cursor_from"(rx881_pos)
    ge rx881_pos, rx881_eos, rxscan884_done
  rxscan884_scan:
    set_addr $I10, rxscan884_loop
    rx881_cur."!mark_push"(0, rx881_pos, $I10)
  rxscan884_done:
.annotate 'line', 401
  # rx rxquantr885 ** 0..1
    set_addr $I10, rxquantr885_done
    rx881_cur."!mark_push"(0, rx881_pos, $I10)
  rxquantr885_loop:
    rx881_cur."!cursor_pos"(rx881_pos)
    find_lex $P886, unicode:"$\x{a2}"
    $P887 = $P886."MATCH"()
    store_lex "$/", $P887
    .const 'Sub' $P889 = "187_1298325448.42642" 
    capture_lex $P889
    $P891 = $P889()
    unless $P891, rx881_fail
  # rx subrule "ws" subtype=method negate=
    rx881_cur."!cursor_pos"(rx881_pos)
    $P10 = rx881_cur."ws"()
    unless $P10, rx881_fail
    rx881_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx881_cur."!cursor_pos"(rx881_pos)
    $P10 = rx881_cur."parameter"()
    unless $P10, rx881_fail
    rx881_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("invocant")
    rx881_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx881_cur."!cursor_pos"(rx881_pos)
    $P10 = rx881_cur."ws"()
    unless $P10, rx881_fail
    rx881_pos = $P10."pos"()
  # rx literal  ":"
    add $I11, rx881_pos, 1
    gt $I11, rx881_eos, rx881_fail
    sub $I11, rx881_pos, rx881_off
    ord $I11, rx881_tgt, $I11
    ne $I11, 58, rx881_fail
    add rx881_pos, 1
    set_addr $I10, rxquantr885_done
    (rx881_rep) = rx881_cur."!mark_commit"($I10)
  rxquantr885_done:
.annotate 'line', 402
  # rx rxquantr892 ** 0..1
    set_addr $I10, rxquantr892_done
    rx881_cur."!mark_push"(0, rx881_pos, $I10)
  rxquantr892_loop:
  # rx rxquantr893 ** 1..*
    set_addr $I10, rxquantr893_done
    rx881_cur."!mark_push"(0, -1, $I10)
  rxquantr893_loop:
  # rx subrule "ws" subtype=method negate=
    rx881_cur."!cursor_pos"(rx881_pos)
    $P10 = rx881_cur."ws"()
    unless $P10, rx881_fail
    rx881_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx881_cur."!cursor_pos"(rx881_pos)
    $P10 = rx881_cur."parameter"()
    unless $P10, rx881_fail
    rx881_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parameter")
    rx881_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx881_cur."!cursor_pos"(rx881_pos)
    $P10 = rx881_cur."ws"()
    unless $P10, rx881_fail
    rx881_pos = $P10."pos"()
    set_addr $I10, rxquantr893_done
    (rx881_rep) = rx881_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr893_done
    rx881_cur."!mark_push"(rx881_rep, rx881_pos, $I10)
  # rx literal  ","
    add $I11, rx881_pos, 1
    gt $I11, rx881_eos, rx881_fail
    sub $I11, rx881_pos, rx881_off
    ord $I11, rx881_tgt, $I11
    ne $I11, 44, rx881_fail
    add rx881_pos, 1
    goto rxquantr893_loop
  rxquantr893_done:
    set_addr $I10, rxquantr892_done
    (rx881_rep) = rx881_cur."!mark_commit"($I10)
  rxquantr892_done:
.annotate 'line', 400
  # rx pass
    rx881_cur."!cursor_pass"(rx881_pos, "signature")
    if_null rx881_debug, debug_753
    rx881_cur."!cursor_debug"("PASS", "signature", " at pos=", rx881_pos)
  debug_753:
    .return (rx881_cur)
  rx881_restart:
.annotate 'line', 4
    if_null rx881_debug, debug_754
    rx881_cur."!cursor_debug"("NEXT", "signature")
  debug_754:
  rx881_fail:
    (rx881_rep, rx881_pos, $I10, $P10) = rx881_cur."!mark_fail"(0)
    lt rx881_pos, -1, rx881_done
    eq rx881_pos, -1, rx881_fail
    jump $I10
  rx881_done:
    rx881_cur."!cursor_fail"()
    if_null rx881_debug, debug_755
    rx881_cur."!cursor_debug"("FAIL", "signature")
  debug_755:
    .return (rx881_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__signature"  :nsentry("!PREFIX__signature") :subid("186_1298325448.42642") :method
.annotate 'line', 4
    new $P883, "ResizablePMCArray"
    push $P883, ""
    .return ($P883)
.end


.namespace ["NQP";"Grammar"]
.sub "_block888"  :anon :subid("187_1298325448.42642") :outer("185_1298325448.42642")
.annotate 'line', 401
    find_dynamic_lex $P890, "$*INVOCANT_OK"
    unless_null $P890, vivify_751
    get_hll_global $P890, "$INVOCANT_OK"
    unless_null $P890, vivify_752
    die "Contextual $*INVOCANT_OK not found"
  vivify_752:
  vivify_751:
    .return ($P890)
.end


.namespace ["NQP";"Grammar"]
.sub "parameter"  :subid("188_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx895_tgt
    .local int rx895_pos
    .local int rx895_off
    .local int rx895_eos
    .local int rx895_rep
    .local pmc rx895_cur
    .local pmc rx895_debug
    (rx895_cur, rx895_pos, rx895_tgt, $I10) = self."!cursor_start"()
    rx895_cur."!cursor_caparray"("typename", "definedness", "default_value")
    .lex unicode:"$\x{a2}", rx895_cur
    .local pmc match
    .lex "$/", match
    length rx895_eos, rx895_tgt
    gt rx895_pos, rx895_eos, rx895_done
    set rx895_off, 0
    lt rx895_pos, 2, rx895_start
    sub rx895_off, rx895_pos, 1
    substr rx895_tgt, rx895_tgt, rx895_off
  rx895_start:
    eq $I10, 1, rx895_restart
    if_null rx895_debug, debug_756
    rx895_cur."!cursor_debug"("START", "parameter")
  debug_756:
    $I10 = self.'from'()
    ne $I10, -1, rxscan898_done
    goto rxscan898_scan
  rxscan898_loop:
    (rx895_pos) = rx895_cur."from"()
    inc rx895_pos
    rx895_cur."!cursor_from"(rx895_pos)
    ge rx895_pos, rx895_eos, rxscan898_done
  rxscan898_scan:
    set_addr $I10, rxscan898_loop
    rx895_cur."!mark_push"(0, rx895_pos, $I10)
  rxscan898_done:
.annotate 'line', 406
  # rx rxquantr899 ** 0..*
    set_addr $I10, rxquantr899_done
    rx895_cur."!mark_push"(0, rx895_pos, $I10)
  rxquantr899_loop:
  # rx subrule "typename" subtype=capture negate=
    rx895_cur."!cursor_pos"(rx895_pos)
    $P10 = rx895_cur."typename"()
    unless $P10, rx895_fail
    rx895_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("typename")
    rx895_pos = $P10."pos"()
  # rx rxquantr900 ** 0..1
    set_addr $I10, rxquantr900_done
    rx895_cur."!mark_push"(0, rx895_pos, $I10)
  rxquantr900_loop:
  # rx literal  ":"
    add $I11, rx895_pos, 1
    gt $I11, rx895_eos, rx895_fail
    sub $I11, rx895_pos, rx895_off
    ord $I11, rx895_tgt, $I11
    ne $I11, 58, rx895_fail
    add rx895_pos, 1
  # rx subcapture "definedness"
    set_addr $I10, rxcap_901_fail
    rx895_cur."!mark_push"(0, rx895_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx895_pos, rx895_eos, rx895_fail
    sub $I10, rx895_pos, rx895_off
    substr $S10, rx895_tgt, $I10, 1
    index $I11, "_DU", $S10
    lt $I11, 0, rx895_fail
    inc rx895_pos
    set_addr $I10, rxcap_901_fail
    ($I12, $I11) = rx895_cur."!mark_peek"($I10)
    rx895_cur."!cursor_pos"($I11)
    ($P10) = rx895_cur."!cursor_start"()
    $P10."!cursor_pass"(rx895_pos, "")
    rx895_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("definedness")
    goto rxcap_901_done
  rxcap_901_fail:
    goto rx895_fail
  rxcap_901_done:
    set_addr $I10, rxquantr900_done
    (rx895_rep) = rx895_cur."!mark_commit"($I10)
  rxquantr900_done:
  # rx subrule "ws" subtype=method negate=
    rx895_cur."!cursor_pos"(rx895_pos)
    $P10 = rx895_cur."ws"()
    unless $P10, rx895_fail
    rx895_pos = $P10."pos"()
    set_addr $I10, rxquantr899_done
    (rx895_rep) = rx895_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr899_done
    rx895_cur."!mark_push"(rx895_rep, rx895_pos, $I10)
    goto rxquantr899_loop
  rxquantr899_done:
  alt902_0:
.annotate 'line', 407
    set_addr $I10, alt902_1
    rx895_cur."!mark_push"(0, rx895_pos, $I10)
.annotate 'line', 408
  # rx subcapture "quant"
    set_addr $I10, rxcap_903_fail
    rx895_cur."!mark_push"(0, rx895_pos, $I10)
  # rx literal  "*"
    add $I11, rx895_pos, 1
    gt $I11, rx895_eos, rx895_fail
    sub $I11, rx895_pos, rx895_off
    ord $I11, rx895_tgt, $I11
    ne $I11, 42, rx895_fail
    add rx895_pos, 1
    set_addr $I10, rxcap_903_fail
    ($I12, $I11) = rx895_cur."!mark_peek"($I10)
    rx895_cur."!cursor_pos"($I11)
    ($P10) = rx895_cur."!cursor_start"()
    $P10."!cursor_pass"(rx895_pos, "")
    rx895_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_903_done
  rxcap_903_fail:
    goto rx895_fail
  rxcap_903_done:
  # rx subrule "param_var" subtype=capture negate=
    rx895_cur."!cursor_pos"(rx895_pos)
    $P10 = rx895_cur."param_var"()
    unless $P10, rx895_fail
    rx895_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx895_pos = $P10."pos"()
    goto alt902_end
  alt902_1:
  alt904_0:
.annotate 'line', 409
    set_addr $I10, alt904_1
    rx895_cur."!mark_push"(0, rx895_pos, $I10)
  # rx subrule "param_var" subtype=capture negate=
    rx895_cur."!cursor_pos"(rx895_pos)
    $P10 = rx895_cur."param_var"()
    unless $P10, rx895_fail
    rx895_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx895_pos = $P10."pos"()
    goto alt904_end
  alt904_1:
  # rx subrule "named_param" subtype=capture negate=
    rx895_cur."!cursor_pos"(rx895_pos)
    $P10 = rx895_cur."named_param"()
    unless $P10, rx895_fail
    rx895_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("named_param")
    rx895_pos = $P10."pos"()
  alt904_end:
  # rx subcapture "quant"
    set_addr $I10, rxcap_906_fail
    rx895_cur."!mark_push"(0, rx895_pos, $I10)
  alt905_0:
    set_addr $I10, alt905_1
    rx895_cur."!mark_push"(0, rx895_pos, $I10)
  # rx literal  "?"
    add $I11, rx895_pos, 1
    gt $I11, rx895_eos, rx895_fail
    sub $I11, rx895_pos, rx895_off
    ord $I11, rx895_tgt, $I11
    ne $I11, 63, rx895_fail
    add rx895_pos, 1
    goto alt905_end
  alt905_1:
    set_addr $I10, alt905_2
    rx895_cur."!mark_push"(0, rx895_pos, $I10)
  # rx literal  "!"
    add $I11, rx895_pos, 1
    gt $I11, rx895_eos, rx895_fail
    sub $I11, rx895_pos, rx895_off
    ord $I11, rx895_tgt, $I11
    ne $I11, 33, rx895_fail
    add rx895_pos, 1
    goto alt905_end
  alt905_2:
  alt905_end:
    set_addr $I10, rxcap_906_fail
    ($I12, $I11) = rx895_cur."!mark_peek"($I10)
    rx895_cur."!cursor_pos"($I11)
    ($P10) = rx895_cur."!cursor_start"()
    $P10."!cursor_pass"(rx895_pos, "")
    rx895_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_906_done
  rxcap_906_fail:
    goto rx895_fail
  rxcap_906_done:
  alt902_end:
.annotate 'line', 411
  # rx rxquantr907 ** 0..1
    set_addr $I10, rxquantr907_done
    rx895_cur."!mark_push"(0, rx895_pos, $I10)
  rxquantr907_loop:
  # rx subrule "default_value" subtype=capture negate=
    rx895_cur."!cursor_pos"(rx895_pos)
    $P10 = rx895_cur."default_value"()
    unless $P10, rx895_fail
    goto rxsubrule908_pass
  rxsubrule908_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx895_fail
  rxsubrule908_pass:
    set_addr $I10, rxsubrule908_back
    rx895_cur."!mark_push"(0, rx895_pos, $I10, $P10)
    $P10."!cursor_names"("default_value")
    rx895_pos = $P10."pos"()
    set_addr $I10, rxquantr907_done
    (rx895_rep) = rx895_cur."!mark_commit"($I10)
  rxquantr907_done:
.annotate 'line', 405
  # rx pass
    rx895_cur."!cursor_pass"(rx895_pos, "parameter")
    if_null rx895_debug, debug_757
    rx895_cur."!cursor_debug"("PASS", "parameter", " at pos=", rx895_pos)
  debug_757:
    .return (rx895_cur)
  rx895_restart:
.annotate 'line', 4
    if_null rx895_debug, debug_758
    rx895_cur."!cursor_debug"("NEXT", "parameter")
  debug_758:
  rx895_fail:
    (rx895_rep, rx895_pos, $I10, $P10) = rx895_cur."!mark_fail"(0)
    lt rx895_pos, -1, rx895_done
    eq rx895_pos, -1, rx895_fail
    jump $I10
  rx895_done:
    rx895_cur."!cursor_fail"()
    if_null rx895_debug, debug_759
    rx895_cur."!cursor_debug"("FAIL", "parameter")
  debug_759:
    .return (rx895_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__parameter"  :nsentry("!PREFIX__parameter") :subid("189_1298325448.42642") :method
.annotate 'line', 4
    new $P897, "ResizablePMCArray"
    push $P897, ""
    .return ($P897)
.end


.namespace ["NQP";"Grammar"]
.sub "param_var"  :subid("190_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx910_tgt
    .local int rx910_pos
    .local int rx910_off
    .local int rx910_eos
    .local int rx910_rep
    .local pmc rx910_cur
    .local pmc rx910_debug
    (rx910_cur, rx910_pos, rx910_tgt, $I10) = self."!cursor_start"()
    rx910_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx910_cur
    .local pmc match
    .lex "$/", match
    length rx910_eos, rx910_tgt
    gt rx910_pos, rx910_eos, rx910_done
    set rx910_off, 0
    lt rx910_pos, 2, rx910_start
    sub rx910_off, rx910_pos, 1
    substr rx910_tgt, rx910_tgt, rx910_off
  rx910_start:
    eq $I10, 1, rx910_restart
    if_null rx910_debug, debug_760
    rx910_cur."!cursor_debug"("START", "param_var")
  debug_760:
    $I10 = self.'from'()
    ne $I10, -1, rxscan914_done
    goto rxscan914_scan
  rxscan914_loop:
    (rx910_pos) = rx910_cur."from"()
    inc rx910_pos
    rx910_cur."!cursor_from"(rx910_pos)
    ge rx910_pos, rx910_eos, rxscan914_done
  rxscan914_scan:
    set_addr $I10, rxscan914_loop
    rx910_cur."!mark_push"(0, rx910_pos, $I10)
  rxscan914_done:
.annotate 'line', 415
  # rx subrule "sigil" subtype=capture negate=
    rx910_cur."!cursor_pos"(rx910_pos)
    $P10 = rx910_cur."sigil"()
    unless $P10, rx910_fail
    rx910_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx910_pos = $P10."pos"()
  # rx rxquantr915 ** 0..1
    set_addr $I10, rxquantr915_done
    rx910_cur."!mark_push"(0, rx910_pos, $I10)
  rxquantr915_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx910_cur."!cursor_pos"(rx910_pos)
    $P10 = rx910_cur."twigil"()
    unless $P10, rx910_fail
    goto rxsubrule916_pass
  rxsubrule916_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx910_fail
  rxsubrule916_pass:
    set_addr $I10, rxsubrule916_back
    rx910_cur."!mark_push"(0, rx910_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx910_pos = $P10."pos"()
    set_addr $I10, rxquantr915_done
    (rx910_rep) = rx910_cur."!mark_commit"($I10)
  rxquantr915_done:
  alt917_0:
.annotate 'line', 416
    set_addr $I10, alt917_1
    rx910_cur."!mark_push"(0, rx910_pos, $I10)
  # rx subrule "ident" subtype=capture negate=
    rx910_cur."!cursor_pos"(rx910_pos)
    $P10 = rx910_cur."ident"()
    unless $P10, rx910_fail
    rx910_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx910_pos = $P10."pos"()
    goto alt917_end
  alt917_1:
  # rx subcapture "name"
    set_addr $I10, rxcap_918_fail
    rx910_cur."!mark_push"(0, rx910_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx910_pos, rx910_eos, rx910_fail
    sub $I10, rx910_pos, rx910_off
    substr $S10, rx910_tgt, $I10, 1
    index $I11, "/!", $S10
    lt $I11, 0, rx910_fail
    inc rx910_pos
    set_addr $I10, rxcap_918_fail
    ($I12, $I11) = rx910_cur."!mark_peek"($I10)
    rx910_cur."!cursor_pos"($I11)
    ($P10) = rx910_cur."!cursor_start"()
    $P10."!cursor_pass"(rx910_pos, "")
    rx910_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    goto rxcap_918_done
  rxcap_918_fail:
    goto rx910_fail
  rxcap_918_done:
  alt917_end:
.annotate 'line', 414
  # rx pass
    rx910_cur."!cursor_pass"(rx910_pos, "param_var")
    if_null rx910_debug, debug_761
    rx910_cur."!cursor_debug"("PASS", "param_var", " at pos=", rx910_pos)
  debug_761:
    .return (rx910_cur)
  rx910_restart:
.annotate 'line', 4
    if_null rx910_debug, debug_762
    rx910_cur."!cursor_debug"("NEXT", "param_var")
  debug_762:
  rx910_fail:
    (rx910_rep, rx910_pos, $I10, $P10) = rx910_cur."!mark_fail"(0)
    lt rx910_pos, -1, rx910_done
    eq rx910_pos, -1, rx910_fail
    jump $I10
  rx910_done:
    rx910_cur."!cursor_fail"()
    if_null rx910_debug, debug_763
    rx910_cur."!cursor_debug"("FAIL", "param_var")
  debug_763:
    .return (rx910_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__param_var"  :nsentry("!PREFIX__param_var") :subid("191_1298325448.42642") :method
.annotate 'line', 4
    $P912 = self."!PREFIX__!subrule"("sigil", "")
    new $P913, "ResizablePMCArray"
    push $P913, $P912
    .return ($P913)
.end


.namespace ["NQP";"Grammar"]
.sub "named_param"  :subid("192_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx920_tgt
    .local int rx920_pos
    .local int rx920_off
    .local int rx920_eos
    .local int rx920_rep
    .local pmc rx920_cur
    .local pmc rx920_debug
    (rx920_cur, rx920_pos, rx920_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx920_cur
    .local pmc match
    .lex "$/", match
    length rx920_eos, rx920_tgt
    gt rx920_pos, rx920_eos, rx920_done
    set rx920_off, 0
    lt rx920_pos, 2, rx920_start
    sub rx920_off, rx920_pos, 1
    substr rx920_tgt, rx920_tgt, rx920_off
  rx920_start:
    eq $I10, 1, rx920_restart
    if_null rx920_debug, debug_764
    rx920_cur."!cursor_debug"("START", "named_param")
  debug_764:
    $I10 = self.'from'()
    ne $I10, -1, rxscan924_done
    goto rxscan924_scan
  rxscan924_loop:
    (rx920_pos) = rx920_cur."from"()
    inc rx920_pos
    rx920_cur."!cursor_from"(rx920_pos)
    ge rx920_pos, rx920_eos, rxscan924_done
  rxscan924_scan:
    set_addr $I10, rxscan924_loop
    rx920_cur."!mark_push"(0, rx920_pos, $I10)
  rxscan924_done:
.annotate 'line', 420
  # rx literal  ":"
    add $I11, rx920_pos, 1
    gt $I11, rx920_eos, rx920_fail
    sub $I11, rx920_pos, rx920_off
    ord $I11, rx920_tgt, $I11
    ne $I11, 58, rx920_fail
    add rx920_pos, 1
  # rx subrule "param_var" subtype=capture negate=
    rx920_cur."!cursor_pos"(rx920_pos)
    $P10 = rx920_cur."param_var"()
    unless $P10, rx920_fail
    rx920_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx920_pos = $P10."pos"()
.annotate 'line', 419
  # rx pass
    rx920_cur."!cursor_pass"(rx920_pos, "named_param")
    if_null rx920_debug, debug_765
    rx920_cur."!cursor_debug"("PASS", "named_param", " at pos=", rx920_pos)
  debug_765:
    .return (rx920_cur)
  rx920_restart:
.annotate 'line', 4
    if_null rx920_debug, debug_766
    rx920_cur."!cursor_debug"("NEXT", "named_param")
  debug_766:
  rx920_fail:
    (rx920_rep, rx920_pos, $I10, $P10) = rx920_cur."!mark_fail"(0)
    lt rx920_pos, -1, rx920_done
    eq rx920_pos, -1, rx920_fail
    jump $I10
  rx920_done:
    rx920_cur."!cursor_fail"()
    if_null rx920_debug, debug_767
    rx920_cur."!cursor_debug"("FAIL", "named_param")
  debug_767:
    .return (rx920_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__named_param"  :nsentry("!PREFIX__named_param") :subid("193_1298325448.42642") :method
.annotate 'line', 4
    $P922 = self."!PREFIX__!subrule"("param_var", ":")
    new $P923, "ResizablePMCArray"
    push $P923, $P922
    .return ($P923)
.end


.namespace ["NQP";"Grammar"]
.sub "default_value"  :subid("194_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx926_tgt
    .local int rx926_pos
    .local int rx926_off
    .local int rx926_eos
    .local int rx926_rep
    .local pmc rx926_cur
    .local pmc rx926_debug
    (rx926_cur, rx926_pos, rx926_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx926_cur
    .local pmc match
    .lex "$/", match
    length rx926_eos, rx926_tgt
    gt rx926_pos, rx926_eos, rx926_done
    set rx926_off, 0
    lt rx926_pos, 2, rx926_start
    sub rx926_off, rx926_pos, 1
    substr rx926_tgt, rx926_tgt, rx926_off
  rx926_start:
    eq $I10, 1, rx926_restart
    if_null rx926_debug, debug_768
    rx926_cur."!cursor_debug"("START", "default_value")
  debug_768:
    $I10 = self.'from'()
    ne $I10, -1, rxscan930_done
    goto rxscan930_scan
  rxscan930_loop:
    (rx926_pos) = rx926_cur."from"()
    inc rx926_pos
    rx926_cur."!cursor_from"(rx926_pos)
    ge rx926_pos, rx926_eos, rxscan930_done
  rxscan930_scan:
    set_addr $I10, rxscan930_loop
    rx926_cur."!mark_push"(0, rx926_pos, $I10)
  rxscan930_done:
.annotate 'line', 423
  # rx subrule "ws" subtype=method negate=
    rx926_cur."!cursor_pos"(rx926_pos)
    $P10 = rx926_cur."ws"()
    unless $P10, rx926_fail
    rx926_pos = $P10."pos"()
  # rx literal  "="
    add $I11, rx926_pos, 1
    gt $I11, rx926_eos, rx926_fail
    sub $I11, rx926_pos, rx926_off
    ord $I11, rx926_tgt, $I11
    ne $I11, 61, rx926_fail
    add rx926_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx926_cur."!cursor_pos"(rx926_pos)
    $P10 = rx926_cur."ws"()
    unless $P10, rx926_fail
    rx926_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx926_cur."!cursor_pos"(rx926_pos)
    $P10 = rx926_cur."EXPR"("i=")
    unless $P10, rx926_fail
    rx926_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx926_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx926_cur."!cursor_pos"(rx926_pos)
    $P10 = rx926_cur."ws"()
    unless $P10, rx926_fail
    rx926_pos = $P10."pos"()
  # rx pass
    rx926_cur."!cursor_pass"(rx926_pos, "default_value")
    if_null rx926_debug, debug_769
    rx926_cur."!cursor_debug"("PASS", "default_value", " at pos=", rx926_pos)
  debug_769:
    .return (rx926_cur)
  rx926_restart:
.annotate 'line', 4
    if_null rx926_debug, debug_770
    rx926_cur."!cursor_debug"("NEXT", "default_value")
  debug_770:
  rx926_fail:
    (rx926_rep, rx926_pos, $I10, $P10) = rx926_cur."!mark_fail"(0)
    lt rx926_pos, -1, rx926_done
    eq rx926_pos, -1, rx926_fail
    jump $I10
  rx926_done:
    rx926_cur."!cursor_fail"()
    if_null rx926_debug, debug_771
    rx926_cur."!cursor_debug"("FAIL", "default_value")
  debug_771:
    .return (rx926_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__default_value"  :nsentry("!PREFIX__default_value") :subid("195_1298325448.42642") :method
.annotate 'line', 4
    $P928 = self."!PREFIX__!subrule"("ws", "")
    new $P929, "ResizablePMCArray"
    push $P929, $P928
    .return ($P929)
.end


.namespace ["NQP";"Grammar"]
.sub "trait"  :subid("196_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx935_tgt
    .local int rx935_pos
    .local int rx935_off
    .local int rx935_eos
    .local int rx935_rep
    .local pmc rx935_cur
    .local pmc rx935_debug
    (rx935_cur, rx935_pos, rx935_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx935_cur
    .local pmc match
    .lex "$/", match
    length rx935_eos, rx935_tgt
    gt rx935_pos, rx935_eos, rx935_done
    set rx935_off, 0
    lt rx935_pos, 2, rx935_start
    sub rx935_off, rx935_pos, 1
    substr rx935_tgt, rx935_tgt, rx935_off
  rx935_start:
    eq $I10, 1, rx935_restart
    if_null rx935_debug, debug_772
    rx935_cur."!cursor_debug"("START", "trait")
  debug_772:
    $I10 = self.'from'()
    ne $I10, -1, rxscan939_done
    goto rxscan939_scan
  rxscan939_loop:
    (rx935_pos) = rx935_cur."from"()
    inc rx935_pos
    rx935_cur."!cursor_from"(rx935_pos)
    ge rx935_pos, rx935_eos, rxscan939_done
  rxscan939_scan:
    set_addr $I10, rxscan939_loop
    rx935_cur."!mark_push"(0, rx935_pos, $I10)
  rxscan939_done:
.annotate 'line', 425
  # rx subrule "ws" subtype=method negate=
    rx935_cur."!cursor_pos"(rx935_pos)
    $P10 = rx935_cur."ws"()
    unless $P10, rx935_fail
    rx935_pos = $P10."pos"()
  # rx subrule "trait_mod" subtype=capture negate=
    rx935_cur."!cursor_pos"(rx935_pos)
    $P10 = rx935_cur."trait_mod"()
    unless $P10, rx935_fail
    rx935_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("trait_mod")
    rx935_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx935_cur."!cursor_pos"(rx935_pos)
    $P10 = rx935_cur."ws"()
    unless $P10, rx935_fail
    rx935_pos = $P10."pos"()
  # rx pass
    rx935_cur."!cursor_pass"(rx935_pos, "trait")
    if_null rx935_debug, debug_773
    rx935_cur."!cursor_debug"("PASS", "trait", " at pos=", rx935_pos)
  debug_773:
    .return (rx935_cur)
  rx935_restart:
.annotate 'line', 4
    if_null rx935_debug, debug_774
    rx935_cur."!cursor_debug"("NEXT", "trait")
  debug_774:
  rx935_fail:
    (rx935_rep, rx935_pos, $I10, $P10) = rx935_cur."!mark_fail"(0)
    lt rx935_pos, -1, rx935_done
    eq rx935_pos, -1, rx935_fail
    jump $I10
  rx935_done:
    rx935_cur."!cursor_fail"()
    if_null rx935_debug, debug_775
    rx935_cur."!cursor_debug"("FAIL", "trait")
  debug_775:
    .return (rx935_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait"  :nsentry("!PREFIX__trait") :subid("197_1298325448.42642") :method
.annotate 'line', 4
    $P937 = self."!PREFIX__!subrule"("ws", "")
    new $P938, "ResizablePMCArray"
    push $P938, $P937
    .return ($P938)
.end


.namespace ["NQP";"Grammar"]
.sub "trait_mod"  :subid("198_1298325448.42642")
    .param pmc param_943
.annotate 'line', 427
    .lex "self", param_943
    $P944 = param_943."!protoregex"("trait_mod")
    .return ($P944)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod"  :subid("199_1298325448.42642")
    .param pmc param_946
.annotate 'line', 427
    .lex "self", param_946
    $P947 = param_946."!PREFIX__!protoregex"("trait_mod")
    .return ($P947)
.end


.namespace ["NQP";"Grammar"]
.sub "trait_mod:sym<is>"  :subid("200_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx949_tgt
    .local int rx949_pos
    .local int rx949_off
    .local int rx949_eos
    .local int rx949_rep
    .local pmc rx949_cur
    .local pmc rx949_debug
    (rx949_cur, rx949_pos, rx949_tgt, $I10) = self."!cursor_start"()
    rx949_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx949_cur
    .local pmc match
    .lex "$/", match
    length rx949_eos, rx949_tgt
    gt rx949_pos, rx949_eos, rx949_done
    set rx949_off, 0
    lt rx949_pos, 2, rx949_start
    sub rx949_off, rx949_pos, 1
    substr rx949_tgt, rx949_tgt, rx949_off
  rx949_start:
    eq $I10, 1, rx949_restart
    if_null rx949_debug, debug_776
    rx949_cur."!cursor_debug"("START", "trait_mod:sym<is>")
  debug_776:
    $I10 = self.'from'()
    ne $I10, -1, rxscan953_done
    goto rxscan953_scan
  rxscan953_loop:
    (rx949_pos) = rx949_cur."from"()
    inc rx949_pos
    rx949_cur."!cursor_from"(rx949_pos)
    ge rx949_pos, rx949_eos, rxscan953_done
  rxscan953_scan:
    set_addr $I10, rxscan953_loop
    rx949_cur."!mark_push"(0, rx949_pos, $I10)
  rxscan953_done:
.annotate 'line', 428
  # rx subcapture "sym"
    set_addr $I10, rxcap_954_fail
    rx949_cur."!mark_push"(0, rx949_pos, $I10)
  # rx literal  "is"
    add $I11, rx949_pos, 2
    gt $I11, rx949_eos, rx949_fail
    sub $I11, rx949_pos, rx949_off
    substr $S10, rx949_tgt, $I11, 2
    ne $S10, "is", rx949_fail
    add rx949_pos, 2
    set_addr $I10, rxcap_954_fail
    ($I12, $I11) = rx949_cur."!mark_peek"($I10)
    rx949_cur."!cursor_pos"($I11)
    ($P10) = rx949_cur."!cursor_start"()
    $P10."!cursor_pass"(rx949_pos, "")
    rx949_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_954_done
  rxcap_954_fail:
    goto rx949_fail
  rxcap_954_done:
  # rx subrule "ws" subtype=method negate=
    rx949_cur."!cursor_pos"(rx949_pos)
    $P10 = rx949_cur."ws"()
    unless $P10, rx949_fail
    rx949_pos = $P10."pos"()
  # rx subrule "deflongname" subtype=capture negate=
    rx949_cur."!cursor_pos"(rx949_pos)
    $P10 = rx949_cur."deflongname"()
    unless $P10, rx949_fail
    rx949_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx949_pos = $P10."pos"()
  # rx rxquantr956 ** 0..1
    set_addr $I10, rxquantr956_done
    rx949_cur."!mark_push"(0, rx949_pos, $I10)
  rxquantr956_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx949_cur."!cursor_pos"(rx949_pos)
    $P10 = rx949_cur."circumfix"()
    unless $P10, rx949_fail
    goto rxsubrule957_pass
  rxsubrule957_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx949_fail
  rxsubrule957_pass:
    set_addr $I10, rxsubrule957_back
    rx949_cur."!mark_push"(0, rx949_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx949_pos = $P10."pos"()
    set_addr $I10, rxquantr956_done
    (rx949_rep) = rx949_cur."!mark_commit"($I10)
  rxquantr956_done:
  # rx subrule "ws" subtype=method negate=
    rx949_cur."!cursor_pos"(rx949_pos)
    $P10 = rx949_cur."ws"()
    unless $P10, rx949_fail
    rx949_pos = $P10."pos"()
  # rx pass
    rx949_cur."!cursor_pass"(rx949_pos, "trait_mod:sym<is>")
    if_null rx949_debug, debug_777
    rx949_cur."!cursor_debug"("PASS", "trait_mod:sym<is>", " at pos=", rx949_pos)
  debug_777:
    .return (rx949_cur)
  rx949_restart:
.annotate 'line', 4
    if_null rx949_debug, debug_778
    rx949_cur."!cursor_debug"("NEXT", "trait_mod:sym<is>")
  debug_778:
  rx949_fail:
    (rx949_rep, rx949_pos, $I10, $P10) = rx949_cur."!mark_fail"(0)
    lt rx949_pos, -1, rx949_done
    eq rx949_pos, -1, rx949_fail
    jump $I10
  rx949_done:
    rx949_cur."!cursor_fail"()
    if_null rx949_debug, debug_779
    rx949_cur."!cursor_debug"("FAIL", "trait_mod:sym<is>")
  debug_779:
    .return (rx949_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod:sym<is>"  :nsentry("!PREFIX__trait_mod:sym<is>") :subid("201_1298325448.42642") :method
.annotate 'line', 4
    $P951 = self."!PREFIX__!subrule"("ws", "is")
    new $P952, "ResizablePMCArray"
    push $P952, $P951
    .return ($P952)
.end


.namespace ["NQP";"Grammar"]
.sub "regex_declarator"  :subid("202_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx960_tgt
    .local int rx960_pos
    .local int rx960_off
    .local int rx960_eos
    .local int rx960_rep
    .local pmc rx960_cur
    .local pmc rx960_debug
    (rx960_cur, rx960_pos, rx960_tgt, $I10) = self."!cursor_start"()
    rx960_cur."!cursor_caparray"("signature")
    .lex unicode:"$\x{a2}", rx960_cur
    .local pmc match
    .lex "$/", match
    length rx960_eos, rx960_tgt
    gt rx960_pos, rx960_eos, rx960_done
    set rx960_off, 0
    lt rx960_pos, 2, rx960_start
    sub rx960_off, rx960_pos, 1
    substr rx960_tgt, rx960_tgt, rx960_off
  rx960_start:
    eq $I10, 1, rx960_restart
    if_null rx960_debug, debug_780
    rx960_cur."!cursor_debug"("START", "regex_declarator")
  debug_780:
    $I10 = self.'from'()
    ne $I10, -1, rxscan964_done
    goto rxscan964_scan
  rxscan964_loop:
    (rx960_pos) = rx960_cur."from"()
    inc rx960_pos
    rx960_cur."!cursor_from"(rx960_pos)
    ge rx960_pos, rx960_eos, rxscan964_done
  rxscan964_scan:
    set_addr $I10, rxscan964_loop
    rx960_cur."!mark_push"(0, rx960_pos, $I10)
  rxscan964_done:
.annotate 'line', 430
  # rx subrule "ws" subtype=method negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."ws"()
    unless $P10, rx960_fail
    rx960_pos = $P10."pos"()
  alt966_0:
.annotate 'line', 431
    set_addr $I10, alt966_1
    rx960_cur."!mark_push"(0, rx960_pos, $I10)
.annotate 'line', 432
  # rx subrule "ws" subtype=method negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."ws"()
    unless $P10, rx960_fail
    rx960_pos = $P10."pos"()
  # rx subcapture "proto"
    set_addr $I10, rxcap_968_fail
    rx960_cur."!mark_push"(0, rx960_pos, $I10)
  # rx literal  "proto"
    add $I11, rx960_pos, 5
    gt $I11, rx960_eos, rx960_fail
    sub $I11, rx960_pos, rx960_off
    substr $S10, rx960_tgt, $I11, 5
    ne $S10, "proto", rx960_fail
    add rx960_pos, 5
    set_addr $I10, rxcap_968_fail
    ($I12, $I11) = rx960_cur."!mark_peek"($I10)
    rx960_cur."!cursor_pos"($I11)
    ($P10) = rx960_cur."!cursor_start"()
    $P10."!cursor_pass"(rx960_pos, "")
    rx960_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("proto")
    goto rxcap_968_done
  rxcap_968_fail:
    goto rx960_fail
  rxcap_968_done:
  # rx subrule "ws" subtype=method negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."ws"()
    unless $P10, rx960_fail
    rx960_pos = $P10."pos"()
  alt970_0:
    set_addr $I10, alt970_1
    rx960_cur."!mark_push"(0, rx960_pos, $I10)
  # rx literal  "regex"
    add $I11, rx960_pos, 5
    gt $I11, rx960_eos, rx960_fail
    sub $I11, rx960_pos, rx960_off
    substr $S10, rx960_tgt, $I11, 5
    ne $S10, "regex", rx960_fail
    add rx960_pos, 5
    goto alt970_end
  alt970_1:
    set_addr $I10, alt970_2
    rx960_cur."!mark_push"(0, rx960_pos, $I10)
  # rx literal  "token"
    add $I11, rx960_pos, 5
    gt $I11, rx960_eos, rx960_fail
    sub $I11, rx960_pos, rx960_off
    substr $S10, rx960_tgt, $I11, 5
    ne $S10, "token", rx960_fail
    add rx960_pos, 5
    goto alt970_end
  alt970_2:
  # rx literal  "rule"
    add $I11, rx960_pos, 4
    gt $I11, rx960_eos, rx960_fail
    sub $I11, rx960_pos, rx960_off
    substr $S10, rx960_tgt, $I11, 4
    ne $S10, "rule", rx960_fail
    add rx960_pos, 4
  alt970_end:
  # rx subrule "ws" subtype=method negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."ws"()
    unless $P10, rx960_fail
    rx960_pos = $P10."pos"()
.annotate 'line', 433
  # rx subrule "deflongname" subtype=capture negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."deflongname"()
    unless $P10, rx960_fail
    rx960_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx960_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."ws"()
    unless $P10, rx960_fail
    rx960_pos = $P10."pos"()
  alt973_0:
.annotate 'line', 434
    set_addr $I10, alt973_1
    rx960_cur."!mark_push"(0, rx960_pos, $I10)
.annotate 'line', 435
  # rx subrule "ws" subtype=method negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."ws"()
    unless $P10, rx960_fail
    rx960_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx960_pos, 1
    gt $I11, rx960_eos, rx960_fail
    sub $I11, rx960_pos, rx960_off
    ord $I11, rx960_tgt, $I11
    ne $I11, 123, rx960_fail
    add rx960_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."ws"()
    unless $P10, rx960_fail
    rx960_pos = $P10."pos"()
  # rx literal  "<...>"
    add $I11, rx960_pos, 5
    gt $I11, rx960_eos, rx960_fail
    sub $I11, rx960_pos, rx960_off
    substr $S10, rx960_tgt, $I11, 5
    ne $S10, "<...>", rx960_fail
    add rx960_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."ws"()
    unless $P10, rx960_fail
    rx960_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx960_pos, 1
    gt $I11, rx960_eos, rx960_fail
    sub $I11, rx960_pos, rx960_off
    ord $I11, rx960_tgt, $I11
    ne $I11, 125, rx960_fail
    add rx960_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."ENDSTMT"()
    unless $P10, rx960_fail
  # rx subrule "ws" subtype=method negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."ws"()
    unless $P10, rx960_fail
    rx960_pos = $P10."pos"()
    goto alt973_end
  alt973_1:
    set_addr $I10, alt973_2
    rx960_cur."!mark_push"(0, rx960_pos, $I10)
.annotate 'line', 436
  # rx subrule "ws" subtype=method negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."ws"()
    unless $P10, rx960_fail
    rx960_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx960_pos, 1
    gt $I11, rx960_eos, rx960_fail
    sub $I11, rx960_pos, rx960_off
    ord $I11, rx960_tgt, $I11
    ne $I11, 123, rx960_fail
    add rx960_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."ws"()
    unless $P10, rx960_fail
    rx960_pos = $P10."pos"()
  # rx literal  "<*>"
    add $I11, rx960_pos, 3
    gt $I11, rx960_eos, rx960_fail
    sub $I11, rx960_pos, rx960_off
    substr $S10, rx960_tgt, $I11, 3
    ne $S10, "<*>", rx960_fail
    add rx960_pos, 3
  # rx subrule "ws" subtype=method negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."ws"()
    unless $P10, rx960_fail
    rx960_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx960_pos, 1
    gt $I11, rx960_eos, rx960_fail
    sub $I11, rx960_pos, rx960_off
    ord $I11, rx960_tgt, $I11
    ne $I11, 125, rx960_fail
    add rx960_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."ENDSTMT"()
    unless $P10, rx960_fail
  # rx subrule "ws" subtype=method negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."ws"()
    unless $P10, rx960_fail
    rx960_pos = $P10."pos"()
    goto alt973_end
  alt973_2:
.annotate 'line', 437
  # rx subrule "ws" subtype=method negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."ws"()
    unless $P10, rx960_fail
    rx960_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."panic"("Proto regex body must be <*> (or <...>, which is deprecated)")
    unless $P10, rx960_fail
    rx960_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."ws"()
    unless $P10, rx960_fail
    rx960_pos = $P10."pos"()
  alt973_end:
.annotate 'line', 438
  # rx subrule "ws" subtype=method negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."ws"()
    unless $P10, rx960_fail
    rx960_pos = $P10."pos"()
.annotate 'line', 432
    goto alt966_end
  alt966_1:
.annotate 'line', 439
  # rx subrule "ws" subtype=method negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."ws"()
    unless $P10, rx960_fail
    rx960_pos = $P10."pos"()
  # rx subcapture "sym"
    set_addr $I10, rxcap_987_fail
    rx960_cur."!mark_push"(0, rx960_pos, $I10)
  alt986_0:
    set_addr $I10, alt986_1
    rx960_cur."!mark_push"(0, rx960_pos, $I10)
  # rx literal  "regex"
    add $I11, rx960_pos, 5
    gt $I11, rx960_eos, rx960_fail
    sub $I11, rx960_pos, rx960_off
    substr $S10, rx960_tgt, $I11, 5
    ne $S10, "regex", rx960_fail
    add rx960_pos, 5
    goto alt986_end
  alt986_1:
    set_addr $I10, alt986_2
    rx960_cur."!mark_push"(0, rx960_pos, $I10)
  # rx literal  "token"
    add $I11, rx960_pos, 5
    gt $I11, rx960_eos, rx960_fail
    sub $I11, rx960_pos, rx960_off
    substr $S10, rx960_tgt, $I11, 5
    ne $S10, "token", rx960_fail
    add rx960_pos, 5
    goto alt986_end
  alt986_2:
  # rx literal  "rule"
    add $I11, rx960_pos, 4
    gt $I11, rx960_eos, rx960_fail
    sub $I11, rx960_pos, rx960_off
    substr $S10, rx960_tgt, $I11, 4
    ne $S10, "rule", rx960_fail
    add rx960_pos, 4
  alt986_end:
    set_addr $I10, rxcap_987_fail
    ($I12, $I11) = rx960_cur."!mark_peek"($I10)
    rx960_cur."!cursor_pos"($I11)
    ($P10) = rx960_cur."!cursor_start"()
    $P10."!cursor_pass"(rx960_pos, "")
    rx960_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_987_done
  rxcap_987_fail:
    goto rx960_fail
  rxcap_987_done:
  # rx subrule "ws" subtype=method negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."ws"()
    unless $P10, rx960_fail
    rx960_pos = $P10."pos"()
.annotate 'line', 440
  # rx subrule "deflongname" subtype=capture negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."deflongname"()
    unless $P10, rx960_fail
    rx960_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx960_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."ws"()
    unless $P10, rx960_fail
    rx960_pos = $P10."pos"()
.annotate 'line', 441
  # rx subrule "newpad" subtype=method negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."newpad"()
    unless $P10, rx960_fail
    rx960_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."ws"()
    unless $P10, rx960_fail
    rx960_pos = $P10."pos"()
.annotate 'line', 442
  # rx rxquantr991 ** 0..1
    set_addr $I10, rxquantr991_done
    rx960_cur."!mark_push"(0, rx960_pos, $I10)
  rxquantr991_loop:
  # rx subrule "ws" subtype=method negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."ws"()
    unless $P10, rx960_fail
    rx960_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx960_pos, 1
    gt $I11, rx960_eos, rx960_fail
    sub $I11, rx960_pos, rx960_off
    ord $I11, rx960_tgt, $I11
    ne $I11, 40, rx960_fail
    add rx960_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."ws"()
    unless $P10, rx960_fail
    rx960_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."signature"()
    unless $P10, rx960_fail
    rx960_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx960_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."ws"()
    unless $P10, rx960_fail
    rx960_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx960_pos, 1
    gt $I11, rx960_eos, rx960_fail
    sub $I11, rx960_pos, rx960_off
    ord $I11, rx960_tgt, $I11
    ne $I11, 41, rx960_fail
    add rx960_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."ws"()
    unless $P10, rx960_fail
    rx960_pos = $P10."pos"()
    set_addr $I10, rxquantr991_done
    (rx960_rep) = rx960_cur."!mark_commit"($I10)
  rxquantr991_done:
  # rx subrule "ws" subtype=method negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."ws"()
    unless $P10, rx960_fail
    rx960_pos = $P10."pos"()
.annotate 'line', 443
  # rx reduce name="regex_declarator" key="open"
    rx960_cur."!cursor_pos"(rx960_pos)
    rx960_cur."!reduce"("regex_declarator", "open")
  # rx subrule "ws" subtype=method negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."ws"()
    unless $P10, rx960_fail
    rx960_pos = $P10."pos"()
.annotate 'line', 444
  # rx literal  "{"
    add $I11, rx960_pos, 1
    gt $I11, rx960_eos, rx960_fail
    sub $I11, rx960_pos, rx960_off
    ord $I11, rx960_tgt, $I11
    ne $I11, 123, rx960_fail
    add rx960_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."LANG"("Regex", "nibbler")
    unless $P10, rx960_fail
    rx960_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx960_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx960_pos, 1
    gt $I11, rx960_eos, rx960_fail
    sub $I11, rx960_pos, rx960_off
    ord $I11, rx960_tgt, $I11
    ne $I11, 125, rx960_fail
    add rx960_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."ENDSTMT"()
    unless $P10, rx960_fail
  # rx subrule "ws" subtype=method negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."ws"()
    unless $P10, rx960_fail
    rx960_pos = $P10."pos"()
  alt966_end:
.annotate 'line', 445
  # rx subrule "ws" subtype=method negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."ws"()
    unless $P10, rx960_fail
    rx960_pos = $P10."pos"()
.annotate 'line', 430
  # rx pass
    rx960_cur."!cursor_pass"(rx960_pos, "regex_declarator")
    if_null rx960_debug, debug_781
    rx960_cur."!cursor_debug"("PASS", "regex_declarator", " at pos=", rx960_pos)
  debug_781:
    .return (rx960_cur)
  rx960_restart:
.annotate 'line', 4
    if_null rx960_debug, debug_782
    rx960_cur."!cursor_debug"("NEXT", "regex_declarator")
  debug_782:
  rx960_fail:
    (rx960_rep, rx960_pos, $I10, $P10) = rx960_cur."!mark_fail"(0)
    lt rx960_pos, -1, rx960_done
    eq rx960_pos, -1, rx960_fail
    jump $I10
  rx960_done:
    rx960_cur."!cursor_fail"()
    if_null rx960_debug, debug_783
    rx960_cur."!cursor_debug"("FAIL", "regex_declarator")
  debug_783:
    .return (rx960_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__regex_declarator"  :nsentry("!PREFIX__regex_declarator") :subid("203_1298325448.42642") :method
.annotate 'line', 4
    $P962 = self."!PREFIX__!subrule"("ws", "")
    new $P963, "ResizablePMCArray"
    push $P963, $P962
    .return ($P963)
.end


.namespace ["NQP";"Grammar"]
.sub "dotty"  :subid("204_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1001_tgt
    .local int rx1001_pos
    .local int rx1001_off
    .local int rx1001_eos
    .local int rx1001_rep
    .local pmc rx1001_cur
    .local pmc rx1001_debug
    (rx1001_cur, rx1001_pos, rx1001_tgt, $I10) = self."!cursor_start"()
    rx1001_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1001_cur
    .local pmc match
    .lex "$/", match
    length rx1001_eos, rx1001_tgt
    gt rx1001_pos, rx1001_eos, rx1001_done
    set rx1001_off, 0
    lt rx1001_pos, 2, rx1001_start
    sub rx1001_off, rx1001_pos, 1
    substr rx1001_tgt, rx1001_tgt, rx1001_off
  rx1001_start:
    eq $I10, 1, rx1001_restart
    if_null rx1001_debug, debug_784
    rx1001_cur."!cursor_debug"("START", "dotty")
  debug_784:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1005_done
    goto rxscan1005_scan
  rxscan1005_loop:
    (rx1001_pos) = rx1001_cur."from"()
    inc rx1001_pos
    rx1001_cur."!cursor_from"(rx1001_pos)
    ge rx1001_pos, rx1001_eos, rxscan1005_done
  rxscan1005_scan:
    set_addr $I10, rxscan1005_loop
    rx1001_cur."!mark_push"(0, rx1001_pos, $I10)
  rxscan1005_done:
.annotate 'line', 449
  # rx literal  "."
    add $I11, rx1001_pos, 1
    gt $I11, rx1001_eos, rx1001_fail
    sub $I11, rx1001_pos, rx1001_off
    ord $I11, rx1001_tgt, $I11
    ne $I11, 46, rx1001_fail
    add rx1001_pos, 1
  alt1006_0:
.annotate 'line', 450
    set_addr $I10, alt1006_1
    rx1001_cur."!mark_push"(0, rx1001_pos, $I10)
  # rx subrule "deflongname" subtype=capture negate=
    rx1001_cur."!cursor_pos"(rx1001_pos)
    $P10 = rx1001_cur."deflongname"()
    unless $P10, rx1001_fail
    rx1001_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname=deflongname")
    rx1001_pos = $P10."pos"()
    goto alt1006_end
  alt1006_1:
.annotate 'line', 451
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1001_pos, rx1001_off
    substr $S10, rx1001_tgt, $I10, 1
    index $I11, "'\"", $S10
    lt $I11, 0, rx1001_fail
  # rx subrule "quote" subtype=capture negate=
    rx1001_cur."!cursor_pos"(rx1001_pos)
    $P10 = rx1001_cur."quote"()
    unless $P10, rx1001_fail
    rx1001_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1001_pos = $P10."pos"()
  alt1007_0:
.annotate 'line', 452
    set_addr $I10, alt1007_1
    rx1001_cur."!mark_push"(0, rx1001_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1001_pos, rx1001_off
    substr $S10, rx1001_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1001_fail
    goto alt1007_end
  alt1007_1:
  # rx subrule "panic" subtype=method negate=
    rx1001_cur."!cursor_pos"(rx1001_pos)
    $P10 = rx1001_cur."panic"("Quoted method name requires parenthesized arguments")
    unless $P10, rx1001_fail
    rx1001_pos = $P10."pos"()
  alt1007_end:
  alt1006_end:
.annotate 'line', 458
  # rx rxquantr1008 ** 0..1
    set_addr $I10, rxquantr1008_done
    rx1001_cur."!mark_push"(0, rx1001_pos, $I10)
  rxquantr1008_loop:
  alt1009_0:
.annotate 'line', 455
    set_addr $I10, alt1009_1
    rx1001_cur."!mark_push"(0, rx1001_pos, $I10)
.annotate 'line', 456
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1001_pos, rx1001_off
    substr $S10, rx1001_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1001_fail
  # rx subrule "args" subtype=capture negate=
    rx1001_cur."!cursor_pos"(rx1001_pos)
    $P10 = rx1001_cur."args"()
    unless $P10, rx1001_fail
    rx1001_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1001_pos = $P10."pos"()
    goto alt1009_end
  alt1009_1:
.annotate 'line', 457
  # rx literal  ":"
    add $I11, rx1001_pos, 1
    gt $I11, rx1001_eos, rx1001_fail
    sub $I11, rx1001_pos, rx1001_off
    ord $I11, rx1001_tgt, $I11
    ne $I11, 58, rx1001_fail
    add rx1001_pos, 1
  # rx charclass s
    ge rx1001_pos, rx1001_eos, rx1001_fail
    sub $I10, rx1001_pos, rx1001_off
    is_cclass $I11, 32, rx1001_tgt, $I10
    unless $I11, rx1001_fail
    inc rx1001_pos
  # rx subrule "arglist" subtype=capture negate=
    rx1001_cur."!cursor_pos"(rx1001_pos)
    $P10 = rx1001_cur."arglist"()
    unless $P10, rx1001_fail
    rx1001_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1001_pos = $P10."pos"()
  alt1009_end:
.annotate 'line', 458
    set_addr $I10, rxquantr1008_done
    (rx1001_rep) = rx1001_cur."!mark_commit"($I10)
  rxquantr1008_done:
.annotate 'line', 448
  # rx pass
    rx1001_cur."!cursor_pass"(rx1001_pos, "dotty")
    if_null rx1001_debug, debug_785
    rx1001_cur."!cursor_debug"("PASS", "dotty", " at pos=", rx1001_pos)
  debug_785:
    .return (rx1001_cur)
  rx1001_restart:
.annotate 'line', 4
    if_null rx1001_debug, debug_786
    rx1001_cur."!cursor_debug"("NEXT", "dotty")
  debug_786:
  rx1001_fail:
    (rx1001_rep, rx1001_pos, $I10, $P10) = rx1001_cur."!mark_fail"(0)
    lt rx1001_pos, -1, rx1001_done
    eq rx1001_pos, -1, rx1001_fail
    jump $I10
  rx1001_done:
    rx1001_cur."!cursor_fail"()
    if_null rx1001_debug, debug_787
    rx1001_cur."!cursor_debug"("FAIL", "dotty")
  debug_787:
    .return (rx1001_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__dotty"  :nsentry("!PREFIX__dotty") :subid("205_1298325448.42642") :method
.annotate 'line', 4
    $P1003 = self."!PREFIX__!subrule"("deflongname", ".")
    new $P1004, "ResizablePMCArray"
    push $P1004, "'"
    push $P1004, "\""
    push $P1004, $P1003
    .return ($P1004)
.end


.namespace ["NQP";"Grammar"]
.sub "term"  :subid("206_1298325448.42642")
    .param pmc param_1011
.annotate 'line', 462
    .lex "self", param_1011
    $P1012 = param_1011."!protoregex"("term")
    .return ($P1012)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term"  :subid("207_1298325448.42642")
    .param pmc param_1014
.annotate 'line', 462
    .lex "self", param_1014
    $P1015 = param_1014."!PREFIX__!protoregex"("term")
    .return ($P1015)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<self>"  :subid("208_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1017_tgt
    .local int rx1017_pos
    .local int rx1017_off
    .local int rx1017_eos
    .local int rx1017_rep
    .local pmc rx1017_cur
    .local pmc rx1017_debug
    (rx1017_cur, rx1017_pos, rx1017_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1017_cur
    .local pmc match
    .lex "$/", match
    length rx1017_eos, rx1017_tgt
    gt rx1017_pos, rx1017_eos, rx1017_done
    set rx1017_off, 0
    lt rx1017_pos, 2, rx1017_start
    sub rx1017_off, rx1017_pos, 1
    substr rx1017_tgt, rx1017_tgt, rx1017_off
  rx1017_start:
    eq $I10, 1, rx1017_restart
    if_null rx1017_debug, debug_788
    rx1017_cur."!cursor_debug"("START", "term:sym<self>")
  debug_788:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1020_done
    goto rxscan1020_scan
  rxscan1020_loop:
    (rx1017_pos) = rx1017_cur."from"()
    inc rx1017_pos
    rx1017_cur."!cursor_from"(rx1017_pos)
    ge rx1017_pos, rx1017_eos, rxscan1020_done
  rxscan1020_scan:
    set_addr $I10, rxscan1020_loop
    rx1017_cur."!mark_push"(0, rx1017_pos, $I10)
  rxscan1020_done:
.annotate 'line', 464
  # rx subcapture "sym"
    set_addr $I10, rxcap_1021_fail
    rx1017_cur."!mark_push"(0, rx1017_pos, $I10)
  # rx literal  "self"
    add $I11, rx1017_pos, 4
    gt $I11, rx1017_eos, rx1017_fail
    sub $I11, rx1017_pos, rx1017_off
    substr $S10, rx1017_tgt, $I11, 4
    ne $S10, "self", rx1017_fail
    add rx1017_pos, 4
    set_addr $I10, rxcap_1021_fail
    ($I12, $I11) = rx1017_cur."!mark_peek"($I10)
    rx1017_cur."!cursor_pos"($I11)
    ($P10) = rx1017_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1017_pos, "")
    rx1017_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1021_done
  rxcap_1021_fail:
    goto rx1017_fail
  rxcap_1021_done:
  # rxanchor rwb
    le rx1017_pos, 0, rx1017_fail
    sub $I10, rx1017_pos, rx1017_off
    is_cclass $I11, 8192, rx1017_tgt, $I10
    if $I11, rx1017_fail
    dec $I10
    is_cclass $I11, 8192, rx1017_tgt, $I10
    unless $I11, rx1017_fail
  # rx pass
    rx1017_cur."!cursor_pass"(rx1017_pos, "term:sym<self>")
    if_null rx1017_debug, debug_789
    rx1017_cur."!cursor_debug"("PASS", "term:sym<self>", " at pos=", rx1017_pos)
  debug_789:
    .return (rx1017_cur)
  rx1017_restart:
.annotate 'line', 4
    if_null rx1017_debug, debug_790
    rx1017_cur."!cursor_debug"("NEXT", "term:sym<self>")
  debug_790:
  rx1017_fail:
    (rx1017_rep, rx1017_pos, $I10, $P10) = rx1017_cur."!mark_fail"(0)
    lt rx1017_pos, -1, rx1017_done
    eq rx1017_pos, -1, rx1017_fail
    jump $I10
  rx1017_done:
    rx1017_cur."!cursor_fail"()
    if_null rx1017_debug, debug_791
    rx1017_cur."!cursor_debug"("FAIL", "term:sym<self>")
  debug_791:
    .return (rx1017_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<self>"  :nsentry("!PREFIX__term:sym<self>") :subid("209_1298325448.42642") :method
.annotate 'line', 4
    new $P1019, "ResizablePMCArray"
    push $P1019, "self"
    .return ($P1019)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<identifier>"  :subid("210_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1023_tgt
    .local int rx1023_pos
    .local int rx1023_off
    .local int rx1023_eos
    .local int rx1023_rep
    .local pmc rx1023_cur
    .local pmc rx1023_debug
    (rx1023_cur, rx1023_pos, rx1023_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1023_cur
    .local pmc match
    .lex "$/", match
    length rx1023_eos, rx1023_tgt
    gt rx1023_pos, rx1023_eos, rx1023_done
    set rx1023_off, 0
    lt rx1023_pos, 2, rx1023_start
    sub rx1023_off, rx1023_pos, 1
    substr rx1023_tgt, rx1023_tgt, rx1023_off
  rx1023_start:
    eq $I10, 1, rx1023_restart
    if_null rx1023_debug, debug_792
    rx1023_cur."!cursor_debug"("START", "term:sym<identifier>")
  debug_792:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1027_done
    goto rxscan1027_scan
  rxscan1027_loop:
    (rx1023_pos) = rx1023_cur."from"()
    inc rx1023_pos
    rx1023_cur."!cursor_from"(rx1023_pos)
    ge rx1023_pos, rx1023_eos, rxscan1027_done
  rxscan1027_scan:
    set_addr $I10, rxscan1027_loop
    rx1023_cur."!mark_push"(0, rx1023_pos, $I10)
  rxscan1027_done:
.annotate 'line', 467
  # rx subrule "deflongname" subtype=capture negate=
    rx1023_cur."!cursor_pos"(rx1023_pos)
    $P10 = rx1023_cur."deflongname"()
    unless $P10, rx1023_fail
    rx1023_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1023_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1023_pos, rx1023_off
    substr $S10, rx1023_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1023_fail
  # rx subrule "args" subtype=capture negate=
    rx1023_cur."!cursor_pos"(rx1023_pos)
    $P10 = rx1023_cur."args"()
    unless $P10, rx1023_fail
    rx1023_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1023_pos = $P10."pos"()
.annotate 'line', 466
  # rx pass
    rx1023_cur."!cursor_pass"(rx1023_pos, "term:sym<identifier>")
    if_null rx1023_debug, debug_793
    rx1023_cur."!cursor_debug"("PASS", "term:sym<identifier>", " at pos=", rx1023_pos)
  debug_793:
    .return (rx1023_cur)
  rx1023_restart:
.annotate 'line', 4
    if_null rx1023_debug, debug_794
    rx1023_cur."!cursor_debug"("NEXT", "term:sym<identifier>")
  debug_794:
  rx1023_fail:
    (rx1023_rep, rx1023_pos, $I10, $P10) = rx1023_cur."!mark_fail"(0)
    lt rx1023_pos, -1, rx1023_done
    eq rx1023_pos, -1, rx1023_fail
    jump $I10
  rx1023_done:
    rx1023_cur."!cursor_fail"()
    if_null rx1023_debug, debug_795
    rx1023_cur."!cursor_debug"("FAIL", "term:sym<identifier>")
  debug_795:
    .return (rx1023_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<identifier>"  :nsentry("!PREFIX__term:sym<identifier>") :subid("211_1298325448.42642") :method
.annotate 'line', 4
    $P1025 = self."!PREFIX__!subrule"("deflongname", "")
    new $P1026, "ResizablePMCArray"
    push $P1026, $P1025
    .return ($P1026)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<name>"  :subid("212_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1029_tgt
    .local int rx1029_pos
    .local int rx1029_off
    .local int rx1029_eos
    .local int rx1029_rep
    .local pmc rx1029_cur
    .local pmc rx1029_debug
    (rx1029_cur, rx1029_pos, rx1029_tgt, $I10) = self."!cursor_start"()
    rx1029_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1029_cur
    .local pmc match
    .lex "$/", match
    length rx1029_eos, rx1029_tgt
    gt rx1029_pos, rx1029_eos, rx1029_done
    set rx1029_off, 0
    lt rx1029_pos, 2, rx1029_start
    sub rx1029_off, rx1029_pos, 1
    substr rx1029_tgt, rx1029_tgt, rx1029_off
  rx1029_start:
    eq $I10, 1, rx1029_restart
    if_null rx1029_debug, debug_796
    rx1029_cur."!cursor_debug"("START", "term:sym<name>")
  debug_796:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1033_done
    goto rxscan1033_scan
  rxscan1033_loop:
    (rx1029_pos) = rx1029_cur."from"()
    inc rx1029_pos
    rx1029_cur."!cursor_from"(rx1029_pos)
    ge rx1029_pos, rx1029_eos, rxscan1033_done
  rxscan1033_scan:
    set_addr $I10, rxscan1033_loop
    rx1029_cur."!mark_push"(0, rx1029_pos, $I10)
  rxscan1033_done:
.annotate 'line', 471
  # rx subrule "name" subtype=capture negate=
    rx1029_cur."!cursor_pos"(rx1029_pos)
    $P10 = rx1029_cur."name"()
    unless $P10, rx1029_fail
    rx1029_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1029_pos = $P10."pos"()
  # rx rxquantr1034 ** 0..1
    set_addr $I10, rxquantr1034_done
    rx1029_cur."!mark_push"(0, rx1029_pos, $I10)
  rxquantr1034_loop:
  # rx subrule "args" subtype=capture negate=
    rx1029_cur."!cursor_pos"(rx1029_pos)
    $P10 = rx1029_cur."args"()
    unless $P10, rx1029_fail
    goto rxsubrule1035_pass
  rxsubrule1035_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1029_fail
  rxsubrule1035_pass:
    set_addr $I10, rxsubrule1035_back
    rx1029_cur."!mark_push"(0, rx1029_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1029_pos = $P10."pos"()
    set_addr $I10, rxquantr1034_done
    (rx1029_rep) = rx1029_cur."!mark_commit"($I10)
  rxquantr1034_done:
.annotate 'line', 470
  # rx pass
    rx1029_cur."!cursor_pass"(rx1029_pos, "term:sym<name>")
    if_null rx1029_debug, debug_797
    rx1029_cur."!cursor_debug"("PASS", "term:sym<name>", " at pos=", rx1029_pos)
  debug_797:
    .return (rx1029_cur)
  rx1029_restart:
.annotate 'line', 4
    if_null rx1029_debug, debug_798
    rx1029_cur."!cursor_debug"("NEXT", "term:sym<name>")
  debug_798:
  rx1029_fail:
    (rx1029_rep, rx1029_pos, $I10, $P10) = rx1029_cur."!mark_fail"(0)
    lt rx1029_pos, -1, rx1029_done
    eq rx1029_pos, -1, rx1029_fail
    jump $I10
  rx1029_done:
    rx1029_cur."!cursor_fail"()
    if_null rx1029_debug, debug_799
    rx1029_cur."!cursor_debug"("FAIL", "term:sym<name>")
  debug_799:
    .return (rx1029_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<name>"  :nsentry("!PREFIX__term:sym<name>") :subid("213_1298325448.42642") :method
.annotate 'line', 4
    $P1031 = self."!PREFIX__!subrule"("name", "")
    new $P1032, "ResizablePMCArray"
    push $P1032, $P1031
    .return ($P1032)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<pir::op>"  :subid("214_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1037_tgt
    .local int rx1037_pos
    .local int rx1037_off
    .local int rx1037_eos
    .local int rx1037_rep
    .local pmc rx1037_cur
    .local pmc rx1037_debug
    (rx1037_cur, rx1037_pos, rx1037_tgt, $I10) = self."!cursor_start"()
    rx1037_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1037_cur
    .local pmc match
    .lex "$/", match
    length rx1037_eos, rx1037_tgt
    gt rx1037_pos, rx1037_eos, rx1037_done
    set rx1037_off, 0
    lt rx1037_pos, 2, rx1037_start
    sub rx1037_off, rx1037_pos, 1
    substr rx1037_tgt, rx1037_tgt, rx1037_off
  rx1037_start:
    eq $I10, 1, rx1037_restart
    if_null rx1037_debug, debug_800
    rx1037_cur."!cursor_debug"("START", "term:sym<pir::op>")
  debug_800:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1040_done
    goto rxscan1040_scan
  rxscan1040_loop:
    (rx1037_pos) = rx1037_cur."from"()
    inc rx1037_pos
    rx1037_cur."!cursor_from"(rx1037_pos)
    ge rx1037_pos, rx1037_eos, rxscan1040_done
  rxscan1040_scan:
    set_addr $I10, rxscan1040_loop
    rx1037_cur."!mark_push"(0, rx1037_pos, $I10)
  rxscan1040_done:
.annotate 'line', 475
  # rx literal  "pir::"
    add $I11, rx1037_pos, 5
    gt $I11, rx1037_eos, rx1037_fail
    sub $I11, rx1037_pos, rx1037_off
    substr $S10, rx1037_tgt, $I11, 5
    ne $S10, "pir::", rx1037_fail
    add rx1037_pos, 5
  # rx subcapture "op"
    set_addr $I10, rxcap_1041_fail
    rx1037_cur."!mark_push"(0, rx1037_pos, $I10)
  # rx charclass_q w r 1..-1
    sub $I10, rx1037_pos, rx1037_off
    find_not_cclass $I11, 8192, rx1037_tgt, $I10, rx1037_eos
    add $I12, $I10, 1
    lt $I11, $I12, rx1037_fail
    add rx1037_pos, rx1037_off, $I11
    set_addr $I10, rxcap_1041_fail
    ($I12, $I11) = rx1037_cur."!mark_peek"($I10)
    rx1037_cur."!cursor_pos"($I11)
    ($P10) = rx1037_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1037_pos, "")
    rx1037_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("op")
    goto rxcap_1041_done
  rxcap_1041_fail:
    goto rx1037_fail
  rxcap_1041_done:
  # rx rxquantr1042 ** 0..1
    set_addr $I10, rxquantr1042_done
    rx1037_cur."!mark_push"(0, rx1037_pos, $I10)
  rxquantr1042_loop:
  # rx subrule "args" subtype=capture negate=
    rx1037_cur."!cursor_pos"(rx1037_pos)
    $P10 = rx1037_cur."args"()
    unless $P10, rx1037_fail
    goto rxsubrule1043_pass
  rxsubrule1043_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1037_fail
  rxsubrule1043_pass:
    set_addr $I10, rxsubrule1043_back
    rx1037_cur."!mark_push"(0, rx1037_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1037_pos = $P10."pos"()
    set_addr $I10, rxquantr1042_done
    (rx1037_rep) = rx1037_cur."!mark_commit"($I10)
  rxquantr1042_done:
.annotate 'line', 474
  # rx pass
    rx1037_cur."!cursor_pass"(rx1037_pos, "term:sym<pir::op>")
    if_null rx1037_debug, debug_801
    rx1037_cur."!cursor_debug"("PASS", "term:sym<pir::op>", " at pos=", rx1037_pos)
  debug_801:
    .return (rx1037_cur)
  rx1037_restart:
.annotate 'line', 4
    if_null rx1037_debug, debug_802
    rx1037_cur."!cursor_debug"("NEXT", "term:sym<pir::op>")
  debug_802:
  rx1037_fail:
    (rx1037_rep, rx1037_pos, $I10, $P10) = rx1037_cur."!mark_fail"(0)
    lt rx1037_pos, -1, rx1037_done
    eq rx1037_pos, -1, rx1037_fail
    jump $I10
  rx1037_done:
    rx1037_cur."!cursor_fail"()
    if_null rx1037_debug, debug_803
    rx1037_cur."!cursor_debug"("FAIL", "term:sym<pir::op>")
  debug_803:
    .return (rx1037_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<pir::op>"  :nsentry("!PREFIX__term:sym<pir::op>") :subid("215_1298325448.42642") :method
.annotate 'line', 4
    new $P1039, "ResizablePMCArray"
    push $P1039, "pir::"
    .return ($P1039)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<onlystar>"  :subid("216_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .const 'Sub' $P1053 = "218_1298325448.42642" 
    capture_lex $P1053
    .local string rx1045_tgt
    .local int rx1045_pos
    .local int rx1045_off
    .local int rx1045_eos
    .local int rx1045_rep
    .local pmc rx1045_cur
    .local pmc rx1045_debug
    (rx1045_cur, rx1045_pos, rx1045_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1045_cur
    .local pmc match
    .lex "$/", match
    length rx1045_eos, rx1045_tgt
    gt rx1045_pos, rx1045_eos, rx1045_done
    set rx1045_off, 0
    lt rx1045_pos, 2, rx1045_start
    sub rx1045_off, rx1045_pos, 1
    substr rx1045_tgt, rx1045_tgt, rx1045_off
  rx1045_start:
    eq $I10, 1, rx1045_restart
    if_null rx1045_debug, debug_804
    rx1045_cur."!cursor_debug"("START", "term:sym<onlystar>")
  debug_804:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1048_done
    goto rxscan1048_scan
  rxscan1048_loop:
    (rx1045_pos) = rx1045_cur."from"()
    inc rx1045_pos
    rx1045_cur."!cursor_from"(rx1045_pos)
    ge rx1045_pos, rx1045_eos, rxscan1048_done
  rxscan1048_scan:
    set_addr $I10, rxscan1048_loop
    rx1045_cur."!mark_push"(0, rx1045_pos, $I10)
  rxscan1048_done:
.annotate 'line', 479
  # rx literal  "{*}"
    add $I11, rx1045_pos, 3
    gt $I11, rx1045_eos, rx1045_fail
    sub $I11, rx1045_pos, rx1045_off
    substr $S10, rx1045_tgt, $I11, 3
    ne $S10, "{*}", rx1045_fail
    add rx1045_pos, 3
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1045_cur."!cursor_pos"(rx1045_pos)
    $P10 = rx1045_cur."ENDSTMT"()
    unless $P10, rx1045_fail
  alt1049_0:
.annotate 'line', 480
    set_addr $I10, alt1049_1
    rx1045_cur."!mark_push"(0, rx1045_pos, $I10)
    rx1045_cur."!cursor_pos"(rx1045_pos)
    find_lex $P1050, unicode:"$\x{a2}"
    $P1051 = $P1050."MATCH"()
    store_lex "$/", $P1051
    .const 'Sub' $P1053 = "218_1298325448.42642" 
    capture_lex $P1053
    $P1057 = $P1053()
    unless $P1057, rx1045_fail
    goto alt1049_end
  alt1049_1:
  # rx subrule "panic" subtype=method negate=
    rx1045_cur."!cursor_pos"(rx1045_pos)
    $P10 = rx1045_cur."panic"("{*} may only appear in proto")
    unless $P10, rx1045_fail
    rx1045_pos = $P10."pos"()
  alt1049_end:
.annotate 'line', 478
  # rx pass
    rx1045_cur."!cursor_pass"(rx1045_pos, "term:sym<onlystar>")
    if_null rx1045_debug, debug_807
    rx1045_cur."!cursor_debug"("PASS", "term:sym<onlystar>", " at pos=", rx1045_pos)
  debug_807:
    .return (rx1045_cur)
  rx1045_restart:
.annotate 'line', 4
    if_null rx1045_debug, debug_808
    rx1045_cur."!cursor_debug"("NEXT", "term:sym<onlystar>")
  debug_808:
  rx1045_fail:
    (rx1045_rep, rx1045_pos, $I10, $P10) = rx1045_cur."!mark_fail"(0)
    lt rx1045_pos, -1, rx1045_done
    eq rx1045_pos, -1, rx1045_fail
    jump $I10
  rx1045_done:
    rx1045_cur."!cursor_fail"()
    if_null rx1045_debug, debug_809
    rx1045_cur."!cursor_debug"("FAIL", "term:sym<onlystar>")
  debug_809:
    .return (rx1045_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<onlystar>"  :nsentry("!PREFIX__term:sym<onlystar>") :subid("217_1298325448.42642") :method
.annotate 'line', 4
    new $P1047, "ResizablePMCArray"
    push $P1047, "{*}"
    .return ($P1047)
.end


.namespace ["NQP";"Grammar"]
.sub "_block1052"  :anon :subid("218_1298325448.42642") :outer("216_1298325448.42642")
.annotate 'line', 480
    find_dynamic_lex $P1054, "$*MULTINESS"
    unless_null $P1054, vivify_805
    get_hll_global $P1054, "$MULTINESS"
    unless_null $P1054, vivify_806
    die "Contextual $*MULTINESS not found"
  vivify_806:
  vivify_805:
    set $S1055, $P1054
    iseq $I1056, $S1055, "proto"
    .return ($I1056)
.end


.namespace ["NQP";"Grammar"]
.sub "args"  :subid("219_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1059_tgt
    .local int rx1059_pos
    .local int rx1059_off
    .local int rx1059_eos
    .local int rx1059_rep
    .local pmc rx1059_cur
    .local pmc rx1059_debug
    (rx1059_cur, rx1059_pos, rx1059_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1059_cur
    .local pmc match
    .lex "$/", match
    length rx1059_eos, rx1059_tgt
    gt rx1059_pos, rx1059_eos, rx1059_done
    set rx1059_off, 0
    lt rx1059_pos, 2, rx1059_start
    sub rx1059_off, rx1059_pos, 1
    substr rx1059_tgt, rx1059_tgt, rx1059_off
  rx1059_start:
    eq $I10, 1, rx1059_restart
    if_null rx1059_debug, debug_810
    rx1059_cur."!cursor_debug"("START", "args")
  debug_810:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1063_done
    goto rxscan1063_scan
  rxscan1063_loop:
    (rx1059_pos) = rx1059_cur."from"()
    inc rx1059_pos
    rx1059_cur."!cursor_from"(rx1059_pos)
    ge rx1059_pos, rx1059_eos, rxscan1063_done
  rxscan1063_scan:
    set_addr $I10, rxscan1063_loop
    rx1059_cur."!mark_push"(0, rx1059_pos, $I10)
  rxscan1063_done:
.annotate 'line', 484
  # rx literal  "("
    add $I11, rx1059_pos, 1
    gt $I11, rx1059_eos, rx1059_fail
    sub $I11, rx1059_pos, rx1059_off
    ord $I11, rx1059_tgt, $I11
    ne $I11, 40, rx1059_fail
    add rx1059_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx1059_cur."!cursor_pos"(rx1059_pos)
    $P10 = rx1059_cur."arglist"()
    unless $P10, rx1059_fail
    rx1059_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1059_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1059_pos, 1
    gt $I11, rx1059_eos, rx1059_fail
    sub $I11, rx1059_pos, rx1059_off
    ord $I11, rx1059_tgt, $I11
    ne $I11, 41, rx1059_fail
    add rx1059_pos, 1
  # rx pass
    rx1059_cur."!cursor_pass"(rx1059_pos, "args")
    if_null rx1059_debug, debug_811
    rx1059_cur."!cursor_debug"("PASS", "args", " at pos=", rx1059_pos)
  debug_811:
    .return (rx1059_cur)
  rx1059_restart:
.annotate 'line', 4
    if_null rx1059_debug, debug_812
    rx1059_cur."!cursor_debug"("NEXT", "args")
  debug_812:
  rx1059_fail:
    (rx1059_rep, rx1059_pos, $I10, $P10) = rx1059_cur."!mark_fail"(0)
    lt rx1059_pos, -1, rx1059_done
    eq rx1059_pos, -1, rx1059_fail
    jump $I10
  rx1059_done:
    rx1059_cur."!cursor_fail"()
    if_null rx1059_debug, debug_813
    rx1059_cur."!cursor_debug"("FAIL", "args")
  debug_813:
    .return (rx1059_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__args"  :nsentry("!PREFIX__args") :subid("220_1298325448.42642") :method
.annotate 'line', 4
    $P1061 = self."!PREFIX__!subrule"("arglist", "(")
    new $P1062, "ResizablePMCArray"
    push $P1062, $P1061
    .return ($P1062)
.end


.namespace ["NQP";"Grammar"]
.sub "arglist"  :subid("221_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1065_tgt
    .local int rx1065_pos
    .local int rx1065_off
    .local int rx1065_eos
    .local int rx1065_rep
    .local pmc rx1065_cur
    .local pmc rx1065_debug
    (rx1065_cur, rx1065_pos, rx1065_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1065_cur
    .local pmc match
    .lex "$/", match
    length rx1065_eos, rx1065_tgt
    gt rx1065_pos, rx1065_eos, rx1065_done
    set rx1065_off, 0
    lt rx1065_pos, 2, rx1065_start
    sub rx1065_off, rx1065_pos, 1
    substr rx1065_tgt, rx1065_tgt, rx1065_off
  rx1065_start:
    eq $I10, 1, rx1065_restart
    if_null rx1065_debug, debug_814
    rx1065_cur."!cursor_debug"("START", "arglist")
  debug_814:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1069_done
    goto rxscan1069_scan
  rxscan1069_loop:
    (rx1065_pos) = rx1065_cur."from"()
    inc rx1065_pos
    rx1065_cur."!cursor_from"(rx1065_pos)
    ge rx1065_pos, rx1065_eos, rxscan1069_done
  rxscan1069_scan:
    set_addr $I10, rxscan1069_loop
    rx1065_cur."!mark_push"(0, rx1065_pos, $I10)
  rxscan1069_done:
.annotate 'line', 488
  # rx subrule "ws" subtype=method negate=
    rx1065_cur."!cursor_pos"(rx1065_pos)
    $P10 = rx1065_cur."ws"()
    unless $P10, rx1065_fail
    rx1065_pos = $P10."pos"()
  alt1070_0:
.annotate 'line', 489
    set_addr $I10, alt1070_1
    rx1065_cur."!mark_push"(0, rx1065_pos, $I10)
.annotate 'line', 490
  # rx subrule "EXPR" subtype=capture negate=
    rx1065_cur."!cursor_pos"(rx1065_pos)
    $P10 = rx1065_cur."EXPR"("f=")
    unless $P10, rx1065_fail
    rx1065_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1065_pos = $P10."pos"()
    goto alt1070_end
  alt1070_1:
  alt1070_end:
.annotate 'line', 487
  # rx pass
    rx1065_cur."!cursor_pass"(rx1065_pos, "arglist")
    if_null rx1065_debug, debug_815
    rx1065_cur."!cursor_debug"("PASS", "arglist", " at pos=", rx1065_pos)
  debug_815:
    .return (rx1065_cur)
  rx1065_restart:
.annotate 'line', 4
    if_null rx1065_debug, debug_816
    rx1065_cur."!cursor_debug"("NEXT", "arglist")
  debug_816:
  rx1065_fail:
    (rx1065_rep, rx1065_pos, $I10, $P10) = rx1065_cur."!mark_fail"(0)
    lt rx1065_pos, -1, rx1065_done
    eq rx1065_pos, -1, rx1065_fail
    jump $I10
  rx1065_done:
    rx1065_cur."!cursor_fail"()
    if_null rx1065_debug, debug_817
    rx1065_cur."!cursor_debug"("FAIL", "arglist")
  debug_817:
    .return (rx1065_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__arglist"  :nsentry("!PREFIX__arglist") :subid("222_1298325448.42642") :method
.annotate 'line', 4
    $P1067 = self."!PREFIX__!subrule"("ws", "")
    new $P1068, "ResizablePMCArray"
    push $P1068, $P1067
    .return ($P1068)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<value>"  :subid("223_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1072_tgt
    .local int rx1072_pos
    .local int rx1072_off
    .local int rx1072_eos
    .local int rx1072_rep
    .local pmc rx1072_cur
    .local pmc rx1072_debug
    (rx1072_cur, rx1072_pos, rx1072_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1072_cur
    .local pmc match
    .lex "$/", match
    length rx1072_eos, rx1072_tgt
    gt rx1072_pos, rx1072_eos, rx1072_done
    set rx1072_off, 0
    lt rx1072_pos, 2, rx1072_start
    sub rx1072_off, rx1072_pos, 1
    substr rx1072_tgt, rx1072_tgt, rx1072_off
  rx1072_start:
    eq $I10, 1, rx1072_restart
    if_null rx1072_debug, debug_818
    rx1072_cur."!cursor_debug"("START", "term:sym<value>")
  debug_818:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1076_done
    goto rxscan1076_scan
  rxscan1076_loop:
    (rx1072_pos) = rx1072_cur."from"()
    inc rx1072_pos
    rx1072_cur."!cursor_from"(rx1072_pos)
    ge rx1072_pos, rx1072_eos, rxscan1076_done
  rxscan1076_scan:
    set_addr $I10, rxscan1076_loop
    rx1072_cur."!mark_push"(0, rx1072_pos, $I10)
  rxscan1076_done:
.annotate 'line', 496
  # rx subrule "value" subtype=capture negate=
    rx1072_cur."!cursor_pos"(rx1072_pos)
    $P10 = rx1072_cur."value"()
    unless $P10, rx1072_fail
    rx1072_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("value")
    rx1072_pos = $P10."pos"()
  # rx pass
    rx1072_cur."!cursor_pass"(rx1072_pos, "term:sym<value>")
    if_null rx1072_debug, debug_819
    rx1072_cur."!cursor_debug"("PASS", "term:sym<value>", " at pos=", rx1072_pos)
  debug_819:
    .return (rx1072_cur)
  rx1072_restart:
.annotate 'line', 4
    if_null rx1072_debug, debug_820
    rx1072_cur."!cursor_debug"("NEXT", "term:sym<value>")
  debug_820:
  rx1072_fail:
    (rx1072_rep, rx1072_pos, $I10, $P10) = rx1072_cur."!mark_fail"(0)
    lt rx1072_pos, -1, rx1072_done
    eq rx1072_pos, -1, rx1072_fail
    jump $I10
  rx1072_done:
    rx1072_cur."!cursor_fail"()
    if_null rx1072_debug, debug_821
    rx1072_cur."!cursor_debug"("FAIL", "term:sym<value>")
  debug_821:
    .return (rx1072_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<value>"  :nsentry("!PREFIX__term:sym<value>") :subid("224_1298325448.42642") :method
.annotate 'line', 4
    $P1074 = self."!PREFIX__!subrule"("value", "")
    new $P1075, "ResizablePMCArray"
    push $P1075, $P1074
    .return ($P1075)
.end


.namespace ["NQP";"Grammar"]
.sub "value"  :subid("225_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1078_tgt
    .local int rx1078_pos
    .local int rx1078_off
    .local int rx1078_eos
    .local int rx1078_rep
    .local pmc rx1078_cur
    .local pmc rx1078_debug
    (rx1078_cur, rx1078_pos, rx1078_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1078_cur
    .local pmc match
    .lex "$/", match
    length rx1078_eos, rx1078_tgt
    gt rx1078_pos, rx1078_eos, rx1078_done
    set rx1078_off, 0
    lt rx1078_pos, 2, rx1078_start
    sub rx1078_off, rx1078_pos, 1
    substr rx1078_tgt, rx1078_tgt, rx1078_off
  rx1078_start:
    eq $I10, 1, rx1078_restart
    if_null rx1078_debug, debug_822
    rx1078_cur."!cursor_debug"("START", "value")
  debug_822:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1083_done
    goto rxscan1083_scan
  rxscan1083_loop:
    (rx1078_pos) = rx1078_cur."from"()
    inc rx1078_pos
    rx1078_cur."!cursor_from"(rx1078_pos)
    ge rx1078_pos, rx1078_eos, rxscan1083_done
  rxscan1083_scan:
    set_addr $I10, rxscan1083_loop
    rx1078_cur."!mark_push"(0, rx1078_pos, $I10)
  rxscan1083_done:
  alt1084_0:
.annotate 'line', 498
    set_addr $I10, alt1084_1
    rx1078_cur."!mark_push"(0, rx1078_pos, $I10)
.annotate 'line', 499
  # rx subrule "quote" subtype=capture negate=
    rx1078_cur."!cursor_pos"(rx1078_pos)
    $P10 = rx1078_cur."quote"()
    unless $P10, rx1078_fail
    rx1078_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1078_pos = $P10."pos"()
    goto alt1084_end
  alt1084_1:
.annotate 'line', 500
  # rx subrule "number" subtype=capture negate=
    rx1078_cur."!cursor_pos"(rx1078_pos)
    $P10 = rx1078_cur."number"()
    unless $P10, rx1078_fail
    rx1078_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("number")
    rx1078_pos = $P10."pos"()
  alt1084_end:
.annotate 'line', 498
  # rx pass
    rx1078_cur."!cursor_pass"(rx1078_pos, "value")
    if_null rx1078_debug, debug_823
    rx1078_cur."!cursor_debug"("PASS", "value", " at pos=", rx1078_pos)
  debug_823:
    .return (rx1078_cur)
  rx1078_restart:
.annotate 'line', 4
    if_null rx1078_debug, debug_824
    rx1078_cur."!cursor_debug"("NEXT", "value")
  debug_824:
  rx1078_fail:
    (rx1078_rep, rx1078_pos, $I10, $P10) = rx1078_cur."!mark_fail"(0)
    lt rx1078_pos, -1, rx1078_done
    eq rx1078_pos, -1, rx1078_fail
    jump $I10
  rx1078_done:
    rx1078_cur."!cursor_fail"()
    if_null rx1078_debug, debug_825
    rx1078_cur."!cursor_debug"("FAIL", "value")
  debug_825:
    .return (rx1078_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__value"  :nsentry("!PREFIX__value") :subid("226_1298325448.42642") :method
.annotate 'line', 4
    $P1080 = self."!PREFIX__!subrule"("number", "")
    $P1081 = self."!PREFIX__!subrule"("quote", "")
    new $P1082, "ResizablePMCArray"
    push $P1082, $P1080
    push $P1082, $P1081
    .return ($P1082)
.end


.namespace ["NQP";"Grammar"]
.sub "number"  :subid("227_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1086_tgt
    .local int rx1086_pos
    .local int rx1086_off
    .local int rx1086_eos
    .local int rx1086_rep
    .local pmc rx1086_cur
    .local pmc rx1086_debug
    (rx1086_cur, rx1086_pos, rx1086_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1086_cur
    .local pmc match
    .lex "$/", match
    length rx1086_eos, rx1086_tgt
    gt rx1086_pos, rx1086_eos, rx1086_done
    set rx1086_off, 0
    lt rx1086_pos, 2, rx1086_start
    sub rx1086_off, rx1086_pos, 1
    substr rx1086_tgt, rx1086_tgt, rx1086_off
  rx1086_start:
    eq $I10, 1, rx1086_restart
    if_null rx1086_debug, debug_826
    rx1086_cur."!cursor_debug"("START", "number")
  debug_826:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1089_done
    goto rxscan1089_scan
  rxscan1089_loop:
    (rx1086_pos) = rx1086_cur."from"()
    inc rx1086_pos
    rx1086_cur."!cursor_from"(rx1086_pos)
    ge rx1086_pos, rx1086_eos, rxscan1089_done
  rxscan1089_scan:
    set_addr $I10, rxscan1089_loop
    rx1086_cur."!mark_push"(0, rx1086_pos, $I10)
  rxscan1089_done:
.annotate 'line', 504
  # rx subcapture "sign"
    set_addr $I10, rxcap_1091_fail
    rx1086_cur."!mark_push"(0, rx1086_pos, $I10)
  # rx enumcharlist_q negate=0  r 0..1
    sub $I10, rx1086_pos, rx1086_off
    set rx1086_rep, 0
    sub $I12, rx1086_eos, rx1086_pos
    le $I12, 1, rxenumcharlistq1090_loop
    set $I12, 1
  rxenumcharlistq1090_loop:
    le $I12, 0, rxenumcharlistq1090_done
    substr $S10, rx1086_tgt, $I10, 1
    index $I11, "+-", $S10
    lt $I11, 0, rxenumcharlistq1090_done
    inc rx1086_rep
  rxenumcharlistq1090_done:
    add rx1086_pos, rx1086_pos, rx1086_rep
    set_addr $I10, rxcap_1091_fail
    ($I12, $I11) = rx1086_cur."!mark_peek"($I10)
    rx1086_cur."!cursor_pos"($I11)
    ($P10) = rx1086_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1086_pos, "")
    rx1086_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sign")
    goto rxcap_1091_done
  rxcap_1091_fail:
    goto rx1086_fail
  rxcap_1091_done:
  alt1092_0:
.annotate 'line', 505
    set_addr $I10, alt1092_1
    rx1086_cur."!mark_push"(0, rx1086_pos, $I10)
  # rx subrule "dec_number" subtype=capture negate=
    rx1086_cur."!cursor_pos"(rx1086_pos)
    $P10 = rx1086_cur."dec_number"()
    unless $P10, rx1086_fail
    rx1086_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dec_number")
    rx1086_pos = $P10."pos"()
    goto alt1092_end
  alt1092_1:
  # rx subrule "integer" subtype=capture negate=
    rx1086_cur."!cursor_pos"(rx1086_pos)
    $P10 = rx1086_cur."integer"()
    unless $P10, rx1086_fail
    rx1086_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("integer")
    rx1086_pos = $P10."pos"()
  alt1092_end:
.annotate 'line', 503
  # rx pass
    rx1086_cur."!cursor_pass"(rx1086_pos, "number")
    if_null rx1086_debug, debug_827
    rx1086_cur."!cursor_debug"("PASS", "number", " at pos=", rx1086_pos)
  debug_827:
    .return (rx1086_cur)
  rx1086_restart:
.annotate 'line', 4
    if_null rx1086_debug, debug_828
    rx1086_cur."!cursor_debug"("NEXT", "number")
  debug_828:
  rx1086_fail:
    (rx1086_rep, rx1086_pos, $I10, $P10) = rx1086_cur."!mark_fail"(0)
    lt rx1086_pos, -1, rx1086_done
    eq rx1086_pos, -1, rx1086_fail
    jump $I10
  rx1086_done:
    rx1086_cur."!cursor_fail"()
    if_null rx1086_debug, debug_829
    rx1086_cur."!cursor_debug"("FAIL", "number")
  debug_829:
    .return (rx1086_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__number"  :nsentry("!PREFIX__number") :subid("228_1298325448.42642") :method
.annotate 'line', 4
    new $P1088, "ResizablePMCArray"
    push $P1088, ""
    .return ($P1088)
.end


.namespace ["NQP";"Grammar"]
.sub "quote"  :subid("229_1298325448.42642")
    .param pmc param_1094
.annotate 'line', 508
    .lex "self", param_1094
    $P1095 = param_1094."!protoregex"("quote")
    .return ($P1095)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote"  :subid("230_1298325448.42642")
    .param pmc param_1097
.annotate 'line', 508
    .lex "self", param_1097
    $P1098 = param_1097."!PREFIX__!protoregex"("quote")
    .return ($P1098)
.end


.namespace ["NQP";"Grammar"]
.sub "quote:sym<apos>"  :subid("231_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1100_tgt
    .local int rx1100_pos
    .local int rx1100_off
    .local int rx1100_eos
    .local int rx1100_rep
    .local pmc rx1100_cur
    .local pmc rx1100_debug
    (rx1100_cur, rx1100_pos, rx1100_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1100_cur
    .local pmc match
    .lex "$/", match
    length rx1100_eos, rx1100_tgt
    gt rx1100_pos, rx1100_eos, rx1100_done
    set rx1100_off, 0
    lt rx1100_pos, 2, rx1100_start
    sub rx1100_off, rx1100_pos, 1
    substr rx1100_tgt, rx1100_tgt, rx1100_off
  rx1100_start:
    eq $I10, 1, rx1100_restart
    if_null rx1100_debug, debug_830
    rx1100_cur."!cursor_debug"("START", "quote:sym<apos>")
  debug_830:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1103_done
    goto rxscan1103_scan
  rxscan1103_loop:
    (rx1100_pos) = rx1100_cur."from"()
    inc rx1100_pos
    rx1100_cur."!cursor_from"(rx1100_pos)
    ge rx1100_pos, rx1100_eos, rxscan1103_done
  rxscan1103_scan:
    set_addr $I10, rxscan1103_loop
    rx1100_cur."!mark_push"(0, rx1100_pos, $I10)
  rxscan1103_done:
.annotate 'line', 509
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1100_pos, rx1100_off
    substr $S10, rx1100_tgt, $I10, 1
    index $I11, "'", $S10
    lt $I11, 0, rx1100_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1100_cur."!cursor_pos"(rx1100_pos)
    $P10 = rx1100_cur."quote_EXPR"(":q")
    unless $P10, rx1100_fail
    rx1100_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1100_pos = $P10."pos"()
  # rx pass
    rx1100_cur."!cursor_pass"(rx1100_pos, "quote:sym<apos>")
    if_null rx1100_debug, debug_831
    rx1100_cur."!cursor_debug"("PASS", "quote:sym<apos>", " at pos=", rx1100_pos)
  debug_831:
    .return (rx1100_cur)
  rx1100_restart:
.annotate 'line', 4
    if_null rx1100_debug, debug_832
    rx1100_cur."!cursor_debug"("NEXT", "quote:sym<apos>")
  debug_832:
  rx1100_fail:
    (rx1100_rep, rx1100_pos, $I10, $P10) = rx1100_cur."!mark_fail"(0)
    lt rx1100_pos, -1, rx1100_done
    eq rx1100_pos, -1, rx1100_fail
    jump $I10
  rx1100_done:
    rx1100_cur."!cursor_fail"()
    if_null rx1100_debug, debug_833
    rx1100_cur."!cursor_debug"("FAIL", "quote:sym<apos>")
  debug_833:
    .return (rx1100_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<apos>"  :nsentry("!PREFIX__quote:sym<apos>") :subid("232_1298325448.42642") :method
.annotate 'line', 4
    new $P1102, "ResizablePMCArray"
    push $P1102, "'"
    .return ($P1102)
.end


.namespace ["NQP";"Grammar"]
.sub "quote:sym<dblq>"  :subid("233_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1105_tgt
    .local int rx1105_pos
    .local int rx1105_off
    .local int rx1105_eos
    .local int rx1105_rep
    .local pmc rx1105_cur
    .local pmc rx1105_debug
    (rx1105_cur, rx1105_pos, rx1105_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1105_cur
    .local pmc match
    .lex "$/", match
    length rx1105_eos, rx1105_tgt
    gt rx1105_pos, rx1105_eos, rx1105_done
    set rx1105_off, 0
    lt rx1105_pos, 2, rx1105_start
    sub rx1105_off, rx1105_pos, 1
    substr rx1105_tgt, rx1105_tgt, rx1105_off
  rx1105_start:
    eq $I10, 1, rx1105_restart
    if_null rx1105_debug, debug_834
    rx1105_cur."!cursor_debug"("START", "quote:sym<dblq>")
  debug_834:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1108_done
    goto rxscan1108_scan
  rxscan1108_loop:
    (rx1105_pos) = rx1105_cur."from"()
    inc rx1105_pos
    rx1105_cur."!cursor_from"(rx1105_pos)
    ge rx1105_pos, rx1105_eos, rxscan1108_done
  rxscan1108_scan:
    set_addr $I10, rxscan1108_loop
    rx1105_cur."!mark_push"(0, rx1105_pos, $I10)
  rxscan1108_done:
.annotate 'line', 510
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1105_pos, rx1105_off
    substr $S10, rx1105_tgt, $I10, 1
    index $I11, "\"", $S10
    lt $I11, 0, rx1105_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1105_cur."!cursor_pos"(rx1105_pos)
    $P10 = rx1105_cur."quote_EXPR"(":qq")
    unless $P10, rx1105_fail
    rx1105_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1105_pos = $P10."pos"()
  # rx pass
    rx1105_cur."!cursor_pass"(rx1105_pos, "quote:sym<dblq>")
    if_null rx1105_debug, debug_835
    rx1105_cur."!cursor_debug"("PASS", "quote:sym<dblq>", " at pos=", rx1105_pos)
  debug_835:
    .return (rx1105_cur)
  rx1105_restart:
.annotate 'line', 4
    if_null rx1105_debug, debug_836
    rx1105_cur."!cursor_debug"("NEXT", "quote:sym<dblq>")
  debug_836:
  rx1105_fail:
    (rx1105_rep, rx1105_pos, $I10, $P10) = rx1105_cur."!mark_fail"(0)
    lt rx1105_pos, -1, rx1105_done
    eq rx1105_pos, -1, rx1105_fail
    jump $I10
  rx1105_done:
    rx1105_cur."!cursor_fail"()
    if_null rx1105_debug, debug_837
    rx1105_cur."!cursor_debug"("FAIL", "quote:sym<dblq>")
  debug_837:
    .return (rx1105_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<dblq>"  :nsentry("!PREFIX__quote:sym<dblq>") :subid("234_1298325448.42642") :method
.annotate 'line', 4
    new $P1107, "ResizablePMCArray"
    push $P1107, "\""
    .return ($P1107)
.end


.namespace ["NQP";"Grammar"]
.sub "quote:sym<q>"  :subid("235_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1110_tgt
    .local int rx1110_pos
    .local int rx1110_off
    .local int rx1110_eos
    .local int rx1110_rep
    .local pmc rx1110_cur
    .local pmc rx1110_debug
    (rx1110_cur, rx1110_pos, rx1110_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1110_cur
    .local pmc match
    .lex "$/", match
    length rx1110_eos, rx1110_tgt
    gt rx1110_pos, rx1110_eos, rx1110_done
    set rx1110_off, 0
    lt rx1110_pos, 2, rx1110_start
    sub rx1110_off, rx1110_pos, 1
    substr rx1110_tgt, rx1110_tgt, rx1110_off
  rx1110_start:
    eq $I10, 1, rx1110_restart
    if_null rx1110_debug, debug_838
    rx1110_cur."!cursor_debug"("START", "quote:sym<q>")
  debug_838:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1114_done
    goto rxscan1114_scan
  rxscan1114_loop:
    (rx1110_pos) = rx1110_cur."from"()
    inc rx1110_pos
    rx1110_cur."!cursor_from"(rx1110_pos)
    ge rx1110_pos, rx1110_eos, rxscan1114_done
  rxscan1114_scan:
    set_addr $I10, rxscan1114_loop
    rx1110_cur."!mark_push"(0, rx1110_pos, $I10)
  rxscan1114_done:
.annotate 'line', 511
  # rx literal  "q"
    add $I11, rx1110_pos, 1
    gt $I11, rx1110_eos, rx1110_fail
    sub $I11, rx1110_pos, rx1110_off
    ord $I11, rx1110_tgt, $I11
    ne $I11, 113, rx1110_fail
    add rx1110_pos, 1
  # rxanchor rwb
    le rx1110_pos, 0, rx1110_fail
    sub $I10, rx1110_pos, rx1110_off
    is_cclass $I11, 8192, rx1110_tgt, $I10
    if $I11, rx1110_fail
    dec $I10
    is_cclass $I11, 8192, rx1110_tgt, $I10
    unless $I11, rx1110_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1110_pos, rx1110_off
    substr $S10, rx1110_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1110_fail
  # rx subrule "ws" subtype=method negate=
    rx1110_cur."!cursor_pos"(rx1110_pos)
    $P10 = rx1110_cur."ws"()
    unless $P10, rx1110_fail
    rx1110_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1110_cur."!cursor_pos"(rx1110_pos)
    $P10 = rx1110_cur."quote_EXPR"(":q")
    unless $P10, rx1110_fail
    rx1110_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1110_pos = $P10."pos"()
  # rx pass
    rx1110_cur."!cursor_pass"(rx1110_pos, "quote:sym<q>")
    if_null rx1110_debug, debug_839
    rx1110_cur."!cursor_debug"("PASS", "quote:sym<q>", " at pos=", rx1110_pos)
  debug_839:
    .return (rx1110_cur)
  rx1110_restart:
.annotate 'line', 4
    if_null rx1110_debug, debug_840
    rx1110_cur."!cursor_debug"("NEXT", "quote:sym<q>")
  debug_840:
  rx1110_fail:
    (rx1110_rep, rx1110_pos, $I10, $P10) = rx1110_cur."!mark_fail"(0)
    lt rx1110_pos, -1, rx1110_done
    eq rx1110_pos, -1, rx1110_fail
    jump $I10
  rx1110_done:
    rx1110_cur."!cursor_fail"()
    if_null rx1110_debug, debug_841
    rx1110_cur."!cursor_debug"("FAIL", "quote:sym<q>")
  debug_841:
    .return (rx1110_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<q>"  :nsentry("!PREFIX__quote:sym<q>") :subid("236_1298325448.42642") :method
.annotate 'line', 4
    $P1112 = self."!PREFIX__!subrule"("ws", "q")
    new $P1113, "ResizablePMCArray"
    push $P1113, $P1112
    .return ($P1113)
.end


.namespace ["NQP";"Grammar"]
.sub "quote:sym<qq>"  :subid("237_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1116_tgt
    .local int rx1116_pos
    .local int rx1116_off
    .local int rx1116_eos
    .local int rx1116_rep
    .local pmc rx1116_cur
    .local pmc rx1116_debug
    (rx1116_cur, rx1116_pos, rx1116_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1116_cur
    .local pmc match
    .lex "$/", match
    length rx1116_eos, rx1116_tgt
    gt rx1116_pos, rx1116_eos, rx1116_done
    set rx1116_off, 0
    lt rx1116_pos, 2, rx1116_start
    sub rx1116_off, rx1116_pos, 1
    substr rx1116_tgt, rx1116_tgt, rx1116_off
  rx1116_start:
    eq $I10, 1, rx1116_restart
    if_null rx1116_debug, debug_842
    rx1116_cur."!cursor_debug"("START", "quote:sym<qq>")
  debug_842:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1120_done
    goto rxscan1120_scan
  rxscan1120_loop:
    (rx1116_pos) = rx1116_cur."from"()
    inc rx1116_pos
    rx1116_cur."!cursor_from"(rx1116_pos)
    ge rx1116_pos, rx1116_eos, rxscan1120_done
  rxscan1120_scan:
    set_addr $I10, rxscan1120_loop
    rx1116_cur."!mark_push"(0, rx1116_pos, $I10)
  rxscan1120_done:
.annotate 'line', 512
  # rx literal  "qq"
    add $I11, rx1116_pos, 2
    gt $I11, rx1116_eos, rx1116_fail
    sub $I11, rx1116_pos, rx1116_off
    substr $S10, rx1116_tgt, $I11, 2
    ne $S10, "qq", rx1116_fail
    add rx1116_pos, 2
  # rxanchor rwb
    le rx1116_pos, 0, rx1116_fail
    sub $I10, rx1116_pos, rx1116_off
    is_cclass $I11, 8192, rx1116_tgt, $I10
    if $I11, rx1116_fail
    dec $I10
    is_cclass $I11, 8192, rx1116_tgt, $I10
    unless $I11, rx1116_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1116_pos, rx1116_off
    substr $S10, rx1116_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1116_fail
  # rx subrule "ws" subtype=method negate=
    rx1116_cur."!cursor_pos"(rx1116_pos)
    $P10 = rx1116_cur."ws"()
    unless $P10, rx1116_fail
    rx1116_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1116_cur."!cursor_pos"(rx1116_pos)
    $P10 = rx1116_cur."quote_EXPR"(":qq")
    unless $P10, rx1116_fail
    rx1116_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1116_pos = $P10."pos"()
  # rx pass
    rx1116_cur."!cursor_pass"(rx1116_pos, "quote:sym<qq>")
    if_null rx1116_debug, debug_843
    rx1116_cur."!cursor_debug"("PASS", "quote:sym<qq>", " at pos=", rx1116_pos)
  debug_843:
    .return (rx1116_cur)
  rx1116_restart:
.annotate 'line', 4
    if_null rx1116_debug, debug_844
    rx1116_cur."!cursor_debug"("NEXT", "quote:sym<qq>")
  debug_844:
  rx1116_fail:
    (rx1116_rep, rx1116_pos, $I10, $P10) = rx1116_cur."!mark_fail"(0)
    lt rx1116_pos, -1, rx1116_done
    eq rx1116_pos, -1, rx1116_fail
    jump $I10
  rx1116_done:
    rx1116_cur."!cursor_fail"()
    if_null rx1116_debug, debug_845
    rx1116_cur."!cursor_debug"("FAIL", "quote:sym<qq>")
  debug_845:
    .return (rx1116_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<qq>"  :nsentry("!PREFIX__quote:sym<qq>") :subid("238_1298325448.42642") :method
.annotate 'line', 4
    $P1118 = self."!PREFIX__!subrule"("ws", "qq")
    new $P1119, "ResizablePMCArray"
    push $P1119, $P1118
    .return ($P1119)
.end


.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q>"  :subid("239_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1122_tgt
    .local int rx1122_pos
    .local int rx1122_off
    .local int rx1122_eos
    .local int rx1122_rep
    .local pmc rx1122_cur
    .local pmc rx1122_debug
    (rx1122_cur, rx1122_pos, rx1122_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1122_cur
    .local pmc match
    .lex "$/", match
    length rx1122_eos, rx1122_tgt
    gt rx1122_pos, rx1122_eos, rx1122_done
    set rx1122_off, 0
    lt rx1122_pos, 2, rx1122_start
    sub rx1122_off, rx1122_pos, 1
    substr rx1122_tgt, rx1122_tgt, rx1122_off
  rx1122_start:
    eq $I10, 1, rx1122_restart
    if_null rx1122_debug, debug_846
    rx1122_cur."!cursor_debug"("START", "quote:sym<Q>")
  debug_846:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1126_done
    goto rxscan1126_scan
  rxscan1126_loop:
    (rx1122_pos) = rx1122_cur."from"()
    inc rx1122_pos
    rx1122_cur."!cursor_from"(rx1122_pos)
    ge rx1122_pos, rx1122_eos, rxscan1126_done
  rxscan1126_scan:
    set_addr $I10, rxscan1126_loop
    rx1122_cur."!mark_push"(0, rx1122_pos, $I10)
  rxscan1126_done:
.annotate 'line', 513
  # rx literal  "Q"
    add $I11, rx1122_pos, 1
    gt $I11, rx1122_eos, rx1122_fail
    sub $I11, rx1122_pos, rx1122_off
    ord $I11, rx1122_tgt, $I11
    ne $I11, 81, rx1122_fail
    add rx1122_pos, 1
  # rxanchor rwb
    le rx1122_pos, 0, rx1122_fail
    sub $I10, rx1122_pos, rx1122_off
    is_cclass $I11, 8192, rx1122_tgt, $I10
    if $I11, rx1122_fail
    dec $I10
    is_cclass $I11, 8192, rx1122_tgt, $I10
    unless $I11, rx1122_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1122_pos, rx1122_off
    substr $S10, rx1122_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1122_fail
  # rx subrule "ws" subtype=method negate=
    rx1122_cur."!cursor_pos"(rx1122_pos)
    $P10 = rx1122_cur."ws"()
    unless $P10, rx1122_fail
    rx1122_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1122_cur."!cursor_pos"(rx1122_pos)
    $P10 = rx1122_cur."quote_EXPR"()
    unless $P10, rx1122_fail
    rx1122_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1122_pos = $P10."pos"()
  # rx pass
    rx1122_cur."!cursor_pass"(rx1122_pos, "quote:sym<Q>")
    if_null rx1122_debug, debug_847
    rx1122_cur."!cursor_debug"("PASS", "quote:sym<Q>", " at pos=", rx1122_pos)
  debug_847:
    .return (rx1122_cur)
  rx1122_restart:
.annotate 'line', 4
    if_null rx1122_debug, debug_848
    rx1122_cur."!cursor_debug"("NEXT", "quote:sym<Q>")
  debug_848:
  rx1122_fail:
    (rx1122_rep, rx1122_pos, $I10, $P10) = rx1122_cur."!mark_fail"(0)
    lt rx1122_pos, -1, rx1122_done
    eq rx1122_pos, -1, rx1122_fail
    jump $I10
  rx1122_done:
    rx1122_cur."!cursor_fail"()
    if_null rx1122_debug, debug_849
    rx1122_cur."!cursor_debug"("FAIL", "quote:sym<Q>")
  debug_849:
    .return (rx1122_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q>"  :nsentry("!PREFIX__quote:sym<Q>") :subid("240_1298325448.42642") :method
.annotate 'line', 4
    $P1124 = self."!PREFIX__!subrule"("ws", "Q")
    new $P1125, "ResizablePMCArray"
    push $P1125, $P1124
    .return ($P1125)
.end


.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q:PIR>"  :subid("241_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1128_tgt
    .local int rx1128_pos
    .local int rx1128_off
    .local int rx1128_eos
    .local int rx1128_rep
    .local pmc rx1128_cur
    .local pmc rx1128_debug
    (rx1128_cur, rx1128_pos, rx1128_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1128_cur
    .local pmc match
    .lex "$/", match
    length rx1128_eos, rx1128_tgt
    gt rx1128_pos, rx1128_eos, rx1128_done
    set rx1128_off, 0
    lt rx1128_pos, 2, rx1128_start
    sub rx1128_off, rx1128_pos, 1
    substr rx1128_tgt, rx1128_tgt, rx1128_off
  rx1128_start:
    eq $I10, 1, rx1128_restart
    if_null rx1128_debug, debug_850
    rx1128_cur."!cursor_debug"("START", "quote:sym<Q:PIR>")
  debug_850:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1132_done
    goto rxscan1132_scan
  rxscan1132_loop:
    (rx1128_pos) = rx1128_cur."from"()
    inc rx1128_pos
    rx1128_cur."!cursor_from"(rx1128_pos)
    ge rx1128_pos, rx1128_eos, rxscan1132_done
  rxscan1132_scan:
    set_addr $I10, rxscan1132_loop
    rx1128_cur."!mark_push"(0, rx1128_pos, $I10)
  rxscan1132_done:
.annotate 'line', 514
  # rx literal  "Q:PIR"
    add $I11, rx1128_pos, 5
    gt $I11, rx1128_eos, rx1128_fail
    sub $I11, rx1128_pos, rx1128_off
    substr $S10, rx1128_tgt, $I11, 5
    ne $S10, "Q:PIR", rx1128_fail
    add rx1128_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx1128_cur."!cursor_pos"(rx1128_pos)
    $P10 = rx1128_cur."ws"()
    unless $P10, rx1128_fail
    rx1128_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1128_cur."!cursor_pos"(rx1128_pos)
    $P10 = rx1128_cur."quote_EXPR"()
    unless $P10, rx1128_fail
    rx1128_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1128_pos = $P10."pos"()
  # rx pass
    rx1128_cur."!cursor_pass"(rx1128_pos, "quote:sym<Q:PIR>")
    if_null rx1128_debug, debug_851
    rx1128_cur."!cursor_debug"("PASS", "quote:sym<Q:PIR>", " at pos=", rx1128_pos)
  debug_851:
    .return (rx1128_cur)
  rx1128_restart:
.annotate 'line', 4
    if_null rx1128_debug, debug_852
    rx1128_cur."!cursor_debug"("NEXT", "quote:sym<Q:PIR>")
  debug_852:
  rx1128_fail:
    (rx1128_rep, rx1128_pos, $I10, $P10) = rx1128_cur."!mark_fail"(0)
    lt rx1128_pos, -1, rx1128_done
    eq rx1128_pos, -1, rx1128_fail
    jump $I10
  rx1128_done:
    rx1128_cur."!cursor_fail"()
    if_null rx1128_debug, debug_853
    rx1128_cur."!cursor_debug"("FAIL", "quote:sym<Q:PIR>")
  debug_853:
    .return (rx1128_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q:PIR>"  :nsentry("!PREFIX__quote:sym<Q:PIR>") :subid("242_1298325448.42642") :method
.annotate 'line', 4
    $P1130 = self."!PREFIX__!subrule"("ws", "Q:PIR")
    new $P1131, "ResizablePMCArray"
    push $P1131, $P1130
    .return ($P1131)
.end


.namespace ["NQP";"Grammar"]
.sub "quote:sym</ />"  :subid("243_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1134_tgt
    .local int rx1134_pos
    .local int rx1134_off
    .local int rx1134_eos
    .local int rx1134_rep
    .local pmc rx1134_cur
    .local pmc rx1134_debug
    (rx1134_cur, rx1134_pos, rx1134_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1134_cur
    .local pmc match
    .lex "$/", match
    length rx1134_eos, rx1134_tgt
    gt rx1134_pos, rx1134_eos, rx1134_done
    set rx1134_off, 0
    lt rx1134_pos, 2, rx1134_start
    sub rx1134_off, rx1134_pos, 1
    substr rx1134_tgt, rx1134_tgt, rx1134_off
  rx1134_start:
    eq $I10, 1, rx1134_restart
    if_null rx1134_debug, debug_854
    rx1134_cur."!cursor_debug"("START", "quote:sym</ />")
  debug_854:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1138_done
    goto rxscan1138_scan
  rxscan1138_loop:
    (rx1134_pos) = rx1134_cur."from"()
    inc rx1134_pos
    rx1134_cur."!cursor_from"(rx1134_pos)
    ge rx1134_pos, rx1134_eos, rxscan1138_done
  rxscan1138_scan:
    set_addr $I10, rxscan1138_loop
    rx1134_cur."!mark_push"(0, rx1134_pos, $I10)
  rxscan1138_done:
.annotate 'line', 516
  # rx literal  "/"
    add $I11, rx1134_pos, 1
    gt $I11, rx1134_eos, rx1134_fail
    sub $I11, rx1134_pos, rx1134_off
    ord $I11, rx1134_tgt, $I11
    ne $I11, 47, rx1134_fail
    add rx1134_pos, 1
.annotate 'line', 517
  # rx subrule "newpad" subtype=method negate=
    rx1134_cur."!cursor_pos"(rx1134_pos)
    $P10 = rx1134_cur."newpad"()
    unless $P10, rx1134_fail
    rx1134_pos = $P10."pos"()
.annotate 'line', 518
  # rx reduce name="quote:sym</ />" key="open"
    rx1134_cur."!cursor_pos"(rx1134_pos)
    rx1134_cur."!reduce"("quote:sym</ />", "open")
.annotate 'line', 519
  # rx subrule "LANG" subtype=capture negate=
    rx1134_cur."!cursor_pos"(rx1134_pos)
    $P10 = rx1134_cur."LANG"("Regex", "nibbler")
    unless $P10, rx1134_fail
    rx1134_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx1134_pos = $P10."pos"()
.annotate 'line', 520
  # rx literal  "/"
    add $I11, rx1134_pos, 1
    gt $I11, rx1134_eos, rx1134_fail
    sub $I11, rx1134_pos, rx1134_off
    ord $I11, rx1134_tgt, $I11
    ne $I11, 47, rx1134_fail
    add rx1134_pos, 1
.annotate 'line', 515
  # rx pass
    rx1134_cur."!cursor_pass"(rx1134_pos, "quote:sym</ />")
    if_null rx1134_debug, debug_855
    rx1134_cur."!cursor_debug"("PASS", "quote:sym</ />", " at pos=", rx1134_pos)
  debug_855:
    .return (rx1134_cur)
  rx1134_restart:
.annotate 'line', 4
    if_null rx1134_debug, debug_856
    rx1134_cur."!cursor_debug"("NEXT", "quote:sym</ />")
  debug_856:
  rx1134_fail:
    (rx1134_rep, rx1134_pos, $I10, $P10) = rx1134_cur."!mark_fail"(0)
    lt rx1134_pos, -1, rx1134_done
    eq rx1134_pos, -1, rx1134_fail
    jump $I10
  rx1134_done:
    rx1134_cur."!cursor_fail"()
    if_null rx1134_debug, debug_857
    rx1134_cur."!cursor_debug"("FAIL", "quote:sym</ />")
  debug_857:
    .return (rx1134_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym</ />"  :nsentry("!PREFIX__quote:sym</ />") :subid("244_1298325448.42642") :method
.annotate 'line', 4
    $P1136 = self."!PREFIX__!subrule"("newpad", "/")
    new $P1137, "ResizablePMCArray"
    push $P1137, $P1136
    .return ($P1137)
.end


.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<$>"  :subid("245_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1140_tgt
    .local int rx1140_pos
    .local int rx1140_off
    .local int rx1140_eos
    .local int rx1140_rep
    .local pmc rx1140_cur
    .local pmc rx1140_debug
    (rx1140_cur, rx1140_pos, rx1140_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1140_cur
    .local pmc match
    .lex "$/", match
    length rx1140_eos, rx1140_tgt
    gt rx1140_pos, rx1140_eos, rx1140_done
    set rx1140_off, 0
    lt rx1140_pos, 2, rx1140_start
    sub rx1140_off, rx1140_pos, 1
    substr rx1140_tgt, rx1140_tgt, rx1140_off
  rx1140_start:
    eq $I10, 1, rx1140_restart
    if_null rx1140_debug, debug_858
    rx1140_cur."!cursor_debug"("START", "quote_escape:sym<$>")
  debug_858:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1143_done
    goto rxscan1143_scan
  rxscan1143_loop:
    (rx1140_pos) = rx1140_cur."from"()
    inc rx1140_pos
    rx1140_cur."!cursor_from"(rx1140_pos)
    ge rx1140_pos, rx1140_eos, rxscan1143_done
  rxscan1143_scan:
    set_addr $I10, rxscan1143_loop
    rx1140_cur."!mark_push"(0, rx1140_pos, $I10)
  rxscan1143_done:
.annotate 'line', 523
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1140_pos, rx1140_off
    substr $S10, rx1140_tgt, $I10, 1
    index $I11, "$", $S10
    lt $I11, 0, rx1140_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1140_cur."!cursor_pos"(rx1140_pos)
    $P10 = rx1140_cur."quotemod_check"("s")
    unless $P10, rx1140_fail
  # rx subrule "variable" subtype=capture negate=
    rx1140_cur."!cursor_pos"(rx1140_pos)
    $P10 = rx1140_cur."variable"()
    unless $P10, rx1140_fail
    rx1140_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx1140_pos = $P10."pos"()
  # rx pass
    rx1140_cur."!cursor_pass"(rx1140_pos, "quote_escape:sym<$>")
    if_null rx1140_debug, debug_859
    rx1140_cur."!cursor_debug"("PASS", "quote_escape:sym<$>", " at pos=", rx1140_pos)
  debug_859:
    .return (rx1140_cur)
  rx1140_restart:
.annotate 'line', 4
    if_null rx1140_debug, debug_860
    rx1140_cur."!cursor_debug"("NEXT", "quote_escape:sym<$>")
  debug_860:
  rx1140_fail:
    (rx1140_rep, rx1140_pos, $I10, $P10) = rx1140_cur."!mark_fail"(0)
    lt rx1140_pos, -1, rx1140_done
    eq rx1140_pos, -1, rx1140_fail
    jump $I10
  rx1140_done:
    rx1140_cur."!cursor_fail"()
    if_null rx1140_debug, debug_861
    rx1140_cur."!cursor_debug"("FAIL", "quote_escape:sym<$>")
  debug_861:
    .return (rx1140_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<$>"  :nsentry("!PREFIX__quote_escape:sym<$>") :subid("246_1298325448.42642") :method
.annotate 'line', 4
    new $P1142, "ResizablePMCArray"
    push $P1142, "$"
    .return ($P1142)
.end


.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<{ }>"  :subid("247_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1145_tgt
    .local int rx1145_pos
    .local int rx1145_off
    .local int rx1145_eos
    .local int rx1145_rep
    .local pmc rx1145_cur
    .local pmc rx1145_debug
    (rx1145_cur, rx1145_pos, rx1145_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1145_cur
    .local pmc match
    .lex "$/", match
    length rx1145_eos, rx1145_tgt
    gt rx1145_pos, rx1145_eos, rx1145_done
    set rx1145_off, 0
    lt rx1145_pos, 2, rx1145_start
    sub rx1145_off, rx1145_pos, 1
    substr rx1145_tgt, rx1145_tgt, rx1145_off
  rx1145_start:
    eq $I10, 1, rx1145_restart
    if_null rx1145_debug, debug_862
    rx1145_cur."!cursor_debug"("START", "quote_escape:sym<{ }>")
  debug_862:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1148_done
    goto rxscan1148_scan
  rxscan1148_loop:
    (rx1145_pos) = rx1145_cur."from"()
    inc rx1145_pos
    rx1145_cur."!cursor_from"(rx1145_pos)
    ge rx1145_pos, rx1145_eos, rxscan1148_done
  rxscan1148_scan:
    set_addr $I10, rxscan1148_loop
    rx1145_cur."!mark_push"(0, rx1145_pos, $I10)
  rxscan1148_done:
.annotate 'line', 524
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1145_pos, rx1145_off
    substr $S10, rx1145_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1145_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."quotemod_check"("c")
    unless $P10, rx1145_fail
  # rx subrule "block" subtype=capture negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."block"()
    unless $P10, rx1145_fail
    rx1145_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1145_pos = $P10."pos"()
  # rx pass
    rx1145_cur."!cursor_pass"(rx1145_pos, "quote_escape:sym<{ }>")
    if_null rx1145_debug, debug_863
    rx1145_cur."!cursor_debug"("PASS", "quote_escape:sym<{ }>", " at pos=", rx1145_pos)
  debug_863:
    .return (rx1145_cur)
  rx1145_restart:
.annotate 'line', 4
    if_null rx1145_debug, debug_864
    rx1145_cur."!cursor_debug"("NEXT", "quote_escape:sym<{ }>")
  debug_864:
  rx1145_fail:
    (rx1145_rep, rx1145_pos, $I10, $P10) = rx1145_cur."!mark_fail"(0)
    lt rx1145_pos, -1, rx1145_done
    eq rx1145_pos, -1, rx1145_fail
    jump $I10
  rx1145_done:
    rx1145_cur."!cursor_fail"()
    if_null rx1145_debug, debug_865
    rx1145_cur."!cursor_debug"("FAIL", "quote_escape:sym<{ }>")
  debug_865:
    .return (rx1145_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<{ }>"  :nsentry("!PREFIX__quote_escape:sym<{ }>") :subid("248_1298325448.42642") :method
.annotate 'line', 4
    new $P1147, "ResizablePMCArray"
    push $P1147, "{"
    .return ($P1147)
.end


.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<esc>"  :subid("249_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1150_tgt
    .local int rx1150_pos
    .local int rx1150_off
    .local int rx1150_eos
    .local int rx1150_rep
    .local pmc rx1150_cur
    .local pmc rx1150_debug
    (rx1150_cur, rx1150_pos, rx1150_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1150_cur
    .local pmc match
    .lex "$/", match
    length rx1150_eos, rx1150_tgt
    gt rx1150_pos, rx1150_eos, rx1150_done
    set rx1150_off, 0
    lt rx1150_pos, 2, rx1150_start
    sub rx1150_off, rx1150_pos, 1
    substr rx1150_tgt, rx1150_tgt, rx1150_off
  rx1150_start:
    eq $I10, 1, rx1150_restart
    if_null rx1150_debug, debug_866
    rx1150_cur."!cursor_debug"("START", "quote_escape:sym<esc>")
  debug_866:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1153_done
    goto rxscan1153_scan
  rxscan1153_loop:
    (rx1150_pos) = rx1150_cur."from"()
    inc rx1150_pos
    rx1150_cur."!cursor_from"(rx1150_pos)
    ge rx1150_pos, rx1150_eos, rxscan1153_done
  rxscan1153_scan:
    set_addr $I10, rxscan1153_loop
    rx1150_cur."!mark_push"(0, rx1150_pos, $I10)
  rxscan1153_done:
.annotate 'line', 525
  # rx literal  "\\e"
    add $I11, rx1150_pos, 2
    gt $I11, rx1150_eos, rx1150_fail
    sub $I11, rx1150_pos, rx1150_off
    substr $S10, rx1150_tgt, $I11, 2
    ne $S10, "\\e", rx1150_fail
    add rx1150_pos, 2
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1150_cur."!cursor_pos"(rx1150_pos)
    $P10 = rx1150_cur."quotemod_check"("b")
    unless $P10, rx1150_fail
  # rx pass
    rx1150_cur."!cursor_pass"(rx1150_pos, "quote_escape:sym<esc>")
    if_null rx1150_debug, debug_867
    rx1150_cur."!cursor_debug"("PASS", "quote_escape:sym<esc>", " at pos=", rx1150_pos)
  debug_867:
    .return (rx1150_cur)
  rx1150_restart:
.annotate 'line', 4
    if_null rx1150_debug, debug_868
    rx1150_cur."!cursor_debug"("NEXT", "quote_escape:sym<esc>")
  debug_868:
  rx1150_fail:
    (rx1150_rep, rx1150_pos, $I10, $P10) = rx1150_cur."!mark_fail"(0)
    lt rx1150_pos, -1, rx1150_done
    eq rx1150_pos, -1, rx1150_fail
    jump $I10
  rx1150_done:
    rx1150_cur."!cursor_fail"()
    if_null rx1150_debug, debug_869
    rx1150_cur."!cursor_debug"("FAIL", "quote_escape:sym<esc>")
  debug_869:
    .return (rx1150_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<esc>"  :nsentry("!PREFIX__quote_escape:sym<esc>") :subid("250_1298325448.42642") :method
.annotate 'line', 4
    new $P1152, "ResizablePMCArray"
    push $P1152, "\\e"
    .return ($P1152)
.end


.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<( )>"  :subid("251_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1155_tgt
    .local int rx1155_pos
    .local int rx1155_off
    .local int rx1155_eos
    .local int rx1155_rep
    .local pmc rx1155_cur
    .local pmc rx1155_debug
    (rx1155_cur, rx1155_pos, rx1155_tgt, $I10) = self."!cursor_start"()
    rx1155_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx1155_cur
    .local pmc match
    .lex "$/", match
    length rx1155_eos, rx1155_tgt
    gt rx1155_pos, rx1155_eos, rx1155_done
    set rx1155_off, 0
    lt rx1155_pos, 2, rx1155_start
    sub rx1155_off, rx1155_pos, 1
    substr rx1155_tgt, rx1155_tgt, rx1155_off
  rx1155_start:
    eq $I10, 1, rx1155_restart
    if_null rx1155_debug, debug_870
    rx1155_cur."!cursor_debug"("START", "circumfix:sym<( )>")
  debug_870:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1159_done
    goto rxscan1159_scan
  rxscan1159_loop:
    (rx1155_pos) = rx1155_cur."from"()
    inc rx1155_pos
    rx1155_cur."!cursor_from"(rx1155_pos)
    ge rx1155_pos, rx1155_eos, rxscan1159_done
  rxscan1159_scan:
    set_addr $I10, rxscan1159_loop
    rx1155_cur."!mark_push"(0, rx1155_pos, $I10)
  rxscan1159_done:
.annotate 'line', 527
  # rx literal  "("
    add $I11, rx1155_pos, 1
    gt $I11, rx1155_eos, rx1155_fail
    sub $I11, rx1155_pos, rx1155_off
    ord $I11, rx1155_tgt, $I11
    ne $I11, 40, rx1155_fail
    add rx1155_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1155_cur."!cursor_pos"(rx1155_pos)
    $P10 = rx1155_cur."ws"()
    unless $P10, rx1155_fail
    rx1155_pos = $P10."pos"()
  # rx rxquantr1160 ** 0..1
    set_addr $I10, rxquantr1160_done
    rx1155_cur."!mark_push"(0, rx1155_pos, $I10)
  rxquantr1160_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx1155_cur."!cursor_pos"(rx1155_pos)
    $P10 = rx1155_cur."EXPR"()
    unless $P10, rx1155_fail
    goto rxsubrule1161_pass
  rxsubrule1161_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1155_fail
  rxsubrule1161_pass:
    set_addr $I10, rxsubrule1161_back
    rx1155_cur."!mark_push"(0, rx1155_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx1155_pos = $P10."pos"()
    set_addr $I10, rxquantr1160_done
    (rx1155_rep) = rx1155_cur."!mark_commit"($I10)
  rxquantr1160_done:
  # rx literal  ")"
    add $I11, rx1155_pos, 1
    gt $I11, rx1155_eos, rx1155_fail
    sub $I11, rx1155_pos, rx1155_off
    ord $I11, rx1155_tgt, $I11
    ne $I11, 41, rx1155_fail
    add rx1155_pos, 1
  # rx pass
    rx1155_cur."!cursor_pass"(rx1155_pos, "circumfix:sym<( )>")
    if_null rx1155_debug, debug_871
    rx1155_cur."!cursor_debug"("PASS", "circumfix:sym<( )>", " at pos=", rx1155_pos)
  debug_871:
    .return (rx1155_cur)
  rx1155_restart:
.annotate 'line', 4
    if_null rx1155_debug, debug_872
    rx1155_cur."!cursor_debug"("NEXT", "circumfix:sym<( )>")
  debug_872:
  rx1155_fail:
    (rx1155_rep, rx1155_pos, $I10, $P10) = rx1155_cur."!mark_fail"(0)
    lt rx1155_pos, -1, rx1155_done
    eq rx1155_pos, -1, rx1155_fail
    jump $I10
  rx1155_done:
    rx1155_cur."!cursor_fail"()
    if_null rx1155_debug, debug_873
    rx1155_cur."!cursor_debug"("FAIL", "circumfix:sym<( )>")
  debug_873:
    .return (rx1155_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<( )>"  :nsentry("!PREFIX__circumfix:sym<( )>") :subid("252_1298325448.42642") :method
.annotate 'line', 4
    $P1157 = self."!PREFIX__!subrule"("ws", "(")
    new $P1158, "ResizablePMCArray"
    push $P1158, $P1157
    .return ($P1158)
.end


.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<[ ]>"  :subid("253_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1163_tgt
    .local int rx1163_pos
    .local int rx1163_off
    .local int rx1163_eos
    .local int rx1163_rep
    .local pmc rx1163_cur
    .local pmc rx1163_debug
    (rx1163_cur, rx1163_pos, rx1163_tgt, $I10) = self."!cursor_start"()
    rx1163_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx1163_cur
    .local pmc match
    .lex "$/", match
    length rx1163_eos, rx1163_tgt
    gt rx1163_pos, rx1163_eos, rx1163_done
    set rx1163_off, 0
    lt rx1163_pos, 2, rx1163_start
    sub rx1163_off, rx1163_pos, 1
    substr rx1163_tgt, rx1163_tgt, rx1163_off
  rx1163_start:
    eq $I10, 1, rx1163_restart
    if_null rx1163_debug, debug_874
    rx1163_cur."!cursor_debug"("START", "circumfix:sym<[ ]>")
  debug_874:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1167_done
    goto rxscan1167_scan
  rxscan1167_loop:
    (rx1163_pos) = rx1163_cur."from"()
    inc rx1163_pos
    rx1163_cur."!cursor_from"(rx1163_pos)
    ge rx1163_pos, rx1163_eos, rxscan1167_done
  rxscan1167_scan:
    set_addr $I10, rxscan1167_loop
    rx1163_cur."!mark_push"(0, rx1163_pos, $I10)
  rxscan1167_done:
.annotate 'line', 528
  # rx literal  "["
    add $I11, rx1163_pos, 1
    gt $I11, rx1163_eos, rx1163_fail
    sub $I11, rx1163_pos, rx1163_off
    ord $I11, rx1163_tgt, $I11
    ne $I11, 91, rx1163_fail
    add rx1163_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1163_cur."!cursor_pos"(rx1163_pos)
    $P10 = rx1163_cur."ws"()
    unless $P10, rx1163_fail
    rx1163_pos = $P10."pos"()
  # rx rxquantr1168 ** 0..1
    set_addr $I10, rxquantr1168_done
    rx1163_cur."!mark_push"(0, rx1163_pos, $I10)
  rxquantr1168_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx1163_cur."!cursor_pos"(rx1163_pos)
    $P10 = rx1163_cur."EXPR"()
    unless $P10, rx1163_fail
    goto rxsubrule1169_pass
  rxsubrule1169_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1163_fail
  rxsubrule1169_pass:
    set_addr $I10, rxsubrule1169_back
    rx1163_cur."!mark_push"(0, rx1163_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx1163_pos = $P10."pos"()
    set_addr $I10, rxquantr1168_done
    (rx1163_rep) = rx1163_cur."!mark_commit"($I10)
  rxquantr1168_done:
  # rx literal  "]"
    add $I11, rx1163_pos, 1
    gt $I11, rx1163_eos, rx1163_fail
    sub $I11, rx1163_pos, rx1163_off
    ord $I11, rx1163_tgt, $I11
    ne $I11, 93, rx1163_fail
    add rx1163_pos, 1
  # rx pass
    rx1163_cur."!cursor_pass"(rx1163_pos, "circumfix:sym<[ ]>")
    if_null rx1163_debug, debug_875
    rx1163_cur."!cursor_debug"("PASS", "circumfix:sym<[ ]>", " at pos=", rx1163_pos)
  debug_875:
    .return (rx1163_cur)
  rx1163_restart:
.annotate 'line', 4
    if_null rx1163_debug, debug_876
    rx1163_cur."!cursor_debug"("NEXT", "circumfix:sym<[ ]>")
  debug_876:
  rx1163_fail:
    (rx1163_rep, rx1163_pos, $I10, $P10) = rx1163_cur."!mark_fail"(0)
    lt rx1163_pos, -1, rx1163_done
    eq rx1163_pos, -1, rx1163_fail
    jump $I10
  rx1163_done:
    rx1163_cur."!cursor_fail"()
    if_null rx1163_debug, debug_877
    rx1163_cur."!cursor_debug"("FAIL", "circumfix:sym<[ ]>")
  debug_877:
    .return (rx1163_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<[ ]>"  :nsentry("!PREFIX__circumfix:sym<[ ]>") :subid("254_1298325448.42642") :method
.annotate 'line', 4
    $P1165 = self."!PREFIX__!subrule"("ws", "[")
    new $P1166, "ResizablePMCArray"
    push $P1166, $P1165
    .return ($P1166)
.end


.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<ang>"  :subid("255_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1171_tgt
    .local int rx1171_pos
    .local int rx1171_off
    .local int rx1171_eos
    .local int rx1171_rep
    .local pmc rx1171_cur
    .local pmc rx1171_debug
    (rx1171_cur, rx1171_pos, rx1171_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1171_cur
    .local pmc match
    .lex "$/", match
    length rx1171_eos, rx1171_tgt
    gt rx1171_pos, rx1171_eos, rx1171_done
    set rx1171_off, 0
    lt rx1171_pos, 2, rx1171_start
    sub rx1171_off, rx1171_pos, 1
    substr rx1171_tgt, rx1171_tgt, rx1171_off
  rx1171_start:
    eq $I10, 1, rx1171_restart
    if_null rx1171_debug, debug_878
    rx1171_cur."!cursor_debug"("START", "circumfix:sym<ang>")
  debug_878:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1174_done
    goto rxscan1174_scan
  rxscan1174_loop:
    (rx1171_pos) = rx1171_cur."from"()
    inc rx1171_pos
    rx1171_cur."!cursor_from"(rx1171_pos)
    ge rx1171_pos, rx1171_eos, rxscan1174_done
  rxscan1174_scan:
    set_addr $I10, rxscan1174_loop
    rx1171_cur."!mark_push"(0, rx1171_pos, $I10)
  rxscan1174_done:
.annotate 'line', 529
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1171_pos, rx1171_off
    substr $S10, rx1171_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx1171_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1171_cur."!cursor_pos"(rx1171_pos)
    $P10 = rx1171_cur."quote_EXPR"(":q", ":w")
    unless $P10, rx1171_fail
    rx1171_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1171_pos = $P10."pos"()
  # rx pass
    rx1171_cur."!cursor_pass"(rx1171_pos, "circumfix:sym<ang>")
    if_null rx1171_debug, debug_879
    rx1171_cur."!cursor_debug"("PASS", "circumfix:sym<ang>", " at pos=", rx1171_pos)
  debug_879:
    .return (rx1171_cur)
  rx1171_restart:
.annotate 'line', 4
    if_null rx1171_debug, debug_880
    rx1171_cur."!cursor_debug"("NEXT", "circumfix:sym<ang>")
  debug_880:
  rx1171_fail:
    (rx1171_rep, rx1171_pos, $I10, $P10) = rx1171_cur."!mark_fail"(0)
    lt rx1171_pos, -1, rx1171_done
    eq rx1171_pos, -1, rx1171_fail
    jump $I10
  rx1171_done:
    rx1171_cur."!cursor_fail"()
    if_null rx1171_debug, debug_881
    rx1171_cur."!cursor_debug"("FAIL", "circumfix:sym<ang>")
  debug_881:
    .return (rx1171_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<ang>"  :nsentry("!PREFIX__circumfix:sym<ang>") :subid("256_1298325448.42642") :method
.annotate 'line', 4
    new $P1173, "ResizablePMCArray"
    push $P1173, "<"
    .return ($P1173)
.end


.namespace ["NQP";"Grammar"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("257_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1176_tgt
    .local int rx1176_pos
    .local int rx1176_off
    .local int rx1176_eos
    .local int rx1176_rep
    .local pmc rx1176_cur
    .local pmc rx1176_debug
    (rx1176_cur, rx1176_pos, rx1176_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1176_cur
    .local pmc match
    .lex "$/", match
    length rx1176_eos, rx1176_tgt
    gt rx1176_pos, rx1176_eos, rx1176_done
    set rx1176_off, 0
    lt rx1176_pos, 2, rx1176_start
    sub rx1176_off, rx1176_pos, 1
    substr rx1176_tgt, rx1176_tgt, rx1176_off
  rx1176_start:
    eq $I10, 1, rx1176_restart
    if_null rx1176_debug, debug_882
    rx1176_cur."!cursor_debug"("START", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_882:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1179_done
    goto rxscan1179_scan
  rxscan1179_loop:
    (rx1176_pos) = rx1176_cur."from"()
    inc rx1176_pos
    rx1176_cur."!cursor_from"(rx1176_pos)
    ge rx1176_pos, rx1176_eos, rxscan1179_done
  rxscan1179_scan:
    set_addr $I10, rxscan1179_loop
    rx1176_cur."!mark_push"(0, rx1176_pos, $I10)
  rxscan1179_done:
.annotate 'line', 530
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1176_pos, rx1176_off
    substr $S10, rx1176_tgt, $I10, 1
    index $I11, unicode:"\x{ab}", $S10
    lt $I11, 0, rx1176_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1176_cur."!cursor_pos"(rx1176_pos)
    $P10 = rx1176_cur."quote_EXPR"(":qq", ":w")
    unless $P10, rx1176_fail
    rx1176_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1176_pos = $P10."pos"()
  # rx pass
    rx1176_cur."!cursor_pass"(rx1176_pos, unicode:"circumfix:sym<\x{ab} \x{bb}>")
    if_null rx1176_debug, debug_883
    rx1176_cur."!cursor_debug"("PASS", unicode:"circumfix:sym<\x{ab} \x{bb}>", " at pos=", rx1176_pos)
  debug_883:
    .return (rx1176_cur)
  rx1176_restart:
.annotate 'line', 4
    if_null rx1176_debug, debug_884
    rx1176_cur."!cursor_debug"("NEXT", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_884:
  rx1176_fail:
    (rx1176_rep, rx1176_pos, $I10, $P10) = rx1176_cur."!mark_fail"(0)
    lt rx1176_pos, -1, rx1176_done
    eq rx1176_pos, -1, rx1176_fail
    jump $I10
  rx1176_done:
    rx1176_cur."!cursor_fail"()
    if_null rx1176_debug, debug_885
    rx1176_cur."!cursor_debug"("FAIL", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_885:
    .return (rx1176_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"  :nsentry(unicode:"!PREFIX__circumfix:sym<\\x{ab} \\x{bb}>") :subid("258_1298325448.42642") :method
.annotate 'line', 4
    new $P1178, "ResizablePMCArray"
    push $P1178, unicode:"\x{ab}"
    .return ($P1178)
.end


.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<{ }>"  :subid("259_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1181_tgt
    .local int rx1181_pos
    .local int rx1181_off
    .local int rx1181_eos
    .local int rx1181_rep
    .local pmc rx1181_cur
    .local pmc rx1181_debug
    (rx1181_cur, rx1181_pos, rx1181_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1181_cur
    .local pmc match
    .lex "$/", match
    length rx1181_eos, rx1181_tgt
    gt rx1181_pos, rx1181_eos, rx1181_done
    set rx1181_off, 0
    lt rx1181_pos, 2, rx1181_start
    sub rx1181_off, rx1181_pos, 1
    substr rx1181_tgt, rx1181_tgt, rx1181_off
  rx1181_start:
    eq $I10, 1, rx1181_restart
    if_null rx1181_debug, debug_886
    rx1181_cur."!cursor_debug"("START", "circumfix:sym<{ }>")
  debug_886:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1184_done
    goto rxscan1184_scan
  rxscan1184_loop:
    (rx1181_pos) = rx1181_cur."from"()
    inc rx1181_pos
    rx1181_cur."!cursor_from"(rx1181_pos)
    ge rx1181_pos, rx1181_eos, rxscan1184_done
  rxscan1184_scan:
    set_addr $I10, rxscan1184_loop
    rx1181_cur."!mark_push"(0, rx1181_pos, $I10)
  rxscan1184_done:
.annotate 'line', 531
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1181_pos, rx1181_off
    substr $S10, rx1181_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1181_fail
  # rx subrule "pblock" subtype=capture negate=
    rx1181_cur."!cursor_pos"(rx1181_pos)
    $P10 = rx1181_cur."pblock"()
    unless $P10, rx1181_fail
    rx1181_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx1181_pos = $P10."pos"()
  # rx pass
    rx1181_cur."!cursor_pass"(rx1181_pos, "circumfix:sym<{ }>")
    if_null rx1181_debug, debug_887
    rx1181_cur."!cursor_debug"("PASS", "circumfix:sym<{ }>", " at pos=", rx1181_pos)
  debug_887:
    .return (rx1181_cur)
  rx1181_restart:
.annotate 'line', 4
    if_null rx1181_debug, debug_888
    rx1181_cur."!cursor_debug"("NEXT", "circumfix:sym<{ }>")
  debug_888:
  rx1181_fail:
    (rx1181_rep, rx1181_pos, $I10, $P10) = rx1181_cur."!mark_fail"(0)
    lt rx1181_pos, -1, rx1181_done
    eq rx1181_pos, -1, rx1181_fail
    jump $I10
  rx1181_done:
    rx1181_cur."!cursor_fail"()
    if_null rx1181_debug, debug_889
    rx1181_cur."!cursor_debug"("FAIL", "circumfix:sym<{ }>")
  debug_889:
    .return (rx1181_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<{ }>"  :nsentry("!PREFIX__circumfix:sym<{ }>") :subid("260_1298325448.42642") :method
.annotate 'line', 4
    new $P1183, "ResizablePMCArray"
    push $P1183, "{"
    .return ($P1183)
.end


.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<sigil>"  :subid("261_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1186_tgt
    .local int rx1186_pos
    .local int rx1186_off
    .local int rx1186_eos
    .local int rx1186_rep
    .local pmc rx1186_cur
    .local pmc rx1186_debug
    (rx1186_cur, rx1186_pos, rx1186_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1186_cur
    .local pmc match
    .lex "$/", match
    length rx1186_eos, rx1186_tgt
    gt rx1186_pos, rx1186_eos, rx1186_done
    set rx1186_off, 0
    lt rx1186_pos, 2, rx1186_start
    sub rx1186_off, rx1186_pos, 1
    substr rx1186_tgt, rx1186_tgt, rx1186_off
  rx1186_start:
    eq $I10, 1, rx1186_restart
    if_null rx1186_debug, debug_890
    rx1186_cur."!cursor_debug"("START", "circumfix:sym<sigil>")
  debug_890:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1190_done
    goto rxscan1190_scan
  rxscan1190_loop:
    (rx1186_pos) = rx1186_cur."from"()
    inc rx1186_pos
    rx1186_cur."!cursor_from"(rx1186_pos)
    ge rx1186_pos, rx1186_eos, rxscan1190_done
  rxscan1190_scan:
    set_addr $I10, rxscan1190_loop
    rx1186_cur."!mark_push"(0, rx1186_pos, $I10)
  rxscan1190_done:
.annotate 'line', 532
  # rx subrule "sigil" subtype=capture negate=
    rx1186_cur."!cursor_pos"(rx1186_pos)
    $P10 = rx1186_cur."sigil"()
    unless $P10, rx1186_fail
    rx1186_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1186_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1186_pos, 1
    gt $I11, rx1186_eos, rx1186_fail
    sub $I11, rx1186_pos, rx1186_off
    ord $I11, rx1186_tgt, $I11
    ne $I11, 40, rx1186_fail
    add rx1186_pos, 1
  # rx subrule "semilist" subtype=capture negate=
    rx1186_cur."!cursor_pos"(rx1186_pos)
    $P10 = rx1186_cur."semilist"()
    unless $P10, rx1186_fail
    rx1186_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("semilist")
    rx1186_pos = $P10."pos"()
  alt1191_0:
    set_addr $I10, alt1191_1
    rx1186_cur."!mark_push"(0, rx1186_pos, $I10)
  # rx literal  ")"
    add $I11, rx1186_pos, 1
    gt $I11, rx1186_eos, rx1186_fail
    sub $I11, rx1186_pos, rx1186_off
    ord $I11, rx1186_tgt, $I11
    ne $I11, 41, rx1186_fail
    add rx1186_pos, 1
    goto alt1191_end
  alt1191_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx1186_cur."!cursor_pos"(rx1186_pos)
    $P10 = rx1186_cur."FAILGOAL"("')'")
    unless $P10, rx1186_fail
    goto rxsubrule1193_pass
  rxsubrule1193_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1186_fail
  rxsubrule1193_pass:
    set_addr $I10, rxsubrule1193_back
    rx1186_cur."!mark_push"(0, rx1186_pos, $I10, $P10)
    rx1186_pos = $P10."pos"()
  alt1191_end:
  # rx pass
    rx1186_cur."!cursor_pass"(rx1186_pos, "circumfix:sym<sigil>")
    if_null rx1186_debug, debug_891
    rx1186_cur."!cursor_debug"("PASS", "circumfix:sym<sigil>", " at pos=", rx1186_pos)
  debug_891:
    .return (rx1186_cur)
  rx1186_restart:
.annotate 'line', 4
    if_null rx1186_debug, debug_892
    rx1186_cur."!cursor_debug"("NEXT", "circumfix:sym<sigil>")
  debug_892:
  rx1186_fail:
    (rx1186_rep, rx1186_pos, $I10, $P10) = rx1186_cur."!mark_fail"(0)
    lt rx1186_pos, -1, rx1186_done
    eq rx1186_pos, -1, rx1186_fail
    jump $I10
  rx1186_done:
    rx1186_cur."!cursor_fail"()
    if_null rx1186_debug, debug_893
    rx1186_cur."!cursor_debug"("FAIL", "circumfix:sym<sigil>")
  debug_893:
    .return (rx1186_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<sigil>"  :nsentry("!PREFIX__circumfix:sym<sigil>") :subid("262_1298325448.42642") :method
.annotate 'line', 4
    $P1188 = self."!PREFIX__!subrule"("sigil", "")
    new $P1189, "ResizablePMCArray"
    push $P1189, $P1188
    .return ($P1189)
.end


.namespace ["NQP";"Grammar"]
.sub "semilist"  :subid("263_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1195_tgt
    .local int rx1195_pos
    .local int rx1195_off
    .local int rx1195_eos
    .local int rx1195_rep
    .local pmc rx1195_cur
    .local pmc rx1195_debug
    (rx1195_cur, rx1195_pos, rx1195_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1195_cur
    .local pmc match
    .lex "$/", match
    length rx1195_eos, rx1195_tgt
    gt rx1195_pos, rx1195_eos, rx1195_done
    set rx1195_off, 0
    lt rx1195_pos, 2, rx1195_start
    sub rx1195_off, rx1195_pos, 1
    substr rx1195_tgt, rx1195_tgt, rx1195_off
  rx1195_start:
    eq $I10, 1, rx1195_restart
    if_null rx1195_debug, debug_894
    rx1195_cur."!cursor_debug"("START", "semilist")
  debug_894:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1199_done
    goto rxscan1199_scan
  rxscan1199_loop:
    (rx1195_pos) = rx1195_cur."from"()
    inc rx1195_pos
    rx1195_cur."!cursor_from"(rx1195_pos)
    ge rx1195_pos, rx1195_eos, rxscan1199_done
  rxscan1199_scan:
    set_addr $I10, rxscan1199_loop
    rx1195_cur."!mark_push"(0, rx1195_pos, $I10)
  rxscan1199_done:
.annotate 'line', 534
  # rx subrule "ws" subtype=method negate=
    rx1195_cur."!cursor_pos"(rx1195_pos)
    $P10 = rx1195_cur."ws"()
    unless $P10, rx1195_fail
    rx1195_pos = $P10."pos"()
  # rx subrule "statement" subtype=capture negate=
    rx1195_cur."!cursor_pos"(rx1195_pos)
    $P10 = rx1195_cur."statement"()
    unless $P10, rx1195_fail
    rx1195_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx1195_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1195_cur."!cursor_pos"(rx1195_pos)
    $P10 = rx1195_cur."ws"()
    unless $P10, rx1195_fail
    rx1195_pos = $P10."pos"()
  # rx pass
    rx1195_cur."!cursor_pass"(rx1195_pos, "semilist")
    if_null rx1195_debug, debug_895
    rx1195_cur."!cursor_debug"("PASS", "semilist", " at pos=", rx1195_pos)
  debug_895:
    .return (rx1195_cur)
  rx1195_restart:
.annotate 'line', 4
    if_null rx1195_debug, debug_896
    rx1195_cur."!cursor_debug"("NEXT", "semilist")
  debug_896:
  rx1195_fail:
    (rx1195_rep, rx1195_pos, $I10, $P10) = rx1195_cur."!mark_fail"(0)
    lt rx1195_pos, -1, rx1195_done
    eq rx1195_pos, -1, rx1195_fail
    jump $I10
  rx1195_done:
    rx1195_cur."!cursor_fail"()
    if_null rx1195_debug, debug_897
    rx1195_cur."!cursor_debug"("FAIL", "semilist")
  debug_897:
    .return (rx1195_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__semilist"  :nsentry("!PREFIX__semilist") :subid("264_1298325448.42642") :method
.annotate 'line', 4
    $P1197 = self."!PREFIX__!subrule"("ws", "")
    new $P1198, "ResizablePMCArray"
    push $P1198, $P1197
    .return ($P1198)
.end


.namespace ["NQP";"Grammar"]
.sub "_block1202"  :anon :subid("265_1298325448.42642") :outer("11_1298325448.42642")
.annotate 'line', 4
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "" :load :init :subid("post898") :outer("265_1298325448.42642")
.annotate 'line', 4
    .const 'Sub' $P1203 = "265_1298325448.42642" 
    .local pmc block
    set block, $P1203
.annotate 'line', 539
    get_hll_global $P1204, ["NQP"], "Grammar"
    $P1204."O"(":prec<y=>, :assoc<unary>", "%methodop")
.annotate 'line', 540
    get_hll_global $P1205, ["NQP"], "Grammar"
    $P1205."O"(":prec<x=>, :assoc<unary>", "%autoincrement")
.annotate 'line', 541
    get_hll_global $P1206, ["NQP"], "Grammar"
    $P1206."O"(":prec<w=>, :assoc<left>", "%exponentiation")
.annotate 'line', 542
    get_hll_global $P1207, ["NQP"], "Grammar"
    $P1207."O"(":prec<v=>, :assoc<unary>", "%symbolic_unary")
.annotate 'line', 543
    get_hll_global $P1208, ["NQP"], "Grammar"
    $P1208."O"(":prec<u=>, :assoc<left>", "%multiplicative")
.annotate 'line', 544
    get_hll_global $P1209, ["NQP"], "Grammar"
    $P1209."O"(":prec<t=>, :assoc<left>", "%additive")
.annotate 'line', 545
    get_hll_global $P1210, ["NQP"], "Grammar"
    $P1210."O"(":prec<r=>, :assoc<left>", "%concatenation")
.annotate 'line', 546
    get_hll_global $P1211, ["NQP"], "Grammar"
    $P1211."O"(":prec<m=>, :assoc<left>", "%relational")
.annotate 'line', 547
    get_hll_global $P1212, ["NQP"], "Grammar"
    $P1212."O"(":prec<l=>, :assoc<left>", "%tight_and")
.annotate 'line', 548
    get_hll_global $P1213, ["NQP"], "Grammar"
    $P1213."O"(":prec<k=>, :assoc<left>", "%tight_or")
.annotate 'line', 549
    get_hll_global $P1214, ["NQP"], "Grammar"
    $P1214."O"(":prec<j=>, :assoc<right>", "%conditional")
.annotate 'line', 550
    get_hll_global $P1215, ["NQP"], "Grammar"
    $P1215."O"(":prec<i=>, :assoc<right>", "%assignment")
.annotate 'line', 551
    get_hll_global $P1216, ["NQP"], "Grammar"
    $P1216."O"(":prec<g=>, :assoc<list>, :nextterm<nulltermish>", "%comma")
.annotate 'line', 552
    get_hll_global $P1217, ["NQP"], "Grammar"
    $P1217."O"(":prec<f=>, :assoc<list>", "%list_infix")
.annotate 'line', 553
    get_hll_global $P1218, ["NQP"], "Grammar"
    $P1218."O"(":prec<e=>, :assoc<unary>", "%list_prefix")
.end


.namespace ["NQP";"Grammar"]
.sub "infixish"  :subid("266_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1220_tgt
    .local int rx1220_pos
    .local int rx1220_off
    .local int rx1220_eos
    .local int rx1220_rep
    .local pmc rx1220_cur
    .local pmc rx1220_debug
    (rx1220_cur, rx1220_pos, rx1220_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1220_cur
    .local pmc match
    .lex "$/", match
    length rx1220_eos, rx1220_tgt
    gt rx1220_pos, rx1220_eos, rx1220_done
    set rx1220_off, 0
    lt rx1220_pos, 2, rx1220_start
    sub rx1220_off, rx1220_pos, 1
    substr rx1220_tgt, rx1220_tgt, rx1220_off
  rx1220_start:
    eq $I10, 1, rx1220_restart
    if_null rx1220_debug, debug_899
    rx1220_cur."!cursor_debug"("START", "infixish")
  debug_899:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1223_done
    goto rxscan1223_scan
  rxscan1223_loop:
    (rx1220_pos) = rx1220_cur."from"()
    inc rx1220_pos
    rx1220_cur."!cursor_from"(rx1220_pos)
    ge rx1220_pos, rx1220_eos, rxscan1223_done
  rxscan1223_scan:
    set_addr $I10, rxscan1223_loop
    rx1220_cur."!mark_push"(0, rx1220_pos, $I10)
  rxscan1223_done:
.annotate 'line', 557
  # rx subrule "infixstopper" subtype=zerowidth negate=1
    rx1220_cur."!cursor_pos"(rx1220_pos)
    $P10 = rx1220_cur."infixstopper"()
    if $P10, rx1220_fail
  # rx subrule "infix" subtype=capture negate=
    rx1220_cur."!cursor_pos"(rx1220_pos)
    $P10 = rx1220_cur."infix"()
    unless $P10, rx1220_fail
    rx1220_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("OPER=infix")
    rx1220_pos = $P10."pos"()
  # rx pass
    rx1220_cur."!cursor_pass"(rx1220_pos, "infixish")
    if_null rx1220_debug, debug_900
    rx1220_cur."!cursor_debug"("PASS", "infixish", " at pos=", rx1220_pos)
  debug_900:
    .return (rx1220_cur)
  rx1220_restart:
.annotate 'line', 4
    if_null rx1220_debug, debug_901
    rx1220_cur."!cursor_debug"("NEXT", "infixish")
  debug_901:
  rx1220_fail:
    (rx1220_rep, rx1220_pos, $I10, $P10) = rx1220_cur."!mark_fail"(0)
    lt rx1220_pos, -1, rx1220_done
    eq rx1220_pos, -1, rx1220_fail
    jump $I10
  rx1220_done:
    rx1220_cur."!cursor_fail"()
    if_null rx1220_debug, debug_902
    rx1220_cur."!cursor_debug"("FAIL", "infixish")
  debug_902:
    .return (rx1220_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixish"  :nsentry("!PREFIX__infixish") :subid("267_1298325448.42642") :method
.annotate 'line', 4
    new $P1222, "ResizablePMCArray"
    push $P1222, ""
    .return ($P1222)
.end


.namespace ["NQP";"Grammar"]
.sub "infixstopper"  :subid("268_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1225_tgt
    .local int rx1225_pos
    .local int rx1225_off
    .local int rx1225_eos
    .local int rx1225_rep
    .local pmc rx1225_cur
    .local pmc rx1225_debug
    (rx1225_cur, rx1225_pos, rx1225_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1225_cur
    .local pmc match
    .lex "$/", match
    length rx1225_eos, rx1225_tgt
    gt rx1225_pos, rx1225_eos, rx1225_done
    set rx1225_off, 0
    lt rx1225_pos, 2, rx1225_start
    sub rx1225_off, rx1225_pos, 1
    substr rx1225_tgt, rx1225_tgt, rx1225_off
  rx1225_start:
    eq $I10, 1, rx1225_restart
    if_null rx1225_debug, debug_903
    rx1225_cur."!cursor_debug"("START", "infixstopper")
  debug_903:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1228_done
    goto rxscan1228_scan
  rxscan1228_loop:
    (rx1225_pos) = rx1225_cur."from"()
    inc rx1225_pos
    rx1225_cur."!cursor_from"(rx1225_pos)
    ge rx1225_pos, rx1225_eos, rxscan1228_done
  rxscan1228_scan:
    set_addr $I10, rxscan1228_loop
    rx1225_cur."!mark_push"(0, rx1225_pos, $I10)
  rxscan1228_done:
.annotate 'line', 558
  # rx subrule "lambda" subtype=zerowidth negate=
    rx1225_cur."!cursor_pos"(rx1225_pos)
    $P10 = rx1225_cur."lambda"()
    unless $P10, rx1225_fail
  # rx pass
    rx1225_cur."!cursor_pass"(rx1225_pos, "infixstopper")
    if_null rx1225_debug, debug_904
    rx1225_cur."!cursor_debug"("PASS", "infixstopper", " at pos=", rx1225_pos)
  debug_904:
    .return (rx1225_cur)
  rx1225_restart:
.annotate 'line', 4
    if_null rx1225_debug, debug_905
    rx1225_cur."!cursor_debug"("NEXT", "infixstopper")
  debug_905:
  rx1225_fail:
    (rx1225_rep, rx1225_pos, $I10, $P10) = rx1225_cur."!mark_fail"(0)
    lt rx1225_pos, -1, rx1225_done
    eq rx1225_pos, -1, rx1225_fail
    jump $I10
  rx1225_done:
    rx1225_cur."!cursor_fail"()
    if_null rx1225_debug, debug_906
    rx1225_cur."!cursor_debug"("FAIL", "infixstopper")
  debug_906:
    .return (rx1225_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixstopper"  :nsentry("!PREFIX__infixstopper") :subid("269_1298325448.42642") :method
.annotate 'line', 4
    new $P1227, "ResizablePMCArray"
    push $P1227, ""
    .return ($P1227)
.end


.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<[ ]>"  :subid("270_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1230_tgt
    .local int rx1230_pos
    .local int rx1230_off
    .local int rx1230_eos
    .local int rx1230_rep
    .local pmc rx1230_cur
    .local pmc rx1230_debug
    (rx1230_cur, rx1230_pos, rx1230_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1230_cur
    .local pmc match
    .lex "$/", match
    length rx1230_eos, rx1230_tgt
    gt rx1230_pos, rx1230_eos, rx1230_done
    set rx1230_off, 0
    lt rx1230_pos, 2, rx1230_start
    sub rx1230_off, rx1230_pos, 1
    substr rx1230_tgt, rx1230_tgt, rx1230_off
  rx1230_start:
    eq $I10, 1, rx1230_restart
    if_null rx1230_debug, debug_907
    rx1230_cur."!cursor_debug"("START", "postcircumfix:sym<[ ]>")
  debug_907:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1234_done
    goto rxscan1234_scan
  rxscan1234_loop:
    (rx1230_pos) = rx1230_cur."from"()
    inc rx1230_pos
    rx1230_cur."!cursor_from"(rx1230_pos)
    ge rx1230_pos, rx1230_eos, rxscan1234_done
  rxscan1234_scan:
    set_addr $I10, rxscan1234_loop
    rx1230_cur."!mark_push"(0, rx1230_pos, $I10)
  rxscan1234_done:
.annotate 'line', 561
  # rx literal  "["
    add $I11, rx1230_pos, 1
    gt $I11, rx1230_eos, rx1230_fail
    sub $I11, rx1230_pos, rx1230_off
    ord $I11, rx1230_tgt, $I11
    ne $I11, 91, rx1230_fail
    add rx1230_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1230_cur."!cursor_pos"(rx1230_pos)
    $P10 = rx1230_cur."ws"()
    unless $P10, rx1230_fail
    rx1230_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1230_cur."!cursor_pos"(rx1230_pos)
    $P10 = rx1230_cur."EXPR"()
    unless $P10, rx1230_fail
    rx1230_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1230_pos = $P10."pos"()
  # rx literal  "]"
    add $I11, rx1230_pos, 1
    gt $I11, rx1230_eos, rx1230_fail
    sub $I11, rx1230_pos, rx1230_off
    ord $I11, rx1230_tgt, $I11
    ne $I11, 93, rx1230_fail
    add rx1230_pos, 1
.annotate 'line', 562
  # rx subrule "O" subtype=capture negate=
    rx1230_cur."!cursor_pos"(rx1230_pos)
    $P10 = rx1230_cur."O"("%methodop")
    unless $P10, rx1230_fail
    rx1230_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1230_pos = $P10."pos"()
.annotate 'line', 560
  # rx pass
    rx1230_cur."!cursor_pass"(rx1230_pos, "postcircumfix:sym<[ ]>")
    if_null rx1230_debug, debug_908
    rx1230_cur."!cursor_debug"("PASS", "postcircumfix:sym<[ ]>", " at pos=", rx1230_pos)
  debug_908:
    .return (rx1230_cur)
  rx1230_restart:
.annotate 'line', 4
    if_null rx1230_debug, debug_909
    rx1230_cur."!cursor_debug"("NEXT", "postcircumfix:sym<[ ]>")
  debug_909:
  rx1230_fail:
    (rx1230_rep, rx1230_pos, $I10, $P10) = rx1230_cur."!mark_fail"(0)
    lt rx1230_pos, -1, rx1230_done
    eq rx1230_pos, -1, rx1230_fail
    jump $I10
  rx1230_done:
    rx1230_cur."!cursor_fail"()
    if_null rx1230_debug, debug_910
    rx1230_cur."!cursor_debug"("FAIL", "postcircumfix:sym<[ ]>")
  debug_910:
    .return (rx1230_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<[ ]>"  :nsentry("!PREFIX__postcircumfix:sym<[ ]>") :subid("271_1298325448.42642") :method
.annotate 'line', 4
    $P1232 = self."!PREFIX__!subrule"("ws", "[")
    new $P1233, "ResizablePMCArray"
    push $P1233, $P1232
    .return ($P1233)
.end


.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<{ }>"  :subid("272_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1236_tgt
    .local int rx1236_pos
    .local int rx1236_off
    .local int rx1236_eos
    .local int rx1236_rep
    .local pmc rx1236_cur
    .local pmc rx1236_debug
    (rx1236_cur, rx1236_pos, rx1236_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1236_cur
    .local pmc match
    .lex "$/", match
    length rx1236_eos, rx1236_tgt
    gt rx1236_pos, rx1236_eos, rx1236_done
    set rx1236_off, 0
    lt rx1236_pos, 2, rx1236_start
    sub rx1236_off, rx1236_pos, 1
    substr rx1236_tgt, rx1236_tgt, rx1236_off
  rx1236_start:
    eq $I10, 1, rx1236_restart
    if_null rx1236_debug, debug_911
    rx1236_cur."!cursor_debug"("START", "postcircumfix:sym<{ }>")
  debug_911:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1240_done
    goto rxscan1240_scan
  rxscan1240_loop:
    (rx1236_pos) = rx1236_cur."from"()
    inc rx1236_pos
    rx1236_cur."!cursor_from"(rx1236_pos)
    ge rx1236_pos, rx1236_eos, rxscan1240_done
  rxscan1240_scan:
    set_addr $I10, rxscan1240_loop
    rx1236_cur."!mark_push"(0, rx1236_pos, $I10)
  rxscan1240_done:
.annotate 'line', 566
  # rx literal  "{"
    add $I11, rx1236_pos, 1
    gt $I11, rx1236_eos, rx1236_fail
    sub $I11, rx1236_pos, rx1236_off
    ord $I11, rx1236_tgt, $I11
    ne $I11, 123, rx1236_fail
    add rx1236_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1236_cur."!cursor_pos"(rx1236_pos)
    $P10 = rx1236_cur."ws"()
    unless $P10, rx1236_fail
    rx1236_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1236_cur."!cursor_pos"(rx1236_pos)
    $P10 = rx1236_cur."EXPR"()
    unless $P10, rx1236_fail
    rx1236_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1236_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1236_pos, 1
    gt $I11, rx1236_eos, rx1236_fail
    sub $I11, rx1236_pos, rx1236_off
    ord $I11, rx1236_tgt, $I11
    ne $I11, 125, rx1236_fail
    add rx1236_pos, 1
.annotate 'line', 567
  # rx subrule "O" subtype=capture negate=
    rx1236_cur."!cursor_pos"(rx1236_pos)
    $P10 = rx1236_cur."O"("%methodop")
    unless $P10, rx1236_fail
    rx1236_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1236_pos = $P10."pos"()
.annotate 'line', 565
  # rx pass
    rx1236_cur."!cursor_pass"(rx1236_pos, "postcircumfix:sym<{ }>")
    if_null rx1236_debug, debug_912
    rx1236_cur."!cursor_debug"("PASS", "postcircumfix:sym<{ }>", " at pos=", rx1236_pos)
  debug_912:
    .return (rx1236_cur)
  rx1236_restart:
.annotate 'line', 4
    if_null rx1236_debug, debug_913
    rx1236_cur."!cursor_debug"("NEXT", "postcircumfix:sym<{ }>")
  debug_913:
  rx1236_fail:
    (rx1236_rep, rx1236_pos, $I10, $P10) = rx1236_cur."!mark_fail"(0)
    lt rx1236_pos, -1, rx1236_done
    eq rx1236_pos, -1, rx1236_fail
    jump $I10
  rx1236_done:
    rx1236_cur."!cursor_fail"()
    if_null rx1236_debug, debug_914
    rx1236_cur."!cursor_debug"("FAIL", "postcircumfix:sym<{ }>")
  debug_914:
    .return (rx1236_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<{ }>"  :nsentry("!PREFIX__postcircumfix:sym<{ }>") :subid("273_1298325448.42642") :method
.annotate 'line', 4
    $P1238 = self."!PREFIX__!subrule"("ws", "{")
    new $P1239, "ResizablePMCArray"
    push $P1239, $P1238
    .return ($P1239)
.end


.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<ang>"  :subid("274_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1242_tgt
    .local int rx1242_pos
    .local int rx1242_off
    .local int rx1242_eos
    .local int rx1242_rep
    .local pmc rx1242_cur
    .local pmc rx1242_debug
    (rx1242_cur, rx1242_pos, rx1242_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1242_cur
    .local pmc match
    .lex "$/", match
    length rx1242_eos, rx1242_tgt
    gt rx1242_pos, rx1242_eos, rx1242_done
    set rx1242_off, 0
    lt rx1242_pos, 2, rx1242_start
    sub rx1242_off, rx1242_pos, 1
    substr rx1242_tgt, rx1242_tgt, rx1242_off
  rx1242_start:
    eq $I10, 1, rx1242_restart
    if_null rx1242_debug, debug_915
    rx1242_cur."!cursor_debug"("START", "postcircumfix:sym<ang>")
  debug_915:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1245_done
    goto rxscan1245_scan
  rxscan1245_loop:
    (rx1242_pos) = rx1242_cur."from"()
    inc rx1242_pos
    rx1242_cur."!cursor_from"(rx1242_pos)
    ge rx1242_pos, rx1242_eos, rxscan1245_done
  rxscan1245_scan:
    set_addr $I10, rxscan1245_loop
    rx1242_cur."!mark_push"(0, rx1242_pos, $I10)
  rxscan1245_done:
.annotate 'line', 571
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1242_pos, rx1242_off
    substr $S10, rx1242_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx1242_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1242_cur."!cursor_pos"(rx1242_pos)
    $P10 = rx1242_cur."quote_EXPR"(":q")
    unless $P10, rx1242_fail
    rx1242_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1242_pos = $P10."pos"()
.annotate 'line', 572
  # rx subrule "O" subtype=capture negate=
    rx1242_cur."!cursor_pos"(rx1242_pos)
    $P10 = rx1242_cur."O"("%methodop")
    unless $P10, rx1242_fail
    rx1242_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1242_pos = $P10."pos"()
.annotate 'line', 570
  # rx pass
    rx1242_cur."!cursor_pass"(rx1242_pos, "postcircumfix:sym<ang>")
    if_null rx1242_debug, debug_916
    rx1242_cur."!cursor_debug"("PASS", "postcircumfix:sym<ang>", " at pos=", rx1242_pos)
  debug_916:
    .return (rx1242_cur)
  rx1242_restart:
.annotate 'line', 4
    if_null rx1242_debug, debug_917
    rx1242_cur."!cursor_debug"("NEXT", "postcircumfix:sym<ang>")
  debug_917:
  rx1242_fail:
    (rx1242_rep, rx1242_pos, $I10, $P10) = rx1242_cur."!mark_fail"(0)
    lt rx1242_pos, -1, rx1242_done
    eq rx1242_pos, -1, rx1242_fail
    jump $I10
  rx1242_done:
    rx1242_cur."!cursor_fail"()
    if_null rx1242_debug, debug_918
    rx1242_cur."!cursor_debug"("FAIL", "postcircumfix:sym<ang>")
  debug_918:
    .return (rx1242_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<ang>"  :nsentry("!PREFIX__postcircumfix:sym<ang>") :subid("275_1298325448.42642") :method
.annotate 'line', 4
    new $P1244, "ResizablePMCArray"
    push $P1244, "<"
    .return ($P1244)
.end


.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<( )>"  :subid("276_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1247_tgt
    .local int rx1247_pos
    .local int rx1247_off
    .local int rx1247_eos
    .local int rx1247_rep
    .local pmc rx1247_cur
    .local pmc rx1247_debug
    (rx1247_cur, rx1247_pos, rx1247_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1247_cur
    .local pmc match
    .lex "$/", match
    length rx1247_eos, rx1247_tgt
    gt rx1247_pos, rx1247_eos, rx1247_done
    set rx1247_off, 0
    lt rx1247_pos, 2, rx1247_start
    sub rx1247_off, rx1247_pos, 1
    substr rx1247_tgt, rx1247_tgt, rx1247_off
  rx1247_start:
    eq $I10, 1, rx1247_restart
    if_null rx1247_debug, debug_919
    rx1247_cur."!cursor_debug"("START", "postcircumfix:sym<( )>")
  debug_919:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1251_done
    goto rxscan1251_scan
  rxscan1251_loop:
    (rx1247_pos) = rx1247_cur."from"()
    inc rx1247_pos
    rx1247_cur."!cursor_from"(rx1247_pos)
    ge rx1247_pos, rx1247_eos, rxscan1251_done
  rxscan1251_scan:
    set_addr $I10, rxscan1251_loop
    rx1247_cur."!mark_push"(0, rx1247_pos, $I10)
  rxscan1251_done:
.annotate 'line', 576
  # rx literal  "("
    add $I11, rx1247_pos, 1
    gt $I11, rx1247_eos, rx1247_fail
    sub $I11, rx1247_pos, rx1247_off
    ord $I11, rx1247_tgt, $I11
    ne $I11, 40, rx1247_fail
    add rx1247_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1247_cur."!cursor_pos"(rx1247_pos)
    $P10 = rx1247_cur."ws"()
    unless $P10, rx1247_fail
    rx1247_pos = $P10."pos"()
  # rx subrule "arglist" subtype=capture negate=
    rx1247_cur."!cursor_pos"(rx1247_pos)
    $P10 = rx1247_cur."arglist"()
    unless $P10, rx1247_fail
    rx1247_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1247_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1247_pos, 1
    gt $I11, rx1247_eos, rx1247_fail
    sub $I11, rx1247_pos, rx1247_off
    ord $I11, rx1247_tgt, $I11
    ne $I11, 41, rx1247_fail
    add rx1247_pos, 1
.annotate 'line', 577
  # rx subrule "O" subtype=capture negate=
    rx1247_cur."!cursor_pos"(rx1247_pos)
    $P10 = rx1247_cur."O"("%methodop")
    unless $P10, rx1247_fail
    rx1247_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1247_pos = $P10."pos"()
.annotate 'line', 575
  # rx pass
    rx1247_cur."!cursor_pass"(rx1247_pos, "postcircumfix:sym<( )>")
    if_null rx1247_debug, debug_920
    rx1247_cur."!cursor_debug"("PASS", "postcircumfix:sym<( )>", " at pos=", rx1247_pos)
  debug_920:
    .return (rx1247_cur)
  rx1247_restart:
.annotate 'line', 4
    if_null rx1247_debug, debug_921
    rx1247_cur."!cursor_debug"("NEXT", "postcircumfix:sym<( )>")
  debug_921:
  rx1247_fail:
    (rx1247_rep, rx1247_pos, $I10, $P10) = rx1247_cur."!mark_fail"(0)
    lt rx1247_pos, -1, rx1247_done
    eq rx1247_pos, -1, rx1247_fail
    jump $I10
  rx1247_done:
    rx1247_cur."!cursor_fail"()
    if_null rx1247_debug, debug_922
    rx1247_cur."!cursor_debug"("FAIL", "postcircumfix:sym<( )>")
  debug_922:
    .return (rx1247_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<( )>"  :nsentry("!PREFIX__postcircumfix:sym<( )>") :subid("277_1298325448.42642") :method
.annotate 'line', 4
    $P1249 = self."!PREFIX__!subrule"("ws", "(")
    new $P1250, "ResizablePMCArray"
    push $P1250, $P1249
    .return ($P1250)
.end


.namespace ["NQP";"Grammar"]
.sub "postfix:sym<.>"  :subid("278_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1253_tgt
    .local int rx1253_pos
    .local int rx1253_off
    .local int rx1253_eos
    .local int rx1253_rep
    .local pmc rx1253_cur
    .local pmc rx1253_debug
    (rx1253_cur, rx1253_pos, rx1253_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1253_cur
    .local pmc match
    .lex "$/", match
    length rx1253_eos, rx1253_tgt
    gt rx1253_pos, rx1253_eos, rx1253_done
    set rx1253_off, 0
    lt rx1253_pos, 2, rx1253_start
    sub rx1253_off, rx1253_pos, 1
    substr rx1253_tgt, rx1253_tgt, rx1253_off
  rx1253_start:
    eq $I10, 1, rx1253_restart
    if_null rx1253_debug, debug_923
    rx1253_cur."!cursor_debug"("START", "postfix:sym<.>")
  debug_923:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1257_done
    goto rxscan1257_scan
  rxscan1257_loop:
    (rx1253_pos) = rx1253_cur."from"()
    inc rx1253_pos
    rx1253_cur."!cursor_from"(rx1253_pos)
    ge rx1253_pos, rx1253_eos, rxscan1257_done
  rxscan1257_scan:
    set_addr $I10, rxscan1257_loop
    rx1253_cur."!mark_push"(0, rx1253_pos, $I10)
  rxscan1257_done:
.annotate 'line', 580
  # rx subrule "dotty" subtype=capture negate=
    rx1253_cur."!cursor_pos"(rx1253_pos)
    $P10 = rx1253_cur."dotty"()
    unless $P10, rx1253_fail
    rx1253_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dotty")
    rx1253_pos = $P10."pos"()
  # rx subrule "O" subtype=capture negate=
    rx1253_cur."!cursor_pos"(rx1253_pos)
    $P10 = rx1253_cur."O"("%methodop")
    unless $P10, rx1253_fail
    rx1253_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1253_pos = $P10."pos"()
  # rx pass
    rx1253_cur."!cursor_pass"(rx1253_pos, "postfix:sym<.>")
    if_null rx1253_debug, debug_924
    rx1253_cur."!cursor_debug"("PASS", "postfix:sym<.>", " at pos=", rx1253_pos)
  debug_924:
    .return (rx1253_cur)
  rx1253_restart:
.annotate 'line', 4
    if_null rx1253_debug, debug_925
    rx1253_cur."!cursor_debug"("NEXT", "postfix:sym<.>")
  debug_925:
  rx1253_fail:
    (rx1253_rep, rx1253_pos, $I10, $P10) = rx1253_cur."!mark_fail"(0)
    lt rx1253_pos, -1, rx1253_done
    eq rx1253_pos, -1, rx1253_fail
    jump $I10
  rx1253_done:
    rx1253_cur."!cursor_fail"()
    if_null rx1253_debug, debug_926
    rx1253_cur."!cursor_debug"("FAIL", "postfix:sym<.>")
  debug_926:
    .return (rx1253_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<.>"  :nsentry("!PREFIX__postfix:sym<.>") :subid("279_1298325448.42642") :method
.annotate 'line', 4
    $P1255 = self."!PREFIX__!subrule"("dotty", "")
    new $P1256, "ResizablePMCArray"
    push $P1256, $P1255
    .return ($P1256)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<++>"  :subid("280_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1259_tgt
    .local int rx1259_pos
    .local int rx1259_off
    .local int rx1259_eos
    .local int rx1259_rep
    .local pmc rx1259_cur
    .local pmc rx1259_debug
    (rx1259_cur, rx1259_pos, rx1259_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1259_cur
    .local pmc match
    .lex "$/", match
    length rx1259_eos, rx1259_tgt
    gt rx1259_pos, rx1259_eos, rx1259_done
    set rx1259_off, 0
    lt rx1259_pos, 2, rx1259_start
    sub rx1259_off, rx1259_pos, 1
    substr rx1259_tgt, rx1259_tgt, rx1259_off
  rx1259_start:
    eq $I10, 1, rx1259_restart
    if_null rx1259_debug, debug_927
    rx1259_cur."!cursor_debug"("START", "prefix:sym<++>")
  debug_927:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1263_done
    goto rxscan1263_scan
  rxscan1263_loop:
    (rx1259_pos) = rx1259_cur."from"()
    inc rx1259_pos
    rx1259_cur."!cursor_from"(rx1259_pos)
    ge rx1259_pos, rx1259_eos, rxscan1263_done
  rxscan1263_scan:
    set_addr $I10, rxscan1263_loop
    rx1259_cur."!mark_push"(0, rx1259_pos, $I10)
  rxscan1263_done:
.annotate 'line', 582
  # rx subcapture "sym"
    set_addr $I10, rxcap_1264_fail
    rx1259_cur."!mark_push"(0, rx1259_pos, $I10)
  # rx literal  "++"
    add $I11, rx1259_pos, 2
    gt $I11, rx1259_eos, rx1259_fail
    sub $I11, rx1259_pos, rx1259_off
    substr $S10, rx1259_tgt, $I11, 2
    ne $S10, "++", rx1259_fail
    add rx1259_pos, 2
    set_addr $I10, rxcap_1264_fail
    ($I12, $I11) = rx1259_cur."!mark_peek"($I10)
    rx1259_cur."!cursor_pos"($I11)
    ($P10) = rx1259_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1259_pos, "")
    rx1259_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1264_done
  rxcap_1264_fail:
    goto rx1259_fail
  rxcap_1264_done:
  # rx subrule "O" subtype=capture negate=
    rx1259_cur."!cursor_pos"(rx1259_pos)
    $P10 = rx1259_cur."O"("%autoincrement, :pirop<inc>")
    unless $P10, rx1259_fail
    rx1259_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1259_pos = $P10."pos"()
  # rx pass
    rx1259_cur."!cursor_pass"(rx1259_pos, "prefix:sym<++>")
    if_null rx1259_debug, debug_928
    rx1259_cur."!cursor_debug"("PASS", "prefix:sym<++>", " at pos=", rx1259_pos)
  debug_928:
    .return (rx1259_cur)
  rx1259_restart:
.annotate 'line', 4
    if_null rx1259_debug, debug_929
    rx1259_cur."!cursor_debug"("NEXT", "prefix:sym<++>")
  debug_929:
  rx1259_fail:
    (rx1259_rep, rx1259_pos, $I10, $P10) = rx1259_cur."!mark_fail"(0)
    lt rx1259_pos, -1, rx1259_done
    eq rx1259_pos, -1, rx1259_fail
    jump $I10
  rx1259_done:
    rx1259_cur."!cursor_fail"()
    if_null rx1259_debug, debug_930
    rx1259_cur."!cursor_debug"("FAIL", "prefix:sym<++>")
  debug_930:
    .return (rx1259_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<++>"  :nsentry("!PREFIX__prefix:sym<++>") :subid("281_1298325448.42642") :method
.annotate 'line', 4
    $P1261 = self."!PREFIX__!subrule"("O", "++")
    new $P1262, "ResizablePMCArray"
    push $P1262, $P1261
    .return ($P1262)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<-->"  :subid("282_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1266_tgt
    .local int rx1266_pos
    .local int rx1266_off
    .local int rx1266_eos
    .local int rx1266_rep
    .local pmc rx1266_cur
    .local pmc rx1266_debug
    (rx1266_cur, rx1266_pos, rx1266_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1266_cur
    .local pmc match
    .lex "$/", match
    length rx1266_eos, rx1266_tgt
    gt rx1266_pos, rx1266_eos, rx1266_done
    set rx1266_off, 0
    lt rx1266_pos, 2, rx1266_start
    sub rx1266_off, rx1266_pos, 1
    substr rx1266_tgt, rx1266_tgt, rx1266_off
  rx1266_start:
    eq $I10, 1, rx1266_restart
    if_null rx1266_debug, debug_931
    rx1266_cur."!cursor_debug"("START", "prefix:sym<-->")
  debug_931:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1270_done
    goto rxscan1270_scan
  rxscan1270_loop:
    (rx1266_pos) = rx1266_cur."from"()
    inc rx1266_pos
    rx1266_cur."!cursor_from"(rx1266_pos)
    ge rx1266_pos, rx1266_eos, rxscan1270_done
  rxscan1270_scan:
    set_addr $I10, rxscan1270_loop
    rx1266_cur."!mark_push"(0, rx1266_pos, $I10)
  rxscan1270_done:
.annotate 'line', 583
  # rx subcapture "sym"
    set_addr $I10, rxcap_1271_fail
    rx1266_cur."!mark_push"(0, rx1266_pos, $I10)
  # rx literal  "--"
    add $I11, rx1266_pos, 2
    gt $I11, rx1266_eos, rx1266_fail
    sub $I11, rx1266_pos, rx1266_off
    substr $S10, rx1266_tgt, $I11, 2
    ne $S10, "--", rx1266_fail
    add rx1266_pos, 2
    set_addr $I10, rxcap_1271_fail
    ($I12, $I11) = rx1266_cur."!mark_peek"($I10)
    rx1266_cur."!cursor_pos"($I11)
    ($P10) = rx1266_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1266_pos, "")
    rx1266_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1271_done
  rxcap_1271_fail:
    goto rx1266_fail
  rxcap_1271_done:
  # rx subrule "O" subtype=capture negate=
    rx1266_cur."!cursor_pos"(rx1266_pos)
    $P10 = rx1266_cur."O"("%autoincrement, :pirop<dec>")
    unless $P10, rx1266_fail
    rx1266_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1266_pos = $P10."pos"()
  # rx pass
    rx1266_cur."!cursor_pass"(rx1266_pos, "prefix:sym<-->")
    if_null rx1266_debug, debug_932
    rx1266_cur."!cursor_debug"("PASS", "prefix:sym<-->", " at pos=", rx1266_pos)
  debug_932:
    .return (rx1266_cur)
  rx1266_restart:
.annotate 'line', 4
    if_null rx1266_debug, debug_933
    rx1266_cur."!cursor_debug"("NEXT", "prefix:sym<-->")
  debug_933:
  rx1266_fail:
    (rx1266_rep, rx1266_pos, $I10, $P10) = rx1266_cur."!mark_fail"(0)
    lt rx1266_pos, -1, rx1266_done
    eq rx1266_pos, -1, rx1266_fail
    jump $I10
  rx1266_done:
    rx1266_cur."!cursor_fail"()
    if_null rx1266_debug, debug_934
    rx1266_cur."!cursor_debug"("FAIL", "prefix:sym<-->")
  debug_934:
    .return (rx1266_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<-->"  :nsentry("!PREFIX__prefix:sym<-->") :subid("283_1298325448.42642") :method
.annotate 'line', 4
    $P1268 = self."!PREFIX__!subrule"("O", "--")
    new $P1269, "ResizablePMCArray"
    push $P1269, $P1268
    .return ($P1269)
.end


.namespace ["NQP";"Grammar"]
.sub "postfix:sym<++>"  :subid("284_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1273_tgt
    .local int rx1273_pos
    .local int rx1273_off
    .local int rx1273_eos
    .local int rx1273_rep
    .local pmc rx1273_cur
    .local pmc rx1273_debug
    (rx1273_cur, rx1273_pos, rx1273_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1273_cur
    .local pmc match
    .lex "$/", match
    length rx1273_eos, rx1273_tgt
    gt rx1273_pos, rx1273_eos, rx1273_done
    set rx1273_off, 0
    lt rx1273_pos, 2, rx1273_start
    sub rx1273_off, rx1273_pos, 1
    substr rx1273_tgt, rx1273_tgt, rx1273_off
  rx1273_start:
    eq $I10, 1, rx1273_restart
    if_null rx1273_debug, debug_935
    rx1273_cur."!cursor_debug"("START", "postfix:sym<++>")
  debug_935:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1277_done
    goto rxscan1277_scan
  rxscan1277_loop:
    (rx1273_pos) = rx1273_cur."from"()
    inc rx1273_pos
    rx1273_cur."!cursor_from"(rx1273_pos)
    ge rx1273_pos, rx1273_eos, rxscan1277_done
  rxscan1277_scan:
    set_addr $I10, rxscan1277_loop
    rx1273_cur."!mark_push"(0, rx1273_pos, $I10)
  rxscan1277_done:
.annotate 'line', 586
  # rx subcapture "sym"
    set_addr $I10, rxcap_1278_fail
    rx1273_cur."!mark_push"(0, rx1273_pos, $I10)
  # rx literal  "++"
    add $I11, rx1273_pos, 2
    gt $I11, rx1273_eos, rx1273_fail
    sub $I11, rx1273_pos, rx1273_off
    substr $S10, rx1273_tgt, $I11, 2
    ne $S10, "++", rx1273_fail
    add rx1273_pos, 2
    set_addr $I10, rxcap_1278_fail
    ($I12, $I11) = rx1273_cur."!mark_peek"($I10)
    rx1273_cur."!cursor_pos"($I11)
    ($P10) = rx1273_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1273_pos, "")
    rx1273_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1278_done
  rxcap_1278_fail:
    goto rx1273_fail
  rxcap_1278_done:
  # rx subrule "O" subtype=capture negate=
    rx1273_cur."!cursor_pos"(rx1273_pos)
    $P10 = rx1273_cur."O"("%autoincrement")
    unless $P10, rx1273_fail
    rx1273_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1273_pos = $P10."pos"()
  # rx pass
    rx1273_cur."!cursor_pass"(rx1273_pos, "postfix:sym<++>")
    if_null rx1273_debug, debug_936
    rx1273_cur."!cursor_debug"("PASS", "postfix:sym<++>", " at pos=", rx1273_pos)
  debug_936:
    .return (rx1273_cur)
  rx1273_restart:
.annotate 'line', 4
    if_null rx1273_debug, debug_937
    rx1273_cur."!cursor_debug"("NEXT", "postfix:sym<++>")
  debug_937:
  rx1273_fail:
    (rx1273_rep, rx1273_pos, $I10, $P10) = rx1273_cur."!mark_fail"(0)
    lt rx1273_pos, -1, rx1273_done
    eq rx1273_pos, -1, rx1273_fail
    jump $I10
  rx1273_done:
    rx1273_cur."!cursor_fail"()
    if_null rx1273_debug, debug_938
    rx1273_cur."!cursor_debug"("FAIL", "postfix:sym<++>")
  debug_938:
    .return (rx1273_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<++>"  :nsentry("!PREFIX__postfix:sym<++>") :subid("285_1298325448.42642") :method
.annotate 'line', 4
    $P1275 = self."!PREFIX__!subrule"("O", "++")
    new $P1276, "ResizablePMCArray"
    push $P1276, $P1275
    .return ($P1276)
.end


.namespace ["NQP";"Grammar"]
.sub "postfix:sym<-->"  :subid("286_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1280_tgt
    .local int rx1280_pos
    .local int rx1280_off
    .local int rx1280_eos
    .local int rx1280_rep
    .local pmc rx1280_cur
    .local pmc rx1280_debug
    (rx1280_cur, rx1280_pos, rx1280_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1280_cur
    .local pmc match
    .lex "$/", match
    length rx1280_eos, rx1280_tgt
    gt rx1280_pos, rx1280_eos, rx1280_done
    set rx1280_off, 0
    lt rx1280_pos, 2, rx1280_start
    sub rx1280_off, rx1280_pos, 1
    substr rx1280_tgt, rx1280_tgt, rx1280_off
  rx1280_start:
    eq $I10, 1, rx1280_restart
    if_null rx1280_debug, debug_939
    rx1280_cur."!cursor_debug"("START", "postfix:sym<-->")
  debug_939:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1284_done
    goto rxscan1284_scan
  rxscan1284_loop:
    (rx1280_pos) = rx1280_cur."from"()
    inc rx1280_pos
    rx1280_cur."!cursor_from"(rx1280_pos)
    ge rx1280_pos, rx1280_eos, rxscan1284_done
  rxscan1284_scan:
    set_addr $I10, rxscan1284_loop
    rx1280_cur."!mark_push"(0, rx1280_pos, $I10)
  rxscan1284_done:
.annotate 'line', 587
  # rx subcapture "sym"
    set_addr $I10, rxcap_1285_fail
    rx1280_cur."!mark_push"(0, rx1280_pos, $I10)
  # rx literal  "--"
    add $I11, rx1280_pos, 2
    gt $I11, rx1280_eos, rx1280_fail
    sub $I11, rx1280_pos, rx1280_off
    substr $S10, rx1280_tgt, $I11, 2
    ne $S10, "--", rx1280_fail
    add rx1280_pos, 2
    set_addr $I10, rxcap_1285_fail
    ($I12, $I11) = rx1280_cur."!mark_peek"($I10)
    rx1280_cur."!cursor_pos"($I11)
    ($P10) = rx1280_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1280_pos, "")
    rx1280_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1285_done
  rxcap_1285_fail:
    goto rx1280_fail
  rxcap_1285_done:
  # rx subrule "O" subtype=capture negate=
    rx1280_cur."!cursor_pos"(rx1280_pos)
    $P10 = rx1280_cur."O"("%autoincrement")
    unless $P10, rx1280_fail
    rx1280_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1280_pos = $P10."pos"()
  # rx pass
    rx1280_cur."!cursor_pass"(rx1280_pos, "postfix:sym<-->")
    if_null rx1280_debug, debug_940
    rx1280_cur."!cursor_debug"("PASS", "postfix:sym<-->", " at pos=", rx1280_pos)
  debug_940:
    .return (rx1280_cur)
  rx1280_restart:
.annotate 'line', 4
    if_null rx1280_debug, debug_941
    rx1280_cur."!cursor_debug"("NEXT", "postfix:sym<-->")
  debug_941:
  rx1280_fail:
    (rx1280_rep, rx1280_pos, $I10, $P10) = rx1280_cur."!mark_fail"(0)
    lt rx1280_pos, -1, rx1280_done
    eq rx1280_pos, -1, rx1280_fail
    jump $I10
  rx1280_done:
    rx1280_cur."!cursor_fail"()
    if_null rx1280_debug, debug_942
    rx1280_cur."!cursor_debug"("FAIL", "postfix:sym<-->")
  debug_942:
    .return (rx1280_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<-->"  :nsentry("!PREFIX__postfix:sym<-->") :subid("287_1298325448.42642") :method
.annotate 'line', 4
    $P1282 = self."!PREFIX__!subrule"("O", "--")
    new $P1283, "ResizablePMCArray"
    push $P1283, $P1282
    .return ($P1283)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<**>"  :subid("288_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1287_tgt
    .local int rx1287_pos
    .local int rx1287_off
    .local int rx1287_eos
    .local int rx1287_rep
    .local pmc rx1287_cur
    .local pmc rx1287_debug
    (rx1287_cur, rx1287_pos, rx1287_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1287_cur
    .local pmc match
    .lex "$/", match
    length rx1287_eos, rx1287_tgt
    gt rx1287_pos, rx1287_eos, rx1287_done
    set rx1287_off, 0
    lt rx1287_pos, 2, rx1287_start
    sub rx1287_off, rx1287_pos, 1
    substr rx1287_tgt, rx1287_tgt, rx1287_off
  rx1287_start:
    eq $I10, 1, rx1287_restart
    if_null rx1287_debug, debug_943
    rx1287_cur."!cursor_debug"("START", "infix:sym<**>")
  debug_943:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1291_done
    goto rxscan1291_scan
  rxscan1291_loop:
    (rx1287_pos) = rx1287_cur."from"()
    inc rx1287_pos
    rx1287_cur."!cursor_from"(rx1287_pos)
    ge rx1287_pos, rx1287_eos, rxscan1291_done
  rxscan1291_scan:
    set_addr $I10, rxscan1291_loop
    rx1287_cur."!mark_push"(0, rx1287_pos, $I10)
  rxscan1291_done:
.annotate 'line', 589
  # rx subcapture "sym"
    set_addr $I10, rxcap_1292_fail
    rx1287_cur."!mark_push"(0, rx1287_pos, $I10)
  # rx literal  "**"
    add $I11, rx1287_pos, 2
    gt $I11, rx1287_eos, rx1287_fail
    sub $I11, rx1287_pos, rx1287_off
    substr $S10, rx1287_tgt, $I11, 2
    ne $S10, "**", rx1287_fail
    add rx1287_pos, 2
    set_addr $I10, rxcap_1292_fail
    ($I12, $I11) = rx1287_cur."!mark_peek"($I10)
    rx1287_cur."!cursor_pos"($I11)
    ($P10) = rx1287_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1287_pos, "")
    rx1287_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1292_done
  rxcap_1292_fail:
    goto rx1287_fail
  rxcap_1292_done:
  # rx subrule "O" subtype=capture negate=
    rx1287_cur."!cursor_pos"(rx1287_pos)
    $P10 = rx1287_cur."O"("%exponentiation, :pirop<pow>")
    unless $P10, rx1287_fail
    rx1287_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1287_pos = $P10."pos"()
  # rx pass
    rx1287_cur."!cursor_pass"(rx1287_pos, "infix:sym<**>")
    if_null rx1287_debug, debug_944
    rx1287_cur."!cursor_debug"("PASS", "infix:sym<**>", " at pos=", rx1287_pos)
  debug_944:
    .return (rx1287_cur)
  rx1287_restart:
.annotate 'line', 4
    if_null rx1287_debug, debug_945
    rx1287_cur."!cursor_debug"("NEXT", "infix:sym<**>")
  debug_945:
  rx1287_fail:
    (rx1287_rep, rx1287_pos, $I10, $P10) = rx1287_cur."!mark_fail"(0)
    lt rx1287_pos, -1, rx1287_done
    eq rx1287_pos, -1, rx1287_fail
    jump $I10
  rx1287_done:
    rx1287_cur."!cursor_fail"()
    if_null rx1287_debug, debug_946
    rx1287_cur."!cursor_debug"("FAIL", "infix:sym<**>")
  debug_946:
    .return (rx1287_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<**>"  :nsentry("!PREFIX__infix:sym<**>") :subid("289_1298325448.42642") :method
.annotate 'line', 4
    $P1289 = self."!PREFIX__!subrule"("O", "**")
    new $P1290, "ResizablePMCArray"
    push $P1290, $P1289
    .return ($P1290)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<+>"  :subid("290_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1294_tgt
    .local int rx1294_pos
    .local int rx1294_off
    .local int rx1294_eos
    .local int rx1294_rep
    .local pmc rx1294_cur
    .local pmc rx1294_debug
    (rx1294_cur, rx1294_pos, rx1294_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1294_cur
    .local pmc match
    .lex "$/", match
    length rx1294_eos, rx1294_tgt
    gt rx1294_pos, rx1294_eos, rx1294_done
    set rx1294_off, 0
    lt rx1294_pos, 2, rx1294_start
    sub rx1294_off, rx1294_pos, 1
    substr rx1294_tgt, rx1294_tgt, rx1294_off
  rx1294_start:
    eq $I10, 1, rx1294_restart
    if_null rx1294_debug, debug_947
    rx1294_cur."!cursor_debug"("START", "prefix:sym<+>")
  debug_947:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1298_done
    goto rxscan1298_scan
  rxscan1298_loop:
    (rx1294_pos) = rx1294_cur."from"()
    inc rx1294_pos
    rx1294_cur."!cursor_from"(rx1294_pos)
    ge rx1294_pos, rx1294_eos, rxscan1298_done
  rxscan1298_scan:
    set_addr $I10, rxscan1298_loop
    rx1294_cur."!mark_push"(0, rx1294_pos, $I10)
  rxscan1298_done:
.annotate 'line', 591
  # rx subcapture "sym"
    set_addr $I10, rxcap_1299_fail
    rx1294_cur."!mark_push"(0, rx1294_pos, $I10)
  # rx literal  "+"
    add $I11, rx1294_pos, 1
    gt $I11, rx1294_eos, rx1294_fail
    sub $I11, rx1294_pos, rx1294_off
    ord $I11, rx1294_tgt, $I11
    ne $I11, 43, rx1294_fail
    add rx1294_pos, 1
    set_addr $I10, rxcap_1299_fail
    ($I12, $I11) = rx1294_cur."!mark_peek"($I10)
    rx1294_cur."!cursor_pos"($I11)
    ($P10) = rx1294_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1294_pos, "")
    rx1294_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1299_done
  rxcap_1299_fail:
    goto rx1294_fail
  rxcap_1299_done:
  # rx subrule "O" subtype=capture negate=
    rx1294_cur."!cursor_pos"(rx1294_pos)
    $P10 = rx1294_cur."O"("%symbolic_unary, :pirop<set N*>")
    unless $P10, rx1294_fail
    rx1294_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1294_pos = $P10."pos"()
  # rx pass
    rx1294_cur."!cursor_pass"(rx1294_pos, "prefix:sym<+>")
    if_null rx1294_debug, debug_948
    rx1294_cur."!cursor_debug"("PASS", "prefix:sym<+>", " at pos=", rx1294_pos)
  debug_948:
    .return (rx1294_cur)
  rx1294_restart:
.annotate 'line', 4
    if_null rx1294_debug, debug_949
    rx1294_cur."!cursor_debug"("NEXT", "prefix:sym<+>")
  debug_949:
  rx1294_fail:
    (rx1294_rep, rx1294_pos, $I10, $P10) = rx1294_cur."!mark_fail"(0)
    lt rx1294_pos, -1, rx1294_done
    eq rx1294_pos, -1, rx1294_fail
    jump $I10
  rx1294_done:
    rx1294_cur."!cursor_fail"()
    if_null rx1294_debug, debug_950
    rx1294_cur."!cursor_debug"("FAIL", "prefix:sym<+>")
  debug_950:
    .return (rx1294_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<+>"  :nsentry("!PREFIX__prefix:sym<+>") :subid("291_1298325448.42642") :method
.annotate 'line', 4
    $P1296 = self."!PREFIX__!subrule"("O", "+")
    new $P1297, "ResizablePMCArray"
    push $P1297, $P1296
    .return ($P1297)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<~>"  :subid("292_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1301_tgt
    .local int rx1301_pos
    .local int rx1301_off
    .local int rx1301_eos
    .local int rx1301_rep
    .local pmc rx1301_cur
    .local pmc rx1301_debug
    (rx1301_cur, rx1301_pos, rx1301_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1301_cur
    .local pmc match
    .lex "$/", match
    length rx1301_eos, rx1301_tgt
    gt rx1301_pos, rx1301_eos, rx1301_done
    set rx1301_off, 0
    lt rx1301_pos, 2, rx1301_start
    sub rx1301_off, rx1301_pos, 1
    substr rx1301_tgt, rx1301_tgt, rx1301_off
  rx1301_start:
    eq $I10, 1, rx1301_restart
    if_null rx1301_debug, debug_951
    rx1301_cur."!cursor_debug"("START", "prefix:sym<~>")
  debug_951:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1305_done
    goto rxscan1305_scan
  rxscan1305_loop:
    (rx1301_pos) = rx1301_cur."from"()
    inc rx1301_pos
    rx1301_cur."!cursor_from"(rx1301_pos)
    ge rx1301_pos, rx1301_eos, rxscan1305_done
  rxscan1305_scan:
    set_addr $I10, rxscan1305_loop
    rx1301_cur."!mark_push"(0, rx1301_pos, $I10)
  rxscan1305_done:
.annotate 'line', 592
  # rx subcapture "sym"
    set_addr $I10, rxcap_1306_fail
    rx1301_cur."!mark_push"(0, rx1301_pos, $I10)
  # rx literal  "~"
    add $I11, rx1301_pos, 1
    gt $I11, rx1301_eos, rx1301_fail
    sub $I11, rx1301_pos, rx1301_off
    ord $I11, rx1301_tgt, $I11
    ne $I11, 126, rx1301_fail
    add rx1301_pos, 1
    set_addr $I10, rxcap_1306_fail
    ($I12, $I11) = rx1301_cur."!mark_peek"($I10)
    rx1301_cur."!cursor_pos"($I11)
    ($P10) = rx1301_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1301_pos, "")
    rx1301_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1306_done
  rxcap_1306_fail:
    goto rx1301_fail
  rxcap_1306_done:
  # rx subrule "O" subtype=capture negate=
    rx1301_cur."!cursor_pos"(rx1301_pos)
    $P10 = rx1301_cur."O"("%symbolic_unary, :pirop<set S*>")
    unless $P10, rx1301_fail
    rx1301_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1301_pos = $P10."pos"()
  # rx pass
    rx1301_cur."!cursor_pass"(rx1301_pos, "prefix:sym<~>")
    if_null rx1301_debug, debug_952
    rx1301_cur."!cursor_debug"("PASS", "prefix:sym<~>", " at pos=", rx1301_pos)
  debug_952:
    .return (rx1301_cur)
  rx1301_restart:
.annotate 'line', 4
    if_null rx1301_debug, debug_953
    rx1301_cur."!cursor_debug"("NEXT", "prefix:sym<~>")
  debug_953:
  rx1301_fail:
    (rx1301_rep, rx1301_pos, $I10, $P10) = rx1301_cur."!mark_fail"(0)
    lt rx1301_pos, -1, rx1301_done
    eq rx1301_pos, -1, rx1301_fail
    jump $I10
  rx1301_done:
    rx1301_cur."!cursor_fail"()
    if_null rx1301_debug, debug_954
    rx1301_cur."!cursor_debug"("FAIL", "prefix:sym<~>")
  debug_954:
    .return (rx1301_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<~>"  :nsentry("!PREFIX__prefix:sym<~>") :subid("293_1298325448.42642") :method
.annotate 'line', 4
    $P1303 = self."!PREFIX__!subrule"("O", "~")
    new $P1304, "ResizablePMCArray"
    push $P1304, $P1303
    .return ($P1304)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<->"  :subid("294_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1308_tgt
    .local int rx1308_pos
    .local int rx1308_off
    .local int rx1308_eos
    .local int rx1308_rep
    .local pmc rx1308_cur
    .local pmc rx1308_debug
    (rx1308_cur, rx1308_pos, rx1308_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1308_cur
    .local pmc match
    .lex "$/", match
    length rx1308_eos, rx1308_tgt
    gt rx1308_pos, rx1308_eos, rx1308_done
    set rx1308_off, 0
    lt rx1308_pos, 2, rx1308_start
    sub rx1308_off, rx1308_pos, 1
    substr rx1308_tgt, rx1308_tgt, rx1308_off
  rx1308_start:
    eq $I10, 1, rx1308_restart
    if_null rx1308_debug, debug_955
    rx1308_cur."!cursor_debug"("START", "prefix:sym<->")
  debug_955:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1311_done
    goto rxscan1311_scan
  rxscan1311_loop:
    (rx1308_pos) = rx1308_cur."from"()
    inc rx1308_pos
    rx1308_cur."!cursor_from"(rx1308_pos)
    ge rx1308_pos, rx1308_eos, rxscan1311_done
  rxscan1311_scan:
    set_addr $I10, rxscan1311_loop
    rx1308_cur."!mark_push"(0, rx1308_pos, $I10)
  rxscan1311_done:
.annotate 'line', 593
  # rx subcapture "sym"
    set_addr $I10, rxcap_1312_fail
    rx1308_cur."!mark_push"(0, rx1308_pos, $I10)
  # rx literal  "-"
    add $I11, rx1308_pos, 1
    gt $I11, rx1308_eos, rx1308_fail
    sub $I11, rx1308_pos, rx1308_off
    ord $I11, rx1308_tgt, $I11
    ne $I11, 45, rx1308_fail
    add rx1308_pos, 1
    set_addr $I10, rxcap_1312_fail
    ($I12, $I11) = rx1308_cur."!mark_peek"($I10)
    rx1308_cur."!cursor_pos"($I11)
    ($P10) = rx1308_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1308_pos, "")
    rx1308_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1312_done
  rxcap_1312_fail:
    goto rx1308_fail
  rxcap_1312_done:
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1308_pos, rx1308_off
    substr $S10, rx1308_tgt, $I10, 1
    index $I11, ">", $S10
    ge $I11, 0, rx1308_fail
  # rx subrule "number" subtype=zerowidth negate=1
    rx1308_cur."!cursor_pos"(rx1308_pos)
    $P10 = rx1308_cur."number"()
    if $P10, rx1308_fail
  # rx subrule "O" subtype=capture negate=
    rx1308_cur."!cursor_pos"(rx1308_pos)
    $P10 = rx1308_cur."O"("%symbolic_unary, :pirop<neg>")
    unless $P10, rx1308_fail
    rx1308_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1308_pos = $P10."pos"()
  # rx pass
    rx1308_cur."!cursor_pass"(rx1308_pos, "prefix:sym<->")
    if_null rx1308_debug, debug_956
    rx1308_cur."!cursor_debug"("PASS", "prefix:sym<->", " at pos=", rx1308_pos)
  debug_956:
    .return (rx1308_cur)
  rx1308_restart:
.annotate 'line', 4
    if_null rx1308_debug, debug_957
    rx1308_cur."!cursor_debug"("NEXT", "prefix:sym<->")
  debug_957:
  rx1308_fail:
    (rx1308_rep, rx1308_pos, $I10, $P10) = rx1308_cur."!mark_fail"(0)
    lt rx1308_pos, -1, rx1308_done
    eq rx1308_pos, -1, rx1308_fail
    jump $I10
  rx1308_done:
    rx1308_cur."!cursor_fail"()
    if_null rx1308_debug, debug_958
    rx1308_cur."!cursor_debug"("FAIL", "prefix:sym<->")
  debug_958:
    .return (rx1308_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<->"  :nsentry("!PREFIX__prefix:sym<->") :subid("295_1298325448.42642") :method
.annotate 'line', 4
    new $P1310, "ResizablePMCArray"
    push $P1310, "-"
    .return ($P1310)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<?>"  :subid("296_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1314_tgt
    .local int rx1314_pos
    .local int rx1314_off
    .local int rx1314_eos
    .local int rx1314_rep
    .local pmc rx1314_cur
    .local pmc rx1314_debug
    (rx1314_cur, rx1314_pos, rx1314_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1314_cur
    .local pmc match
    .lex "$/", match
    length rx1314_eos, rx1314_tgt
    gt rx1314_pos, rx1314_eos, rx1314_done
    set rx1314_off, 0
    lt rx1314_pos, 2, rx1314_start
    sub rx1314_off, rx1314_pos, 1
    substr rx1314_tgt, rx1314_tgt, rx1314_off
  rx1314_start:
    eq $I10, 1, rx1314_restart
    if_null rx1314_debug, debug_959
    rx1314_cur."!cursor_debug"("START", "prefix:sym<?>")
  debug_959:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1318_done
    goto rxscan1318_scan
  rxscan1318_loop:
    (rx1314_pos) = rx1314_cur."from"()
    inc rx1314_pos
    rx1314_cur."!cursor_from"(rx1314_pos)
    ge rx1314_pos, rx1314_eos, rxscan1318_done
  rxscan1318_scan:
    set_addr $I10, rxscan1318_loop
    rx1314_cur."!mark_push"(0, rx1314_pos, $I10)
  rxscan1318_done:
.annotate 'line', 594
  # rx subcapture "sym"
    set_addr $I10, rxcap_1319_fail
    rx1314_cur."!mark_push"(0, rx1314_pos, $I10)
  # rx literal  "?"
    add $I11, rx1314_pos, 1
    gt $I11, rx1314_eos, rx1314_fail
    sub $I11, rx1314_pos, rx1314_off
    ord $I11, rx1314_tgt, $I11
    ne $I11, 63, rx1314_fail
    add rx1314_pos, 1
    set_addr $I10, rxcap_1319_fail
    ($I12, $I11) = rx1314_cur."!mark_peek"($I10)
    rx1314_cur."!cursor_pos"($I11)
    ($P10) = rx1314_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1314_pos, "")
    rx1314_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1319_done
  rxcap_1319_fail:
    goto rx1314_fail
  rxcap_1319_done:
  # rx subrule "O" subtype=capture negate=
    rx1314_cur."!cursor_pos"(rx1314_pos)
    $P10 = rx1314_cur."O"("%symbolic_unary, :pirop<istrue>")
    unless $P10, rx1314_fail
    rx1314_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1314_pos = $P10."pos"()
  # rx pass
    rx1314_cur."!cursor_pass"(rx1314_pos, "prefix:sym<?>")
    if_null rx1314_debug, debug_960
    rx1314_cur."!cursor_debug"("PASS", "prefix:sym<?>", " at pos=", rx1314_pos)
  debug_960:
    .return (rx1314_cur)
  rx1314_restart:
.annotate 'line', 4
    if_null rx1314_debug, debug_961
    rx1314_cur."!cursor_debug"("NEXT", "prefix:sym<?>")
  debug_961:
  rx1314_fail:
    (rx1314_rep, rx1314_pos, $I10, $P10) = rx1314_cur."!mark_fail"(0)
    lt rx1314_pos, -1, rx1314_done
    eq rx1314_pos, -1, rx1314_fail
    jump $I10
  rx1314_done:
    rx1314_cur."!cursor_fail"()
    if_null rx1314_debug, debug_962
    rx1314_cur."!cursor_debug"("FAIL", "prefix:sym<?>")
  debug_962:
    .return (rx1314_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<?>"  :nsentry("!PREFIX__prefix:sym<?>") :subid("297_1298325448.42642") :method
.annotate 'line', 4
    $P1316 = self."!PREFIX__!subrule"("O", "?")
    new $P1317, "ResizablePMCArray"
    push $P1317, $P1316
    .return ($P1317)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<!>"  :subid("298_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1321_tgt
    .local int rx1321_pos
    .local int rx1321_off
    .local int rx1321_eos
    .local int rx1321_rep
    .local pmc rx1321_cur
    .local pmc rx1321_debug
    (rx1321_cur, rx1321_pos, rx1321_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1321_cur
    .local pmc match
    .lex "$/", match
    length rx1321_eos, rx1321_tgt
    gt rx1321_pos, rx1321_eos, rx1321_done
    set rx1321_off, 0
    lt rx1321_pos, 2, rx1321_start
    sub rx1321_off, rx1321_pos, 1
    substr rx1321_tgt, rx1321_tgt, rx1321_off
  rx1321_start:
    eq $I10, 1, rx1321_restart
    if_null rx1321_debug, debug_963
    rx1321_cur."!cursor_debug"("START", "prefix:sym<!>")
  debug_963:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1325_done
    goto rxscan1325_scan
  rxscan1325_loop:
    (rx1321_pos) = rx1321_cur."from"()
    inc rx1321_pos
    rx1321_cur."!cursor_from"(rx1321_pos)
    ge rx1321_pos, rx1321_eos, rxscan1325_done
  rxscan1325_scan:
    set_addr $I10, rxscan1325_loop
    rx1321_cur."!mark_push"(0, rx1321_pos, $I10)
  rxscan1325_done:
.annotate 'line', 595
  # rx subcapture "sym"
    set_addr $I10, rxcap_1326_fail
    rx1321_cur."!mark_push"(0, rx1321_pos, $I10)
  # rx literal  "!"
    add $I11, rx1321_pos, 1
    gt $I11, rx1321_eos, rx1321_fail
    sub $I11, rx1321_pos, rx1321_off
    ord $I11, rx1321_tgt, $I11
    ne $I11, 33, rx1321_fail
    add rx1321_pos, 1
    set_addr $I10, rxcap_1326_fail
    ($I12, $I11) = rx1321_cur."!mark_peek"($I10)
    rx1321_cur."!cursor_pos"($I11)
    ($P10) = rx1321_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1321_pos, "")
    rx1321_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1326_done
  rxcap_1326_fail:
    goto rx1321_fail
  rxcap_1326_done:
  # rx subrule "O" subtype=capture negate=
    rx1321_cur."!cursor_pos"(rx1321_pos)
    $P10 = rx1321_cur."O"("%symbolic_unary, :pirop<isfalse>")
    unless $P10, rx1321_fail
    rx1321_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1321_pos = $P10."pos"()
  # rx pass
    rx1321_cur."!cursor_pass"(rx1321_pos, "prefix:sym<!>")
    if_null rx1321_debug, debug_964
    rx1321_cur."!cursor_debug"("PASS", "prefix:sym<!>", " at pos=", rx1321_pos)
  debug_964:
    .return (rx1321_cur)
  rx1321_restart:
.annotate 'line', 4
    if_null rx1321_debug, debug_965
    rx1321_cur."!cursor_debug"("NEXT", "prefix:sym<!>")
  debug_965:
  rx1321_fail:
    (rx1321_rep, rx1321_pos, $I10, $P10) = rx1321_cur."!mark_fail"(0)
    lt rx1321_pos, -1, rx1321_done
    eq rx1321_pos, -1, rx1321_fail
    jump $I10
  rx1321_done:
    rx1321_cur."!cursor_fail"()
    if_null rx1321_debug, debug_966
    rx1321_cur."!cursor_debug"("FAIL", "prefix:sym<!>")
  debug_966:
    .return (rx1321_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<!>"  :nsentry("!PREFIX__prefix:sym<!>") :subid("299_1298325448.42642") :method
.annotate 'line', 4
    $P1323 = self."!PREFIX__!subrule"("O", "!")
    new $P1324, "ResizablePMCArray"
    push $P1324, $P1323
    .return ($P1324)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<|>"  :subid("300_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1328_tgt
    .local int rx1328_pos
    .local int rx1328_off
    .local int rx1328_eos
    .local int rx1328_rep
    .local pmc rx1328_cur
    .local pmc rx1328_debug
    (rx1328_cur, rx1328_pos, rx1328_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1328_cur
    .local pmc match
    .lex "$/", match
    length rx1328_eos, rx1328_tgt
    gt rx1328_pos, rx1328_eos, rx1328_done
    set rx1328_off, 0
    lt rx1328_pos, 2, rx1328_start
    sub rx1328_off, rx1328_pos, 1
    substr rx1328_tgt, rx1328_tgt, rx1328_off
  rx1328_start:
    eq $I10, 1, rx1328_restart
    if_null rx1328_debug, debug_967
    rx1328_cur."!cursor_debug"("START", "prefix:sym<|>")
  debug_967:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1332_done
    goto rxscan1332_scan
  rxscan1332_loop:
    (rx1328_pos) = rx1328_cur."from"()
    inc rx1328_pos
    rx1328_cur."!cursor_from"(rx1328_pos)
    ge rx1328_pos, rx1328_eos, rxscan1332_done
  rxscan1332_scan:
    set_addr $I10, rxscan1332_loop
    rx1328_cur."!mark_push"(0, rx1328_pos, $I10)
  rxscan1332_done:
.annotate 'line', 596
  # rx subcapture "sym"
    set_addr $I10, rxcap_1333_fail
    rx1328_cur."!mark_push"(0, rx1328_pos, $I10)
  # rx literal  "|"
    add $I11, rx1328_pos, 1
    gt $I11, rx1328_eos, rx1328_fail
    sub $I11, rx1328_pos, rx1328_off
    ord $I11, rx1328_tgt, $I11
    ne $I11, 124, rx1328_fail
    add rx1328_pos, 1
    set_addr $I10, rxcap_1333_fail
    ($I12, $I11) = rx1328_cur."!mark_peek"($I10)
    rx1328_cur."!cursor_pos"($I11)
    ($P10) = rx1328_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1328_pos, "")
    rx1328_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1333_done
  rxcap_1333_fail:
    goto rx1328_fail
  rxcap_1333_done:
  # rx subrule "O" subtype=capture negate=
    rx1328_cur."!cursor_pos"(rx1328_pos)
    $P10 = rx1328_cur."O"("%symbolic_unary")
    unless $P10, rx1328_fail
    rx1328_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1328_pos = $P10."pos"()
  # rx pass
    rx1328_cur."!cursor_pass"(rx1328_pos, "prefix:sym<|>")
    if_null rx1328_debug, debug_968
    rx1328_cur."!cursor_debug"("PASS", "prefix:sym<|>", " at pos=", rx1328_pos)
  debug_968:
    .return (rx1328_cur)
  rx1328_restart:
.annotate 'line', 4
    if_null rx1328_debug, debug_969
    rx1328_cur."!cursor_debug"("NEXT", "prefix:sym<|>")
  debug_969:
  rx1328_fail:
    (rx1328_rep, rx1328_pos, $I10, $P10) = rx1328_cur."!mark_fail"(0)
    lt rx1328_pos, -1, rx1328_done
    eq rx1328_pos, -1, rx1328_fail
    jump $I10
  rx1328_done:
    rx1328_cur."!cursor_fail"()
    if_null rx1328_debug, debug_970
    rx1328_cur."!cursor_debug"("FAIL", "prefix:sym<|>")
  debug_970:
    .return (rx1328_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<|>"  :nsentry("!PREFIX__prefix:sym<|>") :subid("301_1298325448.42642") :method
.annotate 'line', 4
    $P1330 = self."!PREFIX__!subrule"("O", "|")
    new $P1331, "ResizablePMCArray"
    push $P1331, $P1330
    .return ($P1331)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<*>"  :subid("302_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1335_tgt
    .local int rx1335_pos
    .local int rx1335_off
    .local int rx1335_eos
    .local int rx1335_rep
    .local pmc rx1335_cur
    .local pmc rx1335_debug
    (rx1335_cur, rx1335_pos, rx1335_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1335_cur
    .local pmc match
    .lex "$/", match
    length rx1335_eos, rx1335_tgt
    gt rx1335_pos, rx1335_eos, rx1335_done
    set rx1335_off, 0
    lt rx1335_pos, 2, rx1335_start
    sub rx1335_off, rx1335_pos, 1
    substr rx1335_tgt, rx1335_tgt, rx1335_off
  rx1335_start:
    eq $I10, 1, rx1335_restart
    if_null rx1335_debug, debug_971
    rx1335_cur."!cursor_debug"("START", "infix:sym<*>")
  debug_971:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1339_done
    goto rxscan1339_scan
  rxscan1339_loop:
    (rx1335_pos) = rx1335_cur."from"()
    inc rx1335_pos
    rx1335_cur."!cursor_from"(rx1335_pos)
    ge rx1335_pos, rx1335_eos, rxscan1339_done
  rxscan1339_scan:
    set_addr $I10, rxscan1339_loop
    rx1335_cur."!mark_push"(0, rx1335_pos, $I10)
  rxscan1339_done:
.annotate 'line', 598
  # rx subcapture "sym"
    set_addr $I10, rxcap_1340_fail
    rx1335_cur."!mark_push"(0, rx1335_pos, $I10)
  # rx literal  "*"
    add $I11, rx1335_pos, 1
    gt $I11, rx1335_eos, rx1335_fail
    sub $I11, rx1335_pos, rx1335_off
    ord $I11, rx1335_tgt, $I11
    ne $I11, 42, rx1335_fail
    add rx1335_pos, 1
    set_addr $I10, rxcap_1340_fail
    ($I12, $I11) = rx1335_cur."!mark_peek"($I10)
    rx1335_cur."!cursor_pos"($I11)
    ($P10) = rx1335_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1335_pos, "")
    rx1335_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1340_done
  rxcap_1340_fail:
    goto rx1335_fail
  rxcap_1340_done:
  # rx subrule "O" subtype=capture negate=
    rx1335_cur."!cursor_pos"(rx1335_pos)
    $P10 = rx1335_cur."O"("%multiplicative, :pirop<mul>")
    unless $P10, rx1335_fail
    rx1335_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1335_pos = $P10."pos"()
  # rx pass
    rx1335_cur."!cursor_pass"(rx1335_pos, "infix:sym<*>")
    if_null rx1335_debug, debug_972
    rx1335_cur."!cursor_debug"("PASS", "infix:sym<*>", " at pos=", rx1335_pos)
  debug_972:
    .return (rx1335_cur)
  rx1335_restart:
.annotate 'line', 4
    if_null rx1335_debug, debug_973
    rx1335_cur."!cursor_debug"("NEXT", "infix:sym<*>")
  debug_973:
  rx1335_fail:
    (rx1335_rep, rx1335_pos, $I10, $P10) = rx1335_cur."!mark_fail"(0)
    lt rx1335_pos, -1, rx1335_done
    eq rx1335_pos, -1, rx1335_fail
    jump $I10
  rx1335_done:
    rx1335_cur."!cursor_fail"()
    if_null rx1335_debug, debug_974
    rx1335_cur."!cursor_debug"("FAIL", "infix:sym<*>")
  debug_974:
    .return (rx1335_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<*>"  :nsentry("!PREFIX__infix:sym<*>") :subid("303_1298325448.42642") :method
.annotate 'line', 4
    $P1337 = self."!PREFIX__!subrule"("O", "*")
    new $P1338, "ResizablePMCArray"
    push $P1338, $P1337
    .return ($P1338)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym</>"  :subid("304_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1342_tgt
    .local int rx1342_pos
    .local int rx1342_off
    .local int rx1342_eos
    .local int rx1342_rep
    .local pmc rx1342_cur
    .local pmc rx1342_debug
    (rx1342_cur, rx1342_pos, rx1342_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1342_cur
    .local pmc match
    .lex "$/", match
    length rx1342_eos, rx1342_tgt
    gt rx1342_pos, rx1342_eos, rx1342_done
    set rx1342_off, 0
    lt rx1342_pos, 2, rx1342_start
    sub rx1342_off, rx1342_pos, 1
    substr rx1342_tgt, rx1342_tgt, rx1342_off
  rx1342_start:
    eq $I10, 1, rx1342_restart
    if_null rx1342_debug, debug_975
    rx1342_cur."!cursor_debug"("START", "infix:sym</>")
  debug_975:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1346_done
    goto rxscan1346_scan
  rxscan1346_loop:
    (rx1342_pos) = rx1342_cur."from"()
    inc rx1342_pos
    rx1342_cur."!cursor_from"(rx1342_pos)
    ge rx1342_pos, rx1342_eos, rxscan1346_done
  rxscan1346_scan:
    set_addr $I10, rxscan1346_loop
    rx1342_cur."!mark_push"(0, rx1342_pos, $I10)
  rxscan1346_done:
.annotate 'line', 599
  # rx subcapture "sym"
    set_addr $I10, rxcap_1347_fail
    rx1342_cur."!mark_push"(0, rx1342_pos, $I10)
  # rx literal  "/"
    add $I11, rx1342_pos, 1
    gt $I11, rx1342_eos, rx1342_fail
    sub $I11, rx1342_pos, rx1342_off
    ord $I11, rx1342_tgt, $I11
    ne $I11, 47, rx1342_fail
    add rx1342_pos, 1
    set_addr $I10, rxcap_1347_fail
    ($I12, $I11) = rx1342_cur."!mark_peek"($I10)
    rx1342_cur."!cursor_pos"($I11)
    ($P10) = rx1342_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1342_pos, "")
    rx1342_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1347_done
  rxcap_1347_fail:
    goto rx1342_fail
  rxcap_1347_done:
  # rx subrule "O" subtype=capture negate=
    rx1342_cur."!cursor_pos"(rx1342_pos)
    $P10 = rx1342_cur."O"("%multiplicative, :pirop<div>")
    unless $P10, rx1342_fail
    rx1342_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1342_pos = $P10."pos"()
  # rx pass
    rx1342_cur."!cursor_pass"(rx1342_pos, "infix:sym</>")
    if_null rx1342_debug, debug_976
    rx1342_cur."!cursor_debug"("PASS", "infix:sym</>", " at pos=", rx1342_pos)
  debug_976:
    .return (rx1342_cur)
  rx1342_restart:
.annotate 'line', 4
    if_null rx1342_debug, debug_977
    rx1342_cur."!cursor_debug"("NEXT", "infix:sym</>")
  debug_977:
  rx1342_fail:
    (rx1342_rep, rx1342_pos, $I10, $P10) = rx1342_cur."!mark_fail"(0)
    lt rx1342_pos, -1, rx1342_done
    eq rx1342_pos, -1, rx1342_fail
    jump $I10
  rx1342_done:
    rx1342_cur."!cursor_fail"()
    if_null rx1342_debug, debug_978
    rx1342_cur."!cursor_debug"("FAIL", "infix:sym</>")
  debug_978:
    .return (rx1342_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym</>"  :nsentry("!PREFIX__infix:sym</>") :subid("305_1298325448.42642") :method
.annotate 'line', 4
    $P1344 = self."!PREFIX__!subrule"("O", "/")
    new $P1345, "ResizablePMCArray"
    push $P1345, $P1344
    .return ($P1345)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<%>"  :subid("306_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1349_tgt
    .local int rx1349_pos
    .local int rx1349_off
    .local int rx1349_eos
    .local int rx1349_rep
    .local pmc rx1349_cur
    .local pmc rx1349_debug
    (rx1349_cur, rx1349_pos, rx1349_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1349_cur
    .local pmc match
    .lex "$/", match
    length rx1349_eos, rx1349_tgt
    gt rx1349_pos, rx1349_eos, rx1349_done
    set rx1349_off, 0
    lt rx1349_pos, 2, rx1349_start
    sub rx1349_off, rx1349_pos, 1
    substr rx1349_tgt, rx1349_tgt, rx1349_off
  rx1349_start:
    eq $I10, 1, rx1349_restart
    if_null rx1349_debug, debug_979
    rx1349_cur."!cursor_debug"("START", "infix:sym<%>")
  debug_979:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1353_done
    goto rxscan1353_scan
  rxscan1353_loop:
    (rx1349_pos) = rx1349_cur."from"()
    inc rx1349_pos
    rx1349_cur."!cursor_from"(rx1349_pos)
    ge rx1349_pos, rx1349_eos, rxscan1353_done
  rxscan1353_scan:
    set_addr $I10, rxscan1353_loop
    rx1349_cur."!mark_push"(0, rx1349_pos, $I10)
  rxscan1353_done:
.annotate 'line', 600
  # rx subcapture "sym"
    set_addr $I10, rxcap_1354_fail
    rx1349_cur."!mark_push"(0, rx1349_pos, $I10)
  # rx literal  "%"
    add $I11, rx1349_pos, 1
    gt $I11, rx1349_eos, rx1349_fail
    sub $I11, rx1349_pos, rx1349_off
    ord $I11, rx1349_tgt, $I11
    ne $I11, 37, rx1349_fail
    add rx1349_pos, 1
    set_addr $I10, rxcap_1354_fail
    ($I12, $I11) = rx1349_cur."!mark_peek"($I10)
    rx1349_cur."!cursor_pos"($I11)
    ($P10) = rx1349_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1349_pos, "")
    rx1349_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1354_done
  rxcap_1354_fail:
    goto rx1349_fail
  rxcap_1354_done:
  # rx subrule "O" subtype=capture negate=
    rx1349_cur."!cursor_pos"(rx1349_pos)
    $P10 = rx1349_cur."O"("%multiplicative, :pirop<mod>")
    unless $P10, rx1349_fail
    rx1349_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1349_pos = $P10."pos"()
  # rx pass
    rx1349_cur."!cursor_pass"(rx1349_pos, "infix:sym<%>")
    if_null rx1349_debug, debug_980
    rx1349_cur."!cursor_debug"("PASS", "infix:sym<%>", " at pos=", rx1349_pos)
  debug_980:
    .return (rx1349_cur)
  rx1349_restart:
.annotate 'line', 4
    if_null rx1349_debug, debug_981
    rx1349_cur."!cursor_debug"("NEXT", "infix:sym<%>")
  debug_981:
  rx1349_fail:
    (rx1349_rep, rx1349_pos, $I10, $P10) = rx1349_cur."!mark_fail"(0)
    lt rx1349_pos, -1, rx1349_done
    eq rx1349_pos, -1, rx1349_fail
    jump $I10
  rx1349_done:
    rx1349_cur."!cursor_fail"()
    if_null rx1349_debug, debug_982
    rx1349_cur."!cursor_debug"("FAIL", "infix:sym<%>")
  debug_982:
    .return (rx1349_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<%>"  :nsentry("!PREFIX__infix:sym<%>") :subid("307_1298325448.42642") :method
.annotate 'line', 4
    $P1351 = self."!PREFIX__!subrule"("O", "%")
    new $P1352, "ResizablePMCArray"
    push $P1352, $P1351
    .return ($P1352)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<+&>"  :subid("308_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1356_tgt
    .local int rx1356_pos
    .local int rx1356_off
    .local int rx1356_eos
    .local int rx1356_rep
    .local pmc rx1356_cur
    .local pmc rx1356_debug
    (rx1356_cur, rx1356_pos, rx1356_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1356_cur
    .local pmc match
    .lex "$/", match
    length rx1356_eos, rx1356_tgt
    gt rx1356_pos, rx1356_eos, rx1356_done
    set rx1356_off, 0
    lt rx1356_pos, 2, rx1356_start
    sub rx1356_off, rx1356_pos, 1
    substr rx1356_tgt, rx1356_tgt, rx1356_off
  rx1356_start:
    eq $I10, 1, rx1356_restart
    if_null rx1356_debug, debug_983
    rx1356_cur."!cursor_debug"("START", "infix:sym<+&>")
  debug_983:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1360_done
    goto rxscan1360_scan
  rxscan1360_loop:
    (rx1356_pos) = rx1356_cur."from"()
    inc rx1356_pos
    rx1356_cur."!cursor_from"(rx1356_pos)
    ge rx1356_pos, rx1356_eos, rxscan1360_done
  rxscan1360_scan:
    set_addr $I10, rxscan1360_loop
    rx1356_cur."!mark_push"(0, rx1356_pos, $I10)
  rxscan1360_done:
.annotate 'line', 601
  # rx subcapture "sym"
    set_addr $I10, rxcap_1361_fail
    rx1356_cur."!mark_push"(0, rx1356_pos, $I10)
  # rx literal  "+&"
    add $I11, rx1356_pos, 2
    gt $I11, rx1356_eos, rx1356_fail
    sub $I11, rx1356_pos, rx1356_off
    substr $S10, rx1356_tgt, $I11, 2
    ne $S10, "+&", rx1356_fail
    add rx1356_pos, 2
    set_addr $I10, rxcap_1361_fail
    ($I12, $I11) = rx1356_cur."!mark_peek"($I10)
    rx1356_cur."!cursor_pos"($I11)
    ($P10) = rx1356_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1356_pos, "")
    rx1356_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1361_done
  rxcap_1361_fail:
    goto rx1356_fail
  rxcap_1361_done:
  # rx subrule "O" subtype=capture negate=
    rx1356_cur."!cursor_pos"(rx1356_pos)
    $P10 = rx1356_cur."O"("%multiplicative, :pirop<band III>")
    unless $P10, rx1356_fail
    rx1356_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1356_pos = $P10."pos"()
  # rx pass
    rx1356_cur."!cursor_pass"(rx1356_pos, "infix:sym<+&>")
    if_null rx1356_debug, debug_984
    rx1356_cur."!cursor_debug"("PASS", "infix:sym<+&>", " at pos=", rx1356_pos)
  debug_984:
    .return (rx1356_cur)
  rx1356_restart:
.annotate 'line', 4
    if_null rx1356_debug, debug_985
    rx1356_cur."!cursor_debug"("NEXT", "infix:sym<+&>")
  debug_985:
  rx1356_fail:
    (rx1356_rep, rx1356_pos, $I10, $P10) = rx1356_cur."!mark_fail"(0)
    lt rx1356_pos, -1, rx1356_done
    eq rx1356_pos, -1, rx1356_fail
    jump $I10
  rx1356_done:
    rx1356_cur."!cursor_fail"()
    if_null rx1356_debug, debug_986
    rx1356_cur."!cursor_debug"("FAIL", "infix:sym<+&>")
  debug_986:
    .return (rx1356_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+&>"  :nsentry("!PREFIX__infix:sym<+&>") :subid("309_1298325448.42642") :method
.annotate 'line', 4
    $P1358 = self."!PREFIX__!subrule"("O", "+&")
    new $P1359, "ResizablePMCArray"
    push $P1359, $P1358
    .return ($P1359)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<+>"  :subid("310_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1363_tgt
    .local int rx1363_pos
    .local int rx1363_off
    .local int rx1363_eos
    .local int rx1363_rep
    .local pmc rx1363_cur
    .local pmc rx1363_debug
    (rx1363_cur, rx1363_pos, rx1363_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1363_cur
    .local pmc match
    .lex "$/", match
    length rx1363_eos, rx1363_tgt
    gt rx1363_pos, rx1363_eos, rx1363_done
    set rx1363_off, 0
    lt rx1363_pos, 2, rx1363_start
    sub rx1363_off, rx1363_pos, 1
    substr rx1363_tgt, rx1363_tgt, rx1363_off
  rx1363_start:
    eq $I10, 1, rx1363_restart
    if_null rx1363_debug, debug_987
    rx1363_cur."!cursor_debug"("START", "infix:sym<+>")
  debug_987:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1367_done
    goto rxscan1367_scan
  rxscan1367_loop:
    (rx1363_pos) = rx1363_cur."from"()
    inc rx1363_pos
    rx1363_cur."!cursor_from"(rx1363_pos)
    ge rx1363_pos, rx1363_eos, rxscan1367_done
  rxscan1367_scan:
    set_addr $I10, rxscan1367_loop
    rx1363_cur."!mark_push"(0, rx1363_pos, $I10)
  rxscan1367_done:
.annotate 'line', 603
  # rx subcapture "sym"
    set_addr $I10, rxcap_1368_fail
    rx1363_cur."!mark_push"(0, rx1363_pos, $I10)
  # rx literal  "+"
    add $I11, rx1363_pos, 1
    gt $I11, rx1363_eos, rx1363_fail
    sub $I11, rx1363_pos, rx1363_off
    ord $I11, rx1363_tgt, $I11
    ne $I11, 43, rx1363_fail
    add rx1363_pos, 1
    set_addr $I10, rxcap_1368_fail
    ($I12, $I11) = rx1363_cur."!mark_peek"($I10)
    rx1363_cur."!cursor_pos"($I11)
    ($P10) = rx1363_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1363_pos, "")
    rx1363_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1368_done
  rxcap_1368_fail:
    goto rx1363_fail
  rxcap_1368_done:
  # rx subrule "O" subtype=capture negate=
    rx1363_cur."!cursor_pos"(rx1363_pos)
    $P10 = rx1363_cur."O"("%additive, :pirop<add>")
    unless $P10, rx1363_fail
    rx1363_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1363_pos = $P10."pos"()
  # rx pass
    rx1363_cur."!cursor_pass"(rx1363_pos, "infix:sym<+>")
    if_null rx1363_debug, debug_988
    rx1363_cur."!cursor_debug"("PASS", "infix:sym<+>", " at pos=", rx1363_pos)
  debug_988:
    .return (rx1363_cur)
  rx1363_restart:
.annotate 'line', 4
    if_null rx1363_debug, debug_989
    rx1363_cur."!cursor_debug"("NEXT", "infix:sym<+>")
  debug_989:
  rx1363_fail:
    (rx1363_rep, rx1363_pos, $I10, $P10) = rx1363_cur."!mark_fail"(0)
    lt rx1363_pos, -1, rx1363_done
    eq rx1363_pos, -1, rx1363_fail
    jump $I10
  rx1363_done:
    rx1363_cur."!cursor_fail"()
    if_null rx1363_debug, debug_990
    rx1363_cur."!cursor_debug"("FAIL", "infix:sym<+>")
  debug_990:
    .return (rx1363_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+>"  :nsentry("!PREFIX__infix:sym<+>") :subid("311_1298325448.42642") :method
.annotate 'line', 4
    $P1365 = self."!PREFIX__!subrule"("O", "+")
    new $P1366, "ResizablePMCArray"
    push $P1366, $P1365
    .return ($P1366)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<->"  :subid("312_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1370_tgt
    .local int rx1370_pos
    .local int rx1370_off
    .local int rx1370_eos
    .local int rx1370_rep
    .local pmc rx1370_cur
    .local pmc rx1370_debug
    (rx1370_cur, rx1370_pos, rx1370_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1370_cur
    .local pmc match
    .lex "$/", match
    length rx1370_eos, rx1370_tgt
    gt rx1370_pos, rx1370_eos, rx1370_done
    set rx1370_off, 0
    lt rx1370_pos, 2, rx1370_start
    sub rx1370_off, rx1370_pos, 1
    substr rx1370_tgt, rx1370_tgt, rx1370_off
  rx1370_start:
    eq $I10, 1, rx1370_restart
    if_null rx1370_debug, debug_991
    rx1370_cur."!cursor_debug"("START", "infix:sym<->")
  debug_991:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1374_done
    goto rxscan1374_scan
  rxscan1374_loop:
    (rx1370_pos) = rx1370_cur."from"()
    inc rx1370_pos
    rx1370_cur."!cursor_from"(rx1370_pos)
    ge rx1370_pos, rx1370_eos, rxscan1374_done
  rxscan1374_scan:
    set_addr $I10, rxscan1374_loop
    rx1370_cur."!mark_push"(0, rx1370_pos, $I10)
  rxscan1374_done:
.annotate 'line', 604
  # rx subcapture "sym"
    set_addr $I10, rxcap_1375_fail
    rx1370_cur."!mark_push"(0, rx1370_pos, $I10)
  # rx literal  "-"
    add $I11, rx1370_pos, 1
    gt $I11, rx1370_eos, rx1370_fail
    sub $I11, rx1370_pos, rx1370_off
    ord $I11, rx1370_tgt, $I11
    ne $I11, 45, rx1370_fail
    add rx1370_pos, 1
    set_addr $I10, rxcap_1375_fail
    ($I12, $I11) = rx1370_cur."!mark_peek"($I10)
    rx1370_cur."!cursor_pos"($I11)
    ($P10) = rx1370_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1370_pos, "")
    rx1370_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1375_done
  rxcap_1375_fail:
    goto rx1370_fail
  rxcap_1375_done:
  # rx subrule "O" subtype=capture negate=
    rx1370_cur."!cursor_pos"(rx1370_pos)
    $P10 = rx1370_cur."O"("%additive, :pirop<sub>")
    unless $P10, rx1370_fail
    rx1370_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1370_pos = $P10."pos"()
  # rx pass
    rx1370_cur."!cursor_pass"(rx1370_pos, "infix:sym<->")
    if_null rx1370_debug, debug_992
    rx1370_cur."!cursor_debug"("PASS", "infix:sym<->", " at pos=", rx1370_pos)
  debug_992:
    .return (rx1370_cur)
  rx1370_restart:
.annotate 'line', 4
    if_null rx1370_debug, debug_993
    rx1370_cur."!cursor_debug"("NEXT", "infix:sym<->")
  debug_993:
  rx1370_fail:
    (rx1370_rep, rx1370_pos, $I10, $P10) = rx1370_cur."!mark_fail"(0)
    lt rx1370_pos, -1, rx1370_done
    eq rx1370_pos, -1, rx1370_fail
    jump $I10
  rx1370_done:
    rx1370_cur."!cursor_fail"()
    if_null rx1370_debug, debug_994
    rx1370_cur."!cursor_debug"("FAIL", "infix:sym<->")
  debug_994:
    .return (rx1370_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<->"  :nsentry("!PREFIX__infix:sym<->") :subid("313_1298325448.42642") :method
.annotate 'line', 4
    $P1372 = self."!PREFIX__!subrule"("O", "-")
    new $P1373, "ResizablePMCArray"
    push $P1373, $P1372
    .return ($P1373)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<+|>"  :subid("314_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1377_tgt
    .local int rx1377_pos
    .local int rx1377_off
    .local int rx1377_eos
    .local int rx1377_rep
    .local pmc rx1377_cur
    .local pmc rx1377_debug
    (rx1377_cur, rx1377_pos, rx1377_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1377_cur
    .local pmc match
    .lex "$/", match
    length rx1377_eos, rx1377_tgt
    gt rx1377_pos, rx1377_eos, rx1377_done
    set rx1377_off, 0
    lt rx1377_pos, 2, rx1377_start
    sub rx1377_off, rx1377_pos, 1
    substr rx1377_tgt, rx1377_tgt, rx1377_off
  rx1377_start:
    eq $I10, 1, rx1377_restart
    if_null rx1377_debug, debug_995
    rx1377_cur."!cursor_debug"("START", "infix:sym<+|>")
  debug_995:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1381_done
    goto rxscan1381_scan
  rxscan1381_loop:
    (rx1377_pos) = rx1377_cur."from"()
    inc rx1377_pos
    rx1377_cur."!cursor_from"(rx1377_pos)
    ge rx1377_pos, rx1377_eos, rxscan1381_done
  rxscan1381_scan:
    set_addr $I10, rxscan1381_loop
    rx1377_cur."!mark_push"(0, rx1377_pos, $I10)
  rxscan1381_done:
.annotate 'line', 605
  # rx subcapture "sym"
    set_addr $I10, rxcap_1382_fail
    rx1377_cur."!mark_push"(0, rx1377_pos, $I10)
  # rx literal  "+|"
    add $I11, rx1377_pos, 2
    gt $I11, rx1377_eos, rx1377_fail
    sub $I11, rx1377_pos, rx1377_off
    substr $S10, rx1377_tgt, $I11, 2
    ne $S10, "+|", rx1377_fail
    add rx1377_pos, 2
    set_addr $I10, rxcap_1382_fail
    ($I12, $I11) = rx1377_cur."!mark_peek"($I10)
    rx1377_cur."!cursor_pos"($I11)
    ($P10) = rx1377_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1377_pos, "")
    rx1377_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1382_done
  rxcap_1382_fail:
    goto rx1377_fail
  rxcap_1382_done:
  # rx subrule "O" subtype=capture negate=
    rx1377_cur."!cursor_pos"(rx1377_pos)
    $P10 = rx1377_cur."O"("%additive, :pirop<bor III>")
    unless $P10, rx1377_fail
    rx1377_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1377_pos = $P10."pos"()
  # rx pass
    rx1377_cur."!cursor_pass"(rx1377_pos, "infix:sym<+|>")
    if_null rx1377_debug, debug_996
    rx1377_cur."!cursor_debug"("PASS", "infix:sym<+|>", " at pos=", rx1377_pos)
  debug_996:
    .return (rx1377_cur)
  rx1377_restart:
.annotate 'line', 4
    if_null rx1377_debug, debug_997
    rx1377_cur."!cursor_debug"("NEXT", "infix:sym<+|>")
  debug_997:
  rx1377_fail:
    (rx1377_rep, rx1377_pos, $I10, $P10) = rx1377_cur."!mark_fail"(0)
    lt rx1377_pos, -1, rx1377_done
    eq rx1377_pos, -1, rx1377_fail
    jump $I10
  rx1377_done:
    rx1377_cur."!cursor_fail"()
    if_null rx1377_debug, debug_998
    rx1377_cur."!cursor_debug"("FAIL", "infix:sym<+|>")
  debug_998:
    .return (rx1377_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+|>"  :nsentry("!PREFIX__infix:sym<+|>") :subid("315_1298325448.42642") :method
.annotate 'line', 4
    $P1379 = self."!PREFIX__!subrule"("O", "+|")
    new $P1380, "ResizablePMCArray"
    push $P1380, $P1379
    .return ($P1380)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<+^>"  :subid("316_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1384_tgt
    .local int rx1384_pos
    .local int rx1384_off
    .local int rx1384_eos
    .local int rx1384_rep
    .local pmc rx1384_cur
    .local pmc rx1384_debug
    (rx1384_cur, rx1384_pos, rx1384_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1384_cur
    .local pmc match
    .lex "$/", match
    length rx1384_eos, rx1384_tgt
    gt rx1384_pos, rx1384_eos, rx1384_done
    set rx1384_off, 0
    lt rx1384_pos, 2, rx1384_start
    sub rx1384_off, rx1384_pos, 1
    substr rx1384_tgt, rx1384_tgt, rx1384_off
  rx1384_start:
    eq $I10, 1, rx1384_restart
    if_null rx1384_debug, debug_999
    rx1384_cur."!cursor_debug"("START", "infix:sym<+^>")
  debug_999:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1388_done
    goto rxscan1388_scan
  rxscan1388_loop:
    (rx1384_pos) = rx1384_cur."from"()
    inc rx1384_pos
    rx1384_cur."!cursor_from"(rx1384_pos)
    ge rx1384_pos, rx1384_eos, rxscan1388_done
  rxscan1388_scan:
    set_addr $I10, rxscan1388_loop
    rx1384_cur."!mark_push"(0, rx1384_pos, $I10)
  rxscan1388_done:
.annotate 'line', 606
  # rx subcapture "sym"
    set_addr $I10, rxcap_1389_fail
    rx1384_cur."!mark_push"(0, rx1384_pos, $I10)
  # rx literal  "+^"
    add $I11, rx1384_pos, 2
    gt $I11, rx1384_eos, rx1384_fail
    sub $I11, rx1384_pos, rx1384_off
    substr $S10, rx1384_tgt, $I11, 2
    ne $S10, "+^", rx1384_fail
    add rx1384_pos, 2
    set_addr $I10, rxcap_1389_fail
    ($I12, $I11) = rx1384_cur."!mark_peek"($I10)
    rx1384_cur."!cursor_pos"($I11)
    ($P10) = rx1384_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1384_pos, "")
    rx1384_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1389_done
  rxcap_1389_fail:
    goto rx1384_fail
  rxcap_1389_done:
  # rx subrule "O" subtype=capture negate=
    rx1384_cur."!cursor_pos"(rx1384_pos)
    $P10 = rx1384_cur."O"("%additive, :pirop<bxor III>")
    unless $P10, rx1384_fail
    rx1384_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1384_pos = $P10."pos"()
  # rx pass
    rx1384_cur."!cursor_pass"(rx1384_pos, "infix:sym<+^>")
    if_null rx1384_debug, debug_1000
    rx1384_cur."!cursor_debug"("PASS", "infix:sym<+^>", " at pos=", rx1384_pos)
  debug_1000:
    .return (rx1384_cur)
  rx1384_restart:
.annotate 'line', 4
    if_null rx1384_debug, debug_1001
    rx1384_cur."!cursor_debug"("NEXT", "infix:sym<+^>")
  debug_1001:
  rx1384_fail:
    (rx1384_rep, rx1384_pos, $I10, $P10) = rx1384_cur."!mark_fail"(0)
    lt rx1384_pos, -1, rx1384_done
    eq rx1384_pos, -1, rx1384_fail
    jump $I10
  rx1384_done:
    rx1384_cur."!cursor_fail"()
    if_null rx1384_debug, debug_1002
    rx1384_cur."!cursor_debug"("FAIL", "infix:sym<+^>")
  debug_1002:
    .return (rx1384_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+^>"  :nsentry("!PREFIX__infix:sym<+^>") :subid("317_1298325448.42642") :method
.annotate 'line', 4
    $P1386 = self."!PREFIX__!subrule"("O", "+^")
    new $P1387, "ResizablePMCArray"
    push $P1387, $P1386
    .return ($P1387)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<~>"  :subid("318_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1391_tgt
    .local int rx1391_pos
    .local int rx1391_off
    .local int rx1391_eos
    .local int rx1391_rep
    .local pmc rx1391_cur
    .local pmc rx1391_debug
    (rx1391_cur, rx1391_pos, rx1391_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1391_cur
    .local pmc match
    .lex "$/", match
    length rx1391_eos, rx1391_tgt
    gt rx1391_pos, rx1391_eos, rx1391_done
    set rx1391_off, 0
    lt rx1391_pos, 2, rx1391_start
    sub rx1391_off, rx1391_pos, 1
    substr rx1391_tgt, rx1391_tgt, rx1391_off
  rx1391_start:
    eq $I10, 1, rx1391_restart
    if_null rx1391_debug, debug_1003
    rx1391_cur."!cursor_debug"("START", "infix:sym<~>")
  debug_1003:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1395_done
    goto rxscan1395_scan
  rxscan1395_loop:
    (rx1391_pos) = rx1391_cur."from"()
    inc rx1391_pos
    rx1391_cur."!cursor_from"(rx1391_pos)
    ge rx1391_pos, rx1391_eos, rxscan1395_done
  rxscan1395_scan:
    set_addr $I10, rxscan1395_loop
    rx1391_cur."!mark_push"(0, rx1391_pos, $I10)
  rxscan1395_done:
.annotate 'line', 608
  # rx subcapture "sym"
    set_addr $I10, rxcap_1396_fail
    rx1391_cur."!mark_push"(0, rx1391_pos, $I10)
  # rx literal  "~"
    add $I11, rx1391_pos, 1
    gt $I11, rx1391_eos, rx1391_fail
    sub $I11, rx1391_pos, rx1391_off
    ord $I11, rx1391_tgt, $I11
    ne $I11, 126, rx1391_fail
    add rx1391_pos, 1
    set_addr $I10, rxcap_1396_fail
    ($I12, $I11) = rx1391_cur."!mark_peek"($I10)
    rx1391_cur."!cursor_pos"($I11)
    ($P10) = rx1391_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1391_pos, "")
    rx1391_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1396_done
  rxcap_1396_fail:
    goto rx1391_fail
  rxcap_1396_done:
  # rx subrule "O" subtype=capture negate=
    rx1391_cur."!cursor_pos"(rx1391_pos)
    $P10 = rx1391_cur."O"("%concatenation , :pirop<concat>")
    unless $P10, rx1391_fail
    rx1391_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1391_pos = $P10."pos"()
  # rx pass
    rx1391_cur."!cursor_pass"(rx1391_pos, "infix:sym<~>")
    if_null rx1391_debug, debug_1004
    rx1391_cur."!cursor_debug"("PASS", "infix:sym<~>", " at pos=", rx1391_pos)
  debug_1004:
    .return (rx1391_cur)
  rx1391_restart:
.annotate 'line', 4
    if_null rx1391_debug, debug_1005
    rx1391_cur."!cursor_debug"("NEXT", "infix:sym<~>")
  debug_1005:
  rx1391_fail:
    (rx1391_rep, rx1391_pos, $I10, $P10) = rx1391_cur."!mark_fail"(0)
    lt rx1391_pos, -1, rx1391_done
    eq rx1391_pos, -1, rx1391_fail
    jump $I10
  rx1391_done:
    rx1391_cur."!cursor_fail"()
    if_null rx1391_debug, debug_1006
    rx1391_cur."!cursor_debug"("FAIL", "infix:sym<~>")
  debug_1006:
    .return (rx1391_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~>"  :nsentry("!PREFIX__infix:sym<~>") :subid("319_1298325448.42642") :method
.annotate 'line', 4
    $P1393 = self."!PREFIX__!subrule"("O", "~")
    new $P1394, "ResizablePMCArray"
    push $P1394, $P1393
    .return ($P1394)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<==>"  :subid("320_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1398_tgt
    .local int rx1398_pos
    .local int rx1398_off
    .local int rx1398_eos
    .local int rx1398_rep
    .local pmc rx1398_cur
    .local pmc rx1398_debug
    (rx1398_cur, rx1398_pos, rx1398_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1398_cur
    .local pmc match
    .lex "$/", match
    length rx1398_eos, rx1398_tgt
    gt rx1398_pos, rx1398_eos, rx1398_done
    set rx1398_off, 0
    lt rx1398_pos, 2, rx1398_start
    sub rx1398_off, rx1398_pos, 1
    substr rx1398_tgt, rx1398_tgt, rx1398_off
  rx1398_start:
    eq $I10, 1, rx1398_restart
    if_null rx1398_debug, debug_1007
    rx1398_cur."!cursor_debug"("START", "infix:sym<==>")
  debug_1007:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1402_done
    goto rxscan1402_scan
  rxscan1402_loop:
    (rx1398_pos) = rx1398_cur."from"()
    inc rx1398_pos
    rx1398_cur."!cursor_from"(rx1398_pos)
    ge rx1398_pos, rx1398_eos, rxscan1402_done
  rxscan1402_scan:
    set_addr $I10, rxscan1402_loop
    rx1398_cur."!mark_push"(0, rx1398_pos, $I10)
  rxscan1402_done:
.annotate 'line', 610
  # rx subcapture "sym"
    set_addr $I10, rxcap_1403_fail
    rx1398_cur."!mark_push"(0, rx1398_pos, $I10)
  # rx literal  "=="
    add $I11, rx1398_pos, 2
    gt $I11, rx1398_eos, rx1398_fail
    sub $I11, rx1398_pos, rx1398_off
    substr $S10, rx1398_tgt, $I11, 2
    ne $S10, "==", rx1398_fail
    add rx1398_pos, 2
    set_addr $I10, rxcap_1403_fail
    ($I12, $I11) = rx1398_cur."!mark_peek"($I10)
    rx1398_cur."!cursor_pos"($I11)
    ($P10) = rx1398_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1398_pos, "")
    rx1398_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1403_done
  rxcap_1403_fail:
    goto rx1398_fail
  rxcap_1403_done:
  # rx subrule "O" subtype=capture negate=
    rx1398_cur."!cursor_pos"(rx1398_pos)
    $P10 = rx1398_cur."O"("%relational, :pirop<iseq INn>")
    unless $P10, rx1398_fail
    rx1398_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1398_pos = $P10."pos"()
  # rx pass
    rx1398_cur."!cursor_pass"(rx1398_pos, "infix:sym<==>")
    if_null rx1398_debug, debug_1008
    rx1398_cur."!cursor_debug"("PASS", "infix:sym<==>", " at pos=", rx1398_pos)
  debug_1008:
    .return (rx1398_cur)
  rx1398_restart:
.annotate 'line', 4
    if_null rx1398_debug, debug_1009
    rx1398_cur."!cursor_debug"("NEXT", "infix:sym<==>")
  debug_1009:
  rx1398_fail:
    (rx1398_rep, rx1398_pos, $I10, $P10) = rx1398_cur."!mark_fail"(0)
    lt rx1398_pos, -1, rx1398_done
    eq rx1398_pos, -1, rx1398_fail
    jump $I10
  rx1398_done:
    rx1398_cur."!cursor_fail"()
    if_null rx1398_debug, debug_1010
    rx1398_cur."!cursor_debug"("FAIL", "infix:sym<==>")
  debug_1010:
    .return (rx1398_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<==>"  :nsentry("!PREFIX__infix:sym<==>") :subid("321_1298325448.42642") :method
.annotate 'line', 4
    $P1400 = self."!PREFIX__!subrule"("O", "==")
    new $P1401, "ResizablePMCArray"
    push $P1401, $P1400
    .return ($P1401)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<!=>"  :subid("322_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1405_tgt
    .local int rx1405_pos
    .local int rx1405_off
    .local int rx1405_eos
    .local int rx1405_rep
    .local pmc rx1405_cur
    .local pmc rx1405_debug
    (rx1405_cur, rx1405_pos, rx1405_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1405_cur
    .local pmc match
    .lex "$/", match
    length rx1405_eos, rx1405_tgt
    gt rx1405_pos, rx1405_eos, rx1405_done
    set rx1405_off, 0
    lt rx1405_pos, 2, rx1405_start
    sub rx1405_off, rx1405_pos, 1
    substr rx1405_tgt, rx1405_tgt, rx1405_off
  rx1405_start:
    eq $I10, 1, rx1405_restart
    if_null rx1405_debug, debug_1011
    rx1405_cur."!cursor_debug"("START", "infix:sym<!=>")
  debug_1011:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1409_done
    goto rxscan1409_scan
  rxscan1409_loop:
    (rx1405_pos) = rx1405_cur."from"()
    inc rx1405_pos
    rx1405_cur."!cursor_from"(rx1405_pos)
    ge rx1405_pos, rx1405_eos, rxscan1409_done
  rxscan1409_scan:
    set_addr $I10, rxscan1409_loop
    rx1405_cur."!mark_push"(0, rx1405_pos, $I10)
  rxscan1409_done:
.annotate 'line', 611
  # rx subcapture "sym"
    set_addr $I10, rxcap_1410_fail
    rx1405_cur."!mark_push"(0, rx1405_pos, $I10)
  # rx literal  "!="
    add $I11, rx1405_pos, 2
    gt $I11, rx1405_eos, rx1405_fail
    sub $I11, rx1405_pos, rx1405_off
    substr $S10, rx1405_tgt, $I11, 2
    ne $S10, "!=", rx1405_fail
    add rx1405_pos, 2
    set_addr $I10, rxcap_1410_fail
    ($I12, $I11) = rx1405_cur."!mark_peek"($I10)
    rx1405_cur."!cursor_pos"($I11)
    ($P10) = rx1405_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1405_pos, "")
    rx1405_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1410_done
  rxcap_1410_fail:
    goto rx1405_fail
  rxcap_1410_done:
  # rx subrule "O" subtype=capture negate=
    rx1405_cur."!cursor_pos"(rx1405_pos)
    $P10 = rx1405_cur."O"("%relational, :pirop<isne INn>")
    unless $P10, rx1405_fail
    rx1405_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1405_pos = $P10."pos"()
  # rx pass
    rx1405_cur."!cursor_pass"(rx1405_pos, "infix:sym<!=>")
    if_null rx1405_debug, debug_1012
    rx1405_cur."!cursor_debug"("PASS", "infix:sym<!=>", " at pos=", rx1405_pos)
  debug_1012:
    .return (rx1405_cur)
  rx1405_restart:
.annotate 'line', 4
    if_null rx1405_debug, debug_1013
    rx1405_cur."!cursor_debug"("NEXT", "infix:sym<!=>")
  debug_1013:
  rx1405_fail:
    (rx1405_rep, rx1405_pos, $I10, $P10) = rx1405_cur."!mark_fail"(0)
    lt rx1405_pos, -1, rx1405_done
    eq rx1405_pos, -1, rx1405_fail
    jump $I10
  rx1405_done:
    rx1405_cur."!cursor_fail"()
    if_null rx1405_debug, debug_1014
    rx1405_cur."!cursor_debug"("FAIL", "infix:sym<!=>")
  debug_1014:
    .return (rx1405_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<!=>"  :nsentry("!PREFIX__infix:sym<!=>") :subid("323_1298325448.42642") :method
.annotate 'line', 4
    $P1407 = self."!PREFIX__!subrule"("O", "!=")
    new $P1408, "ResizablePMCArray"
    push $P1408, $P1407
    .return ($P1408)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<<=>"  :subid("324_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1412_tgt
    .local int rx1412_pos
    .local int rx1412_off
    .local int rx1412_eos
    .local int rx1412_rep
    .local pmc rx1412_cur
    .local pmc rx1412_debug
    (rx1412_cur, rx1412_pos, rx1412_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1412_cur
    .local pmc match
    .lex "$/", match
    length rx1412_eos, rx1412_tgt
    gt rx1412_pos, rx1412_eos, rx1412_done
    set rx1412_off, 0
    lt rx1412_pos, 2, rx1412_start
    sub rx1412_off, rx1412_pos, 1
    substr rx1412_tgt, rx1412_tgt, rx1412_off
  rx1412_start:
    eq $I10, 1, rx1412_restart
    if_null rx1412_debug, debug_1015
    rx1412_cur."!cursor_debug"("START", "infix:sym<<=>")
  debug_1015:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1416_done
    goto rxscan1416_scan
  rxscan1416_loop:
    (rx1412_pos) = rx1412_cur."from"()
    inc rx1412_pos
    rx1412_cur."!cursor_from"(rx1412_pos)
    ge rx1412_pos, rx1412_eos, rxscan1416_done
  rxscan1416_scan:
    set_addr $I10, rxscan1416_loop
    rx1412_cur."!mark_push"(0, rx1412_pos, $I10)
  rxscan1416_done:
.annotate 'line', 612
  # rx subcapture "sym"
    set_addr $I10, rxcap_1417_fail
    rx1412_cur."!mark_push"(0, rx1412_pos, $I10)
  # rx literal  "<="
    add $I11, rx1412_pos, 2
    gt $I11, rx1412_eos, rx1412_fail
    sub $I11, rx1412_pos, rx1412_off
    substr $S10, rx1412_tgt, $I11, 2
    ne $S10, "<=", rx1412_fail
    add rx1412_pos, 2
    set_addr $I10, rxcap_1417_fail
    ($I12, $I11) = rx1412_cur."!mark_peek"($I10)
    rx1412_cur."!cursor_pos"($I11)
    ($P10) = rx1412_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1412_pos, "")
    rx1412_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1417_done
  rxcap_1417_fail:
    goto rx1412_fail
  rxcap_1417_done:
  # rx subrule "O" subtype=capture negate=
    rx1412_cur."!cursor_pos"(rx1412_pos)
    $P10 = rx1412_cur."O"("%relational, :pirop<isle INn>")
    unless $P10, rx1412_fail
    rx1412_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1412_pos = $P10."pos"()
  # rx pass
    rx1412_cur."!cursor_pass"(rx1412_pos, "infix:sym<<=>")
    if_null rx1412_debug, debug_1016
    rx1412_cur."!cursor_debug"("PASS", "infix:sym<<=>", " at pos=", rx1412_pos)
  debug_1016:
    .return (rx1412_cur)
  rx1412_restart:
.annotate 'line', 4
    if_null rx1412_debug, debug_1017
    rx1412_cur."!cursor_debug"("NEXT", "infix:sym<<=>")
  debug_1017:
  rx1412_fail:
    (rx1412_rep, rx1412_pos, $I10, $P10) = rx1412_cur."!mark_fail"(0)
    lt rx1412_pos, -1, rx1412_done
    eq rx1412_pos, -1, rx1412_fail
    jump $I10
  rx1412_done:
    rx1412_cur."!cursor_fail"()
    if_null rx1412_debug, debug_1018
    rx1412_cur."!cursor_debug"("FAIL", "infix:sym<<=>")
  debug_1018:
    .return (rx1412_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<=>"  :nsentry("!PREFIX__infix:sym<<=>") :subid("325_1298325448.42642") :method
.annotate 'line', 4
    $P1414 = self."!PREFIX__!subrule"("O", "<=")
    new $P1415, "ResizablePMCArray"
    push $P1415, $P1414
    .return ($P1415)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<>=>"  :subid("326_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1419_tgt
    .local int rx1419_pos
    .local int rx1419_off
    .local int rx1419_eos
    .local int rx1419_rep
    .local pmc rx1419_cur
    .local pmc rx1419_debug
    (rx1419_cur, rx1419_pos, rx1419_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1419_cur
    .local pmc match
    .lex "$/", match
    length rx1419_eos, rx1419_tgt
    gt rx1419_pos, rx1419_eos, rx1419_done
    set rx1419_off, 0
    lt rx1419_pos, 2, rx1419_start
    sub rx1419_off, rx1419_pos, 1
    substr rx1419_tgt, rx1419_tgt, rx1419_off
  rx1419_start:
    eq $I10, 1, rx1419_restart
    if_null rx1419_debug, debug_1019
    rx1419_cur."!cursor_debug"("START", "infix:sym<>=>")
  debug_1019:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1423_done
    goto rxscan1423_scan
  rxscan1423_loop:
    (rx1419_pos) = rx1419_cur."from"()
    inc rx1419_pos
    rx1419_cur."!cursor_from"(rx1419_pos)
    ge rx1419_pos, rx1419_eos, rxscan1423_done
  rxscan1423_scan:
    set_addr $I10, rxscan1423_loop
    rx1419_cur."!mark_push"(0, rx1419_pos, $I10)
  rxscan1423_done:
.annotate 'line', 613
  # rx subcapture "sym"
    set_addr $I10, rxcap_1424_fail
    rx1419_cur."!mark_push"(0, rx1419_pos, $I10)
  # rx literal  ">="
    add $I11, rx1419_pos, 2
    gt $I11, rx1419_eos, rx1419_fail
    sub $I11, rx1419_pos, rx1419_off
    substr $S10, rx1419_tgt, $I11, 2
    ne $S10, ">=", rx1419_fail
    add rx1419_pos, 2
    set_addr $I10, rxcap_1424_fail
    ($I12, $I11) = rx1419_cur."!mark_peek"($I10)
    rx1419_cur."!cursor_pos"($I11)
    ($P10) = rx1419_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1419_pos, "")
    rx1419_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1424_done
  rxcap_1424_fail:
    goto rx1419_fail
  rxcap_1424_done:
  # rx subrule "O" subtype=capture negate=
    rx1419_cur."!cursor_pos"(rx1419_pos)
    $P10 = rx1419_cur."O"("%relational, :pirop<isge INn>")
    unless $P10, rx1419_fail
    rx1419_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1419_pos = $P10."pos"()
  # rx pass
    rx1419_cur."!cursor_pass"(rx1419_pos, "infix:sym<>=>")
    if_null rx1419_debug, debug_1020
    rx1419_cur."!cursor_debug"("PASS", "infix:sym<>=>", " at pos=", rx1419_pos)
  debug_1020:
    .return (rx1419_cur)
  rx1419_restart:
.annotate 'line', 4
    if_null rx1419_debug, debug_1021
    rx1419_cur."!cursor_debug"("NEXT", "infix:sym<>=>")
  debug_1021:
  rx1419_fail:
    (rx1419_rep, rx1419_pos, $I10, $P10) = rx1419_cur."!mark_fail"(0)
    lt rx1419_pos, -1, rx1419_done
    eq rx1419_pos, -1, rx1419_fail
    jump $I10
  rx1419_done:
    rx1419_cur."!cursor_fail"()
    if_null rx1419_debug, debug_1022
    rx1419_cur."!cursor_debug"("FAIL", "infix:sym<>=>")
  debug_1022:
    .return (rx1419_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>=>"  :nsentry("!PREFIX__infix:sym<>=>") :subid("327_1298325448.42642") :method
.annotate 'line', 4
    $P1421 = self."!PREFIX__!subrule"("O", ">=")
    new $P1422, "ResizablePMCArray"
    push $P1422, $P1421
    .return ($P1422)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<<>"  :subid("328_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1426_tgt
    .local int rx1426_pos
    .local int rx1426_off
    .local int rx1426_eos
    .local int rx1426_rep
    .local pmc rx1426_cur
    .local pmc rx1426_debug
    (rx1426_cur, rx1426_pos, rx1426_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1426_cur
    .local pmc match
    .lex "$/", match
    length rx1426_eos, rx1426_tgt
    gt rx1426_pos, rx1426_eos, rx1426_done
    set rx1426_off, 0
    lt rx1426_pos, 2, rx1426_start
    sub rx1426_off, rx1426_pos, 1
    substr rx1426_tgt, rx1426_tgt, rx1426_off
  rx1426_start:
    eq $I10, 1, rx1426_restart
    if_null rx1426_debug, debug_1023
    rx1426_cur."!cursor_debug"("START", "infix:sym<<>")
  debug_1023:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1430_done
    goto rxscan1430_scan
  rxscan1430_loop:
    (rx1426_pos) = rx1426_cur."from"()
    inc rx1426_pos
    rx1426_cur."!cursor_from"(rx1426_pos)
    ge rx1426_pos, rx1426_eos, rxscan1430_done
  rxscan1430_scan:
    set_addr $I10, rxscan1430_loop
    rx1426_cur."!mark_push"(0, rx1426_pos, $I10)
  rxscan1430_done:
.annotate 'line', 614
  # rx subcapture "sym"
    set_addr $I10, rxcap_1431_fail
    rx1426_cur."!mark_push"(0, rx1426_pos, $I10)
  # rx literal  "<"
    add $I11, rx1426_pos, 1
    gt $I11, rx1426_eos, rx1426_fail
    sub $I11, rx1426_pos, rx1426_off
    ord $I11, rx1426_tgt, $I11
    ne $I11, 60, rx1426_fail
    add rx1426_pos, 1
    set_addr $I10, rxcap_1431_fail
    ($I12, $I11) = rx1426_cur."!mark_peek"($I10)
    rx1426_cur."!cursor_pos"($I11)
    ($P10) = rx1426_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1426_pos, "")
    rx1426_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1431_done
  rxcap_1431_fail:
    goto rx1426_fail
  rxcap_1431_done:
  # rx subrule "O" subtype=capture negate=
    rx1426_cur."!cursor_pos"(rx1426_pos)
    $P10 = rx1426_cur."O"("%relational, :pirop<islt INn>")
    unless $P10, rx1426_fail
    rx1426_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1426_pos = $P10."pos"()
  # rx pass
    rx1426_cur."!cursor_pass"(rx1426_pos, "infix:sym<<>")
    if_null rx1426_debug, debug_1024
    rx1426_cur."!cursor_debug"("PASS", "infix:sym<<>", " at pos=", rx1426_pos)
  debug_1024:
    .return (rx1426_cur)
  rx1426_restart:
.annotate 'line', 4
    if_null rx1426_debug, debug_1025
    rx1426_cur."!cursor_debug"("NEXT", "infix:sym<<>")
  debug_1025:
  rx1426_fail:
    (rx1426_rep, rx1426_pos, $I10, $P10) = rx1426_cur."!mark_fail"(0)
    lt rx1426_pos, -1, rx1426_done
    eq rx1426_pos, -1, rx1426_fail
    jump $I10
  rx1426_done:
    rx1426_cur."!cursor_fail"()
    if_null rx1426_debug, debug_1026
    rx1426_cur."!cursor_debug"("FAIL", "infix:sym<<>")
  debug_1026:
    .return (rx1426_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<>"  :nsentry("!PREFIX__infix:sym<<>") :subid("329_1298325448.42642") :method
.annotate 'line', 4
    $P1428 = self."!PREFIX__!subrule"("O", "<")
    new $P1429, "ResizablePMCArray"
    push $P1429, $P1428
    .return ($P1429)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<>>"  :subid("330_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1433_tgt
    .local int rx1433_pos
    .local int rx1433_off
    .local int rx1433_eos
    .local int rx1433_rep
    .local pmc rx1433_cur
    .local pmc rx1433_debug
    (rx1433_cur, rx1433_pos, rx1433_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1433_cur
    .local pmc match
    .lex "$/", match
    length rx1433_eos, rx1433_tgt
    gt rx1433_pos, rx1433_eos, rx1433_done
    set rx1433_off, 0
    lt rx1433_pos, 2, rx1433_start
    sub rx1433_off, rx1433_pos, 1
    substr rx1433_tgt, rx1433_tgt, rx1433_off
  rx1433_start:
    eq $I10, 1, rx1433_restart
    if_null rx1433_debug, debug_1027
    rx1433_cur."!cursor_debug"("START", "infix:sym<>>")
  debug_1027:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1437_done
    goto rxscan1437_scan
  rxscan1437_loop:
    (rx1433_pos) = rx1433_cur."from"()
    inc rx1433_pos
    rx1433_cur."!cursor_from"(rx1433_pos)
    ge rx1433_pos, rx1433_eos, rxscan1437_done
  rxscan1437_scan:
    set_addr $I10, rxscan1437_loop
    rx1433_cur."!mark_push"(0, rx1433_pos, $I10)
  rxscan1437_done:
.annotate 'line', 615
  # rx subcapture "sym"
    set_addr $I10, rxcap_1438_fail
    rx1433_cur."!mark_push"(0, rx1433_pos, $I10)
  # rx literal  ">"
    add $I11, rx1433_pos, 1
    gt $I11, rx1433_eos, rx1433_fail
    sub $I11, rx1433_pos, rx1433_off
    ord $I11, rx1433_tgt, $I11
    ne $I11, 62, rx1433_fail
    add rx1433_pos, 1
    set_addr $I10, rxcap_1438_fail
    ($I12, $I11) = rx1433_cur."!mark_peek"($I10)
    rx1433_cur."!cursor_pos"($I11)
    ($P10) = rx1433_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1433_pos, "")
    rx1433_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1438_done
  rxcap_1438_fail:
    goto rx1433_fail
  rxcap_1438_done:
  # rx subrule "O" subtype=capture negate=
    rx1433_cur."!cursor_pos"(rx1433_pos)
    $P10 = rx1433_cur."O"("%relational, :pirop<isgt INn>")
    unless $P10, rx1433_fail
    rx1433_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1433_pos = $P10."pos"()
  # rx pass
    rx1433_cur."!cursor_pass"(rx1433_pos, "infix:sym<>>")
    if_null rx1433_debug, debug_1028
    rx1433_cur."!cursor_debug"("PASS", "infix:sym<>>", " at pos=", rx1433_pos)
  debug_1028:
    .return (rx1433_cur)
  rx1433_restart:
.annotate 'line', 4
    if_null rx1433_debug, debug_1029
    rx1433_cur."!cursor_debug"("NEXT", "infix:sym<>>")
  debug_1029:
  rx1433_fail:
    (rx1433_rep, rx1433_pos, $I10, $P10) = rx1433_cur."!mark_fail"(0)
    lt rx1433_pos, -1, rx1433_done
    eq rx1433_pos, -1, rx1433_fail
    jump $I10
  rx1433_done:
    rx1433_cur."!cursor_fail"()
    if_null rx1433_debug, debug_1030
    rx1433_cur."!cursor_debug"("FAIL", "infix:sym<>>")
  debug_1030:
    .return (rx1433_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>>"  :nsentry("!PREFIX__infix:sym<>>") :subid("331_1298325448.42642") :method
.annotate 'line', 4
    $P1435 = self."!PREFIX__!subrule"("O", ">")
    new $P1436, "ResizablePMCArray"
    push $P1436, $P1435
    .return ($P1436)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<eq>"  :subid("332_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1440_tgt
    .local int rx1440_pos
    .local int rx1440_off
    .local int rx1440_eos
    .local int rx1440_rep
    .local pmc rx1440_cur
    .local pmc rx1440_debug
    (rx1440_cur, rx1440_pos, rx1440_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1440_cur
    .local pmc match
    .lex "$/", match
    length rx1440_eos, rx1440_tgt
    gt rx1440_pos, rx1440_eos, rx1440_done
    set rx1440_off, 0
    lt rx1440_pos, 2, rx1440_start
    sub rx1440_off, rx1440_pos, 1
    substr rx1440_tgt, rx1440_tgt, rx1440_off
  rx1440_start:
    eq $I10, 1, rx1440_restart
    if_null rx1440_debug, debug_1031
    rx1440_cur."!cursor_debug"("START", "infix:sym<eq>")
  debug_1031:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1444_done
    goto rxscan1444_scan
  rxscan1444_loop:
    (rx1440_pos) = rx1440_cur."from"()
    inc rx1440_pos
    rx1440_cur."!cursor_from"(rx1440_pos)
    ge rx1440_pos, rx1440_eos, rxscan1444_done
  rxscan1444_scan:
    set_addr $I10, rxscan1444_loop
    rx1440_cur."!mark_push"(0, rx1440_pos, $I10)
  rxscan1444_done:
.annotate 'line', 616
  # rx subcapture "sym"
    set_addr $I10, rxcap_1445_fail
    rx1440_cur."!mark_push"(0, rx1440_pos, $I10)
  # rx literal  "eq"
    add $I11, rx1440_pos, 2
    gt $I11, rx1440_eos, rx1440_fail
    sub $I11, rx1440_pos, rx1440_off
    substr $S10, rx1440_tgt, $I11, 2
    ne $S10, "eq", rx1440_fail
    add rx1440_pos, 2
    set_addr $I10, rxcap_1445_fail
    ($I12, $I11) = rx1440_cur."!mark_peek"($I10)
    rx1440_cur."!cursor_pos"($I11)
    ($P10) = rx1440_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1440_pos, "")
    rx1440_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1445_done
  rxcap_1445_fail:
    goto rx1440_fail
  rxcap_1445_done:
  # rx subrule "O" subtype=capture negate=
    rx1440_cur."!cursor_pos"(rx1440_pos)
    $P10 = rx1440_cur."O"("%relational, :pirop<iseq ISs>")
    unless $P10, rx1440_fail
    rx1440_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1440_pos = $P10."pos"()
  # rx pass
    rx1440_cur."!cursor_pass"(rx1440_pos, "infix:sym<eq>")
    if_null rx1440_debug, debug_1032
    rx1440_cur."!cursor_debug"("PASS", "infix:sym<eq>", " at pos=", rx1440_pos)
  debug_1032:
    .return (rx1440_cur)
  rx1440_restart:
.annotate 'line', 4
    if_null rx1440_debug, debug_1033
    rx1440_cur."!cursor_debug"("NEXT", "infix:sym<eq>")
  debug_1033:
  rx1440_fail:
    (rx1440_rep, rx1440_pos, $I10, $P10) = rx1440_cur."!mark_fail"(0)
    lt rx1440_pos, -1, rx1440_done
    eq rx1440_pos, -1, rx1440_fail
    jump $I10
  rx1440_done:
    rx1440_cur."!cursor_fail"()
    if_null rx1440_debug, debug_1034
    rx1440_cur."!cursor_debug"("FAIL", "infix:sym<eq>")
  debug_1034:
    .return (rx1440_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<eq>"  :nsentry("!PREFIX__infix:sym<eq>") :subid("333_1298325448.42642") :method
.annotate 'line', 4
    $P1442 = self."!PREFIX__!subrule"("O", "eq")
    new $P1443, "ResizablePMCArray"
    push $P1443, $P1442
    .return ($P1443)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<ne>"  :subid("334_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1447_tgt
    .local int rx1447_pos
    .local int rx1447_off
    .local int rx1447_eos
    .local int rx1447_rep
    .local pmc rx1447_cur
    .local pmc rx1447_debug
    (rx1447_cur, rx1447_pos, rx1447_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1447_cur
    .local pmc match
    .lex "$/", match
    length rx1447_eos, rx1447_tgt
    gt rx1447_pos, rx1447_eos, rx1447_done
    set rx1447_off, 0
    lt rx1447_pos, 2, rx1447_start
    sub rx1447_off, rx1447_pos, 1
    substr rx1447_tgt, rx1447_tgt, rx1447_off
  rx1447_start:
    eq $I10, 1, rx1447_restart
    if_null rx1447_debug, debug_1035
    rx1447_cur."!cursor_debug"("START", "infix:sym<ne>")
  debug_1035:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1451_done
    goto rxscan1451_scan
  rxscan1451_loop:
    (rx1447_pos) = rx1447_cur."from"()
    inc rx1447_pos
    rx1447_cur."!cursor_from"(rx1447_pos)
    ge rx1447_pos, rx1447_eos, rxscan1451_done
  rxscan1451_scan:
    set_addr $I10, rxscan1451_loop
    rx1447_cur."!mark_push"(0, rx1447_pos, $I10)
  rxscan1451_done:
.annotate 'line', 617
  # rx subcapture "sym"
    set_addr $I10, rxcap_1452_fail
    rx1447_cur."!mark_push"(0, rx1447_pos, $I10)
  # rx literal  "ne"
    add $I11, rx1447_pos, 2
    gt $I11, rx1447_eos, rx1447_fail
    sub $I11, rx1447_pos, rx1447_off
    substr $S10, rx1447_tgt, $I11, 2
    ne $S10, "ne", rx1447_fail
    add rx1447_pos, 2
    set_addr $I10, rxcap_1452_fail
    ($I12, $I11) = rx1447_cur."!mark_peek"($I10)
    rx1447_cur."!cursor_pos"($I11)
    ($P10) = rx1447_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1447_pos, "")
    rx1447_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1452_done
  rxcap_1452_fail:
    goto rx1447_fail
  rxcap_1452_done:
  # rx subrule "O" subtype=capture negate=
    rx1447_cur."!cursor_pos"(rx1447_pos)
    $P10 = rx1447_cur."O"("%relational, :pirop<isne ISs>")
    unless $P10, rx1447_fail
    rx1447_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1447_pos = $P10."pos"()
  # rx pass
    rx1447_cur."!cursor_pass"(rx1447_pos, "infix:sym<ne>")
    if_null rx1447_debug, debug_1036
    rx1447_cur."!cursor_debug"("PASS", "infix:sym<ne>", " at pos=", rx1447_pos)
  debug_1036:
    .return (rx1447_cur)
  rx1447_restart:
.annotate 'line', 4
    if_null rx1447_debug, debug_1037
    rx1447_cur."!cursor_debug"("NEXT", "infix:sym<ne>")
  debug_1037:
  rx1447_fail:
    (rx1447_rep, rx1447_pos, $I10, $P10) = rx1447_cur."!mark_fail"(0)
    lt rx1447_pos, -1, rx1447_done
    eq rx1447_pos, -1, rx1447_fail
    jump $I10
  rx1447_done:
    rx1447_cur."!cursor_fail"()
    if_null rx1447_debug, debug_1038
    rx1447_cur."!cursor_debug"("FAIL", "infix:sym<ne>")
  debug_1038:
    .return (rx1447_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ne>"  :nsentry("!PREFIX__infix:sym<ne>") :subid("335_1298325448.42642") :method
.annotate 'line', 4
    $P1449 = self."!PREFIX__!subrule"("O", "ne")
    new $P1450, "ResizablePMCArray"
    push $P1450, $P1449
    .return ($P1450)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<le>"  :subid("336_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1454_tgt
    .local int rx1454_pos
    .local int rx1454_off
    .local int rx1454_eos
    .local int rx1454_rep
    .local pmc rx1454_cur
    .local pmc rx1454_debug
    (rx1454_cur, rx1454_pos, rx1454_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1454_cur
    .local pmc match
    .lex "$/", match
    length rx1454_eos, rx1454_tgt
    gt rx1454_pos, rx1454_eos, rx1454_done
    set rx1454_off, 0
    lt rx1454_pos, 2, rx1454_start
    sub rx1454_off, rx1454_pos, 1
    substr rx1454_tgt, rx1454_tgt, rx1454_off
  rx1454_start:
    eq $I10, 1, rx1454_restart
    if_null rx1454_debug, debug_1039
    rx1454_cur."!cursor_debug"("START", "infix:sym<le>")
  debug_1039:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1458_done
    goto rxscan1458_scan
  rxscan1458_loop:
    (rx1454_pos) = rx1454_cur."from"()
    inc rx1454_pos
    rx1454_cur."!cursor_from"(rx1454_pos)
    ge rx1454_pos, rx1454_eos, rxscan1458_done
  rxscan1458_scan:
    set_addr $I10, rxscan1458_loop
    rx1454_cur."!mark_push"(0, rx1454_pos, $I10)
  rxscan1458_done:
.annotate 'line', 618
  # rx subcapture "sym"
    set_addr $I10, rxcap_1459_fail
    rx1454_cur."!mark_push"(0, rx1454_pos, $I10)
  # rx literal  "le"
    add $I11, rx1454_pos, 2
    gt $I11, rx1454_eos, rx1454_fail
    sub $I11, rx1454_pos, rx1454_off
    substr $S10, rx1454_tgt, $I11, 2
    ne $S10, "le", rx1454_fail
    add rx1454_pos, 2
    set_addr $I10, rxcap_1459_fail
    ($I12, $I11) = rx1454_cur."!mark_peek"($I10)
    rx1454_cur."!cursor_pos"($I11)
    ($P10) = rx1454_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1454_pos, "")
    rx1454_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1459_done
  rxcap_1459_fail:
    goto rx1454_fail
  rxcap_1459_done:
  # rx subrule "O" subtype=capture negate=
    rx1454_cur."!cursor_pos"(rx1454_pos)
    $P10 = rx1454_cur."O"("%relational, :pirop<isle ISs>")
    unless $P10, rx1454_fail
    rx1454_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1454_pos = $P10."pos"()
  # rx pass
    rx1454_cur."!cursor_pass"(rx1454_pos, "infix:sym<le>")
    if_null rx1454_debug, debug_1040
    rx1454_cur."!cursor_debug"("PASS", "infix:sym<le>", " at pos=", rx1454_pos)
  debug_1040:
    .return (rx1454_cur)
  rx1454_restart:
.annotate 'line', 4
    if_null rx1454_debug, debug_1041
    rx1454_cur."!cursor_debug"("NEXT", "infix:sym<le>")
  debug_1041:
  rx1454_fail:
    (rx1454_rep, rx1454_pos, $I10, $P10) = rx1454_cur."!mark_fail"(0)
    lt rx1454_pos, -1, rx1454_done
    eq rx1454_pos, -1, rx1454_fail
    jump $I10
  rx1454_done:
    rx1454_cur."!cursor_fail"()
    if_null rx1454_debug, debug_1042
    rx1454_cur."!cursor_debug"("FAIL", "infix:sym<le>")
  debug_1042:
    .return (rx1454_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<le>"  :nsentry("!PREFIX__infix:sym<le>") :subid("337_1298325448.42642") :method
.annotate 'line', 4
    $P1456 = self."!PREFIX__!subrule"("O", "le")
    new $P1457, "ResizablePMCArray"
    push $P1457, $P1456
    .return ($P1457)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<ge>"  :subid("338_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1461_tgt
    .local int rx1461_pos
    .local int rx1461_off
    .local int rx1461_eos
    .local int rx1461_rep
    .local pmc rx1461_cur
    .local pmc rx1461_debug
    (rx1461_cur, rx1461_pos, rx1461_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1461_cur
    .local pmc match
    .lex "$/", match
    length rx1461_eos, rx1461_tgt
    gt rx1461_pos, rx1461_eos, rx1461_done
    set rx1461_off, 0
    lt rx1461_pos, 2, rx1461_start
    sub rx1461_off, rx1461_pos, 1
    substr rx1461_tgt, rx1461_tgt, rx1461_off
  rx1461_start:
    eq $I10, 1, rx1461_restart
    if_null rx1461_debug, debug_1043
    rx1461_cur."!cursor_debug"("START", "infix:sym<ge>")
  debug_1043:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1465_done
    goto rxscan1465_scan
  rxscan1465_loop:
    (rx1461_pos) = rx1461_cur."from"()
    inc rx1461_pos
    rx1461_cur."!cursor_from"(rx1461_pos)
    ge rx1461_pos, rx1461_eos, rxscan1465_done
  rxscan1465_scan:
    set_addr $I10, rxscan1465_loop
    rx1461_cur."!mark_push"(0, rx1461_pos, $I10)
  rxscan1465_done:
.annotate 'line', 619
  # rx subcapture "sym"
    set_addr $I10, rxcap_1466_fail
    rx1461_cur."!mark_push"(0, rx1461_pos, $I10)
  # rx literal  "ge"
    add $I11, rx1461_pos, 2
    gt $I11, rx1461_eos, rx1461_fail
    sub $I11, rx1461_pos, rx1461_off
    substr $S10, rx1461_tgt, $I11, 2
    ne $S10, "ge", rx1461_fail
    add rx1461_pos, 2
    set_addr $I10, rxcap_1466_fail
    ($I12, $I11) = rx1461_cur."!mark_peek"($I10)
    rx1461_cur."!cursor_pos"($I11)
    ($P10) = rx1461_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1461_pos, "")
    rx1461_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1466_done
  rxcap_1466_fail:
    goto rx1461_fail
  rxcap_1466_done:
  # rx subrule "O" subtype=capture negate=
    rx1461_cur."!cursor_pos"(rx1461_pos)
    $P10 = rx1461_cur."O"("%relational, :pirop<isge ISs>")
    unless $P10, rx1461_fail
    rx1461_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1461_pos = $P10."pos"()
  # rx pass
    rx1461_cur."!cursor_pass"(rx1461_pos, "infix:sym<ge>")
    if_null rx1461_debug, debug_1044
    rx1461_cur."!cursor_debug"("PASS", "infix:sym<ge>", " at pos=", rx1461_pos)
  debug_1044:
    .return (rx1461_cur)
  rx1461_restart:
.annotate 'line', 4
    if_null rx1461_debug, debug_1045
    rx1461_cur."!cursor_debug"("NEXT", "infix:sym<ge>")
  debug_1045:
  rx1461_fail:
    (rx1461_rep, rx1461_pos, $I10, $P10) = rx1461_cur."!mark_fail"(0)
    lt rx1461_pos, -1, rx1461_done
    eq rx1461_pos, -1, rx1461_fail
    jump $I10
  rx1461_done:
    rx1461_cur."!cursor_fail"()
    if_null rx1461_debug, debug_1046
    rx1461_cur."!cursor_debug"("FAIL", "infix:sym<ge>")
  debug_1046:
    .return (rx1461_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ge>"  :nsentry("!PREFIX__infix:sym<ge>") :subid("339_1298325448.42642") :method
.annotate 'line', 4
    $P1463 = self."!PREFIX__!subrule"("O", "ge")
    new $P1464, "ResizablePMCArray"
    push $P1464, $P1463
    .return ($P1464)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<lt>"  :subid("340_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1468_tgt
    .local int rx1468_pos
    .local int rx1468_off
    .local int rx1468_eos
    .local int rx1468_rep
    .local pmc rx1468_cur
    .local pmc rx1468_debug
    (rx1468_cur, rx1468_pos, rx1468_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1468_cur
    .local pmc match
    .lex "$/", match
    length rx1468_eos, rx1468_tgt
    gt rx1468_pos, rx1468_eos, rx1468_done
    set rx1468_off, 0
    lt rx1468_pos, 2, rx1468_start
    sub rx1468_off, rx1468_pos, 1
    substr rx1468_tgt, rx1468_tgt, rx1468_off
  rx1468_start:
    eq $I10, 1, rx1468_restart
    if_null rx1468_debug, debug_1047
    rx1468_cur."!cursor_debug"("START", "infix:sym<lt>")
  debug_1047:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1472_done
    goto rxscan1472_scan
  rxscan1472_loop:
    (rx1468_pos) = rx1468_cur."from"()
    inc rx1468_pos
    rx1468_cur."!cursor_from"(rx1468_pos)
    ge rx1468_pos, rx1468_eos, rxscan1472_done
  rxscan1472_scan:
    set_addr $I10, rxscan1472_loop
    rx1468_cur."!mark_push"(0, rx1468_pos, $I10)
  rxscan1472_done:
.annotate 'line', 620
  # rx subcapture "sym"
    set_addr $I10, rxcap_1473_fail
    rx1468_cur."!mark_push"(0, rx1468_pos, $I10)
  # rx literal  "lt"
    add $I11, rx1468_pos, 2
    gt $I11, rx1468_eos, rx1468_fail
    sub $I11, rx1468_pos, rx1468_off
    substr $S10, rx1468_tgt, $I11, 2
    ne $S10, "lt", rx1468_fail
    add rx1468_pos, 2
    set_addr $I10, rxcap_1473_fail
    ($I12, $I11) = rx1468_cur."!mark_peek"($I10)
    rx1468_cur."!cursor_pos"($I11)
    ($P10) = rx1468_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1468_pos, "")
    rx1468_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1473_done
  rxcap_1473_fail:
    goto rx1468_fail
  rxcap_1473_done:
  # rx subrule "O" subtype=capture negate=
    rx1468_cur."!cursor_pos"(rx1468_pos)
    $P10 = rx1468_cur."O"("%relational, :pirop<islt ISs>")
    unless $P10, rx1468_fail
    rx1468_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1468_pos = $P10."pos"()
  # rx pass
    rx1468_cur."!cursor_pass"(rx1468_pos, "infix:sym<lt>")
    if_null rx1468_debug, debug_1048
    rx1468_cur."!cursor_debug"("PASS", "infix:sym<lt>", " at pos=", rx1468_pos)
  debug_1048:
    .return (rx1468_cur)
  rx1468_restart:
.annotate 'line', 4
    if_null rx1468_debug, debug_1049
    rx1468_cur."!cursor_debug"("NEXT", "infix:sym<lt>")
  debug_1049:
  rx1468_fail:
    (rx1468_rep, rx1468_pos, $I10, $P10) = rx1468_cur."!mark_fail"(0)
    lt rx1468_pos, -1, rx1468_done
    eq rx1468_pos, -1, rx1468_fail
    jump $I10
  rx1468_done:
    rx1468_cur."!cursor_fail"()
    if_null rx1468_debug, debug_1050
    rx1468_cur."!cursor_debug"("FAIL", "infix:sym<lt>")
  debug_1050:
    .return (rx1468_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<lt>"  :nsentry("!PREFIX__infix:sym<lt>") :subid("341_1298325448.42642") :method
.annotate 'line', 4
    $P1470 = self."!PREFIX__!subrule"("O", "lt")
    new $P1471, "ResizablePMCArray"
    push $P1471, $P1470
    .return ($P1471)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<gt>"  :subid("342_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1475_tgt
    .local int rx1475_pos
    .local int rx1475_off
    .local int rx1475_eos
    .local int rx1475_rep
    .local pmc rx1475_cur
    .local pmc rx1475_debug
    (rx1475_cur, rx1475_pos, rx1475_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1475_cur
    .local pmc match
    .lex "$/", match
    length rx1475_eos, rx1475_tgt
    gt rx1475_pos, rx1475_eos, rx1475_done
    set rx1475_off, 0
    lt rx1475_pos, 2, rx1475_start
    sub rx1475_off, rx1475_pos, 1
    substr rx1475_tgt, rx1475_tgt, rx1475_off
  rx1475_start:
    eq $I10, 1, rx1475_restart
    if_null rx1475_debug, debug_1051
    rx1475_cur."!cursor_debug"("START", "infix:sym<gt>")
  debug_1051:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1479_done
    goto rxscan1479_scan
  rxscan1479_loop:
    (rx1475_pos) = rx1475_cur."from"()
    inc rx1475_pos
    rx1475_cur."!cursor_from"(rx1475_pos)
    ge rx1475_pos, rx1475_eos, rxscan1479_done
  rxscan1479_scan:
    set_addr $I10, rxscan1479_loop
    rx1475_cur."!mark_push"(0, rx1475_pos, $I10)
  rxscan1479_done:
.annotate 'line', 621
  # rx subcapture "sym"
    set_addr $I10, rxcap_1480_fail
    rx1475_cur."!mark_push"(0, rx1475_pos, $I10)
  # rx literal  "gt"
    add $I11, rx1475_pos, 2
    gt $I11, rx1475_eos, rx1475_fail
    sub $I11, rx1475_pos, rx1475_off
    substr $S10, rx1475_tgt, $I11, 2
    ne $S10, "gt", rx1475_fail
    add rx1475_pos, 2
    set_addr $I10, rxcap_1480_fail
    ($I12, $I11) = rx1475_cur."!mark_peek"($I10)
    rx1475_cur."!cursor_pos"($I11)
    ($P10) = rx1475_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1475_pos, "")
    rx1475_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1480_done
  rxcap_1480_fail:
    goto rx1475_fail
  rxcap_1480_done:
  # rx subrule "O" subtype=capture negate=
    rx1475_cur."!cursor_pos"(rx1475_pos)
    $P10 = rx1475_cur."O"("%relational, :pirop<isgt ISs>")
    unless $P10, rx1475_fail
    rx1475_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1475_pos = $P10."pos"()
  # rx pass
    rx1475_cur."!cursor_pass"(rx1475_pos, "infix:sym<gt>")
    if_null rx1475_debug, debug_1052
    rx1475_cur."!cursor_debug"("PASS", "infix:sym<gt>", " at pos=", rx1475_pos)
  debug_1052:
    .return (rx1475_cur)
  rx1475_restart:
.annotate 'line', 4
    if_null rx1475_debug, debug_1053
    rx1475_cur."!cursor_debug"("NEXT", "infix:sym<gt>")
  debug_1053:
  rx1475_fail:
    (rx1475_rep, rx1475_pos, $I10, $P10) = rx1475_cur."!mark_fail"(0)
    lt rx1475_pos, -1, rx1475_done
    eq rx1475_pos, -1, rx1475_fail
    jump $I10
  rx1475_done:
    rx1475_cur."!cursor_fail"()
    if_null rx1475_debug, debug_1054
    rx1475_cur."!cursor_debug"("FAIL", "infix:sym<gt>")
  debug_1054:
    .return (rx1475_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<gt>"  :nsentry("!PREFIX__infix:sym<gt>") :subid("343_1298325448.42642") :method
.annotate 'line', 4
    $P1477 = self."!PREFIX__!subrule"("O", "gt")
    new $P1478, "ResizablePMCArray"
    push $P1478, $P1477
    .return ($P1478)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<=:=>"  :subid("344_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1482_tgt
    .local int rx1482_pos
    .local int rx1482_off
    .local int rx1482_eos
    .local int rx1482_rep
    .local pmc rx1482_cur
    .local pmc rx1482_debug
    (rx1482_cur, rx1482_pos, rx1482_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1482_cur
    .local pmc match
    .lex "$/", match
    length rx1482_eos, rx1482_tgt
    gt rx1482_pos, rx1482_eos, rx1482_done
    set rx1482_off, 0
    lt rx1482_pos, 2, rx1482_start
    sub rx1482_off, rx1482_pos, 1
    substr rx1482_tgt, rx1482_tgt, rx1482_off
  rx1482_start:
    eq $I10, 1, rx1482_restart
    if_null rx1482_debug, debug_1055
    rx1482_cur."!cursor_debug"("START", "infix:sym<=:=>")
  debug_1055:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1486_done
    goto rxscan1486_scan
  rxscan1486_loop:
    (rx1482_pos) = rx1482_cur."from"()
    inc rx1482_pos
    rx1482_cur."!cursor_from"(rx1482_pos)
    ge rx1482_pos, rx1482_eos, rxscan1486_done
  rxscan1486_scan:
    set_addr $I10, rxscan1486_loop
    rx1482_cur."!mark_push"(0, rx1482_pos, $I10)
  rxscan1486_done:
.annotate 'line', 622
  # rx subcapture "sym"
    set_addr $I10, rxcap_1487_fail
    rx1482_cur."!mark_push"(0, rx1482_pos, $I10)
  # rx literal  "=:="
    add $I11, rx1482_pos, 3
    gt $I11, rx1482_eos, rx1482_fail
    sub $I11, rx1482_pos, rx1482_off
    substr $S10, rx1482_tgt, $I11, 3
    ne $S10, "=:=", rx1482_fail
    add rx1482_pos, 3
    set_addr $I10, rxcap_1487_fail
    ($I12, $I11) = rx1482_cur."!mark_peek"($I10)
    rx1482_cur."!cursor_pos"($I11)
    ($P10) = rx1482_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1482_pos, "")
    rx1482_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1487_done
  rxcap_1487_fail:
    goto rx1482_fail
  rxcap_1487_done:
  # rx subrule "O" subtype=capture negate=
    rx1482_cur."!cursor_pos"(rx1482_pos)
    $P10 = rx1482_cur."O"("%relational, :pirop<issame>")
    unless $P10, rx1482_fail
    rx1482_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1482_pos = $P10."pos"()
  # rx pass
    rx1482_cur."!cursor_pass"(rx1482_pos, "infix:sym<=:=>")
    if_null rx1482_debug, debug_1056
    rx1482_cur."!cursor_debug"("PASS", "infix:sym<=:=>", " at pos=", rx1482_pos)
  debug_1056:
    .return (rx1482_cur)
  rx1482_restart:
.annotate 'line', 4
    if_null rx1482_debug, debug_1057
    rx1482_cur."!cursor_debug"("NEXT", "infix:sym<=:=>")
  debug_1057:
  rx1482_fail:
    (rx1482_rep, rx1482_pos, $I10, $P10) = rx1482_cur."!mark_fail"(0)
    lt rx1482_pos, -1, rx1482_done
    eq rx1482_pos, -1, rx1482_fail
    jump $I10
  rx1482_done:
    rx1482_cur."!cursor_fail"()
    if_null rx1482_debug, debug_1058
    rx1482_cur."!cursor_debug"("FAIL", "infix:sym<=:=>")
  debug_1058:
    .return (rx1482_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=:=>"  :nsentry("!PREFIX__infix:sym<=:=>") :subid("345_1298325448.42642") :method
.annotate 'line', 4
    $P1484 = self."!PREFIX__!subrule"("O", "=:=")
    new $P1485, "ResizablePMCArray"
    push $P1485, $P1484
    .return ($P1485)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<~~>"  :subid("346_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1489_tgt
    .local int rx1489_pos
    .local int rx1489_off
    .local int rx1489_eos
    .local int rx1489_rep
    .local pmc rx1489_cur
    .local pmc rx1489_debug
    (rx1489_cur, rx1489_pos, rx1489_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1489_cur
    .local pmc match
    .lex "$/", match
    length rx1489_eos, rx1489_tgt
    gt rx1489_pos, rx1489_eos, rx1489_done
    set rx1489_off, 0
    lt rx1489_pos, 2, rx1489_start
    sub rx1489_off, rx1489_pos, 1
    substr rx1489_tgt, rx1489_tgt, rx1489_off
  rx1489_start:
    eq $I10, 1, rx1489_restart
    if_null rx1489_debug, debug_1059
    rx1489_cur."!cursor_debug"("START", "infix:sym<~~>")
  debug_1059:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1493_done
    goto rxscan1493_scan
  rxscan1493_loop:
    (rx1489_pos) = rx1489_cur."from"()
    inc rx1489_pos
    rx1489_cur."!cursor_from"(rx1489_pos)
    ge rx1489_pos, rx1489_eos, rxscan1493_done
  rxscan1493_scan:
    set_addr $I10, rxscan1493_loop
    rx1489_cur."!mark_push"(0, rx1489_pos, $I10)
  rxscan1493_done:
.annotate 'line', 623
  # rx subcapture "sym"
    set_addr $I10, rxcap_1494_fail
    rx1489_cur."!mark_push"(0, rx1489_pos, $I10)
  # rx literal  "~~"
    add $I11, rx1489_pos, 2
    gt $I11, rx1489_eos, rx1489_fail
    sub $I11, rx1489_pos, rx1489_off
    substr $S10, rx1489_tgt, $I11, 2
    ne $S10, "~~", rx1489_fail
    add rx1489_pos, 2
    set_addr $I10, rxcap_1494_fail
    ($I12, $I11) = rx1489_cur."!mark_peek"($I10)
    rx1489_cur."!cursor_pos"($I11)
    ($P10) = rx1489_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1489_pos, "")
    rx1489_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1494_done
  rxcap_1494_fail:
    goto rx1489_fail
  rxcap_1494_done:
  # rx subrule "O" subtype=capture negate=
    rx1489_cur."!cursor_pos"(rx1489_pos)
    $P10 = rx1489_cur."O"("%relational, :reducecheck<smartmatch>")
    unless $P10, rx1489_fail
    rx1489_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1489_pos = $P10."pos"()
  # rx pass
    rx1489_cur."!cursor_pass"(rx1489_pos, "infix:sym<~~>")
    if_null rx1489_debug, debug_1060
    rx1489_cur."!cursor_debug"("PASS", "infix:sym<~~>", " at pos=", rx1489_pos)
  debug_1060:
    .return (rx1489_cur)
  rx1489_restart:
.annotate 'line', 4
    if_null rx1489_debug, debug_1061
    rx1489_cur."!cursor_debug"("NEXT", "infix:sym<~~>")
  debug_1061:
  rx1489_fail:
    (rx1489_rep, rx1489_pos, $I10, $P10) = rx1489_cur."!mark_fail"(0)
    lt rx1489_pos, -1, rx1489_done
    eq rx1489_pos, -1, rx1489_fail
    jump $I10
  rx1489_done:
    rx1489_cur."!cursor_fail"()
    if_null rx1489_debug, debug_1062
    rx1489_cur."!cursor_debug"("FAIL", "infix:sym<~~>")
  debug_1062:
    .return (rx1489_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~~>"  :nsentry("!PREFIX__infix:sym<~~>") :subid("347_1298325448.42642") :method
.annotate 'line', 4
    $P1491 = self."!PREFIX__!subrule"("O", "~~")
    new $P1492, "ResizablePMCArray"
    push $P1492, $P1491
    .return ($P1492)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<&&>"  :subid("348_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1496_tgt
    .local int rx1496_pos
    .local int rx1496_off
    .local int rx1496_eos
    .local int rx1496_rep
    .local pmc rx1496_cur
    .local pmc rx1496_debug
    (rx1496_cur, rx1496_pos, rx1496_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1496_cur
    .local pmc match
    .lex "$/", match
    length rx1496_eos, rx1496_tgt
    gt rx1496_pos, rx1496_eos, rx1496_done
    set rx1496_off, 0
    lt rx1496_pos, 2, rx1496_start
    sub rx1496_off, rx1496_pos, 1
    substr rx1496_tgt, rx1496_tgt, rx1496_off
  rx1496_start:
    eq $I10, 1, rx1496_restart
    if_null rx1496_debug, debug_1063
    rx1496_cur."!cursor_debug"("START", "infix:sym<&&>")
  debug_1063:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1500_done
    goto rxscan1500_scan
  rxscan1500_loop:
    (rx1496_pos) = rx1496_cur."from"()
    inc rx1496_pos
    rx1496_cur."!cursor_from"(rx1496_pos)
    ge rx1496_pos, rx1496_eos, rxscan1500_done
  rxscan1500_scan:
    set_addr $I10, rxscan1500_loop
    rx1496_cur."!mark_push"(0, rx1496_pos, $I10)
  rxscan1500_done:
.annotate 'line', 625
  # rx subcapture "sym"
    set_addr $I10, rxcap_1501_fail
    rx1496_cur."!mark_push"(0, rx1496_pos, $I10)
  # rx literal  "&&"
    add $I11, rx1496_pos, 2
    gt $I11, rx1496_eos, rx1496_fail
    sub $I11, rx1496_pos, rx1496_off
    substr $S10, rx1496_tgt, $I11, 2
    ne $S10, "&&", rx1496_fail
    add rx1496_pos, 2
    set_addr $I10, rxcap_1501_fail
    ($I12, $I11) = rx1496_cur."!mark_peek"($I10)
    rx1496_cur."!cursor_pos"($I11)
    ($P10) = rx1496_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1496_pos, "")
    rx1496_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1501_done
  rxcap_1501_fail:
    goto rx1496_fail
  rxcap_1501_done:
  # rx subrule "O" subtype=capture negate=
    rx1496_cur."!cursor_pos"(rx1496_pos)
    $P10 = rx1496_cur."O"("%tight_and, :pasttype<if>")
    unless $P10, rx1496_fail
    rx1496_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1496_pos = $P10."pos"()
  # rx pass
    rx1496_cur."!cursor_pass"(rx1496_pos, "infix:sym<&&>")
    if_null rx1496_debug, debug_1064
    rx1496_cur."!cursor_debug"("PASS", "infix:sym<&&>", " at pos=", rx1496_pos)
  debug_1064:
    .return (rx1496_cur)
  rx1496_restart:
.annotate 'line', 4
    if_null rx1496_debug, debug_1065
    rx1496_cur."!cursor_debug"("NEXT", "infix:sym<&&>")
  debug_1065:
  rx1496_fail:
    (rx1496_rep, rx1496_pos, $I10, $P10) = rx1496_cur."!mark_fail"(0)
    lt rx1496_pos, -1, rx1496_done
    eq rx1496_pos, -1, rx1496_fail
    jump $I10
  rx1496_done:
    rx1496_cur."!cursor_fail"()
    if_null rx1496_debug, debug_1066
    rx1496_cur."!cursor_debug"("FAIL", "infix:sym<&&>")
  debug_1066:
    .return (rx1496_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<&&>"  :nsentry("!PREFIX__infix:sym<&&>") :subid("349_1298325448.42642") :method
.annotate 'line', 4
    $P1498 = self."!PREFIX__!subrule"("O", "&&")
    new $P1499, "ResizablePMCArray"
    push $P1499, $P1498
    .return ($P1499)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<||>"  :subid("350_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1503_tgt
    .local int rx1503_pos
    .local int rx1503_off
    .local int rx1503_eos
    .local int rx1503_rep
    .local pmc rx1503_cur
    .local pmc rx1503_debug
    (rx1503_cur, rx1503_pos, rx1503_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1503_cur
    .local pmc match
    .lex "$/", match
    length rx1503_eos, rx1503_tgt
    gt rx1503_pos, rx1503_eos, rx1503_done
    set rx1503_off, 0
    lt rx1503_pos, 2, rx1503_start
    sub rx1503_off, rx1503_pos, 1
    substr rx1503_tgt, rx1503_tgt, rx1503_off
  rx1503_start:
    eq $I10, 1, rx1503_restart
    if_null rx1503_debug, debug_1067
    rx1503_cur."!cursor_debug"("START", "infix:sym<||>")
  debug_1067:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1507_done
    goto rxscan1507_scan
  rxscan1507_loop:
    (rx1503_pos) = rx1503_cur."from"()
    inc rx1503_pos
    rx1503_cur."!cursor_from"(rx1503_pos)
    ge rx1503_pos, rx1503_eos, rxscan1507_done
  rxscan1507_scan:
    set_addr $I10, rxscan1507_loop
    rx1503_cur."!mark_push"(0, rx1503_pos, $I10)
  rxscan1507_done:
.annotate 'line', 627
  # rx subcapture "sym"
    set_addr $I10, rxcap_1508_fail
    rx1503_cur."!mark_push"(0, rx1503_pos, $I10)
  # rx literal  "||"
    add $I11, rx1503_pos, 2
    gt $I11, rx1503_eos, rx1503_fail
    sub $I11, rx1503_pos, rx1503_off
    substr $S10, rx1503_tgt, $I11, 2
    ne $S10, "||", rx1503_fail
    add rx1503_pos, 2
    set_addr $I10, rxcap_1508_fail
    ($I12, $I11) = rx1503_cur."!mark_peek"($I10)
    rx1503_cur."!cursor_pos"($I11)
    ($P10) = rx1503_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1503_pos, "")
    rx1503_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1508_done
  rxcap_1508_fail:
    goto rx1503_fail
  rxcap_1508_done:
  # rx subrule "O" subtype=capture negate=
    rx1503_cur."!cursor_pos"(rx1503_pos)
    $P10 = rx1503_cur."O"("%tight_or, :pasttype<unless>")
    unless $P10, rx1503_fail
    rx1503_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1503_pos = $P10."pos"()
  # rx pass
    rx1503_cur."!cursor_pass"(rx1503_pos, "infix:sym<||>")
    if_null rx1503_debug, debug_1068
    rx1503_cur."!cursor_debug"("PASS", "infix:sym<||>", " at pos=", rx1503_pos)
  debug_1068:
    .return (rx1503_cur)
  rx1503_restart:
.annotate 'line', 4
    if_null rx1503_debug, debug_1069
    rx1503_cur."!cursor_debug"("NEXT", "infix:sym<||>")
  debug_1069:
  rx1503_fail:
    (rx1503_rep, rx1503_pos, $I10, $P10) = rx1503_cur."!mark_fail"(0)
    lt rx1503_pos, -1, rx1503_done
    eq rx1503_pos, -1, rx1503_fail
    jump $I10
  rx1503_done:
    rx1503_cur."!cursor_fail"()
    if_null rx1503_debug, debug_1070
    rx1503_cur."!cursor_debug"("FAIL", "infix:sym<||>")
  debug_1070:
    .return (rx1503_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<||>"  :nsentry("!PREFIX__infix:sym<||>") :subid("351_1298325448.42642") :method
.annotate 'line', 4
    $P1505 = self."!PREFIX__!subrule"("O", "||")
    new $P1506, "ResizablePMCArray"
    push $P1506, $P1505
    .return ($P1506)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<//>"  :subid("352_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1510_tgt
    .local int rx1510_pos
    .local int rx1510_off
    .local int rx1510_eos
    .local int rx1510_rep
    .local pmc rx1510_cur
    .local pmc rx1510_debug
    (rx1510_cur, rx1510_pos, rx1510_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1510_cur
    .local pmc match
    .lex "$/", match
    length rx1510_eos, rx1510_tgt
    gt rx1510_pos, rx1510_eos, rx1510_done
    set rx1510_off, 0
    lt rx1510_pos, 2, rx1510_start
    sub rx1510_off, rx1510_pos, 1
    substr rx1510_tgt, rx1510_tgt, rx1510_off
  rx1510_start:
    eq $I10, 1, rx1510_restart
    if_null rx1510_debug, debug_1071
    rx1510_cur."!cursor_debug"("START", "infix:sym<//>")
  debug_1071:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1514_done
    goto rxscan1514_scan
  rxscan1514_loop:
    (rx1510_pos) = rx1510_cur."from"()
    inc rx1510_pos
    rx1510_cur."!cursor_from"(rx1510_pos)
    ge rx1510_pos, rx1510_eos, rxscan1514_done
  rxscan1514_scan:
    set_addr $I10, rxscan1514_loop
    rx1510_cur."!mark_push"(0, rx1510_pos, $I10)
  rxscan1514_done:
.annotate 'line', 628
  # rx subcapture "sym"
    set_addr $I10, rxcap_1515_fail
    rx1510_cur."!mark_push"(0, rx1510_pos, $I10)
  # rx literal  "//"
    add $I11, rx1510_pos, 2
    gt $I11, rx1510_eos, rx1510_fail
    sub $I11, rx1510_pos, rx1510_off
    substr $S10, rx1510_tgt, $I11, 2
    ne $S10, "//", rx1510_fail
    add rx1510_pos, 2
    set_addr $I10, rxcap_1515_fail
    ($I12, $I11) = rx1510_cur."!mark_peek"($I10)
    rx1510_cur."!cursor_pos"($I11)
    ($P10) = rx1510_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1510_pos, "")
    rx1510_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1515_done
  rxcap_1515_fail:
    goto rx1510_fail
  rxcap_1515_done:
  # rx subrule "O" subtype=capture negate=
    rx1510_cur."!cursor_pos"(rx1510_pos)
    $P10 = rx1510_cur."O"("%tight_or, :pasttype<def_or>")
    unless $P10, rx1510_fail
    rx1510_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1510_pos = $P10."pos"()
  # rx pass
    rx1510_cur."!cursor_pass"(rx1510_pos, "infix:sym<//>")
    if_null rx1510_debug, debug_1072
    rx1510_cur."!cursor_debug"("PASS", "infix:sym<//>", " at pos=", rx1510_pos)
  debug_1072:
    .return (rx1510_cur)
  rx1510_restart:
.annotate 'line', 4
    if_null rx1510_debug, debug_1073
    rx1510_cur."!cursor_debug"("NEXT", "infix:sym<//>")
  debug_1073:
  rx1510_fail:
    (rx1510_rep, rx1510_pos, $I10, $P10) = rx1510_cur."!mark_fail"(0)
    lt rx1510_pos, -1, rx1510_done
    eq rx1510_pos, -1, rx1510_fail
    jump $I10
  rx1510_done:
    rx1510_cur."!cursor_fail"()
    if_null rx1510_debug, debug_1074
    rx1510_cur."!cursor_debug"("FAIL", "infix:sym<//>")
  debug_1074:
    .return (rx1510_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<//>"  :nsentry("!PREFIX__infix:sym<//>") :subid("353_1298325448.42642") :method
.annotate 'line', 4
    $P1512 = self."!PREFIX__!subrule"("O", "//")
    new $P1513, "ResizablePMCArray"
    push $P1513, $P1512
    .return ($P1513)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<?? !!>"  :subid("354_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1517_tgt
    .local int rx1517_pos
    .local int rx1517_off
    .local int rx1517_eos
    .local int rx1517_rep
    .local pmc rx1517_cur
    .local pmc rx1517_debug
    (rx1517_cur, rx1517_pos, rx1517_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1517_cur
    .local pmc match
    .lex "$/", match
    length rx1517_eos, rx1517_tgt
    gt rx1517_pos, rx1517_eos, rx1517_done
    set rx1517_off, 0
    lt rx1517_pos, 2, rx1517_start
    sub rx1517_off, rx1517_pos, 1
    substr rx1517_tgt, rx1517_tgt, rx1517_off
  rx1517_start:
    eq $I10, 1, rx1517_restart
    if_null rx1517_debug, debug_1075
    rx1517_cur."!cursor_debug"("START", "infix:sym<?? !!>")
  debug_1075:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1521_done
    goto rxscan1521_scan
  rxscan1521_loop:
    (rx1517_pos) = rx1517_cur."from"()
    inc rx1517_pos
    rx1517_cur."!cursor_from"(rx1517_pos)
    ge rx1517_pos, rx1517_eos, rxscan1521_done
  rxscan1521_scan:
    set_addr $I10, rxscan1521_loop
    rx1517_cur."!mark_push"(0, rx1517_pos, $I10)
  rxscan1521_done:
.annotate 'line', 631
  # rx literal  "??"
    add $I11, rx1517_pos, 2
    gt $I11, rx1517_eos, rx1517_fail
    sub $I11, rx1517_pos, rx1517_off
    substr $S10, rx1517_tgt, $I11, 2
    ne $S10, "??", rx1517_fail
    add rx1517_pos, 2
.annotate 'line', 632
  # rx subrule "ws" subtype=method negate=
    rx1517_cur."!cursor_pos"(rx1517_pos)
    $P10 = rx1517_cur."ws"()
    unless $P10, rx1517_fail
    rx1517_pos = $P10."pos"()
.annotate 'line', 633
  # rx subrule "EXPR" subtype=capture negate=
    rx1517_cur."!cursor_pos"(rx1517_pos)
    $P10 = rx1517_cur."EXPR"("i=")
    unless $P10, rx1517_fail
    rx1517_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1517_pos = $P10."pos"()
.annotate 'line', 634
  # rx literal  "!!"
    add $I11, rx1517_pos, 2
    gt $I11, rx1517_eos, rx1517_fail
    sub $I11, rx1517_pos, rx1517_off
    substr $S10, rx1517_tgt, $I11, 2
    ne $S10, "!!", rx1517_fail
    add rx1517_pos, 2
.annotate 'line', 635
  # rx subrule "O" subtype=capture negate=
    rx1517_cur."!cursor_pos"(rx1517_pos)
    $P10 = rx1517_cur."O"("%conditional, :reducecheck<ternary>, :pasttype<if>")
    unless $P10, rx1517_fail
    rx1517_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1517_pos = $P10."pos"()
.annotate 'line', 630
  # rx pass
    rx1517_cur."!cursor_pass"(rx1517_pos, "infix:sym<?? !!>")
    if_null rx1517_debug, debug_1076
    rx1517_cur."!cursor_debug"("PASS", "infix:sym<?? !!>", " at pos=", rx1517_pos)
  debug_1076:
    .return (rx1517_cur)
  rx1517_restart:
.annotate 'line', 4
    if_null rx1517_debug, debug_1077
    rx1517_cur."!cursor_debug"("NEXT", "infix:sym<?? !!>")
  debug_1077:
  rx1517_fail:
    (rx1517_rep, rx1517_pos, $I10, $P10) = rx1517_cur."!mark_fail"(0)
    lt rx1517_pos, -1, rx1517_done
    eq rx1517_pos, -1, rx1517_fail
    jump $I10
  rx1517_done:
    rx1517_cur."!cursor_fail"()
    if_null rx1517_debug, debug_1078
    rx1517_cur."!cursor_debug"("FAIL", "infix:sym<?? !!>")
  debug_1078:
    .return (rx1517_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<?? !!>"  :nsentry("!PREFIX__infix:sym<?? !!>") :subid("355_1298325448.42642") :method
.annotate 'line', 4
    $P1519 = self."!PREFIX__!subrule"("ws", "??")
    new $P1520, "ResizablePMCArray"
    push $P1520, $P1519
    .return ($P1520)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<=>"  :subid("356_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1523_tgt
    .local int rx1523_pos
    .local int rx1523_off
    .local int rx1523_eos
    .local int rx1523_rep
    .local pmc rx1523_cur
    .local pmc rx1523_debug
    (rx1523_cur, rx1523_pos, rx1523_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1523_cur
    .local pmc match
    .lex "$/", match
    length rx1523_eos, rx1523_tgt
    gt rx1523_pos, rx1523_eos, rx1523_done
    set rx1523_off, 0
    lt rx1523_pos, 2, rx1523_start
    sub rx1523_off, rx1523_pos, 1
    substr rx1523_tgt, rx1523_tgt, rx1523_off
  rx1523_start:
    eq $I10, 1, rx1523_restart
    if_null rx1523_debug, debug_1079
    rx1523_cur."!cursor_debug"("START", "infix:sym<=>")
  debug_1079:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1527_done
    goto rxscan1527_scan
  rxscan1527_loop:
    (rx1523_pos) = rx1523_cur."from"()
    inc rx1523_pos
    rx1523_cur."!cursor_from"(rx1523_pos)
    ge rx1523_pos, rx1523_eos, rxscan1527_done
  rxscan1527_scan:
    set_addr $I10, rxscan1527_loop
    rx1523_cur."!mark_push"(0, rx1523_pos, $I10)
  rxscan1527_done:
.annotate 'line', 639
  # rx subcapture "sym"
    set_addr $I10, rxcap_1528_fail
    rx1523_cur."!mark_push"(0, rx1523_pos, $I10)
  # rx literal  "="
    add $I11, rx1523_pos, 1
    gt $I11, rx1523_eos, rx1523_fail
    sub $I11, rx1523_pos, rx1523_off
    ord $I11, rx1523_tgt, $I11
    ne $I11, 61, rx1523_fail
    add rx1523_pos, 1
    set_addr $I10, rxcap_1528_fail
    ($I12, $I11) = rx1523_cur."!mark_peek"($I10)
    rx1523_cur."!cursor_pos"($I11)
    ($P10) = rx1523_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1523_pos, "")
    rx1523_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1528_done
  rxcap_1528_fail:
    goto rx1523_fail
  rxcap_1528_done:
  # rx subrule "panic" subtype=method negate=
    rx1523_cur."!cursor_pos"(rx1523_pos)
    $P10 = rx1523_cur."panic"("Assignment (\"=\") not supported in NQP, use \":=\" instead")
    unless $P10, rx1523_fail
    rx1523_pos = $P10."pos"()
.annotate 'line', 638
  # rx pass
    rx1523_cur."!cursor_pass"(rx1523_pos, "infix:sym<=>")
    if_null rx1523_debug, debug_1080
    rx1523_cur."!cursor_debug"("PASS", "infix:sym<=>", " at pos=", rx1523_pos)
  debug_1080:
    .return (rx1523_cur)
  rx1523_restart:
.annotate 'line', 4
    if_null rx1523_debug, debug_1081
    rx1523_cur."!cursor_debug"("NEXT", "infix:sym<=>")
  debug_1081:
  rx1523_fail:
    (rx1523_rep, rx1523_pos, $I10, $P10) = rx1523_cur."!mark_fail"(0)
    lt rx1523_pos, -1, rx1523_done
    eq rx1523_pos, -1, rx1523_fail
    jump $I10
  rx1523_done:
    rx1523_cur."!cursor_fail"()
    if_null rx1523_debug, debug_1082
    rx1523_cur."!cursor_debug"("FAIL", "infix:sym<=>")
  debug_1082:
    .return (rx1523_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=>"  :nsentry("!PREFIX__infix:sym<=>") :subid("357_1298325448.42642") :method
.annotate 'line', 4
    $P1525 = self."!PREFIX__!subrule"("panic", "=")
    new $P1526, "ResizablePMCArray"
    push $P1526, $P1525
    .return ($P1526)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<:=>"  :subid("358_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1530_tgt
    .local int rx1530_pos
    .local int rx1530_off
    .local int rx1530_eos
    .local int rx1530_rep
    .local pmc rx1530_cur
    .local pmc rx1530_debug
    (rx1530_cur, rx1530_pos, rx1530_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1530_cur
    .local pmc match
    .lex "$/", match
    length rx1530_eos, rx1530_tgt
    gt rx1530_pos, rx1530_eos, rx1530_done
    set rx1530_off, 0
    lt rx1530_pos, 2, rx1530_start
    sub rx1530_off, rx1530_pos, 1
    substr rx1530_tgt, rx1530_tgt, rx1530_off
  rx1530_start:
    eq $I10, 1, rx1530_restart
    if_null rx1530_debug, debug_1083
    rx1530_cur."!cursor_debug"("START", "infix:sym<:=>")
  debug_1083:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1534_done
    goto rxscan1534_scan
  rxscan1534_loop:
    (rx1530_pos) = rx1530_cur."from"()
    inc rx1530_pos
    rx1530_cur."!cursor_from"(rx1530_pos)
    ge rx1530_pos, rx1530_eos, rxscan1534_done
  rxscan1534_scan:
    set_addr $I10, rxscan1534_loop
    rx1530_cur."!mark_push"(0, rx1530_pos, $I10)
  rxscan1534_done:
.annotate 'line', 641
  # rx subcapture "sym"
    set_addr $I10, rxcap_1535_fail
    rx1530_cur."!mark_push"(0, rx1530_pos, $I10)
  # rx literal  ":="
    add $I11, rx1530_pos, 2
    gt $I11, rx1530_eos, rx1530_fail
    sub $I11, rx1530_pos, rx1530_off
    substr $S10, rx1530_tgt, $I11, 2
    ne $S10, ":=", rx1530_fail
    add rx1530_pos, 2
    set_addr $I10, rxcap_1535_fail
    ($I12, $I11) = rx1530_cur."!mark_peek"($I10)
    rx1530_cur."!cursor_pos"($I11)
    ($P10) = rx1530_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1530_pos, "")
    rx1530_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1535_done
  rxcap_1535_fail:
    goto rx1530_fail
  rxcap_1535_done:
  # rx subrule "O" subtype=capture negate=
    rx1530_cur."!cursor_pos"(rx1530_pos)
    $P10 = rx1530_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx1530_fail
    rx1530_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1530_pos = $P10."pos"()
  # rx pass
    rx1530_cur."!cursor_pass"(rx1530_pos, "infix:sym<:=>")
    if_null rx1530_debug, debug_1084
    rx1530_cur."!cursor_debug"("PASS", "infix:sym<:=>", " at pos=", rx1530_pos)
  debug_1084:
    .return (rx1530_cur)
  rx1530_restart:
.annotate 'line', 4
    if_null rx1530_debug, debug_1085
    rx1530_cur."!cursor_debug"("NEXT", "infix:sym<:=>")
  debug_1085:
  rx1530_fail:
    (rx1530_rep, rx1530_pos, $I10, $P10) = rx1530_cur."!mark_fail"(0)
    lt rx1530_pos, -1, rx1530_done
    eq rx1530_pos, -1, rx1530_fail
    jump $I10
  rx1530_done:
    rx1530_cur."!cursor_fail"()
    if_null rx1530_debug, debug_1086
    rx1530_cur."!cursor_debug"("FAIL", "infix:sym<:=>")
  debug_1086:
    .return (rx1530_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<:=>"  :nsentry("!PREFIX__infix:sym<:=>") :subid("359_1298325448.42642") :method
.annotate 'line', 4
    $P1532 = self."!PREFIX__!subrule"("O", ":=")
    new $P1533, "ResizablePMCArray"
    push $P1533, $P1532
    .return ($P1533)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<::=>"  :subid("360_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1537_tgt
    .local int rx1537_pos
    .local int rx1537_off
    .local int rx1537_eos
    .local int rx1537_rep
    .local pmc rx1537_cur
    .local pmc rx1537_debug
    (rx1537_cur, rx1537_pos, rx1537_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1537_cur
    .local pmc match
    .lex "$/", match
    length rx1537_eos, rx1537_tgt
    gt rx1537_pos, rx1537_eos, rx1537_done
    set rx1537_off, 0
    lt rx1537_pos, 2, rx1537_start
    sub rx1537_off, rx1537_pos, 1
    substr rx1537_tgt, rx1537_tgt, rx1537_off
  rx1537_start:
    eq $I10, 1, rx1537_restart
    if_null rx1537_debug, debug_1087
    rx1537_cur."!cursor_debug"("START", "infix:sym<::=>")
  debug_1087:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1541_done
    goto rxscan1541_scan
  rxscan1541_loop:
    (rx1537_pos) = rx1537_cur."from"()
    inc rx1537_pos
    rx1537_cur."!cursor_from"(rx1537_pos)
    ge rx1537_pos, rx1537_eos, rxscan1541_done
  rxscan1541_scan:
    set_addr $I10, rxscan1541_loop
    rx1537_cur."!mark_push"(0, rx1537_pos, $I10)
  rxscan1541_done:
.annotate 'line', 642
  # rx subcapture "sym"
    set_addr $I10, rxcap_1542_fail
    rx1537_cur."!mark_push"(0, rx1537_pos, $I10)
  # rx literal  "::="
    add $I11, rx1537_pos, 3
    gt $I11, rx1537_eos, rx1537_fail
    sub $I11, rx1537_pos, rx1537_off
    substr $S10, rx1537_tgt, $I11, 3
    ne $S10, "::=", rx1537_fail
    add rx1537_pos, 3
    set_addr $I10, rxcap_1542_fail
    ($I12, $I11) = rx1537_cur."!mark_peek"($I10)
    rx1537_cur."!cursor_pos"($I11)
    ($P10) = rx1537_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1537_pos, "")
    rx1537_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1542_done
  rxcap_1542_fail:
    goto rx1537_fail
  rxcap_1542_done:
  # rx subrule "O" subtype=capture negate=
    rx1537_cur."!cursor_pos"(rx1537_pos)
    $P10 = rx1537_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx1537_fail
    rx1537_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1537_pos = $P10."pos"()
  # rx pass
    rx1537_cur."!cursor_pass"(rx1537_pos, "infix:sym<::=>")
    if_null rx1537_debug, debug_1088
    rx1537_cur."!cursor_debug"("PASS", "infix:sym<::=>", " at pos=", rx1537_pos)
  debug_1088:
    .return (rx1537_cur)
  rx1537_restart:
.annotate 'line', 4
    if_null rx1537_debug, debug_1089
    rx1537_cur."!cursor_debug"("NEXT", "infix:sym<::=>")
  debug_1089:
  rx1537_fail:
    (rx1537_rep, rx1537_pos, $I10, $P10) = rx1537_cur."!mark_fail"(0)
    lt rx1537_pos, -1, rx1537_done
    eq rx1537_pos, -1, rx1537_fail
    jump $I10
  rx1537_done:
    rx1537_cur."!cursor_fail"()
    if_null rx1537_debug, debug_1090
    rx1537_cur."!cursor_debug"("FAIL", "infix:sym<::=>")
  debug_1090:
    .return (rx1537_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<::=>"  :nsentry("!PREFIX__infix:sym<::=>") :subid("361_1298325448.42642") :method
.annotate 'line', 4
    $P1539 = self."!PREFIX__!subrule"("O", "::=")
    new $P1540, "ResizablePMCArray"
    push $P1540, $P1539
    .return ($P1540)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<,>"  :subid("362_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1544_tgt
    .local int rx1544_pos
    .local int rx1544_off
    .local int rx1544_eos
    .local int rx1544_rep
    .local pmc rx1544_cur
    .local pmc rx1544_debug
    (rx1544_cur, rx1544_pos, rx1544_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1544_cur
    .local pmc match
    .lex "$/", match
    length rx1544_eos, rx1544_tgt
    gt rx1544_pos, rx1544_eos, rx1544_done
    set rx1544_off, 0
    lt rx1544_pos, 2, rx1544_start
    sub rx1544_off, rx1544_pos, 1
    substr rx1544_tgt, rx1544_tgt, rx1544_off
  rx1544_start:
    eq $I10, 1, rx1544_restart
    if_null rx1544_debug, debug_1091
    rx1544_cur."!cursor_debug"("START", "infix:sym<,>")
  debug_1091:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1548_done
    goto rxscan1548_scan
  rxscan1548_loop:
    (rx1544_pos) = rx1544_cur."from"()
    inc rx1544_pos
    rx1544_cur."!cursor_from"(rx1544_pos)
    ge rx1544_pos, rx1544_eos, rxscan1548_done
  rxscan1548_scan:
    set_addr $I10, rxscan1548_loop
    rx1544_cur."!mark_push"(0, rx1544_pos, $I10)
  rxscan1548_done:
.annotate 'line', 644
  # rx subcapture "sym"
    set_addr $I10, rxcap_1549_fail
    rx1544_cur."!mark_push"(0, rx1544_pos, $I10)
  # rx literal  ","
    add $I11, rx1544_pos, 1
    gt $I11, rx1544_eos, rx1544_fail
    sub $I11, rx1544_pos, rx1544_off
    ord $I11, rx1544_tgt, $I11
    ne $I11, 44, rx1544_fail
    add rx1544_pos, 1
    set_addr $I10, rxcap_1549_fail
    ($I12, $I11) = rx1544_cur."!mark_peek"($I10)
    rx1544_cur."!cursor_pos"($I11)
    ($P10) = rx1544_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1544_pos, "")
    rx1544_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1549_done
  rxcap_1549_fail:
    goto rx1544_fail
  rxcap_1549_done:
  # rx subrule "O" subtype=capture negate=
    rx1544_cur."!cursor_pos"(rx1544_pos)
    $P10 = rx1544_cur."O"("%comma, :pasttype<list>")
    unless $P10, rx1544_fail
    rx1544_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1544_pos = $P10."pos"()
  # rx pass
    rx1544_cur."!cursor_pass"(rx1544_pos, "infix:sym<,>")
    if_null rx1544_debug, debug_1092
    rx1544_cur."!cursor_debug"("PASS", "infix:sym<,>", " at pos=", rx1544_pos)
  debug_1092:
    .return (rx1544_cur)
  rx1544_restart:
.annotate 'line', 4
    if_null rx1544_debug, debug_1093
    rx1544_cur."!cursor_debug"("NEXT", "infix:sym<,>")
  debug_1093:
  rx1544_fail:
    (rx1544_rep, rx1544_pos, $I10, $P10) = rx1544_cur."!mark_fail"(0)
    lt rx1544_pos, -1, rx1544_done
    eq rx1544_pos, -1, rx1544_fail
    jump $I10
  rx1544_done:
    rx1544_cur."!cursor_fail"()
    if_null rx1544_debug, debug_1094
    rx1544_cur."!cursor_debug"("FAIL", "infix:sym<,>")
  debug_1094:
    .return (rx1544_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<,>"  :nsentry("!PREFIX__infix:sym<,>") :subid("363_1298325448.42642") :method
.annotate 'line', 4
    $P1546 = self."!PREFIX__!subrule"("O", ",")
    new $P1547, "ResizablePMCArray"
    push $P1547, $P1546
    .return ($P1547)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<return>"  :subid("364_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .const 'Sub' $P1559 = "366_1298325448.42642" 
    capture_lex $P1559
    .local string rx1551_tgt
    .local int rx1551_pos
    .local int rx1551_off
    .local int rx1551_eos
    .local int rx1551_rep
    .local pmc rx1551_cur
    .local pmc rx1551_debug
    (rx1551_cur, rx1551_pos, rx1551_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1551_cur
    .local pmc match
    .lex "$/", match
    length rx1551_eos, rx1551_tgt
    gt rx1551_pos, rx1551_eos, rx1551_done
    set rx1551_off, 0
    lt rx1551_pos, 2, rx1551_start
    sub rx1551_off, rx1551_pos, 1
    substr rx1551_tgt, rx1551_tgt, rx1551_off
  rx1551_start:
    eq $I10, 1, rx1551_restart
    if_null rx1551_debug, debug_1095
    rx1551_cur."!cursor_debug"("START", "prefix:sym<return>")
  debug_1095:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1554_done
    goto rxscan1554_scan
  rxscan1554_loop:
    (rx1551_pos) = rx1551_cur."from"()
    inc rx1551_pos
    rx1551_cur."!cursor_from"(rx1551_pos)
    ge rx1551_pos, rx1551_eos, rxscan1554_done
  rxscan1554_scan:
    set_addr $I10, rxscan1554_loop
    rx1551_cur."!mark_push"(0, rx1551_pos, $I10)
  rxscan1554_done:
.annotate 'line', 646
  # rx subcapture "sym"
    set_addr $I10, rxcap_1555_fail
    rx1551_cur."!mark_push"(0, rx1551_pos, $I10)
  # rx literal  "return"
    add $I11, rx1551_pos, 6
    gt $I11, rx1551_eos, rx1551_fail
    sub $I11, rx1551_pos, rx1551_off
    substr $S10, rx1551_tgt, $I11, 6
    ne $S10, "return", rx1551_fail
    add rx1551_pos, 6
    set_addr $I10, rxcap_1555_fail
    ($I12, $I11) = rx1551_cur."!mark_peek"($I10)
    rx1551_cur."!cursor_pos"($I11)
    ($P10) = rx1551_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1551_pos, "")
    rx1551_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1555_done
  rxcap_1555_fail:
    goto rx1551_fail
  rxcap_1555_done:
  # rx charclass s
    ge rx1551_pos, rx1551_eos, rx1551_fail
    sub $I10, rx1551_pos, rx1551_off
    is_cclass $I11, 32, rx1551_tgt, $I10
    unless $I11, rx1551_fail
    inc rx1551_pos
  # rx subrule "O" subtype=capture negate=
    rx1551_cur."!cursor_pos"(rx1551_pos)
    $P10 = rx1551_cur."O"("%list_prefix, :pasttype<return>")
    unless $P10, rx1551_fail
    rx1551_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1551_pos = $P10."pos"()
    rx1551_cur."!cursor_pos"(rx1551_pos)
    find_lex $P1556, unicode:"$\x{a2}"
    $P1557 = $P1556."MATCH"()
    store_lex "$/", $P1557
    .const 'Sub' $P1559 = "366_1298325448.42642" 
    capture_lex $P1559
    $P1561 = $P1559()
  # rx pass
    rx1551_cur."!cursor_pass"(rx1551_pos, "prefix:sym<return>")
    if_null rx1551_debug, debug_1096
    rx1551_cur."!cursor_debug"("PASS", "prefix:sym<return>", " at pos=", rx1551_pos)
  debug_1096:
    .return (rx1551_cur)
  rx1551_restart:
.annotate 'line', 4
    if_null rx1551_debug, debug_1097
    rx1551_cur."!cursor_debug"("NEXT", "prefix:sym<return>")
  debug_1097:
  rx1551_fail:
    (rx1551_rep, rx1551_pos, $I10, $P10) = rx1551_cur."!mark_fail"(0)
    lt rx1551_pos, -1, rx1551_done
    eq rx1551_pos, -1, rx1551_fail
    jump $I10
  rx1551_done:
    rx1551_cur."!cursor_fail"()
    if_null rx1551_debug, debug_1098
    rx1551_cur."!cursor_debug"("FAIL", "prefix:sym<return>")
  debug_1098:
    .return (rx1551_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<return>"  :nsentry("!PREFIX__prefix:sym<return>") :subid("365_1298325448.42642") :method
.annotate 'line', 4
    new $P1553, "ResizablePMCArray"
    push $P1553, "return"
    .return ($P1553)
.end


.namespace ["NQP";"Grammar"]
.sub "_block1558"  :anon :subid("366_1298325448.42642") :outer("364_1298325448.42642")
.annotate 'line', 646
    new $P1560, "Integer"
    assign $P1560, 1
    store_dynamic_lex "$*RETURN_USED", $P1560
    .return ($P1560)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<make>"  :subid("367_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1563_tgt
    .local int rx1563_pos
    .local int rx1563_off
    .local int rx1563_eos
    .local int rx1563_rep
    .local pmc rx1563_cur
    .local pmc rx1563_debug
    (rx1563_cur, rx1563_pos, rx1563_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1563_cur
    .local pmc match
    .lex "$/", match
    length rx1563_eos, rx1563_tgt
    gt rx1563_pos, rx1563_eos, rx1563_done
    set rx1563_off, 0
    lt rx1563_pos, 2, rx1563_start
    sub rx1563_off, rx1563_pos, 1
    substr rx1563_tgt, rx1563_tgt, rx1563_off
  rx1563_start:
    eq $I10, 1, rx1563_restart
    if_null rx1563_debug, debug_1099
    rx1563_cur."!cursor_debug"("START", "prefix:sym<make>")
  debug_1099:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1566_done
    goto rxscan1566_scan
  rxscan1566_loop:
    (rx1563_pos) = rx1563_cur."from"()
    inc rx1563_pos
    rx1563_cur."!cursor_from"(rx1563_pos)
    ge rx1563_pos, rx1563_eos, rxscan1566_done
  rxscan1566_scan:
    set_addr $I10, rxscan1566_loop
    rx1563_cur."!mark_push"(0, rx1563_pos, $I10)
  rxscan1566_done:
.annotate 'line', 647
  # rx subcapture "sym"
    set_addr $I10, rxcap_1567_fail
    rx1563_cur."!mark_push"(0, rx1563_pos, $I10)
  # rx literal  "make"
    add $I11, rx1563_pos, 4
    gt $I11, rx1563_eos, rx1563_fail
    sub $I11, rx1563_pos, rx1563_off
    substr $S10, rx1563_tgt, $I11, 4
    ne $S10, "make", rx1563_fail
    add rx1563_pos, 4
    set_addr $I10, rxcap_1567_fail
    ($I12, $I11) = rx1563_cur."!mark_peek"($I10)
    rx1563_cur."!cursor_pos"($I11)
    ($P10) = rx1563_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1563_pos, "")
    rx1563_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1567_done
  rxcap_1567_fail:
    goto rx1563_fail
  rxcap_1567_done:
  # rx charclass s
    ge rx1563_pos, rx1563_eos, rx1563_fail
    sub $I10, rx1563_pos, rx1563_off
    is_cclass $I11, 32, rx1563_tgt, $I10
    unless $I11, rx1563_fail
    inc rx1563_pos
  # rx subrule "O" subtype=capture negate=
    rx1563_cur."!cursor_pos"(rx1563_pos)
    $P10 = rx1563_cur."O"("%list_prefix")
    unless $P10, rx1563_fail
    rx1563_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1563_pos = $P10."pos"()
  # rx pass
    rx1563_cur."!cursor_pass"(rx1563_pos, "prefix:sym<make>")
    if_null rx1563_debug, debug_1100
    rx1563_cur."!cursor_debug"("PASS", "prefix:sym<make>", " at pos=", rx1563_pos)
  debug_1100:
    .return (rx1563_cur)
  rx1563_restart:
.annotate 'line', 4
    if_null rx1563_debug, debug_1101
    rx1563_cur."!cursor_debug"("NEXT", "prefix:sym<make>")
  debug_1101:
  rx1563_fail:
    (rx1563_rep, rx1563_pos, $I10, $P10) = rx1563_cur."!mark_fail"(0)
    lt rx1563_pos, -1, rx1563_done
    eq rx1563_pos, -1, rx1563_fail
    jump $I10
  rx1563_done:
    rx1563_cur."!cursor_fail"()
    if_null rx1563_debug, debug_1102
    rx1563_cur."!cursor_debug"("FAIL", "prefix:sym<make>")
  debug_1102:
    .return (rx1563_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<make>"  :nsentry("!PREFIX__prefix:sym<make>") :subid("368_1298325448.42642") :method
.annotate 'line', 4
    new $P1565, "ResizablePMCArray"
    push $P1565, "make"
    .return ($P1565)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<last>"  :subid("369_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1569_tgt
    .local int rx1569_pos
    .local int rx1569_off
    .local int rx1569_eos
    .local int rx1569_rep
    .local pmc rx1569_cur
    .local pmc rx1569_debug
    (rx1569_cur, rx1569_pos, rx1569_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1569_cur
    .local pmc match
    .lex "$/", match
    length rx1569_eos, rx1569_tgt
    gt rx1569_pos, rx1569_eos, rx1569_done
    set rx1569_off, 0
    lt rx1569_pos, 2, rx1569_start
    sub rx1569_off, rx1569_pos, 1
    substr rx1569_tgt, rx1569_tgt, rx1569_off
  rx1569_start:
    eq $I10, 1, rx1569_restart
    if_null rx1569_debug, debug_1103
    rx1569_cur."!cursor_debug"("START", "term:sym<last>")
  debug_1103:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1572_done
    goto rxscan1572_scan
  rxscan1572_loop:
    (rx1569_pos) = rx1569_cur."from"()
    inc rx1569_pos
    rx1569_cur."!cursor_from"(rx1569_pos)
    ge rx1569_pos, rx1569_eos, rxscan1572_done
  rxscan1572_scan:
    set_addr $I10, rxscan1572_loop
    rx1569_cur."!mark_push"(0, rx1569_pos, $I10)
  rxscan1572_done:
.annotate 'line', 648
  # rx subcapture "sym"
    set_addr $I10, rxcap_1573_fail
    rx1569_cur."!mark_push"(0, rx1569_pos, $I10)
  # rx literal  "last"
    add $I11, rx1569_pos, 4
    gt $I11, rx1569_eos, rx1569_fail
    sub $I11, rx1569_pos, rx1569_off
    substr $S10, rx1569_tgt, $I11, 4
    ne $S10, "last", rx1569_fail
    add rx1569_pos, 4
    set_addr $I10, rxcap_1573_fail
    ($I12, $I11) = rx1569_cur."!mark_peek"($I10)
    rx1569_cur."!cursor_pos"($I11)
    ($P10) = rx1569_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1569_pos, "")
    rx1569_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1573_done
  rxcap_1573_fail:
    goto rx1569_fail
  rxcap_1573_done:
  # rx pass
    rx1569_cur."!cursor_pass"(rx1569_pos, "term:sym<last>")
    if_null rx1569_debug, debug_1104
    rx1569_cur."!cursor_debug"("PASS", "term:sym<last>", " at pos=", rx1569_pos)
  debug_1104:
    .return (rx1569_cur)
  rx1569_restart:
.annotate 'line', 4
    if_null rx1569_debug, debug_1105
    rx1569_cur."!cursor_debug"("NEXT", "term:sym<last>")
  debug_1105:
  rx1569_fail:
    (rx1569_rep, rx1569_pos, $I10, $P10) = rx1569_cur."!mark_fail"(0)
    lt rx1569_pos, -1, rx1569_done
    eq rx1569_pos, -1, rx1569_fail
    jump $I10
  rx1569_done:
    rx1569_cur."!cursor_fail"()
    if_null rx1569_debug, debug_1106
    rx1569_cur."!cursor_debug"("FAIL", "term:sym<last>")
  debug_1106:
    .return (rx1569_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<last>"  :nsentry("!PREFIX__term:sym<last>") :subid("370_1298325448.42642") :method
.annotate 'line', 4
    new $P1571, "ResizablePMCArray"
    push $P1571, "last"
    .return ($P1571)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<next>"  :subid("371_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1575_tgt
    .local int rx1575_pos
    .local int rx1575_off
    .local int rx1575_eos
    .local int rx1575_rep
    .local pmc rx1575_cur
    .local pmc rx1575_debug
    (rx1575_cur, rx1575_pos, rx1575_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1575_cur
    .local pmc match
    .lex "$/", match
    length rx1575_eos, rx1575_tgt
    gt rx1575_pos, rx1575_eos, rx1575_done
    set rx1575_off, 0
    lt rx1575_pos, 2, rx1575_start
    sub rx1575_off, rx1575_pos, 1
    substr rx1575_tgt, rx1575_tgt, rx1575_off
  rx1575_start:
    eq $I10, 1, rx1575_restart
    if_null rx1575_debug, debug_1107
    rx1575_cur."!cursor_debug"("START", "term:sym<next>")
  debug_1107:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1578_done
    goto rxscan1578_scan
  rxscan1578_loop:
    (rx1575_pos) = rx1575_cur."from"()
    inc rx1575_pos
    rx1575_cur."!cursor_from"(rx1575_pos)
    ge rx1575_pos, rx1575_eos, rxscan1578_done
  rxscan1578_scan:
    set_addr $I10, rxscan1578_loop
    rx1575_cur."!mark_push"(0, rx1575_pos, $I10)
  rxscan1578_done:
.annotate 'line', 649
  # rx subcapture "sym"
    set_addr $I10, rxcap_1579_fail
    rx1575_cur."!mark_push"(0, rx1575_pos, $I10)
  # rx literal  "next"
    add $I11, rx1575_pos, 4
    gt $I11, rx1575_eos, rx1575_fail
    sub $I11, rx1575_pos, rx1575_off
    substr $S10, rx1575_tgt, $I11, 4
    ne $S10, "next", rx1575_fail
    add rx1575_pos, 4
    set_addr $I10, rxcap_1579_fail
    ($I12, $I11) = rx1575_cur."!mark_peek"($I10)
    rx1575_cur."!cursor_pos"($I11)
    ($P10) = rx1575_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1575_pos, "")
    rx1575_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1579_done
  rxcap_1579_fail:
    goto rx1575_fail
  rxcap_1579_done:
  # rx pass
    rx1575_cur."!cursor_pass"(rx1575_pos, "term:sym<next>")
    if_null rx1575_debug, debug_1108
    rx1575_cur."!cursor_debug"("PASS", "term:sym<next>", " at pos=", rx1575_pos)
  debug_1108:
    .return (rx1575_cur)
  rx1575_restart:
.annotate 'line', 4
    if_null rx1575_debug, debug_1109
    rx1575_cur."!cursor_debug"("NEXT", "term:sym<next>")
  debug_1109:
  rx1575_fail:
    (rx1575_rep, rx1575_pos, $I10, $P10) = rx1575_cur."!mark_fail"(0)
    lt rx1575_pos, -1, rx1575_done
    eq rx1575_pos, -1, rx1575_fail
    jump $I10
  rx1575_done:
    rx1575_cur."!cursor_fail"()
    if_null rx1575_debug, debug_1110
    rx1575_cur."!cursor_debug"("FAIL", "term:sym<next>")
  debug_1110:
    .return (rx1575_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<next>"  :nsentry("!PREFIX__term:sym<next>") :subid("372_1298325448.42642") :method
.annotate 'line', 4
    new $P1577, "ResizablePMCArray"
    push $P1577, "next"
    .return ($P1577)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<redo>"  :subid("373_1298325448.42642") :method :outer("11_1298325448.42642")
.annotate 'line', 4
    .local string rx1581_tgt
    .local int rx1581_pos
    .local int rx1581_off
    .local int rx1581_eos
    .local int rx1581_rep
    .local pmc rx1581_cur
    .local pmc rx1581_debug
    (rx1581_cur, rx1581_pos, rx1581_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1581_cur
    .local pmc match
    .lex "$/", match
    length rx1581_eos, rx1581_tgt
    gt rx1581_pos, rx1581_eos, rx1581_done
    set rx1581_off, 0
    lt rx1581_pos, 2, rx1581_start
    sub rx1581_off, rx1581_pos, 1
    substr rx1581_tgt, rx1581_tgt, rx1581_off
  rx1581_start:
    eq $I10, 1, rx1581_restart
    if_null rx1581_debug, debug_1111
    rx1581_cur."!cursor_debug"("START", "term:sym<redo>")
  debug_1111:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1584_done
    goto rxscan1584_scan
  rxscan1584_loop:
    (rx1581_pos) = rx1581_cur."from"()
    inc rx1581_pos
    rx1581_cur."!cursor_from"(rx1581_pos)
    ge rx1581_pos, rx1581_eos, rxscan1584_done
  rxscan1584_scan:
    set_addr $I10, rxscan1584_loop
    rx1581_cur."!mark_push"(0, rx1581_pos, $I10)
  rxscan1584_done:
.annotate 'line', 650
  # rx subcapture "sym"
    set_addr $I10, rxcap_1585_fail
    rx1581_cur."!mark_push"(0, rx1581_pos, $I10)
  # rx literal  "redo"
    add $I11, rx1581_pos, 4
    gt $I11, rx1581_eos, rx1581_fail
    sub $I11, rx1581_pos, rx1581_off
    substr $S10, rx1581_tgt, $I11, 4
    ne $S10, "redo", rx1581_fail
    add rx1581_pos, 4
    set_addr $I10, rxcap_1585_fail
    ($I12, $I11) = rx1581_cur."!mark_peek"($I10)
    rx1581_cur."!cursor_pos"($I11)
    ($P10) = rx1581_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1581_pos, "")
    rx1581_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1585_done
  rxcap_1585_fail:
    goto rx1581_fail
  rxcap_1585_done:
  # rx pass
    rx1581_cur."!cursor_pass"(rx1581_pos, "term:sym<redo>")
    if_null rx1581_debug, debug_1112
    rx1581_cur."!cursor_debug"("PASS", "term:sym<redo>", " at pos=", rx1581_pos)
  debug_1112:
    .return (rx1581_cur)
  rx1581_restart:
.annotate 'line', 4
    if_null rx1581_debug, debug_1113
    rx1581_cur."!cursor_debug"("NEXT", "term:sym<redo>")
  debug_1113:
  rx1581_fail:
    (rx1581_rep, rx1581_pos, $I10, $P10) = rx1581_cur."!mark_fail"(0)
    lt rx1581_pos, -1, rx1581_done
    eq rx1581_pos, -1, rx1581_fail
    jump $I10
  rx1581_done:
    rx1581_cur."!cursor_fail"()
    if_null rx1581_debug, debug_1114
    rx1581_cur."!cursor_debug"("FAIL", "term:sym<redo>")
  debug_1114:
    .return (rx1581_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<redo>"  :nsentry("!PREFIX__term:sym<redo>") :subid("374_1298325448.42642") :method
.annotate 'line', 4
    new $P1583, "ResizablePMCArray"
    push $P1583, "redo"
    .return ($P1583)
.end


.namespace ["NQP";"Grammar"]
.sub "smartmatch"  :subid("375_1298325448.42642") :outer("11_1298325448.42642")
    .param pmc param_1587
    .param pmc param_1588
.annotate 'line', 652
    .lex "self", param_1587
    .lex "$/", param_1588
.annotate 'line', 654
    new $P1589, "Undef"
    .lex "$t", $P1589
    find_lex $P1590, "$/"
    unless_null $P1590, vivify_1115
    $P1590 = root_new ['parrot';'ResizablePMCArray']
  vivify_1115:
    set $P1591, $P1590[0]
    unless_null $P1591, vivify_1116
    new $P1591, "Undef"
  vivify_1116:
    store_lex "$t", $P1591
    find_lex $P1592, "$/"
    unless_null $P1592, vivify_1117
    $P1592 = root_new ['parrot';'ResizablePMCArray']
  vivify_1117:
    set $P1593, $P1592[1]
    unless_null $P1593, vivify_1118
    new $P1593, "Undef"
  vivify_1118:
    find_lex $P1594, "$/"
    unless_null $P1594, vivify_1119
    $P1594 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P1594
  vivify_1119:
    set $P1594[0], $P1593
    find_lex $P1595, "$t"
    find_lex $P1596, "$/"
    unless_null $P1596, vivify_1120
    $P1596 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P1596
  vivify_1120:
    set $P1596[1], $P1595
.annotate 'line', 652
    .return ($P1595)
.end


.namespace ["NQP";"Regex"]
.sub "_block1597"  :subid("376_1298325448.42642") :outer("11_1298325448.42642")
.annotate 'line', 658
    .const 'Sub' $P1662 = "397_1298325448.42642" 
    capture_lex $P1662
    .const 'Sub' $P1655 = "395_1298325448.42642" 
    capture_lex $P1655
    .const 'Sub' $P1650 = "393_1298325448.42642" 
    capture_lex $P1650
    .const 'Sub' $P1638 = "390_1298325448.42642" 
    capture_lex $P1638
    .const 'Sub' $P1628 = "387_1298325448.42642" 
    capture_lex $P1628
    .const 'Sub' $P1623 = "385_1298325448.42642" 
    capture_lex $P1623
    .const 'Sub' $P1614 = "382_1298325448.42642" 
    capture_lex $P1614
    .const 'Sub' $P1609 = "380_1298325448.42642" 
    capture_lex $P1609
    .const 'Sub' $P1600 = "377_1298325448.42642" 
    capture_lex $P1600
    get_global $P1599, "$?CLASS"
    .const 'Sub' $P1655 = "395_1298325448.42642" 
    capture_lex $P1655
    .return ($P1655)
.end


.namespace ["NQP";"Regex"]
.sub "" :load :init :subid("post1121") :outer("376_1298325448.42642")
.annotate 'line', 658
    get_hll_global $P1598, ["NQP";"Regex"], "_block1597" 
    .local pmc block
    set block, $P1598
    .const 'Sub' $P1662 = "397_1298325448.42642" 
    capture_lex $P1662
    $P1662()
.end


.namespace ["NQP";"Regex"]
.sub "_block1661"  :anon :subid("397_1298325448.42642") :outer("376_1298325448.42642")
.annotate 'line', 658
    get_hll_global $P1663, "NQPClassHOW"
    $P1664 = $P1663."new_type"("Regex" :named("name"))
    .local pmc type_obj
    set type_obj, $P1664
    set_hll_global ["NQP"], "Regex", type_obj
    set_global "$?CLASS", type_obj
    get_how $P1665, type_obj
    .const 'Sub' $P1666 = "377_1298325448.42642" 
    $P1665."add_method"(type_obj, "metachar:sym<:my>", $P1666)
    get_how $P1667, type_obj
    get_global $P1668, "!PREFIX__metachar:sym<:my>"
    $P1667."add_method"(type_obj, "!PREFIX__metachar:sym<:my>", $P1668)
    get_how $P1669, type_obj
    .const 'Sub' $P1670 = "380_1298325448.42642" 
    $P1669."add_method"(type_obj, "metachar:sym<{ }>", $P1670)
    get_how $P1671, type_obj
    get_global $P1672, "!PREFIX__metachar:sym<{ }>"
    $P1671."add_method"(type_obj, "!PREFIX__metachar:sym<{ }>", $P1672)
    get_how $P1673, type_obj
    .const 'Sub' $P1674 = "382_1298325448.42642" 
    $P1673."add_method"(type_obj, "metachar:sym<nqpvar>", $P1674)
    get_how $P1675, type_obj
    get_global $P1676, "!PREFIX__metachar:sym<nqpvar>"
    $P1675."add_method"(type_obj, "!PREFIX__metachar:sym<nqpvar>", $P1676)
    get_how $P1677, type_obj
    .const 'Sub' $P1678 = "385_1298325448.42642" 
    $P1677."add_method"(type_obj, "assertion:sym<{ }>", $P1678)
    get_how $P1679, type_obj
    get_global $P1680, "!PREFIX__assertion:sym<{ }>"
    $P1679."add_method"(type_obj, "!PREFIX__assertion:sym<{ }>", $P1680)
    get_how $P1681, type_obj
    .const 'Sub' $P1682 = "387_1298325448.42642" 
    $P1681."add_method"(type_obj, "assertion:sym<?{ }>", $P1682)
    get_how $P1683, type_obj
    get_global $P1684, "!PREFIX__assertion:sym<?{ }>"
    $P1683."add_method"(type_obj, "!PREFIX__assertion:sym<?{ }>", $P1684)
    get_how $P1685, type_obj
    .const 'Sub' $P1686 = "390_1298325448.42642" 
    $P1685."add_method"(type_obj, "assertion:sym<name>", $P1686)
    get_how $P1687, type_obj
    get_global $P1688, "!PREFIX__assertion:sym<name>"
    $P1687."add_method"(type_obj, "!PREFIX__assertion:sym<name>", $P1688)
    get_how $P1689, type_obj
    .const 'Sub' $P1690 = "393_1298325448.42642" 
    $P1689."add_method"(type_obj, "assertion:sym<var>", $P1690)
    get_how $P1691, type_obj
    get_global $P1692, "!PREFIX__assertion:sym<var>"
    $P1691."add_method"(type_obj, "!PREFIX__assertion:sym<var>", $P1692)
    get_how $P1693, type_obj
    .const 'Sub' $P1694 = "395_1298325448.42642" 
    $P1693."add_method"(type_obj, "codeblock", $P1694)
    get_how $P1695, type_obj
    get_global $P1696, "!PREFIX__codeblock"
    $P1695."add_method"(type_obj, "!PREFIX__codeblock", $P1696)
    get_how $P1697, type_obj
    get_hll_global $P1698, ["Regex";"P6Regex"], "Grammar"
    $P1697."add_parent"(type_obj, $P1698)
    get_how $P1699, type_obj
    $P1700 = $P1699."compose"(type_obj)
    .return ($P1700)
.end


.namespace ["NQP";"Regex"]
.sub "metachar:sym<:my>"  :subid("377_1298325448.42642") :method :outer("376_1298325448.42642")
.annotate 'line', 658
    .const 'Sub' $P1606 = "379_1298325448.42642" 
    capture_lex $P1606
    .local string rx1601_tgt
    .local int rx1601_pos
    .local int rx1601_off
    .local int rx1601_eos
    .local int rx1601_rep
    .local pmc rx1601_cur
    .local pmc rx1601_debug
    (rx1601_cur, rx1601_pos, rx1601_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1601_cur
    .local pmc match
    .lex "$/", match
    length rx1601_eos, rx1601_tgt
    gt rx1601_pos, rx1601_eos, rx1601_done
    set rx1601_off, 0
    lt rx1601_pos, 2, rx1601_start
    sub rx1601_off, rx1601_pos, 1
    substr rx1601_tgt, rx1601_tgt, rx1601_off
  rx1601_start:
    eq $I10, 1, rx1601_restart
    if_null rx1601_debug, debug_1122
    rx1601_cur."!cursor_debug"("START", "metachar:sym<:my>")
  debug_1122:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1604_done
    goto rxscan1604_scan
  rxscan1604_loop:
    (rx1601_pos) = rx1601_cur."from"()
    inc rx1601_pos
    rx1601_cur."!cursor_from"(rx1601_pos)
    ge rx1601_pos, rx1601_eos, rxscan1604_done
  rxscan1604_scan:
    set_addr $I10, rxscan1604_loop
    rx1601_cur."!mark_push"(0, rx1601_pos, $I10)
  rxscan1604_done:
.annotate 'line', 660
  # rx literal  ":"
    add $I11, rx1601_pos, 1
    gt $I11, rx1601_eos, rx1601_fail
    sub $I11, rx1601_pos, rx1601_off
    ord $I11, rx1601_tgt, $I11
    ne $I11, 58, rx1601_fail
    add rx1601_pos, 1
  # rx subrule "before" subtype=zerowidth negate=
    rx1601_cur."!cursor_pos"(rx1601_pos)
    .const 'Sub' $P1606 = "379_1298325448.42642" 
    capture_lex $P1606
    $P10 = rx1601_cur."before"($P1606)
    unless $P10, rx1601_fail
  # rx subrule "LANG" subtype=capture negate=
    rx1601_cur."!cursor_pos"(rx1601_pos)
    $P10 = rx1601_cur."LANG"("MAIN", "statement")
    unless $P10, rx1601_fail
    rx1601_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx1601_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1601_cur."!cursor_pos"(rx1601_pos)
    $P10 = rx1601_cur."ws"()
    unless $P10, rx1601_fail
    rx1601_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx1601_pos, 1
    gt $I11, rx1601_eos, rx1601_fail
    sub $I11, rx1601_pos, rx1601_off
    ord $I11, rx1601_tgt, $I11
    ne $I11, 59, rx1601_fail
    add rx1601_pos, 1
.annotate 'line', 659
  # rx pass
    rx1601_cur."!cursor_pass"(rx1601_pos, "metachar:sym<:my>")
    if_null rx1601_debug, debug_1127
    rx1601_cur."!cursor_debug"("PASS", "metachar:sym<:my>", " at pos=", rx1601_pos)
  debug_1127:
    .return (rx1601_cur)
  rx1601_restart:
.annotate 'line', 658
    if_null rx1601_debug, debug_1128
    rx1601_cur."!cursor_debug"("NEXT", "metachar:sym<:my>")
  debug_1128:
  rx1601_fail:
    (rx1601_rep, rx1601_pos, $I10, $P10) = rx1601_cur."!mark_fail"(0)
    lt rx1601_pos, -1, rx1601_done
    eq rx1601_pos, -1, rx1601_fail
    jump $I10
  rx1601_done:
    rx1601_cur."!cursor_fail"()
    if_null rx1601_debug, debug_1129
    rx1601_cur."!cursor_debug"("FAIL", "metachar:sym<:my>")
  debug_1129:
    .return (rx1601_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<:my>"  :nsentry("!PREFIX__metachar:sym<:my>") :subid("378_1298325448.42642") :method
.annotate 'line', 658
    new $P1603, "ResizablePMCArray"
    push $P1603, ":"
    .return ($P1603)
.end


.namespace ["NQP";"Regex"]
.sub "_block1605"  :anon :subid("379_1298325448.42642") :method :outer("377_1298325448.42642")
.annotate 'line', 660
    .local string rx1607_tgt
    .local int rx1607_pos
    .local int rx1607_off
    .local int rx1607_eos
    .local int rx1607_rep
    .local pmc rx1607_cur
    .local pmc rx1607_debug
    (rx1607_cur, rx1607_pos, rx1607_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1607_cur
    .local pmc match
    .lex "$/", match
    length rx1607_eos, rx1607_tgt
    gt rx1607_pos, rx1607_eos, rx1607_done
    set rx1607_off, 0
    lt rx1607_pos, 2, rx1607_start
    sub rx1607_off, rx1607_pos, 1
    substr rx1607_tgt, rx1607_tgt, rx1607_off
  rx1607_start:
    eq $I10, 1, rx1607_restart
    if_null rx1607_debug, debug_1123
    rx1607_cur."!cursor_debug"("START", "")
  debug_1123:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1608_done
    goto rxscan1608_scan
  rxscan1608_loop:
    (rx1607_pos) = rx1607_cur."from"()
    inc rx1607_pos
    rx1607_cur."!cursor_from"(rx1607_pos)
    ge rx1607_pos, rx1607_eos, rxscan1608_done
  rxscan1608_scan:
    set_addr $I10, rxscan1608_loop
    rx1607_cur."!mark_push"(0, rx1607_pos, $I10)
  rxscan1608_done:
  # rx literal  "my"
    add $I11, rx1607_pos, 2
    gt $I11, rx1607_eos, rx1607_fail
    sub $I11, rx1607_pos, rx1607_off
    substr $S10, rx1607_tgt, $I11, 2
    ne $S10, "my", rx1607_fail
    add rx1607_pos, 2
  # rx pass
    rx1607_cur."!cursor_pass"(rx1607_pos, "")
    if_null rx1607_debug, debug_1124
    rx1607_cur."!cursor_debug"("PASS", "", " at pos=", rx1607_pos)
  debug_1124:
    .return (rx1607_cur)
  rx1607_restart:
    if_null rx1607_debug, debug_1125
    rx1607_cur."!cursor_debug"("NEXT", "")
  debug_1125:
  rx1607_fail:
    (rx1607_rep, rx1607_pos, $I10, $P10) = rx1607_cur."!mark_fail"(0)
    lt rx1607_pos, -1, rx1607_done
    eq rx1607_pos, -1, rx1607_fail
    jump $I10
  rx1607_done:
    rx1607_cur."!cursor_fail"()
    if_null rx1607_debug, debug_1126
    rx1607_cur."!cursor_debug"("FAIL", "")
  debug_1126:
    .return (rx1607_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "metachar:sym<{ }>"  :subid("380_1298325448.42642") :method :outer("376_1298325448.42642")
.annotate 'line', 658
    .local string rx1610_tgt
    .local int rx1610_pos
    .local int rx1610_off
    .local int rx1610_eos
    .local int rx1610_rep
    .local pmc rx1610_cur
    .local pmc rx1610_debug
    (rx1610_cur, rx1610_pos, rx1610_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1610_cur
    .local pmc match
    .lex "$/", match
    length rx1610_eos, rx1610_tgt
    gt rx1610_pos, rx1610_eos, rx1610_done
    set rx1610_off, 0
    lt rx1610_pos, 2, rx1610_start
    sub rx1610_off, rx1610_pos, 1
    substr rx1610_tgt, rx1610_tgt, rx1610_off
  rx1610_start:
    eq $I10, 1, rx1610_restart
    if_null rx1610_debug, debug_1130
    rx1610_cur."!cursor_debug"("START", "metachar:sym<{ }>")
  debug_1130:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1613_done
    goto rxscan1613_scan
  rxscan1613_loop:
    (rx1610_pos) = rx1610_cur."from"()
    inc rx1610_pos
    rx1610_cur."!cursor_from"(rx1610_pos)
    ge rx1610_pos, rx1610_eos, rxscan1613_done
  rxscan1613_scan:
    set_addr $I10, rxscan1613_loop
    rx1610_cur."!mark_push"(0, rx1610_pos, $I10)
  rxscan1613_done:
.annotate 'line', 664
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1610_pos, rx1610_off
    substr $S10, rx1610_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1610_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx1610_cur."!cursor_pos"(rx1610_pos)
    $P10 = rx1610_cur."codeblock"()
    unless $P10, rx1610_fail
    rx1610_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx1610_pos = $P10."pos"()
.annotate 'line', 663
  # rx pass
    rx1610_cur."!cursor_pass"(rx1610_pos, "metachar:sym<{ }>")
    if_null rx1610_debug, debug_1131
    rx1610_cur."!cursor_debug"("PASS", "metachar:sym<{ }>", " at pos=", rx1610_pos)
  debug_1131:
    .return (rx1610_cur)
  rx1610_restart:
.annotate 'line', 658
    if_null rx1610_debug, debug_1132
    rx1610_cur."!cursor_debug"("NEXT", "metachar:sym<{ }>")
  debug_1132:
  rx1610_fail:
    (rx1610_rep, rx1610_pos, $I10, $P10) = rx1610_cur."!mark_fail"(0)
    lt rx1610_pos, -1, rx1610_done
    eq rx1610_pos, -1, rx1610_fail
    jump $I10
  rx1610_done:
    rx1610_cur."!cursor_fail"()
    if_null rx1610_debug, debug_1133
    rx1610_cur."!cursor_debug"("FAIL", "metachar:sym<{ }>")
  debug_1133:
    .return (rx1610_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<{ }>"  :nsentry("!PREFIX__metachar:sym<{ }>") :subid("381_1298325448.42642") :method
.annotate 'line', 658
    new $P1612, "ResizablePMCArray"
    push $P1612, "{"
    .return ($P1612)
.end


.namespace ["NQP";"Regex"]
.sub "metachar:sym<nqpvar>"  :subid("382_1298325448.42642") :method :outer("376_1298325448.42642")
.annotate 'line', 658
    .const 'Sub' $P1620 = "384_1298325448.42642" 
    capture_lex $P1620
    .local string rx1615_tgt
    .local int rx1615_pos
    .local int rx1615_off
    .local int rx1615_eos
    .local int rx1615_rep
    .local pmc rx1615_cur
    .local pmc rx1615_debug
    (rx1615_cur, rx1615_pos, rx1615_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1615_cur
    .local pmc match
    .lex "$/", match
    length rx1615_eos, rx1615_tgt
    gt rx1615_pos, rx1615_eos, rx1615_done
    set rx1615_off, 0
    lt rx1615_pos, 2, rx1615_start
    sub rx1615_off, rx1615_pos, 1
    substr rx1615_tgt, rx1615_tgt, rx1615_off
  rx1615_start:
    eq $I10, 1, rx1615_restart
    if_null rx1615_debug, debug_1134
    rx1615_cur."!cursor_debug"("START", "metachar:sym<nqpvar>")
  debug_1134:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1618_done
    goto rxscan1618_scan
  rxscan1618_loop:
    (rx1615_pos) = rx1615_cur."from"()
    inc rx1615_pos
    rx1615_cur."!cursor_from"(rx1615_pos)
    ge rx1615_pos, rx1615_eos, rxscan1618_done
  rxscan1618_scan:
    set_addr $I10, rxscan1618_loop
    rx1615_cur."!mark_push"(0, rx1615_pos, $I10)
  rxscan1618_done:
.annotate 'line', 668
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1615_pos, rx1615_off
    substr $S10, rx1615_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx1615_fail
  # rx subrule "before" subtype=zerowidth negate=
    rx1615_cur."!cursor_pos"(rx1615_pos)
    .const 'Sub' $P1620 = "384_1298325448.42642" 
    capture_lex $P1620
    $P10 = rx1615_cur."before"($P1620)
    unless $P10, rx1615_fail
  # rx subrule "LANG" subtype=capture negate=
    rx1615_cur."!cursor_pos"(rx1615_pos)
    $P10 = rx1615_cur."LANG"("MAIN", "variable")
    unless $P10, rx1615_fail
    rx1615_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx1615_pos = $P10."pos"()
.annotate 'line', 667
  # rx pass
    rx1615_cur."!cursor_pass"(rx1615_pos, "metachar:sym<nqpvar>")
    if_null rx1615_debug, debug_1139
    rx1615_cur."!cursor_debug"("PASS", "metachar:sym<nqpvar>", " at pos=", rx1615_pos)
  debug_1139:
    .return (rx1615_cur)
  rx1615_restart:
.annotate 'line', 658
    if_null rx1615_debug, debug_1140
    rx1615_cur."!cursor_debug"("NEXT", "metachar:sym<nqpvar>")
  debug_1140:
  rx1615_fail:
    (rx1615_rep, rx1615_pos, $I10, $P10) = rx1615_cur."!mark_fail"(0)
    lt rx1615_pos, -1, rx1615_done
    eq rx1615_pos, -1, rx1615_fail
    jump $I10
  rx1615_done:
    rx1615_cur."!cursor_fail"()
    if_null rx1615_debug, debug_1141
    rx1615_cur."!cursor_debug"("FAIL", "metachar:sym<nqpvar>")
  debug_1141:
    .return (rx1615_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<nqpvar>"  :nsentry("!PREFIX__metachar:sym<nqpvar>") :subid("383_1298325448.42642") :method
.annotate 'line', 658
    new $P1617, "ResizablePMCArray"
    push $P1617, "$"
    push $P1617, "@"
    .return ($P1617)
.end


.namespace ["NQP";"Regex"]
.sub "_block1619"  :anon :subid("384_1298325448.42642") :method :outer("382_1298325448.42642")
.annotate 'line', 668
    .local string rx1621_tgt
    .local int rx1621_pos
    .local int rx1621_off
    .local int rx1621_eos
    .local int rx1621_rep
    .local pmc rx1621_cur
    .local pmc rx1621_debug
    (rx1621_cur, rx1621_pos, rx1621_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1621_cur
    .local pmc match
    .lex "$/", match
    length rx1621_eos, rx1621_tgt
    gt rx1621_pos, rx1621_eos, rx1621_done
    set rx1621_off, 0
    lt rx1621_pos, 2, rx1621_start
    sub rx1621_off, rx1621_pos, 1
    substr rx1621_tgt, rx1621_tgt, rx1621_off
  rx1621_start:
    eq $I10, 1, rx1621_restart
    if_null rx1621_debug, debug_1135
    rx1621_cur."!cursor_debug"("START", "")
  debug_1135:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1622_done
    goto rxscan1622_scan
  rxscan1622_loop:
    (rx1621_pos) = rx1621_cur."from"()
    inc rx1621_pos
    rx1621_cur."!cursor_from"(rx1621_pos)
    ge rx1621_pos, rx1621_eos, rxscan1622_done
  rxscan1622_scan:
    set_addr $I10, rxscan1622_loop
    rx1621_cur."!mark_push"(0, rx1621_pos, $I10)
  rxscan1622_done:
  # rx charclass .
    ge rx1621_pos, rx1621_eos, rx1621_fail
    inc rx1621_pos
  # rx charclass w
    ge rx1621_pos, rx1621_eos, rx1621_fail
    sub $I10, rx1621_pos, rx1621_off
    is_cclass $I11, 8192, rx1621_tgt, $I10
    unless $I11, rx1621_fail
    inc rx1621_pos
  # rx pass
    rx1621_cur."!cursor_pass"(rx1621_pos, "")
    if_null rx1621_debug, debug_1136
    rx1621_cur."!cursor_debug"("PASS", "", " at pos=", rx1621_pos)
  debug_1136:
    .return (rx1621_cur)
  rx1621_restart:
    if_null rx1621_debug, debug_1137
    rx1621_cur."!cursor_debug"("NEXT", "")
  debug_1137:
  rx1621_fail:
    (rx1621_rep, rx1621_pos, $I10, $P10) = rx1621_cur."!mark_fail"(0)
    lt rx1621_pos, -1, rx1621_done
    eq rx1621_pos, -1, rx1621_fail
    jump $I10
  rx1621_done:
    rx1621_cur."!cursor_fail"()
    if_null rx1621_debug, debug_1138
    rx1621_cur."!cursor_debug"("FAIL", "")
  debug_1138:
    .return (rx1621_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "assertion:sym<{ }>"  :subid("385_1298325448.42642") :method :outer("376_1298325448.42642")
.annotate 'line', 658
    .local string rx1624_tgt
    .local int rx1624_pos
    .local int rx1624_off
    .local int rx1624_eos
    .local int rx1624_rep
    .local pmc rx1624_cur
    .local pmc rx1624_debug
    (rx1624_cur, rx1624_pos, rx1624_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1624_cur
    .local pmc match
    .lex "$/", match
    length rx1624_eos, rx1624_tgt
    gt rx1624_pos, rx1624_eos, rx1624_done
    set rx1624_off, 0
    lt rx1624_pos, 2, rx1624_start
    sub rx1624_off, rx1624_pos, 1
    substr rx1624_tgt, rx1624_tgt, rx1624_off
  rx1624_start:
    eq $I10, 1, rx1624_restart
    if_null rx1624_debug, debug_1142
    rx1624_cur."!cursor_debug"("START", "assertion:sym<{ }>")
  debug_1142:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1627_done
    goto rxscan1627_scan
  rxscan1627_loop:
    (rx1624_pos) = rx1624_cur."from"()
    inc rx1624_pos
    rx1624_cur."!cursor_from"(rx1624_pos)
    ge rx1624_pos, rx1624_eos, rxscan1627_done
  rxscan1627_scan:
    set_addr $I10, rxscan1627_loop
    rx1624_cur."!mark_push"(0, rx1624_pos, $I10)
  rxscan1627_done:
.annotate 'line', 672
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1624_pos, rx1624_off
    substr $S10, rx1624_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1624_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx1624_cur."!cursor_pos"(rx1624_pos)
    $P10 = rx1624_cur."codeblock"()
    unless $P10, rx1624_fail
    rx1624_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx1624_pos = $P10."pos"()
.annotate 'line', 671
  # rx pass
    rx1624_cur."!cursor_pass"(rx1624_pos, "assertion:sym<{ }>")
    if_null rx1624_debug, debug_1143
    rx1624_cur."!cursor_debug"("PASS", "assertion:sym<{ }>", " at pos=", rx1624_pos)
  debug_1143:
    .return (rx1624_cur)
  rx1624_restart:
.annotate 'line', 658
    if_null rx1624_debug, debug_1144
    rx1624_cur."!cursor_debug"("NEXT", "assertion:sym<{ }>")
  debug_1144:
  rx1624_fail:
    (rx1624_rep, rx1624_pos, $I10, $P10) = rx1624_cur."!mark_fail"(0)
    lt rx1624_pos, -1, rx1624_done
    eq rx1624_pos, -1, rx1624_fail
    jump $I10
  rx1624_done:
    rx1624_cur."!cursor_fail"()
    if_null rx1624_debug, debug_1145
    rx1624_cur."!cursor_debug"("FAIL", "assertion:sym<{ }>")
  debug_1145:
    .return (rx1624_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<{ }>"  :nsentry("!PREFIX__assertion:sym<{ }>") :subid("386_1298325448.42642") :method
.annotate 'line', 658
    new $P1626, "ResizablePMCArray"
    push $P1626, "{"
    .return ($P1626)
.end


.namespace ["NQP";"Regex"]
.sub "assertion:sym<?{ }>"  :subid("387_1298325448.42642") :method :outer("376_1298325448.42642")
.annotate 'line', 658
    .const 'Sub' $P1634 = "389_1298325448.42642" 
    capture_lex $P1634
    .local string rx1629_tgt
    .local int rx1629_pos
    .local int rx1629_off
    .local int rx1629_eos
    .local int rx1629_rep
    .local pmc rx1629_cur
    .local pmc rx1629_debug
    (rx1629_cur, rx1629_pos, rx1629_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1629_cur
    .local pmc match
    .lex "$/", match
    length rx1629_eos, rx1629_tgt
    gt rx1629_pos, rx1629_eos, rx1629_done
    set rx1629_off, 0
    lt rx1629_pos, 2, rx1629_start
    sub rx1629_off, rx1629_pos, 1
    substr rx1629_tgt, rx1629_tgt, rx1629_off
  rx1629_start:
    eq $I10, 1, rx1629_restart
    if_null rx1629_debug, debug_1146
    rx1629_cur."!cursor_debug"("START", "assertion:sym<?{ }>")
  debug_1146:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1632_done
    goto rxscan1632_scan
  rxscan1632_loop:
    (rx1629_pos) = rx1629_cur."from"()
    inc rx1629_pos
    rx1629_cur."!cursor_from"(rx1629_pos)
    ge rx1629_pos, rx1629_eos, rxscan1632_done
  rxscan1632_scan:
    set_addr $I10, rxscan1632_loop
    rx1629_cur."!mark_push"(0, rx1629_pos, $I10)
  rxscan1632_done:
.annotate 'line', 676
  # rx subcapture "zw"
    set_addr $I10, rxcap_1637_fail
    rx1629_cur."!mark_push"(0, rx1629_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1629_pos, rx1629_eos, rx1629_fail
    sub $I10, rx1629_pos, rx1629_off
    substr $S10, rx1629_tgt, $I10, 1
    index $I11, "?!", $S10
    lt $I11, 0, rx1629_fail
    inc rx1629_pos
  # rx subrule "before" subtype=zerowidth negate=
    rx1629_cur."!cursor_pos"(rx1629_pos)
    .const 'Sub' $P1634 = "389_1298325448.42642" 
    capture_lex $P1634
    $P10 = rx1629_cur."before"($P1634)
    unless $P10, rx1629_fail
    set_addr $I10, rxcap_1637_fail
    ($I12, $I11) = rx1629_cur."!mark_peek"($I10)
    rx1629_cur."!cursor_pos"($I11)
    ($P10) = rx1629_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1629_pos, "")
    rx1629_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("zw")
    goto rxcap_1637_done
  rxcap_1637_fail:
    goto rx1629_fail
  rxcap_1637_done:
  # rx subrule "codeblock" subtype=capture negate=
    rx1629_cur."!cursor_pos"(rx1629_pos)
    $P10 = rx1629_cur."codeblock"()
    unless $P10, rx1629_fail
    rx1629_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx1629_pos = $P10."pos"()
.annotate 'line', 675
  # rx pass
    rx1629_cur."!cursor_pass"(rx1629_pos, "assertion:sym<?{ }>")
    if_null rx1629_debug, debug_1151
    rx1629_cur."!cursor_debug"("PASS", "assertion:sym<?{ }>", " at pos=", rx1629_pos)
  debug_1151:
    .return (rx1629_cur)
  rx1629_restart:
.annotate 'line', 658
    if_null rx1629_debug, debug_1152
    rx1629_cur."!cursor_debug"("NEXT", "assertion:sym<?{ }>")
  debug_1152:
  rx1629_fail:
    (rx1629_rep, rx1629_pos, $I10, $P10) = rx1629_cur."!mark_fail"(0)
    lt rx1629_pos, -1, rx1629_done
    eq rx1629_pos, -1, rx1629_fail
    jump $I10
  rx1629_done:
    rx1629_cur."!cursor_fail"()
    if_null rx1629_debug, debug_1153
    rx1629_cur."!cursor_debug"("FAIL", "assertion:sym<?{ }>")
  debug_1153:
    .return (rx1629_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<?{ }>"  :nsentry("!PREFIX__assertion:sym<?{ }>") :subid("388_1298325448.42642") :method
.annotate 'line', 658
    new $P1631, "ResizablePMCArray"
    push $P1631, "!"
    push $P1631, "?"
    .return ($P1631)
.end


.namespace ["NQP";"Regex"]
.sub "_block1633"  :anon :subid("389_1298325448.42642") :method :outer("387_1298325448.42642")
.annotate 'line', 676
    .local string rx1635_tgt
    .local int rx1635_pos
    .local int rx1635_off
    .local int rx1635_eos
    .local int rx1635_rep
    .local pmc rx1635_cur
    .local pmc rx1635_debug
    (rx1635_cur, rx1635_pos, rx1635_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1635_cur
    .local pmc match
    .lex "$/", match
    length rx1635_eos, rx1635_tgt
    gt rx1635_pos, rx1635_eos, rx1635_done
    set rx1635_off, 0
    lt rx1635_pos, 2, rx1635_start
    sub rx1635_off, rx1635_pos, 1
    substr rx1635_tgt, rx1635_tgt, rx1635_off
  rx1635_start:
    eq $I10, 1, rx1635_restart
    if_null rx1635_debug, debug_1147
    rx1635_cur."!cursor_debug"("START", "")
  debug_1147:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1636_done
    goto rxscan1636_scan
  rxscan1636_loop:
    (rx1635_pos) = rx1635_cur."from"()
    inc rx1635_pos
    rx1635_cur."!cursor_from"(rx1635_pos)
    ge rx1635_pos, rx1635_eos, rxscan1636_done
  rxscan1636_scan:
    set_addr $I10, rxscan1636_loop
    rx1635_cur."!mark_push"(0, rx1635_pos, $I10)
  rxscan1636_done:
  # rx literal  "{"
    add $I11, rx1635_pos, 1
    gt $I11, rx1635_eos, rx1635_fail
    sub $I11, rx1635_pos, rx1635_off
    ord $I11, rx1635_tgt, $I11
    ne $I11, 123, rx1635_fail
    add rx1635_pos, 1
  # rx pass
    rx1635_cur."!cursor_pass"(rx1635_pos, "")
    if_null rx1635_debug, debug_1148
    rx1635_cur."!cursor_debug"("PASS", "", " at pos=", rx1635_pos)
  debug_1148:
    .return (rx1635_cur)
  rx1635_restart:
    if_null rx1635_debug, debug_1149
    rx1635_cur."!cursor_debug"("NEXT", "")
  debug_1149:
  rx1635_fail:
    (rx1635_rep, rx1635_pos, $I10, $P10) = rx1635_cur."!mark_fail"(0)
    lt rx1635_pos, -1, rx1635_done
    eq rx1635_pos, -1, rx1635_fail
    jump $I10
  rx1635_done:
    rx1635_cur."!cursor_fail"()
    if_null rx1635_debug, debug_1150
    rx1635_cur."!cursor_debug"("FAIL", "")
  debug_1150:
    .return (rx1635_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "assertion:sym<name>"  :subid("390_1298325448.42642") :method :outer("376_1298325448.42642")
.annotate 'line', 658
    .const 'Sub' $P1647 = "392_1298325448.42642" 
    capture_lex $P1647
    .local string rx1639_tgt
    .local int rx1639_pos
    .local int rx1639_off
    .local int rx1639_eos
    .local int rx1639_rep
    .local pmc rx1639_cur
    .local pmc rx1639_debug
    (rx1639_cur, rx1639_pos, rx1639_tgt, $I10) = self."!cursor_start"()
    rx1639_cur."!cursor_caparray"("assertion", "arglist", "nibbler")
    .lex unicode:"$\x{a2}", rx1639_cur
    .local pmc match
    .lex "$/", match
    length rx1639_eos, rx1639_tgt
    gt rx1639_pos, rx1639_eos, rx1639_done
    set rx1639_off, 0
    lt rx1639_pos, 2, rx1639_start
    sub rx1639_off, rx1639_pos, 1
    substr rx1639_tgt, rx1639_tgt, rx1639_off
  rx1639_start:
    eq $I10, 1, rx1639_restart
    if_null rx1639_debug, debug_1154
    rx1639_cur."!cursor_debug"("START", "assertion:sym<name>")
  debug_1154:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1643_done
    goto rxscan1643_scan
  rxscan1643_loop:
    (rx1639_pos) = rx1639_cur."from"()
    inc rx1639_pos
    rx1639_cur."!cursor_from"(rx1639_pos)
    ge rx1639_pos, rx1639_eos, rxscan1643_done
  rxscan1643_scan:
    set_addr $I10, rxscan1643_loop
    rx1639_cur."!mark_push"(0, rx1639_pos, $I10)
  rxscan1643_done:
.annotate 'line', 680
  # rx subrule "identifier" subtype=capture negate=
    rx1639_cur."!cursor_pos"(rx1639_pos)
    $P10 = rx1639_cur."identifier"()
    unless $P10, rx1639_fail
    rx1639_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx1639_pos = $P10."pos"()
.annotate 'line', 687
  # rx rxquantr1644 ** 0..1
    set_addr $I10, rxquantr1644_done
    rx1639_cur."!mark_push"(0, rx1639_pos, $I10)
  rxquantr1644_loop:
  alt1645_0:
.annotate 'line', 681
    set_addr $I10, alt1645_1
    rx1639_cur."!mark_push"(0, rx1639_pos, $I10)
.annotate 'line', 682
  # rx subrule "before" subtype=zerowidth negate=
    rx1639_cur."!cursor_pos"(rx1639_pos)
    .const 'Sub' $P1647 = "392_1298325448.42642" 
    capture_lex $P1647
    $P10 = rx1639_cur."before"($P1647)
    unless $P10, rx1639_fail
    goto alt1645_end
  alt1645_1:
    set_addr $I10, alt1645_2
    rx1639_cur."!mark_push"(0, rx1639_pos, $I10)
.annotate 'line', 683
  # rx literal  "="
    add $I11, rx1639_pos, 1
    gt $I11, rx1639_eos, rx1639_fail
    sub $I11, rx1639_pos, rx1639_off
    ord $I11, rx1639_tgt, $I11
    ne $I11, 61, rx1639_fail
    add rx1639_pos, 1
  # rx subrule "assertion" subtype=capture negate=
    rx1639_cur."!cursor_pos"(rx1639_pos)
    $P10 = rx1639_cur."assertion"()
    unless $P10, rx1639_fail
    rx1639_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("assertion")
    rx1639_pos = $P10."pos"()
    goto alt1645_end
  alt1645_2:
    set_addr $I10, alt1645_3
    rx1639_cur."!mark_push"(0, rx1639_pos, $I10)
.annotate 'line', 684
  # rx literal  ":"
    add $I11, rx1639_pos, 1
    gt $I11, rx1639_eos, rx1639_fail
    sub $I11, rx1639_pos, rx1639_off
    ord $I11, rx1639_tgt, $I11
    ne $I11, 58, rx1639_fail
    add rx1639_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx1639_cur."!cursor_pos"(rx1639_pos)
    $P10 = rx1639_cur."arglist"()
    unless $P10, rx1639_fail
    rx1639_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1639_pos = $P10."pos"()
    goto alt1645_end
  alt1645_3:
    set_addr $I10, alt1645_4
    rx1639_cur."!mark_push"(0, rx1639_pos, $I10)
.annotate 'line', 685
  # rx literal  "("
    add $I11, rx1639_pos, 1
    gt $I11, rx1639_eos, rx1639_fail
    sub $I11, rx1639_pos, rx1639_off
    ord $I11, rx1639_tgt, $I11
    ne $I11, 40, rx1639_fail
    add rx1639_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx1639_cur."!cursor_pos"(rx1639_pos)
    $P10 = rx1639_cur."LANG"("MAIN", "arglist")
    unless $P10, rx1639_fail
    rx1639_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1639_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1639_pos, 1
    gt $I11, rx1639_eos, rx1639_fail
    sub $I11, rx1639_pos, rx1639_off
    ord $I11, rx1639_tgt, $I11
    ne $I11, 41, rx1639_fail
    add rx1639_pos, 1
    goto alt1645_end
  alt1645_4:
.annotate 'line', 686
  # rx subrule "normspace" subtype=method negate=
    rx1639_cur."!cursor_pos"(rx1639_pos)
    $P10 = rx1639_cur."normspace"()
    unless $P10, rx1639_fail
    rx1639_pos = $P10."pos"()
  # rx subrule "nibbler" subtype=capture negate=
    rx1639_cur."!cursor_pos"(rx1639_pos)
    $P10 = rx1639_cur."nibbler"()
    unless $P10, rx1639_fail
    rx1639_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("nibbler")
    rx1639_pos = $P10."pos"()
  alt1645_end:
.annotate 'line', 687
    set_addr $I10, rxquantr1644_done
    (rx1639_rep) = rx1639_cur."!mark_commit"($I10)
  rxquantr1644_done:
.annotate 'line', 679
  # rx pass
    rx1639_cur."!cursor_pass"(rx1639_pos, "assertion:sym<name>")
    if_null rx1639_debug, debug_1159
    rx1639_cur."!cursor_debug"("PASS", "assertion:sym<name>", " at pos=", rx1639_pos)
  debug_1159:
    .return (rx1639_cur)
  rx1639_restart:
.annotate 'line', 658
    if_null rx1639_debug, debug_1160
    rx1639_cur."!cursor_debug"("NEXT", "assertion:sym<name>")
  debug_1160:
  rx1639_fail:
    (rx1639_rep, rx1639_pos, $I10, $P10) = rx1639_cur."!mark_fail"(0)
    lt rx1639_pos, -1, rx1639_done
    eq rx1639_pos, -1, rx1639_fail
    jump $I10
  rx1639_done:
    rx1639_cur."!cursor_fail"()
    if_null rx1639_debug, debug_1161
    rx1639_cur."!cursor_debug"("FAIL", "assertion:sym<name>")
  debug_1161:
    .return (rx1639_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<name>"  :nsentry("!PREFIX__assertion:sym<name>") :subid("391_1298325448.42642") :method
.annotate 'line', 658
    $P1641 = self."!PREFIX__!subrule"("identifier", "")
    new $P1642, "ResizablePMCArray"
    push $P1642, $P1641
    .return ($P1642)
.end


.namespace ["NQP";"Regex"]
.sub "_block1646"  :anon :subid("392_1298325448.42642") :method :outer("390_1298325448.42642")
.annotate 'line', 682
    .local string rx1648_tgt
    .local int rx1648_pos
    .local int rx1648_off
    .local int rx1648_eos
    .local int rx1648_rep
    .local pmc rx1648_cur
    .local pmc rx1648_debug
    (rx1648_cur, rx1648_pos, rx1648_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1648_cur
    .local pmc match
    .lex "$/", match
    length rx1648_eos, rx1648_tgt
    gt rx1648_pos, rx1648_eos, rx1648_done
    set rx1648_off, 0
    lt rx1648_pos, 2, rx1648_start
    sub rx1648_off, rx1648_pos, 1
    substr rx1648_tgt, rx1648_tgt, rx1648_off
  rx1648_start:
    eq $I10, 1, rx1648_restart
    if_null rx1648_debug, debug_1155
    rx1648_cur."!cursor_debug"("START", "")
  debug_1155:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1649_done
    goto rxscan1649_scan
  rxscan1649_loop:
    (rx1648_pos) = rx1648_cur."from"()
    inc rx1648_pos
    rx1648_cur."!cursor_from"(rx1648_pos)
    ge rx1648_pos, rx1648_eos, rxscan1649_done
  rxscan1649_scan:
    set_addr $I10, rxscan1649_loop
    rx1648_cur."!mark_push"(0, rx1648_pos, $I10)
  rxscan1649_done:
  # rx literal  ">"
    add $I11, rx1648_pos, 1
    gt $I11, rx1648_eos, rx1648_fail
    sub $I11, rx1648_pos, rx1648_off
    ord $I11, rx1648_tgt, $I11
    ne $I11, 62, rx1648_fail
    add rx1648_pos, 1
  # rx pass
    rx1648_cur."!cursor_pass"(rx1648_pos, "")
    if_null rx1648_debug, debug_1156
    rx1648_cur."!cursor_debug"("PASS", "", " at pos=", rx1648_pos)
  debug_1156:
    .return (rx1648_cur)
  rx1648_restart:
    if_null rx1648_debug, debug_1157
    rx1648_cur."!cursor_debug"("NEXT", "")
  debug_1157:
  rx1648_fail:
    (rx1648_rep, rx1648_pos, $I10, $P10) = rx1648_cur."!mark_fail"(0)
    lt rx1648_pos, -1, rx1648_done
    eq rx1648_pos, -1, rx1648_fail
    jump $I10
  rx1648_done:
    rx1648_cur."!cursor_fail"()
    if_null rx1648_debug, debug_1158
    rx1648_cur."!cursor_debug"("FAIL", "")
  debug_1158:
    .return (rx1648_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "assertion:sym<var>"  :subid("393_1298325448.42642") :method :outer("376_1298325448.42642")
.annotate 'line', 658
    .local string rx1651_tgt
    .local int rx1651_pos
    .local int rx1651_off
    .local int rx1651_eos
    .local int rx1651_rep
    .local pmc rx1651_cur
    .local pmc rx1651_debug
    (rx1651_cur, rx1651_pos, rx1651_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1651_cur
    .local pmc match
    .lex "$/", match
    length rx1651_eos, rx1651_tgt
    gt rx1651_pos, rx1651_eos, rx1651_done
    set rx1651_off, 0
    lt rx1651_pos, 2, rx1651_start
    sub rx1651_off, rx1651_pos, 1
    substr rx1651_tgt, rx1651_tgt, rx1651_off
  rx1651_start:
    eq $I10, 1, rx1651_restart
    if_null rx1651_debug, debug_1162
    rx1651_cur."!cursor_debug"("START", "assertion:sym<var>")
  debug_1162:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1654_done
    goto rxscan1654_scan
  rxscan1654_loop:
    (rx1651_pos) = rx1651_cur."from"()
    inc rx1651_pos
    rx1651_cur."!cursor_from"(rx1651_pos)
    ge rx1651_pos, rx1651_eos, rxscan1654_done
  rxscan1654_scan:
    set_addr $I10, rxscan1654_loop
    rx1651_cur."!mark_push"(0, rx1651_pos, $I10)
  rxscan1654_done:
.annotate 'line', 691
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1651_pos, rx1651_off
    substr $S10, rx1651_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx1651_fail
  # rx subrule "LANG" subtype=capture negate=
    rx1651_cur."!cursor_pos"(rx1651_pos)
    $P10 = rx1651_cur."LANG"("MAIN", "variable")
    unless $P10, rx1651_fail
    rx1651_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx1651_pos = $P10."pos"()
.annotate 'line', 690
  # rx pass
    rx1651_cur."!cursor_pass"(rx1651_pos, "assertion:sym<var>")
    if_null rx1651_debug, debug_1163
    rx1651_cur."!cursor_debug"("PASS", "assertion:sym<var>", " at pos=", rx1651_pos)
  debug_1163:
    .return (rx1651_cur)
  rx1651_restart:
.annotate 'line', 658
    if_null rx1651_debug, debug_1164
    rx1651_cur."!cursor_debug"("NEXT", "assertion:sym<var>")
  debug_1164:
  rx1651_fail:
    (rx1651_rep, rx1651_pos, $I10, $P10) = rx1651_cur."!mark_fail"(0)
    lt rx1651_pos, -1, rx1651_done
    eq rx1651_pos, -1, rx1651_fail
    jump $I10
  rx1651_done:
    rx1651_cur."!cursor_fail"()
    if_null rx1651_debug, debug_1165
    rx1651_cur."!cursor_debug"("FAIL", "assertion:sym<var>")
  debug_1165:
    .return (rx1651_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<var>"  :nsentry("!PREFIX__assertion:sym<var>") :subid("394_1298325448.42642") :method
.annotate 'line', 658
    new $P1653, "ResizablePMCArray"
    push $P1653, "$"
    push $P1653, "@"
    .return ($P1653)
.end


.namespace ["NQP";"Regex"]
.sub "codeblock"  :subid("395_1298325448.42642") :method :outer("376_1298325448.42642")
.annotate 'line', 658
    .local string rx1656_tgt
    .local int rx1656_pos
    .local int rx1656_off
    .local int rx1656_eos
    .local int rx1656_rep
    .local pmc rx1656_cur
    .local pmc rx1656_debug
    (rx1656_cur, rx1656_pos, rx1656_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1656_cur
    .local pmc match
    .lex "$/", match
    length rx1656_eos, rx1656_tgt
    gt rx1656_pos, rx1656_eos, rx1656_done
    set rx1656_off, 0
    lt rx1656_pos, 2, rx1656_start
    sub rx1656_off, rx1656_pos, 1
    substr rx1656_tgt, rx1656_tgt, rx1656_off
  rx1656_start:
    eq $I10, 1, rx1656_restart
    if_null rx1656_debug, debug_1166
    rx1656_cur."!cursor_debug"("START", "codeblock")
  debug_1166:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1660_done
    goto rxscan1660_scan
  rxscan1660_loop:
    (rx1656_pos) = rx1656_cur."from"()
    inc rx1656_pos
    rx1656_cur."!cursor_from"(rx1656_pos)
    ge rx1656_pos, rx1656_eos, rxscan1660_done
  rxscan1660_scan:
    set_addr $I10, rxscan1660_loop
    rx1656_cur."!mark_push"(0, rx1656_pos, $I10)
  rxscan1660_done:
.annotate 'line', 695
  # rx subrule "LANG" subtype=capture negate=
    rx1656_cur."!cursor_pos"(rx1656_pos)
    $P10 = rx1656_cur."LANG"("MAIN", "pblock")
    unless $P10, rx1656_fail
    rx1656_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1656_pos = $P10."pos"()
.annotate 'line', 694
  # rx pass
    rx1656_cur."!cursor_pass"(rx1656_pos, "codeblock")
    if_null rx1656_debug, debug_1167
    rx1656_cur."!cursor_debug"("PASS", "codeblock", " at pos=", rx1656_pos)
  debug_1167:
    .return (rx1656_cur)
  rx1656_restart:
.annotate 'line', 658
    if_null rx1656_debug, debug_1168
    rx1656_cur."!cursor_debug"("NEXT", "codeblock")
  debug_1168:
  rx1656_fail:
    (rx1656_rep, rx1656_pos, $I10, $P10) = rx1656_cur."!mark_fail"(0)
    lt rx1656_pos, -1, rx1656_done
    eq rx1656_pos, -1, rx1656_fail
    jump $I10
  rx1656_done:
    rx1656_cur."!cursor_fail"()
    if_null rx1656_debug, debug_1169
    rx1656_cur."!cursor_debug"("FAIL", "codeblock")
  debug_1169:
    .return (rx1656_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "!PREFIX__codeblock"  :nsentry("!PREFIX__codeblock") :subid("396_1298325448.42642") :method
.annotate 'line', 658
    $P1658 = self."!PREFIX__!subrule"("LANG", "")
    new $P1659, "ResizablePMCArray"
    push $P1659, $P1658
    .return ($P1659)
.end


.namespace ["NQP";"Grammar"]
.sub "_block1702" :load :anon :subid("398_1298325448.42642")
.annotate 'line', 4
    .const 'Sub' $P1704 = "11_1298325448.42642" 
    $P1705 = $P1704()
    .return ($P1705)
.end


.namespace []
.sub "_block2419" :load :anon :subid("400_1298325448.42642")
.annotate 'line', 1
    .const 'Sub' $P2421 = "10_1298325448.42642" 
    $P2422 = $P2421()
    .return ($P2422)
.end

### .include 'gen/nqp-actions.pir'

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1298325483.2958")
.annotate 'line', 0
    get_hll_global $P15, ["NQP";"Actions"], "_block14" 
    capture_lex $P15
.annotate 'line', 1
    nqp_dynop_setup 
    get_hll_global $P13, ["NQP"], "Actions"
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
.annotate 'line', 3
    get_hll_global $P15, ["NQP";"Actions"], "_block14" 
    capture_lex $P15
    $P3212 = $P15()
.annotate 'line', 1
    .return ($P3212)
    .const 'Sub' $P3214 = "168_1298325483.2958" 
    .return ($P3214)
.end


.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace ["NQP";"Actions"]
.sub "_block14"  :subid("11_1298325483.2958") :outer("10_1298325483.2958")
.annotate 'line', 3
    .const 'Sub' $P2993 = "167_1298325483.2958" 
    capture_lex $P2993
    get_hll_global $P2867, ["NQP";"RegexActions"], "_block2866" 
    capture_lex $P2867
    .const 'Sub' $P2858 = "156_1298325483.2958" 
    capture_lex $P2858
    .const 'Sub' $P2853 = "155_1298325483.2958" 
    capture_lex $P2853
    .const 'Sub' $P2848 = "154_1298325483.2958" 
    capture_lex $P2848
    .const 'Sub' $P2843 = "153_1298325483.2958" 
    capture_lex $P2843
    .const 'Sub' $P2832 = "152_1298325483.2958" 
    capture_lex $P2832
    .const 'Sub' $P2824 = "151_1298325483.2958" 
    capture_lex $P2824
    .const 'Sub' $P2816 = "150_1298325483.2958" 
    capture_lex $P2816
    .const 'Sub' $P2808 = "149_1298325483.2958" 
    capture_lex $P2808
    .const 'Sub' $P2803 = "148_1298325483.2958" 
    capture_lex $P2803
    .const 'Sub' $P2791 = "147_1298325483.2958" 
    capture_lex $P2791
    .const 'Sub' $P2783 = "146_1298325483.2958" 
    capture_lex $P2783
    .const 'Sub' $P2745 = "145_1298325483.2958" 
    capture_lex $P2745
    .const 'Sub' $P2733 = "144_1298325483.2958" 
    capture_lex $P2733
    .const 'Sub' $P2725 = "143_1298325483.2958" 
    capture_lex $P2725
    .const 'Sub' $P2717 = "142_1298325483.2958" 
    capture_lex $P2717
    .const 'Sub' $P2709 = "141_1298325483.2958" 
    capture_lex $P2709
    .const 'Sub' $P2701 = "140_1298325483.2958" 
    capture_lex $P2701
    .const 'Sub' $P2693 = "139_1298325483.2958" 
    capture_lex $P2693
    .const 'Sub' $P2667 = "138_1298325483.2958" 
    capture_lex $P2667
    .const 'Sub' $P2652 = "137_1298325483.2958" 
    capture_lex $P2652
    .const 'Sub' $P2644 = "136_1298325483.2958" 
    capture_lex $P2644
    .const 'Sub' $P2633 = "135_1298325483.2958" 
    capture_lex $P2633
    .const 'Sub' $P2622 = "134_1298325483.2958" 
    capture_lex $P2622
    .const 'Sub' $P2611 = "133_1298325483.2958" 
    capture_lex $P2611
    .const 'Sub' $P2603 = "132_1298325483.2958" 
    capture_lex $P2603
    .const 'Sub' $P2576 = "131_1298325483.2958" 
    capture_lex $P2576
    .const 'Sub' $P2554 = "130_1298325483.2958" 
    capture_lex $P2554
    .const 'Sub' $P2546 = "129_1298325483.2958" 
    capture_lex $P2546
    .const 'Sub' $P2538 = "128_1298325483.2958" 
    capture_lex $P2538
    .const 'Sub' $P2513 = "127_1298325483.2958" 
    capture_lex $P2513
    .const 'Sub' $P2497 = "126_1298325483.2958" 
    capture_lex $P2497
    .const 'Sub' $P2489 = "125_1298325483.2958" 
    capture_lex $P2489
    .const 'Sub' $P2481 = "124_1298325483.2958" 
    capture_lex $P2481
    .const 'Sub' $P2379 = "121_1298325483.2958" 
    capture_lex $P2379
    .const 'Sub' $P2371 = "120_1298325483.2958" 
    capture_lex $P2371
    .const 'Sub' $P2364 = "119_1298325483.2958" 
    capture_lex $P2364
    .const 'Sub' $P2337 = "118_1298325483.2958" 
    capture_lex $P2337
    .const 'Sub' $P2297 = "117_1298325483.2958" 
    capture_lex $P2297
    .const 'Sub' $P2283 = "116_1298325483.2958" 
    capture_lex $P2283
    .const 'Sub' $P2276 = "115_1298325483.2958" 
    capture_lex $P2276
    .const 'Sub' $P2232 = "114_1298325483.2958" 
    capture_lex $P2232
    .const 'Sub' $P2067 = "110_1298325483.2958" 
    capture_lex $P2067
    .const 'Sub' $P2004 = "108_1298325483.2958" 
    capture_lex $P2004
    .const 'Sub' $P1996 = "107_1298325483.2958" 
    capture_lex $P1996
    .const 'Sub' $P1981 = "106_1298325483.2958" 
    capture_lex $P1981
    .const 'Sub' $P1966 = "105_1298325483.2958" 
    capture_lex $P1966
    .const 'Sub' $P1948 = "104_1298325483.2958" 
    capture_lex $P1948
    .const 'Sub' $P1849 = "103_1298325483.2958" 
    capture_lex $P1849
    .const 'Sub' $P1805 = "100_1298325483.2958" 
    capture_lex $P1805
    .const 'Sub' $P1680 = "97_1298325483.2958" 
    capture_lex $P1680
    .const 'Sub' $P1438 = "90_1298325483.2958" 
    capture_lex $P1438
    .const 'Sub' $P1430 = "89_1298325483.2958" 
    capture_lex $P1430
    .const 'Sub' $P1422 = "88_1298325483.2958" 
    capture_lex $P1422
    .const 'Sub' $P1321 = "84_1298325483.2958" 
    capture_lex $P1321
    .const 'Sub' $P1313 = "83_1298325483.2958" 
    capture_lex $P1313
    .const 'Sub' $P1298 = "82_1298325483.2958" 
    capture_lex $P1298
    .const 'Sub' $P1283 = "81_1298325483.2958" 
    capture_lex $P1283
    .const 'Sub' $P1268 = "80_1298325483.2958" 
    capture_lex $P1268
    .const 'Sub' $P1253 = "79_1298325483.2958" 
    capture_lex $P1253
    .const 'Sub' $P1245 = "78_1298325483.2958" 
    capture_lex $P1245
    .const 'Sub' $P1237 = "77_1298325483.2958" 
    capture_lex $P1237
    .const 'Sub' $P1229 = "76_1298325483.2958" 
    capture_lex $P1229
    .const 'Sub' $P1015 = "72_1298325483.2958" 
    capture_lex $P1015
    .const 'Sub' $P1007 = "71_1298325483.2958" 
    capture_lex $P1007
    .const 'Sub' $P999 = "70_1298325483.2958" 
    capture_lex $P999
    .const 'Sub' $P991 = "69_1298325483.2958" 
    capture_lex $P991
    .const 'Sub' $P983 = "68_1298325483.2958" 
    capture_lex $P983
    .const 'Sub' $P975 = "67_1298325483.2958" 
    capture_lex $P975
    .const 'Sub' $P967 = "66_1298325483.2958" 
    capture_lex $P967
    .const 'Sub' $P877 = "64_1298325483.2958" 
    capture_lex $P877
    .const 'Sub' $P853 = "63_1298325483.2958" 
    capture_lex $P853
    .const 'Sub' $P839 = "62_1298325483.2958" 
    capture_lex $P839
    .const 'Sub' $P831 = "61_1298325483.2958" 
    capture_lex $P831
    .const 'Sub' $P823 = "60_1298325483.2958" 
    capture_lex $P823
    .const 'Sub' $P815 = "59_1298325483.2958" 
    capture_lex $P815
    .const 'Sub' $P807 = "58_1298325483.2958" 
    capture_lex $P807
    .const 'Sub' $P799 = "57_1298325483.2958" 
    capture_lex $P799
    .const 'Sub' $P791 = "56_1298325483.2958" 
    capture_lex $P791
    .const 'Sub' $P783 = "55_1298325483.2958" 
    capture_lex $P783
    .const 'Sub' $P775 = "54_1298325483.2958" 
    capture_lex $P775
    .const 'Sub' $P767 = "53_1298325483.2958" 
    capture_lex $P767
    .const 'Sub' $P759 = "52_1298325483.2958" 
    capture_lex $P759
    .const 'Sub' $P751 = "51_1298325483.2958" 
    capture_lex $P751
    .const 'Sub' $P743 = "50_1298325483.2958" 
    capture_lex $P743
    .const 'Sub' $P735 = "49_1298325483.2958" 
    capture_lex $P735
    .const 'Sub' $P719 = "48_1298325483.2958" 
    capture_lex $P719
    .const 'Sub' $P686 = "47_1298325483.2958" 
    capture_lex $P686
    .const 'Sub' $P672 = "46_1298325483.2958" 
    capture_lex $P672
    .const 'Sub' $P653 = "45_1298325483.2958" 
    capture_lex $P653
    .const 'Sub' $P635 = "44_1298325483.2958" 
    capture_lex $P635
    .const 'Sub' $P611 = "43_1298325483.2958" 
    capture_lex $P611
    .const 'Sub' $P577 = "42_1298325483.2958" 
    capture_lex $P577
    .const 'Sub' $P562 = "41_1298325483.2958" 
    capture_lex $P562
    .const 'Sub' $P550 = "40_1298325483.2958" 
    capture_lex $P550
    .const 'Sub' $P499 = "38_1298325483.2958" 
    capture_lex $P499
    .const 'Sub' $P490 = "37_1298325483.2958" 
    capture_lex $P490
    .const 'Sub' $P479 = "36_1298325483.2958" 
    capture_lex $P479
    .const 'Sub' $P461 = "35_1298325483.2958" 
    capture_lex $P461
    .const 'Sub' $P453 = "34_1298325483.2958" 
    capture_lex $P453
    .const 'Sub' $P445 = "33_1298325483.2958" 
    capture_lex $P445
    .const 'Sub' $P431 = "32_1298325483.2958" 
    capture_lex $P431
    .const 'Sub' $P350 = "30_1298325483.2958" 
    capture_lex $P350
    .const 'Sub' $P309 = "28_1298325483.2958" 
    capture_lex $P309
    .const 'Sub' $P275 = "27_1298325483.2958" 
    capture_lex $P275
    .const 'Sub' $P244 = "26_1298325483.2958" 
    capture_lex $P244
    .const 'Sub' $P236 = "25_1298325483.2958" 
    capture_lex $P236
    .const 'Sub' $P228 = "23_1298325483.2958" 
    capture_lex $P228
    .const 'Sub' $P214 = "22_1298325483.2958" 
    capture_lex $P214
    .const 'Sub' $P149 = "20_1298325483.2958" 
    capture_lex $P149
    .const 'Sub' $P139 = "19_1298325483.2958" 
    capture_lex $P139
    .const 'Sub' $P91 = "18_1298325483.2958" 
    capture_lex $P91
    .const 'Sub' $P78 = "17_1298325483.2958" 
    capture_lex $P78
    .const 'Sub' $P60 = "16_1298325483.2958" 
    capture_lex $P60
    .const 'Sub' $P27 = "13_1298325483.2958" 
    capture_lex $P27
    .const 'Sub' $P19 = "12_1298325483.2958" 
    capture_lex $P19
    get_global $P16, "$?CLASS"
    nqp_dynop_setup 
    get_hll_global $P17, ["NQP"], "RegexActions"
    get_global $P18, "@BLOCK"
    unless_null $P18, vivify_170
    $P18 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P18
  vivify_170:
.annotate 'line', 9
    .const 'Sub' $P19 = "12_1298325483.2958" 
    newclosure $P26, $P19
    .lex "xblock_immediate", $P26
.annotate 'line', 14
    .const 'Sub' $P27 = "13_1298325483.2958" 
    newclosure $P59, $P27
    .lex "block_immediate", $P59
.annotate 'line', 24
    .const 'Sub' $P60 = "16_1298325483.2958" 
    newclosure $P77, $P60
    .lex "vivitype", $P77
.annotate 'line', 43
    .const 'Sub' $P78 = "17_1298325483.2958" 
    newclosure $P90, $P78
    .lex "colonpair_str", $P90
.annotate 'line', 223
    .const 'Sub' $P91 = "18_1298325483.2958" 
    newclosure $P138, $P91
    .lex "push_block_handler", $P138
.annotate 'line', 762
    .const 'Sub' $P139 = "19_1298325483.2958" 
    newclosure $P148, $P139
    .lex "only_star_block", $P148
.annotate 'line', 771
    .const 'Sub' $P149 = "20_1298325483.2958" 
    newclosure $P213, $P149
    .lex "attach_multi_signature", $P213
.annotate 'line', 1241
    .const 'Sub' $P214 = "22_1298325483.2958" 
    newclosure $P225, $P214
    .lex "control", $P225
.annotate 'line', 3
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
    get_global $P226, "@BLOCK"
    .const 'Sub' $P228 = "23_1298325483.2958" 
    capture_lex $P228
    $P228()
    find_lex $P233, "xblock_immediate"
    find_lex $P234, "block_immediate"
    find_lex $P235, "vivitype"
.annotate 'line', 35
    find_lex $P274, "colonpair_str"
.annotate 'line', 216
    find_lex $P671, "push_block_handler"
.annotate 'line', 690
    find_lex $P1803, "only_star_block"
    find_lex $P1804, "attach_multi_signature"
.annotate 'line', 1232
    find_lex $P2842, "control"
.annotate 'line', 1259
    get_hll_global $P2867, ["NQP";"RegexActions"], "_block2866" 
    capture_lex $P2867
    $P2987 = $P2867()
.annotate 'line', 3
    .return ($P2987)
    .const 'Sub' $P2989 = "166_1298325483.2958" 
    .return ($P2989)
.end


.namespace ["NQP";"Actions"]
.sub "" :load :init :subid("post169") :outer("11_1298325483.2958")
.annotate 'line', 3
    get_hll_global $P15, ["NQP";"Actions"], "_block14" 
    .local pmc block
    set block, $P15
    .const 'Sub' $P2993 = "167_1298325483.2958" 
    capture_lex $P2993
    $P2993()
.end


.namespace ["NQP";"Actions"]
.sub "_block2992"  :anon :subid("167_1298325483.2958") :outer("11_1298325483.2958")
.annotate 'line', 3
    get_hll_global $P2994, "NQPClassHOW"
    $P2995 = $P2994."new_type"("Actions" :named("name"))
    .local pmc type_obj
    set type_obj, $P2995
    set_hll_global ["NQP"], "Actions", type_obj
    set_global "$?CLASS", type_obj
    get_how $P2996, type_obj
    .const 'Sub' $P2997 = "25_1298325483.2958" 
    $P2996."add_method"(type_obj, "TOP", $P2997)
    get_how $P2998, type_obj
    .const 'Sub' $P2999 = "26_1298325483.2958" 
    $P2998."add_method"(type_obj, "deflongname", $P2999)
    get_how $P3000, type_obj
    .const 'Sub' $P3001 = "27_1298325483.2958" 
    $P3000."add_method"(type_obj, "comp_unit", $P3001)
    get_how $P3002, type_obj
    .const 'Sub' $P3003 = "28_1298325483.2958" 
    $P3002."add_method"(type_obj, "statementlist", $P3003)
    get_how $P3004, type_obj
    .const 'Sub' $P3005 = "30_1298325483.2958" 
    $P3004."add_method"(type_obj, "statement", $P3005)
    get_how $P3006, type_obj
    .const 'Sub' $P3007 = "32_1298325483.2958" 
    $P3006."add_method"(type_obj, "xblock", $P3007)
    get_how $P3008, type_obj
    .const 'Sub' $P3009 = "33_1298325483.2958" 
    $P3008."add_method"(type_obj, "pblock", $P3009)
    get_how $P3010, type_obj
    .const 'Sub' $P3011 = "34_1298325483.2958" 
    $P3010."add_method"(type_obj, "block", $P3011)
    get_how $P3012, type_obj
    .const 'Sub' $P3013 = "35_1298325483.2958" 
    $P3012."add_method"(type_obj, "blockoid", $P3013)
    get_how $P3014, type_obj
    .const 'Sub' $P3015 = "36_1298325483.2958" 
    $P3014."add_method"(type_obj, "newpad", $P3015)
    get_how $P3016, type_obj
    .const 'Sub' $P3017 = "37_1298325483.2958" 
    $P3016."add_method"(type_obj, "outerctx", $P3017)
    get_how $P3018, type_obj
    .const 'Sub' $P3019 = "38_1298325483.2958" 
    $P3018."add_method"(type_obj, "statement_control:sym<if>", $P3019)
    get_how $P3020, type_obj
    .const 'Sub' $P3021 = "40_1298325483.2958" 
    $P3020."add_method"(type_obj, "statement_control:sym<unless>", $P3021)
    get_how $P3022, type_obj
    .const 'Sub' $P3023 = "41_1298325483.2958" 
    $P3022."add_method"(type_obj, "statement_control:sym<while>", $P3023)
    get_how $P3024, type_obj
    .const 'Sub' $P3025 = "42_1298325483.2958" 
    $P3024."add_method"(type_obj, "statement_control:sym<repeat>", $P3025)
    get_how $P3026, type_obj
    .const 'Sub' $P3027 = "43_1298325483.2958" 
    $P3026."add_method"(type_obj, "statement_control:sym<for>", $P3027)
    get_how $P3028, type_obj
    .const 'Sub' $P3029 = "44_1298325483.2958" 
    $P3028."add_method"(type_obj, "statement_control:sym<CATCH>", $P3029)
    get_how $P3030, type_obj
    .const 'Sub' $P3031 = "45_1298325483.2958" 
    $P3030."add_method"(type_obj, "statement_control:sym<CONTROL>", $P3031)
    get_how $P3032, type_obj
    .const 'Sub' $P3033 = "46_1298325483.2958" 
    $P3032."add_method"(type_obj, "statement_prefix:sym<INIT>", $P3033)
    get_how $P3034, type_obj
    .const 'Sub' $P3035 = "47_1298325483.2958" 
    $P3034."add_method"(type_obj, "statement_prefix:sym<try>", $P3035)
    get_how $P3036, type_obj
    .const 'Sub' $P3037 = "48_1298325483.2958" 
    $P3036."add_method"(type_obj, "blorst", $P3037)
    get_how $P3038, type_obj
    .const 'Sub' $P3039 = "49_1298325483.2958" 
    $P3038."add_method"(type_obj, "statement_mod_cond:sym<if>", $P3039)
    get_how $P3040, type_obj
    .const 'Sub' $P3041 = "50_1298325483.2958" 
    $P3040."add_method"(type_obj, "statement_mod_cond:sym<unless>", $P3041)
    get_how $P3042, type_obj
    .const 'Sub' $P3043 = "51_1298325483.2958" 
    $P3042."add_method"(type_obj, "statement_mod_loop:sym<while>", $P3043)
    get_how $P3044, type_obj
    .const 'Sub' $P3045 = "52_1298325483.2958" 
    $P3044."add_method"(type_obj, "statement_mod_loop:sym<until>", $P3045)
    get_how $P3046, type_obj
    .const 'Sub' $P3047 = "53_1298325483.2958" 
    $P3046."add_method"(type_obj, "term:sym<fatarrow>", $P3047)
    get_how $P3048, type_obj
    .const 'Sub' $P3049 = "54_1298325483.2958" 
    $P3048."add_method"(type_obj, "term:sym<colonpair>", $P3049)
    get_how $P3050, type_obj
    .const 'Sub' $P3051 = "55_1298325483.2958" 
    $P3050."add_method"(type_obj, "term:sym<variable>", $P3051)
    get_how $P3052, type_obj
    .const 'Sub' $P3053 = "56_1298325483.2958" 
    $P3052."add_method"(type_obj, "term:sym<package_declarator>", $P3053)
    get_how $P3054, type_obj
    .const 'Sub' $P3055 = "57_1298325483.2958" 
    $P3054."add_method"(type_obj, "term:sym<scope_declarator>", $P3055)
    get_how $P3056, type_obj
    .const 'Sub' $P3057 = "58_1298325483.2958" 
    $P3056."add_method"(type_obj, "term:sym<routine_declarator>", $P3057)
    get_how $P3058, type_obj
    .const 'Sub' $P3059 = "59_1298325483.2958" 
    $P3058."add_method"(type_obj, "term:sym<regex_declarator>", $P3059)
    get_how $P3060, type_obj
    .const 'Sub' $P3061 = "60_1298325483.2958" 
    $P3060."add_method"(type_obj, "term:sym<statement_prefix>", $P3061)
    get_how $P3062, type_obj
    .const 'Sub' $P3063 = "61_1298325483.2958" 
    $P3062."add_method"(type_obj, "term:sym<lambda>", $P3063)
    get_how $P3064, type_obj
    .const 'Sub' $P3065 = "62_1298325483.2958" 
    $P3064."add_method"(type_obj, "fatarrow", $P3065)
    get_how $P3066, type_obj
    .const 'Sub' $P3067 = "63_1298325483.2958" 
    $P3066."add_method"(type_obj, "colonpair", $P3067)
    get_how $P3068, type_obj
    .const 'Sub' $P3069 = "64_1298325483.2958" 
    $P3068."add_method"(type_obj, "variable", $P3069)
    get_how $P3070, type_obj
    .const 'Sub' $P3071 = "66_1298325483.2958" 
    $P3070."add_method"(type_obj, "package_declarator:sym<module>", $P3071)
    get_how $P3072, type_obj
    .const 'Sub' $P3073 = "67_1298325483.2958" 
    $P3072."add_method"(type_obj, "package_declarator:sym<knowhow>", $P3073)
    get_how $P3074, type_obj
    .const 'Sub' $P3075 = "68_1298325483.2958" 
    $P3074."add_method"(type_obj, "package_declarator:sym<class>", $P3075)
    get_how $P3076, type_obj
    .const 'Sub' $P3077 = "69_1298325483.2958" 
    $P3076."add_method"(type_obj, "package_declarator:sym<grammar>", $P3077)
    get_how $P3078, type_obj
    .const 'Sub' $P3079 = "70_1298325483.2958" 
    $P3078."add_method"(type_obj, "package_declarator:sym<role>", $P3079)
    get_how $P3080, type_obj
    .const 'Sub' $P3081 = "71_1298325483.2958" 
    $P3080."add_method"(type_obj, "package_declarator:sym<native>", $P3081)
    get_how $P3082, type_obj
    .const 'Sub' $P3083 = "72_1298325483.2958" 
    $P3082."add_method"(type_obj, "package_def", $P3083)
    get_how $P3084, type_obj
    .const 'Sub' $P3085 = "76_1298325483.2958" 
    $P3084."add_method"(type_obj, "scope_declarator:sym<my>", $P3085)
    get_how $P3086, type_obj
    .const 'Sub' $P3087 = "77_1298325483.2958" 
    $P3086."add_method"(type_obj, "scope_declarator:sym<our>", $P3087)
    get_how $P3088, type_obj
    .const 'Sub' $P3089 = "78_1298325483.2958" 
    $P3088."add_method"(type_obj, "scope_declarator:sym<has>", $P3089)
    get_how $P3090, type_obj
    .const 'Sub' $P3091 = "79_1298325483.2958" 
    $P3090."add_method"(type_obj, "scoped", $P3091)
    get_how $P3092, type_obj
    .const 'Sub' $P3093 = "80_1298325483.2958" 
    $P3092."add_method"(type_obj, "declarator", $P3093)
    get_how $P3094, type_obj
    .const 'Sub' $P3095 = "81_1298325483.2958" 
    $P3094."add_method"(type_obj, "multi_declarator:sym<multi>", $P3095)
    get_how $P3096, type_obj
    .const 'Sub' $P3097 = "82_1298325483.2958" 
    $P3096."add_method"(type_obj, "multi_declarator:sym<proto>", $P3097)
    get_how $P3098, type_obj
    .const 'Sub' $P3099 = "83_1298325483.2958" 
    $P3098."add_method"(type_obj, "multi_declarator:sym<null>", $P3099)
    get_how $P3100, type_obj
    .const 'Sub' $P3101 = "84_1298325483.2958" 
    $P3100."add_method"(type_obj, "variable_declarator", $P3101)
    get_how $P3102, type_obj
    .const 'Sub' $P3103 = "88_1298325483.2958" 
    $P3102."add_method"(type_obj, "routine_declarator:sym<sub>", $P3103)
    get_how $P3104, type_obj
    .const 'Sub' $P3105 = "89_1298325483.2958" 
    $P3104."add_method"(type_obj, "routine_declarator:sym<method>", $P3105)
    get_how $P3106, type_obj
    .const 'Sub' $P3107 = "90_1298325483.2958" 
    $P3106."add_method"(type_obj, "routine_def", $P3107)
    get_how $P3108, type_obj
    .const 'Sub' $P3109 = "97_1298325483.2958" 
    $P3108."add_method"(type_obj, "method_def", $P3109)
    get_how $P3110, type_obj
    .const 'Sub' $P3111 = "100_1298325483.2958" 
    $P3110."add_method"(type_obj, "signature", $P3111)
    get_how $P3112, type_obj
    .const 'Sub' $P3113 = "103_1298325483.2958" 
    $P3112."add_method"(type_obj, "parameter", $P3113)
    get_how $P3114, type_obj
    .const 'Sub' $P3115 = "104_1298325483.2958" 
    $P3114."add_method"(type_obj, "param_var", $P3115)
    get_how $P3116, type_obj
    .const 'Sub' $P3117 = "105_1298325483.2958" 
    $P3116."add_method"(type_obj, "named_param", $P3117)
    get_how $P3118, type_obj
    .const 'Sub' $P3119 = "106_1298325483.2958" 
    $P3118."add_method"(type_obj, "typename", $P3119)
    get_how $P3120, type_obj
    .const 'Sub' $P3121 = "107_1298325483.2958" 
    $P3120."add_method"(type_obj, "trait", $P3121)
    get_how $P3122, type_obj
    .const 'Sub' $P3123 = "108_1298325483.2958" 
    $P3122."add_method"(type_obj, "trait_mod:sym<is>", $P3123)
    get_how $P3124, type_obj
    .const 'Sub' $P3125 = "110_1298325483.2958" 
    $P3124."add_method"(type_obj, "regex_declarator", $P3125)
    get_how $P3126, type_obj
    .const 'Sub' $P3127 = "114_1298325483.2958" 
    $P3126."add_method"(type_obj, "dotty", $P3127)
    get_how $P3128, type_obj
    .const 'Sub' $P3129 = "115_1298325483.2958" 
    $P3128."add_method"(type_obj, "term:sym<self>", $P3129)
    get_how $P3130, type_obj
    .const 'Sub' $P3131 = "116_1298325483.2958" 
    $P3130."add_method"(type_obj, "term:sym<identifier>", $P3131)
    get_how $P3132, type_obj
    .const 'Sub' $P3133 = "117_1298325483.2958" 
    $P3132."add_method"(type_obj, "term:sym<name>", $P3133)
    get_how $P3134, type_obj
    .const 'Sub' $P3135 = "118_1298325483.2958" 
    $P3134."add_method"(type_obj, "term:sym<pir::op>", $P3135)
    get_how $P3136, type_obj
    .const 'Sub' $P3137 = "119_1298325483.2958" 
    $P3136."add_method"(type_obj, "term:sym<onlystar>", $P3137)
    get_how $P3138, type_obj
    .const 'Sub' $P3139 = "120_1298325483.2958" 
    $P3138."add_method"(type_obj, "args", $P3139)
    get_how $P3140, type_obj
    .const 'Sub' $P3141 = "121_1298325483.2958" 
    $P3140."add_method"(type_obj, "arglist", $P3141)
    get_how $P3142, type_obj
    .const 'Sub' $P3143 = "124_1298325483.2958" 
    $P3142."add_method"(type_obj, "term:sym<multi_declarator>", $P3143)
    get_how $P3144, type_obj
    .const 'Sub' $P3145 = "125_1298325483.2958" 
    $P3144."add_method"(type_obj, "term:sym<value>", $P3145)
    get_how $P3146, type_obj
    .const 'Sub' $P3147 = "126_1298325483.2958" 
    $P3146."add_method"(type_obj, "circumfix:sym<( )>", $P3147)
    get_how $P3148, type_obj
    .const 'Sub' $P3149 = "127_1298325483.2958" 
    $P3148."add_method"(type_obj, "circumfix:sym<[ ]>", $P3149)
    get_how $P3150, type_obj
    .const 'Sub' $P3151 = "128_1298325483.2958" 
    $P3150."add_method"(type_obj, "circumfix:sym<ang>", $P3151)
    get_how $P3152, type_obj
    .const 'Sub' $P3153 = "129_1298325483.2958" 
    $P3152."add_method"(type_obj, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P3153)
    get_how $P3154, type_obj
    .const 'Sub' $P3155 = "130_1298325483.2958" 
    $P3154."add_method"(type_obj, "circumfix:sym<{ }>", $P3155)
    get_how $P3156, type_obj
    .const 'Sub' $P3157 = "131_1298325483.2958" 
    $P3156."add_method"(type_obj, "circumfix:sym<sigil>", $P3157)
    get_how $P3158, type_obj
    .const 'Sub' $P3159 = "132_1298325483.2958" 
    $P3158."add_method"(type_obj, "semilist", $P3159)
    get_how $P3160, type_obj
    .const 'Sub' $P3161 = "133_1298325483.2958" 
    $P3160."add_method"(type_obj, "postcircumfix:sym<[ ]>", $P3161)
    get_how $P3162, type_obj
    .const 'Sub' $P3163 = "134_1298325483.2958" 
    $P3162."add_method"(type_obj, "postcircumfix:sym<{ }>", $P3163)
    get_how $P3164, type_obj
    .const 'Sub' $P3165 = "135_1298325483.2958" 
    $P3164."add_method"(type_obj, "postcircumfix:sym<ang>", $P3165)
    get_how $P3166, type_obj
    .const 'Sub' $P3167 = "136_1298325483.2958" 
    $P3166."add_method"(type_obj, "postcircumfix:sym<( )>", $P3167)
    get_how $P3168, type_obj
    .const 'Sub' $P3169 = "137_1298325483.2958" 
    $P3168."add_method"(type_obj, "value", $P3169)
    get_how $P3170, type_obj
    .const 'Sub' $P3171 = "138_1298325483.2958" 
    $P3170."add_method"(type_obj, "number", $P3171)
    get_how $P3172, type_obj
    .const 'Sub' $P3173 = "139_1298325483.2958" 
    $P3172."add_method"(type_obj, "quote:sym<apos>", $P3173)
    get_how $P3174, type_obj
    .const 'Sub' $P3175 = "140_1298325483.2958" 
    $P3174."add_method"(type_obj, "quote:sym<dblq>", $P3175)
    get_how $P3176, type_obj
    .const 'Sub' $P3177 = "141_1298325483.2958" 
    $P3176."add_method"(type_obj, "quote:sym<qq>", $P3177)
    get_how $P3178, type_obj
    .const 'Sub' $P3179 = "142_1298325483.2958" 
    $P3178."add_method"(type_obj, "quote:sym<q>", $P3179)
    get_how $P3180, type_obj
    .const 'Sub' $P3181 = "143_1298325483.2958" 
    $P3180."add_method"(type_obj, "quote:sym<Q>", $P3181)
    get_how $P3182, type_obj
    .const 'Sub' $P3183 = "144_1298325483.2958" 
    $P3182."add_method"(type_obj, "quote:sym<Q:PIR>", $P3183)
    get_how $P3184, type_obj
    .const 'Sub' $P3185 = "145_1298325483.2958" 
    $P3184."add_method"(type_obj, "quote:sym</ />", $P3185)
    get_how $P3186, type_obj
    .const 'Sub' $P3187 = "146_1298325483.2958" 
    $P3186."add_method"(type_obj, "quote_escape:sym<$>", $P3187)
    get_how $P3188, type_obj
    .const 'Sub' $P3189 = "147_1298325483.2958" 
    $P3188."add_method"(type_obj, "quote_escape:sym<{ }>", $P3189)
    get_how $P3190, type_obj
    .const 'Sub' $P3191 = "148_1298325483.2958" 
    $P3190."add_method"(type_obj, "quote_escape:sym<esc>", $P3191)
    get_how $P3192, type_obj
    .const 'Sub' $P3193 = "149_1298325483.2958" 
    $P3192."add_method"(type_obj, "postfix:sym<.>", $P3193)
    get_how $P3194, type_obj
    .const 'Sub' $P3195 = "150_1298325483.2958" 
    $P3194."add_method"(type_obj, "postfix:sym<++>", $P3195)
    get_how $P3196, type_obj
    .const 'Sub' $P3197 = "151_1298325483.2958" 
    $P3196."add_method"(type_obj, "postfix:sym<-->", $P3197)
    get_how $P3198, type_obj
    .const 'Sub' $P3199 = "152_1298325483.2958" 
    $P3198."add_method"(type_obj, "prefix:sym<make>", $P3199)
    get_how $P3200, type_obj
    .const 'Sub' $P3201 = "153_1298325483.2958" 
    $P3200."add_method"(type_obj, "term:sym<next>", $P3201)
    get_how $P3202, type_obj
    .const 'Sub' $P3203 = "154_1298325483.2958" 
    $P3202."add_method"(type_obj, "term:sym<last>", $P3203)
    get_how $P3204, type_obj
    .const 'Sub' $P3205 = "155_1298325483.2958" 
    $P3204."add_method"(type_obj, "term:sym<redo>", $P3205)
    get_how $P3206, type_obj
    .const 'Sub' $P3207 = "156_1298325483.2958" 
    $P3206."add_method"(type_obj, "infix:sym<~~>", $P3207)
    get_how $P3208, type_obj
    get_hll_global $P3209, ["HLL"], "Actions"
    $P3208."add_parent"(type_obj, $P3209)
    get_how $P3210, type_obj
    $P3211 = $P3210."compose"(type_obj)
    .return ($P3211)
.end


.namespace ["NQP";"Actions"]
.sub "xblock_immediate"  :subid("12_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_20
.annotate 'line', 9
    .lex "$xblock", param_20
.annotate 'line', 10
    find_lex $P21, "$xblock"
    unless_null $P21, vivify_171
    $P21 = root_new ['parrot';'ResizablePMCArray']
  vivify_171:
    set $P22, $P21[1]
    unless_null $P22, vivify_172
    new $P22, "Undef"
  vivify_172:
    $P23 = "block_immediate"($P22)
    find_lex $P24, "$xblock"
    unless_null $P24, vivify_173
    $P24 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$xblock", $P24
  vivify_173:
    set $P24[1], $P23
    find_lex $P25, "$xblock"
.annotate 'line', 9
    .return ($P25)
.end


.namespace ["NQP";"Actions"]
.sub "block_immediate"  :subid("13_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_28
.annotate 'line', 14
    .const 'Sub' $P38 = "14_1298325483.2958" 
    capture_lex $P38
    .lex "$block", param_28
.annotate 'line', 15
    find_lex $P29, "$block"
    $P29."blocktype"("immediate")
.annotate 'line', 16
    find_lex $P33, "$block"
    $P34 = $P33."symtable"()
    unless $P34, unless_32
    set $P31, $P34
    goto unless_32_end
  unless_32:
    find_lex $P35, "$block"
    $P36 = $P35."handlers"()
    set $P31, $P36
  unless_32_end:
    if $P31, unless_30_end
    .const 'Sub' $P38 = "14_1298325483.2958" 
    capture_lex $P38
    $P38()
  unless_30_end:
    find_lex $P58, "$block"
.annotate 'line', 14
    .return ($P58)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block37"  :anon :subid("14_1298325483.2958") :outer("13_1298325483.2958")
.annotate 'line', 16
    .const 'Sub' $P49 = "15_1298325483.2958" 
    capture_lex $P49
.annotate 'line', 17
    new $P39, "Undef"
    .lex "$stmts", $P39
    get_hll_global $P40, ["PAST"], "Stmts"
    find_lex $P41, "$block"
    $P42 = $P40."new"($P41 :named("node"))
    store_lex "$stmts", $P42
.annotate 'line', 18
    find_lex $P44, "$block"
    $P45 = $P44."list"()
    defined $I46, $P45
    unless $I46, for_undef_174
    iter $P43, $P45
    new $P55, 'ExceptionHandler'
    set_label $P55, loop54_handler
    $P55."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P55
  loop54_test:
    unless $P43, loop54_done
    shift $P47, $P43
  loop54_redo:
    .const 'Sub' $P49 = "15_1298325483.2958" 
    capture_lex $P49
    $P49($P47)
  loop54_next:
    goto loop54_test
  loop54_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P56, exception, 'type'
    eq $P56, .CONTROL_LOOP_NEXT, loop54_next
    eq $P56, .CONTROL_LOOP_REDO, loop54_redo
  loop54_done:
    pop_eh 
  for_undef_174:
.annotate 'line', 19
    find_lex $P57, "$stmts"
    store_lex "$block", $P57
.annotate 'line', 16
    .return ($P57)
.end


.namespace ["NQP";"Actions"]
.sub "_block48"  :anon :subid("15_1298325483.2958") :outer("14_1298325483.2958")
    .param pmc param_50
.annotate 'line', 18
    .lex "$_", param_50
    find_lex $P51, "$stmts"
    find_lex $P52, "$_"
    $P53 = $P51."push"($P52)
    .return ($P53)
.end


.namespace ["NQP";"Actions"]
.sub "vivitype"  :subid("16_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_61
.annotate 'line', 24
    .lex "$sigil", param_61
.annotate 'line', 25
    find_lex $P64, "$sigil"
    set $S65, $P64
    iseq $I66, $S65, "%"
    if $I66, if_63
.annotate 'line', 27
    find_lex $P71, "$sigil"
    set $S72, $P71
    iseq $I73, $S72, "@"
    if $I73, if_70
    new $P76, "String"
    assign $P76, "Undef"
    set $P69, $P76
    goto if_70_end
  if_70:
.annotate 'line', 28
    get_hll_global $P74, ["PAST"], "Op"
    $P75 = $P74."new"("    %r = root_new ['parrot';'ResizablePMCArray']" :named("inline"))
    set $P69, $P75
  if_70_end:
    set $P62, $P69
.annotate 'line', 25
    goto if_63_end
  if_63:
.annotate 'line', 26
    get_hll_global $P67, ["PAST"], "Op"
    $P68 = $P67."new"("    %r = root_new ['parrot';'Hash']" :named("inline"))
    set $P62, $P68
  if_63_end:
.annotate 'line', 24
    .return ($P62)
.end


.namespace ["NQP";"Actions"]
.sub "colonpair_str"  :subid("17_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_79
.annotate 'line', 43
    .lex "$ast", param_79
.annotate 'line', 44
    get_hll_global $P82, ["PAST"], "Op"
    find_lex $P83, "$ast"
    $P84 = $P82."ACCEPTS"($P83)
    if $P84, if_81
.annotate 'line', 46
    find_lex $P88, "$ast"
    $P89 = $P88."value"()
    set $P80, $P89
.annotate 'line', 44
    goto if_81_end
  if_81:
.annotate 'line', 45
    find_lex $P85, "$ast"
    $P86 = $P85."list"()
    join $S87, " ", $P86
    new $P80, 'String'
    set $P80, $S87
  if_81_end:
.annotate 'line', 43
    .return ($P80)
.end


.namespace ["NQP";"Actions"]
.sub "push_block_handler"  :subid("18_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_92
    .param pmc param_93
.annotate 'line', 223
    .lex "$/", param_92
    .lex "$block", param_93
.annotate 'line', 224
    get_global $P95, "@BLOCK"
    unless_null $P95, vivify_175
    $P95 = root_new ['parrot';'ResizablePMCArray']
  vivify_175:
    set $P96, $P95[0]
    unless_null $P96, vivify_176
    new $P96, "Undef"
  vivify_176:
    $P97 = $P96."handlers"()
    if $P97, unless_94_end
.annotate 'line', 225
    get_global $P98, "@BLOCK"
    unless_null $P98, vivify_177
    $P98 = root_new ['parrot';'ResizablePMCArray']
  vivify_177:
    set $P99, $P98[0]
    unless_null $P99, vivify_178
    new $P99, "Undef"
  vivify_178:
    new $P100, "ResizablePMCArray"
    $P99."handlers"($P100)
  unless_94_end:
.annotate 'line', 227
    find_lex $P102, "$block"
    $P103 = $P102."arity"()
    if $P103, unless_101_end
.annotate 'line', 228
    find_lex $P104, "$block"
.annotate 'line', 229
    get_hll_global $P105, ["PAST"], "Op"
.annotate 'line', 230
    get_hll_global $P106, ["PAST"], "Var"
    $P107 = $P106."new"("lexical" :named("scope"), "$!" :named("name"), 1 :named("isdecl"))
.annotate 'line', 231
    get_hll_global $P108, ["PAST"], "Var"
    $P109 = $P108."new"("lexical" :named("scope"), "$_" :named("name"))
    $P110 = $P105."new"($P107, $P109, "bind" :named("pasttype"))
.annotate 'line', 229
    $P104."unshift"($P110)
.annotate 'line', 234
    find_lex $P111, "$block"
    get_hll_global $P112, ["PAST"], "Var"
    $P113 = $P112."new"("$_" :named("name"), "parameter" :named("scope"))
    $P111."unshift"($P113)
.annotate 'line', 235
    find_lex $P114, "$block"
    $P114."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 236
    find_lex $P115, "$block"
    $P115."symbol"("$!", "lexical" :named("scope"))
.annotate 'line', 237
    find_lex $P116, "$block"
    $P116."arity"(1)
  unless_101_end:
.annotate 'line', 239
    find_lex $P117, "$block"
    $P117."blocktype"("declaration")
.annotate 'line', 240
    get_global $P118, "@BLOCK"
    unless_null $P118, vivify_179
    $P118 = root_new ['parrot';'ResizablePMCArray']
  vivify_179:
    set $P119, $P118[0]
    unless_null $P119, vivify_180
    new $P119, "Undef"
  vivify_180:
    $P120 = $P119."handlers"()
.annotate 'line', 241
    get_hll_global $P121, ["PAST"], "Control"
    find_lex $P122, "$/"
.annotate 'line', 243
    get_hll_global $P123, ["PAST"], "Stmts"
.annotate 'line', 244
    get_hll_global $P124, ["PAST"], "Op"
    find_lex $P125, "$block"
.annotate 'line', 246
    get_hll_global $P126, ["PAST"], "Var"
    $P127 = $P126."new"("register" :named("scope"), "exception" :named("name"))
    $P128 = $P124."new"($P125, $P127, "call" :named("pasttype"))
.annotate 'line', 248
    get_hll_global $P129, ["PAST"], "Op"
.annotate 'line', 249
    get_hll_global $P130, ["PAST"], "Var"
.annotate 'line', 250
    get_hll_global $P131, ["PAST"], "Var"
    $P132 = $P131."new"("register" :named("scope"), "exception" :named("name"))
    $P133 = $P130."new"($P132, "handled", "keyed" :named("scope"))
.annotate 'line', 249
    $P134 = $P129."new"($P133, 1, "bind" :named("pasttype"))
.annotate 'line', 248
    $P135 = $P123."new"($P128, $P134)
.annotate 'line', 243
    $P136 = $P121."new"($P135, $P122 :named("node"))
.annotate 'line', 241
    $P137 = $P120."unshift"($P136)
.annotate 'line', 223
    .return ($P137)
.end


.namespace ["NQP";"Actions"]
.sub "only_star_block"  :subid("19_1298325483.2958") :outer("11_1298325483.2958")
.annotate 'line', 763
    new $P140, "Undef"
    .lex "$past", $P140
    get_global $P141, "@BLOCK"
    $P142 = $P141."shift"()
    store_lex "$past", $P142
.annotate 'line', 764
    find_lex $P143, "$past"
    $P143."closure"(1)
.annotate 'line', 765
    find_lex $P144, "$past"
    get_hll_global $P145, ["PAST"], "Op"
    $P146 = $P145."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P144."push"($P146)
    find_lex $P147, "$past"
.annotate 'line', 762
    .return ($P147)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "attach_multi_signature"  :subid("20_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_150
.annotate 'line', 771
    .const 'Sub' $P164 = "21_1298325483.2958" 
    capture_lex $P164
    .lex "$routine", param_150
.annotate 'line', 775
    new $P151, "Undef"
    .lex "$types", $P151
.annotate 'line', 776
    new $P152, "Undef"
    .lex "$definednesses", $P152
.annotate 'line', 775
    get_hll_global $P153, ["PAST"], "Op"
    $P154 = $P153."new"("list" :named("pasttype"))
    store_lex "$types", $P154
.annotate 'line', 776
    get_hll_global $P155, ["PAST"], "Op"
    $P156 = $P155."new"("list" :named("pasttype"))
    store_lex "$definednesses", $P156
.annotate 'line', 777
    find_lex $P158, "$routine"
    unless_null $P158, vivify_181
    $P158 = root_new ['parrot';'ResizablePMCArray']
  vivify_181:
    set $P159, $P158[0]
    unless_null $P159, vivify_182
    new $P159, "Undef"
  vivify_182:
    $P160 = $P159."list"()
    defined $I161, $P160
    unless $I161, for_undef_183
    iter $P157, $P160
    new $P202, 'ExceptionHandler'
    set_label $P202, loop201_handler
    $P202."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P202
  loop201_test:
    unless $P157, loop201_done
    shift $P162, $P157
  loop201_redo:
    .const 'Sub' $P164 = "21_1298325483.2958" 
    capture_lex $P164
    $P164($P162)
  loop201_next:
    goto loop201_test
  loop201_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P203, exception, 'type'
    eq $P203, .CONTROL_LOOP_NEXT, loop201_next
    eq $P203, .CONTROL_LOOP_REDO, loop201_redo
  loop201_done:
    pop_eh 
  for_undef_183:
.annotate 'line', 784
    find_lex $P204, "$routine"
    $P205 = $P204."loadinit"()
    get_hll_global $P206, ["PAST"], "Op"
.annotate 'line', 785
    get_hll_global $P207, ["PAST"], "Var"
    $P208 = $P207."new"("block" :named("name"), "register" :named("scope"))
    find_lex $P209, "$types"
    find_lex $P210, "$definednesses"
    $P211 = $P206."new"($P208, $P209, $P210, "set_sub_multisig vPPP" :named("pirop"))
.annotate 'line', 784
    $P212 = $P205."push"($P211)
.annotate 'line', 771
    .return ($P212)
.end


.namespace ["NQP";"Actions"]
.sub "_block163"  :anon :subid("21_1298325483.2958") :outer("20_1298325483.2958")
    .param pmc param_165
.annotate 'line', 777
    .lex "$_", param_165
.annotate 'line', 778
    get_hll_global $P170, ["PAST"], "Var"
    find_lex $P171, "$_"
    $P172 = $P170."ACCEPTS"($P171)
    if $P172, if_169
    set $P168, $P172
    goto if_169_end
  if_169:
    find_lex $P173, "$_"
    $S174 = $P173."scope"()
    iseq $I175, $S174, "parameter"
    new $P168, 'Integer'
    set $P168, $I175
  if_169_end:
    if $P168, if_167
    set $P166, $P168
    goto if_167_end
  if_167:
.annotate 'line', 779
    find_lex $P176, "$types"
    find_lex $P178, "$_"
    $P179 = $P178."multitype"()
    set $P177, $P179
    defined $I181, $P177
    if $I181, default_180
    get_hll_global $P182, ["PAST"], "Op"
    $P183 = $P182."new"("null P" :named("pirop"))
    set $P177, $P183
  default_180:
    $P176."push"($P177)
.annotate 'line', 780
    find_lex $P184, "$definednesses"
    find_lex $P187, "$_"
    unless_null $P187, vivify_184
    $P187 = root_new ['parrot';'Hash']
  vivify_184:
    set $P188, $P187["definedness"]
    unless_null $P188, vivify_185
    new $P188, "Undef"
  vivify_185:
    set $S189, $P188
    iseq $I190, $S189, "D"
    if $I190, if_186
.annotate 'line', 781
    find_lex $P194, "$_"
    unless_null $P194, vivify_186
    $P194 = root_new ['parrot';'Hash']
  vivify_186:
    set $P195, $P194["definedness"]
    unless_null $P195, vivify_187
    new $P195, "Undef"
  vivify_187:
    set $S196, $P195
    iseq $I197, $S196, "U"
    if $I197, if_193
    new $P199, "Integer"
    assign $P199, 0
    set $P192, $P199
    goto if_193_end
  if_193:
    new $P198, "Integer"
    assign $P198, 2
    set $P192, $P198
  if_193_end:
    set $P185, $P192
.annotate 'line', 780
    goto if_186_end
  if_186:
    new $P191, "Integer"
    assign $P191, 1
    set $P185, $P191
  if_186_end:
    $P200 = $P184."push"($P185)
.annotate 'line', 778
    set $P166, $P200
  if_167_end:
.annotate 'line', 777
    .return ($P166)
.end


.namespace ["NQP";"Actions"]
.sub "control"  :subid("22_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_215
    .param pmc param_216
.annotate 'line', 1241
    .lex "$/", param_215
    .lex "$type", param_216
.annotate 'line', 1242
    find_lex $P217, "$/"
    get_hll_global $P218, ["PAST"], "Op"
    find_lex $P219, "$/"
.annotate 'line', 1246
    get_hll_global $P220, ["PAST"], "Val"
    find_lex $P221, "$type"
    $P222 = $P220."new"($P221 :named("value"), "!except_types" :named("returns"))
    $P223 = $P218."new"(0, $P222, $P219 :named("node"), "die__vii" :named("pirop"))
.annotate 'line', 1242
    $P224 = $P217."!make"($P223)
.annotate 'line', 1241
    .return ($P224)
.end


.namespace ["NQP";"Actions"]
.sub "_block227"  :anon :subid("23_1298325483.2958") :outer("11_1298325483.2958")
.annotate 'line', 3
    .const 'Sub' $P230 = "24_1298325483.2958" 
    capture_lex $P230
    .return ()
.end


.namespace ["NQP";"Actions"]
.sub "" :load :init :subid("post188") :outer("23_1298325483.2958")
.annotate 'line', 3
    .const 'Sub' $P228 = "23_1298325483.2958" 
    .local pmc block
    set block, $P228
.annotate 'line', 5
    .const 'Sub' $P230 = "24_1298325483.2958" 
    capture_lex $P230
    $P230()
.end


.namespace ["NQP";"Actions"]
.sub "_block229"  :anon :subid("24_1298325483.2958") :outer("23_1298325483.2958")
.annotate 'line', 6
    get_global $P231, "@BLOCK"
    unless_null $P231, vivify_189
    $P231 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P231
  vivify_189:
 $P232 = new ['ResizablePMCArray'] 
    set_global "@BLOCK", $P232
.annotate 'line', 5
    .return ($P232)
.end


.namespace ["NQP";"Actions"]
.sub "TOP"  :subid("25_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_237
    .param pmc param_238
.annotate 'line', 33
    .lex "self", param_237
    .lex "$/", param_238
    find_lex $P239, "$/"
    find_lex $P240, "$/"
    unless_null $P240, vivify_190
    $P240 = root_new ['parrot';'Hash']
  vivify_190:
    set $P241, $P240["comp_unit"]
    unless_null $P241, vivify_191
    new $P241, "Undef"
  vivify_191:
    $P242 = $P241."ast"()
    $P243 = $P239."!make"($P242)
    .return ($P243)
.end


.namespace ["NQP";"Actions"]
.sub "deflongname"  :subid("26_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_245
    .param pmc param_246
.annotate 'line', 35
    .lex "self", param_245
    .lex "$/", param_246
.annotate 'line', 36
    find_lex $P247, "$/"
.annotate 'line', 37
    find_lex $P250, "$/"
    unless_null $P250, vivify_192
    $P250 = root_new ['parrot';'Hash']
  vivify_192:
    set $P251, $P250["colonpair"]
    unless_null $P251, vivify_193
    new $P251, "Undef"
  vivify_193:
    if $P251, if_249
.annotate 'line', 39
    find_lex $P271, "$/"
    set $S272, $P271
    new $P248, 'String'
    set $P248, $S272
.annotate 'line', 37
    goto if_249_end
  if_249:
    find_lex $P252, "$/"
    unless_null $P252, vivify_194
    $P252 = root_new ['parrot';'Hash']
  vivify_194:
    set $P253, $P252["identifier"]
    unless_null $P253, vivify_195
    new $P253, "Undef"
  vivify_195:
    set $S254, $P253
    new $P255, 'String'
    set $P255, $S254
    concat $P256, $P255, ":"
    find_lex $P257, "$/"
    unless_null $P257, vivify_196
    $P257 = root_new ['parrot';'Hash']
  vivify_196:
    set $P258, $P257["colonpair"]
    unless_null $P258, vivify_197
    $P258 = root_new ['parrot';'ResizablePMCArray']
  vivify_197:
    set $P259, $P258[0]
    unless_null $P259, vivify_198
    new $P259, "Undef"
  vivify_198:
    $P260 = $P259."ast"()
    $S261 = $P260."named"()
    concat $P262, $P256, $S261
    concat $P263, $P262, "<"
.annotate 'line', 38
    find_lex $P264, "$/"
    unless_null $P264, vivify_199
    $P264 = root_new ['parrot';'Hash']
  vivify_199:
    set $P265, $P264["colonpair"]
    unless_null $P265, vivify_200
    $P265 = root_new ['parrot';'ResizablePMCArray']
  vivify_200:
    set $P266, $P265[0]
    unless_null $P266, vivify_201
    new $P266, "Undef"
  vivify_201:
    $P267 = $P266."ast"()
    $S268 = "colonpair_str"($P267)
    concat $P269, $P263, $S268
    concat $P270, $P269, ">"
    set $P248, $P270
  if_249_end:
.annotate 'line', 37
    $P273 = $P247."!make"($P248)
.annotate 'line', 35
    .return ($P273)
.end


.namespace ["NQP";"Actions"]
.sub "comp_unit"  :subid("27_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_276
    .param pmc param_277
.annotate 'line', 49
    .lex "self", param_276
    .lex "$/", param_277
.annotate 'line', 50
    new $P278, "Undef"
    .lex "$mainline", $P278
.annotate 'line', 51
    new $P279, "Undef"
    .lex "$unit", $P279
.annotate 'line', 50
    find_lex $P280, "$/"
    unless_null $P280, vivify_202
    $P280 = root_new ['parrot';'Hash']
  vivify_202:
    set $P281, $P280["statementlist"]
    unless_null $P281, vivify_203
    new $P281, "Undef"
  vivify_203:
    $P282 = $P281."ast"()
    store_lex "$mainline", $P282
.annotate 'line', 51
    get_global $P283, "@BLOCK"
    $P284 = $P283."shift"()
    store_lex "$unit", $P284
.annotate 'line', 55
    find_lex $P285, "$unit"
    find_lex $P286, "self"
    $P287 = $P286."CTXSAVE"()
    $P285."push"($P287)
.annotate 'line', 58
    find_lex $P288, "$unit"
    $P288."loadlibs"("nqp_group", "nqp_ops")
.annotate 'line', 59
    find_lex $P289, "$unit"
    get_hll_global $P290, ["PAST"], "Op"
    $P291 = $P290."new"("nqp_dynop_setup v" :named("pirop"))
    $P289."unshift"($P291)
.annotate 'line', 64
    find_lex $P292, "$unit"
.annotate 'line', 65
    get_hll_global $P293, ["PAST"], "Op"
    find_lex $P294, "$mainline"
    $P295 = $P293."new"($P294, "return" :named("pirop"))
    $P292."push"($P295)
.annotate 'line', 70
    find_lex $P296, "$unit"
.annotate 'line', 71
    get_hll_global $P297, ["PAST"], "Block"
.annotate 'line', 73
    get_hll_global $P298, ["PAST"], "Op"
    get_hll_global $P299, ["PAST"], "Val"
    find_lex $P300, "$unit"
    $P301 = $P299."new"($P300 :named("value"))
    $P302 = $P298."new"($P301, "call" :named("pasttype"))
    $P303 = $P297."new"($P302, ":load" :named("pirflags"), 0 :named("lexical"), "" :named("namespace"))
.annotate 'line', 71
    $P296."push"($P303)
.annotate 'line', 76
    find_lex $P304, "$unit"
    find_lex $P305, "$/"
    $P304."node"($P305)
.annotate 'line', 77
    find_lex $P306, "$/"
    find_lex $P307, "$unit"
    $P308 = $P306."!make"($P307)
.annotate 'line', 49
    .return ($P308)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statementlist"  :subid("28_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_310
    .param pmc param_311
.annotate 'line', 80
    .const 'Sub' $P325 = "29_1298325483.2958" 
    capture_lex $P325
    .lex "self", param_310
    .lex "$/", param_311
.annotate 'line', 81
    new $P312, "Undef"
    .lex "$past", $P312
    get_hll_global $P313, ["PAST"], "Stmts"
    find_lex $P314, "$/"
    $P315 = $P313."new"($P314 :named("node"))
    store_lex "$past", $P315
.annotate 'line', 82
    find_lex $P317, "$/"
    unless_null $P317, vivify_204
    $P317 = root_new ['parrot';'Hash']
  vivify_204:
    set $P318, $P317["statement"]
    unless_null $P318, vivify_205
    new $P318, "Undef"
  vivify_205:
    unless $P318, if_316_end
.annotate 'line', 83
    find_lex $P320, "$/"
    unless_null $P320, vivify_206
    $P320 = root_new ['parrot';'Hash']
  vivify_206:
    set $P321, $P320["statement"]
    unless_null $P321, vivify_207
    new $P321, "Undef"
  vivify_207:
    defined $I322, $P321
    unless $I322, for_undef_208
    iter $P319, $P321
    new $P345, 'ExceptionHandler'
    set_label $P345, loop344_handler
    $P345."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P345
  loop344_test:
    unless $P319, loop344_done
    shift $P323, $P319
  loop344_redo:
    .const 'Sub' $P325 = "29_1298325483.2958" 
    capture_lex $P325
    $P325($P323)
  loop344_next:
    goto loop344_test
  loop344_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P346, exception, 'type'
    eq $P346, .CONTROL_LOOP_NEXT, loop344_next
    eq $P346, .CONTROL_LOOP_REDO, loop344_redo
  loop344_done:
    pop_eh 
  for_undef_208:
  if_316_end:
.annotate 'line', 90
    find_lex $P347, "$/"
    find_lex $P348, "$past"
    $P349 = $P347."!make"($P348)
.annotate 'line', 80
    .return ($P349)
.end


.namespace ["NQP";"Actions"]
.sub "_block324"  :anon :subid("29_1298325483.2958") :outer("28_1298325483.2958")
    .param pmc param_327
.annotate 'line', 84
    new $P326, "Undef"
    .lex "$ast", $P326
    .lex "$_", param_327
    find_lex $P328, "$_"
    $P329 = $P328."ast"()
    store_lex "$ast", $P329
.annotate 'line', 85
    find_lex $P331, "$ast"
    unless_null $P331, vivify_209
    $P331 = root_new ['parrot';'Hash']
  vivify_209:
    set $P332, $P331["sink"]
    unless_null $P332, vivify_210
    new $P332, "Undef"
  vivify_210:
    defined $I333, $P332
    unless $I333, if_330_end
    find_lex $P334, "$ast"
    unless_null $P334, vivify_211
    $P334 = root_new ['parrot';'Hash']
  vivify_211:
    set $P335, $P334["sink"]
    unless_null $P335, vivify_212
    new $P335, "Undef"
  vivify_212:
    store_lex "$ast", $P335
  if_330_end:
.annotate 'line', 86
    find_lex $P337, "$ast"
    unless_null $P337, vivify_213
    $P337 = root_new ['parrot';'Hash']
  vivify_213:
    set $P338, $P337["bareblock"]
    unless_null $P338, vivify_214
    new $P338, "Undef"
  vivify_214:
    unless $P338, if_336_end
    find_lex $P339, "$ast"
    $P340 = "block_immediate"($P339)
    store_lex "$ast", $P340
  if_336_end:
.annotate 'line', 87
    find_lex $P341, "$past"
    find_lex $P342, "$ast"
    $P343 = $P341."push"($P342)
.annotate 'line', 83
    .return ($P343)
.end


.namespace ["NQP";"Actions"]
.sub "statement"  :subid("30_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_351
    .param pmc param_352
    .param pmc param_353 :optional
    .param int has_param_353 :opt_flag
.annotate 'line', 93
    .const 'Sub' $P361 = "31_1298325483.2958" 
    capture_lex $P361
    .lex "self", param_351
    .lex "$/", param_352
    if has_param_353, optparam_215
    new $P354, "Undef"
    set param_353, $P354
  optparam_215:
    .lex "$key", param_353
.annotate 'line', 94
    new $P355, "Undef"
    .lex "$past", $P355
.annotate 'line', 93
    find_lex $P356, "$past"
.annotate 'line', 95
    find_lex $P358, "$/"
    unless_null $P358, vivify_216
    $P358 = root_new ['parrot';'Hash']
  vivify_216:
    set $P359, $P358["EXPR"]
    unless_null $P359, vivify_217
    new $P359, "Undef"
  vivify_217:
    if $P359, if_357
.annotate 'line', 116
    find_lex $P422, "$/"
    unless_null $P422, vivify_218
    $P422 = root_new ['parrot';'Hash']
  vivify_218:
    set $P423, $P422["statement_control"]
    unless_null $P423, vivify_219
    new $P423, "Undef"
  vivify_219:
    if $P423, if_421
.annotate 'line', 117
    new $P427, "Integer"
    assign $P427, 0
    store_lex "$past", $P427
    goto if_421_end
  if_421:
.annotate 'line', 116
    find_lex $P424, "$/"
    unless_null $P424, vivify_220
    $P424 = root_new ['parrot';'Hash']
  vivify_220:
    set $P425, $P424["statement_control"]
    unless_null $P425, vivify_221
    new $P425, "Undef"
  vivify_221:
    $P426 = $P425."ast"()
    store_lex "$past", $P426
  if_421_end:
    goto if_357_end
  if_357:
.annotate 'line', 95
    .const 'Sub' $P361 = "31_1298325483.2958" 
    capture_lex $P361
    $P361()
  if_357_end:
.annotate 'line', 118
    find_lex $P428, "$/"
    find_lex $P429, "$past"
    $P430 = $P428."!make"($P429)
.annotate 'line', 93
    .return ($P430)
.end


.namespace ["NQP";"Actions"]
.sub "_block360"  :anon :subid("31_1298325483.2958") :outer("30_1298325483.2958")
.annotate 'line', 96
    new $P362, "Undef"
    .lex "$mc", $P362
.annotate 'line', 97
    new $P363, "Undef"
    .lex "$ml", $P363
.annotate 'line', 96
    find_lex $P364, "$/"
    unless_null $P364, vivify_222
    $P364 = root_new ['parrot';'Hash']
  vivify_222:
    set $P365, $P364["statement_mod_cond"]
    unless_null $P365, vivify_223
    $P365 = root_new ['parrot';'ResizablePMCArray']
  vivify_223:
    set $P366, $P365[0]
    unless_null $P366, vivify_224
    new $P366, "Undef"
  vivify_224:
    store_lex "$mc", $P366
.annotate 'line', 97
    find_lex $P367, "$/"
    unless_null $P367, vivify_225
    $P367 = root_new ['parrot';'Hash']
  vivify_225:
    set $P368, $P367["statement_mod_loop"]
    unless_null $P368, vivify_226
    $P368 = root_new ['parrot';'ResizablePMCArray']
  vivify_226:
    set $P369, $P368[0]
    unless_null $P369, vivify_227
    new $P369, "Undef"
  vivify_227:
    store_lex "$ml", $P369
.annotate 'line', 98
    find_lex $P370, "$/"
    unless_null $P370, vivify_228
    $P370 = root_new ['parrot';'Hash']
  vivify_228:
    set $P371, $P370["EXPR"]
    unless_null $P371, vivify_229
    new $P371, "Undef"
  vivify_229:
    $P372 = $P371."ast"()
    store_lex "$past", $P372
.annotate 'line', 99
    find_lex $P374, "$mc"
    unless $P374, if_373_end
.annotate 'line', 100
    get_hll_global $P375, ["PAST"], "Op"
    find_lex $P376, "$mc"
    unless_null $P376, vivify_230
    $P376 = root_new ['parrot';'Hash']
  vivify_230:
    set $P377, $P376["cond"]
    unless_null $P377, vivify_231
    new $P377, "Undef"
  vivify_231:
    $P378 = $P377."ast"()
    find_lex $P379, "$past"
    find_lex $P380, "$mc"
    unless_null $P380, vivify_232
    $P380 = root_new ['parrot';'Hash']
  vivify_232:
    set $P381, $P380["sym"]
    unless_null $P381, vivify_233
    new $P381, "Undef"
  vivify_233:
    set $S382, $P381
    find_lex $P383, "$/"
    $P384 = $P375."new"($P378, $P379, $S382 :named("pasttype"), $P383 :named("node"))
    store_lex "$past", $P384
  if_373_end:
.annotate 'line', 102
    find_lex $P387, "$ml"
    if $P387, if_386
    set $P385, $P387
    goto if_386_end
  if_386:
.annotate 'line', 103
    find_lex $P390, "$ml"
    unless_null $P390, vivify_234
    $P390 = root_new ['parrot';'Hash']
  vivify_234:
    set $P391, $P390["sym"]
    unless_null $P391, vivify_235
    new $P391, "Undef"
  vivify_235:
    set $S392, $P391
    iseq $I393, $S392, "for"
    if $I393, if_389
.annotate 'line', 112
    get_hll_global $P411, ["PAST"], "Op"
    find_lex $P412, "$ml"
    unless_null $P412, vivify_236
    $P412 = root_new ['parrot';'Hash']
  vivify_236:
    set $P413, $P412["cond"]
    unless_null $P413, vivify_237
    new $P413, "Undef"
  vivify_237:
    $P414 = $P413."ast"()
    find_lex $P415, "$past"
    find_lex $P416, "$ml"
    unless_null $P416, vivify_238
    $P416 = root_new ['parrot';'Hash']
  vivify_238:
    set $P417, $P416["sym"]
    unless_null $P417, vivify_239
    new $P417, "Undef"
  vivify_239:
    set $S418, $P417
    find_lex $P419, "$/"
    $P420 = $P411."new"($P414, $P415, $S418 :named("pasttype"), $P419 :named("node"))
    store_lex "$past", $P420
.annotate 'line', 111
    set $P388, $P420
.annotate 'line', 103
    goto if_389_end
  if_389:
.annotate 'line', 104
    get_hll_global $P394, ["PAST"], "Block"
.annotate 'line', 105
    get_hll_global $P395, ["PAST"], "Var"
    $P396 = $P395."new"("$_" :named("name"), "parameter" :named("scope"), 1 :named("isdecl"))
    find_lex $P397, "$past"
    $P398 = $P394."new"($P396, $P397, "immediate" :named("blocktype"))
.annotate 'line', 104
    store_lex "$past", $P398
.annotate 'line', 107
    find_lex $P399, "$past"
    $P399."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 108
    find_lex $P400, "$past"
    $P400."arity"(1)
.annotate 'line', 109
    get_hll_global $P401, ["PAST"], "Op"
    find_lex $P402, "$ml"
    unless_null $P402, vivify_240
    $P402 = root_new ['parrot';'Hash']
  vivify_240:
    set $P403, $P402["cond"]
    unless_null $P403, vivify_241
    new $P403, "Undef"
  vivify_241:
    $P404 = $P403."ast"()
    find_lex $P405, "$past"
    find_lex $P406, "$ml"
    unless_null $P406, vivify_242
    $P406 = root_new ['parrot';'Hash']
  vivify_242:
    set $P407, $P406["sym"]
    unless_null $P407, vivify_243
    new $P407, "Undef"
  vivify_243:
    set $S408, $P407
    find_lex $P409, "$/"
    $P410 = $P401."new"($P404, $P405, $S408 :named("pasttype"), $P409 :named("node"))
    store_lex "$past", $P410
.annotate 'line', 103
    set $P388, $P410
  if_389_end:
.annotate 'line', 102
    set $P385, $P388
  if_386_end:
.annotate 'line', 95
    .return ($P385)
.end


.namespace ["NQP";"Actions"]
.sub "xblock"  :subid("32_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_432
    .param pmc param_433
.annotate 'line', 121
    .lex "self", param_432
    .lex "$/", param_433
.annotate 'line', 122
    find_lex $P434, "$/"
    get_hll_global $P435, ["PAST"], "Op"
    find_lex $P436, "$/"
    unless_null $P436, vivify_244
    $P436 = root_new ['parrot';'Hash']
  vivify_244:
    set $P437, $P436["EXPR"]
    unless_null $P437, vivify_245
    new $P437, "Undef"
  vivify_245:
    $P438 = $P437."ast"()
    find_lex $P439, "$/"
    unless_null $P439, vivify_246
    $P439 = root_new ['parrot';'Hash']
  vivify_246:
    set $P440, $P439["pblock"]
    unless_null $P440, vivify_247
    new $P440, "Undef"
  vivify_247:
    $P441 = $P440."ast"()
    find_lex $P442, "$/"
    $P443 = $P435."new"($P438, $P441, "if" :named("pasttype"), $P442 :named("node"))
    $P444 = $P434."!make"($P443)
.annotate 'line', 121
    .return ($P444)
.end


.namespace ["NQP";"Actions"]
.sub "pblock"  :subid("33_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_446
    .param pmc param_447
.annotate 'line', 125
    .lex "self", param_446
    .lex "$/", param_447
.annotate 'line', 126
    find_lex $P448, "$/"
    find_lex $P449, "$/"
    unless_null $P449, vivify_248
    $P449 = root_new ['parrot';'Hash']
  vivify_248:
    set $P450, $P449["blockoid"]
    unless_null $P450, vivify_249
    new $P450, "Undef"
  vivify_249:
    $P451 = $P450."ast"()
    $P452 = $P448."!make"($P451)
.annotate 'line', 125
    .return ($P452)
.end


.namespace ["NQP";"Actions"]
.sub "block"  :subid("34_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_454
    .param pmc param_455
.annotate 'line', 129
    .lex "self", param_454
    .lex "$/", param_455
.annotate 'line', 130
    find_lex $P456, "$/"
    find_lex $P457, "$/"
    unless_null $P457, vivify_250
    $P457 = root_new ['parrot';'Hash']
  vivify_250:
    set $P458, $P457["blockoid"]
    unless_null $P458, vivify_251
    new $P458, "Undef"
  vivify_251:
    $P459 = $P458."ast"()
    $P460 = $P456."!make"($P459)
.annotate 'line', 129
    .return ($P460)
.end


.namespace ["NQP";"Actions"]
.sub "blockoid"  :subid("35_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_462
    .param pmc param_463
.annotate 'line', 133
    .lex "self", param_462
    .lex "$/", param_463
.annotate 'line', 134
    new $P464, "Undef"
    .lex "$past", $P464
.annotate 'line', 135
    new $P465, "Undef"
    .lex "$BLOCK", $P465
.annotate 'line', 134
    find_lex $P466, "$/"
    unless_null $P466, vivify_252
    $P466 = root_new ['parrot';'Hash']
  vivify_252:
    set $P467, $P466["statementlist"]
    unless_null $P467, vivify_253
    new $P467, "Undef"
  vivify_253:
    $P468 = $P467."ast"()
    store_lex "$past", $P468
.annotate 'line', 135
    get_global $P469, "@BLOCK"
    $P470 = $P469."shift"()
    store_lex "$BLOCK", $P470
.annotate 'line', 136
    find_lex $P471, "$BLOCK"
    find_lex $P472, "$past"
    $P471."push"($P472)
.annotate 'line', 137
    find_lex $P473, "$BLOCK"
    find_lex $P474, "$/"
    $P473."node"($P474)
.annotate 'line', 138
    find_lex $P475, "$BLOCK"
    $P475."closure"(1)
.annotate 'line', 139
    find_lex $P476, "$/"
    find_lex $P477, "$BLOCK"
    $P478 = $P476."!make"($P477)
.annotate 'line', 133
    .return ($P478)
.end


.namespace ["NQP";"Actions"]
.sub "newpad"  :subid("36_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_480
    .param pmc param_481
.annotate 'line', 142
    .lex "self", param_480
    .lex "$/", param_481
.annotate 'line', 143
    get_global $P482, "@BLOCK"
    unless_null $P482, vivify_254
    $P482 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P482
  vivify_254:
.annotate 'line', 142
    get_global $P483, "@BLOCK"
.annotate 'line', 144
    get_global $P484, "@BLOCK"
    get_hll_global $P485, ["PAST"], "Block"
    get_hll_global $P486, ["PAST"], "Stmts"
    $P487 = $P486."new"()
    $P488 = $P485."new"($P487)
    $P489 = $P484."unshift"($P488)
.annotate 'line', 142
    .return ($P489)
.end


.namespace ["NQP";"Actions"]
.sub "outerctx"  :subid("37_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_491
    .param pmc param_492
.annotate 'line', 147
    .lex "self", param_491
    .lex "$/", param_492
.annotate 'line', 148
    get_global $P493, "@BLOCK"
    unless_null $P493, vivify_255
    $P493 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P493
  vivify_255:
.annotate 'line', 147
    get_global $P494, "@BLOCK"
.annotate 'line', 149
    find_lex $P495, "self"
    get_global $P496, "@BLOCK"
    unless_null $P496, vivify_256
    $P496 = root_new ['parrot';'ResizablePMCArray']
  vivify_256:
    set $P497, $P496[0]
    unless_null $P497, vivify_257
    new $P497, "Undef"
  vivify_257:
    $P498 = $P495."SET_BLOCK_OUTER_CTX"($P497)
.annotate 'line', 147
    .return ($P498)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statement_control:sym<if>"  :subid("38_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_500
    .param pmc param_501
.annotate 'line', 154
    .const 'Sub' $P529 = "39_1298325483.2958" 
    capture_lex $P529
    .lex "self", param_500
    .lex "$/", param_501
.annotate 'line', 155
    new $P502, "Undef"
    .lex "$count", $P502
.annotate 'line', 156
    new $P503, "Undef"
    .lex "$past", $P503
.annotate 'line', 155
    find_lex $P504, "$/"
    unless_null $P504, vivify_258
    $P504 = root_new ['parrot';'Hash']
  vivify_258:
    set $P505, $P504["xblock"]
    unless_null $P505, vivify_259
    new $P505, "Undef"
  vivify_259:
    set $N506, $P505
    new $P507, 'Float'
    set $P507, $N506
    sub $P508, $P507, 1
    store_lex "$count", $P508
.annotate 'line', 156
    find_lex $P509, "$count"
    set $I510, $P509
    find_lex $P511, "$/"
    unless_null $P511, vivify_260
    $P511 = root_new ['parrot';'Hash']
  vivify_260:
    set $P512, $P511["xblock"]
    unless_null $P512, vivify_261
    $P512 = root_new ['parrot';'ResizablePMCArray']
  vivify_261:
    set $P513, $P512[$I510]
    unless_null $P513, vivify_262
    new $P513, "Undef"
  vivify_262:
    $P514 = $P513."ast"()
    $P515 = "xblock_immediate"($P514)
    store_lex "$past", $P515
.annotate 'line', 157
    find_lex $P517, "$/"
    unless_null $P517, vivify_263
    $P517 = root_new ['parrot';'Hash']
  vivify_263:
    set $P518, $P517["else"]
    unless_null $P518, vivify_264
    new $P518, "Undef"
  vivify_264:
    unless $P518, if_516_end
.annotate 'line', 158
    find_lex $P519, "$past"
    find_lex $P520, "$/"
    unless_null $P520, vivify_265
    $P520 = root_new ['parrot';'Hash']
  vivify_265:
    set $P521, $P520["else"]
    unless_null $P521, vivify_266
    $P521 = root_new ['parrot';'ResizablePMCArray']
  vivify_266:
    set $P522, $P521[0]
    unless_null $P522, vivify_267
    new $P522, "Undef"
  vivify_267:
    $P523 = $P522."ast"()
    $P524 = "block_immediate"($P523)
    $P519."push"($P524)
  if_516_end:
.annotate 'line', 161
    new $P545, 'ExceptionHandler'
    set_label $P545, loop544_handler
    $P545."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P545
  loop544_test:
    find_lex $P525, "$count"
    set $N526, $P525
    isgt $I527, $N526, 0.0
    unless $I527, loop544_done
  loop544_redo:
    .const 'Sub' $P529 = "39_1298325483.2958" 
    capture_lex $P529
    $P529()
  loop544_next:
    goto loop544_test
  loop544_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P546, exception, 'type'
    eq $P546, .CONTROL_LOOP_NEXT, loop544_next
    eq $P546, .CONTROL_LOOP_REDO, loop544_redo
  loop544_done:
    pop_eh 
.annotate 'line', 167
    find_lex $P547, "$/"
    find_lex $P548, "$past"
    $P549 = $P547."!make"($P548)
.annotate 'line', 154
    .return ($P549)
.end


.namespace ["NQP";"Actions"]
.sub "_block528"  :anon :subid("39_1298325483.2958") :outer("38_1298325483.2958")
.annotate 'line', 163
    new $P530, "Undef"
    .lex "$else", $P530
.annotate 'line', 161
    find_lex $P531, "$count"
    clone $P532, $P531
    dec $P531
.annotate 'line', 163
    find_lex $P533, "$past"
    store_lex "$else", $P533
.annotate 'line', 164
    find_lex $P534, "$count"
    set $I535, $P534
    find_lex $P536, "$/"
    unless_null $P536, vivify_268
    $P536 = root_new ['parrot';'Hash']
  vivify_268:
    set $P537, $P536["xblock"]
    unless_null $P537, vivify_269
    $P537 = root_new ['parrot';'ResizablePMCArray']
  vivify_269:
    set $P538, $P537[$I535]
    unless_null $P538, vivify_270
    new $P538, "Undef"
  vivify_270:
    $P539 = $P538."ast"()
    $P540 = "xblock_immediate"($P539)
    store_lex "$past", $P540
.annotate 'line', 165
    find_lex $P541, "$past"
    find_lex $P542, "$else"
    $P543 = $P541."push"($P542)
.annotate 'line', 161
    .return ($P543)
.end


.namespace ["NQP";"Actions"]
.sub "statement_control:sym<unless>"  :subid("40_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_551
    .param pmc param_552
.annotate 'line', 170
    .lex "self", param_551
    .lex "$/", param_552
.annotate 'line', 171
    new $P553, "Undef"
    .lex "$past", $P553
    find_lex $P554, "$/"
    unless_null $P554, vivify_271
    $P554 = root_new ['parrot';'Hash']
  vivify_271:
    set $P555, $P554["xblock"]
    unless_null $P555, vivify_272
    new $P555, "Undef"
  vivify_272:
    $P556 = $P555."ast"()
    $P557 = "xblock_immediate"($P556)
    store_lex "$past", $P557
.annotate 'line', 172
    find_lex $P558, "$past"
    $P558."pasttype"("unless")
.annotate 'line', 173
    find_lex $P559, "$/"
    find_lex $P560, "$past"
    $P561 = $P559."!make"($P560)
.annotate 'line', 170
    .return ($P561)
.end


.namespace ["NQP";"Actions"]
.sub "statement_control:sym<while>"  :subid("41_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_563
    .param pmc param_564
.annotate 'line', 176
    .lex "self", param_563
    .lex "$/", param_564
.annotate 'line', 177
    new $P565, "Undef"
    .lex "$past", $P565
    find_lex $P566, "$/"
    unless_null $P566, vivify_273
    $P566 = root_new ['parrot';'Hash']
  vivify_273:
    set $P567, $P566["xblock"]
    unless_null $P567, vivify_274
    new $P567, "Undef"
  vivify_274:
    $P568 = $P567."ast"()
    $P569 = "xblock_immediate"($P568)
    store_lex "$past", $P569
.annotate 'line', 178
    find_lex $P570, "$past"
    find_lex $P571, "$/"
    unless_null $P571, vivify_275
    $P571 = root_new ['parrot';'Hash']
  vivify_275:
    set $P572, $P571["sym"]
    unless_null $P572, vivify_276
    new $P572, "Undef"
  vivify_276:
    set $S573, $P572
    $P570."pasttype"($S573)
.annotate 'line', 179
    find_lex $P574, "$/"
    find_lex $P575, "$past"
    $P576 = $P574."!make"($P575)
.annotate 'line', 176
    .return ($P576)
.end


.namespace ["NQP";"Actions"]
.sub "statement_control:sym<repeat>"  :subid("42_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_578
    .param pmc param_579
.annotate 'line', 182
    .lex "self", param_578
    .lex "$/", param_579
.annotate 'line', 183
    new $P580, "Undef"
    .lex "$pasttype", $P580
.annotate 'line', 184
    new $P581, "Undef"
    .lex "$past", $P581
.annotate 'line', 183
    new $P582, "String"
    assign $P582, "repeat_"
    find_lex $P583, "$/"
    unless_null $P583, vivify_277
    $P583 = root_new ['parrot';'Hash']
  vivify_277:
    set $P584, $P583["wu"]
    unless_null $P584, vivify_278
    new $P584, "Undef"
  vivify_278:
    set $S585, $P584
    concat $P586, $P582, $S585
    store_lex "$pasttype", $P586
    find_lex $P587, "$past"
.annotate 'line', 185
    find_lex $P589, "$/"
    unless_null $P589, vivify_279
    $P589 = root_new ['parrot';'Hash']
  vivify_279:
    set $P590, $P589["xblock"]
    unless_null $P590, vivify_280
    new $P590, "Undef"
  vivify_280:
    if $P590, if_588
.annotate 'line', 190
    get_hll_global $P597, ["PAST"], "Op"
    find_lex $P598, "$/"
    unless_null $P598, vivify_281
    $P598 = root_new ['parrot';'Hash']
  vivify_281:
    set $P599, $P598["EXPR"]
    unless_null $P599, vivify_282
    new $P599, "Undef"
  vivify_282:
    $P600 = $P599."ast"()
    find_lex $P601, "$/"
    unless_null $P601, vivify_283
    $P601 = root_new ['parrot';'Hash']
  vivify_283:
    set $P602, $P601["pblock"]
    unless_null $P602, vivify_284
    new $P602, "Undef"
  vivify_284:
    $P603 = $P602."ast"()
    $P604 = "block_immediate"($P603)
    find_lex $P605, "$pasttype"
    find_lex $P606, "$/"
    $P607 = $P597."new"($P600, $P604, $P605 :named("pasttype"), $P606 :named("node"))
    store_lex "$past", $P607
.annotate 'line', 189
    goto if_588_end
  if_588:
.annotate 'line', 186
    find_lex $P591, "$/"
    unless_null $P591, vivify_285
    $P591 = root_new ['parrot';'Hash']
  vivify_285:
    set $P592, $P591["xblock"]
    unless_null $P592, vivify_286
    new $P592, "Undef"
  vivify_286:
    $P593 = $P592."ast"()
    $P594 = "xblock_immediate"($P593)
    store_lex "$past", $P594
.annotate 'line', 187
    find_lex $P595, "$past"
    find_lex $P596, "$pasttype"
    $P595."pasttype"($P596)
  if_588_end:
.annotate 'line', 193
    find_lex $P608, "$/"
    find_lex $P609, "$past"
    $P610 = $P608."!make"($P609)
.annotate 'line', 182
    .return ($P610)
.end


.namespace ["NQP";"Actions"]
.sub "statement_control:sym<for>"  :subid("43_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_612
    .param pmc param_613
.annotate 'line', 196
    .lex "self", param_612
    .lex "$/", param_613
.annotate 'line', 197
    new $P614, "Undef"
    .lex "$past", $P614
.annotate 'line', 199
    new $P615, "Undef"
    .lex "$block", $P615
.annotate 'line', 197
    find_lex $P616, "$/"
    unless_null $P616, vivify_287
    $P616 = root_new ['parrot';'Hash']
  vivify_287:
    set $P617, $P616["xblock"]
    unless_null $P617, vivify_288
    new $P617, "Undef"
  vivify_288:
    $P618 = $P617."ast"()
    store_lex "$past", $P618
.annotate 'line', 198
    find_lex $P619, "$past"
    $P619."pasttype"("for")
.annotate 'line', 199
    find_lex $P620, "$past"
    unless_null $P620, vivify_289
    $P620 = root_new ['parrot';'ResizablePMCArray']
  vivify_289:
    set $P621, $P620[1]
    unless_null $P621, vivify_290
    new $P621, "Undef"
  vivify_290:
    store_lex "$block", $P621
.annotate 'line', 200
    find_lex $P623, "$block"
    $P624 = $P623."arity"()
    if $P624, unless_622_end
.annotate 'line', 201
    find_lex $P625, "$block"
    unless_null $P625, vivify_291
    $P625 = root_new ['parrot';'ResizablePMCArray']
  vivify_291:
    set $P626, $P625[0]
    unless_null $P626, vivify_292
    new $P626, "Undef"
  vivify_292:
    get_hll_global $P627, ["PAST"], "Var"
    $P628 = $P627."new"("$_" :named("name"), "parameter" :named("scope"))
    $P626."push"($P628)
.annotate 'line', 202
    find_lex $P629, "$block"
    $P629."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 203
    find_lex $P630, "$block"
    $P630."arity"(1)
  unless_622_end:
.annotate 'line', 205
    find_lex $P631, "$block"
    $P631."blocktype"("immediate")
.annotate 'line', 206
    find_lex $P632, "$/"
    find_lex $P633, "$past"
    $P634 = $P632."!make"($P633)
.annotate 'line', 196
    .return ($P634)
.end


.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CATCH>"  :subid("44_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_636
    .param pmc param_637
.annotate 'line', 209
    .lex "self", param_636
    .lex "$/", param_637
.annotate 'line', 210
    new $P638, "Undef"
    .lex "$block", $P638
    find_lex $P639, "$/"
    unless_null $P639, vivify_293
    $P639 = root_new ['parrot';'Hash']
  vivify_293:
    set $P640, $P639["block"]
    unless_null $P640, vivify_294
    new $P640, "Undef"
  vivify_294:
    $P641 = $P640."ast"()
    store_lex "$block", $P641
.annotate 'line', 211
    find_lex $P642, "$/"
    find_lex $P643, "$block"
    "push_block_handler"($P642, $P643)
.annotate 'line', 212
    get_global $P644, "@BLOCK"
    unless_null $P644, vivify_295
    $P644 = root_new ['parrot';'ResizablePMCArray']
  vivify_295:
    set $P645, $P644[0]
    unless_null $P645, vivify_296
    new $P645, "Undef"
  vivify_296:
    $P646 = $P645."handlers"()
    set $P647, $P646[0]
    unless_null $P647, vivify_297
    new $P647, "Undef"
  vivify_297:
    $P647."handle_types_except"("CONTROL")
.annotate 'line', 213
    find_lex $P648, "$/"
    get_hll_global $P649, ["PAST"], "Stmts"
    find_lex $P650, "$/"
    $P651 = $P649."new"($P650 :named("node"))
    $P652 = $P648."!make"($P651)
.annotate 'line', 209
    .return ($P652)
.end


.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CONTROL>"  :subid("45_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_654
    .param pmc param_655
.annotate 'line', 216
    .lex "self", param_654
    .lex "$/", param_655
.annotate 'line', 217
    new $P656, "Undef"
    .lex "$block", $P656
    find_lex $P657, "$/"
    unless_null $P657, vivify_298
    $P657 = root_new ['parrot';'Hash']
  vivify_298:
    set $P658, $P657["block"]
    unless_null $P658, vivify_299
    new $P658, "Undef"
  vivify_299:
    $P659 = $P658."ast"()
    store_lex "$block", $P659
.annotate 'line', 218
    find_lex $P660, "$/"
    find_lex $P661, "$block"
    "push_block_handler"($P660, $P661)
.annotate 'line', 219
    get_global $P662, "@BLOCK"
    unless_null $P662, vivify_300
    $P662 = root_new ['parrot';'ResizablePMCArray']
  vivify_300:
    set $P663, $P662[0]
    unless_null $P663, vivify_301
    new $P663, "Undef"
  vivify_301:
    $P664 = $P663."handlers"()
    set $P665, $P664[0]
    unless_null $P665, vivify_302
    new $P665, "Undef"
  vivify_302:
    $P665."handle_types"("CONTROL")
.annotate 'line', 220
    find_lex $P666, "$/"
    get_hll_global $P667, ["PAST"], "Stmts"
    find_lex $P668, "$/"
    $P669 = $P667."new"($P668 :named("node"))
    $P670 = $P666."!make"($P669)
.annotate 'line', 216
    .return ($P670)
.end


.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<INIT>"  :subid("46_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_673
    .param pmc param_674
.annotate 'line', 260
    .lex "self", param_673
    .lex "$/", param_674
.annotate 'line', 261
    new $P675, "Undef"
    .lex "$init_block", $P675
    get_hll_global $P676, ["PAST"], "Block"
    $P677 = $P676."new"("immediate" :named("blocktype"))
    store_lex "$init_block", $P677
.annotate 'line', 262
    find_lex $P678, "$init_block"
    $P679 = $P678."loadinit"()
    find_lex $P680, "$/"
    unless_null $P680, vivify_303
    $P680 = root_new ['parrot';'Hash']
  vivify_303:
    set $P681, $P680["blorst"]
    unless_null $P681, vivify_304
    new $P681, "Undef"
  vivify_304:
    $P682 = $P681."ast"()
    $P679."push"($P682)
.annotate 'line', 263
    find_lex $P683, "$/"
    find_lex $P684, "$init_block"
    $P685 = $P683."!make"($P684)
.annotate 'line', 260
    .return ($P685)
.end


.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<try>"  :subid("47_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_687
    .param pmc param_688
.annotate 'line', 266
    .lex "self", param_687
    .lex "$/", param_688
.annotate 'line', 267
    new $P689, "Undef"
    .lex "$past", $P689
    find_lex $P690, "$/"
    unless_null $P690, vivify_305
    $P690 = root_new ['parrot';'Hash']
  vivify_305:
    set $P691, $P690["blorst"]
    unless_null $P691, vivify_306
    new $P691, "Undef"
  vivify_306:
    $P692 = $P691."ast"()
    store_lex "$past", $P692
.annotate 'line', 268
    get_hll_global $P694, ["PAST"], "Block"
    find_lex $P695, "$past"
    $P696 = $P694."ACCEPTS"($P695)
    if $P696, unless_693_end
.annotate 'line', 269
    get_hll_global $P697, ["PAST"], "Block"
    find_lex $P698, "$past"
    find_lex $P699, "$/"
    $P700 = $P697."new"($P698, "immediate" :named("blocktype"), $P699 :named("node"))
    store_lex "$past", $P700
  unless_693_end:
.annotate 'line', 271
    find_lex $P702, "$past"
    $P703 = $P702."handlers"()
    if $P703, unless_701_end
.annotate 'line', 272
    find_lex $P704, "$past"
    get_hll_global $P705, ["PAST"], "Control"
.annotate 'line', 274
    get_hll_global $P706, ["PAST"], "Stmts"
.annotate 'line', 275
    get_hll_global $P707, ["PAST"], "Op"
.annotate 'line', 276
    get_hll_global $P708, ["PAST"], "Var"
.annotate 'line', 277
    get_hll_global $P709, ["PAST"], "Var"
    $P710 = $P709."new"("register" :named("scope"), "exception" :named("name"))
    $P711 = $P708."new"($P710, "handled", "keyed" :named("scope"))
.annotate 'line', 276
    $P712 = $P707."new"($P711, 1, "bind" :named("pasttype"))
.annotate 'line', 275
    $P713 = $P706."new"($P712)
.annotate 'line', 274
    $P714 = $P705."new"($P713, "CONTROL" :named("handle_types_except"))
.annotate 'line', 272
    new $P715, "ResizablePMCArray"
    push $P715, $P714
    $P704."handlers"($P715)
  unless_701_end:
.annotate 'line', 286
    find_lex $P716, "$/"
    find_lex $P717, "$past"
    $P718 = $P716."!make"($P717)
.annotate 'line', 266
    .return ($P718)
.end


.namespace ["NQP";"Actions"]
.sub "blorst"  :subid("48_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_720
    .param pmc param_721
.annotate 'line', 289
    .lex "self", param_720
    .lex "$/", param_721
.annotate 'line', 290
    find_lex $P722, "$/"
.annotate 'line', 291
    find_lex $P725, "$/"
    unless_null $P725, vivify_307
    $P725 = root_new ['parrot';'Hash']
  vivify_307:
    set $P726, $P725["block"]
    unless_null $P726, vivify_308
    new $P726, "Undef"
  vivify_308:
    if $P726, if_724
.annotate 'line', 292
    find_lex $P731, "$/"
    unless_null $P731, vivify_309
    $P731 = root_new ['parrot';'Hash']
  vivify_309:
    set $P732, $P731["statement"]
    unless_null $P732, vivify_310
    new $P732, "Undef"
  vivify_310:
    $P733 = $P732."ast"()
    set $P723, $P733
.annotate 'line', 291
    goto if_724_end
  if_724:
    find_lex $P727, "$/"
    unless_null $P727, vivify_311
    $P727 = root_new ['parrot';'Hash']
  vivify_311:
    set $P728, $P727["block"]
    unless_null $P728, vivify_312
    new $P728, "Undef"
  vivify_312:
    $P729 = $P728."ast"()
    $P730 = "block_immediate"($P729)
    set $P723, $P730
  if_724_end:
    $P734 = $P722."!make"($P723)
.annotate 'line', 289
    .return ($P734)
.end


.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<if>"  :subid("49_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_736
    .param pmc param_737
.annotate 'line', 297
    .lex "self", param_736
    .lex "$/", param_737
    find_lex $P738, "$/"
    find_lex $P739, "$/"
    unless_null $P739, vivify_313
    $P739 = root_new ['parrot';'Hash']
  vivify_313:
    set $P740, $P739["cond"]
    unless_null $P740, vivify_314
    new $P740, "Undef"
  vivify_314:
    $P741 = $P740."ast"()
    $P742 = $P738."!make"($P741)
    .return ($P742)
.end


.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<unless>"  :subid("50_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_744
    .param pmc param_745
.annotate 'line', 298
    .lex "self", param_744
    .lex "$/", param_745
    find_lex $P746, "$/"
    find_lex $P747, "$/"
    unless_null $P747, vivify_315
    $P747 = root_new ['parrot';'Hash']
  vivify_315:
    set $P748, $P747["cond"]
    unless_null $P748, vivify_316
    new $P748, "Undef"
  vivify_316:
    $P749 = $P748."ast"()
    $P750 = $P746."!make"($P749)
    .return ($P750)
.end


.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<while>"  :subid("51_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_752
    .param pmc param_753
.annotate 'line', 300
    .lex "self", param_752
    .lex "$/", param_753
    find_lex $P754, "$/"
    find_lex $P755, "$/"
    unless_null $P755, vivify_317
    $P755 = root_new ['parrot';'Hash']
  vivify_317:
    set $P756, $P755["cond"]
    unless_null $P756, vivify_318
    new $P756, "Undef"
  vivify_318:
    $P757 = $P756."ast"()
    $P758 = $P754."!make"($P757)
    .return ($P758)
.end


.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<until>"  :subid("52_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_760
    .param pmc param_761
.annotate 'line', 301
    .lex "self", param_760
    .lex "$/", param_761
    find_lex $P762, "$/"
    find_lex $P763, "$/"
    unless_null $P763, vivify_319
    $P763 = root_new ['parrot';'Hash']
  vivify_319:
    set $P764, $P763["cond"]
    unless_null $P764, vivify_320
    new $P764, "Undef"
  vivify_320:
    $P765 = $P764."ast"()
    $P766 = $P762."!make"($P765)
    .return ($P766)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<fatarrow>"  :subid("53_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_768
    .param pmc param_769
.annotate 'line', 305
    .lex "self", param_768
    .lex "$/", param_769
    find_lex $P770, "$/"
    find_lex $P771, "$/"
    unless_null $P771, vivify_321
    $P771 = root_new ['parrot';'Hash']
  vivify_321:
    set $P772, $P771["fatarrow"]
    unless_null $P772, vivify_322
    new $P772, "Undef"
  vivify_322:
    $P773 = $P772."ast"()
    $P774 = $P770."!make"($P773)
    .return ($P774)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<colonpair>"  :subid("54_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_776
    .param pmc param_777
.annotate 'line', 306
    .lex "self", param_776
    .lex "$/", param_777
    find_lex $P778, "$/"
    find_lex $P779, "$/"
    unless_null $P779, vivify_323
    $P779 = root_new ['parrot';'Hash']
  vivify_323:
    set $P780, $P779["colonpair"]
    unless_null $P780, vivify_324
    new $P780, "Undef"
  vivify_324:
    $P781 = $P780."ast"()
    $P782 = $P778."!make"($P781)
    .return ($P782)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<variable>"  :subid("55_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_784
    .param pmc param_785
.annotate 'line', 307
    .lex "self", param_784
    .lex "$/", param_785
    find_lex $P786, "$/"
    find_lex $P787, "$/"
    unless_null $P787, vivify_325
    $P787 = root_new ['parrot';'Hash']
  vivify_325:
    set $P788, $P787["variable"]
    unless_null $P788, vivify_326
    new $P788, "Undef"
  vivify_326:
    $P789 = $P788."ast"()
    $P790 = $P786."!make"($P789)
    .return ($P790)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<package_declarator>"  :subid("56_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_792
    .param pmc param_793
.annotate 'line', 308
    .lex "self", param_792
    .lex "$/", param_793
    find_lex $P794, "$/"
    find_lex $P795, "$/"
    unless_null $P795, vivify_327
    $P795 = root_new ['parrot';'Hash']
  vivify_327:
    set $P796, $P795["package_declarator"]
    unless_null $P796, vivify_328
    new $P796, "Undef"
  vivify_328:
    $P797 = $P796."ast"()
    $P798 = $P794."!make"($P797)
    .return ($P798)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<scope_declarator>"  :subid("57_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_800
    .param pmc param_801
.annotate 'line', 309
    .lex "self", param_800
    .lex "$/", param_801
    find_lex $P802, "$/"
    find_lex $P803, "$/"
    unless_null $P803, vivify_329
    $P803 = root_new ['parrot';'Hash']
  vivify_329:
    set $P804, $P803["scope_declarator"]
    unless_null $P804, vivify_330
    new $P804, "Undef"
  vivify_330:
    $P805 = $P804."ast"()
    $P806 = $P802."!make"($P805)
    .return ($P806)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<routine_declarator>"  :subid("58_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_808
    .param pmc param_809
.annotate 'line', 310
    .lex "self", param_808
    .lex "$/", param_809
    find_lex $P810, "$/"
    find_lex $P811, "$/"
    unless_null $P811, vivify_331
    $P811 = root_new ['parrot';'Hash']
  vivify_331:
    set $P812, $P811["routine_declarator"]
    unless_null $P812, vivify_332
    new $P812, "Undef"
  vivify_332:
    $P813 = $P812."ast"()
    $P814 = $P810."!make"($P813)
    .return ($P814)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<regex_declarator>"  :subid("59_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_816
    .param pmc param_817
.annotate 'line', 311
    .lex "self", param_816
    .lex "$/", param_817
    find_lex $P818, "$/"
    find_lex $P819, "$/"
    unless_null $P819, vivify_333
    $P819 = root_new ['parrot';'Hash']
  vivify_333:
    set $P820, $P819["regex_declarator"]
    unless_null $P820, vivify_334
    new $P820, "Undef"
  vivify_334:
    $P821 = $P820."ast"()
    $P822 = $P818."!make"($P821)
    .return ($P822)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<statement_prefix>"  :subid("60_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_824
    .param pmc param_825
.annotate 'line', 312
    .lex "self", param_824
    .lex "$/", param_825
    find_lex $P826, "$/"
    find_lex $P827, "$/"
    unless_null $P827, vivify_335
    $P827 = root_new ['parrot';'Hash']
  vivify_335:
    set $P828, $P827["statement_prefix"]
    unless_null $P828, vivify_336
    new $P828, "Undef"
  vivify_336:
    $P829 = $P828."ast"()
    $P830 = $P826."!make"($P829)
    .return ($P830)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<lambda>"  :subid("61_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_832
    .param pmc param_833
.annotate 'line', 313
    .lex "self", param_832
    .lex "$/", param_833
    find_lex $P834, "$/"
    find_lex $P835, "$/"
    unless_null $P835, vivify_337
    $P835 = root_new ['parrot';'Hash']
  vivify_337:
    set $P836, $P835["pblock"]
    unless_null $P836, vivify_338
    new $P836, "Undef"
  vivify_338:
    $P837 = $P836."ast"()
    $P838 = $P834."!make"($P837)
    .return ($P838)
.end


.namespace ["NQP";"Actions"]
.sub "fatarrow"  :subid("62_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_840
    .param pmc param_841
.annotate 'line', 315
    .lex "self", param_840
    .lex "$/", param_841
.annotate 'line', 316
    new $P842, "Undef"
    .lex "$past", $P842
    find_lex $P843, "$/"
    unless_null $P843, vivify_339
    $P843 = root_new ['parrot';'Hash']
  vivify_339:
    set $P844, $P843["val"]
    unless_null $P844, vivify_340
    new $P844, "Undef"
  vivify_340:
    $P845 = $P844."ast"()
    store_lex "$past", $P845
.annotate 'line', 317
    find_lex $P846, "$past"
    find_lex $P847, "$/"
    unless_null $P847, vivify_341
    $P847 = root_new ['parrot';'Hash']
  vivify_341:
    set $P848, $P847["key"]
    unless_null $P848, vivify_342
    new $P848, "Undef"
  vivify_342:
    $P849 = $P848."Str"()
    $P846."named"($P849)
.annotate 'line', 318
    find_lex $P850, "$/"
    find_lex $P851, "$past"
    $P852 = $P850."!make"($P851)
.annotate 'line', 315
    .return ($P852)
.end


.namespace ["NQP";"Actions"]
.sub "colonpair"  :subid("63_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_854
    .param pmc param_855
.annotate 'line', 321
    .lex "self", param_854
    .lex "$/", param_855
.annotate 'line', 322
    new $P856, "Undef"
    .lex "$past", $P856
.annotate 'line', 323
    find_lex $P859, "$/"
    unless_null $P859, vivify_343
    $P859 = root_new ['parrot';'Hash']
  vivify_343:
    set $P860, $P859["circumfix"]
    unless_null $P860, vivify_344
    new $P860, "Undef"
  vivify_344:
    if $P860, if_858
.annotate 'line', 324
    get_hll_global $P865, ["PAST"], "Val"
    find_lex $P866, "$/"
    unless_null $P866, vivify_345
    $P866 = root_new ['parrot';'Hash']
  vivify_345:
    set $P867, $P866["not"]
    unless_null $P867, vivify_346
    new $P867, "Undef"
  vivify_346:
    isfalse $I868, $P867
    $P869 = $P865."new"($I868 :named("value"))
    set $P857, $P869
.annotate 'line', 323
    goto if_858_end
  if_858:
    find_lex $P861, "$/"
    unless_null $P861, vivify_347
    $P861 = root_new ['parrot';'Hash']
  vivify_347:
    set $P862, $P861["circumfix"]
    unless_null $P862, vivify_348
    $P862 = root_new ['parrot';'ResizablePMCArray']
  vivify_348:
    set $P863, $P862[0]
    unless_null $P863, vivify_349
    new $P863, "Undef"
  vivify_349:
    $P864 = $P863."ast"()
    set $P857, $P864
  if_858_end:
    store_lex "$past", $P857
.annotate 'line', 325
    find_lex $P870, "$past"
    find_lex $P871, "$/"
    unless_null $P871, vivify_350
    $P871 = root_new ['parrot';'Hash']
  vivify_350:
    set $P872, $P871["identifier"]
    unless_null $P872, vivify_351
    new $P872, "Undef"
  vivify_351:
    set $S873, $P872
    $P870."named"($S873)
.annotate 'line', 326
    find_lex $P874, "$/"
    find_lex $P875, "$past"
    $P876 = $P874."!make"($P875)
.annotate 'line', 321
    .return ($P876)
.end


.namespace ["NQP";"Actions"]
.sub "variable"  :subid("64_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_878
    .param pmc param_879
.annotate 'line', 329
    .const 'Sub' $P892 = "65_1298325483.2958" 
    capture_lex $P892
    .lex "self", param_878
    .lex "$/", param_879
.annotate 'line', 330
    new $P880, "Undef"
    .lex "$past", $P880
.annotate 'line', 329
    find_lex $P881, "$past"
.annotate 'line', 331
    find_lex $P883, "$/"
    unless_null $P883, vivify_352
    $P883 = root_new ['parrot';'Hash']
  vivify_352:
    set $P884, $P883["postcircumfix"]
    unless_null $P884, vivify_353
    new $P884, "Undef"
  vivify_353:
    if $P884, if_882
.annotate 'line', 335
    .const 'Sub' $P892 = "65_1298325483.2958" 
    capture_lex $P892
    $P892()
    goto if_882_end
  if_882:
.annotate 'line', 332
    find_lex $P885, "$/"
    unless_null $P885, vivify_370
    $P885 = root_new ['parrot';'Hash']
  vivify_370:
    set $P886, $P885["postcircumfix"]
    unless_null $P886, vivify_371
    new $P886, "Undef"
  vivify_371:
    $P887 = $P886."ast"()
    store_lex "$past", $P887
.annotate 'line', 333
    find_lex $P888, "$past"
    get_hll_global $P889, ["PAST"], "Var"
    $P890 = $P889."new"("$/" :named("name"))
    $P888."unshift"($P890)
  if_882_end:
.annotate 'line', 365
    find_lex $P964, "$/"
    find_lex $P965, "$past"
    $P966 = $P964."!make"($P965)
.annotate 'line', 329
    .return ($P966)
.end


.namespace ["NQP";"Actions"]
.sub "_block891"  :anon :subid("65_1298325483.2958") :outer("64_1298325483.2958")
.annotate 'line', 336
    $P893 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P893
    get_hll_global $P894, ["NQP"], "Compiler"
    find_lex $P895, "$/"
    set $S896, $P895
    $P897 = $P894."parse_name"($S896)
    store_lex "@name", $P897
.annotate 'line', 337
    get_hll_global $P898, ["PAST"], "Var"
    find_lex $P899, "@name"
    $P900 = $P899."pop"()
    set $S901, $P900
    $P902 = $P898."new"($S901 :named("name"))
    store_lex "$past", $P902
.annotate 'line', 338
    find_lex $P904, "@name"
    unless $P904, if_903_end
.annotate 'line', 339
    find_lex $P906, "@name"
    unless_null $P906, vivify_354
    $P906 = root_new ['parrot';'ResizablePMCArray']
  vivify_354:
    set $P907, $P906[0]
    unless_null $P907, vivify_355
    new $P907, "Undef"
  vivify_355:
    set $S908, $P907
    iseq $I909, $S908, "GLOBAL"
    unless $I909, if_905_end
    find_lex $P910, "@name"
    $P910."shift"()
  if_905_end:
.annotate 'line', 340
    find_lex $P911, "$past"
    find_lex $P912, "@name"
    $P911."namespace"($P912)
.annotate 'line', 341
    find_lex $P913, "$past"
    $P913."scope"("package")
.annotate 'line', 342
    find_lex $P914, "$past"
    find_lex $P915, "$/"
    unless_null $P915, vivify_356
    $P915 = root_new ['parrot';'Hash']
  vivify_356:
    set $P916, $P915["sigil"]
    unless_null $P916, vivify_357
    new $P916, "Undef"
  vivify_357:
    $P917 = "vivitype"($P916)
    $P914."viviself"($P917)
.annotate 'line', 343
    find_lex $P918, "$past"
    $P918."lvalue"(1)
  if_903_end:
.annotate 'line', 345
    find_lex $P921, "$/"
    unless_null $P921, vivify_358
    $P921 = root_new ['parrot';'Hash']
  vivify_358:
    set $P922, $P921["twigil"]
    unless_null $P922, vivify_359
    $P922 = root_new ['parrot';'ResizablePMCArray']
  vivify_359:
    set $P923, $P922[0]
    unless_null $P923, vivify_360
    new $P923, "Undef"
  vivify_360:
    set $S924, $P923
    iseq $I925, $S924, "*"
    if $I925, if_920
.annotate 'line', 358
    find_lex $P947, "$/"
    unless_null $P947, vivify_361
    $P947 = root_new ['parrot';'Hash']
  vivify_361:
    set $P948, $P947["twigil"]
    unless_null $P948, vivify_362
    $P948 = root_new ['parrot';'ResizablePMCArray']
  vivify_362:
    set $P949, $P948[0]
    unless_null $P949, vivify_363
    new $P949, "Undef"
  vivify_363:
    set $S950, $P949
    iseq $I951, $S950, "!"
    if $I951, if_946
    new $P945, 'Integer'
    set $P945, $I951
    goto if_946_end
  if_946:
.annotate 'line', 359
    find_lex $P952, "$past"
    get_hll_global $P953, ["PAST"], "Var"
    $P954 = $P953."new"("self" :named("name"))
    $P952."push"($P954)
.annotate 'line', 360
    find_lex $P955, "$past"
    $P955."scope"("attribute")
.annotate 'line', 361
    find_lex $P956, "$past"
    find_lex $P957, "$/"
    unless_null $P957, vivify_364
    $P957 = root_new ['parrot';'Hash']
  vivify_364:
    set $P958, $P957["sigil"]
    unless_null $P958, vivify_365
    new $P958, "Undef"
  vivify_365:
    $P959 = "vivitype"($P958)
    $P956."viviself"($P959)
.annotate 'line', 362
    find_lex $P960, "$past"
    get_hll_global $P961, ["PAST"], "Var"
    $P962 = $P961."new"("$?CLASS" :named("name"))
    $P963 = $P960."push"($P962)
.annotate 'line', 358
    set $P945, $P963
  if_946_end:
    set $P919, $P945
.annotate 'line', 345
    goto if_920_end
  if_920:
.annotate 'line', 346
    find_lex $P926, "$past"
    $P926."scope"("contextual")
.annotate 'line', 347
    find_lex $P927, "$past"
.annotate 'line', 348
    get_hll_global $P928, ["PAST"], "Var"
.annotate 'line', 350
    find_lex $P929, "$/"
    unless_null $P929, vivify_366
    $P929 = root_new ['parrot';'Hash']
  vivify_366:
    set $P930, $P929["sigil"]
    unless_null $P930, vivify_367
    new $P930, "Undef"
  vivify_367:
    set $S931, $P930
    new $P932, 'String'
    set $P932, $S931
    find_lex $P933, "$/"
    unless_null $P933, vivify_368
    $P933 = root_new ['parrot';'Hash']
  vivify_368:
    set $P934, $P933["desigilname"]
    unless_null $P934, vivify_369
    new $P934, "Undef"
  vivify_369:
    concat $P935, $P932, $P934
.annotate 'line', 352
    get_hll_global $P936, ["PAST"], "Op"
    new $P937, "String"
    assign $P937, "Contextual "
    find_lex $P938, "$/"
    set $S939, $P938
    concat $P940, $P937, $S939
    concat $P941, $P940, " not found"
    $P942 = $P936."new"($P941, "die" :named("pirop"))
    $P943 = $P928."new"("package" :named("scope"), "" :named("namespace"), $P935 :named("name"), $P942 :named("viviself"))
.annotate 'line', 348
    $P944 = $P927."viviself"($P943)
.annotate 'line', 345
    set $P919, $P944
  if_920_end:
.annotate 'line', 335
    .return ($P919)
.end


.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<module>"  :subid("66_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_968
    .param pmc param_969
.annotate 'line', 368
    .lex "self", param_968
    .lex "$/", param_969
    find_lex $P970, "$/"
    find_lex $P971, "$/"
    unless_null $P971, vivify_372
    $P971 = root_new ['parrot';'Hash']
  vivify_372:
    set $P972, $P971["package_def"]
    unless_null $P972, vivify_373
    new $P972, "Undef"
  vivify_373:
    $P973 = $P972."ast"()
    $P974 = $P970."!make"($P973)
    .return ($P974)
.end


.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<knowhow>"  :subid("67_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_976
    .param pmc param_977
.annotate 'line', 369
    .lex "self", param_976
    .lex "$/", param_977
    find_lex $P978, "$/"
    find_lex $P979, "$/"
    unless_null $P979, vivify_374
    $P979 = root_new ['parrot';'Hash']
  vivify_374:
    set $P980, $P979["package_def"]
    unless_null $P980, vivify_375
    new $P980, "Undef"
  vivify_375:
    $P981 = $P980."ast"()
    $P982 = $P978."!make"($P981)
    .return ($P982)
.end


.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<class>"  :subid("68_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_984
    .param pmc param_985
.annotate 'line', 370
    .lex "self", param_984
    .lex "$/", param_985
    find_lex $P986, "$/"
    find_lex $P987, "$/"
    unless_null $P987, vivify_376
    $P987 = root_new ['parrot';'Hash']
  vivify_376:
    set $P988, $P987["package_def"]
    unless_null $P988, vivify_377
    new $P988, "Undef"
  vivify_377:
    $P989 = $P988."ast"()
    $P990 = $P986."!make"($P989)
    .return ($P990)
.end


.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<grammar>"  :subid("69_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_992
    .param pmc param_993
.annotate 'line', 371
    .lex "self", param_992
    .lex "$/", param_993
    find_lex $P994, "$/"
    find_lex $P995, "$/"
    unless_null $P995, vivify_378
    $P995 = root_new ['parrot';'Hash']
  vivify_378:
    set $P996, $P995["package_def"]
    unless_null $P996, vivify_379
    new $P996, "Undef"
  vivify_379:
    $P997 = $P996."ast"()
    $P998 = $P994."!make"($P997)
    .return ($P998)
.end


.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<role>"  :subid("70_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_1000
    .param pmc param_1001
.annotate 'line', 372
    .lex "self", param_1000
    .lex "$/", param_1001
    find_lex $P1002, "$/"
    find_lex $P1003, "$/"
    unless_null $P1003, vivify_380
    $P1003 = root_new ['parrot';'Hash']
  vivify_380:
    set $P1004, $P1003["package_def"]
    unless_null $P1004, vivify_381
    new $P1004, "Undef"
  vivify_381:
    $P1005 = $P1004."ast"()
    $P1006 = $P1002."!make"($P1005)
    .return ($P1006)
.end


.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<native>"  :subid("71_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_1008
    .param pmc param_1009
.annotate 'line', 373
    .lex "self", param_1008
    .lex "$/", param_1009
    find_lex $P1010, "$/"
    find_lex $P1011, "$/"
    unless_null $P1011, vivify_382
    $P1011 = root_new ['parrot';'Hash']
  vivify_382:
    set $P1012, $P1011["package_def"]
    unless_null $P1012, vivify_383
    new $P1012, "Undef"
  vivify_383:
    $P1013 = $P1012."ast"()
    $P1014 = $P1010."!make"($P1013)
    .return ($P1014)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "package_def"  :subid("72_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_1016
    .param pmc param_1017
.annotate 'line', 375
    .const 'Sub' $P1176 = "75_1298325483.2958" 
    capture_lex $P1176
    .const 'Sub' $P1125 = "74_1298325483.2958" 
    capture_lex $P1125
    .const 'Sub' $P1083 = "73_1298325483.2958" 
    capture_lex $P1083
    .lex "self", param_1016
    .lex "$/", param_1017
.annotate 'line', 377
    $P1018 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P1018
.annotate 'line', 378
    new $P1019, "Undef"
    .lex "$name", $P1019
.annotate 'line', 379
    new $P1020, "Undef"
    .lex "$how", $P1020
.annotate 'line', 382
    new $P1021, "Undef"
    .lex "$past", $P1021
.annotate 'line', 377
    find_lex $P1022, "$/"
    unless_null $P1022, vivify_384
    $P1022 = root_new ['parrot';'Hash']
  vivify_384:
    set $P1023, $P1022["name"]
    unless_null $P1023, vivify_385
    $P1023 = root_new ['parrot';'Hash']
  vivify_385:
    set $P1024, $P1023["identifier"]
    unless_null $P1024, vivify_386
    new $P1024, "Undef"
  vivify_386:
    clone $P1025, $P1024
    store_lex "@ns", $P1025
.annotate 'line', 378
    find_lex $P1026, "@ns"
    $P1027 = $P1026."pop"()
    set $S1028, $P1027
    new $P1029, 'String'
    set $P1029, $S1028
    store_lex "$name", $P1029
.annotate 'line', 379
    find_dynamic_lex $P1030, "$*PKGDECL"
    unless_null $P1030, vivify_387
    get_hll_global $P1030, "$PKGDECL"
    unless_null $P1030, vivify_388
    die "Contextual $*PKGDECL not found"
  vivify_388:
  vivify_387:
    find_dynamic_lex $P1031, "%*HOW"
    unless_null $P1031, vivify_389
    get_hll_global $P1031, "%HOW"
    unless_null $P1031, vivify_390
    die "Contextual %*HOW not found"
  vivify_390:
  vivify_389:
    set $P1032, $P1031[$P1030]
    unless_null $P1032, vivify_391
    new $P1032, "Undef"
  vivify_391:
    store_lex "$how", $P1032
.annotate 'line', 382
    find_lex $P1035, "$/"
    unless_null $P1035, vivify_392
    $P1035 = root_new ['parrot';'Hash']
  vivify_392:
    set $P1036, $P1035["block"]
    unless_null $P1036, vivify_393
    new $P1036, "Undef"
  vivify_393:
    if $P1036, if_1034
    find_lex $P1040, "$/"
    unless_null $P1040, vivify_394
    $P1040 = root_new ['parrot';'Hash']
  vivify_394:
    set $P1041, $P1040["comp_unit"]
    unless_null $P1041, vivify_395
    new $P1041, "Undef"
  vivify_395:
    $P1042 = $P1041."ast"()
    set $P1033, $P1042
    goto if_1034_end
  if_1034:
    find_lex $P1037, "$/"
    unless_null $P1037, vivify_396
    $P1037 = root_new ['parrot';'Hash']
  vivify_396:
    set $P1038, $P1037["block"]
    unless_null $P1038, vivify_397
    new $P1038, "Undef"
  vivify_397:
    $P1039 = $P1038."ast"()
    set $P1033, $P1039
  if_1034_end:
    store_lex "$past", $P1033
.annotate 'line', 383
    find_lex $P1043, "$past"
    find_lex $P1044, "$/"
    unless_null $P1044, vivify_398
    $P1044 = root_new ['parrot';'Hash']
  vivify_398:
    set $P1045, $P1044["name"]
    unless_null $P1045, vivify_399
    $P1045 = root_new ['parrot';'Hash']
  vivify_399:
    set $P1046, $P1045["identifier"]
    unless_null $P1046, vivify_400
    new $P1046, "Undef"
  vivify_400:
    $P1043."namespace"($P1046)
.annotate 'line', 387
    find_dynamic_lex $P1047, "$*PACKAGE-SETUP"
    unless_null $P1047, vivify_401
    get_hll_global $P1047, "$PACKAGE-SETUP"
    unless_null $P1047, vivify_402
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_402:
  vivify_401:
    get_hll_global $P1048, ["PAST"], "Stmts"
.annotate 'line', 388
    get_hll_global $P1049, ["PAST"], "Op"
.annotate 'line', 389
    get_hll_global $P1050, ["PAST"], "Var"
    $P1051 = $P1050."new"("type_obj" :named("name"), "register" :named("scope"), 1 :named("isdecl"))
.annotate 'line', 390
    get_hll_global $P1052, ["PAST"], "Op"
.annotate 'line', 392
    get_hll_global $P1053, ["PAST"], "Var"
    find_lex $P1054, "$how"
    get_how $P1055, $P1054
    find_lex $P1056, "$how"
    $P1057 = $P1055."name"($P1056)
    $P1058 = $P1053."new"($P1057 :named("name"), "" :named("namespace"), "package" :named("scope"))
.annotate 'line', 393
    get_hll_global $P1059, ["PAST"], "Val"
    find_lex $P1060, "$name"
    $P1061 = $P1059."new"($P1060 :named("value"), "name" :named("named"))
    $P1062 = $P1052."new"($P1058, $P1061, "callmethod" :named("pasttype"), "new_type" :named("name"))
.annotate 'line', 390
    $P1063 = $P1049."new"($P1051, $P1062, "bind" :named("pasttype"))
.annotate 'line', 396
    get_hll_global $P1064, ["PAST"], "Op"
.annotate 'line', 397
    get_hll_global $P1065, ["PAST"], "Var"
    find_lex $P1066, "$name"
    find_lex $P1067, "@ns"
    $P1068 = $P1065."new"($P1066 :named("name"), $P1067 :named("namespace"), "package" :named("scope"))
.annotate 'line', 398
    get_hll_global $P1069, ["PAST"], "Var"
    $P1070 = $P1069."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1071 = $P1064."new"($P1068, $P1070, "bind" :named("pasttype"))
.annotate 'line', 400
    get_hll_global $P1072, ["PAST"], "Op"
.annotate 'line', 401
    get_hll_global $P1073, ["PAST"], "Var"
    $P1074 = $P1073."new"("$?CLASS" :named("name"))
.annotate 'line', 402
    get_hll_global $P1075, ["PAST"], "Var"
    $P1076 = $P1075."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1077 = $P1072."new"($P1074, $P1076, "bind" :named("pasttype"))
.annotate 'line', 400
    $P1078 = $P1048."new"($P1063, $P1071, $P1077)
.annotate 'line', 387
    $P1047."unshift"($P1078)
.annotate 'line', 407
    find_lex $P1080, "$/"
    unless_null $P1080, vivify_403
    $P1080 = root_new ['parrot';'Hash']
  vivify_403:
    set $P1081, $P1080["repr"]
    unless_null $P1081, vivify_404
    new $P1081, "Undef"
  vivify_404:
    unless $P1081, if_1079_end
    .const 'Sub' $P1083 = "73_1298325483.2958" 
    capture_lex $P1083
    $P1083()
  if_1079_end:
.annotate 'line', 418
    find_lex $P1099, "$how"
    can $I1100, $P1099, "parametric"
    if $I1100, if_1098
    new $P1097, 'Integer'
    set $P1097, $I1100
    goto if_1098_end
  if_1098:
    find_lex $P1101, "$how"
    find_lex $P1102, "$how"
    $P1103 = $P1101."parametric"($P1102)
    set $P1097, $P1103
  if_1098_end:
    if $P1097, if_1096
.annotate 'line', 425
    find_lex $P1116, "$past"
    $P1116."blocktype"("immediate")
.annotate 'line', 426
    find_lex $P1117, "$past"
    get_hll_global $P1118, ["PAST"], "Var"
    $P1119 = $P1118."new"("$?CLASS" :named("name"), "package" :named("scope"), 1 :named("isdecl"))
    $P1117."unshift"($P1119)
.annotate 'line', 427
    find_lex $P1120, "$past"
    $P1120."symbol"("$?CLASS", "package" :named("scope"))
.annotate 'line', 424
    goto if_1096_end
  if_1096:
.annotate 'line', 419
    find_lex $P1104, "$past"
    $P1104."blocktype"("declaration")
.annotate 'line', 420
    find_lex $P1105, "$past"
    get_hll_global $P1106, ["PAST"], "Var"
    $P1107 = $P1106."new"("$?CLASS" :named("name"), "parameter" :named("scope"))
    $P1105."unshift"($P1107)
.annotate 'line', 421
    find_lex $P1108, "$past"
    $P1108."symbol"("$?CLASS", "lexical" :named("scope"))
.annotate 'line', 422
    find_dynamic_lex $P1109, "$*PACKAGE-SETUP"
    unless_null $P1109, vivify_413
    get_hll_global $P1109, "$PACKAGE-SETUP"
    unless_null $P1109, vivify_414
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_414:
  vivify_413:
    set $P1110, $P1109[0]
    unless_null $P1110, vivify_415
    $P1110 = root_new ['parrot';'ResizablePMCArray']
  vivify_415:
    set $P1111, $P1110[0]
    unless_null $P1111, vivify_416
    $P1111 = root_new ['parrot';'ResizablePMCArray']
  vivify_416:
    set $P1112, $P1111[1]
    unless_null $P1112, vivify_417
    new $P1112, "Undef"
  vivify_417:
    get_hll_global $P1113, ["PAST"], "Val"
    find_lex $P1114, "$past"
    $P1115 = $P1113."new"($P1114 :named("value"), "body_block" :named("named"))
    $P1112."push"($P1115)
  if_1096_end:
.annotate 'line', 432
    find_lex $P1122, "$/"
    unless_null $P1122, vivify_418
    $P1122 = root_new ['parrot';'Hash']
  vivify_418:
    set $P1123, $P1122["parent"]
    unless_null $P1123, vivify_419
    new $P1123, "Undef"
  vivify_419:
    if $P1123, if_1121
.annotate 'line', 446
    find_dynamic_lex $P1153, "$*PKGDECL"
    unless_null $P1153, vivify_420
    get_hll_global $P1153, "$PKGDECL"
    unless_null $P1153, vivify_421
    die "Contextual $*PKGDECL not found"
  vivify_421:
  vivify_420:
    set $S1154, $P1153
    iseq $I1155, $S1154, "grammar"
    unless $I1155, if_1152_end
.annotate 'line', 447
    find_dynamic_lex $P1156, "$*PACKAGE-SETUP"
    unless_null $P1156, vivify_422
    get_hll_global $P1156, "$PACKAGE-SETUP"
    unless_null $P1156, vivify_423
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_423:
  vivify_422:
    get_hll_global $P1157, ["PAST"], "Op"
.annotate 'line', 449
    get_hll_global $P1158, ["PAST"], "Op"
.annotate 'line', 452
    get_hll_global $P1159, ["PAST"], "Var"
    $P1160 = $P1159."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1161 = $P1158."new"($P1160, "get_how PP" :named("pirop"))
.annotate 'line', 454
    get_hll_global $P1162, ["PAST"], "Var"
    $P1163 = $P1162."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 455
    get_hll_global $P1164, ["PAST"], "Var"
    $P1165 = $P1164."new"("Cursor" :named("name"), "Regex" :named("namespace"), "package" :named("scope"))
    $P1166 = $P1157."new"($P1161, $P1163, $P1165, "callmethod" :named("pasttype"), "add_parent" :named("name"))
.annotate 'line', 447
    $P1156."push"($P1166)
  if_1152_end:
.annotate 'line', 446
    goto if_1121_end
  if_1121:
.annotate 'line', 432
    .const 'Sub' $P1125 = "74_1298325483.2958" 
    capture_lex $P1125
    $P1125()
  if_1121_end:
.annotate 'line', 460
    find_lex $P1168, "$/"
    unless_null $P1168, vivify_430
    $P1168 = root_new ['parrot';'Hash']
  vivify_430:
    set $P1169, $P1168["role"]
    unless_null $P1169, vivify_431
    new $P1169, "Undef"
  vivify_431:
    unless $P1169, if_1167_end
.annotate 'line', 461
    find_lex $P1171, "$/"
    unless_null $P1171, vivify_432
    $P1171 = root_new ['parrot';'Hash']
  vivify_432:
    set $P1172, $P1171["role"]
    unless_null $P1172, vivify_433
    new $P1172, "Undef"
  vivify_433:
    defined $I1173, $P1172
    unless $I1173, for_undef_434
    iter $P1170, $P1172
    new $P1203, 'ExceptionHandler'
    set_label $P1203, loop1202_handler
    $P1203."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1203
  loop1202_test:
    unless $P1170, loop1202_done
    shift $P1174, $P1170
  loop1202_redo:
    .const 'Sub' $P1176 = "75_1298325483.2958" 
    capture_lex $P1176
    $P1176($P1174)
  loop1202_next:
    goto loop1202_test
  loop1202_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1204, exception, 'type'
    eq $P1204, .CONTROL_LOOP_NEXT, loop1202_next
    eq $P1204, .CONTROL_LOOP_REDO, loop1202_redo
  loop1202_done:
    pop_eh 
  for_undef_434:
  if_1167_end:
.annotate 'line', 478
    find_dynamic_lex $P1205, "$*PACKAGE-SETUP"
    unless_null $P1205, vivify_439
    get_hll_global $P1205, "$PACKAGE-SETUP"
    unless_null $P1205, vivify_440
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_440:
  vivify_439:
    get_hll_global $P1206, ["PAST"], "Op"
.annotate 'line', 480
    get_hll_global $P1207, ["PAST"], "Op"
.annotate 'line', 483
    get_hll_global $P1208, ["PAST"], "Var"
    $P1209 = $P1208."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1210 = $P1207."new"($P1209, "get_how PP" :named("pirop"))
.annotate 'line', 485
    get_hll_global $P1211, ["PAST"], "Var"
    $P1212 = $P1211."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1213 = $P1206."new"($P1210, $P1212, "callmethod" :named("pasttype"), "compose" :named("name"))
.annotate 'line', 478
    $P1205."push"($P1213)
.annotate 'line', 489
    get_global $P1214, "@BLOCK"
    unless_null $P1214, vivify_441
    $P1214 = root_new ['parrot';'ResizablePMCArray']
  vivify_441:
    set $P1215, $P1214[0]
    unless_null $P1215, vivify_442
    $P1215 = root_new ['parrot';'ResizablePMCArray']
  vivify_442:
    set $P1216, $P1215[0]
    unless_null $P1216, vivify_443
    new $P1216, "Undef"
  vivify_443:
    get_hll_global $P1217, ["PAST"], "Var"
    find_lex $P1218, "$name"
    find_lex $P1219, "@ns"
    $P1220 = $P1217."new"($P1218 :named("name"), $P1219 :named("namespace"), "package" :named("scope"), 1 :named("isdecl"))
    $P1216."unshift"($P1220)
.annotate 'line', 492
    find_lex $P1221, "$past"
    $P1222 = $P1221."loadinit"()
    get_hll_global $P1223, ["PAST"], "Block"
    find_dynamic_lex $P1224, "$*PACKAGE-SETUP"
    unless_null $P1224, vivify_444
    get_hll_global $P1224, "$PACKAGE-SETUP"
    unless_null $P1224, vivify_445
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_445:
  vivify_444:
    $P1225 = $P1223."new"($P1224, "immediate" :named("blocktype"))
    $P1222."push"($P1225)
.annotate 'line', 494
    find_lex $P1226, "$/"
    find_lex $P1227, "$past"
    $P1228 = $P1226."!make"($P1227)
.annotate 'line', 375
    .return ($P1228)
.end


.namespace ["NQP";"Actions"]
.sub "_block1082"  :anon :subid("73_1298325483.2958") :outer("72_1298325483.2958")
.annotate 'line', 408
    new $P1084, "Undef"
    .lex "$repr_name", $P1084
    find_lex $P1085, "$/"
    unless_null $P1085, vivify_405
    $P1085 = root_new ['parrot';'Hash']
  vivify_405:
    set $P1086, $P1085["repr"]
    unless_null $P1086, vivify_406
    $P1086 = root_new ['parrot';'ResizablePMCArray']
  vivify_406:
    set $P1087, $P1086[0]
    unless_null $P1087, vivify_407
    new $P1087, "Undef"
  vivify_407:
    $P1088 = $P1087."ast"()
    store_lex "$repr_name", $P1088
.annotate 'line', 409
    find_lex $P1089, "$repr_name"
    $P1089."named"("repr")
.annotate 'line', 410
    find_dynamic_lex $P1090, "$*PACKAGE-SETUP"
    unless_null $P1090, vivify_408
    get_hll_global $P1090, "$PACKAGE-SETUP"
    unless_null $P1090, vivify_409
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_409:
  vivify_408:
    set $P1091, $P1090[0]
    unless_null $P1091, vivify_410
    $P1091 = root_new ['parrot';'ResizablePMCArray']
  vivify_410:
    set $P1092, $P1091[0]
    unless_null $P1092, vivify_411
    $P1092 = root_new ['parrot';'ResizablePMCArray']
  vivify_411:
    set $P1093, $P1092[1]
    unless_null $P1093, vivify_412
    new $P1093, "Undef"
  vivify_412:
    find_lex $P1094, "$repr_name"
    $P1095 = $P1093."push"($P1094)
.annotate 'line', 407
    .return ($P1095)
.end


.namespace ["NQP";"Actions"]
.sub "_block1124"  :anon :subid("74_1298325483.2958") :outer("72_1298325483.2958")
.annotate 'line', 433
    $P1126 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P1126
.annotate 'line', 434
    new $P1127, "Undef"
    .lex "$name", $P1127
.annotate 'line', 433
    find_lex $P1128, "$/"
    unless_null $P1128, vivify_424
    $P1128 = root_new ['parrot';'Hash']
  vivify_424:
    set $P1129, $P1128["parent"]
    unless_null $P1129, vivify_425
    $P1129 = root_new ['parrot';'ResizablePMCArray']
  vivify_425:
    set $P1130, $P1129[0]
    unless_null $P1130, vivify_426
    $P1130 = root_new ['parrot';'Hash']
  vivify_426:
    set $P1131, $P1130["identifier"]
    unless_null $P1131, vivify_427
    new $P1131, "Undef"
  vivify_427:
    clone $P1132, $P1131
    store_lex "@ns", $P1132
.annotate 'line', 434
    find_lex $P1133, "@ns"
    $P1134 = $P1133."pop"()
    set $S1135, $P1134
    new $P1136, 'String'
    set $P1136, $S1135
    store_lex "$name", $P1136
.annotate 'line', 435
    find_dynamic_lex $P1137, "$*PACKAGE-SETUP"
    unless_null $P1137, vivify_428
    get_hll_global $P1137, "$PACKAGE-SETUP"
    unless_null $P1137, vivify_429
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_429:
  vivify_428:
    get_hll_global $P1138, ["PAST"], "Op"
.annotate 'line', 437
    get_hll_global $P1139, ["PAST"], "Op"
.annotate 'line', 440
    get_hll_global $P1140, ["PAST"], "Var"
    $P1141 = $P1140."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1142 = $P1139."new"($P1141, "get_how PP" :named("pirop"))
.annotate 'line', 442
    get_hll_global $P1143, ["PAST"], "Var"
    $P1144 = $P1143."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 443
    get_hll_global $P1145, ["PAST"], "Var"
    find_lex $P1146, "$name"
    set $S1147, $P1146
    find_lex $P1148, "@ns"
    $P1149 = $P1145."new"($S1147 :named("name"), $P1148 :named("namespace"), "package" :named("scope"))
    $P1150 = $P1138."new"($P1142, $P1144, $P1149, "callmethod" :named("pasttype"), "add_parent" :named("name"))
.annotate 'line', 435
    $P1151 = $P1137."push"($P1150)
.annotate 'line', 432
    .return ($P1151)
.end


.namespace ["NQP";"Actions"]
.sub "_block1175"  :anon :subid("75_1298325483.2958") :outer("72_1298325483.2958")
    .param pmc param_1179
.annotate 'line', 462
    $P1177 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P1177
.annotate 'line', 463
    new $P1178, "Undef"
    .lex "$name", $P1178
    .lex "$_", param_1179
.annotate 'line', 462
    find_lex $P1180, "$_"
    unless_null $P1180, vivify_435
    $P1180 = root_new ['parrot';'Hash']
  vivify_435:
    set $P1181, $P1180["identifier"]
    unless_null $P1181, vivify_436
    new $P1181, "Undef"
  vivify_436:
    clone $P1182, $P1181
    store_lex "@ns", $P1182
.annotate 'line', 463
    find_lex $P1183, "@ns"
    $P1184 = $P1183."pop"()
    set $S1185, $P1184
    new $P1186, 'String'
    set $P1186, $S1185
    store_lex "$name", $P1186
.annotate 'line', 464
    find_dynamic_lex $P1187, "$*PACKAGE-SETUP"
    unless_null $P1187, vivify_437
    get_hll_global $P1187, "$PACKAGE-SETUP"
    unless_null $P1187, vivify_438
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_438:
  vivify_437:
    get_hll_global $P1188, ["PAST"], "Op"
.annotate 'line', 466
    get_hll_global $P1189, ["PAST"], "Op"
.annotate 'line', 469
    get_hll_global $P1190, ["PAST"], "Var"
    $P1191 = $P1190."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1192 = $P1189."new"($P1191, "get_how PP" :named("pirop"))
.annotate 'line', 471
    get_hll_global $P1193, ["PAST"], "Var"
    $P1194 = $P1193."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 472
    get_hll_global $P1195, ["PAST"], "Var"
    find_lex $P1196, "$name"
    set $S1197, $P1196
    find_lex $P1198, "@ns"
    $P1199 = $P1195."new"($S1197 :named("name"), $P1198 :named("namespace"), "package" :named("scope"))
    $P1200 = $P1188."new"($P1192, $P1194, $P1199, "callmethod" :named("pasttype"), "add_role" :named("name"))
.annotate 'line', 464
    $P1201 = $P1187."push"($P1200)
.annotate 'line', 461
    .return ($P1201)
.end


.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<my>"  :subid("76_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_1230
    .param pmc param_1231
.annotate 'line', 497
    .lex "self", param_1230
    .lex "$/", param_1231
    find_lex $P1232, "$/"
    find_lex $P1233, "$/"
    unless_null $P1233, vivify_446
    $P1233 = root_new ['parrot';'Hash']
  vivify_446:
    set $P1234, $P1233["scoped"]
    unless_null $P1234, vivify_447
    new $P1234, "Undef"
  vivify_447:
    $P1235 = $P1234."ast"()
    $P1236 = $P1232."!make"($P1235)
    .return ($P1236)
.end


.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<our>"  :subid("77_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_1238
    .param pmc param_1239
.annotate 'line', 498
    .lex "self", param_1238
    .lex "$/", param_1239
    find_lex $P1240, "$/"
    find_lex $P1241, "$/"
    unless_null $P1241, vivify_448
    $P1241 = root_new ['parrot';'Hash']
  vivify_448:
    set $P1242, $P1241["scoped"]
    unless_null $P1242, vivify_449
    new $P1242, "Undef"
  vivify_449:
    $P1243 = $P1242."ast"()
    $P1244 = $P1240."!make"($P1243)
    .return ($P1244)
.end


.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<has>"  :subid("78_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_1246
    .param pmc param_1247
.annotate 'line', 499
    .lex "self", param_1246
    .lex "$/", param_1247
    find_lex $P1248, "$/"
    find_lex $P1249, "$/"
    unless_null $P1249, vivify_450
    $P1249 = root_new ['parrot';'Hash']
  vivify_450:
    set $P1250, $P1249["scoped"]
    unless_null $P1250, vivify_451
    new $P1250, "Undef"
  vivify_451:
    $P1251 = $P1250."ast"()
    $P1252 = $P1248."!make"($P1251)
    .return ($P1252)
.end


.namespace ["NQP";"Actions"]
.sub "scoped"  :subid("79_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_1254
    .param pmc param_1255
.annotate 'line', 501
    .lex "self", param_1254
    .lex "$/", param_1255
.annotate 'line', 502
    find_lex $P1256, "$/"
.annotate 'line', 503
    find_lex $P1259, "$/"
    unless_null $P1259, vivify_452
    $P1259 = root_new ['parrot';'Hash']
  vivify_452:
    set $P1260, $P1259["declarator"]
    unless_null $P1260, vivify_453
    new $P1260, "Undef"
  vivify_453:
    if $P1260, if_1258
.annotate 'line', 504
    find_lex $P1264, "$/"
    unless_null $P1264, vivify_454
    $P1264 = root_new ['parrot';'Hash']
  vivify_454:
    set $P1265, $P1264["multi_declarator"]
    unless_null $P1265, vivify_455
    new $P1265, "Undef"
  vivify_455:
    $P1266 = $P1265."ast"()
    set $P1257, $P1266
.annotate 'line', 503
    goto if_1258_end
  if_1258:
    find_lex $P1261, "$/"
    unless_null $P1261, vivify_456
    $P1261 = root_new ['parrot';'Hash']
  vivify_456:
    set $P1262, $P1261["declarator"]
    unless_null $P1262, vivify_457
    new $P1262, "Undef"
  vivify_457:
    $P1263 = $P1262."ast"()
    set $P1257, $P1263
  if_1258_end:
    $P1267 = $P1256."!make"($P1257)
.annotate 'line', 501
    .return ($P1267)
.end


.namespace ["NQP";"Actions"]
.sub "declarator"  :subid("80_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_1269
    .param pmc param_1270
.annotate 'line', 507
    .lex "self", param_1269
    .lex "$/", param_1270
.annotate 'line', 508
    find_lex $P1271, "$/"
.annotate 'line', 509
    find_lex $P1274, "$/"
    unless_null $P1274, vivify_458
    $P1274 = root_new ['parrot';'Hash']
  vivify_458:
    set $P1275, $P1274["routine_declarator"]
    unless_null $P1275, vivify_459
    new $P1275, "Undef"
  vivify_459:
    if $P1275, if_1273
.annotate 'line', 510
    find_lex $P1279, "$/"
    unless_null $P1279, vivify_460
    $P1279 = root_new ['parrot';'Hash']
  vivify_460:
    set $P1280, $P1279["variable_declarator"]
    unless_null $P1280, vivify_461
    new $P1280, "Undef"
  vivify_461:
    $P1281 = $P1280."ast"()
    set $P1272, $P1281
.annotate 'line', 509
    goto if_1273_end
  if_1273:
    find_lex $P1276, "$/"
    unless_null $P1276, vivify_462
    $P1276 = root_new ['parrot';'Hash']
  vivify_462:
    set $P1277, $P1276["routine_declarator"]
    unless_null $P1277, vivify_463
    new $P1277, "Undef"
  vivify_463:
    $P1278 = $P1277."ast"()
    set $P1272, $P1278
  if_1273_end:
    $P1282 = $P1271."!make"($P1272)
.annotate 'line', 507
    .return ($P1282)
.end


.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<multi>"  :subid("81_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_1284
    .param pmc param_1285
.annotate 'line', 513
    .lex "self", param_1284
    .lex "$/", param_1285
    find_lex $P1286, "$/"
    find_lex $P1289, "$/"
    unless_null $P1289, vivify_464
    $P1289 = root_new ['parrot';'Hash']
  vivify_464:
    set $P1290, $P1289["declarator"]
    unless_null $P1290, vivify_465
    new $P1290, "Undef"
  vivify_465:
    if $P1290, if_1288
    find_lex $P1294, "$/"
    unless_null $P1294, vivify_466
    $P1294 = root_new ['parrot';'Hash']
  vivify_466:
    set $P1295, $P1294["routine_def"]
    unless_null $P1295, vivify_467
    new $P1295, "Undef"
  vivify_467:
    $P1296 = $P1295."ast"()
    set $P1287, $P1296
    goto if_1288_end
  if_1288:
    find_lex $P1291, "$/"
    unless_null $P1291, vivify_468
    $P1291 = root_new ['parrot';'Hash']
  vivify_468:
    set $P1292, $P1291["declarator"]
    unless_null $P1292, vivify_469
    new $P1292, "Undef"
  vivify_469:
    $P1293 = $P1292."ast"()
    set $P1287, $P1293
  if_1288_end:
    $P1297 = $P1286."!make"($P1287)
    .return ($P1297)
.end


.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<proto>"  :subid("82_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_1299
    .param pmc param_1300
.annotate 'line', 514
    .lex "self", param_1299
    .lex "$/", param_1300
    find_lex $P1301, "$/"
    find_lex $P1304, "$/"
    unless_null $P1304, vivify_470
    $P1304 = root_new ['parrot';'Hash']
  vivify_470:
    set $P1305, $P1304["declarator"]
    unless_null $P1305, vivify_471
    new $P1305, "Undef"
  vivify_471:
    if $P1305, if_1303
    find_lex $P1309, "$/"
    unless_null $P1309, vivify_472
    $P1309 = root_new ['parrot';'Hash']
  vivify_472:
    set $P1310, $P1309["routine_def"]
    unless_null $P1310, vivify_473
    new $P1310, "Undef"
  vivify_473:
    $P1311 = $P1310."ast"()
    set $P1302, $P1311
    goto if_1303_end
  if_1303:
    find_lex $P1306, "$/"
    unless_null $P1306, vivify_474
    $P1306 = root_new ['parrot';'Hash']
  vivify_474:
    set $P1307, $P1306["declarator"]
    unless_null $P1307, vivify_475
    new $P1307, "Undef"
  vivify_475:
    $P1308 = $P1307."ast"()
    set $P1302, $P1308
  if_1303_end:
    $P1312 = $P1301."!make"($P1302)
    .return ($P1312)
.end


.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<null>"  :subid("83_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_1314
    .param pmc param_1315
.annotate 'line', 515
    .lex "self", param_1314
    .lex "$/", param_1315
    find_lex $P1316, "$/"
    find_lex $P1317, "$/"
    unless_null $P1317, vivify_476
    $P1317 = root_new ['parrot';'Hash']
  vivify_476:
    set $P1318, $P1317["declarator"]
    unless_null $P1318, vivify_477
    new $P1318, "Undef"
  vivify_477:
    $P1319 = $P1318."ast"()
    $P1320 = $P1316."!make"($P1319)
    .return ($P1320)
.end


.namespace ["NQP";"Actions"]
.sub "variable_declarator"  :subid("84_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_1322
    .param pmc param_1323
.annotate 'line', 518
    .const 'Sub' $P1395 = "87_1298325483.2958" 
    capture_lex $P1395
    .const 'Sub' $P1350 = "85_1298325483.2958" 
    capture_lex $P1350
    .lex "self", param_1322
    .lex "$/", param_1323
.annotate 'line', 519
    new $P1324, "Undef"
    .lex "$past", $P1324
.annotate 'line', 520
    new $P1325, "Undef"
    .lex "$sigil", $P1325
.annotate 'line', 521
    new $P1326, "Undef"
    .lex "$name", $P1326
.annotate 'line', 522
    new $P1327, "Undef"
    .lex "$BLOCK", $P1327
.annotate 'line', 519
    find_lex $P1328, "$/"
    unless_null $P1328, vivify_478
    $P1328 = root_new ['parrot';'Hash']
  vivify_478:
    set $P1329, $P1328["variable"]
    unless_null $P1329, vivify_479
    new $P1329, "Undef"
  vivify_479:
    $P1330 = $P1329."ast"()
    store_lex "$past", $P1330
.annotate 'line', 520
    find_lex $P1331, "$/"
    unless_null $P1331, vivify_480
    $P1331 = root_new ['parrot';'Hash']
  vivify_480:
    set $P1332, $P1331["variable"]
    unless_null $P1332, vivify_481
    $P1332 = root_new ['parrot';'Hash']
  vivify_481:
    set $P1333, $P1332["sigil"]
    unless_null $P1333, vivify_482
    new $P1333, "Undef"
  vivify_482:
    store_lex "$sigil", $P1333
.annotate 'line', 521
    find_lex $P1334, "$past"
    $P1335 = $P1334."name"()
    store_lex "$name", $P1335
.annotate 'line', 522
    get_global $P1336, "@BLOCK"
    unless_null $P1336, vivify_483
    $P1336 = root_new ['parrot';'ResizablePMCArray']
  vivify_483:
    set $P1337, $P1336[0]
    unless_null $P1337, vivify_484
    new $P1337, "Undef"
  vivify_484:
    store_lex "$BLOCK", $P1337
.annotate 'line', 523
    find_lex $P1339, "$BLOCK"
    find_lex $P1340, "$name"
    $P1341 = $P1339."symbol"($P1340)
    unless $P1341, if_1338_end
.annotate 'line', 524
    find_lex $P1342, "$/"
    $P1343 = $P1342."CURSOR"()
    find_lex $P1344, "$name"
    $P1343."panic"("Redeclaration of symbol ", $P1344)
  if_1338_end:
.annotate 'line', 526
    find_dynamic_lex $P1346, "$*SCOPE"
    unless_null $P1346, vivify_485
    get_hll_global $P1346, "$SCOPE"
    unless_null $P1346, vivify_486
    die "Contextual $*SCOPE not found"
  vivify_486:
  vivify_485:
    set $S1347, $P1346
    iseq $I1348, $S1347, "has"
    if $I1348, if_1345
.annotate 'line', 551
    .const 'Sub' $P1395 = "87_1298325483.2958" 
    capture_lex $P1395
    $P1395()
    goto if_1345_end
  if_1345:
.annotate 'line', 526
    .const 'Sub' $P1350 = "85_1298325483.2958" 
    capture_lex $P1350
    $P1350()
  if_1345_end:
.annotate 'line', 559
    find_lex $P1419, "$/"
    find_lex $P1420, "$past"
    $P1421 = $P1419."!make"($P1420)
.annotate 'line', 518
    .return ($P1421)
.end


.namespace ["NQP";"Actions"]
.sub "_block1394"  :anon :subid("87_1298325483.2958") :outer("84_1298325483.2958")
.annotate 'line', 552
    new $P1396, "Undef"
    .lex "$scope", $P1396
.annotate 'line', 553
    new $P1397, "Undef"
    .lex "$decl", $P1397
.annotate 'line', 552
    find_dynamic_lex $P1400, "$*SCOPE"
    unless_null $P1400, vivify_487
    get_hll_global $P1400, "$SCOPE"
    unless_null $P1400, vivify_488
    die "Contextual $*SCOPE not found"
  vivify_488:
  vivify_487:
    set $S1401, $P1400
    iseq $I1402, $S1401, "our"
    if $I1402, if_1399
    new $P1404, "String"
    assign $P1404, "lexical"
    set $P1398, $P1404
    goto if_1399_end
  if_1399:
    new $P1403, "String"
    assign $P1403, "package"
    set $P1398, $P1403
  if_1399_end:
    store_lex "$scope", $P1398
.annotate 'line', 553
    get_hll_global $P1405, ["PAST"], "Var"
    find_lex $P1406, "$name"
    find_lex $P1407, "$scope"
.annotate 'line', 554
    find_lex $P1408, "$sigil"
    $P1409 = "vivitype"($P1408)
    find_lex $P1410, "$/"
    $P1411 = $P1405."new"($P1406 :named("name"), $P1407 :named("scope"), 1 :named("isdecl"), 1 :named("lvalue"), $P1409 :named("viviself"), $P1410 :named("node"))
.annotate 'line', 553
    store_lex "$decl", $P1411
.annotate 'line', 556
    find_lex $P1412, "$BLOCK"
    find_lex $P1413, "$name"
    find_lex $P1414, "$scope"
    $P1412."symbol"($P1413, $P1414 :named("scope"))
.annotate 'line', 557
    find_lex $P1415, "$BLOCK"
    unless_null $P1415, vivify_489
    $P1415 = root_new ['parrot';'ResizablePMCArray']
  vivify_489:
    set $P1416, $P1415[0]
    unless_null $P1416, vivify_490
    new $P1416, "Undef"
  vivify_490:
    find_lex $P1417, "$decl"
    $P1418 = $P1416."push"($P1417)
.annotate 'line', 551
    .return ($P1418)
.end


.namespace ["NQP";"Actions"]
.sub "_block1349"  :anon :subid("85_1298325483.2958") :outer("84_1298325483.2958")
.annotate 'line', 526
    .const 'Sub' $P1380 = "86_1298325483.2958" 
    capture_lex $P1380
.annotate 'line', 528
    new $P1351, "Undef"
    .lex "$meta-attr-type", $P1351
.annotate 'line', 536
    new $P1352, "Undef"
    .lex "$meta_args", $P1352
.annotate 'line', 528
    find_dynamic_lex $P1355, "$*PKGDECL"
    unless_null $P1355, vivify_491
    get_hll_global $P1355, "$PKGDECL"
    unless_null $P1355, vivify_492
    die "Contextual $*PKGDECL not found"
  vivify_492:
  vivify_491:
    find_dynamic_lex $P1356, "%*HOW-METAATTR"
    unless_null $P1356, vivify_493
    get_hll_global $P1356, "%HOW-METAATTR"
    unless_null $P1356, vivify_494
    die "Contextual %*HOW-METAATTR not found"
  vivify_494:
  vivify_493:
    set $P1357, $P1356[$P1355]
    unless_null $P1357, vivify_495
    new $P1357, "Undef"
  vivify_495:
    unless $P1357, unless_1354
    set $P1353, $P1357
    goto unless_1354_end
  unless_1354:
    find_dynamic_lex $P1358, "$*DEFAULT-METAATTR"
    unless_null $P1358, vivify_496
    get_hll_global $P1358, "$DEFAULT-METAATTR"
    unless_null $P1358, vivify_497
    die "Contextual $*DEFAULT-METAATTR not found"
  vivify_497:
  vivify_496:
    set $P1353, $P1358
  unless_1354_end:
    store_lex "$meta-attr-type", $P1353
.annotate 'line', 529
    find_dynamic_lex $P1359, "$*PACKAGE-SETUP"
    unless_null $P1359, vivify_498
    get_hll_global $P1359, "$PACKAGE-SETUP"
    unless_null $P1359, vivify_499
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_499:
  vivify_498:
    get_hll_global $P1360, ["PAST"], "Op"
.annotate 'line', 531
    get_hll_global $P1361, ["PAST"], "Op"
.annotate 'line', 533
    get_hll_global $P1362, ["PAST"], "Var"
    $P1363 = $P1362."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1364 = $P1361."new"($P1363, "get_how PP" :named("pirop"))
.annotate 'line', 535
    get_hll_global $P1365, ["PAST"], "Var"
    $P1366 = $P1365."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 536
    get_hll_global $P1367, ["PAST"], "Op"
.annotate 'line', 538
    get_hll_global $P1368, ["PAST"], "Var"
    find_lex $P1369, "$meta-attr-type"
    $P1370 = $P1368."new"($P1369 :named("name"), "" :named("namespace"), "package" :named("scope"))
.annotate 'line', 539
    get_hll_global $P1371, ["PAST"], "Val"
    find_lex $P1372, "$name"
    $P1373 = $P1371."new"($P1372 :named("value"), "name" :named("named"))
    $P1374 = $P1367."new"($P1370, $P1373, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 536
    store_lex "$meta_args", $P1374
    $P1375 = $P1360."new"($P1364, $P1366, $P1374, "callmethod" :named("pasttype"), "add_attribute" :named("name"))
.annotate 'line', 529
    $P1359."push"($P1375)
.annotate 'line', 542
    find_lex $P1377, "$/"
    unless_null $P1377, vivify_500
    $P1377 = root_new ['parrot';'Hash']
  vivify_500:
    set $P1378, $P1377["typename"]
    unless_null $P1378, vivify_501
    new $P1378, "Undef"
  vivify_501:
    unless $P1378, if_1376_end
    .const 'Sub' $P1380 = "86_1298325483.2958" 
    capture_lex $P1380
    $P1380()
  if_1376_end:
.annotate 'line', 548
    find_lex $P1390, "$BLOCK"
    find_lex $P1391, "$name"
    $P1390."symbol"($P1391, "attribute" :named("scope"))
.annotate 'line', 549
    get_hll_global $P1392, ["PAST"], "Stmts"
    $P1393 = $P1392."new"()
    store_lex "$past", $P1393
.annotate 'line', 526
    .return ($P1393)
.end


.namespace ["NQP";"Actions"]
.sub "_block1379"  :anon :subid("86_1298325483.2958") :outer("85_1298325483.2958")
.annotate 'line', 543
    new $P1381, "Undef"
    .lex "$type", $P1381
    find_lex $P1382, "$/"
    unless_null $P1382, vivify_502
    $P1382 = root_new ['parrot';'Hash']
  vivify_502:
    set $P1383, $P1382["typename"]
    unless_null $P1383, vivify_503
    $P1383 = root_new ['parrot';'ResizablePMCArray']
  vivify_503:
    set $P1384, $P1383[0]
    unless_null $P1384, vivify_504
    new $P1384, "Undef"
  vivify_504:
    $P1385 = $P1384."ast"()
    store_lex "$type", $P1385
.annotate 'line', 544
    find_lex $P1386, "$type"
    $P1386."named"("type")
.annotate 'line', 545
    find_lex $P1387, "$meta_args"
    find_lex $P1388, "$type"
    $P1389 = $P1387."push"($P1388)
.annotate 'line', 542
    .return ($P1389)
.end


.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<sub>"  :subid("88_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_1423
    .param pmc param_1424
.annotate 'line', 562
    .lex "self", param_1423
    .lex "$/", param_1424
    find_lex $P1425, "$/"
    find_lex $P1426, "$/"
    unless_null $P1426, vivify_505
    $P1426 = root_new ['parrot';'Hash']
  vivify_505:
    set $P1427, $P1426["routine_def"]
    unless_null $P1427, vivify_506
    new $P1427, "Undef"
  vivify_506:
    $P1428 = $P1427."ast"()
    $P1429 = $P1425."!make"($P1428)
    .return ($P1429)
.end


.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<method>"  :subid("89_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_1431
    .param pmc param_1432
.annotate 'line', 563
    .lex "self", param_1431
    .lex "$/", param_1432
    find_lex $P1433, "$/"
    find_lex $P1434, "$/"
    unless_null $P1434, vivify_507
    $P1434 = root_new ['parrot';'Hash']
  vivify_507:
    set $P1435, $P1434["method_def"]
    unless_null $P1435, vivify_508
    new $P1435, "Undef"
  vivify_508:
    $P1436 = $P1435."ast"()
    $P1437 = $P1433."!make"($P1436)
    .return ($P1437)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "routine_def"  :subid("90_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_1439
    .param pmc param_1440
.annotate 'line', 565
    .const 'Sub' $P1668 = "96_1298325483.2958" 
    capture_lex $P1668
    .const 'Sub' $P1460 = "91_1298325483.2958" 
    capture_lex $P1460
    .lex "self", param_1439
    .lex "$/", param_1440
.annotate 'line', 568
    new $P1441, "Undef"
    .lex "$past", $P1441
.annotate 'line', 579
    new $P1442, "Undef"
    .lex "$block", $P1442
.annotate 'line', 565
    find_lex $P1443, "$past"
.annotate 'line', 569
    find_lex $P1445, "$/"
    unless_null $P1445, vivify_509
    $P1445 = root_new ['parrot';'Hash']
  vivify_509:
    set $P1446, $P1445["onlystar"]
    unless_null $P1446, vivify_510
    new $P1446, "Undef"
  vivify_510:
    if $P1446, if_1444
.annotate 'line', 573
    find_lex $P1448, "$/"
    unless_null $P1448, vivify_511
    $P1448 = root_new ['parrot';'Hash']
  vivify_511:
    set $P1449, $P1448["blockoid"]
    unless_null $P1449, vivify_512
    new $P1449, "Undef"
  vivify_512:
    $P1450 = $P1449."ast"()
    store_lex "$past", $P1450
.annotate 'line', 574
    find_lex $P1451, "$past"
    $P1451."blocktype"("declaration")
.annotate 'line', 575
    find_dynamic_lex $P1453, "$*RETURN_USED"
    unless_null $P1453, vivify_513
    get_hll_global $P1453, "$RETURN_USED"
    unless_null $P1453, vivify_514
    die "Contextual $*RETURN_USED not found"
  vivify_514:
  vivify_513:
    unless $P1453, if_1452_end
.annotate 'line', 576
    find_lex $P1454, "$past"
    $P1454."control"("return_pir")
  if_1452_end:
.annotate 'line', 572
    goto if_1444_end
  if_1444:
.annotate 'line', 570
    $P1447 = "only_star_block"()
    store_lex "$past", $P1447
  if_1444_end:
.annotate 'line', 579
    find_lex $P1455, "$past"
    store_lex "$block", $P1455
.annotate 'line', 581
    find_lex $P1457, "$/"
    unless_null $P1457, vivify_515
    $P1457 = root_new ['parrot';'Hash']
  vivify_515:
    set $P1458, $P1457["deflongname"]
    unless_null $P1458, vivify_516
    new $P1458, "Undef"
  vivify_516:
    unless $P1458, if_1456_end
    .const 'Sub' $P1460 = "91_1298325483.2958" 
    capture_lex $P1460
    $P1460()
  if_1456_end:
.annotate 'line', 681
    find_lex $P1657, "$block"
    find_lex $P1658, "$past"
    unless_null $P1658, vivify_577
    $P1658 = root_new ['parrot';'Hash']
    store_lex "$past", $P1658
  vivify_577:
    set $P1658["block_past"], $P1657
.annotate 'line', 682
    find_lex $P1660, "$/"
    unless_null $P1660, vivify_578
    $P1660 = root_new ['parrot';'Hash']
  vivify_578:
    set $P1661, $P1660["trait"]
    unless_null $P1661, vivify_579
    new $P1661, "Undef"
  vivify_579:
    unless $P1661, if_1659_end
.annotate 'line', 683
    find_lex $P1663, "$/"
    unless_null $P1663, vivify_580
    $P1663 = root_new ['parrot';'Hash']
  vivify_580:
    set $P1664, $P1663["trait"]
    unless_null $P1664, vivify_581
    new $P1664, "Undef"
  vivify_581:
    defined $I1665, $P1664
    unless $I1665, for_undef_582
    iter $P1662, $P1664
    new $P1675, 'ExceptionHandler'
    set_label $P1675, loop1674_handler
    $P1675."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1675
  loop1674_test:
    unless $P1662, loop1674_done
    shift $P1666, $P1662
  loop1674_redo:
    .const 'Sub' $P1668 = "96_1298325483.2958" 
    capture_lex $P1668
    $P1668($P1666)
  loop1674_next:
    goto loop1674_test
  loop1674_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1676, exception, 'type'
    eq $P1676, .CONTROL_LOOP_NEXT, loop1674_next
    eq $P1676, .CONTROL_LOOP_REDO, loop1674_redo
  loop1674_done:
    pop_eh 
  for_undef_582:
  if_1659_end:
.annotate 'line', 686
    find_lex $P1677, "$/"
    find_lex $P1678, "$past"
    $P1679 = $P1677."!make"($P1678)
.annotate 'line', 565
    .return ($P1679)
.end


.namespace ["NQP";"Actions"]
.sub "_block1459"  :anon :subid("91_1298325483.2958") :outer("90_1298325483.2958")
.annotate 'line', 581
    .const 'Sub' $P1583 = "95_1298325483.2958" 
    capture_lex $P1583
    .const 'Sub' $P1494 = "92_1298325483.2958" 
    capture_lex $P1494
.annotate 'line', 582
    new $P1461, "Undef"
    .lex "$name", $P1461
    find_lex $P1462, "$/"
    unless_null $P1462, vivify_517
    $P1462 = root_new ['parrot';'Hash']
  vivify_517:
    set $P1463, $P1462["sigil"]
    unless_null $P1463, vivify_518
    $P1463 = root_new ['parrot';'ResizablePMCArray']
  vivify_518:
    set $P1464, $P1463[0]
    unless_null $P1464, vivify_519
    new $P1464, "Undef"
  vivify_519:
    set $S1465, $P1464
    new $P1466, 'String'
    set $P1466, $S1465
    find_lex $P1467, "$/"
    unless_null $P1467, vivify_520
    $P1467 = root_new ['parrot';'Hash']
  vivify_520:
    set $P1468, $P1467["deflongname"]
    unless_null $P1468, vivify_521
    $P1468 = root_new ['parrot';'ResizablePMCArray']
  vivify_521:
    set $P1469, $P1468[0]
    unless_null $P1469, vivify_522
    new $P1469, "Undef"
  vivify_522:
    $S1470 = $P1469."ast"()
    concat $P1471, $P1466, $S1470
    store_lex "$name", $P1471
.annotate 'line', 583
    find_lex $P1472, "$past"
    find_lex $P1473, "$name"
    $P1472."name"($P1473)
.annotate 'line', 584
    find_dynamic_lex $P1480, "$*SCOPE"
    unless_null $P1480, vivify_523
    get_hll_global $P1480, "$SCOPE"
    unless_null $P1480, vivify_524
    die "Contextual $*SCOPE not found"
  vivify_524:
  vivify_523:
    set $S1481, $P1480
    iseq $I1482, $S1481, ""
    unless $I1482, unless_1479
    new $P1478, 'Integer'
    set $P1478, $I1482
    goto unless_1479_end
  unless_1479:
    find_dynamic_lex $P1483, "$*SCOPE"
    unless_null $P1483, vivify_525
    get_hll_global $P1483, "$SCOPE"
    unless_null $P1483, vivify_526
    die "Contextual $*SCOPE not found"
  vivify_526:
  vivify_525:
    set $S1484, $P1483
    iseq $I1485, $S1484, "my"
    new $P1478, 'Integer'
    set $P1478, $I1485
  unless_1479_end:
    unless $P1478, unless_1477
    set $P1476, $P1478
    goto unless_1477_end
  unless_1477:
    find_dynamic_lex $P1486, "$*SCOPE"
    unless_null $P1486, vivify_527
    get_hll_global $P1486, "$SCOPE"
    unless_null $P1486, vivify_528
    die "Contextual $*SCOPE not found"
  vivify_528:
  vivify_527:
    set $S1487, $P1486
    iseq $I1488, $S1487, "our"
    new $P1476, 'Integer'
    set $P1476, $I1488
  unless_1477_end:
    if $P1476, if_1475
.annotate 'line', 676
    find_lex $P1652, "$/"
    $P1653 = $P1652."CURSOR"()
    find_dynamic_lex $P1654, "$*SCOPE"
    unless_null $P1654, vivify_529
    get_hll_global $P1654, "$SCOPE"
    unless_null $P1654, vivify_530
    die "Contextual $*SCOPE not found"
  vivify_530:
  vivify_529:
    concat $P1655, $P1654, " scoped routines are not supported yet"
    $P1656 = $P1653."panic"($P1655)
.annotate 'line', 675
    set $P1474, $P1656
.annotate 'line', 584
    goto if_1475_end
  if_1475:
.annotate 'line', 585
    find_dynamic_lex $P1490, "$*MULTINESS"
    unless_null $P1490, vivify_531
    get_hll_global $P1490, "$MULTINESS"
    unless_null $P1490, vivify_532
    die "Contextual $*MULTINESS not found"
  vivify_532:
  vivify_531:
    set $S1491, $P1490
    iseq $I1492, $S1491, "multi"
    if $I1492, if_1489
.annotate 'line', 636
    find_dynamic_lex $P1579, "$*MULTINESS"
    unless_null $P1579, vivify_533
    get_hll_global $P1579, "$MULTINESS"
    unless_null $P1579, vivify_534
    die "Contextual $*MULTINESS not found"
  vivify_534:
  vivify_533:
    set $S1580, $P1579
    iseq $I1581, $S1580, "proto"
    if $I1581, if_1578
.annotate 'line', 655
    get_global $P1613, "@BLOCK"
    unless_null $P1613, vivify_535
    $P1613 = root_new ['parrot';'ResizablePMCArray']
  vivify_535:
    set $P1614, $P1613[0]
    unless_null $P1614, vivify_536
    $P1614 = root_new ['parrot';'ResizablePMCArray']
  vivify_536:
    set $P1615, $P1614[0]
    unless_null $P1615, vivify_537
    new $P1615, "Undef"
  vivify_537:
    get_hll_global $P1616, ["PAST"], "Var"
    find_lex $P1617, "$name"
    find_lex $P1618, "$past"
    $P1619 = $P1616."new"($P1617 :named("name"), 1 :named("isdecl"), $P1618 :named("viviself"), "lexical" :named("scope"))
    $P1615."push"($P1619)
.annotate 'line', 657
    get_global $P1620, "@BLOCK"
    unless_null $P1620, vivify_538
    $P1620 = root_new ['parrot';'ResizablePMCArray']
  vivify_538:
    set $P1621, $P1620[0]
    unless_null $P1621, vivify_539
    new $P1621, "Undef"
  vivify_539:
    find_lex $P1622, "$name"
    $P1621."symbol"($P1622, "lexical" :named("scope"))
.annotate 'line', 658
    find_dynamic_lex $P1624, "$*SCOPE"
    unless_null $P1624, vivify_540
    get_hll_global $P1624, "$SCOPE"
    unless_null $P1624, vivify_541
    die "Contextual $*SCOPE not found"
  vivify_541:
  vivify_540:
    set $S1625, $P1624
    iseq $I1626, $S1625, "our"
    unless $I1626, if_1623_end
.annotate 'line', 661
    get_global $P1627, "@BLOCK"
    unless_null $P1627, vivify_542
    $P1627 = root_new ['parrot';'ResizablePMCArray']
  vivify_542:
    set $P1628, $P1627[0]
    unless_null $P1628, vivify_543
    $P1628 = root_new ['parrot';'ResizablePMCArray']
  vivify_543:
    set $P1629, $P1628[0]
    unless_null $P1629, vivify_544
    new $P1629, "Undef"
  vivify_544:
    get_hll_global $P1630, ["PAST"], "Op"
.annotate 'line', 663
    get_hll_global $P1631, ["PAST"], "Var"
    find_lex $P1632, "$name"
    $P1633 = $P1631."new"($P1632 :named("name"), "package" :named("scope"))
.annotate 'line', 664
    get_hll_global $P1634, ["PAST"], "Var"
    find_lex $P1635, "$name"
    $P1636 = $P1634."new"($P1635 :named("name"), "lexical" :named("scope"))
    $P1637 = $P1630."new"($P1633, $P1636, "bind" :named("pasttype"))
.annotate 'line', 661
    $P1629."push"($P1637)
.annotate 'line', 666
    get_global $P1638, "@BLOCK"
    unless_null $P1638, vivify_545
    $P1638 = root_new ['parrot';'ResizablePMCArray']
  vivify_545:
    set $P1639, $P1638[0]
    unless_null $P1639, vivify_546
    new $P1639, "Undef"
  vivify_546:
    $P1640 = $P1639."loadinit"()
    get_hll_global $P1641, ["PAST"], "Op"
.annotate 'line', 668
    get_hll_global $P1642, ["PAST"], "Var"
    find_lex $P1643, "$name"
    $P1644 = $P1642."new"($P1643 :named("name"), "package" :named("scope"))
.annotate 'line', 669
    get_hll_global $P1645, ["PAST"], "Val"
    find_lex $P1646, "$past"
    $P1647 = $P1645."new"($P1646 :named("value"))
    $P1648 = $P1641."new"($P1644, $P1647, "bind" :named("pasttype"))
.annotate 'line', 666
    $P1640."push"($P1648)
  if_1623_end:
.annotate 'line', 654
    goto if_1578_end
  if_1578:
.annotate 'line', 636
    .const 'Sub' $P1583 = "95_1298325483.2958" 
    capture_lex $P1583
    $P1583()
  if_1578_end:
    goto if_1489_end
  if_1489:
.annotate 'line', 585
    .const 'Sub' $P1494 = "92_1298325483.2958" 
    capture_lex $P1494
    $P1494()
  if_1489_end:
.annotate 'line', 673
    get_hll_global $P1649, ["PAST"], "Var"
    find_lex $P1650, "$name"
    $P1651 = $P1649."new"($P1650 :named("name"))
    store_lex "$past", $P1651
.annotate 'line', 584
    set $P1474, $P1651
  if_1475_end:
.annotate 'line', 581
    .return ($P1474)
.end


.namespace ["NQP";"Actions"]
.sub "_block1582"  :anon :subid("95_1298325483.2958") :outer("91_1298325483.2958")
.annotate 'line', 641
    new $P1584, "Undef"
    .lex "$cholder", $P1584
.annotate 'line', 640
    find_dynamic_lex $P1586, "$*SCOPE"
    unless_null $P1586, vivify_547
    get_hll_global $P1586, "$SCOPE"
    unless_null $P1586, vivify_548
    die "Contextual $*SCOPE not found"
  vivify_548:
  vivify_547:
    set $S1587, $P1586
    iseq $I1588, $S1587, "our"
    unless $I1588, if_1585_end
    die "our-scoped protos not yet implemented"
  if_1585_end:
.annotate 'line', 641
    get_hll_global $P1589, ["PAST"], "Op"
    $P1590 = $P1589."new"("list" :named("pasttype"))
    store_lex "$cholder", $P1590
.annotate 'line', 642
    get_global $P1591, "@BLOCK"
    unless_null $P1591, vivify_549
    $P1591 = root_new ['parrot';'ResizablePMCArray']
  vivify_549:
    set $P1592, $P1591[0]
    unless_null $P1592, vivify_550
    $P1592 = root_new ['parrot';'ResizablePMCArray']
  vivify_550:
    set $P1593, $P1592[0]
    unless_null $P1593, vivify_551
    new $P1593, "Undef"
  vivify_551:
    get_hll_global $P1594, ["PAST"], "Var"
    find_lex $P1595, "$name"
    find_lex $P1596, "$past"
    $P1597 = $P1594."new"($P1595 :named("name"), 1 :named("isdecl"), $P1596 :named("viviself"), "lexical" :named("scope"))
    $P1593."push"($P1597)
.annotate 'line', 644
    get_global $P1598, "@BLOCK"
    unless_null $P1598, vivify_552
    $P1598 = root_new ['parrot';'ResizablePMCArray']
  vivify_552:
    set $P1599, $P1598[0]
    unless_null $P1599, vivify_553
    $P1599 = root_new ['parrot';'ResizablePMCArray']
  vivify_553:
    set $P1600, $P1599[0]
    unless_null $P1600, vivify_554
    new $P1600, "Undef"
  vivify_554:
    get_hll_global $P1601, ["PAST"], "Op"
.annotate 'line', 646
    get_hll_global $P1602, ["PAST"], "Var"
    find_lex $P1603, "$name"
    $P1604 = $P1602."new"($P1603 :named("name"))
    find_lex $P1605, "$cholder"
    $P1606 = $P1601."new"($P1604, $P1605, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 644
    $P1600."push"($P1606)
.annotate 'line', 649
    get_global $P1607, "@BLOCK"
    unless_null $P1607, vivify_555
    $P1607 = root_new ['parrot';'ResizablePMCArray']
  vivify_555:
    set $P1608, $P1607[0]
    unless_null $P1608, vivify_556
    new $P1608, "Undef"
  vivify_556:
    find_lex $P1609, "$name"
    find_lex $P1610, "$cholder"
    $P1608."symbol"($P1609, "lexical" :named("scope"), 1 :named("proto"), $P1610 :named("cholder"))
.annotate 'line', 652
    find_lex $P1611, "$past"
    $P1612 = $P1611."pirflags"(":instanceof(\"DispatcherSub\")")
.annotate 'line', 636
    .return ($P1612)
.end


.namespace ["NQP";"Actions"]
.sub "_block1493"  :anon :subid("92_1298325483.2958") :outer("91_1298325483.2958")
.annotate 'line', 585
    .const 'Sub' $P1512 = "93_1298325483.2958" 
    capture_lex $P1512
.annotate 'line', 588
    new $P1495, "Undef"
    .lex "$cholder", $P1495
.annotate 'line', 589
    $P1496 = root_new ['parrot';'Hash']
    .lex "%sym", $P1496
.annotate 'line', 587
    find_dynamic_lex $P1498, "$*SCOPE"
    unless_null $P1498, vivify_557
    get_hll_global $P1498, "$SCOPE"
    unless_null $P1498, vivify_558
    die "Contextual $*SCOPE not found"
  vivify_558:
  vivify_557:
    set $S1499, $P1498
    iseq $I1500, $S1499, "our"
    unless $I1500, if_1497_end
    die "our-scoped multis not yet implemented"
  if_1497_end:
    find_lex $P1501, "$cholder"
.annotate 'line', 589
    get_global $P1502, "@BLOCK"
    unless_null $P1502, vivify_559
    $P1502 = root_new ['parrot';'ResizablePMCArray']
  vivify_559:
    set $P1503, $P1502[0]
    unless_null $P1503, vivify_560
    new $P1503, "Undef"
  vivify_560:
    find_lex $P1504, "$name"
    $P1505 = $P1503."symbol"($P1504)
    store_lex "%sym", $P1505
.annotate 'line', 590
    find_lex $P1507, "%sym"
    unless_null $P1507, vivify_561
    $P1507 = root_new ['parrot';'Hash']
  vivify_561:
    set $P1508, $P1507["cholder"]
    unless_null $P1508, vivify_562
    new $P1508, "Undef"
  vivify_562:
    if $P1508, if_1506
.annotate 'line', 595
    .const 'Sub' $P1512 = "93_1298325483.2958" 
    capture_lex $P1512
    $P1512()
    goto if_1506_end
  if_1506:
.annotate 'line', 591
    find_lex $P1509, "%sym"
    unless_null $P1509, vivify_575
    $P1509 = root_new ['parrot';'Hash']
  vivify_575:
    set $P1510, $P1509["cholder"]
    unless_null $P1510, vivify_576
    new $P1510, "Undef"
  vivify_576:
    store_lex "$cholder", $P1510
  if_1506_end:
.annotate 'line', 631
    find_lex $P1574, "$cholder"
    find_lex $P1575, "$past"
    $P1574."push"($P1575)
.annotate 'line', 634
    find_lex $P1576, "$past"
    $P1577 = "attach_multi_signature"($P1576)
.annotate 'line', 585
    .return ($P1577)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block1511"  :anon :subid("93_1298325483.2958") :outer("92_1298325483.2958")
.annotate 'line', 595
    .const 'Sub' $P1526 = "94_1298325483.2958" 
    capture_lex $P1526
.annotate 'line', 602
    new $P1513, "Undef"
    .lex "$found_proto", $P1513
.annotate 'line', 620
    new $P1514, "Undef"
    .lex "$dispatch_setup", $P1514
.annotate 'line', 597
    find_lex $P1516, "%sym"
    unless_null $P1516, vivify_563
    $P1516 = root_new ['parrot';'Hash']
  vivify_563:
    set $P1517, $P1516["proto"]
    unless_null $P1517, vivify_564
    new $P1517, "Undef"
  vivify_564:
    unless $P1517, if_1515_end
.annotate 'line', 600
    find_lex $P1518, "$/"
    $P1519 = $P1518."CURSOR"()
    $P1519."panic"("Internal Error: Current scope has a proto, but no candidate list holder was set up. (This should never happen.)")
  if_1515_end:
.annotate 'line', 597
    find_lex $P1520, "$found_proto"
.annotate 'line', 603
    get_global $P1522, "@BLOCK"
    defined $I1523, $P1522
    unless $I1523, for_undef_565
    iter $P1521, $P1522
    new $P1548, 'ExceptionHandler'
    set_label $P1548, loop1547_handler
    $P1548."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1548
  loop1547_test:
    unless $P1521, loop1547_done
    shift $P1524, $P1521
  loop1547_redo:
    .const 'Sub' $P1526 = "94_1298325483.2958" 
    capture_lex $P1526
    $P1526($P1524)
  loop1547_next:
    goto loop1547_test
  loop1547_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1549, exception, 'type'
    eq $P1549, .CONTROL_LOOP_NEXT, loop1547_next
    eq $P1549, .CONTROL_LOOP_REDO, loop1547_redo
  loop1547_done:
    pop_eh 
  for_undef_565:
.annotate 'line', 614
    find_lex $P1551, "$found_proto"
    if $P1551, unless_1550_end
.annotate 'line', 615
    find_lex $P1552, "$/"
    $P1553 = $P1552."CURSOR"()
    $P1553."panic"("Sorry, no proto sub in scope, and auto-generation of protos is not yet implemented.")
  unless_1550_end:
.annotate 'line', 619
    get_hll_global $P1554, ["PAST"], "Op"
    $P1555 = $P1554."new"("list" :named("pasttype"))
    store_lex "$cholder", $P1555
.annotate 'line', 620
    get_hll_global $P1556, ["PAST"], "Op"
.annotate 'line', 622
    get_hll_global $P1557, ["PAST"], "Var"
    find_lex $P1558, "$name"
    $P1559 = $P1557."new"($P1558 :named("name"), "outer" :named("scope"))
    find_lex $P1560, "$cholder"
    $P1561 = $P1556."new"($P1559, $P1560, "create_dispatch_and_add_candidates PPP" :named("pirop"))
.annotate 'line', 620
    store_lex "$dispatch_setup", $P1561
.annotate 'line', 625
    get_global $P1562, "@BLOCK"
    unless_null $P1562, vivify_570
    $P1562 = root_new ['parrot';'ResizablePMCArray']
  vivify_570:
    set $P1563, $P1562[0]
    unless_null $P1563, vivify_571
    $P1563 = root_new ['parrot';'ResizablePMCArray']
  vivify_571:
    set $P1564, $P1563[0]
    unless_null $P1564, vivify_572
    new $P1564, "Undef"
  vivify_572:
    get_hll_global $P1565, ["PAST"], "Var"
    find_lex $P1566, "$name"
    find_lex $P1567, "$dispatch_setup"
    $P1568 = $P1565."new"($P1566 :named("name"), 1 :named("isdecl"), $P1567 :named("viviself"), "lexical" :named("scope"))
    $P1564."push"($P1568)
.annotate 'line', 627
    get_global $P1569, "@BLOCK"
    unless_null $P1569, vivify_573
    $P1569 = root_new ['parrot';'ResizablePMCArray']
  vivify_573:
    set $P1570, $P1569[0]
    unless_null $P1570, vivify_574
    new $P1570, "Undef"
  vivify_574:
    find_lex $P1571, "$name"
    find_lex $P1572, "$cholder"
    $P1573 = $P1570."symbol"($P1571, "lexical" :named("scope"), $P1572 :named("cholder"))
.annotate 'line', 595
    .return ($P1573)
.end


.namespace ["NQP";"Actions"]
.sub "_block1525"  :anon :subid("94_1298325483.2958") :outer("93_1298325483.2958")
    .param pmc param_1528
.annotate 'line', 604
    $P1527 = root_new ['parrot';'Hash']
    .lex "%sym", $P1527
    .lex "$_", param_1528
    find_lex $P1529, "$_"
    find_lex $P1530, "$name"
    $P1531 = $P1529."symbol"($P1530)
    store_lex "%sym", $P1531
.annotate 'line', 605
    find_lex $P1536, "%sym"
    unless_null $P1536, vivify_566
    $P1536 = root_new ['parrot';'Hash']
  vivify_566:
    set $P1537, $P1536["proto"]
    unless_null $P1537, vivify_567
    new $P1537, "Undef"
  vivify_567:
    unless $P1537, unless_1535
    set $P1534, $P1537
    goto unless_1535_end
  unless_1535:
    find_lex $P1538, "%sym"
    unless_null $P1538, vivify_568
    $P1538 = root_new ['parrot';'Hash']
  vivify_568:
    set $P1539, $P1538["cholder"]
    unless_null $P1539, vivify_569
    new $P1539, "Undef"
  vivify_569:
    set $P1534, $P1539
  unless_1535_end:
    if $P1534, if_1533
.annotate 'line', 608
    find_lex $P1543, "%sym"
    if $P1543, if_1542
    set $P1541, $P1543
    goto if_1542_end
  if_1542:
.annotate 'line', 609
    find_lex $P1544, "$/"
    $P1545 = $P1544."CURSOR"()
    $P1546 = $P1545."panic"("Cannot declare a multi when an only is already in scope.")
.annotate 'line', 608
    set $P1541, $P1546
  if_1542_end:
    set $P1532, $P1541
.annotate 'line', 605
    goto if_1533_end
  if_1533:
.annotate 'line', 606
    new $P1540, "Integer"
    assign $P1540, 1
    store_lex "$found_proto", $P1540
.annotate 'line', 605
    set $P1532, $P1540
  if_1533_end:
.annotate 'line', 603
    .return ($P1532)
.end


.namespace ["NQP";"Actions"]
.sub "_block1667"  :anon :subid("96_1298325483.2958") :outer("90_1298325483.2958")
    .param pmc param_1669
.annotate 'line', 683
    .lex "$_", param_1669
    find_lex $P1670, "$_"
    $P1671 = $P1670."ast"()
    find_lex $P1672, "$/"
    $P1673 = $P1671($P1672)
    .return ($P1673)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "method_def"  :subid("97_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_1681
    .param pmc param_1682
.annotate 'line', 690
    .const 'Sub' $P1794 = "99_1298325483.2958" 
    capture_lex $P1794
    .const 'Sub' $P1710 = "98_1298325483.2958" 
    capture_lex $P1710
    .lex "self", param_1681
    .lex "$/", param_1682
.annotate 'line', 693
    new $P1683, "Undef"
    .lex "$past", $P1683
.annotate 'line', 690
    find_lex $P1684, "$past"
.annotate 'line', 694
    find_lex $P1686, "$/"
    unless_null $P1686, vivify_583
    $P1686 = root_new ['parrot';'Hash']
  vivify_583:
    set $P1687, $P1686["onlystar"]
    unless_null $P1687, vivify_584
    new $P1687, "Undef"
  vivify_584:
    if $P1687, if_1685
.annotate 'line', 698
    find_lex $P1689, "$/"
    unless_null $P1689, vivify_585
    $P1689 = root_new ['parrot';'Hash']
  vivify_585:
    set $P1690, $P1689["blockoid"]
    unless_null $P1690, vivify_586
    new $P1690, "Undef"
  vivify_586:
    $P1691 = $P1690."ast"()
    store_lex "$past", $P1691
.annotate 'line', 699
    find_lex $P1692, "$past"
    $P1692."blocktype"("declaration")
.annotate 'line', 700
    find_dynamic_lex $P1694, "$*RETURN_USED"
    unless_null $P1694, vivify_587
    get_hll_global $P1694, "$RETURN_USED"
    unless_null $P1694, vivify_588
    die "Contextual $*RETURN_USED not found"
  vivify_588:
  vivify_587:
    unless $P1694, if_1693_end
.annotate 'line', 701
    find_lex $P1695, "$past"
    $P1695."control"("return_pir")
  if_1693_end:
.annotate 'line', 697
    goto if_1685_end
  if_1685:
.annotate 'line', 695
    $P1688 = "only_star_block"()
    store_lex "$past", $P1688
  if_1685_end:
.annotate 'line', 706
    find_lex $P1697, "$past"
    unless_null $P1697, vivify_589
    $P1697 = root_new ['parrot';'Hash']
  vivify_589:
    set $P1698, $P1697["signature_has_invocant"]
    unless_null $P1698, vivify_590
    new $P1698, "Undef"
  vivify_590:
    if $P1698, unless_1696_end
.annotate 'line', 707
    find_lex $P1699, "$past"
    unless_null $P1699, vivify_591
    $P1699 = root_new ['parrot';'ResizablePMCArray']
  vivify_591:
    set $P1700, $P1699[0]
    unless_null $P1700, vivify_592
    new $P1700, "Undef"
  vivify_592:
    get_hll_global $P1701, ["PAST"], "Var"
.annotate 'line', 709
    get_hll_global $P1702, ["PAST"], "Var"
    $P1703 = $P1702."new"("$?CLASS" :named("name"))
    $P1704 = $P1701."new"("self" :named("name"), "parameter" :named("scope"), $P1703 :named("multitype"))
.annotate 'line', 707
    $P1700."unshift"($P1704)
  unless_1696_end:
.annotate 'line', 712
    find_lex $P1705, "$past"
    $P1705."symbol"("self", "lexical" :named("scope"))
.annotate 'line', 715
    find_lex $P1707, "$/"
    unless_null $P1707, vivify_593
    $P1707 = root_new ['parrot';'Hash']
  vivify_593:
    set $P1708, $P1707["deflongname"]
    unless_null $P1708, vivify_594
    new $P1708, "Undef"
  vivify_594:
    unless $P1708, if_1706_end
    .const 'Sub' $P1710 = "98_1298325483.2958" 
    capture_lex $P1710
    $P1710()
  if_1706_end:
.annotate 'line', 750
    find_dynamic_lex $P1776, "$*SCOPE"
    unless_null $P1776, vivify_612
    get_hll_global $P1776, "$SCOPE"
    unless_null $P1776, vivify_613
    die "Contextual $*SCOPE not found"
  vivify_613:
  vivify_612:
    set $S1777, $P1776
    iseq $I1778, $S1777, "our"
    unless $I1778, if_1775_end
.annotate 'line', 751
    find_lex $P1779, "$past"
    $P1779."pirflags"(":nsentry")
  if_1775_end:
.annotate 'line', 755
    find_lex $P1780, "$/"
    find_lex $P1781, "$past"
    $P1780."!make"($P1781)
.annotate 'line', 756
    find_lex $P1782, "$past"
    find_lex $P1783, "$past"
    unless_null $P1783, vivify_614
    $P1783 = root_new ['parrot';'Hash']
    store_lex "$past", $P1783
  vivify_614:
    set $P1783["block_past"], $P1782
.annotate 'line', 757
    find_lex $P1786, "$/"
    unless_null $P1786, vivify_615
    $P1786 = root_new ['parrot';'Hash']
  vivify_615:
    set $P1787, $P1786["trait"]
    unless_null $P1787, vivify_616
    new $P1787, "Undef"
  vivify_616:
    if $P1787, if_1785
    set $P1784, $P1787
    goto if_1785_end
  if_1785:
.annotate 'line', 758
    find_lex $P1789, "$/"
    unless_null $P1789, vivify_617
    $P1789 = root_new ['parrot';'Hash']
  vivify_617:
    set $P1790, $P1789["trait"]
    unless_null $P1790, vivify_618
    new $P1790, "Undef"
  vivify_618:
    defined $I1791, $P1790
    unless $I1791, for_undef_619
    iter $P1788, $P1790
    new $P1801, 'ExceptionHandler'
    set_label $P1801, loop1800_handler
    $P1801."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1801
  loop1800_test:
    unless $P1788, loop1800_done
    shift $P1792, $P1788
  loop1800_redo:
    .const 'Sub' $P1794 = "99_1298325483.2958" 
    capture_lex $P1794
    $P1794($P1792)
  loop1800_next:
    goto loop1800_test
  loop1800_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1802, exception, 'type'
    eq $P1802, .CONTROL_LOOP_NEXT, loop1800_next
    eq $P1802, .CONTROL_LOOP_REDO, loop1800_redo
  loop1800_done:
    pop_eh 
  for_undef_619:
.annotate 'line', 757
    set $P1784, $P1788
  if_1785_end:
.annotate 'line', 690
    .return ($P1784)
.end


.namespace ["NQP";"Actions"]
.sub "_block1709"  :anon :subid("98_1298325483.2958") :outer("97_1298325483.2958")
.annotate 'line', 717
    new $P1711, "Undef"
    .lex "$name", $P1711
.annotate 'line', 722
    new $P1712, "Undef"
    .lex "$to_add", $P1712
.annotate 'line', 717
    find_lex $P1713, "$/"
    unless_null $P1713, vivify_595
    $P1713 = root_new ['parrot';'Hash']
  vivify_595:
    set $P1714, $P1713["private"]
    unless_null $P1714, vivify_596
    new $P1714, "Undef"
  vivify_596:
    set $S1715, $P1714
    new $P1716, 'String'
    set $P1716, $S1715
    find_lex $P1717, "$/"
    unless_null $P1717, vivify_597
    $P1717 = root_new ['parrot';'Hash']
  vivify_597:
    set $P1718, $P1717["deflongname"]
    unless_null $P1718, vivify_598
    $P1718 = root_new ['parrot';'ResizablePMCArray']
  vivify_598:
    set $P1719, $P1718[0]
    unless_null $P1719, vivify_599
    new $P1719, "Undef"
  vivify_599:
    $P1720 = $P1719."ast"()
    set $S1721, $P1720
    concat $P1722, $P1716, $S1721
    store_lex "$name", $P1722
.annotate 'line', 718
    find_lex $P1723, "$past"
    find_lex $P1724, "$name"
    $P1723."name"($P1724)
.annotate 'line', 722
    find_dynamic_lex $P1727, "$*MULTINESS"
    unless_null $P1727, vivify_600
    get_hll_global $P1727, "$MULTINESS"
    unless_null $P1727, vivify_601
    die "Contextual $*MULTINESS not found"
  vivify_601:
  vivify_600:
    set $S1728, $P1727
    isne $I1729, $S1728, "proto"
    if $I1729, if_1726
.annotate 'line', 724
    get_hll_global $P1733, ["PAST"], "Op"
.annotate 'line', 726
    get_hll_global $P1734, ["PAST"], "Val"
    find_lex $P1735, "$past"
    $P1736 = $P1734."new"($P1735 :named("value"))
.annotate 'line', 727
    get_hll_global $P1737, ["PAST"], "Op"
    $P1738 = $P1737."new"("list" :named("pasttype"))
    $P1739 = $P1733."new"($P1736, $P1738, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 724
    set $P1725, $P1739
.annotate 'line', 722
    goto if_1726_end
  if_1726:
.annotate 'line', 723
    get_hll_global $P1730, ["PAST"], "Val"
    find_lex $P1731, "$past"
    $P1732 = $P1730."new"($P1731 :named("value"))
    set $P1725, $P1732
  if_1726_end:
.annotate 'line', 722
    store_lex "$to_add", $P1725
.annotate 'line', 729
    find_dynamic_lex $P1741, "$*MULTINESS"
    unless_null $P1741, vivify_602
    get_hll_global $P1741, "$MULTINESS"
    unless_null $P1741, vivify_603
    die "Contextual $*MULTINESS not found"
  vivify_603:
  vivify_602:
    set $S1742, $P1741
    iseq $I1743, $S1742, "proto"
    unless $I1743, if_1740_end
    find_lex $P1744, "$past"
    $P1744."pirflags"(":instanceof(\"DispatcherSub\")")
  if_1740_end:
.annotate 'line', 733
    find_dynamic_lex $P1746, "$*MULTINESS"
    unless_null $P1746, vivify_604
    get_hll_global $P1746, "$MULTINESS"
    unless_null $P1746, vivify_605
    die "Contextual $*MULTINESS not found"
  vivify_605:
  vivify_604:
    set $S1747, $P1746
    iseq $I1748, $S1747, "multi"
    unless $I1748, if_1745_end
    find_lex $P1749, "$past"
    "attach_multi_signature"($P1749)
  if_1745_end:
.annotate 'line', 736
    find_dynamic_lex $P1752, "$*PACKAGE-SETUP"
    unless_null $P1752, vivify_606
    get_hll_global $P1752, "$PACKAGE-SETUP"
    unless_null $P1752, vivify_607
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_607:
  vivify_606:
    defined $I1753, $P1752
    if $I1753, if_1751
    new $P1750, 'Integer'
    set $P1750, $I1753
    goto if_1751_end
  if_1751:
.annotate 'line', 737
    find_dynamic_lex $P1754, "$*PACKAGE-SETUP"
    unless_null $P1754, vivify_608
    get_hll_global $P1754, "$PACKAGE-SETUP"
    unless_null $P1754, vivify_609
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_609:
  vivify_608:
    get_hll_global $P1755, ["PAST"], "Op"
.annotate 'line', 738
    find_dynamic_lex $P1758, "$*MULTINESS"
    unless_null $P1758, vivify_610
    get_hll_global $P1758, "$MULTINESS"
    unless_null $P1758, vivify_611
    die "Contextual $*MULTINESS not found"
  vivify_611:
  vivify_610:
    set $S1759, $P1758
    iseq $I1760, $S1759, "multi"
    if $I1760, if_1757
    new $P1762, "String"
    assign $P1762, "add_method"
    set $P1756, $P1762
    goto if_1757_end
  if_1757:
    new $P1761, "String"
    assign $P1761, "add_multi_method"
    set $P1756, $P1761
  if_1757_end:
.annotate 'line', 739
    get_hll_global $P1763, ["PAST"], "Op"
.annotate 'line', 742
    get_hll_global $P1764, ["PAST"], "Var"
    $P1765 = $P1764."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1766 = $P1763."new"($P1765, "get_how PP" :named("pirop"))
.annotate 'line', 744
    get_hll_global $P1767, ["PAST"], "Var"
    $P1768 = $P1767."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 745
    get_hll_global $P1769, ["PAST"], "Val"
    find_lex $P1770, "$name"
    $P1771 = $P1769."new"($P1770 :named("value"))
    find_lex $P1772, "$to_add"
    $P1773 = $P1755."new"($P1766, $P1768, $P1771, $P1772, "callmethod" :named("pasttype"), $P1756 :named("name"))
.annotate 'line', 737
    $P1774 = $P1754."push"($P1773)
.annotate 'line', 736
    set $P1750, $P1774
  if_1751_end:
.annotate 'line', 715
    .return ($P1750)
.end


.namespace ["NQP";"Actions"]
.sub "_block1793"  :anon :subid("99_1298325483.2958") :outer("97_1298325483.2958")
    .param pmc param_1795
.annotate 'line', 758
    .lex "$_", param_1795
    find_lex $P1796, "$_"
    $P1797 = $P1796."ast"()
    find_lex $P1798, "$/"
    $P1799 = $P1797($P1798)
    .return ($P1799)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "signature"  :subid("100_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_1806
    .param pmc param_1807
.annotate 'line', 790
    .const 'Sub' $P1840 = "102_1298325483.2958" 
    capture_lex $P1840
    .const 'Sub' $P1816 = "101_1298325483.2958" 
    capture_lex $P1816
    .lex "self", param_1806
    .lex "$/", param_1807
.annotate 'line', 791
    new $P1808, "Undef"
    .lex "$BLOCKINIT", $P1808
    get_global $P1809, "@BLOCK"
    unless_null $P1809, vivify_620
    $P1809 = root_new ['parrot';'ResizablePMCArray']
  vivify_620:
    set $P1810, $P1809[0]
    unless_null $P1810, vivify_621
    $P1810 = root_new ['parrot';'ResizablePMCArray']
  vivify_621:
    set $P1811, $P1810[0]
    unless_null $P1811, vivify_622
    new $P1811, "Undef"
  vivify_622:
    store_lex "$BLOCKINIT", $P1811
.annotate 'line', 792
    find_lex $P1813, "$/"
    unless_null $P1813, vivify_623
    $P1813 = root_new ['parrot';'Hash']
  vivify_623:
    set $P1814, $P1813["invocant"]
    unless_null $P1814, vivify_624
    new $P1814, "Undef"
  vivify_624:
    unless $P1814, if_1812_end
    .const 'Sub' $P1816 = "101_1298325483.2958" 
    capture_lex $P1816
    $P1816()
  if_1812_end:
.annotate 'line', 801
    find_lex $P1835, "$/"
    unless_null $P1835, vivify_630
    $P1835 = root_new ['parrot';'Hash']
  vivify_630:
    set $P1836, $P1835["parameter"]
    unless_null $P1836, vivify_631
    new $P1836, "Undef"
  vivify_631:
    defined $I1837, $P1836
    unless $I1837, for_undef_632
    iter $P1834, $P1836
    new $P1847, 'ExceptionHandler'
    set_label $P1847, loop1846_handler
    $P1847."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1847
  loop1846_test:
    unless $P1834, loop1846_done
    shift $P1838, $P1834
  loop1846_redo:
    .const 'Sub' $P1840 = "102_1298325483.2958" 
    capture_lex $P1840
    $P1840($P1838)
  loop1846_next:
    goto loop1846_test
  loop1846_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1848, exception, 'type'
    eq $P1848, .CONTROL_LOOP_NEXT, loop1846_next
    eq $P1848, .CONTROL_LOOP_REDO, loop1846_redo
  loop1846_done:
    pop_eh 
  for_undef_632:
.annotate 'line', 790
    .return ($P1834)
.end


.namespace ["NQP";"Actions"]
.sub "_block1815"  :anon :subid("101_1298325483.2958") :outer("100_1298325483.2958")
.annotate 'line', 793
    new $P1817, "Undef"
    .lex "$inv", $P1817
    find_lex $P1818, "$/"
    unless_null $P1818, vivify_625
    $P1818 = root_new ['parrot';'Hash']
  vivify_625:
    set $P1819, $P1818["invocant"]
    unless_null $P1819, vivify_626
    $P1819 = root_new ['parrot';'ResizablePMCArray']
  vivify_626:
    set $P1820, $P1819[0]
    unless_null $P1820, vivify_627
    new $P1820, "Undef"
  vivify_627:
    $P1821 = $P1820."ast"()
    store_lex "$inv", $P1821
.annotate 'line', 794
    find_lex $P1822, "$BLOCKINIT"
    find_lex $P1823, "$inv"
    $P1822."push"($P1823)
.annotate 'line', 795
    find_lex $P1824, "$BLOCKINIT"
    get_hll_global $P1825, ["PAST"], "Var"
.annotate 'line', 797
    get_hll_global $P1826, ["PAST"], "Var"
    find_lex $P1827, "$inv"
    $P1828 = $P1827."name"()
    $P1829 = $P1826."new"("lexical" :named("scope"), $P1828 :named("name"))
    $P1830 = $P1825."new"("self" :named("name"), "lexical" :named("scope"), 1 :named("isdecl"), $P1829 :named("viviself"))
.annotate 'line', 795
    $P1824."push"($P1830)
.annotate 'line', 799
    new $P1831, "Integer"
    assign $P1831, 1
    get_global $P1832, "@BLOCK"
    unless_null $P1832, vivify_628
    $P1832 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P1832
  vivify_628:
    set $P1833, $P1832[0]
    unless_null $P1833, vivify_629
    $P1833 = root_new ['parrot';'Hash']
    set $P1832[0], $P1833
  vivify_629:
    set $P1833["signature_has_invocant"], $P1831
.annotate 'line', 792
    .return ($P1831)
.end


.namespace ["NQP";"Actions"]
.sub "_block1839"  :anon :subid("102_1298325483.2958") :outer("100_1298325483.2958")
    .param pmc param_1841
.annotate 'line', 801
    .lex "$_", param_1841
    find_lex $P1842, "$BLOCKINIT"
    find_lex $P1843, "$_"
    $P1844 = $P1843."ast"()
    $P1845 = $P1842."push"($P1844)
    .return ($P1845)
.end


.namespace ["NQP";"Actions"]
.sub "parameter"  :subid("103_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_1850
    .param pmc param_1851
.annotate 'line', 804
    .lex "self", param_1850
    .lex "$/", param_1851
.annotate 'line', 805
    new $P1852, "Undef"
    .lex "$quant", $P1852
.annotate 'line', 806
    new $P1853, "Undef"
    .lex "$past", $P1853
.annotate 'line', 805
    find_lex $P1854, "$/"
    unless_null $P1854, vivify_633
    $P1854 = root_new ['parrot';'Hash']
  vivify_633:
    set $P1855, $P1854["quant"]
    unless_null $P1855, vivify_634
    new $P1855, "Undef"
  vivify_634:
    store_lex "$quant", $P1855
    find_lex $P1856, "$past"
.annotate 'line', 807
    find_lex $P1858, "$/"
    unless_null $P1858, vivify_635
    $P1858 = root_new ['parrot';'Hash']
  vivify_635:
    set $P1859, $P1858["named_param"]
    unless_null $P1859, vivify_636
    new $P1859, "Undef"
  vivify_636:
    if $P1859, if_1857
.annotate 'line', 814
    find_lex $P1873, "$/"
    unless_null $P1873, vivify_637
    $P1873 = root_new ['parrot';'Hash']
  vivify_637:
    set $P1874, $P1873["param_var"]
    unless_null $P1874, vivify_638
    new $P1874, "Undef"
  vivify_638:
    $P1875 = $P1874."ast"()
    store_lex "$past", $P1875
.annotate 'line', 815
    find_lex $P1877, "$quant"
    set $S1878, $P1877
    iseq $I1879, $S1878, "*"
    if $I1879, if_1876
.annotate 'line', 819
    find_lex $P1888, "$quant"
    set $S1889, $P1888
    iseq $I1890, $S1889, "?"
    unless $I1890, if_1887_end
.annotate 'line', 820
    find_lex $P1891, "$past"
    find_lex $P1892, "$/"
    unless_null $P1892, vivify_639
    $P1892 = root_new ['parrot';'Hash']
  vivify_639:
    set $P1893, $P1892["param_var"]
    unless_null $P1893, vivify_640
    $P1893 = root_new ['parrot';'Hash']
  vivify_640:
    set $P1894, $P1893["sigil"]
    unless_null $P1894, vivify_641
    new $P1894, "Undef"
  vivify_641:
    $P1895 = "vivitype"($P1894)
    $P1891."viviself"($P1895)
  if_1887_end:
.annotate 'line', 819
    goto if_1876_end
  if_1876:
.annotate 'line', 816
    find_lex $P1880, "$past"
    $P1880."slurpy"(1)
.annotate 'line', 817
    find_lex $P1881, "$past"
    find_lex $P1882, "$/"
    unless_null $P1882, vivify_642
    $P1882 = root_new ['parrot';'Hash']
  vivify_642:
    set $P1883, $P1882["param_var"]
    unless_null $P1883, vivify_643
    $P1883 = root_new ['parrot';'Hash']
  vivify_643:
    set $P1884, $P1883["sigil"]
    unless_null $P1884, vivify_644
    new $P1884, "Undef"
  vivify_644:
    set $S1885, $P1884
    iseq $I1886, $S1885, "%"
    $P1881."named"($I1886)
  if_1876_end:
.annotate 'line', 813
    goto if_1857_end
  if_1857:
.annotate 'line', 808
    find_lex $P1860, "$/"
    unless_null $P1860, vivify_645
    $P1860 = root_new ['parrot';'Hash']
  vivify_645:
    set $P1861, $P1860["named_param"]
    unless_null $P1861, vivify_646
    new $P1861, "Undef"
  vivify_646:
    $P1862 = $P1861."ast"()
    store_lex "$past", $P1862
.annotate 'line', 809
    find_lex $P1864, "$quant"
    set $S1865, $P1864
    isne $I1866, $S1865, "!"
    unless $I1866, if_1863_end
.annotate 'line', 810
    find_lex $P1867, "$past"
    find_lex $P1868, "$/"
    unless_null $P1868, vivify_647
    $P1868 = root_new ['parrot';'Hash']
  vivify_647:
    set $P1869, $P1868["named_param"]
    unless_null $P1869, vivify_648
    $P1869 = root_new ['parrot';'Hash']
  vivify_648:
    set $P1870, $P1869["param_var"]
    unless_null $P1870, vivify_649
    $P1870 = root_new ['parrot';'Hash']
  vivify_649:
    set $P1871, $P1870["sigil"]
    unless_null $P1871, vivify_650
    new $P1871, "Undef"
  vivify_650:
    $P1872 = "vivitype"($P1871)
    $P1867."viviself"($P1872)
  if_1863_end:
  if_1857_end:
.annotate 'line', 823
    find_lex $P1897, "$/"
    unless_null $P1897, vivify_651
    $P1897 = root_new ['parrot';'Hash']
  vivify_651:
    set $P1898, $P1897["default_value"]
    unless_null $P1898, vivify_652
    new $P1898, "Undef"
  vivify_652:
    unless $P1898, if_1896_end
.annotate 'line', 824
    find_lex $P1900, "$quant"
    set $S1901, $P1900
    iseq $I1902, $S1901, "*"
    unless $I1902, if_1899_end
.annotate 'line', 825
    find_lex $P1903, "$/"
    $P1904 = $P1903."CURSOR"()
    $P1904."panic"("Can't put default on slurpy parameter")
  if_1899_end:
.annotate 'line', 827
    find_lex $P1906, "$quant"
    set $S1907, $P1906
    iseq $I1908, $S1907, "!"
    unless $I1908, if_1905_end
.annotate 'line', 828
    find_lex $P1909, "$/"
    $P1910 = $P1909."CURSOR"()
    $P1910."panic"("Can't put default on required parameter")
  if_1905_end:
.annotate 'line', 830
    find_lex $P1911, "$past"
    find_lex $P1912, "$/"
    unless_null $P1912, vivify_653
    $P1912 = root_new ['parrot';'Hash']
  vivify_653:
    set $P1913, $P1912["default_value"]
    unless_null $P1913, vivify_654
    $P1913 = root_new ['parrot';'ResizablePMCArray']
  vivify_654:
    set $P1914, $P1913[0]
    unless_null $P1914, vivify_655
    $P1914 = root_new ['parrot';'Hash']
  vivify_655:
    set $P1915, $P1914["EXPR"]
    unless_null $P1915, vivify_656
    new $P1915, "Undef"
  vivify_656:
    $P1916 = $P1915."ast"()
    $P1911."viviself"($P1916)
  if_1896_end:
.annotate 'line', 832
    find_lex $P1918, "$past"
    $P1919 = $P1918."viviself"()
    if $P1919, unless_1917_end
    get_global $P1920, "@BLOCK"
    unless_null $P1920, vivify_657
    $P1920 = root_new ['parrot';'ResizablePMCArray']
  vivify_657:
    set $P1921, $P1920[0]
    unless_null $P1921, vivify_658
    new $P1921, "Undef"
  vivify_658:
    get_global $P1922, "@BLOCK"
    unless_null $P1922, vivify_659
    $P1922 = root_new ['parrot';'ResizablePMCArray']
  vivify_659:
    set $P1923, $P1922[0]
    unless_null $P1923, vivify_660
    new $P1923, "Undef"
  vivify_660:
    $P1924 = $P1923."arity"()
    set $N1925, $P1924
    new $P1926, 'Float'
    set $P1926, $N1925
    add $P1927, $P1926, 1
    $P1921."arity"($P1927)
  unless_1917_end:
.annotate 'line', 836
    find_lex $P1929, "$/"
    unless_null $P1929, vivify_661
    $P1929 = root_new ['parrot';'Hash']
  vivify_661:
    set $P1930, $P1929["typename"]
    unless_null $P1930, vivify_662
    new $P1930, "Undef"
  vivify_662:
    unless $P1930, if_1928_end
.annotate 'line', 837
    find_lex $P1931, "$past"
    find_lex $P1932, "$/"
    unless_null $P1932, vivify_663
    $P1932 = root_new ['parrot';'Hash']
  vivify_663:
    set $P1933, $P1932["typename"]
    unless_null $P1933, vivify_664
    $P1933 = root_new ['parrot';'ResizablePMCArray']
  vivify_664:
    set $P1934, $P1933[0]
    unless_null $P1934, vivify_665
    new $P1934, "Undef"
  vivify_665:
    $P1935 = $P1934."ast"()
    $P1931."multitype"($P1935)
  if_1928_end:
.annotate 'line', 841
    find_lex $P1937, "$/"
    unless_null $P1937, vivify_666
    $P1937 = root_new ['parrot';'Hash']
  vivify_666:
    set $P1938, $P1937["definedness"]
    unless_null $P1938, vivify_667
    new $P1938, "Undef"
  vivify_667:
    unless $P1938, if_1936_end
.annotate 'line', 842
    find_lex $P1939, "$/"
    unless_null $P1939, vivify_668
    $P1939 = root_new ['parrot';'Hash']
  vivify_668:
    set $P1940, $P1939["definedness"]
    unless_null $P1940, vivify_669
    $P1940 = root_new ['parrot';'ResizablePMCArray']
  vivify_669:
    set $P1941, $P1940[0]
    unless_null $P1941, vivify_670
    new $P1941, "Undef"
  vivify_670:
    set $S1942, $P1941
    new $P1943, 'String'
    set $P1943, $S1942
    find_lex $P1944, "$past"
    unless_null $P1944, vivify_671
    $P1944 = root_new ['parrot';'Hash']
    store_lex "$past", $P1944
  vivify_671:
    set $P1944["definedness"], $P1943
  if_1936_end:
.annotate 'line', 845
    find_lex $P1945, "$/"
    find_lex $P1946, "$past"
    $P1947 = $P1945."!make"($P1946)
.annotate 'line', 804
    .return ($P1947)
.end


.namespace ["NQP";"Actions"]
.sub "param_var"  :subid("104_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_1949
    .param pmc param_1950
.annotate 'line', 848
    .lex "self", param_1949
    .lex "$/", param_1950
.annotate 'line', 849
    new $P1951, "Undef"
    .lex "$name", $P1951
.annotate 'line', 850
    new $P1952, "Undef"
    .lex "$past", $P1952
.annotate 'line', 849
    find_lex $P1953, "$/"
    set $S1954, $P1953
    new $P1955, 'String'
    set $P1955, $S1954
    store_lex "$name", $P1955
.annotate 'line', 850
    get_hll_global $P1956, ["PAST"], "Var"
    find_lex $P1957, "$name"
    find_lex $P1958, "$/"
    $P1959 = $P1956."new"($P1957 :named("name"), "parameter" :named("scope"), 1 :named("isdecl"), $P1958 :named("node"))
    store_lex "$past", $P1959
.annotate 'line', 852
    get_global $P1960, "@BLOCK"
    unless_null $P1960, vivify_672
    $P1960 = root_new ['parrot';'ResizablePMCArray']
  vivify_672:
    set $P1961, $P1960[0]
    unless_null $P1961, vivify_673
    new $P1961, "Undef"
  vivify_673:
    find_lex $P1962, "$name"
    $P1961."symbol"($P1962, "lexical" :named("scope"))
.annotate 'line', 853
    find_lex $P1963, "$/"
    find_lex $P1964, "$past"
    $P1965 = $P1963."!make"($P1964)
.annotate 'line', 848
    .return ($P1965)
.end


.namespace ["NQP";"Actions"]
.sub "named_param"  :subid("105_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_1967
    .param pmc param_1968
.annotate 'line', 856
    .lex "self", param_1967
    .lex "$/", param_1968
.annotate 'line', 857
    new $P1969, "Undef"
    .lex "$past", $P1969
    find_lex $P1970, "$/"
    unless_null $P1970, vivify_674
    $P1970 = root_new ['parrot';'Hash']
  vivify_674:
    set $P1971, $P1970["param_var"]
    unless_null $P1971, vivify_675
    new $P1971, "Undef"
  vivify_675:
    $P1972 = $P1971."ast"()
    store_lex "$past", $P1972
.annotate 'line', 858
    find_lex $P1973, "$past"
    find_lex $P1974, "$/"
    unless_null $P1974, vivify_676
    $P1974 = root_new ['parrot';'Hash']
  vivify_676:
    set $P1975, $P1974["param_var"]
    unless_null $P1975, vivify_677
    $P1975 = root_new ['parrot';'Hash']
  vivify_677:
    set $P1976, $P1975["name"]
    unless_null $P1976, vivify_678
    new $P1976, "Undef"
  vivify_678:
    set $S1977, $P1976
    $P1973."named"($S1977)
.annotate 'line', 859
    find_lex $P1978, "$/"
    find_lex $P1979, "$past"
    $P1980 = $P1978."!make"($P1979)
.annotate 'line', 856
    .return ($P1980)
.end


.namespace ["NQP";"Actions"]
.sub "typename"  :subid("106_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_1982
    .param pmc param_1983
.annotate 'line', 862
    .lex "self", param_1982
    .lex "$/", param_1983
.annotate 'line', 863
    $P1984 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P1984
    get_hll_global $P1985, ["HLL"], "Compiler"
    find_lex $P1986, "$/"
    set $S1987, $P1986
    $P1988 = $P1985."parse_name"($S1987)
    store_lex "@name", $P1988
.annotate 'line', 864
    find_lex $P1989, "$/"
    get_hll_global $P1990, ["PAST"], "Var"
.annotate 'line', 865
    find_lex $P1991, "@name"
    $P1992 = $P1991."pop"()
    find_lex $P1993, "@name"
    $P1994 = $P1990."new"($P1992 :named("name"), $P1993 :named("namespace"), "package" :named("scope"))
.annotate 'line', 864
    $P1995 = $P1989."!make"($P1994)
.annotate 'line', 862
    .return ($P1995)
.end


.namespace ["NQP";"Actions"]
.sub "trait"  :subid("107_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_1997
    .param pmc param_1998
.annotate 'line', 871
    .lex "self", param_1997
    .lex "$/", param_1998
.annotate 'line', 872
    find_lex $P1999, "$/"
    find_lex $P2000, "$/"
    unless_null $P2000, vivify_679
    $P2000 = root_new ['parrot';'Hash']
  vivify_679:
    set $P2001, $P2000["trait_mod"]
    unless_null $P2001, vivify_680
    new $P2001, "Undef"
  vivify_680:
    $P2002 = $P2001."ast"()
    $P2003 = $P1999."!make"($P2002)
.annotate 'line', 871
    .return ($P2003)
.end


.namespace ["NQP";"Actions"]
.sub "trait_mod:sym<is>"  :subid("108_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_2005
    .param pmc param_2006
.annotate 'line', 875
    .const 'Sub' $P2026 = "109_1298325483.2958" 
    capture_lex $P2026
    .lex "self", param_2005
    .lex "$/", param_2006
.annotate 'line', 876
    new $P2007, "Undef"
    .lex "$cpast", $P2007
    find_lex $P2008, "$/"
    unless_null $P2008, vivify_681
    $P2008 = root_new ['parrot';'Hash']
  vivify_681:
    set $P2009, $P2008["circumfix"]
    unless_null $P2009, vivify_682
    $P2009 = root_new ['parrot';'ResizablePMCArray']
  vivify_682:
    set $P2010, $P2009[0]
    unless_null $P2010, vivify_683
    new $P2010, "Undef"
  vivify_683:
    $P2011 = $P2010."ast"()
    store_lex "$cpast", $P2011
.annotate 'line', 877
    find_lex $P2014, "$/"
    unless_null $P2014, vivify_684
    $P2014 = root_new ['parrot';'Hash']
  vivify_684:
    set $P2015, $P2014["longname"]
    unless_null $P2015, vivify_685
    new $P2015, "Undef"
  vivify_685:
    set $S2016, $P2015
    iseq $I2017, $S2016, "parrot_vtable"
    if $I2017, if_2013
.annotate 'line', 897
    find_lex $P2052, "$/"
    unless_null $P2052, vivify_686
    $P2052 = root_new ['parrot';'Hash']
  vivify_686:
    set $P2053, $P2052["longname"]
    unless_null $P2053, vivify_687
    new $P2053, "Undef"
  vivify_687:
    set $S2054, $P2053
    iseq $I2055, $S2054, "pirflags"
    if $I2055, if_2051
.annotate 'line', 901
    find_lex $P2059, "$/"
    $P2060 = $P2059."CURSOR"()
    new $P2061, 'String'
    set $P2061, "Trait '"
    find_lex $P2062, "$/"
    unless_null $P2062, vivify_688
    $P2062 = root_new ['parrot';'Hash']
  vivify_688:
    set $P2063, $P2062["longname"]
    unless_null $P2063, vivify_689
    new $P2063, "Undef"
  vivify_689:
    concat $P2064, $P2061, $P2063
    concat $P2065, $P2064, "' not implemented"
    $P2066 = $P2060."panic"($P2065)
.annotate 'line', 900
    set $P2050, $P2066
.annotate 'line', 897
    goto if_2051_end
  if_2051:
.annotate 'line', 898
    find_lex $P2056, "$/"
    $P2057 = $P2056."CURSOR"()
    $P2058 = $P2057."panic"("Trait 'pirflags' no longer supported; use 'is vtable'")
.annotate 'line', 897
    set $P2050, $P2058
  if_2051_end:
    set $P2012, $P2050
.annotate 'line', 877
    goto if_2013_end
  if_2013:
.annotate 'line', 880
    get_hll_global $P2019, ["PAST"], "Val"
    find_lex $P2020, "$cpast"
    $P2021 = $P2019."ACCEPTS"($P2020)
    if $P2021, unless_2018_end
.annotate 'line', 879
    find_lex $P2022, "$/"
    $P2023 = $P2022."CURSOR"()
    $P2023."panic"("Trait 'parrot_vtable' requires constant scalar argument")
  unless_2018_end:
.annotate 'line', 881
    find_lex $P2024, "$/"
    .const 'Sub' $P2026 = "109_1298325483.2958" 
    newclosure $P2048, $P2026
    $P2049 = $P2024."!make"($P2048)
.annotate 'line', 877
    set $P2012, $P2049
  if_2013_end:
.annotate 'line', 875
    .return ($P2012)
.end


.namespace ["NQP";"Actions"]
.sub "_block2025"  :anon :subid("109_1298325483.2958") :outer("108_1298325483.2958")
    .param pmc param_2027
.annotate 'line', 881
    .lex "$match", param_2027
.annotate 'line', 882
    new $P2028, "Undef"
    .lex "$meth", $P2028
    find_lex $P2029, "$match"
    $P2030 = $P2029."ast"()
    set $P2031, $P2030["block_past"]
    unless_null $P2031, vivify_690
    new $P2031, "Undef"
  vivify_690:
    store_lex "$meth", $P2031
.annotate 'line', 883
    find_dynamic_lex $P2034, "$*PACKAGE-SETUP"
    unless_null $P2034, vivify_691
    get_hll_global $P2034, "$PACKAGE-SETUP"
    unless_null $P2034, vivify_692
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_692:
  vivify_691:
    defined $I2035, $P2034
    if $I2035, if_2033
    new $P2032, 'Integer'
    set $P2032, $I2035
    goto if_2033_end
  if_2033:
.annotate 'line', 884
    find_dynamic_lex $P2036, "$*PACKAGE-SETUP"
    unless_null $P2036, vivify_693
    get_hll_global $P2036, "$PACKAGE-SETUP"
    unless_null $P2036, vivify_694
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_694:
  vivify_693:
    get_hll_global $P2037, ["PAST"], "Op"
.annotate 'line', 886
    get_hll_global $P2038, ["PAST"], "Op"
.annotate 'line', 889
    get_hll_global $P2039, ["PAST"], "Var"
    $P2040 = $P2039."new"("type_obj" :named("name"), "register" :named("scope"))
    $P2041 = $P2038."new"($P2040, "get_how PP" :named("pirop"))
.annotate 'line', 891
    get_hll_global $P2042, ["PAST"], "Var"
    $P2043 = $P2042."new"("type_obj" :named("name"), "register" :named("scope"))
    find_lex $P2044, "$cpast"
    find_lex $P2045, "$meth"
    $P2046 = $P2037."new"($P2041, $P2043, $P2044, $P2045, "callmethod" :named("pasttype"), "add_parrot_vtable_mapping" :named("name"))
.annotate 'line', 884
    $P2047 = $P2036."push"($P2046)
.annotate 'line', 883
    set $P2032, $P2047
  if_2033_end:
.annotate 'line', 881
    .return ($P2032)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "regex_declarator"  :subid("110_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_2070
    .param pmc param_2071
    .param pmc param_2072 :optional
    .param int has_param_2072 :opt_flag
.annotate 'line', 905
    .const 'Sub' $P2170 = "113_1298325483.2958" 
    capture_lex $P2170
    .const 'Sub' $P2142 = "112_1298325483.2958" 
    capture_lex $P2142
    .const 'Sub' $P2115 = "111_1298325483.2958" 
    capture_lex $P2115
    new $P2069, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2069, control_2068
    push_eh $P2069
    .lex "self", param_2070
    .lex "$/", param_2071
    if has_param_2072, optparam_695
    new $P2073, "Undef"
    set param_2072, $P2073
  optparam_695:
    .lex "$key", param_2072
.annotate 'line', 906
    $P2074 = root_new ['parrot';'ResizablePMCArray']
    .lex "@MODIFIERS", $P2074
.annotate 'line', 909
    new $P2075, "Undef"
    .lex "$name", $P2075
.annotate 'line', 910
    new $P2076, "Undef"
    .lex "$past", $P2076
.annotate 'line', 906

        $P2077 = get_hll_global ['Regex';'P6Regex';'Actions'], '@MODIFIERS'
    
    store_lex "@MODIFIERS", $P2077
.annotate 'line', 909
    find_lex $P2078, "$/"
    unless_null $P2078, vivify_696
    $P2078 = root_new ['parrot';'Hash']
  vivify_696:
    set $P2079, $P2078["deflongname"]
    unless_null $P2079, vivify_697
    new $P2079, "Undef"
  vivify_697:
    $P2080 = $P2079."ast"()
    set $S2081, $P2080
    new $P2082, 'String'
    set $P2082, $S2081
    store_lex "$name", $P2082
    find_lex $P2083, "$past"
.annotate 'line', 911
    find_lex $P2085, "$/"
    unless_null $P2085, vivify_698
    $P2085 = root_new ['parrot';'Hash']
  vivify_698:
    set $P2086, $P2085["proto"]
    unless_null $P2086, vivify_699
    new $P2086, "Undef"
  vivify_699:
    if $P2086, if_2084
.annotate 'line', 950
    find_lex $P2138, "$key"
    set $S2139, $P2138
    iseq $I2140, $S2139, "open"
    if $I2140, if_2137
.annotate 'line', 963
    .const 'Sub' $P2170 = "113_1298325483.2958" 
    capture_lex $P2170
    $P2170()
    goto if_2137_end
  if_2137:
.annotate 'line', 950
    .const 'Sub' $P2142 = "112_1298325483.2958" 
    capture_lex $P2142
    $P2142()
  if_2137_end:
    goto if_2084_end
  if_2084:
.annotate 'line', 913
    get_hll_global $P2087, ["PAST"], "Stmts"
.annotate 'line', 914
    get_hll_global $P2088, ["PAST"], "Block"
    find_lex $P2089, "$name"
.annotate 'line', 915
    get_hll_global $P2090, ["PAST"], "Op"
.annotate 'line', 916
    get_hll_global $P2091, ["PAST"], "Var"
    $P2092 = $P2091."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P2093, "$name"
    $P2094 = $P2090."new"($P2092, $P2093, "!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 915
    find_lex $P2095, "$/"
    $P2096 = $P2088."new"($P2094, $P2089 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P2095 :named("node"))
.annotate 'line', 925
    get_hll_global $P2097, ["PAST"], "Block"
    new $P2098, "String"
    assign $P2098, "!PREFIX__"
    find_lex $P2099, "$name"
    concat $P2100, $P2098, $P2099
.annotate 'line', 926
    get_hll_global $P2101, ["PAST"], "Op"
.annotate 'line', 927
    get_hll_global $P2102, ["PAST"], "Var"
    $P2103 = $P2102."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P2104, "$name"
    $P2105 = $P2101."new"($P2103, $P2104, "!PREFIX__!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 926
    find_lex $P2106, "$/"
    $P2107 = $P2097."new"($P2105, $P2100 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P2106 :named("node"))
.annotate 'line', 925
    $P2108 = $P2087."new"($P2096, $P2107)
.annotate 'line', 913
    store_lex "$past", $P2108
.annotate 'line', 937
    find_lex $P2110, "$past"
    $P2111 = $P2110."list"()
    defined $I2112, $P2111
    unless $I2112, for_undef_720
    iter $P2109, $P2111
    new $P2135, 'ExceptionHandler'
    set_label $P2135, loop2134_handler
    $P2135."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2135
  loop2134_test:
    unless $P2109, loop2134_done
    shift $P2113, $P2109
  loop2134_redo:
    .const 'Sub' $P2115 = "111_1298325483.2958" 
    capture_lex $P2115
    $P2115($P2113)
  loop2134_next:
    goto loop2134_test
  loop2134_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2136, exception, 'type'
    eq $P2136, .CONTROL_LOOP_NEXT, loop2134_next
    eq $P2136, .CONTROL_LOOP_REDO, loop2134_redo
  loop2134_done:
    pop_eh 
  for_undef_720:
  if_2084_end:
.annotate 'line', 999
    find_lex $P2228, "$/"
    find_lex $P2229, "$past"
    $P2230 = $P2228."!make"($P2229)
.annotate 'line', 905
    .return ($P2230)
  control_2068:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2231, exception, "payload"
    .return ($P2231)
.end


.namespace ["NQP";"Actions"]
.sub "_block2169"  :anon :subid("113_1298325483.2958") :outer("110_1298325483.2958")
.annotate 'line', 964
    new $P2171, "Undef"
    .lex "$regex", $P2171
.annotate 'line', 965
    get_hll_global $P2172, ["Regex";"P6Regex";"Actions"], "buildsub"
    find_lex $P2173, "$/"
    unless_null $P2173, vivify_700
    $P2173 = root_new ['parrot';'Hash']
  vivify_700:
    set $P2174, $P2173["p6regex"]
    unless_null $P2174, vivify_701
    new $P2174, "Undef"
  vivify_701:
    $P2175 = $P2174."ast"()
    get_global $P2176, "@BLOCK"
    $P2177 = $P2176."shift"()
    $P2178 = $P2172($P2175, $P2177)
    store_lex "$regex", $P2178
.annotate 'line', 966
    find_lex $P2179, "$regex"
    find_lex $P2180, "$name"
    $P2179."name"($P2180)
.annotate 'line', 968
    get_hll_global $P2181, ["PAST"], "Op"
.annotate 'line', 970
    get_hll_global $P2182, ["PAST"], "Var"
    new $P2183, "ResizablePMCArray"
    push $P2183, "Regex"
    $P2184 = $P2182."new"("Method" :named("name"), $P2183 :named("namespace"), "package" :named("scope"))
    find_lex $P2185, "$regex"
    $P2186 = $P2181."new"($P2184, $P2185, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 968
    store_lex "$past", $P2186
.annotate 'line', 973
    find_dynamic_lex $P2188, "$*PACKAGE-SETUP"
    unless_null $P2188, vivify_702
    get_hll_global $P2188, "$PACKAGE-SETUP"
    unless_null $P2188, vivify_703
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_703:
  vivify_702:
    defined $I2189, $P2188
    unless $I2189, if_2187_end
.annotate 'line', 974
    find_dynamic_lex $P2190, "$*PACKAGE-SETUP"
    unless_null $P2190, vivify_704
    get_hll_global $P2190, "$PACKAGE-SETUP"
    unless_null $P2190, vivify_705
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_705:
  vivify_704:
    get_hll_global $P2191, ["PAST"], "Op"
.annotate 'line', 976
    get_hll_global $P2192, ["PAST"], "Op"
.annotate 'line', 978
    get_hll_global $P2193, ["PAST"], "Var"
    $P2194 = $P2193."new"("type_obj" :named("name"), "register" :named("scope"))
    $P2195 = $P2192."new"($P2194, "get_how PP" :named("pirop"))
.annotate 'line', 980
    get_hll_global $P2196, ["PAST"], "Var"
    $P2197 = $P2196."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 981
    get_hll_global $P2198, ["PAST"], "Val"
    find_lex $P2199, "$name"
    $P2200 = $P2198."new"($P2199 :named("value"))
.annotate 'line', 982
    get_hll_global $P2201, ["PAST"], "Val"
    find_lex $P2202, "$regex"
    $P2203 = $P2201."new"($P2202 :named("value"))
    $P2204 = $P2191."new"($P2195, $P2197, $P2200, $P2203, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 974
    $P2190."push"($P2204)
.annotate 'line', 984
    find_dynamic_lex $P2205, "$*PACKAGE-SETUP"
    unless_null $P2205, vivify_706
    get_hll_global $P2205, "$PACKAGE-SETUP"
    unless_null $P2205, vivify_707
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_707:
  vivify_706:
    get_hll_global $P2206, ["PAST"], "Op"
.annotate 'line', 986
    get_hll_global $P2207, ["PAST"], "Op"
.annotate 'line', 988
    get_hll_global $P2208, ["PAST"], "Var"
    $P2209 = $P2208."new"("type_obj" :named("name"), "register" :named("scope"))
    $P2210 = $P2207."new"($P2209, "get_how PP" :named("pirop"))
.annotate 'line', 990
    get_hll_global $P2211, ["PAST"], "Var"
    $P2212 = $P2211."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 991
    get_hll_global $P2213, ["PAST"], "Val"
    new $P2214, "String"
    assign $P2214, "!PREFIX__"
    find_lex $P2215, "$name"
    concat $P2216, $P2214, $P2215
    $P2217 = $P2213."new"($P2216 :named("value"))
.annotate 'line', 992
    get_hll_global $P2218, ["PAST"], "Var"
    new $P2219, "String"
    assign $P2219, "!PREFIX__"
    find_lex $P2220, "$name"
    concat $P2221, $P2219, $P2220
    $P2222 = $P2218."new"($P2221 :named("name"), "package" :named("scope"))
    $P2223 = $P2206."new"($P2210, $P2212, $P2217, $P2222, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 984
    $P2205."push"($P2223)
  if_2187_end:
.annotate 'line', 996
    find_lex $P2224, "$regex"
    find_lex $P2225, "$past"
    unless_null $P2225, vivify_708
    $P2225 = root_new ['parrot';'Hash']
    store_lex "$past", $P2225
  vivify_708:
    set $P2225["sink"], $P2224
.annotate 'line', 997
    find_lex $P2226, "@MODIFIERS"
    $P2227 = $P2226."shift"()
.annotate 'line', 963
    .return ($P2227)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2141"  :anon :subid("112_1298325483.2958") :outer("110_1298325483.2958")
.annotate 'line', 951
    $P2143 = root_new ['parrot';'Hash']
    .lex "%h", $P2143
.annotate 'line', 950
    find_lex $P2144, "%h"
.annotate 'line', 952
    find_lex $P2146, "$/"
    unless_null $P2146, vivify_709
    $P2146 = root_new ['parrot';'Hash']
  vivify_709:
    set $P2147, $P2146["sym"]
    unless_null $P2147, vivify_710
    new $P2147, "Undef"
  vivify_710:
    set $S2148, $P2147
    iseq $I2149, $S2148, "token"
    unless $I2149, if_2145_end
    new $P2150, "Integer"
    assign $P2150, 1
    find_lex $P2151, "%h"
    unless_null $P2151, vivify_711
    $P2151 = root_new ['parrot';'Hash']
    store_lex "%h", $P2151
  vivify_711:
    set $P2151["r"], $P2150
  if_2145_end:
.annotate 'line', 953
    find_lex $P2153, "$/"
    unless_null $P2153, vivify_712
    $P2153 = root_new ['parrot';'Hash']
  vivify_712:
    set $P2154, $P2153["sym"]
    unless_null $P2154, vivify_713
    new $P2154, "Undef"
  vivify_713:
    set $S2155, $P2154
    iseq $I2156, $S2155, "rule"
    unless $I2156, if_2152_end
    new $P2157, "Integer"
    assign $P2157, 1
    find_lex $P2158, "%h"
    unless_null $P2158, vivify_714
    $P2158 = root_new ['parrot';'Hash']
    store_lex "%h", $P2158
  vivify_714:
    set $P2158["r"], $P2157
    new $P2159, "Integer"
    assign $P2159, 1
    find_lex $P2160, "%h"
    unless_null $P2160, vivify_715
    $P2160 = root_new ['parrot';'Hash']
    store_lex "%h", $P2160
  vivify_715:
    set $P2160["s"], $P2159
  if_2152_end:
.annotate 'line', 954
    find_lex $P2161, "@MODIFIERS"
    find_lex $P2162, "%h"
    $P2161."unshift"($P2162)
.annotate 'line', 955

            $P0 = find_lex '$name'
            set_hll_global ['Regex';'P6Regex';'Actions'], '$REGEXNAME', $P0
        
.annotate 'line', 959
    get_global $P2163, "@BLOCK"
    unless_null $P2163, vivify_716
    $P2163 = root_new ['parrot';'ResizablePMCArray']
  vivify_716:
    set $P2164, $P2163[0]
    unless_null $P2164, vivify_717
    new $P2164, "Undef"
  vivify_717:
    $P2164."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 960
    get_global $P2165, "@BLOCK"
    unless_null $P2165, vivify_718
    $P2165 = root_new ['parrot';'ResizablePMCArray']
  vivify_718:
    set $P2166, $P2165[0]
    unless_null $P2166, vivify_719
    new $P2166, "Undef"
  vivify_719:
    $P2166."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 961
    new $P2167, "Exception"
    set $P2167['type'], .CONTROL_RETURN
    new $P2168, "Integer"
    assign $P2168, 0
    setattribute $P2167, 'payload', $P2168
    throw $P2167
.annotate 'line', 950
    .return ()
.end


.namespace ["NQP";"Actions"]
.sub "_block2114"  :anon :subid("111_1298325483.2958") :outer("110_1298325483.2958")
    .param pmc param_2116
.annotate 'line', 937
    .lex "$_", param_2116
.annotate 'line', 938
    find_dynamic_lex $P2117, "$*PACKAGE-SETUP"
    unless_null $P2117, vivify_721
    get_hll_global $P2117, "$PACKAGE-SETUP"
    unless_null $P2117, vivify_722
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_722:
  vivify_721:
    get_hll_global $P2118, ["PAST"], "Op"
.annotate 'line', 940
    get_hll_global $P2119, ["PAST"], "Op"
.annotate 'line', 942
    get_hll_global $P2120, ["PAST"], "Var"
    $P2121 = $P2120."new"("type_obj" :named("name"), "register" :named("scope"))
    $P2122 = $P2119."new"($P2121, "get_how PP" :named("pirop"))
.annotate 'line', 944
    get_hll_global $P2123, ["PAST"], "Var"
    $P2124 = $P2123."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 945
    get_hll_global $P2125, ["PAST"], "Val"
    find_lex $P2126, "$_"
    $P2127 = $P2126."name"()
    $P2128 = $P2125."new"($P2127 :named("value"))
.annotate 'line', 946
    get_hll_global $P2129, ["PAST"], "Val"
    find_lex $P2130, "$_"
    $P2131 = $P2129."new"($P2130 :named("value"))
    $P2132 = $P2118."new"($P2122, $P2124, $P2128, $P2131, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 938
    $P2133 = $P2117."push"($P2132)
.annotate 'line', 937
    .return ($P2133)
.end


.namespace ["NQP";"Actions"]
.sub "dotty"  :subid("114_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_2233
    .param pmc param_2234
.annotate 'line', 1003
    .lex "self", param_2233
    .lex "$/", param_2234
.annotate 'line', 1004
    new $P2235, "Undef"
    .lex "$past", $P2235
    find_lex $P2238, "$/"
    unless_null $P2238, vivify_723
    $P2238 = root_new ['parrot';'Hash']
  vivify_723:
    set $P2239, $P2238["args"]
    unless_null $P2239, vivify_724
    new $P2239, "Undef"
  vivify_724:
    if $P2239, if_2237
    get_hll_global $P2244, ["PAST"], "Op"
    find_lex $P2245, "$/"
    $P2246 = $P2244."new"($P2245 :named("node"))
    set $P2236, $P2246
    goto if_2237_end
  if_2237:
    find_lex $P2240, "$/"
    unless_null $P2240, vivify_725
    $P2240 = root_new ['parrot';'Hash']
  vivify_725:
    set $P2241, $P2240["args"]
    unless_null $P2241, vivify_726
    $P2241 = root_new ['parrot';'ResizablePMCArray']
  vivify_726:
    set $P2242, $P2241[0]
    unless_null $P2242, vivify_727
    new $P2242, "Undef"
  vivify_727:
    $P2243 = $P2242."ast"()
    set $P2236, $P2243
  if_2237_end:
    store_lex "$past", $P2236
.annotate 'line', 1005
    find_lex $P2248, "$/"
    unless_null $P2248, vivify_728
    $P2248 = root_new ['parrot';'Hash']
  vivify_728:
    set $P2249, $P2248["quote"]
    unless_null $P2249, vivify_729
    new $P2249, "Undef"
  vivify_729:
    if $P2249, if_2247
.annotate 'line', 1009
    find_lex $P2256, "$/"
    unless_null $P2256, vivify_730
    $P2256 = root_new ['parrot';'Hash']
  vivify_730:
    set $P2257, $P2256["longname"]
    unless_null $P2257, vivify_731
    new $P2257, "Undef"
  vivify_731:
    set $S2258, $P2257
    iseq $I2259, $S2258, "HOW"
    if $I2259, if_2255
.annotate 'line', 1013
    find_lex $P2263, "$/"
    unless_null $P2263, vivify_732
    $P2263 = root_new ['parrot';'Hash']
  vivify_732:
    set $P2264, $P2263["longname"]
    unless_null $P2264, vivify_733
    new $P2264, "Undef"
  vivify_733:
    set $S2265, $P2264
    iseq $I2266, $S2265, "WHAT"
    if $I2266, if_2262
.annotate 'line', 1017
    find_lex $P2268, "$past"
    find_lex $P2269, "$/"
    unless_null $P2269, vivify_734
    $P2269 = root_new ['parrot';'Hash']
  vivify_734:
    set $P2270, $P2269["longname"]
    unless_null $P2270, vivify_735
    new $P2270, "Undef"
  vivify_735:
    set $S2271, $P2270
    $P2268."name"($S2271)
.annotate 'line', 1018
    find_lex $P2272, "$past"
    $P2272."pasttype"("callmethod")
.annotate 'line', 1016
    goto if_2262_end
  if_2262:
.annotate 'line', 1014
    find_lex $P2267, "$past"
    $P2267."pirop"("get_what PP")
  if_2262_end:
.annotate 'line', 1013
    goto if_2255_end
  if_2255:
.annotate 'line', 1010
    find_lex $P2260, "$past"
    $P2260."pirop"("get_how PP")
.annotate 'line', 1011
    find_lex $P2261, "$past"
    $P2261."pasttype"("pirop")
  if_2255_end:
.annotate 'line', 1009
    goto if_2247_end
  if_2247:
.annotate 'line', 1006
    find_lex $P2250, "$past"
    find_lex $P2251, "$/"
    unless_null $P2251, vivify_736
    $P2251 = root_new ['parrot';'Hash']
  vivify_736:
    set $P2252, $P2251["quote"]
    unless_null $P2252, vivify_737
    new $P2252, "Undef"
  vivify_737:
    $P2253 = $P2252."ast"()
    $P2250."name"($P2253)
.annotate 'line', 1007
    find_lex $P2254, "$past"
    $P2254."pasttype"("callmethod")
  if_2247_end:
.annotate 'line', 1020
    find_lex $P2273, "$/"
    find_lex $P2274, "$past"
    $P2275 = $P2273."!make"($P2274)
.annotate 'line', 1003
    .return ($P2275)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<self>"  :subid("115_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_2277
    .param pmc param_2278
.annotate 'line', 1025
    .lex "self", param_2277
    .lex "$/", param_2278
.annotate 'line', 1026
    find_lex $P2279, "$/"
    get_hll_global $P2280, ["PAST"], "Var"
    $P2281 = $P2280."new"("self" :named("name"))
    $P2282 = $P2279."!make"($P2281)
.annotate 'line', 1025
    .return ($P2282)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<identifier>"  :subid("116_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_2284
    .param pmc param_2285
.annotate 'line', 1029
    .lex "self", param_2284
    .lex "$/", param_2285
.annotate 'line', 1030
    new $P2286, "Undef"
    .lex "$past", $P2286
    find_lex $P2287, "$/"
    unless_null $P2287, vivify_738
    $P2287 = root_new ['parrot';'Hash']
  vivify_738:
    set $P2288, $P2287["args"]
    unless_null $P2288, vivify_739
    new $P2288, "Undef"
  vivify_739:
    $P2289 = $P2288."ast"()
    store_lex "$past", $P2289
.annotate 'line', 1031
    find_lex $P2290, "$past"
    find_lex $P2291, "$/"
    unless_null $P2291, vivify_740
    $P2291 = root_new ['parrot';'Hash']
  vivify_740:
    set $P2292, $P2291["deflongname"]
    unless_null $P2292, vivify_741
    new $P2292, "Undef"
  vivify_741:
    set $S2293, $P2292
    $P2290."name"($S2293)
.annotate 'line', 1032
    find_lex $P2294, "$/"
    find_lex $P2295, "$past"
    $P2296 = $P2294."!make"($P2295)
.annotate 'line', 1029
    .return ($P2296)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<name>"  :subid("117_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_2298
    .param pmc param_2299
.annotate 'line', 1035
    .lex "self", param_2298
    .lex "$/", param_2299
.annotate 'line', 1036
    $P2300 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P2300
.annotate 'line', 1037
    new $P2301, "Undef"
    .lex "$name", $P2301
.annotate 'line', 1039
    new $P2302, "Undef"
    .lex "$var", $P2302
.annotate 'line', 1041
    new $P2303, "Undef"
    .lex "$past", $P2303
.annotate 'line', 1036
    find_lex $P2304, "$/"
    unless_null $P2304, vivify_742
    $P2304 = root_new ['parrot';'Hash']
  vivify_742:
    set $P2305, $P2304["name"]
    unless_null $P2305, vivify_743
    $P2305 = root_new ['parrot';'Hash']
  vivify_743:
    set $P2306, $P2305["identifier"]
    unless_null $P2306, vivify_744
    new $P2306, "Undef"
  vivify_744:
    clone $P2307, $P2306
    store_lex "@ns", $P2307
.annotate 'line', 1037
    find_lex $P2308, "@ns"
    $P2309 = $P2308."pop"()
    store_lex "$name", $P2309
.annotate 'line', 1038
    find_lex $P2313, "@ns"
    if $P2313, if_2312
    set $P2311, $P2313
    goto if_2312_end
  if_2312:
    find_lex $P2314, "@ns"
    unless_null $P2314, vivify_745
    $P2314 = root_new ['parrot';'ResizablePMCArray']
  vivify_745:
    set $P2315, $P2314[0]
    unless_null $P2315, vivify_746
    new $P2315, "Undef"
  vivify_746:
    set $S2316, $P2315
    iseq $I2317, $S2316, "GLOBAL"
    new $P2311, 'Integer'
    set $P2311, $I2317
  if_2312_end:
    unless $P2311, if_2310_end
    find_lex $P2318, "@ns"
    $P2318."shift"()
  if_2310_end:
.annotate 'line', 1040
    get_hll_global $P2319, ["PAST"], "Var"
    find_lex $P2320, "$name"
    set $S2321, $P2320
    find_lex $P2322, "@ns"
    $P2323 = $P2319."new"($S2321 :named("name"), $P2322 :named("namespace"), "package" :named("scope"))
    store_lex "$var", $P2323
.annotate 'line', 1041
    find_lex $P2324, "$var"
    store_lex "$past", $P2324
.annotate 'line', 1042
    find_lex $P2326, "$/"
    unless_null $P2326, vivify_747
    $P2326 = root_new ['parrot';'Hash']
  vivify_747:
    set $P2327, $P2326["args"]
    unless_null $P2327, vivify_748
    new $P2327, "Undef"
  vivify_748:
    unless $P2327, if_2325_end
.annotate 'line', 1043
    find_lex $P2328, "$/"
    unless_null $P2328, vivify_749
    $P2328 = root_new ['parrot';'Hash']
  vivify_749:
    set $P2329, $P2328["args"]
    unless_null $P2329, vivify_750
    $P2329 = root_new ['parrot';'ResizablePMCArray']
  vivify_750:
    set $P2330, $P2329[0]
    unless_null $P2330, vivify_751
    new $P2330, "Undef"
  vivify_751:
    $P2331 = $P2330."ast"()
    store_lex "$past", $P2331
.annotate 'line', 1044
    find_lex $P2332, "$past"
    find_lex $P2333, "$var"
    $P2332."unshift"($P2333)
  if_2325_end:
.annotate 'line', 1046
    find_lex $P2334, "$/"
    find_lex $P2335, "$past"
    $P2336 = $P2334."!make"($P2335)
.annotate 'line', 1035
    .return ($P2336)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<pir::op>"  :subid("118_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_2338
    .param pmc param_2339
.annotate 'line', 1049
    .lex "self", param_2338
    .lex "$/", param_2339
.annotate 'line', 1050
    new $P2340, "Undef"
    .lex "$past", $P2340
.annotate 'line', 1051
    new $P2341, "Undef"
    .lex "$pirop", $P2341
.annotate 'line', 1050
    find_lex $P2344, "$/"
    unless_null $P2344, vivify_752
    $P2344 = root_new ['parrot';'Hash']
  vivify_752:
    set $P2345, $P2344["args"]
    unless_null $P2345, vivify_753
    new $P2345, "Undef"
  vivify_753:
    if $P2345, if_2343
    get_hll_global $P2350, ["PAST"], "Op"
    find_lex $P2351, "$/"
    $P2352 = $P2350."new"($P2351 :named("node"))
    set $P2342, $P2352
    goto if_2343_end
  if_2343:
    find_lex $P2346, "$/"
    unless_null $P2346, vivify_754
    $P2346 = root_new ['parrot';'Hash']
  vivify_754:
    set $P2347, $P2346["args"]
    unless_null $P2347, vivify_755
    $P2347 = root_new ['parrot';'ResizablePMCArray']
  vivify_755:
    set $P2348, $P2347[0]
    unless_null $P2348, vivify_756
    new $P2348, "Undef"
  vivify_756:
    $P2349 = $P2348."ast"()
    set $P2342, $P2349
  if_2343_end:
    store_lex "$past", $P2342
.annotate 'line', 1051
    find_lex $P2353, "$/"
    unless_null $P2353, vivify_757
    $P2353 = root_new ['parrot';'Hash']
  vivify_757:
    set $P2354, $P2353["op"]
    unless_null $P2354, vivify_758
    new $P2354, "Undef"
  vivify_758:
    set $S2355, $P2354
    new $P2356, 'String'
    set $P2356, $S2355
    store_lex "$pirop", $P2356
.annotate 'line', 1052

        $P0 = find_lex '$pirop'
        $S0 = $P0
        $P0 = split '__', $S0
        $S0 = join ' ', $P0
        $P2357 = box $S0
    
    store_lex "$pirop", $P2357
.annotate 'line', 1059
    find_lex $P2358, "$past"
    find_lex $P2359, "$pirop"
    $P2358."pirop"($P2359)
.annotate 'line', 1060
    find_lex $P2360, "$past"
    $P2360."pasttype"("pirop")
.annotate 'line', 1061
    find_lex $P2361, "$/"
    find_lex $P2362, "$past"
    $P2363 = $P2361."!make"($P2362)
.annotate 'line', 1049
    .return ($P2363)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<onlystar>"  :subid("119_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_2365
    .param pmc param_2366
.annotate 'line', 1064
    .lex "self", param_2365
    .lex "$/", param_2366
.annotate 'line', 1065
    find_lex $P2367, "$/"
    get_hll_global $P2368, ["PAST"], "Op"
    $P2369 = $P2368."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P2370 = $P2367."!make"($P2369)
.annotate 'line', 1064
    .return ($P2370)
.end


.namespace ["NQP";"Actions"]
.sub "args"  :subid("120_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_2372
    .param pmc param_2373
.annotate 'line', 1070
    .lex "self", param_2372
    .lex "$/", param_2373
    find_lex $P2374, "$/"
    find_lex $P2375, "$/"
    unless_null $P2375, vivify_759
    $P2375 = root_new ['parrot';'Hash']
  vivify_759:
    set $P2376, $P2375["arglist"]
    unless_null $P2376, vivify_760
    new $P2376, "Undef"
  vivify_760:
    $P2377 = $P2376."ast"()
    $P2378 = $P2374."!make"($P2377)
    .return ($P2378)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "arglist"  :subid("121_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_2380
    .param pmc param_2381
.annotate 'line', 1072
    .const 'Sub' $P2392 = "122_1298325483.2958" 
    capture_lex $P2392
    .lex "self", param_2380
    .lex "$/", param_2381
.annotate 'line', 1073
    new $P2382, "Undef"
    .lex "$past", $P2382
.annotate 'line', 1081
    new $P2383, "Undef"
    .lex "$i", $P2383
.annotate 'line', 1082
    new $P2384, "Undef"
    .lex "$n", $P2384
.annotate 'line', 1073
    get_hll_global $P2385, ["PAST"], "Op"
    find_lex $P2386, "$/"
    $P2387 = $P2385."new"("call" :named("pasttype"), $P2386 :named("node"))
    store_lex "$past", $P2387
.annotate 'line', 1074
    find_lex $P2389, "$/"
    unless_null $P2389, vivify_761
    $P2389 = root_new ['parrot';'Hash']
  vivify_761:
    set $P2390, $P2389["EXPR"]
    unless_null $P2390, vivify_762
    new $P2390, "Undef"
  vivify_762:
    unless $P2390, if_2388_end
    .const 'Sub' $P2392 = "122_1298325483.2958" 
    capture_lex $P2392
    $P2392()
  if_2388_end:
.annotate 'line', 1081
    new $P2424, "Integer"
    assign $P2424, 0
    store_lex "$i", $P2424
.annotate 'line', 1082
    find_lex $P2425, "$past"
    $P2426 = $P2425."list"()
    set $N2427, $P2426
    new $P2428, 'Float'
    set $P2428, $N2427
    store_lex "$n", $P2428
.annotate 'line', 1083
    new $P2476, 'ExceptionHandler'
    set_label $P2476, loop2475_handler
    $P2476."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2476
  loop2475_test:
    find_lex $P2429, "$i"
    set $N2430, $P2429
    find_lex $P2431, "$n"
    set $N2432, $P2431
    islt $I2433, $N2430, $N2432
    unless $I2433, loop2475_done
  loop2475_redo:
.annotate 'line', 1084
    find_lex $P2435, "$i"
    set $I2436, $P2435
    find_lex $P2437, "$past"
    unless_null $P2437, vivify_766
    $P2437 = root_new ['parrot';'ResizablePMCArray']
  vivify_766:
    set $P2438, $P2437[$I2436]
    unless_null $P2438, vivify_767
    new $P2438, "Undef"
  vivify_767:
    $S2439 = $P2438."name"()
    iseq $I2440, $S2439, "&prefix:<|>"
    unless $I2440, if_2434_end
.annotate 'line', 1085
    find_lex $P2441, "$i"
    set $I2442, $P2441
    find_lex $P2443, "$past"
    unless_null $P2443, vivify_768
    $P2443 = root_new ['parrot';'ResizablePMCArray']
  vivify_768:
    set $P2444, $P2443[$I2442]
    unless_null $P2444, vivify_769
    $P2444 = root_new ['parrot';'ResizablePMCArray']
  vivify_769:
    set $P2445, $P2444[0]
    unless_null $P2445, vivify_770
    new $P2445, "Undef"
  vivify_770:
    find_lex $P2446, "$i"
    set $I2447, $P2446
    find_lex $P2448, "$past"
    unless_null $P2448, vivify_771
    $P2448 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$past", $P2448
  vivify_771:
    set $P2448[$I2447], $P2445
.annotate 'line', 1086
    find_lex $P2449, "$i"
    set $I2450, $P2449
    find_lex $P2451, "$past"
    unless_null $P2451, vivify_772
    $P2451 = root_new ['parrot';'ResizablePMCArray']
  vivify_772:
    set $P2452, $P2451[$I2450]
    unless_null $P2452, vivify_773
    new $P2452, "Undef"
  vivify_773:
    $P2452."flat"(1)
.annotate 'line', 1087
    find_lex $P2456, "$i"
    set $I2457, $P2456
    find_lex $P2458, "$past"
    unless_null $P2458, vivify_774
    $P2458 = root_new ['parrot';'ResizablePMCArray']
  vivify_774:
    set $P2459, $P2458[$I2457]
    unless_null $P2459, vivify_775
    new $P2459, "Undef"
  vivify_775:
    get_hll_global $P2460, ["PAST"], "Val"
    $P2461 = $P2459."isa"($P2460)
    if $P2461, if_2455
    set $P2454, $P2461
    goto if_2455_end
  if_2455:
.annotate 'line', 1088
    find_lex $P2462, "$i"
    set $I2463, $P2462
    find_lex $P2464, "$past"
    unless_null $P2464, vivify_776
    $P2464 = root_new ['parrot';'ResizablePMCArray']
  vivify_776:
    set $P2465, $P2464[$I2463]
    unless_null $P2465, vivify_777
    new $P2465, "Undef"
  vivify_777:
    $S2466 = $P2465."name"()
    substr $S2467, $S2466, 0, 1
    iseq $I2468, $S2467, "%"
    new $P2454, 'Integer'
    set $P2454, $I2468
  if_2455_end:
    unless $P2454, if_2453_end
.annotate 'line', 1089
    find_lex $P2469, "$i"
    set $I2470, $P2469
    find_lex $P2471, "$past"
    unless_null $P2471, vivify_778
    $P2471 = root_new ['parrot';'ResizablePMCArray']
  vivify_778:
    set $P2472, $P2471[$I2470]
    unless_null $P2472, vivify_779
    new $P2472, "Undef"
  vivify_779:
    $P2472."named"(1)
  if_2453_end:
  if_2434_end:
.annotate 'line', 1084
    find_lex $P2473, "$i"
    clone $P2474, $P2473
    inc $P2473
  loop2475_next:
.annotate 'line', 1083
    goto loop2475_test
  loop2475_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2477, exception, 'type'
    eq $P2477, .CONTROL_LOOP_NEXT, loop2475_next
    eq $P2477, .CONTROL_LOOP_REDO, loop2475_redo
  loop2475_done:
    pop_eh 
.annotate 'line', 1094
    find_lex $P2478, "$/"
    find_lex $P2479, "$past"
    $P2480 = $P2478."!make"($P2479)
.annotate 'line', 1072
    .return ($P2480)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2391"  :anon :subid("122_1298325483.2958") :outer("121_1298325483.2958")
.annotate 'line', 1074
    .const 'Sub' $P2413 = "123_1298325483.2958" 
    capture_lex $P2413
.annotate 'line', 1075
    new $P2393, "Undef"
    .lex "$expr", $P2393
    find_lex $P2394, "$/"
    unless_null $P2394, vivify_763
    $P2394 = root_new ['parrot';'Hash']
  vivify_763:
    set $P2395, $P2394["EXPR"]
    unless_null $P2395, vivify_764
    new $P2395, "Undef"
  vivify_764:
    $P2396 = $P2395."ast"()
    store_lex "$expr", $P2396
.annotate 'line', 1076
    find_lex $P2401, "$expr"
    $S2402 = $P2401."name"()
    iseq $I2403, $S2402, "&infix:<,>"
    if $I2403, if_2400
    new $P2399, 'Integer'
    set $P2399, $I2403
    goto if_2400_end
  if_2400:
    find_lex $P2404, "$expr"
    $P2405 = $P2404."named"()
    isfalse $I2406, $P2405
    new $P2399, 'Integer'
    set $P2399, $I2406
  if_2400_end:
    if $P2399, if_2398
.annotate 'line', 1079
    find_lex $P2421, "$past"
    find_lex $P2422, "$expr"
    $P2423 = $P2421."push"($P2422)
    set $P2397, $P2423
.annotate 'line', 1076
    goto if_2398_end
  if_2398:
.annotate 'line', 1077
    find_lex $P2408, "$expr"
    $P2409 = $P2408."list"()
    defined $I2410, $P2409
    unless $I2410, for_undef_765
    iter $P2407, $P2409
    new $P2419, 'ExceptionHandler'
    set_label $P2419, loop2418_handler
    $P2419."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2419
  loop2418_test:
    unless $P2407, loop2418_done
    shift $P2411, $P2407
  loop2418_redo:
    .const 'Sub' $P2413 = "123_1298325483.2958" 
    capture_lex $P2413
    $P2413($P2411)
  loop2418_next:
    goto loop2418_test
  loop2418_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2420, exception, 'type'
    eq $P2420, .CONTROL_LOOP_NEXT, loop2418_next
    eq $P2420, .CONTROL_LOOP_REDO, loop2418_redo
  loop2418_done:
    pop_eh 
  for_undef_765:
.annotate 'line', 1076
    set $P2397, $P2407
  if_2398_end:
.annotate 'line', 1074
    .return ($P2397)
.end


.namespace ["NQP";"Actions"]
.sub "_block2412"  :anon :subid("123_1298325483.2958") :outer("122_1298325483.2958")
    .param pmc param_2414
.annotate 'line', 1077
    .lex "$_", param_2414
    find_lex $P2415, "$past"
    find_lex $P2416, "$_"
    $P2417 = $P2415."push"($P2416)
    .return ($P2417)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<multi_declarator>"  :subid("124_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_2482
    .param pmc param_2483
.annotate 'line', 1097
    .lex "self", param_2482
    .lex "$/", param_2483
    find_lex $P2484, "$/"
    find_lex $P2485, "$/"
    unless_null $P2485, vivify_780
    $P2485 = root_new ['parrot';'Hash']
  vivify_780:
    set $P2486, $P2485["multi_declarator"]
    unless_null $P2486, vivify_781
    new $P2486, "Undef"
  vivify_781:
    $P2487 = $P2486."ast"()
    $P2488 = $P2484."!make"($P2487)
    .return ($P2488)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<value>"  :subid("125_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_2490
    .param pmc param_2491
.annotate 'line', 1099
    .lex "self", param_2490
    .lex "$/", param_2491
    find_lex $P2492, "$/"
    find_lex $P2493, "$/"
    unless_null $P2493, vivify_782
    $P2493 = root_new ['parrot';'Hash']
  vivify_782:
    set $P2494, $P2493["value"]
    unless_null $P2494, vivify_783
    new $P2494, "Undef"
  vivify_783:
    $P2495 = $P2494."ast"()
    $P2496 = $P2492."!make"($P2495)
    .return ($P2496)
.end


.namespace ["NQP";"Actions"]
.sub "circumfix:sym<( )>"  :subid("126_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_2498
    .param pmc param_2499
.annotate 'line', 1101
    .lex "self", param_2498
    .lex "$/", param_2499
.annotate 'line', 1102
    find_lex $P2500, "$/"
.annotate 'line', 1103
    find_lex $P2503, "$/"
    unless_null $P2503, vivify_784
    $P2503 = root_new ['parrot';'Hash']
  vivify_784:
    set $P2504, $P2503["EXPR"]
    unless_null $P2504, vivify_785
    new $P2504, "Undef"
  vivify_785:
    if $P2504, if_2502
.annotate 'line', 1104
    get_hll_global $P2509, ["PAST"], "Op"
    find_lex $P2510, "$/"
    $P2511 = $P2509."new"("list" :named("pasttype"), $P2510 :named("node"))
    set $P2501, $P2511
.annotate 'line', 1103
    goto if_2502_end
  if_2502:
    find_lex $P2505, "$/"
    unless_null $P2505, vivify_786
    $P2505 = root_new ['parrot';'Hash']
  vivify_786:
    set $P2506, $P2505["EXPR"]
    unless_null $P2506, vivify_787
    $P2506 = root_new ['parrot';'ResizablePMCArray']
  vivify_787:
    set $P2507, $P2506[0]
    unless_null $P2507, vivify_788
    new $P2507, "Undef"
  vivify_788:
    $P2508 = $P2507."ast"()
    set $P2501, $P2508
  if_2502_end:
    $P2512 = $P2500."!make"($P2501)
.annotate 'line', 1101
    .return ($P2512)
.end


.namespace ["NQP";"Actions"]
.sub "circumfix:sym<[ ]>"  :subid("127_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_2514
    .param pmc param_2515
.annotate 'line', 1107
    .lex "self", param_2514
    .lex "$/", param_2515
.annotate 'line', 1108
    new $P2516, "Undef"
    .lex "$past", $P2516
.annotate 'line', 1107
    find_lex $P2517, "$past"
.annotate 'line', 1109
    find_lex $P2519, "$/"
    unless_null $P2519, vivify_789
    $P2519 = root_new ['parrot';'Hash']
  vivify_789:
    set $P2520, $P2519["EXPR"]
    unless_null $P2520, vivify_790
    new $P2520, "Undef"
  vivify_790:
    if $P2520, if_2518
.annotate 'line', 1116
    get_hll_global $P2532, ["PAST"], "Op"
    $P2533 = $P2532."new"("list" :named("pasttype"))
    store_lex "$past", $P2533
.annotate 'line', 1115
    goto if_2518_end
  if_2518:
.annotate 'line', 1110
    find_lex $P2521, "$/"
    unless_null $P2521, vivify_791
    $P2521 = root_new ['parrot';'Hash']
  vivify_791:
    set $P2522, $P2521["EXPR"]
    unless_null $P2522, vivify_792
    $P2522 = root_new ['parrot';'ResizablePMCArray']
  vivify_792:
    set $P2523, $P2522[0]
    unless_null $P2523, vivify_793
    new $P2523, "Undef"
  vivify_793:
    $P2524 = $P2523."ast"()
    store_lex "$past", $P2524
.annotate 'line', 1111
    find_lex $P2526, "$past"
    $S2527 = $P2526."name"()
    isne $I2528, $S2527, "&infix:<,>"
    unless $I2528, if_2525_end
.annotate 'line', 1112
    get_hll_global $P2529, ["PAST"], "Op"
    find_lex $P2530, "$past"
    $P2531 = $P2529."new"($P2530, "list" :named("pasttype"))
    store_lex "$past", $P2531
  if_2525_end:
  if_2518_end:
.annotate 'line', 1118
    find_lex $P2534, "$past"
    $P2534."name"("&circumfix:<[ ]>")
.annotate 'line', 1119
    find_lex $P2535, "$/"
    find_lex $P2536, "$past"
    $P2537 = $P2535."!make"($P2536)
.annotate 'line', 1107
    .return ($P2537)
.end


.namespace ["NQP";"Actions"]
.sub "circumfix:sym<ang>"  :subid("128_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_2539
    .param pmc param_2540
.annotate 'line', 1122
    .lex "self", param_2539
    .lex "$/", param_2540
    find_lex $P2541, "$/"
    find_lex $P2542, "$/"
    unless_null $P2542, vivify_794
    $P2542 = root_new ['parrot';'Hash']
  vivify_794:
    set $P2543, $P2542["quote_EXPR"]
    unless_null $P2543, vivify_795
    new $P2543, "Undef"
  vivify_795:
    $P2544 = $P2543."ast"()
    $P2545 = $P2541."!make"($P2544)
    .return ($P2545)
.end


.namespace ["NQP";"Actions"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("129_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_2547
    .param pmc param_2548
.annotate 'line', 1123
    .lex "self", param_2547
    .lex "$/", param_2548
    find_lex $P2549, "$/"
    find_lex $P2550, "$/"
    unless_null $P2550, vivify_796
    $P2550 = root_new ['parrot';'Hash']
  vivify_796:
    set $P2551, $P2550["quote_EXPR"]
    unless_null $P2551, vivify_797
    new $P2551, "Undef"
  vivify_797:
    $P2552 = $P2551."ast"()
    $P2553 = $P2549."!make"($P2552)
    .return ($P2553)
.end


.namespace ["NQP";"Actions"]
.sub "circumfix:sym<{ }>"  :subid("130_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_2555
    .param pmc param_2556
.annotate 'line', 1125
    .lex "self", param_2555
    .lex "$/", param_2556
.annotate 'line', 1126
    new $P2557, "Undef"
    .lex "$past", $P2557
    find_lex $P2560, "$/"
    unless_null $P2560, vivify_798
    $P2560 = root_new ['parrot';'Hash']
  vivify_798:
    set $P2561, $P2560["pblock"]
    unless_null $P2561, vivify_799
    $P2561 = root_new ['parrot';'Hash']
  vivify_799:
    set $P2562, $P2561["blockoid"]
    unless_null $P2562, vivify_800
    $P2562 = root_new ['parrot';'Hash']
  vivify_800:
    set $P2563, $P2562["statementlist"]
    unless_null $P2563, vivify_801
    $P2563 = root_new ['parrot';'Hash']
  vivify_801:
    set $P2564, $P2563["statement"]
    unless_null $P2564, vivify_802
    new $P2564, "Undef"
  vivify_802:
    set $N2565, $P2564
    isgt $I2566, $N2565, 0.0
    if $I2566, if_2559
.annotate 'line', 1128
    $P2570 = "vivitype"("%")
    set $P2558, $P2570
.annotate 'line', 1126
    goto if_2559_end
  if_2559:
.annotate 'line', 1127
    find_lex $P2567, "$/"
    unless_null $P2567, vivify_803
    $P2567 = root_new ['parrot';'Hash']
  vivify_803:
    set $P2568, $P2567["pblock"]
    unless_null $P2568, vivify_804
    new $P2568, "Undef"
  vivify_804:
    $P2569 = $P2568."ast"()
    set $P2558, $P2569
  if_2559_end:
    store_lex "$past", $P2558
.annotate 'line', 1129
    new $P2571, "Integer"
    assign $P2571, 1
    find_lex $P2572, "$past"
    unless_null $P2572, vivify_805
    $P2572 = root_new ['parrot';'Hash']
    store_lex "$past", $P2572
  vivify_805:
    set $P2572["bareblock"], $P2571
.annotate 'line', 1130
    find_lex $P2573, "$/"
    find_lex $P2574, "$past"
    $P2575 = $P2573."!make"($P2574)
.annotate 'line', 1125
    .return ($P2575)
.end


.namespace ["NQP";"Actions"]
.sub "circumfix:sym<sigil>"  :subid("131_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_2577
    .param pmc param_2578
.annotate 'line', 1133
    .lex "self", param_2577
    .lex "$/", param_2578
.annotate 'line', 1134
    new $P2579, "Undef"
    .lex "$name", $P2579
    find_lex $P2582, "$/"
    unless_null $P2582, vivify_806
    $P2582 = root_new ['parrot';'Hash']
  vivify_806:
    set $P2583, $P2582["sigil"]
    unless_null $P2583, vivify_807
    new $P2583, "Undef"
  vivify_807:
    set $S2584, $P2583
    iseq $I2585, $S2584, "@"
    if $I2585, if_2581
.annotate 'line', 1135
    find_lex $P2589, "$/"
    unless_null $P2589, vivify_808
    $P2589 = root_new ['parrot';'Hash']
  vivify_808:
    set $P2590, $P2589["sigil"]
    unless_null $P2590, vivify_809
    new $P2590, "Undef"
  vivify_809:
    set $S2591, $P2590
    iseq $I2592, $S2591, "%"
    if $I2592, if_2588
    new $P2594, "String"
    assign $P2594, "item"
    set $P2587, $P2594
    goto if_2588_end
  if_2588:
    new $P2593, "String"
    assign $P2593, "hash"
    set $P2587, $P2593
  if_2588_end:
    set $P2580, $P2587
.annotate 'line', 1134
    goto if_2581_end
  if_2581:
    new $P2586, "String"
    assign $P2586, "list"
    set $P2580, $P2586
  if_2581_end:
    store_lex "$name", $P2580
.annotate 'line', 1137
    find_lex $P2595, "$/"
    get_hll_global $P2596, ["PAST"], "Op"
    find_lex $P2597, "$name"
    find_lex $P2598, "$/"
    unless_null $P2598, vivify_810
    $P2598 = root_new ['parrot';'Hash']
  vivify_810:
    set $P2599, $P2598["semilist"]
    unless_null $P2599, vivify_811
    new $P2599, "Undef"
  vivify_811:
    $P2600 = $P2599."ast"()
    $P2601 = $P2596."new"($P2600, "callmethod" :named("pasttype"), $P2597 :named("name"))
    $P2602 = $P2595."!make"($P2601)
.annotate 'line', 1133
    .return ($P2602)
.end


.namespace ["NQP";"Actions"]
.sub "semilist"  :subid("132_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_2604
    .param pmc param_2605
.annotate 'line', 1140
    .lex "self", param_2604
    .lex "$/", param_2605
    find_lex $P2606, "$/"
    find_lex $P2607, "$/"
    unless_null $P2607, vivify_812
    $P2607 = root_new ['parrot';'Hash']
  vivify_812:
    set $P2608, $P2607["statement"]
    unless_null $P2608, vivify_813
    new $P2608, "Undef"
  vivify_813:
    $P2609 = $P2608."ast"()
    $P2610 = $P2606."!make"($P2609)
    .return ($P2610)
.end


.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<[ ]>"  :subid("133_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_2612
    .param pmc param_2613
.annotate 'line', 1142
    .lex "self", param_2612
    .lex "$/", param_2613
.annotate 'line', 1143
    find_lex $P2614, "$/"
    get_hll_global $P2615, ["PAST"], "Var"
    find_lex $P2616, "$/"
    unless_null $P2616, vivify_814
    $P2616 = root_new ['parrot';'Hash']
  vivify_814:
    set $P2617, $P2616["EXPR"]
    unless_null $P2617, vivify_815
    new $P2617, "Undef"
  vivify_815:
    $P2618 = $P2617."ast"()
.annotate 'line', 1145
    $P2619 = "vivitype"("@")
    $P2620 = $P2615."new"($P2618, "keyed_int" :named("scope"), "Undef" :named("viviself"), $P2619 :named("vivibase"))
.annotate 'line', 1143
    $P2621 = $P2614."!make"($P2620)
.annotate 'line', 1142
    .return ($P2621)
.end


.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<{ }>"  :subid("134_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_2623
    .param pmc param_2624
.annotate 'line', 1148
    .lex "self", param_2623
    .lex "$/", param_2624
.annotate 'line', 1149
    find_lex $P2625, "$/"
    get_hll_global $P2626, ["PAST"], "Var"
    find_lex $P2627, "$/"
    unless_null $P2627, vivify_816
    $P2627 = root_new ['parrot';'Hash']
  vivify_816:
    set $P2628, $P2627["EXPR"]
    unless_null $P2628, vivify_817
    new $P2628, "Undef"
  vivify_817:
    $P2629 = $P2628."ast"()
.annotate 'line', 1151
    $P2630 = "vivitype"("%")
    $P2631 = $P2626."new"($P2629, "keyed" :named("scope"), "Undef" :named("viviself"), $P2630 :named("vivibase"))
.annotate 'line', 1149
    $P2632 = $P2625."!make"($P2631)
.annotate 'line', 1148
    .return ($P2632)
.end


.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<ang>"  :subid("135_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_2634
    .param pmc param_2635
.annotate 'line', 1154
    .lex "self", param_2634
    .lex "$/", param_2635
.annotate 'line', 1155
    find_lex $P2636, "$/"
    get_hll_global $P2637, ["PAST"], "Var"
    find_lex $P2638, "$/"
    unless_null $P2638, vivify_818
    $P2638 = root_new ['parrot';'Hash']
  vivify_818:
    set $P2639, $P2638["quote_EXPR"]
    unless_null $P2639, vivify_819
    new $P2639, "Undef"
  vivify_819:
    $P2640 = $P2639."ast"()
.annotate 'line', 1157
    $P2641 = "vivitype"("%")
    $P2642 = $P2637."new"($P2640, "keyed" :named("scope"), "Undef" :named("viviself"), $P2641 :named("vivibase"))
.annotate 'line', 1155
    $P2643 = $P2636."!make"($P2642)
.annotate 'line', 1154
    .return ($P2643)
.end


.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<( )>"  :subid("136_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_2645
    .param pmc param_2646
.annotate 'line', 1160
    .lex "self", param_2645
    .lex "$/", param_2646
.annotate 'line', 1161
    find_lex $P2647, "$/"
    find_lex $P2648, "$/"
    unless_null $P2648, vivify_820
    $P2648 = root_new ['parrot';'Hash']
  vivify_820:
    set $P2649, $P2648["arglist"]
    unless_null $P2649, vivify_821
    new $P2649, "Undef"
  vivify_821:
    $P2650 = $P2649."ast"()
    $P2651 = $P2647."!make"($P2650)
.annotate 'line', 1160
    .return ($P2651)
.end


.namespace ["NQP";"Actions"]
.sub "value"  :subid("137_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_2653
    .param pmc param_2654
.annotate 'line', 1164
    .lex "self", param_2653
    .lex "$/", param_2654
.annotate 'line', 1165
    find_lex $P2655, "$/"
    find_lex $P2658, "$/"
    unless_null $P2658, vivify_822
    $P2658 = root_new ['parrot';'Hash']
  vivify_822:
    set $P2659, $P2658["quote"]
    unless_null $P2659, vivify_823
    new $P2659, "Undef"
  vivify_823:
    if $P2659, if_2657
    find_lex $P2663, "$/"
    unless_null $P2663, vivify_824
    $P2663 = root_new ['parrot';'Hash']
  vivify_824:
    set $P2664, $P2663["number"]
    unless_null $P2664, vivify_825
    new $P2664, "Undef"
  vivify_825:
    $P2665 = $P2664."ast"()
    set $P2656, $P2665
    goto if_2657_end
  if_2657:
    find_lex $P2660, "$/"
    unless_null $P2660, vivify_826
    $P2660 = root_new ['parrot';'Hash']
  vivify_826:
    set $P2661, $P2660["quote"]
    unless_null $P2661, vivify_827
    new $P2661, "Undef"
  vivify_827:
    $P2662 = $P2661."ast"()
    set $P2656, $P2662
  if_2657_end:
    $P2666 = $P2655."!make"($P2656)
.annotate 'line', 1164
    .return ($P2666)
.end


.namespace ["NQP";"Actions"]
.sub "number"  :subid("138_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_2668
    .param pmc param_2669
.annotate 'line', 1168
    .lex "self", param_2668
    .lex "$/", param_2669
.annotate 'line', 1169
    new $P2670, "Undef"
    .lex "$value", $P2670
    find_lex $P2673, "$/"
    unless_null $P2673, vivify_828
    $P2673 = root_new ['parrot';'Hash']
  vivify_828:
    set $P2674, $P2673["dec_number"]
    unless_null $P2674, vivify_829
    new $P2674, "Undef"
  vivify_829:
    if $P2674, if_2672
    find_lex $P2678, "$/"
    unless_null $P2678, vivify_830
    $P2678 = root_new ['parrot';'Hash']
  vivify_830:
    set $P2679, $P2678["integer"]
    unless_null $P2679, vivify_831
    new $P2679, "Undef"
  vivify_831:
    $P2680 = $P2679."ast"()
    set $P2671, $P2680
    goto if_2672_end
  if_2672:
    find_lex $P2675, "$/"
    unless_null $P2675, vivify_832
    $P2675 = root_new ['parrot';'Hash']
  vivify_832:
    set $P2676, $P2675["dec_number"]
    unless_null $P2676, vivify_833
    new $P2676, "Undef"
  vivify_833:
    $P2677 = $P2676."ast"()
    set $P2671, $P2677
  if_2672_end:
    store_lex "$value", $P2671
.annotate 'line', 1170
    find_lex $P2682, "$/"
    unless_null $P2682, vivify_834
    $P2682 = root_new ['parrot';'Hash']
  vivify_834:
    set $P2683, $P2682["sign"]
    unless_null $P2683, vivify_835
    new $P2683, "Undef"
  vivify_835:
    set $S2684, $P2683
    iseq $I2685, $S2684, "-"
    unless $I2685, if_2681_end
    find_lex $P2686, "$value"
    neg $P2687, $P2686
    store_lex "$value", $P2687
  if_2681_end:
.annotate 'line', 1171
    find_lex $P2688, "$/"
    get_hll_global $P2689, ["PAST"], "Val"
    find_lex $P2690, "$value"
    $P2691 = $P2689."new"($P2690 :named("value"))
    $P2692 = $P2688."!make"($P2691)
.annotate 'line', 1168
    .return ($P2692)
.end


.namespace ["NQP";"Actions"]
.sub "quote:sym<apos>"  :subid("139_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_2694
    .param pmc param_2695
.annotate 'line', 1174
    .lex "self", param_2694
    .lex "$/", param_2695
    find_lex $P2696, "$/"
    find_lex $P2697, "$/"
    unless_null $P2697, vivify_836
    $P2697 = root_new ['parrot';'Hash']
  vivify_836:
    set $P2698, $P2697["quote_EXPR"]
    unless_null $P2698, vivify_837
    new $P2698, "Undef"
  vivify_837:
    $P2699 = $P2698."ast"()
    $P2700 = $P2696."!make"($P2699)
    .return ($P2700)
.end


.namespace ["NQP";"Actions"]
.sub "quote:sym<dblq>"  :subid("140_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_2702
    .param pmc param_2703
.annotate 'line', 1175
    .lex "self", param_2702
    .lex "$/", param_2703
    find_lex $P2704, "$/"
    find_lex $P2705, "$/"
    unless_null $P2705, vivify_838
    $P2705 = root_new ['parrot';'Hash']
  vivify_838:
    set $P2706, $P2705["quote_EXPR"]
    unless_null $P2706, vivify_839
    new $P2706, "Undef"
  vivify_839:
    $P2707 = $P2706."ast"()
    $P2708 = $P2704."!make"($P2707)
    .return ($P2708)
.end


.namespace ["NQP";"Actions"]
.sub "quote:sym<qq>"  :subid("141_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_2710
    .param pmc param_2711
.annotate 'line', 1176
    .lex "self", param_2710
    .lex "$/", param_2711
    find_lex $P2712, "$/"
    find_lex $P2713, "$/"
    unless_null $P2713, vivify_840
    $P2713 = root_new ['parrot';'Hash']
  vivify_840:
    set $P2714, $P2713["quote_EXPR"]
    unless_null $P2714, vivify_841
    new $P2714, "Undef"
  vivify_841:
    $P2715 = $P2714."ast"()
    $P2716 = $P2712."!make"($P2715)
    .return ($P2716)
.end


.namespace ["NQP";"Actions"]
.sub "quote:sym<q>"  :subid("142_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_2718
    .param pmc param_2719
.annotate 'line', 1177
    .lex "self", param_2718
    .lex "$/", param_2719
    find_lex $P2720, "$/"
    find_lex $P2721, "$/"
    unless_null $P2721, vivify_842
    $P2721 = root_new ['parrot';'Hash']
  vivify_842:
    set $P2722, $P2721["quote_EXPR"]
    unless_null $P2722, vivify_843
    new $P2722, "Undef"
  vivify_843:
    $P2723 = $P2722."ast"()
    $P2724 = $P2720."!make"($P2723)
    .return ($P2724)
.end


.namespace ["NQP";"Actions"]
.sub "quote:sym<Q>"  :subid("143_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_2726
    .param pmc param_2727
.annotate 'line', 1178
    .lex "self", param_2726
    .lex "$/", param_2727
    find_lex $P2728, "$/"
    find_lex $P2729, "$/"
    unless_null $P2729, vivify_844
    $P2729 = root_new ['parrot';'Hash']
  vivify_844:
    set $P2730, $P2729["quote_EXPR"]
    unless_null $P2730, vivify_845
    new $P2730, "Undef"
  vivify_845:
    $P2731 = $P2730."ast"()
    $P2732 = $P2728."!make"($P2731)
    .return ($P2732)
.end


.namespace ["NQP";"Actions"]
.sub "quote:sym<Q:PIR>"  :subid("144_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_2734
    .param pmc param_2735
.annotate 'line', 1179
    .lex "self", param_2734
    .lex "$/", param_2735
.annotate 'line', 1180
    find_lex $P2736, "$/"
    get_hll_global $P2737, ["PAST"], "Op"
    find_lex $P2738, "$/"
    unless_null $P2738, vivify_846
    $P2738 = root_new ['parrot';'Hash']
  vivify_846:
    set $P2739, $P2738["quote_EXPR"]
    unless_null $P2739, vivify_847
    new $P2739, "Undef"
  vivify_847:
    $P2740 = $P2739."ast"()
    $P2741 = $P2740."value"()
    find_lex $P2742, "$/"
    $P2743 = $P2737."new"($P2741 :named("inline"), "inline" :named("pasttype"), $P2742 :named("node"))
    $P2744 = $P2736."!make"($P2743)
.annotate 'line', 1179
    .return ($P2744)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "quote:sym</ />"  :subid("145_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_2748
    .param pmc param_2749
    .param pmc param_2750 :optional
    .param int has_param_2750 :opt_flag
.annotate 'line', 1185
    new $P2747, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2747, control_2746
    push_eh $P2747
    .lex "self", param_2748
    .lex "$/", param_2749
    if has_param_2750, optparam_848
    new $P2751, "Undef"
    set param_2750, $P2751
  optparam_848:
    .lex "$key", param_2750
.annotate 'line', 1195
    new $P2752, "Undef"
    .lex "$regex", $P2752
.annotate 'line', 1197
    new $P2753, "Undef"
    .lex "$past", $P2753
.annotate 'line', 1186
    find_lex $P2755, "$key"
    set $S2756, $P2755
    iseq $I2757, $S2756, "open"
    unless $I2757, if_2754_end
.annotate 'line', 1187

            null $P0
            set_hll_global ['Regex';'P6Regex';'Actions'], '$REGEXNAME', $P0
        
.annotate 'line', 1191
    get_global $P2758, "@BLOCK"
    unless_null $P2758, vivify_849
    $P2758 = root_new ['parrot';'ResizablePMCArray']
  vivify_849:
    set $P2759, $P2758[0]
    unless_null $P2759, vivify_850
    new $P2759, "Undef"
  vivify_850:
    $P2759."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 1192
    get_global $P2760, "@BLOCK"
    unless_null $P2760, vivify_851
    $P2760 = root_new ['parrot';'ResizablePMCArray']
  vivify_851:
    set $P2761, $P2760[0]
    unless_null $P2761, vivify_852
    new $P2761, "Undef"
  vivify_852:
    $P2761."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 1193
    new $P2762, "Exception"
    set $P2762['type'], .CONTROL_RETURN
    new $P2763, "Integer"
    assign $P2763, 0
    setattribute $P2762, 'payload', $P2763
    throw $P2762
  if_2754_end:
.annotate 'line', 1196
    get_hll_global $P2764, ["Regex";"P6Regex";"Actions"], "buildsub"
    find_lex $P2765, "$/"
    unless_null $P2765, vivify_853
    $P2765 = root_new ['parrot';'Hash']
  vivify_853:
    set $P2766, $P2765["p6regex"]
    unless_null $P2766, vivify_854
    new $P2766, "Undef"
  vivify_854:
    $P2767 = $P2766."ast"()
    get_global $P2768, "@BLOCK"
    $P2769 = $P2768."shift"()
    $P2770 = $P2764($P2767, $P2769)
    store_lex "$regex", $P2770
.annotate 'line', 1198
    get_hll_global $P2771, ["PAST"], "Op"
.annotate 'line', 1200
    get_hll_global $P2772, ["PAST"], "Var"
    new $P2773, "ResizablePMCArray"
    push $P2773, "Regex"
    $P2774 = $P2772."new"("Regex" :named("name"), $P2773 :named("namespace"), "package" :named("scope"))
    find_lex $P2775, "$regex"
    $P2776 = $P2771."new"($P2774, $P2775, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 1198
    store_lex "$past", $P2776
.annotate 'line', 1204
    find_lex $P2777, "$regex"
    find_lex $P2778, "$past"
    unless_null $P2778, vivify_855
    $P2778 = root_new ['parrot';'Hash']
    store_lex "$past", $P2778
  vivify_855:
    set $P2778["sink"], $P2777
.annotate 'line', 1205
    find_lex $P2779, "$/"
    find_lex $P2780, "$past"
    $P2781 = $P2779."!make"($P2780)
.annotate 'line', 1185
    .return ($P2781)
  control_2746:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2782, exception, "payload"
    .return ($P2782)
.end


.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<$>"  :subid("146_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_2784
    .param pmc param_2785
.annotate 'line', 1208
    .lex "self", param_2784
    .lex "$/", param_2785
    find_lex $P2786, "$/"
    find_lex $P2787, "$/"
    unless_null $P2787, vivify_856
    $P2787 = root_new ['parrot';'Hash']
  vivify_856:
    set $P2788, $P2787["variable"]
    unless_null $P2788, vivify_857
    new $P2788, "Undef"
  vivify_857:
    $P2789 = $P2788."ast"()
    $P2790 = $P2786."!make"($P2789)
    .return ($P2790)
.end


.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<{ }>"  :subid("147_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_2792
    .param pmc param_2793
.annotate 'line', 1209
    .lex "self", param_2792
    .lex "$/", param_2793
.annotate 'line', 1210
    find_lex $P2794, "$/"
    get_hll_global $P2795, ["PAST"], "Op"
.annotate 'line', 1211
    find_lex $P2796, "$/"
    unless_null $P2796, vivify_858
    $P2796 = root_new ['parrot';'Hash']
  vivify_858:
    set $P2797, $P2796["block"]
    unless_null $P2797, vivify_859
    new $P2797, "Undef"
  vivify_859:
    $P2798 = $P2797."ast"()
    $P2799 = "block_immediate"($P2798)
    find_lex $P2800, "$/"
    $P2801 = $P2795."new"($P2799, "set S*" :named("pirop"), $P2800 :named("node"))
.annotate 'line', 1210
    $P2802 = $P2794."!make"($P2801)
.annotate 'line', 1209
    .return ($P2802)
.end


.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<esc>"  :subid("148_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_2804
    .param pmc param_2805
.annotate 'line', 1214
    .lex "self", param_2804
    .lex "$/", param_2805
    find_lex $P2806, "$/"
    $P2807 = $P2806."!make"("\e")
    .return ($P2807)
.end


.namespace ["NQP";"Actions"]
.sub "postfix:sym<.>"  :subid("149_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_2809
    .param pmc param_2810
.annotate 'line', 1218
    .lex "self", param_2809
    .lex "$/", param_2810
    find_lex $P2811, "$/"
    find_lex $P2812, "$/"
    unless_null $P2812, vivify_860
    $P2812 = root_new ['parrot';'Hash']
  vivify_860:
    set $P2813, $P2812["dotty"]
    unless_null $P2813, vivify_861
    new $P2813, "Undef"
  vivify_861:
    $P2814 = $P2813."ast"()
    $P2815 = $P2811."!make"($P2814)
    .return ($P2815)
.end


.namespace ["NQP";"Actions"]
.sub "postfix:sym<++>"  :subid("150_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_2817
    .param pmc param_2818
.annotate 'line', 1220
    .lex "self", param_2817
    .lex "$/", param_2818
.annotate 'line', 1221
    find_lex $P2819, "$/"
    get_hll_global $P2820, ["PAST"], "Op"
.annotate 'line', 1222
    new $P2821, "ResizablePMCArray"
    push $P2821, "    clone %r, %0"
    push $P2821, "    inc %0"
    $P2822 = $P2820."new"("postfix:<++>" :named("name"), $P2821 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 1221
    $P2823 = $P2819."!make"($P2822)
.annotate 'line', 1220
    .return ($P2823)
.end


.namespace ["NQP";"Actions"]
.sub "postfix:sym<-->"  :subid("151_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_2825
    .param pmc param_2826
.annotate 'line', 1226
    .lex "self", param_2825
    .lex "$/", param_2826
.annotate 'line', 1227
    find_lex $P2827, "$/"
    get_hll_global $P2828, ["PAST"], "Op"
.annotate 'line', 1228
    new $P2829, "ResizablePMCArray"
    push $P2829, "    clone %r, %0"
    push $P2829, "    dec %0"
    $P2830 = $P2828."new"("postfix:<-->" :named("name"), $P2829 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 1227
    $P2831 = $P2827."!make"($P2830)
.annotate 'line', 1226
    .return ($P2831)
.end


.namespace ["NQP";"Actions"]
.sub "prefix:sym<make>"  :subid("152_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_2833
    .param pmc param_2834
.annotate 'line', 1232
    .lex "self", param_2833
    .lex "$/", param_2834
.annotate 'line', 1233
    find_lex $P2835, "$/"
    get_hll_global $P2836, ["PAST"], "Op"
.annotate 'line', 1234
    get_hll_global $P2837, ["PAST"], "Var"
    $P2838 = $P2837."new"("$/" :named("name"), "contextual" :named("scope"))
    find_lex $P2839, "$/"
    $P2840 = $P2836."new"($P2838, "callmethod" :named("pasttype"), "!make" :named("name"), $P2839 :named("node"))
.annotate 'line', 1233
    $P2841 = $P2835."!make"($P2840)
.annotate 'line', 1232
    .return ($P2841)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<next>"  :subid("153_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_2844
    .param pmc param_2845
.annotate 'line', 1250
    .lex "self", param_2844
    .lex "$/", param_2845
    find_lex $P2846, "$/"
    $P2847 = "control"($P2846, "CONTROL_LOOP_NEXT")
    .return ($P2847)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<last>"  :subid("154_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_2849
    .param pmc param_2850
.annotate 'line', 1251
    .lex "self", param_2849
    .lex "$/", param_2850
    find_lex $P2851, "$/"
    $P2852 = "control"($P2851, "CONTROL_LOOP_LAST")
    .return ($P2852)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<redo>"  :subid("155_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_2854
    .param pmc param_2855
.annotate 'line', 1252
    .lex "self", param_2854
    .lex "$/", param_2855
    find_lex $P2856, "$/"
    $P2857 = "control"($P2856, "CONTROL_LOOP_REDO")
    .return ($P2857)
.end


.namespace ["NQP";"Actions"]
.sub "infix:sym<~~>"  :subid("156_1298325483.2958") :outer("11_1298325483.2958")
    .param pmc param_2859
    .param pmc param_2860
.annotate 'line', 1254
    .lex "self", param_2859
    .lex "$/", param_2860
.annotate 'line', 1255
    find_lex $P2861, "$/"
    get_hll_global $P2862, ["PAST"], "Op"
    find_lex $P2863, "$/"
    $P2864 = $P2862."new"("callmethod" :named("pasttype"), "ACCEPTS" :named("name"), $P2863 :named("node"))
    $P2865 = $P2861."!make"($P2864)
.annotate 'line', 1254
    .return ($P2865)
.end


.namespace ["NQP";"RegexActions"]
.sub "_block2866"  :subid("157_1298325483.2958") :outer("11_1298325483.2958")
.annotate 'line', 1259
    .const 'Sub' $P2966 = "165_1298325483.2958" 
    capture_lex $P2966
    .const 'Sub' $P2941 = "164_1298325483.2958" 
    capture_lex $P2941
    .const 'Sub' $P2930 = "163_1298325483.2958" 
    capture_lex $P2930
    .const 'Sub' $P2915 = "162_1298325483.2958" 
    capture_lex $P2915
    .const 'Sub' $P2904 = "161_1298325483.2958" 
    capture_lex $P2904
    .const 'Sub' $P2893 = "160_1298325483.2958" 
    capture_lex $P2893
    .const 'Sub' $P2882 = "159_1298325483.2958" 
    capture_lex $P2882
    .const 'Sub' $P2869 = "158_1298325483.2958" 
    capture_lex $P2869
    get_global $P2868, "$?CLASS"
.annotate 'line', 1293
    .const 'Sub' $P2941 = "164_1298325483.2958" 
    newclosure $P2964, $P2941
.annotate 'line', 1259
    .return ($P2964)
.end


.namespace ["NQP";"RegexActions"]
.sub "" :load :init :subid("post862") :outer("157_1298325483.2958")
.annotate 'line', 1259
    get_hll_global $P2867, ["NQP";"RegexActions"], "_block2866" 
    .local pmc block
    set block, $P2867
    .const 'Sub' $P2966 = "165_1298325483.2958" 
    capture_lex $P2966
    $P2966()
.end


.namespace ["NQP";"RegexActions"]
.sub "_block2965"  :anon :subid("165_1298325483.2958") :outer("157_1298325483.2958")
.annotate 'line', 1259
    get_hll_global $P2967, "NQPClassHOW"
    $P2968 = $P2967."new_type"("RegexActions" :named("name"))
    .local pmc type_obj
    set type_obj, $P2968
    set_hll_global ["NQP"], "RegexActions", type_obj
    set_global "$?CLASS", type_obj
    get_how $P2969, type_obj
    .const 'Sub' $P2970 = "158_1298325483.2958" 
    $P2969."add_method"(type_obj, "metachar:sym<:my>", $P2970)
    get_how $P2971, type_obj
    .const 'Sub' $P2972 = "159_1298325483.2958" 
    $P2971."add_method"(type_obj, "metachar:sym<{ }>", $P2972)
    get_how $P2973, type_obj
    .const 'Sub' $P2974 = "160_1298325483.2958" 
    $P2973."add_method"(type_obj, "metachar:sym<nqpvar>", $P2974)
    get_how $P2975, type_obj
    .const 'Sub' $P2976 = "161_1298325483.2958" 
    $P2975."add_method"(type_obj, "assertion:sym<{ }>", $P2976)
    get_how $P2977, type_obj
    .const 'Sub' $P2978 = "162_1298325483.2958" 
    $P2977."add_method"(type_obj, "assertion:sym<?{ }>", $P2978)
    get_how $P2979, type_obj
    .const 'Sub' $P2980 = "163_1298325483.2958" 
    $P2979."add_method"(type_obj, "assertion:sym<var>", $P2980)
    get_how $P2981, type_obj
    .const 'Sub' $P2982 = "164_1298325483.2958" 
    $P2981."add_method"(type_obj, "codeblock", $P2982)
    get_how $P2983, type_obj
    get_hll_global $P2984, ["Regex";"P6Regex"], "Actions"
    $P2983."add_parent"(type_obj, $P2984)
    get_how $P2985, type_obj
    $P2986 = $P2985."compose"(type_obj)
    .return ($P2986)
.end


.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<:my>"  :subid("158_1298325483.2958") :outer("157_1298325483.2958")
    .param pmc param_2870
    .param pmc param_2871
.annotate 'line', 1261
    .lex "self", param_2870
    .lex "$/", param_2871
.annotate 'line', 1262
    new $P2872, "Undef"
    .lex "$past", $P2872
    find_lex $P2873, "$/"
    unless_null $P2873, vivify_863
    $P2873 = root_new ['parrot';'Hash']
  vivify_863:
    set $P2874, $P2873["statement"]
    unless_null $P2874, vivify_864
    new $P2874, "Undef"
  vivify_864:
    $P2875 = $P2874."ast"()
    store_lex "$past", $P2875
.annotate 'line', 1263
    find_lex $P2876, "$/"
    get_hll_global $P2877, ["PAST"], "Regex"
    find_lex $P2878, "$past"
    find_lex $P2879, "$/"
    $P2880 = $P2877."new"($P2878, "pastnode" :named("pasttype"), "declarative" :named("subtype"), $P2879 :named("node"))
    $P2881 = $P2876."!make"($P2880)
.annotate 'line', 1261
    .return ($P2881)
.end


.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<{ }>"  :subid("159_1298325483.2958") :outer("157_1298325483.2958")
    .param pmc param_2883
    .param pmc param_2884
.annotate 'line', 1267
    .lex "self", param_2883
    .lex "$/", param_2884
.annotate 'line', 1268
    find_lex $P2885, "$/"
    get_hll_global $P2886, ["PAST"], "Regex"
    find_lex $P2887, "$/"
    unless_null $P2887, vivify_865
    $P2887 = root_new ['parrot';'Hash']
  vivify_865:
    set $P2888, $P2887["codeblock"]
    unless_null $P2888, vivify_866
    new $P2888, "Undef"
  vivify_866:
    $P2889 = $P2888."ast"()
    find_lex $P2890, "$/"
    $P2891 = $P2886."new"($P2889, "pastnode" :named("pasttype"), $P2890 :named("node"))
    $P2892 = $P2885."!make"($P2891)
.annotate 'line', 1267
    .return ($P2892)
.end


.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<nqpvar>"  :subid("160_1298325483.2958") :outer("157_1298325483.2958")
    .param pmc param_2894
    .param pmc param_2895
.annotate 'line', 1272
    .lex "self", param_2894
    .lex "$/", param_2895
.annotate 'line', 1273
    find_lex $P2896, "$/"
    get_hll_global $P2897, ["PAST"], "Regex"
    find_lex $P2898, "$/"
    unless_null $P2898, vivify_867
    $P2898 = root_new ['parrot';'Hash']
  vivify_867:
    set $P2899, $P2898["var"]
    unless_null $P2899, vivify_868
    new $P2899, "Undef"
  vivify_868:
    $P2900 = $P2899."ast"()
    find_lex $P2901, "$/"
    $P2902 = $P2897."new"("!INTERPOLATE", $P2900, "subrule" :named("pasttype"), "method" :named("subtype"), $P2901 :named("node"))
    $P2903 = $P2896."!make"($P2902)
.annotate 'line', 1272
    .return ($P2903)
.end


.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<{ }>"  :subid("161_1298325483.2958") :outer("157_1298325483.2958")
    .param pmc param_2905
    .param pmc param_2906
.annotate 'line', 1277
    .lex "self", param_2905
    .lex "$/", param_2906
.annotate 'line', 1278
    find_lex $P2907, "$/"
    get_hll_global $P2908, ["PAST"], "Regex"
    find_lex $P2909, "$/"
    unless_null $P2909, vivify_869
    $P2909 = root_new ['parrot';'Hash']
  vivify_869:
    set $P2910, $P2909["codeblock"]
    unless_null $P2910, vivify_870
    new $P2910, "Undef"
  vivify_870:
    $P2911 = $P2910."ast"()
    find_lex $P2912, "$/"
    $P2913 = $P2908."new"("!INTERPOLATE_REGEX", $P2911, "subrule" :named("pasttype"), "method" :named("subtype"), $P2912 :named("node"))
    $P2914 = $P2907."!make"($P2913)
.annotate 'line', 1277
    .return ($P2914)
.end


.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<?{ }>"  :subid("162_1298325483.2958") :outer("157_1298325483.2958")
    .param pmc param_2916
    .param pmc param_2917
.annotate 'line', 1282
    .lex "self", param_2916
    .lex "$/", param_2917
.annotate 'line', 1283
    find_lex $P2918, "$/"
    get_hll_global $P2919, ["PAST"], "Regex"
    find_lex $P2920, "$/"
    unless_null $P2920, vivify_871
    $P2920 = root_new ['parrot';'Hash']
  vivify_871:
    set $P2921, $P2920["codeblock"]
    unless_null $P2921, vivify_872
    new $P2921, "Undef"
  vivify_872:
    $P2922 = $P2921."ast"()
.annotate 'line', 1284
    find_lex $P2923, "$/"
    unless_null $P2923, vivify_873
    $P2923 = root_new ['parrot';'Hash']
  vivify_873:
    set $P2924, $P2923["zw"]
    unless_null $P2924, vivify_874
    new $P2924, "Undef"
  vivify_874:
    set $S2925, $P2924
    iseq $I2926, $S2925, "!"
    find_lex $P2927, "$/"
    $P2928 = $P2919."new"($P2922, "zerowidth" :named("subtype"), $I2926 :named("negate"), "pastnode" :named("pasttype"), $P2927 :named("node"))
.annotate 'line', 1283
    $P2929 = $P2918."!make"($P2928)
.annotate 'line', 1282
    .return ($P2929)
.end


.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<var>"  :subid("163_1298325483.2958") :outer("157_1298325483.2958")
    .param pmc param_2931
    .param pmc param_2932
.annotate 'line', 1288
    .lex "self", param_2931
    .lex "$/", param_2932
.annotate 'line', 1289
    find_lex $P2933, "$/"
    get_hll_global $P2934, ["PAST"], "Regex"
    find_lex $P2935, "$/"
    unless_null $P2935, vivify_875
    $P2935 = root_new ['parrot';'Hash']
  vivify_875:
    set $P2936, $P2935["var"]
    unless_null $P2936, vivify_876
    new $P2936, "Undef"
  vivify_876:
    $P2937 = $P2936."ast"()
    find_lex $P2938, "$/"
    $P2939 = $P2934."new"("!INTERPOLATE_REGEX", $P2937, "subrule" :named("pasttype"), "method" :named("subtype"), $P2938 :named("node"))
    $P2940 = $P2933."!make"($P2939)
.annotate 'line', 1288
    .return ($P2940)
.end


.namespace ["NQP";"RegexActions"]
.sub "codeblock"  :subid("164_1298325483.2958") :outer("157_1298325483.2958")
    .param pmc param_2942
    .param pmc param_2943
.annotate 'line', 1293
    .lex "self", param_2942
    .lex "$/", param_2943
.annotate 'line', 1294
    new $P2944, "Undef"
    .lex "$block", $P2944
.annotate 'line', 1296
    new $P2945, "Undef"
    .lex "$past", $P2945
.annotate 'line', 1294
    find_lex $P2946, "$/"
    unless_null $P2946, vivify_877
    $P2946 = root_new ['parrot';'Hash']
  vivify_877:
    set $P2947, $P2946["block"]
    unless_null $P2947, vivify_878
    new $P2947, "Undef"
  vivify_878:
    $P2948 = $P2947."ast"()
    store_lex "$block", $P2948
.annotate 'line', 1295
    find_lex $P2949, "$block"
    $P2949."blocktype"("immediate")
.annotate 'line', 1297
    get_hll_global $P2950, ["PAST"], "Stmts"
.annotate 'line', 1298
    get_hll_global $P2951, ["PAST"], "Op"
.annotate 'line', 1299
    get_hll_global $P2952, ["PAST"], "Var"
    $P2953 = $P2952."new"("$/" :named("name"))
.annotate 'line', 1300
    get_hll_global $P2954, ["PAST"], "Op"
.annotate 'line', 1301
    get_hll_global $P2955, ["PAST"], "Var"
    $P2956 = $P2955."new"(unicode:"$\x{a2}" :named("name"))
    $P2957 = $P2954."new"($P2956, "MATCH" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 1300
    $P2958 = $P2951."new"($P2953, $P2957, "bind" :named("pasttype"))
.annotate 'line', 1298
    find_lex $P2959, "$block"
    $P2960 = $P2950."new"($P2958, $P2959)
.annotate 'line', 1297
    store_lex "$past", $P2960
.annotate 'line', 1309
    find_lex $P2961, "$/"
    find_lex $P2962, "$past"
    $P2963 = $P2961."!make"($P2962)
.annotate 'line', 1293
    .return ($P2963)
.end


.namespace ["NQP";"Actions"]
.sub "_block2988" :load :anon :subid("166_1298325483.2958")
.annotate 'line', 3
    .const 'Sub' $P2990 = "11_1298325483.2958" 
    $P2991 = $P2990()
    .return ($P2991)
.end


.namespace []
.sub "_block3213" :load :anon :subid("168_1298325483.2958")
.annotate 'line', 1
    .const 'Sub' $P3215 = "10_1298325483.2958" 
    $P3216 = $P3215()
    .return ($P3216)
.end

### .include 'gen/nqp-compiler.pir'

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1298325488.34429")
.annotate 'line', 0
    get_hll_global $P15, ["NQP";"Compiler"], "_block14" 
    capture_lex $P15
.annotate 'line', 1
    nqp_dynop_setup 
    get_hll_global $P13, ["NQP"], "Compiler"
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
    get_hll_global $P15, ["NQP";"Compiler"], "_block14" 
    capture_lex $P15
    $P25 = $P15()
    .return ($P25)
    .const 'Sub' $P27 = "13_1298325488.34429" 
    .return ($P27)
.end


.namespace ["NQP";"Compiler"]
.sub "_block14"  :subid("11_1298325488.34429") :outer("10_1298325488.34429")
.annotate 'line', 1
    .const 'Sub' $P18 = "12_1298325488.34429" 
    capture_lex $P18
    get_global $P16, "$?CLASS"
    .return ()
.end


.namespace ["NQP";"Compiler"]
.sub "" :load :init :subid("post14") :outer("11_1298325488.34429")
.annotate 'line', 1
    get_hll_global $P15, ["NQP";"Compiler"], "_block14" 
    .local pmc block
    set block, $P15
    .const 'Sub' $P18 = "12_1298325488.34429" 
    capture_lex $P18
    $P18()
.end


.namespace ["NQP";"Compiler"]
.sub "_block17"  :anon :subid("12_1298325488.34429") :outer("11_1298325488.34429")
.annotate 'line', 1
    get_hll_global $P19, "NQPClassHOW"
    $P20 = $P19."new_type"("Compiler" :named("name"))
    .local pmc type_obj
    set type_obj, $P20
    set_hll_global ["NQP"], "Compiler", type_obj
    set_global "$?CLASS", type_obj
    get_how $P21, type_obj
    get_hll_global $P22, ["HLL"], "Compiler"
    $P21."add_parent"(type_obj, $P22)
    get_how $P23, type_obj
    $P24 = $P23."compose"(type_obj)
    .return ($P24)
.end


.namespace []
.sub "_block26" :load :anon :subid("13_1298325488.34429")
.annotate 'line', 1
    .const 'Sub' $P28 = "10_1298325488.34429" 
    $P29 = $P28()
    .return ($P29)
.end

### .include 'src/cheats/nqp-builtins.pir'
.namespace []

.sub 'print'
    .param pmc list            :slurpy
    .local pmc list_it
    list_it = iter list
  list_loop:
    unless list_it goto list_done
    $P0 = shift list_it
    print $P0
    goto list_loop
  list_done:
    .return (1)
.end

.sub 'say'
    .param pmc list            :slurpy
    .tailcall 'print'(list :flat, "\n")
.end

.sub 'ok'
    .param pmc    condition
    .param string description :optional
    .param int    has_desc    :opt_flag
    if condition goto it_was_ok
        print "not "
  it_was_ok:
    print "ok "
    $P0 = get_global "$test_counter"
    $P0 += 1
    print $P0
    unless has_desc goto no_description
        print " - "
        print description
  no_description:
    print "\n"

    unless condition goto not_ok
    .return (1)
  not_ok:
    .return (0)
.end

.sub 'skip'
    .param string desc

    print 'ok '
    $P0 = get_global "$test_counter"
    $P0 += 1
    print $P0
    print " # SKIP "
    print desc
    print "\n"
.end

.sub 'plan'
    .param int quantity
    print "1.."
    print quantity
    print "\n"
.end

.sub '' :anon :init :load
    $P0 = box 0
    set_global '$test_counter', $P0
.end



.namespace ['NQP';'Compiler']

.sub '' :anon :load :init
    .local pmc nqpproto, nqpcomp
    nqpproto = get_hll_global ['NQP'], 'Compiler'
    nqpcomp = nqpproto.'new'()
    nqpcomp.'language'('NQP-rx')
    $P0 = get_hll_global ['NQP'], 'Grammar'
    nqpcomp.'parsegrammar'($P0)
    $P0 = get_hll_global ['NQP'], 'Actions'
    nqpcomp.'parseactions'($P0)
    $P0 = nqpcomp.'commandline_options'()
    push $P0, 'parsetrace'
.end

.sub 'main' :main
    .param pmc args_str

    $P0 = compreg 'NQP-rx'
    $P1 = $P0.'command_line'(args_str, 'encoding'=>'utf8', 'transcode'=>'ascii iso-8859-1')
    exit 0
.end

# Local Variables:
#   mode: pir
#   fill-column: 100
# End:
# vim: expandtab shiftwidth=4 ft=pir:
