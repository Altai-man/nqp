
.HLL "nqp"

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1304456155.152")
    .param pmc param_13 :slurpy
.annotate 'line', 0
    .const 'Sub' $P6129 = "589_1304456155.152" 
    capture_lex $P6129
    .const 'Sub' $P5996 = "581_1304456155.152" 
    capture_lex $P5996
    .const 'Sub' $P1976 = "406_1304456155.152" 
    capture_lex $P1976
    .const 'Sub' $P1911 = "385_1304456155.152" 
    capture_lex $P1911
    .const 'Sub' $P47 = "12_1304456155.152" 
    capture_lex $P47
    .const 'Sub' $P16 = "11_1304456155.152" 
    capture_lex $P16
.annotate 'line', 1
    .lex "@ARGS", param_13
    .lex "GLOBALish", $P14
    .lex "$?PACKAGE", $P15
.annotate 'line', 2258
    .const 'Sub' $P16 = "11_1304456155.152" 
    newclosure $P45, $P16
    .lex "MAIN", $P45
.annotate 'line', 1
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
.annotate 'line', 9
    .const 'Sub' $P47 = "12_1304456155.152" 
    capture_lex $P47
    $P47()
.annotate 'line', 725
    .const 'Sub' $P1911 = "385_1304456155.152" 
    capture_lex $P1911
    $P1911()
.annotate 'line', 768
    .const 'Sub' $P1976 = "406_1304456155.152" 
    capture_lex $P1976
    $P1976()
.annotate 'line', 2200
    .const 'Sub' $P5996 = "581_1304456155.152" 
    capture_lex $P5996
    $P5996()
.annotate 'line', 2255
    .const 'Sub' $P6129 = "589_1304456155.152" 
    capture_lex $P6129
    $P6129()
    find_lex $P6132, "MAIN"
    find_lex $P6135, "@ARGS"
    if $P6135, if_6134
    set $P6133, $P6135
    goto if_6134_end
  if_6134:
    .const 'Sub' $P6136 = "11_1304456155.152" 
    find_lex $P6137, "@ARGS"
    $P6138 = $P6136($P6137 :flat)
    set $P6133, $P6138
  if_6134_end:
.annotate 'line', 1
    .return ($P6133)
    .const 'Sub' $P6140 = "590_1304456155.152" 
    .return ($P6140)
.end


.HLL "nqp"

.namespace []
.sub "" :load :init :subid("post591") :outer("10_1304456155.152")
.annotate 'line', 0
    .const 'Sub' $P12 = "10_1304456155.152" 
    .local pmc block
    set block, $P12
    nqp_get_sc $P6144, "1304456142.948"
    isnull $I6145, $P6144
    if $I6145, if_6143
    .const 'Sub' $P8247 = "10_1304456155.152" 
    $P8248 = $P8247."get_lexinfo"()
    nqp_get_sc_object $P8249, "1304456142.948", 0
    $P8248."set_static_lexpad_value"("GLOBALish", $P8249)
    .const 'Sub' $P8250 = "10_1304456155.152" 
    $P8251 = $P8250."get_lexinfo"()
    $P8251."finish_static_lexpad"()
    .const 'Sub' $P8252 = "10_1304456155.152" 
    $P8253 = $P8252."get_lexinfo"()
    nqp_get_sc_object $P8254, "1304456142.948", 0
    $P8253."set_static_lexpad_value"("$?PACKAGE", $P8254)
    .const 'Sub' $P8255 = "10_1304456155.152" 
    $P8256 = $P8255."get_lexinfo"()
    $P8256."finish_static_lexpad"()
    nqp_get_sc_object $P8257, "1304456142.948", 2
    .const 'Sub' $P8258 = "13_1304456155.152" 
    assign $P8257, $P8258
    nqp_get_sc_object $P8259, "1304456142.948", 3
    .const 'Sub' $P8260 = "14_1304456155.152" 
    assign $P8259, $P8260
    nqp_get_sc_object $P8261, "1304456142.948", 4
    .const 'Sub' $P8262 = "15_1304456155.152" 
    assign $P8261, $P8262
    nqp_get_sc_object $P8263, "1304456142.948", 5
    .const 'Sub' $P8264 = "16_1304456155.152" 
    assign $P8263, $P8264
    nqp_get_sc_object $P8265, "1304456142.948", 6
    .const 'Sub' $P8266 = "17_1304456155.152" 
    assign $P8265, $P8266
    nqp_get_sc_object $P8267, "1304456142.948", 7
    .const 'Sub' $P8268 = "18_1304456155.152" 
    assign $P8267, $P8268
    nqp_get_sc_object $P8269, "1304456142.948", 8
    .const 'Sub' $P8270 = "19_1304456155.152" 
    assign $P8269, $P8270
    nqp_get_sc_object $P8271, "1304456142.948", 9
    .const 'Sub' $P8272 = "20_1304456155.152" 
    assign $P8271, $P8272
    nqp_get_sc_object $P8273, "1304456142.948", 10
    .const 'Sub' $P8274 = "21_1304456155.152" 
    assign $P8273, $P8274
    nqp_get_sc_object $P8275, "1304456142.948", 11
    .const 'Sub' $P8276 = "22_1304456155.152" 
    assign $P8275, $P8276
    nqp_get_sc_object $P8277, "1304456142.948", 12
    .const 'Sub' $P8278 = "23_1304456155.152" 
    assign $P8277, $P8278
    nqp_get_sc_object $P8279, "1304456142.948", 13
    .const 'Sub' $P8280 = "24_1304456155.152" 
    assign $P8279, $P8280
    nqp_get_sc_object $P8281, "1304456142.948", 14
    .const 'Sub' $P8282 = "26_1304456155.152" 
    assign $P8281, $P8282
    nqp_get_sc_object $P8283, "1304456142.948", 15
    .const 'Sub' $P8284 = "27_1304456155.152" 
    assign $P8283, $P8284
    nqp_get_sc_object $P8285, "1304456142.948", 16
    .const 'Sub' $P8286 = "29_1304456155.152" 
    assign $P8285, $P8286
    nqp_get_sc_object $P8287, "1304456142.948", 17
    .const 'Sub' $P8288 = "30_1304456155.152" 
    assign $P8287, $P8288
    nqp_get_sc_object $P8289, "1304456142.948", 18
    .const 'Sub' $P8290 = "31_1304456155.152" 
    assign $P8289, $P8290
    nqp_get_sc_object $P8291, "1304456142.948", 19
    .const 'Sub' $P8292 = "32_1304456155.152" 
    assign $P8291, $P8292
    nqp_get_sc_object $P8293, "1304456142.948", 20
    .const 'Sub' $P8294 = "33_1304456155.152" 
    assign $P8293, $P8294
    nqp_get_sc_object $P8295, "1304456142.948", 21
    .const 'Sub' $P8296 = "34_1304456155.152" 
    assign $P8295, $P8296
    nqp_get_sc_object $P8297, "1304456142.948", 22
    .const 'Sub' $P8298 = "36_1304456155.152" 
    assign $P8297, $P8298
    nqp_get_sc_object $P8299, "1304456142.948", 23
    .const 'Sub' $P8300 = "37_1304456155.152" 
    assign $P8299, $P8300
    nqp_get_sc_object $P8301, "1304456142.948", 24
    .const 'Sub' $P8302 = "38_1304456155.152" 
    assign $P8301, $P8302
    nqp_get_sc_object $P8303, "1304456142.948", 25
    .const 'Sub' $P8304 = "39_1304456155.152" 
    assign $P8303, $P8304
    nqp_get_sc_object $P8305, "1304456142.948", 26
    .const 'Sub' $P8306 = "40_1304456155.152" 
    assign $P8305, $P8306
    nqp_get_sc_object $P8307, "1304456142.948", 27
    .const 'Sub' $P8308 = "41_1304456155.152" 
    assign $P8307, $P8308
    nqp_get_sc_object $P8309, "1304456142.948", 28
    .const 'Sub' $P8310 = "42_1304456155.152" 
    assign $P8309, $P8310
    nqp_get_sc_object $P8311, "1304456142.948", 29
    .const 'Sub' $P8312 = "43_1304456155.152" 
    assign $P8311, $P8312
    nqp_get_sc_object $P8313, "1304456142.948", 30
    .const 'Sub' $P8314 = "44_1304456155.152" 
    assign $P8313, $P8314
    nqp_get_sc_object $P8315, "1304456142.948", 31
    .const 'Sub' $P8316 = "45_1304456155.152" 
    assign $P8315, $P8316
    nqp_get_sc_object $P8317, "1304456142.948", 32
    .const 'Sub' $P8318 = "46_1304456155.152" 
    assign $P8317, $P8318
    nqp_get_sc_object $P8319, "1304456142.948", 33
    .const 'Sub' $P8320 = "47_1304456155.152" 
    assign $P8319, $P8320
    nqp_get_sc_object $P8321, "1304456142.948", 34
    .const 'Sub' $P8322 = "48_1304456155.152" 
    assign $P8321, $P8322
    nqp_get_sc_object $P8323, "1304456142.948", 35
    .const 'Sub' $P8324 = "49_1304456155.152" 
    assign $P8323, $P8324
    nqp_get_sc_object $P8325, "1304456142.948", 36
    .const 'Sub' $P8326 = "50_1304456155.152" 
    assign $P8325, $P8326
    nqp_get_sc_object $P8327, "1304456142.948", 37
    .const 'Sub' $P8328 = "51_1304456155.152" 
    assign $P8327, $P8328
    nqp_get_sc_object $P8329, "1304456142.948", 38
    .const 'Sub' $P8330 = "52_1304456155.152" 
    assign $P8329, $P8330
    nqp_get_sc_object $P8331, "1304456142.948", 39
    .const 'Sub' $P8332 = "53_1304456155.152" 
    assign $P8331, $P8332
    nqp_get_sc_object $P8333, "1304456142.948", 40
    .const 'Sub' $P8334 = "54_1304456155.152" 
    assign $P8333, $P8334
    nqp_get_sc_object $P8335, "1304456142.948", 41
    .const 'Sub' $P8336 = "55_1304456155.152" 
    assign $P8335, $P8336
    nqp_get_sc_object $P8337, "1304456142.948", 42
    .const 'Sub' $P8338 = "56_1304456155.152" 
    assign $P8337, $P8338
    nqp_get_sc_object $P8339, "1304456142.948", 43
    .const 'Sub' $P8340 = "57_1304456155.152" 
    assign $P8339, $P8340
    nqp_get_sc_object $P8341, "1304456142.948", 44
    .const 'Sub' $P8342 = "58_1304456155.152" 
    assign $P8341, $P8342
    nqp_get_sc_object $P8343, "1304456142.948", 45
    .const 'Sub' $P8344 = "59_1304456155.152" 
    assign $P8343, $P8344
    nqp_get_sc_object $P8345, "1304456142.948", 46
    .const 'Sub' $P8346 = "60_1304456155.152" 
    assign $P8345, $P8346
    nqp_get_sc_object $P8347, "1304456142.948", 47
    .const 'Sub' $P8348 = "61_1304456155.152" 
    assign $P8347, $P8348
    nqp_get_sc_object $P8349, "1304456142.948", 48
    .const 'Sub' $P8350 = "62_1304456155.152" 
    assign $P8349, $P8350
    nqp_get_sc_object $P8351, "1304456142.948", 49
    .const 'Sub' $P8352 = "63_1304456155.152" 
    assign $P8351, $P8352
    nqp_get_sc_object $P8353, "1304456142.948", 50
    .const 'Sub' $P8354 = "64_1304456155.152" 
    assign $P8353, $P8354
    nqp_get_sc_object $P8355, "1304456142.948", 51
    .const 'Sub' $P8356 = "65_1304456155.152" 
    assign $P8355, $P8356
    nqp_get_sc_object $P8357, "1304456142.948", 52
    .const 'Sub' $P8358 = "66_1304456155.152" 
    assign $P8357, $P8358
    nqp_get_sc_object $P8359, "1304456142.948", 53
    .const 'Sub' $P8360 = "67_1304456155.152" 
    assign $P8359, $P8360
    nqp_get_sc_object $P8361, "1304456142.948", 54
    .const 'Sub' $P8362 = "68_1304456155.152" 
    assign $P8361, $P8362
    nqp_get_sc_object $P8363, "1304456142.948", 55
    .const 'Sub' $P8364 = "69_1304456155.152" 
    assign $P8363, $P8364
    nqp_get_sc_object $P8365, "1304456142.948", 56
    .const 'Sub' $P8366 = "70_1304456155.152" 
    assign $P8365, $P8366
    nqp_get_sc_object $P8367, "1304456142.948", 57
    .const 'Sub' $P8368 = "71_1304456155.152" 
    assign $P8367, $P8368
    nqp_get_sc_object $P8369, "1304456142.948", 58
    .const 'Sub' $P8370 = "73_1304456155.152" 
    assign $P8369, $P8370
    nqp_get_sc_object $P8371, "1304456142.948", 59
    .const 'Sub' $P8372 = "74_1304456155.152" 
    assign $P8371, $P8372
    nqp_get_sc_object $P8373, "1304456142.948", 60
    .const 'Sub' $P8374 = "75_1304456155.152" 
    assign $P8373, $P8374
    nqp_get_sc_object $P8375, "1304456142.948", 61
    .const 'Sub' $P8376 = "76_1304456155.152" 
    assign $P8375, $P8376
    nqp_get_sc_object $P8377, "1304456142.948", 62
    .const 'Sub' $P8378 = "77_1304456155.152" 
    assign $P8377, $P8378
    nqp_get_sc_object $P8379, "1304456142.948", 63
    .const 'Sub' $P8380 = "78_1304456155.152" 
    assign $P8379, $P8380
    nqp_get_sc_object $P8381, "1304456142.948", 64
    .const 'Sub' $P8382 = "79_1304456155.152" 
    assign $P8381, $P8382
    nqp_get_sc_object $P8383, "1304456142.948", 65
    .const 'Sub' $P8384 = "80_1304456155.152" 
    assign $P8383, $P8384
    nqp_get_sc_object $P8385, "1304456142.948", 66
    .const 'Sub' $P8386 = "81_1304456155.152" 
    assign $P8385, $P8386
    nqp_get_sc_object $P8387, "1304456142.948", 67
    .const 'Sub' $P8388 = "82_1304456155.152" 
    assign $P8387, $P8388
    nqp_get_sc_object $P8389, "1304456142.948", 68
    .const 'Sub' $P8390 = "83_1304456155.152" 
    assign $P8389, $P8390
    nqp_get_sc_object $P8391, "1304456142.948", 69
    .const 'Sub' $P8392 = "84_1304456155.152" 
    assign $P8391, $P8392
    nqp_get_sc_object $P8393, "1304456142.948", 70
    .const 'Sub' $P8394 = "85_1304456155.152" 
    assign $P8393, $P8394
    nqp_get_sc_object $P8395, "1304456142.948", 71
    .const 'Sub' $P8396 = "86_1304456155.152" 
    assign $P8395, $P8396
    nqp_get_sc_object $P8397, "1304456142.948", 72
    .const 'Sub' $P8398 = "87_1304456155.152" 
    assign $P8397, $P8398
    nqp_get_sc_object $P8399, "1304456142.948", 73
    .const 'Sub' $P8400 = "88_1304456155.152" 
    assign $P8399, $P8400
    nqp_get_sc_object $P8401, "1304456142.948", 74
    .const 'Sub' $P8402 = "89_1304456155.152" 
    assign $P8401, $P8402
    nqp_get_sc_object $P8403, "1304456142.948", 75
    .const 'Sub' $P8404 = "90_1304456155.152" 
    assign $P8403, $P8404
    nqp_get_sc_object $P8405, "1304456142.948", 76
    .const 'Sub' $P8406 = "91_1304456155.152" 
    assign $P8405, $P8406
    nqp_get_sc_object $P8407, "1304456142.948", 77
    .const 'Sub' $P8408 = "92_1304456155.152" 
    assign $P8407, $P8408
    nqp_get_sc_object $P8409, "1304456142.948", 78
    .const 'Sub' $P8410 = "93_1304456155.152" 
    assign $P8409, $P8410
    nqp_get_sc_object $P8411, "1304456142.948", 79
    .const 'Sub' $P8412 = "94_1304456155.152" 
    assign $P8411, $P8412
    nqp_get_sc_object $P8413, "1304456142.948", 80
    .const 'Sub' $P8414 = "95_1304456155.152" 
    assign $P8413, $P8414
    nqp_get_sc_object $P8415, "1304456142.948", 81
    .const 'Sub' $P8416 = "96_1304456155.152" 
    assign $P8415, $P8416
    nqp_get_sc_object $P8417, "1304456142.948", 82
    .const 'Sub' $P8418 = "97_1304456155.152" 
    assign $P8417, $P8418
    nqp_get_sc_object $P8419, "1304456142.948", 83
    .const 'Sub' $P8420 = "98_1304456155.152" 
    assign $P8419, $P8420
    nqp_get_sc_object $P8421, "1304456142.948", 84
    .const 'Sub' $P8422 = "99_1304456155.152" 
    assign $P8421, $P8422
    nqp_get_sc_object $P8423, "1304456142.948", 85
    .const 'Sub' $P8424 = "100_1304456155.152" 
    assign $P8423, $P8424
    nqp_get_sc_object $P8425, "1304456142.948", 86
    .const 'Sub' $P8426 = "101_1304456155.152" 
    assign $P8425, $P8426
    nqp_get_sc_object $P8427, "1304456142.948", 87
    .const 'Sub' $P8428 = "102_1304456155.152" 
    assign $P8427, $P8428
    nqp_get_sc_object $P8429, "1304456142.948", 88
    .const 'Sub' $P8430 = "103_1304456155.152" 
    assign $P8429, $P8430
    nqp_get_sc_object $P8431, "1304456142.948", 89
    .const 'Sub' $P8432 = "104_1304456155.152" 
    assign $P8431, $P8432
    nqp_get_sc_object $P8433, "1304456142.948", 90
    .const 'Sub' $P8434 = "105_1304456155.152" 
    assign $P8433, $P8434
    nqp_get_sc_object $P8435, "1304456142.948", 91
    .const 'Sub' $P8436 = "106_1304456155.152" 
    assign $P8435, $P8436
    nqp_get_sc_object $P8437, "1304456142.948", 92
    .const 'Sub' $P8438 = "107_1304456155.152" 
    assign $P8437, $P8438
    nqp_get_sc_object $P8439, "1304456142.948", 93
    .const 'Sub' $P8440 = "108_1304456155.152" 
    assign $P8439, $P8440
    nqp_get_sc_object $P8441, "1304456142.948", 94
    .const 'Sub' $P8442 = "109_1304456155.152" 
    assign $P8441, $P8442
    nqp_get_sc_object $P8443, "1304456142.948", 95
    .const 'Sub' $P8444 = "110_1304456155.152" 
    assign $P8443, $P8444
    nqp_get_sc_object $P8445, "1304456142.948", 96
    .const 'Sub' $P8446 = "111_1304456155.152" 
    assign $P8445, $P8446
    nqp_get_sc_object $P8447, "1304456142.948", 97
    .const 'Sub' $P8448 = "112_1304456155.152" 
    assign $P8447, $P8448
    nqp_get_sc_object $P8449, "1304456142.948", 98
    .const 'Sub' $P8450 = "113_1304456155.152" 
    assign $P8449, $P8450
    nqp_get_sc_object $P8451, "1304456142.948", 99
    .const 'Sub' $P8452 = "114_1304456155.152" 
    assign $P8451, $P8452
    nqp_get_sc_object $P8453, "1304456142.948", 100
    .const 'Sub' $P8454 = "115_1304456155.152" 
    assign $P8453, $P8454
    nqp_get_sc_object $P8455, "1304456142.948", 101
    .const 'Sub' $P8456 = "116_1304456155.152" 
    assign $P8455, $P8456
    nqp_get_sc_object $P8457, "1304456142.948", 102
    .const 'Sub' $P8458 = "117_1304456155.152" 
    assign $P8457, $P8458
    nqp_get_sc_object $P8459, "1304456142.948", 103
    .const 'Sub' $P8460 = "118_1304456155.152" 
    assign $P8459, $P8460
    nqp_get_sc_object $P8461, "1304456142.948", 104
    .const 'Sub' $P8462 = "121_1304456155.152" 
    assign $P8461, $P8462
    nqp_get_sc_object $P8463, "1304456142.948", 105
    .const 'Sub' $P8464 = "122_1304456155.152" 
    assign $P8463, $P8464
    nqp_get_sc_object $P8465, "1304456142.948", 106
    .const 'Sub' $P8466 = "123_1304456155.152" 
    assign $P8465, $P8466
    nqp_get_sc_object $P8467, "1304456142.948", 107
    .const 'Sub' $P8468 = "124_1304456155.152" 
    assign $P8467, $P8468
    nqp_get_sc_object $P8469, "1304456142.948", 108
    .const 'Sub' $P8470 = "125_1304456155.152" 
    assign $P8469, $P8470
    nqp_get_sc_object $P8471, "1304456142.948", 109
    .const 'Sub' $P8472 = "126_1304456155.152" 
    assign $P8471, $P8472
    nqp_get_sc_object $P8473, "1304456142.948", 110
    .const 'Sub' $P8474 = "127_1304456155.152" 
    assign $P8473, $P8474
    nqp_get_sc_object $P8475, "1304456142.948", 111
    .const 'Sub' $P8476 = "128_1304456155.152" 
    assign $P8475, $P8476
    nqp_get_sc_object $P8477, "1304456142.948", 112
    .const 'Sub' $P8478 = "129_1304456155.152" 
    assign $P8477, $P8478
    nqp_get_sc_object $P8479, "1304456142.948", 113
    .const 'Sub' $P8480 = "130_1304456155.152" 
    assign $P8479, $P8480
    nqp_get_sc_object $P8481, "1304456142.948", 114
    .const 'Sub' $P8482 = "131_1304456155.152" 
    assign $P8481, $P8482
    nqp_get_sc_object $P8483, "1304456142.948", 115
    .const 'Sub' $P8484 = "132_1304456155.152" 
    assign $P8483, $P8484
    nqp_get_sc_object $P8485, "1304456142.948", 116
    .const 'Sub' $P8486 = "133_1304456155.152" 
    assign $P8485, $P8486
    nqp_get_sc_object $P8487, "1304456142.948", 117
    .const 'Sub' $P8488 = "134_1304456155.152" 
    assign $P8487, $P8488
    nqp_get_sc_object $P8489, "1304456142.948", 118
    .const 'Sub' $P8490 = "135_1304456155.152" 
    assign $P8489, $P8490
    nqp_get_sc_object $P8491, "1304456142.948", 119
    .const 'Sub' $P8492 = "136_1304456155.152" 
    assign $P8491, $P8492
    nqp_get_sc_object $P8493, "1304456142.948", 120
    .const 'Sub' $P8494 = "137_1304456155.152" 
    assign $P8493, $P8494
    nqp_get_sc_object $P8495, "1304456142.948", 121
    .const 'Sub' $P8496 = "138_1304456155.152" 
    assign $P8495, $P8496
    nqp_get_sc_object $P8497, "1304456142.948", 122
    .const 'Sub' $P8498 = "139_1304456155.152" 
    assign $P8497, $P8498
    nqp_get_sc_object $P8499, "1304456142.948", 123
    .const 'Sub' $P8500 = "140_1304456155.152" 
    assign $P8499, $P8500
    nqp_get_sc_object $P8501, "1304456142.948", 124
    .const 'Sub' $P8502 = "141_1304456155.152" 
    assign $P8501, $P8502
    nqp_get_sc_object $P8503, "1304456142.948", 125
    .const 'Sub' $P8504 = "142_1304456155.152" 
    assign $P8503, $P8504
    nqp_get_sc_object $P8505, "1304456142.948", 126
    .const 'Sub' $P8506 = "143_1304456155.152" 
    assign $P8505, $P8506
    nqp_get_sc_object $P8507, "1304456142.948", 127
    .const 'Sub' $P8508 = "144_1304456155.152" 
    assign $P8507, $P8508
    nqp_get_sc_object $P8509, "1304456142.948", 128
    .const 'Sub' $P8510 = "145_1304456155.152" 
    assign $P8509, $P8510
    nqp_get_sc_object $P8511, "1304456142.948", 129
    .const 'Sub' $P8512 = "146_1304456155.152" 
    assign $P8511, $P8512
    nqp_get_sc_object $P8513, "1304456142.948", 130
    .const 'Sub' $P8514 = "147_1304456155.152" 
    assign $P8513, $P8514
    nqp_get_sc_object $P8515, "1304456142.948", 131
    .const 'Sub' $P8516 = "148_1304456155.152" 
    assign $P8515, $P8516
    nqp_get_sc_object $P8517, "1304456142.948", 132
    .const 'Sub' $P8518 = "149_1304456155.152" 
    assign $P8517, $P8518
    nqp_get_sc_object $P8519, "1304456142.948", 133
    .const 'Sub' $P8520 = "150_1304456155.152" 
    assign $P8519, $P8520
    nqp_get_sc_object $P8521, "1304456142.948", 134
    .const 'Sub' $P8522 = "151_1304456155.152" 
    assign $P8521, $P8522
    nqp_get_sc_object $P8523, "1304456142.948", 135
    .const 'Sub' $P8524 = "152_1304456155.152" 
    assign $P8523, $P8524
    nqp_get_sc_object $P8525, "1304456142.948", 136
    .const 'Sub' $P8526 = "154_1304456155.152" 
    assign $P8525, $P8526
    nqp_get_sc_object $P8527, "1304456142.948", 137
    .const 'Sub' $P8528 = "155_1304456155.152" 
    assign $P8527, $P8528
    nqp_get_sc_object $P8529, "1304456142.948", 138
    .const 'Sub' $P8530 = "156_1304456155.152" 
    assign $P8529, $P8530
    nqp_get_sc_object $P8531, "1304456142.948", 139
    .const 'Sub' $P8532 = "157_1304456155.152" 
    assign $P8531, $P8532
    nqp_get_sc_object $P8533, "1304456142.948", 140
    .const 'Sub' $P8534 = "158_1304456155.152" 
    assign $P8533, $P8534
    nqp_get_sc_object $P8535, "1304456142.948", 141
    .const 'Sub' $P8536 = "159_1304456155.152" 
    assign $P8535, $P8536
    nqp_get_sc_object $P8537, "1304456142.948", 142
    .const 'Sub' $P8538 = "160_1304456155.152" 
    assign $P8537, $P8538
    nqp_get_sc_object $P8539, "1304456142.948", 143
    .const 'Sub' $P8540 = "161_1304456155.152" 
    assign $P8539, $P8540
    nqp_get_sc_object $P8541, "1304456142.948", 144
    .const 'Sub' $P8542 = "162_1304456155.152" 
    assign $P8541, $P8542
    nqp_get_sc_object $P8543, "1304456142.948", 145
    .const 'Sub' $P8544 = "163_1304456155.152" 
    assign $P8543, $P8544
    nqp_get_sc_object $P8545, "1304456142.948", 146
    .const 'Sub' $P8546 = "164_1304456155.152" 
    assign $P8545, $P8546
    nqp_get_sc_object $P8547, "1304456142.948", 147
    .const 'Sub' $P8548 = "165_1304456155.152" 
    assign $P8547, $P8548
    nqp_get_sc_object $P8549, "1304456142.948", 148
    .const 'Sub' $P8550 = "167_1304456155.152" 
    assign $P8549, $P8550
    nqp_get_sc_object $P8551, "1304456142.948", 149
    .const 'Sub' $P8552 = "168_1304456155.152" 
    assign $P8551, $P8552
    nqp_get_sc_object $P8553, "1304456142.948", 150
    .const 'Sub' $P8554 = "169_1304456155.152" 
    assign $P8553, $P8554
    nqp_get_sc_object $P8555, "1304456142.948", 151
    .const 'Sub' $P8556 = "170_1304456155.152" 
    assign $P8555, $P8556
    nqp_get_sc_object $P8557, "1304456142.948", 152
    .const 'Sub' $P8558 = "172_1304456155.152" 
    assign $P8557, $P8558
    nqp_get_sc_object $P8559, "1304456142.948", 153
    .const 'Sub' $P8560 = "173_1304456155.152" 
    assign $P8559, $P8560
    nqp_get_sc_object $P8561, "1304456142.948", 154
    .const 'Sub' $P8562 = "174_1304456155.152" 
    assign $P8561, $P8562
    nqp_get_sc_object $P8563, "1304456142.948", 155
    .const 'Sub' $P8564 = "175_1304456155.152" 
    assign $P8563, $P8564
    nqp_get_sc_object $P8565, "1304456142.948", 156
    .const 'Sub' $P8566 = "176_1304456155.152" 
    assign $P8565, $P8566
    nqp_get_sc_object $P8567, "1304456142.948", 157
    .const 'Sub' $P8568 = "177_1304456155.152" 
    assign $P8567, $P8568
    nqp_get_sc_object $P8569, "1304456142.948", 158
    .const 'Sub' $P8570 = "178_1304456155.152" 
    assign $P8569, $P8570
    nqp_get_sc_object $P8571, "1304456142.948", 159
    .const 'Sub' $P8572 = "179_1304456155.152" 
    assign $P8571, $P8572
    nqp_get_sc_object $P8573, "1304456142.948", 160
    .const 'Sub' $P8574 = "180_1304456155.152" 
    assign $P8573, $P8574
    nqp_get_sc_object $P8575, "1304456142.948", 161
    .const 'Sub' $P8576 = "181_1304456155.152" 
    assign $P8575, $P8576
    nqp_get_sc_object $P8577, "1304456142.948", 162
    .const 'Sub' $P8578 = "183_1304456155.152" 
    assign $P8577, $P8578
    nqp_get_sc_object $P8579, "1304456142.948", 163
    .const 'Sub' $P8580 = "184_1304456155.152" 
    assign $P8579, $P8580
    nqp_get_sc_object $P8581, "1304456142.948", 164
    .const 'Sub' $P8582 = "186_1304456155.152" 
    assign $P8581, $P8582
    nqp_get_sc_object $P8583, "1304456142.948", 165
    .const 'Sub' $P8584 = "187_1304456155.152" 
    assign $P8583, $P8584
    nqp_get_sc_object $P8585, "1304456142.948", 166
    .const 'Sub' $P8586 = "188_1304456155.152" 
    assign $P8585, $P8586
    nqp_get_sc_object $P8587, "1304456142.948", 167
    .const 'Sub' $P8588 = "189_1304456155.152" 
    assign $P8587, $P8588
    nqp_get_sc_object $P8589, "1304456142.948", 168
    .const 'Sub' $P8590 = "190_1304456155.152" 
    assign $P8589, $P8590
    nqp_get_sc_object $P8591, "1304456142.948", 169
    .const 'Sub' $P8592 = "191_1304456155.152" 
    assign $P8591, $P8592
    nqp_get_sc_object $P8593, "1304456142.948", 170
    .const 'Sub' $P8594 = "192_1304456155.152" 
    assign $P8593, $P8594
    nqp_get_sc_object $P8595, "1304456142.948", 171
    .const 'Sub' $P8596 = "193_1304456155.152" 
    assign $P8595, $P8596
    nqp_get_sc_object $P8597, "1304456142.948", 172
    .const 'Sub' $P8598 = "194_1304456155.152" 
    assign $P8597, $P8598
    nqp_get_sc_object $P8599, "1304456142.948", 173
    .const 'Sub' $P8600 = "195_1304456155.152" 
    assign $P8599, $P8600
    nqp_get_sc_object $P8601, "1304456142.948", 174
    .const 'Sub' $P8602 = "197_1304456155.152" 
    assign $P8601, $P8602
    nqp_get_sc_object $P8603, "1304456142.948", 175
    .const 'Sub' $P8604 = "198_1304456155.152" 
    assign $P8603, $P8604
    nqp_get_sc_object $P8605, "1304456142.948", 176
    .const 'Sub' $P8606 = "199_1304456155.152" 
    assign $P8605, $P8606
    nqp_get_sc_object $P8607, "1304456142.948", 177
    .const 'Sub' $P8608 = "200_1304456155.152" 
    assign $P8607, $P8608
    nqp_get_sc_object $P8609, "1304456142.948", 178
    .const 'Sub' $P8610 = "201_1304456155.152" 
    assign $P8609, $P8610
    nqp_get_sc_object $P8611, "1304456142.948", 179
    .const 'Sub' $P8612 = "202_1304456155.152" 
    assign $P8611, $P8612
    nqp_get_sc_object $P8613, "1304456142.948", 180
    .const 'Sub' $P8614 = "203_1304456155.152" 
    assign $P8613, $P8614
    nqp_get_sc_object $P8615, "1304456142.948", 181
    .const 'Sub' $P8616 = "204_1304456155.152" 
    assign $P8615, $P8616
    nqp_get_sc_object $P8617, "1304456142.948", 182
    .const 'Sub' $P8618 = "205_1304456155.152" 
    assign $P8617, $P8618
    nqp_get_sc_object $P8619, "1304456142.948", 183
    .const 'Sub' $P8620 = "206_1304456155.152" 
    assign $P8619, $P8620
    nqp_get_sc_object $P8621, "1304456142.948", 184
    .const 'Sub' $P8622 = "207_1304456155.152" 
    assign $P8621, $P8622
    nqp_get_sc_object $P8623, "1304456142.948", 185
    .const 'Sub' $P8624 = "208_1304456155.152" 
    assign $P8623, $P8624
    nqp_get_sc_object $P8625, "1304456142.948", 186
    .const 'Sub' $P8626 = "209_1304456155.152" 
    assign $P8625, $P8626
    nqp_get_sc_object $P8627, "1304456142.948", 187
    .const 'Sub' $P8628 = "210_1304456155.152" 
    assign $P8627, $P8628
    nqp_get_sc_object $P8629, "1304456142.948", 188
    .const 'Sub' $P8630 = "211_1304456155.152" 
    assign $P8629, $P8630
    nqp_get_sc_object $P8631, "1304456142.948", 189
    .const 'Sub' $P8632 = "212_1304456155.152" 
    assign $P8631, $P8632
    nqp_get_sc_object $P8633, "1304456142.948", 190
    .const 'Sub' $P8634 = "213_1304456155.152" 
    assign $P8633, $P8634
    nqp_get_sc_object $P8635, "1304456142.948", 191
    .const 'Sub' $P8636 = "214_1304456155.152" 
    assign $P8635, $P8636
    nqp_get_sc_object $P8637, "1304456142.948", 192
    .const 'Sub' $P8638 = "215_1304456155.152" 
    assign $P8637, $P8638
    nqp_get_sc_object $P8639, "1304456142.948", 193
    .const 'Sub' $P8640 = "216_1304456155.152" 
    assign $P8639, $P8640
    nqp_get_sc_object $P8641, "1304456142.948", 194
    .const 'Sub' $P8642 = "217_1304456155.152" 
    assign $P8641, $P8642
    nqp_get_sc_object $P8643, "1304456142.948", 195
    .const 'Sub' $P8644 = "218_1304456155.152" 
    assign $P8643, $P8644
    nqp_get_sc_object $P8645, "1304456142.948", 196
    .const 'Sub' $P8646 = "219_1304456155.152" 
    assign $P8645, $P8646
    nqp_get_sc_object $P8647, "1304456142.948", 197
    .const 'Sub' $P8648 = "220_1304456155.152" 
    assign $P8647, $P8648
    nqp_get_sc_object $P8649, "1304456142.948", 198
    .const 'Sub' $P8650 = "221_1304456155.152" 
    assign $P8649, $P8650
    nqp_get_sc_object $P8651, "1304456142.948", 199
    .const 'Sub' $P8652 = "222_1304456155.152" 
    assign $P8651, $P8652
    nqp_get_sc_object $P8653, "1304456142.948", 200
    .const 'Sub' $P8654 = "223_1304456155.152" 
    assign $P8653, $P8654
    nqp_get_sc_object $P8655, "1304456142.948", 201
    .const 'Sub' $P8656 = "224_1304456155.152" 
    assign $P8655, $P8656
    nqp_get_sc_object $P8657, "1304456142.948", 202
    .const 'Sub' $P8658 = "225_1304456155.152" 
    assign $P8657, $P8658
    nqp_get_sc_object $P8659, "1304456142.948", 203
    .const 'Sub' $P8660 = "226_1304456155.152" 
    assign $P8659, $P8660
    nqp_get_sc_object $P8661, "1304456142.948", 204
    .const 'Sub' $P8662 = "228_1304456155.152" 
    assign $P8661, $P8662
    nqp_get_sc_object $P8663, "1304456142.948", 205
    .const 'Sub' $P8664 = "229_1304456155.152" 
    assign $P8663, $P8664
    nqp_get_sc_object $P8665, "1304456142.948", 206
    .const 'Sub' $P8666 = "230_1304456155.152" 
    assign $P8665, $P8666
    nqp_get_sc_object $P8667, "1304456142.948", 207
    .const 'Sub' $P8668 = "231_1304456155.152" 
    assign $P8667, $P8668
    nqp_get_sc_object $P8669, "1304456142.948", 208
    .const 'Sub' $P8670 = "232_1304456155.152" 
    assign $P8669, $P8670
    nqp_get_sc_object $P8671, "1304456142.948", 209
    .const 'Sub' $P8672 = "233_1304456155.152" 
    assign $P8671, $P8672
    nqp_get_sc_object $P8673, "1304456142.948", 210
    .const 'Sub' $P8674 = "234_1304456155.152" 
    assign $P8673, $P8674
    nqp_get_sc_object $P8675, "1304456142.948", 211
    .const 'Sub' $P8676 = "235_1304456155.152" 
    assign $P8675, $P8676
    nqp_get_sc_object $P8677, "1304456142.948", 212
    .const 'Sub' $P8678 = "236_1304456155.152" 
    assign $P8677, $P8678
    nqp_get_sc_object $P8679, "1304456142.948", 213
    .const 'Sub' $P8680 = "237_1304456155.152" 
    assign $P8679, $P8680
    nqp_get_sc_object $P8681, "1304456142.948", 214
    .const 'Sub' $P8682 = "238_1304456155.152" 
    assign $P8681, $P8682
    nqp_get_sc_object $P8683, "1304456142.948", 215
    .const 'Sub' $P8684 = "239_1304456155.152" 
    assign $P8683, $P8684
    nqp_get_sc_object $P8685, "1304456142.948", 216
    .const 'Sub' $P8686 = "240_1304456155.152" 
    assign $P8685, $P8686
    nqp_get_sc_object $P8687, "1304456142.948", 217
    .const 'Sub' $P8688 = "241_1304456155.152" 
    assign $P8687, $P8688
    nqp_get_sc_object $P8689, "1304456142.948", 218
    .const 'Sub' $P8690 = "242_1304456155.152" 
    assign $P8689, $P8690
    nqp_get_sc_object $P8691, "1304456142.948", 219
    .const 'Sub' $P8692 = "243_1304456155.152" 
    assign $P8691, $P8692
    nqp_get_sc_object $P8693, "1304456142.948", 220
    .const 'Sub' $P8694 = "244_1304456155.152" 
    assign $P8693, $P8694
    nqp_get_sc_object $P8695, "1304456142.948", 221
    .const 'Sub' $P8696 = "245_1304456155.152" 
    assign $P8695, $P8696
    nqp_get_sc_object $P8697, "1304456142.948", 222
    .const 'Sub' $P8698 = "246_1304456155.152" 
    assign $P8697, $P8698
    nqp_get_sc_object $P8699, "1304456142.948", 223
    .const 'Sub' $P8700 = "247_1304456155.152" 
    assign $P8699, $P8700
    nqp_get_sc_object $P8701, "1304456142.948", 224
    .const 'Sub' $P8702 = "248_1304456155.152" 
    assign $P8701, $P8702
    nqp_get_sc_object $P8703, "1304456142.948", 225
    .const 'Sub' $P8704 = "249_1304456155.152" 
    assign $P8703, $P8704
    nqp_get_sc_object $P8705, "1304456142.948", 226
    .const 'Sub' $P8706 = "250_1304456155.152" 
    assign $P8705, $P8706
    nqp_get_sc_object $P8707, "1304456142.948", 227
    .const 'Sub' $P8708 = "251_1304456155.152" 
    assign $P8707, $P8708
    nqp_get_sc_object $P8709, "1304456142.948", 228
    .const 'Sub' $P8710 = "252_1304456155.152" 
    assign $P8709, $P8710
    nqp_get_sc_object $P8711, "1304456142.948", 229
    .const 'Sub' $P8712 = "253_1304456155.152" 
    assign $P8711, $P8712
    nqp_get_sc_object $P8713, "1304456142.948", 230
    .const 'Sub' $P8714 = "254_1304456155.152" 
    assign $P8713, $P8714
    nqp_get_sc_object $P8715, "1304456142.948", 231
    .const 'Sub' $P8716 = "255_1304456155.152" 
    assign $P8715, $P8716
    nqp_get_sc_object $P8717, "1304456142.948", 232
    .const 'Sub' $P8718 = "256_1304456155.152" 
    assign $P8717, $P8718
    nqp_get_sc_object $P8719, "1304456142.948", 233
    .const 'Sub' $P8720 = "257_1304456155.152" 
    assign $P8719, $P8720
    nqp_get_sc_object $P8721, "1304456142.948", 234
    .const 'Sub' $P8722 = "258_1304456155.152" 
    assign $P8721, $P8722
    nqp_get_sc_object $P8723, "1304456142.948", 235
    .const 'Sub' $P8724 = "259_1304456155.152" 
    assign $P8723, $P8724
    nqp_get_sc_object $P8725, "1304456142.948", 236
    .const 'Sub' $P8726 = "260_1304456155.152" 
    assign $P8725, $P8726
    nqp_get_sc_object $P8727, "1304456142.948", 237
    .const 'Sub' $P8728 = "261_1304456155.152" 
    assign $P8727, $P8728
    nqp_get_sc_object $P8729, "1304456142.948", 238
    .const 'Sub' $P8730 = "262_1304456155.152" 
    assign $P8729, $P8730
    nqp_get_sc_object $P8731, "1304456142.948", 239
    .const 'Sub' $P8732 = "263_1304456155.152" 
    assign $P8731, $P8732
    nqp_get_sc_object $P8733, "1304456142.948", 240
    .const 'Sub' $P8734 = "264_1304456155.152" 
    assign $P8733, $P8734
    nqp_get_sc_object $P8735, "1304456142.948", 241
    .const 'Sub' $P8736 = "265_1304456155.152" 
    assign $P8735, $P8736
    nqp_get_sc_object $P8737, "1304456142.948", 242
    .const 'Sub' $P8738 = "266_1304456155.152" 
    assign $P8737, $P8738
    nqp_get_sc_object $P8739, "1304456142.948", 243
    .const 'Sub' $P8740 = "267_1304456155.152" 
    assign $P8739, $P8740
    nqp_get_sc_object $P8741, "1304456142.948", 244
    .const 'Sub' $P8742 = "268_1304456155.152" 
    assign $P8741, $P8742
    nqp_get_sc_object $P8743, "1304456142.948", 245
    .const 'Sub' $P8744 = "269_1304456155.152" 
    assign $P8743, $P8744
    nqp_get_sc_object $P8745, "1304456142.948", 246
    .const 'Sub' $P8746 = "270_1304456155.152" 
    assign $P8745, $P8746
    nqp_get_sc_object $P8747, "1304456142.948", 247
    .const 'Sub' $P8748 = "271_1304456155.152" 
    assign $P8747, $P8748
    nqp_get_sc_object $P8749, "1304456142.948", 248
    .const 'Sub' $P8750 = "272_1304456155.152" 
    assign $P8749, $P8750
    nqp_get_sc_object $P8751, "1304456142.948", 249
    .const 'Sub' $P8752 = "273_1304456155.152" 
    assign $P8751, $P8752
    nqp_get_sc_object $P8753, "1304456142.948", 250
    .const 'Sub' $P8754 = "274_1304456155.152" 
    assign $P8753, $P8754
    nqp_get_sc_object $P8755, "1304456142.948", 251
    .const 'Sub' $P8756 = "275_1304456155.152" 
    assign $P8755, $P8756
    nqp_get_sc_object $P8757, "1304456142.948", 252
    .const 'Sub' $P8758 = "276_1304456155.152" 
    assign $P8757, $P8758
    nqp_get_sc_object $P8759, "1304456142.948", 253
    .const 'Sub' $P8760 = "277_1304456155.152" 
    assign $P8759, $P8760
    nqp_get_sc_object $P8761, "1304456142.948", 254
    .const 'Sub' $P8762 = "278_1304456155.152" 
    assign $P8761, $P8762
    nqp_get_sc_object $P8763, "1304456142.948", 255
    .const 'Sub' $P8764 = "279_1304456155.152" 
    assign $P8763, $P8764
    nqp_get_sc_object $P8765, "1304456142.948", 256
    .const 'Sub' $P8766 = "280_1304456155.152" 
    assign $P8765, $P8766
    nqp_get_sc_object $P8767, "1304456142.948", 257
    .const 'Sub' $P8768 = "281_1304456155.152" 
    assign $P8767, $P8768
    nqp_get_sc_object $P8769, "1304456142.948", 258
    .const 'Sub' $P8770 = "282_1304456155.152" 
    assign $P8769, $P8770
    nqp_get_sc_object $P8771, "1304456142.948", 259
    .const 'Sub' $P8772 = "283_1304456155.152" 
    assign $P8771, $P8772
    nqp_get_sc_object $P8773, "1304456142.948", 260
    .const 'Sub' $P8774 = "284_1304456155.152" 
    assign $P8773, $P8774
    nqp_get_sc_object $P8775, "1304456142.948", 261
    .const 'Sub' $P8776 = "285_1304456155.152" 
    assign $P8775, $P8776
    nqp_get_sc_object $P8777, "1304456142.948", 262
    .const 'Sub' $P8778 = "286_1304456155.152" 
    assign $P8777, $P8778
    nqp_get_sc_object $P8779, "1304456142.948", 263
    .const 'Sub' $P8780 = "287_1304456155.152" 
    assign $P8779, $P8780
    nqp_get_sc_object $P8781, "1304456142.948", 264
    .const 'Sub' $P8782 = "288_1304456155.152" 
    assign $P8781, $P8782
    nqp_get_sc_object $P8783, "1304456142.948", 265
    .const 'Sub' $P8784 = "289_1304456155.152" 
    assign $P8783, $P8784
    nqp_get_sc_object $P8785, "1304456142.948", 266
    .const 'Sub' $P8786 = "290_1304456155.152" 
    assign $P8785, $P8786
    nqp_get_sc_object $P8787, "1304456142.948", 267
    .const 'Sub' $P8788 = "291_1304456155.152" 
    assign $P8787, $P8788
    nqp_get_sc_object $P8789, "1304456142.948", 268
    .const 'Sub' $P8790 = "292_1304456155.152" 
    assign $P8789, $P8790
    nqp_get_sc_object $P8791, "1304456142.948", 269
    .const 'Sub' $P8792 = "293_1304456155.152" 
    assign $P8791, $P8792
    nqp_get_sc_object $P8793, "1304456142.948", 270
    .const 'Sub' $P8794 = "294_1304456155.152" 
    assign $P8793, $P8794
    nqp_get_sc_object $P8795, "1304456142.948", 271
    .const 'Sub' $P8796 = "295_1304456155.152" 
    assign $P8795, $P8796
    nqp_get_sc_object $P8797, "1304456142.948", 272
    .const 'Sub' $P8798 = "296_1304456155.152" 
    assign $P8797, $P8798
    nqp_get_sc_object $P8799, "1304456142.948", 273
    .const 'Sub' $P8800 = "297_1304456155.152" 
    assign $P8799, $P8800
    nqp_get_sc_object $P8801, "1304456142.948", 274
    .const 'Sub' $P8802 = "298_1304456155.152" 
    assign $P8801, $P8802
    nqp_get_sc_object $P8803, "1304456142.948", 275
    .const 'Sub' $P8804 = "299_1304456155.152" 
    assign $P8803, $P8804
    nqp_get_sc_object $P8805, "1304456142.948", 276
    .const 'Sub' $P8806 = "300_1304456155.152" 
    assign $P8805, $P8806
    nqp_get_sc_object $P8807, "1304456142.948", 277
    .const 'Sub' $P8808 = "301_1304456155.152" 
    assign $P8807, $P8808
    nqp_get_sc_object $P8809, "1304456142.948", 278
    .const 'Sub' $P8810 = "302_1304456155.152" 
    assign $P8809, $P8810
    nqp_get_sc_object $P8811, "1304456142.948", 279
    .const 'Sub' $P8812 = "303_1304456155.152" 
    assign $P8811, $P8812
    nqp_get_sc_object $P8813, "1304456142.948", 280
    .const 'Sub' $P8814 = "304_1304456155.152" 
    assign $P8813, $P8814
    nqp_get_sc_object $P8815, "1304456142.948", 281
    .const 'Sub' $P8816 = "305_1304456155.152" 
    assign $P8815, $P8816
    nqp_get_sc_object $P8817, "1304456142.948", 282
    .const 'Sub' $P8818 = "306_1304456155.152" 
    assign $P8817, $P8818
    nqp_get_sc_object $P8819, "1304456142.948", 283
    .const 'Sub' $P8820 = "307_1304456155.152" 
    assign $P8819, $P8820
    nqp_get_sc_object $P8821, "1304456142.948", 284
    .const 'Sub' $P8822 = "308_1304456155.152" 
    assign $P8821, $P8822
    nqp_get_sc_object $P8823, "1304456142.948", 285
    .const 'Sub' $P8824 = "309_1304456155.152" 
    assign $P8823, $P8824
    nqp_get_sc_object $P8825, "1304456142.948", 286
    .const 'Sub' $P8826 = "310_1304456155.152" 
    assign $P8825, $P8826
    nqp_get_sc_object $P8827, "1304456142.948", 287
    .const 'Sub' $P8828 = "311_1304456155.152" 
    assign $P8827, $P8828
    nqp_get_sc_object $P8829, "1304456142.948", 288
    .const 'Sub' $P8830 = "312_1304456155.152" 
    assign $P8829, $P8830
    nqp_get_sc_object $P8831, "1304456142.948", 289
    .const 'Sub' $P8832 = "313_1304456155.152" 
    assign $P8831, $P8832
    nqp_get_sc_object $P8833, "1304456142.948", 290
    .const 'Sub' $P8834 = "314_1304456155.152" 
    assign $P8833, $P8834
    nqp_get_sc_object $P8835, "1304456142.948", 291
    .const 'Sub' $P8836 = "315_1304456155.152" 
    assign $P8835, $P8836
    nqp_get_sc_object $P8837, "1304456142.948", 292
    .const 'Sub' $P8838 = "316_1304456155.152" 
    assign $P8837, $P8838
    nqp_get_sc_object $P8839, "1304456142.948", 293
    .const 'Sub' $P8840 = "317_1304456155.152" 
    assign $P8839, $P8840
    nqp_get_sc_object $P8841, "1304456142.948", 294
    .const 'Sub' $P8842 = "318_1304456155.152" 
    assign $P8841, $P8842
    nqp_get_sc_object $P8843, "1304456142.948", 295
    .const 'Sub' $P8844 = "319_1304456155.152" 
    assign $P8843, $P8844
    nqp_get_sc_object $P8845, "1304456142.948", 296
    .const 'Sub' $P8846 = "320_1304456155.152" 
    assign $P8845, $P8846
    nqp_get_sc_object $P8847, "1304456142.948", 297
    .const 'Sub' $P8848 = "321_1304456155.152" 
    assign $P8847, $P8848
    nqp_get_sc_object $P8849, "1304456142.948", 298
    .const 'Sub' $P8850 = "322_1304456155.152" 
    assign $P8849, $P8850
    nqp_get_sc_object $P8851, "1304456142.948", 299
    .const 'Sub' $P8852 = "323_1304456155.152" 
    assign $P8851, $P8852
    nqp_get_sc_object $P8853, "1304456142.948", 300
    .const 'Sub' $P8854 = "324_1304456155.152" 
    assign $P8853, $P8854
    nqp_get_sc_object $P8855, "1304456142.948", 301
    .const 'Sub' $P8856 = "325_1304456155.152" 
    assign $P8855, $P8856
    nqp_get_sc_object $P8857, "1304456142.948", 302
    .const 'Sub' $P8858 = "326_1304456155.152" 
    assign $P8857, $P8858
    nqp_get_sc_object $P8859, "1304456142.948", 303
    .const 'Sub' $P8860 = "327_1304456155.152" 
    assign $P8859, $P8860
    nqp_get_sc_object $P8861, "1304456142.948", 304
    .const 'Sub' $P8862 = "328_1304456155.152" 
    assign $P8861, $P8862
    nqp_get_sc_object $P8863, "1304456142.948", 305
    .const 'Sub' $P8864 = "329_1304456155.152" 
    assign $P8863, $P8864
    nqp_get_sc_object $P8865, "1304456142.948", 306
    .const 'Sub' $P8866 = "330_1304456155.152" 
    assign $P8865, $P8866
    nqp_get_sc_object $P8867, "1304456142.948", 307
    .const 'Sub' $P8868 = "331_1304456155.152" 
    assign $P8867, $P8868
    nqp_get_sc_object $P8869, "1304456142.948", 308
    .const 'Sub' $P8870 = "332_1304456155.152" 
    assign $P8869, $P8870
    nqp_get_sc_object $P8871, "1304456142.948", 309
    .const 'Sub' $P8872 = "333_1304456155.152" 
    assign $P8871, $P8872
    nqp_get_sc_object $P8873, "1304456142.948", 310
    .const 'Sub' $P8874 = "334_1304456155.152" 
    assign $P8873, $P8874
    nqp_get_sc_object $P8875, "1304456142.948", 311
    .const 'Sub' $P8876 = "335_1304456155.152" 
    assign $P8875, $P8876
    nqp_get_sc_object $P8877, "1304456142.948", 312
    .const 'Sub' $P8878 = "336_1304456155.152" 
    assign $P8877, $P8878
    nqp_get_sc_object $P8879, "1304456142.948", 313
    .const 'Sub' $P8880 = "337_1304456155.152" 
    assign $P8879, $P8880
    nqp_get_sc_object $P8881, "1304456142.948", 314
    .const 'Sub' $P8882 = "338_1304456155.152" 
    assign $P8881, $P8882
    nqp_get_sc_object $P8883, "1304456142.948", 315
    .const 'Sub' $P8884 = "339_1304456155.152" 
    assign $P8883, $P8884
    nqp_get_sc_object $P8885, "1304456142.948", 316
    .const 'Sub' $P8886 = "340_1304456155.152" 
    assign $P8885, $P8886
    nqp_get_sc_object $P8887, "1304456142.948", 317
    .const 'Sub' $P8888 = "341_1304456155.152" 
    assign $P8887, $P8888
    nqp_get_sc_object $P8889, "1304456142.948", 318
    .const 'Sub' $P8890 = "342_1304456155.152" 
    assign $P8889, $P8890
    nqp_get_sc_object $P8891, "1304456142.948", 319
    .const 'Sub' $P8892 = "343_1304456155.152" 
    assign $P8891, $P8892
    nqp_get_sc_object $P8893, "1304456142.948", 320
    .const 'Sub' $P8894 = "344_1304456155.152" 
    assign $P8893, $P8894
    nqp_get_sc_object $P8895, "1304456142.948", 321
    .const 'Sub' $P8896 = "345_1304456155.152" 
    assign $P8895, $P8896
    nqp_get_sc_object $P8897, "1304456142.948", 322
    .const 'Sub' $P8898 = "346_1304456155.152" 
    assign $P8897, $P8898
    nqp_get_sc_object $P8899, "1304456142.948", 323
    .const 'Sub' $P8900 = "347_1304456155.152" 
    assign $P8899, $P8900
    nqp_get_sc_object $P8901, "1304456142.948", 324
    .const 'Sub' $P8902 = "348_1304456155.152" 
    assign $P8901, $P8902
    nqp_get_sc_object $P8903, "1304456142.948", 325
    .const 'Sub' $P8904 = "349_1304456155.152" 
    assign $P8903, $P8904
    nqp_get_sc_object $P8905, "1304456142.948", 326
    .const 'Sub' $P8906 = "350_1304456155.152" 
    assign $P8905, $P8906
    nqp_get_sc_object $P8907, "1304456142.948", 327
    .const 'Sub' $P8908 = "351_1304456155.152" 
    assign $P8907, $P8908
    nqp_get_sc_object $P8909, "1304456142.948", 328
    .const 'Sub' $P8910 = "352_1304456155.152" 
    assign $P8909, $P8910
    nqp_get_sc_object $P8911, "1304456142.948", 329
    .const 'Sub' $P8912 = "353_1304456155.152" 
    assign $P8911, $P8912
    nqp_get_sc_object $P8913, "1304456142.948", 330
    .const 'Sub' $P8914 = "354_1304456155.152" 
    assign $P8913, $P8914
    nqp_get_sc_object $P8915, "1304456142.948", 331
    .const 'Sub' $P8916 = "355_1304456155.152" 
    assign $P8915, $P8916
    nqp_get_sc_object $P8917, "1304456142.948", 332
    .const 'Sub' $P8918 = "356_1304456155.152" 
    assign $P8917, $P8918
    nqp_get_sc_object $P8919, "1304456142.948", 333
    .const 'Sub' $P8920 = "357_1304456155.152" 
    assign $P8919, $P8920
    nqp_get_sc_object $P8921, "1304456142.948", 334
    .const 'Sub' $P8922 = "358_1304456155.152" 
    assign $P8921, $P8922
    nqp_get_sc_object $P8923, "1304456142.948", 335
    .const 'Sub' $P8924 = "359_1304456155.152" 
    assign $P8923, $P8924
    nqp_get_sc_object $P8925, "1304456142.948", 336
    .const 'Sub' $P8926 = "360_1304456155.152" 
    assign $P8925, $P8926
    nqp_get_sc_object $P8927, "1304456142.948", 337
    .const 'Sub' $P8928 = "361_1304456155.152" 
    assign $P8927, $P8928
    nqp_get_sc_object $P8929, "1304456142.948", 338
    .const 'Sub' $P8930 = "362_1304456155.152" 
    assign $P8929, $P8930
    nqp_get_sc_object $P8931, "1304456142.948", 339
    .const 'Sub' $P8932 = "363_1304456155.152" 
    assign $P8931, $P8932
    nqp_get_sc_object $P8933, "1304456142.948", 340
    .const 'Sub' $P8934 = "364_1304456155.152" 
    assign $P8933, $P8934
    nqp_get_sc_object $P8935, "1304456142.948", 341
    .const 'Sub' $P8936 = "365_1304456155.152" 
    assign $P8935, $P8936
    nqp_get_sc_object $P8937, "1304456142.948", 342
    .const 'Sub' $P8938 = "366_1304456155.152" 
    assign $P8937, $P8938
    nqp_get_sc_object $P8939, "1304456142.948", 343
    .const 'Sub' $P8940 = "367_1304456155.152" 
    assign $P8939, $P8940
    nqp_get_sc_object $P8941, "1304456142.948", 344
    .const 'Sub' $P8942 = "368_1304456155.152" 
    assign $P8941, $P8942
    nqp_get_sc_object $P8943, "1304456142.948", 345
    .const 'Sub' $P8944 = "369_1304456155.152" 
    assign $P8943, $P8944
    nqp_get_sc_object $P8945, "1304456142.948", 346
    .const 'Sub' $P8946 = "370_1304456155.152" 
    assign $P8945, $P8946
    nqp_get_sc_object $P8947, "1304456142.948", 347
    .const 'Sub' $P8948 = "371_1304456155.152" 
    assign $P8947, $P8948
    nqp_get_sc_object $P8949, "1304456142.948", 348
    .const 'Sub' $P8950 = "372_1304456155.152" 
    assign $P8949, $P8950
    nqp_get_sc_object $P8951, "1304456142.948", 349
    .const 'Sub' $P8952 = "373_1304456155.152" 
    assign $P8951, $P8952
    nqp_get_sc_object $P8953, "1304456142.948", 350
    .const 'Sub' $P8954 = "375_1304456155.152" 
    assign $P8953, $P8954
    nqp_get_sc_object $P8955, "1304456142.948", 351
    .const 'Sub' $P8956 = "376_1304456155.152" 
    assign $P8955, $P8956
    nqp_get_sc_object $P8957, "1304456142.948", 352
    .const 'Sub' $P8958 = "377_1304456155.152" 
    assign $P8957, $P8958
    nqp_get_sc_object $P8959, "1304456142.948", 353
    .const 'Sub' $P8960 = "378_1304456155.152" 
    assign $P8959, $P8960
    nqp_get_sc_object $P8961, "1304456142.948", 354
    .const 'Sub' $P8962 = "379_1304456155.152" 
    assign $P8961, $P8962
    nqp_get_sc_object $P8963, "1304456142.948", 355
    .const 'Sub' $P8964 = "380_1304456155.152" 
    assign $P8963, $P8964
    nqp_get_sc_object $P8965, "1304456142.948", 356
    .const 'Sub' $P8966 = "381_1304456155.152" 
    assign $P8965, $P8966
    nqp_get_sc_object $P8967, "1304456142.948", 357
    .const 'Sub' $P8968 = "382_1304456155.152" 
    assign $P8967, $P8968
    nqp_get_sc_object $P8969, "1304456142.948", 358
    .const 'Sub' $P8970 = "383_1304456155.152" 
    assign $P8969, $P8970
    nqp_get_sc_object $P8971, "1304456142.948", 359
    .const 'Sub' $P8972 = "384_1304456155.152" 
    assign $P8971, $P8972
    .const 'Sub' $P8973 = "12_1304456155.152" 
    $P8974 = $P8973."get_lexinfo"()
    nqp_get_sc_object $P8975, "1304456142.948", 1
    $P8974."set_static_lexpad_value"("$?PACKAGE", $P8975)
    .const 'Sub' $P8976 = "12_1304456155.152" 
    $P8977 = $P8976."get_lexinfo"()
    $P8977."finish_static_lexpad"()
    .const 'Sub' $P8978 = "12_1304456155.152" 
    $P8979 = $P8978."get_lexinfo"()
    nqp_get_sc_object $P8980, "1304456142.948", 1
    $P8979."set_static_lexpad_value"("$?CLASS", $P8980)
    .const 'Sub' $P8981 = "12_1304456155.152" 
    $P8982 = $P8981."get_lexinfo"()
    $P8982."finish_static_lexpad"()
    nqp_get_sc_object $P8983, "1304456142.948", 361
    .const 'Sub' $P8984 = "386_1304456155.152" 
    assign $P8983, $P8984
    nqp_get_sc_object $P8985, "1304456142.948", 362
    .const 'Sub' $P8986 = "388_1304456155.152" 
    assign $P8985, $P8986
    nqp_get_sc_object $P8987, "1304456142.948", 363
    .const 'Sub' $P8988 = "389_1304456155.152" 
    assign $P8987, $P8988
    nqp_get_sc_object $P8989, "1304456142.948", 364
    .const 'Sub' $P8990 = "390_1304456155.152" 
    assign $P8989, $P8990
    nqp_get_sc_object $P8991, "1304456142.948", 365
    .const 'Sub' $P8992 = "391_1304456155.152" 
    assign $P8991, $P8992
    nqp_get_sc_object $P8993, "1304456142.948", 366
    .const 'Sub' $P8994 = "393_1304456155.152" 
    assign $P8993, $P8994
    nqp_get_sc_object $P8995, "1304456142.948", 367
    .const 'Sub' $P8996 = "394_1304456155.152" 
    assign $P8995, $P8996
    nqp_get_sc_object $P8997, "1304456142.948", 368
    .const 'Sub' $P8998 = "395_1304456155.152" 
    assign $P8997, $P8998
    nqp_get_sc_object $P8999, "1304456142.948", 369
    .const 'Sub' $P9000 = "396_1304456155.152" 
    assign $P8999, $P9000
    nqp_get_sc_object $P9001, "1304456142.948", 370
    .const 'Sub' $P9002 = "398_1304456155.152" 
    assign $P9001, $P9002
    nqp_get_sc_object $P9003, "1304456142.948", 371
    .const 'Sub' $P9004 = "399_1304456155.152" 
    assign $P9003, $P9004
    nqp_get_sc_object $P9005, "1304456142.948", 372
    .const 'Sub' $P9006 = "401_1304456155.152" 
    assign $P9005, $P9006
    nqp_get_sc_object $P9007, "1304456142.948", 373
    .const 'Sub' $P9008 = "402_1304456155.152" 
    assign $P9007, $P9008
    nqp_get_sc_object $P9009, "1304456142.948", 374
    .const 'Sub' $P9010 = "403_1304456155.152" 
    assign $P9009, $P9010
    nqp_get_sc_object $P9011, "1304456142.948", 375
    .const 'Sub' $P9012 = "404_1304456155.152" 
    assign $P9011, $P9012
    nqp_get_sc_object $P9013, "1304456142.948", 376
    .const 'Sub' $P9014 = "405_1304456155.152" 
    assign $P9013, $P9014
    .const 'Sub' $P9015 = "385_1304456155.152" 
    $P9016 = $P9015."get_lexinfo"()
    nqp_get_sc_object $P9017, "1304456142.948", 360
    $P9016."set_static_lexpad_value"("$?PACKAGE", $P9017)
    .const 'Sub' $P9018 = "385_1304456155.152" 
    $P9019 = $P9018."get_lexinfo"()
    $P9019."finish_static_lexpad"()
    .const 'Sub' $P9020 = "385_1304456155.152" 
    $P9021 = $P9020."get_lexinfo"()
    nqp_get_sc_object $P9022, "1304456142.948", 360
    $P9021."set_static_lexpad_value"("$?CLASS", $P9022)
    .const 'Sub' $P9023 = "385_1304456155.152" 
    $P9024 = $P9023."get_lexinfo"()
    $P9024."finish_static_lexpad"()
    nqp_get_sc_object $P9025, "1304456142.948", 378
    .const 'Sub' $P9026 = "433_1304456155.152" 
    assign $P9025, $P9026
    nqp_get_sc_object $P9027, "1304456142.948", 379
    .const 'Sub' $P9028 = "434_1304456155.152" 
    assign $P9027, $P9028
    nqp_get_sc_object $P9029, "1304456142.948", 380
    .const 'Sub' $P9030 = "435_1304456155.152" 
    assign $P9029, $P9030
    nqp_get_sc_object $P9031, "1304456142.948", 381
    .const 'Sub' $P9032 = "436_1304456155.152" 
    assign $P9031, $P9032
    nqp_get_sc_object $P9033, "1304456142.948", 382
    .const 'Sub' $P9034 = "438_1304456155.152" 
    assign $P9033, $P9034
    nqp_get_sc_object $P9035, "1304456142.948", 383
    .const 'Sub' $P9036 = "440_1304456155.152" 
    assign $P9035, $P9036
    nqp_get_sc_object $P9037, "1304456142.948", 384
    .const 'Sub' $P9038 = "441_1304456155.152" 
    assign $P9037, $P9038
    nqp_get_sc_object $P9039, "1304456142.948", 385
    .const 'Sub' $P9040 = "442_1304456155.152" 
    assign $P9039, $P9040
    nqp_get_sc_object $P9041, "1304456142.948", 386
    .const 'Sub' $P9042 = "443_1304456155.152" 
    assign $P9041, $P9042
    nqp_get_sc_object $P9043, "1304456142.948", 387
    .const 'Sub' $P9044 = "445_1304456155.152" 
    assign $P9043, $P9044
    nqp_get_sc_object $P9045, "1304456142.948", 388
    .const 'Sub' $P9046 = "446_1304456155.152" 
    assign $P9045, $P9046
    nqp_get_sc_object $P9047, "1304456142.948", 389
    .const 'Sub' $P9048 = "448_1304456155.152" 
    assign $P9047, $P9048
    nqp_get_sc_object $P9049, "1304456142.948", 390
    .const 'Sub' $P9050 = "449_1304456155.152" 
    assign $P9049, $P9050
    nqp_get_sc_object $P9051, "1304456142.948", 391
    .const 'Sub' $P9052 = "450_1304456155.152" 
    assign $P9051, $P9052
    nqp_get_sc_object $P9053, "1304456142.948", 392
    .const 'Sub' $P9054 = "451_1304456155.152" 
    assign $P9053, $P9054
    nqp_get_sc_object $P9055, "1304456142.948", 393
    .const 'Sub' $P9056 = "453_1304456155.152" 
    assign $P9055, $P9056
    nqp_get_sc_object $P9057, "1304456142.948", 394
    .const 'Sub' $P9058 = "454_1304456155.152" 
    assign $P9057, $P9058
    nqp_get_sc_object $P9059, "1304456142.948", 395
    .const 'Sub' $P9060 = "455_1304456155.152" 
    assign $P9059, $P9060
    nqp_get_sc_object $P9061, "1304456142.948", 396
    .const 'Sub' $P9062 = "456_1304456155.152" 
    assign $P9061, $P9062
    nqp_get_sc_object $P9063, "1304456142.948", 397
    .const 'Sub' $P9064 = "457_1304456155.152" 
    assign $P9063, $P9064
    nqp_get_sc_object $P9065, "1304456142.948", 398
    .const 'Sub' $P9066 = "458_1304456155.152" 
    assign $P9065, $P9066
    nqp_get_sc_object $P9067, "1304456142.948", 399
    .const 'Sub' $P9068 = "459_1304456155.152" 
    assign $P9067, $P9068
    nqp_get_sc_object $P9069, "1304456142.948", 400
    .const 'Sub' $P9070 = "460_1304456155.152" 
    assign $P9069, $P9070
    nqp_get_sc_object $P9071, "1304456142.948", 401
    .const 'Sub' $P9072 = "461_1304456155.152" 
    assign $P9071, $P9072
    nqp_get_sc_object $P9073, "1304456142.948", 402
    .const 'Sub' $P9074 = "462_1304456155.152" 
    assign $P9073, $P9074
    nqp_get_sc_object $P9075, "1304456142.948", 403
    .const 'Sub' $P9076 = "463_1304456155.152" 
    assign $P9075, $P9076
    nqp_get_sc_object $P9077, "1304456142.948", 404
    .const 'Sub' $P9078 = "464_1304456155.152" 
    assign $P9077, $P9078
    nqp_get_sc_object $P9079, "1304456142.948", 405
    .const 'Sub' $P9080 = "465_1304456155.152" 
    assign $P9079, $P9080
    nqp_get_sc_object $P9081, "1304456142.948", 406
    .const 'Sub' $P9082 = "466_1304456155.152" 
    assign $P9081, $P9082
    nqp_get_sc_object $P9083, "1304456142.948", 407
    .const 'Sub' $P9084 = "467_1304456155.152" 
    assign $P9083, $P9084
    nqp_get_sc_object $P9085, "1304456142.948", 408
    .const 'Sub' $P9086 = "468_1304456155.152" 
    assign $P9085, $P9086
    nqp_get_sc_object $P9087, "1304456142.948", 409
    .const 'Sub' $P9088 = "469_1304456155.152" 
    assign $P9087, $P9088
    nqp_get_sc_object $P9089, "1304456142.948", 410
    .const 'Sub' $P9090 = "470_1304456155.152" 
    assign $P9089, $P9090
    nqp_get_sc_object $P9091, "1304456142.948", 411
    .const 'Sub' $P9092 = "471_1304456155.152" 
    assign $P9091, $P9092
    nqp_get_sc_object $P9093, "1304456142.948", 412
    .const 'Sub' $P9094 = "472_1304456155.152" 
    assign $P9093, $P9094
    nqp_get_sc_object $P9095, "1304456142.948", 413
    .const 'Sub' $P9096 = "473_1304456155.152" 
    assign $P9095, $P9096
    nqp_get_sc_object $P9097, "1304456142.948", 414
    .const 'Sub' $P9098 = "474_1304456155.152" 
    assign $P9097, $P9098
    nqp_get_sc_object $P9099, "1304456142.948", 415
    .const 'Sub' $P9100 = "475_1304456155.152" 
    assign $P9099, $P9100
    nqp_get_sc_object $P9101, "1304456142.948", 416
    .const 'Sub' $P9102 = "476_1304456155.152" 
    assign $P9101, $P9102
    nqp_get_sc_object $P9103, "1304456142.948", 417
    .const 'Sub' $P9104 = "477_1304456155.152" 
    assign $P9103, $P9104
    nqp_get_sc_object $P9105, "1304456142.948", 418
    .const 'Sub' $P9106 = "483_1304456155.152" 
    assign $P9105, $P9106
    nqp_get_sc_object $P9107, "1304456142.948", 419
    .const 'Sub' $P9108 = "484_1304456155.152" 
    assign $P9107, $P9108
    nqp_get_sc_object $P9109, "1304456142.948", 420
    .const 'Sub' $P9110 = "485_1304456155.152" 
    assign $P9109, $P9110
    nqp_get_sc_object $P9111, "1304456142.948", 421
    .const 'Sub' $P9112 = "486_1304456155.152" 
    assign $P9111, $P9112
    nqp_get_sc_object $P9113, "1304456142.948", 422
    .const 'Sub' $P9114 = "487_1304456155.152" 
    assign $P9113, $P9114
    nqp_get_sc_object $P9115, "1304456142.948", 423
    .const 'Sub' $P9116 = "488_1304456155.152" 
    assign $P9115, $P9116
    nqp_get_sc_object $P9117, "1304456142.948", 424
    .const 'Sub' $P9118 = "489_1304456155.152" 
    assign $P9117, $P9118
    nqp_get_sc_object $P9119, "1304456142.948", 425
    .const 'Sub' $P9120 = "495_1304456155.152" 
    assign $P9119, $P9120
    nqp_get_sc_object $P9121, "1304456142.948", 426
    .const 'Sub' $P9122 = "496_1304456155.152" 
    assign $P9121, $P9122
    nqp_get_sc_object $P9123, "1304456142.948", 427
    .const 'Sub' $P9124 = "497_1304456155.152" 
    assign $P9123, $P9124
    nqp_get_sc_object $P9125, "1304456142.948", 428
    .const 'Sub' $P9126 = "498_1304456155.152" 
    assign $P9125, $P9126
    nqp_get_sc_object $P9127, "1304456142.948", 429
    .const 'Sub' $P9128 = "499_1304456155.152" 
    assign $P9127, $P9128
    nqp_get_sc_object $P9129, "1304456142.948", 430
    .const 'Sub' $P9130 = "500_1304456155.152" 
    assign $P9129, $P9130
    nqp_get_sc_object $P9131, "1304456142.948", 431
    .const 'Sub' $P9132 = "501_1304456155.152" 
    assign $P9131, $P9132
    nqp_get_sc_object $P9133, "1304456142.948", 432
    .const 'Sub' $P9134 = "502_1304456155.152" 
    assign $P9133, $P9134
    nqp_get_sc_object $P9135, "1304456142.948", 433
    .const 'Sub' $P9136 = "503_1304456155.152" 
    assign $P9135, $P9136
    nqp_get_sc_object $P9137, "1304456142.948", 434
    .const 'Sub' $P9138 = "505_1304456155.152" 
    assign $P9137, $P9138
    nqp_get_sc_object $P9139, "1304456142.948", 435
    .const 'Sub' $P9140 = "506_1304456155.152" 
    assign $P9139, $P9140
    nqp_get_sc_object $P9141, "1304456142.948", 436
    .const 'Sub' $P9142 = "507_1304456155.152" 
    assign $P9141, $P9142
    nqp_get_sc_object $P9143, "1304456142.948", 437
    .const 'Sub' $P9144 = "514_1304456155.152" 
    assign $P9143, $P9144
    nqp_get_sc_object $P9145, "1304456142.948", 438
    .const 'Sub' $P9146 = "517_1304456155.152" 
    assign $P9145, $P9146
    nqp_get_sc_object $P9147, "1304456142.948", 439
    .const 'Sub' $P9148 = "520_1304456155.152" 
    assign $P9147, $P9148
    nqp_get_sc_object $P9149, "1304456142.948", 440
    .const 'Sub' $P9150 = "521_1304456155.152" 
    assign $P9149, $P9150
    nqp_get_sc_object $P9151, "1304456142.948", 441
    .const 'Sub' $P9152 = "522_1304456155.152" 
    assign $P9151, $P9152
    nqp_get_sc_object $P9153, "1304456142.948", 442
    .const 'Sub' $P9154 = "523_1304456155.152" 
    assign $P9153, $P9154
    nqp_get_sc_object $P9155, "1304456142.948", 443
    .const 'Sub' $P9156 = "525_1304456155.152" 
    assign $P9155, $P9156
    nqp_get_sc_object $P9157, "1304456142.948", 444
    .const 'Sub' $P9158 = "526_1304456155.152" 
    assign $P9157, $P9158
    nqp_get_sc_object $P9159, "1304456142.948", 445
    .const 'Sub' $P9160 = "529_1304456155.152" 
    assign $P9159, $P9160
    nqp_get_sc_object $P9161, "1304456142.948", 446
    .const 'Sub' $P9162 = "534_1304456155.152" 
    assign $P9161, $P9162
    nqp_get_sc_object $P9163, "1304456142.948", 447
    .const 'Sub' $P9164 = "535_1304456155.152" 
    assign $P9163, $P9164
    nqp_get_sc_object $P9165, "1304456142.948", 448
    .const 'Sub' $P9166 = "536_1304456155.152" 
    assign $P9165, $P9166
    nqp_get_sc_object $P9167, "1304456142.948", 449
    .const 'Sub' $P9168 = "537_1304456155.152" 
    assign $P9167, $P9168
    nqp_get_sc_object $P9169, "1304456142.948", 450
    .const 'Sub' $P9170 = "539_1304456155.152" 
    assign $P9169, $P9170
    nqp_get_sc_object $P9171, "1304456142.948", 451
    .const 'Sub' $P9172 = "540_1304456155.152" 
    assign $P9171, $P9172
    nqp_get_sc_object $P9173, "1304456142.948", 452
    .const 'Sub' $P9174 = "541_1304456155.152" 
    assign $P9173, $P9174
    nqp_get_sc_object $P9175, "1304456142.948", 453
    .const 'Sub' $P9176 = "542_1304456155.152" 
    assign $P9175, $P9176
    nqp_get_sc_object $P9177, "1304456142.948", 454
    .const 'Sub' $P9178 = "545_1304456155.152" 
    assign $P9177, $P9178
    nqp_get_sc_object $P9179, "1304456142.948", 455
    .const 'Sub' $P9180 = "546_1304456155.152" 
    assign $P9179, $P9180
    nqp_get_sc_object $P9181, "1304456142.948", 456
    .const 'Sub' $P9182 = "547_1304456155.152" 
    assign $P9181, $P9182
    nqp_get_sc_object $P9183, "1304456142.948", 457
    .const 'Sub' $P9184 = "548_1304456155.152" 
    assign $P9183, $P9184
    nqp_get_sc_object $P9185, "1304456142.948", 458
    .const 'Sub' $P9186 = "549_1304456155.152" 
    assign $P9185, $P9186
    nqp_get_sc_object $P9187, "1304456142.948", 459
    .const 'Sub' $P9188 = "550_1304456155.152" 
    assign $P9187, $P9188
    nqp_get_sc_object $P9189, "1304456142.948", 460
    .const 'Sub' $P9190 = "551_1304456155.152" 
    assign $P9189, $P9190
    nqp_get_sc_object $P9191, "1304456142.948", 461
    .const 'Sub' $P9192 = "553_1304456155.152" 
    assign $P9191, $P9192
    nqp_get_sc_object $P9193, "1304456142.948", 462
    .const 'Sub' $P9194 = "554_1304456155.152" 
    assign $P9193, $P9194
    nqp_get_sc_object $P9195, "1304456142.948", 463
    .const 'Sub' $P9196 = "555_1304456155.152" 
    assign $P9195, $P9196
    nqp_get_sc_object $P9197, "1304456142.948", 464
    .const 'Sub' $P9198 = "556_1304456155.152" 
    assign $P9197, $P9198
    nqp_get_sc_object $P9199, "1304456142.948", 465
    .const 'Sub' $P9200 = "557_1304456155.152" 
    assign $P9199, $P9200
    nqp_get_sc_object $P9201, "1304456142.948", 466
    .const 'Sub' $P9202 = "558_1304456155.152" 
    assign $P9201, $P9202
    nqp_get_sc_object $P9203, "1304456142.948", 467
    .const 'Sub' $P9204 = "559_1304456155.152" 
    assign $P9203, $P9204
    nqp_get_sc_object $P9205, "1304456142.948", 468
    .const 'Sub' $P9206 = "560_1304456155.152" 
    assign $P9205, $P9206
    nqp_get_sc_object $P9207, "1304456142.948", 469
    .const 'Sub' $P9208 = "561_1304456155.152" 
    assign $P9207, $P9208
    nqp_get_sc_object $P9209, "1304456142.948", 470
    .const 'Sub' $P9210 = "562_1304456155.152" 
    assign $P9209, $P9210
    nqp_get_sc_object $P9211, "1304456142.948", 471
    .const 'Sub' $P9212 = "563_1304456155.152" 
    assign $P9211, $P9212
    nqp_get_sc_object $P9213, "1304456142.948", 472
    .const 'Sub' $P9214 = "564_1304456155.152" 
    assign $P9213, $P9214
    nqp_get_sc_object $P9215, "1304456142.948", 473
    .const 'Sub' $P9216 = "565_1304456155.152" 
    assign $P9215, $P9216
    nqp_get_sc_object $P9217, "1304456142.948", 474
    .const 'Sub' $P9218 = "566_1304456155.152" 
    assign $P9217, $P9218
    nqp_get_sc_object $P9219, "1304456142.948", 475
    .const 'Sub' $P9220 = "567_1304456155.152" 
    assign $P9219, $P9220
    nqp_get_sc_object $P9221, "1304456142.948", 476
    .const 'Sub' $P9222 = "568_1304456155.152" 
    assign $P9221, $P9222
    nqp_get_sc_object $P9223, "1304456142.948", 477
    .const 'Sub' $P9224 = "569_1304456155.152" 
    assign $P9223, $P9224
    nqp_get_sc_object $P9225, "1304456142.948", 478
    .const 'Sub' $P9226 = "570_1304456155.152" 
    assign $P9225, $P9226
    nqp_get_sc_object $P9227, "1304456142.948", 479
    .const 'Sub' $P9228 = "571_1304456155.152" 
    assign $P9227, $P9228
    nqp_get_sc_object $P9229, "1304456142.948", 480
    .const 'Sub' $P9230 = "572_1304456155.152" 
    assign $P9229, $P9230
    nqp_get_sc_object $P9231, "1304456142.948", 481
    .const 'Sub' $P9232 = "573_1304456155.152" 
    assign $P9231, $P9232
    nqp_get_sc_object $P9233, "1304456142.948", 482
    .const 'Sub' $P9234 = "574_1304456155.152" 
    assign $P9233, $P9234
    nqp_get_sc_object $P9235, "1304456142.948", 483
    .const 'Sub' $P9236 = "575_1304456155.152" 
    assign $P9235, $P9236
    nqp_get_sc_object $P9237, "1304456142.948", 484
    .const 'Sub' $P9238 = "576_1304456155.152" 
    assign $P9237, $P9238
    nqp_get_sc_object $P9239, "1304456142.948", 485
    .const 'Sub' $P9240 = "577_1304456155.152" 
    assign $P9239, $P9240
    nqp_get_sc_object $P9241, "1304456142.948", 486
    .const 'Sub' $P9242 = "578_1304456155.152" 
    assign $P9241, $P9242
    nqp_get_sc_object $P9243, "1304456142.948", 487
    .const 'Sub' $P9244 = "579_1304456155.152" 
    assign $P9243, $P9244
    .const 'Sub' $P9245 = "406_1304456155.152" 
    $P9246 = $P9245."get_lexinfo"()
    nqp_get_sc_object $P9247, "1304456142.948", 377
    $P9246."set_static_lexpad_value"("$?PACKAGE", $P9247)
    .const 'Sub' $P9248 = "406_1304456155.152" 
    $P9249 = $P9248."get_lexinfo"()
    $P9249."finish_static_lexpad"()
    .const 'Sub' $P9250 = "406_1304456155.152" 
    $P9251 = $P9250."get_lexinfo"()
    nqp_get_sc_object $P9252, "1304456142.948", 377
    $P9251."set_static_lexpad_value"("$?CLASS", $P9252)
    .const 'Sub' $P9253 = "406_1304456155.152" 
    $P9254 = $P9253."get_lexinfo"()
    $P9254."finish_static_lexpad"()
    nqp_get_sc_object $P9255, "1304456142.948", 489
    .const 'Sub' $P9256 = "582_1304456155.152" 
    assign $P9255, $P9256
    nqp_get_sc_object $P9257, "1304456142.948", 490
    .const 'Sub' $P9258 = "583_1304456155.152" 
    assign $P9257, $P9258
    nqp_get_sc_object $P9259, "1304456142.948", 491
    .const 'Sub' $P9260 = "584_1304456155.152" 
    assign $P9259, $P9260
    nqp_get_sc_object $P9261, "1304456142.948", 492
    .const 'Sub' $P9262 = "585_1304456155.152" 
    assign $P9261, $P9262
    nqp_get_sc_object $P9263, "1304456142.948", 493
    .const 'Sub' $P9264 = "586_1304456155.152" 
    assign $P9263, $P9264
    nqp_get_sc_object $P9265, "1304456142.948", 494
    .const 'Sub' $P9266 = "587_1304456155.152" 
    assign $P9265, $P9266
    nqp_get_sc_object $P9267, "1304456142.948", 495
    .const 'Sub' $P9268 = "588_1304456155.152" 
    assign $P9267, $P9268
    .const 'Sub' $P9269 = "581_1304456155.152" 
    $P9270 = $P9269."get_lexinfo"()
    nqp_get_sc_object $P9271, "1304456142.948", 488
    $P9270."set_static_lexpad_value"("$?PACKAGE", $P9271)
    .const 'Sub' $P9272 = "581_1304456155.152" 
    $P9273 = $P9272."get_lexinfo"()
    $P9273."finish_static_lexpad"()
    .const 'Sub' $P9274 = "581_1304456155.152" 
    $P9275 = $P9274."get_lexinfo"()
    nqp_get_sc_object $P9276, "1304456142.948", 488
    $P9275."set_static_lexpad_value"("$?CLASS", $P9276)
    .const 'Sub' $P9277 = "581_1304456155.152" 
    $P9278 = $P9277."get_lexinfo"()
    $P9278."finish_static_lexpad"()
    .const 'Sub' $P9279 = "589_1304456155.152" 
    $P9280 = $P9279."get_lexinfo"()
    nqp_get_sc_object $P9281, "1304456142.948", 496
    $P9280."set_static_lexpad_value"("$?PACKAGE", $P9281)
    .const 'Sub' $P9282 = "589_1304456155.152" 
    $P9283 = $P9282."get_lexinfo"()
    $P9283."finish_static_lexpad"()
    .const 'Sub' $P9284 = "589_1304456155.152" 
    $P9285 = $P9284."get_lexinfo"()
    nqp_get_sc_object $P9286, "1304456142.948", 496
    $P9285."set_static_lexpad_value"("$?CLASS", $P9286)
    .const 'Sub' $P9287 = "589_1304456155.152" 
    $P9288 = $P9287."get_lexinfo"()
    $P9288."finish_static_lexpad"()
    goto if_6143_end
  if_6143:
    nqp_dynop_setup 
    getinterp $P6146
    get_class $P6147, "LexPad"
    get_class $P6148, "NQPLexPad"
    $P6146."hll_map"($P6147, $P6148)
    nqp_create_sc $P6149, "1304456142.948"
    .local pmc cur_sc
    set cur_sc, $P6149
    nqp_get_sc_object $P6150, "__6MODEL_CORE__", 0
    $P6151 = $P6150."new_type"("GLOBALish" :named("name"))
    nqp_set_sc_for_object $P6151, cur_sc
    nqp_set_sc_object "1304456142.948", 0, $P6151
    .const 'Sub' $P6152 = "10_1304456155.152" 
    $P6153 = $P6152."get_lexinfo"()
    nqp_get_sc_object $P6154, "1304456142.948", 0
    $P6153."set_static_lexpad_value"("GLOBALish", $P6154)
    .const 'Sub' $P6155 = "10_1304456155.152" 
    $P6156 = $P6155."get_lexinfo"()
    $P6156."finish_static_lexpad"()
    .const 'Sub' $P6157 = "10_1304456155.152" 
    $P6158 = $P6157."get_lexinfo"()
    nqp_get_sc_object $P6159, "1304456142.948", 0
    $P6158."set_static_lexpad_value"("$?PACKAGE", $P6159)
    .const 'Sub' $P6160 = "10_1304456155.152" 
    $P6161 = $P6160."get_lexinfo"()
    $P6161."finish_static_lexpad"()
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P6162, "ModuleLoader"
    $P6163 = $P6162."load_setting"("NQPCORE")
    block."set_outer_ctx"($P6163)
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P6164, "ModuleLoader"
    nqp_get_sc_object $P6165, "1304456142.948", 0
    $P6164."load_module"("Regex", $P6165)
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P6166, "ModuleLoader"
    nqp_get_sc_object $P6167, "1304456142.948", 0
    $P6166."load_module"("P6Regex", $P6167)
    nqp_get_sc_object $P6168, "1304456116.562", 41
    $P6169 = $P6168."new_type"("NQP::Grammar" :named("name"))
    nqp_set_sc_for_object $P6169, cur_sc
    nqp_set_sc_object "1304456142.948", 1, $P6169
    nqp_get_sc_object $P6170, "1304456142.948", 1
    nqp_get_sc_object $P6171, "1304456142.948", 0
    nqp_get_package_through_who $P6172, $P6171, "NQP"
    get_who $P6173, $P6172
    set $P6173["Grammar"], $P6170
    nqp_get_sc_object $P6174, "1304456142.948", 1
    get_how $P6175, $P6174
    nqp_get_sc_object $P6176, "1304456142.948", 1
    .const 'Sub' $P6177 = "13_1304456155.152" 
    $P6175."add_method"($P6176, "TOP", $P6177)
    nqp_get_sc_object $P6178, "1304456142.948", 1
    get_how $P6179, $P6178
    nqp_get_sc_object $P6180, "1304456142.948", 1
    .const 'Sub' $P6181 = "14_1304456155.152" 
    $P6179."add_method"($P6180, "identifier", $P6181)
    nqp_get_sc_object $P6182, "1304456142.948", 1
    get_how $P6183, $P6182
    nqp_get_sc_object $P6184, "1304456142.948", 1
    .const 'Sub' $P6185 = "15_1304456155.152" 
    $P6183."add_method"($P6184, "!PREFIX__identifier", $P6185)
    nqp_get_sc_object $P6186, "1304456142.948", 1
    get_how $P6187, $P6186
    nqp_get_sc_object $P6188, "1304456142.948", 1
    .const 'Sub' $P6189 = "16_1304456155.152" 
    $P6187."add_method"($P6188, "name", $P6189)
    nqp_get_sc_object $P6190, "1304456142.948", 1
    get_how $P6191, $P6190
    nqp_get_sc_object $P6192, "1304456142.948", 1
    .const 'Sub' $P6193 = "17_1304456155.152" 
    $P6191."add_method"($P6192, "!PREFIX__name", $P6193)
    nqp_get_sc_object $P6194, "1304456142.948", 1
    get_how $P6195, $P6194
    nqp_get_sc_object $P6196, "1304456142.948", 1
    .const 'Sub' $P6197 = "18_1304456155.152" 
    $P6195."add_method"($P6196, "deflongname", $P6197)
    nqp_get_sc_object $P6198, "1304456142.948", 1
    get_how $P6199, $P6198
    nqp_get_sc_object $P6200, "1304456142.948", 1
    .const 'Sub' $P6201 = "19_1304456155.152" 
    $P6199."add_method"($P6200, "!PREFIX__deflongname", $P6201)
    nqp_get_sc_object $P6202, "1304456142.948", 1
    get_how $P6203, $P6202
    nqp_get_sc_object $P6204, "1304456142.948", 1
    .const 'Sub' $P6205 = "20_1304456155.152" 
    $P6203."add_method"($P6204, "ENDSTMT", $P6205)
    nqp_get_sc_object $P6206, "1304456142.948", 1
    get_how $P6207, $P6206
    nqp_get_sc_object $P6208, "1304456142.948", 1
    .const 'Sub' $P6209 = "21_1304456155.152" 
    $P6207."add_method"($P6208, "!PREFIX__ENDSTMT", $P6209)
    nqp_get_sc_object $P6210, "1304456142.948", 1
    get_how $P6211, $P6210
    nqp_get_sc_object $P6212, "1304456142.948", 1
    .const 'Sub' $P6213 = "22_1304456155.152" 
    $P6211."add_method"($P6212, "ws", $P6213)
    nqp_get_sc_object $P6214, "1304456142.948", 1
    get_how $P6215, $P6214
    nqp_get_sc_object $P6216, "1304456142.948", 1
    .const 'Sub' $P6217 = "23_1304456155.152" 
    $P6215."add_method"($P6216, "!PREFIX__ws", $P6217)
    nqp_get_sc_object $P6218, "1304456142.948", 1
    get_how $P6219, $P6218
    nqp_get_sc_object $P6220, "1304456142.948", 1
    .const 'Sub' $P6221 = "24_1304456155.152" 
    $P6219."add_method"($P6220, "unv", $P6221)
    nqp_get_sc_object $P6222, "1304456142.948", 1
    get_how $P6223, $P6222
    nqp_get_sc_object $P6224, "1304456142.948", 1
    .const 'Sub' $P6225 = "26_1304456155.152" 
    $P6223."add_method"($P6224, "!PREFIX__unv", $P6225)
    nqp_get_sc_object $P6226, "1304456142.948", 1
    get_how $P6227, $P6226
    nqp_get_sc_object $P6228, "1304456142.948", 1
    .const 'Sub' $P6229 = "27_1304456155.152" 
    $P6227."add_method"($P6228, "pod_comment", $P6229)
    nqp_get_sc_object $P6230, "1304456142.948", 1
    get_how $P6231, $P6230
    nqp_get_sc_object $P6232, "1304456142.948", 1
    .const 'Sub' $P6233 = "29_1304456155.152" 
    $P6231."add_method"($P6232, "!PREFIX__pod_comment", $P6233)
    nqp_get_sc_object $P6234, "1304456142.948", 1
    get_how $P6235, $P6234
    nqp_get_sc_object $P6236, "1304456142.948", 1
    .const 'Sub' $P6237 = "30_1304456155.152" 
    $P6235."add_method"($P6236, "comp_unit", $P6237)
    nqp_get_sc_object $P6238, "1304456142.948", 1
    get_how $P6239, $P6238
    nqp_get_sc_object $P6240, "1304456142.948", 1
    .const 'Sub' $P6241 = "31_1304456155.152" 
    $P6239."add_method"($P6240, "!PREFIX__comp_unit", $P6241)
    nqp_get_sc_object $P6242, "1304456142.948", 1
    get_how $P6243, $P6242
    nqp_get_sc_object $P6244, "1304456142.948", 1
    .const 'Sub' $P6245 = "32_1304456155.152" 
    $P6243."add_method"($P6244, "statementlist", $P6245)
    nqp_get_sc_object $P6246, "1304456142.948", 1
    get_how $P6247, $P6246
    nqp_get_sc_object $P6248, "1304456142.948", 1
    .const 'Sub' $P6249 = "33_1304456155.152" 
    $P6247."add_method"($P6248, "!PREFIX__statementlist", $P6249)
    nqp_get_sc_object $P6250, "1304456142.948", 1
    get_how $P6251, $P6250
    nqp_get_sc_object $P6252, "1304456142.948", 1
    .const 'Sub' $P6253 = "34_1304456155.152" 
    $P6251."add_method"($P6252, "statement", $P6253)
    nqp_get_sc_object $P6254, "1304456142.948", 1
    get_how $P6255, $P6254
    nqp_get_sc_object $P6256, "1304456142.948", 1
    .const 'Sub' $P6257 = "36_1304456155.152" 
    $P6255."add_method"($P6256, "!PREFIX__statement", $P6257)
    nqp_get_sc_object $P6258, "1304456142.948", 1
    get_how $P6259, $P6258
    nqp_get_sc_object $P6260, "1304456142.948", 1
    .const 'Sub' $P6261 = "37_1304456155.152" 
    $P6259."add_method"($P6260, "eat_terminator", $P6261)
    nqp_get_sc_object $P6262, "1304456142.948", 1
    get_how $P6263, $P6262
    nqp_get_sc_object $P6264, "1304456142.948", 1
    .const 'Sub' $P6265 = "38_1304456155.152" 
    $P6263."add_method"($P6264, "!PREFIX__eat_terminator", $P6265)
    nqp_get_sc_object $P6266, "1304456142.948", 1
    get_how $P6267, $P6266
    nqp_get_sc_object $P6268, "1304456142.948", 1
    .const 'Sub' $P6269 = "39_1304456155.152" 
    $P6267."add_method"($P6268, "xblock", $P6269)
    nqp_get_sc_object $P6270, "1304456142.948", 1
    get_how $P6271, $P6270
    nqp_get_sc_object $P6272, "1304456142.948", 1
    .const 'Sub' $P6273 = "40_1304456155.152" 
    $P6271."add_method"($P6272, "!PREFIX__xblock", $P6273)
    nqp_get_sc_object $P6274, "1304456142.948", 1
    get_how $P6275, $P6274
    nqp_get_sc_object $P6276, "1304456142.948", 1
    .const 'Sub' $P6277 = "41_1304456155.152" 
    $P6275."add_method"($P6276, "pblock", $P6277)
    nqp_get_sc_object $P6278, "1304456142.948", 1
    get_how $P6279, $P6278
    nqp_get_sc_object $P6280, "1304456142.948", 1
    .const 'Sub' $P6281 = "42_1304456155.152" 
    $P6279."add_method"($P6280, "!PREFIX__pblock", $P6281)
    nqp_get_sc_object $P6282, "1304456142.948", 1
    get_how $P6283, $P6282
    nqp_get_sc_object $P6284, "1304456142.948", 1
    .const 'Sub' $P6285 = "43_1304456155.152" 
    $P6283."add_method"($P6284, "lambda", $P6285)
    nqp_get_sc_object $P6286, "1304456142.948", 1
    get_how $P6287, $P6286
    nqp_get_sc_object $P6288, "1304456142.948", 1
    .const 'Sub' $P6289 = "44_1304456155.152" 
    $P6287."add_method"($P6288, "!PREFIX__lambda", $P6289)
    nqp_get_sc_object $P6290, "1304456142.948", 1
    get_how $P6291, $P6290
    nqp_get_sc_object $P6292, "1304456142.948", 1
    .const 'Sub' $P6293 = "45_1304456155.152" 
    $P6291."add_method"($P6292, "block", $P6293)
    nqp_get_sc_object $P6294, "1304456142.948", 1
    get_how $P6295, $P6294
    nqp_get_sc_object $P6296, "1304456142.948", 1
    .const 'Sub' $P6297 = "46_1304456155.152" 
    $P6295."add_method"($P6296, "!PREFIX__block", $P6297)
    nqp_get_sc_object $P6298, "1304456142.948", 1
    get_how $P6299, $P6298
    nqp_get_sc_object $P6300, "1304456142.948", 1
    .const 'Sub' $P6301 = "47_1304456155.152" 
    $P6299."add_method"($P6300, "blockoid", $P6301)
    nqp_get_sc_object $P6302, "1304456142.948", 1
    get_how $P6303, $P6302
    nqp_get_sc_object $P6304, "1304456142.948", 1
    .const 'Sub' $P6305 = "48_1304456155.152" 
    $P6303."add_method"($P6304, "!PREFIX__blockoid", $P6305)
    nqp_get_sc_object $P6306, "1304456142.948", 1
    get_how $P6307, $P6306
    nqp_get_sc_object $P6308, "1304456142.948", 1
    .const 'Sub' $P6309 = "49_1304456155.152" 
    $P6307."add_method"($P6308, "newpad", $P6309)
    nqp_get_sc_object $P6310, "1304456142.948", 1
    get_how $P6311, $P6310
    nqp_get_sc_object $P6312, "1304456142.948", 1
    .const 'Sub' $P6313 = "50_1304456155.152" 
    $P6311."add_method"($P6312, "!PREFIX__newpad", $P6313)
    nqp_get_sc_object $P6314, "1304456142.948", 1
    get_how $P6315, $P6314
    nqp_get_sc_object $P6316, "1304456142.948", 1
    .const 'Sub' $P6317 = "51_1304456155.152" 
    $P6315."add_method"($P6316, "outerctx", $P6317)
    nqp_get_sc_object $P6318, "1304456142.948", 1
    get_how $P6319, $P6318
    nqp_get_sc_object $P6320, "1304456142.948", 1
    .const 'Sub' $P6321 = "52_1304456155.152" 
    $P6319."add_method"($P6320, "!PREFIX__outerctx", $P6321)
    nqp_get_sc_object $P6322, "1304456142.948", 1
    get_how $P6323, $P6322
    nqp_get_sc_object $P6324, "1304456142.948", 1
    .const 'Sub' $P6325 = "53_1304456155.152" 
    $P6323."add_method"($P6324, "GLOBALish", $P6325)
    nqp_get_sc_object $P6326, "1304456142.948", 1
    get_how $P6327, $P6326
    nqp_get_sc_object $P6328, "1304456142.948", 1
    .const 'Sub' $P6329 = "54_1304456155.152" 
    $P6327."add_method"($P6328, "!PREFIX__GLOBALish", $P6329)
    nqp_get_sc_object $P6330, "1304456142.948", 1
    get_how $P6331, $P6330
    nqp_get_sc_object $P6332, "1304456142.948", 1
    .const 'Sub' $P6333 = "55_1304456155.152" 
    $P6331."add_method"($P6332, "finishpad", $P6333)
    nqp_get_sc_object $P6334, "1304456142.948", 1
    get_how $P6335, $P6334
    nqp_get_sc_object $P6336, "1304456142.948", 1
    .const 'Sub' $P6337 = "56_1304456155.152" 
    $P6335."add_method"($P6336, "!PREFIX__finishpad", $P6337)
    nqp_get_sc_object $P6338, "1304456142.948", 1
    get_how $P6339, $P6338
    nqp_get_sc_object $P6340, "1304456142.948", 1
    .const 'Sub' $P6341 = "57_1304456155.152" 
    $P6339."add_method"($P6340, "you_are_here", $P6341)
    nqp_get_sc_object $P6342, "1304456142.948", 1
    get_how $P6343, $P6342
    nqp_get_sc_object $P6344, "1304456142.948", 1
    .const 'Sub' $P6345 = "58_1304456155.152" 
    $P6343."add_method"($P6344, "!PREFIX__you_are_here", $P6345)
    nqp_get_sc_object $P6346, "1304456142.948", 1
    get_how $P6347, $P6346
    nqp_get_sc_object $P6348, "1304456142.948", 1
    .const 'Sub' $P6349 = "59_1304456155.152" 
    $P6347."add_method"($P6348, "terminator", $P6349)
    nqp_get_sc_object $P6350, "1304456142.948", 1
    get_how $P6351, $P6350
    nqp_get_sc_object $P6352, "1304456142.948", 1
    .const 'Sub' $P6353 = "60_1304456155.152" 
    $P6351."add_method"($P6352, "!PREFIX__terminator", $P6353)
    nqp_get_sc_object $P6354, "1304456142.948", 1
    get_how $P6355, $P6354
    nqp_get_sc_object $P6356, "1304456142.948", 1
    .const 'Sub' $P6357 = "61_1304456155.152" 
    $P6355."add_method"($P6356, "terminator:sym<;>", $P6357)
    nqp_get_sc_object $P6358, "1304456142.948", 1
    get_how $P6359, $P6358
    nqp_get_sc_object $P6360, "1304456142.948", 1
    .const 'Sub' $P6361 = "62_1304456155.152" 
    $P6359."add_method"($P6360, "!PREFIX__terminator:sym<;>", $P6361)
    nqp_get_sc_object $P6362, "1304456142.948", 1
    get_how $P6363, $P6362
    nqp_get_sc_object $P6364, "1304456142.948", 1
    .const 'Sub' $P6365 = "63_1304456155.152" 
    $P6363."add_method"($P6364, "terminator:sym<}>", $P6365)
    nqp_get_sc_object $P6366, "1304456142.948", 1
    get_how $P6367, $P6366
    nqp_get_sc_object $P6368, "1304456142.948", 1
    .const 'Sub' $P6369 = "64_1304456155.152" 
    $P6367."add_method"($P6368, "!PREFIX__terminator:sym<}>", $P6369)
    nqp_get_sc_object $P6370, "1304456142.948", 1
    get_how $P6371, $P6370
    nqp_get_sc_object $P6372, "1304456142.948", 1
    .const 'Sub' $P6373 = "65_1304456155.152" 
    $P6371."add_method"($P6372, "statement_control", $P6373)
    nqp_get_sc_object $P6374, "1304456142.948", 1
    get_how $P6375, $P6374
    nqp_get_sc_object $P6376, "1304456142.948", 1
    .const 'Sub' $P6377 = "66_1304456155.152" 
    $P6375."add_method"($P6376, "!PREFIX__statement_control", $P6377)
    nqp_get_sc_object $P6378, "1304456142.948", 1
    get_how $P6379, $P6378
    nqp_get_sc_object $P6380, "1304456142.948", 1
    .const 'Sub' $P6381 = "67_1304456155.152" 
    $P6379."add_method"($P6380, "statement_control:sym<use>", $P6381)
    nqp_get_sc_object $P6382, "1304456142.948", 1
    get_how $P6383, $P6382
    nqp_get_sc_object $P6384, "1304456142.948", 1
    .const 'Sub' $P6385 = "68_1304456155.152" 
    $P6383."add_method"($P6384, "!PREFIX__statement_control:sym<use>", $P6385)
    nqp_get_sc_object $P6386, "1304456142.948", 1
    get_how $P6387, $P6386
    nqp_get_sc_object $P6388, "1304456142.948", 1
    .const 'Sub' $P6389 = "69_1304456155.152" 
    $P6387."add_method"($P6388, "statement_control:sym<if>", $P6389)
    nqp_get_sc_object $P6390, "1304456142.948", 1
    get_how $P6391, $P6390
    nqp_get_sc_object $P6392, "1304456142.948", 1
    .const 'Sub' $P6393 = "70_1304456155.152" 
    $P6391."add_method"($P6392, "!PREFIX__statement_control:sym<if>", $P6393)
    nqp_get_sc_object $P6394, "1304456142.948", 1
    get_how $P6395, $P6394
    nqp_get_sc_object $P6396, "1304456142.948", 1
    .const 'Sub' $P6397 = "71_1304456155.152" 
    $P6395."add_method"($P6396, "statement_control:sym<unless>", $P6397)
    nqp_get_sc_object $P6398, "1304456142.948", 1
    get_how $P6399, $P6398
    nqp_get_sc_object $P6400, "1304456142.948", 1
    .const 'Sub' $P6401 = "73_1304456155.152" 
    $P6399."add_method"($P6400, "!PREFIX__statement_control:sym<unless>", $P6401)
    nqp_get_sc_object $P6402, "1304456142.948", 1
    get_how $P6403, $P6402
    nqp_get_sc_object $P6404, "1304456142.948", 1
    .const 'Sub' $P6405 = "74_1304456155.152" 
    $P6403."add_method"($P6404, "statement_control:sym<while>", $P6405)
    nqp_get_sc_object $P6406, "1304456142.948", 1
    get_how $P6407, $P6406
    nqp_get_sc_object $P6408, "1304456142.948", 1
    .const 'Sub' $P6409 = "75_1304456155.152" 
    $P6407."add_method"($P6408, "!PREFIX__statement_control:sym<while>", $P6409)
    nqp_get_sc_object $P6410, "1304456142.948", 1
    get_how $P6411, $P6410
    nqp_get_sc_object $P6412, "1304456142.948", 1
    .const 'Sub' $P6413 = "76_1304456155.152" 
    $P6411."add_method"($P6412, "statement_control:sym<repeat>", $P6413)
    nqp_get_sc_object $P6414, "1304456142.948", 1
    get_how $P6415, $P6414
    nqp_get_sc_object $P6416, "1304456142.948", 1
    .const 'Sub' $P6417 = "77_1304456155.152" 
    $P6415."add_method"($P6416, "!PREFIX__statement_control:sym<repeat>", $P6417)
    nqp_get_sc_object $P6418, "1304456142.948", 1
    get_how $P6419, $P6418
    nqp_get_sc_object $P6420, "1304456142.948", 1
    .const 'Sub' $P6421 = "78_1304456155.152" 
    $P6419."add_method"($P6420, "statement_control:sym<for>", $P6421)
    nqp_get_sc_object $P6422, "1304456142.948", 1
    get_how $P6423, $P6422
    nqp_get_sc_object $P6424, "1304456142.948", 1
    .const 'Sub' $P6425 = "79_1304456155.152" 
    $P6423."add_method"($P6424, "!PREFIX__statement_control:sym<for>", $P6425)
    nqp_get_sc_object $P6426, "1304456142.948", 1
    get_how $P6427, $P6426
    nqp_get_sc_object $P6428, "1304456142.948", 1
    .const 'Sub' $P6429 = "80_1304456155.152" 
    $P6427."add_method"($P6428, "statement_control:sym<CATCH>", $P6429)
    nqp_get_sc_object $P6430, "1304456142.948", 1
    get_how $P6431, $P6430
    nqp_get_sc_object $P6432, "1304456142.948", 1
    .const 'Sub' $P6433 = "81_1304456155.152" 
    $P6431."add_method"($P6432, "!PREFIX__statement_control:sym<CATCH>", $P6433)
    nqp_get_sc_object $P6434, "1304456142.948", 1
    get_how $P6435, $P6434
    nqp_get_sc_object $P6436, "1304456142.948", 1
    .const 'Sub' $P6437 = "82_1304456155.152" 
    $P6435."add_method"($P6436, "statement_control:sym<CONTROL>", $P6437)
    nqp_get_sc_object $P6438, "1304456142.948", 1
    get_how $P6439, $P6438
    nqp_get_sc_object $P6440, "1304456142.948", 1
    .const 'Sub' $P6441 = "83_1304456155.152" 
    $P6439."add_method"($P6440, "!PREFIX__statement_control:sym<CONTROL>", $P6441)
    nqp_get_sc_object $P6442, "1304456142.948", 1
    get_how $P6443, $P6442
    nqp_get_sc_object $P6444, "1304456142.948", 1
    .const 'Sub' $P6445 = "84_1304456155.152" 
    $P6443."add_method"($P6444, "statement_prefix", $P6445)
    nqp_get_sc_object $P6446, "1304456142.948", 1
    get_how $P6447, $P6446
    nqp_get_sc_object $P6448, "1304456142.948", 1
    .const 'Sub' $P6449 = "85_1304456155.152" 
    $P6447."add_method"($P6448, "!PREFIX__statement_prefix", $P6449)
    nqp_get_sc_object $P6450, "1304456142.948", 1
    get_how $P6451, $P6450
    nqp_get_sc_object $P6452, "1304456142.948", 1
    .const 'Sub' $P6453 = "86_1304456155.152" 
    $P6451."add_method"($P6452, "statement_prefix:sym<INIT>", $P6453)
    nqp_get_sc_object $P6454, "1304456142.948", 1
    get_how $P6455, $P6454
    nqp_get_sc_object $P6456, "1304456142.948", 1
    .const 'Sub' $P6457 = "87_1304456155.152" 
    $P6455."add_method"($P6456, "!PREFIX__statement_prefix:sym<INIT>", $P6457)
    nqp_get_sc_object $P6458, "1304456142.948", 1
    get_how $P6459, $P6458
    nqp_get_sc_object $P6460, "1304456142.948", 1
    .const 'Sub' $P6461 = "88_1304456155.152" 
    $P6459."add_method"($P6460, "statement_prefix:sym<try>", $P6461)
    nqp_get_sc_object $P6462, "1304456142.948", 1
    get_how $P6463, $P6462
    nqp_get_sc_object $P6464, "1304456142.948", 1
    .const 'Sub' $P6465 = "89_1304456155.152" 
    $P6463."add_method"($P6464, "!PREFIX__statement_prefix:sym<try>", $P6465)
    nqp_get_sc_object $P6466, "1304456142.948", 1
    get_how $P6467, $P6466
    nqp_get_sc_object $P6468, "1304456142.948", 1
    .const 'Sub' $P6469 = "90_1304456155.152" 
    $P6467."add_method"($P6468, "blorst", $P6469)
    nqp_get_sc_object $P6470, "1304456142.948", 1
    get_how $P6471, $P6470
    nqp_get_sc_object $P6472, "1304456142.948", 1
    .const 'Sub' $P6473 = "91_1304456155.152" 
    $P6471."add_method"($P6472, "!PREFIX__blorst", $P6473)
    nqp_get_sc_object $P6474, "1304456142.948", 1
    get_how $P6475, $P6474
    nqp_get_sc_object $P6476, "1304456142.948", 1
    .const 'Sub' $P6477 = "92_1304456155.152" 
    $P6475."add_method"($P6476, "statement_mod_cond", $P6477)
    nqp_get_sc_object $P6478, "1304456142.948", 1
    get_how $P6479, $P6478
    nqp_get_sc_object $P6480, "1304456142.948", 1
    .const 'Sub' $P6481 = "93_1304456155.152" 
    $P6479."add_method"($P6480, "!PREFIX__statement_mod_cond", $P6481)
    nqp_get_sc_object $P6482, "1304456142.948", 1
    get_how $P6483, $P6482
    nqp_get_sc_object $P6484, "1304456142.948", 1
    .const 'Sub' $P6485 = "94_1304456155.152" 
    $P6483."add_method"($P6484, "statement_mod_cond:sym<if>", $P6485)
    nqp_get_sc_object $P6486, "1304456142.948", 1
    get_how $P6487, $P6486
    nqp_get_sc_object $P6488, "1304456142.948", 1
    .const 'Sub' $P6489 = "95_1304456155.152" 
    $P6487."add_method"($P6488, "!PREFIX__statement_mod_cond:sym<if>", $P6489)
    nqp_get_sc_object $P6490, "1304456142.948", 1
    get_how $P6491, $P6490
    nqp_get_sc_object $P6492, "1304456142.948", 1
    .const 'Sub' $P6493 = "96_1304456155.152" 
    $P6491."add_method"($P6492, "statement_mod_cond:sym<unless>", $P6493)
    nqp_get_sc_object $P6494, "1304456142.948", 1
    get_how $P6495, $P6494
    nqp_get_sc_object $P6496, "1304456142.948", 1
    .const 'Sub' $P6497 = "97_1304456155.152" 
    $P6495."add_method"($P6496, "!PREFIX__statement_mod_cond:sym<unless>", $P6497)
    nqp_get_sc_object $P6498, "1304456142.948", 1
    get_how $P6499, $P6498
    nqp_get_sc_object $P6500, "1304456142.948", 1
    .const 'Sub' $P6501 = "98_1304456155.152" 
    $P6499."add_method"($P6500, "statement_mod_loop", $P6501)
    nqp_get_sc_object $P6502, "1304456142.948", 1
    get_how $P6503, $P6502
    nqp_get_sc_object $P6504, "1304456142.948", 1
    .const 'Sub' $P6505 = "99_1304456155.152" 
    $P6503."add_method"($P6504, "!PREFIX__statement_mod_loop", $P6505)
    nqp_get_sc_object $P6506, "1304456142.948", 1
    get_how $P6507, $P6506
    nqp_get_sc_object $P6508, "1304456142.948", 1
    .const 'Sub' $P6509 = "100_1304456155.152" 
    $P6507."add_method"($P6508, "statement_mod_loop:sym<while>", $P6509)
    nqp_get_sc_object $P6510, "1304456142.948", 1
    get_how $P6511, $P6510
    nqp_get_sc_object $P6512, "1304456142.948", 1
    .const 'Sub' $P6513 = "101_1304456155.152" 
    $P6511."add_method"($P6512, "!PREFIX__statement_mod_loop:sym<while>", $P6513)
    nqp_get_sc_object $P6514, "1304456142.948", 1
    get_how $P6515, $P6514
    nqp_get_sc_object $P6516, "1304456142.948", 1
    .const 'Sub' $P6517 = "102_1304456155.152" 
    $P6515."add_method"($P6516, "statement_mod_loop:sym<until>", $P6517)
    nqp_get_sc_object $P6518, "1304456142.948", 1
    get_how $P6519, $P6518
    nqp_get_sc_object $P6520, "1304456142.948", 1
    .const 'Sub' $P6521 = "103_1304456155.152" 
    $P6519."add_method"($P6520, "!PREFIX__statement_mod_loop:sym<until>", $P6521)
    nqp_get_sc_object $P6522, "1304456142.948", 1
    get_how $P6523, $P6522
    nqp_get_sc_object $P6524, "1304456142.948", 1
    .const 'Sub' $P6525 = "104_1304456155.152" 
    $P6523."add_method"($P6524, "statement_mod_loop:sym<for>", $P6525)
    nqp_get_sc_object $P6526, "1304456142.948", 1
    get_how $P6527, $P6526
    nqp_get_sc_object $P6528, "1304456142.948", 1
    .const 'Sub' $P6529 = "105_1304456155.152" 
    $P6527."add_method"($P6528, "!PREFIX__statement_mod_loop:sym<for>", $P6529)
    nqp_get_sc_object $P6530, "1304456142.948", 1
    get_how $P6531, $P6530
    nqp_get_sc_object $P6532, "1304456142.948", 1
    .const 'Sub' $P6533 = "106_1304456155.152" 
    $P6531."add_method"($P6532, "term:sym<fatarrow>", $P6533)
    nqp_get_sc_object $P6534, "1304456142.948", 1
    get_how $P6535, $P6534
    nqp_get_sc_object $P6536, "1304456142.948", 1
    .const 'Sub' $P6537 = "107_1304456155.152" 
    $P6535."add_method"($P6536, "!PREFIX__term:sym<fatarrow>", $P6537)
    nqp_get_sc_object $P6538, "1304456142.948", 1
    get_how $P6539, $P6538
    nqp_get_sc_object $P6540, "1304456142.948", 1
    .const 'Sub' $P6541 = "108_1304456155.152" 
    $P6539."add_method"($P6540, "term:sym<colonpair>", $P6541)
    nqp_get_sc_object $P6542, "1304456142.948", 1
    get_how $P6543, $P6542
    nqp_get_sc_object $P6544, "1304456142.948", 1
    .const 'Sub' $P6545 = "109_1304456155.152" 
    $P6543."add_method"($P6544, "!PREFIX__term:sym<colonpair>", $P6545)
    nqp_get_sc_object $P6546, "1304456142.948", 1
    get_how $P6547, $P6546
    nqp_get_sc_object $P6548, "1304456142.948", 1
    .const 'Sub' $P6549 = "110_1304456155.152" 
    $P6547."add_method"($P6548, "term:sym<variable>", $P6549)
    nqp_get_sc_object $P6550, "1304456142.948", 1
    get_how $P6551, $P6550
    nqp_get_sc_object $P6552, "1304456142.948", 1
    .const 'Sub' $P6553 = "111_1304456155.152" 
    $P6551."add_method"($P6552, "!PREFIX__term:sym<variable>", $P6553)
    nqp_get_sc_object $P6554, "1304456142.948", 1
    get_how $P6555, $P6554
    nqp_get_sc_object $P6556, "1304456142.948", 1
    .const 'Sub' $P6557 = "112_1304456155.152" 
    $P6555."add_method"($P6556, "term:sym<package_declarator>", $P6557)
    nqp_get_sc_object $P6558, "1304456142.948", 1
    get_how $P6559, $P6558
    nqp_get_sc_object $P6560, "1304456142.948", 1
    .const 'Sub' $P6561 = "113_1304456155.152" 
    $P6559."add_method"($P6560, "!PREFIX__term:sym<package_declarator>", $P6561)
    nqp_get_sc_object $P6562, "1304456142.948", 1
    get_how $P6563, $P6562
    nqp_get_sc_object $P6564, "1304456142.948", 1
    .const 'Sub' $P6565 = "114_1304456155.152" 
    $P6563."add_method"($P6564, "term:sym<scope_declarator>", $P6565)
    nqp_get_sc_object $P6566, "1304456142.948", 1
    get_how $P6567, $P6566
    nqp_get_sc_object $P6568, "1304456142.948", 1
    .const 'Sub' $P6569 = "115_1304456155.152" 
    $P6567."add_method"($P6568, "!PREFIX__term:sym<scope_declarator>", $P6569)
    nqp_get_sc_object $P6570, "1304456142.948", 1
    get_how $P6571, $P6570
    nqp_get_sc_object $P6572, "1304456142.948", 1
    .const 'Sub' $P6573 = "116_1304456155.152" 
    $P6571."add_method"($P6572, "term:sym<routine_declarator>", $P6573)
    nqp_get_sc_object $P6574, "1304456142.948", 1
    get_how $P6575, $P6574
    nqp_get_sc_object $P6576, "1304456142.948", 1
    .const 'Sub' $P6577 = "117_1304456155.152" 
    $P6575."add_method"($P6576, "!PREFIX__term:sym<routine_declarator>", $P6577)
    nqp_get_sc_object $P6578, "1304456142.948", 1
    get_how $P6579, $P6578
    nqp_get_sc_object $P6580, "1304456142.948", 1
    .const 'Sub' $P6581 = "118_1304456155.152" 
    $P6579."add_method"($P6580, "term:sym<multi_declarator>", $P6581)
    nqp_get_sc_object $P6582, "1304456142.948", 1
    get_how $P6583, $P6582
    nqp_get_sc_object $P6584, "1304456142.948", 1
    .const 'Sub' $P6585 = "121_1304456155.152" 
    $P6583."add_method"($P6584, "!PREFIX__term:sym<multi_declarator>", $P6585)
    nqp_get_sc_object $P6586, "1304456142.948", 1
    get_how $P6587, $P6586
    nqp_get_sc_object $P6588, "1304456142.948", 1
    .const 'Sub' $P6589 = "122_1304456155.152" 
    $P6587."add_method"($P6588, "term:sym<regex_declarator>", $P6589)
    nqp_get_sc_object $P6590, "1304456142.948", 1
    get_how $P6591, $P6590
    nqp_get_sc_object $P6592, "1304456142.948", 1
    .const 'Sub' $P6593 = "123_1304456155.152" 
    $P6591."add_method"($P6592, "!PREFIX__term:sym<regex_declarator>", $P6593)
    nqp_get_sc_object $P6594, "1304456142.948", 1
    get_how $P6595, $P6594
    nqp_get_sc_object $P6596, "1304456142.948", 1
    .const 'Sub' $P6597 = "124_1304456155.152" 
    $P6595."add_method"($P6596, "term:sym<statement_prefix>", $P6597)
    nqp_get_sc_object $P6598, "1304456142.948", 1
    get_how $P6599, $P6598
    nqp_get_sc_object $P6600, "1304456142.948", 1
    .const 'Sub' $P6601 = "125_1304456155.152" 
    $P6599."add_method"($P6600, "!PREFIX__term:sym<statement_prefix>", $P6601)
    nqp_get_sc_object $P6602, "1304456142.948", 1
    get_how $P6603, $P6602
    nqp_get_sc_object $P6604, "1304456142.948", 1
    .const 'Sub' $P6605 = "126_1304456155.152" 
    $P6603."add_method"($P6604, "term:sym<lambda>", $P6605)
    nqp_get_sc_object $P6606, "1304456142.948", 1
    get_how $P6607, $P6606
    nqp_get_sc_object $P6608, "1304456142.948", 1
    .const 'Sub' $P6609 = "127_1304456155.152" 
    $P6607."add_method"($P6608, "!PREFIX__term:sym<lambda>", $P6609)
    nqp_get_sc_object $P6610, "1304456142.948", 1
    get_how $P6611, $P6610
    nqp_get_sc_object $P6612, "1304456142.948", 1
    .const 'Sub' $P6613 = "128_1304456155.152" 
    $P6611."add_method"($P6612, "fatarrow", $P6613)
    nqp_get_sc_object $P6614, "1304456142.948", 1
    get_how $P6615, $P6614
    nqp_get_sc_object $P6616, "1304456142.948", 1
    .const 'Sub' $P6617 = "129_1304456155.152" 
    $P6615."add_method"($P6616, "!PREFIX__fatarrow", $P6617)
    nqp_get_sc_object $P6618, "1304456142.948", 1
    get_how $P6619, $P6618
    nqp_get_sc_object $P6620, "1304456142.948", 1
    .const 'Sub' $P6621 = "130_1304456155.152" 
    $P6619."add_method"($P6620, "colonpair", $P6621)
    nqp_get_sc_object $P6622, "1304456142.948", 1
    get_how $P6623, $P6622
    nqp_get_sc_object $P6624, "1304456142.948", 1
    .const 'Sub' $P6625 = "131_1304456155.152" 
    $P6623."add_method"($P6624, "!PREFIX__colonpair", $P6625)
    nqp_get_sc_object $P6626, "1304456142.948", 1
    get_how $P6627, $P6626
    nqp_get_sc_object $P6628, "1304456142.948", 1
    .const 'Sub' $P6629 = "132_1304456155.152" 
    $P6627."add_method"($P6628, "variable", $P6629)
    nqp_get_sc_object $P6630, "1304456142.948", 1
    get_how $P6631, $P6630
    nqp_get_sc_object $P6632, "1304456142.948", 1
    .const 'Sub' $P6633 = "133_1304456155.152" 
    $P6631."add_method"($P6632, "!PREFIX__variable", $P6633)
    nqp_get_sc_object $P6634, "1304456142.948", 1
    get_how $P6635, $P6634
    nqp_get_sc_object $P6636, "1304456142.948", 1
    .const 'Sub' $P6637 = "134_1304456155.152" 
    $P6635."add_method"($P6636, "sigil", $P6637)
    nqp_get_sc_object $P6638, "1304456142.948", 1
    get_how $P6639, $P6638
    nqp_get_sc_object $P6640, "1304456142.948", 1
    .const 'Sub' $P6641 = "135_1304456155.152" 
    $P6639."add_method"($P6640, "!PREFIX__sigil", $P6641)
    nqp_get_sc_object $P6642, "1304456142.948", 1
    get_how $P6643, $P6642
    nqp_get_sc_object $P6644, "1304456142.948", 1
    .const 'Sub' $P6645 = "136_1304456155.152" 
    $P6643."add_method"($P6644, "twigil", $P6645)
    nqp_get_sc_object $P6646, "1304456142.948", 1
    get_how $P6647, $P6646
    nqp_get_sc_object $P6648, "1304456142.948", 1
    .const 'Sub' $P6649 = "137_1304456155.152" 
    $P6647."add_method"($P6648, "!PREFIX__twigil", $P6649)
    nqp_get_sc_object $P6650, "1304456142.948", 1
    get_how $P6651, $P6650
    nqp_get_sc_object $P6652, "1304456142.948", 1
    .const 'Sub' $P6653 = "138_1304456155.152" 
    $P6651."add_method"($P6652, "package_declarator", $P6653)
    nqp_get_sc_object $P6654, "1304456142.948", 1
    get_how $P6655, $P6654
    nqp_get_sc_object $P6656, "1304456142.948", 1
    .const 'Sub' $P6657 = "139_1304456155.152" 
    $P6655."add_method"($P6656, "!PREFIX__package_declarator", $P6657)
    nqp_get_sc_object $P6658, "1304456142.948", 1
    get_how $P6659, $P6658
    nqp_get_sc_object $P6660, "1304456142.948", 1
    .const 'Sub' $P6661 = "140_1304456155.152" 
    $P6659."add_method"($P6660, "package_declarator:sym<module>", $P6661)
    nqp_get_sc_object $P6662, "1304456142.948", 1
    get_how $P6663, $P6662
    nqp_get_sc_object $P6664, "1304456142.948", 1
    .const 'Sub' $P6665 = "141_1304456155.152" 
    $P6663."add_method"($P6664, "!PREFIX__package_declarator:sym<module>", $P6665)
    nqp_get_sc_object $P6666, "1304456142.948", 1
    get_how $P6667, $P6666
    nqp_get_sc_object $P6668, "1304456142.948", 1
    .const 'Sub' $P6669 = "142_1304456155.152" 
    $P6667."add_method"($P6668, "package_declarator:sym<knowhow>", $P6669)
    nqp_get_sc_object $P6670, "1304456142.948", 1
    get_how $P6671, $P6670
    nqp_get_sc_object $P6672, "1304456142.948", 1
    .const 'Sub' $P6673 = "143_1304456155.152" 
    $P6671."add_method"($P6672, "!PREFIX__package_declarator:sym<knowhow>", $P6673)
    nqp_get_sc_object $P6674, "1304456142.948", 1
    get_how $P6675, $P6674
    nqp_get_sc_object $P6676, "1304456142.948", 1
    .const 'Sub' $P6677 = "144_1304456155.152" 
    $P6675."add_method"($P6676, "package_declarator:sym<class>", $P6677)
    nqp_get_sc_object $P6678, "1304456142.948", 1
    get_how $P6679, $P6678
    nqp_get_sc_object $P6680, "1304456142.948", 1
    .const 'Sub' $P6681 = "145_1304456155.152" 
    $P6679."add_method"($P6680, "!PREFIX__package_declarator:sym<class>", $P6681)
    nqp_get_sc_object $P6682, "1304456142.948", 1
    get_how $P6683, $P6682
    nqp_get_sc_object $P6684, "1304456142.948", 1
    .const 'Sub' $P6685 = "146_1304456155.152" 
    $P6683."add_method"($P6684, "package_declarator:sym<grammar>", $P6685)
    nqp_get_sc_object $P6686, "1304456142.948", 1
    get_how $P6687, $P6686
    nqp_get_sc_object $P6688, "1304456142.948", 1
    .const 'Sub' $P6689 = "147_1304456155.152" 
    $P6687."add_method"($P6688, "!PREFIX__package_declarator:sym<grammar>", $P6689)
    nqp_get_sc_object $P6690, "1304456142.948", 1
    get_how $P6691, $P6690
    nqp_get_sc_object $P6692, "1304456142.948", 1
    .const 'Sub' $P6693 = "148_1304456155.152" 
    $P6691."add_method"($P6692, "package_declarator:sym<role>", $P6693)
    nqp_get_sc_object $P6694, "1304456142.948", 1
    get_how $P6695, $P6694
    nqp_get_sc_object $P6696, "1304456142.948", 1
    .const 'Sub' $P6697 = "149_1304456155.152" 
    $P6695."add_method"($P6696, "!PREFIX__package_declarator:sym<role>", $P6697)
    nqp_get_sc_object $P6698, "1304456142.948", 1
    get_how $P6699, $P6698
    nqp_get_sc_object $P6700, "1304456142.948", 1
    .const 'Sub' $P6701 = "150_1304456155.152" 
    $P6699."add_method"($P6700, "package_declarator:sym<native>", $P6701)
    nqp_get_sc_object $P6702, "1304456142.948", 1
    get_how $P6703, $P6702
    nqp_get_sc_object $P6704, "1304456142.948", 1
    .const 'Sub' $P6705 = "151_1304456155.152" 
    $P6703."add_method"($P6704, "!PREFIX__package_declarator:sym<native>", $P6705)
    nqp_get_sc_object $P6706, "1304456142.948", 1
    get_how $P6707, $P6706
    nqp_get_sc_object $P6708, "1304456142.948", 1
    .const 'Sub' $P6709 = "152_1304456155.152" 
    $P6707."add_method"($P6708, "package_def", $P6709)
    nqp_get_sc_object $P6710, "1304456142.948", 1
    get_how $P6711, $P6710
    nqp_get_sc_object $P6712, "1304456142.948", 1
    .const 'Sub' $P6713 = "154_1304456155.152" 
    $P6711."add_method"($P6712, "!PREFIX__package_def", $P6713)
    nqp_get_sc_object $P6714, "1304456142.948", 1
    get_how $P6715, $P6714
    nqp_get_sc_object $P6716, "1304456142.948", 1
    .const 'Sub' $P6717 = "155_1304456155.152" 
    $P6715."add_method"($P6716, "scope_declarator", $P6717)
    nqp_get_sc_object $P6718, "1304456142.948", 1
    get_how $P6719, $P6718
    nqp_get_sc_object $P6720, "1304456142.948", 1
    .const 'Sub' $P6721 = "156_1304456155.152" 
    $P6719."add_method"($P6720, "!PREFIX__scope_declarator", $P6721)
    nqp_get_sc_object $P6722, "1304456142.948", 1
    get_how $P6723, $P6722
    nqp_get_sc_object $P6724, "1304456142.948", 1
    .const 'Sub' $P6725 = "157_1304456155.152" 
    $P6723."add_method"($P6724, "scope_declarator:sym<my>", $P6725)
    nqp_get_sc_object $P6726, "1304456142.948", 1
    get_how $P6727, $P6726
    nqp_get_sc_object $P6728, "1304456142.948", 1
    .const 'Sub' $P6729 = "158_1304456155.152" 
    $P6727."add_method"($P6728, "!PREFIX__scope_declarator:sym<my>", $P6729)
    nqp_get_sc_object $P6730, "1304456142.948", 1
    get_how $P6731, $P6730
    nqp_get_sc_object $P6732, "1304456142.948", 1
    .const 'Sub' $P6733 = "159_1304456155.152" 
    $P6731."add_method"($P6732, "scope_declarator:sym<our>", $P6733)
    nqp_get_sc_object $P6734, "1304456142.948", 1
    get_how $P6735, $P6734
    nqp_get_sc_object $P6736, "1304456142.948", 1
    .const 'Sub' $P6737 = "160_1304456155.152" 
    $P6735."add_method"($P6736, "!PREFIX__scope_declarator:sym<our>", $P6737)
    nqp_get_sc_object $P6738, "1304456142.948", 1
    get_how $P6739, $P6738
    nqp_get_sc_object $P6740, "1304456142.948", 1
    .const 'Sub' $P6741 = "161_1304456155.152" 
    $P6739."add_method"($P6740, "scope_declarator:sym<has>", $P6741)
    nqp_get_sc_object $P6742, "1304456142.948", 1
    get_how $P6743, $P6742
    nqp_get_sc_object $P6744, "1304456142.948", 1
    .const 'Sub' $P6745 = "162_1304456155.152" 
    $P6743."add_method"($P6744, "!PREFIX__scope_declarator:sym<has>", $P6745)
    nqp_get_sc_object $P6746, "1304456142.948", 1
    get_how $P6747, $P6746
    nqp_get_sc_object $P6748, "1304456142.948", 1
    .const 'Sub' $P6749 = "163_1304456155.152" 
    $P6747."add_method"($P6748, "scoped", $P6749)
    nqp_get_sc_object $P6750, "1304456142.948", 1
    get_how $P6751, $P6750
    nqp_get_sc_object $P6752, "1304456142.948", 1
    .const 'Sub' $P6753 = "164_1304456155.152" 
    $P6751."add_method"($P6752, "!PREFIX__scoped", $P6753)
    nqp_get_sc_object $P6754, "1304456142.948", 1
    get_how $P6755, $P6754
    nqp_get_sc_object $P6756, "1304456142.948", 1
    .const 'Sub' $P6757 = "165_1304456155.152" 
    $P6755."add_method"($P6756, "typename", $P6757)
    nqp_get_sc_object $P6758, "1304456142.948", 1
    get_how $P6759, $P6758
    nqp_get_sc_object $P6760, "1304456142.948", 1
    .const 'Sub' $P6761 = "167_1304456155.152" 
    $P6759."add_method"($P6760, "!PREFIX__typename", $P6761)
    nqp_get_sc_object $P6762, "1304456142.948", 1
    get_how $P6763, $P6762
    nqp_get_sc_object $P6764, "1304456142.948", 1
    .const 'Sub' $P6765 = "168_1304456155.152" 
    $P6763."add_method"($P6764, "declarator", $P6765)
    nqp_get_sc_object $P6766, "1304456142.948", 1
    get_how $P6767, $P6766
    nqp_get_sc_object $P6768, "1304456142.948", 1
    .const 'Sub' $P6769 = "169_1304456155.152" 
    $P6767."add_method"($P6768, "!PREFIX__declarator", $P6769)
    nqp_get_sc_object $P6770, "1304456142.948", 1
    get_how $P6771, $P6770
    nqp_get_sc_object $P6772, "1304456142.948", 1
    .const 'Sub' $P6773 = "170_1304456155.152" 
    $P6771."add_method"($P6772, "variable_declarator", $P6773)
    nqp_get_sc_object $P6774, "1304456142.948", 1
    get_how $P6775, $P6774
    nqp_get_sc_object $P6776, "1304456142.948", 1
    .const 'Sub' $P6777 = "172_1304456155.152" 
    $P6775."add_method"($P6776, "!PREFIX__variable_declarator", $P6777)
    nqp_get_sc_object $P6778, "1304456142.948", 1
    get_how $P6779, $P6778
    nqp_get_sc_object $P6780, "1304456142.948", 1
    .const 'Sub' $P6781 = "173_1304456155.152" 
    $P6779."add_method"($P6780, "routine_declarator", $P6781)
    nqp_get_sc_object $P6782, "1304456142.948", 1
    get_how $P6783, $P6782
    nqp_get_sc_object $P6784, "1304456142.948", 1
    .const 'Sub' $P6785 = "174_1304456155.152" 
    $P6783."add_method"($P6784, "!PREFIX__routine_declarator", $P6785)
    nqp_get_sc_object $P6786, "1304456142.948", 1
    get_how $P6787, $P6786
    nqp_get_sc_object $P6788, "1304456142.948", 1
    .const 'Sub' $P6789 = "175_1304456155.152" 
    $P6787."add_method"($P6788, "routine_declarator:sym<sub>", $P6789)
    nqp_get_sc_object $P6790, "1304456142.948", 1
    get_how $P6791, $P6790
    nqp_get_sc_object $P6792, "1304456142.948", 1
    .const 'Sub' $P6793 = "176_1304456155.152" 
    $P6791."add_method"($P6792, "!PREFIX__routine_declarator:sym<sub>", $P6793)
    nqp_get_sc_object $P6794, "1304456142.948", 1
    get_how $P6795, $P6794
    nqp_get_sc_object $P6796, "1304456142.948", 1
    .const 'Sub' $P6797 = "177_1304456155.152" 
    $P6795."add_method"($P6796, "routine_declarator:sym<method>", $P6797)
    nqp_get_sc_object $P6798, "1304456142.948", 1
    get_how $P6799, $P6798
    nqp_get_sc_object $P6800, "1304456142.948", 1
    .const 'Sub' $P6801 = "178_1304456155.152" 
    $P6799."add_method"($P6800, "!PREFIX__routine_declarator:sym<method>", $P6801)
    nqp_get_sc_object $P6802, "1304456142.948", 1
    get_how $P6803, $P6802
    nqp_get_sc_object $P6804, "1304456142.948", 1
    .const 'Sub' $P6805 = "179_1304456155.152" 
    $P6803."add_method"($P6804, "routine_def", $P6805)
    nqp_get_sc_object $P6806, "1304456142.948", 1
    get_how $P6807, $P6806
    nqp_get_sc_object $P6808, "1304456142.948", 1
    .const 'Sub' $P6809 = "180_1304456155.152" 
    $P6807."add_method"($P6808, "!PREFIX__routine_def", $P6809)
    nqp_get_sc_object $P6810, "1304456142.948", 1
    get_how $P6811, $P6810
    nqp_get_sc_object $P6812, "1304456142.948", 1
    .const 'Sub' $P6813 = "181_1304456155.152" 
    $P6811."add_method"($P6812, "method_def", $P6813)
    nqp_get_sc_object $P6814, "1304456142.948", 1
    get_how $P6815, $P6814
    nqp_get_sc_object $P6816, "1304456142.948", 1
    .const 'Sub' $P6817 = "183_1304456155.152" 
    $P6815."add_method"($P6816, "!PREFIX__method_def", $P6817)
    nqp_get_sc_object $P6818, "1304456142.948", 1
    get_how $P6819, $P6818
    nqp_get_sc_object $P6820, "1304456142.948", 1
    .const 'Sub' $P6821 = "184_1304456155.152" 
    $P6819."add_method"($P6820, "onlystar", $P6821)
    nqp_get_sc_object $P6822, "1304456142.948", 1
    get_how $P6823, $P6822
    nqp_get_sc_object $P6824, "1304456142.948", 1
    .const 'Sub' $P6825 = "186_1304456155.152" 
    $P6823."add_method"($P6824, "!PREFIX__onlystar", $P6825)
    nqp_get_sc_object $P6826, "1304456142.948", 1
    get_how $P6827, $P6826
    nqp_get_sc_object $P6828, "1304456142.948", 1
    .const 'Sub' $P6829 = "187_1304456155.152" 
    $P6827."add_method"($P6828, "multi_declarator", $P6829)
    nqp_get_sc_object $P6830, "1304456142.948", 1
    get_how $P6831, $P6830
    nqp_get_sc_object $P6832, "1304456142.948", 1
    .const 'Sub' $P6833 = "188_1304456155.152" 
    $P6831."add_method"($P6832, "!PREFIX__multi_declarator", $P6833)
    nqp_get_sc_object $P6834, "1304456142.948", 1
    get_how $P6835, $P6834
    nqp_get_sc_object $P6836, "1304456142.948", 1
    .const 'Sub' $P6837 = "189_1304456155.152" 
    $P6835."add_method"($P6836, "multi_declarator:sym<multi>", $P6837)
    nqp_get_sc_object $P6838, "1304456142.948", 1
    get_how $P6839, $P6838
    nqp_get_sc_object $P6840, "1304456142.948", 1
    .const 'Sub' $P6841 = "190_1304456155.152" 
    $P6839."add_method"($P6840, "!PREFIX__multi_declarator:sym<multi>", $P6841)
    nqp_get_sc_object $P6842, "1304456142.948", 1
    get_how $P6843, $P6842
    nqp_get_sc_object $P6844, "1304456142.948", 1
    .const 'Sub' $P6845 = "191_1304456155.152" 
    $P6843."add_method"($P6844, "multi_declarator:sym<proto>", $P6845)
    nqp_get_sc_object $P6846, "1304456142.948", 1
    get_how $P6847, $P6846
    nqp_get_sc_object $P6848, "1304456142.948", 1
    .const 'Sub' $P6849 = "192_1304456155.152" 
    $P6847."add_method"($P6848, "!PREFIX__multi_declarator:sym<proto>", $P6849)
    nqp_get_sc_object $P6850, "1304456142.948", 1
    get_how $P6851, $P6850
    nqp_get_sc_object $P6852, "1304456142.948", 1
    .const 'Sub' $P6853 = "193_1304456155.152" 
    $P6851."add_method"($P6852, "multi_declarator:sym<null>", $P6853)
    nqp_get_sc_object $P6854, "1304456142.948", 1
    get_how $P6855, $P6854
    nqp_get_sc_object $P6856, "1304456142.948", 1
    .const 'Sub' $P6857 = "194_1304456155.152" 
    $P6855."add_method"($P6856, "!PREFIX__multi_declarator:sym<null>", $P6857)
    nqp_get_sc_object $P6858, "1304456142.948", 1
    get_how $P6859, $P6858
    nqp_get_sc_object $P6860, "1304456142.948", 1
    .const 'Sub' $P6861 = "195_1304456155.152" 
    $P6859."add_method"($P6860, "signature", $P6861)
    nqp_get_sc_object $P6862, "1304456142.948", 1
    get_how $P6863, $P6862
    nqp_get_sc_object $P6864, "1304456142.948", 1
    .const 'Sub' $P6865 = "197_1304456155.152" 
    $P6863."add_method"($P6864, "!PREFIX__signature", $P6865)
    nqp_get_sc_object $P6866, "1304456142.948", 1
    get_how $P6867, $P6866
    nqp_get_sc_object $P6868, "1304456142.948", 1
    .const 'Sub' $P6869 = "198_1304456155.152" 
    $P6867."add_method"($P6868, "parameter", $P6869)
    nqp_get_sc_object $P6870, "1304456142.948", 1
    get_how $P6871, $P6870
    nqp_get_sc_object $P6872, "1304456142.948", 1
    .const 'Sub' $P6873 = "199_1304456155.152" 
    $P6871."add_method"($P6872, "!PREFIX__parameter", $P6873)
    nqp_get_sc_object $P6874, "1304456142.948", 1
    get_how $P6875, $P6874
    nqp_get_sc_object $P6876, "1304456142.948", 1
    .const 'Sub' $P6877 = "200_1304456155.152" 
    $P6875."add_method"($P6876, "param_var", $P6877)
    nqp_get_sc_object $P6878, "1304456142.948", 1
    get_how $P6879, $P6878
    nqp_get_sc_object $P6880, "1304456142.948", 1
    .const 'Sub' $P6881 = "201_1304456155.152" 
    $P6879."add_method"($P6880, "!PREFIX__param_var", $P6881)
    nqp_get_sc_object $P6882, "1304456142.948", 1
    get_how $P6883, $P6882
    nqp_get_sc_object $P6884, "1304456142.948", 1
    .const 'Sub' $P6885 = "202_1304456155.152" 
    $P6883."add_method"($P6884, "named_param", $P6885)
    nqp_get_sc_object $P6886, "1304456142.948", 1
    get_how $P6887, $P6886
    nqp_get_sc_object $P6888, "1304456142.948", 1
    .const 'Sub' $P6889 = "203_1304456155.152" 
    $P6887."add_method"($P6888, "!PREFIX__named_param", $P6889)
    nqp_get_sc_object $P6890, "1304456142.948", 1
    get_how $P6891, $P6890
    nqp_get_sc_object $P6892, "1304456142.948", 1
    .const 'Sub' $P6893 = "204_1304456155.152" 
    $P6891."add_method"($P6892, "default_value", $P6893)
    nqp_get_sc_object $P6894, "1304456142.948", 1
    get_how $P6895, $P6894
    nqp_get_sc_object $P6896, "1304456142.948", 1
    .const 'Sub' $P6897 = "205_1304456155.152" 
    $P6895."add_method"($P6896, "!PREFIX__default_value", $P6897)
    nqp_get_sc_object $P6898, "1304456142.948", 1
    get_how $P6899, $P6898
    nqp_get_sc_object $P6900, "1304456142.948", 1
    .const 'Sub' $P6901 = "206_1304456155.152" 
    $P6899."add_method"($P6900, "trait", $P6901)
    nqp_get_sc_object $P6902, "1304456142.948", 1
    get_how $P6903, $P6902
    nqp_get_sc_object $P6904, "1304456142.948", 1
    .const 'Sub' $P6905 = "207_1304456155.152" 
    $P6903."add_method"($P6904, "!PREFIX__trait", $P6905)
    nqp_get_sc_object $P6906, "1304456142.948", 1
    get_how $P6907, $P6906
    nqp_get_sc_object $P6908, "1304456142.948", 1
    .const 'Sub' $P6909 = "208_1304456155.152" 
    $P6907."add_method"($P6908, "trait_mod", $P6909)
    nqp_get_sc_object $P6910, "1304456142.948", 1
    get_how $P6911, $P6910
    nqp_get_sc_object $P6912, "1304456142.948", 1
    .const 'Sub' $P6913 = "209_1304456155.152" 
    $P6911."add_method"($P6912, "!PREFIX__trait_mod", $P6913)
    nqp_get_sc_object $P6914, "1304456142.948", 1
    get_how $P6915, $P6914
    nqp_get_sc_object $P6916, "1304456142.948", 1
    .const 'Sub' $P6917 = "210_1304456155.152" 
    $P6915."add_method"($P6916, "trait_mod:sym<is>", $P6917)
    nqp_get_sc_object $P6918, "1304456142.948", 1
    get_how $P6919, $P6918
    nqp_get_sc_object $P6920, "1304456142.948", 1
    .const 'Sub' $P6921 = "211_1304456155.152" 
    $P6919."add_method"($P6920, "!PREFIX__trait_mod:sym<is>", $P6921)
    nqp_get_sc_object $P6922, "1304456142.948", 1
    get_how $P6923, $P6922
    nqp_get_sc_object $P6924, "1304456142.948", 1
    .const 'Sub' $P6925 = "212_1304456155.152" 
    $P6923."add_method"($P6924, "regex_declarator", $P6925)
    nqp_get_sc_object $P6926, "1304456142.948", 1
    get_how $P6927, $P6926
    nqp_get_sc_object $P6928, "1304456142.948", 1
    .const 'Sub' $P6929 = "213_1304456155.152" 
    $P6927."add_method"($P6928, "!PREFIX__regex_declarator", $P6929)
    nqp_get_sc_object $P6930, "1304456142.948", 1
    get_how $P6931, $P6930
    nqp_get_sc_object $P6932, "1304456142.948", 1
    .const 'Sub' $P6933 = "214_1304456155.152" 
    $P6931."add_method"($P6932, "dotty", $P6933)
    nqp_get_sc_object $P6934, "1304456142.948", 1
    get_how $P6935, $P6934
    nqp_get_sc_object $P6936, "1304456142.948", 1
    .const 'Sub' $P6937 = "215_1304456155.152" 
    $P6935."add_method"($P6936, "!PREFIX__dotty", $P6937)
    nqp_get_sc_object $P6938, "1304456142.948", 1
    get_how $P6939, $P6938
    nqp_get_sc_object $P6940, "1304456142.948", 1
    .const 'Sub' $P6941 = "216_1304456155.152" 
    $P6939."add_method"($P6940, "term", $P6941)
    nqp_get_sc_object $P6942, "1304456142.948", 1
    get_how $P6943, $P6942
    nqp_get_sc_object $P6944, "1304456142.948", 1
    .const 'Sub' $P6945 = "217_1304456155.152" 
    $P6943."add_method"($P6944, "!PREFIX__term", $P6945)
    nqp_get_sc_object $P6946, "1304456142.948", 1
    get_how $P6947, $P6946
    nqp_get_sc_object $P6948, "1304456142.948", 1
    .const 'Sub' $P6949 = "218_1304456155.152" 
    $P6947."add_method"($P6948, "term:sym<self>", $P6949)
    nqp_get_sc_object $P6950, "1304456142.948", 1
    get_how $P6951, $P6950
    nqp_get_sc_object $P6952, "1304456142.948", 1
    .const 'Sub' $P6953 = "219_1304456155.152" 
    $P6951."add_method"($P6952, "!PREFIX__term:sym<self>", $P6953)
    nqp_get_sc_object $P6954, "1304456142.948", 1
    get_how $P6955, $P6954
    nqp_get_sc_object $P6956, "1304456142.948", 1
    .const 'Sub' $P6957 = "220_1304456155.152" 
    $P6955."add_method"($P6956, "term:sym<identifier>", $P6957)
    nqp_get_sc_object $P6958, "1304456142.948", 1
    get_how $P6959, $P6958
    nqp_get_sc_object $P6960, "1304456142.948", 1
    .const 'Sub' $P6961 = "221_1304456155.152" 
    $P6959."add_method"($P6960, "!PREFIX__term:sym<identifier>", $P6961)
    nqp_get_sc_object $P6962, "1304456142.948", 1
    get_how $P6963, $P6962
    nqp_get_sc_object $P6964, "1304456142.948", 1
    .const 'Sub' $P6965 = "222_1304456155.152" 
    $P6963."add_method"($P6964, "term:sym<name>", $P6965)
    nqp_get_sc_object $P6966, "1304456142.948", 1
    get_how $P6967, $P6966
    nqp_get_sc_object $P6968, "1304456142.948", 1
    .const 'Sub' $P6969 = "223_1304456155.152" 
    $P6967."add_method"($P6968, "!PREFIX__term:sym<name>", $P6969)
    nqp_get_sc_object $P6970, "1304456142.948", 1
    get_how $P6971, $P6970
    nqp_get_sc_object $P6972, "1304456142.948", 1
    .const 'Sub' $P6973 = "224_1304456155.152" 
    $P6971."add_method"($P6972, "term:sym<pir::op>", $P6973)
    nqp_get_sc_object $P6974, "1304456142.948", 1
    get_how $P6975, $P6974
    nqp_get_sc_object $P6976, "1304456142.948", 1
    .const 'Sub' $P6977 = "225_1304456155.152" 
    $P6975."add_method"($P6976, "!PREFIX__term:sym<pir::op>", $P6977)
    nqp_get_sc_object $P6978, "1304456142.948", 1
    get_how $P6979, $P6978
    nqp_get_sc_object $P6980, "1304456142.948", 1
    .const 'Sub' $P6981 = "226_1304456155.152" 
    $P6979."add_method"($P6980, "term:sym<onlystar>", $P6981)
    nqp_get_sc_object $P6982, "1304456142.948", 1
    get_how $P6983, $P6982
    nqp_get_sc_object $P6984, "1304456142.948", 1
    .const 'Sub' $P6985 = "228_1304456155.152" 
    $P6983."add_method"($P6984, "!PREFIX__term:sym<onlystar>", $P6985)
    nqp_get_sc_object $P6986, "1304456142.948", 1
    get_how $P6987, $P6986
    nqp_get_sc_object $P6988, "1304456142.948", 1
    .const 'Sub' $P6989 = "229_1304456155.152" 
    $P6987."add_method"($P6988, "args", $P6989)
    nqp_get_sc_object $P6990, "1304456142.948", 1
    get_how $P6991, $P6990
    nqp_get_sc_object $P6992, "1304456142.948", 1
    .const 'Sub' $P6993 = "230_1304456155.152" 
    $P6991."add_method"($P6992, "!PREFIX__args", $P6993)
    nqp_get_sc_object $P6994, "1304456142.948", 1
    get_how $P6995, $P6994
    nqp_get_sc_object $P6996, "1304456142.948", 1
    .const 'Sub' $P6997 = "231_1304456155.152" 
    $P6995."add_method"($P6996, "arglist", $P6997)
    nqp_get_sc_object $P6998, "1304456142.948", 1
    get_how $P6999, $P6998
    nqp_get_sc_object $P7000, "1304456142.948", 1
    .const 'Sub' $P7001 = "232_1304456155.152" 
    $P6999."add_method"($P7000, "!PREFIX__arglist", $P7001)
    nqp_get_sc_object $P7002, "1304456142.948", 1
    get_how $P7003, $P7002
    nqp_get_sc_object $P7004, "1304456142.948", 1
    .const 'Sub' $P7005 = "233_1304456155.152" 
    $P7003."add_method"($P7004, "term:sym<value>", $P7005)
    nqp_get_sc_object $P7006, "1304456142.948", 1
    get_how $P7007, $P7006
    nqp_get_sc_object $P7008, "1304456142.948", 1
    .const 'Sub' $P7009 = "234_1304456155.152" 
    $P7007."add_method"($P7008, "!PREFIX__term:sym<value>", $P7009)
    nqp_get_sc_object $P7010, "1304456142.948", 1
    get_how $P7011, $P7010
    nqp_get_sc_object $P7012, "1304456142.948", 1
    .const 'Sub' $P7013 = "235_1304456155.152" 
    $P7011."add_method"($P7012, "value", $P7013)
    nqp_get_sc_object $P7014, "1304456142.948", 1
    get_how $P7015, $P7014
    nqp_get_sc_object $P7016, "1304456142.948", 1
    .const 'Sub' $P7017 = "236_1304456155.152" 
    $P7015."add_method"($P7016, "!PREFIX__value", $P7017)
    nqp_get_sc_object $P7018, "1304456142.948", 1
    get_how $P7019, $P7018
    nqp_get_sc_object $P7020, "1304456142.948", 1
    .const 'Sub' $P7021 = "237_1304456155.152" 
    $P7019."add_method"($P7020, "number", $P7021)
    nqp_get_sc_object $P7022, "1304456142.948", 1
    get_how $P7023, $P7022
    nqp_get_sc_object $P7024, "1304456142.948", 1
    .const 'Sub' $P7025 = "238_1304456155.152" 
    $P7023."add_method"($P7024, "!PREFIX__number", $P7025)
    nqp_get_sc_object $P7026, "1304456142.948", 1
    get_how $P7027, $P7026
    nqp_get_sc_object $P7028, "1304456142.948", 1
    .const 'Sub' $P7029 = "239_1304456155.152" 
    $P7027."add_method"($P7028, "quote", $P7029)
    nqp_get_sc_object $P7030, "1304456142.948", 1
    get_how $P7031, $P7030
    nqp_get_sc_object $P7032, "1304456142.948", 1
    .const 'Sub' $P7033 = "240_1304456155.152" 
    $P7031."add_method"($P7032, "!PREFIX__quote", $P7033)
    nqp_get_sc_object $P7034, "1304456142.948", 1
    get_how $P7035, $P7034
    nqp_get_sc_object $P7036, "1304456142.948", 1
    .const 'Sub' $P7037 = "241_1304456155.152" 
    $P7035."add_method"($P7036, "quote:sym<apos>", $P7037)
    nqp_get_sc_object $P7038, "1304456142.948", 1
    get_how $P7039, $P7038
    nqp_get_sc_object $P7040, "1304456142.948", 1
    .const 'Sub' $P7041 = "242_1304456155.152" 
    $P7039."add_method"($P7040, "!PREFIX__quote:sym<apos>", $P7041)
    nqp_get_sc_object $P7042, "1304456142.948", 1
    get_how $P7043, $P7042
    nqp_get_sc_object $P7044, "1304456142.948", 1
    .const 'Sub' $P7045 = "243_1304456155.152" 
    $P7043."add_method"($P7044, "quote:sym<dblq>", $P7045)
    nqp_get_sc_object $P7046, "1304456142.948", 1
    get_how $P7047, $P7046
    nqp_get_sc_object $P7048, "1304456142.948", 1
    .const 'Sub' $P7049 = "244_1304456155.152" 
    $P7047."add_method"($P7048, "!PREFIX__quote:sym<dblq>", $P7049)
    nqp_get_sc_object $P7050, "1304456142.948", 1
    get_how $P7051, $P7050
    nqp_get_sc_object $P7052, "1304456142.948", 1
    .const 'Sub' $P7053 = "245_1304456155.152" 
    $P7051."add_method"($P7052, "quote:sym<q>", $P7053)
    nqp_get_sc_object $P7054, "1304456142.948", 1
    get_how $P7055, $P7054
    nqp_get_sc_object $P7056, "1304456142.948", 1
    .const 'Sub' $P7057 = "246_1304456155.152" 
    $P7055."add_method"($P7056, "!PREFIX__quote:sym<q>", $P7057)
    nqp_get_sc_object $P7058, "1304456142.948", 1
    get_how $P7059, $P7058
    nqp_get_sc_object $P7060, "1304456142.948", 1
    .const 'Sub' $P7061 = "247_1304456155.152" 
    $P7059."add_method"($P7060, "quote:sym<qq>", $P7061)
    nqp_get_sc_object $P7062, "1304456142.948", 1
    get_how $P7063, $P7062
    nqp_get_sc_object $P7064, "1304456142.948", 1
    .const 'Sub' $P7065 = "248_1304456155.152" 
    $P7063."add_method"($P7064, "!PREFIX__quote:sym<qq>", $P7065)
    nqp_get_sc_object $P7066, "1304456142.948", 1
    get_how $P7067, $P7066
    nqp_get_sc_object $P7068, "1304456142.948", 1
    .const 'Sub' $P7069 = "249_1304456155.152" 
    $P7067."add_method"($P7068, "quote:sym<Q>", $P7069)
    nqp_get_sc_object $P7070, "1304456142.948", 1
    get_how $P7071, $P7070
    nqp_get_sc_object $P7072, "1304456142.948", 1
    .const 'Sub' $P7073 = "250_1304456155.152" 
    $P7071."add_method"($P7072, "!PREFIX__quote:sym<Q>", $P7073)
    nqp_get_sc_object $P7074, "1304456142.948", 1
    get_how $P7075, $P7074
    nqp_get_sc_object $P7076, "1304456142.948", 1
    .const 'Sub' $P7077 = "251_1304456155.152" 
    $P7075."add_method"($P7076, "quote:sym<Q:PIR>", $P7077)
    nqp_get_sc_object $P7078, "1304456142.948", 1
    get_how $P7079, $P7078
    nqp_get_sc_object $P7080, "1304456142.948", 1
    .const 'Sub' $P7081 = "252_1304456155.152" 
    $P7079."add_method"($P7080, "!PREFIX__quote:sym<Q:PIR>", $P7081)
    nqp_get_sc_object $P7082, "1304456142.948", 1
    get_how $P7083, $P7082
    nqp_get_sc_object $P7084, "1304456142.948", 1
    .const 'Sub' $P7085 = "253_1304456155.152" 
    $P7083."add_method"($P7084, "quote:sym</ />", $P7085)
    nqp_get_sc_object $P7086, "1304456142.948", 1
    get_how $P7087, $P7086
    nqp_get_sc_object $P7088, "1304456142.948", 1
    .const 'Sub' $P7089 = "254_1304456155.152" 
    $P7087."add_method"($P7088, "!PREFIX__quote:sym</ />", $P7089)
    nqp_get_sc_object $P7090, "1304456142.948", 1
    get_how $P7091, $P7090
    nqp_get_sc_object $P7092, "1304456142.948", 1
    .const 'Sub' $P7093 = "255_1304456155.152" 
    $P7091."add_method"($P7092, "quote_escape:sym<$>", $P7093)
    nqp_get_sc_object $P7094, "1304456142.948", 1
    get_how $P7095, $P7094
    nqp_get_sc_object $P7096, "1304456142.948", 1
    .const 'Sub' $P7097 = "256_1304456155.152" 
    $P7095."add_method"($P7096, "!PREFIX__quote_escape:sym<$>", $P7097)
    nqp_get_sc_object $P7098, "1304456142.948", 1
    get_how $P7099, $P7098
    nqp_get_sc_object $P7100, "1304456142.948", 1
    .const 'Sub' $P7101 = "257_1304456155.152" 
    $P7099."add_method"($P7100, "quote_escape:sym<{ }>", $P7101)
    nqp_get_sc_object $P7102, "1304456142.948", 1
    get_how $P7103, $P7102
    nqp_get_sc_object $P7104, "1304456142.948", 1
    .const 'Sub' $P7105 = "258_1304456155.152" 
    $P7103."add_method"($P7104, "!PREFIX__quote_escape:sym<{ }>", $P7105)
    nqp_get_sc_object $P7106, "1304456142.948", 1
    get_how $P7107, $P7106
    nqp_get_sc_object $P7108, "1304456142.948", 1
    .const 'Sub' $P7109 = "259_1304456155.152" 
    $P7107."add_method"($P7108, "quote_escape:sym<esc>", $P7109)
    nqp_get_sc_object $P7110, "1304456142.948", 1
    get_how $P7111, $P7110
    nqp_get_sc_object $P7112, "1304456142.948", 1
    .const 'Sub' $P7113 = "260_1304456155.152" 
    $P7111."add_method"($P7112, "!PREFIX__quote_escape:sym<esc>", $P7113)
    nqp_get_sc_object $P7114, "1304456142.948", 1
    get_how $P7115, $P7114
    nqp_get_sc_object $P7116, "1304456142.948", 1
    .const 'Sub' $P7117 = "261_1304456155.152" 
    $P7115."add_method"($P7116, "circumfix:sym<( )>", $P7117)
    nqp_get_sc_object $P7118, "1304456142.948", 1
    get_how $P7119, $P7118
    nqp_get_sc_object $P7120, "1304456142.948", 1
    .const 'Sub' $P7121 = "262_1304456155.152" 
    $P7119."add_method"($P7120, "!PREFIX__circumfix:sym<( )>", $P7121)
    nqp_get_sc_object $P7122, "1304456142.948", 1
    get_how $P7123, $P7122
    nqp_get_sc_object $P7124, "1304456142.948", 1
    .const 'Sub' $P7125 = "263_1304456155.152" 
    $P7123."add_method"($P7124, "circumfix:sym<[ ]>", $P7125)
    nqp_get_sc_object $P7126, "1304456142.948", 1
    get_how $P7127, $P7126
    nqp_get_sc_object $P7128, "1304456142.948", 1
    .const 'Sub' $P7129 = "264_1304456155.152" 
    $P7127."add_method"($P7128, "!PREFIX__circumfix:sym<[ ]>", $P7129)
    nqp_get_sc_object $P7130, "1304456142.948", 1
    get_how $P7131, $P7130
    nqp_get_sc_object $P7132, "1304456142.948", 1
    .const 'Sub' $P7133 = "265_1304456155.152" 
    $P7131."add_method"($P7132, "circumfix:sym<ang>", $P7133)
    nqp_get_sc_object $P7134, "1304456142.948", 1
    get_how $P7135, $P7134
    nqp_get_sc_object $P7136, "1304456142.948", 1
    .const 'Sub' $P7137 = "266_1304456155.152" 
    $P7135."add_method"($P7136, "!PREFIX__circumfix:sym<ang>", $P7137)
    nqp_get_sc_object $P7138, "1304456142.948", 1
    get_how $P7139, $P7138
    nqp_get_sc_object $P7140, "1304456142.948", 1
    .const 'Sub' $P7141 = "267_1304456155.152" 
    $P7139."add_method"($P7140, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P7141)
    nqp_get_sc_object $P7142, "1304456142.948", 1
    get_how $P7143, $P7142
    nqp_get_sc_object $P7144, "1304456142.948", 1
    .const 'Sub' $P7145 = "268_1304456155.152" 
    $P7143."add_method"($P7144, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>", $P7145)
    nqp_get_sc_object $P7146, "1304456142.948", 1
    get_how $P7147, $P7146
    nqp_get_sc_object $P7148, "1304456142.948", 1
    .const 'Sub' $P7149 = "269_1304456155.152" 
    $P7147."add_method"($P7148, "circumfix:sym<{ }>", $P7149)
    nqp_get_sc_object $P7150, "1304456142.948", 1
    get_how $P7151, $P7150
    nqp_get_sc_object $P7152, "1304456142.948", 1
    .const 'Sub' $P7153 = "270_1304456155.152" 
    $P7151."add_method"($P7152, "!PREFIX__circumfix:sym<{ }>", $P7153)
    nqp_get_sc_object $P7154, "1304456142.948", 1
    get_how $P7155, $P7154
    nqp_get_sc_object $P7156, "1304456142.948", 1
    .const 'Sub' $P7157 = "271_1304456155.152" 
    $P7155."add_method"($P7156, "circumfix:sym<sigil>", $P7157)
    nqp_get_sc_object $P7158, "1304456142.948", 1
    get_how $P7159, $P7158
    nqp_get_sc_object $P7160, "1304456142.948", 1
    .const 'Sub' $P7161 = "272_1304456155.152" 
    $P7159."add_method"($P7160, "!PREFIX__circumfix:sym<sigil>", $P7161)
    nqp_get_sc_object $P7162, "1304456142.948", 1
    get_how $P7163, $P7162
    nqp_get_sc_object $P7164, "1304456142.948", 1
    .const 'Sub' $P7165 = "273_1304456155.152" 
    $P7163."add_method"($P7164, "semilist", $P7165)
    nqp_get_sc_object $P7166, "1304456142.948", 1
    get_how $P7167, $P7166
    nqp_get_sc_object $P7168, "1304456142.948", 1
    .const 'Sub' $P7169 = "274_1304456155.152" 
    $P7167."add_method"($P7168, "!PREFIX__semilist", $P7169)
    nqp_get_sc_object $P7170, "1304456142.948", 1
    get_how $P7171, $P7170
    nqp_get_sc_object $P7172, "1304456142.948", 1
    .const 'Sub' $P7173 = "275_1304456155.152" 
    $P7171."add_method"($P7172, "infixish", $P7173)
    nqp_get_sc_object $P7174, "1304456142.948", 1
    get_how $P7175, $P7174
    nqp_get_sc_object $P7176, "1304456142.948", 1
    .const 'Sub' $P7177 = "276_1304456155.152" 
    $P7175."add_method"($P7176, "!PREFIX__infixish", $P7177)
    nqp_get_sc_object $P7178, "1304456142.948", 1
    get_how $P7179, $P7178
    nqp_get_sc_object $P7180, "1304456142.948", 1
    .const 'Sub' $P7181 = "277_1304456155.152" 
    $P7179."add_method"($P7180, "infixstopper", $P7181)
    nqp_get_sc_object $P7182, "1304456142.948", 1
    get_how $P7183, $P7182
    nqp_get_sc_object $P7184, "1304456142.948", 1
    .const 'Sub' $P7185 = "278_1304456155.152" 
    $P7183."add_method"($P7184, "!PREFIX__infixstopper", $P7185)
    nqp_get_sc_object $P7186, "1304456142.948", 1
    get_how $P7187, $P7186
    nqp_get_sc_object $P7188, "1304456142.948", 1
    .const 'Sub' $P7189 = "279_1304456155.152" 
    $P7187."add_method"($P7188, "postcircumfix:sym<[ ]>", $P7189)
    nqp_get_sc_object $P7190, "1304456142.948", 1
    get_how $P7191, $P7190
    nqp_get_sc_object $P7192, "1304456142.948", 1
    .const 'Sub' $P7193 = "280_1304456155.152" 
    $P7191."add_method"($P7192, "!PREFIX__postcircumfix:sym<[ ]>", $P7193)
    nqp_get_sc_object $P7194, "1304456142.948", 1
    get_how $P7195, $P7194
    nqp_get_sc_object $P7196, "1304456142.948", 1
    .const 'Sub' $P7197 = "281_1304456155.152" 
    $P7195."add_method"($P7196, "postcircumfix:sym<{ }>", $P7197)
    nqp_get_sc_object $P7198, "1304456142.948", 1
    get_how $P7199, $P7198
    nqp_get_sc_object $P7200, "1304456142.948", 1
    .const 'Sub' $P7201 = "282_1304456155.152" 
    $P7199."add_method"($P7200, "!PREFIX__postcircumfix:sym<{ }>", $P7201)
    nqp_get_sc_object $P7202, "1304456142.948", 1
    get_how $P7203, $P7202
    nqp_get_sc_object $P7204, "1304456142.948", 1
    .const 'Sub' $P7205 = "283_1304456155.152" 
    $P7203."add_method"($P7204, "postcircumfix:sym<ang>", $P7205)
    nqp_get_sc_object $P7206, "1304456142.948", 1
    get_how $P7207, $P7206
    nqp_get_sc_object $P7208, "1304456142.948", 1
    .const 'Sub' $P7209 = "284_1304456155.152" 
    $P7207."add_method"($P7208, "!PREFIX__postcircumfix:sym<ang>", $P7209)
    nqp_get_sc_object $P7210, "1304456142.948", 1
    get_how $P7211, $P7210
    nqp_get_sc_object $P7212, "1304456142.948", 1
    .const 'Sub' $P7213 = "285_1304456155.152" 
    $P7211."add_method"($P7212, "postcircumfix:sym<( )>", $P7213)
    nqp_get_sc_object $P7214, "1304456142.948", 1
    get_how $P7215, $P7214
    nqp_get_sc_object $P7216, "1304456142.948", 1
    .const 'Sub' $P7217 = "286_1304456155.152" 
    $P7215."add_method"($P7216, "!PREFIX__postcircumfix:sym<( )>", $P7217)
    nqp_get_sc_object $P7218, "1304456142.948", 1
    get_how $P7219, $P7218
    nqp_get_sc_object $P7220, "1304456142.948", 1
    .const 'Sub' $P7221 = "287_1304456155.152" 
    $P7219."add_method"($P7220, "postfix:sym<.>", $P7221)
    nqp_get_sc_object $P7222, "1304456142.948", 1
    get_how $P7223, $P7222
    nqp_get_sc_object $P7224, "1304456142.948", 1
    .const 'Sub' $P7225 = "288_1304456155.152" 
    $P7223."add_method"($P7224, "!PREFIX__postfix:sym<.>", $P7225)
    nqp_get_sc_object $P7226, "1304456142.948", 1
    get_how $P7227, $P7226
    nqp_get_sc_object $P7228, "1304456142.948", 1
    .const 'Sub' $P7229 = "289_1304456155.152" 
    $P7227."add_method"($P7228, "prefix:sym<++>", $P7229)
    nqp_get_sc_object $P7230, "1304456142.948", 1
    get_how $P7231, $P7230
    nqp_get_sc_object $P7232, "1304456142.948", 1
    .const 'Sub' $P7233 = "290_1304456155.152" 
    $P7231."add_method"($P7232, "!PREFIX__prefix:sym<++>", $P7233)
    nqp_get_sc_object $P7234, "1304456142.948", 1
    get_how $P7235, $P7234
    nqp_get_sc_object $P7236, "1304456142.948", 1
    .const 'Sub' $P7237 = "291_1304456155.152" 
    $P7235."add_method"($P7236, "prefix:sym<-->", $P7237)
    nqp_get_sc_object $P7238, "1304456142.948", 1
    get_how $P7239, $P7238
    nqp_get_sc_object $P7240, "1304456142.948", 1
    .const 'Sub' $P7241 = "292_1304456155.152" 
    $P7239."add_method"($P7240, "!PREFIX__prefix:sym<-->", $P7241)
    nqp_get_sc_object $P7242, "1304456142.948", 1
    get_how $P7243, $P7242
    nqp_get_sc_object $P7244, "1304456142.948", 1
    .const 'Sub' $P7245 = "293_1304456155.152" 
    $P7243."add_method"($P7244, "postfix:sym<++>", $P7245)
    nqp_get_sc_object $P7246, "1304456142.948", 1
    get_how $P7247, $P7246
    nqp_get_sc_object $P7248, "1304456142.948", 1
    .const 'Sub' $P7249 = "294_1304456155.152" 
    $P7247."add_method"($P7248, "!PREFIX__postfix:sym<++>", $P7249)
    nqp_get_sc_object $P7250, "1304456142.948", 1
    get_how $P7251, $P7250
    nqp_get_sc_object $P7252, "1304456142.948", 1
    .const 'Sub' $P7253 = "295_1304456155.152" 
    $P7251."add_method"($P7252, "postfix:sym<-->", $P7253)
    nqp_get_sc_object $P7254, "1304456142.948", 1
    get_how $P7255, $P7254
    nqp_get_sc_object $P7256, "1304456142.948", 1
    .const 'Sub' $P7257 = "296_1304456155.152" 
    $P7255."add_method"($P7256, "!PREFIX__postfix:sym<-->", $P7257)
    nqp_get_sc_object $P7258, "1304456142.948", 1
    get_how $P7259, $P7258
    nqp_get_sc_object $P7260, "1304456142.948", 1
    .const 'Sub' $P7261 = "297_1304456155.152" 
    $P7259."add_method"($P7260, "infix:sym<**>", $P7261)
    nqp_get_sc_object $P7262, "1304456142.948", 1
    get_how $P7263, $P7262
    nqp_get_sc_object $P7264, "1304456142.948", 1
    .const 'Sub' $P7265 = "298_1304456155.152" 
    $P7263."add_method"($P7264, "!PREFIX__infix:sym<**>", $P7265)
    nqp_get_sc_object $P7266, "1304456142.948", 1
    get_how $P7267, $P7266
    nqp_get_sc_object $P7268, "1304456142.948", 1
    .const 'Sub' $P7269 = "299_1304456155.152" 
    $P7267."add_method"($P7268, "prefix:sym<+>", $P7269)
    nqp_get_sc_object $P7270, "1304456142.948", 1
    get_how $P7271, $P7270
    nqp_get_sc_object $P7272, "1304456142.948", 1
    .const 'Sub' $P7273 = "300_1304456155.152" 
    $P7271."add_method"($P7272, "!PREFIX__prefix:sym<+>", $P7273)
    nqp_get_sc_object $P7274, "1304456142.948", 1
    get_how $P7275, $P7274
    nqp_get_sc_object $P7276, "1304456142.948", 1
    .const 'Sub' $P7277 = "301_1304456155.152" 
    $P7275."add_method"($P7276, "prefix:sym<~>", $P7277)
    nqp_get_sc_object $P7278, "1304456142.948", 1
    get_how $P7279, $P7278
    nqp_get_sc_object $P7280, "1304456142.948", 1
    .const 'Sub' $P7281 = "302_1304456155.152" 
    $P7279."add_method"($P7280, "!PREFIX__prefix:sym<~>", $P7281)
    nqp_get_sc_object $P7282, "1304456142.948", 1
    get_how $P7283, $P7282
    nqp_get_sc_object $P7284, "1304456142.948", 1
    .const 'Sub' $P7285 = "303_1304456155.152" 
    $P7283."add_method"($P7284, "prefix:sym<->", $P7285)
    nqp_get_sc_object $P7286, "1304456142.948", 1
    get_how $P7287, $P7286
    nqp_get_sc_object $P7288, "1304456142.948", 1
    .const 'Sub' $P7289 = "304_1304456155.152" 
    $P7287."add_method"($P7288, "!PREFIX__prefix:sym<->", $P7289)
    nqp_get_sc_object $P7290, "1304456142.948", 1
    get_how $P7291, $P7290
    nqp_get_sc_object $P7292, "1304456142.948", 1
    .const 'Sub' $P7293 = "305_1304456155.152" 
    $P7291."add_method"($P7292, "prefix:sym<?>", $P7293)
    nqp_get_sc_object $P7294, "1304456142.948", 1
    get_how $P7295, $P7294
    nqp_get_sc_object $P7296, "1304456142.948", 1
    .const 'Sub' $P7297 = "306_1304456155.152" 
    $P7295."add_method"($P7296, "!PREFIX__prefix:sym<?>", $P7297)
    nqp_get_sc_object $P7298, "1304456142.948", 1
    get_how $P7299, $P7298
    nqp_get_sc_object $P7300, "1304456142.948", 1
    .const 'Sub' $P7301 = "307_1304456155.152" 
    $P7299."add_method"($P7300, "prefix:sym<!>", $P7301)
    nqp_get_sc_object $P7302, "1304456142.948", 1
    get_how $P7303, $P7302
    nqp_get_sc_object $P7304, "1304456142.948", 1
    .const 'Sub' $P7305 = "308_1304456155.152" 
    $P7303."add_method"($P7304, "!PREFIX__prefix:sym<!>", $P7305)
    nqp_get_sc_object $P7306, "1304456142.948", 1
    get_how $P7307, $P7306
    nqp_get_sc_object $P7308, "1304456142.948", 1
    .const 'Sub' $P7309 = "309_1304456155.152" 
    $P7307."add_method"($P7308, "prefix:sym<|>", $P7309)
    nqp_get_sc_object $P7310, "1304456142.948", 1
    get_how $P7311, $P7310
    nqp_get_sc_object $P7312, "1304456142.948", 1
    .const 'Sub' $P7313 = "310_1304456155.152" 
    $P7311."add_method"($P7312, "!PREFIX__prefix:sym<|>", $P7313)
    nqp_get_sc_object $P7314, "1304456142.948", 1
    get_how $P7315, $P7314
    nqp_get_sc_object $P7316, "1304456142.948", 1
    .const 'Sub' $P7317 = "311_1304456155.152" 
    $P7315."add_method"($P7316, "infix:sym<*>", $P7317)
    nqp_get_sc_object $P7318, "1304456142.948", 1
    get_how $P7319, $P7318
    nqp_get_sc_object $P7320, "1304456142.948", 1
    .const 'Sub' $P7321 = "312_1304456155.152" 
    $P7319."add_method"($P7320, "!PREFIX__infix:sym<*>", $P7321)
    nqp_get_sc_object $P7322, "1304456142.948", 1
    get_how $P7323, $P7322
    nqp_get_sc_object $P7324, "1304456142.948", 1
    .const 'Sub' $P7325 = "313_1304456155.152" 
    $P7323."add_method"($P7324, "infix:sym</>", $P7325)
    nqp_get_sc_object $P7326, "1304456142.948", 1
    get_how $P7327, $P7326
    nqp_get_sc_object $P7328, "1304456142.948", 1
    .const 'Sub' $P7329 = "314_1304456155.152" 
    $P7327."add_method"($P7328, "!PREFIX__infix:sym</>", $P7329)
    nqp_get_sc_object $P7330, "1304456142.948", 1
    get_how $P7331, $P7330
    nqp_get_sc_object $P7332, "1304456142.948", 1
    .const 'Sub' $P7333 = "315_1304456155.152" 
    $P7331."add_method"($P7332, "infix:sym<%>", $P7333)
    nqp_get_sc_object $P7334, "1304456142.948", 1
    get_how $P7335, $P7334
    nqp_get_sc_object $P7336, "1304456142.948", 1
    .const 'Sub' $P7337 = "316_1304456155.152" 
    $P7335."add_method"($P7336, "!PREFIX__infix:sym<%>", $P7337)
    nqp_get_sc_object $P7338, "1304456142.948", 1
    get_how $P7339, $P7338
    nqp_get_sc_object $P7340, "1304456142.948", 1
    .const 'Sub' $P7341 = "317_1304456155.152" 
    $P7339."add_method"($P7340, "infix:sym<+&>", $P7341)
    nqp_get_sc_object $P7342, "1304456142.948", 1
    get_how $P7343, $P7342
    nqp_get_sc_object $P7344, "1304456142.948", 1
    .const 'Sub' $P7345 = "318_1304456155.152" 
    $P7343."add_method"($P7344, "!PREFIX__infix:sym<+&>", $P7345)
    nqp_get_sc_object $P7346, "1304456142.948", 1
    get_how $P7347, $P7346
    nqp_get_sc_object $P7348, "1304456142.948", 1
    .const 'Sub' $P7349 = "319_1304456155.152" 
    $P7347."add_method"($P7348, "infix:sym<+>", $P7349)
    nqp_get_sc_object $P7350, "1304456142.948", 1
    get_how $P7351, $P7350
    nqp_get_sc_object $P7352, "1304456142.948", 1
    .const 'Sub' $P7353 = "320_1304456155.152" 
    $P7351."add_method"($P7352, "!PREFIX__infix:sym<+>", $P7353)
    nqp_get_sc_object $P7354, "1304456142.948", 1
    get_how $P7355, $P7354
    nqp_get_sc_object $P7356, "1304456142.948", 1
    .const 'Sub' $P7357 = "321_1304456155.152" 
    $P7355."add_method"($P7356, "infix:sym<->", $P7357)
    nqp_get_sc_object $P7358, "1304456142.948", 1
    get_how $P7359, $P7358
    nqp_get_sc_object $P7360, "1304456142.948", 1
    .const 'Sub' $P7361 = "322_1304456155.152" 
    $P7359."add_method"($P7360, "!PREFIX__infix:sym<->", $P7361)
    nqp_get_sc_object $P7362, "1304456142.948", 1
    get_how $P7363, $P7362
    nqp_get_sc_object $P7364, "1304456142.948", 1
    .const 'Sub' $P7365 = "323_1304456155.152" 
    $P7363."add_method"($P7364, "infix:sym<+|>", $P7365)
    nqp_get_sc_object $P7366, "1304456142.948", 1
    get_how $P7367, $P7366
    nqp_get_sc_object $P7368, "1304456142.948", 1
    .const 'Sub' $P7369 = "324_1304456155.152" 
    $P7367."add_method"($P7368, "!PREFIX__infix:sym<+|>", $P7369)
    nqp_get_sc_object $P7370, "1304456142.948", 1
    get_how $P7371, $P7370
    nqp_get_sc_object $P7372, "1304456142.948", 1
    .const 'Sub' $P7373 = "325_1304456155.152" 
    $P7371."add_method"($P7372, "infix:sym<+^>", $P7373)
    nqp_get_sc_object $P7374, "1304456142.948", 1
    get_how $P7375, $P7374
    nqp_get_sc_object $P7376, "1304456142.948", 1
    .const 'Sub' $P7377 = "326_1304456155.152" 
    $P7375."add_method"($P7376, "!PREFIX__infix:sym<+^>", $P7377)
    nqp_get_sc_object $P7378, "1304456142.948", 1
    get_how $P7379, $P7378
    nqp_get_sc_object $P7380, "1304456142.948", 1
    .const 'Sub' $P7381 = "327_1304456155.152" 
    $P7379."add_method"($P7380, "infix:sym<~>", $P7381)
    nqp_get_sc_object $P7382, "1304456142.948", 1
    get_how $P7383, $P7382
    nqp_get_sc_object $P7384, "1304456142.948", 1
    .const 'Sub' $P7385 = "328_1304456155.152" 
    $P7383."add_method"($P7384, "!PREFIX__infix:sym<~>", $P7385)
    nqp_get_sc_object $P7386, "1304456142.948", 1
    get_how $P7387, $P7386
    nqp_get_sc_object $P7388, "1304456142.948", 1
    .const 'Sub' $P7389 = "329_1304456155.152" 
    $P7387."add_method"($P7388, "infix:sym<==>", $P7389)
    nqp_get_sc_object $P7390, "1304456142.948", 1
    get_how $P7391, $P7390
    nqp_get_sc_object $P7392, "1304456142.948", 1
    .const 'Sub' $P7393 = "330_1304456155.152" 
    $P7391."add_method"($P7392, "!PREFIX__infix:sym<==>", $P7393)
    nqp_get_sc_object $P7394, "1304456142.948", 1
    get_how $P7395, $P7394
    nqp_get_sc_object $P7396, "1304456142.948", 1
    .const 'Sub' $P7397 = "331_1304456155.152" 
    $P7395."add_method"($P7396, "infix:sym<!=>", $P7397)
    nqp_get_sc_object $P7398, "1304456142.948", 1
    get_how $P7399, $P7398
    nqp_get_sc_object $P7400, "1304456142.948", 1
    .const 'Sub' $P7401 = "332_1304456155.152" 
    $P7399."add_method"($P7400, "!PREFIX__infix:sym<!=>", $P7401)
    nqp_get_sc_object $P7402, "1304456142.948", 1
    get_how $P7403, $P7402
    nqp_get_sc_object $P7404, "1304456142.948", 1
    .const 'Sub' $P7405 = "333_1304456155.152" 
    $P7403."add_method"($P7404, "infix:sym<<=>", $P7405)
    nqp_get_sc_object $P7406, "1304456142.948", 1
    get_how $P7407, $P7406
    nqp_get_sc_object $P7408, "1304456142.948", 1
    .const 'Sub' $P7409 = "334_1304456155.152" 
    $P7407."add_method"($P7408, "!PREFIX__infix:sym<<=>", $P7409)
    nqp_get_sc_object $P7410, "1304456142.948", 1
    get_how $P7411, $P7410
    nqp_get_sc_object $P7412, "1304456142.948", 1
    .const 'Sub' $P7413 = "335_1304456155.152" 
    $P7411."add_method"($P7412, "infix:sym<>=>", $P7413)
    nqp_get_sc_object $P7414, "1304456142.948", 1
    get_how $P7415, $P7414
    nqp_get_sc_object $P7416, "1304456142.948", 1
    .const 'Sub' $P7417 = "336_1304456155.152" 
    $P7415."add_method"($P7416, "!PREFIX__infix:sym<>=>", $P7417)
    nqp_get_sc_object $P7418, "1304456142.948", 1
    get_how $P7419, $P7418
    nqp_get_sc_object $P7420, "1304456142.948", 1
    .const 'Sub' $P7421 = "337_1304456155.152" 
    $P7419."add_method"($P7420, "infix:sym<<>", $P7421)
    nqp_get_sc_object $P7422, "1304456142.948", 1
    get_how $P7423, $P7422
    nqp_get_sc_object $P7424, "1304456142.948", 1
    .const 'Sub' $P7425 = "338_1304456155.152" 
    $P7423."add_method"($P7424, "!PREFIX__infix:sym<<>", $P7425)
    nqp_get_sc_object $P7426, "1304456142.948", 1
    get_how $P7427, $P7426
    nqp_get_sc_object $P7428, "1304456142.948", 1
    .const 'Sub' $P7429 = "339_1304456155.152" 
    $P7427."add_method"($P7428, "infix:sym<>>", $P7429)
    nqp_get_sc_object $P7430, "1304456142.948", 1
    get_how $P7431, $P7430
    nqp_get_sc_object $P7432, "1304456142.948", 1
    .const 'Sub' $P7433 = "340_1304456155.152" 
    $P7431."add_method"($P7432, "!PREFIX__infix:sym<>>", $P7433)
    nqp_get_sc_object $P7434, "1304456142.948", 1
    get_how $P7435, $P7434
    nqp_get_sc_object $P7436, "1304456142.948", 1
    .const 'Sub' $P7437 = "341_1304456155.152" 
    $P7435."add_method"($P7436, "infix:sym<eq>", $P7437)
    nqp_get_sc_object $P7438, "1304456142.948", 1
    get_how $P7439, $P7438
    nqp_get_sc_object $P7440, "1304456142.948", 1
    .const 'Sub' $P7441 = "342_1304456155.152" 
    $P7439."add_method"($P7440, "!PREFIX__infix:sym<eq>", $P7441)
    nqp_get_sc_object $P7442, "1304456142.948", 1
    get_how $P7443, $P7442
    nqp_get_sc_object $P7444, "1304456142.948", 1
    .const 'Sub' $P7445 = "343_1304456155.152" 
    $P7443."add_method"($P7444, "infix:sym<ne>", $P7445)
    nqp_get_sc_object $P7446, "1304456142.948", 1
    get_how $P7447, $P7446
    nqp_get_sc_object $P7448, "1304456142.948", 1
    .const 'Sub' $P7449 = "344_1304456155.152" 
    $P7447."add_method"($P7448, "!PREFIX__infix:sym<ne>", $P7449)
    nqp_get_sc_object $P7450, "1304456142.948", 1
    get_how $P7451, $P7450
    nqp_get_sc_object $P7452, "1304456142.948", 1
    .const 'Sub' $P7453 = "345_1304456155.152" 
    $P7451."add_method"($P7452, "infix:sym<le>", $P7453)
    nqp_get_sc_object $P7454, "1304456142.948", 1
    get_how $P7455, $P7454
    nqp_get_sc_object $P7456, "1304456142.948", 1
    .const 'Sub' $P7457 = "346_1304456155.152" 
    $P7455."add_method"($P7456, "!PREFIX__infix:sym<le>", $P7457)
    nqp_get_sc_object $P7458, "1304456142.948", 1
    get_how $P7459, $P7458
    nqp_get_sc_object $P7460, "1304456142.948", 1
    .const 'Sub' $P7461 = "347_1304456155.152" 
    $P7459."add_method"($P7460, "infix:sym<ge>", $P7461)
    nqp_get_sc_object $P7462, "1304456142.948", 1
    get_how $P7463, $P7462
    nqp_get_sc_object $P7464, "1304456142.948", 1
    .const 'Sub' $P7465 = "348_1304456155.152" 
    $P7463."add_method"($P7464, "!PREFIX__infix:sym<ge>", $P7465)
    nqp_get_sc_object $P7466, "1304456142.948", 1
    get_how $P7467, $P7466
    nqp_get_sc_object $P7468, "1304456142.948", 1
    .const 'Sub' $P7469 = "349_1304456155.152" 
    $P7467."add_method"($P7468, "infix:sym<lt>", $P7469)
    nqp_get_sc_object $P7470, "1304456142.948", 1
    get_how $P7471, $P7470
    nqp_get_sc_object $P7472, "1304456142.948", 1
    .const 'Sub' $P7473 = "350_1304456155.152" 
    $P7471."add_method"($P7472, "!PREFIX__infix:sym<lt>", $P7473)
    nqp_get_sc_object $P7474, "1304456142.948", 1
    get_how $P7475, $P7474
    nqp_get_sc_object $P7476, "1304456142.948", 1
    .const 'Sub' $P7477 = "351_1304456155.152" 
    $P7475."add_method"($P7476, "infix:sym<gt>", $P7477)
    nqp_get_sc_object $P7478, "1304456142.948", 1
    get_how $P7479, $P7478
    nqp_get_sc_object $P7480, "1304456142.948", 1
    .const 'Sub' $P7481 = "352_1304456155.152" 
    $P7479."add_method"($P7480, "!PREFIX__infix:sym<gt>", $P7481)
    nqp_get_sc_object $P7482, "1304456142.948", 1
    get_how $P7483, $P7482
    nqp_get_sc_object $P7484, "1304456142.948", 1
    .const 'Sub' $P7485 = "353_1304456155.152" 
    $P7483."add_method"($P7484, "infix:sym<=:=>", $P7485)
    nqp_get_sc_object $P7486, "1304456142.948", 1
    get_how $P7487, $P7486
    nqp_get_sc_object $P7488, "1304456142.948", 1
    .const 'Sub' $P7489 = "354_1304456155.152" 
    $P7487."add_method"($P7488, "!PREFIX__infix:sym<=:=>", $P7489)
    nqp_get_sc_object $P7490, "1304456142.948", 1
    get_how $P7491, $P7490
    nqp_get_sc_object $P7492, "1304456142.948", 1
    .const 'Sub' $P7493 = "355_1304456155.152" 
    $P7491."add_method"($P7492, "infix:sym<~~>", $P7493)
    nqp_get_sc_object $P7494, "1304456142.948", 1
    get_how $P7495, $P7494
    nqp_get_sc_object $P7496, "1304456142.948", 1
    .const 'Sub' $P7497 = "356_1304456155.152" 
    $P7495."add_method"($P7496, "!PREFIX__infix:sym<~~>", $P7497)
    nqp_get_sc_object $P7498, "1304456142.948", 1
    get_how $P7499, $P7498
    nqp_get_sc_object $P7500, "1304456142.948", 1
    .const 'Sub' $P7501 = "357_1304456155.152" 
    $P7499."add_method"($P7500, "infix:sym<&&>", $P7501)
    nqp_get_sc_object $P7502, "1304456142.948", 1
    get_how $P7503, $P7502
    nqp_get_sc_object $P7504, "1304456142.948", 1
    .const 'Sub' $P7505 = "358_1304456155.152" 
    $P7503."add_method"($P7504, "!PREFIX__infix:sym<&&>", $P7505)
    nqp_get_sc_object $P7506, "1304456142.948", 1
    get_how $P7507, $P7506
    nqp_get_sc_object $P7508, "1304456142.948", 1
    .const 'Sub' $P7509 = "359_1304456155.152" 
    $P7507."add_method"($P7508, "infix:sym<||>", $P7509)
    nqp_get_sc_object $P7510, "1304456142.948", 1
    get_how $P7511, $P7510
    nqp_get_sc_object $P7512, "1304456142.948", 1
    .const 'Sub' $P7513 = "360_1304456155.152" 
    $P7511."add_method"($P7512, "!PREFIX__infix:sym<||>", $P7513)
    nqp_get_sc_object $P7514, "1304456142.948", 1
    get_how $P7515, $P7514
    nqp_get_sc_object $P7516, "1304456142.948", 1
    .const 'Sub' $P7517 = "361_1304456155.152" 
    $P7515."add_method"($P7516, "infix:sym<//>", $P7517)
    nqp_get_sc_object $P7518, "1304456142.948", 1
    get_how $P7519, $P7518
    nqp_get_sc_object $P7520, "1304456142.948", 1
    .const 'Sub' $P7521 = "362_1304456155.152" 
    $P7519."add_method"($P7520, "!PREFIX__infix:sym<//>", $P7521)
    nqp_get_sc_object $P7522, "1304456142.948", 1
    get_how $P7523, $P7522
    nqp_get_sc_object $P7524, "1304456142.948", 1
    .const 'Sub' $P7525 = "363_1304456155.152" 
    $P7523."add_method"($P7524, "infix:sym<?? !!>", $P7525)
    nqp_get_sc_object $P7526, "1304456142.948", 1
    get_how $P7527, $P7526
    nqp_get_sc_object $P7528, "1304456142.948", 1
    .const 'Sub' $P7529 = "364_1304456155.152" 
    $P7527."add_method"($P7528, "!PREFIX__infix:sym<?? !!>", $P7529)
    nqp_get_sc_object $P7530, "1304456142.948", 1
    get_how $P7531, $P7530
    nqp_get_sc_object $P7532, "1304456142.948", 1
    .const 'Sub' $P7533 = "365_1304456155.152" 
    $P7531."add_method"($P7532, "infix:sym<=>", $P7533)
    nqp_get_sc_object $P7534, "1304456142.948", 1
    get_how $P7535, $P7534
    nqp_get_sc_object $P7536, "1304456142.948", 1
    .const 'Sub' $P7537 = "366_1304456155.152" 
    $P7535."add_method"($P7536, "!PREFIX__infix:sym<=>", $P7537)
    nqp_get_sc_object $P7538, "1304456142.948", 1
    get_how $P7539, $P7538
    nqp_get_sc_object $P7540, "1304456142.948", 1
    .const 'Sub' $P7541 = "367_1304456155.152" 
    $P7539."add_method"($P7540, "infix:sym<:=>", $P7541)
    nqp_get_sc_object $P7542, "1304456142.948", 1
    get_how $P7543, $P7542
    nqp_get_sc_object $P7544, "1304456142.948", 1
    .const 'Sub' $P7545 = "368_1304456155.152" 
    $P7543."add_method"($P7544, "!PREFIX__infix:sym<:=>", $P7545)
    nqp_get_sc_object $P7546, "1304456142.948", 1
    get_how $P7547, $P7546
    nqp_get_sc_object $P7548, "1304456142.948", 1
    .const 'Sub' $P7549 = "369_1304456155.152" 
    $P7547."add_method"($P7548, "infix:sym<::=>", $P7549)
    nqp_get_sc_object $P7550, "1304456142.948", 1
    get_how $P7551, $P7550
    nqp_get_sc_object $P7552, "1304456142.948", 1
    .const 'Sub' $P7553 = "370_1304456155.152" 
    $P7551."add_method"($P7552, "!PREFIX__infix:sym<::=>", $P7553)
    nqp_get_sc_object $P7554, "1304456142.948", 1
    get_how $P7555, $P7554
    nqp_get_sc_object $P7556, "1304456142.948", 1
    .const 'Sub' $P7557 = "371_1304456155.152" 
    $P7555."add_method"($P7556, "infix:sym<,>", $P7557)
    nqp_get_sc_object $P7558, "1304456142.948", 1
    get_how $P7559, $P7558
    nqp_get_sc_object $P7560, "1304456142.948", 1
    .const 'Sub' $P7561 = "372_1304456155.152" 
    $P7559."add_method"($P7560, "!PREFIX__infix:sym<,>", $P7561)
    nqp_get_sc_object $P7562, "1304456142.948", 1
    get_how $P7563, $P7562
    nqp_get_sc_object $P7564, "1304456142.948", 1
    .const 'Sub' $P7565 = "373_1304456155.152" 
    $P7563."add_method"($P7564, "prefix:sym<return>", $P7565)
    nqp_get_sc_object $P7566, "1304456142.948", 1
    get_how $P7567, $P7566
    nqp_get_sc_object $P7568, "1304456142.948", 1
    .const 'Sub' $P7569 = "375_1304456155.152" 
    $P7567."add_method"($P7568, "!PREFIX__prefix:sym<return>", $P7569)
    nqp_get_sc_object $P7570, "1304456142.948", 1
    get_how $P7571, $P7570
    nqp_get_sc_object $P7572, "1304456142.948", 1
    .const 'Sub' $P7573 = "376_1304456155.152" 
    $P7571."add_method"($P7572, "prefix:sym<make>", $P7573)
    nqp_get_sc_object $P7574, "1304456142.948", 1
    get_how $P7575, $P7574
    nqp_get_sc_object $P7576, "1304456142.948", 1
    .const 'Sub' $P7577 = "377_1304456155.152" 
    $P7575."add_method"($P7576, "!PREFIX__prefix:sym<make>", $P7577)
    nqp_get_sc_object $P7578, "1304456142.948", 1
    get_how $P7579, $P7578
    nqp_get_sc_object $P7580, "1304456142.948", 1
    .const 'Sub' $P7581 = "378_1304456155.152" 
    $P7579."add_method"($P7580, "term:sym<last>", $P7581)
    nqp_get_sc_object $P7582, "1304456142.948", 1
    get_how $P7583, $P7582
    nqp_get_sc_object $P7584, "1304456142.948", 1
    .const 'Sub' $P7585 = "379_1304456155.152" 
    $P7583."add_method"($P7584, "!PREFIX__term:sym<last>", $P7585)
    nqp_get_sc_object $P7586, "1304456142.948", 1
    get_how $P7587, $P7586
    nqp_get_sc_object $P7588, "1304456142.948", 1
    .const 'Sub' $P7589 = "380_1304456155.152" 
    $P7587."add_method"($P7588, "term:sym<next>", $P7589)
    nqp_get_sc_object $P7590, "1304456142.948", 1
    get_how $P7591, $P7590
    nqp_get_sc_object $P7592, "1304456142.948", 1
    .const 'Sub' $P7593 = "381_1304456155.152" 
    $P7591."add_method"($P7592, "!PREFIX__term:sym<next>", $P7593)
    nqp_get_sc_object $P7594, "1304456142.948", 1
    get_how $P7595, $P7594
    nqp_get_sc_object $P7596, "1304456142.948", 1
    .const 'Sub' $P7597 = "382_1304456155.152" 
    $P7595."add_method"($P7596, "term:sym<redo>", $P7597)
    nqp_get_sc_object $P7598, "1304456142.948", 1
    get_how $P7599, $P7598
    nqp_get_sc_object $P7600, "1304456142.948", 1
    .const 'Sub' $P7601 = "383_1304456155.152" 
    $P7599."add_method"($P7600, "!PREFIX__term:sym<redo>", $P7601)
    nqp_get_sc_object $P7602, "1304456142.948", 1
    get_how $P7603, $P7602
    nqp_get_sc_object $P7604, "1304456142.948", 1
    .const 'Sub' $P7605 = "384_1304456155.152" 
    $P7603."add_method"($P7604, "smartmatch", $P7605)
    .const 'Sub' $P7606 = "12_1304456155.152" 
    $P7607 = $P7606."get_lexinfo"()
    nqp_get_sc_object $P7608, "1304456142.948", 1
    $P7607."set_static_lexpad_value"("$?PACKAGE", $P7608)
    .const 'Sub' $P7609 = "12_1304456155.152" 
    $P7610 = $P7609."get_lexinfo"()
    $P7610."finish_static_lexpad"()
    .const 'Sub' $P7611 = "12_1304456155.152" 
    $P7612 = $P7611."get_lexinfo"()
    nqp_get_sc_object $P7613, "1304456142.948", 1
    $P7612."set_static_lexpad_value"("$?CLASS", $P7613)
    .const 'Sub' $P7614 = "12_1304456155.152" 
    $P7615 = $P7614."get_lexinfo"()
    $P7615."finish_static_lexpad"()
    nqp_get_sc_object $P7616, "1304456142.948", 1
    get_how $P7617, $P7616
    nqp_get_sc_object $P7618, "1304456142.948", 1
    nqp_get_sc_object $P7619, "1304456124.041", 1
    $P7617."add_parent"($P7618, $P7619)
    nqp_get_sc_object $P7620, "1304456142.948", 1
    get_how $P7621, $P7620
    nqp_get_sc_object $P7622, "1304456142.948", 1
    $P7621."compose"($P7622)
    nqp_get_sc_object $P7623, "1304456116.562", 41
    $P7624 = $P7623."new_type"("NQP::Regex" :named("name"))
    nqp_set_sc_for_object $P7624, cur_sc
    nqp_set_sc_object "1304456142.948", 360, $P7624
    nqp_get_sc_object $P7625, "1304456142.948", 360
    nqp_get_sc_object $P7626, "1304456142.948", 0
    nqp_get_package_through_who $P7627, $P7626, "NQP"
    get_who $P7628, $P7627
    set $P7628["Regex"], $P7625
    nqp_get_sc_object $P7629, "1304456142.948", 360
    get_how $P7630, $P7629
    nqp_get_sc_object $P7631, "1304456142.948", 360
    .const 'Sub' $P7632 = "386_1304456155.152" 
    $P7630."add_method"($P7631, "metachar:sym<:my>", $P7632)
    nqp_get_sc_object $P7633, "1304456142.948", 360
    get_how $P7634, $P7633
    nqp_get_sc_object $P7635, "1304456142.948", 360
    .const 'Sub' $P7636 = "388_1304456155.152" 
    $P7634."add_method"($P7635, "!PREFIX__metachar:sym<:my>", $P7636)
    nqp_get_sc_object $P7637, "1304456142.948", 360
    get_how $P7638, $P7637
    nqp_get_sc_object $P7639, "1304456142.948", 360
    .const 'Sub' $P7640 = "389_1304456155.152" 
    $P7638."add_method"($P7639, "metachar:sym<{ }>", $P7640)
    nqp_get_sc_object $P7641, "1304456142.948", 360
    get_how $P7642, $P7641
    nqp_get_sc_object $P7643, "1304456142.948", 360
    .const 'Sub' $P7644 = "390_1304456155.152" 
    $P7642."add_method"($P7643, "!PREFIX__metachar:sym<{ }>", $P7644)
    nqp_get_sc_object $P7645, "1304456142.948", 360
    get_how $P7646, $P7645
    nqp_get_sc_object $P7647, "1304456142.948", 360
    .const 'Sub' $P7648 = "391_1304456155.152" 
    $P7646."add_method"($P7647, "metachar:sym<nqpvar>", $P7648)
    nqp_get_sc_object $P7649, "1304456142.948", 360
    get_how $P7650, $P7649
    nqp_get_sc_object $P7651, "1304456142.948", 360
    .const 'Sub' $P7652 = "393_1304456155.152" 
    $P7650."add_method"($P7651, "!PREFIX__metachar:sym<nqpvar>", $P7652)
    nqp_get_sc_object $P7653, "1304456142.948", 360
    get_how $P7654, $P7653
    nqp_get_sc_object $P7655, "1304456142.948", 360
    .const 'Sub' $P7656 = "394_1304456155.152" 
    $P7654."add_method"($P7655, "assertion:sym<{ }>", $P7656)
    nqp_get_sc_object $P7657, "1304456142.948", 360
    get_how $P7658, $P7657
    nqp_get_sc_object $P7659, "1304456142.948", 360
    .const 'Sub' $P7660 = "395_1304456155.152" 
    $P7658."add_method"($P7659, "!PREFIX__assertion:sym<{ }>", $P7660)
    nqp_get_sc_object $P7661, "1304456142.948", 360
    get_how $P7662, $P7661
    nqp_get_sc_object $P7663, "1304456142.948", 360
    .const 'Sub' $P7664 = "396_1304456155.152" 
    $P7662."add_method"($P7663, "assertion:sym<?{ }>", $P7664)
    nqp_get_sc_object $P7665, "1304456142.948", 360
    get_how $P7666, $P7665
    nqp_get_sc_object $P7667, "1304456142.948", 360
    .const 'Sub' $P7668 = "398_1304456155.152" 
    $P7666."add_method"($P7667, "!PREFIX__assertion:sym<?{ }>", $P7668)
    nqp_get_sc_object $P7669, "1304456142.948", 360
    get_how $P7670, $P7669
    nqp_get_sc_object $P7671, "1304456142.948", 360
    .const 'Sub' $P7672 = "399_1304456155.152" 
    $P7670."add_method"($P7671, "assertion:sym<name>", $P7672)
    nqp_get_sc_object $P7673, "1304456142.948", 360
    get_how $P7674, $P7673
    nqp_get_sc_object $P7675, "1304456142.948", 360
    .const 'Sub' $P7676 = "401_1304456155.152" 
    $P7674."add_method"($P7675, "!PREFIX__assertion:sym<name>", $P7676)
    nqp_get_sc_object $P7677, "1304456142.948", 360
    get_how $P7678, $P7677
    nqp_get_sc_object $P7679, "1304456142.948", 360
    .const 'Sub' $P7680 = "402_1304456155.152" 
    $P7678."add_method"($P7679, "assertion:sym<var>", $P7680)
    nqp_get_sc_object $P7681, "1304456142.948", 360
    get_how $P7682, $P7681
    nqp_get_sc_object $P7683, "1304456142.948", 360
    .const 'Sub' $P7684 = "403_1304456155.152" 
    $P7682."add_method"($P7683, "!PREFIX__assertion:sym<var>", $P7684)
    nqp_get_sc_object $P7685, "1304456142.948", 360
    get_how $P7686, $P7685
    nqp_get_sc_object $P7687, "1304456142.948", 360
    .const 'Sub' $P7688 = "404_1304456155.152" 
    $P7686."add_method"($P7687, "codeblock", $P7688)
    nqp_get_sc_object $P7689, "1304456142.948", 360
    get_how $P7690, $P7689
    nqp_get_sc_object $P7691, "1304456142.948", 360
    .const 'Sub' $P7692 = "405_1304456155.152" 
    $P7690."add_method"($P7691, "!PREFIX__codeblock", $P7692)
    .const 'Sub' $P7693 = "385_1304456155.152" 
    $P7694 = $P7693."get_lexinfo"()
    nqp_get_sc_object $P7695, "1304456142.948", 360
    $P7694."set_static_lexpad_value"("$?PACKAGE", $P7695)
    .const 'Sub' $P7696 = "385_1304456155.152" 
    $P7697 = $P7696."get_lexinfo"()
    $P7697."finish_static_lexpad"()
    .const 'Sub' $P7698 = "385_1304456155.152" 
    $P7699 = $P7698."get_lexinfo"()
    nqp_get_sc_object $P7700, "1304456142.948", 360
    $P7699."set_static_lexpad_value"("$?CLASS", $P7700)
    .const 'Sub' $P7701 = "385_1304456155.152" 
    $P7702 = $P7701."get_lexinfo"()
    $P7702."finish_static_lexpad"()
    nqp_get_sc_object $P7703, "1304456142.948", 360
    get_how $P7704, $P7703
    nqp_get_sc_object $P7705, "1304456142.948", 360
    nqp_get_sc_object $P7706, "1304456135.999", 1
    $P7704."add_parent"($P7705, $P7706)
    nqp_get_sc_object $P7707, "1304456142.948", 360
    get_how $P7708, $P7707
    nqp_get_sc_object $P7709, "1304456142.948", 360
    $P7708."compose"($P7709)
    nqp_get_sc_object $P7710, "1304456116.562", 41
    $P7711 = $P7710."new_type"("NQP::Actions" :named("name"))
    nqp_set_sc_for_object $P7711, cur_sc
    nqp_set_sc_object "1304456142.948", 377, $P7711
    nqp_get_sc_object $P7712, "1304456142.948", 377
    nqp_get_sc_object $P7713, "1304456142.948", 0
    nqp_get_package_through_who $P7714, $P7713, "NQP"
    get_who $P7715, $P7714
    set $P7715["Actions"], $P7712
    nqp_get_sc_object $P7716, "1304456142.948", 377
    get_how $P7717, $P7716
    nqp_get_sc_object $P7718, "1304456142.948", 377
    .const 'Sub' $P7719 = "433_1304456155.152" 
    $P7717."add_method"($P7718, "TOP", $P7719)
    nqp_get_sc_object $P7720, "1304456142.948", 377
    get_how $P7721, $P7720
    nqp_get_sc_object $P7722, "1304456142.948", 377
    .const 'Sub' $P7723 = "434_1304456155.152" 
    $P7721."add_method"($P7722, "deflongname", $P7723)
    nqp_get_sc_object $P7724, "1304456142.948", 377
    get_how $P7725, $P7724
    nqp_get_sc_object $P7726, "1304456142.948", 377
    .const 'Sub' $P7727 = "435_1304456155.152" 
    $P7725."add_method"($P7726, "comp_unit", $P7727)
    nqp_get_sc_object $P7728, "1304456142.948", 377
    get_how $P7729, $P7728
    nqp_get_sc_object $P7730, "1304456142.948", 377
    .const 'Sub' $P7731 = "436_1304456155.152" 
    $P7729."add_method"($P7730, "statementlist", $P7731)
    nqp_get_sc_object $P7732, "1304456142.948", 377
    get_how $P7733, $P7732
    nqp_get_sc_object $P7734, "1304456142.948", 377
    .const 'Sub' $P7735 = "438_1304456155.152" 
    $P7733."add_method"($P7734, "statement", $P7735)
    nqp_get_sc_object $P7736, "1304456142.948", 377
    get_how $P7737, $P7736
    nqp_get_sc_object $P7738, "1304456142.948", 377
    .const 'Sub' $P7739 = "440_1304456155.152" 
    $P7737."add_method"($P7738, "xblock", $P7739)
    nqp_get_sc_object $P7740, "1304456142.948", 377
    get_how $P7741, $P7740
    nqp_get_sc_object $P7742, "1304456142.948", 377
    .const 'Sub' $P7743 = "441_1304456155.152" 
    $P7741."add_method"($P7742, "pblock", $P7743)
    nqp_get_sc_object $P7744, "1304456142.948", 377
    get_how $P7745, $P7744
    nqp_get_sc_object $P7746, "1304456142.948", 377
    .const 'Sub' $P7747 = "442_1304456155.152" 
    $P7745."add_method"($P7746, "block", $P7747)
    nqp_get_sc_object $P7748, "1304456142.948", 377
    get_how $P7749, $P7748
    nqp_get_sc_object $P7750, "1304456142.948", 377
    .const 'Sub' $P7751 = "443_1304456155.152" 
    $P7749."add_method"($P7750, "blockoid", $P7751)
    nqp_get_sc_object $P7752, "1304456142.948", 377
    get_how $P7753, $P7752
    nqp_get_sc_object $P7754, "1304456142.948", 377
    .const 'Sub' $P7755 = "445_1304456155.152" 
    $P7753."add_method"($P7754, "newpad", $P7755)
    nqp_get_sc_object $P7756, "1304456142.948", 377
    get_how $P7757, $P7756
    nqp_get_sc_object $P7758, "1304456142.948", 377
    .const 'Sub' $P7759 = "446_1304456155.152" 
    $P7757."add_method"($P7758, "outerctx", $P7759)
    nqp_get_sc_object $P7760, "1304456142.948", 377
    get_how $P7761, $P7760
    nqp_get_sc_object $P7762, "1304456142.948", 377
    .const 'Sub' $P7763 = "448_1304456155.152" 
    $P7761."add_method"($P7762, "GLOBALish", $P7763)
    nqp_get_sc_object $P7764, "1304456142.948", 377
    get_how $P7765, $P7764
    nqp_get_sc_object $P7766, "1304456142.948", 377
    .const 'Sub' $P7767 = "449_1304456155.152" 
    $P7765."add_method"($P7766, "you_are_here", $P7767)
    nqp_get_sc_object $P7768, "1304456142.948", 377
    get_how $P7769, $P7768
    nqp_get_sc_object $P7770, "1304456142.948", 377
    .const 'Sub' $P7771 = "450_1304456155.152" 
    $P7769."add_method"($P7770, "statement_control:sym<use>", $P7771)
    nqp_get_sc_object $P7772, "1304456142.948", 377
    get_how $P7773, $P7772
    nqp_get_sc_object $P7774, "1304456142.948", 377
    .const 'Sub' $P7775 = "451_1304456155.152" 
    $P7773."add_method"($P7774, "statement_control:sym<if>", $P7775)
    nqp_get_sc_object $P7776, "1304456142.948", 377
    get_how $P7777, $P7776
    nqp_get_sc_object $P7778, "1304456142.948", 377
    .const 'Sub' $P7779 = "453_1304456155.152" 
    $P7777."add_method"($P7778, "statement_control:sym<unless>", $P7779)
    nqp_get_sc_object $P7780, "1304456142.948", 377
    get_how $P7781, $P7780
    nqp_get_sc_object $P7782, "1304456142.948", 377
    .const 'Sub' $P7783 = "454_1304456155.152" 
    $P7781."add_method"($P7782, "statement_control:sym<while>", $P7783)
    nqp_get_sc_object $P7784, "1304456142.948", 377
    get_how $P7785, $P7784
    nqp_get_sc_object $P7786, "1304456142.948", 377
    .const 'Sub' $P7787 = "455_1304456155.152" 
    $P7785."add_method"($P7786, "statement_control:sym<repeat>", $P7787)
    nqp_get_sc_object $P7788, "1304456142.948", 377
    get_how $P7789, $P7788
    nqp_get_sc_object $P7790, "1304456142.948", 377
    .const 'Sub' $P7791 = "456_1304456155.152" 
    $P7789."add_method"($P7790, "statement_control:sym<for>", $P7791)
    nqp_get_sc_object $P7792, "1304456142.948", 377
    get_how $P7793, $P7792
    nqp_get_sc_object $P7794, "1304456142.948", 377
    .const 'Sub' $P7795 = "457_1304456155.152" 
    $P7793."add_method"($P7794, "statement_control:sym<CATCH>", $P7795)
    nqp_get_sc_object $P7796, "1304456142.948", 377
    get_how $P7797, $P7796
    nqp_get_sc_object $P7798, "1304456142.948", 377
    .const 'Sub' $P7799 = "458_1304456155.152" 
    $P7797."add_method"($P7798, "statement_control:sym<CONTROL>", $P7799)
    nqp_get_sc_object $P7800, "1304456142.948", 377
    get_how $P7801, $P7800
    nqp_get_sc_object $P7802, "1304456142.948", 377
    .const 'Sub' $P7803 = "459_1304456155.152" 
    $P7801."add_method"($P7802, "statement_prefix:sym<INIT>", $P7803)
    nqp_get_sc_object $P7804, "1304456142.948", 377
    get_how $P7805, $P7804
    nqp_get_sc_object $P7806, "1304456142.948", 377
    .const 'Sub' $P7807 = "460_1304456155.152" 
    $P7805."add_method"($P7806, "statement_prefix:sym<try>", $P7807)
    nqp_get_sc_object $P7808, "1304456142.948", 377
    get_how $P7809, $P7808
    nqp_get_sc_object $P7810, "1304456142.948", 377
    .const 'Sub' $P7811 = "461_1304456155.152" 
    $P7809."add_method"($P7810, "blorst", $P7811)
    nqp_get_sc_object $P7812, "1304456142.948", 377
    get_how $P7813, $P7812
    nqp_get_sc_object $P7814, "1304456142.948", 377
    .const 'Sub' $P7815 = "462_1304456155.152" 
    $P7813."add_method"($P7814, "statement_mod_cond:sym<if>", $P7815)
    nqp_get_sc_object $P7816, "1304456142.948", 377
    get_how $P7817, $P7816
    nqp_get_sc_object $P7818, "1304456142.948", 377
    .const 'Sub' $P7819 = "463_1304456155.152" 
    $P7817."add_method"($P7818, "statement_mod_cond:sym<unless>", $P7819)
    nqp_get_sc_object $P7820, "1304456142.948", 377
    get_how $P7821, $P7820
    nqp_get_sc_object $P7822, "1304456142.948", 377
    .const 'Sub' $P7823 = "464_1304456155.152" 
    $P7821."add_method"($P7822, "statement_mod_loop:sym<while>", $P7823)
    nqp_get_sc_object $P7824, "1304456142.948", 377
    get_how $P7825, $P7824
    nqp_get_sc_object $P7826, "1304456142.948", 377
    .const 'Sub' $P7827 = "465_1304456155.152" 
    $P7825."add_method"($P7826, "statement_mod_loop:sym<until>", $P7827)
    nqp_get_sc_object $P7828, "1304456142.948", 377
    get_how $P7829, $P7828
    nqp_get_sc_object $P7830, "1304456142.948", 377
    .const 'Sub' $P7831 = "466_1304456155.152" 
    $P7829."add_method"($P7830, "term:sym<fatarrow>", $P7831)
    nqp_get_sc_object $P7832, "1304456142.948", 377
    get_how $P7833, $P7832
    nqp_get_sc_object $P7834, "1304456142.948", 377
    .const 'Sub' $P7835 = "467_1304456155.152" 
    $P7833."add_method"($P7834, "term:sym<colonpair>", $P7835)
    nqp_get_sc_object $P7836, "1304456142.948", 377
    get_how $P7837, $P7836
    nqp_get_sc_object $P7838, "1304456142.948", 377
    .const 'Sub' $P7839 = "468_1304456155.152" 
    $P7837."add_method"($P7838, "term:sym<variable>", $P7839)
    nqp_get_sc_object $P7840, "1304456142.948", 377
    get_how $P7841, $P7840
    nqp_get_sc_object $P7842, "1304456142.948", 377
    .const 'Sub' $P7843 = "469_1304456155.152" 
    $P7841."add_method"($P7842, "term:sym<package_declarator>", $P7843)
    nqp_get_sc_object $P7844, "1304456142.948", 377
    get_how $P7845, $P7844
    nqp_get_sc_object $P7846, "1304456142.948", 377
    .const 'Sub' $P7847 = "470_1304456155.152" 
    $P7845."add_method"($P7846, "term:sym<scope_declarator>", $P7847)
    nqp_get_sc_object $P7848, "1304456142.948", 377
    get_how $P7849, $P7848
    nqp_get_sc_object $P7850, "1304456142.948", 377
    .const 'Sub' $P7851 = "471_1304456155.152" 
    $P7849."add_method"($P7850, "term:sym<routine_declarator>", $P7851)
    nqp_get_sc_object $P7852, "1304456142.948", 377
    get_how $P7853, $P7852
    nqp_get_sc_object $P7854, "1304456142.948", 377
    .const 'Sub' $P7855 = "472_1304456155.152" 
    $P7853."add_method"($P7854, "term:sym<regex_declarator>", $P7855)
    nqp_get_sc_object $P7856, "1304456142.948", 377
    get_how $P7857, $P7856
    nqp_get_sc_object $P7858, "1304456142.948", 377
    .const 'Sub' $P7859 = "473_1304456155.152" 
    $P7857."add_method"($P7858, "term:sym<statement_prefix>", $P7859)
    nqp_get_sc_object $P7860, "1304456142.948", 377
    get_how $P7861, $P7860
    nqp_get_sc_object $P7862, "1304456142.948", 377
    .const 'Sub' $P7863 = "474_1304456155.152" 
    $P7861."add_method"($P7862, "term:sym<lambda>", $P7863)
    nqp_get_sc_object $P7864, "1304456142.948", 377
    get_how $P7865, $P7864
    nqp_get_sc_object $P7866, "1304456142.948", 377
    .const 'Sub' $P7867 = "475_1304456155.152" 
    $P7865."add_method"($P7866, "fatarrow", $P7867)
    nqp_get_sc_object $P7868, "1304456142.948", 377
    get_how $P7869, $P7868
    nqp_get_sc_object $P7870, "1304456142.948", 377
    .const 'Sub' $P7871 = "476_1304456155.152" 
    $P7869."add_method"($P7870, "colonpair", $P7871)
    nqp_get_sc_object $P7872, "1304456142.948", 377
    get_how $P7873, $P7872
    nqp_get_sc_object $P7874, "1304456142.948", 377
    .const 'Sub' $P7875 = "477_1304456155.152" 
    $P7873."add_method"($P7874, "variable", $P7875)
    nqp_get_sc_object $P7876, "1304456142.948", 377
    get_how $P7877, $P7876
    nqp_get_sc_object $P7878, "1304456142.948", 377
    .const 'Sub' $P7879 = "483_1304456155.152" 
    $P7877."add_method"($P7878, "package_declarator:sym<module>", $P7879)
    nqp_get_sc_object $P7880, "1304456142.948", 377
    get_how $P7881, $P7880
    nqp_get_sc_object $P7882, "1304456142.948", 377
    .const 'Sub' $P7883 = "484_1304456155.152" 
    $P7881."add_method"($P7882, "package_declarator:sym<knowhow>", $P7883)
    nqp_get_sc_object $P7884, "1304456142.948", 377
    get_how $P7885, $P7884
    nqp_get_sc_object $P7886, "1304456142.948", 377
    .const 'Sub' $P7887 = "485_1304456155.152" 
    $P7885."add_method"($P7886, "package_declarator:sym<class>", $P7887)
    nqp_get_sc_object $P7888, "1304456142.948", 377
    get_how $P7889, $P7888
    nqp_get_sc_object $P7890, "1304456142.948", 377
    .const 'Sub' $P7891 = "486_1304456155.152" 
    $P7889."add_method"($P7890, "package_declarator:sym<grammar>", $P7891)
    nqp_get_sc_object $P7892, "1304456142.948", 377
    get_how $P7893, $P7892
    nqp_get_sc_object $P7894, "1304456142.948", 377
    .const 'Sub' $P7895 = "487_1304456155.152" 
    $P7893."add_method"($P7894, "package_declarator:sym<role>", $P7895)
    nqp_get_sc_object $P7896, "1304456142.948", 377
    get_how $P7897, $P7896
    nqp_get_sc_object $P7898, "1304456142.948", 377
    .const 'Sub' $P7899 = "488_1304456155.152" 
    $P7897."add_method"($P7898, "package_declarator:sym<native>", $P7899)
    nqp_get_sc_object $P7900, "1304456142.948", 377
    get_how $P7901, $P7900
    nqp_get_sc_object $P7902, "1304456142.948", 377
    .const 'Sub' $P7903 = "489_1304456155.152" 
    $P7901."add_method"($P7902, "package_def", $P7903)
    nqp_get_sc_object $P7904, "1304456142.948", 377
    get_how $P7905, $P7904
    nqp_get_sc_object $P7906, "1304456142.948", 377
    .const 'Sub' $P7907 = "495_1304456155.152" 
    $P7905."add_method"($P7906, "scope_declarator:sym<my>", $P7907)
    nqp_get_sc_object $P7908, "1304456142.948", 377
    get_how $P7909, $P7908
    nqp_get_sc_object $P7910, "1304456142.948", 377
    .const 'Sub' $P7911 = "496_1304456155.152" 
    $P7909."add_method"($P7910, "scope_declarator:sym<our>", $P7911)
    nqp_get_sc_object $P7912, "1304456142.948", 377
    get_how $P7913, $P7912
    nqp_get_sc_object $P7914, "1304456142.948", 377
    .const 'Sub' $P7915 = "497_1304456155.152" 
    $P7913."add_method"($P7914, "scope_declarator:sym<has>", $P7915)
    nqp_get_sc_object $P7916, "1304456142.948", 377
    get_how $P7917, $P7916
    nqp_get_sc_object $P7918, "1304456142.948", 377
    .const 'Sub' $P7919 = "498_1304456155.152" 
    $P7917."add_method"($P7918, "scoped", $P7919)
    nqp_get_sc_object $P7920, "1304456142.948", 377
    get_how $P7921, $P7920
    nqp_get_sc_object $P7922, "1304456142.948", 377
    .const 'Sub' $P7923 = "499_1304456155.152" 
    $P7921."add_method"($P7922, "declarator", $P7923)
    nqp_get_sc_object $P7924, "1304456142.948", 377
    get_how $P7925, $P7924
    nqp_get_sc_object $P7926, "1304456142.948", 377
    .const 'Sub' $P7927 = "500_1304456155.152" 
    $P7925."add_method"($P7926, "multi_declarator:sym<multi>", $P7927)
    nqp_get_sc_object $P7928, "1304456142.948", 377
    get_how $P7929, $P7928
    nqp_get_sc_object $P7930, "1304456142.948", 377
    .const 'Sub' $P7931 = "501_1304456155.152" 
    $P7929."add_method"($P7930, "multi_declarator:sym<proto>", $P7931)
    nqp_get_sc_object $P7932, "1304456142.948", 377
    get_how $P7933, $P7932
    nqp_get_sc_object $P7934, "1304456142.948", 377
    .const 'Sub' $P7935 = "502_1304456155.152" 
    $P7933."add_method"($P7934, "multi_declarator:sym<null>", $P7935)
    nqp_get_sc_object $P7936, "1304456142.948", 377
    get_how $P7937, $P7936
    nqp_get_sc_object $P7938, "1304456142.948", 377
    .const 'Sub' $P7939 = "503_1304456155.152" 
    $P7937."add_method"($P7938, "variable_declarator", $P7939)
    nqp_get_sc_object $P7940, "1304456142.948", 377
    get_how $P7941, $P7940
    nqp_get_sc_object $P7942, "1304456142.948", 377
    .const 'Sub' $P7943 = "505_1304456155.152" 
    $P7941."add_method"($P7942, "routine_declarator:sym<sub>", $P7943)
    nqp_get_sc_object $P7944, "1304456142.948", 377
    get_how $P7945, $P7944
    nqp_get_sc_object $P7946, "1304456142.948", 377
    .const 'Sub' $P7947 = "506_1304456155.152" 
    $P7945."add_method"($P7946, "routine_declarator:sym<method>", $P7947)
    nqp_get_sc_object $P7948, "1304456142.948", 377
    get_how $P7949, $P7948
    nqp_get_sc_object $P7950, "1304456142.948", 377
    .const 'Sub' $P7951 = "507_1304456155.152" 
    $P7949."add_method"($P7950, "routine_def", $P7951)
    nqp_get_sc_object $P7952, "1304456142.948", 377
    get_how $P7953, $P7952
    nqp_get_sc_object $P7954, "1304456142.948", 377
    .const 'Sub' $P7955 = "514_1304456155.152" 
    $P7953."add_method"($P7954, "method_def", $P7955)
    nqp_get_sc_object $P7956, "1304456142.948", 377
    get_how $P7957, $P7956
    nqp_get_sc_object $P7958, "1304456142.948", 377
    .const 'Sub' $P7959 = "517_1304456155.152" 
    $P7957."add_method"($P7958, "signature", $P7959)
    nqp_get_sc_object $P7960, "1304456142.948", 377
    get_how $P7961, $P7960
    nqp_get_sc_object $P7962, "1304456142.948", 377
    .const 'Sub' $P7963 = "520_1304456155.152" 
    $P7961."add_method"($P7962, "parameter", $P7963)
    nqp_get_sc_object $P7964, "1304456142.948", 377
    get_how $P7965, $P7964
    nqp_get_sc_object $P7966, "1304456142.948", 377
    .const 'Sub' $P7967 = "521_1304456155.152" 
    $P7965."add_method"($P7966, "param_var", $P7967)
    nqp_get_sc_object $P7968, "1304456142.948", 377
    get_how $P7969, $P7968
    nqp_get_sc_object $P7970, "1304456142.948", 377
    .const 'Sub' $P7971 = "522_1304456155.152" 
    $P7969."add_method"($P7970, "named_param", $P7971)
    nqp_get_sc_object $P7972, "1304456142.948", 377
    get_how $P7973, $P7972
    nqp_get_sc_object $P7974, "1304456142.948", 377
    .const 'Sub' $P7975 = "523_1304456155.152" 
    $P7973."add_method"($P7974, "typename", $P7975)
    nqp_get_sc_object $P7976, "1304456142.948", 377
    get_how $P7977, $P7976
    nqp_get_sc_object $P7978, "1304456142.948", 377
    .const 'Sub' $P7979 = "525_1304456155.152" 
    $P7977."add_method"($P7978, "trait", $P7979)
    nqp_get_sc_object $P7980, "1304456142.948", 377
    get_how $P7981, $P7980
    nqp_get_sc_object $P7982, "1304456142.948", 377
    .const 'Sub' $P7983 = "526_1304456155.152" 
    $P7981."add_method"($P7982, "trait_mod:sym<is>", $P7983)
    nqp_get_sc_object $P7984, "1304456142.948", 377
    get_how $P7985, $P7984
    nqp_get_sc_object $P7986, "1304456142.948", 377
    .const 'Sub' $P7987 = "529_1304456155.152" 
    $P7985."add_method"($P7986, "regex_declarator", $P7987)
    nqp_get_sc_object $P7988, "1304456142.948", 377
    get_how $P7989, $P7988
    nqp_get_sc_object $P7990, "1304456142.948", 377
    .const 'Sub' $P7991 = "534_1304456155.152" 
    $P7989."add_method"($P7990, "dotty", $P7991)
    nqp_get_sc_object $P7992, "1304456142.948", 377
    get_how $P7993, $P7992
    nqp_get_sc_object $P7994, "1304456142.948", 377
    .const 'Sub' $P7995 = "535_1304456155.152" 
    $P7993."add_method"($P7994, "term:sym<self>", $P7995)
    nqp_get_sc_object $P7996, "1304456142.948", 377
    get_how $P7997, $P7996
    nqp_get_sc_object $P7998, "1304456142.948", 377
    .const 'Sub' $P7999 = "536_1304456155.152" 
    $P7997."add_method"($P7998, "term:sym<identifier>", $P7999)
    nqp_get_sc_object $P8000, "1304456142.948", 377
    get_how $P8001, $P8000
    nqp_get_sc_object $P8002, "1304456142.948", 377
    .const 'Sub' $P8003 = "537_1304456155.152" 
    $P8001."add_method"($P8002, "term:sym<name>", $P8003)
    nqp_get_sc_object $P8004, "1304456142.948", 377
    get_how $P8005, $P8004
    nqp_get_sc_object $P8006, "1304456142.948", 377
    .const 'Sub' $P8007 = "539_1304456155.152" 
    $P8005."add_method"($P8006, "term:sym<pir::op>", $P8007)
    nqp_get_sc_object $P8008, "1304456142.948", 377
    get_how $P8009, $P8008
    nqp_get_sc_object $P8010, "1304456142.948", 377
    .const 'Sub' $P8011 = "540_1304456155.152" 
    $P8009."add_method"($P8010, "term:sym<onlystar>", $P8011)
    nqp_get_sc_object $P8012, "1304456142.948", 377
    get_how $P8013, $P8012
    nqp_get_sc_object $P8014, "1304456142.948", 377
    .const 'Sub' $P8015 = "541_1304456155.152" 
    $P8013."add_method"($P8014, "args", $P8015)
    nqp_get_sc_object $P8016, "1304456142.948", 377
    get_how $P8017, $P8016
    nqp_get_sc_object $P8018, "1304456142.948", 377
    .const 'Sub' $P8019 = "542_1304456155.152" 
    $P8017."add_method"($P8018, "arglist", $P8019)
    nqp_get_sc_object $P8020, "1304456142.948", 377
    get_how $P8021, $P8020
    nqp_get_sc_object $P8022, "1304456142.948", 377
    .const 'Sub' $P8023 = "545_1304456155.152" 
    $P8021."add_method"($P8022, "term:sym<multi_declarator>", $P8023)
    nqp_get_sc_object $P8024, "1304456142.948", 377
    get_how $P8025, $P8024
    nqp_get_sc_object $P8026, "1304456142.948", 377
    .const 'Sub' $P8027 = "546_1304456155.152" 
    $P8025."add_method"($P8026, "term:sym<value>", $P8027)
    nqp_get_sc_object $P8028, "1304456142.948", 377
    get_how $P8029, $P8028
    nqp_get_sc_object $P8030, "1304456142.948", 377
    .const 'Sub' $P8031 = "547_1304456155.152" 
    $P8029."add_method"($P8030, "circumfix:sym<( )>", $P8031)
    nqp_get_sc_object $P8032, "1304456142.948", 377
    get_how $P8033, $P8032
    nqp_get_sc_object $P8034, "1304456142.948", 377
    .const 'Sub' $P8035 = "548_1304456155.152" 
    $P8033."add_method"($P8034, "circumfix:sym<[ ]>", $P8035)
    nqp_get_sc_object $P8036, "1304456142.948", 377
    get_how $P8037, $P8036
    nqp_get_sc_object $P8038, "1304456142.948", 377
    .const 'Sub' $P8039 = "549_1304456155.152" 
    $P8037."add_method"($P8038, "circumfix:sym<ang>", $P8039)
    nqp_get_sc_object $P8040, "1304456142.948", 377
    get_how $P8041, $P8040
    nqp_get_sc_object $P8042, "1304456142.948", 377
    .const 'Sub' $P8043 = "550_1304456155.152" 
    $P8041."add_method"($P8042, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P8043)
    nqp_get_sc_object $P8044, "1304456142.948", 377
    get_how $P8045, $P8044
    nqp_get_sc_object $P8046, "1304456142.948", 377
    .const 'Sub' $P8047 = "551_1304456155.152" 
    $P8045."add_method"($P8046, "circumfix:sym<{ }>", $P8047)
    nqp_get_sc_object $P8048, "1304456142.948", 377
    get_how $P8049, $P8048
    nqp_get_sc_object $P8050, "1304456142.948", 377
    .const 'Sub' $P8051 = "553_1304456155.152" 
    $P8049."add_method"($P8050, "circumfix:sym<sigil>", $P8051)
    nqp_get_sc_object $P8052, "1304456142.948", 377
    get_how $P8053, $P8052
    nqp_get_sc_object $P8054, "1304456142.948", 377
    .const 'Sub' $P8055 = "554_1304456155.152" 
    $P8053."add_method"($P8054, "semilist", $P8055)
    nqp_get_sc_object $P8056, "1304456142.948", 377
    get_how $P8057, $P8056
    nqp_get_sc_object $P8058, "1304456142.948", 377
    .const 'Sub' $P8059 = "555_1304456155.152" 
    $P8057."add_method"($P8058, "postcircumfix:sym<[ ]>", $P8059)
    nqp_get_sc_object $P8060, "1304456142.948", 377
    get_how $P8061, $P8060
    nqp_get_sc_object $P8062, "1304456142.948", 377
    .const 'Sub' $P8063 = "556_1304456155.152" 
    $P8061."add_method"($P8062, "postcircumfix:sym<{ }>", $P8063)
    nqp_get_sc_object $P8064, "1304456142.948", 377
    get_how $P8065, $P8064
    nqp_get_sc_object $P8066, "1304456142.948", 377
    .const 'Sub' $P8067 = "557_1304456155.152" 
    $P8065."add_method"($P8066, "postcircumfix:sym<ang>", $P8067)
    nqp_get_sc_object $P8068, "1304456142.948", 377
    get_how $P8069, $P8068
    nqp_get_sc_object $P8070, "1304456142.948", 377
    .const 'Sub' $P8071 = "558_1304456155.152" 
    $P8069."add_method"($P8070, "postcircumfix:sym<( )>", $P8071)
    nqp_get_sc_object $P8072, "1304456142.948", 377
    get_how $P8073, $P8072
    nqp_get_sc_object $P8074, "1304456142.948", 377
    .const 'Sub' $P8075 = "559_1304456155.152" 
    $P8073."add_method"($P8074, "value", $P8075)
    nqp_get_sc_object $P8076, "1304456142.948", 377
    get_how $P8077, $P8076
    nqp_get_sc_object $P8078, "1304456142.948", 377
    .const 'Sub' $P8079 = "560_1304456155.152" 
    $P8077."add_method"($P8078, "number", $P8079)
    nqp_get_sc_object $P8080, "1304456142.948", 377
    get_how $P8081, $P8080
    nqp_get_sc_object $P8082, "1304456142.948", 377
    .const 'Sub' $P8083 = "561_1304456155.152" 
    $P8081."add_method"($P8082, "quote:sym<apos>", $P8083)
    nqp_get_sc_object $P8084, "1304456142.948", 377
    get_how $P8085, $P8084
    nqp_get_sc_object $P8086, "1304456142.948", 377
    .const 'Sub' $P8087 = "562_1304456155.152" 
    $P8085."add_method"($P8086, "quote:sym<dblq>", $P8087)
    nqp_get_sc_object $P8088, "1304456142.948", 377
    get_how $P8089, $P8088
    nqp_get_sc_object $P8090, "1304456142.948", 377
    .const 'Sub' $P8091 = "563_1304456155.152" 
    $P8089."add_method"($P8090, "quote:sym<qq>", $P8091)
    nqp_get_sc_object $P8092, "1304456142.948", 377
    get_how $P8093, $P8092
    nqp_get_sc_object $P8094, "1304456142.948", 377
    .const 'Sub' $P8095 = "564_1304456155.152" 
    $P8093."add_method"($P8094, "quote:sym<q>", $P8095)
    nqp_get_sc_object $P8096, "1304456142.948", 377
    get_how $P8097, $P8096
    nqp_get_sc_object $P8098, "1304456142.948", 377
    .const 'Sub' $P8099 = "565_1304456155.152" 
    $P8097."add_method"($P8098, "quote:sym<Q>", $P8099)
    nqp_get_sc_object $P8100, "1304456142.948", 377
    get_how $P8101, $P8100
    nqp_get_sc_object $P8102, "1304456142.948", 377
    .const 'Sub' $P8103 = "566_1304456155.152" 
    $P8101."add_method"($P8102, "quote:sym<Q:PIR>", $P8103)
    nqp_get_sc_object $P8104, "1304456142.948", 377
    get_how $P8105, $P8104
    nqp_get_sc_object $P8106, "1304456142.948", 377
    .const 'Sub' $P8107 = "567_1304456155.152" 
    $P8105."add_method"($P8106, "quote:sym</ />", $P8107)
    nqp_get_sc_object $P8108, "1304456142.948", 377
    get_how $P8109, $P8108
    nqp_get_sc_object $P8110, "1304456142.948", 377
    .const 'Sub' $P8111 = "568_1304456155.152" 
    $P8109."add_method"($P8110, "quote_escape:sym<$>", $P8111)
    nqp_get_sc_object $P8112, "1304456142.948", 377
    get_how $P8113, $P8112
    nqp_get_sc_object $P8114, "1304456142.948", 377
    .const 'Sub' $P8115 = "569_1304456155.152" 
    $P8113."add_method"($P8114, "quote_escape:sym<{ }>", $P8115)
    nqp_get_sc_object $P8116, "1304456142.948", 377
    get_how $P8117, $P8116
    nqp_get_sc_object $P8118, "1304456142.948", 377
    .const 'Sub' $P8119 = "570_1304456155.152" 
    $P8117."add_method"($P8118, "quote_escape:sym<esc>", $P8119)
    nqp_get_sc_object $P8120, "1304456142.948", 377
    get_how $P8121, $P8120
    nqp_get_sc_object $P8122, "1304456142.948", 377
    .const 'Sub' $P8123 = "571_1304456155.152" 
    $P8121."add_method"($P8122, "postfix:sym<.>", $P8123)
    nqp_get_sc_object $P8124, "1304456142.948", 377
    get_how $P8125, $P8124
    nqp_get_sc_object $P8126, "1304456142.948", 377
    .const 'Sub' $P8127 = "572_1304456155.152" 
    $P8125."add_method"($P8126, "postfix:sym<++>", $P8127)
    nqp_get_sc_object $P8128, "1304456142.948", 377
    get_how $P8129, $P8128
    nqp_get_sc_object $P8130, "1304456142.948", 377
    .const 'Sub' $P8131 = "573_1304456155.152" 
    $P8129."add_method"($P8130, "postfix:sym<-->", $P8131)
    nqp_get_sc_object $P8132, "1304456142.948", 377
    get_how $P8133, $P8132
    nqp_get_sc_object $P8134, "1304456142.948", 377
    .const 'Sub' $P8135 = "574_1304456155.152" 
    $P8133."add_method"($P8134, "prefix:sym<make>", $P8135)
    nqp_get_sc_object $P8136, "1304456142.948", 377
    get_how $P8137, $P8136
    nqp_get_sc_object $P8138, "1304456142.948", 377
    .const 'Sub' $P8139 = "575_1304456155.152" 
    $P8137."add_method"($P8138, "term:sym<next>", $P8139)
    nqp_get_sc_object $P8140, "1304456142.948", 377
    get_how $P8141, $P8140
    nqp_get_sc_object $P8142, "1304456142.948", 377
    .const 'Sub' $P8143 = "576_1304456155.152" 
    $P8141."add_method"($P8142, "term:sym<last>", $P8143)
    nqp_get_sc_object $P8144, "1304456142.948", 377
    get_how $P8145, $P8144
    nqp_get_sc_object $P8146, "1304456142.948", 377
    .const 'Sub' $P8147 = "577_1304456155.152" 
    $P8145."add_method"($P8146, "term:sym<redo>", $P8147)
    nqp_get_sc_object $P8148, "1304456142.948", 377
    get_how $P8149, $P8148
    nqp_get_sc_object $P8150, "1304456142.948", 377
    .const 'Sub' $P8151 = "578_1304456155.152" 
    $P8149."add_method"($P8150, "infix:sym<~~>", $P8151)
    nqp_get_sc_object $P8152, "1304456142.948", 377
    get_how $P8153, $P8152
    nqp_get_sc_object $P8154, "1304456142.948", 377
    .const 'Sub' $P8155 = "579_1304456155.152" 
    $P8153."add_method"($P8154, "known_sym", $P8155)
    .const 'Sub' $P8156 = "406_1304456155.152" 
    $P8157 = $P8156."get_lexinfo"()
    nqp_get_sc_object $P8158, "1304456142.948", 377
    $P8157."set_static_lexpad_value"("$?PACKAGE", $P8158)
    .const 'Sub' $P8159 = "406_1304456155.152" 
    $P8160 = $P8159."get_lexinfo"()
    $P8160."finish_static_lexpad"()
    .const 'Sub' $P8161 = "406_1304456155.152" 
    $P8162 = $P8161."get_lexinfo"()
    nqp_get_sc_object $P8163, "1304456142.948", 377
    $P8162."set_static_lexpad_value"("$?CLASS", $P8163)
    .const 'Sub' $P8164 = "406_1304456155.152" 
    $P8165 = $P8164."get_lexinfo"()
    $P8165."finish_static_lexpad"()
    nqp_get_sc_object $P8166, "1304456142.948", 377
    get_how $P8167, $P8166
    nqp_get_sc_object $P8168, "1304456142.948", 377
    nqp_get_sc_object $P8169, "1304456124.041", 105
    $P8167."add_parent"($P8168, $P8169)
    nqp_get_sc_object $P8170, "1304456142.948", 377
    get_how $P8171, $P8170
    nqp_get_sc_object $P8172, "1304456142.948", 377
    $P8171."compose"($P8172)
    nqp_get_sc_object $P8173, "1304456116.562", 41
    $P8174 = $P8173."new_type"("NQP::RegexActions" :named("name"))
    nqp_set_sc_for_object $P8174, cur_sc
    nqp_set_sc_object "1304456142.948", 488, $P8174
    nqp_get_sc_object $P8175, "1304456142.948", 488
    nqp_get_sc_object $P8176, "1304456142.948", 0
    nqp_get_package_through_who $P8177, $P8176, "NQP"
    get_who $P8178, $P8177
    set $P8178["RegexActions"], $P8175
    nqp_get_sc_object $P8179, "1304456142.948", 488
    get_how $P8180, $P8179
    nqp_get_sc_object $P8181, "1304456142.948", 488
    .const 'Sub' $P8182 = "582_1304456155.152" 
    $P8180."add_method"($P8181, "metachar:sym<:my>", $P8182)
    nqp_get_sc_object $P8183, "1304456142.948", 488
    get_how $P8184, $P8183
    nqp_get_sc_object $P8185, "1304456142.948", 488
    .const 'Sub' $P8186 = "583_1304456155.152" 
    $P8184."add_method"($P8185, "metachar:sym<{ }>", $P8186)
    nqp_get_sc_object $P8187, "1304456142.948", 488
    get_how $P8188, $P8187
    nqp_get_sc_object $P8189, "1304456142.948", 488
    .const 'Sub' $P8190 = "584_1304456155.152" 
    $P8188."add_method"($P8189, "metachar:sym<nqpvar>", $P8190)
    nqp_get_sc_object $P8191, "1304456142.948", 488
    get_how $P8192, $P8191
    nqp_get_sc_object $P8193, "1304456142.948", 488
    .const 'Sub' $P8194 = "585_1304456155.152" 
    $P8192."add_method"($P8193, "assertion:sym<{ }>", $P8194)
    nqp_get_sc_object $P8195, "1304456142.948", 488
    get_how $P8196, $P8195
    nqp_get_sc_object $P8197, "1304456142.948", 488
    .const 'Sub' $P8198 = "586_1304456155.152" 
    $P8196."add_method"($P8197, "assertion:sym<?{ }>", $P8198)
    nqp_get_sc_object $P8199, "1304456142.948", 488
    get_how $P8200, $P8199
    nqp_get_sc_object $P8201, "1304456142.948", 488
    .const 'Sub' $P8202 = "587_1304456155.152" 
    $P8200."add_method"($P8201, "assertion:sym<var>", $P8202)
    nqp_get_sc_object $P8203, "1304456142.948", 488
    get_how $P8204, $P8203
    nqp_get_sc_object $P8205, "1304456142.948", 488
    .const 'Sub' $P8206 = "588_1304456155.152" 
    $P8204."add_method"($P8205, "codeblock", $P8206)
    .const 'Sub' $P8207 = "581_1304456155.152" 
    $P8208 = $P8207."get_lexinfo"()
    nqp_get_sc_object $P8209, "1304456142.948", 488
    $P8208."set_static_lexpad_value"("$?PACKAGE", $P8209)
    .const 'Sub' $P8210 = "581_1304456155.152" 
    $P8211 = $P8210."get_lexinfo"()
    $P8211."finish_static_lexpad"()
    .const 'Sub' $P8212 = "581_1304456155.152" 
    $P8213 = $P8212."get_lexinfo"()
    nqp_get_sc_object $P8214, "1304456142.948", 488
    $P8213."set_static_lexpad_value"("$?CLASS", $P8214)
    .const 'Sub' $P8215 = "581_1304456155.152" 
    $P8216 = $P8215."get_lexinfo"()
    $P8216."finish_static_lexpad"()
    nqp_get_sc_object $P8217, "1304456142.948", 488
    get_how $P8218, $P8217
    nqp_get_sc_object $P8219, "1304456142.948", 488
    nqp_get_sc_object $P8220, "1304456135.999", 145
    $P8218."add_parent"($P8219, $P8220)
    nqp_get_sc_object $P8221, "1304456142.948", 488
    get_how $P8222, $P8221
    nqp_get_sc_object $P8223, "1304456142.948", 488
    $P8222."compose"($P8223)
    nqp_get_sc_object $P8224, "1304456116.562", 41
    $P8225 = $P8224."new_type"("NQP::Compiler" :named("name"))
    nqp_set_sc_for_object $P8225, cur_sc
    nqp_set_sc_object "1304456142.948", 496, $P8225
    nqp_get_sc_object $P8226, "1304456142.948", 496
    nqp_get_sc_object $P8227, "1304456142.948", 0
    nqp_get_package_through_who $P8228, $P8227, "NQP"
    get_who $P8229, $P8228
    set $P8229["Compiler"], $P8226
    .const 'Sub' $P8230 = "589_1304456155.152" 
    $P8231 = $P8230."get_lexinfo"()
    nqp_get_sc_object $P8232, "1304456142.948", 496
    $P8231."set_static_lexpad_value"("$?PACKAGE", $P8232)
    .const 'Sub' $P8233 = "589_1304456155.152" 
    $P8234 = $P8233."get_lexinfo"()
    $P8234."finish_static_lexpad"()
    .const 'Sub' $P8235 = "589_1304456155.152" 
    $P8236 = $P8235."get_lexinfo"()
    nqp_get_sc_object $P8237, "1304456142.948", 496
    $P8236."set_static_lexpad_value"("$?CLASS", $P8237)
    .const 'Sub' $P8238 = "589_1304456155.152" 
    $P8239 = $P8238."get_lexinfo"()
    $P8239."finish_static_lexpad"()
    nqp_get_sc_object $P8240, "1304456142.948", 496
    get_how $P8241, $P8240
    nqp_get_sc_object $P8242, "1304456142.948", 496
    nqp_get_sc_object $P8243, "1304456124.041", 138
    $P8241."add_parent"($P8242, $P8243)
    nqp_get_sc_object $P8244, "1304456142.948", 496
    get_how $P8245, $P8244
    nqp_get_sc_object $P8246, "1304456142.948", 496
    $P8245."compose"($P8246)
  if_6143_end:
    nqp_get_sc_object $P9289, "1304456142.948", 0
    set_hll_global "GLOBAL", $P9289
.end


.HLL "nqp"

.namespace []
.sub "MAIN"  :subid("11_1304456155.152") :outer("10_1304456155.152")
    .param pmc param_17
.annotate 'line', 2258
    .lex "@ARGS", param_17
.annotate 'line', 2260
    new $P18, "Undef"
    .lex "$nqpcomp", $P18
.annotate 'line', 2266
    $P19 = root_new ['parrot';'ResizablePMCArray']
    .lex "@clo", $P19
.annotate 'line', 2260
    get_hll_global $P20, "GLOBAL"
    nqp_get_package_through_who $P21, $P20, "NQP"
    get_who $P22, $P21
    set $P23, $P22["Compiler"]
    $P24 = $P23."new"()
    store_lex "$nqpcomp", $P24
.annotate 'line', 2261
    find_lex $P25, "$nqpcomp"
    unless_null $P25, vivify_592
    new $P25, "Undef"
  vivify_592:
    $P25."language"("nqp")
.annotate 'line', 2262
    find_lex $P26, "$nqpcomp"
    unless_null $P26, vivify_593
    new $P26, "Undef"
  vivify_593:
    get_hll_global $P27, "GLOBAL"
    nqp_get_package_through_who $P28, $P27, "NQP"
    get_who $P29, $P28
    set $P30, $P29["Grammar"]
    $P26."parsegrammar"($P30)
.annotate 'line', 2263
    find_lex $P31, "$nqpcomp"
    unless_null $P31, vivify_594
    new $P31, "Undef"
  vivify_594:
    get_hll_global $P32, "GLOBAL"
    nqp_get_package_through_who $P33, $P32, "NQP"
    get_who $P34, $P33
    set $P35, $P34["Actions"]
    $P31."parseactions"($P35)
.annotate 'line', 2266
    find_lex $P36, "$nqpcomp"
    unless_null $P36, vivify_595
    new $P36, "Undef"
  vivify_595:
    $P37 = $P36."commandline_options"()
    store_lex "@clo", $P37
.annotate 'line', 2267
    find_lex $P38, "@clo"
    unless_null $P38, vivify_596
    $P38 = root_new ['parrot';'ResizablePMCArray']
  vivify_596:
    $P38."push"("parsetrace")
.annotate 'line', 2268
    find_lex $P39, "@clo"
    unless_null $P39, vivify_597
    $P39 = root_new ['parrot';'ResizablePMCArray']
  vivify_597:
    $P39."push"("setting=s")
.annotate 'line', 2269
    find_lex $P40, "@clo"
    unless_null $P40, vivify_598
    $P40 = root_new ['parrot';'ResizablePMCArray']
  vivify_598:
    $P40."push"("setting-path=s")
.annotate 'line', 2270
    find_lex $P41, "@clo"
    unless_null $P41, vivify_599
    $P41 = root_new ['parrot';'ResizablePMCArray']
  vivify_599:
    $P41."push"("module-path=s")
.annotate 'line', 2273
    find_lex $P42, "$nqpcomp"
    unless_null $P42, vivify_600
    new $P42, "Undef"
  vivify_600:
    find_lex $P43, "@ARGS"
    unless_null $P43, vivify_601
    $P43 = root_new ['parrot';'ResizablePMCArray']
  vivify_601:
    $P44 = $P42."command_line"($P43, "utf8" :named("encoding"), "ascii iso-8859-1" :named("transcode"))
.annotate 'line', 2258
    .return ($P44)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block46"  :subid("12_1304456155.152") :outer("10_1304456155.152")
.annotate 'line', 9
    .const 'Sub' $P1898 = "384_1304456155.152" 
    capture_lex $P1898
    .const 'Sub' $P1896 = "383_1304456155.152" 
    capture_lex $P1896
    .const 'Sub' $P1892 = "382_1304456155.152" 
    capture_lex $P1892
    .const 'Sub' $P1890 = "381_1304456155.152" 
    capture_lex $P1890
    .const 'Sub' $P1886 = "380_1304456155.152" 
    capture_lex $P1886
    .const 'Sub' $P1884 = "379_1304456155.152" 
    capture_lex $P1884
    .const 'Sub' $P1880 = "378_1304456155.152" 
    capture_lex $P1880
    .const 'Sub' $P1878 = "377_1304456155.152" 
    capture_lex $P1878
    .const 'Sub' $P1874 = "376_1304456155.152" 
    capture_lex $P1874
    .const 'Sub' $P1872 = "375_1304456155.152" 
    capture_lex $P1872
    .const 'Sub' $P1862 = "373_1304456155.152" 
    capture_lex $P1862
    .const 'Sub' $P1859 = "372_1304456155.152" 
    capture_lex $P1859
    .const 'Sub' $P1855 = "371_1304456155.152" 
    capture_lex $P1855
    .const 'Sub' $P1852 = "370_1304456155.152" 
    capture_lex $P1852
    .const 'Sub' $P1848 = "369_1304456155.152" 
    capture_lex $P1848
    .const 'Sub' $P1845 = "368_1304456155.152" 
    capture_lex $P1845
    .const 'Sub' $P1841 = "367_1304456155.152" 
    capture_lex $P1841
    .const 'Sub' $P1838 = "366_1304456155.152" 
    capture_lex $P1838
    .const 'Sub' $P1834 = "365_1304456155.152" 
    capture_lex $P1834
    .const 'Sub' $P1831 = "364_1304456155.152" 
    capture_lex $P1831
    .const 'Sub' $P1828 = "363_1304456155.152" 
    capture_lex $P1828
    .const 'Sub' $P1825 = "362_1304456155.152" 
    capture_lex $P1825
    .const 'Sub' $P1821 = "361_1304456155.152" 
    capture_lex $P1821
    .const 'Sub' $P1818 = "360_1304456155.152" 
    capture_lex $P1818
    .const 'Sub' $P1814 = "359_1304456155.152" 
    capture_lex $P1814
    .const 'Sub' $P1811 = "358_1304456155.152" 
    capture_lex $P1811
    .const 'Sub' $P1807 = "357_1304456155.152" 
    capture_lex $P1807
    .const 'Sub' $P1804 = "356_1304456155.152" 
    capture_lex $P1804
    .const 'Sub' $P1800 = "355_1304456155.152" 
    capture_lex $P1800
    .const 'Sub' $P1797 = "354_1304456155.152" 
    capture_lex $P1797
    .const 'Sub' $P1793 = "353_1304456155.152" 
    capture_lex $P1793
    .const 'Sub' $P1790 = "352_1304456155.152" 
    capture_lex $P1790
    .const 'Sub' $P1786 = "351_1304456155.152" 
    capture_lex $P1786
    .const 'Sub' $P1783 = "350_1304456155.152" 
    capture_lex $P1783
    .const 'Sub' $P1779 = "349_1304456155.152" 
    capture_lex $P1779
    .const 'Sub' $P1776 = "348_1304456155.152" 
    capture_lex $P1776
    .const 'Sub' $P1772 = "347_1304456155.152" 
    capture_lex $P1772
    .const 'Sub' $P1769 = "346_1304456155.152" 
    capture_lex $P1769
    .const 'Sub' $P1765 = "345_1304456155.152" 
    capture_lex $P1765
    .const 'Sub' $P1762 = "344_1304456155.152" 
    capture_lex $P1762
    .const 'Sub' $P1758 = "343_1304456155.152" 
    capture_lex $P1758
    .const 'Sub' $P1755 = "342_1304456155.152" 
    capture_lex $P1755
    .const 'Sub' $P1751 = "341_1304456155.152" 
    capture_lex $P1751
    .const 'Sub' $P1748 = "340_1304456155.152" 
    capture_lex $P1748
    .const 'Sub' $P1744 = "339_1304456155.152" 
    capture_lex $P1744
    .const 'Sub' $P1741 = "338_1304456155.152" 
    capture_lex $P1741
    .const 'Sub' $P1737 = "337_1304456155.152" 
    capture_lex $P1737
    .const 'Sub' $P1734 = "336_1304456155.152" 
    capture_lex $P1734
    .const 'Sub' $P1730 = "335_1304456155.152" 
    capture_lex $P1730
    .const 'Sub' $P1727 = "334_1304456155.152" 
    capture_lex $P1727
    .const 'Sub' $P1723 = "333_1304456155.152" 
    capture_lex $P1723
    .const 'Sub' $P1720 = "332_1304456155.152" 
    capture_lex $P1720
    .const 'Sub' $P1716 = "331_1304456155.152" 
    capture_lex $P1716
    .const 'Sub' $P1713 = "330_1304456155.152" 
    capture_lex $P1713
    .const 'Sub' $P1709 = "329_1304456155.152" 
    capture_lex $P1709
    .const 'Sub' $P1706 = "328_1304456155.152" 
    capture_lex $P1706
    .const 'Sub' $P1702 = "327_1304456155.152" 
    capture_lex $P1702
    .const 'Sub' $P1699 = "326_1304456155.152" 
    capture_lex $P1699
    .const 'Sub' $P1695 = "325_1304456155.152" 
    capture_lex $P1695
    .const 'Sub' $P1692 = "324_1304456155.152" 
    capture_lex $P1692
    .const 'Sub' $P1688 = "323_1304456155.152" 
    capture_lex $P1688
    .const 'Sub' $P1685 = "322_1304456155.152" 
    capture_lex $P1685
    .const 'Sub' $P1681 = "321_1304456155.152" 
    capture_lex $P1681
    .const 'Sub' $P1678 = "320_1304456155.152" 
    capture_lex $P1678
    .const 'Sub' $P1674 = "319_1304456155.152" 
    capture_lex $P1674
    .const 'Sub' $P1671 = "318_1304456155.152" 
    capture_lex $P1671
    .const 'Sub' $P1667 = "317_1304456155.152" 
    capture_lex $P1667
    .const 'Sub' $P1664 = "316_1304456155.152" 
    capture_lex $P1664
    .const 'Sub' $P1660 = "315_1304456155.152" 
    capture_lex $P1660
    .const 'Sub' $P1657 = "314_1304456155.152" 
    capture_lex $P1657
    .const 'Sub' $P1653 = "313_1304456155.152" 
    capture_lex $P1653
    .const 'Sub' $P1650 = "312_1304456155.152" 
    capture_lex $P1650
    .const 'Sub' $P1646 = "311_1304456155.152" 
    capture_lex $P1646
    .const 'Sub' $P1643 = "310_1304456155.152" 
    capture_lex $P1643
    .const 'Sub' $P1639 = "309_1304456155.152" 
    capture_lex $P1639
    .const 'Sub' $P1636 = "308_1304456155.152" 
    capture_lex $P1636
    .const 'Sub' $P1632 = "307_1304456155.152" 
    capture_lex $P1632
    .const 'Sub' $P1629 = "306_1304456155.152" 
    capture_lex $P1629
    .const 'Sub' $P1625 = "305_1304456155.152" 
    capture_lex $P1625
    .const 'Sub' $P1623 = "304_1304456155.152" 
    capture_lex $P1623
    .const 'Sub' $P1619 = "303_1304456155.152" 
    capture_lex $P1619
    .const 'Sub' $P1616 = "302_1304456155.152" 
    capture_lex $P1616
    .const 'Sub' $P1612 = "301_1304456155.152" 
    capture_lex $P1612
    .const 'Sub' $P1609 = "300_1304456155.152" 
    capture_lex $P1609
    .const 'Sub' $P1605 = "299_1304456155.152" 
    capture_lex $P1605
    .const 'Sub' $P1602 = "298_1304456155.152" 
    capture_lex $P1602
    .const 'Sub' $P1598 = "297_1304456155.152" 
    capture_lex $P1598
    .const 'Sub' $P1595 = "296_1304456155.152" 
    capture_lex $P1595
    .const 'Sub' $P1591 = "295_1304456155.152" 
    capture_lex $P1591
    .const 'Sub' $P1588 = "294_1304456155.152" 
    capture_lex $P1588
    .const 'Sub' $P1584 = "293_1304456155.152" 
    capture_lex $P1584
    .const 'Sub' $P1581 = "292_1304456155.152" 
    capture_lex $P1581
    .const 'Sub' $P1577 = "291_1304456155.152" 
    capture_lex $P1577
    .const 'Sub' $P1574 = "290_1304456155.152" 
    capture_lex $P1574
    .const 'Sub' $P1570 = "289_1304456155.152" 
    capture_lex $P1570
    .const 'Sub' $P1567 = "288_1304456155.152" 
    capture_lex $P1567
    .const 'Sub' $P1564 = "287_1304456155.152" 
    capture_lex $P1564
    .const 'Sub' $P1561 = "286_1304456155.152" 
    capture_lex $P1561
    .const 'Sub' $P1558 = "285_1304456155.152" 
    capture_lex $P1558
    .const 'Sub' $P1556 = "284_1304456155.152" 
    capture_lex $P1556
    .const 'Sub' $P1553 = "283_1304456155.152" 
    capture_lex $P1553
    .const 'Sub' $P1550 = "282_1304456155.152" 
    capture_lex $P1550
    .const 'Sub' $P1547 = "281_1304456155.152" 
    capture_lex $P1547
    .const 'Sub' $P1544 = "280_1304456155.152" 
    capture_lex $P1544
    .const 'Sub' $P1541 = "279_1304456155.152" 
    capture_lex $P1541
    .const 'Sub' $P1539 = "278_1304456155.152" 
    capture_lex $P1539
    .const 'Sub' $P1536 = "277_1304456155.152" 
    capture_lex $P1536
    .const 'Sub' $P1534 = "276_1304456155.152" 
    capture_lex $P1534
    .const 'Sub' $P1531 = "275_1304456155.152" 
    capture_lex $P1531
    .const 'Sub' $P1528 = "274_1304456155.152" 
    capture_lex $P1528
    .const 'Sub' $P1523 = "273_1304456155.152" 
    capture_lex $P1523
    .const 'Sub' $P1520 = "272_1304456155.152" 
    capture_lex $P1520
    .const 'Sub' $P1514 = "271_1304456155.152" 
    capture_lex $P1514
    .const 'Sub' $P1512 = "270_1304456155.152" 
    capture_lex $P1512
    .const 'Sub' $P1509 = "269_1304456155.152" 
    capture_lex $P1509
    .const 'Sub' $P1507 = "268_1304456155.152" 
    capture_lex $P1507
    .const 'Sub' $P1504 = "267_1304456155.152" 
    capture_lex $P1504
    .const 'Sub' $P1502 = "266_1304456155.152" 
    capture_lex $P1502
    .const 'Sub' $P1499 = "265_1304456155.152" 
    capture_lex $P1499
    .const 'Sub' $P1496 = "264_1304456155.152" 
    capture_lex $P1496
    .const 'Sub' $P1491 = "263_1304456155.152" 
    capture_lex $P1491
    .const 'Sub' $P1488 = "262_1304456155.152" 
    capture_lex $P1488
    .const 'Sub' $P1483 = "261_1304456155.152" 
    capture_lex $P1483
    .const 'Sub' $P1481 = "260_1304456155.152" 
    capture_lex $P1481
    .const 'Sub' $P1478 = "259_1304456155.152" 
    capture_lex $P1478
    .const 'Sub' $P1476 = "258_1304456155.152" 
    capture_lex $P1476
    .const 'Sub' $P1473 = "257_1304456155.152" 
    capture_lex $P1473
    .const 'Sub' $P1471 = "256_1304456155.152" 
    capture_lex $P1471
    .const 'Sub' $P1468 = "255_1304456155.152" 
    capture_lex $P1468
    .const 'Sub' $P1465 = "254_1304456155.152" 
    capture_lex $P1465
    .const 'Sub' $P1462 = "253_1304456155.152" 
    capture_lex $P1462
    .const 'Sub' $P1459 = "252_1304456155.152" 
    capture_lex $P1459
    .const 'Sub' $P1455 = "251_1304456155.152" 
    capture_lex $P1455
    .const 'Sub' $P1452 = "250_1304456155.152" 
    capture_lex $P1452
    .const 'Sub' $P1448 = "249_1304456155.152" 
    capture_lex $P1448
    .const 'Sub' $P1445 = "248_1304456155.152" 
    capture_lex $P1445
    .const 'Sub' $P1441 = "247_1304456155.152" 
    capture_lex $P1441
    .const 'Sub' $P1438 = "246_1304456155.152" 
    capture_lex $P1438
    .const 'Sub' $P1434 = "245_1304456155.152" 
    capture_lex $P1434
    .const 'Sub' $P1432 = "244_1304456155.152" 
    capture_lex $P1432
    .const 'Sub' $P1429 = "243_1304456155.152" 
    capture_lex $P1429
    .const 'Sub' $P1427 = "242_1304456155.152" 
    capture_lex $P1427
    .const 'Sub' $P1424 = "241_1304456155.152" 
    capture_lex $P1424
    .const 'Sub' $P1416 = "238_1304456155.152" 
    capture_lex $P1416
    .const 'Sub' $P1410 = "237_1304456155.152" 
    capture_lex $P1410
    .const 'Sub' $P1406 = "236_1304456155.152" 
    capture_lex $P1406
    .const 'Sub' $P1402 = "235_1304456155.152" 
    capture_lex $P1402
    .const 'Sub' $P1399 = "234_1304456155.152" 
    capture_lex $P1399
    .const 'Sub' $P1396 = "233_1304456155.152" 
    capture_lex $P1396
    .const 'Sub' $P1393 = "232_1304456155.152" 
    capture_lex $P1393
    .const 'Sub' $P1389 = "231_1304456155.152" 
    capture_lex $P1389
    .const 'Sub' $P1386 = "230_1304456155.152" 
    capture_lex $P1386
    .const 'Sub' $P1383 = "229_1304456155.152" 
    capture_lex $P1383
    .const 'Sub' $P1381 = "228_1304456155.152" 
    capture_lex $P1381
    .const 'Sub' $P1367 = "226_1304456155.152" 
    capture_lex $P1367
    .const 'Sub' $P1365 = "225_1304456155.152" 
    capture_lex $P1365
    .const 'Sub' $P1359 = "224_1304456155.152" 
    capture_lex $P1359
    .const 'Sub' $P1356 = "223_1304456155.152" 
    capture_lex $P1356
    .const 'Sub' $P1351 = "222_1304456155.152" 
    capture_lex $P1351
    .const 'Sub' $P1348 = "221_1304456155.152" 
    capture_lex $P1348
    .const 'Sub' $P1345 = "220_1304456155.152" 
    capture_lex $P1345
    .const 'Sub' $P1343 = "219_1304456155.152" 
    capture_lex $P1343
    .const 'Sub' $P1339 = "218_1304456155.152" 
    capture_lex $P1339
    .const 'Sub' $P1330 = "215_1304456155.152" 
    capture_lex $P1330
    .const 'Sub' $P1323 = "214_1304456155.152" 
    capture_lex $P1323
    .const 'Sub' $P1320 = "213_1304456155.152" 
    capture_lex $P1320
    .const 'Sub' $P1282 = "212_1304456155.152" 
    capture_lex $P1282
    .const 'Sub' $P1279 = "211_1304456155.152" 
    capture_lex $P1279
    .const 'Sub' $P1271 = "210_1304456155.152" 
    capture_lex $P1271
    .const 'Sub' $P1262 = "207_1304456155.152" 
    capture_lex $P1262
    .const 'Sub' $P1257 = "206_1304456155.152" 
    capture_lex $P1257
    .const 'Sub' $P1254 = "205_1304456155.152" 
    capture_lex $P1254
    .const 'Sub' $P1248 = "204_1304456155.152" 
    capture_lex $P1248
    .const 'Sub' $P1245 = "203_1304456155.152" 
    capture_lex $P1245
    .const 'Sub' $P1242 = "202_1304456155.152" 
    capture_lex $P1242
    .const 'Sub' $P1239 = "201_1304456155.152" 
    capture_lex $P1239
    .const 'Sub' $P1232 = "200_1304456155.152" 
    capture_lex $P1232
    .const 'Sub' $P1230 = "199_1304456155.152" 
    capture_lex $P1230
    .const 'Sub' $P1217 = "198_1304456155.152" 
    capture_lex $P1217
    .const 'Sub' $P1215 = "197_1304456155.152" 
    capture_lex $P1215
    .const 'Sub' $P1201 = "195_1304456155.152" 
    capture_lex $P1201
    .const 'Sub' $P1198 = "194_1304456155.152" 
    capture_lex $P1198
    .const 'Sub' $P1193 = "193_1304456155.152" 
    capture_lex $P1193
    .const 'Sub' $P1190 = "192_1304456155.152" 
    capture_lex $P1190
    .const 'Sub' $P1183 = "191_1304456155.152" 
    capture_lex $P1183
    .const 'Sub' $P1180 = "190_1304456155.152" 
    capture_lex $P1180
    .const 'Sub' $P1173 = "189_1304456155.152" 
    capture_lex $P1173
    .const 'Sub' $P1165 = "186_1304456155.152" 
    capture_lex $P1165
    .const 'Sub' $P1152 = "184_1304456155.152" 
    capture_lex $P1152
    .const 'Sub' $P1149 = "183_1304456155.152" 
    capture_lex $P1149
    .const 'Sub' $P1108 = "181_1304456155.152" 
    capture_lex $P1108
    .const 'Sub' $P1105 = "180_1304456155.152" 
    capture_lex $P1105
    .const 'Sub' $P1074 = "179_1304456155.152" 
    capture_lex $P1074
    .const 'Sub' $P1071 = "178_1304456155.152" 
    capture_lex $P1071
    .const 'Sub' $P1067 = "177_1304456155.152" 
    capture_lex $P1067
    .const 'Sub' $P1064 = "176_1304456155.152" 
    capture_lex $P1064
    .const 'Sub' $P1060 = "175_1304456155.152" 
    capture_lex $P1060
    .const 'Sub' $P1051 = "172_1304456155.152" 
    capture_lex $P1051
    .const 'Sub' $P1033 = "170_1304456155.152" 
    capture_lex $P1033
    .const 'Sub' $P1029 = "169_1304456155.152" 
    capture_lex $P1029
    .const 'Sub' $P1025 = "168_1304456155.152" 
    capture_lex $P1025
    .const 'Sub' $P1022 = "167_1304456155.152" 
    capture_lex $P1022
    .const 'Sub' $P1006 = "165_1304456155.152" 
    capture_lex $P1006
    .const 'Sub' $P1001 = "164_1304456155.152" 
    capture_lex $P1001
    .const 'Sub' $P990 = "163_1304456155.152" 
    capture_lex $P990
    .const 'Sub' $P987 = "162_1304456155.152" 
    capture_lex $P987
    .const 'Sub' $P983 = "161_1304456155.152" 
    capture_lex $P983
    .const 'Sub' $P980 = "160_1304456155.152" 
    capture_lex $P980
    .const 'Sub' $P976 = "159_1304456155.152" 
    capture_lex $P976
    .const 'Sub' $P973 = "158_1304456155.152" 
    capture_lex $P973
    .const 'Sub' $P969 = "157_1304456155.152" 
    capture_lex $P969
    .const 'Sub' $P960 = "154_1304456155.152" 
    capture_lex $P960
    .const 'Sub' $P791 = "152_1304456155.152" 
    capture_lex $P791
    .const 'Sub' $P788 = "151_1304456155.152" 
    capture_lex $P788
    .const 'Sub' $P778 = "150_1304456155.152" 
    capture_lex $P778
    .const 'Sub' $P775 = "149_1304456155.152" 
    capture_lex $P775
    .const 'Sub' $P765 = "148_1304456155.152" 
    capture_lex $P765
    .const 'Sub' $P762 = "147_1304456155.152" 
    capture_lex $P762
    .const 'Sub' $P752 = "146_1304456155.152" 
    capture_lex $P752
    .const 'Sub' $P749 = "145_1304456155.152" 
    capture_lex $P749
    .const 'Sub' $P739 = "144_1304456155.152" 
    capture_lex $P739
    .const 'Sub' $P736 = "143_1304456155.152" 
    capture_lex $P736
    .const 'Sub' $P726 = "142_1304456155.152" 
    capture_lex $P726
    .const 'Sub' $P723 = "141_1304456155.152" 
    capture_lex $P723
    .const 'Sub' $P713 = "140_1304456155.152" 
    capture_lex $P713
    .const 'Sub' $P705 = "137_1304456155.152" 
    capture_lex $P705
    .const 'Sub' $P702 = "136_1304456155.152" 
    capture_lex $P702
    .const 'Sub' $P700 = "135_1304456155.152" 
    capture_lex $P700
    .const 'Sub' $P697 = "134_1304456155.152" 
    capture_lex $P697
    .const 'Sub' $P693 = "133_1304456155.152" 
    capture_lex $P693
    .const 'Sub' $P685 = "132_1304456155.152" 
    capture_lex $P685
    .const 'Sub' $P680 = "131_1304456155.152" 
    capture_lex $P680
    .const 'Sub' $P673 = "130_1304456155.152" 
    capture_lex $P673
    .const 'Sub' $P670 = "129_1304456155.152" 
    capture_lex $P670
    .const 'Sub' $P666 = "128_1304456155.152" 
    capture_lex $P666
    .const 'Sub' $P664 = "127_1304456155.152" 
    capture_lex $P664
    .const 'Sub' $P661 = "126_1304456155.152" 
    capture_lex $P661
    .const 'Sub' $P658 = "125_1304456155.152" 
    capture_lex $P658
    .const 'Sub' $P655 = "124_1304456155.152" 
    capture_lex $P655
    .const 'Sub' $P652 = "123_1304456155.152" 
    capture_lex $P652
    .const 'Sub' $P649 = "122_1304456155.152" 
    capture_lex $P649
    .const 'Sub' $P647 = "121_1304456155.152" 
    capture_lex $P647
    .const 'Sub' $P634 = "118_1304456155.152" 
    capture_lex $P634
    .const 'Sub' $P631 = "117_1304456155.152" 
    capture_lex $P631
    .const 'Sub' $P628 = "116_1304456155.152" 
    capture_lex $P628
    .const 'Sub' $P625 = "115_1304456155.152" 
    capture_lex $P625
    .const 'Sub' $P622 = "114_1304456155.152" 
    capture_lex $P622
    .const 'Sub' $P619 = "113_1304456155.152" 
    capture_lex $P619
    .const 'Sub' $P616 = "112_1304456155.152" 
    capture_lex $P616
    .const 'Sub' $P613 = "111_1304456155.152" 
    capture_lex $P613
    .const 'Sub' $P610 = "110_1304456155.152" 
    capture_lex $P610
    .const 'Sub' $P607 = "109_1304456155.152" 
    capture_lex $P607
    .const 'Sub' $P604 = "108_1304456155.152" 
    capture_lex $P604
    .const 'Sub' $P601 = "107_1304456155.152" 
    capture_lex $P601
    .const 'Sub' $P598 = "106_1304456155.152" 
    capture_lex $P598
    .const 'Sub' $P595 = "105_1304456155.152" 
    capture_lex $P595
    .const 'Sub' $P589 = "104_1304456155.152" 
    capture_lex $P589
    .const 'Sub' $P586 = "103_1304456155.152" 
    capture_lex $P586
    .const 'Sub' $P580 = "102_1304456155.152" 
    capture_lex $P580
    .const 'Sub' $P577 = "101_1304456155.152" 
    capture_lex $P577
    .const 'Sub' $P571 = "100_1304456155.152" 
    capture_lex $P571
    .const 'Sub' $P562 = "97_1304456155.152" 
    capture_lex $P562
    .const 'Sub' $P556 = "96_1304456155.152" 
    capture_lex $P556
    .const 'Sub' $P553 = "95_1304456155.152" 
    capture_lex $P553
    .const 'Sub' $P547 = "94_1304456155.152" 
    capture_lex $P547
    .const 'Sub' $P539 = "91_1304456155.152" 
    capture_lex $P539
    .const 'Sub' $P535 = "90_1304456155.152" 
    capture_lex $P535
    .const 'Sub' $P532 = "89_1304456155.152" 
    capture_lex $P532
    .const 'Sub' $P528 = "88_1304456155.152" 
    capture_lex $P528
    .const 'Sub' $P525 = "87_1304456155.152" 
    capture_lex $P525
    .const 'Sub' $P521 = "86_1304456155.152" 
    capture_lex $P521
    .const 'Sub' $P513 = "83_1304456155.152" 
    capture_lex $P513
    .const 'Sub' $P507 = "82_1304456155.152" 
    capture_lex $P507
    .const 'Sub' $P505 = "81_1304456155.152" 
    capture_lex $P505
    .const 'Sub' $P499 = "80_1304456155.152" 
    capture_lex $P499
    .const 'Sub' $P497 = "79_1304456155.152" 
    capture_lex $P497
    .const 'Sub' $P491 = "78_1304456155.152" 
    capture_lex $P491
    .const 'Sub' $P489 = "77_1304456155.152" 
    capture_lex $P489
    .const 'Sub' $P471 = "76_1304456155.152" 
    capture_lex $P471
    .const 'Sub' $P469 = "75_1304456155.152" 
    capture_lex $P469
    .const 'Sub' $P462 = "74_1304456155.152" 
    capture_lex $P462
    .const 'Sub' $P460 = "73_1304456155.152" 
    capture_lex $P460
    .const 'Sub' $P444 = "71_1304456155.152" 
    capture_lex $P444
    .const 'Sub' $P442 = "70_1304456155.152" 
    capture_lex $P442
    .const 'Sub' $P426 = "69_1304456155.152" 
    capture_lex $P426
    .const 'Sub' $P424 = "68_1304456155.152" 
    capture_lex $P424
    .const 'Sub' $P418 = "67_1304456155.152" 
    capture_lex $P418
    .const 'Sub' $P410 = "64_1304456155.152" 
    capture_lex $P410
    .const 'Sub' $P407 = "63_1304456155.152" 
    capture_lex $P407
    .const 'Sub' $P405 = "62_1304456155.152" 
    capture_lex $P405
    .const 'Sub' $P402 = "61_1304456155.152" 
    capture_lex $P402
    .const 'Sub' $P394 = "58_1304456155.152" 
    capture_lex $P394
    .const 'Sub' $P391 = "57_1304456155.152" 
    capture_lex $P391
    .const 'Sub' $P389 = "56_1304456155.152" 
    capture_lex $P389
    .const 'Sub' $P386 = "55_1304456155.152" 
    capture_lex $P386
    .const 'Sub' $P384 = "54_1304456155.152" 
    capture_lex $P384
    .const 'Sub' $P381 = "53_1304456155.152" 
    capture_lex $P381
    .const 'Sub' $P379 = "52_1304456155.152" 
    capture_lex $P379
    .const 'Sub' $P376 = "51_1304456155.152" 
    capture_lex $P376
    .const 'Sub' $P374 = "50_1304456155.152" 
    capture_lex $P374
    .const 'Sub' $P371 = "49_1304456155.152" 
    capture_lex $P371
    .const 'Sub' $P368 = "48_1304456155.152" 
    capture_lex $P368
    .const 'Sub' $P361 = "47_1304456155.152" 
    capture_lex $P361
    .const 'Sub' $P358 = "46_1304456155.152" 
    capture_lex $P358
    .const 'Sub' $P354 = "45_1304456155.152" 
    capture_lex $P354
    .const 'Sub' $P352 = "44_1304456155.152" 
    capture_lex $P352
    .const 'Sub' $P348 = "43_1304456155.152" 
    capture_lex $P348
    .const 'Sub' $P344 = "42_1304456155.152" 
    capture_lex $P344
    .const 'Sub' $P340 = "41_1304456155.152" 
    capture_lex $P340
    .const 'Sub' $P337 = "40_1304456155.152" 
    capture_lex $P337
    .const 'Sub' $P334 = "39_1304456155.152" 
    capture_lex $P334
    .const 'Sub' $P332 = "38_1304456155.152" 
    capture_lex $P332
    .const 'Sub' $P328 = "37_1304456155.152" 
    capture_lex $P328
    .const 'Sub' $P326 = "36_1304456155.152" 
    capture_lex $P326
    .const 'Sub' $P313 = "34_1304456155.152" 
    capture_lex $P313
    .const 'Sub' $P309 = "33_1304456155.152" 
    capture_lex $P309
    .const 'Sub' $P299 = "32_1304456155.152" 
    capture_lex $P299
    .const 'Sub' $P296 = "31_1304456155.152" 
    capture_lex $P296
    .const 'Sub' $P276 = "30_1304456155.152" 
    capture_lex $P276
    .const 'Sub' $P274 = "29_1304456155.152" 
    capture_lex $P274
    .const 'Sub' $P237 = "27_1304456155.152" 
    capture_lex $P237
    .const 'Sub' $P235 = "26_1304456155.152" 
    capture_lex $P235
    .const 'Sub' $P222 = "24_1304456155.152" 
    capture_lex $P222
    .const 'Sub' $P220 = "23_1304456155.152" 
    capture_lex $P220
    .const 'Sub' $P211 = "22_1304456155.152" 
    capture_lex $P211
    .const 'Sub' $P209 = "21_1304456155.152" 
    capture_lex $P209
    .const 'Sub' $P199 = "20_1304456155.152" 
    capture_lex $P199
    .const 'Sub' $P196 = "19_1304456155.152" 
    capture_lex $P196
    .const 'Sub' $P191 = "18_1304456155.152" 
    capture_lex $P191
    .const 'Sub' $P189 = "17_1304456155.152" 
    capture_lex $P189
    .const 'Sub' $P184 = "16_1304456155.152" 
    capture_lex $P184
    .const 'Sub' $P181 = "15_1304456155.152" 
    capture_lex $P181
    .const 'Sub' $P177 = "14_1304456155.152" 
    capture_lex $P177
    .const 'Sub' $P110 = "13_1304456155.152" 
    capture_lex $P110
    .lex "$?PACKAGE", $P48
    .lex "$?CLASS", $P49
.annotate 'line', 606
    get_hll_global $P50, "GLOBAL"
    nqp_get_package_through_who $P51, $P50, "NQP"
    get_who $P52, $P51
    set $P53, $P52["Grammar"]
    $P53."O"(":prec<y=>, :assoc<unary>", "%methodop")
.annotate 'line', 607
    get_hll_global $P54, "GLOBAL"
    nqp_get_package_through_who $P55, $P54, "NQP"
    get_who $P56, $P55
    set $P57, $P56["Grammar"]
    $P57."O"(":prec<x=>, :assoc<unary>", "%autoincrement")
.annotate 'line', 608
    get_hll_global $P58, "GLOBAL"
    nqp_get_package_through_who $P59, $P58, "NQP"
    get_who $P60, $P59
    set $P61, $P60["Grammar"]
    $P61."O"(":prec<w=>, :assoc<left>", "%exponentiation")
.annotate 'line', 609
    get_hll_global $P62, "GLOBAL"
    nqp_get_package_through_who $P63, $P62, "NQP"
    get_who $P64, $P63
    set $P65, $P64["Grammar"]
    $P65."O"(":prec<v=>, :assoc<unary>", "%symbolic_unary")
.annotate 'line', 610
    get_hll_global $P66, "GLOBAL"
    nqp_get_package_through_who $P67, $P66, "NQP"
    get_who $P68, $P67
    set $P69, $P68["Grammar"]
    $P69."O"(":prec<u=>, :assoc<left>", "%multiplicative")
.annotate 'line', 611
    get_hll_global $P70, "GLOBAL"
    nqp_get_package_through_who $P71, $P70, "NQP"
    get_who $P72, $P71
    set $P73, $P72["Grammar"]
    $P73."O"(":prec<t=>, :assoc<left>", "%additive")
.annotate 'line', 612
    get_hll_global $P74, "GLOBAL"
    nqp_get_package_through_who $P75, $P74, "NQP"
    get_who $P76, $P75
    set $P77, $P76["Grammar"]
    $P77."O"(":prec<r=>, :assoc<left>", "%concatenation")
.annotate 'line', 613
    get_hll_global $P78, "GLOBAL"
    nqp_get_package_through_who $P79, $P78, "NQP"
    get_who $P80, $P79
    set $P81, $P80["Grammar"]
    $P81."O"(":prec<m=>, :assoc<left>", "%relational")
.annotate 'line', 614
    get_hll_global $P82, "GLOBAL"
    nqp_get_package_through_who $P83, $P82, "NQP"
    get_who $P84, $P83
    set $P85, $P84["Grammar"]
    $P85."O"(":prec<l=>, :assoc<left>", "%tight_and")
.annotate 'line', 615
    get_hll_global $P86, "GLOBAL"
    nqp_get_package_through_who $P87, $P86, "NQP"
    get_who $P88, $P87
    set $P89, $P88["Grammar"]
    $P89."O"(":prec<k=>, :assoc<left>", "%tight_or")
.annotate 'line', 616
    get_hll_global $P90, "GLOBAL"
    nqp_get_package_through_who $P91, $P90, "NQP"
    get_who $P92, $P91
    set $P93, $P92["Grammar"]
    $P93."O"(":prec<j=>, :assoc<right>", "%conditional")
.annotate 'line', 617
    get_hll_global $P94, "GLOBAL"
    nqp_get_package_through_who $P95, $P94, "NQP"
    get_who $P96, $P95
    set $P97, $P96["Grammar"]
    $P97."O"(":prec<i=>, :assoc<right>", "%assignment")
.annotate 'line', 618
    get_hll_global $P98, "GLOBAL"
    nqp_get_package_through_who $P99, $P98, "NQP"
    get_who $P100, $P99
    set $P101, $P100["Grammar"]
    $P101."O"(":prec<g=>, :assoc<list>, :nextterm<nulltermish>", "%comma")
.annotate 'line', 619
    get_hll_global $P102, "GLOBAL"
    nqp_get_package_through_who $P103, $P102, "NQP"
    get_who $P104, $P103
    set $P105, $P104["Grammar"]
    $P105."O"(":prec<f=>, :assoc<list>", "%list_infix")
.annotate 'line', 620
    get_hll_global $P106, "GLOBAL"
    nqp_get_package_through_who $P107, $P106, "NQP"
    get_who $P108, $P107
    set $P109, $P108["Grammar"]
    $P109."O"(":prec<e=>, :assoc<unary>", "%list_prefix")
.annotate 'line', 719
    .const 'Sub' $P1898 = "384_1304456155.152" 
    newclosure $P1909, $P1898
.annotate 'line', 9
    .return ($P1909)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "TOP"  :subid("13_1304456155.152") :outer("12_1304456155.152")
    .param pmc param_111
.annotate 'line', 10
    .lex "self", param_111
.annotate 'line', 12
    $P112 = root_new ['parrot';'Hash']
    .lex "%*LANG", $P112
.annotate 'line', 21
    $P113 = root_new ['parrot';'Hash']
    .lex "%*HOW", $P113
.annotate 'line', 28
    new $P114, "Undef"
    .lex "$*SC", $P114
.annotate 'line', 32
    new $P115, "Undef"
    .lex "$*SCOPE", $P115
.annotate 'line', 33
    new $P116, "Undef"
    .lex "$*MULTINESS", $P116
.annotate 'line', 34
    new $P117, "Undef"
    .lex "$*PKGDECL", $P117
.annotate 'line', 35
    new $P118, "Undef"
    .lex "$*INVOCANT_OK", $P118
.annotate 'line', 36
    new $P119, "Undef"
    .lex "$*RETURN_USED", $P119
.annotate 'line', 10
    find_lex $P122, "%*LANG"
    unless_null $P122, vivify_602
    get_hll_global $P120, "GLOBAL"
    get_who $P121, $P120
    set $P122, $P121["%LANG"]
    unless_null $P122, vivify_603
    die "Contextual %*LANG not found"
  vivify_603:
  vivify_602:
.annotate 'line', 13
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "NQP"
    get_who $P125, $P124
    set $P126, $P125["Regex"]
    find_lex $P129, "%*LANG"
    unless_null $P129, vivify_604
    get_hll_global $P127, "GLOBAL"
    get_who $P128, $P127
    set $P129, $P128["%LANG"]
    unless_null $P129, vivify_605
    die "Contextual %*LANG not found"
  vivify_605:
    store_lex "%*LANG", $P129
  vivify_604:
    set $P129["Regex"], $P126
.annotate 'line', 14
    get_hll_global $P130, "GLOBAL"
    nqp_get_package_through_who $P131, $P130, "NQP"
    get_who $P132, $P131
    set $P133, $P132["RegexActions"]
    find_lex $P136, "%*LANG"
    unless_null $P136, vivify_606
    get_hll_global $P134, "GLOBAL"
    get_who $P135, $P134
    set $P136, $P135["%LANG"]
    unless_null $P136, vivify_607
    die "Contextual %*LANG not found"
  vivify_607:
    store_lex "%*LANG", $P136
  vivify_606:
    set $P136["Regex-actions"], $P133
.annotate 'line', 15
    get_hll_global $P137, "GLOBAL"
    nqp_get_package_through_who $P138, $P137, "NQP"
    get_who $P139, $P138
    set $P140, $P139["Grammar"]
    find_lex $P143, "%*LANG"
    unless_null $P143, vivify_608
    get_hll_global $P141, "GLOBAL"
    get_who $P142, $P141
    set $P143, $P142["%LANG"]
    unless_null $P143, vivify_609
    die "Contextual %*LANG not found"
  vivify_609:
    store_lex "%*LANG", $P143
  vivify_608:
    set $P143["MAIN"], $P140
.annotate 'line', 16
    get_hll_global $P144, "GLOBAL"
    nqp_get_package_through_who $P145, $P144, "NQP"
    get_who $P146, $P145
    set $P147, $P146["Actions"]
    find_lex $P150, "%*LANG"
    unless_null $P150, vivify_610
    get_hll_global $P148, "GLOBAL"
    get_who $P149, $P148
    set $P150, $P149["%LANG"]
    unless_null $P150, vivify_611
    die "Contextual %*LANG not found"
  vivify_611:
    store_lex "%*LANG", $P150
  vivify_610:
    set $P150["MAIN-actions"], $P147
    find_lex $P153, "%*HOW"
    unless_null $P153, vivify_612
    get_hll_global $P151, "GLOBAL"
    get_who $P152, $P151
    set $P153, $P152["%HOW"]
    unless_null $P153, vivify_613
    die "Contextual %*HOW not found"
  vivify_613:
  vivify_612:
.annotate 'line', 22
    get_knowhow $P154
    find_lex $P157, "%*HOW"
    unless_null $P157, vivify_614
    get_hll_global $P155, "GLOBAL"
    get_who $P156, $P155
    set $P157, $P156["%HOW"]
    unless_null $P157, vivify_615
    die "Contextual %*HOW not found"
  vivify_615:
    store_lex "%*HOW", $P157
  vivify_614:
    set $P157["knowhow"], $P154
.annotate 'line', 23
    get_knowhow_attribute $P158
    find_lex $P161, "%*HOW"
    unless_null $P161, vivify_616
    get_hll_global $P159, "GLOBAL"
    get_who $P160, $P159
    set $P161, $P160["%HOW"]
    unless_null $P161, vivify_617
    die "Contextual %*HOW not found"
  vivify_617:
    store_lex "%*HOW", $P161
  vivify_616:
    set $P161["knowhow-attr"], $P158
.annotate 'line', 28
    get_hll_global $P162, "GLOBAL"
    nqp_get_package_through_who $P163, $P162, "HLL"
    nqp_get_package_through_who $P164, $P163, "Compiler"
    get_who $P165, $P164
    set $P166, $P165["SerializationContextBuilder"]
.annotate 'line', 30
    time $N167
    set $S168, $N167
    $P169 = $P166."new"($S168 :named("handle"))
.annotate 'line', 28
    store_lex "$*SC", $P169
.annotate 'line', 32
    new $P170, "String"
    assign $P170, ""
    store_lex "$*SCOPE", $P170
.annotate 'line', 33
    new $P171, "String"
    assign $P171, ""
    store_lex "$*MULTINESS", $P171
.annotate 'line', 34
    new $P172, "String"
    assign $P172, ""
    store_lex "$*PKGDECL", $P172
.annotate 'line', 35
    new $P173, "Integer"
    assign $P173, 0
    store_lex "$*INVOCANT_OK", $P173
.annotate 'line', 36
    new $P174, "Integer"
    assign $P174, 0
    store_lex "$*RETURN_USED", $P174
.annotate 'line', 37
    find_lex $P175, "self"
    $P176 = $P175."comp_unit"()
.annotate 'line', 10
    .return ($P176)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "identifier"  :subid("14_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx178_tgt
    .local int rx178_pos
    .local int rx178_off
    .local int rx178_eos
    .local int rx178_rep
    .local pmc rx178_cur
    .local pmc rx178_debug
    (rx178_cur, rx178_pos, rx178_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx178_cur
    .local pmc match
    .lex "$/", match
    length rx178_eos, rx178_tgt
    gt rx178_pos, rx178_eos, rx178_done
    set rx178_off, 0
    lt rx178_pos, 2, rx178_start
    sub rx178_off, rx178_pos, 1
    substr rx178_tgt, rx178_tgt, rx178_off
  rx178_start:
    eq $I10, 1, rx178_restart
    if_null rx178_debug, debug_618
    rx178_cur."!cursor_debug"("START", "identifier")
  debug_618:
    $I10 = self.'from'()
    ne $I10, -1, rxscan179_done
    goto rxscan179_scan
  rxscan179_loop:
    (rx178_pos) = rx178_cur."from"()
    inc rx178_pos
    rx178_cur."!cursor_from"(rx178_pos)
    ge rx178_pos, rx178_eos, rxscan179_done
  rxscan179_scan:
    set_addr $I10, rxscan179_loop
    rx178_cur."!mark_push"(0, rx178_pos, $I10)
  rxscan179_done:
.annotate 'line', 42
  # rx subrule "ident" subtype=method negate=
    rx178_cur."!cursor_pos"(rx178_pos)
    $P10 = rx178_cur."ident"()
    unless $P10, rx178_fail
    rx178_pos = $P10."pos"()
  # rx rxquantr180 ** 0..*
    set_addr $I10, rxquantr180_done
    rx178_cur."!mark_push"(0, rx178_pos, $I10)
  rxquantr180_loop:
  # rx enumcharlist negate=0 
    ge rx178_pos, rx178_eos, rx178_fail
    sub $I10, rx178_pos, rx178_off
    substr $S10, rx178_tgt, $I10, 1
    index $I11, "-'", $S10
    lt $I11, 0, rx178_fail
    inc rx178_pos
  # rx subrule "ident" subtype=method negate=
    rx178_cur."!cursor_pos"(rx178_pos)
    $P10 = rx178_cur."ident"()
    unless $P10, rx178_fail
    rx178_pos = $P10."pos"()
    set_addr $I10, rxquantr180_done
    (rx178_rep) = rx178_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr180_done
    rx178_cur."!mark_push"(rx178_rep, rx178_pos, $I10)
    goto rxquantr180_loop
  rxquantr180_done:
  # rx pass
    rx178_cur."!cursor_pass"(rx178_pos, "identifier")
    if_null rx178_debug, debug_619
    rx178_cur."!cursor_debug"("PASS", "identifier", " at pos=", rx178_pos)
  debug_619:
    .return (rx178_cur)
  rx178_restart:
.annotate 'line', 10
    if_null rx178_debug, debug_620
    rx178_cur."!cursor_debug"("NEXT", "identifier")
  debug_620:
  rx178_fail:
    (rx178_rep, rx178_pos, $I10, $P10) = rx178_cur."!mark_fail"(0)
    lt rx178_pos, -1, rx178_done
    eq rx178_pos, -1, rx178_fail
    jump $I10
  rx178_done:
    rx178_cur."!cursor_fail"()
    if_null rx178_debug, debug_621
    rx178_cur."!cursor_debug"("FAIL", "identifier")
  debug_621:
    .return (rx178_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__identifier"  :subid("15_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P182 = self."!PREFIX__!subrule"("ident", "")
    new $P183, "ResizablePMCArray"
    push $P183, $P182
    .return ($P183)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "name"  :subid("16_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx185_tgt
    .local int rx185_pos
    .local int rx185_off
    .local int rx185_eos
    .local int rx185_rep
    .local pmc rx185_cur
    .local pmc rx185_debug
    (rx185_cur, rx185_pos, rx185_tgt, $I10) = self."!cursor_start"()
    rx185_cur."!cursor_caparray"("identifier")
    .lex unicode:"$\x{a2}", rx185_cur
    .local pmc match
    .lex "$/", match
    length rx185_eos, rx185_tgt
    gt rx185_pos, rx185_eos, rx185_done
    set rx185_off, 0
    lt rx185_pos, 2, rx185_start
    sub rx185_off, rx185_pos, 1
    substr rx185_tgt, rx185_tgt, rx185_off
  rx185_start:
    eq $I10, 1, rx185_restart
    if_null rx185_debug, debug_622
    rx185_cur."!cursor_debug"("START", "name")
  debug_622:
    $I10 = self.'from'()
    ne $I10, -1, rxscan186_done
    goto rxscan186_scan
  rxscan186_loop:
    (rx185_pos) = rx185_cur."from"()
    inc rx185_pos
    rx185_cur."!cursor_from"(rx185_pos)
    ge rx185_pos, rx185_eos, rxscan186_done
  rxscan186_scan:
    set_addr $I10, rxscan186_loop
    rx185_cur."!mark_push"(0, rx185_pos, $I10)
  rxscan186_done:
.annotate 'line', 44
  # rx rxquantr187 ** 1..*
    set_addr $I10, rxquantr187_done
    rx185_cur."!mark_push"(0, -1, $I10)
  rxquantr187_loop:
  # rx subrule "identifier" subtype=capture negate=
    rx185_cur."!cursor_pos"(rx185_pos)
    $P10 = rx185_cur."identifier"()
    unless $P10, rx185_fail
    goto rxsubrule188_pass
  rxsubrule188_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx185_fail
  rxsubrule188_pass:
    set_addr $I10, rxsubrule188_back
    rx185_cur."!mark_push"(0, rx185_pos, $I10, $P10)
    $P10."!cursor_names"("identifier")
    rx185_pos = $P10."pos"()
    set_addr $I10, rxquantr187_done
    (rx185_rep) = rx185_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr187_done
    rx185_cur."!mark_push"(rx185_rep, rx185_pos, $I10)
  # rx literal  "::"
    add $I11, rx185_pos, 2
    gt $I11, rx185_eos, rx185_fail
    sub $I11, rx185_pos, rx185_off
    substr $S10, rx185_tgt, $I11, 2
    ne $S10, "::", rx185_fail
    add rx185_pos, 2
    goto rxquantr187_loop
  rxquantr187_done:
  # rx pass
    rx185_cur."!cursor_pass"(rx185_pos, "name")
    if_null rx185_debug, debug_623
    rx185_cur."!cursor_debug"("PASS", "name", " at pos=", rx185_pos)
  debug_623:
    .return (rx185_cur)
  rx185_restart:
.annotate 'line', 10
    if_null rx185_debug, debug_624
    rx185_cur."!cursor_debug"("NEXT", "name")
  debug_624:
  rx185_fail:
    (rx185_rep, rx185_pos, $I10, $P10) = rx185_cur."!mark_fail"(0)
    lt rx185_pos, -1, rx185_done
    eq rx185_pos, -1, rx185_fail
    jump $I10
  rx185_done:
    rx185_cur."!cursor_fail"()
    if_null rx185_debug, debug_625
    rx185_cur."!cursor_debug"("FAIL", "name")
  debug_625:
    .return (rx185_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__name"  :subid("17_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    new $P190, "ResizablePMCArray"
    push $P190, ""
    .return ($P190)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "deflongname"  :subid("18_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx192_tgt
    .local int rx192_pos
    .local int rx192_off
    .local int rx192_eos
    .local int rx192_rep
    .local pmc rx192_cur
    .local pmc rx192_debug
    (rx192_cur, rx192_pos, rx192_tgt, $I10) = self."!cursor_start"()
    rx192_cur."!cursor_caparray"("colonpair")
    .lex unicode:"$\x{a2}", rx192_cur
    .local pmc match
    .lex "$/", match
    length rx192_eos, rx192_tgt
    gt rx192_pos, rx192_eos, rx192_done
    set rx192_off, 0
    lt rx192_pos, 2, rx192_start
    sub rx192_off, rx192_pos, 1
    substr rx192_tgt, rx192_tgt, rx192_off
  rx192_start:
    eq $I10, 1, rx192_restart
    if_null rx192_debug, debug_626
    rx192_cur."!cursor_debug"("START", "deflongname")
  debug_626:
    $I10 = self.'from'()
    ne $I10, -1, rxscan193_done
    goto rxscan193_scan
  rxscan193_loop:
    (rx192_pos) = rx192_cur."from"()
    inc rx192_pos
    rx192_cur."!cursor_from"(rx192_pos)
    ge rx192_pos, rx192_eos, rxscan193_done
  rxscan193_scan:
    set_addr $I10, rxscan193_loop
    rx192_cur."!mark_push"(0, rx192_pos, $I10)
  rxscan193_done:
.annotate 'line', 47
  # rx subrule "identifier" subtype=capture negate=
    rx192_cur."!cursor_pos"(rx192_pos)
    $P10 = rx192_cur."identifier"()
    unless $P10, rx192_fail
    rx192_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx192_pos = $P10."pos"()
  # rx rxquantr194 ** 0..1
    set_addr $I10, rxquantr194_done
    rx192_cur."!mark_push"(0, rx192_pos, $I10)
  rxquantr194_loop:
  # rx subrule "colonpair" subtype=capture negate=
    rx192_cur."!cursor_pos"(rx192_pos)
    $P10 = rx192_cur."colonpair"()
    unless $P10, rx192_fail
    goto rxsubrule195_pass
  rxsubrule195_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx192_fail
  rxsubrule195_pass:
    set_addr $I10, rxsubrule195_back
    rx192_cur."!mark_push"(0, rx192_pos, $I10, $P10)
    $P10."!cursor_names"("colonpair")
    rx192_pos = $P10."pos"()
    set_addr $I10, rxquantr194_done
    (rx192_rep) = rx192_cur."!mark_commit"($I10)
  rxquantr194_done:
.annotate 'line', 46
  # rx pass
    rx192_cur."!cursor_pass"(rx192_pos, "deflongname")
    if_null rx192_debug, debug_627
    rx192_cur."!cursor_debug"("PASS", "deflongname", " at pos=", rx192_pos)
  debug_627:
    .return (rx192_cur)
  rx192_restart:
.annotate 'line', 10
    if_null rx192_debug, debug_628
    rx192_cur."!cursor_debug"("NEXT", "deflongname")
  debug_628:
  rx192_fail:
    (rx192_rep, rx192_pos, $I10, $P10) = rx192_cur."!mark_fail"(0)
    lt rx192_pos, -1, rx192_done
    eq rx192_pos, -1, rx192_fail
    jump $I10
  rx192_done:
    rx192_cur."!cursor_fail"()
    if_null rx192_debug, debug_629
    rx192_cur."!cursor_debug"("FAIL", "deflongname")
  debug_629:
    .return (rx192_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__deflongname"  :subid("19_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P197 = self."!PREFIX__!subrule"("identifier", "")
    new $P198, "ResizablePMCArray"
    push $P198, $P197
    .return ($P198)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ENDSTMT"  :subid("20_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx200_tgt
    .local int rx200_pos
    .local int rx200_off
    .local int rx200_eos
    .local int rx200_rep
    .local pmc rx200_cur
    .local pmc rx200_debug
    (rx200_cur, rx200_pos, rx200_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx200_cur
    .local pmc match
    .lex "$/", match
    length rx200_eos, rx200_tgt
    gt rx200_pos, rx200_eos, rx200_done
    set rx200_off, 0
    lt rx200_pos, 2, rx200_start
    sub rx200_off, rx200_pos, 1
    substr rx200_tgt, rx200_tgt, rx200_off
  rx200_start:
    eq $I10, 1, rx200_restart
    if_null rx200_debug, debug_630
    rx200_cur."!cursor_debug"("START", "ENDSTMT")
  debug_630:
    $I10 = self.'from'()
    ne $I10, -1, rxscan201_done
    goto rxscan201_scan
  rxscan201_loop:
    (rx200_pos) = rx200_cur."from"()
    inc rx200_pos
    rx200_cur."!cursor_from"(rx200_pos)
    ge rx200_pos, rx200_eos, rxscan201_done
  rxscan201_scan:
    set_addr $I10, rxscan201_loop
    rx200_cur."!mark_push"(0, rx200_pos, $I10)
  rxscan201_done:
.annotate 'line', 54
  # rx rxquantr202 ** 0..1
    set_addr $I10, rxquantr202_done
    rx200_cur."!mark_push"(0, rx200_pos, $I10)
  rxquantr202_loop:
  alt203_0:
.annotate 'line', 51
    set_addr $I10, alt203_1
    rx200_cur."!mark_push"(0, rx200_pos, $I10)
.annotate 'line', 52
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx200_pos, rx200_off
    set rx200_rep, 0
    sub $I12, rx200_eos, rx200_pos
  rxenumcharlistq204_loop:
    le $I12, 0, rxenumcharlistq204_done
    substr $S10, rx200_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq204_done
    inc rx200_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq204_loop
  rxenumcharlistq204_done:
    add rx200_pos, rx200_pos, rx200_rep
  # rxanchor eol
    sub $I10, rx200_pos, rx200_off
    is_cclass $I11, 4096, rx200_tgt, $I10
    if $I11, rxanchor205_done
    ne rx200_pos, rx200_eos, rx200_fail
    eq rx200_pos, 0, rxanchor205_done
    dec $I10
    is_cclass $I11, 4096, rx200_tgt, $I10
    if $I11, rx200_fail
  rxanchor205_done:
  # rx subrule "ws" subtype=method negate=
    rx200_cur."!cursor_pos"(rx200_pos)
    $P10 = rx200_cur."ws"()
    unless $P10, rx200_fail
    rx200_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx200_cur."!cursor_pos"(rx200_pos)
    $P10 = rx200_cur."MARKER"("endstmt")
    unless $P10, rx200_fail
    goto alt203_end
  alt203_1:
.annotate 'line', 53
  # rx rxquantr206 ** 0..1
    set_addr $I10, rxquantr206_done
    rx200_cur."!mark_push"(0, rx200_pos, $I10)
  rxquantr206_loop:
  # rx subrule "unv" subtype=method negate=
    rx200_cur."!cursor_pos"(rx200_pos)
    $P10 = rx200_cur."unv"()
    unless $P10, rx200_fail
    goto rxsubrule207_pass
  rxsubrule207_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx200_fail
  rxsubrule207_pass:
    set_addr $I10, rxsubrule207_back
    rx200_cur."!mark_push"(0, rx200_pos, $I10, $P10)
    rx200_pos = $P10."pos"()
    set_addr $I10, rxquantr206_done
    (rx200_rep) = rx200_cur."!mark_commit"($I10)
  rxquantr206_done:
  # rxanchor eol
    sub $I10, rx200_pos, rx200_off
    is_cclass $I11, 4096, rx200_tgt, $I10
    if $I11, rxanchor208_done
    ne rx200_pos, rx200_eos, rx200_fail
    eq rx200_pos, 0, rxanchor208_done
    dec $I10
    is_cclass $I11, 4096, rx200_tgt, $I10
    if $I11, rx200_fail
  rxanchor208_done:
  # rx subrule "ws" subtype=method negate=
    rx200_cur."!cursor_pos"(rx200_pos)
    $P10 = rx200_cur."ws"()
    unless $P10, rx200_fail
    rx200_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx200_cur."!cursor_pos"(rx200_pos)
    $P10 = rx200_cur."MARKER"("endstmt")
    unless $P10, rx200_fail
  alt203_end:
.annotate 'line', 54
    set_addr $I10, rxquantr202_done
    (rx200_rep) = rx200_cur."!mark_commit"($I10)
  rxquantr202_done:
.annotate 'line', 50
  # rx pass
    rx200_cur."!cursor_pass"(rx200_pos, "ENDSTMT")
    if_null rx200_debug, debug_631
    rx200_cur."!cursor_debug"("PASS", "ENDSTMT", " at pos=", rx200_pos)
  debug_631:
    .return (rx200_cur)
  rx200_restart:
.annotate 'line', 10
    if_null rx200_debug, debug_632
    rx200_cur."!cursor_debug"("NEXT", "ENDSTMT")
  debug_632:
  rx200_fail:
    (rx200_rep, rx200_pos, $I10, $P10) = rx200_cur."!mark_fail"(0)
    lt rx200_pos, -1, rx200_done
    eq rx200_pos, -1, rx200_fail
    jump $I10
  rx200_done:
    rx200_cur."!cursor_fail"()
    if_null rx200_debug, debug_633
    rx200_cur."!cursor_debug"("FAIL", "ENDSTMT")
  debug_633:
    .return (rx200_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ENDSTMT"  :subid("21_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    new $P210, "ResizablePMCArray"
    push $P210, ""
    .return ($P210)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ws"  :subid("22_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx212_tgt
    .local int rx212_pos
    .local int rx212_off
    .local int rx212_eos
    .local int rx212_rep
    .local pmc rx212_cur
    .local pmc rx212_debug
    (rx212_cur, rx212_pos, rx212_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx212_cur
    .local pmc match
    .lex "$/", match
    length rx212_eos, rx212_tgt
    gt rx212_pos, rx212_eos, rx212_done
    set rx212_off, 0
    lt rx212_pos, 2, rx212_start
    sub rx212_off, rx212_pos, 1
    substr rx212_tgt, rx212_tgt, rx212_off
  rx212_start:
    eq $I10, 1, rx212_restart
    if_null rx212_debug, debug_634
    rx212_cur."!cursor_debug"("START", "ws")
  debug_634:
    $I10 = self.'from'()
    ne $I10, -1, rxscan213_done
    goto rxscan213_scan
  rxscan213_loop:
    (rx212_pos) = rx212_cur."from"()
    inc rx212_pos
    rx212_cur."!cursor_from"(rx212_pos)
    ge rx212_pos, rx212_eos, rxscan213_done
  rxscan213_scan:
    set_addr $I10, rxscan213_loop
    rx212_cur."!mark_push"(0, rx212_pos, $I10)
  rxscan213_done:
  alt214_0:
.annotate 'line', 57
    set_addr $I10, alt214_1
    rx212_cur."!mark_push"(0, rx212_pos, $I10)
.annotate 'line', 58
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx212_cur."!cursor_pos"(rx212_pos)
    $P10 = rx212_cur."MARKED"("ws")
    unless $P10, rx212_fail
    goto alt214_end
  alt214_1:
.annotate 'line', 59
  # rx subrule "ww" subtype=zerowidth negate=1
    rx212_cur."!cursor_pos"(rx212_pos)
    $P10 = rx212_cur."ww"()
    if $P10, rx212_fail
.annotate 'line', 64
  # rx rxquantr215 ** 0..*
    set_addr $I10, rxquantr215_done
    rx212_cur."!mark_push"(0, rx212_pos, $I10)
  rxquantr215_loop:
  alt216_0:
.annotate 'line', 60
    set_addr $I10, alt216_1
    rx212_cur."!mark_push"(0, rx212_pos, $I10)
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx212_pos, rx212_off
    set rx212_rep, 0
    sub $I12, rx212_eos, rx212_pos
  rxenumcharlistq217_loop:
    le $I12, 0, rxenumcharlistq217_done
    substr $S10, rx212_tgt, $I10, 1
    index $I11, unicode:"\n\x{b}\f\r\x{85}\u2028\u2029", $S10
    lt $I11, 0, rxenumcharlistq217_done
    inc rx212_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq217_loop
  rxenumcharlistq217_done:
    lt rx212_rep, 1, rx212_fail
    add rx212_pos, rx212_pos, rx212_rep
    goto alt216_end
  alt216_1:
    set_addr $I10, alt216_2
    rx212_cur."!mark_push"(0, rx212_pos, $I10)
.annotate 'line', 61
  # rx literal  "#"
    add $I11, rx212_pos, 1
    gt $I11, rx212_eos, rx212_fail
    sub $I11, rx212_pos, rx212_off
    ord $I11, rx212_tgt, $I11
    ne $I11, 35, rx212_fail
    add rx212_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx212_pos, rx212_off
    find_cclass $I11, 4096, rx212_tgt, $I10, rx212_eos
    add rx212_pos, rx212_off, $I11
    goto alt216_end
  alt216_2:
    set_addr $I10, alt216_3
    rx212_cur."!mark_push"(0, rx212_pos, $I10)
.annotate 'line', 62
  # rxanchor bol
    eq rx212_pos, 0, rxanchor218_done
    ge rx212_pos, rx212_eos, rx212_fail
    sub $I10, rx212_pos, rx212_off
    dec $I10
    is_cclass $I11, 4096, rx212_tgt, $I10
    unless $I11, rx212_fail
  rxanchor218_done:
  # rx subrule "pod_comment" subtype=method negate=
    rx212_cur."!cursor_pos"(rx212_pos)
    $P10 = rx212_cur."pod_comment"()
    unless $P10, rx212_fail
    rx212_pos = $P10."pos"()
    goto alt216_end
  alt216_3:
.annotate 'line', 63
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx212_pos, rx212_off
    set rx212_rep, 0
    sub $I12, rx212_eos, rx212_pos
  rxenumcharlistq219_loop:
    le $I12, 0, rxenumcharlistq219_done
    substr $S10, rx212_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq219_done
    inc rx212_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq219_loop
  rxenumcharlistq219_done:
    lt rx212_rep, 1, rx212_fail
    add rx212_pos, rx212_pos, rx212_rep
  alt216_end:
.annotate 'line', 64
    set_addr $I10, rxquantr215_done
    (rx212_rep) = rx212_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr215_done
    rx212_cur."!mark_push"(rx212_rep, rx212_pos, $I10)
    goto rxquantr215_loop
  rxquantr215_done:
.annotate 'line', 65
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx212_cur."!cursor_pos"(rx212_pos)
    $P10 = rx212_cur."MARKER"("ws")
    unless $P10, rx212_fail
  alt214_end:
.annotate 'line', 57
  # rx pass
    rx212_cur."!cursor_pass"(rx212_pos, "ws")
    if_null rx212_debug, debug_635
    rx212_cur."!cursor_debug"("PASS", "ws", " at pos=", rx212_pos)
  debug_635:
    .return (rx212_cur)
  rx212_restart:
.annotate 'line', 10
    if_null rx212_debug, debug_636
    rx212_cur."!cursor_debug"("NEXT", "ws")
  debug_636:
  rx212_fail:
    (rx212_rep, rx212_pos, $I10, $P10) = rx212_cur."!mark_fail"(0)
    lt rx212_pos, -1, rx212_done
    eq rx212_pos, -1, rx212_fail
    jump $I10
  rx212_done:
    rx212_cur."!cursor_fail"()
    if_null rx212_debug, debug_637
    rx212_cur."!cursor_debug"("FAIL", "ws")
  debug_637:
    .return (rx212_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ws"  :subid("23_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    new $P221, "ResizablePMCArray"
    push $P221, ""
    push $P221, ""
    .return ($P221)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "unv"  :subid("24_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .const 'Sub' $P228 = "25_1304456155.152" 
    capture_lex $P228
    .local string rx223_tgt
    .local int rx223_pos
    .local int rx223_off
    .local int rx223_eos
    .local int rx223_rep
    .local pmc rx223_cur
    .local pmc rx223_debug
    (rx223_cur, rx223_pos, rx223_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx223_cur
    .local pmc match
    .lex "$/", match
    length rx223_eos, rx223_tgt
    gt rx223_pos, rx223_eos, rx223_done
    set rx223_off, 0
    lt rx223_pos, 2, rx223_start
    sub rx223_off, rx223_pos, 1
    substr rx223_tgt, rx223_tgt, rx223_off
  rx223_start:
    eq $I10, 1, rx223_restart
    if_null rx223_debug, debug_638
    rx223_cur."!cursor_debug"("START", "unv")
  debug_638:
    $I10 = self.'from'()
    ne $I10, -1, rxscan224_done
    goto rxscan224_scan
  rxscan224_loop:
    (rx223_pos) = rx223_cur."from"()
    inc rx223_pos
    rx223_cur."!cursor_from"(rx223_pos)
    ge rx223_pos, rx223_eos, rxscan224_done
  rxscan224_scan:
    set_addr $I10, rxscan224_loop
    rx223_cur."!mark_push"(0, rx223_pos, $I10)
  rxscan224_done:
  alt225_0:
.annotate 'line', 70
    set_addr $I10, alt225_1
    rx223_cur."!mark_push"(0, rx223_pos, $I10)
.annotate 'line', 71
  # rxanchor bol
    eq rx223_pos, 0, rxanchor226_done
    ge rx223_pos, rx223_eos, rx223_fail
    sub $I10, rx223_pos, rx223_off
    dec $I10
    is_cclass $I11, 4096, rx223_tgt, $I10
    unless $I11, rx223_fail
  rxanchor226_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx223_cur."!cursor_pos"(rx223_pos)
    .const 'Sub' $P228 = "25_1304456155.152" 
    capture_lex $P228
    $P10 = rx223_cur."before"($P228)
    unless $P10, rx223_fail
  # rx subrule "pod_comment" subtype=method negate=
    rx223_cur."!cursor_pos"(rx223_pos)
    $P10 = rx223_cur."pod_comment"()
    unless $P10, rx223_fail
    rx223_pos = $P10."pos"()
    goto alt225_end
  alt225_1:
    set_addr $I10, alt225_2
    rx223_cur."!mark_push"(0, rx223_pos, $I10)
.annotate 'line', 72
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx223_pos, rx223_off
    set rx223_rep, 0
    sub $I12, rx223_eos, rx223_pos
  rxenumcharlistq233_loop:
    le $I12, 0, rxenumcharlistq233_done
    substr $S10, rx223_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq233_done
    inc rx223_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq233_loop
  rxenumcharlistq233_done:
    add rx223_pos, rx223_pos, rx223_rep
  # rx literal  "#"
    add $I11, rx223_pos, 1
    gt $I11, rx223_eos, rx223_fail
    sub $I11, rx223_pos, rx223_off
    ord $I11, rx223_tgt, $I11
    ne $I11, 35, rx223_fail
    add rx223_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx223_pos, rx223_off
    find_cclass $I11, 4096, rx223_tgt, $I10, rx223_eos
    add rx223_pos, rx223_off, $I11
    goto alt225_end
  alt225_2:
.annotate 'line', 73
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx223_pos, rx223_off
    set rx223_rep, 0
    sub $I12, rx223_eos, rx223_pos
  rxenumcharlistq234_loop:
    le $I12, 0, rxenumcharlistq234_done
    substr $S10, rx223_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq234_done
    inc rx223_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq234_loop
  rxenumcharlistq234_done:
    lt rx223_rep, 1, rx223_fail
    add rx223_pos, rx223_pos, rx223_rep
  alt225_end:
.annotate 'line', 68
  # rx pass
    rx223_cur."!cursor_pass"(rx223_pos, "unv")
    if_null rx223_debug, debug_643
    rx223_cur."!cursor_debug"("PASS", "unv", " at pos=", rx223_pos)
  debug_643:
    .return (rx223_cur)
  rx223_restart:
.annotate 'line', 10
    if_null rx223_debug, debug_644
    rx223_cur."!cursor_debug"("NEXT", "unv")
  debug_644:
  rx223_fail:
    (rx223_rep, rx223_pos, $I10, $P10) = rx223_cur."!mark_fail"(0)
    lt rx223_pos, -1, rx223_done
    eq rx223_pos, -1, rx223_fail
    jump $I10
  rx223_done:
    rx223_cur."!cursor_fail"()
    if_null rx223_debug, debug_645
    rx223_cur."!cursor_debug"("FAIL", "unv")
  debug_645:
    .return (rx223_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block227"  :anon :subid("25_1304456155.152") :method :outer("24_1304456155.152")
.annotate 'line', 71
    .local string rx229_tgt
    .local int rx229_pos
    .local int rx229_off
    .local int rx229_eos
    .local int rx229_rep
    .local pmc rx229_cur
    .local pmc rx229_debug
    (rx229_cur, rx229_pos, rx229_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx229_cur
    .local pmc match
    .lex "$/", match
    length rx229_eos, rx229_tgt
    gt rx229_pos, rx229_eos, rx229_done
    set rx229_off, 0
    lt rx229_pos, 2, rx229_start
    sub rx229_off, rx229_pos, 1
    substr rx229_tgt, rx229_tgt, rx229_off
  rx229_start:
    eq $I10, 1, rx229_restart
    if_null rx229_debug, debug_639
    rx229_cur."!cursor_debug"("START", "")
  debug_639:
    $I10 = self.'from'()
    ne $I10, -1, rxscan230_done
    goto rxscan230_scan
  rxscan230_loop:
    (rx229_pos) = rx229_cur."from"()
    inc rx229_pos
    rx229_cur."!cursor_from"(rx229_pos)
    ge rx229_pos, rx229_eos, rxscan230_done
  rxscan230_scan:
    set_addr $I10, rxscan230_loop
    rx229_cur."!mark_push"(0, rx229_pos, $I10)
  rxscan230_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx229_pos, rx229_off
    set rx229_rep, 0
    sub $I12, rx229_eos, rx229_pos
  rxenumcharlistq231_loop:
    le $I12, 0, rxenumcharlistq231_done
    substr $S10, rx229_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq231_done
    inc rx229_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq231_loop
  rxenumcharlistq231_done:
    add rx229_pos, rx229_pos, rx229_rep
  # rx literal  "="
    add $I11, rx229_pos, 1
    gt $I11, rx229_eos, rx229_fail
    sub $I11, rx229_pos, rx229_off
    ord $I11, rx229_tgt, $I11
    ne $I11, 61, rx229_fail
    add rx229_pos, 1
  alt232_0:
    set_addr $I10, alt232_1
    rx229_cur."!mark_push"(0, rx229_pos, $I10)
  # rx charclass w
    ge rx229_pos, rx229_eos, rx229_fail
    sub $I10, rx229_pos, rx229_off
    is_cclass $I11, 8192, rx229_tgt, $I10
    unless $I11, rx229_fail
    inc rx229_pos
    goto alt232_end
  alt232_1:
  # rx literal  "\\"
    add $I11, rx229_pos, 1
    gt $I11, rx229_eos, rx229_fail
    sub $I11, rx229_pos, rx229_off
    ord $I11, rx229_tgt, $I11
    ne $I11, 92, rx229_fail
    add rx229_pos, 1
  alt232_end:
  # rx pass
    rx229_cur."!cursor_pass"(rx229_pos, "")
    if_null rx229_debug, debug_640
    rx229_cur."!cursor_debug"("PASS", "", " at pos=", rx229_pos)
  debug_640:
    .return (rx229_cur)
  rx229_restart:
    if_null rx229_debug, debug_641
    rx229_cur."!cursor_debug"("NEXT", "")
  debug_641:
  rx229_fail:
    (rx229_rep, rx229_pos, $I10, $P10) = rx229_cur."!mark_fail"(0)
    lt rx229_pos, -1, rx229_done
    eq rx229_pos, -1, rx229_fail
    jump $I10
  rx229_done:
    rx229_cur."!cursor_fail"()
    if_null rx229_debug, debug_642
    rx229_cur."!cursor_debug"("FAIL", "")
  debug_642:
    .return (rx229_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__unv"  :subid("26_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    new $P236, "ResizablePMCArray"
    push $P236, ""
    push $P236, ""
    push $P236, ""
    .return ($P236)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pod_comment"  :subid("27_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .const 'Sub' $P267 = "28_1304456155.152" 
    capture_lex $P267
    .local string rx238_tgt
    .local int rx238_pos
    .local int rx238_off
    .local int rx238_eos
    .local int rx238_rep
    .local pmc rx238_cur
    .local pmc rx238_debug
    (rx238_cur, rx238_pos, rx238_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx238_cur
    .local pmc match
    .lex "$/", match
    length rx238_eos, rx238_tgt
    gt rx238_pos, rx238_eos, rx238_done
    set rx238_off, 0
    lt rx238_pos, 2, rx238_start
    sub rx238_off, rx238_pos, 1
    substr rx238_tgt, rx238_tgt, rx238_off
  rx238_start:
    eq $I10, 1, rx238_restart
    if_null rx238_debug, debug_646
    rx238_cur."!cursor_debug"("START", "pod_comment")
  debug_646:
    $I10 = self.'from'()
    ne $I10, -1, rxscan239_done
    goto rxscan239_scan
  rxscan239_loop:
    (rx238_pos) = rx238_cur."from"()
    inc rx238_pos
    rx238_cur."!cursor_from"(rx238_pos)
    ge rx238_pos, rx238_eos, rxscan239_done
  rxscan239_scan:
    set_addr $I10, rxscan239_loop
    rx238_cur."!mark_push"(0, rx238_pos, $I10)
  rxscan239_done:
.annotate 'line', 78
  # rxanchor bol
    eq rx238_pos, 0, rxanchor240_done
    ge rx238_pos, rx238_eos, rx238_fail
    sub $I10, rx238_pos, rx238_off
    dec $I10
    is_cclass $I11, 4096, rx238_tgt, $I10
    unless $I11, rx238_fail
  rxanchor240_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx238_pos, rx238_off
    set rx238_rep, 0
    sub $I12, rx238_eos, rx238_pos
  rxenumcharlistq241_loop:
    le $I12, 0, rxenumcharlistq241_done
    substr $S10, rx238_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq241_done
    inc rx238_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq241_loop
  rxenumcharlistq241_done:
    add rx238_pos, rx238_pos, rx238_rep
  # rx literal  "="
    add $I11, rx238_pos, 1
    gt $I11, rx238_eos, rx238_fail
    sub $I11, rx238_pos, rx238_off
    ord $I11, rx238_tgt, $I11
    ne $I11, 61, rx238_fail
    add rx238_pos, 1
  alt242_0:
.annotate 'line', 79
    set_addr $I10, alt242_1
    rx238_cur."!mark_push"(0, rx238_pos, $I10)
.annotate 'line', 80
  # rx literal  "begin"
    add $I11, rx238_pos, 5
    gt $I11, rx238_eos, rx238_fail
    sub $I11, rx238_pos, rx238_off
    substr $S10, rx238_tgt, $I11, 5
    ne $S10, "begin", rx238_fail
    add rx238_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx238_pos, rx238_off
    set rx238_rep, 0
    sub $I12, rx238_eos, rx238_pos
  rxenumcharlistq243_loop:
    le $I12, 0, rxenumcharlistq243_done
    substr $S10, rx238_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq243_done
    inc rx238_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq243_loop
  rxenumcharlistq243_done:
    lt rx238_rep, 1, rx238_fail
    add rx238_pos, rx238_pos, rx238_rep
  # rx literal  "END"
    add $I11, rx238_pos, 3
    gt $I11, rx238_eos, rx238_fail
    sub $I11, rx238_pos, rx238_off
    substr $S10, rx238_tgt, $I11, 3
    ne $S10, "END", rx238_fail
    add rx238_pos, 3
  # rxanchor rwb
    le rx238_pos, 0, rx238_fail
    sub $I10, rx238_pos, rx238_off
    is_cclass $I11, 8192, rx238_tgt, $I10
    if $I11, rx238_fail
    dec $I10
    is_cclass $I11, 8192, rx238_tgt, $I10
    unless $I11, rx238_fail
  alt244_0:
.annotate 'line', 81
    set_addr $I10, alt244_1
    rx238_cur."!mark_push"(0, rx238_pos, $I10)
  # rx rxquantf245 ** 0..*
    set_addr $I10, rxquantf245_loop
    rx238_cur."!mark_push"(0, rx238_pos, $I10)
    goto rxquantf245_done
  rxquantf245_loop:
  # rx charclass .
    ge rx238_pos, rx238_eos, rx238_fail
    inc rx238_pos
    set_addr $I10, rxquantf245_loop
    rx238_cur."!mark_push"(rx238_rep, rx238_pos, $I10)
  rxquantf245_done:
  # rx charclass nl
    ge rx238_pos, rx238_eos, rx238_fail
    sub $I10, rx238_pos, rx238_off
    is_cclass $I11, 4096, rx238_tgt, $I10
    unless $I11, rx238_fail
    substr $S10, rx238_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx238_pos, $I11
    inc rx238_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx238_pos, rx238_off
    set rx238_rep, 0
    sub $I12, rx238_eos, rx238_pos
  rxenumcharlistq247_loop:
    le $I12, 0, rxenumcharlistq247_done
    substr $S10, rx238_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq247_done
    inc rx238_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq247_loop
  rxenumcharlistq247_done:
    add rx238_pos, rx238_pos, rx238_rep
  # rx literal  "=end"
    add $I11, rx238_pos, 4
    gt $I11, rx238_eos, rx238_fail
    sub $I11, rx238_pos, rx238_off
    substr $S10, rx238_tgt, $I11, 4
    ne $S10, "=end", rx238_fail
    add rx238_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx238_pos, rx238_off
    set rx238_rep, 0
    sub $I12, rx238_eos, rx238_pos
  rxenumcharlistq248_loop:
    le $I12, 0, rxenumcharlistq248_done
    substr $S10, rx238_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq248_done
    inc rx238_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq248_loop
  rxenumcharlistq248_done:
    lt rx238_rep, 1, rx238_fail
    add rx238_pos, rx238_pos, rx238_rep
  # rx literal  "END"
    add $I11, rx238_pos, 3
    gt $I11, rx238_eos, rx238_fail
    sub $I11, rx238_pos, rx238_off
    substr $S10, rx238_tgt, $I11, 3
    ne $S10, "END", rx238_fail
    add rx238_pos, 3
  # rxanchor rwb
    le rx238_pos, 0, rx238_fail
    sub $I10, rx238_pos, rx238_off
    is_cclass $I11, 8192, rx238_tgt, $I10
    if $I11, rx238_fail
    dec $I10
    is_cclass $I11, 8192, rx238_tgt, $I10
    unless $I11, rx238_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx238_pos, rx238_off
    find_cclass $I11, 4096, rx238_tgt, $I10, rx238_eos
    add rx238_pos, rx238_off, $I11
    goto alt244_end
  alt244_1:
  # rx charclass_q . r 0..-1
    sub $I10, rx238_pos, rx238_off
    find_not_cclass $I11, 65535, rx238_tgt, $I10, rx238_eos
    add rx238_pos, rx238_off, $I11
  alt244_end:
.annotate 'line', 80
    goto alt242_end
  alt242_1:
    set_addr $I10, alt242_2
    rx238_cur."!mark_push"(0, rx238_pos, $I10)
.annotate 'line', 82
  # rx literal  "begin"
    add $I11, rx238_pos, 5
    gt $I11, rx238_eos, rx238_fail
    sub $I11, rx238_pos, rx238_off
    substr $S10, rx238_tgt, $I11, 5
    ne $S10, "begin", rx238_fail
    add rx238_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx238_pos, rx238_off
    set rx238_rep, 0
    sub $I12, rx238_eos, rx238_pos
  rxenumcharlistq249_loop:
    le $I12, 0, rxenumcharlistq249_done
    substr $S10, rx238_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq249_done
    inc rx238_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq249_loop
  rxenumcharlistq249_done:
    lt rx238_rep, 1, rx238_fail
    add rx238_pos, rx238_pos, rx238_rep
  # rx subrule "identifier" subtype=capture negate=
    rx238_cur."!cursor_pos"(rx238_pos)
    $P10 = rx238_cur."identifier"()
    unless $P10, rx238_fail
    rx238_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx238_pos = $P10."pos"()
  alt250_0:
.annotate 'line', 83
    set_addr $I10, alt250_1
    rx238_cur."!mark_push"(0, rx238_pos, $I10)
.annotate 'line', 84
  # rx rxquantf251 ** 0..*
    set_addr $I10, rxquantf251_loop
    rx238_cur."!mark_push"(0, rx238_pos, $I10)
    goto rxquantf251_done
  rxquantf251_loop:
  # rx charclass .
    ge rx238_pos, rx238_eos, rx238_fail
    inc rx238_pos
    set_addr $I10, rxquantf251_loop
    rx238_cur."!mark_push"(rx238_rep, rx238_pos, $I10)
  rxquantf251_done:
  # rx charclass nl
    ge rx238_pos, rx238_eos, rx238_fail
    sub $I10, rx238_pos, rx238_off
    is_cclass $I11, 4096, rx238_tgt, $I10
    unless $I11, rx238_fail
    substr $S10, rx238_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx238_pos, $I11
    inc rx238_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx238_pos, rx238_off
    set rx238_rep, 0
    sub $I12, rx238_eos, rx238_pos
  rxenumcharlistq253_loop:
    le $I12, 0, rxenumcharlistq253_done
    substr $S10, rx238_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq253_done
    inc rx238_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq253_loop
  rxenumcharlistq253_done:
    add rx238_pos, rx238_pos, rx238_rep
  # rx literal  "=end"
    add $I11, rx238_pos, 4
    gt $I11, rx238_eos, rx238_fail
    sub $I11, rx238_pos, rx238_off
    substr $S10, rx238_tgt, $I11, 4
    ne $S10, "=end", rx238_fail
    add rx238_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx238_pos, rx238_off
    set rx238_rep, 0
    sub $I12, rx238_eos, rx238_pos
  rxenumcharlistq254_loop:
    le $I12, 0, rxenumcharlistq254_done
    substr $S10, rx238_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq254_done
    inc rx238_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq254_loop
  rxenumcharlistq254_done:
    lt rx238_rep, 1, rx238_fail
    add rx238_pos, rx238_pos, rx238_rep
  # rx subrule "!BACKREF" subtype=method negate=
    rx238_cur."!cursor_pos"(rx238_pos)
    $P10 = rx238_cur."!BACKREF"("identifier")
    unless $P10, rx238_fail
    rx238_pos = $P10."pos"()
  # rxanchor rwb
    le rx238_pos, 0, rx238_fail
    sub $I10, rx238_pos, rx238_off
    is_cclass $I11, 8192, rx238_tgt, $I10
    if $I11, rx238_fail
    dec $I10
    is_cclass $I11, 8192, rx238_tgt, $I10
    unless $I11, rx238_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx238_pos, rx238_off
    find_cclass $I11, 4096, rx238_tgt, $I10, rx238_eos
    add rx238_pos, rx238_off, $I11
    goto alt250_end
  alt250_1:
.annotate 'line', 85
  # rx subrule "panic" subtype=method negate=
    rx238_cur."!cursor_pos"(rx238_pos)
    $P10 = rx238_cur."panic"("=begin without matching =end")
    unless $P10, rx238_fail
    rx238_pos = $P10."pos"()
  alt250_end:
.annotate 'line', 82
    goto alt242_end
  alt242_2:
    set_addr $I10, alt242_3
    rx238_cur."!mark_push"(0, rx238_pos, $I10)
.annotate 'line', 87
  # rx literal  "begin"
    add $I11, rx238_pos, 5
    gt $I11, rx238_eos, rx238_fail
    sub $I11, rx238_pos, rx238_off
    substr $S10, rx238_tgt, $I11, 5
    ne $S10, "begin", rx238_fail
    add rx238_pos, 5
  # rxanchor rwb
    le rx238_pos, 0, rx238_fail
    sub $I10, rx238_pos, rx238_off
    is_cclass $I11, 8192, rx238_tgt, $I10
    if $I11, rx238_fail
    dec $I10
    is_cclass $I11, 8192, rx238_tgt, $I10
    unless $I11, rx238_fail
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx238_pos, rx238_off
    set rx238_rep, 0
    sub $I12, rx238_eos, rx238_pos
  rxenumcharlistq256_loop:
    le $I12, 0, rxenumcharlistq256_done
    substr $S10, rx238_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq256_done
    inc rx238_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq256_loop
  rxenumcharlistq256_done:
    add rx238_pos, rx238_pos, rx238_rep
  alt257_0:
.annotate 'line', 88
    set_addr $I10, alt257_1
    rx238_cur."!mark_push"(0, rx238_pos, $I10)
  # rxanchor eol
    sub $I10, rx238_pos, rx238_off
    is_cclass $I11, 4096, rx238_tgt, $I10
    if $I11, rxanchor258_done
    ne rx238_pos, rx238_eos, rx238_fail
    eq rx238_pos, 0, rxanchor258_done
    dec $I10
    is_cclass $I11, 4096, rx238_tgt, $I10
    if $I11, rx238_fail
  rxanchor258_done:
    goto alt257_end
  alt257_1:
    set_addr $I10, alt257_2
    rx238_cur."!mark_push"(0, rx238_pos, $I10)
  # rx literal  "#"
    add $I11, rx238_pos, 1
    gt $I11, rx238_eos, rx238_fail
    sub $I11, rx238_pos, rx238_off
    ord $I11, rx238_tgt, $I11
    ne $I11, 35, rx238_fail
    add rx238_pos, 1
    goto alt257_end
  alt257_2:
  # rx subrule "panic" subtype=method negate=
    rx238_cur."!cursor_pos"(rx238_pos)
    $P10 = rx238_cur."panic"("Unrecognized token after =begin")
    unless $P10, rx238_fail
    rx238_pos = $P10."pos"()
  alt257_end:
  alt259_0:
.annotate 'line', 89
    set_addr $I10, alt259_1
    rx238_cur."!mark_push"(0, rx238_pos, $I10)
.annotate 'line', 90
  # rx rxquantf260 ** 0..*
    set_addr $I10, rxquantf260_loop
    rx238_cur."!mark_push"(0, rx238_pos, $I10)
    goto rxquantf260_done
  rxquantf260_loop:
  # rx charclass .
    ge rx238_pos, rx238_eos, rx238_fail
    inc rx238_pos
    set_addr $I10, rxquantf260_loop
    rx238_cur."!mark_push"(rx238_rep, rx238_pos, $I10)
  rxquantf260_done:
  # rx charclass nl
    ge rx238_pos, rx238_eos, rx238_fail
    sub $I10, rx238_pos, rx238_off
    is_cclass $I11, 4096, rx238_tgt, $I10
    unless $I11, rx238_fail
    substr $S10, rx238_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx238_pos, $I11
    inc rx238_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx238_pos, rx238_off
    set rx238_rep, 0
    sub $I12, rx238_eos, rx238_pos
  rxenumcharlistq262_loop:
    le $I12, 0, rxenumcharlistq262_done
    substr $S10, rx238_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq262_done
    inc rx238_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq262_loop
  rxenumcharlistq262_done:
    add rx238_pos, rx238_pos, rx238_rep
  # rx literal  "=end"
    add $I11, rx238_pos, 4
    gt $I11, rx238_eos, rx238_fail
    sub $I11, rx238_pos, rx238_off
    substr $S10, rx238_tgt, $I11, 4
    ne $S10, "=end", rx238_fail
    add rx238_pos, 4
  # rxanchor rwb
    le rx238_pos, 0, rx238_fail
    sub $I10, rx238_pos, rx238_off
    is_cclass $I11, 8192, rx238_tgt, $I10
    if $I11, rx238_fail
    dec $I10
    is_cclass $I11, 8192, rx238_tgt, $I10
    unless $I11, rx238_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx238_pos, rx238_off
    find_cclass $I11, 4096, rx238_tgt, $I10, rx238_eos
    add rx238_pos, rx238_off, $I11
    goto alt259_end
  alt259_1:
.annotate 'line', 91
  # rx subrule "panic" subtype=method negate=
    rx238_cur."!cursor_pos"(rx238_pos)
    $P10 = rx238_cur."panic"("=begin without matching =end")
    unless $P10, rx238_fail
    rx238_pos = $P10."pos"()
  alt259_end:
.annotate 'line', 87
    goto alt242_end
  alt242_3:
    set_addr $I10, alt242_4
    rx238_cur."!mark_push"(0, rx238_pos, $I10)
.annotate 'line', 93
  # rx subrule "identifier" subtype=capture negate=
    rx238_cur."!cursor_pos"(rx238_pos)
    $P10 = rx238_cur."identifier"()
    unless $P10, rx238_fail
    rx238_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx238_pos = $P10."pos"()
.annotate 'line', 94
  # rx rxquantf263 ** 0..*
    set_addr $I10, rxquantf263_loop
    rx238_cur."!mark_push"(0, rx238_pos, $I10)
    goto rxquantf263_done
  rxquantf263_loop:
  # rx charclass .
    ge rx238_pos, rx238_eos, rx238_fail
    inc rx238_pos
    set_addr $I10, rxquantf263_loop
    rx238_cur."!mark_push"(rx238_rep, rx238_pos, $I10)
  rxquantf263_done:
  # rxanchor bol
    eq rx238_pos, 0, rxanchor265_done
    ge rx238_pos, rx238_eos, rx238_fail
    sub $I10, rx238_pos, rx238_off
    dec $I10
    is_cclass $I11, 4096, rx238_tgt, $I10
    unless $I11, rx238_fail
  rxanchor265_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx238_cur."!cursor_pos"(rx238_pos)
    .const 'Sub' $P267 = "28_1304456155.152" 
    capture_lex $P267
    $P10 = rx238_cur."before"($P267)
    unless $P10, rx238_fail
.annotate 'line', 93
    goto alt242_end
  alt242_4:
  alt273_0:
.annotate 'line', 100
    set_addr $I10, alt273_1
    rx238_cur."!mark_push"(0, rx238_pos, $I10)
  # rx charclass s
    ge rx238_pos, rx238_eos, rx238_fail
    sub $I10, rx238_pos, rx238_off
    is_cclass $I11, 32, rx238_tgt, $I10
    unless $I11, rx238_fail
    inc rx238_pos
    goto alt273_end
  alt273_1:
  # rx subrule "panic" subtype=method negate=
    rx238_cur."!cursor_pos"(rx238_pos)
    $P10 = rx238_cur."panic"("Illegal pod directive")
    unless $P10, rx238_fail
    rx238_pos = $P10."pos"()
  alt273_end:
.annotate 'line', 101
  # rx charclass_q N r 0..-1
    sub $I10, rx238_pos, rx238_off
    find_cclass $I11, 4096, rx238_tgt, $I10, rx238_eos
    add rx238_pos, rx238_off, $I11
  alt242_end:
.annotate 'line', 77
  # rx pass
    rx238_cur."!cursor_pass"(rx238_pos, "pod_comment")
    if_null rx238_debug, debug_651
    rx238_cur."!cursor_debug"("PASS", "pod_comment", " at pos=", rx238_pos)
  debug_651:
    .return (rx238_cur)
  rx238_restart:
.annotate 'line', 10
    if_null rx238_debug, debug_652
    rx238_cur."!cursor_debug"("NEXT", "pod_comment")
  debug_652:
  rx238_fail:
    (rx238_rep, rx238_pos, $I10, $P10) = rx238_cur."!mark_fail"(0)
    lt rx238_pos, -1, rx238_done
    eq rx238_pos, -1, rx238_fail
    jump $I10
  rx238_done:
    rx238_cur."!cursor_fail"()
    if_null rx238_debug, debug_653
    rx238_cur."!cursor_debug"("FAIL", "pod_comment")
  debug_653:
    .return (rx238_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block266"  :anon :subid("28_1304456155.152") :method :outer("27_1304456155.152")
.annotate 'line', 94
    .local string rx268_tgt
    .local int rx268_pos
    .local int rx268_off
    .local int rx268_eos
    .local int rx268_rep
    .local pmc rx268_cur
    .local pmc rx268_debug
    (rx268_cur, rx268_pos, rx268_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx268_cur
    .local pmc match
    .lex "$/", match
    length rx268_eos, rx268_tgt
    gt rx268_pos, rx268_eos, rx268_done
    set rx268_off, 0
    lt rx268_pos, 2, rx268_start
    sub rx268_off, rx268_pos, 1
    substr rx268_tgt, rx268_tgt, rx268_off
  rx268_start:
    eq $I10, 1, rx268_restart
    if_null rx268_debug, debug_647
    rx268_cur."!cursor_debug"("START", "")
  debug_647:
    $I10 = self.'from'()
    ne $I10, -1, rxscan269_done
    goto rxscan269_scan
  rxscan269_loop:
    (rx268_pos) = rx268_cur."from"()
    inc rx268_pos
    rx268_cur."!cursor_from"(rx268_pos)
    ge rx268_pos, rx268_eos, rxscan269_done
  rxscan269_scan:
    set_addr $I10, rxscan269_loop
    rx268_cur."!mark_push"(0, rx268_pos, $I10)
  rxscan269_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx268_pos, rx268_off
    set rx268_rep, 0
    sub $I12, rx268_eos, rx268_pos
  rxenumcharlistq270_loop:
    le $I12, 0, rxenumcharlistq270_done
    substr $S10, rx268_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq270_done
    inc rx268_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq270_loop
  rxenumcharlistq270_done:
    add rx268_pos, rx268_pos, rx268_rep
  alt271_0:
    set_addr $I10, alt271_1
    rx268_cur."!mark_push"(0, rx268_pos, $I10)
.annotate 'line', 95
  # rx literal  "="
    add $I11, rx268_pos, 1
    gt $I11, rx268_eos, rx268_fail
    sub $I11, rx268_pos, rx268_off
    ord $I11, rx268_tgt, $I11
    ne $I11, 61, rx268_fail
    add rx268_pos, 1
.annotate 'line', 97
  # rx rxquantr272 ** 0..1
    set_addr $I10, rxquantr272_done
    rx268_cur."!mark_push"(0, rx268_pos, $I10)
  rxquantr272_loop:
.annotate 'line', 96
  # rx literal  "cut"
    add $I11, rx268_pos, 3
    gt $I11, rx268_eos, rx268_fail
    sub $I11, rx268_pos, rx268_off
    substr $S10, rx268_tgt, $I11, 3
    ne $S10, "cut", rx268_fail
    add rx268_pos, 3
  # rxanchor rwb
    le rx268_pos, 0, rx268_fail
    sub $I10, rx268_pos, rx268_off
    is_cclass $I11, 8192, rx268_tgt, $I10
    if $I11, rx268_fail
    dec $I10
    is_cclass $I11, 8192, rx268_tgt, $I10
    unless $I11, rx268_fail
.annotate 'line', 97
  # rx subrule "panic" subtype=method negate=
    rx268_cur."!cursor_pos"(rx268_pos)
    $P10 = rx268_cur."panic"("Obsolete pod format, please use =begin/=end instead")
    unless $P10, rx268_fail
    rx268_pos = $P10."pos"()
    set_addr $I10, rxquantr272_done
    (rx268_rep) = rx268_cur."!mark_commit"($I10)
  rxquantr272_done:
.annotate 'line', 94
    goto alt271_end
  alt271_1:
.annotate 'line', 98
  # rx charclass nl
    ge rx268_pos, rx268_eos, rx268_fail
    sub $I10, rx268_pos, rx268_off
    is_cclass $I11, 4096, rx268_tgt, $I10
    unless $I11, rx268_fail
    substr $S10, rx268_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx268_pos, $I11
    inc rx268_pos
  alt271_end:
.annotate 'line', 94
  # rx pass
    rx268_cur."!cursor_pass"(rx268_pos, "")
    if_null rx268_debug, debug_648
    rx268_cur."!cursor_debug"("PASS", "", " at pos=", rx268_pos)
  debug_648:
    .return (rx268_cur)
  rx268_restart:
    if_null rx268_debug, debug_649
    rx268_cur."!cursor_debug"("NEXT", "")
  debug_649:
  rx268_fail:
    (rx268_rep, rx268_pos, $I10, $P10) = rx268_cur."!mark_fail"(0)
    lt rx268_pos, -1, rx268_done
    eq rx268_pos, -1, rx268_fail
    jump $I10
  rx268_done:
    rx268_cur."!cursor_fail"()
    if_null rx268_debug, debug_650
    rx268_cur."!cursor_debug"("FAIL", "")
  debug_650:
    .return (rx268_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pod_comment"  :subid("29_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    new $P275, "ResizablePMCArray"
    push $P275, ""
    .return ($P275)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "comp_unit"  :subid("30_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 109
    new $P277, "Undef"
    .lex "$*IN_DECL", $P277
.annotate 'line', 111
    new $P278, "Undef"
    .lex "$*HAS_YOU_ARE_HERE", $P278
.annotate 'line', 112
    new $P279, "Undef"
    .lex "$*MAIN_SUB", $P279
.annotate 'line', 115
    new $P280, "Undef"
    .lex "$*PACKAGE", $P280
.annotate 'line', 116
    new $P281, "Undef"
    .lex "$*GLOBALish", $P281
.annotate 'line', 10
    .local string rx282_tgt
    .local int rx282_pos
    .local int rx282_off
    .local int rx282_eos
    .local int rx282_rep
    .local pmc rx282_cur
    .local pmc rx282_debug
    (rx282_cur, rx282_pos, rx282_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx282_cur
    .local pmc match
    .lex "$/", match
    length rx282_eos, rx282_tgt
    gt rx282_pos, rx282_eos, rx282_done
    set rx282_off, 0
    lt rx282_pos, 2, rx282_start
    sub rx282_off, rx282_pos, 1
    substr rx282_tgt, rx282_tgt, rx282_off
  rx282_start:
    eq $I10, 1, rx282_restart
    if_null rx282_debug, debug_654
    rx282_cur."!cursor_debug"("START", "comp_unit")
  debug_654:
    $I10 = self.'from'()
    ne $I10, -1, rxscan283_done
    goto rxscan283_scan
  rxscan283_loop:
    (rx282_pos) = rx282_cur."from"()
    inc rx282_pos
    rx282_cur."!cursor_from"(rx282_pos)
    ge rx282_pos, rx282_eos, rxscan283_done
  rxscan283_scan:
    set_addr $I10, rxscan283_loop
    rx282_cur."!mark_push"(0, rx282_pos, $I10)
  rxscan283_done:
.annotate 'line', 109
    rx282_cur."!cursor_pos"(rx282_pos)
    new $P284, "String"
    assign $P284, ""
    store_lex "$*IN_DECL", $P284
.annotate 'line', 111
    rx282_cur."!cursor_pos"(rx282_pos)
    new $P285, "Integer"
    assign $P285, 0
    store_lex "$*HAS_YOU_ARE_HERE", $P285
.annotate 'line', 112
    rx282_cur."!cursor_pos"(rx282_pos)
    find_lex $P288, "$*MAIN_SUB"
    unless_null $P288, vivify_655
    get_hll_global $P286, "GLOBAL"
    get_who $P287, $P286
    set $P288, $P287["$MAIN_SUB"]
    unless_null $P288, vivify_656
    die "Contextual $*MAIN_SUB not found"
  vivify_656:
  vivify_655:
.annotate 'line', 113
  # rx subrule "newpad" subtype=method negate=
    rx282_cur."!cursor_pos"(rx282_pos)
    $P10 = rx282_cur."newpad"()
    unless $P10, rx282_fail
    rx282_pos = $P10."pos"()
.annotate 'line', 115
    rx282_cur."!cursor_pos"(rx282_pos)
    find_lex $P291, "$*PACKAGE"
    unless_null $P291, vivify_657
    get_hll_global $P289, "GLOBAL"
    get_who $P290, $P289
    set $P291, $P290["$PACKAGE"]
    unless_null $P291, vivify_658
    die "Contextual $*PACKAGE not found"
  vivify_658:
  vivify_657:
.annotate 'line', 116
    rx282_cur."!cursor_pos"(rx282_pos)
    find_lex $P294, "$*GLOBALish"
    unless_null $P294, vivify_659
    get_hll_global $P292, "GLOBAL"
    get_who $P293, $P292
    set $P294, $P293["$GLOBALish"]
    unless_null $P294, vivify_660
    die "Contextual $*GLOBALish not found"
  vivify_660:
  vivify_659:
.annotate 'line', 117
  # rx subrule "GLOBALish" subtype=method negate=
    rx282_cur."!cursor_pos"(rx282_pos)
    $P10 = rx282_cur."GLOBALish"()
    unless $P10, rx282_fail
    rx282_pos = $P10."pos"()
.annotate 'line', 119
  # rx subrule "outerctx" subtype=method negate=
    rx282_cur."!cursor_pos"(rx282_pos)
    $P10 = rx282_cur."outerctx"()
    unless $P10, rx282_fail
    rx282_pos = $P10."pos"()
.annotate 'line', 121
  # rx subrule "statementlist" subtype=capture negate=
    rx282_cur."!cursor_pos"(rx282_pos)
    $P10 = rx282_cur."statementlist"()
    unless $P10, rx282_fail
    rx282_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx282_pos = $P10."pos"()
  alt295_0:
.annotate 'line', 122
    set_addr $I10, alt295_1
    rx282_cur."!mark_push"(0, rx282_pos, $I10)
  # rxanchor eos
    ne rx282_pos, rx282_eos, rx282_fail
    goto alt295_end
  alt295_1:
  # rx subrule "panic" subtype=method negate=
    rx282_cur."!cursor_pos"(rx282_pos)
    $P10 = rx282_cur."panic"("Confused")
    unless $P10, rx282_fail
    rx282_pos = $P10."pos"()
  alt295_end:
.annotate 'line', 108
  # rx pass
    rx282_cur."!cursor_pass"(rx282_pos, "comp_unit")
    if_null rx282_debug, debug_661
    rx282_cur."!cursor_debug"("PASS", "comp_unit", " at pos=", rx282_pos)
  debug_661:
    .return (rx282_cur)
  rx282_restart:
.annotate 'line', 10
    if_null rx282_debug, debug_662
    rx282_cur."!cursor_debug"("NEXT", "comp_unit")
  debug_662:
  rx282_fail:
    (rx282_rep, rx282_pos, $I10, $P10) = rx282_cur."!mark_fail"(0)
    lt rx282_pos, -1, rx282_done
    eq rx282_pos, -1, rx282_fail
    jump $I10
  rx282_done:
    rx282_cur."!cursor_fail"()
    if_null rx282_debug, debug_663
    rx282_cur."!cursor_debug"("FAIL", "comp_unit")
  debug_663:
    .return (rx282_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__comp_unit"  :subid("31_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P297 = self."!PREFIX__!subrule"("newpad", "")
    new $P298, "ResizablePMCArray"
    push $P298, $P297
    .return ($P298)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statementlist"  :subid("32_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx300_tgt
    .local int rx300_pos
    .local int rx300_off
    .local int rx300_eos
    .local int rx300_rep
    .local pmc rx300_cur
    .local pmc rx300_debug
    (rx300_cur, rx300_pos, rx300_tgt, $I10) = self."!cursor_start"()
    rx300_cur."!cursor_caparray"("statement")
    .lex unicode:"$\x{a2}", rx300_cur
    .local pmc match
    .lex "$/", match
    length rx300_eos, rx300_tgt
    gt rx300_pos, rx300_eos, rx300_done
    set rx300_off, 0
    lt rx300_pos, 2, rx300_start
    sub rx300_off, rx300_pos, 1
    substr rx300_tgt, rx300_tgt, rx300_off
  rx300_start:
    eq $I10, 1, rx300_restart
    if_null rx300_debug, debug_664
    rx300_cur."!cursor_debug"("START", "statementlist")
  debug_664:
    $I10 = self.'from'()
    ne $I10, -1, rxscan301_done
    goto rxscan301_scan
  rxscan301_loop:
    (rx300_pos) = rx300_cur."from"()
    inc rx300_pos
    rx300_cur."!cursor_from"(rx300_pos)
    ge rx300_pos, rx300_eos, rxscan301_done
  rxscan301_scan:
    set_addr $I10, rxscan301_loop
    rx300_cur."!mark_push"(0, rx300_pos, $I10)
  rxscan301_done:
  alt302_0:
.annotate 'line', 125
    set_addr $I10, alt302_1
    rx300_cur."!mark_push"(0, rx300_pos, $I10)
.annotate 'line', 126
  # rx subrule "ws" subtype=method negate=
    rx300_cur."!cursor_pos"(rx300_pos)
    $P10 = rx300_cur."ws"()
    unless $P10, rx300_fail
    rx300_pos = $P10."pos"()
  # rxanchor eos
    ne rx300_pos, rx300_eos, rx300_fail
  # rx subrule "ws" subtype=method negate=
    rx300_cur."!cursor_pos"(rx300_pos)
    $P10 = rx300_cur."ws"()
    unless $P10, rx300_fail
    rx300_pos = $P10."pos"()
    goto alt302_end
  alt302_1:
.annotate 'line', 127
  # rx subrule "ws" subtype=method negate=
    rx300_cur."!cursor_pos"(rx300_pos)
    $P10 = rx300_cur."ws"()
    unless $P10, rx300_fail
    rx300_pos = $P10."pos"()
  # rx rxquantr306 ** 0..*
    set_addr $I10, rxquantr306_done
    rx300_cur."!mark_push"(0, rx300_pos, $I10)
  rxquantr306_loop:
  # rx subrule "statement" subtype=capture negate=
    rx300_cur."!cursor_pos"(rx300_pos)
    $P10 = rx300_cur."statement"()
    unless $P10, rx300_fail
    rx300_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx300_pos = $P10."pos"()
  # rx subrule "eat_terminator" subtype=method negate=
    rx300_cur."!cursor_pos"(rx300_pos)
    $P10 = rx300_cur."eat_terminator"()
    unless $P10, rx300_fail
    rx300_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx300_cur."!cursor_pos"(rx300_pos)
    $P10 = rx300_cur."ws"()
    unless $P10, rx300_fail
    rx300_pos = $P10."pos"()
    set_addr $I10, rxquantr306_done
    (rx300_rep) = rx300_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr306_done
    rx300_cur."!mark_push"(rx300_rep, rx300_pos, $I10)
    goto rxquantr306_loop
  rxquantr306_done:
  # rx subrule "ws" subtype=method negate=
    rx300_cur."!cursor_pos"(rx300_pos)
    $P10 = rx300_cur."ws"()
    unless $P10, rx300_fail
    rx300_pos = $P10."pos"()
  alt302_end:
.annotate 'line', 125
  # rx pass
    rx300_cur."!cursor_pass"(rx300_pos, "statementlist")
    if_null rx300_debug, debug_665
    rx300_cur."!cursor_debug"("PASS", "statementlist", " at pos=", rx300_pos)
  debug_665:
    .return (rx300_cur)
  rx300_restart:
.annotate 'line', 10
    if_null rx300_debug, debug_666
    rx300_cur."!cursor_debug"("NEXT", "statementlist")
  debug_666:
  rx300_fail:
    (rx300_rep, rx300_pos, $I10, $P10) = rx300_cur."!mark_fail"(0)
    lt rx300_pos, -1, rx300_done
    eq rx300_pos, -1, rx300_fail
    jump $I10
  rx300_done:
    rx300_cur."!cursor_fail"()
    if_null rx300_debug, debug_667
    rx300_cur."!cursor_debug"("FAIL", "statementlist")
  debug_667:
    .return (rx300_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statementlist"  :subid("33_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P310 = self."!PREFIX__!subrule"("ws", "")
    $P311 = self."!PREFIX__!subrule"("ws", "")
    new $P312, "ResizablePMCArray"
    push $P312, $P310
    push $P312, $P311
    .return ($P312)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement"  :subid("34_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .const 'Sub' $P317 = "35_1304456155.152" 
    capture_lex $P317
    .local string rx314_tgt
    .local int rx314_pos
    .local int rx314_off
    .local int rx314_eos
    .local int rx314_rep
    .local pmc rx314_cur
    .local pmc rx314_debug
    (rx314_cur, rx314_pos, rx314_tgt, $I10) = self."!cursor_start"()
    rx314_cur."!cursor_caparray"("statement_mod_cond", "statement_mod_loop")
    .lex unicode:"$\x{a2}", rx314_cur
    .local pmc match
    .lex "$/", match
    length rx314_eos, rx314_tgt
    gt rx314_pos, rx314_eos, rx314_done
    set rx314_off, 0
    lt rx314_pos, 2, rx314_start
    sub rx314_off, rx314_pos, 1
    substr rx314_tgt, rx314_tgt, rx314_off
  rx314_start:
    eq $I10, 1, rx314_restart
    if_null rx314_debug, debug_668
    rx314_cur."!cursor_debug"("START", "statement")
  debug_668:
    $I10 = self.'from'()
    ne $I10, -1, rxscan315_done
    goto rxscan315_scan
  rxscan315_loop:
    (rx314_pos) = rx314_cur."from"()
    inc rx314_pos
    rx314_cur."!cursor_from"(rx314_pos)
    ge rx314_pos, rx314_eos, rxscan315_done
  rxscan315_scan:
    set_addr $I10, rxscan315_loop
    rx314_cur."!mark_push"(0, rx314_pos, $I10)
  rxscan315_done:
.annotate 'line', 131
  # rx subrule "before" subtype=zerowidth negate=1
    rx314_cur."!cursor_pos"(rx314_pos)
    .const 'Sub' $P317 = "35_1304456155.152" 
    capture_lex $P317
    $P10 = rx314_cur."before"($P317)
    if $P10, rx314_fail
  alt321_0:
.annotate 'line', 132
    set_addr $I10, alt321_1
    rx314_cur."!mark_push"(0, rx314_pos, $I10)
.annotate 'line', 133
  # rx subrule "statement_control" subtype=capture negate=
    rx314_cur."!cursor_pos"(rx314_pos)
    $P10 = rx314_cur."statement_control"()
    unless $P10, rx314_fail
    rx314_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_control")
    rx314_pos = $P10."pos"()
    goto alt321_end
  alt321_1:
.annotate 'line', 134
  # rx subrule "EXPR" subtype=capture negate=
    rx314_cur."!cursor_pos"(rx314_pos)
    $P10 = rx314_cur."EXPR"()
    unless $P10, rx314_fail
    rx314_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx314_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx314_cur."!cursor_pos"(rx314_pos)
    $P10 = rx314_cur."ws"()
    unless $P10, rx314_fail
    rx314_pos = $P10."pos"()
.annotate 'line', 139
  # rx rxquantr322 ** 0..1
    set_addr $I10, rxquantr322_done
    rx314_cur."!mark_push"(0, rx314_pos, $I10)
  rxquantr322_loop:
  alt323_0:
.annotate 'line', 135
    set_addr $I10, alt323_1
    rx314_cur."!mark_push"(0, rx314_pos, $I10)
.annotate 'line', 136
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx314_cur."!cursor_pos"(rx314_pos)
    $P10 = rx314_cur."MARKED"("endstmt")
    unless $P10, rx314_fail
    goto alt323_end
  alt323_1:
    set_addr $I10, alt323_2
    rx314_cur."!mark_push"(0, rx314_pos, $I10)
.annotate 'line', 137
  # rx subrule "statement_mod_cond" subtype=capture negate=
    rx314_cur."!cursor_pos"(rx314_pos)
    $P10 = rx314_cur."statement_mod_cond"()
    unless $P10, rx314_fail
    rx314_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_cond")
    rx314_pos = $P10."pos"()
  # rx rxquantr324 ** 0..1
    set_addr $I10, rxquantr324_done
    rx314_cur."!mark_push"(0, rx314_pos, $I10)
  rxquantr324_loop:
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx314_cur."!cursor_pos"(rx314_pos)
    $P10 = rx314_cur."statement_mod_loop"()
    unless $P10, rx314_fail
    goto rxsubrule325_pass
  rxsubrule325_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx314_fail
  rxsubrule325_pass:
    set_addr $I10, rxsubrule325_back
    rx314_cur."!mark_push"(0, rx314_pos, $I10, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx314_pos = $P10."pos"()
    set_addr $I10, rxquantr324_done
    (rx314_rep) = rx314_cur."!mark_commit"($I10)
  rxquantr324_done:
    goto alt323_end
  alt323_2:
.annotate 'line', 138
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx314_cur."!cursor_pos"(rx314_pos)
    $P10 = rx314_cur."statement_mod_loop"()
    unless $P10, rx314_fail
    rx314_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx314_pos = $P10."pos"()
  alt323_end:
.annotate 'line', 139
    set_addr $I10, rxquantr322_done
    (rx314_rep) = rx314_cur."!mark_commit"($I10)
  rxquantr322_done:
  alt321_end:
.annotate 'line', 130
  # rx pass
    rx314_cur."!cursor_pass"(rx314_pos, "statement")
    if_null rx314_debug, debug_673
    rx314_cur."!cursor_debug"("PASS", "statement", " at pos=", rx314_pos)
  debug_673:
    .return (rx314_cur)
  rx314_restart:
.annotate 'line', 10
    if_null rx314_debug, debug_674
    rx314_cur."!cursor_debug"("NEXT", "statement")
  debug_674:
  rx314_fail:
    (rx314_rep, rx314_pos, $I10, $P10) = rx314_cur."!mark_fail"(0)
    lt rx314_pos, -1, rx314_done
    eq rx314_pos, -1, rx314_fail
    jump $I10
  rx314_done:
    rx314_cur."!cursor_fail"()
    if_null rx314_debug, debug_675
    rx314_cur."!cursor_debug"("FAIL", "statement")
  debug_675:
    .return (rx314_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block316"  :anon :subid("35_1304456155.152") :method :outer("34_1304456155.152")
.annotate 'line', 131
    .local string rx318_tgt
    .local int rx318_pos
    .local int rx318_off
    .local int rx318_eos
    .local int rx318_rep
    .local pmc rx318_cur
    .local pmc rx318_debug
    (rx318_cur, rx318_pos, rx318_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx318_cur
    .local pmc match
    .lex "$/", match
    length rx318_eos, rx318_tgt
    gt rx318_pos, rx318_eos, rx318_done
    set rx318_off, 0
    lt rx318_pos, 2, rx318_start
    sub rx318_off, rx318_pos, 1
    substr rx318_tgt, rx318_tgt, rx318_off
  rx318_start:
    eq $I10, 1, rx318_restart
    if_null rx318_debug, debug_669
    rx318_cur."!cursor_debug"("START", "")
  debug_669:
    $I10 = self.'from'()
    ne $I10, -1, rxscan319_done
    goto rxscan319_scan
  rxscan319_loop:
    (rx318_pos) = rx318_cur."from"()
    inc rx318_pos
    rx318_cur."!cursor_from"(rx318_pos)
    ge rx318_pos, rx318_eos, rxscan319_done
  rxscan319_scan:
    set_addr $I10, rxscan319_loop
    rx318_cur."!mark_push"(0, rx318_pos, $I10)
  rxscan319_done:
  alt320_0:
    set_addr $I10, alt320_1
    rx318_cur."!mark_push"(0, rx318_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx318_pos, rx318_eos, rx318_fail
    sub $I10, rx318_pos, rx318_off
    substr $S10, rx318_tgt, $I10, 1
    index $I11, "])}", $S10
    lt $I11, 0, rx318_fail
    inc rx318_pos
    goto alt320_end
  alt320_1:
  # rxanchor eos
    ne rx318_pos, rx318_eos, rx318_fail
  alt320_end:
  # rx pass
    rx318_cur."!cursor_pass"(rx318_pos, "")
    if_null rx318_debug, debug_670
    rx318_cur."!cursor_debug"("PASS", "", " at pos=", rx318_pos)
  debug_670:
    .return (rx318_cur)
  rx318_restart:
    if_null rx318_debug, debug_671
    rx318_cur."!cursor_debug"("NEXT", "")
  debug_671:
  rx318_fail:
    (rx318_rep, rx318_pos, $I10, $P10) = rx318_cur."!mark_fail"(0)
    lt rx318_pos, -1, rx318_done
    eq rx318_pos, -1, rx318_fail
    jump $I10
  rx318_done:
    rx318_cur."!cursor_fail"()
    if_null rx318_debug, debug_672
    rx318_cur."!cursor_debug"("FAIL", "")
  debug_672:
    .return (rx318_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement"  :subid("36_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    new $P327, "ResizablePMCArray"
    push $P327, ""
    .return ($P327)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "eat_terminator"  :subid("37_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx329_tgt
    .local int rx329_pos
    .local int rx329_off
    .local int rx329_eos
    .local int rx329_rep
    .local pmc rx329_cur
    .local pmc rx329_debug
    (rx329_cur, rx329_pos, rx329_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx329_cur
    .local pmc match
    .lex "$/", match
    length rx329_eos, rx329_tgt
    gt rx329_pos, rx329_eos, rx329_done
    set rx329_off, 0
    lt rx329_pos, 2, rx329_start
    sub rx329_off, rx329_pos, 1
    substr rx329_tgt, rx329_tgt, rx329_off
  rx329_start:
    eq $I10, 1, rx329_restart
    if_null rx329_debug, debug_676
    rx329_cur."!cursor_debug"("START", "eat_terminator")
  debug_676:
    $I10 = self.'from'()
    ne $I10, -1, rxscan330_done
    goto rxscan330_scan
  rxscan330_loop:
    (rx329_pos) = rx329_cur."from"()
    inc rx329_pos
    rx329_cur."!cursor_from"(rx329_pos)
    ge rx329_pos, rx329_eos, rxscan330_done
  rxscan330_scan:
    set_addr $I10, rxscan330_loop
    rx329_cur."!mark_push"(0, rx329_pos, $I10)
  rxscan330_done:
  alt331_0:
.annotate 'line', 143
    set_addr $I10, alt331_1
    rx329_cur."!mark_push"(0, rx329_pos, $I10)
.annotate 'line', 144
  # rx literal  ";"
    add $I11, rx329_pos, 1
    gt $I11, rx329_eos, rx329_fail
    sub $I11, rx329_pos, rx329_off
    ord $I11, rx329_tgt, $I11
    ne $I11, 59, rx329_fail
    add rx329_pos, 1
    goto alt331_end
  alt331_1:
    set_addr $I10, alt331_2
    rx329_cur."!mark_push"(0, rx329_pos, $I10)
.annotate 'line', 145
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx329_cur."!cursor_pos"(rx329_pos)
    $P10 = rx329_cur."MARKED"("endstmt")
    unless $P10, rx329_fail
    goto alt331_end
  alt331_2:
    set_addr $I10, alt331_3
    rx329_cur."!mark_push"(0, rx329_pos, $I10)
.annotate 'line', 146
  # rx subrule "terminator" subtype=zerowidth negate=
    rx329_cur."!cursor_pos"(rx329_pos)
    $P10 = rx329_cur."terminator"()
    unless $P10, rx329_fail
    goto alt331_end
  alt331_3:
.annotate 'line', 147
  # rxanchor eos
    ne rx329_pos, rx329_eos, rx329_fail
  alt331_end:
.annotate 'line', 143
  # rx pass
    rx329_cur."!cursor_pass"(rx329_pos, "eat_terminator")
    if_null rx329_debug, debug_677
    rx329_cur."!cursor_debug"("PASS", "eat_terminator", " at pos=", rx329_pos)
  debug_677:
    .return (rx329_cur)
  rx329_restart:
.annotate 'line', 10
    if_null rx329_debug, debug_678
    rx329_cur."!cursor_debug"("NEXT", "eat_terminator")
  debug_678:
  rx329_fail:
    (rx329_rep, rx329_pos, $I10, $P10) = rx329_cur."!mark_fail"(0)
    lt rx329_pos, -1, rx329_done
    eq rx329_pos, -1, rx329_fail
    jump $I10
  rx329_done:
    rx329_cur."!cursor_fail"()
    if_null rx329_debug, debug_679
    rx329_cur."!cursor_debug"("FAIL", "eat_terminator")
  debug_679:
    .return (rx329_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__eat_terminator"  :subid("38_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    new $P333, "ResizablePMCArray"
    push $P333, ""
    push $P333, ""
    push $P333, ""
    push $P333, ";"
    .return ($P333)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "xblock"  :subid("39_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx335_tgt
    .local int rx335_pos
    .local int rx335_off
    .local int rx335_eos
    .local int rx335_rep
    .local pmc rx335_cur
    .local pmc rx335_debug
    (rx335_cur, rx335_pos, rx335_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx335_cur
    .local pmc match
    .lex "$/", match
    length rx335_eos, rx335_tgt
    gt rx335_pos, rx335_eos, rx335_done
    set rx335_off, 0
    lt rx335_pos, 2, rx335_start
    sub rx335_off, rx335_pos, 1
    substr rx335_tgt, rx335_tgt, rx335_off
  rx335_start:
    eq $I10, 1, rx335_restart
    if_null rx335_debug, debug_680
    rx335_cur."!cursor_debug"("START", "xblock")
  debug_680:
    $I10 = self.'from'()
    ne $I10, -1, rxscan336_done
    goto rxscan336_scan
  rxscan336_loop:
    (rx335_pos) = rx335_cur."from"()
    inc rx335_pos
    rx335_cur."!cursor_from"(rx335_pos)
    ge rx335_pos, rx335_eos, rxscan336_done
  rxscan336_scan:
    set_addr $I10, rxscan336_loop
    rx335_cur."!mark_push"(0, rx335_pos, $I10)
  rxscan336_done:
.annotate 'line', 151
  # rx subrule "EXPR" subtype=capture negate=
    rx335_cur."!cursor_pos"(rx335_pos)
    $P10 = rx335_cur."EXPR"()
    unless $P10, rx335_fail
    rx335_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx335_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx335_cur."!cursor_pos"(rx335_pos)
    $P10 = rx335_cur."ws"()
    unless $P10, rx335_fail
    rx335_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx335_cur."!cursor_pos"(rx335_pos)
    $P10 = rx335_cur."pblock"()
    unless $P10, rx335_fail
    rx335_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx335_pos = $P10."pos"()
.annotate 'line', 150
  # rx pass
    rx335_cur."!cursor_pass"(rx335_pos, "xblock")
    if_null rx335_debug, debug_681
    rx335_cur."!cursor_debug"("PASS", "xblock", " at pos=", rx335_pos)
  debug_681:
    .return (rx335_cur)
  rx335_restart:
.annotate 'line', 10
    if_null rx335_debug, debug_682
    rx335_cur."!cursor_debug"("NEXT", "xblock")
  debug_682:
  rx335_fail:
    (rx335_rep, rx335_pos, $I10, $P10) = rx335_cur."!mark_fail"(0)
    lt rx335_pos, -1, rx335_done
    eq rx335_pos, -1, rx335_fail
    jump $I10
  rx335_done:
    rx335_cur."!cursor_fail"()
    if_null rx335_debug, debug_683
    rx335_cur."!cursor_debug"("FAIL", "xblock")
  debug_683:
    .return (rx335_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__xblock"  :subid("40_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P338 = self."!PREFIX__!subrule"("EXPR", "")
    new $P339, "ResizablePMCArray"
    push $P339, $P338
    .return ($P339)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pblock"  :subid("41_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx341_tgt
    .local int rx341_pos
    .local int rx341_off
    .local int rx341_eos
    .local int rx341_rep
    .local pmc rx341_cur
    .local pmc rx341_debug
    (rx341_cur, rx341_pos, rx341_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx341_cur
    .local pmc match
    .lex "$/", match
    length rx341_eos, rx341_tgt
    gt rx341_pos, rx341_eos, rx341_done
    set rx341_off, 0
    lt rx341_pos, 2, rx341_start
    sub rx341_off, rx341_pos, 1
    substr rx341_tgt, rx341_tgt, rx341_off
  rx341_start:
    eq $I10, 1, rx341_restart
    if_null rx341_debug, debug_684
    rx341_cur."!cursor_debug"("START", "pblock")
  debug_684:
    $I10 = self.'from'()
    ne $I10, -1, rxscan342_done
    goto rxscan342_scan
  rxscan342_loop:
    (rx341_pos) = rx341_cur."from"()
    inc rx341_pos
    rx341_cur."!cursor_from"(rx341_pos)
    ge rx341_pos, rx341_eos, rxscan342_done
  rxscan342_scan:
    set_addr $I10, rxscan342_loop
    rx341_cur."!mark_push"(0, rx341_pos, $I10)
  rxscan342_done:
  alt343_0:
.annotate 'line', 154
    set_addr $I10, alt343_1
    rx341_cur."!mark_push"(0, rx341_pos, $I10)
.annotate 'line', 155
  # rx subrule "lambda" subtype=method negate=
    rx341_cur."!cursor_pos"(rx341_pos)
    $P10 = rx341_cur."lambda"()
    unless $P10, rx341_fail
    rx341_pos = $P10."pos"()
.annotate 'line', 156
  # rx subrule "newpad" subtype=method negate=
    rx341_cur."!cursor_pos"(rx341_pos)
    $P10 = rx341_cur."newpad"()
    unless $P10, rx341_fail
    rx341_pos = $P10."pos"()
.annotate 'line', 157
  # rx subrule "signature" subtype=capture negate=
    rx341_cur."!cursor_pos"(rx341_pos)
    $P10 = rx341_cur."signature"()
    unless $P10, rx341_fail
    rx341_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx341_pos = $P10."pos"()
.annotate 'line', 158
  # rx subrule "blockoid" subtype=capture negate=
    rx341_cur."!cursor_pos"(rx341_pos)
    $P10 = rx341_cur."blockoid"()
    unless $P10, rx341_fail
    rx341_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx341_pos = $P10."pos"()
.annotate 'line', 155
    goto alt343_end
  alt343_1:
    set_addr $I10, alt343_2
    rx341_cur."!mark_push"(0, rx341_pos, $I10)
.annotate 'line', 159
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx341_pos, rx341_off
    substr $S10, rx341_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx341_fail
.annotate 'line', 160
  # rx subrule "newpad" subtype=method negate=
    rx341_cur."!cursor_pos"(rx341_pos)
    $P10 = rx341_cur."newpad"()
    unless $P10, rx341_fail
    rx341_pos = $P10."pos"()
.annotate 'line', 161
  # rx subrule "blockoid" subtype=capture negate=
    rx341_cur."!cursor_pos"(rx341_pos)
    $P10 = rx341_cur."blockoid"()
    unless $P10, rx341_fail
    rx341_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx341_pos = $P10."pos"()
.annotate 'line', 159
    goto alt343_end
  alt343_2:
.annotate 'line', 162
  # rx subrule "panic" subtype=method negate=
    rx341_cur."!cursor_pos"(rx341_pos)
    $P10 = rx341_cur."panic"("Missing block")
    unless $P10, rx341_fail
    rx341_pos = $P10."pos"()
  alt343_end:
.annotate 'line', 154
  # rx pass
    rx341_cur."!cursor_pass"(rx341_pos, "pblock")
    if_null rx341_debug, debug_685
    rx341_cur."!cursor_debug"("PASS", "pblock", " at pos=", rx341_pos)
  debug_685:
    .return (rx341_cur)
  rx341_restart:
.annotate 'line', 10
    if_null rx341_debug, debug_686
    rx341_cur."!cursor_debug"("NEXT", "pblock")
  debug_686:
  rx341_fail:
    (rx341_rep, rx341_pos, $I10, $P10) = rx341_cur."!mark_fail"(0)
    lt rx341_pos, -1, rx341_done
    eq rx341_pos, -1, rx341_fail
    jump $I10
  rx341_done:
    rx341_cur."!cursor_fail"()
    if_null rx341_debug, debug_687
    rx341_cur."!cursor_debug"("FAIL", "pblock")
  debug_687:
    .return (rx341_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pblock"  :subid("42_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P345 = self."!PREFIX__!subrule"("panic", "")
    $P346 = self."!PREFIX__!subrule"("lambda", "")
    new $P347, "ResizablePMCArray"
    push $P347, $P345
    push $P347, "{"
    push $P347, $P346
    .return ($P347)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "lambda"  :subid("43_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx349_tgt
    .local int rx349_pos
    .local int rx349_off
    .local int rx349_eos
    .local int rx349_rep
    .local pmc rx349_cur
    .local pmc rx349_debug
    (rx349_cur, rx349_pos, rx349_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx349_cur
    .local pmc match
    .lex "$/", match
    length rx349_eos, rx349_tgt
    gt rx349_pos, rx349_eos, rx349_done
    set rx349_off, 0
    lt rx349_pos, 2, rx349_start
    sub rx349_off, rx349_pos, 1
    substr rx349_tgt, rx349_tgt, rx349_off
  rx349_start:
    eq $I10, 1, rx349_restart
    if_null rx349_debug, debug_688
    rx349_cur."!cursor_debug"("START", "lambda")
  debug_688:
    $I10 = self.'from'()
    ne $I10, -1, rxscan350_done
    goto rxscan350_scan
  rxscan350_loop:
    (rx349_pos) = rx349_cur."from"()
    inc rx349_pos
    rx349_cur."!cursor_from"(rx349_pos)
    ge rx349_pos, rx349_eos, rxscan350_done
  rxscan350_scan:
    set_addr $I10, rxscan350_loop
    rx349_cur."!mark_push"(0, rx349_pos, $I10)
  rxscan350_done:
  alt351_0:
.annotate 'line', 165
    set_addr $I10, alt351_1
    rx349_cur."!mark_push"(0, rx349_pos, $I10)
  # rx literal  "->"
    add $I11, rx349_pos, 2
    gt $I11, rx349_eos, rx349_fail
    sub $I11, rx349_pos, rx349_off
    substr $S10, rx349_tgt, $I11, 2
    ne $S10, "->", rx349_fail
    add rx349_pos, 2
    goto alt351_end
  alt351_1:
  # rx literal  "<->"
    add $I11, rx349_pos, 3
    gt $I11, rx349_eos, rx349_fail
    sub $I11, rx349_pos, rx349_off
    substr $S10, rx349_tgt, $I11, 3
    ne $S10, "<->", rx349_fail
    add rx349_pos, 3
  alt351_end:
  # rx pass
    rx349_cur."!cursor_pass"(rx349_pos, "lambda")
    if_null rx349_debug, debug_689
    rx349_cur."!cursor_debug"("PASS", "lambda", " at pos=", rx349_pos)
  debug_689:
    .return (rx349_cur)
  rx349_restart:
.annotate 'line', 10
    if_null rx349_debug, debug_690
    rx349_cur."!cursor_debug"("NEXT", "lambda")
  debug_690:
  rx349_fail:
    (rx349_rep, rx349_pos, $I10, $P10) = rx349_cur."!mark_fail"(0)
    lt rx349_pos, -1, rx349_done
    eq rx349_pos, -1, rx349_fail
    jump $I10
  rx349_done:
    rx349_cur."!cursor_fail"()
    if_null rx349_debug, debug_691
    rx349_cur."!cursor_debug"("FAIL", "lambda")
  debug_691:
    .return (rx349_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__lambda"  :subid("44_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    new $P353, "ResizablePMCArray"
    push $P353, "<->"
    push $P353, "->"
    .return ($P353)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "block"  :subid("45_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx355_tgt
    .local int rx355_pos
    .local int rx355_off
    .local int rx355_eos
    .local int rx355_rep
    .local pmc rx355_cur
    .local pmc rx355_debug
    (rx355_cur, rx355_pos, rx355_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx355_cur
    .local pmc match
    .lex "$/", match
    length rx355_eos, rx355_tgt
    gt rx355_pos, rx355_eos, rx355_done
    set rx355_off, 0
    lt rx355_pos, 2, rx355_start
    sub rx355_off, rx355_pos, 1
    substr rx355_tgt, rx355_tgt, rx355_off
  rx355_start:
    eq $I10, 1, rx355_restart
    if_null rx355_debug, debug_692
    rx355_cur."!cursor_debug"("START", "block")
  debug_692:
    $I10 = self.'from'()
    ne $I10, -1, rxscan356_done
    goto rxscan356_scan
  rxscan356_loop:
    (rx355_pos) = rx355_cur."from"()
    inc rx355_pos
    rx355_cur."!cursor_from"(rx355_pos)
    ge rx355_pos, rx355_eos, rxscan356_done
  rxscan356_scan:
    set_addr $I10, rxscan356_loop
    rx355_cur."!mark_push"(0, rx355_pos, $I10)
  rxscan356_done:
  alt357_0:
.annotate 'line', 168
    set_addr $I10, alt357_1
    rx355_cur."!mark_push"(0, rx355_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx355_pos, rx355_off
    substr $S10, rx355_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx355_fail
    goto alt357_end
  alt357_1:
  # rx subrule "panic" subtype=method negate=
    rx355_cur."!cursor_pos"(rx355_pos)
    $P10 = rx355_cur."panic"("Missing block")
    unless $P10, rx355_fail
    rx355_pos = $P10."pos"()
  alt357_end:
.annotate 'line', 169
  # rx subrule "newpad" subtype=method negate=
    rx355_cur."!cursor_pos"(rx355_pos)
    $P10 = rx355_cur."newpad"()
    unless $P10, rx355_fail
    rx355_pos = $P10."pos"()
.annotate 'line', 170
  # rx subrule "blockoid" subtype=capture negate=
    rx355_cur."!cursor_pos"(rx355_pos)
    $P10 = rx355_cur."blockoid"()
    unless $P10, rx355_fail
    rx355_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx355_pos = $P10."pos"()
.annotate 'line', 167
  # rx pass
    rx355_cur."!cursor_pass"(rx355_pos, "block")
    if_null rx355_debug, debug_693
    rx355_cur."!cursor_debug"("PASS", "block", " at pos=", rx355_pos)
  debug_693:
    .return (rx355_cur)
  rx355_restart:
.annotate 'line', 10
    if_null rx355_debug, debug_694
    rx355_cur."!cursor_debug"("NEXT", "block")
  debug_694:
  rx355_fail:
    (rx355_rep, rx355_pos, $I10, $P10) = rx355_cur."!mark_fail"(0)
    lt rx355_pos, -1, rx355_done
    eq rx355_pos, -1, rx355_fail
    jump $I10
  rx355_done:
    rx355_cur."!cursor_fail"()
    if_null rx355_debug, debug_695
    rx355_cur."!cursor_debug"("FAIL", "block")
  debug_695:
    .return (rx355_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__block"  :subid("46_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P359 = self."!PREFIX__!subrule"("panic", "")
    new $P360, "ResizablePMCArray"
    push $P360, $P359
    push $P360, "{"
    .return ($P360)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blockoid"  :subid("47_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx362_tgt
    .local int rx362_pos
    .local int rx362_off
    .local int rx362_eos
    .local int rx362_rep
    .local pmc rx362_cur
    .local pmc rx362_debug
    (rx362_cur, rx362_pos, rx362_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx362_cur
    .local pmc match
    .lex "$/", match
    length rx362_eos, rx362_tgt
    gt rx362_pos, rx362_eos, rx362_done
    set rx362_off, 0
    lt rx362_pos, 2, rx362_start
    sub rx362_off, rx362_pos, 1
    substr rx362_tgt, rx362_tgt, rx362_off
  rx362_start:
    eq $I10, 1, rx362_restart
    if_null rx362_debug, debug_696
    rx362_cur."!cursor_debug"("START", "blockoid")
  debug_696:
    $I10 = self.'from'()
    ne $I10, -1, rxscan363_done
    goto rxscan363_scan
  rxscan363_loop:
    (rx362_pos) = rx362_cur."from"()
    inc rx362_pos
    rx362_cur."!cursor_from"(rx362_pos)
    ge rx362_pos, rx362_eos, rxscan363_done
  rxscan363_scan:
    set_addr $I10, rxscan363_loop
    rx362_cur."!mark_push"(0, rx362_pos, $I10)
  rxscan363_done:
.annotate 'line', 174
  # rx subrule "finishpad" subtype=method negate=
    rx362_cur."!cursor_pos"(rx362_pos)
    $P10 = rx362_cur."finishpad"()
    unless $P10, rx362_fail
    rx362_pos = $P10."pos"()
  alt364_0:
.annotate 'line', 175
    set_addr $I10, alt364_1
    rx362_cur."!mark_push"(0, rx362_pos, $I10)
.annotate 'line', 176
  # rx literal  "{YOU_ARE_HERE}"
    add $I11, rx362_pos, 14
    gt $I11, rx362_eos, rx362_fail
    sub $I11, rx362_pos, rx362_off
    substr $S10, rx362_tgt, $I11, 14
    ne $S10, "{YOU_ARE_HERE}", rx362_fail
    add rx362_pos, 14
  # rx subrule "you_are_here" subtype=capture negate=
    rx362_cur."!cursor_pos"(rx362_pos)
    $P10 = rx362_cur."you_are_here"()
    unless $P10, rx362_fail
    rx362_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("you_are_here")
    rx362_pos = $P10."pos"()
    goto alt364_end
  alt364_1:
.annotate 'line', 177
  # rx literal  "{"
    add $I11, rx362_pos, 1
    gt $I11, rx362_eos, rx362_fail
    sub $I11, rx362_pos, rx362_off
    ord $I11, rx362_tgt, $I11
    ne $I11, 123, rx362_fail
    add rx362_pos, 1
  # rx subrule "statementlist" subtype=capture negate=
    rx362_cur."!cursor_pos"(rx362_pos)
    $P10 = rx362_cur."statementlist"()
    unless $P10, rx362_fail
    rx362_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx362_pos = $P10."pos"()
  alt365_0:
    set_addr $I10, alt365_1
    rx362_cur."!mark_push"(0, rx362_pos, $I10)
  # rx literal  "}"
    add $I11, rx362_pos, 1
    gt $I11, rx362_eos, rx362_fail
    sub $I11, rx362_pos, rx362_off
    ord $I11, rx362_tgt, $I11
    ne $I11, 125, rx362_fail
    add rx362_pos, 1
    goto alt365_end
  alt365_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx362_cur."!cursor_pos"(rx362_pos)
    $P10 = rx362_cur."FAILGOAL"("'}'")
    unless $P10, rx362_fail
    goto rxsubrule367_pass
  rxsubrule367_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx362_fail
  rxsubrule367_pass:
    set_addr $I10, rxsubrule367_back
    rx362_cur."!mark_push"(0, rx362_pos, $I10, $P10)
    rx362_pos = $P10."pos"()
  alt365_end:
  alt364_end:
.annotate 'line', 179
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx362_cur."!cursor_pos"(rx362_pos)
    $P10 = rx362_cur."ENDSTMT"()
    unless $P10, rx362_fail
.annotate 'line', 173
  # rx pass
    rx362_cur."!cursor_pass"(rx362_pos, "blockoid")
    if_null rx362_debug, debug_697
    rx362_cur."!cursor_debug"("PASS", "blockoid", " at pos=", rx362_pos)
  debug_697:
    .return (rx362_cur)
  rx362_restart:
.annotate 'line', 10
    if_null rx362_debug, debug_698
    rx362_cur."!cursor_debug"("NEXT", "blockoid")
  debug_698:
  rx362_fail:
    (rx362_rep, rx362_pos, $I10, $P10) = rx362_cur."!mark_fail"(0)
    lt rx362_pos, -1, rx362_done
    eq rx362_pos, -1, rx362_fail
    jump $I10
  rx362_done:
    rx362_cur."!cursor_fail"()
    if_null rx362_debug, debug_699
    rx362_cur."!cursor_debug"("FAIL", "blockoid")
  debug_699:
    .return (rx362_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blockoid"  :subid("48_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P369 = self."!PREFIX__!subrule"("finishpad", "")
    new $P370, "ResizablePMCArray"
    push $P370, $P369
    .return ($P370)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "newpad"  :subid("49_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx372_tgt
    .local int rx372_pos
    .local int rx372_off
    .local int rx372_eos
    .local int rx372_rep
    .local pmc rx372_cur
    .local pmc rx372_debug
    (rx372_cur, rx372_pos, rx372_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx372_cur
    .local pmc match
    .lex "$/", match
    length rx372_eos, rx372_tgt
    gt rx372_pos, rx372_eos, rx372_done
    set rx372_off, 0
    lt rx372_pos, 2, rx372_start
    sub rx372_off, rx372_pos, 1
    substr rx372_tgt, rx372_tgt, rx372_off
  rx372_start:
    eq $I10, 1, rx372_restart
    if_null rx372_debug, debug_700
    rx372_cur."!cursor_debug"("START", "newpad")
  debug_700:
    $I10 = self.'from'()
    ne $I10, -1, rxscan373_done
    goto rxscan373_scan
  rxscan373_loop:
    (rx372_pos) = rx372_cur."from"()
    inc rx372_pos
    rx372_cur."!cursor_from"(rx372_pos)
    ge rx372_pos, rx372_eos, rxscan373_done
  rxscan373_scan:
    set_addr $I10, rxscan373_loop
    rx372_cur."!mark_push"(0, rx372_pos, $I10)
  rxscan373_done:
.annotate 'line', 182
  # rx pass
    rx372_cur."!cursor_pass"(rx372_pos, "newpad")
    if_null rx372_debug, debug_701
    rx372_cur."!cursor_debug"("PASS", "newpad", " at pos=", rx372_pos)
  debug_701:
    .return (rx372_cur)
  rx372_restart:
.annotate 'line', 10
    if_null rx372_debug, debug_702
    rx372_cur."!cursor_debug"("NEXT", "newpad")
  debug_702:
  rx372_fail:
    (rx372_rep, rx372_pos, $I10, $P10) = rx372_cur."!mark_fail"(0)
    lt rx372_pos, -1, rx372_done
    eq rx372_pos, -1, rx372_fail
    jump $I10
  rx372_done:
    rx372_cur."!cursor_fail"()
    if_null rx372_debug, debug_703
    rx372_cur."!cursor_debug"("FAIL", "newpad")
  debug_703:
    .return (rx372_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__newpad"  :subid("50_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    new $P375, "ResizablePMCArray"
    push $P375, ""
    .return ($P375)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "outerctx"  :subid("51_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx377_tgt
    .local int rx377_pos
    .local int rx377_off
    .local int rx377_eos
    .local int rx377_rep
    .local pmc rx377_cur
    .local pmc rx377_debug
    (rx377_cur, rx377_pos, rx377_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx377_cur
    .local pmc match
    .lex "$/", match
    length rx377_eos, rx377_tgt
    gt rx377_pos, rx377_eos, rx377_done
    set rx377_off, 0
    lt rx377_pos, 2, rx377_start
    sub rx377_off, rx377_pos, 1
    substr rx377_tgt, rx377_tgt, rx377_off
  rx377_start:
    eq $I10, 1, rx377_restart
    if_null rx377_debug, debug_704
    rx377_cur."!cursor_debug"("START", "outerctx")
  debug_704:
    $I10 = self.'from'()
    ne $I10, -1, rxscan378_done
    goto rxscan378_scan
  rxscan378_loop:
    (rx377_pos) = rx377_cur."from"()
    inc rx377_pos
    rx377_cur."!cursor_from"(rx377_pos)
    ge rx377_pos, rx377_eos, rxscan378_done
  rxscan378_scan:
    set_addr $I10, rxscan378_loop
    rx377_cur."!mark_push"(0, rx377_pos, $I10)
  rxscan378_done:
.annotate 'line', 183
  # rx pass
    rx377_cur."!cursor_pass"(rx377_pos, "outerctx")
    if_null rx377_debug, debug_705
    rx377_cur."!cursor_debug"("PASS", "outerctx", " at pos=", rx377_pos)
  debug_705:
    .return (rx377_cur)
  rx377_restart:
.annotate 'line', 10
    if_null rx377_debug, debug_706
    rx377_cur."!cursor_debug"("NEXT", "outerctx")
  debug_706:
  rx377_fail:
    (rx377_rep, rx377_pos, $I10, $P10) = rx377_cur."!mark_fail"(0)
    lt rx377_pos, -1, rx377_done
    eq rx377_pos, -1, rx377_fail
    jump $I10
  rx377_done:
    rx377_cur."!cursor_fail"()
    if_null rx377_debug, debug_707
    rx377_cur."!cursor_debug"("FAIL", "outerctx")
  debug_707:
    .return (rx377_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__outerctx"  :subid("52_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    new $P380, "ResizablePMCArray"
    push $P380, ""
    .return ($P380)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "GLOBALish"  :subid("53_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx382_tgt
    .local int rx382_pos
    .local int rx382_off
    .local int rx382_eos
    .local int rx382_rep
    .local pmc rx382_cur
    .local pmc rx382_debug
    (rx382_cur, rx382_pos, rx382_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx382_cur
    .local pmc match
    .lex "$/", match
    length rx382_eos, rx382_tgt
    gt rx382_pos, rx382_eos, rx382_done
    set rx382_off, 0
    lt rx382_pos, 2, rx382_start
    sub rx382_off, rx382_pos, 1
    substr rx382_tgt, rx382_tgt, rx382_off
  rx382_start:
    eq $I10, 1, rx382_restart
    if_null rx382_debug, debug_708
    rx382_cur."!cursor_debug"("START", "GLOBALish")
  debug_708:
    $I10 = self.'from'()
    ne $I10, -1, rxscan383_done
    goto rxscan383_scan
  rxscan383_loop:
    (rx382_pos) = rx382_cur."from"()
    inc rx382_pos
    rx382_cur."!cursor_from"(rx382_pos)
    ge rx382_pos, rx382_eos, rxscan383_done
  rxscan383_scan:
    set_addr $I10, rxscan383_loop
    rx382_cur."!mark_push"(0, rx382_pos, $I10)
  rxscan383_done:
.annotate 'line', 184
  # rx pass
    rx382_cur."!cursor_pass"(rx382_pos, "GLOBALish")
    if_null rx382_debug, debug_709
    rx382_cur."!cursor_debug"("PASS", "GLOBALish", " at pos=", rx382_pos)
  debug_709:
    .return (rx382_cur)
  rx382_restart:
.annotate 'line', 10
    if_null rx382_debug, debug_710
    rx382_cur."!cursor_debug"("NEXT", "GLOBALish")
  debug_710:
  rx382_fail:
    (rx382_rep, rx382_pos, $I10, $P10) = rx382_cur."!mark_fail"(0)
    lt rx382_pos, -1, rx382_done
    eq rx382_pos, -1, rx382_fail
    jump $I10
  rx382_done:
    rx382_cur."!cursor_fail"()
    if_null rx382_debug, debug_711
    rx382_cur."!cursor_debug"("FAIL", "GLOBALish")
  debug_711:
    .return (rx382_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__GLOBALish"  :subid("54_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    new $P385, "ResizablePMCArray"
    push $P385, ""
    .return ($P385)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "finishpad"  :subid("55_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx387_tgt
    .local int rx387_pos
    .local int rx387_off
    .local int rx387_eos
    .local int rx387_rep
    .local pmc rx387_cur
    .local pmc rx387_debug
    (rx387_cur, rx387_pos, rx387_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx387_cur
    .local pmc match
    .lex "$/", match
    length rx387_eos, rx387_tgt
    gt rx387_pos, rx387_eos, rx387_done
    set rx387_off, 0
    lt rx387_pos, 2, rx387_start
    sub rx387_off, rx387_pos, 1
    substr rx387_tgt, rx387_tgt, rx387_off
  rx387_start:
    eq $I10, 1, rx387_restart
    if_null rx387_debug, debug_712
    rx387_cur."!cursor_debug"("START", "finishpad")
  debug_712:
    $I10 = self.'from'()
    ne $I10, -1, rxscan388_done
    goto rxscan388_scan
  rxscan388_loop:
    (rx387_pos) = rx387_cur."from"()
    inc rx387_pos
    rx387_cur."!cursor_from"(rx387_pos)
    ge rx387_pos, rx387_eos, rxscan388_done
  rxscan388_scan:
    set_addr $I10, rxscan388_loop
    rx387_cur."!mark_push"(0, rx387_pos, $I10)
  rxscan388_done:
.annotate 'line', 185
  # rx pass
    rx387_cur."!cursor_pass"(rx387_pos, "finishpad")
    if_null rx387_debug, debug_713
    rx387_cur."!cursor_debug"("PASS", "finishpad", " at pos=", rx387_pos)
  debug_713:
    .return (rx387_cur)
  rx387_restart:
.annotate 'line', 10
    if_null rx387_debug, debug_714
    rx387_cur."!cursor_debug"("NEXT", "finishpad")
  debug_714:
  rx387_fail:
    (rx387_rep, rx387_pos, $I10, $P10) = rx387_cur."!mark_fail"(0)
    lt rx387_pos, -1, rx387_done
    eq rx387_pos, -1, rx387_fail
    jump $I10
  rx387_done:
    rx387_cur."!cursor_fail"()
    if_null rx387_debug, debug_715
    rx387_cur."!cursor_debug"("FAIL", "finishpad")
  debug_715:
    .return (rx387_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__finishpad"  :subid("56_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    new $P390, "ResizablePMCArray"
    push $P390, ""
    .return ($P390)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "you_are_here"  :subid("57_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx392_tgt
    .local int rx392_pos
    .local int rx392_off
    .local int rx392_eos
    .local int rx392_rep
    .local pmc rx392_cur
    .local pmc rx392_debug
    (rx392_cur, rx392_pos, rx392_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx392_cur
    .local pmc match
    .lex "$/", match
    length rx392_eos, rx392_tgt
    gt rx392_pos, rx392_eos, rx392_done
    set rx392_off, 0
    lt rx392_pos, 2, rx392_start
    sub rx392_off, rx392_pos, 1
    substr rx392_tgt, rx392_tgt, rx392_off
  rx392_start:
    eq $I10, 1, rx392_restart
    if_null rx392_debug, debug_716
    rx392_cur."!cursor_debug"("START", "you_are_here")
  debug_716:
    $I10 = self.'from'()
    ne $I10, -1, rxscan393_done
    goto rxscan393_scan
  rxscan393_loop:
    (rx392_pos) = rx392_cur."from"()
    inc rx392_pos
    rx392_cur."!cursor_from"(rx392_pos)
    ge rx392_pos, rx392_eos, rxscan393_done
  rxscan393_scan:
    set_addr $I10, rxscan393_loop
    rx392_cur."!mark_push"(0, rx392_pos, $I10)
  rxscan393_done:
.annotate 'line', 186
  # rx pass
    rx392_cur."!cursor_pass"(rx392_pos, "you_are_here")
    if_null rx392_debug, debug_717
    rx392_cur."!cursor_debug"("PASS", "you_are_here", " at pos=", rx392_pos)
  debug_717:
    .return (rx392_cur)
  rx392_restart:
.annotate 'line', 10
    if_null rx392_debug, debug_718
    rx392_cur."!cursor_debug"("NEXT", "you_are_here")
  debug_718:
  rx392_fail:
    (rx392_rep, rx392_pos, $I10, $P10) = rx392_cur."!mark_fail"(0)
    lt rx392_pos, -1, rx392_done
    eq rx392_pos, -1, rx392_fail
    jump $I10
  rx392_done:
    rx392_cur."!cursor_fail"()
    if_null rx392_debug, debug_719
    rx392_cur."!cursor_debug"("FAIL", "you_are_here")
  debug_719:
    .return (rx392_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__you_are_here"  :subid("58_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    new $P395, "ResizablePMCArray"
    push $P395, ""
    .return ($P395)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator"  :subid("59_1304456155.152")
    .param pmc param_397
.annotate 'line', 188
    .lex "self", param_397
    $P398 = param_397."!protoregex"("terminator")
    .return ($P398)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator"  :subid("60_1304456155.152")
    .param pmc param_400
.annotate 'line', 188
    .lex "self", param_400
    $P401 = param_400."!PREFIX__!protoregex"("terminator")
    .return ($P401)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<;>"  :subid("61_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx403_tgt
    .local int rx403_pos
    .local int rx403_off
    .local int rx403_eos
    .local int rx403_rep
    .local pmc rx403_cur
    .local pmc rx403_debug
    (rx403_cur, rx403_pos, rx403_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx403_cur
    .local pmc match
    .lex "$/", match
    length rx403_eos, rx403_tgt
    gt rx403_pos, rx403_eos, rx403_done
    set rx403_off, 0
    lt rx403_pos, 2, rx403_start
    sub rx403_off, rx403_pos, 1
    substr rx403_tgt, rx403_tgt, rx403_off
  rx403_start:
    eq $I10, 1, rx403_restart
    if_null rx403_debug, debug_720
    rx403_cur."!cursor_debug"("START", "terminator:sym<;>")
  debug_720:
    $I10 = self.'from'()
    ne $I10, -1, rxscan404_done
    goto rxscan404_scan
  rxscan404_loop:
    (rx403_pos) = rx403_cur."from"()
    inc rx403_pos
    rx403_cur."!cursor_from"(rx403_pos)
    ge rx403_pos, rx403_eos, rxscan404_done
  rxscan404_scan:
    set_addr $I10, rxscan404_loop
    rx403_cur."!mark_push"(0, rx403_pos, $I10)
  rxscan404_done:
.annotate 'line', 190
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx403_pos, rx403_off
    substr $S10, rx403_tgt, $I10, 1
    index $I11, ";", $S10
    lt $I11, 0, rx403_fail
  # rx pass
    rx403_cur."!cursor_pass"(rx403_pos, "terminator:sym<;>")
    if_null rx403_debug, debug_721
    rx403_cur."!cursor_debug"("PASS", "terminator:sym<;>", " at pos=", rx403_pos)
  debug_721:
    .return (rx403_cur)
  rx403_restart:
.annotate 'line', 10
    if_null rx403_debug, debug_722
    rx403_cur."!cursor_debug"("NEXT", "terminator:sym<;>")
  debug_722:
  rx403_fail:
    (rx403_rep, rx403_pos, $I10, $P10) = rx403_cur."!mark_fail"(0)
    lt rx403_pos, -1, rx403_done
    eq rx403_pos, -1, rx403_fail
    jump $I10
  rx403_done:
    rx403_cur."!cursor_fail"()
    if_null rx403_debug, debug_723
    rx403_cur."!cursor_debug"("FAIL", "terminator:sym<;>")
  debug_723:
    .return (rx403_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<;>"  :subid("62_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    new $P406, "ResizablePMCArray"
    push $P406, ";"
    .return ($P406)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<}>"  :subid("63_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx408_tgt
    .local int rx408_pos
    .local int rx408_off
    .local int rx408_eos
    .local int rx408_rep
    .local pmc rx408_cur
    .local pmc rx408_debug
    (rx408_cur, rx408_pos, rx408_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx408_cur
    .local pmc match
    .lex "$/", match
    length rx408_eos, rx408_tgt
    gt rx408_pos, rx408_eos, rx408_done
    set rx408_off, 0
    lt rx408_pos, 2, rx408_start
    sub rx408_off, rx408_pos, 1
    substr rx408_tgt, rx408_tgt, rx408_off
  rx408_start:
    eq $I10, 1, rx408_restart
    if_null rx408_debug, debug_724
    rx408_cur."!cursor_debug"("START", "terminator:sym<}>")
  debug_724:
    $I10 = self.'from'()
    ne $I10, -1, rxscan409_done
    goto rxscan409_scan
  rxscan409_loop:
    (rx408_pos) = rx408_cur."from"()
    inc rx408_pos
    rx408_cur."!cursor_from"(rx408_pos)
    ge rx408_pos, rx408_eos, rxscan409_done
  rxscan409_scan:
    set_addr $I10, rxscan409_loop
    rx408_cur."!mark_push"(0, rx408_pos, $I10)
  rxscan409_done:
.annotate 'line', 191
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx408_pos, rx408_off
    substr $S10, rx408_tgt, $I10, 1
    index $I11, "}", $S10
    lt $I11, 0, rx408_fail
  # rx pass
    rx408_cur."!cursor_pass"(rx408_pos, "terminator:sym<}>")
    if_null rx408_debug, debug_725
    rx408_cur."!cursor_debug"("PASS", "terminator:sym<}>", " at pos=", rx408_pos)
  debug_725:
    .return (rx408_cur)
  rx408_restart:
.annotate 'line', 10
    if_null rx408_debug, debug_726
    rx408_cur."!cursor_debug"("NEXT", "terminator:sym<}>")
  debug_726:
  rx408_fail:
    (rx408_rep, rx408_pos, $I10, $P10) = rx408_cur."!mark_fail"(0)
    lt rx408_pos, -1, rx408_done
    eq rx408_pos, -1, rx408_fail
    jump $I10
  rx408_done:
    rx408_cur."!cursor_fail"()
    if_null rx408_debug, debug_727
    rx408_cur."!cursor_debug"("FAIL", "terminator:sym<}>")
  debug_727:
    .return (rx408_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<}>"  :subid("64_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    new $P411, "ResizablePMCArray"
    push $P411, "}"
    .return ($P411)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control"  :subid("65_1304456155.152")
    .param pmc param_413
.annotate 'line', 195
    .lex "self", param_413
    $P414 = param_413."!protoregex"("statement_control")
    .return ($P414)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control"  :subid("66_1304456155.152")
    .param pmc param_416
.annotate 'line', 195
    .lex "self", param_416
    $P417 = param_416."!PREFIX__!protoregex"("statement_control")
    .return ($P417)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<use>"  :subid("67_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx419_tgt
    .local int rx419_pos
    .local int rx419_off
    .local int rx419_eos
    .local int rx419_rep
    .local pmc rx419_cur
    .local pmc rx419_debug
    (rx419_cur, rx419_pos, rx419_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx419_cur
    .local pmc match
    .lex "$/", match
    length rx419_eos, rx419_tgt
    gt rx419_pos, rx419_eos, rx419_done
    set rx419_off, 0
    lt rx419_pos, 2, rx419_start
    sub rx419_off, rx419_pos, 1
    substr rx419_tgt, rx419_tgt, rx419_off
  rx419_start:
    eq $I10, 1, rx419_restart
    if_null rx419_debug, debug_728
    rx419_cur."!cursor_debug"("START", "statement_control:sym<use>")
  debug_728:
    $I10 = self.'from'()
    ne $I10, -1, rxscan420_done
    goto rxscan420_scan
  rxscan420_loop:
    (rx419_pos) = rx419_cur."from"()
    inc rx419_pos
    rx419_cur."!cursor_from"(rx419_pos)
    ge rx419_pos, rx419_eos, rxscan420_done
  rxscan420_scan:
    set_addr $I10, rxscan420_loop
    rx419_cur."!mark_push"(0, rx419_pos, $I10)
  rxscan420_done:
.annotate 'line', 198
  # rx subcapture "sym"
    set_addr $I10, rxcap_421_fail
    rx419_cur."!mark_push"(0, rx419_pos, $I10)
  # rx literal  "use"
    add $I11, rx419_pos, 3
    gt $I11, rx419_eos, rx419_fail
    sub $I11, rx419_pos, rx419_off
    substr $S10, rx419_tgt, $I11, 3
    ne $S10, "use", rx419_fail
    add rx419_pos, 3
    set_addr $I10, rxcap_421_fail
    ($I12, $I11) = rx419_cur."!mark_peek"($I10)
    rx419_cur."!cursor_pos"($I11)
    ($P10) = rx419_cur."!cursor_start"()
    $P10."!cursor_pass"(rx419_pos, "")
    rx419_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_421_done
  rxcap_421_fail:
    goto rx419_fail
  rxcap_421_done:
  # rx charclass s
    ge rx419_pos, rx419_eos, rx419_fail
    sub $I10, rx419_pos, rx419_off
    is_cclass $I11, 32, rx419_tgt, $I10
    unless $I11, rx419_fail
    inc rx419_pos
  # rx subrule "ws" subtype=method negate=
    rx419_cur."!cursor_pos"(rx419_pos)
    $P10 = rx419_cur."ws"()
    unless $P10, rx419_fail
    rx419_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx419_cur."!cursor_pos"(rx419_pos)
    $P10 = rx419_cur."name"()
    unless $P10, rx419_fail
    rx419_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx419_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx419_cur."!cursor_pos"(rx419_pos)
    $P10 = rx419_cur."ws"()
    unless $P10, rx419_fail
    rx419_pos = $P10."pos"()
.annotate 'line', 197
  # rx pass
    rx419_cur."!cursor_pass"(rx419_pos, "statement_control:sym<use>")
    if_null rx419_debug, debug_729
    rx419_cur."!cursor_debug"("PASS", "statement_control:sym<use>", " at pos=", rx419_pos)
  debug_729:
    .return (rx419_cur)
  rx419_restart:
.annotate 'line', 10
    if_null rx419_debug, debug_730
    rx419_cur."!cursor_debug"("NEXT", "statement_control:sym<use>")
  debug_730:
  rx419_fail:
    (rx419_rep, rx419_pos, $I10, $P10) = rx419_cur."!mark_fail"(0)
    lt rx419_pos, -1, rx419_done
    eq rx419_pos, -1, rx419_fail
    jump $I10
  rx419_done:
    rx419_cur."!cursor_fail"()
    if_null rx419_debug, debug_731
    rx419_cur."!cursor_debug"("FAIL", "statement_control:sym<use>")
  debug_731:
    .return (rx419_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<use>"  :subid("68_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    new $P425, "ResizablePMCArray"
    push $P425, "use"
    .return ($P425)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<if>"  :subid("69_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx427_tgt
    .local int rx427_pos
    .local int rx427_off
    .local int rx427_eos
    .local int rx427_rep
    .local pmc rx427_cur
    .local pmc rx427_debug
    (rx427_cur, rx427_pos, rx427_tgt, $I10) = self."!cursor_start"()
    rx427_cur."!cursor_caparray"("xblock", "else")
    .lex unicode:"$\x{a2}", rx427_cur
    .local pmc match
    .lex "$/", match
    length rx427_eos, rx427_tgt
    gt rx427_pos, rx427_eos, rx427_done
    set rx427_off, 0
    lt rx427_pos, 2, rx427_start
    sub rx427_off, rx427_pos, 1
    substr rx427_tgt, rx427_tgt, rx427_off
  rx427_start:
    eq $I10, 1, rx427_restart
    if_null rx427_debug, debug_732
    rx427_cur."!cursor_debug"("START", "statement_control:sym<if>")
  debug_732:
    $I10 = self.'from'()
    ne $I10, -1, rxscan428_done
    goto rxscan428_scan
  rxscan428_loop:
    (rx427_pos) = rx427_cur."from"()
    inc rx427_pos
    rx427_cur."!cursor_from"(rx427_pos)
    ge rx427_pos, rx427_eos, rxscan428_done
  rxscan428_scan:
    set_addr $I10, rxscan428_loop
    rx427_cur."!mark_push"(0, rx427_pos, $I10)
  rxscan428_done:
.annotate 'line', 202
  # rx subcapture "sym"
    set_addr $I10, rxcap_429_fail
    rx427_cur."!mark_push"(0, rx427_pos, $I10)
  # rx literal  "if"
    add $I11, rx427_pos, 2
    gt $I11, rx427_eos, rx427_fail
    sub $I11, rx427_pos, rx427_off
    substr $S10, rx427_tgt, $I11, 2
    ne $S10, "if", rx427_fail
    add rx427_pos, 2
    set_addr $I10, rxcap_429_fail
    ($I12, $I11) = rx427_cur."!mark_peek"($I10)
    rx427_cur."!cursor_pos"($I11)
    ($P10) = rx427_cur."!cursor_start"()
    $P10."!cursor_pass"(rx427_pos, "")
    rx427_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_429_done
  rxcap_429_fail:
    goto rx427_fail
  rxcap_429_done:
  # rx charclass s
    ge rx427_pos, rx427_eos, rx427_fail
    sub $I10, rx427_pos, rx427_off
    is_cclass $I11, 32, rx427_tgt, $I10
    unless $I11, rx427_fail
    inc rx427_pos
  # rx subrule "ws" subtype=method negate=
    rx427_cur."!cursor_pos"(rx427_pos)
    $P10 = rx427_cur."ws"()
    unless $P10, rx427_fail
    rx427_pos = $P10."pos"()
.annotate 'line', 203
  # rx subrule "xblock" subtype=capture negate=
    rx427_cur."!cursor_pos"(rx427_pos)
    $P10 = rx427_cur."xblock"()
    unless $P10, rx427_fail
    rx427_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx427_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx427_cur."!cursor_pos"(rx427_pos)
    $P10 = rx427_cur."ws"()
    unless $P10, rx427_fail
    rx427_pos = $P10."pos"()
.annotate 'line', 204
  # rx rxquantr432 ** 0..*
    set_addr $I10, rxquantr432_done
    rx427_cur."!mark_push"(0, rx427_pos, $I10)
  rxquantr432_loop:
  # rx subrule "ws" subtype=method negate=
    rx427_cur."!cursor_pos"(rx427_pos)
    $P10 = rx427_cur."ws"()
    unless $P10, rx427_fail
    rx427_pos = $P10."pos"()
  # rx literal  "elsif"
    add $I11, rx427_pos, 5
    gt $I11, rx427_eos, rx427_fail
    sub $I11, rx427_pos, rx427_off
    substr $S10, rx427_tgt, $I11, 5
    ne $S10, "elsif", rx427_fail
    add rx427_pos, 5
  # rx charclass s
    ge rx427_pos, rx427_eos, rx427_fail
    sub $I10, rx427_pos, rx427_off
    is_cclass $I11, 32, rx427_tgt, $I10
    unless $I11, rx427_fail
    inc rx427_pos
  # rx subrule "ws" subtype=method negate=
    rx427_cur."!cursor_pos"(rx427_pos)
    $P10 = rx427_cur."ws"()
    unless $P10, rx427_fail
    rx427_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx427_cur."!cursor_pos"(rx427_pos)
    $P10 = rx427_cur."xblock"()
    unless $P10, rx427_fail
    rx427_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx427_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx427_cur."!cursor_pos"(rx427_pos)
    $P10 = rx427_cur."ws"()
    unless $P10, rx427_fail
    rx427_pos = $P10."pos"()
    set_addr $I10, rxquantr432_done
    (rx427_rep) = rx427_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr432_done
    rx427_cur."!mark_push"(rx427_rep, rx427_pos, $I10)
    goto rxquantr432_loop
  rxquantr432_done:
  # rx subrule "ws" subtype=method negate=
    rx427_cur."!cursor_pos"(rx427_pos)
    $P10 = rx427_cur."ws"()
    unless $P10, rx427_fail
    rx427_pos = $P10."pos"()
.annotate 'line', 205
  # rx rxquantr437 ** 0..1
    set_addr $I10, rxquantr437_done
    rx427_cur."!mark_push"(0, rx427_pos, $I10)
  rxquantr437_loop:
  # rx subrule "ws" subtype=method negate=
    rx427_cur."!cursor_pos"(rx427_pos)
    $P10 = rx427_cur."ws"()
    unless $P10, rx427_fail
    rx427_pos = $P10."pos"()
  # rx literal  "else"
    add $I11, rx427_pos, 4
    gt $I11, rx427_eos, rx427_fail
    sub $I11, rx427_pos, rx427_off
    substr $S10, rx427_tgt, $I11, 4
    ne $S10, "else", rx427_fail
    add rx427_pos, 4
  # rx charclass s
    ge rx427_pos, rx427_eos, rx427_fail
    sub $I10, rx427_pos, rx427_off
    is_cclass $I11, 32, rx427_tgt, $I10
    unless $I11, rx427_fail
    inc rx427_pos
  # rx subrule "ws" subtype=method negate=
    rx427_cur."!cursor_pos"(rx427_pos)
    $P10 = rx427_cur."ws"()
    unless $P10, rx427_fail
    rx427_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx427_cur."!cursor_pos"(rx427_pos)
    $P10 = rx427_cur."pblock"()
    unless $P10, rx427_fail
    rx427_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("else")
    rx427_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx427_cur."!cursor_pos"(rx427_pos)
    $P10 = rx427_cur."ws"()
    unless $P10, rx427_fail
    rx427_pos = $P10."pos"()
    set_addr $I10, rxquantr437_done
    (rx427_rep) = rx427_cur."!mark_commit"($I10)
  rxquantr437_done:
  # rx subrule "ws" subtype=method negate=
    rx427_cur."!cursor_pos"(rx427_pos)
    $P10 = rx427_cur."ws"()
    unless $P10, rx427_fail
    rx427_pos = $P10."pos"()
.annotate 'line', 201
  # rx pass
    rx427_cur."!cursor_pass"(rx427_pos, "statement_control:sym<if>")
    if_null rx427_debug, debug_733
    rx427_cur."!cursor_debug"("PASS", "statement_control:sym<if>", " at pos=", rx427_pos)
  debug_733:
    .return (rx427_cur)
  rx427_restart:
.annotate 'line', 10
    if_null rx427_debug, debug_734
    rx427_cur."!cursor_debug"("NEXT", "statement_control:sym<if>")
  debug_734:
  rx427_fail:
    (rx427_rep, rx427_pos, $I10, $P10) = rx427_cur."!mark_fail"(0)
    lt rx427_pos, -1, rx427_done
    eq rx427_pos, -1, rx427_fail
    jump $I10
  rx427_done:
    rx427_cur."!cursor_fail"()
    if_null rx427_debug, debug_735
    rx427_cur."!cursor_debug"("FAIL", "statement_control:sym<if>")
  debug_735:
    .return (rx427_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<if>"  :subid("70_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    new $P443, "ResizablePMCArray"
    push $P443, "if"
    .return ($P443)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<unless>"  :subid("71_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .const 'Sub' $P453 = "72_1304456155.152" 
    capture_lex $P453
    .local string rx445_tgt
    .local int rx445_pos
    .local int rx445_off
    .local int rx445_eos
    .local int rx445_rep
    .local pmc rx445_cur
    .local pmc rx445_debug
    (rx445_cur, rx445_pos, rx445_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx445_cur
    .local pmc match
    .lex "$/", match
    length rx445_eos, rx445_tgt
    gt rx445_pos, rx445_eos, rx445_done
    set rx445_off, 0
    lt rx445_pos, 2, rx445_start
    sub rx445_off, rx445_pos, 1
    substr rx445_tgt, rx445_tgt, rx445_off
  rx445_start:
    eq $I10, 1, rx445_restart
    if_null rx445_debug, debug_736
    rx445_cur."!cursor_debug"("START", "statement_control:sym<unless>")
  debug_736:
    $I10 = self.'from'()
    ne $I10, -1, rxscan446_done
    goto rxscan446_scan
  rxscan446_loop:
    (rx445_pos) = rx445_cur."from"()
    inc rx445_pos
    rx445_cur."!cursor_from"(rx445_pos)
    ge rx445_pos, rx445_eos, rxscan446_done
  rxscan446_scan:
    set_addr $I10, rxscan446_loop
    rx445_cur."!mark_push"(0, rx445_pos, $I10)
  rxscan446_done:
.annotate 'line', 209
  # rx subcapture "sym"
    set_addr $I10, rxcap_447_fail
    rx445_cur."!mark_push"(0, rx445_pos, $I10)
  # rx literal  "unless"
    add $I11, rx445_pos, 6
    gt $I11, rx445_eos, rx445_fail
    sub $I11, rx445_pos, rx445_off
    substr $S10, rx445_tgt, $I11, 6
    ne $S10, "unless", rx445_fail
    add rx445_pos, 6
    set_addr $I10, rxcap_447_fail
    ($I12, $I11) = rx445_cur."!mark_peek"($I10)
    rx445_cur."!cursor_pos"($I11)
    ($P10) = rx445_cur."!cursor_start"()
    $P10."!cursor_pass"(rx445_pos, "")
    rx445_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_447_done
  rxcap_447_fail:
    goto rx445_fail
  rxcap_447_done:
  # rx charclass s
    ge rx445_pos, rx445_eos, rx445_fail
    sub $I10, rx445_pos, rx445_off
    is_cclass $I11, 32, rx445_tgt, $I10
    unless $I11, rx445_fail
    inc rx445_pos
  # rx subrule "ws" subtype=method negate=
    rx445_cur."!cursor_pos"(rx445_pos)
    $P10 = rx445_cur."ws"()
    unless $P10, rx445_fail
    rx445_pos = $P10."pos"()
.annotate 'line', 210
  # rx subrule "xblock" subtype=capture negate=
    rx445_cur."!cursor_pos"(rx445_pos)
    $P10 = rx445_cur."xblock"()
    unless $P10, rx445_fail
    rx445_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx445_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx445_cur."!cursor_pos"(rx445_pos)
    $P10 = rx445_cur."ws"()
    unless $P10, rx445_fail
    rx445_pos = $P10."pos"()
  alt450_0:
.annotate 'line', 211
    set_addr $I10, alt450_1
    rx445_cur."!mark_push"(0, rx445_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx445_cur."!cursor_pos"(rx445_pos)
    $P10 = rx445_cur."ws"()
    unless $P10, rx445_fail
    rx445_pos = $P10."pos"()
  # rx subrule "before" subtype=zerowidth negate=1
    rx445_cur."!cursor_pos"(rx445_pos)
    .const 'Sub' $P453 = "72_1304456155.152" 
    capture_lex $P453
    $P10 = rx445_cur."before"($P453)
    if $P10, rx445_fail
  # rx subrule "ws" subtype=method negate=
    rx445_cur."!cursor_pos"(rx445_pos)
    $P10 = rx445_cur."ws"()
    unless $P10, rx445_fail
    rx445_pos = $P10."pos"()
    goto alt450_end
  alt450_1:
  # rx subrule "ws" subtype=method negate=
    rx445_cur."!cursor_pos"(rx445_pos)
    $P10 = rx445_cur."ws"()
    unless $P10, rx445_fail
    rx445_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx445_cur."!cursor_pos"(rx445_pos)
    $P10 = rx445_cur."panic"("unless does not take \"else\", please rewrite using \"if\"")
    unless $P10, rx445_fail
    rx445_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx445_cur."!cursor_pos"(rx445_pos)
    $P10 = rx445_cur."ws"()
    unless $P10, rx445_fail
    rx445_pos = $P10."pos"()
  alt450_end:
  # rx subrule "ws" subtype=method negate=
    rx445_cur."!cursor_pos"(rx445_pos)
    $P10 = rx445_cur."ws"()
    unless $P10, rx445_fail
    rx445_pos = $P10."pos"()
.annotate 'line', 208
  # rx pass
    rx445_cur."!cursor_pass"(rx445_pos, "statement_control:sym<unless>")
    if_null rx445_debug, debug_741
    rx445_cur."!cursor_debug"("PASS", "statement_control:sym<unless>", " at pos=", rx445_pos)
  debug_741:
    .return (rx445_cur)
  rx445_restart:
.annotate 'line', 10
    if_null rx445_debug, debug_742
    rx445_cur."!cursor_debug"("NEXT", "statement_control:sym<unless>")
  debug_742:
  rx445_fail:
    (rx445_rep, rx445_pos, $I10, $P10) = rx445_cur."!mark_fail"(0)
    lt rx445_pos, -1, rx445_done
    eq rx445_pos, -1, rx445_fail
    jump $I10
  rx445_done:
    rx445_cur."!cursor_fail"()
    if_null rx445_debug, debug_743
    rx445_cur."!cursor_debug"("FAIL", "statement_control:sym<unless>")
  debug_743:
    .return (rx445_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block452"  :anon :subid("72_1304456155.152") :method :outer("71_1304456155.152")
.annotate 'line', 211
    .local string rx454_tgt
    .local int rx454_pos
    .local int rx454_off
    .local int rx454_eos
    .local int rx454_rep
    .local pmc rx454_cur
    .local pmc rx454_debug
    (rx454_cur, rx454_pos, rx454_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx454_cur
    .local pmc match
    .lex "$/", match
    length rx454_eos, rx454_tgt
    gt rx454_pos, rx454_eos, rx454_done
    set rx454_off, 0
    lt rx454_pos, 2, rx454_start
    sub rx454_off, rx454_pos, 1
    substr rx454_tgt, rx454_tgt, rx454_off
  rx454_start:
    eq $I10, 1, rx454_restart
    if_null rx454_debug, debug_737
    rx454_cur."!cursor_debug"("START", "")
  debug_737:
    $I10 = self.'from'()
    ne $I10, -1, rxscan455_done
    goto rxscan455_scan
  rxscan455_loop:
    (rx454_pos) = rx454_cur."from"()
    inc rx454_pos
    rx454_cur."!cursor_from"(rx454_pos)
    ge rx454_pos, rx454_eos, rxscan455_done
  rxscan455_scan:
    set_addr $I10, rxscan455_loop
    rx454_cur."!mark_push"(0, rx454_pos, $I10)
  rxscan455_done:
  # rx literal  "else"
    add $I11, rx454_pos, 4
    gt $I11, rx454_eos, rx454_fail
    sub $I11, rx454_pos, rx454_off
    substr $S10, rx454_tgt, $I11, 4
    ne $S10, "else", rx454_fail
    add rx454_pos, 4
  # rx pass
    rx454_cur."!cursor_pass"(rx454_pos, "")
    if_null rx454_debug, debug_738
    rx454_cur."!cursor_debug"("PASS", "", " at pos=", rx454_pos)
  debug_738:
    .return (rx454_cur)
  rx454_restart:
    if_null rx454_debug, debug_739
    rx454_cur."!cursor_debug"("NEXT", "")
  debug_739:
  rx454_fail:
    (rx454_rep, rx454_pos, $I10, $P10) = rx454_cur."!mark_fail"(0)
    lt rx454_pos, -1, rx454_done
    eq rx454_pos, -1, rx454_fail
    jump $I10
  rx454_done:
    rx454_cur."!cursor_fail"()
    if_null rx454_debug, debug_740
    rx454_cur."!cursor_debug"("FAIL", "")
  debug_740:
    .return (rx454_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<unless>"  :subid("73_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    new $P461, "ResizablePMCArray"
    push $P461, "unless"
    .return ($P461)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<while>"  :subid("74_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx463_tgt
    .local int rx463_pos
    .local int rx463_off
    .local int rx463_eos
    .local int rx463_rep
    .local pmc rx463_cur
    .local pmc rx463_debug
    (rx463_cur, rx463_pos, rx463_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx463_cur
    .local pmc match
    .lex "$/", match
    length rx463_eos, rx463_tgt
    gt rx463_pos, rx463_eos, rx463_done
    set rx463_off, 0
    lt rx463_pos, 2, rx463_start
    sub rx463_off, rx463_pos, 1
    substr rx463_tgt, rx463_tgt, rx463_off
  rx463_start:
    eq $I10, 1, rx463_restart
    if_null rx463_debug, debug_744
    rx463_cur."!cursor_debug"("START", "statement_control:sym<while>")
  debug_744:
    $I10 = self.'from'()
    ne $I10, -1, rxscan464_done
    goto rxscan464_scan
  rxscan464_loop:
    (rx463_pos) = rx463_cur."from"()
    inc rx463_pos
    rx463_cur."!cursor_from"(rx463_pos)
    ge rx463_pos, rx463_eos, rxscan464_done
  rxscan464_scan:
    set_addr $I10, rxscan464_loop
    rx463_cur."!mark_push"(0, rx463_pos, $I10)
  rxscan464_done:
.annotate 'line', 215
  # rx subcapture "sym"
    set_addr $I10, rxcap_466_fail
    rx463_cur."!mark_push"(0, rx463_pos, $I10)
  alt465_0:
    set_addr $I10, alt465_1
    rx463_cur."!mark_push"(0, rx463_pos, $I10)
  # rx literal  "while"
    add $I11, rx463_pos, 5
    gt $I11, rx463_eos, rx463_fail
    sub $I11, rx463_pos, rx463_off
    substr $S10, rx463_tgt, $I11, 5
    ne $S10, "while", rx463_fail
    add rx463_pos, 5
    goto alt465_end
  alt465_1:
  # rx literal  "until"
    add $I11, rx463_pos, 5
    gt $I11, rx463_eos, rx463_fail
    sub $I11, rx463_pos, rx463_off
    substr $S10, rx463_tgt, $I11, 5
    ne $S10, "until", rx463_fail
    add rx463_pos, 5
  alt465_end:
    set_addr $I10, rxcap_466_fail
    ($I12, $I11) = rx463_cur."!mark_peek"($I10)
    rx463_cur."!cursor_pos"($I11)
    ($P10) = rx463_cur."!cursor_start"()
    $P10."!cursor_pass"(rx463_pos, "")
    rx463_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_466_done
  rxcap_466_fail:
    goto rx463_fail
  rxcap_466_done:
  # rx charclass s
    ge rx463_pos, rx463_eos, rx463_fail
    sub $I10, rx463_pos, rx463_off
    is_cclass $I11, 32, rx463_tgt, $I10
    unless $I11, rx463_fail
    inc rx463_pos
  # rx subrule "ws" subtype=method negate=
    rx463_cur."!cursor_pos"(rx463_pos)
    $P10 = rx463_cur."ws"()
    unless $P10, rx463_fail
    rx463_pos = $P10."pos"()
.annotate 'line', 216
  # rx subrule "xblock" subtype=capture negate=
    rx463_cur."!cursor_pos"(rx463_pos)
    $P10 = rx463_cur."xblock"()
    unless $P10, rx463_fail
    rx463_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx463_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx463_cur."!cursor_pos"(rx463_pos)
    $P10 = rx463_cur."ws"()
    unless $P10, rx463_fail
    rx463_pos = $P10."pos"()
.annotate 'line', 214
  # rx pass
    rx463_cur."!cursor_pass"(rx463_pos, "statement_control:sym<while>")
    if_null rx463_debug, debug_745
    rx463_cur."!cursor_debug"("PASS", "statement_control:sym<while>", " at pos=", rx463_pos)
  debug_745:
    .return (rx463_cur)
  rx463_restart:
.annotate 'line', 10
    if_null rx463_debug, debug_746
    rx463_cur."!cursor_debug"("NEXT", "statement_control:sym<while>")
  debug_746:
  rx463_fail:
    (rx463_rep, rx463_pos, $I10, $P10) = rx463_cur."!mark_fail"(0)
    lt rx463_pos, -1, rx463_done
    eq rx463_pos, -1, rx463_fail
    jump $I10
  rx463_done:
    rx463_cur."!cursor_fail"()
    if_null rx463_debug, debug_747
    rx463_cur."!cursor_debug"("FAIL", "statement_control:sym<while>")
  debug_747:
    .return (rx463_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<while>"  :subid("75_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    new $P470, "ResizablePMCArray"
    push $P470, "until"
    push $P470, "while"
    .return ($P470)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<repeat>"  :subid("76_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx472_tgt
    .local int rx472_pos
    .local int rx472_off
    .local int rx472_eos
    .local int rx472_rep
    .local pmc rx472_cur
    .local pmc rx472_debug
    (rx472_cur, rx472_pos, rx472_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx472_cur
    .local pmc match
    .lex "$/", match
    length rx472_eos, rx472_tgt
    gt rx472_pos, rx472_eos, rx472_done
    set rx472_off, 0
    lt rx472_pos, 2, rx472_start
    sub rx472_off, rx472_pos, 1
    substr rx472_tgt, rx472_tgt, rx472_off
  rx472_start:
    eq $I10, 1, rx472_restart
    if_null rx472_debug, debug_748
    rx472_cur."!cursor_debug"("START", "statement_control:sym<repeat>")
  debug_748:
    $I10 = self.'from'()
    ne $I10, -1, rxscan473_done
    goto rxscan473_scan
  rxscan473_loop:
    (rx472_pos) = rx472_cur."from"()
    inc rx472_pos
    rx472_cur."!cursor_from"(rx472_pos)
    ge rx472_pos, rx472_eos, rxscan473_done
  rxscan473_scan:
    set_addr $I10, rxscan473_loop
    rx472_cur."!mark_push"(0, rx472_pos, $I10)
  rxscan473_done:
.annotate 'line', 220
  # rx subcapture "sym"
    set_addr $I10, rxcap_474_fail
    rx472_cur."!mark_push"(0, rx472_pos, $I10)
  # rx literal  "repeat"
    add $I11, rx472_pos, 6
    gt $I11, rx472_eos, rx472_fail
    sub $I11, rx472_pos, rx472_off
    substr $S10, rx472_tgt, $I11, 6
    ne $S10, "repeat", rx472_fail
    add rx472_pos, 6
    set_addr $I10, rxcap_474_fail
    ($I12, $I11) = rx472_cur."!mark_peek"($I10)
    rx472_cur."!cursor_pos"($I11)
    ($P10) = rx472_cur."!cursor_start"()
    $P10."!cursor_pass"(rx472_pos, "")
    rx472_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_474_done
  rxcap_474_fail:
    goto rx472_fail
  rxcap_474_done:
  # rx charclass s
    ge rx472_pos, rx472_eos, rx472_fail
    sub $I10, rx472_pos, rx472_off
    is_cclass $I11, 32, rx472_tgt, $I10
    unless $I11, rx472_fail
    inc rx472_pos
  # rx subrule "ws" subtype=method negate=
    rx472_cur."!cursor_pos"(rx472_pos)
    $P10 = rx472_cur."ws"()
    unless $P10, rx472_fail
    rx472_pos = $P10."pos"()
  alt476_0:
.annotate 'line', 221
    set_addr $I10, alt476_1
    rx472_cur."!mark_push"(0, rx472_pos, $I10)
.annotate 'line', 222
  # rx subrule "ws" subtype=method negate=
    rx472_cur."!cursor_pos"(rx472_pos)
    $P10 = rx472_cur."ws"()
    unless $P10, rx472_fail
    rx472_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_479_fail
    rx472_cur."!mark_push"(0, rx472_pos, $I10)
  alt478_0:
    set_addr $I10, alt478_1
    rx472_cur."!mark_push"(0, rx472_pos, $I10)
  # rx literal  "while"
    add $I11, rx472_pos, 5
    gt $I11, rx472_eos, rx472_fail
    sub $I11, rx472_pos, rx472_off
    substr $S10, rx472_tgt, $I11, 5
    ne $S10, "while", rx472_fail
    add rx472_pos, 5
    goto alt478_end
  alt478_1:
  # rx literal  "until"
    add $I11, rx472_pos, 5
    gt $I11, rx472_eos, rx472_fail
    sub $I11, rx472_pos, rx472_off
    substr $S10, rx472_tgt, $I11, 5
    ne $S10, "until", rx472_fail
    add rx472_pos, 5
  alt478_end:
    set_addr $I10, rxcap_479_fail
    ($I12, $I11) = rx472_cur."!mark_peek"($I10)
    rx472_cur."!cursor_pos"($I11)
    ($P10) = rx472_cur."!cursor_start"()
    $P10."!cursor_pass"(rx472_pos, "")
    rx472_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_479_done
  rxcap_479_fail:
    goto rx472_fail
  rxcap_479_done:
  # rx charclass s
    ge rx472_pos, rx472_eos, rx472_fail
    sub $I10, rx472_pos, rx472_off
    is_cclass $I11, 32, rx472_tgt, $I10
    unless $I11, rx472_fail
    inc rx472_pos
  # rx subrule "ws" subtype=method negate=
    rx472_cur."!cursor_pos"(rx472_pos)
    $P10 = rx472_cur."ws"()
    unless $P10, rx472_fail
    rx472_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx472_cur."!cursor_pos"(rx472_pos)
    $P10 = rx472_cur."xblock"()
    unless $P10, rx472_fail
    rx472_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx472_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx472_cur."!cursor_pos"(rx472_pos)
    $P10 = rx472_cur."ws"()
    unless $P10, rx472_fail
    rx472_pos = $P10."pos"()
    goto alt476_end
  alt476_1:
.annotate 'line', 223
  # rx subrule "ws" subtype=method negate=
    rx472_cur."!cursor_pos"(rx472_pos)
    $P10 = rx472_cur."ws"()
    unless $P10, rx472_fail
    rx472_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx472_cur."!cursor_pos"(rx472_pos)
    $P10 = rx472_cur."pblock"()
    unless $P10, rx472_fail
    rx472_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx472_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx472_cur."!cursor_pos"(rx472_pos)
    $P10 = rx472_cur."ws"()
    unless $P10, rx472_fail
    rx472_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_485_fail
    rx472_cur."!mark_push"(0, rx472_pos, $I10)
  alt484_0:
    set_addr $I10, alt484_1
    rx472_cur."!mark_push"(0, rx472_pos, $I10)
  # rx literal  "while"
    add $I11, rx472_pos, 5
    gt $I11, rx472_eos, rx472_fail
    sub $I11, rx472_pos, rx472_off
    substr $S10, rx472_tgt, $I11, 5
    ne $S10, "while", rx472_fail
    add rx472_pos, 5
    goto alt484_end
  alt484_1:
  # rx literal  "until"
    add $I11, rx472_pos, 5
    gt $I11, rx472_eos, rx472_fail
    sub $I11, rx472_pos, rx472_off
    substr $S10, rx472_tgt, $I11, 5
    ne $S10, "until", rx472_fail
    add rx472_pos, 5
  alt484_end:
    set_addr $I10, rxcap_485_fail
    ($I12, $I11) = rx472_cur."!mark_peek"($I10)
    rx472_cur."!cursor_pos"($I11)
    ($P10) = rx472_cur."!cursor_start"()
    $P10."!cursor_pass"(rx472_pos, "")
    rx472_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_485_done
  rxcap_485_fail:
    goto rx472_fail
  rxcap_485_done:
  # rx charclass s
    ge rx472_pos, rx472_eos, rx472_fail
    sub $I10, rx472_pos, rx472_off
    is_cclass $I11, 32, rx472_tgt, $I10
    unless $I11, rx472_fail
    inc rx472_pos
  # rx subrule "ws" subtype=method negate=
    rx472_cur."!cursor_pos"(rx472_pos)
    $P10 = rx472_cur."ws"()
    unless $P10, rx472_fail
    rx472_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx472_cur."!cursor_pos"(rx472_pos)
    $P10 = rx472_cur."EXPR"()
    unless $P10, rx472_fail
    rx472_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx472_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx472_cur."!cursor_pos"(rx472_pos)
    $P10 = rx472_cur."ws"()
    unless $P10, rx472_fail
    rx472_pos = $P10."pos"()
  alt476_end:
.annotate 'line', 224
  # rx subrule "ws" subtype=method negate=
    rx472_cur."!cursor_pos"(rx472_pos)
    $P10 = rx472_cur."ws"()
    unless $P10, rx472_fail
    rx472_pos = $P10."pos"()
.annotate 'line', 219
  # rx pass
    rx472_cur."!cursor_pass"(rx472_pos, "statement_control:sym<repeat>")
    if_null rx472_debug, debug_749
    rx472_cur."!cursor_debug"("PASS", "statement_control:sym<repeat>", " at pos=", rx472_pos)
  debug_749:
    .return (rx472_cur)
  rx472_restart:
.annotate 'line', 10
    if_null rx472_debug, debug_750
    rx472_cur."!cursor_debug"("NEXT", "statement_control:sym<repeat>")
  debug_750:
  rx472_fail:
    (rx472_rep, rx472_pos, $I10, $P10) = rx472_cur."!mark_fail"(0)
    lt rx472_pos, -1, rx472_done
    eq rx472_pos, -1, rx472_fail
    jump $I10
  rx472_done:
    rx472_cur."!cursor_fail"()
    if_null rx472_debug, debug_751
    rx472_cur."!cursor_debug"("FAIL", "statement_control:sym<repeat>")
  debug_751:
    .return (rx472_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<repeat>"  :subid("77_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    new $P490, "ResizablePMCArray"
    push $P490, "repeat"
    .return ($P490)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<for>"  :subid("78_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx492_tgt
    .local int rx492_pos
    .local int rx492_off
    .local int rx492_eos
    .local int rx492_rep
    .local pmc rx492_cur
    .local pmc rx492_debug
    (rx492_cur, rx492_pos, rx492_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx492_cur
    .local pmc match
    .lex "$/", match
    length rx492_eos, rx492_tgt
    gt rx492_pos, rx492_eos, rx492_done
    set rx492_off, 0
    lt rx492_pos, 2, rx492_start
    sub rx492_off, rx492_pos, 1
    substr rx492_tgt, rx492_tgt, rx492_off
  rx492_start:
    eq $I10, 1, rx492_restart
    if_null rx492_debug, debug_752
    rx492_cur."!cursor_debug"("START", "statement_control:sym<for>")
  debug_752:
    $I10 = self.'from'()
    ne $I10, -1, rxscan493_done
    goto rxscan493_scan
  rxscan493_loop:
    (rx492_pos) = rx492_cur."from"()
    inc rx492_pos
    rx492_cur."!cursor_from"(rx492_pos)
    ge rx492_pos, rx492_eos, rxscan493_done
  rxscan493_scan:
    set_addr $I10, rxscan493_loop
    rx492_cur."!mark_push"(0, rx492_pos, $I10)
  rxscan493_done:
.annotate 'line', 228
  # rx subcapture "sym"
    set_addr $I10, rxcap_494_fail
    rx492_cur."!mark_push"(0, rx492_pos, $I10)
  # rx literal  "for"
    add $I11, rx492_pos, 3
    gt $I11, rx492_eos, rx492_fail
    sub $I11, rx492_pos, rx492_off
    substr $S10, rx492_tgt, $I11, 3
    ne $S10, "for", rx492_fail
    add rx492_pos, 3
    set_addr $I10, rxcap_494_fail
    ($I12, $I11) = rx492_cur."!mark_peek"($I10)
    rx492_cur."!cursor_pos"($I11)
    ($P10) = rx492_cur."!cursor_start"()
    $P10."!cursor_pass"(rx492_pos, "")
    rx492_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_494_done
  rxcap_494_fail:
    goto rx492_fail
  rxcap_494_done:
  # rx charclass s
    ge rx492_pos, rx492_eos, rx492_fail
    sub $I10, rx492_pos, rx492_off
    is_cclass $I11, 32, rx492_tgt, $I10
    unless $I11, rx492_fail
    inc rx492_pos
  # rx subrule "ws" subtype=method negate=
    rx492_cur."!cursor_pos"(rx492_pos)
    $P10 = rx492_cur."ws"()
    unless $P10, rx492_fail
    rx492_pos = $P10."pos"()
.annotate 'line', 229
  # rx subrule "xblock" subtype=capture negate=
    rx492_cur."!cursor_pos"(rx492_pos)
    $P10 = rx492_cur."xblock"()
    unless $P10, rx492_fail
    rx492_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx492_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx492_cur."!cursor_pos"(rx492_pos)
    $P10 = rx492_cur."ws"()
    unless $P10, rx492_fail
    rx492_pos = $P10."pos"()
.annotate 'line', 227
  # rx pass
    rx492_cur."!cursor_pass"(rx492_pos, "statement_control:sym<for>")
    if_null rx492_debug, debug_753
    rx492_cur."!cursor_debug"("PASS", "statement_control:sym<for>", " at pos=", rx492_pos)
  debug_753:
    .return (rx492_cur)
  rx492_restart:
.annotate 'line', 10
    if_null rx492_debug, debug_754
    rx492_cur."!cursor_debug"("NEXT", "statement_control:sym<for>")
  debug_754:
  rx492_fail:
    (rx492_rep, rx492_pos, $I10, $P10) = rx492_cur."!mark_fail"(0)
    lt rx492_pos, -1, rx492_done
    eq rx492_pos, -1, rx492_fail
    jump $I10
  rx492_done:
    rx492_cur."!cursor_fail"()
    if_null rx492_debug, debug_755
    rx492_cur."!cursor_debug"("FAIL", "statement_control:sym<for>")
  debug_755:
    .return (rx492_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<for>"  :subid("79_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    new $P498, "ResizablePMCArray"
    push $P498, "for"
    .return ($P498)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CATCH>"  :subid("80_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx500_tgt
    .local int rx500_pos
    .local int rx500_off
    .local int rx500_eos
    .local int rx500_rep
    .local pmc rx500_cur
    .local pmc rx500_debug
    (rx500_cur, rx500_pos, rx500_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx500_cur
    .local pmc match
    .lex "$/", match
    length rx500_eos, rx500_tgt
    gt rx500_pos, rx500_eos, rx500_done
    set rx500_off, 0
    lt rx500_pos, 2, rx500_start
    sub rx500_off, rx500_pos, 1
    substr rx500_tgt, rx500_tgt, rx500_off
  rx500_start:
    eq $I10, 1, rx500_restart
    if_null rx500_debug, debug_756
    rx500_cur."!cursor_debug"("START", "statement_control:sym<CATCH>")
  debug_756:
    $I10 = self.'from'()
    ne $I10, -1, rxscan501_done
    goto rxscan501_scan
  rxscan501_loop:
    (rx500_pos) = rx500_cur."from"()
    inc rx500_pos
    rx500_cur."!cursor_from"(rx500_pos)
    ge rx500_pos, rx500_eos, rxscan501_done
  rxscan501_scan:
    set_addr $I10, rxscan501_loop
    rx500_cur."!mark_push"(0, rx500_pos, $I10)
  rxscan501_done:
.annotate 'line', 233
  # rx subcapture "sym"
    set_addr $I10, rxcap_502_fail
    rx500_cur."!mark_push"(0, rx500_pos, $I10)
  # rx literal  "CATCH"
    add $I11, rx500_pos, 5
    gt $I11, rx500_eos, rx500_fail
    sub $I11, rx500_pos, rx500_off
    substr $S10, rx500_tgt, $I11, 5
    ne $S10, "CATCH", rx500_fail
    add rx500_pos, 5
    set_addr $I10, rxcap_502_fail
    ($I12, $I11) = rx500_cur."!mark_peek"($I10)
    rx500_cur."!cursor_pos"($I11)
    ($P10) = rx500_cur."!cursor_start"()
    $P10."!cursor_pass"(rx500_pos, "")
    rx500_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_502_done
  rxcap_502_fail:
    goto rx500_fail
  rxcap_502_done:
  # rx charclass s
    ge rx500_pos, rx500_eos, rx500_fail
    sub $I10, rx500_pos, rx500_off
    is_cclass $I11, 32, rx500_tgt, $I10
    unless $I11, rx500_fail
    inc rx500_pos
  # rx subrule "ws" subtype=method negate=
    rx500_cur."!cursor_pos"(rx500_pos)
    $P10 = rx500_cur."ws"()
    unless $P10, rx500_fail
    rx500_pos = $P10."pos"()
.annotate 'line', 234
  # rx subrule "block" subtype=capture negate=
    rx500_cur."!cursor_pos"(rx500_pos)
    $P10 = rx500_cur."block"()
    unless $P10, rx500_fail
    rx500_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx500_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx500_cur."!cursor_pos"(rx500_pos)
    $P10 = rx500_cur."ws"()
    unless $P10, rx500_fail
    rx500_pos = $P10."pos"()
.annotate 'line', 232
  # rx pass
    rx500_cur."!cursor_pass"(rx500_pos, "statement_control:sym<CATCH>")
    if_null rx500_debug, debug_757
    rx500_cur."!cursor_debug"("PASS", "statement_control:sym<CATCH>", " at pos=", rx500_pos)
  debug_757:
    .return (rx500_cur)
  rx500_restart:
.annotate 'line', 10
    if_null rx500_debug, debug_758
    rx500_cur."!cursor_debug"("NEXT", "statement_control:sym<CATCH>")
  debug_758:
  rx500_fail:
    (rx500_rep, rx500_pos, $I10, $P10) = rx500_cur."!mark_fail"(0)
    lt rx500_pos, -1, rx500_done
    eq rx500_pos, -1, rx500_fail
    jump $I10
  rx500_done:
    rx500_cur."!cursor_fail"()
    if_null rx500_debug, debug_759
    rx500_cur."!cursor_debug"("FAIL", "statement_control:sym<CATCH>")
  debug_759:
    .return (rx500_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CATCH>"  :subid("81_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    new $P506, "ResizablePMCArray"
    push $P506, "CATCH"
    .return ($P506)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CONTROL>"  :subid("82_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx508_tgt
    .local int rx508_pos
    .local int rx508_off
    .local int rx508_eos
    .local int rx508_rep
    .local pmc rx508_cur
    .local pmc rx508_debug
    (rx508_cur, rx508_pos, rx508_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx508_cur
    .local pmc match
    .lex "$/", match
    length rx508_eos, rx508_tgt
    gt rx508_pos, rx508_eos, rx508_done
    set rx508_off, 0
    lt rx508_pos, 2, rx508_start
    sub rx508_off, rx508_pos, 1
    substr rx508_tgt, rx508_tgt, rx508_off
  rx508_start:
    eq $I10, 1, rx508_restart
    if_null rx508_debug, debug_760
    rx508_cur."!cursor_debug"("START", "statement_control:sym<CONTROL>")
  debug_760:
    $I10 = self.'from'()
    ne $I10, -1, rxscan509_done
    goto rxscan509_scan
  rxscan509_loop:
    (rx508_pos) = rx508_cur."from"()
    inc rx508_pos
    rx508_cur."!cursor_from"(rx508_pos)
    ge rx508_pos, rx508_eos, rxscan509_done
  rxscan509_scan:
    set_addr $I10, rxscan509_loop
    rx508_cur."!mark_push"(0, rx508_pos, $I10)
  rxscan509_done:
.annotate 'line', 238
  # rx subcapture "sym"
    set_addr $I10, rxcap_510_fail
    rx508_cur."!mark_push"(0, rx508_pos, $I10)
  # rx literal  "CONTROL"
    add $I11, rx508_pos, 7
    gt $I11, rx508_eos, rx508_fail
    sub $I11, rx508_pos, rx508_off
    substr $S10, rx508_tgt, $I11, 7
    ne $S10, "CONTROL", rx508_fail
    add rx508_pos, 7
    set_addr $I10, rxcap_510_fail
    ($I12, $I11) = rx508_cur."!mark_peek"($I10)
    rx508_cur."!cursor_pos"($I11)
    ($P10) = rx508_cur."!cursor_start"()
    $P10."!cursor_pass"(rx508_pos, "")
    rx508_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_510_done
  rxcap_510_fail:
    goto rx508_fail
  rxcap_510_done:
  # rx charclass s
    ge rx508_pos, rx508_eos, rx508_fail
    sub $I10, rx508_pos, rx508_off
    is_cclass $I11, 32, rx508_tgt, $I10
    unless $I11, rx508_fail
    inc rx508_pos
  # rx subrule "ws" subtype=method negate=
    rx508_cur."!cursor_pos"(rx508_pos)
    $P10 = rx508_cur."ws"()
    unless $P10, rx508_fail
    rx508_pos = $P10."pos"()
.annotate 'line', 239
  # rx subrule "block" subtype=capture negate=
    rx508_cur."!cursor_pos"(rx508_pos)
    $P10 = rx508_cur."block"()
    unless $P10, rx508_fail
    rx508_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx508_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx508_cur."!cursor_pos"(rx508_pos)
    $P10 = rx508_cur."ws"()
    unless $P10, rx508_fail
    rx508_pos = $P10."pos"()
.annotate 'line', 237
  # rx pass
    rx508_cur."!cursor_pass"(rx508_pos, "statement_control:sym<CONTROL>")
    if_null rx508_debug, debug_761
    rx508_cur."!cursor_debug"("PASS", "statement_control:sym<CONTROL>", " at pos=", rx508_pos)
  debug_761:
    .return (rx508_cur)
  rx508_restart:
.annotate 'line', 10
    if_null rx508_debug, debug_762
    rx508_cur."!cursor_debug"("NEXT", "statement_control:sym<CONTROL>")
  debug_762:
  rx508_fail:
    (rx508_rep, rx508_pos, $I10, $P10) = rx508_cur."!mark_fail"(0)
    lt rx508_pos, -1, rx508_done
    eq rx508_pos, -1, rx508_fail
    jump $I10
  rx508_done:
    rx508_cur."!cursor_fail"()
    if_null rx508_debug, debug_763
    rx508_cur."!cursor_debug"("FAIL", "statement_control:sym<CONTROL>")
  debug_763:
    .return (rx508_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CONTROL>"  :subid("83_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    new $P514, "ResizablePMCArray"
    push $P514, "CONTROL"
    .return ($P514)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix"  :subid("84_1304456155.152")
    .param pmc param_516
.annotate 'line', 242
    .lex "self", param_516
    $P517 = param_516."!protoregex"("statement_prefix")
    .return ($P517)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix"  :subid("85_1304456155.152")
    .param pmc param_519
.annotate 'line', 242
    .lex "self", param_519
    $P520 = param_519."!PREFIX__!protoregex"("statement_prefix")
    .return ($P520)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<INIT>"  :subid("86_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx522_tgt
    .local int rx522_pos
    .local int rx522_off
    .local int rx522_eos
    .local int rx522_rep
    .local pmc rx522_cur
    .local pmc rx522_debug
    (rx522_cur, rx522_pos, rx522_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx522_cur
    .local pmc match
    .lex "$/", match
    length rx522_eos, rx522_tgt
    gt rx522_pos, rx522_eos, rx522_done
    set rx522_off, 0
    lt rx522_pos, 2, rx522_start
    sub rx522_off, rx522_pos, 1
    substr rx522_tgt, rx522_tgt, rx522_off
  rx522_start:
    eq $I10, 1, rx522_restart
    if_null rx522_debug, debug_764
    rx522_cur."!cursor_debug"("START", "statement_prefix:sym<INIT>")
  debug_764:
    $I10 = self.'from'()
    ne $I10, -1, rxscan523_done
    goto rxscan523_scan
  rxscan523_loop:
    (rx522_pos) = rx522_cur."from"()
    inc rx522_pos
    rx522_cur."!cursor_from"(rx522_pos)
    ge rx522_pos, rx522_eos, rxscan523_done
  rxscan523_scan:
    set_addr $I10, rxscan523_loop
    rx522_cur."!mark_push"(0, rx522_pos, $I10)
  rxscan523_done:
.annotate 'line', 243
  # rx subcapture "sym"
    set_addr $I10, rxcap_524_fail
    rx522_cur."!mark_push"(0, rx522_pos, $I10)
  # rx literal  "INIT"
    add $I11, rx522_pos, 4
    gt $I11, rx522_eos, rx522_fail
    sub $I11, rx522_pos, rx522_off
    substr $S10, rx522_tgt, $I11, 4
    ne $S10, "INIT", rx522_fail
    add rx522_pos, 4
    set_addr $I10, rxcap_524_fail
    ($I12, $I11) = rx522_cur."!mark_peek"($I10)
    rx522_cur."!cursor_pos"($I11)
    ($P10) = rx522_cur."!cursor_start"()
    $P10."!cursor_pass"(rx522_pos, "")
    rx522_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_524_done
  rxcap_524_fail:
    goto rx522_fail
  rxcap_524_done:
  # rx subrule "blorst" subtype=capture negate=
    rx522_cur."!cursor_pos"(rx522_pos)
    $P10 = rx522_cur."blorst"()
    unless $P10, rx522_fail
    rx522_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx522_pos = $P10."pos"()
  # rx pass
    rx522_cur."!cursor_pass"(rx522_pos, "statement_prefix:sym<INIT>")
    if_null rx522_debug, debug_765
    rx522_cur."!cursor_debug"("PASS", "statement_prefix:sym<INIT>", " at pos=", rx522_pos)
  debug_765:
    .return (rx522_cur)
  rx522_restart:
.annotate 'line', 10
    if_null rx522_debug, debug_766
    rx522_cur."!cursor_debug"("NEXT", "statement_prefix:sym<INIT>")
  debug_766:
  rx522_fail:
    (rx522_rep, rx522_pos, $I10, $P10) = rx522_cur."!mark_fail"(0)
    lt rx522_pos, -1, rx522_done
    eq rx522_pos, -1, rx522_fail
    jump $I10
  rx522_done:
    rx522_cur."!cursor_fail"()
    if_null rx522_debug, debug_767
    rx522_cur."!cursor_debug"("FAIL", "statement_prefix:sym<INIT>")
  debug_767:
    .return (rx522_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<INIT>"  :subid("87_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P526 = self."!PREFIX__!subrule"("blorst", "INIT")
    new $P527, "ResizablePMCArray"
    push $P527, $P526
    .return ($P527)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<try>"  :subid("88_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx529_tgt
    .local int rx529_pos
    .local int rx529_off
    .local int rx529_eos
    .local int rx529_rep
    .local pmc rx529_cur
    .local pmc rx529_debug
    (rx529_cur, rx529_pos, rx529_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx529_cur
    .local pmc match
    .lex "$/", match
    length rx529_eos, rx529_tgt
    gt rx529_pos, rx529_eos, rx529_done
    set rx529_off, 0
    lt rx529_pos, 2, rx529_start
    sub rx529_off, rx529_pos, 1
    substr rx529_tgt, rx529_tgt, rx529_off
  rx529_start:
    eq $I10, 1, rx529_restart
    if_null rx529_debug, debug_768
    rx529_cur."!cursor_debug"("START", "statement_prefix:sym<try>")
  debug_768:
    $I10 = self.'from'()
    ne $I10, -1, rxscan530_done
    goto rxscan530_scan
  rxscan530_loop:
    (rx529_pos) = rx529_cur."from"()
    inc rx529_pos
    rx529_cur."!cursor_from"(rx529_pos)
    ge rx529_pos, rx529_eos, rxscan530_done
  rxscan530_scan:
    set_addr $I10, rxscan530_loop
    rx529_cur."!mark_push"(0, rx529_pos, $I10)
  rxscan530_done:
.annotate 'line', 246
  # rx subcapture "sym"
    set_addr $I10, rxcap_531_fail
    rx529_cur."!mark_push"(0, rx529_pos, $I10)
  # rx literal  "try"
    add $I11, rx529_pos, 3
    gt $I11, rx529_eos, rx529_fail
    sub $I11, rx529_pos, rx529_off
    substr $S10, rx529_tgt, $I11, 3
    ne $S10, "try", rx529_fail
    add rx529_pos, 3
    set_addr $I10, rxcap_531_fail
    ($I12, $I11) = rx529_cur."!mark_peek"($I10)
    rx529_cur."!cursor_pos"($I11)
    ($P10) = rx529_cur."!cursor_start"()
    $P10."!cursor_pass"(rx529_pos, "")
    rx529_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_531_done
  rxcap_531_fail:
    goto rx529_fail
  rxcap_531_done:
.annotate 'line', 247
  # rx subrule "blorst" subtype=capture negate=
    rx529_cur."!cursor_pos"(rx529_pos)
    $P10 = rx529_cur."blorst"()
    unless $P10, rx529_fail
    rx529_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx529_pos = $P10."pos"()
.annotate 'line', 245
  # rx pass
    rx529_cur."!cursor_pass"(rx529_pos, "statement_prefix:sym<try>")
    if_null rx529_debug, debug_769
    rx529_cur."!cursor_debug"("PASS", "statement_prefix:sym<try>", " at pos=", rx529_pos)
  debug_769:
    .return (rx529_cur)
  rx529_restart:
.annotate 'line', 10
    if_null rx529_debug, debug_770
    rx529_cur."!cursor_debug"("NEXT", "statement_prefix:sym<try>")
  debug_770:
  rx529_fail:
    (rx529_rep, rx529_pos, $I10, $P10) = rx529_cur."!mark_fail"(0)
    lt rx529_pos, -1, rx529_done
    eq rx529_pos, -1, rx529_fail
    jump $I10
  rx529_done:
    rx529_cur."!cursor_fail"()
    if_null rx529_debug, debug_771
    rx529_cur."!cursor_debug"("FAIL", "statement_prefix:sym<try>")
  debug_771:
    .return (rx529_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<try>"  :subid("89_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P533 = self."!PREFIX__!subrule"("blorst", "try")
    new $P534, "ResizablePMCArray"
    push $P534, $P533
    .return ($P534)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blorst"  :subid("90_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx536_tgt
    .local int rx536_pos
    .local int rx536_off
    .local int rx536_eos
    .local int rx536_rep
    .local pmc rx536_cur
    .local pmc rx536_debug
    (rx536_cur, rx536_pos, rx536_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx536_cur
    .local pmc match
    .lex "$/", match
    length rx536_eos, rx536_tgt
    gt rx536_pos, rx536_eos, rx536_done
    set rx536_off, 0
    lt rx536_pos, 2, rx536_start
    sub rx536_off, rx536_pos, 1
    substr rx536_tgt, rx536_tgt, rx536_off
  rx536_start:
    eq $I10, 1, rx536_restart
    if_null rx536_debug, debug_772
    rx536_cur."!cursor_debug"("START", "blorst")
  debug_772:
    $I10 = self.'from'()
    ne $I10, -1, rxscan537_done
    goto rxscan537_scan
  rxscan537_loop:
    (rx536_pos) = rx536_cur."from"()
    inc rx536_pos
    rx536_cur."!cursor_from"(rx536_pos)
    ge rx536_pos, rx536_eos, rxscan537_done
  rxscan537_scan:
    set_addr $I10, rxscan537_loop
    rx536_cur."!mark_push"(0, rx536_pos, $I10)
  rxscan537_done:
.annotate 'line', 251
  # rx charclass s
    ge rx536_pos, rx536_eos, rx536_fail
    sub $I10, rx536_pos, rx536_off
    is_cclass $I11, 32, rx536_tgt, $I10
    unless $I11, rx536_fail
    inc rx536_pos
  # rx subrule "ws" subtype=method negate=
    rx536_cur."!cursor_pos"(rx536_pos)
    $P10 = rx536_cur."ws"()
    unless $P10, rx536_fail
    rx536_pos = $P10."pos"()
  alt538_0:
    set_addr $I10, alt538_1
    rx536_cur."!mark_push"(0, rx536_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx536_pos, rx536_off
    substr $S10, rx536_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx536_fail
  # rx subrule "block" subtype=capture negate=
    rx536_cur."!cursor_pos"(rx536_pos)
    $P10 = rx536_cur."block"()
    unless $P10, rx536_fail
    rx536_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx536_pos = $P10."pos"()
    goto alt538_end
  alt538_1:
  # rx subrule "statement" subtype=capture negate=
    rx536_cur."!cursor_pos"(rx536_pos)
    $P10 = rx536_cur."statement"()
    unless $P10, rx536_fail
    rx536_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx536_pos = $P10."pos"()
  alt538_end:
.annotate 'line', 250
  # rx pass
    rx536_cur."!cursor_pass"(rx536_pos, "blorst")
    if_null rx536_debug, debug_773
    rx536_cur."!cursor_debug"("PASS", "blorst", " at pos=", rx536_pos)
  debug_773:
    .return (rx536_cur)
  rx536_restart:
.annotate 'line', 10
    if_null rx536_debug, debug_774
    rx536_cur."!cursor_debug"("NEXT", "blorst")
  debug_774:
  rx536_fail:
    (rx536_rep, rx536_pos, $I10, $P10) = rx536_cur."!mark_fail"(0)
    lt rx536_pos, -1, rx536_done
    eq rx536_pos, -1, rx536_fail
    jump $I10
  rx536_done:
    rx536_cur."!cursor_fail"()
    if_null rx536_debug, debug_775
    rx536_cur."!cursor_debug"("FAIL", "blorst")
  debug_775:
    .return (rx536_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blorst"  :subid("91_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    new $P540, "ResizablePMCArray"
    push $P540, ""
    .return ($P540)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond"  :subid("92_1304456155.152")
    .param pmc param_542
.annotate 'line', 256
    .lex "self", param_542
    $P543 = param_542."!protoregex"("statement_mod_cond")
    .return ($P543)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond"  :subid("93_1304456155.152")
    .param pmc param_545
.annotate 'line', 256
    .lex "self", param_545
    $P546 = param_545."!PREFIX__!protoregex"("statement_mod_cond")
    .return ($P546)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<if>"  :subid("94_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx548_tgt
    .local int rx548_pos
    .local int rx548_off
    .local int rx548_eos
    .local int rx548_rep
    .local pmc rx548_cur
    .local pmc rx548_debug
    (rx548_cur, rx548_pos, rx548_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx548_cur
    .local pmc match
    .lex "$/", match
    length rx548_eos, rx548_tgt
    gt rx548_pos, rx548_eos, rx548_done
    set rx548_off, 0
    lt rx548_pos, 2, rx548_start
    sub rx548_off, rx548_pos, 1
    substr rx548_tgt, rx548_tgt, rx548_off
  rx548_start:
    eq $I10, 1, rx548_restart
    if_null rx548_debug, debug_776
    rx548_cur."!cursor_debug"("START", "statement_mod_cond:sym<if>")
  debug_776:
    $I10 = self.'from'()
    ne $I10, -1, rxscan549_done
    goto rxscan549_scan
  rxscan549_loop:
    (rx548_pos) = rx548_cur."from"()
    inc rx548_pos
    rx548_cur."!cursor_from"(rx548_pos)
    ge rx548_pos, rx548_eos, rxscan549_done
  rxscan549_scan:
    set_addr $I10, rxscan549_loop
    rx548_cur."!mark_push"(0, rx548_pos, $I10)
  rxscan549_done:
.annotate 'line', 258
  # rx subcapture "sym"
    set_addr $I10, rxcap_550_fail
    rx548_cur."!mark_push"(0, rx548_pos, $I10)
  # rx literal  "if"
    add $I11, rx548_pos, 2
    gt $I11, rx548_eos, rx548_fail
    sub $I11, rx548_pos, rx548_off
    substr $S10, rx548_tgt, $I11, 2
    ne $S10, "if", rx548_fail
    add rx548_pos, 2
    set_addr $I10, rxcap_550_fail
    ($I12, $I11) = rx548_cur."!mark_peek"($I10)
    rx548_cur."!cursor_pos"($I11)
    ($P10) = rx548_cur."!cursor_start"()
    $P10."!cursor_pass"(rx548_pos, "")
    rx548_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_550_done
  rxcap_550_fail:
    goto rx548_fail
  rxcap_550_done:
  # rx subrule "ws" subtype=method negate=
    rx548_cur."!cursor_pos"(rx548_pos)
    $P10 = rx548_cur."ws"()
    unless $P10, rx548_fail
    rx548_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx548_cur."!cursor_pos"(rx548_pos)
    $P10 = rx548_cur."EXPR"()
    unless $P10, rx548_fail
    rx548_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx548_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx548_cur."!cursor_pos"(rx548_pos)
    $P10 = rx548_cur."ws"()
    unless $P10, rx548_fail
    rx548_pos = $P10."pos"()
  # rx pass
    rx548_cur."!cursor_pass"(rx548_pos, "statement_mod_cond:sym<if>")
    if_null rx548_debug, debug_777
    rx548_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<if>", " at pos=", rx548_pos)
  debug_777:
    .return (rx548_cur)
  rx548_restart:
.annotate 'line', 10
    if_null rx548_debug, debug_778
    rx548_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<if>")
  debug_778:
  rx548_fail:
    (rx548_rep, rx548_pos, $I10, $P10) = rx548_cur."!mark_fail"(0)
    lt rx548_pos, -1, rx548_done
    eq rx548_pos, -1, rx548_fail
    jump $I10
  rx548_done:
    rx548_cur."!cursor_fail"()
    if_null rx548_debug, debug_779
    rx548_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<if>")
  debug_779:
    .return (rx548_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<if>"  :subid("95_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P554 = self."!PREFIX__!subrule"("ws", "if")
    new $P555, "ResizablePMCArray"
    push $P555, $P554
    .return ($P555)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<unless>"  :subid("96_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx557_tgt
    .local int rx557_pos
    .local int rx557_off
    .local int rx557_eos
    .local int rx557_rep
    .local pmc rx557_cur
    .local pmc rx557_debug
    (rx557_cur, rx557_pos, rx557_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx557_cur
    .local pmc match
    .lex "$/", match
    length rx557_eos, rx557_tgt
    gt rx557_pos, rx557_eos, rx557_done
    set rx557_off, 0
    lt rx557_pos, 2, rx557_start
    sub rx557_off, rx557_pos, 1
    substr rx557_tgt, rx557_tgt, rx557_off
  rx557_start:
    eq $I10, 1, rx557_restart
    if_null rx557_debug, debug_780
    rx557_cur."!cursor_debug"("START", "statement_mod_cond:sym<unless>")
  debug_780:
    $I10 = self.'from'()
    ne $I10, -1, rxscan558_done
    goto rxscan558_scan
  rxscan558_loop:
    (rx557_pos) = rx557_cur."from"()
    inc rx557_pos
    rx557_cur."!cursor_from"(rx557_pos)
    ge rx557_pos, rx557_eos, rxscan558_done
  rxscan558_scan:
    set_addr $I10, rxscan558_loop
    rx557_cur."!mark_push"(0, rx557_pos, $I10)
  rxscan558_done:
.annotate 'line', 259
  # rx subcapture "sym"
    set_addr $I10, rxcap_559_fail
    rx557_cur."!mark_push"(0, rx557_pos, $I10)
  # rx literal  "unless"
    add $I11, rx557_pos, 6
    gt $I11, rx557_eos, rx557_fail
    sub $I11, rx557_pos, rx557_off
    substr $S10, rx557_tgt, $I11, 6
    ne $S10, "unless", rx557_fail
    add rx557_pos, 6
    set_addr $I10, rxcap_559_fail
    ($I12, $I11) = rx557_cur."!mark_peek"($I10)
    rx557_cur."!cursor_pos"($I11)
    ($P10) = rx557_cur."!cursor_start"()
    $P10."!cursor_pass"(rx557_pos, "")
    rx557_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_559_done
  rxcap_559_fail:
    goto rx557_fail
  rxcap_559_done:
  # rx subrule "ws" subtype=method negate=
    rx557_cur."!cursor_pos"(rx557_pos)
    $P10 = rx557_cur."ws"()
    unless $P10, rx557_fail
    rx557_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx557_cur."!cursor_pos"(rx557_pos)
    $P10 = rx557_cur."EXPR"()
    unless $P10, rx557_fail
    rx557_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx557_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx557_cur."!cursor_pos"(rx557_pos)
    $P10 = rx557_cur."ws"()
    unless $P10, rx557_fail
    rx557_pos = $P10."pos"()
  # rx pass
    rx557_cur."!cursor_pass"(rx557_pos, "statement_mod_cond:sym<unless>")
    if_null rx557_debug, debug_781
    rx557_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<unless>", " at pos=", rx557_pos)
  debug_781:
    .return (rx557_cur)
  rx557_restart:
.annotate 'line', 10
    if_null rx557_debug, debug_782
    rx557_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<unless>")
  debug_782:
  rx557_fail:
    (rx557_rep, rx557_pos, $I10, $P10) = rx557_cur."!mark_fail"(0)
    lt rx557_pos, -1, rx557_done
    eq rx557_pos, -1, rx557_fail
    jump $I10
  rx557_done:
    rx557_cur."!cursor_fail"()
    if_null rx557_debug, debug_783
    rx557_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<unless>")
  debug_783:
    .return (rx557_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<unless>"  :subid("97_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P563 = self."!PREFIX__!subrule"("ws", "unless")
    new $P564, "ResizablePMCArray"
    push $P564, $P563
    .return ($P564)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop"  :subid("98_1304456155.152")
    .param pmc param_566
.annotate 'line', 261
    .lex "self", param_566
    $P567 = param_566."!protoregex"("statement_mod_loop")
    .return ($P567)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop"  :subid("99_1304456155.152")
    .param pmc param_569
.annotate 'line', 261
    .lex "self", param_569
    $P570 = param_569."!PREFIX__!protoregex"("statement_mod_loop")
    .return ($P570)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<while>"  :subid("100_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx572_tgt
    .local int rx572_pos
    .local int rx572_off
    .local int rx572_eos
    .local int rx572_rep
    .local pmc rx572_cur
    .local pmc rx572_debug
    (rx572_cur, rx572_pos, rx572_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx572_cur
    .local pmc match
    .lex "$/", match
    length rx572_eos, rx572_tgt
    gt rx572_pos, rx572_eos, rx572_done
    set rx572_off, 0
    lt rx572_pos, 2, rx572_start
    sub rx572_off, rx572_pos, 1
    substr rx572_tgt, rx572_tgt, rx572_off
  rx572_start:
    eq $I10, 1, rx572_restart
    if_null rx572_debug, debug_784
    rx572_cur."!cursor_debug"("START", "statement_mod_loop:sym<while>")
  debug_784:
    $I10 = self.'from'()
    ne $I10, -1, rxscan573_done
    goto rxscan573_scan
  rxscan573_loop:
    (rx572_pos) = rx572_cur."from"()
    inc rx572_pos
    rx572_cur."!cursor_from"(rx572_pos)
    ge rx572_pos, rx572_eos, rxscan573_done
  rxscan573_scan:
    set_addr $I10, rxscan573_loop
    rx572_cur."!mark_push"(0, rx572_pos, $I10)
  rxscan573_done:
.annotate 'line', 263
  # rx subcapture "sym"
    set_addr $I10, rxcap_574_fail
    rx572_cur."!mark_push"(0, rx572_pos, $I10)
  # rx literal  "while"
    add $I11, rx572_pos, 5
    gt $I11, rx572_eos, rx572_fail
    sub $I11, rx572_pos, rx572_off
    substr $S10, rx572_tgt, $I11, 5
    ne $S10, "while", rx572_fail
    add rx572_pos, 5
    set_addr $I10, rxcap_574_fail
    ($I12, $I11) = rx572_cur."!mark_peek"($I10)
    rx572_cur."!cursor_pos"($I11)
    ($P10) = rx572_cur."!cursor_start"()
    $P10."!cursor_pass"(rx572_pos, "")
    rx572_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_574_done
  rxcap_574_fail:
    goto rx572_fail
  rxcap_574_done:
  # rx subrule "ws" subtype=method negate=
    rx572_cur."!cursor_pos"(rx572_pos)
    $P10 = rx572_cur."ws"()
    unless $P10, rx572_fail
    rx572_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx572_cur."!cursor_pos"(rx572_pos)
    $P10 = rx572_cur."EXPR"()
    unless $P10, rx572_fail
    rx572_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx572_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx572_cur."!cursor_pos"(rx572_pos)
    $P10 = rx572_cur."ws"()
    unless $P10, rx572_fail
    rx572_pos = $P10."pos"()
  # rx pass
    rx572_cur."!cursor_pass"(rx572_pos, "statement_mod_loop:sym<while>")
    if_null rx572_debug, debug_785
    rx572_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<while>", " at pos=", rx572_pos)
  debug_785:
    .return (rx572_cur)
  rx572_restart:
.annotate 'line', 10
    if_null rx572_debug, debug_786
    rx572_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<while>")
  debug_786:
  rx572_fail:
    (rx572_rep, rx572_pos, $I10, $P10) = rx572_cur."!mark_fail"(0)
    lt rx572_pos, -1, rx572_done
    eq rx572_pos, -1, rx572_fail
    jump $I10
  rx572_done:
    rx572_cur."!cursor_fail"()
    if_null rx572_debug, debug_787
    rx572_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<while>")
  debug_787:
    .return (rx572_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<while>"  :subid("101_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P578 = self."!PREFIX__!subrule"("ws", "while")
    new $P579, "ResizablePMCArray"
    push $P579, $P578
    .return ($P579)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<until>"  :subid("102_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx581_tgt
    .local int rx581_pos
    .local int rx581_off
    .local int rx581_eos
    .local int rx581_rep
    .local pmc rx581_cur
    .local pmc rx581_debug
    (rx581_cur, rx581_pos, rx581_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx581_cur
    .local pmc match
    .lex "$/", match
    length rx581_eos, rx581_tgt
    gt rx581_pos, rx581_eos, rx581_done
    set rx581_off, 0
    lt rx581_pos, 2, rx581_start
    sub rx581_off, rx581_pos, 1
    substr rx581_tgt, rx581_tgt, rx581_off
  rx581_start:
    eq $I10, 1, rx581_restart
    if_null rx581_debug, debug_788
    rx581_cur."!cursor_debug"("START", "statement_mod_loop:sym<until>")
  debug_788:
    $I10 = self.'from'()
    ne $I10, -1, rxscan582_done
    goto rxscan582_scan
  rxscan582_loop:
    (rx581_pos) = rx581_cur."from"()
    inc rx581_pos
    rx581_cur."!cursor_from"(rx581_pos)
    ge rx581_pos, rx581_eos, rxscan582_done
  rxscan582_scan:
    set_addr $I10, rxscan582_loop
    rx581_cur."!mark_push"(0, rx581_pos, $I10)
  rxscan582_done:
.annotate 'line', 264
  # rx subcapture "sym"
    set_addr $I10, rxcap_583_fail
    rx581_cur."!mark_push"(0, rx581_pos, $I10)
  # rx literal  "until"
    add $I11, rx581_pos, 5
    gt $I11, rx581_eos, rx581_fail
    sub $I11, rx581_pos, rx581_off
    substr $S10, rx581_tgt, $I11, 5
    ne $S10, "until", rx581_fail
    add rx581_pos, 5
    set_addr $I10, rxcap_583_fail
    ($I12, $I11) = rx581_cur."!mark_peek"($I10)
    rx581_cur."!cursor_pos"($I11)
    ($P10) = rx581_cur."!cursor_start"()
    $P10."!cursor_pass"(rx581_pos, "")
    rx581_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_583_done
  rxcap_583_fail:
    goto rx581_fail
  rxcap_583_done:
  # rx subrule "ws" subtype=method negate=
    rx581_cur."!cursor_pos"(rx581_pos)
    $P10 = rx581_cur."ws"()
    unless $P10, rx581_fail
    rx581_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx581_cur."!cursor_pos"(rx581_pos)
    $P10 = rx581_cur."EXPR"()
    unless $P10, rx581_fail
    rx581_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx581_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx581_cur."!cursor_pos"(rx581_pos)
    $P10 = rx581_cur."ws"()
    unless $P10, rx581_fail
    rx581_pos = $P10."pos"()
  # rx pass
    rx581_cur."!cursor_pass"(rx581_pos, "statement_mod_loop:sym<until>")
    if_null rx581_debug, debug_789
    rx581_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<until>", " at pos=", rx581_pos)
  debug_789:
    .return (rx581_cur)
  rx581_restart:
.annotate 'line', 10
    if_null rx581_debug, debug_790
    rx581_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<until>")
  debug_790:
  rx581_fail:
    (rx581_rep, rx581_pos, $I10, $P10) = rx581_cur."!mark_fail"(0)
    lt rx581_pos, -1, rx581_done
    eq rx581_pos, -1, rx581_fail
    jump $I10
  rx581_done:
    rx581_cur."!cursor_fail"()
    if_null rx581_debug, debug_791
    rx581_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<until>")
  debug_791:
    .return (rx581_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<until>"  :subid("103_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P587 = self."!PREFIX__!subrule"("ws", "until")
    new $P588, "ResizablePMCArray"
    push $P588, $P587
    .return ($P588)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<for>"  :subid("104_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx590_tgt
    .local int rx590_pos
    .local int rx590_off
    .local int rx590_eos
    .local int rx590_rep
    .local pmc rx590_cur
    .local pmc rx590_debug
    (rx590_cur, rx590_pos, rx590_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx590_cur
    .local pmc match
    .lex "$/", match
    length rx590_eos, rx590_tgt
    gt rx590_pos, rx590_eos, rx590_done
    set rx590_off, 0
    lt rx590_pos, 2, rx590_start
    sub rx590_off, rx590_pos, 1
    substr rx590_tgt, rx590_tgt, rx590_off
  rx590_start:
    eq $I10, 1, rx590_restart
    if_null rx590_debug, debug_792
    rx590_cur."!cursor_debug"("START", "statement_mod_loop:sym<for>")
  debug_792:
    $I10 = self.'from'()
    ne $I10, -1, rxscan591_done
    goto rxscan591_scan
  rxscan591_loop:
    (rx590_pos) = rx590_cur."from"()
    inc rx590_pos
    rx590_cur."!cursor_from"(rx590_pos)
    ge rx590_pos, rx590_eos, rxscan591_done
  rxscan591_scan:
    set_addr $I10, rxscan591_loop
    rx590_cur."!mark_push"(0, rx590_pos, $I10)
  rxscan591_done:
.annotate 'line', 265
  # rx subcapture "sym"
    set_addr $I10, rxcap_592_fail
    rx590_cur."!mark_push"(0, rx590_pos, $I10)
  # rx literal  "for"
    add $I11, rx590_pos, 3
    gt $I11, rx590_eos, rx590_fail
    sub $I11, rx590_pos, rx590_off
    substr $S10, rx590_tgt, $I11, 3
    ne $S10, "for", rx590_fail
    add rx590_pos, 3
    set_addr $I10, rxcap_592_fail
    ($I12, $I11) = rx590_cur."!mark_peek"($I10)
    rx590_cur."!cursor_pos"($I11)
    ($P10) = rx590_cur."!cursor_start"()
    $P10."!cursor_pass"(rx590_pos, "")
    rx590_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_592_done
  rxcap_592_fail:
    goto rx590_fail
  rxcap_592_done:
  # rx subrule "ws" subtype=method negate=
    rx590_cur."!cursor_pos"(rx590_pos)
    $P10 = rx590_cur."ws"()
    unless $P10, rx590_fail
    rx590_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx590_cur."!cursor_pos"(rx590_pos)
    $P10 = rx590_cur."EXPR"()
    unless $P10, rx590_fail
    rx590_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx590_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx590_cur."!cursor_pos"(rx590_pos)
    $P10 = rx590_cur."ws"()
    unless $P10, rx590_fail
    rx590_pos = $P10."pos"()
  # rx pass
    rx590_cur."!cursor_pass"(rx590_pos, "statement_mod_loop:sym<for>")
    if_null rx590_debug, debug_793
    rx590_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<for>", " at pos=", rx590_pos)
  debug_793:
    .return (rx590_cur)
  rx590_restart:
.annotate 'line', 10
    if_null rx590_debug, debug_794
    rx590_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<for>")
  debug_794:
  rx590_fail:
    (rx590_rep, rx590_pos, $I10, $P10) = rx590_cur."!mark_fail"(0)
    lt rx590_pos, -1, rx590_done
    eq rx590_pos, -1, rx590_fail
    jump $I10
  rx590_done:
    rx590_cur."!cursor_fail"()
    if_null rx590_debug, debug_795
    rx590_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<for>")
  debug_795:
    .return (rx590_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<for>"  :subid("105_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P596 = self."!PREFIX__!subrule"("ws", "for")
    new $P597, "ResizablePMCArray"
    push $P597, $P596
    .return ($P597)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<fatarrow>"  :subid("106_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx599_tgt
    .local int rx599_pos
    .local int rx599_off
    .local int rx599_eos
    .local int rx599_rep
    .local pmc rx599_cur
    .local pmc rx599_debug
    (rx599_cur, rx599_pos, rx599_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx599_cur
    .local pmc match
    .lex "$/", match
    length rx599_eos, rx599_tgt
    gt rx599_pos, rx599_eos, rx599_done
    set rx599_off, 0
    lt rx599_pos, 2, rx599_start
    sub rx599_off, rx599_pos, 1
    substr rx599_tgt, rx599_tgt, rx599_off
  rx599_start:
    eq $I10, 1, rx599_restart
    if_null rx599_debug, debug_796
    rx599_cur."!cursor_debug"("START", "term:sym<fatarrow>")
  debug_796:
    $I10 = self.'from'()
    ne $I10, -1, rxscan600_done
    goto rxscan600_scan
  rxscan600_loop:
    (rx599_pos) = rx599_cur."from"()
    inc rx599_pos
    rx599_cur."!cursor_from"(rx599_pos)
    ge rx599_pos, rx599_eos, rxscan600_done
  rxscan600_scan:
    set_addr $I10, rxscan600_loop
    rx599_cur."!mark_push"(0, rx599_pos, $I10)
  rxscan600_done:
.annotate 'line', 269
  # rx subrule "fatarrow" subtype=capture negate=
    rx599_cur."!cursor_pos"(rx599_pos)
    $P10 = rx599_cur."fatarrow"()
    unless $P10, rx599_fail
    rx599_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("fatarrow")
    rx599_pos = $P10."pos"()
  # rx pass
    rx599_cur."!cursor_pass"(rx599_pos, "term:sym<fatarrow>")
    if_null rx599_debug, debug_797
    rx599_cur."!cursor_debug"("PASS", "term:sym<fatarrow>", " at pos=", rx599_pos)
  debug_797:
    .return (rx599_cur)
  rx599_restart:
.annotate 'line', 10
    if_null rx599_debug, debug_798
    rx599_cur."!cursor_debug"("NEXT", "term:sym<fatarrow>")
  debug_798:
  rx599_fail:
    (rx599_rep, rx599_pos, $I10, $P10) = rx599_cur."!mark_fail"(0)
    lt rx599_pos, -1, rx599_done
    eq rx599_pos, -1, rx599_fail
    jump $I10
  rx599_done:
    rx599_cur."!cursor_fail"()
    if_null rx599_debug, debug_799
    rx599_cur."!cursor_debug"("FAIL", "term:sym<fatarrow>")
  debug_799:
    .return (rx599_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<fatarrow>"  :subid("107_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P602 = self."!PREFIX__!subrule"("fatarrow", "")
    new $P603, "ResizablePMCArray"
    push $P603, $P602
    .return ($P603)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<colonpair>"  :subid("108_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx605_tgt
    .local int rx605_pos
    .local int rx605_off
    .local int rx605_eos
    .local int rx605_rep
    .local pmc rx605_cur
    .local pmc rx605_debug
    (rx605_cur, rx605_pos, rx605_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx605_cur
    .local pmc match
    .lex "$/", match
    length rx605_eos, rx605_tgt
    gt rx605_pos, rx605_eos, rx605_done
    set rx605_off, 0
    lt rx605_pos, 2, rx605_start
    sub rx605_off, rx605_pos, 1
    substr rx605_tgt, rx605_tgt, rx605_off
  rx605_start:
    eq $I10, 1, rx605_restart
    if_null rx605_debug, debug_800
    rx605_cur."!cursor_debug"("START", "term:sym<colonpair>")
  debug_800:
    $I10 = self.'from'()
    ne $I10, -1, rxscan606_done
    goto rxscan606_scan
  rxscan606_loop:
    (rx605_pos) = rx605_cur."from"()
    inc rx605_pos
    rx605_cur."!cursor_from"(rx605_pos)
    ge rx605_pos, rx605_eos, rxscan606_done
  rxscan606_scan:
    set_addr $I10, rxscan606_loop
    rx605_cur."!mark_push"(0, rx605_pos, $I10)
  rxscan606_done:
.annotate 'line', 270
  # rx subrule "colonpair" subtype=capture negate=
    rx605_cur."!cursor_pos"(rx605_pos)
    $P10 = rx605_cur."colonpair"()
    unless $P10, rx605_fail
    rx605_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("colonpair")
    rx605_pos = $P10."pos"()
  # rx pass
    rx605_cur."!cursor_pass"(rx605_pos, "term:sym<colonpair>")
    if_null rx605_debug, debug_801
    rx605_cur."!cursor_debug"("PASS", "term:sym<colonpair>", " at pos=", rx605_pos)
  debug_801:
    .return (rx605_cur)
  rx605_restart:
.annotate 'line', 10
    if_null rx605_debug, debug_802
    rx605_cur."!cursor_debug"("NEXT", "term:sym<colonpair>")
  debug_802:
  rx605_fail:
    (rx605_rep, rx605_pos, $I10, $P10) = rx605_cur."!mark_fail"(0)
    lt rx605_pos, -1, rx605_done
    eq rx605_pos, -1, rx605_fail
    jump $I10
  rx605_done:
    rx605_cur."!cursor_fail"()
    if_null rx605_debug, debug_803
    rx605_cur."!cursor_debug"("FAIL", "term:sym<colonpair>")
  debug_803:
    .return (rx605_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<colonpair>"  :subid("109_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P608 = self."!PREFIX__!subrule"("colonpair", "")
    new $P609, "ResizablePMCArray"
    push $P609, $P608
    .return ($P609)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<variable>"  :subid("110_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx611_tgt
    .local int rx611_pos
    .local int rx611_off
    .local int rx611_eos
    .local int rx611_rep
    .local pmc rx611_cur
    .local pmc rx611_debug
    (rx611_cur, rx611_pos, rx611_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx611_cur
    .local pmc match
    .lex "$/", match
    length rx611_eos, rx611_tgt
    gt rx611_pos, rx611_eos, rx611_done
    set rx611_off, 0
    lt rx611_pos, 2, rx611_start
    sub rx611_off, rx611_pos, 1
    substr rx611_tgt, rx611_tgt, rx611_off
  rx611_start:
    eq $I10, 1, rx611_restart
    if_null rx611_debug, debug_804
    rx611_cur."!cursor_debug"("START", "term:sym<variable>")
  debug_804:
    $I10 = self.'from'()
    ne $I10, -1, rxscan612_done
    goto rxscan612_scan
  rxscan612_loop:
    (rx611_pos) = rx611_cur."from"()
    inc rx611_pos
    rx611_cur."!cursor_from"(rx611_pos)
    ge rx611_pos, rx611_eos, rxscan612_done
  rxscan612_scan:
    set_addr $I10, rxscan612_loop
    rx611_cur."!mark_push"(0, rx611_pos, $I10)
  rxscan612_done:
.annotate 'line', 271
  # rx subrule "variable" subtype=capture negate=
    rx611_cur."!cursor_pos"(rx611_pos)
    $P10 = rx611_cur."variable"()
    unless $P10, rx611_fail
    rx611_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx611_pos = $P10."pos"()
  # rx pass
    rx611_cur."!cursor_pass"(rx611_pos, "term:sym<variable>")
    if_null rx611_debug, debug_805
    rx611_cur."!cursor_debug"("PASS", "term:sym<variable>", " at pos=", rx611_pos)
  debug_805:
    .return (rx611_cur)
  rx611_restart:
.annotate 'line', 10
    if_null rx611_debug, debug_806
    rx611_cur."!cursor_debug"("NEXT", "term:sym<variable>")
  debug_806:
  rx611_fail:
    (rx611_rep, rx611_pos, $I10, $P10) = rx611_cur."!mark_fail"(0)
    lt rx611_pos, -1, rx611_done
    eq rx611_pos, -1, rx611_fail
    jump $I10
  rx611_done:
    rx611_cur."!cursor_fail"()
    if_null rx611_debug, debug_807
    rx611_cur."!cursor_debug"("FAIL", "term:sym<variable>")
  debug_807:
    .return (rx611_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<variable>"  :subid("111_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P614 = self."!PREFIX__!subrule"("variable", "")
    new $P615, "ResizablePMCArray"
    push $P615, $P614
    .return ($P615)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<package_declarator>"  :subid("112_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx617_tgt
    .local int rx617_pos
    .local int rx617_off
    .local int rx617_eos
    .local int rx617_rep
    .local pmc rx617_cur
    .local pmc rx617_debug
    (rx617_cur, rx617_pos, rx617_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx617_cur
    .local pmc match
    .lex "$/", match
    length rx617_eos, rx617_tgt
    gt rx617_pos, rx617_eos, rx617_done
    set rx617_off, 0
    lt rx617_pos, 2, rx617_start
    sub rx617_off, rx617_pos, 1
    substr rx617_tgt, rx617_tgt, rx617_off
  rx617_start:
    eq $I10, 1, rx617_restart
    if_null rx617_debug, debug_808
    rx617_cur."!cursor_debug"("START", "term:sym<package_declarator>")
  debug_808:
    $I10 = self.'from'()
    ne $I10, -1, rxscan618_done
    goto rxscan618_scan
  rxscan618_loop:
    (rx617_pos) = rx617_cur."from"()
    inc rx617_pos
    rx617_cur."!cursor_from"(rx617_pos)
    ge rx617_pos, rx617_eos, rxscan618_done
  rxscan618_scan:
    set_addr $I10, rxscan618_loop
    rx617_cur."!mark_push"(0, rx617_pos, $I10)
  rxscan618_done:
.annotate 'line', 272
  # rx subrule "package_declarator" subtype=capture negate=
    rx617_cur."!cursor_pos"(rx617_pos)
    $P10 = rx617_cur."package_declarator"()
    unless $P10, rx617_fail
    rx617_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx617_pos = $P10."pos"()
  # rx pass
    rx617_cur."!cursor_pass"(rx617_pos, "term:sym<package_declarator>")
    if_null rx617_debug, debug_809
    rx617_cur."!cursor_debug"("PASS", "term:sym<package_declarator>", " at pos=", rx617_pos)
  debug_809:
    .return (rx617_cur)
  rx617_restart:
.annotate 'line', 10
    if_null rx617_debug, debug_810
    rx617_cur."!cursor_debug"("NEXT", "term:sym<package_declarator>")
  debug_810:
  rx617_fail:
    (rx617_rep, rx617_pos, $I10, $P10) = rx617_cur."!mark_fail"(0)
    lt rx617_pos, -1, rx617_done
    eq rx617_pos, -1, rx617_fail
    jump $I10
  rx617_done:
    rx617_cur."!cursor_fail"()
    if_null rx617_debug, debug_811
    rx617_cur."!cursor_debug"("FAIL", "term:sym<package_declarator>")
  debug_811:
    .return (rx617_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<package_declarator>"  :subid("113_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P620 = self."!PREFIX__!subrule"("package_declarator", "")
    new $P621, "ResizablePMCArray"
    push $P621, $P620
    .return ($P621)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<scope_declarator>"  :subid("114_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx623_tgt
    .local int rx623_pos
    .local int rx623_off
    .local int rx623_eos
    .local int rx623_rep
    .local pmc rx623_cur
    .local pmc rx623_debug
    (rx623_cur, rx623_pos, rx623_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx623_cur
    .local pmc match
    .lex "$/", match
    length rx623_eos, rx623_tgt
    gt rx623_pos, rx623_eos, rx623_done
    set rx623_off, 0
    lt rx623_pos, 2, rx623_start
    sub rx623_off, rx623_pos, 1
    substr rx623_tgt, rx623_tgt, rx623_off
  rx623_start:
    eq $I10, 1, rx623_restart
    if_null rx623_debug, debug_812
    rx623_cur."!cursor_debug"("START", "term:sym<scope_declarator>")
  debug_812:
    $I10 = self.'from'()
    ne $I10, -1, rxscan624_done
    goto rxscan624_scan
  rxscan624_loop:
    (rx623_pos) = rx623_cur."from"()
    inc rx623_pos
    rx623_cur."!cursor_from"(rx623_pos)
    ge rx623_pos, rx623_eos, rxscan624_done
  rxscan624_scan:
    set_addr $I10, rxscan624_loop
    rx623_cur."!mark_push"(0, rx623_pos, $I10)
  rxscan624_done:
.annotate 'line', 273
  # rx subrule "scope_declarator" subtype=capture negate=
    rx623_cur."!cursor_pos"(rx623_pos)
    $P10 = rx623_cur."scope_declarator"()
    unless $P10, rx623_fail
    rx623_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scope_declarator")
    rx623_pos = $P10."pos"()
  # rx pass
    rx623_cur."!cursor_pass"(rx623_pos, "term:sym<scope_declarator>")
    if_null rx623_debug, debug_813
    rx623_cur."!cursor_debug"("PASS", "term:sym<scope_declarator>", " at pos=", rx623_pos)
  debug_813:
    .return (rx623_cur)
  rx623_restart:
.annotate 'line', 10
    if_null rx623_debug, debug_814
    rx623_cur."!cursor_debug"("NEXT", "term:sym<scope_declarator>")
  debug_814:
  rx623_fail:
    (rx623_rep, rx623_pos, $I10, $P10) = rx623_cur."!mark_fail"(0)
    lt rx623_pos, -1, rx623_done
    eq rx623_pos, -1, rx623_fail
    jump $I10
  rx623_done:
    rx623_cur."!cursor_fail"()
    if_null rx623_debug, debug_815
    rx623_cur."!cursor_debug"("FAIL", "term:sym<scope_declarator>")
  debug_815:
    .return (rx623_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<scope_declarator>"  :subid("115_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P626 = self."!PREFIX__!subrule"("scope_declarator", "")
    new $P627, "ResizablePMCArray"
    push $P627, $P626
    .return ($P627)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<routine_declarator>"  :subid("116_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx629_tgt
    .local int rx629_pos
    .local int rx629_off
    .local int rx629_eos
    .local int rx629_rep
    .local pmc rx629_cur
    .local pmc rx629_debug
    (rx629_cur, rx629_pos, rx629_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx629_cur
    .local pmc match
    .lex "$/", match
    length rx629_eos, rx629_tgt
    gt rx629_pos, rx629_eos, rx629_done
    set rx629_off, 0
    lt rx629_pos, 2, rx629_start
    sub rx629_off, rx629_pos, 1
    substr rx629_tgt, rx629_tgt, rx629_off
  rx629_start:
    eq $I10, 1, rx629_restart
    if_null rx629_debug, debug_816
    rx629_cur."!cursor_debug"("START", "term:sym<routine_declarator>")
  debug_816:
    $I10 = self.'from'()
    ne $I10, -1, rxscan630_done
    goto rxscan630_scan
  rxscan630_loop:
    (rx629_pos) = rx629_cur."from"()
    inc rx629_pos
    rx629_cur."!cursor_from"(rx629_pos)
    ge rx629_pos, rx629_eos, rxscan630_done
  rxscan630_scan:
    set_addr $I10, rxscan630_loop
    rx629_cur."!mark_push"(0, rx629_pos, $I10)
  rxscan630_done:
.annotate 'line', 274
  # rx subrule "routine_declarator" subtype=capture negate=
    rx629_cur."!cursor_pos"(rx629_pos)
    $P10 = rx629_cur."routine_declarator"()
    unless $P10, rx629_fail
    rx629_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx629_pos = $P10."pos"()
  # rx pass
    rx629_cur."!cursor_pass"(rx629_pos, "term:sym<routine_declarator>")
    if_null rx629_debug, debug_817
    rx629_cur."!cursor_debug"("PASS", "term:sym<routine_declarator>", " at pos=", rx629_pos)
  debug_817:
    .return (rx629_cur)
  rx629_restart:
.annotate 'line', 10
    if_null rx629_debug, debug_818
    rx629_cur."!cursor_debug"("NEXT", "term:sym<routine_declarator>")
  debug_818:
  rx629_fail:
    (rx629_rep, rx629_pos, $I10, $P10) = rx629_cur."!mark_fail"(0)
    lt rx629_pos, -1, rx629_done
    eq rx629_pos, -1, rx629_fail
    jump $I10
  rx629_done:
    rx629_cur."!cursor_fail"()
    if_null rx629_debug, debug_819
    rx629_cur."!cursor_debug"("FAIL", "term:sym<routine_declarator>")
  debug_819:
    .return (rx629_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<routine_declarator>"  :subid("117_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P632 = self."!PREFIX__!subrule"("routine_declarator", "")
    new $P633, "ResizablePMCArray"
    push $P633, $P632
    .return ($P633)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<multi_declarator>"  :subid("118_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .const 'Sub' $P643 = "120_1304456155.152" 
    capture_lex $P643
    .const 'Sub' $P638 = "119_1304456155.152" 
    capture_lex $P638
    .local string rx635_tgt
    .local int rx635_pos
    .local int rx635_off
    .local int rx635_eos
    .local int rx635_rep
    .local pmc rx635_cur
    .local pmc rx635_debug
    (rx635_cur, rx635_pos, rx635_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx635_cur
    .local pmc match
    .lex "$/", match
    length rx635_eos, rx635_tgt
    gt rx635_pos, rx635_eos, rx635_done
    set rx635_off, 0
    lt rx635_pos, 2, rx635_start
    sub rx635_off, rx635_pos, 1
    substr rx635_tgt, rx635_tgt, rx635_off
  rx635_start:
    eq $I10, 1, rx635_restart
    if_null rx635_debug, debug_820
    rx635_cur."!cursor_debug"("START", "term:sym<multi_declarator>")
  debug_820:
    $I10 = self.'from'()
    ne $I10, -1, rxscan636_done
    goto rxscan636_scan
  rxscan636_loop:
    (rx635_pos) = rx635_cur."from"()
    inc rx635_pos
    rx635_cur."!cursor_from"(rx635_pos)
    ge rx635_pos, rx635_eos, rxscan636_done
  rxscan636_scan:
    set_addr $I10, rxscan636_loop
    rx635_cur."!mark_push"(0, rx635_pos, $I10)
  rxscan636_done:
.annotate 'line', 276
  # rx subrule "before" subtype=zerowidth negate=
    rx635_cur."!cursor_pos"(rx635_pos)
    .const 'Sub' $P638 = "119_1304456155.152" 
    capture_lex $P638
    $P10 = rx635_cur."before"($P638)
    unless $P10, rx635_fail
.annotate 'line', 277
  # rx subrule "before" subtype=zerowidth negate=1
    rx635_cur."!cursor_pos"(rx635_pos)
    .const 'Sub' $P643 = "120_1304456155.152" 
    capture_lex $P643
    $P10 = rx635_cur."before"($P643)
    if $P10, rx635_fail
.annotate 'line', 278
  # rx subrule "multi_declarator" subtype=capture negate=
    rx635_cur."!cursor_pos"(rx635_pos)
    $P10 = rx635_cur."multi_declarator"()
    unless $P10, rx635_fail
    rx635_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx635_pos = $P10."pos"()
.annotate 'line', 275
  # rx pass
    rx635_cur."!cursor_pass"(rx635_pos, "term:sym<multi_declarator>")
    if_null rx635_debug, debug_829
    rx635_cur."!cursor_debug"("PASS", "term:sym<multi_declarator>", " at pos=", rx635_pos)
  debug_829:
    .return (rx635_cur)
  rx635_restart:
.annotate 'line', 10
    if_null rx635_debug, debug_830
    rx635_cur."!cursor_debug"("NEXT", "term:sym<multi_declarator>")
  debug_830:
  rx635_fail:
    (rx635_rep, rx635_pos, $I10, $P10) = rx635_cur."!mark_fail"(0)
    lt rx635_pos, -1, rx635_done
    eq rx635_pos, -1, rx635_fail
    jump $I10
  rx635_done:
    rx635_cur."!cursor_fail"()
    if_null rx635_debug, debug_831
    rx635_cur."!cursor_debug"("FAIL", "term:sym<multi_declarator>")
  debug_831:
    .return (rx635_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block637"  :anon :subid("119_1304456155.152") :method :outer("118_1304456155.152")
.annotate 'line', 276
    .local string rx639_tgt
    .local int rx639_pos
    .local int rx639_off
    .local int rx639_eos
    .local int rx639_rep
    .local pmc rx639_cur
    .local pmc rx639_debug
    (rx639_cur, rx639_pos, rx639_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx639_cur
    .local pmc match
    .lex "$/", match
    length rx639_eos, rx639_tgt
    gt rx639_pos, rx639_eos, rx639_done
    set rx639_off, 0
    lt rx639_pos, 2, rx639_start
    sub rx639_off, rx639_pos, 1
    substr rx639_tgt, rx639_tgt, rx639_off
  rx639_start:
    eq $I10, 1, rx639_restart
    if_null rx639_debug, debug_821
    rx639_cur."!cursor_debug"("START", "")
  debug_821:
    $I10 = self.'from'()
    ne $I10, -1, rxscan640_done
    goto rxscan640_scan
  rxscan640_loop:
    (rx639_pos) = rx639_cur."from"()
    inc rx639_pos
    rx639_cur."!cursor_from"(rx639_pos)
    ge rx639_pos, rx639_eos, rxscan640_done
  rxscan640_scan:
    set_addr $I10, rxscan640_loop
    rx639_cur."!mark_push"(0, rx639_pos, $I10)
  rxscan640_done:
  alt641_0:
    set_addr $I10, alt641_1
    rx639_cur."!mark_push"(0, rx639_pos, $I10)
  # rx literal  "multi"
    add $I11, rx639_pos, 5
    gt $I11, rx639_eos, rx639_fail
    sub $I11, rx639_pos, rx639_off
    substr $S10, rx639_tgt, $I11, 5
    ne $S10, "multi", rx639_fail
    add rx639_pos, 5
    goto alt641_end
  alt641_1:
    set_addr $I10, alt641_2
    rx639_cur."!mark_push"(0, rx639_pos, $I10)
  # rx literal  "proto"
    add $I11, rx639_pos, 5
    gt $I11, rx639_eos, rx639_fail
    sub $I11, rx639_pos, rx639_off
    substr $S10, rx639_tgt, $I11, 5
    ne $S10, "proto", rx639_fail
    add rx639_pos, 5
    goto alt641_end
  alt641_2:
  # rx literal  "only"
    add $I11, rx639_pos, 4
    gt $I11, rx639_eos, rx639_fail
    sub $I11, rx639_pos, rx639_off
    substr $S10, rx639_tgt, $I11, 4
    ne $S10, "only", rx639_fail
    add rx639_pos, 4
  alt641_end:
  # rx pass
    rx639_cur."!cursor_pass"(rx639_pos, "")
    if_null rx639_debug, debug_822
    rx639_cur."!cursor_debug"("PASS", "", " at pos=", rx639_pos)
  debug_822:
    .return (rx639_cur)
  rx639_restart:
    if_null rx639_debug, debug_823
    rx639_cur."!cursor_debug"("NEXT", "")
  debug_823:
  rx639_fail:
    (rx639_rep, rx639_pos, $I10, $P10) = rx639_cur."!mark_fail"(0)
    lt rx639_pos, -1, rx639_done
    eq rx639_pos, -1, rx639_fail
    jump $I10
  rx639_done:
    rx639_cur."!cursor_fail"()
    if_null rx639_debug, debug_824
    rx639_cur."!cursor_debug"("FAIL", "")
  debug_824:
    .return (rx639_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block642"  :anon :subid("120_1304456155.152") :method :outer("118_1304456155.152")
.annotate 'line', 277
    .local string rx644_tgt
    .local int rx644_pos
    .local int rx644_off
    .local int rx644_eos
    .local int rx644_rep
    .local pmc rx644_cur
    .local pmc rx644_debug
    (rx644_cur, rx644_pos, rx644_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx644_cur
    .local pmc match
    .lex "$/", match
    length rx644_eos, rx644_tgt
    gt rx644_pos, rx644_eos, rx644_done
    set rx644_off, 0
    lt rx644_pos, 2, rx644_start
    sub rx644_off, rx644_pos, 1
    substr rx644_tgt, rx644_tgt, rx644_off
  rx644_start:
    eq $I10, 1, rx644_restart
    if_null rx644_debug, debug_825
    rx644_cur."!cursor_debug"("START", "")
  debug_825:
    $I10 = self.'from'()
    ne $I10, -1, rxscan645_done
    goto rxscan645_scan
  rxscan645_loop:
    (rx644_pos) = rx644_cur."from"()
    inc rx644_pos
    rx644_cur."!cursor_from"(rx644_pos)
    ge rx644_pos, rx644_eos, rxscan645_done
  rxscan645_scan:
    set_addr $I10, rxscan645_loop
    rx644_cur."!mark_push"(0, rx644_pos, $I10)
  rxscan645_done:
  # rx literal  "proto"
    add $I11, rx644_pos, 5
    gt $I11, rx644_eos, rx644_fail
    sub $I11, rx644_pos, rx644_off
    substr $S10, rx644_tgt, $I11, 5
    ne $S10, "proto", rx644_fail
    add rx644_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."ws"()
    unless $P10, rx644_fail
    rx644_pos = $P10."pos"()
  alt646_0:
    set_addr $I10, alt646_1
    rx644_cur."!mark_push"(0, rx644_pos, $I10)
  # rx literal  "regex"
    add $I11, rx644_pos, 5
    gt $I11, rx644_eos, rx644_fail
    sub $I11, rx644_pos, rx644_off
    substr $S10, rx644_tgt, $I11, 5
    ne $S10, "regex", rx644_fail
    add rx644_pos, 5
    goto alt646_end
  alt646_1:
    set_addr $I10, alt646_2
    rx644_cur."!mark_push"(0, rx644_pos, $I10)
  # rx literal  "token"
    add $I11, rx644_pos, 5
    gt $I11, rx644_eos, rx644_fail
    sub $I11, rx644_pos, rx644_off
    substr $S10, rx644_tgt, $I11, 5
    ne $S10, "token", rx644_fail
    add rx644_pos, 5
    goto alt646_end
  alt646_2:
  # rx literal  "rule"
    add $I11, rx644_pos, 4
    gt $I11, rx644_eos, rx644_fail
    sub $I11, rx644_pos, rx644_off
    substr $S10, rx644_tgt, $I11, 4
    ne $S10, "rule", rx644_fail
    add rx644_pos, 4
  alt646_end:
  # rx pass
    rx644_cur."!cursor_pass"(rx644_pos, "")
    if_null rx644_debug, debug_826
    rx644_cur."!cursor_debug"("PASS", "", " at pos=", rx644_pos)
  debug_826:
    .return (rx644_cur)
  rx644_restart:
    if_null rx644_debug, debug_827
    rx644_cur."!cursor_debug"("NEXT", "")
  debug_827:
  rx644_fail:
    (rx644_rep, rx644_pos, $I10, $P10) = rx644_cur."!mark_fail"(0)
    lt rx644_pos, -1, rx644_done
    eq rx644_pos, -1, rx644_fail
    jump $I10
  rx644_done:
    rx644_cur."!cursor_fail"()
    if_null rx644_debug, debug_828
    rx644_cur."!cursor_debug"("FAIL", "")
  debug_828:
    .return (rx644_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<multi_declarator>"  :subid("121_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    new $P648, "ResizablePMCArray"
    push $P648, ""
    .return ($P648)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<regex_declarator>"  :subid("122_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx650_tgt
    .local int rx650_pos
    .local int rx650_off
    .local int rx650_eos
    .local int rx650_rep
    .local pmc rx650_cur
    .local pmc rx650_debug
    (rx650_cur, rx650_pos, rx650_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx650_cur
    .local pmc match
    .lex "$/", match
    length rx650_eos, rx650_tgt
    gt rx650_pos, rx650_eos, rx650_done
    set rx650_off, 0
    lt rx650_pos, 2, rx650_start
    sub rx650_off, rx650_pos, 1
    substr rx650_tgt, rx650_tgt, rx650_off
  rx650_start:
    eq $I10, 1, rx650_restart
    if_null rx650_debug, debug_832
    rx650_cur."!cursor_debug"("START", "term:sym<regex_declarator>")
  debug_832:
    $I10 = self.'from'()
    ne $I10, -1, rxscan651_done
    goto rxscan651_scan
  rxscan651_loop:
    (rx650_pos) = rx650_cur."from"()
    inc rx650_pos
    rx650_cur."!cursor_from"(rx650_pos)
    ge rx650_pos, rx650_eos, rxscan651_done
  rxscan651_scan:
    set_addr $I10, rxscan651_loop
    rx650_cur."!mark_push"(0, rx650_pos, $I10)
  rxscan651_done:
.annotate 'line', 280
  # rx subrule "regex_declarator" subtype=capture negate=
    rx650_cur."!cursor_pos"(rx650_pos)
    $P10 = rx650_cur."regex_declarator"()
    unless $P10, rx650_fail
    rx650_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("regex_declarator")
    rx650_pos = $P10."pos"()
  # rx pass
    rx650_cur."!cursor_pass"(rx650_pos, "term:sym<regex_declarator>")
    if_null rx650_debug, debug_833
    rx650_cur."!cursor_debug"("PASS", "term:sym<regex_declarator>", " at pos=", rx650_pos)
  debug_833:
    .return (rx650_cur)
  rx650_restart:
.annotate 'line', 10
    if_null rx650_debug, debug_834
    rx650_cur."!cursor_debug"("NEXT", "term:sym<regex_declarator>")
  debug_834:
  rx650_fail:
    (rx650_rep, rx650_pos, $I10, $P10) = rx650_cur."!mark_fail"(0)
    lt rx650_pos, -1, rx650_done
    eq rx650_pos, -1, rx650_fail
    jump $I10
  rx650_done:
    rx650_cur."!cursor_fail"()
    if_null rx650_debug, debug_835
    rx650_cur."!cursor_debug"("FAIL", "term:sym<regex_declarator>")
  debug_835:
    .return (rx650_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<regex_declarator>"  :subid("123_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P653 = self."!PREFIX__!subrule"("regex_declarator", "")
    new $P654, "ResizablePMCArray"
    push $P654, $P653
    .return ($P654)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<statement_prefix>"  :subid("124_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx656_tgt
    .local int rx656_pos
    .local int rx656_off
    .local int rx656_eos
    .local int rx656_rep
    .local pmc rx656_cur
    .local pmc rx656_debug
    (rx656_cur, rx656_pos, rx656_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx656_cur
    .local pmc match
    .lex "$/", match
    length rx656_eos, rx656_tgt
    gt rx656_pos, rx656_eos, rx656_done
    set rx656_off, 0
    lt rx656_pos, 2, rx656_start
    sub rx656_off, rx656_pos, 1
    substr rx656_tgt, rx656_tgt, rx656_off
  rx656_start:
    eq $I10, 1, rx656_restart
    if_null rx656_debug, debug_836
    rx656_cur."!cursor_debug"("START", "term:sym<statement_prefix>")
  debug_836:
    $I10 = self.'from'()
    ne $I10, -1, rxscan657_done
    goto rxscan657_scan
  rxscan657_loop:
    (rx656_pos) = rx656_cur."from"()
    inc rx656_pos
    rx656_cur."!cursor_from"(rx656_pos)
    ge rx656_pos, rx656_eos, rxscan657_done
  rxscan657_scan:
    set_addr $I10, rxscan657_loop
    rx656_cur."!mark_push"(0, rx656_pos, $I10)
  rxscan657_done:
.annotate 'line', 281
  # rx subrule "statement_prefix" subtype=capture negate=
    rx656_cur."!cursor_pos"(rx656_pos)
    $P10 = rx656_cur."statement_prefix"()
    unless $P10, rx656_fail
    rx656_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_prefix")
    rx656_pos = $P10."pos"()
  # rx pass
    rx656_cur."!cursor_pass"(rx656_pos, "term:sym<statement_prefix>")
    if_null rx656_debug, debug_837
    rx656_cur."!cursor_debug"("PASS", "term:sym<statement_prefix>", " at pos=", rx656_pos)
  debug_837:
    .return (rx656_cur)
  rx656_restart:
.annotate 'line', 10
    if_null rx656_debug, debug_838
    rx656_cur."!cursor_debug"("NEXT", "term:sym<statement_prefix>")
  debug_838:
  rx656_fail:
    (rx656_rep, rx656_pos, $I10, $P10) = rx656_cur."!mark_fail"(0)
    lt rx656_pos, -1, rx656_done
    eq rx656_pos, -1, rx656_fail
    jump $I10
  rx656_done:
    rx656_cur."!cursor_fail"()
    if_null rx656_debug, debug_839
    rx656_cur."!cursor_debug"("FAIL", "term:sym<statement_prefix>")
  debug_839:
    .return (rx656_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<statement_prefix>"  :subid("125_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P659 = self."!PREFIX__!subrule"("statement_prefix", "")
    new $P660, "ResizablePMCArray"
    push $P660, $P659
    .return ($P660)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<lambda>"  :subid("126_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx662_tgt
    .local int rx662_pos
    .local int rx662_off
    .local int rx662_eos
    .local int rx662_rep
    .local pmc rx662_cur
    .local pmc rx662_debug
    (rx662_cur, rx662_pos, rx662_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx662_cur
    .local pmc match
    .lex "$/", match
    length rx662_eos, rx662_tgt
    gt rx662_pos, rx662_eos, rx662_done
    set rx662_off, 0
    lt rx662_pos, 2, rx662_start
    sub rx662_off, rx662_pos, 1
    substr rx662_tgt, rx662_tgt, rx662_off
  rx662_start:
    eq $I10, 1, rx662_restart
    if_null rx662_debug, debug_840
    rx662_cur."!cursor_debug"("START", "term:sym<lambda>")
  debug_840:
    $I10 = self.'from'()
    ne $I10, -1, rxscan663_done
    goto rxscan663_scan
  rxscan663_loop:
    (rx662_pos) = rx662_cur."from"()
    inc rx662_pos
    rx662_cur."!cursor_from"(rx662_pos)
    ge rx662_pos, rx662_eos, rxscan663_done
  rxscan663_scan:
    set_addr $I10, rxscan663_loop
    rx662_cur."!mark_push"(0, rx662_pos, $I10)
  rxscan663_done:
.annotate 'line', 282
  # rx subrule "lambda" subtype=zerowidth negate=
    rx662_cur."!cursor_pos"(rx662_pos)
    $P10 = rx662_cur."lambda"()
    unless $P10, rx662_fail
  # rx subrule "pblock" subtype=capture negate=
    rx662_cur."!cursor_pos"(rx662_pos)
    $P10 = rx662_cur."pblock"()
    unless $P10, rx662_fail
    rx662_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx662_pos = $P10."pos"()
  # rx pass
    rx662_cur."!cursor_pass"(rx662_pos, "term:sym<lambda>")
    if_null rx662_debug, debug_841
    rx662_cur."!cursor_debug"("PASS", "term:sym<lambda>", " at pos=", rx662_pos)
  debug_841:
    .return (rx662_cur)
  rx662_restart:
.annotate 'line', 10
    if_null rx662_debug, debug_842
    rx662_cur."!cursor_debug"("NEXT", "term:sym<lambda>")
  debug_842:
  rx662_fail:
    (rx662_rep, rx662_pos, $I10, $P10) = rx662_cur."!mark_fail"(0)
    lt rx662_pos, -1, rx662_done
    eq rx662_pos, -1, rx662_fail
    jump $I10
  rx662_done:
    rx662_cur."!cursor_fail"()
    if_null rx662_debug, debug_843
    rx662_cur."!cursor_debug"("FAIL", "term:sym<lambda>")
  debug_843:
    .return (rx662_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<lambda>"  :subid("127_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    new $P665, "ResizablePMCArray"
    push $P665, ""
    .return ($P665)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "fatarrow"  :subid("128_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx667_tgt
    .local int rx667_pos
    .local int rx667_off
    .local int rx667_eos
    .local int rx667_rep
    .local pmc rx667_cur
    .local pmc rx667_debug
    (rx667_cur, rx667_pos, rx667_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx667_cur
    .local pmc match
    .lex "$/", match
    length rx667_eos, rx667_tgt
    gt rx667_pos, rx667_eos, rx667_done
    set rx667_off, 0
    lt rx667_pos, 2, rx667_start
    sub rx667_off, rx667_pos, 1
    substr rx667_tgt, rx667_tgt, rx667_off
  rx667_start:
    eq $I10, 1, rx667_restart
    if_null rx667_debug, debug_844
    rx667_cur."!cursor_debug"("START", "fatarrow")
  debug_844:
    $I10 = self.'from'()
    ne $I10, -1, rxscan668_done
    goto rxscan668_scan
  rxscan668_loop:
    (rx667_pos) = rx667_cur."from"()
    inc rx667_pos
    rx667_cur."!cursor_from"(rx667_pos)
    ge rx667_pos, rx667_eos, rxscan668_done
  rxscan668_scan:
    set_addr $I10, rxscan668_loop
    rx667_cur."!mark_push"(0, rx667_pos, $I10)
  rxscan668_done:
.annotate 'line', 285
  # rx subrule "identifier" subtype=capture negate=
    rx667_cur."!cursor_pos"(rx667_pos)
    $P10 = rx667_cur."identifier"()
    unless $P10, rx667_fail
    rx667_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("key")
    rx667_pos = $P10."pos"()
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx667_pos, rx667_off
    set rx667_rep, 0
    sub $I12, rx667_eos, rx667_pos
  rxenumcharlistq669_loop:
    le $I12, 0, rxenumcharlistq669_done
    substr $S10, rx667_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq669_done
    inc rx667_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq669_loop
  rxenumcharlistq669_done:
    add rx667_pos, rx667_pos, rx667_rep
  # rx literal  "=>"
    add $I11, rx667_pos, 2
    gt $I11, rx667_eos, rx667_fail
    sub $I11, rx667_pos, rx667_off
    substr $S10, rx667_tgt, $I11, 2
    ne $S10, "=>", rx667_fail
    add rx667_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx667_cur."!cursor_pos"(rx667_pos)
    $P10 = rx667_cur."ws"()
    unless $P10, rx667_fail
    rx667_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx667_cur."!cursor_pos"(rx667_pos)
    $P10 = rx667_cur."EXPR"("i=")
    unless $P10, rx667_fail
    rx667_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("val")
    rx667_pos = $P10."pos"()
.annotate 'line', 284
  # rx pass
    rx667_cur."!cursor_pass"(rx667_pos, "fatarrow")
    if_null rx667_debug, debug_845
    rx667_cur."!cursor_debug"("PASS", "fatarrow", " at pos=", rx667_pos)
  debug_845:
    .return (rx667_cur)
  rx667_restart:
.annotate 'line', 10
    if_null rx667_debug, debug_846
    rx667_cur."!cursor_debug"("NEXT", "fatarrow")
  debug_846:
  rx667_fail:
    (rx667_rep, rx667_pos, $I10, $P10) = rx667_cur."!mark_fail"(0)
    lt rx667_pos, -1, rx667_done
    eq rx667_pos, -1, rx667_fail
    jump $I10
  rx667_done:
    rx667_cur."!cursor_fail"()
    if_null rx667_debug, debug_847
    rx667_cur."!cursor_debug"("FAIL", "fatarrow")
  debug_847:
    .return (rx667_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__fatarrow"  :subid("129_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P671 = self."!PREFIX__!subrule"("identifier", "")
    new $P672, "ResizablePMCArray"
    push $P672, $P671
    .return ($P672)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "colonpair"  :subid("130_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx674_tgt
    .local int rx674_pos
    .local int rx674_off
    .local int rx674_eos
    .local int rx674_rep
    .local pmc rx674_cur
    .local pmc rx674_debug
    (rx674_cur, rx674_pos, rx674_tgt, $I10) = self."!cursor_start"()
    rx674_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx674_cur
    .local pmc match
    .lex "$/", match
    length rx674_eos, rx674_tgt
    gt rx674_pos, rx674_eos, rx674_done
    set rx674_off, 0
    lt rx674_pos, 2, rx674_start
    sub rx674_off, rx674_pos, 1
    substr rx674_tgt, rx674_tgt, rx674_off
  rx674_start:
    eq $I10, 1, rx674_restart
    if_null rx674_debug, debug_848
    rx674_cur."!cursor_debug"("START", "colonpair")
  debug_848:
    $I10 = self.'from'()
    ne $I10, -1, rxscan675_done
    goto rxscan675_scan
  rxscan675_loop:
    (rx674_pos) = rx674_cur."from"()
    inc rx674_pos
    rx674_cur."!cursor_from"(rx674_pos)
    ge rx674_pos, rx674_eos, rxscan675_done
  rxscan675_scan:
    set_addr $I10, rxscan675_loop
    rx674_cur."!mark_push"(0, rx674_pos, $I10)
  rxscan675_done:
.annotate 'line', 289
  # rx literal  ":"
    add $I11, rx674_pos, 1
    gt $I11, rx674_eos, rx674_fail
    sub $I11, rx674_pos, rx674_off
    ord $I11, rx674_tgt, $I11
    ne $I11, 58, rx674_fail
    add rx674_pos, 1
  alt676_0:
.annotate 'line', 290
    set_addr $I10, alt676_1
    rx674_cur."!mark_push"(0, rx674_pos, $I10)
.annotate 'line', 291
  # rx subcapture "not"
    set_addr $I10, rxcap_677_fail
    rx674_cur."!mark_push"(0, rx674_pos, $I10)
  # rx literal  "!"
    add $I11, rx674_pos, 1
    gt $I11, rx674_eos, rx674_fail
    sub $I11, rx674_pos, rx674_off
    ord $I11, rx674_tgt, $I11
    ne $I11, 33, rx674_fail
    add rx674_pos, 1
    set_addr $I10, rxcap_677_fail
    ($I12, $I11) = rx674_cur."!mark_peek"($I10)
    rx674_cur."!cursor_pos"($I11)
    ($P10) = rx674_cur."!cursor_start"()
    $P10."!cursor_pass"(rx674_pos, "")
    rx674_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("not")
    goto rxcap_677_done
  rxcap_677_fail:
    goto rx674_fail
  rxcap_677_done:
  # rx subrule "identifier" subtype=capture negate=
    rx674_cur."!cursor_pos"(rx674_pos)
    $P10 = rx674_cur."identifier"()
    unless $P10, rx674_fail
    rx674_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx674_pos = $P10."pos"()
    goto alt676_end
  alt676_1:
    set_addr $I10, alt676_2
    rx674_cur."!mark_push"(0, rx674_pos, $I10)
.annotate 'line', 292
  # rx subrule "identifier" subtype=capture negate=
    rx674_cur."!cursor_pos"(rx674_pos)
    $P10 = rx674_cur."identifier"()
    unless $P10, rx674_fail
    rx674_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx674_pos = $P10."pos"()
  # rx rxquantr678 ** 0..1
    set_addr $I10, rxquantr678_done
    rx674_cur."!mark_push"(0, rx674_pos, $I10)
  rxquantr678_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx674_cur."!cursor_pos"(rx674_pos)
    $P10 = rx674_cur."circumfix"()
    unless $P10, rx674_fail
    goto rxsubrule679_pass
  rxsubrule679_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx674_fail
  rxsubrule679_pass:
    set_addr $I10, rxsubrule679_back
    rx674_cur."!mark_push"(0, rx674_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx674_pos = $P10."pos"()
    set_addr $I10, rxquantr678_done
    (rx674_rep) = rx674_cur."!mark_commit"($I10)
  rxquantr678_done:
    goto alt676_end
  alt676_2:
.annotate 'line', 293
  # rx subrule "circumfix" subtype=capture negate=
    rx674_cur."!cursor_pos"(rx674_pos)
    $P10 = rx674_cur."circumfix"()
    unless $P10, rx674_fail
    rx674_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("circumfix")
    rx674_pos = $P10."pos"()
  alt676_end:
.annotate 'line', 288
  # rx pass
    rx674_cur."!cursor_pass"(rx674_pos, "colonpair")
    if_null rx674_debug, debug_849
    rx674_cur."!cursor_debug"("PASS", "colonpair", " at pos=", rx674_pos)
  debug_849:
    .return (rx674_cur)
  rx674_restart:
.annotate 'line', 10
    if_null rx674_debug, debug_850
    rx674_cur."!cursor_debug"("NEXT", "colonpair")
  debug_850:
  rx674_fail:
    (rx674_rep, rx674_pos, $I10, $P10) = rx674_cur."!mark_fail"(0)
    lt rx674_pos, -1, rx674_done
    eq rx674_pos, -1, rx674_fail
    jump $I10
  rx674_done:
    rx674_cur."!cursor_fail"()
    if_null rx674_debug, debug_851
    rx674_cur."!cursor_debug"("FAIL", "colonpair")
  debug_851:
    .return (rx674_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__colonpair"  :subid("131_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P681 = self."!PREFIX__!subrule"("circumfix", ":")
    $P682 = self."!PREFIX__!subrule"("identifier", ":")
    $P683 = self."!PREFIX__!subrule"("identifier", ":!")
    new $P684, "ResizablePMCArray"
    push $P684, $P681
    push $P684, $P682
    push $P684, $P683
    .return ($P684)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable"  :subid("132_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx686_tgt
    .local int rx686_pos
    .local int rx686_off
    .local int rx686_eos
    .local int rx686_rep
    .local pmc rx686_cur
    .local pmc rx686_debug
    (rx686_cur, rx686_pos, rx686_tgt, $I10) = self."!cursor_start"()
    rx686_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx686_cur
    .local pmc match
    .lex "$/", match
    length rx686_eos, rx686_tgt
    gt rx686_pos, rx686_eos, rx686_done
    set rx686_off, 0
    lt rx686_pos, 2, rx686_start
    sub rx686_off, rx686_pos, 1
    substr rx686_tgt, rx686_tgt, rx686_off
  rx686_start:
    eq $I10, 1, rx686_restart
    if_null rx686_debug, debug_852
    rx686_cur."!cursor_debug"("START", "variable")
  debug_852:
    $I10 = self.'from'()
    ne $I10, -1, rxscan687_done
    goto rxscan687_scan
  rxscan687_loop:
    (rx686_pos) = rx686_cur."from"()
    inc rx686_pos
    rx686_cur."!cursor_from"(rx686_pos)
    ge rx686_pos, rx686_eos, rxscan687_done
  rxscan687_scan:
    set_addr $I10, rxscan687_loop
    rx686_cur."!mark_push"(0, rx686_pos, $I10)
  rxscan687_done:
  alt688_0:
.annotate 'line', 297
    set_addr $I10, alt688_1
    rx686_cur."!mark_push"(0, rx686_pos, $I10)
.annotate 'line', 298
  # rx subrule "sigil" subtype=capture negate=
    rx686_cur."!cursor_pos"(rx686_pos)
    $P10 = rx686_cur."sigil"()
    unless $P10, rx686_fail
    rx686_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx686_pos = $P10."pos"()
  # rx rxquantr689 ** 0..1
    set_addr $I10, rxquantr689_done
    rx686_cur."!mark_push"(0, rx686_pos, $I10)
  rxquantr689_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx686_cur."!cursor_pos"(rx686_pos)
    $P10 = rx686_cur."twigil"()
    unless $P10, rx686_fail
    goto rxsubrule690_pass
  rxsubrule690_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx686_fail
  rxsubrule690_pass:
    set_addr $I10, rxsubrule690_back
    rx686_cur."!mark_push"(0, rx686_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx686_pos = $P10."pos"()
    set_addr $I10, rxquantr689_done
    (rx686_rep) = rx686_cur."!mark_commit"($I10)
  rxquantr689_done:
  # rx subrule "name" subtype=capture negate=
    rx686_cur."!cursor_pos"(rx686_pos)
    $P10 = rx686_cur."name"()
    unless $P10, rx686_fail
    rx686_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    rx686_pos = $P10."pos"()
    goto alt688_end
  alt688_1:
    set_addr $I10, alt688_2
    rx686_cur."!mark_push"(0, rx686_pos, $I10)
.annotate 'line', 299
  # rx subrule "sigil" subtype=capture negate=
    rx686_cur."!cursor_pos"(rx686_pos)
    $P10 = rx686_cur."sigil"()
    unless $P10, rx686_fail
    rx686_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx686_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx686_pos, rx686_off
    substr $S10, rx686_tgt, $I10, 1
    index $I11, "<[", $S10
    lt $I11, 0, rx686_fail
  # rx subrule "postcircumfix" subtype=capture negate=
    rx686_cur."!cursor_pos"(rx686_pos)
    $P10 = rx686_cur."postcircumfix"()
    unless $P10, rx686_fail
    rx686_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("postcircumfix")
    rx686_pos = $P10."pos"()
    goto alt688_end
  alt688_2:
.annotate 'line', 300
  # rx subcapture "sigil"
    set_addr $I10, rxcap_691_fail
    rx686_cur."!mark_push"(0, rx686_pos, $I10)
  # rx literal  "$"
    add $I11, rx686_pos, 1
    gt $I11, rx686_eos, rx686_fail
    sub $I11, rx686_pos, rx686_off
    ord $I11, rx686_tgt, $I11
    ne $I11, 36, rx686_fail
    add rx686_pos, 1
    set_addr $I10, rxcap_691_fail
    ($I12, $I11) = rx686_cur."!mark_peek"($I10)
    rx686_cur."!cursor_pos"($I11)
    ($P10) = rx686_cur."!cursor_start"()
    $P10."!cursor_pass"(rx686_pos, "")
    rx686_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_691_done
  rxcap_691_fail:
    goto rx686_fail
  rxcap_691_done:
  # rx subcapture "desigilname"
    set_addr $I10, rxcap_692_fail
    rx686_cur."!mark_push"(0, rx686_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx686_pos, rx686_eos, rx686_fail
    sub $I10, rx686_pos, rx686_off
    substr $S10, rx686_tgt, $I10, 1
    index $I11, "/_!", $S10
    lt $I11, 0, rx686_fail
    inc rx686_pos
    set_addr $I10, rxcap_692_fail
    ($I12, $I11) = rx686_cur."!mark_peek"($I10)
    rx686_cur."!cursor_pos"($I11)
    ($P10) = rx686_cur."!cursor_start"()
    $P10."!cursor_pass"(rx686_pos, "")
    rx686_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    goto rxcap_692_done
  rxcap_692_fail:
    goto rx686_fail
  rxcap_692_done:
  alt688_end:
.annotate 'line', 297
  # rx pass
    rx686_cur."!cursor_pass"(rx686_pos, "variable")
    if_null rx686_debug, debug_853
    rx686_cur."!cursor_debug"("PASS", "variable", " at pos=", rx686_pos)
  debug_853:
    .return (rx686_cur)
  rx686_restart:
.annotate 'line', 10
    if_null rx686_debug, debug_854
    rx686_cur."!cursor_debug"("NEXT", "variable")
  debug_854:
  rx686_fail:
    (rx686_rep, rx686_pos, $I10, $P10) = rx686_cur."!mark_fail"(0)
    lt rx686_pos, -1, rx686_done
    eq rx686_pos, -1, rx686_fail
    jump $I10
  rx686_done:
    rx686_cur."!cursor_fail"()
    if_null rx686_debug, debug_855
    rx686_cur."!cursor_debug"("FAIL", "variable")
  debug_855:
    .return (rx686_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable"  :subid("133_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P694 = self."!PREFIX__!subrule"("sigil", "")
    $P695 = self."!PREFIX__!subrule"("sigil", "")
    new $P696, "ResizablePMCArray"
    push $P696, "/"
    push $P696, "_"
    push $P696, "!"
    push $P696, $P694
    push $P696, $P695
    .return ($P696)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "sigil"  :subid("134_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx698_tgt
    .local int rx698_pos
    .local int rx698_off
    .local int rx698_eos
    .local int rx698_rep
    .local pmc rx698_cur
    .local pmc rx698_debug
    (rx698_cur, rx698_pos, rx698_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx698_cur
    .local pmc match
    .lex "$/", match
    length rx698_eos, rx698_tgt
    gt rx698_pos, rx698_eos, rx698_done
    set rx698_off, 0
    lt rx698_pos, 2, rx698_start
    sub rx698_off, rx698_pos, 1
    substr rx698_tgt, rx698_tgt, rx698_off
  rx698_start:
    eq $I10, 1, rx698_restart
    if_null rx698_debug, debug_856
    rx698_cur."!cursor_debug"("START", "sigil")
  debug_856:
    $I10 = self.'from'()
    ne $I10, -1, rxscan699_done
    goto rxscan699_scan
  rxscan699_loop:
    (rx698_pos) = rx698_cur."from"()
    inc rx698_pos
    rx698_cur."!cursor_from"(rx698_pos)
    ge rx698_pos, rx698_eos, rxscan699_done
  rxscan699_scan:
    set_addr $I10, rxscan699_loop
    rx698_cur."!mark_push"(0, rx698_pos, $I10)
  rxscan699_done:
.annotate 'line', 303
  # rx enumcharlist negate=0 
    ge rx698_pos, rx698_eos, rx698_fail
    sub $I10, rx698_pos, rx698_off
    substr $S10, rx698_tgt, $I10, 1
    index $I11, "$@%&", $S10
    lt $I11, 0, rx698_fail
    inc rx698_pos
  # rx pass
    rx698_cur."!cursor_pass"(rx698_pos, "sigil")
    if_null rx698_debug, debug_857
    rx698_cur."!cursor_debug"("PASS", "sigil", " at pos=", rx698_pos)
  debug_857:
    .return (rx698_cur)
  rx698_restart:
.annotate 'line', 10
    if_null rx698_debug, debug_858
    rx698_cur."!cursor_debug"("NEXT", "sigil")
  debug_858:
  rx698_fail:
    (rx698_rep, rx698_pos, $I10, $P10) = rx698_cur."!mark_fail"(0)
    lt rx698_pos, -1, rx698_done
    eq rx698_pos, -1, rx698_fail
    jump $I10
  rx698_done:
    rx698_cur."!cursor_fail"()
    if_null rx698_debug, debug_859
    rx698_cur."!cursor_debug"("FAIL", "sigil")
  debug_859:
    .return (rx698_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__sigil"  :subid("135_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    new $P701, "ResizablePMCArray"
    push $P701, "$"
    push $P701, "@"
    push $P701, "%"
    push $P701, "&"
    .return ($P701)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "twigil"  :subid("136_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx703_tgt
    .local int rx703_pos
    .local int rx703_off
    .local int rx703_eos
    .local int rx703_rep
    .local pmc rx703_cur
    .local pmc rx703_debug
    (rx703_cur, rx703_pos, rx703_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx703_cur
    .local pmc match
    .lex "$/", match
    length rx703_eos, rx703_tgt
    gt rx703_pos, rx703_eos, rx703_done
    set rx703_off, 0
    lt rx703_pos, 2, rx703_start
    sub rx703_off, rx703_pos, 1
    substr rx703_tgt, rx703_tgt, rx703_off
  rx703_start:
    eq $I10, 1, rx703_restart
    if_null rx703_debug, debug_860
    rx703_cur."!cursor_debug"("START", "twigil")
  debug_860:
    $I10 = self.'from'()
    ne $I10, -1, rxscan704_done
    goto rxscan704_scan
  rxscan704_loop:
    (rx703_pos) = rx703_cur."from"()
    inc rx703_pos
    rx703_cur."!cursor_from"(rx703_pos)
    ge rx703_pos, rx703_eos, rxscan704_done
  rxscan704_scan:
    set_addr $I10, rxscan704_loop
    rx703_cur."!mark_push"(0, rx703_pos, $I10)
  rxscan704_done:
.annotate 'line', 305
  # rx enumcharlist negate=0 
    ge rx703_pos, rx703_eos, rx703_fail
    sub $I10, rx703_pos, rx703_off
    substr $S10, rx703_tgt, $I10, 1
    index $I11, "*!?", $S10
    lt $I11, 0, rx703_fail
    inc rx703_pos
  # rx pass
    rx703_cur."!cursor_pass"(rx703_pos, "twigil")
    if_null rx703_debug, debug_861
    rx703_cur."!cursor_debug"("PASS", "twigil", " at pos=", rx703_pos)
  debug_861:
    .return (rx703_cur)
  rx703_restart:
.annotate 'line', 10
    if_null rx703_debug, debug_862
    rx703_cur."!cursor_debug"("NEXT", "twigil")
  debug_862:
  rx703_fail:
    (rx703_rep, rx703_pos, $I10, $P10) = rx703_cur."!mark_fail"(0)
    lt rx703_pos, -1, rx703_done
    eq rx703_pos, -1, rx703_fail
    jump $I10
  rx703_done:
    rx703_cur."!cursor_fail"()
    if_null rx703_debug, debug_863
    rx703_cur."!cursor_debug"("FAIL", "twigil")
  debug_863:
    .return (rx703_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__twigil"  :subid("137_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    new $P706, "ResizablePMCArray"
    push $P706, "*"
    push $P706, "!"
    push $P706, "?"
    .return ($P706)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator"  :subid("138_1304456155.152")
    .param pmc param_708
.annotate 'line', 307
    .lex "self", param_708
    $P709 = param_708."!protoregex"("package_declarator")
    .return ($P709)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator"  :subid("139_1304456155.152")
    .param pmc param_711
.annotate 'line', 307
    .lex "self", param_711
    $P712 = param_711."!PREFIX__!protoregex"("package_declarator")
    .return ($P712)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<module>"  :subid("140_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 309
    new $P714, "Undef"
    .lex "$*OUTERPACKAGE", $P714
.annotate 'line', 310
    new $P715, "Undef"
    .lex "$*PKGDECL", $P715
.annotate 'line', 10
    .local string rx716_tgt
    .local int rx716_pos
    .local int rx716_off
    .local int rx716_eos
    .local int rx716_rep
    .local pmc rx716_cur
    .local pmc rx716_debug
    (rx716_cur, rx716_pos, rx716_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx716_cur
    .local pmc match
    .lex "$/", match
    length rx716_eos, rx716_tgt
    gt rx716_pos, rx716_eos, rx716_done
    set rx716_off, 0
    lt rx716_pos, 2, rx716_start
    sub rx716_off, rx716_pos, 1
    substr rx716_tgt, rx716_tgt, rx716_off
  rx716_start:
    eq $I10, 1, rx716_restart
    if_null rx716_debug, debug_864
    rx716_cur."!cursor_debug"("START", "package_declarator:sym<module>")
  debug_864:
    $I10 = self.'from'()
    ne $I10, -1, rxscan717_done
    goto rxscan717_scan
  rxscan717_loop:
    (rx716_pos) = rx716_cur."from"()
    inc rx716_pos
    rx716_cur."!cursor_from"(rx716_pos)
    ge rx716_pos, rx716_eos, rxscan717_done
  rxscan717_scan:
    set_addr $I10, rxscan717_loop
    rx716_cur."!mark_push"(0, rx716_pos, $I10)
  rxscan717_done:
.annotate 'line', 309
    rx716_cur."!cursor_pos"(rx716_pos)
    find_dynamic_lex $P720, "$*PACKAGE"
    unless_null $P720, vivify_865
    get_hll_global $P718, "GLOBAL"
    get_who $P719, $P718
    set $P720, $P719["$PACKAGE"]
    unless_null $P720, vivify_866
    die "Contextual $*PACKAGE not found"
  vivify_866:
  vivify_865:
    store_lex "$*OUTERPACKAGE", $P720
.annotate 'line', 310
    rx716_cur."!cursor_pos"(rx716_pos)
    new $P721, "String"
    assign $P721, "module"
    store_lex "$*PKGDECL", $P721
.annotate 'line', 311
  # rx subcapture "sym"
    set_addr $I10, rxcap_722_fail
    rx716_cur."!mark_push"(0, rx716_pos, $I10)
  # rx literal  "module"
    add $I11, rx716_pos, 6
    gt $I11, rx716_eos, rx716_fail
    sub $I11, rx716_pos, rx716_off
    substr $S10, rx716_tgt, $I11, 6
    ne $S10, "module", rx716_fail
    add rx716_pos, 6
    set_addr $I10, rxcap_722_fail
    ($I12, $I11) = rx716_cur."!mark_peek"($I10)
    rx716_cur."!cursor_pos"($I11)
    ($P10) = rx716_cur."!cursor_start"()
    $P10."!cursor_pass"(rx716_pos, "")
    rx716_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_722_done
  rxcap_722_fail:
    goto rx716_fail
  rxcap_722_done:
  # rx subrule "package_def" subtype=capture negate=
    rx716_cur."!cursor_pos"(rx716_pos)
    $P10 = rx716_cur."package_def"()
    unless $P10, rx716_fail
    rx716_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx716_pos = $P10."pos"()
.annotate 'line', 308
  # rx pass
    rx716_cur."!cursor_pass"(rx716_pos, "package_declarator:sym<module>")
    if_null rx716_debug, debug_867
    rx716_cur."!cursor_debug"("PASS", "package_declarator:sym<module>", " at pos=", rx716_pos)
  debug_867:
    .return (rx716_cur)
  rx716_restart:
.annotate 'line', 10
    if_null rx716_debug, debug_868
    rx716_cur."!cursor_debug"("NEXT", "package_declarator:sym<module>")
  debug_868:
  rx716_fail:
    (rx716_rep, rx716_pos, $I10, $P10) = rx716_cur."!mark_fail"(0)
    lt rx716_pos, -1, rx716_done
    eq rx716_pos, -1, rx716_fail
    jump $I10
  rx716_done:
    rx716_cur."!cursor_fail"()
    if_null rx716_debug, debug_869
    rx716_cur."!cursor_debug"("FAIL", "package_declarator:sym<module>")
  debug_869:
    .return (rx716_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<module>"  :subid("141_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P724 = self."!PREFIX__!subrule"("package_def", "module")
    new $P725, "ResizablePMCArray"
    push $P725, $P724
    .return ($P725)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<knowhow>"  :subid("142_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 314
    new $P727, "Undef"
    .lex "$*OUTERPACKAGE", $P727
.annotate 'line', 315
    new $P728, "Undef"
    .lex "$*PKGDECL", $P728
.annotate 'line', 10
    .local string rx729_tgt
    .local int rx729_pos
    .local int rx729_off
    .local int rx729_eos
    .local int rx729_rep
    .local pmc rx729_cur
    .local pmc rx729_debug
    (rx729_cur, rx729_pos, rx729_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx729_cur
    .local pmc match
    .lex "$/", match
    length rx729_eos, rx729_tgt
    gt rx729_pos, rx729_eos, rx729_done
    set rx729_off, 0
    lt rx729_pos, 2, rx729_start
    sub rx729_off, rx729_pos, 1
    substr rx729_tgt, rx729_tgt, rx729_off
  rx729_start:
    eq $I10, 1, rx729_restart
    if_null rx729_debug, debug_870
    rx729_cur."!cursor_debug"("START", "package_declarator:sym<knowhow>")
  debug_870:
    $I10 = self.'from'()
    ne $I10, -1, rxscan730_done
    goto rxscan730_scan
  rxscan730_loop:
    (rx729_pos) = rx729_cur."from"()
    inc rx729_pos
    rx729_cur."!cursor_from"(rx729_pos)
    ge rx729_pos, rx729_eos, rxscan730_done
  rxscan730_scan:
    set_addr $I10, rxscan730_loop
    rx729_cur."!mark_push"(0, rx729_pos, $I10)
  rxscan730_done:
.annotate 'line', 314
    rx729_cur."!cursor_pos"(rx729_pos)
    find_dynamic_lex $P733, "$*PACKAGE"
    unless_null $P733, vivify_871
    get_hll_global $P731, "GLOBAL"
    get_who $P732, $P731
    set $P733, $P732["$PACKAGE"]
    unless_null $P733, vivify_872
    die "Contextual $*PACKAGE not found"
  vivify_872:
  vivify_871:
    store_lex "$*OUTERPACKAGE", $P733
.annotate 'line', 315
    rx729_cur."!cursor_pos"(rx729_pos)
    new $P734, "String"
    assign $P734, "knowhow"
    store_lex "$*PKGDECL", $P734
.annotate 'line', 316
  # rx subcapture "sym"
    set_addr $I10, rxcap_735_fail
    rx729_cur."!mark_push"(0, rx729_pos, $I10)
  # rx literal  "knowhow"
    add $I11, rx729_pos, 7
    gt $I11, rx729_eos, rx729_fail
    sub $I11, rx729_pos, rx729_off
    substr $S10, rx729_tgt, $I11, 7
    ne $S10, "knowhow", rx729_fail
    add rx729_pos, 7
    set_addr $I10, rxcap_735_fail
    ($I12, $I11) = rx729_cur."!mark_peek"($I10)
    rx729_cur."!cursor_pos"($I11)
    ($P10) = rx729_cur."!cursor_start"()
    $P10."!cursor_pass"(rx729_pos, "")
    rx729_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_735_done
  rxcap_735_fail:
    goto rx729_fail
  rxcap_735_done:
  # rx subrule "package_def" subtype=capture negate=
    rx729_cur."!cursor_pos"(rx729_pos)
    $P10 = rx729_cur."package_def"()
    unless $P10, rx729_fail
    rx729_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx729_pos = $P10."pos"()
.annotate 'line', 313
  # rx pass
    rx729_cur."!cursor_pass"(rx729_pos, "package_declarator:sym<knowhow>")
    if_null rx729_debug, debug_873
    rx729_cur."!cursor_debug"("PASS", "package_declarator:sym<knowhow>", " at pos=", rx729_pos)
  debug_873:
    .return (rx729_cur)
  rx729_restart:
.annotate 'line', 10
    if_null rx729_debug, debug_874
    rx729_cur."!cursor_debug"("NEXT", "package_declarator:sym<knowhow>")
  debug_874:
  rx729_fail:
    (rx729_rep, rx729_pos, $I10, $P10) = rx729_cur."!mark_fail"(0)
    lt rx729_pos, -1, rx729_done
    eq rx729_pos, -1, rx729_fail
    jump $I10
  rx729_done:
    rx729_cur."!cursor_fail"()
    if_null rx729_debug, debug_875
    rx729_cur."!cursor_debug"("FAIL", "package_declarator:sym<knowhow>")
  debug_875:
    .return (rx729_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<knowhow>"  :subid("143_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P737 = self."!PREFIX__!subrule"("package_def", "knowhow")
    new $P738, "ResizablePMCArray"
    push $P738, $P737
    .return ($P738)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<class>"  :subid("144_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 319
    new $P740, "Undef"
    .lex "$*OUTERPACKAGE", $P740
.annotate 'line', 320
    new $P741, "Undef"
    .lex "$*PKGDECL", $P741
.annotate 'line', 10
    .local string rx742_tgt
    .local int rx742_pos
    .local int rx742_off
    .local int rx742_eos
    .local int rx742_rep
    .local pmc rx742_cur
    .local pmc rx742_debug
    (rx742_cur, rx742_pos, rx742_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx742_cur
    .local pmc match
    .lex "$/", match
    length rx742_eos, rx742_tgt
    gt rx742_pos, rx742_eos, rx742_done
    set rx742_off, 0
    lt rx742_pos, 2, rx742_start
    sub rx742_off, rx742_pos, 1
    substr rx742_tgt, rx742_tgt, rx742_off
  rx742_start:
    eq $I10, 1, rx742_restart
    if_null rx742_debug, debug_876
    rx742_cur."!cursor_debug"("START", "package_declarator:sym<class>")
  debug_876:
    $I10 = self.'from'()
    ne $I10, -1, rxscan743_done
    goto rxscan743_scan
  rxscan743_loop:
    (rx742_pos) = rx742_cur."from"()
    inc rx742_pos
    rx742_cur."!cursor_from"(rx742_pos)
    ge rx742_pos, rx742_eos, rxscan743_done
  rxscan743_scan:
    set_addr $I10, rxscan743_loop
    rx742_cur."!mark_push"(0, rx742_pos, $I10)
  rxscan743_done:
.annotate 'line', 319
    rx742_cur."!cursor_pos"(rx742_pos)
    find_dynamic_lex $P746, "$*PACKAGE"
    unless_null $P746, vivify_877
    get_hll_global $P744, "GLOBAL"
    get_who $P745, $P744
    set $P746, $P745["$PACKAGE"]
    unless_null $P746, vivify_878
    die "Contextual $*PACKAGE not found"
  vivify_878:
  vivify_877:
    store_lex "$*OUTERPACKAGE", $P746
.annotate 'line', 320
    rx742_cur."!cursor_pos"(rx742_pos)
    new $P747, "String"
    assign $P747, "class"
    store_lex "$*PKGDECL", $P747
.annotate 'line', 321
  # rx subcapture "sym"
    set_addr $I10, rxcap_748_fail
    rx742_cur."!mark_push"(0, rx742_pos, $I10)
  # rx literal  "class"
    add $I11, rx742_pos, 5
    gt $I11, rx742_eos, rx742_fail
    sub $I11, rx742_pos, rx742_off
    substr $S10, rx742_tgt, $I11, 5
    ne $S10, "class", rx742_fail
    add rx742_pos, 5
    set_addr $I10, rxcap_748_fail
    ($I12, $I11) = rx742_cur."!mark_peek"($I10)
    rx742_cur."!cursor_pos"($I11)
    ($P10) = rx742_cur."!cursor_start"()
    $P10."!cursor_pass"(rx742_pos, "")
    rx742_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_748_done
  rxcap_748_fail:
    goto rx742_fail
  rxcap_748_done:
  # rx subrule "package_def" subtype=capture negate=
    rx742_cur."!cursor_pos"(rx742_pos)
    $P10 = rx742_cur."package_def"()
    unless $P10, rx742_fail
    rx742_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx742_pos = $P10."pos"()
.annotate 'line', 318
  # rx pass
    rx742_cur."!cursor_pass"(rx742_pos, "package_declarator:sym<class>")
    if_null rx742_debug, debug_879
    rx742_cur."!cursor_debug"("PASS", "package_declarator:sym<class>", " at pos=", rx742_pos)
  debug_879:
    .return (rx742_cur)
  rx742_restart:
.annotate 'line', 10
    if_null rx742_debug, debug_880
    rx742_cur."!cursor_debug"("NEXT", "package_declarator:sym<class>")
  debug_880:
  rx742_fail:
    (rx742_rep, rx742_pos, $I10, $P10) = rx742_cur."!mark_fail"(0)
    lt rx742_pos, -1, rx742_done
    eq rx742_pos, -1, rx742_fail
    jump $I10
  rx742_done:
    rx742_cur."!cursor_fail"()
    if_null rx742_debug, debug_881
    rx742_cur."!cursor_debug"("FAIL", "package_declarator:sym<class>")
  debug_881:
    .return (rx742_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<class>"  :subid("145_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P750 = self."!PREFIX__!subrule"("package_def", "class")
    new $P751, "ResizablePMCArray"
    push $P751, $P750
    .return ($P751)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<grammar>"  :subid("146_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 324
    new $P753, "Undef"
    .lex "$*OUTERPACKAGE", $P753
.annotate 'line', 325
    new $P754, "Undef"
    .lex "$*PKGDECL", $P754
.annotate 'line', 10
    .local string rx755_tgt
    .local int rx755_pos
    .local int rx755_off
    .local int rx755_eos
    .local int rx755_rep
    .local pmc rx755_cur
    .local pmc rx755_debug
    (rx755_cur, rx755_pos, rx755_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx755_cur
    .local pmc match
    .lex "$/", match
    length rx755_eos, rx755_tgt
    gt rx755_pos, rx755_eos, rx755_done
    set rx755_off, 0
    lt rx755_pos, 2, rx755_start
    sub rx755_off, rx755_pos, 1
    substr rx755_tgt, rx755_tgt, rx755_off
  rx755_start:
    eq $I10, 1, rx755_restart
    if_null rx755_debug, debug_882
    rx755_cur."!cursor_debug"("START", "package_declarator:sym<grammar>")
  debug_882:
    $I10 = self.'from'()
    ne $I10, -1, rxscan756_done
    goto rxscan756_scan
  rxscan756_loop:
    (rx755_pos) = rx755_cur."from"()
    inc rx755_pos
    rx755_cur."!cursor_from"(rx755_pos)
    ge rx755_pos, rx755_eos, rxscan756_done
  rxscan756_scan:
    set_addr $I10, rxscan756_loop
    rx755_cur."!mark_push"(0, rx755_pos, $I10)
  rxscan756_done:
.annotate 'line', 324
    rx755_cur."!cursor_pos"(rx755_pos)
    find_dynamic_lex $P759, "$*PACKAGE"
    unless_null $P759, vivify_883
    get_hll_global $P757, "GLOBAL"
    get_who $P758, $P757
    set $P759, $P758["$PACKAGE"]
    unless_null $P759, vivify_884
    die "Contextual $*PACKAGE not found"
  vivify_884:
  vivify_883:
    store_lex "$*OUTERPACKAGE", $P759
.annotate 'line', 325
    rx755_cur."!cursor_pos"(rx755_pos)
    new $P760, "String"
    assign $P760, "grammar"
    store_lex "$*PKGDECL", $P760
.annotate 'line', 326
  # rx subcapture "sym"
    set_addr $I10, rxcap_761_fail
    rx755_cur."!mark_push"(0, rx755_pos, $I10)
  # rx literal  "grammar"
    add $I11, rx755_pos, 7
    gt $I11, rx755_eos, rx755_fail
    sub $I11, rx755_pos, rx755_off
    substr $S10, rx755_tgt, $I11, 7
    ne $S10, "grammar", rx755_fail
    add rx755_pos, 7
    set_addr $I10, rxcap_761_fail
    ($I12, $I11) = rx755_cur."!mark_peek"($I10)
    rx755_cur."!cursor_pos"($I11)
    ($P10) = rx755_cur."!cursor_start"()
    $P10."!cursor_pass"(rx755_pos, "")
    rx755_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_761_done
  rxcap_761_fail:
    goto rx755_fail
  rxcap_761_done:
  # rx subrule "package_def" subtype=capture negate=
    rx755_cur."!cursor_pos"(rx755_pos)
    $P10 = rx755_cur."package_def"()
    unless $P10, rx755_fail
    rx755_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx755_pos = $P10."pos"()
.annotate 'line', 323
  # rx pass
    rx755_cur."!cursor_pass"(rx755_pos, "package_declarator:sym<grammar>")
    if_null rx755_debug, debug_885
    rx755_cur."!cursor_debug"("PASS", "package_declarator:sym<grammar>", " at pos=", rx755_pos)
  debug_885:
    .return (rx755_cur)
  rx755_restart:
.annotate 'line', 10
    if_null rx755_debug, debug_886
    rx755_cur."!cursor_debug"("NEXT", "package_declarator:sym<grammar>")
  debug_886:
  rx755_fail:
    (rx755_rep, rx755_pos, $I10, $P10) = rx755_cur."!mark_fail"(0)
    lt rx755_pos, -1, rx755_done
    eq rx755_pos, -1, rx755_fail
    jump $I10
  rx755_done:
    rx755_cur."!cursor_fail"()
    if_null rx755_debug, debug_887
    rx755_cur."!cursor_debug"("FAIL", "package_declarator:sym<grammar>")
  debug_887:
    .return (rx755_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<grammar>"  :subid("147_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P763 = self."!PREFIX__!subrule"("package_def", "grammar")
    new $P764, "ResizablePMCArray"
    push $P764, $P763
    .return ($P764)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<role>"  :subid("148_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 329
    new $P766, "Undef"
    .lex "$*OUTERPACKAGE", $P766
.annotate 'line', 330
    new $P767, "Undef"
    .lex "$*PKGDECL", $P767
.annotate 'line', 10
    .local string rx768_tgt
    .local int rx768_pos
    .local int rx768_off
    .local int rx768_eos
    .local int rx768_rep
    .local pmc rx768_cur
    .local pmc rx768_debug
    (rx768_cur, rx768_pos, rx768_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx768_cur
    .local pmc match
    .lex "$/", match
    length rx768_eos, rx768_tgt
    gt rx768_pos, rx768_eos, rx768_done
    set rx768_off, 0
    lt rx768_pos, 2, rx768_start
    sub rx768_off, rx768_pos, 1
    substr rx768_tgt, rx768_tgt, rx768_off
  rx768_start:
    eq $I10, 1, rx768_restart
    if_null rx768_debug, debug_888
    rx768_cur."!cursor_debug"("START", "package_declarator:sym<role>")
  debug_888:
    $I10 = self.'from'()
    ne $I10, -1, rxscan769_done
    goto rxscan769_scan
  rxscan769_loop:
    (rx768_pos) = rx768_cur."from"()
    inc rx768_pos
    rx768_cur."!cursor_from"(rx768_pos)
    ge rx768_pos, rx768_eos, rxscan769_done
  rxscan769_scan:
    set_addr $I10, rxscan769_loop
    rx768_cur."!mark_push"(0, rx768_pos, $I10)
  rxscan769_done:
.annotate 'line', 329
    rx768_cur."!cursor_pos"(rx768_pos)
    find_dynamic_lex $P772, "$*PACKAGE"
    unless_null $P772, vivify_889
    get_hll_global $P770, "GLOBAL"
    get_who $P771, $P770
    set $P772, $P771["$PACKAGE"]
    unless_null $P772, vivify_890
    die "Contextual $*PACKAGE not found"
  vivify_890:
  vivify_889:
    store_lex "$*OUTERPACKAGE", $P772
.annotate 'line', 330
    rx768_cur."!cursor_pos"(rx768_pos)
    new $P773, "String"
    assign $P773, "role"
    store_lex "$*PKGDECL", $P773
.annotate 'line', 331
  # rx subcapture "sym"
    set_addr $I10, rxcap_774_fail
    rx768_cur."!mark_push"(0, rx768_pos, $I10)
  # rx literal  "role"
    add $I11, rx768_pos, 4
    gt $I11, rx768_eos, rx768_fail
    sub $I11, rx768_pos, rx768_off
    substr $S10, rx768_tgt, $I11, 4
    ne $S10, "role", rx768_fail
    add rx768_pos, 4
    set_addr $I10, rxcap_774_fail
    ($I12, $I11) = rx768_cur."!mark_peek"($I10)
    rx768_cur."!cursor_pos"($I11)
    ($P10) = rx768_cur."!cursor_start"()
    $P10."!cursor_pass"(rx768_pos, "")
    rx768_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_774_done
  rxcap_774_fail:
    goto rx768_fail
  rxcap_774_done:
  # rx subrule "package_def" subtype=capture negate=
    rx768_cur."!cursor_pos"(rx768_pos)
    $P10 = rx768_cur."package_def"()
    unless $P10, rx768_fail
    rx768_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx768_pos = $P10."pos"()
.annotate 'line', 328
  # rx pass
    rx768_cur."!cursor_pass"(rx768_pos, "package_declarator:sym<role>")
    if_null rx768_debug, debug_891
    rx768_cur."!cursor_debug"("PASS", "package_declarator:sym<role>", " at pos=", rx768_pos)
  debug_891:
    .return (rx768_cur)
  rx768_restart:
.annotate 'line', 10
    if_null rx768_debug, debug_892
    rx768_cur."!cursor_debug"("NEXT", "package_declarator:sym<role>")
  debug_892:
  rx768_fail:
    (rx768_rep, rx768_pos, $I10, $P10) = rx768_cur."!mark_fail"(0)
    lt rx768_pos, -1, rx768_done
    eq rx768_pos, -1, rx768_fail
    jump $I10
  rx768_done:
    rx768_cur."!cursor_fail"()
    if_null rx768_debug, debug_893
    rx768_cur."!cursor_debug"("FAIL", "package_declarator:sym<role>")
  debug_893:
    .return (rx768_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<role>"  :subid("149_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P776 = self."!PREFIX__!subrule"("package_def", "role")
    new $P777, "ResizablePMCArray"
    push $P777, $P776
    .return ($P777)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<native>"  :subid("150_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 334
    new $P779, "Undef"
    .lex "$*OUTERPACKAGE", $P779
.annotate 'line', 335
    new $P780, "Undef"
    .lex "$*PKGDECL", $P780
.annotate 'line', 10
    .local string rx781_tgt
    .local int rx781_pos
    .local int rx781_off
    .local int rx781_eos
    .local int rx781_rep
    .local pmc rx781_cur
    .local pmc rx781_debug
    (rx781_cur, rx781_pos, rx781_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx781_cur
    .local pmc match
    .lex "$/", match
    length rx781_eos, rx781_tgt
    gt rx781_pos, rx781_eos, rx781_done
    set rx781_off, 0
    lt rx781_pos, 2, rx781_start
    sub rx781_off, rx781_pos, 1
    substr rx781_tgt, rx781_tgt, rx781_off
  rx781_start:
    eq $I10, 1, rx781_restart
    if_null rx781_debug, debug_894
    rx781_cur."!cursor_debug"("START", "package_declarator:sym<native>")
  debug_894:
    $I10 = self.'from'()
    ne $I10, -1, rxscan782_done
    goto rxscan782_scan
  rxscan782_loop:
    (rx781_pos) = rx781_cur."from"()
    inc rx781_pos
    rx781_cur."!cursor_from"(rx781_pos)
    ge rx781_pos, rx781_eos, rxscan782_done
  rxscan782_scan:
    set_addr $I10, rxscan782_loop
    rx781_cur."!mark_push"(0, rx781_pos, $I10)
  rxscan782_done:
.annotate 'line', 334
    rx781_cur."!cursor_pos"(rx781_pos)
    find_dynamic_lex $P785, "$*PACKAGE"
    unless_null $P785, vivify_895
    get_hll_global $P783, "GLOBAL"
    get_who $P784, $P783
    set $P785, $P784["$PACKAGE"]
    unless_null $P785, vivify_896
    die "Contextual $*PACKAGE not found"
  vivify_896:
  vivify_895:
    store_lex "$*OUTERPACKAGE", $P785
.annotate 'line', 335
    rx781_cur."!cursor_pos"(rx781_pos)
    new $P786, "String"
    assign $P786, "native"
    store_lex "$*PKGDECL", $P786
.annotate 'line', 336
  # rx subcapture "sym"
    set_addr $I10, rxcap_787_fail
    rx781_cur."!mark_push"(0, rx781_pos, $I10)
  # rx literal  "native"
    add $I11, rx781_pos, 6
    gt $I11, rx781_eos, rx781_fail
    sub $I11, rx781_pos, rx781_off
    substr $S10, rx781_tgt, $I11, 6
    ne $S10, "native", rx781_fail
    add rx781_pos, 6
    set_addr $I10, rxcap_787_fail
    ($I12, $I11) = rx781_cur."!mark_peek"($I10)
    rx781_cur."!cursor_pos"($I11)
    ($P10) = rx781_cur."!cursor_start"()
    $P10."!cursor_pass"(rx781_pos, "")
    rx781_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_787_done
  rxcap_787_fail:
    goto rx781_fail
  rxcap_787_done:
  # rx subrule "package_def" subtype=capture negate=
    rx781_cur."!cursor_pos"(rx781_pos)
    $P10 = rx781_cur."package_def"()
    unless $P10, rx781_fail
    rx781_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx781_pos = $P10."pos"()
.annotate 'line', 333
  # rx pass
    rx781_cur."!cursor_pass"(rx781_pos, "package_declarator:sym<native>")
    if_null rx781_debug, debug_897
    rx781_cur."!cursor_debug"("PASS", "package_declarator:sym<native>", " at pos=", rx781_pos)
  debug_897:
    .return (rx781_cur)
  rx781_restart:
.annotate 'line', 10
    if_null rx781_debug, debug_898
    rx781_cur."!cursor_debug"("NEXT", "package_declarator:sym<native>")
  debug_898:
  rx781_fail:
    (rx781_rep, rx781_pos, $I10, $P10) = rx781_cur."!mark_fail"(0)
    lt rx781_pos, -1, rx781_done
    eq rx781_pos, -1, rx781_fail
    jump $I10
  rx781_done:
    rx781_cur."!cursor_fail"()
    if_null rx781_debug, debug_899
    rx781_cur."!cursor_debug"("FAIL", "package_declarator:sym<native>")
  debug_899:
    .return (rx781_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<native>"  :subid("151_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P789 = self."!PREFIX__!subrule"("package_def", "native")
    new $P790, "ResizablePMCArray"
    push $P790, $P789
    .return ($P790)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_def"  :subid("152_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .const 'Sub' $P816 = "153_1304456155.152" 
    capture_lex $P816
.annotate 'line', 340
    new $P792, "Undef"
    .lex "$*PACKAGE", $P792
.annotate 'line', 341
    $P793 = root_new ['parrot';'Hash']
    .lex "%*ATTR-CHECK", $P793
.annotate 'line', 10
    .local string rx794_tgt
    .local int rx794_pos
    .local int rx794_off
    .local int rx794_eos
    .local int rx794_rep
    .local pmc rx794_cur
    .local pmc rx794_debug
    (rx794_cur, rx794_pos, rx794_tgt, $I10) = self."!cursor_start"()
    rx794_cur."!cursor_caparray"("repr", "parent", "role")
    .lex unicode:"$\x{a2}", rx794_cur
    .local pmc match
    .lex "$/", match
    length rx794_eos, rx794_tgt
    gt rx794_pos, rx794_eos, rx794_done
    set rx794_off, 0
    lt rx794_pos, 2, rx794_start
    sub rx794_off, rx794_pos, 1
    substr rx794_tgt, rx794_tgt, rx794_off
  rx794_start:
    eq $I10, 1, rx794_restart
    if_null rx794_debug, debug_900
    rx794_cur."!cursor_debug"("START", "package_def")
  debug_900:
    $I10 = self.'from'()
    ne $I10, -1, rxscan795_done
    goto rxscan795_scan
  rxscan795_loop:
    (rx794_pos) = rx794_cur."from"()
    inc rx794_pos
    rx794_cur."!cursor_from"(rx794_pos)
    ge rx794_pos, rx794_eos, rxscan795_done
  rxscan795_scan:
    set_addr $I10, rxscan795_loop
    rx794_cur."!mark_push"(0, rx794_pos, $I10)
  rxscan795_done:
.annotate 'line', 339
  # rx subrule "ws" subtype=method negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."ws"()
    unless $P10, rx794_fail
    rx794_pos = $P10."pos"()
.annotate 'line', 340
    rx794_cur."!cursor_pos"(rx794_pos)
    find_lex $P799, "$*PACKAGE"
    unless_null $P799, vivify_901
    get_hll_global $P797, "GLOBAL"
    get_who $P798, $P797
    set $P799, $P798["$PACKAGE"]
    unless_null $P799, vivify_902
    die "Contextual $*PACKAGE not found"
  vivify_902:
  vivify_901:
  # rx subrule "ws" subtype=method negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."ws"()
    unless $P10, rx794_fail
    rx794_pos = $P10."pos"()
.annotate 'line', 341
    rx794_cur."!cursor_pos"(rx794_pos)
    find_lex $P803, "%*ATTR-CHECK"
    unless_null $P803, vivify_903
    get_hll_global $P801, "GLOBAL"
    get_who $P802, $P801
    set $P803, $P802["%ATTR-CHECK"]
    unless_null $P803, vivify_904
    die "Contextual %*ATTR-CHECK not found"
  vivify_904:
  vivify_903:
  # rx subrule "ws" subtype=method negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."ws"()
    unless $P10, rx794_fail
    rx794_pos = $P10."pos"()
.annotate 'line', 343
  # rx subrule "name" subtype=capture negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."name"()
    unless $P10, rx794_fail
    rx794_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx794_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."ws"()
    unless $P10, rx794_fail
    rx794_pos = $P10."pos"()
.annotate 'line', 344
  # rx rxquantr806 ** 0..1
    set_addr $I10, rxquantr806_done
    rx794_cur."!mark_push"(0, rx794_pos, $I10)
  rxquantr806_loop:
  # rx subrule "ws" subtype=method negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."ws"()
    unless $P10, rx794_fail
    rx794_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx794_pos, 2
    gt $I11, rx794_eos, rx794_fail
    sub $I11, rx794_pos, rx794_off
    substr $S10, rx794_tgt, $I11, 2
    ne $S10, "is", rx794_fail
    add rx794_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."ws"()
    unless $P10, rx794_fail
    rx794_pos = $P10."pos"()
  # rx literal  "repr("
    add $I11, rx794_pos, 5
    gt $I11, rx794_eos, rx794_fail
    sub $I11, rx794_pos, rx794_off
    substr $S10, rx794_tgt, $I11, 5
    ne $S10, "repr(", rx794_fail
    add rx794_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."ws"()
    unless $P10, rx794_fail
    rx794_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."quote_EXPR"()
    unless $P10, rx794_fail
    rx794_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("repr")
    rx794_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."ws"()
    unless $P10, rx794_fail
    rx794_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx794_pos, 1
    gt $I11, rx794_eos, rx794_fail
    sub $I11, rx794_pos, rx794_off
    ord $I11, rx794_tgt, $I11
    ne $I11, 41, rx794_fail
    add rx794_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."ws"()
    unless $P10, rx794_fail
    rx794_pos = $P10."pos"()
    set_addr $I10, rxquantr806_done
    (rx794_rep) = rx794_cur."!mark_commit"($I10)
  rxquantr806_done:
  # rx subrule "ws" subtype=method negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."ws"()
    unless $P10, rx794_fail
    rx794_pos = $P10."pos"()
.annotate 'line', 346
    rx794_cur."!cursor_pos"(rx794_pos)
    find_lex $P813, unicode:"$\x{a2}"
    $P814 = $P813."MATCH"()
    store_lex "$/", $P814
    .const 'Sub' $P816 = "153_1304456155.152" 
    capture_lex $P816
    $P938 = $P816()
.annotate 'line', 372
  # rx subrule "ws" subtype=method negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."ws"()
    unless $P10, rx794_fail
    rx794_pos = $P10."pos"()
.annotate 'line', 374
  # rx rxquantr940 ** 0..1
    set_addr $I10, rxquantr940_done
    rx794_cur."!mark_push"(0, rx794_pos, $I10)
  rxquantr940_loop:
  # rx subrule "ws" subtype=method negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."ws"()
    unless $P10, rx794_fail
    rx794_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx794_pos, 2
    gt $I11, rx794_eos, rx794_fail
    sub $I11, rx794_pos, rx794_off
    substr $S10, rx794_tgt, $I11, 2
    ne $S10, "is", rx794_fail
    add rx794_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."ws"()
    unless $P10, rx794_fail
    rx794_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."name"()
    unless $P10, rx794_fail
    rx794_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parent")
    rx794_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."ws"()
    unless $P10, rx794_fail
    rx794_pos = $P10."pos"()
    set_addr $I10, rxquantr940_done
    (rx794_rep) = rx794_cur."!mark_commit"($I10)
  rxquantr940_done:
  # rx subrule "ws" subtype=method negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."ws"()
    unless $P10, rx794_fail
    rx794_pos = $P10."pos"()
.annotate 'line', 375
  # rx rxquantr945 ** 0..*
    set_addr $I10, rxquantr945_done
    rx794_cur."!mark_push"(0, rx794_pos, $I10)
  rxquantr945_loop:
  # rx subrule "ws" subtype=method negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."ws"()
    unless $P10, rx794_fail
    rx794_pos = $P10."pos"()
  # rx literal  "does"
    add $I11, rx794_pos, 4
    gt $I11, rx794_eos, rx794_fail
    sub $I11, rx794_pos, rx794_off
    substr $S10, rx794_tgt, $I11, 4
    ne $S10, "does", rx794_fail
    add rx794_pos, 4
  # rx subrule "ws" subtype=method negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."ws"()
    unless $P10, rx794_fail
    rx794_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."name"()
    unless $P10, rx794_fail
    rx794_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("role")
    rx794_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."ws"()
    unless $P10, rx794_fail
    rx794_pos = $P10."pos"()
    set_addr $I10, rxquantr945_done
    (rx794_rep) = rx794_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr945_done
    rx794_cur."!mark_push"(rx794_rep, rx794_pos, $I10)
    goto rxquantr945_loop
  rxquantr945_done:
  # rx subrule "ws" subtype=method negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."ws"()
    unless $P10, rx794_fail
    rx794_pos = $P10."pos"()
  alt950_0:
.annotate 'line', 376
    set_addr $I10, alt950_1
    rx794_cur."!mark_push"(0, rx794_pos, $I10)
.annotate 'line', 377
  # rx subrule "ws" subtype=method negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."ws"()
    unless $P10, rx794_fail
    rx794_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx794_pos, 1
    gt $I11, rx794_eos, rx794_fail
    sub $I11, rx794_pos, rx794_off
    ord $I11, rx794_tgt, $I11
    ne $I11, 59, rx794_fail
    add rx794_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."ws"()
    unless $P10, rx794_fail
    rx794_pos = $P10."pos"()
  # rx subrule "comp_unit" subtype=capture negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."comp_unit"()
    unless $P10, rx794_fail
    rx794_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("comp_unit")
    rx794_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."ws"()
    unless $P10, rx794_fail
    rx794_pos = $P10."pos"()
    goto alt950_end
  alt950_1:
    set_addr $I10, alt950_2
    rx794_cur."!mark_push"(0, rx794_pos, $I10)
.annotate 'line', 378
  # rx subrule "ws" subtype=method negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."ws"()
    unless $P10, rx794_fail
    rx794_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx794_pos, rx794_off
    substr $S10, rx794_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx794_fail
  # rx subrule "ws" subtype=method negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."ws"()
    unless $P10, rx794_fail
    rx794_pos = $P10."pos"()
  # rx subrule "block" subtype=capture negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."block"()
    unless $P10, rx794_fail
    rx794_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx794_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."ws"()
    unless $P10, rx794_fail
    rx794_pos = $P10."pos"()
    goto alt950_end
  alt950_2:
.annotate 'line', 379
  # rx subrule "ws" subtype=method negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."ws"()
    unless $P10, rx794_fail
    rx794_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."panic"("Malformed package declaration")
    unless $P10, rx794_fail
    rx794_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."ws"()
    unless $P10, rx794_fail
    rx794_pos = $P10."pos"()
  alt950_end:
.annotate 'line', 380
  # rx subrule "ws" subtype=method negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."ws"()
    unless $P10, rx794_fail
    rx794_pos = $P10."pos"()
.annotate 'line', 339
  # rx pass
    rx794_cur."!cursor_pass"(rx794_pos, "package_def")
    if_null rx794_debug, debug_972
    rx794_cur."!cursor_debug"("PASS", "package_def", " at pos=", rx794_pos)
  debug_972:
    .return (rx794_cur)
  rx794_restart:
.annotate 'line', 10
    if_null rx794_debug, debug_973
    rx794_cur."!cursor_debug"("NEXT", "package_def")
  debug_973:
  rx794_fail:
    (rx794_rep, rx794_pos, $I10, $P10) = rx794_cur."!mark_fail"(0)
    lt rx794_pos, -1, rx794_done
    eq rx794_pos, -1, rx794_fail
    jump $I10
  rx794_done:
    rx794_cur."!cursor_fail"()
    if_null rx794_debug, debug_974
    rx794_cur."!cursor_debug"("FAIL", "package_def")
  debug_974:
    .return (rx794_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block815"  :anon :subid("153_1304456155.152") :outer("152_1304456155.152")
.annotate 'line', 349
    $P817 = root_new ['parrot';'Hash']
    .lex "%args", $P817
.annotate 'line', 346
    find_lex $P818, "%args"
    unless_null $P818, vivify_905
    $P818 = root_new ['parrot';'Hash']
  vivify_905:
.annotate 'line', 350
    find_lex $P819, "$/"
    unless_null $P819, vivify_906
    $P819 = root_new ['parrot';'Hash']
  vivify_906:
    set $P820, $P819["name"]
    unless_null $P820, vivify_907
    new $P820, "Undef"
  vivify_907:
    set $S821, $P820
    new $P822, 'String'
    set $P822, $S821
    find_lex $P823, "%args"
    unless_null $P823, vivify_908
    $P823 = root_new ['parrot';'Hash']
    store_lex "%args", $P823
  vivify_908:
    set $P823["name"], $P822
.annotate 'line', 351
    find_lex $P825, "$/"
    unless_null $P825, vivify_909
    $P825 = root_new ['parrot';'Hash']
  vivify_909:
    set $P826, $P825["repr"]
    unless_null $P826, vivify_910
    new $P826, "Undef"
  vivify_910:
    unless $P826, if_824_end
.annotate 'line', 352
    find_lex $P827, "$/"
    unless_null $P827, vivify_911
    $P827 = root_new ['parrot';'Hash']
  vivify_911:
    set $P828, $P827["repr"]
    unless_null $P828, vivify_912
    $P828 = root_new ['parrot';'ResizablePMCArray']
  vivify_912:
    set $P829, $P828[0]
    unless_null $P829, vivify_913
    $P829 = root_new ['parrot';'Hash']
  vivify_913:
    set $P830, $P829["quote_delimited"]
    unless_null $P830, vivify_914
    $P830 = root_new ['parrot';'Hash']
  vivify_914:
    set $P831, $P830["quote_atom"]
    unless_null $P831, vivify_915
    $P831 = root_new ['parrot';'ResizablePMCArray']
  vivify_915:
    set $P832, $P831[0]
    unless_null $P832, vivify_916
    new $P832, "Undef"
  vivify_916:
    set $S833, $P832
    new $P834, 'String'
    set $P834, $S833
    find_lex $P835, "%args"
    unless_null $P835, vivify_917
    $P835 = root_new ['parrot';'Hash']
    store_lex "%args", $P835
  vivify_917:
    set $P835["repr"], $P834
  if_824_end:
.annotate 'line', 354
    find_dynamic_lex $P838, "$*SC"
    unless_null $P838, vivify_918
    get_hll_global $P836, "GLOBAL"
    get_who $P837, $P836
    set $P838, $P837["$SC"]
    unless_null $P838, vivify_919
    die "Contextual $*SC not found"
  vivify_919:
  vivify_918:
    find_dynamic_lex $P841, "$*PKGDECL"
    unless_null $P841, vivify_920
    get_hll_global $P839, "GLOBAL"
    get_who $P840, $P839
    set $P841, $P840["$PKGDECL"]
    unless_null $P841, vivify_921
    die "Contextual $*PKGDECL not found"
  vivify_921:
  vivify_920:
    find_dynamic_lex $P844, "%*HOW"
    unless_null $P844, vivify_922
    get_hll_global $P842, "GLOBAL"
    get_who $P843, $P842
    set $P844, $P843["%HOW"]
    unless_null $P844, vivify_923
    die "Contextual %*HOW not found"
  vivify_923:
  vivify_922:
    set $P845, $P844[$P841]
    unless_null $P845, vivify_924
    new $P845, "Undef"
  vivify_924:
    find_lex $P846, "%args"
    unless_null $P846, vivify_925
    $P846 = root_new ['parrot';'Hash']
  vivify_925:
    $P847 = $P838."pkg_create_mo"($P845, $P846 :flat)
    store_dynamic_lex "$*PACKAGE", $P847
.annotate 'line', 357
    find_dynamic_lex $P854, "$*SCOPE"
    unless_null $P854, vivify_926
    get_hll_global $P852, "GLOBAL"
    get_who $P853, $P852
    set $P854, $P853["$SCOPE"]
    unless_null $P854, vivify_927
    die "Contextual $*SCOPE not found"
  vivify_927:
  vivify_926:
    set $S855, $P854
    iseq $I856, $S855, "our"
    unless $I856, unless_851
    new $P850, 'Integer'
    set $P850, $I856
    goto unless_851_end
  unless_851:
    find_dynamic_lex $P859, "$*SCOPE"
    unless_null $P859, vivify_928
    get_hll_global $P857, "GLOBAL"
    get_who $P858, $P857
    set $P859, $P858["$SCOPE"]
    unless_null $P859, vivify_929
    die "Contextual $*SCOPE not found"
  vivify_929:
  vivify_928:
    set $S860, $P859
    iseq $I861, $S860, ""
    new $P850, 'Integer'
    set $P850, $I861
  unless_851_end:
    if $P850, if_849
.annotate 'line', 363
    find_dynamic_lex $P902, "$*SCOPE"
    unless_null $P902, vivify_930
    get_hll_global $P900, "GLOBAL"
    get_who $P901, $P900
    set $P902, $P901["$SCOPE"]
    unless_null $P902, vivify_931
    die "Contextual $*SCOPE not found"
  vivify_931:
  vivify_930:
    set $S903, $P902
    iseq $I904, $S903, "my"
    if $I904, if_899
.annotate 'line', 370
    find_lex $P931, "$/"
    unless_null $P931, vivify_932
    new $P931, "Undef"
  vivify_932:
    $P932 = $P931."CURSOR"()
    find_dynamic_lex $P935, "$*SCOPE"
    unless_null $P935, vivify_933
    get_hll_global $P933, "GLOBAL"
    get_who $P934, $P933
    set $P935, $P934["$SCOPE"]
    unless_null $P935, vivify_934
    die "Contextual $*SCOPE not found"
  vivify_934:
  vivify_933:
    concat $P936, $P935, " scoped packages are not supported"
    $P937 = $P932."panic"($P936)
.annotate 'line', 369
    set $P898, $P937
.annotate 'line', 363
    goto if_899_end
  if_899:
.annotate 'line', 364
    find_lex $P906, "$/"
    unless_null $P906, vivify_935
    $P906 = root_new ['parrot';'Hash']
  vivify_935:
    set $P907, $P906["name"]
    unless_null $P907, vivify_936
    $P907 = root_new ['parrot';'Hash']
  vivify_936:
    set $P908, $P907["identifier"]
    unless_null $P908, vivify_937
    new $P908, "Undef"
  vivify_937:
    set $N909, $P908
    isne $I910, $N909, 1.0
    unless $I910, if_905_end
.annotate 'line', 365
    find_lex $P911, "$/"
    unless_null $P911, vivify_938
    $P911 = root_new ['parrot';'Hash']
  vivify_938:
    set $P912, $P911["name"]
    unless_null $P912, vivify_939
    new $P912, "Undef"
  vivify_939:
    $P913 = $P912."CURSOR"()
    $P913."panic"("A my scoped package cannot have a multi-part name yet")
  if_905_end:
.annotate 'line', 367
    find_dynamic_lex $P916, "$*SC"
    unless_null $P916, vivify_940
    get_hll_global $P914, "GLOBAL"
    get_who $P915, $P914
    set $P916, $P915["$SC"]
    unless_null $P916, vivify_941
    die "Contextual $*SC not found"
  vivify_941:
  vivify_940:
    get_hll_global $P917, "GLOBAL"
    nqp_get_package_through_who $P918, $P917, "NQP"
    nqp_get_package_through_who $P919, $P918, "Actions"
    get_who $P920, $P919
    set $P921, $P920["@BLOCK"]
    unless_null $P921, vivify_942
    $P921 = root_new ['parrot';'ResizablePMCArray']
  vivify_942:
    set $P922, $P921[0]
    unless_null $P922, vivify_943
    new $P922, "Undef"
  vivify_943:
    find_lex $P923, "$/"
    unless_null $P923, vivify_944
    $P923 = root_new ['parrot';'Hash']
  vivify_944:
    set $P924, $P923["name"]
    unless_null $P924, vivify_945
    $P924 = root_new ['parrot';'Hash']
  vivify_945:
    set $P925, $P924["identifier"]
    unless_null $P925, vivify_946
    $P925 = root_new ['parrot';'ResizablePMCArray']
  vivify_946:
    set $P926, $P925[0]
    unless_null $P926, vivify_947
    new $P926, "Undef"
  vivify_947:
    find_dynamic_lex $P929, "$*PACKAGE"
    unless_null $P929, vivify_948
    get_hll_global $P927, "GLOBAL"
    get_who $P928, $P927
    set $P929, $P928["$PACKAGE"]
    unless_null $P929, vivify_949
    die "Contextual $*PACKAGE not found"
  vivify_949:
  vivify_948:
    $P930 = $P916."install_lexical_symbol"($P922, $P926, $P929)
.annotate 'line', 363
    set $P898, $P930
  if_899_end:
    set $P848, $P898
.annotate 'line', 357
    goto if_849_end
  if_849:
.annotate 'line', 358
    find_dynamic_lex $P864, "$*SC"
    unless_null $P864, vivify_950
    get_hll_global $P862, "GLOBAL"
    get_who $P863, $P862
    set $P864, $P863["$SC"]
    unless_null $P864, vivify_951
    die "Contextual $*SC not found"
  vivify_951:
  vivify_950:
    find_dynamic_lex $P867, "$*OUTERPACKAGE"
    unless_null $P867, vivify_952
    get_hll_global $P865, "GLOBAL"
    get_who $P866, $P865
    set $P867, $P866["$OUTERPACKAGE"]
    unless_null $P867, vivify_953
    die "Contextual $*OUTERPACKAGE not found"
  vivify_953:
  vivify_952:
    find_lex $P868, "$/"
    unless_null $P868, vivify_954
    $P868 = root_new ['parrot';'Hash']
  vivify_954:
    set $P869, $P868["name"]
    unless_null $P869, vivify_955
    $P869 = root_new ['parrot';'Hash']
  vivify_955:
    set $P870, $P869["identifier"]
    unless_null $P870, vivify_956
    new $P870, "Undef"
  vivify_956:
    find_dynamic_lex $P873, "$*PACKAGE"
    unless_null $P873, vivify_957
    get_hll_global $P871, "GLOBAL"
    get_who $P872, $P871
    set $P873, $P872["$PACKAGE"]
    unless_null $P873, vivify_958
    die "Contextual $*PACKAGE not found"
  vivify_958:
  vivify_957:
    $P864."install_package_symbol"($P867, $P870, $P873)
.annotate 'line', 359
    find_lex $P876, "$/"
    unless_null $P876, vivify_959
    $P876 = root_new ['parrot';'Hash']
  vivify_959:
    set $P877, $P876["name"]
    unless_null $P877, vivify_960
    $P877 = root_new ['parrot';'Hash']
  vivify_960:
    set $P878, $P877["identifier"]
    unless_null $P878, vivify_961
    new $P878, "Undef"
  vivify_961:
    set $N879, $P878
    iseq $I880, $N879, 1.0
    if $I880, if_875
    new $P874, 'Integer'
    set $P874, $I880
    goto if_875_end
  if_875:
.annotate 'line', 360
    find_dynamic_lex $P883, "$*SC"
    unless_null $P883, vivify_962
    get_hll_global $P881, "GLOBAL"
    get_who $P882, $P881
    set $P883, $P882["$SC"]
    unless_null $P883, vivify_963
    die "Contextual $*SC not found"
  vivify_963:
  vivify_962:
    get_hll_global $P884, "GLOBAL"
    nqp_get_package_through_who $P885, $P884, "NQP"
    nqp_get_package_through_who $P886, $P885, "Actions"
    get_who $P887, $P886
    set $P888, $P887["@BLOCK"]
    unless_null $P888, vivify_964
    $P888 = root_new ['parrot';'ResizablePMCArray']
  vivify_964:
    set $P889, $P888[0]
    unless_null $P889, vivify_965
    new $P889, "Undef"
  vivify_965:
    find_lex $P890, "$/"
    unless_null $P890, vivify_966
    $P890 = root_new ['parrot';'Hash']
  vivify_966:
    set $P891, $P890["name"]
    unless_null $P891, vivify_967
    $P891 = root_new ['parrot';'Hash']
  vivify_967:
    set $P892, $P891["identifier"]
    unless_null $P892, vivify_968
    $P892 = root_new ['parrot';'ResizablePMCArray']
  vivify_968:
    set $P893, $P892[0]
    unless_null $P893, vivify_969
    new $P893, "Undef"
  vivify_969:
    find_dynamic_lex $P896, "$*PACKAGE"
    unless_null $P896, vivify_970
    get_hll_global $P894, "GLOBAL"
    get_who $P895, $P894
    set $P896, $P895["$PACKAGE"]
    unless_null $P896, vivify_971
    die "Contextual $*PACKAGE not found"
  vivify_971:
  vivify_970:
    $P897 = $P883."install_lexical_symbol"($P889, $P893, $P896)
.annotate 'line', 359
    set $P874, $P897
  if_875_end:
.annotate 'line', 357
    set $P848, $P874
  if_849_end:
.annotate 'line', 346
    .return ($P848)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_def"  :subid("154_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P961 = self."!PREFIX__!subrule"("ws", "")
    new $P962, "ResizablePMCArray"
    push $P962, $P961
    .return ($P962)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator"  :subid("155_1304456155.152")
    .param pmc param_964
.annotate 'line', 383
    .lex "self", param_964
    $P965 = param_964."!protoregex"("scope_declarator")
    .return ($P965)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator"  :subid("156_1304456155.152")
    .param pmc param_967
.annotate 'line', 383
    .lex "self", param_967
    $P968 = param_967."!PREFIX__!protoregex"("scope_declarator")
    .return ($P968)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<my>"  :subid("157_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx970_tgt
    .local int rx970_pos
    .local int rx970_off
    .local int rx970_eos
    .local int rx970_rep
    .local pmc rx970_cur
    .local pmc rx970_debug
    (rx970_cur, rx970_pos, rx970_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx970_cur
    .local pmc match
    .lex "$/", match
    length rx970_eos, rx970_tgt
    gt rx970_pos, rx970_eos, rx970_done
    set rx970_off, 0
    lt rx970_pos, 2, rx970_start
    sub rx970_off, rx970_pos, 1
    substr rx970_tgt, rx970_tgt, rx970_off
  rx970_start:
    eq $I10, 1, rx970_restart
    if_null rx970_debug, debug_975
    rx970_cur."!cursor_debug"("START", "scope_declarator:sym<my>")
  debug_975:
    $I10 = self.'from'()
    ne $I10, -1, rxscan971_done
    goto rxscan971_scan
  rxscan971_loop:
    (rx970_pos) = rx970_cur."from"()
    inc rx970_pos
    rx970_cur."!cursor_from"(rx970_pos)
    ge rx970_pos, rx970_eos, rxscan971_done
  rxscan971_scan:
    set_addr $I10, rxscan971_loop
    rx970_cur."!mark_push"(0, rx970_pos, $I10)
  rxscan971_done:
.annotate 'line', 384
  # rx subcapture "sym"
    set_addr $I10, rxcap_972_fail
    rx970_cur."!mark_push"(0, rx970_pos, $I10)
  # rx literal  "my"
    add $I11, rx970_pos, 2
    gt $I11, rx970_eos, rx970_fail
    sub $I11, rx970_pos, rx970_off
    substr $S10, rx970_tgt, $I11, 2
    ne $S10, "my", rx970_fail
    add rx970_pos, 2
    set_addr $I10, rxcap_972_fail
    ($I12, $I11) = rx970_cur."!mark_peek"($I10)
    rx970_cur."!cursor_pos"($I11)
    ($P10) = rx970_cur."!cursor_start"()
    $P10."!cursor_pass"(rx970_pos, "")
    rx970_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_972_done
  rxcap_972_fail:
    goto rx970_fail
  rxcap_972_done:
  # rx subrule "scoped" subtype=capture negate=
    rx970_cur."!cursor_pos"(rx970_pos)
    $P10 = rx970_cur."scoped"("my")
    unless $P10, rx970_fail
    rx970_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx970_pos = $P10."pos"()
  # rx pass
    rx970_cur."!cursor_pass"(rx970_pos, "scope_declarator:sym<my>")
    if_null rx970_debug, debug_976
    rx970_cur."!cursor_debug"("PASS", "scope_declarator:sym<my>", " at pos=", rx970_pos)
  debug_976:
    .return (rx970_cur)
  rx970_restart:
.annotate 'line', 10
    if_null rx970_debug, debug_977
    rx970_cur."!cursor_debug"("NEXT", "scope_declarator:sym<my>")
  debug_977:
  rx970_fail:
    (rx970_rep, rx970_pos, $I10, $P10) = rx970_cur."!mark_fail"(0)
    lt rx970_pos, -1, rx970_done
    eq rx970_pos, -1, rx970_fail
    jump $I10
  rx970_done:
    rx970_cur."!cursor_fail"()
    if_null rx970_debug, debug_978
    rx970_cur."!cursor_debug"("FAIL", "scope_declarator:sym<my>")
  debug_978:
    .return (rx970_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<my>"  :subid("158_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P974 = self."!PREFIX__!subrule"("scoped", "my")
    new $P975, "ResizablePMCArray"
    push $P975, $P974
    .return ($P975)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<our>"  :subid("159_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx977_tgt
    .local int rx977_pos
    .local int rx977_off
    .local int rx977_eos
    .local int rx977_rep
    .local pmc rx977_cur
    .local pmc rx977_debug
    (rx977_cur, rx977_pos, rx977_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx977_cur
    .local pmc match
    .lex "$/", match
    length rx977_eos, rx977_tgt
    gt rx977_pos, rx977_eos, rx977_done
    set rx977_off, 0
    lt rx977_pos, 2, rx977_start
    sub rx977_off, rx977_pos, 1
    substr rx977_tgt, rx977_tgt, rx977_off
  rx977_start:
    eq $I10, 1, rx977_restart
    if_null rx977_debug, debug_979
    rx977_cur."!cursor_debug"("START", "scope_declarator:sym<our>")
  debug_979:
    $I10 = self.'from'()
    ne $I10, -1, rxscan978_done
    goto rxscan978_scan
  rxscan978_loop:
    (rx977_pos) = rx977_cur."from"()
    inc rx977_pos
    rx977_cur."!cursor_from"(rx977_pos)
    ge rx977_pos, rx977_eos, rxscan978_done
  rxscan978_scan:
    set_addr $I10, rxscan978_loop
    rx977_cur."!mark_push"(0, rx977_pos, $I10)
  rxscan978_done:
.annotate 'line', 385
  # rx subcapture "sym"
    set_addr $I10, rxcap_979_fail
    rx977_cur."!mark_push"(0, rx977_pos, $I10)
  # rx literal  "our"
    add $I11, rx977_pos, 3
    gt $I11, rx977_eos, rx977_fail
    sub $I11, rx977_pos, rx977_off
    substr $S10, rx977_tgt, $I11, 3
    ne $S10, "our", rx977_fail
    add rx977_pos, 3
    set_addr $I10, rxcap_979_fail
    ($I12, $I11) = rx977_cur."!mark_peek"($I10)
    rx977_cur."!cursor_pos"($I11)
    ($P10) = rx977_cur."!cursor_start"()
    $P10."!cursor_pass"(rx977_pos, "")
    rx977_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_979_done
  rxcap_979_fail:
    goto rx977_fail
  rxcap_979_done:
  # rx subrule "scoped" subtype=capture negate=
    rx977_cur."!cursor_pos"(rx977_pos)
    $P10 = rx977_cur."scoped"("our")
    unless $P10, rx977_fail
    rx977_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx977_pos = $P10."pos"()
  # rx pass
    rx977_cur."!cursor_pass"(rx977_pos, "scope_declarator:sym<our>")
    if_null rx977_debug, debug_980
    rx977_cur."!cursor_debug"("PASS", "scope_declarator:sym<our>", " at pos=", rx977_pos)
  debug_980:
    .return (rx977_cur)
  rx977_restart:
.annotate 'line', 10
    if_null rx977_debug, debug_981
    rx977_cur."!cursor_debug"("NEXT", "scope_declarator:sym<our>")
  debug_981:
  rx977_fail:
    (rx977_rep, rx977_pos, $I10, $P10) = rx977_cur."!mark_fail"(0)
    lt rx977_pos, -1, rx977_done
    eq rx977_pos, -1, rx977_fail
    jump $I10
  rx977_done:
    rx977_cur."!cursor_fail"()
    if_null rx977_debug, debug_982
    rx977_cur."!cursor_debug"("FAIL", "scope_declarator:sym<our>")
  debug_982:
    .return (rx977_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<our>"  :subid("160_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P981 = self."!PREFIX__!subrule"("scoped", "our")
    new $P982, "ResizablePMCArray"
    push $P982, $P981
    .return ($P982)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<has>"  :subid("161_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx984_tgt
    .local int rx984_pos
    .local int rx984_off
    .local int rx984_eos
    .local int rx984_rep
    .local pmc rx984_cur
    .local pmc rx984_debug
    (rx984_cur, rx984_pos, rx984_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx984_cur
    .local pmc match
    .lex "$/", match
    length rx984_eos, rx984_tgt
    gt rx984_pos, rx984_eos, rx984_done
    set rx984_off, 0
    lt rx984_pos, 2, rx984_start
    sub rx984_off, rx984_pos, 1
    substr rx984_tgt, rx984_tgt, rx984_off
  rx984_start:
    eq $I10, 1, rx984_restart
    if_null rx984_debug, debug_983
    rx984_cur."!cursor_debug"("START", "scope_declarator:sym<has>")
  debug_983:
    $I10 = self.'from'()
    ne $I10, -1, rxscan985_done
    goto rxscan985_scan
  rxscan985_loop:
    (rx984_pos) = rx984_cur."from"()
    inc rx984_pos
    rx984_cur."!cursor_from"(rx984_pos)
    ge rx984_pos, rx984_eos, rxscan985_done
  rxscan985_scan:
    set_addr $I10, rxscan985_loop
    rx984_cur."!mark_push"(0, rx984_pos, $I10)
  rxscan985_done:
.annotate 'line', 386
  # rx subcapture "sym"
    set_addr $I10, rxcap_986_fail
    rx984_cur."!mark_push"(0, rx984_pos, $I10)
  # rx literal  "has"
    add $I11, rx984_pos, 3
    gt $I11, rx984_eos, rx984_fail
    sub $I11, rx984_pos, rx984_off
    substr $S10, rx984_tgt, $I11, 3
    ne $S10, "has", rx984_fail
    add rx984_pos, 3
    set_addr $I10, rxcap_986_fail
    ($I12, $I11) = rx984_cur."!mark_peek"($I10)
    rx984_cur."!cursor_pos"($I11)
    ($P10) = rx984_cur."!cursor_start"()
    $P10."!cursor_pass"(rx984_pos, "")
    rx984_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_986_done
  rxcap_986_fail:
    goto rx984_fail
  rxcap_986_done:
  # rx subrule "scoped" subtype=capture negate=
    rx984_cur."!cursor_pos"(rx984_pos)
    $P10 = rx984_cur."scoped"("has")
    unless $P10, rx984_fail
    rx984_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx984_pos = $P10."pos"()
  # rx pass
    rx984_cur."!cursor_pass"(rx984_pos, "scope_declarator:sym<has>")
    if_null rx984_debug, debug_984
    rx984_cur."!cursor_debug"("PASS", "scope_declarator:sym<has>", " at pos=", rx984_pos)
  debug_984:
    .return (rx984_cur)
  rx984_restart:
.annotate 'line', 10
    if_null rx984_debug, debug_985
    rx984_cur."!cursor_debug"("NEXT", "scope_declarator:sym<has>")
  debug_985:
  rx984_fail:
    (rx984_rep, rx984_pos, $I10, $P10) = rx984_cur."!mark_fail"(0)
    lt rx984_pos, -1, rx984_done
    eq rx984_pos, -1, rx984_fail
    jump $I10
  rx984_done:
    rx984_cur."!cursor_fail"()
    if_null rx984_debug, debug_986
    rx984_cur."!cursor_debug"("FAIL", "scope_declarator:sym<has>")
  debug_986:
    .return (rx984_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<has>"  :subid("162_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P988 = self."!PREFIX__!subrule"("scoped", "has")
    new $P989, "ResizablePMCArray"
    push $P989, $P988
    .return ($P989)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scoped"  :subid("163_1304456155.152") :method :outer("12_1304456155.152")
    .param pmc param_991
.annotate 'line', 388
    .lex "$*SCOPE", param_991
.annotate 'line', 10
    .local string rx992_tgt
    .local int rx992_pos
    .local int rx992_off
    .local int rx992_eos
    .local int rx992_rep
    .local pmc rx992_cur
    .local pmc rx992_debug
    (rx992_cur, rx992_pos, rx992_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx992_cur
    .local pmc match
    .lex "$/", match
    length rx992_eos, rx992_tgt
    gt rx992_pos, rx992_eos, rx992_done
    set rx992_off, 0
    lt rx992_pos, 2, rx992_start
    sub rx992_off, rx992_pos, 1
    substr rx992_tgt, rx992_tgt, rx992_off
  rx992_start:
    eq $I10, 1, rx992_restart
    if_null rx992_debug, debug_987
    rx992_cur."!cursor_debug"("START", "scoped")
  debug_987:
    $I10 = self.'from'()
    ne $I10, -1, rxscan993_done
    goto rxscan993_scan
  rxscan993_loop:
    (rx992_pos) = rx992_cur."from"()
    inc rx992_pos
    rx992_cur."!cursor_from"(rx992_pos)
    ge rx992_pos, rx992_eos, rxscan993_done
  rxscan993_scan:
    set_addr $I10, rxscan993_loop
    rx992_cur."!mark_push"(0, rx992_pos, $I10)
  rxscan993_done:
  alt994_0:
.annotate 'line', 388
    set_addr $I10, alt994_1
    rx992_cur."!mark_push"(0, rx992_pos, $I10)
.annotate 'line', 389
  # rx subrule "ws" subtype=method negate=
    rx992_cur."!cursor_pos"(rx992_pos)
    $P10 = rx992_cur."ws"()
    unless $P10, rx992_fail
    rx992_pos = $P10."pos"()
  # rx subrule "declarator" subtype=capture negate=
    rx992_cur."!cursor_pos"(rx992_pos)
    $P10 = rx992_cur."declarator"()
    unless $P10, rx992_fail
    rx992_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx992_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx992_cur."!cursor_pos"(rx992_pos)
    $P10 = rx992_cur."ws"()
    unless $P10, rx992_fail
    rx992_pos = $P10."pos"()
    goto alt994_end
  alt994_1:
    set_addr $I10, alt994_2
    rx992_cur."!mark_push"(0, rx992_pos, $I10)
.annotate 'line', 390
  # rx subrule "ws" subtype=method negate=
    rx992_cur."!cursor_pos"(rx992_pos)
    $P10 = rx992_cur."ws"()
    unless $P10, rx992_fail
    rx992_pos = $P10."pos"()
  # rx subrule "multi_declarator" subtype=capture negate=
    rx992_cur."!cursor_pos"(rx992_pos)
    $P10 = rx992_cur."multi_declarator"()
    unless $P10, rx992_fail
    rx992_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx992_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx992_cur."!cursor_pos"(rx992_pos)
    $P10 = rx992_cur."ws"()
    unless $P10, rx992_fail
    rx992_pos = $P10."pos"()
    goto alt994_end
  alt994_2:
.annotate 'line', 391
  # rx subrule "ws" subtype=method negate=
    rx992_cur."!cursor_pos"(rx992_pos)
    $P10 = rx992_cur."ws"()
    unless $P10, rx992_fail
    rx992_pos = $P10."pos"()
  # rx subrule "package_declarator" subtype=capture negate=
    rx992_cur."!cursor_pos"(rx992_pos)
    $P10 = rx992_cur."package_declarator"()
    unless $P10, rx992_fail
    rx992_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx992_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx992_cur."!cursor_pos"(rx992_pos)
    $P10 = rx992_cur."ws"()
    unless $P10, rx992_fail
    rx992_pos = $P10."pos"()
  alt994_end:
.annotate 'line', 388
  # rx pass
    rx992_cur."!cursor_pass"(rx992_pos, "scoped")
    if_null rx992_debug, debug_988
    rx992_cur."!cursor_debug"("PASS", "scoped", " at pos=", rx992_pos)
  debug_988:
    .return (rx992_cur)
  rx992_restart:
.annotate 'line', 10
    if_null rx992_debug, debug_989
    rx992_cur."!cursor_debug"("NEXT", "scoped")
  debug_989:
  rx992_fail:
    (rx992_rep, rx992_pos, $I10, $P10) = rx992_cur."!mark_fail"(0)
    lt rx992_pos, -1, rx992_done
    eq rx992_pos, -1, rx992_fail
    jump $I10
  rx992_done:
    rx992_cur."!cursor_fail"()
    if_null rx992_debug, debug_990
    rx992_cur."!cursor_debug"("FAIL", "scoped")
  debug_990:
    .return (rx992_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scoped"  :subid("164_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1002 = self."!PREFIX__!subrule"("ws", "")
    $P1003 = self."!PREFIX__!subrule"("ws", "")
    $P1004 = self."!PREFIX__!subrule"("ws", "")
    new $P1005, "ResizablePMCArray"
    push $P1005, $P1002
    push $P1005, $P1003
    push $P1005, $P1004
    .return ($P1005)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "typename"  :subid("165_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .const 'Sub' $P1012 = "166_1304456155.152" 
    capture_lex $P1012
    .local string rx1007_tgt
    .local int rx1007_pos
    .local int rx1007_off
    .local int rx1007_eos
    .local int rx1007_rep
    .local pmc rx1007_cur
    .local pmc rx1007_debug
    (rx1007_cur, rx1007_pos, rx1007_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1007_cur
    .local pmc match
    .lex "$/", match
    length rx1007_eos, rx1007_tgt
    gt rx1007_pos, rx1007_eos, rx1007_done
    set rx1007_off, 0
    lt rx1007_pos, 2, rx1007_start
    sub rx1007_off, rx1007_pos, 1
    substr rx1007_tgt, rx1007_tgt, rx1007_off
  rx1007_start:
    eq $I10, 1, rx1007_restart
    if_null rx1007_debug, debug_991
    rx1007_cur."!cursor_debug"("START", "typename")
  debug_991:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1008_done
    goto rxscan1008_scan
  rxscan1008_loop:
    (rx1007_pos) = rx1007_cur."from"()
    inc rx1007_pos
    rx1007_cur."!cursor_from"(rx1007_pos)
    ge rx1007_pos, rx1007_eos, rxscan1008_done
  rxscan1008_scan:
    set_addr $I10, rxscan1008_loop
    rx1007_cur."!mark_push"(0, rx1007_pos, $I10)
  rxscan1008_done:
.annotate 'line', 395
  # rx subrule "name" subtype=capture negate=
    rx1007_cur."!cursor_pos"(rx1007_pos)
    $P10 = rx1007_cur."name"()
    unless $P10, rx1007_fail
    rx1007_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1007_pos = $P10."pos"()
.annotate 'line', 396
    rx1007_cur."!cursor_pos"(rx1007_pos)
    find_lex $P1009, unicode:"$\x{a2}"
    $P1010 = $P1009."MATCH"()
    store_lex "$/", $P1010
    .const 'Sub' $P1012 = "166_1304456155.152" 
    capture_lex $P1012
    $P1021 = $P1012()
    unless $P1021, rx1007_fail
.annotate 'line', 394
  # rx pass
    rx1007_cur."!cursor_pass"(rx1007_pos, "typename")
    if_null rx1007_debug, debug_998
    rx1007_cur."!cursor_debug"("PASS", "typename", " at pos=", rx1007_pos)
  debug_998:
    .return (rx1007_cur)
  rx1007_restart:
.annotate 'line', 10
    if_null rx1007_debug, debug_999
    rx1007_cur."!cursor_debug"("NEXT", "typename")
  debug_999:
  rx1007_fail:
    (rx1007_rep, rx1007_pos, $I10, $P10) = rx1007_cur."!mark_fail"(0)
    lt rx1007_pos, -1, rx1007_done
    eq rx1007_pos, -1, rx1007_fail
    jump $I10
  rx1007_done:
    rx1007_cur."!cursor_fail"()
    if_null rx1007_debug, debug_1000
    rx1007_cur."!cursor_debug"("FAIL", "typename")
  debug_1000:
    .return (rx1007_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1011"  :anon :subid("166_1304456155.152") :outer("165_1304456155.152")
.annotate 'line', 396
    find_dynamic_lex $P1015, "$*ACTIONS"
    unless_null $P1015, vivify_992
    get_hll_global $P1013, "GLOBAL"
    get_who $P1014, $P1013
    set $P1015, $P1014["$ACTIONS"]
    unless_null $P1015, vivify_993
    die "Contextual $*ACTIONS not found"
  vivify_993:
  vivify_992:
    find_lex $P1016, "$/"
    unless_null $P1016, vivify_994
    new $P1016, "Undef"
  vivify_994:
    find_lex $P1017, "$/"
    unless_null $P1017, vivify_995
    $P1017 = root_new ['parrot';'Hash']
  vivify_995:
    set $P1018, $P1017["name"]
    unless_null $P1018, vivify_996
    $P1018 = root_new ['parrot';'Hash']
  vivify_996:
    set $P1019, $P1018["identifier"]
    unless_null $P1019, vivify_997
    new $P1019, "Undef"
  vivify_997:
    $P1020 = $P1015."known_sym"($P1016, $P1019)
    .return ($P1020)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__typename"  :subid("167_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1023 = self."!PREFIX__!subrule"("name", "")
    new $P1024, "ResizablePMCArray"
    push $P1024, $P1023
    .return ($P1024)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "declarator"  :subid("168_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1026_tgt
    .local int rx1026_pos
    .local int rx1026_off
    .local int rx1026_eos
    .local int rx1026_rep
    .local pmc rx1026_cur
    .local pmc rx1026_debug
    (rx1026_cur, rx1026_pos, rx1026_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1026_cur
    .local pmc match
    .lex "$/", match
    length rx1026_eos, rx1026_tgt
    gt rx1026_pos, rx1026_eos, rx1026_done
    set rx1026_off, 0
    lt rx1026_pos, 2, rx1026_start
    sub rx1026_off, rx1026_pos, 1
    substr rx1026_tgt, rx1026_tgt, rx1026_off
  rx1026_start:
    eq $I10, 1, rx1026_restart
    if_null rx1026_debug, debug_1001
    rx1026_cur."!cursor_debug"("START", "declarator")
  debug_1001:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1027_done
    goto rxscan1027_scan
  rxscan1027_loop:
    (rx1026_pos) = rx1026_cur."from"()
    inc rx1026_pos
    rx1026_cur."!cursor_from"(rx1026_pos)
    ge rx1026_pos, rx1026_eos, rxscan1027_done
  rxscan1027_scan:
    set_addr $I10, rxscan1027_loop
    rx1026_cur."!mark_push"(0, rx1026_pos, $I10)
  rxscan1027_done:
  alt1028_0:
.annotate 'line', 399
    set_addr $I10, alt1028_1
    rx1026_cur."!mark_push"(0, rx1026_pos, $I10)
.annotate 'line', 400
  # rx subrule "variable_declarator" subtype=capture negate=
    rx1026_cur."!cursor_pos"(rx1026_pos)
    $P10 = rx1026_cur."variable_declarator"()
    unless $P10, rx1026_fail
    rx1026_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable_declarator")
    rx1026_pos = $P10."pos"()
    goto alt1028_end
  alt1028_1:
.annotate 'line', 401
  # rx subrule "routine_declarator" subtype=capture negate=
    rx1026_cur."!cursor_pos"(rx1026_pos)
    $P10 = rx1026_cur."routine_declarator"()
    unless $P10, rx1026_fail
    rx1026_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx1026_pos = $P10."pos"()
  alt1028_end:
.annotate 'line', 399
  # rx pass
    rx1026_cur."!cursor_pass"(rx1026_pos, "declarator")
    if_null rx1026_debug, debug_1002
    rx1026_cur."!cursor_debug"("PASS", "declarator", " at pos=", rx1026_pos)
  debug_1002:
    .return (rx1026_cur)
  rx1026_restart:
.annotate 'line', 10
    if_null rx1026_debug, debug_1003
    rx1026_cur."!cursor_debug"("NEXT", "declarator")
  debug_1003:
  rx1026_fail:
    (rx1026_rep, rx1026_pos, $I10, $P10) = rx1026_cur."!mark_fail"(0)
    lt rx1026_pos, -1, rx1026_done
    eq rx1026_pos, -1, rx1026_fail
    jump $I10
  rx1026_done:
    rx1026_cur."!cursor_fail"()
    if_null rx1026_debug, debug_1004
    rx1026_cur."!cursor_debug"("FAIL", "declarator")
  debug_1004:
    .return (rx1026_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__declarator"  :subid("169_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1030 = self."!PREFIX__!subrule"("routine_declarator", "")
    $P1031 = self."!PREFIX__!subrule"("variable_declarator", "")
    new $P1032, "ResizablePMCArray"
    push $P1032, $P1030
    push $P1032, $P1031
    .return ($P1032)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable_declarator"  :subid("170_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .const 'Sub' $P1047 = "171_1304456155.152" 
    capture_lex $P1047
.annotate 'line', 406
    new $P1034, "Undef"
    .lex "$*IN_DECL", $P1034
.annotate 'line', 10
    .local string rx1035_tgt
    .local int rx1035_pos
    .local int rx1035_off
    .local int rx1035_eos
    .local int rx1035_rep
    .local pmc rx1035_cur
    .local pmc rx1035_debug
    (rx1035_cur, rx1035_pos, rx1035_tgt, $I10) = self."!cursor_start"()
    rx1035_cur."!cursor_caparray"("typename")
    .lex unicode:"$\x{a2}", rx1035_cur
    .local pmc match
    .lex "$/", match
    length rx1035_eos, rx1035_tgt
    gt rx1035_pos, rx1035_eos, rx1035_done
    set rx1035_off, 0
    lt rx1035_pos, 2, rx1035_start
    sub rx1035_off, rx1035_pos, 1
    substr rx1035_tgt, rx1035_tgt, rx1035_off
  rx1035_start:
    eq $I10, 1, rx1035_restart
    if_null rx1035_debug, debug_1005
    rx1035_cur."!cursor_debug"("START", "variable_declarator")
  debug_1005:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1036_done
    goto rxscan1036_scan
  rxscan1036_loop:
    (rx1035_pos) = rx1035_cur."from"()
    inc rx1035_pos
    rx1035_cur."!cursor_from"(rx1035_pos)
    ge rx1035_pos, rx1035_eos, rxscan1036_done
  rxscan1036_scan:
    set_addr $I10, rxscan1036_loop
    rx1035_cur."!mark_push"(0, rx1035_pos, $I10)
  rxscan1036_done:
.annotate 'line', 404
  # rx subrule "ws" subtype=method negate=
    rx1035_cur."!cursor_pos"(rx1035_pos)
    $P10 = rx1035_cur."ws"()
    unless $P10, rx1035_fail
    rx1035_pos = $P10."pos"()
.annotate 'line', 405
  # rx rxquantr1038 ** 0..1
    set_addr $I10, rxquantr1038_done
    rx1035_cur."!mark_push"(0, rx1035_pos, $I10)
  rxquantr1038_loop:
  # rx subrule "typename" subtype=capture negate=
    rx1035_cur."!cursor_pos"(rx1035_pos)
    $P10 = rx1035_cur."typename"()
    unless $P10, rx1035_fail
    goto rxsubrule1039_pass
  rxsubrule1039_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1035_fail
  rxsubrule1039_pass:
    set_addr $I10, rxsubrule1039_back
    rx1035_cur."!mark_push"(0, rx1035_pos, $I10, $P10)
    $P10."!cursor_names"("typename")
    rx1035_pos = $P10."pos"()
    set_addr $I10, rxquantr1038_done
    (rx1035_rep) = rx1035_cur."!mark_commit"($I10)
  rxquantr1038_done:
  # rx subrule "ws" subtype=method negate=
    rx1035_cur."!cursor_pos"(rx1035_pos)
    $P10 = rx1035_cur."ws"()
    unless $P10, rx1035_fail
    rx1035_pos = $P10."pos"()
.annotate 'line', 406
    rx1035_cur."!cursor_pos"(rx1035_pos)
    new $P1041, "String"
    assign $P1041, "variable"
    store_lex "$*IN_DECL", $P1041
  # rx subrule "ws" subtype=method negate=
    rx1035_cur."!cursor_pos"(rx1035_pos)
    $P10 = rx1035_cur."ws"()
    unless $P10, rx1035_fail
    rx1035_pos = $P10."pos"()
.annotate 'line', 407
  # rx subrule "variable" subtype=capture negate=
    rx1035_cur."!cursor_pos"(rx1035_pos)
    $P10 = rx1035_cur."variable"()
    unless $P10, rx1035_fail
    rx1035_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx1035_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1035_cur."!cursor_pos"(rx1035_pos)
    $P10 = rx1035_cur."ws"()
    unless $P10, rx1035_fail
    rx1035_pos = $P10."pos"()
.annotate 'line', 408
    rx1035_cur."!cursor_pos"(rx1035_pos)
    find_lex $P1044, unicode:"$\x{a2}"
    $P1045 = $P1044."MATCH"()
    store_lex "$/", $P1045
    .const 'Sub' $P1047 = "171_1304456155.152" 
    capture_lex $P1047
    $P1049 = $P1047()
  # rx subrule "ws" subtype=method negate=
    rx1035_cur."!cursor_pos"(rx1035_pos)
    $P10 = rx1035_cur."ws"()
    unless $P10, rx1035_fail
    rx1035_pos = $P10."pos"()
.annotate 'line', 404
  # rx pass
    rx1035_cur."!cursor_pass"(rx1035_pos, "variable_declarator")
    if_null rx1035_debug, debug_1006
    rx1035_cur."!cursor_debug"("PASS", "variable_declarator", " at pos=", rx1035_pos)
  debug_1006:
    .return (rx1035_cur)
  rx1035_restart:
.annotate 'line', 10
    if_null rx1035_debug, debug_1007
    rx1035_cur."!cursor_debug"("NEXT", "variable_declarator")
  debug_1007:
  rx1035_fail:
    (rx1035_rep, rx1035_pos, $I10, $P10) = rx1035_cur."!mark_fail"(0)
    lt rx1035_pos, -1, rx1035_done
    eq rx1035_pos, -1, rx1035_fail
    jump $I10
  rx1035_done:
    rx1035_cur."!cursor_fail"()
    if_null rx1035_debug, debug_1008
    rx1035_cur."!cursor_debug"("FAIL", "variable_declarator")
  debug_1008:
    .return (rx1035_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1046"  :anon :subid("171_1304456155.152") :outer("170_1304456155.152")
.annotate 'line', 408
    new $P1048, "Integer"
    assign $P1048, 0
    store_dynamic_lex "$*IN_DECL", $P1048
    .return ($P1048)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable_declarator"  :subid("172_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1052 = self."!PREFIX__!subrule"("ws", "")
    new $P1053, "ResizablePMCArray"
    push $P1053, $P1052
    .return ($P1053)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator"  :subid("173_1304456155.152")
    .param pmc param_1055
.annotate 'line', 411
    .lex "self", param_1055
    $P1056 = param_1055."!protoregex"("routine_declarator")
    .return ($P1056)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator"  :subid("174_1304456155.152")
    .param pmc param_1058
.annotate 'line', 411
    .lex "self", param_1058
    $P1059 = param_1058."!PREFIX__!protoregex"("routine_declarator")
    .return ($P1059)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<sub>"  :subid("175_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1061_tgt
    .local int rx1061_pos
    .local int rx1061_off
    .local int rx1061_eos
    .local int rx1061_rep
    .local pmc rx1061_cur
    .local pmc rx1061_debug
    (rx1061_cur, rx1061_pos, rx1061_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1061_cur
    .local pmc match
    .lex "$/", match
    length rx1061_eos, rx1061_tgt
    gt rx1061_pos, rx1061_eos, rx1061_done
    set rx1061_off, 0
    lt rx1061_pos, 2, rx1061_start
    sub rx1061_off, rx1061_pos, 1
    substr rx1061_tgt, rx1061_tgt, rx1061_off
  rx1061_start:
    eq $I10, 1, rx1061_restart
    if_null rx1061_debug, debug_1009
    rx1061_cur."!cursor_debug"("START", "routine_declarator:sym<sub>")
  debug_1009:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1062_done
    goto rxscan1062_scan
  rxscan1062_loop:
    (rx1061_pos) = rx1061_cur."from"()
    inc rx1061_pos
    rx1061_cur."!cursor_from"(rx1061_pos)
    ge rx1061_pos, rx1061_eos, rxscan1062_done
  rxscan1062_scan:
    set_addr $I10, rxscan1062_loop
    rx1061_cur."!mark_push"(0, rx1061_pos, $I10)
  rxscan1062_done:
.annotate 'line', 412
  # rx subcapture "sym"
    set_addr $I10, rxcap_1063_fail
    rx1061_cur."!mark_push"(0, rx1061_pos, $I10)
  # rx literal  "sub"
    add $I11, rx1061_pos, 3
    gt $I11, rx1061_eos, rx1061_fail
    sub $I11, rx1061_pos, rx1061_off
    substr $S10, rx1061_tgt, $I11, 3
    ne $S10, "sub", rx1061_fail
    add rx1061_pos, 3
    set_addr $I10, rxcap_1063_fail
    ($I12, $I11) = rx1061_cur."!mark_peek"($I10)
    rx1061_cur."!cursor_pos"($I11)
    ($P10) = rx1061_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1061_pos, "")
    rx1061_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1063_done
  rxcap_1063_fail:
    goto rx1061_fail
  rxcap_1063_done:
  # rx subrule "routine_def" subtype=capture negate=
    rx1061_cur."!cursor_pos"(rx1061_pos)
    $P10 = rx1061_cur."routine_def"()
    unless $P10, rx1061_fail
    rx1061_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx1061_pos = $P10."pos"()
  # rx pass
    rx1061_cur."!cursor_pass"(rx1061_pos, "routine_declarator:sym<sub>")
    if_null rx1061_debug, debug_1010
    rx1061_cur."!cursor_debug"("PASS", "routine_declarator:sym<sub>", " at pos=", rx1061_pos)
  debug_1010:
    .return (rx1061_cur)
  rx1061_restart:
.annotate 'line', 10
    if_null rx1061_debug, debug_1011
    rx1061_cur."!cursor_debug"("NEXT", "routine_declarator:sym<sub>")
  debug_1011:
  rx1061_fail:
    (rx1061_rep, rx1061_pos, $I10, $P10) = rx1061_cur."!mark_fail"(0)
    lt rx1061_pos, -1, rx1061_done
    eq rx1061_pos, -1, rx1061_fail
    jump $I10
  rx1061_done:
    rx1061_cur."!cursor_fail"()
    if_null rx1061_debug, debug_1012
    rx1061_cur."!cursor_debug"("FAIL", "routine_declarator:sym<sub>")
  debug_1012:
    .return (rx1061_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<sub>"  :subid("176_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1065 = self."!PREFIX__!subrule"("routine_def", "sub")
    new $P1066, "ResizablePMCArray"
    push $P1066, $P1065
    .return ($P1066)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<method>"  :subid("177_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1068_tgt
    .local int rx1068_pos
    .local int rx1068_off
    .local int rx1068_eos
    .local int rx1068_rep
    .local pmc rx1068_cur
    .local pmc rx1068_debug
    (rx1068_cur, rx1068_pos, rx1068_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1068_cur
    .local pmc match
    .lex "$/", match
    length rx1068_eos, rx1068_tgt
    gt rx1068_pos, rx1068_eos, rx1068_done
    set rx1068_off, 0
    lt rx1068_pos, 2, rx1068_start
    sub rx1068_off, rx1068_pos, 1
    substr rx1068_tgt, rx1068_tgt, rx1068_off
  rx1068_start:
    eq $I10, 1, rx1068_restart
    if_null rx1068_debug, debug_1013
    rx1068_cur."!cursor_debug"("START", "routine_declarator:sym<method>")
  debug_1013:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1069_done
    goto rxscan1069_scan
  rxscan1069_loop:
    (rx1068_pos) = rx1068_cur."from"()
    inc rx1068_pos
    rx1068_cur."!cursor_from"(rx1068_pos)
    ge rx1068_pos, rx1068_eos, rxscan1069_done
  rxscan1069_scan:
    set_addr $I10, rxscan1069_loop
    rx1068_cur."!mark_push"(0, rx1068_pos, $I10)
  rxscan1069_done:
.annotate 'line', 413
  # rx subcapture "sym"
    set_addr $I10, rxcap_1070_fail
    rx1068_cur."!mark_push"(0, rx1068_pos, $I10)
  # rx literal  "method"
    add $I11, rx1068_pos, 6
    gt $I11, rx1068_eos, rx1068_fail
    sub $I11, rx1068_pos, rx1068_off
    substr $S10, rx1068_tgt, $I11, 6
    ne $S10, "method", rx1068_fail
    add rx1068_pos, 6
    set_addr $I10, rxcap_1070_fail
    ($I12, $I11) = rx1068_cur."!mark_peek"($I10)
    rx1068_cur."!cursor_pos"($I11)
    ($P10) = rx1068_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1068_pos, "")
    rx1068_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1070_done
  rxcap_1070_fail:
    goto rx1068_fail
  rxcap_1070_done:
  # rx subrule "method_def" subtype=capture negate=
    rx1068_cur."!cursor_pos"(rx1068_pos)
    $P10 = rx1068_cur."method_def"()
    unless $P10, rx1068_fail
    rx1068_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("method_def")
    rx1068_pos = $P10."pos"()
  # rx pass
    rx1068_cur."!cursor_pass"(rx1068_pos, "routine_declarator:sym<method>")
    if_null rx1068_debug, debug_1014
    rx1068_cur."!cursor_debug"("PASS", "routine_declarator:sym<method>", " at pos=", rx1068_pos)
  debug_1014:
    .return (rx1068_cur)
  rx1068_restart:
.annotate 'line', 10
    if_null rx1068_debug, debug_1015
    rx1068_cur."!cursor_debug"("NEXT", "routine_declarator:sym<method>")
  debug_1015:
  rx1068_fail:
    (rx1068_rep, rx1068_pos, $I10, $P10) = rx1068_cur."!mark_fail"(0)
    lt rx1068_pos, -1, rx1068_done
    eq rx1068_pos, -1, rx1068_fail
    jump $I10
  rx1068_done:
    rx1068_cur."!cursor_fail"()
    if_null rx1068_debug, debug_1016
    rx1068_cur."!cursor_debug"("FAIL", "routine_declarator:sym<method>")
  debug_1016:
    .return (rx1068_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<method>"  :subid("178_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1072 = self."!PREFIX__!subrule"("method_def", "method")
    new $P1073, "ResizablePMCArray"
    push $P1073, $P1072
    .return ($P1073)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_def"  :subid("179_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 416
    new $P1075, "Undef"
    .lex "$*RETURN_USED", $P1075
.annotate 'line', 10
    .local string rx1076_tgt
    .local int rx1076_pos
    .local int rx1076_off
    .local int rx1076_eos
    .local int rx1076_rep
    .local pmc rx1076_cur
    .local pmc rx1076_debug
    (rx1076_cur, rx1076_pos, rx1076_tgt, $I10) = self."!cursor_start"()
    rx1076_cur."!cursor_caparray"("sigil", "deflongname", "trait")
    .lex unicode:"$\x{a2}", rx1076_cur
    .local pmc match
    .lex "$/", match
    length rx1076_eos, rx1076_tgt
    gt rx1076_pos, rx1076_eos, rx1076_done
    set rx1076_off, 0
    lt rx1076_pos, 2, rx1076_start
    sub rx1076_off, rx1076_pos, 1
    substr rx1076_tgt, rx1076_tgt, rx1076_off
  rx1076_start:
    eq $I10, 1, rx1076_restart
    if_null rx1076_debug, debug_1017
    rx1076_cur."!cursor_debug"("START", "routine_def")
  debug_1017:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1077_done
    goto rxscan1077_scan
  rxscan1077_loop:
    (rx1076_pos) = rx1076_cur."from"()
    inc rx1076_pos
    rx1076_cur."!cursor_from"(rx1076_pos)
    ge rx1076_pos, rx1076_eos, rxscan1077_done
  rxscan1077_scan:
    set_addr $I10, rxscan1077_loop
    rx1076_cur."!mark_push"(0, rx1076_pos, $I10)
  rxscan1077_done:
.annotate 'line', 415
  # rx subrule "ws" subtype=method negate=
    rx1076_cur."!cursor_pos"(rx1076_pos)
    $P10 = rx1076_cur."ws"()
    unless $P10, rx1076_fail
    rx1076_pos = $P10."pos"()
.annotate 'line', 416
    rx1076_cur."!cursor_pos"(rx1076_pos)
    new $P1079, "Integer"
    assign $P1079, 0
    store_lex "$*RETURN_USED", $P1079
  # rx subrule "ws" subtype=method negate=
    rx1076_cur."!cursor_pos"(rx1076_pos)
    $P10 = rx1076_cur."ws"()
    unless $P10, rx1076_fail
    rx1076_pos = $P10."pos"()
.annotate 'line', 417
  # rx rxquantr1081 ** 0..1
    set_addr $I10, rxquantr1081_done
    rx1076_cur."!mark_push"(0, rx1076_pos, $I10)
  rxquantr1081_loop:
  # rx subrule "ws" subtype=method negate=
    rx1076_cur."!cursor_pos"(rx1076_pos)
    $P10 = rx1076_cur."ws"()
    unless $P10, rx1076_fail
    rx1076_pos = $P10."pos"()
  # rx subcapture "sigil"
    set_addr $I10, rxcap_1084_fail
    rx1076_cur."!mark_push"(0, rx1076_pos, $I10)
  # rx rxquantr1083 ** 0..1
    set_addr $I10, rxquantr1083_done
    rx1076_cur."!mark_push"(0, rx1076_pos, $I10)
  rxquantr1083_loop:
  # rx literal  "&"
    add $I11, rx1076_pos, 1
    gt $I11, rx1076_eos, rx1076_fail
    sub $I11, rx1076_pos, rx1076_off
    ord $I11, rx1076_tgt, $I11
    ne $I11, 38, rx1076_fail
    add rx1076_pos, 1
    set_addr $I10, rxquantr1083_done
    (rx1076_rep) = rx1076_cur."!mark_commit"($I10)
  rxquantr1083_done:
    set_addr $I10, rxcap_1084_fail
    ($I12, $I11) = rx1076_cur."!mark_peek"($I10)
    rx1076_cur."!cursor_pos"($I11)
    ($P10) = rx1076_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1076_pos, "")
    rx1076_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_1084_done
  rxcap_1084_fail:
    goto rx1076_fail
  rxcap_1084_done:
  # rx subrule "deflongname" subtype=capture negate=
    rx1076_cur."!cursor_pos"(rx1076_pos)
    $P10 = rx1076_cur."deflongname"()
    unless $P10, rx1076_fail
    rx1076_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1076_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1076_cur."!cursor_pos"(rx1076_pos)
    $P10 = rx1076_cur."ws"()
    unless $P10, rx1076_fail
    rx1076_pos = $P10."pos"()
    set_addr $I10, rxquantr1081_done
    (rx1076_rep) = rx1076_cur."!mark_commit"($I10)
  rxquantr1081_done:
  # rx subrule "ws" subtype=method negate=
    rx1076_cur."!cursor_pos"(rx1076_pos)
    $P10 = rx1076_cur."ws"()
    unless $P10, rx1076_fail
    rx1076_pos = $P10."pos"()
.annotate 'line', 418
  # rx subrule "newpad" subtype=method negate=
    rx1076_cur."!cursor_pos"(rx1076_pos)
    $P10 = rx1076_cur."newpad"()
    unless $P10, rx1076_fail
    rx1076_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1076_cur."!cursor_pos"(rx1076_pos)
    $P10 = rx1076_cur."ws"()
    unless $P10, rx1076_fail
    rx1076_pos = $P10."pos"()
  alt1088_0:
.annotate 'line', 419
    set_addr $I10, alt1088_1
    rx1076_cur."!mark_push"(0, rx1076_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx1076_cur."!cursor_pos"(rx1076_pos)
    $P10 = rx1076_cur."ws"()
    unless $P10, rx1076_fail
    rx1076_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1076_pos, 1
    gt $I11, rx1076_eos, rx1076_fail
    sub $I11, rx1076_pos, rx1076_off
    ord $I11, rx1076_tgt, $I11
    ne $I11, 40, rx1076_fail
    add rx1076_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1076_cur."!cursor_pos"(rx1076_pos)
    $P10 = rx1076_cur."ws"()
    unless $P10, rx1076_fail
    rx1076_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx1076_cur."!cursor_pos"(rx1076_pos)
    $P10 = rx1076_cur."signature"()
    unless $P10, rx1076_fail
    rx1076_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx1076_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1076_cur."!cursor_pos"(rx1076_pos)
    $P10 = rx1076_cur."ws"()
    unless $P10, rx1076_fail
    rx1076_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1076_pos, 1
    gt $I11, rx1076_eos, rx1076_fail
    sub $I11, rx1076_pos, rx1076_off
    ord $I11, rx1076_tgt, $I11
    ne $I11, 41, rx1076_fail
    add rx1076_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1076_cur."!cursor_pos"(rx1076_pos)
    $P10 = rx1076_cur."ws"()
    unless $P10, rx1076_fail
    rx1076_pos = $P10."pos"()
    goto alt1088_end
  alt1088_1:
.annotate 'line', 420
  # rx subrule "ws" subtype=method negate=
    rx1076_cur."!cursor_pos"(rx1076_pos)
    $P10 = rx1076_cur."ws"()
    unless $P10, rx1076_fail
    rx1076_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1076_cur."!cursor_pos"(rx1076_pos)
    $P10 = rx1076_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx1076_fail
    rx1076_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1076_cur."!cursor_pos"(rx1076_pos)
    $P10 = rx1076_cur."ws"()
    unless $P10, rx1076_fail
    rx1076_pos = $P10."pos"()
  alt1088_end:
  # rx subrule "ws" subtype=method negate=
    rx1076_cur."!cursor_pos"(rx1076_pos)
    $P10 = rx1076_cur."ws"()
    unless $P10, rx1076_fail
    rx1076_pos = $P10."pos"()
.annotate 'line', 421
  # rx rxquantr1096 ** 0..*
    set_addr $I10, rxquantr1096_done
    rx1076_cur."!mark_push"(0, rx1076_pos, $I10)
  rxquantr1096_loop:
  # rx subrule "trait" subtype=capture negate=
    rx1076_cur."!cursor_pos"(rx1076_pos)
    $P10 = rx1076_cur."trait"()
    unless $P10, rx1076_fail
    goto rxsubrule1097_pass
  rxsubrule1097_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1076_fail
  rxsubrule1097_pass:
    set_addr $I10, rxsubrule1097_back
    rx1076_cur."!mark_push"(0, rx1076_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx1076_pos = $P10."pos"()
    set_addr $I10, rxquantr1096_done
    (rx1076_rep) = rx1076_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1096_done
    rx1076_cur."!mark_push"(rx1076_rep, rx1076_pos, $I10)
    goto rxquantr1096_loop
  rxquantr1096_done:
  # rx subrule "ws" subtype=method negate=
    rx1076_cur."!cursor_pos"(rx1076_pos)
    $P10 = rx1076_cur."ws"()
    unless $P10, rx1076_fail
    rx1076_pos = $P10."pos"()
  alt1099_0:
.annotate 'line', 422
    set_addr $I10, alt1099_1
    rx1076_cur."!mark_push"(0, rx1076_pos, $I10)
.annotate 'line', 423
  # rx subrule "ws" subtype=method negate=
    rx1076_cur."!cursor_pos"(rx1076_pos)
    $P10 = rx1076_cur."ws"()
    unless $P10, rx1076_fail
    rx1076_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx1076_cur."!cursor_pos"(rx1076_pos)
    $P10 = rx1076_cur."onlystar"()
    unless $P10, rx1076_fail
    rx1076_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx1076_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1076_cur."!cursor_pos"(rx1076_pos)
    $P10 = rx1076_cur."ws"()
    unless $P10, rx1076_fail
    rx1076_pos = $P10."pos"()
    goto alt1099_end
  alt1099_1:
.annotate 'line', 424
  # rx subrule "ws" subtype=method negate=
    rx1076_cur."!cursor_pos"(rx1076_pos)
    $P10 = rx1076_cur."ws"()
    unless $P10, rx1076_fail
    rx1076_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx1076_cur."!cursor_pos"(rx1076_pos)
    $P10 = rx1076_cur."blockoid"()
    unless $P10, rx1076_fail
    rx1076_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx1076_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1076_cur."!cursor_pos"(rx1076_pos)
    $P10 = rx1076_cur."ws"()
    unless $P10, rx1076_fail
    rx1076_pos = $P10."pos"()
  alt1099_end:
.annotate 'line', 425
  # rx subrule "ws" subtype=method negate=
    rx1076_cur."!cursor_pos"(rx1076_pos)
    $P10 = rx1076_cur."ws"()
    unless $P10, rx1076_fail
    rx1076_pos = $P10."pos"()
.annotate 'line', 415
  # rx pass
    rx1076_cur."!cursor_pass"(rx1076_pos, "routine_def")
    if_null rx1076_debug, debug_1018
    rx1076_cur."!cursor_debug"("PASS", "routine_def", " at pos=", rx1076_pos)
  debug_1018:
    .return (rx1076_cur)
  rx1076_restart:
.annotate 'line', 10
    if_null rx1076_debug, debug_1019
    rx1076_cur."!cursor_debug"("NEXT", "routine_def")
  debug_1019:
  rx1076_fail:
    (rx1076_rep, rx1076_pos, $I10, $P10) = rx1076_cur."!mark_fail"(0)
    lt rx1076_pos, -1, rx1076_done
    eq rx1076_pos, -1, rx1076_fail
    jump $I10
  rx1076_done:
    rx1076_cur."!cursor_fail"()
    if_null rx1076_debug, debug_1020
    rx1076_cur."!cursor_debug"("FAIL", "routine_def")
  debug_1020:
    .return (rx1076_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_def"  :subid("180_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1106 = self."!PREFIX__!subrule"("ws", "")
    new $P1107, "ResizablePMCArray"
    push $P1107, $P1106
    .return ($P1107)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "method_def"  :subid("181_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .const 'Sub' $P1136 = "182_1304456155.152" 
    capture_lex $P1136
.annotate 'line', 429
    new $P1109, "Undef"
    .lex "$*RETURN_USED", $P1109
.annotate 'line', 430
    new $P1110, "Undef"
    .lex "$*INVOCANT_OK", $P1110
.annotate 'line', 10
    .local string rx1111_tgt
    .local int rx1111_pos
    .local int rx1111_off
    .local int rx1111_eos
    .local int rx1111_rep
    .local pmc rx1111_cur
    .local pmc rx1111_debug
    (rx1111_cur, rx1111_pos, rx1111_tgt, $I10) = self."!cursor_start"()
    rx1111_cur."!cursor_caparray"("deflongname", "trait")
    .lex unicode:"$\x{a2}", rx1111_cur
    .local pmc match
    .lex "$/", match
    length rx1111_eos, rx1111_tgt
    gt rx1111_pos, rx1111_eos, rx1111_done
    set rx1111_off, 0
    lt rx1111_pos, 2, rx1111_start
    sub rx1111_off, rx1111_pos, 1
    substr rx1111_tgt, rx1111_tgt, rx1111_off
  rx1111_start:
    eq $I10, 1, rx1111_restart
    if_null rx1111_debug, debug_1021
    rx1111_cur."!cursor_debug"("START", "method_def")
  debug_1021:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1112_done
    goto rxscan1112_scan
  rxscan1112_loop:
    (rx1111_pos) = rx1111_cur."from"()
    inc rx1111_pos
    rx1111_cur."!cursor_from"(rx1111_pos)
    ge rx1111_pos, rx1111_eos, rxscan1112_done
  rxscan1112_scan:
    set_addr $I10, rxscan1112_loop
    rx1111_cur."!mark_push"(0, rx1111_pos, $I10)
  rxscan1112_done:
.annotate 'line', 428
  # rx subrule "ws" subtype=method negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."ws"()
    unless $P10, rx1111_fail
    rx1111_pos = $P10."pos"()
.annotate 'line', 429
    rx1111_cur."!cursor_pos"(rx1111_pos)
    new $P1114, "Integer"
    assign $P1114, 0
    store_lex "$*RETURN_USED", $P1114
  # rx subrule "ws" subtype=method negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."ws"()
    unless $P10, rx1111_fail
    rx1111_pos = $P10."pos"()
.annotate 'line', 430
    rx1111_cur."!cursor_pos"(rx1111_pos)
    new $P1116, "Integer"
    assign $P1116, 1
    store_lex "$*INVOCANT_OK", $P1116
  # rx subrule "ws" subtype=method negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."ws"()
    unless $P10, rx1111_fail
    rx1111_pos = $P10."pos"()
.annotate 'line', 431
  # rx subcapture "private"
    set_addr $I10, rxcap_1119_fail
    rx1111_cur."!mark_push"(0, rx1111_pos, $I10)
  # rx rxquantr1118 ** 0..1
    set_addr $I10, rxquantr1118_done
    rx1111_cur."!mark_push"(0, rx1111_pos, $I10)
  rxquantr1118_loop:
  # rx literal  "!"
    add $I11, rx1111_pos, 1
    gt $I11, rx1111_eos, rx1111_fail
    sub $I11, rx1111_pos, rx1111_off
    ord $I11, rx1111_tgt, $I11
    ne $I11, 33, rx1111_fail
    add rx1111_pos, 1
    set_addr $I10, rxquantr1118_done
    (rx1111_rep) = rx1111_cur."!mark_commit"($I10)
  rxquantr1118_done:
    set_addr $I10, rxcap_1119_fail
    ($I12, $I11) = rx1111_cur."!mark_peek"($I10)
    rx1111_cur."!cursor_pos"($I11)
    ($P10) = rx1111_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1111_pos, "")
    rx1111_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("private")
    goto rxcap_1119_done
  rxcap_1119_fail:
    goto rx1111_fail
  rxcap_1119_done:
  # rx subrule "ws" subtype=method negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."ws"()
    unless $P10, rx1111_fail
    rx1111_pos = $P10."pos"()
.annotate 'line', 432
  # rx rxquantr1121 ** 0..1
    set_addr $I10, rxquantr1121_done
    rx1111_cur."!mark_push"(0, rx1111_pos, $I10)
  rxquantr1121_loop:
  # rx subrule "deflongname" subtype=capture negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."deflongname"()
    unless $P10, rx1111_fail
    goto rxsubrule1122_pass
  rxsubrule1122_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1111_fail
  rxsubrule1122_pass:
    set_addr $I10, rxsubrule1122_back
    rx1111_cur."!mark_push"(0, rx1111_pos, $I10, $P10)
    $P10."!cursor_names"("deflongname")
    rx1111_pos = $P10."pos"()
    set_addr $I10, rxquantr1121_done
    (rx1111_rep) = rx1111_cur."!mark_commit"($I10)
  rxquantr1121_done:
  # rx subrule "ws" subtype=method negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."ws"()
    unless $P10, rx1111_fail
    rx1111_pos = $P10."pos"()
.annotate 'line', 433
  # rx subrule "newpad" subtype=method negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."newpad"()
    unless $P10, rx1111_fail
    rx1111_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."ws"()
    unless $P10, rx1111_fail
    rx1111_pos = $P10."pos"()
  alt1125_0:
.annotate 'line', 434
    set_addr $I10, alt1125_1
    rx1111_cur."!mark_push"(0, rx1111_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."ws"()
    unless $P10, rx1111_fail
    rx1111_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1111_pos, 1
    gt $I11, rx1111_eos, rx1111_fail
    sub $I11, rx1111_pos, rx1111_off
    ord $I11, rx1111_tgt, $I11
    ne $I11, 40, rx1111_fail
    add rx1111_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."ws"()
    unless $P10, rx1111_fail
    rx1111_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."signature"()
    unless $P10, rx1111_fail
    rx1111_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx1111_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."ws"()
    unless $P10, rx1111_fail
    rx1111_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1111_pos, 1
    gt $I11, rx1111_eos, rx1111_fail
    sub $I11, rx1111_pos, rx1111_off
    ord $I11, rx1111_tgt, $I11
    ne $I11, 41, rx1111_fail
    add rx1111_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."ws"()
    unless $P10, rx1111_fail
    rx1111_pos = $P10."pos"()
    goto alt1125_end
  alt1125_1:
.annotate 'line', 435
  # rx subrule "ws" subtype=method negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."ws"()
    unless $P10, rx1111_fail
    rx1111_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx1111_fail
    rx1111_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."ws"()
    unless $P10, rx1111_fail
    rx1111_pos = $P10."pos"()
  alt1125_end:
  # rx subrule "ws" subtype=method negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."ws"()
    unless $P10, rx1111_fail
    rx1111_pos = $P10."pos"()
.annotate 'line', 436
    rx1111_cur."!cursor_pos"(rx1111_pos)
    find_lex $P1133, unicode:"$\x{a2}"
    $P1134 = $P1133."MATCH"()
    store_lex "$/", $P1134
    .const 'Sub' $P1136 = "182_1304456155.152" 
    capture_lex $P1136
    $P1138 = $P1136()
  # rx subrule "ws" subtype=method negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."ws"()
    unless $P10, rx1111_fail
    rx1111_pos = $P10."pos"()
.annotate 'line', 437
  # rx rxquantr1140 ** 0..*
    set_addr $I10, rxquantr1140_done
    rx1111_cur."!mark_push"(0, rx1111_pos, $I10)
  rxquantr1140_loop:
  # rx subrule "trait" subtype=capture negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."trait"()
    unless $P10, rx1111_fail
    goto rxsubrule1141_pass
  rxsubrule1141_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1111_fail
  rxsubrule1141_pass:
    set_addr $I10, rxsubrule1141_back
    rx1111_cur."!mark_push"(0, rx1111_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx1111_pos = $P10."pos"()
    set_addr $I10, rxquantr1140_done
    (rx1111_rep) = rx1111_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1140_done
    rx1111_cur."!mark_push"(rx1111_rep, rx1111_pos, $I10)
    goto rxquantr1140_loop
  rxquantr1140_done:
  # rx subrule "ws" subtype=method negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."ws"()
    unless $P10, rx1111_fail
    rx1111_pos = $P10."pos"()
  alt1143_0:
.annotate 'line', 438
    set_addr $I10, alt1143_1
    rx1111_cur."!mark_push"(0, rx1111_pos, $I10)
.annotate 'line', 439
  # rx subrule "ws" subtype=method negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."ws"()
    unless $P10, rx1111_fail
    rx1111_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."onlystar"()
    unless $P10, rx1111_fail
    rx1111_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx1111_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."ws"()
    unless $P10, rx1111_fail
    rx1111_pos = $P10."pos"()
    goto alt1143_end
  alt1143_1:
.annotate 'line', 440
  # rx subrule "ws" subtype=method negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."ws"()
    unless $P10, rx1111_fail
    rx1111_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."blockoid"()
    unless $P10, rx1111_fail
    rx1111_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx1111_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."ws"()
    unless $P10, rx1111_fail
    rx1111_pos = $P10."pos"()
  alt1143_end:
.annotate 'line', 441
  # rx subrule "ws" subtype=method negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."ws"()
    unless $P10, rx1111_fail
    rx1111_pos = $P10."pos"()
.annotate 'line', 428
  # rx pass
    rx1111_cur."!cursor_pass"(rx1111_pos, "method_def")
    if_null rx1111_debug, debug_1022
    rx1111_cur."!cursor_debug"("PASS", "method_def", " at pos=", rx1111_pos)
  debug_1022:
    .return (rx1111_cur)
  rx1111_restart:
.annotate 'line', 10
    if_null rx1111_debug, debug_1023
    rx1111_cur."!cursor_debug"("NEXT", "method_def")
  debug_1023:
  rx1111_fail:
    (rx1111_rep, rx1111_pos, $I10, $P10) = rx1111_cur."!mark_fail"(0)
    lt rx1111_pos, -1, rx1111_done
    eq rx1111_pos, -1, rx1111_fail
    jump $I10
  rx1111_done:
    rx1111_cur."!cursor_fail"()
    if_null rx1111_debug, debug_1024
    rx1111_cur."!cursor_debug"("FAIL", "method_def")
  debug_1024:
    .return (rx1111_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1135"  :anon :subid("182_1304456155.152") :outer("181_1304456155.152")
.annotate 'line', 436
    new $P1137, "Integer"
    assign $P1137, 0
    store_dynamic_lex "$*INVOCANT_OK", $P1137
    .return ($P1137)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__method_def"  :subid("183_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1150 = self."!PREFIX__!subrule"("ws", "")
    new $P1151, "ResizablePMCArray"
    push $P1151, $P1150
    .return ($P1151)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "onlystar"  :subid("184_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .const 'Sub' $P1158 = "185_1304456155.152" 
    capture_lex $P1158
    .local string rx1153_tgt
    .local int rx1153_pos
    .local int rx1153_off
    .local int rx1153_eos
    .local int rx1153_rep
    .local pmc rx1153_cur
    .local pmc rx1153_debug
    (rx1153_cur, rx1153_pos, rx1153_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1153_cur
    .local pmc match
    .lex "$/", match
    length rx1153_eos, rx1153_tgt
    gt rx1153_pos, rx1153_eos, rx1153_done
    set rx1153_off, 0
    lt rx1153_pos, 2, rx1153_start
    sub rx1153_off, rx1153_pos, 1
    substr rx1153_tgt, rx1153_tgt, rx1153_off
  rx1153_start:
    eq $I10, 1, rx1153_restart
    if_null rx1153_debug, debug_1025
    rx1153_cur."!cursor_debug"("START", "onlystar")
  debug_1025:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1154_done
    goto rxscan1154_scan
  rxscan1154_loop:
    (rx1153_pos) = rx1153_cur."from"()
    inc rx1153_pos
    rx1153_cur."!cursor_from"(rx1153_pos)
    ge rx1153_pos, rx1153_eos, rxscan1154_done
  rxscan1154_scan:
    set_addr $I10, rxscan1154_loop
    rx1153_cur."!mark_push"(0, rx1153_pos, $I10)
  rxscan1154_done:
.annotate 'line', 445
    rx1153_cur."!cursor_pos"(rx1153_pos)
    find_lex $P1155, unicode:"$\x{a2}"
    $P1156 = $P1155."MATCH"()
    store_lex "$/", $P1156
    .const 'Sub' $P1158 = "185_1304456155.152" 
    capture_lex $P1158
    $P1164 = $P1158()
    unless $P1164, rx1153_fail
.annotate 'line', 446
  # rx literal  "{"
    add $I11, rx1153_pos, 1
    gt $I11, rx1153_eos, rx1153_fail
    sub $I11, rx1153_pos, rx1153_off
    ord $I11, rx1153_tgt, $I11
    ne $I11, 123, rx1153_fail
    add rx1153_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1153_cur."!cursor_pos"(rx1153_pos)
    $P10 = rx1153_cur."ws"()
    unless $P10, rx1153_fail
    rx1153_pos = $P10."pos"()
  # rx literal  "*"
    add $I11, rx1153_pos, 1
    gt $I11, rx1153_eos, rx1153_fail
    sub $I11, rx1153_pos, rx1153_off
    ord $I11, rx1153_tgt, $I11
    ne $I11, 42, rx1153_fail
    add rx1153_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1153_cur."!cursor_pos"(rx1153_pos)
    $P10 = rx1153_cur."ws"()
    unless $P10, rx1153_fail
    rx1153_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1153_pos, 1
    gt $I11, rx1153_eos, rx1153_fail
    sub $I11, rx1153_pos, rx1153_off
    ord $I11, rx1153_tgt, $I11
    ne $I11, 125, rx1153_fail
    add rx1153_pos, 1
.annotate 'line', 447
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1153_cur."!cursor_pos"(rx1153_pos)
    $P10 = rx1153_cur."ENDSTMT"()
    unless $P10, rx1153_fail
.annotate 'line', 448
  # rx subrule "finishpad" subtype=method negate=
    rx1153_cur."!cursor_pos"(rx1153_pos)
    $P10 = rx1153_cur."finishpad"()
    unless $P10, rx1153_fail
    rx1153_pos = $P10."pos"()
.annotate 'line', 444
  # rx pass
    rx1153_cur."!cursor_pass"(rx1153_pos, "onlystar")
    if_null rx1153_debug, debug_1028
    rx1153_cur."!cursor_debug"("PASS", "onlystar", " at pos=", rx1153_pos)
  debug_1028:
    .return (rx1153_cur)
  rx1153_restart:
.annotate 'line', 10
    if_null rx1153_debug, debug_1029
    rx1153_cur."!cursor_debug"("NEXT", "onlystar")
  debug_1029:
  rx1153_fail:
    (rx1153_rep, rx1153_pos, $I10, $P10) = rx1153_cur."!mark_fail"(0)
    lt rx1153_pos, -1, rx1153_done
    eq rx1153_pos, -1, rx1153_fail
    jump $I10
  rx1153_done:
    rx1153_cur."!cursor_fail"()
    if_null rx1153_debug, debug_1030
    rx1153_cur."!cursor_debug"("FAIL", "onlystar")
  debug_1030:
    .return (rx1153_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1157"  :anon :subid("185_1304456155.152") :outer("184_1304456155.152")
.annotate 'line', 445
    find_dynamic_lex $P1161, "$*MULTINESS"
    unless_null $P1161, vivify_1026
    get_hll_global $P1159, "GLOBAL"
    get_who $P1160, $P1159
    set $P1161, $P1160["$MULTINESS"]
    unless_null $P1161, vivify_1027
    die "Contextual $*MULTINESS not found"
  vivify_1027:
  vivify_1026:
    set $S1162, $P1161
    iseq $I1163, $S1162, "proto"
    .return ($I1163)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__onlystar"  :subid("186_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    new $P1166, "ResizablePMCArray"
    push $P1166, ""
    .return ($P1166)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator"  :subid("187_1304456155.152")
    .param pmc param_1168
.annotate 'line', 451
    .lex "self", param_1168
    $P1169 = param_1168."!protoregex"("multi_declarator")
    .return ($P1169)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator"  :subid("188_1304456155.152")
    .param pmc param_1171
.annotate 'line', 451
    .lex "self", param_1171
    $P1172 = param_1171."!PREFIX__!protoregex"("multi_declarator")
    .return ($P1172)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<multi>"  :subid("189_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 453
    new $P1174, "Undef"
    .lex "$*MULTINESS", $P1174
.annotate 'line', 10
    .local string rx1175_tgt
    .local int rx1175_pos
    .local int rx1175_off
    .local int rx1175_eos
    .local int rx1175_rep
    .local pmc rx1175_cur
    .local pmc rx1175_debug
    (rx1175_cur, rx1175_pos, rx1175_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1175_cur
    .local pmc match
    .lex "$/", match
    length rx1175_eos, rx1175_tgt
    gt rx1175_pos, rx1175_eos, rx1175_done
    set rx1175_off, 0
    lt rx1175_pos, 2, rx1175_start
    sub rx1175_off, rx1175_pos, 1
    substr rx1175_tgt, rx1175_tgt, rx1175_off
  rx1175_start:
    eq $I10, 1, rx1175_restart
    if_null rx1175_debug, debug_1031
    rx1175_cur."!cursor_debug"("START", "multi_declarator:sym<multi>")
  debug_1031:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1176_done
    goto rxscan1176_scan
  rxscan1176_loop:
    (rx1175_pos) = rx1175_cur."from"()
    inc rx1175_pos
    rx1175_cur."!cursor_from"(rx1175_pos)
    ge rx1175_pos, rx1175_eos, rxscan1176_done
  rxscan1176_scan:
    set_addr $I10, rxscan1176_loop
    rx1175_cur."!mark_push"(0, rx1175_pos, $I10)
  rxscan1176_done:
.annotate 'line', 453
    rx1175_cur."!cursor_pos"(rx1175_pos)
    new $P1177, "String"
    assign $P1177, "multi"
    store_lex "$*MULTINESS", $P1177
.annotate 'line', 454
  # rx subcapture "sym"
    set_addr $I10, rxcap_1178_fail
    rx1175_cur."!mark_push"(0, rx1175_pos, $I10)
  # rx literal  "multi"
    add $I11, rx1175_pos, 5
    gt $I11, rx1175_eos, rx1175_fail
    sub $I11, rx1175_pos, rx1175_off
    substr $S10, rx1175_tgt, $I11, 5
    ne $S10, "multi", rx1175_fail
    add rx1175_pos, 5
    set_addr $I10, rxcap_1178_fail
    ($I12, $I11) = rx1175_cur."!mark_peek"($I10)
    rx1175_cur."!cursor_pos"($I11)
    ($P10) = rx1175_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1175_pos, "")
    rx1175_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1178_done
  rxcap_1178_fail:
    goto rx1175_fail
  rxcap_1178_done:
.annotate 'line', 455
  # rx subrule "ws" subtype=method negate=
    rx1175_cur."!cursor_pos"(rx1175_pos)
    $P10 = rx1175_cur."ws"()
    unless $P10, rx1175_fail
    rx1175_pos = $P10."pos"()
  alt1179_0:
    set_addr $I10, alt1179_1
    rx1175_cur."!mark_push"(0, rx1175_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx1175_cur."!cursor_pos"(rx1175_pos)
    $P10 = rx1175_cur."declarator"()
    unless $P10, rx1175_fail
    rx1175_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1175_pos = $P10."pos"()
    goto alt1179_end
  alt1179_1:
    set_addr $I10, alt1179_2
    rx1175_cur."!mark_push"(0, rx1175_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx1175_cur."!cursor_pos"(rx1175_pos)
    $P10 = rx1175_cur."routine_def"()
    unless $P10, rx1175_fail
    rx1175_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx1175_pos = $P10."pos"()
    goto alt1179_end
  alt1179_2:
  # rx subrule "panic" subtype=method negate=
    rx1175_cur."!cursor_pos"(rx1175_pos)
    $P10 = rx1175_cur."panic"("Malformed multi")
    unless $P10, rx1175_fail
    rx1175_pos = $P10."pos"()
  alt1179_end:
.annotate 'line', 452
  # rx pass
    rx1175_cur."!cursor_pass"(rx1175_pos, "multi_declarator:sym<multi>")
    if_null rx1175_debug, debug_1032
    rx1175_cur."!cursor_debug"("PASS", "multi_declarator:sym<multi>", " at pos=", rx1175_pos)
  debug_1032:
    .return (rx1175_cur)
  rx1175_restart:
.annotate 'line', 10
    if_null rx1175_debug, debug_1033
    rx1175_cur."!cursor_debug"("NEXT", "multi_declarator:sym<multi>")
  debug_1033:
  rx1175_fail:
    (rx1175_rep, rx1175_pos, $I10, $P10) = rx1175_cur."!mark_fail"(0)
    lt rx1175_pos, -1, rx1175_done
    eq rx1175_pos, -1, rx1175_fail
    jump $I10
  rx1175_done:
    rx1175_cur."!cursor_fail"()
    if_null rx1175_debug, debug_1034
    rx1175_cur."!cursor_debug"("FAIL", "multi_declarator:sym<multi>")
  debug_1034:
    .return (rx1175_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<multi>"  :subid("190_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1181 = self."!PREFIX__!subrule"("ws", "multi")
    new $P1182, "ResizablePMCArray"
    push $P1182, $P1181
    .return ($P1182)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<proto>"  :subid("191_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 458
    new $P1184, "Undef"
    .lex "$*MULTINESS", $P1184
.annotate 'line', 10
    .local string rx1185_tgt
    .local int rx1185_pos
    .local int rx1185_off
    .local int rx1185_eos
    .local int rx1185_rep
    .local pmc rx1185_cur
    .local pmc rx1185_debug
    (rx1185_cur, rx1185_pos, rx1185_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1185_cur
    .local pmc match
    .lex "$/", match
    length rx1185_eos, rx1185_tgt
    gt rx1185_pos, rx1185_eos, rx1185_done
    set rx1185_off, 0
    lt rx1185_pos, 2, rx1185_start
    sub rx1185_off, rx1185_pos, 1
    substr rx1185_tgt, rx1185_tgt, rx1185_off
  rx1185_start:
    eq $I10, 1, rx1185_restart
    if_null rx1185_debug, debug_1035
    rx1185_cur."!cursor_debug"("START", "multi_declarator:sym<proto>")
  debug_1035:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1186_done
    goto rxscan1186_scan
  rxscan1186_loop:
    (rx1185_pos) = rx1185_cur."from"()
    inc rx1185_pos
    rx1185_cur."!cursor_from"(rx1185_pos)
    ge rx1185_pos, rx1185_eos, rxscan1186_done
  rxscan1186_scan:
    set_addr $I10, rxscan1186_loop
    rx1185_cur."!mark_push"(0, rx1185_pos, $I10)
  rxscan1186_done:
.annotate 'line', 458
    rx1185_cur."!cursor_pos"(rx1185_pos)
    new $P1187, "String"
    assign $P1187, "proto"
    store_lex "$*MULTINESS", $P1187
.annotate 'line', 459
  # rx subcapture "sym"
    set_addr $I10, rxcap_1188_fail
    rx1185_cur."!mark_push"(0, rx1185_pos, $I10)
  # rx literal  "proto"
    add $I11, rx1185_pos, 5
    gt $I11, rx1185_eos, rx1185_fail
    sub $I11, rx1185_pos, rx1185_off
    substr $S10, rx1185_tgt, $I11, 5
    ne $S10, "proto", rx1185_fail
    add rx1185_pos, 5
    set_addr $I10, rxcap_1188_fail
    ($I12, $I11) = rx1185_cur."!mark_peek"($I10)
    rx1185_cur."!cursor_pos"($I11)
    ($P10) = rx1185_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1185_pos, "")
    rx1185_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1188_done
  rxcap_1188_fail:
    goto rx1185_fail
  rxcap_1188_done:
.annotate 'line', 460
  # rx subrule "ws" subtype=method negate=
    rx1185_cur."!cursor_pos"(rx1185_pos)
    $P10 = rx1185_cur."ws"()
    unless $P10, rx1185_fail
    rx1185_pos = $P10."pos"()
  alt1189_0:
    set_addr $I10, alt1189_1
    rx1185_cur."!mark_push"(0, rx1185_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx1185_cur."!cursor_pos"(rx1185_pos)
    $P10 = rx1185_cur."declarator"()
    unless $P10, rx1185_fail
    rx1185_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1185_pos = $P10."pos"()
    goto alt1189_end
  alt1189_1:
    set_addr $I10, alt1189_2
    rx1185_cur."!mark_push"(0, rx1185_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx1185_cur."!cursor_pos"(rx1185_pos)
    $P10 = rx1185_cur."routine_def"()
    unless $P10, rx1185_fail
    rx1185_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx1185_pos = $P10."pos"()
    goto alt1189_end
  alt1189_2:
  # rx subrule "panic" subtype=method negate=
    rx1185_cur."!cursor_pos"(rx1185_pos)
    $P10 = rx1185_cur."panic"("Malformed proto")
    unless $P10, rx1185_fail
    rx1185_pos = $P10."pos"()
  alt1189_end:
.annotate 'line', 457
  # rx pass
    rx1185_cur."!cursor_pass"(rx1185_pos, "multi_declarator:sym<proto>")
    if_null rx1185_debug, debug_1036
    rx1185_cur."!cursor_debug"("PASS", "multi_declarator:sym<proto>", " at pos=", rx1185_pos)
  debug_1036:
    .return (rx1185_cur)
  rx1185_restart:
.annotate 'line', 10
    if_null rx1185_debug, debug_1037
    rx1185_cur."!cursor_debug"("NEXT", "multi_declarator:sym<proto>")
  debug_1037:
  rx1185_fail:
    (rx1185_rep, rx1185_pos, $I10, $P10) = rx1185_cur."!mark_fail"(0)
    lt rx1185_pos, -1, rx1185_done
    eq rx1185_pos, -1, rx1185_fail
    jump $I10
  rx1185_done:
    rx1185_cur."!cursor_fail"()
    if_null rx1185_debug, debug_1038
    rx1185_cur."!cursor_debug"("FAIL", "multi_declarator:sym<proto>")
  debug_1038:
    .return (rx1185_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<proto>"  :subid("192_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1191 = self."!PREFIX__!subrule"("ws", "proto")
    new $P1192, "ResizablePMCArray"
    push $P1192, $P1191
    .return ($P1192)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<null>"  :subid("193_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 463
    new $P1194, "Undef"
    .lex "$*MULTINESS", $P1194
.annotate 'line', 10
    .local string rx1195_tgt
    .local int rx1195_pos
    .local int rx1195_off
    .local int rx1195_eos
    .local int rx1195_rep
    .local pmc rx1195_cur
    .local pmc rx1195_debug
    (rx1195_cur, rx1195_pos, rx1195_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1195_cur
    .local pmc match
    .lex "$/", match
    length rx1195_eos, rx1195_tgt
    gt rx1195_pos, rx1195_eos, rx1195_done
    set rx1195_off, 0
    lt rx1195_pos, 2, rx1195_start
    sub rx1195_off, rx1195_pos, 1
    substr rx1195_tgt, rx1195_tgt, rx1195_off
  rx1195_start:
    eq $I10, 1, rx1195_restart
    if_null rx1195_debug, debug_1039
    rx1195_cur."!cursor_debug"("START", "multi_declarator:sym<null>")
  debug_1039:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1196_done
    goto rxscan1196_scan
  rxscan1196_loop:
    (rx1195_pos) = rx1195_cur."from"()
    inc rx1195_pos
    rx1195_cur."!cursor_from"(rx1195_pos)
    ge rx1195_pos, rx1195_eos, rxscan1196_done
  rxscan1196_scan:
    set_addr $I10, rxscan1196_loop
    rx1195_cur."!mark_push"(0, rx1195_pos, $I10)
  rxscan1196_done:
.annotate 'line', 463
    rx1195_cur."!cursor_pos"(rx1195_pos)
    new $P1197, "String"
    assign $P1197, ""
    store_lex "$*MULTINESS", $P1197
.annotate 'line', 464
  # rx subrule "declarator" subtype=capture negate=
    rx1195_cur."!cursor_pos"(rx1195_pos)
    $P10 = rx1195_cur."declarator"()
    unless $P10, rx1195_fail
    rx1195_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1195_pos = $P10."pos"()
.annotate 'line', 462
  # rx pass
    rx1195_cur."!cursor_pass"(rx1195_pos, "multi_declarator:sym<null>")
    if_null rx1195_debug, debug_1040
    rx1195_cur."!cursor_debug"("PASS", "multi_declarator:sym<null>", " at pos=", rx1195_pos)
  debug_1040:
    .return (rx1195_cur)
  rx1195_restart:
.annotate 'line', 10
    if_null rx1195_debug, debug_1041
    rx1195_cur."!cursor_debug"("NEXT", "multi_declarator:sym<null>")
  debug_1041:
  rx1195_fail:
    (rx1195_rep, rx1195_pos, $I10, $P10) = rx1195_cur."!mark_fail"(0)
    lt rx1195_pos, -1, rx1195_done
    eq rx1195_pos, -1, rx1195_fail
    jump $I10
  rx1195_done:
    rx1195_cur."!cursor_fail"()
    if_null rx1195_debug, debug_1042
    rx1195_cur."!cursor_debug"("FAIL", "multi_declarator:sym<null>")
  debug_1042:
    .return (rx1195_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<null>"  :subid("194_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1199 = self."!PREFIX__!subrule"("declarator", "")
    new $P1200, "ResizablePMCArray"
    push $P1200, $P1199
    .return ($P1200)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "signature"  :subid("195_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .const 'Sub' $P1208 = "196_1304456155.152" 
    capture_lex $P1208
    .local string rx1202_tgt
    .local int rx1202_pos
    .local int rx1202_off
    .local int rx1202_eos
    .local int rx1202_rep
    .local pmc rx1202_cur
    .local pmc rx1202_debug
    (rx1202_cur, rx1202_pos, rx1202_tgt, $I10) = self."!cursor_start"()
    rx1202_cur."!cursor_caparray"("invocant", "parameter")
    .lex unicode:"$\x{a2}", rx1202_cur
    .local pmc match
    .lex "$/", match
    length rx1202_eos, rx1202_tgt
    gt rx1202_pos, rx1202_eos, rx1202_done
    set rx1202_off, 0
    lt rx1202_pos, 2, rx1202_start
    sub rx1202_off, rx1202_pos, 1
    substr rx1202_tgt, rx1202_tgt, rx1202_off
  rx1202_start:
    eq $I10, 1, rx1202_restart
    if_null rx1202_debug, debug_1043
    rx1202_cur."!cursor_debug"("START", "signature")
  debug_1043:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1203_done
    goto rxscan1203_scan
  rxscan1203_loop:
    (rx1202_pos) = rx1202_cur."from"()
    inc rx1202_pos
    rx1202_cur."!cursor_from"(rx1202_pos)
    ge rx1202_pos, rx1202_eos, rxscan1203_done
  rxscan1203_scan:
    set_addr $I10, rxscan1203_loop
    rx1202_cur."!mark_push"(0, rx1202_pos, $I10)
  rxscan1203_done:
.annotate 'line', 468
  # rx rxquantr1204 ** 0..1
    set_addr $I10, rxquantr1204_done
    rx1202_cur."!mark_push"(0, rx1202_pos, $I10)
  rxquantr1204_loop:
    rx1202_cur."!cursor_pos"(rx1202_pos)
    find_lex $P1205, unicode:"$\x{a2}"
    $P1206 = $P1205."MATCH"()
    store_lex "$/", $P1206
    .const 'Sub' $P1208 = "196_1304456155.152" 
    capture_lex $P1208
    $P1212 = $P1208()
    unless $P1212, rx1202_fail
  # rx subrule "ws" subtype=method negate=
    rx1202_cur."!cursor_pos"(rx1202_pos)
    $P10 = rx1202_cur."ws"()
    unless $P10, rx1202_fail
    rx1202_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx1202_cur."!cursor_pos"(rx1202_pos)
    $P10 = rx1202_cur."parameter"()
    unless $P10, rx1202_fail
    rx1202_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("invocant")
    rx1202_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1202_cur."!cursor_pos"(rx1202_pos)
    $P10 = rx1202_cur."ws"()
    unless $P10, rx1202_fail
    rx1202_pos = $P10."pos"()
  # rx literal  ":"
    add $I11, rx1202_pos, 1
    gt $I11, rx1202_eos, rx1202_fail
    sub $I11, rx1202_pos, rx1202_off
    ord $I11, rx1202_tgt, $I11
    ne $I11, 58, rx1202_fail
    add rx1202_pos, 1
    set_addr $I10, rxquantr1204_done
    (rx1202_rep) = rx1202_cur."!mark_commit"($I10)
  rxquantr1204_done:
.annotate 'line', 469
  # rx rxquantr1213 ** 0..1
    set_addr $I10, rxquantr1213_done
    rx1202_cur."!mark_push"(0, rx1202_pos, $I10)
  rxquantr1213_loop:
  # rx rxquantr1214 ** 1..*
    set_addr $I10, rxquantr1214_done
    rx1202_cur."!mark_push"(0, -1, $I10)
  rxquantr1214_loop:
  # rx subrule "ws" subtype=method negate=
    rx1202_cur."!cursor_pos"(rx1202_pos)
    $P10 = rx1202_cur."ws"()
    unless $P10, rx1202_fail
    rx1202_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx1202_cur."!cursor_pos"(rx1202_pos)
    $P10 = rx1202_cur."parameter"()
    unless $P10, rx1202_fail
    rx1202_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parameter")
    rx1202_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1202_cur."!cursor_pos"(rx1202_pos)
    $P10 = rx1202_cur."ws"()
    unless $P10, rx1202_fail
    rx1202_pos = $P10."pos"()
    set_addr $I10, rxquantr1214_done
    (rx1202_rep) = rx1202_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1214_done
    rx1202_cur."!mark_push"(rx1202_rep, rx1202_pos, $I10)
  # rx literal  ","
    add $I11, rx1202_pos, 1
    gt $I11, rx1202_eos, rx1202_fail
    sub $I11, rx1202_pos, rx1202_off
    ord $I11, rx1202_tgt, $I11
    ne $I11, 44, rx1202_fail
    add rx1202_pos, 1
    goto rxquantr1214_loop
  rxquantr1214_done:
    set_addr $I10, rxquantr1213_done
    (rx1202_rep) = rx1202_cur."!mark_commit"($I10)
  rxquantr1213_done:
.annotate 'line', 467
  # rx pass
    rx1202_cur."!cursor_pass"(rx1202_pos, "signature")
    if_null rx1202_debug, debug_1046
    rx1202_cur."!cursor_debug"("PASS", "signature", " at pos=", rx1202_pos)
  debug_1046:
    .return (rx1202_cur)
  rx1202_restart:
.annotate 'line', 10
    if_null rx1202_debug, debug_1047
    rx1202_cur."!cursor_debug"("NEXT", "signature")
  debug_1047:
  rx1202_fail:
    (rx1202_rep, rx1202_pos, $I10, $P10) = rx1202_cur."!mark_fail"(0)
    lt rx1202_pos, -1, rx1202_done
    eq rx1202_pos, -1, rx1202_fail
    jump $I10
  rx1202_done:
    rx1202_cur."!cursor_fail"()
    if_null rx1202_debug, debug_1048
    rx1202_cur."!cursor_debug"("FAIL", "signature")
  debug_1048:
    .return (rx1202_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1207"  :anon :subid("196_1304456155.152") :outer("195_1304456155.152")
.annotate 'line', 468
    find_dynamic_lex $P1211, "$*INVOCANT_OK"
    unless_null $P1211, vivify_1044
    get_hll_global $P1209, "GLOBAL"
    get_who $P1210, $P1209
    set $P1211, $P1210["$INVOCANT_OK"]
    unless_null $P1211, vivify_1045
    die "Contextual $*INVOCANT_OK not found"
  vivify_1045:
  vivify_1044:
    .return ($P1211)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__signature"  :subid("197_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    new $P1216, "ResizablePMCArray"
    push $P1216, ""
    .return ($P1216)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "parameter"  :subid("198_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1218_tgt
    .local int rx1218_pos
    .local int rx1218_off
    .local int rx1218_eos
    .local int rx1218_rep
    .local pmc rx1218_cur
    .local pmc rx1218_debug
    (rx1218_cur, rx1218_pos, rx1218_tgt, $I10) = self."!cursor_start"()
    rx1218_cur."!cursor_caparray"("typename", "definedness", "default_value")
    .lex unicode:"$\x{a2}", rx1218_cur
    .local pmc match
    .lex "$/", match
    length rx1218_eos, rx1218_tgt
    gt rx1218_pos, rx1218_eos, rx1218_done
    set rx1218_off, 0
    lt rx1218_pos, 2, rx1218_start
    sub rx1218_off, rx1218_pos, 1
    substr rx1218_tgt, rx1218_tgt, rx1218_off
  rx1218_start:
    eq $I10, 1, rx1218_restart
    if_null rx1218_debug, debug_1049
    rx1218_cur."!cursor_debug"("START", "parameter")
  debug_1049:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1219_done
    goto rxscan1219_scan
  rxscan1219_loop:
    (rx1218_pos) = rx1218_cur."from"()
    inc rx1218_pos
    rx1218_cur."!cursor_from"(rx1218_pos)
    ge rx1218_pos, rx1218_eos, rxscan1219_done
  rxscan1219_scan:
    set_addr $I10, rxscan1219_loop
    rx1218_cur."!mark_push"(0, rx1218_pos, $I10)
  rxscan1219_done:
.annotate 'line', 473
  # rx rxquantr1220 ** 0..*
    set_addr $I10, rxquantr1220_done
    rx1218_cur."!mark_push"(0, rx1218_pos, $I10)
  rxquantr1220_loop:
  # rx subrule "typename" subtype=capture negate=
    rx1218_cur."!cursor_pos"(rx1218_pos)
    $P10 = rx1218_cur."typename"()
    unless $P10, rx1218_fail
    rx1218_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("typename")
    rx1218_pos = $P10."pos"()
  # rx rxquantr1221 ** 0..1
    set_addr $I10, rxquantr1221_done
    rx1218_cur."!mark_push"(0, rx1218_pos, $I10)
  rxquantr1221_loop:
  # rx literal  ":"
    add $I11, rx1218_pos, 1
    gt $I11, rx1218_eos, rx1218_fail
    sub $I11, rx1218_pos, rx1218_off
    ord $I11, rx1218_tgt, $I11
    ne $I11, 58, rx1218_fail
    add rx1218_pos, 1
  # rx subcapture "definedness"
    set_addr $I10, rxcap_1222_fail
    rx1218_cur."!mark_push"(0, rx1218_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1218_pos, rx1218_eos, rx1218_fail
    sub $I10, rx1218_pos, rx1218_off
    substr $S10, rx1218_tgt, $I10, 1
    index $I11, "_DU", $S10
    lt $I11, 0, rx1218_fail
    inc rx1218_pos
    set_addr $I10, rxcap_1222_fail
    ($I12, $I11) = rx1218_cur."!mark_peek"($I10)
    rx1218_cur."!cursor_pos"($I11)
    ($P10) = rx1218_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1218_pos, "")
    rx1218_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("definedness")
    goto rxcap_1222_done
  rxcap_1222_fail:
    goto rx1218_fail
  rxcap_1222_done:
    set_addr $I10, rxquantr1221_done
    (rx1218_rep) = rx1218_cur."!mark_commit"($I10)
  rxquantr1221_done:
  # rx subrule "ws" subtype=method negate=
    rx1218_cur."!cursor_pos"(rx1218_pos)
    $P10 = rx1218_cur."ws"()
    unless $P10, rx1218_fail
    rx1218_pos = $P10."pos"()
    set_addr $I10, rxquantr1220_done
    (rx1218_rep) = rx1218_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1220_done
    rx1218_cur."!mark_push"(rx1218_rep, rx1218_pos, $I10)
    goto rxquantr1220_loop
  rxquantr1220_done:
  alt1223_0:
.annotate 'line', 474
    set_addr $I10, alt1223_1
    rx1218_cur."!mark_push"(0, rx1218_pos, $I10)
.annotate 'line', 475
  # rx subcapture "quant"
    set_addr $I10, rxcap_1224_fail
    rx1218_cur."!mark_push"(0, rx1218_pos, $I10)
  # rx literal  "*"
    add $I11, rx1218_pos, 1
    gt $I11, rx1218_eos, rx1218_fail
    sub $I11, rx1218_pos, rx1218_off
    ord $I11, rx1218_tgt, $I11
    ne $I11, 42, rx1218_fail
    add rx1218_pos, 1
    set_addr $I10, rxcap_1224_fail
    ($I12, $I11) = rx1218_cur."!mark_peek"($I10)
    rx1218_cur."!cursor_pos"($I11)
    ($P10) = rx1218_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1218_pos, "")
    rx1218_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_1224_done
  rxcap_1224_fail:
    goto rx1218_fail
  rxcap_1224_done:
  # rx subrule "param_var" subtype=capture negate=
    rx1218_cur."!cursor_pos"(rx1218_pos)
    $P10 = rx1218_cur."param_var"()
    unless $P10, rx1218_fail
    rx1218_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx1218_pos = $P10."pos"()
    goto alt1223_end
  alt1223_1:
  alt1225_0:
.annotate 'line', 476
    set_addr $I10, alt1225_1
    rx1218_cur."!mark_push"(0, rx1218_pos, $I10)
  # rx subrule "param_var" subtype=capture negate=
    rx1218_cur."!cursor_pos"(rx1218_pos)
    $P10 = rx1218_cur."param_var"()
    unless $P10, rx1218_fail
    rx1218_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx1218_pos = $P10."pos"()
    goto alt1225_end
  alt1225_1:
  # rx subrule "named_param" subtype=capture negate=
    rx1218_cur."!cursor_pos"(rx1218_pos)
    $P10 = rx1218_cur."named_param"()
    unless $P10, rx1218_fail
    rx1218_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("named_param")
    rx1218_pos = $P10."pos"()
  alt1225_end:
  # rx subcapture "quant"
    set_addr $I10, rxcap_1227_fail
    rx1218_cur."!mark_push"(0, rx1218_pos, $I10)
  alt1226_0:
    set_addr $I10, alt1226_1
    rx1218_cur."!mark_push"(0, rx1218_pos, $I10)
  # rx literal  "?"
    add $I11, rx1218_pos, 1
    gt $I11, rx1218_eos, rx1218_fail
    sub $I11, rx1218_pos, rx1218_off
    ord $I11, rx1218_tgt, $I11
    ne $I11, 63, rx1218_fail
    add rx1218_pos, 1
    goto alt1226_end
  alt1226_1:
    set_addr $I10, alt1226_2
    rx1218_cur."!mark_push"(0, rx1218_pos, $I10)
  # rx literal  "!"
    add $I11, rx1218_pos, 1
    gt $I11, rx1218_eos, rx1218_fail
    sub $I11, rx1218_pos, rx1218_off
    ord $I11, rx1218_tgt, $I11
    ne $I11, 33, rx1218_fail
    add rx1218_pos, 1
    goto alt1226_end
  alt1226_2:
  alt1226_end:
    set_addr $I10, rxcap_1227_fail
    ($I12, $I11) = rx1218_cur."!mark_peek"($I10)
    rx1218_cur."!cursor_pos"($I11)
    ($P10) = rx1218_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1218_pos, "")
    rx1218_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_1227_done
  rxcap_1227_fail:
    goto rx1218_fail
  rxcap_1227_done:
  alt1223_end:
.annotate 'line', 478
  # rx rxquantr1228 ** 0..1
    set_addr $I10, rxquantr1228_done
    rx1218_cur."!mark_push"(0, rx1218_pos, $I10)
  rxquantr1228_loop:
  # rx subrule "default_value" subtype=capture negate=
    rx1218_cur."!cursor_pos"(rx1218_pos)
    $P10 = rx1218_cur."default_value"()
    unless $P10, rx1218_fail
    goto rxsubrule1229_pass
  rxsubrule1229_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1218_fail
  rxsubrule1229_pass:
    set_addr $I10, rxsubrule1229_back
    rx1218_cur."!mark_push"(0, rx1218_pos, $I10, $P10)
    $P10."!cursor_names"("default_value")
    rx1218_pos = $P10."pos"()
    set_addr $I10, rxquantr1228_done
    (rx1218_rep) = rx1218_cur."!mark_commit"($I10)
  rxquantr1228_done:
.annotate 'line', 472
  # rx pass
    rx1218_cur."!cursor_pass"(rx1218_pos, "parameter")
    if_null rx1218_debug, debug_1050
    rx1218_cur."!cursor_debug"("PASS", "parameter", " at pos=", rx1218_pos)
  debug_1050:
    .return (rx1218_cur)
  rx1218_restart:
.annotate 'line', 10
    if_null rx1218_debug, debug_1051
    rx1218_cur."!cursor_debug"("NEXT", "parameter")
  debug_1051:
  rx1218_fail:
    (rx1218_rep, rx1218_pos, $I10, $P10) = rx1218_cur."!mark_fail"(0)
    lt rx1218_pos, -1, rx1218_done
    eq rx1218_pos, -1, rx1218_fail
    jump $I10
  rx1218_done:
    rx1218_cur."!cursor_fail"()
    if_null rx1218_debug, debug_1052
    rx1218_cur."!cursor_debug"("FAIL", "parameter")
  debug_1052:
    .return (rx1218_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__parameter"  :subid("199_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    new $P1231, "ResizablePMCArray"
    push $P1231, ""
    .return ($P1231)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "param_var"  :subid("200_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1233_tgt
    .local int rx1233_pos
    .local int rx1233_off
    .local int rx1233_eos
    .local int rx1233_rep
    .local pmc rx1233_cur
    .local pmc rx1233_debug
    (rx1233_cur, rx1233_pos, rx1233_tgt, $I10) = self."!cursor_start"()
    rx1233_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx1233_cur
    .local pmc match
    .lex "$/", match
    length rx1233_eos, rx1233_tgt
    gt rx1233_pos, rx1233_eos, rx1233_done
    set rx1233_off, 0
    lt rx1233_pos, 2, rx1233_start
    sub rx1233_off, rx1233_pos, 1
    substr rx1233_tgt, rx1233_tgt, rx1233_off
  rx1233_start:
    eq $I10, 1, rx1233_restart
    if_null rx1233_debug, debug_1053
    rx1233_cur."!cursor_debug"("START", "param_var")
  debug_1053:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1234_done
    goto rxscan1234_scan
  rxscan1234_loop:
    (rx1233_pos) = rx1233_cur."from"()
    inc rx1233_pos
    rx1233_cur."!cursor_from"(rx1233_pos)
    ge rx1233_pos, rx1233_eos, rxscan1234_done
  rxscan1234_scan:
    set_addr $I10, rxscan1234_loop
    rx1233_cur."!mark_push"(0, rx1233_pos, $I10)
  rxscan1234_done:
.annotate 'line', 482
  # rx subrule "sigil" subtype=capture negate=
    rx1233_cur."!cursor_pos"(rx1233_pos)
    $P10 = rx1233_cur."sigil"()
    unless $P10, rx1233_fail
    rx1233_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1233_pos = $P10."pos"()
  # rx rxquantr1235 ** 0..1
    set_addr $I10, rxquantr1235_done
    rx1233_cur."!mark_push"(0, rx1233_pos, $I10)
  rxquantr1235_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx1233_cur."!cursor_pos"(rx1233_pos)
    $P10 = rx1233_cur."twigil"()
    unless $P10, rx1233_fail
    goto rxsubrule1236_pass
  rxsubrule1236_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1233_fail
  rxsubrule1236_pass:
    set_addr $I10, rxsubrule1236_back
    rx1233_cur."!mark_push"(0, rx1233_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx1233_pos = $P10."pos"()
    set_addr $I10, rxquantr1235_done
    (rx1233_rep) = rx1233_cur."!mark_commit"($I10)
  rxquantr1235_done:
  alt1237_0:
.annotate 'line', 483
    set_addr $I10, alt1237_1
    rx1233_cur."!mark_push"(0, rx1233_pos, $I10)
  # rx subrule "ident" subtype=capture negate=
    rx1233_cur."!cursor_pos"(rx1233_pos)
    $P10 = rx1233_cur."ident"()
    unless $P10, rx1233_fail
    rx1233_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1233_pos = $P10."pos"()
    goto alt1237_end
  alt1237_1:
  # rx subcapture "name"
    set_addr $I10, rxcap_1238_fail
    rx1233_cur."!mark_push"(0, rx1233_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1233_pos, rx1233_eos, rx1233_fail
    sub $I10, rx1233_pos, rx1233_off
    substr $S10, rx1233_tgt, $I10, 1
    index $I11, "/!", $S10
    lt $I11, 0, rx1233_fail
    inc rx1233_pos
    set_addr $I10, rxcap_1238_fail
    ($I12, $I11) = rx1233_cur."!mark_peek"($I10)
    rx1233_cur."!cursor_pos"($I11)
    ($P10) = rx1233_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1233_pos, "")
    rx1233_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    goto rxcap_1238_done
  rxcap_1238_fail:
    goto rx1233_fail
  rxcap_1238_done:
  alt1237_end:
.annotate 'line', 481
  # rx pass
    rx1233_cur."!cursor_pass"(rx1233_pos, "param_var")
    if_null rx1233_debug, debug_1054
    rx1233_cur."!cursor_debug"("PASS", "param_var", " at pos=", rx1233_pos)
  debug_1054:
    .return (rx1233_cur)
  rx1233_restart:
.annotate 'line', 10
    if_null rx1233_debug, debug_1055
    rx1233_cur."!cursor_debug"("NEXT", "param_var")
  debug_1055:
  rx1233_fail:
    (rx1233_rep, rx1233_pos, $I10, $P10) = rx1233_cur."!mark_fail"(0)
    lt rx1233_pos, -1, rx1233_done
    eq rx1233_pos, -1, rx1233_fail
    jump $I10
  rx1233_done:
    rx1233_cur."!cursor_fail"()
    if_null rx1233_debug, debug_1056
    rx1233_cur."!cursor_debug"("FAIL", "param_var")
  debug_1056:
    .return (rx1233_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__param_var"  :subid("201_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1240 = self."!PREFIX__!subrule"("sigil", "")
    new $P1241, "ResizablePMCArray"
    push $P1241, $P1240
    .return ($P1241)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "named_param"  :subid("202_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1243_tgt
    .local int rx1243_pos
    .local int rx1243_off
    .local int rx1243_eos
    .local int rx1243_rep
    .local pmc rx1243_cur
    .local pmc rx1243_debug
    (rx1243_cur, rx1243_pos, rx1243_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1243_cur
    .local pmc match
    .lex "$/", match
    length rx1243_eos, rx1243_tgt
    gt rx1243_pos, rx1243_eos, rx1243_done
    set rx1243_off, 0
    lt rx1243_pos, 2, rx1243_start
    sub rx1243_off, rx1243_pos, 1
    substr rx1243_tgt, rx1243_tgt, rx1243_off
  rx1243_start:
    eq $I10, 1, rx1243_restart
    if_null rx1243_debug, debug_1057
    rx1243_cur."!cursor_debug"("START", "named_param")
  debug_1057:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1244_done
    goto rxscan1244_scan
  rxscan1244_loop:
    (rx1243_pos) = rx1243_cur."from"()
    inc rx1243_pos
    rx1243_cur."!cursor_from"(rx1243_pos)
    ge rx1243_pos, rx1243_eos, rxscan1244_done
  rxscan1244_scan:
    set_addr $I10, rxscan1244_loop
    rx1243_cur."!mark_push"(0, rx1243_pos, $I10)
  rxscan1244_done:
.annotate 'line', 487
  # rx literal  ":"
    add $I11, rx1243_pos, 1
    gt $I11, rx1243_eos, rx1243_fail
    sub $I11, rx1243_pos, rx1243_off
    ord $I11, rx1243_tgt, $I11
    ne $I11, 58, rx1243_fail
    add rx1243_pos, 1
  # rx subrule "param_var" subtype=capture negate=
    rx1243_cur."!cursor_pos"(rx1243_pos)
    $P10 = rx1243_cur."param_var"()
    unless $P10, rx1243_fail
    rx1243_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx1243_pos = $P10."pos"()
.annotate 'line', 486
  # rx pass
    rx1243_cur."!cursor_pass"(rx1243_pos, "named_param")
    if_null rx1243_debug, debug_1058
    rx1243_cur."!cursor_debug"("PASS", "named_param", " at pos=", rx1243_pos)
  debug_1058:
    .return (rx1243_cur)
  rx1243_restart:
.annotate 'line', 10
    if_null rx1243_debug, debug_1059
    rx1243_cur."!cursor_debug"("NEXT", "named_param")
  debug_1059:
  rx1243_fail:
    (rx1243_rep, rx1243_pos, $I10, $P10) = rx1243_cur."!mark_fail"(0)
    lt rx1243_pos, -1, rx1243_done
    eq rx1243_pos, -1, rx1243_fail
    jump $I10
  rx1243_done:
    rx1243_cur."!cursor_fail"()
    if_null rx1243_debug, debug_1060
    rx1243_cur."!cursor_debug"("FAIL", "named_param")
  debug_1060:
    .return (rx1243_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__named_param"  :subid("203_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1246 = self."!PREFIX__!subrule"("param_var", ":")
    new $P1247, "ResizablePMCArray"
    push $P1247, $P1246
    .return ($P1247)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "default_value"  :subid("204_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1249_tgt
    .local int rx1249_pos
    .local int rx1249_off
    .local int rx1249_eos
    .local int rx1249_rep
    .local pmc rx1249_cur
    .local pmc rx1249_debug
    (rx1249_cur, rx1249_pos, rx1249_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1249_cur
    .local pmc match
    .lex "$/", match
    length rx1249_eos, rx1249_tgt
    gt rx1249_pos, rx1249_eos, rx1249_done
    set rx1249_off, 0
    lt rx1249_pos, 2, rx1249_start
    sub rx1249_off, rx1249_pos, 1
    substr rx1249_tgt, rx1249_tgt, rx1249_off
  rx1249_start:
    eq $I10, 1, rx1249_restart
    if_null rx1249_debug, debug_1061
    rx1249_cur."!cursor_debug"("START", "default_value")
  debug_1061:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1250_done
    goto rxscan1250_scan
  rxscan1250_loop:
    (rx1249_pos) = rx1249_cur."from"()
    inc rx1249_pos
    rx1249_cur."!cursor_from"(rx1249_pos)
    ge rx1249_pos, rx1249_eos, rxscan1250_done
  rxscan1250_scan:
    set_addr $I10, rxscan1250_loop
    rx1249_cur."!mark_push"(0, rx1249_pos, $I10)
  rxscan1250_done:
.annotate 'line', 490
  # rx subrule "ws" subtype=method negate=
    rx1249_cur."!cursor_pos"(rx1249_pos)
    $P10 = rx1249_cur."ws"()
    unless $P10, rx1249_fail
    rx1249_pos = $P10."pos"()
  # rx literal  "="
    add $I11, rx1249_pos, 1
    gt $I11, rx1249_eos, rx1249_fail
    sub $I11, rx1249_pos, rx1249_off
    ord $I11, rx1249_tgt, $I11
    ne $I11, 61, rx1249_fail
    add rx1249_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1249_cur."!cursor_pos"(rx1249_pos)
    $P10 = rx1249_cur."ws"()
    unless $P10, rx1249_fail
    rx1249_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1249_cur."!cursor_pos"(rx1249_pos)
    $P10 = rx1249_cur."EXPR"("i=")
    unless $P10, rx1249_fail
    rx1249_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1249_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1249_cur."!cursor_pos"(rx1249_pos)
    $P10 = rx1249_cur."ws"()
    unless $P10, rx1249_fail
    rx1249_pos = $P10."pos"()
  # rx pass
    rx1249_cur."!cursor_pass"(rx1249_pos, "default_value")
    if_null rx1249_debug, debug_1062
    rx1249_cur."!cursor_debug"("PASS", "default_value", " at pos=", rx1249_pos)
  debug_1062:
    .return (rx1249_cur)
  rx1249_restart:
.annotate 'line', 10
    if_null rx1249_debug, debug_1063
    rx1249_cur."!cursor_debug"("NEXT", "default_value")
  debug_1063:
  rx1249_fail:
    (rx1249_rep, rx1249_pos, $I10, $P10) = rx1249_cur."!mark_fail"(0)
    lt rx1249_pos, -1, rx1249_done
    eq rx1249_pos, -1, rx1249_fail
    jump $I10
  rx1249_done:
    rx1249_cur."!cursor_fail"()
    if_null rx1249_debug, debug_1064
    rx1249_cur."!cursor_debug"("FAIL", "default_value")
  debug_1064:
    .return (rx1249_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__default_value"  :subid("205_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1255 = self."!PREFIX__!subrule"("ws", "")
    new $P1256, "ResizablePMCArray"
    push $P1256, $P1255
    .return ($P1256)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait"  :subid("206_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1258_tgt
    .local int rx1258_pos
    .local int rx1258_off
    .local int rx1258_eos
    .local int rx1258_rep
    .local pmc rx1258_cur
    .local pmc rx1258_debug
    (rx1258_cur, rx1258_pos, rx1258_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1258_cur
    .local pmc match
    .lex "$/", match
    length rx1258_eos, rx1258_tgt
    gt rx1258_pos, rx1258_eos, rx1258_done
    set rx1258_off, 0
    lt rx1258_pos, 2, rx1258_start
    sub rx1258_off, rx1258_pos, 1
    substr rx1258_tgt, rx1258_tgt, rx1258_off
  rx1258_start:
    eq $I10, 1, rx1258_restart
    if_null rx1258_debug, debug_1065
    rx1258_cur."!cursor_debug"("START", "trait")
  debug_1065:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1259_done
    goto rxscan1259_scan
  rxscan1259_loop:
    (rx1258_pos) = rx1258_cur."from"()
    inc rx1258_pos
    rx1258_cur."!cursor_from"(rx1258_pos)
    ge rx1258_pos, rx1258_eos, rxscan1259_done
  rxscan1259_scan:
    set_addr $I10, rxscan1259_loop
    rx1258_cur."!mark_push"(0, rx1258_pos, $I10)
  rxscan1259_done:
.annotate 'line', 492
  # rx subrule "ws" subtype=method negate=
    rx1258_cur."!cursor_pos"(rx1258_pos)
    $P10 = rx1258_cur."ws"()
    unless $P10, rx1258_fail
    rx1258_pos = $P10."pos"()
  # rx subrule "trait_mod" subtype=capture negate=
    rx1258_cur."!cursor_pos"(rx1258_pos)
    $P10 = rx1258_cur."trait_mod"()
    unless $P10, rx1258_fail
    rx1258_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("trait_mod")
    rx1258_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1258_cur."!cursor_pos"(rx1258_pos)
    $P10 = rx1258_cur."ws"()
    unless $P10, rx1258_fail
    rx1258_pos = $P10."pos"()
  # rx pass
    rx1258_cur."!cursor_pass"(rx1258_pos, "trait")
    if_null rx1258_debug, debug_1066
    rx1258_cur."!cursor_debug"("PASS", "trait", " at pos=", rx1258_pos)
  debug_1066:
    .return (rx1258_cur)
  rx1258_restart:
.annotate 'line', 10
    if_null rx1258_debug, debug_1067
    rx1258_cur."!cursor_debug"("NEXT", "trait")
  debug_1067:
  rx1258_fail:
    (rx1258_rep, rx1258_pos, $I10, $P10) = rx1258_cur."!mark_fail"(0)
    lt rx1258_pos, -1, rx1258_done
    eq rx1258_pos, -1, rx1258_fail
    jump $I10
  rx1258_done:
    rx1258_cur."!cursor_fail"()
    if_null rx1258_debug, debug_1068
    rx1258_cur."!cursor_debug"("FAIL", "trait")
  debug_1068:
    .return (rx1258_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait"  :subid("207_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1263 = self."!PREFIX__!subrule"("ws", "")
    new $P1264, "ResizablePMCArray"
    push $P1264, $P1263
    .return ($P1264)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod"  :subid("208_1304456155.152")
    .param pmc param_1266
.annotate 'line', 494
    .lex "self", param_1266
    $P1267 = param_1266."!protoregex"("trait_mod")
    .return ($P1267)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod"  :subid("209_1304456155.152")
    .param pmc param_1269
.annotate 'line', 494
    .lex "self", param_1269
    $P1270 = param_1269."!PREFIX__!protoregex"("trait_mod")
    .return ($P1270)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod:sym<is>"  :subid("210_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1272_tgt
    .local int rx1272_pos
    .local int rx1272_off
    .local int rx1272_eos
    .local int rx1272_rep
    .local pmc rx1272_cur
    .local pmc rx1272_debug
    (rx1272_cur, rx1272_pos, rx1272_tgt, $I10) = self."!cursor_start"()
    rx1272_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx1272_cur
    .local pmc match
    .lex "$/", match
    length rx1272_eos, rx1272_tgt
    gt rx1272_pos, rx1272_eos, rx1272_done
    set rx1272_off, 0
    lt rx1272_pos, 2, rx1272_start
    sub rx1272_off, rx1272_pos, 1
    substr rx1272_tgt, rx1272_tgt, rx1272_off
  rx1272_start:
    eq $I10, 1, rx1272_restart
    if_null rx1272_debug, debug_1069
    rx1272_cur."!cursor_debug"("START", "trait_mod:sym<is>")
  debug_1069:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1273_done
    goto rxscan1273_scan
  rxscan1273_loop:
    (rx1272_pos) = rx1272_cur."from"()
    inc rx1272_pos
    rx1272_cur."!cursor_from"(rx1272_pos)
    ge rx1272_pos, rx1272_eos, rxscan1273_done
  rxscan1273_scan:
    set_addr $I10, rxscan1273_loop
    rx1272_cur."!mark_push"(0, rx1272_pos, $I10)
  rxscan1273_done:
.annotate 'line', 495
  # rx subcapture "sym"
    set_addr $I10, rxcap_1274_fail
    rx1272_cur."!mark_push"(0, rx1272_pos, $I10)
  # rx literal  "is"
    add $I11, rx1272_pos, 2
    gt $I11, rx1272_eos, rx1272_fail
    sub $I11, rx1272_pos, rx1272_off
    substr $S10, rx1272_tgt, $I11, 2
    ne $S10, "is", rx1272_fail
    add rx1272_pos, 2
    set_addr $I10, rxcap_1274_fail
    ($I12, $I11) = rx1272_cur."!mark_peek"($I10)
    rx1272_cur."!cursor_pos"($I11)
    ($P10) = rx1272_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1272_pos, "")
    rx1272_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1274_done
  rxcap_1274_fail:
    goto rx1272_fail
  rxcap_1274_done:
  # rx subrule "ws" subtype=method negate=
    rx1272_cur."!cursor_pos"(rx1272_pos)
    $P10 = rx1272_cur."ws"()
    unless $P10, rx1272_fail
    rx1272_pos = $P10."pos"()
  # rx subrule "deflongname" subtype=capture negate=
    rx1272_cur."!cursor_pos"(rx1272_pos)
    $P10 = rx1272_cur."deflongname"()
    unless $P10, rx1272_fail
    rx1272_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx1272_pos = $P10."pos"()
  # rx rxquantr1276 ** 0..1
    set_addr $I10, rxquantr1276_done
    rx1272_cur."!mark_push"(0, rx1272_pos, $I10)
  rxquantr1276_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx1272_cur."!cursor_pos"(rx1272_pos)
    $P10 = rx1272_cur."circumfix"()
    unless $P10, rx1272_fail
    goto rxsubrule1277_pass
  rxsubrule1277_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1272_fail
  rxsubrule1277_pass:
    set_addr $I10, rxsubrule1277_back
    rx1272_cur."!mark_push"(0, rx1272_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx1272_pos = $P10."pos"()
    set_addr $I10, rxquantr1276_done
    (rx1272_rep) = rx1272_cur."!mark_commit"($I10)
  rxquantr1276_done:
  # rx subrule "ws" subtype=method negate=
    rx1272_cur."!cursor_pos"(rx1272_pos)
    $P10 = rx1272_cur."ws"()
    unless $P10, rx1272_fail
    rx1272_pos = $P10."pos"()
  # rx pass
    rx1272_cur."!cursor_pass"(rx1272_pos, "trait_mod:sym<is>")
    if_null rx1272_debug, debug_1070
    rx1272_cur."!cursor_debug"("PASS", "trait_mod:sym<is>", " at pos=", rx1272_pos)
  debug_1070:
    .return (rx1272_cur)
  rx1272_restart:
.annotate 'line', 10
    if_null rx1272_debug, debug_1071
    rx1272_cur."!cursor_debug"("NEXT", "trait_mod:sym<is>")
  debug_1071:
  rx1272_fail:
    (rx1272_rep, rx1272_pos, $I10, $P10) = rx1272_cur."!mark_fail"(0)
    lt rx1272_pos, -1, rx1272_done
    eq rx1272_pos, -1, rx1272_fail
    jump $I10
  rx1272_done:
    rx1272_cur."!cursor_fail"()
    if_null rx1272_debug, debug_1072
    rx1272_cur."!cursor_debug"("FAIL", "trait_mod:sym<is>")
  debug_1072:
    .return (rx1272_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod:sym<is>"  :subid("211_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1280 = self."!PREFIX__!subrule"("ws", "is")
    new $P1281, "ResizablePMCArray"
    push $P1281, $P1280
    .return ($P1281)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "regex_declarator"  :subid("212_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1283_tgt
    .local int rx1283_pos
    .local int rx1283_off
    .local int rx1283_eos
    .local int rx1283_rep
    .local pmc rx1283_cur
    .local pmc rx1283_debug
    (rx1283_cur, rx1283_pos, rx1283_tgt, $I10) = self."!cursor_start"()
    rx1283_cur."!cursor_caparray"("signature")
    .lex unicode:"$\x{a2}", rx1283_cur
    .local pmc match
    .lex "$/", match
    length rx1283_eos, rx1283_tgt
    gt rx1283_pos, rx1283_eos, rx1283_done
    set rx1283_off, 0
    lt rx1283_pos, 2, rx1283_start
    sub rx1283_off, rx1283_pos, 1
    substr rx1283_tgt, rx1283_tgt, rx1283_off
  rx1283_start:
    eq $I10, 1, rx1283_restart
    if_null rx1283_debug, debug_1073
    rx1283_cur."!cursor_debug"("START", "regex_declarator")
  debug_1073:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1284_done
    goto rxscan1284_scan
  rxscan1284_loop:
    (rx1283_pos) = rx1283_cur."from"()
    inc rx1283_pos
    rx1283_cur."!cursor_from"(rx1283_pos)
    ge rx1283_pos, rx1283_eos, rxscan1284_done
  rxscan1284_scan:
    set_addr $I10, rxscan1284_loop
    rx1283_cur."!mark_push"(0, rx1283_pos, $I10)
  rxscan1284_done:
.annotate 'line', 497
  # rx subrule "ws" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ws"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
  alt1286_0:
.annotate 'line', 498
    set_addr $I10, alt1286_1
    rx1283_cur."!mark_push"(0, rx1283_pos, $I10)
.annotate 'line', 499
  # rx subrule "ws" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ws"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
  # rx subcapture "proto"
    set_addr $I10, rxcap_1288_fail
    rx1283_cur."!mark_push"(0, rx1283_pos, $I10)
  # rx literal  "proto"
    add $I11, rx1283_pos, 5
    gt $I11, rx1283_eos, rx1283_fail
    sub $I11, rx1283_pos, rx1283_off
    substr $S10, rx1283_tgt, $I11, 5
    ne $S10, "proto", rx1283_fail
    add rx1283_pos, 5
    set_addr $I10, rxcap_1288_fail
    ($I12, $I11) = rx1283_cur."!mark_peek"($I10)
    rx1283_cur."!cursor_pos"($I11)
    ($P10) = rx1283_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1283_pos, "")
    rx1283_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("proto")
    goto rxcap_1288_done
  rxcap_1288_fail:
    goto rx1283_fail
  rxcap_1288_done:
  # rx subrule "ws" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ws"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
  alt1290_0:
    set_addr $I10, alt1290_1
    rx1283_cur."!mark_push"(0, rx1283_pos, $I10)
  # rx literal  "regex"
    add $I11, rx1283_pos, 5
    gt $I11, rx1283_eos, rx1283_fail
    sub $I11, rx1283_pos, rx1283_off
    substr $S10, rx1283_tgt, $I11, 5
    ne $S10, "regex", rx1283_fail
    add rx1283_pos, 5
    goto alt1290_end
  alt1290_1:
    set_addr $I10, alt1290_2
    rx1283_cur."!mark_push"(0, rx1283_pos, $I10)
  # rx literal  "token"
    add $I11, rx1283_pos, 5
    gt $I11, rx1283_eos, rx1283_fail
    sub $I11, rx1283_pos, rx1283_off
    substr $S10, rx1283_tgt, $I11, 5
    ne $S10, "token", rx1283_fail
    add rx1283_pos, 5
    goto alt1290_end
  alt1290_2:
  # rx literal  "rule"
    add $I11, rx1283_pos, 4
    gt $I11, rx1283_eos, rx1283_fail
    sub $I11, rx1283_pos, rx1283_off
    substr $S10, rx1283_tgt, $I11, 4
    ne $S10, "rule", rx1283_fail
    add rx1283_pos, 4
  alt1290_end:
  # rx subrule "ws" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ws"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
.annotate 'line', 500
  # rx subrule "deflongname" subtype=capture negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."deflongname"()
    unless $P10, rx1283_fail
    rx1283_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1283_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ws"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
  alt1293_0:
.annotate 'line', 501
    set_addr $I10, alt1293_1
    rx1283_cur."!mark_push"(0, rx1283_pos, $I10)
.annotate 'line', 502
  # rx subrule "ws" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ws"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx1283_pos, 1
    gt $I11, rx1283_eos, rx1283_fail
    sub $I11, rx1283_pos, rx1283_off
    ord $I11, rx1283_tgt, $I11
    ne $I11, 123, rx1283_fail
    add rx1283_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ws"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
  # rx literal  "<...>"
    add $I11, rx1283_pos, 5
    gt $I11, rx1283_eos, rx1283_fail
    sub $I11, rx1283_pos, rx1283_off
    substr $S10, rx1283_tgt, $I11, 5
    ne $S10, "<...>", rx1283_fail
    add rx1283_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ws"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1283_pos, 1
    gt $I11, rx1283_eos, rx1283_fail
    sub $I11, rx1283_pos, rx1283_off
    ord $I11, rx1283_tgt, $I11
    ne $I11, 125, rx1283_fail
    add rx1283_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ENDSTMT"()
    unless $P10, rx1283_fail
  # rx subrule "ws" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ws"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
    goto alt1293_end
  alt1293_1:
    set_addr $I10, alt1293_2
    rx1283_cur."!mark_push"(0, rx1283_pos, $I10)
.annotate 'line', 503
  # rx subrule "ws" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ws"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx1283_pos, 1
    gt $I11, rx1283_eos, rx1283_fail
    sub $I11, rx1283_pos, rx1283_off
    ord $I11, rx1283_tgt, $I11
    ne $I11, 123, rx1283_fail
    add rx1283_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ws"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
  # rx literal  "<*>"
    add $I11, rx1283_pos, 3
    gt $I11, rx1283_eos, rx1283_fail
    sub $I11, rx1283_pos, rx1283_off
    substr $S10, rx1283_tgt, $I11, 3
    ne $S10, "<*>", rx1283_fail
    add rx1283_pos, 3
  # rx subrule "ws" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ws"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1283_pos, 1
    gt $I11, rx1283_eos, rx1283_fail
    sub $I11, rx1283_pos, rx1283_off
    ord $I11, rx1283_tgt, $I11
    ne $I11, 125, rx1283_fail
    add rx1283_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ENDSTMT"()
    unless $P10, rx1283_fail
  # rx subrule "ws" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ws"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
    goto alt1293_end
  alt1293_2:
.annotate 'line', 504
  # rx subrule "ws" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ws"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."panic"("Proto regex body must be <*> (or <...>, which is deprecated)")
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ws"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
  alt1293_end:
.annotate 'line', 505
  # rx subrule "ws" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ws"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
.annotate 'line', 499
    goto alt1286_end
  alt1286_1:
.annotate 'line', 506
  # rx subrule "ws" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ws"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
  # rx subcapture "sym"
    set_addr $I10, rxcap_1307_fail
    rx1283_cur."!mark_push"(0, rx1283_pos, $I10)
  alt1306_0:
    set_addr $I10, alt1306_1
    rx1283_cur."!mark_push"(0, rx1283_pos, $I10)
  # rx literal  "regex"
    add $I11, rx1283_pos, 5
    gt $I11, rx1283_eos, rx1283_fail
    sub $I11, rx1283_pos, rx1283_off
    substr $S10, rx1283_tgt, $I11, 5
    ne $S10, "regex", rx1283_fail
    add rx1283_pos, 5
    goto alt1306_end
  alt1306_1:
    set_addr $I10, alt1306_2
    rx1283_cur."!mark_push"(0, rx1283_pos, $I10)
  # rx literal  "token"
    add $I11, rx1283_pos, 5
    gt $I11, rx1283_eos, rx1283_fail
    sub $I11, rx1283_pos, rx1283_off
    substr $S10, rx1283_tgt, $I11, 5
    ne $S10, "token", rx1283_fail
    add rx1283_pos, 5
    goto alt1306_end
  alt1306_2:
  # rx literal  "rule"
    add $I11, rx1283_pos, 4
    gt $I11, rx1283_eos, rx1283_fail
    sub $I11, rx1283_pos, rx1283_off
    substr $S10, rx1283_tgt, $I11, 4
    ne $S10, "rule", rx1283_fail
    add rx1283_pos, 4
  alt1306_end:
    set_addr $I10, rxcap_1307_fail
    ($I12, $I11) = rx1283_cur."!mark_peek"($I10)
    rx1283_cur."!cursor_pos"($I11)
    ($P10) = rx1283_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1283_pos, "")
    rx1283_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1307_done
  rxcap_1307_fail:
    goto rx1283_fail
  rxcap_1307_done:
  # rx subrule "ws" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ws"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
.annotate 'line', 507
  # rx subrule "deflongname" subtype=capture negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."deflongname"()
    unless $P10, rx1283_fail
    rx1283_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1283_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ws"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
.annotate 'line', 508
  # rx subrule "newpad" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."newpad"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ws"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
.annotate 'line', 509
  # rx rxquantr1311 ** 0..1
    set_addr $I10, rxquantr1311_done
    rx1283_cur."!mark_push"(0, rx1283_pos, $I10)
  rxquantr1311_loop:
  # rx subrule "ws" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ws"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1283_pos, 1
    gt $I11, rx1283_eos, rx1283_fail
    sub $I11, rx1283_pos, rx1283_off
    ord $I11, rx1283_tgt, $I11
    ne $I11, 40, rx1283_fail
    add rx1283_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ws"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."signature"()
    unless $P10, rx1283_fail
    rx1283_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx1283_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ws"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1283_pos, 1
    gt $I11, rx1283_eos, rx1283_fail
    sub $I11, rx1283_pos, rx1283_off
    ord $I11, rx1283_tgt, $I11
    ne $I11, 41, rx1283_fail
    add rx1283_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ws"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
    set_addr $I10, rxquantr1311_done
    (rx1283_rep) = rx1283_cur."!mark_commit"($I10)
  rxquantr1311_done:
  # rx subrule "ws" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ws"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
.annotate 'line', 510
  # rx reduce name="regex_declarator" key="open"
    rx1283_cur."!cursor_pos"(rx1283_pos)
    rx1283_cur."!reduce"("regex_declarator", "open")
  # rx subrule "ws" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ws"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
.annotate 'line', 511
  # rx literal  "{"
    add $I11, rx1283_pos, 1
    gt $I11, rx1283_eos, rx1283_fail
    sub $I11, rx1283_pos, rx1283_off
    ord $I11, rx1283_tgt, $I11
    ne $I11, 123, rx1283_fail
    add rx1283_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."LANG"("Regex", "nibbler")
    unless $P10, rx1283_fail
    rx1283_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx1283_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1283_pos, 1
    gt $I11, rx1283_eos, rx1283_fail
    sub $I11, rx1283_pos, rx1283_off
    ord $I11, rx1283_tgt, $I11
    ne $I11, 125, rx1283_fail
    add rx1283_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ENDSTMT"()
    unless $P10, rx1283_fail
  # rx subrule "ws" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ws"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
  alt1286_end:
.annotate 'line', 512
  # rx subrule "ws" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ws"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
.annotate 'line', 497
  # rx pass
    rx1283_cur."!cursor_pass"(rx1283_pos, "regex_declarator")
    if_null rx1283_debug, debug_1074
    rx1283_cur."!cursor_debug"("PASS", "regex_declarator", " at pos=", rx1283_pos)
  debug_1074:
    .return (rx1283_cur)
  rx1283_restart:
.annotate 'line', 10
    if_null rx1283_debug, debug_1075
    rx1283_cur."!cursor_debug"("NEXT", "regex_declarator")
  debug_1075:
  rx1283_fail:
    (rx1283_rep, rx1283_pos, $I10, $P10) = rx1283_cur."!mark_fail"(0)
    lt rx1283_pos, -1, rx1283_done
    eq rx1283_pos, -1, rx1283_fail
    jump $I10
  rx1283_done:
    rx1283_cur."!cursor_fail"()
    if_null rx1283_debug, debug_1076
    rx1283_cur."!cursor_debug"("FAIL", "regex_declarator")
  debug_1076:
    .return (rx1283_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__regex_declarator"  :subid("213_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1321 = self."!PREFIX__!subrule"("ws", "")
    new $P1322, "ResizablePMCArray"
    push $P1322, $P1321
    .return ($P1322)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "dotty"  :subid("214_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1324_tgt
    .local int rx1324_pos
    .local int rx1324_off
    .local int rx1324_eos
    .local int rx1324_rep
    .local pmc rx1324_cur
    .local pmc rx1324_debug
    (rx1324_cur, rx1324_pos, rx1324_tgt, $I10) = self."!cursor_start"()
    rx1324_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1324_cur
    .local pmc match
    .lex "$/", match
    length rx1324_eos, rx1324_tgt
    gt rx1324_pos, rx1324_eos, rx1324_done
    set rx1324_off, 0
    lt rx1324_pos, 2, rx1324_start
    sub rx1324_off, rx1324_pos, 1
    substr rx1324_tgt, rx1324_tgt, rx1324_off
  rx1324_start:
    eq $I10, 1, rx1324_restart
    if_null rx1324_debug, debug_1077
    rx1324_cur."!cursor_debug"("START", "dotty")
  debug_1077:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1325_done
    goto rxscan1325_scan
  rxscan1325_loop:
    (rx1324_pos) = rx1324_cur."from"()
    inc rx1324_pos
    rx1324_cur."!cursor_from"(rx1324_pos)
    ge rx1324_pos, rx1324_eos, rxscan1325_done
  rxscan1325_scan:
    set_addr $I10, rxscan1325_loop
    rx1324_cur."!mark_push"(0, rx1324_pos, $I10)
  rxscan1325_done:
.annotate 'line', 516
  # rx literal  "."
    add $I11, rx1324_pos, 1
    gt $I11, rx1324_eos, rx1324_fail
    sub $I11, rx1324_pos, rx1324_off
    ord $I11, rx1324_tgt, $I11
    ne $I11, 46, rx1324_fail
    add rx1324_pos, 1
  alt1326_0:
.annotate 'line', 517
    set_addr $I10, alt1326_1
    rx1324_cur."!mark_push"(0, rx1324_pos, $I10)
  # rx subrule "deflongname" subtype=capture negate=
    rx1324_cur."!cursor_pos"(rx1324_pos)
    $P10 = rx1324_cur."deflongname"()
    unless $P10, rx1324_fail
    rx1324_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname=deflongname")
    rx1324_pos = $P10."pos"()
    goto alt1326_end
  alt1326_1:
.annotate 'line', 518
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1324_pos, rx1324_off
    substr $S10, rx1324_tgt, $I10, 1
    index $I11, "'\"", $S10
    lt $I11, 0, rx1324_fail
  # rx subrule "quote" subtype=capture negate=
    rx1324_cur."!cursor_pos"(rx1324_pos)
    $P10 = rx1324_cur."quote"()
    unless $P10, rx1324_fail
    rx1324_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1324_pos = $P10."pos"()
  alt1327_0:
.annotate 'line', 519
    set_addr $I10, alt1327_1
    rx1324_cur."!mark_push"(0, rx1324_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1324_pos, rx1324_off
    substr $S10, rx1324_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1324_fail
    goto alt1327_end
  alt1327_1:
  # rx subrule "panic" subtype=method negate=
    rx1324_cur."!cursor_pos"(rx1324_pos)
    $P10 = rx1324_cur."panic"("Quoted method name requires parenthesized arguments")
    unless $P10, rx1324_fail
    rx1324_pos = $P10."pos"()
  alt1327_end:
  alt1326_end:
.annotate 'line', 525
  # rx rxquantr1328 ** 0..1
    set_addr $I10, rxquantr1328_done
    rx1324_cur."!mark_push"(0, rx1324_pos, $I10)
  rxquantr1328_loop:
  alt1329_0:
.annotate 'line', 522
    set_addr $I10, alt1329_1
    rx1324_cur."!mark_push"(0, rx1324_pos, $I10)
.annotate 'line', 523
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1324_pos, rx1324_off
    substr $S10, rx1324_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1324_fail
  # rx subrule "args" subtype=capture negate=
    rx1324_cur."!cursor_pos"(rx1324_pos)
    $P10 = rx1324_cur."args"()
    unless $P10, rx1324_fail
    rx1324_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1324_pos = $P10."pos"()
    goto alt1329_end
  alt1329_1:
.annotate 'line', 524
  # rx literal  ":"
    add $I11, rx1324_pos, 1
    gt $I11, rx1324_eos, rx1324_fail
    sub $I11, rx1324_pos, rx1324_off
    ord $I11, rx1324_tgt, $I11
    ne $I11, 58, rx1324_fail
    add rx1324_pos, 1
  # rx charclass s
    ge rx1324_pos, rx1324_eos, rx1324_fail
    sub $I10, rx1324_pos, rx1324_off
    is_cclass $I11, 32, rx1324_tgt, $I10
    unless $I11, rx1324_fail
    inc rx1324_pos
  # rx subrule "arglist" subtype=capture negate=
    rx1324_cur."!cursor_pos"(rx1324_pos)
    $P10 = rx1324_cur."arglist"()
    unless $P10, rx1324_fail
    rx1324_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1324_pos = $P10."pos"()
  alt1329_end:
.annotate 'line', 525
    set_addr $I10, rxquantr1328_done
    (rx1324_rep) = rx1324_cur."!mark_commit"($I10)
  rxquantr1328_done:
.annotate 'line', 515
  # rx pass
    rx1324_cur."!cursor_pass"(rx1324_pos, "dotty")
    if_null rx1324_debug, debug_1078
    rx1324_cur."!cursor_debug"("PASS", "dotty", " at pos=", rx1324_pos)
  debug_1078:
    .return (rx1324_cur)
  rx1324_restart:
.annotate 'line', 10
    if_null rx1324_debug, debug_1079
    rx1324_cur."!cursor_debug"("NEXT", "dotty")
  debug_1079:
  rx1324_fail:
    (rx1324_rep, rx1324_pos, $I10, $P10) = rx1324_cur."!mark_fail"(0)
    lt rx1324_pos, -1, rx1324_done
    eq rx1324_pos, -1, rx1324_fail
    jump $I10
  rx1324_done:
    rx1324_cur."!cursor_fail"()
    if_null rx1324_debug, debug_1080
    rx1324_cur."!cursor_debug"("FAIL", "dotty")
  debug_1080:
    .return (rx1324_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__dotty"  :subid("215_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1331 = self."!PREFIX__!subrule"("deflongname", ".")
    new $P1332, "ResizablePMCArray"
    push $P1332, "'"
    push $P1332, "\""
    push $P1332, $P1331
    .return ($P1332)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term"  :subid("216_1304456155.152")
    .param pmc param_1334
.annotate 'line', 529
    .lex "self", param_1334
    $P1335 = param_1334."!protoregex"("term")
    .return ($P1335)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term"  :subid("217_1304456155.152")
    .param pmc param_1337
.annotate 'line', 529
    .lex "self", param_1337
    $P1338 = param_1337."!PREFIX__!protoregex"("term")
    .return ($P1338)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<self>"  :subid("218_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1340_tgt
    .local int rx1340_pos
    .local int rx1340_off
    .local int rx1340_eos
    .local int rx1340_rep
    .local pmc rx1340_cur
    .local pmc rx1340_debug
    (rx1340_cur, rx1340_pos, rx1340_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1340_cur
    .local pmc match
    .lex "$/", match
    length rx1340_eos, rx1340_tgt
    gt rx1340_pos, rx1340_eos, rx1340_done
    set rx1340_off, 0
    lt rx1340_pos, 2, rx1340_start
    sub rx1340_off, rx1340_pos, 1
    substr rx1340_tgt, rx1340_tgt, rx1340_off
  rx1340_start:
    eq $I10, 1, rx1340_restart
    if_null rx1340_debug, debug_1081
    rx1340_cur."!cursor_debug"("START", "term:sym<self>")
  debug_1081:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1341_done
    goto rxscan1341_scan
  rxscan1341_loop:
    (rx1340_pos) = rx1340_cur."from"()
    inc rx1340_pos
    rx1340_cur."!cursor_from"(rx1340_pos)
    ge rx1340_pos, rx1340_eos, rxscan1341_done
  rxscan1341_scan:
    set_addr $I10, rxscan1341_loop
    rx1340_cur."!mark_push"(0, rx1340_pos, $I10)
  rxscan1341_done:
.annotate 'line', 531
  # rx subcapture "sym"
    set_addr $I10, rxcap_1342_fail
    rx1340_cur."!mark_push"(0, rx1340_pos, $I10)
  # rx literal  "self"
    add $I11, rx1340_pos, 4
    gt $I11, rx1340_eos, rx1340_fail
    sub $I11, rx1340_pos, rx1340_off
    substr $S10, rx1340_tgt, $I11, 4
    ne $S10, "self", rx1340_fail
    add rx1340_pos, 4
    set_addr $I10, rxcap_1342_fail
    ($I12, $I11) = rx1340_cur."!mark_peek"($I10)
    rx1340_cur."!cursor_pos"($I11)
    ($P10) = rx1340_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1340_pos, "")
    rx1340_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1342_done
  rxcap_1342_fail:
    goto rx1340_fail
  rxcap_1342_done:
  # rxanchor rwb
    le rx1340_pos, 0, rx1340_fail
    sub $I10, rx1340_pos, rx1340_off
    is_cclass $I11, 8192, rx1340_tgt, $I10
    if $I11, rx1340_fail
    dec $I10
    is_cclass $I11, 8192, rx1340_tgt, $I10
    unless $I11, rx1340_fail
  # rx pass
    rx1340_cur."!cursor_pass"(rx1340_pos, "term:sym<self>")
    if_null rx1340_debug, debug_1082
    rx1340_cur."!cursor_debug"("PASS", "term:sym<self>", " at pos=", rx1340_pos)
  debug_1082:
    .return (rx1340_cur)
  rx1340_restart:
.annotate 'line', 10
    if_null rx1340_debug, debug_1083
    rx1340_cur."!cursor_debug"("NEXT", "term:sym<self>")
  debug_1083:
  rx1340_fail:
    (rx1340_rep, rx1340_pos, $I10, $P10) = rx1340_cur."!mark_fail"(0)
    lt rx1340_pos, -1, rx1340_done
    eq rx1340_pos, -1, rx1340_fail
    jump $I10
  rx1340_done:
    rx1340_cur."!cursor_fail"()
    if_null rx1340_debug, debug_1084
    rx1340_cur."!cursor_debug"("FAIL", "term:sym<self>")
  debug_1084:
    .return (rx1340_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<self>"  :subid("219_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    new $P1344, "ResizablePMCArray"
    push $P1344, "self"
    .return ($P1344)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<identifier>"  :subid("220_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1346_tgt
    .local int rx1346_pos
    .local int rx1346_off
    .local int rx1346_eos
    .local int rx1346_rep
    .local pmc rx1346_cur
    .local pmc rx1346_debug
    (rx1346_cur, rx1346_pos, rx1346_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1346_cur
    .local pmc match
    .lex "$/", match
    length rx1346_eos, rx1346_tgt
    gt rx1346_pos, rx1346_eos, rx1346_done
    set rx1346_off, 0
    lt rx1346_pos, 2, rx1346_start
    sub rx1346_off, rx1346_pos, 1
    substr rx1346_tgt, rx1346_tgt, rx1346_off
  rx1346_start:
    eq $I10, 1, rx1346_restart
    if_null rx1346_debug, debug_1085
    rx1346_cur."!cursor_debug"("START", "term:sym<identifier>")
  debug_1085:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1347_done
    goto rxscan1347_scan
  rxscan1347_loop:
    (rx1346_pos) = rx1346_cur."from"()
    inc rx1346_pos
    rx1346_cur."!cursor_from"(rx1346_pos)
    ge rx1346_pos, rx1346_eos, rxscan1347_done
  rxscan1347_scan:
    set_addr $I10, rxscan1347_loop
    rx1346_cur."!mark_push"(0, rx1346_pos, $I10)
  rxscan1347_done:
.annotate 'line', 534
  # rx subrule "deflongname" subtype=capture negate=
    rx1346_cur."!cursor_pos"(rx1346_pos)
    $P10 = rx1346_cur."deflongname"()
    unless $P10, rx1346_fail
    rx1346_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1346_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1346_pos, rx1346_off
    substr $S10, rx1346_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1346_fail
  # rx subrule "args" subtype=capture negate=
    rx1346_cur."!cursor_pos"(rx1346_pos)
    $P10 = rx1346_cur."args"()
    unless $P10, rx1346_fail
    rx1346_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1346_pos = $P10."pos"()
.annotate 'line', 533
  # rx pass
    rx1346_cur."!cursor_pass"(rx1346_pos, "term:sym<identifier>")
    if_null rx1346_debug, debug_1086
    rx1346_cur."!cursor_debug"("PASS", "term:sym<identifier>", " at pos=", rx1346_pos)
  debug_1086:
    .return (rx1346_cur)
  rx1346_restart:
.annotate 'line', 10
    if_null rx1346_debug, debug_1087
    rx1346_cur."!cursor_debug"("NEXT", "term:sym<identifier>")
  debug_1087:
  rx1346_fail:
    (rx1346_rep, rx1346_pos, $I10, $P10) = rx1346_cur."!mark_fail"(0)
    lt rx1346_pos, -1, rx1346_done
    eq rx1346_pos, -1, rx1346_fail
    jump $I10
  rx1346_done:
    rx1346_cur."!cursor_fail"()
    if_null rx1346_debug, debug_1088
    rx1346_cur."!cursor_debug"("FAIL", "term:sym<identifier>")
  debug_1088:
    .return (rx1346_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<identifier>"  :subid("221_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1349 = self."!PREFIX__!subrule"("deflongname", "")
    new $P1350, "ResizablePMCArray"
    push $P1350, $P1349
    .return ($P1350)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<name>"  :subid("222_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1352_tgt
    .local int rx1352_pos
    .local int rx1352_off
    .local int rx1352_eos
    .local int rx1352_rep
    .local pmc rx1352_cur
    .local pmc rx1352_debug
    (rx1352_cur, rx1352_pos, rx1352_tgt, $I10) = self."!cursor_start"()
    rx1352_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1352_cur
    .local pmc match
    .lex "$/", match
    length rx1352_eos, rx1352_tgt
    gt rx1352_pos, rx1352_eos, rx1352_done
    set rx1352_off, 0
    lt rx1352_pos, 2, rx1352_start
    sub rx1352_off, rx1352_pos, 1
    substr rx1352_tgt, rx1352_tgt, rx1352_off
  rx1352_start:
    eq $I10, 1, rx1352_restart
    if_null rx1352_debug, debug_1089
    rx1352_cur."!cursor_debug"("START", "term:sym<name>")
  debug_1089:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1353_done
    goto rxscan1353_scan
  rxscan1353_loop:
    (rx1352_pos) = rx1352_cur."from"()
    inc rx1352_pos
    rx1352_cur."!cursor_from"(rx1352_pos)
    ge rx1352_pos, rx1352_eos, rxscan1353_done
  rxscan1353_scan:
    set_addr $I10, rxscan1353_loop
    rx1352_cur."!mark_push"(0, rx1352_pos, $I10)
  rxscan1353_done:
.annotate 'line', 538
  # rx subrule "name" subtype=capture negate=
    rx1352_cur."!cursor_pos"(rx1352_pos)
    $P10 = rx1352_cur."name"()
    unless $P10, rx1352_fail
    rx1352_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1352_pos = $P10."pos"()
  # rx rxquantr1354 ** 0..1
    set_addr $I10, rxquantr1354_done
    rx1352_cur."!mark_push"(0, rx1352_pos, $I10)
  rxquantr1354_loop:
  # rx subrule "args" subtype=capture negate=
    rx1352_cur."!cursor_pos"(rx1352_pos)
    $P10 = rx1352_cur."args"()
    unless $P10, rx1352_fail
    goto rxsubrule1355_pass
  rxsubrule1355_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1352_fail
  rxsubrule1355_pass:
    set_addr $I10, rxsubrule1355_back
    rx1352_cur."!mark_push"(0, rx1352_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1352_pos = $P10."pos"()
    set_addr $I10, rxquantr1354_done
    (rx1352_rep) = rx1352_cur."!mark_commit"($I10)
  rxquantr1354_done:
.annotate 'line', 537
  # rx pass
    rx1352_cur."!cursor_pass"(rx1352_pos, "term:sym<name>")
    if_null rx1352_debug, debug_1090
    rx1352_cur."!cursor_debug"("PASS", "term:sym<name>", " at pos=", rx1352_pos)
  debug_1090:
    .return (rx1352_cur)
  rx1352_restart:
.annotate 'line', 10
    if_null rx1352_debug, debug_1091
    rx1352_cur."!cursor_debug"("NEXT", "term:sym<name>")
  debug_1091:
  rx1352_fail:
    (rx1352_rep, rx1352_pos, $I10, $P10) = rx1352_cur."!mark_fail"(0)
    lt rx1352_pos, -1, rx1352_done
    eq rx1352_pos, -1, rx1352_fail
    jump $I10
  rx1352_done:
    rx1352_cur."!cursor_fail"()
    if_null rx1352_debug, debug_1092
    rx1352_cur."!cursor_debug"("FAIL", "term:sym<name>")
  debug_1092:
    .return (rx1352_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<name>"  :subid("223_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1357 = self."!PREFIX__!subrule"("name", "")
    new $P1358, "ResizablePMCArray"
    push $P1358, $P1357
    .return ($P1358)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<pir::op>"  :subid("224_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1360_tgt
    .local int rx1360_pos
    .local int rx1360_off
    .local int rx1360_eos
    .local int rx1360_rep
    .local pmc rx1360_cur
    .local pmc rx1360_debug
    (rx1360_cur, rx1360_pos, rx1360_tgt, $I10) = self."!cursor_start"()
    rx1360_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1360_cur
    .local pmc match
    .lex "$/", match
    length rx1360_eos, rx1360_tgt
    gt rx1360_pos, rx1360_eos, rx1360_done
    set rx1360_off, 0
    lt rx1360_pos, 2, rx1360_start
    sub rx1360_off, rx1360_pos, 1
    substr rx1360_tgt, rx1360_tgt, rx1360_off
  rx1360_start:
    eq $I10, 1, rx1360_restart
    if_null rx1360_debug, debug_1093
    rx1360_cur."!cursor_debug"("START", "term:sym<pir::op>")
  debug_1093:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1361_done
    goto rxscan1361_scan
  rxscan1361_loop:
    (rx1360_pos) = rx1360_cur."from"()
    inc rx1360_pos
    rx1360_cur."!cursor_from"(rx1360_pos)
    ge rx1360_pos, rx1360_eos, rxscan1361_done
  rxscan1361_scan:
    set_addr $I10, rxscan1361_loop
    rx1360_cur."!mark_push"(0, rx1360_pos, $I10)
  rxscan1361_done:
.annotate 'line', 542
  # rx literal  "pir::"
    add $I11, rx1360_pos, 5
    gt $I11, rx1360_eos, rx1360_fail
    sub $I11, rx1360_pos, rx1360_off
    substr $S10, rx1360_tgt, $I11, 5
    ne $S10, "pir::", rx1360_fail
    add rx1360_pos, 5
  # rx subcapture "op"
    set_addr $I10, rxcap_1362_fail
    rx1360_cur."!mark_push"(0, rx1360_pos, $I10)
  # rx charclass_q w r 1..-1
    sub $I10, rx1360_pos, rx1360_off
    find_not_cclass $I11, 8192, rx1360_tgt, $I10, rx1360_eos
    add $I12, $I10, 1
    lt $I11, $I12, rx1360_fail
    add rx1360_pos, rx1360_off, $I11
    set_addr $I10, rxcap_1362_fail
    ($I12, $I11) = rx1360_cur."!mark_peek"($I10)
    rx1360_cur."!cursor_pos"($I11)
    ($P10) = rx1360_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1360_pos, "")
    rx1360_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("op")
    goto rxcap_1362_done
  rxcap_1362_fail:
    goto rx1360_fail
  rxcap_1362_done:
  # rx rxquantr1363 ** 0..1
    set_addr $I10, rxquantr1363_done
    rx1360_cur."!mark_push"(0, rx1360_pos, $I10)
  rxquantr1363_loop:
  # rx subrule "args" subtype=capture negate=
    rx1360_cur."!cursor_pos"(rx1360_pos)
    $P10 = rx1360_cur."args"()
    unless $P10, rx1360_fail
    goto rxsubrule1364_pass
  rxsubrule1364_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1360_fail
  rxsubrule1364_pass:
    set_addr $I10, rxsubrule1364_back
    rx1360_cur."!mark_push"(0, rx1360_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1360_pos = $P10."pos"()
    set_addr $I10, rxquantr1363_done
    (rx1360_rep) = rx1360_cur."!mark_commit"($I10)
  rxquantr1363_done:
.annotate 'line', 541
  # rx pass
    rx1360_cur."!cursor_pass"(rx1360_pos, "term:sym<pir::op>")
    if_null rx1360_debug, debug_1094
    rx1360_cur."!cursor_debug"("PASS", "term:sym<pir::op>", " at pos=", rx1360_pos)
  debug_1094:
    .return (rx1360_cur)
  rx1360_restart:
.annotate 'line', 10
    if_null rx1360_debug, debug_1095
    rx1360_cur."!cursor_debug"("NEXT", "term:sym<pir::op>")
  debug_1095:
  rx1360_fail:
    (rx1360_rep, rx1360_pos, $I10, $P10) = rx1360_cur."!mark_fail"(0)
    lt rx1360_pos, -1, rx1360_done
    eq rx1360_pos, -1, rx1360_fail
    jump $I10
  rx1360_done:
    rx1360_cur."!cursor_fail"()
    if_null rx1360_debug, debug_1096
    rx1360_cur."!cursor_debug"("FAIL", "term:sym<pir::op>")
  debug_1096:
    .return (rx1360_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<pir::op>"  :subid("225_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    new $P1366, "ResizablePMCArray"
    push $P1366, "pir::"
    .return ($P1366)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<onlystar>"  :subid("226_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .const 'Sub' $P1374 = "227_1304456155.152" 
    capture_lex $P1374
    .local string rx1368_tgt
    .local int rx1368_pos
    .local int rx1368_off
    .local int rx1368_eos
    .local int rx1368_rep
    .local pmc rx1368_cur
    .local pmc rx1368_debug
    (rx1368_cur, rx1368_pos, rx1368_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1368_cur
    .local pmc match
    .lex "$/", match
    length rx1368_eos, rx1368_tgt
    gt rx1368_pos, rx1368_eos, rx1368_done
    set rx1368_off, 0
    lt rx1368_pos, 2, rx1368_start
    sub rx1368_off, rx1368_pos, 1
    substr rx1368_tgt, rx1368_tgt, rx1368_off
  rx1368_start:
    eq $I10, 1, rx1368_restart
    if_null rx1368_debug, debug_1097
    rx1368_cur."!cursor_debug"("START", "term:sym<onlystar>")
  debug_1097:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1369_done
    goto rxscan1369_scan
  rxscan1369_loop:
    (rx1368_pos) = rx1368_cur."from"()
    inc rx1368_pos
    rx1368_cur."!cursor_from"(rx1368_pos)
    ge rx1368_pos, rx1368_eos, rxscan1369_done
  rxscan1369_scan:
    set_addr $I10, rxscan1369_loop
    rx1368_cur."!mark_push"(0, rx1368_pos, $I10)
  rxscan1369_done:
.annotate 'line', 546
  # rx literal  "{*}"
    add $I11, rx1368_pos, 3
    gt $I11, rx1368_eos, rx1368_fail
    sub $I11, rx1368_pos, rx1368_off
    substr $S10, rx1368_tgt, $I11, 3
    ne $S10, "{*}", rx1368_fail
    add rx1368_pos, 3
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1368_cur."!cursor_pos"(rx1368_pos)
    $P10 = rx1368_cur."ENDSTMT"()
    unless $P10, rx1368_fail
  alt1370_0:
.annotate 'line', 547
    set_addr $I10, alt1370_1
    rx1368_cur."!mark_push"(0, rx1368_pos, $I10)
    rx1368_cur."!cursor_pos"(rx1368_pos)
    find_lex $P1371, unicode:"$\x{a2}"
    $P1372 = $P1371."MATCH"()
    store_lex "$/", $P1372
    .const 'Sub' $P1374 = "227_1304456155.152" 
    capture_lex $P1374
    $P1380 = $P1374()
    unless $P1380, rx1368_fail
    goto alt1370_end
  alt1370_1:
  # rx subrule "panic" subtype=method negate=
    rx1368_cur."!cursor_pos"(rx1368_pos)
    $P10 = rx1368_cur."panic"("{*} may only appear in proto")
    unless $P10, rx1368_fail
    rx1368_pos = $P10."pos"()
  alt1370_end:
.annotate 'line', 545
  # rx pass
    rx1368_cur."!cursor_pass"(rx1368_pos, "term:sym<onlystar>")
    if_null rx1368_debug, debug_1100
    rx1368_cur."!cursor_debug"("PASS", "term:sym<onlystar>", " at pos=", rx1368_pos)
  debug_1100:
    .return (rx1368_cur)
  rx1368_restart:
.annotate 'line', 10
    if_null rx1368_debug, debug_1101
    rx1368_cur."!cursor_debug"("NEXT", "term:sym<onlystar>")
  debug_1101:
  rx1368_fail:
    (rx1368_rep, rx1368_pos, $I10, $P10) = rx1368_cur."!mark_fail"(0)
    lt rx1368_pos, -1, rx1368_done
    eq rx1368_pos, -1, rx1368_fail
    jump $I10
  rx1368_done:
    rx1368_cur."!cursor_fail"()
    if_null rx1368_debug, debug_1102
    rx1368_cur."!cursor_debug"("FAIL", "term:sym<onlystar>")
  debug_1102:
    .return (rx1368_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1373"  :anon :subid("227_1304456155.152") :outer("226_1304456155.152")
.annotate 'line', 547
    find_dynamic_lex $P1377, "$*MULTINESS"
    unless_null $P1377, vivify_1098
    get_hll_global $P1375, "GLOBAL"
    get_who $P1376, $P1375
    set $P1377, $P1376["$MULTINESS"]
    unless_null $P1377, vivify_1099
    die "Contextual $*MULTINESS not found"
  vivify_1099:
  vivify_1098:
    set $S1378, $P1377
    iseq $I1379, $S1378, "proto"
    .return ($I1379)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<onlystar>"  :subid("228_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    new $P1382, "ResizablePMCArray"
    push $P1382, "{*}"
    .return ($P1382)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "args"  :subid("229_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1384_tgt
    .local int rx1384_pos
    .local int rx1384_off
    .local int rx1384_eos
    .local int rx1384_rep
    .local pmc rx1384_cur
    .local pmc rx1384_debug
    (rx1384_cur, rx1384_pos, rx1384_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1384_cur
    .local pmc match
    .lex "$/", match
    length rx1384_eos, rx1384_tgt
    gt rx1384_pos, rx1384_eos, rx1384_done
    set rx1384_off, 0
    lt rx1384_pos, 2, rx1384_start
    sub rx1384_off, rx1384_pos, 1
    substr rx1384_tgt, rx1384_tgt, rx1384_off
  rx1384_start:
    eq $I10, 1, rx1384_restart
    if_null rx1384_debug, debug_1103
    rx1384_cur."!cursor_debug"("START", "args")
  debug_1103:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1385_done
    goto rxscan1385_scan
  rxscan1385_loop:
    (rx1384_pos) = rx1384_cur."from"()
    inc rx1384_pos
    rx1384_cur."!cursor_from"(rx1384_pos)
    ge rx1384_pos, rx1384_eos, rxscan1385_done
  rxscan1385_scan:
    set_addr $I10, rxscan1385_loop
    rx1384_cur."!mark_push"(0, rx1384_pos, $I10)
  rxscan1385_done:
.annotate 'line', 551
  # rx literal  "("
    add $I11, rx1384_pos, 1
    gt $I11, rx1384_eos, rx1384_fail
    sub $I11, rx1384_pos, rx1384_off
    ord $I11, rx1384_tgt, $I11
    ne $I11, 40, rx1384_fail
    add rx1384_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx1384_cur."!cursor_pos"(rx1384_pos)
    $P10 = rx1384_cur."arglist"()
    unless $P10, rx1384_fail
    rx1384_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1384_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1384_pos, 1
    gt $I11, rx1384_eos, rx1384_fail
    sub $I11, rx1384_pos, rx1384_off
    ord $I11, rx1384_tgt, $I11
    ne $I11, 41, rx1384_fail
    add rx1384_pos, 1
  # rx pass
    rx1384_cur."!cursor_pass"(rx1384_pos, "args")
    if_null rx1384_debug, debug_1104
    rx1384_cur."!cursor_debug"("PASS", "args", " at pos=", rx1384_pos)
  debug_1104:
    .return (rx1384_cur)
  rx1384_restart:
.annotate 'line', 10
    if_null rx1384_debug, debug_1105
    rx1384_cur."!cursor_debug"("NEXT", "args")
  debug_1105:
  rx1384_fail:
    (rx1384_rep, rx1384_pos, $I10, $P10) = rx1384_cur."!mark_fail"(0)
    lt rx1384_pos, -1, rx1384_done
    eq rx1384_pos, -1, rx1384_fail
    jump $I10
  rx1384_done:
    rx1384_cur."!cursor_fail"()
    if_null rx1384_debug, debug_1106
    rx1384_cur."!cursor_debug"("FAIL", "args")
  debug_1106:
    .return (rx1384_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__args"  :subid("230_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1387 = self."!PREFIX__!subrule"("arglist", "(")
    new $P1388, "ResizablePMCArray"
    push $P1388, $P1387
    .return ($P1388)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "arglist"  :subid("231_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1390_tgt
    .local int rx1390_pos
    .local int rx1390_off
    .local int rx1390_eos
    .local int rx1390_rep
    .local pmc rx1390_cur
    .local pmc rx1390_debug
    (rx1390_cur, rx1390_pos, rx1390_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1390_cur
    .local pmc match
    .lex "$/", match
    length rx1390_eos, rx1390_tgt
    gt rx1390_pos, rx1390_eos, rx1390_done
    set rx1390_off, 0
    lt rx1390_pos, 2, rx1390_start
    sub rx1390_off, rx1390_pos, 1
    substr rx1390_tgt, rx1390_tgt, rx1390_off
  rx1390_start:
    eq $I10, 1, rx1390_restart
    if_null rx1390_debug, debug_1107
    rx1390_cur."!cursor_debug"("START", "arglist")
  debug_1107:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1391_done
    goto rxscan1391_scan
  rxscan1391_loop:
    (rx1390_pos) = rx1390_cur."from"()
    inc rx1390_pos
    rx1390_cur."!cursor_from"(rx1390_pos)
    ge rx1390_pos, rx1390_eos, rxscan1391_done
  rxscan1391_scan:
    set_addr $I10, rxscan1391_loop
    rx1390_cur."!mark_push"(0, rx1390_pos, $I10)
  rxscan1391_done:
.annotate 'line', 555
  # rx subrule "ws" subtype=method negate=
    rx1390_cur."!cursor_pos"(rx1390_pos)
    $P10 = rx1390_cur."ws"()
    unless $P10, rx1390_fail
    rx1390_pos = $P10."pos"()
  alt1392_0:
.annotate 'line', 556
    set_addr $I10, alt1392_1
    rx1390_cur."!mark_push"(0, rx1390_pos, $I10)
.annotate 'line', 557
  # rx subrule "EXPR" subtype=capture negate=
    rx1390_cur."!cursor_pos"(rx1390_pos)
    $P10 = rx1390_cur."EXPR"("f=")
    unless $P10, rx1390_fail
    rx1390_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1390_pos = $P10."pos"()
    goto alt1392_end
  alt1392_1:
  alt1392_end:
.annotate 'line', 554
  # rx pass
    rx1390_cur."!cursor_pass"(rx1390_pos, "arglist")
    if_null rx1390_debug, debug_1108
    rx1390_cur."!cursor_debug"("PASS", "arglist", " at pos=", rx1390_pos)
  debug_1108:
    .return (rx1390_cur)
  rx1390_restart:
.annotate 'line', 10
    if_null rx1390_debug, debug_1109
    rx1390_cur."!cursor_debug"("NEXT", "arglist")
  debug_1109:
  rx1390_fail:
    (rx1390_rep, rx1390_pos, $I10, $P10) = rx1390_cur."!mark_fail"(0)
    lt rx1390_pos, -1, rx1390_done
    eq rx1390_pos, -1, rx1390_fail
    jump $I10
  rx1390_done:
    rx1390_cur."!cursor_fail"()
    if_null rx1390_debug, debug_1110
    rx1390_cur."!cursor_debug"("FAIL", "arglist")
  debug_1110:
    .return (rx1390_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__arglist"  :subid("232_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1394 = self."!PREFIX__!subrule"("ws", "")
    new $P1395, "ResizablePMCArray"
    push $P1395, $P1394
    .return ($P1395)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<value>"  :subid("233_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1397_tgt
    .local int rx1397_pos
    .local int rx1397_off
    .local int rx1397_eos
    .local int rx1397_rep
    .local pmc rx1397_cur
    .local pmc rx1397_debug
    (rx1397_cur, rx1397_pos, rx1397_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1397_cur
    .local pmc match
    .lex "$/", match
    length rx1397_eos, rx1397_tgt
    gt rx1397_pos, rx1397_eos, rx1397_done
    set rx1397_off, 0
    lt rx1397_pos, 2, rx1397_start
    sub rx1397_off, rx1397_pos, 1
    substr rx1397_tgt, rx1397_tgt, rx1397_off
  rx1397_start:
    eq $I10, 1, rx1397_restart
    if_null rx1397_debug, debug_1111
    rx1397_cur."!cursor_debug"("START", "term:sym<value>")
  debug_1111:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1398_done
    goto rxscan1398_scan
  rxscan1398_loop:
    (rx1397_pos) = rx1397_cur."from"()
    inc rx1397_pos
    rx1397_cur."!cursor_from"(rx1397_pos)
    ge rx1397_pos, rx1397_eos, rxscan1398_done
  rxscan1398_scan:
    set_addr $I10, rxscan1398_loop
    rx1397_cur."!mark_push"(0, rx1397_pos, $I10)
  rxscan1398_done:
.annotate 'line', 563
  # rx subrule "value" subtype=capture negate=
    rx1397_cur."!cursor_pos"(rx1397_pos)
    $P10 = rx1397_cur."value"()
    unless $P10, rx1397_fail
    rx1397_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("value")
    rx1397_pos = $P10."pos"()
  # rx pass
    rx1397_cur."!cursor_pass"(rx1397_pos, "term:sym<value>")
    if_null rx1397_debug, debug_1112
    rx1397_cur."!cursor_debug"("PASS", "term:sym<value>", " at pos=", rx1397_pos)
  debug_1112:
    .return (rx1397_cur)
  rx1397_restart:
.annotate 'line', 10
    if_null rx1397_debug, debug_1113
    rx1397_cur."!cursor_debug"("NEXT", "term:sym<value>")
  debug_1113:
  rx1397_fail:
    (rx1397_rep, rx1397_pos, $I10, $P10) = rx1397_cur."!mark_fail"(0)
    lt rx1397_pos, -1, rx1397_done
    eq rx1397_pos, -1, rx1397_fail
    jump $I10
  rx1397_done:
    rx1397_cur."!cursor_fail"()
    if_null rx1397_debug, debug_1114
    rx1397_cur."!cursor_debug"("FAIL", "term:sym<value>")
  debug_1114:
    .return (rx1397_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<value>"  :subid("234_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1400 = self."!PREFIX__!subrule"("value", "")
    new $P1401, "ResizablePMCArray"
    push $P1401, $P1400
    .return ($P1401)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "value"  :subid("235_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1403_tgt
    .local int rx1403_pos
    .local int rx1403_off
    .local int rx1403_eos
    .local int rx1403_rep
    .local pmc rx1403_cur
    .local pmc rx1403_debug
    (rx1403_cur, rx1403_pos, rx1403_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1403_cur
    .local pmc match
    .lex "$/", match
    length rx1403_eos, rx1403_tgt
    gt rx1403_pos, rx1403_eos, rx1403_done
    set rx1403_off, 0
    lt rx1403_pos, 2, rx1403_start
    sub rx1403_off, rx1403_pos, 1
    substr rx1403_tgt, rx1403_tgt, rx1403_off
  rx1403_start:
    eq $I10, 1, rx1403_restart
    if_null rx1403_debug, debug_1115
    rx1403_cur."!cursor_debug"("START", "value")
  debug_1115:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1404_done
    goto rxscan1404_scan
  rxscan1404_loop:
    (rx1403_pos) = rx1403_cur."from"()
    inc rx1403_pos
    rx1403_cur."!cursor_from"(rx1403_pos)
    ge rx1403_pos, rx1403_eos, rxscan1404_done
  rxscan1404_scan:
    set_addr $I10, rxscan1404_loop
    rx1403_cur."!mark_push"(0, rx1403_pos, $I10)
  rxscan1404_done:
  alt1405_0:
.annotate 'line', 565
    set_addr $I10, alt1405_1
    rx1403_cur."!mark_push"(0, rx1403_pos, $I10)
.annotate 'line', 566
  # rx subrule "quote" subtype=capture negate=
    rx1403_cur."!cursor_pos"(rx1403_pos)
    $P10 = rx1403_cur."quote"()
    unless $P10, rx1403_fail
    rx1403_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1403_pos = $P10."pos"()
    goto alt1405_end
  alt1405_1:
.annotate 'line', 567
  # rx subrule "number" subtype=capture negate=
    rx1403_cur."!cursor_pos"(rx1403_pos)
    $P10 = rx1403_cur."number"()
    unless $P10, rx1403_fail
    rx1403_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("number")
    rx1403_pos = $P10."pos"()
  alt1405_end:
.annotate 'line', 565
  # rx pass
    rx1403_cur."!cursor_pass"(rx1403_pos, "value")
    if_null rx1403_debug, debug_1116
    rx1403_cur."!cursor_debug"("PASS", "value", " at pos=", rx1403_pos)
  debug_1116:
    .return (rx1403_cur)
  rx1403_restart:
.annotate 'line', 10
    if_null rx1403_debug, debug_1117
    rx1403_cur."!cursor_debug"("NEXT", "value")
  debug_1117:
  rx1403_fail:
    (rx1403_rep, rx1403_pos, $I10, $P10) = rx1403_cur."!mark_fail"(0)
    lt rx1403_pos, -1, rx1403_done
    eq rx1403_pos, -1, rx1403_fail
    jump $I10
  rx1403_done:
    rx1403_cur."!cursor_fail"()
    if_null rx1403_debug, debug_1118
    rx1403_cur."!cursor_debug"("FAIL", "value")
  debug_1118:
    .return (rx1403_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__value"  :subid("236_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1407 = self."!PREFIX__!subrule"("number", "")
    $P1408 = self."!PREFIX__!subrule"("quote", "")
    new $P1409, "ResizablePMCArray"
    push $P1409, $P1407
    push $P1409, $P1408
    .return ($P1409)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "number"  :subid("237_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1411_tgt
    .local int rx1411_pos
    .local int rx1411_off
    .local int rx1411_eos
    .local int rx1411_rep
    .local pmc rx1411_cur
    .local pmc rx1411_debug
    (rx1411_cur, rx1411_pos, rx1411_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1411_cur
    .local pmc match
    .lex "$/", match
    length rx1411_eos, rx1411_tgt
    gt rx1411_pos, rx1411_eos, rx1411_done
    set rx1411_off, 0
    lt rx1411_pos, 2, rx1411_start
    sub rx1411_off, rx1411_pos, 1
    substr rx1411_tgt, rx1411_tgt, rx1411_off
  rx1411_start:
    eq $I10, 1, rx1411_restart
    if_null rx1411_debug, debug_1119
    rx1411_cur."!cursor_debug"("START", "number")
  debug_1119:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1412_done
    goto rxscan1412_scan
  rxscan1412_loop:
    (rx1411_pos) = rx1411_cur."from"()
    inc rx1411_pos
    rx1411_cur."!cursor_from"(rx1411_pos)
    ge rx1411_pos, rx1411_eos, rxscan1412_done
  rxscan1412_scan:
    set_addr $I10, rxscan1412_loop
    rx1411_cur."!mark_push"(0, rx1411_pos, $I10)
  rxscan1412_done:
.annotate 'line', 571
  # rx subcapture "sign"
    set_addr $I10, rxcap_1414_fail
    rx1411_cur."!mark_push"(0, rx1411_pos, $I10)
  # rx enumcharlist_q negate=0  r 0..1
    sub $I10, rx1411_pos, rx1411_off
    set rx1411_rep, 0
    sub $I12, rx1411_eos, rx1411_pos
    le $I12, 1, rxenumcharlistq1413_loop
    set $I12, 1
  rxenumcharlistq1413_loop:
    le $I12, 0, rxenumcharlistq1413_done
    substr $S10, rx1411_tgt, $I10, 1
    index $I11, "+-", $S10
    lt $I11, 0, rxenumcharlistq1413_done
    inc rx1411_rep
  rxenumcharlistq1413_done:
    add rx1411_pos, rx1411_pos, rx1411_rep
    set_addr $I10, rxcap_1414_fail
    ($I12, $I11) = rx1411_cur."!mark_peek"($I10)
    rx1411_cur."!cursor_pos"($I11)
    ($P10) = rx1411_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1411_pos, "")
    rx1411_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sign")
    goto rxcap_1414_done
  rxcap_1414_fail:
    goto rx1411_fail
  rxcap_1414_done:
  alt1415_0:
.annotate 'line', 572
    set_addr $I10, alt1415_1
    rx1411_cur."!mark_push"(0, rx1411_pos, $I10)
  # rx subrule "dec_number" subtype=capture negate=
    rx1411_cur."!cursor_pos"(rx1411_pos)
    $P10 = rx1411_cur."dec_number"()
    unless $P10, rx1411_fail
    rx1411_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dec_number")
    rx1411_pos = $P10."pos"()
    goto alt1415_end
  alt1415_1:
  # rx subrule "integer" subtype=capture negate=
    rx1411_cur."!cursor_pos"(rx1411_pos)
    $P10 = rx1411_cur."integer"()
    unless $P10, rx1411_fail
    rx1411_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("integer")
    rx1411_pos = $P10."pos"()
  alt1415_end:
.annotate 'line', 570
  # rx pass
    rx1411_cur."!cursor_pass"(rx1411_pos, "number")
    if_null rx1411_debug, debug_1120
    rx1411_cur."!cursor_debug"("PASS", "number", " at pos=", rx1411_pos)
  debug_1120:
    .return (rx1411_cur)
  rx1411_restart:
.annotate 'line', 10
    if_null rx1411_debug, debug_1121
    rx1411_cur."!cursor_debug"("NEXT", "number")
  debug_1121:
  rx1411_fail:
    (rx1411_rep, rx1411_pos, $I10, $P10) = rx1411_cur."!mark_fail"(0)
    lt rx1411_pos, -1, rx1411_done
    eq rx1411_pos, -1, rx1411_fail
    jump $I10
  rx1411_done:
    rx1411_cur."!cursor_fail"()
    if_null rx1411_debug, debug_1122
    rx1411_cur."!cursor_debug"("FAIL", "number")
  debug_1122:
    .return (rx1411_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__number"  :subid("238_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    new $P1417, "ResizablePMCArray"
    push $P1417, ""
    .return ($P1417)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote"  :subid("239_1304456155.152")
    .param pmc param_1419
.annotate 'line', 575
    .lex "self", param_1419
    $P1420 = param_1419."!protoregex"("quote")
    .return ($P1420)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote"  :subid("240_1304456155.152")
    .param pmc param_1422
.annotate 'line', 575
    .lex "self", param_1422
    $P1423 = param_1422."!PREFIX__!protoregex"("quote")
    .return ($P1423)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<apos>"  :subid("241_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1425_tgt
    .local int rx1425_pos
    .local int rx1425_off
    .local int rx1425_eos
    .local int rx1425_rep
    .local pmc rx1425_cur
    .local pmc rx1425_debug
    (rx1425_cur, rx1425_pos, rx1425_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1425_cur
    .local pmc match
    .lex "$/", match
    length rx1425_eos, rx1425_tgt
    gt rx1425_pos, rx1425_eos, rx1425_done
    set rx1425_off, 0
    lt rx1425_pos, 2, rx1425_start
    sub rx1425_off, rx1425_pos, 1
    substr rx1425_tgt, rx1425_tgt, rx1425_off
  rx1425_start:
    eq $I10, 1, rx1425_restart
    if_null rx1425_debug, debug_1123
    rx1425_cur."!cursor_debug"("START", "quote:sym<apos>")
  debug_1123:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1426_done
    goto rxscan1426_scan
  rxscan1426_loop:
    (rx1425_pos) = rx1425_cur."from"()
    inc rx1425_pos
    rx1425_cur."!cursor_from"(rx1425_pos)
    ge rx1425_pos, rx1425_eos, rxscan1426_done
  rxscan1426_scan:
    set_addr $I10, rxscan1426_loop
    rx1425_cur."!mark_push"(0, rx1425_pos, $I10)
  rxscan1426_done:
.annotate 'line', 576
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1425_pos, rx1425_off
    substr $S10, rx1425_tgt, $I10, 1
    index $I11, "'", $S10
    lt $I11, 0, rx1425_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1425_cur."!cursor_pos"(rx1425_pos)
    $P10 = rx1425_cur."quote_EXPR"(":q")
    unless $P10, rx1425_fail
    rx1425_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1425_pos = $P10."pos"()
  # rx pass
    rx1425_cur."!cursor_pass"(rx1425_pos, "quote:sym<apos>")
    if_null rx1425_debug, debug_1124
    rx1425_cur."!cursor_debug"("PASS", "quote:sym<apos>", " at pos=", rx1425_pos)
  debug_1124:
    .return (rx1425_cur)
  rx1425_restart:
.annotate 'line', 10
    if_null rx1425_debug, debug_1125
    rx1425_cur."!cursor_debug"("NEXT", "quote:sym<apos>")
  debug_1125:
  rx1425_fail:
    (rx1425_rep, rx1425_pos, $I10, $P10) = rx1425_cur."!mark_fail"(0)
    lt rx1425_pos, -1, rx1425_done
    eq rx1425_pos, -1, rx1425_fail
    jump $I10
  rx1425_done:
    rx1425_cur."!cursor_fail"()
    if_null rx1425_debug, debug_1126
    rx1425_cur."!cursor_debug"("FAIL", "quote:sym<apos>")
  debug_1126:
    .return (rx1425_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<apos>"  :subid("242_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    new $P1428, "ResizablePMCArray"
    push $P1428, "'"
    .return ($P1428)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<dblq>"  :subid("243_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1430_tgt
    .local int rx1430_pos
    .local int rx1430_off
    .local int rx1430_eos
    .local int rx1430_rep
    .local pmc rx1430_cur
    .local pmc rx1430_debug
    (rx1430_cur, rx1430_pos, rx1430_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1430_cur
    .local pmc match
    .lex "$/", match
    length rx1430_eos, rx1430_tgt
    gt rx1430_pos, rx1430_eos, rx1430_done
    set rx1430_off, 0
    lt rx1430_pos, 2, rx1430_start
    sub rx1430_off, rx1430_pos, 1
    substr rx1430_tgt, rx1430_tgt, rx1430_off
  rx1430_start:
    eq $I10, 1, rx1430_restart
    if_null rx1430_debug, debug_1127
    rx1430_cur."!cursor_debug"("START", "quote:sym<dblq>")
  debug_1127:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1431_done
    goto rxscan1431_scan
  rxscan1431_loop:
    (rx1430_pos) = rx1430_cur."from"()
    inc rx1430_pos
    rx1430_cur."!cursor_from"(rx1430_pos)
    ge rx1430_pos, rx1430_eos, rxscan1431_done
  rxscan1431_scan:
    set_addr $I10, rxscan1431_loop
    rx1430_cur."!mark_push"(0, rx1430_pos, $I10)
  rxscan1431_done:
.annotate 'line', 577
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1430_pos, rx1430_off
    substr $S10, rx1430_tgt, $I10, 1
    index $I11, "\"", $S10
    lt $I11, 0, rx1430_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1430_cur."!cursor_pos"(rx1430_pos)
    $P10 = rx1430_cur."quote_EXPR"(":qq")
    unless $P10, rx1430_fail
    rx1430_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1430_pos = $P10."pos"()
  # rx pass
    rx1430_cur."!cursor_pass"(rx1430_pos, "quote:sym<dblq>")
    if_null rx1430_debug, debug_1128
    rx1430_cur."!cursor_debug"("PASS", "quote:sym<dblq>", " at pos=", rx1430_pos)
  debug_1128:
    .return (rx1430_cur)
  rx1430_restart:
.annotate 'line', 10
    if_null rx1430_debug, debug_1129
    rx1430_cur."!cursor_debug"("NEXT", "quote:sym<dblq>")
  debug_1129:
  rx1430_fail:
    (rx1430_rep, rx1430_pos, $I10, $P10) = rx1430_cur."!mark_fail"(0)
    lt rx1430_pos, -1, rx1430_done
    eq rx1430_pos, -1, rx1430_fail
    jump $I10
  rx1430_done:
    rx1430_cur."!cursor_fail"()
    if_null rx1430_debug, debug_1130
    rx1430_cur."!cursor_debug"("FAIL", "quote:sym<dblq>")
  debug_1130:
    .return (rx1430_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<dblq>"  :subid("244_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    new $P1433, "ResizablePMCArray"
    push $P1433, "\""
    .return ($P1433)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<q>"  :subid("245_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1435_tgt
    .local int rx1435_pos
    .local int rx1435_off
    .local int rx1435_eos
    .local int rx1435_rep
    .local pmc rx1435_cur
    .local pmc rx1435_debug
    (rx1435_cur, rx1435_pos, rx1435_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1435_cur
    .local pmc match
    .lex "$/", match
    length rx1435_eos, rx1435_tgt
    gt rx1435_pos, rx1435_eos, rx1435_done
    set rx1435_off, 0
    lt rx1435_pos, 2, rx1435_start
    sub rx1435_off, rx1435_pos, 1
    substr rx1435_tgt, rx1435_tgt, rx1435_off
  rx1435_start:
    eq $I10, 1, rx1435_restart
    if_null rx1435_debug, debug_1131
    rx1435_cur."!cursor_debug"("START", "quote:sym<q>")
  debug_1131:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1436_done
    goto rxscan1436_scan
  rxscan1436_loop:
    (rx1435_pos) = rx1435_cur."from"()
    inc rx1435_pos
    rx1435_cur."!cursor_from"(rx1435_pos)
    ge rx1435_pos, rx1435_eos, rxscan1436_done
  rxscan1436_scan:
    set_addr $I10, rxscan1436_loop
    rx1435_cur."!mark_push"(0, rx1435_pos, $I10)
  rxscan1436_done:
.annotate 'line', 578
  # rx subcapture "sym"
    set_addr $I10, rxcap_1437_fail
    rx1435_cur."!mark_push"(0, rx1435_pos, $I10)
  # rx literal  "q"
    add $I11, rx1435_pos, 1
    gt $I11, rx1435_eos, rx1435_fail
    sub $I11, rx1435_pos, rx1435_off
    ord $I11, rx1435_tgt, $I11
    ne $I11, 113, rx1435_fail
    add rx1435_pos, 1
    set_addr $I10, rxcap_1437_fail
    ($I12, $I11) = rx1435_cur."!mark_peek"($I10)
    rx1435_cur."!cursor_pos"($I11)
    ($P10) = rx1435_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1435_pos, "")
    rx1435_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1437_done
  rxcap_1437_fail:
    goto rx1435_fail
  rxcap_1437_done:
  # rxanchor rwb
    le rx1435_pos, 0, rx1435_fail
    sub $I10, rx1435_pos, rx1435_off
    is_cclass $I11, 8192, rx1435_tgt, $I10
    if $I11, rx1435_fail
    dec $I10
    is_cclass $I11, 8192, rx1435_tgt, $I10
    unless $I11, rx1435_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1435_pos, rx1435_off
    substr $S10, rx1435_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1435_fail
  # rx subrule "ws" subtype=method negate=
    rx1435_cur."!cursor_pos"(rx1435_pos)
    $P10 = rx1435_cur."ws"()
    unless $P10, rx1435_fail
    rx1435_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1435_cur."!cursor_pos"(rx1435_pos)
    $P10 = rx1435_cur."quote_EXPR"(":q")
    unless $P10, rx1435_fail
    rx1435_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1435_pos = $P10."pos"()
  # rx pass
    rx1435_cur."!cursor_pass"(rx1435_pos, "quote:sym<q>")
    if_null rx1435_debug, debug_1132
    rx1435_cur."!cursor_debug"("PASS", "quote:sym<q>", " at pos=", rx1435_pos)
  debug_1132:
    .return (rx1435_cur)
  rx1435_restart:
.annotate 'line', 10
    if_null rx1435_debug, debug_1133
    rx1435_cur."!cursor_debug"("NEXT", "quote:sym<q>")
  debug_1133:
  rx1435_fail:
    (rx1435_rep, rx1435_pos, $I10, $P10) = rx1435_cur."!mark_fail"(0)
    lt rx1435_pos, -1, rx1435_done
    eq rx1435_pos, -1, rx1435_fail
    jump $I10
  rx1435_done:
    rx1435_cur."!cursor_fail"()
    if_null rx1435_debug, debug_1134
    rx1435_cur."!cursor_debug"("FAIL", "quote:sym<q>")
  debug_1134:
    .return (rx1435_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<q>"  :subid("246_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1439 = self."!PREFIX__!subrule"("ws", "q")
    new $P1440, "ResizablePMCArray"
    push $P1440, $P1439
    .return ($P1440)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<qq>"  :subid("247_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1442_tgt
    .local int rx1442_pos
    .local int rx1442_off
    .local int rx1442_eos
    .local int rx1442_rep
    .local pmc rx1442_cur
    .local pmc rx1442_debug
    (rx1442_cur, rx1442_pos, rx1442_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1442_cur
    .local pmc match
    .lex "$/", match
    length rx1442_eos, rx1442_tgt
    gt rx1442_pos, rx1442_eos, rx1442_done
    set rx1442_off, 0
    lt rx1442_pos, 2, rx1442_start
    sub rx1442_off, rx1442_pos, 1
    substr rx1442_tgt, rx1442_tgt, rx1442_off
  rx1442_start:
    eq $I10, 1, rx1442_restart
    if_null rx1442_debug, debug_1135
    rx1442_cur."!cursor_debug"("START", "quote:sym<qq>")
  debug_1135:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1443_done
    goto rxscan1443_scan
  rxscan1443_loop:
    (rx1442_pos) = rx1442_cur."from"()
    inc rx1442_pos
    rx1442_cur."!cursor_from"(rx1442_pos)
    ge rx1442_pos, rx1442_eos, rxscan1443_done
  rxscan1443_scan:
    set_addr $I10, rxscan1443_loop
    rx1442_cur."!mark_push"(0, rx1442_pos, $I10)
  rxscan1443_done:
.annotate 'line', 579
  # rx subcapture "sym"
    set_addr $I10, rxcap_1444_fail
    rx1442_cur."!mark_push"(0, rx1442_pos, $I10)
  # rx literal  "qq"
    add $I11, rx1442_pos, 2
    gt $I11, rx1442_eos, rx1442_fail
    sub $I11, rx1442_pos, rx1442_off
    substr $S10, rx1442_tgt, $I11, 2
    ne $S10, "qq", rx1442_fail
    add rx1442_pos, 2
    set_addr $I10, rxcap_1444_fail
    ($I12, $I11) = rx1442_cur."!mark_peek"($I10)
    rx1442_cur."!cursor_pos"($I11)
    ($P10) = rx1442_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1442_pos, "")
    rx1442_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1444_done
  rxcap_1444_fail:
    goto rx1442_fail
  rxcap_1444_done:
  # rxanchor rwb
    le rx1442_pos, 0, rx1442_fail
    sub $I10, rx1442_pos, rx1442_off
    is_cclass $I11, 8192, rx1442_tgt, $I10
    if $I11, rx1442_fail
    dec $I10
    is_cclass $I11, 8192, rx1442_tgt, $I10
    unless $I11, rx1442_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1442_pos, rx1442_off
    substr $S10, rx1442_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1442_fail
  # rx subrule "ws" subtype=method negate=
    rx1442_cur."!cursor_pos"(rx1442_pos)
    $P10 = rx1442_cur."ws"()
    unless $P10, rx1442_fail
    rx1442_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1442_cur."!cursor_pos"(rx1442_pos)
    $P10 = rx1442_cur."quote_EXPR"(":qq")
    unless $P10, rx1442_fail
    rx1442_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1442_pos = $P10."pos"()
  # rx pass
    rx1442_cur."!cursor_pass"(rx1442_pos, "quote:sym<qq>")
    if_null rx1442_debug, debug_1136
    rx1442_cur."!cursor_debug"("PASS", "quote:sym<qq>", " at pos=", rx1442_pos)
  debug_1136:
    .return (rx1442_cur)
  rx1442_restart:
.annotate 'line', 10
    if_null rx1442_debug, debug_1137
    rx1442_cur."!cursor_debug"("NEXT", "quote:sym<qq>")
  debug_1137:
  rx1442_fail:
    (rx1442_rep, rx1442_pos, $I10, $P10) = rx1442_cur."!mark_fail"(0)
    lt rx1442_pos, -1, rx1442_done
    eq rx1442_pos, -1, rx1442_fail
    jump $I10
  rx1442_done:
    rx1442_cur."!cursor_fail"()
    if_null rx1442_debug, debug_1138
    rx1442_cur."!cursor_debug"("FAIL", "quote:sym<qq>")
  debug_1138:
    .return (rx1442_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<qq>"  :subid("248_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1446 = self."!PREFIX__!subrule"("ws", "qq")
    new $P1447, "ResizablePMCArray"
    push $P1447, $P1446
    .return ($P1447)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q>"  :subid("249_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1449_tgt
    .local int rx1449_pos
    .local int rx1449_off
    .local int rx1449_eos
    .local int rx1449_rep
    .local pmc rx1449_cur
    .local pmc rx1449_debug
    (rx1449_cur, rx1449_pos, rx1449_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1449_cur
    .local pmc match
    .lex "$/", match
    length rx1449_eos, rx1449_tgt
    gt rx1449_pos, rx1449_eos, rx1449_done
    set rx1449_off, 0
    lt rx1449_pos, 2, rx1449_start
    sub rx1449_off, rx1449_pos, 1
    substr rx1449_tgt, rx1449_tgt, rx1449_off
  rx1449_start:
    eq $I10, 1, rx1449_restart
    if_null rx1449_debug, debug_1139
    rx1449_cur."!cursor_debug"("START", "quote:sym<Q>")
  debug_1139:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1450_done
    goto rxscan1450_scan
  rxscan1450_loop:
    (rx1449_pos) = rx1449_cur."from"()
    inc rx1449_pos
    rx1449_cur."!cursor_from"(rx1449_pos)
    ge rx1449_pos, rx1449_eos, rxscan1450_done
  rxscan1450_scan:
    set_addr $I10, rxscan1450_loop
    rx1449_cur."!mark_push"(0, rx1449_pos, $I10)
  rxscan1450_done:
.annotate 'line', 580
  # rx subcapture "sym"
    set_addr $I10, rxcap_1451_fail
    rx1449_cur."!mark_push"(0, rx1449_pos, $I10)
  # rx literal  "Q"
    add $I11, rx1449_pos, 1
    gt $I11, rx1449_eos, rx1449_fail
    sub $I11, rx1449_pos, rx1449_off
    ord $I11, rx1449_tgt, $I11
    ne $I11, 81, rx1449_fail
    add rx1449_pos, 1
    set_addr $I10, rxcap_1451_fail
    ($I12, $I11) = rx1449_cur."!mark_peek"($I10)
    rx1449_cur."!cursor_pos"($I11)
    ($P10) = rx1449_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1449_pos, "")
    rx1449_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1451_done
  rxcap_1451_fail:
    goto rx1449_fail
  rxcap_1451_done:
  # rxanchor rwb
    le rx1449_pos, 0, rx1449_fail
    sub $I10, rx1449_pos, rx1449_off
    is_cclass $I11, 8192, rx1449_tgt, $I10
    if $I11, rx1449_fail
    dec $I10
    is_cclass $I11, 8192, rx1449_tgt, $I10
    unless $I11, rx1449_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1449_pos, rx1449_off
    substr $S10, rx1449_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1449_fail
  # rx subrule "ws" subtype=method negate=
    rx1449_cur."!cursor_pos"(rx1449_pos)
    $P10 = rx1449_cur."ws"()
    unless $P10, rx1449_fail
    rx1449_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1449_cur."!cursor_pos"(rx1449_pos)
    $P10 = rx1449_cur."quote_EXPR"()
    unless $P10, rx1449_fail
    rx1449_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1449_pos = $P10."pos"()
  # rx pass
    rx1449_cur."!cursor_pass"(rx1449_pos, "quote:sym<Q>")
    if_null rx1449_debug, debug_1140
    rx1449_cur."!cursor_debug"("PASS", "quote:sym<Q>", " at pos=", rx1449_pos)
  debug_1140:
    .return (rx1449_cur)
  rx1449_restart:
.annotate 'line', 10
    if_null rx1449_debug, debug_1141
    rx1449_cur."!cursor_debug"("NEXT", "quote:sym<Q>")
  debug_1141:
  rx1449_fail:
    (rx1449_rep, rx1449_pos, $I10, $P10) = rx1449_cur."!mark_fail"(0)
    lt rx1449_pos, -1, rx1449_done
    eq rx1449_pos, -1, rx1449_fail
    jump $I10
  rx1449_done:
    rx1449_cur."!cursor_fail"()
    if_null rx1449_debug, debug_1142
    rx1449_cur."!cursor_debug"("FAIL", "quote:sym<Q>")
  debug_1142:
    .return (rx1449_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q>"  :subid("250_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1453 = self."!PREFIX__!subrule"("ws", "Q")
    new $P1454, "ResizablePMCArray"
    push $P1454, $P1453
    .return ($P1454)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q:PIR>"  :subid("251_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1456_tgt
    .local int rx1456_pos
    .local int rx1456_off
    .local int rx1456_eos
    .local int rx1456_rep
    .local pmc rx1456_cur
    .local pmc rx1456_debug
    (rx1456_cur, rx1456_pos, rx1456_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1456_cur
    .local pmc match
    .lex "$/", match
    length rx1456_eos, rx1456_tgt
    gt rx1456_pos, rx1456_eos, rx1456_done
    set rx1456_off, 0
    lt rx1456_pos, 2, rx1456_start
    sub rx1456_off, rx1456_pos, 1
    substr rx1456_tgt, rx1456_tgt, rx1456_off
  rx1456_start:
    eq $I10, 1, rx1456_restart
    if_null rx1456_debug, debug_1143
    rx1456_cur."!cursor_debug"("START", "quote:sym<Q:PIR>")
  debug_1143:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1457_done
    goto rxscan1457_scan
  rxscan1457_loop:
    (rx1456_pos) = rx1456_cur."from"()
    inc rx1456_pos
    rx1456_cur."!cursor_from"(rx1456_pos)
    ge rx1456_pos, rx1456_eos, rxscan1457_done
  rxscan1457_scan:
    set_addr $I10, rxscan1457_loop
    rx1456_cur."!mark_push"(0, rx1456_pos, $I10)
  rxscan1457_done:
.annotate 'line', 581
  # rx subcapture "sym"
    set_addr $I10, rxcap_1458_fail
    rx1456_cur."!mark_push"(0, rx1456_pos, $I10)
  # rx literal  "Q:PIR"
    add $I11, rx1456_pos, 5
    gt $I11, rx1456_eos, rx1456_fail
    sub $I11, rx1456_pos, rx1456_off
    substr $S10, rx1456_tgt, $I11, 5
    ne $S10, "Q:PIR", rx1456_fail
    add rx1456_pos, 5
    set_addr $I10, rxcap_1458_fail
    ($I12, $I11) = rx1456_cur."!mark_peek"($I10)
    rx1456_cur."!cursor_pos"($I11)
    ($P10) = rx1456_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1456_pos, "")
    rx1456_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1458_done
  rxcap_1458_fail:
    goto rx1456_fail
  rxcap_1458_done:
  # rx subrule "ws" subtype=method negate=
    rx1456_cur."!cursor_pos"(rx1456_pos)
    $P10 = rx1456_cur."ws"()
    unless $P10, rx1456_fail
    rx1456_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1456_cur."!cursor_pos"(rx1456_pos)
    $P10 = rx1456_cur."quote_EXPR"()
    unless $P10, rx1456_fail
    rx1456_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1456_pos = $P10."pos"()
  # rx pass
    rx1456_cur."!cursor_pass"(rx1456_pos, "quote:sym<Q:PIR>")
    if_null rx1456_debug, debug_1144
    rx1456_cur."!cursor_debug"("PASS", "quote:sym<Q:PIR>", " at pos=", rx1456_pos)
  debug_1144:
    .return (rx1456_cur)
  rx1456_restart:
.annotate 'line', 10
    if_null rx1456_debug, debug_1145
    rx1456_cur."!cursor_debug"("NEXT", "quote:sym<Q:PIR>")
  debug_1145:
  rx1456_fail:
    (rx1456_rep, rx1456_pos, $I10, $P10) = rx1456_cur."!mark_fail"(0)
    lt rx1456_pos, -1, rx1456_done
    eq rx1456_pos, -1, rx1456_fail
    jump $I10
  rx1456_done:
    rx1456_cur."!cursor_fail"()
    if_null rx1456_debug, debug_1146
    rx1456_cur."!cursor_debug"("FAIL", "quote:sym<Q:PIR>")
  debug_1146:
    .return (rx1456_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q:PIR>"  :subid("252_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1460 = self."!PREFIX__!subrule"("ws", "Q:PIR")
    new $P1461, "ResizablePMCArray"
    push $P1461, $P1460
    .return ($P1461)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym</ />"  :subid("253_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1463_tgt
    .local int rx1463_pos
    .local int rx1463_off
    .local int rx1463_eos
    .local int rx1463_rep
    .local pmc rx1463_cur
    .local pmc rx1463_debug
    (rx1463_cur, rx1463_pos, rx1463_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1463_cur
    .local pmc match
    .lex "$/", match
    length rx1463_eos, rx1463_tgt
    gt rx1463_pos, rx1463_eos, rx1463_done
    set rx1463_off, 0
    lt rx1463_pos, 2, rx1463_start
    sub rx1463_off, rx1463_pos, 1
    substr rx1463_tgt, rx1463_tgt, rx1463_off
  rx1463_start:
    eq $I10, 1, rx1463_restart
    if_null rx1463_debug, debug_1147
    rx1463_cur."!cursor_debug"("START", "quote:sym</ />")
  debug_1147:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1464_done
    goto rxscan1464_scan
  rxscan1464_loop:
    (rx1463_pos) = rx1463_cur."from"()
    inc rx1463_pos
    rx1463_cur."!cursor_from"(rx1463_pos)
    ge rx1463_pos, rx1463_eos, rxscan1464_done
  rxscan1464_scan:
    set_addr $I10, rxscan1464_loop
    rx1463_cur."!mark_push"(0, rx1463_pos, $I10)
  rxscan1464_done:
.annotate 'line', 583
  # rx literal  "/"
    add $I11, rx1463_pos, 1
    gt $I11, rx1463_eos, rx1463_fail
    sub $I11, rx1463_pos, rx1463_off
    ord $I11, rx1463_tgt, $I11
    ne $I11, 47, rx1463_fail
    add rx1463_pos, 1
.annotate 'line', 584
  # rx subrule "newpad" subtype=method negate=
    rx1463_cur."!cursor_pos"(rx1463_pos)
    $P10 = rx1463_cur."newpad"()
    unless $P10, rx1463_fail
    rx1463_pos = $P10."pos"()
.annotate 'line', 585
  # rx reduce name="quote:sym</ />" key="open"
    rx1463_cur."!cursor_pos"(rx1463_pos)
    rx1463_cur."!reduce"("quote:sym</ />", "open")
.annotate 'line', 586
  # rx subrule "LANG" subtype=capture negate=
    rx1463_cur."!cursor_pos"(rx1463_pos)
    $P10 = rx1463_cur."LANG"("Regex", "nibbler")
    unless $P10, rx1463_fail
    rx1463_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx1463_pos = $P10."pos"()
.annotate 'line', 587
  # rx literal  "/"
    add $I11, rx1463_pos, 1
    gt $I11, rx1463_eos, rx1463_fail
    sub $I11, rx1463_pos, rx1463_off
    ord $I11, rx1463_tgt, $I11
    ne $I11, 47, rx1463_fail
    add rx1463_pos, 1
.annotate 'line', 582
  # rx pass
    rx1463_cur."!cursor_pass"(rx1463_pos, "quote:sym</ />")
    if_null rx1463_debug, debug_1148
    rx1463_cur."!cursor_debug"("PASS", "quote:sym</ />", " at pos=", rx1463_pos)
  debug_1148:
    .return (rx1463_cur)
  rx1463_restart:
.annotate 'line', 10
    if_null rx1463_debug, debug_1149
    rx1463_cur."!cursor_debug"("NEXT", "quote:sym</ />")
  debug_1149:
  rx1463_fail:
    (rx1463_rep, rx1463_pos, $I10, $P10) = rx1463_cur."!mark_fail"(0)
    lt rx1463_pos, -1, rx1463_done
    eq rx1463_pos, -1, rx1463_fail
    jump $I10
  rx1463_done:
    rx1463_cur."!cursor_fail"()
    if_null rx1463_debug, debug_1150
    rx1463_cur."!cursor_debug"("FAIL", "quote:sym</ />")
  debug_1150:
    .return (rx1463_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym</ />"  :subid("254_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1466 = self."!PREFIX__!subrule"("newpad", "/")
    new $P1467, "ResizablePMCArray"
    push $P1467, $P1466
    .return ($P1467)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<$>"  :subid("255_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1469_tgt
    .local int rx1469_pos
    .local int rx1469_off
    .local int rx1469_eos
    .local int rx1469_rep
    .local pmc rx1469_cur
    .local pmc rx1469_debug
    (rx1469_cur, rx1469_pos, rx1469_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1469_cur
    .local pmc match
    .lex "$/", match
    length rx1469_eos, rx1469_tgt
    gt rx1469_pos, rx1469_eos, rx1469_done
    set rx1469_off, 0
    lt rx1469_pos, 2, rx1469_start
    sub rx1469_off, rx1469_pos, 1
    substr rx1469_tgt, rx1469_tgt, rx1469_off
  rx1469_start:
    eq $I10, 1, rx1469_restart
    if_null rx1469_debug, debug_1151
    rx1469_cur."!cursor_debug"("START", "quote_escape:sym<$>")
  debug_1151:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1470_done
    goto rxscan1470_scan
  rxscan1470_loop:
    (rx1469_pos) = rx1469_cur."from"()
    inc rx1469_pos
    rx1469_cur."!cursor_from"(rx1469_pos)
    ge rx1469_pos, rx1469_eos, rxscan1470_done
  rxscan1470_scan:
    set_addr $I10, rxscan1470_loop
    rx1469_cur."!mark_push"(0, rx1469_pos, $I10)
  rxscan1470_done:
.annotate 'line', 590
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1469_pos, rx1469_off
    substr $S10, rx1469_tgt, $I10, 1
    index $I11, "$", $S10
    lt $I11, 0, rx1469_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1469_cur."!cursor_pos"(rx1469_pos)
    $P10 = rx1469_cur."quotemod_check"("s")
    unless $P10, rx1469_fail
  # rx subrule "variable" subtype=capture negate=
    rx1469_cur."!cursor_pos"(rx1469_pos)
    $P10 = rx1469_cur."variable"()
    unless $P10, rx1469_fail
    rx1469_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx1469_pos = $P10."pos"()
  # rx pass
    rx1469_cur."!cursor_pass"(rx1469_pos, "quote_escape:sym<$>")
    if_null rx1469_debug, debug_1152
    rx1469_cur."!cursor_debug"("PASS", "quote_escape:sym<$>", " at pos=", rx1469_pos)
  debug_1152:
    .return (rx1469_cur)
  rx1469_restart:
.annotate 'line', 10
    if_null rx1469_debug, debug_1153
    rx1469_cur."!cursor_debug"("NEXT", "quote_escape:sym<$>")
  debug_1153:
  rx1469_fail:
    (rx1469_rep, rx1469_pos, $I10, $P10) = rx1469_cur."!mark_fail"(0)
    lt rx1469_pos, -1, rx1469_done
    eq rx1469_pos, -1, rx1469_fail
    jump $I10
  rx1469_done:
    rx1469_cur."!cursor_fail"()
    if_null rx1469_debug, debug_1154
    rx1469_cur."!cursor_debug"("FAIL", "quote_escape:sym<$>")
  debug_1154:
    .return (rx1469_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<$>"  :subid("256_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    new $P1472, "ResizablePMCArray"
    push $P1472, "$"
    .return ($P1472)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<{ }>"  :subid("257_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1474_tgt
    .local int rx1474_pos
    .local int rx1474_off
    .local int rx1474_eos
    .local int rx1474_rep
    .local pmc rx1474_cur
    .local pmc rx1474_debug
    (rx1474_cur, rx1474_pos, rx1474_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1474_cur
    .local pmc match
    .lex "$/", match
    length rx1474_eos, rx1474_tgt
    gt rx1474_pos, rx1474_eos, rx1474_done
    set rx1474_off, 0
    lt rx1474_pos, 2, rx1474_start
    sub rx1474_off, rx1474_pos, 1
    substr rx1474_tgt, rx1474_tgt, rx1474_off
  rx1474_start:
    eq $I10, 1, rx1474_restart
    if_null rx1474_debug, debug_1155
    rx1474_cur."!cursor_debug"("START", "quote_escape:sym<{ }>")
  debug_1155:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1475_done
    goto rxscan1475_scan
  rxscan1475_loop:
    (rx1474_pos) = rx1474_cur."from"()
    inc rx1474_pos
    rx1474_cur."!cursor_from"(rx1474_pos)
    ge rx1474_pos, rx1474_eos, rxscan1475_done
  rxscan1475_scan:
    set_addr $I10, rxscan1475_loop
    rx1474_cur."!mark_push"(0, rx1474_pos, $I10)
  rxscan1475_done:
.annotate 'line', 591
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1474_pos, rx1474_off
    substr $S10, rx1474_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1474_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1474_cur."!cursor_pos"(rx1474_pos)
    $P10 = rx1474_cur."quotemod_check"("c")
    unless $P10, rx1474_fail
  # rx subrule "block" subtype=capture negate=
    rx1474_cur."!cursor_pos"(rx1474_pos)
    $P10 = rx1474_cur."block"()
    unless $P10, rx1474_fail
    rx1474_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1474_pos = $P10."pos"()
  # rx pass
    rx1474_cur."!cursor_pass"(rx1474_pos, "quote_escape:sym<{ }>")
    if_null rx1474_debug, debug_1156
    rx1474_cur."!cursor_debug"("PASS", "quote_escape:sym<{ }>", " at pos=", rx1474_pos)
  debug_1156:
    .return (rx1474_cur)
  rx1474_restart:
.annotate 'line', 10
    if_null rx1474_debug, debug_1157
    rx1474_cur."!cursor_debug"("NEXT", "quote_escape:sym<{ }>")
  debug_1157:
  rx1474_fail:
    (rx1474_rep, rx1474_pos, $I10, $P10) = rx1474_cur."!mark_fail"(0)
    lt rx1474_pos, -1, rx1474_done
    eq rx1474_pos, -1, rx1474_fail
    jump $I10
  rx1474_done:
    rx1474_cur."!cursor_fail"()
    if_null rx1474_debug, debug_1158
    rx1474_cur."!cursor_debug"("FAIL", "quote_escape:sym<{ }>")
  debug_1158:
    .return (rx1474_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<{ }>"  :subid("258_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    new $P1477, "ResizablePMCArray"
    push $P1477, "{"
    .return ($P1477)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<esc>"  :subid("259_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1479_tgt
    .local int rx1479_pos
    .local int rx1479_off
    .local int rx1479_eos
    .local int rx1479_rep
    .local pmc rx1479_cur
    .local pmc rx1479_debug
    (rx1479_cur, rx1479_pos, rx1479_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1479_cur
    .local pmc match
    .lex "$/", match
    length rx1479_eos, rx1479_tgt
    gt rx1479_pos, rx1479_eos, rx1479_done
    set rx1479_off, 0
    lt rx1479_pos, 2, rx1479_start
    sub rx1479_off, rx1479_pos, 1
    substr rx1479_tgt, rx1479_tgt, rx1479_off
  rx1479_start:
    eq $I10, 1, rx1479_restart
    if_null rx1479_debug, debug_1159
    rx1479_cur."!cursor_debug"("START", "quote_escape:sym<esc>")
  debug_1159:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1480_done
    goto rxscan1480_scan
  rxscan1480_loop:
    (rx1479_pos) = rx1479_cur."from"()
    inc rx1479_pos
    rx1479_cur."!cursor_from"(rx1479_pos)
    ge rx1479_pos, rx1479_eos, rxscan1480_done
  rxscan1480_scan:
    set_addr $I10, rxscan1480_loop
    rx1479_cur."!mark_push"(0, rx1479_pos, $I10)
  rxscan1480_done:
.annotate 'line', 592
  # rx literal  "\\e"
    add $I11, rx1479_pos, 2
    gt $I11, rx1479_eos, rx1479_fail
    sub $I11, rx1479_pos, rx1479_off
    substr $S10, rx1479_tgt, $I11, 2
    ne $S10, "\\e", rx1479_fail
    add rx1479_pos, 2
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1479_cur."!cursor_pos"(rx1479_pos)
    $P10 = rx1479_cur."quotemod_check"("b")
    unless $P10, rx1479_fail
  # rx pass
    rx1479_cur."!cursor_pass"(rx1479_pos, "quote_escape:sym<esc>")
    if_null rx1479_debug, debug_1160
    rx1479_cur."!cursor_debug"("PASS", "quote_escape:sym<esc>", " at pos=", rx1479_pos)
  debug_1160:
    .return (rx1479_cur)
  rx1479_restart:
.annotate 'line', 10
    if_null rx1479_debug, debug_1161
    rx1479_cur."!cursor_debug"("NEXT", "quote_escape:sym<esc>")
  debug_1161:
  rx1479_fail:
    (rx1479_rep, rx1479_pos, $I10, $P10) = rx1479_cur."!mark_fail"(0)
    lt rx1479_pos, -1, rx1479_done
    eq rx1479_pos, -1, rx1479_fail
    jump $I10
  rx1479_done:
    rx1479_cur."!cursor_fail"()
    if_null rx1479_debug, debug_1162
    rx1479_cur."!cursor_debug"("FAIL", "quote_escape:sym<esc>")
  debug_1162:
    .return (rx1479_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<esc>"  :subid("260_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    new $P1482, "ResizablePMCArray"
    push $P1482, "\\e"
    .return ($P1482)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<( )>"  :subid("261_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1484_tgt
    .local int rx1484_pos
    .local int rx1484_off
    .local int rx1484_eos
    .local int rx1484_rep
    .local pmc rx1484_cur
    .local pmc rx1484_debug
    (rx1484_cur, rx1484_pos, rx1484_tgt, $I10) = self."!cursor_start"()
    rx1484_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx1484_cur
    .local pmc match
    .lex "$/", match
    length rx1484_eos, rx1484_tgt
    gt rx1484_pos, rx1484_eos, rx1484_done
    set rx1484_off, 0
    lt rx1484_pos, 2, rx1484_start
    sub rx1484_off, rx1484_pos, 1
    substr rx1484_tgt, rx1484_tgt, rx1484_off
  rx1484_start:
    eq $I10, 1, rx1484_restart
    if_null rx1484_debug, debug_1163
    rx1484_cur."!cursor_debug"("START", "circumfix:sym<( )>")
  debug_1163:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1485_done
    goto rxscan1485_scan
  rxscan1485_loop:
    (rx1484_pos) = rx1484_cur."from"()
    inc rx1484_pos
    rx1484_cur."!cursor_from"(rx1484_pos)
    ge rx1484_pos, rx1484_eos, rxscan1485_done
  rxscan1485_scan:
    set_addr $I10, rxscan1485_loop
    rx1484_cur."!mark_push"(0, rx1484_pos, $I10)
  rxscan1485_done:
.annotate 'line', 594
  # rx literal  "("
    add $I11, rx1484_pos, 1
    gt $I11, rx1484_eos, rx1484_fail
    sub $I11, rx1484_pos, rx1484_off
    ord $I11, rx1484_tgt, $I11
    ne $I11, 40, rx1484_fail
    add rx1484_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1484_cur."!cursor_pos"(rx1484_pos)
    $P10 = rx1484_cur."ws"()
    unless $P10, rx1484_fail
    rx1484_pos = $P10."pos"()
  # rx rxquantr1486 ** 0..1
    set_addr $I10, rxquantr1486_done
    rx1484_cur."!mark_push"(0, rx1484_pos, $I10)
  rxquantr1486_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx1484_cur."!cursor_pos"(rx1484_pos)
    $P10 = rx1484_cur."EXPR"()
    unless $P10, rx1484_fail
    goto rxsubrule1487_pass
  rxsubrule1487_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1484_fail
  rxsubrule1487_pass:
    set_addr $I10, rxsubrule1487_back
    rx1484_cur."!mark_push"(0, rx1484_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx1484_pos = $P10."pos"()
    set_addr $I10, rxquantr1486_done
    (rx1484_rep) = rx1484_cur."!mark_commit"($I10)
  rxquantr1486_done:
  # rx literal  ")"
    add $I11, rx1484_pos, 1
    gt $I11, rx1484_eos, rx1484_fail
    sub $I11, rx1484_pos, rx1484_off
    ord $I11, rx1484_tgt, $I11
    ne $I11, 41, rx1484_fail
    add rx1484_pos, 1
  # rx pass
    rx1484_cur."!cursor_pass"(rx1484_pos, "circumfix:sym<( )>")
    if_null rx1484_debug, debug_1164
    rx1484_cur."!cursor_debug"("PASS", "circumfix:sym<( )>", " at pos=", rx1484_pos)
  debug_1164:
    .return (rx1484_cur)
  rx1484_restart:
.annotate 'line', 10
    if_null rx1484_debug, debug_1165
    rx1484_cur."!cursor_debug"("NEXT", "circumfix:sym<( )>")
  debug_1165:
  rx1484_fail:
    (rx1484_rep, rx1484_pos, $I10, $P10) = rx1484_cur."!mark_fail"(0)
    lt rx1484_pos, -1, rx1484_done
    eq rx1484_pos, -1, rx1484_fail
    jump $I10
  rx1484_done:
    rx1484_cur."!cursor_fail"()
    if_null rx1484_debug, debug_1166
    rx1484_cur."!cursor_debug"("FAIL", "circumfix:sym<( )>")
  debug_1166:
    .return (rx1484_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<( )>"  :subid("262_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1489 = self."!PREFIX__!subrule"("ws", "(")
    new $P1490, "ResizablePMCArray"
    push $P1490, $P1489
    .return ($P1490)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<[ ]>"  :subid("263_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1492_tgt
    .local int rx1492_pos
    .local int rx1492_off
    .local int rx1492_eos
    .local int rx1492_rep
    .local pmc rx1492_cur
    .local pmc rx1492_debug
    (rx1492_cur, rx1492_pos, rx1492_tgt, $I10) = self."!cursor_start"()
    rx1492_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx1492_cur
    .local pmc match
    .lex "$/", match
    length rx1492_eos, rx1492_tgt
    gt rx1492_pos, rx1492_eos, rx1492_done
    set rx1492_off, 0
    lt rx1492_pos, 2, rx1492_start
    sub rx1492_off, rx1492_pos, 1
    substr rx1492_tgt, rx1492_tgt, rx1492_off
  rx1492_start:
    eq $I10, 1, rx1492_restart
    if_null rx1492_debug, debug_1167
    rx1492_cur."!cursor_debug"("START", "circumfix:sym<[ ]>")
  debug_1167:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1493_done
    goto rxscan1493_scan
  rxscan1493_loop:
    (rx1492_pos) = rx1492_cur."from"()
    inc rx1492_pos
    rx1492_cur."!cursor_from"(rx1492_pos)
    ge rx1492_pos, rx1492_eos, rxscan1493_done
  rxscan1493_scan:
    set_addr $I10, rxscan1493_loop
    rx1492_cur."!mark_push"(0, rx1492_pos, $I10)
  rxscan1493_done:
.annotate 'line', 595
  # rx literal  "["
    add $I11, rx1492_pos, 1
    gt $I11, rx1492_eos, rx1492_fail
    sub $I11, rx1492_pos, rx1492_off
    ord $I11, rx1492_tgt, $I11
    ne $I11, 91, rx1492_fail
    add rx1492_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1492_cur."!cursor_pos"(rx1492_pos)
    $P10 = rx1492_cur."ws"()
    unless $P10, rx1492_fail
    rx1492_pos = $P10."pos"()
  # rx rxquantr1494 ** 0..1
    set_addr $I10, rxquantr1494_done
    rx1492_cur."!mark_push"(0, rx1492_pos, $I10)
  rxquantr1494_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx1492_cur."!cursor_pos"(rx1492_pos)
    $P10 = rx1492_cur."EXPR"()
    unless $P10, rx1492_fail
    goto rxsubrule1495_pass
  rxsubrule1495_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1492_fail
  rxsubrule1495_pass:
    set_addr $I10, rxsubrule1495_back
    rx1492_cur."!mark_push"(0, rx1492_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx1492_pos = $P10."pos"()
    set_addr $I10, rxquantr1494_done
    (rx1492_rep) = rx1492_cur."!mark_commit"($I10)
  rxquantr1494_done:
  # rx literal  "]"
    add $I11, rx1492_pos, 1
    gt $I11, rx1492_eos, rx1492_fail
    sub $I11, rx1492_pos, rx1492_off
    ord $I11, rx1492_tgt, $I11
    ne $I11, 93, rx1492_fail
    add rx1492_pos, 1
  # rx pass
    rx1492_cur."!cursor_pass"(rx1492_pos, "circumfix:sym<[ ]>")
    if_null rx1492_debug, debug_1168
    rx1492_cur."!cursor_debug"("PASS", "circumfix:sym<[ ]>", " at pos=", rx1492_pos)
  debug_1168:
    .return (rx1492_cur)
  rx1492_restart:
.annotate 'line', 10
    if_null rx1492_debug, debug_1169
    rx1492_cur."!cursor_debug"("NEXT", "circumfix:sym<[ ]>")
  debug_1169:
  rx1492_fail:
    (rx1492_rep, rx1492_pos, $I10, $P10) = rx1492_cur."!mark_fail"(0)
    lt rx1492_pos, -1, rx1492_done
    eq rx1492_pos, -1, rx1492_fail
    jump $I10
  rx1492_done:
    rx1492_cur."!cursor_fail"()
    if_null rx1492_debug, debug_1170
    rx1492_cur."!cursor_debug"("FAIL", "circumfix:sym<[ ]>")
  debug_1170:
    .return (rx1492_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<[ ]>"  :subid("264_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1497 = self."!PREFIX__!subrule"("ws", "[")
    new $P1498, "ResizablePMCArray"
    push $P1498, $P1497
    .return ($P1498)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<ang>"  :subid("265_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1500_tgt
    .local int rx1500_pos
    .local int rx1500_off
    .local int rx1500_eos
    .local int rx1500_rep
    .local pmc rx1500_cur
    .local pmc rx1500_debug
    (rx1500_cur, rx1500_pos, rx1500_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1500_cur
    .local pmc match
    .lex "$/", match
    length rx1500_eos, rx1500_tgt
    gt rx1500_pos, rx1500_eos, rx1500_done
    set rx1500_off, 0
    lt rx1500_pos, 2, rx1500_start
    sub rx1500_off, rx1500_pos, 1
    substr rx1500_tgt, rx1500_tgt, rx1500_off
  rx1500_start:
    eq $I10, 1, rx1500_restart
    if_null rx1500_debug, debug_1171
    rx1500_cur."!cursor_debug"("START", "circumfix:sym<ang>")
  debug_1171:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1501_done
    goto rxscan1501_scan
  rxscan1501_loop:
    (rx1500_pos) = rx1500_cur."from"()
    inc rx1500_pos
    rx1500_cur."!cursor_from"(rx1500_pos)
    ge rx1500_pos, rx1500_eos, rxscan1501_done
  rxscan1501_scan:
    set_addr $I10, rxscan1501_loop
    rx1500_cur."!mark_push"(0, rx1500_pos, $I10)
  rxscan1501_done:
.annotate 'line', 596
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1500_pos, rx1500_off
    substr $S10, rx1500_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx1500_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1500_cur."!cursor_pos"(rx1500_pos)
    $P10 = rx1500_cur."quote_EXPR"(":q", ":w")
    unless $P10, rx1500_fail
    rx1500_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1500_pos = $P10."pos"()
  # rx pass
    rx1500_cur."!cursor_pass"(rx1500_pos, "circumfix:sym<ang>")
    if_null rx1500_debug, debug_1172
    rx1500_cur."!cursor_debug"("PASS", "circumfix:sym<ang>", " at pos=", rx1500_pos)
  debug_1172:
    .return (rx1500_cur)
  rx1500_restart:
.annotate 'line', 10
    if_null rx1500_debug, debug_1173
    rx1500_cur."!cursor_debug"("NEXT", "circumfix:sym<ang>")
  debug_1173:
  rx1500_fail:
    (rx1500_rep, rx1500_pos, $I10, $P10) = rx1500_cur."!mark_fail"(0)
    lt rx1500_pos, -1, rx1500_done
    eq rx1500_pos, -1, rx1500_fail
    jump $I10
  rx1500_done:
    rx1500_cur."!cursor_fail"()
    if_null rx1500_debug, debug_1174
    rx1500_cur."!cursor_debug"("FAIL", "circumfix:sym<ang>")
  debug_1174:
    .return (rx1500_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<ang>"  :subid("266_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    new $P1503, "ResizablePMCArray"
    push $P1503, "<"
    .return ($P1503)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("267_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1505_tgt
    .local int rx1505_pos
    .local int rx1505_off
    .local int rx1505_eos
    .local int rx1505_rep
    .local pmc rx1505_cur
    .local pmc rx1505_debug
    (rx1505_cur, rx1505_pos, rx1505_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1505_cur
    .local pmc match
    .lex "$/", match
    length rx1505_eos, rx1505_tgt
    gt rx1505_pos, rx1505_eos, rx1505_done
    set rx1505_off, 0
    lt rx1505_pos, 2, rx1505_start
    sub rx1505_off, rx1505_pos, 1
    substr rx1505_tgt, rx1505_tgt, rx1505_off
  rx1505_start:
    eq $I10, 1, rx1505_restart
    if_null rx1505_debug, debug_1175
    rx1505_cur."!cursor_debug"("START", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1175:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1506_done
    goto rxscan1506_scan
  rxscan1506_loop:
    (rx1505_pos) = rx1505_cur."from"()
    inc rx1505_pos
    rx1505_cur."!cursor_from"(rx1505_pos)
    ge rx1505_pos, rx1505_eos, rxscan1506_done
  rxscan1506_scan:
    set_addr $I10, rxscan1506_loop
    rx1505_cur."!mark_push"(0, rx1505_pos, $I10)
  rxscan1506_done:
.annotate 'line', 597
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1505_pos, rx1505_off
    substr $S10, rx1505_tgt, $I10, 1
    index $I11, unicode:"\x{ab}", $S10
    lt $I11, 0, rx1505_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1505_cur."!cursor_pos"(rx1505_pos)
    $P10 = rx1505_cur."quote_EXPR"(":qq", ":w")
    unless $P10, rx1505_fail
    rx1505_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1505_pos = $P10."pos"()
  # rx pass
    rx1505_cur."!cursor_pass"(rx1505_pos, unicode:"circumfix:sym<\x{ab} \x{bb}>")
    if_null rx1505_debug, debug_1176
    rx1505_cur."!cursor_debug"("PASS", unicode:"circumfix:sym<\x{ab} \x{bb}>", " at pos=", rx1505_pos)
  debug_1176:
    .return (rx1505_cur)
  rx1505_restart:
.annotate 'line', 10
    if_null rx1505_debug, debug_1177
    rx1505_cur."!cursor_debug"("NEXT", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1177:
  rx1505_fail:
    (rx1505_rep, rx1505_pos, $I10, $P10) = rx1505_cur."!mark_fail"(0)
    lt rx1505_pos, -1, rx1505_done
    eq rx1505_pos, -1, rx1505_fail
    jump $I10
  rx1505_done:
    rx1505_cur."!cursor_fail"()
    if_null rx1505_debug, debug_1178
    rx1505_cur."!cursor_debug"("FAIL", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1178:
    .return (rx1505_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"  :subid("268_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    new $P1508, "ResizablePMCArray"
    push $P1508, unicode:"\x{ab}"
    .return ($P1508)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<{ }>"  :subid("269_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1510_tgt
    .local int rx1510_pos
    .local int rx1510_off
    .local int rx1510_eos
    .local int rx1510_rep
    .local pmc rx1510_cur
    .local pmc rx1510_debug
    (rx1510_cur, rx1510_pos, rx1510_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1510_cur
    .local pmc match
    .lex "$/", match
    length rx1510_eos, rx1510_tgt
    gt rx1510_pos, rx1510_eos, rx1510_done
    set rx1510_off, 0
    lt rx1510_pos, 2, rx1510_start
    sub rx1510_off, rx1510_pos, 1
    substr rx1510_tgt, rx1510_tgt, rx1510_off
  rx1510_start:
    eq $I10, 1, rx1510_restart
    if_null rx1510_debug, debug_1179
    rx1510_cur."!cursor_debug"("START", "circumfix:sym<{ }>")
  debug_1179:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1511_done
    goto rxscan1511_scan
  rxscan1511_loop:
    (rx1510_pos) = rx1510_cur."from"()
    inc rx1510_pos
    rx1510_cur."!cursor_from"(rx1510_pos)
    ge rx1510_pos, rx1510_eos, rxscan1511_done
  rxscan1511_scan:
    set_addr $I10, rxscan1511_loop
    rx1510_cur."!mark_push"(0, rx1510_pos, $I10)
  rxscan1511_done:
.annotate 'line', 598
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1510_pos, rx1510_off
    substr $S10, rx1510_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1510_fail
  # rx subrule "pblock" subtype=capture negate=
    rx1510_cur."!cursor_pos"(rx1510_pos)
    $P10 = rx1510_cur."pblock"()
    unless $P10, rx1510_fail
    rx1510_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx1510_pos = $P10."pos"()
  # rx pass
    rx1510_cur."!cursor_pass"(rx1510_pos, "circumfix:sym<{ }>")
    if_null rx1510_debug, debug_1180
    rx1510_cur."!cursor_debug"("PASS", "circumfix:sym<{ }>", " at pos=", rx1510_pos)
  debug_1180:
    .return (rx1510_cur)
  rx1510_restart:
.annotate 'line', 10
    if_null rx1510_debug, debug_1181
    rx1510_cur."!cursor_debug"("NEXT", "circumfix:sym<{ }>")
  debug_1181:
  rx1510_fail:
    (rx1510_rep, rx1510_pos, $I10, $P10) = rx1510_cur."!mark_fail"(0)
    lt rx1510_pos, -1, rx1510_done
    eq rx1510_pos, -1, rx1510_fail
    jump $I10
  rx1510_done:
    rx1510_cur."!cursor_fail"()
    if_null rx1510_debug, debug_1182
    rx1510_cur."!cursor_debug"("FAIL", "circumfix:sym<{ }>")
  debug_1182:
    .return (rx1510_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<{ }>"  :subid("270_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    new $P1513, "ResizablePMCArray"
    push $P1513, "{"
    .return ($P1513)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<sigil>"  :subid("271_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1515_tgt
    .local int rx1515_pos
    .local int rx1515_off
    .local int rx1515_eos
    .local int rx1515_rep
    .local pmc rx1515_cur
    .local pmc rx1515_debug
    (rx1515_cur, rx1515_pos, rx1515_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1515_cur
    .local pmc match
    .lex "$/", match
    length rx1515_eos, rx1515_tgt
    gt rx1515_pos, rx1515_eos, rx1515_done
    set rx1515_off, 0
    lt rx1515_pos, 2, rx1515_start
    sub rx1515_off, rx1515_pos, 1
    substr rx1515_tgt, rx1515_tgt, rx1515_off
  rx1515_start:
    eq $I10, 1, rx1515_restart
    if_null rx1515_debug, debug_1183
    rx1515_cur."!cursor_debug"("START", "circumfix:sym<sigil>")
  debug_1183:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1516_done
    goto rxscan1516_scan
  rxscan1516_loop:
    (rx1515_pos) = rx1515_cur."from"()
    inc rx1515_pos
    rx1515_cur."!cursor_from"(rx1515_pos)
    ge rx1515_pos, rx1515_eos, rxscan1516_done
  rxscan1516_scan:
    set_addr $I10, rxscan1516_loop
    rx1515_cur."!mark_push"(0, rx1515_pos, $I10)
  rxscan1516_done:
.annotate 'line', 599
  # rx subrule "sigil" subtype=capture negate=
    rx1515_cur."!cursor_pos"(rx1515_pos)
    $P10 = rx1515_cur."sigil"()
    unless $P10, rx1515_fail
    rx1515_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1515_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1515_pos, 1
    gt $I11, rx1515_eos, rx1515_fail
    sub $I11, rx1515_pos, rx1515_off
    ord $I11, rx1515_tgt, $I11
    ne $I11, 40, rx1515_fail
    add rx1515_pos, 1
  # rx subrule "semilist" subtype=capture negate=
    rx1515_cur."!cursor_pos"(rx1515_pos)
    $P10 = rx1515_cur."semilist"()
    unless $P10, rx1515_fail
    rx1515_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("semilist")
    rx1515_pos = $P10."pos"()
  alt1517_0:
    set_addr $I10, alt1517_1
    rx1515_cur."!mark_push"(0, rx1515_pos, $I10)
  # rx literal  ")"
    add $I11, rx1515_pos, 1
    gt $I11, rx1515_eos, rx1515_fail
    sub $I11, rx1515_pos, rx1515_off
    ord $I11, rx1515_tgt, $I11
    ne $I11, 41, rx1515_fail
    add rx1515_pos, 1
    goto alt1517_end
  alt1517_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx1515_cur."!cursor_pos"(rx1515_pos)
    $P10 = rx1515_cur."FAILGOAL"("')'")
    unless $P10, rx1515_fail
    goto rxsubrule1519_pass
  rxsubrule1519_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1515_fail
  rxsubrule1519_pass:
    set_addr $I10, rxsubrule1519_back
    rx1515_cur."!mark_push"(0, rx1515_pos, $I10, $P10)
    rx1515_pos = $P10."pos"()
  alt1517_end:
  # rx pass
    rx1515_cur."!cursor_pass"(rx1515_pos, "circumfix:sym<sigil>")
    if_null rx1515_debug, debug_1184
    rx1515_cur."!cursor_debug"("PASS", "circumfix:sym<sigil>", " at pos=", rx1515_pos)
  debug_1184:
    .return (rx1515_cur)
  rx1515_restart:
.annotate 'line', 10
    if_null rx1515_debug, debug_1185
    rx1515_cur."!cursor_debug"("NEXT", "circumfix:sym<sigil>")
  debug_1185:
  rx1515_fail:
    (rx1515_rep, rx1515_pos, $I10, $P10) = rx1515_cur."!mark_fail"(0)
    lt rx1515_pos, -1, rx1515_done
    eq rx1515_pos, -1, rx1515_fail
    jump $I10
  rx1515_done:
    rx1515_cur."!cursor_fail"()
    if_null rx1515_debug, debug_1186
    rx1515_cur."!cursor_debug"("FAIL", "circumfix:sym<sigil>")
  debug_1186:
    .return (rx1515_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<sigil>"  :subid("272_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1521 = self."!PREFIX__!subrule"("sigil", "")
    new $P1522, "ResizablePMCArray"
    push $P1522, $P1521
    .return ($P1522)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "semilist"  :subid("273_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1524_tgt
    .local int rx1524_pos
    .local int rx1524_off
    .local int rx1524_eos
    .local int rx1524_rep
    .local pmc rx1524_cur
    .local pmc rx1524_debug
    (rx1524_cur, rx1524_pos, rx1524_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1524_cur
    .local pmc match
    .lex "$/", match
    length rx1524_eos, rx1524_tgt
    gt rx1524_pos, rx1524_eos, rx1524_done
    set rx1524_off, 0
    lt rx1524_pos, 2, rx1524_start
    sub rx1524_off, rx1524_pos, 1
    substr rx1524_tgt, rx1524_tgt, rx1524_off
  rx1524_start:
    eq $I10, 1, rx1524_restart
    if_null rx1524_debug, debug_1187
    rx1524_cur."!cursor_debug"("START", "semilist")
  debug_1187:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1525_done
    goto rxscan1525_scan
  rxscan1525_loop:
    (rx1524_pos) = rx1524_cur."from"()
    inc rx1524_pos
    rx1524_cur."!cursor_from"(rx1524_pos)
    ge rx1524_pos, rx1524_eos, rxscan1525_done
  rxscan1525_scan:
    set_addr $I10, rxscan1525_loop
    rx1524_cur."!mark_push"(0, rx1524_pos, $I10)
  rxscan1525_done:
.annotate 'line', 601
  # rx subrule "ws" subtype=method negate=
    rx1524_cur."!cursor_pos"(rx1524_pos)
    $P10 = rx1524_cur."ws"()
    unless $P10, rx1524_fail
    rx1524_pos = $P10."pos"()
  # rx subrule "statement" subtype=capture negate=
    rx1524_cur."!cursor_pos"(rx1524_pos)
    $P10 = rx1524_cur."statement"()
    unless $P10, rx1524_fail
    rx1524_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx1524_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1524_cur."!cursor_pos"(rx1524_pos)
    $P10 = rx1524_cur."ws"()
    unless $P10, rx1524_fail
    rx1524_pos = $P10."pos"()
  # rx pass
    rx1524_cur."!cursor_pass"(rx1524_pos, "semilist")
    if_null rx1524_debug, debug_1188
    rx1524_cur."!cursor_debug"("PASS", "semilist", " at pos=", rx1524_pos)
  debug_1188:
    .return (rx1524_cur)
  rx1524_restart:
.annotate 'line', 10
    if_null rx1524_debug, debug_1189
    rx1524_cur."!cursor_debug"("NEXT", "semilist")
  debug_1189:
  rx1524_fail:
    (rx1524_rep, rx1524_pos, $I10, $P10) = rx1524_cur."!mark_fail"(0)
    lt rx1524_pos, -1, rx1524_done
    eq rx1524_pos, -1, rx1524_fail
    jump $I10
  rx1524_done:
    rx1524_cur."!cursor_fail"()
    if_null rx1524_debug, debug_1190
    rx1524_cur."!cursor_debug"("FAIL", "semilist")
  debug_1190:
    .return (rx1524_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__semilist"  :subid("274_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1529 = self."!PREFIX__!subrule"("ws", "")
    new $P1530, "ResizablePMCArray"
    push $P1530, $P1529
    .return ($P1530)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixish"  :subid("275_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1532_tgt
    .local int rx1532_pos
    .local int rx1532_off
    .local int rx1532_eos
    .local int rx1532_rep
    .local pmc rx1532_cur
    .local pmc rx1532_debug
    (rx1532_cur, rx1532_pos, rx1532_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1532_cur
    .local pmc match
    .lex "$/", match
    length rx1532_eos, rx1532_tgt
    gt rx1532_pos, rx1532_eos, rx1532_done
    set rx1532_off, 0
    lt rx1532_pos, 2, rx1532_start
    sub rx1532_off, rx1532_pos, 1
    substr rx1532_tgt, rx1532_tgt, rx1532_off
  rx1532_start:
    eq $I10, 1, rx1532_restart
    if_null rx1532_debug, debug_1191
    rx1532_cur."!cursor_debug"("START", "infixish")
  debug_1191:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1533_done
    goto rxscan1533_scan
  rxscan1533_loop:
    (rx1532_pos) = rx1532_cur."from"()
    inc rx1532_pos
    rx1532_cur."!cursor_from"(rx1532_pos)
    ge rx1532_pos, rx1532_eos, rxscan1533_done
  rxscan1533_scan:
    set_addr $I10, rxscan1533_loop
    rx1532_cur."!mark_push"(0, rx1532_pos, $I10)
  rxscan1533_done:
.annotate 'line', 624
  # rx subrule "infixstopper" subtype=zerowidth negate=1
    rx1532_cur."!cursor_pos"(rx1532_pos)
    $P10 = rx1532_cur."infixstopper"()
    if $P10, rx1532_fail
  # rx subrule "infix" subtype=capture negate=
    rx1532_cur."!cursor_pos"(rx1532_pos)
    $P10 = rx1532_cur."infix"()
    unless $P10, rx1532_fail
    rx1532_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("OPER=infix")
    rx1532_pos = $P10."pos"()
  # rx pass
    rx1532_cur."!cursor_pass"(rx1532_pos, "infixish")
    if_null rx1532_debug, debug_1192
    rx1532_cur."!cursor_debug"("PASS", "infixish", " at pos=", rx1532_pos)
  debug_1192:
    .return (rx1532_cur)
  rx1532_restart:
.annotate 'line', 10
    if_null rx1532_debug, debug_1193
    rx1532_cur."!cursor_debug"("NEXT", "infixish")
  debug_1193:
  rx1532_fail:
    (rx1532_rep, rx1532_pos, $I10, $P10) = rx1532_cur."!mark_fail"(0)
    lt rx1532_pos, -1, rx1532_done
    eq rx1532_pos, -1, rx1532_fail
    jump $I10
  rx1532_done:
    rx1532_cur."!cursor_fail"()
    if_null rx1532_debug, debug_1194
    rx1532_cur."!cursor_debug"("FAIL", "infixish")
  debug_1194:
    .return (rx1532_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixish"  :subid("276_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    new $P1535, "ResizablePMCArray"
    push $P1535, ""
    .return ($P1535)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixstopper"  :subid("277_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1537_tgt
    .local int rx1537_pos
    .local int rx1537_off
    .local int rx1537_eos
    .local int rx1537_rep
    .local pmc rx1537_cur
    .local pmc rx1537_debug
    (rx1537_cur, rx1537_pos, rx1537_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1537_cur
    .local pmc match
    .lex "$/", match
    length rx1537_eos, rx1537_tgt
    gt rx1537_pos, rx1537_eos, rx1537_done
    set rx1537_off, 0
    lt rx1537_pos, 2, rx1537_start
    sub rx1537_off, rx1537_pos, 1
    substr rx1537_tgt, rx1537_tgt, rx1537_off
  rx1537_start:
    eq $I10, 1, rx1537_restart
    if_null rx1537_debug, debug_1195
    rx1537_cur."!cursor_debug"("START", "infixstopper")
  debug_1195:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1538_done
    goto rxscan1538_scan
  rxscan1538_loop:
    (rx1537_pos) = rx1537_cur."from"()
    inc rx1537_pos
    rx1537_cur."!cursor_from"(rx1537_pos)
    ge rx1537_pos, rx1537_eos, rxscan1538_done
  rxscan1538_scan:
    set_addr $I10, rxscan1538_loop
    rx1537_cur."!mark_push"(0, rx1537_pos, $I10)
  rxscan1538_done:
.annotate 'line', 625
  # rx subrule "lambda" subtype=zerowidth negate=
    rx1537_cur."!cursor_pos"(rx1537_pos)
    $P10 = rx1537_cur."lambda"()
    unless $P10, rx1537_fail
  # rx pass
    rx1537_cur."!cursor_pass"(rx1537_pos, "infixstopper")
    if_null rx1537_debug, debug_1196
    rx1537_cur."!cursor_debug"("PASS", "infixstopper", " at pos=", rx1537_pos)
  debug_1196:
    .return (rx1537_cur)
  rx1537_restart:
.annotate 'line', 10
    if_null rx1537_debug, debug_1197
    rx1537_cur."!cursor_debug"("NEXT", "infixstopper")
  debug_1197:
  rx1537_fail:
    (rx1537_rep, rx1537_pos, $I10, $P10) = rx1537_cur."!mark_fail"(0)
    lt rx1537_pos, -1, rx1537_done
    eq rx1537_pos, -1, rx1537_fail
    jump $I10
  rx1537_done:
    rx1537_cur."!cursor_fail"()
    if_null rx1537_debug, debug_1198
    rx1537_cur."!cursor_debug"("FAIL", "infixstopper")
  debug_1198:
    .return (rx1537_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixstopper"  :subid("278_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    new $P1540, "ResizablePMCArray"
    push $P1540, ""
    .return ($P1540)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<[ ]>"  :subid("279_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1542_tgt
    .local int rx1542_pos
    .local int rx1542_off
    .local int rx1542_eos
    .local int rx1542_rep
    .local pmc rx1542_cur
    .local pmc rx1542_debug
    (rx1542_cur, rx1542_pos, rx1542_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1542_cur
    .local pmc match
    .lex "$/", match
    length rx1542_eos, rx1542_tgt
    gt rx1542_pos, rx1542_eos, rx1542_done
    set rx1542_off, 0
    lt rx1542_pos, 2, rx1542_start
    sub rx1542_off, rx1542_pos, 1
    substr rx1542_tgt, rx1542_tgt, rx1542_off
  rx1542_start:
    eq $I10, 1, rx1542_restart
    if_null rx1542_debug, debug_1199
    rx1542_cur."!cursor_debug"("START", "postcircumfix:sym<[ ]>")
  debug_1199:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1543_done
    goto rxscan1543_scan
  rxscan1543_loop:
    (rx1542_pos) = rx1542_cur."from"()
    inc rx1542_pos
    rx1542_cur."!cursor_from"(rx1542_pos)
    ge rx1542_pos, rx1542_eos, rxscan1543_done
  rxscan1543_scan:
    set_addr $I10, rxscan1543_loop
    rx1542_cur."!mark_push"(0, rx1542_pos, $I10)
  rxscan1543_done:
.annotate 'line', 628
  # rx literal  "["
    add $I11, rx1542_pos, 1
    gt $I11, rx1542_eos, rx1542_fail
    sub $I11, rx1542_pos, rx1542_off
    ord $I11, rx1542_tgt, $I11
    ne $I11, 91, rx1542_fail
    add rx1542_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1542_cur."!cursor_pos"(rx1542_pos)
    $P10 = rx1542_cur."ws"()
    unless $P10, rx1542_fail
    rx1542_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1542_cur."!cursor_pos"(rx1542_pos)
    $P10 = rx1542_cur."EXPR"()
    unless $P10, rx1542_fail
    rx1542_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1542_pos = $P10."pos"()
  # rx literal  "]"
    add $I11, rx1542_pos, 1
    gt $I11, rx1542_eos, rx1542_fail
    sub $I11, rx1542_pos, rx1542_off
    ord $I11, rx1542_tgt, $I11
    ne $I11, 93, rx1542_fail
    add rx1542_pos, 1
.annotate 'line', 629
  # rx subrule "O" subtype=capture negate=
    rx1542_cur."!cursor_pos"(rx1542_pos)
    $P10 = rx1542_cur."O"("%methodop")
    unless $P10, rx1542_fail
    rx1542_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1542_pos = $P10."pos"()
.annotate 'line', 627
  # rx pass
    rx1542_cur."!cursor_pass"(rx1542_pos, "postcircumfix:sym<[ ]>")
    if_null rx1542_debug, debug_1200
    rx1542_cur."!cursor_debug"("PASS", "postcircumfix:sym<[ ]>", " at pos=", rx1542_pos)
  debug_1200:
    .return (rx1542_cur)
  rx1542_restart:
.annotate 'line', 10
    if_null rx1542_debug, debug_1201
    rx1542_cur."!cursor_debug"("NEXT", "postcircumfix:sym<[ ]>")
  debug_1201:
  rx1542_fail:
    (rx1542_rep, rx1542_pos, $I10, $P10) = rx1542_cur."!mark_fail"(0)
    lt rx1542_pos, -1, rx1542_done
    eq rx1542_pos, -1, rx1542_fail
    jump $I10
  rx1542_done:
    rx1542_cur."!cursor_fail"()
    if_null rx1542_debug, debug_1202
    rx1542_cur."!cursor_debug"("FAIL", "postcircumfix:sym<[ ]>")
  debug_1202:
    .return (rx1542_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<[ ]>"  :subid("280_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1545 = self."!PREFIX__!subrule"("ws", "[")
    new $P1546, "ResizablePMCArray"
    push $P1546, $P1545
    .return ($P1546)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<{ }>"  :subid("281_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1548_tgt
    .local int rx1548_pos
    .local int rx1548_off
    .local int rx1548_eos
    .local int rx1548_rep
    .local pmc rx1548_cur
    .local pmc rx1548_debug
    (rx1548_cur, rx1548_pos, rx1548_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1548_cur
    .local pmc match
    .lex "$/", match
    length rx1548_eos, rx1548_tgt
    gt rx1548_pos, rx1548_eos, rx1548_done
    set rx1548_off, 0
    lt rx1548_pos, 2, rx1548_start
    sub rx1548_off, rx1548_pos, 1
    substr rx1548_tgt, rx1548_tgt, rx1548_off
  rx1548_start:
    eq $I10, 1, rx1548_restart
    if_null rx1548_debug, debug_1203
    rx1548_cur."!cursor_debug"("START", "postcircumfix:sym<{ }>")
  debug_1203:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1549_done
    goto rxscan1549_scan
  rxscan1549_loop:
    (rx1548_pos) = rx1548_cur."from"()
    inc rx1548_pos
    rx1548_cur."!cursor_from"(rx1548_pos)
    ge rx1548_pos, rx1548_eos, rxscan1549_done
  rxscan1549_scan:
    set_addr $I10, rxscan1549_loop
    rx1548_cur."!mark_push"(0, rx1548_pos, $I10)
  rxscan1549_done:
.annotate 'line', 633
  # rx literal  "{"
    add $I11, rx1548_pos, 1
    gt $I11, rx1548_eos, rx1548_fail
    sub $I11, rx1548_pos, rx1548_off
    ord $I11, rx1548_tgt, $I11
    ne $I11, 123, rx1548_fail
    add rx1548_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1548_cur."!cursor_pos"(rx1548_pos)
    $P10 = rx1548_cur."ws"()
    unless $P10, rx1548_fail
    rx1548_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1548_cur."!cursor_pos"(rx1548_pos)
    $P10 = rx1548_cur."EXPR"()
    unless $P10, rx1548_fail
    rx1548_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1548_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1548_pos, 1
    gt $I11, rx1548_eos, rx1548_fail
    sub $I11, rx1548_pos, rx1548_off
    ord $I11, rx1548_tgt, $I11
    ne $I11, 125, rx1548_fail
    add rx1548_pos, 1
.annotate 'line', 634
  # rx subrule "O" subtype=capture negate=
    rx1548_cur."!cursor_pos"(rx1548_pos)
    $P10 = rx1548_cur."O"("%methodop")
    unless $P10, rx1548_fail
    rx1548_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1548_pos = $P10."pos"()
.annotate 'line', 632
  # rx pass
    rx1548_cur."!cursor_pass"(rx1548_pos, "postcircumfix:sym<{ }>")
    if_null rx1548_debug, debug_1204
    rx1548_cur."!cursor_debug"("PASS", "postcircumfix:sym<{ }>", " at pos=", rx1548_pos)
  debug_1204:
    .return (rx1548_cur)
  rx1548_restart:
.annotate 'line', 10
    if_null rx1548_debug, debug_1205
    rx1548_cur."!cursor_debug"("NEXT", "postcircumfix:sym<{ }>")
  debug_1205:
  rx1548_fail:
    (rx1548_rep, rx1548_pos, $I10, $P10) = rx1548_cur."!mark_fail"(0)
    lt rx1548_pos, -1, rx1548_done
    eq rx1548_pos, -1, rx1548_fail
    jump $I10
  rx1548_done:
    rx1548_cur."!cursor_fail"()
    if_null rx1548_debug, debug_1206
    rx1548_cur."!cursor_debug"("FAIL", "postcircumfix:sym<{ }>")
  debug_1206:
    .return (rx1548_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<{ }>"  :subid("282_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1551 = self."!PREFIX__!subrule"("ws", "{")
    new $P1552, "ResizablePMCArray"
    push $P1552, $P1551
    .return ($P1552)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<ang>"  :subid("283_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1554_tgt
    .local int rx1554_pos
    .local int rx1554_off
    .local int rx1554_eos
    .local int rx1554_rep
    .local pmc rx1554_cur
    .local pmc rx1554_debug
    (rx1554_cur, rx1554_pos, rx1554_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1554_cur
    .local pmc match
    .lex "$/", match
    length rx1554_eos, rx1554_tgt
    gt rx1554_pos, rx1554_eos, rx1554_done
    set rx1554_off, 0
    lt rx1554_pos, 2, rx1554_start
    sub rx1554_off, rx1554_pos, 1
    substr rx1554_tgt, rx1554_tgt, rx1554_off
  rx1554_start:
    eq $I10, 1, rx1554_restart
    if_null rx1554_debug, debug_1207
    rx1554_cur."!cursor_debug"("START", "postcircumfix:sym<ang>")
  debug_1207:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1555_done
    goto rxscan1555_scan
  rxscan1555_loop:
    (rx1554_pos) = rx1554_cur."from"()
    inc rx1554_pos
    rx1554_cur."!cursor_from"(rx1554_pos)
    ge rx1554_pos, rx1554_eos, rxscan1555_done
  rxscan1555_scan:
    set_addr $I10, rxscan1555_loop
    rx1554_cur."!mark_push"(0, rx1554_pos, $I10)
  rxscan1555_done:
.annotate 'line', 638
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1554_pos, rx1554_off
    substr $S10, rx1554_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx1554_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1554_cur."!cursor_pos"(rx1554_pos)
    $P10 = rx1554_cur."quote_EXPR"(":q")
    unless $P10, rx1554_fail
    rx1554_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1554_pos = $P10."pos"()
.annotate 'line', 639
  # rx subrule "O" subtype=capture negate=
    rx1554_cur."!cursor_pos"(rx1554_pos)
    $P10 = rx1554_cur."O"("%methodop")
    unless $P10, rx1554_fail
    rx1554_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1554_pos = $P10."pos"()
.annotate 'line', 637
  # rx pass
    rx1554_cur."!cursor_pass"(rx1554_pos, "postcircumfix:sym<ang>")
    if_null rx1554_debug, debug_1208
    rx1554_cur."!cursor_debug"("PASS", "postcircumfix:sym<ang>", " at pos=", rx1554_pos)
  debug_1208:
    .return (rx1554_cur)
  rx1554_restart:
.annotate 'line', 10
    if_null rx1554_debug, debug_1209
    rx1554_cur."!cursor_debug"("NEXT", "postcircumfix:sym<ang>")
  debug_1209:
  rx1554_fail:
    (rx1554_rep, rx1554_pos, $I10, $P10) = rx1554_cur."!mark_fail"(0)
    lt rx1554_pos, -1, rx1554_done
    eq rx1554_pos, -1, rx1554_fail
    jump $I10
  rx1554_done:
    rx1554_cur."!cursor_fail"()
    if_null rx1554_debug, debug_1210
    rx1554_cur."!cursor_debug"("FAIL", "postcircumfix:sym<ang>")
  debug_1210:
    .return (rx1554_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<ang>"  :subid("284_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    new $P1557, "ResizablePMCArray"
    push $P1557, "<"
    .return ($P1557)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<( )>"  :subid("285_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1559_tgt
    .local int rx1559_pos
    .local int rx1559_off
    .local int rx1559_eos
    .local int rx1559_rep
    .local pmc rx1559_cur
    .local pmc rx1559_debug
    (rx1559_cur, rx1559_pos, rx1559_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1559_cur
    .local pmc match
    .lex "$/", match
    length rx1559_eos, rx1559_tgt
    gt rx1559_pos, rx1559_eos, rx1559_done
    set rx1559_off, 0
    lt rx1559_pos, 2, rx1559_start
    sub rx1559_off, rx1559_pos, 1
    substr rx1559_tgt, rx1559_tgt, rx1559_off
  rx1559_start:
    eq $I10, 1, rx1559_restart
    if_null rx1559_debug, debug_1211
    rx1559_cur."!cursor_debug"("START", "postcircumfix:sym<( )>")
  debug_1211:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1560_done
    goto rxscan1560_scan
  rxscan1560_loop:
    (rx1559_pos) = rx1559_cur."from"()
    inc rx1559_pos
    rx1559_cur."!cursor_from"(rx1559_pos)
    ge rx1559_pos, rx1559_eos, rxscan1560_done
  rxscan1560_scan:
    set_addr $I10, rxscan1560_loop
    rx1559_cur."!mark_push"(0, rx1559_pos, $I10)
  rxscan1560_done:
.annotate 'line', 643
  # rx literal  "("
    add $I11, rx1559_pos, 1
    gt $I11, rx1559_eos, rx1559_fail
    sub $I11, rx1559_pos, rx1559_off
    ord $I11, rx1559_tgt, $I11
    ne $I11, 40, rx1559_fail
    add rx1559_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1559_cur."!cursor_pos"(rx1559_pos)
    $P10 = rx1559_cur."ws"()
    unless $P10, rx1559_fail
    rx1559_pos = $P10."pos"()
  # rx subrule "arglist" subtype=capture negate=
    rx1559_cur."!cursor_pos"(rx1559_pos)
    $P10 = rx1559_cur."arglist"()
    unless $P10, rx1559_fail
    rx1559_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1559_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1559_pos, 1
    gt $I11, rx1559_eos, rx1559_fail
    sub $I11, rx1559_pos, rx1559_off
    ord $I11, rx1559_tgt, $I11
    ne $I11, 41, rx1559_fail
    add rx1559_pos, 1
.annotate 'line', 644
  # rx subrule "O" subtype=capture negate=
    rx1559_cur."!cursor_pos"(rx1559_pos)
    $P10 = rx1559_cur."O"("%methodop")
    unless $P10, rx1559_fail
    rx1559_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1559_pos = $P10."pos"()
.annotate 'line', 642
  # rx pass
    rx1559_cur."!cursor_pass"(rx1559_pos, "postcircumfix:sym<( )>")
    if_null rx1559_debug, debug_1212
    rx1559_cur."!cursor_debug"("PASS", "postcircumfix:sym<( )>", " at pos=", rx1559_pos)
  debug_1212:
    .return (rx1559_cur)
  rx1559_restart:
.annotate 'line', 10
    if_null rx1559_debug, debug_1213
    rx1559_cur."!cursor_debug"("NEXT", "postcircumfix:sym<( )>")
  debug_1213:
  rx1559_fail:
    (rx1559_rep, rx1559_pos, $I10, $P10) = rx1559_cur."!mark_fail"(0)
    lt rx1559_pos, -1, rx1559_done
    eq rx1559_pos, -1, rx1559_fail
    jump $I10
  rx1559_done:
    rx1559_cur."!cursor_fail"()
    if_null rx1559_debug, debug_1214
    rx1559_cur."!cursor_debug"("FAIL", "postcircumfix:sym<( )>")
  debug_1214:
    .return (rx1559_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<( )>"  :subid("286_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1562 = self."!PREFIX__!subrule"("ws", "(")
    new $P1563, "ResizablePMCArray"
    push $P1563, $P1562
    .return ($P1563)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<.>"  :subid("287_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1565_tgt
    .local int rx1565_pos
    .local int rx1565_off
    .local int rx1565_eos
    .local int rx1565_rep
    .local pmc rx1565_cur
    .local pmc rx1565_debug
    (rx1565_cur, rx1565_pos, rx1565_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1565_cur
    .local pmc match
    .lex "$/", match
    length rx1565_eos, rx1565_tgt
    gt rx1565_pos, rx1565_eos, rx1565_done
    set rx1565_off, 0
    lt rx1565_pos, 2, rx1565_start
    sub rx1565_off, rx1565_pos, 1
    substr rx1565_tgt, rx1565_tgt, rx1565_off
  rx1565_start:
    eq $I10, 1, rx1565_restart
    if_null rx1565_debug, debug_1215
    rx1565_cur."!cursor_debug"("START", "postfix:sym<.>")
  debug_1215:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1566_done
    goto rxscan1566_scan
  rxscan1566_loop:
    (rx1565_pos) = rx1565_cur."from"()
    inc rx1565_pos
    rx1565_cur."!cursor_from"(rx1565_pos)
    ge rx1565_pos, rx1565_eos, rxscan1566_done
  rxscan1566_scan:
    set_addr $I10, rxscan1566_loop
    rx1565_cur."!mark_push"(0, rx1565_pos, $I10)
  rxscan1566_done:
.annotate 'line', 647
  # rx subrule "dotty" subtype=capture negate=
    rx1565_cur."!cursor_pos"(rx1565_pos)
    $P10 = rx1565_cur."dotty"()
    unless $P10, rx1565_fail
    rx1565_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dotty")
    rx1565_pos = $P10."pos"()
  # rx subrule "O" subtype=capture negate=
    rx1565_cur."!cursor_pos"(rx1565_pos)
    $P10 = rx1565_cur."O"("%methodop")
    unless $P10, rx1565_fail
    rx1565_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1565_pos = $P10."pos"()
  # rx pass
    rx1565_cur."!cursor_pass"(rx1565_pos, "postfix:sym<.>")
    if_null rx1565_debug, debug_1216
    rx1565_cur."!cursor_debug"("PASS", "postfix:sym<.>", " at pos=", rx1565_pos)
  debug_1216:
    .return (rx1565_cur)
  rx1565_restart:
.annotate 'line', 10
    if_null rx1565_debug, debug_1217
    rx1565_cur."!cursor_debug"("NEXT", "postfix:sym<.>")
  debug_1217:
  rx1565_fail:
    (rx1565_rep, rx1565_pos, $I10, $P10) = rx1565_cur."!mark_fail"(0)
    lt rx1565_pos, -1, rx1565_done
    eq rx1565_pos, -1, rx1565_fail
    jump $I10
  rx1565_done:
    rx1565_cur."!cursor_fail"()
    if_null rx1565_debug, debug_1218
    rx1565_cur."!cursor_debug"("FAIL", "postfix:sym<.>")
  debug_1218:
    .return (rx1565_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<.>"  :subid("288_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1568 = self."!PREFIX__!subrule"("dotty", "")
    new $P1569, "ResizablePMCArray"
    push $P1569, $P1568
    .return ($P1569)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<++>"  :subid("289_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1571_tgt
    .local int rx1571_pos
    .local int rx1571_off
    .local int rx1571_eos
    .local int rx1571_rep
    .local pmc rx1571_cur
    .local pmc rx1571_debug
    (rx1571_cur, rx1571_pos, rx1571_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1571_cur
    .local pmc match
    .lex "$/", match
    length rx1571_eos, rx1571_tgt
    gt rx1571_pos, rx1571_eos, rx1571_done
    set rx1571_off, 0
    lt rx1571_pos, 2, rx1571_start
    sub rx1571_off, rx1571_pos, 1
    substr rx1571_tgt, rx1571_tgt, rx1571_off
  rx1571_start:
    eq $I10, 1, rx1571_restart
    if_null rx1571_debug, debug_1219
    rx1571_cur."!cursor_debug"("START", "prefix:sym<++>")
  debug_1219:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1572_done
    goto rxscan1572_scan
  rxscan1572_loop:
    (rx1571_pos) = rx1571_cur."from"()
    inc rx1571_pos
    rx1571_cur."!cursor_from"(rx1571_pos)
    ge rx1571_pos, rx1571_eos, rxscan1572_done
  rxscan1572_scan:
    set_addr $I10, rxscan1572_loop
    rx1571_cur."!mark_push"(0, rx1571_pos, $I10)
  rxscan1572_done:
.annotate 'line', 649
  # rx subcapture "sym"
    set_addr $I10, rxcap_1573_fail
    rx1571_cur."!mark_push"(0, rx1571_pos, $I10)
  # rx literal  "++"
    add $I11, rx1571_pos, 2
    gt $I11, rx1571_eos, rx1571_fail
    sub $I11, rx1571_pos, rx1571_off
    substr $S10, rx1571_tgt, $I11, 2
    ne $S10, "++", rx1571_fail
    add rx1571_pos, 2
    set_addr $I10, rxcap_1573_fail
    ($I12, $I11) = rx1571_cur."!mark_peek"($I10)
    rx1571_cur."!cursor_pos"($I11)
    ($P10) = rx1571_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1571_pos, "")
    rx1571_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1573_done
  rxcap_1573_fail:
    goto rx1571_fail
  rxcap_1573_done:
  # rx subrule "O" subtype=capture negate=
    rx1571_cur."!cursor_pos"(rx1571_pos)
    $P10 = rx1571_cur."O"("%autoincrement, :pirop<inc>")
    unless $P10, rx1571_fail
    rx1571_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1571_pos = $P10."pos"()
  # rx pass
    rx1571_cur."!cursor_pass"(rx1571_pos, "prefix:sym<++>")
    if_null rx1571_debug, debug_1220
    rx1571_cur."!cursor_debug"("PASS", "prefix:sym<++>", " at pos=", rx1571_pos)
  debug_1220:
    .return (rx1571_cur)
  rx1571_restart:
.annotate 'line', 10
    if_null rx1571_debug, debug_1221
    rx1571_cur."!cursor_debug"("NEXT", "prefix:sym<++>")
  debug_1221:
  rx1571_fail:
    (rx1571_rep, rx1571_pos, $I10, $P10) = rx1571_cur."!mark_fail"(0)
    lt rx1571_pos, -1, rx1571_done
    eq rx1571_pos, -1, rx1571_fail
    jump $I10
  rx1571_done:
    rx1571_cur."!cursor_fail"()
    if_null rx1571_debug, debug_1222
    rx1571_cur."!cursor_debug"("FAIL", "prefix:sym<++>")
  debug_1222:
    .return (rx1571_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<++>"  :subid("290_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1575 = self."!PREFIX__!subrule"("O", "++")
    new $P1576, "ResizablePMCArray"
    push $P1576, $P1575
    .return ($P1576)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<-->"  :subid("291_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1578_tgt
    .local int rx1578_pos
    .local int rx1578_off
    .local int rx1578_eos
    .local int rx1578_rep
    .local pmc rx1578_cur
    .local pmc rx1578_debug
    (rx1578_cur, rx1578_pos, rx1578_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1578_cur
    .local pmc match
    .lex "$/", match
    length rx1578_eos, rx1578_tgt
    gt rx1578_pos, rx1578_eos, rx1578_done
    set rx1578_off, 0
    lt rx1578_pos, 2, rx1578_start
    sub rx1578_off, rx1578_pos, 1
    substr rx1578_tgt, rx1578_tgt, rx1578_off
  rx1578_start:
    eq $I10, 1, rx1578_restart
    if_null rx1578_debug, debug_1223
    rx1578_cur."!cursor_debug"("START", "prefix:sym<-->")
  debug_1223:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1579_done
    goto rxscan1579_scan
  rxscan1579_loop:
    (rx1578_pos) = rx1578_cur."from"()
    inc rx1578_pos
    rx1578_cur."!cursor_from"(rx1578_pos)
    ge rx1578_pos, rx1578_eos, rxscan1579_done
  rxscan1579_scan:
    set_addr $I10, rxscan1579_loop
    rx1578_cur."!mark_push"(0, rx1578_pos, $I10)
  rxscan1579_done:
.annotate 'line', 650
  # rx subcapture "sym"
    set_addr $I10, rxcap_1580_fail
    rx1578_cur."!mark_push"(0, rx1578_pos, $I10)
  # rx literal  "--"
    add $I11, rx1578_pos, 2
    gt $I11, rx1578_eos, rx1578_fail
    sub $I11, rx1578_pos, rx1578_off
    substr $S10, rx1578_tgt, $I11, 2
    ne $S10, "--", rx1578_fail
    add rx1578_pos, 2
    set_addr $I10, rxcap_1580_fail
    ($I12, $I11) = rx1578_cur."!mark_peek"($I10)
    rx1578_cur."!cursor_pos"($I11)
    ($P10) = rx1578_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1578_pos, "")
    rx1578_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1580_done
  rxcap_1580_fail:
    goto rx1578_fail
  rxcap_1580_done:
  # rx subrule "O" subtype=capture negate=
    rx1578_cur."!cursor_pos"(rx1578_pos)
    $P10 = rx1578_cur."O"("%autoincrement, :pirop<dec>")
    unless $P10, rx1578_fail
    rx1578_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1578_pos = $P10."pos"()
  # rx pass
    rx1578_cur."!cursor_pass"(rx1578_pos, "prefix:sym<-->")
    if_null rx1578_debug, debug_1224
    rx1578_cur."!cursor_debug"("PASS", "prefix:sym<-->", " at pos=", rx1578_pos)
  debug_1224:
    .return (rx1578_cur)
  rx1578_restart:
.annotate 'line', 10
    if_null rx1578_debug, debug_1225
    rx1578_cur."!cursor_debug"("NEXT", "prefix:sym<-->")
  debug_1225:
  rx1578_fail:
    (rx1578_rep, rx1578_pos, $I10, $P10) = rx1578_cur."!mark_fail"(0)
    lt rx1578_pos, -1, rx1578_done
    eq rx1578_pos, -1, rx1578_fail
    jump $I10
  rx1578_done:
    rx1578_cur."!cursor_fail"()
    if_null rx1578_debug, debug_1226
    rx1578_cur."!cursor_debug"("FAIL", "prefix:sym<-->")
  debug_1226:
    .return (rx1578_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<-->"  :subid("292_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1582 = self."!PREFIX__!subrule"("O", "--")
    new $P1583, "ResizablePMCArray"
    push $P1583, $P1582
    .return ($P1583)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<++>"  :subid("293_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1585_tgt
    .local int rx1585_pos
    .local int rx1585_off
    .local int rx1585_eos
    .local int rx1585_rep
    .local pmc rx1585_cur
    .local pmc rx1585_debug
    (rx1585_cur, rx1585_pos, rx1585_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1585_cur
    .local pmc match
    .lex "$/", match
    length rx1585_eos, rx1585_tgt
    gt rx1585_pos, rx1585_eos, rx1585_done
    set rx1585_off, 0
    lt rx1585_pos, 2, rx1585_start
    sub rx1585_off, rx1585_pos, 1
    substr rx1585_tgt, rx1585_tgt, rx1585_off
  rx1585_start:
    eq $I10, 1, rx1585_restart
    if_null rx1585_debug, debug_1227
    rx1585_cur."!cursor_debug"("START", "postfix:sym<++>")
  debug_1227:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1586_done
    goto rxscan1586_scan
  rxscan1586_loop:
    (rx1585_pos) = rx1585_cur."from"()
    inc rx1585_pos
    rx1585_cur."!cursor_from"(rx1585_pos)
    ge rx1585_pos, rx1585_eos, rxscan1586_done
  rxscan1586_scan:
    set_addr $I10, rxscan1586_loop
    rx1585_cur."!mark_push"(0, rx1585_pos, $I10)
  rxscan1586_done:
.annotate 'line', 653
  # rx subcapture "sym"
    set_addr $I10, rxcap_1587_fail
    rx1585_cur."!mark_push"(0, rx1585_pos, $I10)
  # rx literal  "++"
    add $I11, rx1585_pos, 2
    gt $I11, rx1585_eos, rx1585_fail
    sub $I11, rx1585_pos, rx1585_off
    substr $S10, rx1585_tgt, $I11, 2
    ne $S10, "++", rx1585_fail
    add rx1585_pos, 2
    set_addr $I10, rxcap_1587_fail
    ($I12, $I11) = rx1585_cur."!mark_peek"($I10)
    rx1585_cur."!cursor_pos"($I11)
    ($P10) = rx1585_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1585_pos, "")
    rx1585_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1587_done
  rxcap_1587_fail:
    goto rx1585_fail
  rxcap_1587_done:
  # rx subrule "O" subtype=capture negate=
    rx1585_cur."!cursor_pos"(rx1585_pos)
    $P10 = rx1585_cur."O"("%autoincrement")
    unless $P10, rx1585_fail
    rx1585_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1585_pos = $P10."pos"()
  # rx pass
    rx1585_cur."!cursor_pass"(rx1585_pos, "postfix:sym<++>")
    if_null rx1585_debug, debug_1228
    rx1585_cur."!cursor_debug"("PASS", "postfix:sym<++>", " at pos=", rx1585_pos)
  debug_1228:
    .return (rx1585_cur)
  rx1585_restart:
.annotate 'line', 10
    if_null rx1585_debug, debug_1229
    rx1585_cur."!cursor_debug"("NEXT", "postfix:sym<++>")
  debug_1229:
  rx1585_fail:
    (rx1585_rep, rx1585_pos, $I10, $P10) = rx1585_cur."!mark_fail"(0)
    lt rx1585_pos, -1, rx1585_done
    eq rx1585_pos, -1, rx1585_fail
    jump $I10
  rx1585_done:
    rx1585_cur."!cursor_fail"()
    if_null rx1585_debug, debug_1230
    rx1585_cur."!cursor_debug"("FAIL", "postfix:sym<++>")
  debug_1230:
    .return (rx1585_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<++>"  :subid("294_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1589 = self."!PREFIX__!subrule"("O", "++")
    new $P1590, "ResizablePMCArray"
    push $P1590, $P1589
    .return ($P1590)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<-->"  :subid("295_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1592_tgt
    .local int rx1592_pos
    .local int rx1592_off
    .local int rx1592_eos
    .local int rx1592_rep
    .local pmc rx1592_cur
    .local pmc rx1592_debug
    (rx1592_cur, rx1592_pos, rx1592_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1592_cur
    .local pmc match
    .lex "$/", match
    length rx1592_eos, rx1592_tgt
    gt rx1592_pos, rx1592_eos, rx1592_done
    set rx1592_off, 0
    lt rx1592_pos, 2, rx1592_start
    sub rx1592_off, rx1592_pos, 1
    substr rx1592_tgt, rx1592_tgt, rx1592_off
  rx1592_start:
    eq $I10, 1, rx1592_restart
    if_null rx1592_debug, debug_1231
    rx1592_cur."!cursor_debug"("START", "postfix:sym<-->")
  debug_1231:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1593_done
    goto rxscan1593_scan
  rxscan1593_loop:
    (rx1592_pos) = rx1592_cur."from"()
    inc rx1592_pos
    rx1592_cur."!cursor_from"(rx1592_pos)
    ge rx1592_pos, rx1592_eos, rxscan1593_done
  rxscan1593_scan:
    set_addr $I10, rxscan1593_loop
    rx1592_cur."!mark_push"(0, rx1592_pos, $I10)
  rxscan1593_done:
.annotate 'line', 654
  # rx subcapture "sym"
    set_addr $I10, rxcap_1594_fail
    rx1592_cur."!mark_push"(0, rx1592_pos, $I10)
  # rx literal  "--"
    add $I11, rx1592_pos, 2
    gt $I11, rx1592_eos, rx1592_fail
    sub $I11, rx1592_pos, rx1592_off
    substr $S10, rx1592_tgt, $I11, 2
    ne $S10, "--", rx1592_fail
    add rx1592_pos, 2
    set_addr $I10, rxcap_1594_fail
    ($I12, $I11) = rx1592_cur."!mark_peek"($I10)
    rx1592_cur."!cursor_pos"($I11)
    ($P10) = rx1592_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1592_pos, "")
    rx1592_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1594_done
  rxcap_1594_fail:
    goto rx1592_fail
  rxcap_1594_done:
  # rx subrule "O" subtype=capture negate=
    rx1592_cur."!cursor_pos"(rx1592_pos)
    $P10 = rx1592_cur."O"("%autoincrement")
    unless $P10, rx1592_fail
    rx1592_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1592_pos = $P10."pos"()
  # rx pass
    rx1592_cur."!cursor_pass"(rx1592_pos, "postfix:sym<-->")
    if_null rx1592_debug, debug_1232
    rx1592_cur."!cursor_debug"("PASS", "postfix:sym<-->", " at pos=", rx1592_pos)
  debug_1232:
    .return (rx1592_cur)
  rx1592_restart:
.annotate 'line', 10
    if_null rx1592_debug, debug_1233
    rx1592_cur."!cursor_debug"("NEXT", "postfix:sym<-->")
  debug_1233:
  rx1592_fail:
    (rx1592_rep, rx1592_pos, $I10, $P10) = rx1592_cur."!mark_fail"(0)
    lt rx1592_pos, -1, rx1592_done
    eq rx1592_pos, -1, rx1592_fail
    jump $I10
  rx1592_done:
    rx1592_cur."!cursor_fail"()
    if_null rx1592_debug, debug_1234
    rx1592_cur."!cursor_debug"("FAIL", "postfix:sym<-->")
  debug_1234:
    .return (rx1592_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<-->"  :subid("296_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1596 = self."!PREFIX__!subrule"("O", "--")
    new $P1597, "ResizablePMCArray"
    push $P1597, $P1596
    .return ($P1597)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<**>"  :subid("297_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1599_tgt
    .local int rx1599_pos
    .local int rx1599_off
    .local int rx1599_eos
    .local int rx1599_rep
    .local pmc rx1599_cur
    .local pmc rx1599_debug
    (rx1599_cur, rx1599_pos, rx1599_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1599_cur
    .local pmc match
    .lex "$/", match
    length rx1599_eos, rx1599_tgt
    gt rx1599_pos, rx1599_eos, rx1599_done
    set rx1599_off, 0
    lt rx1599_pos, 2, rx1599_start
    sub rx1599_off, rx1599_pos, 1
    substr rx1599_tgt, rx1599_tgt, rx1599_off
  rx1599_start:
    eq $I10, 1, rx1599_restart
    if_null rx1599_debug, debug_1235
    rx1599_cur."!cursor_debug"("START", "infix:sym<**>")
  debug_1235:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1600_done
    goto rxscan1600_scan
  rxscan1600_loop:
    (rx1599_pos) = rx1599_cur."from"()
    inc rx1599_pos
    rx1599_cur."!cursor_from"(rx1599_pos)
    ge rx1599_pos, rx1599_eos, rxscan1600_done
  rxscan1600_scan:
    set_addr $I10, rxscan1600_loop
    rx1599_cur."!mark_push"(0, rx1599_pos, $I10)
  rxscan1600_done:
.annotate 'line', 656
  # rx subcapture "sym"
    set_addr $I10, rxcap_1601_fail
    rx1599_cur."!mark_push"(0, rx1599_pos, $I10)
  # rx literal  "**"
    add $I11, rx1599_pos, 2
    gt $I11, rx1599_eos, rx1599_fail
    sub $I11, rx1599_pos, rx1599_off
    substr $S10, rx1599_tgt, $I11, 2
    ne $S10, "**", rx1599_fail
    add rx1599_pos, 2
    set_addr $I10, rxcap_1601_fail
    ($I12, $I11) = rx1599_cur."!mark_peek"($I10)
    rx1599_cur."!cursor_pos"($I11)
    ($P10) = rx1599_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1599_pos, "")
    rx1599_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1601_done
  rxcap_1601_fail:
    goto rx1599_fail
  rxcap_1601_done:
  # rx subrule "O" subtype=capture negate=
    rx1599_cur."!cursor_pos"(rx1599_pos)
    $P10 = rx1599_cur."O"("%exponentiation, :pirop<pow>")
    unless $P10, rx1599_fail
    rx1599_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1599_pos = $P10."pos"()
  # rx pass
    rx1599_cur."!cursor_pass"(rx1599_pos, "infix:sym<**>")
    if_null rx1599_debug, debug_1236
    rx1599_cur."!cursor_debug"("PASS", "infix:sym<**>", " at pos=", rx1599_pos)
  debug_1236:
    .return (rx1599_cur)
  rx1599_restart:
.annotate 'line', 10
    if_null rx1599_debug, debug_1237
    rx1599_cur."!cursor_debug"("NEXT", "infix:sym<**>")
  debug_1237:
  rx1599_fail:
    (rx1599_rep, rx1599_pos, $I10, $P10) = rx1599_cur."!mark_fail"(0)
    lt rx1599_pos, -1, rx1599_done
    eq rx1599_pos, -1, rx1599_fail
    jump $I10
  rx1599_done:
    rx1599_cur."!cursor_fail"()
    if_null rx1599_debug, debug_1238
    rx1599_cur."!cursor_debug"("FAIL", "infix:sym<**>")
  debug_1238:
    .return (rx1599_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<**>"  :subid("298_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1603 = self."!PREFIX__!subrule"("O", "**")
    new $P1604, "ResizablePMCArray"
    push $P1604, $P1603
    .return ($P1604)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<+>"  :subid("299_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1606_tgt
    .local int rx1606_pos
    .local int rx1606_off
    .local int rx1606_eos
    .local int rx1606_rep
    .local pmc rx1606_cur
    .local pmc rx1606_debug
    (rx1606_cur, rx1606_pos, rx1606_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1606_cur
    .local pmc match
    .lex "$/", match
    length rx1606_eos, rx1606_tgt
    gt rx1606_pos, rx1606_eos, rx1606_done
    set rx1606_off, 0
    lt rx1606_pos, 2, rx1606_start
    sub rx1606_off, rx1606_pos, 1
    substr rx1606_tgt, rx1606_tgt, rx1606_off
  rx1606_start:
    eq $I10, 1, rx1606_restart
    if_null rx1606_debug, debug_1239
    rx1606_cur."!cursor_debug"("START", "prefix:sym<+>")
  debug_1239:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1607_done
    goto rxscan1607_scan
  rxscan1607_loop:
    (rx1606_pos) = rx1606_cur."from"()
    inc rx1606_pos
    rx1606_cur."!cursor_from"(rx1606_pos)
    ge rx1606_pos, rx1606_eos, rxscan1607_done
  rxscan1607_scan:
    set_addr $I10, rxscan1607_loop
    rx1606_cur."!mark_push"(0, rx1606_pos, $I10)
  rxscan1607_done:
.annotate 'line', 658
  # rx subcapture "sym"
    set_addr $I10, rxcap_1608_fail
    rx1606_cur."!mark_push"(0, rx1606_pos, $I10)
  # rx literal  "+"
    add $I11, rx1606_pos, 1
    gt $I11, rx1606_eos, rx1606_fail
    sub $I11, rx1606_pos, rx1606_off
    ord $I11, rx1606_tgt, $I11
    ne $I11, 43, rx1606_fail
    add rx1606_pos, 1
    set_addr $I10, rxcap_1608_fail
    ($I12, $I11) = rx1606_cur."!mark_peek"($I10)
    rx1606_cur."!cursor_pos"($I11)
    ($P10) = rx1606_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1606_pos, "")
    rx1606_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1608_done
  rxcap_1608_fail:
    goto rx1606_fail
  rxcap_1608_done:
  # rx subrule "O" subtype=capture negate=
    rx1606_cur."!cursor_pos"(rx1606_pos)
    $P10 = rx1606_cur."O"("%symbolic_unary, :pirop<set N*>")
    unless $P10, rx1606_fail
    rx1606_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1606_pos = $P10."pos"()
  # rx pass
    rx1606_cur."!cursor_pass"(rx1606_pos, "prefix:sym<+>")
    if_null rx1606_debug, debug_1240
    rx1606_cur."!cursor_debug"("PASS", "prefix:sym<+>", " at pos=", rx1606_pos)
  debug_1240:
    .return (rx1606_cur)
  rx1606_restart:
.annotate 'line', 10
    if_null rx1606_debug, debug_1241
    rx1606_cur."!cursor_debug"("NEXT", "prefix:sym<+>")
  debug_1241:
  rx1606_fail:
    (rx1606_rep, rx1606_pos, $I10, $P10) = rx1606_cur."!mark_fail"(0)
    lt rx1606_pos, -1, rx1606_done
    eq rx1606_pos, -1, rx1606_fail
    jump $I10
  rx1606_done:
    rx1606_cur."!cursor_fail"()
    if_null rx1606_debug, debug_1242
    rx1606_cur."!cursor_debug"("FAIL", "prefix:sym<+>")
  debug_1242:
    .return (rx1606_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<+>"  :subid("300_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1610 = self."!PREFIX__!subrule"("O", "+")
    new $P1611, "ResizablePMCArray"
    push $P1611, $P1610
    .return ($P1611)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<~>"  :subid("301_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1613_tgt
    .local int rx1613_pos
    .local int rx1613_off
    .local int rx1613_eos
    .local int rx1613_rep
    .local pmc rx1613_cur
    .local pmc rx1613_debug
    (rx1613_cur, rx1613_pos, rx1613_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1613_cur
    .local pmc match
    .lex "$/", match
    length rx1613_eos, rx1613_tgt
    gt rx1613_pos, rx1613_eos, rx1613_done
    set rx1613_off, 0
    lt rx1613_pos, 2, rx1613_start
    sub rx1613_off, rx1613_pos, 1
    substr rx1613_tgt, rx1613_tgt, rx1613_off
  rx1613_start:
    eq $I10, 1, rx1613_restart
    if_null rx1613_debug, debug_1243
    rx1613_cur."!cursor_debug"("START", "prefix:sym<~>")
  debug_1243:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1614_done
    goto rxscan1614_scan
  rxscan1614_loop:
    (rx1613_pos) = rx1613_cur."from"()
    inc rx1613_pos
    rx1613_cur."!cursor_from"(rx1613_pos)
    ge rx1613_pos, rx1613_eos, rxscan1614_done
  rxscan1614_scan:
    set_addr $I10, rxscan1614_loop
    rx1613_cur."!mark_push"(0, rx1613_pos, $I10)
  rxscan1614_done:
.annotate 'line', 659
  # rx subcapture "sym"
    set_addr $I10, rxcap_1615_fail
    rx1613_cur."!mark_push"(0, rx1613_pos, $I10)
  # rx literal  "~"
    add $I11, rx1613_pos, 1
    gt $I11, rx1613_eos, rx1613_fail
    sub $I11, rx1613_pos, rx1613_off
    ord $I11, rx1613_tgt, $I11
    ne $I11, 126, rx1613_fail
    add rx1613_pos, 1
    set_addr $I10, rxcap_1615_fail
    ($I12, $I11) = rx1613_cur."!mark_peek"($I10)
    rx1613_cur."!cursor_pos"($I11)
    ($P10) = rx1613_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1613_pos, "")
    rx1613_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1615_done
  rxcap_1615_fail:
    goto rx1613_fail
  rxcap_1615_done:
  # rx subrule "O" subtype=capture negate=
    rx1613_cur."!cursor_pos"(rx1613_pos)
    $P10 = rx1613_cur."O"("%symbolic_unary, :pirop<set S*>")
    unless $P10, rx1613_fail
    rx1613_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1613_pos = $P10."pos"()
  # rx pass
    rx1613_cur."!cursor_pass"(rx1613_pos, "prefix:sym<~>")
    if_null rx1613_debug, debug_1244
    rx1613_cur."!cursor_debug"("PASS", "prefix:sym<~>", " at pos=", rx1613_pos)
  debug_1244:
    .return (rx1613_cur)
  rx1613_restart:
.annotate 'line', 10
    if_null rx1613_debug, debug_1245
    rx1613_cur."!cursor_debug"("NEXT", "prefix:sym<~>")
  debug_1245:
  rx1613_fail:
    (rx1613_rep, rx1613_pos, $I10, $P10) = rx1613_cur."!mark_fail"(0)
    lt rx1613_pos, -1, rx1613_done
    eq rx1613_pos, -1, rx1613_fail
    jump $I10
  rx1613_done:
    rx1613_cur."!cursor_fail"()
    if_null rx1613_debug, debug_1246
    rx1613_cur."!cursor_debug"("FAIL", "prefix:sym<~>")
  debug_1246:
    .return (rx1613_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<~>"  :subid("302_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1617 = self."!PREFIX__!subrule"("O", "~")
    new $P1618, "ResizablePMCArray"
    push $P1618, $P1617
    .return ($P1618)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<->"  :subid("303_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1620_tgt
    .local int rx1620_pos
    .local int rx1620_off
    .local int rx1620_eos
    .local int rx1620_rep
    .local pmc rx1620_cur
    .local pmc rx1620_debug
    (rx1620_cur, rx1620_pos, rx1620_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1620_cur
    .local pmc match
    .lex "$/", match
    length rx1620_eos, rx1620_tgt
    gt rx1620_pos, rx1620_eos, rx1620_done
    set rx1620_off, 0
    lt rx1620_pos, 2, rx1620_start
    sub rx1620_off, rx1620_pos, 1
    substr rx1620_tgt, rx1620_tgt, rx1620_off
  rx1620_start:
    eq $I10, 1, rx1620_restart
    if_null rx1620_debug, debug_1247
    rx1620_cur."!cursor_debug"("START", "prefix:sym<->")
  debug_1247:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1621_done
    goto rxscan1621_scan
  rxscan1621_loop:
    (rx1620_pos) = rx1620_cur."from"()
    inc rx1620_pos
    rx1620_cur."!cursor_from"(rx1620_pos)
    ge rx1620_pos, rx1620_eos, rxscan1621_done
  rxscan1621_scan:
    set_addr $I10, rxscan1621_loop
    rx1620_cur."!mark_push"(0, rx1620_pos, $I10)
  rxscan1621_done:
.annotate 'line', 660
  # rx subcapture "sym"
    set_addr $I10, rxcap_1622_fail
    rx1620_cur."!mark_push"(0, rx1620_pos, $I10)
  # rx literal  "-"
    add $I11, rx1620_pos, 1
    gt $I11, rx1620_eos, rx1620_fail
    sub $I11, rx1620_pos, rx1620_off
    ord $I11, rx1620_tgt, $I11
    ne $I11, 45, rx1620_fail
    add rx1620_pos, 1
    set_addr $I10, rxcap_1622_fail
    ($I12, $I11) = rx1620_cur."!mark_peek"($I10)
    rx1620_cur."!cursor_pos"($I11)
    ($P10) = rx1620_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1620_pos, "")
    rx1620_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1622_done
  rxcap_1622_fail:
    goto rx1620_fail
  rxcap_1622_done:
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1620_pos, rx1620_off
    substr $S10, rx1620_tgt, $I10, 1
    index $I11, ">", $S10
    ge $I11, 0, rx1620_fail
  # rx subrule "number" subtype=zerowidth negate=1
    rx1620_cur."!cursor_pos"(rx1620_pos)
    $P10 = rx1620_cur."number"()
    if $P10, rx1620_fail
  # rx subrule "O" subtype=capture negate=
    rx1620_cur."!cursor_pos"(rx1620_pos)
    $P10 = rx1620_cur."O"("%symbolic_unary, :pirop<neg>")
    unless $P10, rx1620_fail
    rx1620_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1620_pos = $P10."pos"()
  # rx pass
    rx1620_cur."!cursor_pass"(rx1620_pos, "prefix:sym<->")
    if_null rx1620_debug, debug_1248
    rx1620_cur."!cursor_debug"("PASS", "prefix:sym<->", " at pos=", rx1620_pos)
  debug_1248:
    .return (rx1620_cur)
  rx1620_restart:
.annotate 'line', 10
    if_null rx1620_debug, debug_1249
    rx1620_cur."!cursor_debug"("NEXT", "prefix:sym<->")
  debug_1249:
  rx1620_fail:
    (rx1620_rep, rx1620_pos, $I10, $P10) = rx1620_cur."!mark_fail"(0)
    lt rx1620_pos, -1, rx1620_done
    eq rx1620_pos, -1, rx1620_fail
    jump $I10
  rx1620_done:
    rx1620_cur."!cursor_fail"()
    if_null rx1620_debug, debug_1250
    rx1620_cur."!cursor_debug"("FAIL", "prefix:sym<->")
  debug_1250:
    .return (rx1620_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<->"  :subid("304_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    new $P1624, "ResizablePMCArray"
    push $P1624, "-"
    .return ($P1624)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<?>"  :subid("305_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1626_tgt
    .local int rx1626_pos
    .local int rx1626_off
    .local int rx1626_eos
    .local int rx1626_rep
    .local pmc rx1626_cur
    .local pmc rx1626_debug
    (rx1626_cur, rx1626_pos, rx1626_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1626_cur
    .local pmc match
    .lex "$/", match
    length rx1626_eos, rx1626_tgt
    gt rx1626_pos, rx1626_eos, rx1626_done
    set rx1626_off, 0
    lt rx1626_pos, 2, rx1626_start
    sub rx1626_off, rx1626_pos, 1
    substr rx1626_tgt, rx1626_tgt, rx1626_off
  rx1626_start:
    eq $I10, 1, rx1626_restart
    if_null rx1626_debug, debug_1251
    rx1626_cur."!cursor_debug"("START", "prefix:sym<?>")
  debug_1251:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1627_done
    goto rxscan1627_scan
  rxscan1627_loop:
    (rx1626_pos) = rx1626_cur."from"()
    inc rx1626_pos
    rx1626_cur."!cursor_from"(rx1626_pos)
    ge rx1626_pos, rx1626_eos, rxscan1627_done
  rxscan1627_scan:
    set_addr $I10, rxscan1627_loop
    rx1626_cur."!mark_push"(0, rx1626_pos, $I10)
  rxscan1627_done:
.annotate 'line', 661
  # rx subcapture "sym"
    set_addr $I10, rxcap_1628_fail
    rx1626_cur."!mark_push"(0, rx1626_pos, $I10)
  # rx literal  "?"
    add $I11, rx1626_pos, 1
    gt $I11, rx1626_eos, rx1626_fail
    sub $I11, rx1626_pos, rx1626_off
    ord $I11, rx1626_tgt, $I11
    ne $I11, 63, rx1626_fail
    add rx1626_pos, 1
    set_addr $I10, rxcap_1628_fail
    ($I12, $I11) = rx1626_cur."!mark_peek"($I10)
    rx1626_cur."!cursor_pos"($I11)
    ($P10) = rx1626_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1626_pos, "")
    rx1626_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1628_done
  rxcap_1628_fail:
    goto rx1626_fail
  rxcap_1628_done:
  # rx subrule "O" subtype=capture negate=
    rx1626_cur."!cursor_pos"(rx1626_pos)
    $P10 = rx1626_cur."O"("%symbolic_unary, :pirop<istrue>")
    unless $P10, rx1626_fail
    rx1626_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1626_pos = $P10."pos"()
  # rx pass
    rx1626_cur."!cursor_pass"(rx1626_pos, "prefix:sym<?>")
    if_null rx1626_debug, debug_1252
    rx1626_cur."!cursor_debug"("PASS", "prefix:sym<?>", " at pos=", rx1626_pos)
  debug_1252:
    .return (rx1626_cur)
  rx1626_restart:
.annotate 'line', 10
    if_null rx1626_debug, debug_1253
    rx1626_cur."!cursor_debug"("NEXT", "prefix:sym<?>")
  debug_1253:
  rx1626_fail:
    (rx1626_rep, rx1626_pos, $I10, $P10) = rx1626_cur."!mark_fail"(0)
    lt rx1626_pos, -1, rx1626_done
    eq rx1626_pos, -1, rx1626_fail
    jump $I10
  rx1626_done:
    rx1626_cur."!cursor_fail"()
    if_null rx1626_debug, debug_1254
    rx1626_cur."!cursor_debug"("FAIL", "prefix:sym<?>")
  debug_1254:
    .return (rx1626_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<?>"  :subid("306_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1630 = self."!PREFIX__!subrule"("O", "?")
    new $P1631, "ResizablePMCArray"
    push $P1631, $P1630
    .return ($P1631)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<!>"  :subid("307_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1633_tgt
    .local int rx1633_pos
    .local int rx1633_off
    .local int rx1633_eos
    .local int rx1633_rep
    .local pmc rx1633_cur
    .local pmc rx1633_debug
    (rx1633_cur, rx1633_pos, rx1633_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1633_cur
    .local pmc match
    .lex "$/", match
    length rx1633_eos, rx1633_tgt
    gt rx1633_pos, rx1633_eos, rx1633_done
    set rx1633_off, 0
    lt rx1633_pos, 2, rx1633_start
    sub rx1633_off, rx1633_pos, 1
    substr rx1633_tgt, rx1633_tgt, rx1633_off
  rx1633_start:
    eq $I10, 1, rx1633_restart
    if_null rx1633_debug, debug_1255
    rx1633_cur."!cursor_debug"("START", "prefix:sym<!>")
  debug_1255:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1634_done
    goto rxscan1634_scan
  rxscan1634_loop:
    (rx1633_pos) = rx1633_cur."from"()
    inc rx1633_pos
    rx1633_cur."!cursor_from"(rx1633_pos)
    ge rx1633_pos, rx1633_eos, rxscan1634_done
  rxscan1634_scan:
    set_addr $I10, rxscan1634_loop
    rx1633_cur."!mark_push"(0, rx1633_pos, $I10)
  rxscan1634_done:
.annotate 'line', 662
  # rx subcapture "sym"
    set_addr $I10, rxcap_1635_fail
    rx1633_cur."!mark_push"(0, rx1633_pos, $I10)
  # rx literal  "!"
    add $I11, rx1633_pos, 1
    gt $I11, rx1633_eos, rx1633_fail
    sub $I11, rx1633_pos, rx1633_off
    ord $I11, rx1633_tgt, $I11
    ne $I11, 33, rx1633_fail
    add rx1633_pos, 1
    set_addr $I10, rxcap_1635_fail
    ($I12, $I11) = rx1633_cur."!mark_peek"($I10)
    rx1633_cur."!cursor_pos"($I11)
    ($P10) = rx1633_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1633_pos, "")
    rx1633_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1635_done
  rxcap_1635_fail:
    goto rx1633_fail
  rxcap_1635_done:
  # rx subrule "O" subtype=capture negate=
    rx1633_cur."!cursor_pos"(rx1633_pos)
    $P10 = rx1633_cur."O"("%symbolic_unary, :pirop<isfalse>")
    unless $P10, rx1633_fail
    rx1633_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1633_pos = $P10."pos"()
  # rx pass
    rx1633_cur."!cursor_pass"(rx1633_pos, "prefix:sym<!>")
    if_null rx1633_debug, debug_1256
    rx1633_cur."!cursor_debug"("PASS", "prefix:sym<!>", " at pos=", rx1633_pos)
  debug_1256:
    .return (rx1633_cur)
  rx1633_restart:
.annotate 'line', 10
    if_null rx1633_debug, debug_1257
    rx1633_cur."!cursor_debug"("NEXT", "prefix:sym<!>")
  debug_1257:
  rx1633_fail:
    (rx1633_rep, rx1633_pos, $I10, $P10) = rx1633_cur."!mark_fail"(0)
    lt rx1633_pos, -1, rx1633_done
    eq rx1633_pos, -1, rx1633_fail
    jump $I10
  rx1633_done:
    rx1633_cur."!cursor_fail"()
    if_null rx1633_debug, debug_1258
    rx1633_cur."!cursor_debug"("FAIL", "prefix:sym<!>")
  debug_1258:
    .return (rx1633_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<!>"  :subid("308_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1637 = self."!PREFIX__!subrule"("O", "!")
    new $P1638, "ResizablePMCArray"
    push $P1638, $P1637
    .return ($P1638)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<|>"  :subid("309_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1640_tgt
    .local int rx1640_pos
    .local int rx1640_off
    .local int rx1640_eos
    .local int rx1640_rep
    .local pmc rx1640_cur
    .local pmc rx1640_debug
    (rx1640_cur, rx1640_pos, rx1640_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1640_cur
    .local pmc match
    .lex "$/", match
    length rx1640_eos, rx1640_tgt
    gt rx1640_pos, rx1640_eos, rx1640_done
    set rx1640_off, 0
    lt rx1640_pos, 2, rx1640_start
    sub rx1640_off, rx1640_pos, 1
    substr rx1640_tgt, rx1640_tgt, rx1640_off
  rx1640_start:
    eq $I10, 1, rx1640_restart
    if_null rx1640_debug, debug_1259
    rx1640_cur."!cursor_debug"("START", "prefix:sym<|>")
  debug_1259:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1641_done
    goto rxscan1641_scan
  rxscan1641_loop:
    (rx1640_pos) = rx1640_cur."from"()
    inc rx1640_pos
    rx1640_cur."!cursor_from"(rx1640_pos)
    ge rx1640_pos, rx1640_eos, rxscan1641_done
  rxscan1641_scan:
    set_addr $I10, rxscan1641_loop
    rx1640_cur."!mark_push"(0, rx1640_pos, $I10)
  rxscan1641_done:
.annotate 'line', 663
  # rx subcapture "sym"
    set_addr $I10, rxcap_1642_fail
    rx1640_cur."!mark_push"(0, rx1640_pos, $I10)
  # rx literal  "|"
    add $I11, rx1640_pos, 1
    gt $I11, rx1640_eos, rx1640_fail
    sub $I11, rx1640_pos, rx1640_off
    ord $I11, rx1640_tgt, $I11
    ne $I11, 124, rx1640_fail
    add rx1640_pos, 1
    set_addr $I10, rxcap_1642_fail
    ($I12, $I11) = rx1640_cur."!mark_peek"($I10)
    rx1640_cur."!cursor_pos"($I11)
    ($P10) = rx1640_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1640_pos, "")
    rx1640_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1642_done
  rxcap_1642_fail:
    goto rx1640_fail
  rxcap_1642_done:
  # rx subrule "O" subtype=capture negate=
    rx1640_cur."!cursor_pos"(rx1640_pos)
    $P10 = rx1640_cur."O"("%symbolic_unary")
    unless $P10, rx1640_fail
    rx1640_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1640_pos = $P10."pos"()
  # rx pass
    rx1640_cur."!cursor_pass"(rx1640_pos, "prefix:sym<|>")
    if_null rx1640_debug, debug_1260
    rx1640_cur."!cursor_debug"("PASS", "prefix:sym<|>", " at pos=", rx1640_pos)
  debug_1260:
    .return (rx1640_cur)
  rx1640_restart:
.annotate 'line', 10
    if_null rx1640_debug, debug_1261
    rx1640_cur."!cursor_debug"("NEXT", "prefix:sym<|>")
  debug_1261:
  rx1640_fail:
    (rx1640_rep, rx1640_pos, $I10, $P10) = rx1640_cur."!mark_fail"(0)
    lt rx1640_pos, -1, rx1640_done
    eq rx1640_pos, -1, rx1640_fail
    jump $I10
  rx1640_done:
    rx1640_cur."!cursor_fail"()
    if_null rx1640_debug, debug_1262
    rx1640_cur."!cursor_debug"("FAIL", "prefix:sym<|>")
  debug_1262:
    .return (rx1640_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<|>"  :subid("310_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1644 = self."!PREFIX__!subrule"("O", "|")
    new $P1645, "ResizablePMCArray"
    push $P1645, $P1644
    .return ($P1645)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<*>"  :subid("311_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1647_tgt
    .local int rx1647_pos
    .local int rx1647_off
    .local int rx1647_eos
    .local int rx1647_rep
    .local pmc rx1647_cur
    .local pmc rx1647_debug
    (rx1647_cur, rx1647_pos, rx1647_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1647_cur
    .local pmc match
    .lex "$/", match
    length rx1647_eos, rx1647_tgt
    gt rx1647_pos, rx1647_eos, rx1647_done
    set rx1647_off, 0
    lt rx1647_pos, 2, rx1647_start
    sub rx1647_off, rx1647_pos, 1
    substr rx1647_tgt, rx1647_tgt, rx1647_off
  rx1647_start:
    eq $I10, 1, rx1647_restart
    if_null rx1647_debug, debug_1263
    rx1647_cur."!cursor_debug"("START", "infix:sym<*>")
  debug_1263:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1648_done
    goto rxscan1648_scan
  rxscan1648_loop:
    (rx1647_pos) = rx1647_cur."from"()
    inc rx1647_pos
    rx1647_cur."!cursor_from"(rx1647_pos)
    ge rx1647_pos, rx1647_eos, rxscan1648_done
  rxscan1648_scan:
    set_addr $I10, rxscan1648_loop
    rx1647_cur."!mark_push"(0, rx1647_pos, $I10)
  rxscan1648_done:
.annotate 'line', 665
  # rx subcapture "sym"
    set_addr $I10, rxcap_1649_fail
    rx1647_cur."!mark_push"(0, rx1647_pos, $I10)
  # rx literal  "*"
    add $I11, rx1647_pos, 1
    gt $I11, rx1647_eos, rx1647_fail
    sub $I11, rx1647_pos, rx1647_off
    ord $I11, rx1647_tgt, $I11
    ne $I11, 42, rx1647_fail
    add rx1647_pos, 1
    set_addr $I10, rxcap_1649_fail
    ($I12, $I11) = rx1647_cur."!mark_peek"($I10)
    rx1647_cur."!cursor_pos"($I11)
    ($P10) = rx1647_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1647_pos, "")
    rx1647_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1649_done
  rxcap_1649_fail:
    goto rx1647_fail
  rxcap_1649_done:
  # rx subrule "O" subtype=capture negate=
    rx1647_cur."!cursor_pos"(rx1647_pos)
    $P10 = rx1647_cur."O"("%multiplicative, :pirop<mul>")
    unless $P10, rx1647_fail
    rx1647_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1647_pos = $P10."pos"()
  # rx pass
    rx1647_cur."!cursor_pass"(rx1647_pos, "infix:sym<*>")
    if_null rx1647_debug, debug_1264
    rx1647_cur."!cursor_debug"("PASS", "infix:sym<*>", " at pos=", rx1647_pos)
  debug_1264:
    .return (rx1647_cur)
  rx1647_restart:
.annotate 'line', 10
    if_null rx1647_debug, debug_1265
    rx1647_cur."!cursor_debug"("NEXT", "infix:sym<*>")
  debug_1265:
  rx1647_fail:
    (rx1647_rep, rx1647_pos, $I10, $P10) = rx1647_cur."!mark_fail"(0)
    lt rx1647_pos, -1, rx1647_done
    eq rx1647_pos, -1, rx1647_fail
    jump $I10
  rx1647_done:
    rx1647_cur."!cursor_fail"()
    if_null rx1647_debug, debug_1266
    rx1647_cur."!cursor_debug"("FAIL", "infix:sym<*>")
  debug_1266:
    .return (rx1647_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<*>"  :subid("312_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1651 = self."!PREFIX__!subrule"("O", "*")
    new $P1652, "ResizablePMCArray"
    push $P1652, $P1651
    .return ($P1652)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym</>"  :subid("313_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1654_tgt
    .local int rx1654_pos
    .local int rx1654_off
    .local int rx1654_eos
    .local int rx1654_rep
    .local pmc rx1654_cur
    .local pmc rx1654_debug
    (rx1654_cur, rx1654_pos, rx1654_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1654_cur
    .local pmc match
    .lex "$/", match
    length rx1654_eos, rx1654_tgt
    gt rx1654_pos, rx1654_eos, rx1654_done
    set rx1654_off, 0
    lt rx1654_pos, 2, rx1654_start
    sub rx1654_off, rx1654_pos, 1
    substr rx1654_tgt, rx1654_tgt, rx1654_off
  rx1654_start:
    eq $I10, 1, rx1654_restart
    if_null rx1654_debug, debug_1267
    rx1654_cur."!cursor_debug"("START", "infix:sym</>")
  debug_1267:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1655_done
    goto rxscan1655_scan
  rxscan1655_loop:
    (rx1654_pos) = rx1654_cur."from"()
    inc rx1654_pos
    rx1654_cur."!cursor_from"(rx1654_pos)
    ge rx1654_pos, rx1654_eos, rxscan1655_done
  rxscan1655_scan:
    set_addr $I10, rxscan1655_loop
    rx1654_cur."!mark_push"(0, rx1654_pos, $I10)
  rxscan1655_done:
.annotate 'line', 666
  # rx subcapture "sym"
    set_addr $I10, rxcap_1656_fail
    rx1654_cur."!mark_push"(0, rx1654_pos, $I10)
  # rx literal  "/"
    add $I11, rx1654_pos, 1
    gt $I11, rx1654_eos, rx1654_fail
    sub $I11, rx1654_pos, rx1654_off
    ord $I11, rx1654_tgt, $I11
    ne $I11, 47, rx1654_fail
    add rx1654_pos, 1
    set_addr $I10, rxcap_1656_fail
    ($I12, $I11) = rx1654_cur."!mark_peek"($I10)
    rx1654_cur."!cursor_pos"($I11)
    ($P10) = rx1654_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1654_pos, "")
    rx1654_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1656_done
  rxcap_1656_fail:
    goto rx1654_fail
  rxcap_1656_done:
  # rx subrule "O" subtype=capture negate=
    rx1654_cur."!cursor_pos"(rx1654_pos)
    $P10 = rx1654_cur."O"("%multiplicative, :pirop<div>")
    unless $P10, rx1654_fail
    rx1654_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1654_pos = $P10."pos"()
  # rx pass
    rx1654_cur."!cursor_pass"(rx1654_pos, "infix:sym</>")
    if_null rx1654_debug, debug_1268
    rx1654_cur."!cursor_debug"("PASS", "infix:sym</>", " at pos=", rx1654_pos)
  debug_1268:
    .return (rx1654_cur)
  rx1654_restart:
.annotate 'line', 10
    if_null rx1654_debug, debug_1269
    rx1654_cur."!cursor_debug"("NEXT", "infix:sym</>")
  debug_1269:
  rx1654_fail:
    (rx1654_rep, rx1654_pos, $I10, $P10) = rx1654_cur."!mark_fail"(0)
    lt rx1654_pos, -1, rx1654_done
    eq rx1654_pos, -1, rx1654_fail
    jump $I10
  rx1654_done:
    rx1654_cur."!cursor_fail"()
    if_null rx1654_debug, debug_1270
    rx1654_cur."!cursor_debug"("FAIL", "infix:sym</>")
  debug_1270:
    .return (rx1654_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym</>"  :subid("314_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1658 = self."!PREFIX__!subrule"("O", "/")
    new $P1659, "ResizablePMCArray"
    push $P1659, $P1658
    .return ($P1659)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<%>"  :subid("315_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1661_tgt
    .local int rx1661_pos
    .local int rx1661_off
    .local int rx1661_eos
    .local int rx1661_rep
    .local pmc rx1661_cur
    .local pmc rx1661_debug
    (rx1661_cur, rx1661_pos, rx1661_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1661_cur
    .local pmc match
    .lex "$/", match
    length rx1661_eos, rx1661_tgt
    gt rx1661_pos, rx1661_eos, rx1661_done
    set rx1661_off, 0
    lt rx1661_pos, 2, rx1661_start
    sub rx1661_off, rx1661_pos, 1
    substr rx1661_tgt, rx1661_tgt, rx1661_off
  rx1661_start:
    eq $I10, 1, rx1661_restart
    if_null rx1661_debug, debug_1271
    rx1661_cur."!cursor_debug"("START", "infix:sym<%>")
  debug_1271:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1662_done
    goto rxscan1662_scan
  rxscan1662_loop:
    (rx1661_pos) = rx1661_cur."from"()
    inc rx1661_pos
    rx1661_cur."!cursor_from"(rx1661_pos)
    ge rx1661_pos, rx1661_eos, rxscan1662_done
  rxscan1662_scan:
    set_addr $I10, rxscan1662_loop
    rx1661_cur."!mark_push"(0, rx1661_pos, $I10)
  rxscan1662_done:
.annotate 'line', 667
  # rx subcapture "sym"
    set_addr $I10, rxcap_1663_fail
    rx1661_cur."!mark_push"(0, rx1661_pos, $I10)
  # rx literal  "%"
    add $I11, rx1661_pos, 1
    gt $I11, rx1661_eos, rx1661_fail
    sub $I11, rx1661_pos, rx1661_off
    ord $I11, rx1661_tgt, $I11
    ne $I11, 37, rx1661_fail
    add rx1661_pos, 1
    set_addr $I10, rxcap_1663_fail
    ($I12, $I11) = rx1661_cur."!mark_peek"($I10)
    rx1661_cur."!cursor_pos"($I11)
    ($P10) = rx1661_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1661_pos, "")
    rx1661_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1663_done
  rxcap_1663_fail:
    goto rx1661_fail
  rxcap_1663_done:
  # rx subrule "O" subtype=capture negate=
    rx1661_cur."!cursor_pos"(rx1661_pos)
    $P10 = rx1661_cur."O"("%multiplicative, :pirop<mod>")
    unless $P10, rx1661_fail
    rx1661_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1661_pos = $P10."pos"()
  # rx pass
    rx1661_cur."!cursor_pass"(rx1661_pos, "infix:sym<%>")
    if_null rx1661_debug, debug_1272
    rx1661_cur."!cursor_debug"("PASS", "infix:sym<%>", " at pos=", rx1661_pos)
  debug_1272:
    .return (rx1661_cur)
  rx1661_restart:
.annotate 'line', 10
    if_null rx1661_debug, debug_1273
    rx1661_cur."!cursor_debug"("NEXT", "infix:sym<%>")
  debug_1273:
  rx1661_fail:
    (rx1661_rep, rx1661_pos, $I10, $P10) = rx1661_cur."!mark_fail"(0)
    lt rx1661_pos, -1, rx1661_done
    eq rx1661_pos, -1, rx1661_fail
    jump $I10
  rx1661_done:
    rx1661_cur."!cursor_fail"()
    if_null rx1661_debug, debug_1274
    rx1661_cur."!cursor_debug"("FAIL", "infix:sym<%>")
  debug_1274:
    .return (rx1661_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<%>"  :subid("316_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1665 = self."!PREFIX__!subrule"("O", "%")
    new $P1666, "ResizablePMCArray"
    push $P1666, $P1665
    .return ($P1666)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+&>"  :subid("317_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1668_tgt
    .local int rx1668_pos
    .local int rx1668_off
    .local int rx1668_eos
    .local int rx1668_rep
    .local pmc rx1668_cur
    .local pmc rx1668_debug
    (rx1668_cur, rx1668_pos, rx1668_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1668_cur
    .local pmc match
    .lex "$/", match
    length rx1668_eos, rx1668_tgt
    gt rx1668_pos, rx1668_eos, rx1668_done
    set rx1668_off, 0
    lt rx1668_pos, 2, rx1668_start
    sub rx1668_off, rx1668_pos, 1
    substr rx1668_tgt, rx1668_tgt, rx1668_off
  rx1668_start:
    eq $I10, 1, rx1668_restart
    if_null rx1668_debug, debug_1275
    rx1668_cur."!cursor_debug"("START", "infix:sym<+&>")
  debug_1275:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1669_done
    goto rxscan1669_scan
  rxscan1669_loop:
    (rx1668_pos) = rx1668_cur."from"()
    inc rx1668_pos
    rx1668_cur."!cursor_from"(rx1668_pos)
    ge rx1668_pos, rx1668_eos, rxscan1669_done
  rxscan1669_scan:
    set_addr $I10, rxscan1669_loop
    rx1668_cur."!mark_push"(0, rx1668_pos, $I10)
  rxscan1669_done:
.annotate 'line', 668
  # rx subcapture "sym"
    set_addr $I10, rxcap_1670_fail
    rx1668_cur."!mark_push"(0, rx1668_pos, $I10)
  # rx literal  "+&"
    add $I11, rx1668_pos, 2
    gt $I11, rx1668_eos, rx1668_fail
    sub $I11, rx1668_pos, rx1668_off
    substr $S10, rx1668_tgt, $I11, 2
    ne $S10, "+&", rx1668_fail
    add rx1668_pos, 2
    set_addr $I10, rxcap_1670_fail
    ($I12, $I11) = rx1668_cur."!mark_peek"($I10)
    rx1668_cur."!cursor_pos"($I11)
    ($P10) = rx1668_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1668_pos, "")
    rx1668_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1670_done
  rxcap_1670_fail:
    goto rx1668_fail
  rxcap_1670_done:
  # rx subrule "O" subtype=capture negate=
    rx1668_cur."!cursor_pos"(rx1668_pos)
    $P10 = rx1668_cur."O"("%multiplicative, :pirop<band III>")
    unless $P10, rx1668_fail
    rx1668_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1668_pos = $P10."pos"()
  # rx pass
    rx1668_cur."!cursor_pass"(rx1668_pos, "infix:sym<+&>")
    if_null rx1668_debug, debug_1276
    rx1668_cur."!cursor_debug"("PASS", "infix:sym<+&>", " at pos=", rx1668_pos)
  debug_1276:
    .return (rx1668_cur)
  rx1668_restart:
.annotate 'line', 10
    if_null rx1668_debug, debug_1277
    rx1668_cur."!cursor_debug"("NEXT", "infix:sym<+&>")
  debug_1277:
  rx1668_fail:
    (rx1668_rep, rx1668_pos, $I10, $P10) = rx1668_cur."!mark_fail"(0)
    lt rx1668_pos, -1, rx1668_done
    eq rx1668_pos, -1, rx1668_fail
    jump $I10
  rx1668_done:
    rx1668_cur."!cursor_fail"()
    if_null rx1668_debug, debug_1278
    rx1668_cur."!cursor_debug"("FAIL", "infix:sym<+&>")
  debug_1278:
    .return (rx1668_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+&>"  :subid("318_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1672 = self."!PREFIX__!subrule"("O", "+&")
    new $P1673, "ResizablePMCArray"
    push $P1673, $P1672
    .return ($P1673)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+>"  :subid("319_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1675_tgt
    .local int rx1675_pos
    .local int rx1675_off
    .local int rx1675_eos
    .local int rx1675_rep
    .local pmc rx1675_cur
    .local pmc rx1675_debug
    (rx1675_cur, rx1675_pos, rx1675_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1675_cur
    .local pmc match
    .lex "$/", match
    length rx1675_eos, rx1675_tgt
    gt rx1675_pos, rx1675_eos, rx1675_done
    set rx1675_off, 0
    lt rx1675_pos, 2, rx1675_start
    sub rx1675_off, rx1675_pos, 1
    substr rx1675_tgt, rx1675_tgt, rx1675_off
  rx1675_start:
    eq $I10, 1, rx1675_restart
    if_null rx1675_debug, debug_1279
    rx1675_cur."!cursor_debug"("START", "infix:sym<+>")
  debug_1279:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1676_done
    goto rxscan1676_scan
  rxscan1676_loop:
    (rx1675_pos) = rx1675_cur."from"()
    inc rx1675_pos
    rx1675_cur."!cursor_from"(rx1675_pos)
    ge rx1675_pos, rx1675_eos, rxscan1676_done
  rxscan1676_scan:
    set_addr $I10, rxscan1676_loop
    rx1675_cur."!mark_push"(0, rx1675_pos, $I10)
  rxscan1676_done:
.annotate 'line', 670
  # rx subcapture "sym"
    set_addr $I10, rxcap_1677_fail
    rx1675_cur."!mark_push"(0, rx1675_pos, $I10)
  # rx literal  "+"
    add $I11, rx1675_pos, 1
    gt $I11, rx1675_eos, rx1675_fail
    sub $I11, rx1675_pos, rx1675_off
    ord $I11, rx1675_tgt, $I11
    ne $I11, 43, rx1675_fail
    add rx1675_pos, 1
    set_addr $I10, rxcap_1677_fail
    ($I12, $I11) = rx1675_cur."!mark_peek"($I10)
    rx1675_cur."!cursor_pos"($I11)
    ($P10) = rx1675_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1675_pos, "")
    rx1675_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1677_done
  rxcap_1677_fail:
    goto rx1675_fail
  rxcap_1677_done:
  # rx subrule "O" subtype=capture negate=
    rx1675_cur."!cursor_pos"(rx1675_pos)
    $P10 = rx1675_cur."O"("%additive, :pirop<add>")
    unless $P10, rx1675_fail
    rx1675_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1675_pos = $P10."pos"()
  # rx pass
    rx1675_cur."!cursor_pass"(rx1675_pos, "infix:sym<+>")
    if_null rx1675_debug, debug_1280
    rx1675_cur."!cursor_debug"("PASS", "infix:sym<+>", " at pos=", rx1675_pos)
  debug_1280:
    .return (rx1675_cur)
  rx1675_restart:
.annotate 'line', 10
    if_null rx1675_debug, debug_1281
    rx1675_cur."!cursor_debug"("NEXT", "infix:sym<+>")
  debug_1281:
  rx1675_fail:
    (rx1675_rep, rx1675_pos, $I10, $P10) = rx1675_cur."!mark_fail"(0)
    lt rx1675_pos, -1, rx1675_done
    eq rx1675_pos, -1, rx1675_fail
    jump $I10
  rx1675_done:
    rx1675_cur."!cursor_fail"()
    if_null rx1675_debug, debug_1282
    rx1675_cur."!cursor_debug"("FAIL", "infix:sym<+>")
  debug_1282:
    .return (rx1675_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+>"  :subid("320_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1679 = self."!PREFIX__!subrule"("O", "+")
    new $P1680, "ResizablePMCArray"
    push $P1680, $P1679
    .return ($P1680)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<->"  :subid("321_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1682_tgt
    .local int rx1682_pos
    .local int rx1682_off
    .local int rx1682_eos
    .local int rx1682_rep
    .local pmc rx1682_cur
    .local pmc rx1682_debug
    (rx1682_cur, rx1682_pos, rx1682_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1682_cur
    .local pmc match
    .lex "$/", match
    length rx1682_eos, rx1682_tgt
    gt rx1682_pos, rx1682_eos, rx1682_done
    set rx1682_off, 0
    lt rx1682_pos, 2, rx1682_start
    sub rx1682_off, rx1682_pos, 1
    substr rx1682_tgt, rx1682_tgt, rx1682_off
  rx1682_start:
    eq $I10, 1, rx1682_restart
    if_null rx1682_debug, debug_1283
    rx1682_cur."!cursor_debug"("START", "infix:sym<->")
  debug_1283:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1683_done
    goto rxscan1683_scan
  rxscan1683_loop:
    (rx1682_pos) = rx1682_cur."from"()
    inc rx1682_pos
    rx1682_cur."!cursor_from"(rx1682_pos)
    ge rx1682_pos, rx1682_eos, rxscan1683_done
  rxscan1683_scan:
    set_addr $I10, rxscan1683_loop
    rx1682_cur."!mark_push"(0, rx1682_pos, $I10)
  rxscan1683_done:
.annotate 'line', 671
  # rx subcapture "sym"
    set_addr $I10, rxcap_1684_fail
    rx1682_cur."!mark_push"(0, rx1682_pos, $I10)
  # rx literal  "-"
    add $I11, rx1682_pos, 1
    gt $I11, rx1682_eos, rx1682_fail
    sub $I11, rx1682_pos, rx1682_off
    ord $I11, rx1682_tgt, $I11
    ne $I11, 45, rx1682_fail
    add rx1682_pos, 1
    set_addr $I10, rxcap_1684_fail
    ($I12, $I11) = rx1682_cur."!mark_peek"($I10)
    rx1682_cur."!cursor_pos"($I11)
    ($P10) = rx1682_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1682_pos, "")
    rx1682_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1684_done
  rxcap_1684_fail:
    goto rx1682_fail
  rxcap_1684_done:
  # rx subrule "O" subtype=capture negate=
    rx1682_cur."!cursor_pos"(rx1682_pos)
    $P10 = rx1682_cur."O"("%additive, :pirop<sub>")
    unless $P10, rx1682_fail
    rx1682_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1682_pos = $P10."pos"()
  # rx pass
    rx1682_cur."!cursor_pass"(rx1682_pos, "infix:sym<->")
    if_null rx1682_debug, debug_1284
    rx1682_cur."!cursor_debug"("PASS", "infix:sym<->", " at pos=", rx1682_pos)
  debug_1284:
    .return (rx1682_cur)
  rx1682_restart:
.annotate 'line', 10
    if_null rx1682_debug, debug_1285
    rx1682_cur."!cursor_debug"("NEXT", "infix:sym<->")
  debug_1285:
  rx1682_fail:
    (rx1682_rep, rx1682_pos, $I10, $P10) = rx1682_cur."!mark_fail"(0)
    lt rx1682_pos, -1, rx1682_done
    eq rx1682_pos, -1, rx1682_fail
    jump $I10
  rx1682_done:
    rx1682_cur."!cursor_fail"()
    if_null rx1682_debug, debug_1286
    rx1682_cur."!cursor_debug"("FAIL", "infix:sym<->")
  debug_1286:
    .return (rx1682_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<->"  :subid("322_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1686 = self."!PREFIX__!subrule"("O", "-")
    new $P1687, "ResizablePMCArray"
    push $P1687, $P1686
    .return ($P1687)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+|>"  :subid("323_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1689_tgt
    .local int rx1689_pos
    .local int rx1689_off
    .local int rx1689_eos
    .local int rx1689_rep
    .local pmc rx1689_cur
    .local pmc rx1689_debug
    (rx1689_cur, rx1689_pos, rx1689_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1689_cur
    .local pmc match
    .lex "$/", match
    length rx1689_eos, rx1689_tgt
    gt rx1689_pos, rx1689_eos, rx1689_done
    set rx1689_off, 0
    lt rx1689_pos, 2, rx1689_start
    sub rx1689_off, rx1689_pos, 1
    substr rx1689_tgt, rx1689_tgt, rx1689_off
  rx1689_start:
    eq $I10, 1, rx1689_restart
    if_null rx1689_debug, debug_1287
    rx1689_cur."!cursor_debug"("START", "infix:sym<+|>")
  debug_1287:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1690_done
    goto rxscan1690_scan
  rxscan1690_loop:
    (rx1689_pos) = rx1689_cur."from"()
    inc rx1689_pos
    rx1689_cur."!cursor_from"(rx1689_pos)
    ge rx1689_pos, rx1689_eos, rxscan1690_done
  rxscan1690_scan:
    set_addr $I10, rxscan1690_loop
    rx1689_cur."!mark_push"(0, rx1689_pos, $I10)
  rxscan1690_done:
.annotate 'line', 672
  # rx subcapture "sym"
    set_addr $I10, rxcap_1691_fail
    rx1689_cur."!mark_push"(0, rx1689_pos, $I10)
  # rx literal  "+|"
    add $I11, rx1689_pos, 2
    gt $I11, rx1689_eos, rx1689_fail
    sub $I11, rx1689_pos, rx1689_off
    substr $S10, rx1689_tgt, $I11, 2
    ne $S10, "+|", rx1689_fail
    add rx1689_pos, 2
    set_addr $I10, rxcap_1691_fail
    ($I12, $I11) = rx1689_cur."!mark_peek"($I10)
    rx1689_cur."!cursor_pos"($I11)
    ($P10) = rx1689_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1689_pos, "")
    rx1689_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1691_done
  rxcap_1691_fail:
    goto rx1689_fail
  rxcap_1691_done:
  # rx subrule "O" subtype=capture negate=
    rx1689_cur."!cursor_pos"(rx1689_pos)
    $P10 = rx1689_cur."O"("%additive, :pirop<bor III>")
    unless $P10, rx1689_fail
    rx1689_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1689_pos = $P10."pos"()
  # rx pass
    rx1689_cur."!cursor_pass"(rx1689_pos, "infix:sym<+|>")
    if_null rx1689_debug, debug_1288
    rx1689_cur."!cursor_debug"("PASS", "infix:sym<+|>", " at pos=", rx1689_pos)
  debug_1288:
    .return (rx1689_cur)
  rx1689_restart:
.annotate 'line', 10
    if_null rx1689_debug, debug_1289
    rx1689_cur."!cursor_debug"("NEXT", "infix:sym<+|>")
  debug_1289:
  rx1689_fail:
    (rx1689_rep, rx1689_pos, $I10, $P10) = rx1689_cur."!mark_fail"(0)
    lt rx1689_pos, -1, rx1689_done
    eq rx1689_pos, -1, rx1689_fail
    jump $I10
  rx1689_done:
    rx1689_cur."!cursor_fail"()
    if_null rx1689_debug, debug_1290
    rx1689_cur."!cursor_debug"("FAIL", "infix:sym<+|>")
  debug_1290:
    .return (rx1689_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+|>"  :subid("324_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1693 = self."!PREFIX__!subrule"("O", "+|")
    new $P1694, "ResizablePMCArray"
    push $P1694, $P1693
    .return ($P1694)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+^>"  :subid("325_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1696_tgt
    .local int rx1696_pos
    .local int rx1696_off
    .local int rx1696_eos
    .local int rx1696_rep
    .local pmc rx1696_cur
    .local pmc rx1696_debug
    (rx1696_cur, rx1696_pos, rx1696_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1696_cur
    .local pmc match
    .lex "$/", match
    length rx1696_eos, rx1696_tgt
    gt rx1696_pos, rx1696_eos, rx1696_done
    set rx1696_off, 0
    lt rx1696_pos, 2, rx1696_start
    sub rx1696_off, rx1696_pos, 1
    substr rx1696_tgt, rx1696_tgt, rx1696_off
  rx1696_start:
    eq $I10, 1, rx1696_restart
    if_null rx1696_debug, debug_1291
    rx1696_cur."!cursor_debug"("START", "infix:sym<+^>")
  debug_1291:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1697_done
    goto rxscan1697_scan
  rxscan1697_loop:
    (rx1696_pos) = rx1696_cur."from"()
    inc rx1696_pos
    rx1696_cur."!cursor_from"(rx1696_pos)
    ge rx1696_pos, rx1696_eos, rxscan1697_done
  rxscan1697_scan:
    set_addr $I10, rxscan1697_loop
    rx1696_cur."!mark_push"(0, rx1696_pos, $I10)
  rxscan1697_done:
.annotate 'line', 673
  # rx subcapture "sym"
    set_addr $I10, rxcap_1698_fail
    rx1696_cur."!mark_push"(0, rx1696_pos, $I10)
  # rx literal  "+^"
    add $I11, rx1696_pos, 2
    gt $I11, rx1696_eos, rx1696_fail
    sub $I11, rx1696_pos, rx1696_off
    substr $S10, rx1696_tgt, $I11, 2
    ne $S10, "+^", rx1696_fail
    add rx1696_pos, 2
    set_addr $I10, rxcap_1698_fail
    ($I12, $I11) = rx1696_cur."!mark_peek"($I10)
    rx1696_cur."!cursor_pos"($I11)
    ($P10) = rx1696_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1696_pos, "")
    rx1696_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1698_done
  rxcap_1698_fail:
    goto rx1696_fail
  rxcap_1698_done:
  # rx subrule "O" subtype=capture negate=
    rx1696_cur."!cursor_pos"(rx1696_pos)
    $P10 = rx1696_cur."O"("%additive, :pirop<bxor III>")
    unless $P10, rx1696_fail
    rx1696_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1696_pos = $P10."pos"()
  # rx pass
    rx1696_cur."!cursor_pass"(rx1696_pos, "infix:sym<+^>")
    if_null rx1696_debug, debug_1292
    rx1696_cur."!cursor_debug"("PASS", "infix:sym<+^>", " at pos=", rx1696_pos)
  debug_1292:
    .return (rx1696_cur)
  rx1696_restart:
.annotate 'line', 10
    if_null rx1696_debug, debug_1293
    rx1696_cur."!cursor_debug"("NEXT", "infix:sym<+^>")
  debug_1293:
  rx1696_fail:
    (rx1696_rep, rx1696_pos, $I10, $P10) = rx1696_cur."!mark_fail"(0)
    lt rx1696_pos, -1, rx1696_done
    eq rx1696_pos, -1, rx1696_fail
    jump $I10
  rx1696_done:
    rx1696_cur."!cursor_fail"()
    if_null rx1696_debug, debug_1294
    rx1696_cur."!cursor_debug"("FAIL", "infix:sym<+^>")
  debug_1294:
    .return (rx1696_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+^>"  :subid("326_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1700 = self."!PREFIX__!subrule"("O", "+^")
    new $P1701, "ResizablePMCArray"
    push $P1701, $P1700
    .return ($P1701)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~>"  :subid("327_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1703_tgt
    .local int rx1703_pos
    .local int rx1703_off
    .local int rx1703_eos
    .local int rx1703_rep
    .local pmc rx1703_cur
    .local pmc rx1703_debug
    (rx1703_cur, rx1703_pos, rx1703_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1703_cur
    .local pmc match
    .lex "$/", match
    length rx1703_eos, rx1703_tgt
    gt rx1703_pos, rx1703_eos, rx1703_done
    set rx1703_off, 0
    lt rx1703_pos, 2, rx1703_start
    sub rx1703_off, rx1703_pos, 1
    substr rx1703_tgt, rx1703_tgt, rx1703_off
  rx1703_start:
    eq $I10, 1, rx1703_restart
    if_null rx1703_debug, debug_1295
    rx1703_cur."!cursor_debug"("START", "infix:sym<~>")
  debug_1295:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1704_done
    goto rxscan1704_scan
  rxscan1704_loop:
    (rx1703_pos) = rx1703_cur."from"()
    inc rx1703_pos
    rx1703_cur."!cursor_from"(rx1703_pos)
    ge rx1703_pos, rx1703_eos, rxscan1704_done
  rxscan1704_scan:
    set_addr $I10, rxscan1704_loop
    rx1703_cur."!mark_push"(0, rx1703_pos, $I10)
  rxscan1704_done:
.annotate 'line', 675
  # rx subcapture "sym"
    set_addr $I10, rxcap_1705_fail
    rx1703_cur."!mark_push"(0, rx1703_pos, $I10)
  # rx literal  "~"
    add $I11, rx1703_pos, 1
    gt $I11, rx1703_eos, rx1703_fail
    sub $I11, rx1703_pos, rx1703_off
    ord $I11, rx1703_tgt, $I11
    ne $I11, 126, rx1703_fail
    add rx1703_pos, 1
    set_addr $I10, rxcap_1705_fail
    ($I12, $I11) = rx1703_cur."!mark_peek"($I10)
    rx1703_cur."!cursor_pos"($I11)
    ($P10) = rx1703_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1703_pos, "")
    rx1703_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1705_done
  rxcap_1705_fail:
    goto rx1703_fail
  rxcap_1705_done:
  # rx subrule "O" subtype=capture negate=
    rx1703_cur."!cursor_pos"(rx1703_pos)
    $P10 = rx1703_cur."O"("%concatenation , :pirop<concat>")
    unless $P10, rx1703_fail
    rx1703_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1703_pos = $P10."pos"()
  # rx pass
    rx1703_cur."!cursor_pass"(rx1703_pos, "infix:sym<~>")
    if_null rx1703_debug, debug_1296
    rx1703_cur."!cursor_debug"("PASS", "infix:sym<~>", " at pos=", rx1703_pos)
  debug_1296:
    .return (rx1703_cur)
  rx1703_restart:
.annotate 'line', 10
    if_null rx1703_debug, debug_1297
    rx1703_cur."!cursor_debug"("NEXT", "infix:sym<~>")
  debug_1297:
  rx1703_fail:
    (rx1703_rep, rx1703_pos, $I10, $P10) = rx1703_cur."!mark_fail"(0)
    lt rx1703_pos, -1, rx1703_done
    eq rx1703_pos, -1, rx1703_fail
    jump $I10
  rx1703_done:
    rx1703_cur."!cursor_fail"()
    if_null rx1703_debug, debug_1298
    rx1703_cur."!cursor_debug"("FAIL", "infix:sym<~>")
  debug_1298:
    .return (rx1703_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~>"  :subid("328_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1707 = self."!PREFIX__!subrule"("O", "~")
    new $P1708, "ResizablePMCArray"
    push $P1708, $P1707
    .return ($P1708)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<==>"  :subid("329_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1710_tgt
    .local int rx1710_pos
    .local int rx1710_off
    .local int rx1710_eos
    .local int rx1710_rep
    .local pmc rx1710_cur
    .local pmc rx1710_debug
    (rx1710_cur, rx1710_pos, rx1710_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1710_cur
    .local pmc match
    .lex "$/", match
    length rx1710_eos, rx1710_tgt
    gt rx1710_pos, rx1710_eos, rx1710_done
    set rx1710_off, 0
    lt rx1710_pos, 2, rx1710_start
    sub rx1710_off, rx1710_pos, 1
    substr rx1710_tgt, rx1710_tgt, rx1710_off
  rx1710_start:
    eq $I10, 1, rx1710_restart
    if_null rx1710_debug, debug_1299
    rx1710_cur."!cursor_debug"("START", "infix:sym<==>")
  debug_1299:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1711_done
    goto rxscan1711_scan
  rxscan1711_loop:
    (rx1710_pos) = rx1710_cur."from"()
    inc rx1710_pos
    rx1710_cur."!cursor_from"(rx1710_pos)
    ge rx1710_pos, rx1710_eos, rxscan1711_done
  rxscan1711_scan:
    set_addr $I10, rxscan1711_loop
    rx1710_cur."!mark_push"(0, rx1710_pos, $I10)
  rxscan1711_done:
.annotate 'line', 677
  # rx subcapture "sym"
    set_addr $I10, rxcap_1712_fail
    rx1710_cur."!mark_push"(0, rx1710_pos, $I10)
  # rx literal  "=="
    add $I11, rx1710_pos, 2
    gt $I11, rx1710_eos, rx1710_fail
    sub $I11, rx1710_pos, rx1710_off
    substr $S10, rx1710_tgt, $I11, 2
    ne $S10, "==", rx1710_fail
    add rx1710_pos, 2
    set_addr $I10, rxcap_1712_fail
    ($I12, $I11) = rx1710_cur."!mark_peek"($I10)
    rx1710_cur."!cursor_pos"($I11)
    ($P10) = rx1710_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1710_pos, "")
    rx1710_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1712_done
  rxcap_1712_fail:
    goto rx1710_fail
  rxcap_1712_done:
  # rx subrule "O" subtype=capture negate=
    rx1710_cur."!cursor_pos"(rx1710_pos)
    $P10 = rx1710_cur."O"("%relational, :pirop<iseq INn>")
    unless $P10, rx1710_fail
    rx1710_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1710_pos = $P10."pos"()
  # rx pass
    rx1710_cur."!cursor_pass"(rx1710_pos, "infix:sym<==>")
    if_null rx1710_debug, debug_1300
    rx1710_cur."!cursor_debug"("PASS", "infix:sym<==>", " at pos=", rx1710_pos)
  debug_1300:
    .return (rx1710_cur)
  rx1710_restart:
.annotate 'line', 10
    if_null rx1710_debug, debug_1301
    rx1710_cur."!cursor_debug"("NEXT", "infix:sym<==>")
  debug_1301:
  rx1710_fail:
    (rx1710_rep, rx1710_pos, $I10, $P10) = rx1710_cur."!mark_fail"(0)
    lt rx1710_pos, -1, rx1710_done
    eq rx1710_pos, -1, rx1710_fail
    jump $I10
  rx1710_done:
    rx1710_cur."!cursor_fail"()
    if_null rx1710_debug, debug_1302
    rx1710_cur."!cursor_debug"("FAIL", "infix:sym<==>")
  debug_1302:
    .return (rx1710_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<==>"  :subid("330_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1714 = self."!PREFIX__!subrule"("O", "==")
    new $P1715, "ResizablePMCArray"
    push $P1715, $P1714
    .return ($P1715)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<!=>"  :subid("331_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1717_tgt
    .local int rx1717_pos
    .local int rx1717_off
    .local int rx1717_eos
    .local int rx1717_rep
    .local pmc rx1717_cur
    .local pmc rx1717_debug
    (rx1717_cur, rx1717_pos, rx1717_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1717_cur
    .local pmc match
    .lex "$/", match
    length rx1717_eos, rx1717_tgt
    gt rx1717_pos, rx1717_eos, rx1717_done
    set rx1717_off, 0
    lt rx1717_pos, 2, rx1717_start
    sub rx1717_off, rx1717_pos, 1
    substr rx1717_tgt, rx1717_tgt, rx1717_off
  rx1717_start:
    eq $I10, 1, rx1717_restart
    if_null rx1717_debug, debug_1303
    rx1717_cur."!cursor_debug"("START", "infix:sym<!=>")
  debug_1303:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1718_done
    goto rxscan1718_scan
  rxscan1718_loop:
    (rx1717_pos) = rx1717_cur."from"()
    inc rx1717_pos
    rx1717_cur."!cursor_from"(rx1717_pos)
    ge rx1717_pos, rx1717_eos, rxscan1718_done
  rxscan1718_scan:
    set_addr $I10, rxscan1718_loop
    rx1717_cur."!mark_push"(0, rx1717_pos, $I10)
  rxscan1718_done:
.annotate 'line', 678
  # rx subcapture "sym"
    set_addr $I10, rxcap_1719_fail
    rx1717_cur."!mark_push"(0, rx1717_pos, $I10)
  # rx literal  "!="
    add $I11, rx1717_pos, 2
    gt $I11, rx1717_eos, rx1717_fail
    sub $I11, rx1717_pos, rx1717_off
    substr $S10, rx1717_tgt, $I11, 2
    ne $S10, "!=", rx1717_fail
    add rx1717_pos, 2
    set_addr $I10, rxcap_1719_fail
    ($I12, $I11) = rx1717_cur."!mark_peek"($I10)
    rx1717_cur."!cursor_pos"($I11)
    ($P10) = rx1717_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1717_pos, "")
    rx1717_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1719_done
  rxcap_1719_fail:
    goto rx1717_fail
  rxcap_1719_done:
  # rx subrule "O" subtype=capture negate=
    rx1717_cur."!cursor_pos"(rx1717_pos)
    $P10 = rx1717_cur."O"("%relational, :pirop<isne INn>")
    unless $P10, rx1717_fail
    rx1717_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1717_pos = $P10."pos"()
  # rx pass
    rx1717_cur."!cursor_pass"(rx1717_pos, "infix:sym<!=>")
    if_null rx1717_debug, debug_1304
    rx1717_cur."!cursor_debug"("PASS", "infix:sym<!=>", " at pos=", rx1717_pos)
  debug_1304:
    .return (rx1717_cur)
  rx1717_restart:
.annotate 'line', 10
    if_null rx1717_debug, debug_1305
    rx1717_cur."!cursor_debug"("NEXT", "infix:sym<!=>")
  debug_1305:
  rx1717_fail:
    (rx1717_rep, rx1717_pos, $I10, $P10) = rx1717_cur."!mark_fail"(0)
    lt rx1717_pos, -1, rx1717_done
    eq rx1717_pos, -1, rx1717_fail
    jump $I10
  rx1717_done:
    rx1717_cur."!cursor_fail"()
    if_null rx1717_debug, debug_1306
    rx1717_cur."!cursor_debug"("FAIL", "infix:sym<!=>")
  debug_1306:
    .return (rx1717_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<!=>"  :subid("332_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1721 = self."!PREFIX__!subrule"("O", "!=")
    new $P1722, "ResizablePMCArray"
    push $P1722, $P1721
    .return ($P1722)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<=>"  :subid("333_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1724_tgt
    .local int rx1724_pos
    .local int rx1724_off
    .local int rx1724_eos
    .local int rx1724_rep
    .local pmc rx1724_cur
    .local pmc rx1724_debug
    (rx1724_cur, rx1724_pos, rx1724_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1724_cur
    .local pmc match
    .lex "$/", match
    length rx1724_eos, rx1724_tgt
    gt rx1724_pos, rx1724_eos, rx1724_done
    set rx1724_off, 0
    lt rx1724_pos, 2, rx1724_start
    sub rx1724_off, rx1724_pos, 1
    substr rx1724_tgt, rx1724_tgt, rx1724_off
  rx1724_start:
    eq $I10, 1, rx1724_restart
    if_null rx1724_debug, debug_1307
    rx1724_cur."!cursor_debug"("START", "infix:sym<<=>")
  debug_1307:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1725_done
    goto rxscan1725_scan
  rxscan1725_loop:
    (rx1724_pos) = rx1724_cur."from"()
    inc rx1724_pos
    rx1724_cur."!cursor_from"(rx1724_pos)
    ge rx1724_pos, rx1724_eos, rxscan1725_done
  rxscan1725_scan:
    set_addr $I10, rxscan1725_loop
    rx1724_cur."!mark_push"(0, rx1724_pos, $I10)
  rxscan1725_done:
.annotate 'line', 679
  # rx subcapture "sym"
    set_addr $I10, rxcap_1726_fail
    rx1724_cur."!mark_push"(0, rx1724_pos, $I10)
  # rx literal  "<="
    add $I11, rx1724_pos, 2
    gt $I11, rx1724_eos, rx1724_fail
    sub $I11, rx1724_pos, rx1724_off
    substr $S10, rx1724_tgt, $I11, 2
    ne $S10, "<=", rx1724_fail
    add rx1724_pos, 2
    set_addr $I10, rxcap_1726_fail
    ($I12, $I11) = rx1724_cur."!mark_peek"($I10)
    rx1724_cur."!cursor_pos"($I11)
    ($P10) = rx1724_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1724_pos, "")
    rx1724_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1726_done
  rxcap_1726_fail:
    goto rx1724_fail
  rxcap_1726_done:
  # rx subrule "O" subtype=capture negate=
    rx1724_cur."!cursor_pos"(rx1724_pos)
    $P10 = rx1724_cur."O"("%relational, :pirop<isle INn>")
    unless $P10, rx1724_fail
    rx1724_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1724_pos = $P10."pos"()
  # rx pass
    rx1724_cur."!cursor_pass"(rx1724_pos, "infix:sym<<=>")
    if_null rx1724_debug, debug_1308
    rx1724_cur."!cursor_debug"("PASS", "infix:sym<<=>", " at pos=", rx1724_pos)
  debug_1308:
    .return (rx1724_cur)
  rx1724_restart:
.annotate 'line', 10
    if_null rx1724_debug, debug_1309
    rx1724_cur."!cursor_debug"("NEXT", "infix:sym<<=>")
  debug_1309:
  rx1724_fail:
    (rx1724_rep, rx1724_pos, $I10, $P10) = rx1724_cur."!mark_fail"(0)
    lt rx1724_pos, -1, rx1724_done
    eq rx1724_pos, -1, rx1724_fail
    jump $I10
  rx1724_done:
    rx1724_cur."!cursor_fail"()
    if_null rx1724_debug, debug_1310
    rx1724_cur."!cursor_debug"("FAIL", "infix:sym<<=>")
  debug_1310:
    .return (rx1724_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<=>"  :subid("334_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1728 = self."!PREFIX__!subrule"("O", "<=")
    new $P1729, "ResizablePMCArray"
    push $P1729, $P1728
    .return ($P1729)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>=>"  :subid("335_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1731_tgt
    .local int rx1731_pos
    .local int rx1731_off
    .local int rx1731_eos
    .local int rx1731_rep
    .local pmc rx1731_cur
    .local pmc rx1731_debug
    (rx1731_cur, rx1731_pos, rx1731_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1731_cur
    .local pmc match
    .lex "$/", match
    length rx1731_eos, rx1731_tgt
    gt rx1731_pos, rx1731_eos, rx1731_done
    set rx1731_off, 0
    lt rx1731_pos, 2, rx1731_start
    sub rx1731_off, rx1731_pos, 1
    substr rx1731_tgt, rx1731_tgt, rx1731_off
  rx1731_start:
    eq $I10, 1, rx1731_restart
    if_null rx1731_debug, debug_1311
    rx1731_cur."!cursor_debug"("START", "infix:sym<>=>")
  debug_1311:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1732_done
    goto rxscan1732_scan
  rxscan1732_loop:
    (rx1731_pos) = rx1731_cur."from"()
    inc rx1731_pos
    rx1731_cur."!cursor_from"(rx1731_pos)
    ge rx1731_pos, rx1731_eos, rxscan1732_done
  rxscan1732_scan:
    set_addr $I10, rxscan1732_loop
    rx1731_cur."!mark_push"(0, rx1731_pos, $I10)
  rxscan1732_done:
.annotate 'line', 680
  # rx subcapture "sym"
    set_addr $I10, rxcap_1733_fail
    rx1731_cur."!mark_push"(0, rx1731_pos, $I10)
  # rx literal  ">="
    add $I11, rx1731_pos, 2
    gt $I11, rx1731_eos, rx1731_fail
    sub $I11, rx1731_pos, rx1731_off
    substr $S10, rx1731_tgt, $I11, 2
    ne $S10, ">=", rx1731_fail
    add rx1731_pos, 2
    set_addr $I10, rxcap_1733_fail
    ($I12, $I11) = rx1731_cur."!mark_peek"($I10)
    rx1731_cur."!cursor_pos"($I11)
    ($P10) = rx1731_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1731_pos, "")
    rx1731_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1733_done
  rxcap_1733_fail:
    goto rx1731_fail
  rxcap_1733_done:
  # rx subrule "O" subtype=capture negate=
    rx1731_cur."!cursor_pos"(rx1731_pos)
    $P10 = rx1731_cur."O"("%relational, :pirop<isge INn>")
    unless $P10, rx1731_fail
    rx1731_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1731_pos = $P10."pos"()
  # rx pass
    rx1731_cur."!cursor_pass"(rx1731_pos, "infix:sym<>=>")
    if_null rx1731_debug, debug_1312
    rx1731_cur."!cursor_debug"("PASS", "infix:sym<>=>", " at pos=", rx1731_pos)
  debug_1312:
    .return (rx1731_cur)
  rx1731_restart:
.annotate 'line', 10
    if_null rx1731_debug, debug_1313
    rx1731_cur."!cursor_debug"("NEXT", "infix:sym<>=>")
  debug_1313:
  rx1731_fail:
    (rx1731_rep, rx1731_pos, $I10, $P10) = rx1731_cur."!mark_fail"(0)
    lt rx1731_pos, -1, rx1731_done
    eq rx1731_pos, -1, rx1731_fail
    jump $I10
  rx1731_done:
    rx1731_cur."!cursor_fail"()
    if_null rx1731_debug, debug_1314
    rx1731_cur."!cursor_debug"("FAIL", "infix:sym<>=>")
  debug_1314:
    .return (rx1731_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>=>"  :subid("336_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1735 = self."!PREFIX__!subrule"("O", ">=")
    new $P1736, "ResizablePMCArray"
    push $P1736, $P1735
    .return ($P1736)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<>"  :subid("337_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1738_tgt
    .local int rx1738_pos
    .local int rx1738_off
    .local int rx1738_eos
    .local int rx1738_rep
    .local pmc rx1738_cur
    .local pmc rx1738_debug
    (rx1738_cur, rx1738_pos, rx1738_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1738_cur
    .local pmc match
    .lex "$/", match
    length rx1738_eos, rx1738_tgt
    gt rx1738_pos, rx1738_eos, rx1738_done
    set rx1738_off, 0
    lt rx1738_pos, 2, rx1738_start
    sub rx1738_off, rx1738_pos, 1
    substr rx1738_tgt, rx1738_tgt, rx1738_off
  rx1738_start:
    eq $I10, 1, rx1738_restart
    if_null rx1738_debug, debug_1315
    rx1738_cur."!cursor_debug"("START", "infix:sym<<>")
  debug_1315:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1739_done
    goto rxscan1739_scan
  rxscan1739_loop:
    (rx1738_pos) = rx1738_cur."from"()
    inc rx1738_pos
    rx1738_cur."!cursor_from"(rx1738_pos)
    ge rx1738_pos, rx1738_eos, rxscan1739_done
  rxscan1739_scan:
    set_addr $I10, rxscan1739_loop
    rx1738_cur."!mark_push"(0, rx1738_pos, $I10)
  rxscan1739_done:
.annotate 'line', 681
  # rx subcapture "sym"
    set_addr $I10, rxcap_1740_fail
    rx1738_cur."!mark_push"(0, rx1738_pos, $I10)
  # rx literal  "<"
    add $I11, rx1738_pos, 1
    gt $I11, rx1738_eos, rx1738_fail
    sub $I11, rx1738_pos, rx1738_off
    ord $I11, rx1738_tgt, $I11
    ne $I11, 60, rx1738_fail
    add rx1738_pos, 1
    set_addr $I10, rxcap_1740_fail
    ($I12, $I11) = rx1738_cur."!mark_peek"($I10)
    rx1738_cur."!cursor_pos"($I11)
    ($P10) = rx1738_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1738_pos, "")
    rx1738_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1740_done
  rxcap_1740_fail:
    goto rx1738_fail
  rxcap_1740_done:
  # rx subrule "O" subtype=capture negate=
    rx1738_cur."!cursor_pos"(rx1738_pos)
    $P10 = rx1738_cur."O"("%relational, :pirop<islt INn>")
    unless $P10, rx1738_fail
    rx1738_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1738_pos = $P10."pos"()
  # rx pass
    rx1738_cur."!cursor_pass"(rx1738_pos, "infix:sym<<>")
    if_null rx1738_debug, debug_1316
    rx1738_cur."!cursor_debug"("PASS", "infix:sym<<>", " at pos=", rx1738_pos)
  debug_1316:
    .return (rx1738_cur)
  rx1738_restart:
.annotate 'line', 10
    if_null rx1738_debug, debug_1317
    rx1738_cur."!cursor_debug"("NEXT", "infix:sym<<>")
  debug_1317:
  rx1738_fail:
    (rx1738_rep, rx1738_pos, $I10, $P10) = rx1738_cur."!mark_fail"(0)
    lt rx1738_pos, -1, rx1738_done
    eq rx1738_pos, -1, rx1738_fail
    jump $I10
  rx1738_done:
    rx1738_cur."!cursor_fail"()
    if_null rx1738_debug, debug_1318
    rx1738_cur."!cursor_debug"("FAIL", "infix:sym<<>")
  debug_1318:
    .return (rx1738_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<>"  :subid("338_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1742 = self."!PREFIX__!subrule"("O", "<")
    new $P1743, "ResizablePMCArray"
    push $P1743, $P1742
    .return ($P1743)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>>"  :subid("339_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1745_tgt
    .local int rx1745_pos
    .local int rx1745_off
    .local int rx1745_eos
    .local int rx1745_rep
    .local pmc rx1745_cur
    .local pmc rx1745_debug
    (rx1745_cur, rx1745_pos, rx1745_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1745_cur
    .local pmc match
    .lex "$/", match
    length rx1745_eos, rx1745_tgt
    gt rx1745_pos, rx1745_eos, rx1745_done
    set rx1745_off, 0
    lt rx1745_pos, 2, rx1745_start
    sub rx1745_off, rx1745_pos, 1
    substr rx1745_tgt, rx1745_tgt, rx1745_off
  rx1745_start:
    eq $I10, 1, rx1745_restart
    if_null rx1745_debug, debug_1319
    rx1745_cur."!cursor_debug"("START", "infix:sym<>>")
  debug_1319:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1746_done
    goto rxscan1746_scan
  rxscan1746_loop:
    (rx1745_pos) = rx1745_cur."from"()
    inc rx1745_pos
    rx1745_cur."!cursor_from"(rx1745_pos)
    ge rx1745_pos, rx1745_eos, rxscan1746_done
  rxscan1746_scan:
    set_addr $I10, rxscan1746_loop
    rx1745_cur."!mark_push"(0, rx1745_pos, $I10)
  rxscan1746_done:
.annotate 'line', 682
  # rx subcapture "sym"
    set_addr $I10, rxcap_1747_fail
    rx1745_cur."!mark_push"(0, rx1745_pos, $I10)
  # rx literal  ">"
    add $I11, rx1745_pos, 1
    gt $I11, rx1745_eos, rx1745_fail
    sub $I11, rx1745_pos, rx1745_off
    ord $I11, rx1745_tgt, $I11
    ne $I11, 62, rx1745_fail
    add rx1745_pos, 1
    set_addr $I10, rxcap_1747_fail
    ($I12, $I11) = rx1745_cur."!mark_peek"($I10)
    rx1745_cur."!cursor_pos"($I11)
    ($P10) = rx1745_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1745_pos, "")
    rx1745_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1747_done
  rxcap_1747_fail:
    goto rx1745_fail
  rxcap_1747_done:
  # rx subrule "O" subtype=capture negate=
    rx1745_cur."!cursor_pos"(rx1745_pos)
    $P10 = rx1745_cur."O"("%relational, :pirop<isgt INn>")
    unless $P10, rx1745_fail
    rx1745_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1745_pos = $P10."pos"()
  # rx pass
    rx1745_cur."!cursor_pass"(rx1745_pos, "infix:sym<>>")
    if_null rx1745_debug, debug_1320
    rx1745_cur."!cursor_debug"("PASS", "infix:sym<>>", " at pos=", rx1745_pos)
  debug_1320:
    .return (rx1745_cur)
  rx1745_restart:
.annotate 'line', 10
    if_null rx1745_debug, debug_1321
    rx1745_cur."!cursor_debug"("NEXT", "infix:sym<>>")
  debug_1321:
  rx1745_fail:
    (rx1745_rep, rx1745_pos, $I10, $P10) = rx1745_cur."!mark_fail"(0)
    lt rx1745_pos, -1, rx1745_done
    eq rx1745_pos, -1, rx1745_fail
    jump $I10
  rx1745_done:
    rx1745_cur."!cursor_fail"()
    if_null rx1745_debug, debug_1322
    rx1745_cur."!cursor_debug"("FAIL", "infix:sym<>>")
  debug_1322:
    .return (rx1745_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>>"  :subid("340_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1749 = self."!PREFIX__!subrule"("O", ">")
    new $P1750, "ResizablePMCArray"
    push $P1750, $P1749
    .return ($P1750)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<eq>"  :subid("341_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1752_tgt
    .local int rx1752_pos
    .local int rx1752_off
    .local int rx1752_eos
    .local int rx1752_rep
    .local pmc rx1752_cur
    .local pmc rx1752_debug
    (rx1752_cur, rx1752_pos, rx1752_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1752_cur
    .local pmc match
    .lex "$/", match
    length rx1752_eos, rx1752_tgt
    gt rx1752_pos, rx1752_eos, rx1752_done
    set rx1752_off, 0
    lt rx1752_pos, 2, rx1752_start
    sub rx1752_off, rx1752_pos, 1
    substr rx1752_tgt, rx1752_tgt, rx1752_off
  rx1752_start:
    eq $I10, 1, rx1752_restart
    if_null rx1752_debug, debug_1323
    rx1752_cur."!cursor_debug"("START", "infix:sym<eq>")
  debug_1323:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1753_done
    goto rxscan1753_scan
  rxscan1753_loop:
    (rx1752_pos) = rx1752_cur."from"()
    inc rx1752_pos
    rx1752_cur."!cursor_from"(rx1752_pos)
    ge rx1752_pos, rx1752_eos, rxscan1753_done
  rxscan1753_scan:
    set_addr $I10, rxscan1753_loop
    rx1752_cur."!mark_push"(0, rx1752_pos, $I10)
  rxscan1753_done:
.annotate 'line', 683
  # rx subcapture "sym"
    set_addr $I10, rxcap_1754_fail
    rx1752_cur."!mark_push"(0, rx1752_pos, $I10)
  # rx literal  "eq"
    add $I11, rx1752_pos, 2
    gt $I11, rx1752_eos, rx1752_fail
    sub $I11, rx1752_pos, rx1752_off
    substr $S10, rx1752_tgt, $I11, 2
    ne $S10, "eq", rx1752_fail
    add rx1752_pos, 2
    set_addr $I10, rxcap_1754_fail
    ($I12, $I11) = rx1752_cur."!mark_peek"($I10)
    rx1752_cur."!cursor_pos"($I11)
    ($P10) = rx1752_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1752_pos, "")
    rx1752_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1754_done
  rxcap_1754_fail:
    goto rx1752_fail
  rxcap_1754_done:
  # rx subrule "O" subtype=capture negate=
    rx1752_cur."!cursor_pos"(rx1752_pos)
    $P10 = rx1752_cur."O"("%relational, :pirop<iseq ISs>")
    unless $P10, rx1752_fail
    rx1752_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1752_pos = $P10."pos"()
  # rx pass
    rx1752_cur."!cursor_pass"(rx1752_pos, "infix:sym<eq>")
    if_null rx1752_debug, debug_1324
    rx1752_cur."!cursor_debug"("PASS", "infix:sym<eq>", " at pos=", rx1752_pos)
  debug_1324:
    .return (rx1752_cur)
  rx1752_restart:
.annotate 'line', 10
    if_null rx1752_debug, debug_1325
    rx1752_cur."!cursor_debug"("NEXT", "infix:sym<eq>")
  debug_1325:
  rx1752_fail:
    (rx1752_rep, rx1752_pos, $I10, $P10) = rx1752_cur."!mark_fail"(0)
    lt rx1752_pos, -1, rx1752_done
    eq rx1752_pos, -1, rx1752_fail
    jump $I10
  rx1752_done:
    rx1752_cur."!cursor_fail"()
    if_null rx1752_debug, debug_1326
    rx1752_cur."!cursor_debug"("FAIL", "infix:sym<eq>")
  debug_1326:
    .return (rx1752_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<eq>"  :subid("342_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1756 = self."!PREFIX__!subrule"("O", "eq")
    new $P1757, "ResizablePMCArray"
    push $P1757, $P1756
    .return ($P1757)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ne>"  :subid("343_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1759_tgt
    .local int rx1759_pos
    .local int rx1759_off
    .local int rx1759_eos
    .local int rx1759_rep
    .local pmc rx1759_cur
    .local pmc rx1759_debug
    (rx1759_cur, rx1759_pos, rx1759_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1759_cur
    .local pmc match
    .lex "$/", match
    length rx1759_eos, rx1759_tgt
    gt rx1759_pos, rx1759_eos, rx1759_done
    set rx1759_off, 0
    lt rx1759_pos, 2, rx1759_start
    sub rx1759_off, rx1759_pos, 1
    substr rx1759_tgt, rx1759_tgt, rx1759_off
  rx1759_start:
    eq $I10, 1, rx1759_restart
    if_null rx1759_debug, debug_1327
    rx1759_cur."!cursor_debug"("START", "infix:sym<ne>")
  debug_1327:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1760_done
    goto rxscan1760_scan
  rxscan1760_loop:
    (rx1759_pos) = rx1759_cur."from"()
    inc rx1759_pos
    rx1759_cur."!cursor_from"(rx1759_pos)
    ge rx1759_pos, rx1759_eos, rxscan1760_done
  rxscan1760_scan:
    set_addr $I10, rxscan1760_loop
    rx1759_cur."!mark_push"(0, rx1759_pos, $I10)
  rxscan1760_done:
.annotate 'line', 684
  # rx subcapture "sym"
    set_addr $I10, rxcap_1761_fail
    rx1759_cur."!mark_push"(0, rx1759_pos, $I10)
  # rx literal  "ne"
    add $I11, rx1759_pos, 2
    gt $I11, rx1759_eos, rx1759_fail
    sub $I11, rx1759_pos, rx1759_off
    substr $S10, rx1759_tgt, $I11, 2
    ne $S10, "ne", rx1759_fail
    add rx1759_pos, 2
    set_addr $I10, rxcap_1761_fail
    ($I12, $I11) = rx1759_cur."!mark_peek"($I10)
    rx1759_cur."!cursor_pos"($I11)
    ($P10) = rx1759_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1759_pos, "")
    rx1759_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1761_done
  rxcap_1761_fail:
    goto rx1759_fail
  rxcap_1761_done:
  # rx subrule "O" subtype=capture negate=
    rx1759_cur."!cursor_pos"(rx1759_pos)
    $P10 = rx1759_cur."O"("%relational, :pirop<isne ISs>")
    unless $P10, rx1759_fail
    rx1759_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1759_pos = $P10."pos"()
  # rx pass
    rx1759_cur."!cursor_pass"(rx1759_pos, "infix:sym<ne>")
    if_null rx1759_debug, debug_1328
    rx1759_cur."!cursor_debug"("PASS", "infix:sym<ne>", " at pos=", rx1759_pos)
  debug_1328:
    .return (rx1759_cur)
  rx1759_restart:
.annotate 'line', 10
    if_null rx1759_debug, debug_1329
    rx1759_cur."!cursor_debug"("NEXT", "infix:sym<ne>")
  debug_1329:
  rx1759_fail:
    (rx1759_rep, rx1759_pos, $I10, $P10) = rx1759_cur."!mark_fail"(0)
    lt rx1759_pos, -1, rx1759_done
    eq rx1759_pos, -1, rx1759_fail
    jump $I10
  rx1759_done:
    rx1759_cur."!cursor_fail"()
    if_null rx1759_debug, debug_1330
    rx1759_cur."!cursor_debug"("FAIL", "infix:sym<ne>")
  debug_1330:
    .return (rx1759_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ne>"  :subid("344_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1763 = self."!PREFIX__!subrule"("O", "ne")
    new $P1764, "ResizablePMCArray"
    push $P1764, $P1763
    .return ($P1764)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<le>"  :subid("345_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1766_tgt
    .local int rx1766_pos
    .local int rx1766_off
    .local int rx1766_eos
    .local int rx1766_rep
    .local pmc rx1766_cur
    .local pmc rx1766_debug
    (rx1766_cur, rx1766_pos, rx1766_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1766_cur
    .local pmc match
    .lex "$/", match
    length rx1766_eos, rx1766_tgt
    gt rx1766_pos, rx1766_eos, rx1766_done
    set rx1766_off, 0
    lt rx1766_pos, 2, rx1766_start
    sub rx1766_off, rx1766_pos, 1
    substr rx1766_tgt, rx1766_tgt, rx1766_off
  rx1766_start:
    eq $I10, 1, rx1766_restart
    if_null rx1766_debug, debug_1331
    rx1766_cur."!cursor_debug"("START", "infix:sym<le>")
  debug_1331:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1767_done
    goto rxscan1767_scan
  rxscan1767_loop:
    (rx1766_pos) = rx1766_cur."from"()
    inc rx1766_pos
    rx1766_cur."!cursor_from"(rx1766_pos)
    ge rx1766_pos, rx1766_eos, rxscan1767_done
  rxscan1767_scan:
    set_addr $I10, rxscan1767_loop
    rx1766_cur."!mark_push"(0, rx1766_pos, $I10)
  rxscan1767_done:
.annotate 'line', 685
  # rx subcapture "sym"
    set_addr $I10, rxcap_1768_fail
    rx1766_cur."!mark_push"(0, rx1766_pos, $I10)
  # rx literal  "le"
    add $I11, rx1766_pos, 2
    gt $I11, rx1766_eos, rx1766_fail
    sub $I11, rx1766_pos, rx1766_off
    substr $S10, rx1766_tgt, $I11, 2
    ne $S10, "le", rx1766_fail
    add rx1766_pos, 2
    set_addr $I10, rxcap_1768_fail
    ($I12, $I11) = rx1766_cur."!mark_peek"($I10)
    rx1766_cur."!cursor_pos"($I11)
    ($P10) = rx1766_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1766_pos, "")
    rx1766_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1768_done
  rxcap_1768_fail:
    goto rx1766_fail
  rxcap_1768_done:
  # rx subrule "O" subtype=capture negate=
    rx1766_cur."!cursor_pos"(rx1766_pos)
    $P10 = rx1766_cur."O"("%relational, :pirop<isle ISs>")
    unless $P10, rx1766_fail
    rx1766_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1766_pos = $P10."pos"()
  # rx pass
    rx1766_cur."!cursor_pass"(rx1766_pos, "infix:sym<le>")
    if_null rx1766_debug, debug_1332
    rx1766_cur."!cursor_debug"("PASS", "infix:sym<le>", " at pos=", rx1766_pos)
  debug_1332:
    .return (rx1766_cur)
  rx1766_restart:
.annotate 'line', 10
    if_null rx1766_debug, debug_1333
    rx1766_cur."!cursor_debug"("NEXT", "infix:sym<le>")
  debug_1333:
  rx1766_fail:
    (rx1766_rep, rx1766_pos, $I10, $P10) = rx1766_cur."!mark_fail"(0)
    lt rx1766_pos, -1, rx1766_done
    eq rx1766_pos, -1, rx1766_fail
    jump $I10
  rx1766_done:
    rx1766_cur."!cursor_fail"()
    if_null rx1766_debug, debug_1334
    rx1766_cur."!cursor_debug"("FAIL", "infix:sym<le>")
  debug_1334:
    .return (rx1766_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<le>"  :subid("346_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1770 = self."!PREFIX__!subrule"("O", "le")
    new $P1771, "ResizablePMCArray"
    push $P1771, $P1770
    .return ($P1771)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ge>"  :subid("347_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1773_tgt
    .local int rx1773_pos
    .local int rx1773_off
    .local int rx1773_eos
    .local int rx1773_rep
    .local pmc rx1773_cur
    .local pmc rx1773_debug
    (rx1773_cur, rx1773_pos, rx1773_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1773_cur
    .local pmc match
    .lex "$/", match
    length rx1773_eos, rx1773_tgt
    gt rx1773_pos, rx1773_eos, rx1773_done
    set rx1773_off, 0
    lt rx1773_pos, 2, rx1773_start
    sub rx1773_off, rx1773_pos, 1
    substr rx1773_tgt, rx1773_tgt, rx1773_off
  rx1773_start:
    eq $I10, 1, rx1773_restart
    if_null rx1773_debug, debug_1335
    rx1773_cur."!cursor_debug"("START", "infix:sym<ge>")
  debug_1335:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1774_done
    goto rxscan1774_scan
  rxscan1774_loop:
    (rx1773_pos) = rx1773_cur."from"()
    inc rx1773_pos
    rx1773_cur."!cursor_from"(rx1773_pos)
    ge rx1773_pos, rx1773_eos, rxscan1774_done
  rxscan1774_scan:
    set_addr $I10, rxscan1774_loop
    rx1773_cur."!mark_push"(0, rx1773_pos, $I10)
  rxscan1774_done:
.annotate 'line', 686
  # rx subcapture "sym"
    set_addr $I10, rxcap_1775_fail
    rx1773_cur."!mark_push"(0, rx1773_pos, $I10)
  # rx literal  "ge"
    add $I11, rx1773_pos, 2
    gt $I11, rx1773_eos, rx1773_fail
    sub $I11, rx1773_pos, rx1773_off
    substr $S10, rx1773_tgt, $I11, 2
    ne $S10, "ge", rx1773_fail
    add rx1773_pos, 2
    set_addr $I10, rxcap_1775_fail
    ($I12, $I11) = rx1773_cur."!mark_peek"($I10)
    rx1773_cur."!cursor_pos"($I11)
    ($P10) = rx1773_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1773_pos, "")
    rx1773_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1775_done
  rxcap_1775_fail:
    goto rx1773_fail
  rxcap_1775_done:
  # rx subrule "O" subtype=capture negate=
    rx1773_cur."!cursor_pos"(rx1773_pos)
    $P10 = rx1773_cur."O"("%relational, :pirop<isge ISs>")
    unless $P10, rx1773_fail
    rx1773_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1773_pos = $P10."pos"()
  # rx pass
    rx1773_cur."!cursor_pass"(rx1773_pos, "infix:sym<ge>")
    if_null rx1773_debug, debug_1336
    rx1773_cur."!cursor_debug"("PASS", "infix:sym<ge>", " at pos=", rx1773_pos)
  debug_1336:
    .return (rx1773_cur)
  rx1773_restart:
.annotate 'line', 10
    if_null rx1773_debug, debug_1337
    rx1773_cur."!cursor_debug"("NEXT", "infix:sym<ge>")
  debug_1337:
  rx1773_fail:
    (rx1773_rep, rx1773_pos, $I10, $P10) = rx1773_cur."!mark_fail"(0)
    lt rx1773_pos, -1, rx1773_done
    eq rx1773_pos, -1, rx1773_fail
    jump $I10
  rx1773_done:
    rx1773_cur."!cursor_fail"()
    if_null rx1773_debug, debug_1338
    rx1773_cur."!cursor_debug"("FAIL", "infix:sym<ge>")
  debug_1338:
    .return (rx1773_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ge>"  :subid("348_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1777 = self."!PREFIX__!subrule"("O", "ge")
    new $P1778, "ResizablePMCArray"
    push $P1778, $P1777
    .return ($P1778)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<lt>"  :subid("349_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1780_tgt
    .local int rx1780_pos
    .local int rx1780_off
    .local int rx1780_eos
    .local int rx1780_rep
    .local pmc rx1780_cur
    .local pmc rx1780_debug
    (rx1780_cur, rx1780_pos, rx1780_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1780_cur
    .local pmc match
    .lex "$/", match
    length rx1780_eos, rx1780_tgt
    gt rx1780_pos, rx1780_eos, rx1780_done
    set rx1780_off, 0
    lt rx1780_pos, 2, rx1780_start
    sub rx1780_off, rx1780_pos, 1
    substr rx1780_tgt, rx1780_tgt, rx1780_off
  rx1780_start:
    eq $I10, 1, rx1780_restart
    if_null rx1780_debug, debug_1339
    rx1780_cur."!cursor_debug"("START", "infix:sym<lt>")
  debug_1339:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1781_done
    goto rxscan1781_scan
  rxscan1781_loop:
    (rx1780_pos) = rx1780_cur."from"()
    inc rx1780_pos
    rx1780_cur."!cursor_from"(rx1780_pos)
    ge rx1780_pos, rx1780_eos, rxscan1781_done
  rxscan1781_scan:
    set_addr $I10, rxscan1781_loop
    rx1780_cur."!mark_push"(0, rx1780_pos, $I10)
  rxscan1781_done:
.annotate 'line', 687
  # rx subcapture "sym"
    set_addr $I10, rxcap_1782_fail
    rx1780_cur."!mark_push"(0, rx1780_pos, $I10)
  # rx literal  "lt"
    add $I11, rx1780_pos, 2
    gt $I11, rx1780_eos, rx1780_fail
    sub $I11, rx1780_pos, rx1780_off
    substr $S10, rx1780_tgt, $I11, 2
    ne $S10, "lt", rx1780_fail
    add rx1780_pos, 2
    set_addr $I10, rxcap_1782_fail
    ($I12, $I11) = rx1780_cur."!mark_peek"($I10)
    rx1780_cur."!cursor_pos"($I11)
    ($P10) = rx1780_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1780_pos, "")
    rx1780_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1782_done
  rxcap_1782_fail:
    goto rx1780_fail
  rxcap_1782_done:
  # rx subrule "O" subtype=capture negate=
    rx1780_cur."!cursor_pos"(rx1780_pos)
    $P10 = rx1780_cur."O"("%relational, :pirop<islt ISs>")
    unless $P10, rx1780_fail
    rx1780_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1780_pos = $P10."pos"()
  # rx pass
    rx1780_cur."!cursor_pass"(rx1780_pos, "infix:sym<lt>")
    if_null rx1780_debug, debug_1340
    rx1780_cur."!cursor_debug"("PASS", "infix:sym<lt>", " at pos=", rx1780_pos)
  debug_1340:
    .return (rx1780_cur)
  rx1780_restart:
.annotate 'line', 10
    if_null rx1780_debug, debug_1341
    rx1780_cur."!cursor_debug"("NEXT", "infix:sym<lt>")
  debug_1341:
  rx1780_fail:
    (rx1780_rep, rx1780_pos, $I10, $P10) = rx1780_cur."!mark_fail"(0)
    lt rx1780_pos, -1, rx1780_done
    eq rx1780_pos, -1, rx1780_fail
    jump $I10
  rx1780_done:
    rx1780_cur."!cursor_fail"()
    if_null rx1780_debug, debug_1342
    rx1780_cur."!cursor_debug"("FAIL", "infix:sym<lt>")
  debug_1342:
    .return (rx1780_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<lt>"  :subid("350_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1784 = self."!PREFIX__!subrule"("O", "lt")
    new $P1785, "ResizablePMCArray"
    push $P1785, $P1784
    .return ($P1785)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<gt>"  :subid("351_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1787_tgt
    .local int rx1787_pos
    .local int rx1787_off
    .local int rx1787_eos
    .local int rx1787_rep
    .local pmc rx1787_cur
    .local pmc rx1787_debug
    (rx1787_cur, rx1787_pos, rx1787_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1787_cur
    .local pmc match
    .lex "$/", match
    length rx1787_eos, rx1787_tgt
    gt rx1787_pos, rx1787_eos, rx1787_done
    set rx1787_off, 0
    lt rx1787_pos, 2, rx1787_start
    sub rx1787_off, rx1787_pos, 1
    substr rx1787_tgt, rx1787_tgt, rx1787_off
  rx1787_start:
    eq $I10, 1, rx1787_restart
    if_null rx1787_debug, debug_1343
    rx1787_cur."!cursor_debug"("START", "infix:sym<gt>")
  debug_1343:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1788_done
    goto rxscan1788_scan
  rxscan1788_loop:
    (rx1787_pos) = rx1787_cur."from"()
    inc rx1787_pos
    rx1787_cur."!cursor_from"(rx1787_pos)
    ge rx1787_pos, rx1787_eos, rxscan1788_done
  rxscan1788_scan:
    set_addr $I10, rxscan1788_loop
    rx1787_cur."!mark_push"(0, rx1787_pos, $I10)
  rxscan1788_done:
.annotate 'line', 688
  # rx subcapture "sym"
    set_addr $I10, rxcap_1789_fail
    rx1787_cur."!mark_push"(0, rx1787_pos, $I10)
  # rx literal  "gt"
    add $I11, rx1787_pos, 2
    gt $I11, rx1787_eos, rx1787_fail
    sub $I11, rx1787_pos, rx1787_off
    substr $S10, rx1787_tgt, $I11, 2
    ne $S10, "gt", rx1787_fail
    add rx1787_pos, 2
    set_addr $I10, rxcap_1789_fail
    ($I12, $I11) = rx1787_cur."!mark_peek"($I10)
    rx1787_cur."!cursor_pos"($I11)
    ($P10) = rx1787_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1787_pos, "")
    rx1787_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1789_done
  rxcap_1789_fail:
    goto rx1787_fail
  rxcap_1789_done:
  # rx subrule "O" subtype=capture negate=
    rx1787_cur."!cursor_pos"(rx1787_pos)
    $P10 = rx1787_cur."O"("%relational, :pirop<isgt ISs>")
    unless $P10, rx1787_fail
    rx1787_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1787_pos = $P10."pos"()
  # rx pass
    rx1787_cur."!cursor_pass"(rx1787_pos, "infix:sym<gt>")
    if_null rx1787_debug, debug_1344
    rx1787_cur."!cursor_debug"("PASS", "infix:sym<gt>", " at pos=", rx1787_pos)
  debug_1344:
    .return (rx1787_cur)
  rx1787_restart:
.annotate 'line', 10
    if_null rx1787_debug, debug_1345
    rx1787_cur."!cursor_debug"("NEXT", "infix:sym<gt>")
  debug_1345:
  rx1787_fail:
    (rx1787_rep, rx1787_pos, $I10, $P10) = rx1787_cur."!mark_fail"(0)
    lt rx1787_pos, -1, rx1787_done
    eq rx1787_pos, -1, rx1787_fail
    jump $I10
  rx1787_done:
    rx1787_cur."!cursor_fail"()
    if_null rx1787_debug, debug_1346
    rx1787_cur."!cursor_debug"("FAIL", "infix:sym<gt>")
  debug_1346:
    .return (rx1787_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<gt>"  :subid("352_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1791 = self."!PREFIX__!subrule"("O", "gt")
    new $P1792, "ResizablePMCArray"
    push $P1792, $P1791
    .return ($P1792)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=:=>"  :subid("353_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1794_tgt
    .local int rx1794_pos
    .local int rx1794_off
    .local int rx1794_eos
    .local int rx1794_rep
    .local pmc rx1794_cur
    .local pmc rx1794_debug
    (rx1794_cur, rx1794_pos, rx1794_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1794_cur
    .local pmc match
    .lex "$/", match
    length rx1794_eos, rx1794_tgt
    gt rx1794_pos, rx1794_eos, rx1794_done
    set rx1794_off, 0
    lt rx1794_pos, 2, rx1794_start
    sub rx1794_off, rx1794_pos, 1
    substr rx1794_tgt, rx1794_tgt, rx1794_off
  rx1794_start:
    eq $I10, 1, rx1794_restart
    if_null rx1794_debug, debug_1347
    rx1794_cur."!cursor_debug"("START", "infix:sym<=:=>")
  debug_1347:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1795_done
    goto rxscan1795_scan
  rxscan1795_loop:
    (rx1794_pos) = rx1794_cur."from"()
    inc rx1794_pos
    rx1794_cur."!cursor_from"(rx1794_pos)
    ge rx1794_pos, rx1794_eos, rxscan1795_done
  rxscan1795_scan:
    set_addr $I10, rxscan1795_loop
    rx1794_cur."!mark_push"(0, rx1794_pos, $I10)
  rxscan1795_done:
.annotate 'line', 689
  # rx subcapture "sym"
    set_addr $I10, rxcap_1796_fail
    rx1794_cur."!mark_push"(0, rx1794_pos, $I10)
  # rx literal  "=:="
    add $I11, rx1794_pos, 3
    gt $I11, rx1794_eos, rx1794_fail
    sub $I11, rx1794_pos, rx1794_off
    substr $S10, rx1794_tgt, $I11, 3
    ne $S10, "=:=", rx1794_fail
    add rx1794_pos, 3
    set_addr $I10, rxcap_1796_fail
    ($I12, $I11) = rx1794_cur."!mark_peek"($I10)
    rx1794_cur."!cursor_pos"($I11)
    ($P10) = rx1794_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1794_pos, "")
    rx1794_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1796_done
  rxcap_1796_fail:
    goto rx1794_fail
  rxcap_1796_done:
  # rx subrule "O" subtype=capture negate=
    rx1794_cur."!cursor_pos"(rx1794_pos)
    $P10 = rx1794_cur."O"("%relational, :pirop<issame>")
    unless $P10, rx1794_fail
    rx1794_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1794_pos = $P10."pos"()
  # rx pass
    rx1794_cur."!cursor_pass"(rx1794_pos, "infix:sym<=:=>")
    if_null rx1794_debug, debug_1348
    rx1794_cur."!cursor_debug"("PASS", "infix:sym<=:=>", " at pos=", rx1794_pos)
  debug_1348:
    .return (rx1794_cur)
  rx1794_restart:
.annotate 'line', 10
    if_null rx1794_debug, debug_1349
    rx1794_cur."!cursor_debug"("NEXT", "infix:sym<=:=>")
  debug_1349:
  rx1794_fail:
    (rx1794_rep, rx1794_pos, $I10, $P10) = rx1794_cur."!mark_fail"(0)
    lt rx1794_pos, -1, rx1794_done
    eq rx1794_pos, -1, rx1794_fail
    jump $I10
  rx1794_done:
    rx1794_cur."!cursor_fail"()
    if_null rx1794_debug, debug_1350
    rx1794_cur."!cursor_debug"("FAIL", "infix:sym<=:=>")
  debug_1350:
    .return (rx1794_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=:=>"  :subid("354_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1798 = self."!PREFIX__!subrule"("O", "=:=")
    new $P1799, "ResizablePMCArray"
    push $P1799, $P1798
    .return ($P1799)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~~>"  :subid("355_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1801_tgt
    .local int rx1801_pos
    .local int rx1801_off
    .local int rx1801_eos
    .local int rx1801_rep
    .local pmc rx1801_cur
    .local pmc rx1801_debug
    (rx1801_cur, rx1801_pos, rx1801_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1801_cur
    .local pmc match
    .lex "$/", match
    length rx1801_eos, rx1801_tgt
    gt rx1801_pos, rx1801_eos, rx1801_done
    set rx1801_off, 0
    lt rx1801_pos, 2, rx1801_start
    sub rx1801_off, rx1801_pos, 1
    substr rx1801_tgt, rx1801_tgt, rx1801_off
  rx1801_start:
    eq $I10, 1, rx1801_restart
    if_null rx1801_debug, debug_1351
    rx1801_cur."!cursor_debug"("START", "infix:sym<~~>")
  debug_1351:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1802_done
    goto rxscan1802_scan
  rxscan1802_loop:
    (rx1801_pos) = rx1801_cur."from"()
    inc rx1801_pos
    rx1801_cur."!cursor_from"(rx1801_pos)
    ge rx1801_pos, rx1801_eos, rxscan1802_done
  rxscan1802_scan:
    set_addr $I10, rxscan1802_loop
    rx1801_cur."!mark_push"(0, rx1801_pos, $I10)
  rxscan1802_done:
.annotate 'line', 690
  # rx subcapture "sym"
    set_addr $I10, rxcap_1803_fail
    rx1801_cur."!mark_push"(0, rx1801_pos, $I10)
  # rx literal  "~~"
    add $I11, rx1801_pos, 2
    gt $I11, rx1801_eos, rx1801_fail
    sub $I11, rx1801_pos, rx1801_off
    substr $S10, rx1801_tgt, $I11, 2
    ne $S10, "~~", rx1801_fail
    add rx1801_pos, 2
    set_addr $I10, rxcap_1803_fail
    ($I12, $I11) = rx1801_cur."!mark_peek"($I10)
    rx1801_cur."!cursor_pos"($I11)
    ($P10) = rx1801_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1801_pos, "")
    rx1801_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1803_done
  rxcap_1803_fail:
    goto rx1801_fail
  rxcap_1803_done:
  # rx subrule "O" subtype=capture negate=
    rx1801_cur."!cursor_pos"(rx1801_pos)
    $P10 = rx1801_cur."O"("%relational, :reducecheck<smartmatch>")
    unless $P10, rx1801_fail
    rx1801_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1801_pos = $P10."pos"()
  # rx pass
    rx1801_cur."!cursor_pass"(rx1801_pos, "infix:sym<~~>")
    if_null rx1801_debug, debug_1352
    rx1801_cur."!cursor_debug"("PASS", "infix:sym<~~>", " at pos=", rx1801_pos)
  debug_1352:
    .return (rx1801_cur)
  rx1801_restart:
.annotate 'line', 10
    if_null rx1801_debug, debug_1353
    rx1801_cur."!cursor_debug"("NEXT", "infix:sym<~~>")
  debug_1353:
  rx1801_fail:
    (rx1801_rep, rx1801_pos, $I10, $P10) = rx1801_cur."!mark_fail"(0)
    lt rx1801_pos, -1, rx1801_done
    eq rx1801_pos, -1, rx1801_fail
    jump $I10
  rx1801_done:
    rx1801_cur."!cursor_fail"()
    if_null rx1801_debug, debug_1354
    rx1801_cur."!cursor_debug"("FAIL", "infix:sym<~~>")
  debug_1354:
    .return (rx1801_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~~>"  :subid("356_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1805 = self."!PREFIX__!subrule"("O", "~~")
    new $P1806, "ResizablePMCArray"
    push $P1806, $P1805
    .return ($P1806)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<&&>"  :subid("357_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1808_tgt
    .local int rx1808_pos
    .local int rx1808_off
    .local int rx1808_eos
    .local int rx1808_rep
    .local pmc rx1808_cur
    .local pmc rx1808_debug
    (rx1808_cur, rx1808_pos, rx1808_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1808_cur
    .local pmc match
    .lex "$/", match
    length rx1808_eos, rx1808_tgt
    gt rx1808_pos, rx1808_eos, rx1808_done
    set rx1808_off, 0
    lt rx1808_pos, 2, rx1808_start
    sub rx1808_off, rx1808_pos, 1
    substr rx1808_tgt, rx1808_tgt, rx1808_off
  rx1808_start:
    eq $I10, 1, rx1808_restart
    if_null rx1808_debug, debug_1355
    rx1808_cur."!cursor_debug"("START", "infix:sym<&&>")
  debug_1355:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1809_done
    goto rxscan1809_scan
  rxscan1809_loop:
    (rx1808_pos) = rx1808_cur."from"()
    inc rx1808_pos
    rx1808_cur."!cursor_from"(rx1808_pos)
    ge rx1808_pos, rx1808_eos, rxscan1809_done
  rxscan1809_scan:
    set_addr $I10, rxscan1809_loop
    rx1808_cur."!mark_push"(0, rx1808_pos, $I10)
  rxscan1809_done:
.annotate 'line', 692
  # rx subcapture "sym"
    set_addr $I10, rxcap_1810_fail
    rx1808_cur."!mark_push"(0, rx1808_pos, $I10)
  # rx literal  "&&"
    add $I11, rx1808_pos, 2
    gt $I11, rx1808_eos, rx1808_fail
    sub $I11, rx1808_pos, rx1808_off
    substr $S10, rx1808_tgt, $I11, 2
    ne $S10, "&&", rx1808_fail
    add rx1808_pos, 2
    set_addr $I10, rxcap_1810_fail
    ($I12, $I11) = rx1808_cur."!mark_peek"($I10)
    rx1808_cur."!cursor_pos"($I11)
    ($P10) = rx1808_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1808_pos, "")
    rx1808_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1810_done
  rxcap_1810_fail:
    goto rx1808_fail
  rxcap_1810_done:
  # rx subrule "O" subtype=capture negate=
    rx1808_cur."!cursor_pos"(rx1808_pos)
    $P10 = rx1808_cur."O"("%tight_and, :pasttype<if>")
    unless $P10, rx1808_fail
    rx1808_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1808_pos = $P10."pos"()
  # rx pass
    rx1808_cur."!cursor_pass"(rx1808_pos, "infix:sym<&&>")
    if_null rx1808_debug, debug_1356
    rx1808_cur."!cursor_debug"("PASS", "infix:sym<&&>", " at pos=", rx1808_pos)
  debug_1356:
    .return (rx1808_cur)
  rx1808_restart:
.annotate 'line', 10
    if_null rx1808_debug, debug_1357
    rx1808_cur."!cursor_debug"("NEXT", "infix:sym<&&>")
  debug_1357:
  rx1808_fail:
    (rx1808_rep, rx1808_pos, $I10, $P10) = rx1808_cur."!mark_fail"(0)
    lt rx1808_pos, -1, rx1808_done
    eq rx1808_pos, -1, rx1808_fail
    jump $I10
  rx1808_done:
    rx1808_cur."!cursor_fail"()
    if_null rx1808_debug, debug_1358
    rx1808_cur."!cursor_debug"("FAIL", "infix:sym<&&>")
  debug_1358:
    .return (rx1808_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<&&>"  :subid("358_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1812 = self."!PREFIX__!subrule"("O", "&&")
    new $P1813, "ResizablePMCArray"
    push $P1813, $P1812
    .return ($P1813)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<||>"  :subid("359_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1815_tgt
    .local int rx1815_pos
    .local int rx1815_off
    .local int rx1815_eos
    .local int rx1815_rep
    .local pmc rx1815_cur
    .local pmc rx1815_debug
    (rx1815_cur, rx1815_pos, rx1815_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1815_cur
    .local pmc match
    .lex "$/", match
    length rx1815_eos, rx1815_tgt
    gt rx1815_pos, rx1815_eos, rx1815_done
    set rx1815_off, 0
    lt rx1815_pos, 2, rx1815_start
    sub rx1815_off, rx1815_pos, 1
    substr rx1815_tgt, rx1815_tgt, rx1815_off
  rx1815_start:
    eq $I10, 1, rx1815_restart
    if_null rx1815_debug, debug_1359
    rx1815_cur."!cursor_debug"("START", "infix:sym<||>")
  debug_1359:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1816_done
    goto rxscan1816_scan
  rxscan1816_loop:
    (rx1815_pos) = rx1815_cur."from"()
    inc rx1815_pos
    rx1815_cur."!cursor_from"(rx1815_pos)
    ge rx1815_pos, rx1815_eos, rxscan1816_done
  rxscan1816_scan:
    set_addr $I10, rxscan1816_loop
    rx1815_cur."!mark_push"(0, rx1815_pos, $I10)
  rxscan1816_done:
.annotate 'line', 694
  # rx subcapture "sym"
    set_addr $I10, rxcap_1817_fail
    rx1815_cur."!mark_push"(0, rx1815_pos, $I10)
  # rx literal  "||"
    add $I11, rx1815_pos, 2
    gt $I11, rx1815_eos, rx1815_fail
    sub $I11, rx1815_pos, rx1815_off
    substr $S10, rx1815_tgt, $I11, 2
    ne $S10, "||", rx1815_fail
    add rx1815_pos, 2
    set_addr $I10, rxcap_1817_fail
    ($I12, $I11) = rx1815_cur."!mark_peek"($I10)
    rx1815_cur."!cursor_pos"($I11)
    ($P10) = rx1815_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1815_pos, "")
    rx1815_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1817_done
  rxcap_1817_fail:
    goto rx1815_fail
  rxcap_1817_done:
  # rx subrule "O" subtype=capture negate=
    rx1815_cur."!cursor_pos"(rx1815_pos)
    $P10 = rx1815_cur."O"("%tight_or, :pasttype<unless>")
    unless $P10, rx1815_fail
    rx1815_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1815_pos = $P10."pos"()
  # rx pass
    rx1815_cur."!cursor_pass"(rx1815_pos, "infix:sym<||>")
    if_null rx1815_debug, debug_1360
    rx1815_cur."!cursor_debug"("PASS", "infix:sym<||>", " at pos=", rx1815_pos)
  debug_1360:
    .return (rx1815_cur)
  rx1815_restart:
.annotate 'line', 10
    if_null rx1815_debug, debug_1361
    rx1815_cur."!cursor_debug"("NEXT", "infix:sym<||>")
  debug_1361:
  rx1815_fail:
    (rx1815_rep, rx1815_pos, $I10, $P10) = rx1815_cur."!mark_fail"(0)
    lt rx1815_pos, -1, rx1815_done
    eq rx1815_pos, -1, rx1815_fail
    jump $I10
  rx1815_done:
    rx1815_cur."!cursor_fail"()
    if_null rx1815_debug, debug_1362
    rx1815_cur."!cursor_debug"("FAIL", "infix:sym<||>")
  debug_1362:
    .return (rx1815_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<||>"  :subid("360_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1819 = self."!PREFIX__!subrule"("O", "||")
    new $P1820, "ResizablePMCArray"
    push $P1820, $P1819
    .return ($P1820)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<//>"  :subid("361_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1822_tgt
    .local int rx1822_pos
    .local int rx1822_off
    .local int rx1822_eos
    .local int rx1822_rep
    .local pmc rx1822_cur
    .local pmc rx1822_debug
    (rx1822_cur, rx1822_pos, rx1822_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1822_cur
    .local pmc match
    .lex "$/", match
    length rx1822_eos, rx1822_tgt
    gt rx1822_pos, rx1822_eos, rx1822_done
    set rx1822_off, 0
    lt rx1822_pos, 2, rx1822_start
    sub rx1822_off, rx1822_pos, 1
    substr rx1822_tgt, rx1822_tgt, rx1822_off
  rx1822_start:
    eq $I10, 1, rx1822_restart
    if_null rx1822_debug, debug_1363
    rx1822_cur."!cursor_debug"("START", "infix:sym<//>")
  debug_1363:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1823_done
    goto rxscan1823_scan
  rxscan1823_loop:
    (rx1822_pos) = rx1822_cur."from"()
    inc rx1822_pos
    rx1822_cur."!cursor_from"(rx1822_pos)
    ge rx1822_pos, rx1822_eos, rxscan1823_done
  rxscan1823_scan:
    set_addr $I10, rxscan1823_loop
    rx1822_cur."!mark_push"(0, rx1822_pos, $I10)
  rxscan1823_done:
.annotate 'line', 695
  # rx subcapture "sym"
    set_addr $I10, rxcap_1824_fail
    rx1822_cur."!mark_push"(0, rx1822_pos, $I10)
  # rx literal  "//"
    add $I11, rx1822_pos, 2
    gt $I11, rx1822_eos, rx1822_fail
    sub $I11, rx1822_pos, rx1822_off
    substr $S10, rx1822_tgt, $I11, 2
    ne $S10, "//", rx1822_fail
    add rx1822_pos, 2
    set_addr $I10, rxcap_1824_fail
    ($I12, $I11) = rx1822_cur."!mark_peek"($I10)
    rx1822_cur."!cursor_pos"($I11)
    ($P10) = rx1822_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1822_pos, "")
    rx1822_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1824_done
  rxcap_1824_fail:
    goto rx1822_fail
  rxcap_1824_done:
  # rx subrule "O" subtype=capture negate=
    rx1822_cur."!cursor_pos"(rx1822_pos)
    $P10 = rx1822_cur."O"("%tight_or, :pasttype<def_or>")
    unless $P10, rx1822_fail
    rx1822_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1822_pos = $P10."pos"()
  # rx pass
    rx1822_cur."!cursor_pass"(rx1822_pos, "infix:sym<//>")
    if_null rx1822_debug, debug_1364
    rx1822_cur."!cursor_debug"("PASS", "infix:sym<//>", " at pos=", rx1822_pos)
  debug_1364:
    .return (rx1822_cur)
  rx1822_restart:
.annotate 'line', 10
    if_null rx1822_debug, debug_1365
    rx1822_cur."!cursor_debug"("NEXT", "infix:sym<//>")
  debug_1365:
  rx1822_fail:
    (rx1822_rep, rx1822_pos, $I10, $P10) = rx1822_cur."!mark_fail"(0)
    lt rx1822_pos, -1, rx1822_done
    eq rx1822_pos, -1, rx1822_fail
    jump $I10
  rx1822_done:
    rx1822_cur."!cursor_fail"()
    if_null rx1822_debug, debug_1366
    rx1822_cur."!cursor_debug"("FAIL", "infix:sym<//>")
  debug_1366:
    .return (rx1822_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<//>"  :subid("362_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1826 = self."!PREFIX__!subrule"("O", "//")
    new $P1827, "ResizablePMCArray"
    push $P1827, $P1826
    .return ($P1827)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<?? !!>"  :subid("363_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1829_tgt
    .local int rx1829_pos
    .local int rx1829_off
    .local int rx1829_eos
    .local int rx1829_rep
    .local pmc rx1829_cur
    .local pmc rx1829_debug
    (rx1829_cur, rx1829_pos, rx1829_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1829_cur
    .local pmc match
    .lex "$/", match
    length rx1829_eos, rx1829_tgt
    gt rx1829_pos, rx1829_eos, rx1829_done
    set rx1829_off, 0
    lt rx1829_pos, 2, rx1829_start
    sub rx1829_off, rx1829_pos, 1
    substr rx1829_tgt, rx1829_tgt, rx1829_off
  rx1829_start:
    eq $I10, 1, rx1829_restart
    if_null rx1829_debug, debug_1367
    rx1829_cur."!cursor_debug"("START", "infix:sym<?? !!>")
  debug_1367:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1830_done
    goto rxscan1830_scan
  rxscan1830_loop:
    (rx1829_pos) = rx1829_cur."from"()
    inc rx1829_pos
    rx1829_cur."!cursor_from"(rx1829_pos)
    ge rx1829_pos, rx1829_eos, rxscan1830_done
  rxscan1830_scan:
    set_addr $I10, rxscan1830_loop
    rx1829_cur."!mark_push"(0, rx1829_pos, $I10)
  rxscan1830_done:
.annotate 'line', 698
  # rx literal  "??"
    add $I11, rx1829_pos, 2
    gt $I11, rx1829_eos, rx1829_fail
    sub $I11, rx1829_pos, rx1829_off
    substr $S10, rx1829_tgt, $I11, 2
    ne $S10, "??", rx1829_fail
    add rx1829_pos, 2
.annotate 'line', 699
  # rx subrule "ws" subtype=method negate=
    rx1829_cur."!cursor_pos"(rx1829_pos)
    $P10 = rx1829_cur."ws"()
    unless $P10, rx1829_fail
    rx1829_pos = $P10."pos"()
.annotate 'line', 700
  # rx subrule "EXPR" subtype=capture negate=
    rx1829_cur."!cursor_pos"(rx1829_pos)
    $P10 = rx1829_cur."EXPR"("i=")
    unless $P10, rx1829_fail
    rx1829_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1829_pos = $P10."pos"()
.annotate 'line', 701
  # rx literal  "!!"
    add $I11, rx1829_pos, 2
    gt $I11, rx1829_eos, rx1829_fail
    sub $I11, rx1829_pos, rx1829_off
    substr $S10, rx1829_tgt, $I11, 2
    ne $S10, "!!", rx1829_fail
    add rx1829_pos, 2
.annotate 'line', 702
  # rx subrule "O" subtype=capture negate=
    rx1829_cur."!cursor_pos"(rx1829_pos)
    $P10 = rx1829_cur."O"("%conditional, :reducecheck<ternary>, :pasttype<if>")
    unless $P10, rx1829_fail
    rx1829_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1829_pos = $P10."pos"()
.annotate 'line', 697
  # rx pass
    rx1829_cur."!cursor_pass"(rx1829_pos, "infix:sym<?? !!>")
    if_null rx1829_debug, debug_1368
    rx1829_cur."!cursor_debug"("PASS", "infix:sym<?? !!>", " at pos=", rx1829_pos)
  debug_1368:
    .return (rx1829_cur)
  rx1829_restart:
.annotate 'line', 10
    if_null rx1829_debug, debug_1369
    rx1829_cur."!cursor_debug"("NEXT", "infix:sym<?? !!>")
  debug_1369:
  rx1829_fail:
    (rx1829_rep, rx1829_pos, $I10, $P10) = rx1829_cur."!mark_fail"(0)
    lt rx1829_pos, -1, rx1829_done
    eq rx1829_pos, -1, rx1829_fail
    jump $I10
  rx1829_done:
    rx1829_cur."!cursor_fail"()
    if_null rx1829_debug, debug_1370
    rx1829_cur."!cursor_debug"("FAIL", "infix:sym<?? !!>")
  debug_1370:
    .return (rx1829_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<?? !!>"  :subid("364_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1832 = self."!PREFIX__!subrule"("ws", "??")
    new $P1833, "ResizablePMCArray"
    push $P1833, $P1832
    .return ($P1833)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=>"  :subid("365_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1835_tgt
    .local int rx1835_pos
    .local int rx1835_off
    .local int rx1835_eos
    .local int rx1835_rep
    .local pmc rx1835_cur
    .local pmc rx1835_debug
    (rx1835_cur, rx1835_pos, rx1835_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1835_cur
    .local pmc match
    .lex "$/", match
    length rx1835_eos, rx1835_tgt
    gt rx1835_pos, rx1835_eos, rx1835_done
    set rx1835_off, 0
    lt rx1835_pos, 2, rx1835_start
    sub rx1835_off, rx1835_pos, 1
    substr rx1835_tgt, rx1835_tgt, rx1835_off
  rx1835_start:
    eq $I10, 1, rx1835_restart
    if_null rx1835_debug, debug_1371
    rx1835_cur."!cursor_debug"("START", "infix:sym<=>")
  debug_1371:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1836_done
    goto rxscan1836_scan
  rxscan1836_loop:
    (rx1835_pos) = rx1835_cur."from"()
    inc rx1835_pos
    rx1835_cur."!cursor_from"(rx1835_pos)
    ge rx1835_pos, rx1835_eos, rxscan1836_done
  rxscan1836_scan:
    set_addr $I10, rxscan1836_loop
    rx1835_cur."!mark_push"(0, rx1835_pos, $I10)
  rxscan1836_done:
.annotate 'line', 706
  # rx subcapture "sym"
    set_addr $I10, rxcap_1837_fail
    rx1835_cur."!mark_push"(0, rx1835_pos, $I10)
  # rx literal  "="
    add $I11, rx1835_pos, 1
    gt $I11, rx1835_eos, rx1835_fail
    sub $I11, rx1835_pos, rx1835_off
    ord $I11, rx1835_tgt, $I11
    ne $I11, 61, rx1835_fail
    add rx1835_pos, 1
    set_addr $I10, rxcap_1837_fail
    ($I12, $I11) = rx1835_cur."!mark_peek"($I10)
    rx1835_cur."!cursor_pos"($I11)
    ($P10) = rx1835_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1835_pos, "")
    rx1835_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1837_done
  rxcap_1837_fail:
    goto rx1835_fail
  rxcap_1837_done:
  # rx subrule "panic" subtype=method negate=
    rx1835_cur."!cursor_pos"(rx1835_pos)
    $P10 = rx1835_cur."panic"("Assignment (\"=\") not supported in NQP, use \":=\" instead")
    unless $P10, rx1835_fail
    rx1835_pos = $P10."pos"()
.annotate 'line', 705
  # rx pass
    rx1835_cur."!cursor_pass"(rx1835_pos, "infix:sym<=>")
    if_null rx1835_debug, debug_1372
    rx1835_cur."!cursor_debug"("PASS", "infix:sym<=>", " at pos=", rx1835_pos)
  debug_1372:
    .return (rx1835_cur)
  rx1835_restart:
.annotate 'line', 10
    if_null rx1835_debug, debug_1373
    rx1835_cur."!cursor_debug"("NEXT", "infix:sym<=>")
  debug_1373:
  rx1835_fail:
    (rx1835_rep, rx1835_pos, $I10, $P10) = rx1835_cur."!mark_fail"(0)
    lt rx1835_pos, -1, rx1835_done
    eq rx1835_pos, -1, rx1835_fail
    jump $I10
  rx1835_done:
    rx1835_cur."!cursor_fail"()
    if_null rx1835_debug, debug_1374
    rx1835_cur."!cursor_debug"("FAIL", "infix:sym<=>")
  debug_1374:
    .return (rx1835_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=>"  :subid("366_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1839 = self."!PREFIX__!subrule"("panic", "=")
    new $P1840, "ResizablePMCArray"
    push $P1840, $P1839
    .return ($P1840)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<:=>"  :subid("367_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1842_tgt
    .local int rx1842_pos
    .local int rx1842_off
    .local int rx1842_eos
    .local int rx1842_rep
    .local pmc rx1842_cur
    .local pmc rx1842_debug
    (rx1842_cur, rx1842_pos, rx1842_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1842_cur
    .local pmc match
    .lex "$/", match
    length rx1842_eos, rx1842_tgt
    gt rx1842_pos, rx1842_eos, rx1842_done
    set rx1842_off, 0
    lt rx1842_pos, 2, rx1842_start
    sub rx1842_off, rx1842_pos, 1
    substr rx1842_tgt, rx1842_tgt, rx1842_off
  rx1842_start:
    eq $I10, 1, rx1842_restart
    if_null rx1842_debug, debug_1375
    rx1842_cur."!cursor_debug"("START", "infix:sym<:=>")
  debug_1375:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1843_done
    goto rxscan1843_scan
  rxscan1843_loop:
    (rx1842_pos) = rx1842_cur."from"()
    inc rx1842_pos
    rx1842_cur."!cursor_from"(rx1842_pos)
    ge rx1842_pos, rx1842_eos, rxscan1843_done
  rxscan1843_scan:
    set_addr $I10, rxscan1843_loop
    rx1842_cur."!mark_push"(0, rx1842_pos, $I10)
  rxscan1843_done:
.annotate 'line', 708
  # rx subcapture "sym"
    set_addr $I10, rxcap_1844_fail
    rx1842_cur."!mark_push"(0, rx1842_pos, $I10)
  # rx literal  ":="
    add $I11, rx1842_pos, 2
    gt $I11, rx1842_eos, rx1842_fail
    sub $I11, rx1842_pos, rx1842_off
    substr $S10, rx1842_tgt, $I11, 2
    ne $S10, ":=", rx1842_fail
    add rx1842_pos, 2
    set_addr $I10, rxcap_1844_fail
    ($I12, $I11) = rx1842_cur."!mark_peek"($I10)
    rx1842_cur."!cursor_pos"($I11)
    ($P10) = rx1842_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1842_pos, "")
    rx1842_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1844_done
  rxcap_1844_fail:
    goto rx1842_fail
  rxcap_1844_done:
  # rx subrule "O" subtype=capture negate=
    rx1842_cur."!cursor_pos"(rx1842_pos)
    $P10 = rx1842_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx1842_fail
    rx1842_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1842_pos = $P10."pos"()
  # rx pass
    rx1842_cur."!cursor_pass"(rx1842_pos, "infix:sym<:=>")
    if_null rx1842_debug, debug_1376
    rx1842_cur."!cursor_debug"("PASS", "infix:sym<:=>", " at pos=", rx1842_pos)
  debug_1376:
    .return (rx1842_cur)
  rx1842_restart:
.annotate 'line', 10
    if_null rx1842_debug, debug_1377
    rx1842_cur."!cursor_debug"("NEXT", "infix:sym<:=>")
  debug_1377:
  rx1842_fail:
    (rx1842_rep, rx1842_pos, $I10, $P10) = rx1842_cur."!mark_fail"(0)
    lt rx1842_pos, -1, rx1842_done
    eq rx1842_pos, -1, rx1842_fail
    jump $I10
  rx1842_done:
    rx1842_cur."!cursor_fail"()
    if_null rx1842_debug, debug_1378
    rx1842_cur."!cursor_debug"("FAIL", "infix:sym<:=>")
  debug_1378:
    .return (rx1842_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<:=>"  :subid("368_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1846 = self."!PREFIX__!subrule"("O", ":=")
    new $P1847, "ResizablePMCArray"
    push $P1847, $P1846
    .return ($P1847)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<::=>"  :subid("369_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1849_tgt
    .local int rx1849_pos
    .local int rx1849_off
    .local int rx1849_eos
    .local int rx1849_rep
    .local pmc rx1849_cur
    .local pmc rx1849_debug
    (rx1849_cur, rx1849_pos, rx1849_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1849_cur
    .local pmc match
    .lex "$/", match
    length rx1849_eos, rx1849_tgt
    gt rx1849_pos, rx1849_eos, rx1849_done
    set rx1849_off, 0
    lt rx1849_pos, 2, rx1849_start
    sub rx1849_off, rx1849_pos, 1
    substr rx1849_tgt, rx1849_tgt, rx1849_off
  rx1849_start:
    eq $I10, 1, rx1849_restart
    if_null rx1849_debug, debug_1379
    rx1849_cur."!cursor_debug"("START", "infix:sym<::=>")
  debug_1379:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1850_done
    goto rxscan1850_scan
  rxscan1850_loop:
    (rx1849_pos) = rx1849_cur."from"()
    inc rx1849_pos
    rx1849_cur."!cursor_from"(rx1849_pos)
    ge rx1849_pos, rx1849_eos, rxscan1850_done
  rxscan1850_scan:
    set_addr $I10, rxscan1850_loop
    rx1849_cur."!mark_push"(0, rx1849_pos, $I10)
  rxscan1850_done:
.annotate 'line', 709
  # rx subcapture "sym"
    set_addr $I10, rxcap_1851_fail
    rx1849_cur."!mark_push"(0, rx1849_pos, $I10)
  # rx literal  "::="
    add $I11, rx1849_pos, 3
    gt $I11, rx1849_eos, rx1849_fail
    sub $I11, rx1849_pos, rx1849_off
    substr $S10, rx1849_tgt, $I11, 3
    ne $S10, "::=", rx1849_fail
    add rx1849_pos, 3
    set_addr $I10, rxcap_1851_fail
    ($I12, $I11) = rx1849_cur."!mark_peek"($I10)
    rx1849_cur."!cursor_pos"($I11)
    ($P10) = rx1849_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1849_pos, "")
    rx1849_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1851_done
  rxcap_1851_fail:
    goto rx1849_fail
  rxcap_1851_done:
  # rx subrule "O" subtype=capture negate=
    rx1849_cur."!cursor_pos"(rx1849_pos)
    $P10 = rx1849_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx1849_fail
    rx1849_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1849_pos = $P10."pos"()
  # rx pass
    rx1849_cur."!cursor_pass"(rx1849_pos, "infix:sym<::=>")
    if_null rx1849_debug, debug_1380
    rx1849_cur."!cursor_debug"("PASS", "infix:sym<::=>", " at pos=", rx1849_pos)
  debug_1380:
    .return (rx1849_cur)
  rx1849_restart:
.annotate 'line', 10
    if_null rx1849_debug, debug_1381
    rx1849_cur."!cursor_debug"("NEXT", "infix:sym<::=>")
  debug_1381:
  rx1849_fail:
    (rx1849_rep, rx1849_pos, $I10, $P10) = rx1849_cur."!mark_fail"(0)
    lt rx1849_pos, -1, rx1849_done
    eq rx1849_pos, -1, rx1849_fail
    jump $I10
  rx1849_done:
    rx1849_cur."!cursor_fail"()
    if_null rx1849_debug, debug_1382
    rx1849_cur."!cursor_debug"("FAIL", "infix:sym<::=>")
  debug_1382:
    .return (rx1849_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<::=>"  :subid("370_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1853 = self."!PREFIX__!subrule"("O", "::=")
    new $P1854, "ResizablePMCArray"
    push $P1854, $P1853
    .return ($P1854)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<,>"  :subid("371_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1856_tgt
    .local int rx1856_pos
    .local int rx1856_off
    .local int rx1856_eos
    .local int rx1856_rep
    .local pmc rx1856_cur
    .local pmc rx1856_debug
    (rx1856_cur, rx1856_pos, rx1856_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1856_cur
    .local pmc match
    .lex "$/", match
    length rx1856_eos, rx1856_tgt
    gt rx1856_pos, rx1856_eos, rx1856_done
    set rx1856_off, 0
    lt rx1856_pos, 2, rx1856_start
    sub rx1856_off, rx1856_pos, 1
    substr rx1856_tgt, rx1856_tgt, rx1856_off
  rx1856_start:
    eq $I10, 1, rx1856_restart
    if_null rx1856_debug, debug_1383
    rx1856_cur."!cursor_debug"("START", "infix:sym<,>")
  debug_1383:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1857_done
    goto rxscan1857_scan
  rxscan1857_loop:
    (rx1856_pos) = rx1856_cur."from"()
    inc rx1856_pos
    rx1856_cur."!cursor_from"(rx1856_pos)
    ge rx1856_pos, rx1856_eos, rxscan1857_done
  rxscan1857_scan:
    set_addr $I10, rxscan1857_loop
    rx1856_cur."!mark_push"(0, rx1856_pos, $I10)
  rxscan1857_done:
.annotate 'line', 711
  # rx subcapture "sym"
    set_addr $I10, rxcap_1858_fail
    rx1856_cur."!mark_push"(0, rx1856_pos, $I10)
  # rx literal  ","
    add $I11, rx1856_pos, 1
    gt $I11, rx1856_eos, rx1856_fail
    sub $I11, rx1856_pos, rx1856_off
    ord $I11, rx1856_tgt, $I11
    ne $I11, 44, rx1856_fail
    add rx1856_pos, 1
    set_addr $I10, rxcap_1858_fail
    ($I12, $I11) = rx1856_cur."!mark_peek"($I10)
    rx1856_cur."!cursor_pos"($I11)
    ($P10) = rx1856_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1856_pos, "")
    rx1856_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1858_done
  rxcap_1858_fail:
    goto rx1856_fail
  rxcap_1858_done:
  # rx subrule "O" subtype=capture negate=
    rx1856_cur."!cursor_pos"(rx1856_pos)
    $P10 = rx1856_cur."O"("%comma, :pasttype<list>")
    unless $P10, rx1856_fail
    rx1856_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1856_pos = $P10."pos"()
  # rx pass
    rx1856_cur."!cursor_pass"(rx1856_pos, "infix:sym<,>")
    if_null rx1856_debug, debug_1384
    rx1856_cur."!cursor_debug"("PASS", "infix:sym<,>", " at pos=", rx1856_pos)
  debug_1384:
    .return (rx1856_cur)
  rx1856_restart:
.annotate 'line', 10
    if_null rx1856_debug, debug_1385
    rx1856_cur."!cursor_debug"("NEXT", "infix:sym<,>")
  debug_1385:
  rx1856_fail:
    (rx1856_rep, rx1856_pos, $I10, $P10) = rx1856_cur."!mark_fail"(0)
    lt rx1856_pos, -1, rx1856_done
    eq rx1856_pos, -1, rx1856_fail
    jump $I10
  rx1856_done:
    rx1856_cur."!cursor_fail"()
    if_null rx1856_debug, debug_1386
    rx1856_cur."!cursor_debug"("FAIL", "infix:sym<,>")
  debug_1386:
    .return (rx1856_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<,>"  :subid("372_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    $P1860 = self."!PREFIX__!subrule"("O", ",")
    new $P1861, "ResizablePMCArray"
    push $P1861, $P1860
    .return ($P1861)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<return>"  :subid("373_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .const 'Sub' $P1869 = "374_1304456155.152" 
    capture_lex $P1869
    .local string rx1863_tgt
    .local int rx1863_pos
    .local int rx1863_off
    .local int rx1863_eos
    .local int rx1863_rep
    .local pmc rx1863_cur
    .local pmc rx1863_debug
    (rx1863_cur, rx1863_pos, rx1863_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1863_cur
    .local pmc match
    .lex "$/", match
    length rx1863_eos, rx1863_tgt
    gt rx1863_pos, rx1863_eos, rx1863_done
    set rx1863_off, 0
    lt rx1863_pos, 2, rx1863_start
    sub rx1863_off, rx1863_pos, 1
    substr rx1863_tgt, rx1863_tgt, rx1863_off
  rx1863_start:
    eq $I10, 1, rx1863_restart
    if_null rx1863_debug, debug_1387
    rx1863_cur."!cursor_debug"("START", "prefix:sym<return>")
  debug_1387:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1864_done
    goto rxscan1864_scan
  rxscan1864_loop:
    (rx1863_pos) = rx1863_cur."from"()
    inc rx1863_pos
    rx1863_cur."!cursor_from"(rx1863_pos)
    ge rx1863_pos, rx1863_eos, rxscan1864_done
  rxscan1864_scan:
    set_addr $I10, rxscan1864_loop
    rx1863_cur."!mark_push"(0, rx1863_pos, $I10)
  rxscan1864_done:
.annotate 'line', 713
  # rx subcapture "sym"
    set_addr $I10, rxcap_1865_fail
    rx1863_cur."!mark_push"(0, rx1863_pos, $I10)
  # rx literal  "return"
    add $I11, rx1863_pos, 6
    gt $I11, rx1863_eos, rx1863_fail
    sub $I11, rx1863_pos, rx1863_off
    substr $S10, rx1863_tgt, $I11, 6
    ne $S10, "return", rx1863_fail
    add rx1863_pos, 6
    set_addr $I10, rxcap_1865_fail
    ($I12, $I11) = rx1863_cur."!mark_peek"($I10)
    rx1863_cur."!cursor_pos"($I11)
    ($P10) = rx1863_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1863_pos, "")
    rx1863_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1865_done
  rxcap_1865_fail:
    goto rx1863_fail
  rxcap_1865_done:
  # rx charclass s
    ge rx1863_pos, rx1863_eos, rx1863_fail
    sub $I10, rx1863_pos, rx1863_off
    is_cclass $I11, 32, rx1863_tgt, $I10
    unless $I11, rx1863_fail
    inc rx1863_pos
  # rx subrule "O" subtype=capture negate=
    rx1863_cur."!cursor_pos"(rx1863_pos)
    $P10 = rx1863_cur."O"("%list_prefix, :pasttype<return>")
    unless $P10, rx1863_fail
    rx1863_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1863_pos = $P10."pos"()
    rx1863_cur."!cursor_pos"(rx1863_pos)
    find_lex $P1866, unicode:"$\x{a2}"
    $P1867 = $P1866."MATCH"()
    store_lex "$/", $P1867
    .const 'Sub' $P1869 = "374_1304456155.152" 
    capture_lex $P1869
    $P1871 = $P1869()
  # rx pass
    rx1863_cur."!cursor_pass"(rx1863_pos, "prefix:sym<return>")
    if_null rx1863_debug, debug_1388
    rx1863_cur."!cursor_debug"("PASS", "prefix:sym<return>", " at pos=", rx1863_pos)
  debug_1388:
    .return (rx1863_cur)
  rx1863_restart:
.annotate 'line', 10
    if_null rx1863_debug, debug_1389
    rx1863_cur."!cursor_debug"("NEXT", "prefix:sym<return>")
  debug_1389:
  rx1863_fail:
    (rx1863_rep, rx1863_pos, $I10, $P10) = rx1863_cur."!mark_fail"(0)
    lt rx1863_pos, -1, rx1863_done
    eq rx1863_pos, -1, rx1863_fail
    jump $I10
  rx1863_done:
    rx1863_cur."!cursor_fail"()
    if_null rx1863_debug, debug_1390
    rx1863_cur."!cursor_debug"("FAIL", "prefix:sym<return>")
  debug_1390:
    .return (rx1863_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1868"  :anon :subid("374_1304456155.152") :outer("373_1304456155.152")
.annotate 'line', 713
    new $P1870, "Integer"
    assign $P1870, 1
    store_dynamic_lex "$*RETURN_USED", $P1870
    .return ($P1870)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<return>"  :subid("375_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    new $P1873, "ResizablePMCArray"
    push $P1873, "return"
    .return ($P1873)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<make>"  :subid("376_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1875_tgt
    .local int rx1875_pos
    .local int rx1875_off
    .local int rx1875_eos
    .local int rx1875_rep
    .local pmc rx1875_cur
    .local pmc rx1875_debug
    (rx1875_cur, rx1875_pos, rx1875_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1875_cur
    .local pmc match
    .lex "$/", match
    length rx1875_eos, rx1875_tgt
    gt rx1875_pos, rx1875_eos, rx1875_done
    set rx1875_off, 0
    lt rx1875_pos, 2, rx1875_start
    sub rx1875_off, rx1875_pos, 1
    substr rx1875_tgt, rx1875_tgt, rx1875_off
  rx1875_start:
    eq $I10, 1, rx1875_restart
    if_null rx1875_debug, debug_1391
    rx1875_cur."!cursor_debug"("START", "prefix:sym<make>")
  debug_1391:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1876_done
    goto rxscan1876_scan
  rxscan1876_loop:
    (rx1875_pos) = rx1875_cur."from"()
    inc rx1875_pos
    rx1875_cur."!cursor_from"(rx1875_pos)
    ge rx1875_pos, rx1875_eos, rxscan1876_done
  rxscan1876_scan:
    set_addr $I10, rxscan1876_loop
    rx1875_cur."!mark_push"(0, rx1875_pos, $I10)
  rxscan1876_done:
.annotate 'line', 714
  # rx subcapture "sym"
    set_addr $I10, rxcap_1877_fail
    rx1875_cur."!mark_push"(0, rx1875_pos, $I10)
  # rx literal  "make"
    add $I11, rx1875_pos, 4
    gt $I11, rx1875_eos, rx1875_fail
    sub $I11, rx1875_pos, rx1875_off
    substr $S10, rx1875_tgt, $I11, 4
    ne $S10, "make", rx1875_fail
    add rx1875_pos, 4
    set_addr $I10, rxcap_1877_fail
    ($I12, $I11) = rx1875_cur."!mark_peek"($I10)
    rx1875_cur."!cursor_pos"($I11)
    ($P10) = rx1875_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1875_pos, "")
    rx1875_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1877_done
  rxcap_1877_fail:
    goto rx1875_fail
  rxcap_1877_done:
  # rx charclass s
    ge rx1875_pos, rx1875_eos, rx1875_fail
    sub $I10, rx1875_pos, rx1875_off
    is_cclass $I11, 32, rx1875_tgt, $I10
    unless $I11, rx1875_fail
    inc rx1875_pos
  # rx subrule "O" subtype=capture negate=
    rx1875_cur."!cursor_pos"(rx1875_pos)
    $P10 = rx1875_cur."O"("%list_prefix")
    unless $P10, rx1875_fail
    rx1875_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1875_pos = $P10."pos"()
  # rx pass
    rx1875_cur."!cursor_pass"(rx1875_pos, "prefix:sym<make>")
    if_null rx1875_debug, debug_1392
    rx1875_cur."!cursor_debug"("PASS", "prefix:sym<make>", " at pos=", rx1875_pos)
  debug_1392:
    .return (rx1875_cur)
  rx1875_restart:
.annotate 'line', 10
    if_null rx1875_debug, debug_1393
    rx1875_cur."!cursor_debug"("NEXT", "prefix:sym<make>")
  debug_1393:
  rx1875_fail:
    (rx1875_rep, rx1875_pos, $I10, $P10) = rx1875_cur."!mark_fail"(0)
    lt rx1875_pos, -1, rx1875_done
    eq rx1875_pos, -1, rx1875_fail
    jump $I10
  rx1875_done:
    rx1875_cur."!cursor_fail"()
    if_null rx1875_debug, debug_1394
    rx1875_cur."!cursor_debug"("FAIL", "prefix:sym<make>")
  debug_1394:
    .return (rx1875_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<make>"  :subid("377_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    new $P1879, "ResizablePMCArray"
    push $P1879, "make"
    .return ($P1879)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<last>"  :subid("378_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1881_tgt
    .local int rx1881_pos
    .local int rx1881_off
    .local int rx1881_eos
    .local int rx1881_rep
    .local pmc rx1881_cur
    .local pmc rx1881_debug
    (rx1881_cur, rx1881_pos, rx1881_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1881_cur
    .local pmc match
    .lex "$/", match
    length rx1881_eos, rx1881_tgt
    gt rx1881_pos, rx1881_eos, rx1881_done
    set rx1881_off, 0
    lt rx1881_pos, 2, rx1881_start
    sub rx1881_off, rx1881_pos, 1
    substr rx1881_tgt, rx1881_tgt, rx1881_off
  rx1881_start:
    eq $I10, 1, rx1881_restart
    if_null rx1881_debug, debug_1395
    rx1881_cur."!cursor_debug"("START", "term:sym<last>")
  debug_1395:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1882_done
    goto rxscan1882_scan
  rxscan1882_loop:
    (rx1881_pos) = rx1881_cur."from"()
    inc rx1881_pos
    rx1881_cur."!cursor_from"(rx1881_pos)
    ge rx1881_pos, rx1881_eos, rxscan1882_done
  rxscan1882_scan:
    set_addr $I10, rxscan1882_loop
    rx1881_cur."!mark_push"(0, rx1881_pos, $I10)
  rxscan1882_done:
.annotate 'line', 715
  # rx subcapture "sym"
    set_addr $I10, rxcap_1883_fail
    rx1881_cur."!mark_push"(0, rx1881_pos, $I10)
  # rx literal  "last"
    add $I11, rx1881_pos, 4
    gt $I11, rx1881_eos, rx1881_fail
    sub $I11, rx1881_pos, rx1881_off
    substr $S10, rx1881_tgt, $I11, 4
    ne $S10, "last", rx1881_fail
    add rx1881_pos, 4
    set_addr $I10, rxcap_1883_fail
    ($I12, $I11) = rx1881_cur."!mark_peek"($I10)
    rx1881_cur."!cursor_pos"($I11)
    ($P10) = rx1881_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1881_pos, "")
    rx1881_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1883_done
  rxcap_1883_fail:
    goto rx1881_fail
  rxcap_1883_done:
  # rx pass
    rx1881_cur."!cursor_pass"(rx1881_pos, "term:sym<last>")
    if_null rx1881_debug, debug_1396
    rx1881_cur."!cursor_debug"("PASS", "term:sym<last>", " at pos=", rx1881_pos)
  debug_1396:
    .return (rx1881_cur)
  rx1881_restart:
.annotate 'line', 10
    if_null rx1881_debug, debug_1397
    rx1881_cur."!cursor_debug"("NEXT", "term:sym<last>")
  debug_1397:
  rx1881_fail:
    (rx1881_rep, rx1881_pos, $I10, $P10) = rx1881_cur."!mark_fail"(0)
    lt rx1881_pos, -1, rx1881_done
    eq rx1881_pos, -1, rx1881_fail
    jump $I10
  rx1881_done:
    rx1881_cur."!cursor_fail"()
    if_null rx1881_debug, debug_1398
    rx1881_cur."!cursor_debug"("FAIL", "term:sym<last>")
  debug_1398:
    .return (rx1881_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<last>"  :subid("379_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    new $P1885, "ResizablePMCArray"
    push $P1885, "last"
    .return ($P1885)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<next>"  :subid("380_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1887_tgt
    .local int rx1887_pos
    .local int rx1887_off
    .local int rx1887_eos
    .local int rx1887_rep
    .local pmc rx1887_cur
    .local pmc rx1887_debug
    (rx1887_cur, rx1887_pos, rx1887_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1887_cur
    .local pmc match
    .lex "$/", match
    length rx1887_eos, rx1887_tgt
    gt rx1887_pos, rx1887_eos, rx1887_done
    set rx1887_off, 0
    lt rx1887_pos, 2, rx1887_start
    sub rx1887_off, rx1887_pos, 1
    substr rx1887_tgt, rx1887_tgt, rx1887_off
  rx1887_start:
    eq $I10, 1, rx1887_restart
    if_null rx1887_debug, debug_1399
    rx1887_cur."!cursor_debug"("START", "term:sym<next>")
  debug_1399:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1888_done
    goto rxscan1888_scan
  rxscan1888_loop:
    (rx1887_pos) = rx1887_cur."from"()
    inc rx1887_pos
    rx1887_cur."!cursor_from"(rx1887_pos)
    ge rx1887_pos, rx1887_eos, rxscan1888_done
  rxscan1888_scan:
    set_addr $I10, rxscan1888_loop
    rx1887_cur."!mark_push"(0, rx1887_pos, $I10)
  rxscan1888_done:
.annotate 'line', 716
  # rx subcapture "sym"
    set_addr $I10, rxcap_1889_fail
    rx1887_cur."!mark_push"(0, rx1887_pos, $I10)
  # rx literal  "next"
    add $I11, rx1887_pos, 4
    gt $I11, rx1887_eos, rx1887_fail
    sub $I11, rx1887_pos, rx1887_off
    substr $S10, rx1887_tgt, $I11, 4
    ne $S10, "next", rx1887_fail
    add rx1887_pos, 4
    set_addr $I10, rxcap_1889_fail
    ($I12, $I11) = rx1887_cur."!mark_peek"($I10)
    rx1887_cur."!cursor_pos"($I11)
    ($P10) = rx1887_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1887_pos, "")
    rx1887_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1889_done
  rxcap_1889_fail:
    goto rx1887_fail
  rxcap_1889_done:
  # rx pass
    rx1887_cur."!cursor_pass"(rx1887_pos, "term:sym<next>")
    if_null rx1887_debug, debug_1400
    rx1887_cur."!cursor_debug"("PASS", "term:sym<next>", " at pos=", rx1887_pos)
  debug_1400:
    .return (rx1887_cur)
  rx1887_restart:
.annotate 'line', 10
    if_null rx1887_debug, debug_1401
    rx1887_cur."!cursor_debug"("NEXT", "term:sym<next>")
  debug_1401:
  rx1887_fail:
    (rx1887_rep, rx1887_pos, $I10, $P10) = rx1887_cur."!mark_fail"(0)
    lt rx1887_pos, -1, rx1887_done
    eq rx1887_pos, -1, rx1887_fail
    jump $I10
  rx1887_done:
    rx1887_cur."!cursor_fail"()
    if_null rx1887_debug, debug_1402
    rx1887_cur."!cursor_debug"("FAIL", "term:sym<next>")
  debug_1402:
    .return (rx1887_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<next>"  :subid("381_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    new $P1891, "ResizablePMCArray"
    push $P1891, "next"
    .return ($P1891)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<redo>"  :subid("382_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    .local string rx1893_tgt
    .local int rx1893_pos
    .local int rx1893_off
    .local int rx1893_eos
    .local int rx1893_rep
    .local pmc rx1893_cur
    .local pmc rx1893_debug
    (rx1893_cur, rx1893_pos, rx1893_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1893_cur
    .local pmc match
    .lex "$/", match
    length rx1893_eos, rx1893_tgt
    gt rx1893_pos, rx1893_eos, rx1893_done
    set rx1893_off, 0
    lt rx1893_pos, 2, rx1893_start
    sub rx1893_off, rx1893_pos, 1
    substr rx1893_tgt, rx1893_tgt, rx1893_off
  rx1893_start:
    eq $I10, 1, rx1893_restart
    if_null rx1893_debug, debug_1403
    rx1893_cur."!cursor_debug"("START", "term:sym<redo>")
  debug_1403:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1894_done
    goto rxscan1894_scan
  rxscan1894_loop:
    (rx1893_pos) = rx1893_cur."from"()
    inc rx1893_pos
    rx1893_cur."!cursor_from"(rx1893_pos)
    ge rx1893_pos, rx1893_eos, rxscan1894_done
  rxscan1894_scan:
    set_addr $I10, rxscan1894_loop
    rx1893_cur."!mark_push"(0, rx1893_pos, $I10)
  rxscan1894_done:
.annotate 'line', 717
  # rx subcapture "sym"
    set_addr $I10, rxcap_1895_fail
    rx1893_cur."!mark_push"(0, rx1893_pos, $I10)
  # rx literal  "redo"
    add $I11, rx1893_pos, 4
    gt $I11, rx1893_eos, rx1893_fail
    sub $I11, rx1893_pos, rx1893_off
    substr $S10, rx1893_tgt, $I11, 4
    ne $S10, "redo", rx1893_fail
    add rx1893_pos, 4
    set_addr $I10, rxcap_1895_fail
    ($I12, $I11) = rx1893_cur."!mark_peek"($I10)
    rx1893_cur."!cursor_pos"($I11)
    ($P10) = rx1893_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1893_pos, "")
    rx1893_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1895_done
  rxcap_1895_fail:
    goto rx1893_fail
  rxcap_1895_done:
  # rx pass
    rx1893_cur."!cursor_pass"(rx1893_pos, "term:sym<redo>")
    if_null rx1893_debug, debug_1404
    rx1893_cur."!cursor_debug"("PASS", "term:sym<redo>", " at pos=", rx1893_pos)
  debug_1404:
    .return (rx1893_cur)
  rx1893_restart:
.annotate 'line', 10
    if_null rx1893_debug, debug_1405
    rx1893_cur."!cursor_debug"("NEXT", "term:sym<redo>")
  debug_1405:
  rx1893_fail:
    (rx1893_rep, rx1893_pos, $I10, $P10) = rx1893_cur."!mark_fail"(0)
    lt rx1893_pos, -1, rx1893_done
    eq rx1893_pos, -1, rx1893_fail
    jump $I10
  rx1893_done:
    rx1893_cur."!cursor_fail"()
    if_null rx1893_debug, debug_1406
    rx1893_cur."!cursor_debug"("FAIL", "term:sym<redo>")
  debug_1406:
    .return (rx1893_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<redo>"  :subid("383_1304456155.152") :method :outer("12_1304456155.152")
.annotate 'line', 10
    new $P1897, "ResizablePMCArray"
    push $P1897, "redo"
    .return ($P1897)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "smartmatch"  :subid("384_1304456155.152") :outer("12_1304456155.152")
    .param pmc param_1899
    .param pmc param_1900
.annotate 'line', 719
    .lex "self", param_1899
    .lex "$/", param_1900
.annotate 'line', 721
    new $P1901, "Undef"
    .lex "$t", $P1901
    find_lex $P1902, "$/"
    unless_null $P1902, vivify_1407
    $P1902 = root_new ['parrot';'ResizablePMCArray']
  vivify_1407:
    set $P1903, $P1902[0]
    unless_null $P1903, vivify_1408
    new $P1903, "Undef"
  vivify_1408:
    store_lex "$t", $P1903
    find_lex $P1904, "$/"
    unless_null $P1904, vivify_1409
    $P1904 = root_new ['parrot';'ResizablePMCArray']
  vivify_1409:
    set $P1905, $P1904[1]
    unless_null $P1905, vivify_1410
    new $P1905, "Undef"
  vivify_1410:
    find_lex $P1906, "$/"
    unless_null $P1906, vivify_1411
    $P1906 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P1906
  vivify_1411:
    set $P1906[0], $P1905
    find_lex $P1907, "$t"
    unless_null $P1907, vivify_1412
    new $P1907, "Undef"
  vivify_1412:
    find_lex $P1908, "$/"
    unless_null $P1908, vivify_1413
    $P1908 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P1908
  vivify_1413:
    set $P1908[1], $P1907
.annotate 'line', 719
    .return ($P1907)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block1910"  :subid("385_1304456155.152") :outer("10_1304456155.152")
.annotate 'line', 725
    .const 'Sub' $P1972 = "405_1304456155.152" 
    capture_lex $P1972
    .const 'Sub' $P1969 = "404_1304456155.152" 
    capture_lex $P1969
    .const 'Sub' $P1967 = "403_1304456155.152" 
    capture_lex $P1967
    .const 'Sub' $P1964 = "402_1304456155.152" 
    capture_lex $P1964
    .const 'Sub' $P1961 = "401_1304456155.152" 
    capture_lex $P1961
    .const 'Sub' $P1952 = "399_1304456155.152" 
    capture_lex $P1952
    .const 'Sub' $P1950 = "398_1304456155.152" 
    capture_lex $P1950
    .const 'Sub' $P1942 = "396_1304456155.152" 
    capture_lex $P1942
    .const 'Sub' $P1940 = "395_1304456155.152" 
    capture_lex $P1940
    .const 'Sub' $P1937 = "394_1304456155.152" 
    capture_lex $P1937
    .const 'Sub' $P1935 = "393_1304456155.152" 
    capture_lex $P1935
    .const 'Sub' $P1928 = "391_1304456155.152" 
    capture_lex $P1928
    .const 'Sub' $P1926 = "390_1304456155.152" 
    capture_lex $P1926
    .const 'Sub' $P1923 = "389_1304456155.152" 
    capture_lex $P1923
    .const 'Sub' $P1921 = "388_1304456155.152" 
    capture_lex $P1921
    .const 'Sub' $P1914 = "386_1304456155.152" 
    capture_lex $P1914
    .lex "$?PACKAGE", $P1912
    .lex "$?CLASS", $P1913
    .const 'Sub' $P1972 = "405_1304456155.152" 
    capture_lex $P1972
    .return ($P1972)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<:my>"  :subid("386_1304456155.152") :method :outer("385_1304456155.152")
.annotate 'line', 725
    .const 'Sub' $P1918 = "387_1304456155.152" 
    capture_lex $P1918
    .local string rx1915_tgt
    .local int rx1915_pos
    .local int rx1915_off
    .local int rx1915_eos
    .local int rx1915_rep
    .local pmc rx1915_cur
    .local pmc rx1915_debug
    (rx1915_cur, rx1915_pos, rx1915_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1915_cur
    .local pmc match
    .lex "$/", match
    length rx1915_eos, rx1915_tgt
    gt rx1915_pos, rx1915_eos, rx1915_done
    set rx1915_off, 0
    lt rx1915_pos, 2, rx1915_start
    sub rx1915_off, rx1915_pos, 1
    substr rx1915_tgt, rx1915_tgt, rx1915_off
  rx1915_start:
    eq $I10, 1, rx1915_restart
    if_null rx1915_debug, debug_1414
    rx1915_cur."!cursor_debug"("START", "metachar:sym<:my>")
  debug_1414:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1916_done
    goto rxscan1916_scan
  rxscan1916_loop:
    (rx1915_pos) = rx1915_cur."from"()
    inc rx1915_pos
    rx1915_cur."!cursor_from"(rx1915_pos)
    ge rx1915_pos, rx1915_eos, rxscan1916_done
  rxscan1916_scan:
    set_addr $I10, rxscan1916_loop
    rx1915_cur."!mark_push"(0, rx1915_pos, $I10)
  rxscan1916_done:
.annotate 'line', 727
  # rx literal  ":"
    add $I11, rx1915_pos, 1
    gt $I11, rx1915_eos, rx1915_fail
    sub $I11, rx1915_pos, rx1915_off
    ord $I11, rx1915_tgt, $I11
    ne $I11, 58, rx1915_fail
    add rx1915_pos, 1
  # rx subrule "before" subtype=zerowidth negate=
    rx1915_cur."!cursor_pos"(rx1915_pos)
    .const 'Sub' $P1918 = "387_1304456155.152" 
    capture_lex $P1918
    $P10 = rx1915_cur."before"($P1918)
    unless $P10, rx1915_fail
  # rx subrule "LANG" subtype=capture negate=
    rx1915_cur."!cursor_pos"(rx1915_pos)
    $P10 = rx1915_cur."LANG"("MAIN", "statement")
    unless $P10, rx1915_fail
    rx1915_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx1915_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1915_cur."!cursor_pos"(rx1915_pos)
    $P10 = rx1915_cur."ws"()
    unless $P10, rx1915_fail
    rx1915_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx1915_pos, 1
    gt $I11, rx1915_eos, rx1915_fail
    sub $I11, rx1915_pos, rx1915_off
    ord $I11, rx1915_tgt, $I11
    ne $I11, 59, rx1915_fail
    add rx1915_pos, 1
.annotate 'line', 726
  # rx pass
    rx1915_cur."!cursor_pass"(rx1915_pos, "metachar:sym<:my>")
    if_null rx1915_debug, debug_1419
    rx1915_cur."!cursor_debug"("PASS", "metachar:sym<:my>", " at pos=", rx1915_pos)
  debug_1419:
    .return (rx1915_cur)
  rx1915_restart:
.annotate 'line', 725
    if_null rx1915_debug, debug_1420
    rx1915_cur."!cursor_debug"("NEXT", "metachar:sym<:my>")
  debug_1420:
  rx1915_fail:
    (rx1915_rep, rx1915_pos, $I10, $P10) = rx1915_cur."!mark_fail"(0)
    lt rx1915_pos, -1, rx1915_done
    eq rx1915_pos, -1, rx1915_fail
    jump $I10
  rx1915_done:
    rx1915_cur."!cursor_fail"()
    if_null rx1915_debug, debug_1421
    rx1915_cur."!cursor_debug"("FAIL", "metachar:sym<:my>")
  debug_1421:
    .return (rx1915_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block1917"  :anon :subid("387_1304456155.152") :method :outer("386_1304456155.152")
.annotate 'line', 727
    .local string rx1919_tgt
    .local int rx1919_pos
    .local int rx1919_off
    .local int rx1919_eos
    .local int rx1919_rep
    .local pmc rx1919_cur
    .local pmc rx1919_debug
    (rx1919_cur, rx1919_pos, rx1919_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1919_cur
    .local pmc match
    .lex "$/", match
    length rx1919_eos, rx1919_tgt
    gt rx1919_pos, rx1919_eos, rx1919_done
    set rx1919_off, 0
    lt rx1919_pos, 2, rx1919_start
    sub rx1919_off, rx1919_pos, 1
    substr rx1919_tgt, rx1919_tgt, rx1919_off
  rx1919_start:
    eq $I10, 1, rx1919_restart
    if_null rx1919_debug, debug_1415
    rx1919_cur."!cursor_debug"("START", "")
  debug_1415:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1920_done
    goto rxscan1920_scan
  rxscan1920_loop:
    (rx1919_pos) = rx1919_cur."from"()
    inc rx1919_pos
    rx1919_cur."!cursor_from"(rx1919_pos)
    ge rx1919_pos, rx1919_eos, rxscan1920_done
  rxscan1920_scan:
    set_addr $I10, rxscan1920_loop
    rx1919_cur."!mark_push"(0, rx1919_pos, $I10)
  rxscan1920_done:
  # rx literal  "my"
    add $I11, rx1919_pos, 2
    gt $I11, rx1919_eos, rx1919_fail
    sub $I11, rx1919_pos, rx1919_off
    substr $S10, rx1919_tgt, $I11, 2
    ne $S10, "my", rx1919_fail
    add rx1919_pos, 2
  # rx pass
    rx1919_cur."!cursor_pass"(rx1919_pos, "")
    if_null rx1919_debug, debug_1416
    rx1919_cur."!cursor_debug"("PASS", "", " at pos=", rx1919_pos)
  debug_1416:
    .return (rx1919_cur)
  rx1919_restart:
    if_null rx1919_debug, debug_1417
    rx1919_cur."!cursor_debug"("NEXT", "")
  debug_1417:
  rx1919_fail:
    (rx1919_rep, rx1919_pos, $I10, $P10) = rx1919_cur."!mark_fail"(0)
    lt rx1919_pos, -1, rx1919_done
    eq rx1919_pos, -1, rx1919_fail
    jump $I10
  rx1919_done:
    rx1919_cur."!cursor_fail"()
    if_null rx1919_debug, debug_1418
    rx1919_cur."!cursor_debug"("FAIL", "")
  debug_1418:
    .return (rx1919_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<:my>"  :subid("388_1304456155.152") :method :outer("385_1304456155.152")
.annotate 'line', 725
    new $P1922, "ResizablePMCArray"
    push $P1922, ":"
    .return ($P1922)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<{ }>"  :subid("389_1304456155.152") :method :outer("385_1304456155.152")
.annotate 'line', 725
    .local string rx1924_tgt
    .local int rx1924_pos
    .local int rx1924_off
    .local int rx1924_eos
    .local int rx1924_rep
    .local pmc rx1924_cur
    .local pmc rx1924_debug
    (rx1924_cur, rx1924_pos, rx1924_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1924_cur
    .local pmc match
    .lex "$/", match
    length rx1924_eos, rx1924_tgt
    gt rx1924_pos, rx1924_eos, rx1924_done
    set rx1924_off, 0
    lt rx1924_pos, 2, rx1924_start
    sub rx1924_off, rx1924_pos, 1
    substr rx1924_tgt, rx1924_tgt, rx1924_off
  rx1924_start:
    eq $I10, 1, rx1924_restart
    if_null rx1924_debug, debug_1422
    rx1924_cur."!cursor_debug"("START", "metachar:sym<{ }>")
  debug_1422:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1925_done
    goto rxscan1925_scan
  rxscan1925_loop:
    (rx1924_pos) = rx1924_cur."from"()
    inc rx1924_pos
    rx1924_cur."!cursor_from"(rx1924_pos)
    ge rx1924_pos, rx1924_eos, rxscan1925_done
  rxscan1925_scan:
    set_addr $I10, rxscan1925_loop
    rx1924_cur."!mark_push"(0, rx1924_pos, $I10)
  rxscan1925_done:
.annotate 'line', 731
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1924_pos, rx1924_off
    substr $S10, rx1924_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1924_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx1924_cur."!cursor_pos"(rx1924_pos)
    $P10 = rx1924_cur."codeblock"()
    unless $P10, rx1924_fail
    rx1924_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx1924_pos = $P10."pos"()
.annotate 'line', 730
  # rx pass
    rx1924_cur."!cursor_pass"(rx1924_pos, "metachar:sym<{ }>")
    if_null rx1924_debug, debug_1423
    rx1924_cur."!cursor_debug"("PASS", "metachar:sym<{ }>", " at pos=", rx1924_pos)
  debug_1423:
    .return (rx1924_cur)
  rx1924_restart:
.annotate 'line', 725
    if_null rx1924_debug, debug_1424
    rx1924_cur."!cursor_debug"("NEXT", "metachar:sym<{ }>")
  debug_1424:
  rx1924_fail:
    (rx1924_rep, rx1924_pos, $I10, $P10) = rx1924_cur."!mark_fail"(0)
    lt rx1924_pos, -1, rx1924_done
    eq rx1924_pos, -1, rx1924_fail
    jump $I10
  rx1924_done:
    rx1924_cur."!cursor_fail"()
    if_null rx1924_debug, debug_1425
    rx1924_cur."!cursor_debug"("FAIL", "metachar:sym<{ }>")
  debug_1425:
    .return (rx1924_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<{ }>"  :subid("390_1304456155.152") :method :outer("385_1304456155.152")
.annotate 'line', 725
    new $P1927, "ResizablePMCArray"
    push $P1927, "{"
    .return ($P1927)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<nqpvar>"  :subid("391_1304456155.152") :method :outer("385_1304456155.152")
.annotate 'line', 725
    .const 'Sub' $P1932 = "392_1304456155.152" 
    capture_lex $P1932
    .local string rx1929_tgt
    .local int rx1929_pos
    .local int rx1929_off
    .local int rx1929_eos
    .local int rx1929_rep
    .local pmc rx1929_cur
    .local pmc rx1929_debug
    (rx1929_cur, rx1929_pos, rx1929_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1929_cur
    .local pmc match
    .lex "$/", match
    length rx1929_eos, rx1929_tgt
    gt rx1929_pos, rx1929_eos, rx1929_done
    set rx1929_off, 0
    lt rx1929_pos, 2, rx1929_start
    sub rx1929_off, rx1929_pos, 1
    substr rx1929_tgt, rx1929_tgt, rx1929_off
  rx1929_start:
    eq $I10, 1, rx1929_restart
    if_null rx1929_debug, debug_1426
    rx1929_cur."!cursor_debug"("START", "metachar:sym<nqpvar>")
  debug_1426:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1930_done
    goto rxscan1930_scan
  rxscan1930_loop:
    (rx1929_pos) = rx1929_cur."from"()
    inc rx1929_pos
    rx1929_cur."!cursor_from"(rx1929_pos)
    ge rx1929_pos, rx1929_eos, rxscan1930_done
  rxscan1930_scan:
    set_addr $I10, rxscan1930_loop
    rx1929_cur."!mark_push"(0, rx1929_pos, $I10)
  rxscan1930_done:
.annotate 'line', 735
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1929_pos, rx1929_off
    substr $S10, rx1929_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx1929_fail
  # rx subrule "before" subtype=zerowidth negate=
    rx1929_cur."!cursor_pos"(rx1929_pos)
    .const 'Sub' $P1932 = "392_1304456155.152" 
    capture_lex $P1932
    $P10 = rx1929_cur."before"($P1932)
    unless $P10, rx1929_fail
  # rx subrule "LANG" subtype=capture negate=
    rx1929_cur."!cursor_pos"(rx1929_pos)
    $P10 = rx1929_cur."LANG"("MAIN", "variable")
    unless $P10, rx1929_fail
    rx1929_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx1929_pos = $P10."pos"()
.annotate 'line', 734
  # rx pass
    rx1929_cur."!cursor_pass"(rx1929_pos, "metachar:sym<nqpvar>")
    if_null rx1929_debug, debug_1431
    rx1929_cur."!cursor_debug"("PASS", "metachar:sym<nqpvar>", " at pos=", rx1929_pos)
  debug_1431:
    .return (rx1929_cur)
  rx1929_restart:
.annotate 'line', 725
    if_null rx1929_debug, debug_1432
    rx1929_cur."!cursor_debug"("NEXT", "metachar:sym<nqpvar>")
  debug_1432:
  rx1929_fail:
    (rx1929_rep, rx1929_pos, $I10, $P10) = rx1929_cur."!mark_fail"(0)
    lt rx1929_pos, -1, rx1929_done
    eq rx1929_pos, -1, rx1929_fail
    jump $I10
  rx1929_done:
    rx1929_cur."!cursor_fail"()
    if_null rx1929_debug, debug_1433
    rx1929_cur."!cursor_debug"("FAIL", "metachar:sym<nqpvar>")
  debug_1433:
    .return (rx1929_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block1931"  :anon :subid("392_1304456155.152") :method :outer("391_1304456155.152")
.annotate 'line', 735
    .local string rx1933_tgt
    .local int rx1933_pos
    .local int rx1933_off
    .local int rx1933_eos
    .local int rx1933_rep
    .local pmc rx1933_cur
    .local pmc rx1933_debug
    (rx1933_cur, rx1933_pos, rx1933_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1933_cur
    .local pmc match
    .lex "$/", match
    length rx1933_eos, rx1933_tgt
    gt rx1933_pos, rx1933_eos, rx1933_done
    set rx1933_off, 0
    lt rx1933_pos, 2, rx1933_start
    sub rx1933_off, rx1933_pos, 1
    substr rx1933_tgt, rx1933_tgt, rx1933_off
  rx1933_start:
    eq $I10, 1, rx1933_restart
    if_null rx1933_debug, debug_1427
    rx1933_cur."!cursor_debug"("START", "")
  debug_1427:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1934_done
    goto rxscan1934_scan
  rxscan1934_loop:
    (rx1933_pos) = rx1933_cur."from"()
    inc rx1933_pos
    rx1933_cur."!cursor_from"(rx1933_pos)
    ge rx1933_pos, rx1933_eos, rxscan1934_done
  rxscan1934_scan:
    set_addr $I10, rxscan1934_loop
    rx1933_cur."!mark_push"(0, rx1933_pos, $I10)
  rxscan1934_done:
  # rx charclass .
    ge rx1933_pos, rx1933_eos, rx1933_fail
    inc rx1933_pos
  # rx charclass w
    ge rx1933_pos, rx1933_eos, rx1933_fail
    sub $I10, rx1933_pos, rx1933_off
    is_cclass $I11, 8192, rx1933_tgt, $I10
    unless $I11, rx1933_fail
    inc rx1933_pos
  # rx pass
    rx1933_cur."!cursor_pass"(rx1933_pos, "")
    if_null rx1933_debug, debug_1428
    rx1933_cur."!cursor_debug"("PASS", "", " at pos=", rx1933_pos)
  debug_1428:
    .return (rx1933_cur)
  rx1933_restart:
    if_null rx1933_debug, debug_1429
    rx1933_cur."!cursor_debug"("NEXT", "")
  debug_1429:
  rx1933_fail:
    (rx1933_rep, rx1933_pos, $I10, $P10) = rx1933_cur."!mark_fail"(0)
    lt rx1933_pos, -1, rx1933_done
    eq rx1933_pos, -1, rx1933_fail
    jump $I10
  rx1933_done:
    rx1933_cur."!cursor_fail"()
    if_null rx1933_debug, debug_1430
    rx1933_cur."!cursor_debug"("FAIL", "")
  debug_1430:
    .return (rx1933_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<nqpvar>"  :subid("393_1304456155.152") :method :outer("385_1304456155.152")
.annotate 'line', 725
    new $P1936, "ResizablePMCArray"
    push $P1936, "$"
    push $P1936, "@"
    .return ($P1936)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<{ }>"  :subid("394_1304456155.152") :method :outer("385_1304456155.152")
.annotate 'line', 725
    .local string rx1938_tgt
    .local int rx1938_pos
    .local int rx1938_off
    .local int rx1938_eos
    .local int rx1938_rep
    .local pmc rx1938_cur
    .local pmc rx1938_debug
    (rx1938_cur, rx1938_pos, rx1938_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1938_cur
    .local pmc match
    .lex "$/", match
    length rx1938_eos, rx1938_tgt
    gt rx1938_pos, rx1938_eos, rx1938_done
    set rx1938_off, 0
    lt rx1938_pos, 2, rx1938_start
    sub rx1938_off, rx1938_pos, 1
    substr rx1938_tgt, rx1938_tgt, rx1938_off
  rx1938_start:
    eq $I10, 1, rx1938_restart
    if_null rx1938_debug, debug_1434
    rx1938_cur."!cursor_debug"("START", "assertion:sym<{ }>")
  debug_1434:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1939_done
    goto rxscan1939_scan
  rxscan1939_loop:
    (rx1938_pos) = rx1938_cur."from"()
    inc rx1938_pos
    rx1938_cur."!cursor_from"(rx1938_pos)
    ge rx1938_pos, rx1938_eos, rxscan1939_done
  rxscan1939_scan:
    set_addr $I10, rxscan1939_loop
    rx1938_cur."!mark_push"(0, rx1938_pos, $I10)
  rxscan1939_done:
.annotate 'line', 739
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1938_pos, rx1938_off
    substr $S10, rx1938_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1938_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx1938_cur."!cursor_pos"(rx1938_pos)
    $P10 = rx1938_cur."codeblock"()
    unless $P10, rx1938_fail
    rx1938_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx1938_pos = $P10."pos"()
.annotate 'line', 738
  # rx pass
    rx1938_cur."!cursor_pass"(rx1938_pos, "assertion:sym<{ }>")
    if_null rx1938_debug, debug_1435
    rx1938_cur."!cursor_debug"("PASS", "assertion:sym<{ }>", " at pos=", rx1938_pos)
  debug_1435:
    .return (rx1938_cur)
  rx1938_restart:
.annotate 'line', 725
    if_null rx1938_debug, debug_1436
    rx1938_cur."!cursor_debug"("NEXT", "assertion:sym<{ }>")
  debug_1436:
  rx1938_fail:
    (rx1938_rep, rx1938_pos, $I10, $P10) = rx1938_cur."!mark_fail"(0)
    lt rx1938_pos, -1, rx1938_done
    eq rx1938_pos, -1, rx1938_fail
    jump $I10
  rx1938_done:
    rx1938_cur."!cursor_fail"()
    if_null rx1938_debug, debug_1437
    rx1938_cur."!cursor_debug"("FAIL", "assertion:sym<{ }>")
  debug_1437:
    .return (rx1938_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<{ }>"  :subid("395_1304456155.152") :method :outer("385_1304456155.152")
.annotate 'line', 725
    new $P1941, "ResizablePMCArray"
    push $P1941, "{"
    .return ($P1941)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<?{ }>"  :subid("396_1304456155.152") :method :outer("385_1304456155.152")
.annotate 'line', 725
    .const 'Sub' $P1946 = "397_1304456155.152" 
    capture_lex $P1946
    .local string rx1943_tgt
    .local int rx1943_pos
    .local int rx1943_off
    .local int rx1943_eos
    .local int rx1943_rep
    .local pmc rx1943_cur
    .local pmc rx1943_debug
    (rx1943_cur, rx1943_pos, rx1943_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1943_cur
    .local pmc match
    .lex "$/", match
    length rx1943_eos, rx1943_tgt
    gt rx1943_pos, rx1943_eos, rx1943_done
    set rx1943_off, 0
    lt rx1943_pos, 2, rx1943_start
    sub rx1943_off, rx1943_pos, 1
    substr rx1943_tgt, rx1943_tgt, rx1943_off
  rx1943_start:
    eq $I10, 1, rx1943_restart
    if_null rx1943_debug, debug_1438
    rx1943_cur."!cursor_debug"("START", "assertion:sym<?{ }>")
  debug_1438:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1944_done
    goto rxscan1944_scan
  rxscan1944_loop:
    (rx1943_pos) = rx1943_cur."from"()
    inc rx1943_pos
    rx1943_cur."!cursor_from"(rx1943_pos)
    ge rx1943_pos, rx1943_eos, rxscan1944_done
  rxscan1944_scan:
    set_addr $I10, rxscan1944_loop
    rx1943_cur."!mark_push"(0, rx1943_pos, $I10)
  rxscan1944_done:
.annotate 'line', 743
  # rx subcapture "zw"
    set_addr $I10, rxcap_1949_fail
    rx1943_cur."!mark_push"(0, rx1943_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1943_pos, rx1943_eos, rx1943_fail
    sub $I10, rx1943_pos, rx1943_off
    substr $S10, rx1943_tgt, $I10, 1
    index $I11, "?!", $S10
    lt $I11, 0, rx1943_fail
    inc rx1943_pos
  # rx subrule "before" subtype=zerowidth negate=
    rx1943_cur."!cursor_pos"(rx1943_pos)
    .const 'Sub' $P1946 = "397_1304456155.152" 
    capture_lex $P1946
    $P10 = rx1943_cur."before"($P1946)
    unless $P10, rx1943_fail
    set_addr $I10, rxcap_1949_fail
    ($I12, $I11) = rx1943_cur."!mark_peek"($I10)
    rx1943_cur."!cursor_pos"($I11)
    ($P10) = rx1943_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1943_pos, "")
    rx1943_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("zw")
    goto rxcap_1949_done
  rxcap_1949_fail:
    goto rx1943_fail
  rxcap_1949_done:
  # rx subrule "codeblock" subtype=capture negate=
    rx1943_cur."!cursor_pos"(rx1943_pos)
    $P10 = rx1943_cur."codeblock"()
    unless $P10, rx1943_fail
    rx1943_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx1943_pos = $P10."pos"()
.annotate 'line', 742
  # rx pass
    rx1943_cur."!cursor_pass"(rx1943_pos, "assertion:sym<?{ }>")
    if_null rx1943_debug, debug_1443
    rx1943_cur."!cursor_debug"("PASS", "assertion:sym<?{ }>", " at pos=", rx1943_pos)
  debug_1443:
    .return (rx1943_cur)
  rx1943_restart:
.annotate 'line', 725
    if_null rx1943_debug, debug_1444
    rx1943_cur."!cursor_debug"("NEXT", "assertion:sym<?{ }>")
  debug_1444:
  rx1943_fail:
    (rx1943_rep, rx1943_pos, $I10, $P10) = rx1943_cur."!mark_fail"(0)
    lt rx1943_pos, -1, rx1943_done
    eq rx1943_pos, -1, rx1943_fail
    jump $I10
  rx1943_done:
    rx1943_cur."!cursor_fail"()
    if_null rx1943_debug, debug_1445
    rx1943_cur."!cursor_debug"("FAIL", "assertion:sym<?{ }>")
  debug_1445:
    .return (rx1943_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block1945"  :anon :subid("397_1304456155.152") :method :outer("396_1304456155.152")
.annotate 'line', 743
    .local string rx1947_tgt
    .local int rx1947_pos
    .local int rx1947_off
    .local int rx1947_eos
    .local int rx1947_rep
    .local pmc rx1947_cur
    .local pmc rx1947_debug
    (rx1947_cur, rx1947_pos, rx1947_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1947_cur
    .local pmc match
    .lex "$/", match
    length rx1947_eos, rx1947_tgt
    gt rx1947_pos, rx1947_eos, rx1947_done
    set rx1947_off, 0
    lt rx1947_pos, 2, rx1947_start
    sub rx1947_off, rx1947_pos, 1
    substr rx1947_tgt, rx1947_tgt, rx1947_off
  rx1947_start:
    eq $I10, 1, rx1947_restart
    if_null rx1947_debug, debug_1439
    rx1947_cur."!cursor_debug"("START", "")
  debug_1439:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1948_done
    goto rxscan1948_scan
  rxscan1948_loop:
    (rx1947_pos) = rx1947_cur."from"()
    inc rx1947_pos
    rx1947_cur."!cursor_from"(rx1947_pos)
    ge rx1947_pos, rx1947_eos, rxscan1948_done
  rxscan1948_scan:
    set_addr $I10, rxscan1948_loop
    rx1947_cur."!mark_push"(0, rx1947_pos, $I10)
  rxscan1948_done:
  # rx literal  "{"
    add $I11, rx1947_pos, 1
    gt $I11, rx1947_eos, rx1947_fail
    sub $I11, rx1947_pos, rx1947_off
    ord $I11, rx1947_tgt, $I11
    ne $I11, 123, rx1947_fail
    add rx1947_pos, 1
  # rx pass
    rx1947_cur."!cursor_pass"(rx1947_pos, "")
    if_null rx1947_debug, debug_1440
    rx1947_cur."!cursor_debug"("PASS", "", " at pos=", rx1947_pos)
  debug_1440:
    .return (rx1947_cur)
  rx1947_restart:
    if_null rx1947_debug, debug_1441
    rx1947_cur."!cursor_debug"("NEXT", "")
  debug_1441:
  rx1947_fail:
    (rx1947_rep, rx1947_pos, $I10, $P10) = rx1947_cur."!mark_fail"(0)
    lt rx1947_pos, -1, rx1947_done
    eq rx1947_pos, -1, rx1947_fail
    jump $I10
  rx1947_done:
    rx1947_cur."!cursor_fail"()
    if_null rx1947_debug, debug_1442
    rx1947_cur."!cursor_debug"("FAIL", "")
  debug_1442:
    .return (rx1947_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<?{ }>"  :subid("398_1304456155.152") :method :outer("385_1304456155.152")
.annotate 'line', 725
    new $P1951, "ResizablePMCArray"
    push $P1951, "!"
    push $P1951, "?"
    .return ($P1951)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<name>"  :subid("399_1304456155.152") :method :outer("385_1304456155.152")
.annotate 'line', 725
    .const 'Sub' $P1958 = "400_1304456155.152" 
    capture_lex $P1958
    .local string rx1953_tgt
    .local int rx1953_pos
    .local int rx1953_off
    .local int rx1953_eos
    .local int rx1953_rep
    .local pmc rx1953_cur
    .local pmc rx1953_debug
    (rx1953_cur, rx1953_pos, rx1953_tgt, $I10) = self."!cursor_start"()
    rx1953_cur."!cursor_caparray"("assertion", "arglist", "nibbler")
    .lex unicode:"$\x{a2}", rx1953_cur
    .local pmc match
    .lex "$/", match
    length rx1953_eos, rx1953_tgt
    gt rx1953_pos, rx1953_eos, rx1953_done
    set rx1953_off, 0
    lt rx1953_pos, 2, rx1953_start
    sub rx1953_off, rx1953_pos, 1
    substr rx1953_tgt, rx1953_tgt, rx1953_off
  rx1953_start:
    eq $I10, 1, rx1953_restart
    if_null rx1953_debug, debug_1446
    rx1953_cur."!cursor_debug"("START", "assertion:sym<name>")
  debug_1446:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1954_done
    goto rxscan1954_scan
  rxscan1954_loop:
    (rx1953_pos) = rx1953_cur."from"()
    inc rx1953_pos
    rx1953_cur."!cursor_from"(rx1953_pos)
    ge rx1953_pos, rx1953_eos, rxscan1954_done
  rxscan1954_scan:
    set_addr $I10, rxscan1954_loop
    rx1953_cur."!mark_push"(0, rx1953_pos, $I10)
  rxscan1954_done:
.annotate 'line', 747
  # rx subrule "identifier" subtype=capture negate=
    rx1953_cur."!cursor_pos"(rx1953_pos)
    $P10 = rx1953_cur."identifier"()
    unless $P10, rx1953_fail
    rx1953_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx1953_pos = $P10."pos"()
.annotate 'line', 754
  # rx rxquantr1955 ** 0..1
    set_addr $I10, rxquantr1955_done
    rx1953_cur."!mark_push"(0, rx1953_pos, $I10)
  rxquantr1955_loop:
  alt1956_0:
.annotate 'line', 748
    set_addr $I10, alt1956_1
    rx1953_cur."!mark_push"(0, rx1953_pos, $I10)
.annotate 'line', 749
  # rx subrule "before" subtype=zerowidth negate=
    rx1953_cur."!cursor_pos"(rx1953_pos)
    .const 'Sub' $P1958 = "400_1304456155.152" 
    capture_lex $P1958
    $P10 = rx1953_cur."before"($P1958)
    unless $P10, rx1953_fail
    goto alt1956_end
  alt1956_1:
    set_addr $I10, alt1956_2
    rx1953_cur."!mark_push"(0, rx1953_pos, $I10)
.annotate 'line', 750
  # rx literal  "="
    add $I11, rx1953_pos, 1
    gt $I11, rx1953_eos, rx1953_fail
    sub $I11, rx1953_pos, rx1953_off
    ord $I11, rx1953_tgt, $I11
    ne $I11, 61, rx1953_fail
    add rx1953_pos, 1
  # rx subrule "assertion" subtype=capture negate=
    rx1953_cur."!cursor_pos"(rx1953_pos)
    $P10 = rx1953_cur."assertion"()
    unless $P10, rx1953_fail
    rx1953_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("assertion")
    rx1953_pos = $P10."pos"()
    goto alt1956_end
  alt1956_2:
    set_addr $I10, alt1956_3
    rx1953_cur."!mark_push"(0, rx1953_pos, $I10)
.annotate 'line', 751
  # rx literal  ":"
    add $I11, rx1953_pos, 1
    gt $I11, rx1953_eos, rx1953_fail
    sub $I11, rx1953_pos, rx1953_off
    ord $I11, rx1953_tgt, $I11
    ne $I11, 58, rx1953_fail
    add rx1953_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx1953_cur."!cursor_pos"(rx1953_pos)
    $P10 = rx1953_cur."arglist"()
    unless $P10, rx1953_fail
    rx1953_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1953_pos = $P10."pos"()
    goto alt1956_end
  alt1956_3:
    set_addr $I10, alt1956_4
    rx1953_cur."!mark_push"(0, rx1953_pos, $I10)
.annotate 'line', 752
  # rx literal  "("
    add $I11, rx1953_pos, 1
    gt $I11, rx1953_eos, rx1953_fail
    sub $I11, rx1953_pos, rx1953_off
    ord $I11, rx1953_tgt, $I11
    ne $I11, 40, rx1953_fail
    add rx1953_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx1953_cur."!cursor_pos"(rx1953_pos)
    $P10 = rx1953_cur."LANG"("MAIN", "arglist")
    unless $P10, rx1953_fail
    rx1953_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1953_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1953_pos, 1
    gt $I11, rx1953_eos, rx1953_fail
    sub $I11, rx1953_pos, rx1953_off
    ord $I11, rx1953_tgt, $I11
    ne $I11, 41, rx1953_fail
    add rx1953_pos, 1
    goto alt1956_end
  alt1956_4:
.annotate 'line', 753
  # rx subrule "normspace" subtype=method negate=
    rx1953_cur."!cursor_pos"(rx1953_pos)
    $P10 = rx1953_cur."normspace"()
    unless $P10, rx1953_fail
    rx1953_pos = $P10."pos"()
  # rx subrule "nibbler" subtype=capture negate=
    rx1953_cur."!cursor_pos"(rx1953_pos)
    $P10 = rx1953_cur."nibbler"()
    unless $P10, rx1953_fail
    rx1953_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("nibbler")
    rx1953_pos = $P10."pos"()
  alt1956_end:
.annotate 'line', 754
    set_addr $I10, rxquantr1955_done
    (rx1953_rep) = rx1953_cur."!mark_commit"($I10)
  rxquantr1955_done:
.annotate 'line', 746
  # rx pass
    rx1953_cur."!cursor_pass"(rx1953_pos, "assertion:sym<name>")
    if_null rx1953_debug, debug_1451
    rx1953_cur."!cursor_debug"("PASS", "assertion:sym<name>", " at pos=", rx1953_pos)
  debug_1451:
    .return (rx1953_cur)
  rx1953_restart:
.annotate 'line', 725
    if_null rx1953_debug, debug_1452
    rx1953_cur."!cursor_debug"("NEXT", "assertion:sym<name>")
  debug_1452:
  rx1953_fail:
    (rx1953_rep, rx1953_pos, $I10, $P10) = rx1953_cur."!mark_fail"(0)
    lt rx1953_pos, -1, rx1953_done
    eq rx1953_pos, -1, rx1953_fail
    jump $I10
  rx1953_done:
    rx1953_cur."!cursor_fail"()
    if_null rx1953_debug, debug_1453
    rx1953_cur."!cursor_debug"("FAIL", "assertion:sym<name>")
  debug_1453:
    .return (rx1953_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block1957"  :anon :subid("400_1304456155.152") :method :outer("399_1304456155.152")
.annotate 'line', 749
    .local string rx1959_tgt
    .local int rx1959_pos
    .local int rx1959_off
    .local int rx1959_eos
    .local int rx1959_rep
    .local pmc rx1959_cur
    .local pmc rx1959_debug
    (rx1959_cur, rx1959_pos, rx1959_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1959_cur
    .local pmc match
    .lex "$/", match
    length rx1959_eos, rx1959_tgt
    gt rx1959_pos, rx1959_eos, rx1959_done
    set rx1959_off, 0
    lt rx1959_pos, 2, rx1959_start
    sub rx1959_off, rx1959_pos, 1
    substr rx1959_tgt, rx1959_tgt, rx1959_off
  rx1959_start:
    eq $I10, 1, rx1959_restart
    if_null rx1959_debug, debug_1447
    rx1959_cur."!cursor_debug"("START", "")
  debug_1447:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1960_done
    goto rxscan1960_scan
  rxscan1960_loop:
    (rx1959_pos) = rx1959_cur."from"()
    inc rx1959_pos
    rx1959_cur."!cursor_from"(rx1959_pos)
    ge rx1959_pos, rx1959_eos, rxscan1960_done
  rxscan1960_scan:
    set_addr $I10, rxscan1960_loop
    rx1959_cur."!mark_push"(0, rx1959_pos, $I10)
  rxscan1960_done:
  # rx literal  ">"
    add $I11, rx1959_pos, 1
    gt $I11, rx1959_eos, rx1959_fail
    sub $I11, rx1959_pos, rx1959_off
    ord $I11, rx1959_tgt, $I11
    ne $I11, 62, rx1959_fail
    add rx1959_pos, 1
  # rx pass
    rx1959_cur."!cursor_pass"(rx1959_pos, "")
    if_null rx1959_debug, debug_1448
    rx1959_cur."!cursor_debug"("PASS", "", " at pos=", rx1959_pos)
  debug_1448:
    .return (rx1959_cur)
  rx1959_restart:
    if_null rx1959_debug, debug_1449
    rx1959_cur."!cursor_debug"("NEXT", "")
  debug_1449:
  rx1959_fail:
    (rx1959_rep, rx1959_pos, $I10, $P10) = rx1959_cur."!mark_fail"(0)
    lt rx1959_pos, -1, rx1959_done
    eq rx1959_pos, -1, rx1959_fail
    jump $I10
  rx1959_done:
    rx1959_cur."!cursor_fail"()
    if_null rx1959_debug, debug_1450
    rx1959_cur."!cursor_debug"("FAIL", "")
  debug_1450:
    .return (rx1959_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<name>"  :subid("401_1304456155.152") :method :outer("385_1304456155.152")
.annotate 'line', 725
    $P1962 = self."!PREFIX__!subrule"("identifier", "")
    new $P1963, "ResizablePMCArray"
    push $P1963, $P1962
    .return ($P1963)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<var>"  :subid("402_1304456155.152") :method :outer("385_1304456155.152")
.annotate 'line', 725
    .local string rx1965_tgt
    .local int rx1965_pos
    .local int rx1965_off
    .local int rx1965_eos
    .local int rx1965_rep
    .local pmc rx1965_cur
    .local pmc rx1965_debug
    (rx1965_cur, rx1965_pos, rx1965_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1965_cur
    .local pmc match
    .lex "$/", match
    length rx1965_eos, rx1965_tgt
    gt rx1965_pos, rx1965_eos, rx1965_done
    set rx1965_off, 0
    lt rx1965_pos, 2, rx1965_start
    sub rx1965_off, rx1965_pos, 1
    substr rx1965_tgt, rx1965_tgt, rx1965_off
  rx1965_start:
    eq $I10, 1, rx1965_restart
    if_null rx1965_debug, debug_1454
    rx1965_cur."!cursor_debug"("START", "assertion:sym<var>")
  debug_1454:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1966_done
    goto rxscan1966_scan
  rxscan1966_loop:
    (rx1965_pos) = rx1965_cur."from"()
    inc rx1965_pos
    rx1965_cur."!cursor_from"(rx1965_pos)
    ge rx1965_pos, rx1965_eos, rxscan1966_done
  rxscan1966_scan:
    set_addr $I10, rxscan1966_loop
    rx1965_cur."!mark_push"(0, rx1965_pos, $I10)
  rxscan1966_done:
.annotate 'line', 758
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1965_pos, rx1965_off
    substr $S10, rx1965_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx1965_fail
  # rx subrule "LANG" subtype=capture negate=
    rx1965_cur."!cursor_pos"(rx1965_pos)
    $P10 = rx1965_cur."LANG"("MAIN", "variable")
    unless $P10, rx1965_fail
    rx1965_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx1965_pos = $P10."pos"()
.annotate 'line', 757
  # rx pass
    rx1965_cur."!cursor_pass"(rx1965_pos, "assertion:sym<var>")
    if_null rx1965_debug, debug_1455
    rx1965_cur."!cursor_debug"("PASS", "assertion:sym<var>", " at pos=", rx1965_pos)
  debug_1455:
    .return (rx1965_cur)
  rx1965_restart:
.annotate 'line', 725
    if_null rx1965_debug, debug_1456
    rx1965_cur."!cursor_debug"("NEXT", "assertion:sym<var>")
  debug_1456:
  rx1965_fail:
    (rx1965_rep, rx1965_pos, $I10, $P10) = rx1965_cur."!mark_fail"(0)
    lt rx1965_pos, -1, rx1965_done
    eq rx1965_pos, -1, rx1965_fail
    jump $I10
  rx1965_done:
    rx1965_cur."!cursor_fail"()
    if_null rx1965_debug, debug_1457
    rx1965_cur."!cursor_debug"("FAIL", "assertion:sym<var>")
  debug_1457:
    .return (rx1965_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<var>"  :subid("403_1304456155.152") :method :outer("385_1304456155.152")
.annotate 'line', 725
    new $P1968, "ResizablePMCArray"
    push $P1968, "$"
    push $P1968, "@"
    .return ($P1968)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "codeblock"  :subid("404_1304456155.152") :method :outer("385_1304456155.152")
.annotate 'line', 725
    .local string rx1970_tgt
    .local int rx1970_pos
    .local int rx1970_off
    .local int rx1970_eos
    .local int rx1970_rep
    .local pmc rx1970_cur
    .local pmc rx1970_debug
    (rx1970_cur, rx1970_pos, rx1970_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1970_cur
    .local pmc match
    .lex "$/", match
    length rx1970_eos, rx1970_tgt
    gt rx1970_pos, rx1970_eos, rx1970_done
    set rx1970_off, 0
    lt rx1970_pos, 2, rx1970_start
    sub rx1970_off, rx1970_pos, 1
    substr rx1970_tgt, rx1970_tgt, rx1970_off
  rx1970_start:
    eq $I10, 1, rx1970_restart
    if_null rx1970_debug, debug_1458
    rx1970_cur."!cursor_debug"("START", "codeblock")
  debug_1458:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1971_done
    goto rxscan1971_scan
  rxscan1971_loop:
    (rx1970_pos) = rx1970_cur."from"()
    inc rx1970_pos
    rx1970_cur."!cursor_from"(rx1970_pos)
    ge rx1970_pos, rx1970_eos, rxscan1971_done
  rxscan1971_scan:
    set_addr $I10, rxscan1971_loop
    rx1970_cur."!mark_push"(0, rx1970_pos, $I10)
  rxscan1971_done:
.annotate 'line', 762
  # rx subrule "LANG" subtype=capture negate=
    rx1970_cur."!cursor_pos"(rx1970_pos)
    $P10 = rx1970_cur."LANG"("MAIN", "pblock")
    unless $P10, rx1970_fail
    rx1970_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1970_pos = $P10."pos"()
.annotate 'line', 761
  # rx pass
    rx1970_cur."!cursor_pass"(rx1970_pos, "codeblock")
    if_null rx1970_debug, debug_1459
    rx1970_cur."!cursor_debug"("PASS", "codeblock", " at pos=", rx1970_pos)
  debug_1459:
    .return (rx1970_cur)
  rx1970_restart:
.annotate 'line', 725
    if_null rx1970_debug, debug_1460
    rx1970_cur."!cursor_debug"("NEXT", "codeblock")
  debug_1460:
  rx1970_fail:
    (rx1970_rep, rx1970_pos, $I10, $P10) = rx1970_cur."!mark_fail"(0)
    lt rx1970_pos, -1, rx1970_done
    eq rx1970_pos, -1, rx1970_fail
    jump $I10
  rx1970_done:
    rx1970_cur."!cursor_fail"()
    if_null rx1970_debug, debug_1461
    rx1970_cur."!cursor_debug"("FAIL", "codeblock")
  debug_1461:
    .return (rx1970_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__codeblock"  :subid("405_1304456155.152") :method :outer("385_1304456155.152")
.annotate 'line', 725
    $P1973 = self."!PREFIX__!subrule"("LANG", "")
    new $P1974, "ResizablePMCArray"
    push $P1974, $P1973
    .return ($P1974)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1975"  :subid("406_1304456155.152") :outer("10_1304456155.152")
.annotate 'line', 768
    .const 'Sub' $P5975 = "579_1304456155.152" 
    capture_lex $P5975
    .const 'Sub' $P5960 = "578_1304456155.152" 
    capture_lex $P5960
    .const 'Sub' $P5955 = "577_1304456155.152" 
    capture_lex $P5955
    .const 'Sub' $P5950 = "576_1304456155.152" 
    capture_lex $P5950
    .const 'Sub' $P5945 = "575_1304456155.152" 
    capture_lex $P5945
    .const 'Sub' $P5928 = "574_1304456155.152" 
    capture_lex $P5928
    .const 'Sub' $P5917 = "573_1304456155.152" 
    capture_lex $P5917
    .const 'Sub' $P5906 = "572_1304456155.152" 
    capture_lex $P5906
    .const 'Sub' $P5898 = "571_1304456155.152" 
    capture_lex $P5898
    .const 'Sub' $P5893 = "570_1304456155.152" 
    capture_lex $P5893
    .const 'Sub' $P5878 = "569_1304456155.152" 
    capture_lex $P5878
    .const 'Sub' $P5870 = "568_1304456155.152" 
    capture_lex $P5870
    .const 'Sub' $P5812 = "567_1304456155.152" 
    capture_lex $P5812
    .const 'Sub' $P5797 = "566_1304456155.152" 
    capture_lex $P5797
    .const 'Sub' $P5789 = "565_1304456155.152" 
    capture_lex $P5789
    .const 'Sub' $P5781 = "564_1304456155.152" 
    capture_lex $P5781
    .const 'Sub' $P5773 = "563_1304456155.152" 
    capture_lex $P5773
    .const 'Sub' $P5765 = "562_1304456155.152" 
    capture_lex $P5765
    .const 'Sub' $P5757 = "561_1304456155.152" 
    capture_lex $P5757
    .const 'Sub' $P5728 = "560_1304456155.152" 
    capture_lex $P5728
    .const 'Sub' $P5713 = "559_1304456155.152" 
    capture_lex $P5713
    .const 'Sub' $P5705 = "558_1304456155.152" 
    capture_lex $P5705
    .const 'Sub' $P5691 = "557_1304456155.152" 
    capture_lex $P5691
    .const 'Sub' $P5677 = "556_1304456155.152" 
    capture_lex $P5677
    .const 'Sub' $P5663 = "555_1304456155.152" 
    capture_lex $P5663
    .const 'Sub' $P5655 = "554_1304456155.152" 
    capture_lex $P5655
    .const 'Sub' $P5625 = "553_1304456155.152" 
    capture_lex $P5625
    .const 'Sub' $P5587 = "551_1304456155.152" 
    capture_lex $P5587
    .const 'Sub' $P5579 = "550_1304456155.152" 
    capture_lex $P5579
    .const 'Sub' $P5571 = "549_1304456155.152" 
    capture_lex $P5571
    .const 'Sub' $P5540 = "548_1304456155.152" 
    capture_lex $P5540
    .const 'Sub' $P5521 = "547_1304456155.152" 
    capture_lex $P5521
    .const 'Sub' $P5513 = "546_1304456155.152" 
    capture_lex $P5513
    .const 'Sub' $P5505 = "545_1304456155.152" 
    capture_lex $P5505
    .const 'Sub' $P5397 = "542_1304456155.152" 
    capture_lex $P5397
    .const 'Sub' $P5389 = "541_1304456155.152" 
    capture_lex $P5389
    .const 'Sub' $P5379 = "540_1304456155.152" 
    capture_lex $P5379
    .const 'Sub' $P5345 = "539_1304456155.152" 
    capture_lex $P5345
    .const 'Sub' $P5303 = "537_1304456155.152" 
    capture_lex $P5303
    .const 'Sub' $P5289 = "536_1304456155.152" 
    capture_lex $P5289
    .const 'Sub' $P5279 = "535_1304456155.152" 
    capture_lex $P5279
    .const 'Sub' $P5227 = "534_1304456155.152" 
    capture_lex $P5227
    .const 'Sub' $P4998 = "529_1304456155.152" 
    capture_lex $P4998
    .const 'Sub' $P4925 = "526_1304456155.152" 
    capture_lex $P4925
    .const 'Sub' $P4917 = "525_1304456155.152" 
    capture_lex $P4917
    .const 'Sub' $P4873 = "523_1304456155.152" 
    capture_lex $P4873
    .const 'Sub' $P4858 = "522_1304456155.152" 
    capture_lex $P4858
    .const 'Sub' $P4835 = "521_1304456155.152" 
    capture_lex $P4835
    .const 'Sub' $P4732 = "520_1304456155.152" 
    capture_lex $P4732
    .const 'Sub' $P4678 = "517_1304456155.152" 
    capture_lex $P4678
    .const 'Sub' $P4549 = "514_1304456155.152" 
    capture_lex $P4549
    .const 'Sub' $P4222 = "507_1304456155.152" 
    capture_lex $P4222
    .const 'Sub' $P4214 = "506_1304456155.152" 
    capture_lex $P4214
    .const 'Sub' $P4206 = "505_1304456155.152" 
    capture_lex $P4206
    .const 'Sub' $P4081 = "503_1304456155.152" 
    capture_lex $P4081
    .const 'Sub' $P4073 = "502_1304456155.152" 
    capture_lex $P4073
    .const 'Sub' $P4058 = "501_1304456155.152" 
    capture_lex $P4058
    .const 'Sub' $P4043 = "500_1304456155.152" 
    capture_lex $P4043
    .const 'Sub' $P4028 = "499_1304456155.152" 
    capture_lex $P4028
    .const 'Sub' $P4006 = "498_1304456155.152" 
    capture_lex $P4006
    .const 'Sub' $P3998 = "497_1304456155.152" 
    capture_lex $P3998
    .const 'Sub' $P3990 = "496_1304456155.152" 
    capture_lex $P3990
    .const 'Sub' $P3982 = "495_1304456155.152" 
    capture_lex $P3982
    .const 'Sub' $P3748 = "489_1304456155.152" 
    capture_lex $P3748
    .const 'Sub' $P3740 = "488_1304456155.152" 
    capture_lex $P3740
    .const 'Sub' $P3732 = "487_1304456155.152" 
    capture_lex $P3732
    .const 'Sub' $P3724 = "486_1304456155.152" 
    capture_lex $P3724
    .const 'Sub' $P3716 = "485_1304456155.152" 
    capture_lex $P3716
    .const 'Sub' $P3708 = "484_1304456155.152" 
    capture_lex $P3708
    .const 'Sub' $P3700 = "483_1304456155.152" 
    capture_lex $P3700
    .const 'Sub' $P3497 = "477_1304456155.152" 
    capture_lex $P3497
    .const 'Sub' $P3470 = "476_1304456155.152" 
    capture_lex $P3470
    .const 'Sub' $P3456 = "475_1304456155.152" 
    capture_lex $P3456
    .const 'Sub' $P3448 = "474_1304456155.152" 
    capture_lex $P3448
    .const 'Sub' $P3440 = "473_1304456155.152" 
    capture_lex $P3440
    .const 'Sub' $P3432 = "472_1304456155.152" 
    capture_lex $P3432
    .const 'Sub' $P3424 = "471_1304456155.152" 
    capture_lex $P3424
    .const 'Sub' $P3416 = "470_1304456155.152" 
    capture_lex $P3416
    .const 'Sub' $P3408 = "469_1304456155.152" 
    capture_lex $P3408
    .const 'Sub' $P3400 = "468_1304456155.152" 
    capture_lex $P3400
    .const 'Sub' $P3392 = "467_1304456155.152" 
    capture_lex $P3392
    .const 'Sub' $P3384 = "466_1304456155.152" 
    capture_lex $P3384
    .const 'Sub' $P3376 = "465_1304456155.152" 
    capture_lex $P3376
    .const 'Sub' $P3368 = "464_1304456155.152" 
    capture_lex $P3368
    .const 'Sub' $P3360 = "463_1304456155.152" 
    capture_lex $P3360
    .const 'Sub' $P3352 = "462_1304456155.152" 
    capture_lex $P3352
    .const 'Sub' $P3336 = "461_1304456155.152" 
    capture_lex $P3336
    .const 'Sub' $P3282 = "460_1304456155.152" 
    capture_lex $P3282
    .const 'Sub' $P3265 = "459_1304456155.152" 
    capture_lex $P3265
    .const 'Sub' $P3241 = "458_1304456155.152" 
    capture_lex $P3241
    .const 'Sub' $P3218 = "457_1304456155.152" 
    capture_lex $P3218
    .const 'Sub' $P3191 = "456_1304456155.152" 
    capture_lex $P3191
    .const 'Sub' $P3154 = "455_1304456155.152" 
    capture_lex $P3154
    .const 'Sub' $P3139 = "454_1304456155.152" 
    capture_lex $P3139
    .const 'Sub' $P3127 = "453_1304456155.152" 
    capture_lex $P3127
    .const 'Sub' $P3076 = "451_1304456155.152" 
    capture_lex $P3076
    .const 'Sub' $P3051 = "450_1304456155.152" 
    capture_lex $P3051
    .const 'Sub' $P3044 = "449_1304456155.152" 
    capture_lex $P3044
    .const 'Sub' $P3002 = "448_1304456155.152" 
    capture_lex $P3002
    .const 'Sub' $P2952 = "446_1304456155.152" 
    capture_lex $P2952
    .const 'Sub' $P2935 = "445_1304456155.152" 
    capture_lex $P2935
    .const 'Sub' $P2896 = "443_1304456155.152" 
    capture_lex $P2896
    .const 'Sub' $P2888 = "442_1304456155.152" 
    capture_lex $P2888
    .const 'Sub' $P2880 = "441_1304456155.152" 
    capture_lex $P2880
    .const 'Sub' $P2863 = "440_1304456155.152" 
    capture_lex $P2863
    .const 'Sub' $P2767 = "438_1304456155.152" 
    capture_lex $P2767
    .const 'Sub' $P2723 = "436_1304456155.152" 
    capture_lex $P2723
    .const 'Sub' $P2608 = "435_1304456155.152" 
    capture_lex $P2608
    .const 'Sub' $P2577 = "434_1304456155.152" 
    capture_lex $P2577
    .const 'Sub' $P2569 = "433_1304456155.152" 
    capture_lex $P2569
    .const 'Sub' $P2440 = "427_1304456155.152" 
    capture_lex $P2440
    .const 'Sub' $P2405 = "425_1304456155.152" 
    capture_lex $P2405
    .const 'Sub' $P2400 = "424_1304456155.152" 
    capture_lex $P2400
    .const 'Sub' $P2395 = "423_1304456155.152" 
    capture_lex $P2395
    .const 'Sub' $P2282 = "420_1304456155.152" 
    capture_lex $P2282
    .const 'Sub' $P2264 = "419_1304456155.152" 
    capture_lex $P2264
    .const 'Sub' $P2189 = "417_1304456155.152" 
    capture_lex $P2189
    .const 'Sub' $P2174 = "416_1304456155.152" 
    capture_lex $P2174
    .const 'Sub' $P2087 = "415_1304456155.152" 
    capture_lex $P2087
    .const 'Sub' $P2061 = "413_1304456155.152" 
    capture_lex $P2061
    .const 'Sub' $P2045 = "412_1304456155.152" 
    capture_lex $P2045
    .const 'Sub' $P2021 = "411_1304456155.152" 
    capture_lex $P2021
    .const 'Sub' $P1985 = "408_1304456155.152" 
    capture_lex $P1985
    .const 'Sub' $P1977 = "407_1304456155.152" 
    capture_lex $P1977
.annotate 'line', 772
    .const 'Sub' $P1977 = "407_1304456155.152" 
    newclosure $P1984, $P1977
    .lex "xblock_immediate", $P1984
.annotate 'line', 777
    .const 'Sub' $P1985 = "408_1304456155.152" 
    newclosure $P2020, $P1985
    .lex "block_immediate", $P2020
.annotate 'line', 787
    .const 'Sub' $P2021 = "411_1304456155.152" 
    newclosure $P2044, $P2021
    .lex "vivitype", $P2044
.annotate 'line', 806
    .const 'Sub' $P2045 = "412_1304456155.152" 
    newclosure $P2060, $P2045
    .lex "colonpair_str", $P2060
.annotate 'line', 968
    .const 'Sub' $P2061 = "413_1304456155.152" 
    newclosure $P2086, $P2061
    .lex "import_HOW_exports", $P2086
.annotate 'line', 1073
    .const 'Sub' $P2087 = "415_1304456155.152" 
    newclosure $P2173, $P2087
    .lex "push_block_handler", $P2173
.annotate 'line', 1579
    .const 'Sub' $P2174 = "416_1304456155.152" 
    newclosure $P2188, $P2174
    .lex "only_star_block", $P2188
.annotate 'line', 1588
    .const 'Sub' $P2189 = "417_1304456155.152" 
    newclosure $P2263, $P2189
    .lex "attach_multi_signature", $P2263
.annotate 'line', 2040
    .const 'Sub' $P2264 = "419_1304456155.152" 
    newclosure $P2281, $P2264
    .lex "control", $P2281
.annotate 'line', 2059
    .const 'Sub' $P2282 = "420_1304456155.152" 
    newclosure $P2394, $P2282
    .lex "lexical_package_lookup", $P2394
.annotate 'line', 2108
    .const 'Sub' $P2395 = "423_1304456155.152" 
    newclosure $P2399, $P2395
    .lex "is_lexical", $P2399
.annotate 'line', 2114
    .const 'Sub' $P2400 = "424_1304456155.152" 
    newclosure $P2404, $P2400
    .lex "is_package", $P2404
.annotate 'line', 2120
    .const 'Sub' $P2405 = "425_1304456155.152" 
    newclosure $P2439, $P2405
    .lex "is_scope", $P2439
.annotate 'line', 2143
    .const 'Sub' $P2440 = "427_1304456155.152" 
    newclosure $P2560, $P2440
    .lex "find_sym", $P2560
.annotate 'line', 768
    .lex "$?PACKAGE", $P2561
    .lex "$?CLASS", $P2562
.annotate 'line', 770
    new $P2563, "ResizablePMCArray"
    find_lex $P2564, "$?PACKAGE"
    get_who $P2565, $P2564
    set $P2565["@BLOCK"], $P2563
    find_lex $P2566, "xblock_immediate"
    find_lex $P2567, "block_immediate"
    find_lex $P2568, "vivitype"
.annotate 'line', 798
    find_lex $P2607, "colonpair_str"
.annotate 'line', 951
    find_lex $P3001, "import_HOW_exports"
.annotate 'line', 1066
    find_lex $P3264, "push_block_handler"
.annotate 'line', 1526
    find_lex $P4676, "only_star_block"
    find_lex $P4677, "attach_multi_signature"
.annotate 'line', 2031
    find_lex $P5944, "control"
.annotate 'line', 2053
    find_lex $P5971, "lexical_package_lookup"
    find_lex $P5972, "is_lexical"
    find_lex $P5973, "is_package"
    find_lex $P5974, "is_scope"
.annotate 'line', 2131
    find_lex $P5994, "find_sym"
.annotate 'line', 768
    .return ($P5994)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock_immediate"  :subid("407_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_1978
.annotate 'line', 772
    .lex "$xblock", param_1978
.annotate 'line', 773
    find_lex $P1979, "$xblock"
    unless_null $P1979, vivify_1462
    $P1979 = root_new ['parrot';'ResizablePMCArray']
  vivify_1462:
    set $P1980, $P1979[1]
    unless_null $P1980, vivify_1463
    new $P1980, "Undef"
  vivify_1463:
    $P1981 = "block_immediate"($P1980)
    find_lex $P1982, "$xblock"
    unless_null $P1982, vivify_1464
    $P1982 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$xblock", $P1982
  vivify_1464:
    set $P1982[1], $P1981
    find_lex $P1983, "$xblock"
    unless_null $P1983, vivify_1465
    new $P1983, "Undef"
  vivify_1465:
.annotate 'line', 772
    .return ($P1983)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block_immediate"  :subid("408_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_1986
.annotate 'line', 777
    .const 'Sub' $P1996 = "409_1304456155.152" 
    capture_lex $P1996
    .lex "$block", param_1986
.annotate 'line', 778
    find_lex $P1987, "$block"
    unless_null $P1987, vivify_1466
    new $P1987, "Undef"
  vivify_1466:
    $P1987."blocktype"("immediate")
.annotate 'line', 779
    find_lex $P1991, "$block"
    unless_null $P1991, vivify_1467
    new $P1991, "Undef"
  vivify_1467:
    $P1992 = $P1991."symtable"()
    unless $P1992, unless_1990
    set $P1989, $P1992
    goto unless_1990_end
  unless_1990:
    find_lex $P1993, "$block"
    unless_null $P1993, vivify_1468
    new $P1993, "Undef"
  vivify_1468:
    $P1994 = $P1993."handlers"()
    set $P1989, $P1994
  unless_1990_end:
    if $P1989, unless_1988_end
    .const 'Sub' $P1996 = "409_1304456155.152" 
    capture_lex $P1996
    $P1996()
  unless_1988_end:
    find_lex $P2019, "$block"
    unless_null $P2019, vivify_1475
    new $P2019, "Undef"
  vivify_1475:
.annotate 'line', 777
    .return ($P2019)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block1995"  :anon :subid("409_1304456155.152") :outer("408_1304456155.152")
.annotate 'line', 779
    .const 'Sub' $P2010 = "410_1304456155.152" 
    capture_lex $P2010
.annotate 'line', 780
    new $P1997, "Undef"
    .lex "$stmts", $P1997
    get_hll_global $P1998, "GLOBAL"
    nqp_get_package_through_who $P1999, $P1998, "PAST"
    get_who $P2000, $P1999
    set $P2001, $P2000["Stmts"]
    find_lex $P2002, "$block"
    unless_null $P2002, vivify_1469
    new $P2002, "Undef"
  vivify_1469:
    $P2003 = $P2001."new"($P2002 :named("node"))
    store_lex "$stmts", $P2003
.annotate 'line', 781
    find_lex $P2005, "$block"
    unless_null $P2005, vivify_1470
    new $P2005, "Undef"
  vivify_1470:
    $P2006 = $P2005."list"()
    defined $I2007, $P2006
    unless $I2007, for_undef_1471
    iter $P2004, $P2006
    new $P2016, 'ExceptionHandler'
    set_label $P2016, loop2015_handler
    $P2016."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2016
  loop2015_test:
    unless $P2004, loop2015_done
    shift $P2008, $P2004
  loop2015_redo:
    .const 'Sub' $P2010 = "410_1304456155.152" 
    capture_lex $P2010
    $P2010($P2008)
  loop2015_next:
    goto loop2015_test
  loop2015_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2017, exception, 'type'
    eq $P2017, .CONTROL_LOOP_NEXT, loop2015_next
    eq $P2017, .CONTROL_LOOP_REDO, loop2015_redo
  loop2015_done:
    pop_eh 
  for_undef_1471:
.annotate 'line', 782
    find_lex $P2018, "$stmts"
    unless_null $P2018, vivify_1474
    new $P2018, "Undef"
  vivify_1474:
    store_lex "$block", $P2018
.annotate 'line', 779
    .return ($P2018)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2009"  :anon :subid("410_1304456155.152") :outer("409_1304456155.152")
    .param pmc param_2011
.annotate 'line', 781
    .lex "$_", param_2011
    find_lex $P2012, "$stmts"
    unless_null $P2012, vivify_1472
    new $P2012, "Undef"
  vivify_1472:
    find_lex $P2013, "$_"
    unless_null $P2013, vivify_1473
    new $P2013, "Undef"
  vivify_1473:
    $P2014 = $P2012."push"($P2013)
    .return ($P2014)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "vivitype"  :subid("411_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_2022
.annotate 'line', 787
    .lex "$sigil", param_2022
.annotate 'line', 788
    find_lex $P2025, "$sigil"
    unless_null $P2025, vivify_1476
    new $P2025, "Undef"
  vivify_1476:
    set $S2026, $P2025
    iseq $I2027, $S2026, "%"
    if $I2027, if_2024
.annotate 'line', 790
    find_lex $P2035, "$sigil"
    unless_null $P2035, vivify_1477
    new $P2035, "Undef"
  vivify_1477:
    set $S2036, $P2035
    iseq $I2037, $S2036, "@"
    if $I2037, if_2034
    new $P2043, "String"
    assign $P2043, "Undef"
    set $P2033, $P2043
    goto if_2034_end
  if_2034:
.annotate 'line', 791
    get_hll_global $P2038, "GLOBAL"
    nqp_get_package_through_who $P2039, $P2038, "PAST"
    get_who $P2040, $P2039
    set $P2041, $P2040["Op"]
    $P2042 = $P2041."new"("    %r = root_new ['parrot';'ResizablePMCArray']" :named("inline"))
    set $P2033, $P2042
  if_2034_end:
    set $P2023, $P2033
.annotate 'line', 788
    goto if_2024_end
  if_2024:
.annotate 'line', 789
    get_hll_global $P2028, "GLOBAL"
    nqp_get_package_through_who $P2029, $P2028, "PAST"
    get_who $P2030, $P2029
    set $P2031, $P2030["Op"]
    $P2032 = $P2031."new"("    %r = root_new ['parrot';'Hash']" :named("inline"))
    set $P2023, $P2032
  if_2024_end:
.annotate 'line', 787
    .return ($P2023)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair_str"  :subid("412_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_2046
.annotate 'line', 806
    .lex "$ast", param_2046
.annotate 'line', 807
    get_hll_global $P2049, "GLOBAL"
    nqp_get_package_through_who $P2050, $P2049, "PAST"
    get_who $P2051, $P2050
    set $P2052, $P2051["Op"]
    find_lex $P2053, "$ast"
    unless_null $P2053, vivify_1478
    new $P2053, "Undef"
  vivify_1478:
    $P2054 = $P2052."ACCEPTS"($P2053)
    if $P2054, if_2048
.annotate 'line', 809
    find_lex $P2058, "$ast"
    unless_null $P2058, vivify_1479
    new $P2058, "Undef"
  vivify_1479:
    $P2059 = $P2058."value"()
    set $P2047, $P2059
.annotate 'line', 807
    goto if_2048_end
  if_2048:
.annotate 'line', 808
    find_lex $P2055, "$ast"
    unless_null $P2055, vivify_1480
    new $P2055, "Undef"
  vivify_1480:
    $P2056 = $P2055."list"()
    join $S2057, " ", $P2056
    new $P2047, 'String'
    set $P2047, $S2057
  if_2048_end:
.annotate 'line', 806
    .return ($P2047)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "import_HOW_exports"  :subid("413_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_2062
.annotate 'line', 968
    .const 'Sub' $P2074 = "414_1304456155.152" 
    capture_lex $P2074
    .lex "$UNIT", param_2062
.annotate 'line', 970
    find_lex $P2065, "$UNIT"
    unless_null $P2065, vivify_1481
    new $P2065, "Undef"
  vivify_1481:
    exists $I2066, $P2065["EXPORTHOW"]
    if $I2066, if_2064
    new $P2063, 'Integer'
    set $P2063, $I2066
    goto if_2064_end
  if_2064:
.annotate 'line', 971
    find_lex $P2068, "$UNIT"
    unless_null $P2068, vivify_1482
    $P2068 = root_new ['parrot';'Hash']
  vivify_1482:
    set $P2069, $P2068["EXPORTHOW"]
    unless_null $P2069, vivify_1483
    new $P2069, "Undef"
  vivify_1483:
    get_who $P2070, $P2069
    defined $I2071, $P2070
    unless $I2071, for_undef_1484
    iter $P2067, $P2070
    new $P2084, 'ExceptionHandler'
    set_label $P2084, loop2083_handler
    $P2084."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2084
  loop2083_test:
    unless $P2067, loop2083_done
    shift $P2072, $P2067
  loop2083_redo:
    .const 'Sub' $P2074 = "414_1304456155.152" 
    capture_lex $P2074
    $P2074($P2072)
  loop2083_next:
    goto loop2083_test
  loop2083_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2085, exception, 'type'
    eq $P2085, .CONTROL_LOOP_NEXT, loop2083_next
    eq $P2085, .CONTROL_LOOP_REDO, loop2083_redo
  loop2083_done:
    pop_eh 
  for_undef_1484:
.annotate 'line', 970
    set $P2063, $P2067
  if_2064_end:
.annotate 'line', 968
    .return ($P2063)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2073"  :anon :subid("414_1304456155.152") :outer("413_1304456155.152")
    .param pmc param_2075
.annotate 'line', 971
    .lex "$_", param_2075
.annotate 'line', 972
    find_lex $P2076, "$_"
    unless_null $P2076, vivify_1485
    new $P2076, "Undef"
  vivify_1485:
    $P2077 = $P2076."value"()
    find_lex $P2078, "$_"
    unless_null $P2078, vivify_1486
    new $P2078, "Undef"
  vivify_1486:
    $P2079 = $P2078."key"()
    find_dynamic_lex $P2082, "%*HOW"
    unless_null $P2082, vivify_1487
    get_hll_global $P2080, "GLOBAL"
    get_who $P2081, $P2080
    set $P2082, $P2081["%HOW"]
    unless_null $P2082, vivify_1488
    die "Contextual %*HOW not found"
  vivify_1488:
    store_dynamic_lex "%*HOW", $P2082
  vivify_1487:
    set $P2082[$P2079], $P2077
.annotate 'line', 971
    .return ($P2077)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "push_block_handler"  :subid("415_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_2088
    .param pmc param_2089
.annotate 'line', 1073
    .lex "$/", param_2088
    .lex "$block", param_2089
.annotate 'line', 1074
    find_lex $P2091, "$?PACKAGE"
    get_who $P2092, $P2091
    set $P2093, $P2092["@BLOCK"]
    unless_null $P2093, vivify_1489
    $P2093 = root_new ['parrot';'ResizablePMCArray']
  vivify_1489:
    set $P2094, $P2093[0]
    unless_null $P2094, vivify_1490
    new $P2094, "Undef"
  vivify_1490:
    $P2095 = $P2094."handlers"()
    if $P2095, unless_2090_end
.annotate 'line', 1075
    find_lex $P2096, "$?PACKAGE"
    get_who $P2097, $P2096
    set $P2098, $P2097["@BLOCK"]
    unless_null $P2098, vivify_1491
    $P2098 = root_new ['parrot';'ResizablePMCArray']
  vivify_1491:
    set $P2099, $P2098[0]
    unless_null $P2099, vivify_1492
    new $P2099, "Undef"
  vivify_1492:
    new $P2100, "ResizablePMCArray"
    $P2099."handlers"($P2100)
  unless_2090_end:
.annotate 'line', 1077
    find_lex $P2102, "$block"
    unless_null $P2102, vivify_1493
    new $P2102, "Undef"
  vivify_1493:
    $P2103 = $P2102."arity"()
    if $P2103, unless_2101_end
.annotate 'line', 1078
    find_lex $P2104, "$block"
    unless_null $P2104, vivify_1494
    new $P2104, "Undef"
  vivify_1494:
.annotate 'line', 1079
    get_hll_global $P2105, "GLOBAL"
    nqp_get_package_through_who $P2106, $P2105, "PAST"
    get_who $P2107, $P2106
    set $P2108, $P2107["Op"]
.annotate 'line', 1080
    get_hll_global $P2109, "GLOBAL"
    nqp_get_package_through_who $P2110, $P2109, "PAST"
    get_who $P2111, $P2110
    set $P2112, $P2111["Var"]
    $P2113 = $P2112."new"("lexical" :named("scope"), "$!" :named("name"), 1 :named("isdecl"))
.annotate 'line', 1081
    get_hll_global $P2114, "GLOBAL"
    nqp_get_package_through_who $P2115, $P2114, "PAST"
    get_who $P2116, $P2115
    set $P2117, $P2116["Var"]
    $P2118 = $P2117."new"("lexical" :named("scope"), "$_" :named("name"))
    $P2119 = $P2108."new"($P2113, $P2118, "bind" :named("pasttype"))
.annotate 'line', 1079
    $P2104."unshift"($P2119)
.annotate 'line', 1084
    find_lex $P2120, "$block"
    unless_null $P2120, vivify_1495
    new $P2120, "Undef"
  vivify_1495:
    get_hll_global $P2121, "GLOBAL"
    nqp_get_package_through_who $P2122, $P2121, "PAST"
    get_who $P2123, $P2122
    set $P2124, $P2123["Var"]
    $P2125 = $P2124."new"("$_" :named("name"), "parameter" :named("scope"))
    $P2120."unshift"($P2125)
.annotate 'line', 1085
    find_lex $P2126, "$block"
    unless_null $P2126, vivify_1496
    new $P2126, "Undef"
  vivify_1496:
    $P2126."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 1086
    find_lex $P2127, "$block"
    unless_null $P2127, vivify_1497
    new $P2127, "Undef"
  vivify_1497:
    $P2127."symbol"("$!", "lexical" :named("scope"))
.annotate 'line', 1087
    find_lex $P2128, "$block"
    unless_null $P2128, vivify_1498
    new $P2128, "Undef"
  vivify_1498:
    $P2128."arity"(1)
  unless_2101_end:
.annotate 'line', 1089
    find_lex $P2129, "$block"
    unless_null $P2129, vivify_1499
    new $P2129, "Undef"
  vivify_1499:
    $P2129."blocktype"("declaration")
.annotate 'line', 1090
    find_lex $P2130, "$?PACKAGE"
    get_who $P2131, $P2130
    set $P2132, $P2131["@BLOCK"]
    unless_null $P2132, vivify_1500
    $P2132 = root_new ['parrot';'ResizablePMCArray']
  vivify_1500:
    set $P2133, $P2132[0]
    unless_null $P2133, vivify_1501
    new $P2133, "Undef"
  vivify_1501:
    $P2134 = $P2133."handlers"()
.annotate 'line', 1091
    get_hll_global $P2135, "GLOBAL"
    nqp_get_package_through_who $P2136, $P2135, "PAST"
    get_who $P2137, $P2136
    set $P2138, $P2137["Control"]
    find_lex $P2139, "$/"
    unless_null $P2139, vivify_1502
    new $P2139, "Undef"
  vivify_1502:
.annotate 'line', 1093
    get_hll_global $P2140, "GLOBAL"
    nqp_get_package_through_who $P2141, $P2140, "PAST"
    get_who $P2142, $P2141
    set $P2143, $P2142["Stmts"]
.annotate 'line', 1094
    get_hll_global $P2144, "GLOBAL"
    nqp_get_package_through_who $P2145, $P2144, "PAST"
    get_who $P2146, $P2145
    set $P2147, $P2146["Op"]
    find_lex $P2148, "$block"
    unless_null $P2148, vivify_1503
    new $P2148, "Undef"
  vivify_1503:
.annotate 'line', 1096
    get_hll_global $P2149, "GLOBAL"
    nqp_get_package_through_who $P2150, $P2149, "PAST"
    get_who $P2151, $P2150
    set $P2152, $P2151["Var"]
    $P2153 = $P2152."new"("register" :named("scope"), "exception" :named("name"))
    $P2154 = $P2147."new"($P2148, $P2153, "call" :named("pasttype"))
.annotate 'line', 1098
    get_hll_global $P2155, "GLOBAL"
    nqp_get_package_through_who $P2156, $P2155, "PAST"
    get_who $P2157, $P2156
    set $P2158, $P2157["Op"]
.annotate 'line', 1099
    get_hll_global $P2159, "GLOBAL"
    nqp_get_package_through_who $P2160, $P2159, "PAST"
    get_who $P2161, $P2160
    set $P2162, $P2161["Var"]
.annotate 'line', 1100
    get_hll_global $P2163, "GLOBAL"
    nqp_get_package_through_who $P2164, $P2163, "PAST"
    get_who $P2165, $P2164
    set $P2166, $P2165["Var"]
    $P2167 = $P2166."new"("register" :named("scope"), "exception" :named("name"))
    $P2168 = $P2162."new"($P2167, "handled", "keyed" :named("scope"))
.annotate 'line', 1099
    $P2169 = $P2158."new"($P2168, 1, "bind" :named("pasttype"))
.annotate 'line', 1098
    $P2170 = $P2143."new"($P2154, $P2169)
.annotate 'line', 1093
    $P2171 = $P2138."new"($P2170, $P2139 :named("node"))
.annotate 'line', 1091
    $P2172 = $P2134."unshift"($P2171)
.annotate 'line', 1073
    .return ($P2172)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "only_star_block"  :subid("416_1304456155.152") :outer("406_1304456155.152")
.annotate 'line', 1580
    new $P2175, "Undef"
    .lex "$past", $P2175
    find_lex $P2176, "$?PACKAGE"
    get_who $P2177, $P2176
    set $P2178, $P2177["@BLOCK"]
    unless_null $P2178, vivify_1504
    $P2178 = root_new ['parrot';'ResizablePMCArray']
  vivify_1504:
    $P2179 = $P2178."shift"()
    store_lex "$past", $P2179
.annotate 'line', 1581
    find_lex $P2180, "$past"
    unless_null $P2180, vivify_1505
    new $P2180, "Undef"
  vivify_1505:
    $P2180."closure"(1)
.annotate 'line', 1582
    find_lex $P2181, "$past"
    unless_null $P2181, vivify_1506
    new $P2181, "Undef"
  vivify_1506:
    get_hll_global $P2182, "GLOBAL"
    nqp_get_package_through_who $P2183, $P2182, "PAST"
    get_who $P2184, $P2183
    set $P2185, $P2184["Op"]
    $P2186 = $P2185."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P2181."push"($P2186)
    find_lex $P2187, "$past"
    unless_null $P2187, vivify_1507
    new $P2187, "Undef"
  vivify_1507:
.annotate 'line', 1579
    .return ($P2187)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "attach_multi_signature"  :subid("417_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_2190
.annotate 'line', 1588
    .const 'Sub' $P2210 = "418_1304456155.152" 
    capture_lex $P2210
    .lex "$routine", param_2190
.annotate 'line', 1592
    new $P2191, "Undef"
    .lex "$types", $P2191
.annotate 'line', 1593
    new $P2192, "Undef"
    .lex "$definednesses", $P2192
.annotate 'line', 1592
    get_hll_global $P2193, "GLOBAL"
    nqp_get_package_through_who $P2194, $P2193, "PAST"
    get_who $P2195, $P2194
    set $P2196, $P2195["Op"]
    $P2197 = $P2196."new"("list" :named("pasttype"))
    store_lex "$types", $P2197
.annotate 'line', 1593
    get_hll_global $P2198, "GLOBAL"
    nqp_get_package_through_who $P2199, $P2198, "PAST"
    get_who $P2200, $P2199
    set $P2201, $P2200["Op"]
    $P2202 = $P2201."new"("list" :named("pasttype"))
    store_lex "$definednesses", $P2202
.annotate 'line', 1594
    find_lex $P2204, "$routine"
    unless_null $P2204, vivify_1508
    $P2204 = root_new ['parrot';'ResizablePMCArray']
  vivify_1508:
    set $P2205, $P2204[0]
    unless_null $P2205, vivify_1509
    new $P2205, "Undef"
  vivify_1509:
    $P2206 = $P2205."list"()
    defined $I2207, $P2206
    unless $I2207, for_undef_1510
    iter $P2203, $P2206
    new $P2254, 'ExceptionHandler'
    set_label $P2254, loop2253_handler
    $P2254."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2254
  loop2253_test:
    unless $P2203, loop2253_done
    shift $P2208, $P2203
  loop2253_redo:
    .const 'Sub' $P2210 = "418_1304456155.152" 
    capture_lex $P2210
    $P2210($P2208)
  loop2253_next:
    goto loop2253_test
  loop2253_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2255, exception, 'type'
    eq $P2255, .CONTROL_LOOP_NEXT, loop2253_next
    eq $P2255, .CONTROL_LOOP_REDO, loop2253_redo
  loop2253_done:
    pop_eh 
  for_undef_1510:
.annotate 'line', 1601
    find_dynamic_lex $P2258, "$*SC"
    unless_null $P2258, vivify_1520
    get_hll_global $P2256, "GLOBAL"
    get_who $P2257, $P2256
    set $P2258, $P2257["$SC"]
    unless_null $P2258, vivify_1521
    die "Contextual $*SC not found"
  vivify_1521:
  vivify_1520:
    find_lex $P2259, "$routine"
    unless_null $P2259, vivify_1522
    new $P2259, "Undef"
  vivify_1522:
    find_lex $P2260, "$types"
    unless_null $P2260, vivify_1523
    new $P2260, "Undef"
  vivify_1523:
    find_lex $P2261, "$definednesses"
    unless_null $P2261, vivify_1524
    new $P2261, "Undef"
  vivify_1524:
    $P2262 = $P2258."set_routine_signature"($P2259, $P2260, $P2261)
.annotate 'line', 1588
    .return ($P2262)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2209"  :anon :subid("418_1304456155.152") :outer("417_1304456155.152")
    .param pmc param_2211
.annotate 'line', 1594
    .lex "$_", param_2211
.annotate 'line', 1595
    get_hll_global $P2216, "GLOBAL"
    nqp_get_package_through_who $P2217, $P2216, "PAST"
    get_who $P2218, $P2217
    set $P2219, $P2218["Var"]
    find_lex $P2220, "$_"
    unless_null $P2220, vivify_1511
    new $P2220, "Undef"
  vivify_1511:
    $P2221 = $P2219."ACCEPTS"($P2220)
    if $P2221, if_2215
    set $P2214, $P2221
    goto if_2215_end
  if_2215:
    find_lex $P2222, "$_"
    unless_null $P2222, vivify_1512
    new $P2222, "Undef"
  vivify_1512:
    $S2223 = $P2222."scope"()
    iseq $I2224, $S2223, "parameter"
    new $P2214, 'Integer'
    set $P2214, $I2224
  if_2215_end:
    if $P2214, if_2213
    set $P2212, $P2214
    goto if_2213_end
  if_2213:
.annotate 'line', 1596
    find_lex $P2225, "$types"
    unless_null $P2225, vivify_1513
    new $P2225, "Undef"
  vivify_1513:
    find_lex $P2227, "$_"
    unless_null $P2227, vivify_1514
    new $P2227, "Undef"
  vivify_1514:
    $P2228 = $P2227."multitype"()
    set $P2226, $P2228
    defined $I2230, $P2226
    if $I2230, default_2229
    get_hll_global $P2231, "GLOBAL"
    nqp_get_package_through_who $P2232, $P2231, "PAST"
    get_who $P2233, $P2232
    set $P2234, $P2233["Op"]
    $P2235 = $P2234."new"("null P" :named("pirop"))
    set $P2226, $P2235
  default_2229:
    $P2225."push"($P2226)
.annotate 'line', 1597
    find_lex $P2236, "$definednesses"
    unless_null $P2236, vivify_1515
    new $P2236, "Undef"
  vivify_1515:
    find_lex $P2239, "$_"
    unless_null $P2239, vivify_1516
    $P2239 = root_new ['parrot';'Hash']
  vivify_1516:
    set $P2240, $P2239["definedness"]
    unless_null $P2240, vivify_1517
    new $P2240, "Undef"
  vivify_1517:
    set $S2241, $P2240
    iseq $I2242, $S2241, "D"
    if $I2242, if_2238
.annotate 'line', 1598
    find_lex $P2246, "$_"
    unless_null $P2246, vivify_1518
    $P2246 = root_new ['parrot';'Hash']
  vivify_1518:
    set $P2247, $P2246["definedness"]
    unless_null $P2247, vivify_1519
    new $P2247, "Undef"
  vivify_1519:
    set $S2248, $P2247
    iseq $I2249, $S2248, "U"
    if $I2249, if_2245
    new $P2251, "Integer"
    assign $P2251, 0
    set $P2244, $P2251
    goto if_2245_end
  if_2245:
    new $P2250, "Integer"
    assign $P2250, 2
    set $P2244, $P2250
  if_2245_end:
    set $P2237, $P2244
.annotate 'line', 1597
    goto if_2238_end
  if_2238:
    new $P2243, "Integer"
    assign $P2243, 1
    set $P2237, $P2243
  if_2238_end:
    $P2252 = $P2236."push"($P2237)
.annotate 'line', 1595
    set $P2212, $P2252
  if_2213_end:
.annotate 'line', 1594
    .return ($P2212)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "control"  :subid("419_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_2265
    .param pmc param_2266
.annotate 'line', 2040
    .lex "$/", param_2265
    .lex "$type", param_2266
.annotate 'line', 2041
    find_lex $P2267, "$/"
    get_hll_global $P2268, "GLOBAL"
    nqp_get_package_through_who $P2269, $P2268, "PAST"
    get_who $P2270, $P2269
    set $P2271, $P2270["Op"]
    find_lex $P2272, "$/"
    unless_null $P2272, vivify_1525
    new $P2272, "Undef"
  vivify_1525:
.annotate 'line', 2045
    get_hll_global $P2273, "GLOBAL"
    nqp_get_package_through_who $P2274, $P2273, "PAST"
    get_who $P2275, $P2274
    set $P2276, $P2275["Val"]
    find_lex $P2277, "$type"
    unless_null $P2277, vivify_1526
    new $P2277, "Undef"
  vivify_1526:
    $P2278 = $P2276."new"($P2277 :named("value"), "!except_types" :named("returns"))
    $P2279 = $P2271."new"(0, $P2278, $P2272 :named("node"), "die__vii" :named("pirop"))
.annotate 'line', 2041
    $P2280 = $P2267."!make"($P2279)
.annotate 'line', 2040
    .return ($P2280)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "lexical_package_lookup"  :subid("420_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_2285
    .param pmc param_2286
.annotate 'line', 2059
    .const 'Sub' $P2339 = "421_1304456155.152" 
    capture_lex $P2339
    new $P2284, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2284, control_2283
    push_eh $P2284
    .lex "@name", param_2285
    .lex "$/", param_2286
.annotate 'line', 2065
    new $P2287, "Undef"
    .lex "$final_name", $P2287
.annotate 'line', 2066
    new $P2288, "Undef"
    .lex "$lookup", $P2288
.annotate 'line', 2061
    find_lex $P2290, "@name"
    unless_null $P2290, vivify_1527
    $P2290 = root_new ['parrot';'ResizablePMCArray']
  vivify_1527:
    set $N2291, $P2290
    iseq $I2292, $N2291, 0.0
    unless $I2292, if_2289_end
    find_lex $P2293, "$/"
    unless_null $P2293, vivify_1528
    new $P2293, "Undef"
  vivify_1528:
    $P2294 = $P2293."CURSOR"()
    $P2294."panic"("Cannot compile empty name")
  if_2289_end:
.annotate 'line', 2065
    find_lex $P2295, "@name"
    unless_null $P2295, vivify_1529
    $P2295 = root_new ['parrot';'ResizablePMCArray']
  vivify_1529:
    $P2296 = $P2295."pop"()
    store_lex "$final_name", $P2296
.annotate 'line', 2066
    get_hll_global $P2297, "GLOBAL"
    nqp_get_package_through_who $P2298, $P2297, "PAST"
    get_who $P2299, $P2298
    set $P2300, $P2299["Var"]
    find_lex $P2301, "$final_name"
    unless_null $P2301, vivify_1530
    new $P2301, "Undef"
  vivify_1530:
    set $S2302, $P2301
    $P2303 = $P2300."new"($S2302, "keyed" :named("scope"))
    store_lex "$lookup", $P2303
.annotate 'line', 2070
    find_lex $P2305, "@name"
    unless_null $P2305, vivify_1531
    $P2305 = root_new ['parrot';'ResizablePMCArray']
  vivify_1531:
    set $N2306, $P2305
    iseq $I2307, $N2306, 0.0
    if $I2307, if_2304
.annotate 'line', 2088
    .const 'Sub' $P2339 = "421_1304456155.152" 
    capture_lex $P2339
    $P2339()
    goto if_2304_end
  if_2304:
.annotate 'line', 2071
    find_lex $P2308, "$lookup"
    unless_null $P2308, vivify_1544
    new $P2308, "Undef"
  vivify_1544:
    get_hll_global $P2309, "GLOBAL"
    nqp_get_package_through_who $P2310, $P2309, "PAST"
    get_who $P2311, $P2310
    set $P2312, $P2311["Op"]
.annotate 'line', 2073
    get_hll_global $P2313, "GLOBAL"
    nqp_get_package_through_who $P2314, $P2313, "PAST"
    get_who $P2315, $P2314
    set $P2316, $P2315["Var"]
    $P2317 = $P2316."new"("$?PACKAGE" :named("name"), "lexical" :named("scope"))
    $P2318 = $P2312."new"($P2317, "get_who PP" :named("pirop"))
.annotate 'line', 2071
    $P2308."unshift"($P2318)
.annotate 'line', 2075
    find_lex $P2319, "$lookup"
    unless_null $P2319, vivify_1545
    new $P2319, "Undef"
  vivify_1545:
    get_hll_global $P2320, "GLOBAL"
    nqp_get_package_through_who $P2321, $P2320, "PAST"
    get_who $P2322, $P2321
    set $P2323, $P2322["Var"]
.annotate 'line', 2077
    get_hll_global $P2324, "GLOBAL"
    nqp_get_package_through_who $P2325, $P2324, "PAST"
    get_who $P2326, $P2325
    set $P2327, $P2326["Op"]
.annotate 'line', 2079
    get_hll_global $P2328, "GLOBAL"
    nqp_get_package_through_who $P2329, $P2328, "PAST"
    get_who $P2330, $P2329
    set $P2331, $P2330["Var"]
    new $P2332, "ResizablePMCArray"
    $P2333 = $P2331."new"("GLOBAL" :named("name"), $P2332 :named("namespace"), "package" :named("scope"))
    $P2334 = $P2327."new"($P2333, "get_who PP" :named("pirop"))
.annotate 'line', 2081
    find_lex $P2335, "$final_name"
    unless_null $P2335, vivify_1546
    new $P2335, "Undef"
  vivify_1546:
    set $S2336, $P2335
    $P2337 = $P2323."new"($P2334, $S2336, "keyed" :named("scope"))
.annotate 'line', 2075
    $P2319."viviself"($P2337)
  if_2304_end:
.annotate 'line', 2103
    new $P2391, "Exception"
    set $P2391['type'], .CONTROL_RETURN
    find_lex $P2392, "$lookup"
    unless_null $P2392, vivify_1547
    new $P2392, "Undef"
  vivify_1547:
    setattribute $P2391, 'payload', $P2392
    throw $P2391
.annotate 'line', 2059
    .return ()
  control_2283:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2393, exception, "payload"
    .return ($P2393)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2338"  :anon :subid("421_1304456155.152") :outer("420_1304456155.152")
.annotate 'line', 2088
    .const 'Sub' $P2370 = "422_1304456155.152" 
    capture_lex $P2370
.annotate 'line', 2089
    new $P2340, "Undef"
    .lex "$path", $P2340
    find_lex $P2343, "@name"
    unless_null $P2343, vivify_1532
    $P2343 = root_new ['parrot';'ResizablePMCArray']
  vivify_1532:
    set $P2344, $P2343[0]
    unless_null $P2344, vivify_1533
    new $P2344, "Undef"
  vivify_1533:
    $P2345 = "is_lexical"($P2344)
    if $P2345, if_2342
.annotate 'line', 2091
    get_hll_global $P2353, "GLOBAL"
    nqp_get_package_through_who $P2354, $P2353, "PAST"
    get_who $P2355, $P2354
    set $P2356, $P2355["Var"]
    new $P2357, "ResizablePMCArray"
    $P2358 = $P2356."new"("GLOBAL" :named("name"), $P2357 :named("namespace"), "package" :named("scope"))
    set $P2341, $P2358
.annotate 'line', 2089
    goto if_2342_end
  if_2342:
.annotate 'line', 2090
    get_hll_global $P2346, "GLOBAL"
    nqp_get_package_through_who $P2347, $P2346, "PAST"
    get_who $P2348, $P2347
    set $P2349, $P2348["Var"]
    find_lex $P2350, "@name"
    unless_null $P2350, vivify_1534
    $P2350 = root_new ['parrot';'ResizablePMCArray']
  vivify_1534:
    $P2351 = $P2350."shift"()
    $P2352 = $P2349."new"($P2351 :named("name"), "lexical" :named("scope"))
    set $P2341, $P2352
  if_2342_end:
.annotate 'line', 2089
    store_lex "$path", $P2341
.annotate 'line', 2092
    find_lex $P2360, "@name"
    unless_null $P2360, vivify_1535
    $P2360 = root_new ['parrot';'ResizablePMCArray']
  vivify_1535:
    set $P2361, $P2360[0]
    unless_null $P2361, vivify_1536
    new $P2361, "Undef"
  vivify_1536:
    set $S2362, $P2361
    iseq $I2363, $S2362, "GLOBAL"
    unless $I2363, if_2359_end
.annotate 'line', 2093
    find_lex $P2364, "@name"
    unless_null $P2364, vivify_1537
    $P2364 = root_new ['parrot';'ResizablePMCArray']
  vivify_1537:
    $P2364."shift"()
  if_2359_end:
.annotate 'line', 2095
    find_lex $P2366, "@name"
    unless_null $P2366, vivify_1538
    $P2366 = root_new ['parrot';'ResizablePMCArray']
  vivify_1538:
    defined $I2367, $P2366
    unless $I2367, for_undef_1539
    iter $P2365, $P2366
    new $P2381, 'ExceptionHandler'
    set_label $P2381, loop2380_handler
    $P2381."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2381
  loop2380_test:
    unless $P2365, loop2380_done
    shift $P2368, $P2365
  loop2380_redo:
    .const 'Sub' $P2370 = "422_1304456155.152" 
    capture_lex $P2370
    $P2370($P2368)
  loop2380_next:
    goto loop2380_test
  loop2380_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2382, exception, 'type'
    eq $P2382, .CONTROL_LOOP_NEXT, loop2380_next
    eq $P2382, .CONTROL_LOOP_REDO, loop2380_redo
  loop2380_done:
    pop_eh 
  for_undef_1539:
.annotate 'line', 2100
    find_lex $P2383, "$lookup"
    unless_null $P2383, vivify_1542
    new $P2383, "Undef"
  vivify_1542:
    get_hll_global $P2384, "GLOBAL"
    nqp_get_package_through_who $P2385, $P2384, "PAST"
    get_who $P2386, $P2385
    set $P2387, $P2386["Op"]
    find_lex $P2388, "$path"
    unless_null $P2388, vivify_1543
    new $P2388, "Undef"
  vivify_1543:
    $P2389 = $P2387."new"($P2388, "get_who PP" :named("pirop"))
    $P2390 = $P2383."unshift"($P2389)
.annotate 'line', 2088
    .return ($P2390)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2369"  :anon :subid("422_1304456155.152") :outer("421_1304456155.152")
    .param pmc param_2371
.annotate 'line', 2095
    .lex "$_", param_2371
.annotate 'line', 2096
    get_hll_global $P2372, "GLOBAL"
    nqp_get_package_through_who $P2373, $P2372, "PAST"
    get_who $P2374, $P2373
    set $P2375, $P2374["Op"]
    find_lex $P2376, "$path"
    unless_null $P2376, vivify_1540
    new $P2376, "Undef"
  vivify_1540:
.annotate 'line', 2098
    find_lex $P2377, "$_"
    unless_null $P2377, vivify_1541
    new $P2377, "Undef"
  vivify_1541:
    set $S2378, $P2377
    $P2379 = $P2375."new"($P2376, $S2378, "nqp_get_package_through_who PPs" :named("pirop"))
.annotate 'line', 2096
    store_lex "$path", $P2379
.annotate 'line', 2095
    .return ($P2379)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "is_lexical"  :subid("423_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_2396
.annotate 'line', 2108
    .lex "$name", param_2396
.annotate 'line', 2109
    find_lex $P2397, "$name"
    unless_null $P2397, vivify_1548
    new $P2397, "Undef"
  vivify_1548:
    $P2398 = "is_scope"($P2397, "lexical")
.annotate 'line', 2108
    .return ($P2398)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "is_package"  :subid("424_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_2401
.annotate 'line', 2114
    .lex "$name", param_2401
.annotate 'line', 2115
    find_lex $P2402, "$name"
    unless_null $P2402, vivify_1549
    new $P2402, "Undef"
  vivify_1549:
    $P2403 = "is_scope"($P2402, "package")
.annotate 'line', 2114
    .return ($P2403)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "is_scope"  :subid("425_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_2408
    .param pmc param_2409
.annotate 'line', 2120
    .const 'Sub' $P2417 = "426_1304456155.152" 
    capture_lex $P2417
    new $P2407, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2407, control_2406
    push_eh $P2407
    .lex "$name", param_2408
    .lex "$wanted_scope", param_2409
.annotate 'line', 2121
    find_lex $P2411, "$?PACKAGE"
    get_who $P2412, $P2411
    set $P2413, $P2412["@BLOCK"]
    unless_null $P2413, vivify_1550
    $P2413 = root_new ['parrot';'ResizablePMCArray']
  vivify_1550:
    defined $I2414, $P2413
    unless $I2414, for_undef_1551
    iter $P2410, $P2413
    new $P2436, 'ExceptionHandler'
    set_label $P2436, loop2435_handler
    $P2436."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2436
  loop2435_test:
    unless $P2410, loop2435_done
    shift $P2415, $P2410
  loop2435_redo:
    .const 'Sub' $P2417 = "426_1304456155.152" 
    capture_lex $P2417
    $P2417($P2415)
  loop2435_next:
    goto loop2435_test
  loop2435_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2437, exception, 'type'
    eq $P2437, .CONTROL_LOOP_NEXT, loop2435_next
    eq $P2437, .CONTROL_LOOP_REDO, loop2435_redo
  loop2435_done:
    pop_eh 
  for_undef_1551:
.annotate 'line', 2120
    .return (0)
  control_2406:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2438, exception, "payload"
    .return ($P2438)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2416"  :anon :subid("426_1304456155.152") :outer("425_1304456155.152")
    .param pmc param_2419
.annotate 'line', 2122
    $P2418 = root_new ['parrot';'Hash']
    .lex "%sym", $P2418
    .lex "$_", param_2419
    find_lex $P2420, "$_"
    unless_null $P2420, vivify_1552
    new $P2420, "Undef"
  vivify_1552:
    find_lex $P2421, "$name"
    unless_null $P2421, vivify_1553
    new $P2421, "Undef"
  vivify_1553:
    $P2422 = $P2420."symbol"($P2421)
    store_lex "%sym", $P2422
.annotate 'line', 2123
    find_lex $P2425, "%sym"
    unless_null $P2425, vivify_1554
    $P2425 = root_new ['parrot';'Hash']
  vivify_1554:
    set $N2426, $P2425
    if $N2426, if_2424
    new $P2423, 'Float'
    set $P2423, $N2426
    goto if_2424_end
  if_2424:
.annotate 'line', 2124
    new $P2427, "Exception"
    set $P2427['type'], .CONTROL_RETURN
    find_lex $P2428, "%sym"
    unless_null $P2428, vivify_1555
    $P2428 = root_new ['parrot';'Hash']
  vivify_1555:
    set $P2429, $P2428["scope"]
    unless_null $P2429, vivify_1556
    new $P2429, "Undef"
  vivify_1556:
    set $S2430, $P2429
    find_lex $P2431, "$wanted_scope"
    unless_null $P2431, vivify_1557
    new $P2431, "Undef"
  vivify_1557:
    set $S2432, $P2431
    iseq $I2433, $S2430, $S2432
    new $P2434, 'Integer'
    set $P2434, $I2433
    setattribute $P2427, 'payload', $P2434
    throw $P2427
  if_2424_end:
.annotate 'line', 2121
    .return ($P2423)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "find_sym"  :subid("427_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_2443
    .param pmc param_2444
.annotate 'line', 2143
    .const 'Sub' $P2538 = "432_1304456155.152" 
    capture_lex $P2538
    .const 'Sub' $P2498 = "430_1304456155.152" 
    capture_lex $P2498
    .const 'Sub' $P2456 = "428_1304456155.152" 
    capture_lex $P2456
    new $P2442, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2442, control_2441
    push_eh $P2442
    .lex "@name", param_2443
    .lex "$/", param_2444
.annotate 'line', 2167
    new $P2445, "Undef"
    .lex "$result", $P2445
.annotate 'line', 2145
    find_lex $P2447, "@name"
    unless_null $P2447, vivify_1558
    $P2447 = root_new ['parrot';'ResizablePMCArray']
  vivify_1558:
    set $N2448, $P2447
    if $N2448, unless_2446_end
    find_lex $P2449, "$/"
    unless_null $P2449, vivify_1559
    new $P2449, "Undef"
  vivify_1559:
    $P2450 = $P2449."CURSOR"()
    $P2450."panic"("Cannot look up empty name")
  unless_2446_end:
.annotate 'line', 2149
    find_lex $P2452, "@name"
    unless_null $P2452, vivify_1560
    $P2452 = root_new ['parrot';'ResizablePMCArray']
  vivify_1560:
    set $N2453, $P2452
    iseq $I2454, $N2453, 1.0
    unless $I2454, if_2451_end
    .const 'Sub' $P2456 = "428_1304456155.152" 
    capture_lex $P2456
    $P2456()
  if_2451_end:
.annotate 'line', 2167
    find_dynamic_lex $P2492, "$*GLOBALish"
    unless_null $P2492, vivify_1572
    get_hll_global $P2490, "GLOBAL"
    get_who $P2491, $P2490
    set $P2492, $P2491["$GLOBALish"]
    unless_null $P2492, vivify_1573
    die "Contextual $*GLOBALish not found"
  vivify_1573:
  vivify_1572:
    store_lex "$result", $P2492
.annotate 'line', 2168
    find_lex $P2494, "@name"
    unless_null $P2494, vivify_1574
    $P2494 = root_new ['parrot';'ResizablePMCArray']
  vivify_1574:
    set $N2495, $P2494
    isge $I2496, $N2495, 2.0
    unless $I2496, if_2493_end
    .const 'Sub' $P2498 = "430_1304456155.152" 
    capture_lex $P2498
    $P2498()
  if_2493_end:
.annotate 'line', 2186
    find_lex $P2534, "@name"
    unless_null $P2534, vivify_1587
    $P2534 = root_new ['parrot';'ResizablePMCArray']
  vivify_1587:
    defined $I2535, $P2534
    unless $I2535, for_undef_1588
    iter $P2533, $P2534
    new $P2556, 'ExceptionHandler'
    set_label $P2556, loop2555_handler
    $P2556."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2556
  loop2555_test:
    unless $P2533, loop2555_done
    shift $P2536, $P2533
  loop2555_redo:
    .const 'Sub' $P2538 = "432_1304456155.152" 
    capture_lex $P2538
    $P2538($P2536)
  loop2555_next:
    goto loop2555_test
  loop2555_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2557, exception, 'type'
    eq $P2557, .CONTROL_LOOP_NEXT, loop2555_next
    eq $P2557, .CONTROL_LOOP_REDO, loop2555_redo
  loop2555_done:
    pop_eh 
  for_undef_1588:
    find_lex $P2558, "$result"
    unless_null $P2558, vivify_1595
    new $P2558, "Undef"
  vivify_1595:
.annotate 'line', 2143
    .return ($P2558)
  control_2441:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2559, exception, "payload"
    .return ($P2559)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2455"  :anon :subid("428_1304456155.152") :outer("427_1304456155.152")
.annotate 'line', 2149
    .const 'Sub' $P2467 = "429_1304456155.152" 
    capture_lex $P2467
.annotate 'line', 2150
    new $P2457, "Undef"
    .lex "$final_name", $P2457
    find_lex $P2458, "@name"
    unless_null $P2458, vivify_1561
    $P2458 = root_new ['parrot';'ResizablePMCArray']
  vivify_1561:
    set $P2459, $P2458[0]
    unless_null $P2459, vivify_1562
    new $P2459, "Undef"
  vivify_1562:
    store_lex "$final_name", $P2459
.annotate 'line', 2151
    find_lex $P2461, "$?PACKAGE"
    get_who $P2462, $P2461
    set $P2463, $P2462["@BLOCK"]
    unless_null $P2463, vivify_1563
    $P2463 = root_new ['parrot';'ResizablePMCArray']
  vivify_1563:
    defined $I2464, $P2463
    unless $I2464, for_undef_1564
    iter $P2460, $P2463
    new $P2488, 'ExceptionHandler'
    set_label $P2488, loop2487_handler
    $P2488."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2488
  loop2487_test:
    unless $P2460, loop2487_done
    shift $P2465, $P2460
  loop2487_redo:
    .const 'Sub' $P2467 = "429_1304456155.152" 
    capture_lex $P2467
    $P2467($P2465)
  loop2487_next:
    goto loop2487_test
  loop2487_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2489, exception, 'type'
    eq $P2489, .CONTROL_LOOP_NEXT, loop2487_next
    eq $P2489, .CONTROL_LOOP_REDO, loop2487_redo
  loop2487_done:
    pop_eh 
  for_undef_1564:
.annotate 'line', 2149
    .return ($P2460)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2466"  :anon :subid("429_1304456155.152") :outer("428_1304456155.152")
    .param pmc param_2469
.annotate 'line', 2152
    $P2468 = root_new ['parrot';'Hash']
    .lex "%sym", $P2468
    .lex "$_", param_2469
    find_lex $P2470, "$_"
    unless_null $P2470, vivify_1565
    new $P2470, "Undef"
  vivify_1565:
    find_lex $P2471, "$final_name"
    unless_null $P2471, vivify_1566
    new $P2471, "Undef"
  vivify_1566:
    $P2472 = $P2470."symbol"($P2471)
    store_lex "%sym", $P2472
.annotate 'line', 2153
    find_lex $P2475, "%sym"
    unless_null $P2475, vivify_1567
    $P2475 = root_new ['parrot';'Hash']
  vivify_1567:
    set $N2476, $P2475
    if $N2476, if_2474
    new $P2473, 'Float'
    set $P2473, $N2476
    goto if_2474_end
  if_2474:
.annotate 'line', 2154
    find_lex $P2479, "%sym"
    unless_null $P2479, vivify_1568
    $P2479 = root_new ['parrot';'Hash']
  vivify_1568:
    exists $I2480, $P2479["value"]
    if $I2480, if_2478
.annotate 'line', 2158
    new $P2484, 'String'
    set $P2484, "No compile-time value for "
    find_lex $P2485, "$final_name"
    unless_null $P2485, vivify_1569
    new $P2485, "Undef"
  vivify_1569:
    concat $P2486, $P2484, $P2485
    die $P2486
.annotate 'line', 2157
    goto if_2478_end
  if_2478:
.annotate 'line', 2155
    new $P2481, "Exception"
    set $P2481['type'], .CONTROL_RETURN
    find_lex $P2482, "%sym"
    unless_null $P2482, vivify_1570
    $P2482 = root_new ['parrot';'Hash']
  vivify_1570:
    set $P2483, $P2482["value"]
    unless_null $P2483, vivify_1571
    new $P2483, "Undef"
  vivify_1571:
    setattribute $P2481, 'payload', $P2483
    throw $P2481
  if_2478_end:
.annotate 'line', 2153
    set $P2473, $P2477
  if_2474_end:
.annotate 'line', 2151
    .return ($P2473)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2497"  :anon :subid("430_1304456155.152") :outer("427_1304456155.152")
.annotate 'line', 2168
    .const 'Sub' $P2509 = "431_1304456155.152" 
    capture_lex $P2509
.annotate 'line', 2169
    new $P2499, "Undef"
    .lex "$first", $P2499
    find_lex $P2500, "@name"
    unless_null $P2500, vivify_1575
    $P2500 = root_new ['parrot';'ResizablePMCArray']
  vivify_1575:
    set $P2501, $P2500[0]
    unless_null $P2501, vivify_1576
    new $P2501, "Undef"
  vivify_1576:
    store_lex "$first", $P2501
.annotate 'line', 2170
    find_lex $P2503, "$?PACKAGE"
    get_who $P2504, $P2503
    set $P2505, $P2504["@BLOCK"]
    unless_null $P2505, vivify_1577
    $P2505 = root_new ['parrot';'ResizablePMCArray']
  vivify_1577:
    defined $I2506, $P2505
    unless $I2506, for_undef_1578
    iter $P2502, $P2505
    new $P2531, 'ExceptionHandler'
    set_label $P2531, loop2530_handler
    $P2531."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2531
  loop2530_test:
    unless $P2502, loop2530_done
    shift $P2507, $P2502
  loop2530_redo:
    .const 'Sub' $P2509 = "431_1304456155.152" 
    capture_lex $P2509
    $P2509($P2507)
  loop2530_next:
    goto loop2530_test
  loop2530_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2532, exception, 'type'
    eq $P2532, .CONTROL_LOOP_NEXT, loop2530_next
    eq $P2532, .CONTROL_LOOP_REDO, loop2530_redo
  loop2530_done:
    pop_eh 
  for_undef_1578:
.annotate 'line', 2168
    .return ($P2502)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2508"  :anon :subid("431_1304456155.152") :outer("430_1304456155.152")
    .param pmc param_2511
.annotate 'line', 2171
    $P2510 = root_new ['parrot';'Hash']
    .lex "%sym", $P2510
    .lex "$_", param_2511
    find_lex $P2512, "$_"
    unless_null $P2512, vivify_1579
    new $P2512, "Undef"
  vivify_1579:
    find_lex $P2513, "$first"
    unless_null $P2513, vivify_1580
    new $P2513, "Undef"
  vivify_1580:
    $P2514 = $P2512."symbol"($P2513)
    store_lex "%sym", $P2514
.annotate 'line', 2172
    find_lex $P2517, "%sym"
    unless_null $P2517, vivify_1581
    $P2517 = root_new ['parrot';'Hash']
  vivify_1581:
    set $N2518, $P2517
    if $N2518, if_2516
    new $P2515, 'Float'
    set $P2515, $N2518
    goto if_2516_end
  if_2516:
.annotate 'line', 2173
    find_lex $P2521, "%sym"
    unless_null $P2521, vivify_1582
    $P2521 = root_new ['parrot';'Hash']
  vivify_1582:
    exists $I2522, $P2521["value"]
    if $I2522, if_2520
.annotate 'line', 2179
    new $P2527, 'String'
    set $P2527, "No compile-time value for "
    find_lex $P2528, "$first"
    unless_null $P2528, vivify_1583
    new $P2528, "Undef"
  vivify_1583:
    concat $P2529, $P2527, $P2528
    die $P2529
.annotate 'line', 2178
    goto if_2520_end
  if_2520:
.annotate 'line', 2174
    find_lex $P2523, "%sym"
    unless_null $P2523, vivify_1584
    $P2523 = root_new ['parrot';'Hash']
  vivify_1584:
    set $P2524, $P2523["value"]
    unless_null $P2524, vivify_1585
    new $P2524, "Undef"
  vivify_1585:
    store_lex "$result", $P2524
.annotate 'line', 2175
    find_lex $P2525, "@name"
    unless_null $P2525, vivify_1586
    $P2525 = root_new ['parrot';'ResizablePMCArray']
  vivify_1586:
    $P2525."shift"()
.annotate 'line', 2176
    set $I2526, .CONTROL_LOOP_LAST
    die 0, $I2526
  if_2520_end:
.annotate 'line', 2172
    set $P2515, $P2519
  if_2516_end:
.annotate 'line', 2170
    .return ($P2515)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2537"  :anon :subid("432_1304456155.152") :outer("427_1304456155.152")
    .param pmc param_2539
.annotate 'line', 2186
    .lex "$_", param_2539
.annotate 'line', 2187
    find_lex $P2544, "$_"
    unless_null $P2544, vivify_1589
    new $P2544, "Undef"
  vivify_1589:
    set $S2545, $P2544
    find_lex $P2542, "$result"
    unless_null $P2542, vivify_1590
    new $P2542, "Undef"
  vivify_1590:
    get_who $P2543, $P2542
    exists $I2546, $P2543[$S2545]
    if $I2546, if_2541
.annotate 'line', 2191
    new $P2551, "String"
    assign $P2551, "Could not locate compile-time value for symbol "
.annotate 'line', 2192
    find_lex $P2552, "@name"
    unless_null $P2552, vivify_1591
    $P2552 = root_new ['parrot';'ResizablePMCArray']
  vivify_1591:
    join $S2553, "::", $P2552
    concat $P2554, $P2551, $S2553
.annotate 'line', 2191
    die $P2554
.annotate 'line', 2190
    goto if_2541_end
  if_2541:
.annotate 'line', 2188
    find_lex $P2547, "$_"
    unless_null $P2547, vivify_1592
    new $P2547, "Undef"
  vivify_1592:
    find_lex $P2548, "$result"
    unless_null $P2548, vivify_1593
    new $P2548, "Undef"
  vivify_1593:
    get_who $P2549, $P2548
    set $P2550, $P2549[$P2547]
    unless_null $P2550, vivify_1594
    new $P2550, "Undef"
  vivify_1594:
    store_lex "$result", $P2550
.annotate 'line', 2187
    set $P2540, $P2550
  if_2541_end:
.annotate 'line', 2186
    .return ($P2540)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "TOP"  :subid("433_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_2570
    .param pmc param_2571
.annotate 'line', 796
    .lex "self", param_2570
    .lex "$/", param_2571
    find_lex $P2572, "$/"
    find_lex $P2573, "$/"
    unless_null $P2573, vivify_1596
    $P2573 = root_new ['parrot';'Hash']
  vivify_1596:
    set $P2574, $P2573["comp_unit"]
    unless_null $P2574, vivify_1597
    new $P2574, "Undef"
  vivify_1597:
    $P2575 = $P2574."ast"()
    $P2576 = $P2572."!make"($P2575)
    .return ($P2576)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "deflongname"  :subid("434_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_2578
    .param pmc param_2579
.annotate 'line', 798
    .lex "self", param_2578
    .lex "$/", param_2579
.annotate 'line', 799
    find_lex $P2580, "$/"
.annotate 'line', 800
    find_lex $P2583, "$/"
    unless_null $P2583, vivify_1598
    $P2583 = root_new ['parrot';'Hash']
  vivify_1598:
    set $P2584, $P2583["colonpair"]
    unless_null $P2584, vivify_1599
    new $P2584, "Undef"
  vivify_1599:
    if $P2584, if_2582
.annotate 'line', 802
    find_lex $P2604, "$/"
    unless_null $P2604, vivify_1600
    new $P2604, "Undef"
  vivify_1600:
    set $S2605, $P2604
    new $P2581, 'String'
    set $P2581, $S2605
.annotate 'line', 800
    goto if_2582_end
  if_2582:
    find_lex $P2585, "$/"
    unless_null $P2585, vivify_1601
    $P2585 = root_new ['parrot';'Hash']
  vivify_1601:
    set $P2586, $P2585["identifier"]
    unless_null $P2586, vivify_1602
    new $P2586, "Undef"
  vivify_1602:
    set $S2587, $P2586
    new $P2588, 'String'
    set $P2588, $S2587
    concat $P2589, $P2588, ":"
    find_lex $P2590, "$/"
    unless_null $P2590, vivify_1603
    $P2590 = root_new ['parrot';'Hash']
  vivify_1603:
    set $P2591, $P2590["colonpair"]
    unless_null $P2591, vivify_1604
    $P2591 = root_new ['parrot';'ResizablePMCArray']
  vivify_1604:
    set $P2592, $P2591[0]
    unless_null $P2592, vivify_1605
    new $P2592, "Undef"
  vivify_1605:
    $P2593 = $P2592."ast"()
    $S2594 = $P2593."named"()
    concat $P2595, $P2589, $S2594
    concat $P2596, $P2595, "<"
.annotate 'line', 801
    find_lex $P2597, "$/"
    unless_null $P2597, vivify_1606
    $P2597 = root_new ['parrot';'Hash']
  vivify_1606:
    set $P2598, $P2597["colonpair"]
    unless_null $P2598, vivify_1607
    $P2598 = root_new ['parrot';'ResizablePMCArray']
  vivify_1607:
    set $P2599, $P2598[0]
    unless_null $P2599, vivify_1608
    new $P2599, "Undef"
  vivify_1608:
    $P2600 = $P2599."ast"()
    $S2601 = "colonpair_str"($P2600)
    concat $P2602, $P2596, $S2601
    concat $P2603, $P2602, ">"
    set $P2581, $P2603
  if_2582_end:
.annotate 'line', 800
    $P2606 = $P2580."!make"($P2581)
.annotate 'line', 798
    .return ($P2606)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "comp_unit"  :subid("435_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_2609
    .param pmc param_2610
.annotate 'line', 812
    .lex "self", param_2609
    .lex "$/", param_2610
.annotate 'line', 813
    new $P2611, "Undef"
    .lex "$mainline", $P2611
.annotate 'line', 814
    new $P2612, "Undef"
    .lex "$unit", $P2612
.annotate 'line', 813
    find_lex $P2613, "$/"
    unless_null $P2613, vivify_1609
    $P2613 = root_new ['parrot';'Hash']
  vivify_1609:
    set $P2614, $P2613["statementlist"]
    unless_null $P2614, vivify_1610
    new $P2614, "Undef"
  vivify_1610:
    $P2615 = $P2614."ast"()
    store_lex "$mainline", $P2615
.annotate 'line', 814
    find_lex $P2616, "$?PACKAGE"
    get_who $P2617, $P2616
    set $P2618, $P2617["@BLOCK"]
    unless_null $P2618, vivify_1611
    $P2618 = root_new ['parrot';'ResizablePMCArray']
  vivify_1611:
    $P2619 = $P2618."shift"()
    store_lex "$unit", $P2619
.annotate 'line', 818
    find_lex $P2620, "$unit"
    unless_null $P2620, vivify_1612
    new $P2620, "Undef"
  vivify_1612:
    $P2621 = $P2620."loadinit"()
    find_dynamic_lex $P2624, "$*SC"
    unless_null $P2624, vivify_1613
    get_hll_global $P2622, "GLOBAL"
    get_who $P2623, $P2622
    set $P2624, $P2623["$SC"]
    unless_null $P2624, vivify_1614
    die "Contextual $*SC not found"
  vivify_1614:
  vivify_1613:
    $P2625 = $P2624."to_past"()
    $P2621."push"($P2625)
.annotate 'line', 823
    find_lex $P2626, "$unit"
    unless_null $P2626, vivify_1615
    new $P2626, "Undef"
  vivify_1615:
    $P2627 = $P2626."loadinit"()
    get_hll_global $P2628, "GLOBAL"
    nqp_get_package_through_who $P2629, $P2628, "PAST"
    get_who $P2630, $P2629
    set $P2631, $P2630["Op"]
.annotate 'line', 825
    get_hll_global $P2632, "GLOBAL"
    nqp_get_package_through_who $P2633, $P2632, "PAST"
    get_who $P2634, $P2633
    set $P2635, $P2634["Var"]
    new $P2636, "ResizablePMCArray"
    $P2637 = $P2635."new"("GLOBAL" :named("name"), $P2636 :named("namespace"), "package" :named("scope"))
.annotate 'line', 826
    find_dynamic_lex $P2640, "$*SC"
    unless_null $P2640, vivify_1616
    get_hll_global $P2638, "GLOBAL"
    get_who $P2639, $P2638
    set $P2640, $P2639["$SC"]
    unless_null $P2640, vivify_1617
    die "Contextual $*SC not found"
  vivify_1617:
  vivify_1616:
    find_dynamic_lex $P2643, "$*PACKAGE"
    unless_null $P2643, vivify_1618
    get_hll_global $P2641, "GLOBAL"
    get_who $P2642, $P2641
    set $P2643, $P2642["$PACKAGE"]
    unless_null $P2643, vivify_1619
    die "Contextual $*PACKAGE not found"
  vivify_1619:
  vivify_1618:
    $P2644 = $P2640."get_slot_past_for_object"($P2643)
    $P2645 = $P2631."new"($P2637, $P2644, "bind" :named("pasttype"))
.annotate 'line', 823
    $P2627."push"($P2645)
.annotate 'line', 832
    find_dynamic_lex $P2649, "$*HAS_YOU_ARE_HERE"
    unless_null $P2649, vivify_1620
    get_hll_global $P2647, "GLOBAL"
    get_who $P2648, $P2647
    set $P2649, $P2648["$HAS_YOU_ARE_HERE"]
    unless_null $P2649, vivify_1621
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_1621:
  vivify_1620:
    if $P2649, unless_2646_end
.annotate 'line', 833
    find_lex $P2650, "$unit"
    unless_null $P2650, vivify_1622
    new $P2650, "Undef"
  vivify_1622:
    find_lex $P2651, "self"
    $P2652 = $P2651."CTXSAVE"()
    $P2650."push"($P2652)
  unless_2646_end:
.annotate 'line', 837
    find_lex $P2653, "$unit"
    unless_null $P2653, vivify_1623
    new $P2653, "Undef"
  vivify_1623:
    $P2653."loadlibs"("nqp_group", "nqp_ops")
.annotate 'line', 841
    find_dynamic_lex $P2657, "$*MAIN_SUB"
    unless_null $P2657, vivify_1624
    get_hll_global $P2655, "GLOBAL"
    get_who $P2656, $P2655
    set $P2657, $P2656["$MAIN_SUB"]
    unless_null $P2657, vivify_1625
    die "Contextual $*MAIN_SUB not found"
  vivify_1625:
  vivify_1624:
    unless $P2657, if_2654_end
.annotate 'line', 842
    find_lex $P2658, "$unit"
    unless_null $P2658, vivify_1626
    new $P2658, "Undef"
  vivify_1626:
    get_hll_global $P2659, "GLOBAL"
    nqp_get_package_through_who $P2660, $P2659, "PAST"
    get_who $P2661, $P2660
    set $P2662, $P2661["Var"]
    $P2663 = $P2662."new"("parameter" :named("scope"), "@ARGS" :named("name"), 1 :named("slurpy"))
    $P2658."unshift"($P2663)
.annotate 'line', 843
    find_lex $P2664, "$mainline"
    unless_null $P2664, vivify_1627
    new $P2664, "Undef"
  vivify_1627:
    get_hll_global $P2665, "GLOBAL"
    nqp_get_package_through_who $P2666, $P2665, "PAST"
    get_who $P2667, $P2666
    set $P2668, $P2667["Op"]
.annotate 'line', 845
    get_hll_global $P2669, "GLOBAL"
    nqp_get_package_through_who $P2670, $P2669, "PAST"
    get_who $P2671, $P2670
    set $P2672, $P2671["Var"]
    $P2673 = $P2672."new"("lexical" :named("scope"), "@ARGS" :named("name"))
.annotate 'line', 846
    get_hll_global $P2674, "GLOBAL"
    nqp_get_package_through_who $P2675, $P2674, "PAST"
    get_who $P2676, $P2675
    set $P2677, $P2676["Op"]
.annotate 'line', 847
    get_hll_global $P2678, "GLOBAL"
    nqp_get_package_through_who $P2679, $P2678, "PAST"
    get_who $P2680, $P2679
    set $P2681, $P2680["Val"]
    find_dynamic_lex $P2684, "$*MAIN_SUB"
    unless_null $P2684, vivify_1628
    get_hll_global $P2682, "GLOBAL"
    get_who $P2683, $P2682
    set $P2684, $P2683["$MAIN_SUB"]
    unless_null $P2684, vivify_1629
    die "Contextual $*MAIN_SUB not found"
  vivify_1629:
  vivify_1628:
    $P2685 = $P2681."new"($P2684 :named("value"))
.annotate 'line', 848
    get_hll_global $P2686, "GLOBAL"
    nqp_get_package_through_who $P2687, $P2686, "PAST"
    get_who $P2688, $P2687
    set $P2689, $P2688["Var"]
    $P2690 = $P2689."new"("lexical" :named("scope"), "@ARGS" :named("name"), 1 :named("flat"))
    $P2691 = $P2677."new"($P2685, $P2690, "call" :named("pasttype"))
.annotate 'line', 846
    $P2692 = $P2668."new"($P2673, $P2691, "if" :named("pasttype"))
.annotate 'line', 843
    $P2664."push"($P2692)
  if_2654_end:
.annotate 'line', 856
    find_lex $P2693, "$unit"
    unless_null $P2693, vivify_1630
    new $P2693, "Undef"
  vivify_1630:
.annotate 'line', 857
    get_hll_global $P2694, "GLOBAL"
    nqp_get_package_through_who $P2695, $P2694, "PAST"
    get_who $P2696, $P2695
    set $P2697, $P2696["Op"]
    find_lex $P2698, "$mainline"
    unless_null $P2698, vivify_1631
    new $P2698, "Undef"
  vivify_1631:
    $P2699 = $P2697."new"($P2698, "return" :named("pirop"))
    $P2693."push"($P2699)
.annotate 'line', 862
    find_lex $P2700, "$unit"
    unless_null $P2700, vivify_1632
    new $P2700, "Undef"
  vivify_1632:
.annotate 'line', 863
    get_hll_global $P2701, "GLOBAL"
    nqp_get_package_through_who $P2702, $P2701, "PAST"
    get_who $P2703, $P2702
    set $P2704, $P2703["Block"]
.annotate 'line', 865
    get_hll_global $P2705, "GLOBAL"
    nqp_get_package_through_who $P2706, $P2705, "PAST"
    get_who $P2707, $P2706
    set $P2708, $P2707["Op"]
    get_hll_global $P2709, "GLOBAL"
    nqp_get_package_through_who $P2710, $P2709, "PAST"
    get_who $P2711, $P2710
    set $P2712, $P2711["Val"]
    find_lex $P2713, "$unit"
    unless_null $P2713, vivify_1633
    new $P2713, "Undef"
  vivify_1633:
    $P2714 = $P2712."new"($P2713 :named("value"))
    $P2715 = $P2708."new"($P2714, "call" :named("pasttype"))
    $P2716 = $P2704."new"($P2715, ":load" :named("pirflags"), 0 :named("lexical"), "" :named("namespace"))
.annotate 'line', 863
    $P2700."push"($P2716)
.annotate 'line', 868
    find_lex $P2717, "$unit"
    unless_null $P2717, vivify_1634
    new $P2717, "Undef"
  vivify_1634:
    find_lex $P2718, "$/"
    unless_null $P2718, vivify_1635
    new $P2718, "Undef"
  vivify_1635:
    $P2717."node"($P2718)
.annotate 'line', 871
    find_lex $P2719, "$unit"
    unless_null $P2719, vivify_1636
    new $P2719, "Undef"
  vivify_1636:
    $P2719."hll"("nqp")
.annotate 'line', 873
    find_lex $P2720, "$/"
    find_lex $P2721, "$unit"
    unless_null $P2721, vivify_1637
    new $P2721, "Undef"
  vivify_1637:
    $P2722 = $P2720."!make"($P2721)
.annotate 'line', 812
    .return ($P2722)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statementlist"  :subid("436_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_2724
    .param pmc param_2725
.annotate 'line', 876
    .const 'Sub' $P2742 = "437_1304456155.152" 
    capture_lex $P2742
    .lex "self", param_2724
    .lex "$/", param_2725
.annotate 'line', 877
    new $P2726, "Undef"
    .lex "$past", $P2726
    get_hll_global $P2727, "GLOBAL"
    nqp_get_package_through_who $P2728, $P2727, "PAST"
    get_who $P2729, $P2728
    set $P2730, $P2729["Stmts"]
    find_lex $P2731, "$/"
    unless_null $P2731, vivify_1638
    new $P2731, "Undef"
  vivify_1638:
    $P2732 = $P2730."new"($P2731 :named("node"))
    store_lex "$past", $P2732
.annotate 'line', 878
    find_lex $P2734, "$/"
    unless_null $P2734, vivify_1639
    $P2734 = root_new ['parrot';'Hash']
  vivify_1639:
    set $P2735, $P2734["statement"]
    unless_null $P2735, vivify_1640
    new $P2735, "Undef"
  vivify_1640:
    unless $P2735, if_2733_end
.annotate 'line', 879
    find_lex $P2737, "$/"
    unless_null $P2737, vivify_1641
    $P2737 = root_new ['parrot';'Hash']
  vivify_1641:
    set $P2738, $P2737["statement"]
    unless_null $P2738, vivify_1642
    new $P2738, "Undef"
  vivify_1642:
    defined $I2739, $P2738
    unless $I2739, for_undef_1643
    iter $P2736, $P2738
    new $P2762, 'ExceptionHandler'
    set_label $P2762, loop2761_handler
    $P2762."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2762
  loop2761_test:
    unless $P2736, loop2761_done
    shift $P2740, $P2736
  loop2761_redo:
    .const 'Sub' $P2742 = "437_1304456155.152" 
    capture_lex $P2742
    $P2742($P2740)
  loop2761_next:
    goto loop2761_test
  loop2761_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2763, exception, 'type'
    eq $P2763, .CONTROL_LOOP_NEXT, loop2761_next
    eq $P2763, .CONTROL_LOOP_REDO, loop2761_redo
  loop2761_done:
    pop_eh 
  for_undef_1643:
  if_2733_end:
.annotate 'line', 886
    find_lex $P2764, "$/"
    find_lex $P2765, "$past"
    unless_null $P2765, vivify_1654
    new $P2765, "Undef"
  vivify_1654:
    $P2766 = $P2764."!make"($P2765)
.annotate 'line', 876
    .return ($P2766)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2741"  :anon :subid("437_1304456155.152") :outer("436_1304456155.152")
    .param pmc param_2744
.annotate 'line', 880
    new $P2743, "Undef"
    .lex "$ast", $P2743
    .lex "$_", param_2744
    find_lex $P2745, "$_"
    unless_null $P2745, vivify_1644
    new $P2745, "Undef"
  vivify_1644:
    $P2746 = $P2745."ast"()
    store_lex "$ast", $P2746
.annotate 'line', 881
    find_lex $P2748, "$ast"
    unless_null $P2748, vivify_1645
    $P2748 = root_new ['parrot';'Hash']
  vivify_1645:
    set $P2749, $P2748["sink"]
    unless_null $P2749, vivify_1646
    new $P2749, "Undef"
  vivify_1646:
    defined $I2750, $P2749
    unless $I2750, if_2747_end
    find_lex $P2751, "$ast"
    unless_null $P2751, vivify_1647
    $P2751 = root_new ['parrot';'Hash']
  vivify_1647:
    set $P2752, $P2751["sink"]
    unless_null $P2752, vivify_1648
    new $P2752, "Undef"
  vivify_1648:
    store_lex "$ast", $P2752
  if_2747_end:
.annotate 'line', 882
    find_lex $P2754, "$ast"
    unless_null $P2754, vivify_1649
    $P2754 = root_new ['parrot';'Hash']
  vivify_1649:
    set $P2755, $P2754["bareblock"]
    unless_null $P2755, vivify_1650
    new $P2755, "Undef"
  vivify_1650:
    unless $P2755, if_2753_end
    find_lex $P2756, "$ast"
    unless_null $P2756, vivify_1651
    new $P2756, "Undef"
  vivify_1651:
    $P2757 = "block_immediate"($P2756)
    store_lex "$ast", $P2757
  if_2753_end:
.annotate 'line', 883
    find_lex $P2758, "$past"
    unless_null $P2758, vivify_1652
    new $P2758, "Undef"
  vivify_1652:
    find_lex $P2759, "$ast"
    unless_null $P2759, vivify_1653
    new $P2759, "Undef"
  vivify_1653:
    $P2760 = $P2758."push"($P2759)
.annotate 'line', 879
    .return ($P2760)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement"  :subid("438_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_2768
    .param pmc param_2769
    .param pmc param_2770 :optional
    .param int has_param_2770 :opt_flag
.annotate 'line', 889
    .const 'Sub' $P2778 = "439_1304456155.152" 
    capture_lex $P2778
    .lex "self", param_2768
    .lex "$/", param_2769
    if has_param_2770, optparam_1655
    new $P2771, "Undef"
    set param_2770, $P2771
  optparam_1655:
    .lex "$key", param_2770
.annotate 'line', 890
    new $P2772, "Undef"
    .lex "$past", $P2772
.annotate 'line', 889
    find_lex $P2773, "$past"
    unless_null $P2773, vivify_1656
    new $P2773, "Undef"
  vivify_1656:
.annotate 'line', 891
    find_lex $P2775, "$/"
    unless_null $P2775, vivify_1657
    $P2775 = root_new ['parrot';'Hash']
  vivify_1657:
    set $P2776, $P2775["EXPR"]
    unless_null $P2776, vivify_1658
    new $P2776, "Undef"
  vivify_1658:
    if $P2776, if_2774
.annotate 'line', 912
    find_lex $P2854, "$/"
    unless_null $P2854, vivify_1659
    $P2854 = root_new ['parrot';'Hash']
  vivify_1659:
    set $P2855, $P2854["statement_control"]
    unless_null $P2855, vivify_1660
    new $P2855, "Undef"
  vivify_1660:
    if $P2855, if_2853
.annotate 'line', 913
    new $P2859, "Integer"
    assign $P2859, 0
    store_lex "$past", $P2859
    goto if_2853_end
  if_2853:
.annotate 'line', 912
    find_lex $P2856, "$/"
    unless_null $P2856, vivify_1661
    $P2856 = root_new ['parrot';'Hash']
  vivify_1661:
    set $P2857, $P2856["statement_control"]
    unless_null $P2857, vivify_1662
    new $P2857, "Undef"
  vivify_1662:
    $P2858 = $P2857."ast"()
    store_lex "$past", $P2858
  if_2853_end:
    goto if_2774_end
  if_2774:
.annotate 'line', 891
    .const 'Sub' $P2778 = "439_1304456155.152" 
    capture_lex $P2778
    $P2778()
  if_2774_end:
.annotate 'line', 914
    find_lex $P2860, "$/"
    find_lex $P2861, "$past"
    unless_null $P2861, vivify_1696
    new $P2861, "Undef"
  vivify_1696:
    $P2862 = $P2860."!make"($P2861)
.annotate 'line', 889
    .return ($P2862)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2777"  :anon :subid("439_1304456155.152") :outer("438_1304456155.152")
.annotate 'line', 892
    new $P2779, "Undef"
    .lex "$mc", $P2779
.annotate 'line', 893
    new $P2780, "Undef"
    .lex "$ml", $P2780
.annotate 'line', 892
    find_lex $P2781, "$/"
    unless_null $P2781, vivify_1663
    $P2781 = root_new ['parrot';'Hash']
  vivify_1663:
    set $P2782, $P2781["statement_mod_cond"]
    unless_null $P2782, vivify_1664
    $P2782 = root_new ['parrot';'ResizablePMCArray']
  vivify_1664:
    set $P2783, $P2782[0]
    unless_null $P2783, vivify_1665
    new $P2783, "Undef"
  vivify_1665:
    store_lex "$mc", $P2783
.annotate 'line', 893
    find_lex $P2784, "$/"
    unless_null $P2784, vivify_1666
    $P2784 = root_new ['parrot';'Hash']
  vivify_1666:
    set $P2785, $P2784["statement_mod_loop"]
    unless_null $P2785, vivify_1667
    $P2785 = root_new ['parrot';'ResizablePMCArray']
  vivify_1667:
    set $P2786, $P2785[0]
    unless_null $P2786, vivify_1668
    new $P2786, "Undef"
  vivify_1668:
    store_lex "$ml", $P2786
.annotate 'line', 894
    find_lex $P2787, "$/"
    unless_null $P2787, vivify_1669
    $P2787 = root_new ['parrot';'Hash']
  vivify_1669:
    set $P2788, $P2787["EXPR"]
    unless_null $P2788, vivify_1670
    new $P2788, "Undef"
  vivify_1670:
    $P2789 = $P2788."ast"()
    store_lex "$past", $P2789
.annotate 'line', 895
    find_lex $P2791, "$mc"
    unless_null $P2791, vivify_1671
    new $P2791, "Undef"
  vivify_1671:
    unless $P2791, if_2790_end
.annotate 'line', 896
    get_hll_global $P2792, "GLOBAL"
    nqp_get_package_through_who $P2793, $P2792, "PAST"
    get_who $P2794, $P2793
    set $P2795, $P2794["Op"]
    find_lex $P2796, "$mc"
    unless_null $P2796, vivify_1672
    $P2796 = root_new ['parrot';'Hash']
  vivify_1672:
    set $P2797, $P2796["cond"]
    unless_null $P2797, vivify_1673
    new $P2797, "Undef"
  vivify_1673:
    $P2798 = $P2797."ast"()
    find_lex $P2799, "$past"
    unless_null $P2799, vivify_1674
    new $P2799, "Undef"
  vivify_1674:
    find_lex $P2800, "$mc"
    unless_null $P2800, vivify_1675
    $P2800 = root_new ['parrot';'Hash']
  vivify_1675:
    set $P2801, $P2800["sym"]
    unless_null $P2801, vivify_1676
    new $P2801, "Undef"
  vivify_1676:
    set $S2802, $P2801
    find_lex $P2803, "$/"
    unless_null $P2803, vivify_1677
    new $P2803, "Undef"
  vivify_1677:
    $P2804 = $P2795."new"($P2798, $P2799, $S2802 :named("pasttype"), $P2803 :named("node"))
    store_lex "$past", $P2804
  if_2790_end:
.annotate 'line', 898
    find_lex $P2807, "$ml"
    unless_null $P2807, vivify_1678
    new $P2807, "Undef"
  vivify_1678:
    if $P2807, if_2806
    set $P2805, $P2807
    goto if_2806_end
  if_2806:
.annotate 'line', 899
    find_lex $P2810, "$ml"
    unless_null $P2810, vivify_1679
    $P2810 = root_new ['parrot';'Hash']
  vivify_1679:
    set $P2811, $P2810["sym"]
    unless_null $P2811, vivify_1680
    new $P2811, "Undef"
  vivify_1680:
    set $S2812, $P2811
    iseq $I2813, $S2812, "for"
    if $I2813, if_2809
.annotate 'line', 908
    get_hll_global $P2840, "GLOBAL"
    nqp_get_package_through_who $P2841, $P2840, "PAST"
    get_who $P2842, $P2841
    set $P2843, $P2842["Op"]
    find_lex $P2844, "$ml"
    unless_null $P2844, vivify_1681
    $P2844 = root_new ['parrot';'Hash']
  vivify_1681:
    set $P2845, $P2844["cond"]
    unless_null $P2845, vivify_1682
    new $P2845, "Undef"
  vivify_1682:
    $P2846 = $P2845."ast"()
    find_lex $P2847, "$past"
    unless_null $P2847, vivify_1683
    new $P2847, "Undef"
  vivify_1683:
    find_lex $P2848, "$ml"
    unless_null $P2848, vivify_1684
    $P2848 = root_new ['parrot';'Hash']
  vivify_1684:
    set $P2849, $P2848["sym"]
    unless_null $P2849, vivify_1685
    new $P2849, "Undef"
  vivify_1685:
    set $S2850, $P2849
    find_lex $P2851, "$/"
    unless_null $P2851, vivify_1686
    new $P2851, "Undef"
  vivify_1686:
    $P2852 = $P2843."new"($P2846, $P2847, $S2850 :named("pasttype"), $P2851 :named("node"))
    store_lex "$past", $P2852
.annotate 'line', 907
    set $P2808, $P2852
.annotate 'line', 899
    goto if_2809_end
  if_2809:
.annotate 'line', 900
    get_hll_global $P2814, "GLOBAL"
    nqp_get_package_through_who $P2815, $P2814, "PAST"
    get_who $P2816, $P2815
    set $P2817, $P2816["Block"]
.annotate 'line', 901
    get_hll_global $P2818, "GLOBAL"
    nqp_get_package_through_who $P2819, $P2818, "PAST"
    get_who $P2820, $P2819
    set $P2821, $P2820["Var"]
    $P2822 = $P2821."new"("$_" :named("name"), "parameter" :named("scope"), 1 :named("isdecl"))
    find_lex $P2823, "$past"
    unless_null $P2823, vivify_1687
    new $P2823, "Undef"
  vivify_1687:
    $P2824 = $P2817."new"($P2822, $P2823, "immediate" :named("blocktype"))
.annotate 'line', 900
    store_lex "$past", $P2824
.annotate 'line', 903
    find_lex $P2825, "$past"
    unless_null $P2825, vivify_1688
    new $P2825, "Undef"
  vivify_1688:
    $P2825."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 904
    find_lex $P2826, "$past"
    unless_null $P2826, vivify_1689
    new $P2826, "Undef"
  vivify_1689:
    $P2826."arity"(1)
.annotate 'line', 905
    get_hll_global $P2827, "GLOBAL"
    nqp_get_package_through_who $P2828, $P2827, "PAST"
    get_who $P2829, $P2828
    set $P2830, $P2829["Op"]
    find_lex $P2831, "$ml"
    unless_null $P2831, vivify_1690
    $P2831 = root_new ['parrot';'Hash']
  vivify_1690:
    set $P2832, $P2831["cond"]
    unless_null $P2832, vivify_1691
    new $P2832, "Undef"
  vivify_1691:
    $P2833 = $P2832."ast"()
    find_lex $P2834, "$past"
    unless_null $P2834, vivify_1692
    new $P2834, "Undef"
  vivify_1692:
    find_lex $P2835, "$ml"
    unless_null $P2835, vivify_1693
    $P2835 = root_new ['parrot';'Hash']
  vivify_1693:
    set $P2836, $P2835["sym"]
    unless_null $P2836, vivify_1694
    new $P2836, "Undef"
  vivify_1694:
    set $S2837, $P2836
    find_lex $P2838, "$/"
    unless_null $P2838, vivify_1695
    new $P2838, "Undef"
  vivify_1695:
    $P2839 = $P2830."new"($P2833, $P2834, $S2837 :named("pasttype"), $P2838 :named("node"))
    store_lex "$past", $P2839
.annotate 'line', 899
    set $P2808, $P2839
  if_2809_end:
.annotate 'line', 898
    set $P2805, $P2808
  if_2806_end:
.annotate 'line', 891
    .return ($P2805)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock"  :subid("440_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_2864
    .param pmc param_2865
.annotate 'line', 917
    .lex "self", param_2864
    .lex "$/", param_2865
.annotate 'line', 918
    find_lex $P2866, "$/"
    get_hll_global $P2867, "GLOBAL"
    nqp_get_package_through_who $P2868, $P2867, "PAST"
    get_who $P2869, $P2868
    set $P2870, $P2869["Op"]
    find_lex $P2871, "$/"
    unless_null $P2871, vivify_1697
    $P2871 = root_new ['parrot';'Hash']
  vivify_1697:
    set $P2872, $P2871["EXPR"]
    unless_null $P2872, vivify_1698
    new $P2872, "Undef"
  vivify_1698:
    $P2873 = $P2872."ast"()
    find_lex $P2874, "$/"
    unless_null $P2874, vivify_1699
    $P2874 = root_new ['parrot';'Hash']
  vivify_1699:
    set $P2875, $P2874["pblock"]
    unless_null $P2875, vivify_1700
    new $P2875, "Undef"
  vivify_1700:
    $P2876 = $P2875."ast"()
    find_lex $P2877, "$/"
    unless_null $P2877, vivify_1701
    new $P2877, "Undef"
  vivify_1701:
    $P2878 = $P2870."new"($P2873, $P2876, "if" :named("pasttype"), $P2877 :named("node"))
    $P2879 = $P2866."!make"($P2878)
.annotate 'line', 917
    .return ($P2879)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "pblock"  :subid("441_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_2881
    .param pmc param_2882
.annotate 'line', 921
    .lex "self", param_2881
    .lex "$/", param_2882
.annotate 'line', 922
    find_lex $P2883, "$/"
    find_lex $P2884, "$/"
    unless_null $P2884, vivify_1702
    $P2884 = root_new ['parrot';'Hash']
  vivify_1702:
    set $P2885, $P2884["blockoid"]
    unless_null $P2885, vivify_1703
    new $P2885, "Undef"
  vivify_1703:
    $P2886 = $P2885."ast"()
    $P2887 = $P2883."!make"($P2886)
.annotate 'line', 921
    .return ($P2887)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block"  :subid("442_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_2889
    .param pmc param_2890
.annotate 'line', 925
    .lex "self", param_2889
    .lex "$/", param_2890
.annotate 'line', 926
    find_lex $P2891, "$/"
    find_lex $P2892, "$/"
    unless_null $P2892, vivify_1704
    $P2892 = root_new ['parrot';'Hash']
  vivify_1704:
    set $P2893, $P2892["blockoid"]
    unless_null $P2893, vivify_1705
    new $P2893, "Undef"
  vivify_1705:
    $P2894 = $P2893."ast"()
    $P2895 = $P2891."!make"($P2894)
.annotate 'line', 925
    .return ($P2895)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blockoid"  :subid("443_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_2897
    .param pmc param_2898
.annotate 'line', 929
    .const 'Sub' $P2909 = "444_1304456155.152" 
    capture_lex $P2909
    .lex "self", param_2897
    .lex "$/", param_2898
.annotate 'line', 930
    new $P2899, "Undef"
    .lex "$BLOCK", $P2899
    find_lex $P2900, "$?PACKAGE"
    get_who $P2901, $P2900
    set $P2902, $P2901["@BLOCK"]
    unless_null $P2902, vivify_1706
    $P2902 = root_new ['parrot';'ResizablePMCArray']
  vivify_1706:
    $P2903 = $P2902."shift"()
    store_lex "$BLOCK", $P2903
.annotate 'line', 931
    find_lex $P2906, "$/"
    unless_null $P2906, vivify_1707
    $P2906 = root_new ['parrot';'Hash']
  vivify_1707:
    set $P2907, $P2906["statementlist"]
    unless_null $P2907, vivify_1708
    new $P2907, "Undef"
  vivify_1708:
    if $P2907, if_2905
.annotate 'line', 939
    find_dynamic_lex $P2926, "$*HAS_YOU_ARE_HERE"
    unless_null $P2926, vivify_1709
    get_hll_global $P2924, "GLOBAL"
    get_who $P2925, $P2924
    set $P2926, $P2925["$HAS_YOU_ARE_HERE"]
    unless_null $P2926, vivify_1710
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_1710:
  vivify_1709:
    unless $P2926, if_2923_end
.annotate 'line', 940
    find_lex $P2927, "$/"
    unless_null $P2927, vivify_1711
    new $P2927, "Undef"
  vivify_1711:
    $P2928 = $P2927."CURSOR"()
    $P2928."panic"("{YOU_ARE_HERE} may only appear once in a setting")
  if_2923_end:
.annotate 'line', 942
    new $P2929, "Integer"
    assign $P2929, 1
    store_dynamic_lex "$*HAS_YOU_ARE_HERE", $P2929
.annotate 'line', 943
    find_lex $P2930, "$/"
    find_lex $P2931, "$/"
    unless_null $P2931, vivify_1712
    $P2931 = root_new ['parrot';'Hash']
  vivify_1712:
    set $P2932, $P2931["you_are_here"]
    unless_null $P2932, vivify_1713
    new $P2932, "Undef"
  vivify_1713:
    $P2933 = $P2932."ast"()
    $P2934 = $P2930."!make"($P2933)
.annotate 'line', 938
    set $P2904, $P2934
.annotate 'line', 931
    goto if_2905_end
  if_2905:
    .const 'Sub' $P2909 = "444_1304456155.152" 
    capture_lex $P2909
    $P2922 = $P2909()
    set $P2904, $P2922
  if_2905_end:
.annotate 'line', 929
    .return ($P2904)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2908"  :anon :subid("444_1304456155.152") :outer("443_1304456155.152")
.annotate 'line', 932
    new $P2910, "Undef"
    .lex "$past", $P2910
    find_lex $P2911, "$/"
    unless_null $P2911, vivify_1714
    $P2911 = root_new ['parrot';'Hash']
  vivify_1714:
    set $P2912, $P2911["statementlist"]
    unless_null $P2912, vivify_1715
    new $P2912, "Undef"
  vivify_1715:
    $P2913 = $P2912."ast"()
    store_lex "$past", $P2913
.annotate 'line', 933
    find_lex $P2914, "$BLOCK"
    unless_null $P2914, vivify_1716
    new $P2914, "Undef"
  vivify_1716:
    find_lex $P2915, "$past"
    unless_null $P2915, vivify_1717
    new $P2915, "Undef"
  vivify_1717:
    $P2914."push"($P2915)
.annotate 'line', 934
    find_lex $P2916, "$BLOCK"
    unless_null $P2916, vivify_1718
    new $P2916, "Undef"
  vivify_1718:
    find_lex $P2917, "$/"
    unless_null $P2917, vivify_1719
    new $P2917, "Undef"
  vivify_1719:
    $P2916."node"($P2917)
.annotate 'line', 935
    find_lex $P2918, "$BLOCK"
    unless_null $P2918, vivify_1720
    new $P2918, "Undef"
  vivify_1720:
    $P2918."closure"(1)
.annotate 'line', 936
    find_dynamic_lex $P2919, "$/"
    find_lex $P2920, "$BLOCK"
    unless_null $P2920, vivify_1721
    new $P2920, "Undef"
  vivify_1721:
    $P2921 = $P2919."!make"($P2920)
.annotate 'line', 931
    .return ($P2921)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "newpad"  :subid("445_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_2936
    .param pmc param_2937
.annotate 'line', 947
    .lex "self", param_2936
    .lex "$/", param_2937
.annotate 'line', 948
    find_lex $P2938, "$?PACKAGE"
    get_who $P2939, $P2938
    set $P2940, $P2939["@BLOCK"]
    unless_null $P2940, vivify_1722
    $P2940 = root_new ['parrot';'ResizablePMCArray']
  vivify_1722:
    get_hll_global $P2941, "GLOBAL"
    nqp_get_package_through_who $P2942, $P2941, "PAST"
    get_who $P2943, $P2942
    set $P2944, $P2943["Block"]
    get_hll_global $P2945, "GLOBAL"
    nqp_get_package_through_who $P2946, $P2945, "PAST"
    get_who $P2947, $P2946
    set $P2948, $P2947["Stmts"]
    $P2949 = $P2948."new"()
    $P2950 = $P2944."new"($P2949)
    $P2951 = $P2940."unshift"($P2950)
.annotate 'line', 947
    .return ($P2951)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "outerctx"  :subid("446_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_2953
    .param pmc param_2954
.annotate 'line', 951
    .const 'Sub' $P2963 = "447_1304456155.152" 
    capture_lex $P2963
    .lex "self", param_2953
    .lex "$/", param_2954
.annotate 'line', 952
    find_dynamic_lex $P2958, "%*COMPILING"
    unless_null $P2958, vivify_1723
    get_hll_global $P2956, "GLOBAL"
    get_who $P2957, $P2956
    set $P2958, $P2957["%COMPILING"]
    unless_null $P2958, vivify_1724
    die "Contextual %*COMPILING not found"
  vivify_1724:
  vivify_1723:
    set $P2959, $P2958["%?OPTIONS"]
    unless_null $P2959, vivify_1725
    $P2959 = root_new ['parrot';'Hash']
  vivify_1725:
    set $P2960, $P2959["outer_ctx"]
    unless_null $P2960, vivify_1726
    new $P2960, "Undef"
  vivify_1726:
    defined $I2961, $P2960
    if $I2961, unless_2955_end
    .const 'Sub' $P2963 = "447_1304456155.152" 
    capture_lex $P2963
    $P2963()
  unless_2955_end:
.annotate 'line', 965
    find_lex $P2995, "self"
    find_lex $P2996, "$?PACKAGE"
    get_who $P2997, $P2996
    set $P2998, $P2997["@BLOCK"]
    unless_null $P2998, vivify_1742
    $P2998 = root_new ['parrot';'ResizablePMCArray']
  vivify_1742:
    set $P2999, $P2998[0]
    unless_null $P2999, vivify_1743
    new $P2999, "Undef"
  vivify_1743:
    $P3000 = $P2995."SET_BLOCK_OUTER_CTX"($P2999)
.annotate 'line', 951
    .return ($P3000)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2962"  :anon :subid("447_1304456155.152") :outer("446_1304456155.152")
.annotate 'line', 955
    new $P2964, "Undef"
    .lex "$SETTING", $P2964
    find_dynamic_lex $P2967, "$*SC"
    unless_null $P2967, vivify_1727
    get_hll_global $P2965, "GLOBAL"
    get_who $P2966, $P2965
    set $P2967, $P2966["$SC"]
    unless_null $P2967, vivify_1728
    die "Contextual $*SC not found"
  vivify_1728:
  vivify_1727:
    find_dynamic_lex $P2971, "%*COMPILING"
    unless_null $P2971, vivify_1729
    get_hll_global $P2969, "GLOBAL"
    get_who $P2970, $P2969
    set $P2971, $P2970["%COMPILING"]
    unless_null $P2971, vivify_1730
    die "Contextual %*COMPILING not found"
  vivify_1730:
  vivify_1729:
    set $P2972, $P2971["%?OPTIONS"]
    unless_null $P2972, vivify_1731
    $P2972 = root_new ['parrot';'Hash']
  vivify_1731:
    set $P2973, $P2972["setting"]
    unless_null $P2973, vivify_1732
    new $P2973, "Undef"
  vivify_1732:
    set $P2968, $P2973
    defined $I2975, $P2968
    if $I2975, default_2974
    new $P2976, "String"
    assign $P2976, "NQPCORE"
    set $P2968, $P2976
  default_2974:
    $P2977 = $P2967."load_setting"($P2968)
    store_lex "$SETTING", $P2977
.annotate 'line', 960
    find_dynamic_lex $P2982, "%*COMPILING"
    unless_null $P2982, vivify_1733
    get_hll_global $P2980, "GLOBAL"
    get_who $P2981, $P2980
    set $P2982, $P2981["%COMPILING"]
    unless_null $P2982, vivify_1734
    die "Contextual %*COMPILING not found"
  vivify_1734:
  vivify_1733:
    set $P2983, $P2982["%?OPTIONS"]
    unless_null $P2983, vivify_1735
    $P2983 = root_new ['parrot';'Hash']
  vivify_1735:
    set $P2984, $P2983["setting"]
    unless_null $P2984, vivify_1736
    new $P2984, "Undef"
  vivify_1736:
    set $S2985, $P2984
    iseq $I2986, $S2985, "NULL"
    unless $I2986, unless_2979
    new $P2978, 'Integer'
    set $P2978, $I2986
    goto unless_2979_end
  unless_2979:
.annotate 'line', 961
    find_lex $P2987, "$SETTING"
    unless_null $P2987, vivify_1737
    new $P2987, "Undef"
  vivify_1737:
    "import_HOW_exports"($P2987)
.annotate 'line', 962
    find_dynamic_lex $P2990, "$*SC"
    unless_null $P2990, vivify_1738
    get_hll_global $P2988, "GLOBAL"
    get_who $P2989, $P2988
    set $P2990, $P2989["$SC"]
    unless_null $P2990, vivify_1739
    die "Contextual $*SC not found"
  vivify_1739:
  vivify_1738:
    find_dynamic_lex $P2993, "$*GLOBALish"
    unless_null $P2993, vivify_1740
    get_hll_global $P2991, "GLOBAL"
    get_who $P2992, $P2991
    set $P2993, $P2992["$GLOBALish"]
    unless_null $P2993, vivify_1741
    die "Contextual $*GLOBALish not found"
  vivify_1741:
  vivify_1740:
    $P2994 = $P2990."load_module"("Regex", $P2993)
.annotate 'line', 960
    set $P2978, $P2994
  unless_2979_end:
.annotate 'line', 952
    .return ($P2978)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "GLOBALish"  :subid("448_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_3003
    .param pmc param_3004
.annotate 'line', 977
    .lex "self", param_3003
    .lex "$/", param_3004
.annotate 'line', 981
    find_dynamic_lex $P3007, "$*SC"
    unless_null $P3007, vivify_1744
    get_hll_global $P3005, "GLOBAL"
    get_who $P3006, $P3005
    set $P3007, $P3006["$SC"]
    unless_null $P3007, vivify_1745
    die "Contextual $*SC not found"
  vivify_1745:
  vivify_1744:
    find_dynamic_lex $P3010, "%*HOW"
    unless_null $P3010, vivify_1746
    get_hll_global $P3008, "GLOBAL"
    get_who $P3009, $P3008
    set $P3010, $P3009["%HOW"]
    unless_null $P3010, vivify_1747
    die "Contextual %*HOW not found"
  vivify_1747:
  vivify_1746:
    set $P3011, $P3010["knowhow"]
    unless_null $P3011, vivify_1748
    new $P3011, "Undef"
  vivify_1748:
    $P3012 = $P3007."pkg_create_mo"($P3011, "GLOBALish" :named("name"))
    store_dynamic_lex "$*GLOBALish", $P3012
.annotate 'line', 982
    find_dynamic_lex $P3015, "$*GLOBALish"
    unless_null $P3015, vivify_1749
    get_hll_global $P3013, "GLOBAL"
    get_who $P3014, $P3013
    set $P3015, $P3014["$GLOBALish"]
    unless_null $P3015, vivify_1750
    die "Contextual $*GLOBALish not found"
  vivify_1750:
  vivify_1749:
    get_how $P3016, $P3015
    find_dynamic_lex $P3019, "$*GLOBALish"
    unless_null $P3019, vivify_1751
    get_hll_global $P3017, "GLOBAL"
    get_who $P3018, $P3017
    set $P3019, $P3018["$GLOBALish"]
    unless_null $P3019, vivify_1752
    die "Contextual $*GLOBALish not found"
  vivify_1752:
  vivify_1751:
    $P3016."compose"($P3019)
.annotate 'line', 983
    find_dynamic_lex $P3022, "$*SC"
    unless_null $P3022, vivify_1753
    get_hll_global $P3020, "GLOBAL"
    get_who $P3021, $P3020
    set $P3022, $P3021["$SC"]
    unless_null $P3022, vivify_1754
    die "Contextual $*SC not found"
  vivify_1754:
  vivify_1753:
    find_lex $P3023, "$?PACKAGE"
    get_who $P3024, $P3023
    set $P3025, $P3024["@BLOCK"]
    unless_null $P3025, vivify_1755
    $P3025 = root_new ['parrot';'ResizablePMCArray']
  vivify_1755:
    set $P3026, $P3025[0]
    unless_null $P3026, vivify_1756
    new $P3026, "Undef"
  vivify_1756:
    find_dynamic_lex $P3029, "$*GLOBALish"
    unless_null $P3029, vivify_1757
    get_hll_global $P3027, "GLOBAL"
    get_who $P3028, $P3027
    set $P3029, $P3028["$GLOBALish"]
    unless_null $P3029, vivify_1758
    die "Contextual $*GLOBALish not found"
  vivify_1758:
  vivify_1757:
    $P3022."install_lexical_symbol"($P3026, "GLOBALish", $P3029)
.annotate 'line', 986
    find_dynamic_lex $P3032, "$*GLOBALish"
    unless_null $P3032, vivify_1759
    get_hll_global $P3030, "GLOBAL"
    get_who $P3031, $P3030
    set $P3032, $P3031["$GLOBALish"]
    unless_null $P3032, vivify_1760
    die "Contextual $*GLOBALish not found"
  vivify_1760:
  vivify_1759:
    store_dynamic_lex "$*PACKAGE", $P3032
.annotate 'line', 987
    find_dynamic_lex $P3035, "$*SC"
    unless_null $P3035, vivify_1761
    get_hll_global $P3033, "GLOBAL"
    get_who $P3034, $P3033
    set $P3035, $P3034["$SC"]
    unless_null $P3035, vivify_1762
    die "Contextual $*SC not found"
  vivify_1762:
  vivify_1761:
    find_lex $P3036, "$?PACKAGE"
    get_who $P3037, $P3036
    set $P3038, $P3037["@BLOCK"]
    unless_null $P3038, vivify_1763
    $P3038 = root_new ['parrot';'ResizablePMCArray']
  vivify_1763:
    set $P3039, $P3038[0]
    unless_null $P3039, vivify_1764
    new $P3039, "Undef"
  vivify_1764:
    find_dynamic_lex $P3042, "$*PACKAGE"
    unless_null $P3042, vivify_1765
    get_hll_global $P3040, "GLOBAL"
    get_who $P3041, $P3040
    set $P3042, $P3041["$PACKAGE"]
    unless_null $P3042, vivify_1766
    die "Contextual $*PACKAGE not found"
  vivify_1766:
  vivify_1765:
    $P3043 = $P3035."install_lexical_symbol"($P3039, "$?PACKAGE", $P3042)
.annotate 'line', 977
    .return ($P3043)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "you_are_here"  :subid("449_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_3045
    .param pmc param_3046
.annotate 'line', 990
    .lex "self", param_3045
    .lex "$/", param_3046
.annotate 'line', 991
    find_lex $P3047, "$/"
    find_lex $P3048, "self"
    $P3049 = $P3048."CTXSAVE"()
    $P3050 = $P3047."!make"($P3049)
.annotate 'line', 990
    .return ($P3050)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<use>"  :subid("450_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_3052
    .param pmc param_3053
.annotate 'line', 996
    .lex "self", param_3052
    .lex "$/", param_3053
.annotate 'line', 997
    new $P3054, "Undef"
    .lex "$module", $P3054
    find_dynamic_lex $P3057, "$*SC"
    unless_null $P3057, vivify_1767
    get_hll_global $P3055, "GLOBAL"
    get_who $P3056, $P3055
    set $P3057, $P3056["$SC"]
    unless_null $P3057, vivify_1768
    die "Contextual $*SC not found"
  vivify_1768:
  vivify_1767:
    find_lex $P3058, "$/"
    unless_null $P3058, vivify_1769
    $P3058 = root_new ['parrot';'Hash']
  vivify_1769:
    set $P3059, $P3058["name"]
    unless_null $P3059, vivify_1770
    new $P3059, "Undef"
  vivify_1770:
    set $S3060, $P3059
    find_dynamic_lex $P3063, "$*GLOBALish"
    unless_null $P3063, vivify_1771
    get_hll_global $P3061, "GLOBAL"
    get_who $P3062, $P3061
    set $P3063, $P3062["$GLOBALish"]
    unless_null $P3063, vivify_1772
    die "Contextual $*GLOBALish not found"
  vivify_1772:
  vivify_1771:
    $P3064 = $P3057."load_module"($S3060, $P3063)
    store_lex "$module", $P3064
.annotate 'line', 998
    find_lex $P3066, "$module"
    unless_null $P3066, vivify_1773
    new $P3066, "Undef"
  vivify_1773:
    defined $I3067, $P3066
    unless $I3067, if_3065_end
.annotate 'line', 999
    find_lex $P3068, "$module"
    unless_null $P3068, vivify_1774
    new $P3068, "Undef"
  vivify_1774:
    "import_HOW_exports"($P3068)
  if_3065_end:
.annotate 'line', 1001
    find_lex $P3069, "$/"
    get_hll_global $P3070, "GLOBAL"
    nqp_get_package_through_who $P3071, $P3070, "PAST"
    get_who $P3072, $P3071
    set $P3073, $P3072["Stmts"]
    $P3074 = $P3073."new"()
    $P3075 = $P3069."!make"($P3074)
.annotate 'line', 996
    .return ($P3075)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statement_control:sym<if>"  :subid("451_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_3077
    .param pmc param_3078
.annotate 'line', 1004
    .const 'Sub' $P3106 = "452_1304456155.152" 
    capture_lex $P3106
    .lex "self", param_3077
    .lex "$/", param_3078
.annotate 'line', 1005
    new $P3079, "Undef"
    .lex "$count", $P3079
.annotate 'line', 1006
    new $P3080, "Undef"
    .lex "$past", $P3080
.annotate 'line', 1005
    find_lex $P3081, "$/"
    unless_null $P3081, vivify_1775
    $P3081 = root_new ['parrot';'Hash']
  vivify_1775:
    set $P3082, $P3081["xblock"]
    unless_null $P3082, vivify_1776
    new $P3082, "Undef"
  vivify_1776:
    set $N3083, $P3082
    new $P3084, 'Float'
    set $P3084, $N3083
    sub $P3085, $P3084, 1
    store_lex "$count", $P3085
.annotate 'line', 1006
    find_lex $P3086, "$count"
    unless_null $P3086, vivify_1777
    new $P3086, "Undef"
  vivify_1777:
    set $I3087, $P3086
    find_lex $P3088, "$/"
    unless_null $P3088, vivify_1778
    $P3088 = root_new ['parrot';'Hash']
  vivify_1778:
    set $P3089, $P3088["xblock"]
    unless_null $P3089, vivify_1779
    $P3089 = root_new ['parrot';'ResizablePMCArray']
  vivify_1779:
    set $P3090, $P3089[$I3087]
    unless_null $P3090, vivify_1780
    new $P3090, "Undef"
  vivify_1780:
    $P3091 = $P3090."ast"()
    $P3092 = "xblock_immediate"($P3091)
    store_lex "$past", $P3092
.annotate 'line', 1007
    find_lex $P3094, "$/"
    unless_null $P3094, vivify_1781
    $P3094 = root_new ['parrot';'Hash']
  vivify_1781:
    set $P3095, $P3094["else"]
    unless_null $P3095, vivify_1782
    new $P3095, "Undef"
  vivify_1782:
    unless $P3095, if_3093_end
.annotate 'line', 1008
    find_lex $P3096, "$past"
    unless_null $P3096, vivify_1783
    new $P3096, "Undef"
  vivify_1783:
    find_lex $P3097, "$/"
    unless_null $P3097, vivify_1784
    $P3097 = root_new ['parrot';'Hash']
  vivify_1784:
    set $P3098, $P3097["else"]
    unless_null $P3098, vivify_1785
    $P3098 = root_new ['parrot';'ResizablePMCArray']
  vivify_1785:
    set $P3099, $P3098[0]
    unless_null $P3099, vivify_1786
    new $P3099, "Undef"
  vivify_1786:
    $P3100 = $P3099."ast"()
    $P3101 = "block_immediate"($P3100)
    $P3096."push"($P3101)
  if_3093_end:
.annotate 'line', 1011
    new $P3122, 'ExceptionHandler'
    set_label $P3122, loop3121_handler
    $P3122."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3122
  loop3121_test:
    find_lex $P3102, "$count"
    unless_null $P3102, vivify_1787
    new $P3102, "Undef"
  vivify_1787:
    set $N3103, $P3102
    isgt $I3104, $N3103, 0.0
    unless $I3104, loop3121_done
  loop3121_redo:
    .const 'Sub' $P3106 = "452_1304456155.152" 
    capture_lex $P3106
    $P3106()
  loop3121_next:
    goto loop3121_test
  loop3121_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3123, exception, 'type'
    eq $P3123, .CONTROL_LOOP_NEXT, loop3121_next
    eq $P3123, .CONTROL_LOOP_REDO, loop3121_redo
  loop3121_done:
    pop_eh 
.annotate 'line', 1017
    find_lex $P3124, "$/"
    find_lex $P3125, "$past"
    unless_null $P3125, vivify_1796
    new $P3125, "Undef"
  vivify_1796:
    $P3126 = $P3124."!make"($P3125)
.annotate 'line', 1004
    .return ($P3126)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3105"  :anon :subid("452_1304456155.152") :outer("451_1304456155.152")
.annotate 'line', 1013
    new $P3107, "Undef"
    .lex "$else", $P3107
.annotate 'line', 1011
    find_lex $P3108, "$count"
    unless_null $P3108, vivify_1788
    new $P3108, "Undef"
  vivify_1788:
    clone $P3109, $P3108
    dec $P3108
.annotate 'line', 1013
    find_lex $P3110, "$past"
    unless_null $P3110, vivify_1789
    new $P3110, "Undef"
  vivify_1789:
    store_lex "$else", $P3110
.annotate 'line', 1014
    find_lex $P3111, "$count"
    unless_null $P3111, vivify_1790
    new $P3111, "Undef"
  vivify_1790:
    set $I3112, $P3111
    find_lex $P3113, "$/"
    unless_null $P3113, vivify_1791
    $P3113 = root_new ['parrot';'Hash']
  vivify_1791:
    set $P3114, $P3113["xblock"]
    unless_null $P3114, vivify_1792
    $P3114 = root_new ['parrot';'ResizablePMCArray']
  vivify_1792:
    set $P3115, $P3114[$I3112]
    unless_null $P3115, vivify_1793
    new $P3115, "Undef"
  vivify_1793:
    $P3116 = $P3115."ast"()
    $P3117 = "xblock_immediate"($P3116)
    store_lex "$past", $P3117
.annotate 'line', 1015
    find_lex $P3118, "$past"
    unless_null $P3118, vivify_1794
    new $P3118, "Undef"
  vivify_1794:
    find_lex $P3119, "$else"
    unless_null $P3119, vivify_1795
    new $P3119, "Undef"
  vivify_1795:
    $P3120 = $P3118."push"($P3119)
.annotate 'line', 1011
    .return ($P3120)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<unless>"  :subid("453_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_3128
    .param pmc param_3129
.annotate 'line', 1020
    .lex "self", param_3128
    .lex "$/", param_3129
.annotate 'line', 1021
    new $P3130, "Undef"
    .lex "$past", $P3130
    find_lex $P3131, "$/"
    unless_null $P3131, vivify_1797
    $P3131 = root_new ['parrot';'Hash']
  vivify_1797:
    set $P3132, $P3131["xblock"]
    unless_null $P3132, vivify_1798
    new $P3132, "Undef"
  vivify_1798:
    $P3133 = $P3132."ast"()
    $P3134 = "xblock_immediate"($P3133)
    store_lex "$past", $P3134
.annotate 'line', 1022
    find_lex $P3135, "$past"
    unless_null $P3135, vivify_1799
    new $P3135, "Undef"
  vivify_1799:
    $P3135."pasttype"("unless")
.annotate 'line', 1023
    find_lex $P3136, "$/"
    find_lex $P3137, "$past"
    unless_null $P3137, vivify_1800
    new $P3137, "Undef"
  vivify_1800:
    $P3138 = $P3136."!make"($P3137)
.annotate 'line', 1020
    .return ($P3138)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<while>"  :subid("454_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_3140
    .param pmc param_3141
.annotate 'line', 1026
    .lex "self", param_3140
    .lex "$/", param_3141
.annotate 'line', 1027
    new $P3142, "Undef"
    .lex "$past", $P3142
    find_lex $P3143, "$/"
    unless_null $P3143, vivify_1801
    $P3143 = root_new ['parrot';'Hash']
  vivify_1801:
    set $P3144, $P3143["xblock"]
    unless_null $P3144, vivify_1802
    new $P3144, "Undef"
  vivify_1802:
    $P3145 = $P3144."ast"()
    $P3146 = "xblock_immediate"($P3145)
    store_lex "$past", $P3146
.annotate 'line', 1028
    find_lex $P3147, "$past"
    unless_null $P3147, vivify_1803
    new $P3147, "Undef"
  vivify_1803:
    find_lex $P3148, "$/"
    unless_null $P3148, vivify_1804
    $P3148 = root_new ['parrot';'Hash']
  vivify_1804:
    set $P3149, $P3148["sym"]
    unless_null $P3149, vivify_1805
    new $P3149, "Undef"
  vivify_1805:
    set $S3150, $P3149
    $P3147."pasttype"($S3150)
.annotate 'line', 1029
    find_lex $P3151, "$/"
    find_lex $P3152, "$past"
    unless_null $P3152, vivify_1806
    new $P3152, "Undef"
  vivify_1806:
    $P3153 = $P3151."!make"($P3152)
.annotate 'line', 1026
    .return ($P3153)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<repeat>"  :subid("455_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_3155
    .param pmc param_3156
.annotate 'line', 1032
    .lex "self", param_3155
    .lex "$/", param_3156
.annotate 'line', 1033
    new $P3157, "Undef"
    .lex "$pasttype", $P3157
.annotate 'line', 1034
    new $P3158, "Undef"
    .lex "$past", $P3158
.annotate 'line', 1033
    new $P3159, "String"
    assign $P3159, "repeat_"
    find_lex $P3160, "$/"
    unless_null $P3160, vivify_1807
    $P3160 = root_new ['parrot';'Hash']
  vivify_1807:
    set $P3161, $P3160["wu"]
    unless_null $P3161, vivify_1808
    new $P3161, "Undef"
  vivify_1808:
    set $S3162, $P3161
    concat $P3163, $P3159, $S3162
    store_lex "$pasttype", $P3163
    find_lex $P3164, "$past"
    unless_null $P3164, vivify_1809
    new $P3164, "Undef"
  vivify_1809:
.annotate 'line', 1035
    find_lex $P3166, "$/"
    unless_null $P3166, vivify_1810
    $P3166 = root_new ['parrot';'Hash']
  vivify_1810:
    set $P3167, $P3166["xblock"]
    unless_null $P3167, vivify_1811
    new $P3167, "Undef"
  vivify_1811:
    if $P3167, if_3165
.annotate 'line', 1040
    get_hll_global $P3174, "GLOBAL"
    nqp_get_package_through_who $P3175, $P3174, "PAST"
    get_who $P3176, $P3175
    set $P3177, $P3176["Op"]
    find_lex $P3178, "$/"
    unless_null $P3178, vivify_1812
    $P3178 = root_new ['parrot';'Hash']
  vivify_1812:
    set $P3179, $P3178["EXPR"]
    unless_null $P3179, vivify_1813
    new $P3179, "Undef"
  vivify_1813:
    $P3180 = $P3179."ast"()
    find_lex $P3181, "$/"
    unless_null $P3181, vivify_1814
    $P3181 = root_new ['parrot';'Hash']
  vivify_1814:
    set $P3182, $P3181["pblock"]
    unless_null $P3182, vivify_1815
    new $P3182, "Undef"
  vivify_1815:
    $P3183 = $P3182."ast"()
    $P3184 = "block_immediate"($P3183)
    find_lex $P3185, "$pasttype"
    unless_null $P3185, vivify_1816
    new $P3185, "Undef"
  vivify_1816:
    find_lex $P3186, "$/"
    unless_null $P3186, vivify_1817
    new $P3186, "Undef"
  vivify_1817:
    $P3187 = $P3177."new"($P3180, $P3184, $P3185 :named("pasttype"), $P3186 :named("node"))
    store_lex "$past", $P3187
.annotate 'line', 1039
    goto if_3165_end
  if_3165:
.annotate 'line', 1036
    find_lex $P3168, "$/"
    unless_null $P3168, vivify_1818
    $P3168 = root_new ['parrot';'Hash']
  vivify_1818:
    set $P3169, $P3168["xblock"]
    unless_null $P3169, vivify_1819
    new $P3169, "Undef"
  vivify_1819:
    $P3170 = $P3169."ast"()
    $P3171 = "xblock_immediate"($P3170)
    store_lex "$past", $P3171
.annotate 'line', 1037
    find_lex $P3172, "$past"
    unless_null $P3172, vivify_1820
    new $P3172, "Undef"
  vivify_1820:
    find_lex $P3173, "$pasttype"
    unless_null $P3173, vivify_1821
    new $P3173, "Undef"
  vivify_1821:
    $P3172."pasttype"($P3173)
  if_3165_end:
.annotate 'line', 1043
    find_lex $P3188, "$/"
    find_lex $P3189, "$past"
    unless_null $P3189, vivify_1822
    new $P3189, "Undef"
  vivify_1822:
    $P3190 = $P3188."!make"($P3189)
.annotate 'line', 1032
    .return ($P3190)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<for>"  :subid("456_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_3192
    .param pmc param_3193
.annotate 'line', 1046
    .lex "self", param_3192
    .lex "$/", param_3193
.annotate 'line', 1047
    new $P3194, "Undef"
    .lex "$past", $P3194
.annotate 'line', 1049
    new $P3195, "Undef"
    .lex "$block", $P3195
.annotate 'line', 1047
    find_lex $P3196, "$/"
    unless_null $P3196, vivify_1823
    $P3196 = root_new ['parrot';'Hash']
  vivify_1823:
    set $P3197, $P3196["xblock"]
    unless_null $P3197, vivify_1824
    new $P3197, "Undef"
  vivify_1824:
    $P3198 = $P3197."ast"()
    store_lex "$past", $P3198
.annotate 'line', 1048
    find_lex $P3199, "$past"
    unless_null $P3199, vivify_1825
    new $P3199, "Undef"
  vivify_1825:
    $P3199."pasttype"("for")
.annotate 'line', 1049
    find_lex $P3200, "$past"
    unless_null $P3200, vivify_1826
    $P3200 = root_new ['parrot';'ResizablePMCArray']
  vivify_1826:
    set $P3201, $P3200[1]
    unless_null $P3201, vivify_1827
    new $P3201, "Undef"
  vivify_1827:
    store_lex "$block", $P3201
.annotate 'line', 1050
    find_lex $P3203, "$block"
    unless_null $P3203, vivify_1828
    new $P3203, "Undef"
  vivify_1828:
    $P3204 = $P3203."arity"()
    if $P3204, unless_3202_end
.annotate 'line', 1051
    find_lex $P3205, "$block"
    unless_null $P3205, vivify_1829
    $P3205 = root_new ['parrot';'ResizablePMCArray']
  vivify_1829:
    set $P3206, $P3205[0]
    unless_null $P3206, vivify_1830
    new $P3206, "Undef"
  vivify_1830:
    get_hll_global $P3207, "GLOBAL"
    nqp_get_package_through_who $P3208, $P3207, "PAST"
    get_who $P3209, $P3208
    set $P3210, $P3209["Var"]
    $P3211 = $P3210."new"("$_" :named("name"), "parameter" :named("scope"))
    $P3206."push"($P3211)
.annotate 'line', 1052
    find_lex $P3212, "$block"
    unless_null $P3212, vivify_1831
    new $P3212, "Undef"
  vivify_1831:
    $P3212."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 1053
    find_lex $P3213, "$block"
    unless_null $P3213, vivify_1832
    new $P3213, "Undef"
  vivify_1832:
    $P3213."arity"(1)
  unless_3202_end:
.annotate 'line', 1055
    find_lex $P3214, "$block"
    unless_null $P3214, vivify_1833
    new $P3214, "Undef"
  vivify_1833:
    $P3214."blocktype"("immediate")
.annotate 'line', 1056
    find_lex $P3215, "$/"
    find_lex $P3216, "$past"
    unless_null $P3216, vivify_1834
    new $P3216, "Undef"
  vivify_1834:
    $P3217 = $P3215."!make"($P3216)
.annotate 'line', 1046
    .return ($P3217)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CATCH>"  :subid("457_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_3219
    .param pmc param_3220
.annotate 'line', 1059
    .lex "self", param_3219
    .lex "$/", param_3220
.annotate 'line', 1060
    new $P3221, "Undef"
    .lex "$block", $P3221
    find_lex $P3222, "$/"
    unless_null $P3222, vivify_1835
    $P3222 = root_new ['parrot';'Hash']
  vivify_1835:
    set $P3223, $P3222["block"]
    unless_null $P3223, vivify_1836
    new $P3223, "Undef"
  vivify_1836:
    $P3224 = $P3223."ast"()
    store_lex "$block", $P3224
.annotate 'line', 1061
    find_lex $P3225, "$/"
    unless_null $P3225, vivify_1837
    new $P3225, "Undef"
  vivify_1837:
    find_lex $P3226, "$block"
    unless_null $P3226, vivify_1838
    new $P3226, "Undef"
  vivify_1838:
    "push_block_handler"($P3225, $P3226)
.annotate 'line', 1062
    find_lex $P3227, "$?PACKAGE"
    get_who $P3228, $P3227
    set $P3229, $P3228["@BLOCK"]
    unless_null $P3229, vivify_1839
    $P3229 = root_new ['parrot';'ResizablePMCArray']
  vivify_1839:
    set $P3230, $P3229[0]
    unless_null $P3230, vivify_1840
    new $P3230, "Undef"
  vivify_1840:
    $P3231 = $P3230."handlers"()
    set $P3232, $P3231[0]
    unless_null $P3232, vivify_1841
    new $P3232, "Undef"
  vivify_1841:
    $P3232."handle_types_except"("CONTROL")
.annotate 'line', 1063
    find_lex $P3233, "$/"
    get_hll_global $P3234, "GLOBAL"
    nqp_get_package_through_who $P3235, $P3234, "PAST"
    get_who $P3236, $P3235
    set $P3237, $P3236["Stmts"]
    find_lex $P3238, "$/"
    unless_null $P3238, vivify_1842
    new $P3238, "Undef"
  vivify_1842:
    $P3239 = $P3237."new"($P3238 :named("node"))
    $P3240 = $P3233."!make"($P3239)
.annotate 'line', 1059
    .return ($P3240)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CONTROL>"  :subid("458_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_3242
    .param pmc param_3243
.annotate 'line', 1066
    .lex "self", param_3242
    .lex "$/", param_3243
.annotate 'line', 1067
    new $P3244, "Undef"
    .lex "$block", $P3244
    find_lex $P3245, "$/"
    unless_null $P3245, vivify_1843
    $P3245 = root_new ['parrot';'Hash']
  vivify_1843:
    set $P3246, $P3245["block"]
    unless_null $P3246, vivify_1844
    new $P3246, "Undef"
  vivify_1844:
    $P3247 = $P3246."ast"()
    store_lex "$block", $P3247
.annotate 'line', 1068
    find_lex $P3248, "$/"
    unless_null $P3248, vivify_1845
    new $P3248, "Undef"
  vivify_1845:
    find_lex $P3249, "$block"
    unless_null $P3249, vivify_1846
    new $P3249, "Undef"
  vivify_1846:
    "push_block_handler"($P3248, $P3249)
.annotate 'line', 1069
    find_lex $P3250, "$?PACKAGE"
    get_who $P3251, $P3250
    set $P3252, $P3251["@BLOCK"]
    unless_null $P3252, vivify_1847
    $P3252 = root_new ['parrot';'ResizablePMCArray']
  vivify_1847:
    set $P3253, $P3252[0]
    unless_null $P3253, vivify_1848
    new $P3253, "Undef"
  vivify_1848:
    $P3254 = $P3253."handlers"()
    set $P3255, $P3254[0]
    unless_null $P3255, vivify_1849
    new $P3255, "Undef"
  vivify_1849:
    $P3255."handle_types"("CONTROL")
.annotate 'line', 1070
    find_lex $P3256, "$/"
    get_hll_global $P3257, "GLOBAL"
    nqp_get_package_through_who $P3258, $P3257, "PAST"
    get_who $P3259, $P3258
    set $P3260, $P3259["Stmts"]
    find_lex $P3261, "$/"
    unless_null $P3261, vivify_1850
    new $P3261, "Undef"
  vivify_1850:
    $P3262 = $P3260."new"($P3261 :named("node"))
    $P3263 = $P3256."!make"($P3262)
.annotate 'line', 1066
    .return ($P3263)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<INIT>"  :subid("459_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_3266
    .param pmc param_3267
.annotate 'line', 1110
    .lex "self", param_3266
    .lex "$/", param_3267
.annotate 'line', 1111
    find_lex $P3268, "$?PACKAGE"
    get_who $P3269, $P3268
    set $P3270, $P3269["@BLOCK"]
    unless_null $P3270, vivify_1851
    $P3270 = root_new ['parrot';'ResizablePMCArray']
  vivify_1851:
    set $P3271, $P3270[0]
    unless_null $P3271, vivify_1852
    new $P3271, "Undef"
  vivify_1852:
    find_lex $P3272, "$/"
    unless_null $P3272, vivify_1853
    $P3272 = root_new ['parrot';'Hash']
  vivify_1853:
    set $P3273, $P3272["blorst"]
    unless_null $P3273, vivify_1854
    new $P3273, "Undef"
  vivify_1854:
    $P3274 = $P3273."ast"()
    $P3271."push"($P3274)
.annotate 'line', 1112
    find_lex $P3275, "$/"
    get_hll_global $P3276, "GLOBAL"
    nqp_get_package_through_who $P3277, $P3276, "PAST"
    get_who $P3278, $P3277
    set $P3279, $P3278["Stmts"]
    $P3280 = $P3279."new"()
    $P3281 = $P3275."!make"($P3280)
.annotate 'line', 1110
    .return ($P3281)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<try>"  :subid("460_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_3283
    .param pmc param_3284
.annotate 'line', 1115
    .lex "self", param_3283
    .lex "$/", param_3284
.annotate 'line', 1116
    new $P3285, "Undef"
    .lex "$past", $P3285
    find_lex $P3286, "$/"
    unless_null $P3286, vivify_1855
    $P3286 = root_new ['parrot';'Hash']
  vivify_1855:
    set $P3287, $P3286["blorst"]
    unless_null $P3287, vivify_1856
    new $P3287, "Undef"
  vivify_1856:
    $P3288 = $P3287."ast"()
    store_lex "$past", $P3288
.annotate 'line', 1117
    get_hll_global $P3290, "GLOBAL"
    nqp_get_package_through_who $P3291, $P3290, "PAST"
    get_who $P3292, $P3291
    set $P3293, $P3292["Block"]
    find_lex $P3294, "$past"
    unless_null $P3294, vivify_1857
    new $P3294, "Undef"
  vivify_1857:
    $P3295 = $P3293."ACCEPTS"($P3294)
    if $P3295, unless_3289_end
.annotate 'line', 1118
    get_hll_global $P3296, "GLOBAL"
    nqp_get_package_through_who $P3297, $P3296, "PAST"
    get_who $P3298, $P3297
    set $P3299, $P3298["Block"]
    find_lex $P3300, "$past"
    unless_null $P3300, vivify_1858
    new $P3300, "Undef"
  vivify_1858:
    find_lex $P3301, "$/"
    unless_null $P3301, vivify_1859
    new $P3301, "Undef"
  vivify_1859:
    $P3302 = $P3299."new"($P3300, "immediate" :named("blocktype"), $P3301 :named("node"))
    store_lex "$past", $P3302
  unless_3289_end:
.annotate 'line', 1120
    find_lex $P3304, "$past"
    unless_null $P3304, vivify_1860
    new $P3304, "Undef"
  vivify_1860:
    $P3305 = $P3304."handlers"()
    if $P3305, unless_3303_end
.annotate 'line', 1121
    find_lex $P3306, "$past"
    unless_null $P3306, vivify_1861
    new $P3306, "Undef"
  vivify_1861:
    get_hll_global $P3307, "GLOBAL"
    nqp_get_package_through_who $P3308, $P3307, "PAST"
    get_who $P3309, $P3308
    set $P3310, $P3309["Control"]
.annotate 'line', 1123
    get_hll_global $P3311, "GLOBAL"
    nqp_get_package_through_who $P3312, $P3311, "PAST"
    get_who $P3313, $P3312
    set $P3314, $P3313["Stmts"]
.annotate 'line', 1124
    get_hll_global $P3315, "GLOBAL"
    nqp_get_package_through_who $P3316, $P3315, "PAST"
    get_who $P3317, $P3316
    set $P3318, $P3317["Op"]
.annotate 'line', 1125
    get_hll_global $P3319, "GLOBAL"
    nqp_get_package_through_who $P3320, $P3319, "PAST"
    get_who $P3321, $P3320
    set $P3322, $P3321["Var"]
.annotate 'line', 1126
    get_hll_global $P3323, "GLOBAL"
    nqp_get_package_through_who $P3324, $P3323, "PAST"
    get_who $P3325, $P3324
    set $P3326, $P3325["Var"]
    $P3327 = $P3326."new"("register" :named("scope"), "exception" :named("name"))
    $P3328 = $P3322."new"($P3327, "handled", "keyed" :named("scope"))
.annotate 'line', 1125
    $P3329 = $P3318."new"($P3328, 1, "bind" :named("pasttype"))
.annotate 'line', 1124
    $P3330 = $P3314."new"($P3329)
.annotate 'line', 1123
    $P3331 = $P3310."new"($P3330, "CONTROL" :named("handle_types_except"))
.annotate 'line', 1121
    new $P3332, "ResizablePMCArray"
    push $P3332, $P3331
    $P3306."handlers"($P3332)
  unless_3303_end:
.annotate 'line', 1135
    find_lex $P3333, "$/"
    find_lex $P3334, "$past"
    unless_null $P3334, vivify_1862
    new $P3334, "Undef"
  vivify_1862:
    $P3335 = $P3333."!make"($P3334)
.annotate 'line', 1115
    .return ($P3335)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blorst"  :subid("461_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_3337
    .param pmc param_3338
.annotate 'line', 1138
    .lex "self", param_3337
    .lex "$/", param_3338
.annotate 'line', 1139
    find_lex $P3339, "$/"
.annotate 'line', 1140
    find_lex $P3342, "$/"
    unless_null $P3342, vivify_1863
    $P3342 = root_new ['parrot';'Hash']
  vivify_1863:
    set $P3343, $P3342["block"]
    unless_null $P3343, vivify_1864
    new $P3343, "Undef"
  vivify_1864:
    if $P3343, if_3341
.annotate 'line', 1141
    find_lex $P3348, "$/"
    unless_null $P3348, vivify_1865
    $P3348 = root_new ['parrot';'Hash']
  vivify_1865:
    set $P3349, $P3348["statement"]
    unless_null $P3349, vivify_1866
    new $P3349, "Undef"
  vivify_1866:
    $P3350 = $P3349."ast"()
    set $P3340, $P3350
.annotate 'line', 1140
    goto if_3341_end
  if_3341:
    find_lex $P3344, "$/"
    unless_null $P3344, vivify_1867
    $P3344 = root_new ['parrot';'Hash']
  vivify_1867:
    set $P3345, $P3344["block"]
    unless_null $P3345, vivify_1868
    new $P3345, "Undef"
  vivify_1868:
    $P3346 = $P3345."ast"()
    $P3347 = "block_immediate"($P3346)
    set $P3340, $P3347
  if_3341_end:
    $P3351 = $P3339."!make"($P3340)
.annotate 'line', 1138
    .return ($P3351)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<if>"  :subid("462_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_3353
    .param pmc param_3354
.annotate 'line', 1146
    .lex "self", param_3353
    .lex "$/", param_3354
    find_lex $P3355, "$/"
    find_lex $P3356, "$/"
    unless_null $P3356, vivify_1869
    $P3356 = root_new ['parrot';'Hash']
  vivify_1869:
    set $P3357, $P3356["cond"]
    unless_null $P3357, vivify_1870
    new $P3357, "Undef"
  vivify_1870:
    $P3358 = $P3357."ast"()
    $P3359 = $P3355."!make"($P3358)
    .return ($P3359)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<unless>"  :subid("463_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_3361
    .param pmc param_3362
.annotate 'line', 1147
    .lex "self", param_3361
    .lex "$/", param_3362
    find_lex $P3363, "$/"
    find_lex $P3364, "$/"
    unless_null $P3364, vivify_1871
    $P3364 = root_new ['parrot';'Hash']
  vivify_1871:
    set $P3365, $P3364["cond"]
    unless_null $P3365, vivify_1872
    new $P3365, "Undef"
  vivify_1872:
    $P3366 = $P3365."ast"()
    $P3367 = $P3363."!make"($P3366)
    .return ($P3367)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<while>"  :subid("464_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_3369
    .param pmc param_3370
.annotate 'line', 1149
    .lex "self", param_3369
    .lex "$/", param_3370
    find_lex $P3371, "$/"
    find_lex $P3372, "$/"
    unless_null $P3372, vivify_1873
    $P3372 = root_new ['parrot';'Hash']
  vivify_1873:
    set $P3373, $P3372["cond"]
    unless_null $P3373, vivify_1874
    new $P3373, "Undef"
  vivify_1874:
    $P3374 = $P3373."ast"()
    $P3375 = $P3371."!make"($P3374)
    .return ($P3375)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<until>"  :subid("465_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_3377
    .param pmc param_3378
.annotate 'line', 1150
    .lex "self", param_3377
    .lex "$/", param_3378
    find_lex $P3379, "$/"
    find_lex $P3380, "$/"
    unless_null $P3380, vivify_1875
    $P3380 = root_new ['parrot';'Hash']
  vivify_1875:
    set $P3381, $P3380["cond"]
    unless_null $P3381, vivify_1876
    new $P3381, "Undef"
  vivify_1876:
    $P3382 = $P3381."ast"()
    $P3383 = $P3379."!make"($P3382)
    .return ($P3383)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<fatarrow>"  :subid("466_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_3385
    .param pmc param_3386
.annotate 'line', 1154
    .lex "self", param_3385
    .lex "$/", param_3386
    find_lex $P3387, "$/"
    find_lex $P3388, "$/"
    unless_null $P3388, vivify_1877
    $P3388 = root_new ['parrot';'Hash']
  vivify_1877:
    set $P3389, $P3388["fatarrow"]
    unless_null $P3389, vivify_1878
    new $P3389, "Undef"
  vivify_1878:
    $P3390 = $P3389."ast"()
    $P3391 = $P3387."!make"($P3390)
    .return ($P3391)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<colonpair>"  :subid("467_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_3393
    .param pmc param_3394
.annotate 'line', 1155
    .lex "self", param_3393
    .lex "$/", param_3394
    find_lex $P3395, "$/"
    find_lex $P3396, "$/"
    unless_null $P3396, vivify_1879
    $P3396 = root_new ['parrot';'Hash']
  vivify_1879:
    set $P3397, $P3396["colonpair"]
    unless_null $P3397, vivify_1880
    new $P3397, "Undef"
  vivify_1880:
    $P3398 = $P3397."ast"()
    $P3399 = $P3395."!make"($P3398)
    .return ($P3399)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<variable>"  :subid("468_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_3401
    .param pmc param_3402
.annotate 'line', 1156
    .lex "self", param_3401
    .lex "$/", param_3402
    find_lex $P3403, "$/"
    find_lex $P3404, "$/"
    unless_null $P3404, vivify_1881
    $P3404 = root_new ['parrot';'Hash']
  vivify_1881:
    set $P3405, $P3404["variable"]
    unless_null $P3405, vivify_1882
    new $P3405, "Undef"
  vivify_1882:
    $P3406 = $P3405."ast"()
    $P3407 = $P3403."!make"($P3406)
    .return ($P3407)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<package_declarator>"  :subid("469_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_3409
    .param pmc param_3410
.annotate 'line', 1157
    .lex "self", param_3409
    .lex "$/", param_3410
    find_lex $P3411, "$/"
    find_lex $P3412, "$/"
    unless_null $P3412, vivify_1883
    $P3412 = root_new ['parrot';'Hash']
  vivify_1883:
    set $P3413, $P3412["package_declarator"]
    unless_null $P3413, vivify_1884
    new $P3413, "Undef"
  vivify_1884:
    $P3414 = $P3413."ast"()
    $P3415 = $P3411."!make"($P3414)
    .return ($P3415)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<scope_declarator>"  :subid("470_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_3417
    .param pmc param_3418
.annotate 'line', 1158
    .lex "self", param_3417
    .lex "$/", param_3418
    find_lex $P3419, "$/"
    find_lex $P3420, "$/"
    unless_null $P3420, vivify_1885
    $P3420 = root_new ['parrot';'Hash']
  vivify_1885:
    set $P3421, $P3420["scope_declarator"]
    unless_null $P3421, vivify_1886
    new $P3421, "Undef"
  vivify_1886:
    $P3422 = $P3421."ast"()
    $P3423 = $P3419."!make"($P3422)
    .return ($P3423)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<routine_declarator>"  :subid("471_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_3425
    .param pmc param_3426
.annotate 'line', 1159
    .lex "self", param_3425
    .lex "$/", param_3426
    find_lex $P3427, "$/"
    find_lex $P3428, "$/"
    unless_null $P3428, vivify_1887
    $P3428 = root_new ['parrot';'Hash']
  vivify_1887:
    set $P3429, $P3428["routine_declarator"]
    unless_null $P3429, vivify_1888
    new $P3429, "Undef"
  vivify_1888:
    $P3430 = $P3429."ast"()
    $P3431 = $P3427."!make"($P3430)
    .return ($P3431)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<regex_declarator>"  :subid("472_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_3433
    .param pmc param_3434
.annotate 'line', 1160
    .lex "self", param_3433
    .lex "$/", param_3434
    find_lex $P3435, "$/"
    find_lex $P3436, "$/"
    unless_null $P3436, vivify_1889
    $P3436 = root_new ['parrot';'Hash']
  vivify_1889:
    set $P3437, $P3436["regex_declarator"]
    unless_null $P3437, vivify_1890
    new $P3437, "Undef"
  vivify_1890:
    $P3438 = $P3437."ast"()
    $P3439 = $P3435."!make"($P3438)
    .return ($P3439)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<statement_prefix>"  :subid("473_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_3441
    .param pmc param_3442
.annotate 'line', 1161
    .lex "self", param_3441
    .lex "$/", param_3442
    find_lex $P3443, "$/"
    find_lex $P3444, "$/"
    unless_null $P3444, vivify_1891
    $P3444 = root_new ['parrot';'Hash']
  vivify_1891:
    set $P3445, $P3444["statement_prefix"]
    unless_null $P3445, vivify_1892
    new $P3445, "Undef"
  vivify_1892:
    $P3446 = $P3445."ast"()
    $P3447 = $P3443."!make"($P3446)
    .return ($P3447)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<lambda>"  :subid("474_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_3449
    .param pmc param_3450
.annotate 'line', 1162
    .lex "self", param_3449
    .lex "$/", param_3450
    find_lex $P3451, "$/"
    find_lex $P3452, "$/"
    unless_null $P3452, vivify_1893
    $P3452 = root_new ['parrot';'Hash']
  vivify_1893:
    set $P3453, $P3452["pblock"]
    unless_null $P3453, vivify_1894
    new $P3453, "Undef"
  vivify_1894:
    $P3454 = $P3453."ast"()
    $P3455 = $P3451."!make"($P3454)
    .return ($P3455)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "fatarrow"  :subid("475_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_3457
    .param pmc param_3458
.annotate 'line', 1164
    .lex "self", param_3457
    .lex "$/", param_3458
.annotate 'line', 1165
    new $P3459, "Undef"
    .lex "$past", $P3459
    find_lex $P3460, "$/"
    unless_null $P3460, vivify_1895
    $P3460 = root_new ['parrot';'Hash']
  vivify_1895:
    set $P3461, $P3460["val"]
    unless_null $P3461, vivify_1896
    new $P3461, "Undef"
  vivify_1896:
    $P3462 = $P3461."ast"()
    store_lex "$past", $P3462
.annotate 'line', 1166
    find_lex $P3463, "$past"
    unless_null $P3463, vivify_1897
    new $P3463, "Undef"
  vivify_1897:
    find_lex $P3464, "$/"
    unless_null $P3464, vivify_1898
    $P3464 = root_new ['parrot';'Hash']
  vivify_1898:
    set $P3465, $P3464["key"]
    unless_null $P3465, vivify_1899
    new $P3465, "Undef"
  vivify_1899:
    $P3466 = $P3465."Str"()
    $P3463."named"($P3466)
.annotate 'line', 1167
    find_lex $P3467, "$/"
    find_lex $P3468, "$past"
    unless_null $P3468, vivify_1900
    new $P3468, "Undef"
  vivify_1900:
    $P3469 = $P3467."!make"($P3468)
.annotate 'line', 1164
    .return ($P3469)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair"  :subid("476_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_3471
    .param pmc param_3472
.annotate 'line', 1170
    .lex "self", param_3471
    .lex "$/", param_3472
.annotate 'line', 1171
    new $P3473, "Undef"
    .lex "$past", $P3473
.annotate 'line', 1172
    find_lex $P3476, "$/"
    unless_null $P3476, vivify_1901
    $P3476 = root_new ['parrot';'Hash']
  vivify_1901:
    set $P3477, $P3476["circumfix"]
    unless_null $P3477, vivify_1902
    new $P3477, "Undef"
  vivify_1902:
    if $P3477, if_3475
.annotate 'line', 1173
    get_hll_global $P3482, "GLOBAL"
    nqp_get_package_through_who $P3483, $P3482, "PAST"
    get_who $P3484, $P3483
    set $P3485, $P3484["Val"]
    find_lex $P3486, "$/"
    unless_null $P3486, vivify_1903
    $P3486 = root_new ['parrot';'Hash']
  vivify_1903:
    set $P3487, $P3486["not"]
    unless_null $P3487, vivify_1904
    new $P3487, "Undef"
  vivify_1904:
    isfalse $I3488, $P3487
    $P3489 = $P3485."new"($I3488 :named("value"))
    set $P3474, $P3489
.annotate 'line', 1172
    goto if_3475_end
  if_3475:
    find_lex $P3478, "$/"
    unless_null $P3478, vivify_1905
    $P3478 = root_new ['parrot';'Hash']
  vivify_1905:
    set $P3479, $P3478["circumfix"]
    unless_null $P3479, vivify_1906
    $P3479 = root_new ['parrot';'ResizablePMCArray']
  vivify_1906:
    set $P3480, $P3479[0]
    unless_null $P3480, vivify_1907
    new $P3480, "Undef"
  vivify_1907:
    $P3481 = $P3480."ast"()
    set $P3474, $P3481
  if_3475_end:
    store_lex "$past", $P3474
.annotate 'line', 1174
    find_lex $P3490, "$past"
    unless_null $P3490, vivify_1908
    new $P3490, "Undef"
  vivify_1908:
    find_lex $P3491, "$/"
    unless_null $P3491, vivify_1909
    $P3491 = root_new ['parrot';'Hash']
  vivify_1909:
    set $P3492, $P3491["identifier"]
    unless_null $P3492, vivify_1910
    new $P3492, "Undef"
  vivify_1910:
    set $S3493, $P3492
    $P3490."named"($S3493)
.annotate 'line', 1175
    find_lex $P3494, "$/"
    find_lex $P3495, "$past"
    unless_null $P3495, vivify_1911
    new $P3495, "Undef"
  vivify_1911:
    $P3496 = $P3494."!make"($P3495)
.annotate 'line', 1170
    .return ($P3496)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "variable"  :subid("477_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_3498
    .param pmc param_3499
.annotate 'line', 1178
    .const 'Sub' $P3515 = "478_1304456155.152" 
    capture_lex $P3515
    .lex "self", param_3498
    .lex "$/", param_3499
.annotate 'line', 1179
    new $P3500, "Undef"
    .lex "$past", $P3500
.annotate 'line', 1178
    find_lex $P3501, "$past"
    unless_null $P3501, vivify_1912
    new $P3501, "Undef"
  vivify_1912:
.annotate 'line', 1180
    find_lex $P3503, "$/"
    unless_null $P3503, vivify_1913
    $P3503 = root_new ['parrot';'Hash']
  vivify_1913:
    set $P3504, $P3503["postcircumfix"]
    unless_null $P3504, vivify_1914
    new $P3504, "Undef"
  vivify_1914:
    if $P3504, if_3502
.annotate 'line', 1184
    .const 'Sub' $P3515 = "478_1304456155.152" 
    capture_lex $P3515
    $P3515()
    goto if_3502_end
  if_3502:
.annotate 'line', 1181
    find_lex $P3505, "$/"
    unless_null $P3505, vivify_1971
    $P3505 = root_new ['parrot';'Hash']
  vivify_1971:
    set $P3506, $P3505["postcircumfix"]
    unless_null $P3506, vivify_1972
    new $P3506, "Undef"
  vivify_1972:
    $P3507 = $P3506."ast"()
    store_lex "$past", $P3507
.annotate 'line', 1182
    find_lex $P3508, "$past"
    unless_null $P3508, vivify_1973
    new $P3508, "Undef"
  vivify_1973:
    get_hll_global $P3509, "GLOBAL"
    nqp_get_package_through_who $P3510, $P3509, "PAST"
    get_who $P3511, $P3510
    set $P3512, $P3511["Var"]
    $P3513 = $P3512."new"("$/" :named("name"))
    $P3508."unshift"($P3513)
  if_3502_end:
.annotate 'line', 1243
    find_lex $P3697, "$/"
    find_lex $P3698, "$past"
    unless_null $P3698, vivify_1974
    new $P3698, "Undef"
  vivify_1974:
    $P3699 = $P3697."!make"($P3698)
.annotate 'line', 1178
    .return ($P3699)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3514"  :anon :subid("478_1304456155.152") :outer("477_1304456155.152")
.annotate 'line', 1184
    .const 'Sub' $P3591 = "480_1304456155.152" 
    capture_lex $P3591
    .const 'Sub' $P3550 = "479_1304456155.152" 
    capture_lex $P3550
.annotate 'line', 1185
    $P3516 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P3516
    get_hll_global $P3517, "GLOBAL"
    nqp_get_package_through_who $P3518, $P3517, "NQP"
    get_who $P3519, $P3518
    set $P3520, $P3519["Compiler"]
    find_lex $P3521, "$/"
    unless_null $P3521, vivify_1915
    new $P3521, "Undef"
  vivify_1915:
    set $S3522, $P3521
    $P3523 = $P3520."parse_name"($S3522)
    store_lex "@name", $P3523
.annotate 'line', 1186
    find_lex $P3526, "@name"
    unless_null $P3526, vivify_1916
    $P3526 = root_new ['parrot';'ResizablePMCArray']
  vivify_1916:
    set $N3527, $P3526
    isgt $I3528, $N3527, 1.0
    if $I3528, if_3525
.annotate 'line', 1193
    find_lex $P3544, "$/"
    unless_null $P3544, vivify_1917
    $P3544 = root_new ['parrot';'Hash']
  vivify_1917:
    set $P3545, $P3544["twigil"]
    unless_null $P3545, vivify_1918
    $P3545 = root_new ['parrot';'ResizablePMCArray']
  vivify_1918:
    set $P3546, $P3545[0]
    unless_null $P3546, vivify_1919
    new $P3546, "Undef"
  vivify_1919:
    set $S3547, $P3546
    iseq $I3548, $S3547, "*"
    if $I3548, if_3543
.annotate 'line', 1204
    find_lex $P3585, "$/"
    unless_null $P3585, vivify_1920
    $P3585 = root_new ['parrot';'Hash']
  vivify_1920:
    set $P3586, $P3585["twigil"]
    unless_null $P3586, vivify_1921
    $P3586 = root_new ['parrot';'ResizablePMCArray']
  vivify_1921:
    set $P3587, $P3586[0]
    unless_null $P3587, vivify_1922
    new $P3587, "Undef"
  vivify_1922:
    set $S3588, $P3587
    iseq $I3589, $S3588, "!"
    if $I3589, if_3584
.annotate 'line', 1233
    find_lex $P3674, "@name"
    unless_null $P3674, vivify_1923
    $P3674 = root_new ['parrot';'ResizablePMCArray']
  vivify_1923:
    set $P3675, $P3674[0]
    unless_null $P3675, vivify_1924
    new $P3675, "Undef"
  vivify_1924:
    set $S3676, $P3675
    $P3677 = "is_package"($S3676)
    if $P3677, if_3673
.annotate 'line', 1238
    get_hll_global $P3686, "GLOBAL"
    nqp_get_package_through_who $P3687, $P3686, "PAST"
    get_who $P3688, $P3687
    set $P3689, $P3688["Var"]
.annotate 'line', 1239
    find_lex $P3690, "@name"
    unless_null $P3690, vivify_1925
    $P3690 = root_new ['parrot';'ResizablePMCArray']
  vivify_1925:
    $P3691 = $P3690."pop"()
    set $S3692, $P3691
    find_lex $P3693, "$/"
    unless_null $P3693, vivify_1926
    $P3693 = root_new ['parrot';'Hash']
  vivify_1926:
    set $P3694, $P3693["sigil"]
    unless_null $P3694, vivify_1927
    new $P3694, "Undef"
  vivify_1927:
    $P3695 = "vivitype"($P3694)
    $P3696 = $P3689."new"($S3692 :named("name"), $P3695 :named("viviself"))
.annotate 'line', 1238
    store_lex "$past", $P3696
.annotate 'line', 1237
    set $P3672, $P3696
.annotate 'line', 1233
    goto if_3673_end
  if_3673:
.annotate 'line', 1234
    find_lex $P3678, "@name"
    unless_null $P3678, vivify_1928
    $P3678 = root_new ['parrot';'ResizablePMCArray']
  vivify_1928:
    find_lex $P3679, "$/"
    unless_null $P3679, vivify_1929
    new $P3679, "Undef"
  vivify_1929:
    $P3680 = "lexical_package_lookup"($P3678, $P3679)
    store_lex "$past", $P3680
.annotate 'line', 1235
    find_lex $P3681, "$past"
    unless_null $P3681, vivify_1930
    new $P3681, "Undef"
  vivify_1930:
    find_lex $P3682, "$/"
    unless_null $P3682, vivify_1931
    $P3682 = root_new ['parrot';'Hash']
  vivify_1931:
    set $P3683, $P3682["sigil"]
    unless_null $P3683, vivify_1932
    new $P3683, "Undef"
  vivify_1932:
    $P3684 = "vivitype"($P3683)
    $P3685 = $P3681."viviself"($P3684)
.annotate 'line', 1233
    set $P3672, $P3685
  if_3673_end:
    set $P3583, $P3672
.annotate 'line', 1204
    goto if_3584_end
  if_3584:
    .const 'Sub' $P3591 = "480_1304456155.152" 
    capture_lex $P3591
    $P3671 = $P3591()
    set $P3583, $P3671
  if_3584_end:
    set $P3542, $P3583
.annotate 'line', 1193
    goto if_3543_end
  if_3543:
    .const 'Sub' $P3550 = "479_1304456155.152" 
    capture_lex $P3550
    $P3582 = $P3550()
    set $P3542, $P3582
  if_3543_end:
    set $P3524, $P3542
.annotate 'line', 1186
    goto if_3525_end
  if_3525:
.annotate 'line', 1187
    find_lex $P3530, "$/"
    unless_null $P3530, vivify_1963
    $P3530 = root_new ['parrot';'Hash']
  vivify_1963:
    set $P3531, $P3530["twigil"]
    unless_null $P3531, vivify_1964
    new $P3531, "Undef"
  vivify_1964:
    unless $P3531, if_3529_end
.annotate 'line', 1188
    find_lex $P3532, "$/"
    unless_null $P3532, vivify_1965
    new $P3532, "Undef"
  vivify_1965:
    $P3533 = $P3532."CURSOR"()
    $P3533."panic"("Twigil not allowed on multi-part name")
  if_3529_end:
.annotate 'line', 1190
    find_lex $P3534, "@name"
    unless_null $P3534, vivify_1966
    $P3534 = root_new ['parrot';'ResizablePMCArray']
  vivify_1966:
    find_lex $P3535, "$/"
    unless_null $P3535, vivify_1967
    new $P3535, "Undef"
  vivify_1967:
    $P3536 = "lexical_package_lookup"($P3534, $P3535)
    store_lex "$past", $P3536
.annotate 'line', 1191
    find_lex $P3537, "$past"
    unless_null $P3537, vivify_1968
    new $P3537, "Undef"
  vivify_1968:
    find_lex $P3538, "$/"
    unless_null $P3538, vivify_1969
    $P3538 = root_new ['parrot';'Hash']
  vivify_1969:
    set $P3539, $P3538["sigil"]
    unless_null $P3539, vivify_1970
    new $P3539, "Undef"
  vivify_1970:
    $P3540 = "vivitype"($P3539)
    $P3541 = $P3537."viviself"($P3540)
.annotate 'line', 1186
    set $P3524, $P3541
  if_3525_end:
.annotate 'line', 1184
    .return ($P3524)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3590"  :anon :subid("480_1304456155.152") :outer("478_1304456155.152")
.annotate 'line', 1204
    .const 'Sub' $P3622 = "481_1304456155.152" 
    capture_lex $P3622
.annotate 'line', 1206
    new $P3592, "Undef"
    .lex "$name", $P3592
    find_lex $P3593, "@name"
    unless_null $P3593, vivify_1933
    $P3593 = root_new ['parrot';'ResizablePMCArray']
  vivify_1933:
    $P3594 = $P3593."pop"()
    set $S3595, $P3594
    new $P3596, 'String'
    set $P3596, $S3595
    store_lex "$name", $P3596
.annotate 'line', 1207
    get_hll_global $P3597, "GLOBAL"
    nqp_get_package_through_who $P3598, $P3597, "PAST"
    get_who $P3599, $P3598
    set $P3600, $P3599["Var"]
    find_lex $P3601, "$name"
    unless_null $P3601, vivify_1934
    new $P3601, "Undef"
  vivify_1934:
.annotate 'line', 1209
    find_lex $P3602, "$/"
    unless_null $P3602, vivify_1935
    $P3602 = root_new ['parrot';'Hash']
  vivify_1935:
    set $P3603, $P3602["sigil"]
    unless_null $P3603, vivify_1936
    new $P3603, "Undef"
  vivify_1936:
    $P3604 = "vivitype"($P3603)
.annotate 'line', 1210
    get_hll_global $P3605, "GLOBAL"
    nqp_get_package_through_who $P3606, $P3605, "PAST"
    get_who $P3607, $P3606
    set $P3608, $P3607["Var"]
    $P3609 = $P3608."new"("self" :named("name"))
.annotate 'line', 1211
    get_hll_global $P3610, "GLOBAL"
    nqp_get_package_through_who $P3611, $P3610, "PAST"
    get_who $P3612, $P3611
    set $P3613, $P3612["Var"]
    $P3614 = $P3613."new"("$?CLASS" :named("name"))
    $P3615 = $P3600."new"($P3609, $P3614, $P3601 :named("name"), "attribute_6model" :named("scope"), $P3604 :named("viviself"))
.annotate 'line', 1207
    store_lex "$past", $P3615
.annotate 'line', 1215
    find_dynamic_lex $P3620, "$*IN_DECL"
    unless_null $P3620, vivify_1937
    get_hll_global $P3618, "GLOBAL"
    get_who $P3619, $P3618
    set $P3620, $P3619["$IN_DECL"]
    unless_null $P3620, vivify_1938
    die "Contextual $*IN_DECL not found"
  vivify_1938:
  vivify_1937:
    unless $P3620, unless_3617
    set $P3616, $P3620
    goto unless_3617_end
  unless_3617:
    .const 'Sub' $P3622 = "481_1304456155.152" 
    capture_lex $P3622
    $P3670 = $P3622()
    set $P3616, $P3670
  unless_3617_end:
.annotate 'line', 1204
    .return ($P3616)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3621"  :anon :subid("481_1304456155.152") :outer("480_1304456155.152")
.annotate 'line', 1215
    .const 'Sub' $P3637 = "482_1304456155.152" 
    capture_lex $P3637
.annotate 'line', 1216
    new $P3623, "Undef"
    .lex "$attr", $P3623
.annotate 'line', 1215
    find_lex $P3624, "$attr"
    unless_null $P3624, vivify_1939
    new $P3624, "Undef"
  vivify_1939:
.annotate 'line', 1217
    find_dynamic_lex $P3628, "$*PACKAGE"
    unless_null $P3628, vivify_1940
    get_hll_global $P3626, "GLOBAL"
    get_who $P3627, $P3626
    set $P3628, $P3627["$PACKAGE"]
    unless_null $P3628, vivify_1941
    die "Contextual $*PACKAGE not found"
  vivify_1941:
  vivify_1940:
    get_how $P3629, $P3628
    find_dynamic_lex $P3632, "$*PACKAGE"
    unless_null $P3632, vivify_1942
    get_hll_global $P3630, "GLOBAL"
    get_who $P3631, $P3630
    set $P3632, $P3631["$PACKAGE"]
    unless_null $P3632, vivify_1943
    die "Contextual $*PACKAGE not found"
  vivify_1943:
  vivify_1942:
    $P3633 = $P3629."attributes"($P3632, 1 :named("local"))
    defined $I3634, $P3633
    unless $I3634, for_undef_1944
    iter $P3625, $P3633
    new $P3649, 'ExceptionHandler'
    set_label $P3649, loop3648_handler
    $P3649."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3649
  loop3648_test:
    unless $P3625, loop3648_done
    shift $P3635, $P3625
  loop3648_redo:
    .const 'Sub' $P3637 = "482_1304456155.152" 
    capture_lex $P3637
    $P3637($P3635)
  loop3648_next:
    goto loop3648_test
  loop3648_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3650, exception, 'type'
    eq $P3650, .CONTROL_LOOP_NEXT, loop3648_next
    eq $P3650, .CONTROL_LOOP_REDO, loop3648_redo
  loop3648_done:
    pop_eh 
  for_undef_1944:
.annotate 'line', 1223
    find_lex $P3653, "$attr"
    unless_null $P3653, vivify_1948
    new $P3653, "Undef"
  vivify_1948:
    defined $I3654, $P3653
    if $I3654, if_3652
.annotate 'line', 1229
    find_lex $P3663, "$/"
    unless_null $P3663, vivify_1949
    new $P3663, "Undef"
  vivify_1949:
    $P3664 = $P3663."CURSOR"()
    new $P3665, 'String'
    set $P3665, "Attribute '"
    find_lex $P3666, "$name"
    unless_null $P3666, vivify_1950
    new $P3666, "Undef"
  vivify_1950:
    concat $P3667, $P3665, $P3666
    concat $P3668, $P3667, "' not declared"
    $P3669 = $P3664."panic"($P3668)
.annotate 'line', 1228
    set $P3651, $P3669
.annotate 'line', 1223
    goto if_3652_end
  if_3652:
.annotate 'line', 1224
    find_lex $P3657, "$attr"
    unless_null $P3657, vivify_1951
    new $P3657, "Undef"
  vivify_1951:
    can $I3658, $P3657, "type"
    if $I3658, if_3656
    new $P3655, 'Integer'
    set $P3655, $I3658
    goto if_3656_end
  if_3656:
.annotate 'line', 1225
    find_lex $P3659, "$past"
    unless_null $P3659, vivify_1952
    new $P3659, "Undef"
  vivify_1952:
    find_lex $P3660, "$attr"
    unless_null $P3660, vivify_1953
    new $P3660, "Undef"
  vivify_1953:
    $P3661 = $P3660."type"()
    $P3662 = $P3659."type"($P3661)
.annotate 'line', 1224
    set $P3655, $P3662
  if_3656_end:
.annotate 'line', 1223
    set $P3651, $P3655
  if_3652_end:
.annotate 'line', 1215
    .return ($P3651)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3636"  :anon :subid("482_1304456155.152") :outer("481_1304456155.152")
    .param pmc param_3638
.annotate 'line', 1217
    .lex "$_", param_3638
.annotate 'line', 1218
    find_lex $P3641, "$_"
    unless_null $P3641, vivify_1945
    new $P3641, "Undef"
  vivify_1945:
    $S3642 = $P3641."name"()
    find_lex $P3643, "$name"
    unless_null $P3643, vivify_1946
    new $P3643, "Undef"
  vivify_1946:
    set $S3644, $P3643
    iseq $I3645, $S3642, $S3644
    if $I3645, if_3640
    new $P3639, 'Integer'
    set $P3639, $I3645
    goto if_3640_end
  if_3640:
.annotate 'line', 1219
    find_lex $P3646, "$_"
    unless_null $P3646, vivify_1947
    new $P3646, "Undef"
  vivify_1947:
    store_lex "$attr", $P3646
.annotate 'line', 1220
    set $I3647, .CONTROL_LOOP_LAST
    die 0, $I3647
  if_3640_end:
.annotate 'line', 1217
    .return ($P3639)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3549"  :anon :subid("479_1304456155.152") :outer("478_1304456155.152")
.annotate 'line', 1194
    new $P3551, "Undef"
    .lex "$global_fallback", $P3551
    find_lex $P3552, "$/"
    unless_null $P3552, vivify_1954
    $P3552 = root_new ['parrot';'Hash']
  vivify_1954:
    set $P3553, $P3552["sigil"]
    unless_null $P3553, vivify_1955
    new $P3553, "Undef"
  vivify_1955:
    set $S3554, $P3553
    new $P3555, 'String'
    set $P3555, $S3554
    find_lex $P3556, "$/"
    unless_null $P3556, vivify_1956
    $P3556 = root_new ['parrot';'Hash']
  vivify_1956:
    set $P3557, $P3556["desigilname"]
    unless_null $P3557, vivify_1957
    new $P3557, "Undef"
  vivify_1957:
    concat $P3558, $P3555, $P3557
    new $P3559, "ResizablePMCArray"
    push $P3559, "GLOBAL"
    push $P3559, $P3558
    find_lex $P3560, "$/"
    unless_null $P3560, vivify_1958
    new $P3560, "Undef"
  vivify_1958:
    $P3561 = "lexical_package_lookup"($P3559, $P3560)
    store_lex "$global_fallback", $P3561
.annotate 'line', 1195
    find_lex $P3562, "$global_fallback"
    unless_null $P3562, vivify_1959
    new $P3562, "Undef"
  vivify_1959:
    get_hll_global $P3563, "GLOBAL"
    nqp_get_package_through_who $P3564, $P3563, "PAST"
    get_who $P3565, $P3564
    set $P3566, $P3565["Op"]
.annotate 'line', 1196
    new $P3567, "String"
    assign $P3567, "Contextual "
    find_lex $P3568, "$/"
    unless_null $P3568, vivify_1960
    new $P3568, "Undef"
  vivify_1960:
    set $S3569, $P3568
    concat $P3570, $P3567, $S3569
    concat $P3571, $P3570, " not found"
    $P3572 = $P3566."new"($P3571, "die" :named("pirop"))
.annotate 'line', 1195
    $P3562."viviself"($P3572)
.annotate 'line', 1199
    get_hll_global $P3573, "GLOBAL"
    nqp_get_package_through_who $P3574, $P3573, "PAST"
    get_who $P3575, $P3574
    set $P3576, $P3575["Var"]
.annotate 'line', 1200
    find_lex $P3577, "@name"
    unless_null $P3577, vivify_1961
    $P3577 = root_new ['parrot';'ResizablePMCArray']
  vivify_1961:
    $P3578 = $P3577."pop"()
    set $S3579, $P3578
    find_lex $P3580, "$global_fallback"
    unless_null $P3580, vivify_1962
    new $P3580, "Undef"
  vivify_1962:
    $P3581 = $P3576."new"($S3579 :named("name"), "contextual" :named("scope"), $P3580 :named("viviself"))
.annotate 'line', 1199
    store_lex "$past", $P3581
.annotate 'line', 1193
    .return ($P3581)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<module>"  :subid("483_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_3701
    .param pmc param_3702
.annotate 'line', 1246
    .lex "self", param_3701
    .lex "$/", param_3702
    find_lex $P3703, "$/"
    find_lex $P3704, "$/"
    unless_null $P3704, vivify_1975
    $P3704 = root_new ['parrot';'Hash']
  vivify_1975:
    set $P3705, $P3704["package_def"]
    unless_null $P3705, vivify_1976
    new $P3705, "Undef"
  vivify_1976:
    $P3706 = $P3705."ast"()
    $P3707 = $P3703."!make"($P3706)
    .return ($P3707)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<knowhow>"  :subid("484_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_3709
    .param pmc param_3710
.annotate 'line', 1247
    .lex "self", param_3709
    .lex "$/", param_3710
    find_lex $P3711, "$/"
    find_lex $P3712, "$/"
    unless_null $P3712, vivify_1977
    $P3712 = root_new ['parrot';'Hash']
  vivify_1977:
    set $P3713, $P3712["package_def"]
    unless_null $P3713, vivify_1978
    new $P3713, "Undef"
  vivify_1978:
    $P3714 = $P3713."ast"()
    $P3715 = $P3711."!make"($P3714)
    .return ($P3715)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<class>"  :subid("485_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_3717
    .param pmc param_3718
.annotate 'line', 1248
    .lex "self", param_3717
    .lex "$/", param_3718
    find_lex $P3719, "$/"
    find_lex $P3720, "$/"
    unless_null $P3720, vivify_1979
    $P3720 = root_new ['parrot';'Hash']
  vivify_1979:
    set $P3721, $P3720["package_def"]
    unless_null $P3721, vivify_1980
    new $P3721, "Undef"
  vivify_1980:
    $P3722 = $P3721."ast"()
    $P3723 = $P3719."!make"($P3722)
    .return ($P3723)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<grammar>"  :subid("486_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_3725
    .param pmc param_3726
.annotate 'line', 1249
    .lex "self", param_3725
    .lex "$/", param_3726
    find_lex $P3727, "$/"
    find_lex $P3728, "$/"
    unless_null $P3728, vivify_1981
    $P3728 = root_new ['parrot';'Hash']
  vivify_1981:
    set $P3729, $P3728["package_def"]
    unless_null $P3729, vivify_1982
    new $P3729, "Undef"
  vivify_1982:
    $P3730 = $P3729."ast"()
    $P3731 = $P3727."!make"($P3730)
    .return ($P3731)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<role>"  :subid("487_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_3733
    .param pmc param_3734
.annotate 'line', 1250
    .lex "self", param_3733
    .lex "$/", param_3734
    find_lex $P3735, "$/"
    find_lex $P3736, "$/"
    unless_null $P3736, vivify_1983
    $P3736 = root_new ['parrot';'Hash']
  vivify_1983:
    set $P3737, $P3736["package_def"]
    unless_null $P3737, vivify_1984
    new $P3737, "Undef"
  vivify_1984:
    $P3738 = $P3737."ast"()
    $P3739 = $P3735."!make"($P3738)
    .return ($P3739)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<native>"  :subid("488_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_3741
    .param pmc param_3742
.annotate 'line', 1251
    .lex "self", param_3741
    .lex "$/", param_3742
    find_lex $P3743, "$/"
    find_lex $P3744, "$/"
    unless_null $P3744, vivify_1985
    $P3744 = root_new ['parrot';'Hash']
  vivify_1985:
    set $P3745, $P3744["package_def"]
    unless_null $P3745, vivify_1986
    new $P3745, "Undef"
  vivify_1986:
    $P3746 = $P3745."ast"()
    $P3747 = $P3743."!make"($P3746)
    .return ($P3747)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "package_def"  :subid("489_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_3749
    .param pmc param_3750
.annotate 'line', 1253
    .const 'Sub' $P3930 = "493_1304456155.152" 
    capture_lex $P3930
    .const 'Sub' $P3900 = "492_1304456155.152" 
    capture_lex $P3900
    .const 'Sub' $P3853 = "490_1304456155.152" 
    capture_lex $P3853
    .lex "self", param_3749
    .lex "$/", param_3750
.annotate 'line', 1255
    $P3751 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P3751
.annotate 'line', 1256
    new $P3752, "Undef"
    .lex "$name", $P3752
.annotate 'line', 1257
    new $P3753, "Undef"
    .lex "$how", $P3753
.annotate 'line', 1260
    new $P3754, "Undef"
    .lex "$past", $P3754
.annotate 'line', 1255
    find_lex $P3755, "$/"
    unless_null $P3755, vivify_1987
    $P3755 = root_new ['parrot';'Hash']
  vivify_1987:
    set $P3756, $P3755["name"]
    unless_null $P3756, vivify_1988
    $P3756 = root_new ['parrot';'Hash']
  vivify_1988:
    set $P3757, $P3756["identifier"]
    unless_null $P3757, vivify_1989
    new $P3757, "Undef"
  vivify_1989:
    clone $P3758, $P3757
    store_lex "@ns", $P3758
.annotate 'line', 1256
    find_lex $P3759, "@ns"
    unless_null $P3759, vivify_1990
    $P3759 = root_new ['parrot';'ResizablePMCArray']
  vivify_1990:
    $P3760 = $P3759."pop"()
    set $S3761, $P3760
    new $P3762, 'String'
    set $P3762, $S3761
    store_lex "$name", $P3762
.annotate 'line', 1257
    find_dynamic_lex $P3765, "$*PKGDECL"
    unless_null $P3765, vivify_1991
    get_hll_global $P3763, "GLOBAL"
    get_who $P3764, $P3763
    set $P3765, $P3764["$PKGDECL"]
    unless_null $P3765, vivify_1992
    die "Contextual $*PKGDECL not found"
  vivify_1992:
  vivify_1991:
    find_dynamic_lex $P3768, "%*HOW"
    unless_null $P3768, vivify_1993
    get_hll_global $P3766, "GLOBAL"
    get_who $P3767, $P3766
    set $P3768, $P3767["%HOW"]
    unless_null $P3768, vivify_1994
    die "Contextual %*HOW not found"
  vivify_1994:
  vivify_1993:
    set $P3769, $P3768[$P3765]
    unless_null $P3769, vivify_1995
    new $P3769, "Undef"
  vivify_1995:
    store_lex "$how", $P3769
.annotate 'line', 1260
    find_lex $P3772, "$/"
    unless_null $P3772, vivify_1996
    $P3772 = root_new ['parrot';'Hash']
  vivify_1996:
    set $P3773, $P3772["block"]
    unless_null $P3773, vivify_1997
    new $P3773, "Undef"
  vivify_1997:
    if $P3773, if_3771
    find_lex $P3777, "$/"
    unless_null $P3777, vivify_1998
    $P3777 = root_new ['parrot';'Hash']
  vivify_1998:
    set $P3778, $P3777["comp_unit"]
    unless_null $P3778, vivify_1999
    new $P3778, "Undef"
  vivify_1999:
    $P3779 = $P3778."ast"()
    set $P3770, $P3779
    goto if_3771_end
  if_3771:
    find_lex $P3774, "$/"
    unless_null $P3774, vivify_2000
    $P3774 = root_new ['parrot';'Hash']
  vivify_2000:
    set $P3775, $P3774["block"]
    unless_null $P3775, vivify_2001
    new $P3775, "Undef"
  vivify_2001:
    $P3776 = $P3775."ast"()
    set $P3770, $P3776
  if_3771_end:
    store_lex "$past", $P3770
.annotate 'line', 1261
    find_dynamic_lex $P3785, "$*SCOPE"
    unless_null $P3785, vivify_2002
    get_hll_global $P3783, "GLOBAL"
    get_who $P3784, $P3783
    set $P3785, $P3784["$SCOPE"]
    unless_null $P3785, vivify_2003
    die "Contextual $*SCOPE not found"
  vivify_2003:
  vivify_2002:
    set $S3786, $P3785
    iseq $I3787, $S3786, "our"
    unless $I3787, unless_3782
    new $P3781, 'Integer'
    set $P3781, $I3787
    goto unless_3782_end
  unless_3782:
    find_dynamic_lex $P3790, "$*SCOPE"
    unless_null $P3790, vivify_2004
    get_hll_global $P3788, "GLOBAL"
    get_who $P3789, $P3788
    set $P3790, $P3789["$SCOPE"]
    unless_null $P3790, vivify_2005
    die "Contextual $*SCOPE not found"
  vivify_2005:
  vivify_2004:
    set $S3791, $P3790
    iseq $I3792, $S3791, ""
    new $P3781, 'Integer'
    set $P3781, $I3792
  unless_3782_end:
    unless $P3781, if_3780_end
.annotate 'line', 1262
    find_lex $P3793, "$past"
    unless_null $P3793, vivify_2006
    new $P3793, "Undef"
  vivify_2006:
    find_lex $P3794, "$/"
    unless_null $P3794, vivify_2007
    $P3794 = root_new ['parrot';'Hash']
  vivify_2007:
    set $P3795, $P3794["name"]
    unless_null $P3795, vivify_2008
    $P3795 = root_new ['parrot';'Hash']
  vivify_2008:
    set $P3796, $P3795["identifier"]
    unless_null $P3796, vivify_2009
    new $P3796, "Undef"
  vivify_2009:
    $P3793."namespace"($P3796)
  if_3780_end:
.annotate 'line', 1269
    find_lex $P3800, "$how"
    unless_null $P3800, vivify_2010
    new $P3800, "Undef"
  vivify_2010:
    can $I3801, $P3800, "parametric"
    if $I3801, if_3799
    new $P3798, 'Integer'
    set $P3798, $I3801
    goto if_3799_end
  if_3799:
    find_lex $P3802, "$how"
    unless_null $P3802, vivify_2011
    new $P3802, "Undef"
  vivify_2011:
    find_lex $P3803, "$how"
    unless_null $P3803, vivify_2012
    new $P3803, "Undef"
  vivify_2012:
    $P3804 = $P3802."parametric"($P3803)
    set $P3798, $P3804
  if_3799_end:
    if $P3798, if_3797
.annotate 'line', 1278
    find_lex $P3834, "$past"
    unless_null $P3834, vivify_2013
    new $P3834, "Undef"
  vivify_2013:
    $P3834."blocktype"("immediate")
.annotate 'line', 1279
    find_dynamic_lex $P3837, "$*SC"
    unless_null $P3837, vivify_2014
    get_hll_global $P3835, "GLOBAL"
    get_who $P3836, $P3835
    set $P3837, $P3836["$SC"]
    unless_null $P3837, vivify_2015
    die "Contextual $*SC not found"
  vivify_2015:
  vivify_2014:
    find_lex $P3838, "$past"
    unless_null $P3838, vivify_2016
    new $P3838, "Undef"
  vivify_2016:
    find_dynamic_lex $P3841, "$*PACKAGE"
    unless_null $P3841, vivify_2017
    get_hll_global $P3839, "GLOBAL"
    get_who $P3840, $P3839
    set $P3841, $P3840["$PACKAGE"]
    unless_null $P3841, vivify_2018
    die "Contextual $*PACKAGE not found"
  vivify_2018:
  vivify_2017:
    $P3837."install_lexical_symbol"($P3838, "$?PACKAGE", $P3841)
.annotate 'line', 1280
    find_dynamic_lex $P3844, "$*SC"
    unless_null $P3844, vivify_2019
    get_hll_global $P3842, "GLOBAL"
    get_who $P3843, $P3842
    set $P3844, $P3843["$SC"]
    unless_null $P3844, vivify_2020
    die "Contextual $*SC not found"
  vivify_2020:
  vivify_2019:
    find_lex $P3845, "$past"
    unless_null $P3845, vivify_2021
    new $P3845, "Undef"
  vivify_2021:
    find_dynamic_lex $P3848, "$*PACKAGE"
    unless_null $P3848, vivify_2022
    get_hll_global $P3846, "GLOBAL"
    get_who $P3847, $P3846
    set $P3848, $P3847["$PACKAGE"]
    unless_null $P3848, vivify_2023
    die "Contextual $*PACKAGE not found"
  vivify_2023:
  vivify_2022:
    $P3844."install_lexical_symbol"($P3845, "$?CLASS", $P3848)
.annotate 'line', 1277
    goto if_3797_end
  if_3797:
.annotate 'line', 1270
    find_lex $P3805, "$past"
    unless_null $P3805, vivify_2024
    new $P3805, "Undef"
  vivify_2024:
    $P3805."blocktype"("declaration")
.annotate 'line', 1271
    find_lex $P3806, "$past"
    unless_null $P3806, vivify_2025
    new $P3806, "Undef"
  vivify_2025:
    get_hll_global $P3807, "GLOBAL"
    nqp_get_package_through_who $P3808, $P3807, "PAST"
    get_who $P3809, $P3808
    set $P3810, $P3809["Var"]
    $P3811 = $P3810."new"("$?CLASS" :named("name"), "parameter" :named("scope"))
    $P3806."unshift"($P3811)
.annotate 'line', 1272
    find_lex $P3812, "$past"
    unless_null $P3812, vivify_2026
    new $P3812, "Undef"
  vivify_2026:
    $P3812."symbol"("$?CLASS", "lexical" :named("scope"))
.annotate 'line', 1273
    find_dynamic_lex $P3815, "$*SC"
    unless_null $P3815, vivify_2027
    get_hll_global $P3813, "GLOBAL"
    get_who $P3814, $P3813
    set $P3815, $P3814["$SC"]
    unless_null $P3815, vivify_2028
    die "Contextual $*SC not found"
  vivify_2028:
  vivify_2027:
    find_dynamic_lex $P3818, "$*PACKAGE"
    unless_null $P3818, vivify_2029
    get_hll_global $P3816, "GLOBAL"
    get_who $P3817, $P3816
    set $P3818, $P3817["$PACKAGE"]
    unless_null $P3818, vivify_2030
    die "Contextual $*PACKAGE not found"
  vivify_2030:
  vivify_2029:
    find_lex $P3819, "$past"
    unless_null $P3819, vivify_2031
    new $P3819, "Undef"
  vivify_2031:
    $P3815."pkg_set_body_block"($P3818, $P3819)
.annotate 'line', 1274
    find_dynamic_lex $P3822, "$*SC"
    unless_null $P3822, vivify_2032
    get_hll_global $P3820, "GLOBAL"
    get_who $P3821, $P3820
    set $P3822, $P3821["$SC"]
    unless_null $P3822, vivify_2033
    die "Contextual $*SC not found"
  vivify_2033:
  vivify_2032:
    find_lex $P3823, "$past"
    unless_null $P3823, vivify_2034
    new $P3823, "Undef"
  vivify_2034:
    find_dynamic_lex $P3826, "$*PACKAGE"
    unless_null $P3826, vivify_2035
    get_hll_global $P3824, "GLOBAL"
    get_who $P3825, $P3824
    set $P3826, $P3825["$PACKAGE"]
    unless_null $P3826, vivify_2036
    die "Contextual $*PACKAGE not found"
  vivify_2036:
  vivify_2035:
    $P3822."install_lexical_symbol"($P3823, "$?PACKAGE", $P3826)
.annotate 'line', 1275
    find_dynamic_lex $P3829, "$*SC"
    unless_null $P3829, vivify_2037
    get_hll_global $P3827, "GLOBAL"
    get_who $P3828, $P3827
    set $P3829, $P3828["$SC"]
    unless_null $P3829, vivify_2038
    die "Contextual $*SC not found"
  vivify_2038:
  vivify_2037:
    find_lex $P3830, "$past"
    unless_null $P3830, vivify_2039
    new $P3830, "Undef"
  vivify_2039:
    find_dynamic_lex $P3833, "$*PACKAGE"
    unless_null $P3833, vivify_2040
    get_hll_global $P3831, "GLOBAL"
    get_who $P3832, $P3831
    set $P3833, $P3832["$PACKAGE"]
    unless_null $P3833, vivify_2041
    die "Contextual $*PACKAGE not found"
  vivify_2041:
  vivify_2040:
    $P3829."install_lexical_symbol"($P3830, "$?ROLE", $P3833)
  if_3797_end:
.annotate 'line', 1284
    find_lex $P3850, "$/"
    unless_null $P3850, vivify_2042
    $P3850 = root_new ['parrot';'Hash']
  vivify_2042:
    set $P3851, $P3850["parent"]
    unless_null $P3851, vivify_2043
    new $P3851, "Undef"
  vivify_2043:
    if $P3851, if_3849
.annotate 'line', 1298
    find_lex $P3897, "$how"
    unless_null $P3897, vivify_2044
    new $P3897, "Undef"
  vivify_2044:
    can $I3898, $P3897, "set_default_parent"
    unless $I3898, if_3896_end
    .const 'Sub' $P3900 = "492_1304456155.152" 
    capture_lex $P3900
    $P3900()
  if_3896_end:
    goto if_3849_end
  if_3849:
.annotate 'line', 1284
    .const 'Sub' $P3853 = "490_1304456155.152" 
    capture_lex $P3853
    $P3853()
  if_3849_end:
.annotate 'line', 1305
    find_lex $P3922, "$/"
    unless_null $P3922, vivify_2070
    $P3922 = root_new ['parrot';'Hash']
  vivify_2070:
    set $P3923, $P3922["role"]
    unless_null $P3923, vivify_2071
    new $P3923, "Undef"
  vivify_2071:
    unless $P3923, if_3921_end
.annotate 'line', 1306
    find_lex $P3925, "$/"
    unless_null $P3925, vivify_2072
    $P3925 = root_new ['parrot';'Hash']
  vivify_2072:
    set $P3926, $P3925["role"]
    unless_null $P3926, vivify_2073
    new $P3926, "Undef"
  vivify_2073:
    defined $I3927, $P3926
    unless $I3927, for_undef_2074
    iter $P3924, $P3926
    new $P3971, 'ExceptionHandler'
    set_label $P3971, loop3970_handler
    $P3971."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3971
  loop3970_test:
    unless $P3924, loop3970_done
    shift $P3928, $P3924
  loop3970_redo:
    .const 'Sub' $P3930 = "493_1304456155.152" 
    capture_lex $P3930
    $P3930($P3928)
  loop3970_next:
    goto loop3970_test
  loop3970_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3972, exception, 'type'
    eq $P3972, .CONTROL_LOOP_NEXT, loop3970_next
    eq $P3972, .CONTROL_LOOP_REDO, loop3970_redo
  loop3970_done:
    pop_eh 
  for_undef_2074:
  if_3921_end:
.annotate 'line', 1323
    find_dynamic_lex $P3975, "$*SC"
    unless_null $P3975, vivify_2088
    get_hll_global $P3973, "GLOBAL"
    get_who $P3974, $P3973
    set $P3975, $P3974["$SC"]
    unless_null $P3975, vivify_2089
    die "Contextual $*SC not found"
  vivify_2089:
  vivify_2088:
    find_dynamic_lex $P3978, "$*PACKAGE"
    unless_null $P3978, vivify_2090
    get_hll_global $P3976, "GLOBAL"
    get_who $P3977, $P3976
    set $P3978, $P3977["$PACKAGE"]
    unless_null $P3978, vivify_2091
    die "Contextual $*PACKAGE not found"
  vivify_2091:
  vivify_2090:
    $P3975."pkg_compose"($P3978)
.annotate 'line', 1325
    find_lex $P3979, "$/"
    find_lex $P3980, "$past"
    unless_null $P3980, vivify_2092
    new $P3980, "Undef"
  vivify_2092:
    $P3981 = $P3979."!make"($P3980)
.annotate 'line', 1253
    .return ($P3981)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3899"  :anon :subid("492_1304456155.152") :outer("489_1304456155.152")
.annotate 'line', 1299
    new $P3901, "Undef"
    .lex "$default", $P3901
    find_dynamic_lex $P3906, "$*PKGDECL"
    unless_null $P3906, vivify_2045
    get_hll_global $P3904, "GLOBAL"
    get_who $P3905, $P3904
    set $P3906, $P3905["$PKGDECL"]
    unless_null $P3906, vivify_2046
    die "Contextual $*PKGDECL not found"
  vivify_2046:
  vivify_2045:
    set $S3907, $P3906
    iseq $I3908, $S3907, "grammar"
    if $I3908, if_3903
    new $P3910, "ResizablePMCArray"
    push $P3910, "NQPMu"
    set $P3902, $P3910
    goto if_3903_end
  if_3903:
    new $P3909, "ResizablePMCArray"
    push $P3909, "Regex"
    push $P3909, "Cursor"
    set $P3902, $P3909
  if_3903_end:
    store_lex "$default", $P3902
.annotate 'line', 1300
    find_dynamic_lex $P3913, "$*SC"
    unless_null $P3913, vivify_2047
    get_hll_global $P3911, "GLOBAL"
    get_who $P3912, $P3911
    set $P3913, $P3912["$SC"]
    unless_null $P3913, vivify_2048
    die "Contextual $*SC not found"
  vivify_2048:
  vivify_2047:
    find_dynamic_lex $P3916, "$*PACKAGE"
    unless_null $P3916, vivify_2049
    get_hll_global $P3914, "GLOBAL"
    get_who $P3915, $P3914
    set $P3916, $P3915["$PACKAGE"]
    unless_null $P3916, vivify_2050
    die "Contextual $*PACKAGE not found"
  vivify_2050:
  vivify_2049:
.annotate 'line', 1301
    find_lex $P3917, "$default"
    unless_null $P3917, vivify_2051
    new $P3917, "Undef"
  vivify_2051:
    find_lex $P3918, "$/"
    unless_null $P3918, vivify_2052
    new $P3918, "Undef"
  vivify_2052:
    $P3919 = "find_sym"($P3917, $P3918)
    $P3920 = $P3913."pkg_add_parent_or_role"($P3916, "set_default_parent", $P3919)
.annotate 'line', 1298
    .return ($P3920)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3852"  :anon :subid("490_1304456155.152") :outer("489_1304456155.152")
.annotate 'line', 1284
    .const 'Sub' $P3859 = "491_1304456155.152" 
    capture_lex $P3859
.annotate 'line', 1285
    new $P3854, "Undef"
    .lex "$parent", $P3854
.annotate 'line', 1286
    new $P3855, "Undef"
    .lex "$parent_found", $P3855
.annotate 'line', 1284
    find_lex $P3856, "$parent"
    unless_null $P3856, vivify_2053
    new $P3856, "Undef"
  vivify_2053:
    find_lex $P3857, "$parent_found"
    unless_null $P3857, vivify_2054
    new $P3857, "Undef"
  vivify_2054:
.annotate 'line', 1287
    .const 'Sub' $P3859 = "491_1304456155.152" 
    capture_lex $P3859
    $P3859()
.annotate 'line', 1291
    find_lex $P3877, "$parent_found"
    unless_null $P3877, vivify_2060
    new $P3877, "Undef"
  vivify_2060:
    if $P3877, if_3876
.annotate 'line', 1295
    find_lex $P3886, "$/"
    unless_null $P3886, vivify_2061
    new $P3886, "Undef"
  vivify_2061:
    $P3887 = $P3886."CURSOR"()
    new $P3888, "String"
    assign $P3888, "Could not find parent class '"
    find_lex $P3889, "$/"
    unless_null $P3889, vivify_2062
    $P3889 = root_new ['parrot';'Hash']
  vivify_2062:
    set $P3890, $P3889["parent"]
    unless_null $P3890, vivify_2063
    $P3890 = root_new ['parrot';'ResizablePMCArray']
  vivify_2063:
    set $P3891, $P3890[0]
    unless_null $P3891, vivify_2064
    new $P3891, "Undef"
  vivify_2064:
    set $S3892, $P3891
    concat $P3893, $P3888, $S3892
    concat $P3894, $P3893, "'"
    $P3895 = $P3887."panic"($P3894)
.annotate 'line', 1294
    set $P3875, $P3895
.annotate 'line', 1291
    goto if_3876_end
  if_3876:
.annotate 'line', 1292
    find_dynamic_lex $P3880, "$*SC"
    unless_null $P3880, vivify_2065
    get_hll_global $P3878, "GLOBAL"
    get_who $P3879, $P3878
    set $P3880, $P3879["$SC"]
    unless_null $P3880, vivify_2066
    die "Contextual $*SC not found"
  vivify_2066:
  vivify_2065:
    find_dynamic_lex $P3883, "$*PACKAGE"
    unless_null $P3883, vivify_2067
    get_hll_global $P3881, "GLOBAL"
    get_who $P3882, $P3881
    set $P3883, $P3882["$PACKAGE"]
    unless_null $P3883, vivify_2068
    die "Contextual $*PACKAGE not found"
  vivify_2068:
  vivify_2067:
    find_lex $P3884, "$parent"
    unless_null $P3884, vivify_2069
    new $P3884, "Undef"
  vivify_2069:
    $P3885 = $P3880."pkg_add_parent_or_role"($P3883, "add_parent", $P3884)
.annotate 'line', 1291
    set $P3875, $P3885
  if_3876_end:
.annotate 'line', 1284
    .return ($P3875)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3858"  :anon :subid("491_1304456155.152") :outer("490_1304456155.152")
.annotate 'line', 1287
    new $P3870, 'ExceptionHandler'
    set_label $P3870, control_3869
    $P3870."handle_types_except"(.CONTROL_RETURN,  .CONTROL_OK,  .CONTROL_BREAK,  .CONTROL_CONTINUE,  .CONTROL_TAKE,  .CONTROL_LEAVE,  .CONTROL_EXIT,  .CONTROL_LOOP_NEXT,  .CONTROL_LOOP_LAST,  .CONTROL_LOOP_REDO)
    push_eh $P3870
.annotate 'line', 1288
    find_lex $P3860, "$/"
    unless_null $P3860, vivify_2055
    $P3860 = root_new ['parrot';'Hash']
  vivify_2055:
    set $P3861, $P3860["parent"]
    unless_null $P3861, vivify_2056
    $P3861 = root_new ['parrot';'ResizablePMCArray']
  vivify_2056:
    set $P3862, $P3861[0]
    unless_null $P3862, vivify_2057
    $P3862 = root_new ['parrot';'Hash']
  vivify_2057:
    set $P3863, $P3862["identifier"]
    unless_null $P3863, vivify_2058
    new $P3863, "Undef"
  vivify_2058:
    clone $P3864, $P3863
    find_lex $P3865, "$/"
    unless_null $P3865, vivify_2059
    new $P3865, "Undef"
  vivify_2059:
    $P3866 = "find_sym"($P3864, $P3865)
    store_lex "$parent", $P3866
.annotate 'line', 1289
    new $P3867, "Integer"
    assign $P3867, 1
    store_lex "$parent_found", $P3867
.annotate 'line', 1287
    pop_eh 
    goto skip_handler_3868
  control_3869:
    .local pmc exception 
    .get_results (exception) 
    new $P3873, 'Integer'
    set $P3873, 1
    set exception["handled"], $P3873
    set $I3874, exception["handled"]
    ne $I3874, 1, nothandled_3872
  handled_3871:
    .return (exception)
  nothandled_3872:
    rethrow exception
  skip_handler_3868:
    .return ($P3867)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3929"  :anon :subid("493_1304456155.152") :outer("489_1304456155.152")
    .param pmc param_3933
.annotate 'line', 1306
    .const 'Sub' $P3937 = "494_1304456155.152" 
    capture_lex $P3937
.annotate 'line', 1307
    new $P3931, "Undef"
    .lex "$role", $P3931
.annotate 'line', 1308
    new $P3932, "Undef"
    .lex "$role_found", $P3932
    .lex "$_", param_3933
.annotate 'line', 1306
    find_lex $P3934, "$role"
    unless_null $P3934, vivify_2075
    new $P3934, "Undef"
  vivify_2075:
    find_lex $P3935, "$role_found"
    unless_null $P3935, vivify_2076
    new $P3935, "Undef"
  vivify_2076:
.annotate 'line', 1309
    .const 'Sub' $P3937 = "494_1304456155.152" 
    capture_lex $P3937
    $P3937()
.annotate 'line', 1313
    find_lex $P3953, "$role_found"
    unless_null $P3953, vivify_2080
    new $P3953, "Undef"
  vivify_2080:
    if $P3953, if_3952
.annotate 'line', 1317
    find_lex $P3962, "$/"
    unless_null $P3962, vivify_2081
    new $P3962, "Undef"
  vivify_2081:
    $P3963 = $P3962."CURSOR"()
    new $P3964, "String"
    assign $P3964, "Could not find role '"
    find_lex $P3965, "$_"
    unless_null $P3965, vivify_2082
    new $P3965, "Undef"
  vivify_2082:
    set $S3966, $P3965
    concat $P3967, $P3964, $S3966
    concat $P3968, $P3967, "'"
    $P3969 = $P3963."panic"($P3968)
.annotate 'line', 1316
    set $P3951, $P3969
.annotate 'line', 1313
    goto if_3952_end
  if_3952:
.annotate 'line', 1314
    find_dynamic_lex $P3956, "$*SC"
    unless_null $P3956, vivify_2083
    get_hll_global $P3954, "GLOBAL"
    get_who $P3955, $P3954
    set $P3956, $P3955["$SC"]
    unless_null $P3956, vivify_2084
    die "Contextual $*SC not found"
  vivify_2084:
  vivify_2083:
    find_dynamic_lex $P3959, "$*PACKAGE"
    unless_null $P3959, vivify_2085
    get_hll_global $P3957, "GLOBAL"
    get_who $P3958, $P3957
    set $P3959, $P3958["$PACKAGE"]
    unless_null $P3959, vivify_2086
    die "Contextual $*PACKAGE not found"
  vivify_2086:
  vivify_2085:
    find_lex $P3960, "$role"
    unless_null $P3960, vivify_2087
    new $P3960, "Undef"
  vivify_2087:
    $P3961 = $P3956."pkg_add_parent_or_role"($P3959, "add_role", $P3960)
.annotate 'line', 1313
    set $P3951, $P3961
  if_3952_end:
.annotate 'line', 1306
    .return ($P3951)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3936"  :anon :subid("494_1304456155.152") :outer("493_1304456155.152")
.annotate 'line', 1309
    new $P3946, 'ExceptionHandler'
    set_label $P3946, control_3945
    $P3946."handle_types_except"(.CONTROL_RETURN,  .CONTROL_OK,  .CONTROL_BREAK,  .CONTROL_CONTINUE,  .CONTROL_TAKE,  .CONTROL_LEAVE,  .CONTROL_EXIT,  .CONTROL_LOOP_NEXT,  .CONTROL_LOOP_LAST,  .CONTROL_LOOP_REDO)
    push_eh $P3946
.annotate 'line', 1310
    find_lex $P3938, "$_"
    unless_null $P3938, vivify_2077
    $P3938 = root_new ['parrot';'Hash']
  vivify_2077:
    set $P3939, $P3938["identifier"]
    unless_null $P3939, vivify_2078
    new $P3939, "Undef"
  vivify_2078:
    clone $P3940, $P3939
    find_lex $P3941, "$/"
    unless_null $P3941, vivify_2079
    new $P3941, "Undef"
  vivify_2079:
    $P3942 = "find_sym"($P3940, $P3941)
    store_lex "$role", $P3942
.annotate 'line', 1311
    new $P3943, "Integer"
    assign $P3943, 1
    store_lex "$role_found", $P3943
.annotate 'line', 1309
    pop_eh 
    goto skip_handler_3944
  control_3945:
    .local pmc exception 
    .get_results (exception) 
    new $P3949, 'Integer'
    set $P3949, 1
    set exception["handled"], $P3949
    set $I3950, exception["handled"]
    ne $I3950, 1, nothandled_3948
  handled_3947:
    .return (exception)
  nothandled_3948:
    rethrow exception
  skip_handler_3944:
    .return ($P3943)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<my>"  :subid("495_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_3983
    .param pmc param_3984
.annotate 'line', 1328
    .lex "self", param_3983
    .lex "$/", param_3984
    find_lex $P3985, "$/"
    find_lex $P3986, "$/"
    unless_null $P3986, vivify_2093
    $P3986 = root_new ['parrot';'Hash']
  vivify_2093:
    set $P3987, $P3986["scoped"]
    unless_null $P3987, vivify_2094
    new $P3987, "Undef"
  vivify_2094:
    $P3988 = $P3987."ast"()
    $P3989 = $P3985."!make"($P3988)
    .return ($P3989)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<our>"  :subid("496_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_3991
    .param pmc param_3992
.annotate 'line', 1329
    .lex "self", param_3991
    .lex "$/", param_3992
    find_lex $P3993, "$/"
    find_lex $P3994, "$/"
    unless_null $P3994, vivify_2095
    $P3994 = root_new ['parrot';'Hash']
  vivify_2095:
    set $P3995, $P3994["scoped"]
    unless_null $P3995, vivify_2096
    new $P3995, "Undef"
  vivify_2096:
    $P3996 = $P3995."ast"()
    $P3997 = $P3993."!make"($P3996)
    .return ($P3997)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<has>"  :subid("497_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_3999
    .param pmc param_4000
.annotate 'line', 1330
    .lex "self", param_3999
    .lex "$/", param_4000
    find_lex $P4001, "$/"
    find_lex $P4002, "$/"
    unless_null $P4002, vivify_2097
    $P4002 = root_new ['parrot';'Hash']
  vivify_2097:
    set $P4003, $P4002["scoped"]
    unless_null $P4003, vivify_2098
    new $P4003, "Undef"
  vivify_2098:
    $P4004 = $P4003."ast"()
    $P4005 = $P4001."!make"($P4004)
    .return ($P4005)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scoped"  :subid("498_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_4007
    .param pmc param_4008
.annotate 'line', 1332
    .lex "self", param_4007
    .lex "$/", param_4008
.annotate 'line', 1333
    find_lex $P4009, "$/"
    find_lex $P4012, "$/"
    unless_null $P4012, vivify_2099
    $P4012 = root_new ['parrot';'Hash']
  vivify_2099:
    set $P4013, $P4012["declarator"]
    unless_null $P4013, vivify_2100
    new $P4013, "Undef"
  vivify_2100:
    if $P4013, if_4011
.annotate 'line', 1334
    find_lex $P4019, "$/"
    unless_null $P4019, vivify_2101
    $P4019 = root_new ['parrot';'Hash']
  vivify_2101:
    set $P4020, $P4019["multi_declarator"]
    unless_null $P4020, vivify_2102
    new $P4020, "Undef"
  vivify_2102:
    if $P4020, if_4018
.annotate 'line', 1335
    find_lex $P4024, "$/"
    unless_null $P4024, vivify_2103
    $P4024 = root_new ['parrot';'Hash']
  vivify_2103:
    set $P4025, $P4024["package_declarator"]
    unless_null $P4025, vivify_2104
    new $P4025, "Undef"
  vivify_2104:
    $P4026 = $P4025."ast"()
    set $P4017, $P4026
.annotate 'line', 1334
    goto if_4018_end
  if_4018:
    find_lex $P4021, "$/"
    unless_null $P4021, vivify_2105
    $P4021 = root_new ['parrot';'Hash']
  vivify_2105:
    set $P4022, $P4021["multi_declarator"]
    unless_null $P4022, vivify_2106
    new $P4022, "Undef"
  vivify_2106:
    $P4023 = $P4022."ast"()
    set $P4017, $P4023
  if_4018_end:
    set $P4010, $P4017
.annotate 'line', 1333
    goto if_4011_end
  if_4011:
    find_lex $P4014, "$/"
    unless_null $P4014, vivify_2107
    $P4014 = root_new ['parrot';'Hash']
  vivify_2107:
    set $P4015, $P4014["declarator"]
    unless_null $P4015, vivify_2108
    new $P4015, "Undef"
  vivify_2108:
    $P4016 = $P4015."ast"()
    set $P4010, $P4016
  if_4011_end:
    $P4027 = $P4009."!make"($P4010)
.annotate 'line', 1332
    .return ($P4027)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "declarator"  :subid("499_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_4029
    .param pmc param_4030
.annotate 'line', 1338
    .lex "self", param_4029
    .lex "$/", param_4030
.annotate 'line', 1339
    find_lex $P4031, "$/"
.annotate 'line', 1340
    find_lex $P4034, "$/"
    unless_null $P4034, vivify_2109
    $P4034 = root_new ['parrot';'Hash']
  vivify_2109:
    set $P4035, $P4034["routine_declarator"]
    unless_null $P4035, vivify_2110
    new $P4035, "Undef"
  vivify_2110:
    if $P4035, if_4033
.annotate 'line', 1341
    find_lex $P4039, "$/"
    unless_null $P4039, vivify_2111
    $P4039 = root_new ['parrot';'Hash']
  vivify_2111:
    set $P4040, $P4039["variable_declarator"]
    unless_null $P4040, vivify_2112
    new $P4040, "Undef"
  vivify_2112:
    $P4041 = $P4040."ast"()
    set $P4032, $P4041
.annotate 'line', 1340
    goto if_4033_end
  if_4033:
    find_lex $P4036, "$/"
    unless_null $P4036, vivify_2113
    $P4036 = root_new ['parrot';'Hash']
  vivify_2113:
    set $P4037, $P4036["routine_declarator"]
    unless_null $P4037, vivify_2114
    new $P4037, "Undef"
  vivify_2114:
    $P4038 = $P4037."ast"()
    set $P4032, $P4038
  if_4033_end:
    $P4042 = $P4031."!make"($P4032)
.annotate 'line', 1338
    .return ($P4042)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<multi>"  :subid("500_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_4044
    .param pmc param_4045
.annotate 'line', 1344
    .lex "self", param_4044
    .lex "$/", param_4045
    find_lex $P4046, "$/"
    find_lex $P4049, "$/"
    unless_null $P4049, vivify_2115
    $P4049 = root_new ['parrot';'Hash']
  vivify_2115:
    set $P4050, $P4049["declarator"]
    unless_null $P4050, vivify_2116
    new $P4050, "Undef"
  vivify_2116:
    if $P4050, if_4048
    find_lex $P4054, "$/"
    unless_null $P4054, vivify_2117
    $P4054 = root_new ['parrot';'Hash']
  vivify_2117:
    set $P4055, $P4054["routine_def"]
    unless_null $P4055, vivify_2118
    new $P4055, "Undef"
  vivify_2118:
    $P4056 = $P4055."ast"()
    set $P4047, $P4056
    goto if_4048_end
  if_4048:
    find_lex $P4051, "$/"
    unless_null $P4051, vivify_2119
    $P4051 = root_new ['parrot';'Hash']
  vivify_2119:
    set $P4052, $P4051["declarator"]
    unless_null $P4052, vivify_2120
    new $P4052, "Undef"
  vivify_2120:
    $P4053 = $P4052."ast"()
    set $P4047, $P4053
  if_4048_end:
    $P4057 = $P4046."!make"($P4047)
    .return ($P4057)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<proto>"  :subid("501_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_4059
    .param pmc param_4060
.annotate 'line', 1345
    .lex "self", param_4059
    .lex "$/", param_4060
    find_lex $P4061, "$/"
    find_lex $P4064, "$/"
    unless_null $P4064, vivify_2121
    $P4064 = root_new ['parrot';'Hash']
  vivify_2121:
    set $P4065, $P4064["declarator"]
    unless_null $P4065, vivify_2122
    new $P4065, "Undef"
  vivify_2122:
    if $P4065, if_4063
    find_lex $P4069, "$/"
    unless_null $P4069, vivify_2123
    $P4069 = root_new ['parrot';'Hash']
  vivify_2123:
    set $P4070, $P4069["routine_def"]
    unless_null $P4070, vivify_2124
    new $P4070, "Undef"
  vivify_2124:
    $P4071 = $P4070."ast"()
    set $P4062, $P4071
    goto if_4063_end
  if_4063:
    find_lex $P4066, "$/"
    unless_null $P4066, vivify_2125
    $P4066 = root_new ['parrot';'Hash']
  vivify_2125:
    set $P4067, $P4066["declarator"]
    unless_null $P4067, vivify_2126
    new $P4067, "Undef"
  vivify_2126:
    $P4068 = $P4067."ast"()
    set $P4062, $P4068
  if_4063_end:
    $P4072 = $P4061."!make"($P4062)
    .return ($P4072)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<null>"  :subid("502_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_4074
    .param pmc param_4075
.annotate 'line', 1346
    .lex "self", param_4074
    .lex "$/", param_4075
    find_lex $P4076, "$/"
    find_lex $P4077, "$/"
    unless_null $P4077, vivify_2127
    $P4077 = root_new ['parrot';'Hash']
  vivify_2127:
    set $P4078, $P4077["declarator"]
    unless_null $P4078, vivify_2128
    new $P4078, "Undef"
  vivify_2128:
    $P4079 = $P4078."ast"()
    $P4080 = $P4076."!make"($P4079)
    .return ($P4080)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "variable_declarator"  :subid("503_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_4082
    .param pmc param_4083
.annotate 'line', 1349
    .const 'Sub' $P4117 = "504_1304456155.152" 
    capture_lex $P4117
    .lex "self", param_4082
    .lex "$/", param_4083
.annotate 'line', 1350
    new $P4084, "Undef"
    .lex "$past", $P4084
.annotate 'line', 1351
    new $P4085, "Undef"
    .lex "$sigil", $P4085
.annotate 'line', 1352
    new $P4086, "Undef"
    .lex "$name", $P4086
.annotate 'line', 1353
    new $P4087, "Undef"
    .lex "$BLOCK", $P4087
.annotate 'line', 1350
    find_lex $P4088, "$/"
    unless_null $P4088, vivify_2129
    $P4088 = root_new ['parrot';'Hash']
  vivify_2129:
    set $P4089, $P4088["variable"]
    unless_null $P4089, vivify_2130
    new $P4089, "Undef"
  vivify_2130:
    $P4090 = $P4089."ast"()
    store_lex "$past", $P4090
.annotate 'line', 1351
    find_lex $P4091, "$/"
    unless_null $P4091, vivify_2131
    $P4091 = root_new ['parrot';'Hash']
  vivify_2131:
    set $P4092, $P4091["variable"]
    unless_null $P4092, vivify_2132
    $P4092 = root_new ['parrot';'Hash']
  vivify_2132:
    set $P4093, $P4092["sigil"]
    unless_null $P4093, vivify_2133
    new $P4093, "Undef"
  vivify_2133:
    store_lex "$sigil", $P4093
.annotate 'line', 1352
    find_lex $P4094, "$past"
    unless_null $P4094, vivify_2134
    new $P4094, "Undef"
  vivify_2134:
    $P4095 = $P4094."name"()
    store_lex "$name", $P4095
.annotate 'line', 1353
    find_lex $P4096, "$?PACKAGE"
    get_who $P4097, $P4096
    set $P4098, $P4097["@BLOCK"]
    unless_null $P4098, vivify_2135
    $P4098 = root_new ['parrot';'ResizablePMCArray']
  vivify_2135:
    set $P4099, $P4098[0]
    unless_null $P4099, vivify_2136
    new $P4099, "Undef"
  vivify_2136:
    store_lex "$BLOCK", $P4099
.annotate 'line', 1354
    find_lex $P4103, "$name"
    unless_null $P4103, vivify_2137
    new $P4103, "Undef"
  vivify_2137:
    if $P4103, if_4102
    set $P4101, $P4103
    goto if_4102_end
  if_4102:
    find_lex $P4104, "$BLOCK"
    unless_null $P4104, vivify_2138
    new $P4104, "Undef"
  vivify_2138:
    find_lex $P4105, "$name"
    unless_null $P4105, vivify_2139
    new $P4105, "Undef"
  vivify_2139:
    $P4106 = $P4104."symbol"($P4105)
    set $P4101, $P4106
  if_4102_end:
    unless $P4101, if_4100_end
.annotate 'line', 1355
    find_lex $P4107, "$/"
    unless_null $P4107, vivify_2140
    new $P4107, "Undef"
  vivify_2140:
    $P4108 = $P4107."CURSOR"()
    find_lex $P4109, "$name"
    unless_null $P4109, vivify_2141
    new $P4109, "Undef"
  vivify_2141:
    $P4108."panic"("Redeclaration of symbol ", $P4109)
  if_4100_end:
.annotate 'line', 1357
    find_dynamic_lex $P4113, "$*SCOPE"
    unless_null $P4113, vivify_2142
    get_hll_global $P4111, "GLOBAL"
    get_who $P4112, $P4111
    set $P4113, $P4112["$SCOPE"]
    unless_null $P4113, vivify_2143
    die "Contextual $*SCOPE not found"
  vivify_2143:
  vivify_2142:
    set $S4114, $P4113
    iseq $I4115, $S4114, "has"
    if $I4115, if_4110
.annotate 'line', 1377
    find_dynamic_lex $P4174, "$*SCOPE"
    unless_null $P4174, vivify_2144
    get_hll_global $P4172, "GLOBAL"
    get_who $P4173, $P4172
    set $P4174, $P4173["$SCOPE"]
    unless_null $P4174, vivify_2145
    die "Contextual $*SCOPE not found"
  vivify_2145:
  vivify_2144:
    set $S4175, $P4174
    iseq $I4176, $S4175, "our"
    if $I4176, if_4171
.annotate 'line', 1387
    find_lex $P4190, "$BLOCK"
    unless_null $P4190, vivify_2146
    $P4190 = root_new ['parrot';'ResizablePMCArray']
  vivify_2146:
    set $P4191, $P4190[0]
    unless_null $P4191, vivify_2147
    new $P4191, "Undef"
  vivify_2147:
    get_hll_global $P4192, "GLOBAL"
    nqp_get_package_through_who $P4193, $P4192, "PAST"
    get_who $P4194, $P4193
    set $P4195, $P4194["Var"]
    find_lex $P4196, "$name"
    unless_null $P4196, vivify_2148
    new $P4196, "Undef"
  vivify_2148:
.annotate 'line', 1389
    find_lex $P4197, "$sigil"
    unless_null $P4197, vivify_2149
    new $P4197, "Undef"
  vivify_2149:
    $P4198 = "vivitype"($P4197)
    find_lex $P4199, "$/"
    unless_null $P4199, vivify_2150
    new $P4199, "Undef"
  vivify_2150:
    $P4200 = $P4195."new"($P4196 :named("name"), "lexical" :named("scope"), 1 :named("isdecl"), 1 :named("lvalue"), $P4198 :named("viviself"), $P4199 :named("node"))
.annotate 'line', 1387
    $P4191."push"($P4200)
.annotate 'line', 1392
    find_lex $P4201, "$BLOCK"
    unless_null $P4201, vivify_2151
    new $P4201, "Undef"
  vivify_2151:
    find_lex $P4202, "$name"
    unless_null $P4202, vivify_2152
    new $P4202, "Undef"
  vivify_2152:
    $P4201."symbol"($P4202, "lexical" :named("scope"))
.annotate 'line', 1386
    goto if_4171_end
  if_4171:
.annotate 'line', 1381
    find_lex $P4177, "$/"
    unless_null $P4177, vivify_2153
    $P4177 = root_new ['parrot';'Hash']
  vivify_2153:
    set $P4178, $P4177["variable"]
    unless_null $P4178, vivify_2154
    new $P4178, "Undef"
  vivify_2154:
    set $S4179, $P4178
    new $P4180, 'String'
    set $P4180, $S4179
    store_lex "$name", $P4180
.annotate 'line', 1382
    find_lex $P4181, "$name"
    unless_null $P4181, vivify_2155
    new $P4181, "Undef"
  vivify_2155:
    new $P4182, "ResizablePMCArray"
    push $P4182, $P4181
    find_lex $P4183, "$/"
    unless_null $P4183, vivify_2156
    new $P4183, "Undef"
  vivify_2156:
    $P4184 = "lexical_package_lookup"($P4182, $P4183)
    store_lex "$past", $P4184
.annotate 'line', 1383
    find_lex $P4185, "$past"
    unless_null $P4185, vivify_2157
    new $P4185, "Undef"
  vivify_2157:
    find_lex $P4186, "$sigil"
    unless_null $P4186, vivify_2158
    new $P4186, "Undef"
  vivify_2158:
    $P4187 = "vivitype"($P4186)
    $P4185."viviself"($P4187)
.annotate 'line', 1384
    find_lex $P4188, "$BLOCK"
    unless_null $P4188, vivify_2159
    new $P4188, "Undef"
  vivify_2159:
    find_lex $P4189, "$name"
    unless_null $P4189, vivify_2160
    new $P4189, "Undef"
  vivify_2160:
    $P4188."symbol"($P4189, "package" :named("scope"))
  if_4171_end:
.annotate 'line', 1377
    goto if_4110_end
  if_4110:
.annotate 'line', 1357
    .const 'Sub' $P4117 = "504_1304456155.152" 
    capture_lex $P4117
    $P4117()
  if_4110_end:
.annotate 'line', 1394
    find_lex $P4203, "$/"
    find_lex $P4204, "$past"
    unless_null $P4204, vivify_2190
    new $P4204, "Undef"
  vivify_2190:
    $P4205 = $P4203."!make"($P4204)
.annotate 'line', 1349
    .return ($P4205)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4116"  :anon :subid("504_1304456155.152") :outer("503_1304456155.152")
.annotate 'line', 1364
    $P4118 = root_new ['parrot';'Hash']
    .lex "%lit_args", $P4118
.annotate 'line', 1365
    $P4119 = root_new ['parrot';'Hash']
    .lex "%obj_args", $P4119
.annotate 'line', 1359
    find_dynamic_lex $P4126, "$*PKGDECL"
    unless_null $P4126, vivify_2161
    get_hll_global $P4124, "GLOBAL"
    get_who $P4125, $P4124
    set $P4126, $P4125["$PKGDECL"]
    unless_null $P4126, vivify_2162
    die "Contextual $*PKGDECL not found"
  vivify_2162:
  vivify_2161:
    concat $P4127, $P4126, "-attr"
    find_dynamic_lex $P4123, "%*HOW"
    unless_null $P4123, vivify_2163
    get_hll_global $P4121, "GLOBAL"
    get_who $P4122, $P4121
    set $P4123, $P4122["%HOW"]
    unless_null $P4123, vivify_2164
    die "Contextual %*HOW not found"
  vivify_2164:
  vivify_2163:
    exists $I4128, $P4123[$P4127]
    if $I4128, unless_4120_end
.annotate 'line', 1360
    find_lex $P4129, "$/"
    unless_null $P4129, vivify_2165
    new $P4129, "Undef"
  vivify_2165:
    $P4130 = $P4129."CURSOR"()
    find_dynamic_lex $P4133, "$*PKGDECL"
    unless_null $P4133, vivify_2166
    get_hll_global $P4131, "GLOBAL"
    get_who $P4132, $P4131
    set $P4133, $P4132["$PKGDECL"]
    unless_null $P4133, vivify_2167
    die "Contextual $*PKGDECL not found"
  vivify_2167:
  vivify_2166:
    concat $P4134, $P4133, " packages do not support attributes"
    $P4130."panic"($P4134)
  unless_4120_end:
.annotate 'line', 1359
    find_lex $P4135, "%lit_args"
    unless_null $P4135, vivify_2168
    $P4135 = root_new ['parrot';'Hash']
  vivify_2168:
    find_lex $P4136, "%obj_args"
    unless_null $P4136, vivify_2169
    $P4136 = root_new ['parrot';'Hash']
  vivify_2169:
.annotate 'line', 1366
    find_lex $P4137, "$name"
    unless_null $P4137, vivify_2170
    new $P4137, "Undef"
  vivify_2170:
    find_lex $P4138, "%lit_args"
    unless_null $P4138, vivify_2171
    $P4138 = root_new ['parrot';'Hash']
    store_lex "%lit_args", $P4138
  vivify_2171:
    set $P4138["name"], $P4137
.annotate 'line', 1367
    find_lex $P4140, "$/"
    unless_null $P4140, vivify_2172
    $P4140 = root_new ['parrot';'Hash']
  vivify_2172:
    set $P4141, $P4140["typename"]
    unless_null $P4141, vivify_2173
    new $P4141, "Undef"
  vivify_2173:
    unless $P4141, if_4139_end
.annotate 'line', 1368
    find_lex $P4142, "$/"
    unless_null $P4142, vivify_2174
    $P4142 = root_new ['parrot';'Hash']
  vivify_2174:
    set $P4143, $P4142["typename"]
    unless_null $P4143, vivify_2175
    $P4143 = root_new ['parrot';'ResizablePMCArray']
  vivify_2175:
    set $P4144, $P4143[0]
    unless_null $P4144, vivify_2176
    new $P4144, "Undef"
  vivify_2176:
    set $S4145, $P4144
    new $P4146, "ResizablePMCArray"
    push $P4146, $S4145
    find_lex $P4147, "$/"
    unless_null $P4147, vivify_2177
    new $P4147, "Undef"
  vivify_2177:
    $P4148 = "find_sym"($P4146, $P4147)
    find_lex $P4149, "%obj_args"
    unless_null $P4149, vivify_2178
    $P4149 = root_new ['parrot';'Hash']
    store_lex "%obj_args", $P4149
  vivify_2178:
    set $P4149["type"], $P4148
  if_4139_end:
.annotate 'line', 1372
    find_dynamic_lex $P4152, "$*SC"
    unless_null $P4152, vivify_2179
    get_hll_global $P4150, "GLOBAL"
    get_who $P4151, $P4150
    set $P4152, $P4151["$SC"]
    unless_null $P4152, vivify_2180
    die "Contextual $*SC not found"
  vivify_2180:
  vivify_2179:
    find_dynamic_lex $P4155, "$*PACKAGE"
    unless_null $P4155, vivify_2181
    get_hll_global $P4153, "GLOBAL"
    get_who $P4154, $P4153
    set $P4155, $P4154["$PACKAGE"]
    unless_null $P4155, vivify_2182
    die "Contextual $*PACKAGE not found"
  vivify_2182:
  vivify_2181:
    find_dynamic_lex $P4158, "$*PKGDECL"
    unless_null $P4158, vivify_2183
    get_hll_global $P4156, "GLOBAL"
    get_who $P4157, $P4156
    set $P4158, $P4157["$PKGDECL"]
    unless_null $P4158, vivify_2184
    die "Contextual $*PKGDECL not found"
  vivify_2184:
  vivify_2183:
    concat $P4159, $P4158, "-attr"
    find_dynamic_lex $P4162, "%*HOW"
    unless_null $P4162, vivify_2185
    get_hll_global $P4160, "GLOBAL"
    get_who $P4161, $P4160
    set $P4162, $P4161["%HOW"]
    unless_null $P4162, vivify_2186
    die "Contextual %*HOW not found"
  vivify_2186:
  vivify_2185:
    set $P4163, $P4162[$P4159]
    unless_null $P4163, vivify_2187
    new $P4163, "Undef"
  vivify_2187:
    find_lex $P4164, "%lit_args"
    unless_null $P4164, vivify_2188
    $P4164 = root_new ['parrot';'Hash']
  vivify_2188:
    find_lex $P4165, "%obj_args"
    unless_null $P4165, vivify_2189
    $P4165 = root_new ['parrot';'Hash']
  vivify_2189:
    $P4152."pkg_add_attribute"($P4155, $P4163, $P4164, $P4165)
.annotate 'line', 1375
    get_hll_global $P4166, "GLOBAL"
    nqp_get_package_through_who $P4167, $P4166, "PAST"
    get_who $P4168, $P4167
    set $P4169, $P4168["Stmts"]
    $P4170 = $P4169."new"()
    store_lex "$past", $P4170
.annotate 'line', 1357
    .return ($P4170)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<sub>"  :subid("505_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_4207
    .param pmc param_4208
.annotate 'line', 1397
    .lex "self", param_4207
    .lex "$/", param_4208
    find_lex $P4209, "$/"
    find_lex $P4210, "$/"
    unless_null $P4210, vivify_2191
    $P4210 = root_new ['parrot';'Hash']
  vivify_2191:
    set $P4211, $P4210["routine_def"]
    unless_null $P4211, vivify_2192
    new $P4211, "Undef"
  vivify_2192:
    $P4212 = $P4211."ast"()
    $P4213 = $P4209."!make"($P4212)
    .return ($P4213)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<method>"  :subid("506_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_4215
    .param pmc param_4216
.annotate 'line', 1398
    .lex "self", param_4215
    .lex "$/", param_4216
    find_lex $P4217, "$/"
    find_lex $P4218, "$/"
    unless_null $P4218, vivify_2193
    $P4218 = root_new ['parrot';'Hash']
  vivify_2193:
    set $P4219, $P4218["method_def"]
    unless_null $P4219, vivify_2194
    new $P4219, "Undef"
  vivify_2194:
    $P4220 = $P4219."ast"()
    $P4221 = $P4217."!make"($P4220)
    .return ($P4221)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "routine_def"  :subid("507_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_4223
    .param pmc param_4224
.annotate 'line', 1400
    .const 'Sub' $P4537 = "513_1304456155.152" 
    capture_lex $P4537
    .const 'Sub' $P4246 = "508_1304456155.152" 
    capture_lex $P4246
    .lex "self", param_4223
    .lex "$/", param_4224
.annotate 'line', 1403
    new $P4225, "Undef"
    .lex "$past", $P4225
.annotate 'line', 1414
    new $P4226, "Undef"
    .lex "$block", $P4226
.annotate 'line', 1400
    find_lex $P4227, "$past"
    unless_null $P4227, vivify_2195
    new $P4227, "Undef"
  vivify_2195:
.annotate 'line', 1404
    find_lex $P4229, "$/"
    unless_null $P4229, vivify_2196
    $P4229 = root_new ['parrot';'Hash']
  vivify_2196:
    set $P4230, $P4229["onlystar"]
    unless_null $P4230, vivify_2197
    new $P4230, "Undef"
  vivify_2197:
    if $P4230, if_4228
.annotate 'line', 1408
    find_lex $P4232, "$/"
    unless_null $P4232, vivify_2198
    $P4232 = root_new ['parrot';'Hash']
  vivify_2198:
    set $P4233, $P4232["blockoid"]
    unless_null $P4233, vivify_2199
    new $P4233, "Undef"
  vivify_2199:
    $P4234 = $P4233."ast"()
    store_lex "$past", $P4234
.annotate 'line', 1409
    find_lex $P4235, "$past"
    unless_null $P4235, vivify_2200
    new $P4235, "Undef"
  vivify_2200:
    $P4235."blocktype"("declaration")
.annotate 'line', 1410
    find_dynamic_lex $P4239, "$*RETURN_USED"
    unless_null $P4239, vivify_2201
    get_hll_global $P4237, "GLOBAL"
    get_who $P4238, $P4237
    set $P4239, $P4238["$RETURN_USED"]
    unless_null $P4239, vivify_2202
    die "Contextual $*RETURN_USED not found"
  vivify_2202:
  vivify_2201:
    unless $P4239, if_4236_end
.annotate 'line', 1411
    find_lex $P4240, "$past"
    unless_null $P4240, vivify_2203
    new $P4240, "Undef"
  vivify_2203:
    $P4240."control"("return_pir")
  if_4236_end:
.annotate 'line', 1407
    goto if_4228_end
  if_4228:
.annotate 'line', 1405
    $P4231 = "only_star_block"()
    store_lex "$past", $P4231
  if_4228_end:
.annotate 'line', 1414
    find_lex $P4241, "$past"
    unless_null $P4241, vivify_2204
    new $P4241, "Undef"
  vivify_2204:
    store_lex "$block", $P4241
.annotate 'line', 1416
    find_lex $P4243, "$/"
    unless_null $P4243, vivify_2205
    $P4243 = root_new ['parrot';'Hash']
  vivify_2205:
    set $P4244, $P4243["deflongname"]
    unless_null $P4244, vivify_2206
    new $P4244, "Undef"
  vivify_2206:
    unless $P4244, if_4242_end
    .const 'Sub' $P4246 = "508_1304456155.152" 
    capture_lex $P4246
    $P4246()
  if_4242_end:
.annotate 'line', 1517
    find_lex $P4526, "$block"
    unless_null $P4526, vivify_2312
    new $P4526, "Undef"
  vivify_2312:
    find_lex $P4527, "$past"
    unless_null $P4527, vivify_2313
    $P4527 = root_new ['parrot';'Hash']
    store_lex "$past", $P4527
  vivify_2313:
    set $P4527["block_past"], $P4526
.annotate 'line', 1518
    find_lex $P4529, "$/"
    unless_null $P4529, vivify_2314
    $P4529 = root_new ['parrot';'Hash']
  vivify_2314:
    set $P4530, $P4529["trait"]
    unless_null $P4530, vivify_2315
    new $P4530, "Undef"
  vivify_2315:
    unless $P4530, if_4528_end
.annotate 'line', 1519
    find_lex $P4532, "$/"
    unless_null $P4532, vivify_2316
    $P4532 = root_new ['parrot';'Hash']
  vivify_2316:
    set $P4533, $P4532["trait"]
    unless_null $P4533, vivify_2317
    new $P4533, "Undef"
  vivify_2317:
    defined $I4534, $P4533
    unless $I4534, for_undef_2318
    iter $P4531, $P4533
    new $P4544, 'ExceptionHandler'
    set_label $P4544, loop4543_handler
    $P4544."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4544
  loop4543_test:
    unless $P4531, loop4543_done
    shift $P4535, $P4531
  loop4543_redo:
    .const 'Sub' $P4537 = "513_1304456155.152" 
    capture_lex $P4537
    $P4537($P4535)
  loop4543_next:
    goto loop4543_test
  loop4543_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4545, exception, 'type'
    eq $P4545, .CONTROL_LOOP_NEXT, loop4543_next
    eq $P4545, .CONTROL_LOOP_REDO, loop4543_redo
  loop4543_done:
    pop_eh 
  for_undef_2318:
  if_4528_end:
.annotate 'line', 1522
    find_lex $P4546, "$/"
    find_lex $P4547, "$past"
    unless_null $P4547, vivify_2321
    new $P4547, "Undef"
  vivify_2321:
    $P4548 = $P4546."!make"($P4547)
.annotate 'line', 1400
    .return ($P4548)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4245"  :anon :subid("508_1304456155.152") :outer("507_1304456155.152")
.annotate 'line', 1416
    .const 'Sub' $P4400 = "512_1304456155.152" 
    capture_lex $P4400
    .const 'Sub' $P4287 = "509_1304456155.152" 
    capture_lex $P4287
.annotate 'line', 1417
    new $P4247, "Undef"
    .lex "$name", $P4247
    find_lex $P4248, "$/"
    unless_null $P4248, vivify_2207
    $P4248 = root_new ['parrot';'Hash']
  vivify_2207:
    set $P4249, $P4248["sigil"]
    unless_null $P4249, vivify_2208
    $P4249 = root_new ['parrot';'ResizablePMCArray']
  vivify_2208:
    set $P4250, $P4249[0]
    unless_null $P4250, vivify_2209
    new $P4250, "Undef"
  vivify_2209:
    set $S4251, $P4250
    new $P4252, 'String'
    set $P4252, $S4251
    find_lex $P4253, "$/"
    unless_null $P4253, vivify_2210
    $P4253 = root_new ['parrot';'Hash']
  vivify_2210:
    set $P4254, $P4253["deflongname"]
    unless_null $P4254, vivify_2211
    $P4254 = root_new ['parrot';'ResizablePMCArray']
  vivify_2211:
    set $P4255, $P4254[0]
    unless_null $P4255, vivify_2212
    new $P4255, "Undef"
  vivify_2212:
    $S4256 = $P4255."ast"()
    concat $P4257, $P4252, $S4256
    store_lex "$name", $P4257
.annotate 'line', 1418
    find_lex $P4258, "$past"
    unless_null $P4258, vivify_2213
    new $P4258, "Undef"
  vivify_2213:
    find_lex $P4259, "$name"
    unless_null $P4259, vivify_2214
    new $P4259, "Undef"
  vivify_2214:
    $P4258."name"($P4259)
.annotate 'line', 1419
    find_dynamic_lex $P4267, "$*SCOPE"
    unless_null $P4267, vivify_2215
    get_hll_global $P4265, "GLOBAL"
    get_who $P4266, $P4265
    set $P4267, $P4266["$SCOPE"]
    unless_null $P4267, vivify_2216
    die "Contextual $*SCOPE not found"
  vivify_2216:
  vivify_2215:
    set $S4268, $P4267
    iseq $I4269, $S4268, ""
    unless $I4269, unless_4264
    new $P4263, 'Integer'
    set $P4263, $I4269
    goto unless_4264_end
  unless_4264:
    find_dynamic_lex $P4272, "$*SCOPE"
    unless_null $P4272, vivify_2217
    get_hll_global $P4270, "GLOBAL"
    get_who $P4271, $P4270
    set $P4272, $P4271["$SCOPE"]
    unless_null $P4272, vivify_2218
    die "Contextual $*SCOPE not found"
  vivify_2218:
  vivify_2217:
    set $S4273, $P4272
    iseq $I4274, $S4273, "my"
    new $P4263, 'Integer'
    set $P4263, $I4274
  unless_4264_end:
    unless $P4263, unless_4262
    set $P4261, $P4263
    goto unless_4262_end
  unless_4262:
    find_dynamic_lex $P4277, "$*SCOPE"
    unless_null $P4277, vivify_2219
    get_hll_global $P4275, "GLOBAL"
    get_who $P4276, $P4275
    set $P4277, $P4276["$SCOPE"]
    unless_null $P4277, vivify_2220
    die "Contextual $*SCOPE not found"
  vivify_2220:
  vivify_2219:
    set $S4278, $P4277
    iseq $I4279, $S4278, "our"
    new $P4261, 'Integer'
    set $P4261, $I4279
  unless_4262_end:
    if $P4261, if_4260
.annotate 'line', 1507
    find_lex $P4507, "$/"
    unless_null $P4507, vivify_2221
    new $P4507, "Undef"
  vivify_2221:
    $P4508 = $P4507."CURSOR"()
    find_dynamic_lex $P4511, "$*SCOPE"
    unless_null $P4511, vivify_2222
    get_hll_global $P4509, "GLOBAL"
    get_who $P4510, $P4509
    set $P4511, $P4510["$SCOPE"]
    unless_null $P4511, vivify_2223
    die "Contextual $*SCOPE not found"
  vivify_2223:
  vivify_2222:
    concat $P4512, $P4511, " scoped routines are not supported yet"
    $P4508."panic"($P4512)
.annotate 'line', 1506
    goto if_4260_end
  if_4260:
.annotate 'line', 1420
    find_dynamic_lex $P4283, "$*MULTINESS"
    unless_null $P4283, vivify_2224
    get_hll_global $P4281, "GLOBAL"
    get_who $P4282, $P4281
    set $P4283, $P4282["$MULTINESS"]
    unless_null $P4283, vivify_2225
    die "Contextual $*MULTINESS not found"
  vivify_2225:
  vivify_2224:
    set $S4284, $P4283
    iseq $I4285, $S4284, "multi"
    if $I4285, if_4280
.annotate 'line', 1471
    find_dynamic_lex $P4396, "$*MULTINESS"
    unless_null $P4396, vivify_2226
    get_hll_global $P4394, "GLOBAL"
    get_who $P4395, $P4394
    set $P4396, $P4395["$MULTINESS"]
    unless_null $P4396, vivify_2227
    die "Contextual $*MULTINESS not found"
  vivify_2227:
  vivify_2226:
    set $S4397, $P4396
    iseq $I4398, $S4397, "proto"
    if $I4398, if_4393
.annotate 'line', 1490
    find_lex $P4450, "$?PACKAGE"
    get_who $P4451, $P4450
    set $P4452, $P4451["@BLOCK"]
    unless_null $P4452, vivify_2228
    $P4452 = root_new ['parrot';'ResizablePMCArray']
  vivify_2228:
    set $P4453, $P4452[0]
    unless_null $P4453, vivify_2229
    $P4453 = root_new ['parrot';'ResizablePMCArray']
  vivify_2229:
    set $P4454, $P4453[0]
    unless_null $P4454, vivify_2230
    new $P4454, "Undef"
  vivify_2230:
    get_hll_global $P4455, "GLOBAL"
    nqp_get_package_through_who $P4456, $P4455, "PAST"
    get_who $P4457, $P4456
    set $P4458, $P4457["Var"]
    find_lex $P4459, "$name"
    unless_null $P4459, vivify_2231
    new $P4459, "Undef"
  vivify_2231:
    find_lex $P4460, "$past"
    unless_null $P4460, vivify_2232
    new $P4460, "Undef"
  vivify_2232:
    $P4461 = $P4458."new"($P4459 :named("name"), 1 :named("isdecl"), $P4460 :named("viviself"), "lexical" :named("scope"))
    $P4454."push"($P4461)
.annotate 'line', 1492
    find_lex $P4462, "$?PACKAGE"
    get_who $P4463, $P4462
    set $P4464, $P4463["@BLOCK"]
    unless_null $P4464, vivify_2233
    $P4464 = root_new ['parrot';'ResizablePMCArray']
  vivify_2233:
    set $P4465, $P4464[0]
    unless_null $P4465, vivify_2234
    new $P4465, "Undef"
  vivify_2234:
    find_lex $P4466, "$name"
    unless_null $P4466, vivify_2235
    new $P4466, "Undef"
  vivify_2235:
    $P4465."symbol"($P4466, "lexical" :named("scope"))
.annotate 'line', 1493
    find_dynamic_lex $P4470, "$*SCOPE"
    unless_null $P4470, vivify_2236
    get_hll_global $P4468, "GLOBAL"
    get_who $P4469, $P4468
    set $P4470, $P4469["$SCOPE"]
    unless_null $P4470, vivify_2237
    die "Contextual $*SCOPE not found"
  vivify_2237:
  vivify_2236:
    set $S4471, $P4470
    iseq $I4472, $S4471, "our"
    unless $I4472, if_4467_end
.annotate 'line', 1496
    find_dynamic_lex $P4475, "$*SC"
    unless_null $P4475, vivify_2238
    get_hll_global $P4473, "GLOBAL"
    get_who $P4474, $P4473
    set $P4475, $P4474["$SC"]
    unless_null $P4475, vivify_2239
    die "Contextual $*SC not found"
  vivify_2239:
  vivify_2238:
    find_dynamic_lex $P4478, "$*PACKAGE"
    unless_null $P4478, vivify_2240
    get_hll_global $P4476, "GLOBAL"
    get_who $P4477, $P4476
    set $P4478, $P4477["$PACKAGE"]
    unless_null $P4478, vivify_2241
    die "Contextual $*PACKAGE not found"
  vivify_2241:
  vivify_2240:
    find_lex $P4479, "$name"
    unless_null $P4479, vivify_2242
    new $P4479, "Undef"
  vivify_2242:
    find_lex $P4480, "$past"
    unless_null $P4480, vivify_2243
    new $P4480, "Undef"
  vivify_2243:
    $P4475."install_package_routine"($P4478, $P4479, $P4480)
.annotate 'line', 1497
    find_lex $P4481, "$?PACKAGE"
    get_who $P4482, $P4481
    set $P4483, $P4482["@BLOCK"]
    unless_null $P4483, vivify_2244
    $P4483 = root_new ['parrot';'ResizablePMCArray']
  vivify_2244:
    set $P4484, $P4483[0]
    unless_null $P4484, vivify_2245
    $P4484 = root_new ['parrot';'ResizablePMCArray']
  vivify_2245:
    set $P4485, $P4484[0]
    unless_null $P4485, vivify_2246
    new $P4485, "Undef"
  vivify_2246:
    get_hll_global $P4486, "GLOBAL"
    nqp_get_package_through_who $P4487, $P4486, "PAST"
    get_who $P4488, $P4487
    set $P4489, $P4488["Op"]
.annotate 'line', 1499
    find_lex $P4490, "$name"
    unless_null $P4490, vivify_2247
    new $P4490, "Undef"
  vivify_2247:
    new $P4491, "ResizablePMCArray"
    push $P4491, $P4490
    find_lex $P4492, "$/"
    unless_null $P4492, vivify_2248
    new $P4492, "Undef"
  vivify_2248:
    $P4493 = "lexical_package_lookup"($P4491, $P4492)
.annotate 'line', 1500
    get_hll_global $P4494, "GLOBAL"
    nqp_get_package_through_who $P4495, $P4494, "PAST"
    get_who $P4496, $P4495
    set $P4497, $P4496["Var"]
    find_lex $P4498, "$name"
    unless_null $P4498, vivify_2249
    new $P4498, "Undef"
  vivify_2249:
    $P4499 = $P4497."new"($P4498 :named("name"), "lexical" :named("scope"))
    $P4500 = $P4489."new"($P4493, $P4499, "bind" :named("pasttype"))
.annotate 'line', 1497
    $P4485."push"($P4500)
  if_4467_end:
.annotate 'line', 1489
    goto if_4393_end
  if_4393:
.annotate 'line', 1471
    .const 'Sub' $P4400 = "512_1304456155.152" 
    capture_lex $P4400
    $P4400()
  if_4393_end:
    goto if_4280_end
  if_4280:
.annotate 'line', 1420
    .const 'Sub' $P4287 = "509_1304456155.152" 
    capture_lex $P4287
    $P4287()
  if_4280_end:
.annotate 'line', 1504
    get_hll_global $P4501, "GLOBAL"
    nqp_get_package_through_who $P4502, $P4501, "PAST"
    get_who $P4503, $P4502
    set $P4504, $P4503["Var"]
    find_lex $P4505, "$name"
    unless_null $P4505, vivify_2307
    new $P4505, "Undef"
  vivify_2307:
    $P4506 = $P4504."new"($P4505 :named("name"))
    store_lex "$past", $P4506
  if_4260_end:
.annotate 'line', 1511
    find_lex $P4517, "$name"
    unless_null $P4517, vivify_2308
    new $P4517, "Undef"
  vivify_2308:
    set $S4518, $P4517
    iseq $I4519, $S4518, "MAIN"
    if $I4519, if_4516
    new $P4515, 'Integer'
    set $P4515, $I4519
    goto if_4516_end
  if_4516:
    find_dynamic_lex $P4522, "$*MULTINESS"
    unless_null $P4522, vivify_2309
    get_hll_global $P4520, "GLOBAL"
    get_who $P4521, $P4520
    set $P4522, $P4521["$MULTINESS"]
    unless_null $P4522, vivify_2310
    die "Contextual $*MULTINESS not found"
  vivify_2310:
  vivify_2309:
    set $S4523, $P4522
    isne $I4524, $S4523, "multi"
    new $P4515, 'Integer'
    set $P4515, $I4524
  if_4516_end:
    if $P4515, if_4514
    set $P4513, $P4515
    goto if_4514_end
  if_4514:
.annotate 'line', 1512
    find_lex $P4525, "$block"
    unless_null $P4525, vivify_2311
    new $P4525, "Undef"
  vivify_2311:
    store_dynamic_lex "$*MAIN_SUB", $P4525
.annotate 'line', 1511
    set $P4513, $P4525
  if_4514_end:
.annotate 'line', 1416
    .return ($P4513)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4399"  :anon :subid("512_1304456155.152") :outer("508_1304456155.152")
.annotate 'line', 1476
    new $P4401, "Undef"
    .lex "$cholder", $P4401
.annotate 'line', 1475
    find_dynamic_lex $P4405, "$*SCOPE"
    unless_null $P4405, vivify_2250
    get_hll_global $P4403, "GLOBAL"
    get_who $P4404, $P4403
    set $P4405, $P4404["$SCOPE"]
    unless_null $P4405, vivify_2251
    die "Contextual $*SCOPE not found"
  vivify_2251:
  vivify_2250:
    set $S4406, $P4405
    iseq $I4407, $S4406, "our"
    unless $I4407, if_4402_end
    die "our-scoped protos not yet implemented"
  if_4402_end:
.annotate 'line', 1476
    get_hll_global $P4408, "GLOBAL"
    nqp_get_package_through_who $P4409, $P4408, "PAST"
    get_who $P4410, $P4409
    set $P4411, $P4410["Op"]
    $P4412 = $P4411."new"("list" :named("pasttype"))
    store_lex "$cholder", $P4412
.annotate 'line', 1477
    find_lex $P4413, "$?PACKAGE"
    get_who $P4414, $P4413
    set $P4415, $P4414["@BLOCK"]
    unless_null $P4415, vivify_2252
    $P4415 = root_new ['parrot';'ResizablePMCArray']
  vivify_2252:
    set $P4416, $P4415[0]
    unless_null $P4416, vivify_2253
    $P4416 = root_new ['parrot';'ResizablePMCArray']
  vivify_2253:
    set $P4417, $P4416[0]
    unless_null $P4417, vivify_2254
    new $P4417, "Undef"
  vivify_2254:
    get_hll_global $P4418, "GLOBAL"
    nqp_get_package_through_who $P4419, $P4418, "PAST"
    get_who $P4420, $P4419
    set $P4421, $P4420["Var"]
    find_lex $P4422, "$name"
    unless_null $P4422, vivify_2255
    new $P4422, "Undef"
  vivify_2255:
    find_lex $P4423, "$past"
    unless_null $P4423, vivify_2256
    new $P4423, "Undef"
  vivify_2256:
    $P4424 = $P4421."new"($P4422 :named("name"), 1 :named("isdecl"), $P4423 :named("viviself"), "lexical" :named("scope"))
    $P4417."push"($P4424)
.annotate 'line', 1479
    find_lex $P4425, "$?PACKAGE"
    get_who $P4426, $P4425
    set $P4427, $P4426["@BLOCK"]
    unless_null $P4427, vivify_2257
    $P4427 = root_new ['parrot';'ResizablePMCArray']
  vivify_2257:
    set $P4428, $P4427[0]
    unless_null $P4428, vivify_2258
    $P4428 = root_new ['parrot';'ResizablePMCArray']
  vivify_2258:
    set $P4429, $P4428[0]
    unless_null $P4429, vivify_2259
    new $P4429, "Undef"
  vivify_2259:
    get_hll_global $P4430, "GLOBAL"
    nqp_get_package_through_who $P4431, $P4430, "PAST"
    get_who $P4432, $P4431
    set $P4433, $P4432["Op"]
.annotate 'line', 1481
    get_hll_global $P4434, "GLOBAL"
    nqp_get_package_through_who $P4435, $P4434, "PAST"
    get_who $P4436, $P4435
    set $P4437, $P4436["Var"]
    find_lex $P4438, "$name"
    unless_null $P4438, vivify_2260
    new $P4438, "Undef"
  vivify_2260:
    $P4439 = $P4437."new"($P4438 :named("name"))
    find_lex $P4440, "$cholder"
    unless_null $P4440, vivify_2261
    new $P4440, "Undef"
  vivify_2261:
    $P4441 = $P4433."new"($P4439, $P4440, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 1479
    $P4429."push"($P4441)
.annotate 'line', 1484
    find_lex $P4442, "$?PACKAGE"
    get_who $P4443, $P4442
    set $P4444, $P4443["@BLOCK"]
    unless_null $P4444, vivify_2262
    $P4444 = root_new ['parrot';'ResizablePMCArray']
  vivify_2262:
    set $P4445, $P4444[0]
    unless_null $P4445, vivify_2263
    new $P4445, "Undef"
  vivify_2263:
    find_lex $P4446, "$name"
    unless_null $P4446, vivify_2264
    new $P4446, "Undef"
  vivify_2264:
    find_lex $P4447, "$cholder"
    unless_null $P4447, vivify_2265
    new $P4447, "Undef"
  vivify_2265:
    $P4445."symbol"($P4446, "lexical" :named("scope"), 1 :named("proto"), $P4447 :named("cholder"))
.annotate 'line', 1487
    find_lex $P4448, "$past"
    unless_null $P4448, vivify_2266
    new $P4448, "Undef"
  vivify_2266:
    $P4449 = $P4448."pirflags"(":instanceof(\"DispatcherSub\")")
.annotate 'line', 1471
    .return ($P4449)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4286"  :anon :subid("509_1304456155.152") :outer("508_1304456155.152")
.annotate 'line', 1420
    .const 'Sub' $P4309 = "510_1304456155.152" 
    capture_lex $P4309
.annotate 'line', 1423
    new $P4288, "Undef"
    .lex "$cholder", $P4288
.annotate 'line', 1424
    $P4289 = root_new ['parrot';'Hash']
    .lex "%sym", $P4289
.annotate 'line', 1422
    find_dynamic_lex $P4293, "$*SCOPE"
    unless_null $P4293, vivify_2267
    get_hll_global $P4291, "GLOBAL"
    get_who $P4292, $P4291
    set $P4293, $P4292["$SCOPE"]
    unless_null $P4293, vivify_2268
    die "Contextual $*SCOPE not found"
  vivify_2268:
  vivify_2267:
    set $S4294, $P4293
    iseq $I4295, $S4294, "our"
    unless $I4295, if_4290_end
    die "our-scoped multis not yet implemented"
  if_4290_end:
    find_lex $P4296, "$cholder"
    unless_null $P4296, vivify_2269
    new $P4296, "Undef"
  vivify_2269:
.annotate 'line', 1424
    find_lex $P4297, "$?PACKAGE"
    get_who $P4298, $P4297
    set $P4299, $P4298["@BLOCK"]
    unless_null $P4299, vivify_2270
    $P4299 = root_new ['parrot';'ResizablePMCArray']
  vivify_2270:
    set $P4300, $P4299[0]
    unless_null $P4300, vivify_2271
    new $P4300, "Undef"
  vivify_2271:
    find_lex $P4301, "$name"
    unless_null $P4301, vivify_2272
    new $P4301, "Undef"
  vivify_2272:
    $P4302 = $P4300."symbol"($P4301)
    store_lex "%sym", $P4302
.annotate 'line', 1425
    find_lex $P4304, "%sym"
    unless_null $P4304, vivify_2273
    $P4304 = root_new ['parrot';'Hash']
  vivify_2273:
    set $P4305, $P4304["cholder"]
    unless_null $P4305, vivify_2274
    new $P4305, "Undef"
  vivify_2274:
    if $P4305, if_4303
.annotate 'line', 1430
    .const 'Sub' $P4309 = "510_1304456155.152" 
    capture_lex $P4309
    $P4309()
    goto if_4303_end
  if_4303:
.annotate 'line', 1426
    find_lex $P4306, "%sym"
    unless_null $P4306, vivify_2302
    $P4306 = root_new ['parrot';'Hash']
  vivify_2302:
    set $P4307, $P4306["cholder"]
    unless_null $P4307, vivify_2303
    new $P4307, "Undef"
  vivify_2303:
    store_lex "$cholder", $P4307
  if_4303_end:
.annotate 'line', 1466
    find_lex $P4389, "$cholder"
    unless_null $P4389, vivify_2304
    new $P4389, "Undef"
  vivify_2304:
    find_lex $P4390, "$past"
    unless_null $P4390, vivify_2305
    new $P4390, "Undef"
  vivify_2305:
    $P4389."push"($P4390)
.annotate 'line', 1469
    find_lex $P4391, "$past"
    unless_null $P4391, vivify_2306
    new $P4391, "Undef"
  vivify_2306:
    $P4392 = "attach_multi_signature"($P4391)
.annotate 'line', 1420
    .return ($P4392)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block4308"  :anon :subid("510_1304456155.152") :outer("509_1304456155.152")
.annotate 'line', 1430
    .const 'Sub' $P4325 = "511_1304456155.152" 
    capture_lex $P4325
.annotate 'line', 1437
    new $P4310, "Undef"
    .lex "$found_proto", $P4310
.annotate 'line', 1455
    new $P4311, "Undef"
    .lex "$dispatch_setup", $P4311
.annotate 'line', 1432
    find_lex $P4313, "%sym"
    unless_null $P4313, vivify_2275
    $P4313 = root_new ['parrot';'Hash']
  vivify_2275:
    set $P4314, $P4313["proto"]
    unless_null $P4314, vivify_2276
    new $P4314, "Undef"
  vivify_2276:
    unless $P4314, if_4312_end
.annotate 'line', 1435
    find_lex $P4315, "$/"
    unless_null $P4315, vivify_2277
    new $P4315, "Undef"
  vivify_2277:
    $P4316 = $P4315."CURSOR"()
    $P4316."panic"("Internal Error: Current scope has a proto, but no candidate list holder was set up. (This should never happen.)")
  if_4312_end:
.annotate 'line', 1432
    find_lex $P4317, "$found_proto"
    unless_null $P4317, vivify_2278
    new $P4317, "Undef"
  vivify_2278:
.annotate 'line', 1438
    find_lex $P4319, "$?PACKAGE"
    get_who $P4320, $P4319
    set $P4321, $P4320["@BLOCK"]
    unless_null $P4321, vivify_2279
    $P4321 = root_new ['parrot';'ResizablePMCArray']
  vivify_2279:
    defined $I4322, $P4321
    unless $I4322, for_undef_2280
    iter $P4318, $P4321
    new $P4347, 'ExceptionHandler'
    set_label $P4347, loop4346_handler
    $P4347."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4347
  loop4346_test:
    unless $P4318, loop4346_done
    shift $P4323, $P4318
  loop4346_redo:
    .const 'Sub' $P4325 = "511_1304456155.152" 
    capture_lex $P4325
    $P4325($P4323)
  loop4346_next:
    goto loop4346_test
  loop4346_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4348, exception, 'type'
    eq $P4348, .CONTROL_LOOP_NEXT, loop4346_next
    eq $P4348, .CONTROL_LOOP_REDO, loop4346_redo
  loop4346_done:
    pop_eh 
  for_undef_2280:
.annotate 'line', 1449
    find_lex $P4350, "$found_proto"
    unless_null $P4350, vivify_2289
    new $P4350, "Undef"
  vivify_2289:
    if $P4350, unless_4349_end
.annotate 'line', 1450
    find_lex $P4351, "$/"
    unless_null $P4351, vivify_2290
    new $P4351, "Undef"
  vivify_2290:
    $P4352 = $P4351."CURSOR"()
    $P4352."panic"("Sorry, no proto sub in scope, and auto-generation of protos is not yet implemented.")
  unless_4349_end:
.annotate 'line', 1454
    get_hll_global $P4353, "GLOBAL"
    nqp_get_package_through_who $P4354, $P4353, "PAST"
    get_who $P4355, $P4354
    set $P4356, $P4355["Op"]
    $P4357 = $P4356."new"("list" :named("pasttype"))
    store_lex "$cholder", $P4357
.annotate 'line', 1455
    get_hll_global $P4358, "GLOBAL"
    nqp_get_package_through_who $P4359, $P4358, "PAST"
    get_who $P4360, $P4359
    set $P4361, $P4360["Op"]
.annotate 'line', 1457
    get_hll_global $P4362, "GLOBAL"
    nqp_get_package_through_who $P4363, $P4362, "PAST"
    get_who $P4364, $P4363
    set $P4365, $P4364["Var"]
    find_lex $P4366, "$name"
    unless_null $P4366, vivify_2291
    new $P4366, "Undef"
  vivify_2291:
    $P4367 = $P4365."new"($P4366 :named("name"), "outer" :named("scope"))
    find_lex $P4368, "$cholder"
    unless_null $P4368, vivify_2292
    new $P4368, "Undef"
  vivify_2292:
    $P4369 = $P4361."new"($P4367, $P4368, "create_dispatch_and_add_candidates PPP" :named("pirop"))
.annotate 'line', 1455
    store_lex "$dispatch_setup", $P4369
.annotate 'line', 1460
    find_lex $P4370, "$?PACKAGE"
    get_who $P4371, $P4370
    set $P4372, $P4371["@BLOCK"]
    unless_null $P4372, vivify_2293
    $P4372 = root_new ['parrot';'ResizablePMCArray']
  vivify_2293:
    set $P4373, $P4372[0]
    unless_null $P4373, vivify_2294
    $P4373 = root_new ['parrot';'ResizablePMCArray']
  vivify_2294:
    set $P4374, $P4373[0]
    unless_null $P4374, vivify_2295
    new $P4374, "Undef"
  vivify_2295:
    get_hll_global $P4375, "GLOBAL"
    nqp_get_package_through_who $P4376, $P4375, "PAST"
    get_who $P4377, $P4376
    set $P4378, $P4377["Var"]
    find_lex $P4379, "$name"
    unless_null $P4379, vivify_2296
    new $P4379, "Undef"
  vivify_2296:
    find_lex $P4380, "$dispatch_setup"
    unless_null $P4380, vivify_2297
    new $P4380, "Undef"
  vivify_2297:
    $P4381 = $P4378."new"($P4379 :named("name"), 1 :named("isdecl"), $P4380 :named("viviself"), "lexical" :named("scope"))
    $P4374."push"($P4381)
.annotate 'line', 1462
    find_lex $P4382, "$?PACKAGE"
    get_who $P4383, $P4382
    set $P4384, $P4383["@BLOCK"]
    unless_null $P4384, vivify_2298
    $P4384 = root_new ['parrot';'ResizablePMCArray']
  vivify_2298:
    set $P4385, $P4384[0]
    unless_null $P4385, vivify_2299
    new $P4385, "Undef"
  vivify_2299:
    find_lex $P4386, "$name"
    unless_null $P4386, vivify_2300
    new $P4386, "Undef"
  vivify_2300:
    find_lex $P4387, "$cholder"
    unless_null $P4387, vivify_2301
    new $P4387, "Undef"
  vivify_2301:
    $P4388 = $P4385."symbol"($P4386, "lexical" :named("scope"), $P4387 :named("cholder"))
.annotate 'line', 1430
    .return ($P4388)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4324"  :anon :subid("511_1304456155.152") :outer("510_1304456155.152")
    .param pmc param_4327
.annotate 'line', 1439
    $P4326 = root_new ['parrot';'Hash']
    .lex "%sym", $P4326
    .lex "$_", param_4327
    find_lex $P4328, "$_"
    unless_null $P4328, vivify_2281
    new $P4328, "Undef"
  vivify_2281:
    find_lex $P4329, "$name"
    unless_null $P4329, vivify_2282
    new $P4329, "Undef"
  vivify_2282:
    $P4330 = $P4328."symbol"($P4329)
    store_lex "%sym", $P4330
.annotate 'line', 1440
    find_lex $P4335, "%sym"
    unless_null $P4335, vivify_2283
    $P4335 = root_new ['parrot';'Hash']
  vivify_2283:
    set $P4336, $P4335["proto"]
    unless_null $P4336, vivify_2284
    new $P4336, "Undef"
  vivify_2284:
    unless $P4336, unless_4334
    set $P4333, $P4336
    goto unless_4334_end
  unless_4334:
    find_lex $P4337, "%sym"
    unless_null $P4337, vivify_2285
    $P4337 = root_new ['parrot';'Hash']
  vivify_2285:
    set $P4338, $P4337["cholder"]
    unless_null $P4338, vivify_2286
    new $P4338, "Undef"
  vivify_2286:
    set $P4333, $P4338
  unless_4334_end:
    if $P4333, if_4332
.annotate 'line', 1443
    find_lex $P4342, "%sym"
    unless_null $P4342, vivify_2287
    $P4342 = root_new ['parrot';'Hash']
  vivify_2287:
    if $P4342, if_4341
    set $P4340, $P4342
    goto if_4341_end
  if_4341:
.annotate 'line', 1444
    find_lex $P4343, "$/"
    unless_null $P4343, vivify_2288
    new $P4343, "Undef"
  vivify_2288:
    $P4344 = $P4343."CURSOR"()
    $P4345 = $P4344."panic"("Cannot declare a multi when an only is already in scope.")
.annotate 'line', 1443
    set $P4340, $P4345
  if_4341_end:
    set $P4331, $P4340
.annotate 'line', 1440
    goto if_4332_end
  if_4332:
.annotate 'line', 1441
    new $P4339, "Integer"
    assign $P4339, 1
    store_lex "$found_proto", $P4339
.annotate 'line', 1440
    set $P4331, $P4339
  if_4332_end:
.annotate 'line', 1438
    .return ($P4331)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4536"  :anon :subid("513_1304456155.152") :outer("507_1304456155.152")
    .param pmc param_4538
.annotate 'line', 1519
    .lex "$_", param_4538
    find_lex $P4539, "$_"
    unless_null $P4539, vivify_2319
    new $P4539, "Undef"
  vivify_2319:
    $P4540 = $P4539."ast"()
    find_lex $P4541, "$/"
    unless_null $P4541, vivify_2320
    new $P4541, "Undef"
  vivify_2320:
    $P4542 = $P4540($P4541)
    .return ($P4542)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "method_def"  :subid("514_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_4550
    .param pmc param_4551
.annotate 'line', 1526
    .const 'Sub' $P4667 = "516_1304456155.152" 
    capture_lex $P4667
    .const 'Sub' $P4589 = "515_1304456155.152" 
    capture_lex $P4589
    .lex "self", param_4550
    .lex "$/", param_4551
.annotate 'line', 1529
    new $P4552, "Undef"
    .lex "$past", $P4552
.annotate 'line', 1526
    find_lex $P4553, "$past"
    unless_null $P4553, vivify_2322
    new $P4553, "Undef"
  vivify_2322:
.annotate 'line', 1530
    find_lex $P4555, "$/"
    unless_null $P4555, vivify_2323
    $P4555 = root_new ['parrot';'Hash']
  vivify_2323:
    set $P4556, $P4555["onlystar"]
    unless_null $P4556, vivify_2324
    new $P4556, "Undef"
  vivify_2324:
    if $P4556, if_4554
.annotate 'line', 1534
    find_lex $P4558, "$/"
    unless_null $P4558, vivify_2325
    $P4558 = root_new ['parrot';'Hash']
  vivify_2325:
    set $P4559, $P4558["blockoid"]
    unless_null $P4559, vivify_2326
    new $P4559, "Undef"
  vivify_2326:
    $P4560 = $P4559."ast"()
    store_lex "$past", $P4560
.annotate 'line', 1535
    find_lex $P4561, "$past"
    unless_null $P4561, vivify_2327
    new $P4561, "Undef"
  vivify_2327:
    $P4561."blocktype"("declaration")
.annotate 'line', 1536
    find_dynamic_lex $P4565, "$*RETURN_USED"
    unless_null $P4565, vivify_2328
    get_hll_global $P4563, "GLOBAL"
    get_who $P4564, $P4563
    set $P4565, $P4564["$RETURN_USED"]
    unless_null $P4565, vivify_2329
    die "Contextual $*RETURN_USED not found"
  vivify_2329:
  vivify_2328:
    unless $P4565, if_4562_end
.annotate 'line', 1537
    find_lex $P4566, "$past"
    unless_null $P4566, vivify_2330
    new $P4566, "Undef"
  vivify_2330:
    $P4566."control"("return_pir")
  if_4562_end:
.annotate 'line', 1533
    goto if_4554_end
  if_4554:
.annotate 'line', 1531
    $P4557 = "only_star_block"()
    store_lex "$past", $P4557
  if_4554_end:
.annotate 'line', 1542
    find_lex $P4568, "$past"
    unless_null $P4568, vivify_2331
    $P4568 = root_new ['parrot';'Hash']
  vivify_2331:
    set $P4569, $P4568["signature_has_invocant"]
    unless_null $P4569, vivify_2332
    new $P4569, "Undef"
  vivify_2332:
    if $P4569, unless_4567_end
.annotate 'line', 1543
    find_lex $P4570, "$past"
    unless_null $P4570, vivify_2333
    $P4570 = root_new ['parrot';'ResizablePMCArray']
  vivify_2333:
    set $P4571, $P4570[0]
    unless_null $P4571, vivify_2334
    new $P4571, "Undef"
  vivify_2334:
    get_hll_global $P4572, "GLOBAL"
    nqp_get_package_through_who $P4573, $P4572, "PAST"
    get_who $P4574, $P4573
    set $P4575, $P4574["Var"]
.annotate 'line', 1545
    find_dynamic_lex $P4578, "$*SC"
    unless_null $P4578, vivify_2335
    get_hll_global $P4576, "GLOBAL"
    get_who $P4577, $P4576
    set $P4578, $P4577["$SC"]
    unless_null $P4578, vivify_2336
    die "Contextual $*SC not found"
  vivify_2336:
  vivify_2335:
    find_dynamic_lex $P4581, "$*PACKAGE"
    unless_null $P4581, vivify_2337
    get_hll_global $P4579, "GLOBAL"
    get_who $P4580, $P4579
    set $P4581, $P4580["$PACKAGE"]
    unless_null $P4581, vivify_2338
    die "Contextual $*PACKAGE not found"
  vivify_2338:
  vivify_2337:
    $P4582 = $P4578."get_object_sc_ref_past"($P4581)
    $P4583 = $P4575."new"("self" :named("name"), "parameter" :named("scope"), $P4582 :named("multitype"))
.annotate 'line', 1543
    $P4571."unshift"($P4583)
  unless_4567_end:
.annotate 'line', 1548
    find_lex $P4584, "$past"
    unless_null $P4584, vivify_2339
    new $P4584, "Undef"
  vivify_2339:
    $P4584."symbol"("self", "lexical" :named("scope"))
.annotate 'line', 1551
    find_lex $P4586, "$/"
    unless_null $P4586, vivify_2340
    $P4586 = root_new ['parrot';'Hash']
  vivify_2340:
    set $P4587, $P4586["deflongname"]
    unless_null $P4587, vivify_2341
    new $P4587, "Undef"
  vivify_2341:
    unless $P4587, if_4585_end
    .const 'Sub' $P4589 = "515_1304456155.152" 
    capture_lex $P4589
    $P4589()
  if_4585_end:
.annotate 'line', 1572
    find_lex $P4653, "$/"
    find_lex $P4654, "$past"
    unless_null $P4654, vivify_2372
    new $P4654, "Undef"
  vivify_2372:
    $P4653."!make"($P4654)
.annotate 'line', 1573
    find_lex $P4655, "$past"
    unless_null $P4655, vivify_2373
    new $P4655, "Undef"
  vivify_2373:
    find_lex $P4656, "$past"
    unless_null $P4656, vivify_2374
    $P4656 = root_new ['parrot';'Hash']
    store_lex "$past", $P4656
  vivify_2374:
    set $P4656["block_past"], $P4655
.annotate 'line', 1574
    find_lex $P4659, "$/"
    unless_null $P4659, vivify_2375
    $P4659 = root_new ['parrot';'Hash']
  vivify_2375:
    set $P4660, $P4659["trait"]
    unless_null $P4660, vivify_2376
    new $P4660, "Undef"
  vivify_2376:
    if $P4660, if_4658
    set $P4657, $P4660
    goto if_4658_end
  if_4658:
.annotate 'line', 1575
    find_lex $P4662, "$/"
    unless_null $P4662, vivify_2377
    $P4662 = root_new ['parrot';'Hash']
  vivify_2377:
    set $P4663, $P4662["trait"]
    unless_null $P4663, vivify_2378
    new $P4663, "Undef"
  vivify_2378:
    defined $I4664, $P4663
    unless $I4664, for_undef_2379
    iter $P4661, $P4663
    new $P4674, 'ExceptionHandler'
    set_label $P4674, loop4673_handler
    $P4674."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4674
  loop4673_test:
    unless $P4661, loop4673_done
    shift $P4665, $P4661
  loop4673_redo:
    .const 'Sub' $P4667 = "516_1304456155.152" 
    capture_lex $P4667
    $P4667($P4665)
  loop4673_next:
    goto loop4673_test
  loop4673_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4675, exception, 'type'
    eq $P4675, .CONTROL_LOOP_NEXT, loop4673_next
    eq $P4675, .CONTROL_LOOP_REDO, loop4673_redo
  loop4673_done:
    pop_eh 
  for_undef_2379:
.annotate 'line', 1574
    set $P4657, $P4661
  if_4658_end:
.annotate 'line', 1526
    .return ($P4657)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4588"  :anon :subid("515_1304456155.152") :outer("514_1304456155.152")
.annotate 'line', 1553
    new $P4590, "Undef"
    .lex "$name", $P4590
.annotate 'line', 1561
    new $P4591, "Undef"
    .lex "$meta_meth", $P4591
.annotate 'line', 1562
    new $P4592, "Undef"
    .lex "$is_dispatcher", $P4592
.annotate 'line', 1553
    find_lex $P4593, "$/"
    unless_null $P4593, vivify_2342
    $P4593 = root_new ['parrot';'Hash']
  vivify_2342:
    set $P4594, $P4593["private"]
    unless_null $P4594, vivify_2343
    new $P4594, "Undef"
  vivify_2343:
    set $S4595, $P4594
    new $P4596, 'String'
    set $P4596, $S4595
    find_lex $P4597, "$/"
    unless_null $P4597, vivify_2344
    $P4597 = root_new ['parrot';'Hash']
  vivify_2344:
    set $P4598, $P4597["deflongname"]
    unless_null $P4598, vivify_2345
    $P4598 = root_new ['parrot';'ResizablePMCArray']
  vivify_2345:
    set $P4599, $P4598[0]
    unless_null $P4599, vivify_2346
    new $P4599, "Undef"
  vivify_2346:
    $P4600 = $P4599."ast"()
    set $S4601, $P4600
    concat $P4602, $P4596, $S4601
    store_lex "$name", $P4602
.annotate 'line', 1554
    find_lex $P4603, "$past"
    unless_null $P4603, vivify_2347
    new $P4603, "Undef"
  vivify_2347:
    find_lex $P4604, "$name"
    unless_null $P4604, vivify_2348
    new $P4604, "Undef"
  vivify_2348:
    $P4603."name"($P4604)
.annotate 'line', 1558
    find_dynamic_lex $P4608, "$*MULTINESS"
    unless_null $P4608, vivify_2349
    get_hll_global $P4606, "GLOBAL"
    get_who $P4607, $P4606
    set $P4608, $P4607["$MULTINESS"]
    unless_null $P4608, vivify_2350
    die "Contextual $*MULTINESS not found"
  vivify_2350:
  vivify_2349:
    set $S4609, $P4608
    iseq $I4610, $S4609, "multi"
    unless $I4610, if_4605_end
    find_lex $P4611, "$past"
    unless_null $P4611, vivify_2351
    new $P4611, "Undef"
  vivify_2351:
    "attach_multi_signature"($P4611)
  if_4605_end:
.annotate 'line', 1561
    find_dynamic_lex $P4616, "$*MULTINESS"
    unless_null $P4616, vivify_2352
    get_hll_global $P4614, "GLOBAL"
    get_who $P4615, $P4614
    set $P4616, $P4615["$MULTINESS"]
    unless_null $P4616, vivify_2353
    die "Contextual $*MULTINESS not found"
  vivify_2353:
  vivify_2352:
    set $S4617, $P4616
    iseq $I4618, $S4617, "multi"
    if $I4618, if_4613
    new $P4620, "String"
    assign $P4620, "add_method"
    set $P4612, $P4620
    goto if_4613_end
  if_4613:
    new $P4619, "String"
    assign $P4619, "add_multi_method"
    set $P4612, $P4619
  if_4613_end:
    store_lex "$meta_meth", $P4612
.annotate 'line', 1562
    find_dynamic_lex $P4623, "$*MULTINESS"
    unless_null $P4623, vivify_2354
    get_hll_global $P4621, "GLOBAL"
    get_who $P4622, $P4621
    set $P4623, $P4622["$MULTINESS"]
    unless_null $P4623, vivify_2355
    die "Contextual $*MULTINESS not found"
  vivify_2355:
  vivify_2354:
    set $S4624, $P4623
    iseq $I4625, $S4624, "proto"
    new $P4626, 'Integer'
    set $P4626, $I4625
    store_lex "$is_dispatcher", $P4626
.annotate 'line', 1563
    find_dynamic_lex $P4629, "$*SC"
    unless_null $P4629, vivify_2356
    get_hll_global $P4627, "GLOBAL"
    get_who $P4628, $P4627
    set $P4629, $P4628["$SC"]
    unless_null $P4629, vivify_2357
    die "Contextual $*SC not found"
  vivify_2357:
  vivify_2356:
    find_dynamic_lex $P4632, "$*PACKAGE"
    unless_null $P4632, vivify_2358
    get_hll_global $P4630, "GLOBAL"
    get_who $P4631, $P4630
    set $P4632, $P4631["$PACKAGE"]
    unless_null $P4632, vivify_2359
    die "Contextual $*PACKAGE not found"
  vivify_2359:
  vivify_2358:
    find_lex $P4633, "$meta_meth"
    unless_null $P4633, vivify_2360
    new $P4633, "Undef"
  vivify_2360:
    find_lex $P4634, "$name"
    unless_null $P4634, vivify_2361
    new $P4634, "Undef"
  vivify_2361:
    find_lex $P4635, "$past"
    unless_null $P4635, vivify_2362
    new $P4635, "Undef"
  vivify_2362:
    find_lex $P4636, "$is_dispatcher"
    unless_null $P4636, vivify_2363
    new $P4636, "Undef"
  vivify_2363:
    $P4629."pkg_add_method"($P4632, $P4633, $P4634, $P4635, $P4636)
.annotate 'line', 1566
    find_dynamic_lex $P4641, "$*SCOPE"
    unless_null $P4641, vivify_2364
    get_hll_global $P4639, "GLOBAL"
    get_who $P4640, $P4639
    set $P4641, $P4640["$SCOPE"]
    unless_null $P4641, vivify_2365
    die "Contextual $*SCOPE not found"
  vivify_2365:
  vivify_2364:
    set $S4642, $P4641
    iseq $I4643, $S4642, "our"
    if $I4643, if_4638
    new $P4637, 'Integer'
    set $P4637, $I4643
    goto if_4638_end
  if_4638:
.annotate 'line', 1567
    find_dynamic_lex $P4646, "$*SC"
    unless_null $P4646, vivify_2366
    get_hll_global $P4644, "GLOBAL"
    get_who $P4645, $P4644
    set $P4646, $P4645["$SC"]
    unless_null $P4646, vivify_2367
    die "Contextual $*SC not found"
  vivify_2367:
  vivify_2366:
    find_dynamic_lex $P4649, "$*PACKAGE"
    unless_null $P4649, vivify_2368
    get_hll_global $P4647, "GLOBAL"
    get_who $P4648, $P4647
    set $P4649, $P4648["$PACKAGE"]
    unless_null $P4649, vivify_2369
    die "Contextual $*PACKAGE not found"
  vivify_2369:
  vivify_2368:
    find_lex $P4650, "$name"
    unless_null $P4650, vivify_2370
    new $P4650, "Undef"
  vivify_2370:
    find_lex $P4651, "$past"
    unless_null $P4651, vivify_2371
    new $P4651, "Undef"
  vivify_2371:
    $P4652 = $P4646."install_package_routine"($P4649, $P4650, $P4651)
.annotate 'line', 1566
    set $P4637, $P4652
  if_4638_end:
.annotate 'line', 1551
    .return ($P4637)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4666"  :anon :subid("516_1304456155.152") :outer("514_1304456155.152")
    .param pmc param_4668
.annotate 'line', 1575
    .lex "$_", param_4668
    find_lex $P4669, "$_"
    unless_null $P4669, vivify_2380
    new $P4669, "Undef"
  vivify_2380:
    $P4670 = $P4669."ast"()
    find_lex $P4671, "$/"
    unless_null $P4671, vivify_2381
    new $P4671, "Undef"
  vivify_2381:
    $P4672 = $P4670($P4671)
    .return ($P4672)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "signature"  :subid("517_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_4679
    .param pmc param_4680
.annotate 'line', 1604
    .const 'Sub' $P4723 = "519_1304456155.152" 
    capture_lex $P4723
    .const 'Sub' $P4691 = "518_1304456155.152" 
    capture_lex $P4691
    .lex "self", param_4679
    .lex "$/", param_4680
.annotate 'line', 1605
    new $P4681, "Undef"
    .lex "$BLOCKINIT", $P4681
    find_lex $P4682, "$?PACKAGE"
    get_who $P4683, $P4682
    set $P4684, $P4683["@BLOCK"]
    unless_null $P4684, vivify_2382
    $P4684 = root_new ['parrot';'ResizablePMCArray']
  vivify_2382:
    set $P4685, $P4684[0]
    unless_null $P4685, vivify_2383
    $P4685 = root_new ['parrot';'ResizablePMCArray']
  vivify_2383:
    set $P4686, $P4685[0]
    unless_null $P4686, vivify_2384
    new $P4686, "Undef"
  vivify_2384:
    store_lex "$BLOCKINIT", $P4686
.annotate 'line', 1606
    find_lex $P4688, "$/"
    unless_null $P4688, vivify_2385
    $P4688 = root_new ['parrot';'Hash']
  vivify_2385:
    set $P4689, $P4688["invocant"]
    unless_null $P4689, vivify_2386
    new $P4689, "Undef"
  vivify_2386:
    unless $P4689, if_4687_end
    .const 'Sub' $P4691 = "518_1304456155.152" 
    capture_lex $P4691
    $P4691()
  if_4687_end:
.annotate 'line', 1615
    find_lex $P4718, "$/"
    unless_null $P4718, vivify_2396
    $P4718 = root_new ['parrot';'Hash']
  vivify_2396:
    set $P4719, $P4718["parameter"]
    unless_null $P4719, vivify_2397
    new $P4719, "Undef"
  vivify_2397:
    defined $I4720, $P4719
    unless $I4720, for_undef_2398
    iter $P4717, $P4719
    new $P4730, 'ExceptionHandler'
    set_label $P4730, loop4729_handler
    $P4730."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4730
  loop4729_test:
    unless $P4717, loop4729_done
    shift $P4721, $P4717
  loop4729_redo:
    .const 'Sub' $P4723 = "519_1304456155.152" 
    capture_lex $P4723
    $P4723($P4721)
  loop4729_next:
    goto loop4729_test
  loop4729_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4731, exception, 'type'
    eq $P4731, .CONTROL_LOOP_NEXT, loop4729_next
    eq $P4731, .CONTROL_LOOP_REDO, loop4729_redo
  loop4729_done:
    pop_eh 
  for_undef_2398:
.annotate 'line', 1604
    .return ($P4717)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4690"  :anon :subid("518_1304456155.152") :outer("517_1304456155.152")
.annotate 'line', 1607
    new $P4692, "Undef"
    .lex "$inv", $P4692
    find_lex $P4693, "$/"
    unless_null $P4693, vivify_2387
    $P4693 = root_new ['parrot';'Hash']
  vivify_2387:
    set $P4694, $P4693["invocant"]
    unless_null $P4694, vivify_2388
    $P4694 = root_new ['parrot';'ResizablePMCArray']
  vivify_2388:
    set $P4695, $P4694[0]
    unless_null $P4695, vivify_2389
    new $P4695, "Undef"
  vivify_2389:
    $P4696 = $P4695."ast"()
    store_lex "$inv", $P4696
.annotate 'line', 1608
    find_lex $P4697, "$BLOCKINIT"
    unless_null $P4697, vivify_2390
    new $P4697, "Undef"
  vivify_2390:
    find_lex $P4698, "$inv"
    unless_null $P4698, vivify_2391
    new $P4698, "Undef"
  vivify_2391:
    $P4697."push"($P4698)
.annotate 'line', 1609
    find_lex $P4699, "$BLOCKINIT"
    unless_null $P4699, vivify_2392
    new $P4699, "Undef"
  vivify_2392:
    get_hll_global $P4700, "GLOBAL"
    nqp_get_package_through_who $P4701, $P4700, "PAST"
    get_who $P4702, $P4701
    set $P4703, $P4702["Var"]
.annotate 'line', 1611
    get_hll_global $P4704, "GLOBAL"
    nqp_get_package_through_who $P4705, $P4704, "PAST"
    get_who $P4706, $P4705
    set $P4707, $P4706["Var"]
    find_lex $P4708, "$inv"
    unless_null $P4708, vivify_2393
    new $P4708, "Undef"
  vivify_2393:
    $P4709 = $P4708."name"()
    $P4710 = $P4707."new"("lexical" :named("scope"), $P4709 :named("name"))
    $P4711 = $P4703."new"("self" :named("name"), "lexical" :named("scope"), 1 :named("isdecl"), $P4710 :named("viviself"))
.annotate 'line', 1609
    $P4699."push"($P4711)
.annotate 'line', 1613
    new $P4712, "Integer"
    assign $P4712, 1
    find_lex $P4713, "$?PACKAGE"
    get_who $P4714, $P4713
    set $P4715, $P4714["@BLOCK"]
    unless_null $P4715, vivify_2394
    $P4715 = root_new ['parrot';'ResizablePMCArray']
    set $P4714["@BLOCK"], $P4715
  vivify_2394:
    set $P4716, $P4715[0]
    unless_null $P4716, vivify_2395
    $P4716 = root_new ['parrot';'Hash']
    set $P4715[0], $P4716
  vivify_2395:
    set $P4716["signature_has_invocant"], $P4712
.annotate 'line', 1606
    .return ($P4712)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4722"  :anon :subid("519_1304456155.152") :outer("517_1304456155.152")
    .param pmc param_4724
.annotate 'line', 1615
    .lex "$_", param_4724
    find_lex $P4725, "$BLOCKINIT"
    unless_null $P4725, vivify_2399
    new $P4725, "Undef"
  vivify_2399:
    find_lex $P4726, "$_"
    unless_null $P4726, vivify_2400
    new $P4726, "Undef"
  vivify_2400:
    $P4727 = $P4726."ast"()
    $P4728 = $P4725."push"($P4727)
    .return ($P4728)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "parameter"  :subid("520_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_4733
    .param pmc param_4734
.annotate 'line', 1618
    .lex "self", param_4733
    .lex "$/", param_4734
.annotate 'line', 1619
    new $P4735, "Undef"
    .lex "$quant", $P4735
.annotate 'line', 1620
    new $P4736, "Undef"
    .lex "$past", $P4736
.annotate 'line', 1619
    find_lex $P4737, "$/"
    unless_null $P4737, vivify_2401
    $P4737 = root_new ['parrot';'Hash']
  vivify_2401:
    set $P4738, $P4737["quant"]
    unless_null $P4738, vivify_2402
    new $P4738, "Undef"
  vivify_2402:
    store_lex "$quant", $P4738
    find_lex $P4739, "$past"
    unless_null $P4739, vivify_2403
    new $P4739, "Undef"
  vivify_2403:
.annotate 'line', 1621
    find_lex $P4741, "$/"
    unless_null $P4741, vivify_2404
    $P4741 = root_new ['parrot';'Hash']
  vivify_2404:
    set $P4742, $P4741["named_param"]
    unless_null $P4742, vivify_2405
    new $P4742, "Undef"
  vivify_2405:
    if $P4742, if_4740
.annotate 'line', 1628
    find_lex $P4756, "$/"
    unless_null $P4756, vivify_2406
    $P4756 = root_new ['parrot';'Hash']
  vivify_2406:
    set $P4757, $P4756["param_var"]
    unless_null $P4757, vivify_2407
    new $P4757, "Undef"
  vivify_2407:
    $P4758 = $P4757."ast"()
    store_lex "$past", $P4758
.annotate 'line', 1629
    find_lex $P4760, "$quant"
    unless_null $P4760, vivify_2408
    new $P4760, "Undef"
  vivify_2408:
    set $S4761, $P4760
    iseq $I4762, $S4761, "*"
    if $I4762, if_4759
.annotate 'line', 1633
    find_lex $P4771, "$quant"
    unless_null $P4771, vivify_2409
    new $P4771, "Undef"
  vivify_2409:
    set $S4772, $P4771
    iseq $I4773, $S4772, "?"
    unless $I4773, if_4770_end
.annotate 'line', 1634
    find_lex $P4774, "$past"
    unless_null $P4774, vivify_2410
    new $P4774, "Undef"
  vivify_2410:
    find_lex $P4775, "$/"
    unless_null $P4775, vivify_2411
    $P4775 = root_new ['parrot';'Hash']
  vivify_2411:
    set $P4776, $P4775["param_var"]
    unless_null $P4776, vivify_2412
    $P4776 = root_new ['parrot';'Hash']
  vivify_2412:
    set $P4777, $P4776["sigil"]
    unless_null $P4777, vivify_2413
    new $P4777, "Undef"
  vivify_2413:
    $P4778 = "vivitype"($P4777)
    $P4774."viviself"($P4778)
  if_4770_end:
.annotate 'line', 1633
    goto if_4759_end
  if_4759:
.annotate 'line', 1630
    find_lex $P4763, "$past"
    unless_null $P4763, vivify_2414
    new $P4763, "Undef"
  vivify_2414:
    $P4763."slurpy"(1)
.annotate 'line', 1631
    find_lex $P4764, "$past"
    unless_null $P4764, vivify_2415
    new $P4764, "Undef"
  vivify_2415:
    find_lex $P4765, "$/"
    unless_null $P4765, vivify_2416
    $P4765 = root_new ['parrot';'Hash']
  vivify_2416:
    set $P4766, $P4765["param_var"]
    unless_null $P4766, vivify_2417
    $P4766 = root_new ['parrot';'Hash']
  vivify_2417:
    set $P4767, $P4766["sigil"]
    unless_null $P4767, vivify_2418
    new $P4767, "Undef"
  vivify_2418:
    set $S4768, $P4767
    iseq $I4769, $S4768, "%"
    $P4764."named"($I4769)
  if_4759_end:
.annotate 'line', 1627
    goto if_4740_end
  if_4740:
.annotate 'line', 1622
    find_lex $P4743, "$/"
    unless_null $P4743, vivify_2419
    $P4743 = root_new ['parrot';'Hash']
  vivify_2419:
    set $P4744, $P4743["named_param"]
    unless_null $P4744, vivify_2420
    new $P4744, "Undef"
  vivify_2420:
    $P4745 = $P4744."ast"()
    store_lex "$past", $P4745
.annotate 'line', 1623
    find_lex $P4747, "$quant"
    unless_null $P4747, vivify_2421
    new $P4747, "Undef"
  vivify_2421:
    set $S4748, $P4747
    isne $I4749, $S4748, "!"
    unless $I4749, if_4746_end
.annotate 'line', 1624
    find_lex $P4750, "$past"
    unless_null $P4750, vivify_2422
    new $P4750, "Undef"
  vivify_2422:
    find_lex $P4751, "$/"
    unless_null $P4751, vivify_2423
    $P4751 = root_new ['parrot';'Hash']
  vivify_2423:
    set $P4752, $P4751["named_param"]
    unless_null $P4752, vivify_2424
    $P4752 = root_new ['parrot';'Hash']
  vivify_2424:
    set $P4753, $P4752["param_var"]
    unless_null $P4753, vivify_2425
    $P4753 = root_new ['parrot';'Hash']
  vivify_2425:
    set $P4754, $P4753["sigil"]
    unless_null $P4754, vivify_2426
    new $P4754, "Undef"
  vivify_2426:
    $P4755 = "vivitype"($P4754)
    $P4750."viviself"($P4755)
  if_4746_end:
  if_4740_end:
.annotate 'line', 1637
    find_lex $P4780, "$/"
    unless_null $P4780, vivify_2427
    $P4780 = root_new ['parrot';'Hash']
  vivify_2427:
    set $P4781, $P4780["default_value"]
    unless_null $P4781, vivify_2428
    new $P4781, "Undef"
  vivify_2428:
    unless $P4781, if_4779_end
.annotate 'line', 1638
    find_lex $P4783, "$quant"
    unless_null $P4783, vivify_2429
    new $P4783, "Undef"
  vivify_2429:
    set $S4784, $P4783
    iseq $I4785, $S4784, "*"
    unless $I4785, if_4782_end
.annotate 'line', 1639
    find_lex $P4786, "$/"
    unless_null $P4786, vivify_2430
    new $P4786, "Undef"
  vivify_2430:
    $P4787 = $P4786."CURSOR"()
    $P4787."panic"("Can't put default on slurpy parameter")
  if_4782_end:
.annotate 'line', 1641
    find_lex $P4789, "$quant"
    unless_null $P4789, vivify_2431
    new $P4789, "Undef"
  vivify_2431:
    set $S4790, $P4789
    iseq $I4791, $S4790, "!"
    unless $I4791, if_4788_end
.annotate 'line', 1642
    find_lex $P4792, "$/"
    unless_null $P4792, vivify_2432
    new $P4792, "Undef"
  vivify_2432:
    $P4793 = $P4792."CURSOR"()
    $P4793."panic"("Can't put default on required parameter")
  if_4788_end:
.annotate 'line', 1644
    find_lex $P4794, "$past"
    unless_null $P4794, vivify_2433
    new $P4794, "Undef"
  vivify_2433:
    find_lex $P4795, "$/"
    unless_null $P4795, vivify_2434
    $P4795 = root_new ['parrot';'Hash']
  vivify_2434:
    set $P4796, $P4795["default_value"]
    unless_null $P4796, vivify_2435
    $P4796 = root_new ['parrot';'ResizablePMCArray']
  vivify_2435:
    set $P4797, $P4796[0]
    unless_null $P4797, vivify_2436
    $P4797 = root_new ['parrot';'Hash']
  vivify_2436:
    set $P4798, $P4797["EXPR"]
    unless_null $P4798, vivify_2437
    new $P4798, "Undef"
  vivify_2437:
    $P4799 = $P4798."ast"()
    $P4794."viviself"($P4799)
  if_4779_end:
.annotate 'line', 1646
    find_lex $P4801, "$past"
    unless_null $P4801, vivify_2438
    new $P4801, "Undef"
  vivify_2438:
    $P4802 = $P4801."viviself"()
    if $P4802, unless_4800_end
    find_lex $P4803, "$?PACKAGE"
    get_who $P4804, $P4803
    set $P4805, $P4804["@BLOCK"]
    unless_null $P4805, vivify_2439
    $P4805 = root_new ['parrot';'ResizablePMCArray']
  vivify_2439:
    set $P4806, $P4805[0]
    unless_null $P4806, vivify_2440
    new $P4806, "Undef"
  vivify_2440:
    find_lex $P4807, "$?PACKAGE"
    get_who $P4808, $P4807
    set $P4809, $P4808["@BLOCK"]
    unless_null $P4809, vivify_2441
    $P4809 = root_new ['parrot';'ResizablePMCArray']
  vivify_2441:
    set $P4810, $P4809[0]
    unless_null $P4810, vivify_2442
    new $P4810, "Undef"
  vivify_2442:
    $P4811 = $P4810."arity"()
    set $N4812, $P4811
    new $P4813, 'Float'
    set $P4813, $N4812
    add $P4814, $P4813, 1
    $P4806."arity"($P4814)
  unless_4800_end:
.annotate 'line', 1650
    find_lex $P4816, "$/"
    unless_null $P4816, vivify_2443
    $P4816 = root_new ['parrot';'Hash']
  vivify_2443:
    set $P4817, $P4816["typename"]
    unless_null $P4817, vivify_2444
    new $P4817, "Undef"
  vivify_2444:
    unless $P4817, if_4815_end
.annotate 'line', 1651
    find_lex $P4818, "$past"
    unless_null $P4818, vivify_2445
    new $P4818, "Undef"
  vivify_2445:
    find_lex $P4819, "$/"
    unless_null $P4819, vivify_2446
    $P4819 = root_new ['parrot';'Hash']
  vivify_2446:
    set $P4820, $P4819["typename"]
    unless_null $P4820, vivify_2447
    $P4820 = root_new ['parrot';'ResizablePMCArray']
  vivify_2447:
    set $P4821, $P4820[0]
    unless_null $P4821, vivify_2448
    new $P4821, "Undef"
  vivify_2448:
    $P4822 = $P4821."ast"()
    $P4818."multitype"($P4822)
  if_4815_end:
.annotate 'line', 1655
    find_lex $P4824, "$/"
    unless_null $P4824, vivify_2449
    $P4824 = root_new ['parrot';'Hash']
  vivify_2449:
    set $P4825, $P4824["definedness"]
    unless_null $P4825, vivify_2450
    new $P4825, "Undef"
  vivify_2450:
    unless $P4825, if_4823_end
.annotate 'line', 1656
    find_lex $P4826, "$/"
    unless_null $P4826, vivify_2451
    $P4826 = root_new ['parrot';'Hash']
  vivify_2451:
    set $P4827, $P4826["definedness"]
    unless_null $P4827, vivify_2452
    $P4827 = root_new ['parrot';'ResizablePMCArray']
  vivify_2452:
    set $P4828, $P4827[0]
    unless_null $P4828, vivify_2453
    new $P4828, "Undef"
  vivify_2453:
    set $S4829, $P4828
    new $P4830, 'String'
    set $P4830, $S4829
    find_lex $P4831, "$past"
    unless_null $P4831, vivify_2454
    $P4831 = root_new ['parrot';'Hash']
    store_lex "$past", $P4831
  vivify_2454:
    set $P4831["definedness"], $P4830
  if_4823_end:
.annotate 'line', 1659
    find_lex $P4832, "$/"
    find_lex $P4833, "$past"
    unless_null $P4833, vivify_2455
    new $P4833, "Undef"
  vivify_2455:
    $P4834 = $P4832."!make"($P4833)
.annotate 'line', 1618
    .return ($P4834)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "param_var"  :subid("521_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_4836
    .param pmc param_4837
.annotate 'line', 1662
    .lex "self", param_4836
    .lex "$/", param_4837
.annotate 'line', 1663
    new $P4838, "Undef"
    .lex "$name", $P4838
.annotate 'line', 1664
    new $P4839, "Undef"
    .lex "$past", $P4839
.annotate 'line', 1663
    find_lex $P4840, "$/"
    unless_null $P4840, vivify_2456
    new $P4840, "Undef"
  vivify_2456:
    set $S4841, $P4840
    new $P4842, 'String'
    set $P4842, $S4841
    store_lex "$name", $P4842
.annotate 'line', 1664
    get_hll_global $P4843, "GLOBAL"
    nqp_get_package_through_who $P4844, $P4843, "PAST"
    get_who $P4845, $P4844
    set $P4846, $P4845["Var"]
    find_lex $P4847, "$name"
    unless_null $P4847, vivify_2457
    new $P4847, "Undef"
  vivify_2457:
    find_lex $P4848, "$/"
    unless_null $P4848, vivify_2458
    new $P4848, "Undef"
  vivify_2458:
    $P4849 = $P4846."new"($P4847 :named("name"), "parameter" :named("scope"), 1 :named("isdecl"), $P4848 :named("node"))
    store_lex "$past", $P4849
.annotate 'line', 1666
    find_lex $P4850, "$?PACKAGE"
    get_who $P4851, $P4850
    set $P4852, $P4851["@BLOCK"]
    unless_null $P4852, vivify_2459
    $P4852 = root_new ['parrot';'ResizablePMCArray']
  vivify_2459:
    set $P4853, $P4852[0]
    unless_null $P4853, vivify_2460
    new $P4853, "Undef"
  vivify_2460:
    find_lex $P4854, "$name"
    unless_null $P4854, vivify_2461
    new $P4854, "Undef"
  vivify_2461:
    $P4853."symbol"($P4854, "lexical" :named("scope"))
.annotate 'line', 1667
    find_lex $P4855, "$/"
    find_lex $P4856, "$past"
    unless_null $P4856, vivify_2462
    new $P4856, "Undef"
  vivify_2462:
    $P4857 = $P4855."!make"($P4856)
.annotate 'line', 1662
    .return ($P4857)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "named_param"  :subid("522_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_4859
    .param pmc param_4860
.annotate 'line', 1670
    .lex "self", param_4859
    .lex "$/", param_4860
.annotate 'line', 1671
    new $P4861, "Undef"
    .lex "$past", $P4861
    find_lex $P4862, "$/"
    unless_null $P4862, vivify_2463
    $P4862 = root_new ['parrot';'Hash']
  vivify_2463:
    set $P4863, $P4862["param_var"]
    unless_null $P4863, vivify_2464
    new $P4863, "Undef"
  vivify_2464:
    $P4864 = $P4863."ast"()
    store_lex "$past", $P4864
.annotate 'line', 1672
    find_lex $P4865, "$past"
    unless_null $P4865, vivify_2465
    new $P4865, "Undef"
  vivify_2465:
    find_lex $P4866, "$/"
    unless_null $P4866, vivify_2466
    $P4866 = root_new ['parrot';'Hash']
  vivify_2466:
    set $P4867, $P4866["param_var"]
    unless_null $P4867, vivify_2467
    $P4867 = root_new ['parrot';'Hash']
  vivify_2467:
    set $P4868, $P4867["name"]
    unless_null $P4868, vivify_2468
    new $P4868, "Undef"
  vivify_2468:
    set $S4869, $P4868
    $P4865."named"($S4869)
.annotate 'line', 1673
    find_lex $P4870, "$/"
    find_lex $P4871, "$past"
    unless_null $P4871, vivify_2469
    new $P4871, "Undef"
  vivify_2469:
    $P4872 = $P4870."!make"($P4871)
.annotate 'line', 1670
    .return ($P4872)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "typename"  :subid("523_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_4874
    .param pmc param_4875
.annotate 'line', 1676
    .const 'Sub' $P4887 = "524_1304456155.152" 
    capture_lex $P4887
    .lex "self", param_4874
    .lex "$/", param_4875
.annotate 'line', 1680
    $P4876 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P4876
.annotate 'line', 1681
    new $P4877, "Undef"
    .lex "$found", $P4877
.annotate 'line', 1680
    get_hll_global $P4878, "GLOBAL"
    nqp_get_package_through_who $P4879, $P4878, "HLL"
    get_who $P4880, $P4879
    set $P4881, $P4880["Compiler"]
    find_lex $P4882, "$/"
    unless_null $P4882, vivify_2470
    new $P4882, "Undef"
  vivify_2470:
    set $S4883, $P4882
    $P4884 = $P4881."parse_name"($S4883)
    store_lex "@name", $P4884
.annotate 'line', 1681
    new $P4885, "Integer"
    assign $P4885, 0
    store_lex "$found", $P4885
.annotate 'line', 1682
    .const 'Sub' $P4887 = "524_1304456155.152" 
    capture_lex $P4887
    $P4887()
.annotate 'line', 1687
    find_lex $P4908, "$found"
    unless_null $P4908, vivify_2476
    new $P4908, "Undef"
  vivify_2476:
    unless $P4908, unless_4907
    set $P4906, $P4908
    goto unless_4907_end
  unless_4907:
.annotate 'line', 1688
    find_lex $P4909, "$/"
    unless_null $P4909, vivify_2477
    new $P4909, "Undef"
  vivify_2477:
    $P4910 = $P4909."CURSOR"()
    new $P4911, "String"
    assign $P4911, "Use of undeclared type '"
    find_lex $P4912, "$/"
    unless_null $P4912, vivify_2478
    new $P4912, "Undef"
  vivify_2478:
    set $S4913, $P4912
    concat $P4914, $P4911, $S4913
    concat $P4915, $P4914, "'"
    $P4916 = $P4910."panic"($P4915)
.annotate 'line', 1687
    set $P4906, $P4916
  unless_4907_end:
.annotate 'line', 1676
    .return ($P4906)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block4886"  :anon :subid("524_1304456155.152") :outer("523_1304456155.152")
.annotate 'line', 1682
    new $P4901, 'ExceptionHandler'
    set_label $P4901, control_4900
    $P4901."handle_types_except"(.CONTROL_RETURN,  .CONTROL_OK,  .CONTROL_BREAK,  .CONTROL_CONTINUE,  .CONTROL_TAKE,  .CONTROL_LEAVE,  .CONTROL_EXIT,  .CONTROL_LOOP_NEXT,  .CONTROL_LOOP_LAST,  .CONTROL_LOOP_REDO)
    push_eh $P4901
.annotate 'line', 1683
    new $P4888, "Undef"
    .lex "$sym", $P4888
    find_lex $P4889, "@name"
    unless_null $P4889, vivify_2471
    $P4889 = root_new ['parrot';'ResizablePMCArray']
  vivify_2471:
    find_lex $P4890, "$/"
    unless_null $P4890, vivify_2472
    new $P4890, "Undef"
  vivify_2472:
    $P4891 = "find_sym"($P4889, $P4890)
    store_lex "$sym", $P4891
.annotate 'line', 1684
    find_dynamic_lex $P4892, "$/"
    find_dynamic_lex $P4895, "$*SC"
    unless_null $P4895, vivify_2473
    get_hll_global $P4893, "GLOBAL"
    get_who $P4894, $P4893
    set $P4895, $P4894["$SC"]
    unless_null $P4895, vivify_2474
    die "Contextual $*SC not found"
  vivify_2474:
  vivify_2473:
    find_lex $P4896, "$sym"
    unless_null $P4896, vivify_2475
    new $P4896, "Undef"
  vivify_2475:
    $P4897 = $P4895."get_object_sc_ref_past"($P4896)
    $P4892."!make"($P4897)
.annotate 'line', 1685
    new $P4898, "Integer"
    assign $P4898, 1
    store_lex "$found", $P4898
.annotate 'line', 1682
    pop_eh 
    goto skip_handler_4899
  control_4900:
    .local pmc exception 
    .get_results (exception) 
    new $P4904, 'Integer'
    set $P4904, 1
    set exception["handled"], $P4904
    set $I4905, exception["handled"]
    ne $I4905, 1, nothandled_4903
  handled_4902:
    .return (exception)
  nothandled_4903:
    rethrow exception
  skip_handler_4899:
    .return ($P4898)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait"  :subid("525_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_4918
    .param pmc param_4919
.annotate 'line', 1692
    .lex "self", param_4918
    .lex "$/", param_4919
.annotate 'line', 1693
    find_lex $P4920, "$/"
    find_lex $P4921, "$/"
    unless_null $P4921, vivify_2479
    $P4921 = root_new ['parrot';'Hash']
  vivify_2479:
    set $P4922, $P4921["trait_mod"]
    unless_null $P4922, vivify_2480
    new $P4922, "Undef"
  vivify_2480:
    $P4923 = $P4922."ast"()
    $P4924 = $P4920."!make"($P4923)
.annotate 'line', 1692
    .return ($P4924)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait_mod:sym<is>"  :subid("526_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_4926
    .param pmc param_4927
.annotate 'line', 1696
    .const 'Sub' $P4935 = "527_1304456155.152" 
    capture_lex $P4935
    .lex "self", param_4926
    .lex "$/", param_4927
.annotate 'line', 1697
    find_lex $P4930, "$/"
    unless_null $P4930, vivify_2481
    $P4930 = root_new ['parrot';'Hash']
  vivify_2481:
    set $P4931, $P4930["longname"]
    unless_null $P4931, vivify_2482
    new $P4931, "Undef"
  vivify_2482:
    set $S4932, $P4931
    iseq $I4933, $S4932, "parrot_vtable"
    if $I4933, if_4929
.annotate 'line', 1710
    find_lex $P4983, "$/"
    unless_null $P4983, vivify_2483
    $P4983 = root_new ['parrot';'Hash']
  vivify_2483:
    set $P4984, $P4983["longname"]
    unless_null $P4984, vivify_2484
    new $P4984, "Undef"
  vivify_2484:
    set $S4985, $P4984
    iseq $I4986, $S4985, "pirflags"
    if $I4986, if_4982
.annotate 'line', 1714
    find_lex $P4990, "$/"
    unless_null $P4990, vivify_2485
    new $P4990, "Undef"
  vivify_2485:
    $P4991 = $P4990."CURSOR"()
    new $P4992, 'String'
    set $P4992, "Trait '"
    find_lex $P4993, "$/"
    unless_null $P4993, vivify_2486
    $P4993 = root_new ['parrot';'Hash']
  vivify_2486:
    set $P4994, $P4993["longname"]
    unless_null $P4994, vivify_2487
    new $P4994, "Undef"
  vivify_2487:
    concat $P4995, $P4992, $P4994
    concat $P4996, $P4995, "' not implemented"
    $P4997 = $P4991."panic"($P4996)
.annotate 'line', 1713
    set $P4981, $P4997
.annotate 'line', 1710
    goto if_4982_end
  if_4982:
.annotate 'line', 1711
    find_lex $P4987, "$/"
    unless_null $P4987, vivify_2488
    new $P4987, "Undef"
  vivify_2488:
    $P4988 = $P4987."CURSOR"()
    $P4989 = $P4988."panic"("Trait 'pirflags' no longer supported; use 'is vtable'")
.annotate 'line', 1710
    set $P4981, $P4989
  if_4982_end:
    set $P4928, $P4981
.annotate 'line', 1697
    goto if_4929_end
  if_4929:
    .const 'Sub' $P4935 = "527_1304456155.152" 
    capture_lex $P4935
    $P4980 = $P4935()
    set $P4928, $P4980
  if_4929_end:
.annotate 'line', 1696
    .return ($P4928)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4934"  :anon :subid("527_1304456155.152") :outer("526_1304456155.152")
.annotate 'line', 1697
    .const 'Sub' $P4966 = "528_1304456155.152" 
    capture_lex $P4966
.annotate 'line', 1699
    new $P4936, "Undef"
    .lex "$cpast", $P4936
.annotate 'line', 1702
    new $P4937, "Undef"
    .lex "$name", $P4937
.annotate 'line', 1703
    new $P4938, "Undef"
    .lex "$package", $P4938
.annotate 'line', 1704
    new $P4939, "Undef"
    .lex "$is_dispatcher", $P4939
.annotate 'line', 1699
    find_lex $P4940, "$/"
    unless_null $P4940, vivify_2489
    $P4940 = root_new ['parrot';'Hash']
  vivify_2489:
    set $P4941, $P4940["circumfix"]
    unless_null $P4941, vivify_2490
    $P4941 = root_new ['parrot';'ResizablePMCArray']
  vivify_2490:
    set $P4942, $P4941[0]
    unless_null $P4942, vivify_2491
    new $P4942, "Undef"
  vivify_2491:
    $P4943 = $P4942."ast"()
    store_lex "$cpast", $P4943
.annotate 'line', 1701
    get_hll_global $P4945, "GLOBAL"
    nqp_get_package_through_who $P4946, $P4945, "PAST"
    get_who $P4947, $P4946
    set $P4948, $P4947["Val"]
    find_lex $P4949, "$cpast"
    unless_null $P4949, vivify_2492
    new $P4949, "Undef"
  vivify_2492:
    $P4950 = $P4948."ACCEPTS"($P4949)
    if $P4950, unless_4944_end
.annotate 'line', 1700
    find_lex $P4951, "$/"
    unless_null $P4951, vivify_2493
    new $P4951, "Undef"
  vivify_2493:
    $P4952 = $P4951."CURSOR"()
    $P4952."panic"("Trait 'parrot_vtable' requires constant scalar argument")
  unless_4944_end:
.annotate 'line', 1702
    find_lex $P4953, "$cpast"
    unless_null $P4953, vivify_2494
    new $P4953, "Undef"
  vivify_2494:
    $P4954 = $P4953."value"()
    store_lex "$name", $P4954
.annotate 'line', 1703
    find_dynamic_lex $P4957, "$*PACKAGE"
    unless_null $P4957, vivify_2495
    get_hll_global $P4955, "GLOBAL"
    get_who $P4956, $P4955
    set $P4957, $P4956["$PACKAGE"]
    unless_null $P4957, vivify_2496
    die "Contextual $*PACKAGE not found"
  vivify_2496:
  vivify_2495:
    store_lex "$package", $P4957
.annotate 'line', 1704
    find_dynamic_lex $P4960, "$*SCOPE"
    unless_null $P4960, vivify_2497
    get_hll_global $P4958, "GLOBAL"
    get_who $P4959, $P4958
    set $P4960, $P4959["$SCOPE"]
    unless_null $P4960, vivify_2498
    die "Contextual $*SCOPE not found"
  vivify_2498:
  vivify_2497:
    set $S4961, $P4960
    iseq $I4962, $S4961, "proto"
    new $P4963, 'Integer'
    set $P4963, $I4962
    store_lex "$is_dispatcher", $P4963
.annotate 'line', 1705
    find_dynamic_lex $P4964, "$/"
    .const 'Sub' $P4966 = "528_1304456155.152" 
    newclosure $P4978, $P4966
    $P4979 = $P4964."!make"($P4978)
.annotate 'line', 1697
    .return ($P4979)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4965"  :anon :subid("528_1304456155.152") :outer("527_1304456155.152")
    .param pmc param_4967
.annotate 'line', 1705
    .lex "$match", param_4967
.annotate 'line', 1706
    find_dynamic_lex $P4970, "$*SC"
    unless_null $P4970, vivify_2499
    get_hll_global $P4968, "GLOBAL"
    get_who $P4969, $P4968
    set $P4970, $P4969["$SC"]
    unless_null $P4970, vivify_2500
    die "Contextual $*SC not found"
  vivify_2500:
  vivify_2499:
    find_lex $P4971, "$package"
    unless_null $P4971, vivify_2501
    new $P4971, "Undef"
  vivify_2501:
    find_lex $P4972, "$name"
    unless_null $P4972, vivify_2502
    new $P4972, "Undef"
  vivify_2502:
.annotate 'line', 1707
    find_lex $P4973, "$match"
    unless_null $P4973, vivify_2503
    new $P4973, "Undef"
  vivify_2503:
    $P4974 = $P4973."ast"()
    set $P4975, $P4974["block_past"]
    unless_null $P4975, vivify_2504
    new $P4975, "Undef"
  vivify_2504:
.annotate 'line', 1706
    find_lex $P4976, "$is_dispatcher"
    unless_null $P4976, vivify_2505
    new $P4976, "Undef"
  vivify_2505:
    $P4977 = $P4970."pkg_add_method"($P4971, "add_parrot_vtable_mapping", $P4972, $P4975, $P4976)
.annotate 'line', 1705
    .return ($P4977)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "regex_declarator"  :subid("529_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_5001
    .param pmc param_5002
    .param pmc param_5003 :optional
    .param int has_param_5003 :opt_flag
.annotate 'line', 1718
    .const 'Sub' $P5130 = "532_1304456155.152" 
    capture_lex $P5130
    .const 'Sub' $P5092 = "531_1304456155.152" 
    capture_lex $P5092
    .const 'Sub' $P5072 = "530_1304456155.152" 
    capture_lex $P5072
    new $P5000, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P5000, control_4999
    push_eh $P5000
    .lex "self", param_5001
    .lex "$/", param_5002
    if has_param_5003, optparam_2506
    new $P5004, "Undef"
    set param_5003, $P5004
  optparam_2506:
    .lex "$key", param_5003
.annotate 'line', 1719
    $P5005 = root_new ['parrot';'ResizablePMCArray']
    .lex "@MODIFIERS", $P5005
.annotate 'line', 1720
    new $P5006, "Undef"
    .lex "$name", $P5006
.annotate 'line', 1721
    new $P5007, "Undef"
    .lex "$past", $P5007
.annotate 'line', 1719
    get_hll_global $P5008, "GLOBAL"
    nqp_get_package_through_who $P5009, $P5008, "Regex"
    nqp_get_package_through_who $P5010, $P5009, "P6Regex"
    nqp_get_package_through_who $P5011, $P5010, "Actions"
    get_who $P5012, $P5011
    set $P5013, $P5012["@MODIFIERS"]
    unless_null $P5013, vivify_2507
    $P5013 = root_new ['parrot';'ResizablePMCArray']
  vivify_2507:
    store_lex "@MODIFIERS", $P5013
.annotate 'line', 1720
    find_lex $P5014, "$/"
    unless_null $P5014, vivify_2508
    $P5014 = root_new ['parrot';'Hash']
  vivify_2508:
    set $P5015, $P5014["deflongname"]
    unless_null $P5015, vivify_2509
    new $P5015, "Undef"
  vivify_2509:
    $P5016 = $P5015."ast"()
    set $S5017, $P5016
    new $P5018, 'String'
    set $P5018, $S5017
    store_lex "$name", $P5018
    find_lex $P5019, "$past"
    unless_null $P5019, vivify_2510
    new $P5019, "Undef"
  vivify_2510:
.annotate 'line', 1722
    find_lex $P5021, "$/"
    unless_null $P5021, vivify_2511
    $P5021 = root_new ['parrot';'Hash']
  vivify_2511:
    set $P5022, $P5021["proto"]
    unless_null $P5022, vivify_2512
    new $P5022, "Undef"
  vivify_2512:
    if $P5022, if_5020
.annotate 'line', 1752
    find_lex $P5088, "$key"
    unless_null $P5088, vivify_2513
    new $P5088, "Undef"
  vivify_2513:
    set $S5089, $P5088
    iseq $I5090, $S5089, "open"
    if $I5090, if_5087
.annotate 'line', 1762
    .const 'Sub' $P5130 = "532_1304456155.152" 
    capture_lex $P5130
    $P5130()
    goto if_5087_end
  if_5087:
.annotate 'line', 1752
    .const 'Sub' $P5092 = "531_1304456155.152" 
    capture_lex $P5092
    $P5092()
  if_5087_end:
    goto if_5020_end
  if_5020:
.annotate 'line', 1724
    get_hll_global $P5023, "GLOBAL"
    nqp_get_package_through_who $P5024, $P5023, "PAST"
    get_who $P5025, $P5024
    set $P5026, $P5025["Stmts"]
.annotate 'line', 1725
    get_hll_global $P5027, "GLOBAL"
    nqp_get_package_through_who $P5028, $P5027, "PAST"
    get_who $P5029, $P5028
    set $P5030, $P5029["Block"]
    find_lex $P5031, "$name"
    unless_null $P5031, vivify_2563
    new $P5031, "Undef"
  vivify_2563:
.annotate 'line', 1726
    get_hll_global $P5032, "GLOBAL"
    nqp_get_package_through_who $P5033, $P5032, "PAST"
    get_who $P5034, $P5033
    set $P5035, $P5034["Op"]
.annotate 'line', 1727
    get_hll_global $P5036, "GLOBAL"
    nqp_get_package_through_who $P5037, $P5036, "PAST"
    get_who $P5038, $P5037
    set $P5039, $P5038["Var"]
    $P5040 = $P5039."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P5041, "$name"
    unless_null $P5041, vivify_2564
    new $P5041, "Undef"
  vivify_2564:
    $P5042 = $P5035."new"($P5040, $P5041, "!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 1726
    find_lex $P5043, "$/"
    unless_null $P5043, vivify_2565
    new $P5043, "Undef"
  vivify_2565:
    $P5044 = $P5030."new"($P5042, $P5031 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P5043 :named("node"))
.annotate 'line', 1736
    get_hll_global $P5045, "GLOBAL"
    nqp_get_package_through_who $P5046, $P5045, "PAST"
    get_who $P5047, $P5046
    set $P5048, $P5047["Block"]
    new $P5049, "String"
    assign $P5049, "!PREFIX__"
    find_lex $P5050, "$name"
    unless_null $P5050, vivify_2566
    new $P5050, "Undef"
  vivify_2566:
    concat $P5051, $P5049, $P5050
.annotate 'line', 1737
    get_hll_global $P5052, "GLOBAL"
    nqp_get_package_through_who $P5053, $P5052, "PAST"
    get_who $P5054, $P5053
    set $P5055, $P5054["Op"]
.annotate 'line', 1738
    get_hll_global $P5056, "GLOBAL"
    nqp_get_package_through_who $P5057, $P5056, "PAST"
    get_who $P5058, $P5057
    set $P5059, $P5058["Var"]
    $P5060 = $P5059."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P5061, "$name"
    unless_null $P5061, vivify_2567
    new $P5061, "Undef"
  vivify_2567:
    $P5062 = $P5055."new"($P5060, $P5061, "!PREFIX__!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 1737
    find_lex $P5063, "$/"
    unless_null $P5063, vivify_2568
    new $P5063, "Undef"
  vivify_2568:
    $P5064 = $P5048."new"($P5062, $P5051 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P5063 :named("node"))
.annotate 'line', 1736
    $P5065 = $P5026."new"($P5044, $P5064)
.annotate 'line', 1724
    store_lex "$past", $P5065
.annotate 'line', 1748
    find_lex $P5067, "$past"
    unless_null $P5067, vivify_2569
    new $P5067, "Undef"
  vivify_2569:
    $P5068 = $P5067."list"()
    defined $I5069, $P5068
    unless $I5069, for_undef_2570
    iter $P5066, $P5068
    new $P5085, 'ExceptionHandler'
    set_label $P5085, loop5084_handler
    $P5085."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5085
  loop5084_test:
    unless $P5066, loop5084_done
    shift $P5070, $P5066
  loop5084_redo:
    .const 'Sub' $P5072 = "530_1304456155.152" 
    capture_lex $P5072
    $P5072($P5070)
  loop5084_next:
    goto loop5084_test
  loop5084_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5086, exception, 'type'
    eq $P5086, .CONTROL_LOOP_NEXT, loop5084_next
    eq $P5086, .CONTROL_LOOP_REDO, loop5084_redo
  loop5084_done:
    pop_eh 
  for_undef_2570:
  if_5020_end:
.annotate 'line', 1793
    find_lex $P5223, "$/"
    find_lex $P5224, "$past"
    unless_null $P5224, vivify_2577
    new $P5224, "Undef"
  vivify_2577:
    $P5225 = $P5223."!make"($P5224)
.annotate 'line', 1718
    .return ($P5225)
  control_4999:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5226, exception, "payload"
    .return ($P5226)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5129"  :anon :subid("532_1304456155.152") :outer("529_1304456155.152")
.annotate 'line', 1762
    .const 'Sub' $P5162 = "533_1304456155.152" 
    capture_lex $P5162
.annotate 'line', 1763
    new $P5131, "Undef"
    .lex "$regex", $P5131
.annotate 'line', 1766
    new $P5132, "Undef"
    .lex "$prefix_meth", $P5132
.annotate 'line', 1764
    get_hll_global $P5133, "GLOBAL"
    nqp_get_package_through_who $P5134, $P5133, "Regex"
    nqp_get_package_through_who $P5135, $P5134, "P6Regex"
    nqp_get_package_through_who $P5136, $P5135, "Actions"
    get_who $P5137, $P5136
    set $P5138, $P5137["buildsub"]
    find_lex $P5139, "$/"
    unless_null $P5139, vivify_2514
    $P5139 = root_new ['parrot';'Hash']
  vivify_2514:
    set $P5140, $P5139["p6regex"]
    unless_null $P5140, vivify_2515
    new $P5140, "Undef"
  vivify_2515:
    $P5141 = $P5140."ast"()
    find_lex $P5142, "$?PACKAGE"
    get_who $P5143, $P5142
    set $P5144, $P5143["@BLOCK"]
    unless_null $P5144, vivify_2516
    $P5144 = root_new ['parrot';'ResizablePMCArray']
  vivify_2516:
    $P5145 = $P5144."shift"()
    $P5146 = $P5138($P5141, $P5145)
    store_lex "$regex", $P5146
.annotate 'line', 1765
    find_lex $P5147, "$regex"
    unless_null $P5147, vivify_2517
    new $P5147, "Undef"
  vivify_2517:
    find_lex $P5148, "$name"
    unless_null $P5148, vivify_2518
    new $P5148, "Undef"
  vivify_2518:
    $P5147."name"($P5148)
    find_lex $P5149, "$prefix_meth"
    unless_null $P5149, vivify_2519
    new $P5149, "Undef"
  vivify_2519:
.annotate 'line', 1768
    find_dynamic_lex $P5155, "$*PKGDECL"
    unless_null $P5155, vivify_2520
    get_hll_global $P5153, "GLOBAL"
    get_who $P5154, $P5153
    set $P5155, $P5154["$PKGDECL"]
    unless_null $P5155, vivify_2521
    die "Contextual $*PKGDECL not found"
  vivify_2521:
  vivify_2520:
    if $P5155, if_5152
    set $P5151, $P5155
    goto if_5152_end
  if_5152:
    find_dynamic_lex $P5158, "$*PACKAGE"
    unless_null $P5158, vivify_2522
    get_hll_global $P5156, "GLOBAL"
    get_who $P5157, $P5156
    set $P5158, $P5157["$PACKAGE"]
    unless_null $P5158, vivify_2523
    die "Contextual $*PACKAGE not found"
  vivify_2523:
  vivify_2522:
    get_how $P5159, $P5158
    can $I5160, $P5159, "add_method"
    new $P5151, 'Integer'
    set $P5151, $I5160
  if_5152_end:
    unless $P5151, if_5150_end
    .const 'Sub' $P5162 = "533_1304456155.152" 
    capture_lex $P5162
    $P5162()
  if_5150_end:
.annotate 'line', 1783
    get_hll_global $P5200, "GLOBAL"
    nqp_get_package_through_who $P5201, $P5200, "PAST"
    get_who $P5202, $P5201
    set $P5203, $P5202["Op"]
.annotate 'line', 1785
    new $P5204, "ResizablePMCArray"
    push $P5204, "Regex"
    push $P5204, "Method"
    find_lex $P5205, "$/"
    unless_null $P5205, vivify_2540
    new $P5205, "Undef"
  vivify_2540:
    $P5206 = "lexical_package_lookup"($P5204, $P5205)
    find_lex $P5207, "$regex"
    unless_null $P5207, vivify_2541
    new $P5207, "Undef"
  vivify_2541:
    $P5208 = $P5203."new"($P5206, $P5207, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 1783
    store_lex "$past", $P5208
.annotate 'line', 1788
    find_lex $P5211, "$prefix_meth"
    unless_null $P5211, vivify_2542
    new $P5211, "Undef"
  vivify_2542:
    if $P5211, if_5210
    find_lex $P5219, "$regex"
    unless_null $P5219, vivify_2543
    new $P5219, "Undef"
  vivify_2543:
    set $P5209, $P5219
    goto if_5210_end
  if_5210:
.annotate 'line', 1789
    get_hll_global $P5212, "GLOBAL"
    nqp_get_package_through_who $P5213, $P5212, "PAST"
    get_who $P5214, $P5213
    set $P5215, $P5214["Stmts"]
    find_lex $P5216, "$regex"
    unless_null $P5216, vivify_2544
    new $P5216, "Undef"
  vivify_2544:
    find_lex $P5217, "$prefix_meth"
    unless_null $P5217, vivify_2545
    new $P5217, "Undef"
  vivify_2545:
    $P5218 = $P5215."new"($P5216, $P5217)
    set $P5209, $P5218
  if_5210_end:
.annotate 'line', 1788
    find_lex $P5220, "$past"
    unless_null $P5220, vivify_2546
    $P5220 = root_new ['parrot';'Hash']
    store_lex "$past", $P5220
  vivify_2546:
    set $P5220["sink"], $P5209
.annotate 'line', 1791
    find_lex $P5221, "@MODIFIERS"
    unless_null $P5221, vivify_2547
    $P5221 = root_new ['parrot';'ResizablePMCArray']
  vivify_2547:
    $P5222 = $P5221."shift"()
.annotate 'line', 1762
    .return ($P5222)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5161"  :anon :subid("533_1304456155.152") :outer("532_1304456155.152")
.annotate 'line', 1773
    $P5163 = root_new ['parrot';'ResizablePMCArray']
    .lex "@prefixes", $P5163
.annotate 'line', 1770
    find_dynamic_lex $P5166, "$*SC"
    unless_null $P5166, vivify_2524
    get_hll_global $P5164, "GLOBAL"
    get_who $P5165, $P5164
    set $P5166, $P5165["$SC"]
    unless_null $P5166, vivify_2525
    die "Contextual $*SC not found"
  vivify_2525:
  vivify_2524:
    find_dynamic_lex $P5169, "$*PACKAGE"
    unless_null $P5169, vivify_2526
    get_hll_global $P5167, "GLOBAL"
    get_who $P5168, $P5167
    set $P5169, $P5168["$PACKAGE"]
    unless_null $P5169, vivify_2527
    die "Contextual $*PACKAGE not found"
  vivify_2527:
  vivify_2526:
    find_lex $P5170, "$name"
    unless_null $P5170, vivify_2528
    new $P5170, "Undef"
  vivify_2528:
    find_lex $P5171, "$regex"
    unless_null $P5171, vivify_2529
    new $P5171, "Undef"
  vivify_2529:
    $P5166."pkg_add_method"($P5169, "add_method", $P5170, $P5171, 0)
.annotate 'line', 1773
    find_lex $P5172, "$/"
    unless_null $P5172, vivify_2530
    $P5172 = root_new ['parrot';'Hash']
  vivify_2530:
    set $P5173, $P5172["p6regex"]
    unless_null $P5173, vivify_2531
    new $P5173, "Undef"
  vivify_2531:
    $P5174 = $P5173."ast"()
    $P5175 = $P5174."prefix_list"()
    store_lex "@prefixes", $P5175
.annotate 'line', 1774
    get_hll_global $P5176, "GLOBAL"
    nqp_get_package_through_who $P5177, $P5176, "PAST"
    get_who $P5178, $P5177
    set $P5179, $P5178["Block"]
.annotate 'line', 1775
    new $P5180, "String"
    assign $P5180, "!PREFIX__"
    find_lex $P5181, "$name"
    unless_null $P5181, vivify_2532
    new $P5181, "Undef"
  vivify_2532:
    concat $P5182, $P5180, $P5181
.annotate 'line', 1776
    get_hll_global $P5183, "GLOBAL"
    nqp_get_package_through_who $P5184, $P5183, "PAST"
    get_who $P5185, $P5184
    set $P5186, $P5185["Op"]
    find_lex $P5187, "@prefixes"
    unless_null $P5187, vivify_2533
    $P5187 = root_new ['parrot';'ResizablePMCArray']
  vivify_2533:
    $P5188 = $P5186."new"($P5187 :flat, "list" :named("pasttype"))
    $P5189 = $P5179."new"($P5188, $P5182 :named("name"), "method" :named("blocktype"))
.annotate 'line', 1774
    store_lex "$prefix_meth", $P5189
.annotate 'line', 1778
    find_dynamic_lex $P5192, "$*SC"
    unless_null $P5192, vivify_2534
    get_hll_global $P5190, "GLOBAL"
    get_who $P5191, $P5190
    set $P5192, $P5191["$SC"]
    unless_null $P5192, vivify_2535
    die "Contextual $*SC not found"
  vivify_2535:
  vivify_2534:
    find_dynamic_lex $P5195, "$*PACKAGE"
    unless_null $P5195, vivify_2536
    get_hll_global $P5193, "GLOBAL"
    get_who $P5194, $P5193
    set $P5195, $P5194["$PACKAGE"]
    unless_null $P5195, vivify_2537
    die "Contextual $*PACKAGE not found"
  vivify_2537:
  vivify_2536:
    find_lex $P5196, "$prefix_meth"
    unless_null $P5196, vivify_2538
    new $P5196, "Undef"
  vivify_2538:
    $P5197 = $P5196."name"()
    find_lex $P5198, "$prefix_meth"
    unless_null $P5198, vivify_2539
    new $P5198, "Undef"
  vivify_2539:
    $P5199 = $P5192."pkg_add_method"($P5195, "add_method", $P5197, $P5198, 0)
.annotate 'line', 1768
    .return ($P5199)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block5091"  :anon :subid("531_1304456155.152") :outer("529_1304456155.152")
.annotate 'line', 1753
    $P5093 = root_new ['parrot';'Hash']
    .lex "%h", $P5093
.annotate 'line', 1752
    find_lex $P5094, "%h"
    unless_null $P5094, vivify_2548
    $P5094 = root_new ['parrot';'Hash']
  vivify_2548:
.annotate 'line', 1754
    find_lex $P5096, "$/"
    unless_null $P5096, vivify_2549
    $P5096 = root_new ['parrot';'Hash']
  vivify_2549:
    set $P5097, $P5096["sym"]
    unless_null $P5097, vivify_2550
    new $P5097, "Undef"
  vivify_2550:
    set $S5098, $P5097
    iseq $I5099, $S5098, "token"
    unless $I5099, if_5095_end
    new $P5100, "Integer"
    assign $P5100, 1
    find_lex $P5101, "%h"
    unless_null $P5101, vivify_2551
    $P5101 = root_new ['parrot';'Hash']
    store_lex "%h", $P5101
  vivify_2551:
    set $P5101["r"], $P5100
  if_5095_end:
.annotate 'line', 1755
    find_lex $P5103, "$/"
    unless_null $P5103, vivify_2552
    $P5103 = root_new ['parrot';'Hash']
  vivify_2552:
    set $P5104, $P5103["sym"]
    unless_null $P5104, vivify_2553
    new $P5104, "Undef"
  vivify_2553:
    set $S5105, $P5104
    iseq $I5106, $S5105, "rule"
    unless $I5106, if_5102_end
    new $P5107, "Integer"
    assign $P5107, 1
    find_lex $P5108, "%h"
    unless_null $P5108, vivify_2554
    $P5108 = root_new ['parrot';'Hash']
    store_lex "%h", $P5108
  vivify_2554:
    set $P5108["r"], $P5107
    new $P5109, "Integer"
    assign $P5109, 1
    find_lex $P5110, "%h"
    unless_null $P5110, vivify_2555
    $P5110 = root_new ['parrot';'Hash']
    store_lex "%h", $P5110
  vivify_2555:
    set $P5110["s"], $P5109
  if_5102_end:
.annotate 'line', 1756
    find_lex $P5111, "@MODIFIERS"
    unless_null $P5111, vivify_2556
    $P5111 = root_new ['parrot';'ResizablePMCArray']
  vivify_2556:
    find_lex $P5112, "%h"
    unless_null $P5112, vivify_2557
    $P5112 = root_new ['parrot';'Hash']
  vivify_2557:
    $P5111."unshift"($P5112)
.annotate 'line', 1757
    find_lex $P5113, "$name"
    unless_null $P5113, vivify_2558
    new $P5113, "Undef"
  vivify_2558:
    get_hll_global $P5114, "GLOBAL"
    nqp_get_package_through_who $P5115, $P5114, "Regex"
    nqp_get_package_through_who $P5116, $P5115, "P6Regex"
    nqp_get_package_through_who $P5117, $P5116, "Actions"
    get_who $P5118, $P5117
    set $P5118["$REGEXNAME"], $P5113
.annotate 'line', 1758
    find_lex $P5119, "$?PACKAGE"
    get_who $P5120, $P5119
    set $P5121, $P5120["@BLOCK"]
    unless_null $P5121, vivify_2559
    $P5121 = root_new ['parrot';'ResizablePMCArray']
  vivify_2559:
    set $P5122, $P5121[0]
    unless_null $P5122, vivify_2560
    new $P5122, "Undef"
  vivify_2560:
    $P5122."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 1759
    find_lex $P5123, "$?PACKAGE"
    get_who $P5124, $P5123
    set $P5125, $P5124["@BLOCK"]
    unless_null $P5125, vivify_2561
    $P5125 = root_new ['parrot';'ResizablePMCArray']
  vivify_2561:
    set $P5126, $P5125[0]
    unless_null $P5126, vivify_2562
    new $P5126, "Undef"
  vivify_2562:
    $P5126."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 1760
    new $P5127, "Exception"
    set $P5127['type'], .CONTROL_RETURN
    new $P5128, "Integer"
    assign $P5128, 0
    setattribute $P5127, 'payload', $P5128
    throw $P5127
.annotate 'line', 1752
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5071"  :anon :subid("530_1304456155.152") :outer("529_1304456155.152")
    .param pmc param_5073
.annotate 'line', 1748
    .lex "$_", param_5073
.annotate 'line', 1749
    find_dynamic_lex $P5076, "$*SC"
    unless_null $P5076, vivify_2571
    get_hll_global $P5074, "GLOBAL"
    get_who $P5075, $P5074
    set $P5076, $P5075["$SC"]
    unless_null $P5076, vivify_2572
    die "Contextual $*SC not found"
  vivify_2572:
  vivify_2571:
    find_dynamic_lex $P5079, "$*PACKAGE"
    unless_null $P5079, vivify_2573
    get_hll_global $P5077, "GLOBAL"
    get_who $P5078, $P5077
    set $P5079, $P5078["$PACKAGE"]
    unless_null $P5079, vivify_2574
    die "Contextual $*PACKAGE not found"
  vivify_2574:
  vivify_2573:
    find_lex $P5080, "$_"
    unless_null $P5080, vivify_2575
    new $P5080, "Undef"
  vivify_2575:
    $P5081 = $P5080."name"()
    find_lex $P5082, "$_"
    unless_null $P5082, vivify_2576
    new $P5082, "Undef"
  vivify_2576:
    $P5083 = $P5076."pkg_add_method"($P5079, "add_method", $P5081, $P5082, 0)
.annotate 'line', 1748
    .return ($P5083)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "dotty"  :subid("534_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_5228
    .param pmc param_5229
.annotate 'line', 1797
    .lex "self", param_5228
    .lex "$/", param_5229
.annotate 'line', 1798
    new $P5230, "Undef"
    .lex "$past", $P5230
    find_lex $P5233, "$/"
    unless_null $P5233, vivify_2578
    $P5233 = root_new ['parrot';'Hash']
  vivify_2578:
    set $P5234, $P5233["args"]
    unless_null $P5234, vivify_2579
    new $P5234, "Undef"
  vivify_2579:
    if $P5234, if_5232
    get_hll_global $P5239, "GLOBAL"
    nqp_get_package_through_who $P5240, $P5239, "PAST"
    get_who $P5241, $P5240
    set $P5242, $P5241["Op"]
    find_lex $P5243, "$/"
    unless_null $P5243, vivify_2580
    new $P5243, "Undef"
  vivify_2580:
    $P5244 = $P5242."new"($P5243 :named("node"))
    set $P5231, $P5244
    goto if_5232_end
  if_5232:
    find_lex $P5235, "$/"
    unless_null $P5235, vivify_2581
    $P5235 = root_new ['parrot';'Hash']
  vivify_2581:
    set $P5236, $P5235["args"]
    unless_null $P5236, vivify_2582
    $P5236 = root_new ['parrot';'ResizablePMCArray']
  vivify_2582:
    set $P5237, $P5236[0]
    unless_null $P5237, vivify_2583
    new $P5237, "Undef"
  vivify_2583:
    $P5238 = $P5237."ast"()
    set $P5231, $P5238
  if_5232_end:
    store_lex "$past", $P5231
.annotate 'line', 1799
    find_lex $P5246, "$/"
    unless_null $P5246, vivify_2584
    $P5246 = root_new ['parrot';'Hash']
  vivify_2584:
    set $P5247, $P5246["quote"]
    unless_null $P5247, vivify_2585
    new $P5247, "Undef"
  vivify_2585:
    if $P5247, if_5245
.annotate 'line', 1803
    find_lex $P5254, "$/"
    unless_null $P5254, vivify_2586
    $P5254 = root_new ['parrot';'Hash']
  vivify_2586:
    set $P5255, $P5254["longname"]
    unless_null $P5255, vivify_2587
    new $P5255, "Undef"
  vivify_2587:
    set $S5256, $P5255
    iseq $I5257, $S5256, "HOW"
    if $I5257, if_5253
.annotate 'line', 1806
    find_lex $P5260, "$/"
    unless_null $P5260, vivify_2588
    $P5260 = root_new ['parrot';'Hash']
  vivify_2588:
    set $P5261, $P5260["longname"]
    unless_null $P5261, vivify_2589
    new $P5261, "Undef"
  vivify_2589:
    set $S5262, $P5261
    iseq $I5263, $S5262, "WHAT"
    if $I5263, if_5259
.annotate 'line', 1809
    find_lex $P5266, "$/"
    unless_null $P5266, vivify_2590
    $P5266 = root_new ['parrot';'Hash']
  vivify_2590:
    set $P5267, $P5266["longname"]
    unless_null $P5267, vivify_2591
    new $P5267, "Undef"
  vivify_2591:
    set $S5268, $P5267
    iseq $I5269, $S5268, "WHO"
    if $I5269, if_5265
.annotate 'line', 1813
    find_lex $P5271, "$past"
    unless_null $P5271, vivify_2592
    new $P5271, "Undef"
  vivify_2592:
    find_lex $P5272, "$/"
    unless_null $P5272, vivify_2593
    $P5272 = root_new ['parrot';'Hash']
  vivify_2593:
    set $P5273, $P5272["longname"]
    unless_null $P5273, vivify_2594
    new $P5273, "Undef"
  vivify_2594:
    set $S5274, $P5273
    $P5271."name"($S5274)
.annotate 'line', 1814
    find_lex $P5275, "$past"
    unless_null $P5275, vivify_2595
    new $P5275, "Undef"
  vivify_2595:
    $P5275."pasttype"("callmethod")
.annotate 'line', 1812
    goto if_5265_end
  if_5265:
.annotate 'line', 1810
    find_lex $P5270, "$past"
    unless_null $P5270, vivify_2596
    new $P5270, "Undef"
  vivify_2596:
    $P5270."pirop"("get_who PP")
  if_5265_end:
.annotate 'line', 1809
    goto if_5259_end
  if_5259:
.annotate 'line', 1807
    find_lex $P5264, "$past"
    unless_null $P5264, vivify_2597
    new $P5264, "Undef"
  vivify_2597:
    $P5264."pirop"("get_what PP")
  if_5259_end:
.annotate 'line', 1806
    goto if_5253_end
  if_5253:
.annotate 'line', 1804
    find_lex $P5258, "$past"
    unless_null $P5258, vivify_2598
    new $P5258, "Undef"
  vivify_2598:
    $P5258."pirop"("get_how PP")
  if_5253_end:
.annotate 'line', 1803
    goto if_5245_end
  if_5245:
.annotate 'line', 1800
    find_lex $P5248, "$past"
    unless_null $P5248, vivify_2599
    new $P5248, "Undef"
  vivify_2599:
    find_lex $P5249, "$/"
    unless_null $P5249, vivify_2600
    $P5249 = root_new ['parrot';'Hash']
  vivify_2600:
    set $P5250, $P5249["quote"]
    unless_null $P5250, vivify_2601
    new $P5250, "Undef"
  vivify_2601:
    $P5251 = $P5250."ast"()
    $P5248."name"($P5251)
.annotate 'line', 1801
    find_lex $P5252, "$past"
    unless_null $P5252, vivify_2602
    new $P5252, "Undef"
  vivify_2602:
    $P5252."pasttype"("callmethod")
  if_5245_end:
.annotate 'line', 1816
    find_lex $P5276, "$/"
    find_lex $P5277, "$past"
    unless_null $P5277, vivify_2603
    new $P5277, "Undef"
  vivify_2603:
    $P5278 = $P5276."!make"($P5277)
.annotate 'line', 1797
    .return ($P5278)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<self>"  :subid("535_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_5280
    .param pmc param_5281
.annotate 'line', 1821
    .lex "self", param_5280
    .lex "$/", param_5281
.annotate 'line', 1822
    find_lex $P5282, "$/"
    get_hll_global $P5283, "GLOBAL"
    nqp_get_package_through_who $P5284, $P5283, "PAST"
    get_who $P5285, $P5284
    set $P5286, $P5285["Var"]
    $P5287 = $P5286."new"("self" :named("name"))
    $P5288 = $P5282."!make"($P5287)
.annotate 'line', 1821
    .return ($P5288)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<identifier>"  :subid("536_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_5290
    .param pmc param_5291
.annotate 'line', 1825
    .lex "self", param_5290
    .lex "$/", param_5291
.annotate 'line', 1826
    new $P5292, "Undef"
    .lex "$past", $P5292
    find_lex $P5293, "$/"
    unless_null $P5293, vivify_2604
    $P5293 = root_new ['parrot';'Hash']
  vivify_2604:
    set $P5294, $P5293["args"]
    unless_null $P5294, vivify_2605
    new $P5294, "Undef"
  vivify_2605:
    $P5295 = $P5294."ast"()
    store_lex "$past", $P5295
.annotate 'line', 1827
    find_lex $P5296, "$past"
    unless_null $P5296, vivify_2606
    new $P5296, "Undef"
  vivify_2606:
    find_lex $P5297, "$/"
    unless_null $P5297, vivify_2607
    $P5297 = root_new ['parrot';'Hash']
  vivify_2607:
    set $P5298, $P5297["deflongname"]
    unless_null $P5298, vivify_2608
    new $P5298, "Undef"
  vivify_2608:
    set $S5299, $P5298
    $P5296."name"($S5299)
.annotate 'line', 1828
    find_lex $P5300, "$/"
    find_lex $P5301, "$past"
    unless_null $P5301, vivify_2609
    new $P5301, "Undef"
  vivify_2609:
    $P5302 = $P5300."!make"($P5301)
.annotate 'line', 1825
    .return ($P5302)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<name>"  :subid("537_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_5304
    .param pmc param_5305
.annotate 'line', 1831
    .const 'Sub' $P5323 = "538_1304456155.152" 
    capture_lex $P5323
    .lex "self", param_5304
    .lex "$/", param_5305
.annotate 'line', 1833
    new $P5306, "Undef"
    .lex "$var", $P5306
.annotate 'line', 1843
    new $P5307, "Undef"
    .lex "$past", $P5307
.annotate 'line', 1831
    find_lex $P5308, "$var"
    unless_null $P5308, vivify_2610
    new $P5308, "Undef"
  vivify_2610:
.annotate 'line', 1834
    find_lex $P5310, "$/"
    unless_null $P5310, vivify_2611
    $P5310 = root_new ['parrot';'Hash']
  vivify_2611:
    set $P5311, $P5310["name"]
    unless_null $P5311, vivify_2612
    new $P5311, "Undef"
  vivify_2612:
    set $S5312, $P5311
    $P5313 = "is_lexical"($S5312)
    if $P5313, if_5309
.annotate 'line', 1837
    .const 'Sub' $P5323 = "538_1304456155.152" 
    capture_lex $P5323
    $P5323()
    goto if_5309_end
  if_5309:
.annotate 'line', 1835
    get_hll_global $P5314, "GLOBAL"
    nqp_get_package_through_who $P5315, $P5314, "PAST"
    get_who $P5316, $P5315
    set $P5317, $P5316["Var"]
    find_lex $P5318, "$/"
    unless_null $P5318, vivify_2618
    $P5318 = root_new ['parrot';'Hash']
  vivify_2618:
    set $P5319, $P5318["name"]
    unless_null $P5319, vivify_2619
    new $P5319, "Undef"
  vivify_2619:
    set $S5320, $P5319
    $P5321 = $P5317."new"($S5320 :named("name"), "lexical" :named("scope"))
    store_lex "$var", $P5321
  if_5309_end:
.annotate 'line', 1843
    find_lex $P5332, "$var"
    unless_null $P5332, vivify_2620
    new $P5332, "Undef"
  vivify_2620:
    store_lex "$past", $P5332
.annotate 'line', 1844
    find_lex $P5334, "$/"
    unless_null $P5334, vivify_2621
    $P5334 = root_new ['parrot';'Hash']
  vivify_2621:
    set $P5335, $P5334["args"]
    unless_null $P5335, vivify_2622
    new $P5335, "Undef"
  vivify_2622:
    unless $P5335, if_5333_end
.annotate 'line', 1845
    find_lex $P5336, "$/"
    unless_null $P5336, vivify_2623
    $P5336 = root_new ['parrot';'Hash']
  vivify_2623:
    set $P5337, $P5336["args"]
    unless_null $P5337, vivify_2624
    $P5337 = root_new ['parrot';'ResizablePMCArray']
  vivify_2624:
    set $P5338, $P5337[0]
    unless_null $P5338, vivify_2625
    new $P5338, "Undef"
  vivify_2625:
    $P5339 = $P5338."ast"()
    store_lex "$past", $P5339
.annotate 'line', 1846
    find_lex $P5340, "$past"
    unless_null $P5340, vivify_2626
    new $P5340, "Undef"
  vivify_2626:
    find_lex $P5341, "$var"
    unless_null $P5341, vivify_2627
    new $P5341, "Undef"
  vivify_2627:
    $P5340."unshift"($P5341)
  if_5333_end:
.annotate 'line', 1848
    find_lex $P5342, "$/"
    find_lex $P5343, "$past"
    unless_null $P5343, vivify_2628
    new $P5343, "Undef"
  vivify_2628:
    $P5344 = $P5342."!make"($P5343)
.annotate 'line', 1831
    .return ($P5344)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5322"  :anon :subid("538_1304456155.152") :outer("537_1304456155.152")
.annotate 'line', 1838
    $P5324 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P5324
    find_lex $P5325, "$/"
    unless_null $P5325, vivify_2613
    $P5325 = root_new ['parrot';'Hash']
  vivify_2613:
    set $P5326, $P5325["name"]
    unless_null $P5326, vivify_2614
    $P5326 = root_new ['parrot';'Hash']
  vivify_2614:
    set $P5327, $P5326["identifier"]
    unless_null $P5327, vivify_2615
    new $P5327, "Undef"
  vivify_2615:
    clone $P5328, $P5327
    store_lex "@ns", $P5328
.annotate 'line', 1839
    find_lex $P5329, "@ns"
    unless_null $P5329, vivify_2616
    $P5329 = root_new ['parrot';'ResizablePMCArray']
  vivify_2616:
    find_lex $P5330, "$/"
    unless_null $P5330, vivify_2617
    new $P5330, "Undef"
  vivify_2617:
    $P5331 = "lexical_package_lookup"($P5329, $P5330)
    store_lex "$var", $P5331
.annotate 'line', 1837
    .return ($P5331)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<pir::op>"  :subid("539_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_5346
    .param pmc param_5347
.annotate 'line', 1851
    .lex "self", param_5346
    .lex "$/", param_5347
.annotate 'line', 1852
    new $P5348, "Undef"
    .lex "$past", $P5348
.annotate 'line', 1853
    new $P5349, "Undef"
    .lex "$pirop", $P5349
.annotate 'line', 1852
    find_lex $P5352, "$/"
    unless_null $P5352, vivify_2629
    $P5352 = root_new ['parrot';'Hash']
  vivify_2629:
    set $P5353, $P5352["args"]
    unless_null $P5353, vivify_2630
    new $P5353, "Undef"
  vivify_2630:
    if $P5353, if_5351
    get_hll_global $P5358, "GLOBAL"
    nqp_get_package_through_who $P5359, $P5358, "PAST"
    get_who $P5360, $P5359
    set $P5361, $P5360["Op"]
    find_lex $P5362, "$/"
    unless_null $P5362, vivify_2631
    new $P5362, "Undef"
  vivify_2631:
    $P5363 = $P5361."new"($P5362 :named("node"))
    set $P5350, $P5363
    goto if_5351_end
  if_5351:
    find_lex $P5354, "$/"
    unless_null $P5354, vivify_2632
    $P5354 = root_new ['parrot';'Hash']
  vivify_2632:
    set $P5355, $P5354["args"]
    unless_null $P5355, vivify_2633
    $P5355 = root_new ['parrot';'ResizablePMCArray']
  vivify_2633:
    set $P5356, $P5355[0]
    unless_null $P5356, vivify_2634
    new $P5356, "Undef"
  vivify_2634:
    $P5357 = $P5356."ast"()
    set $P5350, $P5357
  if_5351_end:
    store_lex "$past", $P5350
.annotate 'line', 1853
    find_lex $P5364, "$/"
    unless_null $P5364, vivify_2635
    $P5364 = root_new ['parrot';'Hash']
  vivify_2635:
    set $P5365, $P5364["op"]
    unless_null $P5365, vivify_2636
    new $P5365, "Undef"
  vivify_2636:
    set $S5366, $P5365
    new $P5367, 'String'
    set $P5367, $S5366
    store_lex "$pirop", $P5367
.annotate 'line', 1854
    find_lex $P5368, "$pirop"
    unless_null $P5368, vivify_2637
    new $P5368, "Undef"
  vivify_2637:
    set $S5369, $P5368
    split $P5370, "__", $S5369
    join $S5371, " ", $P5370
    new $P5372, 'String'
    set $P5372, $S5371
    store_lex "$pirop", $P5372
.annotate 'line', 1855
    find_lex $P5373, "$past"
    unless_null $P5373, vivify_2638
    new $P5373, "Undef"
  vivify_2638:
    find_lex $P5374, "$pirop"
    unless_null $P5374, vivify_2639
    new $P5374, "Undef"
  vivify_2639:
    $P5373."pirop"($P5374)
.annotate 'line', 1856
    find_lex $P5375, "$past"
    unless_null $P5375, vivify_2640
    new $P5375, "Undef"
  vivify_2640:
    $P5375."pasttype"("pirop")
.annotate 'line', 1857
    find_lex $P5376, "$/"
    find_lex $P5377, "$past"
    unless_null $P5377, vivify_2641
    new $P5377, "Undef"
  vivify_2641:
    $P5378 = $P5376."!make"($P5377)
.annotate 'line', 1851
    .return ($P5378)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<onlystar>"  :subid("540_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_5380
    .param pmc param_5381
.annotate 'line', 1860
    .lex "self", param_5380
    .lex "$/", param_5381
.annotate 'line', 1861
    find_lex $P5382, "$/"
    get_hll_global $P5383, "GLOBAL"
    nqp_get_package_through_who $P5384, $P5383, "PAST"
    get_who $P5385, $P5384
    set $P5386, $P5385["Op"]
    $P5387 = $P5386."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P5388 = $P5382."!make"($P5387)
.annotate 'line', 1860
    .return ($P5388)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "args"  :subid("541_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_5390
    .param pmc param_5391
.annotate 'line', 1866
    .lex "self", param_5390
    .lex "$/", param_5391
    find_lex $P5392, "$/"
    find_lex $P5393, "$/"
    unless_null $P5393, vivify_2642
    $P5393 = root_new ['parrot';'Hash']
  vivify_2642:
    set $P5394, $P5393["arglist"]
    unless_null $P5394, vivify_2643
    new $P5394, "Undef"
  vivify_2643:
    $P5395 = $P5394."ast"()
    $P5396 = $P5392."!make"($P5395)
    .return ($P5396)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "arglist"  :subid("542_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_5398
    .param pmc param_5399
.annotate 'line', 1868
    .const 'Sub' $P5413 = "543_1304456155.152" 
    capture_lex $P5413
    .lex "self", param_5398
    .lex "$/", param_5399
.annotate 'line', 1869
    new $P5400, "Undef"
    .lex "$past", $P5400
.annotate 'line', 1877
    new $P5401, "Undef"
    .lex "$i", $P5401
.annotate 'line', 1878
    new $P5402, "Undef"
    .lex "$n", $P5402
.annotate 'line', 1869
    get_hll_global $P5403, "GLOBAL"
    nqp_get_package_through_who $P5404, $P5403, "PAST"
    get_who $P5405, $P5404
    set $P5406, $P5405["Op"]
    find_lex $P5407, "$/"
    unless_null $P5407, vivify_2644
    new $P5407, "Undef"
  vivify_2644:
    $P5408 = $P5406."new"("call" :named("pasttype"), $P5407 :named("node"))
    store_lex "$past", $P5408
.annotate 'line', 1870
    find_lex $P5410, "$/"
    unless_null $P5410, vivify_2645
    $P5410 = root_new ['parrot';'Hash']
  vivify_2645:
    set $P5411, $P5410["EXPR"]
    unless_null $P5411, vivify_2646
    new $P5411, "Undef"
  vivify_2646:
    unless $P5411, if_5409_end
    .const 'Sub' $P5413 = "543_1304456155.152" 
    capture_lex $P5413
    $P5413()
  if_5409_end:
.annotate 'line', 1877
    new $P5445, "Integer"
    assign $P5445, 0
    store_lex "$i", $P5445
.annotate 'line', 1878
    find_lex $P5446, "$past"
    unless_null $P5446, vivify_2657
    new $P5446, "Undef"
  vivify_2657:
    $P5447 = $P5446."list"()
    set $N5448, $P5447
    new $P5449, 'Float'
    set $P5449, $N5448
    store_lex "$n", $P5449
.annotate 'line', 1879
    new $P5500, 'ExceptionHandler'
    set_label $P5500, loop5499_handler
    $P5500."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5500
  loop5499_test:
    find_lex $P5450, "$i"
    unless_null $P5450, vivify_2658
    new $P5450, "Undef"
  vivify_2658:
    set $N5451, $P5450
    find_lex $P5452, "$n"
    unless_null $P5452, vivify_2659
    new $P5452, "Undef"
  vivify_2659:
    set $N5453, $P5452
    islt $I5454, $N5451, $N5453
    unless $I5454, loop5499_done
  loop5499_redo:
.annotate 'line', 1880
    find_lex $P5456, "$i"
    unless_null $P5456, vivify_2660
    new $P5456, "Undef"
  vivify_2660:
    set $I5457, $P5456
    find_lex $P5458, "$past"
    unless_null $P5458, vivify_2661
    $P5458 = root_new ['parrot';'ResizablePMCArray']
  vivify_2661:
    set $P5459, $P5458[$I5457]
    unless_null $P5459, vivify_2662
    new $P5459, "Undef"
  vivify_2662:
    $S5460 = $P5459."name"()
    iseq $I5461, $S5460, "&prefix:<|>"
    unless $I5461, if_5455_end
.annotate 'line', 1881
    find_lex $P5462, "$i"
    unless_null $P5462, vivify_2663
    new $P5462, "Undef"
  vivify_2663:
    set $I5463, $P5462
    find_lex $P5464, "$past"
    unless_null $P5464, vivify_2664
    $P5464 = root_new ['parrot';'ResizablePMCArray']
  vivify_2664:
    set $P5465, $P5464[$I5463]
    unless_null $P5465, vivify_2665
    $P5465 = root_new ['parrot';'ResizablePMCArray']
  vivify_2665:
    set $P5466, $P5465[0]
    unless_null $P5466, vivify_2666
    new $P5466, "Undef"
  vivify_2666:
    find_lex $P5467, "$i"
    unless_null $P5467, vivify_2667
    new $P5467, "Undef"
  vivify_2667:
    set $I5468, $P5467
    find_lex $P5469, "$past"
    unless_null $P5469, vivify_2668
    $P5469 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$past", $P5469
  vivify_2668:
    set $P5469[$I5468], $P5466
.annotate 'line', 1882
    find_lex $P5470, "$i"
    unless_null $P5470, vivify_2669
    new $P5470, "Undef"
  vivify_2669:
    set $I5471, $P5470
    find_lex $P5472, "$past"
    unless_null $P5472, vivify_2670
    $P5472 = root_new ['parrot';'ResizablePMCArray']
  vivify_2670:
    set $P5473, $P5472[$I5471]
    unless_null $P5473, vivify_2671
    new $P5473, "Undef"
  vivify_2671:
    $P5473."flat"(1)
.annotate 'line', 1883
    find_lex $P5477, "$i"
    unless_null $P5477, vivify_2672
    new $P5477, "Undef"
  vivify_2672:
    set $I5478, $P5477
    find_lex $P5479, "$past"
    unless_null $P5479, vivify_2673
    $P5479 = root_new ['parrot';'ResizablePMCArray']
  vivify_2673:
    set $P5480, $P5479[$I5478]
    unless_null $P5480, vivify_2674
    new $P5480, "Undef"
  vivify_2674:
    get_hll_global $P5481, "GLOBAL"
    nqp_get_package_through_who $P5482, $P5481, "PAST"
    get_who $P5483, $P5482
    set $P5484, $P5483["Val"]
    $P5485 = $P5480."isa"($P5484)
    if $P5485, if_5476
    set $P5475, $P5485
    goto if_5476_end
  if_5476:
.annotate 'line', 1884
    find_lex $P5486, "$i"
    unless_null $P5486, vivify_2675
    new $P5486, "Undef"
  vivify_2675:
    set $I5487, $P5486
    find_lex $P5488, "$past"
    unless_null $P5488, vivify_2676
    $P5488 = root_new ['parrot';'ResizablePMCArray']
  vivify_2676:
    set $P5489, $P5488[$I5487]
    unless_null $P5489, vivify_2677
    new $P5489, "Undef"
  vivify_2677:
    $S5490 = $P5489."name"()
    substr $S5491, $S5490, 0, 1
    iseq $I5492, $S5491, "%"
    new $P5475, 'Integer'
    set $P5475, $I5492
  if_5476_end:
    unless $P5475, if_5474_end
.annotate 'line', 1885
    find_lex $P5493, "$i"
    unless_null $P5493, vivify_2678
    new $P5493, "Undef"
  vivify_2678:
    set $I5494, $P5493
    find_lex $P5495, "$past"
    unless_null $P5495, vivify_2679
    $P5495 = root_new ['parrot';'ResizablePMCArray']
  vivify_2679:
    set $P5496, $P5495[$I5494]
    unless_null $P5496, vivify_2680
    new $P5496, "Undef"
  vivify_2680:
    $P5496."named"(1)
  if_5474_end:
  if_5455_end:
.annotate 'line', 1880
    find_lex $P5497, "$i"
    unless_null $P5497, vivify_2681
    new $P5497, "Undef"
  vivify_2681:
    clone $P5498, $P5497
    inc $P5497
  loop5499_next:
.annotate 'line', 1879
    goto loop5499_test
  loop5499_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5501, exception, 'type'
    eq $P5501, .CONTROL_LOOP_NEXT, loop5499_next
    eq $P5501, .CONTROL_LOOP_REDO, loop5499_redo
  loop5499_done:
    pop_eh 
.annotate 'line', 1890
    find_lex $P5502, "$/"
    find_lex $P5503, "$past"
    unless_null $P5503, vivify_2682
    new $P5503, "Undef"
  vivify_2682:
    $P5504 = $P5502."!make"($P5503)
.annotate 'line', 1868
    .return ($P5504)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block5412"  :anon :subid("543_1304456155.152") :outer("542_1304456155.152")
.annotate 'line', 1870
    .const 'Sub' $P5434 = "544_1304456155.152" 
    capture_lex $P5434
.annotate 'line', 1871
    new $P5414, "Undef"
    .lex "$expr", $P5414
    find_lex $P5415, "$/"
    unless_null $P5415, vivify_2647
    $P5415 = root_new ['parrot';'Hash']
  vivify_2647:
    set $P5416, $P5415["EXPR"]
    unless_null $P5416, vivify_2648
    new $P5416, "Undef"
  vivify_2648:
    $P5417 = $P5416."ast"()
    store_lex "$expr", $P5417
.annotate 'line', 1872
    find_lex $P5422, "$expr"
    unless_null $P5422, vivify_2649
    new $P5422, "Undef"
  vivify_2649:
    $S5423 = $P5422."name"()
    iseq $I5424, $S5423, "&infix:<,>"
    if $I5424, if_5421
    new $P5420, 'Integer'
    set $P5420, $I5424
    goto if_5421_end
  if_5421:
    find_lex $P5425, "$expr"
    unless_null $P5425, vivify_2650
    new $P5425, "Undef"
  vivify_2650:
    $P5426 = $P5425."named"()
    isfalse $I5427, $P5426
    new $P5420, 'Integer'
    set $P5420, $I5427
  if_5421_end:
    if $P5420, if_5419
.annotate 'line', 1875
    find_lex $P5442, "$past"
    unless_null $P5442, vivify_2651
    new $P5442, "Undef"
  vivify_2651:
    find_lex $P5443, "$expr"
    unless_null $P5443, vivify_2652
    new $P5443, "Undef"
  vivify_2652:
    $P5444 = $P5442."push"($P5443)
    set $P5418, $P5444
.annotate 'line', 1872
    goto if_5419_end
  if_5419:
.annotate 'line', 1873
    find_lex $P5429, "$expr"
    unless_null $P5429, vivify_2653
    new $P5429, "Undef"
  vivify_2653:
    $P5430 = $P5429."list"()
    defined $I5431, $P5430
    unless $I5431, for_undef_2654
    iter $P5428, $P5430
    new $P5440, 'ExceptionHandler'
    set_label $P5440, loop5439_handler
    $P5440."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5440
  loop5439_test:
    unless $P5428, loop5439_done
    shift $P5432, $P5428
  loop5439_redo:
    .const 'Sub' $P5434 = "544_1304456155.152" 
    capture_lex $P5434
    $P5434($P5432)
  loop5439_next:
    goto loop5439_test
  loop5439_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5441, exception, 'type'
    eq $P5441, .CONTROL_LOOP_NEXT, loop5439_next
    eq $P5441, .CONTROL_LOOP_REDO, loop5439_redo
  loop5439_done:
    pop_eh 
  for_undef_2654:
.annotate 'line', 1872
    set $P5418, $P5428
  if_5419_end:
.annotate 'line', 1870
    .return ($P5418)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5433"  :anon :subid("544_1304456155.152") :outer("543_1304456155.152")
    .param pmc param_5435
.annotate 'line', 1873
    .lex "$_", param_5435
    find_lex $P5436, "$past"
    unless_null $P5436, vivify_2655
    new $P5436, "Undef"
  vivify_2655:
    find_lex $P5437, "$_"
    unless_null $P5437, vivify_2656
    new $P5437, "Undef"
  vivify_2656:
    $P5438 = $P5436."push"($P5437)
    .return ($P5438)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<multi_declarator>"  :subid("545_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_5506
    .param pmc param_5507
.annotate 'line', 1893
    .lex "self", param_5506
    .lex "$/", param_5507
    find_lex $P5508, "$/"
    find_lex $P5509, "$/"
    unless_null $P5509, vivify_2683
    $P5509 = root_new ['parrot';'Hash']
  vivify_2683:
    set $P5510, $P5509["multi_declarator"]
    unless_null $P5510, vivify_2684
    new $P5510, "Undef"
  vivify_2684:
    $P5511 = $P5510."ast"()
    $P5512 = $P5508."!make"($P5511)
    .return ($P5512)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<value>"  :subid("546_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_5514
    .param pmc param_5515
.annotate 'line', 1895
    .lex "self", param_5514
    .lex "$/", param_5515
    find_lex $P5516, "$/"
    find_lex $P5517, "$/"
    unless_null $P5517, vivify_2685
    $P5517 = root_new ['parrot';'Hash']
  vivify_2685:
    set $P5518, $P5517["value"]
    unless_null $P5518, vivify_2686
    new $P5518, "Undef"
  vivify_2686:
    $P5519 = $P5518."ast"()
    $P5520 = $P5516."!make"($P5519)
    .return ($P5520)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<( )>"  :subid("547_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_5522
    .param pmc param_5523
.annotate 'line', 1897
    .lex "self", param_5522
    .lex "$/", param_5523
.annotate 'line', 1898
    find_lex $P5524, "$/"
.annotate 'line', 1899
    find_lex $P5527, "$/"
    unless_null $P5527, vivify_2687
    $P5527 = root_new ['parrot';'Hash']
  vivify_2687:
    set $P5528, $P5527["EXPR"]
    unless_null $P5528, vivify_2688
    new $P5528, "Undef"
  vivify_2688:
    if $P5528, if_5526
.annotate 'line', 1900
    get_hll_global $P5533, "GLOBAL"
    nqp_get_package_through_who $P5534, $P5533, "PAST"
    get_who $P5535, $P5534
    set $P5536, $P5535["Op"]
    find_lex $P5537, "$/"
    unless_null $P5537, vivify_2689
    new $P5537, "Undef"
  vivify_2689:
    $P5538 = $P5536."new"("list" :named("pasttype"), $P5537 :named("node"))
    set $P5525, $P5538
.annotate 'line', 1899
    goto if_5526_end
  if_5526:
    find_lex $P5529, "$/"
    unless_null $P5529, vivify_2690
    $P5529 = root_new ['parrot';'Hash']
  vivify_2690:
    set $P5530, $P5529["EXPR"]
    unless_null $P5530, vivify_2691
    $P5530 = root_new ['parrot';'ResizablePMCArray']
  vivify_2691:
    set $P5531, $P5530[0]
    unless_null $P5531, vivify_2692
    new $P5531, "Undef"
  vivify_2692:
    $P5532 = $P5531."ast"()
    set $P5525, $P5532
  if_5526_end:
    $P5539 = $P5524."!make"($P5525)
.annotate 'line', 1897
    .return ($P5539)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<[ ]>"  :subid("548_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_5541
    .param pmc param_5542
.annotate 'line', 1903
    .lex "self", param_5541
    .lex "$/", param_5542
.annotate 'line', 1904
    new $P5543, "Undef"
    .lex "$past", $P5543
.annotate 'line', 1903
    find_lex $P5544, "$past"
    unless_null $P5544, vivify_2693
    new $P5544, "Undef"
  vivify_2693:
.annotate 'line', 1905
    find_lex $P5546, "$/"
    unless_null $P5546, vivify_2694
    $P5546 = root_new ['parrot';'Hash']
  vivify_2694:
    set $P5547, $P5546["EXPR"]
    unless_null $P5547, vivify_2695
    new $P5547, "Undef"
  vivify_2695:
    if $P5547, if_5545
.annotate 'line', 1912
    get_hll_global $P5562, "GLOBAL"
    nqp_get_package_through_who $P5563, $P5562, "PAST"
    get_who $P5564, $P5563
    set $P5565, $P5564["Op"]
    $P5566 = $P5565."new"("list" :named("pasttype"))
    store_lex "$past", $P5566
.annotate 'line', 1911
    goto if_5545_end
  if_5545:
.annotate 'line', 1906
    find_lex $P5548, "$/"
    unless_null $P5548, vivify_2696
    $P5548 = root_new ['parrot';'Hash']
  vivify_2696:
    set $P5549, $P5548["EXPR"]
    unless_null $P5549, vivify_2697
    $P5549 = root_new ['parrot';'ResizablePMCArray']
  vivify_2697:
    set $P5550, $P5549[0]
    unless_null $P5550, vivify_2698
    new $P5550, "Undef"
  vivify_2698:
    $P5551 = $P5550."ast"()
    store_lex "$past", $P5551
.annotate 'line', 1907
    find_lex $P5553, "$past"
    unless_null $P5553, vivify_2699
    new $P5553, "Undef"
  vivify_2699:
    $S5554 = $P5553."name"()
    isne $I5555, $S5554, "&infix:<,>"
    unless $I5555, if_5552_end
.annotate 'line', 1908
    get_hll_global $P5556, "GLOBAL"
    nqp_get_package_through_who $P5557, $P5556, "PAST"
    get_who $P5558, $P5557
    set $P5559, $P5558["Op"]
    find_lex $P5560, "$past"
    unless_null $P5560, vivify_2700
    new $P5560, "Undef"
  vivify_2700:
    $P5561 = $P5559."new"($P5560, "list" :named("pasttype"))
    store_lex "$past", $P5561
  if_5552_end:
  if_5545_end:
.annotate 'line', 1914
    find_lex $P5567, "$past"
    unless_null $P5567, vivify_2701
    new $P5567, "Undef"
  vivify_2701:
    $P5567."name"("&circumfix:<[ ]>")
.annotate 'line', 1915
    find_lex $P5568, "$/"
    find_lex $P5569, "$past"
    unless_null $P5569, vivify_2702
    new $P5569, "Undef"
  vivify_2702:
    $P5570 = $P5568."!make"($P5569)
.annotate 'line', 1903
    .return ($P5570)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<ang>"  :subid("549_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_5572
    .param pmc param_5573
.annotate 'line', 1918
    .lex "self", param_5572
    .lex "$/", param_5573
    find_lex $P5574, "$/"
    find_lex $P5575, "$/"
    unless_null $P5575, vivify_2703
    $P5575 = root_new ['parrot';'Hash']
  vivify_2703:
    set $P5576, $P5575["quote_EXPR"]
    unless_null $P5576, vivify_2704
    new $P5576, "Undef"
  vivify_2704:
    $P5577 = $P5576."ast"()
    $P5578 = $P5574."!make"($P5577)
    .return ($P5578)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("550_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_5580
    .param pmc param_5581
.annotate 'line', 1919
    .lex "self", param_5580
    .lex "$/", param_5581
    find_lex $P5582, "$/"
    find_lex $P5583, "$/"
    unless_null $P5583, vivify_2705
    $P5583 = root_new ['parrot';'Hash']
  vivify_2705:
    set $P5584, $P5583["quote_EXPR"]
    unless_null $P5584, vivify_2706
    new $P5584, "Undef"
  vivify_2706:
    $P5585 = $P5584."ast"()
    $P5586 = $P5582."!make"($P5585)
    .return ($P5586)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<{ }>"  :subid("551_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_5588
    .param pmc param_5589
.annotate 'line', 1921
    .const 'Sub' $P5600 = "552_1304456155.152" 
    capture_lex $P5600
    .lex "self", param_5588
    .lex "$/", param_5589
.annotate 'line', 1922
    find_lex $P5592, "$/"
    unless_null $P5592, vivify_2707
    $P5592 = root_new ['parrot';'Hash']
  vivify_2707:
    set $P5593, $P5592["pblock"]
    unless_null $P5593, vivify_2708
    $P5593 = root_new ['parrot';'Hash']
  vivify_2708:
    set $P5594, $P5593["blockoid"]
    unless_null $P5594, vivify_2709
    $P5594 = root_new ['parrot';'Hash']
  vivify_2709:
    set $P5595, $P5594["statementlist"]
    unless_null $P5595, vivify_2710
    $P5595 = root_new ['parrot';'Hash']
  vivify_2710:
    set $P5596, $P5595["statement"]
    unless_null $P5596, vivify_2711
    new $P5596, "Undef"
  vivify_2711:
    set $N5597, $P5596
    isgt $I5598, $N5597, 0.0
    if $I5598, if_5591
.annotate 'line', 1927
    find_lex $P5613, "$/"
    unless_null $P5613, vivify_2712
    $P5613 = root_new ['parrot';'Hash']
  vivify_2712:
    set $P5614, $P5613["pblock"]
    unless_null $P5614, vivify_2713
    $P5614 = root_new ['parrot';'Hash']
  vivify_2713:
    set $P5615, $P5614["blockoid"]
    unless_null $P5615, vivify_2714
    $P5615 = root_new ['parrot';'Hash']
  vivify_2714:
    set $P5616, $P5615["you_are_here"]
    unless_null $P5616, vivify_2715
    new $P5616, "Undef"
  vivify_2715:
    if $P5616, if_5612
.annotate 'line', 1931
    find_lex $P5622, "$/"
    $P5623 = "vivitype"("%")
    $P5624 = $P5622."!make"($P5623)
.annotate 'line', 1930
    set $P5611, $P5624
.annotate 'line', 1927
    goto if_5612_end
  if_5612:
.annotate 'line', 1928
    find_lex $P5617, "$/"
    find_lex $P5618, "$/"
    unless_null $P5618, vivify_2716
    $P5618 = root_new ['parrot';'Hash']
  vivify_2716:
    set $P5619, $P5618["pblock"]
    unless_null $P5619, vivify_2717
    new $P5619, "Undef"
  vivify_2717:
    $P5620 = $P5619."ast"()
    $P5621 = $P5617."!make"($P5620)
.annotate 'line', 1927
    set $P5611, $P5621
  if_5612_end:
    set $P5590, $P5611
.annotate 'line', 1922
    goto if_5591_end
  if_5591:
    .const 'Sub' $P5600 = "552_1304456155.152" 
    capture_lex $P5600
    $P5610 = $P5600()
    set $P5590, $P5610
  if_5591_end:
.annotate 'line', 1921
    .return ($P5590)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5599"  :anon :subid("552_1304456155.152") :outer("551_1304456155.152")
.annotate 'line', 1923
    new $P5601, "Undef"
    .lex "$past", $P5601
    find_lex $P5602, "$/"
    unless_null $P5602, vivify_2718
    $P5602 = root_new ['parrot';'Hash']
  vivify_2718:
    set $P5603, $P5602["pblock"]
    unless_null $P5603, vivify_2719
    new $P5603, "Undef"
  vivify_2719:
    $P5604 = $P5603."ast"()
    store_lex "$past", $P5604
.annotate 'line', 1924
    new $P5605, "Integer"
    assign $P5605, 1
    find_lex $P5606, "$past"
    unless_null $P5606, vivify_2720
    $P5606 = root_new ['parrot';'Hash']
    store_lex "$past", $P5606
  vivify_2720:
    set $P5606["bareblock"], $P5605
.annotate 'line', 1925
    find_dynamic_lex $P5607, "$/"
    find_lex $P5608, "$past"
    unless_null $P5608, vivify_2721
    new $P5608, "Undef"
  vivify_2721:
    $P5609 = $P5607."!make"($P5608)
.annotate 'line', 1922
    .return ($P5609)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<sigil>"  :subid("553_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_5626
    .param pmc param_5627
.annotate 'line', 1935
    .lex "self", param_5626
    .lex "$/", param_5627
.annotate 'line', 1936
    new $P5628, "Undef"
    .lex "$name", $P5628
    find_lex $P5631, "$/"
    unless_null $P5631, vivify_2722
    $P5631 = root_new ['parrot';'Hash']
  vivify_2722:
    set $P5632, $P5631["sigil"]
    unless_null $P5632, vivify_2723
    new $P5632, "Undef"
  vivify_2723:
    set $S5633, $P5632
    iseq $I5634, $S5633, "@"
    if $I5634, if_5630
.annotate 'line', 1937
    find_lex $P5638, "$/"
    unless_null $P5638, vivify_2724
    $P5638 = root_new ['parrot';'Hash']
  vivify_2724:
    set $P5639, $P5638["sigil"]
    unless_null $P5639, vivify_2725
    new $P5639, "Undef"
  vivify_2725:
    set $S5640, $P5639
    iseq $I5641, $S5640, "%"
    if $I5641, if_5637
    new $P5643, "String"
    assign $P5643, "item"
    set $P5636, $P5643
    goto if_5637_end
  if_5637:
    new $P5642, "String"
    assign $P5642, "hash"
    set $P5636, $P5642
  if_5637_end:
    set $P5629, $P5636
.annotate 'line', 1936
    goto if_5630_end
  if_5630:
    new $P5635, "String"
    assign $P5635, "list"
    set $P5629, $P5635
  if_5630_end:
    store_lex "$name", $P5629
.annotate 'line', 1939
    find_lex $P5644, "$/"
    get_hll_global $P5645, "GLOBAL"
    nqp_get_package_through_who $P5646, $P5645, "PAST"
    get_who $P5647, $P5646
    set $P5648, $P5647["Op"]
    find_lex $P5649, "$name"
    unless_null $P5649, vivify_2726
    new $P5649, "Undef"
  vivify_2726:
    find_lex $P5650, "$/"
    unless_null $P5650, vivify_2727
    $P5650 = root_new ['parrot';'Hash']
  vivify_2727:
    set $P5651, $P5650["semilist"]
    unless_null $P5651, vivify_2728
    new $P5651, "Undef"
  vivify_2728:
    $P5652 = $P5651."ast"()
    $P5653 = $P5648."new"($P5652, "callmethod" :named("pasttype"), $P5649 :named("name"))
    $P5654 = $P5644."!make"($P5653)
.annotate 'line', 1935
    .return ($P5654)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "semilist"  :subid("554_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_5656
    .param pmc param_5657
.annotate 'line', 1942
    .lex "self", param_5656
    .lex "$/", param_5657
    find_lex $P5658, "$/"
    find_lex $P5659, "$/"
    unless_null $P5659, vivify_2729
    $P5659 = root_new ['parrot';'Hash']
  vivify_2729:
    set $P5660, $P5659["statement"]
    unless_null $P5660, vivify_2730
    new $P5660, "Undef"
  vivify_2730:
    $P5661 = $P5660."ast"()
    $P5662 = $P5658."!make"($P5661)
    .return ($P5662)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<[ ]>"  :subid("555_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_5664
    .param pmc param_5665
.annotate 'line', 1944
    .lex "self", param_5664
    .lex "$/", param_5665
.annotate 'line', 1945
    find_lex $P5666, "$/"
    get_hll_global $P5667, "GLOBAL"
    nqp_get_package_through_who $P5668, $P5667, "PAST"
    get_who $P5669, $P5668
    set $P5670, $P5669["Var"]
    find_lex $P5671, "$/"
    unless_null $P5671, vivify_2731
    $P5671 = root_new ['parrot';'Hash']
  vivify_2731:
    set $P5672, $P5671["EXPR"]
    unless_null $P5672, vivify_2732
    new $P5672, "Undef"
  vivify_2732:
    $P5673 = $P5672."ast"()
.annotate 'line', 1947
    $P5674 = "vivitype"("@")
    $P5675 = $P5670."new"($P5673, "keyed_int" :named("scope"), "Undef" :named("viviself"), $P5674 :named("vivibase"))
.annotate 'line', 1945
    $P5676 = $P5666."!make"($P5675)
.annotate 'line', 1944
    .return ($P5676)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<{ }>"  :subid("556_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_5678
    .param pmc param_5679
.annotate 'line', 1950
    .lex "self", param_5678
    .lex "$/", param_5679
.annotate 'line', 1951
    find_lex $P5680, "$/"
    get_hll_global $P5681, "GLOBAL"
    nqp_get_package_through_who $P5682, $P5681, "PAST"
    get_who $P5683, $P5682
    set $P5684, $P5683["Var"]
    find_lex $P5685, "$/"
    unless_null $P5685, vivify_2733
    $P5685 = root_new ['parrot';'Hash']
  vivify_2733:
    set $P5686, $P5685["EXPR"]
    unless_null $P5686, vivify_2734
    new $P5686, "Undef"
  vivify_2734:
    $P5687 = $P5686."ast"()
.annotate 'line', 1953
    $P5688 = "vivitype"("%")
    $P5689 = $P5684."new"($P5687, "keyed" :named("scope"), "Undef" :named("viviself"), $P5688 :named("vivibase"))
.annotate 'line', 1951
    $P5690 = $P5680."!make"($P5689)
.annotate 'line', 1950
    .return ($P5690)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<ang>"  :subid("557_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_5692
    .param pmc param_5693
.annotate 'line', 1956
    .lex "self", param_5692
    .lex "$/", param_5693
.annotate 'line', 1957
    find_lex $P5694, "$/"
    get_hll_global $P5695, "GLOBAL"
    nqp_get_package_through_who $P5696, $P5695, "PAST"
    get_who $P5697, $P5696
    set $P5698, $P5697["Var"]
    find_lex $P5699, "$/"
    unless_null $P5699, vivify_2735
    $P5699 = root_new ['parrot';'Hash']
  vivify_2735:
    set $P5700, $P5699["quote_EXPR"]
    unless_null $P5700, vivify_2736
    new $P5700, "Undef"
  vivify_2736:
    $P5701 = $P5700."ast"()
.annotate 'line', 1959
    $P5702 = "vivitype"("%")
    $P5703 = $P5698."new"($P5701, "keyed" :named("scope"), "Undef" :named("viviself"), $P5702 :named("vivibase"))
.annotate 'line', 1957
    $P5704 = $P5694."!make"($P5703)
.annotate 'line', 1956
    .return ($P5704)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<( )>"  :subid("558_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_5706
    .param pmc param_5707
.annotate 'line', 1962
    .lex "self", param_5706
    .lex "$/", param_5707
.annotate 'line', 1963
    find_lex $P5708, "$/"
    find_lex $P5709, "$/"
    unless_null $P5709, vivify_2737
    $P5709 = root_new ['parrot';'Hash']
  vivify_2737:
    set $P5710, $P5709["arglist"]
    unless_null $P5710, vivify_2738
    new $P5710, "Undef"
  vivify_2738:
    $P5711 = $P5710."ast"()
    $P5712 = $P5708."!make"($P5711)
.annotate 'line', 1962
    .return ($P5712)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "value"  :subid("559_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_5714
    .param pmc param_5715
.annotate 'line', 1966
    .lex "self", param_5714
    .lex "$/", param_5715
.annotate 'line', 1967
    find_lex $P5716, "$/"
    find_lex $P5719, "$/"
    unless_null $P5719, vivify_2739
    $P5719 = root_new ['parrot';'Hash']
  vivify_2739:
    set $P5720, $P5719["quote"]
    unless_null $P5720, vivify_2740
    new $P5720, "Undef"
  vivify_2740:
    if $P5720, if_5718
    find_lex $P5724, "$/"
    unless_null $P5724, vivify_2741
    $P5724 = root_new ['parrot';'Hash']
  vivify_2741:
    set $P5725, $P5724["number"]
    unless_null $P5725, vivify_2742
    new $P5725, "Undef"
  vivify_2742:
    $P5726 = $P5725."ast"()
    set $P5717, $P5726
    goto if_5718_end
  if_5718:
    find_lex $P5721, "$/"
    unless_null $P5721, vivify_2743
    $P5721 = root_new ['parrot';'Hash']
  vivify_2743:
    set $P5722, $P5721["quote"]
    unless_null $P5722, vivify_2744
    new $P5722, "Undef"
  vivify_2744:
    $P5723 = $P5722."ast"()
    set $P5717, $P5723
  if_5718_end:
    $P5727 = $P5716."!make"($P5717)
.annotate 'line', 1966
    .return ($P5727)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "number"  :subid("560_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_5729
    .param pmc param_5730
.annotate 'line', 1970
    .lex "self", param_5729
    .lex "$/", param_5730
.annotate 'line', 1971
    new $P5731, "Undef"
    .lex "$value", $P5731
    find_lex $P5734, "$/"
    unless_null $P5734, vivify_2745
    $P5734 = root_new ['parrot';'Hash']
  vivify_2745:
    set $P5735, $P5734["dec_number"]
    unless_null $P5735, vivify_2746
    new $P5735, "Undef"
  vivify_2746:
    if $P5735, if_5733
    find_lex $P5739, "$/"
    unless_null $P5739, vivify_2747
    $P5739 = root_new ['parrot';'Hash']
  vivify_2747:
    set $P5740, $P5739["integer"]
    unless_null $P5740, vivify_2748
    new $P5740, "Undef"
  vivify_2748:
    $P5741 = $P5740."ast"()
    set $P5732, $P5741
    goto if_5733_end
  if_5733:
    find_lex $P5736, "$/"
    unless_null $P5736, vivify_2749
    $P5736 = root_new ['parrot';'Hash']
  vivify_2749:
    set $P5737, $P5736["dec_number"]
    unless_null $P5737, vivify_2750
    new $P5737, "Undef"
  vivify_2750:
    $P5738 = $P5737."ast"()
    set $P5732, $P5738
  if_5733_end:
    store_lex "$value", $P5732
.annotate 'line', 1972
    find_lex $P5743, "$/"
    unless_null $P5743, vivify_2751
    $P5743 = root_new ['parrot';'Hash']
  vivify_2751:
    set $P5744, $P5743["sign"]
    unless_null $P5744, vivify_2752
    new $P5744, "Undef"
  vivify_2752:
    set $S5745, $P5744
    iseq $I5746, $S5745, "-"
    unless $I5746, if_5742_end
    find_lex $P5747, "$value"
    unless_null $P5747, vivify_2753
    new $P5747, "Undef"
  vivify_2753:
    neg $P5748, $P5747
    store_lex "$value", $P5748
  if_5742_end:
.annotate 'line', 1973
    find_lex $P5749, "$/"
    get_hll_global $P5750, "GLOBAL"
    nqp_get_package_through_who $P5751, $P5750, "PAST"
    get_who $P5752, $P5751
    set $P5753, $P5752["Val"]
    find_lex $P5754, "$value"
    unless_null $P5754, vivify_2754
    new $P5754, "Undef"
  vivify_2754:
    $P5755 = $P5753."new"($P5754 :named("value"))
    $P5756 = $P5749."!make"($P5755)
.annotate 'line', 1970
    .return ($P5756)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<apos>"  :subid("561_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_5758
    .param pmc param_5759
.annotate 'line', 1976
    .lex "self", param_5758
    .lex "$/", param_5759
    find_lex $P5760, "$/"
    find_lex $P5761, "$/"
    unless_null $P5761, vivify_2755
    $P5761 = root_new ['parrot';'Hash']
  vivify_2755:
    set $P5762, $P5761["quote_EXPR"]
    unless_null $P5762, vivify_2756
    new $P5762, "Undef"
  vivify_2756:
    $P5763 = $P5762."ast"()
    $P5764 = $P5760."!make"($P5763)
    .return ($P5764)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<dblq>"  :subid("562_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_5766
    .param pmc param_5767
.annotate 'line', 1977
    .lex "self", param_5766
    .lex "$/", param_5767
    find_lex $P5768, "$/"
    find_lex $P5769, "$/"
    unless_null $P5769, vivify_2757
    $P5769 = root_new ['parrot';'Hash']
  vivify_2757:
    set $P5770, $P5769["quote_EXPR"]
    unless_null $P5770, vivify_2758
    new $P5770, "Undef"
  vivify_2758:
    $P5771 = $P5770."ast"()
    $P5772 = $P5768."!make"($P5771)
    .return ($P5772)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<qq>"  :subid("563_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_5774
    .param pmc param_5775
.annotate 'line', 1978
    .lex "self", param_5774
    .lex "$/", param_5775
    find_lex $P5776, "$/"
    find_lex $P5777, "$/"
    unless_null $P5777, vivify_2759
    $P5777 = root_new ['parrot';'Hash']
  vivify_2759:
    set $P5778, $P5777["quote_EXPR"]
    unless_null $P5778, vivify_2760
    new $P5778, "Undef"
  vivify_2760:
    $P5779 = $P5778."ast"()
    $P5780 = $P5776."!make"($P5779)
    .return ($P5780)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<q>"  :subid("564_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_5782
    .param pmc param_5783
.annotate 'line', 1979
    .lex "self", param_5782
    .lex "$/", param_5783
    find_lex $P5784, "$/"
    find_lex $P5785, "$/"
    unless_null $P5785, vivify_2761
    $P5785 = root_new ['parrot';'Hash']
  vivify_2761:
    set $P5786, $P5785["quote_EXPR"]
    unless_null $P5786, vivify_2762
    new $P5786, "Undef"
  vivify_2762:
    $P5787 = $P5786."ast"()
    $P5788 = $P5784."!make"($P5787)
    .return ($P5788)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q>"  :subid("565_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_5790
    .param pmc param_5791
.annotate 'line', 1980
    .lex "self", param_5790
    .lex "$/", param_5791
    find_lex $P5792, "$/"
    find_lex $P5793, "$/"
    unless_null $P5793, vivify_2763
    $P5793 = root_new ['parrot';'Hash']
  vivify_2763:
    set $P5794, $P5793["quote_EXPR"]
    unless_null $P5794, vivify_2764
    new $P5794, "Undef"
  vivify_2764:
    $P5795 = $P5794."ast"()
    $P5796 = $P5792."!make"($P5795)
    .return ($P5796)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q:PIR>"  :subid("566_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_5798
    .param pmc param_5799
.annotate 'line', 1981
    .lex "self", param_5798
    .lex "$/", param_5799
.annotate 'line', 1982
    find_lex $P5800, "$/"
    get_hll_global $P5801, "GLOBAL"
    nqp_get_package_through_who $P5802, $P5801, "PAST"
    get_who $P5803, $P5802
    set $P5804, $P5803["Op"]
    find_lex $P5805, "$/"
    unless_null $P5805, vivify_2765
    $P5805 = root_new ['parrot';'Hash']
  vivify_2765:
    set $P5806, $P5805["quote_EXPR"]
    unless_null $P5806, vivify_2766
    new $P5806, "Undef"
  vivify_2766:
    $P5807 = $P5806."ast"()
    $P5808 = $P5807."value"()
    find_lex $P5809, "$/"
    unless_null $P5809, vivify_2767
    new $P5809, "Undef"
  vivify_2767:
    $P5810 = $P5804."new"($P5808 :named("inline"), "inline" :named("pasttype"), $P5809 :named("node"))
    $P5811 = $P5800."!make"($P5810)
.annotate 'line', 1981
    .return ($P5811)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "quote:sym</ />"  :subid("567_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_5815
    .param pmc param_5816
    .param pmc param_5817 :optional
    .param int has_param_5817 :opt_flag
.annotate 'line', 1987
    new $P5814, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P5814, control_5813
    push_eh $P5814
    .lex "self", param_5815
    .lex "$/", param_5816
    if has_param_5817, optparam_2768
    new $P5818, "Undef"
    set param_5817, $P5818
  optparam_2768:
    .lex "$key", param_5817
.annotate 'line', 1994
    new $P5819, "Undef"
    .lex "$regex", $P5819
.annotate 'line', 1996
    new $P5820, "Undef"
    .lex "$past", $P5820
.annotate 'line', 1988
    find_lex $P5822, "$key"
    unless_null $P5822, vivify_2769
    new $P5822, "Undef"
  vivify_2769:
    set $S5823, $P5822
    iseq $I5824, $S5823, "open"
    unless $I5824, if_5821_end
.annotate 'line', 1989
    null $P5825
    get_hll_global $P5826, "GLOBAL"
    nqp_get_package_through_who $P5827, $P5826, "Regex"
    nqp_get_package_through_who $P5828, $P5827, "P6Regex"
    nqp_get_package_through_who $P5829, $P5828, "Actions"
    get_who $P5830, $P5829
    set $P5830["$REGEXNAME"], $P5825
.annotate 'line', 1990
    find_lex $P5831, "$?PACKAGE"
    get_who $P5832, $P5831
    set $P5833, $P5832["@BLOCK"]
    unless_null $P5833, vivify_2770
    $P5833 = root_new ['parrot';'ResizablePMCArray']
  vivify_2770:
    set $P5834, $P5833[0]
    unless_null $P5834, vivify_2771
    new $P5834, "Undef"
  vivify_2771:
    $P5834."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 1991
    find_lex $P5835, "$?PACKAGE"
    get_who $P5836, $P5835
    set $P5837, $P5836["@BLOCK"]
    unless_null $P5837, vivify_2772
    $P5837 = root_new ['parrot';'ResizablePMCArray']
  vivify_2772:
    set $P5838, $P5837[0]
    unless_null $P5838, vivify_2773
    new $P5838, "Undef"
  vivify_2773:
    $P5838."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 1992
    new $P5839, "Exception"
    set $P5839['type'], .CONTROL_RETURN
    new $P5840, "Integer"
    assign $P5840, 0
    setattribute $P5839, 'payload', $P5840
    throw $P5839
  if_5821_end:
.annotate 'line', 1995
    get_hll_global $P5841, "GLOBAL"
    nqp_get_package_through_who $P5842, $P5841, "Regex"
    nqp_get_package_through_who $P5843, $P5842, "P6Regex"
    nqp_get_package_through_who $P5844, $P5843, "Actions"
    get_who $P5845, $P5844
    set $P5846, $P5845["buildsub"]
    find_lex $P5847, "$/"
    unless_null $P5847, vivify_2774
    $P5847 = root_new ['parrot';'Hash']
  vivify_2774:
    set $P5848, $P5847["p6regex"]
    unless_null $P5848, vivify_2775
    new $P5848, "Undef"
  vivify_2775:
    $P5849 = $P5848."ast"()
    find_lex $P5850, "$?PACKAGE"
    get_who $P5851, $P5850
    set $P5852, $P5851["@BLOCK"]
    unless_null $P5852, vivify_2776
    $P5852 = root_new ['parrot';'ResizablePMCArray']
  vivify_2776:
    $P5853 = $P5852."shift"()
    $P5854 = $P5846($P5849, $P5853)
    store_lex "$regex", $P5854
.annotate 'line', 1997
    get_hll_global $P5855, "GLOBAL"
    nqp_get_package_through_who $P5856, $P5855, "PAST"
    get_who $P5857, $P5856
    set $P5858, $P5857["Op"]
.annotate 'line', 1999
    new $P5859, "ResizablePMCArray"
    push $P5859, "Regex"
    push $P5859, "Regex"
    find_lex $P5860, "$/"
    unless_null $P5860, vivify_2777
    new $P5860, "Undef"
  vivify_2777:
    $P5861 = "lexical_package_lookup"($P5859, $P5860)
    find_lex $P5862, "$regex"
    unless_null $P5862, vivify_2778
    new $P5862, "Undef"
  vivify_2778:
    $P5863 = $P5858."new"($P5861, $P5862, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 1997
    store_lex "$past", $P5863
.annotate 'line', 2003
    find_lex $P5864, "$regex"
    unless_null $P5864, vivify_2779
    new $P5864, "Undef"
  vivify_2779:
    find_lex $P5865, "$past"
    unless_null $P5865, vivify_2780
    $P5865 = root_new ['parrot';'Hash']
    store_lex "$past", $P5865
  vivify_2780:
    set $P5865["sink"], $P5864
.annotate 'line', 2004
    find_lex $P5866, "$/"
    find_lex $P5867, "$past"
    unless_null $P5867, vivify_2781
    new $P5867, "Undef"
  vivify_2781:
    $P5868 = $P5866."!make"($P5867)
.annotate 'line', 1987
    .return ($P5868)
  control_5813:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5869, exception, "payload"
    .return ($P5869)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<$>"  :subid("568_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_5871
    .param pmc param_5872
.annotate 'line', 2007
    .lex "self", param_5871
    .lex "$/", param_5872
    find_lex $P5873, "$/"
    find_lex $P5874, "$/"
    unless_null $P5874, vivify_2782
    $P5874 = root_new ['parrot';'Hash']
  vivify_2782:
    set $P5875, $P5874["variable"]
    unless_null $P5875, vivify_2783
    new $P5875, "Undef"
  vivify_2783:
    $P5876 = $P5875."ast"()
    $P5877 = $P5873."!make"($P5876)
    .return ($P5877)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<{ }>"  :subid("569_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_5879
    .param pmc param_5880
.annotate 'line', 2008
    .lex "self", param_5879
    .lex "$/", param_5880
.annotate 'line', 2009
    find_lex $P5881, "$/"
    get_hll_global $P5882, "GLOBAL"
    nqp_get_package_through_who $P5883, $P5882, "PAST"
    get_who $P5884, $P5883
    set $P5885, $P5884["Op"]
.annotate 'line', 2010
    find_lex $P5886, "$/"
    unless_null $P5886, vivify_2784
    $P5886 = root_new ['parrot';'Hash']
  vivify_2784:
    set $P5887, $P5886["block"]
    unless_null $P5887, vivify_2785
    new $P5887, "Undef"
  vivify_2785:
    $P5888 = $P5887."ast"()
    $P5889 = "block_immediate"($P5888)
    find_lex $P5890, "$/"
    unless_null $P5890, vivify_2786
    new $P5890, "Undef"
  vivify_2786:
    $P5891 = $P5885."new"($P5889, "set S*" :named("pirop"), $P5890 :named("node"))
.annotate 'line', 2009
    $P5892 = $P5881."!make"($P5891)
.annotate 'line', 2008
    .return ($P5892)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<esc>"  :subid("570_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_5894
    .param pmc param_5895
.annotate 'line', 2013
    .lex "self", param_5894
    .lex "$/", param_5895
    find_lex $P5896, "$/"
    $P5897 = $P5896."!make"("\e")
    .return ($P5897)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<.>"  :subid("571_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_5899
    .param pmc param_5900
.annotate 'line', 2017
    .lex "self", param_5899
    .lex "$/", param_5900
    find_lex $P5901, "$/"
    find_lex $P5902, "$/"
    unless_null $P5902, vivify_2787
    $P5902 = root_new ['parrot';'Hash']
  vivify_2787:
    set $P5903, $P5902["dotty"]
    unless_null $P5903, vivify_2788
    new $P5903, "Undef"
  vivify_2788:
    $P5904 = $P5903."ast"()
    $P5905 = $P5901."!make"($P5904)
    .return ($P5905)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<++>"  :subid("572_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_5907
    .param pmc param_5908
.annotate 'line', 2019
    .lex "self", param_5907
    .lex "$/", param_5908
.annotate 'line', 2020
    find_lex $P5909, "$/"
    get_hll_global $P5910, "GLOBAL"
    nqp_get_package_through_who $P5911, $P5910, "PAST"
    get_who $P5912, $P5911
    set $P5913, $P5912["Op"]
.annotate 'line', 2021
    new $P5914, "ResizablePMCArray"
    push $P5914, "    clone %r, %0"
    push $P5914, "    inc %0"
    $P5915 = $P5913."new"("postfix:<++>" :named("name"), $P5914 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 2020
    $P5916 = $P5909."!make"($P5915)
.annotate 'line', 2019
    .return ($P5916)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<-->"  :subid("573_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_5918
    .param pmc param_5919
.annotate 'line', 2025
    .lex "self", param_5918
    .lex "$/", param_5919
.annotate 'line', 2026
    find_lex $P5920, "$/"
    get_hll_global $P5921, "GLOBAL"
    nqp_get_package_through_who $P5922, $P5921, "PAST"
    get_who $P5923, $P5922
    set $P5924, $P5923["Op"]
.annotate 'line', 2027
    new $P5925, "ResizablePMCArray"
    push $P5925, "    clone %r, %0"
    push $P5925, "    dec %0"
    $P5926 = $P5924."new"("postfix:<-->" :named("name"), $P5925 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 2026
    $P5927 = $P5920."!make"($P5926)
.annotate 'line', 2025
    .return ($P5927)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "prefix:sym<make>"  :subid("574_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_5929
    .param pmc param_5930
.annotate 'line', 2031
    .lex "self", param_5929
    .lex "$/", param_5930
.annotate 'line', 2032
    find_lex $P5931, "$/"
    get_hll_global $P5932, "GLOBAL"
    nqp_get_package_through_who $P5933, $P5932, "PAST"
    get_who $P5934, $P5933
    set $P5935, $P5934["Op"]
.annotate 'line', 2033
    get_hll_global $P5936, "GLOBAL"
    nqp_get_package_through_who $P5937, $P5936, "PAST"
    get_who $P5938, $P5937
    set $P5939, $P5938["Var"]
    $P5940 = $P5939."new"("$/" :named("name"), "contextual" :named("scope"))
    find_lex $P5941, "$/"
    unless_null $P5941, vivify_2789
    new $P5941, "Undef"
  vivify_2789:
    $P5942 = $P5935."new"($P5940, "callmethod" :named("pasttype"), "!make" :named("name"), $P5941 :named("node"))
.annotate 'line', 2032
    $P5943 = $P5931."!make"($P5942)
.annotate 'line', 2031
    .return ($P5943)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<next>"  :subid("575_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_5946
    .param pmc param_5947
.annotate 'line', 2049
    .lex "self", param_5946
    .lex "$/", param_5947
    find_lex $P5948, "$/"
    unless_null $P5948, vivify_2790
    new $P5948, "Undef"
  vivify_2790:
    $P5949 = "control"($P5948, "CONTROL_LOOP_NEXT")
    .return ($P5949)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<last>"  :subid("576_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_5951
    .param pmc param_5952
.annotate 'line', 2050
    .lex "self", param_5951
    .lex "$/", param_5952
    find_lex $P5953, "$/"
    unless_null $P5953, vivify_2791
    new $P5953, "Undef"
  vivify_2791:
    $P5954 = "control"($P5953, "CONTROL_LOOP_LAST")
    .return ($P5954)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<redo>"  :subid("577_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_5956
    .param pmc param_5957
.annotate 'line', 2051
    .lex "self", param_5956
    .lex "$/", param_5957
    find_lex $P5958, "$/"
    unless_null $P5958, vivify_2792
    new $P5958, "Undef"
  vivify_2792:
    $P5959 = "control"($P5958, "CONTROL_LOOP_REDO")
    .return ($P5959)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "infix:sym<~~>"  :subid("578_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_5961
    .param pmc param_5962
.annotate 'line', 2053
    .lex "self", param_5961
    .lex "$/", param_5962
.annotate 'line', 2054
    find_lex $P5963, "$/"
    get_hll_global $P5964, "GLOBAL"
    nqp_get_package_through_who $P5965, $P5964, "PAST"
    get_who $P5966, $P5965
    set $P5967, $P5966["Op"]
    find_lex $P5968, "$/"
    unless_null $P5968, vivify_2793
    new $P5968, "Undef"
  vivify_2793:
    $P5969 = $P5967."new"("callmethod" :named("pasttype"), "ACCEPTS" :named("name"), $P5968 :named("node"))
    $P5970 = $P5963."!make"($P5969)
.annotate 'line', 2053
    .return ($P5970)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "known_sym"  :subid("579_1304456155.152") :outer("406_1304456155.152")
    .param pmc param_5976
    .param pmc param_5977
    .param pmc param_5978
.annotate 'line', 2131
    .const 'Sub' $P5982 = "580_1304456155.152" 
    capture_lex $P5982
    .lex "self", param_5976
    .lex "$/", param_5977
    .lex "@name", param_5978
.annotate 'line', 2132
    new $P5979, "Undef"
    .lex "$known", $P5979
    new $P5980, "Integer"
    assign $P5980, 0
    store_lex "$known", $P5980
.annotate 'line', 2133
    .const 'Sub' $P5982 = "580_1304456155.152" 
    capture_lex $P5982
    $P5982()
    find_lex $P5993, "$known"
    unless_null $P5993, vivify_2796
    new $P5993, "Undef"
  vivify_2796:
.annotate 'line', 2131
    .return ($P5993)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block5981"  :anon :subid("580_1304456155.152") :outer("579_1304456155.152")
.annotate 'line', 2133
    new $P5988, 'ExceptionHandler'
    set_label $P5988, control_5987
    $P5988."handle_types_except"(.CONTROL_RETURN,  .CONTROL_OK,  .CONTROL_BREAK,  .CONTROL_CONTINUE,  .CONTROL_TAKE,  .CONTROL_LEAVE,  .CONTROL_EXIT,  .CONTROL_LOOP_NEXT,  .CONTROL_LOOP_LAST,  .CONTROL_LOOP_REDO)
    push_eh $P5988
.annotate 'line', 2134
    find_lex $P5983, "@name"
    unless_null $P5983, vivify_2794
    $P5983 = root_new ['parrot';'ResizablePMCArray']
  vivify_2794:
    find_lex $P5984, "$/"
    unless_null $P5984, vivify_2795
    new $P5984, "Undef"
  vivify_2795:
    "find_sym"($P5983, $P5984)
.annotate 'line', 2135
    new $P5985, "Integer"
    assign $P5985, 1
    store_lex "$known", $P5985
.annotate 'line', 2133
    pop_eh 
    goto skip_handler_5986
  control_5987:
    .local pmc exception 
    .get_results (exception) 
    new $P5991, 'Integer'
    set $P5991, 1
    set exception["handled"], $P5991
    set $I5992, exception["handled"]
    ne $I5992, 1, nothandled_5990
  handled_5989:
    .return (exception)
  nothandled_5990:
    rethrow exception
  skip_handler_5986:
    .return ($P5985)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "_block5995"  :subid("581_1304456155.152") :outer("10_1304456155.152")
.annotate 'line', 2200
    .const 'Sub' $P6089 = "588_1304456155.152" 
    capture_lex $P6089
    .const 'Sub' $P6075 = "587_1304456155.152" 
    capture_lex $P6075
    .const 'Sub' $P6057 = "586_1304456155.152" 
    capture_lex $P6057
    .const 'Sub' $P6043 = "585_1304456155.152" 
    capture_lex $P6043
    .const 'Sub' $P6029 = "584_1304456155.152" 
    capture_lex $P6029
    .const 'Sub' $P6015 = "583_1304456155.152" 
    capture_lex $P6015
    .const 'Sub' $P5999 = "582_1304456155.152" 
    capture_lex $P5999
    .lex "$?PACKAGE", $P5997
    .lex "$?CLASS", $P5998
.annotate 'line', 2234
    .const 'Sub' $P6089 = "588_1304456155.152" 
    newclosure $P6127, $P6089
.annotate 'line', 2200
    .return ($P6127)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<:my>"  :subid("582_1304456155.152") :outer("581_1304456155.152")
    .param pmc param_6000
    .param pmc param_6001
.annotate 'line', 2202
    .lex "self", param_6000
    .lex "$/", param_6001
.annotate 'line', 2203
    new $P6002, "Undef"
    .lex "$past", $P6002
    find_lex $P6003, "$/"
    unless_null $P6003, vivify_2797
    $P6003 = root_new ['parrot';'Hash']
  vivify_2797:
    set $P6004, $P6003["statement"]
    unless_null $P6004, vivify_2798
    new $P6004, "Undef"
  vivify_2798:
    $P6005 = $P6004."ast"()
    store_lex "$past", $P6005
.annotate 'line', 2204
    find_lex $P6006, "$/"
    get_hll_global $P6007, "GLOBAL"
    nqp_get_package_through_who $P6008, $P6007, "PAST"
    get_who $P6009, $P6008
    set $P6010, $P6009["Regex"]
    find_lex $P6011, "$past"
    unless_null $P6011, vivify_2799
    new $P6011, "Undef"
  vivify_2799:
    find_lex $P6012, "$/"
    unless_null $P6012, vivify_2800
    new $P6012, "Undef"
  vivify_2800:
    $P6013 = $P6010."new"($P6011, "pastnode" :named("pasttype"), "declarative" :named("subtype"), $P6012 :named("node"))
    $P6014 = $P6006."!make"($P6013)
.annotate 'line', 2202
    .return ($P6014)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<{ }>"  :subid("583_1304456155.152") :outer("581_1304456155.152")
    .param pmc param_6016
    .param pmc param_6017
.annotate 'line', 2208
    .lex "self", param_6016
    .lex "$/", param_6017
.annotate 'line', 2209
    find_lex $P6018, "$/"
    get_hll_global $P6019, "GLOBAL"
    nqp_get_package_through_who $P6020, $P6019, "PAST"
    get_who $P6021, $P6020
    set $P6022, $P6021["Regex"]
    find_lex $P6023, "$/"
    unless_null $P6023, vivify_2801
    $P6023 = root_new ['parrot';'Hash']
  vivify_2801:
    set $P6024, $P6023["codeblock"]
    unless_null $P6024, vivify_2802
    new $P6024, "Undef"
  vivify_2802:
    $P6025 = $P6024."ast"()
    find_lex $P6026, "$/"
    unless_null $P6026, vivify_2803
    new $P6026, "Undef"
  vivify_2803:
    $P6027 = $P6022."new"($P6025, "pastnode" :named("pasttype"), $P6026 :named("node"))
    $P6028 = $P6018."!make"($P6027)
.annotate 'line', 2208
    .return ($P6028)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<nqpvar>"  :subid("584_1304456155.152") :outer("581_1304456155.152")
    .param pmc param_6030
    .param pmc param_6031
.annotate 'line', 2213
    .lex "self", param_6030
    .lex "$/", param_6031
.annotate 'line', 2214
    find_lex $P6032, "$/"
    get_hll_global $P6033, "GLOBAL"
    nqp_get_package_through_who $P6034, $P6033, "PAST"
    get_who $P6035, $P6034
    set $P6036, $P6035["Regex"]
    find_lex $P6037, "$/"
    unless_null $P6037, vivify_2804
    $P6037 = root_new ['parrot';'Hash']
  vivify_2804:
    set $P6038, $P6037["var"]
    unless_null $P6038, vivify_2805
    new $P6038, "Undef"
  vivify_2805:
    $P6039 = $P6038."ast"()
    find_lex $P6040, "$/"
    unless_null $P6040, vivify_2806
    new $P6040, "Undef"
  vivify_2806:
    $P6041 = $P6036."new"("!INTERPOLATE", $P6039, "subrule" :named("pasttype"), "method" :named("subtype"), $P6040 :named("node"))
    $P6042 = $P6032."!make"($P6041)
.annotate 'line', 2213
    .return ($P6042)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<{ }>"  :subid("585_1304456155.152") :outer("581_1304456155.152")
    .param pmc param_6044
    .param pmc param_6045
.annotate 'line', 2218
    .lex "self", param_6044
    .lex "$/", param_6045
.annotate 'line', 2219
    find_lex $P6046, "$/"
    get_hll_global $P6047, "GLOBAL"
    nqp_get_package_through_who $P6048, $P6047, "PAST"
    get_who $P6049, $P6048
    set $P6050, $P6049["Regex"]
    find_lex $P6051, "$/"
    unless_null $P6051, vivify_2807
    $P6051 = root_new ['parrot';'Hash']
  vivify_2807:
    set $P6052, $P6051["codeblock"]
    unless_null $P6052, vivify_2808
    new $P6052, "Undef"
  vivify_2808:
    $P6053 = $P6052."ast"()
    find_lex $P6054, "$/"
    unless_null $P6054, vivify_2809
    new $P6054, "Undef"
  vivify_2809:
    $P6055 = $P6050."new"("!INTERPOLATE_REGEX", $P6053, "subrule" :named("pasttype"), "method" :named("subtype"), $P6054 :named("node"))
    $P6056 = $P6046."!make"($P6055)
.annotate 'line', 2218
    .return ($P6056)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<?{ }>"  :subid("586_1304456155.152") :outer("581_1304456155.152")
    .param pmc param_6058
    .param pmc param_6059
.annotate 'line', 2223
    .lex "self", param_6058
    .lex "$/", param_6059
.annotate 'line', 2224
    find_lex $P6060, "$/"
    get_hll_global $P6061, "GLOBAL"
    nqp_get_package_through_who $P6062, $P6061, "PAST"
    get_who $P6063, $P6062
    set $P6064, $P6063["Regex"]
    find_lex $P6065, "$/"
    unless_null $P6065, vivify_2810
    $P6065 = root_new ['parrot';'Hash']
  vivify_2810:
    set $P6066, $P6065["codeblock"]
    unless_null $P6066, vivify_2811
    new $P6066, "Undef"
  vivify_2811:
    $P6067 = $P6066."ast"()
.annotate 'line', 2225
    find_lex $P6068, "$/"
    unless_null $P6068, vivify_2812
    $P6068 = root_new ['parrot';'Hash']
  vivify_2812:
    set $P6069, $P6068["zw"]
    unless_null $P6069, vivify_2813
    new $P6069, "Undef"
  vivify_2813:
    set $S6070, $P6069
    iseq $I6071, $S6070, "!"
    find_lex $P6072, "$/"
    unless_null $P6072, vivify_2814
    new $P6072, "Undef"
  vivify_2814:
    $P6073 = $P6064."new"($P6067, "zerowidth" :named("subtype"), $I6071 :named("negate"), "pastnode" :named("pasttype"), $P6072 :named("node"))
.annotate 'line', 2224
    $P6074 = $P6060."!make"($P6073)
.annotate 'line', 2223
    .return ($P6074)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<var>"  :subid("587_1304456155.152") :outer("581_1304456155.152")
    .param pmc param_6076
    .param pmc param_6077
.annotate 'line', 2229
    .lex "self", param_6076
    .lex "$/", param_6077
.annotate 'line', 2230
    find_lex $P6078, "$/"
    get_hll_global $P6079, "GLOBAL"
    nqp_get_package_through_who $P6080, $P6079, "PAST"
    get_who $P6081, $P6080
    set $P6082, $P6081["Regex"]
    find_lex $P6083, "$/"
    unless_null $P6083, vivify_2815
    $P6083 = root_new ['parrot';'Hash']
  vivify_2815:
    set $P6084, $P6083["var"]
    unless_null $P6084, vivify_2816
    new $P6084, "Undef"
  vivify_2816:
    $P6085 = $P6084."ast"()
    find_lex $P6086, "$/"
    unless_null $P6086, vivify_2817
    new $P6086, "Undef"
  vivify_2817:
    $P6087 = $P6082."new"("!INTERPOLATE_REGEX", $P6085, "subrule" :named("pasttype"), "method" :named("subtype"), $P6086 :named("node"))
    $P6088 = $P6078."!make"($P6087)
.annotate 'line', 2229
    .return ($P6088)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "codeblock"  :subid("588_1304456155.152") :outer("581_1304456155.152")
    .param pmc param_6090
    .param pmc param_6091
.annotate 'line', 2234
    .lex "self", param_6090
    .lex "$/", param_6091
.annotate 'line', 2235
    new $P6092, "Undef"
    .lex "$block", $P6092
.annotate 'line', 2237
    new $P6093, "Undef"
    .lex "$past", $P6093
.annotate 'line', 2235
    find_lex $P6094, "$/"
    unless_null $P6094, vivify_2818
    $P6094 = root_new ['parrot';'Hash']
  vivify_2818:
    set $P6095, $P6094["block"]
    unless_null $P6095, vivify_2819
    new $P6095, "Undef"
  vivify_2819:
    $P6096 = $P6095."ast"()
    store_lex "$block", $P6096
.annotate 'line', 2236
    find_lex $P6097, "$block"
    unless_null $P6097, vivify_2820
    new $P6097, "Undef"
  vivify_2820:
    $P6097."blocktype"("immediate")
.annotate 'line', 2238
    get_hll_global $P6098, "GLOBAL"
    nqp_get_package_through_who $P6099, $P6098, "PAST"
    get_who $P6100, $P6099
    set $P6101, $P6100["Stmts"]
.annotate 'line', 2239
    get_hll_global $P6102, "GLOBAL"
    nqp_get_package_through_who $P6103, $P6102, "PAST"
    get_who $P6104, $P6103
    set $P6105, $P6104["Op"]
.annotate 'line', 2240
    get_hll_global $P6106, "GLOBAL"
    nqp_get_package_through_who $P6107, $P6106, "PAST"
    get_who $P6108, $P6107
    set $P6109, $P6108["Var"]
    $P6110 = $P6109."new"("$/" :named("name"))
.annotate 'line', 2241
    get_hll_global $P6111, "GLOBAL"
    nqp_get_package_through_who $P6112, $P6111, "PAST"
    get_who $P6113, $P6112
    set $P6114, $P6113["Op"]
.annotate 'line', 2242
    get_hll_global $P6115, "GLOBAL"
    nqp_get_package_through_who $P6116, $P6115, "PAST"
    get_who $P6117, $P6116
    set $P6118, $P6117["Var"]
    $P6119 = $P6118."new"(unicode:"$\x{a2}" :named("name"))
    $P6120 = $P6114."new"($P6119, "MATCH" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 2241
    $P6121 = $P6105."new"($P6110, $P6120, "bind" :named("pasttype"))
.annotate 'line', 2239
    find_lex $P6122, "$block"
    unless_null $P6122, vivify_2821
    new $P6122, "Undef"
  vivify_2821:
    $P6123 = $P6101."new"($P6121, $P6122)
.annotate 'line', 2238
    store_lex "$past", $P6123
.annotate 'line', 2250
    find_lex $P6124, "$/"
    find_lex $P6125, "$past"
    unless_null $P6125, vivify_2822
    new $P6125, "Undef"
  vivify_2822:
    $P6126 = $P6124."!make"($P6125)
.annotate 'line', 2234
    .return ($P6126)
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "_block6128"  :subid("589_1304456155.152") :outer("10_1304456155.152")
.annotate 'line', 2255
    .lex "$?PACKAGE", $P6130
    .lex "$?CLASS", $P6131
    .return ()
.end


.HLL "nqp"

.namespace []
.sub "_block6139" :load :anon :subid("590_1304456155.152")
.annotate 'line', 1
    .const 'Sub' $P6141 = "10_1304456155.152" 
    $P6142 = $P6141()
    .return ($P6142)
.end

