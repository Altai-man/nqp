.include 'cclass.pasm'
.include 'except_severity.pasm'
.include 'except_types.pasm'
.include 'iglobals.pasm'
.include 'interpinfo.pasm'
.include 'iterator.pasm'
.include 'sysinfo.pasm'

.HLL "nqp"

.loadlib "nqp_group"

.loadlib "nqp_ops"

.loadlib "trans_ops"

.loadlib "io_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1307873304.82979")
    .param pmc param_13 :slurpy
.annotate 'line', 0
    .const 'Sub' $P7343 = "627_1307873304.82979" 
    capture_lex $P7343
    .const 'Sub' $P7210 = "619_1307873304.82979" 
    capture_lex $P7210
    .const 'Sub' $P2941 = "438_1307873304.82979" 
    capture_lex $P2941
    .const 'Sub' $P2876 = "417_1307873304.82979" 
    capture_lex $P2876
    .const 'Sub' $P986 = "40_1307873304.82979" 
    capture_lex $P986
    .const 'Sub' $P57 = "13_1307873304.82979" 
    capture_lex $P57
    .const 'Sub' $P49 = "12_1307873304.82979" 
    capture_lex $P49
    .const 'Sub' $P16 = "11_1307873304.82979" 
    capture_lex $P16
.annotate 'line', 1
    .lex "@ARGS", param_13
    .lex "GLOBALish", $P14
    .lex "$?PACKAGE", $P15
.annotate 'line', 2766
    .const 'Sub' $P16 = "11_1307873304.82979" 
    newclosure $P48, $P16
    .lex "MAIN", $P48
.annotate 'line', 2787
    .const 'Sub' $P49 = "12_1307873304.82979" 
    newclosure $P55, $P49
    .lex "hll-config", $P55
.annotate 'line', 1
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
.annotate 'line', 9
    .const 'Sub' $P57 = "13_1307873304.82979" 
    capture_lex $P57
    $P57()
.annotate 'line', 435
    .const 'Sub' $P986 = "40_1307873304.82979" 
    capture_lex $P986
    $P986()
.annotate 'line', 1162
    .const 'Sub' $P2876 = "417_1307873304.82979" 
    capture_lex $P2876
    $P2876()
.annotate 'line', 1205
    .const 'Sub' $P2941 = "438_1307873304.82979" 
    capture_lex $P2941
    $P2941()
.annotate 'line', 2708
    .const 'Sub' $P7210 = "619_1307873304.82979" 
    capture_lex $P7210
    $P7210()
.annotate 'line', 2763
    .const 'Sub' $P7343 = "627_1307873304.82979" 
    capture_lex $P7343
    $P7343()
    find_lex $P7346, "MAIN"
    find_lex $P7347, "hll-config"
    find_lex $P7350, "@ARGS"
    if $P7350, if_7349
    set $P7348, $P7350
    goto if_7349_end
  if_7349:
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P7351, "ModuleLoader"
    getinterp $P7352
    set $P7353, $P7352["context"]
    $P7351."set_mainline_module"($P7353)
    .const 'Sub' $P7354 = "11_1307873304.82979" 
    find_lex $P7355, "@ARGS"
    $P7356 = $P7354($P7355 :flat)
    set $P7348, $P7356
  if_7349_end:
.annotate 'line', 1
    .return ($P7348)
    .const 'Sub' $P7358 = "628_1307873304.82979" 
    .return ($P7358)
.end


.HLL "nqp"

.namespace []
.sub "" :load :init :subid("post629") :outer("10_1307873304.82979")
.annotate 'line', 0
    .const 'Sub' $P12 = "10_1307873304.82979" 
    .local pmc block
    set block, $P12
    nqp_get_sc $P7362, "1307873293.85412"
    isnull $I7363, $P7362
    if $I7363, if_7361
    .const 'Sub' $P9568 = "10_1307873304.82979" 
    $P9569 = $P9568."get_lexinfo"()
    nqp_get_sc_object $P9570, "1307873293.85412", 0
    $P9569."set_static_lexpad_value"("GLOBALish", $P9570)
    .const 'Sub' $P9571 = "10_1307873304.82979" 
    $P9572 = $P9571."get_lexinfo"()
    $P9572."finish_static_lexpad"()
    .const 'Sub' $P9573 = "10_1307873304.82979" 
    $P9574 = $P9573."get_lexinfo"()
    nqp_get_sc_object $P9575, "1307873293.85412", 0
    $P9574."set_static_lexpad_value"("$?PACKAGE", $P9575)
    .const 'Sub' $P9576 = "10_1307873304.82979" 
    $P9577 = $P9576."get_lexinfo"()
    $P9577."finish_static_lexpad"()
    nqp_get_sc_object $P9578, "1307873293.85412", 2
    .const 'Sub' $P9579 = "14_1307873304.82979" 
    assign $P9578, $P9579
    nqp_get_sc_object $P9580, "1307873293.85412", 3
    .const 'Sub' $P9581 = "16_1307873304.82979" 
    assign $P9580, $P9581
    nqp_get_sc_object $P9582, "1307873293.85412", 4
    .const 'Sub' $P9583 = "17_1307873304.82979" 
    assign $P9582, $P9583
    nqp_get_sc_object $P9584, "1307873293.85412", 5
    .const 'Sub' $P9585 = "20_1307873304.82979" 
    assign $P9584, $P9585
    nqp_get_sc_object $P9586, "1307873293.85412", 6
    .const 'Sub' $P9587 = "21_1307873304.82979" 
    assign $P9586, $P9587
    nqp_get_sc_object $P9588, "1307873293.85412", 7
    .const 'Sub' $P9589 = "22_1307873304.82979" 
    assign $P9588, $P9589
    nqp_get_sc_object $P9590, "1307873293.85412", 8
    .const 'Sub' $P9591 = "23_1307873304.82979" 
    assign $P9590, $P9591
    nqp_get_sc_object $P9592, "1307873293.85412", 9
    .const 'Sub' $P9593 = "26_1307873304.82979" 
    assign $P9592, $P9593
    nqp_get_sc_object $P9594, "1307873293.85412", 10
    .const 'Sub' $P9595 = "29_1307873304.82979" 
    assign $P9594, $P9595
    nqp_get_sc_object $P9596, "1307873293.85412", 11
    .const 'Sub' $P9597 = "30_1307873304.82979" 
    assign $P9596, $P9597
    nqp_get_sc_object $P9598, "1307873293.85412", 12
    .const 'Sub' $P9599 = "35_1307873304.82979" 
    assign $P9598, $P9599
    nqp_get_sc_object $P9600, "1307873293.85412", 13
    .const 'Sub' $P9601 = "36_1307873304.82979" 
    assign $P9600, $P9601
    nqp_get_sc_object $P9602, "1307873293.85412", 14
    .const 'Sub' $P9603 = "37_1307873304.82979" 
    assign $P9602, $P9603
    nqp_get_sc_object $P9604, "1307873293.85412", 15
    .const 'Sub' $P9605 = "38_1307873304.82979" 
    assign $P9604, $P9605
    .const 'Sub' $P9606 = "13_1307873304.82979" 
    $P9607 = $P9606."get_lexinfo"()
    nqp_get_sc_object $P9608, "1307873293.85412", 1
    $P9607."set_static_lexpad_value"("$?PACKAGE", $P9608)
    .const 'Sub' $P9609 = "13_1307873304.82979" 
    $P9610 = $P9609."get_lexinfo"()
    $P9610."finish_static_lexpad"()
    .const 'Sub' $P9611 = "13_1307873304.82979" 
    $P9612 = $P9611."get_lexinfo"()
    nqp_get_sc_object $P9613, "1307873293.85412", 1
    $P9612."set_static_lexpad_value"("$?CLASS", $P9613)
    .const 'Sub' $P9614 = "13_1307873304.82979" 
    $P9615 = $P9614."get_lexinfo"()
    $P9615."finish_static_lexpad"()
    nqp_get_sc_object $P9616, "1307873293.85412", 17
    .const 'Sub' $P9617 = "41_1307873304.82979" 
    assign $P9616, $P9617
    nqp_get_sc_object $P9618, "1307873293.85412", 18
    .const 'Sub' $P9619 = "42_1307873304.82979" 
    assign $P9618, $P9619
    nqp_get_sc_object $P9620, "1307873293.85412", 19
    .const 'Sub' $P9621 = "43_1307873304.82979" 
    assign $P9620, $P9621
    nqp_get_sc_object $P9622, "1307873293.85412", 20
    .const 'Sub' $P9623 = "44_1307873304.82979" 
    assign $P9622, $P9623
    nqp_get_sc_object $P9624, "1307873293.85412", 21
    .const 'Sub' $P9625 = "45_1307873304.82979" 
    assign $P9624, $P9625
    nqp_get_sc_object $P9626, "1307873293.85412", 22
    .const 'Sub' $P9627 = "46_1307873304.82979" 
    assign $P9626, $P9627
    nqp_get_sc_object $P9628, "1307873293.85412", 23
    .const 'Sub' $P9629 = "47_1307873304.82979" 
    assign $P9628, $P9629
    nqp_get_sc_object $P9630, "1307873293.85412", 24
    .const 'Sub' $P9631 = "48_1307873304.82979" 
    assign $P9630, $P9631
    nqp_get_sc_object $P9632, "1307873293.85412", 25
    .const 'Sub' $P9633 = "49_1307873304.82979" 
    assign $P9632, $P9633
    nqp_get_sc_object $P9634, "1307873293.85412", 26
    .const 'Sub' $P9635 = "50_1307873304.82979" 
    assign $P9634, $P9635
    nqp_get_sc_object $P9636, "1307873293.85412", 27
    .const 'Sub' $P9637 = "51_1307873304.82979" 
    assign $P9636, $P9637
    nqp_get_sc_object $P9638, "1307873293.85412", 28
    .const 'Sub' $P9639 = "52_1307873304.82979" 
    assign $P9638, $P9639
    nqp_get_sc_object $P9640, "1307873293.85412", 29
    .const 'Sub' $P9641 = "54_1307873304.82979" 
    assign $P9640, $P9641
    nqp_get_sc_object $P9642, "1307873293.85412", 30
    .const 'Sub' $P9643 = "55_1307873304.82979" 
    assign $P9642, $P9643
    nqp_get_sc_object $P9644, "1307873293.85412", 31
    .const 'Sub' $P9645 = "57_1307873304.82979" 
    assign $P9644, $P9645
    nqp_get_sc_object $P9646, "1307873293.85412", 32
    .const 'Sub' $P9647 = "58_1307873304.82979" 
    assign $P9646, $P9647
    nqp_get_sc_object $P9648, "1307873293.85412", 33
    .const 'Sub' $P9649 = "59_1307873304.82979" 
    assign $P9648, $P9649
    nqp_get_sc_object $P9650, "1307873293.85412", 34
    .const 'Sub' $P9651 = "60_1307873304.82979" 
    assign $P9650, $P9651
    nqp_get_sc_object $P9652, "1307873293.85412", 35
    .const 'Sub' $P9653 = "61_1307873304.82979" 
    assign $P9652, $P9653
    nqp_get_sc_object $P9654, "1307873293.85412", 36
    .const 'Sub' $P9655 = "62_1307873304.82979" 
    assign $P9654, $P9655
    nqp_get_sc_object $P9656, "1307873293.85412", 37
    .const 'Sub' $P9657 = "64_1307873304.82979" 
    assign $P9656, $P9657
    nqp_get_sc_object $P9658, "1307873293.85412", 38
    .const 'Sub' $P9659 = "65_1307873304.82979" 
    assign $P9658, $P9659
    nqp_get_sc_object $P9660, "1307873293.85412", 39
    .const 'Sub' $P9661 = "66_1307873304.82979" 
    assign $P9660, $P9661
    nqp_get_sc_object $P9662, "1307873293.85412", 40
    .const 'Sub' $P9663 = "67_1307873304.82979" 
    assign $P9662, $P9663
    nqp_get_sc_object $P9664, "1307873293.85412", 41
    .const 'Sub' $P9665 = "68_1307873304.82979" 
    assign $P9664, $P9665
    nqp_get_sc_object $P9666, "1307873293.85412", 42
    .const 'Sub' $P9667 = "69_1307873304.82979" 
    assign $P9666, $P9667
    nqp_get_sc_object $P9668, "1307873293.85412", 43
    .const 'Sub' $P9669 = "70_1307873304.82979" 
    assign $P9668, $P9669
    nqp_get_sc_object $P9670, "1307873293.85412", 44
    .const 'Sub' $P9671 = "71_1307873304.82979" 
    assign $P9670, $P9671
    nqp_get_sc_object $P9672, "1307873293.85412", 45
    .const 'Sub' $P9673 = "72_1307873304.82979" 
    assign $P9672, $P9673
    nqp_get_sc_object $P9674, "1307873293.85412", 46
    .const 'Sub' $P9675 = "73_1307873304.82979" 
    assign $P9674, $P9675
    nqp_get_sc_object $P9676, "1307873293.85412", 47
    .const 'Sub' $P9677 = "74_1307873304.82979" 
    assign $P9676, $P9677
    nqp_get_sc_object $P9678, "1307873293.85412", 48
    .const 'Sub' $P9679 = "75_1307873304.82979" 
    assign $P9678, $P9679
    nqp_get_sc_object $P9680, "1307873293.85412", 49
    .const 'Sub' $P9681 = "76_1307873304.82979" 
    assign $P9680, $P9681
    nqp_get_sc_object $P9682, "1307873293.85412", 50
    .const 'Sub' $P9683 = "77_1307873304.82979" 
    assign $P9682, $P9683
    nqp_get_sc_object $P9684, "1307873293.85412", 51
    .const 'Sub' $P9685 = "78_1307873304.82979" 
    assign $P9684, $P9685
    nqp_get_sc_object $P9686, "1307873293.85412", 52
    .const 'Sub' $P9687 = "79_1307873304.82979" 
    assign $P9686, $P9687
    nqp_get_sc_object $P9688, "1307873293.85412", 53
    .const 'Sub' $P9689 = "80_1307873304.82979" 
    assign $P9688, $P9689
    nqp_get_sc_object $P9690, "1307873293.85412", 54
    .const 'Sub' $P9691 = "81_1307873304.82979" 
    assign $P9690, $P9691
    nqp_get_sc_object $P9692, "1307873293.85412", 55
    .const 'Sub' $P9693 = "82_1307873304.82979" 
    assign $P9692, $P9693
    nqp_get_sc_object $P9694, "1307873293.85412", 56
    .const 'Sub' $P9695 = "83_1307873304.82979" 
    assign $P9694, $P9695
    nqp_get_sc_object $P9696, "1307873293.85412", 57
    .const 'Sub' $P9697 = "84_1307873304.82979" 
    assign $P9696, $P9697
    nqp_get_sc_object $P9698, "1307873293.85412", 58
    .const 'Sub' $P9699 = "85_1307873304.82979" 
    assign $P9698, $P9699
    nqp_get_sc_object $P9700, "1307873293.85412", 59
    .const 'Sub' $P9701 = "86_1307873304.82979" 
    assign $P9700, $P9701
    nqp_get_sc_object $P9702, "1307873293.85412", 60
    .const 'Sub' $P9703 = "87_1307873304.82979" 
    assign $P9702, $P9703
    nqp_get_sc_object $P9704, "1307873293.85412", 61
    .const 'Sub' $P9705 = "88_1307873304.82979" 
    assign $P9704, $P9705
    nqp_get_sc_object $P9706, "1307873293.85412", 62
    .const 'Sub' $P9707 = "89_1307873304.82979" 
    assign $P9706, $P9707
    nqp_get_sc_object $P9708, "1307873293.85412", 63
    .const 'Sub' $P9709 = "90_1307873304.82979" 
    assign $P9708, $P9709
    nqp_get_sc_object $P9710, "1307873293.85412", 64
    .const 'Sub' $P9711 = "91_1307873304.82979" 
    assign $P9710, $P9711
    nqp_get_sc_object $P9712, "1307873293.85412", 65
    .const 'Sub' $P9713 = "92_1307873304.82979" 
    assign $P9712, $P9713
    nqp_get_sc_object $P9714, "1307873293.85412", 66
    .const 'Sub' $P9715 = "93_1307873304.82979" 
    assign $P9714, $P9715
    nqp_get_sc_object $P9716, "1307873293.85412", 67
    .const 'Sub' $P9717 = "94_1307873304.82979" 
    assign $P9716, $P9717
    nqp_get_sc_object $P9718, "1307873293.85412", 68
    .const 'Sub' $P9719 = "95_1307873304.82979" 
    assign $P9718, $P9719
    nqp_get_sc_object $P9720, "1307873293.85412", 69
    .const 'Sub' $P9721 = "96_1307873304.82979" 
    assign $P9720, $P9721
    nqp_get_sc_object $P9722, "1307873293.85412", 70
    .const 'Sub' $P9723 = "97_1307873304.82979" 
    assign $P9722, $P9723
    nqp_get_sc_object $P9724, "1307873293.85412", 71
    .const 'Sub' $P9725 = "98_1307873304.82979" 
    assign $P9724, $P9725
    nqp_get_sc_object $P9726, "1307873293.85412", 72
    .const 'Sub' $P9727 = "99_1307873304.82979" 
    assign $P9726, $P9727
    nqp_get_sc_object $P9728, "1307873293.85412", 73
    .const 'Sub' $P9729 = "101_1307873304.82979" 
    assign $P9728, $P9729
    nqp_get_sc_object $P9730, "1307873293.85412", 74
    .const 'Sub' $P9731 = "102_1307873304.82979" 
    assign $P9730, $P9731
    nqp_get_sc_object $P9732, "1307873293.85412", 75
    .const 'Sub' $P9733 = "103_1307873304.82979" 
    assign $P9732, $P9733
    nqp_get_sc_object $P9734, "1307873293.85412", 76
    .const 'Sub' $P9735 = "104_1307873304.82979" 
    assign $P9734, $P9735
    nqp_get_sc_object $P9736, "1307873293.85412", 77
    .const 'Sub' $P9737 = "105_1307873304.82979" 
    assign $P9736, $P9737
    nqp_get_sc_object $P9738, "1307873293.85412", 78
    .const 'Sub' $P9739 = "106_1307873304.82979" 
    assign $P9738, $P9739
    nqp_get_sc_object $P9740, "1307873293.85412", 79
    .const 'Sub' $P9741 = "107_1307873304.82979" 
    assign $P9740, $P9741
    nqp_get_sc_object $P9742, "1307873293.85412", 80
    .const 'Sub' $P9743 = "108_1307873304.82979" 
    assign $P9742, $P9743
    nqp_get_sc_object $P9744, "1307873293.85412", 81
    .const 'Sub' $P9745 = "109_1307873304.82979" 
    assign $P9744, $P9745
    nqp_get_sc_object $P9746, "1307873293.85412", 82
    .const 'Sub' $P9747 = "110_1307873304.82979" 
    assign $P9746, $P9747
    nqp_get_sc_object $P9748, "1307873293.85412", 83
    .const 'Sub' $P9749 = "111_1307873304.82979" 
    assign $P9748, $P9749
    nqp_get_sc_object $P9750, "1307873293.85412", 84
    .const 'Sub' $P9751 = "112_1307873304.82979" 
    assign $P9750, $P9751
    nqp_get_sc_object $P9752, "1307873293.85412", 85
    .const 'Sub' $P9753 = "113_1307873304.82979" 
    assign $P9752, $P9753
    nqp_get_sc_object $P9754, "1307873293.85412", 86
    .const 'Sub' $P9755 = "114_1307873304.82979" 
    assign $P9754, $P9755
    nqp_get_sc_object $P9756, "1307873293.85412", 87
    .const 'Sub' $P9757 = "115_1307873304.82979" 
    assign $P9756, $P9757
    nqp_get_sc_object $P9758, "1307873293.85412", 88
    .const 'Sub' $P9759 = "116_1307873304.82979" 
    assign $P9758, $P9759
    nqp_get_sc_object $P9760, "1307873293.85412", 89
    .const 'Sub' $P9761 = "117_1307873304.82979" 
    assign $P9760, $P9761
    nqp_get_sc_object $P9762, "1307873293.85412", 90
    .const 'Sub' $P9763 = "118_1307873304.82979" 
    assign $P9762, $P9763
    nqp_get_sc_object $P9764, "1307873293.85412", 91
    .const 'Sub' $P9765 = "119_1307873304.82979" 
    assign $P9764, $P9765
    nqp_get_sc_object $P9766, "1307873293.85412", 92
    .const 'Sub' $P9767 = "120_1307873304.82979" 
    assign $P9766, $P9767
    nqp_get_sc_object $P9768, "1307873293.85412", 93
    .const 'Sub' $P9769 = "121_1307873304.82979" 
    assign $P9768, $P9769
    nqp_get_sc_object $P9770, "1307873293.85412", 94
    .const 'Sub' $P9771 = "122_1307873304.82979" 
    assign $P9770, $P9771
    nqp_get_sc_object $P9772, "1307873293.85412", 95
    .const 'Sub' $P9773 = "123_1307873304.82979" 
    assign $P9772, $P9773
    nqp_get_sc_object $P9774, "1307873293.85412", 96
    .const 'Sub' $P9775 = "124_1307873304.82979" 
    assign $P9774, $P9775
    nqp_get_sc_object $P9776, "1307873293.85412", 97
    .const 'Sub' $P9777 = "125_1307873304.82979" 
    assign $P9776, $P9777
    nqp_get_sc_object $P9778, "1307873293.85412", 98
    .const 'Sub' $P9779 = "126_1307873304.82979" 
    assign $P9778, $P9779
    nqp_get_sc_object $P9780, "1307873293.85412", 99
    .const 'Sub' $P9781 = "127_1307873304.82979" 
    assign $P9780, $P9781
    nqp_get_sc_object $P9782, "1307873293.85412", 100
    .const 'Sub' $P9783 = "128_1307873304.82979" 
    assign $P9782, $P9783
    nqp_get_sc_object $P9784, "1307873293.85412", 101
    .const 'Sub' $P9785 = "129_1307873304.82979" 
    assign $P9784, $P9785
    nqp_get_sc_object $P9786, "1307873293.85412", 102
    .const 'Sub' $P9787 = "130_1307873304.82979" 
    assign $P9786, $P9787
    nqp_get_sc_object $P9788, "1307873293.85412", 103
    .const 'Sub' $P9789 = "131_1307873304.82979" 
    assign $P9788, $P9789
    nqp_get_sc_object $P9790, "1307873293.85412", 104
    .const 'Sub' $P9791 = "132_1307873304.82979" 
    assign $P9790, $P9791
    nqp_get_sc_object $P9792, "1307873293.85412", 105
    .const 'Sub' $P9793 = "133_1307873304.82979" 
    assign $P9792, $P9793
    nqp_get_sc_object $P9794, "1307873293.85412", 106
    .const 'Sub' $P9795 = "134_1307873304.82979" 
    assign $P9794, $P9795
    nqp_get_sc_object $P9796, "1307873293.85412", 107
    .const 'Sub' $P9797 = "135_1307873304.82979" 
    assign $P9796, $P9797
    nqp_get_sc_object $P9798, "1307873293.85412", 108
    .const 'Sub' $P9799 = "136_1307873304.82979" 
    assign $P9798, $P9799
    nqp_get_sc_object $P9800, "1307873293.85412", 109
    .const 'Sub' $P9801 = "137_1307873304.82979" 
    assign $P9800, $P9801
    nqp_get_sc_object $P9802, "1307873293.85412", 110
    .const 'Sub' $P9803 = "138_1307873304.82979" 
    assign $P9802, $P9803
    nqp_get_sc_object $P9804, "1307873293.85412", 111
    .const 'Sub' $P9805 = "139_1307873304.82979" 
    assign $P9804, $P9805
    nqp_get_sc_object $P9806, "1307873293.85412", 112
    .const 'Sub' $P9807 = "140_1307873304.82979" 
    assign $P9806, $P9807
    nqp_get_sc_object $P9808, "1307873293.85412", 113
    .const 'Sub' $P9809 = "141_1307873304.82979" 
    assign $P9808, $P9809
    nqp_get_sc_object $P9810, "1307873293.85412", 114
    .const 'Sub' $P9811 = "142_1307873304.82979" 
    assign $P9810, $P9811
    nqp_get_sc_object $P9812, "1307873293.85412", 115
    .const 'Sub' $P9813 = "143_1307873304.82979" 
    assign $P9812, $P9813
    nqp_get_sc_object $P9814, "1307873293.85412", 116
    .const 'Sub' $P9815 = "144_1307873304.82979" 
    assign $P9814, $P9815
    nqp_get_sc_object $P9816, "1307873293.85412", 117
    .const 'Sub' $P9817 = "145_1307873304.82979" 
    assign $P9816, $P9817
    nqp_get_sc_object $P9818, "1307873293.85412", 118
    .const 'Sub' $P9819 = "146_1307873304.82979" 
    assign $P9818, $P9819
    nqp_get_sc_object $P9820, "1307873293.85412", 119
    .const 'Sub' $P9821 = "149_1307873304.82979" 
    assign $P9820, $P9821
    nqp_get_sc_object $P9822, "1307873293.85412", 120
    .const 'Sub' $P9823 = "150_1307873304.82979" 
    assign $P9822, $P9823
    nqp_get_sc_object $P9824, "1307873293.85412", 121
    .const 'Sub' $P9825 = "151_1307873304.82979" 
    assign $P9824, $P9825
    nqp_get_sc_object $P9826, "1307873293.85412", 122
    .const 'Sub' $P9827 = "152_1307873304.82979" 
    assign $P9826, $P9827
    nqp_get_sc_object $P9828, "1307873293.85412", 123
    .const 'Sub' $P9829 = "153_1307873304.82979" 
    assign $P9828, $P9829
    nqp_get_sc_object $P9830, "1307873293.85412", 124
    .const 'Sub' $P9831 = "154_1307873304.82979" 
    assign $P9830, $P9831
    nqp_get_sc_object $P9832, "1307873293.85412", 125
    .const 'Sub' $P9833 = "155_1307873304.82979" 
    assign $P9832, $P9833
    nqp_get_sc_object $P9834, "1307873293.85412", 126
    .const 'Sub' $P9835 = "156_1307873304.82979" 
    assign $P9834, $P9835
    nqp_get_sc_object $P9836, "1307873293.85412", 127
    .const 'Sub' $P9837 = "157_1307873304.82979" 
    assign $P9836, $P9837
    nqp_get_sc_object $P9838, "1307873293.85412", 128
    .const 'Sub' $P9839 = "158_1307873304.82979" 
    assign $P9838, $P9839
    nqp_get_sc_object $P9840, "1307873293.85412", 129
    .const 'Sub' $P9841 = "159_1307873304.82979" 
    assign $P9840, $P9841
    nqp_get_sc_object $P9842, "1307873293.85412", 130
    .const 'Sub' $P9843 = "160_1307873304.82979" 
    assign $P9842, $P9843
    nqp_get_sc_object $P9844, "1307873293.85412", 131
    .const 'Sub' $P9845 = "161_1307873304.82979" 
    assign $P9844, $P9845
    nqp_get_sc_object $P9846, "1307873293.85412", 132
    .const 'Sub' $P9847 = "162_1307873304.82979" 
    assign $P9846, $P9847
    nqp_get_sc_object $P9848, "1307873293.85412", 133
    .const 'Sub' $P9849 = "163_1307873304.82979" 
    assign $P9848, $P9849
    nqp_get_sc_object $P9850, "1307873293.85412", 134
    .const 'Sub' $P9851 = "164_1307873304.82979" 
    assign $P9850, $P9851
    nqp_get_sc_object $P9852, "1307873293.85412", 135
    .const 'Sub' $P9853 = "165_1307873304.82979" 
    assign $P9852, $P9853
    nqp_get_sc_object $P9854, "1307873293.85412", 136
    .const 'Sub' $P9855 = "166_1307873304.82979" 
    assign $P9854, $P9855
    nqp_get_sc_object $P9856, "1307873293.85412", 137
    .const 'Sub' $P9857 = "167_1307873304.82979" 
    assign $P9856, $P9857
    nqp_get_sc_object $P9858, "1307873293.85412", 138
    .const 'Sub' $P9859 = "168_1307873304.82979" 
    assign $P9858, $P9859
    nqp_get_sc_object $P9860, "1307873293.85412", 139
    .const 'Sub' $P9861 = "169_1307873304.82979" 
    assign $P9860, $P9861
    nqp_get_sc_object $P9862, "1307873293.85412", 140
    .const 'Sub' $P9863 = "170_1307873304.82979" 
    assign $P9862, $P9863
    nqp_get_sc_object $P9864, "1307873293.85412", 141
    .const 'Sub' $P9865 = "171_1307873304.82979" 
    assign $P9864, $P9865
    nqp_get_sc_object $P9866, "1307873293.85412", 142
    .const 'Sub' $P9867 = "172_1307873304.82979" 
    assign $P9866, $P9867
    nqp_get_sc_object $P9868, "1307873293.85412", 143
    .const 'Sub' $P9869 = "173_1307873304.82979" 
    assign $P9868, $P9869
    nqp_get_sc_object $P9870, "1307873293.85412", 144
    .const 'Sub' $P9871 = "174_1307873304.82979" 
    assign $P9870, $P9871
    nqp_get_sc_object $P9872, "1307873293.85412", 145
    .const 'Sub' $P9873 = "175_1307873304.82979" 
    assign $P9872, $P9873
    nqp_get_sc_object $P9874, "1307873293.85412", 146
    .const 'Sub' $P9875 = "176_1307873304.82979" 
    assign $P9874, $P9875
    nqp_get_sc_object $P9876, "1307873293.85412", 147
    .const 'Sub' $P9877 = "177_1307873304.82979" 
    assign $P9876, $P9877
    nqp_get_sc_object $P9878, "1307873293.85412", 148
    .const 'Sub' $P9879 = "178_1307873304.82979" 
    assign $P9878, $P9879
    nqp_get_sc_object $P9880, "1307873293.85412", 149
    .const 'Sub' $P9881 = "179_1307873304.82979" 
    assign $P9880, $P9881
    nqp_get_sc_object $P9882, "1307873293.85412", 150
    .const 'Sub' $P9883 = "180_1307873304.82979" 
    assign $P9882, $P9883
    nqp_get_sc_object $P9884, "1307873293.85412", 151
    .const 'Sub' $P9885 = "181_1307873304.82979" 
    assign $P9884, $P9885
    nqp_get_sc_object $P9886, "1307873293.85412", 152
    .const 'Sub' $P9887 = "182_1307873304.82979" 
    assign $P9886, $P9887
    nqp_get_sc_object $P9888, "1307873293.85412", 153
    .const 'Sub' $P9889 = "184_1307873304.82979" 
    assign $P9888, $P9889
    nqp_get_sc_object $P9890, "1307873293.85412", 154
    .const 'Sub' $P9891 = "185_1307873304.82979" 
    assign $P9890, $P9891
    nqp_get_sc_object $P9892, "1307873293.85412", 155
    .const 'Sub' $P9893 = "186_1307873304.82979" 
    assign $P9892, $P9893
    nqp_get_sc_object $P9894, "1307873293.85412", 156
    .const 'Sub' $P9895 = "187_1307873304.82979" 
    assign $P9894, $P9895
    nqp_get_sc_object $P9896, "1307873293.85412", 157
    .const 'Sub' $P9897 = "188_1307873304.82979" 
    assign $P9896, $P9897
    nqp_get_sc_object $P9898, "1307873293.85412", 158
    .const 'Sub' $P9899 = "189_1307873304.82979" 
    assign $P9898, $P9899
    nqp_get_sc_object $P9900, "1307873293.85412", 159
    .const 'Sub' $P9901 = "190_1307873304.82979" 
    assign $P9900, $P9901
    nqp_get_sc_object $P9902, "1307873293.85412", 160
    .const 'Sub' $P9903 = "191_1307873304.82979" 
    assign $P9902, $P9903
    nqp_get_sc_object $P9904, "1307873293.85412", 161
    .const 'Sub' $P9905 = "192_1307873304.82979" 
    assign $P9904, $P9905
    nqp_get_sc_object $P9906, "1307873293.85412", 162
    .const 'Sub' $P9907 = "193_1307873304.82979" 
    assign $P9906, $P9907
    nqp_get_sc_object $P9908, "1307873293.85412", 163
    .const 'Sub' $P9909 = "194_1307873304.82979" 
    assign $P9908, $P9909
    nqp_get_sc_object $P9910, "1307873293.85412", 164
    .const 'Sub' $P9911 = "195_1307873304.82979" 
    assign $P9910, $P9911
    nqp_get_sc_object $P9912, "1307873293.85412", 165
    .const 'Sub' $P9913 = "197_1307873304.82979" 
    assign $P9912, $P9913
    nqp_get_sc_object $P9914, "1307873293.85412", 166
    .const 'Sub' $P9915 = "198_1307873304.82979" 
    assign $P9914, $P9915
    nqp_get_sc_object $P9916, "1307873293.85412", 167
    .const 'Sub' $P9917 = "199_1307873304.82979" 
    assign $P9916, $P9917
    nqp_get_sc_object $P9918, "1307873293.85412", 168
    .const 'Sub' $P9919 = "200_1307873304.82979" 
    assign $P9918, $P9919
    nqp_get_sc_object $P9920, "1307873293.85412", 169
    .const 'Sub' $P9921 = "202_1307873304.82979" 
    assign $P9920, $P9921
    nqp_get_sc_object $P9922, "1307873293.85412", 170
    .const 'Sub' $P9923 = "203_1307873304.82979" 
    assign $P9922, $P9923
    nqp_get_sc_object $P9924, "1307873293.85412", 171
    .const 'Sub' $P9925 = "204_1307873304.82979" 
    assign $P9924, $P9925
    nqp_get_sc_object $P9926, "1307873293.85412", 172
    .const 'Sub' $P9927 = "205_1307873304.82979" 
    assign $P9926, $P9927
    nqp_get_sc_object $P9928, "1307873293.85412", 173
    .const 'Sub' $P9929 = "206_1307873304.82979" 
    assign $P9928, $P9929
    nqp_get_sc_object $P9930, "1307873293.85412", 174
    .const 'Sub' $P9931 = "207_1307873304.82979" 
    assign $P9930, $P9931
    nqp_get_sc_object $P9932, "1307873293.85412", 175
    .const 'Sub' $P9933 = "208_1307873304.82979" 
    assign $P9932, $P9933
    nqp_get_sc_object $P9934, "1307873293.85412", 176
    .const 'Sub' $P9935 = "209_1307873304.82979" 
    assign $P9934, $P9935
    nqp_get_sc_object $P9936, "1307873293.85412", 177
    .const 'Sub' $P9937 = "210_1307873304.82979" 
    assign $P9936, $P9937
    nqp_get_sc_object $P9938, "1307873293.85412", 178
    .const 'Sub' $P9939 = "211_1307873304.82979" 
    assign $P9938, $P9939
    nqp_get_sc_object $P9940, "1307873293.85412", 179
    .const 'Sub' $P9941 = "213_1307873304.82979" 
    assign $P9940, $P9941
    nqp_get_sc_object $P9942, "1307873293.85412", 180
    .const 'Sub' $P9943 = "214_1307873304.82979" 
    assign $P9942, $P9943
    nqp_get_sc_object $P9944, "1307873293.85412", 181
    .const 'Sub' $P9945 = "216_1307873304.82979" 
    assign $P9944, $P9945
    nqp_get_sc_object $P9946, "1307873293.85412", 182
    .const 'Sub' $P9947 = "217_1307873304.82979" 
    assign $P9946, $P9947
    nqp_get_sc_object $P9948, "1307873293.85412", 183
    .const 'Sub' $P9949 = "218_1307873304.82979" 
    assign $P9948, $P9949
    nqp_get_sc_object $P9950, "1307873293.85412", 184
    .const 'Sub' $P9951 = "219_1307873304.82979" 
    assign $P9950, $P9951
    nqp_get_sc_object $P9952, "1307873293.85412", 185
    .const 'Sub' $P9953 = "220_1307873304.82979" 
    assign $P9952, $P9953
    nqp_get_sc_object $P9954, "1307873293.85412", 186
    .const 'Sub' $P9955 = "221_1307873304.82979" 
    assign $P9954, $P9955
    nqp_get_sc_object $P9956, "1307873293.85412", 187
    .const 'Sub' $P9957 = "222_1307873304.82979" 
    assign $P9956, $P9957
    nqp_get_sc_object $P9958, "1307873293.85412", 188
    .const 'Sub' $P9959 = "223_1307873304.82979" 
    assign $P9958, $P9959
    nqp_get_sc_object $P9960, "1307873293.85412", 189
    .const 'Sub' $P9961 = "224_1307873304.82979" 
    assign $P9960, $P9961
    nqp_get_sc_object $P9962, "1307873293.85412", 190
    .const 'Sub' $P9963 = "225_1307873304.82979" 
    assign $P9962, $P9963
    nqp_get_sc_object $P9964, "1307873293.85412", 191
    .const 'Sub' $P9965 = "227_1307873304.82979" 
    assign $P9964, $P9965
    nqp_get_sc_object $P9966, "1307873293.85412", 192
    .const 'Sub' $P9967 = "228_1307873304.82979" 
    assign $P9966, $P9967
    nqp_get_sc_object $P9968, "1307873293.85412", 193
    .const 'Sub' $P9969 = "229_1307873304.82979" 
    assign $P9968, $P9969
    nqp_get_sc_object $P9970, "1307873293.85412", 194
    .const 'Sub' $P9971 = "230_1307873304.82979" 
    assign $P9970, $P9971
    nqp_get_sc_object $P9972, "1307873293.85412", 195
    .const 'Sub' $P9973 = "231_1307873304.82979" 
    assign $P9972, $P9973
    nqp_get_sc_object $P9974, "1307873293.85412", 196
    .const 'Sub' $P9975 = "232_1307873304.82979" 
    assign $P9974, $P9975
    nqp_get_sc_object $P9976, "1307873293.85412", 197
    .const 'Sub' $P9977 = "233_1307873304.82979" 
    assign $P9976, $P9977
    nqp_get_sc_object $P9978, "1307873293.85412", 198
    .const 'Sub' $P9979 = "234_1307873304.82979" 
    assign $P9978, $P9979
    nqp_get_sc_object $P9980, "1307873293.85412", 199
    .const 'Sub' $P9981 = "235_1307873304.82979" 
    assign $P9980, $P9981
    nqp_get_sc_object $P9982, "1307873293.85412", 200
    .const 'Sub' $P9983 = "236_1307873304.82979" 
    assign $P9982, $P9983
    nqp_get_sc_object $P9984, "1307873293.85412", 201
    .const 'Sub' $P9985 = "237_1307873304.82979" 
    assign $P9984, $P9985
    nqp_get_sc_object $P9986, "1307873293.85412", 202
    .const 'Sub' $P9987 = "238_1307873304.82979" 
    assign $P9986, $P9987
    nqp_get_sc_object $P9988, "1307873293.85412", 203
    .const 'Sub' $P9989 = "239_1307873304.82979" 
    assign $P9988, $P9989
    nqp_get_sc_object $P9990, "1307873293.85412", 204
    .const 'Sub' $P9991 = "240_1307873304.82979" 
    assign $P9990, $P9991
    nqp_get_sc_object $P9992, "1307873293.85412", 205
    .const 'Sub' $P9993 = "241_1307873304.82979" 
    assign $P9992, $P9993
    nqp_get_sc_object $P9994, "1307873293.85412", 206
    .const 'Sub' $P9995 = "242_1307873304.82979" 
    assign $P9994, $P9995
    nqp_get_sc_object $P9996, "1307873293.85412", 207
    .const 'Sub' $P9997 = "243_1307873304.82979" 
    assign $P9996, $P9997
    nqp_get_sc_object $P9998, "1307873293.85412", 208
    .const 'Sub' $P9999 = "244_1307873304.82979" 
    assign $P9998, $P9999
    nqp_get_sc_object $P10000, "1307873293.85412", 209
    .const 'Sub' $P10001 = "245_1307873304.82979" 
    assign $P10000, $P10001
    nqp_get_sc_object $P10002, "1307873293.85412", 210
    .const 'Sub' $P10003 = "246_1307873304.82979" 
    assign $P10002, $P10003
    nqp_get_sc_object $P10004, "1307873293.85412", 211
    .const 'Sub' $P10005 = "247_1307873304.82979" 
    assign $P10004, $P10005
    nqp_get_sc_object $P10006, "1307873293.85412", 212
    .const 'Sub' $P10007 = "248_1307873304.82979" 
    assign $P10006, $P10007
    nqp_get_sc_object $P10008, "1307873293.85412", 213
    .const 'Sub' $P10009 = "249_1307873304.82979" 
    assign $P10008, $P10009
    nqp_get_sc_object $P10010, "1307873293.85412", 214
    .const 'Sub' $P10011 = "250_1307873304.82979" 
    assign $P10010, $P10011
    nqp_get_sc_object $P10012, "1307873293.85412", 215
    .const 'Sub' $P10013 = "251_1307873304.82979" 
    assign $P10012, $P10013
    nqp_get_sc_object $P10014, "1307873293.85412", 216
    .const 'Sub' $P10015 = "252_1307873304.82979" 
    assign $P10014, $P10015
    nqp_get_sc_object $P10016, "1307873293.85412", 217
    .const 'Sub' $P10017 = "253_1307873304.82979" 
    assign $P10016, $P10017
    nqp_get_sc_object $P10018, "1307873293.85412", 218
    .const 'Sub' $P10019 = "254_1307873304.82979" 
    assign $P10018, $P10019
    nqp_get_sc_object $P10020, "1307873293.85412", 219
    .const 'Sub' $P10021 = "255_1307873304.82979" 
    assign $P10020, $P10021
    nqp_get_sc_object $P10022, "1307873293.85412", 220
    .const 'Sub' $P10023 = "256_1307873304.82979" 
    assign $P10022, $P10023
    nqp_get_sc_object $P10024, "1307873293.85412", 221
    .const 'Sub' $P10025 = "257_1307873304.82979" 
    assign $P10024, $P10025
    nqp_get_sc_object $P10026, "1307873293.85412", 222
    .const 'Sub' $P10027 = "258_1307873304.82979" 
    assign $P10026, $P10027
    nqp_get_sc_object $P10028, "1307873293.85412", 223
    .const 'Sub' $P10029 = "260_1307873304.82979" 
    assign $P10028, $P10029
    nqp_get_sc_object $P10030, "1307873293.85412", 224
    .const 'Sub' $P10031 = "261_1307873304.82979" 
    assign $P10030, $P10031
    nqp_get_sc_object $P10032, "1307873293.85412", 225
    .const 'Sub' $P10033 = "262_1307873304.82979" 
    assign $P10032, $P10033
    nqp_get_sc_object $P10034, "1307873293.85412", 226
    .const 'Sub' $P10035 = "263_1307873304.82979" 
    assign $P10034, $P10035
    nqp_get_sc_object $P10036, "1307873293.85412", 227
    .const 'Sub' $P10037 = "264_1307873304.82979" 
    assign $P10036, $P10037
    nqp_get_sc_object $P10038, "1307873293.85412", 228
    .const 'Sub' $P10039 = "265_1307873304.82979" 
    assign $P10038, $P10039
    nqp_get_sc_object $P10040, "1307873293.85412", 229
    .const 'Sub' $P10041 = "266_1307873304.82979" 
    assign $P10040, $P10041
    nqp_get_sc_object $P10042, "1307873293.85412", 230
    .const 'Sub' $P10043 = "267_1307873304.82979" 
    assign $P10042, $P10043
    nqp_get_sc_object $P10044, "1307873293.85412", 231
    .const 'Sub' $P10045 = "268_1307873304.82979" 
    assign $P10044, $P10045
    nqp_get_sc_object $P10046, "1307873293.85412", 232
    .const 'Sub' $P10047 = "269_1307873304.82979" 
    assign $P10046, $P10047
    nqp_get_sc_object $P10048, "1307873293.85412", 233
    .const 'Sub' $P10049 = "270_1307873304.82979" 
    assign $P10048, $P10049
    nqp_get_sc_object $P10050, "1307873293.85412", 234
    .const 'Sub' $P10051 = "271_1307873304.82979" 
    assign $P10050, $P10051
    nqp_get_sc_object $P10052, "1307873293.85412", 235
    .const 'Sub' $P10053 = "272_1307873304.82979" 
    assign $P10052, $P10053
    nqp_get_sc_object $P10054, "1307873293.85412", 236
    .const 'Sub' $P10055 = "273_1307873304.82979" 
    assign $P10054, $P10055
    nqp_get_sc_object $P10056, "1307873293.85412", 237
    .const 'Sub' $P10057 = "274_1307873304.82979" 
    assign $P10056, $P10057
    nqp_get_sc_object $P10058, "1307873293.85412", 238
    .const 'Sub' $P10059 = "275_1307873304.82979" 
    assign $P10058, $P10059
    nqp_get_sc_object $P10060, "1307873293.85412", 239
    .const 'Sub' $P10061 = "276_1307873304.82979" 
    assign $P10060, $P10061
    nqp_get_sc_object $P10062, "1307873293.85412", 240
    .const 'Sub' $P10063 = "277_1307873304.82979" 
    assign $P10062, $P10063
    nqp_get_sc_object $P10064, "1307873293.85412", 241
    .const 'Sub' $P10065 = "278_1307873304.82979" 
    assign $P10064, $P10065
    nqp_get_sc_object $P10066, "1307873293.85412", 242
    .const 'Sub' $P10067 = "279_1307873304.82979" 
    assign $P10066, $P10067
    nqp_get_sc_object $P10068, "1307873293.85412", 243
    .const 'Sub' $P10069 = "280_1307873304.82979" 
    assign $P10068, $P10069
    nqp_get_sc_object $P10070, "1307873293.85412", 244
    .const 'Sub' $P10071 = "281_1307873304.82979" 
    assign $P10070, $P10071
    nqp_get_sc_object $P10072, "1307873293.85412", 245
    .const 'Sub' $P10073 = "282_1307873304.82979" 
    assign $P10072, $P10073
    nqp_get_sc_object $P10074, "1307873293.85412", 246
    .const 'Sub' $P10075 = "283_1307873304.82979" 
    assign $P10074, $P10075
    nqp_get_sc_object $P10076, "1307873293.85412", 247
    .const 'Sub' $P10077 = "284_1307873304.82979" 
    assign $P10076, $P10077
    nqp_get_sc_object $P10078, "1307873293.85412", 248
    .const 'Sub' $P10079 = "285_1307873304.82979" 
    assign $P10078, $P10079
    nqp_get_sc_object $P10080, "1307873293.85412", 249
    .const 'Sub' $P10081 = "286_1307873304.82979" 
    assign $P10080, $P10081
    nqp_get_sc_object $P10082, "1307873293.85412", 250
    .const 'Sub' $P10083 = "287_1307873304.82979" 
    assign $P10082, $P10083
    nqp_get_sc_object $P10084, "1307873293.85412", 251
    .const 'Sub' $P10085 = "288_1307873304.82979" 
    assign $P10084, $P10085
    nqp_get_sc_object $P10086, "1307873293.85412", 252
    .const 'Sub' $P10087 = "289_1307873304.82979" 
    assign $P10086, $P10087
    nqp_get_sc_object $P10088, "1307873293.85412", 253
    .const 'Sub' $P10089 = "290_1307873304.82979" 
    assign $P10088, $P10089
    nqp_get_sc_object $P10090, "1307873293.85412", 254
    .const 'Sub' $P10091 = "291_1307873304.82979" 
    assign $P10090, $P10091
    nqp_get_sc_object $P10092, "1307873293.85412", 255
    .const 'Sub' $P10093 = "292_1307873304.82979" 
    assign $P10092, $P10093
    nqp_get_sc_object $P10094, "1307873293.85412", 256
    .const 'Sub' $P10095 = "293_1307873304.82979" 
    assign $P10094, $P10095
    nqp_get_sc_object $P10096, "1307873293.85412", 257
    .const 'Sub' $P10097 = "294_1307873304.82979" 
    assign $P10096, $P10097
    nqp_get_sc_object $P10098, "1307873293.85412", 258
    .const 'Sub' $P10099 = "295_1307873304.82979" 
    assign $P10098, $P10099
    nqp_get_sc_object $P10100, "1307873293.85412", 259
    .const 'Sub' $P10101 = "296_1307873304.82979" 
    assign $P10100, $P10101
    nqp_get_sc_object $P10102, "1307873293.85412", 260
    .const 'Sub' $P10103 = "297_1307873304.82979" 
    assign $P10102, $P10103
    nqp_get_sc_object $P10104, "1307873293.85412", 261
    .const 'Sub' $P10105 = "298_1307873304.82979" 
    assign $P10104, $P10105
    nqp_get_sc_object $P10106, "1307873293.85412", 262
    .const 'Sub' $P10107 = "299_1307873304.82979" 
    assign $P10106, $P10107
    nqp_get_sc_object $P10108, "1307873293.85412", 263
    .const 'Sub' $P10109 = "300_1307873304.82979" 
    assign $P10108, $P10109
    nqp_get_sc_object $P10110, "1307873293.85412", 264
    .const 'Sub' $P10111 = "301_1307873304.82979" 
    assign $P10110, $P10111
    nqp_get_sc_object $P10112, "1307873293.85412", 265
    .const 'Sub' $P10113 = "302_1307873304.82979" 
    assign $P10112, $P10113
    nqp_get_sc_object $P10114, "1307873293.85412", 266
    .const 'Sub' $P10115 = "303_1307873304.82979" 
    assign $P10114, $P10115
    nqp_get_sc_object $P10116, "1307873293.85412", 267
    .const 'Sub' $P10117 = "304_1307873304.82979" 
    assign $P10116, $P10117
    nqp_get_sc_object $P10118, "1307873293.85412", 268
    .const 'Sub' $P10119 = "305_1307873304.82979" 
    assign $P10118, $P10119
    nqp_get_sc_object $P10120, "1307873293.85412", 269
    .const 'Sub' $P10121 = "306_1307873304.82979" 
    assign $P10120, $P10121
    nqp_get_sc_object $P10122, "1307873293.85412", 270
    .const 'Sub' $P10123 = "307_1307873304.82979" 
    assign $P10122, $P10123
    nqp_get_sc_object $P10124, "1307873293.85412", 271
    .const 'Sub' $P10125 = "308_1307873304.82979" 
    assign $P10124, $P10125
    nqp_get_sc_object $P10126, "1307873293.85412", 272
    .const 'Sub' $P10127 = "309_1307873304.82979" 
    assign $P10126, $P10127
    nqp_get_sc_object $P10128, "1307873293.85412", 273
    .const 'Sub' $P10129 = "310_1307873304.82979" 
    assign $P10128, $P10129
    nqp_get_sc_object $P10130, "1307873293.85412", 274
    .const 'Sub' $P10131 = "311_1307873304.82979" 
    assign $P10130, $P10131
    nqp_get_sc_object $P10132, "1307873293.85412", 275
    .const 'Sub' $P10133 = "312_1307873304.82979" 
    assign $P10132, $P10133
    nqp_get_sc_object $P10134, "1307873293.85412", 276
    .const 'Sub' $P10135 = "313_1307873304.82979" 
    assign $P10134, $P10135
    nqp_get_sc_object $P10136, "1307873293.85412", 277
    .const 'Sub' $P10137 = "314_1307873304.82979" 
    assign $P10136, $P10137
    nqp_get_sc_object $P10138, "1307873293.85412", 278
    .const 'Sub' $P10139 = "315_1307873304.82979" 
    assign $P10138, $P10139
    nqp_get_sc_object $P10140, "1307873293.85412", 279
    .const 'Sub' $P10141 = "316_1307873304.82979" 
    assign $P10140, $P10141
    nqp_get_sc_object $P10142, "1307873293.85412", 280
    .const 'Sub' $P10143 = "317_1307873304.82979" 
    assign $P10142, $P10143
    nqp_get_sc_object $P10144, "1307873293.85412", 281
    .const 'Sub' $P10145 = "318_1307873304.82979" 
    assign $P10144, $P10145
    nqp_get_sc_object $P10146, "1307873293.85412", 282
    .const 'Sub' $P10147 = "319_1307873304.82979" 
    assign $P10146, $P10147
    nqp_get_sc_object $P10148, "1307873293.85412", 283
    .const 'Sub' $P10149 = "320_1307873304.82979" 
    assign $P10148, $P10149
    nqp_get_sc_object $P10150, "1307873293.85412", 284
    .const 'Sub' $P10151 = "321_1307873304.82979" 
    assign $P10150, $P10151
    nqp_get_sc_object $P10152, "1307873293.85412", 285
    .const 'Sub' $P10153 = "322_1307873304.82979" 
    assign $P10152, $P10153
    nqp_get_sc_object $P10154, "1307873293.85412", 286
    .const 'Sub' $P10155 = "323_1307873304.82979" 
    assign $P10154, $P10155
    nqp_get_sc_object $P10156, "1307873293.85412", 287
    .const 'Sub' $P10157 = "324_1307873304.82979" 
    assign $P10156, $P10157
    nqp_get_sc_object $P10158, "1307873293.85412", 288
    .const 'Sub' $P10159 = "325_1307873304.82979" 
    assign $P10158, $P10159
    nqp_get_sc_object $P10160, "1307873293.85412", 289
    .const 'Sub' $P10161 = "326_1307873304.82979" 
    assign $P10160, $P10161
    nqp_get_sc_object $P10162, "1307873293.85412", 290
    .const 'Sub' $P10163 = "327_1307873304.82979" 
    assign $P10162, $P10163
    nqp_get_sc_object $P10164, "1307873293.85412", 291
    .const 'Sub' $P10165 = "328_1307873304.82979" 
    assign $P10164, $P10165
    nqp_get_sc_object $P10166, "1307873293.85412", 292
    .const 'Sub' $P10167 = "329_1307873304.82979" 
    assign $P10166, $P10167
    nqp_get_sc_object $P10168, "1307873293.85412", 293
    .const 'Sub' $P10169 = "330_1307873304.82979" 
    assign $P10168, $P10169
    nqp_get_sc_object $P10170, "1307873293.85412", 294
    .const 'Sub' $P10171 = "331_1307873304.82979" 
    assign $P10170, $P10171
    nqp_get_sc_object $P10172, "1307873293.85412", 295
    .const 'Sub' $P10173 = "332_1307873304.82979" 
    assign $P10172, $P10173
    nqp_get_sc_object $P10174, "1307873293.85412", 296
    .const 'Sub' $P10175 = "333_1307873304.82979" 
    assign $P10174, $P10175
    nqp_get_sc_object $P10176, "1307873293.85412", 297
    .const 'Sub' $P10177 = "334_1307873304.82979" 
    assign $P10176, $P10177
    nqp_get_sc_object $P10178, "1307873293.85412", 298
    .const 'Sub' $P10179 = "335_1307873304.82979" 
    assign $P10178, $P10179
    nqp_get_sc_object $P10180, "1307873293.85412", 299
    .const 'Sub' $P10181 = "336_1307873304.82979" 
    assign $P10180, $P10181
    nqp_get_sc_object $P10182, "1307873293.85412", 300
    .const 'Sub' $P10183 = "337_1307873304.82979" 
    assign $P10182, $P10183
    nqp_get_sc_object $P10184, "1307873293.85412", 301
    .const 'Sub' $P10185 = "338_1307873304.82979" 
    assign $P10184, $P10185
    nqp_get_sc_object $P10186, "1307873293.85412", 302
    .const 'Sub' $P10187 = "339_1307873304.82979" 
    assign $P10186, $P10187
    nqp_get_sc_object $P10188, "1307873293.85412", 303
    .const 'Sub' $P10189 = "340_1307873304.82979" 
    assign $P10188, $P10189
    nqp_get_sc_object $P10190, "1307873293.85412", 304
    .const 'Sub' $P10191 = "341_1307873304.82979" 
    assign $P10190, $P10191
    nqp_get_sc_object $P10192, "1307873293.85412", 305
    .const 'Sub' $P10193 = "342_1307873304.82979" 
    assign $P10192, $P10193
    nqp_get_sc_object $P10194, "1307873293.85412", 306
    .const 'Sub' $P10195 = "343_1307873304.82979" 
    assign $P10194, $P10195
    nqp_get_sc_object $P10196, "1307873293.85412", 307
    .const 'Sub' $P10197 = "344_1307873304.82979" 
    assign $P10196, $P10197
    nqp_get_sc_object $P10198, "1307873293.85412", 308
    .const 'Sub' $P10199 = "345_1307873304.82979" 
    assign $P10198, $P10199
    nqp_get_sc_object $P10200, "1307873293.85412", 309
    .const 'Sub' $P10201 = "346_1307873304.82979" 
    assign $P10200, $P10201
    nqp_get_sc_object $P10202, "1307873293.85412", 310
    .const 'Sub' $P10203 = "347_1307873304.82979" 
    assign $P10202, $P10203
    nqp_get_sc_object $P10204, "1307873293.85412", 311
    .const 'Sub' $P10205 = "348_1307873304.82979" 
    assign $P10204, $P10205
    nqp_get_sc_object $P10206, "1307873293.85412", 312
    .const 'Sub' $P10207 = "349_1307873304.82979" 
    assign $P10206, $P10207
    nqp_get_sc_object $P10208, "1307873293.85412", 313
    .const 'Sub' $P10209 = "350_1307873304.82979" 
    assign $P10208, $P10209
    nqp_get_sc_object $P10210, "1307873293.85412", 314
    .const 'Sub' $P10211 = "351_1307873304.82979" 
    assign $P10210, $P10211
    nqp_get_sc_object $P10212, "1307873293.85412", 315
    .const 'Sub' $P10213 = "352_1307873304.82979" 
    assign $P10212, $P10213
    nqp_get_sc_object $P10214, "1307873293.85412", 316
    .const 'Sub' $P10215 = "353_1307873304.82979" 
    assign $P10214, $P10215
    nqp_get_sc_object $P10216, "1307873293.85412", 317
    .const 'Sub' $P10217 = "354_1307873304.82979" 
    assign $P10216, $P10217
    nqp_get_sc_object $P10218, "1307873293.85412", 318
    .const 'Sub' $P10219 = "355_1307873304.82979" 
    assign $P10218, $P10219
    nqp_get_sc_object $P10220, "1307873293.85412", 319
    .const 'Sub' $P10221 = "356_1307873304.82979" 
    assign $P10220, $P10221
    nqp_get_sc_object $P10222, "1307873293.85412", 320
    .const 'Sub' $P10223 = "357_1307873304.82979" 
    assign $P10222, $P10223
    nqp_get_sc_object $P10224, "1307873293.85412", 321
    .const 'Sub' $P10225 = "358_1307873304.82979" 
    assign $P10224, $P10225
    nqp_get_sc_object $P10226, "1307873293.85412", 322
    .const 'Sub' $P10227 = "359_1307873304.82979" 
    assign $P10226, $P10227
    nqp_get_sc_object $P10228, "1307873293.85412", 323
    .const 'Sub' $P10229 = "360_1307873304.82979" 
    assign $P10228, $P10229
    nqp_get_sc_object $P10230, "1307873293.85412", 324
    .const 'Sub' $P10231 = "361_1307873304.82979" 
    assign $P10230, $P10231
    nqp_get_sc_object $P10232, "1307873293.85412", 325
    .const 'Sub' $P10233 = "362_1307873304.82979" 
    assign $P10232, $P10233
    nqp_get_sc_object $P10234, "1307873293.85412", 326
    .const 'Sub' $P10235 = "363_1307873304.82979" 
    assign $P10234, $P10235
    nqp_get_sc_object $P10236, "1307873293.85412", 327
    .const 'Sub' $P10237 = "364_1307873304.82979" 
    assign $P10236, $P10237
    nqp_get_sc_object $P10238, "1307873293.85412", 328
    .const 'Sub' $P10239 = "365_1307873304.82979" 
    assign $P10238, $P10239
    nqp_get_sc_object $P10240, "1307873293.85412", 329
    .const 'Sub' $P10241 = "366_1307873304.82979" 
    assign $P10240, $P10241
    nqp_get_sc_object $P10242, "1307873293.85412", 330
    .const 'Sub' $P10243 = "367_1307873304.82979" 
    assign $P10242, $P10243
    nqp_get_sc_object $P10244, "1307873293.85412", 331
    .const 'Sub' $P10245 = "368_1307873304.82979" 
    assign $P10244, $P10245
    nqp_get_sc_object $P10246, "1307873293.85412", 332
    .const 'Sub' $P10247 = "369_1307873304.82979" 
    assign $P10246, $P10247
    nqp_get_sc_object $P10248, "1307873293.85412", 333
    .const 'Sub' $P10249 = "370_1307873304.82979" 
    assign $P10248, $P10249
    nqp_get_sc_object $P10250, "1307873293.85412", 334
    .const 'Sub' $P10251 = "371_1307873304.82979" 
    assign $P10250, $P10251
    nqp_get_sc_object $P10252, "1307873293.85412", 335
    .const 'Sub' $P10253 = "372_1307873304.82979" 
    assign $P10252, $P10253
    nqp_get_sc_object $P10254, "1307873293.85412", 336
    .const 'Sub' $P10255 = "373_1307873304.82979" 
    assign $P10254, $P10255
    nqp_get_sc_object $P10256, "1307873293.85412", 337
    .const 'Sub' $P10257 = "374_1307873304.82979" 
    assign $P10256, $P10257
    nqp_get_sc_object $P10258, "1307873293.85412", 338
    .const 'Sub' $P10259 = "375_1307873304.82979" 
    assign $P10258, $P10259
    nqp_get_sc_object $P10260, "1307873293.85412", 339
    .const 'Sub' $P10261 = "376_1307873304.82979" 
    assign $P10260, $P10261
    nqp_get_sc_object $P10262, "1307873293.85412", 340
    .const 'Sub' $P10263 = "377_1307873304.82979" 
    assign $P10262, $P10263
    nqp_get_sc_object $P10264, "1307873293.85412", 341
    .const 'Sub' $P10265 = "378_1307873304.82979" 
    assign $P10264, $P10265
    nqp_get_sc_object $P10266, "1307873293.85412", 342
    .const 'Sub' $P10267 = "379_1307873304.82979" 
    assign $P10266, $P10267
    nqp_get_sc_object $P10268, "1307873293.85412", 343
    .const 'Sub' $P10269 = "380_1307873304.82979" 
    assign $P10268, $P10269
    nqp_get_sc_object $P10270, "1307873293.85412", 344
    .const 'Sub' $P10271 = "381_1307873304.82979" 
    assign $P10270, $P10271
    nqp_get_sc_object $P10272, "1307873293.85412", 345
    .const 'Sub' $P10273 = "382_1307873304.82979" 
    assign $P10272, $P10273
    nqp_get_sc_object $P10274, "1307873293.85412", 346
    .const 'Sub' $P10275 = "383_1307873304.82979" 
    assign $P10274, $P10275
    nqp_get_sc_object $P10276, "1307873293.85412", 347
    .const 'Sub' $P10277 = "384_1307873304.82979" 
    assign $P10276, $P10277
    nqp_get_sc_object $P10278, "1307873293.85412", 348
    .const 'Sub' $P10279 = "385_1307873304.82979" 
    assign $P10278, $P10279
    nqp_get_sc_object $P10280, "1307873293.85412", 349
    .const 'Sub' $P10281 = "386_1307873304.82979" 
    assign $P10280, $P10281
    nqp_get_sc_object $P10282, "1307873293.85412", 350
    .const 'Sub' $P10283 = "387_1307873304.82979" 
    assign $P10282, $P10283
    nqp_get_sc_object $P10284, "1307873293.85412", 351
    .const 'Sub' $P10285 = "388_1307873304.82979" 
    assign $P10284, $P10285
    nqp_get_sc_object $P10286, "1307873293.85412", 352
    .const 'Sub' $P10287 = "389_1307873304.82979" 
    assign $P10286, $P10287
    nqp_get_sc_object $P10288, "1307873293.85412", 353
    .const 'Sub' $P10289 = "390_1307873304.82979" 
    assign $P10288, $P10289
    nqp_get_sc_object $P10290, "1307873293.85412", 354
    .const 'Sub' $P10291 = "391_1307873304.82979" 
    assign $P10290, $P10291
    nqp_get_sc_object $P10292, "1307873293.85412", 355
    .const 'Sub' $P10293 = "392_1307873304.82979" 
    assign $P10292, $P10293
    nqp_get_sc_object $P10294, "1307873293.85412", 356
    .const 'Sub' $P10295 = "393_1307873304.82979" 
    assign $P10294, $P10295
    nqp_get_sc_object $P10296, "1307873293.85412", 357
    .const 'Sub' $P10297 = "394_1307873304.82979" 
    assign $P10296, $P10297
    nqp_get_sc_object $P10298, "1307873293.85412", 358
    .const 'Sub' $P10299 = "395_1307873304.82979" 
    assign $P10298, $P10299
    nqp_get_sc_object $P10300, "1307873293.85412", 359
    .const 'Sub' $P10301 = "396_1307873304.82979" 
    assign $P10300, $P10301
    nqp_get_sc_object $P10302, "1307873293.85412", 360
    .const 'Sub' $P10303 = "397_1307873304.82979" 
    assign $P10302, $P10303
    nqp_get_sc_object $P10304, "1307873293.85412", 361
    .const 'Sub' $P10305 = "398_1307873304.82979" 
    assign $P10304, $P10305
    nqp_get_sc_object $P10306, "1307873293.85412", 362
    .const 'Sub' $P10307 = "399_1307873304.82979" 
    assign $P10306, $P10307
    nqp_get_sc_object $P10308, "1307873293.85412", 363
    .const 'Sub' $P10309 = "400_1307873304.82979" 
    assign $P10308, $P10309
    nqp_get_sc_object $P10310, "1307873293.85412", 364
    .const 'Sub' $P10311 = "401_1307873304.82979" 
    assign $P10310, $P10311
    nqp_get_sc_object $P10312, "1307873293.85412", 365
    .const 'Sub' $P10313 = "402_1307873304.82979" 
    assign $P10312, $P10313
    nqp_get_sc_object $P10314, "1307873293.85412", 366
    .const 'Sub' $P10315 = "403_1307873304.82979" 
    assign $P10314, $P10315
    nqp_get_sc_object $P10316, "1307873293.85412", 367
    .const 'Sub' $P10317 = "404_1307873304.82979" 
    assign $P10316, $P10317
    nqp_get_sc_object $P10318, "1307873293.85412", 368
    .const 'Sub' $P10319 = "405_1307873304.82979" 
    assign $P10318, $P10319
    nqp_get_sc_object $P10320, "1307873293.85412", 369
    .const 'Sub' $P10321 = "407_1307873304.82979" 
    assign $P10320, $P10321
    nqp_get_sc_object $P10322, "1307873293.85412", 370
    .const 'Sub' $P10323 = "408_1307873304.82979" 
    assign $P10322, $P10323
    nqp_get_sc_object $P10324, "1307873293.85412", 371
    .const 'Sub' $P10325 = "409_1307873304.82979" 
    assign $P10324, $P10325
    nqp_get_sc_object $P10326, "1307873293.85412", 372
    .const 'Sub' $P10327 = "410_1307873304.82979" 
    assign $P10326, $P10327
    nqp_get_sc_object $P10328, "1307873293.85412", 373
    .const 'Sub' $P10329 = "411_1307873304.82979" 
    assign $P10328, $P10329
    nqp_get_sc_object $P10330, "1307873293.85412", 374
    .const 'Sub' $P10331 = "412_1307873304.82979" 
    assign $P10330, $P10331
    nqp_get_sc_object $P10332, "1307873293.85412", 375
    .const 'Sub' $P10333 = "413_1307873304.82979" 
    assign $P10332, $P10333
    nqp_get_sc_object $P10334, "1307873293.85412", 376
    .const 'Sub' $P10335 = "414_1307873304.82979" 
    assign $P10334, $P10335
    nqp_get_sc_object $P10336, "1307873293.85412", 377
    .const 'Sub' $P10337 = "415_1307873304.82979" 
    assign $P10336, $P10337
    nqp_get_sc_object $P10338, "1307873293.85412", 378
    .const 'Sub' $P10339 = "416_1307873304.82979" 
    assign $P10338, $P10339
    .const 'Sub' $P10340 = "40_1307873304.82979" 
    $P10341 = $P10340."get_lexinfo"()
    nqp_get_sc_object $P10342, "1307873293.85412", 16
    $P10341."set_static_lexpad_value"("$?PACKAGE", $P10342)
    .const 'Sub' $P10343 = "40_1307873304.82979" 
    $P10344 = $P10343."get_lexinfo"()
    $P10344."finish_static_lexpad"()
    .const 'Sub' $P10345 = "40_1307873304.82979" 
    $P10346 = $P10345."get_lexinfo"()
    nqp_get_sc_object $P10347, "1307873293.85412", 16
    $P10346."set_static_lexpad_value"("$?CLASS", $P10347)
    .const 'Sub' $P10348 = "40_1307873304.82979" 
    $P10349 = $P10348."get_lexinfo"()
    $P10349."finish_static_lexpad"()
    nqp_get_sc_object $P10350, "1307873293.85412", 380
    .const 'Sub' $P10351 = "418_1307873304.82979" 
    assign $P10350, $P10351
    nqp_get_sc_object $P10352, "1307873293.85412", 381
    .const 'Sub' $P10353 = "420_1307873304.82979" 
    assign $P10352, $P10353
    nqp_get_sc_object $P10354, "1307873293.85412", 382
    .const 'Sub' $P10355 = "421_1307873304.82979" 
    assign $P10354, $P10355
    nqp_get_sc_object $P10356, "1307873293.85412", 383
    .const 'Sub' $P10357 = "422_1307873304.82979" 
    assign $P10356, $P10357
    nqp_get_sc_object $P10358, "1307873293.85412", 384
    .const 'Sub' $P10359 = "423_1307873304.82979" 
    assign $P10358, $P10359
    nqp_get_sc_object $P10360, "1307873293.85412", 385
    .const 'Sub' $P10361 = "425_1307873304.82979" 
    assign $P10360, $P10361
    nqp_get_sc_object $P10362, "1307873293.85412", 386
    .const 'Sub' $P10363 = "426_1307873304.82979" 
    assign $P10362, $P10363
    nqp_get_sc_object $P10364, "1307873293.85412", 387
    .const 'Sub' $P10365 = "427_1307873304.82979" 
    assign $P10364, $P10365
    nqp_get_sc_object $P10366, "1307873293.85412", 388
    .const 'Sub' $P10367 = "428_1307873304.82979" 
    assign $P10366, $P10367
    nqp_get_sc_object $P10368, "1307873293.85412", 389
    .const 'Sub' $P10369 = "430_1307873304.82979" 
    assign $P10368, $P10369
    nqp_get_sc_object $P10370, "1307873293.85412", 390
    .const 'Sub' $P10371 = "431_1307873304.82979" 
    assign $P10370, $P10371
    nqp_get_sc_object $P10372, "1307873293.85412", 391
    .const 'Sub' $P10373 = "433_1307873304.82979" 
    assign $P10372, $P10373
    nqp_get_sc_object $P10374, "1307873293.85412", 392
    .const 'Sub' $P10375 = "434_1307873304.82979" 
    assign $P10374, $P10375
    nqp_get_sc_object $P10376, "1307873293.85412", 393
    .const 'Sub' $P10377 = "435_1307873304.82979" 
    assign $P10376, $P10377
    nqp_get_sc_object $P10378, "1307873293.85412", 394
    .const 'Sub' $P10379 = "436_1307873304.82979" 
    assign $P10378, $P10379
    nqp_get_sc_object $P10380, "1307873293.85412", 395
    .const 'Sub' $P10381 = "437_1307873304.82979" 
    assign $P10380, $P10381
    .const 'Sub' $P10382 = "417_1307873304.82979" 
    $P10383 = $P10382."get_lexinfo"()
    nqp_get_sc_object $P10384, "1307873293.85412", 379
    $P10383."set_static_lexpad_value"("$?PACKAGE", $P10384)
    .const 'Sub' $P10385 = "417_1307873304.82979" 
    $P10386 = $P10385."get_lexinfo"()
    $P10386."finish_static_lexpad"()
    .const 'Sub' $P10387 = "417_1307873304.82979" 
    $P10388 = $P10387."get_lexinfo"()
    nqp_get_sc_object $P10389, "1307873293.85412", 379
    $P10388."set_static_lexpad_value"("$?CLASS", $P10389)
    .const 'Sub' $P10390 = "417_1307873304.82979" 
    $P10391 = $P10390."get_lexinfo"()
    $P10391."finish_static_lexpad"()
    nqp_get_sc_object $P10392, "1307873293.85412", 397
    .const 'Sub' $P10393 = "465_1307873304.82979" 
    assign $P10392, $P10393
    nqp_get_sc_object $P10394, "1307873293.85412", 398
    .const 'Sub' $P10395 = "466_1307873304.82979" 
    assign $P10394, $P10395
    nqp_get_sc_object $P10396, "1307873293.85412", 399
    .const 'Sub' $P10397 = "467_1307873304.82979" 
    assign $P10396, $P10397
    nqp_get_sc_object $P10398, "1307873293.85412", 400
    .const 'Sub' $P10399 = "469_1307873304.82979" 
    assign $P10398, $P10399
    nqp_get_sc_object $P10400, "1307873293.85412", 401
    .const 'Sub' $P10401 = "471_1307873304.82979" 
    assign $P10400, $P10401
    nqp_get_sc_object $P10402, "1307873293.85412", 402
    .const 'Sub' $P10403 = "473_1307873304.82979" 
    assign $P10402, $P10403
    nqp_get_sc_object $P10404, "1307873293.85412", 403
    .const 'Sub' $P10405 = "474_1307873304.82979" 
    assign $P10404, $P10405
    nqp_get_sc_object $P10406, "1307873293.85412", 404
    .const 'Sub' $P10407 = "475_1307873304.82979" 
    assign $P10406, $P10407
    nqp_get_sc_object $P10408, "1307873293.85412", 405
    .const 'Sub' $P10409 = "476_1307873304.82979" 
    assign $P10408, $P10409
    nqp_get_sc_object $P10410, "1307873293.85412", 406
    .const 'Sub' $P10411 = "478_1307873304.82979" 
    assign $P10410, $P10411
    nqp_get_sc_object $P10412, "1307873293.85412", 407
    .const 'Sub' $P10413 = "479_1307873304.82979" 
    assign $P10412, $P10413
    nqp_get_sc_object $P10414, "1307873293.85412", 408
    .const 'Sub' $P10415 = "481_1307873304.82979" 
    assign $P10414, $P10415
    nqp_get_sc_object $P10416, "1307873293.85412", 409
    .const 'Sub' $P10417 = "482_1307873304.82979" 
    assign $P10416, $P10417
    nqp_get_sc_object $P10418, "1307873293.85412", 410
    .const 'Sub' $P10419 = "483_1307873304.82979" 
    assign $P10418, $P10419
    nqp_get_sc_object $P10420, "1307873293.85412", 411
    .const 'Sub' $P10421 = "484_1307873304.82979" 
    assign $P10420, $P10421
    nqp_get_sc_object $P10422, "1307873293.85412", 412
    .const 'Sub' $P10423 = "486_1307873304.82979" 
    assign $P10422, $P10423
    nqp_get_sc_object $P10424, "1307873293.85412", 413
    .const 'Sub' $P10425 = "487_1307873304.82979" 
    assign $P10424, $P10425
    nqp_get_sc_object $P10426, "1307873293.85412", 414
    .const 'Sub' $P10427 = "488_1307873304.82979" 
    assign $P10426, $P10427
    nqp_get_sc_object $P10428, "1307873293.85412", 415
    .const 'Sub' $P10429 = "489_1307873304.82979" 
    assign $P10428, $P10429
    nqp_get_sc_object $P10430, "1307873293.85412", 416
    .const 'Sub' $P10431 = "490_1307873304.82979" 
    assign $P10430, $P10431
    nqp_get_sc_object $P10432, "1307873293.85412", 417
    .const 'Sub' $P10433 = "491_1307873304.82979" 
    assign $P10432, $P10433
    nqp_get_sc_object $P10434, "1307873293.85412", 418
    .const 'Sub' $P10435 = "492_1307873304.82979" 
    assign $P10434, $P10435
    nqp_get_sc_object $P10436, "1307873293.85412", 419
    .const 'Sub' $P10437 = "493_1307873304.82979" 
    assign $P10436, $P10437
    nqp_get_sc_object $P10438, "1307873293.85412", 420
    .const 'Sub' $P10439 = "494_1307873304.82979" 
    assign $P10438, $P10439
    nqp_get_sc_object $P10440, "1307873293.85412", 421
    .const 'Sub' $P10441 = "495_1307873304.82979" 
    assign $P10440, $P10441
    nqp_get_sc_object $P10442, "1307873293.85412", 422
    .const 'Sub' $P10443 = "496_1307873304.82979" 
    assign $P10442, $P10443
    nqp_get_sc_object $P10444, "1307873293.85412", 423
    .const 'Sub' $P10445 = "497_1307873304.82979" 
    assign $P10444, $P10445
    nqp_get_sc_object $P10446, "1307873293.85412", 424
    .const 'Sub' $P10447 = "498_1307873304.82979" 
    assign $P10446, $P10447
    nqp_get_sc_object $P10448, "1307873293.85412", 425
    .const 'Sub' $P10449 = "499_1307873304.82979" 
    assign $P10448, $P10449
    nqp_get_sc_object $P10450, "1307873293.85412", 426
    .const 'Sub' $P10451 = "500_1307873304.82979" 
    assign $P10450, $P10451
    nqp_get_sc_object $P10452, "1307873293.85412", 427
    .const 'Sub' $P10453 = "501_1307873304.82979" 
    assign $P10452, $P10453
    nqp_get_sc_object $P10454, "1307873293.85412", 428
    .const 'Sub' $P10455 = "502_1307873304.82979" 
    assign $P10454, $P10455
    nqp_get_sc_object $P10456, "1307873293.85412", 429
    .const 'Sub' $P10457 = "503_1307873304.82979" 
    assign $P10456, $P10457
    nqp_get_sc_object $P10458, "1307873293.85412", 430
    .const 'Sub' $P10459 = "504_1307873304.82979" 
    assign $P10458, $P10459
    nqp_get_sc_object $P10460, "1307873293.85412", 431
    .const 'Sub' $P10461 = "505_1307873304.82979" 
    assign $P10460, $P10461
    nqp_get_sc_object $P10462, "1307873293.85412", 432
    .const 'Sub' $P10463 = "506_1307873304.82979" 
    assign $P10462, $P10463
    nqp_get_sc_object $P10464, "1307873293.85412", 433
    .const 'Sub' $P10465 = "507_1307873304.82979" 
    assign $P10464, $P10465
    nqp_get_sc_object $P10466, "1307873293.85412", 434
    .const 'Sub' $P10467 = "508_1307873304.82979" 
    assign $P10466, $P10467
    nqp_get_sc_object $P10468, "1307873293.85412", 435
    .const 'Sub' $P10469 = "509_1307873304.82979" 
    assign $P10468, $P10469
    nqp_get_sc_object $P10470, "1307873293.85412", 436
    .const 'Sub' $P10471 = "510_1307873304.82979" 
    assign $P10470, $P10471
    nqp_get_sc_object $P10472, "1307873293.85412", 437
    .const 'Sub' $P10473 = "516_1307873304.82979" 
    assign $P10472, $P10473
    nqp_get_sc_object $P10474, "1307873293.85412", 438
    .const 'Sub' $P10475 = "517_1307873304.82979" 
    assign $P10474, $P10475
    nqp_get_sc_object $P10476, "1307873293.85412", 439
    .const 'Sub' $P10477 = "518_1307873304.82979" 
    assign $P10476, $P10477
    nqp_get_sc_object $P10478, "1307873293.85412", 440
    .const 'Sub' $P10479 = "519_1307873304.82979" 
    assign $P10478, $P10479
    nqp_get_sc_object $P10480, "1307873293.85412", 441
    .const 'Sub' $P10481 = "520_1307873304.82979" 
    assign $P10480, $P10481
    nqp_get_sc_object $P10482, "1307873293.85412", 442
    .const 'Sub' $P10483 = "521_1307873304.82979" 
    assign $P10482, $P10483
    nqp_get_sc_object $P10484, "1307873293.85412", 443
    .const 'Sub' $P10485 = "522_1307873304.82979" 
    assign $P10484, $P10485
    nqp_get_sc_object $P10486, "1307873293.85412", 444
    .const 'Sub' $P10487 = "523_1307873304.82979" 
    assign $P10486, $P10487
    nqp_get_sc_object $P10488, "1307873293.85412", 445
    .const 'Sub' $P10489 = "529_1307873304.82979" 
    assign $P10488, $P10489
    nqp_get_sc_object $P10490, "1307873293.85412", 446
    .const 'Sub' $P10491 = "530_1307873304.82979" 
    assign $P10490, $P10491
    nqp_get_sc_object $P10492, "1307873293.85412", 447
    .const 'Sub' $P10493 = "531_1307873304.82979" 
    assign $P10492, $P10493
    nqp_get_sc_object $P10494, "1307873293.85412", 448
    .const 'Sub' $P10495 = "532_1307873304.82979" 
    assign $P10494, $P10495
    nqp_get_sc_object $P10496, "1307873293.85412", 449
    .const 'Sub' $P10497 = "533_1307873304.82979" 
    assign $P10496, $P10497
    nqp_get_sc_object $P10498, "1307873293.85412", 450
    .const 'Sub' $P10499 = "534_1307873304.82979" 
    assign $P10498, $P10499
    nqp_get_sc_object $P10500, "1307873293.85412", 451
    .const 'Sub' $P10501 = "535_1307873304.82979" 
    assign $P10500, $P10501
    nqp_get_sc_object $P10502, "1307873293.85412", 452
    .const 'Sub' $P10503 = "536_1307873304.82979" 
    assign $P10502, $P10503
    nqp_get_sc_object $P10504, "1307873293.85412", 453
    .const 'Sub' $P10505 = "537_1307873304.82979" 
    assign $P10504, $P10505
    nqp_get_sc_object $P10506, "1307873293.85412", 454
    .const 'Sub' $P10507 = "540_1307873304.82979" 
    assign $P10506, $P10507
    nqp_get_sc_object $P10508, "1307873293.85412", 455
    .const 'Sub' $P10509 = "541_1307873304.82979" 
    assign $P10508, $P10509
    nqp_get_sc_object $P10510, "1307873293.85412", 456
    .const 'Sub' $P10511 = "542_1307873304.82979" 
    assign $P10510, $P10511
    nqp_get_sc_object $P10512, "1307873293.85412", 457
    .const 'Sub' $P10513 = "549_1307873304.82979" 
    assign $P10512, $P10513
    nqp_get_sc_object $P10514, "1307873293.85412", 458
    .const 'Sub' $P10515 = "552_1307873304.82979" 
    assign $P10514, $P10515
    nqp_get_sc_object $P10516, "1307873293.85412", 459
    .const 'Sub' $P10517 = "555_1307873304.82979" 
    assign $P10516, $P10517
    nqp_get_sc_object $P10518, "1307873293.85412", 460
    .const 'Sub' $P10519 = "556_1307873304.82979" 
    assign $P10518, $P10519
    nqp_get_sc_object $P10520, "1307873293.85412", 461
    .const 'Sub' $P10521 = "557_1307873304.82979" 
    assign $P10520, $P10521
    nqp_get_sc_object $P10522, "1307873293.85412", 462
    .const 'Sub' $P10523 = "558_1307873304.82979" 
    assign $P10522, $P10523
    nqp_get_sc_object $P10524, "1307873293.85412", 463
    .const 'Sub' $P10525 = "560_1307873304.82979" 
    assign $P10524, $P10525
    nqp_get_sc_object $P10526, "1307873293.85412", 464
    .const 'Sub' $P10527 = "561_1307873304.82979" 
    assign $P10526, $P10527
    nqp_get_sc_object $P10528, "1307873293.85412", 465
    .const 'Sub' $P10529 = "566_1307873304.82979" 
    assign $P10528, $P10529
    nqp_get_sc_object $P10530, "1307873293.85412", 466
    .const 'Sub' $P10531 = "571_1307873304.82979" 
    assign $P10530, $P10531
    nqp_get_sc_object $P10532, "1307873293.85412", 467
    .const 'Sub' $P10533 = "572_1307873304.82979" 
    assign $P10532, $P10533
    nqp_get_sc_object $P10534, "1307873293.85412", 468
    .const 'Sub' $P10535 = "573_1307873304.82979" 
    assign $P10534, $P10535
    nqp_get_sc_object $P10536, "1307873293.85412", 469
    .const 'Sub' $P10537 = "574_1307873304.82979" 
    assign $P10536, $P10537
    nqp_get_sc_object $P10538, "1307873293.85412", 470
    .const 'Sub' $P10539 = "576_1307873304.82979" 
    assign $P10538, $P10539
    nqp_get_sc_object $P10540, "1307873293.85412", 471
    .const 'Sub' $P10541 = "577_1307873304.82979" 
    assign $P10540, $P10541
    nqp_get_sc_object $P10542, "1307873293.85412", 472
    .const 'Sub' $P10543 = "578_1307873304.82979" 
    assign $P10542, $P10543
    nqp_get_sc_object $P10544, "1307873293.85412", 473
    .const 'Sub' $P10545 = "579_1307873304.82979" 
    assign $P10544, $P10545
    nqp_get_sc_object $P10546, "1307873293.85412", 474
    .const 'Sub' $P10547 = "580_1307873304.82979" 
    assign $P10546, $P10547
    nqp_get_sc_object $P10548, "1307873293.85412", 475
    .const 'Sub' $P10549 = "583_1307873304.82979" 
    assign $P10548, $P10549
    nqp_get_sc_object $P10550, "1307873293.85412", 476
    .const 'Sub' $P10551 = "584_1307873304.82979" 
    assign $P10550, $P10551
    nqp_get_sc_object $P10552, "1307873293.85412", 477
    .const 'Sub' $P10553 = "585_1307873304.82979" 
    assign $P10552, $P10553
    nqp_get_sc_object $P10554, "1307873293.85412", 478
    .const 'Sub' $P10555 = "586_1307873304.82979" 
    assign $P10554, $P10555
    nqp_get_sc_object $P10556, "1307873293.85412", 479
    .const 'Sub' $P10557 = "587_1307873304.82979" 
    assign $P10556, $P10557
    nqp_get_sc_object $P10558, "1307873293.85412", 480
    .const 'Sub' $P10559 = "588_1307873304.82979" 
    assign $P10558, $P10559
    nqp_get_sc_object $P10560, "1307873293.85412", 481
    .const 'Sub' $P10561 = "589_1307873304.82979" 
    assign $P10560, $P10561
    nqp_get_sc_object $P10562, "1307873293.85412", 482
    .const 'Sub' $P10563 = "591_1307873304.82979" 
    assign $P10562, $P10563
    nqp_get_sc_object $P10564, "1307873293.85412", 483
    .const 'Sub' $P10565 = "592_1307873304.82979" 
    assign $P10564, $P10565
    nqp_get_sc_object $P10566, "1307873293.85412", 484
    .const 'Sub' $P10567 = "593_1307873304.82979" 
    assign $P10566, $P10567
    nqp_get_sc_object $P10568, "1307873293.85412", 485
    .const 'Sub' $P10569 = "594_1307873304.82979" 
    assign $P10568, $P10569
    nqp_get_sc_object $P10570, "1307873293.85412", 486
    .const 'Sub' $P10571 = "595_1307873304.82979" 
    assign $P10570, $P10571
    nqp_get_sc_object $P10572, "1307873293.85412", 487
    .const 'Sub' $P10573 = "596_1307873304.82979" 
    assign $P10572, $P10573
    nqp_get_sc_object $P10574, "1307873293.85412", 488
    .const 'Sub' $P10575 = "597_1307873304.82979" 
    assign $P10574, $P10575
    nqp_get_sc_object $P10576, "1307873293.85412", 489
    .const 'Sub' $P10577 = "598_1307873304.82979" 
    assign $P10576, $P10577
    nqp_get_sc_object $P10578, "1307873293.85412", 490
    .const 'Sub' $P10579 = "599_1307873304.82979" 
    assign $P10578, $P10579
    nqp_get_sc_object $P10580, "1307873293.85412", 491
    .const 'Sub' $P10581 = "600_1307873304.82979" 
    assign $P10580, $P10581
    nqp_get_sc_object $P10582, "1307873293.85412", 492
    .const 'Sub' $P10583 = "601_1307873304.82979" 
    assign $P10582, $P10583
    nqp_get_sc_object $P10584, "1307873293.85412", 493
    .const 'Sub' $P10585 = "602_1307873304.82979" 
    assign $P10584, $P10585
    nqp_get_sc_object $P10586, "1307873293.85412", 494
    .const 'Sub' $P10587 = "603_1307873304.82979" 
    assign $P10586, $P10587
    nqp_get_sc_object $P10588, "1307873293.85412", 495
    .const 'Sub' $P10589 = "604_1307873304.82979" 
    assign $P10588, $P10589
    nqp_get_sc_object $P10590, "1307873293.85412", 496
    .const 'Sub' $P10591 = "605_1307873304.82979" 
    assign $P10590, $P10591
    nqp_get_sc_object $P10592, "1307873293.85412", 497
    .const 'Sub' $P10593 = "606_1307873304.82979" 
    assign $P10592, $P10593
    nqp_get_sc_object $P10594, "1307873293.85412", 498
    .const 'Sub' $P10595 = "607_1307873304.82979" 
    assign $P10594, $P10595
    nqp_get_sc_object $P10596, "1307873293.85412", 499
    .const 'Sub' $P10597 = "608_1307873304.82979" 
    assign $P10596, $P10597
    nqp_get_sc_object $P10598, "1307873293.85412", 500
    .const 'Sub' $P10599 = "609_1307873304.82979" 
    assign $P10598, $P10599
    nqp_get_sc_object $P10600, "1307873293.85412", 501
    .const 'Sub' $P10601 = "610_1307873304.82979" 
    assign $P10600, $P10601
    nqp_get_sc_object $P10602, "1307873293.85412", 502
    .const 'Sub' $P10603 = "611_1307873304.82979" 
    assign $P10602, $P10603
    nqp_get_sc_object $P10604, "1307873293.85412", 503
    .const 'Sub' $P10605 = "612_1307873304.82979" 
    assign $P10604, $P10605
    nqp_get_sc_object $P10606, "1307873293.85412", 504
    .const 'Sub' $P10607 = "613_1307873304.82979" 
    assign $P10606, $P10607
    nqp_get_sc_object $P10608, "1307873293.85412", 505
    .const 'Sub' $P10609 = "614_1307873304.82979" 
    assign $P10608, $P10609
    nqp_get_sc_object $P10610, "1307873293.85412", 506
    .const 'Sub' $P10611 = "615_1307873304.82979" 
    assign $P10610, $P10611
    nqp_get_sc_object $P10612, "1307873293.85412", 507
    .const 'Sub' $P10613 = "616_1307873304.82979" 
    assign $P10612, $P10613
    nqp_get_sc_object $P10614, "1307873293.85412", 508
    .const 'Sub' $P10615 = "617_1307873304.82979" 
    assign $P10614, $P10615
    .const 'Sub' $P10616 = "438_1307873304.82979" 
    $P10617 = $P10616."get_lexinfo"()
    nqp_get_sc_object $P10618, "1307873293.85412", 396
    $P10617."set_static_lexpad_value"("$?PACKAGE", $P10618)
    .const 'Sub' $P10619 = "438_1307873304.82979" 
    $P10620 = $P10619."get_lexinfo"()
    $P10620."finish_static_lexpad"()
    .const 'Sub' $P10621 = "438_1307873304.82979" 
    $P10622 = $P10621."get_lexinfo"()
    nqp_get_sc_object $P10623, "1307873293.85412", 396
    $P10622."set_static_lexpad_value"("$?CLASS", $P10623)
    .const 'Sub' $P10624 = "438_1307873304.82979" 
    $P10625 = $P10624."get_lexinfo"()
    $P10625."finish_static_lexpad"()
    nqp_get_sc_object $P10626, "1307873293.85412", 510
    .const 'Sub' $P10627 = "620_1307873304.82979" 
    assign $P10626, $P10627
    nqp_get_sc_object $P10628, "1307873293.85412", 511
    .const 'Sub' $P10629 = "621_1307873304.82979" 
    assign $P10628, $P10629
    nqp_get_sc_object $P10630, "1307873293.85412", 512
    .const 'Sub' $P10631 = "622_1307873304.82979" 
    assign $P10630, $P10631
    nqp_get_sc_object $P10632, "1307873293.85412", 513
    .const 'Sub' $P10633 = "623_1307873304.82979" 
    assign $P10632, $P10633
    nqp_get_sc_object $P10634, "1307873293.85412", 514
    .const 'Sub' $P10635 = "624_1307873304.82979" 
    assign $P10634, $P10635
    nqp_get_sc_object $P10636, "1307873293.85412", 515
    .const 'Sub' $P10637 = "625_1307873304.82979" 
    assign $P10636, $P10637
    nqp_get_sc_object $P10638, "1307873293.85412", 516
    .const 'Sub' $P10639 = "626_1307873304.82979" 
    assign $P10638, $P10639
    .const 'Sub' $P10640 = "619_1307873304.82979" 
    $P10641 = $P10640."get_lexinfo"()
    nqp_get_sc_object $P10642, "1307873293.85412", 509
    $P10641."set_static_lexpad_value"("$?PACKAGE", $P10642)
    .const 'Sub' $P10643 = "619_1307873304.82979" 
    $P10644 = $P10643."get_lexinfo"()
    $P10644."finish_static_lexpad"()
    .const 'Sub' $P10645 = "619_1307873304.82979" 
    $P10646 = $P10645."get_lexinfo"()
    nqp_get_sc_object $P10647, "1307873293.85412", 509
    $P10646."set_static_lexpad_value"("$?CLASS", $P10647)
    .const 'Sub' $P10648 = "619_1307873304.82979" 
    $P10649 = $P10648."get_lexinfo"()
    $P10649."finish_static_lexpad"()
    .const 'Sub' $P10650 = "627_1307873304.82979" 
    $P10651 = $P10650."get_lexinfo"()
    nqp_get_sc_object $P10652, "1307873293.85412", 517
    $P10651."set_static_lexpad_value"("$?PACKAGE", $P10652)
    .const 'Sub' $P10653 = "627_1307873304.82979" 
    $P10654 = $P10653."get_lexinfo"()
    $P10654."finish_static_lexpad"()
    .const 'Sub' $P10655 = "627_1307873304.82979" 
    $P10656 = $P10655."get_lexinfo"()
    nqp_get_sc_object $P10657, "1307873293.85412", 517
    $P10656."set_static_lexpad_value"("$?CLASS", $P10657)
    .const 'Sub' $P10658 = "627_1307873304.82979" 
    $P10659 = $P10658."get_lexinfo"()
    $P10659."finish_static_lexpad"()
    goto if_7361_end
  if_7361:
    nqp_dynop_setup 
    getinterp $P7364
    get_class $P7365, "LexPad"
    get_class $P7366, "NQPLexPad"
    $P7364."hll_map"($P7365, $P7366)
    nqp_create_sc $P7367, "1307873293.85412"
    .local pmc cur_sc
    set cur_sc, $P7367
    nqp_get_sc_object $P7368, "__6MODEL_CORE__", 0
    $P7369 = $P7368."new_type"("GLOBALish" :named("name"))
    nqp_set_sc_for_object $P7369, cur_sc
    nqp_set_sc_object "1307873293.85412", 0, $P7369
    .const 'Sub' $P7370 = "10_1307873304.82979" 
    $P7371 = $P7370."get_lexinfo"()
    nqp_get_sc_object $P7372, "1307873293.85412", 0
    $P7371."set_static_lexpad_value"("GLOBALish", $P7372)
    .const 'Sub' $P7373 = "10_1307873304.82979" 
    $P7374 = $P7373."get_lexinfo"()
    $P7374."finish_static_lexpad"()
    .const 'Sub' $P7375 = "10_1307873304.82979" 
    $P7376 = $P7375."get_lexinfo"()
    nqp_get_sc_object $P7377, "1307873293.85412", 0
    $P7376."set_static_lexpad_value"("$?PACKAGE", $P7377)
    .const 'Sub' $P7378 = "10_1307873304.82979" 
    $P7379 = $P7378."get_lexinfo"()
    $P7379."finish_static_lexpad"()
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P7380, "ModuleLoader"
    $P7381 = $P7380."load_setting"("NQPCORE")
    block."set_outer_ctx"($P7381)
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P7382, "ModuleLoader"
    nqp_get_sc_object $P7383, "1307873293.85412", 0
    $P7382."load_module"("NQPRegex", $P7383)
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P7384, "ModuleLoader"
    nqp_get_sc_object $P7385, "1307873293.85412", 0
    $P7384."load_module"("NQPP6Regex", $P7385)
    nqp_get_sc_object $P7386, "1307873274.8766", 41
    $P7387 = $P7386."new_type"("NQP::SymbolTable" :named("name"))
    nqp_set_sc_for_object $P7387, cur_sc
    nqp_set_sc_object "1307873293.85412", 1, $P7387
    nqp_get_sc_object $P7388, "1307873293.85412", 1
    nqp_get_sc_object $P7389, "1307873293.85412", 0
    nqp_get_package_through_who $P7390, $P7389, "NQP"
    get_who $P7391, $P7390
    set $P7391["SymbolTable"], $P7388
    nqp_get_sc_object $P7392, "1307873293.85412", 1
    get_how $P7393, $P7392
    nqp_get_sc_object $P7394, "1307873293.85412", 1
    .const 'Sub' $P7395 = "14_1307873304.82979" 
    $P7393."add_method"($P7394, "load_setting", $P7395)
    nqp_get_sc_object $P7396, "1307873293.85412", 1
    get_how $P7397, $P7396
    nqp_get_sc_object $P7398, "1307873293.85412", 1
    .const 'Sub' $P7399 = "16_1307873304.82979" 
    $P7397."add_method"($P7398, "load_module", $P7399)
    nqp_get_sc_object $P7400, "1307873293.85412", 1
    get_how $P7401, $P7400
    nqp_get_sc_object $P7402, "1307873293.85412", 1
    .const 'Sub' $P7403 = "17_1307873304.82979" 
    $P7401."add_method"($P7402, "install_package_symbol", $P7403)
    nqp_get_sc_object $P7404, "1307873293.85412", 1
    get_how $P7405, $P7404
    nqp_get_sc_object $P7406, "1307873293.85412", 1
    .const 'Sub' $P7407 = "20_1307873304.82979" 
    $P7405."add_method"($P7406, "install_lexical_symbol", $P7407)
    nqp_get_sc_object $P7408, "1307873293.85412", 1
    get_how $P7409, $P7408
    nqp_get_sc_object $P7410, "1307873293.85412", 1
    .const 'Sub' $P7411 = "21_1307873304.82979" 
    $P7409."add_method"($P7410, "install_package_routine", $P7411)
    nqp_get_sc_object $P7412, "1307873293.85412", 1
    get_how $P7413, $P7412
    nqp_get_sc_object $P7414, "1307873293.85412", 1
    .const 'Sub' $P7415 = "22_1307873304.82979" 
    $P7413."add_method"($P7414, "pkg_create_mo", $P7415)
    nqp_get_sc_object $P7416, "1307873293.85412", 1
    get_how $P7417, $P7416
    nqp_get_sc_object $P7418, "1307873293.85412", 1
    .const 'Sub' $P7419 = "23_1307873304.82979" 
    $P7417."add_method"($P7418, "pkg_add_attribute", $P7419)
    nqp_get_sc_object $P7420, "1307873293.85412", 1
    get_how $P7421, $P7420
    nqp_get_sc_object $P7422, "1307873293.85412", 1
    .const 'Sub' $P7423 = "26_1307873304.82979" 
    $P7421."add_method"($P7422, "pkg_add_method", $P7423)
    nqp_get_sc_object $P7424, "1307873293.85412", 1
    get_how $P7425, $P7424
    nqp_get_sc_object $P7426, "1307873293.85412", 1
    .const 'Sub' $P7427 = "29_1307873304.82979" 
    $P7425."add_method"($P7426, "set_routine_signature", $P7427)
    nqp_get_sc_object $P7428, "1307873293.85412", 1
    get_how $P7429, $P7428
    nqp_get_sc_object $P7430, "1307873293.85412", 1
    .const 'Sub' $P7431 = "30_1307873304.82979" 
    $P7429."add_method"($P7430, "pkg_set_body_block", $P7431)
    nqp_get_sc_object $P7432, "1307873293.85412", 1
    get_how $P7433, $P7432
    nqp_get_sc_object $P7434, "1307873293.85412", 1
    .const 'Sub' $P7435 = "35_1307873304.82979" 
    $P7433."add_method"($P7434, "pkg_add_parent_or_role", $P7435)
    nqp_get_sc_object $P7436, "1307873293.85412", 1
    get_how $P7437, $P7436
    nqp_get_sc_object $P7438, "1307873293.85412", 1
    .const 'Sub' $P7439 = "36_1307873304.82979" 
    $P7437."add_method"($P7438, "pkg_add_parrot_vtable_handler_mapping", $P7439)
    nqp_get_sc_object $P7440, "1307873293.85412", 1
    get_how $P7441, $P7440
    nqp_get_sc_object $P7442, "1307873293.85412", 1
    .const 'Sub' $P7443 = "37_1307873304.82979" 
    $P7441."add_method"($P7442, "pkg_compose", $P7443)
    nqp_get_sc_object $P7444, "1307873293.85412", 1
    get_how $P7445, $P7444
    nqp_get_sc_object $P7446, "1307873293.85412", 1
    .const 'Sub' $P7447 = "38_1307873304.82979" 
    $P7445."add_method"($P7446, "to_past", $P7447)
    .const 'Sub' $P7448 = "13_1307873304.82979" 
    $P7449 = $P7448."get_lexinfo"()
    nqp_get_sc_object $P7450, "1307873293.85412", 1
    $P7449."set_static_lexpad_value"("$?PACKAGE", $P7450)
    .const 'Sub' $P7451 = "13_1307873304.82979" 
    $P7452 = $P7451."get_lexinfo"()
    $P7452."finish_static_lexpad"()
    .const 'Sub' $P7453 = "13_1307873304.82979" 
    $P7454 = $P7453."get_lexinfo"()
    nqp_get_sc_object $P7455, "1307873293.85412", 1
    $P7454."set_static_lexpad_value"("$?CLASS", $P7455)
    .const 'Sub' $P7456 = "13_1307873304.82979" 
    $P7457 = $P7456."get_lexinfo"()
    $P7457."finish_static_lexpad"()
    nqp_get_sc_object $P7458, "1307873293.85412", 1
    get_how $P7459, $P7458
    nqp_get_sc_object $P7460, "1307873293.85412", 1
    nqp_get_sc_object $P7461, "1307873280.77112", 195
    $P7459."add_parent"($P7460, $P7461)
    nqp_get_sc_object $P7462, "1307873293.85412", 1
    get_how $P7463, $P7462
    nqp_get_sc_object $P7464, "1307873293.85412", 1
    $P7463."compose"($P7464)
    nqp_get_sc_object $P7465, "1307873274.8766", 41
    $P7466 = $P7465."new_type"("NQP::Grammar" :named("name"))
    nqp_set_sc_for_object $P7466, cur_sc
    nqp_set_sc_object "1307873293.85412", 16, $P7466
    nqp_get_sc_object $P7467, "1307873293.85412", 16
    nqp_get_sc_object $P7468, "1307873293.85412", 0
    nqp_get_package_through_who $P7469, $P7468, "NQP"
    get_who $P7470, $P7469
    set $P7470["Grammar"], $P7467
    nqp_get_sc_object $P7471, "1307873293.85412", 16
    get_how $P7472, $P7471
    nqp_get_sc_object $P7473, "1307873293.85412", 16
    .const 'Sub' $P7474 = "41_1307873304.82979" 
    $P7472."add_method"($P7473, "TOP", $P7474)
    nqp_get_sc_object $P7475, "1307873293.85412", 16
    get_how $P7476, $P7475
    nqp_get_sc_object $P7477, "1307873293.85412", 16
    .const 'Sub' $P7478 = "42_1307873304.82979" 
    $P7476."add_method"($P7477, "identifier", $P7478)
    nqp_get_sc_object $P7479, "1307873293.85412", 16
    get_how $P7480, $P7479
    nqp_get_sc_object $P7481, "1307873293.85412", 16
    .const 'Sub' $P7482 = "43_1307873304.82979" 
    $P7480."add_method"($P7481, "!PREFIX__identifier", $P7482)
    nqp_get_sc_object $P7483, "1307873293.85412", 16
    get_how $P7484, $P7483
    nqp_get_sc_object $P7485, "1307873293.85412", 16
    .const 'Sub' $P7486 = "44_1307873304.82979" 
    $P7484."add_method"($P7485, "name", $P7486)
    nqp_get_sc_object $P7487, "1307873293.85412", 16
    get_how $P7488, $P7487
    nqp_get_sc_object $P7489, "1307873293.85412", 16
    .const 'Sub' $P7490 = "45_1307873304.82979" 
    $P7488."add_method"($P7489, "!PREFIX__name", $P7490)
    nqp_get_sc_object $P7491, "1307873293.85412", 16
    get_how $P7492, $P7491
    nqp_get_sc_object $P7493, "1307873293.85412", 16
    .const 'Sub' $P7494 = "46_1307873304.82979" 
    $P7492."add_method"($P7493, "deflongname", $P7494)
    nqp_get_sc_object $P7495, "1307873293.85412", 16
    get_how $P7496, $P7495
    nqp_get_sc_object $P7497, "1307873293.85412", 16
    .const 'Sub' $P7498 = "47_1307873304.82979" 
    $P7496."add_method"($P7497, "!PREFIX__deflongname", $P7498)
    nqp_get_sc_object $P7499, "1307873293.85412", 16
    get_how $P7500, $P7499
    nqp_get_sc_object $P7501, "1307873293.85412", 16
    .const 'Sub' $P7502 = "48_1307873304.82979" 
    $P7500."add_method"($P7501, "ENDSTMT", $P7502)
    nqp_get_sc_object $P7503, "1307873293.85412", 16
    get_how $P7504, $P7503
    nqp_get_sc_object $P7505, "1307873293.85412", 16
    .const 'Sub' $P7506 = "49_1307873304.82979" 
    $P7504."add_method"($P7505, "!PREFIX__ENDSTMT", $P7506)
    nqp_get_sc_object $P7507, "1307873293.85412", 16
    get_how $P7508, $P7507
    nqp_get_sc_object $P7509, "1307873293.85412", 16
    .const 'Sub' $P7510 = "50_1307873304.82979" 
    $P7508."add_method"($P7509, "ws", $P7510)
    nqp_get_sc_object $P7511, "1307873293.85412", 16
    get_how $P7512, $P7511
    nqp_get_sc_object $P7513, "1307873293.85412", 16
    .const 'Sub' $P7514 = "51_1307873304.82979" 
    $P7512."add_method"($P7513, "!PREFIX__ws", $P7514)
    nqp_get_sc_object $P7515, "1307873293.85412", 16
    get_how $P7516, $P7515
    nqp_get_sc_object $P7517, "1307873293.85412", 16
    .const 'Sub' $P7518 = "52_1307873304.82979" 
    $P7516."add_method"($P7517, "unv", $P7518)
    nqp_get_sc_object $P7519, "1307873293.85412", 16
    get_how $P7520, $P7519
    nqp_get_sc_object $P7521, "1307873293.85412", 16
    .const 'Sub' $P7522 = "54_1307873304.82979" 
    $P7520."add_method"($P7521, "!PREFIX__unv", $P7522)
    nqp_get_sc_object $P7523, "1307873293.85412", 16
    get_how $P7524, $P7523
    nqp_get_sc_object $P7525, "1307873293.85412", 16
    .const 'Sub' $P7526 = "55_1307873304.82979" 
    $P7524."add_method"($P7525, "pod_comment", $P7526)
    nqp_get_sc_object $P7527, "1307873293.85412", 16
    get_how $P7528, $P7527
    nqp_get_sc_object $P7529, "1307873293.85412", 16
    .const 'Sub' $P7530 = "57_1307873304.82979" 
    $P7528."add_method"($P7529, "!PREFIX__pod_comment", $P7530)
    nqp_get_sc_object $P7531, "1307873293.85412", 16
    get_how $P7532, $P7531
    nqp_get_sc_object $P7533, "1307873293.85412", 16
    .const 'Sub' $P7534 = "58_1307873304.82979" 
    $P7532."add_method"($P7533, "comp_unit", $P7534)
    nqp_get_sc_object $P7535, "1307873293.85412", 16
    get_how $P7536, $P7535
    nqp_get_sc_object $P7537, "1307873293.85412", 16
    .const 'Sub' $P7538 = "59_1307873304.82979" 
    $P7536."add_method"($P7537, "!PREFIX__comp_unit", $P7538)
    nqp_get_sc_object $P7539, "1307873293.85412", 16
    get_how $P7540, $P7539
    nqp_get_sc_object $P7541, "1307873293.85412", 16
    .const 'Sub' $P7542 = "60_1307873304.82979" 
    $P7540."add_method"($P7541, "statementlist", $P7542)
    nqp_get_sc_object $P7543, "1307873293.85412", 16
    get_how $P7544, $P7543
    nqp_get_sc_object $P7545, "1307873293.85412", 16
    .const 'Sub' $P7546 = "61_1307873304.82979" 
    $P7544."add_method"($P7545, "!PREFIX__statementlist", $P7546)
    nqp_get_sc_object $P7547, "1307873293.85412", 16
    get_how $P7548, $P7547
    nqp_get_sc_object $P7549, "1307873293.85412", 16
    .const 'Sub' $P7550 = "62_1307873304.82979" 
    $P7548."add_method"($P7549, "statement", $P7550)
    nqp_get_sc_object $P7551, "1307873293.85412", 16
    get_how $P7552, $P7551
    nqp_get_sc_object $P7553, "1307873293.85412", 16
    .const 'Sub' $P7554 = "64_1307873304.82979" 
    $P7552."add_method"($P7553, "!PREFIX__statement", $P7554)
    nqp_get_sc_object $P7555, "1307873293.85412", 16
    get_how $P7556, $P7555
    nqp_get_sc_object $P7557, "1307873293.85412", 16
    .const 'Sub' $P7558 = "65_1307873304.82979" 
    $P7556."add_method"($P7557, "eat_terminator", $P7558)
    nqp_get_sc_object $P7559, "1307873293.85412", 16
    get_how $P7560, $P7559
    nqp_get_sc_object $P7561, "1307873293.85412", 16
    .const 'Sub' $P7562 = "66_1307873304.82979" 
    $P7560."add_method"($P7561, "!PREFIX__eat_terminator", $P7562)
    nqp_get_sc_object $P7563, "1307873293.85412", 16
    get_how $P7564, $P7563
    nqp_get_sc_object $P7565, "1307873293.85412", 16
    .const 'Sub' $P7566 = "67_1307873304.82979" 
    $P7564."add_method"($P7565, "xblock", $P7566)
    nqp_get_sc_object $P7567, "1307873293.85412", 16
    get_how $P7568, $P7567
    nqp_get_sc_object $P7569, "1307873293.85412", 16
    .const 'Sub' $P7570 = "68_1307873304.82979" 
    $P7568."add_method"($P7569, "!PREFIX__xblock", $P7570)
    nqp_get_sc_object $P7571, "1307873293.85412", 16
    get_how $P7572, $P7571
    nqp_get_sc_object $P7573, "1307873293.85412", 16
    .const 'Sub' $P7574 = "69_1307873304.82979" 
    $P7572."add_method"($P7573, "pblock", $P7574)
    nqp_get_sc_object $P7575, "1307873293.85412", 16
    get_how $P7576, $P7575
    nqp_get_sc_object $P7577, "1307873293.85412", 16
    .const 'Sub' $P7578 = "70_1307873304.82979" 
    $P7576."add_method"($P7577, "!PREFIX__pblock", $P7578)
    nqp_get_sc_object $P7579, "1307873293.85412", 16
    get_how $P7580, $P7579
    nqp_get_sc_object $P7581, "1307873293.85412", 16
    .const 'Sub' $P7582 = "71_1307873304.82979" 
    $P7580."add_method"($P7581, "lambda", $P7582)
    nqp_get_sc_object $P7583, "1307873293.85412", 16
    get_how $P7584, $P7583
    nqp_get_sc_object $P7585, "1307873293.85412", 16
    .const 'Sub' $P7586 = "72_1307873304.82979" 
    $P7584."add_method"($P7585, "!PREFIX__lambda", $P7586)
    nqp_get_sc_object $P7587, "1307873293.85412", 16
    get_how $P7588, $P7587
    nqp_get_sc_object $P7589, "1307873293.85412", 16
    .const 'Sub' $P7590 = "73_1307873304.82979" 
    $P7588."add_method"($P7589, "block", $P7590)
    nqp_get_sc_object $P7591, "1307873293.85412", 16
    get_how $P7592, $P7591
    nqp_get_sc_object $P7593, "1307873293.85412", 16
    .const 'Sub' $P7594 = "74_1307873304.82979" 
    $P7592."add_method"($P7593, "!PREFIX__block", $P7594)
    nqp_get_sc_object $P7595, "1307873293.85412", 16
    get_how $P7596, $P7595
    nqp_get_sc_object $P7597, "1307873293.85412", 16
    .const 'Sub' $P7598 = "75_1307873304.82979" 
    $P7596."add_method"($P7597, "blockoid", $P7598)
    nqp_get_sc_object $P7599, "1307873293.85412", 16
    get_how $P7600, $P7599
    nqp_get_sc_object $P7601, "1307873293.85412", 16
    .const 'Sub' $P7602 = "76_1307873304.82979" 
    $P7600."add_method"($P7601, "!PREFIX__blockoid", $P7602)
    nqp_get_sc_object $P7603, "1307873293.85412", 16
    get_how $P7604, $P7603
    nqp_get_sc_object $P7605, "1307873293.85412", 16
    .const 'Sub' $P7606 = "77_1307873304.82979" 
    $P7604."add_method"($P7605, "newpad", $P7606)
    nqp_get_sc_object $P7607, "1307873293.85412", 16
    get_how $P7608, $P7607
    nqp_get_sc_object $P7609, "1307873293.85412", 16
    .const 'Sub' $P7610 = "78_1307873304.82979" 
    $P7608."add_method"($P7609, "!PREFIX__newpad", $P7610)
    nqp_get_sc_object $P7611, "1307873293.85412", 16
    get_how $P7612, $P7611
    nqp_get_sc_object $P7613, "1307873293.85412", 16
    .const 'Sub' $P7614 = "79_1307873304.82979" 
    $P7612."add_method"($P7613, "outerctx", $P7614)
    nqp_get_sc_object $P7615, "1307873293.85412", 16
    get_how $P7616, $P7615
    nqp_get_sc_object $P7617, "1307873293.85412", 16
    .const 'Sub' $P7618 = "80_1307873304.82979" 
    $P7616."add_method"($P7617, "!PREFIX__outerctx", $P7618)
    nqp_get_sc_object $P7619, "1307873293.85412", 16
    get_how $P7620, $P7619
    nqp_get_sc_object $P7621, "1307873293.85412", 16
    .const 'Sub' $P7622 = "81_1307873304.82979" 
    $P7620."add_method"($P7621, "GLOBALish", $P7622)
    nqp_get_sc_object $P7623, "1307873293.85412", 16
    get_how $P7624, $P7623
    nqp_get_sc_object $P7625, "1307873293.85412", 16
    .const 'Sub' $P7626 = "82_1307873304.82979" 
    $P7624."add_method"($P7625, "!PREFIX__GLOBALish", $P7626)
    nqp_get_sc_object $P7627, "1307873293.85412", 16
    get_how $P7628, $P7627
    nqp_get_sc_object $P7629, "1307873293.85412", 16
    .const 'Sub' $P7630 = "83_1307873304.82979" 
    $P7628."add_method"($P7629, "finishpad", $P7630)
    nqp_get_sc_object $P7631, "1307873293.85412", 16
    get_how $P7632, $P7631
    nqp_get_sc_object $P7633, "1307873293.85412", 16
    .const 'Sub' $P7634 = "84_1307873304.82979" 
    $P7632."add_method"($P7633, "!PREFIX__finishpad", $P7634)
    nqp_get_sc_object $P7635, "1307873293.85412", 16
    get_how $P7636, $P7635
    nqp_get_sc_object $P7637, "1307873293.85412", 16
    .const 'Sub' $P7638 = "85_1307873304.82979" 
    $P7636."add_method"($P7637, "you_are_here", $P7638)
    nqp_get_sc_object $P7639, "1307873293.85412", 16
    get_how $P7640, $P7639
    nqp_get_sc_object $P7641, "1307873293.85412", 16
    .const 'Sub' $P7642 = "86_1307873304.82979" 
    $P7640."add_method"($P7641, "!PREFIX__you_are_here", $P7642)
    nqp_get_sc_object $P7643, "1307873293.85412", 16
    get_how $P7644, $P7643
    nqp_get_sc_object $P7645, "1307873293.85412", 16
    .const 'Sub' $P7646 = "87_1307873304.82979" 
    $P7644."add_method"($P7645, "terminator", $P7646)
    nqp_get_sc_object $P7647, "1307873293.85412", 16
    get_how $P7648, $P7647
    nqp_get_sc_object $P7649, "1307873293.85412", 16
    .const 'Sub' $P7650 = "88_1307873304.82979" 
    $P7648."add_method"($P7649, "!PREFIX__terminator", $P7650)
    nqp_get_sc_object $P7651, "1307873293.85412", 16
    get_how $P7652, $P7651
    nqp_get_sc_object $P7653, "1307873293.85412", 16
    .const 'Sub' $P7654 = "89_1307873304.82979" 
    $P7652."add_method"($P7653, "terminator:sym<;>", $P7654)
    nqp_get_sc_object $P7655, "1307873293.85412", 16
    get_how $P7656, $P7655
    nqp_get_sc_object $P7657, "1307873293.85412", 16
    .const 'Sub' $P7658 = "90_1307873304.82979" 
    $P7656."add_method"($P7657, "!PREFIX__terminator:sym<;>", $P7658)
    nqp_get_sc_object $P7659, "1307873293.85412", 16
    get_how $P7660, $P7659
    nqp_get_sc_object $P7661, "1307873293.85412", 16
    .const 'Sub' $P7662 = "91_1307873304.82979" 
    $P7660."add_method"($P7661, "terminator:sym<}>", $P7662)
    nqp_get_sc_object $P7663, "1307873293.85412", 16
    get_how $P7664, $P7663
    nqp_get_sc_object $P7665, "1307873293.85412", 16
    .const 'Sub' $P7666 = "92_1307873304.82979" 
    $P7664."add_method"($P7665, "!PREFIX__terminator:sym<}>", $P7666)
    nqp_get_sc_object $P7667, "1307873293.85412", 16
    get_how $P7668, $P7667
    nqp_get_sc_object $P7669, "1307873293.85412", 16
    .const 'Sub' $P7670 = "93_1307873304.82979" 
    $P7668."add_method"($P7669, "statement_control", $P7670)
    nqp_get_sc_object $P7671, "1307873293.85412", 16
    get_how $P7672, $P7671
    nqp_get_sc_object $P7673, "1307873293.85412", 16
    .const 'Sub' $P7674 = "94_1307873304.82979" 
    $P7672."add_method"($P7673, "!PREFIX__statement_control", $P7674)
    nqp_get_sc_object $P7675, "1307873293.85412", 16
    get_how $P7676, $P7675
    nqp_get_sc_object $P7677, "1307873293.85412", 16
    .const 'Sub' $P7678 = "95_1307873304.82979" 
    $P7676."add_method"($P7677, "statement_control:sym<use>", $P7678)
    nqp_get_sc_object $P7679, "1307873293.85412", 16
    get_how $P7680, $P7679
    nqp_get_sc_object $P7681, "1307873293.85412", 16
    .const 'Sub' $P7682 = "96_1307873304.82979" 
    $P7680."add_method"($P7681, "!PREFIX__statement_control:sym<use>", $P7682)
    nqp_get_sc_object $P7683, "1307873293.85412", 16
    get_how $P7684, $P7683
    nqp_get_sc_object $P7685, "1307873293.85412", 16
    .const 'Sub' $P7686 = "97_1307873304.82979" 
    $P7684."add_method"($P7685, "statement_control:sym<if>", $P7686)
    nqp_get_sc_object $P7687, "1307873293.85412", 16
    get_how $P7688, $P7687
    nqp_get_sc_object $P7689, "1307873293.85412", 16
    .const 'Sub' $P7690 = "98_1307873304.82979" 
    $P7688."add_method"($P7689, "!PREFIX__statement_control:sym<if>", $P7690)
    nqp_get_sc_object $P7691, "1307873293.85412", 16
    get_how $P7692, $P7691
    nqp_get_sc_object $P7693, "1307873293.85412", 16
    .const 'Sub' $P7694 = "99_1307873304.82979" 
    $P7692."add_method"($P7693, "statement_control:sym<unless>", $P7694)
    nqp_get_sc_object $P7695, "1307873293.85412", 16
    get_how $P7696, $P7695
    nqp_get_sc_object $P7697, "1307873293.85412", 16
    .const 'Sub' $P7698 = "101_1307873304.82979" 
    $P7696."add_method"($P7697, "!PREFIX__statement_control:sym<unless>", $P7698)
    nqp_get_sc_object $P7699, "1307873293.85412", 16
    get_how $P7700, $P7699
    nqp_get_sc_object $P7701, "1307873293.85412", 16
    .const 'Sub' $P7702 = "102_1307873304.82979" 
    $P7700."add_method"($P7701, "statement_control:sym<while>", $P7702)
    nqp_get_sc_object $P7703, "1307873293.85412", 16
    get_how $P7704, $P7703
    nqp_get_sc_object $P7705, "1307873293.85412", 16
    .const 'Sub' $P7706 = "103_1307873304.82979" 
    $P7704."add_method"($P7705, "!PREFIX__statement_control:sym<while>", $P7706)
    nqp_get_sc_object $P7707, "1307873293.85412", 16
    get_how $P7708, $P7707
    nqp_get_sc_object $P7709, "1307873293.85412", 16
    .const 'Sub' $P7710 = "104_1307873304.82979" 
    $P7708."add_method"($P7709, "statement_control:sym<repeat>", $P7710)
    nqp_get_sc_object $P7711, "1307873293.85412", 16
    get_how $P7712, $P7711
    nqp_get_sc_object $P7713, "1307873293.85412", 16
    .const 'Sub' $P7714 = "105_1307873304.82979" 
    $P7712."add_method"($P7713, "!PREFIX__statement_control:sym<repeat>", $P7714)
    nqp_get_sc_object $P7715, "1307873293.85412", 16
    get_how $P7716, $P7715
    nqp_get_sc_object $P7717, "1307873293.85412", 16
    .const 'Sub' $P7718 = "106_1307873304.82979" 
    $P7716."add_method"($P7717, "statement_control:sym<for>", $P7718)
    nqp_get_sc_object $P7719, "1307873293.85412", 16
    get_how $P7720, $P7719
    nqp_get_sc_object $P7721, "1307873293.85412", 16
    .const 'Sub' $P7722 = "107_1307873304.82979" 
    $P7720."add_method"($P7721, "!PREFIX__statement_control:sym<for>", $P7722)
    nqp_get_sc_object $P7723, "1307873293.85412", 16
    get_how $P7724, $P7723
    nqp_get_sc_object $P7725, "1307873293.85412", 16
    .const 'Sub' $P7726 = "108_1307873304.82979" 
    $P7724."add_method"($P7725, "statement_control:sym<CATCH>", $P7726)
    nqp_get_sc_object $P7727, "1307873293.85412", 16
    get_how $P7728, $P7727
    nqp_get_sc_object $P7729, "1307873293.85412", 16
    .const 'Sub' $P7730 = "109_1307873304.82979" 
    $P7728."add_method"($P7729, "!PREFIX__statement_control:sym<CATCH>", $P7730)
    nqp_get_sc_object $P7731, "1307873293.85412", 16
    get_how $P7732, $P7731
    nqp_get_sc_object $P7733, "1307873293.85412", 16
    .const 'Sub' $P7734 = "110_1307873304.82979" 
    $P7732."add_method"($P7733, "statement_control:sym<CONTROL>", $P7734)
    nqp_get_sc_object $P7735, "1307873293.85412", 16
    get_how $P7736, $P7735
    nqp_get_sc_object $P7737, "1307873293.85412", 16
    .const 'Sub' $P7738 = "111_1307873304.82979" 
    $P7736."add_method"($P7737, "!PREFIX__statement_control:sym<CONTROL>", $P7738)
    nqp_get_sc_object $P7739, "1307873293.85412", 16
    get_how $P7740, $P7739
    nqp_get_sc_object $P7741, "1307873293.85412", 16
    .const 'Sub' $P7742 = "112_1307873304.82979" 
    $P7740."add_method"($P7741, "statement_prefix", $P7742)
    nqp_get_sc_object $P7743, "1307873293.85412", 16
    get_how $P7744, $P7743
    nqp_get_sc_object $P7745, "1307873293.85412", 16
    .const 'Sub' $P7746 = "113_1307873304.82979" 
    $P7744."add_method"($P7745, "!PREFIX__statement_prefix", $P7746)
    nqp_get_sc_object $P7747, "1307873293.85412", 16
    get_how $P7748, $P7747
    nqp_get_sc_object $P7749, "1307873293.85412", 16
    .const 'Sub' $P7750 = "114_1307873304.82979" 
    $P7748."add_method"($P7749, "statement_prefix:sym<INIT>", $P7750)
    nqp_get_sc_object $P7751, "1307873293.85412", 16
    get_how $P7752, $P7751
    nqp_get_sc_object $P7753, "1307873293.85412", 16
    .const 'Sub' $P7754 = "115_1307873304.82979" 
    $P7752."add_method"($P7753, "!PREFIX__statement_prefix:sym<INIT>", $P7754)
    nqp_get_sc_object $P7755, "1307873293.85412", 16
    get_how $P7756, $P7755
    nqp_get_sc_object $P7757, "1307873293.85412", 16
    .const 'Sub' $P7758 = "116_1307873304.82979" 
    $P7756."add_method"($P7757, "statement_prefix:sym<try>", $P7758)
    nqp_get_sc_object $P7759, "1307873293.85412", 16
    get_how $P7760, $P7759
    nqp_get_sc_object $P7761, "1307873293.85412", 16
    .const 'Sub' $P7762 = "117_1307873304.82979" 
    $P7760."add_method"($P7761, "!PREFIX__statement_prefix:sym<try>", $P7762)
    nqp_get_sc_object $P7763, "1307873293.85412", 16
    get_how $P7764, $P7763
    nqp_get_sc_object $P7765, "1307873293.85412", 16
    .const 'Sub' $P7766 = "118_1307873304.82979" 
    $P7764."add_method"($P7765, "blorst", $P7766)
    nqp_get_sc_object $P7767, "1307873293.85412", 16
    get_how $P7768, $P7767
    nqp_get_sc_object $P7769, "1307873293.85412", 16
    .const 'Sub' $P7770 = "119_1307873304.82979" 
    $P7768."add_method"($P7769, "!PREFIX__blorst", $P7770)
    nqp_get_sc_object $P7771, "1307873293.85412", 16
    get_how $P7772, $P7771
    nqp_get_sc_object $P7773, "1307873293.85412", 16
    .const 'Sub' $P7774 = "120_1307873304.82979" 
    $P7772."add_method"($P7773, "statement_mod_cond", $P7774)
    nqp_get_sc_object $P7775, "1307873293.85412", 16
    get_how $P7776, $P7775
    nqp_get_sc_object $P7777, "1307873293.85412", 16
    .const 'Sub' $P7778 = "121_1307873304.82979" 
    $P7776."add_method"($P7777, "!PREFIX__statement_mod_cond", $P7778)
    nqp_get_sc_object $P7779, "1307873293.85412", 16
    get_how $P7780, $P7779
    nqp_get_sc_object $P7781, "1307873293.85412", 16
    .const 'Sub' $P7782 = "122_1307873304.82979" 
    $P7780."add_method"($P7781, "statement_mod_cond:sym<if>", $P7782)
    nqp_get_sc_object $P7783, "1307873293.85412", 16
    get_how $P7784, $P7783
    nqp_get_sc_object $P7785, "1307873293.85412", 16
    .const 'Sub' $P7786 = "123_1307873304.82979" 
    $P7784."add_method"($P7785, "!PREFIX__statement_mod_cond:sym<if>", $P7786)
    nqp_get_sc_object $P7787, "1307873293.85412", 16
    get_how $P7788, $P7787
    nqp_get_sc_object $P7789, "1307873293.85412", 16
    .const 'Sub' $P7790 = "124_1307873304.82979" 
    $P7788."add_method"($P7789, "statement_mod_cond:sym<unless>", $P7790)
    nqp_get_sc_object $P7791, "1307873293.85412", 16
    get_how $P7792, $P7791
    nqp_get_sc_object $P7793, "1307873293.85412", 16
    .const 'Sub' $P7794 = "125_1307873304.82979" 
    $P7792."add_method"($P7793, "!PREFIX__statement_mod_cond:sym<unless>", $P7794)
    nqp_get_sc_object $P7795, "1307873293.85412", 16
    get_how $P7796, $P7795
    nqp_get_sc_object $P7797, "1307873293.85412", 16
    .const 'Sub' $P7798 = "126_1307873304.82979" 
    $P7796."add_method"($P7797, "statement_mod_loop", $P7798)
    nqp_get_sc_object $P7799, "1307873293.85412", 16
    get_how $P7800, $P7799
    nqp_get_sc_object $P7801, "1307873293.85412", 16
    .const 'Sub' $P7802 = "127_1307873304.82979" 
    $P7800."add_method"($P7801, "!PREFIX__statement_mod_loop", $P7802)
    nqp_get_sc_object $P7803, "1307873293.85412", 16
    get_how $P7804, $P7803
    nqp_get_sc_object $P7805, "1307873293.85412", 16
    .const 'Sub' $P7806 = "128_1307873304.82979" 
    $P7804."add_method"($P7805, "statement_mod_loop:sym<while>", $P7806)
    nqp_get_sc_object $P7807, "1307873293.85412", 16
    get_how $P7808, $P7807
    nqp_get_sc_object $P7809, "1307873293.85412", 16
    .const 'Sub' $P7810 = "129_1307873304.82979" 
    $P7808."add_method"($P7809, "!PREFIX__statement_mod_loop:sym<while>", $P7810)
    nqp_get_sc_object $P7811, "1307873293.85412", 16
    get_how $P7812, $P7811
    nqp_get_sc_object $P7813, "1307873293.85412", 16
    .const 'Sub' $P7814 = "130_1307873304.82979" 
    $P7812."add_method"($P7813, "statement_mod_loop:sym<until>", $P7814)
    nqp_get_sc_object $P7815, "1307873293.85412", 16
    get_how $P7816, $P7815
    nqp_get_sc_object $P7817, "1307873293.85412", 16
    .const 'Sub' $P7818 = "131_1307873304.82979" 
    $P7816."add_method"($P7817, "!PREFIX__statement_mod_loop:sym<until>", $P7818)
    nqp_get_sc_object $P7819, "1307873293.85412", 16
    get_how $P7820, $P7819
    nqp_get_sc_object $P7821, "1307873293.85412", 16
    .const 'Sub' $P7822 = "132_1307873304.82979" 
    $P7820."add_method"($P7821, "statement_mod_loop:sym<for>", $P7822)
    nqp_get_sc_object $P7823, "1307873293.85412", 16
    get_how $P7824, $P7823
    nqp_get_sc_object $P7825, "1307873293.85412", 16
    .const 'Sub' $P7826 = "133_1307873304.82979" 
    $P7824."add_method"($P7825, "!PREFIX__statement_mod_loop:sym<for>", $P7826)
    nqp_get_sc_object $P7827, "1307873293.85412", 16
    get_how $P7828, $P7827
    nqp_get_sc_object $P7829, "1307873293.85412", 16
    .const 'Sub' $P7830 = "134_1307873304.82979" 
    $P7828."add_method"($P7829, "term:sym<fatarrow>", $P7830)
    nqp_get_sc_object $P7831, "1307873293.85412", 16
    get_how $P7832, $P7831
    nqp_get_sc_object $P7833, "1307873293.85412", 16
    .const 'Sub' $P7834 = "135_1307873304.82979" 
    $P7832."add_method"($P7833, "!PREFIX__term:sym<fatarrow>", $P7834)
    nqp_get_sc_object $P7835, "1307873293.85412", 16
    get_how $P7836, $P7835
    nqp_get_sc_object $P7837, "1307873293.85412", 16
    .const 'Sub' $P7838 = "136_1307873304.82979" 
    $P7836."add_method"($P7837, "term:sym<colonpair>", $P7838)
    nqp_get_sc_object $P7839, "1307873293.85412", 16
    get_how $P7840, $P7839
    nqp_get_sc_object $P7841, "1307873293.85412", 16
    .const 'Sub' $P7842 = "137_1307873304.82979" 
    $P7840."add_method"($P7841, "!PREFIX__term:sym<colonpair>", $P7842)
    nqp_get_sc_object $P7843, "1307873293.85412", 16
    get_how $P7844, $P7843
    nqp_get_sc_object $P7845, "1307873293.85412", 16
    .const 'Sub' $P7846 = "138_1307873304.82979" 
    $P7844."add_method"($P7845, "term:sym<variable>", $P7846)
    nqp_get_sc_object $P7847, "1307873293.85412", 16
    get_how $P7848, $P7847
    nqp_get_sc_object $P7849, "1307873293.85412", 16
    .const 'Sub' $P7850 = "139_1307873304.82979" 
    $P7848."add_method"($P7849, "!PREFIX__term:sym<variable>", $P7850)
    nqp_get_sc_object $P7851, "1307873293.85412", 16
    get_how $P7852, $P7851
    nqp_get_sc_object $P7853, "1307873293.85412", 16
    .const 'Sub' $P7854 = "140_1307873304.82979" 
    $P7852."add_method"($P7853, "term:sym<package_declarator>", $P7854)
    nqp_get_sc_object $P7855, "1307873293.85412", 16
    get_how $P7856, $P7855
    nqp_get_sc_object $P7857, "1307873293.85412", 16
    .const 'Sub' $P7858 = "141_1307873304.82979" 
    $P7856."add_method"($P7857, "!PREFIX__term:sym<package_declarator>", $P7858)
    nqp_get_sc_object $P7859, "1307873293.85412", 16
    get_how $P7860, $P7859
    nqp_get_sc_object $P7861, "1307873293.85412", 16
    .const 'Sub' $P7862 = "142_1307873304.82979" 
    $P7860."add_method"($P7861, "term:sym<scope_declarator>", $P7862)
    nqp_get_sc_object $P7863, "1307873293.85412", 16
    get_how $P7864, $P7863
    nqp_get_sc_object $P7865, "1307873293.85412", 16
    .const 'Sub' $P7866 = "143_1307873304.82979" 
    $P7864."add_method"($P7865, "!PREFIX__term:sym<scope_declarator>", $P7866)
    nqp_get_sc_object $P7867, "1307873293.85412", 16
    get_how $P7868, $P7867
    nqp_get_sc_object $P7869, "1307873293.85412", 16
    .const 'Sub' $P7870 = "144_1307873304.82979" 
    $P7868."add_method"($P7869, "term:sym<routine_declarator>", $P7870)
    nqp_get_sc_object $P7871, "1307873293.85412", 16
    get_how $P7872, $P7871
    nqp_get_sc_object $P7873, "1307873293.85412", 16
    .const 'Sub' $P7874 = "145_1307873304.82979" 
    $P7872."add_method"($P7873, "!PREFIX__term:sym<routine_declarator>", $P7874)
    nqp_get_sc_object $P7875, "1307873293.85412", 16
    get_how $P7876, $P7875
    nqp_get_sc_object $P7877, "1307873293.85412", 16
    .const 'Sub' $P7878 = "146_1307873304.82979" 
    $P7876."add_method"($P7877, "term:sym<multi_declarator>", $P7878)
    nqp_get_sc_object $P7879, "1307873293.85412", 16
    get_how $P7880, $P7879
    nqp_get_sc_object $P7881, "1307873293.85412", 16
    .const 'Sub' $P7882 = "149_1307873304.82979" 
    $P7880."add_method"($P7881, "!PREFIX__term:sym<multi_declarator>", $P7882)
    nqp_get_sc_object $P7883, "1307873293.85412", 16
    get_how $P7884, $P7883
    nqp_get_sc_object $P7885, "1307873293.85412", 16
    .const 'Sub' $P7886 = "150_1307873304.82979" 
    $P7884."add_method"($P7885, "term:sym<regex_declarator>", $P7886)
    nqp_get_sc_object $P7887, "1307873293.85412", 16
    get_how $P7888, $P7887
    nqp_get_sc_object $P7889, "1307873293.85412", 16
    .const 'Sub' $P7890 = "151_1307873304.82979" 
    $P7888."add_method"($P7889, "!PREFIX__term:sym<regex_declarator>", $P7890)
    nqp_get_sc_object $P7891, "1307873293.85412", 16
    get_how $P7892, $P7891
    nqp_get_sc_object $P7893, "1307873293.85412", 16
    .const 'Sub' $P7894 = "152_1307873304.82979" 
    $P7892."add_method"($P7893, "term:sym<statement_prefix>", $P7894)
    nqp_get_sc_object $P7895, "1307873293.85412", 16
    get_how $P7896, $P7895
    nqp_get_sc_object $P7897, "1307873293.85412", 16
    .const 'Sub' $P7898 = "153_1307873304.82979" 
    $P7896."add_method"($P7897, "!PREFIX__term:sym<statement_prefix>", $P7898)
    nqp_get_sc_object $P7899, "1307873293.85412", 16
    get_how $P7900, $P7899
    nqp_get_sc_object $P7901, "1307873293.85412", 16
    .const 'Sub' $P7902 = "154_1307873304.82979" 
    $P7900."add_method"($P7901, "term:sym<lambda>", $P7902)
    nqp_get_sc_object $P7903, "1307873293.85412", 16
    get_how $P7904, $P7903
    nqp_get_sc_object $P7905, "1307873293.85412", 16
    .const 'Sub' $P7906 = "155_1307873304.82979" 
    $P7904."add_method"($P7905, "!PREFIX__term:sym<lambda>", $P7906)
    nqp_get_sc_object $P7907, "1307873293.85412", 16
    get_how $P7908, $P7907
    nqp_get_sc_object $P7909, "1307873293.85412", 16
    .const 'Sub' $P7910 = "156_1307873304.82979" 
    $P7908."add_method"($P7909, "fatarrow", $P7910)
    nqp_get_sc_object $P7911, "1307873293.85412", 16
    get_how $P7912, $P7911
    nqp_get_sc_object $P7913, "1307873293.85412", 16
    .const 'Sub' $P7914 = "157_1307873304.82979" 
    $P7912."add_method"($P7913, "!PREFIX__fatarrow", $P7914)
    nqp_get_sc_object $P7915, "1307873293.85412", 16
    get_how $P7916, $P7915
    nqp_get_sc_object $P7917, "1307873293.85412", 16
    .const 'Sub' $P7918 = "158_1307873304.82979" 
    $P7916."add_method"($P7917, "colonpair", $P7918)
    nqp_get_sc_object $P7919, "1307873293.85412", 16
    get_how $P7920, $P7919
    nqp_get_sc_object $P7921, "1307873293.85412", 16
    .const 'Sub' $P7922 = "159_1307873304.82979" 
    $P7920."add_method"($P7921, "!PREFIX__colonpair", $P7922)
    nqp_get_sc_object $P7923, "1307873293.85412", 16
    get_how $P7924, $P7923
    nqp_get_sc_object $P7925, "1307873293.85412", 16
    .const 'Sub' $P7926 = "160_1307873304.82979" 
    $P7924."add_method"($P7925, "variable", $P7926)
    nqp_get_sc_object $P7927, "1307873293.85412", 16
    get_how $P7928, $P7927
    nqp_get_sc_object $P7929, "1307873293.85412", 16
    .const 'Sub' $P7930 = "161_1307873304.82979" 
    $P7928."add_method"($P7929, "!PREFIX__variable", $P7930)
    nqp_get_sc_object $P7931, "1307873293.85412", 16
    get_how $P7932, $P7931
    nqp_get_sc_object $P7933, "1307873293.85412", 16
    .const 'Sub' $P7934 = "162_1307873304.82979" 
    $P7932."add_method"($P7933, "sigil", $P7934)
    nqp_get_sc_object $P7935, "1307873293.85412", 16
    get_how $P7936, $P7935
    nqp_get_sc_object $P7937, "1307873293.85412", 16
    .const 'Sub' $P7938 = "163_1307873304.82979" 
    $P7936."add_method"($P7937, "!PREFIX__sigil", $P7938)
    nqp_get_sc_object $P7939, "1307873293.85412", 16
    get_how $P7940, $P7939
    nqp_get_sc_object $P7941, "1307873293.85412", 16
    .const 'Sub' $P7942 = "164_1307873304.82979" 
    $P7940."add_method"($P7941, "twigil", $P7942)
    nqp_get_sc_object $P7943, "1307873293.85412", 16
    get_how $P7944, $P7943
    nqp_get_sc_object $P7945, "1307873293.85412", 16
    .const 'Sub' $P7946 = "165_1307873304.82979" 
    $P7944."add_method"($P7945, "!PREFIX__twigil", $P7946)
    nqp_get_sc_object $P7947, "1307873293.85412", 16
    get_how $P7948, $P7947
    nqp_get_sc_object $P7949, "1307873293.85412", 16
    .const 'Sub' $P7950 = "166_1307873304.82979" 
    $P7948."add_method"($P7949, "package_declarator", $P7950)
    nqp_get_sc_object $P7951, "1307873293.85412", 16
    get_how $P7952, $P7951
    nqp_get_sc_object $P7953, "1307873293.85412", 16
    .const 'Sub' $P7954 = "167_1307873304.82979" 
    $P7952."add_method"($P7953, "!PREFIX__package_declarator", $P7954)
    nqp_get_sc_object $P7955, "1307873293.85412", 16
    get_how $P7956, $P7955
    nqp_get_sc_object $P7957, "1307873293.85412", 16
    .const 'Sub' $P7958 = "168_1307873304.82979" 
    $P7956."add_method"($P7957, "package_declarator:sym<module>", $P7958)
    nqp_get_sc_object $P7959, "1307873293.85412", 16
    get_how $P7960, $P7959
    nqp_get_sc_object $P7961, "1307873293.85412", 16
    .const 'Sub' $P7962 = "169_1307873304.82979" 
    $P7960."add_method"($P7961, "!PREFIX__package_declarator:sym<module>", $P7962)
    nqp_get_sc_object $P7963, "1307873293.85412", 16
    get_how $P7964, $P7963
    nqp_get_sc_object $P7965, "1307873293.85412", 16
    .const 'Sub' $P7966 = "170_1307873304.82979" 
    $P7964."add_method"($P7965, "package_declarator:sym<knowhow>", $P7966)
    nqp_get_sc_object $P7967, "1307873293.85412", 16
    get_how $P7968, $P7967
    nqp_get_sc_object $P7969, "1307873293.85412", 16
    .const 'Sub' $P7970 = "171_1307873304.82979" 
    $P7968."add_method"($P7969, "!PREFIX__package_declarator:sym<knowhow>", $P7970)
    nqp_get_sc_object $P7971, "1307873293.85412", 16
    get_how $P7972, $P7971
    nqp_get_sc_object $P7973, "1307873293.85412", 16
    .const 'Sub' $P7974 = "172_1307873304.82979" 
    $P7972."add_method"($P7973, "package_declarator:sym<class>", $P7974)
    nqp_get_sc_object $P7975, "1307873293.85412", 16
    get_how $P7976, $P7975
    nqp_get_sc_object $P7977, "1307873293.85412", 16
    .const 'Sub' $P7978 = "173_1307873304.82979" 
    $P7976."add_method"($P7977, "!PREFIX__package_declarator:sym<class>", $P7978)
    nqp_get_sc_object $P7979, "1307873293.85412", 16
    get_how $P7980, $P7979
    nqp_get_sc_object $P7981, "1307873293.85412", 16
    .const 'Sub' $P7982 = "174_1307873304.82979" 
    $P7980."add_method"($P7981, "package_declarator:sym<grammar>", $P7982)
    nqp_get_sc_object $P7983, "1307873293.85412", 16
    get_how $P7984, $P7983
    nqp_get_sc_object $P7985, "1307873293.85412", 16
    .const 'Sub' $P7986 = "175_1307873304.82979" 
    $P7984."add_method"($P7985, "!PREFIX__package_declarator:sym<grammar>", $P7986)
    nqp_get_sc_object $P7987, "1307873293.85412", 16
    get_how $P7988, $P7987
    nqp_get_sc_object $P7989, "1307873293.85412", 16
    .const 'Sub' $P7990 = "176_1307873304.82979" 
    $P7988."add_method"($P7989, "package_declarator:sym<role>", $P7990)
    nqp_get_sc_object $P7991, "1307873293.85412", 16
    get_how $P7992, $P7991
    nqp_get_sc_object $P7993, "1307873293.85412", 16
    .const 'Sub' $P7994 = "177_1307873304.82979" 
    $P7992."add_method"($P7993, "!PREFIX__package_declarator:sym<role>", $P7994)
    nqp_get_sc_object $P7995, "1307873293.85412", 16
    get_how $P7996, $P7995
    nqp_get_sc_object $P7997, "1307873293.85412", 16
    .const 'Sub' $P7998 = "178_1307873304.82979" 
    $P7996."add_method"($P7997, "package_declarator:sym<native>", $P7998)
    nqp_get_sc_object $P7999, "1307873293.85412", 16
    get_how $P8000, $P7999
    nqp_get_sc_object $P8001, "1307873293.85412", 16
    .const 'Sub' $P8002 = "179_1307873304.82979" 
    $P8000."add_method"($P8001, "!PREFIX__package_declarator:sym<native>", $P8002)
    nqp_get_sc_object $P8003, "1307873293.85412", 16
    get_how $P8004, $P8003
    nqp_get_sc_object $P8005, "1307873293.85412", 16
    .const 'Sub' $P8006 = "180_1307873304.82979" 
    $P8004."add_method"($P8005, "package_declarator:sym<stub>", $P8006)
    nqp_get_sc_object $P8007, "1307873293.85412", 16
    get_how $P8008, $P8007
    nqp_get_sc_object $P8009, "1307873293.85412", 16
    .const 'Sub' $P8010 = "181_1307873304.82979" 
    $P8008."add_method"($P8009, "!PREFIX__package_declarator:sym<stub>", $P8010)
    nqp_get_sc_object $P8011, "1307873293.85412", 16
    get_how $P8012, $P8011
    nqp_get_sc_object $P8013, "1307873293.85412", 16
    .const 'Sub' $P8014 = "182_1307873304.82979" 
    $P8012."add_method"($P8013, "package_def", $P8014)
    nqp_get_sc_object $P8015, "1307873293.85412", 16
    get_how $P8016, $P8015
    nqp_get_sc_object $P8017, "1307873293.85412", 16
    .const 'Sub' $P8018 = "184_1307873304.82979" 
    $P8016."add_method"($P8017, "!PREFIX__package_def", $P8018)
    nqp_get_sc_object $P8019, "1307873293.85412", 16
    get_how $P8020, $P8019
    nqp_get_sc_object $P8021, "1307873293.85412", 16
    .const 'Sub' $P8022 = "185_1307873304.82979" 
    $P8020."add_method"($P8021, "scope_declarator", $P8022)
    nqp_get_sc_object $P8023, "1307873293.85412", 16
    get_how $P8024, $P8023
    nqp_get_sc_object $P8025, "1307873293.85412", 16
    .const 'Sub' $P8026 = "186_1307873304.82979" 
    $P8024."add_method"($P8025, "!PREFIX__scope_declarator", $P8026)
    nqp_get_sc_object $P8027, "1307873293.85412", 16
    get_how $P8028, $P8027
    nqp_get_sc_object $P8029, "1307873293.85412", 16
    .const 'Sub' $P8030 = "187_1307873304.82979" 
    $P8028."add_method"($P8029, "scope_declarator:sym<my>", $P8030)
    nqp_get_sc_object $P8031, "1307873293.85412", 16
    get_how $P8032, $P8031
    nqp_get_sc_object $P8033, "1307873293.85412", 16
    .const 'Sub' $P8034 = "188_1307873304.82979" 
    $P8032."add_method"($P8033, "!PREFIX__scope_declarator:sym<my>", $P8034)
    nqp_get_sc_object $P8035, "1307873293.85412", 16
    get_how $P8036, $P8035
    nqp_get_sc_object $P8037, "1307873293.85412", 16
    .const 'Sub' $P8038 = "189_1307873304.82979" 
    $P8036."add_method"($P8037, "scope_declarator:sym<our>", $P8038)
    nqp_get_sc_object $P8039, "1307873293.85412", 16
    get_how $P8040, $P8039
    nqp_get_sc_object $P8041, "1307873293.85412", 16
    .const 'Sub' $P8042 = "190_1307873304.82979" 
    $P8040."add_method"($P8041, "!PREFIX__scope_declarator:sym<our>", $P8042)
    nqp_get_sc_object $P8043, "1307873293.85412", 16
    get_how $P8044, $P8043
    nqp_get_sc_object $P8045, "1307873293.85412", 16
    .const 'Sub' $P8046 = "191_1307873304.82979" 
    $P8044."add_method"($P8045, "scope_declarator:sym<has>", $P8046)
    nqp_get_sc_object $P8047, "1307873293.85412", 16
    get_how $P8048, $P8047
    nqp_get_sc_object $P8049, "1307873293.85412", 16
    .const 'Sub' $P8050 = "192_1307873304.82979" 
    $P8048."add_method"($P8049, "!PREFIX__scope_declarator:sym<has>", $P8050)
    nqp_get_sc_object $P8051, "1307873293.85412", 16
    get_how $P8052, $P8051
    nqp_get_sc_object $P8053, "1307873293.85412", 16
    .const 'Sub' $P8054 = "193_1307873304.82979" 
    $P8052."add_method"($P8053, "scoped", $P8054)
    nqp_get_sc_object $P8055, "1307873293.85412", 16
    get_how $P8056, $P8055
    nqp_get_sc_object $P8057, "1307873293.85412", 16
    .const 'Sub' $P8058 = "194_1307873304.82979" 
    $P8056."add_method"($P8057, "!PREFIX__scoped", $P8058)
    nqp_get_sc_object $P8059, "1307873293.85412", 16
    get_how $P8060, $P8059
    nqp_get_sc_object $P8061, "1307873293.85412", 16
    .const 'Sub' $P8062 = "195_1307873304.82979" 
    $P8060."add_method"($P8061, "typename", $P8062)
    nqp_get_sc_object $P8063, "1307873293.85412", 16
    get_how $P8064, $P8063
    nqp_get_sc_object $P8065, "1307873293.85412", 16
    .const 'Sub' $P8066 = "197_1307873304.82979" 
    $P8064."add_method"($P8065, "!PREFIX__typename", $P8066)
    nqp_get_sc_object $P8067, "1307873293.85412", 16
    get_how $P8068, $P8067
    nqp_get_sc_object $P8069, "1307873293.85412", 16
    .const 'Sub' $P8070 = "198_1307873304.82979" 
    $P8068."add_method"($P8069, "declarator", $P8070)
    nqp_get_sc_object $P8071, "1307873293.85412", 16
    get_how $P8072, $P8071
    nqp_get_sc_object $P8073, "1307873293.85412", 16
    .const 'Sub' $P8074 = "199_1307873304.82979" 
    $P8072."add_method"($P8073, "!PREFIX__declarator", $P8074)
    nqp_get_sc_object $P8075, "1307873293.85412", 16
    get_how $P8076, $P8075
    nqp_get_sc_object $P8077, "1307873293.85412", 16
    .const 'Sub' $P8078 = "200_1307873304.82979" 
    $P8076."add_method"($P8077, "variable_declarator", $P8078)
    nqp_get_sc_object $P8079, "1307873293.85412", 16
    get_how $P8080, $P8079
    nqp_get_sc_object $P8081, "1307873293.85412", 16
    .const 'Sub' $P8082 = "202_1307873304.82979" 
    $P8080."add_method"($P8081, "!PREFIX__variable_declarator", $P8082)
    nqp_get_sc_object $P8083, "1307873293.85412", 16
    get_how $P8084, $P8083
    nqp_get_sc_object $P8085, "1307873293.85412", 16
    .const 'Sub' $P8086 = "203_1307873304.82979" 
    $P8084."add_method"($P8085, "routine_declarator", $P8086)
    nqp_get_sc_object $P8087, "1307873293.85412", 16
    get_how $P8088, $P8087
    nqp_get_sc_object $P8089, "1307873293.85412", 16
    .const 'Sub' $P8090 = "204_1307873304.82979" 
    $P8088."add_method"($P8089, "!PREFIX__routine_declarator", $P8090)
    nqp_get_sc_object $P8091, "1307873293.85412", 16
    get_how $P8092, $P8091
    nqp_get_sc_object $P8093, "1307873293.85412", 16
    .const 'Sub' $P8094 = "205_1307873304.82979" 
    $P8092."add_method"($P8093, "routine_declarator:sym<sub>", $P8094)
    nqp_get_sc_object $P8095, "1307873293.85412", 16
    get_how $P8096, $P8095
    nqp_get_sc_object $P8097, "1307873293.85412", 16
    .const 'Sub' $P8098 = "206_1307873304.82979" 
    $P8096."add_method"($P8097, "!PREFIX__routine_declarator:sym<sub>", $P8098)
    nqp_get_sc_object $P8099, "1307873293.85412", 16
    get_how $P8100, $P8099
    nqp_get_sc_object $P8101, "1307873293.85412", 16
    .const 'Sub' $P8102 = "207_1307873304.82979" 
    $P8100."add_method"($P8101, "routine_declarator:sym<method>", $P8102)
    nqp_get_sc_object $P8103, "1307873293.85412", 16
    get_how $P8104, $P8103
    nqp_get_sc_object $P8105, "1307873293.85412", 16
    .const 'Sub' $P8106 = "208_1307873304.82979" 
    $P8104."add_method"($P8105, "!PREFIX__routine_declarator:sym<method>", $P8106)
    nqp_get_sc_object $P8107, "1307873293.85412", 16
    get_how $P8108, $P8107
    nqp_get_sc_object $P8109, "1307873293.85412", 16
    .const 'Sub' $P8110 = "209_1307873304.82979" 
    $P8108."add_method"($P8109, "routine_def", $P8110)
    nqp_get_sc_object $P8111, "1307873293.85412", 16
    get_how $P8112, $P8111
    nqp_get_sc_object $P8113, "1307873293.85412", 16
    .const 'Sub' $P8114 = "210_1307873304.82979" 
    $P8112."add_method"($P8113, "!PREFIX__routine_def", $P8114)
    nqp_get_sc_object $P8115, "1307873293.85412", 16
    get_how $P8116, $P8115
    nqp_get_sc_object $P8117, "1307873293.85412", 16
    .const 'Sub' $P8118 = "211_1307873304.82979" 
    $P8116."add_method"($P8117, "method_def", $P8118)
    nqp_get_sc_object $P8119, "1307873293.85412", 16
    get_how $P8120, $P8119
    nqp_get_sc_object $P8121, "1307873293.85412", 16
    .const 'Sub' $P8122 = "213_1307873304.82979" 
    $P8120."add_method"($P8121, "!PREFIX__method_def", $P8122)
    nqp_get_sc_object $P8123, "1307873293.85412", 16
    get_how $P8124, $P8123
    nqp_get_sc_object $P8125, "1307873293.85412", 16
    .const 'Sub' $P8126 = "214_1307873304.82979" 
    $P8124."add_method"($P8125, "onlystar", $P8126)
    nqp_get_sc_object $P8127, "1307873293.85412", 16
    get_how $P8128, $P8127
    nqp_get_sc_object $P8129, "1307873293.85412", 16
    .const 'Sub' $P8130 = "216_1307873304.82979" 
    $P8128."add_method"($P8129, "!PREFIX__onlystar", $P8130)
    nqp_get_sc_object $P8131, "1307873293.85412", 16
    get_how $P8132, $P8131
    nqp_get_sc_object $P8133, "1307873293.85412", 16
    .const 'Sub' $P8134 = "217_1307873304.82979" 
    $P8132."add_method"($P8133, "multi_declarator", $P8134)
    nqp_get_sc_object $P8135, "1307873293.85412", 16
    get_how $P8136, $P8135
    nqp_get_sc_object $P8137, "1307873293.85412", 16
    .const 'Sub' $P8138 = "218_1307873304.82979" 
    $P8136."add_method"($P8137, "!PREFIX__multi_declarator", $P8138)
    nqp_get_sc_object $P8139, "1307873293.85412", 16
    get_how $P8140, $P8139
    nqp_get_sc_object $P8141, "1307873293.85412", 16
    .const 'Sub' $P8142 = "219_1307873304.82979" 
    $P8140."add_method"($P8141, "multi_declarator:sym<multi>", $P8142)
    nqp_get_sc_object $P8143, "1307873293.85412", 16
    get_how $P8144, $P8143
    nqp_get_sc_object $P8145, "1307873293.85412", 16
    .const 'Sub' $P8146 = "220_1307873304.82979" 
    $P8144."add_method"($P8145, "!PREFIX__multi_declarator:sym<multi>", $P8146)
    nqp_get_sc_object $P8147, "1307873293.85412", 16
    get_how $P8148, $P8147
    nqp_get_sc_object $P8149, "1307873293.85412", 16
    .const 'Sub' $P8150 = "221_1307873304.82979" 
    $P8148."add_method"($P8149, "multi_declarator:sym<proto>", $P8150)
    nqp_get_sc_object $P8151, "1307873293.85412", 16
    get_how $P8152, $P8151
    nqp_get_sc_object $P8153, "1307873293.85412", 16
    .const 'Sub' $P8154 = "222_1307873304.82979" 
    $P8152."add_method"($P8153, "!PREFIX__multi_declarator:sym<proto>", $P8154)
    nqp_get_sc_object $P8155, "1307873293.85412", 16
    get_how $P8156, $P8155
    nqp_get_sc_object $P8157, "1307873293.85412", 16
    .const 'Sub' $P8158 = "223_1307873304.82979" 
    $P8156."add_method"($P8157, "multi_declarator:sym<null>", $P8158)
    nqp_get_sc_object $P8159, "1307873293.85412", 16
    get_how $P8160, $P8159
    nqp_get_sc_object $P8161, "1307873293.85412", 16
    .const 'Sub' $P8162 = "224_1307873304.82979" 
    $P8160."add_method"($P8161, "!PREFIX__multi_declarator:sym<null>", $P8162)
    nqp_get_sc_object $P8163, "1307873293.85412", 16
    get_how $P8164, $P8163
    nqp_get_sc_object $P8165, "1307873293.85412", 16
    .const 'Sub' $P8166 = "225_1307873304.82979" 
    $P8164."add_method"($P8165, "signature", $P8166)
    nqp_get_sc_object $P8167, "1307873293.85412", 16
    get_how $P8168, $P8167
    nqp_get_sc_object $P8169, "1307873293.85412", 16
    .const 'Sub' $P8170 = "227_1307873304.82979" 
    $P8168."add_method"($P8169, "!PREFIX__signature", $P8170)
    nqp_get_sc_object $P8171, "1307873293.85412", 16
    get_how $P8172, $P8171
    nqp_get_sc_object $P8173, "1307873293.85412", 16
    .const 'Sub' $P8174 = "228_1307873304.82979" 
    $P8172."add_method"($P8173, "parameter", $P8174)
    nqp_get_sc_object $P8175, "1307873293.85412", 16
    get_how $P8176, $P8175
    nqp_get_sc_object $P8177, "1307873293.85412", 16
    .const 'Sub' $P8178 = "229_1307873304.82979" 
    $P8176."add_method"($P8177, "!PREFIX__parameter", $P8178)
    nqp_get_sc_object $P8179, "1307873293.85412", 16
    get_how $P8180, $P8179
    nqp_get_sc_object $P8181, "1307873293.85412", 16
    .const 'Sub' $P8182 = "230_1307873304.82979" 
    $P8180."add_method"($P8181, "param_var", $P8182)
    nqp_get_sc_object $P8183, "1307873293.85412", 16
    get_how $P8184, $P8183
    nqp_get_sc_object $P8185, "1307873293.85412", 16
    .const 'Sub' $P8186 = "231_1307873304.82979" 
    $P8184."add_method"($P8185, "!PREFIX__param_var", $P8186)
    nqp_get_sc_object $P8187, "1307873293.85412", 16
    get_how $P8188, $P8187
    nqp_get_sc_object $P8189, "1307873293.85412", 16
    .const 'Sub' $P8190 = "232_1307873304.82979" 
    $P8188."add_method"($P8189, "named_param", $P8190)
    nqp_get_sc_object $P8191, "1307873293.85412", 16
    get_how $P8192, $P8191
    nqp_get_sc_object $P8193, "1307873293.85412", 16
    .const 'Sub' $P8194 = "233_1307873304.82979" 
    $P8192."add_method"($P8193, "!PREFIX__named_param", $P8194)
    nqp_get_sc_object $P8195, "1307873293.85412", 16
    get_how $P8196, $P8195
    nqp_get_sc_object $P8197, "1307873293.85412", 16
    .const 'Sub' $P8198 = "234_1307873304.82979" 
    $P8196."add_method"($P8197, "default_value", $P8198)
    nqp_get_sc_object $P8199, "1307873293.85412", 16
    get_how $P8200, $P8199
    nqp_get_sc_object $P8201, "1307873293.85412", 16
    .const 'Sub' $P8202 = "235_1307873304.82979" 
    $P8200."add_method"($P8201, "!PREFIX__default_value", $P8202)
    nqp_get_sc_object $P8203, "1307873293.85412", 16
    get_how $P8204, $P8203
    nqp_get_sc_object $P8205, "1307873293.85412", 16
    .const 'Sub' $P8206 = "236_1307873304.82979" 
    $P8204."add_method"($P8205, "trait", $P8206)
    nqp_get_sc_object $P8207, "1307873293.85412", 16
    get_how $P8208, $P8207
    nqp_get_sc_object $P8209, "1307873293.85412", 16
    .const 'Sub' $P8210 = "237_1307873304.82979" 
    $P8208."add_method"($P8209, "!PREFIX__trait", $P8210)
    nqp_get_sc_object $P8211, "1307873293.85412", 16
    get_how $P8212, $P8211
    nqp_get_sc_object $P8213, "1307873293.85412", 16
    .const 'Sub' $P8214 = "238_1307873304.82979" 
    $P8212."add_method"($P8213, "trait_mod", $P8214)
    nqp_get_sc_object $P8215, "1307873293.85412", 16
    get_how $P8216, $P8215
    nqp_get_sc_object $P8217, "1307873293.85412", 16
    .const 'Sub' $P8218 = "239_1307873304.82979" 
    $P8216."add_method"($P8217, "!PREFIX__trait_mod", $P8218)
    nqp_get_sc_object $P8219, "1307873293.85412", 16
    get_how $P8220, $P8219
    nqp_get_sc_object $P8221, "1307873293.85412", 16
    .const 'Sub' $P8222 = "240_1307873304.82979" 
    $P8220."add_method"($P8221, "trait_mod:sym<is>", $P8222)
    nqp_get_sc_object $P8223, "1307873293.85412", 16
    get_how $P8224, $P8223
    nqp_get_sc_object $P8225, "1307873293.85412", 16
    .const 'Sub' $P8226 = "241_1307873304.82979" 
    $P8224."add_method"($P8225, "!PREFIX__trait_mod:sym<is>", $P8226)
    nqp_get_sc_object $P8227, "1307873293.85412", 16
    get_how $P8228, $P8227
    nqp_get_sc_object $P8229, "1307873293.85412", 16
    .const 'Sub' $P8230 = "242_1307873304.82979" 
    $P8228."add_method"($P8229, "regex_declarator", $P8230)
    nqp_get_sc_object $P8231, "1307873293.85412", 16
    get_how $P8232, $P8231
    nqp_get_sc_object $P8233, "1307873293.85412", 16
    .const 'Sub' $P8234 = "243_1307873304.82979" 
    $P8232."add_method"($P8233, "!PREFIX__regex_declarator", $P8234)
    nqp_get_sc_object $P8235, "1307873293.85412", 16
    get_how $P8236, $P8235
    nqp_get_sc_object $P8237, "1307873293.85412", 16
    .const 'Sub' $P8238 = "244_1307873304.82979" 
    $P8236."add_method"($P8237, "dotty", $P8238)
    nqp_get_sc_object $P8239, "1307873293.85412", 16
    get_how $P8240, $P8239
    nqp_get_sc_object $P8241, "1307873293.85412", 16
    .const 'Sub' $P8242 = "245_1307873304.82979" 
    $P8240."add_method"($P8241, "!PREFIX__dotty", $P8242)
    nqp_get_sc_object $P8243, "1307873293.85412", 16
    get_how $P8244, $P8243
    nqp_get_sc_object $P8245, "1307873293.85412", 16
    .const 'Sub' $P8246 = "246_1307873304.82979" 
    $P8244."add_method"($P8245, "term", $P8246)
    nqp_get_sc_object $P8247, "1307873293.85412", 16
    get_how $P8248, $P8247
    nqp_get_sc_object $P8249, "1307873293.85412", 16
    .const 'Sub' $P8250 = "247_1307873304.82979" 
    $P8248."add_method"($P8249, "!PREFIX__term", $P8250)
    nqp_get_sc_object $P8251, "1307873293.85412", 16
    get_how $P8252, $P8251
    nqp_get_sc_object $P8253, "1307873293.85412", 16
    .const 'Sub' $P8254 = "248_1307873304.82979" 
    $P8252."add_method"($P8253, "term:sym<self>", $P8254)
    nqp_get_sc_object $P8255, "1307873293.85412", 16
    get_how $P8256, $P8255
    nqp_get_sc_object $P8257, "1307873293.85412", 16
    .const 'Sub' $P8258 = "249_1307873304.82979" 
    $P8256."add_method"($P8257, "!PREFIX__term:sym<self>", $P8258)
    nqp_get_sc_object $P8259, "1307873293.85412", 16
    get_how $P8260, $P8259
    nqp_get_sc_object $P8261, "1307873293.85412", 16
    .const 'Sub' $P8262 = "250_1307873304.82979" 
    $P8260."add_method"($P8261, "term:sym<identifier>", $P8262)
    nqp_get_sc_object $P8263, "1307873293.85412", 16
    get_how $P8264, $P8263
    nqp_get_sc_object $P8265, "1307873293.85412", 16
    .const 'Sub' $P8266 = "251_1307873304.82979" 
    $P8264."add_method"($P8265, "!PREFIX__term:sym<identifier>", $P8266)
    nqp_get_sc_object $P8267, "1307873293.85412", 16
    get_how $P8268, $P8267
    nqp_get_sc_object $P8269, "1307873293.85412", 16
    .const 'Sub' $P8270 = "252_1307873304.82979" 
    $P8268."add_method"($P8269, "term:sym<name>", $P8270)
    nqp_get_sc_object $P8271, "1307873293.85412", 16
    get_how $P8272, $P8271
    nqp_get_sc_object $P8273, "1307873293.85412", 16
    .const 'Sub' $P8274 = "253_1307873304.82979" 
    $P8272."add_method"($P8273, "!PREFIX__term:sym<name>", $P8274)
    nqp_get_sc_object $P8275, "1307873293.85412", 16
    get_how $P8276, $P8275
    nqp_get_sc_object $P8277, "1307873293.85412", 16
    .const 'Sub' $P8278 = "254_1307873304.82979" 
    $P8276."add_method"($P8277, "term:sym<pir::op>", $P8278)
    nqp_get_sc_object $P8279, "1307873293.85412", 16
    get_how $P8280, $P8279
    nqp_get_sc_object $P8281, "1307873293.85412", 16
    .const 'Sub' $P8282 = "255_1307873304.82979" 
    $P8280."add_method"($P8281, "!PREFIX__term:sym<pir::op>", $P8282)
    nqp_get_sc_object $P8283, "1307873293.85412", 16
    get_how $P8284, $P8283
    nqp_get_sc_object $P8285, "1307873293.85412", 16
    .const 'Sub' $P8286 = "256_1307873304.82979" 
    $P8284."add_method"($P8285, "term:sym<pir::const>", $P8286)
    nqp_get_sc_object $P8287, "1307873293.85412", 16
    get_how $P8288, $P8287
    nqp_get_sc_object $P8289, "1307873293.85412", 16
    .const 'Sub' $P8290 = "257_1307873304.82979" 
    $P8288."add_method"($P8289, "!PREFIX__term:sym<pir::const>", $P8290)
    nqp_get_sc_object $P8291, "1307873293.85412", 16
    get_how $P8292, $P8291
    nqp_get_sc_object $P8293, "1307873293.85412", 16
    .const 'Sub' $P8294 = "258_1307873304.82979" 
    $P8292."add_method"($P8293, "term:sym<onlystar>", $P8294)
    nqp_get_sc_object $P8295, "1307873293.85412", 16
    get_how $P8296, $P8295
    nqp_get_sc_object $P8297, "1307873293.85412", 16
    .const 'Sub' $P8298 = "260_1307873304.82979" 
    $P8296."add_method"($P8297, "!PREFIX__term:sym<onlystar>", $P8298)
    nqp_get_sc_object $P8299, "1307873293.85412", 16
    get_how $P8300, $P8299
    nqp_get_sc_object $P8301, "1307873293.85412", 16
    .const 'Sub' $P8302 = "261_1307873304.82979" 
    $P8300."add_method"($P8301, "args", $P8302)
    nqp_get_sc_object $P8303, "1307873293.85412", 16
    get_how $P8304, $P8303
    nqp_get_sc_object $P8305, "1307873293.85412", 16
    .const 'Sub' $P8306 = "262_1307873304.82979" 
    $P8304."add_method"($P8305, "!PREFIX__args", $P8306)
    nqp_get_sc_object $P8307, "1307873293.85412", 16
    get_how $P8308, $P8307
    nqp_get_sc_object $P8309, "1307873293.85412", 16
    .const 'Sub' $P8310 = "263_1307873304.82979" 
    $P8308."add_method"($P8309, "arglist", $P8310)
    nqp_get_sc_object $P8311, "1307873293.85412", 16
    get_how $P8312, $P8311
    nqp_get_sc_object $P8313, "1307873293.85412", 16
    .const 'Sub' $P8314 = "264_1307873304.82979" 
    $P8312."add_method"($P8313, "!PREFIX__arglist", $P8314)
    nqp_get_sc_object $P8315, "1307873293.85412", 16
    get_how $P8316, $P8315
    nqp_get_sc_object $P8317, "1307873293.85412", 16
    .const 'Sub' $P8318 = "265_1307873304.82979" 
    $P8316."add_method"($P8317, "term:sym<value>", $P8318)
    nqp_get_sc_object $P8319, "1307873293.85412", 16
    get_how $P8320, $P8319
    nqp_get_sc_object $P8321, "1307873293.85412", 16
    .const 'Sub' $P8322 = "266_1307873304.82979" 
    $P8320."add_method"($P8321, "!PREFIX__term:sym<value>", $P8322)
    nqp_get_sc_object $P8323, "1307873293.85412", 16
    get_how $P8324, $P8323
    nqp_get_sc_object $P8325, "1307873293.85412", 16
    .const 'Sub' $P8326 = "267_1307873304.82979" 
    $P8324."add_method"($P8325, "value", $P8326)
    nqp_get_sc_object $P8327, "1307873293.85412", 16
    get_how $P8328, $P8327
    nqp_get_sc_object $P8329, "1307873293.85412", 16
    .const 'Sub' $P8330 = "268_1307873304.82979" 
    $P8328."add_method"($P8329, "!PREFIX__value", $P8330)
    nqp_get_sc_object $P8331, "1307873293.85412", 16
    get_how $P8332, $P8331
    nqp_get_sc_object $P8333, "1307873293.85412", 16
    .const 'Sub' $P8334 = "269_1307873304.82979" 
    $P8332."add_method"($P8333, "number", $P8334)
    nqp_get_sc_object $P8335, "1307873293.85412", 16
    get_how $P8336, $P8335
    nqp_get_sc_object $P8337, "1307873293.85412", 16
    .const 'Sub' $P8338 = "270_1307873304.82979" 
    $P8336."add_method"($P8337, "!PREFIX__number", $P8338)
    nqp_get_sc_object $P8339, "1307873293.85412", 16
    get_how $P8340, $P8339
    nqp_get_sc_object $P8341, "1307873293.85412", 16
    .const 'Sub' $P8342 = "271_1307873304.82979" 
    $P8340."add_method"($P8341, "quote", $P8342)
    nqp_get_sc_object $P8343, "1307873293.85412", 16
    get_how $P8344, $P8343
    nqp_get_sc_object $P8345, "1307873293.85412", 16
    .const 'Sub' $P8346 = "272_1307873304.82979" 
    $P8344."add_method"($P8345, "!PREFIX__quote", $P8346)
    nqp_get_sc_object $P8347, "1307873293.85412", 16
    get_how $P8348, $P8347
    nqp_get_sc_object $P8349, "1307873293.85412", 16
    .const 'Sub' $P8350 = "273_1307873304.82979" 
    $P8348."add_method"($P8349, "quote:sym<apos>", $P8350)
    nqp_get_sc_object $P8351, "1307873293.85412", 16
    get_how $P8352, $P8351
    nqp_get_sc_object $P8353, "1307873293.85412", 16
    .const 'Sub' $P8354 = "274_1307873304.82979" 
    $P8352."add_method"($P8353, "!PREFIX__quote:sym<apos>", $P8354)
    nqp_get_sc_object $P8355, "1307873293.85412", 16
    get_how $P8356, $P8355
    nqp_get_sc_object $P8357, "1307873293.85412", 16
    .const 'Sub' $P8358 = "275_1307873304.82979" 
    $P8356."add_method"($P8357, "quote:sym<dblq>", $P8358)
    nqp_get_sc_object $P8359, "1307873293.85412", 16
    get_how $P8360, $P8359
    nqp_get_sc_object $P8361, "1307873293.85412", 16
    .const 'Sub' $P8362 = "276_1307873304.82979" 
    $P8360."add_method"($P8361, "!PREFIX__quote:sym<dblq>", $P8362)
    nqp_get_sc_object $P8363, "1307873293.85412", 16
    get_how $P8364, $P8363
    nqp_get_sc_object $P8365, "1307873293.85412", 16
    .const 'Sub' $P8366 = "277_1307873304.82979" 
    $P8364."add_method"($P8365, "quote:sym<q>", $P8366)
    nqp_get_sc_object $P8367, "1307873293.85412", 16
    get_how $P8368, $P8367
    nqp_get_sc_object $P8369, "1307873293.85412", 16
    .const 'Sub' $P8370 = "278_1307873304.82979" 
    $P8368."add_method"($P8369, "!PREFIX__quote:sym<q>", $P8370)
    nqp_get_sc_object $P8371, "1307873293.85412", 16
    get_how $P8372, $P8371
    nqp_get_sc_object $P8373, "1307873293.85412", 16
    .const 'Sub' $P8374 = "279_1307873304.82979" 
    $P8372."add_method"($P8373, "quote:sym<qq>", $P8374)
    nqp_get_sc_object $P8375, "1307873293.85412", 16
    get_how $P8376, $P8375
    nqp_get_sc_object $P8377, "1307873293.85412", 16
    .const 'Sub' $P8378 = "280_1307873304.82979" 
    $P8376."add_method"($P8377, "!PREFIX__quote:sym<qq>", $P8378)
    nqp_get_sc_object $P8379, "1307873293.85412", 16
    get_how $P8380, $P8379
    nqp_get_sc_object $P8381, "1307873293.85412", 16
    .const 'Sub' $P8382 = "281_1307873304.82979" 
    $P8380."add_method"($P8381, "quote:sym<Q>", $P8382)
    nqp_get_sc_object $P8383, "1307873293.85412", 16
    get_how $P8384, $P8383
    nqp_get_sc_object $P8385, "1307873293.85412", 16
    .const 'Sub' $P8386 = "282_1307873304.82979" 
    $P8384."add_method"($P8385, "!PREFIX__quote:sym<Q>", $P8386)
    nqp_get_sc_object $P8387, "1307873293.85412", 16
    get_how $P8388, $P8387
    nqp_get_sc_object $P8389, "1307873293.85412", 16
    .const 'Sub' $P8390 = "283_1307873304.82979" 
    $P8388."add_method"($P8389, "quote:sym<Q:PIR>", $P8390)
    nqp_get_sc_object $P8391, "1307873293.85412", 16
    get_how $P8392, $P8391
    nqp_get_sc_object $P8393, "1307873293.85412", 16
    .const 'Sub' $P8394 = "284_1307873304.82979" 
    $P8392."add_method"($P8393, "!PREFIX__quote:sym<Q:PIR>", $P8394)
    nqp_get_sc_object $P8395, "1307873293.85412", 16
    get_how $P8396, $P8395
    nqp_get_sc_object $P8397, "1307873293.85412", 16
    .const 'Sub' $P8398 = "285_1307873304.82979" 
    $P8396."add_method"($P8397, "quote:sym</ />", $P8398)
    nqp_get_sc_object $P8399, "1307873293.85412", 16
    get_how $P8400, $P8399
    nqp_get_sc_object $P8401, "1307873293.85412", 16
    .const 'Sub' $P8402 = "286_1307873304.82979" 
    $P8400."add_method"($P8401, "!PREFIX__quote:sym</ />", $P8402)
    nqp_get_sc_object $P8403, "1307873293.85412", 16
    get_how $P8404, $P8403
    nqp_get_sc_object $P8405, "1307873293.85412", 16
    .const 'Sub' $P8406 = "287_1307873304.82979" 
    $P8404."add_method"($P8405, "quote_escape:sym<$>", $P8406)
    nqp_get_sc_object $P8407, "1307873293.85412", 16
    get_how $P8408, $P8407
    nqp_get_sc_object $P8409, "1307873293.85412", 16
    .const 'Sub' $P8410 = "288_1307873304.82979" 
    $P8408."add_method"($P8409, "!PREFIX__quote_escape:sym<$>", $P8410)
    nqp_get_sc_object $P8411, "1307873293.85412", 16
    get_how $P8412, $P8411
    nqp_get_sc_object $P8413, "1307873293.85412", 16
    .const 'Sub' $P8414 = "289_1307873304.82979" 
    $P8412."add_method"($P8413, "quote_escape:sym<{ }>", $P8414)
    nqp_get_sc_object $P8415, "1307873293.85412", 16
    get_how $P8416, $P8415
    nqp_get_sc_object $P8417, "1307873293.85412", 16
    .const 'Sub' $P8418 = "290_1307873304.82979" 
    $P8416."add_method"($P8417, "!PREFIX__quote_escape:sym<{ }>", $P8418)
    nqp_get_sc_object $P8419, "1307873293.85412", 16
    get_how $P8420, $P8419
    nqp_get_sc_object $P8421, "1307873293.85412", 16
    .const 'Sub' $P8422 = "291_1307873304.82979" 
    $P8420."add_method"($P8421, "quote_escape:sym<esc>", $P8422)
    nqp_get_sc_object $P8423, "1307873293.85412", 16
    get_how $P8424, $P8423
    nqp_get_sc_object $P8425, "1307873293.85412", 16
    .const 'Sub' $P8426 = "292_1307873304.82979" 
    $P8424."add_method"($P8425, "!PREFIX__quote_escape:sym<esc>", $P8426)
    nqp_get_sc_object $P8427, "1307873293.85412", 16
    get_how $P8428, $P8427
    nqp_get_sc_object $P8429, "1307873293.85412", 16
    .const 'Sub' $P8430 = "293_1307873304.82979" 
    $P8428."add_method"($P8429, "circumfix:sym<( )>", $P8430)
    nqp_get_sc_object $P8431, "1307873293.85412", 16
    get_how $P8432, $P8431
    nqp_get_sc_object $P8433, "1307873293.85412", 16
    .const 'Sub' $P8434 = "294_1307873304.82979" 
    $P8432."add_method"($P8433, "!PREFIX__circumfix:sym<( )>", $P8434)
    nqp_get_sc_object $P8435, "1307873293.85412", 16
    get_how $P8436, $P8435
    nqp_get_sc_object $P8437, "1307873293.85412", 16
    .const 'Sub' $P8438 = "295_1307873304.82979" 
    $P8436."add_method"($P8437, "circumfix:sym<[ ]>", $P8438)
    nqp_get_sc_object $P8439, "1307873293.85412", 16
    get_how $P8440, $P8439
    nqp_get_sc_object $P8441, "1307873293.85412", 16
    .const 'Sub' $P8442 = "296_1307873304.82979" 
    $P8440."add_method"($P8441, "!PREFIX__circumfix:sym<[ ]>", $P8442)
    nqp_get_sc_object $P8443, "1307873293.85412", 16
    get_how $P8444, $P8443
    nqp_get_sc_object $P8445, "1307873293.85412", 16
    .const 'Sub' $P8446 = "297_1307873304.82979" 
    $P8444."add_method"($P8445, "circumfix:sym<ang>", $P8446)
    nqp_get_sc_object $P8447, "1307873293.85412", 16
    get_how $P8448, $P8447
    nqp_get_sc_object $P8449, "1307873293.85412", 16
    .const 'Sub' $P8450 = "298_1307873304.82979" 
    $P8448."add_method"($P8449, "!PREFIX__circumfix:sym<ang>", $P8450)
    nqp_get_sc_object $P8451, "1307873293.85412", 16
    get_how $P8452, $P8451
    nqp_get_sc_object $P8453, "1307873293.85412", 16
    .const 'Sub' $P8454 = "299_1307873304.82979" 
    $P8452."add_method"($P8453, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P8454)
    nqp_get_sc_object $P8455, "1307873293.85412", 16
    get_how $P8456, $P8455
    nqp_get_sc_object $P8457, "1307873293.85412", 16
    .const 'Sub' $P8458 = "300_1307873304.82979" 
    $P8456."add_method"($P8457, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>", $P8458)
    nqp_get_sc_object $P8459, "1307873293.85412", 16
    get_how $P8460, $P8459
    nqp_get_sc_object $P8461, "1307873293.85412", 16
    .const 'Sub' $P8462 = "301_1307873304.82979" 
    $P8460."add_method"($P8461, "circumfix:sym<{ }>", $P8462)
    nqp_get_sc_object $P8463, "1307873293.85412", 16
    get_how $P8464, $P8463
    nqp_get_sc_object $P8465, "1307873293.85412", 16
    .const 'Sub' $P8466 = "302_1307873304.82979" 
    $P8464."add_method"($P8465, "!PREFIX__circumfix:sym<{ }>", $P8466)
    nqp_get_sc_object $P8467, "1307873293.85412", 16
    get_how $P8468, $P8467
    nqp_get_sc_object $P8469, "1307873293.85412", 16
    .const 'Sub' $P8470 = "303_1307873304.82979" 
    $P8468."add_method"($P8469, "circumfix:sym<sigil>", $P8470)
    nqp_get_sc_object $P8471, "1307873293.85412", 16
    get_how $P8472, $P8471
    nqp_get_sc_object $P8473, "1307873293.85412", 16
    .const 'Sub' $P8474 = "304_1307873304.82979" 
    $P8472."add_method"($P8473, "!PREFIX__circumfix:sym<sigil>", $P8474)
    nqp_get_sc_object $P8475, "1307873293.85412", 16
    get_how $P8476, $P8475
    nqp_get_sc_object $P8477, "1307873293.85412", 16
    .const 'Sub' $P8478 = "305_1307873304.82979" 
    $P8476."add_method"($P8477, "semilist", $P8478)
    nqp_get_sc_object $P8479, "1307873293.85412", 16
    get_how $P8480, $P8479
    nqp_get_sc_object $P8481, "1307873293.85412", 16
    .const 'Sub' $P8482 = "306_1307873304.82979" 
    $P8480."add_method"($P8481, "!PREFIX__semilist", $P8482)
    nqp_get_sc_object $P8483, "1307873293.85412", 16
    get_how $P8484, $P8483
    nqp_get_sc_object $P8485, "1307873293.85412", 16
    .const 'Sub' $P8486 = "307_1307873304.82979" 
    $P8484."add_method"($P8485, "infixish", $P8486)
    nqp_get_sc_object $P8487, "1307873293.85412", 16
    get_how $P8488, $P8487
    nqp_get_sc_object $P8489, "1307873293.85412", 16
    .const 'Sub' $P8490 = "308_1307873304.82979" 
    $P8488."add_method"($P8489, "!PREFIX__infixish", $P8490)
    nqp_get_sc_object $P8491, "1307873293.85412", 16
    get_how $P8492, $P8491
    nqp_get_sc_object $P8493, "1307873293.85412", 16
    .const 'Sub' $P8494 = "309_1307873304.82979" 
    $P8492."add_method"($P8493, "infixstopper", $P8494)
    nqp_get_sc_object $P8495, "1307873293.85412", 16
    get_how $P8496, $P8495
    nqp_get_sc_object $P8497, "1307873293.85412", 16
    .const 'Sub' $P8498 = "310_1307873304.82979" 
    $P8496."add_method"($P8497, "!PREFIX__infixstopper", $P8498)
    nqp_get_sc_object $P8499, "1307873293.85412", 16
    get_how $P8500, $P8499
    nqp_get_sc_object $P8501, "1307873293.85412", 16
    .const 'Sub' $P8502 = "311_1307873304.82979" 
    $P8500."add_method"($P8501, "postcircumfix:sym<[ ]>", $P8502)
    nqp_get_sc_object $P8503, "1307873293.85412", 16
    get_how $P8504, $P8503
    nqp_get_sc_object $P8505, "1307873293.85412", 16
    .const 'Sub' $P8506 = "312_1307873304.82979" 
    $P8504."add_method"($P8505, "!PREFIX__postcircumfix:sym<[ ]>", $P8506)
    nqp_get_sc_object $P8507, "1307873293.85412", 16
    get_how $P8508, $P8507
    nqp_get_sc_object $P8509, "1307873293.85412", 16
    .const 'Sub' $P8510 = "313_1307873304.82979" 
    $P8508."add_method"($P8509, "postcircumfix:sym<{ }>", $P8510)
    nqp_get_sc_object $P8511, "1307873293.85412", 16
    get_how $P8512, $P8511
    nqp_get_sc_object $P8513, "1307873293.85412", 16
    .const 'Sub' $P8514 = "314_1307873304.82979" 
    $P8512."add_method"($P8513, "!PREFIX__postcircumfix:sym<{ }>", $P8514)
    nqp_get_sc_object $P8515, "1307873293.85412", 16
    get_how $P8516, $P8515
    nqp_get_sc_object $P8517, "1307873293.85412", 16
    .const 'Sub' $P8518 = "315_1307873304.82979" 
    $P8516."add_method"($P8517, "postcircumfix:sym<ang>", $P8518)
    nqp_get_sc_object $P8519, "1307873293.85412", 16
    get_how $P8520, $P8519
    nqp_get_sc_object $P8521, "1307873293.85412", 16
    .const 'Sub' $P8522 = "316_1307873304.82979" 
    $P8520."add_method"($P8521, "!PREFIX__postcircumfix:sym<ang>", $P8522)
    nqp_get_sc_object $P8523, "1307873293.85412", 16
    get_how $P8524, $P8523
    nqp_get_sc_object $P8525, "1307873293.85412", 16
    .const 'Sub' $P8526 = "317_1307873304.82979" 
    $P8524."add_method"($P8525, "postcircumfix:sym<( )>", $P8526)
    nqp_get_sc_object $P8527, "1307873293.85412", 16
    get_how $P8528, $P8527
    nqp_get_sc_object $P8529, "1307873293.85412", 16
    .const 'Sub' $P8530 = "318_1307873304.82979" 
    $P8528."add_method"($P8529, "!PREFIX__postcircumfix:sym<( )>", $P8530)
    nqp_get_sc_object $P8531, "1307873293.85412", 16
    get_how $P8532, $P8531
    nqp_get_sc_object $P8533, "1307873293.85412", 16
    .const 'Sub' $P8534 = "319_1307873304.82979" 
    $P8532."add_method"($P8533, "postfix:sym<.>", $P8534)
    nqp_get_sc_object $P8535, "1307873293.85412", 16
    get_how $P8536, $P8535
    nqp_get_sc_object $P8537, "1307873293.85412", 16
    .const 'Sub' $P8538 = "320_1307873304.82979" 
    $P8536."add_method"($P8537, "!PREFIX__postfix:sym<.>", $P8538)
    nqp_get_sc_object $P8539, "1307873293.85412", 16
    get_how $P8540, $P8539
    nqp_get_sc_object $P8541, "1307873293.85412", 16
    .const 'Sub' $P8542 = "321_1307873304.82979" 
    $P8540."add_method"($P8541, "prefix:sym<++>", $P8542)
    nqp_get_sc_object $P8543, "1307873293.85412", 16
    get_how $P8544, $P8543
    nqp_get_sc_object $P8545, "1307873293.85412", 16
    .const 'Sub' $P8546 = "322_1307873304.82979" 
    $P8544."add_method"($P8545, "!PREFIX__prefix:sym<++>", $P8546)
    nqp_get_sc_object $P8547, "1307873293.85412", 16
    get_how $P8548, $P8547
    nqp_get_sc_object $P8549, "1307873293.85412", 16
    .const 'Sub' $P8550 = "323_1307873304.82979" 
    $P8548."add_method"($P8549, "prefix:sym<-->", $P8550)
    nqp_get_sc_object $P8551, "1307873293.85412", 16
    get_how $P8552, $P8551
    nqp_get_sc_object $P8553, "1307873293.85412", 16
    .const 'Sub' $P8554 = "324_1307873304.82979" 
    $P8552."add_method"($P8553, "!PREFIX__prefix:sym<-->", $P8554)
    nqp_get_sc_object $P8555, "1307873293.85412", 16
    get_how $P8556, $P8555
    nqp_get_sc_object $P8557, "1307873293.85412", 16
    .const 'Sub' $P8558 = "325_1307873304.82979" 
    $P8556."add_method"($P8557, "postfix:sym<++>", $P8558)
    nqp_get_sc_object $P8559, "1307873293.85412", 16
    get_how $P8560, $P8559
    nqp_get_sc_object $P8561, "1307873293.85412", 16
    .const 'Sub' $P8562 = "326_1307873304.82979" 
    $P8560."add_method"($P8561, "!PREFIX__postfix:sym<++>", $P8562)
    nqp_get_sc_object $P8563, "1307873293.85412", 16
    get_how $P8564, $P8563
    nqp_get_sc_object $P8565, "1307873293.85412", 16
    .const 'Sub' $P8566 = "327_1307873304.82979" 
    $P8564."add_method"($P8565, "postfix:sym<-->", $P8566)
    nqp_get_sc_object $P8567, "1307873293.85412", 16
    get_how $P8568, $P8567
    nqp_get_sc_object $P8569, "1307873293.85412", 16
    .const 'Sub' $P8570 = "328_1307873304.82979" 
    $P8568."add_method"($P8569, "!PREFIX__postfix:sym<-->", $P8570)
    nqp_get_sc_object $P8571, "1307873293.85412", 16
    get_how $P8572, $P8571
    nqp_get_sc_object $P8573, "1307873293.85412", 16
    .const 'Sub' $P8574 = "329_1307873304.82979" 
    $P8572."add_method"($P8573, "infix:sym<**>", $P8574)
    nqp_get_sc_object $P8575, "1307873293.85412", 16
    get_how $P8576, $P8575
    nqp_get_sc_object $P8577, "1307873293.85412", 16
    .const 'Sub' $P8578 = "330_1307873304.82979" 
    $P8576."add_method"($P8577, "!PREFIX__infix:sym<**>", $P8578)
    nqp_get_sc_object $P8579, "1307873293.85412", 16
    get_how $P8580, $P8579
    nqp_get_sc_object $P8581, "1307873293.85412", 16
    .const 'Sub' $P8582 = "331_1307873304.82979" 
    $P8580."add_method"($P8581, "prefix:sym<+>", $P8582)
    nqp_get_sc_object $P8583, "1307873293.85412", 16
    get_how $P8584, $P8583
    nqp_get_sc_object $P8585, "1307873293.85412", 16
    .const 'Sub' $P8586 = "332_1307873304.82979" 
    $P8584."add_method"($P8585, "!PREFIX__prefix:sym<+>", $P8586)
    nqp_get_sc_object $P8587, "1307873293.85412", 16
    get_how $P8588, $P8587
    nqp_get_sc_object $P8589, "1307873293.85412", 16
    .const 'Sub' $P8590 = "333_1307873304.82979" 
    $P8588."add_method"($P8589, "prefix:sym<~>", $P8590)
    nqp_get_sc_object $P8591, "1307873293.85412", 16
    get_how $P8592, $P8591
    nqp_get_sc_object $P8593, "1307873293.85412", 16
    .const 'Sub' $P8594 = "334_1307873304.82979" 
    $P8592."add_method"($P8593, "!PREFIX__prefix:sym<~>", $P8594)
    nqp_get_sc_object $P8595, "1307873293.85412", 16
    get_how $P8596, $P8595
    nqp_get_sc_object $P8597, "1307873293.85412", 16
    .const 'Sub' $P8598 = "335_1307873304.82979" 
    $P8596."add_method"($P8597, "prefix:sym<->", $P8598)
    nqp_get_sc_object $P8599, "1307873293.85412", 16
    get_how $P8600, $P8599
    nqp_get_sc_object $P8601, "1307873293.85412", 16
    .const 'Sub' $P8602 = "336_1307873304.82979" 
    $P8600."add_method"($P8601, "!PREFIX__prefix:sym<->", $P8602)
    nqp_get_sc_object $P8603, "1307873293.85412", 16
    get_how $P8604, $P8603
    nqp_get_sc_object $P8605, "1307873293.85412", 16
    .const 'Sub' $P8606 = "337_1307873304.82979" 
    $P8604."add_method"($P8605, "prefix:sym<?>", $P8606)
    nqp_get_sc_object $P8607, "1307873293.85412", 16
    get_how $P8608, $P8607
    nqp_get_sc_object $P8609, "1307873293.85412", 16
    .const 'Sub' $P8610 = "338_1307873304.82979" 
    $P8608."add_method"($P8609, "!PREFIX__prefix:sym<?>", $P8610)
    nqp_get_sc_object $P8611, "1307873293.85412", 16
    get_how $P8612, $P8611
    nqp_get_sc_object $P8613, "1307873293.85412", 16
    .const 'Sub' $P8614 = "339_1307873304.82979" 
    $P8612."add_method"($P8613, "prefix:sym<!>", $P8614)
    nqp_get_sc_object $P8615, "1307873293.85412", 16
    get_how $P8616, $P8615
    nqp_get_sc_object $P8617, "1307873293.85412", 16
    .const 'Sub' $P8618 = "340_1307873304.82979" 
    $P8616."add_method"($P8617, "!PREFIX__prefix:sym<!>", $P8618)
    nqp_get_sc_object $P8619, "1307873293.85412", 16
    get_how $P8620, $P8619
    nqp_get_sc_object $P8621, "1307873293.85412", 16
    .const 'Sub' $P8622 = "341_1307873304.82979" 
    $P8620."add_method"($P8621, "prefix:sym<|>", $P8622)
    nqp_get_sc_object $P8623, "1307873293.85412", 16
    get_how $P8624, $P8623
    nqp_get_sc_object $P8625, "1307873293.85412", 16
    .const 'Sub' $P8626 = "342_1307873304.82979" 
    $P8624."add_method"($P8625, "!PREFIX__prefix:sym<|>", $P8626)
    nqp_get_sc_object $P8627, "1307873293.85412", 16
    get_how $P8628, $P8627
    nqp_get_sc_object $P8629, "1307873293.85412", 16
    .const 'Sub' $P8630 = "343_1307873304.82979" 
    $P8628."add_method"($P8629, "infix:sym<*>", $P8630)
    nqp_get_sc_object $P8631, "1307873293.85412", 16
    get_how $P8632, $P8631
    nqp_get_sc_object $P8633, "1307873293.85412", 16
    .const 'Sub' $P8634 = "344_1307873304.82979" 
    $P8632."add_method"($P8633, "!PREFIX__infix:sym<*>", $P8634)
    nqp_get_sc_object $P8635, "1307873293.85412", 16
    get_how $P8636, $P8635
    nqp_get_sc_object $P8637, "1307873293.85412", 16
    .const 'Sub' $P8638 = "345_1307873304.82979" 
    $P8636."add_method"($P8637, "infix:sym</>", $P8638)
    nqp_get_sc_object $P8639, "1307873293.85412", 16
    get_how $P8640, $P8639
    nqp_get_sc_object $P8641, "1307873293.85412", 16
    .const 'Sub' $P8642 = "346_1307873304.82979" 
    $P8640."add_method"($P8641, "!PREFIX__infix:sym</>", $P8642)
    nqp_get_sc_object $P8643, "1307873293.85412", 16
    get_how $P8644, $P8643
    nqp_get_sc_object $P8645, "1307873293.85412", 16
    .const 'Sub' $P8646 = "347_1307873304.82979" 
    $P8644."add_method"($P8645, "infix:sym<%>", $P8646)
    nqp_get_sc_object $P8647, "1307873293.85412", 16
    get_how $P8648, $P8647
    nqp_get_sc_object $P8649, "1307873293.85412", 16
    .const 'Sub' $P8650 = "348_1307873304.82979" 
    $P8648."add_method"($P8649, "!PREFIX__infix:sym<%>", $P8650)
    nqp_get_sc_object $P8651, "1307873293.85412", 16
    get_how $P8652, $P8651
    nqp_get_sc_object $P8653, "1307873293.85412", 16
    .const 'Sub' $P8654 = "349_1307873304.82979" 
    $P8652."add_method"($P8653, "infix:sym<+&>", $P8654)
    nqp_get_sc_object $P8655, "1307873293.85412", 16
    get_how $P8656, $P8655
    nqp_get_sc_object $P8657, "1307873293.85412", 16
    .const 'Sub' $P8658 = "350_1307873304.82979" 
    $P8656."add_method"($P8657, "!PREFIX__infix:sym<+&>", $P8658)
    nqp_get_sc_object $P8659, "1307873293.85412", 16
    get_how $P8660, $P8659
    nqp_get_sc_object $P8661, "1307873293.85412", 16
    .const 'Sub' $P8662 = "351_1307873304.82979" 
    $P8660."add_method"($P8661, "infix:sym<+>", $P8662)
    nqp_get_sc_object $P8663, "1307873293.85412", 16
    get_how $P8664, $P8663
    nqp_get_sc_object $P8665, "1307873293.85412", 16
    .const 'Sub' $P8666 = "352_1307873304.82979" 
    $P8664."add_method"($P8665, "!PREFIX__infix:sym<+>", $P8666)
    nqp_get_sc_object $P8667, "1307873293.85412", 16
    get_how $P8668, $P8667
    nqp_get_sc_object $P8669, "1307873293.85412", 16
    .const 'Sub' $P8670 = "353_1307873304.82979" 
    $P8668."add_method"($P8669, "infix:sym<->", $P8670)
    nqp_get_sc_object $P8671, "1307873293.85412", 16
    get_how $P8672, $P8671
    nqp_get_sc_object $P8673, "1307873293.85412", 16
    .const 'Sub' $P8674 = "354_1307873304.82979" 
    $P8672."add_method"($P8673, "!PREFIX__infix:sym<->", $P8674)
    nqp_get_sc_object $P8675, "1307873293.85412", 16
    get_how $P8676, $P8675
    nqp_get_sc_object $P8677, "1307873293.85412", 16
    .const 'Sub' $P8678 = "355_1307873304.82979" 
    $P8676."add_method"($P8677, "infix:sym<+|>", $P8678)
    nqp_get_sc_object $P8679, "1307873293.85412", 16
    get_how $P8680, $P8679
    nqp_get_sc_object $P8681, "1307873293.85412", 16
    .const 'Sub' $P8682 = "356_1307873304.82979" 
    $P8680."add_method"($P8681, "!PREFIX__infix:sym<+|>", $P8682)
    nqp_get_sc_object $P8683, "1307873293.85412", 16
    get_how $P8684, $P8683
    nqp_get_sc_object $P8685, "1307873293.85412", 16
    .const 'Sub' $P8686 = "357_1307873304.82979" 
    $P8684."add_method"($P8685, "infix:sym<+^>", $P8686)
    nqp_get_sc_object $P8687, "1307873293.85412", 16
    get_how $P8688, $P8687
    nqp_get_sc_object $P8689, "1307873293.85412", 16
    .const 'Sub' $P8690 = "358_1307873304.82979" 
    $P8688."add_method"($P8689, "!PREFIX__infix:sym<+^>", $P8690)
    nqp_get_sc_object $P8691, "1307873293.85412", 16
    get_how $P8692, $P8691
    nqp_get_sc_object $P8693, "1307873293.85412", 16
    .const 'Sub' $P8694 = "359_1307873304.82979" 
    $P8692."add_method"($P8693, "infix:sym<~>", $P8694)
    nqp_get_sc_object $P8695, "1307873293.85412", 16
    get_how $P8696, $P8695
    nqp_get_sc_object $P8697, "1307873293.85412", 16
    .const 'Sub' $P8698 = "360_1307873304.82979" 
    $P8696."add_method"($P8697, "!PREFIX__infix:sym<~>", $P8698)
    nqp_get_sc_object $P8699, "1307873293.85412", 16
    get_how $P8700, $P8699
    nqp_get_sc_object $P8701, "1307873293.85412", 16
    .const 'Sub' $P8702 = "361_1307873304.82979" 
    $P8700."add_method"($P8701, "infix:sym<==>", $P8702)
    nqp_get_sc_object $P8703, "1307873293.85412", 16
    get_how $P8704, $P8703
    nqp_get_sc_object $P8705, "1307873293.85412", 16
    .const 'Sub' $P8706 = "362_1307873304.82979" 
    $P8704."add_method"($P8705, "!PREFIX__infix:sym<==>", $P8706)
    nqp_get_sc_object $P8707, "1307873293.85412", 16
    get_how $P8708, $P8707
    nqp_get_sc_object $P8709, "1307873293.85412", 16
    .const 'Sub' $P8710 = "363_1307873304.82979" 
    $P8708."add_method"($P8709, "infix:sym<!=>", $P8710)
    nqp_get_sc_object $P8711, "1307873293.85412", 16
    get_how $P8712, $P8711
    nqp_get_sc_object $P8713, "1307873293.85412", 16
    .const 'Sub' $P8714 = "364_1307873304.82979" 
    $P8712."add_method"($P8713, "!PREFIX__infix:sym<!=>", $P8714)
    nqp_get_sc_object $P8715, "1307873293.85412", 16
    get_how $P8716, $P8715
    nqp_get_sc_object $P8717, "1307873293.85412", 16
    .const 'Sub' $P8718 = "365_1307873304.82979" 
    $P8716."add_method"($P8717, "infix:sym<<=>", $P8718)
    nqp_get_sc_object $P8719, "1307873293.85412", 16
    get_how $P8720, $P8719
    nqp_get_sc_object $P8721, "1307873293.85412", 16
    .const 'Sub' $P8722 = "366_1307873304.82979" 
    $P8720."add_method"($P8721, "!PREFIX__infix:sym<<=>", $P8722)
    nqp_get_sc_object $P8723, "1307873293.85412", 16
    get_how $P8724, $P8723
    nqp_get_sc_object $P8725, "1307873293.85412", 16
    .const 'Sub' $P8726 = "367_1307873304.82979" 
    $P8724."add_method"($P8725, "infix:sym<>=>", $P8726)
    nqp_get_sc_object $P8727, "1307873293.85412", 16
    get_how $P8728, $P8727
    nqp_get_sc_object $P8729, "1307873293.85412", 16
    .const 'Sub' $P8730 = "368_1307873304.82979" 
    $P8728."add_method"($P8729, "!PREFIX__infix:sym<>=>", $P8730)
    nqp_get_sc_object $P8731, "1307873293.85412", 16
    get_how $P8732, $P8731
    nqp_get_sc_object $P8733, "1307873293.85412", 16
    .const 'Sub' $P8734 = "369_1307873304.82979" 
    $P8732."add_method"($P8733, "infix:sym<<>", $P8734)
    nqp_get_sc_object $P8735, "1307873293.85412", 16
    get_how $P8736, $P8735
    nqp_get_sc_object $P8737, "1307873293.85412", 16
    .const 'Sub' $P8738 = "370_1307873304.82979" 
    $P8736."add_method"($P8737, "!PREFIX__infix:sym<<>", $P8738)
    nqp_get_sc_object $P8739, "1307873293.85412", 16
    get_how $P8740, $P8739
    nqp_get_sc_object $P8741, "1307873293.85412", 16
    .const 'Sub' $P8742 = "371_1307873304.82979" 
    $P8740."add_method"($P8741, "infix:sym<>>", $P8742)
    nqp_get_sc_object $P8743, "1307873293.85412", 16
    get_how $P8744, $P8743
    nqp_get_sc_object $P8745, "1307873293.85412", 16
    .const 'Sub' $P8746 = "372_1307873304.82979" 
    $P8744."add_method"($P8745, "!PREFIX__infix:sym<>>", $P8746)
    nqp_get_sc_object $P8747, "1307873293.85412", 16
    get_how $P8748, $P8747
    nqp_get_sc_object $P8749, "1307873293.85412", 16
    .const 'Sub' $P8750 = "373_1307873304.82979" 
    $P8748."add_method"($P8749, "infix:sym<eq>", $P8750)
    nqp_get_sc_object $P8751, "1307873293.85412", 16
    get_how $P8752, $P8751
    nqp_get_sc_object $P8753, "1307873293.85412", 16
    .const 'Sub' $P8754 = "374_1307873304.82979" 
    $P8752."add_method"($P8753, "!PREFIX__infix:sym<eq>", $P8754)
    nqp_get_sc_object $P8755, "1307873293.85412", 16
    get_how $P8756, $P8755
    nqp_get_sc_object $P8757, "1307873293.85412", 16
    .const 'Sub' $P8758 = "375_1307873304.82979" 
    $P8756."add_method"($P8757, "infix:sym<ne>", $P8758)
    nqp_get_sc_object $P8759, "1307873293.85412", 16
    get_how $P8760, $P8759
    nqp_get_sc_object $P8761, "1307873293.85412", 16
    .const 'Sub' $P8762 = "376_1307873304.82979" 
    $P8760."add_method"($P8761, "!PREFIX__infix:sym<ne>", $P8762)
    nqp_get_sc_object $P8763, "1307873293.85412", 16
    get_how $P8764, $P8763
    nqp_get_sc_object $P8765, "1307873293.85412", 16
    .const 'Sub' $P8766 = "377_1307873304.82979" 
    $P8764."add_method"($P8765, "infix:sym<le>", $P8766)
    nqp_get_sc_object $P8767, "1307873293.85412", 16
    get_how $P8768, $P8767
    nqp_get_sc_object $P8769, "1307873293.85412", 16
    .const 'Sub' $P8770 = "378_1307873304.82979" 
    $P8768."add_method"($P8769, "!PREFIX__infix:sym<le>", $P8770)
    nqp_get_sc_object $P8771, "1307873293.85412", 16
    get_how $P8772, $P8771
    nqp_get_sc_object $P8773, "1307873293.85412", 16
    .const 'Sub' $P8774 = "379_1307873304.82979" 
    $P8772."add_method"($P8773, "infix:sym<ge>", $P8774)
    nqp_get_sc_object $P8775, "1307873293.85412", 16
    get_how $P8776, $P8775
    nqp_get_sc_object $P8777, "1307873293.85412", 16
    .const 'Sub' $P8778 = "380_1307873304.82979" 
    $P8776."add_method"($P8777, "!PREFIX__infix:sym<ge>", $P8778)
    nqp_get_sc_object $P8779, "1307873293.85412", 16
    get_how $P8780, $P8779
    nqp_get_sc_object $P8781, "1307873293.85412", 16
    .const 'Sub' $P8782 = "381_1307873304.82979" 
    $P8780."add_method"($P8781, "infix:sym<lt>", $P8782)
    nqp_get_sc_object $P8783, "1307873293.85412", 16
    get_how $P8784, $P8783
    nqp_get_sc_object $P8785, "1307873293.85412", 16
    .const 'Sub' $P8786 = "382_1307873304.82979" 
    $P8784."add_method"($P8785, "!PREFIX__infix:sym<lt>", $P8786)
    nqp_get_sc_object $P8787, "1307873293.85412", 16
    get_how $P8788, $P8787
    nqp_get_sc_object $P8789, "1307873293.85412", 16
    .const 'Sub' $P8790 = "383_1307873304.82979" 
    $P8788."add_method"($P8789, "infix:sym<gt>", $P8790)
    nqp_get_sc_object $P8791, "1307873293.85412", 16
    get_how $P8792, $P8791
    nqp_get_sc_object $P8793, "1307873293.85412", 16
    .const 'Sub' $P8794 = "384_1307873304.82979" 
    $P8792."add_method"($P8793, "!PREFIX__infix:sym<gt>", $P8794)
    nqp_get_sc_object $P8795, "1307873293.85412", 16
    get_how $P8796, $P8795
    nqp_get_sc_object $P8797, "1307873293.85412", 16
    .const 'Sub' $P8798 = "385_1307873304.82979" 
    $P8796."add_method"($P8797, "infix:sym<=:=>", $P8798)
    nqp_get_sc_object $P8799, "1307873293.85412", 16
    get_how $P8800, $P8799
    nqp_get_sc_object $P8801, "1307873293.85412", 16
    .const 'Sub' $P8802 = "386_1307873304.82979" 
    $P8800."add_method"($P8801, "!PREFIX__infix:sym<=:=>", $P8802)
    nqp_get_sc_object $P8803, "1307873293.85412", 16
    get_how $P8804, $P8803
    nqp_get_sc_object $P8805, "1307873293.85412", 16
    .const 'Sub' $P8806 = "387_1307873304.82979" 
    $P8804."add_method"($P8805, "infix:sym<~~>", $P8806)
    nqp_get_sc_object $P8807, "1307873293.85412", 16
    get_how $P8808, $P8807
    nqp_get_sc_object $P8809, "1307873293.85412", 16
    .const 'Sub' $P8810 = "388_1307873304.82979" 
    $P8808."add_method"($P8809, "!PREFIX__infix:sym<~~>", $P8810)
    nqp_get_sc_object $P8811, "1307873293.85412", 16
    get_how $P8812, $P8811
    nqp_get_sc_object $P8813, "1307873293.85412", 16
    .const 'Sub' $P8814 = "389_1307873304.82979" 
    $P8812."add_method"($P8813, "infix:sym<&&>", $P8814)
    nqp_get_sc_object $P8815, "1307873293.85412", 16
    get_how $P8816, $P8815
    nqp_get_sc_object $P8817, "1307873293.85412", 16
    .const 'Sub' $P8818 = "390_1307873304.82979" 
    $P8816."add_method"($P8817, "!PREFIX__infix:sym<&&>", $P8818)
    nqp_get_sc_object $P8819, "1307873293.85412", 16
    get_how $P8820, $P8819
    nqp_get_sc_object $P8821, "1307873293.85412", 16
    .const 'Sub' $P8822 = "391_1307873304.82979" 
    $P8820."add_method"($P8821, "infix:sym<||>", $P8822)
    nqp_get_sc_object $P8823, "1307873293.85412", 16
    get_how $P8824, $P8823
    nqp_get_sc_object $P8825, "1307873293.85412", 16
    .const 'Sub' $P8826 = "392_1307873304.82979" 
    $P8824."add_method"($P8825, "!PREFIX__infix:sym<||>", $P8826)
    nqp_get_sc_object $P8827, "1307873293.85412", 16
    get_how $P8828, $P8827
    nqp_get_sc_object $P8829, "1307873293.85412", 16
    .const 'Sub' $P8830 = "393_1307873304.82979" 
    $P8828."add_method"($P8829, "infix:sym<//>", $P8830)
    nqp_get_sc_object $P8831, "1307873293.85412", 16
    get_how $P8832, $P8831
    nqp_get_sc_object $P8833, "1307873293.85412", 16
    .const 'Sub' $P8834 = "394_1307873304.82979" 
    $P8832."add_method"($P8833, "!PREFIX__infix:sym<//>", $P8834)
    nqp_get_sc_object $P8835, "1307873293.85412", 16
    get_how $P8836, $P8835
    nqp_get_sc_object $P8837, "1307873293.85412", 16
    .const 'Sub' $P8838 = "395_1307873304.82979" 
    $P8836."add_method"($P8837, "infix:sym<?? !!>", $P8838)
    nqp_get_sc_object $P8839, "1307873293.85412", 16
    get_how $P8840, $P8839
    nqp_get_sc_object $P8841, "1307873293.85412", 16
    .const 'Sub' $P8842 = "396_1307873304.82979" 
    $P8840."add_method"($P8841, "!PREFIX__infix:sym<?? !!>", $P8842)
    nqp_get_sc_object $P8843, "1307873293.85412", 16
    get_how $P8844, $P8843
    nqp_get_sc_object $P8845, "1307873293.85412", 16
    .const 'Sub' $P8846 = "397_1307873304.82979" 
    $P8844."add_method"($P8845, "infix:sym<=>", $P8846)
    nqp_get_sc_object $P8847, "1307873293.85412", 16
    get_how $P8848, $P8847
    nqp_get_sc_object $P8849, "1307873293.85412", 16
    .const 'Sub' $P8850 = "398_1307873304.82979" 
    $P8848."add_method"($P8849, "!PREFIX__infix:sym<=>", $P8850)
    nqp_get_sc_object $P8851, "1307873293.85412", 16
    get_how $P8852, $P8851
    nqp_get_sc_object $P8853, "1307873293.85412", 16
    .const 'Sub' $P8854 = "399_1307873304.82979" 
    $P8852."add_method"($P8853, "infix:sym<:=>", $P8854)
    nqp_get_sc_object $P8855, "1307873293.85412", 16
    get_how $P8856, $P8855
    nqp_get_sc_object $P8857, "1307873293.85412", 16
    .const 'Sub' $P8858 = "400_1307873304.82979" 
    $P8856."add_method"($P8857, "!PREFIX__infix:sym<:=>", $P8858)
    nqp_get_sc_object $P8859, "1307873293.85412", 16
    get_how $P8860, $P8859
    nqp_get_sc_object $P8861, "1307873293.85412", 16
    .const 'Sub' $P8862 = "401_1307873304.82979" 
    $P8860."add_method"($P8861, "infix:sym<::=>", $P8862)
    nqp_get_sc_object $P8863, "1307873293.85412", 16
    get_how $P8864, $P8863
    nqp_get_sc_object $P8865, "1307873293.85412", 16
    .const 'Sub' $P8866 = "402_1307873304.82979" 
    $P8864."add_method"($P8865, "!PREFIX__infix:sym<::=>", $P8866)
    nqp_get_sc_object $P8867, "1307873293.85412", 16
    get_how $P8868, $P8867
    nqp_get_sc_object $P8869, "1307873293.85412", 16
    .const 'Sub' $P8870 = "403_1307873304.82979" 
    $P8868."add_method"($P8869, "infix:sym<,>", $P8870)
    nqp_get_sc_object $P8871, "1307873293.85412", 16
    get_how $P8872, $P8871
    nqp_get_sc_object $P8873, "1307873293.85412", 16
    .const 'Sub' $P8874 = "404_1307873304.82979" 
    $P8872."add_method"($P8873, "!PREFIX__infix:sym<,>", $P8874)
    nqp_get_sc_object $P8875, "1307873293.85412", 16
    get_how $P8876, $P8875
    nqp_get_sc_object $P8877, "1307873293.85412", 16
    .const 'Sub' $P8878 = "405_1307873304.82979" 
    $P8876."add_method"($P8877, "prefix:sym<return>", $P8878)
    nqp_get_sc_object $P8879, "1307873293.85412", 16
    get_how $P8880, $P8879
    nqp_get_sc_object $P8881, "1307873293.85412", 16
    .const 'Sub' $P8882 = "407_1307873304.82979" 
    $P8880."add_method"($P8881, "!PREFIX__prefix:sym<return>", $P8882)
    nqp_get_sc_object $P8883, "1307873293.85412", 16
    get_how $P8884, $P8883
    nqp_get_sc_object $P8885, "1307873293.85412", 16
    .const 'Sub' $P8886 = "408_1307873304.82979" 
    $P8884."add_method"($P8885, "prefix:sym<make>", $P8886)
    nqp_get_sc_object $P8887, "1307873293.85412", 16
    get_how $P8888, $P8887
    nqp_get_sc_object $P8889, "1307873293.85412", 16
    .const 'Sub' $P8890 = "409_1307873304.82979" 
    $P8888."add_method"($P8889, "!PREFIX__prefix:sym<make>", $P8890)
    nqp_get_sc_object $P8891, "1307873293.85412", 16
    get_how $P8892, $P8891
    nqp_get_sc_object $P8893, "1307873293.85412", 16
    .const 'Sub' $P8894 = "410_1307873304.82979" 
    $P8892."add_method"($P8893, "term:sym<last>", $P8894)
    nqp_get_sc_object $P8895, "1307873293.85412", 16
    get_how $P8896, $P8895
    nqp_get_sc_object $P8897, "1307873293.85412", 16
    .const 'Sub' $P8898 = "411_1307873304.82979" 
    $P8896."add_method"($P8897, "!PREFIX__term:sym<last>", $P8898)
    nqp_get_sc_object $P8899, "1307873293.85412", 16
    get_how $P8900, $P8899
    nqp_get_sc_object $P8901, "1307873293.85412", 16
    .const 'Sub' $P8902 = "412_1307873304.82979" 
    $P8900."add_method"($P8901, "term:sym<next>", $P8902)
    nqp_get_sc_object $P8903, "1307873293.85412", 16
    get_how $P8904, $P8903
    nqp_get_sc_object $P8905, "1307873293.85412", 16
    .const 'Sub' $P8906 = "413_1307873304.82979" 
    $P8904."add_method"($P8905, "!PREFIX__term:sym<next>", $P8906)
    nqp_get_sc_object $P8907, "1307873293.85412", 16
    get_how $P8908, $P8907
    nqp_get_sc_object $P8909, "1307873293.85412", 16
    .const 'Sub' $P8910 = "414_1307873304.82979" 
    $P8908."add_method"($P8909, "term:sym<redo>", $P8910)
    nqp_get_sc_object $P8911, "1307873293.85412", 16
    get_how $P8912, $P8911
    nqp_get_sc_object $P8913, "1307873293.85412", 16
    .const 'Sub' $P8914 = "415_1307873304.82979" 
    $P8912."add_method"($P8913, "!PREFIX__term:sym<redo>", $P8914)
    nqp_get_sc_object $P8915, "1307873293.85412", 16
    get_how $P8916, $P8915
    nqp_get_sc_object $P8917, "1307873293.85412", 16
    .const 'Sub' $P8918 = "416_1307873304.82979" 
    $P8916."add_method"($P8917, "smartmatch", $P8918)
    .const 'Sub' $P8919 = "40_1307873304.82979" 
    $P8920 = $P8919."get_lexinfo"()
    nqp_get_sc_object $P8921, "1307873293.85412", 16
    $P8920."set_static_lexpad_value"("$?PACKAGE", $P8921)
    .const 'Sub' $P8922 = "40_1307873304.82979" 
    $P8923 = $P8922."get_lexinfo"()
    $P8923."finish_static_lexpad"()
    .const 'Sub' $P8924 = "40_1307873304.82979" 
    $P8925 = $P8924."get_lexinfo"()
    nqp_get_sc_object $P8926, "1307873293.85412", 16
    $P8925."set_static_lexpad_value"("$?CLASS", $P8926)
    .const 'Sub' $P8927 = "40_1307873304.82979" 
    $P8928 = $P8927."get_lexinfo"()
    $P8928."finish_static_lexpad"()
    nqp_get_sc_object $P8929, "1307873293.85412", 16
    get_how $P8930, $P8929
    nqp_get_sc_object $P8931, "1307873293.85412", 16
    nqp_get_sc_object $P8932, "1307873280.77112", 1
    $P8930."add_parent"($P8931, $P8932)
    nqp_get_sc_object $P8933, "1307873293.85412", 16
    get_how $P8934, $P8933
    nqp_get_sc_object $P8935, "1307873293.85412", 16
    $P8934."compose"($P8935)
    nqp_get_sc_object $P8936, "1307873274.8766", 41
    $P8937 = $P8936."new_type"("NQP::Regex" :named("name"))
    nqp_set_sc_for_object $P8937, cur_sc
    nqp_set_sc_object "1307873293.85412", 379, $P8937
    nqp_get_sc_object $P8938, "1307873293.85412", 379
    nqp_get_sc_object $P8939, "1307873293.85412", 0
    nqp_get_package_through_who $P8940, $P8939, "NQP"
    get_who $P8941, $P8940
    set $P8941["Regex"], $P8938
    nqp_get_sc_object $P8942, "1307873293.85412", 379
    get_how $P8943, $P8942
    nqp_get_sc_object $P8944, "1307873293.85412", 379
    .const 'Sub' $P8945 = "418_1307873304.82979" 
    $P8943."add_method"($P8944, "metachar:sym<:my>", $P8945)
    nqp_get_sc_object $P8946, "1307873293.85412", 379
    get_how $P8947, $P8946
    nqp_get_sc_object $P8948, "1307873293.85412", 379
    .const 'Sub' $P8949 = "420_1307873304.82979" 
    $P8947."add_method"($P8948, "!PREFIX__metachar:sym<:my>", $P8949)
    nqp_get_sc_object $P8950, "1307873293.85412", 379
    get_how $P8951, $P8950
    nqp_get_sc_object $P8952, "1307873293.85412", 379
    .const 'Sub' $P8953 = "421_1307873304.82979" 
    $P8951."add_method"($P8952, "metachar:sym<{ }>", $P8953)
    nqp_get_sc_object $P8954, "1307873293.85412", 379
    get_how $P8955, $P8954
    nqp_get_sc_object $P8956, "1307873293.85412", 379
    .const 'Sub' $P8957 = "422_1307873304.82979" 
    $P8955."add_method"($P8956, "!PREFIX__metachar:sym<{ }>", $P8957)
    nqp_get_sc_object $P8958, "1307873293.85412", 379
    get_how $P8959, $P8958
    nqp_get_sc_object $P8960, "1307873293.85412", 379
    .const 'Sub' $P8961 = "423_1307873304.82979" 
    $P8959."add_method"($P8960, "metachar:sym<nqpvar>", $P8961)
    nqp_get_sc_object $P8962, "1307873293.85412", 379
    get_how $P8963, $P8962
    nqp_get_sc_object $P8964, "1307873293.85412", 379
    .const 'Sub' $P8965 = "425_1307873304.82979" 
    $P8963."add_method"($P8964, "!PREFIX__metachar:sym<nqpvar>", $P8965)
    nqp_get_sc_object $P8966, "1307873293.85412", 379
    get_how $P8967, $P8966
    nqp_get_sc_object $P8968, "1307873293.85412", 379
    .const 'Sub' $P8969 = "426_1307873304.82979" 
    $P8967."add_method"($P8968, "assertion:sym<{ }>", $P8969)
    nqp_get_sc_object $P8970, "1307873293.85412", 379
    get_how $P8971, $P8970
    nqp_get_sc_object $P8972, "1307873293.85412", 379
    .const 'Sub' $P8973 = "427_1307873304.82979" 
    $P8971."add_method"($P8972, "!PREFIX__assertion:sym<{ }>", $P8973)
    nqp_get_sc_object $P8974, "1307873293.85412", 379
    get_how $P8975, $P8974
    nqp_get_sc_object $P8976, "1307873293.85412", 379
    .const 'Sub' $P8977 = "428_1307873304.82979" 
    $P8975."add_method"($P8976, "assertion:sym<?{ }>", $P8977)
    nqp_get_sc_object $P8978, "1307873293.85412", 379
    get_how $P8979, $P8978
    nqp_get_sc_object $P8980, "1307873293.85412", 379
    .const 'Sub' $P8981 = "430_1307873304.82979" 
    $P8979."add_method"($P8980, "!PREFIX__assertion:sym<?{ }>", $P8981)
    nqp_get_sc_object $P8982, "1307873293.85412", 379
    get_how $P8983, $P8982
    nqp_get_sc_object $P8984, "1307873293.85412", 379
    .const 'Sub' $P8985 = "431_1307873304.82979" 
    $P8983."add_method"($P8984, "assertion:sym<name>", $P8985)
    nqp_get_sc_object $P8986, "1307873293.85412", 379
    get_how $P8987, $P8986
    nqp_get_sc_object $P8988, "1307873293.85412", 379
    .const 'Sub' $P8989 = "433_1307873304.82979" 
    $P8987."add_method"($P8988, "!PREFIX__assertion:sym<name>", $P8989)
    nqp_get_sc_object $P8990, "1307873293.85412", 379
    get_how $P8991, $P8990
    nqp_get_sc_object $P8992, "1307873293.85412", 379
    .const 'Sub' $P8993 = "434_1307873304.82979" 
    $P8991."add_method"($P8992, "assertion:sym<var>", $P8993)
    nqp_get_sc_object $P8994, "1307873293.85412", 379
    get_how $P8995, $P8994
    nqp_get_sc_object $P8996, "1307873293.85412", 379
    .const 'Sub' $P8997 = "435_1307873304.82979" 
    $P8995."add_method"($P8996, "!PREFIX__assertion:sym<var>", $P8997)
    nqp_get_sc_object $P8998, "1307873293.85412", 379
    get_how $P8999, $P8998
    nqp_get_sc_object $P9000, "1307873293.85412", 379
    .const 'Sub' $P9001 = "436_1307873304.82979" 
    $P8999."add_method"($P9000, "codeblock", $P9001)
    nqp_get_sc_object $P9002, "1307873293.85412", 379
    get_how $P9003, $P9002
    nqp_get_sc_object $P9004, "1307873293.85412", 379
    .const 'Sub' $P9005 = "437_1307873304.82979" 
    $P9003."add_method"($P9004, "!PREFIX__codeblock", $P9005)
    .const 'Sub' $P9006 = "417_1307873304.82979" 
    $P9007 = $P9006."get_lexinfo"()
    nqp_get_sc_object $P9008, "1307873293.85412", 379
    $P9007."set_static_lexpad_value"("$?PACKAGE", $P9008)
    .const 'Sub' $P9009 = "417_1307873304.82979" 
    $P9010 = $P9009."get_lexinfo"()
    $P9010."finish_static_lexpad"()
    .const 'Sub' $P9011 = "417_1307873304.82979" 
    $P9012 = $P9011."get_lexinfo"()
    nqp_get_sc_object $P9013, "1307873293.85412", 379
    $P9012."set_static_lexpad_value"("$?CLASS", $P9013)
    .const 'Sub' $P9014 = "417_1307873304.82979" 
    $P9015 = $P9014."get_lexinfo"()
    $P9015."finish_static_lexpad"()
    nqp_get_sc_object $P9016, "1307873293.85412", 379
    get_how $P9017, $P9016
    nqp_get_sc_object $P9018, "1307873293.85412", 379
    nqp_get_sc_object $P9019, "1307873288.51323", 1
    $P9017."add_parent"($P9018, $P9019)
    nqp_get_sc_object $P9020, "1307873293.85412", 379
    get_how $P9021, $P9020
    nqp_get_sc_object $P9022, "1307873293.85412", 379
    $P9021."compose"($P9022)
    nqp_get_sc_object $P9023, "1307873274.8766", 41
    $P9024 = $P9023."new_type"("NQP::Actions" :named("name"))
    nqp_set_sc_for_object $P9024, cur_sc
    nqp_set_sc_object "1307873293.85412", 396, $P9024
    nqp_get_sc_object $P9025, "1307873293.85412", 396
    nqp_get_sc_object $P9026, "1307873293.85412", 0
    nqp_get_package_through_who $P9027, $P9026, "NQP"
    get_who $P9028, $P9027
    set $P9028["Actions"], $P9025
    nqp_get_sc_object $P9029, "1307873293.85412", 396
    get_how $P9030, $P9029
    nqp_get_sc_object $P9031, "1307873293.85412", 396
    .const 'Sub' $P9032 = "465_1307873304.82979" 
    $P9030."add_method"($P9031, "TOP", $P9032)
    nqp_get_sc_object $P9033, "1307873293.85412", 396
    get_how $P9034, $P9033
    nqp_get_sc_object $P9035, "1307873293.85412", 396
    .const 'Sub' $P9036 = "466_1307873304.82979" 
    $P9034."add_method"($P9035, "deflongname", $P9036)
    nqp_get_sc_object $P9037, "1307873293.85412", 396
    get_how $P9038, $P9037
    nqp_get_sc_object $P9039, "1307873293.85412", 396
    .const 'Sub' $P9040 = "467_1307873304.82979" 
    $P9038."add_method"($P9039, "comp_unit", $P9040)
    nqp_get_sc_object $P9041, "1307873293.85412", 396
    get_how $P9042, $P9041
    nqp_get_sc_object $P9043, "1307873293.85412", 396
    .const 'Sub' $P9044 = "469_1307873304.82979" 
    $P9042."add_method"($P9043, "statementlist", $P9044)
    nqp_get_sc_object $P9045, "1307873293.85412", 396
    get_how $P9046, $P9045
    nqp_get_sc_object $P9047, "1307873293.85412", 396
    .const 'Sub' $P9048 = "471_1307873304.82979" 
    $P9046."add_method"($P9047, "statement", $P9048)
    nqp_get_sc_object $P9049, "1307873293.85412", 396
    get_how $P9050, $P9049
    nqp_get_sc_object $P9051, "1307873293.85412", 396
    .const 'Sub' $P9052 = "473_1307873304.82979" 
    $P9050."add_method"($P9051, "xblock", $P9052)
    nqp_get_sc_object $P9053, "1307873293.85412", 396
    get_how $P9054, $P9053
    nqp_get_sc_object $P9055, "1307873293.85412", 396
    .const 'Sub' $P9056 = "474_1307873304.82979" 
    $P9054."add_method"($P9055, "pblock", $P9056)
    nqp_get_sc_object $P9057, "1307873293.85412", 396
    get_how $P9058, $P9057
    nqp_get_sc_object $P9059, "1307873293.85412", 396
    .const 'Sub' $P9060 = "475_1307873304.82979" 
    $P9058."add_method"($P9059, "block", $P9060)
    nqp_get_sc_object $P9061, "1307873293.85412", 396
    get_how $P9062, $P9061
    nqp_get_sc_object $P9063, "1307873293.85412", 396
    .const 'Sub' $P9064 = "476_1307873304.82979" 
    $P9062."add_method"($P9063, "blockoid", $P9064)
    nqp_get_sc_object $P9065, "1307873293.85412", 396
    get_how $P9066, $P9065
    nqp_get_sc_object $P9067, "1307873293.85412", 396
    .const 'Sub' $P9068 = "478_1307873304.82979" 
    $P9066."add_method"($P9067, "newpad", $P9068)
    nqp_get_sc_object $P9069, "1307873293.85412", 396
    get_how $P9070, $P9069
    nqp_get_sc_object $P9071, "1307873293.85412", 396
    .const 'Sub' $P9072 = "479_1307873304.82979" 
    $P9070."add_method"($P9071, "outerctx", $P9072)
    nqp_get_sc_object $P9073, "1307873293.85412", 396
    get_how $P9074, $P9073
    nqp_get_sc_object $P9075, "1307873293.85412", 396
    .const 'Sub' $P9076 = "481_1307873304.82979" 
    $P9074."add_method"($P9075, "GLOBALish", $P9076)
    nqp_get_sc_object $P9077, "1307873293.85412", 396
    get_how $P9078, $P9077
    nqp_get_sc_object $P9079, "1307873293.85412", 396
    .const 'Sub' $P9080 = "482_1307873304.82979" 
    $P9078."add_method"($P9079, "you_are_here", $P9080)
    nqp_get_sc_object $P9081, "1307873293.85412", 396
    get_how $P9082, $P9081
    nqp_get_sc_object $P9083, "1307873293.85412", 396
    .const 'Sub' $P9084 = "483_1307873304.82979" 
    $P9082."add_method"($P9083, "statement_control:sym<use>", $P9084)
    nqp_get_sc_object $P9085, "1307873293.85412", 396
    get_how $P9086, $P9085
    nqp_get_sc_object $P9087, "1307873293.85412", 396
    .const 'Sub' $P9088 = "484_1307873304.82979" 
    $P9086."add_method"($P9087, "statement_control:sym<if>", $P9088)
    nqp_get_sc_object $P9089, "1307873293.85412", 396
    get_how $P9090, $P9089
    nqp_get_sc_object $P9091, "1307873293.85412", 396
    .const 'Sub' $P9092 = "486_1307873304.82979" 
    $P9090."add_method"($P9091, "statement_control:sym<unless>", $P9092)
    nqp_get_sc_object $P9093, "1307873293.85412", 396
    get_how $P9094, $P9093
    nqp_get_sc_object $P9095, "1307873293.85412", 396
    .const 'Sub' $P9096 = "487_1307873304.82979" 
    $P9094."add_method"($P9095, "statement_control:sym<while>", $P9096)
    nqp_get_sc_object $P9097, "1307873293.85412", 396
    get_how $P9098, $P9097
    nqp_get_sc_object $P9099, "1307873293.85412", 396
    .const 'Sub' $P9100 = "488_1307873304.82979" 
    $P9098."add_method"($P9099, "statement_control:sym<repeat>", $P9100)
    nqp_get_sc_object $P9101, "1307873293.85412", 396
    get_how $P9102, $P9101
    nqp_get_sc_object $P9103, "1307873293.85412", 396
    .const 'Sub' $P9104 = "489_1307873304.82979" 
    $P9102."add_method"($P9103, "statement_control:sym<for>", $P9104)
    nqp_get_sc_object $P9105, "1307873293.85412", 396
    get_how $P9106, $P9105
    nqp_get_sc_object $P9107, "1307873293.85412", 396
    .const 'Sub' $P9108 = "490_1307873304.82979" 
    $P9106."add_method"($P9107, "statement_control:sym<CATCH>", $P9108)
    nqp_get_sc_object $P9109, "1307873293.85412", 396
    get_how $P9110, $P9109
    nqp_get_sc_object $P9111, "1307873293.85412", 396
    .const 'Sub' $P9112 = "491_1307873304.82979" 
    $P9110."add_method"($P9111, "statement_control:sym<CONTROL>", $P9112)
    nqp_get_sc_object $P9113, "1307873293.85412", 396
    get_how $P9114, $P9113
    nqp_get_sc_object $P9115, "1307873293.85412", 396
    .const 'Sub' $P9116 = "492_1307873304.82979" 
    $P9114."add_method"($P9115, "statement_prefix:sym<INIT>", $P9116)
    nqp_get_sc_object $P9117, "1307873293.85412", 396
    get_how $P9118, $P9117
    nqp_get_sc_object $P9119, "1307873293.85412", 396
    .const 'Sub' $P9120 = "493_1307873304.82979" 
    $P9118."add_method"($P9119, "statement_prefix:sym<try>", $P9120)
    nqp_get_sc_object $P9121, "1307873293.85412", 396
    get_how $P9122, $P9121
    nqp_get_sc_object $P9123, "1307873293.85412", 396
    .const 'Sub' $P9124 = "494_1307873304.82979" 
    $P9122."add_method"($P9123, "blorst", $P9124)
    nqp_get_sc_object $P9125, "1307873293.85412", 396
    get_how $P9126, $P9125
    nqp_get_sc_object $P9127, "1307873293.85412", 396
    .const 'Sub' $P9128 = "495_1307873304.82979" 
    $P9126."add_method"($P9127, "statement_mod_cond:sym<if>", $P9128)
    nqp_get_sc_object $P9129, "1307873293.85412", 396
    get_how $P9130, $P9129
    nqp_get_sc_object $P9131, "1307873293.85412", 396
    .const 'Sub' $P9132 = "496_1307873304.82979" 
    $P9130."add_method"($P9131, "statement_mod_cond:sym<unless>", $P9132)
    nqp_get_sc_object $P9133, "1307873293.85412", 396
    get_how $P9134, $P9133
    nqp_get_sc_object $P9135, "1307873293.85412", 396
    .const 'Sub' $P9136 = "497_1307873304.82979" 
    $P9134."add_method"($P9135, "statement_mod_loop:sym<while>", $P9136)
    nqp_get_sc_object $P9137, "1307873293.85412", 396
    get_how $P9138, $P9137
    nqp_get_sc_object $P9139, "1307873293.85412", 396
    .const 'Sub' $P9140 = "498_1307873304.82979" 
    $P9138."add_method"($P9139, "statement_mod_loop:sym<until>", $P9140)
    nqp_get_sc_object $P9141, "1307873293.85412", 396
    get_how $P9142, $P9141
    nqp_get_sc_object $P9143, "1307873293.85412", 396
    .const 'Sub' $P9144 = "499_1307873304.82979" 
    $P9142."add_method"($P9143, "term:sym<fatarrow>", $P9144)
    nqp_get_sc_object $P9145, "1307873293.85412", 396
    get_how $P9146, $P9145
    nqp_get_sc_object $P9147, "1307873293.85412", 396
    .const 'Sub' $P9148 = "500_1307873304.82979" 
    $P9146."add_method"($P9147, "term:sym<colonpair>", $P9148)
    nqp_get_sc_object $P9149, "1307873293.85412", 396
    get_how $P9150, $P9149
    nqp_get_sc_object $P9151, "1307873293.85412", 396
    .const 'Sub' $P9152 = "501_1307873304.82979" 
    $P9150."add_method"($P9151, "term:sym<variable>", $P9152)
    nqp_get_sc_object $P9153, "1307873293.85412", 396
    get_how $P9154, $P9153
    nqp_get_sc_object $P9155, "1307873293.85412", 396
    .const 'Sub' $P9156 = "502_1307873304.82979" 
    $P9154."add_method"($P9155, "term:sym<package_declarator>", $P9156)
    nqp_get_sc_object $P9157, "1307873293.85412", 396
    get_how $P9158, $P9157
    nqp_get_sc_object $P9159, "1307873293.85412", 396
    .const 'Sub' $P9160 = "503_1307873304.82979" 
    $P9158."add_method"($P9159, "term:sym<scope_declarator>", $P9160)
    nqp_get_sc_object $P9161, "1307873293.85412", 396
    get_how $P9162, $P9161
    nqp_get_sc_object $P9163, "1307873293.85412", 396
    .const 'Sub' $P9164 = "504_1307873304.82979" 
    $P9162."add_method"($P9163, "term:sym<routine_declarator>", $P9164)
    nqp_get_sc_object $P9165, "1307873293.85412", 396
    get_how $P9166, $P9165
    nqp_get_sc_object $P9167, "1307873293.85412", 396
    .const 'Sub' $P9168 = "505_1307873304.82979" 
    $P9166."add_method"($P9167, "term:sym<regex_declarator>", $P9168)
    nqp_get_sc_object $P9169, "1307873293.85412", 396
    get_how $P9170, $P9169
    nqp_get_sc_object $P9171, "1307873293.85412", 396
    .const 'Sub' $P9172 = "506_1307873304.82979" 
    $P9170."add_method"($P9171, "term:sym<statement_prefix>", $P9172)
    nqp_get_sc_object $P9173, "1307873293.85412", 396
    get_how $P9174, $P9173
    nqp_get_sc_object $P9175, "1307873293.85412", 396
    .const 'Sub' $P9176 = "507_1307873304.82979" 
    $P9174."add_method"($P9175, "term:sym<lambda>", $P9176)
    nqp_get_sc_object $P9177, "1307873293.85412", 396
    get_how $P9178, $P9177
    nqp_get_sc_object $P9179, "1307873293.85412", 396
    .const 'Sub' $P9180 = "508_1307873304.82979" 
    $P9178."add_method"($P9179, "fatarrow", $P9180)
    nqp_get_sc_object $P9181, "1307873293.85412", 396
    get_how $P9182, $P9181
    nqp_get_sc_object $P9183, "1307873293.85412", 396
    .const 'Sub' $P9184 = "509_1307873304.82979" 
    $P9182."add_method"($P9183, "colonpair", $P9184)
    nqp_get_sc_object $P9185, "1307873293.85412", 396
    get_how $P9186, $P9185
    nqp_get_sc_object $P9187, "1307873293.85412", 396
    .const 'Sub' $P9188 = "510_1307873304.82979" 
    $P9186."add_method"($P9187, "variable", $P9188)
    nqp_get_sc_object $P9189, "1307873293.85412", 396
    get_how $P9190, $P9189
    nqp_get_sc_object $P9191, "1307873293.85412", 396
    .const 'Sub' $P9192 = "516_1307873304.82979" 
    $P9190."add_method"($P9191, "package_declarator:sym<module>", $P9192)
    nqp_get_sc_object $P9193, "1307873293.85412", 396
    get_how $P9194, $P9193
    nqp_get_sc_object $P9195, "1307873293.85412", 396
    .const 'Sub' $P9196 = "517_1307873304.82979" 
    $P9194."add_method"($P9195, "package_declarator:sym<knowhow>", $P9196)
    nqp_get_sc_object $P9197, "1307873293.85412", 396
    get_how $P9198, $P9197
    nqp_get_sc_object $P9199, "1307873293.85412", 396
    .const 'Sub' $P9200 = "518_1307873304.82979" 
    $P9198."add_method"($P9199, "package_declarator:sym<class>", $P9200)
    nqp_get_sc_object $P9201, "1307873293.85412", 396
    get_how $P9202, $P9201
    nqp_get_sc_object $P9203, "1307873293.85412", 396
    .const 'Sub' $P9204 = "519_1307873304.82979" 
    $P9202."add_method"($P9203, "package_declarator:sym<grammar>", $P9204)
    nqp_get_sc_object $P9205, "1307873293.85412", 396
    get_how $P9206, $P9205
    nqp_get_sc_object $P9207, "1307873293.85412", 396
    .const 'Sub' $P9208 = "520_1307873304.82979" 
    $P9206."add_method"($P9207, "package_declarator:sym<role>", $P9208)
    nqp_get_sc_object $P9209, "1307873293.85412", 396
    get_how $P9210, $P9209
    nqp_get_sc_object $P9211, "1307873293.85412", 396
    .const 'Sub' $P9212 = "521_1307873304.82979" 
    $P9210."add_method"($P9211, "package_declarator:sym<native>", $P9212)
    nqp_get_sc_object $P9213, "1307873293.85412", 396
    get_how $P9214, $P9213
    nqp_get_sc_object $P9215, "1307873293.85412", 396
    .const 'Sub' $P9216 = "522_1307873304.82979" 
    $P9214."add_method"($P9215, "package_declarator:sym<stub>", $P9216)
    nqp_get_sc_object $P9217, "1307873293.85412", 396
    get_how $P9218, $P9217
    nqp_get_sc_object $P9219, "1307873293.85412", 396
    .const 'Sub' $P9220 = "523_1307873304.82979" 
    $P9218."add_method"($P9219, "package_def", $P9220)
    nqp_get_sc_object $P9221, "1307873293.85412", 396
    get_how $P9222, $P9221
    nqp_get_sc_object $P9223, "1307873293.85412", 396
    .const 'Sub' $P9224 = "529_1307873304.82979" 
    $P9222."add_method"($P9223, "scope_declarator:sym<my>", $P9224)
    nqp_get_sc_object $P9225, "1307873293.85412", 396
    get_how $P9226, $P9225
    nqp_get_sc_object $P9227, "1307873293.85412", 396
    .const 'Sub' $P9228 = "530_1307873304.82979" 
    $P9226."add_method"($P9227, "scope_declarator:sym<our>", $P9228)
    nqp_get_sc_object $P9229, "1307873293.85412", 396
    get_how $P9230, $P9229
    nqp_get_sc_object $P9231, "1307873293.85412", 396
    .const 'Sub' $P9232 = "531_1307873304.82979" 
    $P9230."add_method"($P9231, "scope_declarator:sym<has>", $P9232)
    nqp_get_sc_object $P9233, "1307873293.85412", 396
    get_how $P9234, $P9233
    nqp_get_sc_object $P9235, "1307873293.85412", 396
    .const 'Sub' $P9236 = "532_1307873304.82979" 
    $P9234."add_method"($P9235, "scoped", $P9236)
    nqp_get_sc_object $P9237, "1307873293.85412", 396
    get_how $P9238, $P9237
    nqp_get_sc_object $P9239, "1307873293.85412", 396
    .const 'Sub' $P9240 = "533_1307873304.82979" 
    $P9238."add_method"($P9239, "declarator", $P9240)
    nqp_get_sc_object $P9241, "1307873293.85412", 396
    get_how $P9242, $P9241
    nqp_get_sc_object $P9243, "1307873293.85412", 396
    .const 'Sub' $P9244 = "534_1307873304.82979" 
    $P9242."add_method"($P9243, "multi_declarator:sym<multi>", $P9244)
    nqp_get_sc_object $P9245, "1307873293.85412", 396
    get_how $P9246, $P9245
    nqp_get_sc_object $P9247, "1307873293.85412", 396
    .const 'Sub' $P9248 = "535_1307873304.82979" 
    $P9246."add_method"($P9247, "multi_declarator:sym<proto>", $P9248)
    nqp_get_sc_object $P9249, "1307873293.85412", 396
    get_how $P9250, $P9249
    nqp_get_sc_object $P9251, "1307873293.85412", 396
    .const 'Sub' $P9252 = "536_1307873304.82979" 
    $P9250."add_method"($P9251, "multi_declarator:sym<null>", $P9252)
    nqp_get_sc_object $P9253, "1307873293.85412", 396
    get_how $P9254, $P9253
    nqp_get_sc_object $P9255, "1307873293.85412", 396
    .const 'Sub' $P9256 = "537_1307873304.82979" 
    $P9254."add_method"($P9255, "variable_declarator", $P9256)
    nqp_get_sc_object $P9257, "1307873293.85412", 396
    get_how $P9258, $P9257
    nqp_get_sc_object $P9259, "1307873293.85412", 396
    .const 'Sub' $P9260 = "540_1307873304.82979" 
    $P9258."add_method"($P9259, "routine_declarator:sym<sub>", $P9260)
    nqp_get_sc_object $P9261, "1307873293.85412", 396
    get_how $P9262, $P9261
    nqp_get_sc_object $P9263, "1307873293.85412", 396
    .const 'Sub' $P9264 = "541_1307873304.82979" 
    $P9262."add_method"($P9263, "routine_declarator:sym<method>", $P9264)
    nqp_get_sc_object $P9265, "1307873293.85412", 396
    get_how $P9266, $P9265
    nqp_get_sc_object $P9267, "1307873293.85412", 396
    .const 'Sub' $P9268 = "542_1307873304.82979" 
    $P9266."add_method"($P9267, "routine_def", $P9268)
    nqp_get_sc_object $P9269, "1307873293.85412", 396
    get_how $P9270, $P9269
    nqp_get_sc_object $P9271, "1307873293.85412", 396
    .const 'Sub' $P9272 = "549_1307873304.82979" 
    $P9270."add_method"($P9271, "method_def", $P9272)
    nqp_get_sc_object $P9273, "1307873293.85412", 396
    get_how $P9274, $P9273
    nqp_get_sc_object $P9275, "1307873293.85412", 396
    .const 'Sub' $P9276 = "552_1307873304.82979" 
    $P9274."add_method"($P9275, "signature", $P9276)
    nqp_get_sc_object $P9277, "1307873293.85412", 396
    get_how $P9278, $P9277
    nqp_get_sc_object $P9279, "1307873293.85412", 396
    .const 'Sub' $P9280 = "555_1307873304.82979" 
    $P9278."add_method"($P9279, "parameter", $P9280)
    nqp_get_sc_object $P9281, "1307873293.85412", 396
    get_how $P9282, $P9281
    nqp_get_sc_object $P9283, "1307873293.85412", 396
    .const 'Sub' $P9284 = "556_1307873304.82979" 
    $P9282."add_method"($P9283, "param_var", $P9284)
    nqp_get_sc_object $P9285, "1307873293.85412", 396
    get_how $P9286, $P9285
    nqp_get_sc_object $P9287, "1307873293.85412", 396
    .const 'Sub' $P9288 = "557_1307873304.82979" 
    $P9286."add_method"($P9287, "named_param", $P9288)
    nqp_get_sc_object $P9289, "1307873293.85412", 396
    get_how $P9290, $P9289
    nqp_get_sc_object $P9291, "1307873293.85412", 396
    .const 'Sub' $P9292 = "558_1307873304.82979" 
    $P9290."add_method"($P9291, "typename", $P9292)
    nqp_get_sc_object $P9293, "1307873293.85412", 396
    get_how $P9294, $P9293
    nqp_get_sc_object $P9295, "1307873293.85412", 396
    .const 'Sub' $P9296 = "560_1307873304.82979" 
    $P9294."add_method"($P9295, "trait", $P9296)
    nqp_get_sc_object $P9297, "1307873293.85412", 396
    get_how $P9298, $P9297
    nqp_get_sc_object $P9299, "1307873293.85412", 396
    .const 'Sub' $P9300 = "561_1307873304.82979" 
    $P9298."add_method"($P9299, "trait_mod:sym<is>", $P9300)
    nqp_get_sc_object $P9301, "1307873293.85412", 396
    get_how $P9302, $P9301
    nqp_get_sc_object $P9303, "1307873293.85412", 396
    .const 'Sub' $P9304 = "566_1307873304.82979" 
    $P9302."add_method"($P9303, "regex_declarator", $P9304)
    nqp_get_sc_object $P9305, "1307873293.85412", 396
    get_how $P9306, $P9305
    nqp_get_sc_object $P9307, "1307873293.85412", 396
    .const 'Sub' $P9308 = "571_1307873304.82979" 
    $P9306."add_method"($P9307, "dotty", $P9308)
    nqp_get_sc_object $P9309, "1307873293.85412", 396
    get_how $P9310, $P9309
    nqp_get_sc_object $P9311, "1307873293.85412", 396
    .const 'Sub' $P9312 = "572_1307873304.82979" 
    $P9310."add_method"($P9311, "term:sym<self>", $P9312)
    nqp_get_sc_object $P9313, "1307873293.85412", 396
    get_how $P9314, $P9313
    nqp_get_sc_object $P9315, "1307873293.85412", 396
    .const 'Sub' $P9316 = "573_1307873304.82979" 
    $P9314."add_method"($P9315, "term:sym<identifier>", $P9316)
    nqp_get_sc_object $P9317, "1307873293.85412", 396
    get_how $P9318, $P9317
    nqp_get_sc_object $P9319, "1307873293.85412", 396
    .const 'Sub' $P9320 = "574_1307873304.82979" 
    $P9318."add_method"($P9319, "term:sym<name>", $P9320)
    nqp_get_sc_object $P9321, "1307873293.85412", 396
    get_how $P9322, $P9321
    nqp_get_sc_object $P9323, "1307873293.85412", 396
    .const 'Sub' $P9324 = "576_1307873304.82979" 
    $P9322."add_method"($P9323, "term:sym<pir::op>", $P9324)
    nqp_get_sc_object $P9325, "1307873293.85412", 396
    get_how $P9326, $P9325
    nqp_get_sc_object $P9327, "1307873293.85412", 396
    .const 'Sub' $P9328 = "577_1307873304.82979" 
    $P9326."add_method"($P9327, "term:sym<pir::const>", $P9328)
    nqp_get_sc_object $P9329, "1307873293.85412", 396
    get_how $P9330, $P9329
    nqp_get_sc_object $P9331, "1307873293.85412", 396
    .const 'Sub' $P9332 = "578_1307873304.82979" 
    $P9330."add_method"($P9331, "term:sym<onlystar>", $P9332)
    nqp_get_sc_object $P9333, "1307873293.85412", 396
    get_how $P9334, $P9333
    nqp_get_sc_object $P9335, "1307873293.85412", 396
    .const 'Sub' $P9336 = "579_1307873304.82979" 
    $P9334."add_method"($P9335, "args", $P9336)
    nqp_get_sc_object $P9337, "1307873293.85412", 396
    get_how $P9338, $P9337
    nqp_get_sc_object $P9339, "1307873293.85412", 396
    .const 'Sub' $P9340 = "580_1307873304.82979" 
    $P9338."add_method"($P9339, "arglist", $P9340)
    nqp_get_sc_object $P9341, "1307873293.85412", 396
    get_how $P9342, $P9341
    nqp_get_sc_object $P9343, "1307873293.85412", 396
    .const 'Sub' $P9344 = "583_1307873304.82979" 
    $P9342."add_method"($P9343, "term:sym<multi_declarator>", $P9344)
    nqp_get_sc_object $P9345, "1307873293.85412", 396
    get_how $P9346, $P9345
    nqp_get_sc_object $P9347, "1307873293.85412", 396
    .const 'Sub' $P9348 = "584_1307873304.82979" 
    $P9346."add_method"($P9347, "term:sym<value>", $P9348)
    nqp_get_sc_object $P9349, "1307873293.85412", 396
    get_how $P9350, $P9349
    nqp_get_sc_object $P9351, "1307873293.85412", 396
    .const 'Sub' $P9352 = "585_1307873304.82979" 
    $P9350."add_method"($P9351, "circumfix:sym<( )>", $P9352)
    nqp_get_sc_object $P9353, "1307873293.85412", 396
    get_how $P9354, $P9353
    nqp_get_sc_object $P9355, "1307873293.85412", 396
    .const 'Sub' $P9356 = "586_1307873304.82979" 
    $P9354."add_method"($P9355, "circumfix:sym<[ ]>", $P9356)
    nqp_get_sc_object $P9357, "1307873293.85412", 396
    get_how $P9358, $P9357
    nqp_get_sc_object $P9359, "1307873293.85412", 396
    .const 'Sub' $P9360 = "587_1307873304.82979" 
    $P9358."add_method"($P9359, "circumfix:sym<ang>", $P9360)
    nqp_get_sc_object $P9361, "1307873293.85412", 396
    get_how $P9362, $P9361
    nqp_get_sc_object $P9363, "1307873293.85412", 396
    .const 'Sub' $P9364 = "588_1307873304.82979" 
    $P9362."add_method"($P9363, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P9364)
    nqp_get_sc_object $P9365, "1307873293.85412", 396
    get_how $P9366, $P9365
    nqp_get_sc_object $P9367, "1307873293.85412", 396
    .const 'Sub' $P9368 = "589_1307873304.82979" 
    $P9366."add_method"($P9367, "circumfix:sym<{ }>", $P9368)
    nqp_get_sc_object $P9369, "1307873293.85412", 396
    get_how $P9370, $P9369
    nqp_get_sc_object $P9371, "1307873293.85412", 396
    .const 'Sub' $P9372 = "591_1307873304.82979" 
    $P9370."add_method"($P9371, "circumfix:sym<sigil>", $P9372)
    nqp_get_sc_object $P9373, "1307873293.85412", 396
    get_how $P9374, $P9373
    nqp_get_sc_object $P9375, "1307873293.85412", 396
    .const 'Sub' $P9376 = "592_1307873304.82979" 
    $P9374."add_method"($P9375, "semilist", $P9376)
    nqp_get_sc_object $P9377, "1307873293.85412", 396
    get_how $P9378, $P9377
    nqp_get_sc_object $P9379, "1307873293.85412", 396
    .const 'Sub' $P9380 = "593_1307873304.82979" 
    $P9378."add_method"($P9379, "postcircumfix:sym<[ ]>", $P9380)
    nqp_get_sc_object $P9381, "1307873293.85412", 396
    get_how $P9382, $P9381
    nqp_get_sc_object $P9383, "1307873293.85412", 396
    .const 'Sub' $P9384 = "594_1307873304.82979" 
    $P9382."add_method"($P9383, "postcircumfix:sym<{ }>", $P9384)
    nqp_get_sc_object $P9385, "1307873293.85412", 396
    get_how $P9386, $P9385
    nqp_get_sc_object $P9387, "1307873293.85412", 396
    .const 'Sub' $P9388 = "595_1307873304.82979" 
    $P9386."add_method"($P9387, "postcircumfix:sym<ang>", $P9388)
    nqp_get_sc_object $P9389, "1307873293.85412", 396
    get_how $P9390, $P9389
    nqp_get_sc_object $P9391, "1307873293.85412", 396
    .const 'Sub' $P9392 = "596_1307873304.82979" 
    $P9390."add_method"($P9391, "postcircumfix:sym<( )>", $P9392)
    nqp_get_sc_object $P9393, "1307873293.85412", 396
    get_how $P9394, $P9393
    nqp_get_sc_object $P9395, "1307873293.85412", 396
    .const 'Sub' $P9396 = "597_1307873304.82979" 
    $P9394."add_method"($P9395, "value", $P9396)
    nqp_get_sc_object $P9397, "1307873293.85412", 396
    get_how $P9398, $P9397
    nqp_get_sc_object $P9399, "1307873293.85412", 396
    .const 'Sub' $P9400 = "598_1307873304.82979" 
    $P9398."add_method"($P9399, "number", $P9400)
    nqp_get_sc_object $P9401, "1307873293.85412", 396
    get_how $P9402, $P9401
    nqp_get_sc_object $P9403, "1307873293.85412", 396
    .const 'Sub' $P9404 = "599_1307873304.82979" 
    $P9402."add_method"($P9403, "quote:sym<apos>", $P9404)
    nqp_get_sc_object $P9405, "1307873293.85412", 396
    get_how $P9406, $P9405
    nqp_get_sc_object $P9407, "1307873293.85412", 396
    .const 'Sub' $P9408 = "600_1307873304.82979" 
    $P9406."add_method"($P9407, "quote:sym<dblq>", $P9408)
    nqp_get_sc_object $P9409, "1307873293.85412", 396
    get_how $P9410, $P9409
    nqp_get_sc_object $P9411, "1307873293.85412", 396
    .const 'Sub' $P9412 = "601_1307873304.82979" 
    $P9410."add_method"($P9411, "quote:sym<qq>", $P9412)
    nqp_get_sc_object $P9413, "1307873293.85412", 396
    get_how $P9414, $P9413
    nqp_get_sc_object $P9415, "1307873293.85412", 396
    .const 'Sub' $P9416 = "602_1307873304.82979" 
    $P9414."add_method"($P9415, "quote:sym<q>", $P9416)
    nqp_get_sc_object $P9417, "1307873293.85412", 396
    get_how $P9418, $P9417
    nqp_get_sc_object $P9419, "1307873293.85412", 396
    .const 'Sub' $P9420 = "603_1307873304.82979" 
    $P9418."add_method"($P9419, "quote:sym<Q>", $P9420)
    nqp_get_sc_object $P9421, "1307873293.85412", 396
    get_how $P9422, $P9421
    nqp_get_sc_object $P9423, "1307873293.85412", 396
    .const 'Sub' $P9424 = "604_1307873304.82979" 
    $P9422."add_method"($P9423, "quote:sym<Q:PIR>", $P9424)
    nqp_get_sc_object $P9425, "1307873293.85412", 396
    get_how $P9426, $P9425
    nqp_get_sc_object $P9427, "1307873293.85412", 396
    .const 'Sub' $P9428 = "605_1307873304.82979" 
    $P9426."add_method"($P9427, "quote:sym</ />", $P9428)
    nqp_get_sc_object $P9429, "1307873293.85412", 396
    get_how $P9430, $P9429
    nqp_get_sc_object $P9431, "1307873293.85412", 396
    .const 'Sub' $P9432 = "606_1307873304.82979" 
    $P9430."add_method"($P9431, "quote_escape:sym<$>", $P9432)
    nqp_get_sc_object $P9433, "1307873293.85412", 396
    get_how $P9434, $P9433
    nqp_get_sc_object $P9435, "1307873293.85412", 396
    .const 'Sub' $P9436 = "607_1307873304.82979" 
    $P9434."add_method"($P9435, "quote_escape:sym<{ }>", $P9436)
    nqp_get_sc_object $P9437, "1307873293.85412", 396
    get_how $P9438, $P9437
    nqp_get_sc_object $P9439, "1307873293.85412", 396
    .const 'Sub' $P9440 = "608_1307873304.82979" 
    $P9438."add_method"($P9439, "quote_escape:sym<esc>", $P9440)
    nqp_get_sc_object $P9441, "1307873293.85412", 396
    get_how $P9442, $P9441
    nqp_get_sc_object $P9443, "1307873293.85412", 396
    .const 'Sub' $P9444 = "609_1307873304.82979" 
    $P9442."add_method"($P9443, "postfix:sym<.>", $P9444)
    nqp_get_sc_object $P9445, "1307873293.85412", 396
    get_how $P9446, $P9445
    nqp_get_sc_object $P9447, "1307873293.85412", 396
    .const 'Sub' $P9448 = "610_1307873304.82979" 
    $P9446."add_method"($P9447, "postfix:sym<++>", $P9448)
    nqp_get_sc_object $P9449, "1307873293.85412", 396
    get_how $P9450, $P9449
    nqp_get_sc_object $P9451, "1307873293.85412", 396
    .const 'Sub' $P9452 = "611_1307873304.82979" 
    $P9450."add_method"($P9451, "postfix:sym<-->", $P9452)
    nqp_get_sc_object $P9453, "1307873293.85412", 396
    get_how $P9454, $P9453
    nqp_get_sc_object $P9455, "1307873293.85412", 396
    .const 'Sub' $P9456 = "612_1307873304.82979" 
    $P9454."add_method"($P9455, "prefix:sym<make>", $P9456)
    nqp_get_sc_object $P9457, "1307873293.85412", 396
    get_how $P9458, $P9457
    nqp_get_sc_object $P9459, "1307873293.85412", 396
    .const 'Sub' $P9460 = "613_1307873304.82979" 
    $P9458."add_method"($P9459, "term:sym<next>", $P9460)
    nqp_get_sc_object $P9461, "1307873293.85412", 396
    get_how $P9462, $P9461
    nqp_get_sc_object $P9463, "1307873293.85412", 396
    .const 'Sub' $P9464 = "614_1307873304.82979" 
    $P9462."add_method"($P9463, "term:sym<last>", $P9464)
    nqp_get_sc_object $P9465, "1307873293.85412", 396
    get_how $P9466, $P9465
    nqp_get_sc_object $P9467, "1307873293.85412", 396
    .const 'Sub' $P9468 = "615_1307873304.82979" 
    $P9466."add_method"($P9467, "term:sym<redo>", $P9468)
    nqp_get_sc_object $P9469, "1307873293.85412", 396
    get_how $P9470, $P9469
    nqp_get_sc_object $P9471, "1307873293.85412", 396
    .const 'Sub' $P9472 = "616_1307873304.82979" 
    $P9470."add_method"($P9471, "infix:sym<~~>", $P9472)
    nqp_get_sc_object $P9473, "1307873293.85412", 396
    get_how $P9474, $P9473
    nqp_get_sc_object $P9475, "1307873293.85412", 396
    .const 'Sub' $P9476 = "617_1307873304.82979" 
    $P9474."add_method"($P9475, "known_sym", $P9476)
    .const 'Sub' $P9477 = "438_1307873304.82979" 
    $P9478 = $P9477."get_lexinfo"()
    nqp_get_sc_object $P9479, "1307873293.85412", 396
    $P9478."set_static_lexpad_value"("$?PACKAGE", $P9479)
    .const 'Sub' $P9480 = "438_1307873304.82979" 
    $P9481 = $P9480."get_lexinfo"()
    $P9481."finish_static_lexpad"()
    .const 'Sub' $P9482 = "438_1307873304.82979" 
    $P9483 = $P9482."get_lexinfo"()
    nqp_get_sc_object $P9484, "1307873293.85412", 396
    $P9483."set_static_lexpad_value"("$?CLASS", $P9484)
    .const 'Sub' $P9485 = "438_1307873304.82979" 
    $P9486 = $P9485."get_lexinfo"()
    $P9486."finish_static_lexpad"()
    nqp_get_sc_object $P9487, "1307873293.85412", 396
    get_how $P9488, $P9487
    nqp_get_sc_object $P9489, "1307873293.85412", 396
    nqp_get_sc_object $P9490, "1307873280.77112", 105
    $P9488."add_parent"($P9489, $P9490)
    nqp_get_sc_object $P9491, "1307873293.85412", 396
    get_how $P9492, $P9491
    nqp_get_sc_object $P9493, "1307873293.85412", 396
    $P9492."compose"($P9493)
    nqp_get_sc_object $P9494, "1307873274.8766", 41
    $P9495 = $P9494."new_type"("NQP::RegexActions" :named("name"))
    nqp_set_sc_for_object $P9495, cur_sc
    nqp_set_sc_object "1307873293.85412", 509, $P9495
    nqp_get_sc_object $P9496, "1307873293.85412", 509
    nqp_get_sc_object $P9497, "1307873293.85412", 0
    nqp_get_package_through_who $P9498, $P9497, "NQP"
    get_who $P9499, $P9498
    set $P9499["RegexActions"], $P9496
    nqp_get_sc_object $P9500, "1307873293.85412", 509
    get_how $P9501, $P9500
    nqp_get_sc_object $P9502, "1307873293.85412", 509
    .const 'Sub' $P9503 = "620_1307873304.82979" 
    $P9501."add_method"($P9502, "metachar:sym<:my>", $P9503)
    nqp_get_sc_object $P9504, "1307873293.85412", 509
    get_how $P9505, $P9504
    nqp_get_sc_object $P9506, "1307873293.85412", 509
    .const 'Sub' $P9507 = "621_1307873304.82979" 
    $P9505."add_method"($P9506, "metachar:sym<{ }>", $P9507)
    nqp_get_sc_object $P9508, "1307873293.85412", 509
    get_how $P9509, $P9508
    nqp_get_sc_object $P9510, "1307873293.85412", 509
    .const 'Sub' $P9511 = "622_1307873304.82979" 
    $P9509."add_method"($P9510, "metachar:sym<nqpvar>", $P9511)
    nqp_get_sc_object $P9512, "1307873293.85412", 509
    get_how $P9513, $P9512
    nqp_get_sc_object $P9514, "1307873293.85412", 509
    .const 'Sub' $P9515 = "623_1307873304.82979" 
    $P9513."add_method"($P9514, "assertion:sym<{ }>", $P9515)
    nqp_get_sc_object $P9516, "1307873293.85412", 509
    get_how $P9517, $P9516
    nqp_get_sc_object $P9518, "1307873293.85412", 509
    .const 'Sub' $P9519 = "624_1307873304.82979" 
    $P9517."add_method"($P9518, "assertion:sym<?{ }>", $P9519)
    nqp_get_sc_object $P9520, "1307873293.85412", 509
    get_how $P9521, $P9520
    nqp_get_sc_object $P9522, "1307873293.85412", 509
    .const 'Sub' $P9523 = "625_1307873304.82979" 
    $P9521."add_method"($P9522, "assertion:sym<var>", $P9523)
    nqp_get_sc_object $P9524, "1307873293.85412", 509
    get_how $P9525, $P9524
    nqp_get_sc_object $P9526, "1307873293.85412", 509
    .const 'Sub' $P9527 = "626_1307873304.82979" 
    $P9525."add_method"($P9526, "codeblock", $P9527)
    .const 'Sub' $P9528 = "619_1307873304.82979" 
    $P9529 = $P9528."get_lexinfo"()
    nqp_get_sc_object $P9530, "1307873293.85412", 509
    $P9529."set_static_lexpad_value"("$?PACKAGE", $P9530)
    .const 'Sub' $P9531 = "619_1307873304.82979" 
    $P9532 = $P9531."get_lexinfo"()
    $P9532."finish_static_lexpad"()
    .const 'Sub' $P9533 = "619_1307873304.82979" 
    $P9534 = $P9533."get_lexinfo"()
    nqp_get_sc_object $P9535, "1307873293.85412", 509
    $P9534."set_static_lexpad_value"("$?CLASS", $P9535)
    .const 'Sub' $P9536 = "619_1307873304.82979" 
    $P9537 = $P9536."get_lexinfo"()
    $P9537."finish_static_lexpad"()
    nqp_get_sc_object $P9538, "1307873293.85412", 509
    get_how $P9539, $P9538
    nqp_get_sc_object $P9540, "1307873293.85412", 509
    nqp_get_sc_object $P9541, "1307873288.51323", 145
    $P9539."add_parent"($P9540, $P9541)
    nqp_get_sc_object $P9542, "1307873293.85412", 509
    get_how $P9543, $P9542
    nqp_get_sc_object $P9544, "1307873293.85412", 509
    $P9543."compose"($P9544)
    nqp_get_sc_object $P9545, "1307873274.8766", 41
    $P9546 = $P9545."new_type"("NQP::Compiler" :named("name"))
    nqp_set_sc_for_object $P9546, cur_sc
    nqp_set_sc_object "1307873293.85412", 517, $P9546
    nqp_get_sc_object $P9547, "1307873293.85412", 517
    nqp_get_sc_object $P9548, "1307873293.85412", 0
    nqp_get_package_through_who $P9549, $P9548, "NQP"
    get_who $P9550, $P9549
    set $P9550["Compiler"], $P9547
    .const 'Sub' $P9551 = "627_1307873304.82979" 
    $P9552 = $P9551."get_lexinfo"()
    nqp_get_sc_object $P9553, "1307873293.85412", 517
    $P9552."set_static_lexpad_value"("$?PACKAGE", $P9553)
    .const 'Sub' $P9554 = "627_1307873304.82979" 
    $P9555 = $P9554."get_lexinfo"()
    $P9555."finish_static_lexpad"()
    .const 'Sub' $P9556 = "627_1307873304.82979" 
    $P9557 = $P9556."get_lexinfo"()
    nqp_get_sc_object $P9558, "1307873293.85412", 517
    $P9557."set_static_lexpad_value"("$?CLASS", $P9558)
    .const 'Sub' $P9559 = "627_1307873304.82979" 
    $P9560 = $P9559."get_lexinfo"()
    $P9560."finish_static_lexpad"()
    nqp_get_sc_object $P9561, "1307873293.85412", 517
    get_how $P9562, $P9561
    nqp_get_sc_object $P9563, "1307873293.85412", 517
    nqp_get_sc_object $P9564, "1307873280.77112", 138
    $P9562."add_parent"($P9563, $P9564)
    nqp_get_sc_object $P9565, "1307873293.85412", 517
    get_how $P9566, $P9565
    nqp_get_sc_object $P9567, "1307873293.85412", 517
    $P9566."compose"($P9567)
  if_7361_end:
    nqp_get_sc_object $P10660, "1307873293.85412", 0
    set_hll_global "GLOBAL", $P10660
.end


.HLL "nqp"

.namespace []
.sub "MAIN"  :subid("11_1307873304.82979") :outer("10_1307873304.82979")
    .param pmc param_17
.annotate 'line', 2766
    .lex "@ARGS", param_17
.annotate 'line', 2768
    new $P18, "Undef"
    .lex "$nqpcomp", $P18
.annotate 'line', 2775
    $P19 = root_new ['parrot';'ResizablePMCArray']
    .lex "@clo", $P19
.annotate 'line', 2768
    get_hll_global $P20, "GLOBAL"
    nqp_get_package_through_who $P21, $P20, "NQP"
    get_who $P22, $P21
    set $P23, $P22["Compiler"]
    $P24 = $P23."new"()
    store_lex "$nqpcomp", $P24
.annotate 'line', 2769
    find_lex $P25, "$nqpcomp"
    unless_null $P25, vivify_630
    new $P25, "Undef"
  vivify_630:
    $P25."language"("nqp")
.annotate 'line', 2770
    find_lex $P26, "$nqpcomp"
    unless_null $P26, vivify_631
    new $P26, "Undef"
  vivify_631:
    get_hll_global $P27, "GLOBAL"
    nqp_get_package_through_who $P28, $P27, "NQP"
    get_who $P29, $P28
    set $P30, $P29["Grammar"]
    $P26."parsegrammar"($P30)
.annotate 'line', 2771
    find_lex $P31, "$nqpcomp"
    unless_null $P31, vivify_632
    new $P31, "Undef"
  vivify_632:
    get_hll_global $P32, "GLOBAL"
    nqp_get_package_through_who $P33, $P32, "NQP"
    get_who $P34, $P33
    set $P35, $P34["Actions"]
    $P31."parseactions"($P35)
.annotate 'line', 2772
    find_lex $P36, "$nqpcomp"
    unless_null $P36, vivify_633
    new $P36, "Undef"
  vivify_633:
    $P37 = $P36."config"()
    "hll-config"($P37)
.annotate 'line', 2775
    find_lex $P38, "$nqpcomp"
    unless_null $P38, vivify_634
    new $P38, "Undef"
  vivify_634:
    $P39 = $P38."commandline_options"()
    store_lex "@clo", $P39
.annotate 'line', 2776
    find_lex $P40, "@clo"
    unless_null $P40, vivify_635
    $P40 = root_new ['parrot';'ResizablePMCArray']
  vivify_635:
    $P40."push"("parsetrace")
.annotate 'line', 2777
    find_lex $P41, "@clo"
    unless_null $P41, vivify_636
    $P41 = root_new ['parrot';'ResizablePMCArray']
  vivify_636:
    $P41."push"("setting=s")
.annotate 'line', 2778
    find_lex $P42, "@clo"
    unless_null $P42, vivify_637
    $P42 = root_new ['parrot';'ResizablePMCArray']
  vivify_637:
    $P42."push"("setting-path=s")
.annotate 'line', 2779
    find_lex $P43, "@clo"
    unless_null $P43, vivify_638
    $P43 = root_new ['parrot';'ResizablePMCArray']
  vivify_638:
    $P43."push"("module-path=s")
.annotate 'line', 2780
    find_lex $P44, "@clo"
    unless_null $P44, vivify_639
    $P44 = root_new ['parrot';'ResizablePMCArray']
  vivify_639:
    $P44."push"("vmlibs=s")
.annotate 'line', 2783
    find_lex $P45, "$nqpcomp"
    unless_null $P45, vivify_640
    new $P45, "Undef"
  vivify_640:
    find_lex $P46, "@ARGS"
    unless_null $P46, vivify_641
    $P46 = root_new ['parrot';'ResizablePMCArray']
  vivify_641:
    $P47 = $P45."command_line"($P46, "utf8" :named("encoding"), "ascii iso-8859-1" :named("transcode"))
.annotate 'line', 2766
    .return ($P47)
.end


.HLL "nqp"

.namespace []
.sub "hll-config"  :subid("12_1307873304.82979") :outer("10_1307873304.82979")
    .param pmc param_50
.annotate 'line', 2787
    .lex "$config", param_50
.annotate 'line', 2788
    new $P51, "String"
    assign $P51, "2011.05-61-g67d1c79"
    find_lex $P52, "$config"
    unless_null $P52, vivify_642
    $P52 = root_new ['parrot';'Hash']
    store_lex "$config", $P52
  vivify_642:
    set $P52["version"], $P51
.annotate 'line', 2789
    new $P53, "String"
    assign $P53, "2011-06-12T10:08:13Z"
    find_lex $P54, "$config"
    unless_null $P54, vivify_643
    $P54 = root_new ['parrot';'Hash']
    store_lex "$config", $P54
  vivify_643:
    set $P54["build-date"], $P53
.annotate 'line', 2787
    .return ($P53)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block56"  :subid("13_1307873304.82979") :outer("10_1307873304.82979")
.annotate 'line', 9
    .const 'Sub' $P875 = "38_1307873304.82979" 
    capture_lex $P875
    .const 'Sub' $P851 = "37_1307873304.82979" 
    capture_lex $P851
    .const 'Sub' $P821 = "36_1307873304.82979" 
    capture_lex $P821
    .const 'Sub' $P788 = "35_1307873304.82979" 
    capture_lex $P788
    .const 'Sub' $P673 = "30_1307873304.82979" 
    capture_lex $P673
    .const 'Sub' $P626 = "29_1307873304.82979" 
    capture_lex $P626
    .const 'Sub' $P498 = "26_1307873304.82979" 
    capture_lex $P498
    .const 'Sub' $P413 = "23_1307873304.82979" 
    capture_lex $P413
    .const 'Sub' $P336 = "22_1307873304.82979" 
    capture_lex $P336
    .const 'Sub' $P300 = "21_1307873304.82979" 
    capture_lex $P300
    .const 'Sub' $P237 = "20_1307873304.82979" 
    capture_lex $P237
    .const 'Sub' $P161 = "17_1307873304.82979" 
    capture_lex $P161
    .const 'Sub' $P120 = "16_1307873304.82979" 
    capture_lex $P120
    .const 'Sub' $P62 = "14_1307873304.82979" 
    capture_lex $P62
.annotate 'line', 14
    new $P58, "Undef"
    .lex "$loader", $P58
    .lex "$?PACKAGE", $P59
    .lex "$?CLASS", $P60
    get_hll_global $P61, "ModuleLoader"
    store_lex "$loader", $P61
.annotate 'line', 401
    .const 'Sub' $P875 = "38_1307873304.82979" 
    newclosure $P984, $P875
.annotate 'line', 9
    .return ($P984)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.include "except_types.pasm"
.sub "load_setting" :anon :subid("14_1307873304.82979") :outer("13_1307873304.82979")
    .param pmc param_65
    .param pmc param_66
.annotate 'line', 17
    .const 'Sub' $P73 = "15_1307873304.82979" 
    capture_lex $P73
    new $P64, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P64, control_63
    push_eh $P64
    .lex "self", param_65
    .lex "$setting_name", param_66
.annotate 'line', 19
    find_lex $P69, "$setting_name"
    unless_null $P69, vivify_644
    new $P69, "Undef"
  vivify_644:
    set $S70, $P69
    isne $I71, $S70, "NULL"
    if $I71, if_68
    new $P67, 'Integer'
    set $P67, $I71
    goto if_68_end
  if_68:
    .const 'Sub' $P73 = "15_1307873304.82979" 
    capture_lex $P73
    $P118 = $P73()
    set $P67, $P118
  if_68_end:
.annotate 'line', 17
    .return ($P67)
  control_63:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P119, exception, "payload"
    .return ($P119)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.include "except_types.pasm"
.sub "_block72"  :anon :subid("15_1307873304.82979") :outer("14_1307873304.82979")
.annotate 'line', 23
    new $P74, "Undef"
    .lex "$setting", $P74
.annotate 'line', 24
    find_lex $P75, "$loader"
    unless_null $P75, vivify_645
    new $P75, "Undef"
  vivify_645:
    find_lex $P76, "$setting_name"
    unless_null $P76, vivify_646
    new $P76, "Undef"
  vivify_646:
    $P77 = $P75."load_setting"($P76)
    find_dynamic_lex $P80, "%*COMPILING"
    unless_null $P80, vivify_647
    get_hll_global $P78, "GLOBAL"
    get_who $P79, $P78
    set $P80, $P79["%COMPILING"]
    unless_null $P80, vivify_648
    die "Contextual %*COMPILING not found"
  vivify_648:
    store_dynamic_lex "%*COMPILING", $P80
  vivify_647:
    set $P81, $P80["%?OPTIONS"]
    unless_null $P81, vivify_649
    $P81 = root_new ['parrot';'Hash']
    set $P80["%?OPTIONS"], $P81
  vivify_649:
    set $P81["outer_ctx"], $P77
    store_lex "$setting", $P77
.annotate 'line', 27
    find_lex $P82, "self"
    get_hll_global $P83, "GLOBAL"
    nqp_get_package_through_who $P84, $P83, "PAST"
    get_who $P85, $P84
    set $P86, $P85["Stmts"]
.annotate 'line', 28
    get_hll_global $P87, "GLOBAL"
    nqp_get_package_through_who $P88, $P87, "PAST"
    get_who $P89, $P88
    set $P90, $P89["Op"]
    $P91 = $P90."new"("ModuleLoader.pbc", "load_bytecode vs" :named("pirop"))
.annotate 'line', 31
    get_hll_global $P92, "GLOBAL"
    nqp_get_package_through_who $P93, $P92, "PAST"
    get_who $P94, $P93
    set $P95, $P94["Op"]
.annotate 'line', 33
    get_hll_global $P96, "GLOBAL"
    nqp_get_package_through_who $P97, $P96, "PAST"
    get_who $P98, $P97
    set $P99, $P98["Var"]
    $P100 = $P99."new"("block" :named("name"), "register" :named("scope"))
.annotate 'line', 34
    get_hll_global $P101, "GLOBAL"
    nqp_get_package_through_who $P102, $P101, "PAST"
    get_who $P103, $P102
    set $P104, $P103["Op"]
.annotate 'line', 36
    get_hll_global $P105, "GLOBAL"
    nqp_get_package_through_who $P106, $P105, "PAST"
    get_who $P107, $P106
    set $P108, $P107["Var"]
    new $P109, "ResizablePMCArray"
    $P110 = $P108."new"("ModuleLoader" :named("name"), $P109 :named("namespace"), "package" :named("scope"))
    find_lex $P111, "$setting_name"
    unless_null $P111, vivify_650
    new $P111, "Undef"
  vivify_650:
    $P112 = $P104."new"($P110, $P111, "callmethod" :named("pasttype"), "load_setting" :named("name"))
.annotate 'line', 34
    $P113 = $P95."new"($P100, $P112, "callmethod" :named("pasttype"), "set_outer_ctx" :named("name"))
.annotate 'line', 31
    $P114 = $P86."new"($P91, $P113)
.annotate 'line', 27
    $P82."add_event"($P114 :named("deserialize_past"))
.annotate 'line', 42
    new $P115, "Exception"
    set $P115['type'], .CONTROL_RETURN
    find_lex $P116, "$setting"
    unless_null $P116, vivify_651
    new $P116, "Undef"
  vivify_651:
    getattribute $P117, $P116, "lex_pad"
    setattribute $P115, 'payload', $P117
    throw $P115
.annotate 'line', 19
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.include "except_types.pasm"
.sub "load_module" :anon :subid("16_1307873304.82979") :outer("13_1307873304.82979")
    .param pmc param_123
    .param pmc param_124
    .param pmc param_125
.annotate 'line', 48
    new $P122, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P122, control_121
    push_eh $P122
    .lex "self", param_123
    .lex "$module_name", param_124
    .lex "$cur_GLOBALish", param_125
.annotate 'line', 50
    new $P126, "Undef"
    .lex "$module", $P126
    find_lex $P127, "$loader"
    unless_null $P127, vivify_652
    new $P127, "Undef"
  vivify_652:
    find_lex $P128, "$module_name"
    unless_null $P128, vivify_653
    new $P128, "Undef"
  vivify_653:
    find_lex $P129, "$cur_GLOBALish"
    unless_null $P129, vivify_654
    new $P129, "Undef"
  vivify_654:
    $P130 = $P127."load_module"($P128, $P129)
    store_lex "$module", $P130
.annotate 'line', 53
    find_lex $P131, "self"
    get_hll_global $P132, "GLOBAL"
    nqp_get_package_through_who $P133, $P132, "PAST"
    get_who $P134, $P133
    set $P135, $P134["Stmts"]
.annotate 'line', 54
    get_hll_global $P136, "GLOBAL"
    nqp_get_package_through_who $P137, $P136, "PAST"
    get_who $P138, $P137
    set $P139, $P138["Op"]
    $P140 = $P139."new"("ModuleLoader.pbc", "load_bytecode vs" :named("pirop"))
.annotate 'line', 57
    get_hll_global $P141, "GLOBAL"
    nqp_get_package_through_who $P142, $P141, "PAST"
    get_who $P143, $P142
    set $P144, $P143["Op"]
.annotate 'line', 59
    get_hll_global $P145, "GLOBAL"
    nqp_get_package_through_who $P146, $P145, "PAST"
    get_who $P147, $P146
    set $P148, $P147["Var"]
    new $P149, "ResizablePMCArray"
    $P150 = $P148."new"("ModuleLoader" :named("name"), $P149 :named("namespace"), "package" :named("scope"))
    find_lex $P151, "$module_name"
    unless_null $P151, vivify_655
    new $P151, "Undef"
  vivify_655:
.annotate 'line', 61
    find_lex $P152, "self"
    find_lex $P153, "$cur_GLOBALish"
    unless_null $P153, vivify_656
    new $P153, "Undef"
  vivify_656:
    $P154 = $P152."get_slot_past_for_object"($P153)
    $P155 = $P144."new"($P150, $P151, $P154, "callmethod" :named("pasttype"), "load_module" :named("name"))
.annotate 'line', 57
    $P156 = $P135."new"($P140, $P155)
.annotate 'line', 53
    $P131."add_event"($P156 :named("deserialize_past"))
.annotate 'line', 64
    new $P157, "Exception"
    set $P157['type'], .CONTROL_RETURN
    find_lex $P158, "$module"
    unless_null $P158, vivify_657
    new $P158, "Undef"
  vivify_657:
    getattribute $P159, $P158, "lex_pad"
    setattribute $P157, 'payload', $P159
    throw $P157
.annotate 'line', 48
    .return ()
  control_121:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P160, exception, "payload"
    .return ($P160)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.include "except_types.pasm"
.sub "install_package_symbol" :anon :subid("17_1307873304.82979") :outer("13_1307873304.82979")
    .param pmc param_162
    .param pmc param_163
    .param pmc param_164
    .param pmc param_165
.annotate 'line', 69
    .const 'Sub' $P202 = "19_1307873304.82979" 
    capture_lex $P202
    .const 'Sub' $P181 = "18_1307873304.82979" 
    capture_lex $P181
    .lex "self", param_162
    .lex "$package", param_163
    .lex "@sym", param_164
    .lex "$obj", param_165
.annotate 'line', 71
    new $P166, "Undef"
    .lex "$name", $P166
.annotate 'line', 74
    new $P167, "Undef"
    .lex "$target", $P167
.annotate 'line', 81
    new $P168, "Undef"
    .lex "$path", $P168
.annotate 'line', 70
    find_lex $P169, "@sym"
    unless_null $P169, vivify_658
    $P169 = root_new ['parrot';'ResizablePMCArray']
  vivify_658:
    clone $P170, $P169
    store_lex "@sym", $P170
.annotate 'line', 71
    find_lex $P171, "@sym"
    unless_null $P171, vivify_659
    $P171 = root_new ['parrot';'ResizablePMCArray']
  vivify_659:
    $P172 = $P171."pop"()
    set $S173, $P172
    new $P174, 'String'
    set $P174, $S173
    store_lex "$name", $P174
.annotate 'line', 74
    find_lex $P175, "$package"
    unless_null $P175, vivify_660
    new $P175, "Undef"
  vivify_660:
    store_lex "$target", $P175
.annotate 'line', 75
    find_lex $P177, "@sym"
    unless_null $P177, vivify_661
    $P177 = root_new ['parrot';'ResizablePMCArray']
  vivify_661:
    defined $I178, $P177
    unless $I178, for_undef_662
    iter $P176, $P177
    new $P188, 'ExceptionHandler'
    set_label $P188, loop187_handler
    $P188."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P188
  loop187_test:
    unless $P176, loop187_done
    shift $P179, $P176
  loop187_redo:
    .const 'Sub' $P181 = "18_1307873304.82979" 
    capture_lex $P181
    $P181($P179)
  loop187_next:
    goto loop187_test
  loop187_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P189, exception, 'type'
    eq $P189, .CONTROL_LOOP_NEXT, loop187_next
    eq $P189, .CONTROL_LOOP_REDO, loop187_redo
  loop187_done:
    pop_eh 
  for_undef_662:
.annotate 'line', 78
    find_lex $P190, "$obj"
    unless_null $P190, vivify_665
    new $P190, "Undef"
  vivify_665:
    find_lex $P191, "$name"
    unless_null $P191, vivify_666
    new $P191, "Undef"
  vivify_666:
    find_lex $P192, "$target"
    unless_null $P192, vivify_667
    new $P192, "Undef"
    store_lex "$target", $P192
  vivify_667:
    get_who $P193, $P192
    set $P193[$P191], $P190
.annotate 'line', 81
    find_lex $P194, "self"
    find_lex $P195, "$package"
    unless_null $P195, vivify_668
    new $P195, "Undef"
  vivify_668:
    $P196 = $P194."get_slot_past_for_object"($P195)
    store_lex "$path", $P196
.annotate 'line', 82
    find_lex $P198, "@sym"
    unless_null $P198, vivify_669
    $P198 = root_new ['parrot';'ResizablePMCArray']
  vivify_669:
    defined $I199, $P198
    unless $I199, for_undef_670
    iter $P197, $P198
    new $P213, 'ExceptionHandler'
    set_label $P213, loop212_handler
    $P213."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P213
  loop212_test:
    unless $P197, loop212_done
    shift $P200, $P197
  loop212_redo:
    .const 'Sub' $P202 = "19_1307873304.82979" 
    capture_lex $P202
    $P202($P200)
  loop212_next:
    goto loop212_test
  loop212_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P214, exception, 'type'
    eq $P214, .CONTROL_LOOP_NEXT, loop212_next
    eq $P214, .CONTROL_LOOP_REDO, loop212_redo
  loop212_done:
    pop_eh 
  for_undef_670:
.annotate 'line', 85
    find_lex $P215, "self"
    get_hll_global $P216, "GLOBAL"
    nqp_get_package_through_who $P217, $P216, "PAST"
    get_who $P218, $P217
    set $P219, $P218["Op"]
.annotate 'line', 87
    get_hll_global $P220, "GLOBAL"
    nqp_get_package_through_who $P221, $P220, "PAST"
    get_who $P222, $P221
    set $P223, $P222["Var"]
.annotate 'line', 89
    get_hll_global $P224, "GLOBAL"
    nqp_get_package_through_who $P225, $P224, "PAST"
    get_who $P226, $P225
    set $P227, $P226["Op"]
    find_lex $P228, "$path"
    unless_null $P228, vivify_673
    new $P228, "Undef"
  vivify_673:
    $P229 = $P227."new"($P228, "get_who PP" :named("pirop"))
    find_lex $P230, "$name"
    unless_null $P230, vivify_674
    new $P230, "Undef"
  vivify_674:
    $P231 = $P223."new"($P229, $P230, "keyed" :named("scope"))
.annotate 'line', 92
    find_lex $P232, "self"
    find_lex $P233, "$obj"
    unless_null $P233, vivify_675
    new $P233, "Undef"
  vivify_675:
    $P234 = $P232."get_slot_past_for_object"($P233)
    $P235 = $P219."new"($P231, $P234, "bind_6model" :named("pasttype"))
.annotate 'line', 85
    $P236 = $P215."add_event"($P235 :named("deserialize_past"))
.annotate 'line', 69
    .return ($P236)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block180"  :anon :subid("18_1307873304.82979") :outer("17_1307873304.82979")
    .param pmc param_182
.annotate 'line', 75
    .lex "$_", param_182
.annotate 'line', 76
    find_lex $P183, "$target"
    unless_null $P183, vivify_663
    new $P183, "Undef"
  vivify_663:
    find_lex $P184, "$_"
    unless_null $P184, vivify_664
    new $P184, "Undef"
  vivify_664:
    set $S185, $P184
    nqp_get_package_through_who $P186, $P183, $S185
    store_lex "$target", $P186
.annotate 'line', 75
    .return ($P186)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block201"  :anon :subid("19_1307873304.82979") :outer("17_1307873304.82979")
    .param pmc param_203
.annotate 'line', 82
    .lex "$_", param_203
.annotate 'line', 83
    get_hll_global $P204, "GLOBAL"
    nqp_get_package_through_who $P205, $P204, "PAST"
    get_who $P206, $P205
    set $P207, $P206["Op"]
    find_lex $P208, "$path"
    unless_null $P208, vivify_671
    new $P208, "Undef"
  vivify_671:
    find_lex $P209, "$_"
    unless_null $P209, vivify_672
    new $P209, "Undef"
  vivify_672:
    set $S210, $P209
    $P211 = $P207."new"($P208, $S210, "nqp_get_package_through_who PPs" :named("pirop"))
    store_lex "$path", $P211
.annotate 'line', 82
    .return ($P211)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "install_lexical_symbol" :anon :subid("20_1307873304.82979") :outer("13_1307873304.82979")
    .param pmc param_238
    .param pmc param_239
    .param pmc param_240
    .param pmc param_241
.annotate 'line', 100
    .lex "self", param_238
    .lex "$block", param_239
    .lex "$name", param_240
    .lex "$obj", param_241
.annotate 'line', 106
    new $P242, "Undef"
    .lex "$fixup", $P242
.annotate 'line', 102
    find_lex $P243, "$block"
    unless_null $P243, vivify_676
    new $P243, "Undef"
  vivify_676:
    find_lex $P244, "$name"
    unless_null $P244, vivify_677
    new $P244, "Undef"
  vivify_677:
    find_lex $P245, "$obj"
    unless_null $P245, vivify_678
    new $P245, "Undef"
  vivify_678:
    $P243."symbol"($P244, "lexical" :named("scope"), $P245 :named("value"))
.annotate 'line', 103
    find_lex $P246, "$block"
    unless_null $P246, vivify_679
    $P246 = root_new ['parrot';'ResizablePMCArray']
  vivify_679:
    set $P247, $P246[0]
    unless_null $P247, vivify_680
    new $P247, "Undef"
  vivify_680:
    get_hll_global $P248, "GLOBAL"
    nqp_get_package_through_who $P249, $P248, "PAST"
    get_who $P250, $P249
    set $P251, $P250["Var"]
    find_lex $P252, "$name"
    unless_null $P252, vivify_681
    new $P252, "Undef"
  vivify_681:
    $P253 = $P251."new"("lexical" :named("scope"), $P252 :named("name"), 1 :named("isdecl"))
    $P247."push"($P253)
.annotate 'line', 106
    get_hll_global $P254, "GLOBAL"
    nqp_get_package_through_who $P255, $P254, "PAST"
    get_who $P256, $P255
    set $P257, $P256["Stmts"]
.annotate 'line', 107
    get_hll_global $P258, "GLOBAL"
    nqp_get_package_through_who $P259, $P258, "PAST"
    get_who $P260, $P259
    set $P261, $P260["Op"]
.annotate 'line', 109
    get_hll_global $P262, "GLOBAL"
    nqp_get_package_through_who $P263, $P262, "PAST"
    get_who $P264, $P263
    set $P265, $P264["Op"]
.annotate 'line', 111
    get_hll_global $P266, "GLOBAL"
    nqp_get_package_through_who $P267, $P266, "PAST"
    get_who $P268, $P267
    set $P269, $P268["Val"]
    find_lex $P270, "$block"
    unless_null $P270, vivify_682
    new $P270, "Undef"
  vivify_682:
    $P271 = $P269."new"($P270 :named("value"))
    $P272 = $P265."new"($P271, "callmethod" :named("pasttype"), "get_lexinfo" :named("name"))
.annotate 'line', 113
    find_lex $P273, "$name"
    unless_null $P273, vivify_683
    new $P273, "Undef"
  vivify_683:
    set $S274, $P273
    find_lex $P275, "self"
    find_lex $P276, "$obj"
    unless_null $P276, vivify_684
    new $P276, "Undef"
  vivify_684:
    $P277 = $P275."get_slot_past_for_object"($P276)
    $P278 = $P261."new"($P272, $S274, $P277, "callmethod" :named("pasttype"), "set_static_lexpad_value" :named("name"))
.annotate 'line', 117
    get_hll_global $P279, "GLOBAL"
    nqp_get_package_through_who $P280, $P279, "PAST"
    get_who $P281, $P280
    set $P282, $P281["Op"]
.annotate 'line', 119
    get_hll_global $P283, "GLOBAL"
    nqp_get_package_through_who $P284, $P283, "PAST"
    get_who $P285, $P284
    set $P286, $P285["Op"]
.annotate 'line', 121
    get_hll_global $P287, "GLOBAL"
    nqp_get_package_through_who $P288, $P287, "PAST"
    get_who $P289, $P288
    set $P290, $P289["Val"]
    find_lex $P291, "$block"
    unless_null $P291, vivify_685
    new $P291, "Undef"
  vivify_685:
    $P292 = $P290."new"($P291 :named("value"))
    $P293 = $P286."new"($P292, "callmethod" :named("pasttype"), "get_lexinfo" :named("name"))
.annotate 'line', 119
    $P294 = $P282."new"($P293, "callmethod" :named("pasttype"), "finish_static_lexpad" :named("name"))
.annotate 'line', 117
    $P295 = $P257."new"($P278, $P294)
.annotate 'line', 106
    store_lex "$fixup", $P295
.annotate 'line', 125
    find_lex $P296, "self"
    find_lex $P297, "$fixup"
    unless_null $P297, vivify_686
    new $P297, "Undef"
  vivify_686:
    find_lex $P298, "$fixup"
    unless_null $P298, vivify_687
    new $P298, "Undef"
  vivify_687:
    $P299 = $P296."add_event"($P297 :named("deserialize_past"), $P298 :named("fixup_past"))
.annotate 'line', 100
    .return ($P299)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "install_package_routine" :anon :subid("21_1307873304.82979") :outer("13_1307873304.82979")
    .param pmc param_301
    .param pmc param_302
    .param pmc param_303
    .param pmc param_304
.annotate 'line', 130
    .lex "self", param_301
    .lex "$package", param_302
    .lex "$name", param_303
    .lex "$past_block", param_304
.annotate 'line', 131
    new $P305, "Undef"
    .lex "$fixup", $P305
    get_hll_global $P306, "GLOBAL"
    nqp_get_package_through_who $P307, $P306, "PAST"
    get_who $P308, $P307
    set $P309, $P308["Op"]
.annotate 'line', 133
    get_hll_global $P310, "GLOBAL"
    nqp_get_package_through_who $P311, $P310, "PAST"
    get_who $P312, $P311
    set $P313, $P312["Var"]
.annotate 'line', 135
    get_hll_global $P314, "GLOBAL"
    nqp_get_package_through_who $P315, $P314, "PAST"
    get_who $P316, $P315
    set $P317, $P316["Op"]
    find_lex $P318, "self"
    find_lex $P319, "$package"
    unless_null $P319, vivify_688
    new $P319, "Undef"
  vivify_688:
    $P320 = $P318."get_slot_past_for_object"($P319)
    $P321 = $P317."new"($P320, "get_who PP" :named("pirop"))
.annotate 'line', 136
    find_lex $P322, "$name"
    unless_null $P322, vivify_689
    new $P322, "Undef"
  vivify_689:
    set $S323, $P322
    $P324 = $P313."new"($P321, $S323, "keyed" :named("scope"))
.annotate 'line', 138
    get_hll_global $P325, "GLOBAL"
    nqp_get_package_through_who $P326, $P325, "PAST"
    get_who $P327, $P326
    set $P328, $P327["Val"]
    find_lex $P329, "$past_block"
    unless_null $P329, vivify_690
    new $P329, "Undef"
  vivify_690:
    $P330 = $P328."new"($P329 :named("value"))
    $P331 = $P309."new"($P324, $P330, "bind_6model" :named("pasttype"))
.annotate 'line', 131
    store_lex "$fixup", $P331
.annotate 'line', 140
    find_lex $P332, "self"
    find_lex $P333, "$fixup"
    unless_null $P333, vivify_691
    new $P333, "Undef"
  vivify_691:
    find_lex $P334, "$fixup"
    unless_null $P334, vivify_692
    new $P334, "Undef"
  vivify_692:
    $P335 = $P332."add_event"($P333 :named("deserialize_past"), $P334 :named("fixup_past"))
.annotate 'line', 130
    .return ($P335)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.include "except_types.pasm"
.sub "pkg_create_mo" :anon :subid("22_1307873304.82979") :outer("13_1307873304.82979")
    .param pmc param_339
    .param pmc param_340
    .param pmc param_341 :optional :named("name")
    .param int has_param_341 :opt_flag
    .param pmc param_343 :optional :named("repr")
    .param int has_param_343 :opt_flag
.annotate 'line', 145
    new $P338, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P338, control_337
    push_eh $P338
    .lex "self", param_339
    .lex "$how", param_340
    if has_param_341, optparam_693
    new $P342, "Undef"
    set param_341, $P342
  optparam_693:
    .lex "$name", param_341
    if has_param_343, optparam_694
    new $P344, "Undef"
    set param_343, $P344
  optparam_694:
    .lex "$repr", param_343
.annotate 'line', 147
    $P345 = root_new ['parrot';'Hash']
    .lex "%args", $P345
.annotate 'line', 150
    new $P346, "Undef"
    .lex "$mo", $P346
.annotate 'line', 151
    new $P347, "Undef"
    .lex "$slot", $P347
.annotate 'line', 155
    $P348 = root_new ['parrot';'ResizablePMCArray']
    .lex "@how_ns", $P348
.annotate 'line', 156
    new $P349, "Undef"
    .lex "$how_name", $P349
.annotate 'line', 157
    new $P350, "Undef"
    .lex "$setup_call", $P350
.annotate 'line', 145
    find_lex $P351, "%args"
    unless_null $P351, vivify_695
    $P351 = root_new ['parrot';'Hash']
  vivify_695:
.annotate 'line', 148
    find_lex $P353, "$name"
    unless_null $P353, vivify_696
    new $P353, "Undef"
  vivify_696:
    defined $I354, $P353
    unless $I354, if_352_end
    find_lex $P355, "$name"
    unless_null $P355, vivify_697
    new $P355, "Undef"
  vivify_697:
    find_lex $P356, "%args"
    unless_null $P356, vivify_698
    $P356 = root_new ['parrot';'Hash']
    store_lex "%args", $P356
  vivify_698:
    set $P356["name"], $P355
  if_352_end:
.annotate 'line', 149
    find_lex $P358, "$repr"
    unless_null $P358, vivify_699
    new $P358, "Undef"
  vivify_699:
    defined $I359, $P358
    unless $I359, if_357_end
    find_lex $P360, "$repr"
    unless_null $P360, vivify_700
    new $P360, "Undef"
  vivify_700:
    find_lex $P361, "%args"
    unless_null $P361, vivify_701
    $P361 = root_new ['parrot';'Hash']
    store_lex "%args", $P361
  vivify_701:
    set $P361["repr"], $P360
  if_357_end:
.annotate 'line', 150
    find_lex $P362, "$how"
    unless_null $P362, vivify_702
    new $P362, "Undef"
  vivify_702:
    find_lex $P363, "%args"
    unless_null $P363, vivify_703
    $P363 = root_new ['parrot';'Hash']
  vivify_703:
    $P364 = $P362."new_type"($P363 :flat)
    store_lex "$mo", $P364
.annotate 'line', 151
    find_lex $P365, "self"
    find_lex $P366, "$mo"
    unless_null $P366, vivify_704
    new $P366, "Undef"
  vivify_704:
    $P367 = $P365."add_object"($P366)
    store_lex "$slot", $P367
.annotate 'line', 155
    find_lex $P368, "$how"
    unless_null $P368, vivify_705
    new $P368, "Undef"
  vivify_705:
    get_how $P369, $P368
    find_lex $P370, "$how"
    unless_null $P370, vivify_706
    new $P370, "Undef"
  vivify_706:
    $S371 = $P369."name"($P370)
    split $P372, "::", $S371
    store_lex "@how_ns", $P372
.annotate 'line', 156
    find_lex $P373, "@how_ns"
    unless_null $P373, vivify_707
    $P373 = root_new ['parrot';'ResizablePMCArray']
  vivify_707:
    $P374 = $P373."pop"()
    store_lex "$how_name", $P374
.annotate 'line', 157
    get_hll_global $P375, "GLOBAL"
    nqp_get_package_through_who $P376, $P375, "PAST"
    get_who $P377, $P376
    set $P378, $P377["Op"]
.annotate 'line', 159
    find_lex $P379, "self"
    find_lex $P380, "$how"
    unless_null $P380, vivify_708
    new $P380, "Undef"
  vivify_708:
    $P381 = $P379."get_object_sc_ref_past"($P380)
    $P382 = $P378."new"($P381, "callmethod" :named("pasttype"), "new_type" :named("name"))
.annotate 'line', 157
    store_lex "$setup_call", $P382
.annotate 'line', 161
    find_lex $P384, "$name"
    unless_null $P384, vivify_709
    new $P384, "Undef"
  vivify_709:
    defined $I385, $P384
    unless $I385, if_383_end
.annotate 'line', 162
    find_lex $P386, "$setup_call"
    unless_null $P386, vivify_710
    new $P386, "Undef"
  vivify_710:
    get_hll_global $P387, "GLOBAL"
    nqp_get_package_through_who $P388, $P387, "PAST"
    get_who $P389, $P388
    set $P390, $P389["Val"]
    find_lex $P391, "$name"
    unless_null $P391, vivify_711
    new $P391, "Undef"
  vivify_711:
    $P392 = $P390."new"($P391 :named("value"), "name" :named("named"))
    $P386."push"($P392)
  if_383_end:
.annotate 'line', 164
    find_lex $P394, "$repr"
    unless_null $P394, vivify_712
    new $P394, "Undef"
  vivify_712:
    defined $I395, $P394
    unless $I395, if_393_end
.annotate 'line', 165
    find_lex $P396, "$setup_call"
    unless_null $P396, vivify_713
    new $P396, "Undef"
  vivify_713:
    get_hll_global $P397, "GLOBAL"
    nqp_get_package_through_who $P398, $P397, "PAST"
    get_who $P399, $P398
    set $P400, $P399["Val"]
    find_lex $P401, "$repr"
    unless_null $P401, vivify_714
    new $P401, "Undef"
  vivify_714:
    $P402 = $P400."new"($P401 :named("value"), "repr" :named("named"))
    $P396."push"($P402)
  if_393_end:
.annotate 'line', 167
    find_lex $P403, "self"
.annotate 'line', 168
    find_lex $P404, "self"
    find_lex $P405, "$slot"
    unless_null $P405, vivify_715
    new $P405, "Undef"
  vivify_715:
    find_lex $P406, "self"
    find_lex $P407, "$setup_call"
    unless_null $P407, vivify_716
    new $P407, "Undef"
  vivify_716:
    $P408 = $P406."set_cur_sc"($P407)
    $P409 = $P404."set_slot_past"($P405, $P408)
    $P403."add_event"($P409 :named("deserialize_past"))
.annotate 'line', 171
    new $P410, "Exception"
    set $P410['type'], .CONTROL_RETURN
    find_lex $P411, "$mo"
    unless_null $P411, vivify_717
    new $P411, "Undef"
  vivify_717:
    setattribute $P410, 'payload', $P411
    throw $P410
.annotate 'line', 145
    .return ()
  control_337:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P412, exception, "payload"
    .return ($P412)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.include "except_types.pasm"
.sub "pkg_add_attribute" :anon :subid("23_1307873304.82979") :outer("13_1307873304.82979")
    .param pmc param_414
    .param pmc param_415
    .param pmc param_416
    .param pmc param_417
    .param pmc param_418
.annotate 'line', 179
    .const 'Sub' $P464 = "25_1307873304.82979" 
    capture_lex $P464
    .const 'Sub' $P443 = "24_1307873304.82979" 
    capture_lex $P443
    .lex "self", param_414
    .lex "$obj", param_415
    .lex "$meta_attr", param_416
    .lex "%lit_args", param_417
    .lex "%obj_args", param_418
.annotate 'line', 181
    new $P419, "Undef"
    .lex "$attr", $P419
.annotate 'line', 185
    new $P420, "Undef"
    .lex "$create_call", $P420
.annotate 'line', 197
    new $P421, "Undef"
    .lex "$obj_slot_past", $P421
.annotate 'line', 181
    find_lex $P422, "$meta_attr"
    unless_null $P422, vivify_718
    new $P422, "Undef"
  vivify_718:
    find_lex $P423, "%lit_args"
    unless_null $P423, vivify_719
    $P423 = root_new ['parrot';'Hash']
  vivify_719:
    find_lex $P424, "%obj_args"
    unless_null $P424, vivify_720
    $P424 = root_new ['parrot';'Hash']
  vivify_720:
    $P425 = $P422."new"($P423 :flat, $P424 :flat)
    store_lex "$attr", $P425
.annotate 'line', 182
    find_lex $P426, "$obj"
    unless_null $P426, vivify_721
    new $P426, "Undef"
  vivify_721:
    get_how $P427, $P426
    find_lex $P428, "$obj"
    unless_null $P428, vivify_722
    new $P428, "Undef"
  vivify_722:
    find_lex $P429, "$attr"
    unless_null $P429, vivify_723
    new $P429, "Undef"
  vivify_723:
    $P427."add_attribute"($P428, $P429)
.annotate 'line', 185
    get_hll_global $P430, "GLOBAL"
    nqp_get_package_through_who $P431, $P430, "PAST"
    get_who $P432, $P431
    set $P433, $P432["Op"]
.annotate 'line', 187
    find_lex $P434, "self"
    find_lex $P435, "$meta_attr"
    unless_null $P435, vivify_724
    new $P435, "Undef"
  vivify_724:
    $P436 = $P434."get_object_sc_ref_past"($P435)
    $P437 = $P433."new"($P436, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 185
    store_lex "$create_call", $P437
.annotate 'line', 189
    find_lex $P439, "%lit_args"
    unless_null $P439, vivify_725
    $P439 = root_new ['parrot';'Hash']
  vivify_725:
    defined $I440, $P439
    unless $I440, for_undef_726
    iter $P438, $P439
    new $P457, 'ExceptionHandler'
    set_label $P457, loop456_handler
    $P457."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P457
  loop456_test:
    unless $P438, loop456_done
    shift $P441, $P438
  loop456_redo:
    .const 'Sub' $P443 = "24_1307873304.82979" 
    capture_lex $P443
    $P443($P441)
  loop456_next:
    goto loop456_test
  loop456_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P458, exception, 'type'
    eq $P458, .CONTROL_LOOP_NEXT, loop456_next
    eq $P458, .CONTROL_LOOP_REDO, loop456_redo
  loop456_done:
    pop_eh 
  for_undef_726:
.annotate 'line', 192
    find_lex $P460, "%obj_args"
    unless_null $P460, vivify_730
    $P460 = root_new ['parrot';'Hash']
  vivify_730:
    defined $I461, $P460
    unless $I461, for_undef_731
    iter $P459, $P460
    new $P478, 'ExceptionHandler'
    set_label $P478, loop477_handler
    $P478."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P478
  loop477_test:
    unless $P459, loop477_done
    shift $P462, $P459
  loop477_redo:
    .const 'Sub' $P464 = "25_1307873304.82979" 
    capture_lex $P464
    $P464($P462)
  loop477_next:
    goto loop477_test
  loop477_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P479, exception, 'type'
    eq $P479, .CONTROL_LOOP_NEXT, loop477_next
    eq $P479, .CONTROL_LOOP_REDO, loop477_redo
  loop477_done:
    pop_eh 
  for_undef_731:
.annotate 'line', 197
    find_lex $P480, "self"
    find_lex $P481, "$obj"
    unless_null $P481, vivify_737
    new $P481, "Undef"
  vivify_737:
    $P482 = $P480."get_slot_past_for_object"($P481)
    store_lex "$obj_slot_past", $P482
.annotate 'line', 198
    find_lex $P483, "self"
    get_hll_global $P484, "GLOBAL"
    nqp_get_package_through_who $P485, $P484, "PAST"
    get_who $P486, $P485
    set $P487, $P486["Op"]
.annotate 'line', 200
    get_hll_global $P488, "GLOBAL"
    nqp_get_package_through_who $P489, $P488, "PAST"
    get_who $P490, $P489
    set $P491, $P490["Op"]
    find_lex $P492, "$obj_slot_past"
    unless_null $P492, vivify_738
    new $P492, "Undef"
  vivify_738:
    $P493 = $P491."new"($P492, "get_how PP" :named("pirop"))
    find_lex $P494, "$obj_slot_past"
    unless_null $P494, vivify_739
    new $P494, "Undef"
  vivify_739:
    find_lex $P495, "$create_call"
    unless_null $P495, vivify_740
    new $P495, "Undef"
  vivify_740:
    $P496 = $P487."new"($P493, $P494, $P495, "callmethod" :named("pasttype"), "add_attribute" :named("name"))
.annotate 'line', 198
    $P497 = $P483."add_event"($P496 :named("deserialize_past"))
.annotate 'line', 179
    .return ($P497)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block442"  :anon :subid("24_1307873304.82979") :outer("23_1307873304.82979")
    .param pmc param_444
.annotate 'line', 189
    .lex "$_", param_444
.annotate 'line', 190
    find_lex $P445, "$create_call"
    unless_null $P445, vivify_727
    new $P445, "Undef"
  vivify_727:
    get_hll_global $P446, "GLOBAL"
    nqp_get_package_through_who $P447, $P446, "PAST"
    get_who $P448, $P447
    set $P449, $P448["Val"]
    find_lex $P450, "$_"
    unless_null $P450, vivify_728
    new $P450, "Undef"
  vivify_728:
    $P451 = $P450."value"()
    find_lex $P452, "$_"
    unless_null $P452, vivify_729
    new $P452, "Undef"
  vivify_729:
    $P453 = $P452."key"()
    $P454 = $P449."new"($P451 :named("value"), $P453 :named("named"))
    $P455 = $P445."push"($P454)
.annotate 'line', 189
    .return ($P455)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block463"  :anon :subid("25_1307873304.82979") :outer("23_1307873304.82979")
    .param pmc param_466
.annotate 'line', 193
    new $P465, "Undef"
    .lex "$lookup", $P465
    .lex "$_", param_466
    find_lex $P467, "self"
    find_lex $P468, "$_"
    unless_null $P468, vivify_732
    new $P468, "Undef"
  vivify_732:
    $P469 = $P468."value"()
    $P470 = $P467."get_object_sc_ref_past"($P469)
    store_lex "$lookup", $P470
.annotate 'line', 194
    find_lex $P471, "$lookup"
    unless_null $P471, vivify_733
    new $P471, "Undef"
  vivify_733:
    find_lex $P472, "$_"
    unless_null $P472, vivify_734
    new $P472, "Undef"
  vivify_734:
    $P473 = $P472."key"()
    $P471."named"($P473)
.annotate 'line', 195
    find_lex $P474, "$create_call"
    unless_null $P474, vivify_735
    new $P474, "Undef"
  vivify_735:
    find_lex $P475, "$lookup"
    unless_null $P475, vivify_736
    new $P475, "Undef"
  vivify_736:
    $P476 = $P474."push"($P475)
.annotate 'line', 192
    .return ($P476)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "pkg_add_method" :anon :subid("26_1307873304.82979") :outer("13_1307873304.82979")
    .param pmc param_499
    .param pmc param_500
    .param pmc param_501
    .param pmc param_502
    .param pmc param_503
    .param pmc param_504
.annotate 'line', 209
    .const 'Sub' $P544 = "28_1307873304.82979" 
    capture_lex $P544
    .const 'Sub' $P510 = "27_1307873304.82979" 
    capture_lex $P510
    .lex "self", param_499
    .lex "$obj", param_500
    .lex "$meta_method_name", param_501
    .lex "$name", param_502
    .lex "$method_past", param_503
    .lex "$is_dispatcher", param_504
.annotate 'line', 215
    new $P505, "Undef"
    .lex "$stub_code", $P505
.annotate 'line', 221
    new $P506, "Undef"
    .lex "$fixups", $P506
.annotate 'line', 222
    new $P507, "Undef"
    .lex "$dummy", $P507
.annotate 'line', 267
    new $P508, "Undef"
    .lex "$slot_past", $P508
.annotate 'line', 215
    .const 'Sub' $P510 = "27_1307873304.82979" 
    newclosure $P524, $P510
    store_lex "$stub_code", $P524
.annotate 'line', 221
    get_hll_global $P525, "GLOBAL"
    nqp_get_package_through_who $P526, $P525, "PAST"
    get_who $P527, $P526
    set $P528, $P527["Stmts"]
    $P529 = $P528."new"()
    store_lex "$fixups", $P529
    find_lex $P530, "$dummy"
    unless_null $P530, vivify_745
    new $P530, "Undef"
  vivify_745:
.annotate 'line', 223
    find_lex $P532, "$method_past"
    unless_null $P532, vivify_746
    $P532 = root_new ['parrot';'Hash']
  vivify_746:
    set $P533, $P532["compile_time_dummy"]
    unless_null $P533, vivify_747
    new $P533, "Undef"
  vivify_747:
    defined $I534, $P533
    if $I534, if_531
.annotate 'line', 230
    find_lex $P538, "$is_dispatcher"
    unless_null $P538, vivify_748
    new $P538, "Undef"
  vivify_748:
    if $P538, if_537
.annotate 'line', 246
    find_lex $P567, "$stub_code"
    unless_null $P567, vivify_749
    new $P567, "Undef"
  vivify_749:
    clone $P568, $P567
    store_lex "$dummy", $P568
.annotate 'line', 245
    goto if_537_end
  if_537:
.annotate 'line', 231
    find_lex $P539, "$method_past"
    unless_null $P539, vivify_750
    new $P539, "Undef"
  vivify_750:
    $P539."pirflags"(":instanceof(\"DispatcherSub\")")
.annotate 'line', 232
    new $P540, "DispatcherSub"
    find_lex $P541, "$stub_code"
    unless_null $P541, vivify_751
    new $P541, "Undef"
  vivify_751:
    assign $P540, $P541
    store_lex "$dummy", $P540
.annotate 'line', 236
    find_lex $P542, "$dummy"
    unless_null $P542, vivify_752
    new $P542, "Undef"
  vivify_752:
    .const 'Sub' $P544 = "28_1307873304.82979" 
    newclosure $P566, $P544
    setprop $P542, "CLONE_CALLBACK", $P566
  if_537_end:
.annotate 'line', 248
    find_lex $P569, "$dummy"
    unless_null $P569, vivify_757
    new $P569, "Undef"
  vivify_757:
    find_lex $P570, "$name"
    unless_null $P570, vivify_758
    new $P570, "Undef"
  vivify_758:
    set $S571, $P570
    assign $P569, $S571
.annotate 'line', 249
    find_lex $P572, "self"
    find_lex $P573, "$dummy"
    unless_null $P573, vivify_759
    new $P573, "Undef"
  vivify_759:
    $P572."add_code"($P573)
.annotate 'line', 250
    find_lex $P574, "$dummy"
    unless_null $P574, vivify_760
    new $P574, "Undef"
  vivify_760:
    find_lex $P575, "$method_past"
    unless_null $P575, vivify_761
    $P575 = root_new ['parrot';'Hash']
    store_lex "$method_past", $P575
  vivify_761:
    set $P575["compile_time_dummy"], $P574
.annotate 'line', 226
    goto if_531_end
  if_531:
.annotate 'line', 224
    find_lex $P535, "$method_past"
    unless_null $P535, vivify_762
    $P535 = root_new ['parrot';'Hash']
  vivify_762:
    set $P536, $P535["compile_time_dummy"]
    unless_null $P536, vivify_763
    new $P536, "Undef"
  vivify_763:
    store_lex "$dummy", $P536
  if_531_end:
.annotate 'line', 254
    find_lex $P576, "$dummy"
    unless_null $P576, vivify_764
    new $P576, "Undef"
  vivify_764:
    find_lex $P577, "$method_past"
    unless_null $P577, vivify_765
    new $P577, "Undef"
  vivify_765:
    setprop $P576, "PAST", $P577
.annotate 'line', 257
    find_lex $P578, "$obj"
    unless_null $P578, vivify_766
    new $P578, "Undef"
  vivify_766:
    get_how $P579, $P578
    find_lex $P580, "$obj"
    unless_null $P580, vivify_767
    new $P580, "Undef"
  vivify_767:
    find_lex $P581, "$name"
    unless_null $P581, vivify_768
    new $P581, "Undef"
  vivify_768:
    find_lex $P582, "$dummy"
    unless_null $P582, vivify_769
    new $P582, "Undef"
  vivify_769:
    find_lex $P583, "$meta_method_name"
    unless_null $P583, vivify_770
    new $P583, "Undef"
  vivify_770:
    set $S584, $P583
    $P579.$S584($P580, $P581, $P582)
.annotate 'line', 262
    find_lex $P585, "$fixups"
    unless_null $P585, vivify_771
    new $P585, "Undef"
  vivify_771:
    get_hll_global $P586, "GLOBAL"
    nqp_get_package_through_who $P587, $P586, "PAST"
    get_who $P588, $P587
    set $P589, $P588["Op"]
.annotate 'line', 264
    find_lex $P590, "self"
    find_lex $P591, "$dummy"
    unless_null $P591, vivify_772
    new $P591, "Undef"
  vivify_772:
    $P592 = $P590."get_slot_past_for_object"($P591)
.annotate 'line', 265
    get_hll_global $P593, "GLOBAL"
    nqp_get_package_through_who $P594, $P593, "PAST"
    get_who $P595, $P594
    set $P596, $P595["Val"]
    find_lex $P597, "$method_past"
    unless_null $P597, vivify_773
    new $P597, "Undef"
  vivify_773:
    $P598 = $P596."new"($P597 :named("value"))
    $P599 = $P589."new"($P592, $P598, "assign vPP" :named("pirop"))
.annotate 'line', 262
    $P585."push"($P599)
.annotate 'line', 267
    find_lex $P600, "self"
    find_lex $P601, "$obj"
    unless_null $P601, vivify_774
    new $P601, "Undef"
  vivify_774:
    $P602 = $P600."get_slot_past_for_object"($P601)
    store_lex "$slot_past", $P602
.annotate 'line', 268
    find_lex $P603, "self"
.annotate 'line', 269
    get_hll_global $P604, "GLOBAL"
    nqp_get_package_through_who $P605, $P604, "PAST"
    get_who $P606, $P605
    set $P607, $P606["Op"]
    find_lex $P608, "$meta_method_name"
    unless_null $P608, vivify_775
    new $P608, "Undef"
  vivify_775:
.annotate 'line', 271
    get_hll_global $P609, "GLOBAL"
    nqp_get_package_through_who $P610, $P609, "PAST"
    get_who $P611, $P610
    set $P612, $P611["Op"]
    find_lex $P613, "$slot_past"
    unless_null $P613, vivify_776
    new $P613, "Undef"
  vivify_776:
    $P614 = $P612."new"($P613, "get_how PP" :named("pirop"))
    find_lex $P615, "$slot_past"
    unless_null $P615, vivify_777
    new $P615, "Undef"
  vivify_777:
    find_lex $P616, "$name"
    unless_null $P616, vivify_778
    new $P616, "Undef"
  vivify_778:
.annotate 'line', 274
    get_hll_global $P617, "GLOBAL"
    nqp_get_package_through_who $P618, $P617, "PAST"
    get_who $P619, $P618
    set $P620, $P619["Val"]
    find_lex $P621, "$method_past"
    unless_null $P621, vivify_779
    new $P621, "Undef"
  vivify_779:
    $P622 = $P620."new"($P621 :named("value"))
    $P623 = $P607."new"($P614, $P615, $P616, $P622, "callmethod" :named("pasttype"), $P608 :named("name"))
.annotate 'line', 269
    find_lex $P624, "$fixups"
    unless_null $P624, vivify_780
    new $P624, "Undef"
  vivify_780:
    $P625 = $P603."add_event"($P623 :named("deserialize_past"), $P624 :named("fixup_past"))
.annotate 'line', 209
    .return ($P625)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block509"  :anon :subid("27_1307873304.82979") :outer("26_1307873304.82979")
    .param pmc param_511 :slurpy
    .param pmc param_512 :slurpy :named
.annotate 'line', 215
    .lex "@args", param_511
    .lex "%named", param_512
.annotate 'line', 216
    new $P513, "Undef"
    .lex "$compiled", $P513
    get_hll_global $P514, "GLOBAL"
    nqp_get_package_through_who $P515, $P514, "PAST"
    get_who $P516, $P515
    set $P517, $P516["Compiler"]
    find_lex $P518, "$method_past"
    unless_null $P518, vivify_741
    new $P518, "Undef"
  vivify_741:
    $P519 = $P517."compile"($P518)
    store_lex "$compiled", $P519
.annotate 'line', 217
    find_lex $P520, "$compiled"
    unless_null $P520, vivify_742
    new $P520, "Undef"
  vivify_742:
    find_lex $P521, "@args"
    unless_null $P521, vivify_743
    $P521 = root_new ['parrot';'ResizablePMCArray']
  vivify_743:
    find_lex $P522, "%named"
    unless_null $P522, vivify_744
    $P522 = root_new ['parrot';'Hash']
  vivify_744:
    $P523 = $P520($P521 :flat, $P522 :flat)
.annotate 'line', 215
    .return ($P523)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block543"  :anon :subid("28_1307873304.82979") :outer("26_1307873304.82979")
    .param pmc param_545
    .param pmc param_546
.annotate 'line', 236
    .lex "$orig", param_545
    .lex "$clone", param_546
.annotate 'line', 237
    find_lex $P547, "self"
    find_lex $P548, "$clone"
    unless_null $P548, vivify_753
    new $P548, "Undef"
  vivify_753:
    $P547."add_code"($P548)
.annotate 'line', 238
    find_lex $P549, "$fixups"
    unless_null $P549, vivify_754
    new $P549, "Undef"
  vivify_754:
    get_hll_global $P550, "GLOBAL"
    nqp_get_package_through_who $P551, $P550, "PAST"
    get_who $P552, $P551
    set $P553, $P552["Op"]
.annotate 'line', 240
    find_lex $P554, "self"
    find_lex $P555, "$clone"
    unless_null $P555, vivify_755
    new $P555, "Undef"
  vivify_755:
    $P556 = $P554."get_slot_past_for_object"($P555)
.annotate 'line', 241
    get_hll_global $P557, "GLOBAL"
    nqp_get_package_through_who $P558, $P557, "PAST"
    get_who $P559, $P558
    set $P560, $P559["Val"]
    find_lex $P561, "$orig"
    unless_null $P561, vivify_756
    new $P561, "Undef"
  vivify_756:
    getprop $P562, "PAST", $P561
    $P563 = $P560."new"($P562 :named("value"))
    $P564 = $P553."new"($P556, $P563, "assign vPP" :named("pirop"))
.annotate 'line', 238
    $P565 = $P549."push"($P564)
.annotate 'line', 236
    .return ($P565)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "set_routine_signature" :anon :subid("29_1307873304.82979") :outer("13_1307873304.82979")
    .param pmc param_627
    .param pmc param_628
    .param pmc param_629
    .param pmc param_630
.annotate 'line', 280
    .lex "self", param_627
    .lex "$routine", param_628
    .lex "$types", param_629
    .lex "$definednesses", param_630
.annotate 'line', 283
    new $P631, "Undef"
    .lex "$fixup", $P631
.annotate 'line', 290
    new $P632, "Undef"
    .lex "$des", $P632
.annotate 'line', 283
    get_hll_global $P633, "GLOBAL"
    nqp_get_package_through_who $P634, $P633, "PAST"
    get_who $P635, $P634
    set $P636, $P635["Op"]
    find_lex $P637, "$types"
    unless_null $P637, vivify_781
    new $P637, "Undef"
  vivify_781:
    find_lex $P638, "$definednesses"
    unless_null $P638, vivify_782
    new $P638, "Undef"
  vivify_782:
    $P639 = $P636."new"($P637, $P638, "set_sub_multisig vPPP" :named("pirop"))
    store_lex "$fixup", $P639
.annotate 'line', 284
    find_lex $P641, "$routine"
    unless_null $P641, vivify_783
    $P641 = root_new ['parrot';'Hash']
  vivify_783:
    set $P642, $P641["compile_time_dummy"]
    unless_null $P642, vivify_784
    new $P642, "Undef"
  vivify_784:
    defined $I643, $P642
    if $I643, if_640
.annotate 'line', 288
    find_lex $P649, "$fixup"
    unless_null $P649, vivify_785
    new $P649, "Undef"
  vivify_785:
    get_hll_global $P650, "GLOBAL"
    nqp_get_package_through_who $P651, $P650, "PAST"
    get_who $P652, $P651
    set $P653, $P652["Val"]
    find_lex $P654, "$routine"
    unless_null $P654, vivify_786
    new $P654, "Undef"
  vivify_786:
    $P655 = $P653."new"($P654 :named("value"))
    $P649."unshift"($P655)
.annotate 'line', 287
    goto if_640_end
  if_640:
.annotate 'line', 285
    find_lex $P644, "$fixup"
    unless_null $P644, vivify_787
    new $P644, "Undef"
  vivify_787:
    find_lex $P645, "self"
    find_lex $P646, "$routine"
    unless_null $P646, vivify_788
    $P646 = root_new ['parrot';'Hash']
  vivify_788:
    set $P647, $P646["compile_time_dummy"]
    unless_null $P647, vivify_789
    new $P647, "Undef"
  vivify_789:
    $P648 = $P645."get_slot_past_for_object"($P647)
    $P644."unshift"($P648)
  if_640_end:
.annotate 'line', 290
    get_hll_global $P656, "GLOBAL"
    nqp_get_package_through_who $P657, $P656, "PAST"
    get_who $P658, $P657
    set $P659, $P658["Op"]
.annotate 'line', 291
    get_hll_global $P660, "GLOBAL"
    nqp_get_package_through_who $P661, $P660, "PAST"
    get_who $P662, $P661
    set $P663, $P662["Val"]
    find_lex $P664, "$routine"
    unless_null $P664, vivify_790
    new $P664, "Undef"
  vivify_790:
    $P665 = $P663."new"($P664 :named("value"))
    find_lex $P666, "$types"
    unless_null $P666, vivify_791
    new $P666, "Undef"
  vivify_791:
    find_lex $P667, "$definednesses"
    unless_null $P667, vivify_792
    new $P667, "Undef"
  vivify_792:
    $P668 = $P659."new"($P665, $P666, $P667, "set_sub_multisig vPPP" :named("pirop"))
.annotate 'line', 290
    store_lex "$des", $P668
.annotate 'line', 293
    find_lex $P669, "self"
    find_lex $P670, "$des"
    unless_null $P670, vivify_793
    new $P670, "Undef"
  vivify_793:
    find_lex $P671, "$fixup"
    unless_null $P671, vivify_794
    new $P671, "Undef"
  vivify_794:
    $P672 = $P669."add_event"($P670 :named("deserialize_past"), $P671 :named("fixup_past"))
.annotate 'line', 280
    .return ($P672)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "pkg_set_body_block" :anon :subid("30_1307873304.82979") :outer("13_1307873304.82979")
    .param pmc param_674
    .param pmc param_675
    .param pmc param_676
.annotate 'line', 297
    .const 'Sub' $P687 = "31_1307873304.82979" 
    capture_lex $P687
    .lex "self", param_674
    .lex "$obj", param_675
    .lex "$body_past", param_676
.annotate 'line', 308
    new $P677, "Undef"
    .lex "$fixups", $P677
.annotate 'line', 309
    new $P678, "Undef"
    .lex "$dummy", $P678
.annotate 'line', 344
    new $P679, "Undef"
    .lex "$slot_past", $P679
.annotate 'line', 345
    new $P680, "Undef"
    .lex "$des", $P680
.annotate 'line', 308
    get_hll_global $P681, "GLOBAL"
    nqp_get_package_through_who $P682, $P681, "PAST"
    get_who $P683, $P682
    set $P684, $P683["Stmts"]
    $P685 = $P684."new"()
    store_lex "$fixups", $P685
.annotate 'line', 309
    .const 'Sub' $P687 = "31_1307873304.82979" 
    newclosure $P758, $P687
    store_lex "$dummy", $P758
.annotate 'line', 341
    find_lex $P759, "$obj"
    unless_null $P759, vivify_812
    new $P759, "Undef"
  vivify_812:
    get_how $P760, $P759
    find_lex $P761, "$obj"
    unless_null $P761, vivify_813
    new $P761, "Undef"
  vivify_813:
    find_lex $P762, "$dummy"
    unless_null $P762, vivify_814
    new $P762, "Undef"
  vivify_814:
    $P760."set_body_block"($P761, $P762)
.annotate 'line', 344
    find_lex $P763, "self"
    find_lex $P764, "$obj"
    unless_null $P764, vivify_815
    new $P764, "Undef"
  vivify_815:
    $P765 = $P763."get_slot_past_for_object"($P764)
    store_lex "$slot_past", $P765
.annotate 'line', 345
    get_hll_global $P766, "GLOBAL"
    nqp_get_package_through_who $P767, $P766, "PAST"
    get_who $P768, $P767
    set $P769, $P768["Op"]
.annotate 'line', 347
    get_hll_global $P770, "GLOBAL"
    nqp_get_package_through_who $P771, $P770, "PAST"
    get_who $P772, $P771
    set $P773, $P772["Op"]
    find_lex $P774, "$slot_past"
    unless_null $P774, vivify_816
    new $P774, "Undef"
  vivify_816:
    $P775 = $P773."new"($P774, "get_how PP" :named("pirop"))
    find_lex $P776, "$slot_past"
    unless_null $P776, vivify_817
    new $P776, "Undef"
  vivify_817:
.annotate 'line', 349
    get_hll_global $P777, "GLOBAL"
    nqp_get_package_through_who $P778, $P777, "PAST"
    get_who $P779, $P778
    set $P780, $P779["Val"]
    find_lex $P781, "$body_past"
    unless_null $P781, vivify_818
    new $P781, "Undef"
  vivify_818:
    $P782 = $P780."new"($P781 :named("value"))
    $P783 = $P769."new"($P775, $P776, $P782, "callmethod" :named("pasttype"), "set_body_block" :named("name"))
.annotate 'line', 345
    store_lex "$des", $P783
.annotate 'line', 352
    find_lex $P784, "self"
    find_lex $P785, "$des"
    unless_null $P785, vivify_819
    new $P785, "Undef"
  vivify_819:
    find_lex $P786, "$fixups"
    unless_null $P786, vivify_820
    new $P786, "Undef"
  vivify_820:
    $P787 = $P784."add_event"($P785 :named("deserialize_past"), $P786 :named("fixup_past"))
.annotate 'line', 297
    .return ($P787)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.include "except_types.pasm"
.sub "_block686"  :anon :subid("31_1307873304.82979") :outer("30_1307873304.82979")
    .param pmc param_688 :slurpy
.annotate 'line', 309
    .const 'Sub' $P726 = "33_1307873304.82979" 
    capture_lex $P726
    .const 'Sub' $P706 = "32_1307873304.82979" 
    capture_lex $P706
    .lex "@type_args", param_688
.annotate 'line', 311
    new $P689, "Undef"
    .lex "$invoke_body", $P689
    get_hll_global $P690, "GLOBAL"
    nqp_get_package_through_who $P691, $P690, "PAST"
    get_who $P692, $P691
    set $P693, $P692["Op"]
.annotate 'line', 313
    get_hll_global $P694, "GLOBAL"
    nqp_get_package_through_who $P695, $P694, "PAST"
    get_who $P696, $P695
    set $P697, $P696["Val"]
    find_lex $P698, "$body_past"
    unless_null $P698, vivify_795
    new $P698, "Undef"
  vivify_795:
    $P699 = $P697."new"($P698 :named("value"))
    $P700 = $P693."new"($P699, "call" :named("pasttype"))
.annotate 'line', 311
    store_lex "$invoke_body", $P700
.annotate 'line', 315
    find_lex $P702, "@type_args"
    unless_null $P702, vivify_796
    $P702 = root_new ['parrot';'ResizablePMCArray']
  vivify_796:
    defined $I703, $P702
    unless $I703, for_undef_797
    iter $P701, $P702
    new $P714, 'ExceptionHandler'
    set_label $P714, loop713_handler
    $P714."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P714
  loop713_test:
    unless $P701, loop713_done
    shift $P704, $P701
  loop713_redo:
    .const 'Sub' $P706 = "32_1307873304.82979" 
    capture_lex $P706
    $P706($P704)
  loop713_next:
    goto loop713_test
  loop713_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P715, exception, 'type'
    eq $P715, .CONTROL_LOOP_NEXT, loop713_next
    eq $P715, .CONTROL_LOOP_REDO, loop713_redo
  loop713_done:
    pop_eh 
  for_undef_797:
.annotate 'line', 318
    find_lex $P716, "$fixups"
    unless_null $P716, vivify_800
    new $P716, "Undef"
  vivify_800:
    find_lex $P717, "$invoke_body"
    unless_null $P717, vivify_801
    new $P717, "Undef"
  vivify_801:
    $P716."push"($P717)
.annotate 'line', 321
    find_lex $P719, "$obj"
    unless_null $P719, vivify_802
    new $P719, "Undef"
  vivify_802:
    get_how $P720, $P719
    find_lex $P721, "$obj"
    unless_null $P721, vivify_803
    new $P721, "Undef"
  vivify_803:
    $P722 = $P720."methods"($P721, 1 :named("local"))
    defined $I723, $P722
    unless $I723, for_undef_804
    iter $P718, $P722
    new $P756, 'ExceptionHandler'
    set_label $P756, loop755_handler
    $P756."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P756
  loop755_test:
    unless $P718, loop755_done
    shift $P724, $P718
  loop755_redo:
    .const 'Sub' $P726 = "33_1307873304.82979" 
    capture_lex $P726
    $P726($P724)
  loop755_next:
    goto loop755_test
  loop755_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P757, exception, 'type'
    eq $P757, .CONTROL_LOOP_NEXT, loop755_next
    eq $P757, .CONTROL_LOOP_REDO, loop755_redo
  loop755_done:
    pop_eh 
  for_undef_804:
.annotate 'line', 309
    .return ($P718)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block705"  :anon :subid("32_1307873304.82979") :outer("31_1307873304.82979")
    .param pmc param_707
.annotate 'line', 315
    .lex "$_", param_707
.annotate 'line', 316
    find_lex $P708, "$invoke_body"
    unless_null $P708, vivify_798
    new $P708, "Undef"
  vivify_798:
    find_lex $P709, "self"
    find_lex $P710, "$_"
    unless_null $P710, vivify_799
    new $P710, "Undef"
  vivify_799:
    $P711 = $P709."get_slot_past_for_object"($P710)
    $P712 = $P708."push"($P711)
.annotate 'line', 315
    .return ($P712)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block725"  :anon :subid("33_1307873304.82979") :outer("31_1307873304.82979")
    .param pmc param_727
.annotate 'line', 321
    .const 'Sub' $P730 = "34_1307873304.82979" 
    capture_lex $P730
    .lex "$_", param_727
.annotate 'line', 322
    find_lex $P728, "$_"
    unless_null $P728, vivify_805
    new $P728, "Undef"
  vivify_805:
    .const 'Sub' $P730 = "34_1307873304.82979" 
    newclosure $P754, $P730
    setprop $P728, "REIFY_CALLBACK", $P754
.annotate 'line', 321
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block729"  :anon :subid("34_1307873304.82979") :outer("33_1307873304.82979")
    .param pmc param_731
.annotate 'line', 322
    .lex "$meth", param_731
.annotate 'line', 324
    new $P732, "Undef"
    .lex "$clone", $P732
    find_lex $P733, "$meth"
    unless_null $P733, vivify_806
    new $P733, "Undef"
  vivify_806:
    clone $P734, $P733
    store_lex "$clone", $P734
.annotate 'line', 325
    find_lex $P735, "self"
    find_lex $P736, "$clone"
    unless_null $P736, vivify_807
    new $P736, "Undef"
  vivify_807:
    $P735."add_code"($P736)
.annotate 'line', 328
    find_lex $P737, "$fixups"
    unless_null $P737, vivify_808
    new $P737, "Undef"
  vivify_808:
    get_hll_global $P738, "GLOBAL"
    nqp_get_package_through_who $P739, $P738, "PAST"
    get_who $P740, $P739
    set $P741, $P740["Op"]
.annotate 'line', 330
    find_lex $P742, "self"
    find_lex $P743, "$clone"
    unless_null $P743, vivify_809
    new $P743, "Undef"
  vivify_809:
    $P744 = $P742."get_slot_past_for_object"($P743)
.annotate 'line', 331
    get_hll_global $P745, "GLOBAL"
    nqp_get_package_through_who $P746, $P745, "PAST"
    get_who $P747, $P746
    set $P748, $P747["Val"]
    find_lex $P749, "$meth"
    unless_null $P749, vivify_810
    new $P749, "Undef"
  vivify_810:
    getprop $P750, "PAST", $P749
    $P751 = $P748."new"($P750 :named("value"))
    $P752 = $P741."new"($P744, $P751, "assign vPP" :named("pirop"))
.annotate 'line', 328
    $P737."push"($P752)
    find_lex $P753, "$clone"
    unless_null $P753, vivify_811
    new $P753, "Undef"
  vivify_811:
.annotate 'line', 322
    .return ($P753)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "pkg_add_parent_or_role" :anon :subid("35_1307873304.82979") :outer("13_1307873304.82979")
    .param pmc param_789
    .param pmc param_790
    .param pmc param_791
    .param pmc param_792
.annotate 'line', 357
    .lex "self", param_789
    .lex "$obj", param_790
    .lex "$meta_method_name", param_791
    .lex "$to_add", param_792
.annotate 'line', 362
    new $P793, "Undef"
    .lex "$slot_past", $P793
.annotate 'line', 359
    find_lex $P794, "$obj"
    unless_null $P794, vivify_821
    new $P794, "Undef"
  vivify_821:
    get_how $P795, $P794
    find_lex $P796, "$obj"
    unless_null $P796, vivify_822
    new $P796, "Undef"
  vivify_822:
    find_lex $P797, "$to_add"
    unless_null $P797, vivify_823
    new $P797, "Undef"
  vivify_823:
    find_lex $P798, "$meta_method_name"
    unless_null $P798, vivify_824
    new $P798, "Undef"
  vivify_824:
    set $S799, $P798
    $P795.$S799($P796, $P797)
.annotate 'line', 362
    find_lex $P800, "self"
    find_lex $P801, "$obj"
    unless_null $P801, vivify_825
    new $P801, "Undef"
  vivify_825:
    $P802 = $P800."get_slot_past_for_object"($P801)
    store_lex "$slot_past", $P802
.annotate 'line', 363
    find_lex $P803, "self"
    get_hll_global $P804, "GLOBAL"
    nqp_get_package_through_who $P805, $P804, "PAST"
    get_who $P806, $P805
    set $P807, $P806["Op"]
    find_lex $P808, "$meta_method_name"
    unless_null $P808, vivify_826
    new $P808, "Undef"
  vivify_826:
.annotate 'line', 365
    get_hll_global $P809, "GLOBAL"
    nqp_get_package_through_who $P810, $P809, "PAST"
    get_who $P811, $P810
    set $P812, $P811["Op"]
    find_lex $P813, "$slot_past"
    unless_null $P813, vivify_827
    new $P813, "Undef"
  vivify_827:
    $P814 = $P812."new"($P813, "get_how PP" :named("pirop"))
    find_lex $P815, "$slot_past"
    unless_null $P815, vivify_828
    new $P815, "Undef"
  vivify_828:
.annotate 'line', 367
    find_lex $P816, "self"
    find_lex $P817, "$to_add"
    unless_null $P817, vivify_829
    new $P817, "Undef"
  vivify_829:
    $P818 = $P816."get_object_sc_ref_past"($P817)
    $P819 = $P807."new"($P814, $P815, $P818, "callmethod" :named("pasttype"), $P808 :named("name"))
.annotate 'line', 363
    $P820 = $P803."add_event"($P819 :named("deserialize_past"))
.annotate 'line', 357
    .return ($P820)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "pkg_add_parrot_vtable_handler_mapping" :anon :subid("36_1307873304.82979") :outer("13_1307873304.82979")
    .param pmc param_822
    .param pmc param_823
    .param pmc param_824
    .param pmc param_825
.annotate 'line', 371
    .lex "self", param_822
    .lex "$obj", param_823
    .lex "$name", param_824
    .lex "$att_name", param_825
.annotate 'line', 376
    new $P826, "Undef"
    .lex "$slot_past", $P826
.annotate 'line', 373
    find_lex $P827, "$obj"
    unless_null $P827, vivify_830
    new $P827, "Undef"
  vivify_830:
    get_how $P828, $P827
    find_lex $P829, "$obj"
    unless_null $P829, vivify_831
    new $P829, "Undef"
  vivify_831:
    find_lex $P830, "$name"
    unless_null $P830, vivify_832
    new $P830, "Undef"
  vivify_832:
    find_lex $P831, "$att_name"
    unless_null $P831, vivify_833
    new $P831, "Undef"
  vivify_833:
    $P828."add_parrot_vtable_handler_mapping"($P829, $P830, $P831)
.annotate 'line', 376
    find_lex $P832, "self"
    find_lex $P833, "$obj"
    unless_null $P833, vivify_834
    new $P833, "Undef"
  vivify_834:
    $P834 = $P832."get_slot_past_for_object"($P833)
    store_lex "$slot_past", $P834
.annotate 'line', 377
    find_lex $P835, "self"
    get_hll_global $P836, "GLOBAL"
    nqp_get_package_through_who $P837, $P836, "PAST"
    get_who $P838, $P837
    set $P839, $P838["Op"]
.annotate 'line', 379
    get_hll_global $P840, "GLOBAL"
    nqp_get_package_through_who $P841, $P840, "PAST"
    get_who $P842, $P841
    set $P843, $P842["Op"]
    find_lex $P844, "$slot_past"
    unless_null $P844, vivify_835
    new $P844, "Undef"
  vivify_835:
    $P845 = $P843."new"($P844, "get_how PP" :named("pirop"))
    find_lex $P846, "$slot_past"
    unless_null $P846, vivify_836
    new $P846, "Undef"
  vivify_836:
    find_lex $P847, "$name"
    unless_null $P847, vivify_837
    new $P847, "Undef"
  vivify_837:
    find_lex $P848, "$att_name"
    unless_null $P848, vivify_838
    new $P848, "Undef"
  vivify_838:
    $P849 = $P839."new"($P845, $P846, $P847, $P848, "callmethod" :named("pasttype"), "add_parrot_vtable_handler_mapping" :named("name"))
.annotate 'line', 377
    $P850 = $P835."add_event"($P849 :named("deserialize_past"))
.annotate 'line', 371
    .return ($P850)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "pkg_compose" :anon :subid("37_1307873304.82979") :outer("13_1307873304.82979")
    .param pmc param_852
    .param pmc param_853
.annotate 'line', 386
    .lex "self", param_852
    .lex "$obj", param_853
.annotate 'line', 391
    new $P854, "Undef"
    .lex "$slot_past", $P854
.annotate 'line', 388
    find_lex $P855, "$obj"
    unless_null $P855, vivify_839
    new $P855, "Undef"
  vivify_839:
    get_how $P856, $P855
    find_lex $P857, "$obj"
    unless_null $P857, vivify_840
    new $P857, "Undef"
  vivify_840:
    $P856."compose"($P857)
.annotate 'line', 391
    find_lex $P858, "self"
    find_lex $P859, "$obj"
    unless_null $P859, vivify_841
    new $P859, "Undef"
  vivify_841:
    $P860 = $P858."get_slot_past_for_object"($P859)
    store_lex "$slot_past", $P860
.annotate 'line', 392
    find_lex $P861, "self"
    get_hll_global $P862, "GLOBAL"
    nqp_get_package_through_who $P863, $P862, "PAST"
    get_who $P864, $P863
    set $P865, $P864["Op"]
.annotate 'line', 394
    get_hll_global $P866, "GLOBAL"
    nqp_get_package_through_who $P867, $P866, "PAST"
    get_who $P868, $P867
    set $P869, $P868["Op"]
    find_lex $P870, "$slot_past"
    unless_null $P870, vivify_842
    new $P870, "Undef"
  vivify_842:
    $P871 = $P869."new"($P870, "get_how PP" :named("pirop"))
    find_lex $P872, "$slot_past"
    unless_null $P872, vivify_843
    new $P872, "Undef"
  vivify_843:
    $P873 = $P865."new"($P871, $P872, "callmethod" :named("pasttype"), "compose" :named("name"))
.annotate 'line', 392
    $P874 = $P861."add_event"($P873 :named("deserialize_past"))
.annotate 'line', 386
    .return ($P874)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.include "except_types.pasm"
.sub "to_past" :anon :subid("38_1307873304.82979") :outer("13_1307873304.82979")
    .param pmc param_876
.annotate 'line', 401
    .const 'Sub' $P895 = "39_1307873304.82979" 
    capture_lex $P895
    .lex "self", param_876
.annotate 'line', 402
    new $P877, "Undef"
    .lex "$des", $P877
.annotate 'line', 403
    new $P878, "Undef"
    .lex "$fix", $P878
.annotate 'line', 402
    get_hll_global $P879, "GLOBAL"
    nqp_get_package_through_who $P880, $P879, "PAST"
    get_who $P881, $P880
    set $P882, $P881["Stmts"]
    $P883 = $P882."new"()
    store_lex "$des", $P883
.annotate 'line', 403
    get_hll_global $P884, "GLOBAL"
    nqp_get_package_through_who $P885, $P884, "PAST"
    get_who $P886, $P885
    set $P887, $P886["Stmts"]
    $P888 = $P887."new"()
    store_lex "$fix", $P888
.annotate 'line', 404
    find_lex $P890, "self"
    $P891 = $P890."event_stream"()
    defined $I892, $P891
    unless $I892, for_undef_844
    iter $P889, $P891
    new $P914, 'ExceptionHandler'
    set_label $P914, loop913_handler
    $P914."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P914
  loop913_test:
    unless $P889, loop913_done
    shift $P893, $P889
  loop913_redo:
    .const 'Sub' $P895 = "39_1307873304.82979" 
    capture_lex $P895
    $P895($P893)
  loop913_next:
    goto loop913_test
  loop913_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P915, exception, 'type'
    eq $P915, .CONTROL_LOOP_NEXT, loop913_next
    eq $P915, .CONTROL_LOOP_REDO, loop913_redo
  loop913_done:
    pop_eh 
  for_undef_844:
.annotate 'line', 408
    find_dynamic_lex $P916, "$/"
    get_hll_global $P917, "GLOBAL"
    nqp_get_package_through_who $P918, $P917, "PAST"
    get_who $P919, $P918
    set $P920, $P919["Op"]
.annotate 'line', 410
    get_hll_global $P921, "GLOBAL"
    nqp_get_package_through_who $P922, $P921, "PAST"
    get_who $P923, $P922
    set $P924, $P923["Op"]
.annotate 'line', 412
    get_hll_global $P925, "GLOBAL"
    nqp_get_package_through_who $P926, $P925, "PAST"
    get_who $P927, $P926
    set $P928, $P927["Op"]
    find_lex $P929, "self"
    $P930 = $P929."handle"()
    $P931 = $P928."new"($P930, "nqp_get_sc Ps" :named("pirop"))
    $P932 = $P924."new"($P931, "isnull IP" :named("pirop"))
.annotate 'line', 414
    get_hll_global $P933, "GLOBAL"
    nqp_get_package_through_who $P934, $P933, "PAST"
    get_who $P935, $P934
    set $P936, $P935["Stmts"]
.annotate 'line', 415
    get_hll_global $P937, "GLOBAL"
    nqp_get_package_through_who $P938, $P937, "PAST"
    get_who $P939, $P938
    set $P940, $P939["Op"]
    $P941 = $P940."new"("nqp_dynop_setup v" :named("pirop"))
.annotate 'line', 416
    get_hll_global $P942, "GLOBAL"
    nqp_get_package_through_who $P943, $P942, "PAST"
    get_who $P944, $P943
    set $P945, $P944["Op"]
.annotate 'line', 418
    get_hll_global $P946, "GLOBAL"
    nqp_get_package_through_who $P947, $P946, "PAST"
    get_who $P948, $P947
    set $P949, $P948["Op"]
    $P950 = $P949."new"("getinterp P" :named("pirop"))
.annotate 'line', 419
    get_hll_global $P951, "GLOBAL"
    nqp_get_package_through_who $P952, $P951, "PAST"
    get_who $P953, $P952
    set $P954, $P953["Op"]
    $P955 = $P954."new"("LexPad", "get_class Ps" :named("pirop"))
.annotate 'line', 420
    get_hll_global $P956, "GLOBAL"
    nqp_get_package_through_who $P957, $P956, "PAST"
    get_who $P958, $P957
    set $P959, $P958["Op"]
    $P960 = $P959."new"("NQPLexPad", "get_class Ps" :named("pirop"))
    $P961 = $P945."new"($P950, $P955, $P960, "callmethod" :named("pasttype"), "hll_map" :named("name"))
.annotate 'line', 422
    get_hll_global $P962, "GLOBAL"
    nqp_get_package_through_who $P963, $P962, "PAST"
    get_who $P964, $P963
    set $P965, $P964["Op"]
.annotate 'line', 424
    get_hll_global $P966, "GLOBAL"
    nqp_get_package_through_who $P967, $P966, "PAST"
    get_who $P968, $P967
    set $P969, $P968["Var"]
    $P970 = $P969."new"("cur_sc" :named("name"), "register" :named("scope"), 1 :named("isdecl"))
.annotate 'line', 425
    get_hll_global $P971, "GLOBAL"
    nqp_get_package_through_who $P972, $P971, "PAST"
    get_who $P973, $P972
    set $P974, $P973["Op"]
    find_lex $P975, "self"
    $P976 = $P975."handle"()
    $P977 = $P974."new"($P976, "nqp_create_sc Ps" :named("pirop"))
    $P978 = $P965."new"($P970, $P977, "bind_6model" :named("pasttype"))
.annotate 'line', 422
    find_lex $P979, "$des"
    unless_null $P979, vivify_851
    new $P979, "Undef"
  vivify_851:
    $P980 = $P936."new"($P941, $P961, $P978, $P979)
.annotate 'line', 414
    find_lex $P981, "$fix"
    unless_null $P981, vivify_852
    new $P981, "Undef"
  vivify_852:
    $P982 = $P920."new"($P932, $P980, $P981, "if" :named("pasttype"))
.annotate 'line', 408
    $P983 = $P916."!make"($P982)
.annotate 'line', 401
    .return ($P983)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block894"  :anon :subid("39_1307873304.82979") :outer("38_1307873304.82979")
    .param pmc param_896
.annotate 'line', 404
    .lex "$_", param_896
.annotate 'line', 405
    find_lex $P898, "$_"
    unless_null $P898, vivify_845
    new $P898, "Undef"
  vivify_845:
    $P899 = $P898."deserialize_past"()
    defined $I900, $P899
    unless $I900, if_897_end
    find_lex $P901, "$des"
    unless_null $P901, vivify_846
    new $P901, "Undef"
  vivify_846:
    find_lex $P902, "$_"
    unless_null $P902, vivify_847
    new $P902, "Undef"
  vivify_847:
    $P903 = $P902."deserialize_past"()
    $P901."push"($P903)
  if_897_end:
.annotate 'line', 406
    find_lex $P906, "$_"
    unless_null $P906, vivify_848
    new $P906, "Undef"
  vivify_848:
    $P907 = $P906."fixup_past"()
    defined $I908, $P907
    if $I908, if_905
    new $P904, 'Integer'
    set $P904, $I908
    goto if_905_end
  if_905:
    find_lex $P909, "$fix"
    unless_null $P909, vivify_849
    new $P909, "Undef"
  vivify_849:
    find_lex $P910, "$_"
    unless_null $P910, vivify_850
    new $P910, "Undef"
  vivify_850:
    $P911 = $P910."fixup_past"()
    $P912 = $P909."push"($P911)
    set $P904, $P912
  if_905_end:
.annotate 'line', 404
    .return ($P904)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block985"  :subid("40_1307873304.82979") :outer("10_1307873304.82979")
.annotate 'line', 435
    .const 'Sub' $P2863 = "416_1307873304.82979" 
    capture_lex $P2863
    .const 'Sub' $P2861 = "415_1307873304.82979" 
    capture_lex $P2861
    .const 'Sub' $P2857 = "414_1307873304.82979" 
    capture_lex $P2857
    .const 'Sub' $P2855 = "413_1307873304.82979" 
    capture_lex $P2855
    .const 'Sub' $P2851 = "412_1307873304.82979" 
    capture_lex $P2851
    .const 'Sub' $P2849 = "411_1307873304.82979" 
    capture_lex $P2849
    .const 'Sub' $P2845 = "410_1307873304.82979" 
    capture_lex $P2845
    .const 'Sub' $P2843 = "409_1307873304.82979" 
    capture_lex $P2843
    .const 'Sub' $P2839 = "408_1307873304.82979" 
    capture_lex $P2839
    .const 'Sub' $P2837 = "407_1307873304.82979" 
    capture_lex $P2837
    .const 'Sub' $P2827 = "405_1307873304.82979" 
    capture_lex $P2827
    .const 'Sub' $P2824 = "404_1307873304.82979" 
    capture_lex $P2824
    .const 'Sub' $P2820 = "403_1307873304.82979" 
    capture_lex $P2820
    .const 'Sub' $P2817 = "402_1307873304.82979" 
    capture_lex $P2817
    .const 'Sub' $P2813 = "401_1307873304.82979" 
    capture_lex $P2813
    .const 'Sub' $P2810 = "400_1307873304.82979" 
    capture_lex $P2810
    .const 'Sub' $P2806 = "399_1307873304.82979" 
    capture_lex $P2806
    .const 'Sub' $P2803 = "398_1307873304.82979" 
    capture_lex $P2803
    .const 'Sub' $P2799 = "397_1307873304.82979" 
    capture_lex $P2799
    .const 'Sub' $P2796 = "396_1307873304.82979" 
    capture_lex $P2796
    .const 'Sub' $P2793 = "395_1307873304.82979" 
    capture_lex $P2793
    .const 'Sub' $P2790 = "394_1307873304.82979" 
    capture_lex $P2790
    .const 'Sub' $P2786 = "393_1307873304.82979" 
    capture_lex $P2786
    .const 'Sub' $P2783 = "392_1307873304.82979" 
    capture_lex $P2783
    .const 'Sub' $P2779 = "391_1307873304.82979" 
    capture_lex $P2779
    .const 'Sub' $P2776 = "390_1307873304.82979" 
    capture_lex $P2776
    .const 'Sub' $P2772 = "389_1307873304.82979" 
    capture_lex $P2772
    .const 'Sub' $P2769 = "388_1307873304.82979" 
    capture_lex $P2769
    .const 'Sub' $P2765 = "387_1307873304.82979" 
    capture_lex $P2765
    .const 'Sub' $P2762 = "386_1307873304.82979" 
    capture_lex $P2762
    .const 'Sub' $P2758 = "385_1307873304.82979" 
    capture_lex $P2758
    .const 'Sub' $P2755 = "384_1307873304.82979" 
    capture_lex $P2755
    .const 'Sub' $P2751 = "383_1307873304.82979" 
    capture_lex $P2751
    .const 'Sub' $P2748 = "382_1307873304.82979" 
    capture_lex $P2748
    .const 'Sub' $P2744 = "381_1307873304.82979" 
    capture_lex $P2744
    .const 'Sub' $P2741 = "380_1307873304.82979" 
    capture_lex $P2741
    .const 'Sub' $P2737 = "379_1307873304.82979" 
    capture_lex $P2737
    .const 'Sub' $P2734 = "378_1307873304.82979" 
    capture_lex $P2734
    .const 'Sub' $P2730 = "377_1307873304.82979" 
    capture_lex $P2730
    .const 'Sub' $P2727 = "376_1307873304.82979" 
    capture_lex $P2727
    .const 'Sub' $P2723 = "375_1307873304.82979" 
    capture_lex $P2723
    .const 'Sub' $P2720 = "374_1307873304.82979" 
    capture_lex $P2720
    .const 'Sub' $P2716 = "373_1307873304.82979" 
    capture_lex $P2716
    .const 'Sub' $P2713 = "372_1307873304.82979" 
    capture_lex $P2713
    .const 'Sub' $P2709 = "371_1307873304.82979" 
    capture_lex $P2709
    .const 'Sub' $P2706 = "370_1307873304.82979" 
    capture_lex $P2706
    .const 'Sub' $P2702 = "369_1307873304.82979" 
    capture_lex $P2702
    .const 'Sub' $P2699 = "368_1307873304.82979" 
    capture_lex $P2699
    .const 'Sub' $P2695 = "367_1307873304.82979" 
    capture_lex $P2695
    .const 'Sub' $P2692 = "366_1307873304.82979" 
    capture_lex $P2692
    .const 'Sub' $P2688 = "365_1307873304.82979" 
    capture_lex $P2688
    .const 'Sub' $P2685 = "364_1307873304.82979" 
    capture_lex $P2685
    .const 'Sub' $P2681 = "363_1307873304.82979" 
    capture_lex $P2681
    .const 'Sub' $P2678 = "362_1307873304.82979" 
    capture_lex $P2678
    .const 'Sub' $P2674 = "361_1307873304.82979" 
    capture_lex $P2674
    .const 'Sub' $P2671 = "360_1307873304.82979" 
    capture_lex $P2671
    .const 'Sub' $P2667 = "359_1307873304.82979" 
    capture_lex $P2667
    .const 'Sub' $P2664 = "358_1307873304.82979" 
    capture_lex $P2664
    .const 'Sub' $P2660 = "357_1307873304.82979" 
    capture_lex $P2660
    .const 'Sub' $P2657 = "356_1307873304.82979" 
    capture_lex $P2657
    .const 'Sub' $P2653 = "355_1307873304.82979" 
    capture_lex $P2653
    .const 'Sub' $P2650 = "354_1307873304.82979" 
    capture_lex $P2650
    .const 'Sub' $P2646 = "353_1307873304.82979" 
    capture_lex $P2646
    .const 'Sub' $P2643 = "352_1307873304.82979" 
    capture_lex $P2643
    .const 'Sub' $P2639 = "351_1307873304.82979" 
    capture_lex $P2639
    .const 'Sub' $P2636 = "350_1307873304.82979" 
    capture_lex $P2636
    .const 'Sub' $P2632 = "349_1307873304.82979" 
    capture_lex $P2632
    .const 'Sub' $P2629 = "348_1307873304.82979" 
    capture_lex $P2629
    .const 'Sub' $P2625 = "347_1307873304.82979" 
    capture_lex $P2625
    .const 'Sub' $P2622 = "346_1307873304.82979" 
    capture_lex $P2622
    .const 'Sub' $P2618 = "345_1307873304.82979" 
    capture_lex $P2618
    .const 'Sub' $P2615 = "344_1307873304.82979" 
    capture_lex $P2615
    .const 'Sub' $P2611 = "343_1307873304.82979" 
    capture_lex $P2611
    .const 'Sub' $P2608 = "342_1307873304.82979" 
    capture_lex $P2608
    .const 'Sub' $P2604 = "341_1307873304.82979" 
    capture_lex $P2604
    .const 'Sub' $P2601 = "340_1307873304.82979" 
    capture_lex $P2601
    .const 'Sub' $P2597 = "339_1307873304.82979" 
    capture_lex $P2597
    .const 'Sub' $P2594 = "338_1307873304.82979" 
    capture_lex $P2594
    .const 'Sub' $P2590 = "337_1307873304.82979" 
    capture_lex $P2590
    .const 'Sub' $P2588 = "336_1307873304.82979" 
    capture_lex $P2588
    .const 'Sub' $P2584 = "335_1307873304.82979" 
    capture_lex $P2584
    .const 'Sub' $P2581 = "334_1307873304.82979" 
    capture_lex $P2581
    .const 'Sub' $P2577 = "333_1307873304.82979" 
    capture_lex $P2577
    .const 'Sub' $P2574 = "332_1307873304.82979" 
    capture_lex $P2574
    .const 'Sub' $P2570 = "331_1307873304.82979" 
    capture_lex $P2570
    .const 'Sub' $P2567 = "330_1307873304.82979" 
    capture_lex $P2567
    .const 'Sub' $P2563 = "329_1307873304.82979" 
    capture_lex $P2563
    .const 'Sub' $P2560 = "328_1307873304.82979" 
    capture_lex $P2560
    .const 'Sub' $P2556 = "327_1307873304.82979" 
    capture_lex $P2556
    .const 'Sub' $P2553 = "326_1307873304.82979" 
    capture_lex $P2553
    .const 'Sub' $P2549 = "325_1307873304.82979" 
    capture_lex $P2549
    .const 'Sub' $P2546 = "324_1307873304.82979" 
    capture_lex $P2546
    .const 'Sub' $P2542 = "323_1307873304.82979" 
    capture_lex $P2542
    .const 'Sub' $P2539 = "322_1307873304.82979" 
    capture_lex $P2539
    .const 'Sub' $P2535 = "321_1307873304.82979" 
    capture_lex $P2535
    .const 'Sub' $P2532 = "320_1307873304.82979" 
    capture_lex $P2532
    .const 'Sub' $P2529 = "319_1307873304.82979" 
    capture_lex $P2529
    .const 'Sub' $P2526 = "318_1307873304.82979" 
    capture_lex $P2526
    .const 'Sub' $P2523 = "317_1307873304.82979" 
    capture_lex $P2523
    .const 'Sub' $P2521 = "316_1307873304.82979" 
    capture_lex $P2521
    .const 'Sub' $P2518 = "315_1307873304.82979" 
    capture_lex $P2518
    .const 'Sub' $P2515 = "314_1307873304.82979" 
    capture_lex $P2515
    .const 'Sub' $P2512 = "313_1307873304.82979" 
    capture_lex $P2512
    .const 'Sub' $P2509 = "312_1307873304.82979" 
    capture_lex $P2509
    .const 'Sub' $P2506 = "311_1307873304.82979" 
    capture_lex $P2506
    .const 'Sub' $P2504 = "310_1307873304.82979" 
    capture_lex $P2504
    .const 'Sub' $P2501 = "309_1307873304.82979" 
    capture_lex $P2501
    .const 'Sub' $P2499 = "308_1307873304.82979" 
    capture_lex $P2499
    .const 'Sub' $P2496 = "307_1307873304.82979" 
    capture_lex $P2496
    .const 'Sub' $P2493 = "306_1307873304.82979" 
    capture_lex $P2493
    .const 'Sub' $P2488 = "305_1307873304.82979" 
    capture_lex $P2488
    .const 'Sub' $P2485 = "304_1307873304.82979" 
    capture_lex $P2485
    .const 'Sub' $P2479 = "303_1307873304.82979" 
    capture_lex $P2479
    .const 'Sub' $P2477 = "302_1307873304.82979" 
    capture_lex $P2477
    .const 'Sub' $P2474 = "301_1307873304.82979" 
    capture_lex $P2474
    .const 'Sub' $P2472 = "300_1307873304.82979" 
    capture_lex $P2472
    .const 'Sub' $P2469 = "299_1307873304.82979" 
    capture_lex $P2469
    .const 'Sub' $P2467 = "298_1307873304.82979" 
    capture_lex $P2467
    .const 'Sub' $P2464 = "297_1307873304.82979" 
    capture_lex $P2464
    .const 'Sub' $P2461 = "296_1307873304.82979" 
    capture_lex $P2461
    .const 'Sub' $P2456 = "295_1307873304.82979" 
    capture_lex $P2456
    .const 'Sub' $P2453 = "294_1307873304.82979" 
    capture_lex $P2453
    .const 'Sub' $P2448 = "293_1307873304.82979" 
    capture_lex $P2448
    .const 'Sub' $P2446 = "292_1307873304.82979" 
    capture_lex $P2446
    .const 'Sub' $P2443 = "291_1307873304.82979" 
    capture_lex $P2443
    .const 'Sub' $P2441 = "290_1307873304.82979" 
    capture_lex $P2441
    .const 'Sub' $P2438 = "289_1307873304.82979" 
    capture_lex $P2438
    .const 'Sub' $P2436 = "288_1307873304.82979" 
    capture_lex $P2436
    .const 'Sub' $P2433 = "287_1307873304.82979" 
    capture_lex $P2433
    .const 'Sub' $P2430 = "286_1307873304.82979" 
    capture_lex $P2430
    .const 'Sub' $P2427 = "285_1307873304.82979" 
    capture_lex $P2427
    .const 'Sub' $P2424 = "284_1307873304.82979" 
    capture_lex $P2424
    .const 'Sub' $P2420 = "283_1307873304.82979" 
    capture_lex $P2420
    .const 'Sub' $P2417 = "282_1307873304.82979" 
    capture_lex $P2417
    .const 'Sub' $P2413 = "281_1307873304.82979" 
    capture_lex $P2413
    .const 'Sub' $P2410 = "280_1307873304.82979" 
    capture_lex $P2410
    .const 'Sub' $P2406 = "279_1307873304.82979" 
    capture_lex $P2406
    .const 'Sub' $P2403 = "278_1307873304.82979" 
    capture_lex $P2403
    .const 'Sub' $P2399 = "277_1307873304.82979" 
    capture_lex $P2399
    .const 'Sub' $P2397 = "276_1307873304.82979" 
    capture_lex $P2397
    .const 'Sub' $P2394 = "275_1307873304.82979" 
    capture_lex $P2394
    .const 'Sub' $P2392 = "274_1307873304.82979" 
    capture_lex $P2392
    .const 'Sub' $P2389 = "273_1307873304.82979" 
    capture_lex $P2389
    .const 'Sub' $P2381 = "270_1307873304.82979" 
    capture_lex $P2381
    .const 'Sub' $P2375 = "269_1307873304.82979" 
    capture_lex $P2375
    .const 'Sub' $P2371 = "268_1307873304.82979" 
    capture_lex $P2371
    .const 'Sub' $P2367 = "267_1307873304.82979" 
    capture_lex $P2367
    .const 'Sub' $P2364 = "266_1307873304.82979" 
    capture_lex $P2364
    .const 'Sub' $P2361 = "265_1307873304.82979" 
    capture_lex $P2361
    .const 'Sub' $P2358 = "264_1307873304.82979" 
    capture_lex $P2358
    .const 'Sub' $P2354 = "263_1307873304.82979" 
    capture_lex $P2354
    .const 'Sub' $P2351 = "262_1307873304.82979" 
    capture_lex $P2351
    .const 'Sub' $P2348 = "261_1307873304.82979" 
    capture_lex $P2348
    .const 'Sub' $P2346 = "260_1307873304.82979" 
    capture_lex $P2346
    .const 'Sub' $P2332 = "258_1307873304.82979" 
    capture_lex $P2332
    .const 'Sub' $P2330 = "257_1307873304.82979" 
    capture_lex $P2330
    .const 'Sub' $P2326 = "256_1307873304.82979" 
    capture_lex $P2326
    .const 'Sub' $P2324 = "255_1307873304.82979" 
    capture_lex $P2324
    .const 'Sub' $P2318 = "254_1307873304.82979" 
    capture_lex $P2318
    .const 'Sub' $P2315 = "253_1307873304.82979" 
    capture_lex $P2315
    .const 'Sub' $P2310 = "252_1307873304.82979" 
    capture_lex $P2310
    .const 'Sub' $P2307 = "251_1307873304.82979" 
    capture_lex $P2307
    .const 'Sub' $P2304 = "250_1307873304.82979" 
    capture_lex $P2304
    .const 'Sub' $P2302 = "249_1307873304.82979" 
    capture_lex $P2302
    .const 'Sub' $P2298 = "248_1307873304.82979" 
    capture_lex $P2298
    .const 'Sub' $P2289 = "245_1307873304.82979" 
    capture_lex $P2289
    .const 'Sub' $P2282 = "244_1307873304.82979" 
    capture_lex $P2282
    .const 'Sub' $P2279 = "243_1307873304.82979" 
    capture_lex $P2279
    .const 'Sub' $P2241 = "242_1307873304.82979" 
    capture_lex $P2241
    .const 'Sub' $P2238 = "241_1307873304.82979" 
    capture_lex $P2238
    .const 'Sub' $P2230 = "240_1307873304.82979" 
    capture_lex $P2230
    .const 'Sub' $P2221 = "237_1307873304.82979" 
    capture_lex $P2221
    .const 'Sub' $P2216 = "236_1307873304.82979" 
    capture_lex $P2216
    .const 'Sub' $P2213 = "235_1307873304.82979" 
    capture_lex $P2213
    .const 'Sub' $P2207 = "234_1307873304.82979" 
    capture_lex $P2207
    .const 'Sub' $P2204 = "233_1307873304.82979" 
    capture_lex $P2204
    .const 'Sub' $P2201 = "232_1307873304.82979" 
    capture_lex $P2201
    .const 'Sub' $P2198 = "231_1307873304.82979" 
    capture_lex $P2198
    .const 'Sub' $P2191 = "230_1307873304.82979" 
    capture_lex $P2191
    .const 'Sub' $P2189 = "229_1307873304.82979" 
    capture_lex $P2189
    .const 'Sub' $P2176 = "228_1307873304.82979" 
    capture_lex $P2176
    .const 'Sub' $P2174 = "227_1307873304.82979" 
    capture_lex $P2174
    .const 'Sub' $P2160 = "225_1307873304.82979" 
    capture_lex $P2160
    .const 'Sub' $P2157 = "224_1307873304.82979" 
    capture_lex $P2157
    .const 'Sub' $P2152 = "223_1307873304.82979" 
    capture_lex $P2152
    .const 'Sub' $P2149 = "222_1307873304.82979" 
    capture_lex $P2149
    .const 'Sub' $P2142 = "221_1307873304.82979" 
    capture_lex $P2142
    .const 'Sub' $P2139 = "220_1307873304.82979" 
    capture_lex $P2139
    .const 'Sub' $P2132 = "219_1307873304.82979" 
    capture_lex $P2132
    .const 'Sub' $P2124 = "216_1307873304.82979" 
    capture_lex $P2124
    .const 'Sub' $P2111 = "214_1307873304.82979" 
    capture_lex $P2111
    .const 'Sub' $P2108 = "213_1307873304.82979" 
    capture_lex $P2108
    .const 'Sub' $P2067 = "211_1307873304.82979" 
    capture_lex $P2067
    .const 'Sub' $P2064 = "210_1307873304.82979" 
    capture_lex $P2064
    .const 'Sub' $P2033 = "209_1307873304.82979" 
    capture_lex $P2033
    .const 'Sub' $P2030 = "208_1307873304.82979" 
    capture_lex $P2030
    .const 'Sub' $P2026 = "207_1307873304.82979" 
    capture_lex $P2026
    .const 'Sub' $P2023 = "206_1307873304.82979" 
    capture_lex $P2023
    .const 'Sub' $P2019 = "205_1307873304.82979" 
    capture_lex $P2019
    .const 'Sub' $P2010 = "202_1307873304.82979" 
    capture_lex $P2010
    .const 'Sub' $P1989 = "200_1307873304.82979" 
    capture_lex $P1989
    .const 'Sub' $P1985 = "199_1307873304.82979" 
    capture_lex $P1985
    .const 'Sub' $P1981 = "198_1307873304.82979" 
    capture_lex $P1981
    .const 'Sub' $P1978 = "197_1307873304.82979" 
    capture_lex $P1978
    .const 'Sub' $P1962 = "195_1307873304.82979" 
    capture_lex $P1962
    .const 'Sub' $P1957 = "194_1307873304.82979" 
    capture_lex $P1957
    .const 'Sub' $P1946 = "193_1307873304.82979" 
    capture_lex $P1946
    .const 'Sub' $P1943 = "192_1307873304.82979" 
    capture_lex $P1943
    .const 'Sub' $P1939 = "191_1307873304.82979" 
    capture_lex $P1939
    .const 'Sub' $P1936 = "190_1307873304.82979" 
    capture_lex $P1936
    .const 'Sub' $P1932 = "189_1307873304.82979" 
    capture_lex $P1932
    .const 'Sub' $P1929 = "188_1307873304.82979" 
    capture_lex $P1929
    .const 'Sub' $P1925 = "187_1307873304.82979" 
    capture_lex $P1925
    .const 'Sub' $P1916 = "184_1307873304.82979" 
    capture_lex $P1916
    .const 'Sub' $P1752 = "182_1307873304.82979" 
    capture_lex $P1752
    .const 'Sub' $P1749 = "181_1307873304.82979" 
    capture_lex $P1749
    .const 'Sub' $P1729 = "180_1307873304.82979" 
    capture_lex $P1729
    .const 'Sub' $P1726 = "179_1307873304.82979" 
    capture_lex $P1726
    .const 'Sub' $P1716 = "178_1307873304.82979" 
    capture_lex $P1716
    .const 'Sub' $P1713 = "177_1307873304.82979" 
    capture_lex $P1713
    .const 'Sub' $P1703 = "176_1307873304.82979" 
    capture_lex $P1703
    .const 'Sub' $P1700 = "175_1307873304.82979" 
    capture_lex $P1700
    .const 'Sub' $P1690 = "174_1307873304.82979" 
    capture_lex $P1690
    .const 'Sub' $P1687 = "173_1307873304.82979" 
    capture_lex $P1687
    .const 'Sub' $P1677 = "172_1307873304.82979" 
    capture_lex $P1677
    .const 'Sub' $P1674 = "171_1307873304.82979" 
    capture_lex $P1674
    .const 'Sub' $P1664 = "170_1307873304.82979" 
    capture_lex $P1664
    .const 'Sub' $P1661 = "169_1307873304.82979" 
    capture_lex $P1661
    .const 'Sub' $P1651 = "168_1307873304.82979" 
    capture_lex $P1651
    .const 'Sub' $P1643 = "165_1307873304.82979" 
    capture_lex $P1643
    .const 'Sub' $P1640 = "164_1307873304.82979" 
    capture_lex $P1640
    .const 'Sub' $P1638 = "163_1307873304.82979" 
    capture_lex $P1638
    .const 'Sub' $P1635 = "162_1307873304.82979" 
    capture_lex $P1635
    .const 'Sub' $P1631 = "161_1307873304.82979" 
    capture_lex $P1631
    .const 'Sub' $P1623 = "160_1307873304.82979" 
    capture_lex $P1623
    .const 'Sub' $P1618 = "159_1307873304.82979" 
    capture_lex $P1618
    .const 'Sub' $P1611 = "158_1307873304.82979" 
    capture_lex $P1611
    .const 'Sub' $P1608 = "157_1307873304.82979" 
    capture_lex $P1608
    .const 'Sub' $P1604 = "156_1307873304.82979" 
    capture_lex $P1604
    .const 'Sub' $P1602 = "155_1307873304.82979" 
    capture_lex $P1602
    .const 'Sub' $P1599 = "154_1307873304.82979" 
    capture_lex $P1599
    .const 'Sub' $P1596 = "153_1307873304.82979" 
    capture_lex $P1596
    .const 'Sub' $P1593 = "152_1307873304.82979" 
    capture_lex $P1593
    .const 'Sub' $P1590 = "151_1307873304.82979" 
    capture_lex $P1590
    .const 'Sub' $P1587 = "150_1307873304.82979" 
    capture_lex $P1587
    .const 'Sub' $P1585 = "149_1307873304.82979" 
    capture_lex $P1585
    .const 'Sub' $P1572 = "146_1307873304.82979" 
    capture_lex $P1572
    .const 'Sub' $P1569 = "145_1307873304.82979" 
    capture_lex $P1569
    .const 'Sub' $P1566 = "144_1307873304.82979" 
    capture_lex $P1566
    .const 'Sub' $P1563 = "143_1307873304.82979" 
    capture_lex $P1563
    .const 'Sub' $P1560 = "142_1307873304.82979" 
    capture_lex $P1560
    .const 'Sub' $P1557 = "141_1307873304.82979" 
    capture_lex $P1557
    .const 'Sub' $P1554 = "140_1307873304.82979" 
    capture_lex $P1554
    .const 'Sub' $P1551 = "139_1307873304.82979" 
    capture_lex $P1551
    .const 'Sub' $P1548 = "138_1307873304.82979" 
    capture_lex $P1548
    .const 'Sub' $P1545 = "137_1307873304.82979" 
    capture_lex $P1545
    .const 'Sub' $P1542 = "136_1307873304.82979" 
    capture_lex $P1542
    .const 'Sub' $P1539 = "135_1307873304.82979" 
    capture_lex $P1539
    .const 'Sub' $P1536 = "134_1307873304.82979" 
    capture_lex $P1536
    .const 'Sub' $P1533 = "133_1307873304.82979" 
    capture_lex $P1533
    .const 'Sub' $P1527 = "132_1307873304.82979" 
    capture_lex $P1527
    .const 'Sub' $P1524 = "131_1307873304.82979" 
    capture_lex $P1524
    .const 'Sub' $P1518 = "130_1307873304.82979" 
    capture_lex $P1518
    .const 'Sub' $P1515 = "129_1307873304.82979" 
    capture_lex $P1515
    .const 'Sub' $P1509 = "128_1307873304.82979" 
    capture_lex $P1509
    .const 'Sub' $P1500 = "125_1307873304.82979" 
    capture_lex $P1500
    .const 'Sub' $P1494 = "124_1307873304.82979" 
    capture_lex $P1494
    .const 'Sub' $P1491 = "123_1307873304.82979" 
    capture_lex $P1491
    .const 'Sub' $P1485 = "122_1307873304.82979" 
    capture_lex $P1485
    .const 'Sub' $P1477 = "119_1307873304.82979" 
    capture_lex $P1477
    .const 'Sub' $P1473 = "118_1307873304.82979" 
    capture_lex $P1473
    .const 'Sub' $P1470 = "117_1307873304.82979" 
    capture_lex $P1470
    .const 'Sub' $P1466 = "116_1307873304.82979" 
    capture_lex $P1466
    .const 'Sub' $P1463 = "115_1307873304.82979" 
    capture_lex $P1463
    .const 'Sub' $P1459 = "114_1307873304.82979" 
    capture_lex $P1459
    .const 'Sub' $P1451 = "111_1307873304.82979" 
    capture_lex $P1451
    .const 'Sub' $P1445 = "110_1307873304.82979" 
    capture_lex $P1445
    .const 'Sub' $P1443 = "109_1307873304.82979" 
    capture_lex $P1443
    .const 'Sub' $P1437 = "108_1307873304.82979" 
    capture_lex $P1437
    .const 'Sub' $P1435 = "107_1307873304.82979" 
    capture_lex $P1435
    .const 'Sub' $P1429 = "106_1307873304.82979" 
    capture_lex $P1429
    .const 'Sub' $P1427 = "105_1307873304.82979" 
    capture_lex $P1427
    .const 'Sub' $P1409 = "104_1307873304.82979" 
    capture_lex $P1409
    .const 'Sub' $P1407 = "103_1307873304.82979" 
    capture_lex $P1407
    .const 'Sub' $P1400 = "102_1307873304.82979" 
    capture_lex $P1400
    .const 'Sub' $P1398 = "101_1307873304.82979" 
    capture_lex $P1398
    .const 'Sub' $P1382 = "99_1307873304.82979" 
    capture_lex $P1382
    .const 'Sub' $P1380 = "98_1307873304.82979" 
    capture_lex $P1380
    .const 'Sub' $P1364 = "97_1307873304.82979" 
    capture_lex $P1364
    .const 'Sub' $P1362 = "96_1307873304.82979" 
    capture_lex $P1362
    .const 'Sub' $P1356 = "95_1307873304.82979" 
    capture_lex $P1356
    .const 'Sub' $P1348 = "92_1307873304.82979" 
    capture_lex $P1348
    .const 'Sub' $P1345 = "91_1307873304.82979" 
    capture_lex $P1345
    .const 'Sub' $P1343 = "90_1307873304.82979" 
    capture_lex $P1343
    .const 'Sub' $P1340 = "89_1307873304.82979" 
    capture_lex $P1340
    .const 'Sub' $P1332 = "86_1307873304.82979" 
    capture_lex $P1332
    .const 'Sub' $P1329 = "85_1307873304.82979" 
    capture_lex $P1329
    .const 'Sub' $P1327 = "84_1307873304.82979" 
    capture_lex $P1327
    .const 'Sub' $P1324 = "83_1307873304.82979" 
    capture_lex $P1324
    .const 'Sub' $P1322 = "82_1307873304.82979" 
    capture_lex $P1322
    .const 'Sub' $P1319 = "81_1307873304.82979" 
    capture_lex $P1319
    .const 'Sub' $P1317 = "80_1307873304.82979" 
    capture_lex $P1317
    .const 'Sub' $P1314 = "79_1307873304.82979" 
    capture_lex $P1314
    .const 'Sub' $P1312 = "78_1307873304.82979" 
    capture_lex $P1312
    .const 'Sub' $P1309 = "77_1307873304.82979" 
    capture_lex $P1309
    .const 'Sub' $P1306 = "76_1307873304.82979" 
    capture_lex $P1306
    .const 'Sub' $P1299 = "75_1307873304.82979" 
    capture_lex $P1299
    .const 'Sub' $P1296 = "74_1307873304.82979" 
    capture_lex $P1296
    .const 'Sub' $P1292 = "73_1307873304.82979" 
    capture_lex $P1292
    .const 'Sub' $P1290 = "72_1307873304.82979" 
    capture_lex $P1290
    .const 'Sub' $P1286 = "71_1307873304.82979" 
    capture_lex $P1286
    .const 'Sub' $P1282 = "70_1307873304.82979" 
    capture_lex $P1282
    .const 'Sub' $P1278 = "69_1307873304.82979" 
    capture_lex $P1278
    .const 'Sub' $P1275 = "68_1307873304.82979" 
    capture_lex $P1275
    .const 'Sub' $P1272 = "67_1307873304.82979" 
    capture_lex $P1272
    .const 'Sub' $P1270 = "66_1307873304.82979" 
    capture_lex $P1270
    .const 'Sub' $P1266 = "65_1307873304.82979" 
    capture_lex $P1266
    .const 'Sub' $P1264 = "64_1307873304.82979" 
    capture_lex $P1264
    .const 'Sub' $P1251 = "62_1307873304.82979" 
    capture_lex $P1251
    .const 'Sub' $P1247 = "61_1307873304.82979" 
    capture_lex $P1247
    .const 'Sub' $P1237 = "60_1307873304.82979" 
    capture_lex $P1237
    .const 'Sub' $P1234 = "59_1307873304.82979" 
    capture_lex $P1234
    .const 'Sub' $P1214 = "58_1307873304.82979" 
    capture_lex $P1214
    .const 'Sub' $P1212 = "57_1307873304.82979" 
    capture_lex $P1212
    .const 'Sub' $P1175 = "55_1307873304.82979" 
    capture_lex $P1175
    .const 'Sub' $P1173 = "54_1307873304.82979" 
    capture_lex $P1173
    .const 'Sub' $P1160 = "52_1307873304.82979" 
    capture_lex $P1160
    .const 'Sub' $P1158 = "51_1307873304.82979" 
    capture_lex $P1158
    .const 'Sub' $P1149 = "50_1307873304.82979" 
    capture_lex $P1149
    .const 'Sub' $P1147 = "49_1307873304.82979" 
    capture_lex $P1147
    .const 'Sub' $P1137 = "48_1307873304.82979" 
    capture_lex $P1137
    .const 'Sub' $P1134 = "47_1307873304.82979" 
    capture_lex $P1134
    .const 'Sub' $P1129 = "46_1307873304.82979" 
    capture_lex $P1129
    .const 'Sub' $P1127 = "45_1307873304.82979" 
    capture_lex $P1127
    .const 'Sub' $P1122 = "44_1307873304.82979" 
    capture_lex $P1122
    .const 'Sub' $P1119 = "43_1307873304.82979" 
    capture_lex $P1119
    .const 'Sub' $P1115 = "42_1307873304.82979" 
    capture_lex $P1115
    .const 'Sub' $P1049 = "41_1307873304.82979" 
    capture_lex $P1049
    .lex "$?PACKAGE", $P987
    .lex "$?CLASS", $P988
.annotate 'line', 1043
    get_hll_global $P989, "GLOBAL"
    nqp_get_package_through_who $P990, $P989, "NQP"
    get_who $P991, $P990
    set $P992, $P991["Grammar"]
    $P992."O"(":prec<y=>, :assoc<unary>", "%methodop")
.annotate 'line', 1044
    get_hll_global $P993, "GLOBAL"
    nqp_get_package_through_who $P994, $P993, "NQP"
    get_who $P995, $P994
    set $P996, $P995["Grammar"]
    $P996."O"(":prec<x=>, :assoc<unary>", "%autoincrement")
.annotate 'line', 1045
    get_hll_global $P997, "GLOBAL"
    nqp_get_package_through_who $P998, $P997, "NQP"
    get_who $P999, $P998
    set $P1000, $P999["Grammar"]
    $P1000."O"(":prec<w=>, :assoc<left>", "%exponentiation")
.annotate 'line', 1046
    get_hll_global $P1001, "GLOBAL"
    nqp_get_package_through_who $P1002, $P1001, "NQP"
    get_who $P1003, $P1002
    set $P1004, $P1003["Grammar"]
    $P1004."O"(":prec<v=>, :assoc<unary>", "%symbolic_unary")
.annotate 'line', 1047
    get_hll_global $P1005, "GLOBAL"
    nqp_get_package_through_who $P1006, $P1005, "NQP"
    get_who $P1007, $P1006
    set $P1008, $P1007["Grammar"]
    $P1008."O"(":prec<u=>, :assoc<left>", "%multiplicative")
.annotate 'line', 1048
    get_hll_global $P1009, "GLOBAL"
    nqp_get_package_through_who $P1010, $P1009, "NQP"
    get_who $P1011, $P1010
    set $P1012, $P1011["Grammar"]
    $P1012."O"(":prec<t=>, :assoc<left>", "%additive")
.annotate 'line', 1049
    get_hll_global $P1013, "GLOBAL"
    nqp_get_package_through_who $P1014, $P1013, "NQP"
    get_who $P1015, $P1014
    set $P1016, $P1015["Grammar"]
    $P1016."O"(":prec<r=>, :assoc<left>", "%concatenation")
.annotate 'line', 1050
    get_hll_global $P1017, "GLOBAL"
    nqp_get_package_through_who $P1018, $P1017, "NQP"
    get_who $P1019, $P1018
    set $P1020, $P1019["Grammar"]
    $P1020."O"(":prec<m=>, :assoc<left>", "%relational")
.annotate 'line', 1051
    get_hll_global $P1021, "GLOBAL"
    nqp_get_package_through_who $P1022, $P1021, "NQP"
    get_who $P1023, $P1022
    set $P1024, $P1023["Grammar"]
    $P1024."O"(":prec<l=>, :assoc<left>", "%tight_and")
.annotate 'line', 1052
    get_hll_global $P1025, "GLOBAL"
    nqp_get_package_through_who $P1026, $P1025, "NQP"
    get_who $P1027, $P1026
    set $P1028, $P1027["Grammar"]
    $P1028."O"(":prec<k=>, :assoc<left>", "%tight_or")
.annotate 'line', 1053
    get_hll_global $P1029, "GLOBAL"
    nqp_get_package_through_who $P1030, $P1029, "NQP"
    get_who $P1031, $P1030
    set $P1032, $P1031["Grammar"]
    $P1032."O"(":prec<j=>, :assoc<right>", "%conditional")
.annotate 'line', 1054
    get_hll_global $P1033, "GLOBAL"
    nqp_get_package_through_who $P1034, $P1033, "NQP"
    get_who $P1035, $P1034
    set $P1036, $P1035["Grammar"]
    $P1036."O"(":prec<i=>, :assoc<right>", "%assignment")
.annotate 'line', 1055
    get_hll_global $P1037, "GLOBAL"
    nqp_get_package_through_who $P1038, $P1037, "NQP"
    get_who $P1039, $P1038
    set $P1040, $P1039["Grammar"]
    $P1040."O"(":prec<g=>, :assoc<list>, :nextterm<nulltermish>", "%comma")
.annotate 'line', 1056
    get_hll_global $P1041, "GLOBAL"
    nqp_get_package_through_who $P1042, $P1041, "NQP"
    get_who $P1043, $P1042
    set $P1044, $P1043["Grammar"]
    $P1044."O"(":prec<f=>, :assoc<list>", "%list_infix")
.annotate 'line', 1057
    get_hll_global $P1045, "GLOBAL"
    nqp_get_package_through_who $P1046, $P1045, "NQP"
    get_who $P1047, $P1046
    set $P1048, $P1047["Grammar"]
    $P1048."O"(":prec<e=>, :assoc<unary>", "%list_prefix")
.annotate 'line', 1156
    .const 'Sub' $P2863 = "416_1307873304.82979" 
    newclosure $P2874, $P2863
.annotate 'line', 435
    .return ($P2874)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "TOP" :anon :subid("41_1307873304.82979") :outer("40_1307873304.82979")
    .param pmc param_1050
.annotate 'line', 436
    .lex "self", param_1050
.annotate 'line', 438
    $P1051 = root_new ['parrot';'Hash']
    .lex "%*LANG", $P1051
.annotate 'line', 447
    $P1052 = root_new ['parrot';'Hash']
    .lex "%*HOW", $P1052
.annotate 'line', 454
    new $P1053, "Undef"
    .lex "$*SC", $P1053
.annotate 'line', 458
    new $P1054, "Undef"
    .lex "$*SCOPE", $P1054
.annotate 'line', 459
    new $P1055, "Undef"
    .lex "$*MULTINESS", $P1055
.annotate 'line', 460
    new $P1056, "Undef"
    .lex "$*PKGDECL", $P1056
.annotate 'line', 461
    new $P1057, "Undef"
    .lex "$*INVOCANT_OK", $P1057
.annotate 'line', 462
    new $P1058, "Undef"
    .lex "$*RETURN_USED", $P1058
.annotate 'line', 436
    find_lex $P1061, "%*LANG"
    unless_null $P1061, vivify_853
    get_hll_global $P1059, "GLOBAL"
    get_who $P1060, $P1059
    set $P1061, $P1060["%LANG"]
    unless_null $P1061, vivify_854
    die "Contextual %*LANG not found"
  vivify_854:
  vivify_853:
.annotate 'line', 439
    get_hll_global $P1062, "GLOBAL"
    nqp_get_package_through_who $P1063, $P1062, "NQP"
    get_who $P1064, $P1063
    set $P1065, $P1064["Regex"]
    find_lex $P1068, "%*LANG"
    unless_null $P1068, vivify_855
    get_hll_global $P1066, "GLOBAL"
    get_who $P1067, $P1066
    set $P1068, $P1067["%LANG"]
    unless_null $P1068, vivify_856
    die "Contextual %*LANG not found"
  vivify_856:
    store_lex "%*LANG", $P1068
  vivify_855:
    set $P1068["Regex"], $P1065
.annotate 'line', 440
    get_hll_global $P1069, "GLOBAL"
    nqp_get_package_through_who $P1070, $P1069, "NQP"
    get_who $P1071, $P1070
    set $P1072, $P1071["RegexActions"]
    find_lex $P1075, "%*LANG"
    unless_null $P1075, vivify_857
    get_hll_global $P1073, "GLOBAL"
    get_who $P1074, $P1073
    set $P1075, $P1074["%LANG"]
    unless_null $P1075, vivify_858
    die "Contextual %*LANG not found"
  vivify_858:
    store_lex "%*LANG", $P1075
  vivify_857:
    set $P1075["Regex-actions"], $P1072
.annotate 'line', 441
    get_hll_global $P1076, "GLOBAL"
    nqp_get_package_through_who $P1077, $P1076, "NQP"
    get_who $P1078, $P1077
    set $P1079, $P1078["Grammar"]
    find_lex $P1082, "%*LANG"
    unless_null $P1082, vivify_859
    get_hll_global $P1080, "GLOBAL"
    get_who $P1081, $P1080
    set $P1082, $P1081["%LANG"]
    unless_null $P1082, vivify_860
    die "Contextual %*LANG not found"
  vivify_860:
    store_lex "%*LANG", $P1082
  vivify_859:
    set $P1082["MAIN"], $P1079
.annotate 'line', 442
    get_hll_global $P1083, "GLOBAL"
    nqp_get_package_through_who $P1084, $P1083, "NQP"
    get_who $P1085, $P1084
    set $P1086, $P1085["Actions"]
    find_lex $P1089, "%*LANG"
    unless_null $P1089, vivify_861
    get_hll_global $P1087, "GLOBAL"
    get_who $P1088, $P1087
    set $P1089, $P1088["%LANG"]
    unless_null $P1089, vivify_862
    die "Contextual %*LANG not found"
  vivify_862:
    store_lex "%*LANG", $P1089
  vivify_861:
    set $P1089["MAIN-actions"], $P1086
    find_lex $P1092, "%*HOW"
    unless_null $P1092, vivify_863
    get_hll_global $P1090, "GLOBAL"
    get_who $P1091, $P1090
    set $P1092, $P1091["%HOW"]
    unless_null $P1092, vivify_864
    die "Contextual %*HOW not found"
  vivify_864:
  vivify_863:
.annotate 'line', 448
    get_knowhow $P1093
    find_lex $P1096, "%*HOW"
    unless_null $P1096, vivify_865
    get_hll_global $P1094, "GLOBAL"
    get_who $P1095, $P1094
    set $P1096, $P1095["%HOW"]
    unless_null $P1096, vivify_866
    die "Contextual %*HOW not found"
  vivify_866:
    store_lex "%*HOW", $P1096
  vivify_865:
    set $P1096["knowhow"], $P1093
.annotate 'line', 449
    get_knowhow_attribute $P1097
    find_lex $P1100, "%*HOW"
    unless_null $P1100, vivify_867
    get_hll_global $P1098, "GLOBAL"
    get_who $P1099, $P1098
    set $P1100, $P1099["%HOW"]
    unless_null $P1100, vivify_868
    die "Contextual %*HOW not found"
  vivify_868:
    store_lex "%*HOW", $P1100
  vivify_867:
    set $P1100["knowhow-attr"], $P1097
.annotate 'line', 454
    get_hll_global $P1101, "GLOBAL"
    nqp_get_package_through_who $P1102, $P1101, "NQP"
    get_who $P1103, $P1102
    set $P1104, $P1103["SymbolTable"]
.annotate 'line', 456
    time $N1105
    set $S1106, $N1105
    $P1107 = $P1104."new"($S1106 :named("handle"))
.annotate 'line', 454
    store_lex "$*SC", $P1107
.annotate 'line', 458
    new $P1108, "String"
    assign $P1108, ""
    store_lex "$*SCOPE", $P1108
.annotate 'line', 459
    new $P1109, "String"
    assign $P1109, ""
    store_lex "$*MULTINESS", $P1109
.annotate 'line', 460
    new $P1110, "String"
    assign $P1110, ""
    store_lex "$*PKGDECL", $P1110
.annotate 'line', 461
    new $P1111, "Integer"
    assign $P1111, 0
    store_lex "$*INVOCANT_OK", $P1111
.annotate 'line', 462
    new $P1112, "Integer"
    assign $P1112, 0
    store_lex "$*RETURN_USED", $P1112
.annotate 'line', 463
    find_lex $P1113, "self"
    $P1114 = $P1113."comp_unit"()
.annotate 'line', 436
    .return ($P1114)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "identifier"  :subid("42_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx1116_tgt
    .local int rx1116_pos
    .local int rx1116_off
    .local int rx1116_eos
    .local int rx1116_rep
    .local pmc rx1116_cur
    .local pmc rx1116_debug
    (rx1116_cur, rx1116_pos, rx1116_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1116_cur
    .local pmc match
    .lex "$/", match
    length rx1116_eos, rx1116_tgt
    gt rx1116_pos, rx1116_eos, rx1116_done
    set rx1116_off, 0
    lt rx1116_pos, 2, rx1116_start
    sub rx1116_off, rx1116_pos, 1
    substr rx1116_tgt, rx1116_tgt, rx1116_off
  rx1116_start:
    eq $I10, 1, rx1116_restart
    if_null rx1116_debug, debug_869
    rx1116_cur."!cursor_debug"("START", "identifier")
  debug_869:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1117_done
    goto rxscan1117_scan
  rxscan1117_loop:
    (rx1116_pos) = rx1116_cur."from"()
    inc rx1116_pos
    rx1116_cur."!cursor_from"(rx1116_pos)
    ge rx1116_pos, rx1116_eos, rxscan1117_done
  rxscan1117_scan:
    set_addr $I10, rxscan1117_loop
    rx1116_cur."!mark_push"(0, rx1116_pos, $I10)
  rxscan1117_done:
.annotate 'line', 468
  # rx subrule "ident" subtype=method negate=
    rx1116_cur."!cursor_pos"(rx1116_pos)
    $P10 = rx1116_cur."ident"()
    unless $P10, rx1116_fail
    rx1116_pos = $P10."pos"()
  # rx rxquantr1118 ** 0..*
    set_addr $I10, rxquantr1118_done
    rx1116_cur."!mark_push"(0, rx1116_pos, $I10)
  rxquantr1118_loop:
  # rx enumcharlist negate=0 
    ge rx1116_pos, rx1116_eos, rx1116_fail
    sub $I10, rx1116_pos, rx1116_off
    substr $S10, rx1116_tgt, $I10, 1
    index $I11, "-'", $S10
    lt $I11, 0, rx1116_fail
    inc rx1116_pos
  # rx subrule "ident" subtype=method negate=
    rx1116_cur."!cursor_pos"(rx1116_pos)
    $P10 = rx1116_cur."ident"()
    unless $P10, rx1116_fail
    rx1116_pos = $P10."pos"()
    set_addr $I10, rxquantr1118_done
    (rx1116_rep) = rx1116_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1118_done
    rx1116_cur."!mark_push"(rx1116_rep, rx1116_pos, $I10)
    goto rxquantr1118_loop
  rxquantr1118_done:
  # rx pass
    rx1116_cur."!cursor_pass"(rx1116_pos, "identifier")
    if_null rx1116_debug, debug_870
    rx1116_cur."!cursor_debug"("PASS", "identifier", " at pos=", rx1116_pos)
  debug_870:
    .return (rx1116_cur)
  rx1116_restart:
.annotate 'line', 436
    if_null rx1116_debug, debug_871
    rx1116_cur."!cursor_debug"("NEXT", "identifier")
  debug_871:
  rx1116_fail:
    (rx1116_rep, rx1116_pos, $I10, $P10) = rx1116_cur."!mark_fail"(0)
    lt rx1116_pos, -1, rx1116_done
    eq rx1116_pos, -1, rx1116_fail
    jump $I10
  rx1116_done:
    rx1116_cur."!cursor_fail"()
    if_null rx1116_debug, debug_872
    rx1116_cur."!cursor_debug"("FAIL", "identifier")
  debug_872:
    .return (rx1116_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__identifier"  :subid("43_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P1120 = self."!PREFIX__!subrule"("ident", "")
    new $P1121, "ResizablePMCArray"
    push $P1121, $P1120
    .return ($P1121)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "name"  :subid("44_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx1123_tgt
    .local int rx1123_pos
    .local int rx1123_off
    .local int rx1123_eos
    .local int rx1123_rep
    .local pmc rx1123_cur
    .local pmc rx1123_debug
    (rx1123_cur, rx1123_pos, rx1123_tgt, $I10) = self."!cursor_start"()
    rx1123_cur."!cursor_caparray"("identifier")
    .lex unicode:"$\x{a2}", rx1123_cur
    .local pmc match
    .lex "$/", match
    length rx1123_eos, rx1123_tgt
    gt rx1123_pos, rx1123_eos, rx1123_done
    set rx1123_off, 0
    lt rx1123_pos, 2, rx1123_start
    sub rx1123_off, rx1123_pos, 1
    substr rx1123_tgt, rx1123_tgt, rx1123_off
  rx1123_start:
    eq $I10, 1, rx1123_restart
    if_null rx1123_debug, debug_873
    rx1123_cur."!cursor_debug"("START", "name")
  debug_873:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1124_done
    goto rxscan1124_scan
  rxscan1124_loop:
    (rx1123_pos) = rx1123_cur."from"()
    inc rx1123_pos
    rx1123_cur."!cursor_from"(rx1123_pos)
    ge rx1123_pos, rx1123_eos, rxscan1124_done
  rxscan1124_scan:
    set_addr $I10, rxscan1124_loop
    rx1123_cur."!mark_push"(0, rx1123_pos, $I10)
  rxscan1124_done:
.annotate 'line', 470
  # rx rxquantr1125 ** 1..*
    set_addr $I10, rxquantr1125_done
    rx1123_cur."!mark_push"(0, -1, $I10)
  rxquantr1125_loop:
  # rx subrule "identifier" subtype=capture negate=
    rx1123_cur."!cursor_pos"(rx1123_pos)
    $P10 = rx1123_cur."identifier"()
    unless $P10, rx1123_fail
    goto rxsubrule1126_pass
  rxsubrule1126_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1123_fail
  rxsubrule1126_pass:
    set_addr $I10, rxsubrule1126_back
    rx1123_cur."!mark_push"(0, rx1123_pos, $I10, $P10)
    $P10."!cursor_names"("identifier")
    rx1123_pos = $P10."pos"()
    set_addr $I10, rxquantr1125_done
    (rx1123_rep) = rx1123_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1125_done
    rx1123_cur."!mark_push"(rx1123_rep, rx1123_pos, $I10)
  # rx literal  "::"
    add $I11, rx1123_pos, 2
    gt $I11, rx1123_eos, rx1123_fail
    sub $I11, rx1123_pos, rx1123_off
    substr $S10, rx1123_tgt, $I11, 2
    ne $S10, "::", rx1123_fail
    add rx1123_pos, 2
    goto rxquantr1125_loop
  rxquantr1125_done:
  # rx pass
    rx1123_cur."!cursor_pass"(rx1123_pos, "name")
    if_null rx1123_debug, debug_874
    rx1123_cur."!cursor_debug"("PASS", "name", " at pos=", rx1123_pos)
  debug_874:
    .return (rx1123_cur)
  rx1123_restart:
.annotate 'line', 436
    if_null rx1123_debug, debug_875
    rx1123_cur."!cursor_debug"("NEXT", "name")
  debug_875:
  rx1123_fail:
    (rx1123_rep, rx1123_pos, $I10, $P10) = rx1123_cur."!mark_fail"(0)
    lt rx1123_pos, -1, rx1123_done
    eq rx1123_pos, -1, rx1123_fail
    jump $I10
  rx1123_done:
    rx1123_cur."!cursor_fail"()
    if_null rx1123_debug, debug_876
    rx1123_cur."!cursor_debug"("FAIL", "name")
  debug_876:
    .return (rx1123_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__name"  :subid("45_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    new $P1128, "ResizablePMCArray"
    push $P1128, ""
    .return ($P1128)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "deflongname"  :subid("46_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx1130_tgt
    .local int rx1130_pos
    .local int rx1130_off
    .local int rx1130_eos
    .local int rx1130_rep
    .local pmc rx1130_cur
    .local pmc rx1130_debug
    (rx1130_cur, rx1130_pos, rx1130_tgt, $I10) = self."!cursor_start"()
    rx1130_cur."!cursor_caparray"("colonpair")
    .lex unicode:"$\x{a2}", rx1130_cur
    .local pmc match
    .lex "$/", match
    length rx1130_eos, rx1130_tgt
    gt rx1130_pos, rx1130_eos, rx1130_done
    set rx1130_off, 0
    lt rx1130_pos, 2, rx1130_start
    sub rx1130_off, rx1130_pos, 1
    substr rx1130_tgt, rx1130_tgt, rx1130_off
  rx1130_start:
    eq $I10, 1, rx1130_restart
    if_null rx1130_debug, debug_877
    rx1130_cur."!cursor_debug"("START", "deflongname")
  debug_877:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1131_done
    goto rxscan1131_scan
  rxscan1131_loop:
    (rx1130_pos) = rx1130_cur."from"()
    inc rx1130_pos
    rx1130_cur."!cursor_from"(rx1130_pos)
    ge rx1130_pos, rx1130_eos, rxscan1131_done
  rxscan1131_scan:
    set_addr $I10, rxscan1131_loop
    rx1130_cur."!mark_push"(0, rx1130_pos, $I10)
  rxscan1131_done:
.annotate 'line', 473
  # rx subrule "identifier" subtype=capture negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."identifier"()
    unless $P10, rx1130_fail
    rx1130_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx1130_pos = $P10."pos"()
  # rx rxquantr1132 ** 0..1
    set_addr $I10, rxquantr1132_done
    rx1130_cur."!mark_push"(0, rx1130_pos, $I10)
  rxquantr1132_loop:
  # rx subrule "colonpair" subtype=capture negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."colonpair"()
    unless $P10, rx1130_fail
    goto rxsubrule1133_pass
  rxsubrule1133_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1130_fail
  rxsubrule1133_pass:
    set_addr $I10, rxsubrule1133_back
    rx1130_cur."!mark_push"(0, rx1130_pos, $I10, $P10)
    $P10."!cursor_names"("colonpair")
    rx1130_pos = $P10."pos"()
    set_addr $I10, rxquantr1132_done
    (rx1130_rep) = rx1130_cur."!mark_commit"($I10)
  rxquantr1132_done:
.annotate 'line', 472
  # rx pass
    rx1130_cur."!cursor_pass"(rx1130_pos, "deflongname")
    if_null rx1130_debug, debug_878
    rx1130_cur."!cursor_debug"("PASS", "deflongname", " at pos=", rx1130_pos)
  debug_878:
    .return (rx1130_cur)
  rx1130_restart:
.annotate 'line', 436
    if_null rx1130_debug, debug_879
    rx1130_cur."!cursor_debug"("NEXT", "deflongname")
  debug_879:
  rx1130_fail:
    (rx1130_rep, rx1130_pos, $I10, $P10) = rx1130_cur."!mark_fail"(0)
    lt rx1130_pos, -1, rx1130_done
    eq rx1130_pos, -1, rx1130_fail
    jump $I10
  rx1130_done:
    rx1130_cur."!cursor_fail"()
    if_null rx1130_debug, debug_880
    rx1130_cur."!cursor_debug"("FAIL", "deflongname")
  debug_880:
    .return (rx1130_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__deflongname"  :subid("47_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P1135 = self."!PREFIX__!subrule"("identifier", "")
    new $P1136, "ResizablePMCArray"
    push $P1136, $P1135
    .return ($P1136)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ENDSTMT"  :subid("48_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx1138_tgt
    .local int rx1138_pos
    .local int rx1138_off
    .local int rx1138_eos
    .local int rx1138_rep
    .local pmc rx1138_cur
    .local pmc rx1138_debug
    (rx1138_cur, rx1138_pos, rx1138_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1138_cur
    .local pmc match
    .lex "$/", match
    length rx1138_eos, rx1138_tgt
    gt rx1138_pos, rx1138_eos, rx1138_done
    set rx1138_off, 0
    lt rx1138_pos, 2, rx1138_start
    sub rx1138_off, rx1138_pos, 1
    substr rx1138_tgt, rx1138_tgt, rx1138_off
  rx1138_start:
    eq $I10, 1, rx1138_restart
    if_null rx1138_debug, debug_881
    rx1138_cur."!cursor_debug"("START", "ENDSTMT")
  debug_881:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1139_done
    goto rxscan1139_scan
  rxscan1139_loop:
    (rx1138_pos) = rx1138_cur."from"()
    inc rx1138_pos
    rx1138_cur."!cursor_from"(rx1138_pos)
    ge rx1138_pos, rx1138_eos, rxscan1139_done
  rxscan1139_scan:
    set_addr $I10, rxscan1139_loop
    rx1138_cur."!mark_push"(0, rx1138_pos, $I10)
  rxscan1139_done:
.annotate 'line', 480
  # rx rxquantr1140 ** 0..1
    set_addr $I10, rxquantr1140_done
    rx1138_cur."!mark_push"(0, rx1138_pos, $I10)
  rxquantr1140_loop:
  alt1141_0:
.annotate 'line', 477
    set_addr $I10, alt1141_1
    rx1138_cur."!mark_push"(0, rx1138_pos, $I10)
.annotate 'line', 478
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1138_pos, rx1138_off
    set rx1138_rep, 0
    sub $I12, rx1138_eos, rx1138_pos
  rxenumcharlistq1142_loop:
    le $I12, 0, rxenumcharlistq1142_done
    substr $S10, rx1138_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1142_done
    inc rx1138_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1142_loop
  rxenumcharlistq1142_done:
    add rx1138_pos, rx1138_pos, rx1138_rep
  # rxanchor eol
    sub $I10, rx1138_pos, rx1138_off
    is_cclass $I11, .CCLASS_NEWLINE, rx1138_tgt, $I10
    if $I11, rxanchor1143_done
    ne rx1138_pos, rx1138_eos, rx1138_fail
    eq rx1138_pos, 0, rxanchor1143_done
    dec $I10
    is_cclass $I11, .CCLASS_NEWLINE, rx1138_tgt, $I10
    if $I11, rx1138_fail
  rxanchor1143_done:
  # rx subrule "ws" subtype=method negate=
    rx1138_cur."!cursor_pos"(rx1138_pos)
    $P10 = rx1138_cur."ws"()
    unless $P10, rx1138_fail
    rx1138_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx1138_cur."!cursor_pos"(rx1138_pos)
    $P10 = rx1138_cur."MARKER"("endstmt")
    unless $P10, rx1138_fail
    goto alt1141_end
  alt1141_1:
.annotate 'line', 479
  # rx rxquantr1144 ** 0..1
    set_addr $I10, rxquantr1144_done
    rx1138_cur."!mark_push"(0, rx1138_pos, $I10)
  rxquantr1144_loop:
  # rx subrule "unv" subtype=method negate=
    rx1138_cur."!cursor_pos"(rx1138_pos)
    $P10 = rx1138_cur."unv"()
    unless $P10, rx1138_fail
    goto rxsubrule1145_pass
  rxsubrule1145_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1138_fail
  rxsubrule1145_pass:
    set_addr $I10, rxsubrule1145_back
    rx1138_cur."!mark_push"(0, rx1138_pos, $I10, $P10)
    rx1138_pos = $P10."pos"()
    set_addr $I10, rxquantr1144_done
    (rx1138_rep) = rx1138_cur."!mark_commit"($I10)
  rxquantr1144_done:
  # rxanchor eol
    sub $I10, rx1138_pos, rx1138_off
    is_cclass $I11, .CCLASS_NEWLINE, rx1138_tgt, $I10
    if $I11, rxanchor1146_done
    ne rx1138_pos, rx1138_eos, rx1138_fail
    eq rx1138_pos, 0, rxanchor1146_done
    dec $I10
    is_cclass $I11, .CCLASS_NEWLINE, rx1138_tgt, $I10
    if $I11, rx1138_fail
  rxanchor1146_done:
  # rx subrule "ws" subtype=method negate=
    rx1138_cur."!cursor_pos"(rx1138_pos)
    $P10 = rx1138_cur."ws"()
    unless $P10, rx1138_fail
    rx1138_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx1138_cur."!cursor_pos"(rx1138_pos)
    $P10 = rx1138_cur."MARKER"("endstmt")
    unless $P10, rx1138_fail
  alt1141_end:
.annotate 'line', 480
    set_addr $I10, rxquantr1140_done
    (rx1138_rep) = rx1138_cur."!mark_commit"($I10)
  rxquantr1140_done:
.annotate 'line', 476
  # rx pass
    rx1138_cur."!cursor_pass"(rx1138_pos, "ENDSTMT")
    if_null rx1138_debug, debug_882
    rx1138_cur."!cursor_debug"("PASS", "ENDSTMT", " at pos=", rx1138_pos)
  debug_882:
    .return (rx1138_cur)
  rx1138_restart:
.annotate 'line', 436
    if_null rx1138_debug, debug_883
    rx1138_cur."!cursor_debug"("NEXT", "ENDSTMT")
  debug_883:
  rx1138_fail:
    (rx1138_rep, rx1138_pos, $I10, $P10) = rx1138_cur."!mark_fail"(0)
    lt rx1138_pos, -1, rx1138_done
    eq rx1138_pos, -1, rx1138_fail
    jump $I10
  rx1138_done:
    rx1138_cur."!cursor_fail"()
    if_null rx1138_debug, debug_884
    rx1138_cur."!cursor_debug"("FAIL", "ENDSTMT")
  debug_884:
    .return (rx1138_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ENDSTMT"  :subid("49_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    new $P1148, "ResizablePMCArray"
    push $P1148, ""
    .return ($P1148)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ws"  :subid("50_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx1150_tgt
    .local int rx1150_pos
    .local int rx1150_off
    .local int rx1150_eos
    .local int rx1150_rep
    .local pmc rx1150_cur
    .local pmc rx1150_debug
    (rx1150_cur, rx1150_pos, rx1150_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1150_cur
    .local pmc match
    .lex "$/", match
    length rx1150_eos, rx1150_tgt
    gt rx1150_pos, rx1150_eos, rx1150_done
    set rx1150_off, 0
    lt rx1150_pos, 2, rx1150_start
    sub rx1150_off, rx1150_pos, 1
    substr rx1150_tgt, rx1150_tgt, rx1150_off
  rx1150_start:
    eq $I10, 1, rx1150_restart
    if_null rx1150_debug, debug_885
    rx1150_cur."!cursor_debug"("START", "ws")
  debug_885:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1151_done
    goto rxscan1151_scan
  rxscan1151_loop:
    (rx1150_pos) = rx1150_cur."from"()
    inc rx1150_pos
    rx1150_cur."!cursor_from"(rx1150_pos)
    ge rx1150_pos, rx1150_eos, rxscan1151_done
  rxscan1151_scan:
    set_addr $I10, rxscan1151_loop
    rx1150_cur."!mark_push"(0, rx1150_pos, $I10)
  rxscan1151_done:
  alt1152_0:
.annotate 'line', 483
    set_addr $I10, alt1152_1
    rx1150_cur."!mark_push"(0, rx1150_pos, $I10)
.annotate 'line', 484
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx1150_cur."!cursor_pos"(rx1150_pos)
    $P10 = rx1150_cur."MARKED"("ws")
    unless $P10, rx1150_fail
    goto alt1152_end
  alt1152_1:
.annotate 'line', 485
  # rx subrule "ww" subtype=zerowidth negate=1
    rx1150_cur."!cursor_pos"(rx1150_pos)
    $P10 = rx1150_cur."ww"()
    if $P10, rx1150_fail
.annotate 'line', 490
  # rx rxquantr1153 ** 0..*
    set_addr $I10, rxquantr1153_done
    rx1150_cur."!mark_push"(0, rx1150_pos, $I10)
  rxquantr1153_loop:
  alt1154_0:
.annotate 'line', 486
    set_addr $I10, alt1154_1
    rx1150_cur."!mark_push"(0, rx1150_pos, $I10)
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx1150_pos, rx1150_off
    set rx1150_rep, 0
    sub $I12, rx1150_eos, rx1150_pos
  rxenumcharlistq1155_loop:
    le $I12, 0, rxenumcharlistq1155_done
    substr $S10, rx1150_tgt, $I10, 1
    index $I11, unicode:"\n\x{b}\f\r\x{85}\u2028\u2029", $S10
    lt $I11, 0, rxenumcharlistq1155_done
    inc rx1150_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1155_loop
  rxenumcharlistq1155_done:
    lt rx1150_rep, 1, rx1150_fail
    add rx1150_pos, rx1150_pos, rx1150_rep
    goto alt1154_end
  alt1154_1:
    set_addr $I10, alt1154_2
    rx1150_cur."!mark_push"(0, rx1150_pos, $I10)
.annotate 'line', 487
  # rx literal  "#"
    add $I11, rx1150_pos, 1
    gt $I11, rx1150_eos, rx1150_fail
    sub $I11, rx1150_pos, rx1150_off
    ord $I11, rx1150_tgt, $I11
    ne $I11, 35, rx1150_fail
    add rx1150_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx1150_pos, rx1150_off
    find_cclass $I11, .CCLASS_NEWLINE, rx1150_tgt, $I10, rx1150_eos
    add rx1150_pos, rx1150_off, $I11
    goto alt1154_end
  alt1154_2:
    set_addr $I10, alt1154_3
    rx1150_cur."!mark_push"(0, rx1150_pos, $I10)
.annotate 'line', 488
  # rxanchor bol
    eq rx1150_pos, 0, rxanchor1156_done
    ge rx1150_pos, rx1150_eos, rx1150_fail
    sub $I10, rx1150_pos, rx1150_off
    dec $I10
    is_cclass $I11, .CCLASS_NEWLINE, rx1150_tgt, $I10
    unless $I11, rx1150_fail
  rxanchor1156_done:
  # rx subrule "pod_comment" subtype=method negate=
    rx1150_cur."!cursor_pos"(rx1150_pos)
    $P10 = rx1150_cur."pod_comment"()
    unless $P10, rx1150_fail
    rx1150_pos = $P10."pos"()
    goto alt1154_end
  alt1154_3:
.annotate 'line', 489
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx1150_pos, rx1150_off
    set rx1150_rep, 0
    sub $I12, rx1150_eos, rx1150_pos
  rxenumcharlistq1157_loop:
    le $I12, 0, rxenumcharlistq1157_done
    substr $S10, rx1150_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1157_done
    inc rx1150_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1157_loop
  rxenumcharlistq1157_done:
    lt rx1150_rep, 1, rx1150_fail
    add rx1150_pos, rx1150_pos, rx1150_rep
  alt1154_end:
.annotate 'line', 490
    set_addr $I10, rxquantr1153_done
    (rx1150_rep) = rx1150_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1153_done
    rx1150_cur."!mark_push"(rx1150_rep, rx1150_pos, $I10)
    goto rxquantr1153_loop
  rxquantr1153_done:
.annotate 'line', 491
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx1150_cur."!cursor_pos"(rx1150_pos)
    $P10 = rx1150_cur."MARKER"("ws")
    unless $P10, rx1150_fail
  alt1152_end:
.annotate 'line', 483
  # rx pass
    rx1150_cur."!cursor_pass"(rx1150_pos, "ws")
    if_null rx1150_debug, debug_886
    rx1150_cur."!cursor_debug"("PASS", "ws", " at pos=", rx1150_pos)
  debug_886:
    .return (rx1150_cur)
  rx1150_restart:
.annotate 'line', 436
    if_null rx1150_debug, debug_887
    rx1150_cur."!cursor_debug"("NEXT", "ws")
  debug_887:
  rx1150_fail:
    (rx1150_rep, rx1150_pos, $I10, $P10) = rx1150_cur."!mark_fail"(0)
    lt rx1150_pos, -1, rx1150_done
    eq rx1150_pos, -1, rx1150_fail
    jump $I10
  rx1150_done:
    rx1150_cur."!cursor_fail"()
    if_null rx1150_debug, debug_888
    rx1150_cur."!cursor_debug"("FAIL", "ws")
  debug_888:
    .return (rx1150_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ws"  :subid("51_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    new $P1159, "ResizablePMCArray"
    push $P1159, ""
    push $P1159, ""
    .return ($P1159)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "unv"  :subid("52_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .const 'Sub' $P1166 = "53_1307873304.82979" 
    capture_lex $P1166
    .local string rx1161_tgt
    .local int rx1161_pos
    .local int rx1161_off
    .local int rx1161_eos
    .local int rx1161_rep
    .local pmc rx1161_cur
    .local pmc rx1161_debug
    (rx1161_cur, rx1161_pos, rx1161_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1161_cur
    .local pmc match
    .lex "$/", match
    length rx1161_eos, rx1161_tgt
    gt rx1161_pos, rx1161_eos, rx1161_done
    set rx1161_off, 0
    lt rx1161_pos, 2, rx1161_start
    sub rx1161_off, rx1161_pos, 1
    substr rx1161_tgt, rx1161_tgt, rx1161_off
  rx1161_start:
    eq $I10, 1, rx1161_restart
    if_null rx1161_debug, debug_889
    rx1161_cur."!cursor_debug"("START", "unv")
  debug_889:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1162_done
    goto rxscan1162_scan
  rxscan1162_loop:
    (rx1161_pos) = rx1161_cur."from"()
    inc rx1161_pos
    rx1161_cur."!cursor_from"(rx1161_pos)
    ge rx1161_pos, rx1161_eos, rxscan1162_done
  rxscan1162_scan:
    set_addr $I10, rxscan1162_loop
    rx1161_cur."!mark_push"(0, rx1161_pos, $I10)
  rxscan1162_done:
  alt1163_0:
.annotate 'line', 496
    set_addr $I10, alt1163_1
    rx1161_cur."!mark_push"(0, rx1161_pos, $I10)
.annotate 'line', 497
  # rxanchor bol
    eq rx1161_pos, 0, rxanchor1164_done
    ge rx1161_pos, rx1161_eos, rx1161_fail
    sub $I10, rx1161_pos, rx1161_off
    dec $I10
    is_cclass $I11, .CCLASS_NEWLINE, rx1161_tgt, $I10
    unless $I11, rx1161_fail
  rxanchor1164_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx1161_cur."!cursor_pos"(rx1161_pos)
    .const 'Sub' $P1166 = "53_1307873304.82979" 
    capture_lex $P1166
    $P10 = rx1161_cur."before"($P1166)
    unless $P10, rx1161_fail
  # rx subrule "pod_comment" subtype=method negate=
    rx1161_cur."!cursor_pos"(rx1161_pos)
    $P10 = rx1161_cur."pod_comment"()
    unless $P10, rx1161_fail
    rx1161_pos = $P10."pos"()
    goto alt1163_end
  alt1163_1:
    set_addr $I10, alt1163_2
    rx1161_cur."!mark_push"(0, rx1161_pos, $I10)
.annotate 'line', 498
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1161_pos, rx1161_off
    set rx1161_rep, 0
    sub $I12, rx1161_eos, rx1161_pos
  rxenumcharlistq1171_loop:
    le $I12, 0, rxenumcharlistq1171_done
    substr $S10, rx1161_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1171_done
    inc rx1161_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1171_loop
  rxenumcharlistq1171_done:
    add rx1161_pos, rx1161_pos, rx1161_rep
  # rx literal  "#"
    add $I11, rx1161_pos, 1
    gt $I11, rx1161_eos, rx1161_fail
    sub $I11, rx1161_pos, rx1161_off
    ord $I11, rx1161_tgt, $I11
    ne $I11, 35, rx1161_fail
    add rx1161_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx1161_pos, rx1161_off
    find_cclass $I11, .CCLASS_NEWLINE, rx1161_tgt, $I10, rx1161_eos
    add rx1161_pos, rx1161_off, $I11
    goto alt1163_end
  alt1163_2:
.annotate 'line', 499
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx1161_pos, rx1161_off
    set rx1161_rep, 0
    sub $I12, rx1161_eos, rx1161_pos
  rxenumcharlistq1172_loop:
    le $I12, 0, rxenumcharlistq1172_done
    substr $S10, rx1161_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1172_done
    inc rx1161_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1172_loop
  rxenumcharlistq1172_done:
    lt rx1161_rep, 1, rx1161_fail
    add rx1161_pos, rx1161_pos, rx1161_rep
  alt1163_end:
.annotate 'line', 494
  # rx pass
    rx1161_cur."!cursor_pass"(rx1161_pos, "unv")
    if_null rx1161_debug, debug_894
    rx1161_cur."!cursor_debug"("PASS", "unv", " at pos=", rx1161_pos)
  debug_894:
    .return (rx1161_cur)
  rx1161_restart:
.annotate 'line', 436
    if_null rx1161_debug, debug_895
    rx1161_cur."!cursor_debug"("NEXT", "unv")
  debug_895:
  rx1161_fail:
    (rx1161_rep, rx1161_pos, $I10, $P10) = rx1161_cur."!mark_fail"(0)
    lt rx1161_pos, -1, rx1161_done
    eq rx1161_pos, -1, rx1161_fail
    jump $I10
  rx1161_done:
    rx1161_cur."!cursor_fail"()
    if_null rx1161_debug, debug_896
    rx1161_cur."!cursor_debug"("FAIL", "unv")
  debug_896:
    .return (rx1161_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1165"  :anon :subid("53_1307873304.82979") :method :outer("52_1307873304.82979")
.annotate 'line', 497
    .local string rx1167_tgt
    .local int rx1167_pos
    .local int rx1167_off
    .local int rx1167_eos
    .local int rx1167_rep
    .local pmc rx1167_cur
    .local pmc rx1167_debug
    (rx1167_cur, rx1167_pos, rx1167_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1167_cur
    .local pmc match
    .lex "$/", match
    length rx1167_eos, rx1167_tgt
    gt rx1167_pos, rx1167_eos, rx1167_done
    set rx1167_off, 0
    lt rx1167_pos, 2, rx1167_start
    sub rx1167_off, rx1167_pos, 1
    substr rx1167_tgt, rx1167_tgt, rx1167_off
  rx1167_start:
    eq $I10, 1, rx1167_restart
    if_null rx1167_debug, debug_890
    rx1167_cur."!cursor_debug"("START", "")
  debug_890:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1168_done
    goto rxscan1168_scan
  rxscan1168_loop:
    (rx1167_pos) = rx1167_cur."from"()
    inc rx1167_pos
    rx1167_cur."!cursor_from"(rx1167_pos)
    ge rx1167_pos, rx1167_eos, rxscan1168_done
  rxscan1168_scan:
    set_addr $I10, rxscan1168_loop
    rx1167_cur."!mark_push"(0, rx1167_pos, $I10)
  rxscan1168_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1167_pos, rx1167_off
    set rx1167_rep, 0
    sub $I12, rx1167_eos, rx1167_pos
  rxenumcharlistq1169_loop:
    le $I12, 0, rxenumcharlistq1169_done
    substr $S10, rx1167_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1169_done
    inc rx1167_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1169_loop
  rxenumcharlistq1169_done:
    add rx1167_pos, rx1167_pos, rx1167_rep
  # rx literal  "="
    add $I11, rx1167_pos, 1
    gt $I11, rx1167_eos, rx1167_fail
    sub $I11, rx1167_pos, rx1167_off
    ord $I11, rx1167_tgt, $I11
    ne $I11, 61, rx1167_fail
    add rx1167_pos, 1
  alt1170_0:
    set_addr $I10, alt1170_1
    rx1167_cur."!mark_push"(0, rx1167_pos, $I10)
  # rx charclass w
    ge rx1167_pos, rx1167_eos, rx1167_fail
    sub $I10, rx1167_pos, rx1167_off
    is_cclass $I11, .CCLASS_WORD, rx1167_tgt, $I10
    unless $I11, rx1167_fail
    inc rx1167_pos
    goto alt1170_end
  alt1170_1:
  # rx literal  "\\"
    add $I11, rx1167_pos, 1
    gt $I11, rx1167_eos, rx1167_fail
    sub $I11, rx1167_pos, rx1167_off
    ord $I11, rx1167_tgt, $I11
    ne $I11, 92, rx1167_fail
    add rx1167_pos, 1
  alt1170_end:
  # rx pass
    rx1167_cur."!cursor_pass"(rx1167_pos, "")
    if_null rx1167_debug, debug_891
    rx1167_cur."!cursor_debug"("PASS", "", " at pos=", rx1167_pos)
  debug_891:
    .return (rx1167_cur)
  rx1167_restart:
    if_null rx1167_debug, debug_892
    rx1167_cur."!cursor_debug"("NEXT", "")
  debug_892:
  rx1167_fail:
    (rx1167_rep, rx1167_pos, $I10, $P10) = rx1167_cur."!mark_fail"(0)
    lt rx1167_pos, -1, rx1167_done
    eq rx1167_pos, -1, rx1167_fail
    jump $I10
  rx1167_done:
    rx1167_cur."!cursor_fail"()
    if_null rx1167_debug, debug_893
    rx1167_cur."!cursor_debug"("FAIL", "")
  debug_893:
    .return (rx1167_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__unv"  :subid("54_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    new $P1174, "ResizablePMCArray"
    push $P1174, ""
    push $P1174, ""
    push $P1174, ""
    .return ($P1174)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pod_comment"  :subid("55_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .const 'Sub' $P1205 = "56_1307873304.82979" 
    capture_lex $P1205
    .local string rx1176_tgt
    .local int rx1176_pos
    .local int rx1176_off
    .local int rx1176_eos
    .local int rx1176_rep
    .local pmc rx1176_cur
    .local pmc rx1176_debug
    (rx1176_cur, rx1176_pos, rx1176_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1176_cur
    .local pmc match
    .lex "$/", match
    length rx1176_eos, rx1176_tgt
    gt rx1176_pos, rx1176_eos, rx1176_done
    set rx1176_off, 0
    lt rx1176_pos, 2, rx1176_start
    sub rx1176_off, rx1176_pos, 1
    substr rx1176_tgt, rx1176_tgt, rx1176_off
  rx1176_start:
    eq $I10, 1, rx1176_restart
    if_null rx1176_debug, debug_897
    rx1176_cur."!cursor_debug"("START", "pod_comment")
  debug_897:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1177_done
    goto rxscan1177_scan
  rxscan1177_loop:
    (rx1176_pos) = rx1176_cur."from"()
    inc rx1176_pos
    rx1176_cur."!cursor_from"(rx1176_pos)
    ge rx1176_pos, rx1176_eos, rxscan1177_done
  rxscan1177_scan:
    set_addr $I10, rxscan1177_loop
    rx1176_cur."!mark_push"(0, rx1176_pos, $I10)
  rxscan1177_done:
.annotate 'line', 504
  # rxanchor bol
    eq rx1176_pos, 0, rxanchor1178_done
    ge rx1176_pos, rx1176_eos, rx1176_fail
    sub $I10, rx1176_pos, rx1176_off
    dec $I10
    is_cclass $I11, .CCLASS_NEWLINE, rx1176_tgt, $I10
    unless $I11, rx1176_fail
  rxanchor1178_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1176_pos, rx1176_off
    set rx1176_rep, 0
    sub $I12, rx1176_eos, rx1176_pos
  rxenumcharlistq1179_loop:
    le $I12, 0, rxenumcharlistq1179_done
    substr $S10, rx1176_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1179_done
    inc rx1176_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1179_loop
  rxenumcharlistq1179_done:
    add rx1176_pos, rx1176_pos, rx1176_rep
  # rx literal  "="
    add $I11, rx1176_pos, 1
    gt $I11, rx1176_eos, rx1176_fail
    sub $I11, rx1176_pos, rx1176_off
    ord $I11, rx1176_tgt, $I11
    ne $I11, 61, rx1176_fail
    add rx1176_pos, 1
  alt1180_0:
.annotate 'line', 505
    set_addr $I10, alt1180_1
    rx1176_cur."!mark_push"(0, rx1176_pos, $I10)
.annotate 'line', 506
  # rx literal  "begin"
    add $I11, rx1176_pos, 5
    gt $I11, rx1176_eos, rx1176_fail
    sub $I11, rx1176_pos, rx1176_off
    substr $S10, rx1176_tgt, $I11, 5
    ne $S10, "begin", rx1176_fail
    add rx1176_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx1176_pos, rx1176_off
    set rx1176_rep, 0
    sub $I12, rx1176_eos, rx1176_pos
  rxenumcharlistq1181_loop:
    le $I12, 0, rxenumcharlistq1181_done
    substr $S10, rx1176_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1181_done
    inc rx1176_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1181_loop
  rxenumcharlistq1181_done:
    lt rx1176_rep, 1, rx1176_fail
    add rx1176_pos, rx1176_pos, rx1176_rep
  # rx literal  "END"
    add $I11, rx1176_pos, 3
    gt $I11, rx1176_eos, rx1176_fail
    sub $I11, rx1176_pos, rx1176_off
    substr $S10, rx1176_tgt, $I11, 3
    ne $S10, "END", rx1176_fail
    add rx1176_pos, 3
  # rxanchor rwb
    le rx1176_pos, 0, rx1176_fail
    sub $I10, rx1176_pos, rx1176_off
    is_cclass $I11, .CCLASS_WORD, rx1176_tgt, $I10
    if $I11, rx1176_fail
    dec $I10
    is_cclass $I11, .CCLASS_WORD, rx1176_tgt, $I10
    unless $I11, rx1176_fail
  alt1182_0:
.annotate 'line', 507
    set_addr $I10, alt1182_1
    rx1176_cur."!mark_push"(0, rx1176_pos, $I10)
  # rx rxquantf1183 ** 0..*
    set_addr $I10, rxquantf1183_loop
    rx1176_cur."!mark_push"(0, rx1176_pos, $I10)
    goto rxquantf1183_done
  rxquantf1183_loop:
  # rx charclass .
    ge rx1176_pos, rx1176_eos, rx1176_fail
    inc rx1176_pos
    set_addr $I10, rxquantf1183_loop
    rx1176_cur."!mark_push"(rx1176_rep, rx1176_pos, $I10)
  rxquantf1183_done:
  # rx charclass nl
    ge rx1176_pos, rx1176_eos, rx1176_fail
    sub $I10, rx1176_pos, rx1176_off
    is_cclass $I11, .CCLASS_NEWLINE, rx1176_tgt, $I10
    unless $I11, rx1176_fail
    substr $S10, rx1176_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx1176_pos, $I11
    inc rx1176_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1176_pos, rx1176_off
    set rx1176_rep, 0
    sub $I12, rx1176_eos, rx1176_pos
  rxenumcharlistq1185_loop:
    le $I12, 0, rxenumcharlistq1185_done
    substr $S10, rx1176_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1185_done
    inc rx1176_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1185_loop
  rxenumcharlistq1185_done:
    add rx1176_pos, rx1176_pos, rx1176_rep
  # rx literal  "=end"
    add $I11, rx1176_pos, 4
    gt $I11, rx1176_eos, rx1176_fail
    sub $I11, rx1176_pos, rx1176_off
    substr $S10, rx1176_tgt, $I11, 4
    ne $S10, "=end", rx1176_fail
    add rx1176_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx1176_pos, rx1176_off
    set rx1176_rep, 0
    sub $I12, rx1176_eos, rx1176_pos
  rxenumcharlistq1186_loop:
    le $I12, 0, rxenumcharlistq1186_done
    substr $S10, rx1176_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1186_done
    inc rx1176_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1186_loop
  rxenumcharlistq1186_done:
    lt rx1176_rep, 1, rx1176_fail
    add rx1176_pos, rx1176_pos, rx1176_rep
  # rx literal  "END"
    add $I11, rx1176_pos, 3
    gt $I11, rx1176_eos, rx1176_fail
    sub $I11, rx1176_pos, rx1176_off
    substr $S10, rx1176_tgt, $I11, 3
    ne $S10, "END", rx1176_fail
    add rx1176_pos, 3
  # rxanchor rwb
    le rx1176_pos, 0, rx1176_fail
    sub $I10, rx1176_pos, rx1176_off
    is_cclass $I11, .CCLASS_WORD, rx1176_tgt, $I10
    if $I11, rx1176_fail
    dec $I10
    is_cclass $I11, .CCLASS_WORD, rx1176_tgt, $I10
    unless $I11, rx1176_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx1176_pos, rx1176_off
    find_cclass $I11, .CCLASS_NEWLINE, rx1176_tgt, $I10, rx1176_eos
    add rx1176_pos, rx1176_off, $I11
    goto alt1182_end
  alt1182_1:
  # rx charclass_q . r 0..-1
    sub $I10, rx1176_pos, rx1176_off
    find_not_cclass $I11, .CCLASS_ANY, rx1176_tgt, $I10, rx1176_eos
    add rx1176_pos, rx1176_off, $I11
  alt1182_end:
.annotate 'line', 506
    goto alt1180_end
  alt1180_1:
    set_addr $I10, alt1180_2
    rx1176_cur."!mark_push"(0, rx1176_pos, $I10)
.annotate 'line', 508
  # rx literal  "begin"
    add $I11, rx1176_pos, 5
    gt $I11, rx1176_eos, rx1176_fail
    sub $I11, rx1176_pos, rx1176_off
    substr $S10, rx1176_tgt, $I11, 5
    ne $S10, "begin", rx1176_fail
    add rx1176_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx1176_pos, rx1176_off
    set rx1176_rep, 0
    sub $I12, rx1176_eos, rx1176_pos
  rxenumcharlistq1187_loop:
    le $I12, 0, rxenumcharlistq1187_done
    substr $S10, rx1176_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1187_done
    inc rx1176_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1187_loop
  rxenumcharlistq1187_done:
    lt rx1176_rep, 1, rx1176_fail
    add rx1176_pos, rx1176_pos, rx1176_rep
  # rx subrule "identifier" subtype=capture negate=
    rx1176_cur."!cursor_pos"(rx1176_pos)
    $P10 = rx1176_cur."identifier"()
    unless $P10, rx1176_fail
    rx1176_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx1176_pos = $P10."pos"()
  alt1188_0:
.annotate 'line', 509
    set_addr $I10, alt1188_1
    rx1176_cur."!mark_push"(0, rx1176_pos, $I10)
.annotate 'line', 510
  # rx rxquantf1189 ** 0..*
    set_addr $I10, rxquantf1189_loop
    rx1176_cur."!mark_push"(0, rx1176_pos, $I10)
    goto rxquantf1189_done
  rxquantf1189_loop:
  # rx charclass .
    ge rx1176_pos, rx1176_eos, rx1176_fail
    inc rx1176_pos
    set_addr $I10, rxquantf1189_loop
    rx1176_cur."!mark_push"(rx1176_rep, rx1176_pos, $I10)
  rxquantf1189_done:
  # rx charclass nl
    ge rx1176_pos, rx1176_eos, rx1176_fail
    sub $I10, rx1176_pos, rx1176_off
    is_cclass $I11, .CCLASS_NEWLINE, rx1176_tgt, $I10
    unless $I11, rx1176_fail
    substr $S10, rx1176_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx1176_pos, $I11
    inc rx1176_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1176_pos, rx1176_off
    set rx1176_rep, 0
    sub $I12, rx1176_eos, rx1176_pos
  rxenumcharlistq1191_loop:
    le $I12, 0, rxenumcharlistq1191_done
    substr $S10, rx1176_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1191_done
    inc rx1176_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1191_loop
  rxenumcharlistq1191_done:
    add rx1176_pos, rx1176_pos, rx1176_rep
  # rx literal  "=end"
    add $I11, rx1176_pos, 4
    gt $I11, rx1176_eos, rx1176_fail
    sub $I11, rx1176_pos, rx1176_off
    substr $S10, rx1176_tgt, $I11, 4
    ne $S10, "=end", rx1176_fail
    add rx1176_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx1176_pos, rx1176_off
    set rx1176_rep, 0
    sub $I12, rx1176_eos, rx1176_pos
  rxenumcharlistq1192_loop:
    le $I12, 0, rxenumcharlistq1192_done
    substr $S10, rx1176_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1192_done
    inc rx1176_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1192_loop
  rxenumcharlistq1192_done:
    lt rx1176_rep, 1, rx1176_fail
    add rx1176_pos, rx1176_pos, rx1176_rep
  # rx subrule "!BACKREF" subtype=method negate=
    rx1176_cur."!cursor_pos"(rx1176_pos)
    $P10 = rx1176_cur."!BACKREF"("identifier")
    unless $P10, rx1176_fail
    rx1176_pos = $P10."pos"()
  # rxanchor rwb
    le rx1176_pos, 0, rx1176_fail
    sub $I10, rx1176_pos, rx1176_off
    is_cclass $I11, .CCLASS_WORD, rx1176_tgt, $I10
    if $I11, rx1176_fail
    dec $I10
    is_cclass $I11, .CCLASS_WORD, rx1176_tgt, $I10
    unless $I11, rx1176_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx1176_pos, rx1176_off
    find_cclass $I11, .CCLASS_NEWLINE, rx1176_tgt, $I10, rx1176_eos
    add rx1176_pos, rx1176_off, $I11
    goto alt1188_end
  alt1188_1:
.annotate 'line', 511
  # rx subrule "panic" subtype=method negate=
    rx1176_cur."!cursor_pos"(rx1176_pos)
    $P10 = rx1176_cur."panic"("=begin without matching =end")
    unless $P10, rx1176_fail
    rx1176_pos = $P10."pos"()
  alt1188_end:
.annotate 'line', 508
    goto alt1180_end
  alt1180_2:
    set_addr $I10, alt1180_3
    rx1176_cur."!mark_push"(0, rx1176_pos, $I10)
.annotate 'line', 513
  # rx literal  "begin"
    add $I11, rx1176_pos, 5
    gt $I11, rx1176_eos, rx1176_fail
    sub $I11, rx1176_pos, rx1176_off
    substr $S10, rx1176_tgt, $I11, 5
    ne $S10, "begin", rx1176_fail
    add rx1176_pos, 5
  # rxanchor rwb
    le rx1176_pos, 0, rx1176_fail
    sub $I10, rx1176_pos, rx1176_off
    is_cclass $I11, .CCLASS_WORD, rx1176_tgt, $I10
    if $I11, rx1176_fail
    dec $I10
    is_cclass $I11, .CCLASS_WORD, rx1176_tgt, $I10
    unless $I11, rx1176_fail
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1176_pos, rx1176_off
    set rx1176_rep, 0
    sub $I12, rx1176_eos, rx1176_pos
  rxenumcharlistq1194_loop:
    le $I12, 0, rxenumcharlistq1194_done
    substr $S10, rx1176_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1194_done
    inc rx1176_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1194_loop
  rxenumcharlistq1194_done:
    add rx1176_pos, rx1176_pos, rx1176_rep
  alt1195_0:
.annotate 'line', 514
    set_addr $I10, alt1195_1
    rx1176_cur."!mark_push"(0, rx1176_pos, $I10)
  # rxanchor eol
    sub $I10, rx1176_pos, rx1176_off
    is_cclass $I11, .CCLASS_NEWLINE, rx1176_tgt, $I10
    if $I11, rxanchor1196_done
    ne rx1176_pos, rx1176_eos, rx1176_fail
    eq rx1176_pos, 0, rxanchor1196_done
    dec $I10
    is_cclass $I11, .CCLASS_NEWLINE, rx1176_tgt, $I10
    if $I11, rx1176_fail
  rxanchor1196_done:
    goto alt1195_end
  alt1195_1:
    set_addr $I10, alt1195_2
    rx1176_cur."!mark_push"(0, rx1176_pos, $I10)
  # rx literal  "#"
    add $I11, rx1176_pos, 1
    gt $I11, rx1176_eos, rx1176_fail
    sub $I11, rx1176_pos, rx1176_off
    ord $I11, rx1176_tgt, $I11
    ne $I11, 35, rx1176_fail
    add rx1176_pos, 1
    goto alt1195_end
  alt1195_2:
  # rx subrule "panic" subtype=method negate=
    rx1176_cur."!cursor_pos"(rx1176_pos)
    $P10 = rx1176_cur."panic"("Unrecognized token after =begin")
    unless $P10, rx1176_fail
    rx1176_pos = $P10."pos"()
  alt1195_end:
  alt1197_0:
.annotate 'line', 515
    set_addr $I10, alt1197_1
    rx1176_cur."!mark_push"(0, rx1176_pos, $I10)
.annotate 'line', 516
  # rx rxquantf1198 ** 0..*
    set_addr $I10, rxquantf1198_loop
    rx1176_cur."!mark_push"(0, rx1176_pos, $I10)
    goto rxquantf1198_done
  rxquantf1198_loop:
  # rx charclass .
    ge rx1176_pos, rx1176_eos, rx1176_fail
    inc rx1176_pos
    set_addr $I10, rxquantf1198_loop
    rx1176_cur."!mark_push"(rx1176_rep, rx1176_pos, $I10)
  rxquantf1198_done:
  # rx charclass nl
    ge rx1176_pos, rx1176_eos, rx1176_fail
    sub $I10, rx1176_pos, rx1176_off
    is_cclass $I11, .CCLASS_NEWLINE, rx1176_tgt, $I10
    unless $I11, rx1176_fail
    substr $S10, rx1176_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx1176_pos, $I11
    inc rx1176_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1176_pos, rx1176_off
    set rx1176_rep, 0
    sub $I12, rx1176_eos, rx1176_pos
  rxenumcharlistq1200_loop:
    le $I12, 0, rxenumcharlistq1200_done
    substr $S10, rx1176_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1200_done
    inc rx1176_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1200_loop
  rxenumcharlistq1200_done:
    add rx1176_pos, rx1176_pos, rx1176_rep
  # rx literal  "=end"
    add $I11, rx1176_pos, 4
    gt $I11, rx1176_eos, rx1176_fail
    sub $I11, rx1176_pos, rx1176_off
    substr $S10, rx1176_tgt, $I11, 4
    ne $S10, "=end", rx1176_fail
    add rx1176_pos, 4
  # rxanchor rwb
    le rx1176_pos, 0, rx1176_fail
    sub $I10, rx1176_pos, rx1176_off
    is_cclass $I11, .CCLASS_WORD, rx1176_tgt, $I10
    if $I11, rx1176_fail
    dec $I10
    is_cclass $I11, .CCLASS_WORD, rx1176_tgt, $I10
    unless $I11, rx1176_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx1176_pos, rx1176_off
    find_cclass $I11, .CCLASS_NEWLINE, rx1176_tgt, $I10, rx1176_eos
    add rx1176_pos, rx1176_off, $I11
    goto alt1197_end
  alt1197_1:
.annotate 'line', 517
  # rx subrule "panic" subtype=method negate=
    rx1176_cur."!cursor_pos"(rx1176_pos)
    $P10 = rx1176_cur."panic"("=begin without matching =end")
    unless $P10, rx1176_fail
    rx1176_pos = $P10."pos"()
  alt1197_end:
.annotate 'line', 513
    goto alt1180_end
  alt1180_3:
    set_addr $I10, alt1180_4
    rx1176_cur."!mark_push"(0, rx1176_pos, $I10)
.annotate 'line', 519
  # rx subrule "identifier" subtype=capture negate=
    rx1176_cur."!cursor_pos"(rx1176_pos)
    $P10 = rx1176_cur."identifier"()
    unless $P10, rx1176_fail
    rx1176_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx1176_pos = $P10."pos"()
.annotate 'line', 520
  # rx rxquantf1201 ** 0..*
    set_addr $I10, rxquantf1201_loop
    rx1176_cur."!mark_push"(0, rx1176_pos, $I10)
    goto rxquantf1201_done
  rxquantf1201_loop:
  # rx charclass .
    ge rx1176_pos, rx1176_eos, rx1176_fail
    inc rx1176_pos
    set_addr $I10, rxquantf1201_loop
    rx1176_cur."!mark_push"(rx1176_rep, rx1176_pos, $I10)
  rxquantf1201_done:
  # rxanchor bol
    eq rx1176_pos, 0, rxanchor1203_done
    ge rx1176_pos, rx1176_eos, rx1176_fail
    sub $I10, rx1176_pos, rx1176_off
    dec $I10
    is_cclass $I11, .CCLASS_NEWLINE, rx1176_tgt, $I10
    unless $I11, rx1176_fail
  rxanchor1203_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx1176_cur."!cursor_pos"(rx1176_pos)
    .const 'Sub' $P1205 = "56_1307873304.82979" 
    capture_lex $P1205
    $P10 = rx1176_cur."before"($P1205)
    unless $P10, rx1176_fail
.annotate 'line', 519
    goto alt1180_end
  alt1180_4:
  alt1211_0:
.annotate 'line', 526
    set_addr $I10, alt1211_1
    rx1176_cur."!mark_push"(0, rx1176_pos, $I10)
  # rx charclass s
    ge rx1176_pos, rx1176_eos, rx1176_fail
    sub $I10, rx1176_pos, rx1176_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1176_tgt, $I10
    unless $I11, rx1176_fail
    inc rx1176_pos
    goto alt1211_end
  alt1211_1:
  # rx subrule "panic" subtype=method negate=
    rx1176_cur."!cursor_pos"(rx1176_pos)
    $P10 = rx1176_cur."panic"("Illegal pod directive")
    unless $P10, rx1176_fail
    rx1176_pos = $P10."pos"()
  alt1211_end:
.annotate 'line', 527
  # rx charclass_q N r 0..-1
    sub $I10, rx1176_pos, rx1176_off
    find_cclass $I11, .CCLASS_NEWLINE, rx1176_tgt, $I10, rx1176_eos
    add rx1176_pos, rx1176_off, $I11
  alt1180_end:
.annotate 'line', 503
  # rx pass
    rx1176_cur."!cursor_pass"(rx1176_pos, "pod_comment")
    if_null rx1176_debug, debug_902
    rx1176_cur."!cursor_debug"("PASS", "pod_comment", " at pos=", rx1176_pos)
  debug_902:
    .return (rx1176_cur)
  rx1176_restart:
.annotate 'line', 436
    if_null rx1176_debug, debug_903
    rx1176_cur."!cursor_debug"("NEXT", "pod_comment")
  debug_903:
  rx1176_fail:
    (rx1176_rep, rx1176_pos, $I10, $P10) = rx1176_cur."!mark_fail"(0)
    lt rx1176_pos, -1, rx1176_done
    eq rx1176_pos, -1, rx1176_fail
    jump $I10
  rx1176_done:
    rx1176_cur."!cursor_fail"()
    if_null rx1176_debug, debug_904
    rx1176_cur."!cursor_debug"("FAIL", "pod_comment")
  debug_904:
    .return (rx1176_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1204"  :anon :subid("56_1307873304.82979") :method :outer("55_1307873304.82979")
.annotate 'line', 520
    .local string rx1206_tgt
    .local int rx1206_pos
    .local int rx1206_off
    .local int rx1206_eos
    .local int rx1206_rep
    .local pmc rx1206_cur
    .local pmc rx1206_debug
    (rx1206_cur, rx1206_pos, rx1206_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1206_cur
    .local pmc match
    .lex "$/", match
    length rx1206_eos, rx1206_tgt
    gt rx1206_pos, rx1206_eos, rx1206_done
    set rx1206_off, 0
    lt rx1206_pos, 2, rx1206_start
    sub rx1206_off, rx1206_pos, 1
    substr rx1206_tgt, rx1206_tgt, rx1206_off
  rx1206_start:
    eq $I10, 1, rx1206_restart
    if_null rx1206_debug, debug_898
    rx1206_cur."!cursor_debug"("START", "")
  debug_898:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1207_done
    goto rxscan1207_scan
  rxscan1207_loop:
    (rx1206_pos) = rx1206_cur."from"()
    inc rx1206_pos
    rx1206_cur."!cursor_from"(rx1206_pos)
    ge rx1206_pos, rx1206_eos, rxscan1207_done
  rxscan1207_scan:
    set_addr $I10, rxscan1207_loop
    rx1206_cur."!mark_push"(0, rx1206_pos, $I10)
  rxscan1207_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1206_pos, rx1206_off
    set rx1206_rep, 0
    sub $I12, rx1206_eos, rx1206_pos
  rxenumcharlistq1208_loop:
    le $I12, 0, rxenumcharlistq1208_done
    substr $S10, rx1206_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1208_done
    inc rx1206_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1208_loop
  rxenumcharlistq1208_done:
    add rx1206_pos, rx1206_pos, rx1206_rep
  alt1209_0:
    set_addr $I10, alt1209_1
    rx1206_cur."!mark_push"(0, rx1206_pos, $I10)
.annotate 'line', 521
  # rx literal  "="
    add $I11, rx1206_pos, 1
    gt $I11, rx1206_eos, rx1206_fail
    sub $I11, rx1206_pos, rx1206_off
    ord $I11, rx1206_tgt, $I11
    ne $I11, 61, rx1206_fail
    add rx1206_pos, 1
.annotate 'line', 523
  # rx rxquantr1210 ** 0..1
    set_addr $I10, rxquantr1210_done
    rx1206_cur."!mark_push"(0, rx1206_pos, $I10)
  rxquantr1210_loop:
.annotate 'line', 522
  # rx literal  "cut"
    add $I11, rx1206_pos, 3
    gt $I11, rx1206_eos, rx1206_fail
    sub $I11, rx1206_pos, rx1206_off
    substr $S10, rx1206_tgt, $I11, 3
    ne $S10, "cut", rx1206_fail
    add rx1206_pos, 3
  # rxanchor rwb
    le rx1206_pos, 0, rx1206_fail
    sub $I10, rx1206_pos, rx1206_off
    is_cclass $I11, .CCLASS_WORD, rx1206_tgt, $I10
    if $I11, rx1206_fail
    dec $I10
    is_cclass $I11, .CCLASS_WORD, rx1206_tgt, $I10
    unless $I11, rx1206_fail
.annotate 'line', 523
  # rx subrule "panic" subtype=method negate=
    rx1206_cur."!cursor_pos"(rx1206_pos)
    $P10 = rx1206_cur."panic"("Obsolete pod format, please use =begin/=end instead")
    unless $P10, rx1206_fail
    rx1206_pos = $P10."pos"()
    set_addr $I10, rxquantr1210_done
    (rx1206_rep) = rx1206_cur."!mark_commit"($I10)
  rxquantr1210_done:
.annotate 'line', 520
    goto alt1209_end
  alt1209_1:
.annotate 'line', 524
  # rx charclass nl
    ge rx1206_pos, rx1206_eos, rx1206_fail
    sub $I10, rx1206_pos, rx1206_off
    is_cclass $I11, .CCLASS_NEWLINE, rx1206_tgt, $I10
    unless $I11, rx1206_fail
    substr $S10, rx1206_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx1206_pos, $I11
    inc rx1206_pos
  alt1209_end:
.annotate 'line', 520
  # rx pass
    rx1206_cur."!cursor_pass"(rx1206_pos, "")
    if_null rx1206_debug, debug_899
    rx1206_cur."!cursor_debug"("PASS", "", " at pos=", rx1206_pos)
  debug_899:
    .return (rx1206_cur)
  rx1206_restart:
    if_null rx1206_debug, debug_900
    rx1206_cur."!cursor_debug"("NEXT", "")
  debug_900:
  rx1206_fail:
    (rx1206_rep, rx1206_pos, $I10, $P10) = rx1206_cur."!mark_fail"(0)
    lt rx1206_pos, -1, rx1206_done
    eq rx1206_pos, -1, rx1206_fail
    jump $I10
  rx1206_done:
    rx1206_cur."!cursor_fail"()
    if_null rx1206_debug, debug_901
    rx1206_cur."!cursor_debug"("FAIL", "")
  debug_901:
    .return (rx1206_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pod_comment"  :subid("57_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    new $P1213, "ResizablePMCArray"
    push $P1213, ""
    .return ($P1213)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "comp_unit"  :subid("58_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 535
    new $P1215, "Undef"
    .lex "$*IN_DECL", $P1215
.annotate 'line', 537
    new $P1216, "Undef"
    .lex "$*HAS_YOU_ARE_HERE", $P1216
.annotate 'line', 538
    new $P1217, "Undef"
    .lex "$*MAIN_SUB", $P1217
.annotate 'line', 541
    new $P1218, "Undef"
    .lex "$*PACKAGE", $P1218
.annotate 'line', 542
    new $P1219, "Undef"
    .lex "$*GLOBALish", $P1219
.annotate 'line', 436
    .local string rx1220_tgt
    .local int rx1220_pos
    .local int rx1220_off
    .local int rx1220_eos
    .local int rx1220_rep
    .local pmc rx1220_cur
    .local pmc rx1220_debug
    (rx1220_cur, rx1220_pos, rx1220_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1220_cur
    .local pmc match
    .lex "$/", match
    length rx1220_eos, rx1220_tgt
    gt rx1220_pos, rx1220_eos, rx1220_done
    set rx1220_off, 0
    lt rx1220_pos, 2, rx1220_start
    sub rx1220_off, rx1220_pos, 1
    substr rx1220_tgt, rx1220_tgt, rx1220_off
  rx1220_start:
    eq $I10, 1, rx1220_restart
    if_null rx1220_debug, debug_905
    rx1220_cur."!cursor_debug"("START", "comp_unit")
  debug_905:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1221_done
    goto rxscan1221_scan
  rxscan1221_loop:
    (rx1220_pos) = rx1220_cur."from"()
    inc rx1220_pos
    rx1220_cur."!cursor_from"(rx1220_pos)
    ge rx1220_pos, rx1220_eos, rxscan1221_done
  rxscan1221_scan:
    set_addr $I10, rxscan1221_loop
    rx1220_cur."!mark_push"(0, rx1220_pos, $I10)
  rxscan1221_done:
.annotate 'line', 535
    rx1220_cur."!cursor_pos"(rx1220_pos)
    new $P1222, "String"
    assign $P1222, ""
    store_lex "$*IN_DECL", $P1222
.annotate 'line', 537
    rx1220_cur."!cursor_pos"(rx1220_pos)
    new $P1223, "Integer"
    assign $P1223, 0
    store_lex "$*HAS_YOU_ARE_HERE", $P1223
.annotate 'line', 538
    rx1220_cur."!cursor_pos"(rx1220_pos)
    find_lex $P1226, "$*MAIN_SUB"
    unless_null $P1226, vivify_906
    get_hll_global $P1224, "GLOBAL"
    get_who $P1225, $P1224
    set $P1226, $P1225["$MAIN_SUB"]
    unless_null $P1226, vivify_907
    die "Contextual $*MAIN_SUB not found"
  vivify_907:
  vivify_906:
.annotate 'line', 539
  # rx subrule "newpad" subtype=method negate=
    rx1220_cur."!cursor_pos"(rx1220_pos)
    $P10 = rx1220_cur."newpad"()
    unless $P10, rx1220_fail
    rx1220_pos = $P10."pos"()
.annotate 'line', 541
    rx1220_cur."!cursor_pos"(rx1220_pos)
    find_lex $P1229, "$*PACKAGE"
    unless_null $P1229, vivify_908
    get_hll_global $P1227, "GLOBAL"
    get_who $P1228, $P1227
    set $P1229, $P1228["$PACKAGE"]
    unless_null $P1229, vivify_909
    die "Contextual $*PACKAGE not found"
  vivify_909:
  vivify_908:
.annotate 'line', 542
    rx1220_cur."!cursor_pos"(rx1220_pos)
    find_lex $P1232, "$*GLOBALish"
    unless_null $P1232, vivify_910
    get_hll_global $P1230, "GLOBAL"
    get_who $P1231, $P1230
    set $P1232, $P1231["$GLOBALish"]
    unless_null $P1232, vivify_911
    die "Contextual $*GLOBALish not found"
  vivify_911:
  vivify_910:
.annotate 'line', 543
  # rx subrule "GLOBALish" subtype=method negate=
    rx1220_cur."!cursor_pos"(rx1220_pos)
    $P10 = rx1220_cur."GLOBALish"()
    unless $P10, rx1220_fail
    rx1220_pos = $P10."pos"()
.annotate 'line', 545
  # rx subrule "outerctx" subtype=method negate=
    rx1220_cur."!cursor_pos"(rx1220_pos)
    $P10 = rx1220_cur."outerctx"()
    unless $P10, rx1220_fail
    rx1220_pos = $P10."pos"()
.annotate 'line', 547
  # rx subrule "statementlist" subtype=capture negate=
    rx1220_cur."!cursor_pos"(rx1220_pos)
    $P10 = rx1220_cur."statementlist"()
    unless $P10, rx1220_fail
    rx1220_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx1220_pos = $P10."pos"()
  alt1233_0:
.annotate 'line', 548
    set_addr $I10, alt1233_1
    rx1220_cur."!mark_push"(0, rx1220_pos, $I10)
  # rxanchor eos
    ne rx1220_pos, rx1220_eos, rx1220_fail
    goto alt1233_end
  alt1233_1:
  # rx subrule "panic" subtype=method negate=
    rx1220_cur."!cursor_pos"(rx1220_pos)
    $P10 = rx1220_cur."panic"("Confused")
    unless $P10, rx1220_fail
    rx1220_pos = $P10."pos"()
  alt1233_end:
.annotate 'line', 534
  # rx pass
    rx1220_cur."!cursor_pass"(rx1220_pos, "comp_unit")
    if_null rx1220_debug, debug_912
    rx1220_cur."!cursor_debug"("PASS", "comp_unit", " at pos=", rx1220_pos)
  debug_912:
    .return (rx1220_cur)
  rx1220_restart:
.annotate 'line', 436
    if_null rx1220_debug, debug_913
    rx1220_cur."!cursor_debug"("NEXT", "comp_unit")
  debug_913:
  rx1220_fail:
    (rx1220_rep, rx1220_pos, $I10, $P10) = rx1220_cur."!mark_fail"(0)
    lt rx1220_pos, -1, rx1220_done
    eq rx1220_pos, -1, rx1220_fail
    jump $I10
  rx1220_done:
    rx1220_cur."!cursor_fail"()
    if_null rx1220_debug, debug_914
    rx1220_cur."!cursor_debug"("FAIL", "comp_unit")
  debug_914:
    .return (rx1220_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__comp_unit"  :subid("59_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P1235 = self."!PREFIX__!subrule"("newpad", "")
    new $P1236, "ResizablePMCArray"
    push $P1236, $P1235
    .return ($P1236)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statementlist"  :subid("60_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx1238_tgt
    .local int rx1238_pos
    .local int rx1238_off
    .local int rx1238_eos
    .local int rx1238_rep
    .local pmc rx1238_cur
    .local pmc rx1238_debug
    (rx1238_cur, rx1238_pos, rx1238_tgt, $I10) = self."!cursor_start"()
    rx1238_cur."!cursor_caparray"("statement")
    .lex unicode:"$\x{a2}", rx1238_cur
    .local pmc match
    .lex "$/", match
    length rx1238_eos, rx1238_tgt
    gt rx1238_pos, rx1238_eos, rx1238_done
    set rx1238_off, 0
    lt rx1238_pos, 2, rx1238_start
    sub rx1238_off, rx1238_pos, 1
    substr rx1238_tgt, rx1238_tgt, rx1238_off
  rx1238_start:
    eq $I10, 1, rx1238_restart
    if_null rx1238_debug, debug_915
    rx1238_cur."!cursor_debug"("START", "statementlist")
  debug_915:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1239_done
    goto rxscan1239_scan
  rxscan1239_loop:
    (rx1238_pos) = rx1238_cur."from"()
    inc rx1238_pos
    rx1238_cur."!cursor_from"(rx1238_pos)
    ge rx1238_pos, rx1238_eos, rxscan1239_done
  rxscan1239_scan:
    set_addr $I10, rxscan1239_loop
    rx1238_cur."!mark_push"(0, rx1238_pos, $I10)
  rxscan1239_done:
  alt1240_0:
.annotate 'line', 551
    set_addr $I10, alt1240_1
    rx1238_cur."!mark_push"(0, rx1238_pos, $I10)
.annotate 'line', 552
  # rx subrule "ws" subtype=method negate=
    rx1238_cur."!cursor_pos"(rx1238_pos)
    $P10 = rx1238_cur."ws"()
    unless $P10, rx1238_fail
    rx1238_pos = $P10."pos"()
  # rxanchor eos
    ne rx1238_pos, rx1238_eos, rx1238_fail
  # rx subrule "ws" subtype=method negate=
    rx1238_cur."!cursor_pos"(rx1238_pos)
    $P10 = rx1238_cur."ws"()
    unless $P10, rx1238_fail
    rx1238_pos = $P10."pos"()
    goto alt1240_end
  alt1240_1:
.annotate 'line', 553
  # rx subrule "ws" subtype=method negate=
    rx1238_cur."!cursor_pos"(rx1238_pos)
    $P10 = rx1238_cur."ws"()
    unless $P10, rx1238_fail
    rx1238_pos = $P10."pos"()
  # rx rxquantr1244 ** 0..*
    set_addr $I10, rxquantr1244_done
    rx1238_cur."!mark_push"(0, rx1238_pos, $I10)
  rxquantr1244_loop:
  # rx subrule "statement" subtype=capture negate=
    rx1238_cur."!cursor_pos"(rx1238_pos)
    $P10 = rx1238_cur."statement"()
    unless $P10, rx1238_fail
    rx1238_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx1238_pos = $P10."pos"()
  # rx subrule "eat_terminator" subtype=method negate=
    rx1238_cur."!cursor_pos"(rx1238_pos)
    $P10 = rx1238_cur."eat_terminator"()
    unless $P10, rx1238_fail
    rx1238_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1238_cur."!cursor_pos"(rx1238_pos)
    $P10 = rx1238_cur."ws"()
    unless $P10, rx1238_fail
    rx1238_pos = $P10."pos"()
    set_addr $I10, rxquantr1244_done
    (rx1238_rep) = rx1238_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1244_done
    rx1238_cur."!mark_push"(rx1238_rep, rx1238_pos, $I10)
    goto rxquantr1244_loop
  rxquantr1244_done:
  # rx subrule "ws" subtype=method negate=
    rx1238_cur."!cursor_pos"(rx1238_pos)
    $P10 = rx1238_cur."ws"()
    unless $P10, rx1238_fail
    rx1238_pos = $P10."pos"()
  alt1240_end:
.annotate 'line', 551
  # rx pass
    rx1238_cur."!cursor_pass"(rx1238_pos, "statementlist")
    if_null rx1238_debug, debug_916
    rx1238_cur."!cursor_debug"("PASS", "statementlist", " at pos=", rx1238_pos)
  debug_916:
    .return (rx1238_cur)
  rx1238_restart:
.annotate 'line', 436
    if_null rx1238_debug, debug_917
    rx1238_cur."!cursor_debug"("NEXT", "statementlist")
  debug_917:
  rx1238_fail:
    (rx1238_rep, rx1238_pos, $I10, $P10) = rx1238_cur."!mark_fail"(0)
    lt rx1238_pos, -1, rx1238_done
    eq rx1238_pos, -1, rx1238_fail
    jump $I10
  rx1238_done:
    rx1238_cur."!cursor_fail"()
    if_null rx1238_debug, debug_918
    rx1238_cur."!cursor_debug"("FAIL", "statementlist")
  debug_918:
    .return (rx1238_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statementlist"  :subid("61_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P1248 = self."!PREFIX__!subrule"("ws", "")
    $P1249 = self."!PREFIX__!subrule"("ws", "")
    new $P1250, "ResizablePMCArray"
    push $P1250, $P1248
    push $P1250, $P1249
    .return ($P1250)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement"  :subid("62_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .const 'Sub' $P1255 = "63_1307873304.82979" 
    capture_lex $P1255
    .local string rx1252_tgt
    .local int rx1252_pos
    .local int rx1252_off
    .local int rx1252_eos
    .local int rx1252_rep
    .local pmc rx1252_cur
    .local pmc rx1252_debug
    (rx1252_cur, rx1252_pos, rx1252_tgt, $I10) = self."!cursor_start"()
    rx1252_cur."!cursor_caparray"("statement_mod_cond", "statement_mod_loop")
    .lex unicode:"$\x{a2}", rx1252_cur
    .local pmc match
    .lex "$/", match
    length rx1252_eos, rx1252_tgt
    gt rx1252_pos, rx1252_eos, rx1252_done
    set rx1252_off, 0
    lt rx1252_pos, 2, rx1252_start
    sub rx1252_off, rx1252_pos, 1
    substr rx1252_tgt, rx1252_tgt, rx1252_off
  rx1252_start:
    eq $I10, 1, rx1252_restart
    if_null rx1252_debug, debug_919
    rx1252_cur."!cursor_debug"("START", "statement")
  debug_919:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1253_done
    goto rxscan1253_scan
  rxscan1253_loop:
    (rx1252_pos) = rx1252_cur."from"()
    inc rx1252_pos
    rx1252_cur."!cursor_from"(rx1252_pos)
    ge rx1252_pos, rx1252_eos, rxscan1253_done
  rxscan1253_scan:
    set_addr $I10, rxscan1253_loop
    rx1252_cur."!mark_push"(0, rx1252_pos, $I10)
  rxscan1253_done:
.annotate 'line', 557
  # rx subrule "before" subtype=zerowidth negate=1
    rx1252_cur."!cursor_pos"(rx1252_pos)
    .const 'Sub' $P1255 = "63_1307873304.82979" 
    capture_lex $P1255
    $P10 = rx1252_cur."before"($P1255)
    if $P10, rx1252_fail
  alt1259_0:
.annotate 'line', 558
    set_addr $I10, alt1259_1
    rx1252_cur."!mark_push"(0, rx1252_pos, $I10)
.annotate 'line', 559
  # rx subrule "statement_control" subtype=capture negate=
    rx1252_cur."!cursor_pos"(rx1252_pos)
    $P10 = rx1252_cur."statement_control"()
    unless $P10, rx1252_fail
    rx1252_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_control")
    rx1252_pos = $P10."pos"()
    goto alt1259_end
  alt1259_1:
.annotate 'line', 560
  # rx subrule "EXPR" subtype=capture negate=
    rx1252_cur."!cursor_pos"(rx1252_pos)
    $P10 = rx1252_cur."EXPR"()
    unless $P10, rx1252_fail
    rx1252_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1252_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1252_cur."!cursor_pos"(rx1252_pos)
    $P10 = rx1252_cur."ws"()
    unless $P10, rx1252_fail
    rx1252_pos = $P10."pos"()
.annotate 'line', 565
  # rx rxquantr1260 ** 0..1
    set_addr $I10, rxquantr1260_done
    rx1252_cur."!mark_push"(0, rx1252_pos, $I10)
  rxquantr1260_loop:
  alt1261_0:
.annotate 'line', 561
    set_addr $I10, alt1261_1
    rx1252_cur."!mark_push"(0, rx1252_pos, $I10)
.annotate 'line', 562
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx1252_cur."!cursor_pos"(rx1252_pos)
    $P10 = rx1252_cur."MARKED"("endstmt")
    unless $P10, rx1252_fail
    goto alt1261_end
  alt1261_1:
    set_addr $I10, alt1261_2
    rx1252_cur."!mark_push"(0, rx1252_pos, $I10)
.annotate 'line', 563
  # rx subrule "statement_mod_cond" subtype=capture negate=
    rx1252_cur."!cursor_pos"(rx1252_pos)
    $P10 = rx1252_cur."statement_mod_cond"()
    unless $P10, rx1252_fail
    rx1252_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_cond")
    rx1252_pos = $P10."pos"()
  # rx rxquantr1262 ** 0..1
    set_addr $I10, rxquantr1262_done
    rx1252_cur."!mark_push"(0, rx1252_pos, $I10)
  rxquantr1262_loop:
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx1252_cur."!cursor_pos"(rx1252_pos)
    $P10 = rx1252_cur."statement_mod_loop"()
    unless $P10, rx1252_fail
    goto rxsubrule1263_pass
  rxsubrule1263_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1252_fail
  rxsubrule1263_pass:
    set_addr $I10, rxsubrule1263_back
    rx1252_cur."!mark_push"(0, rx1252_pos, $I10, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx1252_pos = $P10."pos"()
    set_addr $I10, rxquantr1262_done
    (rx1252_rep) = rx1252_cur."!mark_commit"($I10)
  rxquantr1262_done:
    goto alt1261_end
  alt1261_2:
.annotate 'line', 564
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx1252_cur."!cursor_pos"(rx1252_pos)
    $P10 = rx1252_cur."statement_mod_loop"()
    unless $P10, rx1252_fail
    rx1252_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx1252_pos = $P10."pos"()
  alt1261_end:
.annotate 'line', 565
    set_addr $I10, rxquantr1260_done
    (rx1252_rep) = rx1252_cur."!mark_commit"($I10)
  rxquantr1260_done:
  alt1259_end:
.annotate 'line', 556
  # rx pass
    rx1252_cur."!cursor_pass"(rx1252_pos, "statement")
    if_null rx1252_debug, debug_924
    rx1252_cur."!cursor_debug"("PASS", "statement", " at pos=", rx1252_pos)
  debug_924:
    .return (rx1252_cur)
  rx1252_restart:
.annotate 'line', 436
    if_null rx1252_debug, debug_925
    rx1252_cur."!cursor_debug"("NEXT", "statement")
  debug_925:
  rx1252_fail:
    (rx1252_rep, rx1252_pos, $I10, $P10) = rx1252_cur."!mark_fail"(0)
    lt rx1252_pos, -1, rx1252_done
    eq rx1252_pos, -1, rx1252_fail
    jump $I10
  rx1252_done:
    rx1252_cur."!cursor_fail"()
    if_null rx1252_debug, debug_926
    rx1252_cur."!cursor_debug"("FAIL", "statement")
  debug_926:
    .return (rx1252_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1254"  :anon :subid("63_1307873304.82979") :method :outer("62_1307873304.82979")
.annotate 'line', 557
    .local string rx1256_tgt
    .local int rx1256_pos
    .local int rx1256_off
    .local int rx1256_eos
    .local int rx1256_rep
    .local pmc rx1256_cur
    .local pmc rx1256_debug
    (rx1256_cur, rx1256_pos, rx1256_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1256_cur
    .local pmc match
    .lex "$/", match
    length rx1256_eos, rx1256_tgt
    gt rx1256_pos, rx1256_eos, rx1256_done
    set rx1256_off, 0
    lt rx1256_pos, 2, rx1256_start
    sub rx1256_off, rx1256_pos, 1
    substr rx1256_tgt, rx1256_tgt, rx1256_off
  rx1256_start:
    eq $I10, 1, rx1256_restart
    if_null rx1256_debug, debug_920
    rx1256_cur."!cursor_debug"("START", "")
  debug_920:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1257_done
    goto rxscan1257_scan
  rxscan1257_loop:
    (rx1256_pos) = rx1256_cur."from"()
    inc rx1256_pos
    rx1256_cur."!cursor_from"(rx1256_pos)
    ge rx1256_pos, rx1256_eos, rxscan1257_done
  rxscan1257_scan:
    set_addr $I10, rxscan1257_loop
    rx1256_cur."!mark_push"(0, rx1256_pos, $I10)
  rxscan1257_done:
  alt1258_0:
    set_addr $I10, alt1258_1
    rx1256_cur."!mark_push"(0, rx1256_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1256_pos, rx1256_eos, rx1256_fail
    sub $I10, rx1256_pos, rx1256_off
    substr $S10, rx1256_tgt, $I10, 1
    index $I11, "])}", $S10
    lt $I11, 0, rx1256_fail
    inc rx1256_pos
    goto alt1258_end
  alt1258_1:
  # rxanchor eos
    ne rx1256_pos, rx1256_eos, rx1256_fail
  alt1258_end:
  # rx pass
    rx1256_cur."!cursor_pass"(rx1256_pos, "")
    if_null rx1256_debug, debug_921
    rx1256_cur."!cursor_debug"("PASS", "", " at pos=", rx1256_pos)
  debug_921:
    .return (rx1256_cur)
  rx1256_restart:
    if_null rx1256_debug, debug_922
    rx1256_cur."!cursor_debug"("NEXT", "")
  debug_922:
  rx1256_fail:
    (rx1256_rep, rx1256_pos, $I10, $P10) = rx1256_cur."!mark_fail"(0)
    lt rx1256_pos, -1, rx1256_done
    eq rx1256_pos, -1, rx1256_fail
    jump $I10
  rx1256_done:
    rx1256_cur."!cursor_fail"()
    if_null rx1256_debug, debug_923
    rx1256_cur."!cursor_debug"("FAIL", "")
  debug_923:
    .return (rx1256_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement"  :subid("64_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    new $P1265, "ResizablePMCArray"
    push $P1265, ""
    .return ($P1265)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "eat_terminator"  :subid("65_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx1267_tgt
    .local int rx1267_pos
    .local int rx1267_off
    .local int rx1267_eos
    .local int rx1267_rep
    .local pmc rx1267_cur
    .local pmc rx1267_debug
    (rx1267_cur, rx1267_pos, rx1267_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1267_cur
    .local pmc match
    .lex "$/", match
    length rx1267_eos, rx1267_tgt
    gt rx1267_pos, rx1267_eos, rx1267_done
    set rx1267_off, 0
    lt rx1267_pos, 2, rx1267_start
    sub rx1267_off, rx1267_pos, 1
    substr rx1267_tgt, rx1267_tgt, rx1267_off
  rx1267_start:
    eq $I10, 1, rx1267_restart
    if_null rx1267_debug, debug_927
    rx1267_cur."!cursor_debug"("START", "eat_terminator")
  debug_927:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1268_done
    goto rxscan1268_scan
  rxscan1268_loop:
    (rx1267_pos) = rx1267_cur."from"()
    inc rx1267_pos
    rx1267_cur."!cursor_from"(rx1267_pos)
    ge rx1267_pos, rx1267_eos, rxscan1268_done
  rxscan1268_scan:
    set_addr $I10, rxscan1268_loop
    rx1267_cur."!mark_push"(0, rx1267_pos, $I10)
  rxscan1268_done:
  alt1269_0:
.annotate 'line', 569
    set_addr $I10, alt1269_1
    rx1267_cur."!mark_push"(0, rx1267_pos, $I10)
.annotate 'line', 570
  # rx literal  ";"
    add $I11, rx1267_pos, 1
    gt $I11, rx1267_eos, rx1267_fail
    sub $I11, rx1267_pos, rx1267_off
    ord $I11, rx1267_tgt, $I11
    ne $I11, 59, rx1267_fail
    add rx1267_pos, 1
    goto alt1269_end
  alt1269_1:
    set_addr $I10, alt1269_2
    rx1267_cur."!mark_push"(0, rx1267_pos, $I10)
.annotate 'line', 571
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx1267_cur."!cursor_pos"(rx1267_pos)
    $P10 = rx1267_cur."MARKED"("endstmt")
    unless $P10, rx1267_fail
    goto alt1269_end
  alt1269_2:
    set_addr $I10, alt1269_3
    rx1267_cur."!mark_push"(0, rx1267_pos, $I10)
.annotate 'line', 572
  # rx subrule "terminator" subtype=zerowidth negate=
    rx1267_cur."!cursor_pos"(rx1267_pos)
    $P10 = rx1267_cur."terminator"()
    unless $P10, rx1267_fail
    goto alt1269_end
  alt1269_3:
.annotate 'line', 573
  # rxanchor eos
    ne rx1267_pos, rx1267_eos, rx1267_fail
  alt1269_end:
.annotate 'line', 569
  # rx pass
    rx1267_cur."!cursor_pass"(rx1267_pos, "eat_terminator")
    if_null rx1267_debug, debug_928
    rx1267_cur."!cursor_debug"("PASS", "eat_terminator", " at pos=", rx1267_pos)
  debug_928:
    .return (rx1267_cur)
  rx1267_restart:
.annotate 'line', 436
    if_null rx1267_debug, debug_929
    rx1267_cur."!cursor_debug"("NEXT", "eat_terminator")
  debug_929:
  rx1267_fail:
    (rx1267_rep, rx1267_pos, $I10, $P10) = rx1267_cur."!mark_fail"(0)
    lt rx1267_pos, -1, rx1267_done
    eq rx1267_pos, -1, rx1267_fail
    jump $I10
  rx1267_done:
    rx1267_cur."!cursor_fail"()
    if_null rx1267_debug, debug_930
    rx1267_cur."!cursor_debug"("FAIL", "eat_terminator")
  debug_930:
    .return (rx1267_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__eat_terminator"  :subid("66_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    new $P1271, "ResizablePMCArray"
    push $P1271, ""
    push $P1271, ""
    push $P1271, ""
    push $P1271, ";"
    .return ($P1271)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "xblock"  :subid("67_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx1273_tgt
    .local int rx1273_pos
    .local int rx1273_off
    .local int rx1273_eos
    .local int rx1273_rep
    .local pmc rx1273_cur
    .local pmc rx1273_debug
    (rx1273_cur, rx1273_pos, rx1273_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1273_cur
    .local pmc match
    .lex "$/", match
    length rx1273_eos, rx1273_tgt
    gt rx1273_pos, rx1273_eos, rx1273_done
    set rx1273_off, 0
    lt rx1273_pos, 2, rx1273_start
    sub rx1273_off, rx1273_pos, 1
    substr rx1273_tgt, rx1273_tgt, rx1273_off
  rx1273_start:
    eq $I10, 1, rx1273_restart
    if_null rx1273_debug, debug_931
    rx1273_cur."!cursor_debug"("START", "xblock")
  debug_931:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1274_done
    goto rxscan1274_scan
  rxscan1274_loop:
    (rx1273_pos) = rx1273_cur."from"()
    inc rx1273_pos
    rx1273_cur."!cursor_from"(rx1273_pos)
    ge rx1273_pos, rx1273_eos, rxscan1274_done
  rxscan1274_scan:
    set_addr $I10, rxscan1274_loop
    rx1273_cur."!mark_push"(0, rx1273_pos, $I10)
  rxscan1274_done:
.annotate 'line', 577
  # rx subrule "EXPR" subtype=capture negate=
    rx1273_cur."!cursor_pos"(rx1273_pos)
    $P10 = rx1273_cur."EXPR"()
    unless $P10, rx1273_fail
    rx1273_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1273_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1273_cur."!cursor_pos"(rx1273_pos)
    $P10 = rx1273_cur."ws"()
    unless $P10, rx1273_fail
    rx1273_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx1273_cur."!cursor_pos"(rx1273_pos)
    $P10 = rx1273_cur."pblock"()
    unless $P10, rx1273_fail
    rx1273_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx1273_pos = $P10."pos"()
.annotate 'line', 576
  # rx pass
    rx1273_cur."!cursor_pass"(rx1273_pos, "xblock")
    if_null rx1273_debug, debug_932
    rx1273_cur."!cursor_debug"("PASS", "xblock", " at pos=", rx1273_pos)
  debug_932:
    .return (rx1273_cur)
  rx1273_restart:
.annotate 'line', 436
    if_null rx1273_debug, debug_933
    rx1273_cur."!cursor_debug"("NEXT", "xblock")
  debug_933:
  rx1273_fail:
    (rx1273_rep, rx1273_pos, $I10, $P10) = rx1273_cur."!mark_fail"(0)
    lt rx1273_pos, -1, rx1273_done
    eq rx1273_pos, -1, rx1273_fail
    jump $I10
  rx1273_done:
    rx1273_cur."!cursor_fail"()
    if_null rx1273_debug, debug_934
    rx1273_cur."!cursor_debug"("FAIL", "xblock")
  debug_934:
    .return (rx1273_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__xblock"  :subid("68_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P1276 = self."!PREFIX__!subrule"("EXPR", "")
    new $P1277, "ResizablePMCArray"
    push $P1277, $P1276
    .return ($P1277)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pblock"  :subid("69_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx1279_tgt
    .local int rx1279_pos
    .local int rx1279_off
    .local int rx1279_eos
    .local int rx1279_rep
    .local pmc rx1279_cur
    .local pmc rx1279_debug
    (rx1279_cur, rx1279_pos, rx1279_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1279_cur
    .local pmc match
    .lex "$/", match
    length rx1279_eos, rx1279_tgt
    gt rx1279_pos, rx1279_eos, rx1279_done
    set rx1279_off, 0
    lt rx1279_pos, 2, rx1279_start
    sub rx1279_off, rx1279_pos, 1
    substr rx1279_tgt, rx1279_tgt, rx1279_off
  rx1279_start:
    eq $I10, 1, rx1279_restart
    if_null rx1279_debug, debug_935
    rx1279_cur."!cursor_debug"("START", "pblock")
  debug_935:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1280_done
    goto rxscan1280_scan
  rxscan1280_loop:
    (rx1279_pos) = rx1279_cur."from"()
    inc rx1279_pos
    rx1279_cur."!cursor_from"(rx1279_pos)
    ge rx1279_pos, rx1279_eos, rxscan1280_done
  rxscan1280_scan:
    set_addr $I10, rxscan1280_loop
    rx1279_cur."!mark_push"(0, rx1279_pos, $I10)
  rxscan1280_done:
  alt1281_0:
.annotate 'line', 580
    set_addr $I10, alt1281_1
    rx1279_cur."!mark_push"(0, rx1279_pos, $I10)
.annotate 'line', 581
  # rx subrule "lambda" subtype=method negate=
    rx1279_cur."!cursor_pos"(rx1279_pos)
    $P10 = rx1279_cur."lambda"()
    unless $P10, rx1279_fail
    rx1279_pos = $P10."pos"()
.annotate 'line', 582
  # rx subrule "newpad" subtype=method negate=
    rx1279_cur."!cursor_pos"(rx1279_pos)
    $P10 = rx1279_cur."newpad"()
    unless $P10, rx1279_fail
    rx1279_pos = $P10."pos"()
.annotate 'line', 583
  # rx subrule "signature" subtype=capture negate=
    rx1279_cur."!cursor_pos"(rx1279_pos)
    $P10 = rx1279_cur."signature"()
    unless $P10, rx1279_fail
    rx1279_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx1279_pos = $P10."pos"()
.annotate 'line', 584
  # rx subrule "blockoid" subtype=capture negate=
    rx1279_cur."!cursor_pos"(rx1279_pos)
    $P10 = rx1279_cur."blockoid"()
    unless $P10, rx1279_fail
    rx1279_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx1279_pos = $P10."pos"()
.annotate 'line', 581
    goto alt1281_end
  alt1281_1:
    set_addr $I10, alt1281_2
    rx1279_cur."!mark_push"(0, rx1279_pos, $I10)
.annotate 'line', 585
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1279_pos, rx1279_off
    substr $S10, rx1279_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1279_fail
.annotate 'line', 586
  # rx subrule "newpad" subtype=method negate=
    rx1279_cur."!cursor_pos"(rx1279_pos)
    $P10 = rx1279_cur."newpad"()
    unless $P10, rx1279_fail
    rx1279_pos = $P10."pos"()
.annotate 'line', 587
  # rx subrule "blockoid" subtype=capture negate=
    rx1279_cur."!cursor_pos"(rx1279_pos)
    $P10 = rx1279_cur."blockoid"()
    unless $P10, rx1279_fail
    rx1279_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx1279_pos = $P10."pos"()
.annotate 'line', 585
    goto alt1281_end
  alt1281_2:
.annotate 'line', 588
  # rx subrule "panic" subtype=method negate=
    rx1279_cur."!cursor_pos"(rx1279_pos)
    $P10 = rx1279_cur."panic"("Missing block")
    unless $P10, rx1279_fail
    rx1279_pos = $P10."pos"()
  alt1281_end:
.annotate 'line', 580
  # rx pass
    rx1279_cur."!cursor_pass"(rx1279_pos, "pblock")
    if_null rx1279_debug, debug_936
    rx1279_cur."!cursor_debug"("PASS", "pblock", " at pos=", rx1279_pos)
  debug_936:
    .return (rx1279_cur)
  rx1279_restart:
.annotate 'line', 436
    if_null rx1279_debug, debug_937
    rx1279_cur."!cursor_debug"("NEXT", "pblock")
  debug_937:
  rx1279_fail:
    (rx1279_rep, rx1279_pos, $I10, $P10) = rx1279_cur."!mark_fail"(0)
    lt rx1279_pos, -1, rx1279_done
    eq rx1279_pos, -1, rx1279_fail
    jump $I10
  rx1279_done:
    rx1279_cur."!cursor_fail"()
    if_null rx1279_debug, debug_938
    rx1279_cur."!cursor_debug"("FAIL", "pblock")
  debug_938:
    .return (rx1279_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pblock"  :subid("70_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P1283 = self."!PREFIX__!subrule"("panic", "")
    $P1284 = self."!PREFIX__!subrule"("lambda", "")
    new $P1285, "ResizablePMCArray"
    push $P1285, $P1283
    push $P1285, "{"
    push $P1285, $P1284
    .return ($P1285)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "lambda"  :subid("71_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx1287_tgt
    .local int rx1287_pos
    .local int rx1287_off
    .local int rx1287_eos
    .local int rx1287_rep
    .local pmc rx1287_cur
    .local pmc rx1287_debug
    (rx1287_cur, rx1287_pos, rx1287_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1287_cur
    .local pmc match
    .lex "$/", match
    length rx1287_eos, rx1287_tgt
    gt rx1287_pos, rx1287_eos, rx1287_done
    set rx1287_off, 0
    lt rx1287_pos, 2, rx1287_start
    sub rx1287_off, rx1287_pos, 1
    substr rx1287_tgt, rx1287_tgt, rx1287_off
  rx1287_start:
    eq $I10, 1, rx1287_restart
    if_null rx1287_debug, debug_939
    rx1287_cur."!cursor_debug"("START", "lambda")
  debug_939:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1288_done
    goto rxscan1288_scan
  rxscan1288_loop:
    (rx1287_pos) = rx1287_cur."from"()
    inc rx1287_pos
    rx1287_cur."!cursor_from"(rx1287_pos)
    ge rx1287_pos, rx1287_eos, rxscan1288_done
  rxscan1288_scan:
    set_addr $I10, rxscan1288_loop
    rx1287_cur."!mark_push"(0, rx1287_pos, $I10)
  rxscan1288_done:
  alt1289_0:
.annotate 'line', 591
    set_addr $I10, alt1289_1
    rx1287_cur."!mark_push"(0, rx1287_pos, $I10)
  # rx literal  "->"
    add $I11, rx1287_pos, 2
    gt $I11, rx1287_eos, rx1287_fail
    sub $I11, rx1287_pos, rx1287_off
    substr $S10, rx1287_tgt, $I11, 2
    ne $S10, "->", rx1287_fail
    add rx1287_pos, 2
    goto alt1289_end
  alt1289_1:
  # rx literal  "<->"
    add $I11, rx1287_pos, 3
    gt $I11, rx1287_eos, rx1287_fail
    sub $I11, rx1287_pos, rx1287_off
    substr $S10, rx1287_tgt, $I11, 3
    ne $S10, "<->", rx1287_fail
    add rx1287_pos, 3
  alt1289_end:
  # rx pass
    rx1287_cur."!cursor_pass"(rx1287_pos, "lambda")
    if_null rx1287_debug, debug_940
    rx1287_cur."!cursor_debug"("PASS", "lambda", " at pos=", rx1287_pos)
  debug_940:
    .return (rx1287_cur)
  rx1287_restart:
.annotate 'line', 436
    if_null rx1287_debug, debug_941
    rx1287_cur."!cursor_debug"("NEXT", "lambda")
  debug_941:
  rx1287_fail:
    (rx1287_rep, rx1287_pos, $I10, $P10) = rx1287_cur."!mark_fail"(0)
    lt rx1287_pos, -1, rx1287_done
    eq rx1287_pos, -1, rx1287_fail
    jump $I10
  rx1287_done:
    rx1287_cur."!cursor_fail"()
    if_null rx1287_debug, debug_942
    rx1287_cur."!cursor_debug"("FAIL", "lambda")
  debug_942:
    .return (rx1287_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__lambda"  :subid("72_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    new $P1291, "ResizablePMCArray"
    push $P1291, "<->"
    push $P1291, "->"
    .return ($P1291)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "block"  :subid("73_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx1293_tgt
    .local int rx1293_pos
    .local int rx1293_off
    .local int rx1293_eos
    .local int rx1293_rep
    .local pmc rx1293_cur
    .local pmc rx1293_debug
    (rx1293_cur, rx1293_pos, rx1293_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1293_cur
    .local pmc match
    .lex "$/", match
    length rx1293_eos, rx1293_tgt
    gt rx1293_pos, rx1293_eos, rx1293_done
    set rx1293_off, 0
    lt rx1293_pos, 2, rx1293_start
    sub rx1293_off, rx1293_pos, 1
    substr rx1293_tgt, rx1293_tgt, rx1293_off
  rx1293_start:
    eq $I10, 1, rx1293_restart
    if_null rx1293_debug, debug_943
    rx1293_cur."!cursor_debug"("START", "block")
  debug_943:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1294_done
    goto rxscan1294_scan
  rxscan1294_loop:
    (rx1293_pos) = rx1293_cur."from"()
    inc rx1293_pos
    rx1293_cur."!cursor_from"(rx1293_pos)
    ge rx1293_pos, rx1293_eos, rxscan1294_done
  rxscan1294_scan:
    set_addr $I10, rxscan1294_loop
    rx1293_cur."!mark_push"(0, rx1293_pos, $I10)
  rxscan1294_done:
  alt1295_0:
.annotate 'line', 594
    set_addr $I10, alt1295_1
    rx1293_cur."!mark_push"(0, rx1293_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1293_pos, rx1293_off
    substr $S10, rx1293_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1293_fail
    goto alt1295_end
  alt1295_1:
  # rx subrule "panic" subtype=method negate=
    rx1293_cur."!cursor_pos"(rx1293_pos)
    $P10 = rx1293_cur."panic"("Missing block")
    unless $P10, rx1293_fail
    rx1293_pos = $P10."pos"()
  alt1295_end:
.annotate 'line', 595
  # rx subrule "newpad" subtype=method negate=
    rx1293_cur."!cursor_pos"(rx1293_pos)
    $P10 = rx1293_cur."newpad"()
    unless $P10, rx1293_fail
    rx1293_pos = $P10."pos"()
.annotate 'line', 596
  # rx subrule "blockoid" subtype=capture negate=
    rx1293_cur."!cursor_pos"(rx1293_pos)
    $P10 = rx1293_cur."blockoid"()
    unless $P10, rx1293_fail
    rx1293_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx1293_pos = $P10."pos"()
.annotate 'line', 593
  # rx pass
    rx1293_cur."!cursor_pass"(rx1293_pos, "block")
    if_null rx1293_debug, debug_944
    rx1293_cur."!cursor_debug"("PASS", "block", " at pos=", rx1293_pos)
  debug_944:
    .return (rx1293_cur)
  rx1293_restart:
.annotate 'line', 436
    if_null rx1293_debug, debug_945
    rx1293_cur."!cursor_debug"("NEXT", "block")
  debug_945:
  rx1293_fail:
    (rx1293_rep, rx1293_pos, $I10, $P10) = rx1293_cur."!mark_fail"(0)
    lt rx1293_pos, -1, rx1293_done
    eq rx1293_pos, -1, rx1293_fail
    jump $I10
  rx1293_done:
    rx1293_cur."!cursor_fail"()
    if_null rx1293_debug, debug_946
    rx1293_cur."!cursor_debug"("FAIL", "block")
  debug_946:
    .return (rx1293_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__block"  :subid("74_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P1297 = self."!PREFIX__!subrule"("panic", "")
    new $P1298, "ResizablePMCArray"
    push $P1298, $P1297
    push $P1298, "{"
    .return ($P1298)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blockoid"  :subid("75_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx1300_tgt
    .local int rx1300_pos
    .local int rx1300_off
    .local int rx1300_eos
    .local int rx1300_rep
    .local pmc rx1300_cur
    .local pmc rx1300_debug
    (rx1300_cur, rx1300_pos, rx1300_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1300_cur
    .local pmc match
    .lex "$/", match
    length rx1300_eos, rx1300_tgt
    gt rx1300_pos, rx1300_eos, rx1300_done
    set rx1300_off, 0
    lt rx1300_pos, 2, rx1300_start
    sub rx1300_off, rx1300_pos, 1
    substr rx1300_tgt, rx1300_tgt, rx1300_off
  rx1300_start:
    eq $I10, 1, rx1300_restart
    if_null rx1300_debug, debug_947
    rx1300_cur."!cursor_debug"("START", "blockoid")
  debug_947:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1301_done
    goto rxscan1301_scan
  rxscan1301_loop:
    (rx1300_pos) = rx1300_cur."from"()
    inc rx1300_pos
    rx1300_cur."!cursor_from"(rx1300_pos)
    ge rx1300_pos, rx1300_eos, rxscan1301_done
  rxscan1301_scan:
    set_addr $I10, rxscan1301_loop
    rx1300_cur."!mark_push"(0, rx1300_pos, $I10)
  rxscan1301_done:
.annotate 'line', 600
  # rx subrule "finishpad" subtype=method negate=
    rx1300_cur."!cursor_pos"(rx1300_pos)
    $P10 = rx1300_cur."finishpad"()
    unless $P10, rx1300_fail
    rx1300_pos = $P10."pos"()
  alt1302_0:
.annotate 'line', 601
    set_addr $I10, alt1302_1
    rx1300_cur."!mark_push"(0, rx1300_pos, $I10)
.annotate 'line', 602
  # rx literal  "{YOU_ARE_HERE}"
    add $I11, rx1300_pos, 14
    gt $I11, rx1300_eos, rx1300_fail
    sub $I11, rx1300_pos, rx1300_off
    substr $S10, rx1300_tgt, $I11, 14
    ne $S10, "{YOU_ARE_HERE}", rx1300_fail
    add rx1300_pos, 14
  # rx subrule "you_are_here" subtype=capture negate=
    rx1300_cur."!cursor_pos"(rx1300_pos)
    $P10 = rx1300_cur."you_are_here"()
    unless $P10, rx1300_fail
    rx1300_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("you_are_here")
    rx1300_pos = $P10."pos"()
    goto alt1302_end
  alt1302_1:
.annotate 'line', 603
  # rx literal  "{"
    add $I11, rx1300_pos, 1
    gt $I11, rx1300_eos, rx1300_fail
    sub $I11, rx1300_pos, rx1300_off
    ord $I11, rx1300_tgt, $I11
    ne $I11, 123, rx1300_fail
    add rx1300_pos, 1
  # rx subrule "statementlist" subtype=capture negate=
    rx1300_cur."!cursor_pos"(rx1300_pos)
    $P10 = rx1300_cur."statementlist"()
    unless $P10, rx1300_fail
    rx1300_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx1300_pos = $P10."pos"()
  alt1303_0:
    set_addr $I10, alt1303_1
    rx1300_cur."!mark_push"(0, rx1300_pos, $I10)
  # rx literal  "}"
    add $I11, rx1300_pos, 1
    gt $I11, rx1300_eos, rx1300_fail
    sub $I11, rx1300_pos, rx1300_off
    ord $I11, rx1300_tgt, $I11
    ne $I11, 125, rx1300_fail
    add rx1300_pos, 1
    goto alt1303_end
  alt1303_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx1300_cur."!cursor_pos"(rx1300_pos)
    $P10 = rx1300_cur."FAILGOAL"("'}'")
    unless $P10, rx1300_fail
    goto rxsubrule1305_pass
  rxsubrule1305_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1300_fail
  rxsubrule1305_pass:
    set_addr $I10, rxsubrule1305_back
    rx1300_cur."!mark_push"(0, rx1300_pos, $I10, $P10)
    rx1300_pos = $P10."pos"()
  alt1303_end:
  alt1302_end:
.annotate 'line', 605
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1300_cur."!cursor_pos"(rx1300_pos)
    $P10 = rx1300_cur."ENDSTMT"()
    unless $P10, rx1300_fail
.annotate 'line', 599
  # rx pass
    rx1300_cur."!cursor_pass"(rx1300_pos, "blockoid")
    if_null rx1300_debug, debug_948
    rx1300_cur."!cursor_debug"("PASS", "blockoid", " at pos=", rx1300_pos)
  debug_948:
    .return (rx1300_cur)
  rx1300_restart:
.annotate 'line', 436
    if_null rx1300_debug, debug_949
    rx1300_cur."!cursor_debug"("NEXT", "blockoid")
  debug_949:
  rx1300_fail:
    (rx1300_rep, rx1300_pos, $I10, $P10) = rx1300_cur."!mark_fail"(0)
    lt rx1300_pos, -1, rx1300_done
    eq rx1300_pos, -1, rx1300_fail
    jump $I10
  rx1300_done:
    rx1300_cur."!cursor_fail"()
    if_null rx1300_debug, debug_950
    rx1300_cur."!cursor_debug"("FAIL", "blockoid")
  debug_950:
    .return (rx1300_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blockoid"  :subid("76_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P1307 = self."!PREFIX__!subrule"("finishpad", "")
    new $P1308, "ResizablePMCArray"
    push $P1308, $P1307
    .return ($P1308)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "newpad"  :subid("77_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx1310_tgt
    .local int rx1310_pos
    .local int rx1310_off
    .local int rx1310_eos
    .local int rx1310_rep
    .local pmc rx1310_cur
    .local pmc rx1310_debug
    (rx1310_cur, rx1310_pos, rx1310_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1310_cur
    .local pmc match
    .lex "$/", match
    length rx1310_eos, rx1310_tgt
    gt rx1310_pos, rx1310_eos, rx1310_done
    set rx1310_off, 0
    lt rx1310_pos, 2, rx1310_start
    sub rx1310_off, rx1310_pos, 1
    substr rx1310_tgt, rx1310_tgt, rx1310_off
  rx1310_start:
    eq $I10, 1, rx1310_restart
    if_null rx1310_debug, debug_951
    rx1310_cur."!cursor_debug"("START", "newpad")
  debug_951:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1311_done
    goto rxscan1311_scan
  rxscan1311_loop:
    (rx1310_pos) = rx1310_cur."from"()
    inc rx1310_pos
    rx1310_cur."!cursor_from"(rx1310_pos)
    ge rx1310_pos, rx1310_eos, rxscan1311_done
  rxscan1311_scan:
    set_addr $I10, rxscan1311_loop
    rx1310_cur."!mark_push"(0, rx1310_pos, $I10)
  rxscan1311_done:
.annotate 'line', 608
  # rx pass
    rx1310_cur."!cursor_pass"(rx1310_pos, "newpad")
    if_null rx1310_debug, debug_952
    rx1310_cur."!cursor_debug"("PASS", "newpad", " at pos=", rx1310_pos)
  debug_952:
    .return (rx1310_cur)
  rx1310_restart:
.annotate 'line', 436
    if_null rx1310_debug, debug_953
    rx1310_cur."!cursor_debug"("NEXT", "newpad")
  debug_953:
  rx1310_fail:
    (rx1310_rep, rx1310_pos, $I10, $P10) = rx1310_cur."!mark_fail"(0)
    lt rx1310_pos, -1, rx1310_done
    eq rx1310_pos, -1, rx1310_fail
    jump $I10
  rx1310_done:
    rx1310_cur."!cursor_fail"()
    if_null rx1310_debug, debug_954
    rx1310_cur."!cursor_debug"("FAIL", "newpad")
  debug_954:
    .return (rx1310_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__newpad"  :subid("78_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    new $P1313, "ResizablePMCArray"
    push $P1313, ""
    .return ($P1313)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "outerctx"  :subid("79_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx1315_tgt
    .local int rx1315_pos
    .local int rx1315_off
    .local int rx1315_eos
    .local int rx1315_rep
    .local pmc rx1315_cur
    .local pmc rx1315_debug
    (rx1315_cur, rx1315_pos, rx1315_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1315_cur
    .local pmc match
    .lex "$/", match
    length rx1315_eos, rx1315_tgt
    gt rx1315_pos, rx1315_eos, rx1315_done
    set rx1315_off, 0
    lt rx1315_pos, 2, rx1315_start
    sub rx1315_off, rx1315_pos, 1
    substr rx1315_tgt, rx1315_tgt, rx1315_off
  rx1315_start:
    eq $I10, 1, rx1315_restart
    if_null rx1315_debug, debug_955
    rx1315_cur."!cursor_debug"("START", "outerctx")
  debug_955:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1316_done
    goto rxscan1316_scan
  rxscan1316_loop:
    (rx1315_pos) = rx1315_cur."from"()
    inc rx1315_pos
    rx1315_cur."!cursor_from"(rx1315_pos)
    ge rx1315_pos, rx1315_eos, rxscan1316_done
  rxscan1316_scan:
    set_addr $I10, rxscan1316_loop
    rx1315_cur."!mark_push"(0, rx1315_pos, $I10)
  rxscan1316_done:
.annotate 'line', 609
  # rx pass
    rx1315_cur."!cursor_pass"(rx1315_pos, "outerctx")
    if_null rx1315_debug, debug_956
    rx1315_cur."!cursor_debug"("PASS", "outerctx", " at pos=", rx1315_pos)
  debug_956:
    .return (rx1315_cur)
  rx1315_restart:
.annotate 'line', 436
    if_null rx1315_debug, debug_957
    rx1315_cur."!cursor_debug"("NEXT", "outerctx")
  debug_957:
  rx1315_fail:
    (rx1315_rep, rx1315_pos, $I10, $P10) = rx1315_cur."!mark_fail"(0)
    lt rx1315_pos, -1, rx1315_done
    eq rx1315_pos, -1, rx1315_fail
    jump $I10
  rx1315_done:
    rx1315_cur."!cursor_fail"()
    if_null rx1315_debug, debug_958
    rx1315_cur."!cursor_debug"("FAIL", "outerctx")
  debug_958:
    .return (rx1315_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__outerctx"  :subid("80_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    new $P1318, "ResizablePMCArray"
    push $P1318, ""
    .return ($P1318)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "GLOBALish"  :subid("81_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx1320_tgt
    .local int rx1320_pos
    .local int rx1320_off
    .local int rx1320_eos
    .local int rx1320_rep
    .local pmc rx1320_cur
    .local pmc rx1320_debug
    (rx1320_cur, rx1320_pos, rx1320_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1320_cur
    .local pmc match
    .lex "$/", match
    length rx1320_eos, rx1320_tgt
    gt rx1320_pos, rx1320_eos, rx1320_done
    set rx1320_off, 0
    lt rx1320_pos, 2, rx1320_start
    sub rx1320_off, rx1320_pos, 1
    substr rx1320_tgt, rx1320_tgt, rx1320_off
  rx1320_start:
    eq $I10, 1, rx1320_restart
    if_null rx1320_debug, debug_959
    rx1320_cur."!cursor_debug"("START", "GLOBALish")
  debug_959:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1321_done
    goto rxscan1321_scan
  rxscan1321_loop:
    (rx1320_pos) = rx1320_cur."from"()
    inc rx1320_pos
    rx1320_cur."!cursor_from"(rx1320_pos)
    ge rx1320_pos, rx1320_eos, rxscan1321_done
  rxscan1321_scan:
    set_addr $I10, rxscan1321_loop
    rx1320_cur."!mark_push"(0, rx1320_pos, $I10)
  rxscan1321_done:
.annotate 'line', 610
  # rx pass
    rx1320_cur."!cursor_pass"(rx1320_pos, "GLOBALish")
    if_null rx1320_debug, debug_960
    rx1320_cur."!cursor_debug"("PASS", "GLOBALish", " at pos=", rx1320_pos)
  debug_960:
    .return (rx1320_cur)
  rx1320_restart:
.annotate 'line', 436
    if_null rx1320_debug, debug_961
    rx1320_cur."!cursor_debug"("NEXT", "GLOBALish")
  debug_961:
  rx1320_fail:
    (rx1320_rep, rx1320_pos, $I10, $P10) = rx1320_cur."!mark_fail"(0)
    lt rx1320_pos, -1, rx1320_done
    eq rx1320_pos, -1, rx1320_fail
    jump $I10
  rx1320_done:
    rx1320_cur."!cursor_fail"()
    if_null rx1320_debug, debug_962
    rx1320_cur."!cursor_debug"("FAIL", "GLOBALish")
  debug_962:
    .return (rx1320_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__GLOBALish"  :subid("82_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    new $P1323, "ResizablePMCArray"
    push $P1323, ""
    .return ($P1323)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "finishpad"  :subid("83_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx1325_tgt
    .local int rx1325_pos
    .local int rx1325_off
    .local int rx1325_eos
    .local int rx1325_rep
    .local pmc rx1325_cur
    .local pmc rx1325_debug
    (rx1325_cur, rx1325_pos, rx1325_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1325_cur
    .local pmc match
    .lex "$/", match
    length rx1325_eos, rx1325_tgt
    gt rx1325_pos, rx1325_eos, rx1325_done
    set rx1325_off, 0
    lt rx1325_pos, 2, rx1325_start
    sub rx1325_off, rx1325_pos, 1
    substr rx1325_tgt, rx1325_tgt, rx1325_off
  rx1325_start:
    eq $I10, 1, rx1325_restart
    if_null rx1325_debug, debug_963
    rx1325_cur."!cursor_debug"("START", "finishpad")
  debug_963:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1326_done
    goto rxscan1326_scan
  rxscan1326_loop:
    (rx1325_pos) = rx1325_cur."from"()
    inc rx1325_pos
    rx1325_cur."!cursor_from"(rx1325_pos)
    ge rx1325_pos, rx1325_eos, rxscan1326_done
  rxscan1326_scan:
    set_addr $I10, rxscan1326_loop
    rx1325_cur."!mark_push"(0, rx1325_pos, $I10)
  rxscan1326_done:
.annotate 'line', 611
  # rx pass
    rx1325_cur."!cursor_pass"(rx1325_pos, "finishpad")
    if_null rx1325_debug, debug_964
    rx1325_cur."!cursor_debug"("PASS", "finishpad", " at pos=", rx1325_pos)
  debug_964:
    .return (rx1325_cur)
  rx1325_restart:
.annotate 'line', 436
    if_null rx1325_debug, debug_965
    rx1325_cur."!cursor_debug"("NEXT", "finishpad")
  debug_965:
  rx1325_fail:
    (rx1325_rep, rx1325_pos, $I10, $P10) = rx1325_cur."!mark_fail"(0)
    lt rx1325_pos, -1, rx1325_done
    eq rx1325_pos, -1, rx1325_fail
    jump $I10
  rx1325_done:
    rx1325_cur."!cursor_fail"()
    if_null rx1325_debug, debug_966
    rx1325_cur."!cursor_debug"("FAIL", "finishpad")
  debug_966:
    .return (rx1325_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__finishpad"  :subid("84_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    new $P1328, "ResizablePMCArray"
    push $P1328, ""
    .return ($P1328)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "you_are_here"  :subid("85_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx1330_tgt
    .local int rx1330_pos
    .local int rx1330_off
    .local int rx1330_eos
    .local int rx1330_rep
    .local pmc rx1330_cur
    .local pmc rx1330_debug
    (rx1330_cur, rx1330_pos, rx1330_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1330_cur
    .local pmc match
    .lex "$/", match
    length rx1330_eos, rx1330_tgt
    gt rx1330_pos, rx1330_eos, rx1330_done
    set rx1330_off, 0
    lt rx1330_pos, 2, rx1330_start
    sub rx1330_off, rx1330_pos, 1
    substr rx1330_tgt, rx1330_tgt, rx1330_off
  rx1330_start:
    eq $I10, 1, rx1330_restart
    if_null rx1330_debug, debug_967
    rx1330_cur."!cursor_debug"("START", "you_are_here")
  debug_967:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1331_done
    goto rxscan1331_scan
  rxscan1331_loop:
    (rx1330_pos) = rx1330_cur."from"()
    inc rx1330_pos
    rx1330_cur."!cursor_from"(rx1330_pos)
    ge rx1330_pos, rx1330_eos, rxscan1331_done
  rxscan1331_scan:
    set_addr $I10, rxscan1331_loop
    rx1330_cur."!mark_push"(0, rx1330_pos, $I10)
  rxscan1331_done:
.annotate 'line', 612
  # rx pass
    rx1330_cur."!cursor_pass"(rx1330_pos, "you_are_here")
    if_null rx1330_debug, debug_968
    rx1330_cur."!cursor_debug"("PASS", "you_are_here", " at pos=", rx1330_pos)
  debug_968:
    .return (rx1330_cur)
  rx1330_restart:
.annotate 'line', 436
    if_null rx1330_debug, debug_969
    rx1330_cur."!cursor_debug"("NEXT", "you_are_here")
  debug_969:
  rx1330_fail:
    (rx1330_rep, rx1330_pos, $I10, $P10) = rx1330_cur."!mark_fail"(0)
    lt rx1330_pos, -1, rx1330_done
    eq rx1330_pos, -1, rx1330_fail
    jump $I10
  rx1330_done:
    rx1330_cur."!cursor_fail"()
    if_null rx1330_debug, debug_970
    rx1330_cur."!cursor_debug"("FAIL", "you_are_here")
  debug_970:
    .return (rx1330_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__you_are_here"  :subid("86_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    new $P1333, "ResizablePMCArray"
    push $P1333, ""
    .return ($P1333)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator"  :subid("87_1307873304.82979")
    .param pmc param_1335
.annotate 'line', 614
    .lex "self", param_1335
    $P1336 = param_1335."!protoregex"("terminator")
    .return ($P1336)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator"  :subid("88_1307873304.82979")
    .param pmc param_1338
.annotate 'line', 614
    .lex "self", param_1338
    $P1339 = param_1338."!PREFIX__!protoregex"("terminator")
    .return ($P1339)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<;>"  :subid("89_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx1341_tgt
    .local int rx1341_pos
    .local int rx1341_off
    .local int rx1341_eos
    .local int rx1341_rep
    .local pmc rx1341_cur
    .local pmc rx1341_debug
    (rx1341_cur, rx1341_pos, rx1341_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1341_cur
    .local pmc match
    .lex "$/", match
    length rx1341_eos, rx1341_tgt
    gt rx1341_pos, rx1341_eos, rx1341_done
    set rx1341_off, 0
    lt rx1341_pos, 2, rx1341_start
    sub rx1341_off, rx1341_pos, 1
    substr rx1341_tgt, rx1341_tgt, rx1341_off
  rx1341_start:
    eq $I10, 1, rx1341_restart
    if_null rx1341_debug, debug_971
    rx1341_cur."!cursor_debug"("START", "terminator:sym<;>")
  debug_971:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1342_done
    goto rxscan1342_scan
  rxscan1342_loop:
    (rx1341_pos) = rx1341_cur."from"()
    inc rx1341_pos
    rx1341_cur."!cursor_from"(rx1341_pos)
    ge rx1341_pos, rx1341_eos, rxscan1342_done
  rxscan1342_scan:
    set_addr $I10, rxscan1342_loop
    rx1341_cur."!mark_push"(0, rx1341_pos, $I10)
  rxscan1342_done:
.annotate 'line', 616
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1341_pos, rx1341_off
    substr $S10, rx1341_tgt, $I10, 1
    index $I11, ";", $S10
    lt $I11, 0, rx1341_fail
  # rx pass
    rx1341_cur."!cursor_pass"(rx1341_pos, "terminator:sym<;>")
    if_null rx1341_debug, debug_972
    rx1341_cur."!cursor_debug"("PASS", "terminator:sym<;>", " at pos=", rx1341_pos)
  debug_972:
    .return (rx1341_cur)
  rx1341_restart:
.annotate 'line', 436
    if_null rx1341_debug, debug_973
    rx1341_cur."!cursor_debug"("NEXT", "terminator:sym<;>")
  debug_973:
  rx1341_fail:
    (rx1341_rep, rx1341_pos, $I10, $P10) = rx1341_cur."!mark_fail"(0)
    lt rx1341_pos, -1, rx1341_done
    eq rx1341_pos, -1, rx1341_fail
    jump $I10
  rx1341_done:
    rx1341_cur."!cursor_fail"()
    if_null rx1341_debug, debug_974
    rx1341_cur."!cursor_debug"("FAIL", "terminator:sym<;>")
  debug_974:
    .return (rx1341_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<;>"  :subid("90_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    new $P1344, "ResizablePMCArray"
    push $P1344, ";"
    .return ($P1344)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<}>"  :subid("91_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx1346_tgt
    .local int rx1346_pos
    .local int rx1346_off
    .local int rx1346_eos
    .local int rx1346_rep
    .local pmc rx1346_cur
    .local pmc rx1346_debug
    (rx1346_cur, rx1346_pos, rx1346_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1346_cur
    .local pmc match
    .lex "$/", match
    length rx1346_eos, rx1346_tgt
    gt rx1346_pos, rx1346_eos, rx1346_done
    set rx1346_off, 0
    lt rx1346_pos, 2, rx1346_start
    sub rx1346_off, rx1346_pos, 1
    substr rx1346_tgt, rx1346_tgt, rx1346_off
  rx1346_start:
    eq $I10, 1, rx1346_restart
    if_null rx1346_debug, debug_975
    rx1346_cur."!cursor_debug"("START", "terminator:sym<}>")
  debug_975:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1347_done
    goto rxscan1347_scan
  rxscan1347_loop:
    (rx1346_pos) = rx1346_cur."from"()
    inc rx1346_pos
    rx1346_cur."!cursor_from"(rx1346_pos)
    ge rx1346_pos, rx1346_eos, rxscan1347_done
  rxscan1347_scan:
    set_addr $I10, rxscan1347_loop
    rx1346_cur."!mark_push"(0, rx1346_pos, $I10)
  rxscan1347_done:
.annotate 'line', 617
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1346_pos, rx1346_off
    substr $S10, rx1346_tgt, $I10, 1
    index $I11, "}", $S10
    lt $I11, 0, rx1346_fail
  # rx pass
    rx1346_cur."!cursor_pass"(rx1346_pos, "terminator:sym<}>")
    if_null rx1346_debug, debug_976
    rx1346_cur."!cursor_debug"("PASS", "terminator:sym<}>", " at pos=", rx1346_pos)
  debug_976:
    .return (rx1346_cur)
  rx1346_restart:
.annotate 'line', 436
    if_null rx1346_debug, debug_977
    rx1346_cur."!cursor_debug"("NEXT", "terminator:sym<}>")
  debug_977:
  rx1346_fail:
    (rx1346_rep, rx1346_pos, $I10, $P10) = rx1346_cur."!mark_fail"(0)
    lt rx1346_pos, -1, rx1346_done
    eq rx1346_pos, -1, rx1346_fail
    jump $I10
  rx1346_done:
    rx1346_cur."!cursor_fail"()
    if_null rx1346_debug, debug_978
    rx1346_cur."!cursor_debug"("FAIL", "terminator:sym<}>")
  debug_978:
    .return (rx1346_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<}>"  :subid("92_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    new $P1349, "ResizablePMCArray"
    push $P1349, "}"
    .return ($P1349)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control"  :subid("93_1307873304.82979")
    .param pmc param_1351
.annotate 'line', 621
    .lex "self", param_1351
    $P1352 = param_1351."!protoregex"("statement_control")
    .return ($P1352)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control"  :subid("94_1307873304.82979")
    .param pmc param_1354
.annotate 'line', 621
    .lex "self", param_1354
    $P1355 = param_1354."!PREFIX__!protoregex"("statement_control")
    .return ($P1355)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<use>"  :subid("95_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx1357_tgt
    .local int rx1357_pos
    .local int rx1357_off
    .local int rx1357_eos
    .local int rx1357_rep
    .local pmc rx1357_cur
    .local pmc rx1357_debug
    (rx1357_cur, rx1357_pos, rx1357_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1357_cur
    .local pmc match
    .lex "$/", match
    length rx1357_eos, rx1357_tgt
    gt rx1357_pos, rx1357_eos, rx1357_done
    set rx1357_off, 0
    lt rx1357_pos, 2, rx1357_start
    sub rx1357_off, rx1357_pos, 1
    substr rx1357_tgt, rx1357_tgt, rx1357_off
  rx1357_start:
    eq $I10, 1, rx1357_restart
    if_null rx1357_debug, debug_979
    rx1357_cur."!cursor_debug"("START", "statement_control:sym<use>")
  debug_979:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1358_done
    goto rxscan1358_scan
  rxscan1358_loop:
    (rx1357_pos) = rx1357_cur."from"()
    inc rx1357_pos
    rx1357_cur."!cursor_from"(rx1357_pos)
    ge rx1357_pos, rx1357_eos, rxscan1358_done
  rxscan1358_scan:
    set_addr $I10, rxscan1358_loop
    rx1357_cur."!mark_push"(0, rx1357_pos, $I10)
  rxscan1358_done:
.annotate 'line', 624
  # rx subcapture "sym"
    set_addr $I10, rxcap_1359_fail
    rx1357_cur."!mark_push"(0, rx1357_pos, $I10)
  # rx literal  "use"
    add $I11, rx1357_pos, 3
    gt $I11, rx1357_eos, rx1357_fail
    sub $I11, rx1357_pos, rx1357_off
    substr $S10, rx1357_tgt, $I11, 3
    ne $S10, "use", rx1357_fail
    add rx1357_pos, 3
    set_addr $I10, rxcap_1359_fail
    ($I12, $I11) = rx1357_cur."!mark_peek"($I10)
    rx1357_cur."!cursor_pos"($I11)
    ($P10) = rx1357_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1357_pos, "")
    rx1357_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1359_done
  rxcap_1359_fail:
    goto rx1357_fail
  rxcap_1359_done:
  # rx charclass s
    ge rx1357_pos, rx1357_eos, rx1357_fail
    sub $I10, rx1357_pos, rx1357_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1357_tgt, $I10
    unless $I11, rx1357_fail
    inc rx1357_pos
  # rx subrule "ws" subtype=method negate=
    rx1357_cur."!cursor_pos"(rx1357_pos)
    $P10 = rx1357_cur."ws"()
    unless $P10, rx1357_fail
    rx1357_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx1357_cur."!cursor_pos"(rx1357_pos)
    $P10 = rx1357_cur."name"()
    unless $P10, rx1357_fail
    rx1357_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1357_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1357_cur."!cursor_pos"(rx1357_pos)
    $P10 = rx1357_cur."ws"()
    unless $P10, rx1357_fail
    rx1357_pos = $P10."pos"()
.annotate 'line', 623
  # rx pass
    rx1357_cur."!cursor_pass"(rx1357_pos, "statement_control:sym<use>")
    if_null rx1357_debug, debug_980
    rx1357_cur."!cursor_debug"("PASS", "statement_control:sym<use>", " at pos=", rx1357_pos)
  debug_980:
    .return (rx1357_cur)
  rx1357_restart:
.annotate 'line', 436
    if_null rx1357_debug, debug_981
    rx1357_cur."!cursor_debug"("NEXT", "statement_control:sym<use>")
  debug_981:
  rx1357_fail:
    (rx1357_rep, rx1357_pos, $I10, $P10) = rx1357_cur."!mark_fail"(0)
    lt rx1357_pos, -1, rx1357_done
    eq rx1357_pos, -1, rx1357_fail
    jump $I10
  rx1357_done:
    rx1357_cur."!cursor_fail"()
    if_null rx1357_debug, debug_982
    rx1357_cur."!cursor_debug"("FAIL", "statement_control:sym<use>")
  debug_982:
    .return (rx1357_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<use>"  :subid("96_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    new $P1363, "ResizablePMCArray"
    push $P1363, "use"
    .return ($P1363)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<if>"  :subid("97_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx1365_tgt
    .local int rx1365_pos
    .local int rx1365_off
    .local int rx1365_eos
    .local int rx1365_rep
    .local pmc rx1365_cur
    .local pmc rx1365_debug
    (rx1365_cur, rx1365_pos, rx1365_tgt, $I10) = self."!cursor_start"()
    rx1365_cur."!cursor_caparray"("xblock", "else")
    .lex unicode:"$\x{a2}", rx1365_cur
    .local pmc match
    .lex "$/", match
    length rx1365_eos, rx1365_tgt
    gt rx1365_pos, rx1365_eos, rx1365_done
    set rx1365_off, 0
    lt rx1365_pos, 2, rx1365_start
    sub rx1365_off, rx1365_pos, 1
    substr rx1365_tgt, rx1365_tgt, rx1365_off
  rx1365_start:
    eq $I10, 1, rx1365_restart
    if_null rx1365_debug, debug_983
    rx1365_cur."!cursor_debug"("START", "statement_control:sym<if>")
  debug_983:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1366_done
    goto rxscan1366_scan
  rxscan1366_loop:
    (rx1365_pos) = rx1365_cur."from"()
    inc rx1365_pos
    rx1365_cur."!cursor_from"(rx1365_pos)
    ge rx1365_pos, rx1365_eos, rxscan1366_done
  rxscan1366_scan:
    set_addr $I10, rxscan1366_loop
    rx1365_cur."!mark_push"(0, rx1365_pos, $I10)
  rxscan1366_done:
.annotate 'line', 628
  # rx subcapture "sym"
    set_addr $I10, rxcap_1367_fail
    rx1365_cur."!mark_push"(0, rx1365_pos, $I10)
  # rx literal  "if"
    add $I11, rx1365_pos, 2
    gt $I11, rx1365_eos, rx1365_fail
    sub $I11, rx1365_pos, rx1365_off
    substr $S10, rx1365_tgt, $I11, 2
    ne $S10, "if", rx1365_fail
    add rx1365_pos, 2
    set_addr $I10, rxcap_1367_fail
    ($I12, $I11) = rx1365_cur."!mark_peek"($I10)
    rx1365_cur."!cursor_pos"($I11)
    ($P10) = rx1365_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1365_pos, "")
    rx1365_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1367_done
  rxcap_1367_fail:
    goto rx1365_fail
  rxcap_1367_done:
  # rx charclass s
    ge rx1365_pos, rx1365_eos, rx1365_fail
    sub $I10, rx1365_pos, rx1365_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1365_tgt, $I10
    unless $I11, rx1365_fail
    inc rx1365_pos
  # rx subrule "ws" subtype=method negate=
    rx1365_cur."!cursor_pos"(rx1365_pos)
    $P10 = rx1365_cur."ws"()
    unless $P10, rx1365_fail
    rx1365_pos = $P10."pos"()
.annotate 'line', 629
  # rx subrule "xblock" subtype=capture negate=
    rx1365_cur."!cursor_pos"(rx1365_pos)
    $P10 = rx1365_cur."xblock"()
    unless $P10, rx1365_fail
    rx1365_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx1365_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1365_cur."!cursor_pos"(rx1365_pos)
    $P10 = rx1365_cur."ws"()
    unless $P10, rx1365_fail
    rx1365_pos = $P10."pos"()
.annotate 'line', 630
  # rx rxquantr1370 ** 0..*
    set_addr $I10, rxquantr1370_done
    rx1365_cur."!mark_push"(0, rx1365_pos, $I10)
  rxquantr1370_loop:
  # rx subrule "ws" subtype=method negate=
    rx1365_cur."!cursor_pos"(rx1365_pos)
    $P10 = rx1365_cur."ws"()
    unless $P10, rx1365_fail
    rx1365_pos = $P10."pos"()
  # rx literal  "elsif"
    add $I11, rx1365_pos, 5
    gt $I11, rx1365_eos, rx1365_fail
    sub $I11, rx1365_pos, rx1365_off
    substr $S10, rx1365_tgt, $I11, 5
    ne $S10, "elsif", rx1365_fail
    add rx1365_pos, 5
  # rx charclass s
    ge rx1365_pos, rx1365_eos, rx1365_fail
    sub $I10, rx1365_pos, rx1365_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1365_tgt, $I10
    unless $I11, rx1365_fail
    inc rx1365_pos
  # rx subrule "ws" subtype=method negate=
    rx1365_cur."!cursor_pos"(rx1365_pos)
    $P10 = rx1365_cur."ws"()
    unless $P10, rx1365_fail
    rx1365_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx1365_cur."!cursor_pos"(rx1365_pos)
    $P10 = rx1365_cur."xblock"()
    unless $P10, rx1365_fail
    rx1365_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx1365_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1365_cur."!cursor_pos"(rx1365_pos)
    $P10 = rx1365_cur."ws"()
    unless $P10, rx1365_fail
    rx1365_pos = $P10."pos"()
    set_addr $I10, rxquantr1370_done
    (rx1365_rep) = rx1365_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1370_done
    rx1365_cur."!mark_push"(rx1365_rep, rx1365_pos, $I10)
    goto rxquantr1370_loop
  rxquantr1370_done:
  # rx subrule "ws" subtype=method negate=
    rx1365_cur."!cursor_pos"(rx1365_pos)
    $P10 = rx1365_cur."ws"()
    unless $P10, rx1365_fail
    rx1365_pos = $P10."pos"()
.annotate 'line', 631
  # rx rxquantr1375 ** 0..1
    set_addr $I10, rxquantr1375_done
    rx1365_cur."!mark_push"(0, rx1365_pos, $I10)
  rxquantr1375_loop:
  # rx subrule "ws" subtype=method negate=
    rx1365_cur."!cursor_pos"(rx1365_pos)
    $P10 = rx1365_cur."ws"()
    unless $P10, rx1365_fail
    rx1365_pos = $P10."pos"()
  # rx literal  "else"
    add $I11, rx1365_pos, 4
    gt $I11, rx1365_eos, rx1365_fail
    sub $I11, rx1365_pos, rx1365_off
    substr $S10, rx1365_tgt, $I11, 4
    ne $S10, "else", rx1365_fail
    add rx1365_pos, 4
  # rx charclass s
    ge rx1365_pos, rx1365_eos, rx1365_fail
    sub $I10, rx1365_pos, rx1365_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1365_tgt, $I10
    unless $I11, rx1365_fail
    inc rx1365_pos
  # rx subrule "ws" subtype=method negate=
    rx1365_cur."!cursor_pos"(rx1365_pos)
    $P10 = rx1365_cur."ws"()
    unless $P10, rx1365_fail
    rx1365_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx1365_cur."!cursor_pos"(rx1365_pos)
    $P10 = rx1365_cur."pblock"()
    unless $P10, rx1365_fail
    rx1365_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("else")
    rx1365_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1365_cur."!cursor_pos"(rx1365_pos)
    $P10 = rx1365_cur."ws"()
    unless $P10, rx1365_fail
    rx1365_pos = $P10."pos"()
    set_addr $I10, rxquantr1375_done
    (rx1365_rep) = rx1365_cur."!mark_commit"($I10)
  rxquantr1375_done:
  # rx subrule "ws" subtype=method negate=
    rx1365_cur."!cursor_pos"(rx1365_pos)
    $P10 = rx1365_cur."ws"()
    unless $P10, rx1365_fail
    rx1365_pos = $P10."pos"()
.annotate 'line', 627
  # rx pass
    rx1365_cur."!cursor_pass"(rx1365_pos, "statement_control:sym<if>")
    if_null rx1365_debug, debug_984
    rx1365_cur."!cursor_debug"("PASS", "statement_control:sym<if>", " at pos=", rx1365_pos)
  debug_984:
    .return (rx1365_cur)
  rx1365_restart:
.annotate 'line', 436
    if_null rx1365_debug, debug_985
    rx1365_cur."!cursor_debug"("NEXT", "statement_control:sym<if>")
  debug_985:
  rx1365_fail:
    (rx1365_rep, rx1365_pos, $I10, $P10) = rx1365_cur."!mark_fail"(0)
    lt rx1365_pos, -1, rx1365_done
    eq rx1365_pos, -1, rx1365_fail
    jump $I10
  rx1365_done:
    rx1365_cur."!cursor_fail"()
    if_null rx1365_debug, debug_986
    rx1365_cur."!cursor_debug"("FAIL", "statement_control:sym<if>")
  debug_986:
    .return (rx1365_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<if>"  :subid("98_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    new $P1381, "ResizablePMCArray"
    push $P1381, "if"
    .return ($P1381)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<unless>"  :subid("99_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .const 'Sub' $P1391 = "100_1307873304.82979" 
    capture_lex $P1391
    .local string rx1383_tgt
    .local int rx1383_pos
    .local int rx1383_off
    .local int rx1383_eos
    .local int rx1383_rep
    .local pmc rx1383_cur
    .local pmc rx1383_debug
    (rx1383_cur, rx1383_pos, rx1383_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1383_cur
    .local pmc match
    .lex "$/", match
    length rx1383_eos, rx1383_tgt
    gt rx1383_pos, rx1383_eos, rx1383_done
    set rx1383_off, 0
    lt rx1383_pos, 2, rx1383_start
    sub rx1383_off, rx1383_pos, 1
    substr rx1383_tgt, rx1383_tgt, rx1383_off
  rx1383_start:
    eq $I10, 1, rx1383_restart
    if_null rx1383_debug, debug_987
    rx1383_cur."!cursor_debug"("START", "statement_control:sym<unless>")
  debug_987:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1384_done
    goto rxscan1384_scan
  rxscan1384_loop:
    (rx1383_pos) = rx1383_cur."from"()
    inc rx1383_pos
    rx1383_cur."!cursor_from"(rx1383_pos)
    ge rx1383_pos, rx1383_eos, rxscan1384_done
  rxscan1384_scan:
    set_addr $I10, rxscan1384_loop
    rx1383_cur."!mark_push"(0, rx1383_pos, $I10)
  rxscan1384_done:
.annotate 'line', 635
  # rx subcapture "sym"
    set_addr $I10, rxcap_1385_fail
    rx1383_cur."!mark_push"(0, rx1383_pos, $I10)
  # rx literal  "unless"
    add $I11, rx1383_pos, 6
    gt $I11, rx1383_eos, rx1383_fail
    sub $I11, rx1383_pos, rx1383_off
    substr $S10, rx1383_tgt, $I11, 6
    ne $S10, "unless", rx1383_fail
    add rx1383_pos, 6
    set_addr $I10, rxcap_1385_fail
    ($I12, $I11) = rx1383_cur."!mark_peek"($I10)
    rx1383_cur."!cursor_pos"($I11)
    ($P10) = rx1383_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1383_pos, "")
    rx1383_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1385_done
  rxcap_1385_fail:
    goto rx1383_fail
  rxcap_1385_done:
  # rx charclass s
    ge rx1383_pos, rx1383_eos, rx1383_fail
    sub $I10, rx1383_pos, rx1383_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1383_tgt, $I10
    unless $I11, rx1383_fail
    inc rx1383_pos
  # rx subrule "ws" subtype=method negate=
    rx1383_cur."!cursor_pos"(rx1383_pos)
    $P10 = rx1383_cur."ws"()
    unless $P10, rx1383_fail
    rx1383_pos = $P10."pos"()
.annotate 'line', 636
  # rx subrule "xblock" subtype=capture negate=
    rx1383_cur."!cursor_pos"(rx1383_pos)
    $P10 = rx1383_cur."xblock"()
    unless $P10, rx1383_fail
    rx1383_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx1383_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1383_cur."!cursor_pos"(rx1383_pos)
    $P10 = rx1383_cur."ws"()
    unless $P10, rx1383_fail
    rx1383_pos = $P10."pos"()
  alt1388_0:
.annotate 'line', 637
    set_addr $I10, alt1388_1
    rx1383_cur."!mark_push"(0, rx1383_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx1383_cur."!cursor_pos"(rx1383_pos)
    $P10 = rx1383_cur."ws"()
    unless $P10, rx1383_fail
    rx1383_pos = $P10."pos"()
  # rx subrule "before" subtype=zerowidth negate=1
    rx1383_cur."!cursor_pos"(rx1383_pos)
    .const 'Sub' $P1391 = "100_1307873304.82979" 
    capture_lex $P1391
    $P10 = rx1383_cur."before"($P1391)
    if $P10, rx1383_fail
  # rx subrule "ws" subtype=method negate=
    rx1383_cur."!cursor_pos"(rx1383_pos)
    $P10 = rx1383_cur."ws"()
    unless $P10, rx1383_fail
    rx1383_pos = $P10."pos"()
    goto alt1388_end
  alt1388_1:
  # rx subrule "ws" subtype=method negate=
    rx1383_cur."!cursor_pos"(rx1383_pos)
    $P10 = rx1383_cur."ws"()
    unless $P10, rx1383_fail
    rx1383_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1383_cur."!cursor_pos"(rx1383_pos)
    $P10 = rx1383_cur."panic"("unless does not take \"else\", please rewrite using \"if\"")
    unless $P10, rx1383_fail
    rx1383_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1383_cur."!cursor_pos"(rx1383_pos)
    $P10 = rx1383_cur."ws"()
    unless $P10, rx1383_fail
    rx1383_pos = $P10."pos"()
  alt1388_end:
  # rx subrule "ws" subtype=method negate=
    rx1383_cur."!cursor_pos"(rx1383_pos)
    $P10 = rx1383_cur."ws"()
    unless $P10, rx1383_fail
    rx1383_pos = $P10."pos"()
.annotate 'line', 634
  # rx pass
    rx1383_cur."!cursor_pass"(rx1383_pos, "statement_control:sym<unless>")
    if_null rx1383_debug, debug_992
    rx1383_cur."!cursor_debug"("PASS", "statement_control:sym<unless>", " at pos=", rx1383_pos)
  debug_992:
    .return (rx1383_cur)
  rx1383_restart:
.annotate 'line', 436
    if_null rx1383_debug, debug_993
    rx1383_cur."!cursor_debug"("NEXT", "statement_control:sym<unless>")
  debug_993:
  rx1383_fail:
    (rx1383_rep, rx1383_pos, $I10, $P10) = rx1383_cur."!mark_fail"(0)
    lt rx1383_pos, -1, rx1383_done
    eq rx1383_pos, -1, rx1383_fail
    jump $I10
  rx1383_done:
    rx1383_cur."!cursor_fail"()
    if_null rx1383_debug, debug_994
    rx1383_cur."!cursor_debug"("FAIL", "statement_control:sym<unless>")
  debug_994:
    .return (rx1383_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1390"  :anon :subid("100_1307873304.82979") :method :outer("99_1307873304.82979")
.annotate 'line', 637
    .local string rx1392_tgt
    .local int rx1392_pos
    .local int rx1392_off
    .local int rx1392_eos
    .local int rx1392_rep
    .local pmc rx1392_cur
    .local pmc rx1392_debug
    (rx1392_cur, rx1392_pos, rx1392_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1392_cur
    .local pmc match
    .lex "$/", match
    length rx1392_eos, rx1392_tgt
    gt rx1392_pos, rx1392_eos, rx1392_done
    set rx1392_off, 0
    lt rx1392_pos, 2, rx1392_start
    sub rx1392_off, rx1392_pos, 1
    substr rx1392_tgt, rx1392_tgt, rx1392_off
  rx1392_start:
    eq $I10, 1, rx1392_restart
    if_null rx1392_debug, debug_988
    rx1392_cur."!cursor_debug"("START", "")
  debug_988:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1393_done
    goto rxscan1393_scan
  rxscan1393_loop:
    (rx1392_pos) = rx1392_cur."from"()
    inc rx1392_pos
    rx1392_cur."!cursor_from"(rx1392_pos)
    ge rx1392_pos, rx1392_eos, rxscan1393_done
  rxscan1393_scan:
    set_addr $I10, rxscan1393_loop
    rx1392_cur."!mark_push"(0, rx1392_pos, $I10)
  rxscan1393_done:
  # rx literal  "else"
    add $I11, rx1392_pos, 4
    gt $I11, rx1392_eos, rx1392_fail
    sub $I11, rx1392_pos, rx1392_off
    substr $S10, rx1392_tgt, $I11, 4
    ne $S10, "else", rx1392_fail
    add rx1392_pos, 4
  # rx pass
    rx1392_cur."!cursor_pass"(rx1392_pos, "")
    if_null rx1392_debug, debug_989
    rx1392_cur."!cursor_debug"("PASS", "", " at pos=", rx1392_pos)
  debug_989:
    .return (rx1392_cur)
  rx1392_restart:
    if_null rx1392_debug, debug_990
    rx1392_cur."!cursor_debug"("NEXT", "")
  debug_990:
  rx1392_fail:
    (rx1392_rep, rx1392_pos, $I10, $P10) = rx1392_cur."!mark_fail"(0)
    lt rx1392_pos, -1, rx1392_done
    eq rx1392_pos, -1, rx1392_fail
    jump $I10
  rx1392_done:
    rx1392_cur."!cursor_fail"()
    if_null rx1392_debug, debug_991
    rx1392_cur."!cursor_debug"("FAIL", "")
  debug_991:
    .return (rx1392_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<unless>"  :subid("101_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    new $P1399, "ResizablePMCArray"
    push $P1399, "unless"
    .return ($P1399)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<while>"  :subid("102_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx1401_tgt
    .local int rx1401_pos
    .local int rx1401_off
    .local int rx1401_eos
    .local int rx1401_rep
    .local pmc rx1401_cur
    .local pmc rx1401_debug
    (rx1401_cur, rx1401_pos, rx1401_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1401_cur
    .local pmc match
    .lex "$/", match
    length rx1401_eos, rx1401_tgt
    gt rx1401_pos, rx1401_eos, rx1401_done
    set rx1401_off, 0
    lt rx1401_pos, 2, rx1401_start
    sub rx1401_off, rx1401_pos, 1
    substr rx1401_tgt, rx1401_tgt, rx1401_off
  rx1401_start:
    eq $I10, 1, rx1401_restart
    if_null rx1401_debug, debug_995
    rx1401_cur."!cursor_debug"("START", "statement_control:sym<while>")
  debug_995:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1402_done
    goto rxscan1402_scan
  rxscan1402_loop:
    (rx1401_pos) = rx1401_cur."from"()
    inc rx1401_pos
    rx1401_cur."!cursor_from"(rx1401_pos)
    ge rx1401_pos, rx1401_eos, rxscan1402_done
  rxscan1402_scan:
    set_addr $I10, rxscan1402_loop
    rx1401_cur."!mark_push"(0, rx1401_pos, $I10)
  rxscan1402_done:
.annotate 'line', 641
  # rx subcapture "sym"
    set_addr $I10, rxcap_1404_fail
    rx1401_cur."!mark_push"(0, rx1401_pos, $I10)
  alt1403_0:
    set_addr $I10, alt1403_1
    rx1401_cur."!mark_push"(0, rx1401_pos, $I10)
  # rx literal  "while"
    add $I11, rx1401_pos, 5
    gt $I11, rx1401_eos, rx1401_fail
    sub $I11, rx1401_pos, rx1401_off
    substr $S10, rx1401_tgt, $I11, 5
    ne $S10, "while", rx1401_fail
    add rx1401_pos, 5
    goto alt1403_end
  alt1403_1:
  # rx literal  "until"
    add $I11, rx1401_pos, 5
    gt $I11, rx1401_eos, rx1401_fail
    sub $I11, rx1401_pos, rx1401_off
    substr $S10, rx1401_tgt, $I11, 5
    ne $S10, "until", rx1401_fail
    add rx1401_pos, 5
  alt1403_end:
    set_addr $I10, rxcap_1404_fail
    ($I12, $I11) = rx1401_cur."!mark_peek"($I10)
    rx1401_cur."!cursor_pos"($I11)
    ($P10) = rx1401_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1401_pos, "")
    rx1401_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1404_done
  rxcap_1404_fail:
    goto rx1401_fail
  rxcap_1404_done:
  # rx charclass s
    ge rx1401_pos, rx1401_eos, rx1401_fail
    sub $I10, rx1401_pos, rx1401_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1401_tgt, $I10
    unless $I11, rx1401_fail
    inc rx1401_pos
  # rx subrule "ws" subtype=method negate=
    rx1401_cur."!cursor_pos"(rx1401_pos)
    $P10 = rx1401_cur."ws"()
    unless $P10, rx1401_fail
    rx1401_pos = $P10."pos"()
.annotate 'line', 642
  # rx subrule "xblock" subtype=capture negate=
    rx1401_cur."!cursor_pos"(rx1401_pos)
    $P10 = rx1401_cur."xblock"()
    unless $P10, rx1401_fail
    rx1401_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx1401_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1401_cur."!cursor_pos"(rx1401_pos)
    $P10 = rx1401_cur."ws"()
    unless $P10, rx1401_fail
    rx1401_pos = $P10."pos"()
.annotate 'line', 640
  # rx pass
    rx1401_cur."!cursor_pass"(rx1401_pos, "statement_control:sym<while>")
    if_null rx1401_debug, debug_996
    rx1401_cur."!cursor_debug"("PASS", "statement_control:sym<while>", " at pos=", rx1401_pos)
  debug_996:
    .return (rx1401_cur)
  rx1401_restart:
.annotate 'line', 436
    if_null rx1401_debug, debug_997
    rx1401_cur."!cursor_debug"("NEXT", "statement_control:sym<while>")
  debug_997:
  rx1401_fail:
    (rx1401_rep, rx1401_pos, $I10, $P10) = rx1401_cur."!mark_fail"(0)
    lt rx1401_pos, -1, rx1401_done
    eq rx1401_pos, -1, rx1401_fail
    jump $I10
  rx1401_done:
    rx1401_cur."!cursor_fail"()
    if_null rx1401_debug, debug_998
    rx1401_cur."!cursor_debug"("FAIL", "statement_control:sym<while>")
  debug_998:
    .return (rx1401_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<while>"  :subid("103_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    new $P1408, "ResizablePMCArray"
    push $P1408, "until"
    push $P1408, "while"
    .return ($P1408)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<repeat>"  :subid("104_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx1410_tgt
    .local int rx1410_pos
    .local int rx1410_off
    .local int rx1410_eos
    .local int rx1410_rep
    .local pmc rx1410_cur
    .local pmc rx1410_debug
    (rx1410_cur, rx1410_pos, rx1410_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1410_cur
    .local pmc match
    .lex "$/", match
    length rx1410_eos, rx1410_tgt
    gt rx1410_pos, rx1410_eos, rx1410_done
    set rx1410_off, 0
    lt rx1410_pos, 2, rx1410_start
    sub rx1410_off, rx1410_pos, 1
    substr rx1410_tgt, rx1410_tgt, rx1410_off
  rx1410_start:
    eq $I10, 1, rx1410_restart
    if_null rx1410_debug, debug_999
    rx1410_cur."!cursor_debug"("START", "statement_control:sym<repeat>")
  debug_999:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1411_done
    goto rxscan1411_scan
  rxscan1411_loop:
    (rx1410_pos) = rx1410_cur."from"()
    inc rx1410_pos
    rx1410_cur."!cursor_from"(rx1410_pos)
    ge rx1410_pos, rx1410_eos, rxscan1411_done
  rxscan1411_scan:
    set_addr $I10, rxscan1411_loop
    rx1410_cur."!mark_push"(0, rx1410_pos, $I10)
  rxscan1411_done:
.annotate 'line', 646
  # rx subcapture "sym"
    set_addr $I10, rxcap_1412_fail
    rx1410_cur."!mark_push"(0, rx1410_pos, $I10)
  # rx literal  "repeat"
    add $I11, rx1410_pos, 6
    gt $I11, rx1410_eos, rx1410_fail
    sub $I11, rx1410_pos, rx1410_off
    substr $S10, rx1410_tgt, $I11, 6
    ne $S10, "repeat", rx1410_fail
    add rx1410_pos, 6
    set_addr $I10, rxcap_1412_fail
    ($I12, $I11) = rx1410_cur."!mark_peek"($I10)
    rx1410_cur."!cursor_pos"($I11)
    ($P10) = rx1410_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1410_pos, "")
    rx1410_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1412_done
  rxcap_1412_fail:
    goto rx1410_fail
  rxcap_1412_done:
  # rx charclass s
    ge rx1410_pos, rx1410_eos, rx1410_fail
    sub $I10, rx1410_pos, rx1410_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1410_tgt, $I10
    unless $I11, rx1410_fail
    inc rx1410_pos
  # rx subrule "ws" subtype=method negate=
    rx1410_cur."!cursor_pos"(rx1410_pos)
    $P10 = rx1410_cur."ws"()
    unless $P10, rx1410_fail
    rx1410_pos = $P10."pos"()
  alt1414_0:
.annotate 'line', 647
    set_addr $I10, alt1414_1
    rx1410_cur."!mark_push"(0, rx1410_pos, $I10)
.annotate 'line', 648
  # rx subrule "ws" subtype=method negate=
    rx1410_cur."!cursor_pos"(rx1410_pos)
    $P10 = rx1410_cur."ws"()
    unless $P10, rx1410_fail
    rx1410_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_1417_fail
    rx1410_cur."!mark_push"(0, rx1410_pos, $I10)
  alt1416_0:
    set_addr $I10, alt1416_1
    rx1410_cur."!mark_push"(0, rx1410_pos, $I10)
  # rx literal  "while"
    add $I11, rx1410_pos, 5
    gt $I11, rx1410_eos, rx1410_fail
    sub $I11, rx1410_pos, rx1410_off
    substr $S10, rx1410_tgt, $I11, 5
    ne $S10, "while", rx1410_fail
    add rx1410_pos, 5
    goto alt1416_end
  alt1416_1:
  # rx literal  "until"
    add $I11, rx1410_pos, 5
    gt $I11, rx1410_eos, rx1410_fail
    sub $I11, rx1410_pos, rx1410_off
    substr $S10, rx1410_tgt, $I11, 5
    ne $S10, "until", rx1410_fail
    add rx1410_pos, 5
  alt1416_end:
    set_addr $I10, rxcap_1417_fail
    ($I12, $I11) = rx1410_cur."!mark_peek"($I10)
    rx1410_cur."!cursor_pos"($I11)
    ($P10) = rx1410_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1410_pos, "")
    rx1410_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_1417_done
  rxcap_1417_fail:
    goto rx1410_fail
  rxcap_1417_done:
  # rx charclass s
    ge rx1410_pos, rx1410_eos, rx1410_fail
    sub $I10, rx1410_pos, rx1410_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1410_tgt, $I10
    unless $I11, rx1410_fail
    inc rx1410_pos
  # rx subrule "ws" subtype=method negate=
    rx1410_cur."!cursor_pos"(rx1410_pos)
    $P10 = rx1410_cur."ws"()
    unless $P10, rx1410_fail
    rx1410_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx1410_cur."!cursor_pos"(rx1410_pos)
    $P10 = rx1410_cur."xblock"()
    unless $P10, rx1410_fail
    rx1410_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx1410_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1410_cur."!cursor_pos"(rx1410_pos)
    $P10 = rx1410_cur."ws"()
    unless $P10, rx1410_fail
    rx1410_pos = $P10."pos"()
    goto alt1414_end
  alt1414_1:
.annotate 'line', 649
  # rx subrule "ws" subtype=method negate=
    rx1410_cur."!cursor_pos"(rx1410_pos)
    $P10 = rx1410_cur."ws"()
    unless $P10, rx1410_fail
    rx1410_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx1410_cur."!cursor_pos"(rx1410_pos)
    $P10 = rx1410_cur."pblock"()
    unless $P10, rx1410_fail
    rx1410_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx1410_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1410_cur."!cursor_pos"(rx1410_pos)
    $P10 = rx1410_cur."ws"()
    unless $P10, rx1410_fail
    rx1410_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_1423_fail
    rx1410_cur."!mark_push"(0, rx1410_pos, $I10)
  alt1422_0:
    set_addr $I10, alt1422_1
    rx1410_cur."!mark_push"(0, rx1410_pos, $I10)
  # rx literal  "while"
    add $I11, rx1410_pos, 5
    gt $I11, rx1410_eos, rx1410_fail
    sub $I11, rx1410_pos, rx1410_off
    substr $S10, rx1410_tgt, $I11, 5
    ne $S10, "while", rx1410_fail
    add rx1410_pos, 5
    goto alt1422_end
  alt1422_1:
  # rx literal  "until"
    add $I11, rx1410_pos, 5
    gt $I11, rx1410_eos, rx1410_fail
    sub $I11, rx1410_pos, rx1410_off
    substr $S10, rx1410_tgt, $I11, 5
    ne $S10, "until", rx1410_fail
    add rx1410_pos, 5
  alt1422_end:
    set_addr $I10, rxcap_1423_fail
    ($I12, $I11) = rx1410_cur."!mark_peek"($I10)
    rx1410_cur."!cursor_pos"($I11)
    ($P10) = rx1410_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1410_pos, "")
    rx1410_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_1423_done
  rxcap_1423_fail:
    goto rx1410_fail
  rxcap_1423_done:
  # rx charclass s
    ge rx1410_pos, rx1410_eos, rx1410_fail
    sub $I10, rx1410_pos, rx1410_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1410_tgt, $I10
    unless $I11, rx1410_fail
    inc rx1410_pos
  # rx subrule "ws" subtype=method negate=
    rx1410_cur."!cursor_pos"(rx1410_pos)
    $P10 = rx1410_cur."ws"()
    unless $P10, rx1410_fail
    rx1410_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1410_cur."!cursor_pos"(rx1410_pos)
    $P10 = rx1410_cur."EXPR"()
    unless $P10, rx1410_fail
    rx1410_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1410_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1410_cur."!cursor_pos"(rx1410_pos)
    $P10 = rx1410_cur."ws"()
    unless $P10, rx1410_fail
    rx1410_pos = $P10."pos"()
  alt1414_end:
.annotate 'line', 650
  # rx subrule "ws" subtype=method negate=
    rx1410_cur."!cursor_pos"(rx1410_pos)
    $P10 = rx1410_cur."ws"()
    unless $P10, rx1410_fail
    rx1410_pos = $P10."pos"()
.annotate 'line', 645
  # rx pass
    rx1410_cur."!cursor_pass"(rx1410_pos, "statement_control:sym<repeat>")
    if_null rx1410_debug, debug_1000
    rx1410_cur."!cursor_debug"("PASS", "statement_control:sym<repeat>", " at pos=", rx1410_pos)
  debug_1000:
    .return (rx1410_cur)
  rx1410_restart:
.annotate 'line', 436
    if_null rx1410_debug, debug_1001
    rx1410_cur."!cursor_debug"("NEXT", "statement_control:sym<repeat>")
  debug_1001:
  rx1410_fail:
    (rx1410_rep, rx1410_pos, $I10, $P10) = rx1410_cur."!mark_fail"(0)
    lt rx1410_pos, -1, rx1410_done
    eq rx1410_pos, -1, rx1410_fail
    jump $I10
  rx1410_done:
    rx1410_cur."!cursor_fail"()
    if_null rx1410_debug, debug_1002
    rx1410_cur."!cursor_debug"("FAIL", "statement_control:sym<repeat>")
  debug_1002:
    .return (rx1410_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<repeat>"  :subid("105_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    new $P1428, "ResizablePMCArray"
    push $P1428, "repeat"
    .return ($P1428)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<for>"  :subid("106_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx1430_tgt
    .local int rx1430_pos
    .local int rx1430_off
    .local int rx1430_eos
    .local int rx1430_rep
    .local pmc rx1430_cur
    .local pmc rx1430_debug
    (rx1430_cur, rx1430_pos, rx1430_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1430_cur
    .local pmc match
    .lex "$/", match
    length rx1430_eos, rx1430_tgt
    gt rx1430_pos, rx1430_eos, rx1430_done
    set rx1430_off, 0
    lt rx1430_pos, 2, rx1430_start
    sub rx1430_off, rx1430_pos, 1
    substr rx1430_tgt, rx1430_tgt, rx1430_off
  rx1430_start:
    eq $I10, 1, rx1430_restart
    if_null rx1430_debug, debug_1003
    rx1430_cur."!cursor_debug"("START", "statement_control:sym<for>")
  debug_1003:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1431_done
    goto rxscan1431_scan
  rxscan1431_loop:
    (rx1430_pos) = rx1430_cur."from"()
    inc rx1430_pos
    rx1430_cur."!cursor_from"(rx1430_pos)
    ge rx1430_pos, rx1430_eos, rxscan1431_done
  rxscan1431_scan:
    set_addr $I10, rxscan1431_loop
    rx1430_cur."!mark_push"(0, rx1430_pos, $I10)
  rxscan1431_done:
.annotate 'line', 654
  # rx subcapture "sym"
    set_addr $I10, rxcap_1432_fail
    rx1430_cur."!mark_push"(0, rx1430_pos, $I10)
  # rx literal  "for"
    add $I11, rx1430_pos, 3
    gt $I11, rx1430_eos, rx1430_fail
    sub $I11, rx1430_pos, rx1430_off
    substr $S10, rx1430_tgt, $I11, 3
    ne $S10, "for", rx1430_fail
    add rx1430_pos, 3
    set_addr $I10, rxcap_1432_fail
    ($I12, $I11) = rx1430_cur."!mark_peek"($I10)
    rx1430_cur."!cursor_pos"($I11)
    ($P10) = rx1430_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1430_pos, "")
    rx1430_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1432_done
  rxcap_1432_fail:
    goto rx1430_fail
  rxcap_1432_done:
  # rx charclass s
    ge rx1430_pos, rx1430_eos, rx1430_fail
    sub $I10, rx1430_pos, rx1430_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1430_tgt, $I10
    unless $I11, rx1430_fail
    inc rx1430_pos
  # rx subrule "ws" subtype=method negate=
    rx1430_cur."!cursor_pos"(rx1430_pos)
    $P10 = rx1430_cur."ws"()
    unless $P10, rx1430_fail
    rx1430_pos = $P10."pos"()
.annotate 'line', 655
  # rx subrule "xblock" subtype=capture negate=
    rx1430_cur."!cursor_pos"(rx1430_pos)
    $P10 = rx1430_cur."xblock"()
    unless $P10, rx1430_fail
    rx1430_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx1430_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1430_cur."!cursor_pos"(rx1430_pos)
    $P10 = rx1430_cur."ws"()
    unless $P10, rx1430_fail
    rx1430_pos = $P10."pos"()
.annotate 'line', 653
  # rx pass
    rx1430_cur."!cursor_pass"(rx1430_pos, "statement_control:sym<for>")
    if_null rx1430_debug, debug_1004
    rx1430_cur."!cursor_debug"("PASS", "statement_control:sym<for>", " at pos=", rx1430_pos)
  debug_1004:
    .return (rx1430_cur)
  rx1430_restart:
.annotate 'line', 436
    if_null rx1430_debug, debug_1005
    rx1430_cur."!cursor_debug"("NEXT", "statement_control:sym<for>")
  debug_1005:
  rx1430_fail:
    (rx1430_rep, rx1430_pos, $I10, $P10) = rx1430_cur."!mark_fail"(0)
    lt rx1430_pos, -1, rx1430_done
    eq rx1430_pos, -1, rx1430_fail
    jump $I10
  rx1430_done:
    rx1430_cur."!cursor_fail"()
    if_null rx1430_debug, debug_1006
    rx1430_cur."!cursor_debug"("FAIL", "statement_control:sym<for>")
  debug_1006:
    .return (rx1430_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<for>"  :subid("107_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    new $P1436, "ResizablePMCArray"
    push $P1436, "for"
    .return ($P1436)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CATCH>"  :subid("108_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx1438_tgt
    .local int rx1438_pos
    .local int rx1438_off
    .local int rx1438_eos
    .local int rx1438_rep
    .local pmc rx1438_cur
    .local pmc rx1438_debug
    (rx1438_cur, rx1438_pos, rx1438_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1438_cur
    .local pmc match
    .lex "$/", match
    length rx1438_eos, rx1438_tgt
    gt rx1438_pos, rx1438_eos, rx1438_done
    set rx1438_off, 0
    lt rx1438_pos, 2, rx1438_start
    sub rx1438_off, rx1438_pos, 1
    substr rx1438_tgt, rx1438_tgt, rx1438_off
  rx1438_start:
    eq $I10, 1, rx1438_restart
    if_null rx1438_debug, debug_1007
    rx1438_cur."!cursor_debug"("START", "statement_control:sym<CATCH>")
  debug_1007:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1439_done
    goto rxscan1439_scan
  rxscan1439_loop:
    (rx1438_pos) = rx1438_cur."from"()
    inc rx1438_pos
    rx1438_cur."!cursor_from"(rx1438_pos)
    ge rx1438_pos, rx1438_eos, rxscan1439_done
  rxscan1439_scan:
    set_addr $I10, rxscan1439_loop
    rx1438_cur."!mark_push"(0, rx1438_pos, $I10)
  rxscan1439_done:
.annotate 'line', 659
  # rx subcapture "sym"
    set_addr $I10, rxcap_1440_fail
    rx1438_cur."!mark_push"(0, rx1438_pos, $I10)
  # rx literal  "CATCH"
    add $I11, rx1438_pos, 5
    gt $I11, rx1438_eos, rx1438_fail
    sub $I11, rx1438_pos, rx1438_off
    substr $S10, rx1438_tgt, $I11, 5
    ne $S10, "CATCH", rx1438_fail
    add rx1438_pos, 5
    set_addr $I10, rxcap_1440_fail
    ($I12, $I11) = rx1438_cur."!mark_peek"($I10)
    rx1438_cur."!cursor_pos"($I11)
    ($P10) = rx1438_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1438_pos, "")
    rx1438_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1440_done
  rxcap_1440_fail:
    goto rx1438_fail
  rxcap_1440_done:
  # rx charclass s
    ge rx1438_pos, rx1438_eos, rx1438_fail
    sub $I10, rx1438_pos, rx1438_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1438_tgt, $I10
    unless $I11, rx1438_fail
    inc rx1438_pos
  # rx subrule "ws" subtype=method negate=
    rx1438_cur."!cursor_pos"(rx1438_pos)
    $P10 = rx1438_cur."ws"()
    unless $P10, rx1438_fail
    rx1438_pos = $P10."pos"()
.annotate 'line', 660
  # rx subrule "block" subtype=capture negate=
    rx1438_cur."!cursor_pos"(rx1438_pos)
    $P10 = rx1438_cur."block"()
    unless $P10, rx1438_fail
    rx1438_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1438_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1438_cur."!cursor_pos"(rx1438_pos)
    $P10 = rx1438_cur."ws"()
    unless $P10, rx1438_fail
    rx1438_pos = $P10."pos"()
.annotate 'line', 658
  # rx pass
    rx1438_cur."!cursor_pass"(rx1438_pos, "statement_control:sym<CATCH>")
    if_null rx1438_debug, debug_1008
    rx1438_cur."!cursor_debug"("PASS", "statement_control:sym<CATCH>", " at pos=", rx1438_pos)
  debug_1008:
    .return (rx1438_cur)
  rx1438_restart:
.annotate 'line', 436
    if_null rx1438_debug, debug_1009
    rx1438_cur."!cursor_debug"("NEXT", "statement_control:sym<CATCH>")
  debug_1009:
  rx1438_fail:
    (rx1438_rep, rx1438_pos, $I10, $P10) = rx1438_cur."!mark_fail"(0)
    lt rx1438_pos, -1, rx1438_done
    eq rx1438_pos, -1, rx1438_fail
    jump $I10
  rx1438_done:
    rx1438_cur."!cursor_fail"()
    if_null rx1438_debug, debug_1010
    rx1438_cur."!cursor_debug"("FAIL", "statement_control:sym<CATCH>")
  debug_1010:
    .return (rx1438_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CATCH>"  :subid("109_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    new $P1444, "ResizablePMCArray"
    push $P1444, "CATCH"
    .return ($P1444)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CONTROL>"  :subid("110_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx1446_tgt
    .local int rx1446_pos
    .local int rx1446_off
    .local int rx1446_eos
    .local int rx1446_rep
    .local pmc rx1446_cur
    .local pmc rx1446_debug
    (rx1446_cur, rx1446_pos, rx1446_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1446_cur
    .local pmc match
    .lex "$/", match
    length rx1446_eos, rx1446_tgt
    gt rx1446_pos, rx1446_eos, rx1446_done
    set rx1446_off, 0
    lt rx1446_pos, 2, rx1446_start
    sub rx1446_off, rx1446_pos, 1
    substr rx1446_tgt, rx1446_tgt, rx1446_off
  rx1446_start:
    eq $I10, 1, rx1446_restart
    if_null rx1446_debug, debug_1011
    rx1446_cur."!cursor_debug"("START", "statement_control:sym<CONTROL>")
  debug_1011:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1447_done
    goto rxscan1447_scan
  rxscan1447_loop:
    (rx1446_pos) = rx1446_cur."from"()
    inc rx1446_pos
    rx1446_cur."!cursor_from"(rx1446_pos)
    ge rx1446_pos, rx1446_eos, rxscan1447_done
  rxscan1447_scan:
    set_addr $I10, rxscan1447_loop
    rx1446_cur."!mark_push"(0, rx1446_pos, $I10)
  rxscan1447_done:
.annotate 'line', 664
  # rx subcapture "sym"
    set_addr $I10, rxcap_1448_fail
    rx1446_cur."!mark_push"(0, rx1446_pos, $I10)
  # rx literal  "CONTROL"
    add $I11, rx1446_pos, 7
    gt $I11, rx1446_eos, rx1446_fail
    sub $I11, rx1446_pos, rx1446_off
    substr $S10, rx1446_tgt, $I11, 7
    ne $S10, "CONTROL", rx1446_fail
    add rx1446_pos, 7
    set_addr $I10, rxcap_1448_fail
    ($I12, $I11) = rx1446_cur."!mark_peek"($I10)
    rx1446_cur."!cursor_pos"($I11)
    ($P10) = rx1446_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1446_pos, "")
    rx1446_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1448_done
  rxcap_1448_fail:
    goto rx1446_fail
  rxcap_1448_done:
  # rx charclass s
    ge rx1446_pos, rx1446_eos, rx1446_fail
    sub $I10, rx1446_pos, rx1446_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1446_tgt, $I10
    unless $I11, rx1446_fail
    inc rx1446_pos
  # rx subrule "ws" subtype=method negate=
    rx1446_cur."!cursor_pos"(rx1446_pos)
    $P10 = rx1446_cur."ws"()
    unless $P10, rx1446_fail
    rx1446_pos = $P10."pos"()
.annotate 'line', 665
  # rx subrule "block" subtype=capture negate=
    rx1446_cur."!cursor_pos"(rx1446_pos)
    $P10 = rx1446_cur."block"()
    unless $P10, rx1446_fail
    rx1446_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1446_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1446_cur."!cursor_pos"(rx1446_pos)
    $P10 = rx1446_cur."ws"()
    unless $P10, rx1446_fail
    rx1446_pos = $P10."pos"()
.annotate 'line', 663
  # rx pass
    rx1446_cur."!cursor_pass"(rx1446_pos, "statement_control:sym<CONTROL>")
    if_null rx1446_debug, debug_1012
    rx1446_cur."!cursor_debug"("PASS", "statement_control:sym<CONTROL>", " at pos=", rx1446_pos)
  debug_1012:
    .return (rx1446_cur)
  rx1446_restart:
.annotate 'line', 436
    if_null rx1446_debug, debug_1013
    rx1446_cur."!cursor_debug"("NEXT", "statement_control:sym<CONTROL>")
  debug_1013:
  rx1446_fail:
    (rx1446_rep, rx1446_pos, $I10, $P10) = rx1446_cur."!mark_fail"(0)
    lt rx1446_pos, -1, rx1446_done
    eq rx1446_pos, -1, rx1446_fail
    jump $I10
  rx1446_done:
    rx1446_cur."!cursor_fail"()
    if_null rx1446_debug, debug_1014
    rx1446_cur."!cursor_debug"("FAIL", "statement_control:sym<CONTROL>")
  debug_1014:
    .return (rx1446_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CONTROL>"  :subid("111_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    new $P1452, "ResizablePMCArray"
    push $P1452, "CONTROL"
    .return ($P1452)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix"  :subid("112_1307873304.82979")
    .param pmc param_1454
.annotate 'line', 668
    .lex "self", param_1454
    $P1455 = param_1454."!protoregex"("statement_prefix")
    .return ($P1455)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix"  :subid("113_1307873304.82979")
    .param pmc param_1457
.annotate 'line', 668
    .lex "self", param_1457
    $P1458 = param_1457."!PREFIX__!protoregex"("statement_prefix")
    .return ($P1458)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<INIT>"  :subid("114_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx1460_tgt
    .local int rx1460_pos
    .local int rx1460_off
    .local int rx1460_eos
    .local int rx1460_rep
    .local pmc rx1460_cur
    .local pmc rx1460_debug
    (rx1460_cur, rx1460_pos, rx1460_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1460_cur
    .local pmc match
    .lex "$/", match
    length rx1460_eos, rx1460_tgt
    gt rx1460_pos, rx1460_eos, rx1460_done
    set rx1460_off, 0
    lt rx1460_pos, 2, rx1460_start
    sub rx1460_off, rx1460_pos, 1
    substr rx1460_tgt, rx1460_tgt, rx1460_off
  rx1460_start:
    eq $I10, 1, rx1460_restart
    if_null rx1460_debug, debug_1015
    rx1460_cur."!cursor_debug"("START", "statement_prefix:sym<INIT>")
  debug_1015:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1461_done
    goto rxscan1461_scan
  rxscan1461_loop:
    (rx1460_pos) = rx1460_cur."from"()
    inc rx1460_pos
    rx1460_cur."!cursor_from"(rx1460_pos)
    ge rx1460_pos, rx1460_eos, rxscan1461_done
  rxscan1461_scan:
    set_addr $I10, rxscan1461_loop
    rx1460_cur."!mark_push"(0, rx1460_pos, $I10)
  rxscan1461_done:
.annotate 'line', 669
  # rx subcapture "sym"
    set_addr $I10, rxcap_1462_fail
    rx1460_cur."!mark_push"(0, rx1460_pos, $I10)
  # rx literal  "INIT"
    add $I11, rx1460_pos, 4
    gt $I11, rx1460_eos, rx1460_fail
    sub $I11, rx1460_pos, rx1460_off
    substr $S10, rx1460_tgt, $I11, 4
    ne $S10, "INIT", rx1460_fail
    add rx1460_pos, 4
    set_addr $I10, rxcap_1462_fail
    ($I12, $I11) = rx1460_cur."!mark_peek"($I10)
    rx1460_cur."!cursor_pos"($I11)
    ($P10) = rx1460_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1460_pos, "")
    rx1460_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1462_done
  rxcap_1462_fail:
    goto rx1460_fail
  rxcap_1462_done:
  # rx subrule "blorst" subtype=capture negate=
    rx1460_cur."!cursor_pos"(rx1460_pos)
    $P10 = rx1460_cur."blorst"()
    unless $P10, rx1460_fail
    rx1460_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx1460_pos = $P10."pos"()
  # rx pass
    rx1460_cur."!cursor_pass"(rx1460_pos, "statement_prefix:sym<INIT>")
    if_null rx1460_debug, debug_1016
    rx1460_cur."!cursor_debug"("PASS", "statement_prefix:sym<INIT>", " at pos=", rx1460_pos)
  debug_1016:
    .return (rx1460_cur)
  rx1460_restart:
.annotate 'line', 436
    if_null rx1460_debug, debug_1017
    rx1460_cur."!cursor_debug"("NEXT", "statement_prefix:sym<INIT>")
  debug_1017:
  rx1460_fail:
    (rx1460_rep, rx1460_pos, $I10, $P10) = rx1460_cur."!mark_fail"(0)
    lt rx1460_pos, -1, rx1460_done
    eq rx1460_pos, -1, rx1460_fail
    jump $I10
  rx1460_done:
    rx1460_cur."!cursor_fail"()
    if_null rx1460_debug, debug_1018
    rx1460_cur."!cursor_debug"("FAIL", "statement_prefix:sym<INIT>")
  debug_1018:
    .return (rx1460_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<INIT>"  :subid("115_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P1464 = self."!PREFIX__!subrule"("blorst", "INIT")
    new $P1465, "ResizablePMCArray"
    push $P1465, $P1464
    .return ($P1465)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<try>"  :subid("116_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx1467_tgt
    .local int rx1467_pos
    .local int rx1467_off
    .local int rx1467_eos
    .local int rx1467_rep
    .local pmc rx1467_cur
    .local pmc rx1467_debug
    (rx1467_cur, rx1467_pos, rx1467_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1467_cur
    .local pmc match
    .lex "$/", match
    length rx1467_eos, rx1467_tgt
    gt rx1467_pos, rx1467_eos, rx1467_done
    set rx1467_off, 0
    lt rx1467_pos, 2, rx1467_start
    sub rx1467_off, rx1467_pos, 1
    substr rx1467_tgt, rx1467_tgt, rx1467_off
  rx1467_start:
    eq $I10, 1, rx1467_restart
    if_null rx1467_debug, debug_1019
    rx1467_cur."!cursor_debug"("START", "statement_prefix:sym<try>")
  debug_1019:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1468_done
    goto rxscan1468_scan
  rxscan1468_loop:
    (rx1467_pos) = rx1467_cur."from"()
    inc rx1467_pos
    rx1467_cur."!cursor_from"(rx1467_pos)
    ge rx1467_pos, rx1467_eos, rxscan1468_done
  rxscan1468_scan:
    set_addr $I10, rxscan1468_loop
    rx1467_cur."!mark_push"(0, rx1467_pos, $I10)
  rxscan1468_done:
.annotate 'line', 672
  # rx subcapture "sym"
    set_addr $I10, rxcap_1469_fail
    rx1467_cur."!mark_push"(0, rx1467_pos, $I10)
  # rx literal  "try"
    add $I11, rx1467_pos, 3
    gt $I11, rx1467_eos, rx1467_fail
    sub $I11, rx1467_pos, rx1467_off
    substr $S10, rx1467_tgt, $I11, 3
    ne $S10, "try", rx1467_fail
    add rx1467_pos, 3
    set_addr $I10, rxcap_1469_fail
    ($I12, $I11) = rx1467_cur."!mark_peek"($I10)
    rx1467_cur."!cursor_pos"($I11)
    ($P10) = rx1467_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1467_pos, "")
    rx1467_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1469_done
  rxcap_1469_fail:
    goto rx1467_fail
  rxcap_1469_done:
.annotate 'line', 673
  # rx subrule "blorst" subtype=capture negate=
    rx1467_cur."!cursor_pos"(rx1467_pos)
    $P10 = rx1467_cur."blorst"()
    unless $P10, rx1467_fail
    rx1467_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx1467_pos = $P10."pos"()
.annotate 'line', 671
  # rx pass
    rx1467_cur."!cursor_pass"(rx1467_pos, "statement_prefix:sym<try>")
    if_null rx1467_debug, debug_1020
    rx1467_cur."!cursor_debug"("PASS", "statement_prefix:sym<try>", " at pos=", rx1467_pos)
  debug_1020:
    .return (rx1467_cur)
  rx1467_restart:
.annotate 'line', 436
    if_null rx1467_debug, debug_1021
    rx1467_cur."!cursor_debug"("NEXT", "statement_prefix:sym<try>")
  debug_1021:
  rx1467_fail:
    (rx1467_rep, rx1467_pos, $I10, $P10) = rx1467_cur."!mark_fail"(0)
    lt rx1467_pos, -1, rx1467_done
    eq rx1467_pos, -1, rx1467_fail
    jump $I10
  rx1467_done:
    rx1467_cur."!cursor_fail"()
    if_null rx1467_debug, debug_1022
    rx1467_cur."!cursor_debug"("FAIL", "statement_prefix:sym<try>")
  debug_1022:
    .return (rx1467_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<try>"  :subid("117_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P1471 = self."!PREFIX__!subrule"("blorst", "try")
    new $P1472, "ResizablePMCArray"
    push $P1472, $P1471
    .return ($P1472)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blorst"  :subid("118_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx1474_tgt
    .local int rx1474_pos
    .local int rx1474_off
    .local int rx1474_eos
    .local int rx1474_rep
    .local pmc rx1474_cur
    .local pmc rx1474_debug
    (rx1474_cur, rx1474_pos, rx1474_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1474_cur
    .local pmc match
    .lex "$/", match
    length rx1474_eos, rx1474_tgt
    gt rx1474_pos, rx1474_eos, rx1474_done
    set rx1474_off, 0
    lt rx1474_pos, 2, rx1474_start
    sub rx1474_off, rx1474_pos, 1
    substr rx1474_tgt, rx1474_tgt, rx1474_off
  rx1474_start:
    eq $I10, 1, rx1474_restart
    if_null rx1474_debug, debug_1023
    rx1474_cur."!cursor_debug"("START", "blorst")
  debug_1023:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1475_done
    goto rxscan1475_scan
  rxscan1475_loop:
    (rx1474_pos) = rx1474_cur."from"()
    inc rx1474_pos
    rx1474_cur."!cursor_from"(rx1474_pos)
    ge rx1474_pos, rx1474_eos, rxscan1475_done
  rxscan1475_scan:
    set_addr $I10, rxscan1475_loop
    rx1474_cur."!mark_push"(0, rx1474_pos, $I10)
  rxscan1475_done:
.annotate 'line', 677
  # rx charclass s
    ge rx1474_pos, rx1474_eos, rx1474_fail
    sub $I10, rx1474_pos, rx1474_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1474_tgt, $I10
    unless $I11, rx1474_fail
    inc rx1474_pos
  # rx subrule "ws" subtype=method negate=
    rx1474_cur."!cursor_pos"(rx1474_pos)
    $P10 = rx1474_cur."ws"()
    unless $P10, rx1474_fail
    rx1474_pos = $P10."pos"()
  alt1476_0:
    set_addr $I10, alt1476_1
    rx1474_cur."!mark_push"(0, rx1474_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1474_pos, rx1474_off
    substr $S10, rx1474_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1474_fail
  # rx subrule "block" subtype=capture negate=
    rx1474_cur."!cursor_pos"(rx1474_pos)
    $P10 = rx1474_cur."block"()
    unless $P10, rx1474_fail
    rx1474_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1474_pos = $P10."pos"()
    goto alt1476_end
  alt1476_1:
  # rx subrule "statement" subtype=capture negate=
    rx1474_cur."!cursor_pos"(rx1474_pos)
    $P10 = rx1474_cur."statement"()
    unless $P10, rx1474_fail
    rx1474_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx1474_pos = $P10."pos"()
  alt1476_end:
.annotate 'line', 676
  # rx pass
    rx1474_cur."!cursor_pass"(rx1474_pos, "blorst")
    if_null rx1474_debug, debug_1024
    rx1474_cur."!cursor_debug"("PASS", "blorst", " at pos=", rx1474_pos)
  debug_1024:
    .return (rx1474_cur)
  rx1474_restart:
.annotate 'line', 436
    if_null rx1474_debug, debug_1025
    rx1474_cur."!cursor_debug"("NEXT", "blorst")
  debug_1025:
  rx1474_fail:
    (rx1474_rep, rx1474_pos, $I10, $P10) = rx1474_cur."!mark_fail"(0)
    lt rx1474_pos, -1, rx1474_done
    eq rx1474_pos, -1, rx1474_fail
    jump $I10
  rx1474_done:
    rx1474_cur."!cursor_fail"()
    if_null rx1474_debug, debug_1026
    rx1474_cur."!cursor_debug"("FAIL", "blorst")
  debug_1026:
    .return (rx1474_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blorst"  :subid("119_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    new $P1478, "ResizablePMCArray"
    push $P1478, ""
    .return ($P1478)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond"  :subid("120_1307873304.82979")
    .param pmc param_1480
.annotate 'line', 682
    .lex "self", param_1480
    $P1481 = param_1480."!protoregex"("statement_mod_cond")
    .return ($P1481)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond"  :subid("121_1307873304.82979")
    .param pmc param_1483
.annotate 'line', 682
    .lex "self", param_1483
    $P1484 = param_1483."!PREFIX__!protoregex"("statement_mod_cond")
    .return ($P1484)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<if>"  :subid("122_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx1486_tgt
    .local int rx1486_pos
    .local int rx1486_off
    .local int rx1486_eos
    .local int rx1486_rep
    .local pmc rx1486_cur
    .local pmc rx1486_debug
    (rx1486_cur, rx1486_pos, rx1486_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1486_cur
    .local pmc match
    .lex "$/", match
    length rx1486_eos, rx1486_tgt
    gt rx1486_pos, rx1486_eos, rx1486_done
    set rx1486_off, 0
    lt rx1486_pos, 2, rx1486_start
    sub rx1486_off, rx1486_pos, 1
    substr rx1486_tgt, rx1486_tgt, rx1486_off
  rx1486_start:
    eq $I10, 1, rx1486_restart
    if_null rx1486_debug, debug_1027
    rx1486_cur."!cursor_debug"("START", "statement_mod_cond:sym<if>")
  debug_1027:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1487_done
    goto rxscan1487_scan
  rxscan1487_loop:
    (rx1486_pos) = rx1486_cur."from"()
    inc rx1486_pos
    rx1486_cur."!cursor_from"(rx1486_pos)
    ge rx1486_pos, rx1486_eos, rxscan1487_done
  rxscan1487_scan:
    set_addr $I10, rxscan1487_loop
    rx1486_cur."!mark_push"(0, rx1486_pos, $I10)
  rxscan1487_done:
.annotate 'line', 684
  # rx subcapture "sym"
    set_addr $I10, rxcap_1488_fail
    rx1486_cur."!mark_push"(0, rx1486_pos, $I10)
  # rx literal  "if"
    add $I11, rx1486_pos, 2
    gt $I11, rx1486_eos, rx1486_fail
    sub $I11, rx1486_pos, rx1486_off
    substr $S10, rx1486_tgt, $I11, 2
    ne $S10, "if", rx1486_fail
    add rx1486_pos, 2
    set_addr $I10, rxcap_1488_fail
    ($I12, $I11) = rx1486_cur."!mark_peek"($I10)
    rx1486_cur."!cursor_pos"($I11)
    ($P10) = rx1486_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1486_pos, "")
    rx1486_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1488_done
  rxcap_1488_fail:
    goto rx1486_fail
  rxcap_1488_done:
  # rx subrule "ws" subtype=method negate=
    rx1486_cur."!cursor_pos"(rx1486_pos)
    $P10 = rx1486_cur."ws"()
    unless $P10, rx1486_fail
    rx1486_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1486_cur."!cursor_pos"(rx1486_pos)
    $P10 = rx1486_cur."EXPR"()
    unless $P10, rx1486_fail
    rx1486_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx1486_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1486_cur."!cursor_pos"(rx1486_pos)
    $P10 = rx1486_cur."ws"()
    unless $P10, rx1486_fail
    rx1486_pos = $P10."pos"()
  # rx pass
    rx1486_cur."!cursor_pass"(rx1486_pos, "statement_mod_cond:sym<if>")
    if_null rx1486_debug, debug_1028
    rx1486_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<if>", " at pos=", rx1486_pos)
  debug_1028:
    .return (rx1486_cur)
  rx1486_restart:
.annotate 'line', 436
    if_null rx1486_debug, debug_1029
    rx1486_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<if>")
  debug_1029:
  rx1486_fail:
    (rx1486_rep, rx1486_pos, $I10, $P10) = rx1486_cur."!mark_fail"(0)
    lt rx1486_pos, -1, rx1486_done
    eq rx1486_pos, -1, rx1486_fail
    jump $I10
  rx1486_done:
    rx1486_cur."!cursor_fail"()
    if_null rx1486_debug, debug_1030
    rx1486_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<if>")
  debug_1030:
    .return (rx1486_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<if>"  :subid("123_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P1492 = self."!PREFIX__!subrule"("ws", "if")
    new $P1493, "ResizablePMCArray"
    push $P1493, $P1492
    .return ($P1493)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<unless>"  :subid("124_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx1495_tgt
    .local int rx1495_pos
    .local int rx1495_off
    .local int rx1495_eos
    .local int rx1495_rep
    .local pmc rx1495_cur
    .local pmc rx1495_debug
    (rx1495_cur, rx1495_pos, rx1495_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1495_cur
    .local pmc match
    .lex "$/", match
    length rx1495_eos, rx1495_tgt
    gt rx1495_pos, rx1495_eos, rx1495_done
    set rx1495_off, 0
    lt rx1495_pos, 2, rx1495_start
    sub rx1495_off, rx1495_pos, 1
    substr rx1495_tgt, rx1495_tgt, rx1495_off
  rx1495_start:
    eq $I10, 1, rx1495_restart
    if_null rx1495_debug, debug_1031
    rx1495_cur."!cursor_debug"("START", "statement_mod_cond:sym<unless>")
  debug_1031:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1496_done
    goto rxscan1496_scan
  rxscan1496_loop:
    (rx1495_pos) = rx1495_cur."from"()
    inc rx1495_pos
    rx1495_cur."!cursor_from"(rx1495_pos)
    ge rx1495_pos, rx1495_eos, rxscan1496_done
  rxscan1496_scan:
    set_addr $I10, rxscan1496_loop
    rx1495_cur."!mark_push"(0, rx1495_pos, $I10)
  rxscan1496_done:
.annotate 'line', 685
  # rx subcapture "sym"
    set_addr $I10, rxcap_1497_fail
    rx1495_cur."!mark_push"(0, rx1495_pos, $I10)
  # rx literal  "unless"
    add $I11, rx1495_pos, 6
    gt $I11, rx1495_eos, rx1495_fail
    sub $I11, rx1495_pos, rx1495_off
    substr $S10, rx1495_tgt, $I11, 6
    ne $S10, "unless", rx1495_fail
    add rx1495_pos, 6
    set_addr $I10, rxcap_1497_fail
    ($I12, $I11) = rx1495_cur."!mark_peek"($I10)
    rx1495_cur."!cursor_pos"($I11)
    ($P10) = rx1495_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1495_pos, "")
    rx1495_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1497_done
  rxcap_1497_fail:
    goto rx1495_fail
  rxcap_1497_done:
  # rx subrule "ws" subtype=method negate=
    rx1495_cur."!cursor_pos"(rx1495_pos)
    $P10 = rx1495_cur."ws"()
    unless $P10, rx1495_fail
    rx1495_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1495_cur."!cursor_pos"(rx1495_pos)
    $P10 = rx1495_cur."EXPR"()
    unless $P10, rx1495_fail
    rx1495_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx1495_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1495_cur."!cursor_pos"(rx1495_pos)
    $P10 = rx1495_cur."ws"()
    unless $P10, rx1495_fail
    rx1495_pos = $P10."pos"()
  # rx pass
    rx1495_cur."!cursor_pass"(rx1495_pos, "statement_mod_cond:sym<unless>")
    if_null rx1495_debug, debug_1032
    rx1495_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<unless>", " at pos=", rx1495_pos)
  debug_1032:
    .return (rx1495_cur)
  rx1495_restart:
.annotate 'line', 436
    if_null rx1495_debug, debug_1033
    rx1495_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<unless>")
  debug_1033:
  rx1495_fail:
    (rx1495_rep, rx1495_pos, $I10, $P10) = rx1495_cur."!mark_fail"(0)
    lt rx1495_pos, -1, rx1495_done
    eq rx1495_pos, -1, rx1495_fail
    jump $I10
  rx1495_done:
    rx1495_cur."!cursor_fail"()
    if_null rx1495_debug, debug_1034
    rx1495_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<unless>")
  debug_1034:
    .return (rx1495_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<unless>"  :subid("125_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P1501 = self."!PREFIX__!subrule"("ws", "unless")
    new $P1502, "ResizablePMCArray"
    push $P1502, $P1501
    .return ($P1502)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop"  :subid("126_1307873304.82979")
    .param pmc param_1504
.annotate 'line', 687
    .lex "self", param_1504
    $P1505 = param_1504."!protoregex"("statement_mod_loop")
    .return ($P1505)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop"  :subid("127_1307873304.82979")
    .param pmc param_1507
.annotate 'line', 687
    .lex "self", param_1507
    $P1508 = param_1507."!PREFIX__!protoregex"("statement_mod_loop")
    .return ($P1508)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<while>"  :subid("128_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx1510_tgt
    .local int rx1510_pos
    .local int rx1510_off
    .local int rx1510_eos
    .local int rx1510_rep
    .local pmc rx1510_cur
    .local pmc rx1510_debug
    (rx1510_cur, rx1510_pos, rx1510_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1510_cur
    .local pmc match
    .lex "$/", match
    length rx1510_eos, rx1510_tgt
    gt rx1510_pos, rx1510_eos, rx1510_done
    set rx1510_off, 0
    lt rx1510_pos, 2, rx1510_start
    sub rx1510_off, rx1510_pos, 1
    substr rx1510_tgt, rx1510_tgt, rx1510_off
  rx1510_start:
    eq $I10, 1, rx1510_restart
    if_null rx1510_debug, debug_1035
    rx1510_cur."!cursor_debug"("START", "statement_mod_loop:sym<while>")
  debug_1035:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1511_done
    goto rxscan1511_scan
  rxscan1511_loop:
    (rx1510_pos) = rx1510_cur."from"()
    inc rx1510_pos
    rx1510_cur."!cursor_from"(rx1510_pos)
    ge rx1510_pos, rx1510_eos, rxscan1511_done
  rxscan1511_scan:
    set_addr $I10, rxscan1511_loop
    rx1510_cur."!mark_push"(0, rx1510_pos, $I10)
  rxscan1511_done:
.annotate 'line', 689
  # rx subcapture "sym"
    set_addr $I10, rxcap_1512_fail
    rx1510_cur."!mark_push"(0, rx1510_pos, $I10)
  # rx literal  "while"
    add $I11, rx1510_pos, 5
    gt $I11, rx1510_eos, rx1510_fail
    sub $I11, rx1510_pos, rx1510_off
    substr $S10, rx1510_tgt, $I11, 5
    ne $S10, "while", rx1510_fail
    add rx1510_pos, 5
    set_addr $I10, rxcap_1512_fail
    ($I12, $I11) = rx1510_cur."!mark_peek"($I10)
    rx1510_cur."!cursor_pos"($I11)
    ($P10) = rx1510_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1510_pos, "")
    rx1510_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1512_done
  rxcap_1512_fail:
    goto rx1510_fail
  rxcap_1512_done:
  # rx subrule "ws" subtype=method negate=
    rx1510_cur."!cursor_pos"(rx1510_pos)
    $P10 = rx1510_cur."ws"()
    unless $P10, rx1510_fail
    rx1510_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1510_cur."!cursor_pos"(rx1510_pos)
    $P10 = rx1510_cur."EXPR"()
    unless $P10, rx1510_fail
    rx1510_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx1510_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1510_cur."!cursor_pos"(rx1510_pos)
    $P10 = rx1510_cur."ws"()
    unless $P10, rx1510_fail
    rx1510_pos = $P10."pos"()
  # rx pass
    rx1510_cur."!cursor_pass"(rx1510_pos, "statement_mod_loop:sym<while>")
    if_null rx1510_debug, debug_1036
    rx1510_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<while>", " at pos=", rx1510_pos)
  debug_1036:
    .return (rx1510_cur)
  rx1510_restart:
.annotate 'line', 436
    if_null rx1510_debug, debug_1037
    rx1510_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<while>")
  debug_1037:
  rx1510_fail:
    (rx1510_rep, rx1510_pos, $I10, $P10) = rx1510_cur."!mark_fail"(0)
    lt rx1510_pos, -1, rx1510_done
    eq rx1510_pos, -1, rx1510_fail
    jump $I10
  rx1510_done:
    rx1510_cur."!cursor_fail"()
    if_null rx1510_debug, debug_1038
    rx1510_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<while>")
  debug_1038:
    .return (rx1510_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<while>"  :subid("129_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P1516 = self."!PREFIX__!subrule"("ws", "while")
    new $P1517, "ResizablePMCArray"
    push $P1517, $P1516
    .return ($P1517)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<until>"  :subid("130_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx1519_tgt
    .local int rx1519_pos
    .local int rx1519_off
    .local int rx1519_eos
    .local int rx1519_rep
    .local pmc rx1519_cur
    .local pmc rx1519_debug
    (rx1519_cur, rx1519_pos, rx1519_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1519_cur
    .local pmc match
    .lex "$/", match
    length rx1519_eos, rx1519_tgt
    gt rx1519_pos, rx1519_eos, rx1519_done
    set rx1519_off, 0
    lt rx1519_pos, 2, rx1519_start
    sub rx1519_off, rx1519_pos, 1
    substr rx1519_tgt, rx1519_tgt, rx1519_off
  rx1519_start:
    eq $I10, 1, rx1519_restart
    if_null rx1519_debug, debug_1039
    rx1519_cur."!cursor_debug"("START", "statement_mod_loop:sym<until>")
  debug_1039:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1520_done
    goto rxscan1520_scan
  rxscan1520_loop:
    (rx1519_pos) = rx1519_cur."from"()
    inc rx1519_pos
    rx1519_cur."!cursor_from"(rx1519_pos)
    ge rx1519_pos, rx1519_eos, rxscan1520_done
  rxscan1520_scan:
    set_addr $I10, rxscan1520_loop
    rx1519_cur."!mark_push"(0, rx1519_pos, $I10)
  rxscan1520_done:
.annotate 'line', 690
  # rx subcapture "sym"
    set_addr $I10, rxcap_1521_fail
    rx1519_cur."!mark_push"(0, rx1519_pos, $I10)
  # rx literal  "until"
    add $I11, rx1519_pos, 5
    gt $I11, rx1519_eos, rx1519_fail
    sub $I11, rx1519_pos, rx1519_off
    substr $S10, rx1519_tgt, $I11, 5
    ne $S10, "until", rx1519_fail
    add rx1519_pos, 5
    set_addr $I10, rxcap_1521_fail
    ($I12, $I11) = rx1519_cur."!mark_peek"($I10)
    rx1519_cur."!cursor_pos"($I11)
    ($P10) = rx1519_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1519_pos, "")
    rx1519_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1521_done
  rxcap_1521_fail:
    goto rx1519_fail
  rxcap_1521_done:
  # rx subrule "ws" subtype=method negate=
    rx1519_cur."!cursor_pos"(rx1519_pos)
    $P10 = rx1519_cur."ws"()
    unless $P10, rx1519_fail
    rx1519_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1519_cur."!cursor_pos"(rx1519_pos)
    $P10 = rx1519_cur."EXPR"()
    unless $P10, rx1519_fail
    rx1519_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx1519_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1519_cur."!cursor_pos"(rx1519_pos)
    $P10 = rx1519_cur."ws"()
    unless $P10, rx1519_fail
    rx1519_pos = $P10."pos"()
  # rx pass
    rx1519_cur."!cursor_pass"(rx1519_pos, "statement_mod_loop:sym<until>")
    if_null rx1519_debug, debug_1040
    rx1519_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<until>", " at pos=", rx1519_pos)
  debug_1040:
    .return (rx1519_cur)
  rx1519_restart:
.annotate 'line', 436
    if_null rx1519_debug, debug_1041
    rx1519_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<until>")
  debug_1041:
  rx1519_fail:
    (rx1519_rep, rx1519_pos, $I10, $P10) = rx1519_cur."!mark_fail"(0)
    lt rx1519_pos, -1, rx1519_done
    eq rx1519_pos, -1, rx1519_fail
    jump $I10
  rx1519_done:
    rx1519_cur."!cursor_fail"()
    if_null rx1519_debug, debug_1042
    rx1519_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<until>")
  debug_1042:
    .return (rx1519_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<until>"  :subid("131_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P1525 = self."!PREFIX__!subrule"("ws", "until")
    new $P1526, "ResizablePMCArray"
    push $P1526, $P1525
    .return ($P1526)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<for>"  :subid("132_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx1528_tgt
    .local int rx1528_pos
    .local int rx1528_off
    .local int rx1528_eos
    .local int rx1528_rep
    .local pmc rx1528_cur
    .local pmc rx1528_debug
    (rx1528_cur, rx1528_pos, rx1528_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1528_cur
    .local pmc match
    .lex "$/", match
    length rx1528_eos, rx1528_tgt
    gt rx1528_pos, rx1528_eos, rx1528_done
    set rx1528_off, 0
    lt rx1528_pos, 2, rx1528_start
    sub rx1528_off, rx1528_pos, 1
    substr rx1528_tgt, rx1528_tgt, rx1528_off
  rx1528_start:
    eq $I10, 1, rx1528_restart
    if_null rx1528_debug, debug_1043
    rx1528_cur."!cursor_debug"("START", "statement_mod_loop:sym<for>")
  debug_1043:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1529_done
    goto rxscan1529_scan
  rxscan1529_loop:
    (rx1528_pos) = rx1528_cur."from"()
    inc rx1528_pos
    rx1528_cur."!cursor_from"(rx1528_pos)
    ge rx1528_pos, rx1528_eos, rxscan1529_done
  rxscan1529_scan:
    set_addr $I10, rxscan1529_loop
    rx1528_cur."!mark_push"(0, rx1528_pos, $I10)
  rxscan1529_done:
.annotate 'line', 691
  # rx subcapture "sym"
    set_addr $I10, rxcap_1530_fail
    rx1528_cur."!mark_push"(0, rx1528_pos, $I10)
  # rx literal  "for"
    add $I11, rx1528_pos, 3
    gt $I11, rx1528_eos, rx1528_fail
    sub $I11, rx1528_pos, rx1528_off
    substr $S10, rx1528_tgt, $I11, 3
    ne $S10, "for", rx1528_fail
    add rx1528_pos, 3
    set_addr $I10, rxcap_1530_fail
    ($I12, $I11) = rx1528_cur."!mark_peek"($I10)
    rx1528_cur."!cursor_pos"($I11)
    ($P10) = rx1528_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1528_pos, "")
    rx1528_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1530_done
  rxcap_1530_fail:
    goto rx1528_fail
  rxcap_1530_done:
  # rx subrule "ws" subtype=method negate=
    rx1528_cur."!cursor_pos"(rx1528_pos)
    $P10 = rx1528_cur."ws"()
    unless $P10, rx1528_fail
    rx1528_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1528_cur."!cursor_pos"(rx1528_pos)
    $P10 = rx1528_cur."EXPR"()
    unless $P10, rx1528_fail
    rx1528_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx1528_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1528_cur."!cursor_pos"(rx1528_pos)
    $P10 = rx1528_cur."ws"()
    unless $P10, rx1528_fail
    rx1528_pos = $P10."pos"()
  # rx pass
    rx1528_cur."!cursor_pass"(rx1528_pos, "statement_mod_loop:sym<for>")
    if_null rx1528_debug, debug_1044
    rx1528_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<for>", " at pos=", rx1528_pos)
  debug_1044:
    .return (rx1528_cur)
  rx1528_restart:
.annotate 'line', 436
    if_null rx1528_debug, debug_1045
    rx1528_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<for>")
  debug_1045:
  rx1528_fail:
    (rx1528_rep, rx1528_pos, $I10, $P10) = rx1528_cur."!mark_fail"(0)
    lt rx1528_pos, -1, rx1528_done
    eq rx1528_pos, -1, rx1528_fail
    jump $I10
  rx1528_done:
    rx1528_cur."!cursor_fail"()
    if_null rx1528_debug, debug_1046
    rx1528_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<for>")
  debug_1046:
    .return (rx1528_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<for>"  :subid("133_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P1534 = self."!PREFIX__!subrule"("ws", "for")
    new $P1535, "ResizablePMCArray"
    push $P1535, $P1534
    .return ($P1535)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<fatarrow>"  :subid("134_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx1537_tgt
    .local int rx1537_pos
    .local int rx1537_off
    .local int rx1537_eos
    .local int rx1537_rep
    .local pmc rx1537_cur
    .local pmc rx1537_debug
    (rx1537_cur, rx1537_pos, rx1537_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1537_cur
    .local pmc match
    .lex "$/", match
    length rx1537_eos, rx1537_tgt
    gt rx1537_pos, rx1537_eos, rx1537_done
    set rx1537_off, 0
    lt rx1537_pos, 2, rx1537_start
    sub rx1537_off, rx1537_pos, 1
    substr rx1537_tgt, rx1537_tgt, rx1537_off
  rx1537_start:
    eq $I10, 1, rx1537_restart
    if_null rx1537_debug, debug_1047
    rx1537_cur."!cursor_debug"("START", "term:sym<fatarrow>")
  debug_1047:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1538_done
    goto rxscan1538_scan
  rxscan1538_loop:
    (rx1537_pos) = rx1537_cur."from"()
    inc rx1537_pos
    rx1537_cur."!cursor_from"(rx1537_pos)
    ge rx1537_pos, rx1537_eos, rxscan1538_done
  rxscan1538_scan:
    set_addr $I10, rxscan1538_loop
    rx1537_cur."!mark_push"(0, rx1537_pos, $I10)
  rxscan1538_done:
.annotate 'line', 695
  # rx subrule "fatarrow" subtype=capture negate=
    rx1537_cur."!cursor_pos"(rx1537_pos)
    $P10 = rx1537_cur."fatarrow"()
    unless $P10, rx1537_fail
    rx1537_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("fatarrow")
    rx1537_pos = $P10."pos"()
  # rx pass
    rx1537_cur."!cursor_pass"(rx1537_pos, "term:sym<fatarrow>")
    if_null rx1537_debug, debug_1048
    rx1537_cur."!cursor_debug"("PASS", "term:sym<fatarrow>", " at pos=", rx1537_pos)
  debug_1048:
    .return (rx1537_cur)
  rx1537_restart:
.annotate 'line', 436
    if_null rx1537_debug, debug_1049
    rx1537_cur."!cursor_debug"("NEXT", "term:sym<fatarrow>")
  debug_1049:
  rx1537_fail:
    (rx1537_rep, rx1537_pos, $I10, $P10) = rx1537_cur."!mark_fail"(0)
    lt rx1537_pos, -1, rx1537_done
    eq rx1537_pos, -1, rx1537_fail
    jump $I10
  rx1537_done:
    rx1537_cur."!cursor_fail"()
    if_null rx1537_debug, debug_1050
    rx1537_cur."!cursor_debug"("FAIL", "term:sym<fatarrow>")
  debug_1050:
    .return (rx1537_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<fatarrow>"  :subid("135_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P1540 = self."!PREFIX__!subrule"("fatarrow", "")
    new $P1541, "ResizablePMCArray"
    push $P1541, $P1540
    .return ($P1541)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<colonpair>"  :subid("136_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx1543_tgt
    .local int rx1543_pos
    .local int rx1543_off
    .local int rx1543_eos
    .local int rx1543_rep
    .local pmc rx1543_cur
    .local pmc rx1543_debug
    (rx1543_cur, rx1543_pos, rx1543_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1543_cur
    .local pmc match
    .lex "$/", match
    length rx1543_eos, rx1543_tgt
    gt rx1543_pos, rx1543_eos, rx1543_done
    set rx1543_off, 0
    lt rx1543_pos, 2, rx1543_start
    sub rx1543_off, rx1543_pos, 1
    substr rx1543_tgt, rx1543_tgt, rx1543_off
  rx1543_start:
    eq $I10, 1, rx1543_restart
    if_null rx1543_debug, debug_1051
    rx1543_cur."!cursor_debug"("START", "term:sym<colonpair>")
  debug_1051:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1544_done
    goto rxscan1544_scan
  rxscan1544_loop:
    (rx1543_pos) = rx1543_cur."from"()
    inc rx1543_pos
    rx1543_cur."!cursor_from"(rx1543_pos)
    ge rx1543_pos, rx1543_eos, rxscan1544_done
  rxscan1544_scan:
    set_addr $I10, rxscan1544_loop
    rx1543_cur."!mark_push"(0, rx1543_pos, $I10)
  rxscan1544_done:
.annotate 'line', 696
  # rx subrule "colonpair" subtype=capture negate=
    rx1543_cur."!cursor_pos"(rx1543_pos)
    $P10 = rx1543_cur."colonpair"()
    unless $P10, rx1543_fail
    rx1543_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("colonpair")
    rx1543_pos = $P10."pos"()
  # rx pass
    rx1543_cur."!cursor_pass"(rx1543_pos, "term:sym<colonpair>")
    if_null rx1543_debug, debug_1052
    rx1543_cur."!cursor_debug"("PASS", "term:sym<colonpair>", " at pos=", rx1543_pos)
  debug_1052:
    .return (rx1543_cur)
  rx1543_restart:
.annotate 'line', 436
    if_null rx1543_debug, debug_1053
    rx1543_cur."!cursor_debug"("NEXT", "term:sym<colonpair>")
  debug_1053:
  rx1543_fail:
    (rx1543_rep, rx1543_pos, $I10, $P10) = rx1543_cur."!mark_fail"(0)
    lt rx1543_pos, -1, rx1543_done
    eq rx1543_pos, -1, rx1543_fail
    jump $I10
  rx1543_done:
    rx1543_cur."!cursor_fail"()
    if_null rx1543_debug, debug_1054
    rx1543_cur."!cursor_debug"("FAIL", "term:sym<colonpair>")
  debug_1054:
    .return (rx1543_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<colonpair>"  :subid("137_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P1546 = self."!PREFIX__!subrule"("colonpair", "")
    new $P1547, "ResizablePMCArray"
    push $P1547, $P1546
    .return ($P1547)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<variable>"  :subid("138_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx1549_tgt
    .local int rx1549_pos
    .local int rx1549_off
    .local int rx1549_eos
    .local int rx1549_rep
    .local pmc rx1549_cur
    .local pmc rx1549_debug
    (rx1549_cur, rx1549_pos, rx1549_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1549_cur
    .local pmc match
    .lex "$/", match
    length rx1549_eos, rx1549_tgt
    gt rx1549_pos, rx1549_eos, rx1549_done
    set rx1549_off, 0
    lt rx1549_pos, 2, rx1549_start
    sub rx1549_off, rx1549_pos, 1
    substr rx1549_tgt, rx1549_tgt, rx1549_off
  rx1549_start:
    eq $I10, 1, rx1549_restart
    if_null rx1549_debug, debug_1055
    rx1549_cur."!cursor_debug"("START", "term:sym<variable>")
  debug_1055:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1550_done
    goto rxscan1550_scan
  rxscan1550_loop:
    (rx1549_pos) = rx1549_cur."from"()
    inc rx1549_pos
    rx1549_cur."!cursor_from"(rx1549_pos)
    ge rx1549_pos, rx1549_eos, rxscan1550_done
  rxscan1550_scan:
    set_addr $I10, rxscan1550_loop
    rx1549_cur."!mark_push"(0, rx1549_pos, $I10)
  rxscan1550_done:
.annotate 'line', 697
  # rx subrule "variable" subtype=capture negate=
    rx1549_cur."!cursor_pos"(rx1549_pos)
    $P10 = rx1549_cur."variable"()
    unless $P10, rx1549_fail
    rx1549_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx1549_pos = $P10."pos"()
  # rx pass
    rx1549_cur."!cursor_pass"(rx1549_pos, "term:sym<variable>")
    if_null rx1549_debug, debug_1056
    rx1549_cur."!cursor_debug"("PASS", "term:sym<variable>", " at pos=", rx1549_pos)
  debug_1056:
    .return (rx1549_cur)
  rx1549_restart:
.annotate 'line', 436
    if_null rx1549_debug, debug_1057
    rx1549_cur."!cursor_debug"("NEXT", "term:sym<variable>")
  debug_1057:
  rx1549_fail:
    (rx1549_rep, rx1549_pos, $I10, $P10) = rx1549_cur."!mark_fail"(0)
    lt rx1549_pos, -1, rx1549_done
    eq rx1549_pos, -1, rx1549_fail
    jump $I10
  rx1549_done:
    rx1549_cur."!cursor_fail"()
    if_null rx1549_debug, debug_1058
    rx1549_cur."!cursor_debug"("FAIL", "term:sym<variable>")
  debug_1058:
    .return (rx1549_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<variable>"  :subid("139_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P1552 = self."!PREFIX__!subrule"("variable", "")
    new $P1553, "ResizablePMCArray"
    push $P1553, $P1552
    .return ($P1553)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<package_declarator>"  :subid("140_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx1555_tgt
    .local int rx1555_pos
    .local int rx1555_off
    .local int rx1555_eos
    .local int rx1555_rep
    .local pmc rx1555_cur
    .local pmc rx1555_debug
    (rx1555_cur, rx1555_pos, rx1555_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1555_cur
    .local pmc match
    .lex "$/", match
    length rx1555_eos, rx1555_tgt
    gt rx1555_pos, rx1555_eos, rx1555_done
    set rx1555_off, 0
    lt rx1555_pos, 2, rx1555_start
    sub rx1555_off, rx1555_pos, 1
    substr rx1555_tgt, rx1555_tgt, rx1555_off
  rx1555_start:
    eq $I10, 1, rx1555_restart
    if_null rx1555_debug, debug_1059
    rx1555_cur."!cursor_debug"("START", "term:sym<package_declarator>")
  debug_1059:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1556_done
    goto rxscan1556_scan
  rxscan1556_loop:
    (rx1555_pos) = rx1555_cur."from"()
    inc rx1555_pos
    rx1555_cur."!cursor_from"(rx1555_pos)
    ge rx1555_pos, rx1555_eos, rxscan1556_done
  rxscan1556_scan:
    set_addr $I10, rxscan1556_loop
    rx1555_cur."!mark_push"(0, rx1555_pos, $I10)
  rxscan1556_done:
.annotate 'line', 698
  # rx subrule "package_declarator" subtype=capture negate=
    rx1555_cur."!cursor_pos"(rx1555_pos)
    $P10 = rx1555_cur."package_declarator"()
    unless $P10, rx1555_fail
    rx1555_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx1555_pos = $P10."pos"()
  # rx pass
    rx1555_cur."!cursor_pass"(rx1555_pos, "term:sym<package_declarator>")
    if_null rx1555_debug, debug_1060
    rx1555_cur."!cursor_debug"("PASS", "term:sym<package_declarator>", " at pos=", rx1555_pos)
  debug_1060:
    .return (rx1555_cur)
  rx1555_restart:
.annotate 'line', 436
    if_null rx1555_debug, debug_1061
    rx1555_cur."!cursor_debug"("NEXT", "term:sym<package_declarator>")
  debug_1061:
  rx1555_fail:
    (rx1555_rep, rx1555_pos, $I10, $P10) = rx1555_cur."!mark_fail"(0)
    lt rx1555_pos, -1, rx1555_done
    eq rx1555_pos, -1, rx1555_fail
    jump $I10
  rx1555_done:
    rx1555_cur."!cursor_fail"()
    if_null rx1555_debug, debug_1062
    rx1555_cur."!cursor_debug"("FAIL", "term:sym<package_declarator>")
  debug_1062:
    .return (rx1555_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<package_declarator>"  :subid("141_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P1558 = self."!PREFIX__!subrule"("package_declarator", "")
    new $P1559, "ResizablePMCArray"
    push $P1559, $P1558
    .return ($P1559)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<scope_declarator>"  :subid("142_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx1561_tgt
    .local int rx1561_pos
    .local int rx1561_off
    .local int rx1561_eos
    .local int rx1561_rep
    .local pmc rx1561_cur
    .local pmc rx1561_debug
    (rx1561_cur, rx1561_pos, rx1561_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1561_cur
    .local pmc match
    .lex "$/", match
    length rx1561_eos, rx1561_tgt
    gt rx1561_pos, rx1561_eos, rx1561_done
    set rx1561_off, 0
    lt rx1561_pos, 2, rx1561_start
    sub rx1561_off, rx1561_pos, 1
    substr rx1561_tgt, rx1561_tgt, rx1561_off
  rx1561_start:
    eq $I10, 1, rx1561_restart
    if_null rx1561_debug, debug_1063
    rx1561_cur."!cursor_debug"("START", "term:sym<scope_declarator>")
  debug_1063:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1562_done
    goto rxscan1562_scan
  rxscan1562_loop:
    (rx1561_pos) = rx1561_cur."from"()
    inc rx1561_pos
    rx1561_cur."!cursor_from"(rx1561_pos)
    ge rx1561_pos, rx1561_eos, rxscan1562_done
  rxscan1562_scan:
    set_addr $I10, rxscan1562_loop
    rx1561_cur."!mark_push"(0, rx1561_pos, $I10)
  rxscan1562_done:
.annotate 'line', 699
  # rx subrule "scope_declarator" subtype=capture negate=
    rx1561_cur."!cursor_pos"(rx1561_pos)
    $P10 = rx1561_cur."scope_declarator"()
    unless $P10, rx1561_fail
    rx1561_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scope_declarator")
    rx1561_pos = $P10."pos"()
  # rx pass
    rx1561_cur."!cursor_pass"(rx1561_pos, "term:sym<scope_declarator>")
    if_null rx1561_debug, debug_1064
    rx1561_cur."!cursor_debug"("PASS", "term:sym<scope_declarator>", " at pos=", rx1561_pos)
  debug_1064:
    .return (rx1561_cur)
  rx1561_restart:
.annotate 'line', 436
    if_null rx1561_debug, debug_1065
    rx1561_cur."!cursor_debug"("NEXT", "term:sym<scope_declarator>")
  debug_1065:
  rx1561_fail:
    (rx1561_rep, rx1561_pos, $I10, $P10) = rx1561_cur."!mark_fail"(0)
    lt rx1561_pos, -1, rx1561_done
    eq rx1561_pos, -1, rx1561_fail
    jump $I10
  rx1561_done:
    rx1561_cur."!cursor_fail"()
    if_null rx1561_debug, debug_1066
    rx1561_cur."!cursor_debug"("FAIL", "term:sym<scope_declarator>")
  debug_1066:
    .return (rx1561_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<scope_declarator>"  :subid("143_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P1564 = self."!PREFIX__!subrule"("scope_declarator", "")
    new $P1565, "ResizablePMCArray"
    push $P1565, $P1564
    .return ($P1565)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<routine_declarator>"  :subid("144_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx1567_tgt
    .local int rx1567_pos
    .local int rx1567_off
    .local int rx1567_eos
    .local int rx1567_rep
    .local pmc rx1567_cur
    .local pmc rx1567_debug
    (rx1567_cur, rx1567_pos, rx1567_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1567_cur
    .local pmc match
    .lex "$/", match
    length rx1567_eos, rx1567_tgt
    gt rx1567_pos, rx1567_eos, rx1567_done
    set rx1567_off, 0
    lt rx1567_pos, 2, rx1567_start
    sub rx1567_off, rx1567_pos, 1
    substr rx1567_tgt, rx1567_tgt, rx1567_off
  rx1567_start:
    eq $I10, 1, rx1567_restart
    if_null rx1567_debug, debug_1067
    rx1567_cur."!cursor_debug"("START", "term:sym<routine_declarator>")
  debug_1067:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1568_done
    goto rxscan1568_scan
  rxscan1568_loop:
    (rx1567_pos) = rx1567_cur."from"()
    inc rx1567_pos
    rx1567_cur."!cursor_from"(rx1567_pos)
    ge rx1567_pos, rx1567_eos, rxscan1568_done
  rxscan1568_scan:
    set_addr $I10, rxscan1568_loop
    rx1567_cur."!mark_push"(0, rx1567_pos, $I10)
  rxscan1568_done:
.annotate 'line', 700
  # rx subrule "routine_declarator" subtype=capture negate=
    rx1567_cur."!cursor_pos"(rx1567_pos)
    $P10 = rx1567_cur."routine_declarator"()
    unless $P10, rx1567_fail
    rx1567_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx1567_pos = $P10."pos"()
  # rx pass
    rx1567_cur."!cursor_pass"(rx1567_pos, "term:sym<routine_declarator>")
    if_null rx1567_debug, debug_1068
    rx1567_cur."!cursor_debug"("PASS", "term:sym<routine_declarator>", " at pos=", rx1567_pos)
  debug_1068:
    .return (rx1567_cur)
  rx1567_restart:
.annotate 'line', 436
    if_null rx1567_debug, debug_1069
    rx1567_cur."!cursor_debug"("NEXT", "term:sym<routine_declarator>")
  debug_1069:
  rx1567_fail:
    (rx1567_rep, rx1567_pos, $I10, $P10) = rx1567_cur."!mark_fail"(0)
    lt rx1567_pos, -1, rx1567_done
    eq rx1567_pos, -1, rx1567_fail
    jump $I10
  rx1567_done:
    rx1567_cur."!cursor_fail"()
    if_null rx1567_debug, debug_1070
    rx1567_cur."!cursor_debug"("FAIL", "term:sym<routine_declarator>")
  debug_1070:
    .return (rx1567_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<routine_declarator>"  :subid("145_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P1570 = self."!PREFIX__!subrule"("routine_declarator", "")
    new $P1571, "ResizablePMCArray"
    push $P1571, $P1570
    .return ($P1571)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<multi_declarator>"  :subid("146_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .const 'Sub' $P1581 = "148_1307873304.82979" 
    capture_lex $P1581
    .const 'Sub' $P1576 = "147_1307873304.82979" 
    capture_lex $P1576
    .local string rx1573_tgt
    .local int rx1573_pos
    .local int rx1573_off
    .local int rx1573_eos
    .local int rx1573_rep
    .local pmc rx1573_cur
    .local pmc rx1573_debug
    (rx1573_cur, rx1573_pos, rx1573_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1573_cur
    .local pmc match
    .lex "$/", match
    length rx1573_eos, rx1573_tgt
    gt rx1573_pos, rx1573_eos, rx1573_done
    set rx1573_off, 0
    lt rx1573_pos, 2, rx1573_start
    sub rx1573_off, rx1573_pos, 1
    substr rx1573_tgt, rx1573_tgt, rx1573_off
  rx1573_start:
    eq $I10, 1, rx1573_restart
    if_null rx1573_debug, debug_1071
    rx1573_cur."!cursor_debug"("START", "term:sym<multi_declarator>")
  debug_1071:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1574_done
    goto rxscan1574_scan
  rxscan1574_loop:
    (rx1573_pos) = rx1573_cur."from"()
    inc rx1573_pos
    rx1573_cur."!cursor_from"(rx1573_pos)
    ge rx1573_pos, rx1573_eos, rxscan1574_done
  rxscan1574_scan:
    set_addr $I10, rxscan1574_loop
    rx1573_cur."!mark_push"(0, rx1573_pos, $I10)
  rxscan1574_done:
.annotate 'line', 702
  # rx subrule "before" subtype=zerowidth negate=
    rx1573_cur."!cursor_pos"(rx1573_pos)
    .const 'Sub' $P1576 = "147_1307873304.82979" 
    capture_lex $P1576
    $P10 = rx1573_cur."before"($P1576)
    unless $P10, rx1573_fail
.annotate 'line', 703
  # rx subrule "before" subtype=zerowidth negate=1
    rx1573_cur."!cursor_pos"(rx1573_pos)
    .const 'Sub' $P1581 = "148_1307873304.82979" 
    capture_lex $P1581
    $P10 = rx1573_cur."before"($P1581)
    if $P10, rx1573_fail
.annotate 'line', 704
  # rx subrule "multi_declarator" subtype=capture negate=
    rx1573_cur."!cursor_pos"(rx1573_pos)
    $P10 = rx1573_cur."multi_declarator"()
    unless $P10, rx1573_fail
    rx1573_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx1573_pos = $P10."pos"()
.annotate 'line', 701
  # rx pass
    rx1573_cur."!cursor_pass"(rx1573_pos, "term:sym<multi_declarator>")
    if_null rx1573_debug, debug_1080
    rx1573_cur."!cursor_debug"("PASS", "term:sym<multi_declarator>", " at pos=", rx1573_pos)
  debug_1080:
    .return (rx1573_cur)
  rx1573_restart:
.annotate 'line', 436
    if_null rx1573_debug, debug_1081
    rx1573_cur."!cursor_debug"("NEXT", "term:sym<multi_declarator>")
  debug_1081:
  rx1573_fail:
    (rx1573_rep, rx1573_pos, $I10, $P10) = rx1573_cur."!mark_fail"(0)
    lt rx1573_pos, -1, rx1573_done
    eq rx1573_pos, -1, rx1573_fail
    jump $I10
  rx1573_done:
    rx1573_cur."!cursor_fail"()
    if_null rx1573_debug, debug_1082
    rx1573_cur."!cursor_debug"("FAIL", "term:sym<multi_declarator>")
  debug_1082:
    .return (rx1573_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1575"  :anon :subid("147_1307873304.82979") :method :outer("146_1307873304.82979")
.annotate 'line', 702
    .local string rx1577_tgt
    .local int rx1577_pos
    .local int rx1577_off
    .local int rx1577_eos
    .local int rx1577_rep
    .local pmc rx1577_cur
    .local pmc rx1577_debug
    (rx1577_cur, rx1577_pos, rx1577_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1577_cur
    .local pmc match
    .lex "$/", match
    length rx1577_eos, rx1577_tgt
    gt rx1577_pos, rx1577_eos, rx1577_done
    set rx1577_off, 0
    lt rx1577_pos, 2, rx1577_start
    sub rx1577_off, rx1577_pos, 1
    substr rx1577_tgt, rx1577_tgt, rx1577_off
  rx1577_start:
    eq $I10, 1, rx1577_restart
    if_null rx1577_debug, debug_1072
    rx1577_cur."!cursor_debug"("START", "")
  debug_1072:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1578_done
    goto rxscan1578_scan
  rxscan1578_loop:
    (rx1577_pos) = rx1577_cur."from"()
    inc rx1577_pos
    rx1577_cur."!cursor_from"(rx1577_pos)
    ge rx1577_pos, rx1577_eos, rxscan1578_done
  rxscan1578_scan:
    set_addr $I10, rxscan1578_loop
    rx1577_cur."!mark_push"(0, rx1577_pos, $I10)
  rxscan1578_done:
  alt1579_0:
    set_addr $I10, alt1579_1
    rx1577_cur."!mark_push"(0, rx1577_pos, $I10)
  # rx literal  "multi"
    add $I11, rx1577_pos, 5
    gt $I11, rx1577_eos, rx1577_fail
    sub $I11, rx1577_pos, rx1577_off
    substr $S10, rx1577_tgt, $I11, 5
    ne $S10, "multi", rx1577_fail
    add rx1577_pos, 5
    goto alt1579_end
  alt1579_1:
    set_addr $I10, alt1579_2
    rx1577_cur."!mark_push"(0, rx1577_pos, $I10)
  # rx literal  "proto"
    add $I11, rx1577_pos, 5
    gt $I11, rx1577_eos, rx1577_fail
    sub $I11, rx1577_pos, rx1577_off
    substr $S10, rx1577_tgt, $I11, 5
    ne $S10, "proto", rx1577_fail
    add rx1577_pos, 5
    goto alt1579_end
  alt1579_2:
  # rx literal  "only"
    add $I11, rx1577_pos, 4
    gt $I11, rx1577_eos, rx1577_fail
    sub $I11, rx1577_pos, rx1577_off
    substr $S10, rx1577_tgt, $I11, 4
    ne $S10, "only", rx1577_fail
    add rx1577_pos, 4
  alt1579_end:
  # rx pass
    rx1577_cur."!cursor_pass"(rx1577_pos, "")
    if_null rx1577_debug, debug_1073
    rx1577_cur."!cursor_debug"("PASS", "", " at pos=", rx1577_pos)
  debug_1073:
    .return (rx1577_cur)
  rx1577_restart:
    if_null rx1577_debug, debug_1074
    rx1577_cur."!cursor_debug"("NEXT", "")
  debug_1074:
  rx1577_fail:
    (rx1577_rep, rx1577_pos, $I10, $P10) = rx1577_cur."!mark_fail"(0)
    lt rx1577_pos, -1, rx1577_done
    eq rx1577_pos, -1, rx1577_fail
    jump $I10
  rx1577_done:
    rx1577_cur."!cursor_fail"()
    if_null rx1577_debug, debug_1075
    rx1577_cur."!cursor_debug"("FAIL", "")
  debug_1075:
    .return (rx1577_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1580"  :anon :subid("148_1307873304.82979") :method :outer("146_1307873304.82979")
.annotate 'line', 703
    .local string rx1582_tgt
    .local int rx1582_pos
    .local int rx1582_off
    .local int rx1582_eos
    .local int rx1582_rep
    .local pmc rx1582_cur
    .local pmc rx1582_debug
    (rx1582_cur, rx1582_pos, rx1582_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1582_cur
    .local pmc match
    .lex "$/", match
    length rx1582_eos, rx1582_tgt
    gt rx1582_pos, rx1582_eos, rx1582_done
    set rx1582_off, 0
    lt rx1582_pos, 2, rx1582_start
    sub rx1582_off, rx1582_pos, 1
    substr rx1582_tgt, rx1582_tgt, rx1582_off
  rx1582_start:
    eq $I10, 1, rx1582_restart
    if_null rx1582_debug, debug_1076
    rx1582_cur."!cursor_debug"("START", "")
  debug_1076:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1583_done
    goto rxscan1583_scan
  rxscan1583_loop:
    (rx1582_pos) = rx1582_cur."from"()
    inc rx1582_pos
    rx1582_cur."!cursor_from"(rx1582_pos)
    ge rx1582_pos, rx1582_eos, rxscan1583_done
  rxscan1583_scan:
    set_addr $I10, rxscan1583_loop
    rx1582_cur."!mark_push"(0, rx1582_pos, $I10)
  rxscan1583_done:
  # rx literal  "proto"
    add $I11, rx1582_pos, 5
    gt $I11, rx1582_eos, rx1582_fail
    sub $I11, rx1582_pos, rx1582_off
    substr $S10, rx1582_tgt, $I11, 5
    ne $S10, "proto", rx1582_fail
    add rx1582_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx1582_cur."!cursor_pos"(rx1582_pos)
    $P10 = rx1582_cur."ws"()
    unless $P10, rx1582_fail
    rx1582_pos = $P10."pos"()
  alt1584_0:
    set_addr $I10, alt1584_1
    rx1582_cur."!mark_push"(0, rx1582_pos, $I10)
  # rx literal  "regex"
    add $I11, rx1582_pos, 5
    gt $I11, rx1582_eos, rx1582_fail
    sub $I11, rx1582_pos, rx1582_off
    substr $S10, rx1582_tgt, $I11, 5
    ne $S10, "regex", rx1582_fail
    add rx1582_pos, 5
    goto alt1584_end
  alt1584_1:
    set_addr $I10, alt1584_2
    rx1582_cur."!mark_push"(0, rx1582_pos, $I10)
  # rx literal  "token"
    add $I11, rx1582_pos, 5
    gt $I11, rx1582_eos, rx1582_fail
    sub $I11, rx1582_pos, rx1582_off
    substr $S10, rx1582_tgt, $I11, 5
    ne $S10, "token", rx1582_fail
    add rx1582_pos, 5
    goto alt1584_end
  alt1584_2:
  # rx literal  "rule"
    add $I11, rx1582_pos, 4
    gt $I11, rx1582_eos, rx1582_fail
    sub $I11, rx1582_pos, rx1582_off
    substr $S10, rx1582_tgt, $I11, 4
    ne $S10, "rule", rx1582_fail
    add rx1582_pos, 4
  alt1584_end:
  # rx pass
    rx1582_cur."!cursor_pass"(rx1582_pos, "")
    if_null rx1582_debug, debug_1077
    rx1582_cur."!cursor_debug"("PASS", "", " at pos=", rx1582_pos)
  debug_1077:
    .return (rx1582_cur)
  rx1582_restart:
    if_null rx1582_debug, debug_1078
    rx1582_cur."!cursor_debug"("NEXT", "")
  debug_1078:
  rx1582_fail:
    (rx1582_rep, rx1582_pos, $I10, $P10) = rx1582_cur."!mark_fail"(0)
    lt rx1582_pos, -1, rx1582_done
    eq rx1582_pos, -1, rx1582_fail
    jump $I10
  rx1582_done:
    rx1582_cur."!cursor_fail"()
    if_null rx1582_debug, debug_1079
    rx1582_cur."!cursor_debug"("FAIL", "")
  debug_1079:
    .return (rx1582_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<multi_declarator>"  :subid("149_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    new $P1586, "ResizablePMCArray"
    push $P1586, ""
    .return ($P1586)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<regex_declarator>"  :subid("150_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx1588_tgt
    .local int rx1588_pos
    .local int rx1588_off
    .local int rx1588_eos
    .local int rx1588_rep
    .local pmc rx1588_cur
    .local pmc rx1588_debug
    (rx1588_cur, rx1588_pos, rx1588_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1588_cur
    .local pmc match
    .lex "$/", match
    length rx1588_eos, rx1588_tgt
    gt rx1588_pos, rx1588_eos, rx1588_done
    set rx1588_off, 0
    lt rx1588_pos, 2, rx1588_start
    sub rx1588_off, rx1588_pos, 1
    substr rx1588_tgt, rx1588_tgt, rx1588_off
  rx1588_start:
    eq $I10, 1, rx1588_restart
    if_null rx1588_debug, debug_1083
    rx1588_cur."!cursor_debug"("START", "term:sym<regex_declarator>")
  debug_1083:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1589_done
    goto rxscan1589_scan
  rxscan1589_loop:
    (rx1588_pos) = rx1588_cur."from"()
    inc rx1588_pos
    rx1588_cur."!cursor_from"(rx1588_pos)
    ge rx1588_pos, rx1588_eos, rxscan1589_done
  rxscan1589_scan:
    set_addr $I10, rxscan1589_loop
    rx1588_cur."!mark_push"(0, rx1588_pos, $I10)
  rxscan1589_done:
.annotate 'line', 706
  # rx subrule "regex_declarator" subtype=capture negate=
    rx1588_cur."!cursor_pos"(rx1588_pos)
    $P10 = rx1588_cur."regex_declarator"()
    unless $P10, rx1588_fail
    rx1588_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("regex_declarator")
    rx1588_pos = $P10."pos"()
  # rx pass
    rx1588_cur."!cursor_pass"(rx1588_pos, "term:sym<regex_declarator>")
    if_null rx1588_debug, debug_1084
    rx1588_cur."!cursor_debug"("PASS", "term:sym<regex_declarator>", " at pos=", rx1588_pos)
  debug_1084:
    .return (rx1588_cur)
  rx1588_restart:
.annotate 'line', 436
    if_null rx1588_debug, debug_1085
    rx1588_cur."!cursor_debug"("NEXT", "term:sym<regex_declarator>")
  debug_1085:
  rx1588_fail:
    (rx1588_rep, rx1588_pos, $I10, $P10) = rx1588_cur."!mark_fail"(0)
    lt rx1588_pos, -1, rx1588_done
    eq rx1588_pos, -1, rx1588_fail
    jump $I10
  rx1588_done:
    rx1588_cur."!cursor_fail"()
    if_null rx1588_debug, debug_1086
    rx1588_cur."!cursor_debug"("FAIL", "term:sym<regex_declarator>")
  debug_1086:
    .return (rx1588_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<regex_declarator>"  :subid("151_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P1591 = self."!PREFIX__!subrule"("regex_declarator", "")
    new $P1592, "ResizablePMCArray"
    push $P1592, $P1591
    .return ($P1592)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<statement_prefix>"  :subid("152_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx1594_tgt
    .local int rx1594_pos
    .local int rx1594_off
    .local int rx1594_eos
    .local int rx1594_rep
    .local pmc rx1594_cur
    .local pmc rx1594_debug
    (rx1594_cur, rx1594_pos, rx1594_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1594_cur
    .local pmc match
    .lex "$/", match
    length rx1594_eos, rx1594_tgt
    gt rx1594_pos, rx1594_eos, rx1594_done
    set rx1594_off, 0
    lt rx1594_pos, 2, rx1594_start
    sub rx1594_off, rx1594_pos, 1
    substr rx1594_tgt, rx1594_tgt, rx1594_off
  rx1594_start:
    eq $I10, 1, rx1594_restart
    if_null rx1594_debug, debug_1087
    rx1594_cur."!cursor_debug"("START", "term:sym<statement_prefix>")
  debug_1087:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1595_done
    goto rxscan1595_scan
  rxscan1595_loop:
    (rx1594_pos) = rx1594_cur."from"()
    inc rx1594_pos
    rx1594_cur."!cursor_from"(rx1594_pos)
    ge rx1594_pos, rx1594_eos, rxscan1595_done
  rxscan1595_scan:
    set_addr $I10, rxscan1595_loop
    rx1594_cur."!mark_push"(0, rx1594_pos, $I10)
  rxscan1595_done:
.annotate 'line', 707
  # rx subrule "statement_prefix" subtype=capture negate=
    rx1594_cur."!cursor_pos"(rx1594_pos)
    $P10 = rx1594_cur."statement_prefix"()
    unless $P10, rx1594_fail
    rx1594_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_prefix")
    rx1594_pos = $P10."pos"()
  # rx pass
    rx1594_cur."!cursor_pass"(rx1594_pos, "term:sym<statement_prefix>")
    if_null rx1594_debug, debug_1088
    rx1594_cur."!cursor_debug"("PASS", "term:sym<statement_prefix>", " at pos=", rx1594_pos)
  debug_1088:
    .return (rx1594_cur)
  rx1594_restart:
.annotate 'line', 436
    if_null rx1594_debug, debug_1089
    rx1594_cur."!cursor_debug"("NEXT", "term:sym<statement_prefix>")
  debug_1089:
  rx1594_fail:
    (rx1594_rep, rx1594_pos, $I10, $P10) = rx1594_cur."!mark_fail"(0)
    lt rx1594_pos, -1, rx1594_done
    eq rx1594_pos, -1, rx1594_fail
    jump $I10
  rx1594_done:
    rx1594_cur."!cursor_fail"()
    if_null rx1594_debug, debug_1090
    rx1594_cur."!cursor_debug"("FAIL", "term:sym<statement_prefix>")
  debug_1090:
    .return (rx1594_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<statement_prefix>"  :subid("153_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P1597 = self."!PREFIX__!subrule"("statement_prefix", "")
    new $P1598, "ResizablePMCArray"
    push $P1598, $P1597
    .return ($P1598)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<lambda>"  :subid("154_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx1600_tgt
    .local int rx1600_pos
    .local int rx1600_off
    .local int rx1600_eos
    .local int rx1600_rep
    .local pmc rx1600_cur
    .local pmc rx1600_debug
    (rx1600_cur, rx1600_pos, rx1600_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1600_cur
    .local pmc match
    .lex "$/", match
    length rx1600_eos, rx1600_tgt
    gt rx1600_pos, rx1600_eos, rx1600_done
    set rx1600_off, 0
    lt rx1600_pos, 2, rx1600_start
    sub rx1600_off, rx1600_pos, 1
    substr rx1600_tgt, rx1600_tgt, rx1600_off
  rx1600_start:
    eq $I10, 1, rx1600_restart
    if_null rx1600_debug, debug_1091
    rx1600_cur."!cursor_debug"("START", "term:sym<lambda>")
  debug_1091:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1601_done
    goto rxscan1601_scan
  rxscan1601_loop:
    (rx1600_pos) = rx1600_cur."from"()
    inc rx1600_pos
    rx1600_cur."!cursor_from"(rx1600_pos)
    ge rx1600_pos, rx1600_eos, rxscan1601_done
  rxscan1601_scan:
    set_addr $I10, rxscan1601_loop
    rx1600_cur."!mark_push"(0, rx1600_pos, $I10)
  rxscan1601_done:
.annotate 'line', 708
  # rx subrule "lambda" subtype=zerowidth negate=
    rx1600_cur."!cursor_pos"(rx1600_pos)
    $P10 = rx1600_cur."lambda"()
    unless $P10, rx1600_fail
  # rx subrule "pblock" subtype=capture negate=
    rx1600_cur."!cursor_pos"(rx1600_pos)
    $P10 = rx1600_cur."pblock"()
    unless $P10, rx1600_fail
    rx1600_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx1600_pos = $P10."pos"()
  # rx pass
    rx1600_cur."!cursor_pass"(rx1600_pos, "term:sym<lambda>")
    if_null rx1600_debug, debug_1092
    rx1600_cur."!cursor_debug"("PASS", "term:sym<lambda>", " at pos=", rx1600_pos)
  debug_1092:
    .return (rx1600_cur)
  rx1600_restart:
.annotate 'line', 436
    if_null rx1600_debug, debug_1093
    rx1600_cur."!cursor_debug"("NEXT", "term:sym<lambda>")
  debug_1093:
  rx1600_fail:
    (rx1600_rep, rx1600_pos, $I10, $P10) = rx1600_cur."!mark_fail"(0)
    lt rx1600_pos, -1, rx1600_done
    eq rx1600_pos, -1, rx1600_fail
    jump $I10
  rx1600_done:
    rx1600_cur."!cursor_fail"()
    if_null rx1600_debug, debug_1094
    rx1600_cur."!cursor_debug"("FAIL", "term:sym<lambda>")
  debug_1094:
    .return (rx1600_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<lambda>"  :subid("155_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    new $P1603, "ResizablePMCArray"
    push $P1603, ""
    .return ($P1603)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "fatarrow"  :subid("156_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx1605_tgt
    .local int rx1605_pos
    .local int rx1605_off
    .local int rx1605_eos
    .local int rx1605_rep
    .local pmc rx1605_cur
    .local pmc rx1605_debug
    (rx1605_cur, rx1605_pos, rx1605_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1605_cur
    .local pmc match
    .lex "$/", match
    length rx1605_eos, rx1605_tgt
    gt rx1605_pos, rx1605_eos, rx1605_done
    set rx1605_off, 0
    lt rx1605_pos, 2, rx1605_start
    sub rx1605_off, rx1605_pos, 1
    substr rx1605_tgt, rx1605_tgt, rx1605_off
  rx1605_start:
    eq $I10, 1, rx1605_restart
    if_null rx1605_debug, debug_1095
    rx1605_cur."!cursor_debug"("START", "fatarrow")
  debug_1095:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1606_done
    goto rxscan1606_scan
  rxscan1606_loop:
    (rx1605_pos) = rx1605_cur."from"()
    inc rx1605_pos
    rx1605_cur."!cursor_from"(rx1605_pos)
    ge rx1605_pos, rx1605_eos, rxscan1606_done
  rxscan1606_scan:
    set_addr $I10, rxscan1606_loop
    rx1605_cur."!mark_push"(0, rx1605_pos, $I10)
  rxscan1606_done:
.annotate 'line', 711
  # rx subrule "identifier" subtype=capture negate=
    rx1605_cur."!cursor_pos"(rx1605_pos)
    $P10 = rx1605_cur."identifier"()
    unless $P10, rx1605_fail
    rx1605_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("key")
    rx1605_pos = $P10."pos"()
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1605_pos, rx1605_off
    set rx1605_rep, 0
    sub $I12, rx1605_eos, rx1605_pos
  rxenumcharlistq1607_loop:
    le $I12, 0, rxenumcharlistq1607_done
    substr $S10, rx1605_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1607_done
    inc rx1605_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1607_loop
  rxenumcharlistq1607_done:
    add rx1605_pos, rx1605_pos, rx1605_rep
  # rx literal  "=>"
    add $I11, rx1605_pos, 2
    gt $I11, rx1605_eos, rx1605_fail
    sub $I11, rx1605_pos, rx1605_off
    substr $S10, rx1605_tgt, $I11, 2
    ne $S10, "=>", rx1605_fail
    add rx1605_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx1605_cur."!cursor_pos"(rx1605_pos)
    $P10 = rx1605_cur."ws"()
    unless $P10, rx1605_fail
    rx1605_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1605_cur."!cursor_pos"(rx1605_pos)
    $P10 = rx1605_cur."EXPR"("i=")
    unless $P10, rx1605_fail
    rx1605_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("val")
    rx1605_pos = $P10."pos"()
.annotate 'line', 710
  # rx pass
    rx1605_cur."!cursor_pass"(rx1605_pos, "fatarrow")
    if_null rx1605_debug, debug_1096
    rx1605_cur."!cursor_debug"("PASS", "fatarrow", " at pos=", rx1605_pos)
  debug_1096:
    .return (rx1605_cur)
  rx1605_restart:
.annotate 'line', 436
    if_null rx1605_debug, debug_1097
    rx1605_cur."!cursor_debug"("NEXT", "fatarrow")
  debug_1097:
  rx1605_fail:
    (rx1605_rep, rx1605_pos, $I10, $P10) = rx1605_cur."!mark_fail"(0)
    lt rx1605_pos, -1, rx1605_done
    eq rx1605_pos, -1, rx1605_fail
    jump $I10
  rx1605_done:
    rx1605_cur."!cursor_fail"()
    if_null rx1605_debug, debug_1098
    rx1605_cur."!cursor_debug"("FAIL", "fatarrow")
  debug_1098:
    .return (rx1605_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__fatarrow"  :subid("157_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P1609 = self."!PREFIX__!subrule"("identifier", "")
    new $P1610, "ResizablePMCArray"
    push $P1610, $P1609
    .return ($P1610)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "colonpair"  :subid("158_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx1612_tgt
    .local int rx1612_pos
    .local int rx1612_off
    .local int rx1612_eos
    .local int rx1612_rep
    .local pmc rx1612_cur
    .local pmc rx1612_debug
    (rx1612_cur, rx1612_pos, rx1612_tgt, $I10) = self."!cursor_start"()
    rx1612_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx1612_cur
    .local pmc match
    .lex "$/", match
    length rx1612_eos, rx1612_tgt
    gt rx1612_pos, rx1612_eos, rx1612_done
    set rx1612_off, 0
    lt rx1612_pos, 2, rx1612_start
    sub rx1612_off, rx1612_pos, 1
    substr rx1612_tgt, rx1612_tgt, rx1612_off
  rx1612_start:
    eq $I10, 1, rx1612_restart
    if_null rx1612_debug, debug_1099
    rx1612_cur."!cursor_debug"("START", "colonpair")
  debug_1099:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1613_done
    goto rxscan1613_scan
  rxscan1613_loop:
    (rx1612_pos) = rx1612_cur."from"()
    inc rx1612_pos
    rx1612_cur."!cursor_from"(rx1612_pos)
    ge rx1612_pos, rx1612_eos, rxscan1613_done
  rxscan1613_scan:
    set_addr $I10, rxscan1613_loop
    rx1612_cur."!mark_push"(0, rx1612_pos, $I10)
  rxscan1613_done:
.annotate 'line', 715
  # rx literal  ":"
    add $I11, rx1612_pos, 1
    gt $I11, rx1612_eos, rx1612_fail
    sub $I11, rx1612_pos, rx1612_off
    ord $I11, rx1612_tgt, $I11
    ne $I11, 58, rx1612_fail
    add rx1612_pos, 1
  alt1614_0:
.annotate 'line', 716
    set_addr $I10, alt1614_1
    rx1612_cur."!mark_push"(0, rx1612_pos, $I10)
.annotate 'line', 717
  # rx subcapture "not"
    set_addr $I10, rxcap_1615_fail
    rx1612_cur."!mark_push"(0, rx1612_pos, $I10)
  # rx literal  "!"
    add $I11, rx1612_pos, 1
    gt $I11, rx1612_eos, rx1612_fail
    sub $I11, rx1612_pos, rx1612_off
    ord $I11, rx1612_tgt, $I11
    ne $I11, 33, rx1612_fail
    add rx1612_pos, 1
    set_addr $I10, rxcap_1615_fail
    ($I12, $I11) = rx1612_cur."!mark_peek"($I10)
    rx1612_cur."!cursor_pos"($I11)
    ($P10) = rx1612_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1612_pos, "")
    rx1612_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("not")
    goto rxcap_1615_done
  rxcap_1615_fail:
    goto rx1612_fail
  rxcap_1615_done:
  # rx subrule "identifier" subtype=capture negate=
    rx1612_cur."!cursor_pos"(rx1612_pos)
    $P10 = rx1612_cur."identifier"()
    unless $P10, rx1612_fail
    rx1612_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx1612_pos = $P10."pos"()
    goto alt1614_end
  alt1614_1:
    set_addr $I10, alt1614_2
    rx1612_cur."!mark_push"(0, rx1612_pos, $I10)
.annotate 'line', 718
  # rx subrule "identifier" subtype=capture negate=
    rx1612_cur."!cursor_pos"(rx1612_pos)
    $P10 = rx1612_cur."identifier"()
    unless $P10, rx1612_fail
    rx1612_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx1612_pos = $P10."pos"()
  # rx rxquantr1616 ** 0..1
    set_addr $I10, rxquantr1616_done
    rx1612_cur."!mark_push"(0, rx1612_pos, $I10)
  rxquantr1616_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx1612_cur."!cursor_pos"(rx1612_pos)
    $P10 = rx1612_cur."circumfix"()
    unless $P10, rx1612_fail
    goto rxsubrule1617_pass
  rxsubrule1617_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1612_fail
  rxsubrule1617_pass:
    set_addr $I10, rxsubrule1617_back
    rx1612_cur."!mark_push"(0, rx1612_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx1612_pos = $P10."pos"()
    set_addr $I10, rxquantr1616_done
    (rx1612_rep) = rx1612_cur."!mark_commit"($I10)
  rxquantr1616_done:
    goto alt1614_end
  alt1614_2:
.annotate 'line', 719
  # rx subrule "circumfix" subtype=capture negate=
    rx1612_cur."!cursor_pos"(rx1612_pos)
    $P10 = rx1612_cur."circumfix"()
    unless $P10, rx1612_fail
    rx1612_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("circumfix")
    rx1612_pos = $P10."pos"()
  alt1614_end:
.annotate 'line', 714
  # rx pass
    rx1612_cur."!cursor_pass"(rx1612_pos, "colonpair")
    if_null rx1612_debug, debug_1100
    rx1612_cur."!cursor_debug"("PASS", "colonpair", " at pos=", rx1612_pos)
  debug_1100:
    .return (rx1612_cur)
  rx1612_restart:
.annotate 'line', 436
    if_null rx1612_debug, debug_1101
    rx1612_cur."!cursor_debug"("NEXT", "colonpair")
  debug_1101:
  rx1612_fail:
    (rx1612_rep, rx1612_pos, $I10, $P10) = rx1612_cur."!mark_fail"(0)
    lt rx1612_pos, -1, rx1612_done
    eq rx1612_pos, -1, rx1612_fail
    jump $I10
  rx1612_done:
    rx1612_cur."!cursor_fail"()
    if_null rx1612_debug, debug_1102
    rx1612_cur."!cursor_debug"("FAIL", "colonpair")
  debug_1102:
    .return (rx1612_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__colonpair"  :subid("159_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P1619 = self."!PREFIX__!subrule"("circumfix", ":")
    $P1620 = self."!PREFIX__!subrule"("identifier", ":")
    $P1621 = self."!PREFIX__!subrule"("identifier", ":!")
    new $P1622, "ResizablePMCArray"
    push $P1622, $P1619
    push $P1622, $P1620
    push $P1622, $P1621
    .return ($P1622)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable"  :subid("160_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx1624_tgt
    .local int rx1624_pos
    .local int rx1624_off
    .local int rx1624_eos
    .local int rx1624_rep
    .local pmc rx1624_cur
    .local pmc rx1624_debug
    (rx1624_cur, rx1624_pos, rx1624_tgt, $I10) = self."!cursor_start"()
    rx1624_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx1624_cur
    .local pmc match
    .lex "$/", match
    length rx1624_eos, rx1624_tgt
    gt rx1624_pos, rx1624_eos, rx1624_done
    set rx1624_off, 0
    lt rx1624_pos, 2, rx1624_start
    sub rx1624_off, rx1624_pos, 1
    substr rx1624_tgt, rx1624_tgt, rx1624_off
  rx1624_start:
    eq $I10, 1, rx1624_restart
    if_null rx1624_debug, debug_1103
    rx1624_cur."!cursor_debug"("START", "variable")
  debug_1103:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1625_done
    goto rxscan1625_scan
  rxscan1625_loop:
    (rx1624_pos) = rx1624_cur."from"()
    inc rx1624_pos
    rx1624_cur."!cursor_from"(rx1624_pos)
    ge rx1624_pos, rx1624_eos, rxscan1625_done
  rxscan1625_scan:
    set_addr $I10, rxscan1625_loop
    rx1624_cur."!mark_push"(0, rx1624_pos, $I10)
  rxscan1625_done:
  alt1626_0:
.annotate 'line', 723
    set_addr $I10, alt1626_1
    rx1624_cur."!mark_push"(0, rx1624_pos, $I10)
.annotate 'line', 724
  # rx subrule "sigil" subtype=capture negate=
    rx1624_cur."!cursor_pos"(rx1624_pos)
    $P10 = rx1624_cur."sigil"()
    unless $P10, rx1624_fail
    rx1624_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1624_pos = $P10."pos"()
  # rx rxquantr1627 ** 0..1
    set_addr $I10, rxquantr1627_done
    rx1624_cur."!mark_push"(0, rx1624_pos, $I10)
  rxquantr1627_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx1624_cur."!cursor_pos"(rx1624_pos)
    $P10 = rx1624_cur."twigil"()
    unless $P10, rx1624_fail
    goto rxsubrule1628_pass
  rxsubrule1628_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1624_fail
  rxsubrule1628_pass:
    set_addr $I10, rxsubrule1628_back
    rx1624_cur."!mark_push"(0, rx1624_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx1624_pos = $P10."pos"()
    set_addr $I10, rxquantr1627_done
    (rx1624_rep) = rx1624_cur."!mark_commit"($I10)
  rxquantr1627_done:
  # rx subrule "name" subtype=capture negate=
    rx1624_cur."!cursor_pos"(rx1624_pos)
    $P10 = rx1624_cur."name"()
    unless $P10, rx1624_fail
    rx1624_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    rx1624_pos = $P10."pos"()
    goto alt1626_end
  alt1626_1:
    set_addr $I10, alt1626_2
    rx1624_cur."!mark_push"(0, rx1624_pos, $I10)
.annotate 'line', 725
  # rx subrule "sigil" subtype=capture negate=
    rx1624_cur."!cursor_pos"(rx1624_pos)
    $P10 = rx1624_cur."sigil"()
    unless $P10, rx1624_fail
    rx1624_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1624_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1624_pos, rx1624_off
    substr $S10, rx1624_tgt, $I10, 1
    index $I11, "<[", $S10
    lt $I11, 0, rx1624_fail
  # rx subrule "postcircumfix" subtype=capture negate=
    rx1624_cur."!cursor_pos"(rx1624_pos)
    $P10 = rx1624_cur."postcircumfix"()
    unless $P10, rx1624_fail
    rx1624_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("postcircumfix")
    rx1624_pos = $P10."pos"()
    goto alt1626_end
  alt1626_2:
.annotate 'line', 726
  # rx subcapture "sigil"
    set_addr $I10, rxcap_1629_fail
    rx1624_cur."!mark_push"(0, rx1624_pos, $I10)
  # rx literal  "$"
    add $I11, rx1624_pos, 1
    gt $I11, rx1624_eos, rx1624_fail
    sub $I11, rx1624_pos, rx1624_off
    ord $I11, rx1624_tgt, $I11
    ne $I11, 36, rx1624_fail
    add rx1624_pos, 1
    set_addr $I10, rxcap_1629_fail
    ($I12, $I11) = rx1624_cur."!mark_peek"($I10)
    rx1624_cur."!cursor_pos"($I11)
    ($P10) = rx1624_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1624_pos, "")
    rx1624_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_1629_done
  rxcap_1629_fail:
    goto rx1624_fail
  rxcap_1629_done:
  # rx subcapture "desigilname"
    set_addr $I10, rxcap_1630_fail
    rx1624_cur."!mark_push"(0, rx1624_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1624_pos, rx1624_eos, rx1624_fail
    sub $I10, rx1624_pos, rx1624_off
    substr $S10, rx1624_tgt, $I10, 1
    index $I11, "/_!", $S10
    lt $I11, 0, rx1624_fail
    inc rx1624_pos
    set_addr $I10, rxcap_1630_fail
    ($I12, $I11) = rx1624_cur."!mark_peek"($I10)
    rx1624_cur."!cursor_pos"($I11)
    ($P10) = rx1624_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1624_pos, "")
    rx1624_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    goto rxcap_1630_done
  rxcap_1630_fail:
    goto rx1624_fail
  rxcap_1630_done:
  alt1626_end:
.annotate 'line', 723
  # rx pass
    rx1624_cur."!cursor_pass"(rx1624_pos, "variable")
    if_null rx1624_debug, debug_1104
    rx1624_cur."!cursor_debug"("PASS", "variable", " at pos=", rx1624_pos)
  debug_1104:
    .return (rx1624_cur)
  rx1624_restart:
.annotate 'line', 436
    if_null rx1624_debug, debug_1105
    rx1624_cur."!cursor_debug"("NEXT", "variable")
  debug_1105:
  rx1624_fail:
    (rx1624_rep, rx1624_pos, $I10, $P10) = rx1624_cur."!mark_fail"(0)
    lt rx1624_pos, -1, rx1624_done
    eq rx1624_pos, -1, rx1624_fail
    jump $I10
  rx1624_done:
    rx1624_cur."!cursor_fail"()
    if_null rx1624_debug, debug_1106
    rx1624_cur."!cursor_debug"("FAIL", "variable")
  debug_1106:
    .return (rx1624_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable"  :subid("161_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P1632 = self."!PREFIX__!subrule"("sigil", "")
    $P1633 = self."!PREFIX__!subrule"("sigil", "")
    new $P1634, "ResizablePMCArray"
    push $P1634, "/"
    push $P1634, "_"
    push $P1634, "!"
    push $P1634, $P1632
    push $P1634, $P1633
    .return ($P1634)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "sigil"  :subid("162_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx1636_tgt
    .local int rx1636_pos
    .local int rx1636_off
    .local int rx1636_eos
    .local int rx1636_rep
    .local pmc rx1636_cur
    .local pmc rx1636_debug
    (rx1636_cur, rx1636_pos, rx1636_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1636_cur
    .local pmc match
    .lex "$/", match
    length rx1636_eos, rx1636_tgt
    gt rx1636_pos, rx1636_eos, rx1636_done
    set rx1636_off, 0
    lt rx1636_pos, 2, rx1636_start
    sub rx1636_off, rx1636_pos, 1
    substr rx1636_tgt, rx1636_tgt, rx1636_off
  rx1636_start:
    eq $I10, 1, rx1636_restart
    if_null rx1636_debug, debug_1107
    rx1636_cur."!cursor_debug"("START", "sigil")
  debug_1107:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1637_done
    goto rxscan1637_scan
  rxscan1637_loop:
    (rx1636_pos) = rx1636_cur."from"()
    inc rx1636_pos
    rx1636_cur."!cursor_from"(rx1636_pos)
    ge rx1636_pos, rx1636_eos, rxscan1637_done
  rxscan1637_scan:
    set_addr $I10, rxscan1637_loop
    rx1636_cur."!mark_push"(0, rx1636_pos, $I10)
  rxscan1637_done:
.annotate 'line', 729
  # rx enumcharlist negate=0 
    ge rx1636_pos, rx1636_eos, rx1636_fail
    sub $I10, rx1636_pos, rx1636_off
    substr $S10, rx1636_tgt, $I10, 1
    index $I11, "$@%&", $S10
    lt $I11, 0, rx1636_fail
    inc rx1636_pos
  # rx pass
    rx1636_cur."!cursor_pass"(rx1636_pos, "sigil")
    if_null rx1636_debug, debug_1108
    rx1636_cur."!cursor_debug"("PASS", "sigil", " at pos=", rx1636_pos)
  debug_1108:
    .return (rx1636_cur)
  rx1636_restart:
.annotate 'line', 436
    if_null rx1636_debug, debug_1109
    rx1636_cur."!cursor_debug"("NEXT", "sigil")
  debug_1109:
  rx1636_fail:
    (rx1636_rep, rx1636_pos, $I10, $P10) = rx1636_cur."!mark_fail"(0)
    lt rx1636_pos, -1, rx1636_done
    eq rx1636_pos, -1, rx1636_fail
    jump $I10
  rx1636_done:
    rx1636_cur."!cursor_fail"()
    if_null rx1636_debug, debug_1110
    rx1636_cur."!cursor_debug"("FAIL", "sigil")
  debug_1110:
    .return (rx1636_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__sigil"  :subid("163_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    new $P1639, "ResizablePMCArray"
    push $P1639, "$"
    push $P1639, "@"
    push $P1639, "%"
    push $P1639, "&"
    .return ($P1639)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "twigil"  :subid("164_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx1641_tgt
    .local int rx1641_pos
    .local int rx1641_off
    .local int rx1641_eos
    .local int rx1641_rep
    .local pmc rx1641_cur
    .local pmc rx1641_debug
    (rx1641_cur, rx1641_pos, rx1641_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1641_cur
    .local pmc match
    .lex "$/", match
    length rx1641_eos, rx1641_tgt
    gt rx1641_pos, rx1641_eos, rx1641_done
    set rx1641_off, 0
    lt rx1641_pos, 2, rx1641_start
    sub rx1641_off, rx1641_pos, 1
    substr rx1641_tgt, rx1641_tgt, rx1641_off
  rx1641_start:
    eq $I10, 1, rx1641_restart
    if_null rx1641_debug, debug_1111
    rx1641_cur."!cursor_debug"("START", "twigil")
  debug_1111:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1642_done
    goto rxscan1642_scan
  rxscan1642_loop:
    (rx1641_pos) = rx1641_cur."from"()
    inc rx1641_pos
    rx1641_cur."!cursor_from"(rx1641_pos)
    ge rx1641_pos, rx1641_eos, rxscan1642_done
  rxscan1642_scan:
    set_addr $I10, rxscan1642_loop
    rx1641_cur."!mark_push"(0, rx1641_pos, $I10)
  rxscan1642_done:
.annotate 'line', 731
  # rx enumcharlist negate=0 
    ge rx1641_pos, rx1641_eos, rx1641_fail
    sub $I10, rx1641_pos, rx1641_off
    substr $S10, rx1641_tgt, $I10, 1
    index $I11, "*!?", $S10
    lt $I11, 0, rx1641_fail
    inc rx1641_pos
  # rx pass
    rx1641_cur."!cursor_pass"(rx1641_pos, "twigil")
    if_null rx1641_debug, debug_1112
    rx1641_cur."!cursor_debug"("PASS", "twigil", " at pos=", rx1641_pos)
  debug_1112:
    .return (rx1641_cur)
  rx1641_restart:
.annotate 'line', 436
    if_null rx1641_debug, debug_1113
    rx1641_cur."!cursor_debug"("NEXT", "twigil")
  debug_1113:
  rx1641_fail:
    (rx1641_rep, rx1641_pos, $I10, $P10) = rx1641_cur."!mark_fail"(0)
    lt rx1641_pos, -1, rx1641_done
    eq rx1641_pos, -1, rx1641_fail
    jump $I10
  rx1641_done:
    rx1641_cur."!cursor_fail"()
    if_null rx1641_debug, debug_1114
    rx1641_cur."!cursor_debug"("FAIL", "twigil")
  debug_1114:
    .return (rx1641_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__twigil"  :subid("165_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    new $P1644, "ResizablePMCArray"
    push $P1644, "*"
    push $P1644, "!"
    push $P1644, "?"
    .return ($P1644)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator"  :subid("166_1307873304.82979")
    .param pmc param_1646
.annotate 'line', 733
    .lex "self", param_1646
    $P1647 = param_1646."!protoregex"("package_declarator")
    .return ($P1647)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator"  :subid("167_1307873304.82979")
    .param pmc param_1649
.annotate 'line', 733
    .lex "self", param_1649
    $P1650 = param_1649."!PREFIX__!protoregex"("package_declarator")
    .return ($P1650)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<module>"  :subid("168_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 735
    new $P1652, "Undef"
    .lex "$*OUTERPACKAGE", $P1652
.annotate 'line', 736
    new $P1653, "Undef"
    .lex "$*PKGDECL", $P1653
.annotate 'line', 436
    .local string rx1654_tgt
    .local int rx1654_pos
    .local int rx1654_off
    .local int rx1654_eos
    .local int rx1654_rep
    .local pmc rx1654_cur
    .local pmc rx1654_debug
    (rx1654_cur, rx1654_pos, rx1654_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1654_cur
    .local pmc match
    .lex "$/", match
    length rx1654_eos, rx1654_tgt
    gt rx1654_pos, rx1654_eos, rx1654_done
    set rx1654_off, 0
    lt rx1654_pos, 2, rx1654_start
    sub rx1654_off, rx1654_pos, 1
    substr rx1654_tgt, rx1654_tgt, rx1654_off
  rx1654_start:
    eq $I10, 1, rx1654_restart
    if_null rx1654_debug, debug_1115
    rx1654_cur."!cursor_debug"("START", "package_declarator:sym<module>")
  debug_1115:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1655_done
    goto rxscan1655_scan
  rxscan1655_loop:
    (rx1654_pos) = rx1654_cur."from"()
    inc rx1654_pos
    rx1654_cur."!cursor_from"(rx1654_pos)
    ge rx1654_pos, rx1654_eos, rxscan1655_done
  rxscan1655_scan:
    set_addr $I10, rxscan1655_loop
    rx1654_cur."!mark_push"(0, rx1654_pos, $I10)
  rxscan1655_done:
.annotate 'line', 735
    rx1654_cur."!cursor_pos"(rx1654_pos)
    find_dynamic_lex $P1658, "$*PACKAGE"
    unless_null $P1658, vivify_1116
    get_hll_global $P1656, "GLOBAL"
    get_who $P1657, $P1656
    set $P1658, $P1657["$PACKAGE"]
    unless_null $P1658, vivify_1117
    die "Contextual $*PACKAGE not found"
  vivify_1117:
  vivify_1116:
    store_lex "$*OUTERPACKAGE", $P1658
.annotate 'line', 736
    rx1654_cur."!cursor_pos"(rx1654_pos)
    new $P1659, "String"
    assign $P1659, "module"
    store_lex "$*PKGDECL", $P1659
.annotate 'line', 737
  # rx subcapture "sym"
    set_addr $I10, rxcap_1660_fail
    rx1654_cur."!mark_push"(0, rx1654_pos, $I10)
  # rx literal  "module"
    add $I11, rx1654_pos, 6
    gt $I11, rx1654_eos, rx1654_fail
    sub $I11, rx1654_pos, rx1654_off
    substr $S10, rx1654_tgt, $I11, 6
    ne $S10, "module", rx1654_fail
    add rx1654_pos, 6
    set_addr $I10, rxcap_1660_fail
    ($I12, $I11) = rx1654_cur."!mark_peek"($I10)
    rx1654_cur."!cursor_pos"($I11)
    ($P10) = rx1654_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1654_pos, "")
    rx1654_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1660_done
  rxcap_1660_fail:
    goto rx1654_fail
  rxcap_1660_done:
  # rx subrule "package_def" subtype=capture negate=
    rx1654_cur."!cursor_pos"(rx1654_pos)
    $P10 = rx1654_cur."package_def"()
    unless $P10, rx1654_fail
    rx1654_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx1654_pos = $P10."pos"()
.annotate 'line', 734
  # rx pass
    rx1654_cur."!cursor_pass"(rx1654_pos, "package_declarator:sym<module>")
    if_null rx1654_debug, debug_1118
    rx1654_cur."!cursor_debug"("PASS", "package_declarator:sym<module>", " at pos=", rx1654_pos)
  debug_1118:
    .return (rx1654_cur)
  rx1654_restart:
.annotate 'line', 436
    if_null rx1654_debug, debug_1119
    rx1654_cur."!cursor_debug"("NEXT", "package_declarator:sym<module>")
  debug_1119:
  rx1654_fail:
    (rx1654_rep, rx1654_pos, $I10, $P10) = rx1654_cur."!mark_fail"(0)
    lt rx1654_pos, -1, rx1654_done
    eq rx1654_pos, -1, rx1654_fail
    jump $I10
  rx1654_done:
    rx1654_cur."!cursor_fail"()
    if_null rx1654_debug, debug_1120
    rx1654_cur."!cursor_debug"("FAIL", "package_declarator:sym<module>")
  debug_1120:
    .return (rx1654_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<module>"  :subid("169_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P1662 = self."!PREFIX__!subrule"("package_def", "module")
    new $P1663, "ResizablePMCArray"
    push $P1663, $P1662
    .return ($P1663)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<knowhow>"  :subid("170_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 740
    new $P1665, "Undef"
    .lex "$*OUTERPACKAGE", $P1665
.annotate 'line', 741
    new $P1666, "Undef"
    .lex "$*PKGDECL", $P1666
.annotate 'line', 436
    .local string rx1667_tgt
    .local int rx1667_pos
    .local int rx1667_off
    .local int rx1667_eos
    .local int rx1667_rep
    .local pmc rx1667_cur
    .local pmc rx1667_debug
    (rx1667_cur, rx1667_pos, rx1667_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1667_cur
    .local pmc match
    .lex "$/", match
    length rx1667_eos, rx1667_tgt
    gt rx1667_pos, rx1667_eos, rx1667_done
    set rx1667_off, 0
    lt rx1667_pos, 2, rx1667_start
    sub rx1667_off, rx1667_pos, 1
    substr rx1667_tgt, rx1667_tgt, rx1667_off
  rx1667_start:
    eq $I10, 1, rx1667_restart
    if_null rx1667_debug, debug_1121
    rx1667_cur."!cursor_debug"("START", "package_declarator:sym<knowhow>")
  debug_1121:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1668_done
    goto rxscan1668_scan
  rxscan1668_loop:
    (rx1667_pos) = rx1667_cur."from"()
    inc rx1667_pos
    rx1667_cur."!cursor_from"(rx1667_pos)
    ge rx1667_pos, rx1667_eos, rxscan1668_done
  rxscan1668_scan:
    set_addr $I10, rxscan1668_loop
    rx1667_cur."!mark_push"(0, rx1667_pos, $I10)
  rxscan1668_done:
.annotate 'line', 740
    rx1667_cur."!cursor_pos"(rx1667_pos)
    find_dynamic_lex $P1671, "$*PACKAGE"
    unless_null $P1671, vivify_1122
    get_hll_global $P1669, "GLOBAL"
    get_who $P1670, $P1669
    set $P1671, $P1670["$PACKAGE"]
    unless_null $P1671, vivify_1123
    die "Contextual $*PACKAGE not found"
  vivify_1123:
  vivify_1122:
    store_lex "$*OUTERPACKAGE", $P1671
.annotate 'line', 741
    rx1667_cur."!cursor_pos"(rx1667_pos)
    new $P1672, "String"
    assign $P1672, "knowhow"
    store_lex "$*PKGDECL", $P1672
.annotate 'line', 742
  # rx subcapture "sym"
    set_addr $I10, rxcap_1673_fail
    rx1667_cur."!mark_push"(0, rx1667_pos, $I10)
  # rx literal  "knowhow"
    add $I11, rx1667_pos, 7
    gt $I11, rx1667_eos, rx1667_fail
    sub $I11, rx1667_pos, rx1667_off
    substr $S10, rx1667_tgt, $I11, 7
    ne $S10, "knowhow", rx1667_fail
    add rx1667_pos, 7
    set_addr $I10, rxcap_1673_fail
    ($I12, $I11) = rx1667_cur."!mark_peek"($I10)
    rx1667_cur."!cursor_pos"($I11)
    ($P10) = rx1667_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1667_pos, "")
    rx1667_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1673_done
  rxcap_1673_fail:
    goto rx1667_fail
  rxcap_1673_done:
  # rx subrule "package_def" subtype=capture negate=
    rx1667_cur."!cursor_pos"(rx1667_pos)
    $P10 = rx1667_cur."package_def"()
    unless $P10, rx1667_fail
    rx1667_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx1667_pos = $P10."pos"()
.annotate 'line', 739
  # rx pass
    rx1667_cur."!cursor_pass"(rx1667_pos, "package_declarator:sym<knowhow>")
    if_null rx1667_debug, debug_1124
    rx1667_cur."!cursor_debug"("PASS", "package_declarator:sym<knowhow>", " at pos=", rx1667_pos)
  debug_1124:
    .return (rx1667_cur)
  rx1667_restart:
.annotate 'line', 436
    if_null rx1667_debug, debug_1125
    rx1667_cur."!cursor_debug"("NEXT", "package_declarator:sym<knowhow>")
  debug_1125:
  rx1667_fail:
    (rx1667_rep, rx1667_pos, $I10, $P10) = rx1667_cur."!mark_fail"(0)
    lt rx1667_pos, -1, rx1667_done
    eq rx1667_pos, -1, rx1667_fail
    jump $I10
  rx1667_done:
    rx1667_cur."!cursor_fail"()
    if_null rx1667_debug, debug_1126
    rx1667_cur."!cursor_debug"("FAIL", "package_declarator:sym<knowhow>")
  debug_1126:
    .return (rx1667_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<knowhow>"  :subid("171_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P1675 = self."!PREFIX__!subrule"("package_def", "knowhow")
    new $P1676, "ResizablePMCArray"
    push $P1676, $P1675
    .return ($P1676)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<class>"  :subid("172_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 745
    new $P1678, "Undef"
    .lex "$*OUTERPACKAGE", $P1678
.annotate 'line', 746
    new $P1679, "Undef"
    .lex "$*PKGDECL", $P1679
.annotate 'line', 436
    .local string rx1680_tgt
    .local int rx1680_pos
    .local int rx1680_off
    .local int rx1680_eos
    .local int rx1680_rep
    .local pmc rx1680_cur
    .local pmc rx1680_debug
    (rx1680_cur, rx1680_pos, rx1680_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1680_cur
    .local pmc match
    .lex "$/", match
    length rx1680_eos, rx1680_tgt
    gt rx1680_pos, rx1680_eos, rx1680_done
    set rx1680_off, 0
    lt rx1680_pos, 2, rx1680_start
    sub rx1680_off, rx1680_pos, 1
    substr rx1680_tgt, rx1680_tgt, rx1680_off
  rx1680_start:
    eq $I10, 1, rx1680_restart
    if_null rx1680_debug, debug_1127
    rx1680_cur."!cursor_debug"("START", "package_declarator:sym<class>")
  debug_1127:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1681_done
    goto rxscan1681_scan
  rxscan1681_loop:
    (rx1680_pos) = rx1680_cur."from"()
    inc rx1680_pos
    rx1680_cur."!cursor_from"(rx1680_pos)
    ge rx1680_pos, rx1680_eos, rxscan1681_done
  rxscan1681_scan:
    set_addr $I10, rxscan1681_loop
    rx1680_cur."!mark_push"(0, rx1680_pos, $I10)
  rxscan1681_done:
.annotate 'line', 745
    rx1680_cur."!cursor_pos"(rx1680_pos)
    find_dynamic_lex $P1684, "$*PACKAGE"
    unless_null $P1684, vivify_1128
    get_hll_global $P1682, "GLOBAL"
    get_who $P1683, $P1682
    set $P1684, $P1683["$PACKAGE"]
    unless_null $P1684, vivify_1129
    die "Contextual $*PACKAGE not found"
  vivify_1129:
  vivify_1128:
    store_lex "$*OUTERPACKAGE", $P1684
.annotate 'line', 746
    rx1680_cur."!cursor_pos"(rx1680_pos)
    new $P1685, "String"
    assign $P1685, "class"
    store_lex "$*PKGDECL", $P1685
.annotate 'line', 747
  # rx subcapture "sym"
    set_addr $I10, rxcap_1686_fail
    rx1680_cur."!mark_push"(0, rx1680_pos, $I10)
  # rx literal  "class"
    add $I11, rx1680_pos, 5
    gt $I11, rx1680_eos, rx1680_fail
    sub $I11, rx1680_pos, rx1680_off
    substr $S10, rx1680_tgt, $I11, 5
    ne $S10, "class", rx1680_fail
    add rx1680_pos, 5
    set_addr $I10, rxcap_1686_fail
    ($I12, $I11) = rx1680_cur."!mark_peek"($I10)
    rx1680_cur."!cursor_pos"($I11)
    ($P10) = rx1680_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1680_pos, "")
    rx1680_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1686_done
  rxcap_1686_fail:
    goto rx1680_fail
  rxcap_1686_done:
  # rx subrule "package_def" subtype=capture negate=
    rx1680_cur."!cursor_pos"(rx1680_pos)
    $P10 = rx1680_cur."package_def"()
    unless $P10, rx1680_fail
    rx1680_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx1680_pos = $P10."pos"()
.annotate 'line', 744
  # rx pass
    rx1680_cur."!cursor_pass"(rx1680_pos, "package_declarator:sym<class>")
    if_null rx1680_debug, debug_1130
    rx1680_cur."!cursor_debug"("PASS", "package_declarator:sym<class>", " at pos=", rx1680_pos)
  debug_1130:
    .return (rx1680_cur)
  rx1680_restart:
.annotate 'line', 436
    if_null rx1680_debug, debug_1131
    rx1680_cur."!cursor_debug"("NEXT", "package_declarator:sym<class>")
  debug_1131:
  rx1680_fail:
    (rx1680_rep, rx1680_pos, $I10, $P10) = rx1680_cur."!mark_fail"(0)
    lt rx1680_pos, -1, rx1680_done
    eq rx1680_pos, -1, rx1680_fail
    jump $I10
  rx1680_done:
    rx1680_cur."!cursor_fail"()
    if_null rx1680_debug, debug_1132
    rx1680_cur."!cursor_debug"("FAIL", "package_declarator:sym<class>")
  debug_1132:
    .return (rx1680_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<class>"  :subid("173_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P1688 = self."!PREFIX__!subrule"("package_def", "class")
    new $P1689, "ResizablePMCArray"
    push $P1689, $P1688
    .return ($P1689)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<grammar>"  :subid("174_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 750
    new $P1691, "Undef"
    .lex "$*OUTERPACKAGE", $P1691
.annotate 'line', 751
    new $P1692, "Undef"
    .lex "$*PKGDECL", $P1692
.annotate 'line', 436
    .local string rx1693_tgt
    .local int rx1693_pos
    .local int rx1693_off
    .local int rx1693_eos
    .local int rx1693_rep
    .local pmc rx1693_cur
    .local pmc rx1693_debug
    (rx1693_cur, rx1693_pos, rx1693_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1693_cur
    .local pmc match
    .lex "$/", match
    length rx1693_eos, rx1693_tgt
    gt rx1693_pos, rx1693_eos, rx1693_done
    set rx1693_off, 0
    lt rx1693_pos, 2, rx1693_start
    sub rx1693_off, rx1693_pos, 1
    substr rx1693_tgt, rx1693_tgt, rx1693_off
  rx1693_start:
    eq $I10, 1, rx1693_restart
    if_null rx1693_debug, debug_1133
    rx1693_cur."!cursor_debug"("START", "package_declarator:sym<grammar>")
  debug_1133:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1694_done
    goto rxscan1694_scan
  rxscan1694_loop:
    (rx1693_pos) = rx1693_cur."from"()
    inc rx1693_pos
    rx1693_cur."!cursor_from"(rx1693_pos)
    ge rx1693_pos, rx1693_eos, rxscan1694_done
  rxscan1694_scan:
    set_addr $I10, rxscan1694_loop
    rx1693_cur."!mark_push"(0, rx1693_pos, $I10)
  rxscan1694_done:
.annotate 'line', 750
    rx1693_cur."!cursor_pos"(rx1693_pos)
    find_dynamic_lex $P1697, "$*PACKAGE"
    unless_null $P1697, vivify_1134
    get_hll_global $P1695, "GLOBAL"
    get_who $P1696, $P1695
    set $P1697, $P1696["$PACKAGE"]
    unless_null $P1697, vivify_1135
    die "Contextual $*PACKAGE not found"
  vivify_1135:
  vivify_1134:
    store_lex "$*OUTERPACKAGE", $P1697
.annotate 'line', 751
    rx1693_cur."!cursor_pos"(rx1693_pos)
    new $P1698, "String"
    assign $P1698, "grammar"
    store_lex "$*PKGDECL", $P1698
.annotate 'line', 752
  # rx subcapture "sym"
    set_addr $I10, rxcap_1699_fail
    rx1693_cur."!mark_push"(0, rx1693_pos, $I10)
  # rx literal  "grammar"
    add $I11, rx1693_pos, 7
    gt $I11, rx1693_eos, rx1693_fail
    sub $I11, rx1693_pos, rx1693_off
    substr $S10, rx1693_tgt, $I11, 7
    ne $S10, "grammar", rx1693_fail
    add rx1693_pos, 7
    set_addr $I10, rxcap_1699_fail
    ($I12, $I11) = rx1693_cur."!mark_peek"($I10)
    rx1693_cur."!cursor_pos"($I11)
    ($P10) = rx1693_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1693_pos, "")
    rx1693_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1699_done
  rxcap_1699_fail:
    goto rx1693_fail
  rxcap_1699_done:
  # rx subrule "package_def" subtype=capture negate=
    rx1693_cur."!cursor_pos"(rx1693_pos)
    $P10 = rx1693_cur."package_def"()
    unless $P10, rx1693_fail
    rx1693_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx1693_pos = $P10."pos"()
.annotate 'line', 749
  # rx pass
    rx1693_cur."!cursor_pass"(rx1693_pos, "package_declarator:sym<grammar>")
    if_null rx1693_debug, debug_1136
    rx1693_cur."!cursor_debug"("PASS", "package_declarator:sym<grammar>", " at pos=", rx1693_pos)
  debug_1136:
    .return (rx1693_cur)
  rx1693_restart:
.annotate 'line', 436
    if_null rx1693_debug, debug_1137
    rx1693_cur."!cursor_debug"("NEXT", "package_declarator:sym<grammar>")
  debug_1137:
  rx1693_fail:
    (rx1693_rep, rx1693_pos, $I10, $P10) = rx1693_cur."!mark_fail"(0)
    lt rx1693_pos, -1, rx1693_done
    eq rx1693_pos, -1, rx1693_fail
    jump $I10
  rx1693_done:
    rx1693_cur."!cursor_fail"()
    if_null rx1693_debug, debug_1138
    rx1693_cur."!cursor_debug"("FAIL", "package_declarator:sym<grammar>")
  debug_1138:
    .return (rx1693_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<grammar>"  :subid("175_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P1701 = self."!PREFIX__!subrule"("package_def", "grammar")
    new $P1702, "ResizablePMCArray"
    push $P1702, $P1701
    .return ($P1702)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<role>"  :subid("176_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 755
    new $P1704, "Undef"
    .lex "$*OUTERPACKAGE", $P1704
.annotate 'line', 756
    new $P1705, "Undef"
    .lex "$*PKGDECL", $P1705
.annotate 'line', 436
    .local string rx1706_tgt
    .local int rx1706_pos
    .local int rx1706_off
    .local int rx1706_eos
    .local int rx1706_rep
    .local pmc rx1706_cur
    .local pmc rx1706_debug
    (rx1706_cur, rx1706_pos, rx1706_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1706_cur
    .local pmc match
    .lex "$/", match
    length rx1706_eos, rx1706_tgt
    gt rx1706_pos, rx1706_eos, rx1706_done
    set rx1706_off, 0
    lt rx1706_pos, 2, rx1706_start
    sub rx1706_off, rx1706_pos, 1
    substr rx1706_tgt, rx1706_tgt, rx1706_off
  rx1706_start:
    eq $I10, 1, rx1706_restart
    if_null rx1706_debug, debug_1139
    rx1706_cur."!cursor_debug"("START", "package_declarator:sym<role>")
  debug_1139:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1707_done
    goto rxscan1707_scan
  rxscan1707_loop:
    (rx1706_pos) = rx1706_cur."from"()
    inc rx1706_pos
    rx1706_cur."!cursor_from"(rx1706_pos)
    ge rx1706_pos, rx1706_eos, rxscan1707_done
  rxscan1707_scan:
    set_addr $I10, rxscan1707_loop
    rx1706_cur."!mark_push"(0, rx1706_pos, $I10)
  rxscan1707_done:
.annotate 'line', 755
    rx1706_cur."!cursor_pos"(rx1706_pos)
    find_dynamic_lex $P1710, "$*PACKAGE"
    unless_null $P1710, vivify_1140
    get_hll_global $P1708, "GLOBAL"
    get_who $P1709, $P1708
    set $P1710, $P1709["$PACKAGE"]
    unless_null $P1710, vivify_1141
    die "Contextual $*PACKAGE not found"
  vivify_1141:
  vivify_1140:
    store_lex "$*OUTERPACKAGE", $P1710
.annotate 'line', 756
    rx1706_cur."!cursor_pos"(rx1706_pos)
    new $P1711, "String"
    assign $P1711, "role"
    store_lex "$*PKGDECL", $P1711
.annotate 'line', 757
  # rx subcapture "sym"
    set_addr $I10, rxcap_1712_fail
    rx1706_cur."!mark_push"(0, rx1706_pos, $I10)
  # rx literal  "role"
    add $I11, rx1706_pos, 4
    gt $I11, rx1706_eos, rx1706_fail
    sub $I11, rx1706_pos, rx1706_off
    substr $S10, rx1706_tgt, $I11, 4
    ne $S10, "role", rx1706_fail
    add rx1706_pos, 4
    set_addr $I10, rxcap_1712_fail
    ($I12, $I11) = rx1706_cur."!mark_peek"($I10)
    rx1706_cur."!cursor_pos"($I11)
    ($P10) = rx1706_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1706_pos, "")
    rx1706_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1712_done
  rxcap_1712_fail:
    goto rx1706_fail
  rxcap_1712_done:
  # rx subrule "package_def" subtype=capture negate=
    rx1706_cur."!cursor_pos"(rx1706_pos)
    $P10 = rx1706_cur."package_def"()
    unless $P10, rx1706_fail
    rx1706_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx1706_pos = $P10."pos"()
.annotate 'line', 754
  # rx pass
    rx1706_cur."!cursor_pass"(rx1706_pos, "package_declarator:sym<role>")
    if_null rx1706_debug, debug_1142
    rx1706_cur."!cursor_debug"("PASS", "package_declarator:sym<role>", " at pos=", rx1706_pos)
  debug_1142:
    .return (rx1706_cur)
  rx1706_restart:
.annotate 'line', 436
    if_null rx1706_debug, debug_1143
    rx1706_cur."!cursor_debug"("NEXT", "package_declarator:sym<role>")
  debug_1143:
  rx1706_fail:
    (rx1706_rep, rx1706_pos, $I10, $P10) = rx1706_cur."!mark_fail"(0)
    lt rx1706_pos, -1, rx1706_done
    eq rx1706_pos, -1, rx1706_fail
    jump $I10
  rx1706_done:
    rx1706_cur."!cursor_fail"()
    if_null rx1706_debug, debug_1144
    rx1706_cur."!cursor_debug"("FAIL", "package_declarator:sym<role>")
  debug_1144:
    .return (rx1706_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<role>"  :subid("177_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P1714 = self."!PREFIX__!subrule"("package_def", "role")
    new $P1715, "ResizablePMCArray"
    push $P1715, $P1714
    .return ($P1715)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<native>"  :subid("178_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 760
    new $P1717, "Undef"
    .lex "$*OUTERPACKAGE", $P1717
.annotate 'line', 761
    new $P1718, "Undef"
    .lex "$*PKGDECL", $P1718
.annotate 'line', 436
    .local string rx1719_tgt
    .local int rx1719_pos
    .local int rx1719_off
    .local int rx1719_eos
    .local int rx1719_rep
    .local pmc rx1719_cur
    .local pmc rx1719_debug
    (rx1719_cur, rx1719_pos, rx1719_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1719_cur
    .local pmc match
    .lex "$/", match
    length rx1719_eos, rx1719_tgt
    gt rx1719_pos, rx1719_eos, rx1719_done
    set rx1719_off, 0
    lt rx1719_pos, 2, rx1719_start
    sub rx1719_off, rx1719_pos, 1
    substr rx1719_tgt, rx1719_tgt, rx1719_off
  rx1719_start:
    eq $I10, 1, rx1719_restart
    if_null rx1719_debug, debug_1145
    rx1719_cur."!cursor_debug"("START", "package_declarator:sym<native>")
  debug_1145:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1720_done
    goto rxscan1720_scan
  rxscan1720_loop:
    (rx1719_pos) = rx1719_cur."from"()
    inc rx1719_pos
    rx1719_cur."!cursor_from"(rx1719_pos)
    ge rx1719_pos, rx1719_eos, rxscan1720_done
  rxscan1720_scan:
    set_addr $I10, rxscan1720_loop
    rx1719_cur."!mark_push"(0, rx1719_pos, $I10)
  rxscan1720_done:
.annotate 'line', 760
    rx1719_cur."!cursor_pos"(rx1719_pos)
    find_dynamic_lex $P1723, "$*PACKAGE"
    unless_null $P1723, vivify_1146
    get_hll_global $P1721, "GLOBAL"
    get_who $P1722, $P1721
    set $P1723, $P1722["$PACKAGE"]
    unless_null $P1723, vivify_1147
    die "Contextual $*PACKAGE not found"
  vivify_1147:
  vivify_1146:
    store_lex "$*OUTERPACKAGE", $P1723
.annotate 'line', 761
    rx1719_cur."!cursor_pos"(rx1719_pos)
    new $P1724, "String"
    assign $P1724, "native"
    store_lex "$*PKGDECL", $P1724
.annotate 'line', 762
  # rx subcapture "sym"
    set_addr $I10, rxcap_1725_fail
    rx1719_cur."!mark_push"(0, rx1719_pos, $I10)
  # rx literal  "native"
    add $I11, rx1719_pos, 6
    gt $I11, rx1719_eos, rx1719_fail
    sub $I11, rx1719_pos, rx1719_off
    substr $S10, rx1719_tgt, $I11, 6
    ne $S10, "native", rx1719_fail
    add rx1719_pos, 6
    set_addr $I10, rxcap_1725_fail
    ($I12, $I11) = rx1719_cur."!mark_peek"($I10)
    rx1719_cur."!cursor_pos"($I11)
    ($P10) = rx1719_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1719_pos, "")
    rx1719_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1725_done
  rxcap_1725_fail:
    goto rx1719_fail
  rxcap_1725_done:
  # rx subrule "package_def" subtype=capture negate=
    rx1719_cur."!cursor_pos"(rx1719_pos)
    $P10 = rx1719_cur."package_def"()
    unless $P10, rx1719_fail
    rx1719_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx1719_pos = $P10."pos"()
.annotate 'line', 759
  # rx pass
    rx1719_cur."!cursor_pass"(rx1719_pos, "package_declarator:sym<native>")
    if_null rx1719_debug, debug_1148
    rx1719_cur."!cursor_debug"("PASS", "package_declarator:sym<native>", " at pos=", rx1719_pos)
  debug_1148:
    .return (rx1719_cur)
  rx1719_restart:
.annotate 'line', 436
    if_null rx1719_debug, debug_1149
    rx1719_cur."!cursor_debug"("NEXT", "package_declarator:sym<native>")
  debug_1149:
  rx1719_fail:
    (rx1719_rep, rx1719_pos, $I10, $P10) = rx1719_cur."!mark_fail"(0)
    lt rx1719_pos, -1, rx1719_done
    eq rx1719_pos, -1, rx1719_fail
    jump $I10
  rx1719_done:
    rx1719_cur."!cursor_fail"()
    if_null rx1719_debug, debug_1150
    rx1719_cur."!cursor_debug"("FAIL", "package_declarator:sym<native>")
  debug_1150:
    .return (rx1719_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<native>"  :subid("179_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P1727 = self."!PREFIX__!subrule"("package_def", "native")
    new $P1728, "ResizablePMCArray"
    push $P1728, $P1727
    .return ($P1728)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<stub>"  :subid("180_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 765
    new $P1730, "Undef"
    .lex "$*OUTERPACKAGE", $P1730
.annotate 'line', 766
    new $P1731, "Undef"
    .lex "$*PKGDECL", $P1731
.annotate 'line', 436
    .local string rx1732_tgt
    .local int rx1732_pos
    .local int rx1732_off
    .local int rx1732_eos
    .local int rx1732_rep
    .local pmc rx1732_cur
    .local pmc rx1732_debug
    (rx1732_cur, rx1732_pos, rx1732_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1732_cur
    .local pmc match
    .lex "$/", match
    length rx1732_eos, rx1732_tgt
    gt rx1732_pos, rx1732_eos, rx1732_done
    set rx1732_off, 0
    lt rx1732_pos, 2, rx1732_start
    sub rx1732_off, rx1732_pos, 1
    substr rx1732_tgt, rx1732_tgt, rx1732_off
  rx1732_start:
    eq $I10, 1, rx1732_restart
    if_null rx1732_debug, debug_1151
    rx1732_cur."!cursor_debug"("START", "package_declarator:sym<stub>")
  debug_1151:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1733_done
    goto rxscan1733_scan
  rxscan1733_loop:
    (rx1732_pos) = rx1732_cur."from"()
    inc rx1732_pos
    rx1732_cur."!cursor_from"(rx1732_pos)
    ge rx1732_pos, rx1732_eos, rxscan1733_done
  rxscan1733_scan:
    set_addr $I10, rxscan1733_loop
    rx1732_cur."!mark_push"(0, rx1732_pos, $I10)
  rxscan1733_done:
.annotate 'line', 764
  # rx subrule "ws" subtype=method negate=
    rx1732_cur."!cursor_pos"(rx1732_pos)
    $P10 = rx1732_cur."ws"()
    unless $P10, rx1732_fail
    rx1732_pos = $P10."pos"()
.annotate 'line', 765
    rx1732_cur."!cursor_pos"(rx1732_pos)
    find_dynamic_lex $P1737, "$*PACKAGE"
    unless_null $P1737, vivify_1152
    get_hll_global $P1735, "GLOBAL"
    get_who $P1736, $P1735
    set $P1737, $P1736["$PACKAGE"]
    unless_null $P1737, vivify_1153
    die "Contextual $*PACKAGE not found"
  vivify_1153:
  vivify_1152:
    store_lex "$*OUTERPACKAGE", $P1737
  # rx subrule "ws" subtype=method negate=
    rx1732_cur."!cursor_pos"(rx1732_pos)
    $P10 = rx1732_cur."ws"()
    unless $P10, rx1732_fail
    rx1732_pos = $P10."pos"()
.annotate 'line', 766
    rx1732_cur."!cursor_pos"(rx1732_pos)
    new $P1739, "String"
    assign $P1739, "stub"
    store_lex "$*PKGDECL", $P1739
  # rx subrule "ws" subtype=method negate=
    rx1732_cur."!cursor_pos"(rx1732_pos)
    $P10 = rx1732_cur."ws"()
    unless $P10, rx1732_fail
    rx1732_pos = $P10."pos"()
.annotate 'line', 767
  # rx subcapture "sym"
    set_addr $I10, rxcap_1741_fail
    rx1732_cur."!mark_push"(0, rx1732_pos, $I10)
  # rx literal  "stub"
    add $I11, rx1732_pos, 4
    gt $I11, rx1732_eos, rx1732_fail
    sub $I11, rx1732_pos, rx1732_off
    substr $S10, rx1732_tgt, $I11, 4
    ne $S10, "stub", rx1732_fail
    add rx1732_pos, 4
    set_addr $I10, rxcap_1741_fail
    ($I12, $I11) = rx1732_cur."!mark_peek"($I10)
    rx1732_cur."!cursor_pos"($I11)
    ($P10) = rx1732_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1732_pos, "")
    rx1732_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1741_done
  rxcap_1741_fail:
    goto rx1732_fail
  rxcap_1741_done:
  # rx subrule "ws" subtype=method negate=
    rx1732_cur."!cursor_pos"(rx1732_pos)
    $P10 = rx1732_cur."ws"()
    unless $P10, rx1732_fail
    rx1732_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx1732_cur."!cursor_pos"(rx1732_pos)
    $P10 = rx1732_cur."name"()
    unless $P10, rx1732_fail
    rx1732_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1732_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1732_cur."!cursor_pos"(rx1732_pos)
    $P10 = rx1732_cur."ws"()
    unless $P10, rx1732_fail
    rx1732_pos = $P10."pos"()
.annotate 'line', 768
  # rx literal  "metaclass"
    add $I11, rx1732_pos, 9
    gt $I11, rx1732_eos, rx1732_fail
    sub $I11, rx1732_pos, rx1732_off
    substr $S10, rx1732_tgt, $I11, 9
    ne $S10, "metaclass", rx1732_fail
    add rx1732_pos, 9
  # rx subrule "ws" subtype=method negate=
    rx1732_cur."!cursor_pos"(rx1732_pos)
    $P10 = rx1732_cur."ws"()
    unless $P10, rx1732_fail
    rx1732_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx1732_cur."!cursor_pos"(rx1732_pos)
    $P10 = rx1732_cur."name"()
    unless $P10, rx1732_fail
    rx1732_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("metaclass")
    rx1732_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1732_cur."!cursor_pos"(rx1732_pos)
    $P10 = rx1732_cur."ws"()
    unless $P10, rx1732_fail
    rx1732_pos = $P10."pos"()
.annotate 'line', 769
  # rx literal  "{"
    add $I11, rx1732_pos, 1
    gt $I11, rx1732_eos, rx1732_fail
    sub $I11, rx1732_pos, rx1732_off
    ord $I11, rx1732_tgt, $I11
    ne $I11, 123, rx1732_fail
    add rx1732_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1732_cur."!cursor_pos"(rx1732_pos)
    $P10 = rx1732_cur."ws"()
    unless $P10, rx1732_fail
    rx1732_pos = $P10."pos"()
  # rx literal  "..."
    add $I11, rx1732_pos, 3
    gt $I11, rx1732_eos, rx1732_fail
    sub $I11, rx1732_pos, rx1732_off
    substr $S10, rx1732_tgt, $I11, 3
    ne $S10, "...", rx1732_fail
    add rx1732_pos, 3
  # rx subrule "ws" subtype=method negate=
    rx1732_cur."!cursor_pos"(rx1732_pos)
    $P10 = rx1732_cur."ws"()
    unless $P10, rx1732_fail
    rx1732_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1732_pos, 1
    gt $I11, rx1732_eos, rx1732_fail
    sub $I11, rx1732_pos, rx1732_off
    ord $I11, rx1732_tgt, $I11
    ne $I11, 125, rx1732_fail
    add rx1732_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1732_cur."!cursor_pos"(rx1732_pos)
    $P10 = rx1732_cur."ws"()
    unless $P10, rx1732_fail
    rx1732_pos = $P10."pos"()
.annotate 'line', 764
  # rx pass
    rx1732_cur."!cursor_pass"(rx1732_pos, "package_declarator:sym<stub>")
    if_null rx1732_debug, debug_1154
    rx1732_cur."!cursor_debug"("PASS", "package_declarator:sym<stub>", " at pos=", rx1732_pos)
  debug_1154:
    .return (rx1732_cur)
  rx1732_restart:
.annotate 'line', 436
    if_null rx1732_debug, debug_1155
    rx1732_cur."!cursor_debug"("NEXT", "package_declarator:sym<stub>")
  debug_1155:
  rx1732_fail:
    (rx1732_rep, rx1732_pos, $I10, $P10) = rx1732_cur."!mark_fail"(0)
    lt rx1732_pos, -1, rx1732_done
    eq rx1732_pos, -1, rx1732_fail
    jump $I10
  rx1732_done:
    rx1732_cur."!cursor_fail"()
    if_null rx1732_debug, debug_1156
    rx1732_cur."!cursor_debug"("FAIL", "package_declarator:sym<stub>")
  debug_1156:
    .return (rx1732_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<stub>"  :subid("181_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P1750 = self."!PREFIX__!subrule"("ws", "")
    new $P1751, "ResizablePMCArray"
    push $P1751, $P1750
    .return ($P1751)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_def"  :subid("182_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .const 'Sub' $P1772 = "183_1307873304.82979" 
    capture_lex $P1772
.annotate 'line', 773
    new $P1753, "Undef"
    .lex "$*PACKAGE", $P1753
.annotate 'line', 436
    .local string rx1754_tgt
    .local int rx1754_pos
    .local int rx1754_off
    .local int rx1754_eos
    .local int rx1754_rep
    .local pmc rx1754_cur
    .local pmc rx1754_debug
    (rx1754_cur, rx1754_pos, rx1754_tgt, $I10) = self."!cursor_start"()
    rx1754_cur."!cursor_caparray"("repr", "parent", "role")
    .lex unicode:"$\x{a2}", rx1754_cur
    .local pmc match
    .lex "$/", match
    length rx1754_eos, rx1754_tgt
    gt rx1754_pos, rx1754_eos, rx1754_done
    set rx1754_off, 0
    lt rx1754_pos, 2, rx1754_start
    sub rx1754_off, rx1754_pos, 1
    substr rx1754_tgt, rx1754_tgt, rx1754_off
  rx1754_start:
    eq $I10, 1, rx1754_restart
    if_null rx1754_debug, debug_1157
    rx1754_cur."!cursor_debug"("START", "package_def")
  debug_1157:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1755_done
    goto rxscan1755_scan
  rxscan1755_loop:
    (rx1754_pos) = rx1754_cur."from"()
    inc rx1754_pos
    rx1754_cur."!cursor_from"(rx1754_pos)
    ge rx1754_pos, rx1754_eos, rxscan1755_done
  rxscan1755_scan:
    set_addr $I10, rxscan1755_loop
    rx1754_cur."!mark_push"(0, rx1754_pos, $I10)
  rxscan1755_done:
.annotate 'line', 772
  # rx subrule "ws" subtype=method negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."ws"()
    unless $P10, rx1754_fail
    rx1754_pos = $P10."pos"()
.annotate 'line', 773
    rx1754_cur."!cursor_pos"(rx1754_pos)
    find_lex $P1759, "$*PACKAGE"
    unless_null $P1759, vivify_1158
    get_hll_global $P1757, "GLOBAL"
    get_who $P1758, $P1757
    set $P1759, $P1758["$PACKAGE"]
    unless_null $P1759, vivify_1159
    die "Contextual $*PACKAGE not found"
  vivify_1159:
  vivify_1158:
  # rx subrule "ws" subtype=method negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."ws"()
    unless $P10, rx1754_fail
    rx1754_pos = $P10."pos"()
.annotate 'line', 775
  # rx subrule "name" subtype=capture negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."name"()
    unless $P10, rx1754_fail
    rx1754_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1754_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."ws"()
    unless $P10, rx1754_fail
    rx1754_pos = $P10."pos"()
.annotate 'line', 776
  # rx rxquantr1762 ** 0..1
    set_addr $I10, rxquantr1762_done
    rx1754_cur."!mark_push"(0, rx1754_pos, $I10)
  rxquantr1762_loop:
  # rx subrule "ws" subtype=method negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."ws"()
    unless $P10, rx1754_fail
    rx1754_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx1754_pos, 2
    gt $I11, rx1754_eos, rx1754_fail
    sub $I11, rx1754_pos, rx1754_off
    substr $S10, rx1754_tgt, $I11, 2
    ne $S10, "is", rx1754_fail
    add rx1754_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."ws"()
    unless $P10, rx1754_fail
    rx1754_pos = $P10."pos"()
  # rx literal  "repr("
    add $I11, rx1754_pos, 5
    gt $I11, rx1754_eos, rx1754_fail
    sub $I11, rx1754_pos, rx1754_off
    substr $S10, rx1754_tgt, $I11, 5
    ne $S10, "repr(", rx1754_fail
    add rx1754_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."ws"()
    unless $P10, rx1754_fail
    rx1754_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."quote_EXPR"()
    unless $P10, rx1754_fail
    rx1754_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("repr")
    rx1754_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."ws"()
    unless $P10, rx1754_fail
    rx1754_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1754_pos, 1
    gt $I11, rx1754_eos, rx1754_fail
    sub $I11, rx1754_pos, rx1754_off
    ord $I11, rx1754_tgt, $I11
    ne $I11, 41, rx1754_fail
    add rx1754_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."ws"()
    unless $P10, rx1754_fail
    rx1754_pos = $P10."pos"()
    set_addr $I10, rxquantr1762_done
    (rx1754_rep) = rx1754_cur."!mark_commit"($I10)
  rxquantr1762_done:
  # rx subrule "ws" subtype=method negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."ws"()
    unless $P10, rx1754_fail
    rx1754_pos = $P10."pos"()
.annotate 'line', 778
    rx1754_cur."!cursor_pos"(rx1754_pos)
    find_lex $P1769, unicode:"$\x{a2}"
    $P1770 = $P1769."MATCH"()
    store_lex "$/", $P1770
    .const 'Sub' $P1772 = "183_1307873304.82979" 
    capture_lex $P1772
    $P1894 = $P1772()
.annotate 'line', 804
  # rx subrule "ws" subtype=method negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."ws"()
    unless $P10, rx1754_fail
    rx1754_pos = $P10."pos"()
.annotate 'line', 806
  # rx rxquantr1896 ** 0..1
    set_addr $I10, rxquantr1896_done
    rx1754_cur."!mark_push"(0, rx1754_pos, $I10)
  rxquantr1896_loop:
  # rx subrule "ws" subtype=method negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."ws"()
    unless $P10, rx1754_fail
    rx1754_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx1754_pos, 2
    gt $I11, rx1754_eos, rx1754_fail
    sub $I11, rx1754_pos, rx1754_off
    substr $S10, rx1754_tgt, $I11, 2
    ne $S10, "is", rx1754_fail
    add rx1754_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."ws"()
    unless $P10, rx1754_fail
    rx1754_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."name"()
    unless $P10, rx1754_fail
    rx1754_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parent")
    rx1754_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."ws"()
    unless $P10, rx1754_fail
    rx1754_pos = $P10."pos"()
    set_addr $I10, rxquantr1896_done
    (rx1754_rep) = rx1754_cur."!mark_commit"($I10)
  rxquantr1896_done:
  # rx subrule "ws" subtype=method negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."ws"()
    unless $P10, rx1754_fail
    rx1754_pos = $P10."pos"()
.annotate 'line', 807
  # rx rxquantr1901 ** 0..*
    set_addr $I10, rxquantr1901_done
    rx1754_cur."!mark_push"(0, rx1754_pos, $I10)
  rxquantr1901_loop:
  # rx subrule "ws" subtype=method negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."ws"()
    unless $P10, rx1754_fail
    rx1754_pos = $P10."pos"()
  # rx literal  "does"
    add $I11, rx1754_pos, 4
    gt $I11, rx1754_eos, rx1754_fail
    sub $I11, rx1754_pos, rx1754_off
    substr $S10, rx1754_tgt, $I11, 4
    ne $S10, "does", rx1754_fail
    add rx1754_pos, 4
  # rx subrule "ws" subtype=method negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."ws"()
    unless $P10, rx1754_fail
    rx1754_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."name"()
    unless $P10, rx1754_fail
    rx1754_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("role")
    rx1754_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."ws"()
    unless $P10, rx1754_fail
    rx1754_pos = $P10."pos"()
    set_addr $I10, rxquantr1901_done
    (rx1754_rep) = rx1754_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1901_done
    rx1754_cur."!mark_push"(rx1754_rep, rx1754_pos, $I10)
    goto rxquantr1901_loop
  rxquantr1901_done:
  # rx subrule "ws" subtype=method negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."ws"()
    unless $P10, rx1754_fail
    rx1754_pos = $P10."pos"()
  alt1906_0:
.annotate 'line', 808
    set_addr $I10, alt1906_1
    rx1754_cur."!mark_push"(0, rx1754_pos, $I10)
.annotate 'line', 809
  # rx subrule "ws" subtype=method negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."ws"()
    unless $P10, rx1754_fail
    rx1754_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx1754_pos, 1
    gt $I11, rx1754_eos, rx1754_fail
    sub $I11, rx1754_pos, rx1754_off
    ord $I11, rx1754_tgt, $I11
    ne $I11, 59, rx1754_fail
    add rx1754_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."ws"()
    unless $P10, rx1754_fail
    rx1754_pos = $P10."pos"()
  # rx subrule "comp_unit" subtype=capture negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."comp_unit"()
    unless $P10, rx1754_fail
    rx1754_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("comp_unit")
    rx1754_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."ws"()
    unless $P10, rx1754_fail
    rx1754_pos = $P10."pos"()
    goto alt1906_end
  alt1906_1:
    set_addr $I10, alt1906_2
    rx1754_cur."!mark_push"(0, rx1754_pos, $I10)
.annotate 'line', 810
  # rx subrule "ws" subtype=method negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."ws"()
    unless $P10, rx1754_fail
    rx1754_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1754_pos, rx1754_off
    substr $S10, rx1754_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1754_fail
  # rx subrule "ws" subtype=method negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."ws"()
    unless $P10, rx1754_fail
    rx1754_pos = $P10."pos"()
  # rx subrule "block" subtype=capture negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."block"()
    unless $P10, rx1754_fail
    rx1754_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1754_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."ws"()
    unless $P10, rx1754_fail
    rx1754_pos = $P10."pos"()
    goto alt1906_end
  alt1906_2:
.annotate 'line', 811
  # rx subrule "ws" subtype=method negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."ws"()
    unless $P10, rx1754_fail
    rx1754_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."panic"("Malformed package declaration")
    unless $P10, rx1754_fail
    rx1754_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."ws"()
    unless $P10, rx1754_fail
    rx1754_pos = $P10."pos"()
  alt1906_end:
.annotate 'line', 812
  # rx subrule "ws" subtype=method negate=
    rx1754_cur."!cursor_pos"(rx1754_pos)
    $P10 = rx1754_cur."ws"()
    unless $P10, rx1754_fail
    rx1754_pos = $P10."pos"()
.annotate 'line', 772
  # rx pass
    rx1754_cur."!cursor_pass"(rx1754_pos, "package_def")
    if_null rx1754_debug, debug_1227
    rx1754_cur."!cursor_debug"("PASS", "package_def", " at pos=", rx1754_pos)
  debug_1227:
    .return (rx1754_cur)
  rx1754_restart:
.annotate 'line', 436
    if_null rx1754_debug, debug_1228
    rx1754_cur."!cursor_debug"("NEXT", "package_def")
  debug_1228:
  rx1754_fail:
    (rx1754_rep, rx1754_pos, $I10, $P10) = rx1754_cur."!mark_fail"(0)
    lt rx1754_pos, -1, rx1754_done
    eq rx1754_pos, -1, rx1754_fail
    jump $I10
  rx1754_done:
    rx1754_cur."!cursor_fail"()
    if_null rx1754_debug, debug_1229
    rx1754_cur."!cursor_debug"("FAIL", "package_def")
  debug_1229:
    .return (rx1754_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1771"  :anon :subid("183_1307873304.82979") :outer("182_1307873304.82979")
.annotate 'line', 781
    $P1773 = root_new ['parrot';'Hash']
    .lex "%args", $P1773
.annotate 'line', 778
    find_lex $P1774, "%args"
    unless_null $P1774, vivify_1160
    $P1774 = root_new ['parrot';'Hash']
  vivify_1160:
.annotate 'line', 782
    find_lex $P1775, "$/"
    unless_null $P1775, vivify_1161
    $P1775 = root_new ['parrot';'Hash']
  vivify_1161:
    set $P1776, $P1775["name"]
    unless_null $P1776, vivify_1162
    new $P1776, "Undef"
  vivify_1162:
    set $S1777, $P1776
    new $P1778, 'String'
    set $P1778, $S1777
    find_lex $P1779, "%args"
    unless_null $P1779, vivify_1163
    $P1779 = root_new ['parrot';'Hash']
    store_lex "%args", $P1779
  vivify_1163:
    set $P1779["name"], $P1778
.annotate 'line', 783
    find_lex $P1781, "$/"
    unless_null $P1781, vivify_1164
    $P1781 = root_new ['parrot';'Hash']
  vivify_1164:
    set $P1782, $P1781["repr"]
    unless_null $P1782, vivify_1165
    new $P1782, "Undef"
  vivify_1165:
    unless $P1782, if_1780_end
.annotate 'line', 784
    find_lex $P1783, "$/"
    unless_null $P1783, vivify_1166
    $P1783 = root_new ['parrot';'Hash']
  vivify_1166:
    set $P1784, $P1783["repr"]
    unless_null $P1784, vivify_1167
    $P1784 = root_new ['parrot';'ResizablePMCArray']
  vivify_1167:
    set $P1785, $P1784[0]
    unless_null $P1785, vivify_1168
    $P1785 = root_new ['parrot';'Hash']
  vivify_1168:
    set $P1786, $P1785["quote_delimited"]
    unless_null $P1786, vivify_1169
    $P1786 = root_new ['parrot';'Hash']
  vivify_1169:
    set $P1787, $P1786["quote_atom"]
    unless_null $P1787, vivify_1170
    $P1787 = root_new ['parrot';'ResizablePMCArray']
  vivify_1170:
    set $P1788, $P1787[0]
    unless_null $P1788, vivify_1171
    new $P1788, "Undef"
  vivify_1171:
    set $S1789, $P1788
    new $P1790, 'String'
    set $P1790, $S1789
    find_lex $P1791, "%args"
    unless_null $P1791, vivify_1172
    $P1791 = root_new ['parrot';'Hash']
    store_lex "%args", $P1791
  vivify_1172:
    set $P1791["repr"], $P1790
  if_1780_end:
.annotate 'line', 786
    find_dynamic_lex $P1794, "$*SC"
    unless_null $P1794, vivify_1173
    get_hll_global $P1792, "GLOBAL"
    get_who $P1793, $P1792
    set $P1794, $P1793["$SC"]
    unless_null $P1794, vivify_1174
    die "Contextual $*SC not found"
  vivify_1174:
  vivify_1173:
    find_dynamic_lex $P1797, "$*PKGDECL"
    unless_null $P1797, vivify_1175
    get_hll_global $P1795, "GLOBAL"
    get_who $P1796, $P1795
    set $P1797, $P1796["$PKGDECL"]
    unless_null $P1797, vivify_1176
    die "Contextual $*PKGDECL not found"
  vivify_1176:
  vivify_1175:
    find_dynamic_lex $P1800, "%*HOW"
    unless_null $P1800, vivify_1177
    get_hll_global $P1798, "GLOBAL"
    get_who $P1799, $P1798
    set $P1800, $P1799["%HOW"]
    unless_null $P1800, vivify_1178
    die "Contextual %*HOW not found"
  vivify_1178:
  vivify_1177:
    set $P1801, $P1800[$P1797]
    unless_null $P1801, vivify_1179
    new $P1801, "Undef"
  vivify_1179:
    find_lex $P1802, "%args"
    unless_null $P1802, vivify_1180
    $P1802 = root_new ['parrot';'Hash']
  vivify_1180:
    $P1803 = $P1794."pkg_create_mo"($P1801, $P1802 :flat)
    store_dynamic_lex "$*PACKAGE", $P1803
.annotate 'line', 789
    find_dynamic_lex $P1810, "$*SCOPE"
    unless_null $P1810, vivify_1181
    get_hll_global $P1808, "GLOBAL"
    get_who $P1809, $P1808
    set $P1810, $P1809["$SCOPE"]
    unless_null $P1810, vivify_1182
    die "Contextual $*SCOPE not found"
  vivify_1182:
  vivify_1181:
    set $S1811, $P1810
    iseq $I1812, $S1811, "our"
    unless $I1812, unless_1807
    new $P1806, 'Integer'
    set $P1806, $I1812
    goto unless_1807_end
  unless_1807:
    find_dynamic_lex $P1815, "$*SCOPE"
    unless_null $P1815, vivify_1183
    get_hll_global $P1813, "GLOBAL"
    get_who $P1814, $P1813
    set $P1815, $P1814["$SCOPE"]
    unless_null $P1815, vivify_1184
    die "Contextual $*SCOPE not found"
  vivify_1184:
  vivify_1183:
    set $S1816, $P1815
    iseq $I1817, $S1816, ""
    new $P1806, 'Integer'
    set $P1806, $I1817
  unless_1807_end:
    if $P1806, if_1805
.annotate 'line', 795
    find_dynamic_lex $P1858, "$*SCOPE"
    unless_null $P1858, vivify_1185
    get_hll_global $P1856, "GLOBAL"
    get_who $P1857, $P1856
    set $P1858, $P1857["$SCOPE"]
    unless_null $P1858, vivify_1186
    die "Contextual $*SCOPE not found"
  vivify_1186:
  vivify_1185:
    set $S1859, $P1858
    iseq $I1860, $S1859, "my"
    if $I1860, if_1855
.annotate 'line', 802
    find_lex $P1887, "$/"
    unless_null $P1887, vivify_1187
    new $P1887, "Undef"
  vivify_1187:
    $P1888 = $P1887."CURSOR"()
    find_dynamic_lex $P1891, "$*SCOPE"
    unless_null $P1891, vivify_1188
    get_hll_global $P1889, "GLOBAL"
    get_who $P1890, $P1889
    set $P1891, $P1890["$SCOPE"]
    unless_null $P1891, vivify_1189
    die "Contextual $*SCOPE not found"
  vivify_1189:
  vivify_1188:
    concat $P1892, $P1891, " scoped packages are not supported"
    $P1893 = $P1888."panic"($P1892)
.annotate 'line', 801
    set $P1854, $P1893
.annotate 'line', 795
    goto if_1855_end
  if_1855:
.annotate 'line', 796
    find_lex $P1862, "$/"
    unless_null $P1862, vivify_1190
    $P1862 = root_new ['parrot';'Hash']
  vivify_1190:
    set $P1863, $P1862["name"]
    unless_null $P1863, vivify_1191
    $P1863 = root_new ['parrot';'Hash']
  vivify_1191:
    set $P1864, $P1863["identifier"]
    unless_null $P1864, vivify_1192
    new $P1864, "Undef"
  vivify_1192:
    set $N1865, $P1864
    isne $I1866, $N1865, 1.0
    unless $I1866, if_1861_end
.annotate 'line', 797
    find_lex $P1867, "$/"
    unless_null $P1867, vivify_1193
    $P1867 = root_new ['parrot';'Hash']
  vivify_1193:
    set $P1868, $P1867["name"]
    unless_null $P1868, vivify_1194
    new $P1868, "Undef"
  vivify_1194:
    $P1869 = $P1868."CURSOR"()
    $P1869."panic"("A my scoped package cannot have a multi-part name yet")
  if_1861_end:
.annotate 'line', 799
    find_dynamic_lex $P1872, "$*SC"
    unless_null $P1872, vivify_1195
    get_hll_global $P1870, "GLOBAL"
    get_who $P1871, $P1870
    set $P1872, $P1871["$SC"]
    unless_null $P1872, vivify_1196
    die "Contextual $*SC not found"
  vivify_1196:
  vivify_1195:
    get_hll_global $P1873, "GLOBAL"
    nqp_get_package_through_who $P1874, $P1873, "NQP"
    nqp_get_package_through_who $P1875, $P1874, "Actions"
    get_who $P1876, $P1875
    set $P1877, $P1876["@BLOCK"]
    unless_null $P1877, vivify_1197
    $P1877 = root_new ['parrot';'ResizablePMCArray']
  vivify_1197:
    set $P1878, $P1877[0]
    unless_null $P1878, vivify_1198
    new $P1878, "Undef"
  vivify_1198:
    find_lex $P1879, "$/"
    unless_null $P1879, vivify_1199
    $P1879 = root_new ['parrot';'Hash']
  vivify_1199:
    set $P1880, $P1879["name"]
    unless_null $P1880, vivify_1200
    $P1880 = root_new ['parrot';'Hash']
  vivify_1200:
    set $P1881, $P1880["identifier"]
    unless_null $P1881, vivify_1201
    $P1881 = root_new ['parrot';'ResizablePMCArray']
  vivify_1201:
    set $P1882, $P1881[0]
    unless_null $P1882, vivify_1202
    new $P1882, "Undef"
  vivify_1202:
    find_dynamic_lex $P1885, "$*PACKAGE"
    unless_null $P1885, vivify_1203
    get_hll_global $P1883, "GLOBAL"
    get_who $P1884, $P1883
    set $P1885, $P1884["$PACKAGE"]
    unless_null $P1885, vivify_1204
    die "Contextual $*PACKAGE not found"
  vivify_1204:
  vivify_1203:
    $P1886 = $P1872."install_lexical_symbol"($P1878, $P1882, $P1885)
.annotate 'line', 795
    set $P1854, $P1886
  if_1855_end:
    set $P1804, $P1854
.annotate 'line', 789
    goto if_1805_end
  if_1805:
.annotate 'line', 790
    find_dynamic_lex $P1820, "$*SC"
    unless_null $P1820, vivify_1205
    get_hll_global $P1818, "GLOBAL"
    get_who $P1819, $P1818
    set $P1820, $P1819["$SC"]
    unless_null $P1820, vivify_1206
    die "Contextual $*SC not found"
  vivify_1206:
  vivify_1205:
    find_dynamic_lex $P1823, "$*OUTERPACKAGE"
    unless_null $P1823, vivify_1207
    get_hll_global $P1821, "GLOBAL"
    get_who $P1822, $P1821
    set $P1823, $P1822["$OUTERPACKAGE"]
    unless_null $P1823, vivify_1208
    die "Contextual $*OUTERPACKAGE not found"
  vivify_1208:
  vivify_1207:
    find_lex $P1824, "$/"
    unless_null $P1824, vivify_1209
    $P1824 = root_new ['parrot';'Hash']
  vivify_1209:
    set $P1825, $P1824["name"]
    unless_null $P1825, vivify_1210
    $P1825 = root_new ['parrot';'Hash']
  vivify_1210:
    set $P1826, $P1825["identifier"]
    unless_null $P1826, vivify_1211
    new $P1826, "Undef"
  vivify_1211:
    find_dynamic_lex $P1829, "$*PACKAGE"
    unless_null $P1829, vivify_1212
    get_hll_global $P1827, "GLOBAL"
    get_who $P1828, $P1827
    set $P1829, $P1828["$PACKAGE"]
    unless_null $P1829, vivify_1213
    die "Contextual $*PACKAGE not found"
  vivify_1213:
  vivify_1212:
    $P1820."install_package_symbol"($P1823, $P1826, $P1829)
.annotate 'line', 791
    find_lex $P1832, "$/"
    unless_null $P1832, vivify_1214
    $P1832 = root_new ['parrot';'Hash']
  vivify_1214:
    set $P1833, $P1832["name"]
    unless_null $P1833, vivify_1215
    $P1833 = root_new ['parrot';'Hash']
  vivify_1215:
    set $P1834, $P1833["identifier"]
    unless_null $P1834, vivify_1216
    new $P1834, "Undef"
  vivify_1216:
    set $N1835, $P1834
    iseq $I1836, $N1835, 1.0
    if $I1836, if_1831
    new $P1830, 'Integer'
    set $P1830, $I1836
    goto if_1831_end
  if_1831:
.annotate 'line', 792
    find_dynamic_lex $P1839, "$*SC"
    unless_null $P1839, vivify_1217
    get_hll_global $P1837, "GLOBAL"
    get_who $P1838, $P1837
    set $P1839, $P1838["$SC"]
    unless_null $P1839, vivify_1218
    die "Contextual $*SC not found"
  vivify_1218:
  vivify_1217:
    get_hll_global $P1840, "GLOBAL"
    nqp_get_package_through_who $P1841, $P1840, "NQP"
    nqp_get_package_through_who $P1842, $P1841, "Actions"
    get_who $P1843, $P1842
    set $P1844, $P1843["@BLOCK"]
    unless_null $P1844, vivify_1219
    $P1844 = root_new ['parrot';'ResizablePMCArray']
  vivify_1219:
    set $P1845, $P1844[0]
    unless_null $P1845, vivify_1220
    new $P1845, "Undef"
  vivify_1220:
    find_lex $P1846, "$/"
    unless_null $P1846, vivify_1221
    $P1846 = root_new ['parrot';'Hash']
  vivify_1221:
    set $P1847, $P1846["name"]
    unless_null $P1847, vivify_1222
    $P1847 = root_new ['parrot';'Hash']
  vivify_1222:
    set $P1848, $P1847["identifier"]
    unless_null $P1848, vivify_1223
    $P1848 = root_new ['parrot';'ResizablePMCArray']
  vivify_1223:
    set $P1849, $P1848[0]
    unless_null $P1849, vivify_1224
    new $P1849, "Undef"
  vivify_1224:
    find_dynamic_lex $P1852, "$*PACKAGE"
    unless_null $P1852, vivify_1225
    get_hll_global $P1850, "GLOBAL"
    get_who $P1851, $P1850
    set $P1852, $P1851["$PACKAGE"]
    unless_null $P1852, vivify_1226
    die "Contextual $*PACKAGE not found"
  vivify_1226:
  vivify_1225:
    $P1853 = $P1839."install_lexical_symbol"($P1845, $P1849, $P1852)
.annotate 'line', 791
    set $P1830, $P1853
  if_1831_end:
.annotate 'line', 789
    set $P1804, $P1830
  if_1805_end:
.annotate 'line', 778
    .return ($P1804)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_def"  :subid("184_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P1917 = self."!PREFIX__!subrule"("ws", "")
    new $P1918, "ResizablePMCArray"
    push $P1918, $P1917
    .return ($P1918)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator"  :subid("185_1307873304.82979")
    .param pmc param_1920
.annotate 'line', 815
    .lex "self", param_1920
    $P1921 = param_1920."!protoregex"("scope_declarator")
    .return ($P1921)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator"  :subid("186_1307873304.82979")
    .param pmc param_1923
.annotate 'line', 815
    .lex "self", param_1923
    $P1924 = param_1923."!PREFIX__!protoregex"("scope_declarator")
    .return ($P1924)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<my>"  :subid("187_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx1926_tgt
    .local int rx1926_pos
    .local int rx1926_off
    .local int rx1926_eos
    .local int rx1926_rep
    .local pmc rx1926_cur
    .local pmc rx1926_debug
    (rx1926_cur, rx1926_pos, rx1926_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1926_cur
    .local pmc match
    .lex "$/", match
    length rx1926_eos, rx1926_tgt
    gt rx1926_pos, rx1926_eos, rx1926_done
    set rx1926_off, 0
    lt rx1926_pos, 2, rx1926_start
    sub rx1926_off, rx1926_pos, 1
    substr rx1926_tgt, rx1926_tgt, rx1926_off
  rx1926_start:
    eq $I10, 1, rx1926_restart
    if_null rx1926_debug, debug_1230
    rx1926_cur."!cursor_debug"("START", "scope_declarator:sym<my>")
  debug_1230:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1927_done
    goto rxscan1927_scan
  rxscan1927_loop:
    (rx1926_pos) = rx1926_cur."from"()
    inc rx1926_pos
    rx1926_cur."!cursor_from"(rx1926_pos)
    ge rx1926_pos, rx1926_eos, rxscan1927_done
  rxscan1927_scan:
    set_addr $I10, rxscan1927_loop
    rx1926_cur."!mark_push"(0, rx1926_pos, $I10)
  rxscan1927_done:
.annotate 'line', 816
  # rx subcapture "sym"
    set_addr $I10, rxcap_1928_fail
    rx1926_cur."!mark_push"(0, rx1926_pos, $I10)
  # rx literal  "my"
    add $I11, rx1926_pos, 2
    gt $I11, rx1926_eos, rx1926_fail
    sub $I11, rx1926_pos, rx1926_off
    substr $S10, rx1926_tgt, $I11, 2
    ne $S10, "my", rx1926_fail
    add rx1926_pos, 2
    set_addr $I10, rxcap_1928_fail
    ($I12, $I11) = rx1926_cur."!mark_peek"($I10)
    rx1926_cur."!cursor_pos"($I11)
    ($P10) = rx1926_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1926_pos, "")
    rx1926_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1928_done
  rxcap_1928_fail:
    goto rx1926_fail
  rxcap_1928_done:
  # rx subrule "scoped" subtype=capture negate=
    rx1926_cur."!cursor_pos"(rx1926_pos)
    $P10 = rx1926_cur."scoped"("my")
    unless $P10, rx1926_fail
    rx1926_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx1926_pos = $P10."pos"()
  # rx pass
    rx1926_cur."!cursor_pass"(rx1926_pos, "scope_declarator:sym<my>")
    if_null rx1926_debug, debug_1231
    rx1926_cur."!cursor_debug"("PASS", "scope_declarator:sym<my>", " at pos=", rx1926_pos)
  debug_1231:
    .return (rx1926_cur)
  rx1926_restart:
.annotate 'line', 436
    if_null rx1926_debug, debug_1232
    rx1926_cur."!cursor_debug"("NEXT", "scope_declarator:sym<my>")
  debug_1232:
  rx1926_fail:
    (rx1926_rep, rx1926_pos, $I10, $P10) = rx1926_cur."!mark_fail"(0)
    lt rx1926_pos, -1, rx1926_done
    eq rx1926_pos, -1, rx1926_fail
    jump $I10
  rx1926_done:
    rx1926_cur."!cursor_fail"()
    if_null rx1926_debug, debug_1233
    rx1926_cur."!cursor_debug"("FAIL", "scope_declarator:sym<my>")
  debug_1233:
    .return (rx1926_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<my>"  :subid("188_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P1930 = self."!PREFIX__!subrule"("scoped", "my")
    new $P1931, "ResizablePMCArray"
    push $P1931, $P1930
    .return ($P1931)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<our>"  :subid("189_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx1933_tgt
    .local int rx1933_pos
    .local int rx1933_off
    .local int rx1933_eos
    .local int rx1933_rep
    .local pmc rx1933_cur
    .local pmc rx1933_debug
    (rx1933_cur, rx1933_pos, rx1933_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1933_cur
    .local pmc match
    .lex "$/", match
    length rx1933_eos, rx1933_tgt
    gt rx1933_pos, rx1933_eos, rx1933_done
    set rx1933_off, 0
    lt rx1933_pos, 2, rx1933_start
    sub rx1933_off, rx1933_pos, 1
    substr rx1933_tgt, rx1933_tgt, rx1933_off
  rx1933_start:
    eq $I10, 1, rx1933_restart
    if_null rx1933_debug, debug_1234
    rx1933_cur."!cursor_debug"("START", "scope_declarator:sym<our>")
  debug_1234:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1934_done
    goto rxscan1934_scan
  rxscan1934_loop:
    (rx1933_pos) = rx1933_cur."from"()
    inc rx1933_pos
    rx1933_cur."!cursor_from"(rx1933_pos)
    ge rx1933_pos, rx1933_eos, rxscan1934_done
  rxscan1934_scan:
    set_addr $I10, rxscan1934_loop
    rx1933_cur."!mark_push"(0, rx1933_pos, $I10)
  rxscan1934_done:
.annotate 'line', 817
  # rx subcapture "sym"
    set_addr $I10, rxcap_1935_fail
    rx1933_cur."!mark_push"(0, rx1933_pos, $I10)
  # rx literal  "our"
    add $I11, rx1933_pos, 3
    gt $I11, rx1933_eos, rx1933_fail
    sub $I11, rx1933_pos, rx1933_off
    substr $S10, rx1933_tgt, $I11, 3
    ne $S10, "our", rx1933_fail
    add rx1933_pos, 3
    set_addr $I10, rxcap_1935_fail
    ($I12, $I11) = rx1933_cur."!mark_peek"($I10)
    rx1933_cur."!cursor_pos"($I11)
    ($P10) = rx1933_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1933_pos, "")
    rx1933_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1935_done
  rxcap_1935_fail:
    goto rx1933_fail
  rxcap_1935_done:
  # rx subrule "scoped" subtype=capture negate=
    rx1933_cur."!cursor_pos"(rx1933_pos)
    $P10 = rx1933_cur."scoped"("our")
    unless $P10, rx1933_fail
    rx1933_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx1933_pos = $P10."pos"()
  # rx pass
    rx1933_cur."!cursor_pass"(rx1933_pos, "scope_declarator:sym<our>")
    if_null rx1933_debug, debug_1235
    rx1933_cur."!cursor_debug"("PASS", "scope_declarator:sym<our>", " at pos=", rx1933_pos)
  debug_1235:
    .return (rx1933_cur)
  rx1933_restart:
.annotate 'line', 436
    if_null rx1933_debug, debug_1236
    rx1933_cur."!cursor_debug"("NEXT", "scope_declarator:sym<our>")
  debug_1236:
  rx1933_fail:
    (rx1933_rep, rx1933_pos, $I10, $P10) = rx1933_cur."!mark_fail"(0)
    lt rx1933_pos, -1, rx1933_done
    eq rx1933_pos, -1, rx1933_fail
    jump $I10
  rx1933_done:
    rx1933_cur."!cursor_fail"()
    if_null rx1933_debug, debug_1237
    rx1933_cur."!cursor_debug"("FAIL", "scope_declarator:sym<our>")
  debug_1237:
    .return (rx1933_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<our>"  :subid("190_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P1937 = self."!PREFIX__!subrule"("scoped", "our")
    new $P1938, "ResizablePMCArray"
    push $P1938, $P1937
    .return ($P1938)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<has>"  :subid("191_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx1940_tgt
    .local int rx1940_pos
    .local int rx1940_off
    .local int rx1940_eos
    .local int rx1940_rep
    .local pmc rx1940_cur
    .local pmc rx1940_debug
    (rx1940_cur, rx1940_pos, rx1940_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1940_cur
    .local pmc match
    .lex "$/", match
    length rx1940_eos, rx1940_tgt
    gt rx1940_pos, rx1940_eos, rx1940_done
    set rx1940_off, 0
    lt rx1940_pos, 2, rx1940_start
    sub rx1940_off, rx1940_pos, 1
    substr rx1940_tgt, rx1940_tgt, rx1940_off
  rx1940_start:
    eq $I10, 1, rx1940_restart
    if_null rx1940_debug, debug_1238
    rx1940_cur."!cursor_debug"("START", "scope_declarator:sym<has>")
  debug_1238:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1941_done
    goto rxscan1941_scan
  rxscan1941_loop:
    (rx1940_pos) = rx1940_cur."from"()
    inc rx1940_pos
    rx1940_cur."!cursor_from"(rx1940_pos)
    ge rx1940_pos, rx1940_eos, rxscan1941_done
  rxscan1941_scan:
    set_addr $I10, rxscan1941_loop
    rx1940_cur."!mark_push"(0, rx1940_pos, $I10)
  rxscan1941_done:
.annotate 'line', 818
  # rx subcapture "sym"
    set_addr $I10, rxcap_1942_fail
    rx1940_cur."!mark_push"(0, rx1940_pos, $I10)
  # rx literal  "has"
    add $I11, rx1940_pos, 3
    gt $I11, rx1940_eos, rx1940_fail
    sub $I11, rx1940_pos, rx1940_off
    substr $S10, rx1940_tgt, $I11, 3
    ne $S10, "has", rx1940_fail
    add rx1940_pos, 3
    set_addr $I10, rxcap_1942_fail
    ($I12, $I11) = rx1940_cur."!mark_peek"($I10)
    rx1940_cur."!cursor_pos"($I11)
    ($P10) = rx1940_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1940_pos, "")
    rx1940_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1942_done
  rxcap_1942_fail:
    goto rx1940_fail
  rxcap_1942_done:
  # rx subrule "scoped" subtype=capture negate=
    rx1940_cur."!cursor_pos"(rx1940_pos)
    $P10 = rx1940_cur."scoped"("has")
    unless $P10, rx1940_fail
    rx1940_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx1940_pos = $P10."pos"()
  # rx pass
    rx1940_cur."!cursor_pass"(rx1940_pos, "scope_declarator:sym<has>")
    if_null rx1940_debug, debug_1239
    rx1940_cur."!cursor_debug"("PASS", "scope_declarator:sym<has>", " at pos=", rx1940_pos)
  debug_1239:
    .return (rx1940_cur)
  rx1940_restart:
.annotate 'line', 436
    if_null rx1940_debug, debug_1240
    rx1940_cur."!cursor_debug"("NEXT", "scope_declarator:sym<has>")
  debug_1240:
  rx1940_fail:
    (rx1940_rep, rx1940_pos, $I10, $P10) = rx1940_cur."!mark_fail"(0)
    lt rx1940_pos, -1, rx1940_done
    eq rx1940_pos, -1, rx1940_fail
    jump $I10
  rx1940_done:
    rx1940_cur."!cursor_fail"()
    if_null rx1940_debug, debug_1241
    rx1940_cur."!cursor_debug"("FAIL", "scope_declarator:sym<has>")
  debug_1241:
    .return (rx1940_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<has>"  :subid("192_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P1944 = self."!PREFIX__!subrule"("scoped", "has")
    new $P1945, "ResizablePMCArray"
    push $P1945, $P1944
    .return ($P1945)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scoped"  :subid("193_1307873304.82979") :method :outer("40_1307873304.82979")
    .param pmc param_1947
.annotate 'line', 820
    .lex "$*SCOPE", param_1947
.annotate 'line', 436
    .local string rx1948_tgt
    .local int rx1948_pos
    .local int rx1948_off
    .local int rx1948_eos
    .local int rx1948_rep
    .local pmc rx1948_cur
    .local pmc rx1948_debug
    (rx1948_cur, rx1948_pos, rx1948_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1948_cur
    .local pmc match
    .lex "$/", match
    length rx1948_eos, rx1948_tgt
    gt rx1948_pos, rx1948_eos, rx1948_done
    set rx1948_off, 0
    lt rx1948_pos, 2, rx1948_start
    sub rx1948_off, rx1948_pos, 1
    substr rx1948_tgt, rx1948_tgt, rx1948_off
  rx1948_start:
    eq $I10, 1, rx1948_restart
    if_null rx1948_debug, debug_1242
    rx1948_cur."!cursor_debug"("START", "scoped")
  debug_1242:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1949_done
    goto rxscan1949_scan
  rxscan1949_loop:
    (rx1948_pos) = rx1948_cur."from"()
    inc rx1948_pos
    rx1948_cur."!cursor_from"(rx1948_pos)
    ge rx1948_pos, rx1948_eos, rxscan1949_done
  rxscan1949_scan:
    set_addr $I10, rxscan1949_loop
    rx1948_cur."!mark_push"(0, rx1948_pos, $I10)
  rxscan1949_done:
  alt1950_0:
.annotate 'line', 820
    set_addr $I10, alt1950_1
    rx1948_cur."!mark_push"(0, rx1948_pos, $I10)
.annotate 'line', 821
  # rx subrule "ws" subtype=method negate=
    rx1948_cur."!cursor_pos"(rx1948_pos)
    $P10 = rx1948_cur."ws"()
    unless $P10, rx1948_fail
    rx1948_pos = $P10."pos"()
  # rx subrule "declarator" subtype=capture negate=
    rx1948_cur."!cursor_pos"(rx1948_pos)
    $P10 = rx1948_cur."declarator"()
    unless $P10, rx1948_fail
    rx1948_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1948_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1948_cur."!cursor_pos"(rx1948_pos)
    $P10 = rx1948_cur."ws"()
    unless $P10, rx1948_fail
    rx1948_pos = $P10."pos"()
    goto alt1950_end
  alt1950_1:
    set_addr $I10, alt1950_2
    rx1948_cur."!mark_push"(0, rx1948_pos, $I10)
.annotate 'line', 822
  # rx subrule "ws" subtype=method negate=
    rx1948_cur."!cursor_pos"(rx1948_pos)
    $P10 = rx1948_cur."ws"()
    unless $P10, rx1948_fail
    rx1948_pos = $P10."pos"()
  # rx subrule "multi_declarator" subtype=capture negate=
    rx1948_cur."!cursor_pos"(rx1948_pos)
    $P10 = rx1948_cur."multi_declarator"()
    unless $P10, rx1948_fail
    rx1948_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx1948_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1948_cur."!cursor_pos"(rx1948_pos)
    $P10 = rx1948_cur."ws"()
    unless $P10, rx1948_fail
    rx1948_pos = $P10."pos"()
    goto alt1950_end
  alt1950_2:
.annotate 'line', 823
  # rx subrule "ws" subtype=method negate=
    rx1948_cur."!cursor_pos"(rx1948_pos)
    $P10 = rx1948_cur."ws"()
    unless $P10, rx1948_fail
    rx1948_pos = $P10."pos"()
  # rx subrule "package_declarator" subtype=capture negate=
    rx1948_cur."!cursor_pos"(rx1948_pos)
    $P10 = rx1948_cur."package_declarator"()
    unless $P10, rx1948_fail
    rx1948_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx1948_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1948_cur."!cursor_pos"(rx1948_pos)
    $P10 = rx1948_cur."ws"()
    unless $P10, rx1948_fail
    rx1948_pos = $P10."pos"()
  alt1950_end:
.annotate 'line', 820
  # rx pass
    rx1948_cur."!cursor_pass"(rx1948_pos, "scoped")
    if_null rx1948_debug, debug_1243
    rx1948_cur."!cursor_debug"("PASS", "scoped", " at pos=", rx1948_pos)
  debug_1243:
    .return (rx1948_cur)
  rx1948_restart:
.annotate 'line', 436
    if_null rx1948_debug, debug_1244
    rx1948_cur."!cursor_debug"("NEXT", "scoped")
  debug_1244:
  rx1948_fail:
    (rx1948_rep, rx1948_pos, $I10, $P10) = rx1948_cur."!mark_fail"(0)
    lt rx1948_pos, -1, rx1948_done
    eq rx1948_pos, -1, rx1948_fail
    jump $I10
  rx1948_done:
    rx1948_cur."!cursor_fail"()
    if_null rx1948_debug, debug_1245
    rx1948_cur."!cursor_debug"("FAIL", "scoped")
  debug_1245:
    .return (rx1948_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scoped"  :subid("194_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P1958 = self."!PREFIX__!subrule"("ws", "")
    $P1959 = self."!PREFIX__!subrule"("ws", "")
    $P1960 = self."!PREFIX__!subrule"("ws", "")
    new $P1961, "ResizablePMCArray"
    push $P1961, $P1958
    push $P1961, $P1959
    push $P1961, $P1960
    .return ($P1961)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "typename"  :subid("195_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .const 'Sub' $P1968 = "196_1307873304.82979" 
    capture_lex $P1968
    .local string rx1963_tgt
    .local int rx1963_pos
    .local int rx1963_off
    .local int rx1963_eos
    .local int rx1963_rep
    .local pmc rx1963_cur
    .local pmc rx1963_debug
    (rx1963_cur, rx1963_pos, rx1963_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1963_cur
    .local pmc match
    .lex "$/", match
    length rx1963_eos, rx1963_tgt
    gt rx1963_pos, rx1963_eos, rx1963_done
    set rx1963_off, 0
    lt rx1963_pos, 2, rx1963_start
    sub rx1963_off, rx1963_pos, 1
    substr rx1963_tgt, rx1963_tgt, rx1963_off
  rx1963_start:
    eq $I10, 1, rx1963_restart
    if_null rx1963_debug, debug_1246
    rx1963_cur."!cursor_debug"("START", "typename")
  debug_1246:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1964_done
    goto rxscan1964_scan
  rxscan1964_loop:
    (rx1963_pos) = rx1963_cur."from"()
    inc rx1963_pos
    rx1963_cur."!cursor_from"(rx1963_pos)
    ge rx1963_pos, rx1963_eos, rxscan1964_done
  rxscan1964_scan:
    set_addr $I10, rxscan1964_loop
    rx1963_cur."!mark_push"(0, rx1963_pos, $I10)
  rxscan1964_done:
.annotate 'line', 827
  # rx subrule "name" subtype=capture negate=
    rx1963_cur."!cursor_pos"(rx1963_pos)
    $P10 = rx1963_cur."name"()
    unless $P10, rx1963_fail
    rx1963_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1963_pos = $P10."pos"()
.annotate 'line', 828
    rx1963_cur."!cursor_pos"(rx1963_pos)
    find_lex $P1965, unicode:"$\x{a2}"
    $P1966 = $P1965."MATCH"()
    store_lex "$/", $P1966
    .const 'Sub' $P1968 = "196_1307873304.82979" 
    capture_lex $P1968
    $P1977 = $P1968()
    unless $P1977, rx1963_fail
.annotate 'line', 826
  # rx pass
    rx1963_cur."!cursor_pass"(rx1963_pos, "typename")
    if_null rx1963_debug, debug_1253
    rx1963_cur."!cursor_debug"("PASS", "typename", " at pos=", rx1963_pos)
  debug_1253:
    .return (rx1963_cur)
  rx1963_restart:
.annotate 'line', 436
    if_null rx1963_debug, debug_1254
    rx1963_cur."!cursor_debug"("NEXT", "typename")
  debug_1254:
  rx1963_fail:
    (rx1963_rep, rx1963_pos, $I10, $P10) = rx1963_cur."!mark_fail"(0)
    lt rx1963_pos, -1, rx1963_done
    eq rx1963_pos, -1, rx1963_fail
    jump $I10
  rx1963_done:
    rx1963_cur."!cursor_fail"()
    if_null rx1963_debug, debug_1255
    rx1963_cur."!cursor_debug"("FAIL", "typename")
  debug_1255:
    .return (rx1963_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1967"  :anon :subid("196_1307873304.82979") :outer("195_1307873304.82979")
.annotate 'line', 828
    find_dynamic_lex $P1971, "$*ACTIONS"
    unless_null $P1971, vivify_1247
    get_hll_global $P1969, "GLOBAL"
    get_who $P1970, $P1969
    set $P1971, $P1970["$ACTIONS"]
    unless_null $P1971, vivify_1248
    die "Contextual $*ACTIONS not found"
  vivify_1248:
  vivify_1247:
    find_lex $P1972, "$/"
    unless_null $P1972, vivify_1249
    new $P1972, "Undef"
  vivify_1249:
    find_lex $P1973, "$/"
    unless_null $P1973, vivify_1250
    $P1973 = root_new ['parrot';'Hash']
  vivify_1250:
    set $P1974, $P1973["name"]
    unless_null $P1974, vivify_1251
    $P1974 = root_new ['parrot';'Hash']
  vivify_1251:
    set $P1975, $P1974["identifier"]
    unless_null $P1975, vivify_1252
    new $P1975, "Undef"
  vivify_1252:
    $P1976 = $P1971."known_sym"($P1972, $P1975)
    .return ($P1976)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__typename"  :subid("197_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P1979 = self."!PREFIX__!subrule"("name", "")
    new $P1980, "ResizablePMCArray"
    push $P1980, $P1979
    .return ($P1980)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "declarator"  :subid("198_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx1982_tgt
    .local int rx1982_pos
    .local int rx1982_off
    .local int rx1982_eos
    .local int rx1982_rep
    .local pmc rx1982_cur
    .local pmc rx1982_debug
    (rx1982_cur, rx1982_pos, rx1982_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1982_cur
    .local pmc match
    .lex "$/", match
    length rx1982_eos, rx1982_tgt
    gt rx1982_pos, rx1982_eos, rx1982_done
    set rx1982_off, 0
    lt rx1982_pos, 2, rx1982_start
    sub rx1982_off, rx1982_pos, 1
    substr rx1982_tgt, rx1982_tgt, rx1982_off
  rx1982_start:
    eq $I10, 1, rx1982_restart
    if_null rx1982_debug, debug_1256
    rx1982_cur."!cursor_debug"("START", "declarator")
  debug_1256:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1983_done
    goto rxscan1983_scan
  rxscan1983_loop:
    (rx1982_pos) = rx1982_cur."from"()
    inc rx1982_pos
    rx1982_cur."!cursor_from"(rx1982_pos)
    ge rx1982_pos, rx1982_eos, rxscan1983_done
  rxscan1983_scan:
    set_addr $I10, rxscan1983_loop
    rx1982_cur."!mark_push"(0, rx1982_pos, $I10)
  rxscan1983_done:
  alt1984_0:
.annotate 'line', 831
    set_addr $I10, alt1984_1
    rx1982_cur."!mark_push"(0, rx1982_pos, $I10)
.annotate 'line', 832
  # rx subrule "variable_declarator" subtype=capture negate=
    rx1982_cur."!cursor_pos"(rx1982_pos)
    $P10 = rx1982_cur."variable_declarator"()
    unless $P10, rx1982_fail
    rx1982_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable_declarator")
    rx1982_pos = $P10."pos"()
    goto alt1984_end
  alt1984_1:
.annotate 'line', 833
  # rx subrule "routine_declarator" subtype=capture negate=
    rx1982_cur."!cursor_pos"(rx1982_pos)
    $P10 = rx1982_cur."routine_declarator"()
    unless $P10, rx1982_fail
    rx1982_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx1982_pos = $P10."pos"()
  alt1984_end:
.annotate 'line', 831
  # rx pass
    rx1982_cur."!cursor_pass"(rx1982_pos, "declarator")
    if_null rx1982_debug, debug_1257
    rx1982_cur."!cursor_debug"("PASS", "declarator", " at pos=", rx1982_pos)
  debug_1257:
    .return (rx1982_cur)
  rx1982_restart:
.annotate 'line', 436
    if_null rx1982_debug, debug_1258
    rx1982_cur."!cursor_debug"("NEXT", "declarator")
  debug_1258:
  rx1982_fail:
    (rx1982_rep, rx1982_pos, $I10, $P10) = rx1982_cur."!mark_fail"(0)
    lt rx1982_pos, -1, rx1982_done
    eq rx1982_pos, -1, rx1982_fail
    jump $I10
  rx1982_done:
    rx1982_cur."!cursor_fail"()
    if_null rx1982_debug, debug_1259
    rx1982_cur."!cursor_debug"("FAIL", "declarator")
  debug_1259:
    .return (rx1982_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__declarator"  :subid("199_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P1986 = self."!PREFIX__!subrule"("routine_declarator", "")
    $P1987 = self."!PREFIX__!subrule"("variable_declarator", "")
    new $P1988, "ResizablePMCArray"
    push $P1988, $P1986
    push $P1988, $P1987
    .return ($P1988)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable_declarator"  :subid("200_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .const 'Sub' $P2003 = "201_1307873304.82979" 
    capture_lex $P2003
.annotate 'line', 838
    new $P1990, "Undef"
    .lex "$*IN_DECL", $P1990
.annotate 'line', 436
    .local string rx1991_tgt
    .local int rx1991_pos
    .local int rx1991_off
    .local int rx1991_eos
    .local int rx1991_rep
    .local pmc rx1991_cur
    .local pmc rx1991_debug
    (rx1991_cur, rx1991_pos, rx1991_tgt, $I10) = self."!cursor_start"()
    rx1991_cur."!cursor_caparray"("typename", "trait")
    .lex unicode:"$\x{a2}", rx1991_cur
    .local pmc match
    .lex "$/", match
    length rx1991_eos, rx1991_tgt
    gt rx1991_pos, rx1991_eos, rx1991_done
    set rx1991_off, 0
    lt rx1991_pos, 2, rx1991_start
    sub rx1991_off, rx1991_pos, 1
    substr rx1991_tgt, rx1991_tgt, rx1991_off
  rx1991_start:
    eq $I10, 1, rx1991_restart
    if_null rx1991_debug, debug_1260
    rx1991_cur."!cursor_debug"("START", "variable_declarator")
  debug_1260:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1992_done
    goto rxscan1992_scan
  rxscan1992_loop:
    (rx1991_pos) = rx1991_cur."from"()
    inc rx1991_pos
    rx1991_cur."!cursor_from"(rx1991_pos)
    ge rx1991_pos, rx1991_eos, rxscan1992_done
  rxscan1992_scan:
    set_addr $I10, rxscan1992_loop
    rx1991_cur."!mark_push"(0, rx1991_pos, $I10)
  rxscan1992_done:
.annotate 'line', 836
  # rx subrule "ws" subtype=method negate=
    rx1991_cur."!cursor_pos"(rx1991_pos)
    $P10 = rx1991_cur."ws"()
    unless $P10, rx1991_fail
    rx1991_pos = $P10."pos"()
.annotate 'line', 837
  # rx rxquantr1994 ** 0..1
    set_addr $I10, rxquantr1994_done
    rx1991_cur."!mark_push"(0, rx1991_pos, $I10)
  rxquantr1994_loop:
  # rx subrule "typename" subtype=capture negate=
    rx1991_cur."!cursor_pos"(rx1991_pos)
    $P10 = rx1991_cur."typename"()
    unless $P10, rx1991_fail
    goto rxsubrule1995_pass
  rxsubrule1995_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1991_fail
  rxsubrule1995_pass:
    set_addr $I10, rxsubrule1995_back
    rx1991_cur."!mark_push"(0, rx1991_pos, $I10, $P10)
    $P10."!cursor_names"("typename")
    rx1991_pos = $P10."pos"()
    set_addr $I10, rxquantr1994_done
    (rx1991_rep) = rx1991_cur."!mark_commit"($I10)
  rxquantr1994_done:
  # rx subrule "ws" subtype=method negate=
    rx1991_cur."!cursor_pos"(rx1991_pos)
    $P10 = rx1991_cur."ws"()
    unless $P10, rx1991_fail
    rx1991_pos = $P10."pos"()
.annotate 'line', 838
    rx1991_cur."!cursor_pos"(rx1991_pos)
    new $P1997, "String"
    assign $P1997, "variable"
    store_lex "$*IN_DECL", $P1997
  # rx subrule "ws" subtype=method negate=
    rx1991_cur."!cursor_pos"(rx1991_pos)
    $P10 = rx1991_cur."ws"()
    unless $P10, rx1991_fail
    rx1991_pos = $P10."pos"()
.annotate 'line', 839
  # rx subrule "variable" subtype=capture negate=
    rx1991_cur."!cursor_pos"(rx1991_pos)
    $P10 = rx1991_cur."variable"()
    unless $P10, rx1991_fail
    rx1991_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx1991_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1991_cur."!cursor_pos"(rx1991_pos)
    $P10 = rx1991_cur."ws"()
    unless $P10, rx1991_fail
    rx1991_pos = $P10."pos"()
.annotate 'line', 840
    rx1991_cur."!cursor_pos"(rx1991_pos)
    find_lex $P2000, unicode:"$\x{a2}"
    $P2001 = $P2000."MATCH"()
    store_lex "$/", $P2001
    .const 'Sub' $P2003 = "201_1307873304.82979" 
    capture_lex $P2003
    $P2005 = $P2003()
  # rx subrule "ws" subtype=method negate=
    rx1991_cur."!cursor_pos"(rx1991_pos)
    $P10 = rx1991_cur."ws"()
    unless $P10, rx1991_fail
    rx1991_pos = $P10."pos"()
.annotate 'line', 841
  # rx rxquantr2007 ** 0..*
    set_addr $I10, rxquantr2007_done
    rx1991_cur."!mark_push"(0, rx1991_pos, $I10)
  rxquantr2007_loop:
  # rx subrule "trait" subtype=capture negate=
    rx1991_cur."!cursor_pos"(rx1991_pos)
    $P10 = rx1991_cur."trait"()
    unless $P10, rx1991_fail
    goto rxsubrule2008_pass
  rxsubrule2008_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1991_fail
  rxsubrule2008_pass:
    set_addr $I10, rxsubrule2008_back
    rx1991_cur."!mark_push"(0, rx1991_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx1991_pos = $P10."pos"()
    set_addr $I10, rxquantr2007_done
    (rx1991_rep) = rx1991_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr2007_done
    rx1991_cur."!mark_push"(rx1991_rep, rx1991_pos, $I10)
    goto rxquantr2007_loop
  rxquantr2007_done:
  # rx subrule "ws" subtype=method negate=
    rx1991_cur."!cursor_pos"(rx1991_pos)
    $P10 = rx1991_cur."ws"()
    unless $P10, rx1991_fail
    rx1991_pos = $P10."pos"()
.annotate 'line', 836
  # rx pass
    rx1991_cur."!cursor_pass"(rx1991_pos, "variable_declarator")
    if_null rx1991_debug, debug_1261
    rx1991_cur."!cursor_debug"("PASS", "variable_declarator", " at pos=", rx1991_pos)
  debug_1261:
    .return (rx1991_cur)
  rx1991_restart:
.annotate 'line', 436
    if_null rx1991_debug, debug_1262
    rx1991_cur."!cursor_debug"("NEXT", "variable_declarator")
  debug_1262:
  rx1991_fail:
    (rx1991_rep, rx1991_pos, $I10, $P10) = rx1991_cur."!mark_fail"(0)
    lt rx1991_pos, -1, rx1991_done
    eq rx1991_pos, -1, rx1991_fail
    jump $I10
  rx1991_done:
    rx1991_cur."!cursor_fail"()
    if_null rx1991_debug, debug_1263
    rx1991_cur."!cursor_debug"("FAIL", "variable_declarator")
  debug_1263:
    .return (rx1991_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block2002"  :anon :subid("201_1307873304.82979") :outer("200_1307873304.82979")
.annotate 'line', 840
    new $P2004, "Integer"
    assign $P2004, 0
    store_dynamic_lex "$*IN_DECL", $P2004
    .return ($P2004)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable_declarator"  :subid("202_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2011 = self."!PREFIX__!subrule"("ws", "")
    new $P2012, "ResizablePMCArray"
    push $P2012, $P2011
    .return ($P2012)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator"  :subid("203_1307873304.82979")
    .param pmc param_2014
.annotate 'line', 844
    .lex "self", param_2014
    $P2015 = param_2014."!protoregex"("routine_declarator")
    .return ($P2015)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator"  :subid("204_1307873304.82979")
    .param pmc param_2017
.annotate 'line', 844
    .lex "self", param_2017
    $P2018 = param_2017."!PREFIX__!protoregex"("routine_declarator")
    .return ($P2018)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<sub>"  :subid("205_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2020_tgt
    .local int rx2020_pos
    .local int rx2020_off
    .local int rx2020_eos
    .local int rx2020_rep
    .local pmc rx2020_cur
    .local pmc rx2020_debug
    (rx2020_cur, rx2020_pos, rx2020_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2020_cur
    .local pmc match
    .lex "$/", match
    length rx2020_eos, rx2020_tgt
    gt rx2020_pos, rx2020_eos, rx2020_done
    set rx2020_off, 0
    lt rx2020_pos, 2, rx2020_start
    sub rx2020_off, rx2020_pos, 1
    substr rx2020_tgt, rx2020_tgt, rx2020_off
  rx2020_start:
    eq $I10, 1, rx2020_restart
    if_null rx2020_debug, debug_1264
    rx2020_cur."!cursor_debug"("START", "routine_declarator:sym<sub>")
  debug_1264:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2021_done
    goto rxscan2021_scan
  rxscan2021_loop:
    (rx2020_pos) = rx2020_cur."from"()
    inc rx2020_pos
    rx2020_cur."!cursor_from"(rx2020_pos)
    ge rx2020_pos, rx2020_eos, rxscan2021_done
  rxscan2021_scan:
    set_addr $I10, rxscan2021_loop
    rx2020_cur."!mark_push"(0, rx2020_pos, $I10)
  rxscan2021_done:
.annotate 'line', 845
  # rx subcapture "sym"
    set_addr $I10, rxcap_2022_fail
    rx2020_cur."!mark_push"(0, rx2020_pos, $I10)
  # rx literal  "sub"
    add $I11, rx2020_pos, 3
    gt $I11, rx2020_eos, rx2020_fail
    sub $I11, rx2020_pos, rx2020_off
    substr $S10, rx2020_tgt, $I11, 3
    ne $S10, "sub", rx2020_fail
    add rx2020_pos, 3
    set_addr $I10, rxcap_2022_fail
    ($I12, $I11) = rx2020_cur."!mark_peek"($I10)
    rx2020_cur."!cursor_pos"($I11)
    ($P10) = rx2020_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2020_pos, "")
    rx2020_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2022_done
  rxcap_2022_fail:
    goto rx2020_fail
  rxcap_2022_done:
  # rx subrule "routine_def" subtype=capture negate=
    rx2020_cur."!cursor_pos"(rx2020_pos)
    $P10 = rx2020_cur."routine_def"()
    unless $P10, rx2020_fail
    rx2020_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx2020_pos = $P10."pos"()
  # rx pass
    rx2020_cur."!cursor_pass"(rx2020_pos, "routine_declarator:sym<sub>")
    if_null rx2020_debug, debug_1265
    rx2020_cur."!cursor_debug"("PASS", "routine_declarator:sym<sub>", " at pos=", rx2020_pos)
  debug_1265:
    .return (rx2020_cur)
  rx2020_restart:
.annotate 'line', 436
    if_null rx2020_debug, debug_1266
    rx2020_cur."!cursor_debug"("NEXT", "routine_declarator:sym<sub>")
  debug_1266:
  rx2020_fail:
    (rx2020_rep, rx2020_pos, $I10, $P10) = rx2020_cur."!mark_fail"(0)
    lt rx2020_pos, -1, rx2020_done
    eq rx2020_pos, -1, rx2020_fail
    jump $I10
  rx2020_done:
    rx2020_cur."!cursor_fail"()
    if_null rx2020_debug, debug_1267
    rx2020_cur."!cursor_debug"("FAIL", "routine_declarator:sym<sub>")
  debug_1267:
    .return (rx2020_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<sub>"  :subid("206_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2024 = self."!PREFIX__!subrule"("routine_def", "sub")
    new $P2025, "ResizablePMCArray"
    push $P2025, $P2024
    .return ($P2025)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<method>"  :subid("207_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2027_tgt
    .local int rx2027_pos
    .local int rx2027_off
    .local int rx2027_eos
    .local int rx2027_rep
    .local pmc rx2027_cur
    .local pmc rx2027_debug
    (rx2027_cur, rx2027_pos, rx2027_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2027_cur
    .local pmc match
    .lex "$/", match
    length rx2027_eos, rx2027_tgt
    gt rx2027_pos, rx2027_eos, rx2027_done
    set rx2027_off, 0
    lt rx2027_pos, 2, rx2027_start
    sub rx2027_off, rx2027_pos, 1
    substr rx2027_tgt, rx2027_tgt, rx2027_off
  rx2027_start:
    eq $I10, 1, rx2027_restart
    if_null rx2027_debug, debug_1268
    rx2027_cur."!cursor_debug"("START", "routine_declarator:sym<method>")
  debug_1268:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2028_done
    goto rxscan2028_scan
  rxscan2028_loop:
    (rx2027_pos) = rx2027_cur."from"()
    inc rx2027_pos
    rx2027_cur."!cursor_from"(rx2027_pos)
    ge rx2027_pos, rx2027_eos, rxscan2028_done
  rxscan2028_scan:
    set_addr $I10, rxscan2028_loop
    rx2027_cur."!mark_push"(0, rx2027_pos, $I10)
  rxscan2028_done:
.annotate 'line', 846
  # rx subcapture "sym"
    set_addr $I10, rxcap_2029_fail
    rx2027_cur."!mark_push"(0, rx2027_pos, $I10)
  # rx literal  "method"
    add $I11, rx2027_pos, 6
    gt $I11, rx2027_eos, rx2027_fail
    sub $I11, rx2027_pos, rx2027_off
    substr $S10, rx2027_tgt, $I11, 6
    ne $S10, "method", rx2027_fail
    add rx2027_pos, 6
    set_addr $I10, rxcap_2029_fail
    ($I12, $I11) = rx2027_cur."!mark_peek"($I10)
    rx2027_cur."!cursor_pos"($I11)
    ($P10) = rx2027_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2027_pos, "")
    rx2027_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2029_done
  rxcap_2029_fail:
    goto rx2027_fail
  rxcap_2029_done:
  # rx subrule "method_def" subtype=capture negate=
    rx2027_cur."!cursor_pos"(rx2027_pos)
    $P10 = rx2027_cur."method_def"()
    unless $P10, rx2027_fail
    rx2027_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("method_def")
    rx2027_pos = $P10."pos"()
  # rx pass
    rx2027_cur."!cursor_pass"(rx2027_pos, "routine_declarator:sym<method>")
    if_null rx2027_debug, debug_1269
    rx2027_cur."!cursor_debug"("PASS", "routine_declarator:sym<method>", " at pos=", rx2027_pos)
  debug_1269:
    .return (rx2027_cur)
  rx2027_restart:
.annotate 'line', 436
    if_null rx2027_debug, debug_1270
    rx2027_cur."!cursor_debug"("NEXT", "routine_declarator:sym<method>")
  debug_1270:
  rx2027_fail:
    (rx2027_rep, rx2027_pos, $I10, $P10) = rx2027_cur."!mark_fail"(0)
    lt rx2027_pos, -1, rx2027_done
    eq rx2027_pos, -1, rx2027_fail
    jump $I10
  rx2027_done:
    rx2027_cur."!cursor_fail"()
    if_null rx2027_debug, debug_1271
    rx2027_cur."!cursor_debug"("FAIL", "routine_declarator:sym<method>")
  debug_1271:
    .return (rx2027_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<method>"  :subid("208_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2031 = self."!PREFIX__!subrule"("method_def", "method")
    new $P2032, "ResizablePMCArray"
    push $P2032, $P2031
    .return ($P2032)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_def"  :subid("209_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 849
    new $P2034, "Undef"
    .lex "$*RETURN_USED", $P2034
.annotate 'line', 436
    .local string rx2035_tgt
    .local int rx2035_pos
    .local int rx2035_off
    .local int rx2035_eos
    .local int rx2035_rep
    .local pmc rx2035_cur
    .local pmc rx2035_debug
    (rx2035_cur, rx2035_pos, rx2035_tgt, $I10) = self."!cursor_start"()
    rx2035_cur."!cursor_caparray"("sigil", "deflongname", "trait")
    .lex unicode:"$\x{a2}", rx2035_cur
    .local pmc match
    .lex "$/", match
    length rx2035_eos, rx2035_tgt
    gt rx2035_pos, rx2035_eos, rx2035_done
    set rx2035_off, 0
    lt rx2035_pos, 2, rx2035_start
    sub rx2035_off, rx2035_pos, 1
    substr rx2035_tgt, rx2035_tgt, rx2035_off
  rx2035_start:
    eq $I10, 1, rx2035_restart
    if_null rx2035_debug, debug_1272
    rx2035_cur."!cursor_debug"("START", "routine_def")
  debug_1272:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2036_done
    goto rxscan2036_scan
  rxscan2036_loop:
    (rx2035_pos) = rx2035_cur."from"()
    inc rx2035_pos
    rx2035_cur."!cursor_from"(rx2035_pos)
    ge rx2035_pos, rx2035_eos, rxscan2036_done
  rxscan2036_scan:
    set_addr $I10, rxscan2036_loop
    rx2035_cur."!mark_push"(0, rx2035_pos, $I10)
  rxscan2036_done:
.annotate 'line', 848
  # rx subrule "ws" subtype=method negate=
    rx2035_cur."!cursor_pos"(rx2035_pos)
    $P10 = rx2035_cur."ws"()
    unless $P10, rx2035_fail
    rx2035_pos = $P10."pos"()
.annotate 'line', 849
    rx2035_cur."!cursor_pos"(rx2035_pos)
    new $P2038, "Integer"
    assign $P2038, 0
    store_lex "$*RETURN_USED", $P2038
  # rx subrule "ws" subtype=method negate=
    rx2035_cur."!cursor_pos"(rx2035_pos)
    $P10 = rx2035_cur."ws"()
    unless $P10, rx2035_fail
    rx2035_pos = $P10."pos"()
.annotate 'line', 850
  # rx rxquantr2040 ** 0..1
    set_addr $I10, rxquantr2040_done
    rx2035_cur."!mark_push"(0, rx2035_pos, $I10)
  rxquantr2040_loop:
  # rx subrule "ws" subtype=method negate=
    rx2035_cur."!cursor_pos"(rx2035_pos)
    $P10 = rx2035_cur."ws"()
    unless $P10, rx2035_fail
    rx2035_pos = $P10."pos"()
  # rx subcapture "sigil"
    set_addr $I10, rxcap_2043_fail
    rx2035_cur."!mark_push"(0, rx2035_pos, $I10)
  # rx rxquantr2042 ** 0..1
    set_addr $I10, rxquantr2042_done
    rx2035_cur."!mark_push"(0, rx2035_pos, $I10)
  rxquantr2042_loop:
  # rx literal  "&"
    add $I11, rx2035_pos, 1
    gt $I11, rx2035_eos, rx2035_fail
    sub $I11, rx2035_pos, rx2035_off
    ord $I11, rx2035_tgt, $I11
    ne $I11, 38, rx2035_fail
    add rx2035_pos, 1
    set_addr $I10, rxquantr2042_done
    (rx2035_rep) = rx2035_cur."!mark_commit"($I10)
  rxquantr2042_done:
    set_addr $I10, rxcap_2043_fail
    ($I12, $I11) = rx2035_cur."!mark_peek"($I10)
    rx2035_cur."!cursor_pos"($I11)
    ($P10) = rx2035_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2035_pos, "")
    rx2035_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_2043_done
  rxcap_2043_fail:
    goto rx2035_fail
  rxcap_2043_done:
  # rx subrule "deflongname" subtype=capture negate=
    rx2035_cur."!cursor_pos"(rx2035_pos)
    $P10 = rx2035_cur."deflongname"()
    unless $P10, rx2035_fail
    rx2035_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx2035_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2035_cur."!cursor_pos"(rx2035_pos)
    $P10 = rx2035_cur."ws"()
    unless $P10, rx2035_fail
    rx2035_pos = $P10."pos"()
    set_addr $I10, rxquantr2040_done
    (rx2035_rep) = rx2035_cur."!mark_commit"($I10)
  rxquantr2040_done:
  # rx subrule "ws" subtype=method negate=
    rx2035_cur."!cursor_pos"(rx2035_pos)
    $P10 = rx2035_cur."ws"()
    unless $P10, rx2035_fail
    rx2035_pos = $P10."pos"()
.annotate 'line', 851
  # rx subrule "newpad" subtype=method negate=
    rx2035_cur."!cursor_pos"(rx2035_pos)
    $P10 = rx2035_cur."newpad"()
    unless $P10, rx2035_fail
    rx2035_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2035_cur."!cursor_pos"(rx2035_pos)
    $P10 = rx2035_cur."ws"()
    unless $P10, rx2035_fail
    rx2035_pos = $P10."pos"()
  alt2047_0:
.annotate 'line', 852
    set_addr $I10, alt2047_1
    rx2035_cur."!mark_push"(0, rx2035_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx2035_cur."!cursor_pos"(rx2035_pos)
    $P10 = rx2035_cur."ws"()
    unless $P10, rx2035_fail
    rx2035_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx2035_pos, 1
    gt $I11, rx2035_eos, rx2035_fail
    sub $I11, rx2035_pos, rx2035_off
    ord $I11, rx2035_tgt, $I11
    ne $I11, 40, rx2035_fail
    add rx2035_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2035_cur."!cursor_pos"(rx2035_pos)
    $P10 = rx2035_cur."ws"()
    unless $P10, rx2035_fail
    rx2035_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx2035_cur."!cursor_pos"(rx2035_pos)
    $P10 = rx2035_cur."signature"()
    unless $P10, rx2035_fail
    rx2035_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx2035_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2035_cur."!cursor_pos"(rx2035_pos)
    $P10 = rx2035_cur."ws"()
    unless $P10, rx2035_fail
    rx2035_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx2035_pos, 1
    gt $I11, rx2035_eos, rx2035_fail
    sub $I11, rx2035_pos, rx2035_off
    ord $I11, rx2035_tgt, $I11
    ne $I11, 41, rx2035_fail
    add rx2035_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2035_cur."!cursor_pos"(rx2035_pos)
    $P10 = rx2035_cur."ws"()
    unless $P10, rx2035_fail
    rx2035_pos = $P10."pos"()
    goto alt2047_end
  alt2047_1:
.annotate 'line', 853
  # rx subrule "ws" subtype=method negate=
    rx2035_cur."!cursor_pos"(rx2035_pos)
    $P10 = rx2035_cur."ws"()
    unless $P10, rx2035_fail
    rx2035_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx2035_cur."!cursor_pos"(rx2035_pos)
    $P10 = rx2035_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx2035_fail
    rx2035_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2035_cur."!cursor_pos"(rx2035_pos)
    $P10 = rx2035_cur."ws"()
    unless $P10, rx2035_fail
    rx2035_pos = $P10."pos"()
  alt2047_end:
  # rx subrule "ws" subtype=method negate=
    rx2035_cur."!cursor_pos"(rx2035_pos)
    $P10 = rx2035_cur."ws"()
    unless $P10, rx2035_fail
    rx2035_pos = $P10."pos"()
.annotate 'line', 854
  # rx rxquantr2055 ** 0..*
    set_addr $I10, rxquantr2055_done
    rx2035_cur."!mark_push"(0, rx2035_pos, $I10)
  rxquantr2055_loop:
  # rx subrule "trait" subtype=capture negate=
    rx2035_cur."!cursor_pos"(rx2035_pos)
    $P10 = rx2035_cur."trait"()
    unless $P10, rx2035_fail
    goto rxsubrule2056_pass
  rxsubrule2056_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx2035_fail
  rxsubrule2056_pass:
    set_addr $I10, rxsubrule2056_back
    rx2035_cur."!mark_push"(0, rx2035_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx2035_pos = $P10."pos"()
    set_addr $I10, rxquantr2055_done
    (rx2035_rep) = rx2035_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr2055_done
    rx2035_cur."!mark_push"(rx2035_rep, rx2035_pos, $I10)
    goto rxquantr2055_loop
  rxquantr2055_done:
  # rx subrule "ws" subtype=method negate=
    rx2035_cur."!cursor_pos"(rx2035_pos)
    $P10 = rx2035_cur."ws"()
    unless $P10, rx2035_fail
    rx2035_pos = $P10."pos"()
  alt2058_0:
.annotate 'line', 855
    set_addr $I10, alt2058_1
    rx2035_cur."!mark_push"(0, rx2035_pos, $I10)
.annotate 'line', 856
  # rx subrule "ws" subtype=method negate=
    rx2035_cur."!cursor_pos"(rx2035_pos)
    $P10 = rx2035_cur."ws"()
    unless $P10, rx2035_fail
    rx2035_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx2035_cur."!cursor_pos"(rx2035_pos)
    $P10 = rx2035_cur."onlystar"()
    unless $P10, rx2035_fail
    rx2035_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx2035_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2035_cur."!cursor_pos"(rx2035_pos)
    $P10 = rx2035_cur."ws"()
    unless $P10, rx2035_fail
    rx2035_pos = $P10."pos"()
    goto alt2058_end
  alt2058_1:
.annotate 'line', 857
  # rx subrule "ws" subtype=method negate=
    rx2035_cur."!cursor_pos"(rx2035_pos)
    $P10 = rx2035_cur."ws"()
    unless $P10, rx2035_fail
    rx2035_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx2035_cur."!cursor_pos"(rx2035_pos)
    $P10 = rx2035_cur."blockoid"()
    unless $P10, rx2035_fail
    rx2035_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx2035_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2035_cur."!cursor_pos"(rx2035_pos)
    $P10 = rx2035_cur."ws"()
    unless $P10, rx2035_fail
    rx2035_pos = $P10."pos"()
  alt2058_end:
.annotate 'line', 858
  # rx subrule "ws" subtype=method negate=
    rx2035_cur."!cursor_pos"(rx2035_pos)
    $P10 = rx2035_cur."ws"()
    unless $P10, rx2035_fail
    rx2035_pos = $P10."pos"()
.annotate 'line', 848
  # rx pass
    rx2035_cur."!cursor_pass"(rx2035_pos, "routine_def")
    if_null rx2035_debug, debug_1273
    rx2035_cur."!cursor_debug"("PASS", "routine_def", " at pos=", rx2035_pos)
  debug_1273:
    .return (rx2035_cur)
  rx2035_restart:
.annotate 'line', 436
    if_null rx2035_debug, debug_1274
    rx2035_cur."!cursor_debug"("NEXT", "routine_def")
  debug_1274:
  rx2035_fail:
    (rx2035_rep, rx2035_pos, $I10, $P10) = rx2035_cur."!mark_fail"(0)
    lt rx2035_pos, -1, rx2035_done
    eq rx2035_pos, -1, rx2035_fail
    jump $I10
  rx2035_done:
    rx2035_cur."!cursor_fail"()
    if_null rx2035_debug, debug_1275
    rx2035_cur."!cursor_debug"("FAIL", "routine_def")
  debug_1275:
    .return (rx2035_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_def"  :subid("210_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2065 = self."!PREFIX__!subrule"("ws", "")
    new $P2066, "ResizablePMCArray"
    push $P2066, $P2065
    .return ($P2066)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "method_def"  :subid("211_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .const 'Sub' $P2095 = "212_1307873304.82979" 
    capture_lex $P2095
.annotate 'line', 862
    new $P2068, "Undef"
    .lex "$*RETURN_USED", $P2068
.annotate 'line', 863
    new $P2069, "Undef"
    .lex "$*INVOCANT_OK", $P2069
.annotate 'line', 436
    .local string rx2070_tgt
    .local int rx2070_pos
    .local int rx2070_off
    .local int rx2070_eos
    .local int rx2070_rep
    .local pmc rx2070_cur
    .local pmc rx2070_debug
    (rx2070_cur, rx2070_pos, rx2070_tgt, $I10) = self."!cursor_start"()
    rx2070_cur."!cursor_caparray"("deflongname", "trait")
    .lex unicode:"$\x{a2}", rx2070_cur
    .local pmc match
    .lex "$/", match
    length rx2070_eos, rx2070_tgt
    gt rx2070_pos, rx2070_eos, rx2070_done
    set rx2070_off, 0
    lt rx2070_pos, 2, rx2070_start
    sub rx2070_off, rx2070_pos, 1
    substr rx2070_tgt, rx2070_tgt, rx2070_off
  rx2070_start:
    eq $I10, 1, rx2070_restart
    if_null rx2070_debug, debug_1276
    rx2070_cur."!cursor_debug"("START", "method_def")
  debug_1276:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2071_done
    goto rxscan2071_scan
  rxscan2071_loop:
    (rx2070_pos) = rx2070_cur."from"()
    inc rx2070_pos
    rx2070_cur."!cursor_from"(rx2070_pos)
    ge rx2070_pos, rx2070_eos, rxscan2071_done
  rxscan2071_scan:
    set_addr $I10, rxscan2071_loop
    rx2070_cur."!mark_push"(0, rx2070_pos, $I10)
  rxscan2071_done:
.annotate 'line', 861
  # rx subrule "ws" subtype=method negate=
    rx2070_cur."!cursor_pos"(rx2070_pos)
    $P10 = rx2070_cur."ws"()
    unless $P10, rx2070_fail
    rx2070_pos = $P10."pos"()
.annotate 'line', 862
    rx2070_cur."!cursor_pos"(rx2070_pos)
    new $P2073, "Integer"
    assign $P2073, 0
    store_lex "$*RETURN_USED", $P2073
  # rx subrule "ws" subtype=method negate=
    rx2070_cur."!cursor_pos"(rx2070_pos)
    $P10 = rx2070_cur."ws"()
    unless $P10, rx2070_fail
    rx2070_pos = $P10."pos"()
.annotate 'line', 863
    rx2070_cur."!cursor_pos"(rx2070_pos)
    new $P2075, "Integer"
    assign $P2075, 1
    store_lex "$*INVOCANT_OK", $P2075
  # rx subrule "ws" subtype=method negate=
    rx2070_cur."!cursor_pos"(rx2070_pos)
    $P10 = rx2070_cur."ws"()
    unless $P10, rx2070_fail
    rx2070_pos = $P10."pos"()
.annotate 'line', 864
  # rx subcapture "private"
    set_addr $I10, rxcap_2078_fail
    rx2070_cur."!mark_push"(0, rx2070_pos, $I10)
  # rx rxquantr2077 ** 0..1
    set_addr $I10, rxquantr2077_done
    rx2070_cur."!mark_push"(0, rx2070_pos, $I10)
  rxquantr2077_loop:
  # rx literal  "!"
    add $I11, rx2070_pos, 1
    gt $I11, rx2070_eos, rx2070_fail
    sub $I11, rx2070_pos, rx2070_off
    ord $I11, rx2070_tgt, $I11
    ne $I11, 33, rx2070_fail
    add rx2070_pos, 1
    set_addr $I10, rxquantr2077_done
    (rx2070_rep) = rx2070_cur."!mark_commit"($I10)
  rxquantr2077_done:
    set_addr $I10, rxcap_2078_fail
    ($I12, $I11) = rx2070_cur."!mark_peek"($I10)
    rx2070_cur."!cursor_pos"($I11)
    ($P10) = rx2070_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2070_pos, "")
    rx2070_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("private")
    goto rxcap_2078_done
  rxcap_2078_fail:
    goto rx2070_fail
  rxcap_2078_done:
  # rx subrule "ws" subtype=method negate=
    rx2070_cur."!cursor_pos"(rx2070_pos)
    $P10 = rx2070_cur."ws"()
    unless $P10, rx2070_fail
    rx2070_pos = $P10."pos"()
.annotate 'line', 865
  # rx rxquantr2080 ** 0..1
    set_addr $I10, rxquantr2080_done
    rx2070_cur."!mark_push"(0, rx2070_pos, $I10)
  rxquantr2080_loop:
  # rx subrule "deflongname" subtype=capture negate=
    rx2070_cur."!cursor_pos"(rx2070_pos)
    $P10 = rx2070_cur."deflongname"()
    unless $P10, rx2070_fail
    goto rxsubrule2081_pass
  rxsubrule2081_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx2070_fail
  rxsubrule2081_pass:
    set_addr $I10, rxsubrule2081_back
    rx2070_cur."!mark_push"(0, rx2070_pos, $I10, $P10)
    $P10."!cursor_names"("deflongname")
    rx2070_pos = $P10."pos"()
    set_addr $I10, rxquantr2080_done
    (rx2070_rep) = rx2070_cur."!mark_commit"($I10)
  rxquantr2080_done:
  # rx subrule "ws" subtype=method negate=
    rx2070_cur."!cursor_pos"(rx2070_pos)
    $P10 = rx2070_cur."ws"()
    unless $P10, rx2070_fail
    rx2070_pos = $P10."pos"()
.annotate 'line', 866
  # rx subrule "newpad" subtype=method negate=
    rx2070_cur."!cursor_pos"(rx2070_pos)
    $P10 = rx2070_cur."newpad"()
    unless $P10, rx2070_fail
    rx2070_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2070_cur."!cursor_pos"(rx2070_pos)
    $P10 = rx2070_cur."ws"()
    unless $P10, rx2070_fail
    rx2070_pos = $P10."pos"()
  alt2084_0:
.annotate 'line', 867
    set_addr $I10, alt2084_1
    rx2070_cur."!mark_push"(0, rx2070_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx2070_cur."!cursor_pos"(rx2070_pos)
    $P10 = rx2070_cur."ws"()
    unless $P10, rx2070_fail
    rx2070_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx2070_pos, 1
    gt $I11, rx2070_eos, rx2070_fail
    sub $I11, rx2070_pos, rx2070_off
    ord $I11, rx2070_tgt, $I11
    ne $I11, 40, rx2070_fail
    add rx2070_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2070_cur."!cursor_pos"(rx2070_pos)
    $P10 = rx2070_cur."ws"()
    unless $P10, rx2070_fail
    rx2070_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx2070_cur."!cursor_pos"(rx2070_pos)
    $P10 = rx2070_cur."signature"()
    unless $P10, rx2070_fail
    rx2070_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx2070_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2070_cur."!cursor_pos"(rx2070_pos)
    $P10 = rx2070_cur."ws"()
    unless $P10, rx2070_fail
    rx2070_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx2070_pos, 1
    gt $I11, rx2070_eos, rx2070_fail
    sub $I11, rx2070_pos, rx2070_off
    ord $I11, rx2070_tgt, $I11
    ne $I11, 41, rx2070_fail
    add rx2070_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2070_cur."!cursor_pos"(rx2070_pos)
    $P10 = rx2070_cur."ws"()
    unless $P10, rx2070_fail
    rx2070_pos = $P10."pos"()
    goto alt2084_end
  alt2084_1:
.annotate 'line', 868
  # rx subrule "ws" subtype=method negate=
    rx2070_cur."!cursor_pos"(rx2070_pos)
    $P10 = rx2070_cur."ws"()
    unless $P10, rx2070_fail
    rx2070_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx2070_cur."!cursor_pos"(rx2070_pos)
    $P10 = rx2070_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx2070_fail
    rx2070_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2070_cur."!cursor_pos"(rx2070_pos)
    $P10 = rx2070_cur."ws"()
    unless $P10, rx2070_fail
    rx2070_pos = $P10."pos"()
  alt2084_end:
  # rx subrule "ws" subtype=method negate=
    rx2070_cur."!cursor_pos"(rx2070_pos)
    $P10 = rx2070_cur."ws"()
    unless $P10, rx2070_fail
    rx2070_pos = $P10."pos"()
.annotate 'line', 869
    rx2070_cur."!cursor_pos"(rx2070_pos)
    find_lex $P2092, unicode:"$\x{a2}"
    $P2093 = $P2092."MATCH"()
    store_lex "$/", $P2093
    .const 'Sub' $P2095 = "212_1307873304.82979" 
    capture_lex $P2095
    $P2097 = $P2095()
  # rx subrule "ws" subtype=method negate=
    rx2070_cur."!cursor_pos"(rx2070_pos)
    $P10 = rx2070_cur."ws"()
    unless $P10, rx2070_fail
    rx2070_pos = $P10."pos"()
.annotate 'line', 870
  # rx rxquantr2099 ** 0..*
    set_addr $I10, rxquantr2099_done
    rx2070_cur."!mark_push"(0, rx2070_pos, $I10)
  rxquantr2099_loop:
  # rx subrule "trait" subtype=capture negate=
    rx2070_cur."!cursor_pos"(rx2070_pos)
    $P10 = rx2070_cur."trait"()
    unless $P10, rx2070_fail
    goto rxsubrule2100_pass
  rxsubrule2100_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx2070_fail
  rxsubrule2100_pass:
    set_addr $I10, rxsubrule2100_back
    rx2070_cur."!mark_push"(0, rx2070_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx2070_pos = $P10."pos"()
    set_addr $I10, rxquantr2099_done
    (rx2070_rep) = rx2070_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr2099_done
    rx2070_cur."!mark_push"(rx2070_rep, rx2070_pos, $I10)
    goto rxquantr2099_loop
  rxquantr2099_done:
  # rx subrule "ws" subtype=method negate=
    rx2070_cur."!cursor_pos"(rx2070_pos)
    $P10 = rx2070_cur."ws"()
    unless $P10, rx2070_fail
    rx2070_pos = $P10."pos"()
  alt2102_0:
.annotate 'line', 871
    set_addr $I10, alt2102_1
    rx2070_cur."!mark_push"(0, rx2070_pos, $I10)
.annotate 'line', 872
  # rx subrule "ws" subtype=method negate=
    rx2070_cur."!cursor_pos"(rx2070_pos)
    $P10 = rx2070_cur."ws"()
    unless $P10, rx2070_fail
    rx2070_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx2070_cur."!cursor_pos"(rx2070_pos)
    $P10 = rx2070_cur."onlystar"()
    unless $P10, rx2070_fail
    rx2070_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx2070_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2070_cur."!cursor_pos"(rx2070_pos)
    $P10 = rx2070_cur."ws"()
    unless $P10, rx2070_fail
    rx2070_pos = $P10."pos"()
    goto alt2102_end
  alt2102_1:
.annotate 'line', 873
  # rx subrule "ws" subtype=method negate=
    rx2070_cur."!cursor_pos"(rx2070_pos)
    $P10 = rx2070_cur."ws"()
    unless $P10, rx2070_fail
    rx2070_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx2070_cur."!cursor_pos"(rx2070_pos)
    $P10 = rx2070_cur."blockoid"()
    unless $P10, rx2070_fail
    rx2070_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx2070_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2070_cur."!cursor_pos"(rx2070_pos)
    $P10 = rx2070_cur."ws"()
    unless $P10, rx2070_fail
    rx2070_pos = $P10."pos"()
  alt2102_end:
.annotate 'line', 874
  # rx subrule "ws" subtype=method negate=
    rx2070_cur."!cursor_pos"(rx2070_pos)
    $P10 = rx2070_cur."ws"()
    unless $P10, rx2070_fail
    rx2070_pos = $P10."pos"()
.annotate 'line', 861
  # rx pass
    rx2070_cur."!cursor_pass"(rx2070_pos, "method_def")
    if_null rx2070_debug, debug_1277
    rx2070_cur."!cursor_debug"("PASS", "method_def", " at pos=", rx2070_pos)
  debug_1277:
    .return (rx2070_cur)
  rx2070_restart:
.annotate 'line', 436
    if_null rx2070_debug, debug_1278
    rx2070_cur."!cursor_debug"("NEXT", "method_def")
  debug_1278:
  rx2070_fail:
    (rx2070_rep, rx2070_pos, $I10, $P10) = rx2070_cur."!mark_fail"(0)
    lt rx2070_pos, -1, rx2070_done
    eq rx2070_pos, -1, rx2070_fail
    jump $I10
  rx2070_done:
    rx2070_cur."!cursor_fail"()
    if_null rx2070_debug, debug_1279
    rx2070_cur."!cursor_debug"("FAIL", "method_def")
  debug_1279:
    .return (rx2070_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block2094"  :anon :subid("212_1307873304.82979") :outer("211_1307873304.82979")
.annotate 'line', 869
    new $P2096, "Integer"
    assign $P2096, 0
    store_dynamic_lex "$*INVOCANT_OK", $P2096
    .return ($P2096)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__method_def"  :subid("213_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2109 = self."!PREFIX__!subrule"("ws", "")
    new $P2110, "ResizablePMCArray"
    push $P2110, $P2109
    .return ($P2110)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "onlystar"  :subid("214_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .const 'Sub' $P2117 = "215_1307873304.82979" 
    capture_lex $P2117
    .local string rx2112_tgt
    .local int rx2112_pos
    .local int rx2112_off
    .local int rx2112_eos
    .local int rx2112_rep
    .local pmc rx2112_cur
    .local pmc rx2112_debug
    (rx2112_cur, rx2112_pos, rx2112_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2112_cur
    .local pmc match
    .lex "$/", match
    length rx2112_eos, rx2112_tgt
    gt rx2112_pos, rx2112_eos, rx2112_done
    set rx2112_off, 0
    lt rx2112_pos, 2, rx2112_start
    sub rx2112_off, rx2112_pos, 1
    substr rx2112_tgt, rx2112_tgt, rx2112_off
  rx2112_start:
    eq $I10, 1, rx2112_restart
    if_null rx2112_debug, debug_1280
    rx2112_cur."!cursor_debug"("START", "onlystar")
  debug_1280:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2113_done
    goto rxscan2113_scan
  rxscan2113_loop:
    (rx2112_pos) = rx2112_cur."from"()
    inc rx2112_pos
    rx2112_cur."!cursor_from"(rx2112_pos)
    ge rx2112_pos, rx2112_eos, rxscan2113_done
  rxscan2113_scan:
    set_addr $I10, rxscan2113_loop
    rx2112_cur."!mark_push"(0, rx2112_pos, $I10)
  rxscan2113_done:
.annotate 'line', 878
    rx2112_cur."!cursor_pos"(rx2112_pos)
    find_lex $P2114, unicode:"$\x{a2}"
    $P2115 = $P2114."MATCH"()
    store_lex "$/", $P2115
    .const 'Sub' $P2117 = "215_1307873304.82979" 
    capture_lex $P2117
    $P2123 = $P2117()
    unless $P2123, rx2112_fail
.annotate 'line', 879
  # rx literal  "{"
    add $I11, rx2112_pos, 1
    gt $I11, rx2112_eos, rx2112_fail
    sub $I11, rx2112_pos, rx2112_off
    ord $I11, rx2112_tgt, $I11
    ne $I11, 123, rx2112_fail
    add rx2112_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2112_cur."!cursor_pos"(rx2112_pos)
    $P10 = rx2112_cur."ws"()
    unless $P10, rx2112_fail
    rx2112_pos = $P10."pos"()
  # rx literal  "*"
    add $I11, rx2112_pos, 1
    gt $I11, rx2112_eos, rx2112_fail
    sub $I11, rx2112_pos, rx2112_off
    ord $I11, rx2112_tgt, $I11
    ne $I11, 42, rx2112_fail
    add rx2112_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2112_cur."!cursor_pos"(rx2112_pos)
    $P10 = rx2112_cur."ws"()
    unless $P10, rx2112_fail
    rx2112_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx2112_pos, 1
    gt $I11, rx2112_eos, rx2112_fail
    sub $I11, rx2112_pos, rx2112_off
    ord $I11, rx2112_tgt, $I11
    ne $I11, 125, rx2112_fail
    add rx2112_pos, 1
.annotate 'line', 880
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx2112_cur."!cursor_pos"(rx2112_pos)
    $P10 = rx2112_cur."ENDSTMT"()
    unless $P10, rx2112_fail
.annotate 'line', 881
  # rx subrule "finishpad" subtype=method negate=
    rx2112_cur."!cursor_pos"(rx2112_pos)
    $P10 = rx2112_cur."finishpad"()
    unless $P10, rx2112_fail
    rx2112_pos = $P10."pos"()
.annotate 'line', 877
  # rx pass
    rx2112_cur."!cursor_pass"(rx2112_pos, "onlystar")
    if_null rx2112_debug, debug_1283
    rx2112_cur."!cursor_debug"("PASS", "onlystar", " at pos=", rx2112_pos)
  debug_1283:
    .return (rx2112_cur)
  rx2112_restart:
.annotate 'line', 436
    if_null rx2112_debug, debug_1284
    rx2112_cur."!cursor_debug"("NEXT", "onlystar")
  debug_1284:
  rx2112_fail:
    (rx2112_rep, rx2112_pos, $I10, $P10) = rx2112_cur."!mark_fail"(0)
    lt rx2112_pos, -1, rx2112_done
    eq rx2112_pos, -1, rx2112_fail
    jump $I10
  rx2112_done:
    rx2112_cur."!cursor_fail"()
    if_null rx2112_debug, debug_1285
    rx2112_cur."!cursor_debug"("FAIL", "onlystar")
  debug_1285:
    .return (rx2112_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block2116"  :anon :subid("215_1307873304.82979") :outer("214_1307873304.82979")
.annotate 'line', 878
    find_dynamic_lex $P2120, "$*MULTINESS"
    unless_null $P2120, vivify_1281
    get_hll_global $P2118, "GLOBAL"
    get_who $P2119, $P2118
    set $P2120, $P2119["$MULTINESS"]
    unless_null $P2120, vivify_1282
    die "Contextual $*MULTINESS not found"
  vivify_1282:
  vivify_1281:
    set $S2121, $P2120
    iseq $I2122, $S2121, "proto"
    .return ($I2122)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__onlystar"  :subid("216_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    new $P2125, "ResizablePMCArray"
    push $P2125, ""
    .return ($P2125)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator"  :subid("217_1307873304.82979")
    .param pmc param_2127
.annotate 'line', 884
    .lex "self", param_2127
    $P2128 = param_2127."!protoregex"("multi_declarator")
    .return ($P2128)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator"  :subid("218_1307873304.82979")
    .param pmc param_2130
.annotate 'line', 884
    .lex "self", param_2130
    $P2131 = param_2130."!PREFIX__!protoregex"("multi_declarator")
    .return ($P2131)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<multi>"  :subid("219_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 886
    new $P2133, "Undef"
    .lex "$*MULTINESS", $P2133
.annotate 'line', 436
    .local string rx2134_tgt
    .local int rx2134_pos
    .local int rx2134_off
    .local int rx2134_eos
    .local int rx2134_rep
    .local pmc rx2134_cur
    .local pmc rx2134_debug
    (rx2134_cur, rx2134_pos, rx2134_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2134_cur
    .local pmc match
    .lex "$/", match
    length rx2134_eos, rx2134_tgt
    gt rx2134_pos, rx2134_eos, rx2134_done
    set rx2134_off, 0
    lt rx2134_pos, 2, rx2134_start
    sub rx2134_off, rx2134_pos, 1
    substr rx2134_tgt, rx2134_tgt, rx2134_off
  rx2134_start:
    eq $I10, 1, rx2134_restart
    if_null rx2134_debug, debug_1286
    rx2134_cur."!cursor_debug"("START", "multi_declarator:sym<multi>")
  debug_1286:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2135_done
    goto rxscan2135_scan
  rxscan2135_loop:
    (rx2134_pos) = rx2134_cur."from"()
    inc rx2134_pos
    rx2134_cur."!cursor_from"(rx2134_pos)
    ge rx2134_pos, rx2134_eos, rxscan2135_done
  rxscan2135_scan:
    set_addr $I10, rxscan2135_loop
    rx2134_cur."!mark_push"(0, rx2134_pos, $I10)
  rxscan2135_done:
.annotate 'line', 886
    rx2134_cur."!cursor_pos"(rx2134_pos)
    new $P2136, "String"
    assign $P2136, "multi"
    store_lex "$*MULTINESS", $P2136
.annotate 'line', 887
  # rx subcapture "sym"
    set_addr $I10, rxcap_2137_fail
    rx2134_cur."!mark_push"(0, rx2134_pos, $I10)
  # rx literal  "multi"
    add $I11, rx2134_pos, 5
    gt $I11, rx2134_eos, rx2134_fail
    sub $I11, rx2134_pos, rx2134_off
    substr $S10, rx2134_tgt, $I11, 5
    ne $S10, "multi", rx2134_fail
    add rx2134_pos, 5
    set_addr $I10, rxcap_2137_fail
    ($I12, $I11) = rx2134_cur."!mark_peek"($I10)
    rx2134_cur."!cursor_pos"($I11)
    ($P10) = rx2134_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2134_pos, "")
    rx2134_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2137_done
  rxcap_2137_fail:
    goto rx2134_fail
  rxcap_2137_done:
.annotate 'line', 888
  # rx subrule "ws" subtype=method negate=
    rx2134_cur."!cursor_pos"(rx2134_pos)
    $P10 = rx2134_cur."ws"()
    unless $P10, rx2134_fail
    rx2134_pos = $P10."pos"()
  alt2138_0:
    set_addr $I10, alt2138_1
    rx2134_cur."!mark_push"(0, rx2134_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx2134_cur."!cursor_pos"(rx2134_pos)
    $P10 = rx2134_cur."declarator"()
    unless $P10, rx2134_fail
    rx2134_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx2134_pos = $P10."pos"()
    goto alt2138_end
  alt2138_1:
    set_addr $I10, alt2138_2
    rx2134_cur."!mark_push"(0, rx2134_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx2134_cur."!cursor_pos"(rx2134_pos)
    $P10 = rx2134_cur."routine_def"()
    unless $P10, rx2134_fail
    rx2134_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx2134_pos = $P10."pos"()
    goto alt2138_end
  alt2138_2:
  # rx subrule "panic" subtype=method negate=
    rx2134_cur."!cursor_pos"(rx2134_pos)
    $P10 = rx2134_cur."panic"("Malformed multi")
    unless $P10, rx2134_fail
    rx2134_pos = $P10."pos"()
  alt2138_end:
.annotate 'line', 885
  # rx pass
    rx2134_cur."!cursor_pass"(rx2134_pos, "multi_declarator:sym<multi>")
    if_null rx2134_debug, debug_1287
    rx2134_cur."!cursor_debug"("PASS", "multi_declarator:sym<multi>", " at pos=", rx2134_pos)
  debug_1287:
    .return (rx2134_cur)
  rx2134_restart:
.annotate 'line', 436
    if_null rx2134_debug, debug_1288
    rx2134_cur."!cursor_debug"("NEXT", "multi_declarator:sym<multi>")
  debug_1288:
  rx2134_fail:
    (rx2134_rep, rx2134_pos, $I10, $P10) = rx2134_cur."!mark_fail"(0)
    lt rx2134_pos, -1, rx2134_done
    eq rx2134_pos, -1, rx2134_fail
    jump $I10
  rx2134_done:
    rx2134_cur."!cursor_fail"()
    if_null rx2134_debug, debug_1289
    rx2134_cur."!cursor_debug"("FAIL", "multi_declarator:sym<multi>")
  debug_1289:
    .return (rx2134_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<multi>"  :subid("220_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2140 = self."!PREFIX__!subrule"("ws", "multi")
    new $P2141, "ResizablePMCArray"
    push $P2141, $P2140
    .return ($P2141)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<proto>"  :subid("221_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 891
    new $P2143, "Undef"
    .lex "$*MULTINESS", $P2143
.annotate 'line', 436
    .local string rx2144_tgt
    .local int rx2144_pos
    .local int rx2144_off
    .local int rx2144_eos
    .local int rx2144_rep
    .local pmc rx2144_cur
    .local pmc rx2144_debug
    (rx2144_cur, rx2144_pos, rx2144_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2144_cur
    .local pmc match
    .lex "$/", match
    length rx2144_eos, rx2144_tgt
    gt rx2144_pos, rx2144_eos, rx2144_done
    set rx2144_off, 0
    lt rx2144_pos, 2, rx2144_start
    sub rx2144_off, rx2144_pos, 1
    substr rx2144_tgt, rx2144_tgt, rx2144_off
  rx2144_start:
    eq $I10, 1, rx2144_restart
    if_null rx2144_debug, debug_1290
    rx2144_cur."!cursor_debug"("START", "multi_declarator:sym<proto>")
  debug_1290:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2145_done
    goto rxscan2145_scan
  rxscan2145_loop:
    (rx2144_pos) = rx2144_cur."from"()
    inc rx2144_pos
    rx2144_cur."!cursor_from"(rx2144_pos)
    ge rx2144_pos, rx2144_eos, rxscan2145_done
  rxscan2145_scan:
    set_addr $I10, rxscan2145_loop
    rx2144_cur."!mark_push"(0, rx2144_pos, $I10)
  rxscan2145_done:
.annotate 'line', 891
    rx2144_cur."!cursor_pos"(rx2144_pos)
    new $P2146, "String"
    assign $P2146, "proto"
    store_lex "$*MULTINESS", $P2146
.annotate 'line', 892
  # rx subcapture "sym"
    set_addr $I10, rxcap_2147_fail
    rx2144_cur."!mark_push"(0, rx2144_pos, $I10)
  # rx literal  "proto"
    add $I11, rx2144_pos, 5
    gt $I11, rx2144_eos, rx2144_fail
    sub $I11, rx2144_pos, rx2144_off
    substr $S10, rx2144_tgt, $I11, 5
    ne $S10, "proto", rx2144_fail
    add rx2144_pos, 5
    set_addr $I10, rxcap_2147_fail
    ($I12, $I11) = rx2144_cur."!mark_peek"($I10)
    rx2144_cur."!cursor_pos"($I11)
    ($P10) = rx2144_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2144_pos, "")
    rx2144_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2147_done
  rxcap_2147_fail:
    goto rx2144_fail
  rxcap_2147_done:
.annotate 'line', 893
  # rx subrule "ws" subtype=method negate=
    rx2144_cur."!cursor_pos"(rx2144_pos)
    $P10 = rx2144_cur."ws"()
    unless $P10, rx2144_fail
    rx2144_pos = $P10."pos"()
  alt2148_0:
    set_addr $I10, alt2148_1
    rx2144_cur."!mark_push"(0, rx2144_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx2144_cur."!cursor_pos"(rx2144_pos)
    $P10 = rx2144_cur."declarator"()
    unless $P10, rx2144_fail
    rx2144_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx2144_pos = $P10."pos"()
    goto alt2148_end
  alt2148_1:
    set_addr $I10, alt2148_2
    rx2144_cur."!mark_push"(0, rx2144_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx2144_cur."!cursor_pos"(rx2144_pos)
    $P10 = rx2144_cur."routine_def"()
    unless $P10, rx2144_fail
    rx2144_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx2144_pos = $P10."pos"()
    goto alt2148_end
  alt2148_2:
  # rx subrule "panic" subtype=method negate=
    rx2144_cur."!cursor_pos"(rx2144_pos)
    $P10 = rx2144_cur."panic"("Malformed proto")
    unless $P10, rx2144_fail
    rx2144_pos = $P10."pos"()
  alt2148_end:
.annotate 'line', 890
  # rx pass
    rx2144_cur."!cursor_pass"(rx2144_pos, "multi_declarator:sym<proto>")
    if_null rx2144_debug, debug_1291
    rx2144_cur."!cursor_debug"("PASS", "multi_declarator:sym<proto>", " at pos=", rx2144_pos)
  debug_1291:
    .return (rx2144_cur)
  rx2144_restart:
.annotate 'line', 436
    if_null rx2144_debug, debug_1292
    rx2144_cur."!cursor_debug"("NEXT", "multi_declarator:sym<proto>")
  debug_1292:
  rx2144_fail:
    (rx2144_rep, rx2144_pos, $I10, $P10) = rx2144_cur."!mark_fail"(0)
    lt rx2144_pos, -1, rx2144_done
    eq rx2144_pos, -1, rx2144_fail
    jump $I10
  rx2144_done:
    rx2144_cur."!cursor_fail"()
    if_null rx2144_debug, debug_1293
    rx2144_cur."!cursor_debug"("FAIL", "multi_declarator:sym<proto>")
  debug_1293:
    .return (rx2144_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<proto>"  :subid("222_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2150 = self."!PREFIX__!subrule"("ws", "proto")
    new $P2151, "ResizablePMCArray"
    push $P2151, $P2150
    .return ($P2151)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<null>"  :subid("223_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 896
    new $P2153, "Undef"
    .lex "$*MULTINESS", $P2153
.annotate 'line', 436
    .local string rx2154_tgt
    .local int rx2154_pos
    .local int rx2154_off
    .local int rx2154_eos
    .local int rx2154_rep
    .local pmc rx2154_cur
    .local pmc rx2154_debug
    (rx2154_cur, rx2154_pos, rx2154_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2154_cur
    .local pmc match
    .lex "$/", match
    length rx2154_eos, rx2154_tgt
    gt rx2154_pos, rx2154_eos, rx2154_done
    set rx2154_off, 0
    lt rx2154_pos, 2, rx2154_start
    sub rx2154_off, rx2154_pos, 1
    substr rx2154_tgt, rx2154_tgt, rx2154_off
  rx2154_start:
    eq $I10, 1, rx2154_restart
    if_null rx2154_debug, debug_1294
    rx2154_cur."!cursor_debug"("START", "multi_declarator:sym<null>")
  debug_1294:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2155_done
    goto rxscan2155_scan
  rxscan2155_loop:
    (rx2154_pos) = rx2154_cur."from"()
    inc rx2154_pos
    rx2154_cur."!cursor_from"(rx2154_pos)
    ge rx2154_pos, rx2154_eos, rxscan2155_done
  rxscan2155_scan:
    set_addr $I10, rxscan2155_loop
    rx2154_cur."!mark_push"(0, rx2154_pos, $I10)
  rxscan2155_done:
.annotate 'line', 896
    rx2154_cur."!cursor_pos"(rx2154_pos)
    new $P2156, "String"
    assign $P2156, ""
    store_lex "$*MULTINESS", $P2156
.annotate 'line', 897
  # rx subrule "declarator" subtype=capture negate=
    rx2154_cur."!cursor_pos"(rx2154_pos)
    $P10 = rx2154_cur."declarator"()
    unless $P10, rx2154_fail
    rx2154_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx2154_pos = $P10."pos"()
.annotate 'line', 895
  # rx pass
    rx2154_cur."!cursor_pass"(rx2154_pos, "multi_declarator:sym<null>")
    if_null rx2154_debug, debug_1295
    rx2154_cur."!cursor_debug"("PASS", "multi_declarator:sym<null>", " at pos=", rx2154_pos)
  debug_1295:
    .return (rx2154_cur)
  rx2154_restart:
.annotate 'line', 436
    if_null rx2154_debug, debug_1296
    rx2154_cur."!cursor_debug"("NEXT", "multi_declarator:sym<null>")
  debug_1296:
  rx2154_fail:
    (rx2154_rep, rx2154_pos, $I10, $P10) = rx2154_cur."!mark_fail"(0)
    lt rx2154_pos, -1, rx2154_done
    eq rx2154_pos, -1, rx2154_fail
    jump $I10
  rx2154_done:
    rx2154_cur."!cursor_fail"()
    if_null rx2154_debug, debug_1297
    rx2154_cur."!cursor_debug"("FAIL", "multi_declarator:sym<null>")
  debug_1297:
    .return (rx2154_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<null>"  :subid("224_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2158 = self."!PREFIX__!subrule"("declarator", "")
    new $P2159, "ResizablePMCArray"
    push $P2159, $P2158
    .return ($P2159)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "signature"  :subid("225_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .const 'Sub' $P2167 = "226_1307873304.82979" 
    capture_lex $P2167
    .local string rx2161_tgt
    .local int rx2161_pos
    .local int rx2161_off
    .local int rx2161_eos
    .local int rx2161_rep
    .local pmc rx2161_cur
    .local pmc rx2161_debug
    (rx2161_cur, rx2161_pos, rx2161_tgt, $I10) = self."!cursor_start"()
    rx2161_cur."!cursor_caparray"("invocant", "parameter")
    .lex unicode:"$\x{a2}", rx2161_cur
    .local pmc match
    .lex "$/", match
    length rx2161_eos, rx2161_tgt
    gt rx2161_pos, rx2161_eos, rx2161_done
    set rx2161_off, 0
    lt rx2161_pos, 2, rx2161_start
    sub rx2161_off, rx2161_pos, 1
    substr rx2161_tgt, rx2161_tgt, rx2161_off
  rx2161_start:
    eq $I10, 1, rx2161_restart
    if_null rx2161_debug, debug_1298
    rx2161_cur."!cursor_debug"("START", "signature")
  debug_1298:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2162_done
    goto rxscan2162_scan
  rxscan2162_loop:
    (rx2161_pos) = rx2161_cur."from"()
    inc rx2161_pos
    rx2161_cur."!cursor_from"(rx2161_pos)
    ge rx2161_pos, rx2161_eos, rxscan2162_done
  rxscan2162_scan:
    set_addr $I10, rxscan2162_loop
    rx2161_cur."!mark_push"(0, rx2161_pos, $I10)
  rxscan2162_done:
.annotate 'line', 901
  # rx rxquantr2163 ** 0..1
    set_addr $I10, rxquantr2163_done
    rx2161_cur."!mark_push"(0, rx2161_pos, $I10)
  rxquantr2163_loop:
    rx2161_cur."!cursor_pos"(rx2161_pos)
    find_lex $P2164, unicode:"$\x{a2}"
    $P2165 = $P2164."MATCH"()
    store_lex "$/", $P2165
    .const 'Sub' $P2167 = "226_1307873304.82979" 
    capture_lex $P2167
    $P2171 = $P2167()
    unless $P2171, rx2161_fail
  # rx subrule "ws" subtype=method negate=
    rx2161_cur."!cursor_pos"(rx2161_pos)
    $P10 = rx2161_cur."ws"()
    unless $P10, rx2161_fail
    rx2161_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx2161_cur."!cursor_pos"(rx2161_pos)
    $P10 = rx2161_cur."parameter"()
    unless $P10, rx2161_fail
    rx2161_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("invocant")
    rx2161_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2161_cur."!cursor_pos"(rx2161_pos)
    $P10 = rx2161_cur."ws"()
    unless $P10, rx2161_fail
    rx2161_pos = $P10."pos"()
  # rx literal  ":"
    add $I11, rx2161_pos, 1
    gt $I11, rx2161_eos, rx2161_fail
    sub $I11, rx2161_pos, rx2161_off
    ord $I11, rx2161_tgt, $I11
    ne $I11, 58, rx2161_fail
    add rx2161_pos, 1
    set_addr $I10, rxquantr2163_done
    (rx2161_rep) = rx2161_cur."!mark_commit"($I10)
  rxquantr2163_done:
.annotate 'line', 902
  # rx rxquantr2172 ** 0..1
    set_addr $I10, rxquantr2172_done
    rx2161_cur."!mark_push"(0, rx2161_pos, $I10)
  rxquantr2172_loop:
  # rx rxquantr2173 ** 1..*
    set_addr $I10, rxquantr2173_done
    rx2161_cur."!mark_push"(0, -1, $I10)
  rxquantr2173_loop:
  # rx subrule "ws" subtype=method negate=
    rx2161_cur."!cursor_pos"(rx2161_pos)
    $P10 = rx2161_cur."ws"()
    unless $P10, rx2161_fail
    rx2161_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx2161_cur."!cursor_pos"(rx2161_pos)
    $P10 = rx2161_cur."parameter"()
    unless $P10, rx2161_fail
    rx2161_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parameter")
    rx2161_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2161_cur."!cursor_pos"(rx2161_pos)
    $P10 = rx2161_cur."ws"()
    unless $P10, rx2161_fail
    rx2161_pos = $P10."pos"()
    set_addr $I10, rxquantr2173_done
    (rx2161_rep) = rx2161_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr2173_done
    rx2161_cur."!mark_push"(rx2161_rep, rx2161_pos, $I10)
  # rx literal  ","
    add $I11, rx2161_pos, 1
    gt $I11, rx2161_eos, rx2161_fail
    sub $I11, rx2161_pos, rx2161_off
    ord $I11, rx2161_tgt, $I11
    ne $I11, 44, rx2161_fail
    add rx2161_pos, 1
    goto rxquantr2173_loop
  rxquantr2173_done:
    set_addr $I10, rxquantr2172_done
    (rx2161_rep) = rx2161_cur."!mark_commit"($I10)
  rxquantr2172_done:
.annotate 'line', 900
  # rx pass
    rx2161_cur."!cursor_pass"(rx2161_pos, "signature")
    if_null rx2161_debug, debug_1301
    rx2161_cur."!cursor_debug"("PASS", "signature", " at pos=", rx2161_pos)
  debug_1301:
    .return (rx2161_cur)
  rx2161_restart:
.annotate 'line', 436
    if_null rx2161_debug, debug_1302
    rx2161_cur."!cursor_debug"("NEXT", "signature")
  debug_1302:
  rx2161_fail:
    (rx2161_rep, rx2161_pos, $I10, $P10) = rx2161_cur."!mark_fail"(0)
    lt rx2161_pos, -1, rx2161_done
    eq rx2161_pos, -1, rx2161_fail
    jump $I10
  rx2161_done:
    rx2161_cur."!cursor_fail"()
    if_null rx2161_debug, debug_1303
    rx2161_cur."!cursor_debug"("FAIL", "signature")
  debug_1303:
    .return (rx2161_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block2166"  :anon :subid("226_1307873304.82979") :outer("225_1307873304.82979")
.annotate 'line', 901
    find_dynamic_lex $P2170, "$*INVOCANT_OK"
    unless_null $P2170, vivify_1299
    get_hll_global $P2168, "GLOBAL"
    get_who $P2169, $P2168
    set $P2170, $P2169["$INVOCANT_OK"]
    unless_null $P2170, vivify_1300
    die "Contextual $*INVOCANT_OK not found"
  vivify_1300:
  vivify_1299:
    .return ($P2170)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__signature"  :subid("227_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    new $P2175, "ResizablePMCArray"
    push $P2175, ""
    .return ($P2175)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "parameter"  :subid("228_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2177_tgt
    .local int rx2177_pos
    .local int rx2177_off
    .local int rx2177_eos
    .local int rx2177_rep
    .local pmc rx2177_cur
    .local pmc rx2177_debug
    (rx2177_cur, rx2177_pos, rx2177_tgt, $I10) = self."!cursor_start"()
    rx2177_cur."!cursor_caparray"("typename", "definedness", "default_value")
    .lex unicode:"$\x{a2}", rx2177_cur
    .local pmc match
    .lex "$/", match
    length rx2177_eos, rx2177_tgt
    gt rx2177_pos, rx2177_eos, rx2177_done
    set rx2177_off, 0
    lt rx2177_pos, 2, rx2177_start
    sub rx2177_off, rx2177_pos, 1
    substr rx2177_tgt, rx2177_tgt, rx2177_off
  rx2177_start:
    eq $I10, 1, rx2177_restart
    if_null rx2177_debug, debug_1304
    rx2177_cur."!cursor_debug"("START", "parameter")
  debug_1304:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2178_done
    goto rxscan2178_scan
  rxscan2178_loop:
    (rx2177_pos) = rx2177_cur."from"()
    inc rx2177_pos
    rx2177_cur."!cursor_from"(rx2177_pos)
    ge rx2177_pos, rx2177_eos, rxscan2178_done
  rxscan2178_scan:
    set_addr $I10, rxscan2178_loop
    rx2177_cur."!mark_push"(0, rx2177_pos, $I10)
  rxscan2178_done:
.annotate 'line', 906
  # rx rxquantr2179 ** 0..*
    set_addr $I10, rxquantr2179_done
    rx2177_cur."!mark_push"(0, rx2177_pos, $I10)
  rxquantr2179_loop:
  # rx subrule "typename" subtype=capture negate=
    rx2177_cur."!cursor_pos"(rx2177_pos)
    $P10 = rx2177_cur."typename"()
    unless $P10, rx2177_fail
    rx2177_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("typename")
    rx2177_pos = $P10."pos"()
  # rx rxquantr2180 ** 0..1
    set_addr $I10, rxquantr2180_done
    rx2177_cur."!mark_push"(0, rx2177_pos, $I10)
  rxquantr2180_loop:
  # rx literal  ":"
    add $I11, rx2177_pos, 1
    gt $I11, rx2177_eos, rx2177_fail
    sub $I11, rx2177_pos, rx2177_off
    ord $I11, rx2177_tgt, $I11
    ne $I11, 58, rx2177_fail
    add rx2177_pos, 1
  # rx subcapture "definedness"
    set_addr $I10, rxcap_2181_fail
    rx2177_cur."!mark_push"(0, rx2177_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx2177_pos, rx2177_eos, rx2177_fail
    sub $I10, rx2177_pos, rx2177_off
    substr $S10, rx2177_tgt, $I10, 1
    index $I11, "_DU", $S10
    lt $I11, 0, rx2177_fail
    inc rx2177_pos
    set_addr $I10, rxcap_2181_fail
    ($I12, $I11) = rx2177_cur."!mark_peek"($I10)
    rx2177_cur."!cursor_pos"($I11)
    ($P10) = rx2177_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2177_pos, "")
    rx2177_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("definedness")
    goto rxcap_2181_done
  rxcap_2181_fail:
    goto rx2177_fail
  rxcap_2181_done:
    set_addr $I10, rxquantr2180_done
    (rx2177_rep) = rx2177_cur."!mark_commit"($I10)
  rxquantr2180_done:
  # rx subrule "ws" subtype=method negate=
    rx2177_cur."!cursor_pos"(rx2177_pos)
    $P10 = rx2177_cur."ws"()
    unless $P10, rx2177_fail
    rx2177_pos = $P10."pos"()
    set_addr $I10, rxquantr2179_done
    (rx2177_rep) = rx2177_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr2179_done
    rx2177_cur."!mark_push"(rx2177_rep, rx2177_pos, $I10)
    goto rxquantr2179_loop
  rxquantr2179_done:
  alt2182_0:
.annotate 'line', 907
    set_addr $I10, alt2182_1
    rx2177_cur."!mark_push"(0, rx2177_pos, $I10)
.annotate 'line', 908
  # rx subcapture "quant"
    set_addr $I10, rxcap_2183_fail
    rx2177_cur."!mark_push"(0, rx2177_pos, $I10)
  # rx literal  "*"
    add $I11, rx2177_pos, 1
    gt $I11, rx2177_eos, rx2177_fail
    sub $I11, rx2177_pos, rx2177_off
    ord $I11, rx2177_tgt, $I11
    ne $I11, 42, rx2177_fail
    add rx2177_pos, 1
    set_addr $I10, rxcap_2183_fail
    ($I12, $I11) = rx2177_cur."!mark_peek"($I10)
    rx2177_cur."!cursor_pos"($I11)
    ($P10) = rx2177_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2177_pos, "")
    rx2177_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_2183_done
  rxcap_2183_fail:
    goto rx2177_fail
  rxcap_2183_done:
  # rx subrule "param_var" subtype=capture negate=
    rx2177_cur."!cursor_pos"(rx2177_pos)
    $P10 = rx2177_cur."param_var"()
    unless $P10, rx2177_fail
    rx2177_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx2177_pos = $P10."pos"()
    goto alt2182_end
  alt2182_1:
  alt2184_0:
.annotate 'line', 909
    set_addr $I10, alt2184_1
    rx2177_cur."!mark_push"(0, rx2177_pos, $I10)
  # rx subrule "param_var" subtype=capture negate=
    rx2177_cur."!cursor_pos"(rx2177_pos)
    $P10 = rx2177_cur."param_var"()
    unless $P10, rx2177_fail
    rx2177_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx2177_pos = $P10."pos"()
    goto alt2184_end
  alt2184_1:
  # rx subrule "named_param" subtype=capture negate=
    rx2177_cur."!cursor_pos"(rx2177_pos)
    $P10 = rx2177_cur."named_param"()
    unless $P10, rx2177_fail
    rx2177_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("named_param")
    rx2177_pos = $P10."pos"()
  alt2184_end:
  # rx subcapture "quant"
    set_addr $I10, rxcap_2186_fail
    rx2177_cur."!mark_push"(0, rx2177_pos, $I10)
  alt2185_0:
    set_addr $I10, alt2185_1
    rx2177_cur."!mark_push"(0, rx2177_pos, $I10)
  # rx literal  "?"
    add $I11, rx2177_pos, 1
    gt $I11, rx2177_eos, rx2177_fail
    sub $I11, rx2177_pos, rx2177_off
    ord $I11, rx2177_tgt, $I11
    ne $I11, 63, rx2177_fail
    add rx2177_pos, 1
    goto alt2185_end
  alt2185_1:
    set_addr $I10, alt2185_2
    rx2177_cur."!mark_push"(0, rx2177_pos, $I10)
  # rx literal  "!"
    add $I11, rx2177_pos, 1
    gt $I11, rx2177_eos, rx2177_fail
    sub $I11, rx2177_pos, rx2177_off
    ord $I11, rx2177_tgt, $I11
    ne $I11, 33, rx2177_fail
    add rx2177_pos, 1
    goto alt2185_end
  alt2185_2:
  alt2185_end:
    set_addr $I10, rxcap_2186_fail
    ($I12, $I11) = rx2177_cur."!mark_peek"($I10)
    rx2177_cur."!cursor_pos"($I11)
    ($P10) = rx2177_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2177_pos, "")
    rx2177_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_2186_done
  rxcap_2186_fail:
    goto rx2177_fail
  rxcap_2186_done:
  alt2182_end:
.annotate 'line', 911
  # rx rxquantr2187 ** 0..1
    set_addr $I10, rxquantr2187_done
    rx2177_cur."!mark_push"(0, rx2177_pos, $I10)
  rxquantr2187_loop:
  # rx subrule "default_value" subtype=capture negate=
    rx2177_cur."!cursor_pos"(rx2177_pos)
    $P10 = rx2177_cur."default_value"()
    unless $P10, rx2177_fail
    goto rxsubrule2188_pass
  rxsubrule2188_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx2177_fail
  rxsubrule2188_pass:
    set_addr $I10, rxsubrule2188_back
    rx2177_cur."!mark_push"(0, rx2177_pos, $I10, $P10)
    $P10."!cursor_names"("default_value")
    rx2177_pos = $P10."pos"()
    set_addr $I10, rxquantr2187_done
    (rx2177_rep) = rx2177_cur."!mark_commit"($I10)
  rxquantr2187_done:
.annotate 'line', 905
  # rx pass
    rx2177_cur."!cursor_pass"(rx2177_pos, "parameter")
    if_null rx2177_debug, debug_1305
    rx2177_cur."!cursor_debug"("PASS", "parameter", " at pos=", rx2177_pos)
  debug_1305:
    .return (rx2177_cur)
  rx2177_restart:
.annotate 'line', 436
    if_null rx2177_debug, debug_1306
    rx2177_cur."!cursor_debug"("NEXT", "parameter")
  debug_1306:
  rx2177_fail:
    (rx2177_rep, rx2177_pos, $I10, $P10) = rx2177_cur."!mark_fail"(0)
    lt rx2177_pos, -1, rx2177_done
    eq rx2177_pos, -1, rx2177_fail
    jump $I10
  rx2177_done:
    rx2177_cur."!cursor_fail"()
    if_null rx2177_debug, debug_1307
    rx2177_cur."!cursor_debug"("FAIL", "parameter")
  debug_1307:
    .return (rx2177_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__parameter"  :subid("229_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    new $P2190, "ResizablePMCArray"
    push $P2190, ""
    .return ($P2190)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "param_var"  :subid("230_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2192_tgt
    .local int rx2192_pos
    .local int rx2192_off
    .local int rx2192_eos
    .local int rx2192_rep
    .local pmc rx2192_cur
    .local pmc rx2192_debug
    (rx2192_cur, rx2192_pos, rx2192_tgt, $I10) = self."!cursor_start"()
    rx2192_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx2192_cur
    .local pmc match
    .lex "$/", match
    length rx2192_eos, rx2192_tgt
    gt rx2192_pos, rx2192_eos, rx2192_done
    set rx2192_off, 0
    lt rx2192_pos, 2, rx2192_start
    sub rx2192_off, rx2192_pos, 1
    substr rx2192_tgt, rx2192_tgt, rx2192_off
  rx2192_start:
    eq $I10, 1, rx2192_restart
    if_null rx2192_debug, debug_1308
    rx2192_cur."!cursor_debug"("START", "param_var")
  debug_1308:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2193_done
    goto rxscan2193_scan
  rxscan2193_loop:
    (rx2192_pos) = rx2192_cur."from"()
    inc rx2192_pos
    rx2192_cur."!cursor_from"(rx2192_pos)
    ge rx2192_pos, rx2192_eos, rxscan2193_done
  rxscan2193_scan:
    set_addr $I10, rxscan2193_loop
    rx2192_cur."!mark_push"(0, rx2192_pos, $I10)
  rxscan2193_done:
.annotate 'line', 915
  # rx subrule "sigil" subtype=capture negate=
    rx2192_cur."!cursor_pos"(rx2192_pos)
    $P10 = rx2192_cur."sigil"()
    unless $P10, rx2192_fail
    rx2192_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx2192_pos = $P10."pos"()
  # rx rxquantr2194 ** 0..1
    set_addr $I10, rxquantr2194_done
    rx2192_cur."!mark_push"(0, rx2192_pos, $I10)
  rxquantr2194_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx2192_cur."!cursor_pos"(rx2192_pos)
    $P10 = rx2192_cur."twigil"()
    unless $P10, rx2192_fail
    goto rxsubrule2195_pass
  rxsubrule2195_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx2192_fail
  rxsubrule2195_pass:
    set_addr $I10, rxsubrule2195_back
    rx2192_cur."!mark_push"(0, rx2192_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx2192_pos = $P10."pos"()
    set_addr $I10, rxquantr2194_done
    (rx2192_rep) = rx2192_cur."!mark_commit"($I10)
  rxquantr2194_done:
  alt2196_0:
.annotate 'line', 916
    set_addr $I10, alt2196_1
    rx2192_cur."!mark_push"(0, rx2192_pos, $I10)
  # rx subrule "ident" subtype=capture negate=
    rx2192_cur."!cursor_pos"(rx2192_pos)
    $P10 = rx2192_cur."ident"()
    unless $P10, rx2192_fail
    rx2192_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx2192_pos = $P10."pos"()
    goto alt2196_end
  alt2196_1:
  # rx subcapture "name"
    set_addr $I10, rxcap_2197_fail
    rx2192_cur."!mark_push"(0, rx2192_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx2192_pos, rx2192_eos, rx2192_fail
    sub $I10, rx2192_pos, rx2192_off
    substr $S10, rx2192_tgt, $I10, 1
    index $I11, "/!", $S10
    lt $I11, 0, rx2192_fail
    inc rx2192_pos
    set_addr $I10, rxcap_2197_fail
    ($I12, $I11) = rx2192_cur."!mark_peek"($I10)
    rx2192_cur."!cursor_pos"($I11)
    ($P10) = rx2192_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2192_pos, "")
    rx2192_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    goto rxcap_2197_done
  rxcap_2197_fail:
    goto rx2192_fail
  rxcap_2197_done:
  alt2196_end:
.annotate 'line', 914
  # rx pass
    rx2192_cur."!cursor_pass"(rx2192_pos, "param_var")
    if_null rx2192_debug, debug_1309
    rx2192_cur."!cursor_debug"("PASS", "param_var", " at pos=", rx2192_pos)
  debug_1309:
    .return (rx2192_cur)
  rx2192_restart:
.annotate 'line', 436
    if_null rx2192_debug, debug_1310
    rx2192_cur."!cursor_debug"("NEXT", "param_var")
  debug_1310:
  rx2192_fail:
    (rx2192_rep, rx2192_pos, $I10, $P10) = rx2192_cur."!mark_fail"(0)
    lt rx2192_pos, -1, rx2192_done
    eq rx2192_pos, -1, rx2192_fail
    jump $I10
  rx2192_done:
    rx2192_cur."!cursor_fail"()
    if_null rx2192_debug, debug_1311
    rx2192_cur."!cursor_debug"("FAIL", "param_var")
  debug_1311:
    .return (rx2192_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__param_var"  :subid("231_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2199 = self."!PREFIX__!subrule"("sigil", "")
    new $P2200, "ResizablePMCArray"
    push $P2200, $P2199
    .return ($P2200)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "named_param"  :subid("232_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2202_tgt
    .local int rx2202_pos
    .local int rx2202_off
    .local int rx2202_eos
    .local int rx2202_rep
    .local pmc rx2202_cur
    .local pmc rx2202_debug
    (rx2202_cur, rx2202_pos, rx2202_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2202_cur
    .local pmc match
    .lex "$/", match
    length rx2202_eos, rx2202_tgt
    gt rx2202_pos, rx2202_eos, rx2202_done
    set rx2202_off, 0
    lt rx2202_pos, 2, rx2202_start
    sub rx2202_off, rx2202_pos, 1
    substr rx2202_tgt, rx2202_tgt, rx2202_off
  rx2202_start:
    eq $I10, 1, rx2202_restart
    if_null rx2202_debug, debug_1312
    rx2202_cur."!cursor_debug"("START", "named_param")
  debug_1312:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2203_done
    goto rxscan2203_scan
  rxscan2203_loop:
    (rx2202_pos) = rx2202_cur."from"()
    inc rx2202_pos
    rx2202_cur."!cursor_from"(rx2202_pos)
    ge rx2202_pos, rx2202_eos, rxscan2203_done
  rxscan2203_scan:
    set_addr $I10, rxscan2203_loop
    rx2202_cur."!mark_push"(0, rx2202_pos, $I10)
  rxscan2203_done:
.annotate 'line', 920
  # rx literal  ":"
    add $I11, rx2202_pos, 1
    gt $I11, rx2202_eos, rx2202_fail
    sub $I11, rx2202_pos, rx2202_off
    ord $I11, rx2202_tgt, $I11
    ne $I11, 58, rx2202_fail
    add rx2202_pos, 1
  # rx subrule "param_var" subtype=capture negate=
    rx2202_cur."!cursor_pos"(rx2202_pos)
    $P10 = rx2202_cur."param_var"()
    unless $P10, rx2202_fail
    rx2202_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx2202_pos = $P10."pos"()
.annotate 'line', 919
  # rx pass
    rx2202_cur."!cursor_pass"(rx2202_pos, "named_param")
    if_null rx2202_debug, debug_1313
    rx2202_cur."!cursor_debug"("PASS", "named_param", " at pos=", rx2202_pos)
  debug_1313:
    .return (rx2202_cur)
  rx2202_restart:
.annotate 'line', 436
    if_null rx2202_debug, debug_1314
    rx2202_cur."!cursor_debug"("NEXT", "named_param")
  debug_1314:
  rx2202_fail:
    (rx2202_rep, rx2202_pos, $I10, $P10) = rx2202_cur."!mark_fail"(0)
    lt rx2202_pos, -1, rx2202_done
    eq rx2202_pos, -1, rx2202_fail
    jump $I10
  rx2202_done:
    rx2202_cur."!cursor_fail"()
    if_null rx2202_debug, debug_1315
    rx2202_cur."!cursor_debug"("FAIL", "named_param")
  debug_1315:
    .return (rx2202_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__named_param"  :subid("233_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2205 = self."!PREFIX__!subrule"("param_var", ":")
    new $P2206, "ResizablePMCArray"
    push $P2206, $P2205
    .return ($P2206)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "default_value"  :subid("234_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2208_tgt
    .local int rx2208_pos
    .local int rx2208_off
    .local int rx2208_eos
    .local int rx2208_rep
    .local pmc rx2208_cur
    .local pmc rx2208_debug
    (rx2208_cur, rx2208_pos, rx2208_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2208_cur
    .local pmc match
    .lex "$/", match
    length rx2208_eos, rx2208_tgt
    gt rx2208_pos, rx2208_eos, rx2208_done
    set rx2208_off, 0
    lt rx2208_pos, 2, rx2208_start
    sub rx2208_off, rx2208_pos, 1
    substr rx2208_tgt, rx2208_tgt, rx2208_off
  rx2208_start:
    eq $I10, 1, rx2208_restart
    if_null rx2208_debug, debug_1316
    rx2208_cur."!cursor_debug"("START", "default_value")
  debug_1316:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2209_done
    goto rxscan2209_scan
  rxscan2209_loop:
    (rx2208_pos) = rx2208_cur."from"()
    inc rx2208_pos
    rx2208_cur."!cursor_from"(rx2208_pos)
    ge rx2208_pos, rx2208_eos, rxscan2209_done
  rxscan2209_scan:
    set_addr $I10, rxscan2209_loop
    rx2208_cur."!mark_push"(0, rx2208_pos, $I10)
  rxscan2209_done:
.annotate 'line', 923
  # rx subrule "ws" subtype=method negate=
    rx2208_cur."!cursor_pos"(rx2208_pos)
    $P10 = rx2208_cur."ws"()
    unless $P10, rx2208_fail
    rx2208_pos = $P10."pos"()
  # rx literal  "="
    add $I11, rx2208_pos, 1
    gt $I11, rx2208_eos, rx2208_fail
    sub $I11, rx2208_pos, rx2208_off
    ord $I11, rx2208_tgt, $I11
    ne $I11, 61, rx2208_fail
    add rx2208_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2208_cur."!cursor_pos"(rx2208_pos)
    $P10 = rx2208_cur."ws"()
    unless $P10, rx2208_fail
    rx2208_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx2208_cur."!cursor_pos"(rx2208_pos)
    $P10 = rx2208_cur."EXPR"("i=")
    unless $P10, rx2208_fail
    rx2208_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx2208_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2208_cur."!cursor_pos"(rx2208_pos)
    $P10 = rx2208_cur."ws"()
    unless $P10, rx2208_fail
    rx2208_pos = $P10."pos"()
  # rx pass
    rx2208_cur."!cursor_pass"(rx2208_pos, "default_value")
    if_null rx2208_debug, debug_1317
    rx2208_cur."!cursor_debug"("PASS", "default_value", " at pos=", rx2208_pos)
  debug_1317:
    .return (rx2208_cur)
  rx2208_restart:
.annotate 'line', 436
    if_null rx2208_debug, debug_1318
    rx2208_cur."!cursor_debug"("NEXT", "default_value")
  debug_1318:
  rx2208_fail:
    (rx2208_rep, rx2208_pos, $I10, $P10) = rx2208_cur."!mark_fail"(0)
    lt rx2208_pos, -1, rx2208_done
    eq rx2208_pos, -1, rx2208_fail
    jump $I10
  rx2208_done:
    rx2208_cur."!cursor_fail"()
    if_null rx2208_debug, debug_1319
    rx2208_cur."!cursor_debug"("FAIL", "default_value")
  debug_1319:
    .return (rx2208_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__default_value"  :subid("235_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2214 = self."!PREFIX__!subrule"("ws", "")
    new $P2215, "ResizablePMCArray"
    push $P2215, $P2214
    .return ($P2215)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait"  :subid("236_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2217_tgt
    .local int rx2217_pos
    .local int rx2217_off
    .local int rx2217_eos
    .local int rx2217_rep
    .local pmc rx2217_cur
    .local pmc rx2217_debug
    (rx2217_cur, rx2217_pos, rx2217_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2217_cur
    .local pmc match
    .lex "$/", match
    length rx2217_eos, rx2217_tgt
    gt rx2217_pos, rx2217_eos, rx2217_done
    set rx2217_off, 0
    lt rx2217_pos, 2, rx2217_start
    sub rx2217_off, rx2217_pos, 1
    substr rx2217_tgt, rx2217_tgt, rx2217_off
  rx2217_start:
    eq $I10, 1, rx2217_restart
    if_null rx2217_debug, debug_1320
    rx2217_cur."!cursor_debug"("START", "trait")
  debug_1320:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2218_done
    goto rxscan2218_scan
  rxscan2218_loop:
    (rx2217_pos) = rx2217_cur."from"()
    inc rx2217_pos
    rx2217_cur."!cursor_from"(rx2217_pos)
    ge rx2217_pos, rx2217_eos, rxscan2218_done
  rxscan2218_scan:
    set_addr $I10, rxscan2218_loop
    rx2217_cur."!mark_push"(0, rx2217_pos, $I10)
  rxscan2218_done:
.annotate 'line', 925
  # rx subrule "ws" subtype=method negate=
    rx2217_cur."!cursor_pos"(rx2217_pos)
    $P10 = rx2217_cur."ws"()
    unless $P10, rx2217_fail
    rx2217_pos = $P10."pos"()
  # rx subrule "trait_mod" subtype=capture negate=
    rx2217_cur."!cursor_pos"(rx2217_pos)
    $P10 = rx2217_cur."trait_mod"()
    unless $P10, rx2217_fail
    rx2217_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("trait_mod")
    rx2217_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2217_cur."!cursor_pos"(rx2217_pos)
    $P10 = rx2217_cur."ws"()
    unless $P10, rx2217_fail
    rx2217_pos = $P10."pos"()
  # rx pass
    rx2217_cur."!cursor_pass"(rx2217_pos, "trait")
    if_null rx2217_debug, debug_1321
    rx2217_cur."!cursor_debug"("PASS", "trait", " at pos=", rx2217_pos)
  debug_1321:
    .return (rx2217_cur)
  rx2217_restart:
.annotate 'line', 436
    if_null rx2217_debug, debug_1322
    rx2217_cur."!cursor_debug"("NEXT", "trait")
  debug_1322:
  rx2217_fail:
    (rx2217_rep, rx2217_pos, $I10, $P10) = rx2217_cur."!mark_fail"(0)
    lt rx2217_pos, -1, rx2217_done
    eq rx2217_pos, -1, rx2217_fail
    jump $I10
  rx2217_done:
    rx2217_cur."!cursor_fail"()
    if_null rx2217_debug, debug_1323
    rx2217_cur."!cursor_debug"("FAIL", "trait")
  debug_1323:
    .return (rx2217_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait"  :subid("237_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2222 = self."!PREFIX__!subrule"("ws", "")
    new $P2223, "ResizablePMCArray"
    push $P2223, $P2222
    .return ($P2223)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod"  :subid("238_1307873304.82979")
    .param pmc param_2225
.annotate 'line', 927
    .lex "self", param_2225
    $P2226 = param_2225."!protoregex"("trait_mod")
    .return ($P2226)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod"  :subid("239_1307873304.82979")
    .param pmc param_2228
.annotate 'line', 927
    .lex "self", param_2228
    $P2229 = param_2228."!PREFIX__!protoregex"("trait_mod")
    .return ($P2229)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod:sym<is>"  :subid("240_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2231_tgt
    .local int rx2231_pos
    .local int rx2231_off
    .local int rx2231_eos
    .local int rx2231_rep
    .local pmc rx2231_cur
    .local pmc rx2231_debug
    (rx2231_cur, rx2231_pos, rx2231_tgt, $I10) = self."!cursor_start"()
    rx2231_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx2231_cur
    .local pmc match
    .lex "$/", match
    length rx2231_eos, rx2231_tgt
    gt rx2231_pos, rx2231_eos, rx2231_done
    set rx2231_off, 0
    lt rx2231_pos, 2, rx2231_start
    sub rx2231_off, rx2231_pos, 1
    substr rx2231_tgt, rx2231_tgt, rx2231_off
  rx2231_start:
    eq $I10, 1, rx2231_restart
    if_null rx2231_debug, debug_1324
    rx2231_cur."!cursor_debug"("START", "trait_mod:sym<is>")
  debug_1324:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2232_done
    goto rxscan2232_scan
  rxscan2232_loop:
    (rx2231_pos) = rx2231_cur."from"()
    inc rx2231_pos
    rx2231_cur."!cursor_from"(rx2231_pos)
    ge rx2231_pos, rx2231_eos, rxscan2232_done
  rxscan2232_scan:
    set_addr $I10, rxscan2232_loop
    rx2231_cur."!mark_push"(0, rx2231_pos, $I10)
  rxscan2232_done:
.annotate 'line', 928
  # rx subcapture "sym"
    set_addr $I10, rxcap_2233_fail
    rx2231_cur."!mark_push"(0, rx2231_pos, $I10)
  # rx literal  "is"
    add $I11, rx2231_pos, 2
    gt $I11, rx2231_eos, rx2231_fail
    sub $I11, rx2231_pos, rx2231_off
    substr $S10, rx2231_tgt, $I11, 2
    ne $S10, "is", rx2231_fail
    add rx2231_pos, 2
    set_addr $I10, rxcap_2233_fail
    ($I12, $I11) = rx2231_cur."!mark_peek"($I10)
    rx2231_cur."!cursor_pos"($I11)
    ($P10) = rx2231_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2231_pos, "")
    rx2231_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2233_done
  rxcap_2233_fail:
    goto rx2231_fail
  rxcap_2233_done:
  # rx subrule "ws" subtype=method negate=
    rx2231_cur."!cursor_pos"(rx2231_pos)
    $P10 = rx2231_cur."ws"()
    unless $P10, rx2231_fail
    rx2231_pos = $P10."pos"()
  # rx subrule "deflongname" subtype=capture negate=
    rx2231_cur."!cursor_pos"(rx2231_pos)
    $P10 = rx2231_cur."deflongname"()
    unless $P10, rx2231_fail
    rx2231_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx2231_pos = $P10."pos"()
  # rx rxquantr2235 ** 0..1
    set_addr $I10, rxquantr2235_done
    rx2231_cur."!mark_push"(0, rx2231_pos, $I10)
  rxquantr2235_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx2231_cur."!cursor_pos"(rx2231_pos)
    $P10 = rx2231_cur."circumfix"()
    unless $P10, rx2231_fail
    goto rxsubrule2236_pass
  rxsubrule2236_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx2231_fail
  rxsubrule2236_pass:
    set_addr $I10, rxsubrule2236_back
    rx2231_cur."!mark_push"(0, rx2231_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx2231_pos = $P10."pos"()
    set_addr $I10, rxquantr2235_done
    (rx2231_rep) = rx2231_cur."!mark_commit"($I10)
  rxquantr2235_done:
  # rx subrule "ws" subtype=method negate=
    rx2231_cur."!cursor_pos"(rx2231_pos)
    $P10 = rx2231_cur."ws"()
    unless $P10, rx2231_fail
    rx2231_pos = $P10."pos"()
  # rx pass
    rx2231_cur."!cursor_pass"(rx2231_pos, "trait_mod:sym<is>")
    if_null rx2231_debug, debug_1325
    rx2231_cur."!cursor_debug"("PASS", "trait_mod:sym<is>", " at pos=", rx2231_pos)
  debug_1325:
    .return (rx2231_cur)
  rx2231_restart:
.annotate 'line', 436
    if_null rx2231_debug, debug_1326
    rx2231_cur."!cursor_debug"("NEXT", "trait_mod:sym<is>")
  debug_1326:
  rx2231_fail:
    (rx2231_rep, rx2231_pos, $I10, $P10) = rx2231_cur."!mark_fail"(0)
    lt rx2231_pos, -1, rx2231_done
    eq rx2231_pos, -1, rx2231_fail
    jump $I10
  rx2231_done:
    rx2231_cur."!cursor_fail"()
    if_null rx2231_debug, debug_1327
    rx2231_cur."!cursor_debug"("FAIL", "trait_mod:sym<is>")
  debug_1327:
    .return (rx2231_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod:sym<is>"  :subid("241_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2239 = self."!PREFIX__!subrule"("ws", "is")
    new $P2240, "ResizablePMCArray"
    push $P2240, $P2239
    .return ($P2240)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "regex_declarator"  :subid("242_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2242_tgt
    .local int rx2242_pos
    .local int rx2242_off
    .local int rx2242_eos
    .local int rx2242_rep
    .local pmc rx2242_cur
    .local pmc rx2242_debug
    (rx2242_cur, rx2242_pos, rx2242_tgt, $I10) = self."!cursor_start"()
    rx2242_cur."!cursor_caparray"("signature")
    .lex unicode:"$\x{a2}", rx2242_cur
    .local pmc match
    .lex "$/", match
    length rx2242_eos, rx2242_tgt
    gt rx2242_pos, rx2242_eos, rx2242_done
    set rx2242_off, 0
    lt rx2242_pos, 2, rx2242_start
    sub rx2242_off, rx2242_pos, 1
    substr rx2242_tgt, rx2242_tgt, rx2242_off
  rx2242_start:
    eq $I10, 1, rx2242_restart
    if_null rx2242_debug, debug_1328
    rx2242_cur."!cursor_debug"("START", "regex_declarator")
  debug_1328:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2243_done
    goto rxscan2243_scan
  rxscan2243_loop:
    (rx2242_pos) = rx2242_cur."from"()
    inc rx2242_pos
    rx2242_cur."!cursor_from"(rx2242_pos)
    ge rx2242_pos, rx2242_eos, rxscan2243_done
  rxscan2243_scan:
    set_addr $I10, rxscan2243_loop
    rx2242_cur."!mark_push"(0, rx2242_pos, $I10)
  rxscan2243_done:
.annotate 'line', 930
  # rx subrule "ws" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ws"()
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
  alt2245_0:
.annotate 'line', 931
    set_addr $I10, alt2245_1
    rx2242_cur."!mark_push"(0, rx2242_pos, $I10)
.annotate 'line', 932
  # rx subrule "ws" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ws"()
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
  # rx subcapture "proto"
    set_addr $I10, rxcap_2247_fail
    rx2242_cur."!mark_push"(0, rx2242_pos, $I10)
  # rx literal  "proto"
    add $I11, rx2242_pos, 5
    gt $I11, rx2242_eos, rx2242_fail
    sub $I11, rx2242_pos, rx2242_off
    substr $S10, rx2242_tgt, $I11, 5
    ne $S10, "proto", rx2242_fail
    add rx2242_pos, 5
    set_addr $I10, rxcap_2247_fail
    ($I12, $I11) = rx2242_cur."!mark_peek"($I10)
    rx2242_cur."!cursor_pos"($I11)
    ($P10) = rx2242_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2242_pos, "")
    rx2242_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("proto")
    goto rxcap_2247_done
  rxcap_2247_fail:
    goto rx2242_fail
  rxcap_2247_done:
  # rx subrule "ws" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ws"()
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
  alt2249_0:
    set_addr $I10, alt2249_1
    rx2242_cur."!mark_push"(0, rx2242_pos, $I10)
  # rx literal  "regex"
    add $I11, rx2242_pos, 5
    gt $I11, rx2242_eos, rx2242_fail
    sub $I11, rx2242_pos, rx2242_off
    substr $S10, rx2242_tgt, $I11, 5
    ne $S10, "regex", rx2242_fail
    add rx2242_pos, 5
    goto alt2249_end
  alt2249_1:
    set_addr $I10, alt2249_2
    rx2242_cur."!mark_push"(0, rx2242_pos, $I10)
  # rx literal  "token"
    add $I11, rx2242_pos, 5
    gt $I11, rx2242_eos, rx2242_fail
    sub $I11, rx2242_pos, rx2242_off
    substr $S10, rx2242_tgt, $I11, 5
    ne $S10, "token", rx2242_fail
    add rx2242_pos, 5
    goto alt2249_end
  alt2249_2:
  # rx literal  "rule"
    add $I11, rx2242_pos, 4
    gt $I11, rx2242_eos, rx2242_fail
    sub $I11, rx2242_pos, rx2242_off
    substr $S10, rx2242_tgt, $I11, 4
    ne $S10, "rule", rx2242_fail
    add rx2242_pos, 4
  alt2249_end:
  # rx subrule "ws" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ws"()
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
.annotate 'line', 933
  # rx subrule "deflongname" subtype=capture negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."deflongname"()
    unless $P10, rx2242_fail
    rx2242_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx2242_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ws"()
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
  alt2252_0:
.annotate 'line', 934
    set_addr $I10, alt2252_1
    rx2242_cur."!mark_push"(0, rx2242_pos, $I10)
.annotate 'line', 935
  # rx subrule "ws" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ws"()
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx2242_pos, 1
    gt $I11, rx2242_eos, rx2242_fail
    sub $I11, rx2242_pos, rx2242_off
    ord $I11, rx2242_tgt, $I11
    ne $I11, 123, rx2242_fail
    add rx2242_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ws"()
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
  # rx literal  "<...>"
    add $I11, rx2242_pos, 5
    gt $I11, rx2242_eos, rx2242_fail
    sub $I11, rx2242_pos, rx2242_off
    substr $S10, rx2242_tgt, $I11, 5
    ne $S10, "<...>", rx2242_fail
    add rx2242_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ws"()
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx2242_pos, 1
    gt $I11, rx2242_eos, rx2242_fail
    sub $I11, rx2242_pos, rx2242_off
    ord $I11, rx2242_tgt, $I11
    ne $I11, 125, rx2242_fail
    add rx2242_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ENDSTMT"()
    unless $P10, rx2242_fail
  # rx subrule "ws" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ws"()
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
    goto alt2252_end
  alt2252_1:
    set_addr $I10, alt2252_2
    rx2242_cur."!mark_push"(0, rx2242_pos, $I10)
.annotate 'line', 936
  # rx subrule "ws" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ws"()
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx2242_pos, 1
    gt $I11, rx2242_eos, rx2242_fail
    sub $I11, rx2242_pos, rx2242_off
    ord $I11, rx2242_tgt, $I11
    ne $I11, 123, rx2242_fail
    add rx2242_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ws"()
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
  # rx literal  "<*>"
    add $I11, rx2242_pos, 3
    gt $I11, rx2242_eos, rx2242_fail
    sub $I11, rx2242_pos, rx2242_off
    substr $S10, rx2242_tgt, $I11, 3
    ne $S10, "<*>", rx2242_fail
    add rx2242_pos, 3
  # rx subrule "ws" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ws"()
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx2242_pos, 1
    gt $I11, rx2242_eos, rx2242_fail
    sub $I11, rx2242_pos, rx2242_off
    ord $I11, rx2242_tgt, $I11
    ne $I11, 125, rx2242_fail
    add rx2242_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ENDSTMT"()
    unless $P10, rx2242_fail
  # rx subrule "ws" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ws"()
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
    goto alt2252_end
  alt2252_2:
.annotate 'line', 937
  # rx subrule "ws" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ws"()
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."panic"("Proto regex body must be <*> (or <...>, which is deprecated)")
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ws"()
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
  alt2252_end:
.annotate 'line', 938
  # rx subrule "ws" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ws"()
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
.annotate 'line', 932
    goto alt2245_end
  alt2245_1:
.annotate 'line', 939
  # rx subrule "ws" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ws"()
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
  # rx subcapture "sym"
    set_addr $I10, rxcap_2266_fail
    rx2242_cur."!mark_push"(0, rx2242_pos, $I10)
  alt2265_0:
    set_addr $I10, alt2265_1
    rx2242_cur."!mark_push"(0, rx2242_pos, $I10)
  # rx literal  "regex"
    add $I11, rx2242_pos, 5
    gt $I11, rx2242_eos, rx2242_fail
    sub $I11, rx2242_pos, rx2242_off
    substr $S10, rx2242_tgt, $I11, 5
    ne $S10, "regex", rx2242_fail
    add rx2242_pos, 5
    goto alt2265_end
  alt2265_1:
    set_addr $I10, alt2265_2
    rx2242_cur."!mark_push"(0, rx2242_pos, $I10)
  # rx literal  "token"
    add $I11, rx2242_pos, 5
    gt $I11, rx2242_eos, rx2242_fail
    sub $I11, rx2242_pos, rx2242_off
    substr $S10, rx2242_tgt, $I11, 5
    ne $S10, "token", rx2242_fail
    add rx2242_pos, 5
    goto alt2265_end
  alt2265_2:
  # rx literal  "rule"
    add $I11, rx2242_pos, 4
    gt $I11, rx2242_eos, rx2242_fail
    sub $I11, rx2242_pos, rx2242_off
    substr $S10, rx2242_tgt, $I11, 4
    ne $S10, "rule", rx2242_fail
    add rx2242_pos, 4
  alt2265_end:
    set_addr $I10, rxcap_2266_fail
    ($I12, $I11) = rx2242_cur."!mark_peek"($I10)
    rx2242_cur."!cursor_pos"($I11)
    ($P10) = rx2242_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2242_pos, "")
    rx2242_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2266_done
  rxcap_2266_fail:
    goto rx2242_fail
  rxcap_2266_done:
  # rx subrule "ws" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ws"()
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
.annotate 'line', 940
  # rx subrule "deflongname" subtype=capture negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."deflongname"()
    unless $P10, rx2242_fail
    rx2242_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx2242_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ws"()
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
.annotate 'line', 941
  # rx subrule "newpad" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."newpad"()
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ws"()
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
.annotate 'line', 942
  # rx rxquantr2270 ** 0..1
    set_addr $I10, rxquantr2270_done
    rx2242_cur."!mark_push"(0, rx2242_pos, $I10)
  rxquantr2270_loop:
  # rx subrule "ws" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ws"()
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx2242_pos, 1
    gt $I11, rx2242_eos, rx2242_fail
    sub $I11, rx2242_pos, rx2242_off
    ord $I11, rx2242_tgt, $I11
    ne $I11, 40, rx2242_fail
    add rx2242_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ws"()
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."signature"()
    unless $P10, rx2242_fail
    rx2242_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx2242_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ws"()
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx2242_pos, 1
    gt $I11, rx2242_eos, rx2242_fail
    sub $I11, rx2242_pos, rx2242_off
    ord $I11, rx2242_tgt, $I11
    ne $I11, 41, rx2242_fail
    add rx2242_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ws"()
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
    set_addr $I10, rxquantr2270_done
    (rx2242_rep) = rx2242_cur."!mark_commit"($I10)
  rxquantr2270_done:
  # rx subrule "ws" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ws"()
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
.annotate 'line', 943
  # rx reduce name="regex_declarator" key="open"
    rx2242_cur."!cursor_pos"(rx2242_pos)
    rx2242_cur."!reduce"("regex_declarator", "open")
  # rx subrule "ws" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ws"()
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
.annotate 'line', 944
  # rx literal  "{"
    add $I11, rx2242_pos, 1
    gt $I11, rx2242_eos, rx2242_fail
    sub $I11, rx2242_pos, rx2242_off
    ord $I11, rx2242_tgt, $I11
    ne $I11, 123, rx2242_fail
    add rx2242_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."LANG"("Regex", "nibbler")
    unless $P10, rx2242_fail
    rx2242_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx2242_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx2242_pos, 1
    gt $I11, rx2242_eos, rx2242_fail
    sub $I11, rx2242_pos, rx2242_off
    ord $I11, rx2242_tgt, $I11
    ne $I11, 125, rx2242_fail
    add rx2242_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ENDSTMT"()
    unless $P10, rx2242_fail
  # rx subrule "ws" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ws"()
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
  alt2245_end:
.annotate 'line', 945
  # rx subrule "ws" subtype=method negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."ws"()
    unless $P10, rx2242_fail
    rx2242_pos = $P10."pos"()
.annotate 'line', 930
  # rx pass
    rx2242_cur."!cursor_pass"(rx2242_pos, "regex_declarator")
    if_null rx2242_debug, debug_1329
    rx2242_cur."!cursor_debug"("PASS", "regex_declarator", " at pos=", rx2242_pos)
  debug_1329:
    .return (rx2242_cur)
  rx2242_restart:
.annotate 'line', 436
    if_null rx2242_debug, debug_1330
    rx2242_cur."!cursor_debug"("NEXT", "regex_declarator")
  debug_1330:
  rx2242_fail:
    (rx2242_rep, rx2242_pos, $I10, $P10) = rx2242_cur."!mark_fail"(0)
    lt rx2242_pos, -1, rx2242_done
    eq rx2242_pos, -1, rx2242_fail
    jump $I10
  rx2242_done:
    rx2242_cur."!cursor_fail"()
    if_null rx2242_debug, debug_1331
    rx2242_cur."!cursor_debug"("FAIL", "regex_declarator")
  debug_1331:
    .return (rx2242_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__regex_declarator"  :subid("243_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2280 = self."!PREFIX__!subrule"("ws", "")
    new $P2281, "ResizablePMCArray"
    push $P2281, $P2280
    .return ($P2281)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "dotty"  :subid("244_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2283_tgt
    .local int rx2283_pos
    .local int rx2283_off
    .local int rx2283_eos
    .local int rx2283_rep
    .local pmc rx2283_cur
    .local pmc rx2283_debug
    (rx2283_cur, rx2283_pos, rx2283_tgt, $I10) = self."!cursor_start"()
    rx2283_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx2283_cur
    .local pmc match
    .lex "$/", match
    length rx2283_eos, rx2283_tgt
    gt rx2283_pos, rx2283_eos, rx2283_done
    set rx2283_off, 0
    lt rx2283_pos, 2, rx2283_start
    sub rx2283_off, rx2283_pos, 1
    substr rx2283_tgt, rx2283_tgt, rx2283_off
  rx2283_start:
    eq $I10, 1, rx2283_restart
    if_null rx2283_debug, debug_1332
    rx2283_cur."!cursor_debug"("START", "dotty")
  debug_1332:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2284_done
    goto rxscan2284_scan
  rxscan2284_loop:
    (rx2283_pos) = rx2283_cur."from"()
    inc rx2283_pos
    rx2283_cur."!cursor_from"(rx2283_pos)
    ge rx2283_pos, rx2283_eos, rxscan2284_done
  rxscan2284_scan:
    set_addr $I10, rxscan2284_loop
    rx2283_cur."!mark_push"(0, rx2283_pos, $I10)
  rxscan2284_done:
.annotate 'line', 949
  # rx literal  "."
    add $I11, rx2283_pos, 1
    gt $I11, rx2283_eos, rx2283_fail
    sub $I11, rx2283_pos, rx2283_off
    ord $I11, rx2283_tgt, $I11
    ne $I11, 46, rx2283_fail
    add rx2283_pos, 1
  alt2285_0:
.annotate 'line', 950
    set_addr $I10, alt2285_1
    rx2283_cur."!mark_push"(0, rx2283_pos, $I10)
  # rx subrule "deflongname" subtype=capture negate=
    rx2283_cur."!cursor_pos"(rx2283_pos)
    $P10 = rx2283_cur."deflongname"()
    unless $P10, rx2283_fail
    rx2283_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname=deflongname")
    rx2283_pos = $P10."pos"()
    goto alt2285_end
  alt2285_1:
.annotate 'line', 951
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2283_pos, rx2283_off
    substr $S10, rx2283_tgt, $I10, 1
    index $I11, "'\"", $S10
    lt $I11, 0, rx2283_fail
  # rx subrule "quote" subtype=capture negate=
    rx2283_cur."!cursor_pos"(rx2283_pos)
    $P10 = rx2283_cur."quote"()
    unless $P10, rx2283_fail
    rx2283_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx2283_pos = $P10."pos"()
  alt2286_0:
.annotate 'line', 952
    set_addr $I10, alt2286_1
    rx2283_cur."!mark_push"(0, rx2283_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2283_pos, rx2283_off
    substr $S10, rx2283_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx2283_fail
    goto alt2286_end
  alt2286_1:
  # rx subrule "panic" subtype=method negate=
    rx2283_cur."!cursor_pos"(rx2283_pos)
    $P10 = rx2283_cur."panic"("Quoted method name requires parenthesized arguments")
    unless $P10, rx2283_fail
    rx2283_pos = $P10."pos"()
  alt2286_end:
  alt2285_end:
.annotate 'line', 958
  # rx rxquantr2287 ** 0..1
    set_addr $I10, rxquantr2287_done
    rx2283_cur."!mark_push"(0, rx2283_pos, $I10)
  rxquantr2287_loop:
  alt2288_0:
.annotate 'line', 955
    set_addr $I10, alt2288_1
    rx2283_cur."!mark_push"(0, rx2283_pos, $I10)
.annotate 'line', 956
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2283_pos, rx2283_off
    substr $S10, rx2283_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx2283_fail
  # rx subrule "args" subtype=capture negate=
    rx2283_cur."!cursor_pos"(rx2283_pos)
    $P10 = rx2283_cur."args"()
    unless $P10, rx2283_fail
    rx2283_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx2283_pos = $P10."pos"()
    goto alt2288_end
  alt2288_1:
.annotate 'line', 957
  # rx literal  ":"
    add $I11, rx2283_pos, 1
    gt $I11, rx2283_eos, rx2283_fail
    sub $I11, rx2283_pos, rx2283_off
    ord $I11, rx2283_tgt, $I11
    ne $I11, 58, rx2283_fail
    add rx2283_pos, 1
  # rx charclass s
    ge rx2283_pos, rx2283_eos, rx2283_fail
    sub $I10, rx2283_pos, rx2283_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx2283_tgt, $I10
    unless $I11, rx2283_fail
    inc rx2283_pos
  # rx subrule "arglist" subtype=capture negate=
    rx2283_cur."!cursor_pos"(rx2283_pos)
    $P10 = rx2283_cur."arglist"()
    unless $P10, rx2283_fail
    rx2283_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx2283_pos = $P10."pos"()
  alt2288_end:
.annotate 'line', 958
    set_addr $I10, rxquantr2287_done
    (rx2283_rep) = rx2283_cur."!mark_commit"($I10)
  rxquantr2287_done:
.annotate 'line', 948
  # rx pass
    rx2283_cur."!cursor_pass"(rx2283_pos, "dotty")
    if_null rx2283_debug, debug_1333
    rx2283_cur."!cursor_debug"("PASS", "dotty", " at pos=", rx2283_pos)
  debug_1333:
    .return (rx2283_cur)
  rx2283_restart:
.annotate 'line', 436
    if_null rx2283_debug, debug_1334
    rx2283_cur."!cursor_debug"("NEXT", "dotty")
  debug_1334:
  rx2283_fail:
    (rx2283_rep, rx2283_pos, $I10, $P10) = rx2283_cur."!mark_fail"(0)
    lt rx2283_pos, -1, rx2283_done
    eq rx2283_pos, -1, rx2283_fail
    jump $I10
  rx2283_done:
    rx2283_cur."!cursor_fail"()
    if_null rx2283_debug, debug_1335
    rx2283_cur."!cursor_debug"("FAIL", "dotty")
  debug_1335:
    .return (rx2283_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__dotty"  :subid("245_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2290 = self."!PREFIX__!subrule"("deflongname", ".")
    new $P2291, "ResizablePMCArray"
    push $P2291, "'"
    push $P2291, "\""
    push $P2291, $P2290
    .return ($P2291)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term"  :subid("246_1307873304.82979")
    .param pmc param_2293
.annotate 'line', 962
    .lex "self", param_2293
    $P2294 = param_2293."!protoregex"("term")
    .return ($P2294)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term"  :subid("247_1307873304.82979")
    .param pmc param_2296
.annotate 'line', 962
    .lex "self", param_2296
    $P2297 = param_2296."!PREFIX__!protoregex"("term")
    .return ($P2297)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<self>"  :subid("248_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2299_tgt
    .local int rx2299_pos
    .local int rx2299_off
    .local int rx2299_eos
    .local int rx2299_rep
    .local pmc rx2299_cur
    .local pmc rx2299_debug
    (rx2299_cur, rx2299_pos, rx2299_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2299_cur
    .local pmc match
    .lex "$/", match
    length rx2299_eos, rx2299_tgt
    gt rx2299_pos, rx2299_eos, rx2299_done
    set rx2299_off, 0
    lt rx2299_pos, 2, rx2299_start
    sub rx2299_off, rx2299_pos, 1
    substr rx2299_tgt, rx2299_tgt, rx2299_off
  rx2299_start:
    eq $I10, 1, rx2299_restart
    if_null rx2299_debug, debug_1336
    rx2299_cur."!cursor_debug"("START", "term:sym<self>")
  debug_1336:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2300_done
    goto rxscan2300_scan
  rxscan2300_loop:
    (rx2299_pos) = rx2299_cur."from"()
    inc rx2299_pos
    rx2299_cur."!cursor_from"(rx2299_pos)
    ge rx2299_pos, rx2299_eos, rxscan2300_done
  rxscan2300_scan:
    set_addr $I10, rxscan2300_loop
    rx2299_cur."!mark_push"(0, rx2299_pos, $I10)
  rxscan2300_done:
.annotate 'line', 964
  # rx subcapture "sym"
    set_addr $I10, rxcap_2301_fail
    rx2299_cur."!mark_push"(0, rx2299_pos, $I10)
  # rx literal  "self"
    add $I11, rx2299_pos, 4
    gt $I11, rx2299_eos, rx2299_fail
    sub $I11, rx2299_pos, rx2299_off
    substr $S10, rx2299_tgt, $I11, 4
    ne $S10, "self", rx2299_fail
    add rx2299_pos, 4
    set_addr $I10, rxcap_2301_fail
    ($I12, $I11) = rx2299_cur."!mark_peek"($I10)
    rx2299_cur."!cursor_pos"($I11)
    ($P10) = rx2299_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2299_pos, "")
    rx2299_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2301_done
  rxcap_2301_fail:
    goto rx2299_fail
  rxcap_2301_done:
  # rxanchor rwb
    le rx2299_pos, 0, rx2299_fail
    sub $I10, rx2299_pos, rx2299_off
    is_cclass $I11, .CCLASS_WORD, rx2299_tgt, $I10
    if $I11, rx2299_fail
    dec $I10
    is_cclass $I11, .CCLASS_WORD, rx2299_tgt, $I10
    unless $I11, rx2299_fail
  # rx pass
    rx2299_cur."!cursor_pass"(rx2299_pos, "term:sym<self>")
    if_null rx2299_debug, debug_1337
    rx2299_cur."!cursor_debug"("PASS", "term:sym<self>", " at pos=", rx2299_pos)
  debug_1337:
    .return (rx2299_cur)
  rx2299_restart:
.annotate 'line', 436
    if_null rx2299_debug, debug_1338
    rx2299_cur."!cursor_debug"("NEXT", "term:sym<self>")
  debug_1338:
  rx2299_fail:
    (rx2299_rep, rx2299_pos, $I10, $P10) = rx2299_cur."!mark_fail"(0)
    lt rx2299_pos, -1, rx2299_done
    eq rx2299_pos, -1, rx2299_fail
    jump $I10
  rx2299_done:
    rx2299_cur."!cursor_fail"()
    if_null rx2299_debug, debug_1339
    rx2299_cur."!cursor_debug"("FAIL", "term:sym<self>")
  debug_1339:
    .return (rx2299_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<self>"  :subid("249_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    new $P2303, "ResizablePMCArray"
    push $P2303, "self"
    .return ($P2303)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<identifier>"  :subid("250_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2305_tgt
    .local int rx2305_pos
    .local int rx2305_off
    .local int rx2305_eos
    .local int rx2305_rep
    .local pmc rx2305_cur
    .local pmc rx2305_debug
    (rx2305_cur, rx2305_pos, rx2305_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2305_cur
    .local pmc match
    .lex "$/", match
    length rx2305_eos, rx2305_tgt
    gt rx2305_pos, rx2305_eos, rx2305_done
    set rx2305_off, 0
    lt rx2305_pos, 2, rx2305_start
    sub rx2305_off, rx2305_pos, 1
    substr rx2305_tgt, rx2305_tgt, rx2305_off
  rx2305_start:
    eq $I10, 1, rx2305_restart
    if_null rx2305_debug, debug_1340
    rx2305_cur."!cursor_debug"("START", "term:sym<identifier>")
  debug_1340:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2306_done
    goto rxscan2306_scan
  rxscan2306_loop:
    (rx2305_pos) = rx2305_cur."from"()
    inc rx2305_pos
    rx2305_cur."!cursor_from"(rx2305_pos)
    ge rx2305_pos, rx2305_eos, rxscan2306_done
  rxscan2306_scan:
    set_addr $I10, rxscan2306_loop
    rx2305_cur."!mark_push"(0, rx2305_pos, $I10)
  rxscan2306_done:
.annotate 'line', 967
  # rx subrule "deflongname" subtype=capture negate=
    rx2305_cur."!cursor_pos"(rx2305_pos)
    $P10 = rx2305_cur."deflongname"()
    unless $P10, rx2305_fail
    rx2305_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx2305_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2305_pos, rx2305_off
    substr $S10, rx2305_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx2305_fail
  # rx subrule "args" subtype=capture negate=
    rx2305_cur."!cursor_pos"(rx2305_pos)
    $P10 = rx2305_cur."args"()
    unless $P10, rx2305_fail
    rx2305_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx2305_pos = $P10."pos"()
.annotate 'line', 966
  # rx pass
    rx2305_cur."!cursor_pass"(rx2305_pos, "term:sym<identifier>")
    if_null rx2305_debug, debug_1341
    rx2305_cur."!cursor_debug"("PASS", "term:sym<identifier>", " at pos=", rx2305_pos)
  debug_1341:
    .return (rx2305_cur)
  rx2305_restart:
.annotate 'line', 436
    if_null rx2305_debug, debug_1342
    rx2305_cur."!cursor_debug"("NEXT", "term:sym<identifier>")
  debug_1342:
  rx2305_fail:
    (rx2305_rep, rx2305_pos, $I10, $P10) = rx2305_cur."!mark_fail"(0)
    lt rx2305_pos, -1, rx2305_done
    eq rx2305_pos, -1, rx2305_fail
    jump $I10
  rx2305_done:
    rx2305_cur."!cursor_fail"()
    if_null rx2305_debug, debug_1343
    rx2305_cur."!cursor_debug"("FAIL", "term:sym<identifier>")
  debug_1343:
    .return (rx2305_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<identifier>"  :subid("251_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2308 = self."!PREFIX__!subrule"("deflongname", "")
    new $P2309, "ResizablePMCArray"
    push $P2309, $P2308
    .return ($P2309)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<name>"  :subid("252_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2311_tgt
    .local int rx2311_pos
    .local int rx2311_off
    .local int rx2311_eos
    .local int rx2311_rep
    .local pmc rx2311_cur
    .local pmc rx2311_debug
    (rx2311_cur, rx2311_pos, rx2311_tgt, $I10) = self."!cursor_start"()
    rx2311_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx2311_cur
    .local pmc match
    .lex "$/", match
    length rx2311_eos, rx2311_tgt
    gt rx2311_pos, rx2311_eos, rx2311_done
    set rx2311_off, 0
    lt rx2311_pos, 2, rx2311_start
    sub rx2311_off, rx2311_pos, 1
    substr rx2311_tgt, rx2311_tgt, rx2311_off
  rx2311_start:
    eq $I10, 1, rx2311_restart
    if_null rx2311_debug, debug_1344
    rx2311_cur."!cursor_debug"("START", "term:sym<name>")
  debug_1344:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2312_done
    goto rxscan2312_scan
  rxscan2312_loop:
    (rx2311_pos) = rx2311_cur."from"()
    inc rx2311_pos
    rx2311_cur."!cursor_from"(rx2311_pos)
    ge rx2311_pos, rx2311_eos, rxscan2312_done
  rxscan2312_scan:
    set_addr $I10, rxscan2312_loop
    rx2311_cur."!mark_push"(0, rx2311_pos, $I10)
  rxscan2312_done:
.annotate 'line', 971
  # rx subrule "name" subtype=capture negate=
    rx2311_cur."!cursor_pos"(rx2311_pos)
    $P10 = rx2311_cur."name"()
    unless $P10, rx2311_fail
    rx2311_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx2311_pos = $P10."pos"()
  # rx rxquantr2313 ** 0..1
    set_addr $I10, rxquantr2313_done
    rx2311_cur."!mark_push"(0, rx2311_pos, $I10)
  rxquantr2313_loop:
  # rx subrule "args" subtype=capture negate=
    rx2311_cur."!cursor_pos"(rx2311_pos)
    $P10 = rx2311_cur."args"()
    unless $P10, rx2311_fail
    goto rxsubrule2314_pass
  rxsubrule2314_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx2311_fail
  rxsubrule2314_pass:
    set_addr $I10, rxsubrule2314_back
    rx2311_cur."!mark_push"(0, rx2311_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx2311_pos = $P10."pos"()
    set_addr $I10, rxquantr2313_done
    (rx2311_rep) = rx2311_cur."!mark_commit"($I10)
  rxquantr2313_done:
.annotate 'line', 970
  # rx pass
    rx2311_cur."!cursor_pass"(rx2311_pos, "term:sym<name>")
    if_null rx2311_debug, debug_1345
    rx2311_cur."!cursor_debug"("PASS", "term:sym<name>", " at pos=", rx2311_pos)
  debug_1345:
    .return (rx2311_cur)
  rx2311_restart:
.annotate 'line', 436
    if_null rx2311_debug, debug_1346
    rx2311_cur."!cursor_debug"("NEXT", "term:sym<name>")
  debug_1346:
  rx2311_fail:
    (rx2311_rep, rx2311_pos, $I10, $P10) = rx2311_cur."!mark_fail"(0)
    lt rx2311_pos, -1, rx2311_done
    eq rx2311_pos, -1, rx2311_fail
    jump $I10
  rx2311_done:
    rx2311_cur."!cursor_fail"()
    if_null rx2311_debug, debug_1347
    rx2311_cur."!cursor_debug"("FAIL", "term:sym<name>")
  debug_1347:
    .return (rx2311_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<name>"  :subid("253_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2316 = self."!PREFIX__!subrule"("name", "")
    new $P2317, "ResizablePMCArray"
    push $P2317, $P2316
    .return ($P2317)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<pir::op>"  :subid("254_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2319_tgt
    .local int rx2319_pos
    .local int rx2319_off
    .local int rx2319_eos
    .local int rx2319_rep
    .local pmc rx2319_cur
    .local pmc rx2319_debug
    (rx2319_cur, rx2319_pos, rx2319_tgt, $I10) = self."!cursor_start"()
    rx2319_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx2319_cur
    .local pmc match
    .lex "$/", match
    length rx2319_eos, rx2319_tgt
    gt rx2319_pos, rx2319_eos, rx2319_done
    set rx2319_off, 0
    lt rx2319_pos, 2, rx2319_start
    sub rx2319_off, rx2319_pos, 1
    substr rx2319_tgt, rx2319_tgt, rx2319_off
  rx2319_start:
    eq $I10, 1, rx2319_restart
    if_null rx2319_debug, debug_1348
    rx2319_cur."!cursor_debug"("START", "term:sym<pir::op>")
  debug_1348:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2320_done
    goto rxscan2320_scan
  rxscan2320_loop:
    (rx2319_pos) = rx2319_cur."from"()
    inc rx2319_pos
    rx2319_cur."!cursor_from"(rx2319_pos)
    ge rx2319_pos, rx2319_eos, rxscan2320_done
  rxscan2320_scan:
    set_addr $I10, rxscan2320_loop
    rx2319_cur."!mark_push"(0, rx2319_pos, $I10)
  rxscan2320_done:
.annotate 'line', 975
  # rx literal  "pir::"
    add $I11, rx2319_pos, 5
    gt $I11, rx2319_eos, rx2319_fail
    sub $I11, rx2319_pos, rx2319_off
    substr $S10, rx2319_tgt, $I11, 5
    ne $S10, "pir::", rx2319_fail
    add rx2319_pos, 5
  # rx subcapture "op"
    set_addr $I10, rxcap_2321_fail
    rx2319_cur."!mark_push"(0, rx2319_pos, $I10)
  # rx charclass_q w r 1..-1
    sub $I10, rx2319_pos, rx2319_off
    find_not_cclass $I11, .CCLASS_WORD, rx2319_tgt, $I10, rx2319_eos
    add $I12, $I10, 1
    lt $I11, $I12, rx2319_fail
    add rx2319_pos, rx2319_off, $I11
    set_addr $I10, rxcap_2321_fail
    ($I12, $I11) = rx2319_cur."!mark_peek"($I10)
    rx2319_cur."!cursor_pos"($I11)
    ($P10) = rx2319_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2319_pos, "")
    rx2319_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("op")
    goto rxcap_2321_done
  rxcap_2321_fail:
    goto rx2319_fail
  rxcap_2321_done:
  # rx rxquantr2322 ** 0..1
    set_addr $I10, rxquantr2322_done
    rx2319_cur."!mark_push"(0, rx2319_pos, $I10)
  rxquantr2322_loop:
  # rx subrule "args" subtype=capture negate=
    rx2319_cur."!cursor_pos"(rx2319_pos)
    $P10 = rx2319_cur."args"()
    unless $P10, rx2319_fail
    goto rxsubrule2323_pass
  rxsubrule2323_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx2319_fail
  rxsubrule2323_pass:
    set_addr $I10, rxsubrule2323_back
    rx2319_cur."!mark_push"(0, rx2319_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx2319_pos = $P10."pos"()
    set_addr $I10, rxquantr2322_done
    (rx2319_rep) = rx2319_cur."!mark_commit"($I10)
  rxquantr2322_done:
.annotate 'line', 974
  # rx pass
    rx2319_cur."!cursor_pass"(rx2319_pos, "term:sym<pir::op>")
    if_null rx2319_debug, debug_1349
    rx2319_cur."!cursor_debug"("PASS", "term:sym<pir::op>", " at pos=", rx2319_pos)
  debug_1349:
    .return (rx2319_cur)
  rx2319_restart:
.annotate 'line', 436
    if_null rx2319_debug, debug_1350
    rx2319_cur."!cursor_debug"("NEXT", "term:sym<pir::op>")
  debug_1350:
  rx2319_fail:
    (rx2319_rep, rx2319_pos, $I10, $P10) = rx2319_cur."!mark_fail"(0)
    lt rx2319_pos, -1, rx2319_done
    eq rx2319_pos, -1, rx2319_fail
    jump $I10
  rx2319_done:
    rx2319_cur."!cursor_fail"()
    if_null rx2319_debug, debug_1351
    rx2319_cur."!cursor_debug"("FAIL", "term:sym<pir::op>")
  debug_1351:
    .return (rx2319_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<pir::op>"  :subid("255_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    new $P2325, "ResizablePMCArray"
    push $P2325, "pir::"
    .return ($P2325)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<pir::const>"  :subid("256_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2327_tgt
    .local int rx2327_pos
    .local int rx2327_off
    .local int rx2327_eos
    .local int rx2327_rep
    .local pmc rx2327_cur
    .local pmc rx2327_debug
    (rx2327_cur, rx2327_pos, rx2327_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2327_cur
    .local pmc match
    .lex "$/", match
    length rx2327_eos, rx2327_tgt
    gt rx2327_pos, rx2327_eos, rx2327_done
    set rx2327_off, 0
    lt rx2327_pos, 2, rx2327_start
    sub rx2327_off, rx2327_pos, 1
    substr rx2327_tgt, rx2327_tgt, rx2327_off
  rx2327_start:
    eq $I10, 1, rx2327_restart
    if_null rx2327_debug, debug_1352
    rx2327_cur."!cursor_debug"("START", "term:sym<pir::const>")
  debug_1352:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2328_done
    goto rxscan2328_scan
  rxscan2328_loop:
    (rx2327_pos) = rx2327_cur."from"()
    inc rx2327_pos
    rx2327_cur."!cursor_from"(rx2327_pos)
    ge rx2327_pos, rx2327_eos, rxscan2328_done
  rxscan2328_scan:
    set_addr $I10, rxscan2328_loop
    rx2327_cur."!mark_push"(0, rx2327_pos, $I10)
  rxscan2328_done:
.annotate 'line', 979
  # rx literal  "pir::const::"
    add $I11, rx2327_pos, 12
    gt $I11, rx2327_eos, rx2327_fail
    sub $I11, rx2327_pos, rx2327_off
    substr $S10, rx2327_tgt, $I11, 12
    ne $S10, "pir::const::", rx2327_fail
    add rx2327_pos, 12
  # rx subcapture "const"
    set_addr $I10, rxcap_2329_fail
    rx2327_cur."!mark_push"(0, rx2327_pos, $I10)
  # rx charclass_q w r 1..-1
    sub $I10, rx2327_pos, rx2327_off
    find_not_cclass $I11, .CCLASS_WORD, rx2327_tgt, $I10, rx2327_eos
    add $I12, $I10, 1
    lt $I11, $I12, rx2327_fail
    add rx2327_pos, rx2327_off, $I11
    set_addr $I10, rxcap_2329_fail
    ($I12, $I11) = rx2327_cur."!mark_peek"($I10)
    rx2327_cur."!cursor_pos"($I11)
    ($P10) = rx2327_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2327_pos, "")
    rx2327_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("const")
    goto rxcap_2329_done
  rxcap_2329_fail:
    goto rx2327_fail
  rxcap_2329_done:
.annotate 'line', 978
  # rx pass
    rx2327_cur."!cursor_pass"(rx2327_pos, "term:sym<pir::const>")
    if_null rx2327_debug, debug_1353
    rx2327_cur."!cursor_debug"("PASS", "term:sym<pir::const>", " at pos=", rx2327_pos)
  debug_1353:
    .return (rx2327_cur)
  rx2327_restart:
.annotate 'line', 436
    if_null rx2327_debug, debug_1354
    rx2327_cur."!cursor_debug"("NEXT", "term:sym<pir::const>")
  debug_1354:
  rx2327_fail:
    (rx2327_rep, rx2327_pos, $I10, $P10) = rx2327_cur."!mark_fail"(0)
    lt rx2327_pos, -1, rx2327_done
    eq rx2327_pos, -1, rx2327_fail
    jump $I10
  rx2327_done:
    rx2327_cur."!cursor_fail"()
    if_null rx2327_debug, debug_1355
    rx2327_cur."!cursor_debug"("FAIL", "term:sym<pir::const>")
  debug_1355:
    .return (rx2327_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<pir::const>"  :subid("257_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    new $P2331, "ResizablePMCArray"
    push $P2331, "pir::const::"
    .return ($P2331)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<onlystar>"  :subid("258_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .const 'Sub' $P2339 = "259_1307873304.82979" 
    capture_lex $P2339
    .local string rx2333_tgt
    .local int rx2333_pos
    .local int rx2333_off
    .local int rx2333_eos
    .local int rx2333_rep
    .local pmc rx2333_cur
    .local pmc rx2333_debug
    (rx2333_cur, rx2333_pos, rx2333_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2333_cur
    .local pmc match
    .lex "$/", match
    length rx2333_eos, rx2333_tgt
    gt rx2333_pos, rx2333_eos, rx2333_done
    set rx2333_off, 0
    lt rx2333_pos, 2, rx2333_start
    sub rx2333_off, rx2333_pos, 1
    substr rx2333_tgt, rx2333_tgt, rx2333_off
  rx2333_start:
    eq $I10, 1, rx2333_restart
    if_null rx2333_debug, debug_1356
    rx2333_cur."!cursor_debug"("START", "term:sym<onlystar>")
  debug_1356:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2334_done
    goto rxscan2334_scan
  rxscan2334_loop:
    (rx2333_pos) = rx2333_cur."from"()
    inc rx2333_pos
    rx2333_cur."!cursor_from"(rx2333_pos)
    ge rx2333_pos, rx2333_eos, rxscan2334_done
  rxscan2334_scan:
    set_addr $I10, rxscan2334_loop
    rx2333_cur."!mark_push"(0, rx2333_pos, $I10)
  rxscan2334_done:
.annotate 'line', 983
  # rx literal  "{*}"
    add $I11, rx2333_pos, 3
    gt $I11, rx2333_eos, rx2333_fail
    sub $I11, rx2333_pos, rx2333_off
    substr $S10, rx2333_tgt, $I11, 3
    ne $S10, "{*}", rx2333_fail
    add rx2333_pos, 3
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx2333_cur."!cursor_pos"(rx2333_pos)
    $P10 = rx2333_cur."ENDSTMT"()
    unless $P10, rx2333_fail
  alt2335_0:
.annotate 'line', 984
    set_addr $I10, alt2335_1
    rx2333_cur."!mark_push"(0, rx2333_pos, $I10)
    rx2333_cur."!cursor_pos"(rx2333_pos)
    find_lex $P2336, unicode:"$\x{a2}"
    $P2337 = $P2336."MATCH"()
    store_lex "$/", $P2337
    .const 'Sub' $P2339 = "259_1307873304.82979" 
    capture_lex $P2339
    $P2345 = $P2339()
    unless $P2345, rx2333_fail
    goto alt2335_end
  alt2335_1:
  # rx subrule "panic" subtype=method negate=
    rx2333_cur."!cursor_pos"(rx2333_pos)
    $P10 = rx2333_cur."panic"("{*} may only appear in proto")
    unless $P10, rx2333_fail
    rx2333_pos = $P10."pos"()
  alt2335_end:
.annotate 'line', 982
  # rx pass
    rx2333_cur."!cursor_pass"(rx2333_pos, "term:sym<onlystar>")
    if_null rx2333_debug, debug_1359
    rx2333_cur."!cursor_debug"("PASS", "term:sym<onlystar>", " at pos=", rx2333_pos)
  debug_1359:
    .return (rx2333_cur)
  rx2333_restart:
.annotate 'line', 436
    if_null rx2333_debug, debug_1360
    rx2333_cur."!cursor_debug"("NEXT", "term:sym<onlystar>")
  debug_1360:
  rx2333_fail:
    (rx2333_rep, rx2333_pos, $I10, $P10) = rx2333_cur."!mark_fail"(0)
    lt rx2333_pos, -1, rx2333_done
    eq rx2333_pos, -1, rx2333_fail
    jump $I10
  rx2333_done:
    rx2333_cur."!cursor_fail"()
    if_null rx2333_debug, debug_1361
    rx2333_cur."!cursor_debug"("FAIL", "term:sym<onlystar>")
  debug_1361:
    .return (rx2333_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block2338"  :anon :subid("259_1307873304.82979") :outer("258_1307873304.82979")
.annotate 'line', 984
    find_dynamic_lex $P2342, "$*MULTINESS"
    unless_null $P2342, vivify_1357
    get_hll_global $P2340, "GLOBAL"
    get_who $P2341, $P2340
    set $P2342, $P2341["$MULTINESS"]
    unless_null $P2342, vivify_1358
    die "Contextual $*MULTINESS not found"
  vivify_1358:
  vivify_1357:
    set $S2343, $P2342
    iseq $I2344, $S2343, "proto"
    .return ($I2344)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<onlystar>"  :subid("260_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    new $P2347, "ResizablePMCArray"
    push $P2347, "{*}"
    .return ($P2347)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "args"  :subid("261_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2349_tgt
    .local int rx2349_pos
    .local int rx2349_off
    .local int rx2349_eos
    .local int rx2349_rep
    .local pmc rx2349_cur
    .local pmc rx2349_debug
    (rx2349_cur, rx2349_pos, rx2349_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2349_cur
    .local pmc match
    .lex "$/", match
    length rx2349_eos, rx2349_tgt
    gt rx2349_pos, rx2349_eos, rx2349_done
    set rx2349_off, 0
    lt rx2349_pos, 2, rx2349_start
    sub rx2349_off, rx2349_pos, 1
    substr rx2349_tgt, rx2349_tgt, rx2349_off
  rx2349_start:
    eq $I10, 1, rx2349_restart
    if_null rx2349_debug, debug_1362
    rx2349_cur."!cursor_debug"("START", "args")
  debug_1362:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2350_done
    goto rxscan2350_scan
  rxscan2350_loop:
    (rx2349_pos) = rx2349_cur."from"()
    inc rx2349_pos
    rx2349_cur."!cursor_from"(rx2349_pos)
    ge rx2349_pos, rx2349_eos, rxscan2350_done
  rxscan2350_scan:
    set_addr $I10, rxscan2350_loop
    rx2349_cur."!mark_push"(0, rx2349_pos, $I10)
  rxscan2350_done:
.annotate 'line', 988
  # rx literal  "("
    add $I11, rx2349_pos, 1
    gt $I11, rx2349_eos, rx2349_fail
    sub $I11, rx2349_pos, rx2349_off
    ord $I11, rx2349_tgt, $I11
    ne $I11, 40, rx2349_fail
    add rx2349_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx2349_cur."!cursor_pos"(rx2349_pos)
    $P10 = rx2349_cur."arglist"()
    unless $P10, rx2349_fail
    rx2349_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2349_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx2349_pos, 1
    gt $I11, rx2349_eos, rx2349_fail
    sub $I11, rx2349_pos, rx2349_off
    ord $I11, rx2349_tgt, $I11
    ne $I11, 41, rx2349_fail
    add rx2349_pos, 1
  # rx pass
    rx2349_cur."!cursor_pass"(rx2349_pos, "args")
    if_null rx2349_debug, debug_1363
    rx2349_cur."!cursor_debug"("PASS", "args", " at pos=", rx2349_pos)
  debug_1363:
    .return (rx2349_cur)
  rx2349_restart:
.annotate 'line', 436
    if_null rx2349_debug, debug_1364
    rx2349_cur."!cursor_debug"("NEXT", "args")
  debug_1364:
  rx2349_fail:
    (rx2349_rep, rx2349_pos, $I10, $P10) = rx2349_cur."!mark_fail"(0)
    lt rx2349_pos, -1, rx2349_done
    eq rx2349_pos, -1, rx2349_fail
    jump $I10
  rx2349_done:
    rx2349_cur."!cursor_fail"()
    if_null rx2349_debug, debug_1365
    rx2349_cur."!cursor_debug"("FAIL", "args")
  debug_1365:
    .return (rx2349_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__args"  :subid("262_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2352 = self."!PREFIX__!subrule"("arglist", "(")
    new $P2353, "ResizablePMCArray"
    push $P2353, $P2352
    .return ($P2353)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "arglist"  :subid("263_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2355_tgt
    .local int rx2355_pos
    .local int rx2355_off
    .local int rx2355_eos
    .local int rx2355_rep
    .local pmc rx2355_cur
    .local pmc rx2355_debug
    (rx2355_cur, rx2355_pos, rx2355_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2355_cur
    .local pmc match
    .lex "$/", match
    length rx2355_eos, rx2355_tgt
    gt rx2355_pos, rx2355_eos, rx2355_done
    set rx2355_off, 0
    lt rx2355_pos, 2, rx2355_start
    sub rx2355_off, rx2355_pos, 1
    substr rx2355_tgt, rx2355_tgt, rx2355_off
  rx2355_start:
    eq $I10, 1, rx2355_restart
    if_null rx2355_debug, debug_1366
    rx2355_cur."!cursor_debug"("START", "arglist")
  debug_1366:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2356_done
    goto rxscan2356_scan
  rxscan2356_loop:
    (rx2355_pos) = rx2355_cur."from"()
    inc rx2355_pos
    rx2355_cur."!cursor_from"(rx2355_pos)
    ge rx2355_pos, rx2355_eos, rxscan2356_done
  rxscan2356_scan:
    set_addr $I10, rxscan2356_loop
    rx2355_cur."!mark_push"(0, rx2355_pos, $I10)
  rxscan2356_done:
.annotate 'line', 992
  # rx subrule "ws" subtype=method negate=
    rx2355_cur."!cursor_pos"(rx2355_pos)
    $P10 = rx2355_cur."ws"()
    unless $P10, rx2355_fail
    rx2355_pos = $P10."pos"()
  alt2357_0:
.annotate 'line', 993
    set_addr $I10, alt2357_1
    rx2355_cur."!mark_push"(0, rx2355_pos, $I10)
.annotate 'line', 994
  # rx subrule "EXPR" subtype=capture negate=
    rx2355_cur."!cursor_pos"(rx2355_pos)
    $P10 = rx2355_cur."EXPR"("f=")
    unless $P10, rx2355_fail
    rx2355_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx2355_pos = $P10."pos"()
    goto alt2357_end
  alt2357_1:
  alt2357_end:
.annotate 'line', 991
  # rx pass
    rx2355_cur."!cursor_pass"(rx2355_pos, "arglist")
    if_null rx2355_debug, debug_1367
    rx2355_cur."!cursor_debug"("PASS", "arglist", " at pos=", rx2355_pos)
  debug_1367:
    .return (rx2355_cur)
  rx2355_restart:
.annotate 'line', 436
    if_null rx2355_debug, debug_1368
    rx2355_cur."!cursor_debug"("NEXT", "arglist")
  debug_1368:
  rx2355_fail:
    (rx2355_rep, rx2355_pos, $I10, $P10) = rx2355_cur."!mark_fail"(0)
    lt rx2355_pos, -1, rx2355_done
    eq rx2355_pos, -1, rx2355_fail
    jump $I10
  rx2355_done:
    rx2355_cur."!cursor_fail"()
    if_null rx2355_debug, debug_1369
    rx2355_cur."!cursor_debug"("FAIL", "arglist")
  debug_1369:
    .return (rx2355_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__arglist"  :subid("264_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2359 = self."!PREFIX__!subrule"("ws", "")
    new $P2360, "ResizablePMCArray"
    push $P2360, $P2359
    .return ($P2360)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<value>"  :subid("265_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2362_tgt
    .local int rx2362_pos
    .local int rx2362_off
    .local int rx2362_eos
    .local int rx2362_rep
    .local pmc rx2362_cur
    .local pmc rx2362_debug
    (rx2362_cur, rx2362_pos, rx2362_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2362_cur
    .local pmc match
    .lex "$/", match
    length rx2362_eos, rx2362_tgt
    gt rx2362_pos, rx2362_eos, rx2362_done
    set rx2362_off, 0
    lt rx2362_pos, 2, rx2362_start
    sub rx2362_off, rx2362_pos, 1
    substr rx2362_tgt, rx2362_tgt, rx2362_off
  rx2362_start:
    eq $I10, 1, rx2362_restart
    if_null rx2362_debug, debug_1370
    rx2362_cur."!cursor_debug"("START", "term:sym<value>")
  debug_1370:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2363_done
    goto rxscan2363_scan
  rxscan2363_loop:
    (rx2362_pos) = rx2362_cur."from"()
    inc rx2362_pos
    rx2362_cur."!cursor_from"(rx2362_pos)
    ge rx2362_pos, rx2362_eos, rxscan2363_done
  rxscan2363_scan:
    set_addr $I10, rxscan2363_loop
    rx2362_cur."!mark_push"(0, rx2362_pos, $I10)
  rxscan2363_done:
.annotate 'line', 1000
  # rx subrule "value" subtype=capture negate=
    rx2362_cur."!cursor_pos"(rx2362_pos)
    $P10 = rx2362_cur."value"()
    unless $P10, rx2362_fail
    rx2362_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("value")
    rx2362_pos = $P10."pos"()
  # rx pass
    rx2362_cur."!cursor_pass"(rx2362_pos, "term:sym<value>")
    if_null rx2362_debug, debug_1371
    rx2362_cur."!cursor_debug"("PASS", "term:sym<value>", " at pos=", rx2362_pos)
  debug_1371:
    .return (rx2362_cur)
  rx2362_restart:
.annotate 'line', 436
    if_null rx2362_debug, debug_1372
    rx2362_cur."!cursor_debug"("NEXT", "term:sym<value>")
  debug_1372:
  rx2362_fail:
    (rx2362_rep, rx2362_pos, $I10, $P10) = rx2362_cur."!mark_fail"(0)
    lt rx2362_pos, -1, rx2362_done
    eq rx2362_pos, -1, rx2362_fail
    jump $I10
  rx2362_done:
    rx2362_cur."!cursor_fail"()
    if_null rx2362_debug, debug_1373
    rx2362_cur."!cursor_debug"("FAIL", "term:sym<value>")
  debug_1373:
    .return (rx2362_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<value>"  :subid("266_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2365 = self."!PREFIX__!subrule"("value", "")
    new $P2366, "ResizablePMCArray"
    push $P2366, $P2365
    .return ($P2366)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "value"  :subid("267_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2368_tgt
    .local int rx2368_pos
    .local int rx2368_off
    .local int rx2368_eos
    .local int rx2368_rep
    .local pmc rx2368_cur
    .local pmc rx2368_debug
    (rx2368_cur, rx2368_pos, rx2368_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2368_cur
    .local pmc match
    .lex "$/", match
    length rx2368_eos, rx2368_tgt
    gt rx2368_pos, rx2368_eos, rx2368_done
    set rx2368_off, 0
    lt rx2368_pos, 2, rx2368_start
    sub rx2368_off, rx2368_pos, 1
    substr rx2368_tgt, rx2368_tgt, rx2368_off
  rx2368_start:
    eq $I10, 1, rx2368_restart
    if_null rx2368_debug, debug_1374
    rx2368_cur."!cursor_debug"("START", "value")
  debug_1374:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2369_done
    goto rxscan2369_scan
  rxscan2369_loop:
    (rx2368_pos) = rx2368_cur."from"()
    inc rx2368_pos
    rx2368_cur."!cursor_from"(rx2368_pos)
    ge rx2368_pos, rx2368_eos, rxscan2369_done
  rxscan2369_scan:
    set_addr $I10, rxscan2369_loop
    rx2368_cur."!mark_push"(0, rx2368_pos, $I10)
  rxscan2369_done:
  alt2370_0:
.annotate 'line', 1002
    set_addr $I10, alt2370_1
    rx2368_cur."!mark_push"(0, rx2368_pos, $I10)
.annotate 'line', 1003
  # rx subrule "quote" subtype=capture negate=
    rx2368_cur."!cursor_pos"(rx2368_pos)
    $P10 = rx2368_cur."quote"()
    unless $P10, rx2368_fail
    rx2368_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx2368_pos = $P10."pos"()
    goto alt2370_end
  alt2370_1:
.annotate 'line', 1004
  # rx subrule "number" subtype=capture negate=
    rx2368_cur."!cursor_pos"(rx2368_pos)
    $P10 = rx2368_cur."number"()
    unless $P10, rx2368_fail
    rx2368_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("number")
    rx2368_pos = $P10."pos"()
  alt2370_end:
.annotate 'line', 1002
  # rx pass
    rx2368_cur."!cursor_pass"(rx2368_pos, "value")
    if_null rx2368_debug, debug_1375
    rx2368_cur."!cursor_debug"("PASS", "value", " at pos=", rx2368_pos)
  debug_1375:
    .return (rx2368_cur)
  rx2368_restart:
.annotate 'line', 436
    if_null rx2368_debug, debug_1376
    rx2368_cur."!cursor_debug"("NEXT", "value")
  debug_1376:
  rx2368_fail:
    (rx2368_rep, rx2368_pos, $I10, $P10) = rx2368_cur."!mark_fail"(0)
    lt rx2368_pos, -1, rx2368_done
    eq rx2368_pos, -1, rx2368_fail
    jump $I10
  rx2368_done:
    rx2368_cur."!cursor_fail"()
    if_null rx2368_debug, debug_1377
    rx2368_cur."!cursor_debug"("FAIL", "value")
  debug_1377:
    .return (rx2368_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__value"  :subid("268_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2372 = self."!PREFIX__!subrule"("number", "")
    $P2373 = self."!PREFIX__!subrule"("quote", "")
    new $P2374, "ResizablePMCArray"
    push $P2374, $P2372
    push $P2374, $P2373
    .return ($P2374)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "number"  :subid("269_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2376_tgt
    .local int rx2376_pos
    .local int rx2376_off
    .local int rx2376_eos
    .local int rx2376_rep
    .local pmc rx2376_cur
    .local pmc rx2376_debug
    (rx2376_cur, rx2376_pos, rx2376_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2376_cur
    .local pmc match
    .lex "$/", match
    length rx2376_eos, rx2376_tgt
    gt rx2376_pos, rx2376_eos, rx2376_done
    set rx2376_off, 0
    lt rx2376_pos, 2, rx2376_start
    sub rx2376_off, rx2376_pos, 1
    substr rx2376_tgt, rx2376_tgt, rx2376_off
  rx2376_start:
    eq $I10, 1, rx2376_restart
    if_null rx2376_debug, debug_1378
    rx2376_cur."!cursor_debug"("START", "number")
  debug_1378:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2377_done
    goto rxscan2377_scan
  rxscan2377_loop:
    (rx2376_pos) = rx2376_cur."from"()
    inc rx2376_pos
    rx2376_cur."!cursor_from"(rx2376_pos)
    ge rx2376_pos, rx2376_eos, rxscan2377_done
  rxscan2377_scan:
    set_addr $I10, rxscan2377_loop
    rx2376_cur."!mark_push"(0, rx2376_pos, $I10)
  rxscan2377_done:
.annotate 'line', 1008
  # rx subcapture "sign"
    set_addr $I10, rxcap_2379_fail
    rx2376_cur."!mark_push"(0, rx2376_pos, $I10)
  # rx enumcharlist_q negate=0  r 0..1
    sub $I10, rx2376_pos, rx2376_off
    set rx2376_rep, 0
    sub $I12, rx2376_eos, rx2376_pos
    le $I12, 1, rxenumcharlistq2378_loop
    set $I12, 1
  rxenumcharlistq2378_loop:
    le $I12, 0, rxenumcharlistq2378_done
    substr $S10, rx2376_tgt, $I10, 1
    index $I11, "+-", $S10
    lt $I11, 0, rxenumcharlistq2378_done
    inc rx2376_rep
  rxenumcharlistq2378_done:
    add rx2376_pos, rx2376_pos, rx2376_rep
    set_addr $I10, rxcap_2379_fail
    ($I12, $I11) = rx2376_cur."!mark_peek"($I10)
    rx2376_cur."!cursor_pos"($I11)
    ($P10) = rx2376_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2376_pos, "")
    rx2376_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sign")
    goto rxcap_2379_done
  rxcap_2379_fail:
    goto rx2376_fail
  rxcap_2379_done:
  alt2380_0:
.annotate 'line', 1009
    set_addr $I10, alt2380_1
    rx2376_cur."!mark_push"(0, rx2376_pos, $I10)
  # rx subrule "dec_number" subtype=capture negate=
    rx2376_cur."!cursor_pos"(rx2376_pos)
    $P10 = rx2376_cur."dec_number"()
    unless $P10, rx2376_fail
    rx2376_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dec_number")
    rx2376_pos = $P10."pos"()
    goto alt2380_end
  alt2380_1:
  # rx subrule "integer" subtype=capture negate=
    rx2376_cur."!cursor_pos"(rx2376_pos)
    $P10 = rx2376_cur."integer"()
    unless $P10, rx2376_fail
    rx2376_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("integer")
    rx2376_pos = $P10."pos"()
  alt2380_end:
.annotate 'line', 1007
  # rx pass
    rx2376_cur."!cursor_pass"(rx2376_pos, "number")
    if_null rx2376_debug, debug_1379
    rx2376_cur."!cursor_debug"("PASS", "number", " at pos=", rx2376_pos)
  debug_1379:
    .return (rx2376_cur)
  rx2376_restart:
.annotate 'line', 436
    if_null rx2376_debug, debug_1380
    rx2376_cur."!cursor_debug"("NEXT", "number")
  debug_1380:
  rx2376_fail:
    (rx2376_rep, rx2376_pos, $I10, $P10) = rx2376_cur."!mark_fail"(0)
    lt rx2376_pos, -1, rx2376_done
    eq rx2376_pos, -1, rx2376_fail
    jump $I10
  rx2376_done:
    rx2376_cur."!cursor_fail"()
    if_null rx2376_debug, debug_1381
    rx2376_cur."!cursor_debug"("FAIL", "number")
  debug_1381:
    .return (rx2376_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__number"  :subid("270_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    new $P2382, "ResizablePMCArray"
    push $P2382, ""
    .return ($P2382)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote"  :subid("271_1307873304.82979")
    .param pmc param_2384
.annotate 'line', 1012
    .lex "self", param_2384
    $P2385 = param_2384."!protoregex"("quote")
    .return ($P2385)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote"  :subid("272_1307873304.82979")
    .param pmc param_2387
.annotate 'line', 1012
    .lex "self", param_2387
    $P2388 = param_2387."!PREFIX__!protoregex"("quote")
    .return ($P2388)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<apos>"  :subid("273_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2390_tgt
    .local int rx2390_pos
    .local int rx2390_off
    .local int rx2390_eos
    .local int rx2390_rep
    .local pmc rx2390_cur
    .local pmc rx2390_debug
    (rx2390_cur, rx2390_pos, rx2390_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2390_cur
    .local pmc match
    .lex "$/", match
    length rx2390_eos, rx2390_tgt
    gt rx2390_pos, rx2390_eos, rx2390_done
    set rx2390_off, 0
    lt rx2390_pos, 2, rx2390_start
    sub rx2390_off, rx2390_pos, 1
    substr rx2390_tgt, rx2390_tgt, rx2390_off
  rx2390_start:
    eq $I10, 1, rx2390_restart
    if_null rx2390_debug, debug_1382
    rx2390_cur."!cursor_debug"("START", "quote:sym<apos>")
  debug_1382:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2391_done
    goto rxscan2391_scan
  rxscan2391_loop:
    (rx2390_pos) = rx2390_cur."from"()
    inc rx2390_pos
    rx2390_cur."!cursor_from"(rx2390_pos)
    ge rx2390_pos, rx2390_eos, rxscan2391_done
  rxscan2391_scan:
    set_addr $I10, rxscan2391_loop
    rx2390_cur."!mark_push"(0, rx2390_pos, $I10)
  rxscan2391_done:
.annotate 'line', 1013
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2390_pos, rx2390_off
    substr $S10, rx2390_tgt, $I10, 1
    index $I11, "'", $S10
    lt $I11, 0, rx2390_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx2390_cur."!cursor_pos"(rx2390_pos)
    $P10 = rx2390_cur."quote_EXPR"(":q")
    unless $P10, rx2390_fail
    rx2390_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx2390_pos = $P10."pos"()
  # rx pass
    rx2390_cur."!cursor_pass"(rx2390_pos, "quote:sym<apos>")
    if_null rx2390_debug, debug_1383
    rx2390_cur."!cursor_debug"("PASS", "quote:sym<apos>", " at pos=", rx2390_pos)
  debug_1383:
    .return (rx2390_cur)
  rx2390_restart:
.annotate 'line', 436
    if_null rx2390_debug, debug_1384
    rx2390_cur."!cursor_debug"("NEXT", "quote:sym<apos>")
  debug_1384:
  rx2390_fail:
    (rx2390_rep, rx2390_pos, $I10, $P10) = rx2390_cur."!mark_fail"(0)
    lt rx2390_pos, -1, rx2390_done
    eq rx2390_pos, -1, rx2390_fail
    jump $I10
  rx2390_done:
    rx2390_cur."!cursor_fail"()
    if_null rx2390_debug, debug_1385
    rx2390_cur."!cursor_debug"("FAIL", "quote:sym<apos>")
  debug_1385:
    .return (rx2390_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<apos>"  :subid("274_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    new $P2393, "ResizablePMCArray"
    push $P2393, "'"
    .return ($P2393)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<dblq>"  :subid("275_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2395_tgt
    .local int rx2395_pos
    .local int rx2395_off
    .local int rx2395_eos
    .local int rx2395_rep
    .local pmc rx2395_cur
    .local pmc rx2395_debug
    (rx2395_cur, rx2395_pos, rx2395_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2395_cur
    .local pmc match
    .lex "$/", match
    length rx2395_eos, rx2395_tgt
    gt rx2395_pos, rx2395_eos, rx2395_done
    set rx2395_off, 0
    lt rx2395_pos, 2, rx2395_start
    sub rx2395_off, rx2395_pos, 1
    substr rx2395_tgt, rx2395_tgt, rx2395_off
  rx2395_start:
    eq $I10, 1, rx2395_restart
    if_null rx2395_debug, debug_1386
    rx2395_cur."!cursor_debug"("START", "quote:sym<dblq>")
  debug_1386:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2396_done
    goto rxscan2396_scan
  rxscan2396_loop:
    (rx2395_pos) = rx2395_cur."from"()
    inc rx2395_pos
    rx2395_cur."!cursor_from"(rx2395_pos)
    ge rx2395_pos, rx2395_eos, rxscan2396_done
  rxscan2396_scan:
    set_addr $I10, rxscan2396_loop
    rx2395_cur."!mark_push"(0, rx2395_pos, $I10)
  rxscan2396_done:
.annotate 'line', 1014
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2395_pos, rx2395_off
    substr $S10, rx2395_tgt, $I10, 1
    index $I11, "\"", $S10
    lt $I11, 0, rx2395_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx2395_cur."!cursor_pos"(rx2395_pos)
    $P10 = rx2395_cur."quote_EXPR"(":qq")
    unless $P10, rx2395_fail
    rx2395_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx2395_pos = $P10."pos"()
  # rx pass
    rx2395_cur."!cursor_pass"(rx2395_pos, "quote:sym<dblq>")
    if_null rx2395_debug, debug_1387
    rx2395_cur."!cursor_debug"("PASS", "quote:sym<dblq>", " at pos=", rx2395_pos)
  debug_1387:
    .return (rx2395_cur)
  rx2395_restart:
.annotate 'line', 436
    if_null rx2395_debug, debug_1388
    rx2395_cur."!cursor_debug"("NEXT", "quote:sym<dblq>")
  debug_1388:
  rx2395_fail:
    (rx2395_rep, rx2395_pos, $I10, $P10) = rx2395_cur."!mark_fail"(0)
    lt rx2395_pos, -1, rx2395_done
    eq rx2395_pos, -1, rx2395_fail
    jump $I10
  rx2395_done:
    rx2395_cur."!cursor_fail"()
    if_null rx2395_debug, debug_1389
    rx2395_cur."!cursor_debug"("FAIL", "quote:sym<dblq>")
  debug_1389:
    .return (rx2395_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<dblq>"  :subid("276_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    new $P2398, "ResizablePMCArray"
    push $P2398, "\""
    .return ($P2398)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<q>"  :subid("277_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2400_tgt
    .local int rx2400_pos
    .local int rx2400_off
    .local int rx2400_eos
    .local int rx2400_rep
    .local pmc rx2400_cur
    .local pmc rx2400_debug
    (rx2400_cur, rx2400_pos, rx2400_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2400_cur
    .local pmc match
    .lex "$/", match
    length rx2400_eos, rx2400_tgt
    gt rx2400_pos, rx2400_eos, rx2400_done
    set rx2400_off, 0
    lt rx2400_pos, 2, rx2400_start
    sub rx2400_off, rx2400_pos, 1
    substr rx2400_tgt, rx2400_tgt, rx2400_off
  rx2400_start:
    eq $I10, 1, rx2400_restart
    if_null rx2400_debug, debug_1390
    rx2400_cur."!cursor_debug"("START", "quote:sym<q>")
  debug_1390:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2401_done
    goto rxscan2401_scan
  rxscan2401_loop:
    (rx2400_pos) = rx2400_cur."from"()
    inc rx2400_pos
    rx2400_cur."!cursor_from"(rx2400_pos)
    ge rx2400_pos, rx2400_eos, rxscan2401_done
  rxscan2401_scan:
    set_addr $I10, rxscan2401_loop
    rx2400_cur."!mark_push"(0, rx2400_pos, $I10)
  rxscan2401_done:
.annotate 'line', 1015
  # rx subcapture "sym"
    set_addr $I10, rxcap_2402_fail
    rx2400_cur."!mark_push"(0, rx2400_pos, $I10)
  # rx literal  "q"
    add $I11, rx2400_pos, 1
    gt $I11, rx2400_eos, rx2400_fail
    sub $I11, rx2400_pos, rx2400_off
    ord $I11, rx2400_tgt, $I11
    ne $I11, 113, rx2400_fail
    add rx2400_pos, 1
    set_addr $I10, rxcap_2402_fail
    ($I12, $I11) = rx2400_cur."!mark_peek"($I10)
    rx2400_cur."!cursor_pos"($I11)
    ($P10) = rx2400_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2400_pos, "")
    rx2400_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2402_done
  rxcap_2402_fail:
    goto rx2400_fail
  rxcap_2402_done:
  # rxanchor rwb
    le rx2400_pos, 0, rx2400_fail
    sub $I10, rx2400_pos, rx2400_off
    is_cclass $I11, .CCLASS_WORD, rx2400_tgt, $I10
    if $I11, rx2400_fail
    dec $I10
    is_cclass $I11, .CCLASS_WORD, rx2400_tgt, $I10
    unless $I11, rx2400_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx2400_pos, rx2400_off
    substr $S10, rx2400_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx2400_fail
  # rx subrule "ws" subtype=method negate=
    rx2400_cur."!cursor_pos"(rx2400_pos)
    $P10 = rx2400_cur."ws"()
    unless $P10, rx2400_fail
    rx2400_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx2400_cur."!cursor_pos"(rx2400_pos)
    $P10 = rx2400_cur."quote_EXPR"(":q")
    unless $P10, rx2400_fail
    rx2400_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx2400_pos = $P10."pos"()
  # rx pass
    rx2400_cur."!cursor_pass"(rx2400_pos, "quote:sym<q>")
    if_null rx2400_debug, debug_1391
    rx2400_cur."!cursor_debug"("PASS", "quote:sym<q>", " at pos=", rx2400_pos)
  debug_1391:
    .return (rx2400_cur)
  rx2400_restart:
.annotate 'line', 436
    if_null rx2400_debug, debug_1392
    rx2400_cur."!cursor_debug"("NEXT", "quote:sym<q>")
  debug_1392:
  rx2400_fail:
    (rx2400_rep, rx2400_pos, $I10, $P10) = rx2400_cur."!mark_fail"(0)
    lt rx2400_pos, -1, rx2400_done
    eq rx2400_pos, -1, rx2400_fail
    jump $I10
  rx2400_done:
    rx2400_cur."!cursor_fail"()
    if_null rx2400_debug, debug_1393
    rx2400_cur."!cursor_debug"("FAIL", "quote:sym<q>")
  debug_1393:
    .return (rx2400_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<q>"  :subid("278_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2404 = self."!PREFIX__!subrule"("ws", "q")
    new $P2405, "ResizablePMCArray"
    push $P2405, $P2404
    .return ($P2405)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<qq>"  :subid("279_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2407_tgt
    .local int rx2407_pos
    .local int rx2407_off
    .local int rx2407_eos
    .local int rx2407_rep
    .local pmc rx2407_cur
    .local pmc rx2407_debug
    (rx2407_cur, rx2407_pos, rx2407_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2407_cur
    .local pmc match
    .lex "$/", match
    length rx2407_eos, rx2407_tgt
    gt rx2407_pos, rx2407_eos, rx2407_done
    set rx2407_off, 0
    lt rx2407_pos, 2, rx2407_start
    sub rx2407_off, rx2407_pos, 1
    substr rx2407_tgt, rx2407_tgt, rx2407_off
  rx2407_start:
    eq $I10, 1, rx2407_restart
    if_null rx2407_debug, debug_1394
    rx2407_cur."!cursor_debug"("START", "quote:sym<qq>")
  debug_1394:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2408_done
    goto rxscan2408_scan
  rxscan2408_loop:
    (rx2407_pos) = rx2407_cur."from"()
    inc rx2407_pos
    rx2407_cur."!cursor_from"(rx2407_pos)
    ge rx2407_pos, rx2407_eos, rxscan2408_done
  rxscan2408_scan:
    set_addr $I10, rxscan2408_loop
    rx2407_cur."!mark_push"(0, rx2407_pos, $I10)
  rxscan2408_done:
.annotate 'line', 1016
  # rx subcapture "sym"
    set_addr $I10, rxcap_2409_fail
    rx2407_cur."!mark_push"(0, rx2407_pos, $I10)
  # rx literal  "qq"
    add $I11, rx2407_pos, 2
    gt $I11, rx2407_eos, rx2407_fail
    sub $I11, rx2407_pos, rx2407_off
    substr $S10, rx2407_tgt, $I11, 2
    ne $S10, "qq", rx2407_fail
    add rx2407_pos, 2
    set_addr $I10, rxcap_2409_fail
    ($I12, $I11) = rx2407_cur."!mark_peek"($I10)
    rx2407_cur."!cursor_pos"($I11)
    ($P10) = rx2407_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2407_pos, "")
    rx2407_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2409_done
  rxcap_2409_fail:
    goto rx2407_fail
  rxcap_2409_done:
  # rxanchor rwb
    le rx2407_pos, 0, rx2407_fail
    sub $I10, rx2407_pos, rx2407_off
    is_cclass $I11, .CCLASS_WORD, rx2407_tgt, $I10
    if $I11, rx2407_fail
    dec $I10
    is_cclass $I11, .CCLASS_WORD, rx2407_tgt, $I10
    unless $I11, rx2407_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx2407_pos, rx2407_off
    substr $S10, rx2407_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx2407_fail
  # rx subrule "ws" subtype=method negate=
    rx2407_cur."!cursor_pos"(rx2407_pos)
    $P10 = rx2407_cur."ws"()
    unless $P10, rx2407_fail
    rx2407_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx2407_cur."!cursor_pos"(rx2407_pos)
    $P10 = rx2407_cur."quote_EXPR"(":qq")
    unless $P10, rx2407_fail
    rx2407_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx2407_pos = $P10."pos"()
  # rx pass
    rx2407_cur."!cursor_pass"(rx2407_pos, "quote:sym<qq>")
    if_null rx2407_debug, debug_1395
    rx2407_cur."!cursor_debug"("PASS", "quote:sym<qq>", " at pos=", rx2407_pos)
  debug_1395:
    .return (rx2407_cur)
  rx2407_restart:
.annotate 'line', 436
    if_null rx2407_debug, debug_1396
    rx2407_cur."!cursor_debug"("NEXT", "quote:sym<qq>")
  debug_1396:
  rx2407_fail:
    (rx2407_rep, rx2407_pos, $I10, $P10) = rx2407_cur."!mark_fail"(0)
    lt rx2407_pos, -1, rx2407_done
    eq rx2407_pos, -1, rx2407_fail
    jump $I10
  rx2407_done:
    rx2407_cur."!cursor_fail"()
    if_null rx2407_debug, debug_1397
    rx2407_cur."!cursor_debug"("FAIL", "quote:sym<qq>")
  debug_1397:
    .return (rx2407_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<qq>"  :subid("280_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2411 = self."!PREFIX__!subrule"("ws", "qq")
    new $P2412, "ResizablePMCArray"
    push $P2412, $P2411
    .return ($P2412)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q>"  :subid("281_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2414_tgt
    .local int rx2414_pos
    .local int rx2414_off
    .local int rx2414_eos
    .local int rx2414_rep
    .local pmc rx2414_cur
    .local pmc rx2414_debug
    (rx2414_cur, rx2414_pos, rx2414_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2414_cur
    .local pmc match
    .lex "$/", match
    length rx2414_eos, rx2414_tgt
    gt rx2414_pos, rx2414_eos, rx2414_done
    set rx2414_off, 0
    lt rx2414_pos, 2, rx2414_start
    sub rx2414_off, rx2414_pos, 1
    substr rx2414_tgt, rx2414_tgt, rx2414_off
  rx2414_start:
    eq $I10, 1, rx2414_restart
    if_null rx2414_debug, debug_1398
    rx2414_cur."!cursor_debug"("START", "quote:sym<Q>")
  debug_1398:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2415_done
    goto rxscan2415_scan
  rxscan2415_loop:
    (rx2414_pos) = rx2414_cur."from"()
    inc rx2414_pos
    rx2414_cur."!cursor_from"(rx2414_pos)
    ge rx2414_pos, rx2414_eos, rxscan2415_done
  rxscan2415_scan:
    set_addr $I10, rxscan2415_loop
    rx2414_cur."!mark_push"(0, rx2414_pos, $I10)
  rxscan2415_done:
.annotate 'line', 1017
  # rx subcapture "sym"
    set_addr $I10, rxcap_2416_fail
    rx2414_cur."!mark_push"(0, rx2414_pos, $I10)
  # rx literal  "Q"
    add $I11, rx2414_pos, 1
    gt $I11, rx2414_eos, rx2414_fail
    sub $I11, rx2414_pos, rx2414_off
    ord $I11, rx2414_tgt, $I11
    ne $I11, 81, rx2414_fail
    add rx2414_pos, 1
    set_addr $I10, rxcap_2416_fail
    ($I12, $I11) = rx2414_cur."!mark_peek"($I10)
    rx2414_cur."!cursor_pos"($I11)
    ($P10) = rx2414_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2414_pos, "")
    rx2414_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2416_done
  rxcap_2416_fail:
    goto rx2414_fail
  rxcap_2416_done:
  # rxanchor rwb
    le rx2414_pos, 0, rx2414_fail
    sub $I10, rx2414_pos, rx2414_off
    is_cclass $I11, .CCLASS_WORD, rx2414_tgt, $I10
    if $I11, rx2414_fail
    dec $I10
    is_cclass $I11, .CCLASS_WORD, rx2414_tgt, $I10
    unless $I11, rx2414_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx2414_pos, rx2414_off
    substr $S10, rx2414_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx2414_fail
  # rx subrule "ws" subtype=method negate=
    rx2414_cur."!cursor_pos"(rx2414_pos)
    $P10 = rx2414_cur."ws"()
    unless $P10, rx2414_fail
    rx2414_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx2414_cur."!cursor_pos"(rx2414_pos)
    $P10 = rx2414_cur."quote_EXPR"()
    unless $P10, rx2414_fail
    rx2414_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx2414_pos = $P10."pos"()
  # rx pass
    rx2414_cur."!cursor_pass"(rx2414_pos, "quote:sym<Q>")
    if_null rx2414_debug, debug_1399
    rx2414_cur."!cursor_debug"("PASS", "quote:sym<Q>", " at pos=", rx2414_pos)
  debug_1399:
    .return (rx2414_cur)
  rx2414_restart:
.annotate 'line', 436
    if_null rx2414_debug, debug_1400
    rx2414_cur."!cursor_debug"("NEXT", "quote:sym<Q>")
  debug_1400:
  rx2414_fail:
    (rx2414_rep, rx2414_pos, $I10, $P10) = rx2414_cur."!mark_fail"(0)
    lt rx2414_pos, -1, rx2414_done
    eq rx2414_pos, -1, rx2414_fail
    jump $I10
  rx2414_done:
    rx2414_cur."!cursor_fail"()
    if_null rx2414_debug, debug_1401
    rx2414_cur."!cursor_debug"("FAIL", "quote:sym<Q>")
  debug_1401:
    .return (rx2414_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q>"  :subid("282_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2418 = self."!PREFIX__!subrule"("ws", "Q")
    new $P2419, "ResizablePMCArray"
    push $P2419, $P2418
    .return ($P2419)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q:PIR>"  :subid("283_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2421_tgt
    .local int rx2421_pos
    .local int rx2421_off
    .local int rx2421_eos
    .local int rx2421_rep
    .local pmc rx2421_cur
    .local pmc rx2421_debug
    (rx2421_cur, rx2421_pos, rx2421_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2421_cur
    .local pmc match
    .lex "$/", match
    length rx2421_eos, rx2421_tgt
    gt rx2421_pos, rx2421_eos, rx2421_done
    set rx2421_off, 0
    lt rx2421_pos, 2, rx2421_start
    sub rx2421_off, rx2421_pos, 1
    substr rx2421_tgt, rx2421_tgt, rx2421_off
  rx2421_start:
    eq $I10, 1, rx2421_restart
    if_null rx2421_debug, debug_1402
    rx2421_cur."!cursor_debug"("START", "quote:sym<Q:PIR>")
  debug_1402:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2422_done
    goto rxscan2422_scan
  rxscan2422_loop:
    (rx2421_pos) = rx2421_cur."from"()
    inc rx2421_pos
    rx2421_cur."!cursor_from"(rx2421_pos)
    ge rx2421_pos, rx2421_eos, rxscan2422_done
  rxscan2422_scan:
    set_addr $I10, rxscan2422_loop
    rx2421_cur."!mark_push"(0, rx2421_pos, $I10)
  rxscan2422_done:
.annotate 'line', 1018
  # rx subcapture "sym"
    set_addr $I10, rxcap_2423_fail
    rx2421_cur."!mark_push"(0, rx2421_pos, $I10)
  # rx literal  "Q:PIR"
    add $I11, rx2421_pos, 5
    gt $I11, rx2421_eos, rx2421_fail
    sub $I11, rx2421_pos, rx2421_off
    substr $S10, rx2421_tgt, $I11, 5
    ne $S10, "Q:PIR", rx2421_fail
    add rx2421_pos, 5
    set_addr $I10, rxcap_2423_fail
    ($I12, $I11) = rx2421_cur."!mark_peek"($I10)
    rx2421_cur."!cursor_pos"($I11)
    ($P10) = rx2421_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2421_pos, "")
    rx2421_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2423_done
  rxcap_2423_fail:
    goto rx2421_fail
  rxcap_2423_done:
  # rx subrule "ws" subtype=method negate=
    rx2421_cur."!cursor_pos"(rx2421_pos)
    $P10 = rx2421_cur."ws"()
    unless $P10, rx2421_fail
    rx2421_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx2421_cur."!cursor_pos"(rx2421_pos)
    $P10 = rx2421_cur."quote_EXPR"()
    unless $P10, rx2421_fail
    rx2421_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx2421_pos = $P10."pos"()
  # rx pass
    rx2421_cur."!cursor_pass"(rx2421_pos, "quote:sym<Q:PIR>")
    if_null rx2421_debug, debug_1403
    rx2421_cur."!cursor_debug"("PASS", "quote:sym<Q:PIR>", " at pos=", rx2421_pos)
  debug_1403:
    .return (rx2421_cur)
  rx2421_restart:
.annotate 'line', 436
    if_null rx2421_debug, debug_1404
    rx2421_cur."!cursor_debug"("NEXT", "quote:sym<Q:PIR>")
  debug_1404:
  rx2421_fail:
    (rx2421_rep, rx2421_pos, $I10, $P10) = rx2421_cur."!mark_fail"(0)
    lt rx2421_pos, -1, rx2421_done
    eq rx2421_pos, -1, rx2421_fail
    jump $I10
  rx2421_done:
    rx2421_cur."!cursor_fail"()
    if_null rx2421_debug, debug_1405
    rx2421_cur."!cursor_debug"("FAIL", "quote:sym<Q:PIR>")
  debug_1405:
    .return (rx2421_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q:PIR>"  :subid("284_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2425 = self."!PREFIX__!subrule"("ws", "Q:PIR")
    new $P2426, "ResizablePMCArray"
    push $P2426, $P2425
    .return ($P2426)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym</ />"  :subid("285_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2428_tgt
    .local int rx2428_pos
    .local int rx2428_off
    .local int rx2428_eos
    .local int rx2428_rep
    .local pmc rx2428_cur
    .local pmc rx2428_debug
    (rx2428_cur, rx2428_pos, rx2428_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2428_cur
    .local pmc match
    .lex "$/", match
    length rx2428_eos, rx2428_tgt
    gt rx2428_pos, rx2428_eos, rx2428_done
    set rx2428_off, 0
    lt rx2428_pos, 2, rx2428_start
    sub rx2428_off, rx2428_pos, 1
    substr rx2428_tgt, rx2428_tgt, rx2428_off
  rx2428_start:
    eq $I10, 1, rx2428_restart
    if_null rx2428_debug, debug_1406
    rx2428_cur."!cursor_debug"("START", "quote:sym</ />")
  debug_1406:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2429_done
    goto rxscan2429_scan
  rxscan2429_loop:
    (rx2428_pos) = rx2428_cur."from"()
    inc rx2428_pos
    rx2428_cur."!cursor_from"(rx2428_pos)
    ge rx2428_pos, rx2428_eos, rxscan2429_done
  rxscan2429_scan:
    set_addr $I10, rxscan2429_loop
    rx2428_cur."!mark_push"(0, rx2428_pos, $I10)
  rxscan2429_done:
.annotate 'line', 1020
  # rx literal  "/"
    add $I11, rx2428_pos, 1
    gt $I11, rx2428_eos, rx2428_fail
    sub $I11, rx2428_pos, rx2428_off
    ord $I11, rx2428_tgt, $I11
    ne $I11, 47, rx2428_fail
    add rx2428_pos, 1
.annotate 'line', 1021
  # rx subrule "newpad" subtype=method negate=
    rx2428_cur."!cursor_pos"(rx2428_pos)
    $P10 = rx2428_cur."newpad"()
    unless $P10, rx2428_fail
    rx2428_pos = $P10."pos"()
.annotate 'line', 1022
  # rx reduce name="quote:sym</ />" key="open"
    rx2428_cur."!cursor_pos"(rx2428_pos)
    rx2428_cur."!reduce"("quote:sym</ />", "open")
.annotate 'line', 1023
  # rx subrule "LANG" subtype=capture negate=
    rx2428_cur."!cursor_pos"(rx2428_pos)
    $P10 = rx2428_cur."LANG"("Regex", "nibbler")
    unless $P10, rx2428_fail
    rx2428_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx2428_pos = $P10."pos"()
.annotate 'line', 1024
  # rx literal  "/"
    add $I11, rx2428_pos, 1
    gt $I11, rx2428_eos, rx2428_fail
    sub $I11, rx2428_pos, rx2428_off
    ord $I11, rx2428_tgt, $I11
    ne $I11, 47, rx2428_fail
    add rx2428_pos, 1
.annotate 'line', 1019
  # rx pass
    rx2428_cur."!cursor_pass"(rx2428_pos, "quote:sym</ />")
    if_null rx2428_debug, debug_1407
    rx2428_cur."!cursor_debug"("PASS", "quote:sym</ />", " at pos=", rx2428_pos)
  debug_1407:
    .return (rx2428_cur)
  rx2428_restart:
.annotate 'line', 436
    if_null rx2428_debug, debug_1408
    rx2428_cur."!cursor_debug"("NEXT", "quote:sym</ />")
  debug_1408:
  rx2428_fail:
    (rx2428_rep, rx2428_pos, $I10, $P10) = rx2428_cur."!mark_fail"(0)
    lt rx2428_pos, -1, rx2428_done
    eq rx2428_pos, -1, rx2428_fail
    jump $I10
  rx2428_done:
    rx2428_cur."!cursor_fail"()
    if_null rx2428_debug, debug_1409
    rx2428_cur."!cursor_debug"("FAIL", "quote:sym</ />")
  debug_1409:
    .return (rx2428_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym</ />"  :subid("286_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2431 = self."!PREFIX__!subrule"("newpad", "/")
    new $P2432, "ResizablePMCArray"
    push $P2432, $P2431
    .return ($P2432)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<$>"  :subid("287_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2434_tgt
    .local int rx2434_pos
    .local int rx2434_off
    .local int rx2434_eos
    .local int rx2434_rep
    .local pmc rx2434_cur
    .local pmc rx2434_debug
    (rx2434_cur, rx2434_pos, rx2434_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2434_cur
    .local pmc match
    .lex "$/", match
    length rx2434_eos, rx2434_tgt
    gt rx2434_pos, rx2434_eos, rx2434_done
    set rx2434_off, 0
    lt rx2434_pos, 2, rx2434_start
    sub rx2434_off, rx2434_pos, 1
    substr rx2434_tgt, rx2434_tgt, rx2434_off
  rx2434_start:
    eq $I10, 1, rx2434_restart
    if_null rx2434_debug, debug_1410
    rx2434_cur."!cursor_debug"("START", "quote_escape:sym<$>")
  debug_1410:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2435_done
    goto rxscan2435_scan
  rxscan2435_loop:
    (rx2434_pos) = rx2434_cur."from"()
    inc rx2434_pos
    rx2434_cur."!cursor_from"(rx2434_pos)
    ge rx2434_pos, rx2434_eos, rxscan2435_done
  rxscan2435_scan:
    set_addr $I10, rxscan2435_loop
    rx2434_cur."!mark_push"(0, rx2434_pos, $I10)
  rxscan2435_done:
.annotate 'line', 1027
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2434_pos, rx2434_off
    substr $S10, rx2434_tgt, $I10, 1
    index $I11, "$", $S10
    lt $I11, 0, rx2434_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx2434_cur."!cursor_pos"(rx2434_pos)
    $P10 = rx2434_cur."quotemod_check"("s")
    unless $P10, rx2434_fail
  # rx subrule "variable" subtype=capture negate=
    rx2434_cur."!cursor_pos"(rx2434_pos)
    $P10 = rx2434_cur."variable"()
    unless $P10, rx2434_fail
    rx2434_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx2434_pos = $P10."pos"()
  # rx pass
    rx2434_cur."!cursor_pass"(rx2434_pos, "quote_escape:sym<$>")
    if_null rx2434_debug, debug_1411
    rx2434_cur."!cursor_debug"("PASS", "quote_escape:sym<$>", " at pos=", rx2434_pos)
  debug_1411:
    .return (rx2434_cur)
  rx2434_restart:
.annotate 'line', 436
    if_null rx2434_debug, debug_1412
    rx2434_cur."!cursor_debug"("NEXT", "quote_escape:sym<$>")
  debug_1412:
  rx2434_fail:
    (rx2434_rep, rx2434_pos, $I10, $P10) = rx2434_cur."!mark_fail"(0)
    lt rx2434_pos, -1, rx2434_done
    eq rx2434_pos, -1, rx2434_fail
    jump $I10
  rx2434_done:
    rx2434_cur."!cursor_fail"()
    if_null rx2434_debug, debug_1413
    rx2434_cur."!cursor_debug"("FAIL", "quote_escape:sym<$>")
  debug_1413:
    .return (rx2434_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<$>"  :subid("288_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    new $P2437, "ResizablePMCArray"
    push $P2437, "$"
    .return ($P2437)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<{ }>"  :subid("289_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2439_tgt
    .local int rx2439_pos
    .local int rx2439_off
    .local int rx2439_eos
    .local int rx2439_rep
    .local pmc rx2439_cur
    .local pmc rx2439_debug
    (rx2439_cur, rx2439_pos, rx2439_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2439_cur
    .local pmc match
    .lex "$/", match
    length rx2439_eos, rx2439_tgt
    gt rx2439_pos, rx2439_eos, rx2439_done
    set rx2439_off, 0
    lt rx2439_pos, 2, rx2439_start
    sub rx2439_off, rx2439_pos, 1
    substr rx2439_tgt, rx2439_tgt, rx2439_off
  rx2439_start:
    eq $I10, 1, rx2439_restart
    if_null rx2439_debug, debug_1414
    rx2439_cur."!cursor_debug"("START", "quote_escape:sym<{ }>")
  debug_1414:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2440_done
    goto rxscan2440_scan
  rxscan2440_loop:
    (rx2439_pos) = rx2439_cur."from"()
    inc rx2439_pos
    rx2439_cur."!cursor_from"(rx2439_pos)
    ge rx2439_pos, rx2439_eos, rxscan2440_done
  rxscan2440_scan:
    set_addr $I10, rxscan2440_loop
    rx2439_cur."!mark_push"(0, rx2439_pos, $I10)
  rxscan2440_done:
.annotate 'line', 1028
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2439_pos, rx2439_off
    substr $S10, rx2439_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2439_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx2439_cur."!cursor_pos"(rx2439_pos)
    $P10 = rx2439_cur."quotemod_check"("c")
    unless $P10, rx2439_fail
  # rx subrule "block" subtype=capture negate=
    rx2439_cur."!cursor_pos"(rx2439_pos)
    $P10 = rx2439_cur."block"()
    unless $P10, rx2439_fail
    rx2439_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx2439_pos = $P10."pos"()
  # rx pass
    rx2439_cur."!cursor_pass"(rx2439_pos, "quote_escape:sym<{ }>")
    if_null rx2439_debug, debug_1415
    rx2439_cur."!cursor_debug"("PASS", "quote_escape:sym<{ }>", " at pos=", rx2439_pos)
  debug_1415:
    .return (rx2439_cur)
  rx2439_restart:
.annotate 'line', 436
    if_null rx2439_debug, debug_1416
    rx2439_cur."!cursor_debug"("NEXT", "quote_escape:sym<{ }>")
  debug_1416:
  rx2439_fail:
    (rx2439_rep, rx2439_pos, $I10, $P10) = rx2439_cur."!mark_fail"(0)
    lt rx2439_pos, -1, rx2439_done
    eq rx2439_pos, -1, rx2439_fail
    jump $I10
  rx2439_done:
    rx2439_cur."!cursor_fail"()
    if_null rx2439_debug, debug_1417
    rx2439_cur."!cursor_debug"("FAIL", "quote_escape:sym<{ }>")
  debug_1417:
    .return (rx2439_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<{ }>"  :subid("290_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    new $P2442, "ResizablePMCArray"
    push $P2442, "{"
    .return ($P2442)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<esc>"  :subid("291_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2444_tgt
    .local int rx2444_pos
    .local int rx2444_off
    .local int rx2444_eos
    .local int rx2444_rep
    .local pmc rx2444_cur
    .local pmc rx2444_debug
    (rx2444_cur, rx2444_pos, rx2444_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2444_cur
    .local pmc match
    .lex "$/", match
    length rx2444_eos, rx2444_tgt
    gt rx2444_pos, rx2444_eos, rx2444_done
    set rx2444_off, 0
    lt rx2444_pos, 2, rx2444_start
    sub rx2444_off, rx2444_pos, 1
    substr rx2444_tgt, rx2444_tgt, rx2444_off
  rx2444_start:
    eq $I10, 1, rx2444_restart
    if_null rx2444_debug, debug_1418
    rx2444_cur."!cursor_debug"("START", "quote_escape:sym<esc>")
  debug_1418:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2445_done
    goto rxscan2445_scan
  rxscan2445_loop:
    (rx2444_pos) = rx2444_cur."from"()
    inc rx2444_pos
    rx2444_cur."!cursor_from"(rx2444_pos)
    ge rx2444_pos, rx2444_eos, rxscan2445_done
  rxscan2445_scan:
    set_addr $I10, rxscan2445_loop
    rx2444_cur."!mark_push"(0, rx2444_pos, $I10)
  rxscan2445_done:
.annotate 'line', 1029
  # rx literal  "\\e"
    add $I11, rx2444_pos, 2
    gt $I11, rx2444_eos, rx2444_fail
    sub $I11, rx2444_pos, rx2444_off
    substr $S10, rx2444_tgt, $I11, 2
    ne $S10, "\\e", rx2444_fail
    add rx2444_pos, 2
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx2444_cur."!cursor_pos"(rx2444_pos)
    $P10 = rx2444_cur."quotemod_check"("b")
    unless $P10, rx2444_fail
  # rx pass
    rx2444_cur."!cursor_pass"(rx2444_pos, "quote_escape:sym<esc>")
    if_null rx2444_debug, debug_1419
    rx2444_cur."!cursor_debug"("PASS", "quote_escape:sym<esc>", " at pos=", rx2444_pos)
  debug_1419:
    .return (rx2444_cur)
  rx2444_restart:
.annotate 'line', 436
    if_null rx2444_debug, debug_1420
    rx2444_cur."!cursor_debug"("NEXT", "quote_escape:sym<esc>")
  debug_1420:
  rx2444_fail:
    (rx2444_rep, rx2444_pos, $I10, $P10) = rx2444_cur."!mark_fail"(0)
    lt rx2444_pos, -1, rx2444_done
    eq rx2444_pos, -1, rx2444_fail
    jump $I10
  rx2444_done:
    rx2444_cur."!cursor_fail"()
    if_null rx2444_debug, debug_1421
    rx2444_cur."!cursor_debug"("FAIL", "quote_escape:sym<esc>")
  debug_1421:
    .return (rx2444_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<esc>"  :subid("292_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    new $P2447, "ResizablePMCArray"
    push $P2447, "\\e"
    .return ($P2447)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<( )>"  :subid("293_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2449_tgt
    .local int rx2449_pos
    .local int rx2449_off
    .local int rx2449_eos
    .local int rx2449_rep
    .local pmc rx2449_cur
    .local pmc rx2449_debug
    (rx2449_cur, rx2449_pos, rx2449_tgt, $I10) = self."!cursor_start"()
    rx2449_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx2449_cur
    .local pmc match
    .lex "$/", match
    length rx2449_eos, rx2449_tgt
    gt rx2449_pos, rx2449_eos, rx2449_done
    set rx2449_off, 0
    lt rx2449_pos, 2, rx2449_start
    sub rx2449_off, rx2449_pos, 1
    substr rx2449_tgt, rx2449_tgt, rx2449_off
  rx2449_start:
    eq $I10, 1, rx2449_restart
    if_null rx2449_debug, debug_1422
    rx2449_cur."!cursor_debug"("START", "circumfix:sym<( )>")
  debug_1422:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2450_done
    goto rxscan2450_scan
  rxscan2450_loop:
    (rx2449_pos) = rx2449_cur."from"()
    inc rx2449_pos
    rx2449_cur."!cursor_from"(rx2449_pos)
    ge rx2449_pos, rx2449_eos, rxscan2450_done
  rxscan2450_scan:
    set_addr $I10, rxscan2450_loop
    rx2449_cur."!mark_push"(0, rx2449_pos, $I10)
  rxscan2450_done:
.annotate 'line', 1031
  # rx literal  "("
    add $I11, rx2449_pos, 1
    gt $I11, rx2449_eos, rx2449_fail
    sub $I11, rx2449_pos, rx2449_off
    ord $I11, rx2449_tgt, $I11
    ne $I11, 40, rx2449_fail
    add rx2449_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2449_cur."!cursor_pos"(rx2449_pos)
    $P10 = rx2449_cur."ws"()
    unless $P10, rx2449_fail
    rx2449_pos = $P10."pos"()
  # rx rxquantr2451 ** 0..1
    set_addr $I10, rxquantr2451_done
    rx2449_cur."!mark_push"(0, rx2449_pos, $I10)
  rxquantr2451_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx2449_cur."!cursor_pos"(rx2449_pos)
    $P10 = rx2449_cur."EXPR"()
    unless $P10, rx2449_fail
    goto rxsubrule2452_pass
  rxsubrule2452_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx2449_fail
  rxsubrule2452_pass:
    set_addr $I10, rxsubrule2452_back
    rx2449_cur."!mark_push"(0, rx2449_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx2449_pos = $P10."pos"()
    set_addr $I10, rxquantr2451_done
    (rx2449_rep) = rx2449_cur."!mark_commit"($I10)
  rxquantr2451_done:
  # rx literal  ")"
    add $I11, rx2449_pos, 1
    gt $I11, rx2449_eos, rx2449_fail
    sub $I11, rx2449_pos, rx2449_off
    ord $I11, rx2449_tgt, $I11
    ne $I11, 41, rx2449_fail
    add rx2449_pos, 1
  # rx pass
    rx2449_cur."!cursor_pass"(rx2449_pos, "circumfix:sym<( )>")
    if_null rx2449_debug, debug_1423
    rx2449_cur."!cursor_debug"("PASS", "circumfix:sym<( )>", " at pos=", rx2449_pos)
  debug_1423:
    .return (rx2449_cur)
  rx2449_restart:
.annotate 'line', 436
    if_null rx2449_debug, debug_1424
    rx2449_cur."!cursor_debug"("NEXT", "circumfix:sym<( )>")
  debug_1424:
  rx2449_fail:
    (rx2449_rep, rx2449_pos, $I10, $P10) = rx2449_cur."!mark_fail"(0)
    lt rx2449_pos, -1, rx2449_done
    eq rx2449_pos, -1, rx2449_fail
    jump $I10
  rx2449_done:
    rx2449_cur."!cursor_fail"()
    if_null rx2449_debug, debug_1425
    rx2449_cur."!cursor_debug"("FAIL", "circumfix:sym<( )>")
  debug_1425:
    .return (rx2449_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<( )>"  :subid("294_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2454 = self."!PREFIX__!subrule"("ws", "(")
    new $P2455, "ResizablePMCArray"
    push $P2455, $P2454
    .return ($P2455)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<[ ]>"  :subid("295_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2457_tgt
    .local int rx2457_pos
    .local int rx2457_off
    .local int rx2457_eos
    .local int rx2457_rep
    .local pmc rx2457_cur
    .local pmc rx2457_debug
    (rx2457_cur, rx2457_pos, rx2457_tgt, $I10) = self."!cursor_start"()
    rx2457_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx2457_cur
    .local pmc match
    .lex "$/", match
    length rx2457_eos, rx2457_tgt
    gt rx2457_pos, rx2457_eos, rx2457_done
    set rx2457_off, 0
    lt rx2457_pos, 2, rx2457_start
    sub rx2457_off, rx2457_pos, 1
    substr rx2457_tgt, rx2457_tgt, rx2457_off
  rx2457_start:
    eq $I10, 1, rx2457_restart
    if_null rx2457_debug, debug_1426
    rx2457_cur."!cursor_debug"("START", "circumfix:sym<[ ]>")
  debug_1426:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2458_done
    goto rxscan2458_scan
  rxscan2458_loop:
    (rx2457_pos) = rx2457_cur."from"()
    inc rx2457_pos
    rx2457_cur."!cursor_from"(rx2457_pos)
    ge rx2457_pos, rx2457_eos, rxscan2458_done
  rxscan2458_scan:
    set_addr $I10, rxscan2458_loop
    rx2457_cur."!mark_push"(0, rx2457_pos, $I10)
  rxscan2458_done:
.annotate 'line', 1032
  # rx literal  "["
    add $I11, rx2457_pos, 1
    gt $I11, rx2457_eos, rx2457_fail
    sub $I11, rx2457_pos, rx2457_off
    ord $I11, rx2457_tgt, $I11
    ne $I11, 91, rx2457_fail
    add rx2457_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2457_cur."!cursor_pos"(rx2457_pos)
    $P10 = rx2457_cur."ws"()
    unless $P10, rx2457_fail
    rx2457_pos = $P10."pos"()
  # rx rxquantr2459 ** 0..1
    set_addr $I10, rxquantr2459_done
    rx2457_cur."!mark_push"(0, rx2457_pos, $I10)
  rxquantr2459_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx2457_cur."!cursor_pos"(rx2457_pos)
    $P10 = rx2457_cur."EXPR"()
    unless $P10, rx2457_fail
    goto rxsubrule2460_pass
  rxsubrule2460_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx2457_fail
  rxsubrule2460_pass:
    set_addr $I10, rxsubrule2460_back
    rx2457_cur."!mark_push"(0, rx2457_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx2457_pos = $P10."pos"()
    set_addr $I10, rxquantr2459_done
    (rx2457_rep) = rx2457_cur."!mark_commit"($I10)
  rxquantr2459_done:
  # rx literal  "]"
    add $I11, rx2457_pos, 1
    gt $I11, rx2457_eos, rx2457_fail
    sub $I11, rx2457_pos, rx2457_off
    ord $I11, rx2457_tgt, $I11
    ne $I11, 93, rx2457_fail
    add rx2457_pos, 1
  # rx pass
    rx2457_cur."!cursor_pass"(rx2457_pos, "circumfix:sym<[ ]>")
    if_null rx2457_debug, debug_1427
    rx2457_cur."!cursor_debug"("PASS", "circumfix:sym<[ ]>", " at pos=", rx2457_pos)
  debug_1427:
    .return (rx2457_cur)
  rx2457_restart:
.annotate 'line', 436
    if_null rx2457_debug, debug_1428
    rx2457_cur."!cursor_debug"("NEXT", "circumfix:sym<[ ]>")
  debug_1428:
  rx2457_fail:
    (rx2457_rep, rx2457_pos, $I10, $P10) = rx2457_cur."!mark_fail"(0)
    lt rx2457_pos, -1, rx2457_done
    eq rx2457_pos, -1, rx2457_fail
    jump $I10
  rx2457_done:
    rx2457_cur."!cursor_fail"()
    if_null rx2457_debug, debug_1429
    rx2457_cur."!cursor_debug"("FAIL", "circumfix:sym<[ ]>")
  debug_1429:
    .return (rx2457_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<[ ]>"  :subid("296_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2462 = self."!PREFIX__!subrule"("ws", "[")
    new $P2463, "ResizablePMCArray"
    push $P2463, $P2462
    .return ($P2463)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<ang>"  :subid("297_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2465_tgt
    .local int rx2465_pos
    .local int rx2465_off
    .local int rx2465_eos
    .local int rx2465_rep
    .local pmc rx2465_cur
    .local pmc rx2465_debug
    (rx2465_cur, rx2465_pos, rx2465_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2465_cur
    .local pmc match
    .lex "$/", match
    length rx2465_eos, rx2465_tgt
    gt rx2465_pos, rx2465_eos, rx2465_done
    set rx2465_off, 0
    lt rx2465_pos, 2, rx2465_start
    sub rx2465_off, rx2465_pos, 1
    substr rx2465_tgt, rx2465_tgt, rx2465_off
  rx2465_start:
    eq $I10, 1, rx2465_restart
    if_null rx2465_debug, debug_1430
    rx2465_cur."!cursor_debug"("START", "circumfix:sym<ang>")
  debug_1430:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2466_done
    goto rxscan2466_scan
  rxscan2466_loop:
    (rx2465_pos) = rx2465_cur."from"()
    inc rx2465_pos
    rx2465_cur."!cursor_from"(rx2465_pos)
    ge rx2465_pos, rx2465_eos, rxscan2466_done
  rxscan2466_scan:
    set_addr $I10, rxscan2466_loop
    rx2465_cur."!mark_push"(0, rx2465_pos, $I10)
  rxscan2466_done:
.annotate 'line', 1033
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2465_pos, rx2465_off
    substr $S10, rx2465_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx2465_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx2465_cur."!cursor_pos"(rx2465_pos)
    $P10 = rx2465_cur."quote_EXPR"(":q", ":w")
    unless $P10, rx2465_fail
    rx2465_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx2465_pos = $P10."pos"()
  # rx pass
    rx2465_cur."!cursor_pass"(rx2465_pos, "circumfix:sym<ang>")
    if_null rx2465_debug, debug_1431
    rx2465_cur."!cursor_debug"("PASS", "circumfix:sym<ang>", " at pos=", rx2465_pos)
  debug_1431:
    .return (rx2465_cur)
  rx2465_restart:
.annotate 'line', 436
    if_null rx2465_debug, debug_1432
    rx2465_cur."!cursor_debug"("NEXT", "circumfix:sym<ang>")
  debug_1432:
  rx2465_fail:
    (rx2465_rep, rx2465_pos, $I10, $P10) = rx2465_cur."!mark_fail"(0)
    lt rx2465_pos, -1, rx2465_done
    eq rx2465_pos, -1, rx2465_fail
    jump $I10
  rx2465_done:
    rx2465_cur."!cursor_fail"()
    if_null rx2465_debug, debug_1433
    rx2465_cur."!cursor_debug"("FAIL", "circumfix:sym<ang>")
  debug_1433:
    .return (rx2465_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<ang>"  :subid("298_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    new $P2468, "ResizablePMCArray"
    push $P2468, "<"
    .return ($P2468)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("299_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2470_tgt
    .local int rx2470_pos
    .local int rx2470_off
    .local int rx2470_eos
    .local int rx2470_rep
    .local pmc rx2470_cur
    .local pmc rx2470_debug
    (rx2470_cur, rx2470_pos, rx2470_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2470_cur
    .local pmc match
    .lex "$/", match
    length rx2470_eos, rx2470_tgt
    gt rx2470_pos, rx2470_eos, rx2470_done
    set rx2470_off, 0
    lt rx2470_pos, 2, rx2470_start
    sub rx2470_off, rx2470_pos, 1
    substr rx2470_tgt, rx2470_tgt, rx2470_off
  rx2470_start:
    eq $I10, 1, rx2470_restart
    if_null rx2470_debug, debug_1434
    rx2470_cur."!cursor_debug"("START", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1434:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2471_done
    goto rxscan2471_scan
  rxscan2471_loop:
    (rx2470_pos) = rx2470_cur."from"()
    inc rx2470_pos
    rx2470_cur."!cursor_from"(rx2470_pos)
    ge rx2470_pos, rx2470_eos, rxscan2471_done
  rxscan2471_scan:
    set_addr $I10, rxscan2471_loop
    rx2470_cur."!mark_push"(0, rx2470_pos, $I10)
  rxscan2471_done:
.annotate 'line', 1034
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2470_pos, rx2470_off
    substr $S10, rx2470_tgt, $I10, 1
    index $I11, unicode:"\x{ab}", $S10
    lt $I11, 0, rx2470_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx2470_cur."!cursor_pos"(rx2470_pos)
    $P10 = rx2470_cur."quote_EXPR"(":qq", ":w")
    unless $P10, rx2470_fail
    rx2470_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx2470_pos = $P10."pos"()
  # rx pass
    rx2470_cur."!cursor_pass"(rx2470_pos, unicode:"circumfix:sym<\x{ab} \x{bb}>")
    if_null rx2470_debug, debug_1435
    rx2470_cur."!cursor_debug"("PASS", unicode:"circumfix:sym<\x{ab} \x{bb}>", " at pos=", rx2470_pos)
  debug_1435:
    .return (rx2470_cur)
  rx2470_restart:
.annotate 'line', 436
    if_null rx2470_debug, debug_1436
    rx2470_cur."!cursor_debug"("NEXT", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1436:
  rx2470_fail:
    (rx2470_rep, rx2470_pos, $I10, $P10) = rx2470_cur."!mark_fail"(0)
    lt rx2470_pos, -1, rx2470_done
    eq rx2470_pos, -1, rx2470_fail
    jump $I10
  rx2470_done:
    rx2470_cur."!cursor_fail"()
    if_null rx2470_debug, debug_1437
    rx2470_cur."!cursor_debug"("FAIL", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1437:
    .return (rx2470_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"  :subid("300_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    new $P2473, "ResizablePMCArray"
    push $P2473, unicode:"\x{ab}"
    .return ($P2473)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<{ }>"  :subid("301_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2475_tgt
    .local int rx2475_pos
    .local int rx2475_off
    .local int rx2475_eos
    .local int rx2475_rep
    .local pmc rx2475_cur
    .local pmc rx2475_debug
    (rx2475_cur, rx2475_pos, rx2475_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2475_cur
    .local pmc match
    .lex "$/", match
    length rx2475_eos, rx2475_tgt
    gt rx2475_pos, rx2475_eos, rx2475_done
    set rx2475_off, 0
    lt rx2475_pos, 2, rx2475_start
    sub rx2475_off, rx2475_pos, 1
    substr rx2475_tgt, rx2475_tgt, rx2475_off
  rx2475_start:
    eq $I10, 1, rx2475_restart
    if_null rx2475_debug, debug_1438
    rx2475_cur."!cursor_debug"("START", "circumfix:sym<{ }>")
  debug_1438:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2476_done
    goto rxscan2476_scan
  rxscan2476_loop:
    (rx2475_pos) = rx2475_cur."from"()
    inc rx2475_pos
    rx2475_cur."!cursor_from"(rx2475_pos)
    ge rx2475_pos, rx2475_eos, rxscan2476_done
  rxscan2476_scan:
    set_addr $I10, rxscan2476_loop
    rx2475_cur."!mark_push"(0, rx2475_pos, $I10)
  rxscan2476_done:
.annotate 'line', 1035
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2475_pos, rx2475_off
    substr $S10, rx2475_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2475_fail
  # rx subrule "pblock" subtype=capture negate=
    rx2475_cur."!cursor_pos"(rx2475_pos)
    $P10 = rx2475_cur."pblock"()
    unless $P10, rx2475_fail
    rx2475_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx2475_pos = $P10."pos"()
  # rx pass
    rx2475_cur."!cursor_pass"(rx2475_pos, "circumfix:sym<{ }>")
    if_null rx2475_debug, debug_1439
    rx2475_cur."!cursor_debug"("PASS", "circumfix:sym<{ }>", " at pos=", rx2475_pos)
  debug_1439:
    .return (rx2475_cur)
  rx2475_restart:
.annotate 'line', 436
    if_null rx2475_debug, debug_1440
    rx2475_cur."!cursor_debug"("NEXT", "circumfix:sym<{ }>")
  debug_1440:
  rx2475_fail:
    (rx2475_rep, rx2475_pos, $I10, $P10) = rx2475_cur."!mark_fail"(0)
    lt rx2475_pos, -1, rx2475_done
    eq rx2475_pos, -1, rx2475_fail
    jump $I10
  rx2475_done:
    rx2475_cur."!cursor_fail"()
    if_null rx2475_debug, debug_1441
    rx2475_cur."!cursor_debug"("FAIL", "circumfix:sym<{ }>")
  debug_1441:
    .return (rx2475_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<{ }>"  :subid("302_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    new $P2478, "ResizablePMCArray"
    push $P2478, "{"
    .return ($P2478)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<sigil>"  :subid("303_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2480_tgt
    .local int rx2480_pos
    .local int rx2480_off
    .local int rx2480_eos
    .local int rx2480_rep
    .local pmc rx2480_cur
    .local pmc rx2480_debug
    (rx2480_cur, rx2480_pos, rx2480_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2480_cur
    .local pmc match
    .lex "$/", match
    length rx2480_eos, rx2480_tgt
    gt rx2480_pos, rx2480_eos, rx2480_done
    set rx2480_off, 0
    lt rx2480_pos, 2, rx2480_start
    sub rx2480_off, rx2480_pos, 1
    substr rx2480_tgt, rx2480_tgt, rx2480_off
  rx2480_start:
    eq $I10, 1, rx2480_restart
    if_null rx2480_debug, debug_1442
    rx2480_cur."!cursor_debug"("START", "circumfix:sym<sigil>")
  debug_1442:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2481_done
    goto rxscan2481_scan
  rxscan2481_loop:
    (rx2480_pos) = rx2480_cur."from"()
    inc rx2480_pos
    rx2480_cur."!cursor_from"(rx2480_pos)
    ge rx2480_pos, rx2480_eos, rxscan2481_done
  rxscan2481_scan:
    set_addr $I10, rxscan2481_loop
    rx2480_cur."!mark_push"(0, rx2480_pos, $I10)
  rxscan2481_done:
.annotate 'line', 1036
  # rx subrule "sigil" subtype=capture negate=
    rx2480_cur."!cursor_pos"(rx2480_pos)
    $P10 = rx2480_cur."sigil"()
    unless $P10, rx2480_fail
    rx2480_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx2480_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx2480_pos, 1
    gt $I11, rx2480_eos, rx2480_fail
    sub $I11, rx2480_pos, rx2480_off
    ord $I11, rx2480_tgt, $I11
    ne $I11, 40, rx2480_fail
    add rx2480_pos, 1
  # rx subrule "semilist" subtype=capture negate=
    rx2480_cur."!cursor_pos"(rx2480_pos)
    $P10 = rx2480_cur."semilist"()
    unless $P10, rx2480_fail
    rx2480_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("semilist")
    rx2480_pos = $P10."pos"()
  alt2482_0:
    set_addr $I10, alt2482_1
    rx2480_cur."!mark_push"(0, rx2480_pos, $I10)
  # rx literal  ")"
    add $I11, rx2480_pos, 1
    gt $I11, rx2480_eos, rx2480_fail
    sub $I11, rx2480_pos, rx2480_off
    ord $I11, rx2480_tgt, $I11
    ne $I11, 41, rx2480_fail
    add rx2480_pos, 1
    goto alt2482_end
  alt2482_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx2480_cur."!cursor_pos"(rx2480_pos)
    $P10 = rx2480_cur."FAILGOAL"("')'")
    unless $P10, rx2480_fail
    goto rxsubrule2484_pass
  rxsubrule2484_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx2480_fail
  rxsubrule2484_pass:
    set_addr $I10, rxsubrule2484_back
    rx2480_cur."!mark_push"(0, rx2480_pos, $I10, $P10)
    rx2480_pos = $P10."pos"()
  alt2482_end:
  # rx pass
    rx2480_cur."!cursor_pass"(rx2480_pos, "circumfix:sym<sigil>")
    if_null rx2480_debug, debug_1443
    rx2480_cur."!cursor_debug"("PASS", "circumfix:sym<sigil>", " at pos=", rx2480_pos)
  debug_1443:
    .return (rx2480_cur)
  rx2480_restart:
.annotate 'line', 436
    if_null rx2480_debug, debug_1444
    rx2480_cur."!cursor_debug"("NEXT", "circumfix:sym<sigil>")
  debug_1444:
  rx2480_fail:
    (rx2480_rep, rx2480_pos, $I10, $P10) = rx2480_cur."!mark_fail"(0)
    lt rx2480_pos, -1, rx2480_done
    eq rx2480_pos, -1, rx2480_fail
    jump $I10
  rx2480_done:
    rx2480_cur."!cursor_fail"()
    if_null rx2480_debug, debug_1445
    rx2480_cur."!cursor_debug"("FAIL", "circumfix:sym<sigil>")
  debug_1445:
    .return (rx2480_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<sigil>"  :subid("304_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2486 = self."!PREFIX__!subrule"("sigil", "")
    new $P2487, "ResizablePMCArray"
    push $P2487, $P2486
    .return ($P2487)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "semilist"  :subid("305_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2489_tgt
    .local int rx2489_pos
    .local int rx2489_off
    .local int rx2489_eos
    .local int rx2489_rep
    .local pmc rx2489_cur
    .local pmc rx2489_debug
    (rx2489_cur, rx2489_pos, rx2489_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2489_cur
    .local pmc match
    .lex "$/", match
    length rx2489_eos, rx2489_tgt
    gt rx2489_pos, rx2489_eos, rx2489_done
    set rx2489_off, 0
    lt rx2489_pos, 2, rx2489_start
    sub rx2489_off, rx2489_pos, 1
    substr rx2489_tgt, rx2489_tgt, rx2489_off
  rx2489_start:
    eq $I10, 1, rx2489_restart
    if_null rx2489_debug, debug_1446
    rx2489_cur."!cursor_debug"("START", "semilist")
  debug_1446:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2490_done
    goto rxscan2490_scan
  rxscan2490_loop:
    (rx2489_pos) = rx2489_cur."from"()
    inc rx2489_pos
    rx2489_cur."!cursor_from"(rx2489_pos)
    ge rx2489_pos, rx2489_eos, rxscan2490_done
  rxscan2490_scan:
    set_addr $I10, rxscan2490_loop
    rx2489_cur."!mark_push"(0, rx2489_pos, $I10)
  rxscan2490_done:
.annotate 'line', 1038
  # rx subrule "ws" subtype=method negate=
    rx2489_cur."!cursor_pos"(rx2489_pos)
    $P10 = rx2489_cur."ws"()
    unless $P10, rx2489_fail
    rx2489_pos = $P10."pos"()
  # rx subrule "statement" subtype=capture negate=
    rx2489_cur."!cursor_pos"(rx2489_pos)
    $P10 = rx2489_cur."statement"()
    unless $P10, rx2489_fail
    rx2489_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx2489_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2489_cur."!cursor_pos"(rx2489_pos)
    $P10 = rx2489_cur."ws"()
    unless $P10, rx2489_fail
    rx2489_pos = $P10."pos"()
  # rx pass
    rx2489_cur."!cursor_pass"(rx2489_pos, "semilist")
    if_null rx2489_debug, debug_1447
    rx2489_cur."!cursor_debug"("PASS", "semilist", " at pos=", rx2489_pos)
  debug_1447:
    .return (rx2489_cur)
  rx2489_restart:
.annotate 'line', 436
    if_null rx2489_debug, debug_1448
    rx2489_cur."!cursor_debug"("NEXT", "semilist")
  debug_1448:
  rx2489_fail:
    (rx2489_rep, rx2489_pos, $I10, $P10) = rx2489_cur."!mark_fail"(0)
    lt rx2489_pos, -1, rx2489_done
    eq rx2489_pos, -1, rx2489_fail
    jump $I10
  rx2489_done:
    rx2489_cur."!cursor_fail"()
    if_null rx2489_debug, debug_1449
    rx2489_cur."!cursor_debug"("FAIL", "semilist")
  debug_1449:
    .return (rx2489_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__semilist"  :subid("306_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2494 = self."!PREFIX__!subrule"("ws", "")
    new $P2495, "ResizablePMCArray"
    push $P2495, $P2494
    .return ($P2495)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixish"  :subid("307_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2497_tgt
    .local int rx2497_pos
    .local int rx2497_off
    .local int rx2497_eos
    .local int rx2497_rep
    .local pmc rx2497_cur
    .local pmc rx2497_debug
    (rx2497_cur, rx2497_pos, rx2497_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2497_cur
    .local pmc match
    .lex "$/", match
    length rx2497_eos, rx2497_tgt
    gt rx2497_pos, rx2497_eos, rx2497_done
    set rx2497_off, 0
    lt rx2497_pos, 2, rx2497_start
    sub rx2497_off, rx2497_pos, 1
    substr rx2497_tgt, rx2497_tgt, rx2497_off
  rx2497_start:
    eq $I10, 1, rx2497_restart
    if_null rx2497_debug, debug_1450
    rx2497_cur."!cursor_debug"("START", "infixish")
  debug_1450:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2498_done
    goto rxscan2498_scan
  rxscan2498_loop:
    (rx2497_pos) = rx2497_cur."from"()
    inc rx2497_pos
    rx2497_cur."!cursor_from"(rx2497_pos)
    ge rx2497_pos, rx2497_eos, rxscan2498_done
  rxscan2498_scan:
    set_addr $I10, rxscan2498_loop
    rx2497_cur."!mark_push"(0, rx2497_pos, $I10)
  rxscan2498_done:
.annotate 'line', 1061
  # rx subrule "infixstopper" subtype=zerowidth negate=1
    rx2497_cur."!cursor_pos"(rx2497_pos)
    $P10 = rx2497_cur."infixstopper"()
    if $P10, rx2497_fail
  # rx subrule "infix" subtype=capture negate=
    rx2497_cur."!cursor_pos"(rx2497_pos)
    $P10 = rx2497_cur."infix"()
    unless $P10, rx2497_fail
    rx2497_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("OPER=infix")
    rx2497_pos = $P10."pos"()
  # rx pass
    rx2497_cur."!cursor_pass"(rx2497_pos, "infixish")
    if_null rx2497_debug, debug_1451
    rx2497_cur."!cursor_debug"("PASS", "infixish", " at pos=", rx2497_pos)
  debug_1451:
    .return (rx2497_cur)
  rx2497_restart:
.annotate 'line', 436
    if_null rx2497_debug, debug_1452
    rx2497_cur."!cursor_debug"("NEXT", "infixish")
  debug_1452:
  rx2497_fail:
    (rx2497_rep, rx2497_pos, $I10, $P10) = rx2497_cur."!mark_fail"(0)
    lt rx2497_pos, -1, rx2497_done
    eq rx2497_pos, -1, rx2497_fail
    jump $I10
  rx2497_done:
    rx2497_cur."!cursor_fail"()
    if_null rx2497_debug, debug_1453
    rx2497_cur."!cursor_debug"("FAIL", "infixish")
  debug_1453:
    .return (rx2497_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixish"  :subid("308_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    new $P2500, "ResizablePMCArray"
    push $P2500, ""
    .return ($P2500)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixstopper"  :subid("309_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2502_tgt
    .local int rx2502_pos
    .local int rx2502_off
    .local int rx2502_eos
    .local int rx2502_rep
    .local pmc rx2502_cur
    .local pmc rx2502_debug
    (rx2502_cur, rx2502_pos, rx2502_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2502_cur
    .local pmc match
    .lex "$/", match
    length rx2502_eos, rx2502_tgt
    gt rx2502_pos, rx2502_eos, rx2502_done
    set rx2502_off, 0
    lt rx2502_pos, 2, rx2502_start
    sub rx2502_off, rx2502_pos, 1
    substr rx2502_tgt, rx2502_tgt, rx2502_off
  rx2502_start:
    eq $I10, 1, rx2502_restart
    if_null rx2502_debug, debug_1454
    rx2502_cur."!cursor_debug"("START", "infixstopper")
  debug_1454:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2503_done
    goto rxscan2503_scan
  rxscan2503_loop:
    (rx2502_pos) = rx2502_cur."from"()
    inc rx2502_pos
    rx2502_cur."!cursor_from"(rx2502_pos)
    ge rx2502_pos, rx2502_eos, rxscan2503_done
  rxscan2503_scan:
    set_addr $I10, rxscan2503_loop
    rx2502_cur."!mark_push"(0, rx2502_pos, $I10)
  rxscan2503_done:
.annotate 'line', 1062
  # rx subrule "lambda" subtype=zerowidth negate=
    rx2502_cur."!cursor_pos"(rx2502_pos)
    $P10 = rx2502_cur."lambda"()
    unless $P10, rx2502_fail
  # rx pass
    rx2502_cur."!cursor_pass"(rx2502_pos, "infixstopper")
    if_null rx2502_debug, debug_1455
    rx2502_cur."!cursor_debug"("PASS", "infixstopper", " at pos=", rx2502_pos)
  debug_1455:
    .return (rx2502_cur)
  rx2502_restart:
.annotate 'line', 436
    if_null rx2502_debug, debug_1456
    rx2502_cur."!cursor_debug"("NEXT", "infixstopper")
  debug_1456:
  rx2502_fail:
    (rx2502_rep, rx2502_pos, $I10, $P10) = rx2502_cur."!mark_fail"(0)
    lt rx2502_pos, -1, rx2502_done
    eq rx2502_pos, -1, rx2502_fail
    jump $I10
  rx2502_done:
    rx2502_cur."!cursor_fail"()
    if_null rx2502_debug, debug_1457
    rx2502_cur."!cursor_debug"("FAIL", "infixstopper")
  debug_1457:
    .return (rx2502_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixstopper"  :subid("310_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    new $P2505, "ResizablePMCArray"
    push $P2505, ""
    .return ($P2505)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<[ ]>"  :subid("311_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2507_tgt
    .local int rx2507_pos
    .local int rx2507_off
    .local int rx2507_eos
    .local int rx2507_rep
    .local pmc rx2507_cur
    .local pmc rx2507_debug
    (rx2507_cur, rx2507_pos, rx2507_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2507_cur
    .local pmc match
    .lex "$/", match
    length rx2507_eos, rx2507_tgt
    gt rx2507_pos, rx2507_eos, rx2507_done
    set rx2507_off, 0
    lt rx2507_pos, 2, rx2507_start
    sub rx2507_off, rx2507_pos, 1
    substr rx2507_tgt, rx2507_tgt, rx2507_off
  rx2507_start:
    eq $I10, 1, rx2507_restart
    if_null rx2507_debug, debug_1458
    rx2507_cur."!cursor_debug"("START", "postcircumfix:sym<[ ]>")
  debug_1458:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2508_done
    goto rxscan2508_scan
  rxscan2508_loop:
    (rx2507_pos) = rx2507_cur."from"()
    inc rx2507_pos
    rx2507_cur."!cursor_from"(rx2507_pos)
    ge rx2507_pos, rx2507_eos, rxscan2508_done
  rxscan2508_scan:
    set_addr $I10, rxscan2508_loop
    rx2507_cur."!mark_push"(0, rx2507_pos, $I10)
  rxscan2508_done:
.annotate 'line', 1065
  # rx literal  "["
    add $I11, rx2507_pos, 1
    gt $I11, rx2507_eos, rx2507_fail
    sub $I11, rx2507_pos, rx2507_off
    ord $I11, rx2507_tgt, $I11
    ne $I11, 91, rx2507_fail
    add rx2507_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2507_cur."!cursor_pos"(rx2507_pos)
    $P10 = rx2507_cur."ws"()
    unless $P10, rx2507_fail
    rx2507_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx2507_cur."!cursor_pos"(rx2507_pos)
    $P10 = rx2507_cur."EXPR"()
    unless $P10, rx2507_fail
    rx2507_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx2507_pos = $P10."pos"()
  # rx literal  "]"
    add $I11, rx2507_pos, 1
    gt $I11, rx2507_eos, rx2507_fail
    sub $I11, rx2507_pos, rx2507_off
    ord $I11, rx2507_tgt, $I11
    ne $I11, 93, rx2507_fail
    add rx2507_pos, 1
.annotate 'line', 1066
  # rx subrule "O" subtype=capture negate=
    rx2507_cur."!cursor_pos"(rx2507_pos)
    $P10 = rx2507_cur."O"("%methodop")
    unless $P10, rx2507_fail
    rx2507_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2507_pos = $P10."pos"()
.annotate 'line', 1064
  # rx pass
    rx2507_cur."!cursor_pass"(rx2507_pos, "postcircumfix:sym<[ ]>")
    if_null rx2507_debug, debug_1459
    rx2507_cur."!cursor_debug"("PASS", "postcircumfix:sym<[ ]>", " at pos=", rx2507_pos)
  debug_1459:
    .return (rx2507_cur)
  rx2507_restart:
.annotate 'line', 436
    if_null rx2507_debug, debug_1460
    rx2507_cur."!cursor_debug"("NEXT", "postcircumfix:sym<[ ]>")
  debug_1460:
  rx2507_fail:
    (rx2507_rep, rx2507_pos, $I10, $P10) = rx2507_cur."!mark_fail"(0)
    lt rx2507_pos, -1, rx2507_done
    eq rx2507_pos, -1, rx2507_fail
    jump $I10
  rx2507_done:
    rx2507_cur."!cursor_fail"()
    if_null rx2507_debug, debug_1461
    rx2507_cur."!cursor_debug"("FAIL", "postcircumfix:sym<[ ]>")
  debug_1461:
    .return (rx2507_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<[ ]>"  :subid("312_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2510 = self."!PREFIX__!subrule"("ws", "[")
    new $P2511, "ResizablePMCArray"
    push $P2511, $P2510
    .return ($P2511)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<{ }>"  :subid("313_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2513_tgt
    .local int rx2513_pos
    .local int rx2513_off
    .local int rx2513_eos
    .local int rx2513_rep
    .local pmc rx2513_cur
    .local pmc rx2513_debug
    (rx2513_cur, rx2513_pos, rx2513_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2513_cur
    .local pmc match
    .lex "$/", match
    length rx2513_eos, rx2513_tgt
    gt rx2513_pos, rx2513_eos, rx2513_done
    set rx2513_off, 0
    lt rx2513_pos, 2, rx2513_start
    sub rx2513_off, rx2513_pos, 1
    substr rx2513_tgt, rx2513_tgt, rx2513_off
  rx2513_start:
    eq $I10, 1, rx2513_restart
    if_null rx2513_debug, debug_1462
    rx2513_cur."!cursor_debug"("START", "postcircumfix:sym<{ }>")
  debug_1462:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2514_done
    goto rxscan2514_scan
  rxscan2514_loop:
    (rx2513_pos) = rx2513_cur."from"()
    inc rx2513_pos
    rx2513_cur."!cursor_from"(rx2513_pos)
    ge rx2513_pos, rx2513_eos, rxscan2514_done
  rxscan2514_scan:
    set_addr $I10, rxscan2514_loop
    rx2513_cur."!mark_push"(0, rx2513_pos, $I10)
  rxscan2514_done:
.annotate 'line', 1070
  # rx literal  "{"
    add $I11, rx2513_pos, 1
    gt $I11, rx2513_eos, rx2513_fail
    sub $I11, rx2513_pos, rx2513_off
    ord $I11, rx2513_tgt, $I11
    ne $I11, 123, rx2513_fail
    add rx2513_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2513_cur."!cursor_pos"(rx2513_pos)
    $P10 = rx2513_cur."ws"()
    unless $P10, rx2513_fail
    rx2513_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx2513_cur."!cursor_pos"(rx2513_pos)
    $P10 = rx2513_cur."EXPR"()
    unless $P10, rx2513_fail
    rx2513_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx2513_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx2513_pos, 1
    gt $I11, rx2513_eos, rx2513_fail
    sub $I11, rx2513_pos, rx2513_off
    ord $I11, rx2513_tgt, $I11
    ne $I11, 125, rx2513_fail
    add rx2513_pos, 1
.annotate 'line', 1071
  # rx subrule "O" subtype=capture negate=
    rx2513_cur."!cursor_pos"(rx2513_pos)
    $P10 = rx2513_cur."O"("%methodop")
    unless $P10, rx2513_fail
    rx2513_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2513_pos = $P10."pos"()
.annotate 'line', 1069
  # rx pass
    rx2513_cur."!cursor_pass"(rx2513_pos, "postcircumfix:sym<{ }>")
    if_null rx2513_debug, debug_1463
    rx2513_cur."!cursor_debug"("PASS", "postcircumfix:sym<{ }>", " at pos=", rx2513_pos)
  debug_1463:
    .return (rx2513_cur)
  rx2513_restart:
.annotate 'line', 436
    if_null rx2513_debug, debug_1464
    rx2513_cur."!cursor_debug"("NEXT", "postcircumfix:sym<{ }>")
  debug_1464:
  rx2513_fail:
    (rx2513_rep, rx2513_pos, $I10, $P10) = rx2513_cur."!mark_fail"(0)
    lt rx2513_pos, -1, rx2513_done
    eq rx2513_pos, -1, rx2513_fail
    jump $I10
  rx2513_done:
    rx2513_cur."!cursor_fail"()
    if_null rx2513_debug, debug_1465
    rx2513_cur."!cursor_debug"("FAIL", "postcircumfix:sym<{ }>")
  debug_1465:
    .return (rx2513_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<{ }>"  :subid("314_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2516 = self."!PREFIX__!subrule"("ws", "{")
    new $P2517, "ResizablePMCArray"
    push $P2517, $P2516
    .return ($P2517)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<ang>"  :subid("315_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2519_tgt
    .local int rx2519_pos
    .local int rx2519_off
    .local int rx2519_eos
    .local int rx2519_rep
    .local pmc rx2519_cur
    .local pmc rx2519_debug
    (rx2519_cur, rx2519_pos, rx2519_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2519_cur
    .local pmc match
    .lex "$/", match
    length rx2519_eos, rx2519_tgt
    gt rx2519_pos, rx2519_eos, rx2519_done
    set rx2519_off, 0
    lt rx2519_pos, 2, rx2519_start
    sub rx2519_off, rx2519_pos, 1
    substr rx2519_tgt, rx2519_tgt, rx2519_off
  rx2519_start:
    eq $I10, 1, rx2519_restart
    if_null rx2519_debug, debug_1466
    rx2519_cur."!cursor_debug"("START", "postcircumfix:sym<ang>")
  debug_1466:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2520_done
    goto rxscan2520_scan
  rxscan2520_loop:
    (rx2519_pos) = rx2519_cur."from"()
    inc rx2519_pos
    rx2519_cur."!cursor_from"(rx2519_pos)
    ge rx2519_pos, rx2519_eos, rxscan2520_done
  rxscan2520_scan:
    set_addr $I10, rxscan2520_loop
    rx2519_cur."!mark_push"(0, rx2519_pos, $I10)
  rxscan2520_done:
.annotate 'line', 1075
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2519_pos, rx2519_off
    substr $S10, rx2519_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx2519_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx2519_cur."!cursor_pos"(rx2519_pos)
    $P10 = rx2519_cur."quote_EXPR"(":q")
    unless $P10, rx2519_fail
    rx2519_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx2519_pos = $P10."pos"()
.annotate 'line', 1076
  # rx subrule "O" subtype=capture negate=
    rx2519_cur."!cursor_pos"(rx2519_pos)
    $P10 = rx2519_cur."O"("%methodop")
    unless $P10, rx2519_fail
    rx2519_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2519_pos = $P10."pos"()
.annotate 'line', 1074
  # rx pass
    rx2519_cur."!cursor_pass"(rx2519_pos, "postcircumfix:sym<ang>")
    if_null rx2519_debug, debug_1467
    rx2519_cur."!cursor_debug"("PASS", "postcircumfix:sym<ang>", " at pos=", rx2519_pos)
  debug_1467:
    .return (rx2519_cur)
  rx2519_restart:
.annotate 'line', 436
    if_null rx2519_debug, debug_1468
    rx2519_cur."!cursor_debug"("NEXT", "postcircumfix:sym<ang>")
  debug_1468:
  rx2519_fail:
    (rx2519_rep, rx2519_pos, $I10, $P10) = rx2519_cur."!mark_fail"(0)
    lt rx2519_pos, -1, rx2519_done
    eq rx2519_pos, -1, rx2519_fail
    jump $I10
  rx2519_done:
    rx2519_cur."!cursor_fail"()
    if_null rx2519_debug, debug_1469
    rx2519_cur."!cursor_debug"("FAIL", "postcircumfix:sym<ang>")
  debug_1469:
    .return (rx2519_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<ang>"  :subid("316_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    new $P2522, "ResizablePMCArray"
    push $P2522, "<"
    .return ($P2522)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<( )>"  :subid("317_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2524_tgt
    .local int rx2524_pos
    .local int rx2524_off
    .local int rx2524_eos
    .local int rx2524_rep
    .local pmc rx2524_cur
    .local pmc rx2524_debug
    (rx2524_cur, rx2524_pos, rx2524_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2524_cur
    .local pmc match
    .lex "$/", match
    length rx2524_eos, rx2524_tgt
    gt rx2524_pos, rx2524_eos, rx2524_done
    set rx2524_off, 0
    lt rx2524_pos, 2, rx2524_start
    sub rx2524_off, rx2524_pos, 1
    substr rx2524_tgt, rx2524_tgt, rx2524_off
  rx2524_start:
    eq $I10, 1, rx2524_restart
    if_null rx2524_debug, debug_1470
    rx2524_cur."!cursor_debug"("START", "postcircumfix:sym<( )>")
  debug_1470:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2525_done
    goto rxscan2525_scan
  rxscan2525_loop:
    (rx2524_pos) = rx2524_cur."from"()
    inc rx2524_pos
    rx2524_cur."!cursor_from"(rx2524_pos)
    ge rx2524_pos, rx2524_eos, rxscan2525_done
  rxscan2525_scan:
    set_addr $I10, rxscan2525_loop
    rx2524_cur."!mark_push"(0, rx2524_pos, $I10)
  rxscan2525_done:
.annotate 'line', 1080
  # rx literal  "("
    add $I11, rx2524_pos, 1
    gt $I11, rx2524_eos, rx2524_fail
    sub $I11, rx2524_pos, rx2524_off
    ord $I11, rx2524_tgt, $I11
    ne $I11, 40, rx2524_fail
    add rx2524_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2524_cur."!cursor_pos"(rx2524_pos)
    $P10 = rx2524_cur."ws"()
    unless $P10, rx2524_fail
    rx2524_pos = $P10."pos"()
  # rx subrule "arglist" subtype=capture negate=
    rx2524_cur."!cursor_pos"(rx2524_pos)
    $P10 = rx2524_cur."arglist"()
    unless $P10, rx2524_fail
    rx2524_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2524_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx2524_pos, 1
    gt $I11, rx2524_eos, rx2524_fail
    sub $I11, rx2524_pos, rx2524_off
    ord $I11, rx2524_tgt, $I11
    ne $I11, 41, rx2524_fail
    add rx2524_pos, 1
.annotate 'line', 1081
  # rx subrule "O" subtype=capture negate=
    rx2524_cur."!cursor_pos"(rx2524_pos)
    $P10 = rx2524_cur."O"("%methodop")
    unless $P10, rx2524_fail
    rx2524_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2524_pos = $P10."pos"()
.annotate 'line', 1079
  # rx pass
    rx2524_cur."!cursor_pass"(rx2524_pos, "postcircumfix:sym<( )>")
    if_null rx2524_debug, debug_1471
    rx2524_cur."!cursor_debug"("PASS", "postcircumfix:sym<( )>", " at pos=", rx2524_pos)
  debug_1471:
    .return (rx2524_cur)
  rx2524_restart:
.annotate 'line', 436
    if_null rx2524_debug, debug_1472
    rx2524_cur."!cursor_debug"("NEXT", "postcircumfix:sym<( )>")
  debug_1472:
  rx2524_fail:
    (rx2524_rep, rx2524_pos, $I10, $P10) = rx2524_cur."!mark_fail"(0)
    lt rx2524_pos, -1, rx2524_done
    eq rx2524_pos, -1, rx2524_fail
    jump $I10
  rx2524_done:
    rx2524_cur."!cursor_fail"()
    if_null rx2524_debug, debug_1473
    rx2524_cur."!cursor_debug"("FAIL", "postcircumfix:sym<( )>")
  debug_1473:
    .return (rx2524_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<( )>"  :subid("318_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2527 = self."!PREFIX__!subrule"("ws", "(")
    new $P2528, "ResizablePMCArray"
    push $P2528, $P2527
    .return ($P2528)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<.>"  :subid("319_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2530_tgt
    .local int rx2530_pos
    .local int rx2530_off
    .local int rx2530_eos
    .local int rx2530_rep
    .local pmc rx2530_cur
    .local pmc rx2530_debug
    (rx2530_cur, rx2530_pos, rx2530_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2530_cur
    .local pmc match
    .lex "$/", match
    length rx2530_eos, rx2530_tgt
    gt rx2530_pos, rx2530_eos, rx2530_done
    set rx2530_off, 0
    lt rx2530_pos, 2, rx2530_start
    sub rx2530_off, rx2530_pos, 1
    substr rx2530_tgt, rx2530_tgt, rx2530_off
  rx2530_start:
    eq $I10, 1, rx2530_restart
    if_null rx2530_debug, debug_1474
    rx2530_cur."!cursor_debug"("START", "postfix:sym<.>")
  debug_1474:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2531_done
    goto rxscan2531_scan
  rxscan2531_loop:
    (rx2530_pos) = rx2530_cur."from"()
    inc rx2530_pos
    rx2530_cur."!cursor_from"(rx2530_pos)
    ge rx2530_pos, rx2530_eos, rxscan2531_done
  rxscan2531_scan:
    set_addr $I10, rxscan2531_loop
    rx2530_cur."!mark_push"(0, rx2530_pos, $I10)
  rxscan2531_done:
.annotate 'line', 1084
  # rx subrule "dotty" subtype=capture negate=
    rx2530_cur."!cursor_pos"(rx2530_pos)
    $P10 = rx2530_cur."dotty"()
    unless $P10, rx2530_fail
    rx2530_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dotty")
    rx2530_pos = $P10."pos"()
  # rx subrule "O" subtype=capture negate=
    rx2530_cur."!cursor_pos"(rx2530_pos)
    $P10 = rx2530_cur."O"("%methodop")
    unless $P10, rx2530_fail
    rx2530_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2530_pos = $P10."pos"()
  # rx pass
    rx2530_cur."!cursor_pass"(rx2530_pos, "postfix:sym<.>")
    if_null rx2530_debug, debug_1475
    rx2530_cur."!cursor_debug"("PASS", "postfix:sym<.>", " at pos=", rx2530_pos)
  debug_1475:
    .return (rx2530_cur)
  rx2530_restart:
.annotate 'line', 436
    if_null rx2530_debug, debug_1476
    rx2530_cur."!cursor_debug"("NEXT", "postfix:sym<.>")
  debug_1476:
  rx2530_fail:
    (rx2530_rep, rx2530_pos, $I10, $P10) = rx2530_cur."!mark_fail"(0)
    lt rx2530_pos, -1, rx2530_done
    eq rx2530_pos, -1, rx2530_fail
    jump $I10
  rx2530_done:
    rx2530_cur."!cursor_fail"()
    if_null rx2530_debug, debug_1477
    rx2530_cur."!cursor_debug"("FAIL", "postfix:sym<.>")
  debug_1477:
    .return (rx2530_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<.>"  :subid("320_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2533 = self."!PREFIX__!subrule"("dotty", "")
    new $P2534, "ResizablePMCArray"
    push $P2534, $P2533
    .return ($P2534)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<++>"  :subid("321_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2536_tgt
    .local int rx2536_pos
    .local int rx2536_off
    .local int rx2536_eos
    .local int rx2536_rep
    .local pmc rx2536_cur
    .local pmc rx2536_debug
    (rx2536_cur, rx2536_pos, rx2536_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2536_cur
    .local pmc match
    .lex "$/", match
    length rx2536_eos, rx2536_tgt
    gt rx2536_pos, rx2536_eos, rx2536_done
    set rx2536_off, 0
    lt rx2536_pos, 2, rx2536_start
    sub rx2536_off, rx2536_pos, 1
    substr rx2536_tgt, rx2536_tgt, rx2536_off
  rx2536_start:
    eq $I10, 1, rx2536_restart
    if_null rx2536_debug, debug_1478
    rx2536_cur."!cursor_debug"("START", "prefix:sym<++>")
  debug_1478:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2537_done
    goto rxscan2537_scan
  rxscan2537_loop:
    (rx2536_pos) = rx2536_cur."from"()
    inc rx2536_pos
    rx2536_cur."!cursor_from"(rx2536_pos)
    ge rx2536_pos, rx2536_eos, rxscan2537_done
  rxscan2537_scan:
    set_addr $I10, rxscan2537_loop
    rx2536_cur."!mark_push"(0, rx2536_pos, $I10)
  rxscan2537_done:
.annotate 'line', 1086
  # rx subcapture "sym"
    set_addr $I10, rxcap_2538_fail
    rx2536_cur."!mark_push"(0, rx2536_pos, $I10)
  # rx literal  "++"
    add $I11, rx2536_pos, 2
    gt $I11, rx2536_eos, rx2536_fail
    sub $I11, rx2536_pos, rx2536_off
    substr $S10, rx2536_tgt, $I11, 2
    ne $S10, "++", rx2536_fail
    add rx2536_pos, 2
    set_addr $I10, rxcap_2538_fail
    ($I12, $I11) = rx2536_cur."!mark_peek"($I10)
    rx2536_cur."!cursor_pos"($I11)
    ($P10) = rx2536_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2536_pos, "")
    rx2536_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2538_done
  rxcap_2538_fail:
    goto rx2536_fail
  rxcap_2538_done:
  # rx subrule "O" subtype=capture negate=
    rx2536_cur."!cursor_pos"(rx2536_pos)
    $P10 = rx2536_cur."O"("%autoincrement, :pirop<inc>")
    unless $P10, rx2536_fail
    rx2536_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2536_pos = $P10."pos"()
  # rx pass
    rx2536_cur."!cursor_pass"(rx2536_pos, "prefix:sym<++>")
    if_null rx2536_debug, debug_1479
    rx2536_cur."!cursor_debug"("PASS", "prefix:sym<++>", " at pos=", rx2536_pos)
  debug_1479:
    .return (rx2536_cur)
  rx2536_restart:
.annotate 'line', 436
    if_null rx2536_debug, debug_1480
    rx2536_cur."!cursor_debug"("NEXT", "prefix:sym<++>")
  debug_1480:
  rx2536_fail:
    (rx2536_rep, rx2536_pos, $I10, $P10) = rx2536_cur."!mark_fail"(0)
    lt rx2536_pos, -1, rx2536_done
    eq rx2536_pos, -1, rx2536_fail
    jump $I10
  rx2536_done:
    rx2536_cur."!cursor_fail"()
    if_null rx2536_debug, debug_1481
    rx2536_cur."!cursor_debug"("FAIL", "prefix:sym<++>")
  debug_1481:
    .return (rx2536_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<++>"  :subid("322_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2540 = self."!PREFIX__!subrule"("O", "++")
    new $P2541, "ResizablePMCArray"
    push $P2541, $P2540
    .return ($P2541)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<-->"  :subid("323_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2543_tgt
    .local int rx2543_pos
    .local int rx2543_off
    .local int rx2543_eos
    .local int rx2543_rep
    .local pmc rx2543_cur
    .local pmc rx2543_debug
    (rx2543_cur, rx2543_pos, rx2543_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2543_cur
    .local pmc match
    .lex "$/", match
    length rx2543_eos, rx2543_tgt
    gt rx2543_pos, rx2543_eos, rx2543_done
    set rx2543_off, 0
    lt rx2543_pos, 2, rx2543_start
    sub rx2543_off, rx2543_pos, 1
    substr rx2543_tgt, rx2543_tgt, rx2543_off
  rx2543_start:
    eq $I10, 1, rx2543_restart
    if_null rx2543_debug, debug_1482
    rx2543_cur."!cursor_debug"("START", "prefix:sym<-->")
  debug_1482:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2544_done
    goto rxscan2544_scan
  rxscan2544_loop:
    (rx2543_pos) = rx2543_cur."from"()
    inc rx2543_pos
    rx2543_cur."!cursor_from"(rx2543_pos)
    ge rx2543_pos, rx2543_eos, rxscan2544_done
  rxscan2544_scan:
    set_addr $I10, rxscan2544_loop
    rx2543_cur."!mark_push"(0, rx2543_pos, $I10)
  rxscan2544_done:
.annotate 'line', 1087
  # rx subcapture "sym"
    set_addr $I10, rxcap_2545_fail
    rx2543_cur."!mark_push"(0, rx2543_pos, $I10)
  # rx literal  "--"
    add $I11, rx2543_pos, 2
    gt $I11, rx2543_eos, rx2543_fail
    sub $I11, rx2543_pos, rx2543_off
    substr $S10, rx2543_tgt, $I11, 2
    ne $S10, "--", rx2543_fail
    add rx2543_pos, 2
    set_addr $I10, rxcap_2545_fail
    ($I12, $I11) = rx2543_cur."!mark_peek"($I10)
    rx2543_cur."!cursor_pos"($I11)
    ($P10) = rx2543_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2543_pos, "")
    rx2543_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2545_done
  rxcap_2545_fail:
    goto rx2543_fail
  rxcap_2545_done:
  # rx subrule "O" subtype=capture negate=
    rx2543_cur."!cursor_pos"(rx2543_pos)
    $P10 = rx2543_cur."O"("%autoincrement, :pirop<dec>")
    unless $P10, rx2543_fail
    rx2543_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2543_pos = $P10."pos"()
  # rx pass
    rx2543_cur."!cursor_pass"(rx2543_pos, "prefix:sym<-->")
    if_null rx2543_debug, debug_1483
    rx2543_cur."!cursor_debug"("PASS", "prefix:sym<-->", " at pos=", rx2543_pos)
  debug_1483:
    .return (rx2543_cur)
  rx2543_restart:
.annotate 'line', 436
    if_null rx2543_debug, debug_1484
    rx2543_cur."!cursor_debug"("NEXT", "prefix:sym<-->")
  debug_1484:
  rx2543_fail:
    (rx2543_rep, rx2543_pos, $I10, $P10) = rx2543_cur."!mark_fail"(0)
    lt rx2543_pos, -1, rx2543_done
    eq rx2543_pos, -1, rx2543_fail
    jump $I10
  rx2543_done:
    rx2543_cur."!cursor_fail"()
    if_null rx2543_debug, debug_1485
    rx2543_cur."!cursor_debug"("FAIL", "prefix:sym<-->")
  debug_1485:
    .return (rx2543_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<-->"  :subid("324_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2547 = self."!PREFIX__!subrule"("O", "--")
    new $P2548, "ResizablePMCArray"
    push $P2548, $P2547
    .return ($P2548)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<++>"  :subid("325_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2550_tgt
    .local int rx2550_pos
    .local int rx2550_off
    .local int rx2550_eos
    .local int rx2550_rep
    .local pmc rx2550_cur
    .local pmc rx2550_debug
    (rx2550_cur, rx2550_pos, rx2550_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2550_cur
    .local pmc match
    .lex "$/", match
    length rx2550_eos, rx2550_tgt
    gt rx2550_pos, rx2550_eos, rx2550_done
    set rx2550_off, 0
    lt rx2550_pos, 2, rx2550_start
    sub rx2550_off, rx2550_pos, 1
    substr rx2550_tgt, rx2550_tgt, rx2550_off
  rx2550_start:
    eq $I10, 1, rx2550_restart
    if_null rx2550_debug, debug_1486
    rx2550_cur."!cursor_debug"("START", "postfix:sym<++>")
  debug_1486:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2551_done
    goto rxscan2551_scan
  rxscan2551_loop:
    (rx2550_pos) = rx2550_cur."from"()
    inc rx2550_pos
    rx2550_cur."!cursor_from"(rx2550_pos)
    ge rx2550_pos, rx2550_eos, rxscan2551_done
  rxscan2551_scan:
    set_addr $I10, rxscan2551_loop
    rx2550_cur."!mark_push"(0, rx2550_pos, $I10)
  rxscan2551_done:
.annotate 'line', 1090
  # rx subcapture "sym"
    set_addr $I10, rxcap_2552_fail
    rx2550_cur."!mark_push"(0, rx2550_pos, $I10)
  # rx literal  "++"
    add $I11, rx2550_pos, 2
    gt $I11, rx2550_eos, rx2550_fail
    sub $I11, rx2550_pos, rx2550_off
    substr $S10, rx2550_tgt, $I11, 2
    ne $S10, "++", rx2550_fail
    add rx2550_pos, 2
    set_addr $I10, rxcap_2552_fail
    ($I12, $I11) = rx2550_cur."!mark_peek"($I10)
    rx2550_cur."!cursor_pos"($I11)
    ($P10) = rx2550_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2550_pos, "")
    rx2550_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2552_done
  rxcap_2552_fail:
    goto rx2550_fail
  rxcap_2552_done:
  # rx subrule "O" subtype=capture negate=
    rx2550_cur."!cursor_pos"(rx2550_pos)
    $P10 = rx2550_cur."O"("%autoincrement")
    unless $P10, rx2550_fail
    rx2550_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2550_pos = $P10."pos"()
  # rx pass
    rx2550_cur."!cursor_pass"(rx2550_pos, "postfix:sym<++>")
    if_null rx2550_debug, debug_1487
    rx2550_cur."!cursor_debug"("PASS", "postfix:sym<++>", " at pos=", rx2550_pos)
  debug_1487:
    .return (rx2550_cur)
  rx2550_restart:
.annotate 'line', 436
    if_null rx2550_debug, debug_1488
    rx2550_cur."!cursor_debug"("NEXT", "postfix:sym<++>")
  debug_1488:
  rx2550_fail:
    (rx2550_rep, rx2550_pos, $I10, $P10) = rx2550_cur."!mark_fail"(0)
    lt rx2550_pos, -1, rx2550_done
    eq rx2550_pos, -1, rx2550_fail
    jump $I10
  rx2550_done:
    rx2550_cur."!cursor_fail"()
    if_null rx2550_debug, debug_1489
    rx2550_cur."!cursor_debug"("FAIL", "postfix:sym<++>")
  debug_1489:
    .return (rx2550_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<++>"  :subid("326_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2554 = self."!PREFIX__!subrule"("O", "++")
    new $P2555, "ResizablePMCArray"
    push $P2555, $P2554
    .return ($P2555)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<-->"  :subid("327_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2557_tgt
    .local int rx2557_pos
    .local int rx2557_off
    .local int rx2557_eos
    .local int rx2557_rep
    .local pmc rx2557_cur
    .local pmc rx2557_debug
    (rx2557_cur, rx2557_pos, rx2557_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2557_cur
    .local pmc match
    .lex "$/", match
    length rx2557_eos, rx2557_tgt
    gt rx2557_pos, rx2557_eos, rx2557_done
    set rx2557_off, 0
    lt rx2557_pos, 2, rx2557_start
    sub rx2557_off, rx2557_pos, 1
    substr rx2557_tgt, rx2557_tgt, rx2557_off
  rx2557_start:
    eq $I10, 1, rx2557_restart
    if_null rx2557_debug, debug_1490
    rx2557_cur."!cursor_debug"("START", "postfix:sym<-->")
  debug_1490:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2558_done
    goto rxscan2558_scan
  rxscan2558_loop:
    (rx2557_pos) = rx2557_cur."from"()
    inc rx2557_pos
    rx2557_cur."!cursor_from"(rx2557_pos)
    ge rx2557_pos, rx2557_eos, rxscan2558_done
  rxscan2558_scan:
    set_addr $I10, rxscan2558_loop
    rx2557_cur."!mark_push"(0, rx2557_pos, $I10)
  rxscan2558_done:
.annotate 'line', 1091
  # rx subcapture "sym"
    set_addr $I10, rxcap_2559_fail
    rx2557_cur."!mark_push"(0, rx2557_pos, $I10)
  # rx literal  "--"
    add $I11, rx2557_pos, 2
    gt $I11, rx2557_eos, rx2557_fail
    sub $I11, rx2557_pos, rx2557_off
    substr $S10, rx2557_tgt, $I11, 2
    ne $S10, "--", rx2557_fail
    add rx2557_pos, 2
    set_addr $I10, rxcap_2559_fail
    ($I12, $I11) = rx2557_cur."!mark_peek"($I10)
    rx2557_cur."!cursor_pos"($I11)
    ($P10) = rx2557_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2557_pos, "")
    rx2557_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2559_done
  rxcap_2559_fail:
    goto rx2557_fail
  rxcap_2559_done:
  # rx subrule "O" subtype=capture negate=
    rx2557_cur."!cursor_pos"(rx2557_pos)
    $P10 = rx2557_cur."O"("%autoincrement")
    unless $P10, rx2557_fail
    rx2557_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2557_pos = $P10."pos"()
  # rx pass
    rx2557_cur."!cursor_pass"(rx2557_pos, "postfix:sym<-->")
    if_null rx2557_debug, debug_1491
    rx2557_cur."!cursor_debug"("PASS", "postfix:sym<-->", " at pos=", rx2557_pos)
  debug_1491:
    .return (rx2557_cur)
  rx2557_restart:
.annotate 'line', 436
    if_null rx2557_debug, debug_1492
    rx2557_cur."!cursor_debug"("NEXT", "postfix:sym<-->")
  debug_1492:
  rx2557_fail:
    (rx2557_rep, rx2557_pos, $I10, $P10) = rx2557_cur."!mark_fail"(0)
    lt rx2557_pos, -1, rx2557_done
    eq rx2557_pos, -1, rx2557_fail
    jump $I10
  rx2557_done:
    rx2557_cur."!cursor_fail"()
    if_null rx2557_debug, debug_1493
    rx2557_cur."!cursor_debug"("FAIL", "postfix:sym<-->")
  debug_1493:
    .return (rx2557_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<-->"  :subid("328_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2561 = self."!PREFIX__!subrule"("O", "--")
    new $P2562, "ResizablePMCArray"
    push $P2562, $P2561
    .return ($P2562)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<**>"  :subid("329_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2564_tgt
    .local int rx2564_pos
    .local int rx2564_off
    .local int rx2564_eos
    .local int rx2564_rep
    .local pmc rx2564_cur
    .local pmc rx2564_debug
    (rx2564_cur, rx2564_pos, rx2564_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2564_cur
    .local pmc match
    .lex "$/", match
    length rx2564_eos, rx2564_tgt
    gt rx2564_pos, rx2564_eos, rx2564_done
    set rx2564_off, 0
    lt rx2564_pos, 2, rx2564_start
    sub rx2564_off, rx2564_pos, 1
    substr rx2564_tgt, rx2564_tgt, rx2564_off
  rx2564_start:
    eq $I10, 1, rx2564_restart
    if_null rx2564_debug, debug_1494
    rx2564_cur."!cursor_debug"("START", "infix:sym<**>")
  debug_1494:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2565_done
    goto rxscan2565_scan
  rxscan2565_loop:
    (rx2564_pos) = rx2564_cur."from"()
    inc rx2564_pos
    rx2564_cur."!cursor_from"(rx2564_pos)
    ge rx2564_pos, rx2564_eos, rxscan2565_done
  rxscan2565_scan:
    set_addr $I10, rxscan2565_loop
    rx2564_cur."!mark_push"(0, rx2564_pos, $I10)
  rxscan2565_done:
.annotate 'line', 1093
  # rx subcapture "sym"
    set_addr $I10, rxcap_2566_fail
    rx2564_cur."!mark_push"(0, rx2564_pos, $I10)
  # rx literal  "**"
    add $I11, rx2564_pos, 2
    gt $I11, rx2564_eos, rx2564_fail
    sub $I11, rx2564_pos, rx2564_off
    substr $S10, rx2564_tgt, $I11, 2
    ne $S10, "**", rx2564_fail
    add rx2564_pos, 2
    set_addr $I10, rxcap_2566_fail
    ($I12, $I11) = rx2564_cur."!mark_peek"($I10)
    rx2564_cur."!cursor_pos"($I11)
    ($P10) = rx2564_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2564_pos, "")
    rx2564_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2566_done
  rxcap_2566_fail:
    goto rx2564_fail
  rxcap_2566_done:
  # rx subrule "O" subtype=capture negate=
    rx2564_cur."!cursor_pos"(rx2564_pos)
    $P10 = rx2564_cur."O"("%exponentiation, :pirop<pow__NNN>")
    unless $P10, rx2564_fail
    rx2564_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2564_pos = $P10."pos"()
  # rx pass
    rx2564_cur."!cursor_pass"(rx2564_pos, "infix:sym<**>")
    if_null rx2564_debug, debug_1495
    rx2564_cur."!cursor_debug"("PASS", "infix:sym<**>", " at pos=", rx2564_pos)
  debug_1495:
    .return (rx2564_cur)
  rx2564_restart:
.annotate 'line', 436
    if_null rx2564_debug, debug_1496
    rx2564_cur."!cursor_debug"("NEXT", "infix:sym<**>")
  debug_1496:
  rx2564_fail:
    (rx2564_rep, rx2564_pos, $I10, $P10) = rx2564_cur."!mark_fail"(0)
    lt rx2564_pos, -1, rx2564_done
    eq rx2564_pos, -1, rx2564_fail
    jump $I10
  rx2564_done:
    rx2564_cur."!cursor_fail"()
    if_null rx2564_debug, debug_1497
    rx2564_cur."!cursor_debug"("FAIL", "infix:sym<**>")
  debug_1497:
    .return (rx2564_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<**>"  :subid("330_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2568 = self."!PREFIX__!subrule"("O", "**")
    new $P2569, "ResizablePMCArray"
    push $P2569, $P2568
    .return ($P2569)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<+>"  :subid("331_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2571_tgt
    .local int rx2571_pos
    .local int rx2571_off
    .local int rx2571_eos
    .local int rx2571_rep
    .local pmc rx2571_cur
    .local pmc rx2571_debug
    (rx2571_cur, rx2571_pos, rx2571_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2571_cur
    .local pmc match
    .lex "$/", match
    length rx2571_eos, rx2571_tgt
    gt rx2571_pos, rx2571_eos, rx2571_done
    set rx2571_off, 0
    lt rx2571_pos, 2, rx2571_start
    sub rx2571_off, rx2571_pos, 1
    substr rx2571_tgt, rx2571_tgt, rx2571_off
  rx2571_start:
    eq $I10, 1, rx2571_restart
    if_null rx2571_debug, debug_1498
    rx2571_cur."!cursor_debug"("START", "prefix:sym<+>")
  debug_1498:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2572_done
    goto rxscan2572_scan
  rxscan2572_loop:
    (rx2571_pos) = rx2571_cur."from"()
    inc rx2571_pos
    rx2571_cur."!cursor_from"(rx2571_pos)
    ge rx2571_pos, rx2571_eos, rxscan2572_done
  rxscan2572_scan:
    set_addr $I10, rxscan2572_loop
    rx2571_cur."!mark_push"(0, rx2571_pos, $I10)
  rxscan2572_done:
.annotate 'line', 1095
  # rx subcapture "sym"
    set_addr $I10, rxcap_2573_fail
    rx2571_cur."!mark_push"(0, rx2571_pos, $I10)
  # rx literal  "+"
    add $I11, rx2571_pos, 1
    gt $I11, rx2571_eos, rx2571_fail
    sub $I11, rx2571_pos, rx2571_off
    ord $I11, rx2571_tgt, $I11
    ne $I11, 43, rx2571_fail
    add rx2571_pos, 1
    set_addr $I10, rxcap_2573_fail
    ($I12, $I11) = rx2571_cur."!mark_peek"($I10)
    rx2571_cur."!cursor_pos"($I11)
    ($P10) = rx2571_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2571_pos, "")
    rx2571_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2573_done
  rxcap_2573_fail:
    goto rx2571_fail
  rxcap_2573_done:
  # rx subrule "O" subtype=capture negate=
    rx2571_cur."!cursor_pos"(rx2571_pos)
    $P10 = rx2571_cur."O"("%symbolic_unary, :pirop<set N*>")
    unless $P10, rx2571_fail
    rx2571_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2571_pos = $P10."pos"()
  # rx pass
    rx2571_cur."!cursor_pass"(rx2571_pos, "prefix:sym<+>")
    if_null rx2571_debug, debug_1499
    rx2571_cur."!cursor_debug"("PASS", "prefix:sym<+>", " at pos=", rx2571_pos)
  debug_1499:
    .return (rx2571_cur)
  rx2571_restart:
.annotate 'line', 436
    if_null rx2571_debug, debug_1500
    rx2571_cur."!cursor_debug"("NEXT", "prefix:sym<+>")
  debug_1500:
  rx2571_fail:
    (rx2571_rep, rx2571_pos, $I10, $P10) = rx2571_cur."!mark_fail"(0)
    lt rx2571_pos, -1, rx2571_done
    eq rx2571_pos, -1, rx2571_fail
    jump $I10
  rx2571_done:
    rx2571_cur."!cursor_fail"()
    if_null rx2571_debug, debug_1501
    rx2571_cur."!cursor_debug"("FAIL", "prefix:sym<+>")
  debug_1501:
    .return (rx2571_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<+>"  :subid("332_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2575 = self."!PREFIX__!subrule"("O", "+")
    new $P2576, "ResizablePMCArray"
    push $P2576, $P2575
    .return ($P2576)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<~>"  :subid("333_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2578_tgt
    .local int rx2578_pos
    .local int rx2578_off
    .local int rx2578_eos
    .local int rx2578_rep
    .local pmc rx2578_cur
    .local pmc rx2578_debug
    (rx2578_cur, rx2578_pos, rx2578_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2578_cur
    .local pmc match
    .lex "$/", match
    length rx2578_eos, rx2578_tgt
    gt rx2578_pos, rx2578_eos, rx2578_done
    set rx2578_off, 0
    lt rx2578_pos, 2, rx2578_start
    sub rx2578_off, rx2578_pos, 1
    substr rx2578_tgt, rx2578_tgt, rx2578_off
  rx2578_start:
    eq $I10, 1, rx2578_restart
    if_null rx2578_debug, debug_1502
    rx2578_cur."!cursor_debug"("START", "prefix:sym<~>")
  debug_1502:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2579_done
    goto rxscan2579_scan
  rxscan2579_loop:
    (rx2578_pos) = rx2578_cur."from"()
    inc rx2578_pos
    rx2578_cur."!cursor_from"(rx2578_pos)
    ge rx2578_pos, rx2578_eos, rxscan2579_done
  rxscan2579_scan:
    set_addr $I10, rxscan2579_loop
    rx2578_cur."!mark_push"(0, rx2578_pos, $I10)
  rxscan2579_done:
.annotate 'line', 1096
  # rx subcapture "sym"
    set_addr $I10, rxcap_2580_fail
    rx2578_cur."!mark_push"(0, rx2578_pos, $I10)
  # rx literal  "~"
    add $I11, rx2578_pos, 1
    gt $I11, rx2578_eos, rx2578_fail
    sub $I11, rx2578_pos, rx2578_off
    ord $I11, rx2578_tgt, $I11
    ne $I11, 126, rx2578_fail
    add rx2578_pos, 1
    set_addr $I10, rxcap_2580_fail
    ($I12, $I11) = rx2578_cur."!mark_peek"($I10)
    rx2578_cur."!cursor_pos"($I11)
    ($P10) = rx2578_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2578_pos, "")
    rx2578_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2580_done
  rxcap_2580_fail:
    goto rx2578_fail
  rxcap_2580_done:
  # rx subrule "O" subtype=capture negate=
    rx2578_cur."!cursor_pos"(rx2578_pos)
    $P10 = rx2578_cur."O"("%symbolic_unary, :pirop<set S*>")
    unless $P10, rx2578_fail
    rx2578_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2578_pos = $P10."pos"()
  # rx pass
    rx2578_cur."!cursor_pass"(rx2578_pos, "prefix:sym<~>")
    if_null rx2578_debug, debug_1503
    rx2578_cur."!cursor_debug"("PASS", "prefix:sym<~>", " at pos=", rx2578_pos)
  debug_1503:
    .return (rx2578_cur)
  rx2578_restart:
.annotate 'line', 436
    if_null rx2578_debug, debug_1504
    rx2578_cur."!cursor_debug"("NEXT", "prefix:sym<~>")
  debug_1504:
  rx2578_fail:
    (rx2578_rep, rx2578_pos, $I10, $P10) = rx2578_cur."!mark_fail"(0)
    lt rx2578_pos, -1, rx2578_done
    eq rx2578_pos, -1, rx2578_fail
    jump $I10
  rx2578_done:
    rx2578_cur."!cursor_fail"()
    if_null rx2578_debug, debug_1505
    rx2578_cur."!cursor_debug"("FAIL", "prefix:sym<~>")
  debug_1505:
    .return (rx2578_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<~>"  :subid("334_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2582 = self."!PREFIX__!subrule"("O", "~")
    new $P2583, "ResizablePMCArray"
    push $P2583, $P2582
    .return ($P2583)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<->"  :subid("335_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2585_tgt
    .local int rx2585_pos
    .local int rx2585_off
    .local int rx2585_eos
    .local int rx2585_rep
    .local pmc rx2585_cur
    .local pmc rx2585_debug
    (rx2585_cur, rx2585_pos, rx2585_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2585_cur
    .local pmc match
    .lex "$/", match
    length rx2585_eos, rx2585_tgt
    gt rx2585_pos, rx2585_eos, rx2585_done
    set rx2585_off, 0
    lt rx2585_pos, 2, rx2585_start
    sub rx2585_off, rx2585_pos, 1
    substr rx2585_tgt, rx2585_tgt, rx2585_off
  rx2585_start:
    eq $I10, 1, rx2585_restart
    if_null rx2585_debug, debug_1506
    rx2585_cur."!cursor_debug"("START", "prefix:sym<->")
  debug_1506:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2586_done
    goto rxscan2586_scan
  rxscan2586_loop:
    (rx2585_pos) = rx2585_cur."from"()
    inc rx2585_pos
    rx2585_cur."!cursor_from"(rx2585_pos)
    ge rx2585_pos, rx2585_eos, rxscan2586_done
  rxscan2586_scan:
    set_addr $I10, rxscan2586_loop
    rx2585_cur."!mark_push"(0, rx2585_pos, $I10)
  rxscan2586_done:
.annotate 'line', 1097
  # rx subcapture "sym"
    set_addr $I10, rxcap_2587_fail
    rx2585_cur."!mark_push"(0, rx2585_pos, $I10)
  # rx literal  "-"
    add $I11, rx2585_pos, 1
    gt $I11, rx2585_eos, rx2585_fail
    sub $I11, rx2585_pos, rx2585_off
    ord $I11, rx2585_tgt, $I11
    ne $I11, 45, rx2585_fail
    add rx2585_pos, 1
    set_addr $I10, rxcap_2587_fail
    ($I12, $I11) = rx2585_cur."!mark_peek"($I10)
    rx2585_cur."!cursor_pos"($I11)
    ($P10) = rx2585_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2585_pos, "")
    rx2585_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2587_done
  rxcap_2587_fail:
    goto rx2585_fail
  rxcap_2587_done:
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx2585_pos, rx2585_off
    substr $S10, rx2585_tgt, $I10, 1
    index $I11, ">", $S10
    ge $I11, 0, rx2585_fail
  # rx subrule "number" subtype=zerowidth negate=1
    rx2585_cur."!cursor_pos"(rx2585_pos)
    $P10 = rx2585_cur."number"()
    if $P10, rx2585_fail
  # rx subrule "O" subtype=capture negate=
    rx2585_cur."!cursor_pos"(rx2585_pos)
    $P10 = rx2585_cur."O"("%symbolic_unary, :pirop<neg>")
    unless $P10, rx2585_fail
    rx2585_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2585_pos = $P10."pos"()
  # rx pass
    rx2585_cur."!cursor_pass"(rx2585_pos, "prefix:sym<->")
    if_null rx2585_debug, debug_1507
    rx2585_cur."!cursor_debug"("PASS", "prefix:sym<->", " at pos=", rx2585_pos)
  debug_1507:
    .return (rx2585_cur)
  rx2585_restart:
.annotate 'line', 436
    if_null rx2585_debug, debug_1508
    rx2585_cur."!cursor_debug"("NEXT", "prefix:sym<->")
  debug_1508:
  rx2585_fail:
    (rx2585_rep, rx2585_pos, $I10, $P10) = rx2585_cur."!mark_fail"(0)
    lt rx2585_pos, -1, rx2585_done
    eq rx2585_pos, -1, rx2585_fail
    jump $I10
  rx2585_done:
    rx2585_cur."!cursor_fail"()
    if_null rx2585_debug, debug_1509
    rx2585_cur."!cursor_debug"("FAIL", "prefix:sym<->")
  debug_1509:
    .return (rx2585_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<->"  :subid("336_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    new $P2589, "ResizablePMCArray"
    push $P2589, "-"
    .return ($P2589)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<?>"  :subid("337_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2591_tgt
    .local int rx2591_pos
    .local int rx2591_off
    .local int rx2591_eos
    .local int rx2591_rep
    .local pmc rx2591_cur
    .local pmc rx2591_debug
    (rx2591_cur, rx2591_pos, rx2591_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2591_cur
    .local pmc match
    .lex "$/", match
    length rx2591_eos, rx2591_tgt
    gt rx2591_pos, rx2591_eos, rx2591_done
    set rx2591_off, 0
    lt rx2591_pos, 2, rx2591_start
    sub rx2591_off, rx2591_pos, 1
    substr rx2591_tgt, rx2591_tgt, rx2591_off
  rx2591_start:
    eq $I10, 1, rx2591_restart
    if_null rx2591_debug, debug_1510
    rx2591_cur."!cursor_debug"("START", "prefix:sym<?>")
  debug_1510:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2592_done
    goto rxscan2592_scan
  rxscan2592_loop:
    (rx2591_pos) = rx2591_cur."from"()
    inc rx2591_pos
    rx2591_cur."!cursor_from"(rx2591_pos)
    ge rx2591_pos, rx2591_eos, rxscan2592_done
  rxscan2592_scan:
    set_addr $I10, rxscan2592_loop
    rx2591_cur."!mark_push"(0, rx2591_pos, $I10)
  rxscan2592_done:
.annotate 'line', 1098
  # rx subcapture "sym"
    set_addr $I10, rxcap_2593_fail
    rx2591_cur."!mark_push"(0, rx2591_pos, $I10)
  # rx literal  "?"
    add $I11, rx2591_pos, 1
    gt $I11, rx2591_eos, rx2591_fail
    sub $I11, rx2591_pos, rx2591_off
    ord $I11, rx2591_tgt, $I11
    ne $I11, 63, rx2591_fail
    add rx2591_pos, 1
    set_addr $I10, rxcap_2593_fail
    ($I12, $I11) = rx2591_cur."!mark_peek"($I10)
    rx2591_cur."!cursor_pos"($I11)
    ($P10) = rx2591_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2591_pos, "")
    rx2591_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2593_done
  rxcap_2593_fail:
    goto rx2591_fail
  rxcap_2593_done:
  # rx subrule "O" subtype=capture negate=
    rx2591_cur."!cursor_pos"(rx2591_pos)
    $P10 = rx2591_cur."O"("%symbolic_unary, :pirop<istrue>")
    unless $P10, rx2591_fail
    rx2591_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2591_pos = $P10."pos"()
  # rx pass
    rx2591_cur."!cursor_pass"(rx2591_pos, "prefix:sym<?>")
    if_null rx2591_debug, debug_1511
    rx2591_cur."!cursor_debug"("PASS", "prefix:sym<?>", " at pos=", rx2591_pos)
  debug_1511:
    .return (rx2591_cur)
  rx2591_restart:
.annotate 'line', 436
    if_null rx2591_debug, debug_1512
    rx2591_cur."!cursor_debug"("NEXT", "prefix:sym<?>")
  debug_1512:
  rx2591_fail:
    (rx2591_rep, rx2591_pos, $I10, $P10) = rx2591_cur."!mark_fail"(0)
    lt rx2591_pos, -1, rx2591_done
    eq rx2591_pos, -1, rx2591_fail
    jump $I10
  rx2591_done:
    rx2591_cur."!cursor_fail"()
    if_null rx2591_debug, debug_1513
    rx2591_cur."!cursor_debug"("FAIL", "prefix:sym<?>")
  debug_1513:
    .return (rx2591_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<?>"  :subid("338_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2595 = self."!PREFIX__!subrule"("O", "?")
    new $P2596, "ResizablePMCArray"
    push $P2596, $P2595
    .return ($P2596)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<!>"  :subid("339_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2598_tgt
    .local int rx2598_pos
    .local int rx2598_off
    .local int rx2598_eos
    .local int rx2598_rep
    .local pmc rx2598_cur
    .local pmc rx2598_debug
    (rx2598_cur, rx2598_pos, rx2598_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2598_cur
    .local pmc match
    .lex "$/", match
    length rx2598_eos, rx2598_tgt
    gt rx2598_pos, rx2598_eos, rx2598_done
    set rx2598_off, 0
    lt rx2598_pos, 2, rx2598_start
    sub rx2598_off, rx2598_pos, 1
    substr rx2598_tgt, rx2598_tgt, rx2598_off
  rx2598_start:
    eq $I10, 1, rx2598_restart
    if_null rx2598_debug, debug_1514
    rx2598_cur."!cursor_debug"("START", "prefix:sym<!>")
  debug_1514:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2599_done
    goto rxscan2599_scan
  rxscan2599_loop:
    (rx2598_pos) = rx2598_cur."from"()
    inc rx2598_pos
    rx2598_cur."!cursor_from"(rx2598_pos)
    ge rx2598_pos, rx2598_eos, rxscan2599_done
  rxscan2599_scan:
    set_addr $I10, rxscan2599_loop
    rx2598_cur."!mark_push"(0, rx2598_pos, $I10)
  rxscan2599_done:
.annotate 'line', 1099
  # rx subcapture "sym"
    set_addr $I10, rxcap_2600_fail
    rx2598_cur."!mark_push"(0, rx2598_pos, $I10)
  # rx literal  "!"
    add $I11, rx2598_pos, 1
    gt $I11, rx2598_eos, rx2598_fail
    sub $I11, rx2598_pos, rx2598_off
    ord $I11, rx2598_tgt, $I11
    ne $I11, 33, rx2598_fail
    add rx2598_pos, 1
    set_addr $I10, rxcap_2600_fail
    ($I12, $I11) = rx2598_cur."!mark_peek"($I10)
    rx2598_cur."!cursor_pos"($I11)
    ($P10) = rx2598_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2598_pos, "")
    rx2598_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2600_done
  rxcap_2600_fail:
    goto rx2598_fail
  rxcap_2600_done:
  # rx subrule "O" subtype=capture negate=
    rx2598_cur."!cursor_pos"(rx2598_pos)
    $P10 = rx2598_cur."O"("%symbolic_unary, :pirop<isfalse>")
    unless $P10, rx2598_fail
    rx2598_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2598_pos = $P10."pos"()
  # rx pass
    rx2598_cur."!cursor_pass"(rx2598_pos, "prefix:sym<!>")
    if_null rx2598_debug, debug_1515
    rx2598_cur."!cursor_debug"("PASS", "prefix:sym<!>", " at pos=", rx2598_pos)
  debug_1515:
    .return (rx2598_cur)
  rx2598_restart:
.annotate 'line', 436
    if_null rx2598_debug, debug_1516
    rx2598_cur."!cursor_debug"("NEXT", "prefix:sym<!>")
  debug_1516:
  rx2598_fail:
    (rx2598_rep, rx2598_pos, $I10, $P10) = rx2598_cur."!mark_fail"(0)
    lt rx2598_pos, -1, rx2598_done
    eq rx2598_pos, -1, rx2598_fail
    jump $I10
  rx2598_done:
    rx2598_cur."!cursor_fail"()
    if_null rx2598_debug, debug_1517
    rx2598_cur."!cursor_debug"("FAIL", "prefix:sym<!>")
  debug_1517:
    .return (rx2598_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<!>"  :subid("340_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2602 = self."!PREFIX__!subrule"("O", "!")
    new $P2603, "ResizablePMCArray"
    push $P2603, $P2602
    .return ($P2603)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<|>"  :subid("341_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2605_tgt
    .local int rx2605_pos
    .local int rx2605_off
    .local int rx2605_eos
    .local int rx2605_rep
    .local pmc rx2605_cur
    .local pmc rx2605_debug
    (rx2605_cur, rx2605_pos, rx2605_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2605_cur
    .local pmc match
    .lex "$/", match
    length rx2605_eos, rx2605_tgt
    gt rx2605_pos, rx2605_eos, rx2605_done
    set rx2605_off, 0
    lt rx2605_pos, 2, rx2605_start
    sub rx2605_off, rx2605_pos, 1
    substr rx2605_tgt, rx2605_tgt, rx2605_off
  rx2605_start:
    eq $I10, 1, rx2605_restart
    if_null rx2605_debug, debug_1518
    rx2605_cur."!cursor_debug"("START", "prefix:sym<|>")
  debug_1518:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2606_done
    goto rxscan2606_scan
  rxscan2606_loop:
    (rx2605_pos) = rx2605_cur."from"()
    inc rx2605_pos
    rx2605_cur."!cursor_from"(rx2605_pos)
    ge rx2605_pos, rx2605_eos, rxscan2606_done
  rxscan2606_scan:
    set_addr $I10, rxscan2606_loop
    rx2605_cur."!mark_push"(0, rx2605_pos, $I10)
  rxscan2606_done:
.annotate 'line', 1100
  # rx subcapture "sym"
    set_addr $I10, rxcap_2607_fail
    rx2605_cur."!mark_push"(0, rx2605_pos, $I10)
  # rx literal  "|"
    add $I11, rx2605_pos, 1
    gt $I11, rx2605_eos, rx2605_fail
    sub $I11, rx2605_pos, rx2605_off
    ord $I11, rx2605_tgt, $I11
    ne $I11, 124, rx2605_fail
    add rx2605_pos, 1
    set_addr $I10, rxcap_2607_fail
    ($I12, $I11) = rx2605_cur."!mark_peek"($I10)
    rx2605_cur."!cursor_pos"($I11)
    ($P10) = rx2605_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2605_pos, "")
    rx2605_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2607_done
  rxcap_2607_fail:
    goto rx2605_fail
  rxcap_2607_done:
  # rx subrule "O" subtype=capture negate=
    rx2605_cur."!cursor_pos"(rx2605_pos)
    $P10 = rx2605_cur."O"("%symbolic_unary")
    unless $P10, rx2605_fail
    rx2605_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2605_pos = $P10."pos"()
  # rx pass
    rx2605_cur."!cursor_pass"(rx2605_pos, "prefix:sym<|>")
    if_null rx2605_debug, debug_1519
    rx2605_cur."!cursor_debug"("PASS", "prefix:sym<|>", " at pos=", rx2605_pos)
  debug_1519:
    .return (rx2605_cur)
  rx2605_restart:
.annotate 'line', 436
    if_null rx2605_debug, debug_1520
    rx2605_cur."!cursor_debug"("NEXT", "prefix:sym<|>")
  debug_1520:
  rx2605_fail:
    (rx2605_rep, rx2605_pos, $I10, $P10) = rx2605_cur."!mark_fail"(0)
    lt rx2605_pos, -1, rx2605_done
    eq rx2605_pos, -1, rx2605_fail
    jump $I10
  rx2605_done:
    rx2605_cur."!cursor_fail"()
    if_null rx2605_debug, debug_1521
    rx2605_cur."!cursor_debug"("FAIL", "prefix:sym<|>")
  debug_1521:
    .return (rx2605_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<|>"  :subid("342_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2609 = self."!PREFIX__!subrule"("O", "|")
    new $P2610, "ResizablePMCArray"
    push $P2610, $P2609
    .return ($P2610)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<*>"  :subid("343_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2612_tgt
    .local int rx2612_pos
    .local int rx2612_off
    .local int rx2612_eos
    .local int rx2612_rep
    .local pmc rx2612_cur
    .local pmc rx2612_debug
    (rx2612_cur, rx2612_pos, rx2612_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2612_cur
    .local pmc match
    .lex "$/", match
    length rx2612_eos, rx2612_tgt
    gt rx2612_pos, rx2612_eos, rx2612_done
    set rx2612_off, 0
    lt rx2612_pos, 2, rx2612_start
    sub rx2612_off, rx2612_pos, 1
    substr rx2612_tgt, rx2612_tgt, rx2612_off
  rx2612_start:
    eq $I10, 1, rx2612_restart
    if_null rx2612_debug, debug_1522
    rx2612_cur."!cursor_debug"("START", "infix:sym<*>")
  debug_1522:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2613_done
    goto rxscan2613_scan
  rxscan2613_loop:
    (rx2612_pos) = rx2612_cur."from"()
    inc rx2612_pos
    rx2612_cur."!cursor_from"(rx2612_pos)
    ge rx2612_pos, rx2612_eos, rxscan2613_done
  rxscan2613_scan:
    set_addr $I10, rxscan2613_loop
    rx2612_cur."!mark_push"(0, rx2612_pos, $I10)
  rxscan2613_done:
.annotate 'line', 1102
  # rx subcapture "sym"
    set_addr $I10, rxcap_2614_fail
    rx2612_cur."!mark_push"(0, rx2612_pos, $I10)
  # rx literal  "*"
    add $I11, rx2612_pos, 1
    gt $I11, rx2612_eos, rx2612_fail
    sub $I11, rx2612_pos, rx2612_off
    ord $I11, rx2612_tgt, $I11
    ne $I11, 42, rx2612_fail
    add rx2612_pos, 1
    set_addr $I10, rxcap_2614_fail
    ($I12, $I11) = rx2612_cur."!mark_peek"($I10)
    rx2612_cur."!cursor_pos"($I11)
    ($P10) = rx2612_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2612_pos, "")
    rx2612_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2614_done
  rxcap_2614_fail:
    goto rx2612_fail
  rxcap_2614_done:
  # rx subrule "O" subtype=capture negate=
    rx2612_cur."!cursor_pos"(rx2612_pos)
    $P10 = rx2612_cur."O"("%multiplicative, :pirop<mul>")
    unless $P10, rx2612_fail
    rx2612_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2612_pos = $P10."pos"()
  # rx pass
    rx2612_cur."!cursor_pass"(rx2612_pos, "infix:sym<*>")
    if_null rx2612_debug, debug_1523
    rx2612_cur."!cursor_debug"("PASS", "infix:sym<*>", " at pos=", rx2612_pos)
  debug_1523:
    .return (rx2612_cur)
  rx2612_restart:
.annotate 'line', 436
    if_null rx2612_debug, debug_1524
    rx2612_cur."!cursor_debug"("NEXT", "infix:sym<*>")
  debug_1524:
  rx2612_fail:
    (rx2612_rep, rx2612_pos, $I10, $P10) = rx2612_cur."!mark_fail"(0)
    lt rx2612_pos, -1, rx2612_done
    eq rx2612_pos, -1, rx2612_fail
    jump $I10
  rx2612_done:
    rx2612_cur."!cursor_fail"()
    if_null rx2612_debug, debug_1525
    rx2612_cur."!cursor_debug"("FAIL", "infix:sym<*>")
  debug_1525:
    .return (rx2612_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<*>"  :subid("344_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2616 = self."!PREFIX__!subrule"("O", "*")
    new $P2617, "ResizablePMCArray"
    push $P2617, $P2616
    .return ($P2617)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym</>"  :subid("345_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2619_tgt
    .local int rx2619_pos
    .local int rx2619_off
    .local int rx2619_eos
    .local int rx2619_rep
    .local pmc rx2619_cur
    .local pmc rx2619_debug
    (rx2619_cur, rx2619_pos, rx2619_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2619_cur
    .local pmc match
    .lex "$/", match
    length rx2619_eos, rx2619_tgt
    gt rx2619_pos, rx2619_eos, rx2619_done
    set rx2619_off, 0
    lt rx2619_pos, 2, rx2619_start
    sub rx2619_off, rx2619_pos, 1
    substr rx2619_tgt, rx2619_tgt, rx2619_off
  rx2619_start:
    eq $I10, 1, rx2619_restart
    if_null rx2619_debug, debug_1526
    rx2619_cur."!cursor_debug"("START", "infix:sym</>")
  debug_1526:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2620_done
    goto rxscan2620_scan
  rxscan2620_loop:
    (rx2619_pos) = rx2619_cur."from"()
    inc rx2619_pos
    rx2619_cur."!cursor_from"(rx2619_pos)
    ge rx2619_pos, rx2619_eos, rxscan2620_done
  rxscan2620_scan:
    set_addr $I10, rxscan2620_loop
    rx2619_cur."!mark_push"(0, rx2619_pos, $I10)
  rxscan2620_done:
.annotate 'line', 1103
  # rx subcapture "sym"
    set_addr $I10, rxcap_2621_fail
    rx2619_cur."!mark_push"(0, rx2619_pos, $I10)
  # rx literal  "/"
    add $I11, rx2619_pos, 1
    gt $I11, rx2619_eos, rx2619_fail
    sub $I11, rx2619_pos, rx2619_off
    ord $I11, rx2619_tgt, $I11
    ne $I11, 47, rx2619_fail
    add rx2619_pos, 1
    set_addr $I10, rxcap_2621_fail
    ($I12, $I11) = rx2619_cur."!mark_peek"($I10)
    rx2619_cur."!cursor_pos"($I11)
    ($P10) = rx2619_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2619_pos, "")
    rx2619_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2621_done
  rxcap_2621_fail:
    goto rx2619_fail
  rxcap_2621_done:
  # rx subrule "O" subtype=capture negate=
    rx2619_cur."!cursor_pos"(rx2619_pos)
    $P10 = rx2619_cur."O"("%multiplicative, :pirop<div>")
    unless $P10, rx2619_fail
    rx2619_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2619_pos = $P10."pos"()
  # rx pass
    rx2619_cur."!cursor_pass"(rx2619_pos, "infix:sym</>")
    if_null rx2619_debug, debug_1527
    rx2619_cur."!cursor_debug"("PASS", "infix:sym</>", " at pos=", rx2619_pos)
  debug_1527:
    .return (rx2619_cur)
  rx2619_restart:
.annotate 'line', 436
    if_null rx2619_debug, debug_1528
    rx2619_cur."!cursor_debug"("NEXT", "infix:sym</>")
  debug_1528:
  rx2619_fail:
    (rx2619_rep, rx2619_pos, $I10, $P10) = rx2619_cur."!mark_fail"(0)
    lt rx2619_pos, -1, rx2619_done
    eq rx2619_pos, -1, rx2619_fail
    jump $I10
  rx2619_done:
    rx2619_cur."!cursor_fail"()
    if_null rx2619_debug, debug_1529
    rx2619_cur."!cursor_debug"("FAIL", "infix:sym</>")
  debug_1529:
    .return (rx2619_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym</>"  :subid("346_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2623 = self."!PREFIX__!subrule"("O", "/")
    new $P2624, "ResizablePMCArray"
    push $P2624, $P2623
    .return ($P2624)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<%>"  :subid("347_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2626_tgt
    .local int rx2626_pos
    .local int rx2626_off
    .local int rx2626_eos
    .local int rx2626_rep
    .local pmc rx2626_cur
    .local pmc rx2626_debug
    (rx2626_cur, rx2626_pos, rx2626_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2626_cur
    .local pmc match
    .lex "$/", match
    length rx2626_eos, rx2626_tgt
    gt rx2626_pos, rx2626_eos, rx2626_done
    set rx2626_off, 0
    lt rx2626_pos, 2, rx2626_start
    sub rx2626_off, rx2626_pos, 1
    substr rx2626_tgt, rx2626_tgt, rx2626_off
  rx2626_start:
    eq $I10, 1, rx2626_restart
    if_null rx2626_debug, debug_1530
    rx2626_cur."!cursor_debug"("START", "infix:sym<%>")
  debug_1530:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2627_done
    goto rxscan2627_scan
  rxscan2627_loop:
    (rx2626_pos) = rx2626_cur."from"()
    inc rx2626_pos
    rx2626_cur."!cursor_from"(rx2626_pos)
    ge rx2626_pos, rx2626_eos, rxscan2627_done
  rxscan2627_scan:
    set_addr $I10, rxscan2627_loop
    rx2626_cur."!mark_push"(0, rx2626_pos, $I10)
  rxscan2627_done:
.annotate 'line', 1104
  # rx subcapture "sym"
    set_addr $I10, rxcap_2628_fail
    rx2626_cur."!mark_push"(0, rx2626_pos, $I10)
  # rx literal  "%"
    add $I11, rx2626_pos, 1
    gt $I11, rx2626_eos, rx2626_fail
    sub $I11, rx2626_pos, rx2626_off
    ord $I11, rx2626_tgt, $I11
    ne $I11, 37, rx2626_fail
    add rx2626_pos, 1
    set_addr $I10, rxcap_2628_fail
    ($I12, $I11) = rx2626_cur."!mark_peek"($I10)
    rx2626_cur."!cursor_pos"($I11)
    ($P10) = rx2626_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2626_pos, "")
    rx2626_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2628_done
  rxcap_2628_fail:
    goto rx2626_fail
  rxcap_2628_done:
  # rx subrule "O" subtype=capture negate=
    rx2626_cur."!cursor_pos"(rx2626_pos)
    $P10 = rx2626_cur."O"("%multiplicative, :pirop<mod>")
    unless $P10, rx2626_fail
    rx2626_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2626_pos = $P10."pos"()
  # rx pass
    rx2626_cur."!cursor_pass"(rx2626_pos, "infix:sym<%>")
    if_null rx2626_debug, debug_1531
    rx2626_cur."!cursor_debug"("PASS", "infix:sym<%>", " at pos=", rx2626_pos)
  debug_1531:
    .return (rx2626_cur)
  rx2626_restart:
.annotate 'line', 436
    if_null rx2626_debug, debug_1532
    rx2626_cur."!cursor_debug"("NEXT", "infix:sym<%>")
  debug_1532:
  rx2626_fail:
    (rx2626_rep, rx2626_pos, $I10, $P10) = rx2626_cur."!mark_fail"(0)
    lt rx2626_pos, -1, rx2626_done
    eq rx2626_pos, -1, rx2626_fail
    jump $I10
  rx2626_done:
    rx2626_cur."!cursor_fail"()
    if_null rx2626_debug, debug_1533
    rx2626_cur."!cursor_debug"("FAIL", "infix:sym<%>")
  debug_1533:
    .return (rx2626_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<%>"  :subid("348_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2630 = self."!PREFIX__!subrule"("O", "%")
    new $P2631, "ResizablePMCArray"
    push $P2631, $P2630
    .return ($P2631)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+&>"  :subid("349_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2633_tgt
    .local int rx2633_pos
    .local int rx2633_off
    .local int rx2633_eos
    .local int rx2633_rep
    .local pmc rx2633_cur
    .local pmc rx2633_debug
    (rx2633_cur, rx2633_pos, rx2633_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2633_cur
    .local pmc match
    .lex "$/", match
    length rx2633_eos, rx2633_tgt
    gt rx2633_pos, rx2633_eos, rx2633_done
    set rx2633_off, 0
    lt rx2633_pos, 2, rx2633_start
    sub rx2633_off, rx2633_pos, 1
    substr rx2633_tgt, rx2633_tgt, rx2633_off
  rx2633_start:
    eq $I10, 1, rx2633_restart
    if_null rx2633_debug, debug_1534
    rx2633_cur."!cursor_debug"("START", "infix:sym<+&>")
  debug_1534:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2634_done
    goto rxscan2634_scan
  rxscan2634_loop:
    (rx2633_pos) = rx2633_cur."from"()
    inc rx2633_pos
    rx2633_cur."!cursor_from"(rx2633_pos)
    ge rx2633_pos, rx2633_eos, rxscan2634_done
  rxscan2634_scan:
    set_addr $I10, rxscan2634_loop
    rx2633_cur."!mark_push"(0, rx2633_pos, $I10)
  rxscan2634_done:
.annotate 'line', 1105
  # rx subcapture "sym"
    set_addr $I10, rxcap_2635_fail
    rx2633_cur."!mark_push"(0, rx2633_pos, $I10)
  # rx literal  "+&"
    add $I11, rx2633_pos, 2
    gt $I11, rx2633_eos, rx2633_fail
    sub $I11, rx2633_pos, rx2633_off
    substr $S10, rx2633_tgt, $I11, 2
    ne $S10, "+&", rx2633_fail
    add rx2633_pos, 2
    set_addr $I10, rxcap_2635_fail
    ($I12, $I11) = rx2633_cur."!mark_peek"($I10)
    rx2633_cur."!cursor_pos"($I11)
    ($P10) = rx2633_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2633_pos, "")
    rx2633_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2635_done
  rxcap_2635_fail:
    goto rx2633_fail
  rxcap_2635_done:
  # rx subrule "O" subtype=capture negate=
    rx2633_cur."!cursor_pos"(rx2633_pos)
    $P10 = rx2633_cur."O"("%multiplicative, :pirop<band III>")
    unless $P10, rx2633_fail
    rx2633_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2633_pos = $P10."pos"()
  # rx pass
    rx2633_cur."!cursor_pass"(rx2633_pos, "infix:sym<+&>")
    if_null rx2633_debug, debug_1535
    rx2633_cur."!cursor_debug"("PASS", "infix:sym<+&>", " at pos=", rx2633_pos)
  debug_1535:
    .return (rx2633_cur)
  rx2633_restart:
.annotate 'line', 436
    if_null rx2633_debug, debug_1536
    rx2633_cur."!cursor_debug"("NEXT", "infix:sym<+&>")
  debug_1536:
  rx2633_fail:
    (rx2633_rep, rx2633_pos, $I10, $P10) = rx2633_cur."!mark_fail"(0)
    lt rx2633_pos, -1, rx2633_done
    eq rx2633_pos, -1, rx2633_fail
    jump $I10
  rx2633_done:
    rx2633_cur."!cursor_fail"()
    if_null rx2633_debug, debug_1537
    rx2633_cur."!cursor_debug"("FAIL", "infix:sym<+&>")
  debug_1537:
    .return (rx2633_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+&>"  :subid("350_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2637 = self."!PREFIX__!subrule"("O", "+&")
    new $P2638, "ResizablePMCArray"
    push $P2638, $P2637
    .return ($P2638)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+>"  :subid("351_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2640_tgt
    .local int rx2640_pos
    .local int rx2640_off
    .local int rx2640_eos
    .local int rx2640_rep
    .local pmc rx2640_cur
    .local pmc rx2640_debug
    (rx2640_cur, rx2640_pos, rx2640_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2640_cur
    .local pmc match
    .lex "$/", match
    length rx2640_eos, rx2640_tgt
    gt rx2640_pos, rx2640_eos, rx2640_done
    set rx2640_off, 0
    lt rx2640_pos, 2, rx2640_start
    sub rx2640_off, rx2640_pos, 1
    substr rx2640_tgt, rx2640_tgt, rx2640_off
  rx2640_start:
    eq $I10, 1, rx2640_restart
    if_null rx2640_debug, debug_1538
    rx2640_cur."!cursor_debug"("START", "infix:sym<+>")
  debug_1538:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2641_done
    goto rxscan2641_scan
  rxscan2641_loop:
    (rx2640_pos) = rx2640_cur."from"()
    inc rx2640_pos
    rx2640_cur."!cursor_from"(rx2640_pos)
    ge rx2640_pos, rx2640_eos, rxscan2641_done
  rxscan2641_scan:
    set_addr $I10, rxscan2641_loop
    rx2640_cur."!mark_push"(0, rx2640_pos, $I10)
  rxscan2641_done:
.annotate 'line', 1107
  # rx subcapture "sym"
    set_addr $I10, rxcap_2642_fail
    rx2640_cur."!mark_push"(0, rx2640_pos, $I10)
  # rx literal  "+"
    add $I11, rx2640_pos, 1
    gt $I11, rx2640_eos, rx2640_fail
    sub $I11, rx2640_pos, rx2640_off
    ord $I11, rx2640_tgt, $I11
    ne $I11, 43, rx2640_fail
    add rx2640_pos, 1
    set_addr $I10, rxcap_2642_fail
    ($I12, $I11) = rx2640_cur."!mark_peek"($I10)
    rx2640_cur."!cursor_pos"($I11)
    ($P10) = rx2640_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2640_pos, "")
    rx2640_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2642_done
  rxcap_2642_fail:
    goto rx2640_fail
  rxcap_2642_done:
  # rx subrule "O" subtype=capture negate=
    rx2640_cur."!cursor_pos"(rx2640_pos)
    $P10 = rx2640_cur."O"("%additive, :pirop<add>")
    unless $P10, rx2640_fail
    rx2640_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2640_pos = $P10."pos"()
  # rx pass
    rx2640_cur."!cursor_pass"(rx2640_pos, "infix:sym<+>")
    if_null rx2640_debug, debug_1539
    rx2640_cur."!cursor_debug"("PASS", "infix:sym<+>", " at pos=", rx2640_pos)
  debug_1539:
    .return (rx2640_cur)
  rx2640_restart:
.annotate 'line', 436
    if_null rx2640_debug, debug_1540
    rx2640_cur."!cursor_debug"("NEXT", "infix:sym<+>")
  debug_1540:
  rx2640_fail:
    (rx2640_rep, rx2640_pos, $I10, $P10) = rx2640_cur."!mark_fail"(0)
    lt rx2640_pos, -1, rx2640_done
    eq rx2640_pos, -1, rx2640_fail
    jump $I10
  rx2640_done:
    rx2640_cur."!cursor_fail"()
    if_null rx2640_debug, debug_1541
    rx2640_cur."!cursor_debug"("FAIL", "infix:sym<+>")
  debug_1541:
    .return (rx2640_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+>"  :subid("352_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2644 = self."!PREFIX__!subrule"("O", "+")
    new $P2645, "ResizablePMCArray"
    push $P2645, $P2644
    .return ($P2645)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<->"  :subid("353_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2647_tgt
    .local int rx2647_pos
    .local int rx2647_off
    .local int rx2647_eos
    .local int rx2647_rep
    .local pmc rx2647_cur
    .local pmc rx2647_debug
    (rx2647_cur, rx2647_pos, rx2647_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2647_cur
    .local pmc match
    .lex "$/", match
    length rx2647_eos, rx2647_tgt
    gt rx2647_pos, rx2647_eos, rx2647_done
    set rx2647_off, 0
    lt rx2647_pos, 2, rx2647_start
    sub rx2647_off, rx2647_pos, 1
    substr rx2647_tgt, rx2647_tgt, rx2647_off
  rx2647_start:
    eq $I10, 1, rx2647_restart
    if_null rx2647_debug, debug_1542
    rx2647_cur."!cursor_debug"("START", "infix:sym<->")
  debug_1542:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2648_done
    goto rxscan2648_scan
  rxscan2648_loop:
    (rx2647_pos) = rx2647_cur."from"()
    inc rx2647_pos
    rx2647_cur."!cursor_from"(rx2647_pos)
    ge rx2647_pos, rx2647_eos, rxscan2648_done
  rxscan2648_scan:
    set_addr $I10, rxscan2648_loop
    rx2647_cur."!mark_push"(0, rx2647_pos, $I10)
  rxscan2648_done:
.annotate 'line', 1108
  # rx subcapture "sym"
    set_addr $I10, rxcap_2649_fail
    rx2647_cur."!mark_push"(0, rx2647_pos, $I10)
  # rx literal  "-"
    add $I11, rx2647_pos, 1
    gt $I11, rx2647_eos, rx2647_fail
    sub $I11, rx2647_pos, rx2647_off
    ord $I11, rx2647_tgt, $I11
    ne $I11, 45, rx2647_fail
    add rx2647_pos, 1
    set_addr $I10, rxcap_2649_fail
    ($I12, $I11) = rx2647_cur."!mark_peek"($I10)
    rx2647_cur."!cursor_pos"($I11)
    ($P10) = rx2647_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2647_pos, "")
    rx2647_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2649_done
  rxcap_2649_fail:
    goto rx2647_fail
  rxcap_2649_done:
  # rx subrule "O" subtype=capture negate=
    rx2647_cur."!cursor_pos"(rx2647_pos)
    $P10 = rx2647_cur."O"("%additive, :pirop<sub>")
    unless $P10, rx2647_fail
    rx2647_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2647_pos = $P10."pos"()
  # rx pass
    rx2647_cur."!cursor_pass"(rx2647_pos, "infix:sym<->")
    if_null rx2647_debug, debug_1543
    rx2647_cur."!cursor_debug"("PASS", "infix:sym<->", " at pos=", rx2647_pos)
  debug_1543:
    .return (rx2647_cur)
  rx2647_restart:
.annotate 'line', 436
    if_null rx2647_debug, debug_1544
    rx2647_cur."!cursor_debug"("NEXT", "infix:sym<->")
  debug_1544:
  rx2647_fail:
    (rx2647_rep, rx2647_pos, $I10, $P10) = rx2647_cur."!mark_fail"(0)
    lt rx2647_pos, -1, rx2647_done
    eq rx2647_pos, -1, rx2647_fail
    jump $I10
  rx2647_done:
    rx2647_cur."!cursor_fail"()
    if_null rx2647_debug, debug_1545
    rx2647_cur."!cursor_debug"("FAIL", "infix:sym<->")
  debug_1545:
    .return (rx2647_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<->"  :subid("354_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2651 = self."!PREFIX__!subrule"("O", "-")
    new $P2652, "ResizablePMCArray"
    push $P2652, $P2651
    .return ($P2652)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+|>"  :subid("355_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2654_tgt
    .local int rx2654_pos
    .local int rx2654_off
    .local int rx2654_eos
    .local int rx2654_rep
    .local pmc rx2654_cur
    .local pmc rx2654_debug
    (rx2654_cur, rx2654_pos, rx2654_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2654_cur
    .local pmc match
    .lex "$/", match
    length rx2654_eos, rx2654_tgt
    gt rx2654_pos, rx2654_eos, rx2654_done
    set rx2654_off, 0
    lt rx2654_pos, 2, rx2654_start
    sub rx2654_off, rx2654_pos, 1
    substr rx2654_tgt, rx2654_tgt, rx2654_off
  rx2654_start:
    eq $I10, 1, rx2654_restart
    if_null rx2654_debug, debug_1546
    rx2654_cur."!cursor_debug"("START", "infix:sym<+|>")
  debug_1546:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2655_done
    goto rxscan2655_scan
  rxscan2655_loop:
    (rx2654_pos) = rx2654_cur."from"()
    inc rx2654_pos
    rx2654_cur."!cursor_from"(rx2654_pos)
    ge rx2654_pos, rx2654_eos, rxscan2655_done
  rxscan2655_scan:
    set_addr $I10, rxscan2655_loop
    rx2654_cur."!mark_push"(0, rx2654_pos, $I10)
  rxscan2655_done:
.annotate 'line', 1109
  # rx subcapture "sym"
    set_addr $I10, rxcap_2656_fail
    rx2654_cur."!mark_push"(0, rx2654_pos, $I10)
  # rx literal  "+|"
    add $I11, rx2654_pos, 2
    gt $I11, rx2654_eos, rx2654_fail
    sub $I11, rx2654_pos, rx2654_off
    substr $S10, rx2654_tgt, $I11, 2
    ne $S10, "+|", rx2654_fail
    add rx2654_pos, 2
    set_addr $I10, rxcap_2656_fail
    ($I12, $I11) = rx2654_cur."!mark_peek"($I10)
    rx2654_cur."!cursor_pos"($I11)
    ($P10) = rx2654_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2654_pos, "")
    rx2654_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2656_done
  rxcap_2656_fail:
    goto rx2654_fail
  rxcap_2656_done:
  # rx subrule "O" subtype=capture negate=
    rx2654_cur."!cursor_pos"(rx2654_pos)
    $P10 = rx2654_cur."O"("%additive, :pirop<bor III>")
    unless $P10, rx2654_fail
    rx2654_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2654_pos = $P10."pos"()
  # rx pass
    rx2654_cur."!cursor_pass"(rx2654_pos, "infix:sym<+|>")
    if_null rx2654_debug, debug_1547
    rx2654_cur."!cursor_debug"("PASS", "infix:sym<+|>", " at pos=", rx2654_pos)
  debug_1547:
    .return (rx2654_cur)
  rx2654_restart:
.annotate 'line', 436
    if_null rx2654_debug, debug_1548
    rx2654_cur."!cursor_debug"("NEXT", "infix:sym<+|>")
  debug_1548:
  rx2654_fail:
    (rx2654_rep, rx2654_pos, $I10, $P10) = rx2654_cur."!mark_fail"(0)
    lt rx2654_pos, -1, rx2654_done
    eq rx2654_pos, -1, rx2654_fail
    jump $I10
  rx2654_done:
    rx2654_cur."!cursor_fail"()
    if_null rx2654_debug, debug_1549
    rx2654_cur."!cursor_debug"("FAIL", "infix:sym<+|>")
  debug_1549:
    .return (rx2654_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+|>"  :subid("356_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2658 = self."!PREFIX__!subrule"("O", "+|")
    new $P2659, "ResizablePMCArray"
    push $P2659, $P2658
    .return ($P2659)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+^>"  :subid("357_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2661_tgt
    .local int rx2661_pos
    .local int rx2661_off
    .local int rx2661_eos
    .local int rx2661_rep
    .local pmc rx2661_cur
    .local pmc rx2661_debug
    (rx2661_cur, rx2661_pos, rx2661_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2661_cur
    .local pmc match
    .lex "$/", match
    length rx2661_eos, rx2661_tgt
    gt rx2661_pos, rx2661_eos, rx2661_done
    set rx2661_off, 0
    lt rx2661_pos, 2, rx2661_start
    sub rx2661_off, rx2661_pos, 1
    substr rx2661_tgt, rx2661_tgt, rx2661_off
  rx2661_start:
    eq $I10, 1, rx2661_restart
    if_null rx2661_debug, debug_1550
    rx2661_cur."!cursor_debug"("START", "infix:sym<+^>")
  debug_1550:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2662_done
    goto rxscan2662_scan
  rxscan2662_loop:
    (rx2661_pos) = rx2661_cur."from"()
    inc rx2661_pos
    rx2661_cur."!cursor_from"(rx2661_pos)
    ge rx2661_pos, rx2661_eos, rxscan2662_done
  rxscan2662_scan:
    set_addr $I10, rxscan2662_loop
    rx2661_cur."!mark_push"(0, rx2661_pos, $I10)
  rxscan2662_done:
.annotate 'line', 1110
  # rx subcapture "sym"
    set_addr $I10, rxcap_2663_fail
    rx2661_cur."!mark_push"(0, rx2661_pos, $I10)
  # rx literal  "+^"
    add $I11, rx2661_pos, 2
    gt $I11, rx2661_eos, rx2661_fail
    sub $I11, rx2661_pos, rx2661_off
    substr $S10, rx2661_tgt, $I11, 2
    ne $S10, "+^", rx2661_fail
    add rx2661_pos, 2
    set_addr $I10, rxcap_2663_fail
    ($I12, $I11) = rx2661_cur."!mark_peek"($I10)
    rx2661_cur."!cursor_pos"($I11)
    ($P10) = rx2661_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2661_pos, "")
    rx2661_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2663_done
  rxcap_2663_fail:
    goto rx2661_fail
  rxcap_2663_done:
  # rx subrule "O" subtype=capture negate=
    rx2661_cur."!cursor_pos"(rx2661_pos)
    $P10 = rx2661_cur."O"("%additive, :pirop<bxor III>")
    unless $P10, rx2661_fail
    rx2661_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2661_pos = $P10."pos"()
  # rx pass
    rx2661_cur."!cursor_pass"(rx2661_pos, "infix:sym<+^>")
    if_null rx2661_debug, debug_1551
    rx2661_cur."!cursor_debug"("PASS", "infix:sym<+^>", " at pos=", rx2661_pos)
  debug_1551:
    .return (rx2661_cur)
  rx2661_restart:
.annotate 'line', 436
    if_null rx2661_debug, debug_1552
    rx2661_cur."!cursor_debug"("NEXT", "infix:sym<+^>")
  debug_1552:
  rx2661_fail:
    (rx2661_rep, rx2661_pos, $I10, $P10) = rx2661_cur."!mark_fail"(0)
    lt rx2661_pos, -1, rx2661_done
    eq rx2661_pos, -1, rx2661_fail
    jump $I10
  rx2661_done:
    rx2661_cur."!cursor_fail"()
    if_null rx2661_debug, debug_1553
    rx2661_cur."!cursor_debug"("FAIL", "infix:sym<+^>")
  debug_1553:
    .return (rx2661_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+^>"  :subid("358_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2665 = self."!PREFIX__!subrule"("O", "+^")
    new $P2666, "ResizablePMCArray"
    push $P2666, $P2665
    .return ($P2666)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~>"  :subid("359_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2668_tgt
    .local int rx2668_pos
    .local int rx2668_off
    .local int rx2668_eos
    .local int rx2668_rep
    .local pmc rx2668_cur
    .local pmc rx2668_debug
    (rx2668_cur, rx2668_pos, rx2668_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2668_cur
    .local pmc match
    .lex "$/", match
    length rx2668_eos, rx2668_tgt
    gt rx2668_pos, rx2668_eos, rx2668_done
    set rx2668_off, 0
    lt rx2668_pos, 2, rx2668_start
    sub rx2668_off, rx2668_pos, 1
    substr rx2668_tgt, rx2668_tgt, rx2668_off
  rx2668_start:
    eq $I10, 1, rx2668_restart
    if_null rx2668_debug, debug_1554
    rx2668_cur."!cursor_debug"("START", "infix:sym<~>")
  debug_1554:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2669_done
    goto rxscan2669_scan
  rxscan2669_loop:
    (rx2668_pos) = rx2668_cur."from"()
    inc rx2668_pos
    rx2668_cur."!cursor_from"(rx2668_pos)
    ge rx2668_pos, rx2668_eos, rxscan2669_done
  rxscan2669_scan:
    set_addr $I10, rxscan2669_loop
    rx2668_cur."!mark_push"(0, rx2668_pos, $I10)
  rxscan2669_done:
.annotate 'line', 1112
  # rx subcapture "sym"
    set_addr $I10, rxcap_2670_fail
    rx2668_cur."!mark_push"(0, rx2668_pos, $I10)
  # rx literal  "~"
    add $I11, rx2668_pos, 1
    gt $I11, rx2668_eos, rx2668_fail
    sub $I11, rx2668_pos, rx2668_off
    ord $I11, rx2668_tgt, $I11
    ne $I11, 126, rx2668_fail
    add rx2668_pos, 1
    set_addr $I10, rxcap_2670_fail
    ($I12, $I11) = rx2668_cur."!mark_peek"($I10)
    rx2668_cur."!cursor_pos"($I11)
    ($P10) = rx2668_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2668_pos, "")
    rx2668_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2670_done
  rxcap_2670_fail:
    goto rx2668_fail
  rxcap_2670_done:
  # rx subrule "O" subtype=capture negate=
    rx2668_cur."!cursor_pos"(rx2668_pos)
    $P10 = rx2668_cur."O"("%concatenation , :pirop<concat>")
    unless $P10, rx2668_fail
    rx2668_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2668_pos = $P10."pos"()
  # rx pass
    rx2668_cur."!cursor_pass"(rx2668_pos, "infix:sym<~>")
    if_null rx2668_debug, debug_1555
    rx2668_cur."!cursor_debug"("PASS", "infix:sym<~>", " at pos=", rx2668_pos)
  debug_1555:
    .return (rx2668_cur)
  rx2668_restart:
.annotate 'line', 436
    if_null rx2668_debug, debug_1556
    rx2668_cur."!cursor_debug"("NEXT", "infix:sym<~>")
  debug_1556:
  rx2668_fail:
    (rx2668_rep, rx2668_pos, $I10, $P10) = rx2668_cur."!mark_fail"(0)
    lt rx2668_pos, -1, rx2668_done
    eq rx2668_pos, -1, rx2668_fail
    jump $I10
  rx2668_done:
    rx2668_cur."!cursor_fail"()
    if_null rx2668_debug, debug_1557
    rx2668_cur."!cursor_debug"("FAIL", "infix:sym<~>")
  debug_1557:
    .return (rx2668_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~>"  :subid("360_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2672 = self."!PREFIX__!subrule"("O", "~")
    new $P2673, "ResizablePMCArray"
    push $P2673, $P2672
    .return ($P2673)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<==>"  :subid("361_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2675_tgt
    .local int rx2675_pos
    .local int rx2675_off
    .local int rx2675_eos
    .local int rx2675_rep
    .local pmc rx2675_cur
    .local pmc rx2675_debug
    (rx2675_cur, rx2675_pos, rx2675_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2675_cur
    .local pmc match
    .lex "$/", match
    length rx2675_eos, rx2675_tgt
    gt rx2675_pos, rx2675_eos, rx2675_done
    set rx2675_off, 0
    lt rx2675_pos, 2, rx2675_start
    sub rx2675_off, rx2675_pos, 1
    substr rx2675_tgt, rx2675_tgt, rx2675_off
  rx2675_start:
    eq $I10, 1, rx2675_restart
    if_null rx2675_debug, debug_1558
    rx2675_cur."!cursor_debug"("START", "infix:sym<==>")
  debug_1558:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2676_done
    goto rxscan2676_scan
  rxscan2676_loop:
    (rx2675_pos) = rx2675_cur."from"()
    inc rx2675_pos
    rx2675_cur."!cursor_from"(rx2675_pos)
    ge rx2675_pos, rx2675_eos, rxscan2676_done
  rxscan2676_scan:
    set_addr $I10, rxscan2676_loop
    rx2675_cur."!mark_push"(0, rx2675_pos, $I10)
  rxscan2676_done:
.annotate 'line', 1114
  # rx subcapture "sym"
    set_addr $I10, rxcap_2677_fail
    rx2675_cur."!mark_push"(0, rx2675_pos, $I10)
  # rx literal  "=="
    add $I11, rx2675_pos, 2
    gt $I11, rx2675_eos, rx2675_fail
    sub $I11, rx2675_pos, rx2675_off
    substr $S10, rx2675_tgt, $I11, 2
    ne $S10, "==", rx2675_fail
    add rx2675_pos, 2
    set_addr $I10, rxcap_2677_fail
    ($I12, $I11) = rx2675_cur."!mark_peek"($I10)
    rx2675_cur."!cursor_pos"($I11)
    ($P10) = rx2675_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2675_pos, "")
    rx2675_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2677_done
  rxcap_2677_fail:
    goto rx2675_fail
  rxcap_2677_done:
  # rx subrule "O" subtype=capture negate=
    rx2675_cur."!cursor_pos"(rx2675_pos)
    $P10 = rx2675_cur."O"("%relational, :pirop<iseq INn>")
    unless $P10, rx2675_fail
    rx2675_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2675_pos = $P10."pos"()
  # rx pass
    rx2675_cur."!cursor_pass"(rx2675_pos, "infix:sym<==>")
    if_null rx2675_debug, debug_1559
    rx2675_cur."!cursor_debug"("PASS", "infix:sym<==>", " at pos=", rx2675_pos)
  debug_1559:
    .return (rx2675_cur)
  rx2675_restart:
.annotate 'line', 436
    if_null rx2675_debug, debug_1560
    rx2675_cur."!cursor_debug"("NEXT", "infix:sym<==>")
  debug_1560:
  rx2675_fail:
    (rx2675_rep, rx2675_pos, $I10, $P10) = rx2675_cur."!mark_fail"(0)
    lt rx2675_pos, -1, rx2675_done
    eq rx2675_pos, -1, rx2675_fail
    jump $I10
  rx2675_done:
    rx2675_cur."!cursor_fail"()
    if_null rx2675_debug, debug_1561
    rx2675_cur."!cursor_debug"("FAIL", "infix:sym<==>")
  debug_1561:
    .return (rx2675_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<==>"  :subid("362_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2679 = self."!PREFIX__!subrule"("O", "==")
    new $P2680, "ResizablePMCArray"
    push $P2680, $P2679
    .return ($P2680)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<!=>"  :subid("363_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2682_tgt
    .local int rx2682_pos
    .local int rx2682_off
    .local int rx2682_eos
    .local int rx2682_rep
    .local pmc rx2682_cur
    .local pmc rx2682_debug
    (rx2682_cur, rx2682_pos, rx2682_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2682_cur
    .local pmc match
    .lex "$/", match
    length rx2682_eos, rx2682_tgt
    gt rx2682_pos, rx2682_eos, rx2682_done
    set rx2682_off, 0
    lt rx2682_pos, 2, rx2682_start
    sub rx2682_off, rx2682_pos, 1
    substr rx2682_tgt, rx2682_tgt, rx2682_off
  rx2682_start:
    eq $I10, 1, rx2682_restart
    if_null rx2682_debug, debug_1562
    rx2682_cur."!cursor_debug"("START", "infix:sym<!=>")
  debug_1562:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2683_done
    goto rxscan2683_scan
  rxscan2683_loop:
    (rx2682_pos) = rx2682_cur."from"()
    inc rx2682_pos
    rx2682_cur."!cursor_from"(rx2682_pos)
    ge rx2682_pos, rx2682_eos, rxscan2683_done
  rxscan2683_scan:
    set_addr $I10, rxscan2683_loop
    rx2682_cur."!mark_push"(0, rx2682_pos, $I10)
  rxscan2683_done:
.annotate 'line', 1115
  # rx subcapture "sym"
    set_addr $I10, rxcap_2684_fail
    rx2682_cur."!mark_push"(0, rx2682_pos, $I10)
  # rx literal  "!="
    add $I11, rx2682_pos, 2
    gt $I11, rx2682_eos, rx2682_fail
    sub $I11, rx2682_pos, rx2682_off
    substr $S10, rx2682_tgt, $I11, 2
    ne $S10, "!=", rx2682_fail
    add rx2682_pos, 2
    set_addr $I10, rxcap_2684_fail
    ($I12, $I11) = rx2682_cur."!mark_peek"($I10)
    rx2682_cur."!cursor_pos"($I11)
    ($P10) = rx2682_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2682_pos, "")
    rx2682_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2684_done
  rxcap_2684_fail:
    goto rx2682_fail
  rxcap_2684_done:
  # rx subrule "O" subtype=capture negate=
    rx2682_cur."!cursor_pos"(rx2682_pos)
    $P10 = rx2682_cur."O"("%relational, :pirop<isne INn>")
    unless $P10, rx2682_fail
    rx2682_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2682_pos = $P10."pos"()
  # rx pass
    rx2682_cur."!cursor_pass"(rx2682_pos, "infix:sym<!=>")
    if_null rx2682_debug, debug_1563
    rx2682_cur."!cursor_debug"("PASS", "infix:sym<!=>", " at pos=", rx2682_pos)
  debug_1563:
    .return (rx2682_cur)
  rx2682_restart:
.annotate 'line', 436
    if_null rx2682_debug, debug_1564
    rx2682_cur."!cursor_debug"("NEXT", "infix:sym<!=>")
  debug_1564:
  rx2682_fail:
    (rx2682_rep, rx2682_pos, $I10, $P10) = rx2682_cur."!mark_fail"(0)
    lt rx2682_pos, -1, rx2682_done
    eq rx2682_pos, -1, rx2682_fail
    jump $I10
  rx2682_done:
    rx2682_cur."!cursor_fail"()
    if_null rx2682_debug, debug_1565
    rx2682_cur."!cursor_debug"("FAIL", "infix:sym<!=>")
  debug_1565:
    .return (rx2682_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<!=>"  :subid("364_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2686 = self."!PREFIX__!subrule"("O", "!=")
    new $P2687, "ResizablePMCArray"
    push $P2687, $P2686
    .return ($P2687)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<=>"  :subid("365_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2689_tgt
    .local int rx2689_pos
    .local int rx2689_off
    .local int rx2689_eos
    .local int rx2689_rep
    .local pmc rx2689_cur
    .local pmc rx2689_debug
    (rx2689_cur, rx2689_pos, rx2689_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2689_cur
    .local pmc match
    .lex "$/", match
    length rx2689_eos, rx2689_tgt
    gt rx2689_pos, rx2689_eos, rx2689_done
    set rx2689_off, 0
    lt rx2689_pos, 2, rx2689_start
    sub rx2689_off, rx2689_pos, 1
    substr rx2689_tgt, rx2689_tgt, rx2689_off
  rx2689_start:
    eq $I10, 1, rx2689_restart
    if_null rx2689_debug, debug_1566
    rx2689_cur."!cursor_debug"("START", "infix:sym<<=>")
  debug_1566:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2690_done
    goto rxscan2690_scan
  rxscan2690_loop:
    (rx2689_pos) = rx2689_cur."from"()
    inc rx2689_pos
    rx2689_cur."!cursor_from"(rx2689_pos)
    ge rx2689_pos, rx2689_eos, rxscan2690_done
  rxscan2690_scan:
    set_addr $I10, rxscan2690_loop
    rx2689_cur."!mark_push"(0, rx2689_pos, $I10)
  rxscan2690_done:
.annotate 'line', 1116
  # rx subcapture "sym"
    set_addr $I10, rxcap_2691_fail
    rx2689_cur."!mark_push"(0, rx2689_pos, $I10)
  # rx literal  "<="
    add $I11, rx2689_pos, 2
    gt $I11, rx2689_eos, rx2689_fail
    sub $I11, rx2689_pos, rx2689_off
    substr $S10, rx2689_tgt, $I11, 2
    ne $S10, "<=", rx2689_fail
    add rx2689_pos, 2
    set_addr $I10, rxcap_2691_fail
    ($I12, $I11) = rx2689_cur."!mark_peek"($I10)
    rx2689_cur."!cursor_pos"($I11)
    ($P10) = rx2689_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2689_pos, "")
    rx2689_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2691_done
  rxcap_2691_fail:
    goto rx2689_fail
  rxcap_2691_done:
  # rx subrule "O" subtype=capture negate=
    rx2689_cur."!cursor_pos"(rx2689_pos)
    $P10 = rx2689_cur."O"("%relational, :pirop<isle INn>")
    unless $P10, rx2689_fail
    rx2689_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2689_pos = $P10."pos"()
  # rx pass
    rx2689_cur."!cursor_pass"(rx2689_pos, "infix:sym<<=>")
    if_null rx2689_debug, debug_1567
    rx2689_cur."!cursor_debug"("PASS", "infix:sym<<=>", " at pos=", rx2689_pos)
  debug_1567:
    .return (rx2689_cur)
  rx2689_restart:
.annotate 'line', 436
    if_null rx2689_debug, debug_1568
    rx2689_cur."!cursor_debug"("NEXT", "infix:sym<<=>")
  debug_1568:
  rx2689_fail:
    (rx2689_rep, rx2689_pos, $I10, $P10) = rx2689_cur."!mark_fail"(0)
    lt rx2689_pos, -1, rx2689_done
    eq rx2689_pos, -1, rx2689_fail
    jump $I10
  rx2689_done:
    rx2689_cur."!cursor_fail"()
    if_null rx2689_debug, debug_1569
    rx2689_cur."!cursor_debug"("FAIL", "infix:sym<<=>")
  debug_1569:
    .return (rx2689_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<=>"  :subid("366_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2693 = self."!PREFIX__!subrule"("O", "<=")
    new $P2694, "ResizablePMCArray"
    push $P2694, $P2693
    .return ($P2694)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>=>"  :subid("367_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2696_tgt
    .local int rx2696_pos
    .local int rx2696_off
    .local int rx2696_eos
    .local int rx2696_rep
    .local pmc rx2696_cur
    .local pmc rx2696_debug
    (rx2696_cur, rx2696_pos, rx2696_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2696_cur
    .local pmc match
    .lex "$/", match
    length rx2696_eos, rx2696_tgt
    gt rx2696_pos, rx2696_eos, rx2696_done
    set rx2696_off, 0
    lt rx2696_pos, 2, rx2696_start
    sub rx2696_off, rx2696_pos, 1
    substr rx2696_tgt, rx2696_tgt, rx2696_off
  rx2696_start:
    eq $I10, 1, rx2696_restart
    if_null rx2696_debug, debug_1570
    rx2696_cur."!cursor_debug"("START", "infix:sym<>=>")
  debug_1570:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2697_done
    goto rxscan2697_scan
  rxscan2697_loop:
    (rx2696_pos) = rx2696_cur."from"()
    inc rx2696_pos
    rx2696_cur."!cursor_from"(rx2696_pos)
    ge rx2696_pos, rx2696_eos, rxscan2697_done
  rxscan2697_scan:
    set_addr $I10, rxscan2697_loop
    rx2696_cur."!mark_push"(0, rx2696_pos, $I10)
  rxscan2697_done:
.annotate 'line', 1117
  # rx subcapture "sym"
    set_addr $I10, rxcap_2698_fail
    rx2696_cur."!mark_push"(0, rx2696_pos, $I10)
  # rx literal  ">="
    add $I11, rx2696_pos, 2
    gt $I11, rx2696_eos, rx2696_fail
    sub $I11, rx2696_pos, rx2696_off
    substr $S10, rx2696_tgt, $I11, 2
    ne $S10, ">=", rx2696_fail
    add rx2696_pos, 2
    set_addr $I10, rxcap_2698_fail
    ($I12, $I11) = rx2696_cur."!mark_peek"($I10)
    rx2696_cur."!cursor_pos"($I11)
    ($P10) = rx2696_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2696_pos, "")
    rx2696_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2698_done
  rxcap_2698_fail:
    goto rx2696_fail
  rxcap_2698_done:
  # rx subrule "O" subtype=capture negate=
    rx2696_cur."!cursor_pos"(rx2696_pos)
    $P10 = rx2696_cur."O"("%relational, :pirop<isge INn>")
    unless $P10, rx2696_fail
    rx2696_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2696_pos = $P10."pos"()
  # rx pass
    rx2696_cur."!cursor_pass"(rx2696_pos, "infix:sym<>=>")
    if_null rx2696_debug, debug_1571
    rx2696_cur."!cursor_debug"("PASS", "infix:sym<>=>", " at pos=", rx2696_pos)
  debug_1571:
    .return (rx2696_cur)
  rx2696_restart:
.annotate 'line', 436
    if_null rx2696_debug, debug_1572
    rx2696_cur."!cursor_debug"("NEXT", "infix:sym<>=>")
  debug_1572:
  rx2696_fail:
    (rx2696_rep, rx2696_pos, $I10, $P10) = rx2696_cur."!mark_fail"(0)
    lt rx2696_pos, -1, rx2696_done
    eq rx2696_pos, -1, rx2696_fail
    jump $I10
  rx2696_done:
    rx2696_cur."!cursor_fail"()
    if_null rx2696_debug, debug_1573
    rx2696_cur."!cursor_debug"("FAIL", "infix:sym<>=>")
  debug_1573:
    .return (rx2696_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>=>"  :subid("368_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2700 = self."!PREFIX__!subrule"("O", ">=")
    new $P2701, "ResizablePMCArray"
    push $P2701, $P2700
    .return ($P2701)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<>"  :subid("369_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2703_tgt
    .local int rx2703_pos
    .local int rx2703_off
    .local int rx2703_eos
    .local int rx2703_rep
    .local pmc rx2703_cur
    .local pmc rx2703_debug
    (rx2703_cur, rx2703_pos, rx2703_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2703_cur
    .local pmc match
    .lex "$/", match
    length rx2703_eos, rx2703_tgt
    gt rx2703_pos, rx2703_eos, rx2703_done
    set rx2703_off, 0
    lt rx2703_pos, 2, rx2703_start
    sub rx2703_off, rx2703_pos, 1
    substr rx2703_tgt, rx2703_tgt, rx2703_off
  rx2703_start:
    eq $I10, 1, rx2703_restart
    if_null rx2703_debug, debug_1574
    rx2703_cur."!cursor_debug"("START", "infix:sym<<>")
  debug_1574:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2704_done
    goto rxscan2704_scan
  rxscan2704_loop:
    (rx2703_pos) = rx2703_cur."from"()
    inc rx2703_pos
    rx2703_cur."!cursor_from"(rx2703_pos)
    ge rx2703_pos, rx2703_eos, rxscan2704_done
  rxscan2704_scan:
    set_addr $I10, rxscan2704_loop
    rx2703_cur."!mark_push"(0, rx2703_pos, $I10)
  rxscan2704_done:
.annotate 'line', 1118
  # rx subcapture "sym"
    set_addr $I10, rxcap_2705_fail
    rx2703_cur."!mark_push"(0, rx2703_pos, $I10)
  # rx literal  "<"
    add $I11, rx2703_pos, 1
    gt $I11, rx2703_eos, rx2703_fail
    sub $I11, rx2703_pos, rx2703_off
    ord $I11, rx2703_tgt, $I11
    ne $I11, 60, rx2703_fail
    add rx2703_pos, 1
    set_addr $I10, rxcap_2705_fail
    ($I12, $I11) = rx2703_cur."!mark_peek"($I10)
    rx2703_cur."!cursor_pos"($I11)
    ($P10) = rx2703_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2703_pos, "")
    rx2703_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2705_done
  rxcap_2705_fail:
    goto rx2703_fail
  rxcap_2705_done:
  # rx subrule "O" subtype=capture negate=
    rx2703_cur."!cursor_pos"(rx2703_pos)
    $P10 = rx2703_cur."O"("%relational, :pirop<islt INn>")
    unless $P10, rx2703_fail
    rx2703_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2703_pos = $P10."pos"()
  # rx pass
    rx2703_cur."!cursor_pass"(rx2703_pos, "infix:sym<<>")
    if_null rx2703_debug, debug_1575
    rx2703_cur."!cursor_debug"("PASS", "infix:sym<<>", " at pos=", rx2703_pos)
  debug_1575:
    .return (rx2703_cur)
  rx2703_restart:
.annotate 'line', 436
    if_null rx2703_debug, debug_1576
    rx2703_cur."!cursor_debug"("NEXT", "infix:sym<<>")
  debug_1576:
  rx2703_fail:
    (rx2703_rep, rx2703_pos, $I10, $P10) = rx2703_cur."!mark_fail"(0)
    lt rx2703_pos, -1, rx2703_done
    eq rx2703_pos, -1, rx2703_fail
    jump $I10
  rx2703_done:
    rx2703_cur."!cursor_fail"()
    if_null rx2703_debug, debug_1577
    rx2703_cur."!cursor_debug"("FAIL", "infix:sym<<>")
  debug_1577:
    .return (rx2703_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<>"  :subid("370_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2707 = self."!PREFIX__!subrule"("O", "<")
    new $P2708, "ResizablePMCArray"
    push $P2708, $P2707
    .return ($P2708)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>>"  :subid("371_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2710_tgt
    .local int rx2710_pos
    .local int rx2710_off
    .local int rx2710_eos
    .local int rx2710_rep
    .local pmc rx2710_cur
    .local pmc rx2710_debug
    (rx2710_cur, rx2710_pos, rx2710_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2710_cur
    .local pmc match
    .lex "$/", match
    length rx2710_eos, rx2710_tgt
    gt rx2710_pos, rx2710_eos, rx2710_done
    set rx2710_off, 0
    lt rx2710_pos, 2, rx2710_start
    sub rx2710_off, rx2710_pos, 1
    substr rx2710_tgt, rx2710_tgt, rx2710_off
  rx2710_start:
    eq $I10, 1, rx2710_restart
    if_null rx2710_debug, debug_1578
    rx2710_cur."!cursor_debug"("START", "infix:sym<>>")
  debug_1578:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2711_done
    goto rxscan2711_scan
  rxscan2711_loop:
    (rx2710_pos) = rx2710_cur."from"()
    inc rx2710_pos
    rx2710_cur."!cursor_from"(rx2710_pos)
    ge rx2710_pos, rx2710_eos, rxscan2711_done
  rxscan2711_scan:
    set_addr $I10, rxscan2711_loop
    rx2710_cur."!mark_push"(0, rx2710_pos, $I10)
  rxscan2711_done:
.annotate 'line', 1119
  # rx subcapture "sym"
    set_addr $I10, rxcap_2712_fail
    rx2710_cur."!mark_push"(0, rx2710_pos, $I10)
  # rx literal  ">"
    add $I11, rx2710_pos, 1
    gt $I11, rx2710_eos, rx2710_fail
    sub $I11, rx2710_pos, rx2710_off
    ord $I11, rx2710_tgt, $I11
    ne $I11, 62, rx2710_fail
    add rx2710_pos, 1
    set_addr $I10, rxcap_2712_fail
    ($I12, $I11) = rx2710_cur."!mark_peek"($I10)
    rx2710_cur."!cursor_pos"($I11)
    ($P10) = rx2710_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2710_pos, "")
    rx2710_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2712_done
  rxcap_2712_fail:
    goto rx2710_fail
  rxcap_2712_done:
  # rx subrule "O" subtype=capture negate=
    rx2710_cur."!cursor_pos"(rx2710_pos)
    $P10 = rx2710_cur."O"("%relational, :pirop<isgt INn>")
    unless $P10, rx2710_fail
    rx2710_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2710_pos = $P10."pos"()
  # rx pass
    rx2710_cur."!cursor_pass"(rx2710_pos, "infix:sym<>>")
    if_null rx2710_debug, debug_1579
    rx2710_cur."!cursor_debug"("PASS", "infix:sym<>>", " at pos=", rx2710_pos)
  debug_1579:
    .return (rx2710_cur)
  rx2710_restart:
.annotate 'line', 436
    if_null rx2710_debug, debug_1580
    rx2710_cur."!cursor_debug"("NEXT", "infix:sym<>>")
  debug_1580:
  rx2710_fail:
    (rx2710_rep, rx2710_pos, $I10, $P10) = rx2710_cur."!mark_fail"(0)
    lt rx2710_pos, -1, rx2710_done
    eq rx2710_pos, -1, rx2710_fail
    jump $I10
  rx2710_done:
    rx2710_cur."!cursor_fail"()
    if_null rx2710_debug, debug_1581
    rx2710_cur."!cursor_debug"("FAIL", "infix:sym<>>")
  debug_1581:
    .return (rx2710_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>>"  :subid("372_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2714 = self."!PREFIX__!subrule"("O", ">")
    new $P2715, "ResizablePMCArray"
    push $P2715, $P2714
    .return ($P2715)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<eq>"  :subid("373_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2717_tgt
    .local int rx2717_pos
    .local int rx2717_off
    .local int rx2717_eos
    .local int rx2717_rep
    .local pmc rx2717_cur
    .local pmc rx2717_debug
    (rx2717_cur, rx2717_pos, rx2717_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2717_cur
    .local pmc match
    .lex "$/", match
    length rx2717_eos, rx2717_tgt
    gt rx2717_pos, rx2717_eos, rx2717_done
    set rx2717_off, 0
    lt rx2717_pos, 2, rx2717_start
    sub rx2717_off, rx2717_pos, 1
    substr rx2717_tgt, rx2717_tgt, rx2717_off
  rx2717_start:
    eq $I10, 1, rx2717_restart
    if_null rx2717_debug, debug_1582
    rx2717_cur."!cursor_debug"("START", "infix:sym<eq>")
  debug_1582:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2718_done
    goto rxscan2718_scan
  rxscan2718_loop:
    (rx2717_pos) = rx2717_cur."from"()
    inc rx2717_pos
    rx2717_cur."!cursor_from"(rx2717_pos)
    ge rx2717_pos, rx2717_eos, rxscan2718_done
  rxscan2718_scan:
    set_addr $I10, rxscan2718_loop
    rx2717_cur."!mark_push"(0, rx2717_pos, $I10)
  rxscan2718_done:
.annotate 'line', 1120
  # rx subcapture "sym"
    set_addr $I10, rxcap_2719_fail
    rx2717_cur."!mark_push"(0, rx2717_pos, $I10)
  # rx literal  "eq"
    add $I11, rx2717_pos, 2
    gt $I11, rx2717_eos, rx2717_fail
    sub $I11, rx2717_pos, rx2717_off
    substr $S10, rx2717_tgt, $I11, 2
    ne $S10, "eq", rx2717_fail
    add rx2717_pos, 2
    set_addr $I10, rxcap_2719_fail
    ($I12, $I11) = rx2717_cur."!mark_peek"($I10)
    rx2717_cur."!cursor_pos"($I11)
    ($P10) = rx2717_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2717_pos, "")
    rx2717_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2719_done
  rxcap_2719_fail:
    goto rx2717_fail
  rxcap_2719_done:
  # rx subrule "O" subtype=capture negate=
    rx2717_cur."!cursor_pos"(rx2717_pos)
    $P10 = rx2717_cur."O"("%relational, :pirop<iseq ISs>")
    unless $P10, rx2717_fail
    rx2717_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2717_pos = $P10."pos"()
  # rx pass
    rx2717_cur."!cursor_pass"(rx2717_pos, "infix:sym<eq>")
    if_null rx2717_debug, debug_1583
    rx2717_cur."!cursor_debug"("PASS", "infix:sym<eq>", " at pos=", rx2717_pos)
  debug_1583:
    .return (rx2717_cur)
  rx2717_restart:
.annotate 'line', 436
    if_null rx2717_debug, debug_1584
    rx2717_cur."!cursor_debug"("NEXT", "infix:sym<eq>")
  debug_1584:
  rx2717_fail:
    (rx2717_rep, rx2717_pos, $I10, $P10) = rx2717_cur."!mark_fail"(0)
    lt rx2717_pos, -1, rx2717_done
    eq rx2717_pos, -1, rx2717_fail
    jump $I10
  rx2717_done:
    rx2717_cur."!cursor_fail"()
    if_null rx2717_debug, debug_1585
    rx2717_cur."!cursor_debug"("FAIL", "infix:sym<eq>")
  debug_1585:
    .return (rx2717_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<eq>"  :subid("374_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2721 = self."!PREFIX__!subrule"("O", "eq")
    new $P2722, "ResizablePMCArray"
    push $P2722, $P2721
    .return ($P2722)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ne>"  :subid("375_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2724_tgt
    .local int rx2724_pos
    .local int rx2724_off
    .local int rx2724_eos
    .local int rx2724_rep
    .local pmc rx2724_cur
    .local pmc rx2724_debug
    (rx2724_cur, rx2724_pos, rx2724_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2724_cur
    .local pmc match
    .lex "$/", match
    length rx2724_eos, rx2724_tgt
    gt rx2724_pos, rx2724_eos, rx2724_done
    set rx2724_off, 0
    lt rx2724_pos, 2, rx2724_start
    sub rx2724_off, rx2724_pos, 1
    substr rx2724_tgt, rx2724_tgt, rx2724_off
  rx2724_start:
    eq $I10, 1, rx2724_restart
    if_null rx2724_debug, debug_1586
    rx2724_cur."!cursor_debug"("START", "infix:sym<ne>")
  debug_1586:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2725_done
    goto rxscan2725_scan
  rxscan2725_loop:
    (rx2724_pos) = rx2724_cur."from"()
    inc rx2724_pos
    rx2724_cur."!cursor_from"(rx2724_pos)
    ge rx2724_pos, rx2724_eos, rxscan2725_done
  rxscan2725_scan:
    set_addr $I10, rxscan2725_loop
    rx2724_cur."!mark_push"(0, rx2724_pos, $I10)
  rxscan2725_done:
.annotate 'line', 1121
  # rx subcapture "sym"
    set_addr $I10, rxcap_2726_fail
    rx2724_cur."!mark_push"(0, rx2724_pos, $I10)
  # rx literal  "ne"
    add $I11, rx2724_pos, 2
    gt $I11, rx2724_eos, rx2724_fail
    sub $I11, rx2724_pos, rx2724_off
    substr $S10, rx2724_tgt, $I11, 2
    ne $S10, "ne", rx2724_fail
    add rx2724_pos, 2
    set_addr $I10, rxcap_2726_fail
    ($I12, $I11) = rx2724_cur."!mark_peek"($I10)
    rx2724_cur."!cursor_pos"($I11)
    ($P10) = rx2724_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2724_pos, "")
    rx2724_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2726_done
  rxcap_2726_fail:
    goto rx2724_fail
  rxcap_2726_done:
  # rx subrule "O" subtype=capture negate=
    rx2724_cur."!cursor_pos"(rx2724_pos)
    $P10 = rx2724_cur."O"("%relational, :pirop<isne ISs>")
    unless $P10, rx2724_fail
    rx2724_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2724_pos = $P10."pos"()
  # rx pass
    rx2724_cur."!cursor_pass"(rx2724_pos, "infix:sym<ne>")
    if_null rx2724_debug, debug_1587
    rx2724_cur."!cursor_debug"("PASS", "infix:sym<ne>", " at pos=", rx2724_pos)
  debug_1587:
    .return (rx2724_cur)
  rx2724_restart:
.annotate 'line', 436
    if_null rx2724_debug, debug_1588
    rx2724_cur."!cursor_debug"("NEXT", "infix:sym<ne>")
  debug_1588:
  rx2724_fail:
    (rx2724_rep, rx2724_pos, $I10, $P10) = rx2724_cur."!mark_fail"(0)
    lt rx2724_pos, -1, rx2724_done
    eq rx2724_pos, -1, rx2724_fail
    jump $I10
  rx2724_done:
    rx2724_cur."!cursor_fail"()
    if_null rx2724_debug, debug_1589
    rx2724_cur."!cursor_debug"("FAIL", "infix:sym<ne>")
  debug_1589:
    .return (rx2724_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ne>"  :subid("376_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2728 = self."!PREFIX__!subrule"("O", "ne")
    new $P2729, "ResizablePMCArray"
    push $P2729, $P2728
    .return ($P2729)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<le>"  :subid("377_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2731_tgt
    .local int rx2731_pos
    .local int rx2731_off
    .local int rx2731_eos
    .local int rx2731_rep
    .local pmc rx2731_cur
    .local pmc rx2731_debug
    (rx2731_cur, rx2731_pos, rx2731_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2731_cur
    .local pmc match
    .lex "$/", match
    length rx2731_eos, rx2731_tgt
    gt rx2731_pos, rx2731_eos, rx2731_done
    set rx2731_off, 0
    lt rx2731_pos, 2, rx2731_start
    sub rx2731_off, rx2731_pos, 1
    substr rx2731_tgt, rx2731_tgt, rx2731_off
  rx2731_start:
    eq $I10, 1, rx2731_restart
    if_null rx2731_debug, debug_1590
    rx2731_cur."!cursor_debug"("START", "infix:sym<le>")
  debug_1590:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2732_done
    goto rxscan2732_scan
  rxscan2732_loop:
    (rx2731_pos) = rx2731_cur."from"()
    inc rx2731_pos
    rx2731_cur."!cursor_from"(rx2731_pos)
    ge rx2731_pos, rx2731_eos, rxscan2732_done
  rxscan2732_scan:
    set_addr $I10, rxscan2732_loop
    rx2731_cur."!mark_push"(0, rx2731_pos, $I10)
  rxscan2732_done:
.annotate 'line', 1122
  # rx subcapture "sym"
    set_addr $I10, rxcap_2733_fail
    rx2731_cur."!mark_push"(0, rx2731_pos, $I10)
  # rx literal  "le"
    add $I11, rx2731_pos, 2
    gt $I11, rx2731_eos, rx2731_fail
    sub $I11, rx2731_pos, rx2731_off
    substr $S10, rx2731_tgt, $I11, 2
    ne $S10, "le", rx2731_fail
    add rx2731_pos, 2
    set_addr $I10, rxcap_2733_fail
    ($I12, $I11) = rx2731_cur."!mark_peek"($I10)
    rx2731_cur."!cursor_pos"($I11)
    ($P10) = rx2731_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2731_pos, "")
    rx2731_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2733_done
  rxcap_2733_fail:
    goto rx2731_fail
  rxcap_2733_done:
  # rx subrule "O" subtype=capture negate=
    rx2731_cur."!cursor_pos"(rx2731_pos)
    $P10 = rx2731_cur."O"("%relational, :pirop<isle ISs>")
    unless $P10, rx2731_fail
    rx2731_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2731_pos = $P10."pos"()
  # rx pass
    rx2731_cur."!cursor_pass"(rx2731_pos, "infix:sym<le>")
    if_null rx2731_debug, debug_1591
    rx2731_cur."!cursor_debug"("PASS", "infix:sym<le>", " at pos=", rx2731_pos)
  debug_1591:
    .return (rx2731_cur)
  rx2731_restart:
.annotate 'line', 436
    if_null rx2731_debug, debug_1592
    rx2731_cur."!cursor_debug"("NEXT", "infix:sym<le>")
  debug_1592:
  rx2731_fail:
    (rx2731_rep, rx2731_pos, $I10, $P10) = rx2731_cur."!mark_fail"(0)
    lt rx2731_pos, -1, rx2731_done
    eq rx2731_pos, -1, rx2731_fail
    jump $I10
  rx2731_done:
    rx2731_cur."!cursor_fail"()
    if_null rx2731_debug, debug_1593
    rx2731_cur."!cursor_debug"("FAIL", "infix:sym<le>")
  debug_1593:
    .return (rx2731_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<le>"  :subid("378_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2735 = self."!PREFIX__!subrule"("O", "le")
    new $P2736, "ResizablePMCArray"
    push $P2736, $P2735
    .return ($P2736)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ge>"  :subid("379_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2738_tgt
    .local int rx2738_pos
    .local int rx2738_off
    .local int rx2738_eos
    .local int rx2738_rep
    .local pmc rx2738_cur
    .local pmc rx2738_debug
    (rx2738_cur, rx2738_pos, rx2738_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2738_cur
    .local pmc match
    .lex "$/", match
    length rx2738_eos, rx2738_tgt
    gt rx2738_pos, rx2738_eos, rx2738_done
    set rx2738_off, 0
    lt rx2738_pos, 2, rx2738_start
    sub rx2738_off, rx2738_pos, 1
    substr rx2738_tgt, rx2738_tgt, rx2738_off
  rx2738_start:
    eq $I10, 1, rx2738_restart
    if_null rx2738_debug, debug_1594
    rx2738_cur."!cursor_debug"("START", "infix:sym<ge>")
  debug_1594:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2739_done
    goto rxscan2739_scan
  rxscan2739_loop:
    (rx2738_pos) = rx2738_cur."from"()
    inc rx2738_pos
    rx2738_cur."!cursor_from"(rx2738_pos)
    ge rx2738_pos, rx2738_eos, rxscan2739_done
  rxscan2739_scan:
    set_addr $I10, rxscan2739_loop
    rx2738_cur."!mark_push"(0, rx2738_pos, $I10)
  rxscan2739_done:
.annotate 'line', 1123
  # rx subcapture "sym"
    set_addr $I10, rxcap_2740_fail
    rx2738_cur."!mark_push"(0, rx2738_pos, $I10)
  # rx literal  "ge"
    add $I11, rx2738_pos, 2
    gt $I11, rx2738_eos, rx2738_fail
    sub $I11, rx2738_pos, rx2738_off
    substr $S10, rx2738_tgt, $I11, 2
    ne $S10, "ge", rx2738_fail
    add rx2738_pos, 2
    set_addr $I10, rxcap_2740_fail
    ($I12, $I11) = rx2738_cur."!mark_peek"($I10)
    rx2738_cur."!cursor_pos"($I11)
    ($P10) = rx2738_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2738_pos, "")
    rx2738_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2740_done
  rxcap_2740_fail:
    goto rx2738_fail
  rxcap_2740_done:
  # rx subrule "O" subtype=capture negate=
    rx2738_cur."!cursor_pos"(rx2738_pos)
    $P10 = rx2738_cur."O"("%relational, :pirop<isge ISs>")
    unless $P10, rx2738_fail
    rx2738_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2738_pos = $P10."pos"()
  # rx pass
    rx2738_cur."!cursor_pass"(rx2738_pos, "infix:sym<ge>")
    if_null rx2738_debug, debug_1595
    rx2738_cur."!cursor_debug"("PASS", "infix:sym<ge>", " at pos=", rx2738_pos)
  debug_1595:
    .return (rx2738_cur)
  rx2738_restart:
.annotate 'line', 436
    if_null rx2738_debug, debug_1596
    rx2738_cur."!cursor_debug"("NEXT", "infix:sym<ge>")
  debug_1596:
  rx2738_fail:
    (rx2738_rep, rx2738_pos, $I10, $P10) = rx2738_cur."!mark_fail"(0)
    lt rx2738_pos, -1, rx2738_done
    eq rx2738_pos, -1, rx2738_fail
    jump $I10
  rx2738_done:
    rx2738_cur."!cursor_fail"()
    if_null rx2738_debug, debug_1597
    rx2738_cur."!cursor_debug"("FAIL", "infix:sym<ge>")
  debug_1597:
    .return (rx2738_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ge>"  :subid("380_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2742 = self."!PREFIX__!subrule"("O", "ge")
    new $P2743, "ResizablePMCArray"
    push $P2743, $P2742
    .return ($P2743)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<lt>"  :subid("381_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2745_tgt
    .local int rx2745_pos
    .local int rx2745_off
    .local int rx2745_eos
    .local int rx2745_rep
    .local pmc rx2745_cur
    .local pmc rx2745_debug
    (rx2745_cur, rx2745_pos, rx2745_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2745_cur
    .local pmc match
    .lex "$/", match
    length rx2745_eos, rx2745_tgt
    gt rx2745_pos, rx2745_eos, rx2745_done
    set rx2745_off, 0
    lt rx2745_pos, 2, rx2745_start
    sub rx2745_off, rx2745_pos, 1
    substr rx2745_tgt, rx2745_tgt, rx2745_off
  rx2745_start:
    eq $I10, 1, rx2745_restart
    if_null rx2745_debug, debug_1598
    rx2745_cur."!cursor_debug"("START", "infix:sym<lt>")
  debug_1598:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2746_done
    goto rxscan2746_scan
  rxscan2746_loop:
    (rx2745_pos) = rx2745_cur."from"()
    inc rx2745_pos
    rx2745_cur."!cursor_from"(rx2745_pos)
    ge rx2745_pos, rx2745_eos, rxscan2746_done
  rxscan2746_scan:
    set_addr $I10, rxscan2746_loop
    rx2745_cur."!mark_push"(0, rx2745_pos, $I10)
  rxscan2746_done:
.annotate 'line', 1124
  # rx subcapture "sym"
    set_addr $I10, rxcap_2747_fail
    rx2745_cur."!mark_push"(0, rx2745_pos, $I10)
  # rx literal  "lt"
    add $I11, rx2745_pos, 2
    gt $I11, rx2745_eos, rx2745_fail
    sub $I11, rx2745_pos, rx2745_off
    substr $S10, rx2745_tgt, $I11, 2
    ne $S10, "lt", rx2745_fail
    add rx2745_pos, 2
    set_addr $I10, rxcap_2747_fail
    ($I12, $I11) = rx2745_cur."!mark_peek"($I10)
    rx2745_cur."!cursor_pos"($I11)
    ($P10) = rx2745_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2745_pos, "")
    rx2745_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2747_done
  rxcap_2747_fail:
    goto rx2745_fail
  rxcap_2747_done:
  # rx subrule "O" subtype=capture negate=
    rx2745_cur."!cursor_pos"(rx2745_pos)
    $P10 = rx2745_cur."O"("%relational, :pirop<islt ISs>")
    unless $P10, rx2745_fail
    rx2745_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2745_pos = $P10."pos"()
  # rx pass
    rx2745_cur."!cursor_pass"(rx2745_pos, "infix:sym<lt>")
    if_null rx2745_debug, debug_1599
    rx2745_cur."!cursor_debug"("PASS", "infix:sym<lt>", " at pos=", rx2745_pos)
  debug_1599:
    .return (rx2745_cur)
  rx2745_restart:
.annotate 'line', 436
    if_null rx2745_debug, debug_1600
    rx2745_cur."!cursor_debug"("NEXT", "infix:sym<lt>")
  debug_1600:
  rx2745_fail:
    (rx2745_rep, rx2745_pos, $I10, $P10) = rx2745_cur."!mark_fail"(0)
    lt rx2745_pos, -1, rx2745_done
    eq rx2745_pos, -1, rx2745_fail
    jump $I10
  rx2745_done:
    rx2745_cur."!cursor_fail"()
    if_null rx2745_debug, debug_1601
    rx2745_cur."!cursor_debug"("FAIL", "infix:sym<lt>")
  debug_1601:
    .return (rx2745_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<lt>"  :subid("382_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2749 = self."!PREFIX__!subrule"("O", "lt")
    new $P2750, "ResizablePMCArray"
    push $P2750, $P2749
    .return ($P2750)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<gt>"  :subid("383_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2752_tgt
    .local int rx2752_pos
    .local int rx2752_off
    .local int rx2752_eos
    .local int rx2752_rep
    .local pmc rx2752_cur
    .local pmc rx2752_debug
    (rx2752_cur, rx2752_pos, rx2752_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2752_cur
    .local pmc match
    .lex "$/", match
    length rx2752_eos, rx2752_tgt
    gt rx2752_pos, rx2752_eos, rx2752_done
    set rx2752_off, 0
    lt rx2752_pos, 2, rx2752_start
    sub rx2752_off, rx2752_pos, 1
    substr rx2752_tgt, rx2752_tgt, rx2752_off
  rx2752_start:
    eq $I10, 1, rx2752_restart
    if_null rx2752_debug, debug_1602
    rx2752_cur."!cursor_debug"("START", "infix:sym<gt>")
  debug_1602:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2753_done
    goto rxscan2753_scan
  rxscan2753_loop:
    (rx2752_pos) = rx2752_cur."from"()
    inc rx2752_pos
    rx2752_cur."!cursor_from"(rx2752_pos)
    ge rx2752_pos, rx2752_eos, rxscan2753_done
  rxscan2753_scan:
    set_addr $I10, rxscan2753_loop
    rx2752_cur."!mark_push"(0, rx2752_pos, $I10)
  rxscan2753_done:
.annotate 'line', 1125
  # rx subcapture "sym"
    set_addr $I10, rxcap_2754_fail
    rx2752_cur."!mark_push"(0, rx2752_pos, $I10)
  # rx literal  "gt"
    add $I11, rx2752_pos, 2
    gt $I11, rx2752_eos, rx2752_fail
    sub $I11, rx2752_pos, rx2752_off
    substr $S10, rx2752_tgt, $I11, 2
    ne $S10, "gt", rx2752_fail
    add rx2752_pos, 2
    set_addr $I10, rxcap_2754_fail
    ($I12, $I11) = rx2752_cur."!mark_peek"($I10)
    rx2752_cur."!cursor_pos"($I11)
    ($P10) = rx2752_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2752_pos, "")
    rx2752_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2754_done
  rxcap_2754_fail:
    goto rx2752_fail
  rxcap_2754_done:
  # rx subrule "O" subtype=capture negate=
    rx2752_cur."!cursor_pos"(rx2752_pos)
    $P10 = rx2752_cur."O"("%relational, :pirop<isgt ISs>")
    unless $P10, rx2752_fail
    rx2752_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2752_pos = $P10."pos"()
  # rx pass
    rx2752_cur."!cursor_pass"(rx2752_pos, "infix:sym<gt>")
    if_null rx2752_debug, debug_1603
    rx2752_cur."!cursor_debug"("PASS", "infix:sym<gt>", " at pos=", rx2752_pos)
  debug_1603:
    .return (rx2752_cur)
  rx2752_restart:
.annotate 'line', 436
    if_null rx2752_debug, debug_1604
    rx2752_cur."!cursor_debug"("NEXT", "infix:sym<gt>")
  debug_1604:
  rx2752_fail:
    (rx2752_rep, rx2752_pos, $I10, $P10) = rx2752_cur."!mark_fail"(0)
    lt rx2752_pos, -1, rx2752_done
    eq rx2752_pos, -1, rx2752_fail
    jump $I10
  rx2752_done:
    rx2752_cur."!cursor_fail"()
    if_null rx2752_debug, debug_1605
    rx2752_cur."!cursor_debug"("FAIL", "infix:sym<gt>")
  debug_1605:
    .return (rx2752_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<gt>"  :subid("384_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2756 = self."!PREFIX__!subrule"("O", "gt")
    new $P2757, "ResizablePMCArray"
    push $P2757, $P2756
    .return ($P2757)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=:=>"  :subid("385_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2759_tgt
    .local int rx2759_pos
    .local int rx2759_off
    .local int rx2759_eos
    .local int rx2759_rep
    .local pmc rx2759_cur
    .local pmc rx2759_debug
    (rx2759_cur, rx2759_pos, rx2759_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2759_cur
    .local pmc match
    .lex "$/", match
    length rx2759_eos, rx2759_tgt
    gt rx2759_pos, rx2759_eos, rx2759_done
    set rx2759_off, 0
    lt rx2759_pos, 2, rx2759_start
    sub rx2759_off, rx2759_pos, 1
    substr rx2759_tgt, rx2759_tgt, rx2759_off
  rx2759_start:
    eq $I10, 1, rx2759_restart
    if_null rx2759_debug, debug_1606
    rx2759_cur."!cursor_debug"("START", "infix:sym<=:=>")
  debug_1606:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2760_done
    goto rxscan2760_scan
  rxscan2760_loop:
    (rx2759_pos) = rx2759_cur."from"()
    inc rx2759_pos
    rx2759_cur."!cursor_from"(rx2759_pos)
    ge rx2759_pos, rx2759_eos, rxscan2760_done
  rxscan2760_scan:
    set_addr $I10, rxscan2760_loop
    rx2759_cur."!mark_push"(0, rx2759_pos, $I10)
  rxscan2760_done:
.annotate 'line', 1126
  # rx subcapture "sym"
    set_addr $I10, rxcap_2761_fail
    rx2759_cur."!mark_push"(0, rx2759_pos, $I10)
  # rx literal  "=:="
    add $I11, rx2759_pos, 3
    gt $I11, rx2759_eos, rx2759_fail
    sub $I11, rx2759_pos, rx2759_off
    substr $S10, rx2759_tgt, $I11, 3
    ne $S10, "=:=", rx2759_fail
    add rx2759_pos, 3
    set_addr $I10, rxcap_2761_fail
    ($I12, $I11) = rx2759_cur."!mark_peek"($I10)
    rx2759_cur."!cursor_pos"($I11)
    ($P10) = rx2759_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2759_pos, "")
    rx2759_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2761_done
  rxcap_2761_fail:
    goto rx2759_fail
  rxcap_2761_done:
  # rx subrule "O" subtype=capture negate=
    rx2759_cur."!cursor_pos"(rx2759_pos)
    $P10 = rx2759_cur."O"("%relational, :pirop<issame>")
    unless $P10, rx2759_fail
    rx2759_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2759_pos = $P10."pos"()
  # rx pass
    rx2759_cur."!cursor_pass"(rx2759_pos, "infix:sym<=:=>")
    if_null rx2759_debug, debug_1607
    rx2759_cur."!cursor_debug"("PASS", "infix:sym<=:=>", " at pos=", rx2759_pos)
  debug_1607:
    .return (rx2759_cur)
  rx2759_restart:
.annotate 'line', 436
    if_null rx2759_debug, debug_1608
    rx2759_cur."!cursor_debug"("NEXT", "infix:sym<=:=>")
  debug_1608:
  rx2759_fail:
    (rx2759_rep, rx2759_pos, $I10, $P10) = rx2759_cur."!mark_fail"(0)
    lt rx2759_pos, -1, rx2759_done
    eq rx2759_pos, -1, rx2759_fail
    jump $I10
  rx2759_done:
    rx2759_cur."!cursor_fail"()
    if_null rx2759_debug, debug_1609
    rx2759_cur."!cursor_debug"("FAIL", "infix:sym<=:=>")
  debug_1609:
    .return (rx2759_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=:=>"  :subid("386_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2763 = self."!PREFIX__!subrule"("O", "=:=")
    new $P2764, "ResizablePMCArray"
    push $P2764, $P2763
    .return ($P2764)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~~>"  :subid("387_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2766_tgt
    .local int rx2766_pos
    .local int rx2766_off
    .local int rx2766_eos
    .local int rx2766_rep
    .local pmc rx2766_cur
    .local pmc rx2766_debug
    (rx2766_cur, rx2766_pos, rx2766_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2766_cur
    .local pmc match
    .lex "$/", match
    length rx2766_eos, rx2766_tgt
    gt rx2766_pos, rx2766_eos, rx2766_done
    set rx2766_off, 0
    lt rx2766_pos, 2, rx2766_start
    sub rx2766_off, rx2766_pos, 1
    substr rx2766_tgt, rx2766_tgt, rx2766_off
  rx2766_start:
    eq $I10, 1, rx2766_restart
    if_null rx2766_debug, debug_1610
    rx2766_cur."!cursor_debug"("START", "infix:sym<~~>")
  debug_1610:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2767_done
    goto rxscan2767_scan
  rxscan2767_loop:
    (rx2766_pos) = rx2766_cur."from"()
    inc rx2766_pos
    rx2766_cur."!cursor_from"(rx2766_pos)
    ge rx2766_pos, rx2766_eos, rxscan2767_done
  rxscan2767_scan:
    set_addr $I10, rxscan2767_loop
    rx2766_cur."!mark_push"(0, rx2766_pos, $I10)
  rxscan2767_done:
.annotate 'line', 1127
  # rx subcapture "sym"
    set_addr $I10, rxcap_2768_fail
    rx2766_cur."!mark_push"(0, rx2766_pos, $I10)
  # rx literal  "~~"
    add $I11, rx2766_pos, 2
    gt $I11, rx2766_eos, rx2766_fail
    sub $I11, rx2766_pos, rx2766_off
    substr $S10, rx2766_tgt, $I11, 2
    ne $S10, "~~", rx2766_fail
    add rx2766_pos, 2
    set_addr $I10, rxcap_2768_fail
    ($I12, $I11) = rx2766_cur."!mark_peek"($I10)
    rx2766_cur."!cursor_pos"($I11)
    ($P10) = rx2766_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2766_pos, "")
    rx2766_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2768_done
  rxcap_2768_fail:
    goto rx2766_fail
  rxcap_2768_done:
  # rx subrule "O" subtype=capture negate=
    rx2766_cur."!cursor_pos"(rx2766_pos)
    $P10 = rx2766_cur."O"("%relational, :reducecheck<smartmatch>")
    unless $P10, rx2766_fail
    rx2766_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2766_pos = $P10."pos"()
  # rx pass
    rx2766_cur."!cursor_pass"(rx2766_pos, "infix:sym<~~>")
    if_null rx2766_debug, debug_1611
    rx2766_cur."!cursor_debug"("PASS", "infix:sym<~~>", " at pos=", rx2766_pos)
  debug_1611:
    .return (rx2766_cur)
  rx2766_restart:
.annotate 'line', 436
    if_null rx2766_debug, debug_1612
    rx2766_cur."!cursor_debug"("NEXT", "infix:sym<~~>")
  debug_1612:
  rx2766_fail:
    (rx2766_rep, rx2766_pos, $I10, $P10) = rx2766_cur."!mark_fail"(0)
    lt rx2766_pos, -1, rx2766_done
    eq rx2766_pos, -1, rx2766_fail
    jump $I10
  rx2766_done:
    rx2766_cur."!cursor_fail"()
    if_null rx2766_debug, debug_1613
    rx2766_cur."!cursor_debug"("FAIL", "infix:sym<~~>")
  debug_1613:
    .return (rx2766_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~~>"  :subid("388_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2770 = self."!PREFIX__!subrule"("O", "~~")
    new $P2771, "ResizablePMCArray"
    push $P2771, $P2770
    .return ($P2771)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<&&>"  :subid("389_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2773_tgt
    .local int rx2773_pos
    .local int rx2773_off
    .local int rx2773_eos
    .local int rx2773_rep
    .local pmc rx2773_cur
    .local pmc rx2773_debug
    (rx2773_cur, rx2773_pos, rx2773_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2773_cur
    .local pmc match
    .lex "$/", match
    length rx2773_eos, rx2773_tgt
    gt rx2773_pos, rx2773_eos, rx2773_done
    set rx2773_off, 0
    lt rx2773_pos, 2, rx2773_start
    sub rx2773_off, rx2773_pos, 1
    substr rx2773_tgt, rx2773_tgt, rx2773_off
  rx2773_start:
    eq $I10, 1, rx2773_restart
    if_null rx2773_debug, debug_1614
    rx2773_cur."!cursor_debug"("START", "infix:sym<&&>")
  debug_1614:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2774_done
    goto rxscan2774_scan
  rxscan2774_loop:
    (rx2773_pos) = rx2773_cur."from"()
    inc rx2773_pos
    rx2773_cur."!cursor_from"(rx2773_pos)
    ge rx2773_pos, rx2773_eos, rxscan2774_done
  rxscan2774_scan:
    set_addr $I10, rxscan2774_loop
    rx2773_cur."!mark_push"(0, rx2773_pos, $I10)
  rxscan2774_done:
.annotate 'line', 1129
  # rx subcapture "sym"
    set_addr $I10, rxcap_2775_fail
    rx2773_cur."!mark_push"(0, rx2773_pos, $I10)
  # rx literal  "&&"
    add $I11, rx2773_pos, 2
    gt $I11, rx2773_eos, rx2773_fail
    sub $I11, rx2773_pos, rx2773_off
    substr $S10, rx2773_tgt, $I11, 2
    ne $S10, "&&", rx2773_fail
    add rx2773_pos, 2
    set_addr $I10, rxcap_2775_fail
    ($I12, $I11) = rx2773_cur."!mark_peek"($I10)
    rx2773_cur."!cursor_pos"($I11)
    ($P10) = rx2773_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2773_pos, "")
    rx2773_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2775_done
  rxcap_2775_fail:
    goto rx2773_fail
  rxcap_2775_done:
  # rx subrule "O" subtype=capture negate=
    rx2773_cur."!cursor_pos"(rx2773_pos)
    $P10 = rx2773_cur."O"("%tight_and, :pasttype<if>")
    unless $P10, rx2773_fail
    rx2773_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2773_pos = $P10."pos"()
  # rx pass
    rx2773_cur."!cursor_pass"(rx2773_pos, "infix:sym<&&>")
    if_null rx2773_debug, debug_1615
    rx2773_cur."!cursor_debug"("PASS", "infix:sym<&&>", " at pos=", rx2773_pos)
  debug_1615:
    .return (rx2773_cur)
  rx2773_restart:
.annotate 'line', 436
    if_null rx2773_debug, debug_1616
    rx2773_cur."!cursor_debug"("NEXT", "infix:sym<&&>")
  debug_1616:
  rx2773_fail:
    (rx2773_rep, rx2773_pos, $I10, $P10) = rx2773_cur."!mark_fail"(0)
    lt rx2773_pos, -1, rx2773_done
    eq rx2773_pos, -1, rx2773_fail
    jump $I10
  rx2773_done:
    rx2773_cur."!cursor_fail"()
    if_null rx2773_debug, debug_1617
    rx2773_cur."!cursor_debug"("FAIL", "infix:sym<&&>")
  debug_1617:
    .return (rx2773_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<&&>"  :subid("390_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2777 = self."!PREFIX__!subrule"("O", "&&")
    new $P2778, "ResizablePMCArray"
    push $P2778, $P2777
    .return ($P2778)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<||>"  :subid("391_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2780_tgt
    .local int rx2780_pos
    .local int rx2780_off
    .local int rx2780_eos
    .local int rx2780_rep
    .local pmc rx2780_cur
    .local pmc rx2780_debug
    (rx2780_cur, rx2780_pos, rx2780_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2780_cur
    .local pmc match
    .lex "$/", match
    length rx2780_eos, rx2780_tgt
    gt rx2780_pos, rx2780_eos, rx2780_done
    set rx2780_off, 0
    lt rx2780_pos, 2, rx2780_start
    sub rx2780_off, rx2780_pos, 1
    substr rx2780_tgt, rx2780_tgt, rx2780_off
  rx2780_start:
    eq $I10, 1, rx2780_restart
    if_null rx2780_debug, debug_1618
    rx2780_cur."!cursor_debug"("START", "infix:sym<||>")
  debug_1618:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2781_done
    goto rxscan2781_scan
  rxscan2781_loop:
    (rx2780_pos) = rx2780_cur."from"()
    inc rx2780_pos
    rx2780_cur."!cursor_from"(rx2780_pos)
    ge rx2780_pos, rx2780_eos, rxscan2781_done
  rxscan2781_scan:
    set_addr $I10, rxscan2781_loop
    rx2780_cur."!mark_push"(0, rx2780_pos, $I10)
  rxscan2781_done:
.annotate 'line', 1131
  # rx subcapture "sym"
    set_addr $I10, rxcap_2782_fail
    rx2780_cur."!mark_push"(0, rx2780_pos, $I10)
  # rx literal  "||"
    add $I11, rx2780_pos, 2
    gt $I11, rx2780_eos, rx2780_fail
    sub $I11, rx2780_pos, rx2780_off
    substr $S10, rx2780_tgt, $I11, 2
    ne $S10, "||", rx2780_fail
    add rx2780_pos, 2
    set_addr $I10, rxcap_2782_fail
    ($I12, $I11) = rx2780_cur."!mark_peek"($I10)
    rx2780_cur."!cursor_pos"($I11)
    ($P10) = rx2780_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2780_pos, "")
    rx2780_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2782_done
  rxcap_2782_fail:
    goto rx2780_fail
  rxcap_2782_done:
  # rx subrule "O" subtype=capture negate=
    rx2780_cur."!cursor_pos"(rx2780_pos)
    $P10 = rx2780_cur."O"("%tight_or, :pasttype<unless>")
    unless $P10, rx2780_fail
    rx2780_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2780_pos = $P10."pos"()
  # rx pass
    rx2780_cur."!cursor_pass"(rx2780_pos, "infix:sym<||>")
    if_null rx2780_debug, debug_1619
    rx2780_cur."!cursor_debug"("PASS", "infix:sym<||>", " at pos=", rx2780_pos)
  debug_1619:
    .return (rx2780_cur)
  rx2780_restart:
.annotate 'line', 436
    if_null rx2780_debug, debug_1620
    rx2780_cur."!cursor_debug"("NEXT", "infix:sym<||>")
  debug_1620:
  rx2780_fail:
    (rx2780_rep, rx2780_pos, $I10, $P10) = rx2780_cur."!mark_fail"(0)
    lt rx2780_pos, -1, rx2780_done
    eq rx2780_pos, -1, rx2780_fail
    jump $I10
  rx2780_done:
    rx2780_cur."!cursor_fail"()
    if_null rx2780_debug, debug_1621
    rx2780_cur."!cursor_debug"("FAIL", "infix:sym<||>")
  debug_1621:
    .return (rx2780_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<||>"  :subid("392_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2784 = self."!PREFIX__!subrule"("O", "||")
    new $P2785, "ResizablePMCArray"
    push $P2785, $P2784
    .return ($P2785)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<//>"  :subid("393_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2787_tgt
    .local int rx2787_pos
    .local int rx2787_off
    .local int rx2787_eos
    .local int rx2787_rep
    .local pmc rx2787_cur
    .local pmc rx2787_debug
    (rx2787_cur, rx2787_pos, rx2787_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2787_cur
    .local pmc match
    .lex "$/", match
    length rx2787_eos, rx2787_tgt
    gt rx2787_pos, rx2787_eos, rx2787_done
    set rx2787_off, 0
    lt rx2787_pos, 2, rx2787_start
    sub rx2787_off, rx2787_pos, 1
    substr rx2787_tgt, rx2787_tgt, rx2787_off
  rx2787_start:
    eq $I10, 1, rx2787_restart
    if_null rx2787_debug, debug_1622
    rx2787_cur."!cursor_debug"("START", "infix:sym<//>")
  debug_1622:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2788_done
    goto rxscan2788_scan
  rxscan2788_loop:
    (rx2787_pos) = rx2787_cur."from"()
    inc rx2787_pos
    rx2787_cur."!cursor_from"(rx2787_pos)
    ge rx2787_pos, rx2787_eos, rxscan2788_done
  rxscan2788_scan:
    set_addr $I10, rxscan2788_loop
    rx2787_cur."!mark_push"(0, rx2787_pos, $I10)
  rxscan2788_done:
.annotate 'line', 1132
  # rx subcapture "sym"
    set_addr $I10, rxcap_2789_fail
    rx2787_cur."!mark_push"(0, rx2787_pos, $I10)
  # rx literal  "//"
    add $I11, rx2787_pos, 2
    gt $I11, rx2787_eos, rx2787_fail
    sub $I11, rx2787_pos, rx2787_off
    substr $S10, rx2787_tgt, $I11, 2
    ne $S10, "//", rx2787_fail
    add rx2787_pos, 2
    set_addr $I10, rxcap_2789_fail
    ($I12, $I11) = rx2787_cur."!mark_peek"($I10)
    rx2787_cur."!cursor_pos"($I11)
    ($P10) = rx2787_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2787_pos, "")
    rx2787_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2789_done
  rxcap_2789_fail:
    goto rx2787_fail
  rxcap_2789_done:
  # rx subrule "O" subtype=capture negate=
    rx2787_cur."!cursor_pos"(rx2787_pos)
    $P10 = rx2787_cur."O"("%tight_or, :pasttype<def_or>")
    unless $P10, rx2787_fail
    rx2787_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2787_pos = $P10."pos"()
  # rx pass
    rx2787_cur."!cursor_pass"(rx2787_pos, "infix:sym<//>")
    if_null rx2787_debug, debug_1623
    rx2787_cur."!cursor_debug"("PASS", "infix:sym<//>", " at pos=", rx2787_pos)
  debug_1623:
    .return (rx2787_cur)
  rx2787_restart:
.annotate 'line', 436
    if_null rx2787_debug, debug_1624
    rx2787_cur."!cursor_debug"("NEXT", "infix:sym<//>")
  debug_1624:
  rx2787_fail:
    (rx2787_rep, rx2787_pos, $I10, $P10) = rx2787_cur."!mark_fail"(0)
    lt rx2787_pos, -1, rx2787_done
    eq rx2787_pos, -1, rx2787_fail
    jump $I10
  rx2787_done:
    rx2787_cur."!cursor_fail"()
    if_null rx2787_debug, debug_1625
    rx2787_cur."!cursor_debug"("FAIL", "infix:sym<//>")
  debug_1625:
    .return (rx2787_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<//>"  :subid("394_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2791 = self."!PREFIX__!subrule"("O", "//")
    new $P2792, "ResizablePMCArray"
    push $P2792, $P2791
    .return ($P2792)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<?? !!>"  :subid("395_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2794_tgt
    .local int rx2794_pos
    .local int rx2794_off
    .local int rx2794_eos
    .local int rx2794_rep
    .local pmc rx2794_cur
    .local pmc rx2794_debug
    (rx2794_cur, rx2794_pos, rx2794_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2794_cur
    .local pmc match
    .lex "$/", match
    length rx2794_eos, rx2794_tgt
    gt rx2794_pos, rx2794_eos, rx2794_done
    set rx2794_off, 0
    lt rx2794_pos, 2, rx2794_start
    sub rx2794_off, rx2794_pos, 1
    substr rx2794_tgt, rx2794_tgt, rx2794_off
  rx2794_start:
    eq $I10, 1, rx2794_restart
    if_null rx2794_debug, debug_1626
    rx2794_cur."!cursor_debug"("START", "infix:sym<?? !!>")
  debug_1626:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2795_done
    goto rxscan2795_scan
  rxscan2795_loop:
    (rx2794_pos) = rx2794_cur."from"()
    inc rx2794_pos
    rx2794_cur."!cursor_from"(rx2794_pos)
    ge rx2794_pos, rx2794_eos, rxscan2795_done
  rxscan2795_scan:
    set_addr $I10, rxscan2795_loop
    rx2794_cur."!mark_push"(0, rx2794_pos, $I10)
  rxscan2795_done:
.annotate 'line', 1135
  # rx literal  "??"
    add $I11, rx2794_pos, 2
    gt $I11, rx2794_eos, rx2794_fail
    sub $I11, rx2794_pos, rx2794_off
    substr $S10, rx2794_tgt, $I11, 2
    ne $S10, "??", rx2794_fail
    add rx2794_pos, 2
.annotate 'line', 1136
  # rx subrule "ws" subtype=method negate=
    rx2794_cur."!cursor_pos"(rx2794_pos)
    $P10 = rx2794_cur."ws"()
    unless $P10, rx2794_fail
    rx2794_pos = $P10."pos"()
.annotate 'line', 1137
  # rx subrule "EXPR" subtype=capture negate=
    rx2794_cur."!cursor_pos"(rx2794_pos)
    $P10 = rx2794_cur."EXPR"("i=")
    unless $P10, rx2794_fail
    rx2794_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx2794_pos = $P10."pos"()
.annotate 'line', 1138
  # rx literal  "!!"
    add $I11, rx2794_pos, 2
    gt $I11, rx2794_eos, rx2794_fail
    sub $I11, rx2794_pos, rx2794_off
    substr $S10, rx2794_tgt, $I11, 2
    ne $S10, "!!", rx2794_fail
    add rx2794_pos, 2
.annotate 'line', 1139
  # rx subrule "O" subtype=capture negate=
    rx2794_cur."!cursor_pos"(rx2794_pos)
    $P10 = rx2794_cur."O"("%conditional, :reducecheck<ternary>, :pasttype<if>")
    unless $P10, rx2794_fail
    rx2794_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2794_pos = $P10."pos"()
.annotate 'line', 1134
  # rx pass
    rx2794_cur."!cursor_pass"(rx2794_pos, "infix:sym<?? !!>")
    if_null rx2794_debug, debug_1627
    rx2794_cur."!cursor_debug"("PASS", "infix:sym<?? !!>", " at pos=", rx2794_pos)
  debug_1627:
    .return (rx2794_cur)
  rx2794_restart:
.annotate 'line', 436
    if_null rx2794_debug, debug_1628
    rx2794_cur."!cursor_debug"("NEXT", "infix:sym<?? !!>")
  debug_1628:
  rx2794_fail:
    (rx2794_rep, rx2794_pos, $I10, $P10) = rx2794_cur."!mark_fail"(0)
    lt rx2794_pos, -1, rx2794_done
    eq rx2794_pos, -1, rx2794_fail
    jump $I10
  rx2794_done:
    rx2794_cur."!cursor_fail"()
    if_null rx2794_debug, debug_1629
    rx2794_cur."!cursor_debug"("FAIL", "infix:sym<?? !!>")
  debug_1629:
    .return (rx2794_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<?? !!>"  :subid("396_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2797 = self."!PREFIX__!subrule"("ws", "??")
    new $P2798, "ResizablePMCArray"
    push $P2798, $P2797
    .return ($P2798)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=>"  :subid("397_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2800_tgt
    .local int rx2800_pos
    .local int rx2800_off
    .local int rx2800_eos
    .local int rx2800_rep
    .local pmc rx2800_cur
    .local pmc rx2800_debug
    (rx2800_cur, rx2800_pos, rx2800_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2800_cur
    .local pmc match
    .lex "$/", match
    length rx2800_eos, rx2800_tgt
    gt rx2800_pos, rx2800_eos, rx2800_done
    set rx2800_off, 0
    lt rx2800_pos, 2, rx2800_start
    sub rx2800_off, rx2800_pos, 1
    substr rx2800_tgt, rx2800_tgt, rx2800_off
  rx2800_start:
    eq $I10, 1, rx2800_restart
    if_null rx2800_debug, debug_1630
    rx2800_cur."!cursor_debug"("START", "infix:sym<=>")
  debug_1630:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2801_done
    goto rxscan2801_scan
  rxscan2801_loop:
    (rx2800_pos) = rx2800_cur."from"()
    inc rx2800_pos
    rx2800_cur."!cursor_from"(rx2800_pos)
    ge rx2800_pos, rx2800_eos, rxscan2801_done
  rxscan2801_scan:
    set_addr $I10, rxscan2801_loop
    rx2800_cur."!mark_push"(0, rx2800_pos, $I10)
  rxscan2801_done:
.annotate 'line', 1143
  # rx subcapture "sym"
    set_addr $I10, rxcap_2802_fail
    rx2800_cur."!mark_push"(0, rx2800_pos, $I10)
  # rx literal  "="
    add $I11, rx2800_pos, 1
    gt $I11, rx2800_eos, rx2800_fail
    sub $I11, rx2800_pos, rx2800_off
    ord $I11, rx2800_tgt, $I11
    ne $I11, 61, rx2800_fail
    add rx2800_pos, 1
    set_addr $I10, rxcap_2802_fail
    ($I12, $I11) = rx2800_cur."!mark_peek"($I10)
    rx2800_cur."!cursor_pos"($I11)
    ($P10) = rx2800_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2800_pos, "")
    rx2800_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2802_done
  rxcap_2802_fail:
    goto rx2800_fail
  rxcap_2802_done:
  # rx subrule "panic" subtype=method negate=
    rx2800_cur."!cursor_pos"(rx2800_pos)
    $P10 = rx2800_cur."panic"("Assignment (\"=\") not supported in NQP, use \":=\" instead")
    unless $P10, rx2800_fail
    rx2800_pos = $P10."pos"()
.annotate 'line', 1142
  # rx pass
    rx2800_cur."!cursor_pass"(rx2800_pos, "infix:sym<=>")
    if_null rx2800_debug, debug_1631
    rx2800_cur."!cursor_debug"("PASS", "infix:sym<=>", " at pos=", rx2800_pos)
  debug_1631:
    .return (rx2800_cur)
  rx2800_restart:
.annotate 'line', 436
    if_null rx2800_debug, debug_1632
    rx2800_cur."!cursor_debug"("NEXT", "infix:sym<=>")
  debug_1632:
  rx2800_fail:
    (rx2800_rep, rx2800_pos, $I10, $P10) = rx2800_cur."!mark_fail"(0)
    lt rx2800_pos, -1, rx2800_done
    eq rx2800_pos, -1, rx2800_fail
    jump $I10
  rx2800_done:
    rx2800_cur."!cursor_fail"()
    if_null rx2800_debug, debug_1633
    rx2800_cur."!cursor_debug"("FAIL", "infix:sym<=>")
  debug_1633:
    .return (rx2800_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=>"  :subid("398_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2804 = self."!PREFIX__!subrule"("panic", "=")
    new $P2805, "ResizablePMCArray"
    push $P2805, $P2804
    .return ($P2805)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<:=>"  :subid("399_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2807_tgt
    .local int rx2807_pos
    .local int rx2807_off
    .local int rx2807_eos
    .local int rx2807_rep
    .local pmc rx2807_cur
    .local pmc rx2807_debug
    (rx2807_cur, rx2807_pos, rx2807_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2807_cur
    .local pmc match
    .lex "$/", match
    length rx2807_eos, rx2807_tgt
    gt rx2807_pos, rx2807_eos, rx2807_done
    set rx2807_off, 0
    lt rx2807_pos, 2, rx2807_start
    sub rx2807_off, rx2807_pos, 1
    substr rx2807_tgt, rx2807_tgt, rx2807_off
  rx2807_start:
    eq $I10, 1, rx2807_restart
    if_null rx2807_debug, debug_1634
    rx2807_cur."!cursor_debug"("START", "infix:sym<:=>")
  debug_1634:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2808_done
    goto rxscan2808_scan
  rxscan2808_loop:
    (rx2807_pos) = rx2807_cur."from"()
    inc rx2807_pos
    rx2807_cur."!cursor_from"(rx2807_pos)
    ge rx2807_pos, rx2807_eos, rxscan2808_done
  rxscan2808_scan:
    set_addr $I10, rxscan2808_loop
    rx2807_cur."!mark_push"(0, rx2807_pos, $I10)
  rxscan2808_done:
.annotate 'line', 1145
  # rx subcapture "sym"
    set_addr $I10, rxcap_2809_fail
    rx2807_cur."!mark_push"(0, rx2807_pos, $I10)
  # rx literal  ":="
    add $I11, rx2807_pos, 2
    gt $I11, rx2807_eos, rx2807_fail
    sub $I11, rx2807_pos, rx2807_off
    substr $S10, rx2807_tgt, $I11, 2
    ne $S10, ":=", rx2807_fail
    add rx2807_pos, 2
    set_addr $I10, rxcap_2809_fail
    ($I12, $I11) = rx2807_cur."!mark_peek"($I10)
    rx2807_cur."!cursor_pos"($I11)
    ($P10) = rx2807_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2807_pos, "")
    rx2807_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2809_done
  rxcap_2809_fail:
    goto rx2807_fail
  rxcap_2809_done:
  # rx subrule "O" subtype=capture negate=
    rx2807_cur."!cursor_pos"(rx2807_pos)
    $P10 = rx2807_cur."O"("%assignment, :pasttype<bind_6model>")
    unless $P10, rx2807_fail
    rx2807_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2807_pos = $P10."pos"()
  # rx pass
    rx2807_cur."!cursor_pass"(rx2807_pos, "infix:sym<:=>")
    if_null rx2807_debug, debug_1635
    rx2807_cur."!cursor_debug"("PASS", "infix:sym<:=>", " at pos=", rx2807_pos)
  debug_1635:
    .return (rx2807_cur)
  rx2807_restart:
.annotate 'line', 436
    if_null rx2807_debug, debug_1636
    rx2807_cur."!cursor_debug"("NEXT", "infix:sym<:=>")
  debug_1636:
  rx2807_fail:
    (rx2807_rep, rx2807_pos, $I10, $P10) = rx2807_cur."!mark_fail"(0)
    lt rx2807_pos, -1, rx2807_done
    eq rx2807_pos, -1, rx2807_fail
    jump $I10
  rx2807_done:
    rx2807_cur."!cursor_fail"()
    if_null rx2807_debug, debug_1637
    rx2807_cur."!cursor_debug"("FAIL", "infix:sym<:=>")
  debug_1637:
    .return (rx2807_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<:=>"  :subid("400_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2811 = self."!PREFIX__!subrule"("O", ":=")
    new $P2812, "ResizablePMCArray"
    push $P2812, $P2811
    .return ($P2812)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<::=>"  :subid("401_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2814_tgt
    .local int rx2814_pos
    .local int rx2814_off
    .local int rx2814_eos
    .local int rx2814_rep
    .local pmc rx2814_cur
    .local pmc rx2814_debug
    (rx2814_cur, rx2814_pos, rx2814_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2814_cur
    .local pmc match
    .lex "$/", match
    length rx2814_eos, rx2814_tgt
    gt rx2814_pos, rx2814_eos, rx2814_done
    set rx2814_off, 0
    lt rx2814_pos, 2, rx2814_start
    sub rx2814_off, rx2814_pos, 1
    substr rx2814_tgt, rx2814_tgt, rx2814_off
  rx2814_start:
    eq $I10, 1, rx2814_restart
    if_null rx2814_debug, debug_1638
    rx2814_cur."!cursor_debug"("START", "infix:sym<::=>")
  debug_1638:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2815_done
    goto rxscan2815_scan
  rxscan2815_loop:
    (rx2814_pos) = rx2814_cur."from"()
    inc rx2814_pos
    rx2814_cur."!cursor_from"(rx2814_pos)
    ge rx2814_pos, rx2814_eos, rxscan2815_done
  rxscan2815_scan:
    set_addr $I10, rxscan2815_loop
    rx2814_cur."!mark_push"(0, rx2814_pos, $I10)
  rxscan2815_done:
.annotate 'line', 1146
  # rx subcapture "sym"
    set_addr $I10, rxcap_2816_fail
    rx2814_cur."!mark_push"(0, rx2814_pos, $I10)
  # rx literal  "::="
    add $I11, rx2814_pos, 3
    gt $I11, rx2814_eos, rx2814_fail
    sub $I11, rx2814_pos, rx2814_off
    substr $S10, rx2814_tgt, $I11, 3
    ne $S10, "::=", rx2814_fail
    add rx2814_pos, 3
    set_addr $I10, rxcap_2816_fail
    ($I12, $I11) = rx2814_cur."!mark_peek"($I10)
    rx2814_cur."!cursor_pos"($I11)
    ($P10) = rx2814_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2814_pos, "")
    rx2814_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2816_done
  rxcap_2816_fail:
    goto rx2814_fail
  rxcap_2816_done:
  # rx subrule "O" subtype=capture negate=
    rx2814_cur."!cursor_pos"(rx2814_pos)
    $P10 = rx2814_cur."O"("%assignment, :pasttype<bind_6model>")
    unless $P10, rx2814_fail
    rx2814_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2814_pos = $P10."pos"()
  # rx pass
    rx2814_cur."!cursor_pass"(rx2814_pos, "infix:sym<::=>")
    if_null rx2814_debug, debug_1639
    rx2814_cur."!cursor_debug"("PASS", "infix:sym<::=>", " at pos=", rx2814_pos)
  debug_1639:
    .return (rx2814_cur)
  rx2814_restart:
.annotate 'line', 436
    if_null rx2814_debug, debug_1640
    rx2814_cur."!cursor_debug"("NEXT", "infix:sym<::=>")
  debug_1640:
  rx2814_fail:
    (rx2814_rep, rx2814_pos, $I10, $P10) = rx2814_cur."!mark_fail"(0)
    lt rx2814_pos, -1, rx2814_done
    eq rx2814_pos, -1, rx2814_fail
    jump $I10
  rx2814_done:
    rx2814_cur."!cursor_fail"()
    if_null rx2814_debug, debug_1641
    rx2814_cur."!cursor_debug"("FAIL", "infix:sym<::=>")
  debug_1641:
    .return (rx2814_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<::=>"  :subid("402_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2818 = self."!PREFIX__!subrule"("O", "::=")
    new $P2819, "ResizablePMCArray"
    push $P2819, $P2818
    .return ($P2819)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<,>"  :subid("403_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2821_tgt
    .local int rx2821_pos
    .local int rx2821_off
    .local int rx2821_eos
    .local int rx2821_rep
    .local pmc rx2821_cur
    .local pmc rx2821_debug
    (rx2821_cur, rx2821_pos, rx2821_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2821_cur
    .local pmc match
    .lex "$/", match
    length rx2821_eos, rx2821_tgt
    gt rx2821_pos, rx2821_eos, rx2821_done
    set rx2821_off, 0
    lt rx2821_pos, 2, rx2821_start
    sub rx2821_off, rx2821_pos, 1
    substr rx2821_tgt, rx2821_tgt, rx2821_off
  rx2821_start:
    eq $I10, 1, rx2821_restart
    if_null rx2821_debug, debug_1642
    rx2821_cur."!cursor_debug"("START", "infix:sym<,>")
  debug_1642:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2822_done
    goto rxscan2822_scan
  rxscan2822_loop:
    (rx2821_pos) = rx2821_cur."from"()
    inc rx2821_pos
    rx2821_cur."!cursor_from"(rx2821_pos)
    ge rx2821_pos, rx2821_eos, rxscan2822_done
  rxscan2822_scan:
    set_addr $I10, rxscan2822_loop
    rx2821_cur."!mark_push"(0, rx2821_pos, $I10)
  rxscan2822_done:
.annotate 'line', 1148
  # rx subcapture "sym"
    set_addr $I10, rxcap_2823_fail
    rx2821_cur."!mark_push"(0, rx2821_pos, $I10)
  # rx literal  ","
    add $I11, rx2821_pos, 1
    gt $I11, rx2821_eos, rx2821_fail
    sub $I11, rx2821_pos, rx2821_off
    ord $I11, rx2821_tgt, $I11
    ne $I11, 44, rx2821_fail
    add rx2821_pos, 1
    set_addr $I10, rxcap_2823_fail
    ($I12, $I11) = rx2821_cur."!mark_peek"($I10)
    rx2821_cur."!cursor_pos"($I11)
    ($P10) = rx2821_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2821_pos, "")
    rx2821_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2823_done
  rxcap_2823_fail:
    goto rx2821_fail
  rxcap_2823_done:
  # rx subrule "O" subtype=capture negate=
    rx2821_cur."!cursor_pos"(rx2821_pos)
    $P10 = rx2821_cur."O"("%comma, :pasttype<list>")
    unless $P10, rx2821_fail
    rx2821_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2821_pos = $P10."pos"()
  # rx pass
    rx2821_cur."!cursor_pass"(rx2821_pos, "infix:sym<,>")
    if_null rx2821_debug, debug_1643
    rx2821_cur."!cursor_debug"("PASS", "infix:sym<,>", " at pos=", rx2821_pos)
  debug_1643:
    .return (rx2821_cur)
  rx2821_restart:
.annotate 'line', 436
    if_null rx2821_debug, debug_1644
    rx2821_cur."!cursor_debug"("NEXT", "infix:sym<,>")
  debug_1644:
  rx2821_fail:
    (rx2821_rep, rx2821_pos, $I10, $P10) = rx2821_cur."!mark_fail"(0)
    lt rx2821_pos, -1, rx2821_done
    eq rx2821_pos, -1, rx2821_fail
    jump $I10
  rx2821_done:
    rx2821_cur."!cursor_fail"()
    if_null rx2821_debug, debug_1645
    rx2821_cur."!cursor_debug"("FAIL", "infix:sym<,>")
  debug_1645:
    .return (rx2821_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<,>"  :subid("404_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    $P2825 = self."!PREFIX__!subrule"("O", ",")
    new $P2826, "ResizablePMCArray"
    push $P2826, $P2825
    .return ($P2826)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<return>"  :subid("405_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .const 'Sub' $P2834 = "406_1307873304.82979" 
    capture_lex $P2834
    .local string rx2828_tgt
    .local int rx2828_pos
    .local int rx2828_off
    .local int rx2828_eos
    .local int rx2828_rep
    .local pmc rx2828_cur
    .local pmc rx2828_debug
    (rx2828_cur, rx2828_pos, rx2828_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2828_cur
    .local pmc match
    .lex "$/", match
    length rx2828_eos, rx2828_tgt
    gt rx2828_pos, rx2828_eos, rx2828_done
    set rx2828_off, 0
    lt rx2828_pos, 2, rx2828_start
    sub rx2828_off, rx2828_pos, 1
    substr rx2828_tgt, rx2828_tgt, rx2828_off
  rx2828_start:
    eq $I10, 1, rx2828_restart
    if_null rx2828_debug, debug_1646
    rx2828_cur."!cursor_debug"("START", "prefix:sym<return>")
  debug_1646:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2829_done
    goto rxscan2829_scan
  rxscan2829_loop:
    (rx2828_pos) = rx2828_cur."from"()
    inc rx2828_pos
    rx2828_cur."!cursor_from"(rx2828_pos)
    ge rx2828_pos, rx2828_eos, rxscan2829_done
  rxscan2829_scan:
    set_addr $I10, rxscan2829_loop
    rx2828_cur."!mark_push"(0, rx2828_pos, $I10)
  rxscan2829_done:
.annotate 'line', 1150
  # rx subcapture "sym"
    set_addr $I10, rxcap_2830_fail
    rx2828_cur."!mark_push"(0, rx2828_pos, $I10)
  # rx literal  "return"
    add $I11, rx2828_pos, 6
    gt $I11, rx2828_eos, rx2828_fail
    sub $I11, rx2828_pos, rx2828_off
    substr $S10, rx2828_tgt, $I11, 6
    ne $S10, "return", rx2828_fail
    add rx2828_pos, 6
    set_addr $I10, rxcap_2830_fail
    ($I12, $I11) = rx2828_cur."!mark_peek"($I10)
    rx2828_cur."!cursor_pos"($I11)
    ($P10) = rx2828_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2828_pos, "")
    rx2828_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2830_done
  rxcap_2830_fail:
    goto rx2828_fail
  rxcap_2830_done:
  # rx charclass s
    ge rx2828_pos, rx2828_eos, rx2828_fail
    sub $I10, rx2828_pos, rx2828_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx2828_tgt, $I10
    unless $I11, rx2828_fail
    inc rx2828_pos
  # rx subrule "O" subtype=capture negate=
    rx2828_cur."!cursor_pos"(rx2828_pos)
    $P10 = rx2828_cur."O"("%list_prefix, :pasttype<return>")
    unless $P10, rx2828_fail
    rx2828_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2828_pos = $P10."pos"()
    rx2828_cur."!cursor_pos"(rx2828_pos)
    find_lex $P2831, unicode:"$\x{a2}"
    $P2832 = $P2831."MATCH"()
    store_lex "$/", $P2832
    .const 'Sub' $P2834 = "406_1307873304.82979" 
    capture_lex $P2834
    $P2836 = $P2834()
  # rx pass
    rx2828_cur."!cursor_pass"(rx2828_pos, "prefix:sym<return>")
    if_null rx2828_debug, debug_1647
    rx2828_cur."!cursor_debug"("PASS", "prefix:sym<return>", " at pos=", rx2828_pos)
  debug_1647:
    .return (rx2828_cur)
  rx2828_restart:
.annotate 'line', 436
    if_null rx2828_debug, debug_1648
    rx2828_cur."!cursor_debug"("NEXT", "prefix:sym<return>")
  debug_1648:
  rx2828_fail:
    (rx2828_rep, rx2828_pos, $I10, $P10) = rx2828_cur."!mark_fail"(0)
    lt rx2828_pos, -1, rx2828_done
    eq rx2828_pos, -1, rx2828_fail
    jump $I10
  rx2828_done:
    rx2828_cur."!cursor_fail"()
    if_null rx2828_debug, debug_1649
    rx2828_cur."!cursor_debug"("FAIL", "prefix:sym<return>")
  debug_1649:
    .return (rx2828_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block2833"  :anon :subid("406_1307873304.82979") :outer("405_1307873304.82979")
.annotate 'line', 1150
    new $P2835, "Integer"
    assign $P2835, 1
    store_dynamic_lex "$*RETURN_USED", $P2835
    .return ($P2835)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<return>"  :subid("407_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    new $P2838, "ResizablePMCArray"
    push $P2838, "return"
    .return ($P2838)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<make>"  :subid("408_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2840_tgt
    .local int rx2840_pos
    .local int rx2840_off
    .local int rx2840_eos
    .local int rx2840_rep
    .local pmc rx2840_cur
    .local pmc rx2840_debug
    (rx2840_cur, rx2840_pos, rx2840_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2840_cur
    .local pmc match
    .lex "$/", match
    length rx2840_eos, rx2840_tgt
    gt rx2840_pos, rx2840_eos, rx2840_done
    set rx2840_off, 0
    lt rx2840_pos, 2, rx2840_start
    sub rx2840_off, rx2840_pos, 1
    substr rx2840_tgt, rx2840_tgt, rx2840_off
  rx2840_start:
    eq $I10, 1, rx2840_restart
    if_null rx2840_debug, debug_1650
    rx2840_cur."!cursor_debug"("START", "prefix:sym<make>")
  debug_1650:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2841_done
    goto rxscan2841_scan
  rxscan2841_loop:
    (rx2840_pos) = rx2840_cur."from"()
    inc rx2840_pos
    rx2840_cur."!cursor_from"(rx2840_pos)
    ge rx2840_pos, rx2840_eos, rxscan2841_done
  rxscan2841_scan:
    set_addr $I10, rxscan2841_loop
    rx2840_cur."!mark_push"(0, rx2840_pos, $I10)
  rxscan2841_done:
.annotate 'line', 1151
  # rx subcapture "sym"
    set_addr $I10, rxcap_2842_fail
    rx2840_cur."!mark_push"(0, rx2840_pos, $I10)
  # rx literal  "make"
    add $I11, rx2840_pos, 4
    gt $I11, rx2840_eos, rx2840_fail
    sub $I11, rx2840_pos, rx2840_off
    substr $S10, rx2840_tgt, $I11, 4
    ne $S10, "make", rx2840_fail
    add rx2840_pos, 4
    set_addr $I10, rxcap_2842_fail
    ($I12, $I11) = rx2840_cur."!mark_peek"($I10)
    rx2840_cur."!cursor_pos"($I11)
    ($P10) = rx2840_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2840_pos, "")
    rx2840_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2842_done
  rxcap_2842_fail:
    goto rx2840_fail
  rxcap_2842_done:
  # rx charclass s
    ge rx2840_pos, rx2840_eos, rx2840_fail
    sub $I10, rx2840_pos, rx2840_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx2840_tgt, $I10
    unless $I11, rx2840_fail
    inc rx2840_pos
  # rx subrule "O" subtype=capture negate=
    rx2840_cur."!cursor_pos"(rx2840_pos)
    $P10 = rx2840_cur."O"("%list_prefix")
    unless $P10, rx2840_fail
    rx2840_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2840_pos = $P10."pos"()
  # rx pass
    rx2840_cur."!cursor_pass"(rx2840_pos, "prefix:sym<make>")
    if_null rx2840_debug, debug_1651
    rx2840_cur."!cursor_debug"("PASS", "prefix:sym<make>", " at pos=", rx2840_pos)
  debug_1651:
    .return (rx2840_cur)
  rx2840_restart:
.annotate 'line', 436
    if_null rx2840_debug, debug_1652
    rx2840_cur."!cursor_debug"("NEXT", "prefix:sym<make>")
  debug_1652:
  rx2840_fail:
    (rx2840_rep, rx2840_pos, $I10, $P10) = rx2840_cur."!mark_fail"(0)
    lt rx2840_pos, -1, rx2840_done
    eq rx2840_pos, -1, rx2840_fail
    jump $I10
  rx2840_done:
    rx2840_cur."!cursor_fail"()
    if_null rx2840_debug, debug_1653
    rx2840_cur."!cursor_debug"("FAIL", "prefix:sym<make>")
  debug_1653:
    .return (rx2840_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<make>"  :subid("409_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    new $P2844, "ResizablePMCArray"
    push $P2844, "make"
    .return ($P2844)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<last>"  :subid("410_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2846_tgt
    .local int rx2846_pos
    .local int rx2846_off
    .local int rx2846_eos
    .local int rx2846_rep
    .local pmc rx2846_cur
    .local pmc rx2846_debug
    (rx2846_cur, rx2846_pos, rx2846_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2846_cur
    .local pmc match
    .lex "$/", match
    length rx2846_eos, rx2846_tgt
    gt rx2846_pos, rx2846_eos, rx2846_done
    set rx2846_off, 0
    lt rx2846_pos, 2, rx2846_start
    sub rx2846_off, rx2846_pos, 1
    substr rx2846_tgt, rx2846_tgt, rx2846_off
  rx2846_start:
    eq $I10, 1, rx2846_restart
    if_null rx2846_debug, debug_1654
    rx2846_cur."!cursor_debug"("START", "term:sym<last>")
  debug_1654:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2847_done
    goto rxscan2847_scan
  rxscan2847_loop:
    (rx2846_pos) = rx2846_cur."from"()
    inc rx2846_pos
    rx2846_cur."!cursor_from"(rx2846_pos)
    ge rx2846_pos, rx2846_eos, rxscan2847_done
  rxscan2847_scan:
    set_addr $I10, rxscan2847_loop
    rx2846_cur."!mark_push"(0, rx2846_pos, $I10)
  rxscan2847_done:
.annotate 'line', 1152
  # rx subcapture "sym"
    set_addr $I10, rxcap_2848_fail
    rx2846_cur."!mark_push"(0, rx2846_pos, $I10)
  # rx literal  "last"
    add $I11, rx2846_pos, 4
    gt $I11, rx2846_eos, rx2846_fail
    sub $I11, rx2846_pos, rx2846_off
    substr $S10, rx2846_tgt, $I11, 4
    ne $S10, "last", rx2846_fail
    add rx2846_pos, 4
    set_addr $I10, rxcap_2848_fail
    ($I12, $I11) = rx2846_cur."!mark_peek"($I10)
    rx2846_cur."!cursor_pos"($I11)
    ($P10) = rx2846_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2846_pos, "")
    rx2846_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2848_done
  rxcap_2848_fail:
    goto rx2846_fail
  rxcap_2848_done:
  # rx pass
    rx2846_cur."!cursor_pass"(rx2846_pos, "term:sym<last>")
    if_null rx2846_debug, debug_1655
    rx2846_cur."!cursor_debug"("PASS", "term:sym<last>", " at pos=", rx2846_pos)
  debug_1655:
    .return (rx2846_cur)
  rx2846_restart:
.annotate 'line', 436
    if_null rx2846_debug, debug_1656
    rx2846_cur."!cursor_debug"("NEXT", "term:sym<last>")
  debug_1656:
  rx2846_fail:
    (rx2846_rep, rx2846_pos, $I10, $P10) = rx2846_cur."!mark_fail"(0)
    lt rx2846_pos, -1, rx2846_done
    eq rx2846_pos, -1, rx2846_fail
    jump $I10
  rx2846_done:
    rx2846_cur."!cursor_fail"()
    if_null rx2846_debug, debug_1657
    rx2846_cur."!cursor_debug"("FAIL", "term:sym<last>")
  debug_1657:
    .return (rx2846_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<last>"  :subid("411_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    new $P2850, "ResizablePMCArray"
    push $P2850, "last"
    .return ($P2850)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<next>"  :subid("412_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2852_tgt
    .local int rx2852_pos
    .local int rx2852_off
    .local int rx2852_eos
    .local int rx2852_rep
    .local pmc rx2852_cur
    .local pmc rx2852_debug
    (rx2852_cur, rx2852_pos, rx2852_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2852_cur
    .local pmc match
    .lex "$/", match
    length rx2852_eos, rx2852_tgt
    gt rx2852_pos, rx2852_eos, rx2852_done
    set rx2852_off, 0
    lt rx2852_pos, 2, rx2852_start
    sub rx2852_off, rx2852_pos, 1
    substr rx2852_tgt, rx2852_tgt, rx2852_off
  rx2852_start:
    eq $I10, 1, rx2852_restart
    if_null rx2852_debug, debug_1658
    rx2852_cur."!cursor_debug"("START", "term:sym<next>")
  debug_1658:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2853_done
    goto rxscan2853_scan
  rxscan2853_loop:
    (rx2852_pos) = rx2852_cur."from"()
    inc rx2852_pos
    rx2852_cur."!cursor_from"(rx2852_pos)
    ge rx2852_pos, rx2852_eos, rxscan2853_done
  rxscan2853_scan:
    set_addr $I10, rxscan2853_loop
    rx2852_cur."!mark_push"(0, rx2852_pos, $I10)
  rxscan2853_done:
.annotate 'line', 1153
  # rx subcapture "sym"
    set_addr $I10, rxcap_2854_fail
    rx2852_cur."!mark_push"(0, rx2852_pos, $I10)
  # rx literal  "next"
    add $I11, rx2852_pos, 4
    gt $I11, rx2852_eos, rx2852_fail
    sub $I11, rx2852_pos, rx2852_off
    substr $S10, rx2852_tgt, $I11, 4
    ne $S10, "next", rx2852_fail
    add rx2852_pos, 4
    set_addr $I10, rxcap_2854_fail
    ($I12, $I11) = rx2852_cur."!mark_peek"($I10)
    rx2852_cur."!cursor_pos"($I11)
    ($P10) = rx2852_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2852_pos, "")
    rx2852_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2854_done
  rxcap_2854_fail:
    goto rx2852_fail
  rxcap_2854_done:
  # rx pass
    rx2852_cur."!cursor_pass"(rx2852_pos, "term:sym<next>")
    if_null rx2852_debug, debug_1659
    rx2852_cur."!cursor_debug"("PASS", "term:sym<next>", " at pos=", rx2852_pos)
  debug_1659:
    .return (rx2852_cur)
  rx2852_restart:
.annotate 'line', 436
    if_null rx2852_debug, debug_1660
    rx2852_cur."!cursor_debug"("NEXT", "term:sym<next>")
  debug_1660:
  rx2852_fail:
    (rx2852_rep, rx2852_pos, $I10, $P10) = rx2852_cur."!mark_fail"(0)
    lt rx2852_pos, -1, rx2852_done
    eq rx2852_pos, -1, rx2852_fail
    jump $I10
  rx2852_done:
    rx2852_cur."!cursor_fail"()
    if_null rx2852_debug, debug_1661
    rx2852_cur."!cursor_debug"("FAIL", "term:sym<next>")
  debug_1661:
    .return (rx2852_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<next>"  :subid("413_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    new $P2856, "ResizablePMCArray"
    push $P2856, "next"
    .return ($P2856)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<redo>"  :subid("414_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    .local string rx2858_tgt
    .local int rx2858_pos
    .local int rx2858_off
    .local int rx2858_eos
    .local int rx2858_rep
    .local pmc rx2858_cur
    .local pmc rx2858_debug
    (rx2858_cur, rx2858_pos, rx2858_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2858_cur
    .local pmc match
    .lex "$/", match
    length rx2858_eos, rx2858_tgt
    gt rx2858_pos, rx2858_eos, rx2858_done
    set rx2858_off, 0
    lt rx2858_pos, 2, rx2858_start
    sub rx2858_off, rx2858_pos, 1
    substr rx2858_tgt, rx2858_tgt, rx2858_off
  rx2858_start:
    eq $I10, 1, rx2858_restart
    if_null rx2858_debug, debug_1662
    rx2858_cur."!cursor_debug"("START", "term:sym<redo>")
  debug_1662:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2859_done
    goto rxscan2859_scan
  rxscan2859_loop:
    (rx2858_pos) = rx2858_cur."from"()
    inc rx2858_pos
    rx2858_cur."!cursor_from"(rx2858_pos)
    ge rx2858_pos, rx2858_eos, rxscan2859_done
  rxscan2859_scan:
    set_addr $I10, rxscan2859_loop
    rx2858_cur."!mark_push"(0, rx2858_pos, $I10)
  rxscan2859_done:
.annotate 'line', 1154
  # rx subcapture "sym"
    set_addr $I10, rxcap_2860_fail
    rx2858_cur."!mark_push"(0, rx2858_pos, $I10)
  # rx literal  "redo"
    add $I11, rx2858_pos, 4
    gt $I11, rx2858_eos, rx2858_fail
    sub $I11, rx2858_pos, rx2858_off
    substr $S10, rx2858_tgt, $I11, 4
    ne $S10, "redo", rx2858_fail
    add rx2858_pos, 4
    set_addr $I10, rxcap_2860_fail
    ($I12, $I11) = rx2858_cur."!mark_peek"($I10)
    rx2858_cur."!cursor_pos"($I11)
    ($P10) = rx2858_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2858_pos, "")
    rx2858_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2860_done
  rxcap_2860_fail:
    goto rx2858_fail
  rxcap_2860_done:
  # rx pass
    rx2858_cur."!cursor_pass"(rx2858_pos, "term:sym<redo>")
    if_null rx2858_debug, debug_1663
    rx2858_cur."!cursor_debug"("PASS", "term:sym<redo>", " at pos=", rx2858_pos)
  debug_1663:
    .return (rx2858_cur)
  rx2858_restart:
.annotate 'line', 436
    if_null rx2858_debug, debug_1664
    rx2858_cur."!cursor_debug"("NEXT", "term:sym<redo>")
  debug_1664:
  rx2858_fail:
    (rx2858_rep, rx2858_pos, $I10, $P10) = rx2858_cur."!mark_fail"(0)
    lt rx2858_pos, -1, rx2858_done
    eq rx2858_pos, -1, rx2858_fail
    jump $I10
  rx2858_done:
    rx2858_cur."!cursor_fail"()
    if_null rx2858_debug, debug_1665
    rx2858_cur."!cursor_debug"("FAIL", "term:sym<redo>")
  debug_1665:
    .return (rx2858_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<redo>"  :subid("415_1307873304.82979") :method :outer("40_1307873304.82979")
.annotate 'line', 436
    new $P2862, "ResizablePMCArray"
    push $P2862, "redo"
    .return ($P2862)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "smartmatch" :anon :subid("416_1307873304.82979") :outer("40_1307873304.82979")
    .param pmc param_2864
    .param pmc param_2865
.annotate 'line', 1156
    .lex "self", param_2864
    .lex "$/", param_2865
.annotate 'line', 1158
    new $P2866, "Undef"
    .lex "$t", $P2866
    find_lex $P2867, "$/"
    unless_null $P2867, vivify_1666
    $P2867 = root_new ['parrot';'ResizablePMCArray']
  vivify_1666:
    set $P2868, $P2867[0]
    unless_null $P2868, vivify_1667
    new $P2868, "Undef"
  vivify_1667:
    store_lex "$t", $P2868
    find_lex $P2869, "$/"
    unless_null $P2869, vivify_1668
    $P2869 = root_new ['parrot';'ResizablePMCArray']
  vivify_1668:
    set $P2870, $P2869[1]
    unless_null $P2870, vivify_1669
    new $P2870, "Undef"
  vivify_1669:
    find_lex $P2871, "$/"
    unless_null $P2871, vivify_1670
    $P2871 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P2871
  vivify_1670:
    set $P2871[0], $P2870
    find_lex $P2872, "$t"
    unless_null $P2872, vivify_1671
    new $P2872, "Undef"
  vivify_1671:
    find_lex $P2873, "$/"
    unless_null $P2873, vivify_1672
    $P2873 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P2873
  vivify_1672:
    set $P2873[1], $P2872
.annotate 'line', 1156
    .return ($P2872)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2875"  :subid("417_1307873304.82979") :outer("10_1307873304.82979")
.annotate 'line', 1162
    .const 'Sub' $P2937 = "437_1307873304.82979" 
    capture_lex $P2937
    .const 'Sub' $P2934 = "436_1307873304.82979" 
    capture_lex $P2934
    .const 'Sub' $P2932 = "435_1307873304.82979" 
    capture_lex $P2932
    .const 'Sub' $P2929 = "434_1307873304.82979" 
    capture_lex $P2929
    .const 'Sub' $P2926 = "433_1307873304.82979" 
    capture_lex $P2926
    .const 'Sub' $P2917 = "431_1307873304.82979" 
    capture_lex $P2917
    .const 'Sub' $P2915 = "430_1307873304.82979" 
    capture_lex $P2915
    .const 'Sub' $P2907 = "428_1307873304.82979" 
    capture_lex $P2907
    .const 'Sub' $P2905 = "427_1307873304.82979" 
    capture_lex $P2905
    .const 'Sub' $P2902 = "426_1307873304.82979" 
    capture_lex $P2902
    .const 'Sub' $P2900 = "425_1307873304.82979" 
    capture_lex $P2900
    .const 'Sub' $P2893 = "423_1307873304.82979" 
    capture_lex $P2893
    .const 'Sub' $P2891 = "422_1307873304.82979" 
    capture_lex $P2891
    .const 'Sub' $P2888 = "421_1307873304.82979" 
    capture_lex $P2888
    .const 'Sub' $P2886 = "420_1307873304.82979" 
    capture_lex $P2886
    .const 'Sub' $P2879 = "418_1307873304.82979" 
    capture_lex $P2879
    .lex "$?PACKAGE", $P2877
    .lex "$?CLASS", $P2878
    .const 'Sub' $P2937 = "437_1307873304.82979" 
    capture_lex $P2937
    .return ($P2937)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<:my>"  :subid("418_1307873304.82979") :method :outer("417_1307873304.82979")
.annotate 'line', 1162
    .const 'Sub' $P2883 = "419_1307873304.82979" 
    capture_lex $P2883
    .local string rx2880_tgt
    .local int rx2880_pos
    .local int rx2880_off
    .local int rx2880_eos
    .local int rx2880_rep
    .local pmc rx2880_cur
    .local pmc rx2880_debug
    (rx2880_cur, rx2880_pos, rx2880_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2880_cur
    .local pmc match
    .lex "$/", match
    length rx2880_eos, rx2880_tgt
    gt rx2880_pos, rx2880_eos, rx2880_done
    set rx2880_off, 0
    lt rx2880_pos, 2, rx2880_start
    sub rx2880_off, rx2880_pos, 1
    substr rx2880_tgt, rx2880_tgt, rx2880_off
  rx2880_start:
    eq $I10, 1, rx2880_restart
    if_null rx2880_debug, debug_1673
    rx2880_cur."!cursor_debug"("START", "metachar:sym<:my>")
  debug_1673:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2881_done
    goto rxscan2881_scan
  rxscan2881_loop:
    (rx2880_pos) = rx2880_cur."from"()
    inc rx2880_pos
    rx2880_cur."!cursor_from"(rx2880_pos)
    ge rx2880_pos, rx2880_eos, rxscan2881_done
  rxscan2881_scan:
    set_addr $I10, rxscan2881_loop
    rx2880_cur."!mark_push"(0, rx2880_pos, $I10)
  rxscan2881_done:
.annotate 'line', 1164
  # rx literal  ":"
    add $I11, rx2880_pos, 1
    gt $I11, rx2880_eos, rx2880_fail
    sub $I11, rx2880_pos, rx2880_off
    ord $I11, rx2880_tgt, $I11
    ne $I11, 58, rx2880_fail
    add rx2880_pos, 1
  # rx subrule "before" subtype=zerowidth negate=
    rx2880_cur."!cursor_pos"(rx2880_pos)
    .const 'Sub' $P2883 = "419_1307873304.82979" 
    capture_lex $P2883
    $P10 = rx2880_cur."before"($P2883)
    unless $P10, rx2880_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2880_cur."!cursor_pos"(rx2880_pos)
    $P10 = rx2880_cur."LANG"("MAIN", "statement")
    unless $P10, rx2880_fail
    rx2880_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx2880_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2880_cur."!cursor_pos"(rx2880_pos)
    $P10 = rx2880_cur."ws"()
    unless $P10, rx2880_fail
    rx2880_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx2880_pos, 1
    gt $I11, rx2880_eos, rx2880_fail
    sub $I11, rx2880_pos, rx2880_off
    ord $I11, rx2880_tgt, $I11
    ne $I11, 59, rx2880_fail
    add rx2880_pos, 1
.annotate 'line', 1163
  # rx pass
    rx2880_cur."!cursor_pass"(rx2880_pos, "metachar:sym<:my>")
    if_null rx2880_debug, debug_1678
    rx2880_cur."!cursor_debug"("PASS", "metachar:sym<:my>", " at pos=", rx2880_pos)
  debug_1678:
    .return (rx2880_cur)
  rx2880_restart:
.annotate 'line', 1162
    if_null rx2880_debug, debug_1679
    rx2880_cur."!cursor_debug"("NEXT", "metachar:sym<:my>")
  debug_1679:
  rx2880_fail:
    (rx2880_rep, rx2880_pos, $I10, $P10) = rx2880_cur."!mark_fail"(0)
    lt rx2880_pos, -1, rx2880_done
    eq rx2880_pos, -1, rx2880_fail
    jump $I10
  rx2880_done:
    rx2880_cur."!cursor_fail"()
    if_null rx2880_debug, debug_1680
    rx2880_cur."!cursor_debug"("FAIL", "metachar:sym<:my>")
  debug_1680:
    .return (rx2880_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2882"  :anon :subid("419_1307873304.82979") :method :outer("418_1307873304.82979")
.annotate 'line', 1164
    .local string rx2884_tgt
    .local int rx2884_pos
    .local int rx2884_off
    .local int rx2884_eos
    .local int rx2884_rep
    .local pmc rx2884_cur
    .local pmc rx2884_debug
    (rx2884_cur, rx2884_pos, rx2884_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2884_cur
    .local pmc match
    .lex "$/", match
    length rx2884_eos, rx2884_tgt
    gt rx2884_pos, rx2884_eos, rx2884_done
    set rx2884_off, 0
    lt rx2884_pos, 2, rx2884_start
    sub rx2884_off, rx2884_pos, 1
    substr rx2884_tgt, rx2884_tgt, rx2884_off
  rx2884_start:
    eq $I10, 1, rx2884_restart
    if_null rx2884_debug, debug_1674
    rx2884_cur."!cursor_debug"("START", "")
  debug_1674:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2885_done
    goto rxscan2885_scan
  rxscan2885_loop:
    (rx2884_pos) = rx2884_cur."from"()
    inc rx2884_pos
    rx2884_cur."!cursor_from"(rx2884_pos)
    ge rx2884_pos, rx2884_eos, rxscan2885_done
  rxscan2885_scan:
    set_addr $I10, rxscan2885_loop
    rx2884_cur."!mark_push"(0, rx2884_pos, $I10)
  rxscan2885_done:
  # rx literal  "my"
    add $I11, rx2884_pos, 2
    gt $I11, rx2884_eos, rx2884_fail
    sub $I11, rx2884_pos, rx2884_off
    substr $S10, rx2884_tgt, $I11, 2
    ne $S10, "my", rx2884_fail
    add rx2884_pos, 2
  # rx pass
    rx2884_cur."!cursor_pass"(rx2884_pos, "")
    if_null rx2884_debug, debug_1675
    rx2884_cur."!cursor_debug"("PASS", "", " at pos=", rx2884_pos)
  debug_1675:
    .return (rx2884_cur)
  rx2884_restart:
    if_null rx2884_debug, debug_1676
    rx2884_cur."!cursor_debug"("NEXT", "")
  debug_1676:
  rx2884_fail:
    (rx2884_rep, rx2884_pos, $I10, $P10) = rx2884_cur."!mark_fail"(0)
    lt rx2884_pos, -1, rx2884_done
    eq rx2884_pos, -1, rx2884_fail
    jump $I10
  rx2884_done:
    rx2884_cur."!cursor_fail"()
    if_null rx2884_debug, debug_1677
    rx2884_cur."!cursor_debug"("FAIL", "")
  debug_1677:
    .return (rx2884_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<:my>"  :subid("420_1307873304.82979") :method :outer("417_1307873304.82979")
.annotate 'line', 1162
    new $P2887, "ResizablePMCArray"
    push $P2887, ":"
    .return ($P2887)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<{ }>"  :subid("421_1307873304.82979") :method :outer("417_1307873304.82979")
.annotate 'line', 1162
    .local string rx2889_tgt
    .local int rx2889_pos
    .local int rx2889_off
    .local int rx2889_eos
    .local int rx2889_rep
    .local pmc rx2889_cur
    .local pmc rx2889_debug
    (rx2889_cur, rx2889_pos, rx2889_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2889_cur
    .local pmc match
    .lex "$/", match
    length rx2889_eos, rx2889_tgt
    gt rx2889_pos, rx2889_eos, rx2889_done
    set rx2889_off, 0
    lt rx2889_pos, 2, rx2889_start
    sub rx2889_off, rx2889_pos, 1
    substr rx2889_tgt, rx2889_tgt, rx2889_off
  rx2889_start:
    eq $I10, 1, rx2889_restart
    if_null rx2889_debug, debug_1681
    rx2889_cur."!cursor_debug"("START", "metachar:sym<{ }>")
  debug_1681:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2890_done
    goto rxscan2890_scan
  rxscan2890_loop:
    (rx2889_pos) = rx2889_cur."from"()
    inc rx2889_pos
    rx2889_cur."!cursor_from"(rx2889_pos)
    ge rx2889_pos, rx2889_eos, rxscan2890_done
  rxscan2890_scan:
    set_addr $I10, rxscan2890_loop
    rx2889_cur."!mark_push"(0, rx2889_pos, $I10)
  rxscan2890_done:
.annotate 'line', 1168
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2889_pos, rx2889_off
    substr $S10, rx2889_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2889_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx2889_cur."!cursor_pos"(rx2889_pos)
    $P10 = rx2889_cur."codeblock"()
    unless $P10, rx2889_fail
    rx2889_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2889_pos = $P10."pos"()
.annotate 'line', 1167
  # rx pass
    rx2889_cur."!cursor_pass"(rx2889_pos, "metachar:sym<{ }>")
    if_null rx2889_debug, debug_1682
    rx2889_cur."!cursor_debug"("PASS", "metachar:sym<{ }>", " at pos=", rx2889_pos)
  debug_1682:
    .return (rx2889_cur)
  rx2889_restart:
.annotate 'line', 1162
    if_null rx2889_debug, debug_1683
    rx2889_cur."!cursor_debug"("NEXT", "metachar:sym<{ }>")
  debug_1683:
  rx2889_fail:
    (rx2889_rep, rx2889_pos, $I10, $P10) = rx2889_cur."!mark_fail"(0)
    lt rx2889_pos, -1, rx2889_done
    eq rx2889_pos, -1, rx2889_fail
    jump $I10
  rx2889_done:
    rx2889_cur."!cursor_fail"()
    if_null rx2889_debug, debug_1684
    rx2889_cur."!cursor_debug"("FAIL", "metachar:sym<{ }>")
  debug_1684:
    .return (rx2889_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<{ }>"  :subid("422_1307873304.82979") :method :outer("417_1307873304.82979")
.annotate 'line', 1162
    new $P2892, "ResizablePMCArray"
    push $P2892, "{"
    .return ($P2892)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<nqpvar>"  :subid("423_1307873304.82979") :method :outer("417_1307873304.82979")
.annotate 'line', 1162
    .const 'Sub' $P2897 = "424_1307873304.82979" 
    capture_lex $P2897
    .local string rx2894_tgt
    .local int rx2894_pos
    .local int rx2894_off
    .local int rx2894_eos
    .local int rx2894_rep
    .local pmc rx2894_cur
    .local pmc rx2894_debug
    (rx2894_cur, rx2894_pos, rx2894_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2894_cur
    .local pmc match
    .lex "$/", match
    length rx2894_eos, rx2894_tgt
    gt rx2894_pos, rx2894_eos, rx2894_done
    set rx2894_off, 0
    lt rx2894_pos, 2, rx2894_start
    sub rx2894_off, rx2894_pos, 1
    substr rx2894_tgt, rx2894_tgt, rx2894_off
  rx2894_start:
    eq $I10, 1, rx2894_restart
    if_null rx2894_debug, debug_1685
    rx2894_cur."!cursor_debug"("START", "metachar:sym<nqpvar>")
  debug_1685:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2895_done
    goto rxscan2895_scan
  rxscan2895_loop:
    (rx2894_pos) = rx2894_cur."from"()
    inc rx2894_pos
    rx2894_cur."!cursor_from"(rx2894_pos)
    ge rx2894_pos, rx2894_eos, rxscan2895_done
  rxscan2895_scan:
    set_addr $I10, rxscan2895_loop
    rx2894_cur."!mark_push"(0, rx2894_pos, $I10)
  rxscan2895_done:
.annotate 'line', 1172
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2894_pos, rx2894_off
    substr $S10, rx2894_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx2894_fail
  # rx subrule "before" subtype=zerowidth negate=
    rx2894_cur."!cursor_pos"(rx2894_pos)
    .const 'Sub' $P2897 = "424_1307873304.82979" 
    capture_lex $P2897
    $P10 = rx2894_cur."before"($P2897)
    unless $P10, rx2894_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2894_cur."!cursor_pos"(rx2894_pos)
    $P10 = rx2894_cur."LANG"("MAIN", "variable")
    unless $P10, rx2894_fail
    rx2894_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx2894_pos = $P10."pos"()
.annotate 'line', 1171
  # rx pass
    rx2894_cur."!cursor_pass"(rx2894_pos, "metachar:sym<nqpvar>")
    if_null rx2894_debug, debug_1690
    rx2894_cur."!cursor_debug"("PASS", "metachar:sym<nqpvar>", " at pos=", rx2894_pos)
  debug_1690:
    .return (rx2894_cur)
  rx2894_restart:
.annotate 'line', 1162
    if_null rx2894_debug, debug_1691
    rx2894_cur."!cursor_debug"("NEXT", "metachar:sym<nqpvar>")
  debug_1691:
  rx2894_fail:
    (rx2894_rep, rx2894_pos, $I10, $P10) = rx2894_cur."!mark_fail"(0)
    lt rx2894_pos, -1, rx2894_done
    eq rx2894_pos, -1, rx2894_fail
    jump $I10
  rx2894_done:
    rx2894_cur."!cursor_fail"()
    if_null rx2894_debug, debug_1692
    rx2894_cur."!cursor_debug"("FAIL", "metachar:sym<nqpvar>")
  debug_1692:
    .return (rx2894_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2896"  :anon :subid("424_1307873304.82979") :method :outer("423_1307873304.82979")
.annotate 'line', 1172
    .local string rx2898_tgt
    .local int rx2898_pos
    .local int rx2898_off
    .local int rx2898_eos
    .local int rx2898_rep
    .local pmc rx2898_cur
    .local pmc rx2898_debug
    (rx2898_cur, rx2898_pos, rx2898_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2898_cur
    .local pmc match
    .lex "$/", match
    length rx2898_eos, rx2898_tgt
    gt rx2898_pos, rx2898_eos, rx2898_done
    set rx2898_off, 0
    lt rx2898_pos, 2, rx2898_start
    sub rx2898_off, rx2898_pos, 1
    substr rx2898_tgt, rx2898_tgt, rx2898_off
  rx2898_start:
    eq $I10, 1, rx2898_restart
    if_null rx2898_debug, debug_1686
    rx2898_cur."!cursor_debug"("START", "")
  debug_1686:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2899_done
    goto rxscan2899_scan
  rxscan2899_loop:
    (rx2898_pos) = rx2898_cur."from"()
    inc rx2898_pos
    rx2898_cur."!cursor_from"(rx2898_pos)
    ge rx2898_pos, rx2898_eos, rxscan2899_done
  rxscan2899_scan:
    set_addr $I10, rxscan2899_loop
    rx2898_cur."!mark_push"(0, rx2898_pos, $I10)
  rxscan2899_done:
  # rx charclass .
    ge rx2898_pos, rx2898_eos, rx2898_fail
    inc rx2898_pos
  # rx charclass w
    ge rx2898_pos, rx2898_eos, rx2898_fail
    sub $I10, rx2898_pos, rx2898_off
    is_cclass $I11, .CCLASS_WORD, rx2898_tgt, $I10
    unless $I11, rx2898_fail
    inc rx2898_pos
  # rx pass
    rx2898_cur."!cursor_pass"(rx2898_pos, "")
    if_null rx2898_debug, debug_1687
    rx2898_cur."!cursor_debug"("PASS", "", " at pos=", rx2898_pos)
  debug_1687:
    .return (rx2898_cur)
  rx2898_restart:
    if_null rx2898_debug, debug_1688
    rx2898_cur."!cursor_debug"("NEXT", "")
  debug_1688:
  rx2898_fail:
    (rx2898_rep, rx2898_pos, $I10, $P10) = rx2898_cur."!mark_fail"(0)
    lt rx2898_pos, -1, rx2898_done
    eq rx2898_pos, -1, rx2898_fail
    jump $I10
  rx2898_done:
    rx2898_cur."!cursor_fail"()
    if_null rx2898_debug, debug_1689
    rx2898_cur."!cursor_debug"("FAIL", "")
  debug_1689:
    .return (rx2898_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<nqpvar>"  :subid("425_1307873304.82979") :method :outer("417_1307873304.82979")
.annotate 'line', 1162
    new $P2901, "ResizablePMCArray"
    push $P2901, "$"
    push $P2901, "@"
    .return ($P2901)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<{ }>"  :subid("426_1307873304.82979") :method :outer("417_1307873304.82979")
.annotate 'line', 1162
    .local string rx2903_tgt
    .local int rx2903_pos
    .local int rx2903_off
    .local int rx2903_eos
    .local int rx2903_rep
    .local pmc rx2903_cur
    .local pmc rx2903_debug
    (rx2903_cur, rx2903_pos, rx2903_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2903_cur
    .local pmc match
    .lex "$/", match
    length rx2903_eos, rx2903_tgt
    gt rx2903_pos, rx2903_eos, rx2903_done
    set rx2903_off, 0
    lt rx2903_pos, 2, rx2903_start
    sub rx2903_off, rx2903_pos, 1
    substr rx2903_tgt, rx2903_tgt, rx2903_off
  rx2903_start:
    eq $I10, 1, rx2903_restart
    if_null rx2903_debug, debug_1693
    rx2903_cur."!cursor_debug"("START", "assertion:sym<{ }>")
  debug_1693:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2904_done
    goto rxscan2904_scan
  rxscan2904_loop:
    (rx2903_pos) = rx2903_cur."from"()
    inc rx2903_pos
    rx2903_cur."!cursor_from"(rx2903_pos)
    ge rx2903_pos, rx2903_eos, rxscan2904_done
  rxscan2904_scan:
    set_addr $I10, rxscan2904_loop
    rx2903_cur."!mark_push"(0, rx2903_pos, $I10)
  rxscan2904_done:
.annotate 'line', 1176
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2903_pos, rx2903_off
    substr $S10, rx2903_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2903_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx2903_cur."!cursor_pos"(rx2903_pos)
    $P10 = rx2903_cur."codeblock"()
    unless $P10, rx2903_fail
    rx2903_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2903_pos = $P10."pos"()
.annotate 'line', 1175
  # rx pass
    rx2903_cur."!cursor_pass"(rx2903_pos, "assertion:sym<{ }>")
    if_null rx2903_debug, debug_1694
    rx2903_cur."!cursor_debug"("PASS", "assertion:sym<{ }>", " at pos=", rx2903_pos)
  debug_1694:
    .return (rx2903_cur)
  rx2903_restart:
.annotate 'line', 1162
    if_null rx2903_debug, debug_1695
    rx2903_cur."!cursor_debug"("NEXT", "assertion:sym<{ }>")
  debug_1695:
  rx2903_fail:
    (rx2903_rep, rx2903_pos, $I10, $P10) = rx2903_cur."!mark_fail"(0)
    lt rx2903_pos, -1, rx2903_done
    eq rx2903_pos, -1, rx2903_fail
    jump $I10
  rx2903_done:
    rx2903_cur."!cursor_fail"()
    if_null rx2903_debug, debug_1696
    rx2903_cur."!cursor_debug"("FAIL", "assertion:sym<{ }>")
  debug_1696:
    .return (rx2903_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<{ }>"  :subid("427_1307873304.82979") :method :outer("417_1307873304.82979")
.annotate 'line', 1162
    new $P2906, "ResizablePMCArray"
    push $P2906, "{"
    .return ($P2906)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<?{ }>"  :subid("428_1307873304.82979") :method :outer("417_1307873304.82979")
.annotate 'line', 1162
    .const 'Sub' $P2911 = "429_1307873304.82979" 
    capture_lex $P2911
    .local string rx2908_tgt
    .local int rx2908_pos
    .local int rx2908_off
    .local int rx2908_eos
    .local int rx2908_rep
    .local pmc rx2908_cur
    .local pmc rx2908_debug
    (rx2908_cur, rx2908_pos, rx2908_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2908_cur
    .local pmc match
    .lex "$/", match
    length rx2908_eos, rx2908_tgt
    gt rx2908_pos, rx2908_eos, rx2908_done
    set rx2908_off, 0
    lt rx2908_pos, 2, rx2908_start
    sub rx2908_off, rx2908_pos, 1
    substr rx2908_tgt, rx2908_tgt, rx2908_off
  rx2908_start:
    eq $I10, 1, rx2908_restart
    if_null rx2908_debug, debug_1697
    rx2908_cur."!cursor_debug"("START", "assertion:sym<?{ }>")
  debug_1697:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2909_done
    goto rxscan2909_scan
  rxscan2909_loop:
    (rx2908_pos) = rx2908_cur."from"()
    inc rx2908_pos
    rx2908_cur."!cursor_from"(rx2908_pos)
    ge rx2908_pos, rx2908_eos, rxscan2909_done
  rxscan2909_scan:
    set_addr $I10, rxscan2909_loop
    rx2908_cur."!mark_push"(0, rx2908_pos, $I10)
  rxscan2909_done:
.annotate 'line', 1180
  # rx subcapture "zw"
    set_addr $I10, rxcap_2914_fail
    rx2908_cur."!mark_push"(0, rx2908_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx2908_pos, rx2908_eos, rx2908_fail
    sub $I10, rx2908_pos, rx2908_off
    substr $S10, rx2908_tgt, $I10, 1
    index $I11, "?!", $S10
    lt $I11, 0, rx2908_fail
    inc rx2908_pos
  # rx subrule "before" subtype=zerowidth negate=
    rx2908_cur."!cursor_pos"(rx2908_pos)
    .const 'Sub' $P2911 = "429_1307873304.82979" 
    capture_lex $P2911
    $P10 = rx2908_cur."before"($P2911)
    unless $P10, rx2908_fail
    set_addr $I10, rxcap_2914_fail
    ($I12, $I11) = rx2908_cur."!mark_peek"($I10)
    rx2908_cur."!cursor_pos"($I11)
    ($P10) = rx2908_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2908_pos, "")
    rx2908_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("zw")
    goto rxcap_2914_done
  rxcap_2914_fail:
    goto rx2908_fail
  rxcap_2914_done:
  # rx subrule "codeblock" subtype=capture negate=
    rx2908_cur."!cursor_pos"(rx2908_pos)
    $P10 = rx2908_cur."codeblock"()
    unless $P10, rx2908_fail
    rx2908_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2908_pos = $P10."pos"()
.annotate 'line', 1179
  # rx pass
    rx2908_cur."!cursor_pass"(rx2908_pos, "assertion:sym<?{ }>")
    if_null rx2908_debug, debug_1702
    rx2908_cur."!cursor_debug"("PASS", "assertion:sym<?{ }>", " at pos=", rx2908_pos)
  debug_1702:
    .return (rx2908_cur)
  rx2908_restart:
.annotate 'line', 1162
    if_null rx2908_debug, debug_1703
    rx2908_cur."!cursor_debug"("NEXT", "assertion:sym<?{ }>")
  debug_1703:
  rx2908_fail:
    (rx2908_rep, rx2908_pos, $I10, $P10) = rx2908_cur."!mark_fail"(0)
    lt rx2908_pos, -1, rx2908_done
    eq rx2908_pos, -1, rx2908_fail
    jump $I10
  rx2908_done:
    rx2908_cur."!cursor_fail"()
    if_null rx2908_debug, debug_1704
    rx2908_cur."!cursor_debug"("FAIL", "assertion:sym<?{ }>")
  debug_1704:
    .return (rx2908_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2910"  :anon :subid("429_1307873304.82979") :method :outer("428_1307873304.82979")
.annotate 'line', 1180
    .local string rx2912_tgt
    .local int rx2912_pos
    .local int rx2912_off
    .local int rx2912_eos
    .local int rx2912_rep
    .local pmc rx2912_cur
    .local pmc rx2912_debug
    (rx2912_cur, rx2912_pos, rx2912_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2912_cur
    .local pmc match
    .lex "$/", match
    length rx2912_eos, rx2912_tgt
    gt rx2912_pos, rx2912_eos, rx2912_done
    set rx2912_off, 0
    lt rx2912_pos, 2, rx2912_start
    sub rx2912_off, rx2912_pos, 1
    substr rx2912_tgt, rx2912_tgt, rx2912_off
  rx2912_start:
    eq $I10, 1, rx2912_restart
    if_null rx2912_debug, debug_1698
    rx2912_cur."!cursor_debug"("START", "")
  debug_1698:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2913_done
    goto rxscan2913_scan
  rxscan2913_loop:
    (rx2912_pos) = rx2912_cur."from"()
    inc rx2912_pos
    rx2912_cur."!cursor_from"(rx2912_pos)
    ge rx2912_pos, rx2912_eos, rxscan2913_done
  rxscan2913_scan:
    set_addr $I10, rxscan2913_loop
    rx2912_cur."!mark_push"(0, rx2912_pos, $I10)
  rxscan2913_done:
  # rx literal  "{"
    add $I11, rx2912_pos, 1
    gt $I11, rx2912_eos, rx2912_fail
    sub $I11, rx2912_pos, rx2912_off
    ord $I11, rx2912_tgt, $I11
    ne $I11, 123, rx2912_fail
    add rx2912_pos, 1
  # rx pass
    rx2912_cur."!cursor_pass"(rx2912_pos, "")
    if_null rx2912_debug, debug_1699
    rx2912_cur."!cursor_debug"("PASS", "", " at pos=", rx2912_pos)
  debug_1699:
    .return (rx2912_cur)
  rx2912_restart:
    if_null rx2912_debug, debug_1700
    rx2912_cur."!cursor_debug"("NEXT", "")
  debug_1700:
  rx2912_fail:
    (rx2912_rep, rx2912_pos, $I10, $P10) = rx2912_cur."!mark_fail"(0)
    lt rx2912_pos, -1, rx2912_done
    eq rx2912_pos, -1, rx2912_fail
    jump $I10
  rx2912_done:
    rx2912_cur."!cursor_fail"()
    if_null rx2912_debug, debug_1701
    rx2912_cur."!cursor_debug"("FAIL", "")
  debug_1701:
    .return (rx2912_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<?{ }>"  :subid("430_1307873304.82979") :method :outer("417_1307873304.82979")
.annotate 'line', 1162
    new $P2916, "ResizablePMCArray"
    push $P2916, "!"
    push $P2916, "?"
    .return ($P2916)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<name>"  :subid("431_1307873304.82979") :method :outer("417_1307873304.82979")
.annotate 'line', 1162
    .const 'Sub' $P2923 = "432_1307873304.82979" 
    capture_lex $P2923
    .local string rx2918_tgt
    .local int rx2918_pos
    .local int rx2918_off
    .local int rx2918_eos
    .local int rx2918_rep
    .local pmc rx2918_cur
    .local pmc rx2918_debug
    (rx2918_cur, rx2918_pos, rx2918_tgt, $I10) = self."!cursor_start"()
    rx2918_cur."!cursor_caparray"("assertion", "arglist", "nibbler")
    .lex unicode:"$\x{a2}", rx2918_cur
    .local pmc match
    .lex "$/", match
    length rx2918_eos, rx2918_tgt
    gt rx2918_pos, rx2918_eos, rx2918_done
    set rx2918_off, 0
    lt rx2918_pos, 2, rx2918_start
    sub rx2918_off, rx2918_pos, 1
    substr rx2918_tgt, rx2918_tgt, rx2918_off
  rx2918_start:
    eq $I10, 1, rx2918_restart
    if_null rx2918_debug, debug_1705
    rx2918_cur."!cursor_debug"("START", "assertion:sym<name>")
  debug_1705:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2919_done
    goto rxscan2919_scan
  rxscan2919_loop:
    (rx2918_pos) = rx2918_cur."from"()
    inc rx2918_pos
    rx2918_cur."!cursor_from"(rx2918_pos)
    ge rx2918_pos, rx2918_eos, rxscan2919_done
  rxscan2919_scan:
    set_addr $I10, rxscan2919_loop
    rx2918_cur."!mark_push"(0, rx2918_pos, $I10)
  rxscan2919_done:
.annotate 'line', 1184
  # rx subrule "identifier" subtype=capture negate=
    rx2918_cur."!cursor_pos"(rx2918_pos)
    $P10 = rx2918_cur."identifier"()
    unless $P10, rx2918_fail
    rx2918_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx2918_pos = $P10."pos"()
.annotate 'line', 1191
  # rx rxquantr2920 ** 0..1
    set_addr $I10, rxquantr2920_done
    rx2918_cur."!mark_push"(0, rx2918_pos, $I10)
  rxquantr2920_loop:
  alt2921_0:
.annotate 'line', 1185
    set_addr $I10, alt2921_1
    rx2918_cur."!mark_push"(0, rx2918_pos, $I10)
.annotate 'line', 1186
  # rx subrule "before" subtype=zerowidth negate=
    rx2918_cur."!cursor_pos"(rx2918_pos)
    .const 'Sub' $P2923 = "432_1307873304.82979" 
    capture_lex $P2923
    $P10 = rx2918_cur."before"($P2923)
    unless $P10, rx2918_fail
    goto alt2921_end
  alt2921_1:
    set_addr $I10, alt2921_2
    rx2918_cur."!mark_push"(0, rx2918_pos, $I10)
.annotate 'line', 1187
  # rx literal  "="
    add $I11, rx2918_pos, 1
    gt $I11, rx2918_eos, rx2918_fail
    sub $I11, rx2918_pos, rx2918_off
    ord $I11, rx2918_tgt, $I11
    ne $I11, 61, rx2918_fail
    add rx2918_pos, 1
  # rx subrule "assertion" subtype=capture negate=
    rx2918_cur."!cursor_pos"(rx2918_pos)
    $P10 = rx2918_cur."assertion"()
    unless $P10, rx2918_fail
    rx2918_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("assertion")
    rx2918_pos = $P10."pos"()
    goto alt2921_end
  alt2921_2:
    set_addr $I10, alt2921_3
    rx2918_cur."!mark_push"(0, rx2918_pos, $I10)
.annotate 'line', 1188
  # rx literal  ":"
    add $I11, rx2918_pos, 1
    gt $I11, rx2918_eos, rx2918_fail
    sub $I11, rx2918_pos, rx2918_off
    ord $I11, rx2918_tgt, $I11
    ne $I11, 58, rx2918_fail
    add rx2918_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx2918_cur."!cursor_pos"(rx2918_pos)
    $P10 = rx2918_cur."arglist"()
    unless $P10, rx2918_fail
    rx2918_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2918_pos = $P10."pos"()
    goto alt2921_end
  alt2921_3:
    set_addr $I10, alt2921_4
    rx2918_cur."!mark_push"(0, rx2918_pos, $I10)
.annotate 'line', 1189
  # rx literal  "("
    add $I11, rx2918_pos, 1
    gt $I11, rx2918_eos, rx2918_fail
    sub $I11, rx2918_pos, rx2918_off
    ord $I11, rx2918_tgt, $I11
    ne $I11, 40, rx2918_fail
    add rx2918_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx2918_cur."!cursor_pos"(rx2918_pos)
    $P10 = rx2918_cur."LANG"("MAIN", "arglist")
    unless $P10, rx2918_fail
    rx2918_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2918_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx2918_pos, 1
    gt $I11, rx2918_eos, rx2918_fail
    sub $I11, rx2918_pos, rx2918_off
    ord $I11, rx2918_tgt, $I11
    ne $I11, 41, rx2918_fail
    add rx2918_pos, 1
    goto alt2921_end
  alt2921_4:
.annotate 'line', 1190
  # rx subrule "normspace" subtype=method negate=
    rx2918_cur."!cursor_pos"(rx2918_pos)
    $P10 = rx2918_cur."normspace"()
    unless $P10, rx2918_fail
    rx2918_pos = $P10."pos"()
  # rx subrule "nibbler" subtype=capture negate=
    rx2918_cur."!cursor_pos"(rx2918_pos)
    $P10 = rx2918_cur."nibbler"()
    unless $P10, rx2918_fail
    rx2918_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("nibbler")
    rx2918_pos = $P10."pos"()
  alt2921_end:
.annotate 'line', 1191
    set_addr $I10, rxquantr2920_done
    (rx2918_rep) = rx2918_cur."!mark_commit"($I10)
  rxquantr2920_done:
.annotate 'line', 1183
  # rx pass
    rx2918_cur."!cursor_pass"(rx2918_pos, "assertion:sym<name>")
    if_null rx2918_debug, debug_1710
    rx2918_cur."!cursor_debug"("PASS", "assertion:sym<name>", " at pos=", rx2918_pos)
  debug_1710:
    .return (rx2918_cur)
  rx2918_restart:
.annotate 'line', 1162
    if_null rx2918_debug, debug_1711
    rx2918_cur."!cursor_debug"("NEXT", "assertion:sym<name>")
  debug_1711:
  rx2918_fail:
    (rx2918_rep, rx2918_pos, $I10, $P10) = rx2918_cur."!mark_fail"(0)
    lt rx2918_pos, -1, rx2918_done
    eq rx2918_pos, -1, rx2918_fail
    jump $I10
  rx2918_done:
    rx2918_cur."!cursor_fail"()
    if_null rx2918_debug, debug_1712
    rx2918_cur."!cursor_debug"("FAIL", "assertion:sym<name>")
  debug_1712:
    .return (rx2918_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2922"  :anon :subid("432_1307873304.82979") :method :outer("431_1307873304.82979")
.annotate 'line', 1186
    .local string rx2924_tgt
    .local int rx2924_pos
    .local int rx2924_off
    .local int rx2924_eos
    .local int rx2924_rep
    .local pmc rx2924_cur
    .local pmc rx2924_debug
    (rx2924_cur, rx2924_pos, rx2924_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2924_cur
    .local pmc match
    .lex "$/", match
    length rx2924_eos, rx2924_tgt
    gt rx2924_pos, rx2924_eos, rx2924_done
    set rx2924_off, 0
    lt rx2924_pos, 2, rx2924_start
    sub rx2924_off, rx2924_pos, 1
    substr rx2924_tgt, rx2924_tgt, rx2924_off
  rx2924_start:
    eq $I10, 1, rx2924_restart
    if_null rx2924_debug, debug_1706
    rx2924_cur."!cursor_debug"("START", "")
  debug_1706:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2925_done
    goto rxscan2925_scan
  rxscan2925_loop:
    (rx2924_pos) = rx2924_cur."from"()
    inc rx2924_pos
    rx2924_cur."!cursor_from"(rx2924_pos)
    ge rx2924_pos, rx2924_eos, rxscan2925_done
  rxscan2925_scan:
    set_addr $I10, rxscan2925_loop
    rx2924_cur."!mark_push"(0, rx2924_pos, $I10)
  rxscan2925_done:
  # rx literal  ">"
    add $I11, rx2924_pos, 1
    gt $I11, rx2924_eos, rx2924_fail
    sub $I11, rx2924_pos, rx2924_off
    ord $I11, rx2924_tgt, $I11
    ne $I11, 62, rx2924_fail
    add rx2924_pos, 1
  # rx pass
    rx2924_cur."!cursor_pass"(rx2924_pos, "")
    if_null rx2924_debug, debug_1707
    rx2924_cur."!cursor_debug"("PASS", "", " at pos=", rx2924_pos)
  debug_1707:
    .return (rx2924_cur)
  rx2924_restart:
    if_null rx2924_debug, debug_1708
    rx2924_cur."!cursor_debug"("NEXT", "")
  debug_1708:
  rx2924_fail:
    (rx2924_rep, rx2924_pos, $I10, $P10) = rx2924_cur."!mark_fail"(0)
    lt rx2924_pos, -1, rx2924_done
    eq rx2924_pos, -1, rx2924_fail
    jump $I10
  rx2924_done:
    rx2924_cur."!cursor_fail"()
    if_null rx2924_debug, debug_1709
    rx2924_cur."!cursor_debug"("FAIL", "")
  debug_1709:
    .return (rx2924_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<name>"  :subid("433_1307873304.82979") :method :outer("417_1307873304.82979")
.annotate 'line', 1162
    $P2927 = self."!PREFIX__!subrule"("identifier", "")
    new $P2928, "ResizablePMCArray"
    push $P2928, $P2927
    .return ($P2928)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<var>"  :subid("434_1307873304.82979") :method :outer("417_1307873304.82979")
.annotate 'line', 1162
    .local string rx2930_tgt
    .local int rx2930_pos
    .local int rx2930_off
    .local int rx2930_eos
    .local int rx2930_rep
    .local pmc rx2930_cur
    .local pmc rx2930_debug
    (rx2930_cur, rx2930_pos, rx2930_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2930_cur
    .local pmc match
    .lex "$/", match
    length rx2930_eos, rx2930_tgt
    gt rx2930_pos, rx2930_eos, rx2930_done
    set rx2930_off, 0
    lt rx2930_pos, 2, rx2930_start
    sub rx2930_off, rx2930_pos, 1
    substr rx2930_tgt, rx2930_tgt, rx2930_off
  rx2930_start:
    eq $I10, 1, rx2930_restart
    if_null rx2930_debug, debug_1713
    rx2930_cur."!cursor_debug"("START", "assertion:sym<var>")
  debug_1713:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2931_done
    goto rxscan2931_scan
  rxscan2931_loop:
    (rx2930_pos) = rx2930_cur."from"()
    inc rx2930_pos
    rx2930_cur."!cursor_from"(rx2930_pos)
    ge rx2930_pos, rx2930_eos, rxscan2931_done
  rxscan2931_scan:
    set_addr $I10, rxscan2931_loop
    rx2930_cur."!mark_push"(0, rx2930_pos, $I10)
  rxscan2931_done:
.annotate 'line', 1195
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2930_pos, rx2930_off
    substr $S10, rx2930_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx2930_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2930_cur."!cursor_pos"(rx2930_pos)
    $P10 = rx2930_cur."LANG"("MAIN", "variable")
    unless $P10, rx2930_fail
    rx2930_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx2930_pos = $P10."pos"()
.annotate 'line', 1194
  # rx pass
    rx2930_cur."!cursor_pass"(rx2930_pos, "assertion:sym<var>")
    if_null rx2930_debug, debug_1714
    rx2930_cur."!cursor_debug"("PASS", "assertion:sym<var>", " at pos=", rx2930_pos)
  debug_1714:
    .return (rx2930_cur)
  rx2930_restart:
.annotate 'line', 1162
    if_null rx2930_debug, debug_1715
    rx2930_cur."!cursor_debug"("NEXT", "assertion:sym<var>")
  debug_1715:
  rx2930_fail:
    (rx2930_rep, rx2930_pos, $I10, $P10) = rx2930_cur."!mark_fail"(0)
    lt rx2930_pos, -1, rx2930_done
    eq rx2930_pos, -1, rx2930_fail
    jump $I10
  rx2930_done:
    rx2930_cur."!cursor_fail"()
    if_null rx2930_debug, debug_1716
    rx2930_cur."!cursor_debug"("FAIL", "assertion:sym<var>")
  debug_1716:
    .return (rx2930_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<var>"  :subid("435_1307873304.82979") :method :outer("417_1307873304.82979")
.annotate 'line', 1162
    new $P2933, "ResizablePMCArray"
    push $P2933, "$"
    push $P2933, "@"
    .return ($P2933)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "codeblock"  :subid("436_1307873304.82979") :method :outer("417_1307873304.82979")
.annotate 'line', 1162
    .local string rx2935_tgt
    .local int rx2935_pos
    .local int rx2935_off
    .local int rx2935_eos
    .local int rx2935_rep
    .local pmc rx2935_cur
    .local pmc rx2935_debug
    (rx2935_cur, rx2935_pos, rx2935_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2935_cur
    .local pmc match
    .lex "$/", match
    length rx2935_eos, rx2935_tgt
    gt rx2935_pos, rx2935_eos, rx2935_done
    set rx2935_off, 0
    lt rx2935_pos, 2, rx2935_start
    sub rx2935_off, rx2935_pos, 1
    substr rx2935_tgt, rx2935_tgt, rx2935_off
  rx2935_start:
    eq $I10, 1, rx2935_restart
    if_null rx2935_debug, debug_1717
    rx2935_cur."!cursor_debug"("START", "codeblock")
  debug_1717:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2936_done
    goto rxscan2936_scan
  rxscan2936_loop:
    (rx2935_pos) = rx2935_cur."from"()
    inc rx2935_pos
    rx2935_cur."!cursor_from"(rx2935_pos)
    ge rx2935_pos, rx2935_eos, rxscan2936_done
  rxscan2936_scan:
    set_addr $I10, rxscan2936_loop
    rx2935_cur."!mark_push"(0, rx2935_pos, $I10)
  rxscan2936_done:
.annotate 'line', 1199
  # rx subrule "LANG" subtype=capture negate=
    rx2935_cur."!cursor_pos"(rx2935_pos)
    $P10 = rx2935_cur."LANG"("MAIN", "pblock")
    unless $P10, rx2935_fail
    rx2935_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx2935_pos = $P10."pos"()
.annotate 'line', 1198
  # rx pass
    rx2935_cur."!cursor_pass"(rx2935_pos, "codeblock")
    if_null rx2935_debug, debug_1718
    rx2935_cur."!cursor_debug"("PASS", "codeblock", " at pos=", rx2935_pos)
  debug_1718:
    .return (rx2935_cur)
  rx2935_restart:
.annotate 'line', 1162
    if_null rx2935_debug, debug_1719
    rx2935_cur."!cursor_debug"("NEXT", "codeblock")
  debug_1719:
  rx2935_fail:
    (rx2935_rep, rx2935_pos, $I10, $P10) = rx2935_cur."!mark_fail"(0)
    lt rx2935_pos, -1, rx2935_done
    eq rx2935_pos, -1, rx2935_fail
    jump $I10
  rx2935_done:
    rx2935_cur."!cursor_fail"()
    if_null rx2935_debug, debug_1720
    rx2935_cur."!cursor_debug"("FAIL", "codeblock")
  debug_1720:
    .return (rx2935_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__codeblock"  :subid("437_1307873304.82979") :method :outer("417_1307873304.82979")
.annotate 'line', 1162
    $P2938 = self."!PREFIX__!subrule"("LANG", "")
    new $P2939, "ResizablePMCArray"
    push $P2939, $P2938
    .return ($P2939)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2940"  :subid("438_1307873304.82979") :outer("10_1307873304.82979")
.annotate 'line', 1205
    .const 'Sub' $P7189 = "617_1307873304.82979" 
    capture_lex $P7189
    .const 'Sub' $P7174 = "616_1307873304.82979" 
    capture_lex $P7174
    .const 'Sub' $P7169 = "615_1307873304.82979" 
    capture_lex $P7169
    .const 'Sub' $P7164 = "614_1307873304.82979" 
    capture_lex $P7164
    .const 'Sub' $P7159 = "613_1307873304.82979" 
    capture_lex $P7159
    .const 'Sub' $P7142 = "612_1307873304.82979" 
    capture_lex $P7142
    .const 'Sub' $P7131 = "611_1307873304.82979" 
    capture_lex $P7131
    .const 'Sub' $P7120 = "610_1307873304.82979" 
    capture_lex $P7120
    .const 'Sub' $P7112 = "609_1307873304.82979" 
    capture_lex $P7112
    .const 'Sub' $P7107 = "608_1307873304.82979" 
    capture_lex $P7107
    .const 'Sub' $P7092 = "607_1307873304.82979" 
    capture_lex $P7092
    .const 'Sub' $P7084 = "606_1307873304.82979" 
    capture_lex $P7084
    .const 'Sub' $P7026 = "605_1307873304.82979" 
    capture_lex $P7026
    .const 'Sub' $P7011 = "604_1307873304.82979" 
    capture_lex $P7011
    .const 'Sub' $P7003 = "603_1307873304.82979" 
    capture_lex $P7003
    .const 'Sub' $P6995 = "602_1307873304.82979" 
    capture_lex $P6995
    .const 'Sub' $P6987 = "601_1307873304.82979" 
    capture_lex $P6987
    .const 'Sub' $P6979 = "600_1307873304.82979" 
    capture_lex $P6979
    .const 'Sub' $P6971 = "599_1307873304.82979" 
    capture_lex $P6971
    .const 'Sub' $P6942 = "598_1307873304.82979" 
    capture_lex $P6942
    .const 'Sub' $P6927 = "597_1307873304.82979" 
    capture_lex $P6927
    .const 'Sub' $P6919 = "596_1307873304.82979" 
    capture_lex $P6919
    .const 'Sub' $P6905 = "595_1307873304.82979" 
    capture_lex $P6905
    .const 'Sub' $P6891 = "594_1307873304.82979" 
    capture_lex $P6891
    .const 'Sub' $P6877 = "593_1307873304.82979" 
    capture_lex $P6877
    .const 'Sub' $P6869 = "592_1307873304.82979" 
    capture_lex $P6869
    .const 'Sub' $P6839 = "591_1307873304.82979" 
    capture_lex $P6839
    .const 'Sub' $P6801 = "589_1307873304.82979" 
    capture_lex $P6801
    .const 'Sub' $P6793 = "588_1307873304.82979" 
    capture_lex $P6793
    .const 'Sub' $P6785 = "587_1307873304.82979" 
    capture_lex $P6785
    .const 'Sub' $P6754 = "586_1307873304.82979" 
    capture_lex $P6754
    .const 'Sub' $P6735 = "585_1307873304.82979" 
    capture_lex $P6735
    .const 'Sub' $P6727 = "584_1307873304.82979" 
    capture_lex $P6727
    .const 'Sub' $P6719 = "583_1307873304.82979" 
    capture_lex $P6719
    .const 'Sub' $P6611 = "580_1307873304.82979" 
    capture_lex $P6611
    .const 'Sub' $P6603 = "579_1307873304.82979" 
    capture_lex $P6603
    .const 'Sub' $P6593 = "578_1307873304.82979" 
    capture_lex $P6593
    .const 'Sub' $P6579 = "577_1307873304.82979" 
    capture_lex $P6579
    .const 'Sub' $P6545 = "576_1307873304.82979" 
    capture_lex $P6545
    .const 'Sub' $P6503 = "574_1307873304.82979" 
    capture_lex $P6503
    .const 'Sub' $P6489 = "573_1307873304.82979" 
    capture_lex $P6489
    .const 'Sub' $P6479 = "572_1307873304.82979" 
    capture_lex $P6479
    .const 'Sub' $P6427 = "571_1307873304.82979" 
    capture_lex $P6427
    .const 'Sub' $P6198 = "566_1307873304.82979" 
    capture_lex $P6198
    .const 'Sub' $P6080 = "561_1307873304.82979" 
    capture_lex $P6080
    .const 'Sub' $P6072 = "560_1307873304.82979" 
    capture_lex $P6072
    .const 'Sub' $P6028 = "558_1307873304.82979" 
    capture_lex $P6028
    .const 'Sub' $P6013 = "557_1307873304.82979" 
    capture_lex $P6013
    .const 'Sub' $P5990 = "556_1307873304.82979" 
    capture_lex $P5990
    .const 'Sub' $P5887 = "555_1307873304.82979" 
    capture_lex $P5887
    .const 'Sub' $P5833 = "552_1307873304.82979" 
    capture_lex $P5833
    .const 'Sub' $P5691 = "549_1307873304.82979" 
    capture_lex $P5691
    .const 'Sub' $P5364 = "542_1307873304.82979" 
    capture_lex $P5364
    .const 'Sub' $P5356 = "541_1307873304.82979" 
    capture_lex $P5356
    .const 'Sub' $P5348 = "540_1307873304.82979" 
    capture_lex $P5348
    .const 'Sub' $P5205 = "537_1307873304.82979" 
    capture_lex $P5205
    .const 'Sub' $P5197 = "536_1307873304.82979" 
    capture_lex $P5197
    .const 'Sub' $P5182 = "535_1307873304.82979" 
    capture_lex $P5182
    .const 'Sub' $P5167 = "534_1307873304.82979" 
    capture_lex $P5167
    .const 'Sub' $P5152 = "533_1307873304.82979" 
    capture_lex $P5152
    .const 'Sub' $P5130 = "532_1307873304.82979" 
    capture_lex $P5130
    .const 'Sub' $P5122 = "531_1307873304.82979" 
    capture_lex $P5122
    .const 'Sub' $P5114 = "530_1307873304.82979" 
    capture_lex $P5114
    .const 'Sub' $P5106 = "529_1307873304.82979" 
    capture_lex $P5106
    .const 'Sub' $P4872 = "523_1307873304.82979" 
    capture_lex $P4872
    .const 'Sub' $P4773 = "522_1307873304.82979" 
    capture_lex $P4773
    .const 'Sub' $P4765 = "521_1307873304.82979" 
    capture_lex $P4765
    .const 'Sub' $P4757 = "520_1307873304.82979" 
    capture_lex $P4757
    .const 'Sub' $P4749 = "519_1307873304.82979" 
    capture_lex $P4749
    .const 'Sub' $P4741 = "518_1307873304.82979" 
    capture_lex $P4741
    .const 'Sub' $P4733 = "517_1307873304.82979" 
    capture_lex $P4733
    .const 'Sub' $P4725 = "516_1307873304.82979" 
    capture_lex $P4725
    .const 'Sub' $P4523 = "510_1307873304.82979" 
    capture_lex $P4523
    .const 'Sub' $P4496 = "509_1307873304.82979" 
    capture_lex $P4496
    .const 'Sub' $P4482 = "508_1307873304.82979" 
    capture_lex $P4482
    .const 'Sub' $P4474 = "507_1307873304.82979" 
    capture_lex $P4474
    .const 'Sub' $P4466 = "506_1307873304.82979" 
    capture_lex $P4466
    .const 'Sub' $P4458 = "505_1307873304.82979" 
    capture_lex $P4458
    .const 'Sub' $P4450 = "504_1307873304.82979" 
    capture_lex $P4450
    .const 'Sub' $P4442 = "503_1307873304.82979" 
    capture_lex $P4442
    .const 'Sub' $P4434 = "502_1307873304.82979" 
    capture_lex $P4434
    .const 'Sub' $P4426 = "501_1307873304.82979" 
    capture_lex $P4426
    .const 'Sub' $P4418 = "500_1307873304.82979" 
    capture_lex $P4418
    .const 'Sub' $P4410 = "499_1307873304.82979" 
    capture_lex $P4410
    .const 'Sub' $P4402 = "498_1307873304.82979" 
    capture_lex $P4402
    .const 'Sub' $P4394 = "497_1307873304.82979" 
    capture_lex $P4394
    .const 'Sub' $P4386 = "496_1307873304.82979" 
    capture_lex $P4386
    .const 'Sub' $P4378 = "495_1307873304.82979" 
    capture_lex $P4378
    .const 'Sub' $P4362 = "494_1307873304.82979" 
    capture_lex $P4362
    .const 'Sub' $P4308 = "493_1307873304.82979" 
    capture_lex $P4308
    .const 'Sub' $P4291 = "492_1307873304.82979" 
    capture_lex $P4291
    .const 'Sub' $P4267 = "491_1307873304.82979" 
    capture_lex $P4267
    .const 'Sub' $P4244 = "490_1307873304.82979" 
    capture_lex $P4244
    .const 'Sub' $P4217 = "489_1307873304.82979" 
    capture_lex $P4217
    .const 'Sub' $P4180 = "488_1307873304.82979" 
    capture_lex $P4180
    .const 'Sub' $P4165 = "487_1307873304.82979" 
    capture_lex $P4165
    .const 'Sub' $P4153 = "486_1307873304.82979" 
    capture_lex $P4153
    .const 'Sub' $P4102 = "484_1307873304.82979" 
    capture_lex $P4102
    .const 'Sub' $P4077 = "483_1307873304.82979" 
    capture_lex $P4077
    .const 'Sub' $P4070 = "482_1307873304.82979" 
    capture_lex $P4070
    .const 'Sub' $P4028 = "481_1307873304.82979" 
    capture_lex $P4028
    .const 'Sub' $P3978 = "479_1307873304.82979" 
    capture_lex $P3978
    .const 'Sub' $P3961 = "478_1307873304.82979" 
    capture_lex $P3961
    .const 'Sub' $P3922 = "476_1307873304.82979" 
    capture_lex $P3922
    .const 'Sub' $P3914 = "475_1307873304.82979" 
    capture_lex $P3914
    .const 'Sub' $P3906 = "474_1307873304.82979" 
    capture_lex $P3906
    .const 'Sub' $P3889 = "473_1307873304.82979" 
    capture_lex $P3889
    .const 'Sub' $P3793 = "471_1307873304.82979" 
    capture_lex $P3793
    .const 'Sub' $P3749 = "469_1307873304.82979" 
    capture_lex $P3749
    .const 'Sub' $P3572 = "467_1307873304.82979" 
    capture_lex $P3572
    .const 'Sub' $P3541 = "466_1307873304.82979" 
    capture_lex $P3541
    .const 'Sub' $P3533 = "465_1307873304.82979" 
    capture_lex $P3533
    .const 'Sub' $P3405 = "459_1307873304.82979" 
    capture_lex $P3405
    .const 'Sub' $P3370 = "457_1307873304.82979" 
    capture_lex $P3370
    .const 'Sub' $P3365 = "456_1307873304.82979" 
    capture_lex $P3365
    .const 'Sub' $P3360 = "455_1307873304.82979" 
    capture_lex $P3360
    .const 'Sub' $P3247 = "452_1307873304.82979" 
    capture_lex $P3247
    .const 'Sub' $P3229 = "451_1307873304.82979" 
    capture_lex $P3229
    .const 'Sub' $P3154 = "449_1307873304.82979" 
    capture_lex $P3154
    .const 'Sub' $P3139 = "448_1307873304.82979" 
    capture_lex $P3139
    .const 'Sub' $P3052 = "447_1307873304.82979" 
    capture_lex $P3052
    .const 'Sub' $P3026 = "445_1307873304.82979" 
    capture_lex $P3026
    .const 'Sub' $P3010 = "444_1307873304.82979" 
    capture_lex $P3010
    .const 'Sub' $P2986 = "443_1307873304.82979" 
    capture_lex $P2986
    .const 'Sub' $P2950 = "440_1307873304.82979" 
    capture_lex $P2950
    .const 'Sub' $P2942 = "439_1307873304.82979" 
    capture_lex $P2942
.annotate 'line', 1209
    .const 'Sub' $P2942 = "439_1307873304.82979" 
    newclosure $P2949, $P2942
    .lex "xblock_immediate", $P2949
.annotate 'line', 1214
    .const 'Sub' $P2950 = "440_1307873304.82979" 
    newclosure $P2985, $P2950
    .lex "block_immediate", $P2985
.annotate 'line', 1224
    .const 'Sub' $P2986 = "443_1307873304.82979" 
    newclosure $P3009, $P2986
    .lex "vivitype", $P3009
.annotate 'line', 1243
    .const 'Sub' $P3010 = "444_1307873304.82979" 
    newclosure $P3025, $P3010
    .lex "colonpair_str", $P3025
.annotate 'line', 1422
    .const 'Sub' $P3026 = "445_1307873304.82979" 
    newclosure $P3051, $P3026
    .lex "import_HOW_exports", $P3051
.annotate 'line', 1527
    .const 'Sub' $P3052 = "447_1307873304.82979" 
    newclosure $P3138, $P3052
    .lex "push_block_handler", $P3138
.annotate 'line', 2072
    .const 'Sub' $P3139 = "448_1307873304.82979" 
    newclosure $P3153, $P3139
    .lex "only_star_block", $P3153
.annotate 'line', 2081
    .const 'Sub' $P3154 = "449_1307873304.82979" 
    newclosure $P3228, $P3154
    .lex "attach_multi_signature", $P3228
.annotate 'line', 2548
    .const 'Sub' $P3229 = "451_1307873304.82979" 
    newclosure $P3246, $P3229
    .lex "control", $P3246
.annotate 'line', 2567
    .const 'Sub' $P3247 = "452_1307873304.82979" 
    newclosure $P3359, $P3247
    .lex "lexical_package_lookup", $P3359
.annotate 'line', 2616
    .const 'Sub' $P3360 = "455_1307873304.82979" 
    newclosure $P3364, $P3360
    .lex "is_lexical", $P3364
.annotate 'line', 2622
    .const 'Sub' $P3365 = "456_1307873304.82979" 
    newclosure $P3369, $P3365
    .lex "is_package", $P3369
.annotate 'line', 2628
    .const 'Sub' $P3370 = "457_1307873304.82979" 
    newclosure $P3404, $P3370
    .lex "is_scope", $P3404
.annotate 'line', 2651
    .const 'Sub' $P3405 = "459_1307873304.82979" 
    newclosure $P3524, $P3405
    .lex "find_sym", $P3524
.annotate 'line', 1205
    .lex "$?PACKAGE", $P3525
    .lex "$?CLASS", $P3526
.annotate 'line', 1207
    new $P3527, "ResizablePMCArray"
    find_lex $P3528, "$?PACKAGE"
    get_who $P3529, $P3528
    set $P3529["@BLOCK"], $P3527
    find_lex $P3530, "xblock_immediate"
    find_lex $P3531, "block_immediate"
    find_lex $P3532, "vivitype"
.annotate 'line', 1235
    find_lex $P3571, "colonpair_str"
.annotate 'line', 1405
    find_lex $P4027, "import_HOW_exports"
.annotate 'line', 1520
    find_lex $P4290, "push_block_handler"
.annotate 'line', 2013
    find_lex $P5831, "only_star_block"
    find_lex $P5832, "attach_multi_signature"
.annotate 'line', 2539
    find_lex $P7158, "control"
.annotate 'line', 2561
    find_lex $P7185, "lexical_package_lookup"
    find_lex $P7186, "is_lexical"
    find_lex $P7187, "is_package"
    find_lex $P7188, "is_scope"
.annotate 'line', 2639
    find_lex $P7208, "find_sym"
.annotate 'line', 1205
    .return ($P7208)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock_immediate"  :subid("439_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_2943
.annotate 'line', 1209
    .lex "$xblock", param_2943
.annotate 'line', 1210
    find_lex $P2944, "$xblock"
    unless_null $P2944, vivify_1721
    $P2944 = root_new ['parrot';'ResizablePMCArray']
  vivify_1721:
    set $P2945, $P2944[1]
    unless_null $P2945, vivify_1722
    new $P2945, "Undef"
  vivify_1722:
    $P2946 = "block_immediate"($P2945)
    find_lex $P2947, "$xblock"
    unless_null $P2947, vivify_1723
    $P2947 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$xblock", $P2947
  vivify_1723:
    set $P2947[1], $P2946
    find_lex $P2948, "$xblock"
    unless_null $P2948, vivify_1724
    new $P2948, "Undef"
  vivify_1724:
.annotate 'line', 1209
    .return ($P2948)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block_immediate"  :subid("440_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_2951
.annotate 'line', 1214
    .const 'Sub' $P2961 = "441_1307873304.82979" 
    capture_lex $P2961
    .lex "$block", param_2951
.annotate 'line', 1215
    find_lex $P2952, "$block"
    unless_null $P2952, vivify_1725
    new $P2952, "Undef"
  vivify_1725:
    $P2952."blocktype"("immediate")
.annotate 'line', 1216
    find_lex $P2956, "$block"
    unless_null $P2956, vivify_1726
    new $P2956, "Undef"
  vivify_1726:
    $P2957 = $P2956."symtable"()
    unless $P2957, unless_2955
    set $P2954, $P2957
    goto unless_2955_end
  unless_2955:
    find_lex $P2958, "$block"
    unless_null $P2958, vivify_1727
    new $P2958, "Undef"
  vivify_1727:
    $P2959 = $P2958."handlers"()
    set $P2954, $P2959
  unless_2955_end:
    if $P2954, unless_2953_end
    .const 'Sub' $P2961 = "441_1307873304.82979" 
    capture_lex $P2961
    $P2961()
  unless_2953_end:
    find_lex $P2984, "$block"
    unless_null $P2984, vivify_1734
    new $P2984, "Undef"
  vivify_1734:
.annotate 'line', 1214
    .return ($P2984)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2960"  :anon :subid("441_1307873304.82979") :outer("440_1307873304.82979")
.annotate 'line', 1216
    .const 'Sub' $P2975 = "442_1307873304.82979" 
    capture_lex $P2975
.annotate 'line', 1217
    new $P2962, "Undef"
    .lex "$stmts", $P2962
    get_hll_global $P2963, "GLOBAL"
    nqp_get_package_through_who $P2964, $P2963, "PAST"
    get_who $P2965, $P2964
    set $P2966, $P2965["Stmts"]
    find_lex $P2967, "$block"
    unless_null $P2967, vivify_1728
    new $P2967, "Undef"
  vivify_1728:
    $P2968 = $P2966."new"($P2967 :named("node"))
    store_lex "$stmts", $P2968
.annotate 'line', 1218
    find_lex $P2970, "$block"
    unless_null $P2970, vivify_1729
    new $P2970, "Undef"
  vivify_1729:
    $P2971 = $P2970."list"()
    defined $I2972, $P2971
    unless $I2972, for_undef_1730
    iter $P2969, $P2971
    new $P2981, 'ExceptionHandler'
    set_label $P2981, loop2980_handler
    $P2981."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2981
  loop2980_test:
    unless $P2969, loop2980_done
    shift $P2973, $P2969
  loop2980_redo:
    .const 'Sub' $P2975 = "442_1307873304.82979" 
    capture_lex $P2975
    $P2975($P2973)
  loop2980_next:
    goto loop2980_test
  loop2980_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2982, exception, 'type'
    eq $P2982, .CONTROL_LOOP_NEXT, loop2980_next
    eq $P2982, .CONTROL_LOOP_REDO, loop2980_redo
  loop2980_done:
    pop_eh 
  for_undef_1730:
.annotate 'line', 1219
    find_lex $P2983, "$stmts"
    unless_null $P2983, vivify_1733
    new $P2983, "Undef"
  vivify_1733:
    store_lex "$block", $P2983
.annotate 'line', 1216
    .return ($P2983)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2974"  :anon :subid("442_1307873304.82979") :outer("441_1307873304.82979")
    .param pmc param_2976
.annotate 'line', 1218
    .lex "$_", param_2976
    find_lex $P2977, "$stmts"
    unless_null $P2977, vivify_1731
    new $P2977, "Undef"
  vivify_1731:
    find_lex $P2978, "$_"
    unless_null $P2978, vivify_1732
    new $P2978, "Undef"
  vivify_1732:
    $P2979 = $P2977."push"($P2978)
    .return ($P2979)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "vivitype"  :subid("443_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_2987
.annotate 'line', 1224
    .lex "$sigil", param_2987
.annotate 'line', 1225
    find_lex $P2990, "$sigil"
    unless_null $P2990, vivify_1735
    new $P2990, "Undef"
  vivify_1735:
    set $S2991, $P2990
    iseq $I2992, $S2991, "%"
    if $I2992, if_2989
.annotate 'line', 1227
    find_lex $P3000, "$sigil"
    unless_null $P3000, vivify_1736
    new $P3000, "Undef"
  vivify_1736:
    set $S3001, $P3000
    iseq $I3002, $S3001, "@"
    if $I3002, if_2999
    new $P3008, "String"
    assign $P3008, "Undef"
    set $P2998, $P3008
    goto if_2999_end
  if_2999:
.annotate 'line', 1228
    get_hll_global $P3003, "GLOBAL"
    nqp_get_package_through_who $P3004, $P3003, "PAST"
    get_who $P3005, $P3004
    set $P3006, $P3005["Op"]
    $P3007 = $P3006."new"("    %r = root_new ['parrot';'ResizablePMCArray']" :named("inline"))
    set $P2998, $P3007
  if_2999_end:
    set $P2988, $P2998
.annotate 'line', 1225
    goto if_2989_end
  if_2989:
.annotate 'line', 1226
    get_hll_global $P2993, "GLOBAL"
    nqp_get_package_through_who $P2994, $P2993, "PAST"
    get_who $P2995, $P2994
    set $P2996, $P2995["Op"]
    $P2997 = $P2996."new"("    %r = root_new ['parrot';'Hash']" :named("inline"))
    set $P2988, $P2997
  if_2989_end:
.annotate 'line', 1224
    .return ($P2988)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair_str"  :subid("444_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_3011
.annotate 'line', 1243
    .lex "$ast", param_3011
.annotate 'line', 1244
    get_hll_global $P3014, "GLOBAL"
    nqp_get_package_through_who $P3015, $P3014, "PAST"
    get_who $P3016, $P3015
    set $P3017, $P3016["Op"]
    find_lex $P3018, "$ast"
    unless_null $P3018, vivify_1737
    new $P3018, "Undef"
  vivify_1737:
    $P3019 = $P3017."ACCEPTS"($P3018)
    if $P3019, if_3013
.annotate 'line', 1246
    find_lex $P3023, "$ast"
    unless_null $P3023, vivify_1738
    new $P3023, "Undef"
  vivify_1738:
    $P3024 = $P3023."value"()
    set $P3012, $P3024
.annotate 'line', 1244
    goto if_3013_end
  if_3013:
.annotate 'line', 1245
    find_lex $P3020, "$ast"
    unless_null $P3020, vivify_1739
    new $P3020, "Undef"
  vivify_1739:
    $P3021 = $P3020."list"()
    join $S3022, " ", $P3021
    new $P3012, 'String'
    set $P3012, $S3022
  if_3013_end:
.annotate 'line', 1243
    .return ($P3012)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "import_HOW_exports"  :subid("445_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_3027
.annotate 'line', 1422
    .const 'Sub' $P3039 = "446_1307873304.82979" 
    capture_lex $P3039
    .lex "$UNIT", param_3027
.annotate 'line', 1424
    find_lex $P3030, "$UNIT"
    unless_null $P3030, vivify_1740
    new $P3030, "Undef"
  vivify_1740:
    exists $I3031, $P3030["EXPORTHOW"]
    if $I3031, if_3029
    new $P3028, 'Integer'
    set $P3028, $I3031
    goto if_3029_end
  if_3029:
.annotate 'line', 1425
    find_lex $P3033, "$UNIT"
    unless_null $P3033, vivify_1741
    $P3033 = root_new ['parrot';'Hash']
  vivify_1741:
    set $P3034, $P3033["EXPORTHOW"]
    unless_null $P3034, vivify_1742
    new $P3034, "Undef"
  vivify_1742:
    get_who $P3035, $P3034
    defined $I3036, $P3035
    unless $I3036, for_undef_1743
    iter $P3032, $P3035
    new $P3049, 'ExceptionHandler'
    set_label $P3049, loop3048_handler
    $P3049."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3049
  loop3048_test:
    unless $P3032, loop3048_done
    shift $P3037, $P3032
  loop3048_redo:
    .const 'Sub' $P3039 = "446_1307873304.82979" 
    capture_lex $P3039
    $P3039($P3037)
  loop3048_next:
    goto loop3048_test
  loop3048_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3050, exception, 'type'
    eq $P3050, .CONTROL_LOOP_NEXT, loop3048_next
    eq $P3050, .CONTROL_LOOP_REDO, loop3048_redo
  loop3048_done:
    pop_eh 
  for_undef_1743:
.annotate 'line', 1424
    set $P3028, $P3032
  if_3029_end:
.annotate 'line', 1422
    .return ($P3028)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3038"  :anon :subid("446_1307873304.82979") :outer("445_1307873304.82979")
    .param pmc param_3040
.annotate 'line', 1425
    .lex "$_", param_3040
.annotate 'line', 1426
    find_lex $P3041, "$_"
    unless_null $P3041, vivify_1744
    new $P3041, "Undef"
  vivify_1744:
    $P3042 = $P3041."value"()
    find_lex $P3043, "$_"
    unless_null $P3043, vivify_1745
    new $P3043, "Undef"
  vivify_1745:
    $P3044 = $P3043."key"()
    find_dynamic_lex $P3047, "%*HOW"
    unless_null $P3047, vivify_1746
    get_hll_global $P3045, "GLOBAL"
    get_who $P3046, $P3045
    set $P3047, $P3046["%HOW"]
    unless_null $P3047, vivify_1747
    die "Contextual %*HOW not found"
  vivify_1747:
    store_dynamic_lex "%*HOW", $P3047
  vivify_1746:
    set $P3047[$P3044], $P3042
.annotate 'line', 1425
    .return ($P3042)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "push_block_handler"  :subid("447_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_3053
    .param pmc param_3054
.annotate 'line', 1527
    .lex "$/", param_3053
    .lex "$block", param_3054
.annotate 'line', 1528
    find_lex $P3056, "$?PACKAGE"
    get_who $P3057, $P3056
    set $P3058, $P3057["@BLOCK"]
    unless_null $P3058, vivify_1748
    $P3058 = root_new ['parrot';'ResizablePMCArray']
  vivify_1748:
    set $P3059, $P3058[0]
    unless_null $P3059, vivify_1749
    new $P3059, "Undef"
  vivify_1749:
    $P3060 = $P3059."handlers"()
    if $P3060, unless_3055_end
.annotate 'line', 1529
    find_lex $P3061, "$?PACKAGE"
    get_who $P3062, $P3061
    set $P3063, $P3062["@BLOCK"]
    unless_null $P3063, vivify_1750
    $P3063 = root_new ['parrot';'ResizablePMCArray']
  vivify_1750:
    set $P3064, $P3063[0]
    unless_null $P3064, vivify_1751
    new $P3064, "Undef"
  vivify_1751:
    new $P3065, "ResizablePMCArray"
    $P3064."handlers"($P3065)
  unless_3055_end:
.annotate 'line', 1531
    find_lex $P3067, "$block"
    unless_null $P3067, vivify_1752
    new $P3067, "Undef"
  vivify_1752:
    $P3068 = $P3067."arity"()
    if $P3068, unless_3066_end
.annotate 'line', 1532
    find_lex $P3069, "$block"
    unless_null $P3069, vivify_1753
    new $P3069, "Undef"
  vivify_1753:
.annotate 'line', 1533
    get_hll_global $P3070, "GLOBAL"
    nqp_get_package_through_who $P3071, $P3070, "PAST"
    get_who $P3072, $P3071
    set $P3073, $P3072["Op"]
.annotate 'line', 1534
    get_hll_global $P3074, "GLOBAL"
    nqp_get_package_through_who $P3075, $P3074, "PAST"
    get_who $P3076, $P3075
    set $P3077, $P3076["Var"]
    $P3078 = $P3077."new"("lexical" :named("scope"), "$!" :named("name"), 1 :named("isdecl"))
.annotate 'line', 1535
    get_hll_global $P3079, "GLOBAL"
    nqp_get_package_through_who $P3080, $P3079, "PAST"
    get_who $P3081, $P3080
    set $P3082, $P3081["Var"]
    $P3083 = $P3082."new"("lexical" :named("scope"), "$_" :named("name"))
    $P3084 = $P3073."new"($P3078, $P3083, "bind_6model" :named("pasttype"))
.annotate 'line', 1533
    $P3069."unshift"($P3084)
.annotate 'line', 1538
    find_lex $P3085, "$block"
    unless_null $P3085, vivify_1754
    new $P3085, "Undef"
  vivify_1754:
    get_hll_global $P3086, "GLOBAL"
    nqp_get_package_through_who $P3087, $P3086, "PAST"
    get_who $P3088, $P3087
    set $P3089, $P3088["Var"]
    $P3090 = $P3089."new"("$_" :named("name"), "parameter" :named("scope"))
    $P3085."unshift"($P3090)
.annotate 'line', 1539
    find_lex $P3091, "$block"
    unless_null $P3091, vivify_1755
    new $P3091, "Undef"
  vivify_1755:
    $P3091."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 1540
    find_lex $P3092, "$block"
    unless_null $P3092, vivify_1756
    new $P3092, "Undef"
  vivify_1756:
    $P3092."symbol"("$!", "lexical" :named("scope"))
.annotate 'line', 1541
    find_lex $P3093, "$block"
    unless_null $P3093, vivify_1757
    new $P3093, "Undef"
  vivify_1757:
    $P3093."arity"(1)
  unless_3066_end:
.annotate 'line', 1543
    find_lex $P3094, "$block"
    unless_null $P3094, vivify_1758
    new $P3094, "Undef"
  vivify_1758:
    $P3094."blocktype"("declaration")
.annotate 'line', 1544
    find_lex $P3095, "$?PACKAGE"
    get_who $P3096, $P3095
    set $P3097, $P3096["@BLOCK"]
    unless_null $P3097, vivify_1759
    $P3097 = root_new ['parrot';'ResizablePMCArray']
  vivify_1759:
    set $P3098, $P3097[0]
    unless_null $P3098, vivify_1760
    new $P3098, "Undef"
  vivify_1760:
    $P3099 = $P3098."handlers"()
.annotate 'line', 1545
    get_hll_global $P3100, "GLOBAL"
    nqp_get_package_through_who $P3101, $P3100, "PAST"
    get_who $P3102, $P3101
    set $P3103, $P3102["Control"]
    find_lex $P3104, "$/"
    unless_null $P3104, vivify_1761
    new $P3104, "Undef"
  vivify_1761:
.annotate 'line', 1547
    get_hll_global $P3105, "GLOBAL"
    nqp_get_package_through_who $P3106, $P3105, "PAST"
    get_who $P3107, $P3106
    set $P3108, $P3107["Stmts"]
.annotate 'line', 1548
    get_hll_global $P3109, "GLOBAL"
    nqp_get_package_through_who $P3110, $P3109, "PAST"
    get_who $P3111, $P3110
    set $P3112, $P3111["Op"]
    find_lex $P3113, "$block"
    unless_null $P3113, vivify_1762
    new $P3113, "Undef"
  vivify_1762:
.annotate 'line', 1550
    get_hll_global $P3114, "GLOBAL"
    nqp_get_package_through_who $P3115, $P3114, "PAST"
    get_who $P3116, $P3115
    set $P3117, $P3116["Var"]
    $P3118 = $P3117."new"("register" :named("scope"), "exception" :named("name"))
    $P3119 = $P3112."new"($P3113, $P3118, "call" :named("pasttype"))
.annotate 'line', 1552
    get_hll_global $P3120, "GLOBAL"
    nqp_get_package_through_who $P3121, $P3120, "PAST"
    get_who $P3122, $P3121
    set $P3123, $P3122["Op"]
.annotate 'line', 1553
    get_hll_global $P3124, "GLOBAL"
    nqp_get_package_through_who $P3125, $P3124, "PAST"
    get_who $P3126, $P3125
    set $P3127, $P3126["Var"]
.annotate 'line', 1554
    get_hll_global $P3128, "GLOBAL"
    nqp_get_package_through_who $P3129, $P3128, "PAST"
    get_who $P3130, $P3129
    set $P3131, $P3130["Var"]
    $P3132 = $P3131."new"("register" :named("scope"), "exception" :named("name"))
    $P3133 = $P3127."new"($P3132, "handled", "keyed" :named("scope"))
.annotate 'line', 1553
    $P3134 = $P3123."new"($P3133, 1, "bind_6model" :named("pasttype"))
.annotate 'line', 1552
    $P3135 = $P3108."new"($P3119, $P3134)
.annotate 'line', 1547
    $P3136 = $P3103."new"($P3135, $P3104 :named("node"))
.annotate 'line', 1545
    $P3137 = $P3099."unshift"($P3136)
.annotate 'line', 1527
    .return ($P3137)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "only_star_block"  :subid("448_1307873304.82979") :outer("438_1307873304.82979")
.annotate 'line', 2073
    new $P3140, "Undef"
    .lex "$past", $P3140
    find_lex $P3141, "$?PACKAGE"
    get_who $P3142, $P3141
    set $P3143, $P3142["@BLOCK"]
    unless_null $P3143, vivify_1763
    $P3143 = root_new ['parrot';'ResizablePMCArray']
  vivify_1763:
    $P3144 = $P3143."shift"()
    store_lex "$past", $P3144
.annotate 'line', 2074
    find_lex $P3145, "$past"
    unless_null $P3145, vivify_1764
    new $P3145, "Undef"
  vivify_1764:
    $P3145."closure"(1)
.annotate 'line', 2075
    find_lex $P3146, "$past"
    unless_null $P3146, vivify_1765
    new $P3146, "Undef"
  vivify_1765:
    get_hll_global $P3147, "GLOBAL"
    nqp_get_package_through_who $P3148, $P3147, "PAST"
    get_who $P3149, $P3148
    set $P3150, $P3149["Op"]
    $P3151 = $P3150."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P3146."push"($P3151)
    find_lex $P3152, "$past"
    unless_null $P3152, vivify_1766
    new $P3152, "Undef"
  vivify_1766:
.annotate 'line', 2072
    .return ($P3152)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "attach_multi_signature"  :subid("449_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_3155
.annotate 'line', 2081
    .const 'Sub' $P3175 = "450_1307873304.82979" 
    capture_lex $P3175
    .lex "$routine", param_3155
.annotate 'line', 2085
    new $P3156, "Undef"
    .lex "$types", $P3156
.annotate 'line', 2086
    new $P3157, "Undef"
    .lex "$definednesses", $P3157
.annotate 'line', 2085
    get_hll_global $P3158, "GLOBAL"
    nqp_get_package_through_who $P3159, $P3158, "PAST"
    get_who $P3160, $P3159
    set $P3161, $P3160["Op"]
    $P3162 = $P3161."new"("list" :named("pasttype"))
    store_lex "$types", $P3162
.annotate 'line', 2086
    get_hll_global $P3163, "GLOBAL"
    nqp_get_package_through_who $P3164, $P3163, "PAST"
    get_who $P3165, $P3164
    set $P3166, $P3165["Op"]
    $P3167 = $P3166."new"("list" :named("pasttype"))
    store_lex "$definednesses", $P3167
.annotate 'line', 2087
    find_lex $P3169, "$routine"
    unless_null $P3169, vivify_1767
    $P3169 = root_new ['parrot';'ResizablePMCArray']
  vivify_1767:
    set $P3170, $P3169[0]
    unless_null $P3170, vivify_1768
    new $P3170, "Undef"
  vivify_1768:
    $P3171 = $P3170."list"()
    defined $I3172, $P3171
    unless $I3172, for_undef_1769
    iter $P3168, $P3171
    new $P3219, 'ExceptionHandler'
    set_label $P3219, loop3218_handler
    $P3219."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3219
  loop3218_test:
    unless $P3168, loop3218_done
    shift $P3173, $P3168
  loop3218_redo:
    .const 'Sub' $P3175 = "450_1307873304.82979" 
    capture_lex $P3175
    $P3175($P3173)
  loop3218_next:
    goto loop3218_test
  loop3218_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3220, exception, 'type'
    eq $P3220, .CONTROL_LOOP_NEXT, loop3218_next
    eq $P3220, .CONTROL_LOOP_REDO, loop3218_redo
  loop3218_done:
    pop_eh 
  for_undef_1769:
.annotate 'line', 2094
    find_dynamic_lex $P3223, "$*SC"
    unless_null $P3223, vivify_1779
    get_hll_global $P3221, "GLOBAL"
    get_who $P3222, $P3221
    set $P3223, $P3222["$SC"]
    unless_null $P3223, vivify_1780
    die "Contextual $*SC not found"
  vivify_1780:
  vivify_1779:
    find_lex $P3224, "$routine"
    unless_null $P3224, vivify_1781
    new $P3224, "Undef"
  vivify_1781:
    find_lex $P3225, "$types"
    unless_null $P3225, vivify_1782
    new $P3225, "Undef"
  vivify_1782:
    find_lex $P3226, "$definednesses"
    unless_null $P3226, vivify_1783
    new $P3226, "Undef"
  vivify_1783:
    $P3227 = $P3223."set_routine_signature"($P3224, $P3225, $P3226)
.annotate 'line', 2081
    .return ($P3227)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3174"  :anon :subid("450_1307873304.82979") :outer("449_1307873304.82979")
    .param pmc param_3176
.annotate 'line', 2087
    .lex "$_", param_3176
.annotate 'line', 2088
    get_hll_global $P3181, "GLOBAL"
    nqp_get_package_through_who $P3182, $P3181, "PAST"
    get_who $P3183, $P3182
    set $P3184, $P3183["Var"]
    find_lex $P3185, "$_"
    unless_null $P3185, vivify_1770
    new $P3185, "Undef"
  vivify_1770:
    $P3186 = $P3184."ACCEPTS"($P3185)
    if $P3186, if_3180
    set $P3179, $P3186
    goto if_3180_end
  if_3180:
    find_lex $P3187, "$_"
    unless_null $P3187, vivify_1771
    new $P3187, "Undef"
  vivify_1771:
    $S3188 = $P3187."scope"()
    iseq $I3189, $S3188, "parameter"
    new $P3179, 'Integer'
    set $P3179, $I3189
  if_3180_end:
    if $P3179, if_3178
    set $P3177, $P3179
    goto if_3178_end
  if_3178:
.annotate 'line', 2089
    find_lex $P3190, "$types"
    unless_null $P3190, vivify_1772
    new $P3190, "Undef"
  vivify_1772:
    find_lex $P3192, "$_"
    unless_null $P3192, vivify_1773
    new $P3192, "Undef"
  vivify_1773:
    $P3193 = $P3192."multitype"()
    set $P3191, $P3193
    defined $I3195, $P3191
    if $I3195, default_3194
    get_hll_global $P3196, "GLOBAL"
    nqp_get_package_through_who $P3197, $P3196, "PAST"
    get_who $P3198, $P3197
    set $P3199, $P3198["Op"]
    $P3200 = $P3199."new"("null P" :named("pirop"))
    set $P3191, $P3200
  default_3194:
    $P3190."push"($P3191)
.annotate 'line', 2090
    find_lex $P3201, "$definednesses"
    unless_null $P3201, vivify_1774
    new $P3201, "Undef"
  vivify_1774:
    find_lex $P3204, "$_"
    unless_null $P3204, vivify_1775
    $P3204 = root_new ['parrot';'Hash']
  vivify_1775:
    set $P3205, $P3204["definedness"]
    unless_null $P3205, vivify_1776
    new $P3205, "Undef"
  vivify_1776:
    set $S3206, $P3205
    iseq $I3207, $S3206, "D"
    if $I3207, if_3203
.annotate 'line', 2091
    find_lex $P3211, "$_"
    unless_null $P3211, vivify_1777
    $P3211 = root_new ['parrot';'Hash']
  vivify_1777:
    set $P3212, $P3211["definedness"]
    unless_null $P3212, vivify_1778
    new $P3212, "Undef"
  vivify_1778:
    set $S3213, $P3212
    iseq $I3214, $S3213, "U"
    if $I3214, if_3210
    new $P3216, "Integer"
    assign $P3216, 0
    set $P3209, $P3216
    goto if_3210_end
  if_3210:
    new $P3215, "Integer"
    assign $P3215, 2
    set $P3209, $P3215
  if_3210_end:
    set $P3202, $P3209
.annotate 'line', 2090
    goto if_3203_end
  if_3203:
    new $P3208, "Integer"
    assign $P3208, 1
    set $P3202, $P3208
  if_3203_end:
    $P3217 = $P3201."push"($P3202)
.annotate 'line', 2088
    set $P3177, $P3217
  if_3178_end:
.annotate 'line', 2087
    .return ($P3177)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "control"  :subid("451_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_3230
    .param pmc param_3231
.annotate 'line', 2548
    .lex "$/", param_3230
    .lex "$type", param_3231
.annotate 'line', 2549
    find_lex $P3232, "$/"
    get_hll_global $P3233, "GLOBAL"
    nqp_get_package_through_who $P3234, $P3233, "PAST"
    get_who $P3235, $P3234
    set $P3236, $P3235["Op"]
    find_lex $P3237, "$/"
    unless_null $P3237, vivify_1784
    new $P3237, "Undef"
  vivify_1784:
.annotate 'line', 2553
    get_hll_global $P3238, "GLOBAL"
    nqp_get_package_through_who $P3239, $P3238, "PAST"
    get_who $P3240, $P3239
    set $P3241, $P3240["Val"]
    find_lex $P3242, "$type"
    unless_null $P3242, vivify_1785
    new $P3242, "Undef"
  vivify_1785:
    $P3243 = $P3241."new"($P3242 :named("value"), "!macro_const" :named("returns"))
    $P3244 = $P3236."new"(0, $P3243, $P3237 :named("node"), "die__vii" :named("pirop"))
.annotate 'line', 2549
    $P3245 = $P3232."!make"($P3244)
.annotate 'line', 2548
    .return ($P3245)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "lexical_package_lookup"  :subid("452_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_3250
    .param pmc param_3251
.annotate 'line', 2567
    .const 'Sub' $P3304 = "453_1307873304.82979" 
    capture_lex $P3304
    new $P3249, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P3249, control_3248
    push_eh $P3249
    .lex "@name", param_3250
    .lex "$/", param_3251
.annotate 'line', 2573
    new $P3252, "Undef"
    .lex "$final_name", $P3252
.annotate 'line', 2574
    new $P3253, "Undef"
    .lex "$lookup", $P3253
.annotate 'line', 2569
    find_lex $P3255, "@name"
    unless_null $P3255, vivify_1786
    $P3255 = root_new ['parrot';'ResizablePMCArray']
  vivify_1786:
    set $N3256, $P3255
    iseq $I3257, $N3256, 0.0
    unless $I3257, if_3254_end
    find_lex $P3258, "$/"
    unless_null $P3258, vivify_1787
    new $P3258, "Undef"
  vivify_1787:
    $P3259 = $P3258."CURSOR"()
    $P3259."panic"("Cannot compile empty name")
  if_3254_end:
.annotate 'line', 2573
    find_lex $P3260, "@name"
    unless_null $P3260, vivify_1788
    $P3260 = root_new ['parrot';'ResizablePMCArray']
  vivify_1788:
    $P3261 = $P3260."pop"()
    store_lex "$final_name", $P3261
.annotate 'line', 2574
    get_hll_global $P3262, "GLOBAL"
    nqp_get_package_through_who $P3263, $P3262, "PAST"
    get_who $P3264, $P3263
    set $P3265, $P3264["Var"]
    find_lex $P3266, "$final_name"
    unless_null $P3266, vivify_1789
    new $P3266, "Undef"
  vivify_1789:
    set $S3267, $P3266
    $P3268 = $P3265."new"($S3267, "keyed" :named("scope"))
    store_lex "$lookup", $P3268
.annotate 'line', 2578
    find_lex $P3270, "@name"
    unless_null $P3270, vivify_1790
    $P3270 = root_new ['parrot';'ResizablePMCArray']
  vivify_1790:
    set $N3271, $P3270
    iseq $I3272, $N3271, 0.0
    if $I3272, if_3269
.annotate 'line', 2596
    .const 'Sub' $P3304 = "453_1307873304.82979" 
    capture_lex $P3304
    $P3304()
    goto if_3269_end
  if_3269:
.annotate 'line', 2579
    find_lex $P3273, "$lookup"
    unless_null $P3273, vivify_1803
    new $P3273, "Undef"
  vivify_1803:
    get_hll_global $P3274, "GLOBAL"
    nqp_get_package_through_who $P3275, $P3274, "PAST"
    get_who $P3276, $P3275
    set $P3277, $P3276["Op"]
.annotate 'line', 2581
    get_hll_global $P3278, "GLOBAL"
    nqp_get_package_through_who $P3279, $P3278, "PAST"
    get_who $P3280, $P3279
    set $P3281, $P3280["Var"]
    $P3282 = $P3281."new"("$?PACKAGE" :named("name"), "lexical" :named("scope"))
    $P3283 = $P3277."new"($P3282, "get_who PP" :named("pirop"))
.annotate 'line', 2579
    $P3273."unshift"($P3283)
.annotate 'line', 2583
    find_lex $P3284, "$lookup"
    unless_null $P3284, vivify_1804
    new $P3284, "Undef"
  vivify_1804:
    get_hll_global $P3285, "GLOBAL"
    nqp_get_package_through_who $P3286, $P3285, "PAST"
    get_who $P3287, $P3286
    set $P3288, $P3287["Var"]
.annotate 'line', 2585
    get_hll_global $P3289, "GLOBAL"
    nqp_get_package_through_who $P3290, $P3289, "PAST"
    get_who $P3291, $P3290
    set $P3292, $P3291["Op"]
.annotate 'line', 2587
    get_hll_global $P3293, "GLOBAL"
    nqp_get_package_through_who $P3294, $P3293, "PAST"
    get_who $P3295, $P3294
    set $P3296, $P3295["Var"]
    new $P3297, "ResizablePMCArray"
    $P3298 = $P3296."new"("GLOBAL" :named("name"), $P3297 :named("namespace"), "package" :named("scope"))
    $P3299 = $P3292."new"($P3298, "get_who PP" :named("pirop"))
.annotate 'line', 2589
    find_lex $P3300, "$final_name"
    unless_null $P3300, vivify_1805
    new $P3300, "Undef"
  vivify_1805:
    set $S3301, $P3300
    $P3302 = $P3288."new"($P3299, $S3301, "keyed" :named("scope"))
.annotate 'line', 2583
    $P3284."viviself"($P3302)
  if_3269_end:
.annotate 'line', 2611
    new $P3356, "Exception"
    set $P3356['type'], .CONTROL_RETURN
    find_lex $P3357, "$lookup"
    unless_null $P3357, vivify_1806
    new $P3357, "Undef"
  vivify_1806:
    setattribute $P3356, 'payload', $P3357
    throw $P3356
.annotate 'line', 2567
    .return ()
  control_3248:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3358, exception, "payload"
    .return ($P3358)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3303"  :anon :subid("453_1307873304.82979") :outer("452_1307873304.82979")
.annotate 'line', 2596
    .const 'Sub' $P3335 = "454_1307873304.82979" 
    capture_lex $P3335
.annotate 'line', 2597
    new $P3305, "Undef"
    .lex "$path", $P3305
    find_lex $P3308, "@name"
    unless_null $P3308, vivify_1791
    $P3308 = root_new ['parrot';'ResizablePMCArray']
  vivify_1791:
    set $P3309, $P3308[0]
    unless_null $P3309, vivify_1792
    new $P3309, "Undef"
  vivify_1792:
    $P3310 = "is_lexical"($P3309)
    if $P3310, if_3307
.annotate 'line', 2599
    get_hll_global $P3318, "GLOBAL"
    nqp_get_package_through_who $P3319, $P3318, "PAST"
    get_who $P3320, $P3319
    set $P3321, $P3320["Var"]
    new $P3322, "ResizablePMCArray"
    $P3323 = $P3321."new"("GLOBAL" :named("name"), $P3322 :named("namespace"), "package" :named("scope"))
    set $P3306, $P3323
.annotate 'line', 2597
    goto if_3307_end
  if_3307:
.annotate 'line', 2598
    get_hll_global $P3311, "GLOBAL"
    nqp_get_package_through_who $P3312, $P3311, "PAST"
    get_who $P3313, $P3312
    set $P3314, $P3313["Var"]
    find_lex $P3315, "@name"
    unless_null $P3315, vivify_1793
    $P3315 = root_new ['parrot';'ResizablePMCArray']
  vivify_1793:
    $P3316 = $P3315."shift"()
    $P3317 = $P3314."new"($P3316 :named("name"), "lexical" :named("scope"))
    set $P3306, $P3317
  if_3307_end:
.annotate 'line', 2597
    store_lex "$path", $P3306
.annotate 'line', 2600
    find_lex $P3325, "@name"
    unless_null $P3325, vivify_1794
    $P3325 = root_new ['parrot';'ResizablePMCArray']
  vivify_1794:
    set $P3326, $P3325[0]
    unless_null $P3326, vivify_1795
    new $P3326, "Undef"
  vivify_1795:
    set $S3327, $P3326
    iseq $I3328, $S3327, "GLOBAL"
    unless $I3328, if_3324_end
.annotate 'line', 2601
    find_lex $P3329, "@name"
    unless_null $P3329, vivify_1796
    $P3329 = root_new ['parrot';'ResizablePMCArray']
  vivify_1796:
    $P3329."shift"()
  if_3324_end:
.annotate 'line', 2603
    find_lex $P3331, "@name"
    unless_null $P3331, vivify_1797
    $P3331 = root_new ['parrot';'ResizablePMCArray']
  vivify_1797:
    defined $I3332, $P3331
    unless $I3332, for_undef_1798
    iter $P3330, $P3331
    new $P3346, 'ExceptionHandler'
    set_label $P3346, loop3345_handler
    $P3346."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3346
  loop3345_test:
    unless $P3330, loop3345_done
    shift $P3333, $P3330
  loop3345_redo:
    .const 'Sub' $P3335 = "454_1307873304.82979" 
    capture_lex $P3335
    $P3335($P3333)
  loop3345_next:
    goto loop3345_test
  loop3345_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3347, exception, 'type'
    eq $P3347, .CONTROL_LOOP_NEXT, loop3345_next
    eq $P3347, .CONTROL_LOOP_REDO, loop3345_redo
  loop3345_done:
    pop_eh 
  for_undef_1798:
.annotate 'line', 2608
    find_lex $P3348, "$lookup"
    unless_null $P3348, vivify_1801
    new $P3348, "Undef"
  vivify_1801:
    get_hll_global $P3349, "GLOBAL"
    nqp_get_package_through_who $P3350, $P3349, "PAST"
    get_who $P3351, $P3350
    set $P3352, $P3351["Op"]
    find_lex $P3353, "$path"
    unless_null $P3353, vivify_1802
    new $P3353, "Undef"
  vivify_1802:
    $P3354 = $P3352."new"($P3353, "get_who PP" :named("pirop"))
    $P3355 = $P3348."unshift"($P3354)
.annotate 'line', 2596
    .return ($P3355)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3334"  :anon :subid("454_1307873304.82979") :outer("453_1307873304.82979")
    .param pmc param_3336
.annotate 'line', 2603
    .lex "$_", param_3336
.annotate 'line', 2604
    get_hll_global $P3337, "GLOBAL"
    nqp_get_package_through_who $P3338, $P3337, "PAST"
    get_who $P3339, $P3338
    set $P3340, $P3339["Op"]
    find_lex $P3341, "$path"
    unless_null $P3341, vivify_1799
    new $P3341, "Undef"
  vivify_1799:
.annotate 'line', 2606
    find_lex $P3342, "$_"
    unless_null $P3342, vivify_1800
    new $P3342, "Undef"
  vivify_1800:
    set $S3343, $P3342
    $P3344 = $P3340."new"($P3341, $S3343, "nqp_get_package_through_who PPs" :named("pirop"))
.annotate 'line', 2604
    store_lex "$path", $P3344
.annotate 'line', 2603
    .return ($P3344)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "is_lexical"  :subid("455_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_3361
.annotate 'line', 2616
    .lex "$name", param_3361
.annotate 'line', 2617
    find_lex $P3362, "$name"
    unless_null $P3362, vivify_1807
    new $P3362, "Undef"
  vivify_1807:
    $P3363 = "is_scope"($P3362, "lexical")
.annotate 'line', 2616
    .return ($P3363)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "is_package"  :subid("456_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_3366
.annotate 'line', 2622
    .lex "$name", param_3366
.annotate 'line', 2623
    find_lex $P3367, "$name"
    unless_null $P3367, vivify_1808
    new $P3367, "Undef"
  vivify_1808:
    $P3368 = "is_scope"($P3367, "package")
.annotate 'line', 2622
    .return ($P3368)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "is_scope"  :subid("457_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_3373
    .param pmc param_3374
.annotate 'line', 2628
    .const 'Sub' $P3382 = "458_1307873304.82979" 
    capture_lex $P3382
    new $P3372, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P3372, control_3371
    push_eh $P3372
    .lex "$name", param_3373
    .lex "$wanted_scope", param_3374
.annotate 'line', 2629
    find_lex $P3376, "$?PACKAGE"
    get_who $P3377, $P3376
    set $P3378, $P3377["@BLOCK"]
    unless_null $P3378, vivify_1809
    $P3378 = root_new ['parrot';'ResizablePMCArray']
  vivify_1809:
    defined $I3379, $P3378
    unless $I3379, for_undef_1810
    iter $P3375, $P3378
    new $P3401, 'ExceptionHandler'
    set_label $P3401, loop3400_handler
    $P3401."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3401
  loop3400_test:
    unless $P3375, loop3400_done
    shift $P3380, $P3375
  loop3400_redo:
    .const 'Sub' $P3382 = "458_1307873304.82979" 
    capture_lex $P3382
    $P3382($P3380)
  loop3400_next:
    goto loop3400_test
  loop3400_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3402, exception, 'type'
    eq $P3402, .CONTROL_LOOP_NEXT, loop3400_next
    eq $P3402, .CONTROL_LOOP_REDO, loop3400_redo
  loop3400_done:
    pop_eh 
  for_undef_1810:
.annotate 'line', 2628
    .return (0)
  control_3371:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3403, exception, "payload"
    .return ($P3403)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3381"  :anon :subid("458_1307873304.82979") :outer("457_1307873304.82979")
    .param pmc param_3384
.annotate 'line', 2630
    $P3383 = root_new ['parrot';'Hash']
    .lex "%sym", $P3383
    .lex "$_", param_3384
    find_lex $P3385, "$_"
    unless_null $P3385, vivify_1811
    new $P3385, "Undef"
  vivify_1811:
    find_lex $P3386, "$name"
    unless_null $P3386, vivify_1812
    new $P3386, "Undef"
  vivify_1812:
    $P3387 = $P3385."symbol"($P3386)
    store_lex "%sym", $P3387
.annotate 'line', 2631
    find_lex $P3390, "%sym"
    unless_null $P3390, vivify_1813
    $P3390 = root_new ['parrot';'Hash']
  vivify_1813:
    set $N3391, $P3390
    if $N3391, if_3389
    new $P3388, 'Float'
    set $P3388, $N3391
    goto if_3389_end
  if_3389:
.annotate 'line', 2632
    new $P3392, "Exception"
    set $P3392['type'], .CONTROL_RETURN
    find_lex $P3393, "%sym"
    unless_null $P3393, vivify_1814
    $P3393 = root_new ['parrot';'Hash']
  vivify_1814:
    set $P3394, $P3393["scope"]
    unless_null $P3394, vivify_1815
    new $P3394, "Undef"
  vivify_1815:
    set $S3395, $P3394
    find_lex $P3396, "$wanted_scope"
    unless_null $P3396, vivify_1816
    new $P3396, "Undef"
  vivify_1816:
    set $S3397, $P3396
    iseq $I3398, $S3395, $S3397
    new $P3399, 'Integer'
    set $P3399, $I3398
    setattribute $P3392, 'payload', $P3399
    throw $P3392
  if_3389_end:
.annotate 'line', 2629
    .return ($P3388)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "find_sym"  :subid("459_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_3408
    .param pmc param_3409
.annotate 'line', 2651
    .const 'Sub' $P3502 = "464_1307873304.82979" 
    capture_lex $P3502
    .const 'Sub' $P3463 = "462_1307873304.82979" 
    capture_lex $P3463
    .const 'Sub' $P3421 = "460_1307873304.82979" 
    capture_lex $P3421
    new $P3407, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P3407, control_3406
    push_eh $P3407
    .lex "@name", param_3408
    .lex "$/", param_3409
.annotate 'line', 2675
    new $P3410, "Undef"
    .lex "$result", $P3410
.annotate 'line', 2653
    find_lex $P3412, "@name"
    unless_null $P3412, vivify_1817
    $P3412 = root_new ['parrot';'ResizablePMCArray']
  vivify_1817:
    set $N3413, $P3412
    if $N3413, unless_3411_end
    find_lex $P3414, "$/"
    unless_null $P3414, vivify_1818
    new $P3414, "Undef"
  vivify_1818:
    $P3415 = $P3414."CURSOR"()
    $P3415."panic"("Cannot look up empty name")
  unless_3411_end:
.annotate 'line', 2657
    find_lex $P3417, "@name"
    unless_null $P3417, vivify_1819
    $P3417 = root_new ['parrot';'ResizablePMCArray']
  vivify_1819:
    set $N3418, $P3417
    iseq $I3419, $N3418, 1.0
    unless $I3419, if_3416_end
    .const 'Sub' $P3421 = "460_1307873304.82979" 
    capture_lex $P3421
    $P3421()
  if_3416_end:
.annotate 'line', 2675
    find_dynamic_lex $P3457, "$*GLOBALish"
    unless_null $P3457, vivify_1831
    get_hll_global $P3455, "GLOBAL"
    get_who $P3456, $P3455
    set $P3457, $P3456["$GLOBALish"]
    unless_null $P3457, vivify_1832
    die "Contextual $*GLOBALish not found"
  vivify_1832:
  vivify_1831:
    store_lex "$result", $P3457
.annotate 'line', 2676
    find_lex $P3459, "@name"
    unless_null $P3459, vivify_1833
    $P3459 = root_new ['parrot';'ResizablePMCArray']
  vivify_1833:
    set $N3460, $P3459
    isge $I3461, $N3460, 2.0
    unless $I3461, if_3458_end
    .const 'Sub' $P3463 = "462_1307873304.82979" 
    capture_lex $P3463
    $P3463()
  if_3458_end:
.annotate 'line', 2694
    find_lex $P3498, "@name"
    unless_null $P3498, vivify_1846
    $P3498 = root_new ['parrot';'ResizablePMCArray']
  vivify_1846:
    defined $I3499, $P3498
    unless $I3499, for_undef_1847
    iter $P3497, $P3498
    new $P3520, 'ExceptionHandler'
    set_label $P3520, loop3519_handler
    $P3520."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3520
  loop3519_test:
    unless $P3497, loop3519_done
    shift $P3500, $P3497
  loop3519_redo:
    .const 'Sub' $P3502 = "464_1307873304.82979" 
    capture_lex $P3502
    $P3502($P3500)
  loop3519_next:
    goto loop3519_test
  loop3519_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3521, exception, 'type'
    eq $P3521, .CONTROL_LOOP_NEXT, loop3519_next
    eq $P3521, .CONTROL_LOOP_REDO, loop3519_redo
  loop3519_done:
    pop_eh 
  for_undef_1847:
    find_lex $P3522, "$result"
    unless_null $P3522, vivify_1854
    new $P3522, "Undef"
  vivify_1854:
.annotate 'line', 2651
    .return ($P3522)
  control_3406:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3523, exception, "payload"
    .return ($P3523)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3420"  :anon :subid("460_1307873304.82979") :outer("459_1307873304.82979")
.annotate 'line', 2657
    .const 'Sub' $P3432 = "461_1307873304.82979" 
    capture_lex $P3432
.annotate 'line', 2658
    new $P3422, "Undef"
    .lex "$final_name", $P3422
    find_lex $P3423, "@name"
    unless_null $P3423, vivify_1820
    $P3423 = root_new ['parrot';'ResizablePMCArray']
  vivify_1820:
    set $P3424, $P3423[0]
    unless_null $P3424, vivify_1821
    new $P3424, "Undef"
  vivify_1821:
    store_lex "$final_name", $P3424
.annotate 'line', 2659
    find_lex $P3426, "$?PACKAGE"
    get_who $P3427, $P3426
    set $P3428, $P3427["@BLOCK"]
    unless_null $P3428, vivify_1822
    $P3428 = root_new ['parrot';'ResizablePMCArray']
  vivify_1822:
    defined $I3429, $P3428
    unless $I3429, for_undef_1823
    iter $P3425, $P3428
    new $P3453, 'ExceptionHandler'
    set_label $P3453, loop3452_handler
    $P3453."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3453
  loop3452_test:
    unless $P3425, loop3452_done
    shift $P3430, $P3425
  loop3452_redo:
    .const 'Sub' $P3432 = "461_1307873304.82979" 
    capture_lex $P3432
    $P3432($P3430)
  loop3452_next:
    goto loop3452_test
  loop3452_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3454, exception, 'type'
    eq $P3454, .CONTROL_LOOP_NEXT, loop3452_next
    eq $P3454, .CONTROL_LOOP_REDO, loop3452_redo
  loop3452_done:
    pop_eh 
  for_undef_1823:
.annotate 'line', 2657
    .return ($P3425)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3431"  :anon :subid("461_1307873304.82979") :outer("460_1307873304.82979")
    .param pmc param_3434
.annotate 'line', 2660
    $P3433 = root_new ['parrot';'Hash']
    .lex "%sym", $P3433
    .lex "$_", param_3434
    find_lex $P3435, "$_"
    unless_null $P3435, vivify_1824
    new $P3435, "Undef"
  vivify_1824:
    find_lex $P3436, "$final_name"
    unless_null $P3436, vivify_1825
    new $P3436, "Undef"
  vivify_1825:
    $P3437 = $P3435."symbol"($P3436)
    store_lex "%sym", $P3437
.annotate 'line', 2661
    find_lex $P3440, "%sym"
    unless_null $P3440, vivify_1826
    $P3440 = root_new ['parrot';'Hash']
  vivify_1826:
    set $N3441, $P3440
    if $N3441, if_3439
    new $P3438, 'Float'
    set $P3438, $N3441
    goto if_3439_end
  if_3439:
.annotate 'line', 2662
    find_lex $P3444, "%sym"
    unless_null $P3444, vivify_1827
    $P3444 = root_new ['parrot';'Hash']
  vivify_1827:
    exists $I3445, $P3444["value"]
    if $I3445, if_3443
.annotate 'line', 2666
    new $P3449, 'String'
    set $P3449, "No compile-time value for "
    find_lex $P3450, "$final_name"
    unless_null $P3450, vivify_1828
    new $P3450, "Undef"
  vivify_1828:
    concat $P3451, $P3449, $P3450
    die $P3451
.annotate 'line', 2665
    goto if_3443_end
  if_3443:
.annotate 'line', 2663
    new $P3446, "Exception"
    set $P3446['type'], .CONTROL_RETURN
    find_lex $P3447, "%sym"
    unless_null $P3447, vivify_1829
    $P3447 = root_new ['parrot';'Hash']
  vivify_1829:
    set $P3448, $P3447["value"]
    unless_null $P3448, vivify_1830
    new $P3448, "Undef"
  vivify_1830:
    setattribute $P3446, 'payload', $P3448
    throw $P3446
  if_3443_end:
.annotate 'line', 2661
    set $P3438, $P3442
  if_3439_end:
.annotate 'line', 2659
    .return ($P3438)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3462"  :anon :subid("462_1307873304.82979") :outer("459_1307873304.82979")
.annotate 'line', 2676
    .const 'Sub' $P3474 = "463_1307873304.82979" 
    capture_lex $P3474
.annotate 'line', 2677
    new $P3464, "Undef"
    .lex "$first", $P3464
    find_lex $P3465, "@name"
    unless_null $P3465, vivify_1834
    $P3465 = root_new ['parrot';'ResizablePMCArray']
  vivify_1834:
    set $P3466, $P3465[0]
    unless_null $P3466, vivify_1835
    new $P3466, "Undef"
  vivify_1835:
    store_lex "$first", $P3466
.annotate 'line', 2678
    find_lex $P3468, "$?PACKAGE"
    get_who $P3469, $P3468
    set $P3470, $P3469["@BLOCK"]
    unless_null $P3470, vivify_1836
    $P3470 = root_new ['parrot';'ResizablePMCArray']
  vivify_1836:
    defined $I3471, $P3470
    unless $I3471, for_undef_1837
    iter $P3467, $P3470
    new $P3495, 'ExceptionHandler'
    set_label $P3495, loop3494_handler
    $P3495."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3495
  loop3494_test:
    unless $P3467, loop3494_done
    shift $P3472, $P3467
  loop3494_redo:
    .const 'Sub' $P3474 = "463_1307873304.82979" 
    capture_lex $P3474
    $P3474($P3472)
  loop3494_next:
    goto loop3494_test
  loop3494_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3496, exception, 'type'
    eq $P3496, .CONTROL_LOOP_NEXT, loop3494_next
    eq $P3496, .CONTROL_LOOP_REDO, loop3494_redo
  loop3494_done:
    pop_eh 
  for_undef_1837:
.annotate 'line', 2676
    .return ($P3467)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3473"  :anon :subid("463_1307873304.82979") :outer("462_1307873304.82979")
    .param pmc param_3476
.annotate 'line', 2679
    $P3475 = root_new ['parrot';'Hash']
    .lex "%sym", $P3475
    .lex "$_", param_3476
    find_lex $P3477, "$_"
    unless_null $P3477, vivify_1838
    new $P3477, "Undef"
  vivify_1838:
    find_lex $P3478, "$first"
    unless_null $P3478, vivify_1839
    new $P3478, "Undef"
  vivify_1839:
    $P3479 = $P3477."symbol"($P3478)
    store_lex "%sym", $P3479
.annotate 'line', 2680
    find_lex $P3482, "%sym"
    unless_null $P3482, vivify_1840
    $P3482 = root_new ['parrot';'Hash']
  vivify_1840:
    set $N3483, $P3482
    if $N3483, if_3481
    new $P3480, 'Float'
    set $P3480, $N3483
    goto if_3481_end
  if_3481:
.annotate 'line', 2681
    find_lex $P3486, "%sym"
    unless_null $P3486, vivify_1841
    $P3486 = root_new ['parrot';'Hash']
  vivify_1841:
    exists $I3487, $P3486["value"]
    if $I3487, if_3485
.annotate 'line', 2687
    new $P3491, 'String'
    set $P3491, "No compile-time value for "
    find_lex $P3492, "$first"
    unless_null $P3492, vivify_1842
    new $P3492, "Undef"
  vivify_1842:
    concat $P3493, $P3491, $P3492
    die $P3493
.annotate 'line', 2686
    goto if_3485_end
  if_3485:
.annotate 'line', 2682
    find_lex $P3488, "%sym"
    unless_null $P3488, vivify_1843
    $P3488 = root_new ['parrot';'Hash']
  vivify_1843:
    set $P3489, $P3488["value"]
    unless_null $P3489, vivify_1844
    new $P3489, "Undef"
  vivify_1844:
    store_lex "$result", $P3489
.annotate 'line', 2683
    find_lex $P3490, "@name"
    unless_null $P3490, vivify_1845
    $P3490 = root_new ['parrot';'ResizablePMCArray']
  vivify_1845:
    $P3490."shift"()
.annotate 'line', 2684
    die 0, .CONTROL_LOOP_LAST
  if_3485_end:
.annotate 'line', 2680
    set $P3480, $P3484
  if_3481_end:
.annotate 'line', 2678
    .return ($P3480)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3501"  :anon :subid("464_1307873304.82979") :outer("459_1307873304.82979")
    .param pmc param_3503
.annotate 'line', 2694
    .lex "$_", param_3503
.annotate 'line', 2695
    find_lex $P3508, "$_"
    unless_null $P3508, vivify_1848
    new $P3508, "Undef"
  vivify_1848:
    set $S3509, $P3508
    find_lex $P3506, "$result"
    unless_null $P3506, vivify_1849
    new $P3506, "Undef"
  vivify_1849:
    get_who $P3507, $P3506
    exists $I3510, $P3507[$S3509]
    if $I3510, if_3505
.annotate 'line', 2699
    new $P3515, "String"
    assign $P3515, "Could not locate compile-time value for symbol "
.annotate 'line', 2700
    find_lex $P3516, "@name"
    unless_null $P3516, vivify_1850
    $P3516 = root_new ['parrot';'ResizablePMCArray']
  vivify_1850:
    join $S3517, "::", $P3516
    concat $P3518, $P3515, $S3517
.annotate 'line', 2699
    die $P3518
.annotate 'line', 2698
    goto if_3505_end
  if_3505:
.annotate 'line', 2696
    find_lex $P3511, "$_"
    unless_null $P3511, vivify_1851
    new $P3511, "Undef"
  vivify_1851:
    find_lex $P3512, "$result"
    unless_null $P3512, vivify_1852
    new $P3512, "Undef"
  vivify_1852:
    get_who $P3513, $P3512
    set $P3514, $P3513[$P3511]
    unless_null $P3514, vivify_1853
    new $P3514, "Undef"
  vivify_1853:
    store_lex "$result", $P3514
.annotate 'line', 2695
    set $P3504, $P3514
  if_3505_end:
.annotate 'line', 2694
    .return ($P3504)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "TOP" :anon :subid("465_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_3534
    .param pmc param_3535
.annotate 'line', 1233
    .lex "self", param_3534
    .lex "$/", param_3535
    find_lex $P3536, "$/"
    find_lex $P3537, "$/"
    unless_null $P3537, vivify_1855
    $P3537 = root_new ['parrot';'Hash']
  vivify_1855:
    set $P3538, $P3537["comp_unit"]
    unless_null $P3538, vivify_1856
    new $P3538, "Undef"
  vivify_1856:
    $P3539 = $P3538."ast"()
    $P3540 = $P3536."!make"($P3539)
    .return ($P3540)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "deflongname" :anon :subid("466_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_3542
    .param pmc param_3543
.annotate 'line', 1235
    .lex "self", param_3542
    .lex "$/", param_3543
.annotate 'line', 1236
    find_lex $P3544, "$/"
.annotate 'line', 1237
    find_lex $P3547, "$/"
    unless_null $P3547, vivify_1857
    $P3547 = root_new ['parrot';'Hash']
  vivify_1857:
    set $P3548, $P3547["colonpair"]
    unless_null $P3548, vivify_1858
    new $P3548, "Undef"
  vivify_1858:
    if $P3548, if_3546
.annotate 'line', 1239
    find_lex $P3568, "$/"
    unless_null $P3568, vivify_1859
    new $P3568, "Undef"
  vivify_1859:
    set $S3569, $P3568
    new $P3545, 'String'
    set $P3545, $S3569
.annotate 'line', 1237
    goto if_3546_end
  if_3546:
    find_lex $P3549, "$/"
    unless_null $P3549, vivify_1860
    $P3549 = root_new ['parrot';'Hash']
  vivify_1860:
    set $P3550, $P3549["identifier"]
    unless_null $P3550, vivify_1861
    new $P3550, "Undef"
  vivify_1861:
    set $S3551, $P3550
    new $P3552, 'String'
    set $P3552, $S3551
    concat $P3553, $P3552, ":"
    find_lex $P3554, "$/"
    unless_null $P3554, vivify_1862
    $P3554 = root_new ['parrot';'Hash']
  vivify_1862:
    set $P3555, $P3554["colonpair"]
    unless_null $P3555, vivify_1863
    $P3555 = root_new ['parrot';'ResizablePMCArray']
  vivify_1863:
    set $P3556, $P3555[0]
    unless_null $P3556, vivify_1864
    new $P3556, "Undef"
  vivify_1864:
    $P3557 = $P3556."ast"()
    $S3558 = $P3557."named"()
    concat $P3559, $P3553, $S3558
    concat $P3560, $P3559, "<"
.annotate 'line', 1238
    find_lex $P3561, "$/"
    unless_null $P3561, vivify_1865
    $P3561 = root_new ['parrot';'Hash']
  vivify_1865:
    set $P3562, $P3561["colonpair"]
    unless_null $P3562, vivify_1866
    $P3562 = root_new ['parrot';'ResizablePMCArray']
  vivify_1866:
    set $P3563, $P3562[0]
    unless_null $P3563, vivify_1867
    new $P3563, "Undef"
  vivify_1867:
    $P3564 = $P3563."ast"()
    $S3565 = "colonpair_str"($P3564)
    concat $P3566, $P3560, $S3565
    concat $P3567, $P3566, ">"
    set $P3545, $P3567
  if_3546_end:
.annotate 'line', 1237
    $P3570 = $P3544."!make"($P3545)
.annotate 'line', 1235
    .return ($P3570)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "comp_unit" :anon :subid("467_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_3573
    .param pmc param_3574
.annotate 'line', 1249
    .const 'Sub' $P3637 = "468_1307873304.82979" 
    capture_lex $P3637
    .lex "self", param_3573
    .lex "$/", param_3574
.annotate 'line', 1250
    new $P3575, "Undef"
    .lex "$mainline", $P3575
.annotate 'line', 1251
    new $P3576, "Undef"
    .lex "$unit", $P3576
.annotate 'line', 1274
    $P3577 = root_new ['parrot';'ResizablePMCArray']
    .lex "@loadlibs", $P3577
.annotate 'line', 1287
    new $P3578, "Undef"
    .lex "$main_tasks", $P3578
.annotate 'line', 1250
    find_lex $P3579, "$/"
    unless_null $P3579, vivify_1868
    $P3579 = root_new ['parrot';'Hash']
  vivify_1868:
    set $P3580, $P3579["statementlist"]
    unless_null $P3580, vivify_1869
    new $P3580, "Undef"
  vivify_1869:
    $P3581 = $P3580."ast"()
    store_lex "$mainline", $P3581
.annotate 'line', 1251
    find_lex $P3582, "$?PACKAGE"
    get_who $P3583, $P3582
    set $P3584, $P3583["@BLOCK"]
    unless_null $P3584, vivify_1870
    $P3584 = root_new ['parrot';'ResizablePMCArray']
  vivify_1870:
    $P3585 = $P3584."shift"()
    store_lex "$unit", $P3585
.annotate 'line', 1255
    find_lex $P3586, "$unit"
    unless_null $P3586, vivify_1871
    new $P3586, "Undef"
  vivify_1871:
    $P3587 = $P3586."loadinit"()
    find_dynamic_lex $P3590, "$*SC"
    unless_null $P3590, vivify_1872
    get_hll_global $P3588, "GLOBAL"
    get_who $P3589, $P3588
    set $P3590, $P3589["$SC"]
    unless_null $P3590, vivify_1873
    die "Contextual $*SC not found"
  vivify_1873:
  vivify_1872:
    $P3591 = $P3590."to_past"()
    $P3587."push"($P3591)
.annotate 'line', 1260
    find_lex $P3592, "$unit"
    unless_null $P3592, vivify_1874
    new $P3592, "Undef"
  vivify_1874:
    $P3593 = $P3592."loadinit"()
    get_hll_global $P3594, "GLOBAL"
    nqp_get_package_through_who $P3595, $P3594, "PAST"
    get_who $P3596, $P3595
    set $P3597, $P3596["Op"]
.annotate 'line', 1262
    get_hll_global $P3598, "GLOBAL"
    nqp_get_package_through_who $P3599, $P3598, "PAST"
    get_who $P3600, $P3599
    set $P3601, $P3600["Var"]
    new $P3602, "ResizablePMCArray"
    $P3603 = $P3601."new"("GLOBAL" :named("name"), $P3602 :named("namespace"), "package" :named("scope"))
.annotate 'line', 1263
    find_dynamic_lex $P3606, "$*SC"
    unless_null $P3606, vivify_1875
    get_hll_global $P3604, "GLOBAL"
    get_who $P3605, $P3604
    set $P3606, $P3605["$SC"]
    unless_null $P3606, vivify_1876
    die "Contextual $*SC not found"
  vivify_1876:
  vivify_1875:
    find_dynamic_lex $P3609, "$*PACKAGE"
    unless_null $P3609, vivify_1877
    get_hll_global $P3607, "GLOBAL"
    get_who $P3608, $P3607
    set $P3609, $P3608["$PACKAGE"]
    unless_null $P3609, vivify_1878
    die "Contextual $*PACKAGE not found"
  vivify_1878:
  vivify_1877:
    $P3610 = $P3606."get_slot_past_for_object"($P3609)
    $P3611 = $P3597."new"($P3603, $P3610, "bind_6model" :named("pasttype"))
.annotate 'line', 1260
    $P3593."push"($P3611)
.annotate 'line', 1269
    find_dynamic_lex $P3615, "$*HAS_YOU_ARE_HERE"
    unless_null $P3615, vivify_1879
    get_hll_global $P3613, "GLOBAL"
    get_who $P3614, $P3613
    set $P3615, $P3614["$HAS_YOU_ARE_HERE"]
    unless_null $P3615, vivify_1880
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_1880:
  vivify_1879:
    if $P3615, unless_3612_end
.annotate 'line', 1270
    find_lex $P3616, "$unit"
    unless_null $P3616, vivify_1881
    new $P3616, "Undef"
  vivify_1881:
    find_lex $P3617, "self"
    $P3618 = $P3617."CTXSAVE"()
    $P3616."push"($P3618)
  unless_3612_end:
.annotate 'line', 1274
    new $P3619, "ResizablePMCArray"
    push $P3619, "nqp_group"
    push $P3619, "nqp_ops"
    push $P3619, "trans_ops"
    push $P3619, "io_ops"
    store_lex "@loadlibs", $P3619
.annotate 'line', 1275
    find_dynamic_lex $P3623, "%*COMPILING"
    unless_null $P3623, vivify_1882
    get_hll_global $P3621, "GLOBAL"
    get_who $P3622, $P3621
    set $P3623, $P3622["%COMPILING"]
    unless_null $P3623, vivify_1883
    die "Contextual %*COMPILING not found"
  vivify_1883:
  vivify_1882:
    set $P3624, $P3623["%?OPTIONS"]
    unless_null $P3624, vivify_1884
    $P3624 = root_new ['parrot';'Hash']
  vivify_1884:
    set $P3625, $P3624["vmlibs"]
    unless_null $P3625, vivify_1885
    new $P3625, "Undef"
  vivify_1885:
    unless $P3625, if_3620_end
.annotate 'line', 1276
    find_dynamic_lex $P3629, "%*COMPILING"
    unless_null $P3629, vivify_1886
    get_hll_global $P3627, "GLOBAL"
    get_who $P3628, $P3627
    set $P3629, $P3628["%COMPILING"]
    unless_null $P3629, vivify_1887
    die "Contextual %*COMPILING not found"
  vivify_1887:
  vivify_1886:
    set $P3630, $P3629["%?OPTIONS"]
    unless_null $P3630, vivify_1888
    $P3630 = root_new ['parrot';'Hash']
  vivify_1888:
    set $P3631, $P3630["vmlibs"]
    unless_null $P3631, vivify_1889
    new $P3631, "Undef"
  vivify_1889:
    set $S3632, $P3631
    split $P3633, ",", $S3632
    defined $I3634, $P3633
    unless $I3634, for_undef_1890
    iter $P3626, $P3633
    new $P3643, 'ExceptionHandler'
    set_label $P3643, loop3642_handler
    $P3643."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3643
  loop3642_test:
    unless $P3626, loop3642_done
    shift $P3635, $P3626
  loop3642_redo:
    .const 'Sub' $P3637 = "468_1307873304.82979" 
    capture_lex $P3637
    $P3637($P3635)
  loop3642_next:
    goto loop3642_test
  loop3642_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3644, exception, 'type'
    eq $P3644, .CONTROL_LOOP_NEXT, loop3642_next
    eq $P3644, .CONTROL_LOOP_REDO, loop3642_redo
  loop3642_done:
    pop_eh 
  for_undef_1890:
  if_3620_end:
.annotate 'line', 1280
    find_lex $P3645, "$unit"
    unless_null $P3645, vivify_1893
    new $P3645, "Undef"
  vivify_1893:
    find_lex $P3646, "@loadlibs"
    unless_null $P3646, vivify_1894
    $P3646 = root_new ['parrot';'ResizablePMCArray']
  vivify_1894:
    $P3645."loadlibs"($P3646 :flat)
.annotate 'line', 1286
    find_lex $P3647, "$unit"
    unless_null $P3647, vivify_1895
    new $P3647, "Undef"
  vivify_1895:
    get_hll_global $P3648, "GLOBAL"
    nqp_get_package_through_who $P3649, $P3648, "PAST"
    get_who $P3650, $P3649
    set $P3651, $P3650["Var"]
    $P3652 = $P3651."new"("parameter" :named("scope"), "@ARGS" :named("name"), 1 :named("slurpy"))
    $P3647."unshift"($P3652)
.annotate 'line', 1287
    get_hll_global $P3653, "GLOBAL"
    nqp_get_package_through_who $P3654, $P3653, "PAST"
    get_who $P3655, $P3654
    set $P3656, $P3655["Stmts"]
.annotate 'line', 1288
    get_hll_global $P3657, "GLOBAL"
    nqp_get_package_through_who $P3658, $P3657, "PAST"
    get_who $P3659, $P3658
    set $P3660, $P3659["Op"]
    $P3661 = $P3660."new"("ModuleLoader.pbc", "load_bytecode vs" :named("pirop"))
.annotate 'line', 1289
    get_hll_global $P3662, "GLOBAL"
    nqp_get_package_through_who $P3663, $P3662, "PAST"
    get_who $P3664, $P3663
    set $P3665, $P3664["Op"]
.annotate 'line', 1291
    get_hll_global $P3666, "GLOBAL"
    nqp_get_package_through_who $P3667, $P3666, "PAST"
    get_who $P3668, $P3667
    set $P3669, $P3668["Var"]
    new $P3670, "ResizablePMCArray"
    $P3671 = $P3669."new"("ModuleLoader" :named("name"), $P3670 :named("namespace"), "package" :named("scope"))
.annotate 'line', 1292
    get_hll_global $P3672, "GLOBAL"
    nqp_get_package_through_who $P3673, $P3672, "PAST"
    get_who $P3674, $P3673
    set $P3675, $P3674["Var"]
    get_hll_global $P3676, "GLOBAL"
    nqp_get_package_through_who $P3677, $P3676, "PAST"
    get_who $P3678, $P3677
    set $P3679, $P3678["Op"]
    $P3680 = $P3679."new"("getinterp P" :named("pirop"))
    $P3681 = $P3675."new"($P3680, "context", "keyed" :named("scope"))
    $P3682 = $P3665."new"($P3671, $P3681, "callmethod" :named("pasttype"), "set_mainline_module" :named("name"))
.annotate 'line', 1289
    $P3683 = $P3656."new"($P3661, $P3682)
.annotate 'line', 1287
    store_lex "$main_tasks", $P3683
.annotate 'line', 1295
    find_dynamic_lex $P3687, "$*MAIN_SUB"
    unless_null $P3687, vivify_1896
    get_hll_global $P3685, "GLOBAL"
    get_who $P3686, $P3685
    set $P3687, $P3686["$MAIN_SUB"]
    unless_null $P3687, vivify_1897
    die "Contextual $*MAIN_SUB not found"
  vivify_1897:
  vivify_1896:
    unless $P3687, if_3684_end
.annotate 'line', 1296
    find_lex $P3688, "$main_tasks"
    unless_null $P3688, vivify_1898
    new $P3688, "Undef"
  vivify_1898:
    get_hll_global $P3689, "GLOBAL"
    nqp_get_package_through_who $P3690, $P3689, "PAST"
    get_who $P3691, $P3690
    set $P3692, $P3691["Op"]
.annotate 'line', 1297
    get_hll_global $P3693, "GLOBAL"
    nqp_get_package_through_who $P3694, $P3693, "PAST"
    get_who $P3695, $P3694
    set $P3696, $P3695["Val"]
    find_dynamic_lex $P3699, "$*MAIN_SUB"
    unless_null $P3699, vivify_1899
    get_hll_global $P3697, "GLOBAL"
    get_who $P3698, $P3697
    set $P3699, $P3698["$MAIN_SUB"]
    unless_null $P3699, vivify_1900
    die "Contextual $*MAIN_SUB not found"
  vivify_1900:
  vivify_1899:
    $P3700 = $P3696."new"($P3699 :named("value"))
.annotate 'line', 1298
    get_hll_global $P3701, "GLOBAL"
    nqp_get_package_through_who $P3702, $P3701, "PAST"
    get_who $P3703, $P3702
    set $P3704, $P3703["Var"]
    $P3705 = $P3704."new"("lexical" :named("scope"), "@ARGS" :named("name"), 1 :named("flat"))
    $P3706 = $P3692."new"($P3700, $P3705, "call" :named("pasttype"))
.annotate 'line', 1296
    $P3688."push"($P3706)
  if_3684_end:
.annotate 'line', 1301
    find_lex $P3707, "$mainline"
    unless_null $P3707, vivify_1901
    new $P3707, "Undef"
  vivify_1901:
    get_hll_global $P3708, "GLOBAL"
    nqp_get_package_through_who $P3709, $P3708, "PAST"
    get_who $P3710, $P3709
    set $P3711, $P3710["Op"]
.annotate 'line', 1303
    get_hll_global $P3712, "GLOBAL"
    nqp_get_package_through_who $P3713, $P3712, "PAST"
    get_who $P3714, $P3713
    set $P3715, $P3714["Var"]
    $P3716 = $P3715."new"("lexical" :named("scope"), "@ARGS" :named("name"))
    find_lex $P3717, "$main_tasks"
    unless_null $P3717, vivify_1902
    new $P3717, "Undef"
  vivify_1902:
    $P3718 = $P3711."new"($P3716, $P3717, "if" :named("pasttype"))
.annotate 'line', 1301
    $P3707."push"($P3718)
.annotate 'line', 1310
    find_lex $P3719, "$unit"
    unless_null $P3719, vivify_1903
    new $P3719, "Undef"
  vivify_1903:
.annotate 'line', 1311
    get_hll_global $P3720, "GLOBAL"
    nqp_get_package_through_who $P3721, $P3720, "PAST"
    get_who $P3722, $P3721
    set $P3723, $P3722["Op"]
    find_lex $P3724, "$mainline"
    unless_null $P3724, vivify_1904
    new $P3724, "Undef"
  vivify_1904:
    $P3725 = $P3723."new"($P3724, "return" :named("pirop"))
    $P3719."push"($P3725)
.annotate 'line', 1316
    find_lex $P3726, "$unit"
    unless_null $P3726, vivify_1905
    new $P3726, "Undef"
  vivify_1905:
.annotate 'line', 1317
    get_hll_global $P3727, "GLOBAL"
    nqp_get_package_through_who $P3728, $P3727, "PAST"
    get_who $P3729, $P3728
    set $P3730, $P3729["Block"]
.annotate 'line', 1319
    get_hll_global $P3731, "GLOBAL"
    nqp_get_package_through_who $P3732, $P3731, "PAST"
    get_who $P3733, $P3732
    set $P3734, $P3733["Op"]
    get_hll_global $P3735, "GLOBAL"
    nqp_get_package_through_who $P3736, $P3735, "PAST"
    get_who $P3737, $P3736
    set $P3738, $P3737["Val"]
    find_lex $P3739, "$unit"
    unless_null $P3739, vivify_1906
    new $P3739, "Undef"
  vivify_1906:
    $P3740 = $P3738."new"($P3739 :named("value"))
    $P3741 = $P3734."new"($P3740, "call" :named("pasttype"))
    $P3742 = $P3730."new"($P3741, ":load" :named("pirflags"), 0 :named("lexical"), "" :named("namespace"))
.annotate 'line', 1317
    $P3726."push"($P3742)
.annotate 'line', 1322
    find_lex $P3743, "$unit"
    unless_null $P3743, vivify_1907
    new $P3743, "Undef"
  vivify_1907:
    find_lex $P3744, "$/"
    unless_null $P3744, vivify_1908
    new $P3744, "Undef"
  vivify_1908:
    $P3743."node"($P3744)
.annotate 'line', 1325
    find_lex $P3745, "$unit"
    unless_null $P3745, vivify_1909
    new $P3745, "Undef"
  vivify_1909:
    $P3745."hll"("nqp")
.annotate 'line', 1327
    find_lex $P3746, "$/"
    find_lex $P3747, "$unit"
    unless_null $P3747, vivify_1910
    new $P3747, "Undef"
  vivify_1910:
    $P3748 = $P3746."!make"($P3747)
.annotate 'line', 1249
    .return ($P3748)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3636"  :anon :subid("468_1307873304.82979") :outer("467_1307873304.82979")
    .param pmc param_3638
.annotate 'line', 1276
    .lex "$_", param_3638
.annotate 'line', 1277
    find_lex $P3639, "@loadlibs"
    unless_null $P3639, vivify_1891
    $P3639 = root_new ['parrot';'ResizablePMCArray']
  vivify_1891:
    find_lex $P3640, "$_"
    unless_null $P3640, vivify_1892
    new $P3640, "Undef"
  vivify_1892:
    $P3641 = $P3639."push"($P3640)
.annotate 'line', 1276
    .return ($P3641)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statementlist" :anon :subid("469_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_3750
    .param pmc param_3751
.annotate 'line', 1330
    .const 'Sub' $P3768 = "470_1307873304.82979" 
    capture_lex $P3768
    .lex "self", param_3750
    .lex "$/", param_3751
.annotate 'line', 1331
    new $P3752, "Undef"
    .lex "$past", $P3752
    get_hll_global $P3753, "GLOBAL"
    nqp_get_package_through_who $P3754, $P3753, "PAST"
    get_who $P3755, $P3754
    set $P3756, $P3755["Stmts"]
    find_lex $P3757, "$/"
    unless_null $P3757, vivify_1911
    new $P3757, "Undef"
  vivify_1911:
    $P3758 = $P3756."new"($P3757 :named("node"))
    store_lex "$past", $P3758
.annotate 'line', 1332
    find_lex $P3760, "$/"
    unless_null $P3760, vivify_1912
    $P3760 = root_new ['parrot';'Hash']
  vivify_1912:
    set $P3761, $P3760["statement"]
    unless_null $P3761, vivify_1913
    new $P3761, "Undef"
  vivify_1913:
    unless $P3761, if_3759_end
.annotate 'line', 1333
    find_lex $P3763, "$/"
    unless_null $P3763, vivify_1914
    $P3763 = root_new ['parrot';'Hash']
  vivify_1914:
    set $P3764, $P3763["statement"]
    unless_null $P3764, vivify_1915
    new $P3764, "Undef"
  vivify_1915:
    defined $I3765, $P3764
    unless $I3765, for_undef_1916
    iter $P3762, $P3764
    new $P3788, 'ExceptionHandler'
    set_label $P3788, loop3787_handler
    $P3788."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3788
  loop3787_test:
    unless $P3762, loop3787_done
    shift $P3766, $P3762
  loop3787_redo:
    .const 'Sub' $P3768 = "470_1307873304.82979" 
    capture_lex $P3768
    $P3768($P3766)
  loop3787_next:
    goto loop3787_test
  loop3787_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3789, exception, 'type'
    eq $P3789, .CONTROL_LOOP_NEXT, loop3787_next
    eq $P3789, .CONTROL_LOOP_REDO, loop3787_redo
  loop3787_done:
    pop_eh 
  for_undef_1916:
  if_3759_end:
.annotate 'line', 1340
    find_lex $P3790, "$/"
    find_lex $P3791, "$past"
    unless_null $P3791, vivify_1927
    new $P3791, "Undef"
  vivify_1927:
    $P3792 = $P3790."!make"($P3791)
.annotate 'line', 1330
    .return ($P3792)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3767"  :anon :subid("470_1307873304.82979") :outer("469_1307873304.82979")
    .param pmc param_3770
.annotate 'line', 1334
    new $P3769, "Undef"
    .lex "$ast", $P3769
    .lex "$_", param_3770
    find_lex $P3771, "$_"
    unless_null $P3771, vivify_1917
    new $P3771, "Undef"
  vivify_1917:
    $P3772 = $P3771."ast"()
    store_lex "$ast", $P3772
.annotate 'line', 1335
    find_lex $P3774, "$ast"
    unless_null $P3774, vivify_1918
    $P3774 = root_new ['parrot';'Hash']
  vivify_1918:
    set $P3775, $P3774["sink"]
    unless_null $P3775, vivify_1919
    new $P3775, "Undef"
  vivify_1919:
    defined $I3776, $P3775
    unless $I3776, if_3773_end
    find_lex $P3777, "$ast"
    unless_null $P3777, vivify_1920
    $P3777 = root_new ['parrot';'Hash']
  vivify_1920:
    set $P3778, $P3777["sink"]
    unless_null $P3778, vivify_1921
    new $P3778, "Undef"
  vivify_1921:
    store_lex "$ast", $P3778
  if_3773_end:
.annotate 'line', 1336
    find_lex $P3780, "$ast"
    unless_null $P3780, vivify_1922
    $P3780 = root_new ['parrot';'Hash']
  vivify_1922:
    set $P3781, $P3780["bareblock"]
    unless_null $P3781, vivify_1923
    new $P3781, "Undef"
  vivify_1923:
    unless $P3781, if_3779_end
    find_lex $P3782, "$ast"
    unless_null $P3782, vivify_1924
    new $P3782, "Undef"
  vivify_1924:
    $P3783 = "block_immediate"($P3782)
    store_lex "$ast", $P3783
  if_3779_end:
.annotate 'line', 1337
    find_lex $P3784, "$past"
    unless_null $P3784, vivify_1925
    new $P3784, "Undef"
  vivify_1925:
    find_lex $P3785, "$ast"
    unless_null $P3785, vivify_1926
    new $P3785, "Undef"
  vivify_1926:
    $P3786 = $P3784."push"($P3785)
.annotate 'line', 1333
    .return ($P3786)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement" :anon :subid("471_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_3794
    .param pmc param_3795
    .param pmc param_3796 :optional
    .param int has_param_3796 :opt_flag
.annotate 'line', 1343
    .const 'Sub' $P3804 = "472_1307873304.82979" 
    capture_lex $P3804
    .lex "self", param_3794
    .lex "$/", param_3795
    if has_param_3796, optparam_1928
    new $P3797, "Undef"
    set param_3796, $P3797
  optparam_1928:
    .lex "$key", param_3796
.annotate 'line', 1344
    new $P3798, "Undef"
    .lex "$past", $P3798
.annotate 'line', 1343
    find_lex $P3799, "$past"
    unless_null $P3799, vivify_1929
    new $P3799, "Undef"
  vivify_1929:
.annotate 'line', 1345
    find_lex $P3801, "$/"
    unless_null $P3801, vivify_1930
    $P3801 = root_new ['parrot';'Hash']
  vivify_1930:
    set $P3802, $P3801["EXPR"]
    unless_null $P3802, vivify_1931
    new $P3802, "Undef"
  vivify_1931:
    if $P3802, if_3800
.annotate 'line', 1366
    find_lex $P3880, "$/"
    unless_null $P3880, vivify_1932
    $P3880 = root_new ['parrot';'Hash']
  vivify_1932:
    set $P3881, $P3880["statement_control"]
    unless_null $P3881, vivify_1933
    new $P3881, "Undef"
  vivify_1933:
    if $P3881, if_3879
.annotate 'line', 1367
    new $P3885, "Integer"
    assign $P3885, 0
    store_lex "$past", $P3885
    goto if_3879_end
  if_3879:
.annotate 'line', 1366
    find_lex $P3882, "$/"
    unless_null $P3882, vivify_1934
    $P3882 = root_new ['parrot';'Hash']
  vivify_1934:
    set $P3883, $P3882["statement_control"]
    unless_null $P3883, vivify_1935
    new $P3883, "Undef"
  vivify_1935:
    $P3884 = $P3883."ast"()
    store_lex "$past", $P3884
  if_3879_end:
    goto if_3800_end
  if_3800:
.annotate 'line', 1345
    .const 'Sub' $P3804 = "472_1307873304.82979" 
    capture_lex $P3804
    $P3804()
  if_3800_end:
.annotate 'line', 1368
    find_lex $P3886, "$/"
    find_lex $P3887, "$past"
    unless_null $P3887, vivify_1969
    new $P3887, "Undef"
  vivify_1969:
    $P3888 = $P3886."!make"($P3887)
.annotate 'line', 1343
    .return ($P3888)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3803"  :anon :subid("472_1307873304.82979") :outer("471_1307873304.82979")
.annotate 'line', 1346
    new $P3805, "Undef"
    .lex "$mc", $P3805
.annotate 'line', 1347
    new $P3806, "Undef"
    .lex "$ml", $P3806
.annotate 'line', 1346
    find_lex $P3807, "$/"
    unless_null $P3807, vivify_1936
    $P3807 = root_new ['parrot';'Hash']
  vivify_1936:
    set $P3808, $P3807["statement_mod_cond"]
    unless_null $P3808, vivify_1937
    $P3808 = root_new ['parrot';'ResizablePMCArray']
  vivify_1937:
    set $P3809, $P3808[0]
    unless_null $P3809, vivify_1938
    new $P3809, "Undef"
  vivify_1938:
    store_lex "$mc", $P3809
.annotate 'line', 1347
    find_lex $P3810, "$/"
    unless_null $P3810, vivify_1939
    $P3810 = root_new ['parrot';'Hash']
  vivify_1939:
    set $P3811, $P3810["statement_mod_loop"]
    unless_null $P3811, vivify_1940
    $P3811 = root_new ['parrot';'ResizablePMCArray']
  vivify_1940:
    set $P3812, $P3811[0]
    unless_null $P3812, vivify_1941
    new $P3812, "Undef"
  vivify_1941:
    store_lex "$ml", $P3812
.annotate 'line', 1348
    find_lex $P3813, "$/"
    unless_null $P3813, vivify_1942
    $P3813 = root_new ['parrot';'Hash']
  vivify_1942:
    set $P3814, $P3813["EXPR"]
    unless_null $P3814, vivify_1943
    new $P3814, "Undef"
  vivify_1943:
    $P3815 = $P3814."ast"()
    store_lex "$past", $P3815
.annotate 'line', 1349
    find_lex $P3817, "$mc"
    unless_null $P3817, vivify_1944
    new $P3817, "Undef"
  vivify_1944:
    unless $P3817, if_3816_end
.annotate 'line', 1350
    get_hll_global $P3818, "GLOBAL"
    nqp_get_package_through_who $P3819, $P3818, "PAST"
    get_who $P3820, $P3819
    set $P3821, $P3820["Op"]
    find_lex $P3822, "$mc"
    unless_null $P3822, vivify_1945
    $P3822 = root_new ['parrot';'Hash']
  vivify_1945:
    set $P3823, $P3822["cond"]
    unless_null $P3823, vivify_1946
    new $P3823, "Undef"
  vivify_1946:
    $P3824 = $P3823."ast"()
    find_lex $P3825, "$past"
    unless_null $P3825, vivify_1947
    new $P3825, "Undef"
  vivify_1947:
    find_lex $P3826, "$mc"
    unless_null $P3826, vivify_1948
    $P3826 = root_new ['parrot';'Hash']
  vivify_1948:
    set $P3827, $P3826["sym"]
    unless_null $P3827, vivify_1949
    new $P3827, "Undef"
  vivify_1949:
    set $S3828, $P3827
    find_lex $P3829, "$/"
    unless_null $P3829, vivify_1950
    new $P3829, "Undef"
  vivify_1950:
    $P3830 = $P3821."new"($P3824, $P3825, $S3828 :named("pasttype"), $P3829 :named("node"))
    store_lex "$past", $P3830
  if_3816_end:
.annotate 'line', 1352
    find_lex $P3833, "$ml"
    unless_null $P3833, vivify_1951
    new $P3833, "Undef"
  vivify_1951:
    if $P3833, if_3832
    set $P3831, $P3833
    goto if_3832_end
  if_3832:
.annotate 'line', 1353
    find_lex $P3836, "$ml"
    unless_null $P3836, vivify_1952
    $P3836 = root_new ['parrot';'Hash']
  vivify_1952:
    set $P3837, $P3836["sym"]
    unless_null $P3837, vivify_1953
    new $P3837, "Undef"
  vivify_1953:
    set $S3838, $P3837
    iseq $I3839, $S3838, "for"
    if $I3839, if_3835
.annotate 'line', 1362
    get_hll_global $P3866, "GLOBAL"
    nqp_get_package_through_who $P3867, $P3866, "PAST"
    get_who $P3868, $P3867
    set $P3869, $P3868["Op"]
    find_lex $P3870, "$ml"
    unless_null $P3870, vivify_1954
    $P3870 = root_new ['parrot';'Hash']
  vivify_1954:
    set $P3871, $P3870["cond"]
    unless_null $P3871, vivify_1955
    new $P3871, "Undef"
  vivify_1955:
    $P3872 = $P3871."ast"()
    find_lex $P3873, "$past"
    unless_null $P3873, vivify_1956
    new $P3873, "Undef"
  vivify_1956:
    find_lex $P3874, "$ml"
    unless_null $P3874, vivify_1957
    $P3874 = root_new ['parrot';'Hash']
  vivify_1957:
    set $P3875, $P3874["sym"]
    unless_null $P3875, vivify_1958
    new $P3875, "Undef"
  vivify_1958:
    set $S3876, $P3875
    find_lex $P3877, "$/"
    unless_null $P3877, vivify_1959
    new $P3877, "Undef"
  vivify_1959:
    $P3878 = $P3869."new"($P3872, $P3873, $S3876 :named("pasttype"), $P3877 :named("node"))
    store_lex "$past", $P3878
.annotate 'line', 1361
    set $P3834, $P3878
.annotate 'line', 1353
    goto if_3835_end
  if_3835:
.annotate 'line', 1354
    get_hll_global $P3840, "GLOBAL"
    nqp_get_package_through_who $P3841, $P3840, "PAST"
    get_who $P3842, $P3841
    set $P3843, $P3842["Block"]
.annotate 'line', 1355
    get_hll_global $P3844, "GLOBAL"
    nqp_get_package_through_who $P3845, $P3844, "PAST"
    get_who $P3846, $P3845
    set $P3847, $P3846["Var"]
    $P3848 = $P3847."new"("$_" :named("name"), "parameter" :named("scope"), 1 :named("isdecl"))
    find_lex $P3849, "$past"
    unless_null $P3849, vivify_1960
    new $P3849, "Undef"
  vivify_1960:
    $P3850 = $P3843."new"($P3848, $P3849, "immediate" :named("blocktype"))
.annotate 'line', 1354
    store_lex "$past", $P3850
.annotate 'line', 1357
    find_lex $P3851, "$past"
    unless_null $P3851, vivify_1961
    new $P3851, "Undef"
  vivify_1961:
    $P3851."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 1358
    find_lex $P3852, "$past"
    unless_null $P3852, vivify_1962
    new $P3852, "Undef"
  vivify_1962:
    $P3852."arity"(1)
.annotate 'line', 1359
    get_hll_global $P3853, "GLOBAL"
    nqp_get_package_through_who $P3854, $P3853, "PAST"
    get_who $P3855, $P3854
    set $P3856, $P3855["Op"]
    find_lex $P3857, "$ml"
    unless_null $P3857, vivify_1963
    $P3857 = root_new ['parrot';'Hash']
  vivify_1963:
    set $P3858, $P3857["cond"]
    unless_null $P3858, vivify_1964
    new $P3858, "Undef"
  vivify_1964:
    $P3859 = $P3858."ast"()
    find_lex $P3860, "$past"
    unless_null $P3860, vivify_1965
    new $P3860, "Undef"
  vivify_1965:
    find_lex $P3861, "$ml"
    unless_null $P3861, vivify_1966
    $P3861 = root_new ['parrot';'Hash']
  vivify_1966:
    set $P3862, $P3861["sym"]
    unless_null $P3862, vivify_1967
    new $P3862, "Undef"
  vivify_1967:
    set $S3863, $P3862
    find_lex $P3864, "$/"
    unless_null $P3864, vivify_1968
    new $P3864, "Undef"
  vivify_1968:
    $P3865 = $P3856."new"($P3859, $P3860, $S3863 :named("pasttype"), $P3864 :named("node"))
    store_lex "$past", $P3865
.annotate 'line', 1353
    set $P3834, $P3865
  if_3835_end:
.annotate 'line', 1352
    set $P3831, $P3834
  if_3832_end:
.annotate 'line', 1345
    .return ($P3831)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock" :anon :subid("473_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_3890
    .param pmc param_3891
.annotate 'line', 1371
    .lex "self", param_3890
    .lex "$/", param_3891
.annotate 'line', 1372
    find_lex $P3892, "$/"
    get_hll_global $P3893, "GLOBAL"
    nqp_get_package_through_who $P3894, $P3893, "PAST"
    get_who $P3895, $P3894
    set $P3896, $P3895["Op"]
    find_lex $P3897, "$/"
    unless_null $P3897, vivify_1970
    $P3897 = root_new ['parrot';'Hash']
  vivify_1970:
    set $P3898, $P3897["EXPR"]
    unless_null $P3898, vivify_1971
    new $P3898, "Undef"
  vivify_1971:
    $P3899 = $P3898."ast"()
    find_lex $P3900, "$/"
    unless_null $P3900, vivify_1972
    $P3900 = root_new ['parrot';'Hash']
  vivify_1972:
    set $P3901, $P3900["pblock"]
    unless_null $P3901, vivify_1973
    new $P3901, "Undef"
  vivify_1973:
    $P3902 = $P3901."ast"()
    find_lex $P3903, "$/"
    unless_null $P3903, vivify_1974
    new $P3903, "Undef"
  vivify_1974:
    $P3904 = $P3896."new"($P3899, $P3902, "if" :named("pasttype"), $P3903 :named("node"))
    $P3905 = $P3892."!make"($P3904)
.annotate 'line', 1371
    .return ($P3905)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "pblock" :anon :subid("474_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_3907
    .param pmc param_3908
.annotate 'line', 1375
    .lex "self", param_3907
    .lex "$/", param_3908
.annotate 'line', 1376
    find_lex $P3909, "$/"
    find_lex $P3910, "$/"
    unless_null $P3910, vivify_1975
    $P3910 = root_new ['parrot';'Hash']
  vivify_1975:
    set $P3911, $P3910["blockoid"]
    unless_null $P3911, vivify_1976
    new $P3911, "Undef"
  vivify_1976:
    $P3912 = $P3911."ast"()
    $P3913 = $P3909."!make"($P3912)
.annotate 'line', 1375
    .return ($P3913)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block" :anon :subid("475_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_3915
    .param pmc param_3916
.annotate 'line', 1379
    .lex "self", param_3915
    .lex "$/", param_3916
.annotate 'line', 1380
    find_lex $P3917, "$/"
    find_lex $P3918, "$/"
    unless_null $P3918, vivify_1977
    $P3918 = root_new ['parrot';'Hash']
  vivify_1977:
    set $P3919, $P3918["blockoid"]
    unless_null $P3919, vivify_1978
    new $P3919, "Undef"
  vivify_1978:
    $P3920 = $P3919."ast"()
    $P3921 = $P3917."!make"($P3920)
.annotate 'line', 1379
    .return ($P3921)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blockoid" :anon :subid("476_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_3923
    .param pmc param_3924
.annotate 'line', 1383
    .const 'Sub' $P3935 = "477_1307873304.82979" 
    capture_lex $P3935
    .lex "self", param_3923
    .lex "$/", param_3924
.annotate 'line', 1384
    new $P3925, "Undef"
    .lex "$BLOCK", $P3925
    find_lex $P3926, "$?PACKAGE"
    get_who $P3927, $P3926
    set $P3928, $P3927["@BLOCK"]
    unless_null $P3928, vivify_1979
    $P3928 = root_new ['parrot';'ResizablePMCArray']
  vivify_1979:
    $P3929 = $P3928."shift"()
    store_lex "$BLOCK", $P3929
.annotate 'line', 1385
    find_lex $P3932, "$/"
    unless_null $P3932, vivify_1980
    $P3932 = root_new ['parrot';'Hash']
  vivify_1980:
    set $P3933, $P3932["statementlist"]
    unless_null $P3933, vivify_1981
    new $P3933, "Undef"
  vivify_1981:
    if $P3933, if_3931
.annotate 'line', 1393
    find_dynamic_lex $P3952, "$*HAS_YOU_ARE_HERE"
    unless_null $P3952, vivify_1982
    get_hll_global $P3950, "GLOBAL"
    get_who $P3951, $P3950
    set $P3952, $P3951["$HAS_YOU_ARE_HERE"]
    unless_null $P3952, vivify_1983
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_1983:
  vivify_1982:
    unless $P3952, if_3949_end
.annotate 'line', 1394
    find_lex $P3953, "$/"
    unless_null $P3953, vivify_1984
    new $P3953, "Undef"
  vivify_1984:
    $P3954 = $P3953."CURSOR"()
    $P3954."panic"("{YOU_ARE_HERE} may only appear once in a setting")
  if_3949_end:
.annotate 'line', 1396
    new $P3955, "Integer"
    assign $P3955, 1
    store_dynamic_lex "$*HAS_YOU_ARE_HERE", $P3955
.annotate 'line', 1397
    find_lex $P3956, "$/"
    find_lex $P3957, "$/"
    unless_null $P3957, vivify_1985
    $P3957 = root_new ['parrot';'Hash']
  vivify_1985:
    set $P3958, $P3957["you_are_here"]
    unless_null $P3958, vivify_1986
    new $P3958, "Undef"
  vivify_1986:
    $P3959 = $P3958."ast"()
    $P3960 = $P3956."!make"($P3959)
.annotate 'line', 1392
    set $P3930, $P3960
.annotate 'line', 1385
    goto if_3931_end
  if_3931:
    .const 'Sub' $P3935 = "477_1307873304.82979" 
    capture_lex $P3935
    $P3948 = $P3935()
    set $P3930, $P3948
  if_3931_end:
.annotate 'line', 1383
    .return ($P3930)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3934"  :anon :subid("477_1307873304.82979") :outer("476_1307873304.82979")
.annotate 'line', 1386
    new $P3936, "Undef"
    .lex "$past", $P3936
    find_lex $P3937, "$/"
    unless_null $P3937, vivify_1987
    $P3937 = root_new ['parrot';'Hash']
  vivify_1987:
    set $P3938, $P3937["statementlist"]
    unless_null $P3938, vivify_1988
    new $P3938, "Undef"
  vivify_1988:
    $P3939 = $P3938."ast"()
    store_lex "$past", $P3939
.annotate 'line', 1387
    find_lex $P3940, "$BLOCK"
    unless_null $P3940, vivify_1989
    new $P3940, "Undef"
  vivify_1989:
    find_lex $P3941, "$past"
    unless_null $P3941, vivify_1990
    new $P3941, "Undef"
  vivify_1990:
    $P3940."push"($P3941)
.annotate 'line', 1388
    find_lex $P3942, "$BLOCK"
    unless_null $P3942, vivify_1991
    new $P3942, "Undef"
  vivify_1991:
    find_lex $P3943, "$/"
    unless_null $P3943, vivify_1992
    new $P3943, "Undef"
  vivify_1992:
    $P3942."node"($P3943)
.annotate 'line', 1389
    find_lex $P3944, "$BLOCK"
    unless_null $P3944, vivify_1993
    new $P3944, "Undef"
  vivify_1993:
    $P3944."closure"(1)
.annotate 'line', 1390
    find_dynamic_lex $P3945, "$/"
    find_lex $P3946, "$BLOCK"
    unless_null $P3946, vivify_1994
    new $P3946, "Undef"
  vivify_1994:
    $P3947 = $P3945."!make"($P3946)
.annotate 'line', 1385
    .return ($P3947)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "newpad" :anon :subid("478_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_3962
    .param pmc param_3963
.annotate 'line', 1401
    .lex "self", param_3962
    .lex "$/", param_3963
.annotate 'line', 1402
    find_lex $P3964, "$?PACKAGE"
    get_who $P3965, $P3964
    set $P3966, $P3965["@BLOCK"]
    unless_null $P3966, vivify_1995
    $P3966 = root_new ['parrot';'ResizablePMCArray']
  vivify_1995:
    get_hll_global $P3967, "GLOBAL"
    nqp_get_package_through_who $P3968, $P3967, "PAST"
    get_who $P3969, $P3968
    set $P3970, $P3969["Block"]
    get_hll_global $P3971, "GLOBAL"
    nqp_get_package_through_who $P3972, $P3971, "PAST"
    get_who $P3973, $P3972
    set $P3974, $P3973["Stmts"]
    $P3975 = $P3974."new"()
    $P3976 = $P3970."new"($P3975)
    $P3977 = $P3966."unshift"($P3976)
.annotate 'line', 1401
    .return ($P3977)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "outerctx" :anon :subid("479_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_3979
    .param pmc param_3980
.annotate 'line', 1405
    .const 'Sub' $P3989 = "480_1307873304.82979" 
    capture_lex $P3989
    .lex "self", param_3979
    .lex "$/", param_3980
.annotate 'line', 1406
    find_dynamic_lex $P3984, "%*COMPILING"
    unless_null $P3984, vivify_1996
    get_hll_global $P3982, "GLOBAL"
    get_who $P3983, $P3982
    set $P3984, $P3983["%COMPILING"]
    unless_null $P3984, vivify_1997
    die "Contextual %*COMPILING not found"
  vivify_1997:
  vivify_1996:
    set $P3985, $P3984["%?OPTIONS"]
    unless_null $P3985, vivify_1998
    $P3985 = root_new ['parrot';'Hash']
  vivify_1998:
    set $P3986, $P3985["outer_ctx"]
    unless_null $P3986, vivify_1999
    new $P3986, "Undef"
  vivify_1999:
    defined $I3987, $P3986
    if $I3987, unless_3981_end
    .const 'Sub' $P3989 = "480_1307873304.82979" 
    capture_lex $P3989
    $P3989()
  unless_3981_end:
.annotate 'line', 1419
    find_lex $P4021, "self"
    find_lex $P4022, "$?PACKAGE"
    get_who $P4023, $P4022
    set $P4024, $P4023["@BLOCK"]
    unless_null $P4024, vivify_2015
    $P4024 = root_new ['parrot';'ResizablePMCArray']
  vivify_2015:
    set $P4025, $P4024[0]
    unless_null $P4025, vivify_2016
    new $P4025, "Undef"
  vivify_2016:
    $P4026 = $P4021."SET_BLOCK_OUTER_CTX"($P4025)
.annotate 'line', 1405
    .return ($P4026)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3988"  :anon :subid("480_1307873304.82979") :outer("479_1307873304.82979")
.annotate 'line', 1409
    new $P3990, "Undef"
    .lex "$SETTING", $P3990
    find_dynamic_lex $P3993, "$*SC"
    unless_null $P3993, vivify_2000
    get_hll_global $P3991, "GLOBAL"
    get_who $P3992, $P3991
    set $P3993, $P3992["$SC"]
    unless_null $P3993, vivify_2001
    die "Contextual $*SC not found"
  vivify_2001:
  vivify_2000:
    find_dynamic_lex $P3997, "%*COMPILING"
    unless_null $P3997, vivify_2002
    get_hll_global $P3995, "GLOBAL"
    get_who $P3996, $P3995
    set $P3997, $P3996["%COMPILING"]
    unless_null $P3997, vivify_2003
    die "Contextual %*COMPILING not found"
  vivify_2003:
  vivify_2002:
    set $P3998, $P3997["%?OPTIONS"]
    unless_null $P3998, vivify_2004
    $P3998 = root_new ['parrot';'Hash']
  vivify_2004:
    set $P3999, $P3998["setting"]
    unless_null $P3999, vivify_2005
    new $P3999, "Undef"
  vivify_2005:
    set $P3994, $P3999
    defined $I4001, $P3994
    if $I4001, default_4000
    new $P4002, "String"
    assign $P4002, "NQPCORE"
    set $P3994, $P4002
  default_4000:
    $P4003 = $P3993."load_setting"($P3994)
    store_lex "$SETTING", $P4003
.annotate 'line', 1414
    find_dynamic_lex $P4008, "%*COMPILING"
    unless_null $P4008, vivify_2006
    get_hll_global $P4006, "GLOBAL"
    get_who $P4007, $P4006
    set $P4008, $P4007["%COMPILING"]
    unless_null $P4008, vivify_2007
    die "Contextual %*COMPILING not found"
  vivify_2007:
  vivify_2006:
    set $P4009, $P4008["%?OPTIONS"]
    unless_null $P4009, vivify_2008
    $P4009 = root_new ['parrot';'Hash']
  vivify_2008:
    set $P4010, $P4009["setting"]
    unless_null $P4010, vivify_2009
    new $P4010, "Undef"
  vivify_2009:
    set $S4011, $P4010
    iseq $I4012, $S4011, "NULL"
    unless $I4012, unless_4005
    new $P4004, 'Integer'
    set $P4004, $I4012
    goto unless_4005_end
  unless_4005:
.annotate 'line', 1415
    find_lex $P4013, "$SETTING"
    unless_null $P4013, vivify_2010
    new $P4013, "Undef"
  vivify_2010:
    "import_HOW_exports"($P4013)
.annotate 'line', 1416
    find_dynamic_lex $P4016, "$*SC"
    unless_null $P4016, vivify_2011
    get_hll_global $P4014, "GLOBAL"
    get_who $P4015, $P4014
    set $P4016, $P4015["$SC"]
    unless_null $P4016, vivify_2012
    die "Contextual $*SC not found"
  vivify_2012:
  vivify_2011:
    find_dynamic_lex $P4019, "$*GLOBALish"
    unless_null $P4019, vivify_2013
    get_hll_global $P4017, "GLOBAL"
    get_who $P4018, $P4017
    set $P4019, $P4018["$GLOBALish"]
    unless_null $P4019, vivify_2014
    die "Contextual $*GLOBALish not found"
  vivify_2014:
  vivify_2013:
    $P4020 = $P4016."load_module"("NQPRegex", $P4019)
.annotate 'line', 1414
    set $P4004, $P4020
  unless_4005_end:
.annotate 'line', 1406
    .return ($P4004)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "GLOBALish" :anon :subid("481_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_4029
    .param pmc param_4030
.annotate 'line', 1431
    .lex "self", param_4029
    .lex "$/", param_4030
.annotate 'line', 1435
    find_dynamic_lex $P4033, "$*SC"
    unless_null $P4033, vivify_2017
    get_hll_global $P4031, "GLOBAL"
    get_who $P4032, $P4031
    set $P4033, $P4032["$SC"]
    unless_null $P4033, vivify_2018
    die "Contextual $*SC not found"
  vivify_2018:
  vivify_2017:
    find_dynamic_lex $P4036, "%*HOW"
    unless_null $P4036, vivify_2019
    get_hll_global $P4034, "GLOBAL"
    get_who $P4035, $P4034
    set $P4036, $P4035["%HOW"]
    unless_null $P4036, vivify_2020
    die "Contextual %*HOW not found"
  vivify_2020:
  vivify_2019:
    set $P4037, $P4036["knowhow"]
    unless_null $P4037, vivify_2021
    new $P4037, "Undef"
  vivify_2021:
    $P4038 = $P4033."pkg_create_mo"($P4037, "GLOBALish" :named("name"))
    store_dynamic_lex "$*GLOBALish", $P4038
.annotate 'line', 1436
    find_dynamic_lex $P4041, "$*GLOBALish"
    unless_null $P4041, vivify_2022
    get_hll_global $P4039, "GLOBAL"
    get_who $P4040, $P4039
    set $P4041, $P4040["$GLOBALish"]
    unless_null $P4041, vivify_2023
    die "Contextual $*GLOBALish not found"
  vivify_2023:
  vivify_2022:
    get_how $P4042, $P4041
    find_dynamic_lex $P4045, "$*GLOBALish"
    unless_null $P4045, vivify_2024
    get_hll_global $P4043, "GLOBAL"
    get_who $P4044, $P4043
    set $P4045, $P4044["$GLOBALish"]
    unless_null $P4045, vivify_2025
    die "Contextual $*GLOBALish not found"
  vivify_2025:
  vivify_2024:
    $P4042."compose"($P4045)
.annotate 'line', 1437
    find_dynamic_lex $P4048, "$*SC"
    unless_null $P4048, vivify_2026
    get_hll_global $P4046, "GLOBAL"
    get_who $P4047, $P4046
    set $P4048, $P4047["$SC"]
    unless_null $P4048, vivify_2027
    die "Contextual $*SC not found"
  vivify_2027:
  vivify_2026:
    find_lex $P4049, "$?PACKAGE"
    get_who $P4050, $P4049
    set $P4051, $P4050["@BLOCK"]
    unless_null $P4051, vivify_2028
    $P4051 = root_new ['parrot';'ResizablePMCArray']
  vivify_2028:
    set $P4052, $P4051[0]
    unless_null $P4052, vivify_2029
    new $P4052, "Undef"
  vivify_2029:
    find_dynamic_lex $P4055, "$*GLOBALish"
    unless_null $P4055, vivify_2030
    get_hll_global $P4053, "GLOBAL"
    get_who $P4054, $P4053
    set $P4055, $P4054["$GLOBALish"]
    unless_null $P4055, vivify_2031
    die "Contextual $*GLOBALish not found"
  vivify_2031:
  vivify_2030:
    $P4048."install_lexical_symbol"($P4052, "GLOBALish", $P4055)
.annotate 'line', 1440
    find_dynamic_lex $P4058, "$*GLOBALish"
    unless_null $P4058, vivify_2032
    get_hll_global $P4056, "GLOBAL"
    get_who $P4057, $P4056
    set $P4058, $P4057["$GLOBALish"]
    unless_null $P4058, vivify_2033
    die "Contextual $*GLOBALish not found"
  vivify_2033:
  vivify_2032:
    store_dynamic_lex "$*PACKAGE", $P4058
.annotate 'line', 1441
    find_dynamic_lex $P4061, "$*SC"
    unless_null $P4061, vivify_2034
    get_hll_global $P4059, "GLOBAL"
    get_who $P4060, $P4059
    set $P4061, $P4060["$SC"]
    unless_null $P4061, vivify_2035
    die "Contextual $*SC not found"
  vivify_2035:
  vivify_2034:
    find_lex $P4062, "$?PACKAGE"
    get_who $P4063, $P4062
    set $P4064, $P4063["@BLOCK"]
    unless_null $P4064, vivify_2036
    $P4064 = root_new ['parrot';'ResizablePMCArray']
  vivify_2036:
    set $P4065, $P4064[0]
    unless_null $P4065, vivify_2037
    new $P4065, "Undef"
  vivify_2037:
    find_dynamic_lex $P4068, "$*PACKAGE"
    unless_null $P4068, vivify_2038
    get_hll_global $P4066, "GLOBAL"
    get_who $P4067, $P4066
    set $P4068, $P4067["$PACKAGE"]
    unless_null $P4068, vivify_2039
    die "Contextual $*PACKAGE not found"
  vivify_2039:
  vivify_2038:
    $P4069 = $P4061."install_lexical_symbol"($P4065, "$?PACKAGE", $P4068)
.annotate 'line', 1431
    .return ($P4069)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "you_are_here" :anon :subid("482_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_4071
    .param pmc param_4072
.annotate 'line', 1444
    .lex "self", param_4071
    .lex "$/", param_4072
.annotate 'line', 1445
    find_lex $P4073, "$/"
    find_lex $P4074, "self"
    $P4075 = $P4074."CTXSAVE"()
    $P4076 = $P4073."!make"($P4075)
.annotate 'line', 1444
    .return ($P4076)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<use>" :anon :subid("483_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_4078
    .param pmc param_4079
.annotate 'line', 1450
    .lex "self", param_4078
    .lex "$/", param_4079
.annotate 'line', 1451
    new $P4080, "Undef"
    .lex "$module", $P4080
    find_dynamic_lex $P4083, "$*SC"
    unless_null $P4083, vivify_2040
    get_hll_global $P4081, "GLOBAL"
    get_who $P4082, $P4081
    set $P4083, $P4082["$SC"]
    unless_null $P4083, vivify_2041
    die "Contextual $*SC not found"
  vivify_2041:
  vivify_2040:
    find_lex $P4084, "$/"
    unless_null $P4084, vivify_2042
    $P4084 = root_new ['parrot';'Hash']
  vivify_2042:
    set $P4085, $P4084["name"]
    unless_null $P4085, vivify_2043
    new $P4085, "Undef"
  vivify_2043:
    set $S4086, $P4085
    find_dynamic_lex $P4089, "$*GLOBALish"
    unless_null $P4089, vivify_2044
    get_hll_global $P4087, "GLOBAL"
    get_who $P4088, $P4087
    set $P4089, $P4088["$GLOBALish"]
    unless_null $P4089, vivify_2045
    die "Contextual $*GLOBALish not found"
  vivify_2045:
  vivify_2044:
    $P4090 = $P4083."load_module"($S4086, $P4089)
    store_lex "$module", $P4090
.annotate 'line', 1452
    find_lex $P4092, "$module"
    unless_null $P4092, vivify_2046
    new $P4092, "Undef"
  vivify_2046:
    defined $I4093, $P4092
    unless $I4093, if_4091_end
.annotate 'line', 1453
    find_lex $P4094, "$module"
    unless_null $P4094, vivify_2047
    new $P4094, "Undef"
  vivify_2047:
    "import_HOW_exports"($P4094)
  if_4091_end:
.annotate 'line', 1455
    find_lex $P4095, "$/"
    get_hll_global $P4096, "GLOBAL"
    nqp_get_package_through_who $P4097, $P4096, "PAST"
    get_who $P4098, $P4097
    set $P4099, $P4098["Stmts"]
    $P4100 = $P4099."new"()
    $P4101 = $P4095."!make"($P4100)
.annotate 'line', 1450
    .return ($P4101)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statement_control:sym<if>" :anon :subid("484_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_4103
    .param pmc param_4104
.annotate 'line', 1458
    .const 'Sub' $P4132 = "485_1307873304.82979" 
    capture_lex $P4132
    .lex "self", param_4103
    .lex "$/", param_4104
.annotate 'line', 1459
    new $P4105, "Undef"
    .lex "$count", $P4105
.annotate 'line', 1460
    new $P4106, "Undef"
    .lex "$past", $P4106
.annotate 'line', 1459
    find_lex $P4107, "$/"
    unless_null $P4107, vivify_2048
    $P4107 = root_new ['parrot';'Hash']
  vivify_2048:
    set $P4108, $P4107["xblock"]
    unless_null $P4108, vivify_2049
    new $P4108, "Undef"
  vivify_2049:
    set $N4109, $P4108
    new $P4110, 'Float'
    set $P4110, $N4109
    sub $P4111, $P4110, 1
    store_lex "$count", $P4111
.annotate 'line', 1460
    find_lex $P4112, "$count"
    unless_null $P4112, vivify_2050
    new $P4112, "Undef"
  vivify_2050:
    set $I4113, $P4112
    find_lex $P4114, "$/"
    unless_null $P4114, vivify_2051
    $P4114 = root_new ['parrot';'Hash']
  vivify_2051:
    set $P4115, $P4114["xblock"]
    unless_null $P4115, vivify_2052
    $P4115 = root_new ['parrot';'ResizablePMCArray']
  vivify_2052:
    set $P4116, $P4115[$I4113]
    unless_null $P4116, vivify_2053
    new $P4116, "Undef"
  vivify_2053:
    $P4117 = $P4116."ast"()
    $P4118 = "xblock_immediate"($P4117)
    store_lex "$past", $P4118
.annotate 'line', 1461
    find_lex $P4120, "$/"
    unless_null $P4120, vivify_2054
    $P4120 = root_new ['parrot';'Hash']
  vivify_2054:
    set $P4121, $P4120["else"]
    unless_null $P4121, vivify_2055
    new $P4121, "Undef"
  vivify_2055:
    unless $P4121, if_4119_end
.annotate 'line', 1462
    find_lex $P4122, "$past"
    unless_null $P4122, vivify_2056
    new $P4122, "Undef"
  vivify_2056:
    find_lex $P4123, "$/"
    unless_null $P4123, vivify_2057
    $P4123 = root_new ['parrot';'Hash']
  vivify_2057:
    set $P4124, $P4123["else"]
    unless_null $P4124, vivify_2058
    $P4124 = root_new ['parrot';'ResizablePMCArray']
  vivify_2058:
    set $P4125, $P4124[0]
    unless_null $P4125, vivify_2059
    new $P4125, "Undef"
  vivify_2059:
    $P4126 = $P4125."ast"()
    $P4127 = "block_immediate"($P4126)
    $P4122."push"($P4127)
  if_4119_end:
.annotate 'line', 1465
    new $P4148, 'ExceptionHandler'
    set_label $P4148, loop4147_handler
    $P4148."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4148
  loop4147_test:
    find_lex $P4128, "$count"
    unless_null $P4128, vivify_2060
    new $P4128, "Undef"
  vivify_2060:
    set $N4129, $P4128
    isgt $I4130, $N4129, 0.0
    unless $I4130, loop4147_done
  loop4147_redo:
    .const 'Sub' $P4132 = "485_1307873304.82979" 
    capture_lex $P4132
    $P4132()
  loop4147_next:
    goto loop4147_test
  loop4147_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4149, exception, 'type'
    eq $P4149, .CONTROL_LOOP_NEXT, loop4147_next
    eq $P4149, .CONTROL_LOOP_REDO, loop4147_redo
  loop4147_done:
    pop_eh 
.annotate 'line', 1471
    find_lex $P4150, "$/"
    find_lex $P4151, "$past"
    unless_null $P4151, vivify_2069
    new $P4151, "Undef"
  vivify_2069:
    $P4152 = $P4150."!make"($P4151)
.annotate 'line', 1458
    .return ($P4152)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4131"  :anon :subid("485_1307873304.82979") :outer("484_1307873304.82979")
.annotate 'line', 1467
    new $P4133, "Undef"
    .lex "$else", $P4133
.annotate 'line', 1465
    find_lex $P4134, "$count"
    unless_null $P4134, vivify_2061
    new $P4134, "Undef"
  vivify_2061:
    clone $P4135, $P4134
    dec $P4134
.annotate 'line', 1467
    find_lex $P4136, "$past"
    unless_null $P4136, vivify_2062
    new $P4136, "Undef"
  vivify_2062:
    store_lex "$else", $P4136
.annotate 'line', 1468
    find_lex $P4137, "$count"
    unless_null $P4137, vivify_2063
    new $P4137, "Undef"
  vivify_2063:
    set $I4138, $P4137
    find_lex $P4139, "$/"
    unless_null $P4139, vivify_2064
    $P4139 = root_new ['parrot';'Hash']
  vivify_2064:
    set $P4140, $P4139["xblock"]
    unless_null $P4140, vivify_2065
    $P4140 = root_new ['parrot';'ResizablePMCArray']
  vivify_2065:
    set $P4141, $P4140[$I4138]
    unless_null $P4141, vivify_2066
    new $P4141, "Undef"
  vivify_2066:
    $P4142 = $P4141."ast"()
    $P4143 = "xblock_immediate"($P4142)
    store_lex "$past", $P4143
.annotate 'line', 1469
    find_lex $P4144, "$past"
    unless_null $P4144, vivify_2067
    new $P4144, "Undef"
  vivify_2067:
    find_lex $P4145, "$else"
    unless_null $P4145, vivify_2068
    new $P4145, "Undef"
  vivify_2068:
    $P4146 = $P4144."push"($P4145)
.annotate 'line', 1465
    .return ($P4146)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<unless>" :anon :subid("486_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_4154
    .param pmc param_4155
.annotate 'line', 1474
    .lex "self", param_4154
    .lex "$/", param_4155
.annotate 'line', 1475
    new $P4156, "Undef"
    .lex "$past", $P4156
    find_lex $P4157, "$/"
    unless_null $P4157, vivify_2070
    $P4157 = root_new ['parrot';'Hash']
  vivify_2070:
    set $P4158, $P4157["xblock"]
    unless_null $P4158, vivify_2071
    new $P4158, "Undef"
  vivify_2071:
    $P4159 = $P4158."ast"()
    $P4160 = "xblock_immediate"($P4159)
    store_lex "$past", $P4160
.annotate 'line', 1476
    find_lex $P4161, "$past"
    unless_null $P4161, vivify_2072
    new $P4161, "Undef"
  vivify_2072:
    $P4161."pasttype"("unless")
.annotate 'line', 1477
    find_lex $P4162, "$/"
    find_lex $P4163, "$past"
    unless_null $P4163, vivify_2073
    new $P4163, "Undef"
  vivify_2073:
    $P4164 = $P4162."!make"($P4163)
.annotate 'line', 1474
    .return ($P4164)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<while>" :anon :subid("487_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_4166
    .param pmc param_4167
.annotate 'line', 1480
    .lex "self", param_4166
    .lex "$/", param_4167
.annotate 'line', 1481
    new $P4168, "Undef"
    .lex "$past", $P4168
    find_lex $P4169, "$/"
    unless_null $P4169, vivify_2074
    $P4169 = root_new ['parrot';'Hash']
  vivify_2074:
    set $P4170, $P4169["xblock"]
    unless_null $P4170, vivify_2075
    new $P4170, "Undef"
  vivify_2075:
    $P4171 = $P4170."ast"()
    $P4172 = "xblock_immediate"($P4171)
    store_lex "$past", $P4172
.annotate 'line', 1482
    find_lex $P4173, "$past"
    unless_null $P4173, vivify_2076
    new $P4173, "Undef"
  vivify_2076:
    find_lex $P4174, "$/"
    unless_null $P4174, vivify_2077
    $P4174 = root_new ['parrot';'Hash']
  vivify_2077:
    set $P4175, $P4174["sym"]
    unless_null $P4175, vivify_2078
    new $P4175, "Undef"
  vivify_2078:
    set $S4176, $P4175
    $P4173."pasttype"($S4176)
.annotate 'line', 1483
    find_lex $P4177, "$/"
    find_lex $P4178, "$past"
    unless_null $P4178, vivify_2079
    new $P4178, "Undef"
  vivify_2079:
    $P4179 = $P4177."!make"($P4178)
.annotate 'line', 1480
    .return ($P4179)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<repeat>" :anon :subid("488_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_4181
    .param pmc param_4182
.annotate 'line', 1486
    .lex "self", param_4181
    .lex "$/", param_4182
.annotate 'line', 1487
    new $P4183, "Undef"
    .lex "$pasttype", $P4183
.annotate 'line', 1488
    new $P4184, "Undef"
    .lex "$past", $P4184
.annotate 'line', 1487
    new $P4185, "String"
    assign $P4185, "repeat_"
    find_lex $P4186, "$/"
    unless_null $P4186, vivify_2080
    $P4186 = root_new ['parrot';'Hash']
  vivify_2080:
    set $P4187, $P4186["wu"]
    unless_null $P4187, vivify_2081
    new $P4187, "Undef"
  vivify_2081:
    set $S4188, $P4187
    concat $P4189, $P4185, $S4188
    store_lex "$pasttype", $P4189
    find_lex $P4190, "$past"
    unless_null $P4190, vivify_2082
    new $P4190, "Undef"
  vivify_2082:
.annotate 'line', 1489
    find_lex $P4192, "$/"
    unless_null $P4192, vivify_2083
    $P4192 = root_new ['parrot';'Hash']
  vivify_2083:
    set $P4193, $P4192["xblock"]
    unless_null $P4193, vivify_2084
    new $P4193, "Undef"
  vivify_2084:
    if $P4193, if_4191
.annotate 'line', 1494
    get_hll_global $P4200, "GLOBAL"
    nqp_get_package_through_who $P4201, $P4200, "PAST"
    get_who $P4202, $P4201
    set $P4203, $P4202["Op"]
    find_lex $P4204, "$/"
    unless_null $P4204, vivify_2085
    $P4204 = root_new ['parrot';'Hash']
  vivify_2085:
    set $P4205, $P4204["EXPR"]
    unless_null $P4205, vivify_2086
    new $P4205, "Undef"
  vivify_2086:
    $P4206 = $P4205."ast"()
    find_lex $P4207, "$/"
    unless_null $P4207, vivify_2087
    $P4207 = root_new ['parrot';'Hash']
  vivify_2087:
    set $P4208, $P4207["pblock"]
    unless_null $P4208, vivify_2088
    new $P4208, "Undef"
  vivify_2088:
    $P4209 = $P4208."ast"()
    $P4210 = "block_immediate"($P4209)
    find_lex $P4211, "$pasttype"
    unless_null $P4211, vivify_2089
    new $P4211, "Undef"
  vivify_2089:
    find_lex $P4212, "$/"
    unless_null $P4212, vivify_2090
    new $P4212, "Undef"
  vivify_2090:
    $P4213 = $P4203."new"($P4206, $P4210, $P4211 :named("pasttype"), $P4212 :named("node"))
    store_lex "$past", $P4213
.annotate 'line', 1493
    goto if_4191_end
  if_4191:
.annotate 'line', 1490
    find_lex $P4194, "$/"
    unless_null $P4194, vivify_2091
    $P4194 = root_new ['parrot';'Hash']
  vivify_2091:
    set $P4195, $P4194["xblock"]
    unless_null $P4195, vivify_2092
    new $P4195, "Undef"
  vivify_2092:
    $P4196 = $P4195."ast"()
    $P4197 = "xblock_immediate"($P4196)
    store_lex "$past", $P4197
.annotate 'line', 1491
    find_lex $P4198, "$past"
    unless_null $P4198, vivify_2093
    new $P4198, "Undef"
  vivify_2093:
    find_lex $P4199, "$pasttype"
    unless_null $P4199, vivify_2094
    new $P4199, "Undef"
  vivify_2094:
    $P4198."pasttype"($P4199)
  if_4191_end:
.annotate 'line', 1497
    find_lex $P4214, "$/"
    find_lex $P4215, "$past"
    unless_null $P4215, vivify_2095
    new $P4215, "Undef"
  vivify_2095:
    $P4216 = $P4214."!make"($P4215)
.annotate 'line', 1486
    .return ($P4216)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<for>" :anon :subid("489_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_4218
    .param pmc param_4219
.annotate 'line', 1500
    .lex "self", param_4218
    .lex "$/", param_4219
.annotate 'line', 1501
    new $P4220, "Undef"
    .lex "$past", $P4220
.annotate 'line', 1503
    new $P4221, "Undef"
    .lex "$block", $P4221
.annotate 'line', 1501
    find_lex $P4222, "$/"
    unless_null $P4222, vivify_2096
    $P4222 = root_new ['parrot';'Hash']
  vivify_2096:
    set $P4223, $P4222["xblock"]
    unless_null $P4223, vivify_2097
    new $P4223, "Undef"
  vivify_2097:
    $P4224 = $P4223."ast"()
    store_lex "$past", $P4224
.annotate 'line', 1502
    find_lex $P4225, "$past"
    unless_null $P4225, vivify_2098
    new $P4225, "Undef"
  vivify_2098:
    $P4225."pasttype"("for")
.annotate 'line', 1503
    find_lex $P4226, "$past"
    unless_null $P4226, vivify_2099
    $P4226 = root_new ['parrot';'ResizablePMCArray']
  vivify_2099:
    set $P4227, $P4226[1]
    unless_null $P4227, vivify_2100
    new $P4227, "Undef"
  vivify_2100:
    store_lex "$block", $P4227
.annotate 'line', 1504
    find_lex $P4229, "$block"
    unless_null $P4229, vivify_2101
    new $P4229, "Undef"
  vivify_2101:
    $P4230 = $P4229."arity"()
    if $P4230, unless_4228_end
.annotate 'line', 1505
    find_lex $P4231, "$block"
    unless_null $P4231, vivify_2102
    $P4231 = root_new ['parrot';'ResizablePMCArray']
  vivify_2102:
    set $P4232, $P4231[0]
    unless_null $P4232, vivify_2103
    new $P4232, "Undef"
  vivify_2103:
    get_hll_global $P4233, "GLOBAL"
    nqp_get_package_through_who $P4234, $P4233, "PAST"
    get_who $P4235, $P4234
    set $P4236, $P4235["Var"]
    $P4237 = $P4236."new"("$_" :named("name"), "parameter" :named("scope"))
    $P4232."push"($P4237)
.annotate 'line', 1506
    find_lex $P4238, "$block"
    unless_null $P4238, vivify_2104
    new $P4238, "Undef"
  vivify_2104:
    $P4238."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 1507
    find_lex $P4239, "$block"
    unless_null $P4239, vivify_2105
    new $P4239, "Undef"
  vivify_2105:
    $P4239."arity"(1)
  unless_4228_end:
.annotate 'line', 1509
    find_lex $P4240, "$block"
    unless_null $P4240, vivify_2106
    new $P4240, "Undef"
  vivify_2106:
    $P4240."blocktype"("immediate")
.annotate 'line', 1510
    find_lex $P4241, "$/"
    find_lex $P4242, "$past"
    unless_null $P4242, vivify_2107
    new $P4242, "Undef"
  vivify_2107:
    $P4243 = $P4241."!make"($P4242)
.annotate 'line', 1500
    .return ($P4243)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CATCH>" :anon :subid("490_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_4245
    .param pmc param_4246
.annotate 'line', 1513
    .lex "self", param_4245
    .lex "$/", param_4246
.annotate 'line', 1514
    new $P4247, "Undef"
    .lex "$block", $P4247
    find_lex $P4248, "$/"
    unless_null $P4248, vivify_2108
    $P4248 = root_new ['parrot';'Hash']
  vivify_2108:
    set $P4249, $P4248["block"]
    unless_null $P4249, vivify_2109
    new $P4249, "Undef"
  vivify_2109:
    $P4250 = $P4249."ast"()
    store_lex "$block", $P4250
.annotate 'line', 1515
    find_lex $P4251, "$/"
    unless_null $P4251, vivify_2110
    new $P4251, "Undef"
  vivify_2110:
    find_lex $P4252, "$block"
    unless_null $P4252, vivify_2111
    new $P4252, "Undef"
  vivify_2111:
    "push_block_handler"($P4251, $P4252)
.annotate 'line', 1516
    find_lex $P4253, "$?PACKAGE"
    get_who $P4254, $P4253
    set $P4255, $P4254["@BLOCK"]
    unless_null $P4255, vivify_2112
    $P4255 = root_new ['parrot';'ResizablePMCArray']
  vivify_2112:
    set $P4256, $P4255[0]
    unless_null $P4256, vivify_2113
    new $P4256, "Undef"
  vivify_2113:
    $P4257 = $P4256."handlers"()
    set $P4258, $P4257[0]
    unless_null $P4258, vivify_2114
    new $P4258, "Undef"
  vivify_2114:
    $P4258."handle_types_except"("CONTROL")
.annotate 'line', 1517
    find_lex $P4259, "$/"
    get_hll_global $P4260, "GLOBAL"
    nqp_get_package_through_who $P4261, $P4260, "PAST"
    get_who $P4262, $P4261
    set $P4263, $P4262["Stmts"]
    find_lex $P4264, "$/"
    unless_null $P4264, vivify_2115
    new $P4264, "Undef"
  vivify_2115:
    $P4265 = $P4263."new"($P4264 :named("node"))
    $P4266 = $P4259."!make"($P4265)
.annotate 'line', 1513
    .return ($P4266)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CONTROL>" :anon :subid("491_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_4268
    .param pmc param_4269
.annotate 'line', 1520
    .lex "self", param_4268
    .lex "$/", param_4269
.annotate 'line', 1521
    new $P4270, "Undef"
    .lex "$block", $P4270
    find_lex $P4271, "$/"
    unless_null $P4271, vivify_2116
    $P4271 = root_new ['parrot';'Hash']
  vivify_2116:
    set $P4272, $P4271["block"]
    unless_null $P4272, vivify_2117
    new $P4272, "Undef"
  vivify_2117:
    $P4273 = $P4272."ast"()
    store_lex "$block", $P4273
.annotate 'line', 1522
    find_lex $P4274, "$/"
    unless_null $P4274, vivify_2118
    new $P4274, "Undef"
  vivify_2118:
    find_lex $P4275, "$block"
    unless_null $P4275, vivify_2119
    new $P4275, "Undef"
  vivify_2119:
    "push_block_handler"($P4274, $P4275)
.annotate 'line', 1523
    find_lex $P4276, "$?PACKAGE"
    get_who $P4277, $P4276
    set $P4278, $P4277["@BLOCK"]
    unless_null $P4278, vivify_2120
    $P4278 = root_new ['parrot';'ResizablePMCArray']
  vivify_2120:
    set $P4279, $P4278[0]
    unless_null $P4279, vivify_2121
    new $P4279, "Undef"
  vivify_2121:
    $P4280 = $P4279."handlers"()
    set $P4281, $P4280[0]
    unless_null $P4281, vivify_2122
    new $P4281, "Undef"
  vivify_2122:
    $P4281."handle_types"("CONTROL")
.annotate 'line', 1524
    find_lex $P4282, "$/"
    get_hll_global $P4283, "GLOBAL"
    nqp_get_package_through_who $P4284, $P4283, "PAST"
    get_who $P4285, $P4284
    set $P4286, $P4285["Stmts"]
    find_lex $P4287, "$/"
    unless_null $P4287, vivify_2123
    new $P4287, "Undef"
  vivify_2123:
    $P4288 = $P4286."new"($P4287 :named("node"))
    $P4289 = $P4282."!make"($P4288)
.annotate 'line', 1520
    .return ($P4289)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<INIT>" :anon :subid("492_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_4292
    .param pmc param_4293
.annotate 'line', 1564
    .lex "self", param_4292
    .lex "$/", param_4293
.annotate 'line', 1565
    find_lex $P4294, "$?PACKAGE"
    get_who $P4295, $P4294
    set $P4296, $P4295["@BLOCK"]
    unless_null $P4296, vivify_2124
    $P4296 = root_new ['parrot';'ResizablePMCArray']
  vivify_2124:
    set $P4297, $P4296[0]
    unless_null $P4297, vivify_2125
    new $P4297, "Undef"
  vivify_2125:
    find_lex $P4298, "$/"
    unless_null $P4298, vivify_2126
    $P4298 = root_new ['parrot';'Hash']
  vivify_2126:
    set $P4299, $P4298["blorst"]
    unless_null $P4299, vivify_2127
    new $P4299, "Undef"
  vivify_2127:
    $P4300 = $P4299."ast"()
    $P4297."push"($P4300)
.annotate 'line', 1566
    find_lex $P4301, "$/"
    get_hll_global $P4302, "GLOBAL"
    nqp_get_package_through_who $P4303, $P4302, "PAST"
    get_who $P4304, $P4303
    set $P4305, $P4304["Stmts"]
    $P4306 = $P4305."new"()
    $P4307 = $P4301."!make"($P4306)
.annotate 'line', 1564
    .return ($P4307)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<try>" :anon :subid("493_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_4309
    .param pmc param_4310
.annotate 'line', 1569
    .lex "self", param_4309
    .lex "$/", param_4310
.annotate 'line', 1570
    new $P4311, "Undef"
    .lex "$past", $P4311
    find_lex $P4312, "$/"
    unless_null $P4312, vivify_2128
    $P4312 = root_new ['parrot';'Hash']
  vivify_2128:
    set $P4313, $P4312["blorst"]
    unless_null $P4313, vivify_2129
    new $P4313, "Undef"
  vivify_2129:
    $P4314 = $P4313."ast"()
    store_lex "$past", $P4314
.annotate 'line', 1571
    get_hll_global $P4316, "GLOBAL"
    nqp_get_package_through_who $P4317, $P4316, "PAST"
    get_who $P4318, $P4317
    set $P4319, $P4318["Block"]
    find_lex $P4320, "$past"
    unless_null $P4320, vivify_2130
    new $P4320, "Undef"
  vivify_2130:
    $P4321 = $P4319."ACCEPTS"($P4320)
    if $P4321, unless_4315_end
.annotate 'line', 1572
    get_hll_global $P4322, "GLOBAL"
    nqp_get_package_through_who $P4323, $P4322, "PAST"
    get_who $P4324, $P4323
    set $P4325, $P4324["Block"]
    find_lex $P4326, "$past"
    unless_null $P4326, vivify_2131
    new $P4326, "Undef"
  vivify_2131:
    find_lex $P4327, "$/"
    unless_null $P4327, vivify_2132
    new $P4327, "Undef"
  vivify_2132:
    $P4328 = $P4325."new"($P4326, "immediate" :named("blocktype"), $P4327 :named("node"))
    store_lex "$past", $P4328
  unless_4315_end:
.annotate 'line', 1574
    find_lex $P4330, "$past"
    unless_null $P4330, vivify_2133
    new $P4330, "Undef"
  vivify_2133:
    $P4331 = $P4330."handlers"()
    if $P4331, unless_4329_end
.annotate 'line', 1575
    find_lex $P4332, "$past"
    unless_null $P4332, vivify_2134
    new $P4332, "Undef"
  vivify_2134:
    get_hll_global $P4333, "GLOBAL"
    nqp_get_package_through_who $P4334, $P4333, "PAST"
    get_who $P4335, $P4334
    set $P4336, $P4335["Control"]
.annotate 'line', 1577
    get_hll_global $P4337, "GLOBAL"
    nqp_get_package_through_who $P4338, $P4337, "PAST"
    get_who $P4339, $P4338
    set $P4340, $P4339["Stmts"]
.annotate 'line', 1578
    get_hll_global $P4341, "GLOBAL"
    nqp_get_package_through_who $P4342, $P4341, "PAST"
    get_who $P4343, $P4342
    set $P4344, $P4343["Op"]
.annotate 'line', 1579
    get_hll_global $P4345, "GLOBAL"
    nqp_get_package_through_who $P4346, $P4345, "PAST"
    get_who $P4347, $P4346
    set $P4348, $P4347["Var"]
.annotate 'line', 1580
    get_hll_global $P4349, "GLOBAL"
    nqp_get_package_through_who $P4350, $P4349, "PAST"
    get_who $P4351, $P4350
    set $P4352, $P4351["Var"]
    $P4353 = $P4352."new"("register" :named("scope"), "exception" :named("name"))
    $P4354 = $P4348."new"($P4353, "handled", "keyed" :named("scope"))
.annotate 'line', 1579
    $P4355 = $P4344."new"($P4354, 1, "bind_6model" :named("pasttype"))
.annotate 'line', 1578
    $P4356 = $P4340."new"($P4355)
.annotate 'line', 1577
    $P4357 = $P4336."new"($P4356, "CONTROL" :named("handle_types_except"))
.annotate 'line', 1575
    new $P4358, "ResizablePMCArray"
    push $P4358, $P4357
    $P4332."handlers"($P4358)
  unless_4329_end:
.annotate 'line', 1589
    find_lex $P4359, "$/"
    find_lex $P4360, "$past"
    unless_null $P4360, vivify_2135
    new $P4360, "Undef"
  vivify_2135:
    $P4361 = $P4359."!make"($P4360)
.annotate 'line', 1569
    .return ($P4361)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blorst" :anon :subid("494_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_4363
    .param pmc param_4364
.annotate 'line', 1592
    .lex "self", param_4363
    .lex "$/", param_4364
.annotate 'line', 1593
    find_lex $P4365, "$/"
.annotate 'line', 1594
    find_lex $P4368, "$/"
    unless_null $P4368, vivify_2136
    $P4368 = root_new ['parrot';'Hash']
  vivify_2136:
    set $P4369, $P4368["block"]
    unless_null $P4369, vivify_2137
    new $P4369, "Undef"
  vivify_2137:
    if $P4369, if_4367
.annotate 'line', 1595
    find_lex $P4374, "$/"
    unless_null $P4374, vivify_2138
    $P4374 = root_new ['parrot';'Hash']
  vivify_2138:
    set $P4375, $P4374["statement"]
    unless_null $P4375, vivify_2139
    new $P4375, "Undef"
  vivify_2139:
    $P4376 = $P4375."ast"()
    set $P4366, $P4376
.annotate 'line', 1594
    goto if_4367_end
  if_4367:
    find_lex $P4370, "$/"
    unless_null $P4370, vivify_2140
    $P4370 = root_new ['parrot';'Hash']
  vivify_2140:
    set $P4371, $P4370["block"]
    unless_null $P4371, vivify_2141
    new $P4371, "Undef"
  vivify_2141:
    $P4372 = $P4371."ast"()
    $P4373 = "block_immediate"($P4372)
    set $P4366, $P4373
  if_4367_end:
    $P4377 = $P4365."!make"($P4366)
.annotate 'line', 1592
    .return ($P4377)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<if>" :anon :subid("495_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_4379
    .param pmc param_4380
.annotate 'line', 1600
    .lex "self", param_4379
    .lex "$/", param_4380
    find_lex $P4381, "$/"
    find_lex $P4382, "$/"
    unless_null $P4382, vivify_2142
    $P4382 = root_new ['parrot';'Hash']
  vivify_2142:
    set $P4383, $P4382["cond"]
    unless_null $P4383, vivify_2143
    new $P4383, "Undef"
  vivify_2143:
    $P4384 = $P4383."ast"()
    $P4385 = $P4381."!make"($P4384)
    .return ($P4385)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<unless>" :anon :subid("496_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_4387
    .param pmc param_4388
.annotate 'line', 1601
    .lex "self", param_4387
    .lex "$/", param_4388
    find_lex $P4389, "$/"
    find_lex $P4390, "$/"
    unless_null $P4390, vivify_2144
    $P4390 = root_new ['parrot';'Hash']
  vivify_2144:
    set $P4391, $P4390["cond"]
    unless_null $P4391, vivify_2145
    new $P4391, "Undef"
  vivify_2145:
    $P4392 = $P4391."ast"()
    $P4393 = $P4389."!make"($P4392)
    .return ($P4393)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<while>" :anon :subid("497_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_4395
    .param pmc param_4396
.annotate 'line', 1603
    .lex "self", param_4395
    .lex "$/", param_4396
    find_lex $P4397, "$/"
    find_lex $P4398, "$/"
    unless_null $P4398, vivify_2146
    $P4398 = root_new ['parrot';'Hash']
  vivify_2146:
    set $P4399, $P4398["cond"]
    unless_null $P4399, vivify_2147
    new $P4399, "Undef"
  vivify_2147:
    $P4400 = $P4399."ast"()
    $P4401 = $P4397."!make"($P4400)
    .return ($P4401)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<until>" :anon :subid("498_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_4403
    .param pmc param_4404
.annotate 'line', 1604
    .lex "self", param_4403
    .lex "$/", param_4404
    find_lex $P4405, "$/"
    find_lex $P4406, "$/"
    unless_null $P4406, vivify_2148
    $P4406 = root_new ['parrot';'Hash']
  vivify_2148:
    set $P4407, $P4406["cond"]
    unless_null $P4407, vivify_2149
    new $P4407, "Undef"
  vivify_2149:
    $P4408 = $P4407."ast"()
    $P4409 = $P4405."!make"($P4408)
    .return ($P4409)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<fatarrow>" :anon :subid("499_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_4411
    .param pmc param_4412
.annotate 'line', 1608
    .lex "self", param_4411
    .lex "$/", param_4412
    find_lex $P4413, "$/"
    find_lex $P4414, "$/"
    unless_null $P4414, vivify_2150
    $P4414 = root_new ['parrot';'Hash']
  vivify_2150:
    set $P4415, $P4414["fatarrow"]
    unless_null $P4415, vivify_2151
    new $P4415, "Undef"
  vivify_2151:
    $P4416 = $P4415."ast"()
    $P4417 = $P4413."!make"($P4416)
    .return ($P4417)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<colonpair>" :anon :subid("500_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_4419
    .param pmc param_4420
.annotate 'line', 1609
    .lex "self", param_4419
    .lex "$/", param_4420
    find_lex $P4421, "$/"
    find_lex $P4422, "$/"
    unless_null $P4422, vivify_2152
    $P4422 = root_new ['parrot';'Hash']
  vivify_2152:
    set $P4423, $P4422["colonpair"]
    unless_null $P4423, vivify_2153
    new $P4423, "Undef"
  vivify_2153:
    $P4424 = $P4423."ast"()
    $P4425 = $P4421."!make"($P4424)
    .return ($P4425)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<variable>" :anon :subid("501_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_4427
    .param pmc param_4428
.annotate 'line', 1610
    .lex "self", param_4427
    .lex "$/", param_4428
    find_lex $P4429, "$/"
    find_lex $P4430, "$/"
    unless_null $P4430, vivify_2154
    $P4430 = root_new ['parrot';'Hash']
  vivify_2154:
    set $P4431, $P4430["variable"]
    unless_null $P4431, vivify_2155
    new $P4431, "Undef"
  vivify_2155:
    $P4432 = $P4431."ast"()
    $P4433 = $P4429."!make"($P4432)
    .return ($P4433)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<package_declarator>" :anon :subid("502_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_4435
    .param pmc param_4436
.annotate 'line', 1611
    .lex "self", param_4435
    .lex "$/", param_4436
    find_lex $P4437, "$/"
    find_lex $P4438, "$/"
    unless_null $P4438, vivify_2156
    $P4438 = root_new ['parrot';'Hash']
  vivify_2156:
    set $P4439, $P4438["package_declarator"]
    unless_null $P4439, vivify_2157
    new $P4439, "Undef"
  vivify_2157:
    $P4440 = $P4439."ast"()
    $P4441 = $P4437."!make"($P4440)
    .return ($P4441)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<scope_declarator>" :anon :subid("503_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_4443
    .param pmc param_4444
.annotate 'line', 1612
    .lex "self", param_4443
    .lex "$/", param_4444
    find_lex $P4445, "$/"
    find_lex $P4446, "$/"
    unless_null $P4446, vivify_2158
    $P4446 = root_new ['parrot';'Hash']
  vivify_2158:
    set $P4447, $P4446["scope_declarator"]
    unless_null $P4447, vivify_2159
    new $P4447, "Undef"
  vivify_2159:
    $P4448 = $P4447."ast"()
    $P4449 = $P4445."!make"($P4448)
    .return ($P4449)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<routine_declarator>" :anon :subid("504_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_4451
    .param pmc param_4452
.annotate 'line', 1613
    .lex "self", param_4451
    .lex "$/", param_4452
    find_lex $P4453, "$/"
    find_lex $P4454, "$/"
    unless_null $P4454, vivify_2160
    $P4454 = root_new ['parrot';'Hash']
  vivify_2160:
    set $P4455, $P4454["routine_declarator"]
    unless_null $P4455, vivify_2161
    new $P4455, "Undef"
  vivify_2161:
    $P4456 = $P4455."ast"()
    $P4457 = $P4453."!make"($P4456)
    .return ($P4457)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<regex_declarator>" :anon :subid("505_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_4459
    .param pmc param_4460
.annotate 'line', 1614
    .lex "self", param_4459
    .lex "$/", param_4460
    find_lex $P4461, "$/"
    find_lex $P4462, "$/"
    unless_null $P4462, vivify_2162
    $P4462 = root_new ['parrot';'Hash']
  vivify_2162:
    set $P4463, $P4462["regex_declarator"]
    unless_null $P4463, vivify_2163
    new $P4463, "Undef"
  vivify_2163:
    $P4464 = $P4463."ast"()
    $P4465 = $P4461."!make"($P4464)
    .return ($P4465)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<statement_prefix>" :anon :subid("506_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_4467
    .param pmc param_4468
.annotate 'line', 1615
    .lex "self", param_4467
    .lex "$/", param_4468
    find_lex $P4469, "$/"
    find_lex $P4470, "$/"
    unless_null $P4470, vivify_2164
    $P4470 = root_new ['parrot';'Hash']
  vivify_2164:
    set $P4471, $P4470["statement_prefix"]
    unless_null $P4471, vivify_2165
    new $P4471, "Undef"
  vivify_2165:
    $P4472 = $P4471."ast"()
    $P4473 = $P4469."!make"($P4472)
    .return ($P4473)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<lambda>" :anon :subid("507_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_4475
    .param pmc param_4476
.annotate 'line', 1616
    .lex "self", param_4475
    .lex "$/", param_4476
    find_lex $P4477, "$/"
    find_lex $P4478, "$/"
    unless_null $P4478, vivify_2166
    $P4478 = root_new ['parrot';'Hash']
  vivify_2166:
    set $P4479, $P4478["pblock"]
    unless_null $P4479, vivify_2167
    new $P4479, "Undef"
  vivify_2167:
    $P4480 = $P4479."ast"()
    $P4481 = $P4477."!make"($P4480)
    .return ($P4481)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "fatarrow" :anon :subid("508_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_4483
    .param pmc param_4484
.annotate 'line', 1618
    .lex "self", param_4483
    .lex "$/", param_4484
.annotate 'line', 1619
    new $P4485, "Undef"
    .lex "$past", $P4485
    find_lex $P4486, "$/"
    unless_null $P4486, vivify_2168
    $P4486 = root_new ['parrot';'Hash']
  vivify_2168:
    set $P4487, $P4486["val"]
    unless_null $P4487, vivify_2169
    new $P4487, "Undef"
  vivify_2169:
    $P4488 = $P4487."ast"()
    store_lex "$past", $P4488
.annotate 'line', 1620
    find_lex $P4489, "$past"
    unless_null $P4489, vivify_2170
    new $P4489, "Undef"
  vivify_2170:
    find_lex $P4490, "$/"
    unless_null $P4490, vivify_2171
    $P4490 = root_new ['parrot';'Hash']
  vivify_2171:
    set $P4491, $P4490["key"]
    unless_null $P4491, vivify_2172
    new $P4491, "Undef"
  vivify_2172:
    $P4492 = $P4491."Str"()
    $P4489."named"($P4492)
.annotate 'line', 1621
    find_lex $P4493, "$/"
    find_lex $P4494, "$past"
    unless_null $P4494, vivify_2173
    new $P4494, "Undef"
  vivify_2173:
    $P4495 = $P4493."!make"($P4494)
.annotate 'line', 1618
    .return ($P4495)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair" :anon :subid("509_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_4497
    .param pmc param_4498
.annotate 'line', 1624
    .lex "self", param_4497
    .lex "$/", param_4498
.annotate 'line', 1625
    new $P4499, "Undef"
    .lex "$past", $P4499
.annotate 'line', 1626
    find_lex $P4502, "$/"
    unless_null $P4502, vivify_2174
    $P4502 = root_new ['parrot';'Hash']
  vivify_2174:
    set $P4503, $P4502["circumfix"]
    unless_null $P4503, vivify_2175
    new $P4503, "Undef"
  vivify_2175:
    if $P4503, if_4501
.annotate 'line', 1627
    get_hll_global $P4508, "GLOBAL"
    nqp_get_package_through_who $P4509, $P4508, "PAST"
    get_who $P4510, $P4509
    set $P4511, $P4510["Val"]
    find_lex $P4512, "$/"
    unless_null $P4512, vivify_2176
    $P4512 = root_new ['parrot';'Hash']
  vivify_2176:
    set $P4513, $P4512["not"]
    unless_null $P4513, vivify_2177
    new $P4513, "Undef"
  vivify_2177:
    isfalse $I4514, $P4513
    $P4515 = $P4511."new"($I4514 :named("value"))
    set $P4500, $P4515
.annotate 'line', 1626
    goto if_4501_end
  if_4501:
    find_lex $P4504, "$/"
    unless_null $P4504, vivify_2178
    $P4504 = root_new ['parrot';'Hash']
  vivify_2178:
    set $P4505, $P4504["circumfix"]
    unless_null $P4505, vivify_2179
    $P4505 = root_new ['parrot';'ResizablePMCArray']
  vivify_2179:
    set $P4506, $P4505[0]
    unless_null $P4506, vivify_2180
    new $P4506, "Undef"
  vivify_2180:
    $P4507 = $P4506."ast"()
    set $P4500, $P4507
  if_4501_end:
    store_lex "$past", $P4500
.annotate 'line', 1628
    find_lex $P4516, "$past"
    unless_null $P4516, vivify_2181
    new $P4516, "Undef"
  vivify_2181:
    find_lex $P4517, "$/"
    unless_null $P4517, vivify_2182
    $P4517 = root_new ['parrot';'Hash']
  vivify_2182:
    set $P4518, $P4517["identifier"]
    unless_null $P4518, vivify_2183
    new $P4518, "Undef"
  vivify_2183:
    set $S4519, $P4518
    $P4516."named"($S4519)
.annotate 'line', 1629
    find_lex $P4520, "$/"
    find_lex $P4521, "$past"
    unless_null $P4521, vivify_2184
    new $P4521, "Undef"
  vivify_2184:
    $P4522 = $P4520."!make"($P4521)
.annotate 'line', 1624
    .return ($P4522)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "variable" :anon :subid("510_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_4524
    .param pmc param_4525
.annotate 'line', 1632
    .const 'Sub' $P4541 = "511_1307873304.82979" 
    capture_lex $P4541
    .lex "self", param_4524
    .lex "$/", param_4525
.annotate 'line', 1633
    new $P4526, "Undef"
    .lex "$past", $P4526
.annotate 'line', 1632
    find_lex $P4527, "$past"
    unless_null $P4527, vivify_2185
    new $P4527, "Undef"
  vivify_2185:
.annotate 'line', 1634
    find_lex $P4529, "$/"
    unless_null $P4529, vivify_2186
    $P4529 = root_new ['parrot';'Hash']
  vivify_2186:
    set $P4530, $P4529["postcircumfix"]
    unless_null $P4530, vivify_2187
    new $P4530, "Undef"
  vivify_2187:
    if $P4530, if_4528
.annotate 'line', 1638
    .const 'Sub' $P4541 = "511_1307873304.82979" 
    capture_lex $P4541
    $P4541()
    goto if_4528_end
  if_4528:
.annotate 'line', 1635
    find_lex $P4531, "$/"
    unless_null $P4531, vivify_2244
    $P4531 = root_new ['parrot';'Hash']
  vivify_2244:
    set $P4532, $P4531["postcircumfix"]
    unless_null $P4532, vivify_2245
    new $P4532, "Undef"
  vivify_2245:
    $P4533 = $P4532."ast"()
    store_lex "$past", $P4533
.annotate 'line', 1636
    find_lex $P4534, "$past"
    unless_null $P4534, vivify_2246
    new $P4534, "Undef"
  vivify_2246:
    get_hll_global $P4535, "GLOBAL"
    nqp_get_package_through_who $P4536, $P4535, "PAST"
    get_who $P4537, $P4536
    set $P4538, $P4537["Var"]
    $P4539 = $P4538."new"("$/" :named("name"))
    $P4534."unshift"($P4539)
  if_4528_end:
.annotate 'line', 1697
    find_lex $P4722, "$/"
    find_lex $P4723, "$past"
    unless_null $P4723, vivify_2247
    new $P4723, "Undef"
  vivify_2247:
    $P4724 = $P4722."!make"($P4723)
.annotate 'line', 1632
    .return ($P4724)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4540"  :anon :subid("511_1307873304.82979") :outer("510_1307873304.82979")
.annotate 'line', 1638
    .const 'Sub' $P4617 = "513_1307873304.82979" 
    capture_lex $P4617
    .const 'Sub' $P4576 = "512_1307873304.82979" 
    capture_lex $P4576
.annotate 'line', 1639
    $P4542 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P4542
    get_hll_global $P4543, "GLOBAL"
    nqp_get_package_through_who $P4544, $P4543, "NQP"
    get_who $P4545, $P4544
    set $P4546, $P4545["Compiler"]
    find_lex $P4547, "$/"
    unless_null $P4547, vivify_2188
    new $P4547, "Undef"
  vivify_2188:
    set $S4548, $P4547
    $P4549 = $P4546."parse_name"($S4548)
    store_lex "@name", $P4549
.annotate 'line', 1640
    find_lex $P4552, "@name"
    unless_null $P4552, vivify_2189
    $P4552 = root_new ['parrot';'ResizablePMCArray']
  vivify_2189:
    set $N4553, $P4552
    isgt $I4554, $N4553, 1.0
    if $I4554, if_4551
.annotate 'line', 1647
    find_lex $P4570, "$/"
    unless_null $P4570, vivify_2190
    $P4570 = root_new ['parrot';'Hash']
  vivify_2190:
    set $P4571, $P4570["twigil"]
    unless_null $P4571, vivify_2191
    $P4571 = root_new ['parrot';'ResizablePMCArray']
  vivify_2191:
    set $P4572, $P4571[0]
    unless_null $P4572, vivify_2192
    new $P4572, "Undef"
  vivify_2192:
    set $S4573, $P4572
    iseq $I4574, $S4573, "*"
    if $I4574, if_4569
.annotate 'line', 1658
    find_lex $P4611, "$/"
    unless_null $P4611, vivify_2193
    $P4611 = root_new ['parrot';'Hash']
  vivify_2193:
    set $P4612, $P4611["twigil"]
    unless_null $P4612, vivify_2194
    $P4612 = root_new ['parrot';'ResizablePMCArray']
  vivify_2194:
    set $P4613, $P4612[0]
    unless_null $P4613, vivify_2195
    new $P4613, "Undef"
  vivify_2195:
    set $S4614, $P4613
    iseq $I4615, $S4614, "!"
    if $I4615, if_4610
.annotate 'line', 1687
    find_lex $P4699, "@name"
    unless_null $P4699, vivify_2196
    $P4699 = root_new ['parrot';'ResizablePMCArray']
  vivify_2196:
    set $P4700, $P4699[0]
    unless_null $P4700, vivify_2197
    new $P4700, "Undef"
  vivify_2197:
    set $S4701, $P4700
    $P4702 = "is_package"($S4701)
    if $P4702, if_4698
.annotate 'line', 1692
    get_hll_global $P4711, "GLOBAL"
    nqp_get_package_through_who $P4712, $P4711, "PAST"
    get_who $P4713, $P4712
    set $P4714, $P4713["Var"]
.annotate 'line', 1693
    find_lex $P4715, "@name"
    unless_null $P4715, vivify_2198
    $P4715 = root_new ['parrot';'ResizablePMCArray']
  vivify_2198:
    $P4716 = $P4715."pop"()
    set $S4717, $P4716
    find_lex $P4718, "$/"
    unless_null $P4718, vivify_2199
    $P4718 = root_new ['parrot';'Hash']
  vivify_2199:
    set $P4719, $P4718["sigil"]
    unless_null $P4719, vivify_2200
    new $P4719, "Undef"
  vivify_2200:
    $P4720 = "vivitype"($P4719)
    $P4721 = $P4714."new"($S4717 :named("name"), $P4720 :named("viviself"))
.annotate 'line', 1692
    store_lex "$past", $P4721
.annotate 'line', 1691
    set $P4697, $P4721
.annotate 'line', 1687
    goto if_4698_end
  if_4698:
.annotate 'line', 1688
    find_lex $P4703, "@name"
    unless_null $P4703, vivify_2201
    $P4703 = root_new ['parrot';'ResizablePMCArray']
  vivify_2201:
    find_lex $P4704, "$/"
    unless_null $P4704, vivify_2202
    new $P4704, "Undef"
  vivify_2202:
    $P4705 = "lexical_package_lookup"($P4703, $P4704)
    store_lex "$past", $P4705
.annotate 'line', 1689
    find_lex $P4706, "$past"
    unless_null $P4706, vivify_2203
    new $P4706, "Undef"
  vivify_2203:
    find_lex $P4707, "$/"
    unless_null $P4707, vivify_2204
    $P4707 = root_new ['parrot';'Hash']
  vivify_2204:
    set $P4708, $P4707["sigil"]
    unless_null $P4708, vivify_2205
    new $P4708, "Undef"
  vivify_2205:
    $P4709 = "vivitype"($P4708)
    $P4710 = $P4706."viviself"($P4709)
.annotate 'line', 1687
    set $P4697, $P4710
  if_4698_end:
    set $P4609, $P4697
.annotate 'line', 1658
    goto if_4610_end
  if_4610:
    .const 'Sub' $P4617 = "513_1307873304.82979" 
    capture_lex $P4617
    $P4696 = $P4617()
    set $P4609, $P4696
  if_4610_end:
    set $P4568, $P4609
.annotate 'line', 1647
    goto if_4569_end
  if_4569:
    .const 'Sub' $P4576 = "512_1307873304.82979" 
    capture_lex $P4576
    $P4608 = $P4576()
    set $P4568, $P4608
  if_4569_end:
    set $P4550, $P4568
.annotate 'line', 1640
    goto if_4551_end
  if_4551:
.annotate 'line', 1641
    find_lex $P4556, "$/"
    unless_null $P4556, vivify_2236
    $P4556 = root_new ['parrot';'Hash']
  vivify_2236:
    set $P4557, $P4556["twigil"]
    unless_null $P4557, vivify_2237
    new $P4557, "Undef"
  vivify_2237:
    unless $P4557, if_4555_end
.annotate 'line', 1642
    find_lex $P4558, "$/"
    unless_null $P4558, vivify_2238
    new $P4558, "Undef"
  vivify_2238:
    $P4559 = $P4558."CURSOR"()
    $P4559."panic"("Twigil not allowed on multi-part name")
  if_4555_end:
.annotate 'line', 1644
    find_lex $P4560, "@name"
    unless_null $P4560, vivify_2239
    $P4560 = root_new ['parrot';'ResizablePMCArray']
  vivify_2239:
    find_lex $P4561, "$/"
    unless_null $P4561, vivify_2240
    new $P4561, "Undef"
  vivify_2240:
    $P4562 = "lexical_package_lookup"($P4560, $P4561)
    store_lex "$past", $P4562
.annotate 'line', 1645
    find_lex $P4563, "$past"
    unless_null $P4563, vivify_2241
    new $P4563, "Undef"
  vivify_2241:
    find_lex $P4564, "$/"
    unless_null $P4564, vivify_2242
    $P4564 = root_new ['parrot';'Hash']
  vivify_2242:
    set $P4565, $P4564["sigil"]
    unless_null $P4565, vivify_2243
    new $P4565, "Undef"
  vivify_2243:
    $P4566 = "vivitype"($P4565)
    $P4567 = $P4563."viviself"($P4566)
.annotate 'line', 1640
    set $P4550, $P4567
  if_4551_end:
.annotate 'line', 1638
    .return ($P4550)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4616"  :anon :subid("513_1307873304.82979") :outer("511_1307873304.82979")
.annotate 'line', 1658
    .const 'Sub' $P4648 = "514_1307873304.82979" 
    capture_lex $P4648
.annotate 'line', 1660
    new $P4618, "Undef"
    .lex "$name", $P4618
    find_lex $P4619, "@name"
    unless_null $P4619, vivify_2206
    $P4619 = root_new ['parrot';'ResizablePMCArray']
  vivify_2206:
    $P4620 = $P4619."pop"()
    set $S4621, $P4620
    new $P4622, 'String'
    set $P4622, $S4621
    store_lex "$name", $P4622
.annotate 'line', 1661
    get_hll_global $P4623, "GLOBAL"
    nqp_get_package_through_who $P4624, $P4623, "PAST"
    get_who $P4625, $P4624
    set $P4626, $P4625["Var"]
    find_lex $P4627, "$name"
    unless_null $P4627, vivify_2207
    new $P4627, "Undef"
  vivify_2207:
.annotate 'line', 1663
    find_lex $P4628, "$/"
    unless_null $P4628, vivify_2208
    $P4628 = root_new ['parrot';'Hash']
  vivify_2208:
    set $P4629, $P4628["sigil"]
    unless_null $P4629, vivify_2209
    new $P4629, "Undef"
  vivify_2209:
    $P4630 = "vivitype"($P4629)
.annotate 'line', 1664
    get_hll_global $P4631, "GLOBAL"
    nqp_get_package_through_who $P4632, $P4631, "PAST"
    get_who $P4633, $P4632
    set $P4634, $P4633["Var"]
    $P4635 = $P4634."new"("self" :named("name"))
.annotate 'line', 1665
    get_hll_global $P4636, "GLOBAL"
    nqp_get_package_through_who $P4637, $P4636, "PAST"
    get_who $P4638, $P4637
    set $P4639, $P4638["Var"]
    $P4640 = $P4639."new"("$?CLASS" :named("name"))
    $P4641 = $P4626."new"($P4635, $P4640, $P4627 :named("name"), "attribute_6model" :named("scope"), $P4630 :named("viviself"))
.annotate 'line', 1661
    store_lex "$past", $P4641
.annotate 'line', 1669
    find_dynamic_lex $P4646, "$*IN_DECL"
    unless_null $P4646, vivify_2210
    get_hll_global $P4644, "GLOBAL"
    get_who $P4645, $P4644
    set $P4646, $P4645["$IN_DECL"]
    unless_null $P4646, vivify_2211
    die "Contextual $*IN_DECL not found"
  vivify_2211:
  vivify_2210:
    unless $P4646, unless_4643
    set $P4642, $P4646
    goto unless_4643_end
  unless_4643:
    .const 'Sub' $P4648 = "514_1307873304.82979" 
    capture_lex $P4648
    $P4695 = $P4648()
    set $P4642, $P4695
  unless_4643_end:
.annotate 'line', 1658
    .return ($P4642)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block4647"  :anon :subid("514_1307873304.82979") :outer("513_1307873304.82979")
.annotate 'line', 1669
    .const 'Sub' $P4663 = "515_1307873304.82979" 
    capture_lex $P4663
.annotate 'line', 1670
    new $P4649, "Undef"
    .lex "$attr", $P4649
.annotate 'line', 1669
    find_lex $P4650, "$attr"
    unless_null $P4650, vivify_2212
    new $P4650, "Undef"
  vivify_2212:
.annotate 'line', 1671
    find_dynamic_lex $P4654, "$*PACKAGE"
    unless_null $P4654, vivify_2213
    get_hll_global $P4652, "GLOBAL"
    get_who $P4653, $P4652
    set $P4654, $P4653["$PACKAGE"]
    unless_null $P4654, vivify_2214
    die "Contextual $*PACKAGE not found"
  vivify_2214:
  vivify_2213:
    get_how $P4655, $P4654
    find_dynamic_lex $P4658, "$*PACKAGE"
    unless_null $P4658, vivify_2215
    get_hll_global $P4656, "GLOBAL"
    get_who $P4657, $P4656
    set $P4658, $P4657["$PACKAGE"]
    unless_null $P4658, vivify_2216
    die "Contextual $*PACKAGE not found"
  vivify_2216:
  vivify_2215:
    $P4659 = $P4655."attributes"($P4658, 1 :named("local"))
    defined $I4660, $P4659
    unless $I4660, for_undef_2217
    iter $P4651, $P4659
    new $P4674, 'ExceptionHandler'
    set_label $P4674, loop4673_handler
    $P4674."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4674
  loop4673_test:
    unless $P4651, loop4673_done
    shift $P4661, $P4651
  loop4673_redo:
    .const 'Sub' $P4663 = "515_1307873304.82979" 
    capture_lex $P4663
    $P4663($P4661)
  loop4673_next:
    goto loop4673_test
  loop4673_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4675, exception, 'type'
    eq $P4675, .CONTROL_LOOP_NEXT, loop4673_next
    eq $P4675, .CONTROL_LOOP_REDO, loop4673_redo
  loop4673_done:
    pop_eh 
  for_undef_2217:
.annotate 'line', 1677
    find_lex $P4678, "$attr"
    unless_null $P4678, vivify_2221
    new $P4678, "Undef"
  vivify_2221:
    defined $I4679, $P4678
    if $I4679, if_4677
.annotate 'line', 1683
    find_lex $P4688, "$/"
    unless_null $P4688, vivify_2222
    new $P4688, "Undef"
  vivify_2222:
    $P4689 = $P4688."CURSOR"()
    new $P4690, 'String'
    set $P4690, "Attribute '"
    find_lex $P4691, "$name"
    unless_null $P4691, vivify_2223
    new $P4691, "Undef"
  vivify_2223:
    concat $P4692, $P4690, $P4691
    concat $P4693, $P4692, "' not declared"
    $P4694 = $P4689."panic"($P4693)
.annotate 'line', 1682
    set $P4676, $P4694
.annotate 'line', 1677
    goto if_4677_end
  if_4677:
.annotate 'line', 1678
    find_lex $P4682, "$attr"
    unless_null $P4682, vivify_2224
    new $P4682, "Undef"
  vivify_2224:
    can $I4683, $P4682, "type"
    if $I4683, if_4681
    new $P4680, 'Integer'
    set $P4680, $I4683
    goto if_4681_end
  if_4681:
.annotate 'line', 1679
    find_lex $P4684, "$past"
    unless_null $P4684, vivify_2225
    new $P4684, "Undef"
  vivify_2225:
    find_lex $P4685, "$attr"
    unless_null $P4685, vivify_2226
    new $P4685, "Undef"
  vivify_2226:
    $P4686 = $P4685."type"()
    $P4687 = $P4684."type"($P4686)
.annotate 'line', 1678
    set $P4680, $P4687
  if_4681_end:
.annotate 'line', 1677
    set $P4676, $P4680
  if_4677_end:
.annotate 'line', 1669
    .return ($P4676)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4662"  :anon :subid("515_1307873304.82979") :outer("514_1307873304.82979")
    .param pmc param_4664
.annotate 'line', 1671
    .lex "$_", param_4664
.annotate 'line', 1672
    find_lex $P4667, "$_"
    unless_null $P4667, vivify_2218
    new $P4667, "Undef"
  vivify_2218:
    $S4668 = $P4667."name"()
    find_lex $P4669, "$name"
    unless_null $P4669, vivify_2219
    new $P4669, "Undef"
  vivify_2219:
    set $S4670, $P4669
    iseq $I4671, $S4668, $S4670
    if $I4671, if_4666
    new $P4665, 'Integer'
    set $P4665, $I4671
    goto if_4666_end
  if_4666:
.annotate 'line', 1673
    find_lex $P4672, "$_"
    unless_null $P4672, vivify_2220
    new $P4672, "Undef"
  vivify_2220:
    store_lex "$attr", $P4672
.annotate 'line', 1674
    die 0, .CONTROL_LOOP_LAST
  if_4666_end:
.annotate 'line', 1671
    .return ($P4665)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4575"  :anon :subid("512_1307873304.82979") :outer("511_1307873304.82979")
.annotate 'line', 1648
    new $P4577, "Undef"
    .lex "$global_fallback", $P4577
    find_lex $P4578, "$/"
    unless_null $P4578, vivify_2227
    $P4578 = root_new ['parrot';'Hash']
  vivify_2227:
    set $P4579, $P4578["sigil"]
    unless_null $P4579, vivify_2228
    new $P4579, "Undef"
  vivify_2228:
    set $S4580, $P4579
    new $P4581, 'String'
    set $P4581, $S4580
    find_lex $P4582, "$/"
    unless_null $P4582, vivify_2229
    $P4582 = root_new ['parrot';'Hash']
  vivify_2229:
    set $P4583, $P4582["desigilname"]
    unless_null $P4583, vivify_2230
    new $P4583, "Undef"
  vivify_2230:
    concat $P4584, $P4581, $P4583
    new $P4585, "ResizablePMCArray"
    push $P4585, "GLOBAL"
    push $P4585, $P4584
    find_lex $P4586, "$/"
    unless_null $P4586, vivify_2231
    new $P4586, "Undef"
  vivify_2231:
    $P4587 = "lexical_package_lookup"($P4585, $P4586)
    store_lex "$global_fallback", $P4587
.annotate 'line', 1649
    find_lex $P4588, "$global_fallback"
    unless_null $P4588, vivify_2232
    new $P4588, "Undef"
  vivify_2232:
    get_hll_global $P4589, "GLOBAL"
    nqp_get_package_through_who $P4590, $P4589, "PAST"
    get_who $P4591, $P4590
    set $P4592, $P4591["Op"]
.annotate 'line', 1650
    new $P4593, "String"
    assign $P4593, "Contextual "
    find_lex $P4594, "$/"
    unless_null $P4594, vivify_2233
    new $P4594, "Undef"
  vivify_2233:
    set $S4595, $P4594
    concat $P4596, $P4593, $S4595
    concat $P4597, $P4596, " not found"
    $P4598 = $P4592."new"($P4597, "die" :named("pirop"))
.annotate 'line', 1649
    $P4588."viviself"($P4598)
.annotate 'line', 1653
    get_hll_global $P4599, "GLOBAL"
    nqp_get_package_through_who $P4600, $P4599, "PAST"
    get_who $P4601, $P4600
    set $P4602, $P4601["Var"]
.annotate 'line', 1654
    find_lex $P4603, "@name"
    unless_null $P4603, vivify_2234
    $P4603 = root_new ['parrot';'ResizablePMCArray']
  vivify_2234:
    $P4604 = $P4603."pop"()
    set $S4605, $P4604
    find_lex $P4606, "$global_fallback"
    unless_null $P4606, vivify_2235
    new $P4606, "Undef"
  vivify_2235:
    $P4607 = $P4602."new"($S4605 :named("name"), "contextual" :named("scope"), $P4606 :named("viviself"))
.annotate 'line', 1653
    store_lex "$past", $P4607
.annotate 'line', 1647
    .return ($P4607)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<module>" :anon :subid("516_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_4726
    .param pmc param_4727
.annotate 'line', 1700
    .lex "self", param_4726
    .lex "$/", param_4727
    find_lex $P4728, "$/"
    find_lex $P4729, "$/"
    unless_null $P4729, vivify_2248
    $P4729 = root_new ['parrot';'Hash']
  vivify_2248:
    set $P4730, $P4729["package_def"]
    unless_null $P4730, vivify_2249
    new $P4730, "Undef"
  vivify_2249:
    $P4731 = $P4730."ast"()
    $P4732 = $P4728."!make"($P4731)
    .return ($P4732)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<knowhow>" :anon :subid("517_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_4734
    .param pmc param_4735
.annotate 'line', 1701
    .lex "self", param_4734
    .lex "$/", param_4735
    find_lex $P4736, "$/"
    find_lex $P4737, "$/"
    unless_null $P4737, vivify_2250
    $P4737 = root_new ['parrot';'Hash']
  vivify_2250:
    set $P4738, $P4737["package_def"]
    unless_null $P4738, vivify_2251
    new $P4738, "Undef"
  vivify_2251:
    $P4739 = $P4738."ast"()
    $P4740 = $P4736."!make"($P4739)
    .return ($P4740)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<class>" :anon :subid("518_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_4742
    .param pmc param_4743
.annotate 'line', 1702
    .lex "self", param_4742
    .lex "$/", param_4743
    find_lex $P4744, "$/"
    find_lex $P4745, "$/"
    unless_null $P4745, vivify_2252
    $P4745 = root_new ['parrot';'Hash']
  vivify_2252:
    set $P4746, $P4745["package_def"]
    unless_null $P4746, vivify_2253
    new $P4746, "Undef"
  vivify_2253:
    $P4747 = $P4746."ast"()
    $P4748 = $P4744."!make"($P4747)
    .return ($P4748)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<grammar>" :anon :subid("519_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_4750
    .param pmc param_4751
.annotate 'line', 1703
    .lex "self", param_4750
    .lex "$/", param_4751
    find_lex $P4752, "$/"
    find_lex $P4753, "$/"
    unless_null $P4753, vivify_2254
    $P4753 = root_new ['parrot';'Hash']
  vivify_2254:
    set $P4754, $P4753["package_def"]
    unless_null $P4754, vivify_2255
    new $P4754, "Undef"
  vivify_2255:
    $P4755 = $P4754."ast"()
    $P4756 = $P4752."!make"($P4755)
    .return ($P4756)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<role>" :anon :subid("520_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_4758
    .param pmc param_4759
.annotate 'line', 1704
    .lex "self", param_4758
    .lex "$/", param_4759
    find_lex $P4760, "$/"
    find_lex $P4761, "$/"
    unless_null $P4761, vivify_2256
    $P4761 = root_new ['parrot';'Hash']
  vivify_2256:
    set $P4762, $P4761["package_def"]
    unless_null $P4762, vivify_2257
    new $P4762, "Undef"
  vivify_2257:
    $P4763 = $P4762."ast"()
    $P4764 = $P4760."!make"($P4763)
    .return ($P4764)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<native>" :anon :subid("521_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_4766
    .param pmc param_4767
.annotate 'line', 1705
    .lex "self", param_4766
    .lex "$/", param_4767
    find_lex $P4768, "$/"
    find_lex $P4769, "$/"
    unless_null $P4769, vivify_2258
    $P4769 = root_new ['parrot';'Hash']
  vivify_2258:
    set $P4770, $P4769["package_def"]
    unless_null $P4770, vivify_2259
    new $P4770, "Undef"
  vivify_2259:
    $P4771 = $P4770."ast"()
    $P4772 = $P4768."!make"($P4771)
    .return ($P4772)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<stub>" :anon :subid("522_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_4774
    .param pmc param_4775
.annotate 'line', 1707
    .lex "self", param_4774
    .lex "$/", param_4775
.annotate 'line', 1710
    new $P4776, "Undef"
    .lex "$HOW", $P4776
.annotate 'line', 1711
    new $P4777, "Undef"
    .lex "$PACKAGE", $P4777
.annotate 'line', 1710
    find_lex $P4778, "$/"
    unless_null $P4778, vivify_2260
    $P4778 = root_new ['parrot';'Hash']
  vivify_2260:
    set $P4779, $P4778["metaclass"]
    unless_null $P4779, vivify_2261
    $P4779 = root_new ['parrot';'Hash']
  vivify_2261:
    set $P4780, $P4779["identifier"]
    unless_null $P4780, vivify_2262
    new $P4780, "Undef"
  vivify_2262:
    find_lex $P4781, "$/"
    unless_null $P4781, vivify_2263
    new $P4781, "Undef"
  vivify_2263:
    $P4782 = "find_sym"($P4780, $P4781)
    store_lex "$HOW", $P4782
.annotate 'line', 1711
    find_dynamic_lex $P4785, "$*SC"
    unless_null $P4785, vivify_2264
    get_hll_global $P4783, "GLOBAL"
    get_who $P4784, $P4783
    set $P4785, $P4784["$SC"]
    unless_null $P4785, vivify_2265
    die "Contextual $*SC not found"
  vivify_2265:
  vivify_2264:
    find_lex $P4786, "$HOW"
    unless_null $P4786, vivify_2266
    new $P4786, "Undef"
  vivify_2266:
    find_lex $P4787, "$/"
    unless_null $P4787, vivify_2267
    $P4787 = root_new ['parrot';'Hash']
  vivify_2267:
    set $P4788, $P4787["name"]
    unless_null $P4788, vivify_2268
    new $P4788, "Undef"
  vivify_2268:
    set $S4789, $P4788
    $P4790 = $P4785."pkg_create_mo"($P4786, $S4789 :named("name"))
    store_lex "$PACKAGE", $P4790
.annotate 'line', 1714
    find_dynamic_lex $P4796, "$*SCOPE"
    unless_null $P4796, vivify_2269
    get_hll_global $P4794, "GLOBAL"
    get_who $P4795, $P4794
    set $P4796, $P4795["$SCOPE"]
    unless_null $P4796, vivify_2270
    die "Contextual $*SCOPE not found"
  vivify_2270:
  vivify_2269:
    set $S4797, $P4796
    iseq $I4798, $S4797, "our"
    unless $I4798, unless_4793
    new $P4792, 'Integer'
    set $P4792, $I4798
    goto unless_4793_end
  unless_4793:
    find_dynamic_lex $P4801, "$*SCOPE"
    unless_null $P4801, vivify_2271
    get_hll_global $P4799, "GLOBAL"
    get_who $P4800, $P4799
    set $P4801, $P4800["$SCOPE"]
    unless_null $P4801, vivify_2272
    die "Contextual $*SCOPE not found"
  vivify_2272:
  vivify_2271:
    set $S4802, $P4801
    iseq $I4803, $S4802, ""
    new $P4792, 'Integer'
    set $P4792, $I4803
  unless_4793_end:
    if $P4792, if_4791
.annotate 'line', 1720
    find_dynamic_lex $P4835, "$*SCOPE"
    unless_null $P4835, vivify_2273
    get_hll_global $P4833, "GLOBAL"
    get_who $P4834, $P4833
    set $P4835, $P4834["$SCOPE"]
    unless_null $P4835, vivify_2274
    die "Contextual $*SCOPE not found"
  vivify_2274:
  vivify_2273:
    set $S4836, $P4835
    iseq $I4837, $S4836, "my"
    if $I4837, if_4832
.annotate 'line', 1727
    find_lex $P4859, "$/"
    unless_null $P4859, vivify_2275
    new $P4859, "Undef"
  vivify_2275:
    $P4860 = $P4859."CURSOR"()
    find_dynamic_lex $P4863, "$*SCOPE"
    unless_null $P4863, vivify_2276
    get_hll_global $P4861, "GLOBAL"
    get_who $P4862, $P4861
    set $P4863, $P4862["$SCOPE"]
    unless_null $P4863, vivify_2277
    die "Contextual $*SCOPE not found"
  vivify_2277:
  vivify_2276:
    concat $P4864, $P4863, " scoped packages are not supported"
    $P4860."panic"($P4864)
.annotate 'line', 1726
    goto if_4832_end
  if_4832:
.annotate 'line', 1721
    find_lex $P4839, "$/"
    unless_null $P4839, vivify_2278
    $P4839 = root_new ['parrot';'Hash']
  vivify_2278:
    set $P4840, $P4839["name"]
    unless_null $P4840, vivify_2279
    $P4840 = root_new ['parrot';'Hash']
  vivify_2279:
    set $P4841, $P4840["identifier"]
    unless_null $P4841, vivify_2280
    new $P4841, "Undef"
  vivify_2280:
    set $N4842, $P4841
    isne $I4843, $N4842, 1.0
    unless $I4843, if_4838_end
.annotate 'line', 1722
    find_lex $P4844, "$/"
    unless_null $P4844, vivify_2281
    $P4844 = root_new ['parrot';'Hash']
  vivify_2281:
    set $P4845, $P4844["name"]
    unless_null $P4845, vivify_2282
    new $P4845, "Undef"
  vivify_2282:
    $P4846 = $P4845."CURSOR"()
    $P4846."panic"("A my scoped package cannot have a multi-part name yet")
  if_4838_end:
.annotate 'line', 1724
    find_dynamic_lex $P4849, "$*SC"
    unless_null $P4849, vivify_2283
    get_hll_global $P4847, "GLOBAL"
    get_who $P4848, $P4847
    set $P4849, $P4848["$SC"]
    unless_null $P4849, vivify_2284
    die "Contextual $*SC not found"
  vivify_2284:
  vivify_2283:
    find_lex $P4850, "$?PACKAGE"
    get_who $P4851, $P4850
    set $P4852, $P4851["@BLOCK"]
    unless_null $P4852, vivify_2285
    $P4852 = root_new ['parrot';'ResizablePMCArray']
  vivify_2285:
    set $P4853, $P4852[0]
    unless_null $P4853, vivify_2286
    new $P4853, "Undef"
  vivify_2286:
    find_lex $P4854, "$/"
    unless_null $P4854, vivify_2287
    $P4854 = root_new ['parrot';'Hash']
  vivify_2287:
    set $P4855, $P4854["name"]
    unless_null $P4855, vivify_2288
    $P4855 = root_new ['parrot';'Hash']
  vivify_2288:
    set $P4856, $P4855["identifier"]
    unless_null $P4856, vivify_2289
    $P4856 = root_new ['parrot';'ResizablePMCArray']
  vivify_2289:
    set $P4857, $P4856[0]
    unless_null $P4857, vivify_2290
    new $P4857, "Undef"
  vivify_2290:
    find_lex $P4858, "$PACKAGE"
    unless_null $P4858, vivify_2291
    new $P4858, "Undef"
  vivify_2291:
    $P4849."install_lexical_symbol"($P4853, $P4857, $P4858)
  if_4832_end:
.annotate 'line', 1720
    goto if_4791_end
  if_4791:
.annotate 'line', 1715
    find_dynamic_lex $P4806, "$*SC"
    unless_null $P4806, vivify_2292
    get_hll_global $P4804, "GLOBAL"
    get_who $P4805, $P4804
    set $P4806, $P4805["$SC"]
    unless_null $P4806, vivify_2293
    die "Contextual $*SC not found"
  vivify_2293:
  vivify_2292:
    find_dynamic_lex $P4809, "$*OUTERPACKAGE"
    unless_null $P4809, vivify_2294
    get_hll_global $P4807, "GLOBAL"
    get_who $P4808, $P4807
    set $P4809, $P4808["$OUTERPACKAGE"]
    unless_null $P4809, vivify_2295
    die "Contextual $*OUTERPACKAGE not found"
  vivify_2295:
  vivify_2294:
    find_lex $P4810, "$/"
    unless_null $P4810, vivify_2296
    $P4810 = root_new ['parrot';'Hash']
  vivify_2296:
    set $P4811, $P4810["name"]
    unless_null $P4811, vivify_2297
    $P4811 = root_new ['parrot';'Hash']
  vivify_2297:
    set $P4812, $P4811["identifier"]
    unless_null $P4812, vivify_2298
    new $P4812, "Undef"
  vivify_2298:
    find_lex $P4813, "$PACKAGE"
    unless_null $P4813, vivify_2299
    new $P4813, "Undef"
  vivify_2299:
    $P4806."install_package_symbol"($P4809, $P4812, $P4813)
.annotate 'line', 1716
    find_lex $P4815, "$/"
    unless_null $P4815, vivify_2300
    $P4815 = root_new ['parrot';'Hash']
  vivify_2300:
    set $P4816, $P4815["name"]
    unless_null $P4816, vivify_2301
    $P4816 = root_new ['parrot';'Hash']
  vivify_2301:
    set $P4817, $P4816["identifier"]
    unless_null $P4817, vivify_2302
    new $P4817, "Undef"
  vivify_2302:
    set $N4818, $P4817
    iseq $I4819, $N4818, 1.0
    unless $I4819, if_4814_end
.annotate 'line', 1717
    find_dynamic_lex $P4822, "$*SC"
    unless_null $P4822, vivify_2303
    get_hll_global $P4820, "GLOBAL"
    get_who $P4821, $P4820
    set $P4822, $P4821["$SC"]
    unless_null $P4822, vivify_2304
    die "Contextual $*SC not found"
  vivify_2304:
  vivify_2303:
    find_lex $P4823, "$?PACKAGE"
    get_who $P4824, $P4823
    set $P4825, $P4824["@BLOCK"]
    unless_null $P4825, vivify_2305
    $P4825 = root_new ['parrot';'ResizablePMCArray']
  vivify_2305:
    set $P4826, $P4825[0]
    unless_null $P4826, vivify_2306
    new $P4826, "Undef"
  vivify_2306:
    find_lex $P4827, "$/"
    unless_null $P4827, vivify_2307
    $P4827 = root_new ['parrot';'Hash']
  vivify_2307:
    set $P4828, $P4827["name"]
    unless_null $P4828, vivify_2308
    $P4828 = root_new ['parrot';'Hash']
  vivify_2308:
    set $P4829, $P4828["identifier"]
    unless_null $P4829, vivify_2309
    $P4829 = root_new ['parrot';'ResizablePMCArray']
  vivify_2309:
    set $P4830, $P4829[0]
    unless_null $P4830, vivify_2310
    new $P4830, "Undef"
  vivify_2310:
    find_lex $P4831, "$PACKAGE"
    unless_null $P4831, vivify_2311
    new $P4831, "Undef"
  vivify_2311:
    $P4822."install_lexical_symbol"($P4826, $P4830, $P4831)
  if_4814_end:
  if_4791_end:
.annotate 'line', 1730
    find_lex $P4865, "$/"
    get_hll_global $P4866, "GLOBAL"
    nqp_get_package_through_who $P4867, $P4866, "PAST"
    get_who $P4868, $P4867
    set $P4869, $P4868["Stmts"]
    $P4870 = $P4869."new"()
    $P4871 = $P4865."!make"($P4870)
.annotate 'line', 1707
    .return ($P4871)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "package_def" :anon :subid("523_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_4873
    .param pmc param_4874
.annotate 'line', 1733
    .const 'Sub' $P5054 = "527_1307873304.82979" 
    capture_lex $P5054
    .const 'Sub' $P5024 = "526_1307873304.82979" 
    capture_lex $P5024
    .const 'Sub' $P4977 = "524_1307873304.82979" 
    capture_lex $P4977
    .lex "self", param_4873
    .lex "$/", param_4874
.annotate 'line', 1735
    $P4875 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P4875
.annotate 'line', 1736
    new $P4876, "Undef"
    .lex "$name", $P4876
.annotate 'line', 1737
    new $P4877, "Undef"
    .lex "$how", $P4877
.annotate 'line', 1740
    new $P4878, "Undef"
    .lex "$past", $P4878
.annotate 'line', 1735
    find_lex $P4879, "$/"
    unless_null $P4879, vivify_2312
    $P4879 = root_new ['parrot';'Hash']
  vivify_2312:
    set $P4880, $P4879["name"]
    unless_null $P4880, vivify_2313
    $P4880 = root_new ['parrot';'Hash']
  vivify_2313:
    set $P4881, $P4880["identifier"]
    unless_null $P4881, vivify_2314
    new $P4881, "Undef"
  vivify_2314:
    clone $P4882, $P4881
    store_lex "@ns", $P4882
.annotate 'line', 1736
    find_lex $P4883, "@ns"
    unless_null $P4883, vivify_2315
    $P4883 = root_new ['parrot';'ResizablePMCArray']
  vivify_2315:
    $P4884 = $P4883."pop"()
    set $S4885, $P4884
    new $P4886, 'String'
    set $P4886, $S4885
    store_lex "$name", $P4886
.annotate 'line', 1737
    find_dynamic_lex $P4889, "$*PKGDECL"
    unless_null $P4889, vivify_2316
    get_hll_global $P4887, "GLOBAL"
    get_who $P4888, $P4887
    set $P4889, $P4888["$PKGDECL"]
    unless_null $P4889, vivify_2317
    die "Contextual $*PKGDECL not found"
  vivify_2317:
  vivify_2316:
    find_dynamic_lex $P4892, "%*HOW"
    unless_null $P4892, vivify_2318
    get_hll_global $P4890, "GLOBAL"
    get_who $P4891, $P4890
    set $P4892, $P4891["%HOW"]
    unless_null $P4892, vivify_2319
    die "Contextual %*HOW not found"
  vivify_2319:
  vivify_2318:
    set $P4893, $P4892[$P4889]
    unless_null $P4893, vivify_2320
    new $P4893, "Undef"
  vivify_2320:
    store_lex "$how", $P4893
.annotate 'line', 1740
    find_lex $P4896, "$/"
    unless_null $P4896, vivify_2321
    $P4896 = root_new ['parrot';'Hash']
  vivify_2321:
    set $P4897, $P4896["block"]
    unless_null $P4897, vivify_2322
    new $P4897, "Undef"
  vivify_2322:
    if $P4897, if_4895
    find_lex $P4901, "$/"
    unless_null $P4901, vivify_2323
    $P4901 = root_new ['parrot';'Hash']
  vivify_2323:
    set $P4902, $P4901["comp_unit"]
    unless_null $P4902, vivify_2324
    new $P4902, "Undef"
  vivify_2324:
    $P4903 = $P4902."ast"()
    set $P4894, $P4903
    goto if_4895_end
  if_4895:
    find_lex $P4898, "$/"
    unless_null $P4898, vivify_2325
    $P4898 = root_new ['parrot';'Hash']
  vivify_2325:
    set $P4899, $P4898["block"]
    unless_null $P4899, vivify_2326
    new $P4899, "Undef"
  vivify_2326:
    $P4900 = $P4899."ast"()
    set $P4894, $P4900
  if_4895_end:
    store_lex "$past", $P4894
.annotate 'line', 1741
    find_dynamic_lex $P4909, "$*SCOPE"
    unless_null $P4909, vivify_2327
    get_hll_global $P4907, "GLOBAL"
    get_who $P4908, $P4907
    set $P4909, $P4908["$SCOPE"]
    unless_null $P4909, vivify_2328
    die "Contextual $*SCOPE not found"
  vivify_2328:
  vivify_2327:
    set $S4910, $P4909
    iseq $I4911, $S4910, "our"
    unless $I4911, unless_4906
    new $P4905, 'Integer'
    set $P4905, $I4911
    goto unless_4906_end
  unless_4906:
    find_dynamic_lex $P4914, "$*SCOPE"
    unless_null $P4914, vivify_2329
    get_hll_global $P4912, "GLOBAL"
    get_who $P4913, $P4912
    set $P4914, $P4913["$SCOPE"]
    unless_null $P4914, vivify_2330
    die "Contextual $*SCOPE not found"
  vivify_2330:
  vivify_2329:
    set $S4915, $P4914
    iseq $I4916, $S4915, ""
    new $P4905, 'Integer'
    set $P4905, $I4916
  unless_4906_end:
    unless $P4905, if_4904_end
.annotate 'line', 1742
    find_lex $P4917, "$past"
    unless_null $P4917, vivify_2331
    new $P4917, "Undef"
  vivify_2331:
    find_lex $P4918, "$/"
    unless_null $P4918, vivify_2332
    $P4918 = root_new ['parrot';'Hash']
  vivify_2332:
    set $P4919, $P4918["name"]
    unless_null $P4919, vivify_2333
    $P4919 = root_new ['parrot';'Hash']
  vivify_2333:
    set $P4920, $P4919["identifier"]
    unless_null $P4920, vivify_2334
    new $P4920, "Undef"
  vivify_2334:
    $P4917."namespace"($P4920)
  if_4904_end:
.annotate 'line', 1749
    find_lex $P4924, "$how"
    unless_null $P4924, vivify_2335
    new $P4924, "Undef"
  vivify_2335:
    can $I4925, $P4924, "parametric"
    if $I4925, if_4923
    new $P4922, 'Integer'
    set $P4922, $I4925
    goto if_4923_end
  if_4923:
    find_lex $P4926, "$how"
    unless_null $P4926, vivify_2336
    new $P4926, "Undef"
  vivify_2336:
    find_lex $P4927, "$how"
    unless_null $P4927, vivify_2337
    new $P4927, "Undef"
  vivify_2337:
    $P4928 = $P4926."parametric"($P4927)
    set $P4922, $P4928
  if_4923_end:
    if $P4922, if_4921
.annotate 'line', 1758
    find_lex $P4958, "$past"
    unless_null $P4958, vivify_2338
    new $P4958, "Undef"
  vivify_2338:
    $P4958."blocktype"("immediate")
.annotate 'line', 1759
    find_dynamic_lex $P4961, "$*SC"
    unless_null $P4961, vivify_2339
    get_hll_global $P4959, "GLOBAL"
    get_who $P4960, $P4959
    set $P4961, $P4960["$SC"]
    unless_null $P4961, vivify_2340
    die "Contextual $*SC not found"
  vivify_2340:
  vivify_2339:
    find_lex $P4962, "$past"
    unless_null $P4962, vivify_2341
    new $P4962, "Undef"
  vivify_2341:
    find_dynamic_lex $P4965, "$*PACKAGE"
    unless_null $P4965, vivify_2342
    get_hll_global $P4963, "GLOBAL"
    get_who $P4964, $P4963
    set $P4965, $P4964["$PACKAGE"]
    unless_null $P4965, vivify_2343
    die "Contextual $*PACKAGE not found"
  vivify_2343:
  vivify_2342:
    $P4961."install_lexical_symbol"($P4962, "$?PACKAGE", $P4965)
.annotate 'line', 1760
    find_dynamic_lex $P4968, "$*SC"
    unless_null $P4968, vivify_2344
    get_hll_global $P4966, "GLOBAL"
    get_who $P4967, $P4966
    set $P4968, $P4967["$SC"]
    unless_null $P4968, vivify_2345
    die "Contextual $*SC not found"
  vivify_2345:
  vivify_2344:
    find_lex $P4969, "$past"
    unless_null $P4969, vivify_2346
    new $P4969, "Undef"
  vivify_2346:
    find_dynamic_lex $P4972, "$*PACKAGE"
    unless_null $P4972, vivify_2347
    get_hll_global $P4970, "GLOBAL"
    get_who $P4971, $P4970
    set $P4972, $P4971["$PACKAGE"]
    unless_null $P4972, vivify_2348
    die "Contextual $*PACKAGE not found"
  vivify_2348:
  vivify_2347:
    $P4968."install_lexical_symbol"($P4969, "$?CLASS", $P4972)
.annotate 'line', 1757
    goto if_4921_end
  if_4921:
.annotate 'line', 1750
    find_lex $P4929, "$past"
    unless_null $P4929, vivify_2349
    new $P4929, "Undef"
  vivify_2349:
    $P4929."blocktype"("declaration")
.annotate 'line', 1751
    find_lex $P4930, "$past"
    unless_null $P4930, vivify_2350
    new $P4930, "Undef"
  vivify_2350:
    get_hll_global $P4931, "GLOBAL"
    nqp_get_package_through_who $P4932, $P4931, "PAST"
    get_who $P4933, $P4932
    set $P4934, $P4933["Var"]
    $P4935 = $P4934."new"("$?CLASS" :named("name"), "parameter" :named("scope"))
    $P4930."unshift"($P4935)
.annotate 'line', 1752
    find_lex $P4936, "$past"
    unless_null $P4936, vivify_2351
    new $P4936, "Undef"
  vivify_2351:
    $P4936."symbol"("$?CLASS", "lexical" :named("scope"))
.annotate 'line', 1753
    find_dynamic_lex $P4939, "$*SC"
    unless_null $P4939, vivify_2352
    get_hll_global $P4937, "GLOBAL"
    get_who $P4938, $P4937
    set $P4939, $P4938["$SC"]
    unless_null $P4939, vivify_2353
    die "Contextual $*SC not found"
  vivify_2353:
  vivify_2352:
    find_dynamic_lex $P4942, "$*PACKAGE"
    unless_null $P4942, vivify_2354
    get_hll_global $P4940, "GLOBAL"
    get_who $P4941, $P4940
    set $P4942, $P4941["$PACKAGE"]
    unless_null $P4942, vivify_2355
    die "Contextual $*PACKAGE not found"
  vivify_2355:
  vivify_2354:
    find_lex $P4943, "$past"
    unless_null $P4943, vivify_2356
    new $P4943, "Undef"
  vivify_2356:
    $P4939."pkg_set_body_block"($P4942, $P4943)
.annotate 'line', 1754
    find_dynamic_lex $P4946, "$*SC"
    unless_null $P4946, vivify_2357
    get_hll_global $P4944, "GLOBAL"
    get_who $P4945, $P4944
    set $P4946, $P4945["$SC"]
    unless_null $P4946, vivify_2358
    die "Contextual $*SC not found"
  vivify_2358:
  vivify_2357:
    find_lex $P4947, "$past"
    unless_null $P4947, vivify_2359
    new $P4947, "Undef"
  vivify_2359:
    find_dynamic_lex $P4950, "$*PACKAGE"
    unless_null $P4950, vivify_2360
    get_hll_global $P4948, "GLOBAL"
    get_who $P4949, $P4948
    set $P4950, $P4949["$PACKAGE"]
    unless_null $P4950, vivify_2361
    die "Contextual $*PACKAGE not found"
  vivify_2361:
  vivify_2360:
    $P4946."install_lexical_symbol"($P4947, "$?PACKAGE", $P4950)
.annotate 'line', 1755
    find_dynamic_lex $P4953, "$*SC"
    unless_null $P4953, vivify_2362
    get_hll_global $P4951, "GLOBAL"
    get_who $P4952, $P4951
    set $P4953, $P4952["$SC"]
    unless_null $P4953, vivify_2363
    die "Contextual $*SC not found"
  vivify_2363:
  vivify_2362:
    find_lex $P4954, "$past"
    unless_null $P4954, vivify_2364
    new $P4954, "Undef"
  vivify_2364:
    find_dynamic_lex $P4957, "$*PACKAGE"
    unless_null $P4957, vivify_2365
    get_hll_global $P4955, "GLOBAL"
    get_who $P4956, $P4955
    set $P4957, $P4956["$PACKAGE"]
    unless_null $P4957, vivify_2366
    die "Contextual $*PACKAGE not found"
  vivify_2366:
  vivify_2365:
    $P4953."install_lexical_symbol"($P4954, "$?ROLE", $P4957)
  if_4921_end:
.annotate 'line', 1764
    find_lex $P4974, "$/"
    unless_null $P4974, vivify_2367
    $P4974 = root_new ['parrot';'Hash']
  vivify_2367:
    set $P4975, $P4974["parent"]
    unless_null $P4975, vivify_2368
    new $P4975, "Undef"
  vivify_2368:
    if $P4975, if_4973
.annotate 'line', 1778
    find_lex $P5021, "$how"
    unless_null $P5021, vivify_2369
    new $P5021, "Undef"
  vivify_2369:
    can $I5022, $P5021, "set_default_parent"
    unless $I5022, if_5020_end
    .const 'Sub' $P5024 = "526_1307873304.82979" 
    capture_lex $P5024
    $P5024()
  if_5020_end:
    goto if_4973_end
  if_4973:
.annotate 'line', 1764
    .const 'Sub' $P4977 = "524_1307873304.82979" 
    capture_lex $P4977
    $P4977()
  if_4973_end:
.annotate 'line', 1785
    find_lex $P5046, "$/"
    unless_null $P5046, vivify_2395
    $P5046 = root_new ['parrot';'Hash']
  vivify_2395:
    set $P5047, $P5046["role"]
    unless_null $P5047, vivify_2396
    new $P5047, "Undef"
  vivify_2396:
    unless $P5047, if_5045_end
.annotate 'line', 1786
    find_lex $P5049, "$/"
    unless_null $P5049, vivify_2397
    $P5049 = root_new ['parrot';'Hash']
  vivify_2397:
    set $P5050, $P5049["role"]
    unless_null $P5050, vivify_2398
    new $P5050, "Undef"
  vivify_2398:
    defined $I5051, $P5050
    unless $I5051, for_undef_2399
    iter $P5048, $P5050
    new $P5095, 'ExceptionHandler'
    set_label $P5095, loop5094_handler
    $P5095."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5095
  loop5094_test:
    unless $P5048, loop5094_done
    shift $P5052, $P5048
  loop5094_redo:
    .const 'Sub' $P5054 = "527_1307873304.82979" 
    capture_lex $P5054
    $P5054($P5052)
  loop5094_next:
    goto loop5094_test
  loop5094_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5096, exception, 'type'
    eq $P5096, .CONTROL_LOOP_NEXT, loop5094_next
    eq $P5096, .CONTROL_LOOP_REDO, loop5094_redo
  loop5094_done:
    pop_eh 
  for_undef_2399:
  if_5045_end:
.annotate 'line', 1803
    find_dynamic_lex $P5099, "$*SC"
    unless_null $P5099, vivify_2413
    get_hll_global $P5097, "GLOBAL"
    get_who $P5098, $P5097
    set $P5099, $P5098["$SC"]
    unless_null $P5099, vivify_2414
    die "Contextual $*SC not found"
  vivify_2414:
  vivify_2413:
    find_dynamic_lex $P5102, "$*PACKAGE"
    unless_null $P5102, vivify_2415
    get_hll_global $P5100, "GLOBAL"
    get_who $P5101, $P5100
    set $P5102, $P5101["$PACKAGE"]
    unless_null $P5102, vivify_2416
    die "Contextual $*PACKAGE not found"
  vivify_2416:
  vivify_2415:
    $P5099."pkg_compose"($P5102)
.annotate 'line', 1805
    find_lex $P5103, "$/"
    find_lex $P5104, "$past"
    unless_null $P5104, vivify_2417
    new $P5104, "Undef"
  vivify_2417:
    $P5105 = $P5103."!make"($P5104)
.annotate 'line', 1733
    .return ($P5105)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5023"  :anon :subid("526_1307873304.82979") :outer("523_1307873304.82979")
.annotate 'line', 1779
    new $P5025, "Undef"
    .lex "$default", $P5025
    find_dynamic_lex $P5030, "$*PKGDECL"
    unless_null $P5030, vivify_2370
    get_hll_global $P5028, "GLOBAL"
    get_who $P5029, $P5028
    set $P5030, $P5029["$PKGDECL"]
    unless_null $P5030, vivify_2371
    die "Contextual $*PKGDECL not found"
  vivify_2371:
  vivify_2370:
    set $S5031, $P5030
    iseq $I5032, $S5031, "grammar"
    if $I5032, if_5027
    new $P5034, "ResizablePMCArray"
    push $P5034, "NQPMu"
    set $P5026, $P5034
    goto if_5027_end
  if_5027:
    new $P5033, "ResizablePMCArray"
    push $P5033, "Regex"
    push $P5033, "Cursor"
    set $P5026, $P5033
  if_5027_end:
    store_lex "$default", $P5026
.annotate 'line', 1780
    find_dynamic_lex $P5037, "$*SC"
    unless_null $P5037, vivify_2372
    get_hll_global $P5035, "GLOBAL"
    get_who $P5036, $P5035
    set $P5037, $P5036["$SC"]
    unless_null $P5037, vivify_2373
    die "Contextual $*SC not found"
  vivify_2373:
  vivify_2372:
    find_dynamic_lex $P5040, "$*PACKAGE"
    unless_null $P5040, vivify_2374
    get_hll_global $P5038, "GLOBAL"
    get_who $P5039, $P5038
    set $P5040, $P5039["$PACKAGE"]
    unless_null $P5040, vivify_2375
    die "Contextual $*PACKAGE not found"
  vivify_2375:
  vivify_2374:
.annotate 'line', 1781
    find_lex $P5041, "$default"
    unless_null $P5041, vivify_2376
    new $P5041, "Undef"
  vivify_2376:
    find_lex $P5042, "$/"
    unless_null $P5042, vivify_2377
    new $P5042, "Undef"
  vivify_2377:
    $P5043 = "find_sym"($P5041, $P5042)
    $P5044 = $P5037."pkg_add_parent_or_role"($P5040, "set_default_parent", $P5043)
.annotate 'line', 1778
    .return ($P5044)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4976"  :anon :subid("524_1307873304.82979") :outer("523_1307873304.82979")
.annotate 'line', 1764
    .const 'Sub' $P4983 = "525_1307873304.82979" 
    capture_lex $P4983
.annotate 'line', 1765
    new $P4978, "Undef"
    .lex "$parent", $P4978
.annotate 'line', 1766
    new $P4979, "Undef"
    .lex "$parent_found", $P4979
.annotate 'line', 1764
    find_lex $P4980, "$parent"
    unless_null $P4980, vivify_2378
    new $P4980, "Undef"
  vivify_2378:
    find_lex $P4981, "$parent_found"
    unless_null $P4981, vivify_2379
    new $P4981, "Undef"
  vivify_2379:
.annotate 'line', 1767
    .const 'Sub' $P4983 = "525_1307873304.82979" 
    capture_lex $P4983
    $P4983()
.annotate 'line', 1771
    find_lex $P5001, "$parent_found"
    unless_null $P5001, vivify_2385
    new $P5001, "Undef"
  vivify_2385:
    if $P5001, if_5000
.annotate 'line', 1775
    find_lex $P5010, "$/"
    unless_null $P5010, vivify_2386
    new $P5010, "Undef"
  vivify_2386:
    $P5011 = $P5010."CURSOR"()
    new $P5012, "String"
    assign $P5012, "Could not find parent class '"
    find_lex $P5013, "$/"
    unless_null $P5013, vivify_2387
    $P5013 = root_new ['parrot';'Hash']
  vivify_2387:
    set $P5014, $P5013["parent"]
    unless_null $P5014, vivify_2388
    $P5014 = root_new ['parrot';'ResizablePMCArray']
  vivify_2388:
    set $P5015, $P5014[0]
    unless_null $P5015, vivify_2389
    new $P5015, "Undef"
  vivify_2389:
    set $S5016, $P5015
    concat $P5017, $P5012, $S5016
    concat $P5018, $P5017, "'"
    $P5019 = $P5011."panic"($P5018)
.annotate 'line', 1774
    set $P4999, $P5019
.annotate 'line', 1771
    goto if_5000_end
  if_5000:
.annotate 'line', 1772
    find_dynamic_lex $P5004, "$*SC"
    unless_null $P5004, vivify_2390
    get_hll_global $P5002, "GLOBAL"
    get_who $P5003, $P5002
    set $P5004, $P5003["$SC"]
    unless_null $P5004, vivify_2391
    die "Contextual $*SC not found"
  vivify_2391:
  vivify_2390:
    find_dynamic_lex $P5007, "$*PACKAGE"
    unless_null $P5007, vivify_2392
    get_hll_global $P5005, "GLOBAL"
    get_who $P5006, $P5005
    set $P5007, $P5006["$PACKAGE"]
    unless_null $P5007, vivify_2393
    die "Contextual $*PACKAGE not found"
  vivify_2393:
  vivify_2392:
    find_lex $P5008, "$parent"
    unless_null $P5008, vivify_2394
    new $P5008, "Undef"
  vivify_2394:
    $P5009 = $P5004."pkg_add_parent_or_role"($P5007, "add_parent", $P5008)
.annotate 'line', 1771
    set $P4999, $P5009
  if_5000_end:
.annotate 'line', 1764
    .return ($P4999)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block4982"  :anon :subid("525_1307873304.82979") :outer("524_1307873304.82979")
.annotate 'line', 1767
    new $P4994, 'ExceptionHandler'
    set_label $P4994, control_4993
    $P4994."handle_types_except"(.CONTROL_RETURN,  .CONTROL_OK,  .CONTROL_BREAK,  .CONTROL_CONTINUE,  .CONTROL_TAKE,  .CONTROL_LEAVE,  .CONTROL_EXIT,  .CONTROL_LOOP_NEXT,  .CONTROL_LOOP_LAST,  .CONTROL_LOOP_REDO)
    push_eh $P4994
.annotate 'line', 1768
    find_lex $P4984, "$/"
    unless_null $P4984, vivify_2380
    $P4984 = root_new ['parrot';'Hash']
  vivify_2380:
    set $P4985, $P4984["parent"]
    unless_null $P4985, vivify_2381
    $P4985 = root_new ['parrot';'ResizablePMCArray']
  vivify_2381:
    set $P4986, $P4985[0]
    unless_null $P4986, vivify_2382
    $P4986 = root_new ['parrot';'Hash']
  vivify_2382:
    set $P4987, $P4986["identifier"]
    unless_null $P4987, vivify_2383
    new $P4987, "Undef"
  vivify_2383:
    clone $P4988, $P4987
    find_lex $P4989, "$/"
    unless_null $P4989, vivify_2384
    new $P4989, "Undef"
  vivify_2384:
    $P4990 = "find_sym"($P4988, $P4989)
    store_lex "$parent", $P4990
.annotate 'line', 1769
    new $P4991, "Integer"
    assign $P4991, 1
    store_lex "$parent_found", $P4991
.annotate 'line', 1767
    pop_eh 
    goto skip_handler_4992
  control_4993:
    .local pmc exception 
    .get_results (exception) 
    new $P4997, 'Integer'
    set $P4997, 1
    set exception["handled"], $P4997
    set $I4998, exception["handled"]
    ne $I4998, 1, nothandled_4996
  handled_4995:
    .return (exception)
  nothandled_4996:
    rethrow exception
  skip_handler_4992:
    .return ($P4991)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5053"  :anon :subid("527_1307873304.82979") :outer("523_1307873304.82979")
    .param pmc param_5057
.annotate 'line', 1786
    .const 'Sub' $P5061 = "528_1307873304.82979" 
    capture_lex $P5061
.annotate 'line', 1787
    new $P5055, "Undef"
    .lex "$role", $P5055
.annotate 'line', 1788
    new $P5056, "Undef"
    .lex "$role_found", $P5056
    .lex "$_", param_5057
.annotate 'line', 1786
    find_lex $P5058, "$role"
    unless_null $P5058, vivify_2400
    new $P5058, "Undef"
  vivify_2400:
    find_lex $P5059, "$role_found"
    unless_null $P5059, vivify_2401
    new $P5059, "Undef"
  vivify_2401:
.annotate 'line', 1789
    .const 'Sub' $P5061 = "528_1307873304.82979" 
    capture_lex $P5061
    $P5061()
.annotate 'line', 1793
    find_lex $P5077, "$role_found"
    unless_null $P5077, vivify_2405
    new $P5077, "Undef"
  vivify_2405:
    if $P5077, if_5076
.annotate 'line', 1797
    find_lex $P5086, "$/"
    unless_null $P5086, vivify_2406
    new $P5086, "Undef"
  vivify_2406:
    $P5087 = $P5086."CURSOR"()
    new $P5088, "String"
    assign $P5088, "Could not find role '"
    find_lex $P5089, "$_"
    unless_null $P5089, vivify_2407
    new $P5089, "Undef"
  vivify_2407:
    set $S5090, $P5089
    concat $P5091, $P5088, $S5090
    concat $P5092, $P5091, "'"
    $P5093 = $P5087."panic"($P5092)
.annotate 'line', 1796
    set $P5075, $P5093
.annotate 'line', 1793
    goto if_5076_end
  if_5076:
.annotate 'line', 1794
    find_dynamic_lex $P5080, "$*SC"
    unless_null $P5080, vivify_2408
    get_hll_global $P5078, "GLOBAL"
    get_who $P5079, $P5078
    set $P5080, $P5079["$SC"]
    unless_null $P5080, vivify_2409
    die "Contextual $*SC not found"
  vivify_2409:
  vivify_2408:
    find_dynamic_lex $P5083, "$*PACKAGE"
    unless_null $P5083, vivify_2410
    get_hll_global $P5081, "GLOBAL"
    get_who $P5082, $P5081
    set $P5083, $P5082["$PACKAGE"]
    unless_null $P5083, vivify_2411
    die "Contextual $*PACKAGE not found"
  vivify_2411:
  vivify_2410:
    find_lex $P5084, "$role"
    unless_null $P5084, vivify_2412
    new $P5084, "Undef"
  vivify_2412:
    $P5085 = $P5080."pkg_add_parent_or_role"($P5083, "add_role", $P5084)
.annotate 'line', 1793
    set $P5075, $P5085
  if_5076_end:
.annotate 'line', 1786
    .return ($P5075)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block5060"  :anon :subid("528_1307873304.82979") :outer("527_1307873304.82979")
.annotate 'line', 1789
    new $P5070, 'ExceptionHandler'
    set_label $P5070, control_5069
    $P5070."handle_types_except"(.CONTROL_RETURN,  .CONTROL_OK,  .CONTROL_BREAK,  .CONTROL_CONTINUE,  .CONTROL_TAKE,  .CONTROL_LEAVE,  .CONTROL_EXIT,  .CONTROL_LOOP_NEXT,  .CONTROL_LOOP_LAST,  .CONTROL_LOOP_REDO)
    push_eh $P5070
.annotate 'line', 1790
    find_lex $P5062, "$_"
    unless_null $P5062, vivify_2402
    $P5062 = root_new ['parrot';'Hash']
  vivify_2402:
    set $P5063, $P5062["identifier"]
    unless_null $P5063, vivify_2403
    new $P5063, "Undef"
  vivify_2403:
    clone $P5064, $P5063
    find_lex $P5065, "$/"
    unless_null $P5065, vivify_2404
    new $P5065, "Undef"
  vivify_2404:
    $P5066 = "find_sym"($P5064, $P5065)
    store_lex "$role", $P5066
.annotate 'line', 1791
    new $P5067, "Integer"
    assign $P5067, 1
    store_lex "$role_found", $P5067
.annotate 'line', 1789
    pop_eh 
    goto skip_handler_5068
  control_5069:
    .local pmc exception 
    .get_results (exception) 
    new $P5073, 'Integer'
    set $P5073, 1
    set exception["handled"], $P5073
    set $I5074, exception["handled"]
    ne $I5074, 1, nothandled_5072
  handled_5071:
    .return (exception)
  nothandled_5072:
    rethrow exception
  skip_handler_5068:
    .return ($P5067)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<my>" :anon :subid("529_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_5107
    .param pmc param_5108
.annotate 'line', 1808
    .lex "self", param_5107
    .lex "$/", param_5108
    find_lex $P5109, "$/"
    find_lex $P5110, "$/"
    unless_null $P5110, vivify_2418
    $P5110 = root_new ['parrot';'Hash']
  vivify_2418:
    set $P5111, $P5110["scoped"]
    unless_null $P5111, vivify_2419
    new $P5111, "Undef"
  vivify_2419:
    $P5112 = $P5111."ast"()
    $P5113 = $P5109."!make"($P5112)
    .return ($P5113)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<our>" :anon :subid("530_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_5115
    .param pmc param_5116
.annotate 'line', 1809
    .lex "self", param_5115
    .lex "$/", param_5116
    find_lex $P5117, "$/"
    find_lex $P5118, "$/"
    unless_null $P5118, vivify_2420
    $P5118 = root_new ['parrot';'Hash']
  vivify_2420:
    set $P5119, $P5118["scoped"]
    unless_null $P5119, vivify_2421
    new $P5119, "Undef"
  vivify_2421:
    $P5120 = $P5119."ast"()
    $P5121 = $P5117."!make"($P5120)
    .return ($P5121)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<has>" :anon :subid("531_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_5123
    .param pmc param_5124
.annotate 'line', 1810
    .lex "self", param_5123
    .lex "$/", param_5124
    find_lex $P5125, "$/"
    find_lex $P5126, "$/"
    unless_null $P5126, vivify_2422
    $P5126 = root_new ['parrot';'Hash']
  vivify_2422:
    set $P5127, $P5126["scoped"]
    unless_null $P5127, vivify_2423
    new $P5127, "Undef"
  vivify_2423:
    $P5128 = $P5127."ast"()
    $P5129 = $P5125."!make"($P5128)
    .return ($P5129)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scoped" :anon :subid("532_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_5131
    .param pmc param_5132
.annotate 'line', 1812
    .lex "self", param_5131
    .lex "$/", param_5132
.annotate 'line', 1813
    find_lex $P5133, "$/"
    find_lex $P5136, "$/"
    unless_null $P5136, vivify_2424
    $P5136 = root_new ['parrot';'Hash']
  vivify_2424:
    set $P5137, $P5136["declarator"]
    unless_null $P5137, vivify_2425
    new $P5137, "Undef"
  vivify_2425:
    if $P5137, if_5135
.annotate 'line', 1814
    find_lex $P5143, "$/"
    unless_null $P5143, vivify_2426
    $P5143 = root_new ['parrot';'Hash']
  vivify_2426:
    set $P5144, $P5143["multi_declarator"]
    unless_null $P5144, vivify_2427
    new $P5144, "Undef"
  vivify_2427:
    if $P5144, if_5142
.annotate 'line', 1815
    find_lex $P5148, "$/"
    unless_null $P5148, vivify_2428
    $P5148 = root_new ['parrot';'Hash']
  vivify_2428:
    set $P5149, $P5148["package_declarator"]
    unless_null $P5149, vivify_2429
    new $P5149, "Undef"
  vivify_2429:
    $P5150 = $P5149."ast"()
    set $P5141, $P5150
.annotate 'line', 1814
    goto if_5142_end
  if_5142:
    find_lex $P5145, "$/"
    unless_null $P5145, vivify_2430
    $P5145 = root_new ['parrot';'Hash']
  vivify_2430:
    set $P5146, $P5145["multi_declarator"]
    unless_null $P5146, vivify_2431
    new $P5146, "Undef"
  vivify_2431:
    $P5147 = $P5146."ast"()
    set $P5141, $P5147
  if_5142_end:
    set $P5134, $P5141
.annotate 'line', 1813
    goto if_5135_end
  if_5135:
    find_lex $P5138, "$/"
    unless_null $P5138, vivify_2432
    $P5138 = root_new ['parrot';'Hash']
  vivify_2432:
    set $P5139, $P5138["declarator"]
    unless_null $P5139, vivify_2433
    new $P5139, "Undef"
  vivify_2433:
    $P5140 = $P5139."ast"()
    set $P5134, $P5140
  if_5135_end:
    $P5151 = $P5133."!make"($P5134)
.annotate 'line', 1812
    .return ($P5151)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "declarator" :anon :subid("533_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_5153
    .param pmc param_5154
.annotate 'line', 1818
    .lex "self", param_5153
    .lex "$/", param_5154
.annotate 'line', 1819
    find_lex $P5155, "$/"
.annotate 'line', 1820
    find_lex $P5158, "$/"
    unless_null $P5158, vivify_2434
    $P5158 = root_new ['parrot';'Hash']
  vivify_2434:
    set $P5159, $P5158["routine_declarator"]
    unless_null $P5159, vivify_2435
    new $P5159, "Undef"
  vivify_2435:
    if $P5159, if_5157
.annotate 'line', 1821
    find_lex $P5163, "$/"
    unless_null $P5163, vivify_2436
    $P5163 = root_new ['parrot';'Hash']
  vivify_2436:
    set $P5164, $P5163["variable_declarator"]
    unless_null $P5164, vivify_2437
    new $P5164, "Undef"
  vivify_2437:
    $P5165 = $P5164."ast"()
    set $P5156, $P5165
.annotate 'line', 1820
    goto if_5157_end
  if_5157:
    find_lex $P5160, "$/"
    unless_null $P5160, vivify_2438
    $P5160 = root_new ['parrot';'Hash']
  vivify_2438:
    set $P5161, $P5160["routine_declarator"]
    unless_null $P5161, vivify_2439
    new $P5161, "Undef"
  vivify_2439:
    $P5162 = $P5161."ast"()
    set $P5156, $P5162
  if_5157_end:
    $P5166 = $P5155."!make"($P5156)
.annotate 'line', 1818
    .return ($P5166)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<multi>" :anon :subid("534_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_5168
    .param pmc param_5169
.annotate 'line', 1824
    .lex "self", param_5168
    .lex "$/", param_5169
    find_lex $P5170, "$/"
    find_lex $P5173, "$/"
    unless_null $P5173, vivify_2440
    $P5173 = root_new ['parrot';'Hash']
  vivify_2440:
    set $P5174, $P5173["declarator"]
    unless_null $P5174, vivify_2441
    new $P5174, "Undef"
  vivify_2441:
    if $P5174, if_5172
    find_lex $P5178, "$/"
    unless_null $P5178, vivify_2442
    $P5178 = root_new ['parrot';'Hash']
  vivify_2442:
    set $P5179, $P5178["routine_def"]
    unless_null $P5179, vivify_2443
    new $P5179, "Undef"
  vivify_2443:
    $P5180 = $P5179."ast"()
    set $P5171, $P5180
    goto if_5172_end
  if_5172:
    find_lex $P5175, "$/"
    unless_null $P5175, vivify_2444
    $P5175 = root_new ['parrot';'Hash']
  vivify_2444:
    set $P5176, $P5175["declarator"]
    unless_null $P5176, vivify_2445
    new $P5176, "Undef"
  vivify_2445:
    $P5177 = $P5176."ast"()
    set $P5171, $P5177
  if_5172_end:
    $P5181 = $P5170."!make"($P5171)
    .return ($P5181)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<proto>" :anon :subid("535_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_5183
    .param pmc param_5184
.annotate 'line', 1825
    .lex "self", param_5183
    .lex "$/", param_5184
    find_lex $P5185, "$/"
    find_lex $P5188, "$/"
    unless_null $P5188, vivify_2446
    $P5188 = root_new ['parrot';'Hash']
  vivify_2446:
    set $P5189, $P5188["declarator"]
    unless_null $P5189, vivify_2447
    new $P5189, "Undef"
  vivify_2447:
    if $P5189, if_5187
    find_lex $P5193, "$/"
    unless_null $P5193, vivify_2448
    $P5193 = root_new ['parrot';'Hash']
  vivify_2448:
    set $P5194, $P5193["routine_def"]
    unless_null $P5194, vivify_2449
    new $P5194, "Undef"
  vivify_2449:
    $P5195 = $P5194."ast"()
    set $P5186, $P5195
    goto if_5187_end
  if_5187:
    find_lex $P5190, "$/"
    unless_null $P5190, vivify_2450
    $P5190 = root_new ['parrot';'Hash']
  vivify_2450:
    set $P5191, $P5190["declarator"]
    unless_null $P5191, vivify_2451
    new $P5191, "Undef"
  vivify_2451:
    $P5192 = $P5191."ast"()
    set $P5186, $P5192
  if_5187_end:
    $P5196 = $P5185."!make"($P5186)
    .return ($P5196)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<null>" :anon :subid("536_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_5198
    .param pmc param_5199
.annotate 'line', 1826
    .lex "self", param_5198
    .lex "$/", param_5199
    find_lex $P5200, "$/"
    find_lex $P5201, "$/"
    unless_null $P5201, vivify_2452
    $P5201 = root_new ['parrot';'Hash']
  vivify_2452:
    set $P5202, $P5201["declarator"]
    unless_null $P5202, vivify_2453
    new $P5202, "Undef"
  vivify_2453:
    $P5203 = $P5202."ast"()
    $P5204 = $P5200."!make"($P5203)
    .return ($P5204)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "variable_declarator" :anon :subid("537_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_5206
    .param pmc param_5207
.annotate 'line', 1829
    .const 'Sub' $P5339 = "539_1307873304.82979" 
    capture_lex $P5339
    .const 'Sub' $P5241 = "538_1307873304.82979" 
    capture_lex $P5241
    .lex "self", param_5206
    .lex "$/", param_5207
.annotate 'line', 1830
    new $P5208, "Undef"
    .lex "$past", $P5208
.annotate 'line', 1831
    new $P5209, "Undef"
    .lex "$sigil", $P5209
.annotate 'line', 1832
    new $P5210, "Undef"
    .lex "$name", $P5210
.annotate 'line', 1833
    new $P5211, "Undef"
    .lex "$BLOCK", $P5211
.annotate 'line', 1830
    find_lex $P5212, "$/"
    unless_null $P5212, vivify_2454
    $P5212 = root_new ['parrot';'Hash']
  vivify_2454:
    set $P5213, $P5212["variable"]
    unless_null $P5213, vivify_2455
    new $P5213, "Undef"
  vivify_2455:
    $P5214 = $P5213."ast"()
    store_lex "$past", $P5214
.annotate 'line', 1831
    find_lex $P5215, "$/"
    unless_null $P5215, vivify_2456
    $P5215 = root_new ['parrot';'Hash']
  vivify_2456:
    set $P5216, $P5215["variable"]
    unless_null $P5216, vivify_2457
    $P5216 = root_new ['parrot';'Hash']
  vivify_2457:
    set $P5217, $P5216["sigil"]
    unless_null $P5217, vivify_2458
    new $P5217, "Undef"
  vivify_2458:
    store_lex "$sigil", $P5217
.annotate 'line', 1832
    find_lex $P5218, "$past"
    unless_null $P5218, vivify_2459
    new $P5218, "Undef"
  vivify_2459:
    $P5219 = $P5218."name"()
    store_lex "$name", $P5219
.annotate 'line', 1833
    find_lex $P5220, "$?PACKAGE"
    get_who $P5221, $P5220
    set $P5222, $P5221["@BLOCK"]
    unless_null $P5222, vivify_2460
    $P5222 = root_new ['parrot';'ResizablePMCArray']
  vivify_2460:
    set $P5223, $P5222[0]
    unless_null $P5223, vivify_2461
    new $P5223, "Undef"
  vivify_2461:
    store_lex "$BLOCK", $P5223
.annotate 'line', 1834
    find_lex $P5227, "$name"
    unless_null $P5227, vivify_2462
    new $P5227, "Undef"
  vivify_2462:
    if $P5227, if_5226
    set $P5225, $P5227
    goto if_5226_end
  if_5226:
    find_lex $P5228, "$BLOCK"
    unless_null $P5228, vivify_2463
    new $P5228, "Undef"
  vivify_2463:
    find_lex $P5229, "$name"
    unless_null $P5229, vivify_2464
    new $P5229, "Undef"
  vivify_2464:
    $P5230 = $P5228."symbol"($P5229)
    set $P5225, $P5230
  if_5226_end:
    unless $P5225, if_5224_end
.annotate 'line', 1835
    find_lex $P5231, "$/"
    unless_null $P5231, vivify_2465
    new $P5231, "Undef"
  vivify_2465:
    $P5232 = $P5231."CURSOR"()
    find_lex $P5233, "$name"
    unless_null $P5233, vivify_2466
    new $P5233, "Undef"
  vivify_2466:
    $P5232."panic"("Redeclaration of symbol ", $P5233)
  if_5224_end:
.annotate 'line', 1837
    find_dynamic_lex $P5237, "$*SCOPE"
    unless_null $P5237, vivify_2467
    get_hll_global $P5235, "GLOBAL"
    get_who $P5236, $P5235
    set $P5237, $P5236["$SCOPE"]
    unless_null $P5237, vivify_2468
    die "Contextual $*SCOPE not found"
  vivify_2468:
  vivify_2467:
    set $S5238, $P5237
    iseq $I5239, $S5238, "has"
    if $I5239, if_5234
.annotate 'line', 1857
    find_dynamic_lex $P5298, "$*SCOPE"
    unless_null $P5298, vivify_2469
    get_hll_global $P5296, "GLOBAL"
    get_who $P5297, $P5296
    set $P5298, $P5297["$SCOPE"]
    unless_null $P5298, vivify_2470
    die "Contextual $*SCOPE not found"
  vivify_2470:
  vivify_2469:
    set $S5299, $P5298
    iseq $I5300, $S5299, "our"
    if $I5300, if_5295
.annotate 'line', 1867
    find_lex $P5314, "$BLOCK"
    unless_null $P5314, vivify_2471
    $P5314 = root_new ['parrot';'ResizablePMCArray']
  vivify_2471:
    set $P5315, $P5314[0]
    unless_null $P5315, vivify_2472
    new $P5315, "Undef"
  vivify_2472:
    get_hll_global $P5316, "GLOBAL"
    nqp_get_package_through_who $P5317, $P5316, "PAST"
    get_who $P5318, $P5317
    set $P5319, $P5318["Var"]
    find_lex $P5320, "$name"
    unless_null $P5320, vivify_2473
    new $P5320, "Undef"
  vivify_2473:
.annotate 'line', 1869
    find_lex $P5321, "$sigil"
    unless_null $P5321, vivify_2474
    new $P5321, "Undef"
  vivify_2474:
    $P5322 = "vivitype"($P5321)
    find_lex $P5323, "$/"
    unless_null $P5323, vivify_2475
    new $P5323, "Undef"
  vivify_2475:
    $P5324 = $P5319."new"($P5320 :named("name"), "lexical" :named("scope"), 1 :named("isdecl"), 1 :named("lvalue"), $P5322 :named("viviself"), $P5323 :named("node"))
.annotate 'line', 1867
    $P5315."push"($P5324)
.annotate 'line', 1872
    find_lex $P5325, "$BLOCK"
    unless_null $P5325, vivify_2476
    new $P5325, "Undef"
  vivify_2476:
    find_lex $P5326, "$name"
    unless_null $P5326, vivify_2477
    new $P5326, "Undef"
  vivify_2477:
    $P5325."symbol"($P5326, "lexical" :named("scope"))
.annotate 'line', 1866
    goto if_5295_end
  if_5295:
.annotate 'line', 1861
    find_lex $P5301, "$/"
    unless_null $P5301, vivify_2478
    $P5301 = root_new ['parrot';'Hash']
  vivify_2478:
    set $P5302, $P5301["variable"]
    unless_null $P5302, vivify_2479
    new $P5302, "Undef"
  vivify_2479:
    set $S5303, $P5302
    new $P5304, 'String'
    set $P5304, $S5303
    store_lex "$name", $P5304
.annotate 'line', 1862
    find_lex $P5305, "$name"
    unless_null $P5305, vivify_2480
    new $P5305, "Undef"
  vivify_2480:
    new $P5306, "ResizablePMCArray"
    push $P5306, $P5305
    find_lex $P5307, "$/"
    unless_null $P5307, vivify_2481
    new $P5307, "Undef"
  vivify_2481:
    $P5308 = "lexical_package_lookup"($P5306, $P5307)
    store_lex "$past", $P5308
.annotate 'line', 1863
    find_lex $P5309, "$past"
    unless_null $P5309, vivify_2482
    new $P5309, "Undef"
  vivify_2482:
    find_lex $P5310, "$sigil"
    unless_null $P5310, vivify_2483
    new $P5310, "Undef"
  vivify_2483:
    $P5311 = "vivitype"($P5310)
    $P5309."viviself"($P5311)
.annotate 'line', 1864
    find_lex $P5312, "$BLOCK"
    unless_null $P5312, vivify_2484
    new $P5312, "Undef"
  vivify_2484:
    find_lex $P5313, "$name"
    unless_null $P5313, vivify_2485
    new $P5313, "Undef"
  vivify_2485:
    $P5312."symbol"($P5313, "package" :named("scope"))
  if_5295_end:
.annotate 'line', 1857
    goto if_5234_end
  if_5234:
.annotate 'line', 1837
    .const 'Sub' $P5241 = "538_1307873304.82979" 
    capture_lex $P5241
    $P5241()
  if_5234_end:
.annotate 'line', 1876
    find_lex $P5327, "$/"
    find_lex $P5328, "$past"
    unless_null $P5328, vivify_2515
    new $P5328, "Undef"
  vivify_2515:
    $P5327."!make"($P5328)
.annotate 'line', 1878
    find_lex $P5331, "$/"
    unless_null $P5331, vivify_2516
    $P5331 = root_new ['parrot';'Hash']
  vivify_2516:
    set $P5332, $P5331["trait"]
    unless_null $P5332, vivify_2517
    new $P5332, "Undef"
  vivify_2517:
    if $P5332, if_5330
    set $P5329, $P5332
    goto if_5330_end
  if_5330:
.annotate 'line', 1879
    find_lex $P5334, "$/"
    unless_null $P5334, vivify_2518
    $P5334 = root_new ['parrot';'Hash']
  vivify_2518:
    set $P5335, $P5334["trait"]
    unless_null $P5335, vivify_2519
    new $P5335, "Undef"
  vivify_2519:
    defined $I5336, $P5335
    unless $I5336, for_undef_2520
    iter $P5333, $P5335
    new $P5346, 'ExceptionHandler'
    set_label $P5346, loop5345_handler
    $P5346."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5346
  loop5345_test:
    unless $P5333, loop5345_done
    shift $P5337, $P5333
  loop5345_redo:
    .const 'Sub' $P5339 = "539_1307873304.82979" 
    capture_lex $P5339
    $P5339($P5337)
  loop5345_next:
    goto loop5345_test
  loop5345_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5347, exception, 'type'
    eq $P5347, .CONTROL_LOOP_NEXT, loop5345_next
    eq $P5347, .CONTROL_LOOP_REDO, loop5345_redo
  loop5345_done:
    pop_eh 
  for_undef_2520:
.annotate 'line', 1878
    set $P5329, $P5333
  if_5330_end:
.annotate 'line', 1829
    .return ($P5329)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5240"  :anon :subid("538_1307873304.82979") :outer("537_1307873304.82979")
.annotate 'line', 1844
    $P5242 = root_new ['parrot';'Hash']
    .lex "%lit_args", $P5242
.annotate 'line', 1845
    $P5243 = root_new ['parrot';'Hash']
    .lex "%obj_args", $P5243
.annotate 'line', 1839
    find_dynamic_lex $P5250, "$*PKGDECL"
    unless_null $P5250, vivify_2486
    get_hll_global $P5248, "GLOBAL"
    get_who $P5249, $P5248
    set $P5250, $P5249["$PKGDECL"]
    unless_null $P5250, vivify_2487
    die "Contextual $*PKGDECL not found"
  vivify_2487:
  vivify_2486:
    concat $P5251, $P5250, "-attr"
    find_dynamic_lex $P5247, "%*HOW"
    unless_null $P5247, vivify_2488
    get_hll_global $P5245, "GLOBAL"
    get_who $P5246, $P5245
    set $P5247, $P5246["%HOW"]
    unless_null $P5247, vivify_2489
    die "Contextual %*HOW not found"
  vivify_2489:
  vivify_2488:
    exists $I5252, $P5247[$P5251]
    if $I5252, unless_5244_end
.annotate 'line', 1840
    find_lex $P5253, "$/"
    unless_null $P5253, vivify_2490
    new $P5253, "Undef"
  vivify_2490:
    $P5254 = $P5253."CURSOR"()
    find_dynamic_lex $P5257, "$*PKGDECL"
    unless_null $P5257, vivify_2491
    get_hll_global $P5255, "GLOBAL"
    get_who $P5256, $P5255
    set $P5257, $P5256["$PKGDECL"]
    unless_null $P5257, vivify_2492
    die "Contextual $*PKGDECL not found"
  vivify_2492:
  vivify_2491:
    concat $P5258, $P5257, " packages do not support attributes"
    $P5254."panic"($P5258)
  unless_5244_end:
.annotate 'line', 1839
    find_lex $P5259, "%lit_args"
    unless_null $P5259, vivify_2493
    $P5259 = root_new ['parrot';'Hash']
  vivify_2493:
    find_lex $P5260, "%obj_args"
    unless_null $P5260, vivify_2494
    $P5260 = root_new ['parrot';'Hash']
  vivify_2494:
.annotate 'line', 1846
    find_lex $P5261, "$name"
    unless_null $P5261, vivify_2495
    new $P5261, "Undef"
  vivify_2495:
    find_lex $P5262, "%lit_args"
    unless_null $P5262, vivify_2496
    $P5262 = root_new ['parrot';'Hash']
    store_lex "%lit_args", $P5262
  vivify_2496:
    set $P5262["name"], $P5261
.annotate 'line', 1847
    find_lex $P5264, "$/"
    unless_null $P5264, vivify_2497
    $P5264 = root_new ['parrot';'Hash']
  vivify_2497:
    set $P5265, $P5264["typename"]
    unless_null $P5265, vivify_2498
    new $P5265, "Undef"
  vivify_2498:
    unless $P5265, if_5263_end
.annotate 'line', 1848
    find_lex $P5266, "$/"
    unless_null $P5266, vivify_2499
    $P5266 = root_new ['parrot';'Hash']
  vivify_2499:
    set $P5267, $P5266["typename"]
    unless_null $P5267, vivify_2500
    $P5267 = root_new ['parrot';'ResizablePMCArray']
  vivify_2500:
    set $P5268, $P5267[0]
    unless_null $P5268, vivify_2501
    new $P5268, "Undef"
  vivify_2501:
    set $S5269, $P5268
    new $P5270, "ResizablePMCArray"
    push $P5270, $S5269
    find_lex $P5271, "$/"
    unless_null $P5271, vivify_2502
    new $P5271, "Undef"
  vivify_2502:
    $P5272 = "find_sym"($P5270, $P5271)
    find_lex $P5273, "%obj_args"
    unless_null $P5273, vivify_2503
    $P5273 = root_new ['parrot';'Hash']
    store_lex "%obj_args", $P5273
  vivify_2503:
    set $P5273["type"], $P5272
  if_5263_end:
.annotate 'line', 1852
    find_dynamic_lex $P5276, "$*SC"
    unless_null $P5276, vivify_2504
    get_hll_global $P5274, "GLOBAL"
    get_who $P5275, $P5274
    set $P5276, $P5275["$SC"]
    unless_null $P5276, vivify_2505
    die "Contextual $*SC not found"
  vivify_2505:
  vivify_2504:
    find_dynamic_lex $P5279, "$*PACKAGE"
    unless_null $P5279, vivify_2506
    get_hll_global $P5277, "GLOBAL"
    get_who $P5278, $P5277
    set $P5279, $P5278["$PACKAGE"]
    unless_null $P5279, vivify_2507
    die "Contextual $*PACKAGE not found"
  vivify_2507:
  vivify_2506:
    find_dynamic_lex $P5282, "$*PKGDECL"
    unless_null $P5282, vivify_2508
    get_hll_global $P5280, "GLOBAL"
    get_who $P5281, $P5280
    set $P5282, $P5281["$PKGDECL"]
    unless_null $P5282, vivify_2509
    die "Contextual $*PKGDECL not found"
  vivify_2509:
  vivify_2508:
    concat $P5283, $P5282, "-attr"
    find_dynamic_lex $P5286, "%*HOW"
    unless_null $P5286, vivify_2510
    get_hll_global $P5284, "GLOBAL"
    get_who $P5285, $P5284
    set $P5286, $P5285["%HOW"]
    unless_null $P5286, vivify_2511
    die "Contextual %*HOW not found"
  vivify_2511:
  vivify_2510:
    set $P5287, $P5286[$P5283]
    unless_null $P5287, vivify_2512
    new $P5287, "Undef"
  vivify_2512:
    find_lex $P5288, "%lit_args"
    unless_null $P5288, vivify_2513
    $P5288 = root_new ['parrot';'Hash']
  vivify_2513:
    find_lex $P5289, "%obj_args"
    unless_null $P5289, vivify_2514
    $P5289 = root_new ['parrot';'Hash']
  vivify_2514:
    $P5276."pkg_add_attribute"($P5279, $P5287, $P5288, $P5289)
.annotate 'line', 1855
    get_hll_global $P5290, "GLOBAL"
    nqp_get_package_through_who $P5291, $P5290, "PAST"
    get_who $P5292, $P5291
    set $P5293, $P5292["Stmts"]
    $P5294 = $P5293."new"()
    store_lex "$past", $P5294
.annotate 'line', 1837
    .return ($P5294)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5338"  :anon :subid("539_1307873304.82979") :outer("537_1307873304.82979")
    .param pmc param_5340
.annotate 'line', 1879
    .lex "$_", param_5340
    find_lex $P5341, "$_"
    unless_null $P5341, vivify_2521
    new $P5341, "Undef"
  vivify_2521:
    $P5342 = $P5341."ast"()
    find_lex $P5343, "$/"
    unless_null $P5343, vivify_2522
    new $P5343, "Undef"
  vivify_2522:
    $P5344 = $P5342($P5343)
    .return ($P5344)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<sub>" :anon :subid("540_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_5349
    .param pmc param_5350
.annotate 'line', 1884
    .lex "self", param_5349
    .lex "$/", param_5350
    find_lex $P5351, "$/"
    find_lex $P5352, "$/"
    unless_null $P5352, vivify_2523
    $P5352 = root_new ['parrot';'Hash']
  vivify_2523:
    set $P5353, $P5352["routine_def"]
    unless_null $P5353, vivify_2524
    new $P5353, "Undef"
  vivify_2524:
    $P5354 = $P5353."ast"()
    $P5355 = $P5351."!make"($P5354)
    .return ($P5355)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<method>" :anon :subid("541_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_5357
    .param pmc param_5358
.annotate 'line', 1885
    .lex "self", param_5357
    .lex "$/", param_5358
    find_lex $P5359, "$/"
    find_lex $P5360, "$/"
    unless_null $P5360, vivify_2525
    $P5360 = root_new ['parrot';'Hash']
  vivify_2525:
    set $P5361, $P5360["method_def"]
    unless_null $P5361, vivify_2526
    new $P5361, "Undef"
  vivify_2526:
    $P5362 = $P5361."ast"()
    $P5363 = $P5359."!make"($P5362)
    .return ($P5363)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "routine_def" :anon :subid("542_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_5365
    .param pmc param_5366
.annotate 'line', 1887
    .const 'Sub' $P5679 = "548_1307873304.82979" 
    capture_lex $P5679
    .const 'Sub' $P5388 = "543_1307873304.82979" 
    capture_lex $P5388
    .lex "self", param_5365
    .lex "$/", param_5366
.annotate 'line', 1890
    new $P5367, "Undef"
    .lex "$past", $P5367
.annotate 'line', 1901
    new $P5368, "Undef"
    .lex "$block", $P5368
.annotate 'line', 1887
    find_lex $P5369, "$past"
    unless_null $P5369, vivify_2527
    new $P5369, "Undef"
  vivify_2527:
.annotate 'line', 1891
    find_lex $P5371, "$/"
    unless_null $P5371, vivify_2528
    $P5371 = root_new ['parrot';'Hash']
  vivify_2528:
    set $P5372, $P5371["onlystar"]
    unless_null $P5372, vivify_2529
    new $P5372, "Undef"
  vivify_2529:
    if $P5372, if_5370
.annotate 'line', 1895
    find_lex $P5374, "$/"
    unless_null $P5374, vivify_2530
    $P5374 = root_new ['parrot';'Hash']
  vivify_2530:
    set $P5375, $P5374["blockoid"]
    unless_null $P5375, vivify_2531
    new $P5375, "Undef"
  vivify_2531:
    $P5376 = $P5375."ast"()
    store_lex "$past", $P5376
.annotate 'line', 1896
    find_lex $P5377, "$past"
    unless_null $P5377, vivify_2532
    new $P5377, "Undef"
  vivify_2532:
    $P5377."blocktype"("declaration")
.annotate 'line', 1897
    find_dynamic_lex $P5381, "$*RETURN_USED"
    unless_null $P5381, vivify_2533
    get_hll_global $P5379, "GLOBAL"
    get_who $P5380, $P5379
    set $P5381, $P5380["$RETURN_USED"]
    unless_null $P5381, vivify_2534
    die "Contextual $*RETURN_USED not found"
  vivify_2534:
  vivify_2533:
    unless $P5381, if_5378_end
.annotate 'line', 1898
    find_lex $P5382, "$past"
    unless_null $P5382, vivify_2535
    new $P5382, "Undef"
  vivify_2535:
    $P5382."control"("return_pir")
  if_5378_end:
.annotate 'line', 1894
    goto if_5370_end
  if_5370:
.annotate 'line', 1892
    $P5373 = "only_star_block"()
    store_lex "$past", $P5373
  if_5370_end:
.annotate 'line', 1901
    find_lex $P5383, "$past"
    unless_null $P5383, vivify_2536
    new $P5383, "Undef"
  vivify_2536:
    store_lex "$block", $P5383
.annotate 'line', 1903
    find_lex $P5385, "$/"
    unless_null $P5385, vivify_2537
    $P5385 = root_new ['parrot';'Hash']
  vivify_2537:
    set $P5386, $P5385["deflongname"]
    unless_null $P5386, vivify_2538
    new $P5386, "Undef"
  vivify_2538:
    unless $P5386, if_5384_end
    .const 'Sub' $P5388 = "543_1307873304.82979" 
    capture_lex $P5388
    $P5388()
  if_5384_end:
.annotate 'line', 2004
    find_lex $P5668, "$block"
    unless_null $P5668, vivify_2644
    new $P5668, "Undef"
  vivify_2644:
    find_lex $P5669, "$past"
    unless_null $P5669, vivify_2645
    $P5669 = root_new ['parrot';'Hash']
    store_lex "$past", $P5669
  vivify_2645:
    set $P5669["block_past"], $P5668
.annotate 'line', 2005
    find_lex $P5671, "$/"
    unless_null $P5671, vivify_2646
    $P5671 = root_new ['parrot';'Hash']
  vivify_2646:
    set $P5672, $P5671["trait"]
    unless_null $P5672, vivify_2647
    new $P5672, "Undef"
  vivify_2647:
    unless $P5672, if_5670_end
.annotate 'line', 2006
    find_lex $P5674, "$/"
    unless_null $P5674, vivify_2648
    $P5674 = root_new ['parrot';'Hash']
  vivify_2648:
    set $P5675, $P5674["trait"]
    unless_null $P5675, vivify_2649
    new $P5675, "Undef"
  vivify_2649:
    defined $I5676, $P5675
    unless $I5676, for_undef_2650
    iter $P5673, $P5675
    new $P5686, 'ExceptionHandler'
    set_label $P5686, loop5685_handler
    $P5686."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5686
  loop5685_test:
    unless $P5673, loop5685_done
    shift $P5677, $P5673
  loop5685_redo:
    .const 'Sub' $P5679 = "548_1307873304.82979" 
    capture_lex $P5679
    $P5679($P5677)
  loop5685_next:
    goto loop5685_test
  loop5685_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5687, exception, 'type'
    eq $P5687, .CONTROL_LOOP_NEXT, loop5685_next
    eq $P5687, .CONTROL_LOOP_REDO, loop5685_redo
  loop5685_done:
    pop_eh 
  for_undef_2650:
  if_5670_end:
.annotate 'line', 2009
    find_lex $P5688, "$/"
    find_lex $P5689, "$past"
    unless_null $P5689, vivify_2653
    new $P5689, "Undef"
  vivify_2653:
    $P5690 = $P5688."!make"($P5689)
.annotate 'line', 1887
    .return ($P5690)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5387"  :anon :subid("543_1307873304.82979") :outer("542_1307873304.82979")
.annotate 'line', 1903
    .const 'Sub' $P5542 = "547_1307873304.82979" 
    capture_lex $P5542
    .const 'Sub' $P5429 = "544_1307873304.82979" 
    capture_lex $P5429
.annotate 'line', 1904
    new $P5389, "Undef"
    .lex "$name", $P5389
    find_lex $P5390, "$/"
    unless_null $P5390, vivify_2539
    $P5390 = root_new ['parrot';'Hash']
  vivify_2539:
    set $P5391, $P5390["sigil"]
    unless_null $P5391, vivify_2540
    $P5391 = root_new ['parrot';'ResizablePMCArray']
  vivify_2540:
    set $P5392, $P5391[0]
    unless_null $P5392, vivify_2541
    new $P5392, "Undef"
  vivify_2541:
    set $S5393, $P5392
    new $P5394, 'String'
    set $P5394, $S5393
    find_lex $P5395, "$/"
    unless_null $P5395, vivify_2542
    $P5395 = root_new ['parrot';'Hash']
  vivify_2542:
    set $P5396, $P5395["deflongname"]
    unless_null $P5396, vivify_2543
    $P5396 = root_new ['parrot';'ResizablePMCArray']
  vivify_2543:
    set $P5397, $P5396[0]
    unless_null $P5397, vivify_2544
    new $P5397, "Undef"
  vivify_2544:
    $S5398 = $P5397."ast"()
    concat $P5399, $P5394, $S5398
    store_lex "$name", $P5399
.annotate 'line', 1905
    find_lex $P5400, "$past"
    unless_null $P5400, vivify_2545
    new $P5400, "Undef"
  vivify_2545:
    find_lex $P5401, "$name"
    unless_null $P5401, vivify_2546
    new $P5401, "Undef"
  vivify_2546:
    $P5400."name"($P5401)
.annotate 'line', 1906
    find_dynamic_lex $P5409, "$*SCOPE"
    unless_null $P5409, vivify_2547
    get_hll_global $P5407, "GLOBAL"
    get_who $P5408, $P5407
    set $P5409, $P5408["$SCOPE"]
    unless_null $P5409, vivify_2548
    die "Contextual $*SCOPE not found"
  vivify_2548:
  vivify_2547:
    set $S5410, $P5409
    iseq $I5411, $S5410, ""
    unless $I5411, unless_5406
    new $P5405, 'Integer'
    set $P5405, $I5411
    goto unless_5406_end
  unless_5406:
    find_dynamic_lex $P5414, "$*SCOPE"
    unless_null $P5414, vivify_2549
    get_hll_global $P5412, "GLOBAL"
    get_who $P5413, $P5412
    set $P5414, $P5413["$SCOPE"]
    unless_null $P5414, vivify_2550
    die "Contextual $*SCOPE not found"
  vivify_2550:
  vivify_2549:
    set $S5415, $P5414
    iseq $I5416, $S5415, "my"
    new $P5405, 'Integer'
    set $P5405, $I5416
  unless_5406_end:
    unless $P5405, unless_5404
    set $P5403, $P5405
    goto unless_5404_end
  unless_5404:
    find_dynamic_lex $P5419, "$*SCOPE"
    unless_null $P5419, vivify_2551
    get_hll_global $P5417, "GLOBAL"
    get_who $P5418, $P5417
    set $P5419, $P5418["$SCOPE"]
    unless_null $P5419, vivify_2552
    die "Contextual $*SCOPE not found"
  vivify_2552:
  vivify_2551:
    set $S5420, $P5419
    iseq $I5421, $S5420, "our"
    new $P5403, 'Integer'
    set $P5403, $I5421
  unless_5404_end:
    if $P5403, if_5402
.annotate 'line', 1994
    find_lex $P5649, "$/"
    unless_null $P5649, vivify_2553
    new $P5649, "Undef"
  vivify_2553:
    $P5650 = $P5649."CURSOR"()
    find_dynamic_lex $P5653, "$*SCOPE"
    unless_null $P5653, vivify_2554
    get_hll_global $P5651, "GLOBAL"
    get_who $P5652, $P5651
    set $P5653, $P5652["$SCOPE"]
    unless_null $P5653, vivify_2555
    die "Contextual $*SCOPE not found"
  vivify_2555:
  vivify_2554:
    concat $P5654, $P5653, " scoped routines are not supported yet"
    $P5650."panic"($P5654)
.annotate 'line', 1993
    goto if_5402_end
  if_5402:
.annotate 'line', 1907
    find_dynamic_lex $P5425, "$*MULTINESS"
    unless_null $P5425, vivify_2556
    get_hll_global $P5423, "GLOBAL"
    get_who $P5424, $P5423
    set $P5425, $P5424["$MULTINESS"]
    unless_null $P5425, vivify_2557
    die "Contextual $*MULTINESS not found"
  vivify_2557:
  vivify_2556:
    set $S5426, $P5425
    iseq $I5427, $S5426, "multi"
    if $I5427, if_5422
.annotate 'line', 1958
    find_dynamic_lex $P5538, "$*MULTINESS"
    unless_null $P5538, vivify_2558
    get_hll_global $P5536, "GLOBAL"
    get_who $P5537, $P5536
    set $P5538, $P5537["$MULTINESS"]
    unless_null $P5538, vivify_2559
    die "Contextual $*MULTINESS not found"
  vivify_2559:
  vivify_2558:
    set $S5539, $P5538
    iseq $I5540, $S5539, "proto"
    if $I5540, if_5535
.annotate 'line', 1977
    find_lex $P5592, "$?PACKAGE"
    get_who $P5593, $P5592
    set $P5594, $P5593["@BLOCK"]
    unless_null $P5594, vivify_2560
    $P5594 = root_new ['parrot';'ResizablePMCArray']
  vivify_2560:
    set $P5595, $P5594[0]
    unless_null $P5595, vivify_2561
    $P5595 = root_new ['parrot';'ResizablePMCArray']
  vivify_2561:
    set $P5596, $P5595[0]
    unless_null $P5596, vivify_2562
    new $P5596, "Undef"
  vivify_2562:
    get_hll_global $P5597, "GLOBAL"
    nqp_get_package_through_who $P5598, $P5597, "PAST"
    get_who $P5599, $P5598
    set $P5600, $P5599["Var"]
    find_lex $P5601, "$name"
    unless_null $P5601, vivify_2563
    new $P5601, "Undef"
  vivify_2563:
    find_lex $P5602, "$past"
    unless_null $P5602, vivify_2564
    new $P5602, "Undef"
  vivify_2564:
    $P5603 = $P5600."new"($P5601 :named("name"), 1 :named("isdecl"), $P5602 :named("viviself"), "lexical" :named("scope"))
    $P5596."push"($P5603)
.annotate 'line', 1979
    find_lex $P5604, "$?PACKAGE"
    get_who $P5605, $P5604
    set $P5606, $P5605["@BLOCK"]
    unless_null $P5606, vivify_2565
    $P5606 = root_new ['parrot';'ResizablePMCArray']
  vivify_2565:
    set $P5607, $P5606[0]
    unless_null $P5607, vivify_2566
    new $P5607, "Undef"
  vivify_2566:
    find_lex $P5608, "$name"
    unless_null $P5608, vivify_2567
    new $P5608, "Undef"
  vivify_2567:
    $P5607."symbol"($P5608, "lexical" :named("scope"))
.annotate 'line', 1980
    find_dynamic_lex $P5612, "$*SCOPE"
    unless_null $P5612, vivify_2568
    get_hll_global $P5610, "GLOBAL"
    get_who $P5611, $P5610
    set $P5612, $P5611["$SCOPE"]
    unless_null $P5612, vivify_2569
    die "Contextual $*SCOPE not found"
  vivify_2569:
  vivify_2568:
    set $S5613, $P5612
    iseq $I5614, $S5613, "our"
    unless $I5614, if_5609_end
.annotate 'line', 1983
    find_dynamic_lex $P5617, "$*SC"
    unless_null $P5617, vivify_2570
    get_hll_global $P5615, "GLOBAL"
    get_who $P5616, $P5615
    set $P5617, $P5616["$SC"]
    unless_null $P5617, vivify_2571
    die "Contextual $*SC not found"
  vivify_2571:
  vivify_2570:
    find_dynamic_lex $P5620, "$*PACKAGE"
    unless_null $P5620, vivify_2572
    get_hll_global $P5618, "GLOBAL"
    get_who $P5619, $P5618
    set $P5620, $P5619["$PACKAGE"]
    unless_null $P5620, vivify_2573
    die "Contextual $*PACKAGE not found"
  vivify_2573:
  vivify_2572:
    find_lex $P5621, "$name"
    unless_null $P5621, vivify_2574
    new $P5621, "Undef"
  vivify_2574:
    find_lex $P5622, "$past"
    unless_null $P5622, vivify_2575
    new $P5622, "Undef"
  vivify_2575:
    $P5617."install_package_routine"($P5620, $P5621, $P5622)
.annotate 'line', 1984
    find_lex $P5623, "$?PACKAGE"
    get_who $P5624, $P5623
    set $P5625, $P5624["@BLOCK"]
    unless_null $P5625, vivify_2576
    $P5625 = root_new ['parrot';'ResizablePMCArray']
  vivify_2576:
    set $P5626, $P5625[0]
    unless_null $P5626, vivify_2577
    $P5626 = root_new ['parrot';'ResizablePMCArray']
  vivify_2577:
    set $P5627, $P5626[0]
    unless_null $P5627, vivify_2578
    new $P5627, "Undef"
  vivify_2578:
    get_hll_global $P5628, "GLOBAL"
    nqp_get_package_through_who $P5629, $P5628, "PAST"
    get_who $P5630, $P5629
    set $P5631, $P5630["Op"]
.annotate 'line', 1986
    find_lex $P5632, "$name"
    unless_null $P5632, vivify_2579
    new $P5632, "Undef"
  vivify_2579:
    new $P5633, "ResizablePMCArray"
    push $P5633, $P5632
    find_lex $P5634, "$/"
    unless_null $P5634, vivify_2580
    new $P5634, "Undef"
  vivify_2580:
    $P5635 = "lexical_package_lookup"($P5633, $P5634)
.annotate 'line', 1987
    get_hll_global $P5636, "GLOBAL"
    nqp_get_package_through_who $P5637, $P5636, "PAST"
    get_who $P5638, $P5637
    set $P5639, $P5638["Var"]
    find_lex $P5640, "$name"
    unless_null $P5640, vivify_2581
    new $P5640, "Undef"
  vivify_2581:
    $P5641 = $P5639."new"($P5640 :named("name"), "lexical" :named("scope"))
    $P5642 = $P5631."new"($P5635, $P5641, "bind_6model" :named("pasttype"))
.annotate 'line', 1984
    $P5627."push"($P5642)
  if_5609_end:
.annotate 'line', 1976
    goto if_5535_end
  if_5535:
.annotate 'line', 1958
    .const 'Sub' $P5542 = "547_1307873304.82979" 
    capture_lex $P5542
    $P5542()
  if_5535_end:
    goto if_5422_end
  if_5422:
.annotate 'line', 1907
    .const 'Sub' $P5429 = "544_1307873304.82979" 
    capture_lex $P5429
    $P5429()
  if_5422_end:
.annotate 'line', 1991
    get_hll_global $P5643, "GLOBAL"
    nqp_get_package_through_who $P5644, $P5643, "PAST"
    get_who $P5645, $P5644
    set $P5646, $P5645["Var"]
    find_lex $P5647, "$name"
    unless_null $P5647, vivify_2639
    new $P5647, "Undef"
  vivify_2639:
    $P5648 = $P5646."new"($P5647 :named("name"))
    store_lex "$past", $P5648
  if_5402_end:
.annotate 'line', 1998
    find_lex $P5659, "$name"
    unless_null $P5659, vivify_2640
    new $P5659, "Undef"
  vivify_2640:
    set $S5660, $P5659
    iseq $I5661, $S5660, "MAIN"
    if $I5661, if_5658
    new $P5657, 'Integer'
    set $P5657, $I5661
    goto if_5658_end
  if_5658:
    find_dynamic_lex $P5664, "$*MULTINESS"
    unless_null $P5664, vivify_2641
    get_hll_global $P5662, "GLOBAL"
    get_who $P5663, $P5662
    set $P5664, $P5663["$MULTINESS"]
    unless_null $P5664, vivify_2642
    die "Contextual $*MULTINESS not found"
  vivify_2642:
  vivify_2641:
    set $S5665, $P5664
    isne $I5666, $S5665, "multi"
    new $P5657, 'Integer'
    set $P5657, $I5666
  if_5658_end:
    if $P5657, if_5656
    set $P5655, $P5657
    goto if_5656_end
  if_5656:
.annotate 'line', 1999
    find_lex $P5667, "$block"
    unless_null $P5667, vivify_2643
    new $P5667, "Undef"
  vivify_2643:
    store_dynamic_lex "$*MAIN_SUB", $P5667
.annotate 'line', 1998
    set $P5655, $P5667
  if_5656_end:
.annotate 'line', 1903
    .return ($P5655)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5541"  :anon :subid("547_1307873304.82979") :outer("543_1307873304.82979")
.annotate 'line', 1963
    new $P5543, "Undef"
    .lex "$cholder", $P5543
.annotate 'line', 1962
    find_dynamic_lex $P5547, "$*SCOPE"
    unless_null $P5547, vivify_2582
    get_hll_global $P5545, "GLOBAL"
    get_who $P5546, $P5545
    set $P5547, $P5546["$SCOPE"]
    unless_null $P5547, vivify_2583
    die "Contextual $*SCOPE not found"
  vivify_2583:
  vivify_2582:
    set $S5548, $P5547
    iseq $I5549, $S5548, "our"
    unless $I5549, if_5544_end
    die "our-scoped protos not yet implemented"
  if_5544_end:
.annotate 'line', 1963
    get_hll_global $P5550, "GLOBAL"
    nqp_get_package_through_who $P5551, $P5550, "PAST"
    get_who $P5552, $P5551
    set $P5553, $P5552["Op"]
    $P5554 = $P5553."new"("list" :named("pasttype"))
    store_lex "$cholder", $P5554
.annotate 'line', 1964
    find_lex $P5555, "$?PACKAGE"
    get_who $P5556, $P5555
    set $P5557, $P5556["@BLOCK"]
    unless_null $P5557, vivify_2584
    $P5557 = root_new ['parrot';'ResizablePMCArray']
  vivify_2584:
    set $P5558, $P5557[0]
    unless_null $P5558, vivify_2585
    $P5558 = root_new ['parrot';'ResizablePMCArray']
  vivify_2585:
    set $P5559, $P5558[0]
    unless_null $P5559, vivify_2586
    new $P5559, "Undef"
  vivify_2586:
    get_hll_global $P5560, "GLOBAL"
    nqp_get_package_through_who $P5561, $P5560, "PAST"
    get_who $P5562, $P5561
    set $P5563, $P5562["Var"]
    find_lex $P5564, "$name"
    unless_null $P5564, vivify_2587
    new $P5564, "Undef"
  vivify_2587:
    find_lex $P5565, "$past"
    unless_null $P5565, vivify_2588
    new $P5565, "Undef"
  vivify_2588:
    $P5566 = $P5563."new"($P5564 :named("name"), 1 :named("isdecl"), $P5565 :named("viviself"), "lexical" :named("scope"))
    $P5559."push"($P5566)
.annotate 'line', 1966
    find_lex $P5567, "$?PACKAGE"
    get_who $P5568, $P5567
    set $P5569, $P5568["@BLOCK"]
    unless_null $P5569, vivify_2589
    $P5569 = root_new ['parrot';'ResizablePMCArray']
  vivify_2589:
    set $P5570, $P5569[0]
    unless_null $P5570, vivify_2590
    $P5570 = root_new ['parrot';'ResizablePMCArray']
  vivify_2590:
    set $P5571, $P5570[0]
    unless_null $P5571, vivify_2591
    new $P5571, "Undef"
  vivify_2591:
    get_hll_global $P5572, "GLOBAL"
    nqp_get_package_through_who $P5573, $P5572, "PAST"
    get_who $P5574, $P5573
    set $P5575, $P5574["Op"]
.annotate 'line', 1968
    get_hll_global $P5576, "GLOBAL"
    nqp_get_package_through_who $P5577, $P5576, "PAST"
    get_who $P5578, $P5577
    set $P5579, $P5578["Var"]
    find_lex $P5580, "$name"
    unless_null $P5580, vivify_2592
    new $P5580, "Undef"
  vivify_2592:
    $P5581 = $P5579."new"($P5580 :named("name"))
    find_lex $P5582, "$cholder"
    unless_null $P5582, vivify_2593
    new $P5582, "Undef"
  vivify_2593:
    $P5583 = $P5575."new"($P5581, $P5582, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 1966
    $P5571."push"($P5583)
.annotate 'line', 1971
    find_lex $P5584, "$?PACKAGE"
    get_who $P5585, $P5584
    set $P5586, $P5585["@BLOCK"]
    unless_null $P5586, vivify_2594
    $P5586 = root_new ['parrot';'ResizablePMCArray']
  vivify_2594:
    set $P5587, $P5586[0]
    unless_null $P5587, vivify_2595
    new $P5587, "Undef"
  vivify_2595:
    find_lex $P5588, "$name"
    unless_null $P5588, vivify_2596
    new $P5588, "Undef"
  vivify_2596:
    find_lex $P5589, "$cholder"
    unless_null $P5589, vivify_2597
    new $P5589, "Undef"
  vivify_2597:
    $P5587."symbol"($P5588, "lexical" :named("scope"), 1 :named("proto"), $P5589 :named("cholder"))
.annotate 'line', 1974
    find_lex $P5590, "$past"
    unless_null $P5590, vivify_2598
    new $P5590, "Undef"
  vivify_2598:
    $P5591 = $P5590."pirflags"(":instanceof(\"DispatcherSub\")")
.annotate 'line', 1958
    .return ($P5591)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5428"  :anon :subid("544_1307873304.82979") :outer("543_1307873304.82979")
.annotate 'line', 1907
    .const 'Sub' $P5451 = "545_1307873304.82979" 
    capture_lex $P5451
.annotate 'line', 1910
    new $P5430, "Undef"
    .lex "$cholder", $P5430
.annotate 'line', 1911
    $P5431 = root_new ['parrot';'Hash']
    .lex "%sym", $P5431
.annotate 'line', 1909
    find_dynamic_lex $P5435, "$*SCOPE"
    unless_null $P5435, vivify_2599
    get_hll_global $P5433, "GLOBAL"
    get_who $P5434, $P5433
    set $P5435, $P5434["$SCOPE"]
    unless_null $P5435, vivify_2600
    die "Contextual $*SCOPE not found"
  vivify_2600:
  vivify_2599:
    set $S5436, $P5435
    iseq $I5437, $S5436, "our"
    unless $I5437, if_5432_end
    die "our-scoped multis not yet implemented"
  if_5432_end:
    find_lex $P5438, "$cholder"
    unless_null $P5438, vivify_2601
    new $P5438, "Undef"
  vivify_2601:
.annotate 'line', 1911
    find_lex $P5439, "$?PACKAGE"
    get_who $P5440, $P5439
    set $P5441, $P5440["@BLOCK"]
    unless_null $P5441, vivify_2602
    $P5441 = root_new ['parrot';'ResizablePMCArray']
  vivify_2602:
    set $P5442, $P5441[0]
    unless_null $P5442, vivify_2603
    new $P5442, "Undef"
  vivify_2603:
    find_lex $P5443, "$name"
    unless_null $P5443, vivify_2604
    new $P5443, "Undef"
  vivify_2604:
    $P5444 = $P5442."symbol"($P5443)
    store_lex "%sym", $P5444
.annotate 'line', 1912
    find_lex $P5446, "%sym"
    unless_null $P5446, vivify_2605
    $P5446 = root_new ['parrot';'Hash']
  vivify_2605:
    set $P5447, $P5446["cholder"]
    unless_null $P5447, vivify_2606
    new $P5447, "Undef"
  vivify_2606:
    if $P5447, if_5445
.annotate 'line', 1917
    .const 'Sub' $P5451 = "545_1307873304.82979" 
    capture_lex $P5451
    $P5451()
    goto if_5445_end
  if_5445:
.annotate 'line', 1913
    find_lex $P5448, "%sym"
    unless_null $P5448, vivify_2634
    $P5448 = root_new ['parrot';'Hash']
  vivify_2634:
    set $P5449, $P5448["cholder"]
    unless_null $P5449, vivify_2635
    new $P5449, "Undef"
  vivify_2635:
    store_lex "$cholder", $P5449
  if_5445_end:
.annotate 'line', 1953
    find_lex $P5531, "$cholder"
    unless_null $P5531, vivify_2636
    new $P5531, "Undef"
  vivify_2636:
    find_lex $P5532, "$past"
    unless_null $P5532, vivify_2637
    new $P5532, "Undef"
  vivify_2637:
    $P5531."push"($P5532)
.annotate 'line', 1956
    find_lex $P5533, "$past"
    unless_null $P5533, vivify_2638
    new $P5533, "Undef"
  vivify_2638:
    $P5534 = "attach_multi_signature"($P5533)
.annotate 'line', 1907
    .return ($P5534)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block5450"  :anon :subid("545_1307873304.82979") :outer("544_1307873304.82979")
.annotate 'line', 1917
    .const 'Sub' $P5467 = "546_1307873304.82979" 
    capture_lex $P5467
.annotate 'line', 1924
    new $P5452, "Undef"
    .lex "$found_proto", $P5452
.annotate 'line', 1942
    new $P5453, "Undef"
    .lex "$dispatch_setup", $P5453
.annotate 'line', 1919
    find_lex $P5455, "%sym"
    unless_null $P5455, vivify_2607
    $P5455 = root_new ['parrot';'Hash']
  vivify_2607:
    set $P5456, $P5455["proto"]
    unless_null $P5456, vivify_2608
    new $P5456, "Undef"
  vivify_2608:
    unless $P5456, if_5454_end
.annotate 'line', 1922
    find_lex $P5457, "$/"
    unless_null $P5457, vivify_2609
    new $P5457, "Undef"
  vivify_2609:
    $P5458 = $P5457."CURSOR"()
    $P5458."panic"("Internal Error: Current scope has a proto, but no candidate list holder was set up. (This should never happen.)")
  if_5454_end:
.annotate 'line', 1919
    find_lex $P5459, "$found_proto"
    unless_null $P5459, vivify_2610
    new $P5459, "Undef"
  vivify_2610:
.annotate 'line', 1925
    find_lex $P5461, "$?PACKAGE"
    get_who $P5462, $P5461
    set $P5463, $P5462["@BLOCK"]
    unless_null $P5463, vivify_2611
    $P5463 = root_new ['parrot';'ResizablePMCArray']
  vivify_2611:
    defined $I5464, $P5463
    unless $I5464, for_undef_2612
    iter $P5460, $P5463
    new $P5489, 'ExceptionHandler'
    set_label $P5489, loop5488_handler
    $P5489."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5489
  loop5488_test:
    unless $P5460, loop5488_done
    shift $P5465, $P5460
  loop5488_redo:
    .const 'Sub' $P5467 = "546_1307873304.82979" 
    capture_lex $P5467
    $P5467($P5465)
  loop5488_next:
    goto loop5488_test
  loop5488_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5490, exception, 'type'
    eq $P5490, .CONTROL_LOOP_NEXT, loop5488_next
    eq $P5490, .CONTROL_LOOP_REDO, loop5488_redo
  loop5488_done:
    pop_eh 
  for_undef_2612:
.annotate 'line', 1936
    find_lex $P5492, "$found_proto"
    unless_null $P5492, vivify_2621
    new $P5492, "Undef"
  vivify_2621:
    if $P5492, unless_5491_end
.annotate 'line', 1937
    find_lex $P5493, "$/"
    unless_null $P5493, vivify_2622
    new $P5493, "Undef"
  vivify_2622:
    $P5494 = $P5493."CURSOR"()
    $P5494."panic"("Sorry, no proto sub in scope, and auto-generation of protos is not yet implemented.")
  unless_5491_end:
.annotate 'line', 1941
    get_hll_global $P5495, "GLOBAL"
    nqp_get_package_through_who $P5496, $P5495, "PAST"
    get_who $P5497, $P5496
    set $P5498, $P5497["Op"]
    $P5499 = $P5498."new"("list" :named("pasttype"))
    store_lex "$cholder", $P5499
.annotate 'line', 1942
    get_hll_global $P5500, "GLOBAL"
    nqp_get_package_through_who $P5501, $P5500, "PAST"
    get_who $P5502, $P5501
    set $P5503, $P5502["Op"]
.annotate 'line', 1944
    get_hll_global $P5504, "GLOBAL"
    nqp_get_package_through_who $P5505, $P5504, "PAST"
    get_who $P5506, $P5505
    set $P5507, $P5506["Var"]
    find_lex $P5508, "$name"
    unless_null $P5508, vivify_2623
    new $P5508, "Undef"
  vivify_2623:
    $P5509 = $P5507."new"($P5508 :named("name"), "outer" :named("scope"))
    find_lex $P5510, "$cholder"
    unless_null $P5510, vivify_2624
    new $P5510, "Undef"
  vivify_2624:
    $P5511 = $P5503."new"($P5509, $P5510, "create_dispatch_and_add_candidates PPP" :named("pirop"))
.annotate 'line', 1942
    store_lex "$dispatch_setup", $P5511
.annotate 'line', 1947
    find_lex $P5512, "$?PACKAGE"
    get_who $P5513, $P5512
    set $P5514, $P5513["@BLOCK"]
    unless_null $P5514, vivify_2625
    $P5514 = root_new ['parrot';'ResizablePMCArray']
  vivify_2625:
    set $P5515, $P5514[0]
    unless_null $P5515, vivify_2626
    $P5515 = root_new ['parrot';'ResizablePMCArray']
  vivify_2626:
    set $P5516, $P5515[0]
    unless_null $P5516, vivify_2627
    new $P5516, "Undef"
  vivify_2627:
    get_hll_global $P5517, "GLOBAL"
    nqp_get_package_through_who $P5518, $P5517, "PAST"
    get_who $P5519, $P5518
    set $P5520, $P5519["Var"]
    find_lex $P5521, "$name"
    unless_null $P5521, vivify_2628
    new $P5521, "Undef"
  vivify_2628:
    find_lex $P5522, "$dispatch_setup"
    unless_null $P5522, vivify_2629
    new $P5522, "Undef"
  vivify_2629:
    $P5523 = $P5520."new"($P5521 :named("name"), 1 :named("isdecl"), $P5522 :named("viviself"), "lexical" :named("scope"))
    $P5516."push"($P5523)
.annotate 'line', 1949
    find_lex $P5524, "$?PACKAGE"
    get_who $P5525, $P5524
    set $P5526, $P5525["@BLOCK"]
    unless_null $P5526, vivify_2630
    $P5526 = root_new ['parrot';'ResizablePMCArray']
  vivify_2630:
    set $P5527, $P5526[0]
    unless_null $P5527, vivify_2631
    new $P5527, "Undef"
  vivify_2631:
    find_lex $P5528, "$name"
    unless_null $P5528, vivify_2632
    new $P5528, "Undef"
  vivify_2632:
    find_lex $P5529, "$cholder"
    unless_null $P5529, vivify_2633
    new $P5529, "Undef"
  vivify_2633:
    $P5530 = $P5527."symbol"($P5528, "lexical" :named("scope"), $P5529 :named("cholder"))
.annotate 'line', 1917
    .return ($P5530)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5466"  :anon :subid("546_1307873304.82979") :outer("545_1307873304.82979")
    .param pmc param_5469
.annotate 'line', 1926
    $P5468 = root_new ['parrot';'Hash']
    .lex "%sym", $P5468
    .lex "$_", param_5469
    find_lex $P5470, "$_"
    unless_null $P5470, vivify_2613
    new $P5470, "Undef"
  vivify_2613:
    find_lex $P5471, "$name"
    unless_null $P5471, vivify_2614
    new $P5471, "Undef"
  vivify_2614:
    $P5472 = $P5470."symbol"($P5471)
    store_lex "%sym", $P5472
.annotate 'line', 1927
    find_lex $P5477, "%sym"
    unless_null $P5477, vivify_2615
    $P5477 = root_new ['parrot';'Hash']
  vivify_2615:
    set $P5478, $P5477["proto"]
    unless_null $P5478, vivify_2616
    new $P5478, "Undef"
  vivify_2616:
    unless $P5478, unless_5476
    set $P5475, $P5478
    goto unless_5476_end
  unless_5476:
    find_lex $P5479, "%sym"
    unless_null $P5479, vivify_2617
    $P5479 = root_new ['parrot';'Hash']
  vivify_2617:
    set $P5480, $P5479["cholder"]
    unless_null $P5480, vivify_2618
    new $P5480, "Undef"
  vivify_2618:
    set $P5475, $P5480
  unless_5476_end:
    if $P5475, if_5474
.annotate 'line', 1930
    find_lex $P5484, "%sym"
    unless_null $P5484, vivify_2619
    $P5484 = root_new ['parrot';'Hash']
  vivify_2619:
    if $P5484, if_5483
    set $P5482, $P5484
    goto if_5483_end
  if_5483:
.annotate 'line', 1931
    find_lex $P5485, "$/"
    unless_null $P5485, vivify_2620
    new $P5485, "Undef"
  vivify_2620:
    $P5486 = $P5485."CURSOR"()
    $P5487 = $P5486."panic"("Cannot declare a multi when an only is already in scope.")
.annotate 'line', 1930
    set $P5482, $P5487
  if_5483_end:
    set $P5473, $P5482
.annotate 'line', 1927
    goto if_5474_end
  if_5474:
.annotate 'line', 1928
    new $P5481, "Integer"
    assign $P5481, 1
    store_lex "$found_proto", $P5481
.annotate 'line', 1927
    set $P5473, $P5481
  if_5474_end:
.annotate 'line', 1925
    .return ($P5473)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5678"  :anon :subid("548_1307873304.82979") :outer("542_1307873304.82979")
    .param pmc param_5680
.annotate 'line', 2006
    .lex "$_", param_5680
    find_lex $P5681, "$_"
    unless_null $P5681, vivify_2651
    new $P5681, "Undef"
  vivify_2651:
    $P5682 = $P5681."ast"()
    find_lex $P5683, "$/"
    unless_null $P5683, vivify_2652
    new $P5683, "Undef"
  vivify_2652:
    $P5684 = $P5682($P5683)
    .return ($P5684)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "method_def" :anon :subid("549_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_5692
    .param pmc param_5693
.annotate 'line', 2013
    .const 'Sub' $P5822 = "551_1307873304.82979" 
    capture_lex $P5822
    .const 'Sub' $P5731 = "550_1307873304.82979" 
    capture_lex $P5731
    .lex "self", param_5692
    .lex "$/", param_5693
.annotate 'line', 2016
    new $P5694, "Undef"
    .lex "$past", $P5694
.annotate 'line', 2013
    find_lex $P5695, "$past"
    unless_null $P5695, vivify_2654
    new $P5695, "Undef"
  vivify_2654:
.annotate 'line', 2017
    find_lex $P5697, "$/"
    unless_null $P5697, vivify_2655
    $P5697 = root_new ['parrot';'Hash']
  vivify_2655:
    set $P5698, $P5697["onlystar"]
    unless_null $P5698, vivify_2656
    new $P5698, "Undef"
  vivify_2656:
    if $P5698, if_5696
.annotate 'line', 2021
    find_lex $P5700, "$/"
    unless_null $P5700, vivify_2657
    $P5700 = root_new ['parrot';'Hash']
  vivify_2657:
    set $P5701, $P5700["blockoid"]
    unless_null $P5701, vivify_2658
    new $P5701, "Undef"
  vivify_2658:
    $P5702 = $P5701."ast"()
    store_lex "$past", $P5702
.annotate 'line', 2022
    find_lex $P5703, "$past"
    unless_null $P5703, vivify_2659
    new $P5703, "Undef"
  vivify_2659:
    $P5703."blocktype"("declaration")
.annotate 'line', 2023
    find_dynamic_lex $P5707, "$*RETURN_USED"
    unless_null $P5707, vivify_2660
    get_hll_global $P5705, "GLOBAL"
    get_who $P5706, $P5705
    set $P5707, $P5706["$RETURN_USED"]
    unless_null $P5707, vivify_2661
    die "Contextual $*RETURN_USED not found"
  vivify_2661:
  vivify_2660:
    unless $P5707, if_5704_end
.annotate 'line', 2024
    find_lex $P5708, "$past"
    unless_null $P5708, vivify_2662
    new $P5708, "Undef"
  vivify_2662:
    $P5708."control"("return_pir")
  if_5704_end:
.annotate 'line', 2020
    goto if_5696_end
  if_5696:
.annotate 'line', 2018
    $P5699 = "only_star_block"()
    store_lex "$past", $P5699
  if_5696_end:
.annotate 'line', 2029
    find_lex $P5710, "$past"
    unless_null $P5710, vivify_2663
    $P5710 = root_new ['parrot';'Hash']
  vivify_2663:
    set $P5711, $P5710["signature_has_invocant"]
    unless_null $P5711, vivify_2664
    new $P5711, "Undef"
  vivify_2664:
    if $P5711, unless_5709_end
.annotate 'line', 2030
    find_lex $P5712, "$past"
    unless_null $P5712, vivify_2665
    $P5712 = root_new ['parrot';'ResizablePMCArray']
  vivify_2665:
    set $P5713, $P5712[0]
    unless_null $P5713, vivify_2666
    new $P5713, "Undef"
  vivify_2666:
    get_hll_global $P5714, "GLOBAL"
    nqp_get_package_through_who $P5715, $P5714, "PAST"
    get_who $P5716, $P5715
    set $P5717, $P5716["Var"]
.annotate 'line', 2032
    find_dynamic_lex $P5720, "$*SC"
    unless_null $P5720, vivify_2667
    get_hll_global $P5718, "GLOBAL"
    get_who $P5719, $P5718
    set $P5720, $P5719["$SC"]
    unless_null $P5720, vivify_2668
    die "Contextual $*SC not found"
  vivify_2668:
  vivify_2667:
    find_dynamic_lex $P5723, "$*PACKAGE"
    unless_null $P5723, vivify_2669
    get_hll_global $P5721, "GLOBAL"
    get_who $P5722, $P5721
    set $P5723, $P5722["$PACKAGE"]
    unless_null $P5723, vivify_2670
    die "Contextual $*PACKAGE not found"
  vivify_2670:
  vivify_2669:
    $P5724 = $P5720."get_object_sc_ref_past"($P5723)
    $P5725 = $P5717."new"("self" :named("name"), "parameter" :named("scope"), $P5724 :named("multitype"))
.annotate 'line', 2030
    $P5713."unshift"($P5725)
  unless_5709_end:
.annotate 'line', 2035
    find_lex $P5726, "$past"
    unless_null $P5726, vivify_2671
    new $P5726, "Undef"
  vivify_2671:
    $P5726."symbol"("self", "lexical" :named("scope"))
.annotate 'line', 2038
    find_lex $P5728, "$/"
    unless_null $P5728, vivify_2672
    $P5728 = root_new ['parrot';'Hash']
  vivify_2672:
    set $P5729, $P5728["deflongname"]
    unless_null $P5729, vivify_2673
    new $P5729, "Undef"
  vivify_2673:
    unless $P5729, if_5727_end
    .const 'Sub' $P5731 = "550_1307873304.82979" 
    capture_lex $P5731
    $P5731()
  if_5727_end:
.annotate 'line', 2065
    find_lex $P5808, "$/"
    find_lex $P5809, "$past"
    unless_null $P5809, vivify_2708
    new $P5809, "Undef"
  vivify_2708:
    $P5808."!make"($P5809)
.annotate 'line', 2066
    find_lex $P5810, "$past"
    unless_null $P5810, vivify_2709
    new $P5810, "Undef"
  vivify_2709:
    find_lex $P5811, "$past"
    unless_null $P5811, vivify_2710
    $P5811 = root_new ['parrot';'Hash']
    store_lex "$past", $P5811
  vivify_2710:
    set $P5811["block_past"], $P5810
.annotate 'line', 2067
    find_lex $P5814, "$/"
    unless_null $P5814, vivify_2711
    $P5814 = root_new ['parrot';'Hash']
  vivify_2711:
    set $P5815, $P5814["trait"]
    unless_null $P5815, vivify_2712
    new $P5815, "Undef"
  vivify_2712:
    if $P5815, if_5813
    set $P5812, $P5815
    goto if_5813_end
  if_5813:
.annotate 'line', 2068
    find_lex $P5817, "$/"
    unless_null $P5817, vivify_2713
    $P5817 = root_new ['parrot';'Hash']
  vivify_2713:
    set $P5818, $P5817["trait"]
    unless_null $P5818, vivify_2714
    new $P5818, "Undef"
  vivify_2714:
    defined $I5819, $P5818
    unless $I5819, for_undef_2715
    iter $P5816, $P5818
    new $P5829, 'ExceptionHandler'
    set_label $P5829, loop5828_handler
    $P5829."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5829
  loop5828_test:
    unless $P5816, loop5828_done
    shift $P5820, $P5816
  loop5828_redo:
    .const 'Sub' $P5822 = "551_1307873304.82979" 
    capture_lex $P5822
    $P5822($P5820)
  loop5828_next:
    goto loop5828_test
  loop5828_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5830, exception, 'type'
    eq $P5830, .CONTROL_LOOP_NEXT, loop5828_next
    eq $P5830, .CONTROL_LOOP_REDO, loop5828_redo
  loop5828_done:
    pop_eh 
  for_undef_2715:
.annotate 'line', 2067
    set $P5812, $P5816
  if_5813_end:
.annotate 'line', 2013
    .return ($P5812)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5730"  :anon :subid("550_1307873304.82979") :outer("549_1307873304.82979")
.annotate 'line', 2040
    new $P5732, "Undef"
    .lex "$name", $P5732
.annotate 'line', 2048
    new $P5733, "Undef"
    .lex "$meta_meth", $P5733
.annotate 'line', 2049
    new $P5734, "Undef"
    .lex "$is_dispatcher", $P5734
.annotate 'line', 2040
    find_lex $P5735, "$/"
    unless_null $P5735, vivify_2674
    $P5735 = root_new ['parrot';'Hash']
  vivify_2674:
    set $P5736, $P5735["private"]
    unless_null $P5736, vivify_2675
    new $P5736, "Undef"
  vivify_2675:
    set $S5737, $P5736
    new $P5738, 'String'
    set $P5738, $S5737
    find_lex $P5739, "$/"
    unless_null $P5739, vivify_2676
    $P5739 = root_new ['parrot';'Hash']
  vivify_2676:
    set $P5740, $P5739["deflongname"]
    unless_null $P5740, vivify_2677
    $P5740 = root_new ['parrot';'ResizablePMCArray']
  vivify_2677:
    set $P5741, $P5740[0]
    unless_null $P5741, vivify_2678
    new $P5741, "Undef"
  vivify_2678:
    $P5742 = $P5741."ast"()
    set $S5743, $P5742
    concat $P5744, $P5738, $S5743
    store_lex "$name", $P5744
.annotate 'line', 2041
    find_lex $P5745, "$past"
    unless_null $P5745, vivify_2679
    new $P5745, "Undef"
  vivify_2679:
    find_lex $P5746, "$name"
    unless_null $P5746, vivify_2680
    new $P5746, "Undef"
  vivify_2680:
    $P5745."name"($P5746)
.annotate 'line', 2045
    find_dynamic_lex $P5750, "$*MULTINESS"
    unless_null $P5750, vivify_2681
    get_hll_global $P5748, "GLOBAL"
    get_who $P5749, $P5748
    set $P5750, $P5749["$MULTINESS"]
    unless_null $P5750, vivify_2682
    die "Contextual $*MULTINESS not found"
  vivify_2682:
  vivify_2681:
    set $S5751, $P5750
    iseq $I5752, $S5751, "multi"
    unless $I5752, if_5747_end
    find_lex $P5753, "$past"
    unless_null $P5753, vivify_2683
    new $P5753, "Undef"
  vivify_2683:
    "attach_multi_signature"($P5753)
  if_5747_end:
.annotate 'line', 2048
    find_dynamic_lex $P5758, "$*MULTINESS"
    unless_null $P5758, vivify_2684
    get_hll_global $P5756, "GLOBAL"
    get_who $P5757, $P5756
    set $P5758, $P5757["$MULTINESS"]
    unless_null $P5758, vivify_2685
    die "Contextual $*MULTINESS not found"
  vivify_2685:
  vivify_2684:
    set $S5759, $P5758
    iseq $I5760, $S5759, "multi"
    if $I5760, if_5755
    new $P5762, "String"
    assign $P5762, "add_method"
    set $P5754, $P5762
    goto if_5755_end
  if_5755:
    new $P5761, "String"
    assign $P5761, "add_multi_method"
    set $P5754, $P5761
  if_5755_end:
    store_lex "$meta_meth", $P5754
.annotate 'line', 2049
    find_dynamic_lex $P5765, "$*MULTINESS"
    unless_null $P5765, vivify_2686
    get_hll_global $P5763, "GLOBAL"
    get_who $P5764, $P5763
    set $P5765, $P5764["$MULTINESS"]
    unless_null $P5765, vivify_2687
    die "Contextual $*MULTINESS not found"
  vivify_2687:
  vivify_2686:
    set $S5766, $P5765
    iseq $I5767, $S5766, "proto"
    new $P5768, 'Integer'
    set $P5768, $I5767
    store_lex "$is_dispatcher", $P5768
.annotate 'line', 2050
    find_dynamic_lex $P5771, "$*SC"
    unless_null $P5771, vivify_2688
    get_hll_global $P5769, "GLOBAL"
    get_who $P5770, $P5769
    set $P5771, $P5770["$SC"]
    unless_null $P5771, vivify_2689
    die "Contextual $*SC not found"
  vivify_2689:
  vivify_2688:
    find_dynamic_lex $P5774, "$*PACKAGE"
    unless_null $P5774, vivify_2690
    get_hll_global $P5772, "GLOBAL"
    get_who $P5773, $P5772
    set $P5774, $P5773["$PACKAGE"]
    unless_null $P5774, vivify_2691
    die "Contextual $*PACKAGE not found"
  vivify_2691:
  vivify_2690:
    find_lex $P5775, "$meta_meth"
    unless_null $P5775, vivify_2692
    new $P5775, "Undef"
  vivify_2692:
    find_lex $P5776, "$name"
    unless_null $P5776, vivify_2693
    new $P5776, "Undef"
  vivify_2693:
    find_lex $P5777, "$past"
    unless_null $P5777, vivify_2694
    new $P5777, "Undef"
  vivify_2694:
    find_lex $P5778, "$is_dispatcher"
    unless_null $P5778, vivify_2695
    new $P5778, "Undef"
  vivify_2695:
    $P5771."pkg_add_method"($P5774, $P5775, $P5776, $P5777, $P5778)
.annotate 'line', 2053
    find_dynamic_lex $P5783, "$*SCOPE"
    unless_null $P5783, vivify_2696
    get_hll_global $P5781, "GLOBAL"
    get_who $P5782, $P5781
    set $P5783, $P5782["$SCOPE"]
    unless_null $P5783, vivify_2697
    die "Contextual $*SCOPE not found"
  vivify_2697:
  vivify_2696:
    set $S5784, $P5783
    iseq $I5785, $S5784, "our"
    if $I5785, if_5780
.annotate 'line', 2056
    find_lex $P5797, "$past"
    unless_null $P5797, vivify_2698
    new $P5797, "Undef"
  vivify_2698:
    $P5798 = $P5797."pirflags"()
    if $P5798, if_5796
.annotate 'line', 2059
    find_lex $P5806, "$past"
    unless_null $P5806, vivify_2699
    new $P5806, "Undef"
  vivify_2699:
    $P5807 = $P5806."pirflags"(":anon")
.annotate 'line', 2058
    set $P5795, $P5807
.annotate 'line', 2056
    goto if_5796_end
  if_5796:
.annotate 'line', 2057
    find_lex $P5799, "$past"
    unless_null $P5799, vivify_2700
    new $P5799, "Undef"
  vivify_2700:
    find_lex $P5800, "$past"
    unless_null $P5800, vivify_2701
    new $P5800, "Undef"
  vivify_2701:
    $P5801 = $P5800."pirflags"()
    set $S5802, $P5801
    new $P5803, 'String'
    set $P5803, $S5802
    concat $P5804, $P5803, ":anon"
    $P5805 = $P5799."pirflags"($P5804)
.annotate 'line', 2056
    set $P5795, $P5805
  if_5796_end:
.annotate 'line', 2055
    set $P5779, $P5795
.annotate 'line', 2053
    goto if_5780_end
  if_5780:
.annotate 'line', 2054
    find_dynamic_lex $P5788, "$*SC"
    unless_null $P5788, vivify_2702
    get_hll_global $P5786, "GLOBAL"
    get_who $P5787, $P5786
    set $P5788, $P5787["$SC"]
    unless_null $P5788, vivify_2703
    die "Contextual $*SC not found"
  vivify_2703:
  vivify_2702:
    find_dynamic_lex $P5791, "$*PACKAGE"
    unless_null $P5791, vivify_2704
    get_hll_global $P5789, "GLOBAL"
    get_who $P5790, $P5789
    set $P5791, $P5790["$PACKAGE"]
    unless_null $P5791, vivify_2705
    die "Contextual $*PACKAGE not found"
  vivify_2705:
  vivify_2704:
    find_lex $P5792, "$name"
    unless_null $P5792, vivify_2706
    new $P5792, "Undef"
  vivify_2706:
    find_lex $P5793, "$past"
    unless_null $P5793, vivify_2707
    new $P5793, "Undef"
  vivify_2707:
    $P5794 = $P5788."install_package_routine"($P5791, $P5792, $P5793)
.annotate 'line', 2053
    set $P5779, $P5794
  if_5780_end:
.annotate 'line', 2038
    .return ($P5779)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5821"  :anon :subid("551_1307873304.82979") :outer("549_1307873304.82979")
    .param pmc param_5823
.annotate 'line', 2068
    .lex "$_", param_5823
    find_lex $P5824, "$_"
    unless_null $P5824, vivify_2716
    new $P5824, "Undef"
  vivify_2716:
    $P5825 = $P5824."ast"()
    find_lex $P5826, "$/"
    unless_null $P5826, vivify_2717
    new $P5826, "Undef"
  vivify_2717:
    $P5827 = $P5825($P5826)
    .return ($P5827)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "signature" :anon :subid("552_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_5834
    .param pmc param_5835
.annotate 'line', 2097
    .const 'Sub' $P5878 = "554_1307873304.82979" 
    capture_lex $P5878
    .const 'Sub' $P5846 = "553_1307873304.82979" 
    capture_lex $P5846
    .lex "self", param_5834
    .lex "$/", param_5835
.annotate 'line', 2098
    new $P5836, "Undef"
    .lex "$BLOCKINIT", $P5836
    find_lex $P5837, "$?PACKAGE"
    get_who $P5838, $P5837
    set $P5839, $P5838["@BLOCK"]
    unless_null $P5839, vivify_2718
    $P5839 = root_new ['parrot';'ResizablePMCArray']
  vivify_2718:
    set $P5840, $P5839[0]
    unless_null $P5840, vivify_2719
    $P5840 = root_new ['parrot';'ResizablePMCArray']
  vivify_2719:
    set $P5841, $P5840[0]
    unless_null $P5841, vivify_2720
    new $P5841, "Undef"
  vivify_2720:
    store_lex "$BLOCKINIT", $P5841
.annotate 'line', 2099
    find_lex $P5843, "$/"
    unless_null $P5843, vivify_2721
    $P5843 = root_new ['parrot';'Hash']
  vivify_2721:
    set $P5844, $P5843["invocant"]
    unless_null $P5844, vivify_2722
    new $P5844, "Undef"
  vivify_2722:
    unless $P5844, if_5842_end
    .const 'Sub' $P5846 = "553_1307873304.82979" 
    capture_lex $P5846
    $P5846()
  if_5842_end:
.annotate 'line', 2108
    find_lex $P5873, "$/"
    unless_null $P5873, vivify_2732
    $P5873 = root_new ['parrot';'Hash']
  vivify_2732:
    set $P5874, $P5873["parameter"]
    unless_null $P5874, vivify_2733
    new $P5874, "Undef"
  vivify_2733:
    defined $I5875, $P5874
    unless $I5875, for_undef_2734
    iter $P5872, $P5874
    new $P5885, 'ExceptionHandler'
    set_label $P5885, loop5884_handler
    $P5885."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5885
  loop5884_test:
    unless $P5872, loop5884_done
    shift $P5876, $P5872
  loop5884_redo:
    .const 'Sub' $P5878 = "554_1307873304.82979" 
    capture_lex $P5878
    $P5878($P5876)
  loop5884_next:
    goto loop5884_test
  loop5884_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5886, exception, 'type'
    eq $P5886, .CONTROL_LOOP_NEXT, loop5884_next
    eq $P5886, .CONTROL_LOOP_REDO, loop5884_redo
  loop5884_done:
    pop_eh 
  for_undef_2734:
.annotate 'line', 2097
    .return ($P5872)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5845"  :anon :subid("553_1307873304.82979") :outer("552_1307873304.82979")
.annotate 'line', 2100
    new $P5847, "Undef"
    .lex "$inv", $P5847
    find_lex $P5848, "$/"
    unless_null $P5848, vivify_2723
    $P5848 = root_new ['parrot';'Hash']
  vivify_2723:
    set $P5849, $P5848["invocant"]
    unless_null $P5849, vivify_2724
    $P5849 = root_new ['parrot';'ResizablePMCArray']
  vivify_2724:
    set $P5850, $P5849[0]
    unless_null $P5850, vivify_2725
    new $P5850, "Undef"
  vivify_2725:
    $P5851 = $P5850."ast"()
    store_lex "$inv", $P5851
.annotate 'line', 2101
    find_lex $P5852, "$BLOCKINIT"
    unless_null $P5852, vivify_2726
    new $P5852, "Undef"
  vivify_2726:
    find_lex $P5853, "$inv"
    unless_null $P5853, vivify_2727
    new $P5853, "Undef"
  vivify_2727:
    $P5852."push"($P5853)
.annotate 'line', 2102
    find_lex $P5854, "$BLOCKINIT"
    unless_null $P5854, vivify_2728
    new $P5854, "Undef"
  vivify_2728:
    get_hll_global $P5855, "GLOBAL"
    nqp_get_package_through_who $P5856, $P5855, "PAST"
    get_who $P5857, $P5856
    set $P5858, $P5857["Var"]
.annotate 'line', 2104
    get_hll_global $P5859, "GLOBAL"
    nqp_get_package_through_who $P5860, $P5859, "PAST"
    get_who $P5861, $P5860
    set $P5862, $P5861["Var"]
    find_lex $P5863, "$inv"
    unless_null $P5863, vivify_2729
    new $P5863, "Undef"
  vivify_2729:
    $P5864 = $P5863."name"()
    $P5865 = $P5862."new"("lexical" :named("scope"), $P5864 :named("name"))
    $P5866 = $P5858."new"("self" :named("name"), "lexical" :named("scope"), 1 :named("isdecl"), $P5865 :named("viviself"))
.annotate 'line', 2102
    $P5854."push"($P5866)
.annotate 'line', 2106
    new $P5867, "Integer"
    assign $P5867, 1
    find_lex $P5868, "$?PACKAGE"
    get_who $P5869, $P5868
    set $P5870, $P5869["@BLOCK"]
    unless_null $P5870, vivify_2730
    $P5870 = root_new ['parrot';'ResizablePMCArray']
    set $P5869["@BLOCK"], $P5870
  vivify_2730:
    set $P5871, $P5870[0]
    unless_null $P5871, vivify_2731
    $P5871 = root_new ['parrot';'Hash']
    set $P5870[0], $P5871
  vivify_2731:
    set $P5871["signature_has_invocant"], $P5867
.annotate 'line', 2099
    .return ($P5867)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5877"  :anon :subid("554_1307873304.82979") :outer("552_1307873304.82979")
    .param pmc param_5879
.annotate 'line', 2108
    .lex "$_", param_5879
    find_lex $P5880, "$BLOCKINIT"
    unless_null $P5880, vivify_2735
    new $P5880, "Undef"
  vivify_2735:
    find_lex $P5881, "$_"
    unless_null $P5881, vivify_2736
    new $P5881, "Undef"
  vivify_2736:
    $P5882 = $P5881."ast"()
    $P5883 = $P5880."push"($P5882)
    .return ($P5883)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "parameter" :anon :subid("555_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_5888
    .param pmc param_5889
.annotate 'line', 2111
    .lex "self", param_5888
    .lex "$/", param_5889
.annotate 'line', 2112
    new $P5890, "Undef"
    .lex "$quant", $P5890
.annotate 'line', 2113
    new $P5891, "Undef"
    .lex "$past", $P5891
.annotate 'line', 2112
    find_lex $P5892, "$/"
    unless_null $P5892, vivify_2737
    $P5892 = root_new ['parrot';'Hash']
  vivify_2737:
    set $P5893, $P5892["quant"]
    unless_null $P5893, vivify_2738
    new $P5893, "Undef"
  vivify_2738:
    store_lex "$quant", $P5893
    find_lex $P5894, "$past"
    unless_null $P5894, vivify_2739
    new $P5894, "Undef"
  vivify_2739:
.annotate 'line', 2114
    find_lex $P5896, "$/"
    unless_null $P5896, vivify_2740
    $P5896 = root_new ['parrot';'Hash']
  vivify_2740:
    set $P5897, $P5896["named_param"]
    unless_null $P5897, vivify_2741
    new $P5897, "Undef"
  vivify_2741:
    if $P5897, if_5895
.annotate 'line', 2121
    find_lex $P5911, "$/"
    unless_null $P5911, vivify_2742
    $P5911 = root_new ['parrot';'Hash']
  vivify_2742:
    set $P5912, $P5911["param_var"]
    unless_null $P5912, vivify_2743
    new $P5912, "Undef"
  vivify_2743:
    $P5913 = $P5912."ast"()
    store_lex "$past", $P5913
.annotate 'line', 2122
    find_lex $P5915, "$quant"
    unless_null $P5915, vivify_2744
    new $P5915, "Undef"
  vivify_2744:
    set $S5916, $P5915
    iseq $I5917, $S5916, "*"
    if $I5917, if_5914
.annotate 'line', 2126
    find_lex $P5926, "$quant"
    unless_null $P5926, vivify_2745
    new $P5926, "Undef"
  vivify_2745:
    set $S5927, $P5926
    iseq $I5928, $S5927, "?"
    unless $I5928, if_5925_end
.annotate 'line', 2127
    find_lex $P5929, "$past"
    unless_null $P5929, vivify_2746
    new $P5929, "Undef"
  vivify_2746:
    find_lex $P5930, "$/"
    unless_null $P5930, vivify_2747
    $P5930 = root_new ['parrot';'Hash']
  vivify_2747:
    set $P5931, $P5930["param_var"]
    unless_null $P5931, vivify_2748
    $P5931 = root_new ['parrot';'Hash']
  vivify_2748:
    set $P5932, $P5931["sigil"]
    unless_null $P5932, vivify_2749
    new $P5932, "Undef"
  vivify_2749:
    $P5933 = "vivitype"($P5932)
    $P5929."viviself"($P5933)
  if_5925_end:
.annotate 'line', 2126
    goto if_5914_end
  if_5914:
.annotate 'line', 2123
    find_lex $P5918, "$past"
    unless_null $P5918, vivify_2750
    new $P5918, "Undef"
  vivify_2750:
    $P5918."slurpy"(1)
.annotate 'line', 2124
    find_lex $P5919, "$past"
    unless_null $P5919, vivify_2751
    new $P5919, "Undef"
  vivify_2751:
    find_lex $P5920, "$/"
    unless_null $P5920, vivify_2752
    $P5920 = root_new ['parrot';'Hash']
  vivify_2752:
    set $P5921, $P5920["param_var"]
    unless_null $P5921, vivify_2753
    $P5921 = root_new ['parrot';'Hash']
  vivify_2753:
    set $P5922, $P5921["sigil"]
    unless_null $P5922, vivify_2754
    new $P5922, "Undef"
  vivify_2754:
    set $S5923, $P5922
    iseq $I5924, $S5923, "%"
    $P5919."named"($I5924)
  if_5914_end:
.annotate 'line', 2120
    goto if_5895_end
  if_5895:
.annotate 'line', 2115
    find_lex $P5898, "$/"
    unless_null $P5898, vivify_2755
    $P5898 = root_new ['parrot';'Hash']
  vivify_2755:
    set $P5899, $P5898["named_param"]
    unless_null $P5899, vivify_2756
    new $P5899, "Undef"
  vivify_2756:
    $P5900 = $P5899."ast"()
    store_lex "$past", $P5900
.annotate 'line', 2116
    find_lex $P5902, "$quant"
    unless_null $P5902, vivify_2757
    new $P5902, "Undef"
  vivify_2757:
    set $S5903, $P5902
    isne $I5904, $S5903, "!"
    unless $I5904, if_5901_end
.annotate 'line', 2117
    find_lex $P5905, "$past"
    unless_null $P5905, vivify_2758
    new $P5905, "Undef"
  vivify_2758:
    find_lex $P5906, "$/"
    unless_null $P5906, vivify_2759
    $P5906 = root_new ['parrot';'Hash']
  vivify_2759:
    set $P5907, $P5906["named_param"]
    unless_null $P5907, vivify_2760
    $P5907 = root_new ['parrot';'Hash']
  vivify_2760:
    set $P5908, $P5907["param_var"]
    unless_null $P5908, vivify_2761
    $P5908 = root_new ['parrot';'Hash']
  vivify_2761:
    set $P5909, $P5908["sigil"]
    unless_null $P5909, vivify_2762
    new $P5909, "Undef"
  vivify_2762:
    $P5910 = "vivitype"($P5909)
    $P5905."viviself"($P5910)
  if_5901_end:
  if_5895_end:
.annotate 'line', 2130
    find_lex $P5935, "$/"
    unless_null $P5935, vivify_2763
    $P5935 = root_new ['parrot';'Hash']
  vivify_2763:
    set $P5936, $P5935["default_value"]
    unless_null $P5936, vivify_2764
    new $P5936, "Undef"
  vivify_2764:
    unless $P5936, if_5934_end
.annotate 'line', 2131
    find_lex $P5938, "$quant"
    unless_null $P5938, vivify_2765
    new $P5938, "Undef"
  vivify_2765:
    set $S5939, $P5938
    iseq $I5940, $S5939, "*"
    unless $I5940, if_5937_end
.annotate 'line', 2132
    find_lex $P5941, "$/"
    unless_null $P5941, vivify_2766
    new $P5941, "Undef"
  vivify_2766:
    $P5942 = $P5941."CURSOR"()
    $P5942."panic"("Can't put default on slurpy parameter")
  if_5937_end:
.annotate 'line', 2134
    find_lex $P5944, "$quant"
    unless_null $P5944, vivify_2767
    new $P5944, "Undef"
  vivify_2767:
    set $S5945, $P5944
    iseq $I5946, $S5945, "!"
    unless $I5946, if_5943_end
.annotate 'line', 2135
    find_lex $P5947, "$/"
    unless_null $P5947, vivify_2768
    new $P5947, "Undef"
  vivify_2768:
    $P5948 = $P5947."CURSOR"()
    $P5948."panic"("Can't put default on required parameter")
  if_5943_end:
.annotate 'line', 2137
    find_lex $P5949, "$past"
    unless_null $P5949, vivify_2769
    new $P5949, "Undef"
  vivify_2769:
    find_lex $P5950, "$/"
    unless_null $P5950, vivify_2770
    $P5950 = root_new ['parrot';'Hash']
  vivify_2770:
    set $P5951, $P5950["default_value"]
    unless_null $P5951, vivify_2771
    $P5951 = root_new ['parrot';'ResizablePMCArray']
  vivify_2771:
    set $P5952, $P5951[0]
    unless_null $P5952, vivify_2772
    $P5952 = root_new ['parrot';'Hash']
  vivify_2772:
    set $P5953, $P5952["EXPR"]
    unless_null $P5953, vivify_2773
    new $P5953, "Undef"
  vivify_2773:
    $P5954 = $P5953."ast"()
    $P5949."viviself"($P5954)
  if_5934_end:
.annotate 'line', 2139
    find_lex $P5956, "$past"
    unless_null $P5956, vivify_2774
    new $P5956, "Undef"
  vivify_2774:
    $P5957 = $P5956."viviself"()
    if $P5957, unless_5955_end
    find_lex $P5958, "$?PACKAGE"
    get_who $P5959, $P5958
    set $P5960, $P5959["@BLOCK"]
    unless_null $P5960, vivify_2775
    $P5960 = root_new ['parrot';'ResizablePMCArray']
  vivify_2775:
    set $P5961, $P5960[0]
    unless_null $P5961, vivify_2776
    new $P5961, "Undef"
  vivify_2776:
    find_lex $P5962, "$?PACKAGE"
    get_who $P5963, $P5962
    set $P5964, $P5963["@BLOCK"]
    unless_null $P5964, vivify_2777
    $P5964 = root_new ['parrot';'ResizablePMCArray']
  vivify_2777:
    set $P5965, $P5964[0]
    unless_null $P5965, vivify_2778
    new $P5965, "Undef"
  vivify_2778:
    $P5966 = $P5965."arity"()
    set $N5967, $P5966
    new $P5968, 'Float'
    set $P5968, $N5967
    add $P5969, $P5968, 1
    $P5961."arity"($P5969)
  unless_5955_end:
.annotate 'line', 2143
    find_lex $P5971, "$/"
    unless_null $P5971, vivify_2779
    $P5971 = root_new ['parrot';'Hash']
  vivify_2779:
    set $P5972, $P5971["typename"]
    unless_null $P5972, vivify_2780
    new $P5972, "Undef"
  vivify_2780:
    unless $P5972, if_5970_end
.annotate 'line', 2144
    find_lex $P5973, "$past"
    unless_null $P5973, vivify_2781
    new $P5973, "Undef"
  vivify_2781:
    find_lex $P5974, "$/"
    unless_null $P5974, vivify_2782
    $P5974 = root_new ['parrot';'Hash']
  vivify_2782:
    set $P5975, $P5974["typename"]
    unless_null $P5975, vivify_2783
    $P5975 = root_new ['parrot';'ResizablePMCArray']
  vivify_2783:
    set $P5976, $P5975[0]
    unless_null $P5976, vivify_2784
    new $P5976, "Undef"
  vivify_2784:
    $P5977 = $P5976."ast"()
    $P5973."multitype"($P5977)
  if_5970_end:
.annotate 'line', 2148
    find_lex $P5979, "$/"
    unless_null $P5979, vivify_2785
    $P5979 = root_new ['parrot';'Hash']
  vivify_2785:
    set $P5980, $P5979["definedness"]
    unless_null $P5980, vivify_2786
    new $P5980, "Undef"
  vivify_2786:
    unless $P5980, if_5978_end
.annotate 'line', 2149
    find_lex $P5981, "$/"
    unless_null $P5981, vivify_2787
    $P5981 = root_new ['parrot';'Hash']
  vivify_2787:
    set $P5982, $P5981["definedness"]
    unless_null $P5982, vivify_2788
    $P5982 = root_new ['parrot';'ResizablePMCArray']
  vivify_2788:
    set $P5983, $P5982[0]
    unless_null $P5983, vivify_2789
    new $P5983, "Undef"
  vivify_2789:
    set $S5984, $P5983
    new $P5985, 'String'
    set $P5985, $S5984
    find_lex $P5986, "$past"
    unless_null $P5986, vivify_2790
    $P5986 = root_new ['parrot';'Hash']
    store_lex "$past", $P5986
  vivify_2790:
    set $P5986["definedness"], $P5985
  if_5978_end:
.annotate 'line', 2152
    find_lex $P5987, "$/"
    find_lex $P5988, "$past"
    unless_null $P5988, vivify_2791
    new $P5988, "Undef"
  vivify_2791:
    $P5989 = $P5987."!make"($P5988)
.annotate 'line', 2111
    .return ($P5989)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "param_var" :anon :subid("556_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_5991
    .param pmc param_5992
.annotate 'line', 2155
    .lex "self", param_5991
    .lex "$/", param_5992
.annotate 'line', 2156
    new $P5993, "Undef"
    .lex "$name", $P5993
.annotate 'line', 2157
    new $P5994, "Undef"
    .lex "$past", $P5994
.annotate 'line', 2156
    find_lex $P5995, "$/"
    unless_null $P5995, vivify_2792
    new $P5995, "Undef"
  vivify_2792:
    set $S5996, $P5995
    new $P5997, 'String'
    set $P5997, $S5996
    store_lex "$name", $P5997
.annotate 'line', 2157
    get_hll_global $P5998, "GLOBAL"
    nqp_get_package_through_who $P5999, $P5998, "PAST"
    get_who $P6000, $P5999
    set $P6001, $P6000["Var"]
    find_lex $P6002, "$name"
    unless_null $P6002, vivify_2793
    new $P6002, "Undef"
  vivify_2793:
    find_lex $P6003, "$/"
    unless_null $P6003, vivify_2794
    new $P6003, "Undef"
  vivify_2794:
    $P6004 = $P6001."new"($P6002 :named("name"), "parameter" :named("scope"), 1 :named("isdecl"), $P6003 :named("node"))
    store_lex "$past", $P6004
.annotate 'line', 2159
    find_lex $P6005, "$?PACKAGE"
    get_who $P6006, $P6005
    set $P6007, $P6006["@BLOCK"]
    unless_null $P6007, vivify_2795
    $P6007 = root_new ['parrot';'ResizablePMCArray']
  vivify_2795:
    set $P6008, $P6007[0]
    unless_null $P6008, vivify_2796
    new $P6008, "Undef"
  vivify_2796:
    find_lex $P6009, "$name"
    unless_null $P6009, vivify_2797
    new $P6009, "Undef"
  vivify_2797:
    $P6008."symbol"($P6009, "lexical" :named("scope"))
.annotate 'line', 2160
    find_lex $P6010, "$/"
    find_lex $P6011, "$past"
    unless_null $P6011, vivify_2798
    new $P6011, "Undef"
  vivify_2798:
    $P6012 = $P6010."!make"($P6011)
.annotate 'line', 2155
    .return ($P6012)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "named_param" :anon :subid("557_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_6014
    .param pmc param_6015
.annotate 'line', 2163
    .lex "self", param_6014
    .lex "$/", param_6015
.annotate 'line', 2164
    new $P6016, "Undef"
    .lex "$past", $P6016
    find_lex $P6017, "$/"
    unless_null $P6017, vivify_2799
    $P6017 = root_new ['parrot';'Hash']
  vivify_2799:
    set $P6018, $P6017["param_var"]
    unless_null $P6018, vivify_2800
    new $P6018, "Undef"
  vivify_2800:
    $P6019 = $P6018."ast"()
    store_lex "$past", $P6019
.annotate 'line', 2165
    find_lex $P6020, "$past"
    unless_null $P6020, vivify_2801
    new $P6020, "Undef"
  vivify_2801:
    find_lex $P6021, "$/"
    unless_null $P6021, vivify_2802
    $P6021 = root_new ['parrot';'Hash']
  vivify_2802:
    set $P6022, $P6021["param_var"]
    unless_null $P6022, vivify_2803
    $P6022 = root_new ['parrot';'Hash']
  vivify_2803:
    set $P6023, $P6022["name"]
    unless_null $P6023, vivify_2804
    new $P6023, "Undef"
  vivify_2804:
    set $S6024, $P6023
    $P6020."named"($S6024)
.annotate 'line', 2166
    find_lex $P6025, "$/"
    find_lex $P6026, "$past"
    unless_null $P6026, vivify_2805
    new $P6026, "Undef"
  vivify_2805:
    $P6027 = $P6025."!make"($P6026)
.annotate 'line', 2163
    .return ($P6027)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "typename" :anon :subid("558_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_6029
    .param pmc param_6030
.annotate 'line', 2169
    .const 'Sub' $P6042 = "559_1307873304.82979" 
    capture_lex $P6042
    .lex "self", param_6029
    .lex "$/", param_6030
.annotate 'line', 2173
    $P6031 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P6031
.annotate 'line', 2174
    new $P6032, "Undef"
    .lex "$found", $P6032
.annotate 'line', 2173
    get_hll_global $P6033, "GLOBAL"
    nqp_get_package_through_who $P6034, $P6033, "HLL"
    get_who $P6035, $P6034
    set $P6036, $P6035["Compiler"]
    find_lex $P6037, "$/"
    unless_null $P6037, vivify_2806
    new $P6037, "Undef"
  vivify_2806:
    set $S6038, $P6037
    $P6039 = $P6036."parse_name"($S6038)
    store_lex "@name", $P6039
.annotate 'line', 2174
    new $P6040, "Integer"
    assign $P6040, 0
    store_lex "$found", $P6040
.annotate 'line', 2175
    .const 'Sub' $P6042 = "559_1307873304.82979" 
    capture_lex $P6042
    $P6042()
.annotate 'line', 2180
    find_lex $P6063, "$found"
    unless_null $P6063, vivify_2812
    new $P6063, "Undef"
  vivify_2812:
    unless $P6063, unless_6062
    set $P6061, $P6063
    goto unless_6062_end
  unless_6062:
.annotate 'line', 2181
    find_lex $P6064, "$/"
    unless_null $P6064, vivify_2813
    new $P6064, "Undef"
  vivify_2813:
    $P6065 = $P6064."CURSOR"()
    new $P6066, "String"
    assign $P6066, "Use of undeclared type '"
    find_lex $P6067, "$/"
    unless_null $P6067, vivify_2814
    new $P6067, "Undef"
  vivify_2814:
    set $S6068, $P6067
    concat $P6069, $P6066, $S6068
    concat $P6070, $P6069, "'"
    $P6071 = $P6065."panic"($P6070)
.annotate 'line', 2180
    set $P6061, $P6071
  unless_6062_end:
.annotate 'line', 2169
    .return ($P6061)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block6041"  :anon :subid("559_1307873304.82979") :outer("558_1307873304.82979")
.annotate 'line', 2175
    new $P6056, 'ExceptionHandler'
    set_label $P6056, control_6055
    $P6056."handle_types_except"(.CONTROL_RETURN,  .CONTROL_OK,  .CONTROL_BREAK,  .CONTROL_CONTINUE,  .CONTROL_TAKE,  .CONTROL_LEAVE,  .CONTROL_EXIT,  .CONTROL_LOOP_NEXT,  .CONTROL_LOOP_LAST,  .CONTROL_LOOP_REDO)
    push_eh $P6056
.annotate 'line', 2176
    new $P6043, "Undef"
    .lex "$sym", $P6043
    find_lex $P6044, "@name"
    unless_null $P6044, vivify_2807
    $P6044 = root_new ['parrot';'ResizablePMCArray']
  vivify_2807:
    find_lex $P6045, "$/"
    unless_null $P6045, vivify_2808
    new $P6045, "Undef"
  vivify_2808:
    $P6046 = "find_sym"($P6044, $P6045)
    store_lex "$sym", $P6046
.annotate 'line', 2177
    find_dynamic_lex $P6047, "$/"
    find_dynamic_lex $P6050, "$*SC"
    unless_null $P6050, vivify_2809
    get_hll_global $P6048, "GLOBAL"
    get_who $P6049, $P6048
    set $P6050, $P6049["$SC"]
    unless_null $P6050, vivify_2810
    die "Contextual $*SC not found"
  vivify_2810:
  vivify_2809:
    find_lex $P6051, "$sym"
    unless_null $P6051, vivify_2811
    new $P6051, "Undef"
  vivify_2811:
    $P6052 = $P6050."get_object_sc_ref_past"($P6051)
    $P6047."!make"($P6052)
.annotate 'line', 2178
    new $P6053, "Integer"
    assign $P6053, 1
    store_lex "$found", $P6053
.annotate 'line', 2175
    pop_eh 
    goto skip_handler_6054
  control_6055:
    .local pmc exception 
    .get_results (exception) 
    new $P6059, 'Integer'
    set $P6059, 1
    set exception["handled"], $P6059
    set $I6060, exception["handled"]
    ne $I6060, 1, nothandled_6058
  handled_6057:
    .return (exception)
  nothandled_6058:
    rethrow exception
  skip_handler_6054:
    .return ($P6053)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait" :anon :subid("560_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_6073
    .param pmc param_6074
.annotate 'line', 2185
    .lex "self", param_6073
    .lex "$/", param_6074
.annotate 'line', 2186
    find_lex $P6075, "$/"
    find_lex $P6076, "$/"
    unless_null $P6076, vivify_2815
    $P6076 = root_new ['parrot';'Hash']
  vivify_2815:
    set $P6077, $P6076["trait_mod"]
    unless_null $P6077, vivify_2816
    new $P6077, "Undef"
  vivify_2816:
    $P6078 = $P6077."ast"()
    $P6079 = $P6075."!make"($P6078)
.annotate 'line', 2185
    .return ($P6079)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait_mod:sym<is>" :anon :subid("561_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_6081
    .param pmc param_6082
.annotate 'line', 2189
    .const 'Sub' $P6143 = "564_1307873304.82979" 
    capture_lex $P6143
    .const 'Sub' $P6090 = "562_1307873304.82979" 
    capture_lex $P6090
    .lex "self", param_6081
    .lex "$/", param_6082
.annotate 'line', 2190
    find_lex $P6085, "$/"
    unless_null $P6085, vivify_2817
    $P6085 = root_new ['parrot';'Hash']
  vivify_2817:
    set $P6086, $P6085["longname"]
    unless_null $P6086, vivify_2818
    new $P6086, "Undef"
  vivify_2818:
    set $S6087, $P6086
    iseq $I6088, $S6087, "parrot_vtable"
    if $I6088, if_6084
.annotate 'line', 2203
    find_lex $P6138, "$/"
    unless_null $P6138, vivify_2819
    $P6138 = root_new ['parrot';'Hash']
  vivify_2819:
    set $P6139, $P6138["longname"]
    unless_null $P6139, vivify_2820
    new $P6139, "Undef"
  vivify_2820:
    set $S6140, $P6139
    iseq $I6141, $S6140, "parrot_vtable_handler"
    if $I6141, if_6137
.annotate 'line', 2214
    find_lex $P6183, "$/"
    unless_null $P6183, vivify_2821
    $P6183 = root_new ['parrot';'Hash']
  vivify_2821:
    set $P6184, $P6183["longname"]
    unless_null $P6184, vivify_2822
    new $P6184, "Undef"
  vivify_2822:
    set $S6185, $P6184
    iseq $I6186, $S6185, "pirflags"
    if $I6186, if_6182
.annotate 'line', 2218
    find_lex $P6190, "$/"
    unless_null $P6190, vivify_2823
    new $P6190, "Undef"
  vivify_2823:
    $P6191 = $P6190."CURSOR"()
    new $P6192, 'String'
    set $P6192, "Trait '"
    find_lex $P6193, "$/"
    unless_null $P6193, vivify_2824
    $P6193 = root_new ['parrot';'Hash']
  vivify_2824:
    set $P6194, $P6193["longname"]
    unless_null $P6194, vivify_2825
    new $P6194, "Undef"
  vivify_2825:
    concat $P6195, $P6192, $P6194
    concat $P6196, $P6195, "' not implemented"
    $P6197 = $P6191."panic"($P6196)
.annotate 'line', 2217
    set $P6181, $P6197
.annotate 'line', 2214
    goto if_6182_end
  if_6182:
.annotate 'line', 2215
    find_lex $P6187, "$/"
    unless_null $P6187, vivify_2826
    new $P6187, "Undef"
  vivify_2826:
    $P6188 = $P6187."CURSOR"()
    $P6189 = $P6188."panic"("Trait 'pirflags' no longer supported; use 'is vtable'")
.annotate 'line', 2214
    set $P6181, $P6189
  if_6182_end:
    set $P6136, $P6181
.annotate 'line', 2203
    goto if_6137_end
  if_6137:
    .const 'Sub' $P6143 = "564_1307873304.82979" 
    capture_lex $P6143
    $P6180 = $P6143()
    set $P6136, $P6180
  if_6137_end:
    set $P6083, $P6136
.annotate 'line', 2190
    goto if_6084_end
  if_6084:
    .const 'Sub' $P6090 = "562_1307873304.82979" 
    capture_lex $P6090
    $P6135 = $P6090()
    set $P6083, $P6135
  if_6084_end:
.annotate 'line', 2189
    .return ($P6083)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6142"  :anon :subid("564_1307873304.82979") :outer("561_1307873304.82979")
.annotate 'line', 2203
    .const 'Sub' $P6167 = "565_1307873304.82979" 
    capture_lex $P6167
.annotate 'line', 2205
    new $P6144, "Undef"
    .lex "$cpast", $P6144
.annotate 'line', 2208
    new $P6145, "Undef"
    .lex "$name", $P6145
.annotate 'line', 2209
    new $P6146, "Undef"
    .lex "$package", $P6146
.annotate 'line', 2205
    find_lex $P6147, "$/"
    unless_null $P6147, vivify_2827
    $P6147 = root_new ['parrot';'Hash']
  vivify_2827:
    set $P6148, $P6147["circumfix"]
    unless_null $P6148, vivify_2828
    $P6148 = root_new ['parrot';'ResizablePMCArray']
  vivify_2828:
    set $P6149, $P6148[0]
    unless_null $P6149, vivify_2829
    new $P6149, "Undef"
  vivify_2829:
    $P6150 = $P6149."ast"()
    store_lex "$cpast", $P6150
.annotate 'line', 2207
    get_hll_global $P6152, "GLOBAL"
    nqp_get_package_through_who $P6153, $P6152, "PAST"
    get_who $P6154, $P6153
    set $P6155, $P6154["Val"]
    find_lex $P6156, "$cpast"
    unless_null $P6156, vivify_2830
    new $P6156, "Undef"
  vivify_2830:
    $P6157 = $P6155."ACCEPTS"($P6156)
    if $P6157, unless_6151_end
.annotate 'line', 2206
    find_lex $P6158, "$/"
    unless_null $P6158, vivify_2831
    new $P6158, "Undef"
  vivify_2831:
    $P6159 = $P6158."CURSOR"()
    $P6159."panic"("Trait 'parrot_vtable_handler' requires constant scalar argument")
  unless_6151_end:
.annotate 'line', 2208
    find_lex $P6160, "$cpast"
    unless_null $P6160, vivify_2832
    new $P6160, "Undef"
  vivify_2832:
    $P6161 = $P6160."value"()
    store_lex "$name", $P6161
.annotate 'line', 2209
    find_dynamic_lex $P6164, "$*PACKAGE"
    unless_null $P6164, vivify_2833
    get_hll_global $P6162, "GLOBAL"
    get_who $P6163, $P6162
    set $P6164, $P6163["$PACKAGE"]
    unless_null $P6164, vivify_2834
    die "Contextual $*PACKAGE not found"
  vivify_2834:
  vivify_2833:
    store_lex "$package", $P6164
.annotate 'line', 2210
    find_dynamic_lex $P6165, "$/"
    .const 'Sub' $P6167 = "565_1307873304.82979" 
    newclosure $P6178, $P6167
    $P6179 = $P6165."!make"($P6178)
.annotate 'line', 2203
    .return ($P6179)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6166"  :anon :subid("565_1307873304.82979") :outer("564_1307873304.82979")
    .param pmc param_6168
.annotate 'line', 2210
    .lex "$match", param_6168
.annotate 'line', 2211
    find_dynamic_lex $P6171, "$*SC"
    unless_null $P6171, vivify_2835
    get_hll_global $P6169, "GLOBAL"
    get_who $P6170, $P6169
    set $P6171, $P6170["$SC"]
    unless_null $P6171, vivify_2836
    die "Contextual $*SC not found"
  vivify_2836:
  vivify_2835:
    find_lex $P6172, "$package"
    unless_null $P6172, vivify_2837
    new $P6172, "Undef"
  vivify_2837:
    find_lex $P6173, "$name"
    unless_null $P6173, vivify_2838
    new $P6173, "Undef"
  vivify_2838:
    find_lex $P6174, "$match"
    unless_null $P6174, vivify_2839
    $P6174 = root_new ['parrot';'Hash']
  vivify_2839:
    set $P6175, $P6174["variable"]
    unless_null $P6175, vivify_2840
    new $P6175, "Undef"
  vivify_2840:
    set $S6176, $P6175
    $P6177 = $P6171."pkg_add_parrot_vtable_handler_mapping"($P6172, $P6173, $S6176)
.annotate 'line', 2210
    .return ($P6177)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6089"  :anon :subid("562_1307873304.82979") :outer("561_1307873304.82979")
.annotate 'line', 2190
    .const 'Sub' $P6121 = "563_1307873304.82979" 
    capture_lex $P6121
.annotate 'line', 2192
    new $P6091, "Undef"
    .lex "$cpast", $P6091
.annotate 'line', 2195
    new $P6092, "Undef"
    .lex "$name", $P6092
.annotate 'line', 2196
    new $P6093, "Undef"
    .lex "$package", $P6093
.annotate 'line', 2197
    new $P6094, "Undef"
    .lex "$is_dispatcher", $P6094
.annotate 'line', 2192
    find_lex $P6095, "$/"
    unless_null $P6095, vivify_2841
    $P6095 = root_new ['parrot';'Hash']
  vivify_2841:
    set $P6096, $P6095["circumfix"]
    unless_null $P6096, vivify_2842
    $P6096 = root_new ['parrot';'ResizablePMCArray']
  vivify_2842:
    set $P6097, $P6096[0]
    unless_null $P6097, vivify_2843
    new $P6097, "Undef"
  vivify_2843:
    $P6098 = $P6097."ast"()
    store_lex "$cpast", $P6098
.annotate 'line', 2194
    get_hll_global $P6100, "GLOBAL"
    nqp_get_package_through_who $P6101, $P6100, "PAST"
    get_who $P6102, $P6101
    set $P6103, $P6102["Val"]
    find_lex $P6104, "$cpast"
    unless_null $P6104, vivify_2844
    new $P6104, "Undef"
  vivify_2844:
    $P6105 = $P6103."ACCEPTS"($P6104)
    if $P6105, unless_6099_end
.annotate 'line', 2193
    find_lex $P6106, "$/"
    unless_null $P6106, vivify_2845
    new $P6106, "Undef"
  vivify_2845:
    $P6107 = $P6106."CURSOR"()
    $P6107."panic"("Trait 'parrot_vtable' requires constant scalar argument")
  unless_6099_end:
.annotate 'line', 2195
    find_lex $P6108, "$cpast"
    unless_null $P6108, vivify_2846
    new $P6108, "Undef"
  vivify_2846:
    $P6109 = $P6108."value"()
    store_lex "$name", $P6109
.annotate 'line', 2196
    find_dynamic_lex $P6112, "$*PACKAGE"
    unless_null $P6112, vivify_2847
    get_hll_global $P6110, "GLOBAL"
    get_who $P6111, $P6110
    set $P6112, $P6111["$PACKAGE"]
    unless_null $P6112, vivify_2848
    die "Contextual $*PACKAGE not found"
  vivify_2848:
  vivify_2847:
    store_lex "$package", $P6112
.annotate 'line', 2197
    find_dynamic_lex $P6115, "$*SCOPE"
    unless_null $P6115, vivify_2849
    get_hll_global $P6113, "GLOBAL"
    get_who $P6114, $P6113
    set $P6115, $P6114["$SCOPE"]
    unless_null $P6115, vivify_2850
    die "Contextual $*SCOPE not found"
  vivify_2850:
  vivify_2849:
    set $S6116, $P6115
    iseq $I6117, $S6116, "proto"
    new $P6118, 'Integer'
    set $P6118, $I6117
    store_lex "$is_dispatcher", $P6118
.annotate 'line', 2198
    find_dynamic_lex $P6119, "$/"
    .const 'Sub' $P6121 = "563_1307873304.82979" 
    newclosure $P6133, $P6121
    $P6134 = $P6119."!make"($P6133)
.annotate 'line', 2190
    .return ($P6134)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6120"  :anon :subid("563_1307873304.82979") :outer("562_1307873304.82979")
    .param pmc param_6122
.annotate 'line', 2198
    .lex "$match", param_6122
.annotate 'line', 2199
    find_dynamic_lex $P6125, "$*SC"
    unless_null $P6125, vivify_2851
    get_hll_global $P6123, "GLOBAL"
    get_who $P6124, $P6123
    set $P6125, $P6124["$SC"]
    unless_null $P6125, vivify_2852
    die "Contextual $*SC not found"
  vivify_2852:
  vivify_2851:
    find_lex $P6126, "$package"
    unless_null $P6126, vivify_2853
    new $P6126, "Undef"
  vivify_2853:
    find_lex $P6127, "$name"
    unless_null $P6127, vivify_2854
    new $P6127, "Undef"
  vivify_2854:
.annotate 'line', 2200
    find_lex $P6128, "$match"
    unless_null $P6128, vivify_2855
    new $P6128, "Undef"
  vivify_2855:
    $P6129 = $P6128."ast"()
    set $P6130, $P6129["block_past"]
    unless_null $P6130, vivify_2856
    new $P6130, "Undef"
  vivify_2856:
.annotate 'line', 2199
    find_lex $P6131, "$is_dispatcher"
    unless_null $P6131, vivify_2857
    new $P6131, "Undef"
  vivify_2857:
    $P6132 = $P6125."pkg_add_method"($P6126, "add_parrot_vtable_mapping", $P6127, $P6130, $P6131)
.annotate 'line', 2198
    .return ($P6132)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "regex_declarator" :anon :subid("566_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_6201
    .param pmc param_6202
    .param pmc param_6203 :optional
    .param int has_param_6203 :opt_flag
.annotate 'line', 2222
    .const 'Sub' $P6330 = "569_1307873304.82979" 
    capture_lex $P6330
    .const 'Sub' $P6292 = "568_1307873304.82979" 
    capture_lex $P6292
    .const 'Sub' $P6272 = "567_1307873304.82979" 
    capture_lex $P6272
    new $P6200, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P6200, control_6199
    push_eh $P6200
    .lex "self", param_6201
    .lex "$/", param_6202
    if has_param_6203, optparam_2858
    new $P6204, "Undef"
    set param_6203, $P6204
  optparam_2858:
    .lex "$key", param_6203
.annotate 'line', 2223
    $P6205 = root_new ['parrot';'ResizablePMCArray']
    .lex "@MODIFIERS", $P6205
.annotate 'line', 2224
    new $P6206, "Undef"
    .lex "$name", $P6206
.annotate 'line', 2225
    new $P6207, "Undef"
    .lex "$past", $P6207
.annotate 'line', 2223
    get_hll_global $P6208, "GLOBAL"
    nqp_get_package_through_who $P6209, $P6208, "Regex"
    nqp_get_package_through_who $P6210, $P6209, "P6Regex"
    nqp_get_package_through_who $P6211, $P6210, "Actions"
    get_who $P6212, $P6211
    set $P6213, $P6212["@MODIFIERS"]
    unless_null $P6213, vivify_2859
    $P6213 = root_new ['parrot';'ResizablePMCArray']
  vivify_2859:
    store_lex "@MODIFIERS", $P6213
.annotate 'line', 2224
    find_lex $P6214, "$/"
    unless_null $P6214, vivify_2860
    $P6214 = root_new ['parrot';'Hash']
  vivify_2860:
    set $P6215, $P6214["deflongname"]
    unless_null $P6215, vivify_2861
    new $P6215, "Undef"
  vivify_2861:
    $P6216 = $P6215."ast"()
    set $S6217, $P6216
    new $P6218, 'String'
    set $P6218, $S6217
    store_lex "$name", $P6218
    find_lex $P6219, "$past"
    unless_null $P6219, vivify_2862
    new $P6219, "Undef"
  vivify_2862:
.annotate 'line', 2226
    find_lex $P6221, "$/"
    unless_null $P6221, vivify_2863
    $P6221 = root_new ['parrot';'Hash']
  vivify_2863:
    set $P6222, $P6221["proto"]
    unless_null $P6222, vivify_2864
    new $P6222, "Undef"
  vivify_2864:
    if $P6222, if_6220
.annotate 'line', 2256
    find_lex $P6288, "$key"
    unless_null $P6288, vivify_2865
    new $P6288, "Undef"
  vivify_2865:
    set $S6289, $P6288
    iseq $I6290, $S6289, "open"
    if $I6290, if_6287
.annotate 'line', 2266
    .const 'Sub' $P6330 = "569_1307873304.82979" 
    capture_lex $P6330
    $P6330()
    goto if_6287_end
  if_6287:
.annotate 'line', 2256
    .const 'Sub' $P6292 = "568_1307873304.82979" 
    capture_lex $P6292
    $P6292()
  if_6287_end:
    goto if_6220_end
  if_6220:
.annotate 'line', 2228
    get_hll_global $P6223, "GLOBAL"
    nqp_get_package_through_who $P6224, $P6223, "PAST"
    get_who $P6225, $P6224
    set $P6226, $P6225["Stmts"]
.annotate 'line', 2229
    get_hll_global $P6227, "GLOBAL"
    nqp_get_package_through_who $P6228, $P6227, "PAST"
    get_who $P6229, $P6228
    set $P6230, $P6229["Block"]
    find_lex $P6231, "$name"
    unless_null $P6231, vivify_2915
    new $P6231, "Undef"
  vivify_2915:
.annotate 'line', 2230
    get_hll_global $P6232, "GLOBAL"
    nqp_get_package_through_who $P6233, $P6232, "PAST"
    get_who $P6234, $P6233
    set $P6235, $P6234["Op"]
.annotate 'line', 2231
    get_hll_global $P6236, "GLOBAL"
    nqp_get_package_through_who $P6237, $P6236, "PAST"
    get_who $P6238, $P6237
    set $P6239, $P6238["Var"]
    $P6240 = $P6239."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P6241, "$name"
    unless_null $P6241, vivify_2916
    new $P6241, "Undef"
  vivify_2916:
    $P6242 = $P6235."new"($P6240, $P6241, "!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 2230
    find_lex $P6243, "$/"
    unless_null $P6243, vivify_2917
    new $P6243, "Undef"
  vivify_2917:
    $P6244 = $P6230."new"($P6242, $P6231 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P6243 :named("node"))
.annotate 'line', 2240
    get_hll_global $P6245, "GLOBAL"
    nqp_get_package_through_who $P6246, $P6245, "PAST"
    get_who $P6247, $P6246
    set $P6248, $P6247["Block"]
    new $P6249, "String"
    assign $P6249, "!PREFIX__"
    find_lex $P6250, "$name"
    unless_null $P6250, vivify_2918
    new $P6250, "Undef"
  vivify_2918:
    concat $P6251, $P6249, $P6250
.annotate 'line', 2241
    get_hll_global $P6252, "GLOBAL"
    nqp_get_package_through_who $P6253, $P6252, "PAST"
    get_who $P6254, $P6253
    set $P6255, $P6254["Op"]
.annotate 'line', 2242
    get_hll_global $P6256, "GLOBAL"
    nqp_get_package_through_who $P6257, $P6256, "PAST"
    get_who $P6258, $P6257
    set $P6259, $P6258["Var"]
    $P6260 = $P6259."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P6261, "$name"
    unless_null $P6261, vivify_2919
    new $P6261, "Undef"
  vivify_2919:
    $P6262 = $P6255."new"($P6260, $P6261, "!PREFIX__!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 2241
    find_lex $P6263, "$/"
    unless_null $P6263, vivify_2920
    new $P6263, "Undef"
  vivify_2920:
    $P6264 = $P6248."new"($P6262, $P6251 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P6263 :named("node"))
.annotate 'line', 2240
    $P6265 = $P6226."new"($P6244, $P6264)
.annotate 'line', 2228
    store_lex "$past", $P6265
.annotate 'line', 2252
    find_lex $P6267, "$past"
    unless_null $P6267, vivify_2921
    new $P6267, "Undef"
  vivify_2921:
    $P6268 = $P6267."list"()
    defined $I6269, $P6268
    unless $I6269, for_undef_2922
    iter $P6266, $P6268
    new $P6285, 'ExceptionHandler'
    set_label $P6285, loop6284_handler
    $P6285."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P6285
  loop6284_test:
    unless $P6266, loop6284_done
    shift $P6270, $P6266
  loop6284_redo:
    .const 'Sub' $P6272 = "567_1307873304.82979" 
    capture_lex $P6272
    $P6272($P6270)
  loop6284_next:
    goto loop6284_test
  loop6284_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P6286, exception, 'type'
    eq $P6286, .CONTROL_LOOP_NEXT, loop6284_next
    eq $P6286, .CONTROL_LOOP_REDO, loop6284_redo
  loop6284_done:
    pop_eh 
  for_undef_2922:
  if_6220_end:
.annotate 'line', 2297
    find_lex $P6423, "$/"
    find_lex $P6424, "$past"
    unless_null $P6424, vivify_2929
    new $P6424, "Undef"
  vivify_2929:
    $P6425 = $P6423."!make"($P6424)
.annotate 'line', 2222
    .return ($P6425)
  control_6199:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P6426, exception, "payload"
    .return ($P6426)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6329"  :anon :subid("569_1307873304.82979") :outer("566_1307873304.82979")
.annotate 'line', 2266
    .const 'Sub' $P6362 = "570_1307873304.82979" 
    capture_lex $P6362
.annotate 'line', 2267
    new $P6331, "Undef"
    .lex "$regex", $P6331
.annotate 'line', 2270
    new $P6332, "Undef"
    .lex "$prefix_meth", $P6332
.annotate 'line', 2268
    get_hll_global $P6333, "GLOBAL"
    nqp_get_package_through_who $P6334, $P6333, "Regex"
    nqp_get_package_through_who $P6335, $P6334, "P6Regex"
    nqp_get_package_through_who $P6336, $P6335, "Actions"
    get_who $P6337, $P6336
    set $P6338, $P6337["buildsub"]
    find_lex $P6339, "$/"
    unless_null $P6339, vivify_2866
    $P6339 = root_new ['parrot';'Hash']
  vivify_2866:
    set $P6340, $P6339["p6regex"]
    unless_null $P6340, vivify_2867
    new $P6340, "Undef"
  vivify_2867:
    $P6341 = $P6340."ast"()
    find_lex $P6342, "$?PACKAGE"
    get_who $P6343, $P6342
    set $P6344, $P6343["@BLOCK"]
    unless_null $P6344, vivify_2868
    $P6344 = root_new ['parrot';'ResizablePMCArray']
  vivify_2868:
    $P6345 = $P6344."shift"()
    $P6346 = $P6338($P6341, $P6345)
    store_lex "$regex", $P6346
.annotate 'line', 2269
    find_lex $P6347, "$regex"
    unless_null $P6347, vivify_2869
    new $P6347, "Undef"
  vivify_2869:
    find_lex $P6348, "$name"
    unless_null $P6348, vivify_2870
    new $P6348, "Undef"
  vivify_2870:
    $P6347."name"($P6348)
    find_lex $P6349, "$prefix_meth"
    unless_null $P6349, vivify_2871
    new $P6349, "Undef"
  vivify_2871:
.annotate 'line', 2272
    find_dynamic_lex $P6355, "$*PKGDECL"
    unless_null $P6355, vivify_2872
    get_hll_global $P6353, "GLOBAL"
    get_who $P6354, $P6353
    set $P6355, $P6354["$PKGDECL"]
    unless_null $P6355, vivify_2873
    die "Contextual $*PKGDECL not found"
  vivify_2873:
  vivify_2872:
    if $P6355, if_6352
    set $P6351, $P6355
    goto if_6352_end
  if_6352:
    find_dynamic_lex $P6358, "$*PACKAGE"
    unless_null $P6358, vivify_2874
    get_hll_global $P6356, "GLOBAL"
    get_who $P6357, $P6356
    set $P6358, $P6357["$PACKAGE"]
    unless_null $P6358, vivify_2875
    die "Contextual $*PACKAGE not found"
  vivify_2875:
  vivify_2874:
    get_how $P6359, $P6358
    can $I6360, $P6359, "add_method"
    new $P6351, 'Integer'
    set $P6351, $I6360
  if_6352_end:
    unless $P6351, if_6350_end
    .const 'Sub' $P6362 = "570_1307873304.82979" 
    capture_lex $P6362
    $P6362()
  if_6350_end:
.annotate 'line', 2287
    get_hll_global $P6400, "GLOBAL"
    nqp_get_package_through_who $P6401, $P6400, "PAST"
    get_who $P6402, $P6401
    set $P6403, $P6402["Op"]
.annotate 'line', 2289
    new $P6404, "ResizablePMCArray"
    push $P6404, "Regex"
    push $P6404, "Method"
    find_lex $P6405, "$/"
    unless_null $P6405, vivify_2892
    new $P6405, "Undef"
  vivify_2892:
    $P6406 = "lexical_package_lookup"($P6404, $P6405)
    find_lex $P6407, "$regex"
    unless_null $P6407, vivify_2893
    new $P6407, "Undef"
  vivify_2893:
    $P6408 = $P6403."new"($P6406, $P6407, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 2287
    store_lex "$past", $P6408
.annotate 'line', 2292
    find_lex $P6411, "$prefix_meth"
    unless_null $P6411, vivify_2894
    new $P6411, "Undef"
  vivify_2894:
    if $P6411, if_6410
    find_lex $P6419, "$regex"
    unless_null $P6419, vivify_2895
    new $P6419, "Undef"
  vivify_2895:
    set $P6409, $P6419
    goto if_6410_end
  if_6410:
.annotate 'line', 2293
    get_hll_global $P6412, "GLOBAL"
    nqp_get_package_through_who $P6413, $P6412, "PAST"
    get_who $P6414, $P6413
    set $P6415, $P6414["Stmts"]
    find_lex $P6416, "$regex"
    unless_null $P6416, vivify_2896
    new $P6416, "Undef"
  vivify_2896:
    find_lex $P6417, "$prefix_meth"
    unless_null $P6417, vivify_2897
    new $P6417, "Undef"
  vivify_2897:
    $P6418 = $P6415."new"($P6416, $P6417)
    set $P6409, $P6418
  if_6410_end:
.annotate 'line', 2292
    find_lex $P6420, "$past"
    unless_null $P6420, vivify_2898
    $P6420 = root_new ['parrot';'Hash']
    store_lex "$past", $P6420
  vivify_2898:
    set $P6420["sink"], $P6409
.annotate 'line', 2295
    find_lex $P6421, "@MODIFIERS"
    unless_null $P6421, vivify_2899
    $P6421 = root_new ['parrot';'ResizablePMCArray']
  vivify_2899:
    $P6422 = $P6421."shift"()
.annotate 'line', 2266
    .return ($P6422)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6361"  :anon :subid("570_1307873304.82979") :outer("569_1307873304.82979")
.annotate 'line', 2277
    $P6363 = root_new ['parrot';'ResizablePMCArray']
    .lex "@prefixes", $P6363
.annotate 'line', 2274
    find_dynamic_lex $P6366, "$*SC"
    unless_null $P6366, vivify_2876
    get_hll_global $P6364, "GLOBAL"
    get_who $P6365, $P6364
    set $P6366, $P6365["$SC"]
    unless_null $P6366, vivify_2877
    die "Contextual $*SC not found"
  vivify_2877:
  vivify_2876:
    find_dynamic_lex $P6369, "$*PACKAGE"
    unless_null $P6369, vivify_2878
    get_hll_global $P6367, "GLOBAL"
    get_who $P6368, $P6367
    set $P6369, $P6368["$PACKAGE"]
    unless_null $P6369, vivify_2879
    die "Contextual $*PACKAGE not found"
  vivify_2879:
  vivify_2878:
    find_lex $P6370, "$name"
    unless_null $P6370, vivify_2880
    new $P6370, "Undef"
  vivify_2880:
    find_lex $P6371, "$regex"
    unless_null $P6371, vivify_2881
    new $P6371, "Undef"
  vivify_2881:
    $P6366."pkg_add_method"($P6369, "add_method", $P6370, $P6371, 0)
.annotate 'line', 2277
    find_lex $P6372, "$/"
    unless_null $P6372, vivify_2882
    $P6372 = root_new ['parrot';'Hash']
  vivify_2882:
    set $P6373, $P6372["p6regex"]
    unless_null $P6373, vivify_2883
    new $P6373, "Undef"
  vivify_2883:
    $P6374 = $P6373."ast"()
    $P6375 = $P6374."prefix_list"()
    store_lex "@prefixes", $P6375
.annotate 'line', 2278
    get_hll_global $P6376, "GLOBAL"
    nqp_get_package_through_who $P6377, $P6376, "PAST"
    get_who $P6378, $P6377
    set $P6379, $P6378["Block"]
.annotate 'line', 2279
    new $P6380, "String"
    assign $P6380, "!PREFIX__"
    find_lex $P6381, "$name"
    unless_null $P6381, vivify_2884
    new $P6381, "Undef"
  vivify_2884:
    concat $P6382, $P6380, $P6381
.annotate 'line', 2280
    get_hll_global $P6383, "GLOBAL"
    nqp_get_package_through_who $P6384, $P6383, "PAST"
    get_who $P6385, $P6384
    set $P6386, $P6385["Op"]
    find_lex $P6387, "@prefixes"
    unless_null $P6387, vivify_2885
    $P6387 = root_new ['parrot';'ResizablePMCArray']
  vivify_2885:
    $P6388 = $P6386."new"($P6387 :flat, "list" :named("pasttype"))
    $P6389 = $P6379."new"($P6388, $P6382 :named("name"), "method" :named("blocktype"))
.annotate 'line', 2278
    store_lex "$prefix_meth", $P6389
.annotate 'line', 2282
    find_dynamic_lex $P6392, "$*SC"
    unless_null $P6392, vivify_2886
    get_hll_global $P6390, "GLOBAL"
    get_who $P6391, $P6390
    set $P6392, $P6391["$SC"]
    unless_null $P6392, vivify_2887
    die "Contextual $*SC not found"
  vivify_2887:
  vivify_2886:
    find_dynamic_lex $P6395, "$*PACKAGE"
    unless_null $P6395, vivify_2888
    get_hll_global $P6393, "GLOBAL"
    get_who $P6394, $P6393
    set $P6395, $P6394["$PACKAGE"]
    unless_null $P6395, vivify_2889
    die "Contextual $*PACKAGE not found"
  vivify_2889:
  vivify_2888:
    find_lex $P6396, "$prefix_meth"
    unless_null $P6396, vivify_2890
    new $P6396, "Undef"
  vivify_2890:
    $P6397 = $P6396."name"()
    find_lex $P6398, "$prefix_meth"
    unless_null $P6398, vivify_2891
    new $P6398, "Undef"
  vivify_2891:
    $P6399 = $P6392."pkg_add_method"($P6395, "add_method", $P6397, $P6398, 0)
.annotate 'line', 2272
    .return ($P6399)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block6291"  :anon :subid("568_1307873304.82979") :outer("566_1307873304.82979")
.annotate 'line', 2257
    $P6293 = root_new ['parrot';'Hash']
    .lex "%h", $P6293
.annotate 'line', 2256
    find_lex $P6294, "%h"
    unless_null $P6294, vivify_2900
    $P6294 = root_new ['parrot';'Hash']
  vivify_2900:
.annotate 'line', 2258
    find_lex $P6296, "$/"
    unless_null $P6296, vivify_2901
    $P6296 = root_new ['parrot';'Hash']
  vivify_2901:
    set $P6297, $P6296["sym"]
    unless_null $P6297, vivify_2902
    new $P6297, "Undef"
  vivify_2902:
    set $S6298, $P6297
    iseq $I6299, $S6298, "token"
    unless $I6299, if_6295_end
    new $P6300, "Integer"
    assign $P6300, 1
    find_lex $P6301, "%h"
    unless_null $P6301, vivify_2903
    $P6301 = root_new ['parrot';'Hash']
    store_lex "%h", $P6301
  vivify_2903:
    set $P6301["r"], $P6300
  if_6295_end:
.annotate 'line', 2259
    find_lex $P6303, "$/"
    unless_null $P6303, vivify_2904
    $P6303 = root_new ['parrot';'Hash']
  vivify_2904:
    set $P6304, $P6303["sym"]
    unless_null $P6304, vivify_2905
    new $P6304, "Undef"
  vivify_2905:
    set $S6305, $P6304
    iseq $I6306, $S6305, "rule"
    unless $I6306, if_6302_end
    new $P6307, "Integer"
    assign $P6307, 1
    find_lex $P6308, "%h"
    unless_null $P6308, vivify_2906
    $P6308 = root_new ['parrot';'Hash']
    store_lex "%h", $P6308
  vivify_2906:
    set $P6308["r"], $P6307
    new $P6309, "Integer"
    assign $P6309, 1
    find_lex $P6310, "%h"
    unless_null $P6310, vivify_2907
    $P6310 = root_new ['parrot';'Hash']
    store_lex "%h", $P6310
  vivify_2907:
    set $P6310["s"], $P6309
  if_6302_end:
.annotate 'line', 2260
    find_lex $P6311, "@MODIFIERS"
    unless_null $P6311, vivify_2908
    $P6311 = root_new ['parrot';'ResizablePMCArray']
  vivify_2908:
    find_lex $P6312, "%h"
    unless_null $P6312, vivify_2909
    $P6312 = root_new ['parrot';'Hash']
  vivify_2909:
    $P6311."unshift"($P6312)
.annotate 'line', 2261
    find_lex $P6313, "$name"
    unless_null $P6313, vivify_2910
    new $P6313, "Undef"
  vivify_2910:
    get_hll_global $P6314, "GLOBAL"
    nqp_get_package_through_who $P6315, $P6314, "Regex"
    nqp_get_package_through_who $P6316, $P6315, "P6Regex"
    nqp_get_package_through_who $P6317, $P6316, "Actions"
    get_who $P6318, $P6317
    set $P6318["$REGEXNAME"], $P6313
.annotate 'line', 2262
    find_lex $P6319, "$?PACKAGE"
    get_who $P6320, $P6319
    set $P6321, $P6320["@BLOCK"]
    unless_null $P6321, vivify_2911
    $P6321 = root_new ['parrot';'ResizablePMCArray']
  vivify_2911:
    set $P6322, $P6321[0]
    unless_null $P6322, vivify_2912
    new $P6322, "Undef"
  vivify_2912:
    $P6322."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 2263
    find_lex $P6323, "$?PACKAGE"
    get_who $P6324, $P6323
    set $P6325, $P6324["@BLOCK"]
    unless_null $P6325, vivify_2913
    $P6325 = root_new ['parrot';'ResizablePMCArray']
  vivify_2913:
    set $P6326, $P6325[0]
    unless_null $P6326, vivify_2914
    new $P6326, "Undef"
  vivify_2914:
    $P6326."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 2264
    new $P6327, "Exception"
    set $P6327['type'], .CONTROL_RETURN
    new $P6328, "Integer"
    assign $P6328, 0
    setattribute $P6327, 'payload', $P6328
    throw $P6327
.annotate 'line', 2256
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6271"  :anon :subid("567_1307873304.82979") :outer("566_1307873304.82979")
    .param pmc param_6273
.annotate 'line', 2252
    .lex "$_", param_6273
.annotate 'line', 2253
    find_dynamic_lex $P6276, "$*SC"
    unless_null $P6276, vivify_2923
    get_hll_global $P6274, "GLOBAL"
    get_who $P6275, $P6274
    set $P6276, $P6275["$SC"]
    unless_null $P6276, vivify_2924
    die "Contextual $*SC not found"
  vivify_2924:
  vivify_2923:
    find_dynamic_lex $P6279, "$*PACKAGE"
    unless_null $P6279, vivify_2925
    get_hll_global $P6277, "GLOBAL"
    get_who $P6278, $P6277
    set $P6279, $P6278["$PACKAGE"]
    unless_null $P6279, vivify_2926
    die "Contextual $*PACKAGE not found"
  vivify_2926:
  vivify_2925:
    find_lex $P6280, "$_"
    unless_null $P6280, vivify_2927
    new $P6280, "Undef"
  vivify_2927:
    $P6281 = $P6280."name"()
    find_lex $P6282, "$_"
    unless_null $P6282, vivify_2928
    new $P6282, "Undef"
  vivify_2928:
    $P6283 = $P6276."pkg_add_method"($P6279, "add_method", $P6281, $P6282, 0)
.annotate 'line', 2252
    .return ($P6283)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "dotty" :anon :subid("571_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_6428
    .param pmc param_6429
.annotate 'line', 2301
    .lex "self", param_6428
    .lex "$/", param_6429
.annotate 'line', 2302
    new $P6430, "Undef"
    .lex "$past", $P6430
    find_lex $P6433, "$/"
    unless_null $P6433, vivify_2930
    $P6433 = root_new ['parrot';'Hash']
  vivify_2930:
    set $P6434, $P6433["args"]
    unless_null $P6434, vivify_2931
    new $P6434, "Undef"
  vivify_2931:
    if $P6434, if_6432
    get_hll_global $P6439, "GLOBAL"
    nqp_get_package_through_who $P6440, $P6439, "PAST"
    get_who $P6441, $P6440
    set $P6442, $P6441["Op"]
    find_lex $P6443, "$/"
    unless_null $P6443, vivify_2932
    new $P6443, "Undef"
  vivify_2932:
    $P6444 = $P6442."new"($P6443 :named("node"))
    set $P6431, $P6444
    goto if_6432_end
  if_6432:
    find_lex $P6435, "$/"
    unless_null $P6435, vivify_2933
    $P6435 = root_new ['parrot';'Hash']
  vivify_2933:
    set $P6436, $P6435["args"]
    unless_null $P6436, vivify_2934
    $P6436 = root_new ['parrot';'ResizablePMCArray']
  vivify_2934:
    set $P6437, $P6436[0]
    unless_null $P6437, vivify_2935
    new $P6437, "Undef"
  vivify_2935:
    $P6438 = $P6437."ast"()
    set $P6431, $P6438
  if_6432_end:
    store_lex "$past", $P6431
.annotate 'line', 2303
    find_lex $P6446, "$/"
    unless_null $P6446, vivify_2936
    $P6446 = root_new ['parrot';'Hash']
  vivify_2936:
    set $P6447, $P6446["quote"]
    unless_null $P6447, vivify_2937
    new $P6447, "Undef"
  vivify_2937:
    if $P6447, if_6445
.annotate 'line', 2307
    find_lex $P6454, "$/"
    unless_null $P6454, vivify_2938
    $P6454 = root_new ['parrot';'Hash']
  vivify_2938:
    set $P6455, $P6454["longname"]
    unless_null $P6455, vivify_2939
    new $P6455, "Undef"
  vivify_2939:
    set $S6456, $P6455
    iseq $I6457, $S6456, "HOW"
    if $I6457, if_6453
.annotate 'line', 2310
    find_lex $P6460, "$/"
    unless_null $P6460, vivify_2940
    $P6460 = root_new ['parrot';'Hash']
  vivify_2940:
    set $P6461, $P6460["longname"]
    unless_null $P6461, vivify_2941
    new $P6461, "Undef"
  vivify_2941:
    set $S6462, $P6461
    iseq $I6463, $S6462, "WHAT"
    if $I6463, if_6459
.annotate 'line', 2313
    find_lex $P6466, "$/"
    unless_null $P6466, vivify_2942
    $P6466 = root_new ['parrot';'Hash']
  vivify_2942:
    set $P6467, $P6466["longname"]
    unless_null $P6467, vivify_2943
    new $P6467, "Undef"
  vivify_2943:
    set $S6468, $P6467
    iseq $I6469, $S6468, "WHO"
    if $I6469, if_6465
.annotate 'line', 2317
    find_lex $P6471, "$past"
    unless_null $P6471, vivify_2944
    new $P6471, "Undef"
  vivify_2944:
    find_lex $P6472, "$/"
    unless_null $P6472, vivify_2945
    $P6472 = root_new ['parrot';'Hash']
  vivify_2945:
    set $P6473, $P6472["longname"]
    unless_null $P6473, vivify_2946
    new $P6473, "Undef"
  vivify_2946:
    set $S6474, $P6473
    $P6471."name"($S6474)
.annotate 'line', 2318
    find_lex $P6475, "$past"
    unless_null $P6475, vivify_2947
    new $P6475, "Undef"
  vivify_2947:
    $P6475."pasttype"("callmethod")
.annotate 'line', 2316
    goto if_6465_end
  if_6465:
.annotate 'line', 2314
    find_lex $P6470, "$past"
    unless_null $P6470, vivify_2948
    new $P6470, "Undef"
  vivify_2948:
    $P6470."pirop"("get_who PP")
  if_6465_end:
.annotate 'line', 2313
    goto if_6459_end
  if_6459:
.annotate 'line', 2311
    find_lex $P6464, "$past"
    unless_null $P6464, vivify_2949
    new $P6464, "Undef"
  vivify_2949:
    $P6464."pirop"("get_what PP")
  if_6459_end:
.annotate 'line', 2310
    goto if_6453_end
  if_6453:
.annotate 'line', 2308
    find_lex $P6458, "$past"
    unless_null $P6458, vivify_2950
    new $P6458, "Undef"
  vivify_2950:
    $P6458."pirop"("get_how PP")
  if_6453_end:
.annotate 'line', 2307
    goto if_6445_end
  if_6445:
.annotate 'line', 2304
    find_lex $P6448, "$past"
    unless_null $P6448, vivify_2951
    new $P6448, "Undef"
  vivify_2951:
    find_lex $P6449, "$/"
    unless_null $P6449, vivify_2952
    $P6449 = root_new ['parrot';'Hash']
  vivify_2952:
    set $P6450, $P6449["quote"]
    unless_null $P6450, vivify_2953
    new $P6450, "Undef"
  vivify_2953:
    $P6451 = $P6450."ast"()
    $P6448."name"($P6451)
.annotate 'line', 2305
    find_lex $P6452, "$past"
    unless_null $P6452, vivify_2954
    new $P6452, "Undef"
  vivify_2954:
    $P6452."pasttype"("callmethod")
  if_6445_end:
.annotate 'line', 2320
    find_lex $P6476, "$/"
    find_lex $P6477, "$past"
    unless_null $P6477, vivify_2955
    new $P6477, "Undef"
  vivify_2955:
    $P6478 = $P6476."!make"($P6477)
.annotate 'line', 2301
    .return ($P6478)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<self>" :anon :subid("572_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_6480
    .param pmc param_6481
.annotate 'line', 2325
    .lex "self", param_6480
    .lex "$/", param_6481
.annotate 'line', 2326
    find_lex $P6482, "$/"
    get_hll_global $P6483, "GLOBAL"
    nqp_get_package_through_who $P6484, $P6483, "PAST"
    get_who $P6485, $P6484
    set $P6486, $P6485["Var"]
    $P6487 = $P6486."new"("self" :named("name"))
    $P6488 = $P6482."!make"($P6487)
.annotate 'line', 2325
    .return ($P6488)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<identifier>" :anon :subid("573_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_6490
    .param pmc param_6491
.annotate 'line', 2329
    .lex "self", param_6490
    .lex "$/", param_6491
.annotate 'line', 2330
    new $P6492, "Undef"
    .lex "$past", $P6492
    find_lex $P6493, "$/"
    unless_null $P6493, vivify_2956
    $P6493 = root_new ['parrot';'Hash']
  vivify_2956:
    set $P6494, $P6493["args"]
    unless_null $P6494, vivify_2957
    new $P6494, "Undef"
  vivify_2957:
    $P6495 = $P6494."ast"()
    store_lex "$past", $P6495
.annotate 'line', 2331
    find_lex $P6496, "$past"
    unless_null $P6496, vivify_2958
    new $P6496, "Undef"
  vivify_2958:
    find_lex $P6497, "$/"
    unless_null $P6497, vivify_2959
    $P6497 = root_new ['parrot';'Hash']
  vivify_2959:
    set $P6498, $P6497["deflongname"]
    unless_null $P6498, vivify_2960
    new $P6498, "Undef"
  vivify_2960:
    set $S6499, $P6498
    $P6496."name"($S6499)
.annotate 'line', 2332
    find_lex $P6500, "$/"
    find_lex $P6501, "$past"
    unless_null $P6501, vivify_2961
    new $P6501, "Undef"
  vivify_2961:
    $P6502 = $P6500."!make"($P6501)
.annotate 'line', 2329
    .return ($P6502)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<name>" :anon :subid("574_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_6504
    .param pmc param_6505
.annotate 'line', 2335
    .const 'Sub' $P6523 = "575_1307873304.82979" 
    capture_lex $P6523
    .lex "self", param_6504
    .lex "$/", param_6505
.annotate 'line', 2337
    new $P6506, "Undef"
    .lex "$var", $P6506
.annotate 'line', 2347
    new $P6507, "Undef"
    .lex "$past", $P6507
.annotate 'line', 2335
    find_lex $P6508, "$var"
    unless_null $P6508, vivify_2962
    new $P6508, "Undef"
  vivify_2962:
.annotate 'line', 2338
    find_lex $P6510, "$/"
    unless_null $P6510, vivify_2963
    $P6510 = root_new ['parrot';'Hash']
  vivify_2963:
    set $P6511, $P6510["name"]
    unless_null $P6511, vivify_2964
    new $P6511, "Undef"
  vivify_2964:
    set $S6512, $P6511
    $P6513 = "is_lexical"($S6512)
    if $P6513, if_6509
.annotate 'line', 2341
    .const 'Sub' $P6523 = "575_1307873304.82979" 
    capture_lex $P6523
    $P6523()
    goto if_6509_end
  if_6509:
.annotate 'line', 2339
    get_hll_global $P6514, "GLOBAL"
    nqp_get_package_through_who $P6515, $P6514, "PAST"
    get_who $P6516, $P6515
    set $P6517, $P6516["Var"]
    find_lex $P6518, "$/"
    unless_null $P6518, vivify_2970
    $P6518 = root_new ['parrot';'Hash']
  vivify_2970:
    set $P6519, $P6518["name"]
    unless_null $P6519, vivify_2971
    new $P6519, "Undef"
  vivify_2971:
    set $S6520, $P6519
    $P6521 = $P6517."new"($S6520 :named("name"), "lexical" :named("scope"))
    store_lex "$var", $P6521
  if_6509_end:
.annotate 'line', 2347
    find_lex $P6532, "$var"
    unless_null $P6532, vivify_2972
    new $P6532, "Undef"
  vivify_2972:
    store_lex "$past", $P6532
.annotate 'line', 2348
    find_lex $P6534, "$/"
    unless_null $P6534, vivify_2973
    $P6534 = root_new ['parrot';'Hash']
  vivify_2973:
    set $P6535, $P6534["args"]
    unless_null $P6535, vivify_2974
    new $P6535, "Undef"
  vivify_2974:
    unless $P6535, if_6533_end
.annotate 'line', 2349
    find_lex $P6536, "$/"
    unless_null $P6536, vivify_2975
    $P6536 = root_new ['parrot';'Hash']
  vivify_2975:
    set $P6537, $P6536["args"]
    unless_null $P6537, vivify_2976
    $P6537 = root_new ['parrot';'ResizablePMCArray']
  vivify_2976:
    set $P6538, $P6537[0]
    unless_null $P6538, vivify_2977
    new $P6538, "Undef"
  vivify_2977:
    $P6539 = $P6538."ast"()
    store_lex "$past", $P6539
.annotate 'line', 2350
    find_lex $P6540, "$past"
    unless_null $P6540, vivify_2978
    new $P6540, "Undef"
  vivify_2978:
    find_lex $P6541, "$var"
    unless_null $P6541, vivify_2979
    new $P6541, "Undef"
  vivify_2979:
    $P6540."unshift"($P6541)
  if_6533_end:
.annotate 'line', 2352
    find_lex $P6542, "$/"
    find_lex $P6543, "$past"
    unless_null $P6543, vivify_2980
    new $P6543, "Undef"
  vivify_2980:
    $P6544 = $P6542."!make"($P6543)
.annotate 'line', 2335
    .return ($P6544)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6522"  :anon :subid("575_1307873304.82979") :outer("574_1307873304.82979")
.annotate 'line', 2342
    $P6524 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P6524
    find_lex $P6525, "$/"
    unless_null $P6525, vivify_2965
    $P6525 = root_new ['parrot';'Hash']
  vivify_2965:
    set $P6526, $P6525["name"]
    unless_null $P6526, vivify_2966
    $P6526 = root_new ['parrot';'Hash']
  vivify_2966:
    set $P6527, $P6526["identifier"]
    unless_null $P6527, vivify_2967
    new $P6527, "Undef"
  vivify_2967:
    clone $P6528, $P6527
    store_lex "@ns", $P6528
.annotate 'line', 2343
    find_lex $P6529, "@ns"
    unless_null $P6529, vivify_2968
    $P6529 = root_new ['parrot';'ResizablePMCArray']
  vivify_2968:
    find_lex $P6530, "$/"
    unless_null $P6530, vivify_2969
    new $P6530, "Undef"
  vivify_2969:
    $P6531 = "lexical_package_lookup"($P6529, $P6530)
    store_lex "$var", $P6531
.annotate 'line', 2341
    .return ($P6531)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<pir::op>" :anon :subid("576_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_6546
    .param pmc param_6547
.annotate 'line', 2355
    .lex "self", param_6546
    .lex "$/", param_6547
.annotate 'line', 2356
    new $P6548, "Undef"
    .lex "$past", $P6548
.annotate 'line', 2357
    new $P6549, "Undef"
    .lex "$pirop", $P6549
.annotate 'line', 2356
    find_lex $P6552, "$/"
    unless_null $P6552, vivify_2981
    $P6552 = root_new ['parrot';'Hash']
  vivify_2981:
    set $P6553, $P6552["args"]
    unless_null $P6553, vivify_2982
    new $P6553, "Undef"
  vivify_2982:
    if $P6553, if_6551
    get_hll_global $P6558, "GLOBAL"
    nqp_get_package_through_who $P6559, $P6558, "PAST"
    get_who $P6560, $P6559
    set $P6561, $P6560["Op"]
    find_lex $P6562, "$/"
    unless_null $P6562, vivify_2983
    new $P6562, "Undef"
  vivify_2983:
    $P6563 = $P6561."new"($P6562 :named("node"))
    set $P6550, $P6563
    goto if_6551_end
  if_6551:
    find_lex $P6554, "$/"
    unless_null $P6554, vivify_2984
    $P6554 = root_new ['parrot';'Hash']
  vivify_2984:
    set $P6555, $P6554["args"]
    unless_null $P6555, vivify_2985
    $P6555 = root_new ['parrot';'ResizablePMCArray']
  vivify_2985:
    set $P6556, $P6555[0]
    unless_null $P6556, vivify_2986
    new $P6556, "Undef"
  vivify_2986:
    $P6557 = $P6556."ast"()
    set $P6550, $P6557
  if_6551_end:
    store_lex "$past", $P6550
.annotate 'line', 2357
    find_lex $P6564, "$/"
    unless_null $P6564, vivify_2987
    $P6564 = root_new ['parrot';'Hash']
  vivify_2987:
    set $P6565, $P6564["op"]
    unless_null $P6565, vivify_2988
    new $P6565, "Undef"
  vivify_2988:
    set $S6566, $P6565
    new $P6567, 'String'
    set $P6567, $S6566
    store_lex "$pirop", $P6567
.annotate 'line', 2358
    find_lex $P6568, "$pirop"
    unless_null $P6568, vivify_2989
    new $P6568, "Undef"
  vivify_2989:
    set $S6569, $P6568
    split $P6570, "__", $S6569
    join $S6571, " ", $P6570
    new $P6572, 'String'
    set $P6572, $S6571
    store_lex "$pirop", $P6572
.annotate 'line', 2359
    find_lex $P6573, "$past"
    unless_null $P6573, vivify_2990
    new $P6573, "Undef"
  vivify_2990:
    find_lex $P6574, "$pirop"
    unless_null $P6574, vivify_2991
    new $P6574, "Undef"
  vivify_2991:
    $P6573."pirop"($P6574)
.annotate 'line', 2360
    find_lex $P6575, "$past"
    unless_null $P6575, vivify_2992
    new $P6575, "Undef"
  vivify_2992:
    $P6575."pasttype"("pirop")
.annotate 'line', 2361
    find_lex $P6576, "$/"
    find_lex $P6577, "$past"
    unless_null $P6577, vivify_2993
    new $P6577, "Undef"
  vivify_2993:
    $P6578 = $P6576."!make"($P6577)
.annotate 'line', 2355
    .return ($P6578)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<pir::const>" :anon :subid("577_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_6580
    .param pmc param_6581
.annotate 'line', 2364
    .lex "self", param_6580
    .lex "$/", param_6581
.annotate 'line', 2365
    find_lex $P6582, "$/"
    get_hll_global $P6583, "GLOBAL"
    nqp_get_package_through_who $P6584, $P6583, "PAST"
    get_who $P6585, $P6584
    set $P6586, $P6585["Val"]
    find_lex $P6587, "$/"
    unless_null $P6587, vivify_2994
    $P6587 = root_new ['parrot';'Hash']
  vivify_2994:
    set $P6588, $P6587["const"]
    unless_null $P6588, vivify_2995
    new $P6588, "Undef"
  vivify_2995:
    set $S6589, $P6588
    find_lex $P6590, "$/"
    unless_null $P6590, vivify_2996
    new $P6590, "Undef"
  vivify_2996:
    $P6591 = $P6586."new"($S6589 :named("value"), "!macro_const" :named("returns"), $P6590 :named("node"))
    $P6592 = $P6582."!make"($P6591)
.annotate 'line', 2364
    .return ($P6592)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<onlystar>" :anon :subid("578_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_6594
    .param pmc param_6595
.annotate 'line', 2368
    .lex "self", param_6594
    .lex "$/", param_6595
.annotate 'line', 2369
    find_lex $P6596, "$/"
    get_hll_global $P6597, "GLOBAL"
    nqp_get_package_through_who $P6598, $P6597, "PAST"
    get_who $P6599, $P6598
    set $P6600, $P6599["Op"]
    $P6601 = $P6600."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P6602 = $P6596."!make"($P6601)
.annotate 'line', 2368
    .return ($P6602)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "args" :anon :subid("579_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_6604
    .param pmc param_6605
.annotate 'line', 2374
    .lex "self", param_6604
    .lex "$/", param_6605
    find_lex $P6606, "$/"
    find_lex $P6607, "$/"
    unless_null $P6607, vivify_2997
    $P6607 = root_new ['parrot';'Hash']
  vivify_2997:
    set $P6608, $P6607["arglist"]
    unless_null $P6608, vivify_2998
    new $P6608, "Undef"
  vivify_2998:
    $P6609 = $P6608."ast"()
    $P6610 = $P6606."!make"($P6609)
    .return ($P6610)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "arglist" :anon :subid("580_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_6612
    .param pmc param_6613
.annotate 'line', 2376
    .const 'Sub' $P6627 = "581_1307873304.82979" 
    capture_lex $P6627
    .lex "self", param_6612
    .lex "$/", param_6613
.annotate 'line', 2377
    new $P6614, "Undef"
    .lex "$past", $P6614
.annotate 'line', 2385
    new $P6615, "Undef"
    .lex "$i", $P6615
.annotate 'line', 2386
    new $P6616, "Undef"
    .lex "$n", $P6616
.annotate 'line', 2377
    get_hll_global $P6617, "GLOBAL"
    nqp_get_package_through_who $P6618, $P6617, "PAST"
    get_who $P6619, $P6618
    set $P6620, $P6619["Op"]
    find_lex $P6621, "$/"
    unless_null $P6621, vivify_2999
    new $P6621, "Undef"
  vivify_2999:
    $P6622 = $P6620."new"("call" :named("pasttype"), $P6621 :named("node"))
    store_lex "$past", $P6622
.annotate 'line', 2378
    find_lex $P6624, "$/"
    unless_null $P6624, vivify_3000
    $P6624 = root_new ['parrot';'Hash']
  vivify_3000:
    set $P6625, $P6624["EXPR"]
    unless_null $P6625, vivify_3001
    new $P6625, "Undef"
  vivify_3001:
    unless $P6625, if_6623_end
    .const 'Sub' $P6627 = "581_1307873304.82979" 
    capture_lex $P6627
    $P6627()
  if_6623_end:
.annotate 'line', 2385
    new $P6659, "Integer"
    assign $P6659, 0
    store_lex "$i", $P6659
.annotate 'line', 2386
    find_lex $P6660, "$past"
    unless_null $P6660, vivify_3012
    new $P6660, "Undef"
  vivify_3012:
    $P6661 = $P6660."list"()
    set $N6662, $P6661
    new $P6663, 'Float'
    set $P6663, $N6662
    store_lex "$n", $P6663
.annotate 'line', 2387
    new $P6714, 'ExceptionHandler'
    set_label $P6714, loop6713_handler
    $P6714."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P6714
  loop6713_test:
    find_lex $P6664, "$i"
    unless_null $P6664, vivify_3013
    new $P6664, "Undef"
  vivify_3013:
    set $N6665, $P6664
    find_lex $P6666, "$n"
    unless_null $P6666, vivify_3014
    new $P6666, "Undef"
  vivify_3014:
    set $N6667, $P6666
    islt $I6668, $N6665, $N6667
    unless $I6668, loop6713_done
  loop6713_redo:
.annotate 'line', 2388
    find_lex $P6670, "$i"
    unless_null $P6670, vivify_3015
    new $P6670, "Undef"
  vivify_3015:
    set $I6671, $P6670
    find_lex $P6672, "$past"
    unless_null $P6672, vivify_3016
    $P6672 = root_new ['parrot';'ResizablePMCArray']
  vivify_3016:
    set $P6673, $P6672[$I6671]
    unless_null $P6673, vivify_3017
    new $P6673, "Undef"
  vivify_3017:
    $S6674 = $P6673."name"()
    iseq $I6675, $S6674, "&prefix:<|>"
    unless $I6675, if_6669_end
.annotate 'line', 2389
    find_lex $P6676, "$i"
    unless_null $P6676, vivify_3018
    new $P6676, "Undef"
  vivify_3018:
    set $I6677, $P6676
    find_lex $P6678, "$past"
    unless_null $P6678, vivify_3019
    $P6678 = root_new ['parrot';'ResizablePMCArray']
  vivify_3019:
    set $P6679, $P6678[$I6677]
    unless_null $P6679, vivify_3020
    $P6679 = root_new ['parrot';'ResizablePMCArray']
  vivify_3020:
    set $P6680, $P6679[0]
    unless_null $P6680, vivify_3021
    new $P6680, "Undef"
  vivify_3021:
    find_lex $P6681, "$i"
    unless_null $P6681, vivify_3022
    new $P6681, "Undef"
  vivify_3022:
    set $I6682, $P6681
    find_lex $P6683, "$past"
    unless_null $P6683, vivify_3023
    $P6683 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$past", $P6683
  vivify_3023:
    set $P6683[$I6682], $P6680
.annotate 'line', 2390
    find_lex $P6684, "$i"
    unless_null $P6684, vivify_3024
    new $P6684, "Undef"
  vivify_3024:
    set $I6685, $P6684
    find_lex $P6686, "$past"
    unless_null $P6686, vivify_3025
    $P6686 = root_new ['parrot';'ResizablePMCArray']
  vivify_3025:
    set $P6687, $P6686[$I6685]
    unless_null $P6687, vivify_3026
    new $P6687, "Undef"
  vivify_3026:
    $P6687."flat"(1)
.annotate 'line', 2391
    find_lex $P6691, "$i"
    unless_null $P6691, vivify_3027
    new $P6691, "Undef"
  vivify_3027:
    set $I6692, $P6691
    find_lex $P6693, "$past"
    unless_null $P6693, vivify_3028
    $P6693 = root_new ['parrot';'ResizablePMCArray']
  vivify_3028:
    set $P6694, $P6693[$I6692]
    unless_null $P6694, vivify_3029
    new $P6694, "Undef"
  vivify_3029:
    get_hll_global $P6695, "GLOBAL"
    nqp_get_package_through_who $P6696, $P6695, "PAST"
    get_who $P6697, $P6696
    set $P6698, $P6697["Val"]
    $P6699 = $P6694."isa"($P6698)
    if $P6699, if_6690
    set $P6689, $P6699
    goto if_6690_end
  if_6690:
.annotate 'line', 2392
    find_lex $P6700, "$i"
    unless_null $P6700, vivify_3030
    new $P6700, "Undef"
  vivify_3030:
    set $I6701, $P6700
    find_lex $P6702, "$past"
    unless_null $P6702, vivify_3031
    $P6702 = root_new ['parrot';'ResizablePMCArray']
  vivify_3031:
    set $P6703, $P6702[$I6701]
    unless_null $P6703, vivify_3032
    new $P6703, "Undef"
  vivify_3032:
    $S6704 = $P6703."name"()
    substr $S6705, $S6704, 0, 1
    iseq $I6706, $S6705, "%"
    new $P6689, 'Integer'
    set $P6689, $I6706
  if_6690_end:
    unless $P6689, if_6688_end
.annotate 'line', 2393
    find_lex $P6707, "$i"
    unless_null $P6707, vivify_3033
    new $P6707, "Undef"
  vivify_3033:
    set $I6708, $P6707
    find_lex $P6709, "$past"
    unless_null $P6709, vivify_3034
    $P6709 = root_new ['parrot';'ResizablePMCArray']
  vivify_3034:
    set $P6710, $P6709[$I6708]
    unless_null $P6710, vivify_3035
    new $P6710, "Undef"
  vivify_3035:
    $P6710."named"(1)
  if_6688_end:
  if_6669_end:
.annotate 'line', 2388
    find_lex $P6711, "$i"
    unless_null $P6711, vivify_3036
    new $P6711, "Undef"
  vivify_3036:
    clone $P6712, $P6711
    inc $P6711
  loop6713_next:
.annotate 'line', 2387
    goto loop6713_test
  loop6713_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P6715, exception, 'type'
    eq $P6715, .CONTROL_LOOP_NEXT, loop6713_next
    eq $P6715, .CONTROL_LOOP_REDO, loop6713_redo
  loop6713_done:
    pop_eh 
.annotate 'line', 2398
    find_lex $P6716, "$/"
    find_lex $P6717, "$past"
    unless_null $P6717, vivify_3037
    new $P6717, "Undef"
  vivify_3037:
    $P6718 = $P6716."!make"($P6717)
.annotate 'line', 2376
    .return ($P6718)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block6626"  :anon :subid("581_1307873304.82979") :outer("580_1307873304.82979")
.annotate 'line', 2378
    .const 'Sub' $P6648 = "582_1307873304.82979" 
    capture_lex $P6648
.annotate 'line', 2379
    new $P6628, "Undef"
    .lex "$expr", $P6628
    find_lex $P6629, "$/"
    unless_null $P6629, vivify_3002
    $P6629 = root_new ['parrot';'Hash']
  vivify_3002:
    set $P6630, $P6629["EXPR"]
    unless_null $P6630, vivify_3003
    new $P6630, "Undef"
  vivify_3003:
    $P6631 = $P6630."ast"()
    store_lex "$expr", $P6631
.annotate 'line', 2380
    find_lex $P6636, "$expr"
    unless_null $P6636, vivify_3004
    new $P6636, "Undef"
  vivify_3004:
    $S6637 = $P6636."name"()
    iseq $I6638, $S6637, "&infix:<,>"
    if $I6638, if_6635
    new $P6634, 'Integer'
    set $P6634, $I6638
    goto if_6635_end
  if_6635:
    find_lex $P6639, "$expr"
    unless_null $P6639, vivify_3005
    new $P6639, "Undef"
  vivify_3005:
    $P6640 = $P6639."named"()
    isfalse $I6641, $P6640
    new $P6634, 'Integer'
    set $P6634, $I6641
  if_6635_end:
    if $P6634, if_6633
.annotate 'line', 2383
    find_lex $P6656, "$past"
    unless_null $P6656, vivify_3006
    new $P6656, "Undef"
  vivify_3006:
    find_lex $P6657, "$expr"
    unless_null $P6657, vivify_3007
    new $P6657, "Undef"
  vivify_3007:
    $P6658 = $P6656."push"($P6657)
    set $P6632, $P6658
.annotate 'line', 2380
    goto if_6633_end
  if_6633:
.annotate 'line', 2381
    find_lex $P6643, "$expr"
    unless_null $P6643, vivify_3008
    new $P6643, "Undef"
  vivify_3008:
    $P6644 = $P6643."list"()
    defined $I6645, $P6644
    unless $I6645, for_undef_3009
    iter $P6642, $P6644
    new $P6654, 'ExceptionHandler'
    set_label $P6654, loop6653_handler
    $P6654."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P6654
  loop6653_test:
    unless $P6642, loop6653_done
    shift $P6646, $P6642
  loop6653_redo:
    .const 'Sub' $P6648 = "582_1307873304.82979" 
    capture_lex $P6648
    $P6648($P6646)
  loop6653_next:
    goto loop6653_test
  loop6653_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P6655, exception, 'type'
    eq $P6655, .CONTROL_LOOP_NEXT, loop6653_next
    eq $P6655, .CONTROL_LOOP_REDO, loop6653_redo
  loop6653_done:
    pop_eh 
  for_undef_3009:
.annotate 'line', 2380
    set $P6632, $P6642
  if_6633_end:
.annotate 'line', 2378
    .return ($P6632)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6647"  :anon :subid("582_1307873304.82979") :outer("581_1307873304.82979")
    .param pmc param_6649
.annotate 'line', 2381
    .lex "$_", param_6649
    find_lex $P6650, "$past"
    unless_null $P6650, vivify_3010
    new $P6650, "Undef"
  vivify_3010:
    find_lex $P6651, "$_"
    unless_null $P6651, vivify_3011
    new $P6651, "Undef"
  vivify_3011:
    $P6652 = $P6650."push"($P6651)
    .return ($P6652)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<multi_declarator>" :anon :subid("583_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_6720
    .param pmc param_6721
.annotate 'line', 2401
    .lex "self", param_6720
    .lex "$/", param_6721
    find_lex $P6722, "$/"
    find_lex $P6723, "$/"
    unless_null $P6723, vivify_3038
    $P6723 = root_new ['parrot';'Hash']
  vivify_3038:
    set $P6724, $P6723["multi_declarator"]
    unless_null $P6724, vivify_3039
    new $P6724, "Undef"
  vivify_3039:
    $P6725 = $P6724."ast"()
    $P6726 = $P6722."!make"($P6725)
    .return ($P6726)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<value>" :anon :subid("584_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_6728
    .param pmc param_6729
.annotate 'line', 2403
    .lex "self", param_6728
    .lex "$/", param_6729
    find_lex $P6730, "$/"
    find_lex $P6731, "$/"
    unless_null $P6731, vivify_3040
    $P6731 = root_new ['parrot';'Hash']
  vivify_3040:
    set $P6732, $P6731["value"]
    unless_null $P6732, vivify_3041
    new $P6732, "Undef"
  vivify_3041:
    $P6733 = $P6732."ast"()
    $P6734 = $P6730."!make"($P6733)
    .return ($P6734)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<( )>" :anon :subid("585_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_6736
    .param pmc param_6737
.annotate 'line', 2405
    .lex "self", param_6736
    .lex "$/", param_6737
.annotate 'line', 2406
    find_lex $P6738, "$/"
.annotate 'line', 2407
    find_lex $P6741, "$/"
    unless_null $P6741, vivify_3042
    $P6741 = root_new ['parrot';'Hash']
  vivify_3042:
    set $P6742, $P6741["EXPR"]
    unless_null $P6742, vivify_3043
    new $P6742, "Undef"
  vivify_3043:
    if $P6742, if_6740
.annotate 'line', 2408
    get_hll_global $P6747, "GLOBAL"
    nqp_get_package_through_who $P6748, $P6747, "PAST"
    get_who $P6749, $P6748
    set $P6750, $P6749["Op"]
    find_lex $P6751, "$/"
    unless_null $P6751, vivify_3044
    new $P6751, "Undef"
  vivify_3044:
    $P6752 = $P6750."new"("list" :named("pasttype"), $P6751 :named("node"))
    set $P6739, $P6752
.annotate 'line', 2407
    goto if_6740_end
  if_6740:
    find_lex $P6743, "$/"
    unless_null $P6743, vivify_3045
    $P6743 = root_new ['parrot';'Hash']
  vivify_3045:
    set $P6744, $P6743["EXPR"]
    unless_null $P6744, vivify_3046
    $P6744 = root_new ['parrot';'ResizablePMCArray']
  vivify_3046:
    set $P6745, $P6744[0]
    unless_null $P6745, vivify_3047
    new $P6745, "Undef"
  vivify_3047:
    $P6746 = $P6745."ast"()
    set $P6739, $P6746
  if_6740_end:
    $P6753 = $P6738."!make"($P6739)
.annotate 'line', 2405
    .return ($P6753)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<[ ]>" :anon :subid("586_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_6755
    .param pmc param_6756
.annotate 'line', 2411
    .lex "self", param_6755
    .lex "$/", param_6756
.annotate 'line', 2412
    new $P6757, "Undef"
    .lex "$past", $P6757
.annotate 'line', 2411
    find_lex $P6758, "$past"
    unless_null $P6758, vivify_3048
    new $P6758, "Undef"
  vivify_3048:
.annotate 'line', 2413
    find_lex $P6760, "$/"
    unless_null $P6760, vivify_3049
    $P6760 = root_new ['parrot';'Hash']
  vivify_3049:
    set $P6761, $P6760["EXPR"]
    unless_null $P6761, vivify_3050
    new $P6761, "Undef"
  vivify_3050:
    if $P6761, if_6759
.annotate 'line', 2420
    get_hll_global $P6776, "GLOBAL"
    nqp_get_package_through_who $P6777, $P6776, "PAST"
    get_who $P6778, $P6777
    set $P6779, $P6778["Op"]
    $P6780 = $P6779."new"("list" :named("pasttype"))
    store_lex "$past", $P6780
.annotate 'line', 2419
    goto if_6759_end
  if_6759:
.annotate 'line', 2414
    find_lex $P6762, "$/"
    unless_null $P6762, vivify_3051
    $P6762 = root_new ['parrot';'Hash']
  vivify_3051:
    set $P6763, $P6762["EXPR"]
    unless_null $P6763, vivify_3052
    $P6763 = root_new ['parrot';'ResizablePMCArray']
  vivify_3052:
    set $P6764, $P6763[0]
    unless_null $P6764, vivify_3053
    new $P6764, "Undef"
  vivify_3053:
    $P6765 = $P6764."ast"()
    store_lex "$past", $P6765
.annotate 'line', 2415
    find_lex $P6767, "$past"
    unless_null $P6767, vivify_3054
    new $P6767, "Undef"
  vivify_3054:
    $S6768 = $P6767."name"()
    isne $I6769, $S6768, "&infix:<,>"
    unless $I6769, if_6766_end
.annotate 'line', 2416
    get_hll_global $P6770, "GLOBAL"
    nqp_get_package_through_who $P6771, $P6770, "PAST"
    get_who $P6772, $P6771
    set $P6773, $P6772["Op"]
    find_lex $P6774, "$past"
    unless_null $P6774, vivify_3055
    new $P6774, "Undef"
  vivify_3055:
    $P6775 = $P6773."new"($P6774, "list" :named("pasttype"))
    store_lex "$past", $P6775
  if_6766_end:
  if_6759_end:
.annotate 'line', 2422
    find_lex $P6781, "$past"
    unless_null $P6781, vivify_3056
    new $P6781, "Undef"
  vivify_3056:
    $P6781."name"("&circumfix:<[ ]>")
.annotate 'line', 2423
    find_lex $P6782, "$/"
    find_lex $P6783, "$past"
    unless_null $P6783, vivify_3057
    new $P6783, "Undef"
  vivify_3057:
    $P6784 = $P6782."!make"($P6783)
.annotate 'line', 2411
    .return ($P6784)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<ang>" :anon :subid("587_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_6786
    .param pmc param_6787
.annotate 'line', 2426
    .lex "self", param_6786
    .lex "$/", param_6787
    find_lex $P6788, "$/"
    find_lex $P6789, "$/"
    unless_null $P6789, vivify_3058
    $P6789 = root_new ['parrot';'Hash']
  vivify_3058:
    set $P6790, $P6789["quote_EXPR"]
    unless_null $P6790, vivify_3059
    new $P6790, "Undef"
  vivify_3059:
    $P6791 = $P6790."ast"()
    $P6792 = $P6788."!make"($P6791)
    .return ($P6792)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>" :anon :subid("588_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_6794
    .param pmc param_6795
.annotate 'line', 2427
    .lex "self", param_6794
    .lex "$/", param_6795
    find_lex $P6796, "$/"
    find_lex $P6797, "$/"
    unless_null $P6797, vivify_3060
    $P6797 = root_new ['parrot';'Hash']
  vivify_3060:
    set $P6798, $P6797["quote_EXPR"]
    unless_null $P6798, vivify_3061
    new $P6798, "Undef"
  vivify_3061:
    $P6799 = $P6798."ast"()
    $P6800 = $P6796."!make"($P6799)
    .return ($P6800)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<{ }>" :anon :subid("589_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_6802
    .param pmc param_6803
.annotate 'line', 2429
    .const 'Sub' $P6814 = "590_1307873304.82979" 
    capture_lex $P6814
    .lex "self", param_6802
    .lex "$/", param_6803
.annotate 'line', 2430
    find_lex $P6806, "$/"
    unless_null $P6806, vivify_3062
    $P6806 = root_new ['parrot';'Hash']
  vivify_3062:
    set $P6807, $P6806["pblock"]
    unless_null $P6807, vivify_3063
    $P6807 = root_new ['parrot';'Hash']
  vivify_3063:
    set $P6808, $P6807["blockoid"]
    unless_null $P6808, vivify_3064
    $P6808 = root_new ['parrot';'Hash']
  vivify_3064:
    set $P6809, $P6808["statementlist"]
    unless_null $P6809, vivify_3065
    $P6809 = root_new ['parrot';'Hash']
  vivify_3065:
    set $P6810, $P6809["statement"]
    unless_null $P6810, vivify_3066
    new $P6810, "Undef"
  vivify_3066:
    set $N6811, $P6810
    isgt $I6812, $N6811, 0.0
    if $I6812, if_6805
.annotate 'line', 2435
    find_lex $P6827, "$/"
    unless_null $P6827, vivify_3067
    $P6827 = root_new ['parrot';'Hash']
  vivify_3067:
    set $P6828, $P6827["pblock"]
    unless_null $P6828, vivify_3068
    $P6828 = root_new ['parrot';'Hash']
  vivify_3068:
    set $P6829, $P6828["blockoid"]
    unless_null $P6829, vivify_3069
    $P6829 = root_new ['parrot';'Hash']
  vivify_3069:
    set $P6830, $P6829["you_are_here"]
    unless_null $P6830, vivify_3070
    new $P6830, "Undef"
  vivify_3070:
    if $P6830, if_6826
.annotate 'line', 2439
    find_lex $P6836, "$/"
    $P6837 = "vivitype"("%")
    $P6838 = $P6836."!make"($P6837)
.annotate 'line', 2438
    set $P6825, $P6838
.annotate 'line', 2435
    goto if_6826_end
  if_6826:
.annotate 'line', 2436
    find_lex $P6831, "$/"
    find_lex $P6832, "$/"
    unless_null $P6832, vivify_3071
    $P6832 = root_new ['parrot';'Hash']
  vivify_3071:
    set $P6833, $P6832["pblock"]
    unless_null $P6833, vivify_3072
    new $P6833, "Undef"
  vivify_3072:
    $P6834 = $P6833."ast"()
    $P6835 = $P6831."!make"($P6834)
.annotate 'line', 2435
    set $P6825, $P6835
  if_6826_end:
    set $P6804, $P6825
.annotate 'line', 2430
    goto if_6805_end
  if_6805:
    .const 'Sub' $P6814 = "590_1307873304.82979" 
    capture_lex $P6814
    $P6824 = $P6814()
    set $P6804, $P6824
  if_6805_end:
.annotate 'line', 2429
    .return ($P6804)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6813"  :anon :subid("590_1307873304.82979") :outer("589_1307873304.82979")
.annotate 'line', 2431
    new $P6815, "Undef"
    .lex "$past", $P6815
    find_lex $P6816, "$/"
    unless_null $P6816, vivify_3073
    $P6816 = root_new ['parrot';'Hash']
  vivify_3073:
    set $P6817, $P6816["pblock"]
    unless_null $P6817, vivify_3074
    new $P6817, "Undef"
  vivify_3074:
    $P6818 = $P6817."ast"()
    store_lex "$past", $P6818
.annotate 'line', 2432
    new $P6819, "Integer"
    assign $P6819, 1
    find_lex $P6820, "$past"
    unless_null $P6820, vivify_3075
    $P6820 = root_new ['parrot';'Hash']
    store_lex "$past", $P6820
  vivify_3075:
    set $P6820["bareblock"], $P6819
.annotate 'line', 2433
    find_dynamic_lex $P6821, "$/"
    find_lex $P6822, "$past"
    unless_null $P6822, vivify_3076
    new $P6822, "Undef"
  vivify_3076:
    $P6823 = $P6821."!make"($P6822)
.annotate 'line', 2430
    .return ($P6823)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<sigil>" :anon :subid("591_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_6840
    .param pmc param_6841
.annotate 'line', 2443
    .lex "self", param_6840
    .lex "$/", param_6841
.annotate 'line', 2444
    new $P6842, "Undef"
    .lex "$name", $P6842
    find_lex $P6845, "$/"
    unless_null $P6845, vivify_3077
    $P6845 = root_new ['parrot';'Hash']
  vivify_3077:
    set $P6846, $P6845["sigil"]
    unless_null $P6846, vivify_3078
    new $P6846, "Undef"
  vivify_3078:
    set $S6847, $P6846
    iseq $I6848, $S6847, "@"
    if $I6848, if_6844
.annotate 'line', 2445
    find_lex $P6852, "$/"
    unless_null $P6852, vivify_3079
    $P6852 = root_new ['parrot';'Hash']
  vivify_3079:
    set $P6853, $P6852["sigil"]
    unless_null $P6853, vivify_3080
    new $P6853, "Undef"
  vivify_3080:
    set $S6854, $P6853
    iseq $I6855, $S6854, "%"
    if $I6855, if_6851
    new $P6857, "String"
    assign $P6857, "item"
    set $P6850, $P6857
    goto if_6851_end
  if_6851:
    new $P6856, "String"
    assign $P6856, "hash"
    set $P6850, $P6856
  if_6851_end:
    set $P6843, $P6850
.annotate 'line', 2444
    goto if_6844_end
  if_6844:
    new $P6849, "String"
    assign $P6849, "list"
    set $P6843, $P6849
  if_6844_end:
    store_lex "$name", $P6843
.annotate 'line', 2447
    find_lex $P6858, "$/"
    get_hll_global $P6859, "GLOBAL"
    nqp_get_package_through_who $P6860, $P6859, "PAST"
    get_who $P6861, $P6860
    set $P6862, $P6861["Op"]
    find_lex $P6863, "$name"
    unless_null $P6863, vivify_3081
    new $P6863, "Undef"
  vivify_3081:
    find_lex $P6864, "$/"
    unless_null $P6864, vivify_3082
    $P6864 = root_new ['parrot';'Hash']
  vivify_3082:
    set $P6865, $P6864["semilist"]
    unless_null $P6865, vivify_3083
    new $P6865, "Undef"
  vivify_3083:
    $P6866 = $P6865."ast"()
    $P6867 = $P6862."new"($P6866, "callmethod" :named("pasttype"), $P6863 :named("name"))
    $P6868 = $P6858."!make"($P6867)
.annotate 'line', 2443
    .return ($P6868)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "semilist" :anon :subid("592_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_6870
    .param pmc param_6871
.annotate 'line', 2450
    .lex "self", param_6870
    .lex "$/", param_6871
    find_lex $P6872, "$/"
    find_lex $P6873, "$/"
    unless_null $P6873, vivify_3084
    $P6873 = root_new ['parrot';'Hash']
  vivify_3084:
    set $P6874, $P6873["statement"]
    unless_null $P6874, vivify_3085
    new $P6874, "Undef"
  vivify_3085:
    $P6875 = $P6874."ast"()
    $P6876 = $P6872."!make"($P6875)
    .return ($P6876)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<[ ]>" :anon :subid("593_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_6878
    .param pmc param_6879
.annotate 'line', 2452
    .lex "self", param_6878
    .lex "$/", param_6879
.annotate 'line', 2453
    find_lex $P6880, "$/"
    get_hll_global $P6881, "GLOBAL"
    nqp_get_package_through_who $P6882, $P6881, "PAST"
    get_who $P6883, $P6882
    set $P6884, $P6883["Var"]
    find_lex $P6885, "$/"
    unless_null $P6885, vivify_3086
    $P6885 = root_new ['parrot';'Hash']
  vivify_3086:
    set $P6886, $P6885["EXPR"]
    unless_null $P6886, vivify_3087
    new $P6886, "Undef"
  vivify_3087:
    $P6887 = $P6886."ast"()
.annotate 'line', 2455
    $P6888 = "vivitype"("@")
    $P6889 = $P6884."new"($P6887, "keyed_int" :named("scope"), "Undef" :named("viviself"), $P6888 :named("vivibase"))
.annotate 'line', 2453
    $P6890 = $P6880."!make"($P6889)
.annotate 'line', 2452
    .return ($P6890)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<{ }>" :anon :subid("594_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_6892
    .param pmc param_6893
.annotate 'line', 2458
    .lex "self", param_6892
    .lex "$/", param_6893
.annotate 'line', 2459
    find_lex $P6894, "$/"
    get_hll_global $P6895, "GLOBAL"
    nqp_get_package_through_who $P6896, $P6895, "PAST"
    get_who $P6897, $P6896
    set $P6898, $P6897["Var"]
    find_lex $P6899, "$/"
    unless_null $P6899, vivify_3088
    $P6899 = root_new ['parrot';'Hash']
  vivify_3088:
    set $P6900, $P6899["EXPR"]
    unless_null $P6900, vivify_3089
    new $P6900, "Undef"
  vivify_3089:
    $P6901 = $P6900."ast"()
.annotate 'line', 2461
    $P6902 = "vivitype"("%")
    $P6903 = $P6898."new"($P6901, "keyed" :named("scope"), "Undef" :named("viviself"), $P6902 :named("vivibase"))
.annotate 'line', 2459
    $P6904 = $P6894."!make"($P6903)
.annotate 'line', 2458
    .return ($P6904)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<ang>" :anon :subid("595_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_6906
    .param pmc param_6907
.annotate 'line', 2464
    .lex "self", param_6906
    .lex "$/", param_6907
.annotate 'line', 2465
    find_lex $P6908, "$/"
    get_hll_global $P6909, "GLOBAL"
    nqp_get_package_through_who $P6910, $P6909, "PAST"
    get_who $P6911, $P6910
    set $P6912, $P6911["Var"]
    find_lex $P6913, "$/"
    unless_null $P6913, vivify_3090
    $P6913 = root_new ['parrot';'Hash']
  vivify_3090:
    set $P6914, $P6913["quote_EXPR"]
    unless_null $P6914, vivify_3091
    new $P6914, "Undef"
  vivify_3091:
    $P6915 = $P6914."ast"()
.annotate 'line', 2467
    $P6916 = "vivitype"("%")
    $P6917 = $P6912."new"($P6915, "keyed" :named("scope"), "Undef" :named("viviself"), $P6916 :named("vivibase"))
.annotate 'line', 2465
    $P6918 = $P6908."!make"($P6917)
.annotate 'line', 2464
    .return ($P6918)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<( )>" :anon :subid("596_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_6920
    .param pmc param_6921
.annotate 'line', 2470
    .lex "self", param_6920
    .lex "$/", param_6921
.annotate 'line', 2471
    find_lex $P6922, "$/"
    find_lex $P6923, "$/"
    unless_null $P6923, vivify_3092
    $P6923 = root_new ['parrot';'Hash']
  vivify_3092:
    set $P6924, $P6923["arglist"]
    unless_null $P6924, vivify_3093
    new $P6924, "Undef"
  vivify_3093:
    $P6925 = $P6924."ast"()
    $P6926 = $P6922."!make"($P6925)
.annotate 'line', 2470
    .return ($P6926)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "value" :anon :subid("597_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_6928
    .param pmc param_6929
.annotate 'line', 2474
    .lex "self", param_6928
    .lex "$/", param_6929
.annotate 'line', 2475
    find_lex $P6930, "$/"
    find_lex $P6933, "$/"
    unless_null $P6933, vivify_3094
    $P6933 = root_new ['parrot';'Hash']
  vivify_3094:
    set $P6934, $P6933["quote"]
    unless_null $P6934, vivify_3095
    new $P6934, "Undef"
  vivify_3095:
    if $P6934, if_6932
    find_lex $P6938, "$/"
    unless_null $P6938, vivify_3096
    $P6938 = root_new ['parrot';'Hash']
  vivify_3096:
    set $P6939, $P6938["number"]
    unless_null $P6939, vivify_3097
    new $P6939, "Undef"
  vivify_3097:
    $P6940 = $P6939."ast"()
    set $P6931, $P6940
    goto if_6932_end
  if_6932:
    find_lex $P6935, "$/"
    unless_null $P6935, vivify_3098
    $P6935 = root_new ['parrot';'Hash']
  vivify_3098:
    set $P6936, $P6935["quote"]
    unless_null $P6936, vivify_3099
    new $P6936, "Undef"
  vivify_3099:
    $P6937 = $P6936."ast"()
    set $P6931, $P6937
  if_6932_end:
    $P6941 = $P6930."!make"($P6931)
.annotate 'line', 2474
    .return ($P6941)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "number" :anon :subid("598_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_6943
    .param pmc param_6944
.annotate 'line', 2478
    .lex "self", param_6943
    .lex "$/", param_6944
.annotate 'line', 2479
    new $P6945, "Undef"
    .lex "$value", $P6945
    find_lex $P6948, "$/"
    unless_null $P6948, vivify_3100
    $P6948 = root_new ['parrot';'Hash']
  vivify_3100:
    set $P6949, $P6948["dec_number"]
    unless_null $P6949, vivify_3101
    new $P6949, "Undef"
  vivify_3101:
    if $P6949, if_6947
    find_lex $P6953, "$/"
    unless_null $P6953, vivify_3102
    $P6953 = root_new ['parrot';'Hash']
  vivify_3102:
    set $P6954, $P6953["integer"]
    unless_null $P6954, vivify_3103
    new $P6954, "Undef"
  vivify_3103:
    $P6955 = $P6954."ast"()
    set $P6946, $P6955
    goto if_6947_end
  if_6947:
    find_lex $P6950, "$/"
    unless_null $P6950, vivify_3104
    $P6950 = root_new ['parrot';'Hash']
  vivify_3104:
    set $P6951, $P6950["dec_number"]
    unless_null $P6951, vivify_3105
    new $P6951, "Undef"
  vivify_3105:
    $P6952 = $P6951."ast"()
    set $P6946, $P6952
  if_6947_end:
    store_lex "$value", $P6946
.annotate 'line', 2480
    find_lex $P6957, "$/"
    unless_null $P6957, vivify_3106
    $P6957 = root_new ['parrot';'Hash']
  vivify_3106:
    set $P6958, $P6957["sign"]
    unless_null $P6958, vivify_3107
    new $P6958, "Undef"
  vivify_3107:
    set $S6959, $P6958
    iseq $I6960, $S6959, "-"
    unless $I6960, if_6956_end
    find_lex $P6961, "$value"
    unless_null $P6961, vivify_3108
    new $P6961, "Undef"
  vivify_3108:
    neg $P6962, $P6961
    store_lex "$value", $P6962
  if_6956_end:
.annotate 'line', 2481
    find_lex $P6963, "$/"
    get_hll_global $P6964, "GLOBAL"
    nqp_get_package_through_who $P6965, $P6964, "PAST"
    get_who $P6966, $P6965
    set $P6967, $P6966["Val"]
    find_lex $P6968, "$value"
    unless_null $P6968, vivify_3109
    new $P6968, "Undef"
  vivify_3109:
    $P6969 = $P6967."new"($P6968 :named("value"))
    $P6970 = $P6963."!make"($P6969)
.annotate 'line', 2478
    .return ($P6970)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<apos>" :anon :subid("599_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_6972
    .param pmc param_6973
.annotate 'line', 2484
    .lex "self", param_6972
    .lex "$/", param_6973
    find_lex $P6974, "$/"
    find_lex $P6975, "$/"
    unless_null $P6975, vivify_3110
    $P6975 = root_new ['parrot';'Hash']
  vivify_3110:
    set $P6976, $P6975["quote_EXPR"]
    unless_null $P6976, vivify_3111
    new $P6976, "Undef"
  vivify_3111:
    $P6977 = $P6976."ast"()
    $P6978 = $P6974."!make"($P6977)
    .return ($P6978)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<dblq>" :anon :subid("600_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_6980
    .param pmc param_6981
.annotate 'line', 2485
    .lex "self", param_6980
    .lex "$/", param_6981
    find_lex $P6982, "$/"
    find_lex $P6983, "$/"
    unless_null $P6983, vivify_3112
    $P6983 = root_new ['parrot';'Hash']
  vivify_3112:
    set $P6984, $P6983["quote_EXPR"]
    unless_null $P6984, vivify_3113
    new $P6984, "Undef"
  vivify_3113:
    $P6985 = $P6984."ast"()
    $P6986 = $P6982."!make"($P6985)
    .return ($P6986)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<qq>" :anon :subid("601_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_6988
    .param pmc param_6989
.annotate 'line', 2486
    .lex "self", param_6988
    .lex "$/", param_6989
    find_lex $P6990, "$/"
    find_lex $P6991, "$/"
    unless_null $P6991, vivify_3114
    $P6991 = root_new ['parrot';'Hash']
  vivify_3114:
    set $P6992, $P6991["quote_EXPR"]
    unless_null $P6992, vivify_3115
    new $P6992, "Undef"
  vivify_3115:
    $P6993 = $P6992."ast"()
    $P6994 = $P6990."!make"($P6993)
    .return ($P6994)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<q>" :anon :subid("602_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_6996
    .param pmc param_6997
.annotate 'line', 2487
    .lex "self", param_6996
    .lex "$/", param_6997
    find_lex $P6998, "$/"
    find_lex $P6999, "$/"
    unless_null $P6999, vivify_3116
    $P6999 = root_new ['parrot';'Hash']
  vivify_3116:
    set $P7000, $P6999["quote_EXPR"]
    unless_null $P7000, vivify_3117
    new $P7000, "Undef"
  vivify_3117:
    $P7001 = $P7000."ast"()
    $P7002 = $P6998."!make"($P7001)
    .return ($P7002)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q>" :anon :subid("603_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_7004
    .param pmc param_7005
.annotate 'line', 2488
    .lex "self", param_7004
    .lex "$/", param_7005
    find_lex $P7006, "$/"
    find_lex $P7007, "$/"
    unless_null $P7007, vivify_3118
    $P7007 = root_new ['parrot';'Hash']
  vivify_3118:
    set $P7008, $P7007["quote_EXPR"]
    unless_null $P7008, vivify_3119
    new $P7008, "Undef"
  vivify_3119:
    $P7009 = $P7008."ast"()
    $P7010 = $P7006."!make"($P7009)
    .return ($P7010)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q:PIR>" :anon :subid("604_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_7012
    .param pmc param_7013
.annotate 'line', 2489
    .lex "self", param_7012
    .lex "$/", param_7013
.annotate 'line', 2490
    find_lex $P7014, "$/"
    get_hll_global $P7015, "GLOBAL"
    nqp_get_package_through_who $P7016, $P7015, "PAST"
    get_who $P7017, $P7016
    set $P7018, $P7017["Op"]
    find_lex $P7019, "$/"
    unless_null $P7019, vivify_3120
    $P7019 = root_new ['parrot';'Hash']
  vivify_3120:
    set $P7020, $P7019["quote_EXPR"]
    unless_null $P7020, vivify_3121
    new $P7020, "Undef"
  vivify_3121:
    $P7021 = $P7020."ast"()
    $P7022 = $P7021."value"()
    find_lex $P7023, "$/"
    unless_null $P7023, vivify_3122
    new $P7023, "Undef"
  vivify_3122:
    $P7024 = $P7018."new"($P7022 :named("inline"), "inline" :named("pasttype"), $P7023 :named("node"))
    $P7025 = $P7014."!make"($P7024)
.annotate 'line', 2489
    .return ($P7025)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "quote:sym</ />" :anon :subid("605_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_7029
    .param pmc param_7030
    .param pmc param_7031 :optional
    .param int has_param_7031 :opt_flag
.annotate 'line', 2495
    new $P7028, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P7028, control_7027
    push_eh $P7028
    .lex "self", param_7029
    .lex "$/", param_7030
    if has_param_7031, optparam_3123
    new $P7032, "Undef"
    set param_7031, $P7032
  optparam_3123:
    .lex "$key", param_7031
.annotate 'line', 2502
    new $P7033, "Undef"
    .lex "$regex", $P7033
.annotate 'line', 2504
    new $P7034, "Undef"
    .lex "$past", $P7034
.annotate 'line', 2496
    find_lex $P7036, "$key"
    unless_null $P7036, vivify_3124
    new $P7036, "Undef"
  vivify_3124:
    set $S7037, $P7036
    iseq $I7038, $S7037, "open"
    unless $I7038, if_7035_end
.annotate 'line', 2497
    null $P7039
    get_hll_global $P7040, "GLOBAL"
    nqp_get_package_through_who $P7041, $P7040, "Regex"
    nqp_get_package_through_who $P7042, $P7041, "P6Regex"
    nqp_get_package_through_who $P7043, $P7042, "Actions"
    get_who $P7044, $P7043
    set $P7044["$REGEXNAME"], $P7039
.annotate 'line', 2498
    find_lex $P7045, "$?PACKAGE"
    get_who $P7046, $P7045
    set $P7047, $P7046["@BLOCK"]
    unless_null $P7047, vivify_3125
    $P7047 = root_new ['parrot';'ResizablePMCArray']
  vivify_3125:
    set $P7048, $P7047[0]
    unless_null $P7048, vivify_3126
    new $P7048, "Undef"
  vivify_3126:
    $P7048."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 2499
    find_lex $P7049, "$?PACKAGE"
    get_who $P7050, $P7049
    set $P7051, $P7050["@BLOCK"]
    unless_null $P7051, vivify_3127
    $P7051 = root_new ['parrot';'ResizablePMCArray']
  vivify_3127:
    set $P7052, $P7051[0]
    unless_null $P7052, vivify_3128
    new $P7052, "Undef"
  vivify_3128:
    $P7052."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 2500
    new $P7053, "Exception"
    set $P7053['type'], .CONTROL_RETURN
    new $P7054, "Integer"
    assign $P7054, 0
    setattribute $P7053, 'payload', $P7054
    throw $P7053
  if_7035_end:
.annotate 'line', 2503
    get_hll_global $P7055, "GLOBAL"
    nqp_get_package_through_who $P7056, $P7055, "Regex"
    nqp_get_package_through_who $P7057, $P7056, "P6Regex"
    nqp_get_package_through_who $P7058, $P7057, "Actions"
    get_who $P7059, $P7058
    set $P7060, $P7059["buildsub"]
    find_lex $P7061, "$/"
    unless_null $P7061, vivify_3129
    $P7061 = root_new ['parrot';'Hash']
  vivify_3129:
    set $P7062, $P7061["p6regex"]
    unless_null $P7062, vivify_3130
    new $P7062, "Undef"
  vivify_3130:
    $P7063 = $P7062."ast"()
    find_lex $P7064, "$?PACKAGE"
    get_who $P7065, $P7064
    set $P7066, $P7065["@BLOCK"]
    unless_null $P7066, vivify_3131
    $P7066 = root_new ['parrot';'ResizablePMCArray']
  vivify_3131:
    $P7067 = $P7066."shift"()
    $P7068 = $P7060($P7063, $P7067)
    store_lex "$regex", $P7068
.annotate 'line', 2505
    get_hll_global $P7069, "GLOBAL"
    nqp_get_package_through_who $P7070, $P7069, "PAST"
    get_who $P7071, $P7070
    set $P7072, $P7071["Op"]
.annotate 'line', 2507
    new $P7073, "ResizablePMCArray"
    push $P7073, "Regex"
    push $P7073, "Regex"
    find_lex $P7074, "$/"
    unless_null $P7074, vivify_3132
    new $P7074, "Undef"
  vivify_3132:
    $P7075 = "lexical_package_lookup"($P7073, $P7074)
    find_lex $P7076, "$regex"
    unless_null $P7076, vivify_3133
    new $P7076, "Undef"
  vivify_3133:
    $P7077 = $P7072."new"($P7075, $P7076, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 2505
    store_lex "$past", $P7077
.annotate 'line', 2511
    find_lex $P7078, "$regex"
    unless_null $P7078, vivify_3134
    new $P7078, "Undef"
  vivify_3134:
    find_lex $P7079, "$past"
    unless_null $P7079, vivify_3135
    $P7079 = root_new ['parrot';'Hash']
    store_lex "$past", $P7079
  vivify_3135:
    set $P7079["sink"], $P7078
.annotate 'line', 2512
    find_lex $P7080, "$/"
    find_lex $P7081, "$past"
    unless_null $P7081, vivify_3136
    new $P7081, "Undef"
  vivify_3136:
    $P7082 = $P7080."!make"($P7081)
.annotate 'line', 2495
    .return ($P7082)
  control_7027:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P7083, exception, "payload"
    .return ($P7083)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<$>" :anon :subid("606_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_7085
    .param pmc param_7086
.annotate 'line', 2515
    .lex "self", param_7085
    .lex "$/", param_7086
    find_lex $P7087, "$/"
    find_lex $P7088, "$/"
    unless_null $P7088, vivify_3137
    $P7088 = root_new ['parrot';'Hash']
  vivify_3137:
    set $P7089, $P7088["variable"]
    unless_null $P7089, vivify_3138
    new $P7089, "Undef"
  vivify_3138:
    $P7090 = $P7089."ast"()
    $P7091 = $P7087."!make"($P7090)
    .return ($P7091)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<{ }>" :anon :subid("607_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_7093
    .param pmc param_7094
.annotate 'line', 2516
    .lex "self", param_7093
    .lex "$/", param_7094
.annotate 'line', 2517
    find_lex $P7095, "$/"
    get_hll_global $P7096, "GLOBAL"
    nqp_get_package_through_who $P7097, $P7096, "PAST"
    get_who $P7098, $P7097
    set $P7099, $P7098["Op"]
.annotate 'line', 2518
    find_lex $P7100, "$/"
    unless_null $P7100, vivify_3139
    $P7100 = root_new ['parrot';'Hash']
  vivify_3139:
    set $P7101, $P7100["block"]
    unless_null $P7101, vivify_3140
    new $P7101, "Undef"
  vivify_3140:
    $P7102 = $P7101."ast"()
    $P7103 = "block_immediate"($P7102)
    find_lex $P7104, "$/"
    unless_null $P7104, vivify_3141
    new $P7104, "Undef"
  vivify_3141:
    $P7105 = $P7099."new"($P7103, "set S*" :named("pirop"), $P7104 :named("node"))
.annotate 'line', 2517
    $P7106 = $P7095."!make"($P7105)
.annotate 'line', 2516
    .return ($P7106)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<esc>" :anon :subid("608_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_7108
    .param pmc param_7109
.annotate 'line', 2521
    .lex "self", param_7108
    .lex "$/", param_7109
    find_lex $P7110, "$/"
    $P7111 = $P7110."!make"("\e")
    .return ($P7111)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<.>" :anon :subid("609_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_7113
    .param pmc param_7114
.annotate 'line', 2525
    .lex "self", param_7113
    .lex "$/", param_7114
    find_lex $P7115, "$/"
    find_lex $P7116, "$/"
    unless_null $P7116, vivify_3142
    $P7116 = root_new ['parrot';'Hash']
  vivify_3142:
    set $P7117, $P7116["dotty"]
    unless_null $P7117, vivify_3143
    new $P7117, "Undef"
  vivify_3143:
    $P7118 = $P7117."ast"()
    $P7119 = $P7115."!make"($P7118)
    .return ($P7119)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<++>" :anon :subid("610_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_7121
    .param pmc param_7122
.annotate 'line', 2527
    .lex "self", param_7121
    .lex "$/", param_7122
.annotate 'line', 2528
    find_lex $P7123, "$/"
    get_hll_global $P7124, "GLOBAL"
    nqp_get_package_through_who $P7125, $P7124, "PAST"
    get_who $P7126, $P7125
    set $P7127, $P7126["Op"]
.annotate 'line', 2529
    new $P7128, "ResizablePMCArray"
    push $P7128, "    clone %r, %0"
    push $P7128, "    inc %0"
    $P7129 = $P7127."new"("postfix:<++>" :named("name"), $P7128 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 2528
    $P7130 = $P7123."!make"($P7129)
.annotate 'line', 2527
    .return ($P7130)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<-->" :anon :subid("611_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_7132
    .param pmc param_7133
.annotate 'line', 2533
    .lex "self", param_7132
    .lex "$/", param_7133
.annotate 'line', 2534
    find_lex $P7134, "$/"
    get_hll_global $P7135, "GLOBAL"
    nqp_get_package_through_who $P7136, $P7135, "PAST"
    get_who $P7137, $P7136
    set $P7138, $P7137["Op"]
.annotate 'line', 2535
    new $P7139, "ResizablePMCArray"
    push $P7139, "    clone %r, %0"
    push $P7139, "    dec %0"
    $P7140 = $P7138."new"("postfix:<-->" :named("name"), $P7139 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 2534
    $P7141 = $P7134."!make"($P7140)
.annotate 'line', 2533
    .return ($P7141)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "prefix:sym<make>" :anon :subid("612_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_7143
    .param pmc param_7144
.annotate 'line', 2539
    .lex "self", param_7143
    .lex "$/", param_7144
.annotate 'line', 2540
    find_lex $P7145, "$/"
    get_hll_global $P7146, "GLOBAL"
    nqp_get_package_through_who $P7147, $P7146, "PAST"
    get_who $P7148, $P7147
    set $P7149, $P7148["Op"]
.annotate 'line', 2541
    get_hll_global $P7150, "GLOBAL"
    nqp_get_package_through_who $P7151, $P7150, "PAST"
    get_who $P7152, $P7151
    set $P7153, $P7152["Var"]
    $P7154 = $P7153."new"("$/" :named("name"), "contextual" :named("scope"))
    find_lex $P7155, "$/"
    unless_null $P7155, vivify_3144
    new $P7155, "Undef"
  vivify_3144:
    $P7156 = $P7149."new"($P7154, "callmethod" :named("pasttype"), "!make" :named("name"), $P7155 :named("node"))
.annotate 'line', 2540
    $P7157 = $P7145."!make"($P7156)
.annotate 'line', 2539
    .return ($P7157)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<next>" :anon :subid("613_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_7160
    .param pmc param_7161
.annotate 'line', 2557
    .lex "self", param_7160
    .lex "$/", param_7161
    find_lex $P7162, "$/"
    unless_null $P7162, vivify_3145
    new $P7162, "Undef"
  vivify_3145:
    $P7163 = "control"($P7162, "CONTROL_LOOP_NEXT")
    .return ($P7163)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<last>" :anon :subid("614_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_7165
    .param pmc param_7166
.annotate 'line', 2558
    .lex "self", param_7165
    .lex "$/", param_7166
    find_lex $P7167, "$/"
    unless_null $P7167, vivify_3146
    new $P7167, "Undef"
  vivify_3146:
    $P7168 = "control"($P7167, "CONTROL_LOOP_LAST")
    .return ($P7168)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<redo>" :anon :subid("615_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_7170
    .param pmc param_7171
.annotate 'line', 2559
    .lex "self", param_7170
    .lex "$/", param_7171
    find_lex $P7172, "$/"
    unless_null $P7172, vivify_3147
    new $P7172, "Undef"
  vivify_3147:
    $P7173 = "control"($P7172, "CONTROL_LOOP_REDO")
    .return ($P7173)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "infix:sym<~~>" :anon :subid("616_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_7175
    .param pmc param_7176
.annotate 'line', 2561
    .lex "self", param_7175
    .lex "$/", param_7176
.annotate 'line', 2562
    find_lex $P7177, "$/"
    get_hll_global $P7178, "GLOBAL"
    nqp_get_package_through_who $P7179, $P7178, "PAST"
    get_who $P7180, $P7179
    set $P7181, $P7180["Op"]
    find_lex $P7182, "$/"
    unless_null $P7182, vivify_3148
    new $P7182, "Undef"
  vivify_3148:
    $P7183 = $P7181."new"("callmethod" :named("pasttype"), "ACCEPTS" :named("name"), $P7182 :named("node"))
    $P7184 = $P7177."!make"($P7183)
.annotate 'line', 2561
    .return ($P7184)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "known_sym" :anon :subid("617_1307873304.82979") :outer("438_1307873304.82979")
    .param pmc param_7190
    .param pmc param_7191
    .param pmc param_7192
.annotate 'line', 2639
    .const 'Sub' $P7196 = "618_1307873304.82979" 
    capture_lex $P7196
    .lex "self", param_7190
    .lex "$/", param_7191
    .lex "@name", param_7192
.annotate 'line', 2640
    new $P7193, "Undef"
    .lex "$known", $P7193
    new $P7194, "Integer"
    assign $P7194, 0
    store_lex "$known", $P7194
.annotate 'line', 2641
    .const 'Sub' $P7196 = "618_1307873304.82979" 
    capture_lex $P7196
    $P7196()
    find_lex $P7207, "$known"
    unless_null $P7207, vivify_3151
    new $P7207, "Undef"
  vivify_3151:
.annotate 'line', 2639
    .return ($P7207)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block7195"  :anon :subid("618_1307873304.82979") :outer("617_1307873304.82979")
.annotate 'line', 2641
    new $P7202, 'ExceptionHandler'
    set_label $P7202, control_7201
    $P7202."handle_types_except"(.CONTROL_RETURN,  .CONTROL_OK,  .CONTROL_BREAK,  .CONTROL_CONTINUE,  .CONTROL_TAKE,  .CONTROL_LEAVE,  .CONTROL_EXIT,  .CONTROL_LOOP_NEXT,  .CONTROL_LOOP_LAST,  .CONTROL_LOOP_REDO)
    push_eh $P7202
.annotate 'line', 2642
    find_lex $P7197, "@name"
    unless_null $P7197, vivify_3149
    $P7197 = root_new ['parrot';'ResizablePMCArray']
  vivify_3149:
    find_lex $P7198, "$/"
    unless_null $P7198, vivify_3150
    new $P7198, "Undef"
  vivify_3150:
    "find_sym"($P7197, $P7198)
.annotate 'line', 2643
    new $P7199, "Integer"
    assign $P7199, 1
    store_lex "$known", $P7199
.annotate 'line', 2641
    pop_eh 
    goto skip_handler_7200
  control_7201:
    .local pmc exception 
    .get_results (exception) 
    new $P7205, 'Integer'
    set $P7205, 1
    set exception["handled"], $P7205
    set $I7206, exception["handled"]
    ne $I7206, 1, nothandled_7204
  handled_7203:
    .return (exception)
  nothandled_7204:
    rethrow exception
  skip_handler_7200:
    .return ($P7199)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "_block7209"  :subid("619_1307873304.82979") :outer("10_1307873304.82979")
.annotate 'line', 2708
    .const 'Sub' $P7303 = "626_1307873304.82979" 
    capture_lex $P7303
    .const 'Sub' $P7289 = "625_1307873304.82979" 
    capture_lex $P7289
    .const 'Sub' $P7271 = "624_1307873304.82979" 
    capture_lex $P7271
    .const 'Sub' $P7257 = "623_1307873304.82979" 
    capture_lex $P7257
    .const 'Sub' $P7243 = "622_1307873304.82979" 
    capture_lex $P7243
    .const 'Sub' $P7229 = "621_1307873304.82979" 
    capture_lex $P7229
    .const 'Sub' $P7213 = "620_1307873304.82979" 
    capture_lex $P7213
    .lex "$?PACKAGE", $P7211
    .lex "$?CLASS", $P7212
.annotate 'line', 2742
    .const 'Sub' $P7303 = "626_1307873304.82979" 
    newclosure $P7341, $P7303
.annotate 'line', 2708
    .return ($P7341)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<:my>" :anon :subid("620_1307873304.82979") :outer("619_1307873304.82979")
    .param pmc param_7214
    .param pmc param_7215
.annotate 'line', 2710
    .lex "self", param_7214
    .lex "$/", param_7215
.annotate 'line', 2711
    new $P7216, "Undef"
    .lex "$past", $P7216
    find_lex $P7217, "$/"
    unless_null $P7217, vivify_3152
    $P7217 = root_new ['parrot';'Hash']
  vivify_3152:
    set $P7218, $P7217["statement"]
    unless_null $P7218, vivify_3153
    new $P7218, "Undef"
  vivify_3153:
    $P7219 = $P7218."ast"()
    store_lex "$past", $P7219
.annotate 'line', 2712
    find_lex $P7220, "$/"
    get_hll_global $P7221, "GLOBAL"
    nqp_get_package_through_who $P7222, $P7221, "PAST"
    get_who $P7223, $P7222
    set $P7224, $P7223["Regex"]
    find_lex $P7225, "$past"
    unless_null $P7225, vivify_3154
    new $P7225, "Undef"
  vivify_3154:
    find_lex $P7226, "$/"
    unless_null $P7226, vivify_3155
    new $P7226, "Undef"
  vivify_3155:
    $P7227 = $P7224."new"($P7225, "pastnode" :named("pasttype"), "declarative" :named("subtype"), $P7226 :named("node"))
    $P7228 = $P7220."!make"($P7227)
.annotate 'line', 2710
    .return ($P7228)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<{ }>" :anon :subid("621_1307873304.82979") :outer("619_1307873304.82979")
    .param pmc param_7230
    .param pmc param_7231
.annotate 'line', 2716
    .lex "self", param_7230
    .lex "$/", param_7231
.annotate 'line', 2717
    find_lex $P7232, "$/"
    get_hll_global $P7233, "GLOBAL"
    nqp_get_package_through_who $P7234, $P7233, "PAST"
    get_who $P7235, $P7234
    set $P7236, $P7235["Regex"]
    find_lex $P7237, "$/"
    unless_null $P7237, vivify_3156
    $P7237 = root_new ['parrot';'Hash']
  vivify_3156:
    set $P7238, $P7237["codeblock"]
    unless_null $P7238, vivify_3157
    new $P7238, "Undef"
  vivify_3157:
    $P7239 = $P7238."ast"()
    find_lex $P7240, "$/"
    unless_null $P7240, vivify_3158
    new $P7240, "Undef"
  vivify_3158:
    $P7241 = $P7236."new"($P7239, "pastnode" :named("pasttype"), $P7240 :named("node"))
    $P7242 = $P7232."!make"($P7241)
.annotate 'line', 2716
    .return ($P7242)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<nqpvar>" :anon :subid("622_1307873304.82979") :outer("619_1307873304.82979")
    .param pmc param_7244
    .param pmc param_7245
.annotate 'line', 2721
    .lex "self", param_7244
    .lex "$/", param_7245
.annotate 'line', 2722
    find_lex $P7246, "$/"
    get_hll_global $P7247, "GLOBAL"
    nqp_get_package_through_who $P7248, $P7247, "PAST"
    get_who $P7249, $P7248
    set $P7250, $P7249["Regex"]
    find_lex $P7251, "$/"
    unless_null $P7251, vivify_3159
    $P7251 = root_new ['parrot';'Hash']
  vivify_3159:
    set $P7252, $P7251["var"]
    unless_null $P7252, vivify_3160
    new $P7252, "Undef"
  vivify_3160:
    $P7253 = $P7252."ast"()
    find_lex $P7254, "$/"
    unless_null $P7254, vivify_3161
    new $P7254, "Undef"
  vivify_3161:
    $P7255 = $P7250."new"("!INTERPOLATE", $P7253, "subrule" :named("pasttype"), "method" :named("subtype"), $P7254 :named("node"))
    $P7256 = $P7246."!make"($P7255)
.annotate 'line', 2721
    .return ($P7256)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<{ }>" :anon :subid("623_1307873304.82979") :outer("619_1307873304.82979")
    .param pmc param_7258
    .param pmc param_7259
.annotate 'line', 2726
    .lex "self", param_7258
    .lex "$/", param_7259
.annotate 'line', 2727
    find_lex $P7260, "$/"
    get_hll_global $P7261, "GLOBAL"
    nqp_get_package_through_who $P7262, $P7261, "PAST"
    get_who $P7263, $P7262
    set $P7264, $P7263["Regex"]
    find_lex $P7265, "$/"
    unless_null $P7265, vivify_3162
    $P7265 = root_new ['parrot';'Hash']
  vivify_3162:
    set $P7266, $P7265["codeblock"]
    unless_null $P7266, vivify_3163
    new $P7266, "Undef"
  vivify_3163:
    $P7267 = $P7266."ast"()
    find_lex $P7268, "$/"
    unless_null $P7268, vivify_3164
    new $P7268, "Undef"
  vivify_3164:
    $P7269 = $P7264."new"("!INTERPOLATE_REGEX", $P7267, "subrule" :named("pasttype"), "method" :named("subtype"), $P7268 :named("node"))
    $P7270 = $P7260."!make"($P7269)
.annotate 'line', 2726
    .return ($P7270)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<?{ }>" :anon :subid("624_1307873304.82979") :outer("619_1307873304.82979")
    .param pmc param_7272
    .param pmc param_7273
.annotate 'line', 2731
    .lex "self", param_7272
    .lex "$/", param_7273
.annotate 'line', 2732
    find_lex $P7274, "$/"
    get_hll_global $P7275, "GLOBAL"
    nqp_get_package_through_who $P7276, $P7275, "PAST"
    get_who $P7277, $P7276
    set $P7278, $P7277["Regex"]
    find_lex $P7279, "$/"
    unless_null $P7279, vivify_3165
    $P7279 = root_new ['parrot';'Hash']
  vivify_3165:
    set $P7280, $P7279["codeblock"]
    unless_null $P7280, vivify_3166
    new $P7280, "Undef"
  vivify_3166:
    $P7281 = $P7280."ast"()
.annotate 'line', 2733
    find_lex $P7282, "$/"
    unless_null $P7282, vivify_3167
    $P7282 = root_new ['parrot';'Hash']
  vivify_3167:
    set $P7283, $P7282["zw"]
    unless_null $P7283, vivify_3168
    new $P7283, "Undef"
  vivify_3168:
    set $S7284, $P7283
    iseq $I7285, $S7284, "!"
    find_lex $P7286, "$/"
    unless_null $P7286, vivify_3169
    new $P7286, "Undef"
  vivify_3169:
    $P7287 = $P7278."new"($P7281, "zerowidth" :named("subtype"), $I7285 :named("negate"), "pastnode" :named("pasttype"), $P7286 :named("node"))
.annotate 'line', 2732
    $P7288 = $P7274."!make"($P7287)
.annotate 'line', 2731
    .return ($P7288)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<var>" :anon :subid("625_1307873304.82979") :outer("619_1307873304.82979")
    .param pmc param_7290
    .param pmc param_7291
.annotate 'line', 2737
    .lex "self", param_7290
    .lex "$/", param_7291
.annotate 'line', 2738
    find_lex $P7292, "$/"
    get_hll_global $P7293, "GLOBAL"
    nqp_get_package_through_who $P7294, $P7293, "PAST"
    get_who $P7295, $P7294
    set $P7296, $P7295["Regex"]
    find_lex $P7297, "$/"
    unless_null $P7297, vivify_3170
    $P7297 = root_new ['parrot';'Hash']
  vivify_3170:
    set $P7298, $P7297["var"]
    unless_null $P7298, vivify_3171
    new $P7298, "Undef"
  vivify_3171:
    $P7299 = $P7298."ast"()
    find_lex $P7300, "$/"
    unless_null $P7300, vivify_3172
    new $P7300, "Undef"
  vivify_3172:
    $P7301 = $P7296."new"("!INTERPOLATE_REGEX", $P7299, "subrule" :named("pasttype"), "method" :named("subtype"), $P7300 :named("node"))
    $P7302 = $P7292."!make"($P7301)
.annotate 'line', 2737
    .return ($P7302)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "codeblock" :anon :subid("626_1307873304.82979") :outer("619_1307873304.82979")
    .param pmc param_7304
    .param pmc param_7305
.annotate 'line', 2742
    .lex "self", param_7304
    .lex "$/", param_7305
.annotate 'line', 2743
    new $P7306, "Undef"
    .lex "$block", $P7306
.annotate 'line', 2745
    new $P7307, "Undef"
    .lex "$past", $P7307
.annotate 'line', 2743
    find_lex $P7308, "$/"
    unless_null $P7308, vivify_3173
    $P7308 = root_new ['parrot';'Hash']
  vivify_3173:
    set $P7309, $P7308["block"]
    unless_null $P7309, vivify_3174
    new $P7309, "Undef"
  vivify_3174:
    $P7310 = $P7309."ast"()
    store_lex "$block", $P7310
.annotate 'line', 2744
    find_lex $P7311, "$block"
    unless_null $P7311, vivify_3175
    new $P7311, "Undef"
  vivify_3175:
    $P7311."blocktype"("immediate")
.annotate 'line', 2746
    get_hll_global $P7312, "GLOBAL"
    nqp_get_package_through_who $P7313, $P7312, "PAST"
    get_who $P7314, $P7313
    set $P7315, $P7314["Stmts"]
.annotate 'line', 2747
    get_hll_global $P7316, "GLOBAL"
    nqp_get_package_through_who $P7317, $P7316, "PAST"
    get_who $P7318, $P7317
    set $P7319, $P7318["Op"]
.annotate 'line', 2748
    get_hll_global $P7320, "GLOBAL"
    nqp_get_package_through_who $P7321, $P7320, "PAST"
    get_who $P7322, $P7321
    set $P7323, $P7322["Var"]
    $P7324 = $P7323."new"("$/" :named("name"))
.annotate 'line', 2749
    get_hll_global $P7325, "GLOBAL"
    nqp_get_package_through_who $P7326, $P7325, "PAST"
    get_who $P7327, $P7326
    set $P7328, $P7327["Op"]
.annotate 'line', 2750
    get_hll_global $P7329, "GLOBAL"
    nqp_get_package_through_who $P7330, $P7329, "PAST"
    get_who $P7331, $P7330
    set $P7332, $P7331["Var"]
    $P7333 = $P7332."new"(unicode:"$\x{a2}" :named("name"))
    $P7334 = $P7328."new"($P7333, "MATCH" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 2749
    $P7335 = $P7319."new"($P7324, $P7334, "bind_6model" :named("pasttype"))
.annotate 'line', 2747
    find_lex $P7336, "$block"
    unless_null $P7336, vivify_3176
    new $P7336, "Undef"
  vivify_3176:
    $P7337 = $P7315."new"($P7335, $P7336)
.annotate 'line', 2746
    store_lex "$past", $P7337
.annotate 'line', 2758
    find_lex $P7338, "$/"
    find_lex $P7339, "$past"
    unless_null $P7339, vivify_3177
    new $P7339, "Undef"
  vivify_3177:
    $P7340 = $P7338."!make"($P7339)
.annotate 'line', 2742
    .return ($P7340)
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "_block7342"  :subid("627_1307873304.82979") :outer("10_1307873304.82979")
.annotate 'line', 2763
    .lex "$?PACKAGE", $P7344
    .lex "$?CLASS", $P7345
    .return ()
.end


.HLL "nqp"

.namespace []
.sub "_block7357" :load :anon :subid("628_1307873304.82979")
.annotate 'line', 1
    .const 'Sub' $P7359 = "10_1307873304.82979" 
    $P7360 = $P7359()
    .return ($P7360)
.end

