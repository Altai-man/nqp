.include 'cclass.pasm'
.include 'except_severity.pasm'
.include 'except_types.pasm'
.include 'iglobals.pasm'
.include 'interpinfo.pasm'
.include 'iterator.pasm'
.include 'sysinfo.pasm'
.include 'datatypes.pasm'

.HLL "nqp"

.loadlib "nqp_group"

.loadlib "nqp_ops"

.loadlib "trans_ops"

.loadlib "io_ops"

.namespace []
.sub "_block1000"  :anon :subid("10_1310110678.31883")
    .param pmc param_1002 :slurpy
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 0
    .const 'Sub' $P3752 = "630_1310110678.31883" 
    capture_lex $P3752
    .const 'Sub' $P3715 = "622_1310110678.31883" 
    capture_lex $P3715
    .const 'Sub' $P2377 = "440_1310110678.31883" 
    capture_lex $P2377
    .const 'Sub' $P2322 = "419_1310110678.31883" 
    capture_lex $P2322
    .const 'Sub' $P1219 = "40_1310110678.31883" 
    capture_lex $P1219
    .const 'Sub' $P1025 = "13_1310110678.31883" 
    capture_lex $P1025
    .const 'Sub' $P1019 = "12_1310110678.31883" 
    capture_lex $P1019
    .const 'Sub' $P1006 = "11_1310110678.31883" 
    capture_lex $P1006
.annotate 'line', 1
    .lex "@ARGS", param_1002
    .lex "GLOBALish", $P1003
    .lex "$?PACKAGE", $P1004
.annotate 'line', 2782
    .const 'Sub' $P1006 = "11_1310110678.31883" 
    newclosure $P1017, $P1006
    set $P1005, $P1017
    .lex "MAIN", $P1005
.annotate 'line', 2805
    .const 'Sub' $P1019 = "12_1310110678.31883" 
    newclosure $P1023, $P1019
    set $P1018, $P1023
    .lex "hll-config", $P1018
.annotate 'line', 1
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
.annotate 'line', 9
    .const 'Sub' $P1025 = "13_1310110678.31883" 
    capture_lex $P1025
    $P1025()
.annotate 'line', 435
    .const 'Sub' $P1219 = "40_1310110678.31883" 
    capture_lex $P1219
    $P1219()
.annotate 'line', 1166
    .const 'Sub' $P2322 = "419_1310110678.31883" 
    capture_lex $P2322
    $P2322()
.annotate 'line', 1209
    .const 'Sub' $P2377 = "440_1310110678.31883" 
    capture_lex $P2377
    $P2377()
.annotate 'line', 2724
    .const 'Sub' $P3715 = "622_1310110678.31883" 
    capture_lex $P3715
    $P3715()
.annotate 'line', 2779
    .const 'Sub' $P3752 = "630_1310110678.31883" 
    capture_lex $P3752
    $P3752()
.annotate 'line', 1
    find_lex $P103, "MAIN"
    find_lex $P103, "hll-config"
    find_lex $P104, "@ARGS"
    if $P104, if_3755
    set $P103, $P104
    goto if_3755_end
  if_3755:
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P105, "ModuleLoader"
    getinterp $P106
    set $P107, $P106["context"]
    $P105."set_mainline_module"($P107)
    .const 'Sub' $P3756 = "11_1310110678.31883" 
    find_lex $P108, "@ARGS"
    $P109 = $P3756($P108 :flat)
    set $P103, $P109
  if_3755_end:
    .return ($P103)
    .const 'Sub' $P3758 = "631_1310110678.31883" 
    .return ($P3758)
.end


.HLL "nqp"

.namespace []
.sub "" :load :init :subid("post632") :outer("10_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 0
    .const 'Sub' $P1001 = "10_1310110678.31883" 
    .local pmc block
    set block, $P1001
    nqp_get_sc $P111, "1310110667.17599"
    isnull $I100, $P111
    if $I100, if_3760
    goto if_3760_end
  if_3760:
    nqp_dynop_setup 
    getinterp $P112
    get_class $P113, "LexPad"
    get_class $P114, "NQPLexPad"
    $P112."hll_map"($P113, $P114)
    nqp_create_sc $P115, "1310110667.17599"
    .local pmc cur_sc
    set cur_sc, $P115
    nqp_get_sc_object $P116, "__6MODEL_CORE__", 0
    $P117 = $P116."new_type"("GLOBALish" :named("name"))
    nqp_set_sc_for_object $P117, cur_sc
    nqp_set_sc_object "1310110667.17599", 0, $P117
    .const 'Sub' $P3761 = "10_1310110678.31883" 
    $P116 = $P3761."get_lexinfo"()
    nqp_get_sc_object $P117, "1310110667.17599", 0
    $P116."set_static_lexpad_value"("GLOBALish", $P117)
    .const 'Sub' $P3762 = "10_1310110678.31883" 
    $P118 = $P3762."get_lexinfo"()
    $P118."finish_static_lexpad"()
    .const 'Sub' $P3763 = "10_1310110678.31883" 
    $P116 = $P3763."get_lexinfo"()
    nqp_get_sc_object $P117, "1310110667.17599", 0
    $P116."set_static_lexpad_value"("$?PACKAGE", $P117)
    .const 'Sub' $P3764 = "10_1310110678.31883" 
    $P118 = $P3764."get_lexinfo"()
    $P118."finish_static_lexpad"()
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P116, "ModuleLoader"
    $P117 = $P116."load_setting"("NQPCORE")
    block."set_outer_ctx"($P117)
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P116, "ModuleLoader"
    nqp_get_sc_object $P117, "1310110667.17599", 0
    $P116."load_module"("NQPRegex", $P117)
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P116, "ModuleLoader"
    nqp_get_sc_object $P117, "1310110667.17599", 0
    $P116."load_module"("NQPP6Regex", $P117)
    nqp_get_sc_object $P116, "1310110648.32303", 41
    $P117 = $P116."new_type"("NQP::SymbolTable" :named("name"))
    nqp_set_sc_for_object $P117, cur_sc
    nqp_set_sc_object "1310110667.17599", 1, $P117
    nqp_get_sc_object $P116, "1310110667.17599", 1
    nqp_get_sc_object $P117, "1310110667.17599", 0
    nqp_get_package_through_who $P118, $P117, "NQP"
    get_who $P119, $P118
    set $P119["SymbolTable"], $P116
    nqp_get_sc_object $P116, "1310110667.17599", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 1
    .const 'Sub' $P3765 = "14_1310110678.31883" 
    $P117."add_method"($P118, "load_setting", $P3765)
    nqp_get_sc_object $P116, "1310110667.17599", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 1
    .const 'Sub' $P3766 = "16_1310110678.31883" 
    $P117."add_method"($P118, "load_module", $P3766)
    nqp_get_sc_object $P116, "1310110667.17599", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 1
    .const 'Sub' $P3767 = "17_1310110678.31883" 
    $P117."add_method"($P118, "install_package_symbol", $P3767)
    nqp_get_sc_object $P116, "1310110667.17599", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 1
    .const 'Sub' $P3768 = "20_1310110678.31883" 
    $P117."add_method"($P118, "install_lexical_symbol", $P3768)
    nqp_get_sc_object $P116, "1310110667.17599", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 1
    .const 'Sub' $P3769 = "21_1310110678.31883" 
    $P117."add_method"($P118, "install_package_routine", $P3769)
    nqp_get_sc_object $P116, "1310110667.17599", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 1
    .const 'Sub' $P3770 = "22_1310110678.31883" 
    $P117."add_method"($P118, "pkg_create_mo", $P3770)
    nqp_get_sc_object $P116, "1310110667.17599", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 1
    .const 'Sub' $P3771 = "23_1310110678.31883" 
    $P117."add_method"($P118, "pkg_add_attribute", $P3771)
    nqp_get_sc_object $P116, "1310110667.17599", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 1
    .const 'Sub' $P3772 = "26_1310110678.31883" 
    $P117."add_method"($P118, "pkg_add_method", $P3772)
    nqp_get_sc_object $P116, "1310110667.17599", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 1
    .const 'Sub' $P3773 = "29_1310110678.31883" 
    $P117."add_method"($P118, "set_routine_signature", $P3773)
    nqp_get_sc_object $P116, "1310110667.17599", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 1
    .const 'Sub' $P3774 = "30_1310110678.31883" 
    $P117."add_method"($P118, "pkg_set_body_block", $P3774)
    nqp_get_sc_object $P116, "1310110667.17599", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 1
    .const 'Sub' $P3775 = "35_1310110678.31883" 
    $P117."add_method"($P118, "pkg_add_parent_or_role", $P3775)
    nqp_get_sc_object $P116, "1310110667.17599", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 1
    .const 'Sub' $P3776 = "36_1310110678.31883" 
    $P117."add_method"($P118, "pkg_add_parrot_vtable_handler_mapping", $P3776)
    nqp_get_sc_object $P116, "1310110667.17599", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 1
    .const 'Sub' $P3777 = "37_1310110678.31883" 
    $P117."add_method"($P118, "pkg_compose", $P3777)
    nqp_get_sc_object $P116, "1310110667.17599", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 1
    .const 'Sub' $P3778 = "38_1310110678.31883" 
    $P117."add_method"($P118, "to_past", $P3778)
    .const 'Sub' $P3779 = "13_1310110678.31883" 
    $P116 = $P3779."get_lexinfo"()
    nqp_get_sc_object $P117, "1310110667.17599", 1
    $P116."set_static_lexpad_value"("$?PACKAGE", $P117)
    .const 'Sub' $P3780 = "13_1310110678.31883" 
    $P118 = $P3780."get_lexinfo"()
    $P118."finish_static_lexpad"()
    .const 'Sub' $P3781 = "13_1310110678.31883" 
    $P116 = $P3781."get_lexinfo"()
    nqp_get_sc_object $P117, "1310110667.17599", 1
    $P116."set_static_lexpad_value"("$?CLASS", $P117)
    .const 'Sub' $P3782 = "13_1310110678.31883" 
    $P118 = $P3782."get_lexinfo"()
    $P118."finish_static_lexpad"()
    nqp_get_sc_object $P116, "1310110667.17599", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 1
    nqp_get_sc_object $P119, "1310110654.27327", 195
    $P117."add_parent"($P118, $P119)
    nqp_get_sc_object $P116, "1310110667.17599", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 1
    $P117."compose"($P118)
    nqp_get_sc_object $P116, "1310110648.32303", 41
    $P117 = $P116."new_type"("NQP::Grammar" :named("name"))
    nqp_set_sc_for_object $P117, cur_sc
    nqp_set_sc_object "1310110667.17599", 16, $P117
    nqp_get_sc_object $P116, "1310110667.17599", 16
    nqp_get_sc_object $P117, "1310110667.17599", 0
    nqp_get_package_through_who $P118, $P117, "NQP"
    get_who $P119, $P118
    set $P119["Grammar"], $P116
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3783 = "41_1310110678.31883" 
    $P117."add_method"($P118, "TOP", $P3783)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3784 = "42_1310110678.31883" 
    $P117."add_method"($P118, "identifier", $P3784)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3785 = "43_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__identifier", $P3785)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3786 = "44_1310110678.31883" 
    $P117."add_method"($P118, "name", $P3786)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3787 = "45_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__name", $P3787)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3788 = "46_1310110678.31883" 
    $P117."add_method"($P118, "deflongname", $P3788)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3789 = "47_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__deflongname", $P3789)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3790 = "48_1310110678.31883" 
    $P117."add_method"($P118, "ENDSTMT", $P3790)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3791 = "49_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__ENDSTMT", $P3791)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3792 = "50_1310110678.31883" 
    $P117."add_method"($P118, "ws", $P3792)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3793 = "51_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__ws", $P3793)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3794 = "52_1310110678.31883" 
    $P117."add_method"($P118, "unv", $P3794)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3795 = "54_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__unv", $P3795)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3796 = "55_1310110678.31883" 
    $P117."add_method"($P118, "pod_comment", $P3796)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3797 = "57_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__pod_comment", $P3797)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3798 = "58_1310110678.31883" 
    $P117."add_method"($P118, "comp_unit", $P3798)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3799 = "59_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__comp_unit", $P3799)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3800 = "60_1310110678.31883" 
    $P117."add_method"($P118, "statementlist", $P3800)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3801 = "61_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__statementlist", $P3801)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3802 = "62_1310110678.31883" 
    $P117."add_method"($P118, "statement", $P3802)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3803 = "64_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__statement", $P3803)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3804 = "65_1310110678.31883" 
    $P117."add_method"($P118, "eat_terminator", $P3804)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3805 = "66_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__eat_terminator", $P3805)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3806 = "67_1310110678.31883" 
    $P117."add_method"($P118, "xblock", $P3806)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3807 = "68_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__xblock", $P3807)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3808 = "69_1310110678.31883" 
    $P117."add_method"($P118, "pblock", $P3808)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3809 = "70_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__pblock", $P3809)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3810 = "71_1310110678.31883" 
    $P117."add_method"($P118, "lambda", $P3810)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3811 = "72_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__lambda", $P3811)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3812 = "73_1310110678.31883" 
    $P117."add_method"($P118, "block", $P3812)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3813 = "74_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__block", $P3813)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3814 = "75_1310110678.31883" 
    $P117."add_method"($P118, "blockoid", $P3814)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3815 = "76_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__blockoid", $P3815)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3816 = "77_1310110678.31883" 
    $P117."add_method"($P118, "newpad", $P3816)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3817 = "78_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__newpad", $P3817)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3818 = "79_1310110678.31883" 
    $P117."add_method"($P118, "outerctx", $P3818)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3819 = "80_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__outerctx", $P3819)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3820 = "81_1310110678.31883" 
    $P117."add_method"($P118, "GLOBALish", $P3820)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3821 = "82_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__GLOBALish", $P3821)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3822 = "83_1310110678.31883" 
    $P117."add_method"($P118, "finishpad", $P3822)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3823 = "84_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__finishpad", $P3823)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3824 = "85_1310110678.31883" 
    $P117."add_method"($P118, "you_are_here", $P3824)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3825 = "86_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__you_are_here", $P3825)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3826 = "87_1310110678.31883" 
    $P117."add_method"($P118, "terminator", $P3826)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3827 = "88_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__terminator", $P3827)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3828 = "89_1310110678.31883" 
    $P117."add_method"($P118, "terminator:sym<;>", $P3828)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3829 = "90_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__terminator:sym<;>", $P3829)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3830 = "91_1310110678.31883" 
    $P117."add_method"($P118, "terminator:sym<}>", $P3830)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3831 = "92_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__terminator:sym<}>", $P3831)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3832 = "93_1310110678.31883" 
    $P117."add_method"($P118, "statement_control", $P3832)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3833 = "94_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__statement_control", $P3833)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3834 = "95_1310110678.31883" 
    $P117."add_method"($P118, "statement_control:sym<use>", $P3834)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3835 = "96_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__statement_control:sym<use>", $P3835)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3836 = "97_1310110678.31883" 
    $P117."add_method"($P118, "statement_control:sym<if>", $P3836)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3837 = "98_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__statement_control:sym<if>", $P3837)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3838 = "99_1310110678.31883" 
    $P117."add_method"($P118, "statement_control:sym<unless>", $P3838)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3839 = "101_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__statement_control:sym<unless>", $P3839)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3840 = "102_1310110678.31883" 
    $P117."add_method"($P118, "statement_control:sym<while>", $P3840)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3841 = "103_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__statement_control:sym<while>", $P3841)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3842 = "104_1310110678.31883" 
    $P117."add_method"($P118, "statement_control:sym<repeat>", $P3842)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3843 = "105_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__statement_control:sym<repeat>", $P3843)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3844 = "106_1310110678.31883" 
    $P117."add_method"($P118, "statement_control:sym<for>", $P3844)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3845 = "107_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__statement_control:sym<for>", $P3845)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3846 = "108_1310110678.31883" 
    $P117."add_method"($P118, "statement_control:sym<CATCH>", $P3846)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3847 = "109_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__statement_control:sym<CATCH>", $P3847)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3848 = "110_1310110678.31883" 
    $P117."add_method"($P118, "statement_control:sym<CONTROL>", $P3848)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3849 = "111_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__statement_control:sym<CONTROL>", $P3849)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3850 = "112_1310110678.31883" 
    $P117."add_method"($P118, "statement_prefix", $P3850)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3851 = "113_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__statement_prefix", $P3851)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3852 = "114_1310110678.31883" 
    $P117."add_method"($P118, "statement_prefix:sym<INIT>", $P3852)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3853 = "115_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__statement_prefix:sym<INIT>", $P3853)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3854 = "116_1310110678.31883" 
    $P117."add_method"($P118, "statement_prefix:sym<try>", $P3854)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3855 = "117_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__statement_prefix:sym<try>", $P3855)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3856 = "118_1310110678.31883" 
    $P117."add_method"($P118, "blorst", $P3856)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3857 = "119_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__blorst", $P3857)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3858 = "120_1310110678.31883" 
    $P117."add_method"($P118, "statement_mod_cond", $P3858)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3859 = "121_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__statement_mod_cond", $P3859)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3860 = "122_1310110678.31883" 
    $P117."add_method"($P118, "statement_mod_cond:sym<if>", $P3860)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3861 = "123_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__statement_mod_cond:sym<if>", $P3861)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3862 = "124_1310110678.31883" 
    $P117."add_method"($P118, "statement_mod_cond:sym<unless>", $P3862)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3863 = "125_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__statement_mod_cond:sym<unless>", $P3863)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3864 = "126_1310110678.31883" 
    $P117."add_method"($P118, "statement_mod_loop", $P3864)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3865 = "127_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__statement_mod_loop", $P3865)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3866 = "128_1310110678.31883" 
    $P117."add_method"($P118, "statement_mod_loop:sym<while>", $P3866)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3867 = "129_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__statement_mod_loop:sym<while>", $P3867)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3868 = "130_1310110678.31883" 
    $P117."add_method"($P118, "statement_mod_loop:sym<until>", $P3868)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3869 = "131_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__statement_mod_loop:sym<until>", $P3869)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3870 = "132_1310110678.31883" 
    $P117."add_method"($P118, "statement_mod_loop:sym<for>", $P3870)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3871 = "133_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__statement_mod_loop:sym<for>", $P3871)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3872 = "134_1310110678.31883" 
    $P117."add_method"($P118, "term:sym<fatarrow>", $P3872)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3873 = "135_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__term:sym<fatarrow>", $P3873)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3874 = "136_1310110678.31883" 
    $P117."add_method"($P118, "term:sym<colonpair>", $P3874)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3875 = "137_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__term:sym<colonpair>", $P3875)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3876 = "138_1310110678.31883" 
    $P117."add_method"($P118, "term:sym<variable>", $P3876)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3877 = "139_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__term:sym<variable>", $P3877)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3878 = "140_1310110678.31883" 
    $P117."add_method"($P118, "term:sym<package_declarator>", $P3878)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3879 = "141_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__term:sym<package_declarator>", $P3879)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3880 = "142_1310110678.31883" 
    $P117."add_method"($P118, "term:sym<scope_declarator>", $P3880)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3881 = "143_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__term:sym<scope_declarator>", $P3881)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3882 = "144_1310110678.31883" 
    $P117."add_method"($P118, "term:sym<routine_declarator>", $P3882)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3883 = "145_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__term:sym<routine_declarator>", $P3883)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3884 = "146_1310110678.31883" 
    $P117."add_method"($P118, "term:sym<multi_declarator>", $P3884)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3885 = "149_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__term:sym<multi_declarator>", $P3885)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3886 = "150_1310110678.31883" 
    $P117."add_method"($P118, "term:sym<regex_declarator>", $P3886)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3887 = "151_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__term:sym<regex_declarator>", $P3887)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3888 = "152_1310110678.31883" 
    $P117."add_method"($P118, "term:sym<statement_prefix>", $P3888)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3889 = "153_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__term:sym<statement_prefix>", $P3889)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3890 = "154_1310110678.31883" 
    $P117."add_method"($P118, "term:sym<lambda>", $P3890)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3891 = "155_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__term:sym<lambda>", $P3891)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3892 = "156_1310110678.31883" 
    $P117."add_method"($P118, "fatarrow", $P3892)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3893 = "157_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__fatarrow", $P3893)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3894 = "158_1310110678.31883" 
    $P117."add_method"($P118, "colonpair", $P3894)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3895 = "159_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__colonpair", $P3895)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3896 = "160_1310110678.31883" 
    $P117."add_method"($P118, "variable", $P3896)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3897 = "161_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__variable", $P3897)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3898 = "162_1310110678.31883" 
    $P117."add_method"($P118, "sigil", $P3898)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3899 = "163_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__sigil", $P3899)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3900 = "164_1310110678.31883" 
    $P117."add_method"($P118, "twigil", $P3900)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3901 = "165_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__twigil", $P3901)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3902 = "166_1310110678.31883" 
    $P117."add_method"($P118, "package_declarator", $P3902)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3903 = "167_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__package_declarator", $P3903)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3904 = "168_1310110678.31883" 
    $P117."add_method"($P118, "package_declarator:sym<module>", $P3904)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3905 = "169_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__package_declarator:sym<module>", $P3905)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3906 = "170_1310110678.31883" 
    $P117."add_method"($P118, "package_declarator:sym<knowhow>", $P3906)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3907 = "171_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__package_declarator:sym<knowhow>", $P3907)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3908 = "172_1310110678.31883" 
    $P117."add_method"($P118, "package_declarator:sym<class>", $P3908)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3909 = "173_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__package_declarator:sym<class>", $P3909)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3910 = "174_1310110678.31883" 
    $P117."add_method"($P118, "package_declarator:sym<grammar>", $P3910)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3911 = "175_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__package_declarator:sym<grammar>", $P3911)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3912 = "176_1310110678.31883" 
    $P117."add_method"($P118, "package_declarator:sym<role>", $P3912)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3913 = "177_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__package_declarator:sym<role>", $P3913)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3914 = "178_1310110678.31883" 
    $P117."add_method"($P118, "package_declarator:sym<native>", $P3914)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3915 = "179_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__package_declarator:sym<native>", $P3915)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3916 = "180_1310110678.31883" 
    $P117."add_method"($P118, "package_declarator:sym<stub>", $P3916)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3917 = "181_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__package_declarator:sym<stub>", $P3917)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3918 = "182_1310110678.31883" 
    $P117."add_method"($P118, "package_def", $P3918)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3919 = "184_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__package_def", $P3919)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3920 = "185_1310110678.31883" 
    $P117."add_method"($P118, "scope_declarator", $P3920)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3921 = "186_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__scope_declarator", $P3921)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3922 = "187_1310110678.31883" 
    $P117."add_method"($P118, "scope_declarator:sym<my>", $P3922)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3923 = "188_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__scope_declarator:sym<my>", $P3923)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3924 = "189_1310110678.31883" 
    $P117."add_method"($P118, "scope_declarator:sym<our>", $P3924)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3925 = "190_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__scope_declarator:sym<our>", $P3925)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3926 = "191_1310110678.31883" 
    $P117."add_method"($P118, "scope_declarator:sym<has>", $P3926)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3927 = "192_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__scope_declarator:sym<has>", $P3927)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3928 = "193_1310110678.31883" 
    $P117."add_method"($P118, "scoped", $P3928)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3929 = "194_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__scoped", $P3929)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3930 = "195_1310110678.31883" 
    $P117."add_method"($P118, "typename", $P3930)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3931 = "197_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__typename", $P3931)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3932 = "198_1310110678.31883" 
    $P117."add_method"($P118, "declarator", $P3932)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3933 = "199_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__declarator", $P3933)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3934 = "200_1310110678.31883" 
    $P117."add_method"($P118, "variable_declarator", $P3934)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3935 = "202_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__variable_declarator", $P3935)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3936 = "203_1310110678.31883" 
    $P117."add_method"($P118, "routine_declarator", $P3936)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3937 = "204_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__routine_declarator", $P3937)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3938 = "205_1310110678.31883" 
    $P117."add_method"($P118, "routine_declarator:sym<sub>", $P3938)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3939 = "206_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__routine_declarator:sym<sub>", $P3939)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3940 = "207_1310110678.31883" 
    $P117."add_method"($P118, "routine_declarator:sym<method>", $P3940)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3941 = "208_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__routine_declarator:sym<method>", $P3941)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3942 = "209_1310110678.31883" 
    $P117."add_method"($P118, "routine_def", $P3942)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3943 = "210_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__routine_def", $P3943)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3944 = "211_1310110678.31883" 
    $P117."add_method"($P118, "method_def", $P3944)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3945 = "213_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__method_def", $P3945)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3946 = "214_1310110678.31883" 
    $P117."add_method"($P118, "onlystar", $P3946)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3947 = "216_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__onlystar", $P3947)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3948 = "217_1310110678.31883" 
    $P117."add_method"($P118, "multi_declarator", $P3948)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3949 = "218_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__multi_declarator", $P3949)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3950 = "219_1310110678.31883" 
    $P117."add_method"($P118, "multi_declarator:sym<multi>", $P3950)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3951 = "220_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__multi_declarator:sym<multi>", $P3951)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3952 = "221_1310110678.31883" 
    $P117."add_method"($P118, "multi_declarator:sym<proto>", $P3952)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3953 = "222_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__multi_declarator:sym<proto>", $P3953)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3954 = "223_1310110678.31883" 
    $P117."add_method"($P118, "multi_declarator:sym<null>", $P3954)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3955 = "224_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__multi_declarator:sym<null>", $P3955)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3956 = "225_1310110678.31883" 
    $P117."add_method"($P118, "signature", $P3956)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3957 = "227_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__signature", $P3957)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3958 = "228_1310110678.31883" 
    $P117."add_method"($P118, "parameter", $P3958)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3959 = "229_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__parameter", $P3959)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3960 = "230_1310110678.31883" 
    $P117."add_method"($P118, "param_var", $P3960)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3961 = "231_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__param_var", $P3961)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3962 = "232_1310110678.31883" 
    $P117."add_method"($P118, "named_param", $P3962)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3963 = "233_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__named_param", $P3963)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3964 = "234_1310110678.31883" 
    $P117."add_method"($P118, "default_value", $P3964)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3965 = "235_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__default_value", $P3965)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3966 = "236_1310110678.31883" 
    $P117."add_method"($P118, "trait", $P3966)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3967 = "237_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__trait", $P3967)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3968 = "238_1310110678.31883" 
    $P117."add_method"($P118, "trait_mod", $P3968)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3969 = "239_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__trait_mod", $P3969)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3970 = "240_1310110678.31883" 
    $P117."add_method"($P118, "trait_mod:sym<is>", $P3970)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3971 = "241_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__trait_mod:sym<is>", $P3971)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3972 = "242_1310110678.31883" 
    $P117."add_method"($P118, "regex_declarator", $P3972)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3973 = "243_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__regex_declarator", $P3973)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3974 = "244_1310110678.31883" 
    $P117."add_method"($P118, "dotty", $P3974)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3975 = "245_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__dotty", $P3975)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3976 = "246_1310110678.31883" 
    $P117."add_method"($P118, "term", $P3976)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3977 = "247_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__term", $P3977)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3978 = "248_1310110678.31883" 
    $P117."add_method"($P118, "term:sym<self>", $P3978)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3979 = "249_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__term:sym<self>", $P3979)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3980 = "250_1310110678.31883" 
    $P117."add_method"($P118, "term:sym<identifier>", $P3980)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3981 = "251_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__term:sym<identifier>", $P3981)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3982 = "252_1310110678.31883" 
    $P117."add_method"($P118, "term:sym<name>", $P3982)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3983 = "253_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__term:sym<name>", $P3983)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3984 = "254_1310110678.31883" 
    $P117."add_method"($P118, "term:sym<pir::op>", $P3984)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3985 = "255_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__term:sym<pir::op>", $P3985)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3986 = "256_1310110678.31883" 
    $P117."add_method"($P118, "term:sym<pir::const>", $P3986)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3987 = "257_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__term:sym<pir::const>", $P3987)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3988 = "258_1310110678.31883" 
    $P117."add_method"($P118, "term:sym<nqp::op>", $P3988)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3989 = "259_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__term:sym<nqp::op>", $P3989)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3990 = "260_1310110678.31883" 
    $P117."add_method"($P118, "term:sym<onlystar>", $P3990)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3991 = "262_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__term:sym<onlystar>", $P3991)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3992 = "263_1310110678.31883" 
    $P117."add_method"($P118, "args", $P3992)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3993 = "264_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__args", $P3993)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3994 = "265_1310110678.31883" 
    $P117."add_method"($P118, "arglist", $P3994)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3995 = "266_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__arglist", $P3995)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3996 = "267_1310110678.31883" 
    $P117."add_method"($P118, "term:sym<value>", $P3996)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3997 = "268_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__term:sym<value>", $P3997)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3998 = "269_1310110678.31883" 
    $P117."add_method"($P118, "value", $P3998)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P3999 = "270_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__value", $P3999)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4000 = "271_1310110678.31883" 
    $P117."add_method"($P118, "number", $P4000)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4001 = "272_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__number", $P4001)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4002 = "273_1310110678.31883" 
    $P117."add_method"($P118, "quote", $P4002)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4003 = "274_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__quote", $P4003)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4004 = "275_1310110678.31883" 
    $P117."add_method"($P118, "quote:sym<apos>", $P4004)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4005 = "276_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__quote:sym<apos>", $P4005)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4006 = "277_1310110678.31883" 
    $P117."add_method"($P118, "quote:sym<dblq>", $P4006)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4007 = "278_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__quote:sym<dblq>", $P4007)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4008 = "279_1310110678.31883" 
    $P117."add_method"($P118, "quote:sym<q>", $P4008)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4009 = "280_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__quote:sym<q>", $P4009)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4010 = "281_1310110678.31883" 
    $P117."add_method"($P118, "quote:sym<qq>", $P4010)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4011 = "282_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__quote:sym<qq>", $P4011)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4012 = "283_1310110678.31883" 
    $P117."add_method"($P118, "quote:sym<Q>", $P4012)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4013 = "284_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__quote:sym<Q>", $P4013)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4014 = "285_1310110678.31883" 
    $P117."add_method"($P118, "quote:sym<Q:PIR>", $P4014)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4015 = "286_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__quote:sym<Q:PIR>", $P4015)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4016 = "287_1310110678.31883" 
    $P117."add_method"($P118, "quote:sym</ />", $P4016)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4017 = "288_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__quote:sym</ />", $P4017)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4018 = "289_1310110678.31883" 
    $P117."add_method"($P118, "quote_escape:sym<$>", $P4018)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4019 = "290_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__quote_escape:sym<$>", $P4019)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4020 = "291_1310110678.31883" 
    $P117."add_method"($P118, "quote_escape:sym<{ }>", $P4020)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4021 = "292_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__quote_escape:sym<{ }>", $P4021)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4022 = "293_1310110678.31883" 
    $P117."add_method"($P118, "quote_escape:sym<esc>", $P4022)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4023 = "294_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__quote_escape:sym<esc>", $P4023)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4024 = "295_1310110678.31883" 
    $P117."add_method"($P118, "circumfix:sym<( )>", $P4024)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4025 = "296_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__circumfix:sym<( )>", $P4025)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4026 = "297_1310110678.31883" 
    $P117."add_method"($P118, "circumfix:sym<[ ]>", $P4026)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4027 = "298_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__circumfix:sym<[ ]>", $P4027)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4028 = "299_1310110678.31883" 
    $P117."add_method"($P118, "circumfix:sym<ang>", $P4028)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4029 = "300_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__circumfix:sym<ang>", $P4029)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4030 = "301_1310110678.31883" 
    $P117."add_method"($P118, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P4030)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4031 = "302_1310110678.31883" 
    $P117."add_method"($P118, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>", $P4031)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4032 = "303_1310110678.31883" 
    $P117."add_method"($P118, "circumfix:sym<{ }>", $P4032)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4033 = "304_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__circumfix:sym<{ }>", $P4033)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4034 = "305_1310110678.31883" 
    $P117."add_method"($P118, "circumfix:sym<sigil>", $P4034)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4035 = "306_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__circumfix:sym<sigil>", $P4035)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4036 = "307_1310110678.31883" 
    $P117."add_method"($P118, "semilist", $P4036)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4037 = "308_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__semilist", $P4037)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4038 = "309_1310110678.31883" 
    $P117."add_method"($P118, "infixish", $P4038)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4039 = "310_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__infixish", $P4039)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4040 = "311_1310110678.31883" 
    $P117."add_method"($P118, "infixstopper", $P4040)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4041 = "312_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__infixstopper", $P4041)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4042 = "313_1310110678.31883" 
    $P117."add_method"($P118, "postcircumfix:sym<[ ]>", $P4042)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4043 = "314_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__postcircumfix:sym<[ ]>", $P4043)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4044 = "315_1310110678.31883" 
    $P117."add_method"($P118, "postcircumfix:sym<{ }>", $P4044)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4045 = "316_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__postcircumfix:sym<{ }>", $P4045)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4046 = "317_1310110678.31883" 
    $P117."add_method"($P118, "postcircumfix:sym<ang>", $P4046)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4047 = "318_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__postcircumfix:sym<ang>", $P4047)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4048 = "319_1310110678.31883" 
    $P117."add_method"($P118, "postcircumfix:sym<( )>", $P4048)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4049 = "320_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__postcircumfix:sym<( )>", $P4049)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4050 = "321_1310110678.31883" 
    $P117."add_method"($P118, "postfix:sym<.>", $P4050)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4051 = "322_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__postfix:sym<.>", $P4051)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4052 = "323_1310110678.31883" 
    $P117."add_method"($P118, "prefix:sym<++>", $P4052)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4053 = "324_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__prefix:sym<++>", $P4053)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4054 = "325_1310110678.31883" 
    $P117."add_method"($P118, "prefix:sym<-->", $P4054)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4055 = "326_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__prefix:sym<-->", $P4055)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4056 = "327_1310110678.31883" 
    $P117."add_method"($P118, "postfix:sym<++>", $P4056)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4057 = "328_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__postfix:sym<++>", $P4057)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4058 = "329_1310110678.31883" 
    $P117."add_method"($P118, "postfix:sym<-->", $P4058)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4059 = "330_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__postfix:sym<-->", $P4059)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4060 = "331_1310110678.31883" 
    $P117."add_method"($P118, "infix:sym<**>", $P4060)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4061 = "332_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<**>", $P4061)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4062 = "333_1310110678.31883" 
    $P117."add_method"($P118, "prefix:sym<+>", $P4062)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4063 = "334_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__prefix:sym<+>", $P4063)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4064 = "335_1310110678.31883" 
    $P117."add_method"($P118, "prefix:sym<~>", $P4064)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4065 = "336_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__prefix:sym<~>", $P4065)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4066 = "337_1310110678.31883" 
    $P117."add_method"($P118, "prefix:sym<->", $P4066)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4067 = "338_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__prefix:sym<->", $P4067)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4068 = "339_1310110678.31883" 
    $P117."add_method"($P118, "prefix:sym<?>", $P4068)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4069 = "340_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__prefix:sym<?>", $P4069)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4070 = "341_1310110678.31883" 
    $P117."add_method"($P118, "prefix:sym<!>", $P4070)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4071 = "342_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__prefix:sym<!>", $P4071)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4072 = "343_1310110678.31883" 
    $P117."add_method"($P118, "prefix:sym<|>", $P4072)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4073 = "344_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__prefix:sym<|>", $P4073)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4074 = "345_1310110678.31883" 
    $P117."add_method"($P118, "infix:sym<*>", $P4074)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4075 = "346_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<*>", $P4075)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4076 = "347_1310110678.31883" 
    $P117."add_method"($P118, "infix:sym</>", $P4076)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4077 = "348_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__infix:sym</>", $P4077)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4078 = "349_1310110678.31883" 
    $P117."add_method"($P118, "infix:sym<%>", $P4078)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4079 = "350_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<%>", $P4079)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4080 = "351_1310110678.31883" 
    $P117."add_method"($P118, "infix:sym<+&>", $P4080)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4081 = "352_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<+&>", $P4081)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4082 = "353_1310110678.31883" 
    $P117."add_method"($P118, "infix:sym<+>", $P4082)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4083 = "354_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<+>", $P4083)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4084 = "355_1310110678.31883" 
    $P117."add_method"($P118, "infix:sym<->", $P4084)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4085 = "356_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<->", $P4085)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4086 = "357_1310110678.31883" 
    $P117."add_method"($P118, "infix:sym<+|>", $P4086)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4087 = "358_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<+|>", $P4087)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4088 = "359_1310110678.31883" 
    $P117."add_method"($P118, "infix:sym<+^>", $P4088)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4089 = "360_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<+^>", $P4089)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4090 = "361_1310110678.31883" 
    $P117."add_method"($P118, "infix:sym<~>", $P4090)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4091 = "362_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<~>", $P4091)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4092 = "363_1310110678.31883" 
    $P117."add_method"($P118, "infix:sym<==>", $P4092)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4093 = "364_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<==>", $P4093)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4094 = "365_1310110678.31883" 
    $P117."add_method"($P118, "infix:sym<!=>", $P4094)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4095 = "366_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<!=>", $P4095)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4096 = "367_1310110678.31883" 
    $P117."add_method"($P118, "infix:sym<<=>", $P4096)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4097 = "368_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<<=>", $P4097)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4098 = "369_1310110678.31883" 
    $P117."add_method"($P118, "infix:sym<>=>", $P4098)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4099 = "370_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<>=>", $P4099)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4100 = "371_1310110678.31883" 
    $P117."add_method"($P118, "infix:sym<<>", $P4100)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4101 = "372_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<<>", $P4101)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4102 = "373_1310110678.31883" 
    $P117."add_method"($P118, "infix:sym<>>", $P4102)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4103 = "374_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<>>", $P4103)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4104 = "375_1310110678.31883" 
    $P117."add_method"($P118, "infix:sym<eq>", $P4104)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4105 = "376_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<eq>", $P4105)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4106 = "377_1310110678.31883" 
    $P117."add_method"($P118, "infix:sym<ne>", $P4106)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4107 = "378_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<ne>", $P4107)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4108 = "379_1310110678.31883" 
    $P117."add_method"($P118, "infix:sym<le>", $P4108)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4109 = "380_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<le>", $P4109)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4110 = "381_1310110678.31883" 
    $P117."add_method"($P118, "infix:sym<ge>", $P4110)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4111 = "382_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<ge>", $P4111)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4112 = "383_1310110678.31883" 
    $P117."add_method"($P118, "infix:sym<lt>", $P4112)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4113 = "384_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<lt>", $P4113)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4114 = "385_1310110678.31883" 
    $P117."add_method"($P118, "infix:sym<gt>", $P4114)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4115 = "386_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<gt>", $P4115)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4116 = "387_1310110678.31883" 
    $P117."add_method"($P118, "infix:sym<=:=>", $P4116)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4117 = "388_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<=:=>", $P4117)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4118 = "389_1310110678.31883" 
    $P117."add_method"($P118, "infix:sym<~~>", $P4118)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4119 = "390_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<~~>", $P4119)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4120 = "391_1310110678.31883" 
    $P117."add_method"($P118, "infix:sym<&&>", $P4120)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4121 = "392_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<&&>", $P4121)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4122 = "393_1310110678.31883" 
    $P117."add_method"($P118, "infix:sym<||>", $P4122)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4123 = "394_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<||>", $P4123)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4124 = "395_1310110678.31883" 
    $P117."add_method"($P118, "infix:sym<//>", $P4124)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4125 = "396_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<//>", $P4125)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4126 = "397_1310110678.31883" 
    $P117."add_method"($P118, "infix:sym<?? !!>", $P4126)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4127 = "398_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<?? !!>", $P4127)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4128 = "399_1310110678.31883" 
    $P117."add_method"($P118, "infix:sym<=>", $P4128)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4129 = "400_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<=>", $P4129)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4130 = "401_1310110678.31883" 
    $P117."add_method"($P118, "infix:sym<:=>", $P4130)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4131 = "402_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<:=>", $P4131)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4132 = "403_1310110678.31883" 
    $P117."add_method"($P118, "infix:sym<::=>", $P4132)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4133 = "404_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<::=>", $P4133)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4134 = "405_1310110678.31883" 
    $P117."add_method"($P118, "infix:sym<,>", $P4134)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4135 = "406_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<,>", $P4135)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4136 = "407_1310110678.31883" 
    $P117."add_method"($P118, "prefix:sym<return>", $P4136)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4137 = "409_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__prefix:sym<return>", $P4137)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4138 = "410_1310110678.31883" 
    $P117."add_method"($P118, "prefix:sym<make>", $P4138)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4139 = "411_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__prefix:sym<make>", $P4139)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4140 = "412_1310110678.31883" 
    $P117."add_method"($P118, "term:sym<last>", $P4140)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4141 = "413_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__term:sym<last>", $P4141)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4142 = "414_1310110678.31883" 
    $P117."add_method"($P118, "term:sym<next>", $P4142)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4143 = "415_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__term:sym<next>", $P4143)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4144 = "416_1310110678.31883" 
    $P117."add_method"($P118, "term:sym<redo>", $P4144)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4145 = "417_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__term:sym<redo>", $P4145)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    .const 'Sub' $P4146 = "418_1310110678.31883" 
    $P117."add_method"($P118, "smartmatch", $P4146)
    .const 'Sub' $P4147 = "40_1310110678.31883" 
    $P116 = $P4147."get_lexinfo"()
    nqp_get_sc_object $P117, "1310110667.17599", 16
    $P116."set_static_lexpad_value"("$?PACKAGE", $P117)
    .const 'Sub' $P4148 = "40_1310110678.31883" 
    $P118 = $P4148."get_lexinfo"()
    $P118."finish_static_lexpad"()
    .const 'Sub' $P4149 = "40_1310110678.31883" 
    $P116 = $P4149."get_lexinfo"()
    nqp_get_sc_object $P117, "1310110667.17599", 16
    $P116."set_static_lexpad_value"("$?CLASS", $P117)
    .const 'Sub' $P4150 = "40_1310110678.31883" 
    $P118 = $P4150."get_lexinfo"()
    $P118."finish_static_lexpad"()
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    nqp_get_sc_object $P119, "1310110654.27327", 1
    $P117."add_parent"($P118, $P119)
    nqp_get_sc_object $P116, "1310110667.17599", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 16
    $P117."compose"($P118)
    nqp_get_sc_object $P116, "1310110648.32303", 41
    $P117 = $P116."new_type"("NQP::Regex" :named("name"))
    nqp_set_sc_for_object $P117, cur_sc
    nqp_set_sc_object "1310110667.17599", 381, $P117
    nqp_get_sc_object $P116, "1310110667.17599", 381
    nqp_get_sc_object $P117, "1310110667.17599", 0
    nqp_get_package_through_who $P118, $P117, "NQP"
    get_who $P119, $P118
    set $P119["Regex"], $P116
    nqp_get_sc_object $P116, "1310110667.17599", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 381
    .const 'Sub' $P4151 = "420_1310110678.31883" 
    $P117."add_method"($P118, "metachar:sym<:my>", $P4151)
    nqp_get_sc_object $P116, "1310110667.17599", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 381
    .const 'Sub' $P4152 = "422_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__metachar:sym<:my>", $P4152)
    nqp_get_sc_object $P116, "1310110667.17599", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 381
    .const 'Sub' $P4153 = "423_1310110678.31883" 
    $P117."add_method"($P118, "metachar:sym<{ }>", $P4153)
    nqp_get_sc_object $P116, "1310110667.17599", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 381
    .const 'Sub' $P4154 = "424_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__metachar:sym<{ }>", $P4154)
    nqp_get_sc_object $P116, "1310110667.17599", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 381
    .const 'Sub' $P4155 = "425_1310110678.31883" 
    $P117."add_method"($P118, "metachar:sym<nqpvar>", $P4155)
    nqp_get_sc_object $P116, "1310110667.17599", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 381
    .const 'Sub' $P4156 = "427_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__metachar:sym<nqpvar>", $P4156)
    nqp_get_sc_object $P116, "1310110667.17599", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 381
    .const 'Sub' $P4157 = "428_1310110678.31883" 
    $P117."add_method"($P118, "assertion:sym<{ }>", $P4157)
    nqp_get_sc_object $P116, "1310110667.17599", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 381
    .const 'Sub' $P4158 = "429_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__assertion:sym<{ }>", $P4158)
    nqp_get_sc_object $P116, "1310110667.17599", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 381
    .const 'Sub' $P4159 = "430_1310110678.31883" 
    $P117."add_method"($P118, "assertion:sym<?{ }>", $P4159)
    nqp_get_sc_object $P116, "1310110667.17599", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 381
    .const 'Sub' $P4160 = "432_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__assertion:sym<?{ }>", $P4160)
    nqp_get_sc_object $P116, "1310110667.17599", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 381
    .const 'Sub' $P4161 = "433_1310110678.31883" 
    $P117."add_method"($P118, "assertion:sym<name>", $P4161)
    nqp_get_sc_object $P116, "1310110667.17599", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 381
    .const 'Sub' $P4162 = "435_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__assertion:sym<name>", $P4162)
    nqp_get_sc_object $P116, "1310110667.17599", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 381
    .const 'Sub' $P4163 = "436_1310110678.31883" 
    $P117."add_method"($P118, "assertion:sym<var>", $P4163)
    nqp_get_sc_object $P116, "1310110667.17599", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 381
    .const 'Sub' $P4164 = "437_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__assertion:sym<var>", $P4164)
    nqp_get_sc_object $P116, "1310110667.17599", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 381
    .const 'Sub' $P4165 = "438_1310110678.31883" 
    $P117."add_method"($P118, "codeblock", $P4165)
    nqp_get_sc_object $P116, "1310110667.17599", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 381
    .const 'Sub' $P4166 = "439_1310110678.31883" 
    $P117."add_method"($P118, "!PREFIX__codeblock", $P4166)
    .const 'Sub' $P4167 = "419_1310110678.31883" 
    $P116 = $P4167."get_lexinfo"()
    nqp_get_sc_object $P117, "1310110667.17599", 381
    $P116."set_static_lexpad_value"("$?PACKAGE", $P117)
    .const 'Sub' $P4168 = "419_1310110678.31883" 
    $P118 = $P4168."get_lexinfo"()
    $P118."finish_static_lexpad"()
    .const 'Sub' $P4169 = "419_1310110678.31883" 
    $P116 = $P4169."get_lexinfo"()
    nqp_get_sc_object $P117, "1310110667.17599", 381
    $P116."set_static_lexpad_value"("$?CLASS", $P117)
    .const 'Sub' $P4170 = "419_1310110678.31883" 
    $P118 = $P4170."get_lexinfo"()
    $P118."finish_static_lexpad"()
    nqp_get_sc_object $P116, "1310110667.17599", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 381
    nqp_get_sc_object $P119, "1310110661.93249", 1
    $P117."add_parent"($P118, $P119)
    nqp_get_sc_object $P116, "1310110667.17599", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 381
    $P117."compose"($P118)
    nqp_get_sc_object $P116, "1310110648.32303", 41
    $P117 = $P116."new_type"("NQP::Actions" :named("name"))
    nqp_set_sc_for_object $P117, cur_sc
    nqp_set_sc_object "1310110667.17599", 398, $P117
    nqp_get_sc_object $P116, "1310110667.17599", 398
    nqp_get_sc_object $P117, "1310110667.17599", 0
    nqp_get_package_through_who $P118, $P117, "NQP"
    get_who $P119, $P118
    set $P119["Actions"], $P116
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4171 = "467_1310110678.31883" 
    $P117."add_method"($P118, "TOP", $P4171)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4172 = "468_1310110678.31883" 
    $P117."add_method"($P118, "deflongname", $P4172)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4173 = "469_1310110678.31883" 
    $P117."add_method"($P118, "comp_unit", $P4173)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4174 = "471_1310110678.31883" 
    $P117."add_method"($P118, "statementlist", $P4174)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4175 = "473_1310110678.31883" 
    $P117."add_method"($P118, "statement", $P4175)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4176 = "475_1310110678.31883" 
    $P117."add_method"($P118, "xblock", $P4176)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4177 = "476_1310110678.31883" 
    $P117."add_method"($P118, "pblock", $P4177)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4178 = "477_1310110678.31883" 
    $P117."add_method"($P118, "block", $P4178)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4179 = "478_1310110678.31883" 
    $P117."add_method"($P118, "blockoid", $P4179)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4180 = "480_1310110678.31883" 
    $P117."add_method"($P118, "newpad", $P4180)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4181 = "481_1310110678.31883" 
    $P117."add_method"($P118, "outerctx", $P4181)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4182 = "483_1310110678.31883" 
    $P117."add_method"($P118, "GLOBALish", $P4182)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4183 = "484_1310110678.31883" 
    $P117."add_method"($P118, "you_are_here", $P4183)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4184 = "485_1310110678.31883" 
    $P117."add_method"($P118, "statement_control:sym<use>", $P4184)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4185 = "486_1310110678.31883" 
    $P117."add_method"($P118, "statement_control:sym<if>", $P4185)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4186 = "488_1310110678.31883" 
    $P117."add_method"($P118, "statement_control:sym<unless>", $P4186)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4187 = "489_1310110678.31883" 
    $P117."add_method"($P118, "statement_control:sym<while>", $P4187)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4188 = "490_1310110678.31883" 
    $P117."add_method"($P118, "statement_control:sym<repeat>", $P4188)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4189 = "491_1310110678.31883" 
    $P117."add_method"($P118, "statement_control:sym<for>", $P4189)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4190 = "492_1310110678.31883" 
    $P117."add_method"($P118, "statement_control:sym<CATCH>", $P4190)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4191 = "493_1310110678.31883" 
    $P117."add_method"($P118, "statement_control:sym<CONTROL>", $P4191)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4192 = "494_1310110678.31883" 
    $P117."add_method"($P118, "statement_prefix:sym<INIT>", $P4192)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4193 = "495_1310110678.31883" 
    $P117."add_method"($P118, "statement_prefix:sym<try>", $P4193)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4194 = "496_1310110678.31883" 
    $P117."add_method"($P118, "blorst", $P4194)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4195 = "497_1310110678.31883" 
    $P117."add_method"($P118, "statement_mod_cond:sym<if>", $P4195)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4196 = "498_1310110678.31883" 
    $P117."add_method"($P118, "statement_mod_cond:sym<unless>", $P4196)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4197 = "499_1310110678.31883" 
    $P117."add_method"($P118, "statement_mod_loop:sym<while>", $P4197)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4198 = "500_1310110678.31883" 
    $P117."add_method"($P118, "statement_mod_loop:sym<until>", $P4198)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4199 = "501_1310110678.31883" 
    $P117."add_method"($P118, "term:sym<fatarrow>", $P4199)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4200 = "502_1310110678.31883" 
    $P117."add_method"($P118, "term:sym<colonpair>", $P4200)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4201 = "503_1310110678.31883" 
    $P117."add_method"($P118, "term:sym<variable>", $P4201)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4202 = "504_1310110678.31883" 
    $P117."add_method"($P118, "term:sym<package_declarator>", $P4202)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4203 = "505_1310110678.31883" 
    $P117."add_method"($P118, "term:sym<scope_declarator>", $P4203)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4204 = "506_1310110678.31883" 
    $P117."add_method"($P118, "term:sym<routine_declarator>", $P4204)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4205 = "507_1310110678.31883" 
    $P117."add_method"($P118, "term:sym<regex_declarator>", $P4205)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4206 = "508_1310110678.31883" 
    $P117."add_method"($P118, "term:sym<statement_prefix>", $P4206)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4207 = "509_1310110678.31883" 
    $P117."add_method"($P118, "term:sym<lambda>", $P4207)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4208 = "510_1310110678.31883" 
    $P117."add_method"($P118, "fatarrow", $P4208)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4209 = "511_1310110678.31883" 
    $P117."add_method"($P118, "colonpair", $P4209)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4210 = "512_1310110678.31883" 
    $P117."add_method"($P118, "variable", $P4210)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4211 = "518_1310110678.31883" 
    $P117."add_method"($P118, "package_declarator:sym<module>", $P4211)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4212 = "519_1310110678.31883" 
    $P117."add_method"($P118, "package_declarator:sym<knowhow>", $P4212)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4213 = "520_1310110678.31883" 
    $P117."add_method"($P118, "package_declarator:sym<class>", $P4213)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4214 = "521_1310110678.31883" 
    $P117."add_method"($P118, "package_declarator:sym<grammar>", $P4214)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4215 = "522_1310110678.31883" 
    $P117."add_method"($P118, "package_declarator:sym<role>", $P4215)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4216 = "523_1310110678.31883" 
    $P117."add_method"($P118, "package_declarator:sym<native>", $P4216)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4217 = "524_1310110678.31883" 
    $P117."add_method"($P118, "package_declarator:sym<stub>", $P4217)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4218 = "525_1310110678.31883" 
    $P117."add_method"($P118, "package_def", $P4218)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4219 = "531_1310110678.31883" 
    $P117."add_method"($P118, "scope_declarator:sym<my>", $P4219)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4220 = "532_1310110678.31883" 
    $P117."add_method"($P118, "scope_declarator:sym<our>", $P4220)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4221 = "533_1310110678.31883" 
    $P117."add_method"($P118, "scope_declarator:sym<has>", $P4221)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4222 = "534_1310110678.31883" 
    $P117."add_method"($P118, "scoped", $P4222)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4223 = "535_1310110678.31883" 
    $P117."add_method"($P118, "declarator", $P4223)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4224 = "536_1310110678.31883" 
    $P117."add_method"($P118, "multi_declarator:sym<multi>", $P4224)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4225 = "537_1310110678.31883" 
    $P117."add_method"($P118, "multi_declarator:sym<proto>", $P4225)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4226 = "538_1310110678.31883" 
    $P117."add_method"($P118, "multi_declarator:sym<null>", $P4226)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4227 = "539_1310110678.31883" 
    $P117."add_method"($P118, "variable_declarator", $P4227)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4228 = "542_1310110678.31883" 
    $P117."add_method"($P118, "routine_declarator:sym<sub>", $P4228)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4229 = "543_1310110678.31883" 
    $P117."add_method"($P118, "routine_declarator:sym<method>", $P4229)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4230 = "544_1310110678.31883" 
    $P117."add_method"($P118, "routine_def", $P4230)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4231 = "551_1310110678.31883" 
    $P117."add_method"($P118, "method_def", $P4231)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4232 = "554_1310110678.31883" 
    $P117."add_method"($P118, "signature", $P4232)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4233 = "557_1310110678.31883" 
    $P117."add_method"($P118, "parameter", $P4233)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4234 = "558_1310110678.31883" 
    $P117."add_method"($P118, "param_var", $P4234)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4235 = "559_1310110678.31883" 
    $P117."add_method"($P118, "named_param", $P4235)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4236 = "560_1310110678.31883" 
    $P117."add_method"($P118, "typename", $P4236)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4237 = "562_1310110678.31883" 
    $P117."add_method"($P118, "trait", $P4237)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4238 = "563_1310110678.31883" 
    $P117."add_method"($P118, "trait_mod:sym<is>", $P4238)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4239 = "568_1310110678.31883" 
    $P117."add_method"($P118, "regex_declarator", $P4239)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4240 = "573_1310110678.31883" 
    $P117."add_method"($P118, "dotty", $P4240)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4241 = "574_1310110678.31883" 
    $P117."add_method"($P118, "term:sym<self>", $P4241)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4242 = "575_1310110678.31883" 
    $P117."add_method"($P118, "term:sym<identifier>", $P4242)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4243 = "576_1310110678.31883" 
    $P117."add_method"($P118, "term:sym<name>", $P4243)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4244 = "578_1310110678.31883" 
    $P117."add_method"($P118, "term:sym<pir::op>", $P4244)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4245 = "579_1310110678.31883" 
    $P117."add_method"($P118, "term:sym<pir::const>", $P4245)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4246 = "580_1310110678.31883" 
    $P117."add_method"($P118, "term:sym<nqp::op>", $P4246)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4247 = "581_1310110678.31883" 
    $P117."add_method"($P118, "term:sym<onlystar>", $P4247)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4248 = "582_1310110678.31883" 
    $P117."add_method"($P118, "args", $P4248)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4249 = "583_1310110678.31883" 
    $P117."add_method"($P118, "arglist", $P4249)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4250 = "586_1310110678.31883" 
    $P117."add_method"($P118, "term:sym<multi_declarator>", $P4250)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4251 = "587_1310110678.31883" 
    $P117."add_method"($P118, "term:sym<value>", $P4251)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4252 = "588_1310110678.31883" 
    $P117."add_method"($P118, "circumfix:sym<( )>", $P4252)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4253 = "589_1310110678.31883" 
    $P117."add_method"($P118, "circumfix:sym<[ ]>", $P4253)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4254 = "590_1310110678.31883" 
    $P117."add_method"($P118, "circumfix:sym<ang>", $P4254)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4255 = "591_1310110678.31883" 
    $P117."add_method"($P118, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P4255)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4256 = "592_1310110678.31883" 
    $P117."add_method"($P118, "circumfix:sym<{ }>", $P4256)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4257 = "594_1310110678.31883" 
    $P117."add_method"($P118, "circumfix:sym<sigil>", $P4257)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4258 = "595_1310110678.31883" 
    $P117."add_method"($P118, "semilist", $P4258)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4259 = "596_1310110678.31883" 
    $P117."add_method"($P118, "postcircumfix:sym<[ ]>", $P4259)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4260 = "597_1310110678.31883" 
    $P117."add_method"($P118, "postcircumfix:sym<{ }>", $P4260)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4261 = "598_1310110678.31883" 
    $P117."add_method"($P118, "postcircumfix:sym<ang>", $P4261)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4262 = "599_1310110678.31883" 
    $P117."add_method"($P118, "postcircumfix:sym<( )>", $P4262)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4263 = "600_1310110678.31883" 
    $P117."add_method"($P118, "value", $P4263)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4264 = "601_1310110678.31883" 
    $P117."add_method"($P118, "number", $P4264)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4265 = "602_1310110678.31883" 
    $P117."add_method"($P118, "quote:sym<apos>", $P4265)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4266 = "603_1310110678.31883" 
    $P117."add_method"($P118, "quote:sym<dblq>", $P4266)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4267 = "604_1310110678.31883" 
    $P117."add_method"($P118, "quote:sym<qq>", $P4267)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4268 = "605_1310110678.31883" 
    $P117."add_method"($P118, "quote:sym<q>", $P4268)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4269 = "606_1310110678.31883" 
    $P117."add_method"($P118, "quote:sym<Q>", $P4269)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4270 = "607_1310110678.31883" 
    $P117."add_method"($P118, "quote:sym<Q:PIR>", $P4270)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4271 = "608_1310110678.31883" 
    $P117."add_method"($P118, "quote:sym</ />", $P4271)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4272 = "609_1310110678.31883" 
    $P117."add_method"($P118, "quote_escape:sym<$>", $P4272)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4273 = "610_1310110678.31883" 
    $P117."add_method"($P118, "quote_escape:sym<{ }>", $P4273)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4274 = "611_1310110678.31883" 
    $P117."add_method"($P118, "quote_escape:sym<esc>", $P4274)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4275 = "612_1310110678.31883" 
    $P117."add_method"($P118, "postfix:sym<.>", $P4275)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4276 = "613_1310110678.31883" 
    $P117."add_method"($P118, "postfix:sym<++>", $P4276)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4277 = "614_1310110678.31883" 
    $P117."add_method"($P118, "postfix:sym<-->", $P4277)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4278 = "615_1310110678.31883" 
    $P117."add_method"($P118, "prefix:sym<make>", $P4278)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4279 = "616_1310110678.31883" 
    $P117."add_method"($P118, "term:sym<next>", $P4279)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4280 = "617_1310110678.31883" 
    $P117."add_method"($P118, "term:sym<last>", $P4280)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4281 = "618_1310110678.31883" 
    $P117."add_method"($P118, "term:sym<redo>", $P4281)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4282 = "619_1310110678.31883" 
    $P117."add_method"($P118, "infix:sym<~~>", $P4282)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    .const 'Sub' $P4283 = "620_1310110678.31883" 
    $P117."add_method"($P118, "known_sym", $P4283)
    .const 'Sub' $P4284 = "440_1310110678.31883" 
    $P116 = $P4284."get_lexinfo"()
    nqp_get_sc_object $P117, "1310110667.17599", 398
    $P116."set_static_lexpad_value"("$?PACKAGE", $P117)
    .const 'Sub' $P4285 = "440_1310110678.31883" 
    $P118 = $P4285."get_lexinfo"()
    $P118."finish_static_lexpad"()
    .const 'Sub' $P4286 = "440_1310110678.31883" 
    $P116 = $P4286."get_lexinfo"()
    nqp_get_sc_object $P117, "1310110667.17599", 398
    $P116."set_static_lexpad_value"("$?CLASS", $P117)
    .const 'Sub' $P4287 = "440_1310110678.31883" 
    $P118 = $P4287."get_lexinfo"()
    $P118."finish_static_lexpad"()
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    nqp_get_sc_object $P119, "1310110654.27327", 105
    $P117."add_parent"($P118, $P119)
    nqp_get_sc_object $P116, "1310110667.17599", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 398
    $P117."compose"($P118)
    nqp_get_sc_object $P116, "1310110648.32303", 41
    $P117 = $P116."new_type"("NQP::RegexActions" :named("name"))
    nqp_set_sc_for_object $P117, cur_sc
    nqp_set_sc_object "1310110667.17599", 512, $P117
    nqp_get_sc_object $P116, "1310110667.17599", 512
    nqp_get_sc_object $P117, "1310110667.17599", 0
    nqp_get_package_through_who $P118, $P117, "NQP"
    get_who $P119, $P118
    set $P119["RegexActions"], $P116
    nqp_get_sc_object $P116, "1310110667.17599", 512
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 512
    .const 'Sub' $P4288 = "623_1310110678.31883" 
    $P117."add_method"($P118, "metachar:sym<:my>", $P4288)
    nqp_get_sc_object $P116, "1310110667.17599", 512
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 512
    .const 'Sub' $P4289 = "624_1310110678.31883" 
    $P117."add_method"($P118, "metachar:sym<{ }>", $P4289)
    nqp_get_sc_object $P116, "1310110667.17599", 512
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 512
    .const 'Sub' $P4290 = "625_1310110678.31883" 
    $P117."add_method"($P118, "metachar:sym<nqpvar>", $P4290)
    nqp_get_sc_object $P116, "1310110667.17599", 512
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 512
    .const 'Sub' $P4291 = "626_1310110678.31883" 
    $P117."add_method"($P118, "assertion:sym<{ }>", $P4291)
    nqp_get_sc_object $P116, "1310110667.17599", 512
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 512
    .const 'Sub' $P4292 = "627_1310110678.31883" 
    $P117."add_method"($P118, "assertion:sym<?{ }>", $P4292)
    nqp_get_sc_object $P116, "1310110667.17599", 512
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 512
    .const 'Sub' $P4293 = "628_1310110678.31883" 
    $P117."add_method"($P118, "assertion:sym<var>", $P4293)
    nqp_get_sc_object $P116, "1310110667.17599", 512
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 512
    .const 'Sub' $P4294 = "629_1310110678.31883" 
    $P117."add_method"($P118, "codeblock", $P4294)
    .const 'Sub' $P4295 = "622_1310110678.31883" 
    $P116 = $P4295."get_lexinfo"()
    nqp_get_sc_object $P117, "1310110667.17599", 512
    $P116."set_static_lexpad_value"("$?PACKAGE", $P117)
    .const 'Sub' $P4296 = "622_1310110678.31883" 
    $P118 = $P4296."get_lexinfo"()
    $P118."finish_static_lexpad"()
    .const 'Sub' $P4297 = "622_1310110678.31883" 
    $P116 = $P4297."get_lexinfo"()
    nqp_get_sc_object $P117, "1310110667.17599", 512
    $P116."set_static_lexpad_value"("$?CLASS", $P117)
    .const 'Sub' $P4298 = "622_1310110678.31883" 
    $P118 = $P4298."get_lexinfo"()
    $P118."finish_static_lexpad"()
    nqp_get_sc_object $P116, "1310110667.17599", 512
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 512
    nqp_get_sc_object $P119, "1310110661.93249", 145
    $P117."add_parent"($P118, $P119)
    nqp_get_sc_object $P116, "1310110667.17599", 512
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 512
    $P117."compose"($P118)
    nqp_get_sc_object $P116, "1310110648.32303", 41
    $P117 = $P116."new_type"("NQP::Compiler" :named("name"))
    nqp_set_sc_for_object $P117, cur_sc
    nqp_set_sc_object "1310110667.17599", 520, $P117
    nqp_get_sc_object $P116, "1310110667.17599", 520
    nqp_get_sc_object $P117, "1310110667.17599", 0
    nqp_get_package_through_who $P118, $P117, "NQP"
    get_who $P119, $P118
    set $P119["Compiler"], $P116
    .const 'Sub' $P4299 = "630_1310110678.31883" 
    $P116 = $P4299."get_lexinfo"()
    nqp_get_sc_object $P117, "1310110667.17599", 520
    $P116."set_static_lexpad_value"("$?PACKAGE", $P117)
    .const 'Sub' $P4300 = "630_1310110678.31883" 
    $P118 = $P4300."get_lexinfo"()
    $P118."finish_static_lexpad"()
    .const 'Sub' $P4301 = "630_1310110678.31883" 
    $P116 = $P4301."get_lexinfo"()
    nqp_get_sc_object $P117, "1310110667.17599", 520
    $P116."set_static_lexpad_value"("$?CLASS", $P117)
    .const 'Sub' $P4302 = "630_1310110678.31883" 
    $P118 = $P4302."get_lexinfo"()
    $P118."finish_static_lexpad"()
    nqp_get_sc_object $P116, "1310110667.17599", 520
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 520
    nqp_get_sc_object $P119, "1310110654.27327", 138
    $P117."add_parent"($P118, $P119)
    nqp_get_sc_object $P116, "1310110667.17599", 520
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1310110667.17599", 520
    $P117."compose"($P118)
  if_3760_end:
    nqp_get_sc_object $P116, "1310110667.17599", 0
    set_hll_global "GLOBAL", $P116
.end


.HLL "nqp"

.namespace []
.sub "MAIN"  :subid("11_1310110678.31883") :outer("10_1310110678.31883")
    .param pmc param_1007
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2782
    .lex "@ARGS", param_1007
.annotate 'line', 2784
    new $P100, "Undef"
    set $P1008, $P100
    .lex "$nqpcomp", $P1008
.annotate 'line', 2791
    $P1010 = root_new ['parrot';'ResizablePMCArray']
    set $P1009, $P1010
    .lex "@clo", $P1009
.annotate 'line', 2784
    get_hll_global $P101, "GLOBAL"
    nqp_get_package_through_who $P102, $P101, "NQP"
    get_who $P103, $P102
    set $P104, $P103["Compiler"]
    $P105 = $P104."new"()
    store_lex "$nqpcomp", $P105
.annotate 'line', 2785
    find_lex $P101, "$nqpcomp"
    unless_null $P101, vivify_633
    new $P101, "Undef"
  vivify_633:
    $P101."language"("nqp")
.annotate 'line', 2786
    find_lex $P101, "$nqpcomp"
    unless_null $P101, vivify_634
    new $P101, "Undef"
  vivify_634:
    get_hll_global $P102, "GLOBAL"
    nqp_get_package_through_who $P103, $P102, "NQP"
    get_who $P104, $P103
    set $P105, $P104["Grammar"]
    $P101."parsegrammar"($P105)
.annotate 'line', 2787
    find_lex $P101, "$nqpcomp"
    unless_null $P101, vivify_635
    new $P101, "Undef"
  vivify_635:
    get_hll_global $P102, "GLOBAL"
    nqp_get_package_through_who $P103, $P102, "NQP"
    get_who $P104, $P103
    set $P105, $P104["Actions"]
    $P101."parseactions"($P105)
.annotate 'line', 2788
    find_lex $P101, "$nqpcomp"
    unless_null $P101, vivify_636
    new $P101, "Undef"
  vivify_636:
    $P102 = $P101."config"()
    "hll-config"($P102)
.annotate 'line', 2791
    find_lex $P101, "$nqpcomp"
    unless_null $P101, vivify_637
    new $P101, "Undef"
  vivify_637:
    $P102 = $P101."commandline_options"()
    store_lex "@clo", $P102
.annotate 'line', 2792
    find_lex $P1011, "@clo"
    unless_null $P1011, vivify_638
    $P1011 = root_new ['parrot';'ResizablePMCArray']
  vivify_638:
    $P1011."push"("parsetrace")
.annotate 'line', 2793
    find_lex $P1012, "@clo"
    unless_null $P1012, vivify_639
    $P1012 = root_new ['parrot';'ResizablePMCArray']
  vivify_639:
    $P1012."push"("setting=s")
.annotate 'line', 2794
    find_lex $P1013, "@clo"
    unless_null $P1013, vivify_640
    $P1013 = root_new ['parrot';'ResizablePMCArray']
  vivify_640:
    $P1013."push"("setting-path=s")
.annotate 'line', 2795
    find_lex $P1014, "@clo"
    unless_null $P1014, vivify_641
    $P1014 = root_new ['parrot';'ResizablePMCArray']
  vivify_641:
    $P1014."push"("module-path=s")
.annotate 'line', 2796
    find_lex $P1015, "@clo"
    unless_null $P1015, vivify_642
    $P1015 = root_new ['parrot';'ResizablePMCArray']
  vivify_642:
    $P1015."push"("vmlibs=s")
.annotate 'line', 2799
    find_lex $P101, "$nqpcomp"
    unless_null $P101, vivify_643
    new $P101, "Undef"
  vivify_643:
    find_lex $P1016, "@ARGS"
    unless_null $P1016, vivify_644
    $P1016 = root_new ['parrot';'ResizablePMCArray']
  vivify_644:
    $P101."command_line"($P1016, "utf8" :named("encoding"), "ascii iso-8859-1" :named("transcode"))
.annotate 'line', 2801
    find_lex $P101, "$nqpcomp"
    unless_null $P101, vivify_645
    new $P101, "Undef"
  vivify_645:
    $P102 = $P101."nqpevent"()
.annotate 'line', 2782
    .return ($P102)
.end


.HLL "nqp"

.namespace []
.sub "hll-config"  :subid("12_1310110678.31883") :outer("10_1310110678.31883")
    .param pmc param_1020
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2805
    .lex "$config", param_1020
.annotate 'line', 2806
    new $P101, "String"
    assign $P101, "2011.06-35-g7426748"
    find_lex $P1021, "$config"
    unless_null $P1021, vivify_646
    $P1021 = root_new ['parrot';'Hash']
    store_lex "$config", $P1021
  vivify_646:
    set $P1021["version"], $P101
.annotate 'line', 2807
    new $P101, "String"
    assign $P101, "2011-07-08T07:37:47Z"
    find_lex $P1022, "$config"
    unless_null $P1022, vivify_647
    $P1022 = root_new ['parrot';'Hash']
    store_lex "$config", $P1022
  vivify_647:
    set $P1022["build-date"], $P101
.annotate 'line', 2805
    .return ($P101)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block1024"  :subid("13_1310110678.31883") :outer("10_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 9
    .const 'Sub' $P1207 = "38_1310110678.31883" 
    capture_lex $P1207
    .const 'Sub' $P1203 = "37_1310110678.31883" 
    capture_lex $P1203
    .const 'Sub' $P1197 = "36_1310110678.31883" 
    capture_lex $P1197
    .const 'Sub' $P1191 = "35_1310110678.31883" 
    capture_lex $P1191
    .const 'Sub' $P1164 = "30_1310110678.31883" 
    capture_lex $P1164
    .const 'Sub' $P1154 = "29_1310110678.31883" 
    capture_lex $P1154
    .const 'Sub' $P1125 = "26_1310110678.31883" 
    capture_lex $P1125
    .const 'Sub' $P1103 = "23_1310110678.31883" 
    capture_lex $P1103
    .const 'Sub' $P1079 = "22_1310110678.31883" 
    capture_lex $P1079
    .const 'Sub' $P1073 = "21_1310110678.31883" 
    capture_lex $P1073
    .const 'Sub' $P1066 = "20_1310110678.31883" 
    capture_lex $P1066
    .const 'Sub' $P1046 = "17_1310110678.31883" 
    capture_lex $P1046
    .const 'Sub' $P1039 = "16_1310110678.31883" 
    capture_lex $P1039
    .const 'Sub' $P1029 = "14_1310110678.31883" 
    capture_lex $P1029
.annotate 'line', 14
    new $P103, "Undef"
    set $P1026, $P103
    .lex "$loader", $P1026
    .lex "$?PACKAGE", $P1027
    .lex "$?CLASS", $P1028
    get_hll_global $P104, "ModuleLoader"
    store_lex "$loader", $P104
.annotate 'line', 401
    .const 'Sub' $P1207 = "38_1310110678.31883" 
    newclosure $P1217, $P1207
.annotate 'line', 9
    .return ($P1217)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.include "except_types.pasm"
.sub "load_setting" :anon :subid("14_1310110678.31883") :outer("13_1310110678.31883")
    .param pmc param_1032
    .param pmc param_1033
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 17
    .const 'Sub' $P1036 = "15_1310110678.31883" 
    capture_lex $P1036
    new $P1031, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P1031, control_1030
    push_eh $P1031
    .lex "self", param_1032
    .lex "$setting_name", param_1033
.annotate 'line', 19
    find_lex $P105, "$setting_name"
    unless_null $P105, vivify_648
    new $P105, "Undef"
  vivify_648:
    set $S100, $P105
    isne $I100, $S100, "NULL"
    if $I100, if_1034
    new $P104, 'Integer'
    set $P104, $I100
    goto if_1034_end
  if_1034:
    .const 'Sub' $P1036 = "15_1310110678.31883" 
    capture_lex $P1036
    $P107 = $P1036()
    set $P104, $P107
  if_1034_end:
.annotate 'line', 17
    .return ($P104)
  control_1030:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P105, exception, "payload"
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.include "except_types.pasm"
.sub "_block1035"  :anon :subid("15_1310110678.31883") :outer("14_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 23
    new $P106, "Undef"
    set $P1037, $P106
    .lex "$setting", $P1037
.annotate 'line', 24
    find_lex $P107, "$loader"
    unless_null $P107, vivify_649
    new $P107, "Undef"
  vivify_649:
    find_lex $P108, "$setting_name"
    unless_null $P108, vivify_650
    new $P108, "Undef"
  vivify_650:
    $P109 = $P107."load_setting"($P108)
    find_dynamic_lex $P112, "%*COMPILING"
    unless_null $P112, vivify_651
    get_hll_global $P110, "GLOBAL"
    get_who $P111, $P110
    set $P112, $P111["%COMPILING"]
    unless_null $P112, vivify_652
    die "Contextual %*COMPILING not found"
  vivify_652:
    store_dynamic_lex "%*COMPILING", $P112
  vivify_651:
    set $P1038, $P112["%?OPTIONS"]
    unless_null $P1038, vivify_653
    $P1038 = root_new ['parrot';'Hash']
    set $P112["%?OPTIONS"], $P1038
  vivify_653:
    set $P1038["outer_ctx"], $P109
    store_lex "$setting", $P109
.annotate 'line', 27
    find_lex $P107, "self"
    get_hll_global $P108, "GLOBAL"
    nqp_get_package_through_who $P109, $P108, "PAST"
    get_who $P110, $P109
    set $P111, $P110["Stmts"]
.annotate 'line', 28
    get_hll_global $P112, "GLOBAL"
    nqp_get_package_through_who $P113, $P112, "PAST"
    get_who $P114, $P113
    set $P115, $P114["Op"]
    $P116 = $P115."new"("ModuleLoader.pbc", "load_bytecode vs" :named("pirop"))
.annotate 'line', 31
    get_hll_global $P117, "GLOBAL"
    nqp_get_package_through_who $P118, $P117, "PAST"
    get_who $P119, $P118
    set $P120, $P119["Op"]
.annotate 'line', 33
    get_hll_global $P121, "GLOBAL"
    nqp_get_package_through_who $P122, $P121, "PAST"
    get_who $P123, $P122
    set $P124, $P123["Var"]
    $P125 = $P124."new"("block" :named("name"), "register" :named("scope"))
.annotate 'line', 34
    get_hll_global $P126, "GLOBAL"
    nqp_get_package_through_who $P127, $P126, "PAST"
    get_who $P128, $P127
    set $P129, $P128["Op"]
.annotate 'line', 36
    get_hll_global $P130, "GLOBAL"
    nqp_get_package_through_who $P131, $P130, "PAST"
    get_who $P132, $P131
    set $P133, $P132["Var"]
    new $P134, "ResizablePMCArray"
    $P135 = $P133."new"("ModuleLoader" :named("name"), $P134 :named("namespace"), "package" :named("scope"))
    find_lex $P136, "$setting_name"
    unless_null $P136, vivify_654
    new $P136, "Undef"
  vivify_654:
    $P137 = $P129."new"($P135, $P136, "callmethod" :named("pasttype"), "load_setting" :named("name"))
.annotate 'line', 34
    $P138 = $P120."new"($P125, $P137, "callmethod" :named("pasttype"), "set_outer_ctx" :named("name"))
.annotate 'line', 31
    $P139 = $P111."new"($P116, $P138)
.annotate 'line', 27
    $P107."add_event"($P139 :named("deserialize_past"))
.annotate 'line', 42
    new $P107, "Exception"
    set $P107['type'], .CONTROL_RETURN
    find_lex $P108, "$setting"
    unless_null $P108, vivify_655
    new $P108, "Undef"
  vivify_655:
    getattribute $P109, $P108, "lex_pad"
    setattribute $P107, 'payload', $P109
    throw $P107
.annotate 'line', 19
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.include "except_types.pasm"
.sub "load_module" :anon :subid("16_1310110678.31883") :outer("13_1310110678.31883")
    .param pmc param_1042
    .param pmc param_1043
    .param pmc param_1044
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 48
    new $P1041, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P1041, control_1040
    push_eh $P1041
    .lex "self", param_1042
    .lex "$module_name", param_1043
    .lex "$cur_GLOBALish", param_1044
.annotate 'line', 50
    new $P104, "Undef"
    set $P1045, $P104
    .lex "$module", $P1045
    find_lex $P105, "$loader"
    unless_null $P105, vivify_656
    new $P105, "Undef"
  vivify_656:
    find_lex $P106, "$module_name"
    unless_null $P106, vivify_657
    new $P106, "Undef"
  vivify_657:
    find_lex $P107, "$cur_GLOBALish"
    unless_null $P107, vivify_658
    new $P107, "Undef"
  vivify_658:
    $P108 = $P105."load_module"($P106, $P107)
    store_lex "$module", $P108
.annotate 'line', 53
    find_lex $P105, "self"
    get_hll_global $P106, "GLOBAL"
    nqp_get_package_through_who $P107, $P106, "PAST"
    get_who $P108, $P107
    set $P109, $P108["Stmts"]
.annotate 'line', 54
    get_hll_global $P110, "GLOBAL"
    nqp_get_package_through_who $P111, $P110, "PAST"
    get_who $P112, $P111
    set $P113, $P112["Op"]
    $P114 = $P113."new"("ModuleLoader.pbc", "load_bytecode vs" :named("pirop"))
.annotate 'line', 57
    get_hll_global $P115, "GLOBAL"
    nqp_get_package_through_who $P116, $P115, "PAST"
    get_who $P117, $P116
    set $P118, $P117["Op"]
.annotate 'line', 59
    get_hll_global $P119, "GLOBAL"
    nqp_get_package_through_who $P120, $P119, "PAST"
    get_who $P121, $P120
    set $P122, $P121["Var"]
    new $P123, "ResizablePMCArray"
    $P124 = $P122."new"("ModuleLoader" :named("name"), $P123 :named("namespace"), "package" :named("scope"))
    find_lex $P125, "$module_name"
    unless_null $P125, vivify_659
    new $P125, "Undef"
  vivify_659:
.annotate 'line', 61
    find_lex $P126, "self"
    find_lex $P127, "$cur_GLOBALish"
    unless_null $P127, vivify_660
    new $P127, "Undef"
  vivify_660:
    $P128 = $P126."get_slot_past_for_object"($P127)
    $P129 = $P118."new"($P124, $P125, $P128, "callmethod" :named("pasttype"), "load_module" :named("name"))
.annotate 'line', 57
    $P130 = $P109."new"($P114, $P129)
.annotate 'line', 53
    $P105."add_event"($P130 :named("deserialize_past"))
.annotate 'line', 64
    new $P105, "Exception"
    set $P105['type'], .CONTROL_RETURN
    find_lex $P106, "$module"
    unless_null $P106, vivify_661
    new $P106, "Undef"
  vivify_661:
    getattribute $P107, $P106, "lex_pad"
    setattribute $P105, 'payload', $P107
    throw $P105
.annotate 'line', 48
    .return ()
  control_1040:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P105, exception, "payload"
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.include "except_types.pasm"
.sub "install_package_symbol" :anon :subid("17_1310110678.31883") :outer("13_1310110678.31883")
    .param pmc param_1047
    .param pmc param_1048
    .param pmc param_1049
    .param pmc param_1050
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 69
    .const 'Sub' $P1063 = "19_1310110678.31883" 
    capture_lex $P1063
    .const 'Sub' $P1058 = "18_1310110678.31883" 
    capture_lex $P1058
    .lex "self", param_1047
    .lex "$package", param_1048
    .lex "@sym", param_1049
    .lex "$obj", param_1050
.annotate 'line', 71
    new $P104, "Undef"
    set $P1051, $P104
    .lex "$name", $P1051
.annotate 'line', 74
    new $P105, "Undef"
    set $P1052, $P105
    .lex "$target", $P1052
.annotate 'line', 81
    new $P106, "Undef"
    set $P1053, $P106
    .lex "$path", $P1053
.annotate 'line', 70
    find_lex $P1054, "@sym"
    unless_null $P1054, vivify_662
    $P1054 = root_new ['parrot';'ResizablePMCArray']
  vivify_662:
    clone $P107, $P1054
    store_lex "@sym", $P107
.annotate 'line', 71
    find_lex $P1055, "@sym"
    unless_null $P1055, vivify_663
    $P1055 = root_new ['parrot';'ResizablePMCArray']
  vivify_663:
    $P107 = $P1055."pop"()
    set $S100, $P107
    new $P108, 'String'
    set $P108, $S100
    store_lex "$name", $P108
.annotate 'line', 74
    find_lex $P107, "$package"
    unless_null $P107, vivify_664
    new $P107, "Undef"
  vivify_664:
    store_lex "$target", $P107
.annotate 'line', 75
    find_lex $P1056, "@sym"
    unless_null $P1056, vivify_665
    $P1056 = root_new ['parrot';'ResizablePMCArray']
  vivify_665:
    defined $I100, $P1056
    unless $I100, for_undef_666
    iter $P107, $P1056
    new $P109, 'ExceptionHandler'
    set_label $P109, loop1060_handler
    $P109."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P109
  loop1060_test:
    unless $P107, loop1060_done
    shift $P108, $P107
  loop1060_redo:
    .const 'Sub' $P1058 = "18_1310110678.31883" 
    capture_lex $P1058
    $P1058($P108)
  loop1060_next:
    goto loop1060_test
  loop1060_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P110, exception, 'type'
    eq $P110, .CONTROL_LOOP_NEXT, loop1060_next
    eq $P110, .CONTROL_LOOP_REDO, loop1060_redo
  loop1060_done:
    pop_eh 
  for_undef_666:
.annotate 'line', 78
    find_lex $P107, "$obj"
    unless_null $P107, vivify_669
    new $P107, "Undef"
  vivify_669:
    find_lex $P108, "$name"
    unless_null $P108, vivify_670
    new $P108, "Undef"
  vivify_670:
    find_lex $P109, "$target"
    unless_null $P109, vivify_671
    new $P109, "Undef"
    store_lex "$target", $P109
  vivify_671:
    get_who $P110, $P109
    set $P110[$P108], $P107
.annotate 'line', 81
    find_lex $P107, "self"
    find_lex $P108, "$package"
    unless_null $P108, vivify_672
    new $P108, "Undef"
  vivify_672:
    $P109 = $P107."get_slot_past_for_object"($P108)
    store_lex "$path", $P109
.annotate 'line', 82
    find_lex $P1061, "@sym"
    unless_null $P1061, vivify_673
    $P1061 = root_new ['parrot';'ResizablePMCArray']
  vivify_673:
    defined $I100, $P1061
    unless $I100, for_undef_674
    iter $P107, $P1061
    new $P109, 'ExceptionHandler'
    set_label $P109, loop1065_handler
    $P109."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P109
  loop1065_test:
    unless $P107, loop1065_done
    shift $P108, $P107
  loop1065_redo:
    .const 'Sub' $P1063 = "19_1310110678.31883" 
    capture_lex $P1063
    $P1063($P108)
  loop1065_next:
    goto loop1065_test
  loop1065_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P110, exception, 'type'
    eq $P110, .CONTROL_LOOP_NEXT, loop1065_next
    eq $P110, .CONTROL_LOOP_REDO, loop1065_redo
  loop1065_done:
    pop_eh 
  for_undef_674:
.annotate 'line', 85
    find_lex $P107, "self"
    get_hll_global $P108, "GLOBAL"
    nqp_get_package_through_who $P109, $P108, "PAST"
    get_who $P110, $P109
    set $P111, $P110["Op"]
.annotate 'line', 87
    get_hll_global $P112, "GLOBAL"
    nqp_get_package_through_who $P113, $P112, "PAST"
    get_who $P114, $P113
    set $P115, $P114["Var"]
.annotate 'line', 89
    get_hll_global $P116, "GLOBAL"
    nqp_get_package_through_who $P117, $P116, "PAST"
    get_who $P118, $P117
    set $P119, $P118["Op"]
    find_lex $P120, "$path"
    unless_null $P120, vivify_677
    new $P120, "Undef"
  vivify_677:
    $P121 = $P119."new"($P120, "get_who PP" :named("pirop"))
    find_lex $P122, "$name"
    unless_null $P122, vivify_678
    new $P122, "Undef"
  vivify_678:
    $P123 = $P115."new"($P121, $P122, "keyed" :named("scope"))
.annotate 'line', 92
    find_lex $P124, "self"
    find_lex $P125, "$obj"
    unless_null $P125, vivify_679
    new $P125, "Undef"
  vivify_679:
    $P126 = $P124."get_slot_past_for_object"($P125)
    $P127 = $P111."new"($P123, $P126, "bind_6model" :named("pasttype"))
.annotate 'line', 85
    $P128 = $P107."add_event"($P127 :named("deserialize_past"))
.annotate 'line', 69
    .return ($P128)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block1057"  :anon :subid("18_1310110678.31883") :outer("17_1310110678.31883")
    .param pmc param_1059
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 75
    .lex "$_", param_1059
.annotate 'line', 76
    find_lex $P109, "$target"
    unless_null $P109, vivify_667
    new $P109, "Undef"
  vivify_667:
    find_lex $P110, "$_"
    unless_null $P110, vivify_668
    new $P110, "Undef"
  vivify_668:
    set $S100, $P110
    nqp_get_package_through_who $P111, $P109, $S100
    store_lex "$target", $P111
.annotate 'line', 75
    .return ($P111)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block1062"  :anon :subid("19_1310110678.31883") :outer("17_1310110678.31883")
    .param pmc param_1064
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 82
    .lex "$_", param_1064
.annotate 'line', 83
    get_hll_global $P109, "GLOBAL"
    nqp_get_package_through_who $P110, $P109, "PAST"
    get_who $P111, $P110
    set $P112, $P111["Op"]
    find_lex $P113, "$path"
    unless_null $P113, vivify_675
    new $P113, "Undef"
  vivify_675:
    find_lex $P114, "$_"
    unless_null $P114, vivify_676
    new $P114, "Undef"
  vivify_676:
    set $S100, $P114
    $P115 = $P112."new"($P113, $S100, "nqp_get_package_through_who PPs" :named("pirop"))
    store_lex "$path", $P115
.annotate 'line', 82
    .return ($P115)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "install_lexical_symbol" :anon :subid("20_1310110678.31883") :outer("13_1310110678.31883")
    .param pmc param_1067
    .param pmc param_1068
    .param pmc param_1069
    .param pmc param_1070
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 100
    .lex "self", param_1067
    .lex "$block", param_1068
    .lex "$name", param_1069
    .lex "$obj", param_1070
.annotate 'line', 106
    new $P104, "Undef"
    set $P1071, $P104
    .lex "$fixup", $P1071
.annotate 'line', 102
    find_lex $P105, "$block"
    unless_null $P105, vivify_680
    new $P105, "Undef"
  vivify_680:
    find_lex $P106, "$name"
    unless_null $P106, vivify_681
    new $P106, "Undef"
  vivify_681:
    find_lex $P107, "$obj"
    unless_null $P107, vivify_682
    new $P107, "Undef"
  vivify_682:
    $P105."symbol"($P106, "lexical" :named("scope"), $P107 :named("value"))
.annotate 'line', 103
    find_lex $P1072, "$block"
    unless_null $P1072, vivify_683
    $P1072 = root_new ['parrot';'ResizablePMCArray']
  vivify_683:
    set $P105, $P1072[0]
    unless_null $P105, vivify_684
    new $P105, "Undef"
  vivify_684:
    get_hll_global $P106, "GLOBAL"
    nqp_get_package_through_who $P107, $P106, "PAST"
    get_who $P108, $P107
    set $P109, $P108["Var"]
    find_lex $P110, "$name"
    unless_null $P110, vivify_685
    new $P110, "Undef"
  vivify_685:
    $P111 = $P109."new"("lexical" :named("scope"), $P110 :named("name"), 1 :named("isdecl"))
    $P105."push"($P111)
.annotate 'line', 106
    get_hll_global $P105, "GLOBAL"
    nqp_get_package_through_who $P106, $P105, "PAST"
    get_who $P107, $P106
    set $P108, $P107["Stmts"]
.annotate 'line', 107
    get_hll_global $P109, "GLOBAL"
    nqp_get_package_through_who $P110, $P109, "PAST"
    get_who $P111, $P110
    set $P112, $P111["Op"]
.annotate 'line', 109
    get_hll_global $P113, "GLOBAL"
    nqp_get_package_through_who $P114, $P113, "PAST"
    get_who $P115, $P114
    set $P116, $P115["Op"]
.annotate 'line', 111
    get_hll_global $P117, "GLOBAL"
    nqp_get_package_through_who $P118, $P117, "PAST"
    get_who $P119, $P118
    set $P120, $P119["Val"]
    find_lex $P121, "$block"
    unless_null $P121, vivify_686
    new $P121, "Undef"
  vivify_686:
    $P122 = $P120."new"($P121 :named("value"))
    $P123 = $P116."new"($P122, "callmethod" :named("pasttype"), "get_lexinfo" :named("name"))
.annotate 'line', 113
    find_lex $P124, "$name"
    unless_null $P124, vivify_687
    new $P124, "Undef"
  vivify_687:
    set $S100, $P124
    find_lex $P125, "self"
    find_lex $P126, "$obj"
    unless_null $P126, vivify_688
    new $P126, "Undef"
  vivify_688:
    $P127 = $P125."get_slot_past_for_object"($P126)
    $P128 = $P112."new"($P123, $S100, $P127, "callmethod" :named("pasttype"), "set_static_lexpad_value" :named("name"))
.annotate 'line', 117
    get_hll_global $P129, "GLOBAL"
    nqp_get_package_through_who $P130, $P129, "PAST"
    get_who $P131, $P130
    set $P132, $P131["Op"]
.annotate 'line', 119
    get_hll_global $P133, "GLOBAL"
    nqp_get_package_through_who $P134, $P133, "PAST"
    get_who $P135, $P134
    set $P136, $P135["Op"]
.annotate 'line', 121
    get_hll_global $P137, "GLOBAL"
    nqp_get_package_through_who $P138, $P137, "PAST"
    get_who $P139, $P138
    set $P140, $P139["Val"]
    find_lex $P141, "$block"
    unless_null $P141, vivify_689
    new $P141, "Undef"
  vivify_689:
    $P142 = $P140."new"($P141 :named("value"))
    $P143 = $P136."new"($P142, "callmethod" :named("pasttype"), "get_lexinfo" :named("name"))
.annotate 'line', 119
    $P144 = $P132."new"($P143, "callmethod" :named("pasttype"), "finish_static_lexpad" :named("name"))
.annotate 'line', 117
    $P145 = $P108."new"($P128, $P144)
.annotate 'line', 106
    store_lex "$fixup", $P145
.annotate 'line', 125
    find_lex $P105, "self"
    find_lex $P106, "$fixup"
    unless_null $P106, vivify_690
    new $P106, "Undef"
  vivify_690:
    find_lex $P107, "$fixup"
    unless_null $P107, vivify_691
    new $P107, "Undef"
  vivify_691:
    $P108 = $P105."add_event"($P106 :named("deserialize_past"), $P107 :named("fixup_past"))
.annotate 'line', 100
    .return ($P108)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "install_package_routine" :anon :subid("21_1310110678.31883") :outer("13_1310110678.31883")
    .param pmc param_1074
    .param pmc param_1075
    .param pmc param_1076
    .param pmc param_1077
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 130
    .lex "self", param_1074
    .lex "$package", param_1075
    .lex "$name", param_1076
    .lex "$past_block", param_1077
.annotate 'line', 131
    new $P104, "Undef"
    set $P1078, $P104
    .lex "$fixup", $P1078
    get_hll_global $P105, "GLOBAL"
    nqp_get_package_through_who $P106, $P105, "PAST"
    get_who $P107, $P106
    set $P108, $P107["Op"]
.annotate 'line', 133
    get_hll_global $P109, "GLOBAL"
    nqp_get_package_through_who $P110, $P109, "PAST"
    get_who $P111, $P110
    set $P112, $P111["Var"]
.annotate 'line', 135
    get_hll_global $P113, "GLOBAL"
    nqp_get_package_through_who $P114, $P113, "PAST"
    get_who $P115, $P114
    set $P116, $P115["Op"]
    find_lex $P117, "self"
    find_lex $P118, "$package"
    unless_null $P118, vivify_692
    new $P118, "Undef"
  vivify_692:
    $P119 = $P117."get_slot_past_for_object"($P118)
    $P120 = $P116."new"($P119, "get_who PP" :named("pirop"))
.annotate 'line', 136
    find_lex $P121, "$name"
    unless_null $P121, vivify_693
    new $P121, "Undef"
  vivify_693:
    set $S100, $P121
    $P122 = $P112."new"($P120, $S100, "keyed" :named("scope"))
.annotate 'line', 138
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P126, $P125["Val"]
    find_lex $P127, "$past_block"
    unless_null $P127, vivify_694
    new $P127, "Undef"
  vivify_694:
    $P128 = $P126."new"($P127 :named("value"))
    $P129 = $P108."new"($P122, $P128, "bind_6model" :named("pasttype"))
.annotate 'line', 131
    store_lex "$fixup", $P129
.annotate 'line', 140
    find_lex $P105, "self"
    find_lex $P106, "$fixup"
    unless_null $P106, vivify_695
    new $P106, "Undef"
  vivify_695:
    find_lex $P107, "$fixup"
    unless_null $P107, vivify_696
    new $P107, "Undef"
  vivify_696:
    $P108 = $P105."add_event"($P106 :named("deserialize_past"), $P107 :named("fixup_past"))
.annotate 'line', 130
    .return ($P108)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.include "except_types.pasm"
.sub "pkg_create_mo" :anon :subid("22_1310110678.31883") :outer("13_1310110678.31883")
    .param pmc param_1082
    .param pmc param_1083
    .param pmc param_1084 :optional :named("name")
    .param int has_param_1084 :opt_flag
    .param pmc param_1085 :optional :named("repr")
    .param int has_param_1085 :opt_flag
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 145
    new $P1081, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P1081, control_1080
    push_eh $P1081
    .lex "self", param_1082
    .lex "$how", param_1083
    if has_param_1084, optparam_697
    new $P104, "Undef"
    set param_1084, $P104
  optparam_697:
    .lex "$name", param_1084
    if has_param_1085, optparam_698
    new $P105, "Undef"
    set param_1085, $P105
  optparam_698:
    .lex "$repr", param_1085
.annotate 'line', 147
    $P1087 = root_new ['parrot';'Hash']
    set $P1086, $P1087
    .lex "%args", $P1086
.annotate 'line', 150
    new $P106, "Undef"
    set $P1088, $P106
    .lex "$mo", $P1088
.annotate 'line', 151
    new $P107, "Undef"
    set $P1089, $P107
    .lex "$slot", $P1089
.annotate 'line', 155
    $P1091 = root_new ['parrot';'ResizablePMCArray']
    set $P1090, $P1091
    .lex "@how_ns", $P1090
.annotate 'line', 156
    new $P108, "Undef"
    set $P1092, $P108
    .lex "$how_name", $P1092
.annotate 'line', 157
    new $P109, "Undef"
    set $P1093, $P109
    .lex "$setup_call", $P1093
.annotate 'line', 145
    find_lex $P1094, "%args"
    unless_null $P1094, vivify_699
    $P1094 = root_new ['parrot';'Hash']
  vivify_699:
.annotate 'line', 148
    find_lex $P110, "$name"
    unless_null $P110, vivify_700
    new $P110, "Undef"
  vivify_700:
    defined $I100, $P110
    unless $I100, if_1095_end
    find_lex $P111, "$name"
    unless_null $P111, vivify_701
    new $P111, "Undef"
  vivify_701:
    find_lex $P1096, "%args"
    unless_null $P1096, vivify_702
    $P1096 = root_new ['parrot';'Hash']
    store_lex "%args", $P1096
  vivify_702:
    set $P1096["name"], $P111
  if_1095_end:
.annotate 'line', 149
    find_lex $P110, "$repr"
    unless_null $P110, vivify_703
    new $P110, "Undef"
  vivify_703:
    defined $I100, $P110
    unless $I100, if_1097_end
    find_lex $P111, "$repr"
    unless_null $P111, vivify_704
    new $P111, "Undef"
  vivify_704:
    find_lex $P1098, "%args"
    unless_null $P1098, vivify_705
    $P1098 = root_new ['parrot';'Hash']
    store_lex "%args", $P1098
  vivify_705:
    set $P1098["repr"], $P111
  if_1097_end:
.annotate 'line', 150
    find_lex $P110, "$how"
    unless_null $P110, vivify_706
    new $P110, "Undef"
  vivify_706:
    find_lex $P1099, "%args"
    unless_null $P1099, vivify_707
    $P1099 = root_new ['parrot';'Hash']
  vivify_707:
    $P111 = $P110."new_type"($P1099 :flat)
    store_lex "$mo", $P111
.annotate 'line', 151
    find_lex $P110, "self"
    find_lex $P111, "$mo"
    unless_null $P111, vivify_708
    new $P111, "Undef"
  vivify_708:
    $P112 = $P110."add_object"($P111)
    store_lex "$slot", $P112
.annotate 'line', 155
    find_lex $P110, "$how"
    unless_null $P110, vivify_709
    new $P110, "Undef"
  vivify_709:
    get_how $P111, $P110
    find_lex $P112, "$how"
    unless_null $P112, vivify_710
    new $P112, "Undef"
  vivify_710:
    $S100 = $P111."name"($P112)
    split $P113, "::", $S100
    store_lex "@how_ns", $P113
.annotate 'line', 156
    find_lex $P1100, "@how_ns"
    unless_null $P1100, vivify_711
    $P1100 = root_new ['parrot';'ResizablePMCArray']
  vivify_711:
    $P110 = $P1100."pop"()
    store_lex "$how_name", $P110
.annotate 'line', 157
    get_hll_global $P110, "GLOBAL"
    nqp_get_package_through_who $P111, $P110, "PAST"
    get_who $P112, $P111
    set $P113, $P112["Op"]
.annotate 'line', 159
    find_lex $P114, "self"
    find_lex $P115, "$how"
    unless_null $P115, vivify_712
    new $P115, "Undef"
  vivify_712:
    $P116 = $P114."get_object_sc_ref_past"($P115)
    $P117 = $P113."new"($P116, "callmethod" :named("pasttype"), "new_type" :named("name"))
.annotate 'line', 157
    store_lex "$setup_call", $P117
.annotate 'line', 161
    find_lex $P110, "$name"
    unless_null $P110, vivify_713
    new $P110, "Undef"
  vivify_713:
    defined $I100, $P110
    unless $I100, if_1101_end
.annotate 'line', 162
    find_lex $P111, "$setup_call"
    unless_null $P111, vivify_714
    new $P111, "Undef"
  vivify_714:
    get_hll_global $P112, "GLOBAL"
    nqp_get_package_through_who $P113, $P112, "PAST"
    get_who $P114, $P113
    set $P115, $P114["Val"]
    find_lex $P116, "$name"
    unless_null $P116, vivify_715
    new $P116, "Undef"
  vivify_715:
    $P117 = $P115."new"($P116 :named("value"), "name" :named("named"))
    $P111."push"($P117)
  if_1101_end:
.annotate 'line', 164
    find_lex $P110, "$repr"
    unless_null $P110, vivify_716
    new $P110, "Undef"
  vivify_716:
    defined $I100, $P110
    unless $I100, if_1102_end
.annotate 'line', 165
    find_lex $P111, "$setup_call"
    unless_null $P111, vivify_717
    new $P111, "Undef"
  vivify_717:
    get_hll_global $P112, "GLOBAL"
    nqp_get_package_through_who $P113, $P112, "PAST"
    get_who $P114, $P113
    set $P115, $P114["Val"]
    find_lex $P116, "$repr"
    unless_null $P116, vivify_718
    new $P116, "Undef"
  vivify_718:
    $P117 = $P115."new"($P116 :named("value"), "repr" :named("named"))
    $P111."push"($P117)
  if_1102_end:
.annotate 'line', 167
    find_lex $P110, "self"
.annotate 'line', 168
    find_lex $P111, "self"
    find_lex $P112, "$slot"
    unless_null $P112, vivify_719
    new $P112, "Undef"
  vivify_719:
    find_lex $P113, "self"
    find_lex $P114, "$setup_call"
    unless_null $P114, vivify_720
    new $P114, "Undef"
  vivify_720:
    $P115 = $P113."set_cur_sc"($P114)
    $P116 = $P111."set_slot_past"($P112, $P115)
.annotate 'line', 167
    $P110."add_event"($P116 :named("deserialize_past"))
.annotate 'line', 171
    new $P110, "Exception"
    set $P110['type'], .CONTROL_RETURN
    find_lex $P111, "$mo"
    unless_null $P111, vivify_721
    new $P111, "Undef"
  vivify_721:
    setattribute $P110, 'payload', $P111
    throw $P110
.annotate 'line', 145
    .return ()
  control_1080:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P110, exception, "payload"
    .return ($P110)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.include "except_types.pasm"
.sub "pkg_add_attribute" :anon :subid("23_1310110678.31883") :outer("13_1310110678.31883")
    .param pmc param_1104
    .param pmc param_1105
    .param pmc param_1106
    .param pmc param_1107
    .param pmc param_1108
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 179
    .const 'Sub' $P1121 = "25_1310110678.31883" 
    capture_lex $P1121
    .const 'Sub' $P1116 = "24_1310110678.31883" 
    capture_lex $P1116
    .lex "self", param_1104
    .lex "$obj", param_1105
    .lex "$meta_attr", param_1106
    .lex "%lit_args", param_1107
    .lex "%obj_args", param_1108
.annotate 'line', 181
    new $P104, "Undef"
    set $P1109, $P104
    .lex "$attr", $P1109
.annotate 'line', 185
    new $P105, "Undef"
    set $P1110, $P105
    .lex "$create_call", $P1110
.annotate 'line', 197
    new $P106, "Undef"
    set $P1111, $P106
    .lex "$obj_slot_past", $P1111
.annotate 'line', 181
    find_lex $P107, "$meta_attr"
    unless_null $P107, vivify_722
    new $P107, "Undef"
  vivify_722:
    find_lex $P1112, "%lit_args"
    unless_null $P1112, vivify_723
    $P1112 = root_new ['parrot';'Hash']
  vivify_723:
    find_lex $P1113, "%obj_args"
    unless_null $P1113, vivify_724
    $P1113 = root_new ['parrot';'Hash']
  vivify_724:
    $P108 = $P107."new"($P1112 :flat, $P1113 :flat)
    store_lex "$attr", $P108
.annotate 'line', 182
    find_lex $P107, "$obj"
    unless_null $P107, vivify_725
    new $P107, "Undef"
  vivify_725:
    get_how $P108, $P107
    find_lex $P109, "$obj"
    unless_null $P109, vivify_726
    new $P109, "Undef"
  vivify_726:
    find_lex $P110, "$attr"
    unless_null $P110, vivify_727
    new $P110, "Undef"
  vivify_727:
    $P108."add_attribute"($P109, $P110)
.annotate 'line', 185
    get_hll_global $P107, "GLOBAL"
    nqp_get_package_through_who $P108, $P107, "PAST"
    get_who $P109, $P108
    set $P110, $P109["Op"]
.annotate 'line', 187
    find_lex $P111, "self"
    find_lex $P112, "$meta_attr"
    unless_null $P112, vivify_728
    new $P112, "Undef"
  vivify_728:
    $P113 = $P111."get_object_sc_ref_past"($P112)
    $P114 = $P110."new"($P113, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 185
    store_lex "$create_call", $P114
.annotate 'line', 189
    find_lex $P1114, "%lit_args"
    unless_null $P1114, vivify_729
    $P1114 = root_new ['parrot';'Hash']
  vivify_729:
    defined $I100, $P1114
    unless $I100, for_undef_730
    iter $P107, $P1114
    new $P109, 'ExceptionHandler'
    set_label $P109, loop1118_handler
    $P109."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P109
  loop1118_test:
    unless $P107, loop1118_done
    shift $P108, $P107
  loop1118_redo:
    .const 'Sub' $P1116 = "24_1310110678.31883" 
    capture_lex $P1116
    $P1116($P108)
  loop1118_next:
    goto loop1118_test
  loop1118_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P110, exception, 'type'
    eq $P110, .CONTROL_LOOP_NEXT, loop1118_next
    eq $P110, .CONTROL_LOOP_REDO, loop1118_redo
  loop1118_done:
    pop_eh 
  for_undef_730:
.annotate 'line', 192
    find_lex $P1119, "%obj_args"
    unless_null $P1119, vivify_734
    $P1119 = root_new ['parrot';'Hash']
  vivify_734:
    defined $I100, $P1119
    unless $I100, for_undef_735
    iter $P107, $P1119
    new $P110, 'ExceptionHandler'
    set_label $P110, loop1124_handler
    $P110."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P110
  loop1124_test:
    unless $P107, loop1124_done
    shift $P108, $P107
  loop1124_redo:
    .const 'Sub' $P1121 = "25_1310110678.31883" 
    capture_lex $P1121
    $P1121($P108)
  loop1124_next:
    goto loop1124_test
  loop1124_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P111, exception, 'type'
    eq $P111, .CONTROL_LOOP_NEXT, loop1124_next
    eq $P111, .CONTROL_LOOP_REDO, loop1124_redo
  loop1124_done:
    pop_eh 
  for_undef_735:
.annotate 'line', 197
    find_lex $P107, "self"
    find_lex $P108, "$obj"
    unless_null $P108, vivify_741
    new $P108, "Undef"
  vivify_741:
    $P109 = $P107."get_slot_past_for_object"($P108)
    store_lex "$obj_slot_past", $P109
.annotate 'line', 198
    find_lex $P107, "self"
    get_hll_global $P108, "GLOBAL"
    nqp_get_package_through_who $P109, $P108, "PAST"
    get_who $P110, $P109
    set $P111, $P110["Op"]
.annotate 'line', 200
    get_hll_global $P112, "GLOBAL"
    nqp_get_package_through_who $P113, $P112, "PAST"
    get_who $P114, $P113
    set $P115, $P114["Op"]
    find_lex $P116, "$obj_slot_past"
    unless_null $P116, vivify_742
    new $P116, "Undef"
  vivify_742:
    $P117 = $P115."new"($P116, "get_how PP" :named("pirop"))
    find_lex $P118, "$obj_slot_past"
    unless_null $P118, vivify_743
    new $P118, "Undef"
  vivify_743:
    find_lex $P119, "$create_call"
    unless_null $P119, vivify_744
    new $P119, "Undef"
  vivify_744:
    $P120 = $P111."new"($P117, $P118, $P119, "callmethod" :named("pasttype"), "add_attribute" :named("name"))
.annotate 'line', 198
    $P121 = $P107."add_event"($P120 :named("deserialize_past"))
.annotate 'line', 179
    .return ($P121)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block1115"  :anon :subid("24_1310110678.31883") :outer("23_1310110678.31883")
    .param pmc param_1117
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 189
    .lex "$_", param_1117
.annotate 'line', 190
    find_lex $P109, "$create_call"
    unless_null $P109, vivify_731
    new $P109, "Undef"
  vivify_731:
    get_hll_global $P110, "GLOBAL"
    nqp_get_package_through_who $P111, $P110, "PAST"
    get_who $P112, $P111
    set $P113, $P112["Val"]
    find_lex $P114, "$_"
    unless_null $P114, vivify_732
    new $P114, "Undef"
  vivify_732:
    $P115 = $P114."value"()
    find_lex $P116, "$_"
    unless_null $P116, vivify_733
    new $P116, "Undef"
  vivify_733:
    $P117 = $P116."key"()
    $P118 = $P113."new"($P115 :named("value"), $P117 :named("named"))
    $P119 = $P109."push"($P118)
.annotate 'line', 189
    .return ($P119)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block1120"  :anon :subid("25_1310110678.31883") :outer("23_1310110678.31883")
    .param pmc param_1123
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 193
    new $P109, "Undef"
    set $P1122, $P109
    .lex "$lookup", $P1122
    .lex "$_", param_1123
    find_lex $P110, "self"
    find_lex $P111, "$_"
    unless_null $P111, vivify_736
    new $P111, "Undef"
  vivify_736:
    $P112 = $P111."value"()
    $P113 = $P110."get_object_sc_ref_past"($P112)
    store_lex "$lookup", $P113
.annotate 'line', 194
    find_lex $P110, "$lookup"
    unless_null $P110, vivify_737
    new $P110, "Undef"
  vivify_737:
    find_lex $P111, "$_"
    unless_null $P111, vivify_738
    new $P111, "Undef"
  vivify_738:
    $P112 = $P111."key"()
    $P110."named"($P112)
.annotate 'line', 195
    find_lex $P110, "$create_call"
    unless_null $P110, vivify_739
    new $P110, "Undef"
  vivify_739:
    find_lex $P111, "$lookup"
    unless_null $P111, vivify_740
    new $P111, "Undef"
  vivify_740:
    $P112 = $P110."push"($P111)
.annotate 'line', 192
    .return ($P112)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "pkg_add_method" :anon :subid("26_1310110678.31883") :outer("13_1310110678.31883")
    .param pmc param_1126
    .param pmc param_1127
    .param pmc param_1128
    .param pmc param_1129
    .param pmc param_1130
    .param pmc param_1131
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 209
    .const 'Sub' $P1149 = "28_1310110678.31883" 
    capture_lex $P1149
    .const 'Sub' $P1137 = "27_1310110678.31883" 
    capture_lex $P1137
    .lex "self", param_1126
    .lex "$obj", param_1127
    .lex "$meta_method_name", param_1128
    .lex "$name", param_1129
    .lex "$method_past", param_1130
    .lex "$is_dispatcher", param_1131
.annotate 'line', 215
    new $P104, "Undef"
    set $P1132, $P104
    .lex "$stub_code", $P1132
.annotate 'line', 221
    new $P105, "Undef"
    set $P1133, $P105
    .lex "$fixups", $P1133
.annotate 'line', 222
    new $P106, "Undef"
    set $P1134, $P106
    .lex "$dummy", $P1134
.annotate 'line', 267
    new $P107, "Undef"
    set $P1135, $P107
    .lex "$slot_past", $P1135
.annotate 'line', 215
    .const 'Sub' $P1137 = "27_1310110678.31883" 
    newclosure $P1143, $P1137
    store_lex "$stub_code", $P1143
.annotate 'line', 221
    get_hll_global $P108, "GLOBAL"
    nqp_get_package_through_who $P109, $P108, "PAST"
    get_who $P110, $P109
    set $P111, $P110["Stmts"]
    $P112 = $P111."new"()
    store_lex "$fixups", $P112
.annotate 'line', 209
    find_lex $P108, "$dummy"
    unless_null $P108, vivify_749
    new $P108, "Undef"
  vivify_749:
.annotate 'line', 223
    find_lex $P1145, "$method_past"
    unless_null $P1145, vivify_750
    $P1145 = root_new ['parrot';'Hash']
  vivify_750:
    set $P108, $P1145["compile_time_dummy"]
    unless_null $P108, vivify_751
    new $P108, "Undef"
  vivify_751:
    defined $I100, $P108
    if $I100, if_1144
.annotate 'line', 230
    find_lex $P109, "$is_dispatcher"
    unless_null $P109, vivify_752
    new $P109, "Undef"
  vivify_752:
    if $P109, if_1147
.annotate 'line', 246
    find_lex $P110, "$stub_code"
    unless_null $P110, vivify_753
    new $P110, "Undef"
  vivify_753:
    clone $P111, $P110
    store_lex "$dummy", $P111
.annotate 'line', 245
    goto if_1147_end
  if_1147:
.annotate 'line', 231
    find_lex $P110, "$method_past"
    unless_null $P110, vivify_754
    new $P110, "Undef"
  vivify_754:
    $P110."pirflags"(":instanceof(\"DispatcherSub\")")
.annotate 'line', 232
    new $P110, "DispatcherSub"
    find_lex $P111, "$stub_code"
    unless_null $P111, vivify_755
    new $P111, "Undef"
  vivify_755:
    assign $P110, $P111
    store_lex "$dummy", $P110
.annotate 'line', 236
    find_lex $P110, "$dummy"
    unless_null $P110, vivify_756
    new $P110, "Undef"
  vivify_756:
    .const 'Sub' $P1149 = "28_1310110678.31883" 
    newclosure $P1152, $P1149
    setprop $P110, "CLONE_CALLBACK", $P1152
  if_1147_end:
.annotate 'line', 248
    find_lex $P109, "$dummy"
    unless_null $P109, vivify_761
    new $P109, "Undef"
  vivify_761:
    find_lex $P110, "$name"
    unless_null $P110, vivify_762
    new $P110, "Undef"
  vivify_762:
    set $S100, $P110
    assign $P109, $S100
.annotate 'line', 249
    find_lex $P109, "self"
    find_lex $P110, "$dummy"
    unless_null $P110, vivify_763
    new $P110, "Undef"
  vivify_763:
    $P109."add_code"($P110)
.annotate 'line', 250
    find_lex $P109, "$dummy"
    unless_null $P109, vivify_764
    new $P109, "Undef"
  vivify_764:
    find_lex $P1153, "$method_past"
    unless_null $P1153, vivify_765
    $P1153 = root_new ['parrot';'Hash']
    store_lex "$method_past", $P1153
  vivify_765:
    set $P1153["compile_time_dummy"], $P109
.annotate 'line', 226
    goto if_1144_end
  if_1144:
.annotate 'line', 224
    find_lex $P1146, "$method_past"
    unless_null $P1146, vivify_766
    $P1146 = root_new ['parrot';'Hash']
  vivify_766:
    set $P109, $P1146["compile_time_dummy"]
    unless_null $P109, vivify_767
    new $P109, "Undef"
  vivify_767:
    store_lex "$dummy", $P109
  if_1144_end:
.annotate 'line', 254
    find_lex $P108, "$dummy"
    unless_null $P108, vivify_768
    new $P108, "Undef"
  vivify_768:
    find_lex $P109, "$method_past"
    unless_null $P109, vivify_769
    new $P109, "Undef"
  vivify_769:
    setprop $P108, "PAST", $P109
.annotate 'line', 257
    find_lex $P108, "$obj"
    unless_null $P108, vivify_770
    new $P108, "Undef"
  vivify_770:
    get_how $P109, $P108
    find_lex $P110, "$obj"
    unless_null $P110, vivify_771
    new $P110, "Undef"
  vivify_771:
    find_lex $P111, "$name"
    unless_null $P111, vivify_772
    new $P111, "Undef"
  vivify_772:
    find_lex $P112, "$dummy"
    unless_null $P112, vivify_773
    new $P112, "Undef"
  vivify_773:
    find_lex $P113, "$meta_method_name"
    unless_null $P113, vivify_774
    new $P113, "Undef"
  vivify_774:
    set $S100, $P113
    $P109.$S100($P110, $P111, $P112)
.annotate 'line', 262
    find_lex $P108, "$fixups"
    unless_null $P108, vivify_775
    new $P108, "Undef"
  vivify_775:
    get_hll_global $P109, "GLOBAL"
    nqp_get_package_through_who $P110, $P109, "PAST"
    get_who $P111, $P110
    set $P112, $P111["Op"]
.annotate 'line', 264
    find_lex $P113, "self"
    find_lex $P114, "$dummy"
    unless_null $P114, vivify_776
    new $P114, "Undef"
  vivify_776:
    $P115 = $P113."get_slot_past_for_object"($P114)
.annotate 'line', 265
    get_hll_global $P116, "GLOBAL"
    nqp_get_package_through_who $P117, $P116, "PAST"
    get_who $P118, $P117
    set $P119, $P118["Val"]
    find_lex $P120, "$method_past"
    unless_null $P120, vivify_777
    new $P120, "Undef"
  vivify_777:
    $P121 = $P119."new"($P120 :named("value"))
    $P122 = $P112."new"($P115, $P121, "assign vPP" :named("pirop"))
.annotate 'line', 262
    $P108."push"($P122)
.annotate 'line', 267
    find_lex $P108, "self"
    find_lex $P109, "$obj"
    unless_null $P109, vivify_778
    new $P109, "Undef"
  vivify_778:
    $P110 = $P108."get_slot_past_for_object"($P109)
    store_lex "$slot_past", $P110
.annotate 'line', 268
    find_lex $P108, "self"
.annotate 'line', 269
    get_hll_global $P109, "GLOBAL"
    nqp_get_package_through_who $P110, $P109, "PAST"
    get_who $P111, $P110
    set $P112, $P111["Op"]
    find_lex $P113, "$meta_method_name"
    unless_null $P113, vivify_779
    new $P113, "Undef"
  vivify_779:
.annotate 'line', 271
    get_hll_global $P114, "GLOBAL"
    nqp_get_package_through_who $P115, $P114, "PAST"
    get_who $P116, $P115
    set $P117, $P116["Op"]
    find_lex $P118, "$slot_past"
    unless_null $P118, vivify_780
    new $P118, "Undef"
  vivify_780:
    $P119 = $P117."new"($P118, "get_how PP" :named("pirop"))
    find_lex $P120, "$slot_past"
    unless_null $P120, vivify_781
    new $P120, "Undef"
  vivify_781:
    find_lex $P121, "$name"
    unless_null $P121, vivify_782
    new $P121, "Undef"
  vivify_782:
.annotate 'line', 274
    get_hll_global $P122, "GLOBAL"
    nqp_get_package_through_who $P123, $P122, "PAST"
    get_who $P124, $P123
    set $P125, $P124["Val"]
    find_lex $P126, "$method_past"
    unless_null $P126, vivify_783
    new $P126, "Undef"
  vivify_783:
    $P127 = $P125."new"($P126 :named("value"))
    $P128 = $P112."new"($P119, $P120, $P121, $P127, "callmethod" :named("pasttype"), $P113 :named("name"))
.annotate 'line', 268
    find_lex $P129, "$fixups"
    unless_null $P129, vivify_784
    new $P129, "Undef"
  vivify_784:
    $P130 = $P108."add_event"($P128 :named("deserialize_past"), $P129 :named("fixup_past"))
.annotate 'line', 209
    .return ($P130)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block1136"  :anon :subid("27_1310110678.31883") :outer("26_1310110678.31883")
    .param pmc param_1138 :slurpy
    .param pmc param_1139 :slurpy :named
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 215
    .lex "@args", param_1138
    .lex "%named", param_1139
.annotate 'line', 216
    new $P108, "Undef"
    set $P1140, $P108
    .lex "$compiled", $P1140
    get_hll_global $P109, "GLOBAL"
    nqp_get_package_through_who $P110, $P109, "PAST"
    get_who $P111, $P110
    set $P112, $P111["Compiler"]
    find_lex $P113, "$method_past"
    unless_null $P113, vivify_745
    new $P113, "Undef"
  vivify_745:
    $P114 = $P112."compile"($P113)
    store_lex "$compiled", $P114
.annotate 'line', 217
    find_lex $P109, "$compiled"
    unless_null $P109, vivify_746
    new $P109, "Undef"
  vivify_746:
    find_lex $P1141, "@args"
    unless_null $P1141, vivify_747
    $P1141 = root_new ['parrot';'ResizablePMCArray']
  vivify_747:
    find_lex $P1142, "%named"
    unless_null $P1142, vivify_748
    $P1142 = root_new ['parrot';'Hash']
  vivify_748:
    $P110 = $P109($P1141 :flat, $P1142 :flat)
.annotate 'line', 215
    .return ($P110)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block1148"  :anon :subid("28_1310110678.31883") :outer("26_1310110678.31883")
    .param pmc param_1150
    .param pmc param_1151
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 236
    .lex "$orig", param_1150
    .lex "$clone", param_1151
.annotate 'line', 237
    find_lex $P111, "self"
    find_lex $P112, "$clone"
    unless_null $P112, vivify_757
    new $P112, "Undef"
  vivify_757:
    $P111."add_code"($P112)
.annotate 'line', 238
    find_lex $P111, "$fixups"
    unless_null $P111, vivify_758
    new $P111, "Undef"
  vivify_758:
    get_hll_global $P112, "GLOBAL"
    nqp_get_package_through_who $P113, $P112, "PAST"
    get_who $P114, $P113
    set $P115, $P114["Op"]
.annotate 'line', 240
    find_lex $P116, "self"
    find_lex $P117, "$clone"
    unless_null $P117, vivify_759
    new $P117, "Undef"
  vivify_759:
    $P118 = $P116."get_slot_past_for_object"($P117)
.annotate 'line', 241
    get_hll_global $P119, "GLOBAL"
    nqp_get_package_through_who $P120, $P119, "PAST"
    get_who $P121, $P120
    set $P122, $P121["Val"]
    find_lex $P123, "$orig"
    unless_null $P123, vivify_760
    new $P123, "Undef"
  vivify_760:
    getprop $P124, "PAST", $P123
    $P125 = $P122."new"($P124 :named("value"))
    $P126 = $P115."new"($P118, $P125, "assign vPP" :named("pirop"))
.annotate 'line', 238
    $P127 = $P111."push"($P126)
.annotate 'line', 236
    .return ($P127)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "set_routine_signature" :anon :subid("29_1310110678.31883") :outer("13_1310110678.31883")
    .param pmc param_1155
    .param pmc param_1156
    .param pmc param_1157
    .param pmc param_1158
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 280
    .lex "self", param_1155
    .lex "$routine", param_1156
    .lex "$types", param_1157
    .lex "$definednesses", param_1158
.annotate 'line', 283
    new $P104, "Undef"
    set $P1159, $P104
    .lex "$fixup", $P1159
.annotate 'line', 290
    new $P105, "Undef"
    set $P1160, $P105
    .lex "$des", $P1160
.annotate 'line', 283
    get_hll_global $P106, "GLOBAL"
    nqp_get_package_through_who $P107, $P106, "PAST"
    get_who $P108, $P107
    set $P109, $P108["Op"]
    find_lex $P110, "$types"
    unless_null $P110, vivify_785
    new $P110, "Undef"
  vivify_785:
    find_lex $P111, "$definednesses"
    unless_null $P111, vivify_786
    new $P111, "Undef"
  vivify_786:
    $P112 = $P109."new"($P110, $P111, "set_sub_multisig vPPP" :named("pirop"))
    store_lex "$fixup", $P112
.annotate 'line', 284
    find_lex $P1162, "$routine"
    unless_null $P1162, vivify_787
    $P1162 = root_new ['parrot';'Hash']
  vivify_787:
    set $P106, $P1162["compile_time_dummy"]
    unless_null $P106, vivify_788
    new $P106, "Undef"
  vivify_788:
    defined $I100, $P106
    if $I100, if_1161
.annotate 'line', 288
    find_lex $P107, "$fixup"
    unless_null $P107, vivify_789
    new $P107, "Undef"
  vivify_789:
    get_hll_global $P108, "GLOBAL"
    nqp_get_package_through_who $P109, $P108, "PAST"
    get_who $P110, $P109
    set $P111, $P110["Val"]
    find_lex $P112, "$routine"
    unless_null $P112, vivify_790
    new $P112, "Undef"
  vivify_790:
    $P113 = $P111."new"($P112 :named("value"))
    $P107."unshift"($P113)
.annotate 'line', 287
    goto if_1161_end
  if_1161:
.annotate 'line', 285
    find_lex $P107, "$fixup"
    unless_null $P107, vivify_791
    new $P107, "Undef"
  vivify_791:
    find_lex $P108, "self"
    find_lex $P1163, "$routine"
    unless_null $P1163, vivify_792
    $P1163 = root_new ['parrot';'Hash']
  vivify_792:
    set $P109, $P1163["compile_time_dummy"]
    unless_null $P109, vivify_793
    new $P109, "Undef"
  vivify_793:
    $P110 = $P108."get_slot_past_for_object"($P109)
    $P107."unshift"($P110)
  if_1161_end:
.annotate 'line', 290
    get_hll_global $P106, "GLOBAL"
    nqp_get_package_through_who $P107, $P106, "PAST"
    get_who $P108, $P107
    set $P109, $P108["Op"]
.annotate 'line', 291
    get_hll_global $P110, "GLOBAL"
    nqp_get_package_through_who $P111, $P110, "PAST"
    get_who $P112, $P111
    set $P113, $P112["Val"]
    find_lex $P114, "$routine"
    unless_null $P114, vivify_794
    new $P114, "Undef"
  vivify_794:
    $P115 = $P113."new"($P114 :named("value"))
    find_lex $P116, "$types"
    unless_null $P116, vivify_795
    new $P116, "Undef"
  vivify_795:
    find_lex $P117, "$definednesses"
    unless_null $P117, vivify_796
    new $P117, "Undef"
  vivify_796:
    $P118 = $P109."new"($P115, $P116, $P117, "set_sub_multisig vPPP" :named("pirop"))
.annotate 'line', 290
    store_lex "$des", $P118
.annotate 'line', 293
    find_lex $P106, "self"
    find_lex $P107, "$des"
    unless_null $P107, vivify_797
    new $P107, "Undef"
  vivify_797:
    find_lex $P108, "$fixup"
    unless_null $P108, vivify_798
    new $P108, "Undef"
  vivify_798:
    $P109 = $P106."add_event"($P107 :named("deserialize_past"), $P108 :named("fixup_past"))
.annotate 'line', 280
    .return ($P109)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "pkg_set_body_block" :anon :subid("30_1310110678.31883") :outer("13_1310110678.31883")
    .param pmc param_1165
    .param pmc param_1166
    .param pmc param_1167
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 297
    .const 'Sub' $P1173 = "31_1310110678.31883" 
    capture_lex $P1173
    .lex "self", param_1165
    .lex "$obj", param_1166
    .lex "$body_past", param_1167
.annotate 'line', 308
    new $P104, "Undef"
    set $P1168, $P104
    .lex "$fixups", $P1168
.annotate 'line', 309
    new $P105, "Undef"
    set $P1169, $P105
    .lex "$dummy", $P1169
.annotate 'line', 344
    new $P106, "Undef"
    set $P1170, $P106
    .lex "$slot_past", $P1170
.annotate 'line', 345
    new $P107, "Undef"
    set $P1171, $P107
    .lex "$des", $P1171
.annotate 'line', 308
    get_hll_global $P108, "GLOBAL"
    nqp_get_package_through_who $P109, $P108, "PAST"
    get_who $P110, $P109
    set $P111, $P110["Stmts"]
    $P112 = $P111."new"()
    store_lex "$fixups", $P112
.annotate 'line', 309
    .const 'Sub' $P1173 = "31_1310110678.31883" 
    newclosure $P1190, $P1173
    store_lex "$dummy", $P1190
.annotate 'line', 341
    find_lex $P108, "$obj"
    unless_null $P108, vivify_816
    new $P108, "Undef"
  vivify_816:
    get_how $P109, $P108
    find_lex $P110, "$obj"
    unless_null $P110, vivify_817
    new $P110, "Undef"
  vivify_817:
    find_lex $P111, "$dummy"
    unless_null $P111, vivify_818
    new $P111, "Undef"
  vivify_818:
    $P109."set_body_block"($P110, $P111)
.annotate 'line', 344
    find_lex $P108, "self"
    find_lex $P109, "$obj"
    unless_null $P109, vivify_819
    new $P109, "Undef"
  vivify_819:
    $P110 = $P108."get_slot_past_for_object"($P109)
    store_lex "$slot_past", $P110
.annotate 'line', 345
    get_hll_global $P108, "GLOBAL"
    nqp_get_package_through_who $P109, $P108, "PAST"
    get_who $P110, $P109
    set $P111, $P110["Op"]
.annotate 'line', 347
    get_hll_global $P112, "GLOBAL"
    nqp_get_package_through_who $P113, $P112, "PAST"
    get_who $P114, $P113
    set $P115, $P114["Op"]
    find_lex $P116, "$slot_past"
    unless_null $P116, vivify_820
    new $P116, "Undef"
  vivify_820:
    $P117 = $P115."new"($P116, "get_how PP" :named("pirop"))
    find_lex $P118, "$slot_past"
    unless_null $P118, vivify_821
    new $P118, "Undef"
  vivify_821:
.annotate 'line', 349
    get_hll_global $P119, "GLOBAL"
    nqp_get_package_through_who $P120, $P119, "PAST"
    get_who $P121, $P120
    set $P122, $P121["Val"]
    find_lex $P123, "$body_past"
    unless_null $P123, vivify_822
    new $P123, "Undef"
  vivify_822:
    $P124 = $P122."new"($P123 :named("value"))
    $P125 = $P111."new"($P117, $P118, $P124, "callmethod" :named("pasttype"), "set_body_block" :named("name"))
.annotate 'line', 345
    store_lex "$des", $P125
.annotate 'line', 352
    find_lex $P108, "self"
    find_lex $P109, "$des"
    unless_null $P109, vivify_823
    new $P109, "Undef"
  vivify_823:
    find_lex $P110, "$fixups"
    unless_null $P110, vivify_824
    new $P110, "Undef"
  vivify_824:
    $P111 = $P108."add_event"($P109 :named("deserialize_past"), $P110 :named("fixup_past"))
.annotate 'line', 297
    .return ($P111)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.include "except_types.pasm"
.sub "_block1172"  :anon :subid("31_1310110678.31883") :outer("30_1310110678.31883")
    .param pmc param_1174 :slurpy
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 309
    .const 'Sub' $P1182 = "33_1310110678.31883" 
    capture_lex $P1182
    .const 'Sub' $P1178 = "32_1310110678.31883" 
    capture_lex $P1178
    .lex "@type_args", param_1174
.annotate 'line', 311
    new $P108, "Undef"
    set $P1175, $P108
    .lex "$invoke_body", $P1175
    get_hll_global $P109, "GLOBAL"
    nqp_get_package_through_who $P110, $P109, "PAST"
    get_who $P111, $P110
    set $P112, $P111["Op"]
.annotate 'line', 313
    get_hll_global $P113, "GLOBAL"
    nqp_get_package_through_who $P114, $P113, "PAST"
    get_who $P115, $P114
    set $P116, $P115["Val"]
    find_lex $P117, "$body_past"
    unless_null $P117, vivify_799
    new $P117, "Undef"
  vivify_799:
    $P118 = $P116."new"($P117 :named("value"))
    $P119 = $P112."new"($P118, "call" :named("pasttype"))
.annotate 'line', 311
    store_lex "$invoke_body", $P119
.annotate 'line', 315
    find_lex $P1176, "@type_args"
    unless_null $P1176, vivify_800
    $P1176 = root_new ['parrot';'ResizablePMCArray']
  vivify_800:
    defined $I100, $P1176
    unless $I100, for_undef_801
    iter $P109, $P1176
    new $P111, 'ExceptionHandler'
    set_label $P111, loop1180_handler
    $P111."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P111
  loop1180_test:
    unless $P109, loop1180_done
    shift $P110, $P109
  loop1180_redo:
    .const 'Sub' $P1178 = "32_1310110678.31883" 
    capture_lex $P1178
    $P1178($P110)
  loop1180_next:
    goto loop1180_test
  loop1180_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P112, exception, 'type'
    eq $P112, .CONTROL_LOOP_NEXT, loop1180_next
    eq $P112, .CONTROL_LOOP_REDO, loop1180_redo
  loop1180_done:
    pop_eh 
  for_undef_801:
.annotate 'line', 318
    find_lex $P109, "$fixups"
    unless_null $P109, vivify_804
    new $P109, "Undef"
  vivify_804:
    find_lex $P110, "$invoke_body"
    unless_null $P110, vivify_805
    new $P110, "Undef"
  vivify_805:
    $P109."push"($P110)
.annotate 'line', 321
    find_lex $P110, "$obj"
    unless_null $P110, vivify_806
    new $P110, "Undef"
  vivify_806:
    get_how $P111, $P110
    find_lex $P112, "$obj"
    unless_null $P112, vivify_807
    new $P112, "Undef"
  vivify_807:
    $P113 = $P111."methods"($P112, 1 :named("local"))
    defined $I100, $P113
    unless $I100, for_undef_808
    iter $P109, $P113
    new $P115, 'ExceptionHandler'
    set_label $P115, loop1189_handler
    $P115."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P115
  loop1189_test:
    unless $P109, loop1189_done
    shift $P114, $P109
  loop1189_redo:
    .const 'Sub' $P1182 = "33_1310110678.31883" 
    capture_lex $P1182
    $P1182($P114)
  loop1189_next:
    goto loop1189_test
  loop1189_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P116, exception, 'type'
    eq $P116, .CONTROL_LOOP_NEXT, loop1189_next
    eq $P116, .CONTROL_LOOP_REDO, loop1189_redo
  loop1189_done:
    pop_eh 
  for_undef_808:
.annotate 'line', 309
    .return ($P109)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block1177"  :anon :subid("32_1310110678.31883") :outer("31_1310110678.31883")
    .param pmc param_1179
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 315
    .lex "$_", param_1179
.annotate 'line', 316
    find_lex $P111, "$invoke_body"
    unless_null $P111, vivify_802
    new $P111, "Undef"
  vivify_802:
    find_lex $P112, "self"
    find_lex $P113, "$_"
    unless_null $P113, vivify_803
    new $P113, "Undef"
  vivify_803:
    $P114 = $P112."get_slot_past_for_object"($P113)
    $P115 = $P111."push"($P114)
.annotate 'line', 315
    .return ($P115)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block1181"  :anon :subid("33_1310110678.31883") :outer("31_1310110678.31883")
    .param pmc param_1183
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 321
    .const 'Sub' $P1185 = "34_1310110678.31883" 
    capture_lex $P1185
    .lex "$_", param_1183
.annotate 'line', 322
    find_lex $P115, "$_"
    unless_null $P115, vivify_809
    new $P115, "Undef"
  vivify_809:
    .const 'Sub' $P1185 = "34_1310110678.31883" 
    newclosure $P1188, $P1185
    setprop $P115, "REIFY_CALLBACK", $P1188
.annotate 'line', 321
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block1184"  :anon :subid("34_1310110678.31883") :outer("33_1310110678.31883")
    .param pmc param_1186
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 322
    .lex "$meth", param_1186
.annotate 'line', 324
    new $P116, "Undef"
    set $P1187, $P116
    .lex "$clone", $P1187
    find_lex $P117, "$meth"
    unless_null $P117, vivify_810
    new $P117, "Undef"
  vivify_810:
    clone $P118, $P117
    store_lex "$clone", $P118
.annotate 'line', 325
    find_lex $P117, "self"
    find_lex $P118, "$clone"
    unless_null $P118, vivify_811
    new $P118, "Undef"
  vivify_811:
    $P117."add_code"($P118)
.annotate 'line', 328
    find_lex $P117, "$fixups"
    unless_null $P117, vivify_812
    new $P117, "Undef"
  vivify_812:
    get_hll_global $P118, "GLOBAL"
    nqp_get_package_through_who $P119, $P118, "PAST"
    get_who $P120, $P119
    set $P121, $P120["Op"]
.annotate 'line', 330
    find_lex $P122, "self"
    find_lex $P123, "$clone"
    unless_null $P123, vivify_813
    new $P123, "Undef"
  vivify_813:
    $P124 = $P122."get_slot_past_for_object"($P123)
.annotate 'line', 331
    get_hll_global $P125, "GLOBAL"
    nqp_get_package_through_who $P126, $P125, "PAST"
    get_who $P127, $P126
    set $P128, $P127["Val"]
    find_lex $P129, "$meth"
    unless_null $P129, vivify_814
    new $P129, "Undef"
  vivify_814:
    getprop $P130, "PAST", $P129
    $P131 = $P128."new"($P130 :named("value"))
    $P132 = $P121."new"($P124, $P131, "assign vPP" :named("pirop"))
.annotate 'line', 328
    $P117."push"($P132)
.annotate 'line', 322
    find_lex $P117, "$clone"
    unless_null $P117, vivify_815
    new $P117, "Undef"
  vivify_815:
    .return ($P117)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "pkg_add_parent_or_role" :anon :subid("35_1310110678.31883") :outer("13_1310110678.31883")
    .param pmc param_1192
    .param pmc param_1193
    .param pmc param_1194
    .param pmc param_1195
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 357
    .lex "self", param_1192
    .lex "$obj", param_1193
    .lex "$meta_method_name", param_1194
    .lex "$to_add", param_1195
.annotate 'line', 362
    new $P104, "Undef"
    set $P1196, $P104
    .lex "$slot_past", $P1196
.annotate 'line', 359
    find_lex $P105, "$obj"
    unless_null $P105, vivify_825
    new $P105, "Undef"
  vivify_825:
    get_how $P106, $P105
    find_lex $P107, "$obj"
    unless_null $P107, vivify_826
    new $P107, "Undef"
  vivify_826:
    find_lex $P108, "$to_add"
    unless_null $P108, vivify_827
    new $P108, "Undef"
  vivify_827:
    find_lex $P109, "$meta_method_name"
    unless_null $P109, vivify_828
    new $P109, "Undef"
  vivify_828:
    set $S100, $P109
    $P106.$S100($P107, $P108)
.annotate 'line', 362
    find_lex $P105, "self"
    find_lex $P106, "$obj"
    unless_null $P106, vivify_829
    new $P106, "Undef"
  vivify_829:
    $P107 = $P105."get_slot_past_for_object"($P106)
    store_lex "$slot_past", $P107
.annotate 'line', 363
    find_lex $P105, "self"
    get_hll_global $P106, "GLOBAL"
    nqp_get_package_through_who $P107, $P106, "PAST"
    get_who $P108, $P107
    set $P109, $P108["Op"]
    find_lex $P110, "$meta_method_name"
    unless_null $P110, vivify_830
    new $P110, "Undef"
  vivify_830:
.annotate 'line', 365
    get_hll_global $P111, "GLOBAL"
    nqp_get_package_through_who $P112, $P111, "PAST"
    get_who $P113, $P112
    set $P114, $P113["Op"]
    find_lex $P115, "$slot_past"
    unless_null $P115, vivify_831
    new $P115, "Undef"
  vivify_831:
    $P116 = $P114."new"($P115, "get_how PP" :named("pirop"))
    find_lex $P117, "$slot_past"
    unless_null $P117, vivify_832
    new $P117, "Undef"
  vivify_832:
.annotate 'line', 367
    find_lex $P118, "self"
    find_lex $P119, "$to_add"
    unless_null $P119, vivify_833
    new $P119, "Undef"
  vivify_833:
    $P120 = $P118."get_object_sc_ref_past"($P119)
    $P121 = $P109."new"($P116, $P117, $P120, "callmethod" :named("pasttype"), $P110 :named("name"))
.annotate 'line', 363
    $P122 = $P105."add_event"($P121 :named("deserialize_past"))
.annotate 'line', 357
    .return ($P122)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "pkg_add_parrot_vtable_handler_mapping" :anon :subid("36_1310110678.31883") :outer("13_1310110678.31883")
    .param pmc param_1198
    .param pmc param_1199
    .param pmc param_1200
    .param pmc param_1201
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 371
    .lex "self", param_1198
    .lex "$obj", param_1199
    .lex "$name", param_1200
    .lex "$att_name", param_1201
.annotate 'line', 376
    new $P104, "Undef"
    set $P1202, $P104
    .lex "$slot_past", $P1202
.annotate 'line', 373
    find_lex $P105, "$obj"
    unless_null $P105, vivify_834
    new $P105, "Undef"
  vivify_834:
    get_how $P106, $P105
    find_lex $P107, "$obj"
    unless_null $P107, vivify_835
    new $P107, "Undef"
  vivify_835:
    find_lex $P108, "$name"
    unless_null $P108, vivify_836
    new $P108, "Undef"
  vivify_836:
    find_lex $P109, "$att_name"
    unless_null $P109, vivify_837
    new $P109, "Undef"
  vivify_837:
    $P106."add_parrot_vtable_handler_mapping"($P107, $P108, $P109)
.annotate 'line', 376
    find_lex $P105, "self"
    find_lex $P106, "$obj"
    unless_null $P106, vivify_838
    new $P106, "Undef"
  vivify_838:
    $P107 = $P105."get_slot_past_for_object"($P106)
    store_lex "$slot_past", $P107
.annotate 'line', 377
    find_lex $P105, "self"
    get_hll_global $P106, "GLOBAL"
    nqp_get_package_through_who $P107, $P106, "PAST"
    get_who $P108, $P107
    set $P109, $P108["Op"]
.annotate 'line', 379
    get_hll_global $P110, "GLOBAL"
    nqp_get_package_through_who $P111, $P110, "PAST"
    get_who $P112, $P111
    set $P113, $P112["Op"]
    find_lex $P114, "$slot_past"
    unless_null $P114, vivify_839
    new $P114, "Undef"
  vivify_839:
    $P115 = $P113."new"($P114, "get_how PP" :named("pirop"))
    find_lex $P116, "$slot_past"
    unless_null $P116, vivify_840
    new $P116, "Undef"
  vivify_840:
    find_lex $P117, "$name"
    unless_null $P117, vivify_841
    new $P117, "Undef"
  vivify_841:
    find_lex $P118, "$att_name"
    unless_null $P118, vivify_842
    new $P118, "Undef"
  vivify_842:
    $P119 = $P109."new"($P115, $P116, $P117, $P118, "callmethod" :named("pasttype"), "add_parrot_vtable_handler_mapping" :named("name"))
.annotate 'line', 377
    $P120 = $P105."add_event"($P119 :named("deserialize_past"))
.annotate 'line', 371
    .return ($P120)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "pkg_compose" :anon :subid("37_1310110678.31883") :outer("13_1310110678.31883")
    .param pmc param_1204
    .param pmc param_1205
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 386
    .lex "self", param_1204
    .lex "$obj", param_1205
.annotate 'line', 391
    new $P104, "Undef"
    set $P1206, $P104
    .lex "$slot_past", $P1206
.annotate 'line', 388
    find_lex $P105, "$obj"
    unless_null $P105, vivify_843
    new $P105, "Undef"
  vivify_843:
    get_how $P106, $P105
    find_lex $P107, "$obj"
    unless_null $P107, vivify_844
    new $P107, "Undef"
  vivify_844:
    $P106."compose"($P107)
.annotate 'line', 391
    find_lex $P105, "self"
    find_lex $P106, "$obj"
    unless_null $P106, vivify_845
    new $P106, "Undef"
  vivify_845:
    $P107 = $P105."get_slot_past_for_object"($P106)
    store_lex "$slot_past", $P107
.annotate 'line', 392
    find_lex $P105, "self"
    get_hll_global $P106, "GLOBAL"
    nqp_get_package_through_who $P107, $P106, "PAST"
    get_who $P108, $P107
    set $P109, $P108["Op"]
.annotate 'line', 394
    get_hll_global $P110, "GLOBAL"
    nqp_get_package_through_who $P111, $P110, "PAST"
    get_who $P112, $P111
    set $P113, $P112["Op"]
    find_lex $P114, "$slot_past"
    unless_null $P114, vivify_846
    new $P114, "Undef"
  vivify_846:
    $P115 = $P113."new"($P114, "get_how PP" :named("pirop"))
    find_lex $P116, "$slot_past"
    unless_null $P116, vivify_847
    new $P116, "Undef"
  vivify_847:
    $P117 = $P109."new"($P115, $P116, "callmethod" :named("pasttype"), "compose" :named("name"))
.annotate 'line', 392
    $P118 = $P105."add_event"($P117 :named("deserialize_past"))
.annotate 'line', 386
    .return ($P118)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.include "except_types.pasm"
.sub "to_past" :anon :subid("38_1310110678.31883") :outer("13_1310110678.31883")
    .param pmc param_1208
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 401
    .const 'Sub' $P1212 = "39_1310110678.31883" 
    capture_lex $P1212
    .lex "self", param_1208
.annotate 'line', 402
    new $P104, "Undef"
    set $P1209, $P104
    .lex "$des", $P1209
.annotate 'line', 403
    new $P105, "Undef"
    set $P1210, $P105
    .lex "$fix", $P1210
.annotate 'line', 402
    get_hll_global $P106, "GLOBAL"
    nqp_get_package_through_who $P107, $P106, "PAST"
    get_who $P108, $P107
    set $P109, $P108["Stmts"]
    $P110 = $P109."new"()
    store_lex "$des", $P110
.annotate 'line', 403
    get_hll_global $P106, "GLOBAL"
    nqp_get_package_through_who $P107, $P106, "PAST"
    get_who $P108, $P107
    set $P109, $P108["Stmts"]
    $P110 = $P109."new"()
    store_lex "$fix", $P110
.annotate 'line', 404
    find_lex $P107, "self"
    $P108 = $P107."event_stream"()
    defined $I100, $P108
    unless $I100, for_undef_848
    iter $P106, $P108
    new $P111, 'ExceptionHandler'
    set_label $P111, loop1216_handler
    $P111."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P111
  loop1216_test:
    unless $P106, loop1216_done
    shift $P109, $P106
  loop1216_redo:
    .const 'Sub' $P1212 = "39_1310110678.31883" 
    capture_lex $P1212
    $P1212($P109)
  loop1216_next:
    goto loop1216_test
  loop1216_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P112, exception, 'type'
    eq $P112, .CONTROL_LOOP_NEXT, loop1216_next
    eq $P112, .CONTROL_LOOP_REDO, loop1216_redo
  loop1216_done:
    pop_eh 
  for_undef_848:
.annotate 'line', 408
    find_dynamic_lex $P106, "$/"
    get_hll_global $P107, "GLOBAL"
    nqp_get_package_through_who $P108, $P107, "PAST"
    get_who $P109, $P108
    set $P110, $P109["Op"]
.annotate 'line', 410
    get_hll_global $P111, "GLOBAL"
    nqp_get_package_through_who $P112, $P111, "PAST"
    get_who $P113, $P112
    set $P114, $P113["Op"]
.annotate 'line', 412
    get_hll_global $P115, "GLOBAL"
    nqp_get_package_through_who $P116, $P115, "PAST"
    get_who $P117, $P116
    set $P118, $P117["Op"]
    find_lex $P119, "self"
    $P120 = $P119."handle"()
    $P121 = $P118."new"($P120, "nqp_get_sc Ps" :named("pirop"))
    $P122 = $P114."new"($P121, "isnull IP" :named("pirop"))
.annotate 'line', 414
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P126, $P125["Stmts"]
.annotate 'line', 415
    get_hll_global $P127, "GLOBAL"
    nqp_get_package_through_who $P128, $P127, "PAST"
    get_who $P129, $P128
    set $P130, $P129["Op"]
    $P131 = $P130."new"("nqp_dynop_setup v" :named("pirop"))
.annotate 'line', 416
    get_hll_global $P132, "GLOBAL"
    nqp_get_package_through_who $P133, $P132, "PAST"
    get_who $P134, $P133
    set $P135, $P134["Op"]
.annotate 'line', 418
    get_hll_global $P136, "GLOBAL"
    nqp_get_package_through_who $P137, $P136, "PAST"
    get_who $P138, $P137
    set $P139, $P138["Op"]
    $P140 = $P139."new"("getinterp P" :named("pirop"))
.annotate 'line', 419
    get_hll_global $P141, "GLOBAL"
    nqp_get_package_through_who $P142, $P141, "PAST"
    get_who $P143, $P142
    set $P144, $P143["Op"]
    $P145 = $P144."new"("LexPad", "get_class Ps" :named("pirop"))
.annotate 'line', 420
    get_hll_global $P146, "GLOBAL"
    nqp_get_package_through_who $P147, $P146, "PAST"
    get_who $P148, $P147
    set $P149, $P148["Op"]
    $P150 = $P149."new"("NQPLexPad", "get_class Ps" :named("pirop"))
    $P151 = $P135."new"($P140, $P145, $P150, "callmethod" :named("pasttype"), "hll_map" :named("name"))
.annotate 'line', 422
    get_hll_global $P152, "GLOBAL"
    nqp_get_package_through_who $P153, $P152, "PAST"
    get_who $P154, $P153
    set $P155, $P154["Op"]
.annotate 'line', 424
    get_hll_global $P156, "GLOBAL"
    nqp_get_package_through_who $P157, $P156, "PAST"
    get_who $P158, $P157
    set $P159, $P158["Var"]
    $P160 = $P159."new"("cur_sc" :named("name"), "register" :named("scope"), 1 :named("isdecl"))
.annotate 'line', 425
    get_hll_global $P161, "GLOBAL"
    nqp_get_package_through_who $P162, $P161, "PAST"
    get_who $P163, $P162
    set $P164, $P163["Op"]
    find_lex $P165, "self"
    $P166 = $P165."handle"()
    $P167 = $P164."new"($P166, "nqp_create_sc Ps" :named("pirop"))
    $P168 = $P155."new"($P160, $P167, "bind_6model" :named("pasttype"))
.annotate 'line', 422
    find_lex $P169, "$des"
    unless_null $P169, vivify_855
    new $P169, "Undef"
  vivify_855:
    $P170 = $P126."new"($P131, $P151, $P168, $P169)
.annotate 'line', 414
    find_lex $P171, "$fix"
    unless_null $P171, vivify_856
    new $P171, "Undef"
  vivify_856:
    $P172 = $P110."new"($P122, $P170, $P171, "if" :named("pasttype"))
.annotate 'line', 408
    $P173 = $P106."!make"($P172)
.annotate 'line', 401
    .return ($P173)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block1211"  :anon :subid("39_1310110678.31883") :outer("38_1310110678.31883")
    .param pmc param_1213
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 404
    .lex "$_", param_1213
.annotate 'line', 405
    find_lex $P110, "$_"
    unless_null $P110, vivify_849
    new $P110, "Undef"
  vivify_849:
    $P111 = $P110."deserialize_past"()
    defined $I101, $P111
    unless $I101, if_1214_end
    find_lex $P112, "$des"
    unless_null $P112, vivify_850
    new $P112, "Undef"
  vivify_850:
    get_hll_global $P113, "GLOBAL"
    nqp_get_package_through_who $P114, $P113, "PAST"
    get_who $P115, $P114
    set $P116, $P115["Stmt"]
    find_lex $P117, "$_"
    unless_null $P117, vivify_851
    new $P117, "Undef"
  vivify_851:
    $P118 = $P117."deserialize_past"()
    $P119 = $P116."new"($P118)
    $P112."push"($P119)
  if_1214_end:
.annotate 'line', 406
    find_lex $P111, "$_"
    unless_null $P111, vivify_852
    new $P111, "Undef"
  vivify_852:
    $P112 = $P111."fixup_past"()
    defined $I101, $P112
    if $I101, if_1215
    new $P110, 'Integer'
    set $P110, $I101
    goto if_1215_end
  if_1215:
    find_lex $P113, "$fix"
    unless_null $P113, vivify_853
    new $P113, "Undef"
  vivify_853:
    get_hll_global $P114, "GLOBAL"
    nqp_get_package_through_who $P115, $P114, "PAST"
    get_who $P116, $P115
    set $P117, $P116["Stmt"]
    find_lex $P118, "$_"
    unless_null $P118, vivify_854
    new $P118, "Undef"
  vivify_854:
    $P119 = $P118."fixup_past"()
    $P120 = $P117."new"($P119)
    $P121 = $P113."push"($P120)
    set $P110, $P121
  if_1215_end:
.annotate 'line', 404
    .return ($P110)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1218"  :subid("40_1310110678.31883") :outer("10_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .const 'Sub' $P2312 = "418_1310110678.31883" 
    capture_lex $P2312
    .const 'Sub' $P2311 = "417_1310110678.31883" 
    capture_lex $P2311
    .const 'Sub' $P2307 = "416_1310110678.31883" 
    capture_lex $P2307
    .const 'Sub' $P2306 = "415_1310110678.31883" 
    capture_lex $P2306
    .const 'Sub' $P2302 = "414_1310110678.31883" 
    capture_lex $P2302
    .const 'Sub' $P2301 = "413_1310110678.31883" 
    capture_lex $P2301
    .const 'Sub' $P2297 = "412_1310110678.31883" 
    capture_lex $P2297
    .const 'Sub' $P2296 = "411_1310110678.31883" 
    capture_lex $P2296
    .const 'Sub' $P2292 = "410_1310110678.31883" 
    capture_lex $P2292
    .const 'Sub' $P2291 = "409_1310110678.31883" 
    capture_lex $P2291
    .const 'Sub' $P2285 = "407_1310110678.31883" 
    capture_lex $P2285
    .const 'Sub' $P2284 = "406_1310110678.31883" 
    capture_lex $P2284
    .const 'Sub' $P2280 = "405_1310110678.31883" 
    capture_lex $P2280
    .const 'Sub' $P2279 = "404_1310110678.31883" 
    capture_lex $P2279
    .const 'Sub' $P2275 = "403_1310110678.31883" 
    capture_lex $P2275
    .const 'Sub' $P2274 = "402_1310110678.31883" 
    capture_lex $P2274
    .const 'Sub' $P2270 = "401_1310110678.31883" 
    capture_lex $P2270
    .const 'Sub' $P2269 = "400_1310110678.31883" 
    capture_lex $P2269
    .const 'Sub' $P2265 = "399_1310110678.31883" 
    capture_lex $P2265
    .const 'Sub' $P2264 = "398_1310110678.31883" 
    capture_lex $P2264
    .const 'Sub' $P2261 = "397_1310110678.31883" 
    capture_lex $P2261
    .const 'Sub' $P2260 = "396_1310110678.31883" 
    capture_lex $P2260
    .const 'Sub' $P2256 = "395_1310110678.31883" 
    capture_lex $P2256
    .const 'Sub' $P2255 = "394_1310110678.31883" 
    capture_lex $P2255
    .const 'Sub' $P2251 = "393_1310110678.31883" 
    capture_lex $P2251
    .const 'Sub' $P2250 = "392_1310110678.31883" 
    capture_lex $P2250
    .const 'Sub' $P2246 = "391_1310110678.31883" 
    capture_lex $P2246
    .const 'Sub' $P2245 = "390_1310110678.31883" 
    capture_lex $P2245
    .const 'Sub' $P2241 = "389_1310110678.31883" 
    capture_lex $P2241
    .const 'Sub' $P2240 = "388_1310110678.31883" 
    capture_lex $P2240
    .const 'Sub' $P2236 = "387_1310110678.31883" 
    capture_lex $P2236
    .const 'Sub' $P2235 = "386_1310110678.31883" 
    capture_lex $P2235
    .const 'Sub' $P2231 = "385_1310110678.31883" 
    capture_lex $P2231
    .const 'Sub' $P2230 = "384_1310110678.31883" 
    capture_lex $P2230
    .const 'Sub' $P2226 = "383_1310110678.31883" 
    capture_lex $P2226
    .const 'Sub' $P2225 = "382_1310110678.31883" 
    capture_lex $P2225
    .const 'Sub' $P2221 = "381_1310110678.31883" 
    capture_lex $P2221
    .const 'Sub' $P2220 = "380_1310110678.31883" 
    capture_lex $P2220
    .const 'Sub' $P2216 = "379_1310110678.31883" 
    capture_lex $P2216
    .const 'Sub' $P2215 = "378_1310110678.31883" 
    capture_lex $P2215
    .const 'Sub' $P2211 = "377_1310110678.31883" 
    capture_lex $P2211
    .const 'Sub' $P2210 = "376_1310110678.31883" 
    capture_lex $P2210
    .const 'Sub' $P2206 = "375_1310110678.31883" 
    capture_lex $P2206
    .const 'Sub' $P2205 = "374_1310110678.31883" 
    capture_lex $P2205
    .const 'Sub' $P2201 = "373_1310110678.31883" 
    capture_lex $P2201
    .const 'Sub' $P2200 = "372_1310110678.31883" 
    capture_lex $P2200
    .const 'Sub' $P2196 = "371_1310110678.31883" 
    capture_lex $P2196
    .const 'Sub' $P2195 = "370_1310110678.31883" 
    capture_lex $P2195
    .const 'Sub' $P2191 = "369_1310110678.31883" 
    capture_lex $P2191
    .const 'Sub' $P2190 = "368_1310110678.31883" 
    capture_lex $P2190
    .const 'Sub' $P2186 = "367_1310110678.31883" 
    capture_lex $P2186
    .const 'Sub' $P2185 = "366_1310110678.31883" 
    capture_lex $P2185
    .const 'Sub' $P2181 = "365_1310110678.31883" 
    capture_lex $P2181
    .const 'Sub' $P2180 = "364_1310110678.31883" 
    capture_lex $P2180
    .const 'Sub' $P2176 = "363_1310110678.31883" 
    capture_lex $P2176
    .const 'Sub' $P2175 = "362_1310110678.31883" 
    capture_lex $P2175
    .const 'Sub' $P2171 = "361_1310110678.31883" 
    capture_lex $P2171
    .const 'Sub' $P2170 = "360_1310110678.31883" 
    capture_lex $P2170
    .const 'Sub' $P2166 = "359_1310110678.31883" 
    capture_lex $P2166
    .const 'Sub' $P2165 = "358_1310110678.31883" 
    capture_lex $P2165
    .const 'Sub' $P2161 = "357_1310110678.31883" 
    capture_lex $P2161
    .const 'Sub' $P2160 = "356_1310110678.31883" 
    capture_lex $P2160
    .const 'Sub' $P2156 = "355_1310110678.31883" 
    capture_lex $P2156
    .const 'Sub' $P2155 = "354_1310110678.31883" 
    capture_lex $P2155
    .const 'Sub' $P2151 = "353_1310110678.31883" 
    capture_lex $P2151
    .const 'Sub' $P2150 = "352_1310110678.31883" 
    capture_lex $P2150
    .const 'Sub' $P2146 = "351_1310110678.31883" 
    capture_lex $P2146
    .const 'Sub' $P2145 = "350_1310110678.31883" 
    capture_lex $P2145
    .const 'Sub' $P2141 = "349_1310110678.31883" 
    capture_lex $P2141
    .const 'Sub' $P2140 = "348_1310110678.31883" 
    capture_lex $P2140
    .const 'Sub' $P2136 = "347_1310110678.31883" 
    capture_lex $P2136
    .const 'Sub' $P2135 = "346_1310110678.31883" 
    capture_lex $P2135
    .const 'Sub' $P2131 = "345_1310110678.31883" 
    capture_lex $P2131
    .const 'Sub' $P2130 = "344_1310110678.31883" 
    capture_lex $P2130
    .const 'Sub' $P2126 = "343_1310110678.31883" 
    capture_lex $P2126
    .const 'Sub' $P2125 = "342_1310110678.31883" 
    capture_lex $P2125
    .const 'Sub' $P2121 = "341_1310110678.31883" 
    capture_lex $P2121
    .const 'Sub' $P2120 = "340_1310110678.31883" 
    capture_lex $P2120
    .const 'Sub' $P2116 = "339_1310110678.31883" 
    capture_lex $P2116
    .const 'Sub' $P2115 = "338_1310110678.31883" 
    capture_lex $P2115
    .const 'Sub' $P2111 = "337_1310110678.31883" 
    capture_lex $P2111
    .const 'Sub' $P2110 = "336_1310110678.31883" 
    capture_lex $P2110
    .const 'Sub' $P2106 = "335_1310110678.31883" 
    capture_lex $P2106
    .const 'Sub' $P2105 = "334_1310110678.31883" 
    capture_lex $P2105
    .const 'Sub' $P2101 = "333_1310110678.31883" 
    capture_lex $P2101
    .const 'Sub' $P2100 = "332_1310110678.31883" 
    capture_lex $P2100
    .const 'Sub' $P2096 = "331_1310110678.31883" 
    capture_lex $P2096
    .const 'Sub' $P2095 = "330_1310110678.31883" 
    capture_lex $P2095
    .const 'Sub' $P2091 = "329_1310110678.31883" 
    capture_lex $P2091
    .const 'Sub' $P2090 = "328_1310110678.31883" 
    capture_lex $P2090
    .const 'Sub' $P2086 = "327_1310110678.31883" 
    capture_lex $P2086
    .const 'Sub' $P2085 = "326_1310110678.31883" 
    capture_lex $P2085
    .const 'Sub' $P2081 = "325_1310110678.31883" 
    capture_lex $P2081
    .const 'Sub' $P2080 = "324_1310110678.31883" 
    capture_lex $P2080
    .const 'Sub' $P2076 = "323_1310110678.31883" 
    capture_lex $P2076
    .const 'Sub' $P2075 = "322_1310110678.31883" 
    capture_lex $P2075
    .const 'Sub' $P2072 = "321_1310110678.31883" 
    capture_lex $P2072
    .const 'Sub' $P2071 = "320_1310110678.31883" 
    capture_lex $P2071
    .const 'Sub' $P2068 = "319_1310110678.31883" 
    capture_lex $P2068
    .const 'Sub' $P2067 = "318_1310110678.31883" 
    capture_lex $P2067
    .const 'Sub' $P2064 = "317_1310110678.31883" 
    capture_lex $P2064
    .const 'Sub' $P2063 = "316_1310110678.31883" 
    capture_lex $P2063
    .const 'Sub' $P2060 = "315_1310110678.31883" 
    capture_lex $P2060
    .const 'Sub' $P2059 = "314_1310110678.31883" 
    capture_lex $P2059
    .const 'Sub' $P2056 = "313_1310110678.31883" 
    capture_lex $P2056
    .const 'Sub' $P2055 = "312_1310110678.31883" 
    capture_lex $P2055
    .const 'Sub' $P2052 = "311_1310110678.31883" 
    capture_lex $P2052
    .const 'Sub' $P2051 = "310_1310110678.31883" 
    capture_lex $P2051
    .const 'Sub' $P2048 = "309_1310110678.31883" 
    capture_lex $P2048
    .const 'Sub' $P2047 = "308_1310110678.31883" 
    capture_lex $P2047
    .const 'Sub' $P2044 = "307_1310110678.31883" 
    capture_lex $P2044
    .const 'Sub' $P2043 = "306_1310110678.31883" 
    capture_lex $P2043
    .const 'Sub' $P2038 = "305_1310110678.31883" 
    capture_lex $P2038
    .const 'Sub' $P2037 = "304_1310110678.31883" 
    capture_lex $P2037
    .const 'Sub' $P2034 = "303_1310110678.31883" 
    capture_lex $P2034
    .const 'Sub' $P2033 = "302_1310110678.31883" 
    capture_lex $P2033
    .const 'Sub' $P2030 = "301_1310110678.31883" 
    capture_lex $P2030
    .const 'Sub' $P2029 = "300_1310110678.31883" 
    capture_lex $P2029
    .const 'Sub' $P2026 = "299_1310110678.31883" 
    capture_lex $P2026
    .const 'Sub' $P2025 = "298_1310110678.31883" 
    capture_lex $P2025
    .const 'Sub' $P2020 = "297_1310110678.31883" 
    capture_lex $P2020
    .const 'Sub' $P2019 = "296_1310110678.31883" 
    capture_lex $P2019
    .const 'Sub' $P2014 = "295_1310110678.31883" 
    capture_lex $P2014
    .const 'Sub' $P2013 = "294_1310110678.31883" 
    capture_lex $P2013
    .const 'Sub' $P2010 = "293_1310110678.31883" 
    capture_lex $P2010
    .const 'Sub' $P2009 = "292_1310110678.31883" 
    capture_lex $P2009
    .const 'Sub' $P2006 = "291_1310110678.31883" 
    capture_lex $P2006
    .const 'Sub' $P2005 = "290_1310110678.31883" 
    capture_lex $P2005
    .const 'Sub' $P2002 = "289_1310110678.31883" 
    capture_lex $P2002
    .const 'Sub' $P2001 = "288_1310110678.31883" 
    capture_lex $P2001
    .const 'Sub' $P1998 = "287_1310110678.31883" 
    capture_lex $P1998
    .const 'Sub' $P1997 = "286_1310110678.31883" 
    capture_lex $P1997
    .const 'Sub' $P1993 = "285_1310110678.31883" 
    capture_lex $P1993
    .const 'Sub' $P1992 = "284_1310110678.31883" 
    capture_lex $P1992
    .const 'Sub' $P1988 = "283_1310110678.31883" 
    capture_lex $P1988
    .const 'Sub' $P1987 = "282_1310110678.31883" 
    capture_lex $P1987
    .const 'Sub' $P1983 = "281_1310110678.31883" 
    capture_lex $P1983
    .const 'Sub' $P1982 = "280_1310110678.31883" 
    capture_lex $P1982
    .const 'Sub' $P1978 = "279_1310110678.31883" 
    capture_lex $P1978
    .const 'Sub' $P1977 = "278_1310110678.31883" 
    capture_lex $P1977
    .const 'Sub' $P1974 = "277_1310110678.31883" 
    capture_lex $P1974
    .const 'Sub' $P1973 = "276_1310110678.31883" 
    capture_lex $P1973
    .const 'Sub' $P1970 = "275_1310110678.31883" 
    capture_lex $P1970
    .const 'Sub' $P1965 = "272_1310110678.31883" 
    capture_lex $P1965
    .const 'Sub' $P1959 = "271_1310110678.31883" 
    capture_lex $P1959
    .const 'Sub' $P1958 = "270_1310110678.31883" 
    capture_lex $P1958
    .const 'Sub' $P1954 = "269_1310110678.31883" 
    capture_lex $P1954
    .const 'Sub' $P1953 = "268_1310110678.31883" 
    capture_lex $P1953
    .const 'Sub' $P1950 = "267_1310110678.31883" 
    capture_lex $P1950
    .const 'Sub' $P1949 = "266_1310110678.31883" 
    capture_lex $P1949
    .const 'Sub' $P1945 = "265_1310110678.31883" 
    capture_lex $P1945
    .const 'Sub' $P1944 = "264_1310110678.31883" 
    capture_lex $P1944
    .const 'Sub' $P1941 = "263_1310110678.31883" 
    capture_lex $P1941
    .const 'Sub' $P1940 = "262_1310110678.31883" 
    capture_lex $P1940
    .const 'Sub' $P1934 = "260_1310110678.31883" 
    capture_lex $P1934
    .const 'Sub' $P1933 = "259_1310110678.31883" 
    capture_lex $P1933
    .const 'Sub' $P1927 = "258_1310110678.31883" 
    capture_lex $P1927
    .const 'Sub' $P1926 = "257_1310110678.31883" 
    capture_lex $P1926
    .const 'Sub' $P1922 = "256_1310110678.31883" 
    capture_lex $P1922
    .const 'Sub' $P1921 = "255_1310110678.31883" 
    capture_lex $P1921
    .const 'Sub' $P1915 = "254_1310110678.31883" 
    capture_lex $P1915
    .const 'Sub' $P1914 = "253_1310110678.31883" 
    capture_lex $P1914
    .const 'Sub' $P1909 = "252_1310110678.31883" 
    capture_lex $P1909
    .const 'Sub' $P1908 = "251_1310110678.31883" 
    capture_lex $P1908
    .const 'Sub' $P1905 = "250_1310110678.31883" 
    capture_lex $P1905
    .const 'Sub' $P1904 = "249_1310110678.31883" 
    capture_lex $P1904
    .const 'Sub' $P1900 = "248_1310110678.31883" 
    capture_lex $P1900
    .const 'Sub' $P1895 = "245_1310110678.31883" 
    capture_lex $P1895
    .const 'Sub' $P1888 = "244_1310110678.31883" 
    capture_lex $P1888
    .const 'Sub' $P1887 = "243_1310110678.31883" 
    capture_lex $P1887
    .const 'Sub' $P1877 = "242_1310110678.31883" 
    capture_lex $P1877
    .const 'Sub' $P1876 = "241_1310110678.31883" 
    capture_lex $P1876
    .const 'Sub' $P1870 = "240_1310110678.31883" 
    capture_lex $P1870
    .const 'Sub' $P1865 = "237_1310110678.31883" 
    capture_lex $P1865
    .const 'Sub' $P1862 = "236_1310110678.31883" 
    capture_lex $P1862
    .const 'Sub' $P1861 = "235_1310110678.31883" 
    capture_lex $P1861
    .const 'Sub' $P1858 = "234_1310110678.31883" 
    capture_lex $P1858
    .const 'Sub' $P1857 = "233_1310110678.31883" 
    capture_lex $P1857
    .const 'Sub' $P1854 = "232_1310110678.31883" 
    capture_lex $P1854
    .const 'Sub' $P1853 = "231_1310110678.31883" 
    capture_lex $P1853
    .const 'Sub' $P1846 = "230_1310110678.31883" 
    capture_lex $P1846
    .const 'Sub' $P1845 = "229_1310110678.31883" 
    capture_lex $P1845
    .const 'Sub' $P1832 = "228_1310110678.31883" 
    capture_lex $P1832
    .const 'Sub' $P1831 = "227_1310110678.31883" 
    capture_lex $P1831
    .const 'Sub' $P1823 = "225_1310110678.31883" 
    capture_lex $P1823
    .const 'Sub' $P1822 = "224_1310110678.31883" 
    capture_lex $P1822
    .const 'Sub' $P1818 = "223_1310110678.31883" 
    capture_lex $P1818
    .const 'Sub' $P1817 = "222_1310110678.31883" 
    capture_lex $P1817
    .const 'Sub' $P1811 = "221_1310110678.31883" 
    capture_lex $P1811
    .const 'Sub' $P1810 = "220_1310110678.31883" 
    capture_lex $P1810
    .const 'Sub' $P1804 = "219_1310110678.31883" 
    capture_lex $P1804
    .const 'Sub' $P1799 = "216_1310110678.31883" 
    capture_lex $P1799
    .const 'Sub' $P1794 = "214_1310110678.31883" 
    capture_lex $P1794
    .const 'Sub' $P1793 = "213_1310110678.31883" 
    capture_lex $P1793
    .const 'Sub' $P1778 = "211_1310110678.31883" 
    capture_lex $P1778
    .const 'Sub' $P1777 = "210_1310110678.31883" 
    capture_lex $P1777
    .const 'Sub' $P1766 = "209_1310110678.31883" 
    capture_lex $P1766
    .const 'Sub' $P1765 = "208_1310110678.31883" 
    capture_lex $P1765
    .const 'Sub' $P1761 = "207_1310110678.31883" 
    capture_lex $P1761
    .const 'Sub' $P1760 = "206_1310110678.31883" 
    capture_lex $P1760
    .const 'Sub' $P1756 = "205_1310110678.31883" 
    capture_lex $P1756
    .const 'Sub' $P1751 = "202_1310110678.31883" 
    capture_lex $P1751
    .const 'Sub' $P1741 = "200_1310110678.31883" 
    capture_lex $P1741
    .const 'Sub' $P1740 = "199_1310110678.31883" 
    capture_lex $P1740
    .const 'Sub' $P1736 = "198_1310110678.31883" 
    capture_lex $P1736
    .const 'Sub' $P1735 = "197_1310110678.31883" 
    capture_lex $P1735
    .const 'Sub' $P1728 = "195_1310110678.31883" 
    capture_lex $P1728
    .const 'Sub' $P1727 = "194_1310110678.31883" 
    capture_lex $P1727
    .const 'Sub' $P1722 = "193_1310110678.31883" 
    capture_lex $P1722
    .const 'Sub' $P1721 = "192_1310110678.31883" 
    capture_lex $P1721
    .const 'Sub' $P1717 = "191_1310110678.31883" 
    capture_lex $P1717
    .const 'Sub' $P1716 = "190_1310110678.31883" 
    capture_lex $P1716
    .const 'Sub' $P1712 = "189_1310110678.31883" 
    capture_lex $P1712
    .const 'Sub' $P1711 = "188_1310110678.31883" 
    capture_lex $P1711
    .const 'Sub' $P1707 = "187_1310110678.31883" 
    capture_lex $P1707
    .const 'Sub' $P1702 = "184_1310110678.31883" 
    capture_lex $P1702
    .const 'Sub' $P1658 = "182_1310110678.31883" 
    capture_lex $P1658
    .const 'Sub' $P1657 = "181_1310110678.31883" 
    capture_lex $P1657
    .const 'Sub' $P1651 = "180_1310110678.31883" 
    capture_lex $P1651
    .const 'Sub' $P1650 = "179_1310110678.31883" 
    capture_lex $P1650
    .const 'Sub' $P1644 = "178_1310110678.31883" 
    capture_lex $P1644
    .const 'Sub' $P1643 = "177_1310110678.31883" 
    capture_lex $P1643
    .const 'Sub' $P1637 = "176_1310110678.31883" 
    capture_lex $P1637
    .const 'Sub' $P1636 = "175_1310110678.31883" 
    capture_lex $P1636
    .const 'Sub' $P1630 = "174_1310110678.31883" 
    capture_lex $P1630
    .const 'Sub' $P1629 = "173_1310110678.31883" 
    capture_lex $P1629
    .const 'Sub' $P1623 = "172_1310110678.31883" 
    capture_lex $P1623
    .const 'Sub' $P1622 = "171_1310110678.31883" 
    capture_lex $P1622
    .const 'Sub' $P1616 = "170_1310110678.31883" 
    capture_lex $P1616
    .const 'Sub' $P1615 = "169_1310110678.31883" 
    capture_lex $P1615
    .const 'Sub' $P1609 = "168_1310110678.31883" 
    capture_lex $P1609
    .const 'Sub' $P1604 = "165_1310110678.31883" 
    capture_lex $P1604
    .const 'Sub' $P1601 = "164_1310110678.31883" 
    capture_lex $P1601
    .const 'Sub' $P1600 = "163_1310110678.31883" 
    capture_lex $P1600
    .const 'Sub' $P1597 = "162_1310110678.31883" 
    capture_lex $P1597
    .const 'Sub' $P1596 = "161_1310110678.31883" 
    capture_lex $P1596
    .const 'Sub' $P1588 = "160_1310110678.31883" 
    capture_lex $P1588
    .const 'Sub' $P1587 = "159_1310110678.31883" 
    capture_lex $P1587
    .const 'Sub' $P1580 = "158_1310110678.31883" 
    capture_lex $P1580
    .const 'Sub' $P1579 = "157_1310110678.31883" 
    capture_lex $P1579
    .const 'Sub' $P1575 = "156_1310110678.31883" 
    capture_lex $P1575
    .const 'Sub' $P1574 = "155_1310110678.31883" 
    capture_lex $P1574
    .const 'Sub' $P1571 = "154_1310110678.31883" 
    capture_lex $P1571
    .const 'Sub' $P1570 = "153_1310110678.31883" 
    capture_lex $P1570
    .const 'Sub' $P1567 = "152_1310110678.31883" 
    capture_lex $P1567
    .const 'Sub' $P1566 = "151_1310110678.31883" 
    capture_lex $P1566
    .const 'Sub' $P1563 = "150_1310110678.31883" 
    capture_lex $P1563
    .const 'Sub' $P1562 = "149_1310110678.31883" 
    capture_lex $P1562
    .const 'Sub' $P1549 = "146_1310110678.31883" 
    capture_lex $P1549
    .const 'Sub' $P1548 = "145_1310110678.31883" 
    capture_lex $P1548
    .const 'Sub' $P1545 = "144_1310110678.31883" 
    capture_lex $P1545
    .const 'Sub' $P1544 = "143_1310110678.31883" 
    capture_lex $P1544
    .const 'Sub' $P1541 = "142_1310110678.31883" 
    capture_lex $P1541
    .const 'Sub' $P1540 = "141_1310110678.31883" 
    capture_lex $P1540
    .const 'Sub' $P1537 = "140_1310110678.31883" 
    capture_lex $P1537
    .const 'Sub' $P1536 = "139_1310110678.31883" 
    capture_lex $P1536
    .const 'Sub' $P1533 = "138_1310110678.31883" 
    capture_lex $P1533
    .const 'Sub' $P1532 = "137_1310110678.31883" 
    capture_lex $P1532
    .const 'Sub' $P1529 = "136_1310110678.31883" 
    capture_lex $P1529
    .const 'Sub' $P1528 = "135_1310110678.31883" 
    capture_lex $P1528
    .const 'Sub' $P1525 = "134_1310110678.31883" 
    capture_lex $P1525
    .const 'Sub' $P1524 = "133_1310110678.31883" 
    capture_lex $P1524
    .const 'Sub' $P1520 = "132_1310110678.31883" 
    capture_lex $P1520
    .const 'Sub' $P1519 = "131_1310110678.31883" 
    capture_lex $P1519
    .const 'Sub' $P1515 = "130_1310110678.31883" 
    capture_lex $P1515
    .const 'Sub' $P1514 = "129_1310110678.31883" 
    capture_lex $P1514
    .const 'Sub' $P1510 = "128_1310110678.31883" 
    capture_lex $P1510
    .const 'Sub' $P1505 = "125_1310110678.31883" 
    capture_lex $P1505
    .const 'Sub' $P1501 = "124_1310110678.31883" 
    capture_lex $P1501
    .const 'Sub' $P1500 = "123_1310110678.31883" 
    capture_lex $P1500
    .const 'Sub' $P1496 = "122_1310110678.31883" 
    capture_lex $P1496
    .const 'Sub' $P1491 = "119_1310110678.31883" 
    capture_lex $P1491
    .const 'Sub' $P1487 = "118_1310110678.31883" 
    capture_lex $P1487
    .const 'Sub' $P1486 = "117_1310110678.31883" 
    capture_lex $P1486
    .const 'Sub' $P1482 = "116_1310110678.31883" 
    capture_lex $P1482
    .const 'Sub' $P1481 = "115_1310110678.31883" 
    capture_lex $P1481
    .const 'Sub' $P1477 = "114_1310110678.31883" 
    capture_lex $P1477
    .const 'Sub' $P1472 = "111_1310110678.31883" 
    capture_lex $P1472
    .const 'Sub' $P1468 = "110_1310110678.31883" 
    capture_lex $P1468
    .const 'Sub' $P1467 = "109_1310110678.31883" 
    capture_lex $P1467
    .const 'Sub' $P1463 = "108_1310110678.31883" 
    capture_lex $P1463
    .const 'Sub' $P1462 = "107_1310110678.31883" 
    capture_lex $P1462
    .const 'Sub' $P1458 = "106_1310110678.31883" 
    capture_lex $P1458
    .const 'Sub' $P1457 = "105_1310110678.31883" 
    capture_lex $P1457
    .const 'Sub' $P1448 = "104_1310110678.31883" 
    capture_lex $P1448
    .const 'Sub' $P1447 = "103_1310110678.31883" 
    capture_lex $P1447
    .const 'Sub' $P1442 = "102_1310110678.31883" 
    capture_lex $P1442
    .const 'Sub' $P1441 = "101_1310110678.31883" 
    capture_lex $P1441
    .const 'Sub' $P1432 = "99_1310110678.31883" 
    capture_lex $P1432
    .const 'Sub' $P1431 = "98_1310110678.31883" 
    capture_lex $P1431
    .const 'Sub' $P1425 = "97_1310110678.31883" 
    capture_lex $P1425
    .const 'Sub' $P1424 = "96_1310110678.31883" 
    capture_lex $P1424
    .const 'Sub' $P1420 = "95_1310110678.31883" 
    capture_lex $P1420
    .const 'Sub' $P1415 = "92_1310110678.31883" 
    capture_lex $P1415
    .const 'Sub' $P1412 = "91_1310110678.31883" 
    capture_lex $P1412
    .const 'Sub' $P1411 = "90_1310110678.31883" 
    capture_lex $P1411
    .const 'Sub' $P1408 = "89_1310110678.31883" 
    capture_lex $P1408
    .const 'Sub' $P1403 = "86_1310110678.31883" 
    capture_lex $P1403
    .const 'Sub' $P1400 = "85_1310110678.31883" 
    capture_lex $P1400
    .const 'Sub' $P1399 = "84_1310110678.31883" 
    capture_lex $P1399
    .const 'Sub' $P1396 = "83_1310110678.31883" 
    capture_lex $P1396
    .const 'Sub' $P1395 = "82_1310110678.31883" 
    capture_lex $P1395
    .const 'Sub' $P1392 = "81_1310110678.31883" 
    capture_lex $P1392
    .const 'Sub' $P1391 = "80_1310110678.31883" 
    capture_lex $P1391
    .const 'Sub' $P1388 = "79_1310110678.31883" 
    capture_lex $P1388
    .const 'Sub' $P1387 = "78_1310110678.31883" 
    capture_lex $P1387
    .const 'Sub' $P1384 = "77_1310110678.31883" 
    capture_lex $P1384
    .const 'Sub' $P1383 = "76_1310110678.31883" 
    capture_lex $P1383
    .const 'Sub' $P1377 = "75_1310110678.31883" 
    capture_lex $P1377
    .const 'Sub' $P1376 = "74_1310110678.31883" 
    capture_lex $P1376
    .const 'Sub' $P1372 = "73_1310110678.31883" 
    capture_lex $P1372
    .const 'Sub' $P1371 = "72_1310110678.31883" 
    capture_lex $P1371
    .const 'Sub' $P1367 = "71_1310110678.31883" 
    capture_lex $P1367
    .const 'Sub' $P1366 = "70_1310110678.31883" 
    capture_lex $P1366
    .const 'Sub' $P1362 = "69_1310110678.31883" 
    capture_lex $P1362
    .const 'Sub' $P1361 = "68_1310110678.31883" 
    capture_lex $P1361
    .const 'Sub' $P1358 = "67_1310110678.31883" 
    capture_lex $P1358
    .const 'Sub' $P1357 = "66_1310110678.31883" 
    capture_lex $P1357
    .const 'Sub' $P1353 = "65_1310110678.31883" 
    capture_lex $P1353
    .const 'Sub' $P1352 = "64_1310110678.31883" 
    capture_lex $P1352
    .const 'Sub' $P1339 = "62_1310110678.31883" 
    capture_lex $P1339
    .const 'Sub' $P1338 = "61_1310110678.31883" 
    capture_lex $P1338
    .const 'Sub' $P1333 = "60_1310110678.31883" 
    capture_lex $P1333
    .const 'Sub' $P1332 = "59_1310110678.31883" 
    capture_lex $P1332
    .const 'Sub' $P1323 = "58_1310110678.31883" 
    capture_lex $P1323
    .const 'Sub' $P1322 = "57_1310110678.31883" 
    capture_lex $P1322
    .const 'Sub' $P1286 = "55_1310110678.31883" 
    capture_lex $P1286
    .const 'Sub' $P1285 = "54_1310110678.31883" 
    capture_lex $P1285
    .const 'Sub' $P1272 = "52_1310110678.31883" 
    capture_lex $P1272
    .const 'Sub' $P1271 = "51_1310110678.31883" 
    capture_lex $P1271
    .const 'Sub' $P1262 = "50_1310110678.31883" 
    capture_lex $P1262
    .const 'Sub' $P1261 = "49_1310110678.31883" 
    capture_lex $P1261
    .const 'Sub' $P1251 = "48_1310110678.31883" 
    capture_lex $P1251
    .const 'Sub' $P1250 = "47_1310110678.31883" 
    capture_lex $P1250
    .const 'Sub' $P1245 = "46_1310110678.31883" 
    capture_lex $P1245
    .const 'Sub' $P1244 = "45_1310110678.31883" 
    capture_lex $P1244
    .const 'Sub' $P1239 = "44_1310110678.31883" 
    capture_lex $P1239
    .const 'Sub' $P1238 = "43_1310110678.31883" 
    capture_lex $P1238
    .const 'Sub' $P1234 = "42_1310110678.31883" 
    capture_lex $P1234
    .const 'Sub' $P1222 = "41_1310110678.31883" 
    capture_lex $P1222
    .lex "$?PACKAGE", $P1220
    .lex "$?CLASS", $P1221
.annotate 'line', 1047
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<y=>, :assoc<unary>", "%methodop")
.annotate 'line', 1048
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<x=>, :assoc<unary>", "%autoincrement")
.annotate 'line', 1049
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<w=>, :assoc<left>", "%exponentiation")
.annotate 'line', 1050
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<v=>, :assoc<unary>", "%symbolic_unary")
.annotate 'line', 1051
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<u=>, :assoc<left>", "%multiplicative")
.annotate 'line', 1052
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<t=>, :assoc<left>", "%additive")
.annotate 'line', 1053
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<r=>, :assoc<left>", "%concatenation")
.annotate 'line', 1054
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<m=>, :assoc<left>", "%relational")
.annotate 'line', 1055
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<l=>, :assoc<left>", "%tight_and")
.annotate 'line', 1056
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<k=>, :assoc<left>", "%tight_or")
.annotate 'line', 1057
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<j=>, :assoc<right>", "%conditional")
.annotate 'line', 1058
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<i=>, :assoc<right>", "%assignment")
.annotate 'line', 1059
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<g=>, :assoc<list>, :nextterm<nulltermish>", "%comma")
.annotate 'line', 1060
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<f=>, :assoc<list>", "%list_infix")
.annotate 'line', 1061
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<e=>, :assoc<unary>", "%list_prefix")
.annotate 'line', 1160
    .const 'Sub' $P2312 = "418_1310110678.31883" 
    newclosure $P2320, $P2312
.annotate 'line', 435
    .return ($P2320)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "TOP" :anon :subid("41_1310110678.31883") :outer("40_1310110678.31883")
    .param pmc param_1223
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 436
    .lex "self", param_1223
.annotate 'line', 438
    $P1225 = root_new ['parrot';'Hash']
    set $P1224, $P1225
    .lex "%*LANG", $P1224
.annotate 'line', 447
    $P1227 = root_new ['parrot';'Hash']
    set $P1226, $P1227
    .lex "%*HOW", $P1226
.annotate 'line', 454
    new $P103, "Undef"
    set $P1228, $P103
    .lex "$*SC", $P1228
.annotate 'line', 458
    new $P104, "Undef"
    set $P1229, $P104
    .lex "$*SCOPE", $P1229
.annotate 'line', 459
    new $P105, "Undef"
    set $P1230, $P105
    .lex "$*MULTINESS", $P1230
.annotate 'line', 460
    new $P106, "Undef"
    set $P1231, $P106
    .lex "$*PKGDECL", $P1231
.annotate 'line', 461
    new $P107, "Undef"
    set $P1232, $P107
    .lex "$*INVOCANT_OK", $P1232
.annotate 'line', 462
    new $P108, "Undef"
    set $P1233, $P108
    .lex "$*RETURN_USED", $P1233
.annotate 'line', 436
    find_lex $P111, "%*LANG"
    unless_null $P111, vivify_857
    get_hll_global $P109, "GLOBAL"
    get_who $P110, $P109
    set $P111, $P110["%LANG"]
    unless_null $P111, vivify_858
    die "Contextual %*LANG not found"
  vivify_858:
  vivify_857:
.annotate 'line', 439
    get_hll_global $P109, "GLOBAL"
    nqp_get_package_through_who $P110, $P109, "NQP"
    get_who $P111, $P110
    set $P112, $P111["Regex"]
    find_lex $P115, "%*LANG"
    unless_null $P115, vivify_859
    get_hll_global $P113, "GLOBAL"
    get_who $P114, $P113
    set $P115, $P114["%LANG"]
    unless_null $P115, vivify_860
    die "Contextual %*LANG not found"
  vivify_860:
    store_lex "%*LANG", $P115
  vivify_859:
    set $P115["Regex"], $P112
.annotate 'line', 440
    get_hll_global $P109, "GLOBAL"
    nqp_get_package_through_who $P110, $P109, "NQP"
    get_who $P111, $P110
    set $P112, $P111["RegexActions"]
    find_lex $P115, "%*LANG"
    unless_null $P115, vivify_861
    get_hll_global $P113, "GLOBAL"
    get_who $P114, $P113
    set $P115, $P114["%LANG"]
    unless_null $P115, vivify_862
    die "Contextual %*LANG not found"
  vivify_862:
    store_lex "%*LANG", $P115
  vivify_861:
    set $P115["Regex-actions"], $P112
.annotate 'line', 441
    get_hll_global $P109, "GLOBAL"
    nqp_get_package_through_who $P110, $P109, "NQP"
    get_who $P111, $P110
    set $P112, $P111["Grammar"]
    find_lex $P115, "%*LANG"
    unless_null $P115, vivify_863
    get_hll_global $P113, "GLOBAL"
    get_who $P114, $P113
    set $P115, $P114["%LANG"]
    unless_null $P115, vivify_864
    die "Contextual %*LANG not found"
  vivify_864:
    store_lex "%*LANG", $P115
  vivify_863:
    set $P115["MAIN"], $P112
.annotate 'line', 442
    get_hll_global $P109, "GLOBAL"
    nqp_get_package_through_who $P110, $P109, "NQP"
    get_who $P111, $P110
    set $P112, $P111["Actions"]
    find_lex $P115, "%*LANG"
    unless_null $P115, vivify_865
    get_hll_global $P113, "GLOBAL"
    get_who $P114, $P113
    set $P115, $P114["%LANG"]
    unless_null $P115, vivify_866
    die "Contextual %*LANG not found"
  vivify_866:
    store_lex "%*LANG", $P115
  vivify_865:
    set $P115["MAIN-actions"], $P112
.annotate 'line', 436
    find_lex $P111, "%*HOW"
    unless_null $P111, vivify_867
    get_hll_global $P109, "GLOBAL"
    get_who $P110, $P109
    set $P111, $P110["%HOW"]
    unless_null $P111, vivify_868
    die "Contextual %*HOW not found"
  vivify_868:
  vivify_867:
.annotate 'line', 448
    get_knowhow $P109
    find_lex $P112, "%*HOW"
    unless_null $P112, vivify_869
    get_hll_global $P110, "GLOBAL"
    get_who $P111, $P110
    set $P112, $P111["%HOW"]
    unless_null $P112, vivify_870
    die "Contextual %*HOW not found"
  vivify_870:
    store_lex "%*HOW", $P112
  vivify_869:
    set $P112["knowhow"], $P109
.annotate 'line', 449
    get_knowhow_attribute $P109
    find_lex $P112, "%*HOW"
    unless_null $P112, vivify_871
    get_hll_global $P110, "GLOBAL"
    get_who $P111, $P110
    set $P112, $P111["%HOW"]
    unless_null $P112, vivify_872
    die "Contextual %*HOW not found"
  vivify_872:
    store_lex "%*HOW", $P112
  vivify_871:
    set $P112["knowhow-attr"], $P109
.annotate 'line', 454
    get_hll_global $P109, "GLOBAL"
    nqp_get_package_through_who $P110, $P109, "NQP"
    get_who $P111, $P110
    set $P112, $P111["SymbolTable"]
.annotate 'line', 456
    time $N100
    set $S100, $N100
.annotate 'line', 454
    $P113 = $P112."new"($S100 :named("handle"))
    store_lex "$*SC", $P113
.annotate 'line', 458
    new $P109, "String"
    assign $P109, ""
    store_lex "$*SCOPE", $P109
.annotate 'line', 459
    new $P109, "String"
    assign $P109, ""
    store_lex "$*MULTINESS", $P109
.annotate 'line', 460
    new $P109, "String"
    assign $P109, ""
    store_lex "$*PKGDECL", $P109
.annotate 'line', 461
    new $P109, "Integer"
    assign $P109, 0
    store_lex "$*INVOCANT_OK", $P109
.annotate 'line', 462
    new $P109, "Integer"
    assign $P109, 0
    store_lex "$*RETURN_USED", $P109
.annotate 'line', 463
    find_lex $P109, "self"
    $P110 = $P109."comp_unit"()
.annotate 'line', 436
    .return ($P110)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "identifier"  :subid("42_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1235_tgt
    .local int rx1235_pos
    .local int rx1235_off
    .local int rx1235_eos
    .local int rx1235_rep
    .local pmc rx1235_cur
    .local pmc rx1235_debug
    (rx1235_cur, rx1235_pos, rx1235_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1235_cur
    .local pmc match
    .lex "$/", match
    length rx1235_eos, rx1235_tgt
    gt rx1235_pos, rx1235_eos, rx1235_done
    set rx1235_off, 0
    lt rx1235_pos, 2, rx1235_start
    sub rx1235_off, rx1235_pos, 1
    substr rx1235_tgt, rx1235_tgt, rx1235_off
  rx1235_start:
    eq $I10, 1, rx1235_restart
    if_null rx1235_debug, debug_873
    rx1235_cur."!cursor_debug"("START", "identifier")
  debug_873:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1236_done
    goto rxscan1236_scan
  rxscan1236_loop:
    (rx1235_pos) = rx1235_cur."from"()
    inc rx1235_pos
    rx1235_cur."!cursor_from"(rx1235_pos)
    ge rx1235_pos, rx1235_eos, rxscan1236_done
  rxscan1236_scan:
    set_addr $I10, rxscan1236_loop
    rx1235_cur."!mark_push"(0, rx1235_pos, $I10)
  rxscan1236_done:
.annotate 'line', 468
  # rx subrule "ident" subtype=method negate=
    rx1235_cur."!cursor_pos"(rx1235_pos)
    $P10 = rx1235_cur."ident"()
    unless $P10, rx1235_fail
    rx1235_pos = $P10."pos"()
  # rx rxquantr1237 ** 0..*
    set_addr $I10, rxquantr1237_done
    rx1235_cur."!mark_push"(0, rx1235_pos, $I10)
  rxquantr1237_loop:
  # rx enumcharlist negate=0 
    ge rx1235_pos, rx1235_eos, rx1235_fail
    sub $I10, rx1235_pos, rx1235_off
    substr $S10, rx1235_tgt, $I10, 1
    index $I11, "-'", $S10
    lt $I11, 0, rx1235_fail
    inc rx1235_pos
  # rx subrule "ident" subtype=method negate=
    rx1235_cur."!cursor_pos"(rx1235_pos)
    $P10 = rx1235_cur."ident"()
    unless $P10, rx1235_fail
    rx1235_pos = $P10."pos"()
    set_addr $I10, rxquantr1237_done
    (rx1235_rep) = rx1235_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1237_done
    rx1235_cur."!mark_push"(rx1235_rep, rx1235_pos, $I10)
    goto rxquantr1237_loop
  rxquantr1237_done:
  # rx pass
    rx1235_cur."!cursor_pass"(rx1235_pos, "identifier")
    if_null rx1235_debug, debug_874
    rx1235_cur."!cursor_debug"("PASS", "identifier", " at pos=", rx1235_pos)
  debug_874:
    .return (rx1235_cur)
  rx1235_restart:
.annotate 'line', 435
    if_null rx1235_debug, debug_875
    rx1235_cur."!cursor_debug"("NEXT", "identifier")
  debug_875:
  rx1235_fail:
    (rx1235_rep, rx1235_pos, $I10, $P10) = rx1235_cur."!mark_fail"(0)
    lt rx1235_pos, -1, rx1235_done
    eq rx1235_pos, -1, rx1235_fail
    jump $I10
  rx1235_done:
    rx1235_cur."!cursor_fail"()
    if_null rx1235_debug, debug_876
    rx1235_cur."!cursor_debug"("FAIL", "identifier")
  debug_876:
    .return (rx1235_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__identifier"  :subid("43_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("ident", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "name"  :subid("44_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1240_tgt
    .local int rx1240_pos
    .local int rx1240_off
    .local int rx1240_eos
    .local int rx1240_rep
    .local pmc rx1240_cur
    .local pmc rx1240_debug
    (rx1240_cur, rx1240_pos, rx1240_tgt, $I10) = self."!cursor_start"()
    rx1240_cur."!cursor_caparray"("identifier")
    .lex unicode:"$\x{a2}", rx1240_cur
    .local pmc match
    .lex "$/", match
    length rx1240_eos, rx1240_tgt
    gt rx1240_pos, rx1240_eos, rx1240_done
    set rx1240_off, 0
    lt rx1240_pos, 2, rx1240_start
    sub rx1240_off, rx1240_pos, 1
    substr rx1240_tgt, rx1240_tgt, rx1240_off
  rx1240_start:
    eq $I10, 1, rx1240_restart
    if_null rx1240_debug, debug_877
    rx1240_cur."!cursor_debug"("START", "name")
  debug_877:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1241_done
    goto rxscan1241_scan
  rxscan1241_loop:
    (rx1240_pos) = rx1240_cur."from"()
    inc rx1240_pos
    rx1240_cur."!cursor_from"(rx1240_pos)
    ge rx1240_pos, rx1240_eos, rxscan1241_done
  rxscan1241_scan:
    set_addr $I10, rxscan1241_loop
    rx1240_cur."!mark_push"(0, rx1240_pos, $I10)
  rxscan1241_done:
.annotate 'line', 470
  # rx rxquantr1242 ** 1..*
    set_addr $I10, rxquantr1242_done
    rx1240_cur."!mark_push"(0, -1, $I10)
  rxquantr1242_loop:
  # rx subrule "identifier" subtype=capture negate=
    rx1240_cur."!cursor_pos"(rx1240_pos)
    $P10 = rx1240_cur."identifier"()
    unless $P10, rx1240_fail
    goto rxsubrule1243_pass
  rxsubrule1243_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1240_fail
  rxsubrule1243_pass:
    set_addr $I10, rxsubrule1243_back
    rx1240_cur."!mark_push"(0, rx1240_pos, $I10, $P10)
    $P10."!cursor_names"("identifier")
    rx1240_pos = $P10."pos"()
    set_addr $I10, rxquantr1242_done
    (rx1240_rep) = rx1240_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1242_done
    rx1240_cur."!mark_push"(rx1240_rep, rx1240_pos, $I10)
  # rx literal  "::"
    add $I11, rx1240_pos, 2
    gt $I11, rx1240_eos, rx1240_fail
    sub $I11, rx1240_pos, rx1240_off
    substr $S10, rx1240_tgt, $I11, 2
    ne $S10, "::", rx1240_fail
    add rx1240_pos, 2
    goto rxquantr1242_loop
  rxquantr1242_done:
  # rx pass
    rx1240_cur."!cursor_pass"(rx1240_pos, "name")
    if_null rx1240_debug, debug_878
    rx1240_cur."!cursor_debug"("PASS", "name", " at pos=", rx1240_pos)
  debug_878:
    .return (rx1240_cur)
  rx1240_restart:
.annotate 'line', 435
    if_null rx1240_debug, debug_879
    rx1240_cur."!cursor_debug"("NEXT", "name")
  debug_879:
  rx1240_fail:
    (rx1240_rep, rx1240_pos, $I10, $P10) = rx1240_cur."!mark_fail"(0)
    lt rx1240_pos, -1, rx1240_done
    eq rx1240_pos, -1, rx1240_fail
    jump $I10
  rx1240_done:
    rx1240_cur."!cursor_fail"()
    if_null rx1240_debug, debug_880
    rx1240_cur."!cursor_debug"("FAIL", "name")
  debug_880:
    .return (rx1240_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__name"  :subid("45_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "deflongname"  :subid("46_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1246_tgt
    .local int rx1246_pos
    .local int rx1246_off
    .local int rx1246_eos
    .local int rx1246_rep
    .local pmc rx1246_cur
    .local pmc rx1246_debug
    (rx1246_cur, rx1246_pos, rx1246_tgt, $I10) = self."!cursor_start"()
    rx1246_cur."!cursor_caparray"("colonpair")
    .lex unicode:"$\x{a2}", rx1246_cur
    .local pmc match
    .lex "$/", match
    length rx1246_eos, rx1246_tgt
    gt rx1246_pos, rx1246_eos, rx1246_done
    set rx1246_off, 0
    lt rx1246_pos, 2, rx1246_start
    sub rx1246_off, rx1246_pos, 1
    substr rx1246_tgt, rx1246_tgt, rx1246_off
  rx1246_start:
    eq $I10, 1, rx1246_restart
    if_null rx1246_debug, debug_881
    rx1246_cur."!cursor_debug"("START", "deflongname")
  debug_881:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1247_done
    goto rxscan1247_scan
  rxscan1247_loop:
    (rx1246_pos) = rx1246_cur."from"()
    inc rx1246_pos
    rx1246_cur."!cursor_from"(rx1246_pos)
    ge rx1246_pos, rx1246_eos, rxscan1247_done
  rxscan1247_scan:
    set_addr $I10, rxscan1247_loop
    rx1246_cur."!mark_push"(0, rx1246_pos, $I10)
  rxscan1247_done:
.annotate 'line', 473
  # rx subrule "identifier" subtype=capture negate=
    rx1246_cur."!cursor_pos"(rx1246_pos)
    $P10 = rx1246_cur."identifier"()
    unless $P10, rx1246_fail
    rx1246_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx1246_pos = $P10."pos"()
  # rx rxquantr1248 ** 0..1
    set_addr $I10, rxquantr1248_done
    rx1246_cur."!mark_push"(0, rx1246_pos, $I10)
  rxquantr1248_loop:
  # rx subrule "colonpair" subtype=capture negate=
    rx1246_cur."!cursor_pos"(rx1246_pos)
    $P10 = rx1246_cur."colonpair"()
    unless $P10, rx1246_fail
    goto rxsubrule1249_pass
  rxsubrule1249_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1246_fail
  rxsubrule1249_pass:
    set_addr $I10, rxsubrule1249_back
    rx1246_cur."!mark_push"(0, rx1246_pos, $I10, $P10)
    $P10."!cursor_names"("colonpair")
    rx1246_pos = $P10."pos"()
    set_addr $I10, rxquantr1248_done
    (rx1246_rep) = rx1246_cur."!mark_commit"($I10)
  rxquantr1248_done:
.annotate 'line', 472
  # rx pass
    rx1246_cur."!cursor_pass"(rx1246_pos, "deflongname")
    if_null rx1246_debug, debug_882
    rx1246_cur."!cursor_debug"("PASS", "deflongname", " at pos=", rx1246_pos)
  debug_882:
    .return (rx1246_cur)
  rx1246_restart:
.annotate 'line', 435
    if_null rx1246_debug, debug_883
    rx1246_cur."!cursor_debug"("NEXT", "deflongname")
  debug_883:
  rx1246_fail:
    (rx1246_rep, rx1246_pos, $I10, $P10) = rx1246_cur."!mark_fail"(0)
    lt rx1246_pos, -1, rx1246_done
    eq rx1246_pos, -1, rx1246_fail
    jump $I10
  rx1246_done:
    rx1246_cur."!cursor_fail"()
    if_null rx1246_debug, debug_884
    rx1246_cur."!cursor_debug"("FAIL", "deflongname")
  debug_884:
    .return (rx1246_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__deflongname"  :subid("47_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("identifier", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ENDSTMT"  :subid("48_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1252_tgt
    .local int rx1252_pos
    .local int rx1252_off
    .local int rx1252_eos
    .local int rx1252_rep
    .local pmc rx1252_cur
    .local pmc rx1252_debug
    (rx1252_cur, rx1252_pos, rx1252_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1252_cur
    .local pmc match
    .lex "$/", match
    length rx1252_eos, rx1252_tgt
    gt rx1252_pos, rx1252_eos, rx1252_done
    set rx1252_off, 0
    lt rx1252_pos, 2, rx1252_start
    sub rx1252_off, rx1252_pos, 1
    substr rx1252_tgt, rx1252_tgt, rx1252_off
  rx1252_start:
    eq $I10, 1, rx1252_restart
    if_null rx1252_debug, debug_885
    rx1252_cur."!cursor_debug"("START", "ENDSTMT")
  debug_885:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1253_done
    goto rxscan1253_scan
  rxscan1253_loop:
    (rx1252_pos) = rx1252_cur."from"()
    inc rx1252_pos
    rx1252_cur."!cursor_from"(rx1252_pos)
    ge rx1252_pos, rx1252_eos, rxscan1253_done
  rxscan1253_scan:
    set_addr $I10, rxscan1253_loop
    rx1252_cur."!mark_push"(0, rx1252_pos, $I10)
  rxscan1253_done:
.annotate 'line', 480
  # rx rxquantr1254 ** 0..1
    set_addr $I10, rxquantr1254_done
    rx1252_cur."!mark_push"(0, rx1252_pos, $I10)
  rxquantr1254_loop:
  alt1255_0:
.annotate 'line', 477
    set_addr $I10, alt1255_1
    rx1252_cur."!mark_push"(0, rx1252_pos, $I10)
.annotate 'line', 478
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1252_pos, rx1252_off
    set rx1252_rep, 0
    sub $I12, rx1252_eos, rx1252_pos
  rxenumcharlistq1256_loop:
    le $I12, 0, rxenumcharlistq1256_done
    substr $S10, rx1252_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1256_done
    inc rx1252_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1256_loop
  rxenumcharlistq1256_done:
    add rx1252_pos, rx1252_pos, rx1252_rep
  # rxanchor eol
    sub $I10, rx1252_pos, rx1252_off
    is_cclass $I11, .CCLASS_NEWLINE, rx1252_tgt, $I10
    if $I11, rxanchor1257_done
    ne rx1252_pos, rx1252_eos, rx1252_fail
    eq rx1252_pos, 0, rxanchor1257_done
    dec $I10
    is_cclass $I11, .CCLASS_NEWLINE, rx1252_tgt, $I10
    if $I11, rx1252_fail
  rxanchor1257_done:
  # rx subrule "ws" subtype=method negate=
    rx1252_cur."!cursor_pos"(rx1252_pos)
    $P10 = rx1252_cur."ws"()
    unless $P10, rx1252_fail
    rx1252_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx1252_cur."!cursor_pos"(rx1252_pos)
    $P10 = rx1252_cur."MARKER"("endstmt")
    unless $P10, rx1252_fail
    goto alt1255_end
  alt1255_1:
.annotate 'line', 479
  # rx rxquantr1258 ** 0..1
    set_addr $I10, rxquantr1258_done
    rx1252_cur."!mark_push"(0, rx1252_pos, $I10)
  rxquantr1258_loop:
  # rx subrule "unv" subtype=method negate=
    rx1252_cur."!cursor_pos"(rx1252_pos)
    $P10 = rx1252_cur."unv"()
    unless $P10, rx1252_fail
    goto rxsubrule1259_pass
  rxsubrule1259_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1252_fail
  rxsubrule1259_pass:
    set_addr $I10, rxsubrule1259_back
    rx1252_cur."!mark_push"(0, rx1252_pos, $I10, $P10)
    rx1252_pos = $P10."pos"()
    set_addr $I10, rxquantr1258_done
    (rx1252_rep) = rx1252_cur."!mark_commit"($I10)
  rxquantr1258_done:
  # rxanchor eol
    sub $I10, rx1252_pos, rx1252_off
    is_cclass $I11, .CCLASS_NEWLINE, rx1252_tgt, $I10
    if $I11, rxanchor1260_done
    ne rx1252_pos, rx1252_eos, rx1252_fail
    eq rx1252_pos, 0, rxanchor1260_done
    dec $I10
    is_cclass $I11, .CCLASS_NEWLINE, rx1252_tgt, $I10
    if $I11, rx1252_fail
  rxanchor1260_done:
  # rx subrule "ws" subtype=method negate=
    rx1252_cur."!cursor_pos"(rx1252_pos)
    $P10 = rx1252_cur."ws"()
    unless $P10, rx1252_fail
    rx1252_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx1252_cur."!cursor_pos"(rx1252_pos)
    $P10 = rx1252_cur."MARKER"("endstmt")
    unless $P10, rx1252_fail
  alt1255_end:
.annotate 'line', 480
    set_addr $I10, rxquantr1254_done
    (rx1252_rep) = rx1252_cur."!mark_commit"($I10)
  rxquantr1254_done:
.annotate 'line', 476
  # rx pass
    rx1252_cur."!cursor_pass"(rx1252_pos, "ENDSTMT")
    if_null rx1252_debug, debug_886
    rx1252_cur."!cursor_debug"("PASS", "ENDSTMT", " at pos=", rx1252_pos)
  debug_886:
    .return (rx1252_cur)
  rx1252_restart:
.annotate 'line', 435
    if_null rx1252_debug, debug_887
    rx1252_cur."!cursor_debug"("NEXT", "ENDSTMT")
  debug_887:
  rx1252_fail:
    (rx1252_rep, rx1252_pos, $I10, $P10) = rx1252_cur."!mark_fail"(0)
    lt rx1252_pos, -1, rx1252_done
    eq rx1252_pos, -1, rx1252_fail
    jump $I10
  rx1252_done:
    rx1252_cur."!cursor_fail"()
    if_null rx1252_debug, debug_888
    rx1252_cur."!cursor_debug"("FAIL", "ENDSTMT")
  debug_888:
    .return (rx1252_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ENDSTMT"  :subid("49_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ws"  :subid("50_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1263_tgt
    .local int rx1263_pos
    .local int rx1263_off
    .local int rx1263_eos
    .local int rx1263_rep
    .local pmc rx1263_cur
    .local pmc rx1263_debug
    (rx1263_cur, rx1263_pos, rx1263_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1263_cur
    .local pmc match
    .lex "$/", match
    length rx1263_eos, rx1263_tgt
    gt rx1263_pos, rx1263_eos, rx1263_done
    set rx1263_off, 0
    lt rx1263_pos, 2, rx1263_start
    sub rx1263_off, rx1263_pos, 1
    substr rx1263_tgt, rx1263_tgt, rx1263_off
  rx1263_start:
    eq $I10, 1, rx1263_restart
    if_null rx1263_debug, debug_889
    rx1263_cur."!cursor_debug"("START", "ws")
  debug_889:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1264_done
    goto rxscan1264_scan
  rxscan1264_loop:
    (rx1263_pos) = rx1263_cur."from"()
    inc rx1263_pos
    rx1263_cur."!cursor_from"(rx1263_pos)
    ge rx1263_pos, rx1263_eos, rxscan1264_done
  rxscan1264_scan:
    set_addr $I10, rxscan1264_loop
    rx1263_cur."!mark_push"(0, rx1263_pos, $I10)
  rxscan1264_done:
  alt1265_0:
.annotate 'line', 483
    set_addr $I10, alt1265_1
    rx1263_cur."!mark_push"(0, rx1263_pos, $I10)
.annotate 'line', 484
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx1263_cur."!cursor_pos"(rx1263_pos)
    $P10 = rx1263_cur."MARKED"("ws")
    unless $P10, rx1263_fail
    goto alt1265_end
  alt1265_1:
.annotate 'line', 485
  # rx subrule "ww" subtype=zerowidth negate=1
    rx1263_cur."!cursor_pos"(rx1263_pos)
    $P10 = rx1263_cur."ww"()
    if $P10, rx1263_fail
.annotate 'line', 490
  # rx rxquantr1266 ** 0..*
    set_addr $I10, rxquantr1266_done
    rx1263_cur."!mark_push"(0, rx1263_pos, $I10)
  rxquantr1266_loop:
  alt1267_0:
.annotate 'line', 486
    set_addr $I10, alt1267_1
    rx1263_cur."!mark_push"(0, rx1263_pos, $I10)
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx1263_pos, rx1263_off
    set rx1263_rep, 0
    sub $I12, rx1263_eos, rx1263_pos
  rxenumcharlistq1268_loop:
    le $I12, 0, rxenumcharlistq1268_done
    substr $S10, rx1263_tgt, $I10, 1
    index $I11, unicode:"\n\x{b}\f\r\x{85}\u2028\u2029", $S10
    lt $I11, 0, rxenumcharlistq1268_done
    inc rx1263_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1268_loop
  rxenumcharlistq1268_done:
    lt rx1263_rep, 1, rx1263_fail
    add rx1263_pos, rx1263_pos, rx1263_rep
    goto alt1267_end
  alt1267_1:
    set_addr $I10, alt1267_2
    rx1263_cur."!mark_push"(0, rx1263_pos, $I10)
.annotate 'line', 487
  # rx literal  "#"
    add $I11, rx1263_pos, 1
    gt $I11, rx1263_eos, rx1263_fail
    sub $I11, rx1263_pos, rx1263_off
    ord $I11, rx1263_tgt, $I11
    ne $I11, 35, rx1263_fail
    add rx1263_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx1263_pos, rx1263_off
    find_cclass $I11, .CCLASS_NEWLINE, rx1263_tgt, $I10, rx1263_eos
    add rx1263_pos, rx1263_off, $I11
    goto alt1267_end
  alt1267_2:
    set_addr $I10, alt1267_3
    rx1263_cur."!mark_push"(0, rx1263_pos, $I10)
.annotate 'line', 488
  # rxanchor bol
    eq rx1263_pos, 0, rxanchor1269_done
    ge rx1263_pos, rx1263_eos, rx1263_fail
    sub $I10, rx1263_pos, rx1263_off
    dec $I10
    is_cclass $I11, .CCLASS_NEWLINE, rx1263_tgt, $I10
    unless $I11, rx1263_fail
  rxanchor1269_done:
  # rx subrule "pod_comment" subtype=method negate=
    rx1263_cur."!cursor_pos"(rx1263_pos)
    $P10 = rx1263_cur."pod_comment"()
    unless $P10, rx1263_fail
    rx1263_pos = $P10."pos"()
    goto alt1267_end
  alt1267_3:
.annotate 'line', 489
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx1263_pos, rx1263_off
    set rx1263_rep, 0
    sub $I12, rx1263_eos, rx1263_pos
  rxenumcharlistq1270_loop:
    le $I12, 0, rxenumcharlistq1270_done
    substr $S10, rx1263_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1270_done
    inc rx1263_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1270_loop
  rxenumcharlistq1270_done:
    lt rx1263_rep, 1, rx1263_fail
    add rx1263_pos, rx1263_pos, rx1263_rep
  alt1267_end:
.annotate 'line', 490
    set_addr $I10, rxquantr1266_done
    (rx1263_rep) = rx1263_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1266_done
    rx1263_cur."!mark_push"(rx1263_rep, rx1263_pos, $I10)
    goto rxquantr1266_loop
  rxquantr1266_done:
.annotate 'line', 491
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx1263_cur."!cursor_pos"(rx1263_pos)
    $P10 = rx1263_cur."MARKER"("ws")
    unless $P10, rx1263_fail
  alt1265_end:
.annotate 'line', 483
  # rx pass
    rx1263_cur."!cursor_pass"(rx1263_pos, "ws")
    if_null rx1263_debug, debug_890
    rx1263_cur."!cursor_debug"("PASS", "ws", " at pos=", rx1263_pos)
  debug_890:
    .return (rx1263_cur)
  rx1263_restart:
.annotate 'line', 435
    if_null rx1263_debug, debug_891
    rx1263_cur."!cursor_debug"("NEXT", "ws")
  debug_891:
  rx1263_fail:
    (rx1263_rep, rx1263_pos, $I10, $P10) = rx1263_cur."!mark_fail"(0)
    lt rx1263_pos, -1, rx1263_done
    eq rx1263_pos, -1, rx1263_fail
    jump $I10
  rx1263_done:
    rx1263_cur."!cursor_fail"()
    if_null rx1263_debug, debug_892
    rx1263_cur."!cursor_debug"("FAIL", "ws")
  debug_892:
    .return (rx1263_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ws"  :subid("51_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    new $P103, "ResizablePMCArray"
    push $P103, ""
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "unv"  :subid("52_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .const 'Sub' $P1278 = "53_1310110678.31883" 
    capture_lex $P1278
    .local string rx1273_tgt
    .local int rx1273_pos
    .local int rx1273_off
    .local int rx1273_eos
    .local int rx1273_rep
    .local pmc rx1273_cur
    .local pmc rx1273_debug
    (rx1273_cur, rx1273_pos, rx1273_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1273_cur
    .local pmc match
    .lex "$/", match
    length rx1273_eos, rx1273_tgt
    gt rx1273_pos, rx1273_eos, rx1273_done
    set rx1273_off, 0
    lt rx1273_pos, 2, rx1273_start
    sub rx1273_off, rx1273_pos, 1
    substr rx1273_tgt, rx1273_tgt, rx1273_off
  rx1273_start:
    eq $I10, 1, rx1273_restart
    if_null rx1273_debug, debug_893
    rx1273_cur."!cursor_debug"("START", "unv")
  debug_893:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1274_done
    goto rxscan1274_scan
  rxscan1274_loop:
    (rx1273_pos) = rx1273_cur."from"()
    inc rx1273_pos
    rx1273_cur."!cursor_from"(rx1273_pos)
    ge rx1273_pos, rx1273_eos, rxscan1274_done
  rxscan1274_scan:
    set_addr $I10, rxscan1274_loop
    rx1273_cur."!mark_push"(0, rx1273_pos, $I10)
  rxscan1274_done:
  alt1275_0:
.annotate 'line', 496
    set_addr $I10, alt1275_1
    rx1273_cur."!mark_push"(0, rx1273_pos, $I10)
.annotate 'line', 497
  # rxanchor bol
    eq rx1273_pos, 0, rxanchor1276_done
    ge rx1273_pos, rx1273_eos, rx1273_fail
    sub $I10, rx1273_pos, rx1273_off
    dec $I10
    is_cclass $I11, .CCLASS_NEWLINE, rx1273_tgt, $I10
    unless $I11, rx1273_fail
  rxanchor1276_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx1273_cur."!cursor_pos"(rx1273_pos)
    .const 'Sub' $P1278 = "53_1310110678.31883" 
    capture_lex $P1278
    $P10 = rx1273_cur."before"($P1278)
    unless $P10, rx1273_fail
  # rx subrule "pod_comment" subtype=method negate=
    rx1273_cur."!cursor_pos"(rx1273_pos)
    $P10 = rx1273_cur."pod_comment"()
    unless $P10, rx1273_fail
    rx1273_pos = $P10."pos"()
    goto alt1275_end
  alt1275_1:
    set_addr $I10, alt1275_2
    rx1273_cur."!mark_push"(0, rx1273_pos, $I10)
.annotate 'line', 498
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1273_pos, rx1273_off
    set rx1273_rep, 0
    sub $I12, rx1273_eos, rx1273_pos
  rxenumcharlistq1283_loop:
    le $I12, 0, rxenumcharlistq1283_done
    substr $S10, rx1273_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1283_done
    inc rx1273_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1283_loop
  rxenumcharlistq1283_done:
    add rx1273_pos, rx1273_pos, rx1273_rep
  # rx literal  "#"
    add $I11, rx1273_pos, 1
    gt $I11, rx1273_eos, rx1273_fail
    sub $I11, rx1273_pos, rx1273_off
    ord $I11, rx1273_tgt, $I11
    ne $I11, 35, rx1273_fail
    add rx1273_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx1273_pos, rx1273_off
    find_cclass $I11, .CCLASS_NEWLINE, rx1273_tgt, $I10, rx1273_eos
    add rx1273_pos, rx1273_off, $I11
    goto alt1275_end
  alt1275_2:
.annotate 'line', 499
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx1273_pos, rx1273_off
    set rx1273_rep, 0
    sub $I12, rx1273_eos, rx1273_pos
  rxenumcharlistq1284_loop:
    le $I12, 0, rxenumcharlistq1284_done
    substr $S10, rx1273_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1284_done
    inc rx1273_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1284_loop
  rxenumcharlistq1284_done:
    lt rx1273_rep, 1, rx1273_fail
    add rx1273_pos, rx1273_pos, rx1273_rep
  alt1275_end:
.annotate 'line', 494
  # rx pass
    rx1273_cur."!cursor_pass"(rx1273_pos, "unv")
    if_null rx1273_debug, debug_898
    rx1273_cur."!cursor_debug"("PASS", "unv", " at pos=", rx1273_pos)
  debug_898:
    .return (rx1273_cur)
  rx1273_restart:
.annotate 'line', 435
    if_null rx1273_debug, debug_899
    rx1273_cur."!cursor_debug"("NEXT", "unv")
  debug_899:
  rx1273_fail:
    (rx1273_rep, rx1273_pos, $I10, $P10) = rx1273_cur."!mark_fail"(0)
    lt rx1273_pos, -1, rx1273_done
    eq rx1273_pos, -1, rx1273_fail
    jump $I10
  rx1273_done:
    rx1273_cur."!cursor_fail"()
    if_null rx1273_debug, debug_900
    rx1273_cur."!cursor_debug"("FAIL", "unv")
  debug_900:
    .return (rx1273_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1277"  :anon :subid("53_1310110678.31883") :method :outer("52_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 497
    .local string rx1279_tgt
    .local int rx1279_pos
    .local int rx1279_off
    .local int rx1279_eos
    .local int rx1279_rep
    .local pmc rx1279_cur
    .local pmc rx1279_debug
    (rx1279_cur, rx1279_pos, rx1279_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1279_cur
    .local pmc match
    .lex "$/", match
    length rx1279_eos, rx1279_tgt
    gt rx1279_pos, rx1279_eos, rx1279_done
    set rx1279_off, 0
    lt rx1279_pos, 2, rx1279_start
    sub rx1279_off, rx1279_pos, 1
    substr rx1279_tgt, rx1279_tgt, rx1279_off
  rx1279_start:
    eq $I10, 1, rx1279_restart
    if_null rx1279_debug, debug_894
    rx1279_cur."!cursor_debug"("START", "")
  debug_894:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1280_done
    goto rxscan1280_scan
  rxscan1280_loop:
    (rx1279_pos) = rx1279_cur."from"()
    inc rx1279_pos
    rx1279_cur."!cursor_from"(rx1279_pos)
    ge rx1279_pos, rx1279_eos, rxscan1280_done
  rxscan1280_scan:
    set_addr $I10, rxscan1280_loop
    rx1279_cur."!mark_push"(0, rx1279_pos, $I10)
  rxscan1280_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1279_pos, rx1279_off
    set rx1279_rep, 0
    sub $I12, rx1279_eos, rx1279_pos
  rxenumcharlistq1281_loop:
    le $I12, 0, rxenumcharlistq1281_done
    substr $S10, rx1279_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1281_done
    inc rx1279_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1281_loop
  rxenumcharlistq1281_done:
    add rx1279_pos, rx1279_pos, rx1279_rep
  # rx literal  "="
    add $I11, rx1279_pos, 1
    gt $I11, rx1279_eos, rx1279_fail
    sub $I11, rx1279_pos, rx1279_off
    ord $I11, rx1279_tgt, $I11
    ne $I11, 61, rx1279_fail
    add rx1279_pos, 1
  alt1282_0:
    set_addr $I10, alt1282_1
    rx1279_cur."!mark_push"(0, rx1279_pos, $I10)
  # rx charclass w
    ge rx1279_pos, rx1279_eos, rx1279_fail
    sub $I10, rx1279_pos, rx1279_off
    is_cclass $I11, .CCLASS_WORD, rx1279_tgt, $I10
    unless $I11, rx1279_fail
    inc rx1279_pos
    goto alt1282_end
  alt1282_1:
  # rx literal  "\\"
    add $I11, rx1279_pos, 1
    gt $I11, rx1279_eos, rx1279_fail
    sub $I11, rx1279_pos, rx1279_off
    ord $I11, rx1279_tgt, $I11
    ne $I11, 92, rx1279_fail
    add rx1279_pos, 1
  alt1282_end:
  # rx pass
    rx1279_cur."!cursor_pass"(rx1279_pos, "")
    if_null rx1279_debug, debug_895
    rx1279_cur."!cursor_debug"("PASS", "", " at pos=", rx1279_pos)
  debug_895:
    .return (rx1279_cur)
  rx1279_restart:
    if_null rx1279_debug, debug_896
    rx1279_cur."!cursor_debug"("NEXT", "")
  debug_896:
  rx1279_fail:
    (rx1279_rep, rx1279_pos, $I10, $P10) = rx1279_cur."!mark_fail"(0)
    lt rx1279_pos, -1, rx1279_done
    eq rx1279_pos, -1, rx1279_fail
    jump $I10
  rx1279_done:
    rx1279_cur."!cursor_fail"()
    if_null rx1279_debug, debug_897
    rx1279_cur."!cursor_debug"("FAIL", "")
  debug_897:
    .return (rx1279_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__unv"  :subid("54_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    new $P103, "ResizablePMCArray"
    push $P103, ""
    push $P103, ""
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pod_comment"  :subid("55_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .const 'Sub' $P1315 = "56_1310110678.31883" 
    capture_lex $P1315
    .local string rx1287_tgt
    .local int rx1287_pos
    .local int rx1287_off
    .local int rx1287_eos
    .local int rx1287_rep
    .local pmc rx1287_cur
    .local pmc rx1287_debug
    (rx1287_cur, rx1287_pos, rx1287_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1287_cur
    .local pmc match
    .lex "$/", match
    length rx1287_eos, rx1287_tgt
    gt rx1287_pos, rx1287_eos, rx1287_done
    set rx1287_off, 0
    lt rx1287_pos, 2, rx1287_start
    sub rx1287_off, rx1287_pos, 1
    substr rx1287_tgt, rx1287_tgt, rx1287_off
  rx1287_start:
    eq $I10, 1, rx1287_restart
    if_null rx1287_debug, debug_901
    rx1287_cur."!cursor_debug"("START", "pod_comment")
  debug_901:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1288_done
    goto rxscan1288_scan
  rxscan1288_loop:
    (rx1287_pos) = rx1287_cur."from"()
    inc rx1287_pos
    rx1287_cur."!cursor_from"(rx1287_pos)
    ge rx1287_pos, rx1287_eos, rxscan1288_done
  rxscan1288_scan:
    set_addr $I10, rxscan1288_loop
    rx1287_cur."!mark_push"(0, rx1287_pos, $I10)
  rxscan1288_done:
.annotate 'line', 504
  # rxanchor bol
    eq rx1287_pos, 0, rxanchor1289_done
    ge rx1287_pos, rx1287_eos, rx1287_fail
    sub $I10, rx1287_pos, rx1287_off
    dec $I10
    is_cclass $I11, .CCLASS_NEWLINE, rx1287_tgt, $I10
    unless $I11, rx1287_fail
  rxanchor1289_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1287_pos, rx1287_off
    set rx1287_rep, 0
    sub $I12, rx1287_eos, rx1287_pos
  rxenumcharlistq1290_loop:
    le $I12, 0, rxenumcharlistq1290_done
    substr $S10, rx1287_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1290_done
    inc rx1287_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1290_loop
  rxenumcharlistq1290_done:
    add rx1287_pos, rx1287_pos, rx1287_rep
  # rx literal  "="
    add $I11, rx1287_pos, 1
    gt $I11, rx1287_eos, rx1287_fail
    sub $I11, rx1287_pos, rx1287_off
    ord $I11, rx1287_tgt, $I11
    ne $I11, 61, rx1287_fail
    add rx1287_pos, 1
  alt1291_0:
.annotate 'line', 505
    set_addr $I10, alt1291_1
    rx1287_cur."!mark_push"(0, rx1287_pos, $I10)
.annotate 'line', 506
  # rx literal  "begin"
    add $I11, rx1287_pos, 5
    gt $I11, rx1287_eos, rx1287_fail
    sub $I11, rx1287_pos, rx1287_off
    substr $S10, rx1287_tgt, $I11, 5
    ne $S10, "begin", rx1287_fail
    add rx1287_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx1287_pos, rx1287_off
    set rx1287_rep, 0
    sub $I12, rx1287_eos, rx1287_pos
  rxenumcharlistq1292_loop:
    le $I12, 0, rxenumcharlistq1292_done
    substr $S10, rx1287_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1292_done
    inc rx1287_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1292_loop
  rxenumcharlistq1292_done:
    lt rx1287_rep, 1, rx1287_fail
    add rx1287_pos, rx1287_pos, rx1287_rep
  # rx literal  "END"
    add $I11, rx1287_pos, 3
    gt $I11, rx1287_eos, rx1287_fail
    sub $I11, rx1287_pos, rx1287_off
    substr $S10, rx1287_tgt, $I11, 3
    ne $S10, "END", rx1287_fail
    add rx1287_pos, 3
  # rxanchor rwb
    le rx1287_pos, 0, rx1287_fail
    sub $I10, rx1287_pos, rx1287_off
    is_cclass $I11, .CCLASS_WORD, rx1287_tgt, $I10
    if $I11, rx1287_fail
    dec $I10
    is_cclass $I11, .CCLASS_WORD, rx1287_tgt, $I10
    unless $I11, rx1287_fail
  alt1293_0:
.annotate 'line', 507
    set_addr $I10, alt1293_1
    rx1287_cur."!mark_push"(0, rx1287_pos, $I10)
  # rx rxquantf1294 ** 0..*
    set_addr $I10, rxquantf1294_loop
    rx1287_cur."!mark_push"(0, rx1287_pos, $I10)
    goto rxquantf1294_done
  rxquantf1294_loop:
  # rx charclass .
    ge rx1287_pos, rx1287_eos, rx1287_fail
    inc rx1287_pos
    set_addr $I10, rxquantf1294_loop
    rx1287_cur."!mark_push"(rx1287_rep, rx1287_pos, $I10)
  rxquantf1294_done:
  # rx charclass nl
    ge rx1287_pos, rx1287_eos, rx1287_fail
    sub $I10, rx1287_pos, rx1287_off
    is_cclass $I11, .CCLASS_NEWLINE, rx1287_tgt, $I10
    unless $I11, rx1287_fail
    substr $S10, rx1287_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx1287_pos, $I11
    inc rx1287_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1287_pos, rx1287_off
    set rx1287_rep, 0
    sub $I12, rx1287_eos, rx1287_pos
  rxenumcharlistq1296_loop:
    le $I12, 0, rxenumcharlistq1296_done
    substr $S10, rx1287_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1296_done
    inc rx1287_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1296_loop
  rxenumcharlistq1296_done:
    add rx1287_pos, rx1287_pos, rx1287_rep
  # rx literal  "=end"
    add $I11, rx1287_pos, 4
    gt $I11, rx1287_eos, rx1287_fail
    sub $I11, rx1287_pos, rx1287_off
    substr $S10, rx1287_tgt, $I11, 4
    ne $S10, "=end", rx1287_fail
    add rx1287_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx1287_pos, rx1287_off
    set rx1287_rep, 0
    sub $I12, rx1287_eos, rx1287_pos
  rxenumcharlistq1297_loop:
    le $I12, 0, rxenumcharlistq1297_done
    substr $S10, rx1287_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1297_done
    inc rx1287_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1297_loop
  rxenumcharlistq1297_done:
    lt rx1287_rep, 1, rx1287_fail
    add rx1287_pos, rx1287_pos, rx1287_rep
  # rx literal  "END"
    add $I11, rx1287_pos, 3
    gt $I11, rx1287_eos, rx1287_fail
    sub $I11, rx1287_pos, rx1287_off
    substr $S10, rx1287_tgt, $I11, 3
    ne $S10, "END", rx1287_fail
    add rx1287_pos, 3
  # rxanchor rwb
    le rx1287_pos, 0, rx1287_fail
    sub $I10, rx1287_pos, rx1287_off
    is_cclass $I11, .CCLASS_WORD, rx1287_tgt, $I10
    if $I11, rx1287_fail
    dec $I10
    is_cclass $I11, .CCLASS_WORD, rx1287_tgt, $I10
    unless $I11, rx1287_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx1287_pos, rx1287_off
    find_cclass $I11, .CCLASS_NEWLINE, rx1287_tgt, $I10, rx1287_eos
    add rx1287_pos, rx1287_off, $I11
    goto alt1293_end
  alt1293_1:
  # rx charclass_q . r 0..-1
    sub $I10, rx1287_pos, rx1287_off
    find_not_cclass $I11, .CCLASS_ANY, rx1287_tgt, $I10, rx1287_eos
    add rx1287_pos, rx1287_off, $I11
  alt1293_end:
.annotate 'line', 506
    goto alt1291_end
  alt1291_1:
    set_addr $I10, alt1291_2
    rx1287_cur."!mark_push"(0, rx1287_pos, $I10)
.annotate 'line', 508
  # rx literal  "begin"
    add $I11, rx1287_pos, 5
    gt $I11, rx1287_eos, rx1287_fail
    sub $I11, rx1287_pos, rx1287_off
    substr $S10, rx1287_tgt, $I11, 5
    ne $S10, "begin", rx1287_fail
    add rx1287_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx1287_pos, rx1287_off
    set rx1287_rep, 0
    sub $I12, rx1287_eos, rx1287_pos
  rxenumcharlistq1298_loop:
    le $I12, 0, rxenumcharlistq1298_done
    substr $S10, rx1287_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1298_done
    inc rx1287_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1298_loop
  rxenumcharlistq1298_done:
    lt rx1287_rep, 1, rx1287_fail
    add rx1287_pos, rx1287_pos, rx1287_rep
  # rx subrule "identifier" subtype=capture negate=
    rx1287_cur."!cursor_pos"(rx1287_pos)
    $P10 = rx1287_cur."identifier"()
    unless $P10, rx1287_fail
    rx1287_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx1287_pos = $P10."pos"()
  alt1299_0:
.annotate 'line', 509
    set_addr $I10, alt1299_1
    rx1287_cur."!mark_push"(0, rx1287_pos, $I10)
.annotate 'line', 510
  # rx rxquantf1300 ** 0..*
    set_addr $I10, rxquantf1300_loop
    rx1287_cur."!mark_push"(0, rx1287_pos, $I10)
    goto rxquantf1300_done
  rxquantf1300_loop:
  # rx charclass .
    ge rx1287_pos, rx1287_eos, rx1287_fail
    inc rx1287_pos
    set_addr $I10, rxquantf1300_loop
    rx1287_cur."!mark_push"(rx1287_rep, rx1287_pos, $I10)
  rxquantf1300_done:
  # rx charclass nl
    ge rx1287_pos, rx1287_eos, rx1287_fail
    sub $I10, rx1287_pos, rx1287_off
    is_cclass $I11, .CCLASS_NEWLINE, rx1287_tgt, $I10
    unless $I11, rx1287_fail
    substr $S10, rx1287_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx1287_pos, $I11
    inc rx1287_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1287_pos, rx1287_off
    set rx1287_rep, 0
    sub $I12, rx1287_eos, rx1287_pos
  rxenumcharlistq1302_loop:
    le $I12, 0, rxenumcharlistq1302_done
    substr $S10, rx1287_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1302_done
    inc rx1287_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1302_loop
  rxenumcharlistq1302_done:
    add rx1287_pos, rx1287_pos, rx1287_rep
  # rx literal  "=end"
    add $I11, rx1287_pos, 4
    gt $I11, rx1287_eos, rx1287_fail
    sub $I11, rx1287_pos, rx1287_off
    substr $S10, rx1287_tgt, $I11, 4
    ne $S10, "=end", rx1287_fail
    add rx1287_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx1287_pos, rx1287_off
    set rx1287_rep, 0
    sub $I12, rx1287_eos, rx1287_pos
  rxenumcharlistq1303_loop:
    le $I12, 0, rxenumcharlistq1303_done
    substr $S10, rx1287_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1303_done
    inc rx1287_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1303_loop
  rxenumcharlistq1303_done:
    lt rx1287_rep, 1, rx1287_fail
    add rx1287_pos, rx1287_pos, rx1287_rep
  # rx subrule "!BACKREF" subtype=method negate=
    rx1287_cur."!cursor_pos"(rx1287_pos)
    $P10 = rx1287_cur."!BACKREF"("identifier")
    unless $P10, rx1287_fail
    rx1287_pos = $P10."pos"()
  # rxanchor rwb
    le rx1287_pos, 0, rx1287_fail
    sub $I10, rx1287_pos, rx1287_off
    is_cclass $I11, .CCLASS_WORD, rx1287_tgt, $I10
    if $I11, rx1287_fail
    dec $I10
    is_cclass $I11, .CCLASS_WORD, rx1287_tgt, $I10
    unless $I11, rx1287_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx1287_pos, rx1287_off
    find_cclass $I11, .CCLASS_NEWLINE, rx1287_tgt, $I10, rx1287_eos
    add rx1287_pos, rx1287_off, $I11
    goto alt1299_end
  alt1299_1:
.annotate 'line', 511
  # rx subrule "panic" subtype=method negate=
    rx1287_cur."!cursor_pos"(rx1287_pos)
    $P10 = rx1287_cur."panic"("=begin without matching =end")
    unless $P10, rx1287_fail
    rx1287_pos = $P10."pos"()
  alt1299_end:
.annotate 'line', 508
    goto alt1291_end
  alt1291_2:
    set_addr $I10, alt1291_3
    rx1287_cur."!mark_push"(0, rx1287_pos, $I10)
.annotate 'line', 513
  # rx literal  "begin"
    add $I11, rx1287_pos, 5
    gt $I11, rx1287_eos, rx1287_fail
    sub $I11, rx1287_pos, rx1287_off
    substr $S10, rx1287_tgt, $I11, 5
    ne $S10, "begin", rx1287_fail
    add rx1287_pos, 5
  # rxanchor rwb
    le rx1287_pos, 0, rx1287_fail
    sub $I10, rx1287_pos, rx1287_off
    is_cclass $I11, .CCLASS_WORD, rx1287_tgt, $I10
    if $I11, rx1287_fail
    dec $I10
    is_cclass $I11, .CCLASS_WORD, rx1287_tgt, $I10
    unless $I11, rx1287_fail
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1287_pos, rx1287_off
    set rx1287_rep, 0
    sub $I12, rx1287_eos, rx1287_pos
  rxenumcharlistq1304_loop:
    le $I12, 0, rxenumcharlistq1304_done
    substr $S10, rx1287_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1304_done
    inc rx1287_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1304_loop
  rxenumcharlistq1304_done:
    add rx1287_pos, rx1287_pos, rx1287_rep
  alt1305_0:
.annotate 'line', 514
    set_addr $I10, alt1305_1
    rx1287_cur."!mark_push"(0, rx1287_pos, $I10)
  # rxanchor eol
    sub $I10, rx1287_pos, rx1287_off
    is_cclass $I11, .CCLASS_NEWLINE, rx1287_tgt, $I10
    if $I11, rxanchor1306_done
    ne rx1287_pos, rx1287_eos, rx1287_fail
    eq rx1287_pos, 0, rxanchor1306_done
    dec $I10
    is_cclass $I11, .CCLASS_NEWLINE, rx1287_tgt, $I10
    if $I11, rx1287_fail
  rxanchor1306_done:
    goto alt1305_end
  alt1305_1:
    set_addr $I10, alt1305_2
    rx1287_cur."!mark_push"(0, rx1287_pos, $I10)
  # rx literal  "#"
    add $I11, rx1287_pos, 1
    gt $I11, rx1287_eos, rx1287_fail
    sub $I11, rx1287_pos, rx1287_off
    ord $I11, rx1287_tgt, $I11
    ne $I11, 35, rx1287_fail
    add rx1287_pos, 1
    goto alt1305_end
  alt1305_2:
  # rx subrule "panic" subtype=method negate=
    rx1287_cur."!cursor_pos"(rx1287_pos)
    $P10 = rx1287_cur."panic"("Unrecognized token after =begin")
    unless $P10, rx1287_fail
    rx1287_pos = $P10."pos"()
  alt1305_end:
  alt1307_0:
.annotate 'line', 515
    set_addr $I10, alt1307_1
    rx1287_cur."!mark_push"(0, rx1287_pos, $I10)
.annotate 'line', 516
  # rx rxquantf1308 ** 0..*
    set_addr $I10, rxquantf1308_loop
    rx1287_cur."!mark_push"(0, rx1287_pos, $I10)
    goto rxquantf1308_done
  rxquantf1308_loop:
  # rx charclass .
    ge rx1287_pos, rx1287_eos, rx1287_fail
    inc rx1287_pos
    set_addr $I10, rxquantf1308_loop
    rx1287_cur."!mark_push"(rx1287_rep, rx1287_pos, $I10)
  rxquantf1308_done:
  # rx charclass nl
    ge rx1287_pos, rx1287_eos, rx1287_fail
    sub $I10, rx1287_pos, rx1287_off
    is_cclass $I11, .CCLASS_NEWLINE, rx1287_tgt, $I10
    unless $I11, rx1287_fail
    substr $S10, rx1287_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx1287_pos, $I11
    inc rx1287_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1287_pos, rx1287_off
    set rx1287_rep, 0
    sub $I12, rx1287_eos, rx1287_pos
  rxenumcharlistq1310_loop:
    le $I12, 0, rxenumcharlistq1310_done
    substr $S10, rx1287_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1310_done
    inc rx1287_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1310_loop
  rxenumcharlistq1310_done:
    add rx1287_pos, rx1287_pos, rx1287_rep
  # rx literal  "=end"
    add $I11, rx1287_pos, 4
    gt $I11, rx1287_eos, rx1287_fail
    sub $I11, rx1287_pos, rx1287_off
    substr $S10, rx1287_tgt, $I11, 4
    ne $S10, "=end", rx1287_fail
    add rx1287_pos, 4
  # rxanchor rwb
    le rx1287_pos, 0, rx1287_fail
    sub $I10, rx1287_pos, rx1287_off
    is_cclass $I11, .CCLASS_WORD, rx1287_tgt, $I10
    if $I11, rx1287_fail
    dec $I10
    is_cclass $I11, .CCLASS_WORD, rx1287_tgt, $I10
    unless $I11, rx1287_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx1287_pos, rx1287_off
    find_cclass $I11, .CCLASS_NEWLINE, rx1287_tgt, $I10, rx1287_eos
    add rx1287_pos, rx1287_off, $I11
    goto alt1307_end
  alt1307_1:
.annotate 'line', 517
  # rx subrule "panic" subtype=method negate=
    rx1287_cur."!cursor_pos"(rx1287_pos)
    $P10 = rx1287_cur."panic"("=begin without matching =end")
    unless $P10, rx1287_fail
    rx1287_pos = $P10."pos"()
  alt1307_end:
.annotate 'line', 513
    goto alt1291_end
  alt1291_3:
    set_addr $I10, alt1291_4
    rx1287_cur."!mark_push"(0, rx1287_pos, $I10)
.annotate 'line', 519
  # rx subrule "identifier" subtype=capture negate=
    rx1287_cur."!cursor_pos"(rx1287_pos)
    $P10 = rx1287_cur."identifier"()
    unless $P10, rx1287_fail
    rx1287_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx1287_pos = $P10."pos"()
.annotate 'line', 520
  # rx rxquantf1311 ** 0..*
    set_addr $I10, rxquantf1311_loop
    rx1287_cur."!mark_push"(0, rx1287_pos, $I10)
    goto rxquantf1311_done
  rxquantf1311_loop:
  # rx charclass .
    ge rx1287_pos, rx1287_eos, rx1287_fail
    inc rx1287_pos
    set_addr $I10, rxquantf1311_loop
    rx1287_cur."!mark_push"(rx1287_rep, rx1287_pos, $I10)
  rxquantf1311_done:
  # rxanchor bol
    eq rx1287_pos, 0, rxanchor1313_done
    ge rx1287_pos, rx1287_eos, rx1287_fail
    sub $I10, rx1287_pos, rx1287_off
    dec $I10
    is_cclass $I11, .CCLASS_NEWLINE, rx1287_tgt, $I10
    unless $I11, rx1287_fail
  rxanchor1313_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx1287_cur."!cursor_pos"(rx1287_pos)
    .const 'Sub' $P1315 = "56_1310110678.31883" 
    capture_lex $P1315
    $P10 = rx1287_cur."before"($P1315)
    unless $P10, rx1287_fail
.annotate 'line', 519
    goto alt1291_end
  alt1291_4:
  alt1321_0:
.annotate 'line', 526
    set_addr $I10, alt1321_1
    rx1287_cur."!mark_push"(0, rx1287_pos, $I10)
  # rx charclass s
    ge rx1287_pos, rx1287_eos, rx1287_fail
    sub $I10, rx1287_pos, rx1287_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1287_tgt, $I10
    unless $I11, rx1287_fail
    inc rx1287_pos
    goto alt1321_end
  alt1321_1:
  # rx subrule "panic" subtype=method negate=
    rx1287_cur."!cursor_pos"(rx1287_pos)
    $P10 = rx1287_cur."panic"("Illegal pod directive")
    unless $P10, rx1287_fail
    rx1287_pos = $P10."pos"()
  alt1321_end:
.annotate 'line', 527
  # rx charclass_q N r 0..-1
    sub $I10, rx1287_pos, rx1287_off
    find_cclass $I11, .CCLASS_NEWLINE, rx1287_tgt, $I10, rx1287_eos
    add rx1287_pos, rx1287_off, $I11
  alt1291_end:
.annotate 'line', 503
  # rx pass
    rx1287_cur."!cursor_pass"(rx1287_pos, "pod_comment")
    if_null rx1287_debug, debug_906
    rx1287_cur."!cursor_debug"("PASS", "pod_comment", " at pos=", rx1287_pos)
  debug_906:
    .return (rx1287_cur)
  rx1287_restart:
.annotate 'line', 435
    if_null rx1287_debug, debug_907
    rx1287_cur."!cursor_debug"("NEXT", "pod_comment")
  debug_907:
  rx1287_fail:
    (rx1287_rep, rx1287_pos, $I10, $P10) = rx1287_cur."!mark_fail"(0)
    lt rx1287_pos, -1, rx1287_done
    eq rx1287_pos, -1, rx1287_fail
    jump $I10
  rx1287_done:
    rx1287_cur."!cursor_fail"()
    if_null rx1287_debug, debug_908
    rx1287_cur."!cursor_debug"("FAIL", "pod_comment")
  debug_908:
    .return (rx1287_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1314"  :anon :subid("56_1310110678.31883") :method :outer("55_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 520
    .local string rx1316_tgt
    .local int rx1316_pos
    .local int rx1316_off
    .local int rx1316_eos
    .local int rx1316_rep
    .local pmc rx1316_cur
    .local pmc rx1316_debug
    (rx1316_cur, rx1316_pos, rx1316_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1316_cur
    .local pmc match
    .lex "$/", match
    length rx1316_eos, rx1316_tgt
    gt rx1316_pos, rx1316_eos, rx1316_done
    set rx1316_off, 0
    lt rx1316_pos, 2, rx1316_start
    sub rx1316_off, rx1316_pos, 1
    substr rx1316_tgt, rx1316_tgt, rx1316_off
  rx1316_start:
    eq $I10, 1, rx1316_restart
    if_null rx1316_debug, debug_902
    rx1316_cur."!cursor_debug"("START", "")
  debug_902:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1317_done
    goto rxscan1317_scan
  rxscan1317_loop:
    (rx1316_pos) = rx1316_cur."from"()
    inc rx1316_pos
    rx1316_cur."!cursor_from"(rx1316_pos)
    ge rx1316_pos, rx1316_eos, rxscan1317_done
  rxscan1317_scan:
    set_addr $I10, rxscan1317_loop
    rx1316_cur."!mark_push"(0, rx1316_pos, $I10)
  rxscan1317_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1316_pos, rx1316_off
    set rx1316_rep, 0
    sub $I12, rx1316_eos, rx1316_pos
  rxenumcharlistq1318_loop:
    le $I12, 0, rxenumcharlistq1318_done
    substr $S10, rx1316_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1318_done
    inc rx1316_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1318_loop
  rxenumcharlistq1318_done:
    add rx1316_pos, rx1316_pos, rx1316_rep
  alt1319_0:
    set_addr $I10, alt1319_1
    rx1316_cur."!mark_push"(0, rx1316_pos, $I10)
.annotate 'line', 521
  # rx literal  "="
    add $I11, rx1316_pos, 1
    gt $I11, rx1316_eos, rx1316_fail
    sub $I11, rx1316_pos, rx1316_off
    ord $I11, rx1316_tgt, $I11
    ne $I11, 61, rx1316_fail
    add rx1316_pos, 1
.annotate 'line', 523
  # rx rxquantr1320 ** 0..1
    set_addr $I10, rxquantr1320_done
    rx1316_cur."!mark_push"(0, rx1316_pos, $I10)
  rxquantr1320_loop:
.annotate 'line', 522
  # rx literal  "cut"
    add $I11, rx1316_pos, 3
    gt $I11, rx1316_eos, rx1316_fail
    sub $I11, rx1316_pos, rx1316_off
    substr $S10, rx1316_tgt, $I11, 3
    ne $S10, "cut", rx1316_fail
    add rx1316_pos, 3
  # rxanchor rwb
    le rx1316_pos, 0, rx1316_fail
    sub $I10, rx1316_pos, rx1316_off
    is_cclass $I11, .CCLASS_WORD, rx1316_tgt, $I10
    if $I11, rx1316_fail
    dec $I10
    is_cclass $I11, .CCLASS_WORD, rx1316_tgt, $I10
    unless $I11, rx1316_fail
.annotate 'line', 523
  # rx subrule "panic" subtype=method negate=
    rx1316_cur."!cursor_pos"(rx1316_pos)
    $P10 = rx1316_cur."panic"("Obsolete pod format, please use =begin/=end instead")
    unless $P10, rx1316_fail
    rx1316_pos = $P10."pos"()
    set_addr $I10, rxquantr1320_done
    (rx1316_rep) = rx1316_cur."!mark_commit"($I10)
  rxquantr1320_done:
.annotate 'line', 520
    goto alt1319_end
  alt1319_1:
.annotate 'line', 524
  # rx charclass nl
    ge rx1316_pos, rx1316_eos, rx1316_fail
    sub $I10, rx1316_pos, rx1316_off
    is_cclass $I11, .CCLASS_NEWLINE, rx1316_tgt, $I10
    unless $I11, rx1316_fail
    substr $S10, rx1316_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx1316_pos, $I11
    inc rx1316_pos
  alt1319_end:
.annotate 'line', 520
  # rx pass
    rx1316_cur."!cursor_pass"(rx1316_pos, "")
    if_null rx1316_debug, debug_903
    rx1316_cur."!cursor_debug"("PASS", "", " at pos=", rx1316_pos)
  debug_903:
    .return (rx1316_cur)
  rx1316_restart:
    if_null rx1316_debug, debug_904
    rx1316_cur."!cursor_debug"("NEXT", "")
  debug_904:
  rx1316_fail:
    (rx1316_rep, rx1316_pos, $I10, $P10) = rx1316_cur."!mark_fail"(0)
    lt rx1316_pos, -1, rx1316_done
    eq rx1316_pos, -1, rx1316_fail
    jump $I10
  rx1316_done:
    rx1316_cur."!cursor_fail"()
    if_null rx1316_debug, debug_905
    rx1316_cur."!cursor_debug"("FAIL", "")
  debug_905:
    .return (rx1316_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pod_comment"  :subid("57_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    new $P104, "ResizablePMCArray"
    push $P104, ""
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "comp_unit"  :subid("58_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 535
    new $P103, "Undef"
    set $P1324, $P103
    .lex "$*IN_DECL", $P1324
.annotate 'line', 537
    new $P104, "Undef"
    set $P1325, $P104
    .lex "$*HAS_YOU_ARE_HERE", $P1325
.annotate 'line', 538
    new $P105, "Undef"
    set $P1326, $P105
    .lex "$*MAIN_SUB", $P1326
.annotate 'line', 541
    new $P106, "Undef"
    set $P1327, $P106
    .lex "$*PACKAGE", $P1327
.annotate 'line', 542
    new $P107, "Undef"
    set $P1328, $P107
    .lex "$*GLOBALish", $P1328
.annotate 'line', 435
    .local string rx1329_tgt
    .local int rx1329_pos
    .local int rx1329_off
    .local int rx1329_eos
    .local int rx1329_rep
    .local pmc rx1329_cur
    .local pmc rx1329_debug
    (rx1329_cur, rx1329_pos, rx1329_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1329_cur
    .local pmc match
    .lex "$/", match
    length rx1329_eos, rx1329_tgt
    gt rx1329_pos, rx1329_eos, rx1329_done
    set rx1329_off, 0
    lt rx1329_pos, 2, rx1329_start
    sub rx1329_off, rx1329_pos, 1
    substr rx1329_tgt, rx1329_tgt, rx1329_off
  rx1329_start:
    eq $I10, 1, rx1329_restart
    if_null rx1329_debug, debug_909
    rx1329_cur."!cursor_debug"("START", "comp_unit")
  debug_909:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1330_done
    goto rxscan1330_scan
  rxscan1330_loop:
    (rx1329_pos) = rx1329_cur."from"()
    inc rx1329_pos
    rx1329_cur."!cursor_from"(rx1329_pos)
    ge rx1329_pos, rx1329_eos, rxscan1330_done
  rxscan1330_scan:
    set_addr $I10, rxscan1330_loop
    rx1329_cur."!mark_push"(0, rx1329_pos, $I10)
  rxscan1330_done:
.annotate 'line', 535
    rx1329_cur."!cursor_pos"(rx1329_pos)
    new $P108, "String"
    assign $P108, ""
    store_lex "$*IN_DECL", $P108
.annotate 'line', 537
    rx1329_cur."!cursor_pos"(rx1329_pos)
    new $P109, "Integer"
    assign $P109, 0
    store_lex "$*HAS_YOU_ARE_HERE", $P109
.annotate 'line', 538
    rx1329_cur."!cursor_pos"(rx1329_pos)
    find_lex $P112, "$*MAIN_SUB"
    unless_null $P112, vivify_910
    get_hll_global $P110, "GLOBAL"
    get_who $P111, $P110
    set $P112, $P111["$MAIN_SUB"]
    unless_null $P112, vivify_911
    die "Contextual $*MAIN_SUB not found"
  vivify_911:
  vivify_910:
.annotate 'line', 539
  # rx subrule "newpad" subtype=method negate=
    rx1329_cur."!cursor_pos"(rx1329_pos)
    $P10 = rx1329_cur."newpad"()
    unless $P10, rx1329_fail
    rx1329_pos = $P10."pos"()
.annotate 'line', 541
    rx1329_cur."!cursor_pos"(rx1329_pos)
    find_lex $P115, "$*PACKAGE"
    unless_null $P115, vivify_912
    get_hll_global $P113, "GLOBAL"
    get_who $P114, $P113
    set $P115, $P114["$PACKAGE"]
    unless_null $P115, vivify_913
    die "Contextual $*PACKAGE not found"
  vivify_913:
  vivify_912:
.annotate 'line', 542
    rx1329_cur."!cursor_pos"(rx1329_pos)
    find_lex $P118, "$*GLOBALish"
    unless_null $P118, vivify_914
    get_hll_global $P116, "GLOBAL"
    get_who $P117, $P116
    set $P118, $P117["$GLOBALish"]
    unless_null $P118, vivify_915
    die "Contextual $*GLOBALish not found"
  vivify_915:
  vivify_914:
.annotate 'line', 543
  # rx subrule "GLOBALish" subtype=method negate=
    rx1329_cur."!cursor_pos"(rx1329_pos)
    $P10 = rx1329_cur."GLOBALish"()
    unless $P10, rx1329_fail
    rx1329_pos = $P10."pos"()
.annotate 'line', 545
  # rx subrule "outerctx" subtype=method negate=
    rx1329_cur."!cursor_pos"(rx1329_pos)
    $P10 = rx1329_cur."outerctx"()
    unless $P10, rx1329_fail
    rx1329_pos = $P10."pos"()
.annotate 'line', 547
  # rx subrule "statementlist" subtype=capture negate=
    rx1329_cur."!cursor_pos"(rx1329_pos)
    $P10 = rx1329_cur."statementlist"()
    unless $P10, rx1329_fail
    rx1329_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx1329_pos = $P10."pos"()
  alt1331_0:
.annotate 'line', 548
    set_addr $I10, alt1331_1
    rx1329_cur."!mark_push"(0, rx1329_pos, $I10)
  # rxanchor eos
    ne rx1329_pos, rx1329_eos, rx1329_fail
    goto alt1331_end
  alt1331_1:
  # rx subrule "panic" subtype=method negate=
    rx1329_cur."!cursor_pos"(rx1329_pos)
    $P10 = rx1329_cur."panic"("Confused")
    unless $P10, rx1329_fail
    rx1329_pos = $P10."pos"()
  alt1331_end:
.annotate 'line', 534
  # rx pass
    rx1329_cur."!cursor_pass"(rx1329_pos, "comp_unit")
    if_null rx1329_debug, debug_916
    rx1329_cur."!cursor_debug"("PASS", "comp_unit", " at pos=", rx1329_pos)
  debug_916:
    .return (rx1329_cur)
  rx1329_restart:
.annotate 'line', 435
    if_null rx1329_debug, debug_917
    rx1329_cur."!cursor_debug"("NEXT", "comp_unit")
  debug_917:
  rx1329_fail:
    (rx1329_rep, rx1329_pos, $I10, $P10) = rx1329_cur."!mark_fail"(0)
    lt rx1329_pos, -1, rx1329_done
    eq rx1329_pos, -1, rx1329_fail
    jump $I10
  rx1329_done:
    rx1329_cur."!cursor_fail"()
    if_null rx1329_debug, debug_918
    rx1329_cur."!cursor_debug"("FAIL", "comp_unit")
  debug_918:
    .return (rx1329_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__comp_unit"  :subid("59_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P119 = self."!PREFIX__!subrule"("newpad", "")
    new $P120, "ResizablePMCArray"
    push $P120, $P119
    .return ($P120)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statementlist"  :subid("60_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1334_tgt
    .local int rx1334_pos
    .local int rx1334_off
    .local int rx1334_eos
    .local int rx1334_rep
    .local pmc rx1334_cur
    .local pmc rx1334_debug
    (rx1334_cur, rx1334_pos, rx1334_tgt, $I10) = self."!cursor_start"()
    rx1334_cur."!cursor_caparray"("statement")
    .lex unicode:"$\x{a2}", rx1334_cur
    .local pmc match
    .lex "$/", match
    length rx1334_eos, rx1334_tgt
    gt rx1334_pos, rx1334_eos, rx1334_done
    set rx1334_off, 0
    lt rx1334_pos, 2, rx1334_start
    sub rx1334_off, rx1334_pos, 1
    substr rx1334_tgt, rx1334_tgt, rx1334_off
  rx1334_start:
    eq $I10, 1, rx1334_restart
    if_null rx1334_debug, debug_919
    rx1334_cur."!cursor_debug"("START", "statementlist")
  debug_919:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1335_done
    goto rxscan1335_scan
  rxscan1335_loop:
    (rx1334_pos) = rx1334_cur."from"()
    inc rx1334_pos
    rx1334_cur."!cursor_from"(rx1334_pos)
    ge rx1334_pos, rx1334_eos, rxscan1335_done
  rxscan1335_scan:
    set_addr $I10, rxscan1335_loop
    rx1334_cur."!mark_push"(0, rx1334_pos, $I10)
  rxscan1335_done:
  alt1336_0:
.annotate 'line', 551
    set_addr $I10, alt1336_1
    rx1334_cur."!mark_push"(0, rx1334_pos, $I10)
.annotate 'line', 552
  # rx subrule "ws" subtype=method negate=
    rx1334_cur."!cursor_pos"(rx1334_pos)
    $P10 = rx1334_cur."ws"()
    unless $P10, rx1334_fail
    rx1334_pos = $P10."pos"()
  # rxanchor eos
    ne rx1334_pos, rx1334_eos, rx1334_fail
  # rx subrule "ws" subtype=method negate=
    rx1334_cur."!cursor_pos"(rx1334_pos)
    $P10 = rx1334_cur."ws"()
    unless $P10, rx1334_fail
    rx1334_pos = $P10."pos"()
    goto alt1336_end
  alt1336_1:
.annotate 'line', 553
  # rx subrule "ws" subtype=method negate=
    rx1334_cur."!cursor_pos"(rx1334_pos)
    $P10 = rx1334_cur."ws"()
    unless $P10, rx1334_fail
    rx1334_pos = $P10."pos"()
  # rx rxquantr1337 ** 0..*
    set_addr $I10, rxquantr1337_done
    rx1334_cur."!mark_push"(0, rx1334_pos, $I10)
  rxquantr1337_loop:
  # rx subrule "statement" subtype=capture negate=
    rx1334_cur."!cursor_pos"(rx1334_pos)
    $P10 = rx1334_cur."statement"()
    unless $P10, rx1334_fail
    rx1334_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx1334_pos = $P10."pos"()
  # rx subrule "eat_terminator" subtype=method negate=
    rx1334_cur."!cursor_pos"(rx1334_pos)
    $P10 = rx1334_cur."eat_terminator"()
    unless $P10, rx1334_fail
    rx1334_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1334_cur."!cursor_pos"(rx1334_pos)
    $P10 = rx1334_cur."ws"()
    unless $P10, rx1334_fail
    rx1334_pos = $P10."pos"()
    set_addr $I10, rxquantr1337_done
    (rx1334_rep) = rx1334_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1337_done
    rx1334_cur."!mark_push"(rx1334_rep, rx1334_pos, $I10)
    goto rxquantr1337_loop
  rxquantr1337_done:
  # rx subrule "ws" subtype=method negate=
    rx1334_cur."!cursor_pos"(rx1334_pos)
    $P10 = rx1334_cur."ws"()
    unless $P10, rx1334_fail
    rx1334_pos = $P10."pos"()
  alt1336_end:
.annotate 'line', 551
  # rx pass
    rx1334_cur."!cursor_pass"(rx1334_pos, "statementlist")
    if_null rx1334_debug, debug_920
    rx1334_cur."!cursor_debug"("PASS", "statementlist", " at pos=", rx1334_pos)
  debug_920:
    .return (rx1334_cur)
  rx1334_restart:
.annotate 'line', 435
    if_null rx1334_debug, debug_921
    rx1334_cur."!cursor_debug"("NEXT", "statementlist")
  debug_921:
  rx1334_fail:
    (rx1334_rep, rx1334_pos, $I10, $P10) = rx1334_cur."!mark_fail"(0)
    lt rx1334_pos, -1, rx1334_done
    eq rx1334_pos, -1, rx1334_fail
    jump $I10
  rx1334_done:
    rx1334_cur."!cursor_fail"()
    if_null rx1334_debug, debug_922
    rx1334_cur."!cursor_debug"("FAIL", "statementlist")
  debug_922:
    .return (rx1334_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statementlist"  :subid("61_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P108 = self."!PREFIX__!subrule"("ws", "")
    $P109 = self."!PREFIX__!subrule"("ws", "")
    new $P110, "ResizablePMCArray"
    push $P110, $P108
    push $P110, $P109
    .return ($P110)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement"  :subid("62_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .const 'Sub' $P1343 = "63_1310110678.31883" 
    capture_lex $P1343
    .local string rx1340_tgt
    .local int rx1340_pos
    .local int rx1340_off
    .local int rx1340_eos
    .local int rx1340_rep
    .local pmc rx1340_cur
    .local pmc rx1340_debug
    (rx1340_cur, rx1340_pos, rx1340_tgt, $I10) = self."!cursor_start"()
    rx1340_cur."!cursor_caparray"("statement_mod_cond", "statement_mod_loop")
    .lex unicode:"$\x{a2}", rx1340_cur
    .local pmc match
    .lex "$/", match
    length rx1340_eos, rx1340_tgt
    gt rx1340_pos, rx1340_eos, rx1340_done
    set rx1340_off, 0
    lt rx1340_pos, 2, rx1340_start
    sub rx1340_off, rx1340_pos, 1
    substr rx1340_tgt, rx1340_tgt, rx1340_off
  rx1340_start:
    eq $I10, 1, rx1340_restart
    if_null rx1340_debug, debug_923
    rx1340_cur."!cursor_debug"("START", "statement")
  debug_923:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1341_done
    goto rxscan1341_scan
  rxscan1341_loop:
    (rx1340_pos) = rx1340_cur."from"()
    inc rx1340_pos
    rx1340_cur."!cursor_from"(rx1340_pos)
    ge rx1340_pos, rx1340_eos, rxscan1341_done
  rxscan1341_scan:
    set_addr $I10, rxscan1341_loop
    rx1340_cur."!mark_push"(0, rx1340_pos, $I10)
  rxscan1341_done:
.annotate 'line', 557
  # rx subrule "before" subtype=zerowidth negate=1
    rx1340_cur."!cursor_pos"(rx1340_pos)
    .const 'Sub' $P1343 = "63_1310110678.31883" 
    capture_lex $P1343
    $P10 = rx1340_cur."before"($P1343)
    if $P10, rx1340_fail
  alt1347_0:
.annotate 'line', 558
    set_addr $I10, alt1347_1
    rx1340_cur."!mark_push"(0, rx1340_pos, $I10)
.annotate 'line', 559
  # rx subrule "statement_control" subtype=capture negate=
    rx1340_cur."!cursor_pos"(rx1340_pos)
    $P10 = rx1340_cur."statement_control"()
    unless $P10, rx1340_fail
    rx1340_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_control")
    rx1340_pos = $P10."pos"()
    goto alt1347_end
  alt1347_1:
.annotate 'line', 560
  # rx subrule "EXPR" subtype=capture negate=
    rx1340_cur."!cursor_pos"(rx1340_pos)
    $P10 = rx1340_cur."EXPR"()
    unless $P10, rx1340_fail
    rx1340_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1340_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1340_cur."!cursor_pos"(rx1340_pos)
    $P10 = rx1340_cur."ws"()
    unless $P10, rx1340_fail
    rx1340_pos = $P10."pos"()
.annotate 'line', 565
  # rx rxquantr1348 ** 0..1
    set_addr $I10, rxquantr1348_done
    rx1340_cur."!mark_push"(0, rx1340_pos, $I10)
  rxquantr1348_loop:
  alt1349_0:
.annotate 'line', 561
    set_addr $I10, alt1349_1
    rx1340_cur."!mark_push"(0, rx1340_pos, $I10)
.annotate 'line', 562
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx1340_cur."!cursor_pos"(rx1340_pos)
    $P10 = rx1340_cur."MARKED"("endstmt")
    unless $P10, rx1340_fail
    goto alt1349_end
  alt1349_1:
    set_addr $I10, alt1349_2
    rx1340_cur."!mark_push"(0, rx1340_pos, $I10)
.annotate 'line', 563
  # rx subrule "statement_mod_cond" subtype=capture negate=
    rx1340_cur."!cursor_pos"(rx1340_pos)
    $P10 = rx1340_cur."statement_mod_cond"()
    unless $P10, rx1340_fail
    rx1340_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_cond")
    rx1340_pos = $P10."pos"()
  # rx rxquantr1350 ** 0..1
    set_addr $I10, rxquantr1350_done
    rx1340_cur."!mark_push"(0, rx1340_pos, $I10)
  rxquantr1350_loop:
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx1340_cur."!cursor_pos"(rx1340_pos)
    $P10 = rx1340_cur."statement_mod_loop"()
    unless $P10, rx1340_fail
    goto rxsubrule1351_pass
  rxsubrule1351_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1340_fail
  rxsubrule1351_pass:
    set_addr $I10, rxsubrule1351_back
    rx1340_cur."!mark_push"(0, rx1340_pos, $I10, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx1340_pos = $P10."pos"()
    set_addr $I10, rxquantr1350_done
    (rx1340_rep) = rx1340_cur."!mark_commit"($I10)
  rxquantr1350_done:
    goto alt1349_end
  alt1349_2:
.annotate 'line', 564
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx1340_cur."!cursor_pos"(rx1340_pos)
    $P10 = rx1340_cur."statement_mod_loop"()
    unless $P10, rx1340_fail
    rx1340_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx1340_pos = $P10."pos"()
  alt1349_end:
.annotate 'line', 565
    set_addr $I10, rxquantr1348_done
    (rx1340_rep) = rx1340_cur."!mark_commit"($I10)
  rxquantr1348_done:
  alt1347_end:
.annotate 'line', 556
  # rx pass
    rx1340_cur."!cursor_pass"(rx1340_pos, "statement")
    if_null rx1340_debug, debug_928
    rx1340_cur."!cursor_debug"("PASS", "statement", " at pos=", rx1340_pos)
  debug_928:
    .return (rx1340_cur)
  rx1340_restart:
.annotate 'line', 435
    if_null rx1340_debug, debug_929
    rx1340_cur."!cursor_debug"("NEXT", "statement")
  debug_929:
  rx1340_fail:
    (rx1340_rep, rx1340_pos, $I10, $P10) = rx1340_cur."!mark_fail"(0)
    lt rx1340_pos, -1, rx1340_done
    eq rx1340_pos, -1, rx1340_fail
    jump $I10
  rx1340_done:
    rx1340_cur."!cursor_fail"()
    if_null rx1340_debug, debug_930
    rx1340_cur."!cursor_debug"("FAIL", "statement")
  debug_930:
    .return (rx1340_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1342"  :anon :subid("63_1310110678.31883") :method :outer("62_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 557
    .local string rx1344_tgt
    .local int rx1344_pos
    .local int rx1344_off
    .local int rx1344_eos
    .local int rx1344_rep
    .local pmc rx1344_cur
    .local pmc rx1344_debug
    (rx1344_cur, rx1344_pos, rx1344_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1344_cur
    .local pmc match
    .lex "$/", match
    length rx1344_eos, rx1344_tgt
    gt rx1344_pos, rx1344_eos, rx1344_done
    set rx1344_off, 0
    lt rx1344_pos, 2, rx1344_start
    sub rx1344_off, rx1344_pos, 1
    substr rx1344_tgt, rx1344_tgt, rx1344_off
  rx1344_start:
    eq $I10, 1, rx1344_restart
    if_null rx1344_debug, debug_924
    rx1344_cur."!cursor_debug"("START", "")
  debug_924:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1345_done
    goto rxscan1345_scan
  rxscan1345_loop:
    (rx1344_pos) = rx1344_cur."from"()
    inc rx1344_pos
    rx1344_cur."!cursor_from"(rx1344_pos)
    ge rx1344_pos, rx1344_eos, rxscan1345_done
  rxscan1345_scan:
    set_addr $I10, rxscan1345_loop
    rx1344_cur."!mark_push"(0, rx1344_pos, $I10)
  rxscan1345_done:
  alt1346_0:
    set_addr $I10, alt1346_1
    rx1344_cur."!mark_push"(0, rx1344_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1344_pos, rx1344_eos, rx1344_fail
    sub $I10, rx1344_pos, rx1344_off
    substr $S10, rx1344_tgt, $I10, 1
    index $I11, "])}", $S10
    lt $I11, 0, rx1344_fail
    inc rx1344_pos
    goto alt1346_end
  alt1346_1:
  # rxanchor eos
    ne rx1344_pos, rx1344_eos, rx1344_fail
  alt1346_end:
  # rx pass
    rx1344_cur."!cursor_pass"(rx1344_pos, "")
    if_null rx1344_debug, debug_925
    rx1344_cur."!cursor_debug"("PASS", "", " at pos=", rx1344_pos)
  debug_925:
    .return (rx1344_cur)
  rx1344_restart:
    if_null rx1344_debug, debug_926
    rx1344_cur."!cursor_debug"("NEXT", "")
  debug_926:
  rx1344_fail:
    (rx1344_rep, rx1344_pos, $I10, $P10) = rx1344_cur."!mark_fail"(0)
    lt rx1344_pos, -1, rx1344_done
    eq rx1344_pos, -1, rx1344_fail
    jump $I10
  rx1344_done:
    rx1344_cur."!cursor_fail"()
    if_null rx1344_debug, debug_927
    rx1344_cur."!cursor_debug"("FAIL", "")
  debug_927:
    .return (rx1344_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement"  :subid("64_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "eat_terminator"  :subid("65_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1354_tgt
    .local int rx1354_pos
    .local int rx1354_off
    .local int rx1354_eos
    .local int rx1354_rep
    .local pmc rx1354_cur
    .local pmc rx1354_debug
    (rx1354_cur, rx1354_pos, rx1354_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1354_cur
    .local pmc match
    .lex "$/", match
    length rx1354_eos, rx1354_tgt
    gt rx1354_pos, rx1354_eos, rx1354_done
    set rx1354_off, 0
    lt rx1354_pos, 2, rx1354_start
    sub rx1354_off, rx1354_pos, 1
    substr rx1354_tgt, rx1354_tgt, rx1354_off
  rx1354_start:
    eq $I10, 1, rx1354_restart
    if_null rx1354_debug, debug_931
    rx1354_cur."!cursor_debug"("START", "eat_terminator")
  debug_931:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1355_done
    goto rxscan1355_scan
  rxscan1355_loop:
    (rx1354_pos) = rx1354_cur."from"()
    inc rx1354_pos
    rx1354_cur."!cursor_from"(rx1354_pos)
    ge rx1354_pos, rx1354_eos, rxscan1355_done
  rxscan1355_scan:
    set_addr $I10, rxscan1355_loop
    rx1354_cur."!mark_push"(0, rx1354_pos, $I10)
  rxscan1355_done:
  alt1356_0:
.annotate 'line', 569
    set_addr $I10, alt1356_1
    rx1354_cur."!mark_push"(0, rx1354_pos, $I10)
.annotate 'line', 570
  # rx literal  ";"
    add $I11, rx1354_pos, 1
    gt $I11, rx1354_eos, rx1354_fail
    sub $I11, rx1354_pos, rx1354_off
    ord $I11, rx1354_tgt, $I11
    ne $I11, 59, rx1354_fail
    add rx1354_pos, 1
    goto alt1356_end
  alt1356_1:
    set_addr $I10, alt1356_2
    rx1354_cur."!mark_push"(0, rx1354_pos, $I10)
.annotate 'line', 571
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx1354_cur."!cursor_pos"(rx1354_pos)
    $P10 = rx1354_cur."MARKED"("endstmt")
    unless $P10, rx1354_fail
    goto alt1356_end
  alt1356_2:
    set_addr $I10, alt1356_3
    rx1354_cur."!mark_push"(0, rx1354_pos, $I10)
.annotate 'line', 572
  # rx subrule "terminator" subtype=zerowidth negate=
    rx1354_cur."!cursor_pos"(rx1354_pos)
    $P10 = rx1354_cur."terminator"()
    unless $P10, rx1354_fail
    goto alt1356_end
  alt1356_3:
.annotate 'line', 573
  # rxanchor eos
    ne rx1354_pos, rx1354_eos, rx1354_fail
  alt1356_end:
.annotate 'line', 569
  # rx pass
    rx1354_cur."!cursor_pass"(rx1354_pos, "eat_terminator")
    if_null rx1354_debug, debug_932
    rx1354_cur."!cursor_debug"("PASS", "eat_terminator", " at pos=", rx1354_pos)
  debug_932:
    .return (rx1354_cur)
  rx1354_restart:
.annotate 'line', 435
    if_null rx1354_debug, debug_933
    rx1354_cur."!cursor_debug"("NEXT", "eat_terminator")
  debug_933:
  rx1354_fail:
    (rx1354_rep, rx1354_pos, $I10, $P10) = rx1354_cur."!mark_fail"(0)
    lt rx1354_pos, -1, rx1354_done
    eq rx1354_pos, -1, rx1354_fail
    jump $I10
  rx1354_done:
    rx1354_cur."!cursor_fail"()
    if_null rx1354_debug, debug_934
    rx1354_cur."!cursor_debug"("FAIL", "eat_terminator")
  debug_934:
    .return (rx1354_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__eat_terminator"  :subid("66_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    new $P103, "ResizablePMCArray"
    push $P103, ""
    push $P103, ""
    push $P103, ""
    push $P103, ";"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "xblock"  :subid("67_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1359_tgt
    .local int rx1359_pos
    .local int rx1359_off
    .local int rx1359_eos
    .local int rx1359_rep
    .local pmc rx1359_cur
    .local pmc rx1359_debug
    (rx1359_cur, rx1359_pos, rx1359_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1359_cur
    .local pmc match
    .lex "$/", match
    length rx1359_eos, rx1359_tgt
    gt rx1359_pos, rx1359_eos, rx1359_done
    set rx1359_off, 0
    lt rx1359_pos, 2, rx1359_start
    sub rx1359_off, rx1359_pos, 1
    substr rx1359_tgt, rx1359_tgt, rx1359_off
  rx1359_start:
    eq $I10, 1, rx1359_restart
    if_null rx1359_debug, debug_935
    rx1359_cur."!cursor_debug"("START", "xblock")
  debug_935:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1360_done
    goto rxscan1360_scan
  rxscan1360_loop:
    (rx1359_pos) = rx1359_cur."from"()
    inc rx1359_pos
    rx1359_cur."!cursor_from"(rx1359_pos)
    ge rx1359_pos, rx1359_eos, rxscan1360_done
  rxscan1360_scan:
    set_addr $I10, rxscan1360_loop
    rx1359_cur."!mark_push"(0, rx1359_pos, $I10)
  rxscan1360_done:
.annotate 'line', 577
  # rx subrule "EXPR" subtype=capture negate=
    rx1359_cur."!cursor_pos"(rx1359_pos)
    $P10 = rx1359_cur."EXPR"()
    unless $P10, rx1359_fail
    rx1359_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1359_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1359_cur."!cursor_pos"(rx1359_pos)
    $P10 = rx1359_cur."ws"()
    unless $P10, rx1359_fail
    rx1359_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx1359_cur."!cursor_pos"(rx1359_pos)
    $P10 = rx1359_cur."pblock"()
    unless $P10, rx1359_fail
    rx1359_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx1359_pos = $P10."pos"()
.annotate 'line', 576
  # rx pass
    rx1359_cur."!cursor_pass"(rx1359_pos, "xblock")
    if_null rx1359_debug, debug_936
    rx1359_cur."!cursor_debug"("PASS", "xblock", " at pos=", rx1359_pos)
  debug_936:
    .return (rx1359_cur)
  rx1359_restart:
.annotate 'line', 435
    if_null rx1359_debug, debug_937
    rx1359_cur."!cursor_debug"("NEXT", "xblock")
  debug_937:
  rx1359_fail:
    (rx1359_rep, rx1359_pos, $I10, $P10) = rx1359_cur."!mark_fail"(0)
    lt rx1359_pos, -1, rx1359_done
    eq rx1359_pos, -1, rx1359_fail
    jump $I10
  rx1359_done:
    rx1359_cur."!cursor_fail"()
    if_null rx1359_debug, debug_938
    rx1359_cur."!cursor_debug"("FAIL", "xblock")
  debug_938:
    .return (rx1359_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__xblock"  :subid("68_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("EXPR", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pblock"  :subid("69_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1363_tgt
    .local int rx1363_pos
    .local int rx1363_off
    .local int rx1363_eos
    .local int rx1363_rep
    .local pmc rx1363_cur
    .local pmc rx1363_debug
    (rx1363_cur, rx1363_pos, rx1363_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1363_cur
    .local pmc match
    .lex "$/", match
    length rx1363_eos, rx1363_tgt
    gt rx1363_pos, rx1363_eos, rx1363_done
    set rx1363_off, 0
    lt rx1363_pos, 2, rx1363_start
    sub rx1363_off, rx1363_pos, 1
    substr rx1363_tgt, rx1363_tgt, rx1363_off
  rx1363_start:
    eq $I10, 1, rx1363_restart
    if_null rx1363_debug, debug_939
    rx1363_cur."!cursor_debug"("START", "pblock")
  debug_939:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1364_done
    goto rxscan1364_scan
  rxscan1364_loop:
    (rx1363_pos) = rx1363_cur."from"()
    inc rx1363_pos
    rx1363_cur."!cursor_from"(rx1363_pos)
    ge rx1363_pos, rx1363_eos, rxscan1364_done
  rxscan1364_scan:
    set_addr $I10, rxscan1364_loop
    rx1363_cur."!mark_push"(0, rx1363_pos, $I10)
  rxscan1364_done:
  alt1365_0:
.annotate 'line', 580
    set_addr $I10, alt1365_1
    rx1363_cur."!mark_push"(0, rx1363_pos, $I10)
.annotate 'line', 581
  # rx subrule "lambda" subtype=method negate=
    rx1363_cur."!cursor_pos"(rx1363_pos)
    $P10 = rx1363_cur."lambda"()
    unless $P10, rx1363_fail
    rx1363_pos = $P10."pos"()
.annotate 'line', 582
  # rx subrule "newpad" subtype=method negate=
    rx1363_cur."!cursor_pos"(rx1363_pos)
    $P10 = rx1363_cur."newpad"()
    unless $P10, rx1363_fail
    rx1363_pos = $P10."pos"()
.annotate 'line', 583
  # rx subrule "signature" subtype=capture negate=
    rx1363_cur."!cursor_pos"(rx1363_pos)
    $P10 = rx1363_cur."signature"()
    unless $P10, rx1363_fail
    rx1363_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx1363_pos = $P10."pos"()
.annotate 'line', 584
  # rx subrule "blockoid" subtype=capture negate=
    rx1363_cur."!cursor_pos"(rx1363_pos)
    $P10 = rx1363_cur."blockoid"()
    unless $P10, rx1363_fail
    rx1363_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx1363_pos = $P10."pos"()
.annotate 'line', 581
    goto alt1365_end
  alt1365_1:
    set_addr $I10, alt1365_2
    rx1363_cur."!mark_push"(0, rx1363_pos, $I10)
.annotate 'line', 585
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1363_pos, rx1363_off
    substr $S10, rx1363_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1363_fail
.annotate 'line', 586
  # rx subrule "newpad" subtype=method negate=
    rx1363_cur."!cursor_pos"(rx1363_pos)
    $P10 = rx1363_cur."newpad"()
    unless $P10, rx1363_fail
    rx1363_pos = $P10."pos"()
.annotate 'line', 587
  # rx subrule "blockoid" subtype=capture negate=
    rx1363_cur."!cursor_pos"(rx1363_pos)
    $P10 = rx1363_cur."blockoid"()
    unless $P10, rx1363_fail
    rx1363_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx1363_pos = $P10."pos"()
.annotate 'line', 585
    goto alt1365_end
  alt1365_2:
.annotate 'line', 588
  # rx subrule "panic" subtype=method negate=
    rx1363_cur."!cursor_pos"(rx1363_pos)
    $P10 = rx1363_cur."panic"("Missing block")
    unless $P10, rx1363_fail
    rx1363_pos = $P10."pos"()
  alt1365_end:
.annotate 'line', 580
  # rx pass
    rx1363_cur."!cursor_pass"(rx1363_pos, "pblock")
    if_null rx1363_debug, debug_940
    rx1363_cur."!cursor_debug"("PASS", "pblock", " at pos=", rx1363_pos)
  debug_940:
    .return (rx1363_cur)
  rx1363_restart:
.annotate 'line', 435
    if_null rx1363_debug, debug_941
    rx1363_cur."!cursor_debug"("NEXT", "pblock")
  debug_941:
  rx1363_fail:
    (rx1363_rep, rx1363_pos, $I10, $P10) = rx1363_cur."!mark_fail"(0)
    lt rx1363_pos, -1, rx1363_done
    eq rx1363_pos, -1, rx1363_fail
    jump $I10
  rx1363_done:
    rx1363_cur."!cursor_fail"()
    if_null rx1363_debug, debug_942
    rx1363_cur."!cursor_debug"("FAIL", "pblock")
  debug_942:
    .return (rx1363_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pblock"  :subid("70_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("panic", "")
    $P104 = self."!PREFIX__!subrule"("lambda", "")
    new $P105, "ResizablePMCArray"
    push $P105, $P103
    push $P105, "{"
    push $P105, $P104
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "lambda"  :subid("71_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1368_tgt
    .local int rx1368_pos
    .local int rx1368_off
    .local int rx1368_eos
    .local int rx1368_rep
    .local pmc rx1368_cur
    .local pmc rx1368_debug
    (rx1368_cur, rx1368_pos, rx1368_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1368_cur
    .local pmc match
    .lex "$/", match
    length rx1368_eos, rx1368_tgt
    gt rx1368_pos, rx1368_eos, rx1368_done
    set rx1368_off, 0
    lt rx1368_pos, 2, rx1368_start
    sub rx1368_off, rx1368_pos, 1
    substr rx1368_tgt, rx1368_tgt, rx1368_off
  rx1368_start:
    eq $I10, 1, rx1368_restart
    if_null rx1368_debug, debug_943
    rx1368_cur."!cursor_debug"("START", "lambda")
  debug_943:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1369_done
    goto rxscan1369_scan
  rxscan1369_loop:
    (rx1368_pos) = rx1368_cur."from"()
    inc rx1368_pos
    rx1368_cur."!cursor_from"(rx1368_pos)
    ge rx1368_pos, rx1368_eos, rxscan1369_done
  rxscan1369_scan:
    set_addr $I10, rxscan1369_loop
    rx1368_cur."!mark_push"(0, rx1368_pos, $I10)
  rxscan1369_done:
  alt1370_0:
.annotate 'line', 591
    set_addr $I10, alt1370_1
    rx1368_cur."!mark_push"(0, rx1368_pos, $I10)
  # rx literal  "->"
    add $I11, rx1368_pos, 2
    gt $I11, rx1368_eos, rx1368_fail
    sub $I11, rx1368_pos, rx1368_off
    substr $S10, rx1368_tgt, $I11, 2
    ne $S10, "->", rx1368_fail
    add rx1368_pos, 2
    goto alt1370_end
  alt1370_1:
  # rx literal  "<->"
    add $I11, rx1368_pos, 3
    gt $I11, rx1368_eos, rx1368_fail
    sub $I11, rx1368_pos, rx1368_off
    substr $S10, rx1368_tgt, $I11, 3
    ne $S10, "<->", rx1368_fail
    add rx1368_pos, 3
  alt1370_end:
  # rx pass
    rx1368_cur."!cursor_pass"(rx1368_pos, "lambda")
    if_null rx1368_debug, debug_944
    rx1368_cur."!cursor_debug"("PASS", "lambda", " at pos=", rx1368_pos)
  debug_944:
    .return (rx1368_cur)
  rx1368_restart:
.annotate 'line', 435
    if_null rx1368_debug, debug_945
    rx1368_cur."!cursor_debug"("NEXT", "lambda")
  debug_945:
  rx1368_fail:
    (rx1368_rep, rx1368_pos, $I10, $P10) = rx1368_cur."!mark_fail"(0)
    lt rx1368_pos, -1, rx1368_done
    eq rx1368_pos, -1, rx1368_fail
    jump $I10
  rx1368_done:
    rx1368_cur."!cursor_fail"()
    if_null rx1368_debug, debug_946
    rx1368_cur."!cursor_debug"("FAIL", "lambda")
  debug_946:
    .return (rx1368_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__lambda"  :subid("72_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    new $P103, "ResizablePMCArray"
    push $P103, "<->"
    push $P103, "->"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "block"  :subid("73_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1373_tgt
    .local int rx1373_pos
    .local int rx1373_off
    .local int rx1373_eos
    .local int rx1373_rep
    .local pmc rx1373_cur
    .local pmc rx1373_debug
    (rx1373_cur, rx1373_pos, rx1373_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1373_cur
    .local pmc match
    .lex "$/", match
    length rx1373_eos, rx1373_tgt
    gt rx1373_pos, rx1373_eos, rx1373_done
    set rx1373_off, 0
    lt rx1373_pos, 2, rx1373_start
    sub rx1373_off, rx1373_pos, 1
    substr rx1373_tgt, rx1373_tgt, rx1373_off
  rx1373_start:
    eq $I10, 1, rx1373_restart
    if_null rx1373_debug, debug_947
    rx1373_cur."!cursor_debug"("START", "block")
  debug_947:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1374_done
    goto rxscan1374_scan
  rxscan1374_loop:
    (rx1373_pos) = rx1373_cur."from"()
    inc rx1373_pos
    rx1373_cur."!cursor_from"(rx1373_pos)
    ge rx1373_pos, rx1373_eos, rxscan1374_done
  rxscan1374_scan:
    set_addr $I10, rxscan1374_loop
    rx1373_cur."!mark_push"(0, rx1373_pos, $I10)
  rxscan1374_done:
  alt1375_0:
.annotate 'line', 594
    set_addr $I10, alt1375_1
    rx1373_cur."!mark_push"(0, rx1373_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1373_pos, rx1373_off
    substr $S10, rx1373_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1373_fail
    goto alt1375_end
  alt1375_1:
  # rx subrule "panic" subtype=method negate=
    rx1373_cur."!cursor_pos"(rx1373_pos)
    $P10 = rx1373_cur."panic"("Missing block")
    unless $P10, rx1373_fail
    rx1373_pos = $P10."pos"()
  alt1375_end:
.annotate 'line', 595
  # rx subrule "newpad" subtype=method negate=
    rx1373_cur."!cursor_pos"(rx1373_pos)
    $P10 = rx1373_cur."newpad"()
    unless $P10, rx1373_fail
    rx1373_pos = $P10."pos"()
.annotate 'line', 596
  # rx subrule "blockoid" subtype=capture negate=
    rx1373_cur."!cursor_pos"(rx1373_pos)
    $P10 = rx1373_cur."blockoid"()
    unless $P10, rx1373_fail
    rx1373_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx1373_pos = $P10."pos"()
.annotate 'line', 593
  # rx pass
    rx1373_cur."!cursor_pass"(rx1373_pos, "block")
    if_null rx1373_debug, debug_948
    rx1373_cur."!cursor_debug"("PASS", "block", " at pos=", rx1373_pos)
  debug_948:
    .return (rx1373_cur)
  rx1373_restart:
.annotate 'line', 435
    if_null rx1373_debug, debug_949
    rx1373_cur."!cursor_debug"("NEXT", "block")
  debug_949:
  rx1373_fail:
    (rx1373_rep, rx1373_pos, $I10, $P10) = rx1373_cur."!mark_fail"(0)
    lt rx1373_pos, -1, rx1373_done
    eq rx1373_pos, -1, rx1373_fail
    jump $I10
  rx1373_done:
    rx1373_cur."!cursor_fail"()
    if_null rx1373_debug, debug_950
    rx1373_cur."!cursor_debug"("FAIL", "block")
  debug_950:
    .return (rx1373_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__block"  :subid("74_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("panic", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    push $P104, "{"
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blockoid"  :subid("75_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1378_tgt
    .local int rx1378_pos
    .local int rx1378_off
    .local int rx1378_eos
    .local int rx1378_rep
    .local pmc rx1378_cur
    .local pmc rx1378_debug
    (rx1378_cur, rx1378_pos, rx1378_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1378_cur
    .local pmc match
    .lex "$/", match
    length rx1378_eos, rx1378_tgt
    gt rx1378_pos, rx1378_eos, rx1378_done
    set rx1378_off, 0
    lt rx1378_pos, 2, rx1378_start
    sub rx1378_off, rx1378_pos, 1
    substr rx1378_tgt, rx1378_tgt, rx1378_off
  rx1378_start:
    eq $I10, 1, rx1378_restart
    if_null rx1378_debug, debug_951
    rx1378_cur."!cursor_debug"("START", "blockoid")
  debug_951:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1379_done
    goto rxscan1379_scan
  rxscan1379_loop:
    (rx1378_pos) = rx1378_cur."from"()
    inc rx1378_pos
    rx1378_cur."!cursor_from"(rx1378_pos)
    ge rx1378_pos, rx1378_eos, rxscan1379_done
  rxscan1379_scan:
    set_addr $I10, rxscan1379_loop
    rx1378_cur."!mark_push"(0, rx1378_pos, $I10)
  rxscan1379_done:
.annotate 'line', 600
  # rx subrule "finishpad" subtype=method negate=
    rx1378_cur."!cursor_pos"(rx1378_pos)
    $P10 = rx1378_cur."finishpad"()
    unless $P10, rx1378_fail
    rx1378_pos = $P10."pos"()
  alt1380_0:
.annotate 'line', 601
    set_addr $I10, alt1380_1
    rx1378_cur."!mark_push"(0, rx1378_pos, $I10)
.annotate 'line', 602
  # rx literal  "{YOU_ARE_HERE}"
    add $I11, rx1378_pos, 14
    gt $I11, rx1378_eos, rx1378_fail
    sub $I11, rx1378_pos, rx1378_off
    substr $S10, rx1378_tgt, $I11, 14
    ne $S10, "{YOU_ARE_HERE}", rx1378_fail
    add rx1378_pos, 14
  # rx subrule "you_are_here" subtype=capture negate=
    rx1378_cur."!cursor_pos"(rx1378_pos)
    $P10 = rx1378_cur."you_are_here"()
    unless $P10, rx1378_fail
    rx1378_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("you_are_here")
    rx1378_pos = $P10."pos"()
    goto alt1380_end
  alt1380_1:
.annotate 'line', 603
  # rx literal  "{"
    add $I11, rx1378_pos, 1
    gt $I11, rx1378_eos, rx1378_fail
    sub $I11, rx1378_pos, rx1378_off
    ord $I11, rx1378_tgt, $I11
    ne $I11, 123, rx1378_fail
    add rx1378_pos, 1
  # rx subrule "statementlist" subtype=capture negate=
    rx1378_cur."!cursor_pos"(rx1378_pos)
    $P10 = rx1378_cur."statementlist"()
    unless $P10, rx1378_fail
    rx1378_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx1378_pos = $P10."pos"()
  alt1381_0:
    set_addr $I10, alt1381_1
    rx1378_cur."!mark_push"(0, rx1378_pos, $I10)
  # rx literal  "}"
    add $I11, rx1378_pos, 1
    gt $I11, rx1378_eos, rx1378_fail
    sub $I11, rx1378_pos, rx1378_off
    ord $I11, rx1378_tgt, $I11
    ne $I11, 125, rx1378_fail
    add rx1378_pos, 1
    goto alt1381_end
  alt1381_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx1378_cur."!cursor_pos"(rx1378_pos)
    $P10 = rx1378_cur."FAILGOAL"("'}'")
    unless $P10, rx1378_fail
    goto rxsubrule1382_pass
  rxsubrule1382_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1378_fail
  rxsubrule1382_pass:
    set_addr $I10, rxsubrule1382_back
    rx1378_cur."!mark_push"(0, rx1378_pos, $I10, $P10)
    rx1378_pos = $P10."pos"()
  alt1381_end:
  alt1380_end:
.annotate 'line', 605
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1378_cur."!cursor_pos"(rx1378_pos)
    $P10 = rx1378_cur."ENDSTMT"()
    unless $P10, rx1378_fail
.annotate 'line', 599
  # rx pass
    rx1378_cur."!cursor_pass"(rx1378_pos, "blockoid")
    if_null rx1378_debug, debug_952
    rx1378_cur."!cursor_debug"("PASS", "blockoid", " at pos=", rx1378_pos)
  debug_952:
    .return (rx1378_cur)
  rx1378_restart:
.annotate 'line', 435
    if_null rx1378_debug, debug_953
    rx1378_cur."!cursor_debug"("NEXT", "blockoid")
  debug_953:
  rx1378_fail:
    (rx1378_rep, rx1378_pos, $I10, $P10) = rx1378_cur."!mark_fail"(0)
    lt rx1378_pos, -1, rx1378_done
    eq rx1378_pos, -1, rx1378_fail
    jump $I10
  rx1378_done:
    rx1378_cur."!cursor_fail"()
    if_null rx1378_debug, debug_954
    rx1378_cur."!cursor_debug"("FAIL", "blockoid")
  debug_954:
    .return (rx1378_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blockoid"  :subid("76_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P104 = self."!PREFIX__!subrule"("finishpad", "")
    new $P105, "ResizablePMCArray"
    push $P105, $P104
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "newpad"  :subid("77_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1385_tgt
    .local int rx1385_pos
    .local int rx1385_off
    .local int rx1385_eos
    .local int rx1385_rep
    .local pmc rx1385_cur
    .local pmc rx1385_debug
    (rx1385_cur, rx1385_pos, rx1385_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1385_cur
    .local pmc match
    .lex "$/", match
    length rx1385_eos, rx1385_tgt
    gt rx1385_pos, rx1385_eos, rx1385_done
    set rx1385_off, 0
    lt rx1385_pos, 2, rx1385_start
    sub rx1385_off, rx1385_pos, 1
    substr rx1385_tgt, rx1385_tgt, rx1385_off
  rx1385_start:
    eq $I10, 1, rx1385_restart
    if_null rx1385_debug, debug_955
    rx1385_cur."!cursor_debug"("START", "newpad")
  debug_955:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1386_done
    goto rxscan1386_scan
  rxscan1386_loop:
    (rx1385_pos) = rx1385_cur."from"()
    inc rx1385_pos
    rx1385_cur."!cursor_from"(rx1385_pos)
    ge rx1385_pos, rx1385_eos, rxscan1386_done
  rxscan1386_scan:
    set_addr $I10, rxscan1386_loop
    rx1385_cur."!mark_push"(0, rx1385_pos, $I10)
  rxscan1386_done:
.annotate 'line', 608
  # rx pass
    rx1385_cur."!cursor_pass"(rx1385_pos, "newpad")
    if_null rx1385_debug, debug_956
    rx1385_cur."!cursor_debug"("PASS", "newpad", " at pos=", rx1385_pos)
  debug_956:
    .return (rx1385_cur)
  rx1385_restart:
.annotate 'line', 435
    if_null rx1385_debug, debug_957
    rx1385_cur."!cursor_debug"("NEXT", "newpad")
  debug_957:
  rx1385_fail:
    (rx1385_rep, rx1385_pos, $I10, $P10) = rx1385_cur."!mark_fail"(0)
    lt rx1385_pos, -1, rx1385_done
    eq rx1385_pos, -1, rx1385_fail
    jump $I10
  rx1385_done:
    rx1385_cur."!cursor_fail"()
    if_null rx1385_debug, debug_958
    rx1385_cur."!cursor_debug"("FAIL", "newpad")
  debug_958:
    .return (rx1385_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__newpad"  :subid("78_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "outerctx"  :subid("79_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1389_tgt
    .local int rx1389_pos
    .local int rx1389_off
    .local int rx1389_eos
    .local int rx1389_rep
    .local pmc rx1389_cur
    .local pmc rx1389_debug
    (rx1389_cur, rx1389_pos, rx1389_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1389_cur
    .local pmc match
    .lex "$/", match
    length rx1389_eos, rx1389_tgt
    gt rx1389_pos, rx1389_eos, rx1389_done
    set rx1389_off, 0
    lt rx1389_pos, 2, rx1389_start
    sub rx1389_off, rx1389_pos, 1
    substr rx1389_tgt, rx1389_tgt, rx1389_off
  rx1389_start:
    eq $I10, 1, rx1389_restart
    if_null rx1389_debug, debug_959
    rx1389_cur."!cursor_debug"("START", "outerctx")
  debug_959:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1390_done
    goto rxscan1390_scan
  rxscan1390_loop:
    (rx1389_pos) = rx1389_cur."from"()
    inc rx1389_pos
    rx1389_cur."!cursor_from"(rx1389_pos)
    ge rx1389_pos, rx1389_eos, rxscan1390_done
  rxscan1390_scan:
    set_addr $I10, rxscan1390_loop
    rx1389_cur."!mark_push"(0, rx1389_pos, $I10)
  rxscan1390_done:
.annotate 'line', 609
  # rx pass
    rx1389_cur."!cursor_pass"(rx1389_pos, "outerctx")
    if_null rx1389_debug, debug_960
    rx1389_cur."!cursor_debug"("PASS", "outerctx", " at pos=", rx1389_pos)
  debug_960:
    .return (rx1389_cur)
  rx1389_restart:
.annotate 'line', 435
    if_null rx1389_debug, debug_961
    rx1389_cur."!cursor_debug"("NEXT", "outerctx")
  debug_961:
  rx1389_fail:
    (rx1389_rep, rx1389_pos, $I10, $P10) = rx1389_cur."!mark_fail"(0)
    lt rx1389_pos, -1, rx1389_done
    eq rx1389_pos, -1, rx1389_fail
    jump $I10
  rx1389_done:
    rx1389_cur."!cursor_fail"()
    if_null rx1389_debug, debug_962
    rx1389_cur."!cursor_debug"("FAIL", "outerctx")
  debug_962:
    .return (rx1389_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__outerctx"  :subid("80_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "GLOBALish"  :subid("81_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1393_tgt
    .local int rx1393_pos
    .local int rx1393_off
    .local int rx1393_eos
    .local int rx1393_rep
    .local pmc rx1393_cur
    .local pmc rx1393_debug
    (rx1393_cur, rx1393_pos, rx1393_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1393_cur
    .local pmc match
    .lex "$/", match
    length rx1393_eos, rx1393_tgt
    gt rx1393_pos, rx1393_eos, rx1393_done
    set rx1393_off, 0
    lt rx1393_pos, 2, rx1393_start
    sub rx1393_off, rx1393_pos, 1
    substr rx1393_tgt, rx1393_tgt, rx1393_off
  rx1393_start:
    eq $I10, 1, rx1393_restart
    if_null rx1393_debug, debug_963
    rx1393_cur."!cursor_debug"("START", "GLOBALish")
  debug_963:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1394_done
    goto rxscan1394_scan
  rxscan1394_loop:
    (rx1393_pos) = rx1393_cur."from"()
    inc rx1393_pos
    rx1393_cur."!cursor_from"(rx1393_pos)
    ge rx1393_pos, rx1393_eos, rxscan1394_done
  rxscan1394_scan:
    set_addr $I10, rxscan1394_loop
    rx1393_cur."!mark_push"(0, rx1393_pos, $I10)
  rxscan1394_done:
.annotate 'line', 610
  # rx pass
    rx1393_cur."!cursor_pass"(rx1393_pos, "GLOBALish")
    if_null rx1393_debug, debug_964
    rx1393_cur."!cursor_debug"("PASS", "GLOBALish", " at pos=", rx1393_pos)
  debug_964:
    .return (rx1393_cur)
  rx1393_restart:
.annotate 'line', 435
    if_null rx1393_debug, debug_965
    rx1393_cur."!cursor_debug"("NEXT", "GLOBALish")
  debug_965:
  rx1393_fail:
    (rx1393_rep, rx1393_pos, $I10, $P10) = rx1393_cur."!mark_fail"(0)
    lt rx1393_pos, -1, rx1393_done
    eq rx1393_pos, -1, rx1393_fail
    jump $I10
  rx1393_done:
    rx1393_cur."!cursor_fail"()
    if_null rx1393_debug, debug_966
    rx1393_cur."!cursor_debug"("FAIL", "GLOBALish")
  debug_966:
    .return (rx1393_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__GLOBALish"  :subid("82_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "finishpad"  :subid("83_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1397_tgt
    .local int rx1397_pos
    .local int rx1397_off
    .local int rx1397_eos
    .local int rx1397_rep
    .local pmc rx1397_cur
    .local pmc rx1397_debug
    (rx1397_cur, rx1397_pos, rx1397_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1397_cur
    .local pmc match
    .lex "$/", match
    length rx1397_eos, rx1397_tgt
    gt rx1397_pos, rx1397_eos, rx1397_done
    set rx1397_off, 0
    lt rx1397_pos, 2, rx1397_start
    sub rx1397_off, rx1397_pos, 1
    substr rx1397_tgt, rx1397_tgt, rx1397_off
  rx1397_start:
    eq $I10, 1, rx1397_restart
    if_null rx1397_debug, debug_967
    rx1397_cur."!cursor_debug"("START", "finishpad")
  debug_967:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1398_done
    goto rxscan1398_scan
  rxscan1398_loop:
    (rx1397_pos) = rx1397_cur."from"()
    inc rx1397_pos
    rx1397_cur."!cursor_from"(rx1397_pos)
    ge rx1397_pos, rx1397_eos, rxscan1398_done
  rxscan1398_scan:
    set_addr $I10, rxscan1398_loop
    rx1397_cur."!mark_push"(0, rx1397_pos, $I10)
  rxscan1398_done:
.annotate 'line', 611
  # rx pass
    rx1397_cur."!cursor_pass"(rx1397_pos, "finishpad")
    if_null rx1397_debug, debug_968
    rx1397_cur."!cursor_debug"("PASS", "finishpad", " at pos=", rx1397_pos)
  debug_968:
    .return (rx1397_cur)
  rx1397_restart:
.annotate 'line', 435
    if_null rx1397_debug, debug_969
    rx1397_cur."!cursor_debug"("NEXT", "finishpad")
  debug_969:
  rx1397_fail:
    (rx1397_rep, rx1397_pos, $I10, $P10) = rx1397_cur."!mark_fail"(0)
    lt rx1397_pos, -1, rx1397_done
    eq rx1397_pos, -1, rx1397_fail
    jump $I10
  rx1397_done:
    rx1397_cur."!cursor_fail"()
    if_null rx1397_debug, debug_970
    rx1397_cur."!cursor_debug"("FAIL", "finishpad")
  debug_970:
    .return (rx1397_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__finishpad"  :subid("84_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "you_are_here"  :subid("85_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1401_tgt
    .local int rx1401_pos
    .local int rx1401_off
    .local int rx1401_eos
    .local int rx1401_rep
    .local pmc rx1401_cur
    .local pmc rx1401_debug
    (rx1401_cur, rx1401_pos, rx1401_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1401_cur
    .local pmc match
    .lex "$/", match
    length rx1401_eos, rx1401_tgt
    gt rx1401_pos, rx1401_eos, rx1401_done
    set rx1401_off, 0
    lt rx1401_pos, 2, rx1401_start
    sub rx1401_off, rx1401_pos, 1
    substr rx1401_tgt, rx1401_tgt, rx1401_off
  rx1401_start:
    eq $I10, 1, rx1401_restart
    if_null rx1401_debug, debug_971
    rx1401_cur."!cursor_debug"("START", "you_are_here")
  debug_971:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1402_done
    goto rxscan1402_scan
  rxscan1402_loop:
    (rx1401_pos) = rx1401_cur."from"()
    inc rx1401_pos
    rx1401_cur."!cursor_from"(rx1401_pos)
    ge rx1401_pos, rx1401_eos, rxscan1402_done
  rxscan1402_scan:
    set_addr $I10, rxscan1402_loop
    rx1401_cur."!mark_push"(0, rx1401_pos, $I10)
  rxscan1402_done:
.annotate 'line', 612
  # rx pass
    rx1401_cur."!cursor_pass"(rx1401_pos, "you_are_here")
    if_null rx1401_debug, debug_972
    rx1401_cur."!cursor_debug"("PASS", "you_are_here", " at pos=", rx1401_pos)
  debug_972:
    .return (rx1401_cur)
  rx1401_restart:
.annotate 'line', 435
    if_null rx1401_debug, debug_973
    rx1401_cur."!cursor_debug"("NEXT", "you_are_here")
  debug_973:
  rx1401_fail:
    (rx1401_rep, rx1401_pos, $I10, $P10) = rx1401_cur."!mark_fail"(0)
    lt rx1401_pos, -1, rx1401_done
    eq rx1401_pos, -1, rx1401_fail
    jump $I10
  rx1401_done:
    rx1401_cur."!cursor_fail"()
    if_null rx1401_debug, debug_974
    rx1401_cur."!cursor_debug"("FAIL", "you_are_here")
  debug_974:
    .return (rx1401_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__you_are_here"  :subid("86_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator"  :subid("87_1310110678.31883")
    .param pmc param_1405
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 614
    .lex "self", param_1405
    $P103 = param_1405."!protoregex"("terminator")
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator"  :subid("88_1310110678.31883")
    .param pmc param_1407
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 614
    .lex "self", param_1407
    $P104 = param_1407."!PREFIX__!protoregex"("terminator")
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<;>"  :subid("89_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1409_tgt
    .local int rx1409_pos
    .local int rx1409_off
    .local int rx1409_eos
    .local int rx1409_rep
    .local pmc rx1409_cur
    .local pmc rx1409_debug
    (rx1409_cur, rx1409_pos, rx1409_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1409_cur
    .local pmc match
    .lex "$/", match
    length rx1409_eos, rx1409_tgt
    gt rx1409_pos, rx1409_eos, rx1409_done
    set rx1409_off, 0
    lt rx1409_pos, 2, rx1409_start
    sub rx1409_off, rx1409_pos, 1
    substr rx1409_tgt, rx1409_tgt, rx1409_off
  rx1409_start:
    eq $I10, 1, rx1409_restart
    if_null rx1409_debug, debug_975
    rx1409_cur."!cursor_debug"("START", "terminator:sym<;>")
  debug_975:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1410_done
    goto rxscan1410_scan
  rxscan1410_loop:
    (rx1409_pos) = rx1409_cur."from"()
    inc rx1409_pos
    rx1409_cur."!cursor_from"(rx1409_pos)
    ge rx1409_pos, rx1409_eos, rxscan1410_done
  rxscan1410_scan:
    set_addr $I10, rxscan1410_loop
    rx1409_cur."!mark_push"(0, rx1409_pos, $I10)
  rxscan1410_done:
.annotate 'line', 616
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1409_pos, rx1409_off
    substr $S10, rx1409_tgt, $I10, 1
    index $I11, ";", $S10
    lt $I11, 0, rx1409_fail
  # rx pass
    rx1409_cur."!cursor_pass"(rx1409_pos, "terminator:sym<;>")
    if_null rx1409_debug, debug_976
    rx1409_cur."!cursor_debug"("PASS", "terminator:sym<;>", " at pos=", rx1409_pos)
  debug_976:
    .return (rx1409_cur)
  rx1409_restart:
.annotate 'line', 435
    if_null rx1409_debug, debug_977
    rx1409_cur."!cursor_debug"("NEXT", "terminator:sym<;>")
  debug_977:
  rx1409_fail:
    (rx1409_rep, rx1409_pos, $I10, $P10) = rx1409_cur."!mark_fail"(0)
    lt rx1409_pos, -1, rx1409_done
    eq rx1409_pos, -1, rx1409_fail
    jump $I10
  rx1409_done:
    rx1409_cur."!cursor_fail"()
    if_null rx1409_debug, debug_978
    rx1409_cur."!cursor_debug"("FAIL", "terminator:sym<;>")
  debug_978:
    .return (rx1409_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<;>"  :subid("90_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    new $P103, "ResizablePMCArray"
    push $P103, ";"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<}>"  :subid("91_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1413_tgt
    .local int rx1413_pos
    .local int rx1413_off
    .local int rx1413_eos
    .local int rx1413_rep
    .local pmc rx1413_cur
    .local pmc rx1413_debug
    (rx1413_cur, rx1413_pos, rx1413_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1413_cur
    .local pmc match
    .lex "$/", match
    length rx1413_eos, rx1413_tgt
    gt rx1413_pos, rx1413_eos, rx1413_done
    set rx1413_off, 0
    lt rx1413_pos, 2, rx1413_start
    sub rx1413_off, rx1413_pos, 1
    substr rx1413_tgt, rx1413_tgt, rx1413_off
  rx1413_start:
    eq $I10, 1, rx1413_restart
    if_null rx1413_debug, debug_979
    rx1413_cur."!cursor_debug"("START", "terminator:sym<}>")
  debug_979:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1414_done
    goto rxscan1414_scan
  rxscan1414_loop:
    (rx1413_pos) = rx1413_cur."from"()
    inc rx1413_pos
    rx1413_cur."!cursor_from"(rx1413_pos)
    ge rx1413_pos, rx1413_eos, rxscan1414_done
  rxscan1414_scan:
    set_addr $I10, rxscan1414_loop
    rx1413_cur."!mark_push"(0, rx1413_pos, $I10)
  rxscan1414_done:
.annotate 'line', 617
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1413_pos, rx1413_off
    substr $S10, rx1413_tgt, $I10, 1
    index $I11, "}", $S10
    lt $I11, 0, rx1413_fail
  # rx pass
    rx1413_cur."!cursor_pass"(rx1413_pos, "terminator:sym<}>")
    if_null rx1413_debug, debug_980
    rx1413_cur."!cursor_debug"("PASS", "terminator:sym<}>", " at pos=", rx1413_pos)
  debug_980:
    .return (rx1413_cur)
  rx1413_restart:
.annotate 'line', 435
    if_null rx1413_debug, debug_981
    rx1413_cur."!cursor_debug"("NEXT", "terminator:sym<}>")
  debug_981:
  rx1413_fail:
    (rx1413_rep, rx1413_pos, $I10, $P10) = rx1413_cur."!mark_fail"(0)
    lt rx1413_pos, -1, rx1413_done
    eq rx1413_pos, -1, rx1413_fail
    jump $I10
  rx1413_done:
    rx1413_cur."!cursor_fail"()
    if_null rx1413_debug, debug_982
    rx1413_cur."!cursor_debug"("FAIL", "terminator:sym<}>")
  debug_982:
    .return (rx1413_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<}>"  :subid("92_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    new $P103, "ResizablePMCArray"
    push $P103, "}"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control"  :subid("93_1310110678.31883")
    .param pmc param_1417
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 621
    .lex "self", param_1417
    $P103 = param_1417."!protoregex"("statement_control")
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control"  :subid("94_1310110678.31883")
    .param pmc param_1419
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 621
    .lex "self", param_1419
    $P104 = param_1419."!PREFIX__!protoregex"("statement_control")
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<use>"  :subid("95_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1421_tgt
    .local int rx1421_pos
    .local int rx1421_off
    .local int rx1421_eos
    .local int rx1421_rep
    .local pmc rx1421_cur
    .local pmc rx1421_debug
    (rx1421_cur, rx1421_pos, rx1421_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1421_cur
    .local pmc match
    .lex "$/", match
    length rx1421_eos, rx1421_tgt
    gt rx1421_pos, rx1421_eos, rx1421_done
    set rx1421_off, 0
    lt rx1421_pos, 2, rx1421_start
    sub rx1421_off, rx1421_pos, 1
    substr rx1421_tgt, rx1421_tgt, rx1421_off
  rx1421_start:
    eq $I10, 1, rx1421_restart
    if_null rx1421_debug, debug_983
    rx1421_cur."!cursor_debug"("START", "statement_control:sym<use>")
  debug_983:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1422_done
    goto rxscan1422_scan
  rxscan1422_loop:
    (rx1421_pos) = rx1421_cur."from"()
    inc rx1421_pos
    rx1421_cur."!cursor_from"(rx1421_pos)
    ge rx1421_pos, rx1421_eos, rxscan1422_done
  rxscan1422_scan:
    set_addr $I10, rxscan1422_loop
    rx1421_cur."!mark_push"(0, rx1421_pos, $I10)
  rxscan1422_done:
.annotate 'line', 624
  # rx subcapture "sym"
    set_addr $I10, rxcap_1423_fail
    rx1421_cur."!mark_push"(0, rx1421_pos, $I10)
  # rx literal  "use"
    add $I11, rx1421_pos, 3
    gt $I11, rx1421_eos, rx1421_fail
    sub $I11, rx1421_pos, rx1421_off
    substr $S10, rx1421_tgt, $I11, 3
    ne $S10, "use", rx1421_fail
    add rx1421_pos, 3
    set_addr $I10, rxcap_1423_fail
    ($I12, $I11) = rx1421_cur."!mark_peek"($I10)
    rx1421_cur."!cursor_pos"($I11)
    ($P10) = rx1421_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1421_pos, "")
    rx1421_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1423_done
  rxcap_1423_fail:
    goto rx1421_fail
  rxcap_1423_done:
  # rx charclass s
    ge rx1421_pos, rx1421_eos, rx1421_fail
    sub $I10, rx1421_pos, rx1421_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1421_tgt, $I10
    unless $I11, rx1421_fail
    inc rx1421_pos
  # rx subrule "ws" subtype=method negate=
    rx1421_cur."!cursor_pos"(rx1421_pos)
    $P10 = rx1421_cur."ws"()
    unless $P10, rx1421_fail
    rx1421_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx1421_cur."!cursor_pos"(rx1421_pos)
    $P10 = rx1421_cur."name"()
    unless $P10, rx1421_fail
    rx1421_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1421_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1421_cur."!cursor_pos"(rx1421_pos)
    $P10 = rx1421_cur."ws"()
    unless $P10, rx1421_fail
    rx1421_pos = $P10."pos"()
.annotate 'line', 623
  # rx pass
    rx1421_cur."!cursor_pass"(rx1421_pos, "statement_control:sym<use>")
    if_null rx1421_debug, debug_984
    rx1421_cur."!cursor_debug"("PASS", "statement_control:sym<use>", " at pos=", rx1421_pos)
  debug_984:
    .return (rx1421_cur)
  rx1421_restart:
.annotate 'line', 435
    if_null rx1421_debug, debug_985
    rx1421_cur."!cursor_debug"("NEXT", "statement_control:sym<use>")
  debug_985:
  rx1421_fail:
    (rx1421_rep, rx1421_pos, $I10, $P10) = rx1421_cur."!mark_fail"(0)
    lt rx1421_pos, -1, rx1421_done
    eq rx1421_pos, -1, rx1421_fail
    jump $I10
  rx1421_done:
    rx1421_cur."!cursor_fail"()
    if_null rx1421_debug, debug_986
    rx1421_cur."!cursor_debug"("FAIL", "statement_control:sym<use>")
  debug_986:
    .return (rx1421_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<use>"  :subid("96_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    new $P105, "ResizablePMCArray"
    push $P105, "use"
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<if>"  :subid("97_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1426_tgt
    .local int rx1426_pos
    .local int rx1426_off
    .local int rx1426_eos
    .local int rx1426_rep
    .local pmc rx1426_cur
    .local pmc rx1426_debug
    (rx1426_cur, rx1426_pos, rx1426_tgt, $I10) = self."!cursor_start"()
    rx1426_cur."!cursor_caparray"("xblock", "else")
    .lex unicode:"$\x{a2}", rx1426_cur
    .local pmc match
    .lex "$/", match
    length rx1426_eos, rx1426_tgt
    gt rx1426_pos, rx1426_eos, rx1426_done
    set rx1426_off, 0
    lt rx1426_pos, 2, rx1426_start
    sub rx1426_off, rx1426_pos, 1
    substr rx1426_tgt, rx1426_tgt, rx1426_off
  rx1426_start:
    eq $I10, 1, rx1426_restart
    if_null rx1426_debug, debug_987
    rx1426_cur."!cursor_debug"("START", "statement_control:sym<if>")
  debug_987:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1427_done
    goto rxscan1427_scan
  rxscan1427_loop:
    (rx1426_pos) = rx1426_cur."from"()
    inc rx1426_pos
    rx1426_cur."!cursor_from"(rx1426_pos)
    ge rx1426_pos, rx1426_eos, rxscan1427_done
  rxscan1427_scan:
    set_addr $I10, rxscan1427_loop
    rx1426_cur."!mark_push"(0, rx1426_pos, $I10)
  rxscan1427_done:
.annotate 'line', 628
  # rx subcapture "sym"
    set_addr $I10, rxcap_1428_fail
    rx1426_cur."!mark_push"(0, rx1426_pos, $I10)
  # rx literal  "if"
    add $I11, rx1426_pos, 2
    gt $I11, rx1426_eos, rx1426_fail
    sub $I11, rx1426_pos, rx1426_off
    substr $S10, rx1426_tgt, $I11, 2
    ne $S10, "if", rx1426_fail
    add rx1426_pos, 2
    set_addr $I10, rxcap_1428_fail
    ($I12, $I11) = rx1426_cur."!mark_peek"($I10)
    rx1426_cur."!cursor_pos"($I11)
    ($P10) = rx1426_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1426_pos, "")
    rx1426_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1428_done
  rxcap_1428_fail:
    goto rx1426_fail
  rxcap_1428_done:
  # rx charclass s
    ge rx1426_pos, rx1426_eos, rx1426_fail
    sub $I10, rx1426_pos, rx1426_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1426_tgt, $I10
    unless $I11, rx1426_fail
    inc rx1426_pos
  # rx subrule "ws" subtype=method negate=
    rx1426_cur."!cursor_pos"(rx1426_pos)
    $P10 = rx1426_cur."ws"()
    unless $P10, rx1426_fail
    rx1426_pos = $P10."pos"()
.annotate 'line', 629
  # rx subrule "xblock" subtype=capture negate=
    rx1426_cur."!cursor_pos"(rx1426_pos)
    $P10 = rx1426_cur."xblock"()
    unless $P10, rx1426_fail
    rx1426_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx1426_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1426_cur."!cursor_pos"(rx1426_pos)
    $P10 = rx1426_cur."ws"()
    unless $P10, rx1426_fail
    rx1426_pos = $P10."pos"()
.annotate 'line', 630
  # rx rxquantr1429 ** 0..*
    set_addr $I10, rxquantr1429_done
    rx1426_cur."!mark_push"(0, rx1426_pos, $I10)
  rxquantr1429_loop:
  # rx subrule "ws" subtype=method negate=
    rx1426_cur."!cursor_pos"(rx1426_pos)
    $P10 = rx1426_cur."ws"()
    unless $P10, rx1426_fail
    rx1426_pos = $P10."pos"()
  # rx literal  "elsif"
    add $I11, rx1426_pos, 5
    gt $I11, rx1426_eos, rx1426_fail
    sub $I11, rx1426_pos, rx1426_off
    substr $S10, rx1426_tgt, $I11, 5
    ne $S10, "elsif", rx1426_fail
    add rx1426_pos, 5
  # rx charclass s
    ge rx1426_pos, rx1426_eos, rx1426_fail
    sub $I10, rx1426_pos, rx1426_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1426_tgt, $I10
    unless $I11, rx1426_fail
    inc rx1426_pos
  # rx subrule "ws" subtype=method negate=
    rx1426_cur."!cursor_pos"(rx1426_pos)
    $P10 = rx1426_cur."ws"()
    unless $P10, rx1426_fail
    rx1426_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx1426_cur."!cursor_pos"(rx1426_pos)
    $P10 = rx1426_cur."xblock"()
    unless $P10, rx1426_fail
    rx1426_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx1426_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1426_cur."!cursor_pos"(rx1426_pos)
    $P10 = rx1426_cur."ws"()
    unless $P10, rx1426_fail
    rx1426_pos = $P10."pos"()
    set_addr $I10, rxquantr1429_done
    (rx1426_rep) = rx1426_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1429_done
    rx1426_cur."!mark_push"(rx1426_rep, rx1426_pos, $I10)
    goto rxquantr1429_loop
  rxquantr1429_done:
  # rx subrule "ws" subtype=method negate=
    rx1426_cur."!cursor_pos"(rx1426_pos)
    $P10 = rx1426_cur."ws"()
    unless $P10, rx1426_fail
    rx1426_pos = $P10."pos"()
.annotate 'line', 631
  # rx rxquantr1430 ** 0..1
    set_addr $I10, rxquantr1430_done
    rx1426_cur."!mark_push"(0, rx1426_pos, $I10)
  rxquantr1430_loop:
  # rx subrule "ws" subtype=method negate=
    rx1426_cur."!cursor_pos"(rx1426_pos)
    $P10 = rx1426_cur."ws"()
    unless $P10, rx1426_fail
    rx1426_pos = $P10."pos"()
  # rx literal  "else"
    add $I11, rx1426_pos, 4
    gt $I11, rx1426_eos, rx1426_fail
    sub $I11, rx1426_pos, rx1426_off
    substr $S10, rx1426_tgt, $I11, 4
    ne $S10, "else", rx1426_fail
    add rx1426_pos, 4
  # rx charclass s
    ge rx1426_pos, rx1426_eos, rx1426_fail
    sub $I10, rx1426_pos, rx1426_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1426_tgt, $I10
    unless $I11, rx1426_fail
    inc rx1426_pos
  # rx subrule "ws" subtype=method negate=
    rx1426_cur."!cursor_pos"(rx1426_pos)
    $P10 = rx1426_cur."ws"()
    unless $P10, rx1426_fail
    rx1426_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx1426_cur."!cursor_pos"(rx1426_pos)
    $P10 = rx1426_cur."pblock"()
    unless $P10, rx1426_fail
    rx1426_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("else")
    rx1426_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1426_cur."!cursor_pos"(rx1426_pos)
    $P10 = rx1426_cur."ws"()
    unless $P10, rx1426_fail
    rx1426_pos = $P10."pos"()
    set_addr $I10, rxquantr1430_done
    (rx1426_rep) = rx1426_cur."!mark_commit"($I10)
  rxquantr1430_done:
  # rx subrule "ws" subtype=method negate=
    rx1426_cur."!cursor_pos"(rx1426_pos)
    $P10 = rx1426_cur."ws"()
    unless $P10, rx1426_fail
    rx1426_pos = $P10."pos"()
.annotate 'line', 627
  # rx pass
    rx1426_cur."!cursor_pass"(rx1426_pos, "statement_control:sym<if>")
    if_null rx1426_debug, debug_988
    rx1426_cur."!cursor_debug"("PASS", "statement_control:sym<if>", " at pos=", rx1426_pos)
  debug_988:
    .return (rx1426_cur)
  rx1426_restart:
.annotate 'line', 435
    if_null rx1426_debug, debug_989
    rx1426_cur."!cursor_debug"("NEXT", "statement_control:sym<if>")
  debug_989:
  rx1426_fail:
    (rx1426_rep, rx1426_pos, $I10, $P10) = rx1426_cur."!mark_fail"(0)
    lt rx1426_pos, -1, rx1426_done
    eq rx1426_pos, -1, rx1426_fail
    jump $I10
  rx1426_done:
    rx1426_cur."!cursor_fail"()
    if_null rx1426_debug, debug_990
    rx1426_cur."!cursor_debug"("FAIL", "statement_control:sym<if>")
  debug_990:
    .return (rx1426_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<if>"  :subid("98_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    new $P113, "ResizablePMCArray"
    push $P113, "if"
    .return ($P113)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<unless>"  :subid("99_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .const 'Sub' $P1438 = "100_1310110678.31883" 
    capture_lex $P1438
    .local string rx1433_tgt
    .local int rx1433_pos
    .local int rx1433_off
    .local int rx1433_eos
    .local int rx1433_rep
    .local pmc rx1433_cur
    .local pmc rx1433_debug
    (rx1433_cur, rx1433_pos, rx1433_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1433_cur
    .local pmc match
    .lex "$/", match
    length rx1433_eos, rx1433_tgt
    gt rx1433_pos, rx1433_eos, rx1433_done
    set rx1433_off, 0
    lt rx1433_pos, 2, rx1433_start
    sub rx1433_off, rx1433_pos, 1
    substr rx1433_tgt, rx1433_tgt, rx1433_off
  rx1433_start:
    eq $I10, 1, rx1433_restart
    if_null rx1433_debug, debug_991
    rx1433_cur."!cursor_debug"("START", "statement_control:sym<unless>")
  debug_991:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1434_done
    goto rxscan1434_scan
  rxscan1434_loop:
    (rx1433_pos) = rx1433_cur."from"()
    inc rx1433_pos
    rx1433_cur."!cursor_from"(rx1433_pos)
    ge rx1433_pos, rx1433_eos, rxscan1434_done
  rxscan1434_scan:
    set_addr $I10, rxscan1434_loop
    rx1433_cur."!mark_push"(0, rx1433_pos, $I10)
  rxscan1434_done:
.annotate 'line', 635
  # rx subcapture "sym"
    set_addr $I10, rxcap_1435_fail
    rx1433_cur."!mark_push"(0, rx1433_pos, $I10)
  # rx literal  "unless"
    add $I11, rx1433_pos, 6
    gt $I11, rx1433_eos, rx1433_fail
    sub $I11, rx1433_pos, rx1433_off
    substr $S10, rx1433_tgt, $I11, 6
    ne $S10, "unless", rx1433_fail
    add rx1433_pos, 6
    set_addr $I10, rxcap_1435_fail
    ($I12, $I11) = rx1433_cur."!mark_peek"($I10)
    rx1433_cur."!cursor_pos"($I11)
    ($P10) = rx1433_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1433_pos, "")
    rx1433_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1435_done
  rxcap_1435_fail:
    goto rx1433_fail
  rxcap_1435_done:
  # rx charclass s
    ge rx1433_pos, rx1433_eos, rx1433_fail
    sub $I10, rx1433_pos, rx1433_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1433_tgt, $I10
    unless $I11, rx1433_fail
    inc rx1433_pos
  # rx subrule "ws" subtype=method negate=
    rx1433_cur."!cursor_pos"(rx1433_pos)
    $P10 = rx1433_cur."ws"()
    unless $P10, rx1433_fail
    rx1433_pos = $P10."pos"()
.annotate 'line', 636
  # rx subrule "xblock" subtype=capture negate=
    rx1433_cur."!cursor_pos"(rx1433_pos)
    $P10 = rx1433_cur."xblock"()
    unless $P10, rx1433_fail
    rx1433_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx1433_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1433_cur."!cursor_pos"(rx1433_pos)
    $P10 = rx1433_cur."ws"()
    unless $P10, rx1433_fail
    rx1433_pos = $P10."pos"()
  alt1436_0:
.annotate 'line', 637
    set_addr $I10, alt1436_1
    rx1433_cur."!mark_push"(0, rx1433_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx1433_cur."!cursor_pos"(rx1433_pos)
    $P10 = rx1433_cur."ws"()
    unless $P10, rx1433_fail
    rx1433_pos = $P10."pos"()
  # rx subrule "before" subtype=zerowidth negate=1
    rx1433_cur."!cursor_pos"(rx1433_pos)
    .const 'Sub' $P1438 = "100_1310110678.31883" 
    capture_lex $P1438
    $P10 = rx1433_cur."before"($P1438)
    if $P10, rx1433_fail
  # rx subrule "ws" subtype=method negate=
    rx1433_cur."!cursor_pos"(rx1433_pos)
    $P10 = rx1433_cur."ws"()
    unless $P10, rx1433_fail
    rx1433_pos = $P10."pos"()
    goto alt1436_end
  alt1436_1:
  # rx subrule "ws" subtype=method negate=
    rx1433_cur."!cursor_pos"(rx1433_pos)
    $P10 = rx1433_cur."ws"()
    unless $P10, rx1433_fail
    rx1433_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1433_cur."!cursor_pos"(rx1433_pos)
    $P10 = rx1433_cur."panic"("unless does not take \"else\", please rewrite using \"if\"")
    unless $P10, rx1433_fail
    rx1433_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1433_cur."!cursor_pos"(rx1433_pos)
    $P10 = rx1433_cur."ws"()
    unless $P10, rx1433_fail
    rx1433_pos = $P10."pos"()
  alt1436_end:
  # rx subrule "ws" subtype=method negate=
    rx1433_cur."!cursor_pos"(rx1433_pos)
    $P10 = rx1433_cur."ws"()
    unless $P10, rx1433_fail
    rx1433_pos = $P10."pos"()
.annotate 'line', 634
  # rx pass
    rx1433_cur."!cursor_pass"(rx1433_pos, "statement_control:sym<unless>")
    if_null rx1433_debug, debug_996
    rx1433_cur."!cursor_debug"("PASS", "statement_control:sym<unless>", " at pos=", rx1433_pos)
  debug_996:
    .return (rx1433_cur)
  rx1433_restart:
.annotate 'line', 435
    if_null rx1433_debug, debug_997
    rx1433_cur."!cursor_debug"("NEXT", "statement_control:sym<unless>")
  debug_997:
  rx1433_fail:
    (rx1433_rep, rx1433_pos, $I10, $P10) = rx1433_cur."!mark_fail"(0)
    lt rx1433_pos, -1, rx1433_done
    eq rx1433_pos, -1, rx1433_fail
    jump $I10
  rx1433_done:
    rx1433_cur."!cursor_fail"()
    if_null rx1433_debug, debug_998
    rx1433_cur."!cursor_debug"("FAIL", "statement_control:sym<unless>")
  debug_998:
    .return (rx1433_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1437"  :anon :subid("100_1310110678.31883") :method :outer("99_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 637
    .local string rx1439_tgt
    .local int rx1439_pos
    .local int rx1439_off
    .local int rx1439_eos
    .local int rx1439_rep
    .local pmc rx1439_cur
    .local pmc rx1439_debug
    (rx1439_cur, rx1439_pos, rx1439_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1439_cur
    .local pmc match
    .lex "$/", match
    length rx1439_eos, rx1439_tgt
    gt rx1439_pos, rx1439_eos, rx1439_done
    set rx1439_off, 0
    lt rx1439_pos, 2, rx1439_start
    sub rx1439_off, rx1439_pos, 1
    substr rx1439_tgt, rx1439_tgt, rx1439_off
  rx1439_start:
    eq $I10, 1, rx1439_restart
    if_null rx1439_debug, debug_992
    rx1439_cur."!cursor_debug"("START", "")
  debug_992:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1440_done
    goto rxscan1440_scan
  rxscan1440_loop:
    (rx1439_pos) = rx1439_cur."from"()
    inc rx1439_pos
    rx1439_cur."!cursor_from"(rx1439_pos)
    ge rx1439_pos, rx1439_eos, rxscan1440_done
  rxscan1440_scan:
    set_addr $I10, rxscan1440_loop
    rx1439_cur."!mark_push"(0, rx1439_pos, $I10)
  rxscan1440_done:
  # rx literal  "else"
    add $I11, rx1439_pos, 4
    gt $I11, rx1439_eos, rx1439_fail
    sub $I11, rx1439_pos, rx1439_off
    substr $S10, rx1439_tgt, $I11, 4
    ne $S10, "else", rx1439_fail
    add rx1439_pos, 4
  # rx pass
    rx1439_cur."!cursor_pass"(rx1439_pos, "")
    if_null rx1439_debug, debug_993
    rx1439_cur."!cursor_debug"("PASS", "", " at pos=", rx1439_pos)
  debug_993:
    .return (rx1439_cur)
  rx1439_restart:
    if_null rx1439_debug, debug_994
    rx1439_cur."!cursor_debug"("NEXT", "")
  debug_994:
  rx1439_fail:
    (rx1439_rep, rx1439_pos, $I10, $P10) = rx1439_cur."!mark_fail"(0)
    lt rx1439_pos, -1, rx1439_done
    eq rx1439_pos, -1, rx1439_fail
    jump $I10
  rx1439_done:
    rx1439_cur."!cursor_fail"()
    if_null rx1439_debug, debug_995
    rx1439_cur."!cursor_debug"("FAIL", "")
  debug_995:
    .return (rx1439_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<unless>"  :subid("101_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    new $P110, "ResizablePMCArray"
    push $P110, "unless"
    .return ($P110)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<while>"  :subid("102_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1443_tgt
    .local int rx1443_pos
    .local int rx1443_off
    .local int rx1443_eos
    .local int rx1443_rep
    .local pmc rx1443_cur
    .local pmc rx1443_debug
    (rx1443_cur, rx1443_pos, rx1443_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1443_cur
    .local pmc match
    .lex "$/", match
    length rx1443_eos, rx1443_tgt
    gt rx1443_pos, rx1443_eos, rx1443_done
    set rx1443_off, 0
    lt rx1443_pos, 2, rx1443_start
    sub rx1443_off, rx1443_pos, 1
    substr rx1443_tgt, rx1443_tgt, rx1443_off
  rx1443_start:
    eq $I10, 1, rx1443_restart
    if_null rx1443_debug, debug_999
    rx1443_cur."!cursor_debug"("START", "statement_control:sym<while>")
  debug_999:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1444_done
    goto rxscan1444_scan
  rxscan1444_loop:
    (rx1443_pos) = rx1443_cur."from"()
    inc rx1443_pos
    rx1443_cur."!cursor_from"(rx1443_pos)
    ge rx1443_pos, rx1443_eos, rxscan1444_done
  rxscan1444_scan:
    set_addr $I10, rxscan1444_loop
    rx1443_cur."!mark_push"(0, rx1443_pos, $I10)
  rxscan1444_done:
.annotate 'line', 641
  # rx subcapture "sym"
    set_addr $I10, rxcap_1446_fail
    rx1443_cur."!mark_push"(0, rx1443_pos, $I10)
  alt1445_0:
    set_addr $I10, alt1445_1
    rx1443_cur."!mark_push"(0, rx1443_pos, $I10)
  # rx literal  "while"
    add $I11, rx1443_pos, 5
    gt $I11, rx1443_eos, rx1443_fail
    sub $I11, rx1443_pos, rx1443_off
    substr $S10, rx1443_tgt, $I11, 5
    ne $S10, "while", rx1443_fail
    add rx1443_pos, 5
    goto alt1445_end
  alt1445_1:
  # rx literal  "until"
    add $I11, rx1443_pos, 5
    gt $I11, rx1443_eos, rx1443_fail
    sub $I11, rx1443_pos, rx1443_off
    substr $S10, rx1443_tgt, $I11, 5
    ne $S10, "until", rx1443_fail
    add rx1443_pos, 5
  alt1445_end:
    set_addr $I10, rxcap_1446_fail
    ($I12, $I11) = rx1443_cur."!mark_peek"($I10)
    rx1443_cur."!cursor_pos"($I11)
    ($P10) = rx1443_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1443_pos, "")
    rx1443_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1446_done
  rxcap_1446_fail:
    goto rx1443_fail
  rxcap_1446_done:
  # rx charclass s
    ge rx1443_pos, rx1443_eos, rx1443_fail
    sub $I10, rx1443_pos, rx1443_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1443_tgt, $I10
    unless $I11, rx1443_fail
    inc rx1443_pos
  # rx subrule "ws" subtype=method negate=
    rx1443_cur."!cursor_pos"(rx1443_pos)
    $P10 = rx1443_cur."ws"()
    unless $P10, rx1443_fail
    rx1443_pos = $P10."pos"()
.annotate 'line', 642
  # rx subrule "xblock" subtype=capture negate=
    rx1443_cur."!cursor_pos"(rx1443_pos)
    $P10 = rx1443_cur."xblock"()
    unless $P10, rx1443_fail
    rx1443_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx1443_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1443_cur."!cursor_pos"(rx1443_pos)
    $P10 = rx1443_cur."ws"()
    unless $P10, rx1443_fail
    rx1443_pos = $P10."pos"()
.annotate 'line', 640
  # rx pass
    rx1443_cur."!cursor_pass"(rx1443_pos, "statement_control:sym<while>")
    if_null rx1443_debug, debug_1000
    rx1443_cur."!cursor_debug"("PASS", "statement_control:sym<while>", " at pos=", rx1443_pos)
  debug_1000:
    .return (rx1443_cur)
  rx1443_restart:
.annotate 'line', 435
    if_null rx1443_debug, debug_1001
    rx1443_cur."!cursor_debug"("NEXT", "statement_control:sym<while>")
  debug_1001:
  rx1443_fail:
    (rx1443_rep, rx1443_pos, $I10, $P10) = rx1443_cur."!mark_fail"(0)
    lt rx1443_pos, -1, rx1443_done
    eq rx1443_pos, -1, rx1443_fail
    jump $I10
  rx1443_done:
    rx1443_cur."!cursor_fail"()
    if_null rx1443_debug, debug_1002
    rx1443_cur."!cursor_debug"("FAIL", "statement_control:sym<while>")
  debug_1002:
    .return (rx1443_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<while>"  :subid("103_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    new $P105, "ResizablePMCArray"
    push $P105, "until"
    push $P105, "while"
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<repeat>"  :subid("104_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1449_tgt
    .local int rx1449_pos
    .local int rx1449_off
    .local int rx1449_eos
    .local int rx1449_rep
    .local pmc rx1449_cur
    .local pmc rx1449_debug
    (rx1449_cur, rx1449_pos, rx1449_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1449_cur
    .local pmc match
    .lex "$/", match
    length rx1449_eos, rx1449_tgt
    gt rx1449_pos, rx1449_eos, rx1449_done
    set rx1449_off, 0
    lt rx1449_pos, 2, rx1449_start
    sub rx1449_off, rx1449_pos, 1
    substr rx1449_tgt, rx1449_tgt, rx1449_off
  rx1449_start:
    eq $I10, 1, rx1449_restart
    if_null rx1449_debug, debug_1003
    rx1449_cur."!cursor_debug"("START", "statement_control:sym<repeat>")
  debug_1003:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1450_done
    goto rxscan1450_scan
  rxscan1450_loop:
    (rx1449_pos) = rx1449_cur."from"()
    inc rx1449_pos
    rx1449_cur."!cursor_from"(rx1449_pos)
    ge rx1449_pos, rx1449_eos, rxscan1450_done
  rxscan1450_scan:
    set_addr $I10, rxscan1450_loop
    rx1449_cur."!mark_push"(0, rx1449_pos, $I10)
  rxscan1450_done:
.annotate 'line', 646
  # rx subcapture "sym"
    set_addr $I10, rxcap_1451_fail
    rx1449_cur."!mark_push"(0, rx1449_pos, $I10)
  # rx literal  "repeat"
    add $I11, rx1449_pos, 6
    gt $I11, rx1449_eos, rx1449_fail
    sub $I11, rx1449_pos, rx1449_off
    substr $S10, rx1449_tgt, $I11, 6
    ne $S10, "repeat", rx1449_fail
    add rx1449_pos, 6
    set_addr $I10, rxcap_1451_fail
    ($I12, $I11) = rx1449_cur."!mark_peek"($I10)
    rx1449_cur."!cursor_pos"($I11)
    ($P10) = rx1449_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1449_pos, "")
    rx1449_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1451_done
  rxcap_1451_fail:
    goto rx1449_fail
  rxcap_1451_done:
  # rx charclass s
    ge rx1449_pos, rx1449_eos, rx1449_fail
    sub $I10, rx1449_pos, rx1449_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1449_tgt, $I10
    unless $I11, rx1449_fail
    inc rx1449_pos
  # rx subrule "ws" subtype=method negate=
    rx1449_cur."!cursor_pos"(rx1449_pos)
    $P10 = rx1449_cur."ws"()
    unless $P10, rx1449_fail
    rx1449_pos = $P10."pos"()
  alt1452_0:
.annotate 'line', 647
    set_addr $I10, alt1452_1
    rx1449_cur."!mark_push"(0, rx1449_pos, $I10)
.annotate 'line', 648
  # rx subrule "ws" subtype=method negate=
    rx1449_cur."!cursor_pos"(rx1449_pos)
    $P10 = rx1449_cur."ws"()
    unless $P10, rx1449_fail
    rx1449_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_1454_fail
    rx1449_cur."!mark_push"(0, rx1449_pos, $I10)
  alt1453_0:
    set_addr $I10, alt1453_1
    rx1449_cur."!mark_push"(0, rx1449_pos, $I10)
  # rx literal  "while"
    add $I11, rx1449_pos, 5
    gt $I11, rx1449_eos, rx1449_fail
    sub $I11, rx1449_pos, rx1449_off
    substr $S10, rx1449_tgt, $I11, 5
    ne $S10, "while", rx1449_fail
    add rx1449_pos, 5
    goto alt1453_end
  alt1453_1:
  # rx literal  "until"
    add $I11, rx1449_pos, 5
    gt $I11, rx1449_eos, rx1449_fail
    sub $I11, rx1449_pos, rx1449_off
    substr $S10, rx1449_tgt, $I11, 5
    ne $S10, "until", rx1449_fail
    add rx1449_pos, 5
  alt1453_end:
    set_addr $I10, rxcap_1454_fail
    ($I12, $I11) = rx1449_cur."!mark_peek"($I10)
    rx1449_cur."!cursor_pos"($I11)
    ($P10) = rx1449_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1449_pos, "")
    rx1449_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_1454_done
  rxcap_1454_fail:
    goto rx1449_fail
  rxcap_1454_done:
  # rx charclass s
    ge rx1449_pos, rx1449_eos, rx1449_fail
    sub $I10, rx1449_pos, rx1449_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1449_tgt, $I10
    unless $I11, rx1449_fail
    inc rx1449_pos
  # rx subrule "ws" subtype=method negate=
    rx1449_cur."!cursor_pos"(rx1449_pos)
    $P10 = rx1449_cur."ws"()
    unless $P10, rx1449_fail
    rx1449_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx1449_cur."!cursor_pos"(rx1449_pos)
    $P10 = rx1449_cur."xblock"()
    unless $P10, rx1449_fail
    rx1449_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx1449_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1449_cur."!cursor_pos"(rx1449_pos)
    $P10 = rx1449_cur."ws"()
    unless $P10, rx1449_fail
    rx1449_pos = $P10."pos"()
    goto alt1452_end
  alt1452_1:
.annotate 'line', 649
  # rx subrule "ws" subtype=method negate=
    rx1449_cur."!cursor_pos"(rx1449_pos)
    $P10 = rx1449_cur."ws"()
    unless $P10, rx1449_fail
    rx1449_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx1449_cur."!cursor_pos"(rx1449_pos)
    $P10 = rx1449_cur."pblock"()
    unless $P10, rx1449_fail
    rx1449_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx1449_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1449_cur."!cursor_pos"(rx1449_pos)
    $P10 = rx1449_cur."ws"()
    unless $P10, rx1449_fail
    rx1449_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_1456_fail
    rx1449_cur."!mark_push"(0, rx1449_pos, $I10)
  alt1455_0:
    set_addr $I10, alt1455_1
    rx1449_cur."!mark_push"(0, rx1449_pos, $I10)
  # rx literal  "while"
    add $I11, rx1449_pos, 5
    gt $I11, rx1449_eos, rx1449_fail
    sub $I11, rx1449_pos, rx1449_off
    substr $S10, rx1449_tgt, $I11, 5
    ne $S10, "while", rx1449_fail
    add rx1449_pos, 5
    goto alt1455_end
  alt1455_1:
  # rx literal  "until"
    add $I11, rx1449_pos, 5
    gt $I11, rx1449_eos, rx1449_fail
    sub $I11, rx1449_pos, rx1449_off
    substr $S10, rx1449_tgt, $I11, 5
    ne $S10, "until", rx1449_fail
    add rx1449_pos, 5
  alt1455_end:
    set_addr $I10, rxcap_1456_fail
    ($I12, $I11) = rx1449_cur."!mark_peek"($I10)
    rx1449_cur."!cursor_pos"($I11)
    ($P10) = rx1449_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1449_pos, "")
    rx1449_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_1456_done
  rxcap_1456_fail:
    goto rx1449_fail
  rxcap_1456_done:
  # rx charclass s
    ge rx1449_pos, rx1449_eos, rx1449_fail
    sub $I10, rx1449_pos, rx1449_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1449_tgt, $I10
    unless $I11, rx1449_fail
    inc rx1449_pos
  # rx subrule "ws" subtype=method negate=
    rx1449_cur."!cursor_pos"(rx1449_pos)
    $P10 = rx1449_cur."ws"()
    unless $P10, rx1449_fail
    rx1449_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1449_cur."!cursor_pos"(rx1449_pos)
    $P10 = rx1449_cur."EXPR"()
    unless $P10, rx1449_fail
    rx1449_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1449_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1449_cur."!cursor_pos"(rx1449_pos)
    $P10 = rx1449_cur."ws"()
    unless $P10, rx1449_fail
    rx1449_pos = $P10."pos"()
  alt1452_end:
.annotate 'line', 650
  # rx subrule "ws" subtype=method negate=
    rx1449_cur."!cursor_pos"(rx1449_pos)
    $P10 = rx1449_cur."ws"()
    unless $P10, rx1449_fail
    rx1449_pos = $P10."pos"()
.annotate 'line', 645
  # rx pass
    rx1449_cur."!cursor_pass"(rx1449_pos, "statement_control:sym<repeat>")
    if_null rx1449_debug, debug_1004
    rx1449_cur."!cursor_debug"("PASS", "statement_control:sym<repeat>", " at pos=", rx1449_pos)
  debug_1004:
    .return (rx1449_cur)
  rx1449_restart:
.annotate 'line', 435
    if_null rx1449_debug, debug_1005
    rx1449_cur."!cursor_debug"("NEXT", "statement_control:sym<repeat>")
  debug_1005:
  rx1449_fail:
    (rx1449_rep, rx1449_pos, $I10, $P10) = rx1449_cur."!mark_fail"(0)
    lt rx1449_pos, -1, rx1449_done
    eq rx1449_pos, -1, rx1449_fail
    jump $I10
  rx1449_done:
    rx1449_cur."!cursor_fail"()
    if_null rx1449_debug, debug_1006
    rx1449_cur."!cursor_debug"("FAIL", "statement_control:sym<repeat>")
  debug_1006:
    .return (rx1449_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<repeat>"  :subid("105_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    new $P112, "ResizablePMCArray"
    push $P112, "repeat"
    .return ($P112)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<for>"  :subid("106_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1459_tgt
    .local int rx1459_pos
    .local int rx1459_off
    .local int rx1459_eos
    .local int rx1459_rep
    .local pmc rx1459_cur
    .local pmc rx1459_debug
    (rx1459_cur, rx1459_pos, rx1459_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1459_cur
    .local pmc match
    .lex "$/", match
    length rx1459_eos, rx1459_tgt
    gt rx1459_pos, rx1459_eos, rx1459_done
    set rx1459_off, 0
    lt rx1459_pos, 2, rx1459_start
    sub rx1459_off, rx1459_pos, 1
    substr rx1459_tgt, rx1459_tgt, rx1459_off
  rx1459_start:
    eq $I10, 1, rx1459_restart
    if_null rx1459_debug, debug_1007
    rx1459_cur."!cursor_debug"("START", "statement_control:sym<for>")
  debug_1007:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1460_done
    goto rxscan1460_scan
  rxscan1460_loop:
    (rx1459_pos) = rx1459_cur."from"()
    inc rx1459_pos
    rx1459_cur."!cursor_from"(rx1459_pos)
    ge rx1459_pos, rx1459_eos, rxscan1460_done
  rxscan1460_scan:
    set_addr $I10, rxscan1460_loop
    rx1459_cur."!mark_push"(0, rx1459_pos, $I10)
  rxscan1460_done:
.annotate 'line', 654
  # rx subcapture "sym"
    set_addr $I10, rxcap_1461_fail
    rx1459_cur."!mark_push"(0, rx1459_pos, $I10)
  # rx literal  "for"
    add $I11, rx1459_pos, 3
    gt $I11, rx1459_eos, rx1459_fail
    sub $I11, rx1459_pos, rx1459_off
    substr $S10, rx1459_tgt, $I11, 3
    ne $S10, "for", rx1459_fail
    add rx1459_pos, 3
    set_addr $I10, rxcap_1461_fail
    ($I12, $I11) = rx1459_cur."!mark_peek"($I10)
    rx1459_cur."!cursor_pos"($I11)
    ($P10) = rx1459_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1459_pos, "")
    rx1459_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1461_done
  rxcap_1461_fail:
    goto rx1459_fail
  rxcap_1461_done:
  # rx charclass s
    ge rx1459_pos, rx1459_eos, rx1459_fail
    sub $I10, rx1459_pos, rx1459_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1459_tgt, $I10
    unless $I11, rx1459_fail
    inc rx1459_pos
  # rx subrule "ws" subtype=method negate=
    rx1459_cur."!cursor_pos"(rx1459_pos)
    $P10 = rx1459_cur."ws"()
    unless $P10, rx1459_fail
    rx1459_pos = $P10."pos"()
.annotate 'line', 655
  # rx subrule "xblock" subtype=capture negate=
    rx1459_cur."!cursor_pos"(rx1459_pos)
    $P10 = rx1459_cur."xblock"()
    unless $P10, rx1459_fail
    rx1459_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx1459_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1459_cur."!cursor_pos"(rx1459_pos)
    $P10 = rx1459_cur."ws"()
    unless $P10, rx1459_fail
    rx1459_pos = $P10."pos"()
.annotate 'line', 653
  # rx pass
    rx1459_cur."!cursor_pass"(rx1459_pos, "statement_control:sym<for>")
    if_null rx1459_debug, debug_1008
    rx1459_cur."!cursor_debug"("PASS", "statement_control:sym<for>", " at pos=", rx1459_pos)
  debug_1008:
    .return (rx1459_cur)
  rx1459_restart:
.annotate 'line', 435
    if_null rx1459_debug, debug_1009
    rx1459_cur."!cursor_debug"("NEXT", "statement_control:sym<for>")
  debug_1009:
  rx1459_fail:
    (rx1459_rep, rx1459_pos, $I10, $P10) = rx1459_cur."!mark_fail"(0)
    lt rx1459_pos, -1, rx1459_done
    eq rx1459_pos, -1, rx1459_fail
    jump $I10
  rx1459_done:
    rx1459_cur."!cursor_fail"()
    if_null rx1459_debug, debug_1010
    rx1459_cur."!cursor_debug"("FAIL", "statement_control:sym<for>")
  debug_1010:
    .return (rx1459_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<for>"  :subid("107_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    new $P105, "ResizablePMCArray"
    push $P105, "for"
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CATCH>"  :subid("108_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1464_tgt
    .local int rx1464_pos
    .local int rx1464_off
    .local int rx1464_eos
    .local int rx1464_rep
    .local pmc rx1464_cur
    .local pmc rx1464_debug
    (rx1464_cur, rx1464_pos, rx1464_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1464_cur
    .local pmc match
    .lex "$/", match
    length rx1464_eos, rx1464_tgt
    gt rx1464_pos, rx1464_eos, rx1464_done
    set rx1464_off, 0
    lt rx1464_pos, 2, rx1464_start
    sub rx1464_off, rx1464_pos, 1
    substr rx1464_tgt, rx1464_tgt, rx1464_off
  rx1464_start:
    eq $I10, 1, rx1464_restart
    if_null rx1464_debug, debug_1011
    rx1464_cur."!cursor_debug"("START", "statement_control:sym<CATCH>")
  debug_1011:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1465_done
    goto rxscan1465_scan
  rxscan1465_loop:
    (rx1464_pos) = rx1464_cur."from"()
    inc rx1464_pos
    rx1464_cur."!cursor_from"(rx1464_pos)
    ge rx1464_pos, rx1464_eos, rxscan1465_done
  rxscan1465_scan:
    set_addr $I10, rxscan1465_loop
    rx1464_cur."!mark_push"(0, rx1464_pos, $I10)
  rxscan1465_done:
.annotate 'line', 659
  # rx subcapture "sym"
    set_addr $I10, rxcap_1466_fail
    rx1464_cur."!mark_push"(0, rx1464_pos, $I10)
  # rx literal  "CATCH"
    add $I11, rx1464_pos, 5
    gt $I11, rx1464_eos, rx1464_fail
    sub $I11, rx1464_pos, rx1464_off
    substr $S10, rx1464_tgt, $I11, 5
    ne $S10, "CATCH", rx1464_fail
    add rx1464_pos, 5
    set_addr $I10, rxcap_1466_fail
    ($I12, $I11) = rx1464_cur."!mark_peek"($I10)
    rx1464_cur."!cursor_pos"($I11)
    ($P10) = rx1464_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1464_pos, "")
    rx1464_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1466_done
  rxcap_1466_fail:
    goto rx1464_fail
  rxcap_1466_done:
  # rx charclass s
    ge rx1464_pos, rx1464_eos, rx1464_fail
    sub $I10, rx1464_pos, rx1464_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1464_tgt, $I10
    unless $I11, rx1464_fail
    inc rx1464_pos
  # rx subrule "ws" subtype=method negate=
    rx1464_cur."!cursor_pos"(rx1464_pos)
    $P10 = rx1464_cur."ws"()
    unless $P10, rx1464_fail
    rx1464_pos = $P10."pos"()
.annotate 'line', 660
  # rx subrule "block" subtype=capture negate=
    rx1464_cur."!cursor_pos"(rx1464_pos)
    $P10 = rx1464_cur."block"()
    unless $P10, rx1464_fail
    rx1464_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1464_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1464_cur."!cursor_pos"(rx1464_pos)
    $P10 = rx1464_cur."ws"()
    unless $P10, rx1464_fail
    rx1464_pos = $P10."pos"()
.annotate 'line', 658
  # rx pass
    rx1464_cur."!cursor_pass"(rx1464_pos, "statement_control:sym<CATCH>")
    if_null rx1464_debug, debug_1012
    rx1464_cur."!cursor_debug"("PASS", "statement_control:sym<CATCH>", " at pos=", rx1464_pos)
  debug_1012:
    .return (rx1464_cur)
  rx1464_restart:
.annotate 'line', 435
    if_null rx1464_debug, debug_1013
    rx1464_cur."!cursor_debug"("NEXT", "statement_control:sym<CATCH>")
  debug_1013:
  rx1464_fail:
    (rx1464_rep, rx1464_pos, $I10, $P10) = rx1464_cur."!mark_fail"(0)
    lt rx1464_pos, -1, rx1464_done
    eq rx1464_pos, -1, rx1464_fail
    jump $I10
  rx1464_done:
    rx1464_cur."!cursor_fail"()
    if_null rx1464_debug, debug_1014
    rx1464_cur."!cursor_debug"("FAIL", "statement_control:sym<CATCH>")
  debug_1014:
    .return (rx1464_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CATCH>"  :subid("109_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    new $P105, "ResizablePMCArray"
    push $P105, "CATCH"
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CONTROL>"  :subid("110_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1469_tgt
    .local int rx1469_pos
    .local int rx1469_off
    .local int rx1469_eos
    .local int rx1469_rep
    .local pmc rx1469_cur
    .local pmc rx1469_debug
    (rx1469_cur, rx1469_pos, rx1469_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1469_cur
    .local pmc match
    .lex "$/", match
    length rx1469_eos, rx1469_tgt
    gt rx1469_pos, rx1469_eos, rx1469_done
    set rx1469_off, 0
    lt rx1469_pos, 2, rx1469_start
    sub rx1469_off, rx1469_pos, 1
    substr rx1469_tgt, rx1469_tgt, rx1469_off
  rx1469_start:
    eq $I10, 1, rx1469_restart
    if_null rx1469_debug, debug_1015
    rx1469_cur."!cursor_debug"("START", "statement_control:sym<CONTROL>")
  debug_1015:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1470_done
    goto rxscan1470_scan
  rxscan1470_loop:
    (rx1469_pos) = rx1469_cur."from"()
    inc rx1469_pos
    rx1469_cur."!cursor_from"(rx1469_pos)
    ge rx1469_pos, rx1469_eos, rxscan1470_done
  rxscan1470_scan:
    set_addr $I10, rxscan1470_loop
    rx1469_cur."!mark_push"(0, rx1469_pos, $I10)
  rxscan1470_done:
.annotate 'line', 664
  # rx subcapture "sym"
    set_addr $I10, rxcap_1471_fail
    rx1469_cur."!mark_push"(0, rx1469_pos, $I10)
  # rx literal  "CONTROL"
    add $I11, rx1469_pos, 7
    gt $I11, rx1469_eos, rx1469_fail
    sub $I11, rx1469_pos, rx1469_off
    substr $S10, rx1469_tgt, $I11, 7
    ne $S10, "CONTROL", rx1469_fail
    add rx1469_pos, 7
    set_addr $I10, rxcap_1471_fail
    ($I12, $I11) = rx1469_cur."!mark_peek"($I10)
    rx1469_cur."!cursor_pos"($I11)
    ($P10) = rx1469_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1469_pos, "")
    rx1469_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1471_done
  rxcap_1471_fail:
    goto rx1469_fail
  rxcap_1471_done:
  # rx charclass s
    ge rx1469_pos, rx1469_eos, rx1469_fail
    sub $I10, rx1469_pos, rx1469_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1469_tgt, $I10
    unless $I11, rx1469_fail
    inc rx1469_pos
  # rx subrule "ws" subtype=method negate=
    rx1469_cur."!cursor_pos"(rx1469_pos)
    $P10 = rx1469_cur."ws"()
    unless $P10, rx1469_fail
    rx1469_pos = $P10."pos"()
.annotate 'line', 665
  # rx subrule "block" subtype=capture negate=
    rx1469_cur."!cursor_pos"(rx1469_pos)
    $P10 = rx1469_cur."block"()
    unless $P10, rx1469_fail
    rx1469_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1469_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1469_cur."!cursor_pos"(rx1469_pos)
    $P10 = rx1469_cur."ws"()
    unless $P10, rx1469_fail
    rx1469_pos = $P10."pos"()
.annotate 'line', 663
  # rx pass
    rx1469_cur."!cursor_pass"(rx1469_pos, "statement_control:sym<CONTROL>")
    if_null rx1469_debug, debug_1016
    rx1469_cur."!cursor_debug"("PASS", "statement_control:sym<CONTROL>", " at pos=", rx1469_pos)
  debug_1016:
    .return (rx1469_cur)
  rx1469_restart:
.annotate 'line', 435
    if_null rx1469_debug, debug_1017
    rx1469_cur."!cursor_debug"("NEXT", "statement_control:sym<CONTROL>")
  debug_1017:
  rx1469_fail:
    (rx1469_rep, rx1469_pos, $I10, $P10) = rx1469_cur."!mark_fail"(0)
    lt rx1469_pos, -1, rx1469_done
    eq rx1469_pos, -1, rx1469_fail
    jump $I10
  rx1469_done:
    rx1469_cur."!cursor_fail"()
    if_null rx1469_debug, debug_1018
    rx1469_cur."!cursor_debug"("FAIL", "statement_control:sym<CONTROL>")
  debug_1018:
    .return (rx1469_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CONTROL>"  :subid("111_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    new $P105, "ResizablePMCArray"
    push $P105, "CONTROL"
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix"  :subid("112_1310110678.31883")
    .param pmc param_1474
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 668
    .lex "self", param_1474
    $P103 = param_1474."!protoregex"("statement_prefix")
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix"  :subid("113_1310110678.31883")
    .param pmc param_1476
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 668
    .lex "self", param_1476
    $P104 = param_1476."!PREFIX__!protoregex"("statement_prefix")
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<INIT>"  :subid("114_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1478_tgt
    .local int rx1478_pos
    .local int rx1478_off
    .local int rx1478_eos
    .local int rx1478_rep
    .local pmc rx1478_cur
    .local pmc rx1478_debug
    (rx1478_cur, rx1478_pos, rx1478_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1478_cur
    .local pmc match
    .lex "$/", match
    length rx1478_eos, rx1478_tgt
    gt rx1478_pos, rx1478_eos, rx1478_done
    set rx1478_off, 0
    lt rx1478_pos, 2, rx1478_start
    sub rx1478_off, rx1478_pos, 1
    substr rx1478_tgt, rx1478_tgt, rx1478_off
  rx1478_start:
    eq $I10, 1, rx1478_restart
    if_null rx1478_debug, debug_1019
    rx1478_cur."!cursor_debug"("START", "statement_prefix:sym<INIT>")
  debug_1019:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1479_done
    goto rxscan1479_scan
  rxscan1479_loop:
    (rx1478_pos) = rx1478_cur."from"()
    inc rx1478_pos
    rx1478_cur."!cursor_from"(rx1478_pos)
    ge rx1478_pos, rx1478_eos, rxscan1479_done
  rxscan1479_scan:
    set_addr $I10, rxscan1479_loop
    rx1478_cur."!mark_push"(0, rx1478_pos, $I10)
  rxscan1479_done:
.annotate 'line', 669
  # rx subcapture "sym"
    set_addr $I10, rxcap_1480_fail
    rx1478_cur."!mark_push"(0, rx1478_pos, $I10)
  # rx literal  "INIT"
    add $I11, rx1478_pos, 4
    gt $I11, rx1478_eos, rx1478_fail
    sub $I11, rx1478_pos, rx1478_off
    substr $S10, rx1478_tgt, $I11, 4
    ne $S10, "INIT", rx1478_fail
    add rx1478_pos, 4
    set_addr $I10, rxcap_1480_fail
    ($I12, $I11) = rx1478_cur."!mark_peek"($I10)
    rx1478_cur."!cursor_pos"($I11)
    ($P10) = rx1478_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1478_pos, "")
    rx1478_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1480_done
  rxcap_1480_fail:
    goto rx1478_fail
  rxcap_1480_done:
  # rx subrule "blorst" subtype=capture negate=
    rx1478_cur."!cursor_pos"(rx1478_pos)
    $P10 = rx1478_cur."blorst"()
    unless $P10, rx1478_fail
    rx1478_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx1478_pos = $P10."pos"()
  # rx pass
    rx1478_cur."!cursor_pass"(rx1478_pos, "statement_prefix:sym<INIT>")
    if_null rx1478_debug, debug_1020
    rx1478_cur."!cursor_debug"("PASS", "statement_prefix:sym<INIT>", " at pos=", rx1478_pos)
  debug_1020:
    .return (rx1478_cur)
  rx1478_restart:
.annotate 'line', 435
    if_null rx1478_debug, debug_1021
    rx1478_cur."!cursor_debug"("NEXT", "statement_prefix:sym<INIT>")
  debug_1021:
  rx1478_fail:
    (rx1478_rep, rx1478_pos, $I10, $P10) = rx1478_cur."!mark_fail"(0)
    lt rx1478_pos, -1, rx1478_done
    eq rx1478_pos, -1, rx1478_fail
    jump $I10
  rx1478_done:
    rx1478_cur."!cursor_fail"()
    if_null rx1478_debug, debug_1022
    rx1478_cur."!cursor_debug"("FAIL", "statement_prefix:sym<INIT>")
  debug_1022:
    .return (rx1478_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<INIT>"  :subid("115_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("blorst", "INIT")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<try>"  :subid("116_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1483_tgt
    .local int rx1483_pos
    .local int rx1483_off
    .local int rx1483_eos
    .local int rx1483_rep
    .local pmc rx1483_cur
    .local pmc rx1483_debug
    (rx1483_cur, rx1483_pos, rx1483_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1483_cur
    .local pmc match
    .lex "$/", match
    length rx1483_eos, rx1483_tgt
    gt rx1483_pos, rx1483_eos, rx1483_done
    set rx1483_off, 0
    lt rx1483_pos, 2, rx1483_start
    sub rx1483_off, rx1483_pos, 1
    substr rx1483_tgt, rx1483_tgt, rx1483_off
  rx1483_start:
    eq $I10, 1, rx1483_restart
    if_null rx1483_debug, debug_1023
    rx1483_cur."!cursor_debug"("START", "statement_prefix:sym<try>")
  debug_1023:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1484_done
    goto rxscan1484_scan
  rxscan1484_loop:
    (rx1483_pos) = rx1483_cur."from"()
    inc rx1483_pos
    rx1483_cur."!cursor_from"(rx1483_pos)
    ge rx1483_pos, rx1483_eos, rxscan1484_done
  rxscan1484_scan:
    set_addr $I10, rxscan1484_loop
    rx1483_cur."!mark_push"(0, rx1483_pos, $I10)
  rxscan1484_done:
.annotate 'line', 672
  # rx subcapture "sym"
    set_addr $I10, rxcap_1485_fail
    rx1483_cur."!mark_push"(0, rx1483_pos, $I10)
  # rx literal  "try"
    add $I11, rx1483_pos, 3
    gt $I11, rx1483_eos, rx1483_fail
    sub $I11, rx1483_pos, rx1483_off
    substr $S10, rx1483_tgt, $I11, 3
    ne $S10, "try", rx1483_fail
    add rx1483_pos, 3
    set_addr $I10, rxcap_1485_fail
    ($I12, $I11) = rx1483_cur."!mark_peek"($I10)
    rx1483_cur."!cursor_pos"($I11)
    ($P10) = rx1483_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1483_pos, "")
    rx1483_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1485_done
  rxcap_1485_fail:
    goto rx1483_fail
  rxcap_1485_done:
.annotate 'line', 673
  # rx subrule "blorst" subtype=capture negate=
    rx1483_cur."!cursor_pos"(rx1483_pos)
    $P10 = rx1483_cur."blorst"()
    unless $P10, rx1483_fail
    rx1483_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx1483_pos = $P10."pos"()
.annotate 'line', 671
  # rx pass
    rx1483_cur."!cursor_pass"(rx1483_pos, "statement_prefix:sym<try>")
    if_null rx1483_debug, debug_1024
    rx1483_cur."!cursor_debug"("PASS", "statement_prefix:sym<try>", " at pos=", rx1483_pos)
  debug_1024:
    .return (rx1483_cur)
  rx1483_restart:
.annotate 'line', 435
    if_null rx1483_debug, debug_1025
    rx1483_cur."!cursor_debug"("NEXT", "statement_prefix:sym<try>")
  debug_1025:
  rx1483_fail:
    (rx1483_rep, rx1483_pos, $I10, $P10) = rx1483_cur."!mark_fail"(0)
    lt rx1483_pos, -1, rx1483_done
    eq rx1483_pos, -1, rx1483_fail
    jump $I10
  rx1483_done:
    rx1483_cur."!cursor_fail"()
    if_null rx1483_debug, debug_1026
    rx1483_cur."!cursor_debug"("FAIL", "statement_prefix:sym<try>")
  debug_1026:
    .return (rx1483_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<try>"  :subid("117_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("blorst", "try")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blorst"  :subid("118_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1488_tgt
    .local int rx1488_pos
    .local int rx1488_off
    .local int rx1488_eos
    .local int rx1488_rep
    .local pmc rx1488_cur
    .local pmc rx1488_debug
    (rx1488_cur, rx1488_pos, rx1488_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1488_cur
    .local pmc match
    .lex "$/", match
    length rx1488_eos, rx1488_tgt
    gt rx1488_pos, rx1488_eos, rx1488_done
    set rx1488_off, 0
    lt rx1488_pos, 2, rx1488_start
    sub rx1488_off, rx1488_pos, 1
    substr rx1488_tgt, rx1488_tgt, rx1488_off
  rx1488_start:
    eq $I10, 1, rx1488_restart
    if_null rx1488_debug, debug_1027
    rx1488_cur."!cursor_debug"("START", "blorst")
  debug_1027:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1489_done
    goto rxscan1489_scan
  rxscan1489_loop:
    (rx1488_pos) = rx1488_cur."from"()
    inc rx1488_pos
    rx1488_cur."!cursor_from"(rx1488_pos)
    ge rx1488_pos, rx1488_eos, rxscan1489_done
  rxscan1489_scan:
    set_addr $I10, rxscan1489_loop
    rx1488_cur."!mark_push"(0, rx1488_pos, $I10)
  rxscan1489_done:
.annotate 'line', 677
  # rx charclass s
    ge rx1488_pos, rx1488_eos, rx1488_fail
    sub $I10, rx1488_pos, rx1488_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1488_tgt, $I10
    unless $I11, rx1488_fail
    inc rx1488_pos
  # rx subrule "ws" subtype=method negate=
    rx1488_cur."!cursor_pos"(rx1488_pos)
    $P10 = rx1488_cur."ws"()
    unless $P10, rx1488_fail
    rx1488_pos = $P10."pos"()
  alt1490_0:
    set_addr $I10, alt1490_1
    rx1488_cur."!mark_push"(0, rx1488_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1488_pos, rx1488_off
    substr $S10, rx1488_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1488_fail
  # rx subrule "block" subtype=capture negate=
    rx1488_cur."!cursor_pos"(rx1488_pos)
    $P10 = rx1488_cur."block"()
    unless $P10, rx1488_fail
    rx1488_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1488_pos = $P10."pos"()
    goto alt1490_end
  alt1490_1:
  # rx subrule "statement" subtype=capture negate=
    rx1488_cur."!cursor_pos"(rx1488_pos)
    $P10 = rx1488_cur."statement"()
    unless $P10, rx1488_fail
    rx1488_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx1488_pos = $P10."pos"()
  alt1490_end:
.annotate 'line', 676
  # rx pass
    rx1488_cur."!cursor_pass"(rx1488_pos, "blorst")
    if_null rx1488_debug, debug_1028
    rx1488_cur."!cursor_debug"("PASS", "blorst", " at pos=", rx1488_pos)
  debug_1028:
    .return (rx1488_cur)
  rx1488_restart:
.annotate 'line', 435
    if_null rx1488_debug, debug_1029
    rx1488_cur."!cursor_debug"("NEXT", "blorst")
  debug_1029:
  rx1488_fail:
    (rx1488_rep, rx1488_pos, $I10, $P10) = rx1488_cur."!mark_fail"(0)
    lt rx1488_pos, -1, rx1488_done
    eq rx1488_pos, -1, rx1488_fail
    jump $I10
  rx1488_done:
    rx1488_cur."!cursor_fail"()
    if_null rx1488_debug, debug_1030
    rx1488_cur."!cursor_debug"("FAIL", "blorst")
  debug_1030:
    .return (rx1488_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blorst"  :subid("119_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond"  :subid("120_1310110678.31883")
    .param pmc param_1493
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 682
    .lex "self", param_1493
    $P103 = param_1493."!protoregex"("statement_mod_cond")
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond"  :subid("121_1310110678.31883")
    .param pmc param_1495
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 682
    .lex "self", param_1495
    $P104 = param_1495."!PREFIX__!protoregex"("statement_mod_cond")
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<if>"  :subid("122_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1497_tgt
    .local int rx1497_pos
    .local int rx1497_off
    .local int rx1497_eos
    .local int rx1497_rep
    .local pmc rx1497_cur
    .local pmc rx1497_debug
    (rx1497_cur, rx1497_pos, rx1497_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1497_cur
    .local pmc match
    .lex "$/", match
    length rx1497_eos, rx1497_tgt
    gt rx1497_pos, rx1497_eos, rx1497_done
    set rx1497_off, 0
    lt rx1497_pos, 2, rx1497_start
    sub rx1497_off, rx1497_pos, 1
    substr rx1497_tgt, rx1497_tgt, rx1497_off
  rx1497_start:
    eq $I10, 1, rx1497_restart
    if_null rx1497_debug, debug_1031
    rx1497_cur."!cursor_debug"("START", "statement_mod_cond:sym<if>")
  debug_1031:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1498_done
    goto rxscan1498_scan
  rxscan1498_loop:
    (rx1497_pos) = rx1497_cur."from"()
    inc rx1497_pos
    rx1497_cur."!cursor_from"(rx1497_pos)
    ge rx1497_pos, rx1497_eos, rxscan1498_done
  rxscan1498_scan:
    set_addr $I10, rxscan1498_loop
    rx1497_cur."!mark_push"(0, rx1497_pos, $I10)
  rxscan1498_done:
.annotate 'line', 684
  # rx subcapture "sym"
    set_addr $I10, rxcap_1499_fail
    rx1497_cur."!mark_push"(0, rx1497_pos, $I10)
  # rx literal  "if"
    add $I11, rx1497_pos, 2
    gt $I11, rx1497_eos, rx1497_fail
    sub $I11, rx1497_pos, rx1497_off
    substr $S10, rx1497_tgt, $I11, 2
    ne $S10, "if", rx1497_fail
    add rx1497_pos, 2
    set_addr $I10, rxcap_1499_fail
    ($I12, $I11) = rx1497_cur."!mark_peek"($I10)
    rx1497_cur."!cursor_pos"($I11)
    ($P10) = rx1497_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1497_pos, "")
    rx1497_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1499_done
  rxcap_1499_fail:
    goto rx1497_fail
  rxcap_1499_done:
  # rx subrule "ws" subtype=method negate=
    rx1497_cur."!cursor_pos"(rx1497_pos)
    $P10 = rx1497_cur."ws"()
    unless $P10, rx1497_fail
    rx1497_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1497_cur."!cursor_pos"(rx1497_pos)
    $P10 = rx1497_cur."EXPR"()
    unless $P10, rx1497_fail
    rx1497_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx1497_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1497_cur."!cursor_pos"(rx1497_pos)
    $P10 = rx1497_cur."ws"()
    unless $P10, rx1497_fail
    rx1497_pos = $P10."pos"()
  # rx pass
    rx1497_cur."!cursor_pass"(rx1497_pos, "statement_mod_cond:sym<if>")
    if_null rx1497_debug, debug_1032
    rx1497_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<if>", " at pos=", rx1497_pos)
  debug_1032:
    .return (rx1497_cur)
  rx1497_restart:
.annotate 'line', 435
    if_null rx1497_debug, debug_1033
    rx1497_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<if>")
  debug_1033:
  rx1497_fail:
    (rx1497_rep, rx1497_pos, $I10, $P10) = rx1497_cur."!mark_fail"(0)
    lt rx1497_pos, -1, rx1497_done
    eq rx1497_pos, -1, rx1497_fail
    jump $I10
  rx1497_done:
    rx1497_cur."!cursor_fail"()
    if_null rx1497_debug, debug_1034
    rx1497_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<if>")
  debug_1034:
    .return (rx1497_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<if>"  :subid("123_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P105 = self."!PREFIX__!subrule"("ws", "if")
    new $P106, "ResizablePMCArray"
    push $P106, $P105
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<unless>"  :subid("124_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1502_tgt
    .local int rx1502_pos
    .local int rx1502_off
    .local int rx1502_eos
    .local int rx1502_rep
    .local pmc rx1502_cur
    .local pmc rx1502_debug
    (rx1502_cur, rx1502_pos, rx1502_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1502_cur
    .local pmc match
    .lex "$/", match
    length rx1502_eos, rx1502_tgt
    gt rx1502_pos, rx1502_eos, rx1502_done
    set rx1502_off, 0
    lt rx1502_pos, 2, rx1502_start
    sub rx1502_off, rx1502_pos, 1
    substr rx1502_tgt, rx1502_tgt, rx1502_off
  rx1502_start:
    eq $I10, 1, rx1502_restart
    if_null rx1502_debug, debug_1035
    rx1502_cur."!cursor_debug"("START", "statement_mod_cond:sym<unless>")
  debug_1035:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1503_done
    goto rxscan1503_scan
  rxscan1503_loop:
    (rx1502_pos) = rx1502_cur."from"()
    inc rx1502_pos
    rx1502_cur."!cursor_from"(rx1502_pos)
    ge rx1502_pos, rx1502_eos, rxscan1503_done
  rxscan1503_scan:
    set_addr $I10, rxscan1503_loop
    rx1502_cur."!mark_push"(0, rx1502_pos, $I10)
  rxscan1503_done:
.annotate 'line', 685
  # rx subcapture "sym"
    set_addr $I10, rxcap_1504_fail
    rx1502_cur."!mark_push"(0, rx1502_pos, $I10)
  # rx literal  "unless"
    add $I11, rx1502_pos, 6
    gt $I11, rx1502_eos, rx1502_fail
    sub $I11, rx1502_pos, rx1502_off
    substr $S10, rx1502_tgt, $I11, 6
    ne $S10, "unless", rx1502_fail
    add rx1502_pos, 6
    set_addr $I10, rxcap_1504_fail
    ($I12, $I11) = rx1502_cur."!mark_peek"($I10)
    rx1502_cur."!cursor_pos"($I11)
    ($P10) = rx1502_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1502_pos, "")
    rx1502_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1504_done
  rxcap_1504_fail:
    goto rx1502_fail
  rxcap_1504_done:
  # rx subrule "ws" subtype=method negate=
    rx1502_cur."!cursor_pos"(rx1502_pos)
    $P10 = rx1502_cur."ws"()
    unless $P10, rx1502_fail
    rx1502_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1502_cur."!cursor_pos"(rx1502_pos)
    $P10 = rx1502_cur."EXPR"()
    unless $P10, rx1502_fail
    rx1502_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx1502_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1502_cur."!cursor_pos"(rx1502_pos)
    $P10 = rx1502_cur."ws"()
    unless $P10, rx1502_fail
    rx1502_pos = $P10."pos"()
  # rx pass
    rx1502_cur."!cursor_pass"(rx1502_pos, "statement_mod_cond:sym<unless>")
    if_null rx1502_debug, debug_1036
    rx1502_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<unless>", " at pos=", rx1502_pos)
  debug_1036:
    .return (rx1502_cur)
  rx1502_restart:
.annotate 'line', 435
    if_null rx1502_debug, debug_1037
    rx1502_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<unless>")
  debug_1037:
  rx1502_fail:
    (rx1502_rep, rx1502_pos, $I10, $P10) = rx1502_cur."!mark_fail"(0)
    lt rx1502_pos, -1, rx1502_done
    eq rx1502_pos, -1, rx1502_fail
    jump $I10
  rx1502_done:
    rx1502_cur."!cursor_fail"()
    if_null rx1502_debug, debug_1038
    rx1502_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<unless>")
  debug_1038:
    .return (rx1502_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<unless>"  :subid("125_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P105 = self."!PREFIX__!subrule"("ws", "unless")
    new $P106, "ResizablePMCArray"
    push $P106, $P105
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop"  :subid("126_1310110678.31883")
    .param pmc param_1507
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 687
    .lex "self", param_1507
    $P103 = param_1507."!protoregex"("statement_mod_loop")
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop"  :subid("127_1310110678.31883")
    .param pmc param_1509
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 687
    .lex "self", param_1509
    $P104 = param_1509."!PREFIX__!protoregex"("statement_mod_loop")
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<while>"  :subid("128_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1511_tgt
    .local int rx1511_pos
    .local int rx1511_off
    .local int rx1511_eos
    .local int rx1511_rep
    .local pmc rx1511_cur
    .local pmc rx1511_debug
    (rx1511_cur, rx1511_pos, rx1511_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1511_cur
    .local pmc match
    .lex "$/", match
    length rx1511_eos, rx1511_tgt
    gt rx1511_pos, rx1511_eos, rx1511_done
    set rx1511_off, 0
    lt rx1511_pos, 2, rx1511_start
    sub rx1511_off, rx1511_pos, 1
    substr rx1511_tgt, rx1511_tgt, rx1511_off
  rx1511_start:
    eq $I10, 1, rx1511_restart
    if_null rx1511_debug, debug_1039
    rx1511_cur."!cursor_debug"("START", "statement_mod_loop:sym<while>")
  debug_1039:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1512_done
    goto rxscan1512_scan
  rxscan1512_loop:
    (rx1511_pos) = rx1511_cur."from"()
    inc rx1511_pos
    rx1511_cur."!cursor_from"(rx1511_pos)
    ge rx1511_pos, rx1511_eos, rxscan1512_done
  rxscan1512_scan:
    set_addr $I10, rxscan1512_loop
    rx1511_cur."!mark_push"(0, rx1511_pos, $I10)
  rxscan1512_done:
.annotate 'line', 689
  # rx subcapture "sym"
    set_addr $I10, rxcap_1513_fail
    rx1511_cur."!mark_push"(0, rx1511_pos, $I10)
  # rx literal  "while"
    add $I11, rx1511_pos, 5
    gt $I11, rx1511_eos, rx1511_fail
    sub $I11, rx1511_pos, rx1511_off
    substr $S10, rx1511_tgt, $I11, 5
    ne $S10, "while", rx1511_fail
    add rx1511_pos, 5
    set_addr $I10, rxcap_1513_fail
    ($I12, $I11) = rx1511_cur."!mark_peek"($I10)
    rx1511_cur."!cursor_pos"($I11)
    ($P10) = rx1511_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1511_pos, "")
    rx1511_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1513_done
  rxcap_1513_fail:
    goto rx1511_fail
  rxcap_1513_done:
  # rx subrule "ws" subtype=method negate=
    rx1511_cur."!cursor_pos"(rx1511_pos)
    $P10 = rx1511_cur."ws"()
    unless $P10, rx1511_fail
    rx1511_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1511_cur."!cursor_pos"(rx1511_pos)
    $P10 = rx1511_cur."EXPR"()
    unless $P10, rx1511_fail
    rx1511_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx1511_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1511_cur."!cursor_pos"(rx1511_pos)
    $P10 = rx1511_cur."ws"()
    unless $P10, rx1511_fail
    rx1511_pos = $P10."pos"()
  # rx pass
    rx1511_cur."!cursor_pass"(rx1511_pos, "statement_mod_loop:sym<while>")
    if_null rx1511_debug, debug_1040
    rx1511_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<while>", " at pos=", rx1511_pos)
  debug_1040:
    .return (rx1511_cur)
  rx1511_restart:
.annotate 'line', 435
    if_null rx1511_debug, debug_1041
    rx1511_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<while>")
  debug_1041:
  rx1511_fail:
    (rx1511_rep, rx1511_pos, $I10, $P10) = rx1511_cur."!mark_fail"(0)
    lt rx1511_pos, -1, rx1511_done
    eq rx1511_pos, -1, rx1511_fail
    jump $I10
  rx1511_done:
    rx1511_cur."!cursor_fail"()
    if_null rx1511_debug, debug_1042
    rx1511_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<while>")
  debug_1042:
    .return (rx1511_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<while>"  :subid("129_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P105 = self."!PREFIX__!subrule"("ws", "while")
    new $P106, "ResizablePMCArray"
    push $P106, $P105
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<until>"  :subid("130_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1516_tgt
    .local int rx1516_pos
    .local int rx1516_off
    .local int rx1516_eos
    .local int rx1516_rep
    .local pmc rx1516_cur
    .local pmc rx1516_debug
    (rx1516_cur, rx1516_pos, rx1516_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1516_cur
    .local pmc match
    .lex "$/", match
    length rx1516_eos, rx1516_tgt
    gt rx1516_pos, rx1516_eos, rx1516_done
    set rx1516_off, 0
    lt rx1516_pos, 2, rx1516_start
    sub rx1516_off, rx1516_pos, 1
    substr rx1516_tgt, rx1516_tgt, rx1516_off
  rx1516_start:
    eq $I10, 1, rx1516_restart
    if_null rx1516_debug, debug_1043
    rx1516_cur."!cursor_debug"("START", "statement_mod_loop:sym<until>")
  debug_1043:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1517_done
    goto rxscan1517_scan
  rxscan1517_loop:
    (rx1516_pos) = rx1516_cur."from"()
    inc rx1516_pos
    rx1516_cur."!cursor_from"(rx1516_pos)
    ge rx1516_pos, rx1516_eos, rxscan1517_done
  rxscan1517_scan:
    set_addr $I10, rxscan1517_loop
    rx1516_cur."!mark_push"(0, rx1516_pos, $I10)
  rxscan1517_done:
.annotate 'line', 690
  # rx subcapture "sym"
    set_addr $I10, rxcap_1518_fail
    rx1516_cur."!mark_push"(0, rx1516_pos, $I10)
  # rx literal  "until"
    add $I11, rx1516_pos, 5
    gt $I11, rx1516_eos, rx1516_fail
    sub $I11, rx1516_pos, rx1516_off
    substr $S10, rx1516_tgt, $I11, 5
    ne $S10, "until", rx1516_fail
    add rx1516_pos, 5
    set_addr $I10, rxcap_1518_fail
    ($I12, $I11) = rx1516_cur."!mark_peek"($I10)
    rx1516_cur."!cursor_pos"($I11)
    ($P10) = rx1516_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1516_pos, "")
    rx1516_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1518_done
  rxcap_1518_fail:
    goto rx1516_fail
  rxcap_1518_done:
  # rx subrule "ws" subtype=method negate=
    rx1516_cur."!cursor_pos"(rx1516_pos)
    $P10 = rx1516_cur."ws"()
    unless $P10, rx1516_fail
    rx1516_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1516_cur."!cursor_pos"(rx1516_pos)
    $P10 = rx1516_cur."EXPR"()
    unless $P10, rx1516_fail
    rx1516_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx1516_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1516_cur."!cursor_pos"(rx1516_pos)
    $P10 = rx1516_cur."ws"()
    unless $P10, rx1516_fail
    rx1516_pos = $P10."pos"()
  # rx pass
    rx1516_cur."!cursor_pass"(rx1516_pos, "statement_mod_loop:sym<until>")
    if_null rx1516_debug, debug_1044
    rx1516_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<until>", " at pos=", rx1516_pos)
  debug_1044:
    .return (rx1516_cur)
  rx1516_restart:
.annotate 'line', 435
    if_null rx1516_debug, debug_1045
    rx1516_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<until>")
  debug_1045:
  rx1516_fail:
    (rx1516_rep, rx1516_pos, $I10, $P10) = rx1516_cur."!mark_fail"(0)
    lt rx1516_pos, -1, rx1516_done
    eq rx1516_pos, -1, rx1516_fail
    jump $I10
  rx1516_done:
    rx1516_cur."!cursor_fail"()
    if_null rx1516_debug, debug_1046
    rx1516_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<until>")
  debug_1046:
    .return (rx1516_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<until>"  :subid("131_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P105 = self."!PREFIX__!subrule"("ws", "until")
    new $P106, "ResizablePMCArray"
    push $P106, $P105
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<for>"  :subid("132_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1521_tgt
    .local int rx1521_pos
    .local int rx1521_off
    .local int rx1521_eos
    .local int rx1521_rep
    .local pmc rx1521_cur
    .local pmc rx1521_debug
    (rx1521_cur, rx1521_pos, rx1521_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1521_cur
    .local pmc match
    .lex "$/", match
    length rx1521_eos, rx1521_tgt
    gt rx1521_pos, rx1521_eos, rx1521_done
    set rx1521_off, 0
    lt rx1521_pos, 2, rx1521_start
    sub rx1521_off, rx1521_pos, 1
    substr rx1521_tgt, rx1521_tgt, rx1521_off
  rx1521_start:
    eq $I10, 1, rx1521_restart
    if_null rx1521_debug, debug_1047
    rx1521_cur."!cursor_debug"("START", "statement_mod_loop:sym<for>")
  debug_1047:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1522_done
    goto rxscan1522_scan
  rxscan1522_loop:
    (rx1521_pos) = rx1521_cur."from"()
    inc rx1521_pos
    rx1521_cur."!cursor_from"(rx1521_pos)
    ge rx1521_pos, rx1521_eos, rxscan1522_done
  rxscan1522_scan:
    set_addr $I10, rxscan1522_loop
    rx1521_cur."!mark_push"(0, rx1521_pos, $I10)
  rxscan1522_done:
.annotate 'line', 691
  # rx subcapture "sym"
    set_addr $I10, rxcap_1523_fail
    rx1521_cur."!mark_push"(0, rx1521_pos, $I10)
  # rx literal  "for"
    add $I11, rx1521_pos, 3
    gt $I11, rx1521_eos, rx1521_fail
    sub $I11, rx1521_pos, rx1521_off
    substr $S10, rx1521_tgt, $I11, 3
    ne $S10, "for", rx1521_fail
    add rx1521_pos, 3
    set_addr $I10, rxcap_1523_fail
    ($I12, $I11) = rx1521_cur."!mark_peek"($I10)
    rx1521_cur."!cursor_pos"($I11)
    ($P10) = rx1521_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1521_pos, "")
    rx1521_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1523_done
  rxcap_1523_fail:
    goto rx1521_fail
  rxcap_1523_done:
  # rx subrule "ws" subtype=method negate=
    rx1521_cur."!cursor_pos"(rx1521_pos)
    $P10 = rx1521_cur."ws"()
    unless $P10, rx1521_fail
    rx1521_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1521_cur."!cursor_pos"(rx1521_pos)
    $P10 = rx1521_cur."EXPR"()
    unless $P10, rx1521_fail
    rx1521_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx1521_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1521_cur."!cursor_pos"(rx1521_pos)
    $P10 = rx1521_cur."ws"()
    unless $P10, rx1521_fail
    rx1521_pos = $P10."pos"()
  # rx pass
    rx1521_cur."!cursor_pass"(rx1521_pos, "statement_mod_loop:sym<for>")
    if_null rx1521_debug, debug_1048
    rx1521_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<for>", " at pos=", rx1521_pos)
  debug_1048:
    .return (rx1521_cur)
  rx1521_restart:
.annotate 'line', 435
    if_null rx1521_debug, debug_1049
    rx1521_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<for>")
  debug_1049:
  rx1521_fail:
    (rx1521_rep, rx1521_pos, $I10, $P10) = rx1521_cur."!mark_fail"(0)
    lt rx1521_pos, -1, rx1521_done
    eq rx1521_pos, -1, rx1521_fail
    jump $I10
  rx1521_done:
    rx1521_cur."!cursor_fail"()
    if_null rx1521_debug, debug_1050
    rx1521_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<for>")
  debug_1050:
    .return (rx1521_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<for>"  :subid("133_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P105 = self."!PREFIX__!subrule"("ws", "for")
    new $P106, "ResizablePMCArray"
    push $P106, $P105
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<fatarrow>"  :subid("134_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1526_tgt
    .local int rx1526_pos
    .local int rx1526_off
    .local int rx1526_eos
    .local int rx1526_rep
    .local pmc rx1526_cur
    .local pmc rx1526_debug
    (rx1526_cur, rx1526_pos, rx1526_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1526_cur
    .local pmc match
    .lex "$/", match
    length rx1526_eos, rx1526_tgt
    gt rx1526_pos, rx1526_eos, rx1526_done
    set rx1526_off, 0
    lt rx1526_pos, 2, rx1526_start
    sub rx1526_off, rx1526_pos, 1
    substr rx1526_tgt, rx1526_tgt, rx1526_off
  rx1526_start:
    eq $I10, 1, rx1526_restart
    if_null rx1526_debug, debug_1051
    rx1526_cur."!cursor_debug"("START", "term:sym<fatarrow>")
  debug_1051:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1527_done
    goto rxscan1527_scan
  rxscan1527_loop:
    (rx1526_pos) = rx1526_cur."from"()
    inc rx1526_pos
    rx1526_cur."!cursor_from"(rx1526_pos)
    ge rx1526_pos, rx1526_eos, rxscan1527_done
  rxscan1527_scan:
    set_addr $I10, rxscan1527_loop
    rx1526_cur."!mark_push"(0, rx1526_pos, $I10)
  rxscan1527_done:
.annotate 'line', 695
  # rx subrule "fatarrow" subtype=capture negate=
    rx1526_cur."!cursor_pos"(rx1526_pos)
    $P10 = rx1526_cur."fatarrow"()
    unless $P10, rx1526_fail
    rx1526_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("fatarrow")
    rx1526_pos = $P10."pos"()
  # rx pass
    rx1526_cur."!cursor_pass"(rx1526_pos, "term:sym<fatarrow>")
    if_null rx1526_debug, debug_1052
    rx1526_cur."!cursor_debug"("PASS", "term:sym<fatarrow>", " at pos=", rx1526_pos)
  debug_1052:
    .return (rx1526_cur)
  rx1526_restart:
.annotate 'line', 435
    if_null rx1526_debug, debug_1053
    rx1526_cur."!cursor_debug"("NEXT", "term:sym<fatarrow>")
  debug_1053:
  rx1526_fail:
    (rx1526_rep, rx1526_pos, $I10, $P10) = rx1526_cur."!mark_fail"(0)
    lt rx1526_pos, -1, rx1526_done
    eq rx1526_pos, -1, rx1526_fail
    jump $I10
  rx1526_done:
    rx1526_cur."!cursor_fail"()
    if_null rx1526_debug, debug_1054
    rx1526_cur."!cursor_debug"("FAIL", "term:sym<fatarrow>")
  debug_1054:
    .return (rx1526_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<fatarrow>"  :subid("135_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("fatarrow", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<colonpair>"  :subid("136_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1530_tgt
    .local int rx1530_pos
    .local int rx1530_off
    .local int rx1530_eos
    .local int rx1530_rep
    .local pmc rx1530_cur
    .local pmc rx1530_debug
    (rx1530_cur, rx1530_pos, rx1530_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1530_cur
    .local pmc match
    .lex "$/", match
    length rx1530_eos, rx1530_tgt
    gt rx1530_pos, rx1530_eos, rx1530_done
    set rx1530_off, 0
    lt rx1530_pos, 2, rx1530_start
    sub rx1530_off, rx1530_pos, 1
    substr rx1530_tgt, rx1530_tgt, rx1530_off
  rx1530_start:
    eq $I10, 1, rx1530_restart
    if_null rx1530_debug, debug_1055
    rx1530_cur."!cursor_debug"("START", "term:sym<colonpair>")
  debug_1055:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1531_done
    goto rxscan1531_scan
  rxscan1531_loop:
    (rx1530_pos) = rx1530_cur."from"()
    inc rx1530_pos
    rx1530_cur."!cursor_from"(rx1530_pos)
    ge rx1530_pos, rx1530_eos, rxscan1531_done
  rxscan1531_scan:
    set_addr $I10, rxscan1531_loop
    rx1530_cur."!mark_push"(0, rx1530_pos, $I10)
  rxscan1531_done:
.annotate 'line', 696
  # rx subrule "colonpair" subtype=capture negate=
    rx1530_cur."!cursor_pos"(rx1530_pos)
    $P10 = rx1530_cur."colonpair"()
    unless $P10, rx1530_fail
    rx1530_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("colonpair")
    rx1530_pos = $P10."pos"()
  # rx pass
    rx1530_cur."!cursor_pass"(rx1530_pos, "term:sym<colonpair>")
    if_null rx1530_debug, debug_1056
    rx1530_cur."!cursor_debug"("PASS", "term:sym<colonpair>", " at pos=", rx1530_pos)
  debug_1056:
    .return (rx1530_cur)
  rx1530_restart:
.annotate 'line', 435
    if_null rx1530_debug, debug_1057
    rx1530_cur."!cursor_debug"("NEXT", "term:sym<colonpair>")
  debug_1057:
  rx1530_fail:
    (rx1530_rep, rx1530_pos, $I10, $P10) = rx1530_cur."!mark_fail"(0)
    lt rx1530_pos, -1, rx1530_done
    eq rx1530_pos, -1, rx1530_fail
    jump $I10
  rx1530_done:
    rx1530_cur."!cursor_fail"()
    if_null rx1530_debug, debug_1058
    rx1530_cur."!cursor_debug"("FAIL", "term:sym<colonpair>")
  debug_1058:
    .return (rx1530_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<colonpair>"  :subid("137_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("colonpair", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<variable>"  :subid("138_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1534_tgt
    .local int rx1534_pos
    .local int rx1534_off
    .local int rx1534_eos
    .local int rx1534_rep
    .local pmc rx1534_cur
    .local pmc rx1534_debug
    (rx1534_cur, rx1534_pos, rx1534_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1534_cur
    .local pmc match
    .lex "$/", match
    length rx1534_eos, rx1534_tgt
    gt rx1534_pos, rx1534_eos, rx1534_done
    set rx1534_off, 0
    lt rx1534_pos, 2, rx1534_start
    sub rx1534_off, rx1534_pos, 1
    substr rx1534_tgt, rx1534_tgt, rx1534_off
  rx1534_start:
    eq $I10, 1, rx1534_restart
    if_null rx1534_debug, debug_1059
    rx1534_cur."!cursor_debug"("START", "term:sym<variable>")
  debug_1059:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1535_done
    goto rxscan1535_scan
  rxscan1535_loop:
    (rx1534_pos) = rx1534_cur."from"()
    inc rx1534_pos
    rx1534_cur."!cursor_from"(rx1534_pos)
    ge rx1534_pos, rx1534_eos, rxscan1535_done
  rxscan1535_scan:
    set_addr $I10, rxscan1535_loop
    rx1534_cur."!mark_push"(0, rx1534_pos, $I10)
  rxscan1535_done:
.annotate 'line', 697
  # rx subrule "variable" subtype=capture negate=
    rx1534_cur."!cursor_pos"(rx1534_pos)
    $P10 = rx1534_cur."variable"()
    unless $P10, rx1534_fail
    rx1534_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx1534_pos = $P10."pos"()
  # rx pass
    rx1534_cur."!cursor_pass"(rx1534_pos, "term:sym<variable>")
    if_null rx1534_debug, debug_1060
    rx1534_cur."!cursor_debug"("PASS", "term:sym<variable>", " at pos=", rx1534_pos)
  debug_1060:
    .return (rx1534_cur)
  rx1534_restart:
.annotate 'line', 435
    if_null rx1534_debug, debug_1061
    rx1534_cur."!cursor_debug"("NEXT", "term:sym<variable>")
  debug_1061:
  rx1534_fail:
    (rx1534_rep, rx1534_pos, $I10, $P10) = rx1534_cur."!mark_fail"(0)
    lt rx1534_pos, -1, rx1534_done
    eq rx1534_pos, -1, rx1534_fail
    jump $I10
  rx1534_done:
    rx1534_cur."!cursor_fail"()
    if_null rx1534_debug, debug_1062
    rx1534_cur."!cursor_debug"("FAIL", "term:sym<variable>")
  debug_1062:
    .return (rx1534_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<variable>"  :subid("139_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("variable", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<package_declarator>"  :subid("140_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1538_tgt
    .local int rx1538_pos
    .local int rx1538_off
    .local int rx1538_eos
    .local int rx1538_rep
    .local pmc rx1538_cur
    .local pmc rx1538_debug
    (rx1538_cur, rx1538_pos, rx1538_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1538_cur
    .local pmc match
    .lex "$/", match
    length rx1538_eos, rx1538_tgt
    gt rx1538_pos, rx1538_eos, rx1538_done
    set rx1538_off, 0
    lt rx1538_pos, 2, rx1538_start
    sub rx1538_off, rx1538_pos, 1
    substr rx1538_tgt, rx1538_tgt, rx1538_off
  rx1538_start:
    eq $I10, 1, rx1538_restart
    if_null rx1538_debug, debug_1063
    rx1538_cur."!cursor_debug"("START", "term:sym<package_declarator>")
  debug_1063:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1539_done
    goto rxscan1539_scan
  rxscan1539_loop:
    (rx1538_pos) = rx1538_cur."from"()
    inc rx1538_pos
    rx1538_cur."!cursor_from"(rx1538_pos)
    ge rx1538_pos, rx1538_eos, rxscan1539_done
  rxscan1539_scan:
    set_addr $I10, rxscan1539_loop
    rx1538_cur."!mark_push"(0, rx1538_pos, $I10)
  rxscan1539_done:
.annotate 'line', 698
  # rx subrule "package_declarator" subtype=capture negate=
    rx1538_cur."!cursor_pos"(rx1538_pos)
    $P10 = rx1538_cur."package_declarator"()
    unless $P10, rx1538_fail
    rx1538_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx1538_pos = $P10."pos"()
  # rx pass
    rx1538_cur."!cursor_pass"(rx1538_pos, "term:sym<package_declarator>")
    if_null rx1538_debug, debug_1064
    rx1538_cur."!cursor_debug"("PASS", "term:sym<package_declarator>", " at pos=", rx1538_pos)
  debug_1064:
    .return (rx1538_cur)
  rx1538_restart:
.annotate 'line', 435
    if_null rx1538_debug, debug_1065
    rx1538_cur."!cursor_debug"("NEXT", "term:sym<package_declarator>")
  debug_1065:
  rx1538_fail:
    (rx1538_rep, rx1538_pos, $I10, $P10) = rx1538_cur."!mark_fail"(0)
    lt rx1538_pos, -1, rx1538_done
    eq rx1538_pos, -1, rx1538_fail
    jump $I10
  rx1538_done:
    rx1538_cur."!cursor_fail"()
    if_null rx1538_debug, debug_1066
    rx1538_cur."!cursor_debug"("FAIL", "term:sym<package_declarator>")
  debug_1066:
    .return (rx1538_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<package_declarator>"  :subid("141_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("package_declarator", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<scope_declarator>"  :subid("142_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1542_tgt
    .local int rx1542_pos
    .local int rx1542_off
    .local int rx1542_eos
    .local int rx1542_rep
    .local pmc rx1542_cur
    .local pmc rx1542_debug
    (rx1542_cur, rx1542_pos, rx1542_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1542_cur
    .local pmc match
    .lex "$/", match
    length rx1542_eos, rx1542_tgt
    gt rx1542_pos, rx1542_eos, rx1542_done
    set rx1542_off, 0
    lt rx1542_pos, 2, rx1542_start
    sub rx1542_off, rx1542_pos, 1
    substr rx1542_tgt, rx1542_tgt, rx1542_off
  rx1542_start:
    eq $I10, 1, rx1542_restart
    if_null rx1542_debug, debug_1067
    rx1542_cur."!cursor_debug"("START", "term:sym<scope_declarator>")
  debug_1067:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1543_done
    goto rxscan1543_scan
  rxscan1543_loop:
    (rx1542_pos) = rx1542_cur."from"()
    inc rx1542_pos
    rx1542_cur."!cursor_from"(rx1542_pos)
    ge rx1542_pos, rx1542_eos, rxscan1543_done
  rxscan1543_scan:
    set_addr $I10, rxscan1543_loop
    rx1542_cur."!mark_push"(0, rx1542_pos, $I10)
  rxscan1543_done:
.annotate 'line', 699
  # rx subrule "scope_declarator" subtype=capture negate=
    rx1542_cur."!cursor_pos"(rx1542_pos)
    $P10 = rx1542_cur."scope_declarator"()
    unless $P10, rx1542_fail
    rx1542_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scope_declarator")
    rx1542_pos = $P10."pos"()
  # rx pass
    rx1542_cur."!cursor_pass"(rx1542_pos, "term:sym<scope_declarator>")
    if_null rx1542_debug, debug_1068
    rx1542_cur."!cursor_debug"("PASS", "term:sym<scope_declarator>", " at pos=", rx1542_pos)
  debug_1068:
    .return (rx1542_cur)
  rx1542_restart:
.annotate 'line', 435
    if_null rx1542_debug, debug_1069
    rx1542_cur."!cursor_debug"("NEXT", "term:sym<scope_declarator>")
  debug_1069:
  rx1542_fail:
    (rx1542_rep, rx1542_pos, $I10, $P10) = rx1542_cur."!mark_fail"(0)
    lt rx1542_pos, -1, rx1542_done
    eq rx1542_pos, -1, rx1542_fail
    jump $I10
  rx1542_done:
    rx1542_cur."!cursor_fail"()
    if_null rx1542_debug, debug_1070
    rx1542_cur."!cursor_debug"("FAIL", "term:sym<scope_declarator>")
  debug_1070:
    .return (rx1542_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<scope_declarator>"  :subid("143_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("scope_declarator", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<routine_declarator>"  :subid("144_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1546_tgt
    .local int rx1546_pos
    .local int rx1546_off
    .local int rx1546_eos
    .local int rx1546_rep
    .local pmc rx1546_cur
    .local pmc rx1546_debug
    (rx1546_cur, rx1546_pos, rx1546_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1546_cur
    .local pmc match
    .lex "$/", match
    length rx1546_eos, rx1546_tgt
    gt rx1546_pos, rx1546_eos, rx1546_done
    set rx1546_off, 0
    lt rx1546_pos, 2, rx1546_start
    sub rx1546_off, rx1546_pos, 1
    substr rx1546_tgt, rx1546_tgt, rx1546_off
  rx1546_start:
    eq $I10, 1, rx1546_restart
    if_null rx1546_debug, debug_1071
    rx1546_cur."!cursor_debug"("START", "term:sym<routine_declarator>")
  debug_1071:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1547_done
    goto rxscan1547_scan
  rxscan1547_loop:
    (rx1546_pos) = rx1546_cur."from"()
    inc rx1546_pos
    rx1546_cur."!cursor_from"(rx1546_pos)
    ge rx1546_pos, rx1546_eos, rxscan1547_done
  rxscan1547_scan:
    set_addr $I10, rxscan1547_loop
    rx1546_cur."!mark_push"(0, rx1546_pos, $I10)
  rxscan1547_done:
.annotate 'line', 700
  # rx subrule "routine_declarator" subtype=capture negate=
    rx1546_cur."!cursor_pos"(rx1546_pos)
    $P10 = rx1546_cur."routine_declarator"()
    unless $P10, rx1546_fail
    rx1546_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx1546_pos = $P10."pos"()
  # rx pass
    rx1546_cur."!cursor_pass"(rx1546_pos, "term:sym<routine_declarator>")
    if_null rx1546_debug, debug_1072
    rx1546_cur."!cursor_debug"("PASS", "term:sym<routine_declarator>", " at pos=", rx1546_pos)
  debug_1072:
    .return (rx1546_cur)
  rx1546_restart:
.annotate 'line', 435
    if_null rx1546_debug, debug_1073
    rx1546_cur."!cursor_debug"("NEXT", "term:sym<routine_declarator>")
  debug_1073:
  rx1546_fail:
    (rx1546_rep, rx1546_pos, $I10, $P10) = rx1546_cur."!mark_fail"(0)
    lt rx1546_pos, -1, rx1546_done
    eq rx1546_pos, -1, rx1546_fail
    jump $I10
  rx1546_done:
    rx1546_cur."!cursor_fail"()
    if_null rx1546_debug, debug_1074
    rx1546_cur."!cursor_debug"("FAIL", "term:sym<routine_declarator>")
  debug_1074:
    .return (rx1546_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<routine_declarator>"  :subid("145_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("routine_declarator", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<multi_declarator>"  :subid("146_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .const 'Sub' $P1558 = "148_1310110678.31883" 
    capture_lex $P1558
    .const 'Sub' $P1553 = "147_1310110678.31883" 
    capture_lex $P1553
    .local string rx1550_tgt
    .local int rx1550_pos
    .local int rx1550_off
    .local int rx1550_eos
    .local int rx1550_rep
    .local pmc rx1550_cur
    .local pmc rx1550_debug
    (rx1550_cur, rx1550_pos, rx1550_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1550_cur
    .local pmc match
    .lex "$/", match
    length rx1550_eos, rx1550_tgt
    gt rx1550_pos, rx1550_eos, rx1550_done
    set rx1550_off, 0
    lt rx1550_pos, 2, rx1550_start
    sub rx1550_off, rx1550_pos, 1
    substr rx1550_tgt, rx1550_tgt, rx1550_off
  rx1550_start:
    eq $I10, 1, rx1550_restart
    if_null rx1550_debug, debug_1075
    rx1550_cur."!cursor_debug"("START", "term:sym<multi_declarator>")
  debug_1075:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1551_done
    goto rxscan1551_scan
  rxscan1551_loop:
    (rx1550_pos) = rx1550_cur."from"()
    inc rx1550_pos
    rx1550_cur."!cursor_from"(rx1550_pos)
    ge rx1550_pos, rx1550_eos, rxscan1551_done
  rxscan1551_scan:
    set_addr $I10, rxscan1551_loop
    rx1550_cur."!mark_push"(0, rx1550_pos, $I10)
  rxscan1551_done:
.annotate 'line', 702
  # rx subrule "before" subtype=zerowidth negate=
    rx1550_cur."!cursor_pos"(rx1550_pos)
    .const 'Sub' $P1553 = "147_1310110678.31883" 
    capture_lex $P1553
    $P10 = rx1550_cur."before"($P1553)
    unless $P10, rx1550_fail
.annotate 'line', 703
  # rx subrule "before" subtype=zerowidth negate=1
    rx1550_cur."!cursor_pos"(rx1550_pos)
    .const 'Sub' $P1558 = "148_1310110678.31883" 
    capture_lex $P1558
    $P10 = rx1550_cur."before"($P1558)
    if $P10, rx1550_fail
.annotate 'line', 704
  # rx subrule "multi_declarator" subtype=capture negate=
    rx1550_cur."!cursor_pos"(rx1550_pos)
    $P10 = rx1550_cur."multi_declarator"()
    unless $P10, rx1550_fail
    rx1550_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx1550_pos = $P10."pos"()
.annotate 'line', 701
  # rx pass
    rx1550_cur."!cursor_pass"(rx1550_pos, "term:sym<multi_declarator>")
    if_null rx1550_debug, debug_1084
    rx1550_cur."!cursor_debug"("PASS", "term:sym<multi_declarator>", " at pos=", rx1550_pos)
  debug_1084:
    .return (rx1550_cur)
  rx1550_restart:
.annotate 'line', 435
    if_null rx1550_debug, debug_1085
    rx1550_cur."!cursor_debug"("NEXT", "term:sym<multi_declarator>")
  debug_1085:
  rx1550_fail:
    (rx1550_rep, rx1550_pos, $I10, $P10) = rx1550_cur."!mark_fail"(0)
    lt rx1550_pos, -1, rx1550_done
    eq rx1550_pos, -1, rx1550_fail
    jump $I10
  rx1550_done:
    rx1550_cur."!cursor_fail"()
    if_null rx1550_debug, debug_1086
    rx1550_cur."!cursor_debug"("FAIL", "term:sym<multi_declarator>")
  debug_1086:
    .return (rx1550_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1552"  :anon :subid("147_1310110678.31883") :method :outer("146_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 702
    .local string rx1554_tgt
    .local int rx1554_pos
    .local int rx1554_off
    .local int rx1554_eos
    .local int rx1554_rep
    .local pmc rx1554_cur
    .local pmc rx1554_debug
    (rx1554_cur, rx1554_pos, rx1554_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1554_cur
    .local pmc match
    .lex "$/", match
    length rx1554_eos, rx1554_tgt
    gt rx1554_pos, rx1554_eos, rx1554_done
    set rx1554_off, 0
    lt rx1554_pos, 2, rx1554_start
    sub rx1554_off, rx1554_pos, 1
    substr rx1554_tgt, rx1554_tgt, rx1554_off
  rx1554_start:
    eq $I10, 1, rx1554_restart
    if_null rx1554_debug, debug_1076
    rx1554_cur."!cursor_debug"("START", "")
  debug_1076:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1555_done
    goto rxscan1555_scan
  rxscan1555_loop:
    (rx1554_pos) = rx1554_cur."from"()
    inc rx1554_pos
    rx1554_cur."!cursor_from"(rx1554_pos)
    ge rx1554_pos, rx1554_eos, rxscan1555_done
  rxscan1555_scan:
    set_addr $I10, rxscan1555_loop
    rx1554_cur."!mark_push"(0, rx1554_pos, $I10)
  rxscan1555_done:
  alt1556_0:
    set_addr $I10, alt1556_1
    rx1554_cur."!mark_push"(0, rx1554_pos, $I10)
  # rx literal  "multi"
    add $I11, rx1554_pos, 5
    gt $I11, rx1554_eos, rx1554_fail
    sub $I11, rx1554_pos, rx1554_off
    substr $S10, rx1554_tgt, $I11, 5
    ne $S10, "multi", rx1554_fail
    add rx1554_pos, 5
    goto alt1556_end
  alt1556_1:
    set_addr $I10, alt1556_2
    rx1554_cur."!mark_push"(0, rx1554_pos, $I10)
  # rx literal  "proto"
    add $I11, rx1554_pos, 5
    gt $I11, rx1554_eos, rx1554_fail
    sub $I11, rx1554_pos, rx1554_off
    substr $S10, rx1554_tgt, $I11, 5
    ne $S10, "proto", rx1554_fail
    add rx1554_pos, 5
    goto alt1556_end
  alt1556_2:
  # rx literal  "only"
    add $I11, rx1554_pos, 4
    gt $I11, rx1554_eos, rx1554_fail
    sub $I11, rx1554_pos, rx1554_off
    substr $S10, rx1554_tgt, $I11, 4
    ne $S10, "only", rx1554_fail
    add rx1554_pos, 4
  alt1556_end:
  # rx pass
    rx1554_cur."!cursor_pass"(rx1554_pos, "")
    if_null rx1554_debug, debug_1077
    rx1554_cur."!cursor_debug"("PASS", "", " at pos=", rx1554_pos)
  debug_1077:
    .return (rx1554_cur)
  rx1554_restart:
    if_null rx1554_debug, debug_1078
    rx1554_cur."!cursor_debug"("NEXT", "")
  debug_1078:
  rx1554_fail:
    (rx1554_rep, rx1554_pos, $I10, $P10) = rx1554_cur."!mark_fail"(0)
    lt rx1554_pos, -1, rx1554_done
    eq rx1554_pos, -1, rx1554_fail
    jump $I10
  rx1554_done:
    rx1554_cur."!cursor_fail"()
    if_null rx1554_debug, debug_1079
    rx1554_cur."!cursor_debug"("FAIL", "")
  debug_1079:
    .return (rx1554_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1557"  :anon :subid("148_1310110678.31883") :method :outer("146_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 703
    .local string rx1559_tgt
    .local int rx1559_pos
    .local int rx1559_off
    .local int rx1559_eos
    .local int rx1559_rep
    .local pmc rx1559_cur
    .local pmc rx1559_debug
    (rx1559_cur, rx1559_pos, rx1559_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1559_cur
    .local pmc match
    .lex "$/", match
    length rx1559_eos, rx1559_tgt
    gt rx1559_pos, rx1559_eos, rx1559_done
    set rx1559_off, 0
    lt rx1559_pos, 2, rx1559_start
    sub rx1559_off, rx1559_pos, 1
    substr rx1559_tgt, rx1559_tgt, rx1559_off
  rx1559_start:
    eq $I10, 1, rx1559_restart
    if_null rx1559_debug, debug_1080
    rx1559_cur."!cursor_debug"("START", "")
  debug_1080:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1560_done
    goto rxscan1560_scan
  rxscan1560_loop:
    (rx1559_pos) = rx1559_cur."from"()
    inc rx1559_pos
    rx1559_cur."!cursor_from"(rx1559_pos)
    ge rx1559_pos, rx1559_eos, rxscan1560_done
  rxscan1560_scan:
    set_addr $I10, rxscan1560_loop
    rx1559_cur."!mark_push"(0, rx1559_pos, $I10)
  rxscan1560_done:
  # rx literal  "proto"
    add $I11, rx1559_pos, 5
    gt $I11, rx1559_eos, rx1559_fail
    sub $I11, rx1559_pos, rx1559_off
    substr $S10, rx1559_tgt, $I11, 5
    ne $S10, "proto", rx1559_fail
    add rx1559_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx1559_cur."!cursor_pos"(rx1559_pos)
    $P10 = rx1559_cur."ws"()
    unless $P10, rx1559_fail
    rx1559_pos = $P10."pos"()
  alt1561_0:
    set_addr $I10, alt1561_1
    rx1559_cur."!mark_push"(0, rx1559_pos, $I10)
  # rx literal  "regex"
    add $I11, rx1559_pos, 5
    gt $I11, rx1559_eos, rx1559_fail
    sub $I11, rx1559_pos, rx1559_off
    substr $S10, rx1559_tgt, $I11, 5
    ne $S10, "regex", rx1559_fail
    add rx1559_pos, 5
    goto alt1561_end
  alt1561_1:
    set_addr $I10, alt1561_2
    rx1559_cur."!mark_push"(0, rx1559_pos, $I10)
  # rx literal  "token"
    add $I11, rx1559_pos, 5
    gt $I11, rx1559_eos, rx1559_fail
    sub $I11, rx1559_pos, rx1559_off
    substr $S10, rx1559_tgt, $I11, 5
    ne $S10, "token", rx1559_fail
    add rx1559_pos, 5
    goto alt1561_end
  alt1561_2:
  # rx literal  "rule"
    add $I11, rx1559_pos, 4
    gt $I11, rx1559_eos, rx1559_fail
    sub $I11, rx1559_pos, rx1559_off
    substr $S10, rx1559_tgt, $I11, 4
    ne $S10, "rule", rx1559_fail
    add rx1559_pos, 4
  alt1561_end:
  # rx pass
    rx1559_cur."!cursor_pass"(rx1559_pos, "")
    if_null rx1559_debug, debug_1081
    rx1559_cur."!cursor_debug"("PASS", "", " at pos=", rx1559_pos)
  debug_1081:
    .return (rx1559_cur)
  rx1559_restart:
    if_null rx1559_debug, debug_1082
    rx1559_cur."!cursor_debug"("NEXT", "")
  debug_1082:
  rx1559_fail:
    (rx1559_rep, rx1559_pos, $I10, $P10) = rx1559_cur."!mark_fail"(0)
    lt rx1559_pos, -1, rx1559_done
    eq rx1559_pos, -1, rx1559_fail
    jump $I10
  rx1559_done:
    rx1559_cur."!cursor_fail"()
    if_null rx1559_debug, debug_1083
    rx1559_cur."!cursor_debug"("FAIL", "")
  debug_1083:
    .return (rx1559_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<multi_declarator>"  :subid("149_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<regex_declarator>"  :subid("150_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1564_tgt
    .local int rx1564_pos
    .local int rx1564_off
    .local int rx1564_eos
    .local int rx1564_rep
    .local pmc rx1564_cur
    .local pmc rx1564_debug
    (rx1564_cur, rx1564_pos, rx1564_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1564_cur
    .local pmc match
    .lex "$/", match
    length rx1564_eos, rx1564_tgt
    gt rx1564_pos, rx1564_eos, rx1564_done
    set rx1564_off, 0
    lt rx1564_pos, 2, rx1564_start
    sub rx1564_off, rx1564_pos, 1
    substr rx1564_tgt, rx1564_tgt, rx1564_off
  rx1564_start:
    eq $I10, 1, rx1564_restart
    if_null rx1564_debug, debug_1087
    rx1564_cur."!cursor_debug"("START", "term:sym<regex_declarator>")
  debug_1087:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1565_done
    goto rxscan1565_scan
  rxscan1565_loop:
    (rx1564_pos) = rx1564_cur."from"()
    inc rx1564_pos
    rx1564_cur."!cursor_from"(rx1564_pos)
    ge rx1564_pos, rx1564_eos, rxscan1565_done
  rxscan1565_scan:
    set_addr $I10, rxscan1565_loop
    rx1564_cur."!mark_push"(0, rx1564_pos, $I10)
  rxscan1565_done:
.annotate 'line', 706
  # rx subrule "regex_declarator" subtype=capture negate=
    rx1564_cur."!cursor_pos"(rx1564_pos)
    $P10 = rx1564_cur."regex_declarator"()
    unless $P10, rx1564_fail
    rx1564_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("regex_declarator")
    rx1564_pos = $P10."pos"()
  # rx pass
    rx1564_cur."!cursor_pass"(rx1564_pos, "term:sym<regex_declarator>")
    if_null rx1564_debug, debug_1088
    rx1564_cur."!cursor_debug"("PASS", "term:sym<regex_declarator>", " at pos=", rx1564_pos)
  debug_1088:
    .return (rx1564_cur)
  rx1564_restart:
.annotate 'line', 435
    if_null rx1564_debug, debug_1089
    rx1564_cur."!cursor_debug"("NEXT", "term:sym<regex_declarator>")
  debug_1089:
  rx1564_fail:
    (rx1564_rep, rx1564_pos, $I10, $P10) = rx1564_cur."!mark_fail"(0)
    lt rx1564_pos, -1, rx1564_done
    eq rx1564_pos, -1, rx1564_fail
    jump $I10
  rx1564_done:
    rx1564_cur."!cursor_fail"()
    if_null rx1564_debug, debug_1090
    rx1564_cur."!cursor_debug"("FAIL", "term:sym<regex_declarator>")
  debug_1090:
    .return (rx1564_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<regex_declarator>"  :subid("151_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("regex_declarator", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<statement_prefix>"  :subid("152_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1568_tgt
    .local int rx1568_pos
    .local int rx1568_off
    .local int rx1568_eos
    .local int rx1568_rep
    .local pmc rx1568_cur
    .local pmc rx1568_debug
    (rx1568_cur, rx1568_pos, rx1568_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1568_cur
    .local pmc match
    .lex "$/", match
    length rx1568_eos, rx1568_tgt
    gt rx1568_pos, rx1568_eos, rx1568_done
    set rx1568_off, 0
    lt rx1568_pos, 2, rx1568_start
    sub rx1568_off, rx1568_pos, 1
    substr rx1568_tgt, rx1568_tgt, rx1568_off
  rx1568_start:
    eq $I10, 1, rx1568_restart
    if_null rx1568_debug, debug_1091
    rx1568_cur."!cursor_debug"("START", "term:sym<statement_prefix>")
  debug_1091:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1569_done
    goto rxscan1569_scan
  rxscan1569_loop:
    (rx1568_pos) = rx1568_cur."from"()
    inc rx1568_pos
    rx1568_cur."!cursor_from"(rx1568_pos)
    ge rx1568_pos, rx1568_eos, rxscan1569_done
  rxscan1569_scan:
    set_addr $I10, rxscan1569_loop
    rx1568_cur."!mark_push"(0, rx1568_pos, $I10)
  rxscan1569_done:
.annotate 'line', 707
  # rx subrule "statement_prefix" subtype=capture negate=
    rx1568_cur."!cursor_pos"(rx1568_pos)
    $P10 = rx1568_cur."statement_prefix"()
    unless $P10, rx1568_fail
    rx1568_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_prefix")
    rx1568_pos = $P10."pos"()
  # rx pass
    rx1568_cur."!cursor_pass"(rx1568_pos, "term:sym<statement_prefix>")
    if_null rx1568_debug, debug_1092
    rx1568_cur."!cursor_debug"("PASS", "term:sym<statement_prefix>", " at pos=", rx1568_pos)
  debug_1092:
    .return (rx1568_cur)
  rx1568_restart:
.annotate 'line', 435
    if_null rx1568_debug, debug_1093
    rx1568_cur."!cursor_debug"("NEXT", "term:sym<statement_prefix>")
  debug_1093:
  rx1568_fail:
    (rx1568_rep, rx1568_pos, $I10, $P10) = rx1568_cur."!mark_fail"(0)
    lt rx1568_pos, -1, rx1568_done
    eq rx1568_pos, -1, rx1568_fail
    jump $I10
  rx1568_done:
    rx1568_cur."!cursor_fail"()
    if_null rx1568_debug, debug_1094
    rx1568_cur."!cursor_debug"("FAIL", "term:sym<statement_prefix>")
  debug_1094:
    .return (rx1568_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<statement_prefix>"  :subid("153_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("statement_prefix", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<lambda>"  :subid("154_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1572_tgt
    .local int rx1572_pos
    .local int rx1572_off
    .local int rx1572_eos
    .local int rx1572_rep
    .local pmc rx1572_cur
    .local pmc rx1572_debug
    (rx1572_cur, rx1572_pos, rx1572_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1572_cur
    .local pmc match
    .lex "$/", match
    length rx1572_eos, rx1572_tgt
    gt rx1572_pos, rx1572_eos, rx1572_done
    set rx1572_off, 0
    lt rx1572_pos, 2, rx1572_start
    sub rx1572_off, rx1572_pos, 1
    substr rx1572_tgt, rx1572_tgt, rx1572_off
  rx1572_start:
    eq $I10, 1, rx1572_restart
    if_null rx1572_debug, debug_1095
    rx1572_cur."!cursor_debug"("START", "term:sym<lambda>")
  debug_1095:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1573_done
    goto rxscan1573_scan
  rxscan1573_loop:
    (rx1572_pos) = rx1572_cur."from"()
    inc rx1572_pos
    rx1572_cur."!cursor_from"(rx1572_pos)
    ge rx1572_pos, rx1572_eos, rxscan1573_done
  rxscan1573_scan:
    set_addr $I10, rxscan1573_loop
    rx1572_cur."!mark_push"(0, rx1572_pos, $I10)
  rxscan1573_done:
.annotate 'line', 708
  # rx subrule "lambda" subtype=zerowidth negate=
    rx1572_cur."!cursor_pos"(rx1572_pos)
    $P10 = rx1572_cur."lambda"()
    unless $P10, rx1572_fail
  # rx subrule "pblock" subtype=capture negate=
    rx1572_cur."!cursor_pos"(rx1572_pos)
    $P10 = rx1572_cur."pblock"()
    unless $P10, rx1572_fail
    rx1572_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx1572_pos = $P10."pos"()
  # rx pass
    rx1572_cur."!cursor_pass"(rx1572_pos, "term:sym<lambda>")
    if_null rx1572_debug, debug_1096
    rx1572_cur."!cursor_debug"("PASS", "term:sym<lambda>", " at pos=", rx1572_pos)
  debug_1096:
    .return (rx1572_cur)
  rx1572_restart:
.annotate 'line', 435
    if_null rx1572_debug, debug_1097
    rx1572_cur."!cursor_debug"("NEXT", "term:sym<lambda>")
  debug_1097:
  rx1572_fail:
    (rx1572_rep, rx1572_pos, $I10, $P10) = rx1572_cur."!mark_fail"(0)
    lt rx1572_pos, -1, rx1572_done
    eq rx1572_pos, -1, rx1572_fail
    jump $I10
  rx1572_done:
    rx1572_cur."!cursor_fail"()
    if_null rx1572_debug, debug_1098
    rx1572_cur."!cursor_debug"("FAIL", "term:sym<lambda>")
  debug_1098:
    .return (rx1572_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<lambda>"  :subid("155_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "fatarrow"  :subid("156_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1576_tgt
    .local int rx1576_pos
    .local int rx1576_off
    .local int rx1576_eos
    .local int rx1576_rep
    .local pmc rx1576_cur
    .local pmc rx1576_debug
    (rx1576_cur, rx1576_pos, rx1576_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1576_cur
    .local pmc match
    .lex "$/", match
    length rx1576_eos, rx1576_tgt
    gt rx1576_pos, rx1576_eos, rx1576_done
    set rx1576_off, 0
    lt rx1576_pos, 2, rx1576_start
    sub rx1576_off, rx1576_pos, 1
    substr rx1576_tgt, rx1576_tgt, rx1576_off
  rx1576_start:
    eq $I10, 1, rx1576_restart
    if_null rx1576_debug, debug_1099
    rx1576_cur."!cursor_debug"("START", "fatarrow")
  debug_1099:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1577_done
    goto rxscan1577_scan
  rxscan1577_loop:
    (rx1576_pos) = rx1576_cur."from"()
    inc rx1576_pos
    rx1576_cur."!cursor_from"(rx1576_pos)
    ge rx1576_pos, rx1576_eos, rxscan1577_done
  rxscan1577_scan:
    set_addr $I10, rxscan1577_loop
    rx1576_cur."!mark_push"(0, rx1576_pos, $I10)
  rxscan1577_done:
.annotate 'line', 711
  # rx subrule "identifier" subtype=capture negate=
    rx1576_cur."!cursor_pos"(rx1576_pos)
    $P10 = rx1576_cur."identifier"()
    unless $P10, rx1576_fail
    rx1576_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("key")
    rx1576_pos = $P10."pos"()
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1576_pos, rx1576_off
    set rx1576_rep, 0
    sub $I12, rx1576_eos, rx1576_pos
  rxenumcharlistq1578_loop:
    le $I12, 0, rxenumcharlistq1578_done
    substr $S10, rx1576_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1578_done
    inc rx1576_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1578_loop
  rxenumcharlistq1578_done:
    add rx1576_pos, rx1576_pos, rx1576_rep
  # rx literal  "=>"
    add $I11, rx1576_pos, 2
    gt $I11, rx1576_eos, rx1576_fail
    sub $I11, rx1576_pos, rx1576_off
    substr $S10, rx1576_tgt, $I11, 2
    ne $S10, "=>", rx1576_fail
    add rx1576_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx1576_cur."!cursor_pos"(rx1576_pos)
    $P10 = rx1576_cur."ws"()
    unless $P10, rx1576_fail
    rx1576_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1576_cur."!cursor_pos"(rx1576_pos)
    $P10 = rx1576_cur."EXPR"("i=")
    unless $P10, rx1576_fail
    rx1576_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("val")
    rx1576_pos = $P10."pos"()
.annotate 'line', 710
  # rx pass
    rx1576_cur."!cursor_pass"(rx1576_pos, "fatarrow")
    if_null rx1576_debug, debug_1100
    rx1576_cur."!cursor_debug"("PASS", "fatarrow", " at pos=", rx1576_pos)
  debug_1100:
    .return (rx1576_cur)
  rx1576_restart:
.annotate 'line', 435
    if_null rx1576_debug, debug_1101
    rx1576_cur."!cursor_debug"("NEXT", "fatarrow")
  debug_1101:
  rx1576_fail:
    (rx1576_rep, rx1576_pos, $I10, $P10) = rx1576_cur."!mark_fail"(0)
    lt rx1576_pos, -1, rx1576_done
    eq rx1576_pos, -1, rx1576_fail
    jump $I10
  rx1576_done:
    rx1576_cur."!cursor_fail"()
    if_null rx1576_debug, debug_1102
    rx1576_cur."!cursor_debug"("FAIL", "fatarrow")
  debug_1102:
    .return (rx1576_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__fatarrow"  :subid("157_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("identifier", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "colonpair"  :subid("158_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1581_tgt
    .local int rx1581_pos
    .local int rx1581_off
    .local int rx1581_eos
    .local int rx1581_rep
    .local pmc rx1581_cur
    .local pmc rx1581_debug
    (rx1581_cur, rx1581_pos, rx1581_tgt, $I10) = self."!cursor_start"()
    rx1581_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx1581_cur
    .local pmc match
    .lex "$/", match
    length rx1581_eos, rx1581_tgt
    gt rx1581_pos, rx1581_eos, rx1581_done
    set rx1581_off, 0
    lt rx1581_pos, 2, rx1581_start
    sub rx1581_off, rx1581_pos, 1
    substr rx1581_tgt, rx1581_tgt, rx1581_off
  rx1581_start:
    eq $I10, 1, rx1581_restart
    if_null rx1581_debug, debug_1103
    rx1581_cur."!cursor_debug"("START", "colonpair")
  debug_1103:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1582_done
    goto rxscan1582_scan
  rxscan1582_loop:
    (rx1581_pos) = rx1581_cur."from"()
    inc rx1581_pos
    rx1581_cur."!cursor_from"(rx1581_pos)
    ge rx1581_pos, rx1581_eos, rxscan1582_done
  rxscan1582_scan:
    set_addr $I10, rxscan1582_loop
    rx1581_cur."!mark_push"(0, rx1581_pos, $I10)
  rxscan1582_done:
.annotate 'line', 715
  # rx literal  ":"
    add $I11, rx1581_pos, 1
    gt $I11, rx1581_eos, rx1581_fail
    sub $I11, rx1581_pos, rx1581_off
    ord $I11, rx1581_tgt, $I11
    ne $I11, 58, rx1581_fail
    add rx1581_pos, 1
  alt1583_0:
.annotate 'line', 716
    set_addr $I10, alt1583_1
    rx1581_cur."!mark_push"(0, rx1581_pos, $I10)
.annotate 'line', 717
  # rx subcapture "not"
    set_addr $I10, rxcap_1584_fail
    rx1581_cur."!mark_push"(0, rx1581_pos, $I10)
  # rx literal  "!"
    add $I11, rx1581_pos, 1
    gt $I11, rx1581_eos, rx1581_fail
    sub $I11, rx1581_pos, rx1581_off
    ord $I11, rx1581_tgt, $I11
    ne $I11, 33, rx1581_fail
    add rx1581_pos, 1
    set_addr $I10, rxcap_1584_fail
    ($I12, $I11) = rx1581_cur."!mark_peek"($I10)
    rx1581_cur."!cursor_pos"($I11)
    ($P10) = rx1581_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1581_pos, "")
    rx1581_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("not")
    goto rxcap_1584_done
  rxcap_1584_fail:
    goto rx1581_fail
  rxcap_1584_done:
  # rx subrule "identifier" subtype=capture negate=
    rx1581_cur."!cursor_pos"(rx1581_pos)
    $P10 = rx1581_cur."identifier"()
    unless $P10, rx1581_fail
    rx1581_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx1581_pos = $P10."pos"()
    goto alt1583_end
  alt1583_1:
    set_addr $I10, alt1583_2
    rx1581_cur."!mark_push"(0, rx1581_pos, $I10)
.annotate 'line', 718
  # rx subrule "identifier" subtype=capture negate=
    rx1581_cur."!cursor_pos"(rx1581_pos)
    $P10 = rx1581_cur."identifier"()
    unless $P10, rx1581_fail
    rx1581_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx1581_pos = $P10."pos"()
  # rx rxquantr1585 ** 0..1
    set_addr $I10, rxquantr1585_done
    rx1581_cur."!mark_push"(0, rx1581_pos, $I10)
  rxquantr1585_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx1581_cur."!cursor_pos"(rx1581_pos)
    $P10 = rx1581_cur."circumfix"()
    unless $P10, rx1581_fail
    goto rxsubrule1586_pass
  rxsubrule1586_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1581_fail
  rxsubrule1586_pass:
    set_addr $I10, rxsubrule1586_back
    rx1581_cur."!mark_push"(0, rx1581_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx1581_pos = $P10."pos"()
    set_addr $I10, rxquantr1585_done
    (rx1581_rep) = rx1581_cur."!mark_commit"($I10)
  rxquantr1585_done:
    goto alt1583_end
  alt1583_2:
.annotate 'line', 719
  # rx subrule "circumfix" subtype=capture negate=
    rx1581_cur."!cursor_pos"(rx1581_pos)
    $P10 = rx1581_cur."circumfix"()
    unless $P10, rx1581_fail
    rx1581_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("circumfix")
    rx1581_pos = $P10."pos"()
  alt1583_end:
.annotate 'line', 714
  # rx pass
    rx1581_cur."!cursor_pass"(rx1581_pos, "colonpair")
    if_null rx1581_debug, debug_1104
    rx1581_cur."!cursor_debug"("PASS", "colonpair", " at pos=", rx1581_pos)
  debug_1104:
    .return (rx1581_cur)
  rx1581_restart:
.annotate 'line', 435
    if_null rx1581_debug, debug_1105
    rx1581_cur."!cursor_debug"("NEXT", "colonpair")
  debug_1105:
  rx1581_fail:
    (rx1581_rep, rx1581_pos, $I10, $P10) = rx1581_cur."!mark_fail"(0)
    lt rx1581_pos, -1, rx1581_done
    eq rx1581_pos, -1, rx1581_fail
    jump $I10
  rx1581_done:
    rx1581_cur."!cursor_fail"()
    if_null rx1581_debug, debug_1106
    rx1581_cur."!cursor_debug"("FAIL", "colonpair")
  debug_1106:
    .return (rx1581_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__colonpair"  :subid("159_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("circumfix", ":")
    $P104 = self."!PREFIX__!subrule"("identifier", ":")
    $P105 = self."!PREFIX__!subrule"("identifier", ":!")
    new $P106, "ResizablePMCArray"
    push $P106, $P103
    push $P106, $P104
    push $P106, $P105
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable"  :subid("160_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1589_tgt
    .local int rx1589_pos
    .local int rx1589_off
    .local int rx1589_eos
    .local int rx1589_rep
    .local pmc rx1589_cur
    .local pmc rx1589_debug
    (rx1589_cur, rx1589_pos, rx1589_tgt, $I10) = self."!cursor_start"()
    rx1589_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx1589_cur
    .local pmc match
    .lex "$/", match
    length rx1589_eos, rx1589_tgt
    gt rx1589_pos, rx1589_eos, rx1589_done
    set rx1589_off, 0
    lt rx1589_pos, 2, rx1589_start
    sub rx1589_off, rx1589_pos, 1
    substr rx1589_tgt, rx1589_tgt, rx1589_off
  rx1589_start:
    eq $I10, 1, rx1589_restart
    if_null rx1589_debug, debug_1107
    rx1589_cur."!cursor_debug"("START", "variable")
  debug_1107:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1590_done
    goto rxscan1590_scan
  rxscan1590_loop:
    (rx1589_pos) = rx1589_cur."from"()
    inc rx1589_pos
    rx1589_cur."!cursor_from"(rx1589_pos)
    ge rx1589_pos, rx1589_eos, rxscan1590_done
  rxscan1590_scan:
    set_addr $I10, rxscan1590_loop
    rx1589_cur."!mark_push"(0, rx1589_pos, $I10)
  rxscan1590_done:
  alt1591_0:
.annotate 'line', 723
    set_addr $I10, alt1591_1
    rx1589_cur."!mark_push"(0, rx1589_pos, $I10)
.annotate 'line', 724
  # rx subrule "sigil" subtype=capture negate=
    rx1589_cur."!cursor_pos"(rx1589_pos)
    $P10 = rx1589_cur."sigil"()
    unless $P10, rx1589_fail
    rx1589_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1589_pos = $P10."pos"()
  # rx rxquantr1592 ** 0..1
    set_addr $I10, rxquantr1592_done
    rx1589_cur."!mark_push"(0, rx1589_pos, $I10)
  rxquantr1592_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx1589_cur."!cursor_pos"(rx1589_pos)
    $P10 = rx1589_cur."twigil"()
    unless $P10, rx1589_fail
    goto rxsubrule1593_pass
  rxsubrule1593_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1589_fail
  rxsubrule1593_pass:
    set_addr $I10, rxsubrule1593_back
    rx1589_cur."!mark_push"(0, rx1589_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx1589_pos = $P10."pos"()
    set_addr $I10, rxquantr1592_done
    (rx1589_rep) = rx1589_cur."!mark_commit"($I10)
  rxquantr1592_done:
  # rx subrule "name" subtype=capture negate=
    rx1589_cur."!cursor_pos"(rx1589_pos)
    $P10 = rx1589_cur."name"()
    unless $P10, rx1589_fail
    rx1589_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    rx1589_pos = $P10."pos"()
    goto alt1591_end
  alt1591_1:
    set_addr $I10, alt1591_2
    rx1589_cur."!mark_push"(0, rx1589_pos, $I10)
.annotate 'line', 725
  # rx subrule "sigil" subtype=capture negate=
    rx1589_cur."!cursor_pos"(rx1589_pos)
    $P10 = rx1589_cur."sigil"()
    unless $P10, rx1589_fail
    rx1589_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1589_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1589_pos, rx1589_off
    substr $S10, rx1589_tgt, $I10, 1
    index $I11, "<[", $S10
    lt $I11, 0, rx1589_fail
  # rx subrule "postcircumfix" subtype=capture negate=
    rx1589_cur."!cursor_pos"(rx1589_pos)
    $P10 = rx1589_cur."postcircumfix"()
    unless $P10, rx1589_fail
    rx1589_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("postcircumfix")
    rx1589_pos = $P10."pos"()
    goto alt1591_end
  alt1591_2:
.annotate 'line', 726
  # rx subcapture "sigil"
    set_addr $I10, rxcap_1594_fail
    rx1589_cur."!mark_push"(0, rx1589_pos, $I10)
  # rx literal  "$"
    add $I11, rx1589_pos, 1
    gt $I11, rx1589_eos, rx1589_fail
    sub $I11, rx1589_pos, rx1589_off
    ord $I11, rx1589_tgt, $I11
    ne $I11, 36, rx1589_fail
    add rx1589_pos, 1
    set_addr $I10, rxcap_1594_fail
    ($I12, $I11) = rx1589_cur."!mark_peek"($I10)
    rx1589_cur."!cursor_pos"($I11)
    ($P10) = rx1589_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1589_pos, "")
    rx1589_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_1594_done
  rxcap_1594_fail:
    goto rx1589_fail
  rxcap_1594_done:
  # rx subcapture "desigilname"
    set_addr $I10, rxcap_1595_fail
    rx1589_cur."!mark_push"(0, rx1589_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1589_pos, rx1589_eos, rx1589_fail
    sub $I10, rx1589_pos, rx1589_off
    substr $S10, rx1589_tgt, $I10, 1
    index $I11, "/_!", $S10
    lt $I11, 0, rx1589_fail
    inc rx1589_pos
    set_addr $I10, rxcap_1595_fail
    ($I12, $I11) = rx1589_cur."!mark_peek"($I10)
    rx1589_cur."!cursor_pos"($I11)
    ($P10) = rx1589_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1589_pos, "")
    rx1589_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    goto rxcap_1595_done
  rxcap_1595_fail:
    goto rx1589_fail
  rxcap_1595_done:
  alt1591_end:
.annotate 'line', 723
  # rx pass
    rx1589_cur."!cursor_pass"(rx1589_pos, "variable")
    if_null rx1589_debug, debug_1108
    rx1589_cur."!cursor_debug"("PASS", "variable", " at pos=", rx1589_pos)
  debug_1108:
    .return (rx1589_cur)
  rx1589_restart:
.annotate 'line', 435
    if_null rx1589_debug, debug_1109
    rx1589_cur."!cursor_debug"("NEXT", "variable")
  debug_1109:
  rx1589_fail:
    (rx1589_rep, rx1589_pos, $I10, $P10) = rx1589_cur."!mark_fail"(0)
    lt rx1589_pos, -1, rx1589_done
    eq rx1589_pos, -1, rx1589_fail
    jump $I10
  rx1589_done:
    rx1589_cur."!cursor_fail"()
    if_null rx1589_debug, debug_1110
    rx1589_cur."!cursor_debug"("FAIL", "variable")
  debug_1110:
    .return (rx1589_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable"  :subid("161_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("sigil", "")
    $P104 = self."!PREFIX__!subrule"("sigil", "")
    new $P105, "ResizablePMCArray"
    push $P105, "/"
    push $P105, "_"
    push $P105, "!"
    push $P105, $P103
    push $P105, $P104
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "sigil"  :subid("162_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1598_tgt
    .local int rx1598_pos
    .local int rx1598_off
    .local int rx1598_eos
    .local int rx1598_rep
    .local pmc rx1598_cur
    .local pmc rx1598_debug
    (rx1598_cur, rx1598_pos, rx1598_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1598_cur
    .local pmc match
    .lex "$/", match
    length rx1598_eos, rx1598_tgt
    gt rx1598_pos, rx1598_eos, rx1598_done
    set rx1598_off, 0
    lt rx1598_pos, 2, rx1598_start
    sub rx1598_off, rx1598_pos, 1
    substr rx1598_tgt, rx1598_tgt, rx1598_off
  rx1598_start:
    eq $I10, 1, rx1598_restart
    if_null rx1598_debug, debug_1111
    rx1598_cur."!cursor_debug"("START", "sigil")
  debug_1111:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1599_done
    goto rxscan1599_scan
  rxscan1599_loop:
    (rx1598_pos) = rx1598_cur."from"()
    inc rx1598_pos
    rx1598_cur."!cursor_from"(rx1598_pos)
    ge rx1598_pos, rx1598_eos, rxscan1599_done
  rxscan1599_scan:
    set_addr $I10, rxscan1599_loop
    rx1598_cur."!mark_push"(0, rx1598_pos, $I10)
  rxscan1599_done:
.annotate 'line', 729
  # rx enumcharlist negate=0 
    ge rx1598_pos, rx1598_eos, rx1598_fail
    sub $I10, rx1598_pos, rx1598_off
    substr $S10, rx1598_tgt, $I10, 1
    index $I11, "$@%&", $S10
    lt $I11, 0, rx1598_fail
    inc rx1598_pos
  # rx pass
    rx1598_cur."!cursor_pass"(rx1598_pos, "sigil")
    if_null rx1598_debug, debug_1112
    rx1598_cur."!cursor_debug"("PASS", "sigil", " at pos=", rx1598_pos)
  debug_1112:
    .return (rx1598_cur)
  rx1598_restart:
.annotate 'line', 435
    if_null rx1598_debug, debug_1113
    rx1598_cur."!cursor_debug"("NEXT", "sigil")
  debug_1113:
  rx1598_fail:
    (rx1598_rep, rx1598_pos, $I10, $P10) = rx1598_cur."!mark_fail"(0)
    lt rx1598_pos, -1, rx1598_done
    eq rx1598_pos, -1, rx1598_fail
    jump $I10
  rx1598_done:
    rx1598_cur."!cursor_fail"()
    if_null rx1598_debug, debug_1114
    rx1598_cur."!cursor_debug"("FAIL", "sigil")
  debug_1114:
    .return (rx1598_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__sigil"  :subid("163_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    new $P103, "ResizablePMCArray"
    push $P103, "$"
    push $P103, "@"
    push $P103, "%"
    push $P103, "&"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "twigil"  :subid("164_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1602_tgt
    .local int rx1602_pos
    .local int rx1602_off
    .local int rx1602_eos
    .local int rx1602_rep
    .local pmc rx1602_cur
    .local pmc rx1602_debug
    (rx1602_cur, rx1602_pos, rx1602_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1602_cur
    .local pmc match
    .lex "$/", match
    length rx1602_eos, rx1602_tgt
    gt rx1602_pos, rx1602_eos, rx1602_done
    set rx1602_off, 0
    lt rx1602_pos, 2, rx1602_start
    sub rx1602_off, rx1602_pos, 1
    substr rx1602_tgt, rx1602_tgt, rx1602_off
  rx1602_start:
    eq $I10, 1, rx1602_restart
    if_null rx1602_debug, debug_1115
    rx1602_cur."!cursor_debug"("START", "twigil")
  debug_1115:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1603_done
    goto rxscan1603_scan
  rxscan1603_loop:
    (rx1602_pos) = rx1602_cur."from"()
    inc rx1602_pos
    rx1602_cur."!cursor_from"(rx1602_pos)
    ge rx1602_pos, rx1602_eos, rxscan1603_done
  rxscan1603_scan:
    set_addr $I10, rxscan1603_loop
    rx1602_cur."!mark_push"(0, rx1602_pos, $I10)
  rxscan1603_done:
.annotate 'line', 731
  # rx enumcharlist negate=0 
    ge rx1602_pos, rx1602_eos, rx1602_fail
    sub $I10, rx1602_pos, rx1602_off
    substr $S10, rx1602_tgt, $I10, 1
    index $I11, "*!?", $S10
    lt $I11, 0, rx1602_fail
    inc rx1602_pos
  # rx pass
    rx1602_cur."!cursor_pass"(rx1602_pos, "twigil")
    if_null rx1602_debug, debug_1116
    rx1602_cur."!cursor_debug"("PASS", "twigil", " at pos=", rx1602_pos)
  debug_1116:
    .return (rx1602_cur)
  rx1602_restart:
.annotate 'line', 435
    if_null rx1602_debug, debug_1117
    rx1602_cur."!cursor_debug"("NEXT", "twigil")
  debug_1117:
  rx1602_fail:
    (rx1602_rep, rx1602_pos, $I10, $P10) = rx1602_cur."!mark_fail"(0)
    lt rx1602_pos, -1, rx1602_done
    eq rx1602_pos, -1, rx1602_fail
    jump $I10
  rx1602_done:
    rx1602_cur."!cursor_fail"()
    if_null rx1602_debug, debug_1118
    rx1602_cur."!cursor_debug"("FAIL", "twigil")
  debug_1118:
    .return (rx1602_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__twigil"  :subid("165_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    new $P103, "ResizablePMCArray"
    push $P103, "*"
    push $P103, "!"
    push $P103, "?"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator"  :subid("166_1310110678.31883")
    .param pmc param_1606
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 733
    .lex "self", param_1606
    $P103 = param_1606."!protoregex"("package_declarator")
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator"  :subid("167_1310110678.31883")
    .param pmc param_1608
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 733
    .lex "self", param_1608
    $P104 = param_1608."!PREFIX__!protoregex"("package_declarator")
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<module>"  :subid("168_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 735
    new $P103, "Undef"
    set $P1610, $P103
    .lex "$*OUTERPACKAGE", $P1610
.annotate 'line', 736
    new $P104, "Undef"
    set $P1611, $P104
    .lex "$*PKGDECL", $P1611
.annotate 'line', 435
    .local string rx1612_tgt
    .local int rx1612_pos
    .local int rx1612_off
    .local int rx1612_eos
    .local int rx1612_rep
    .local pmc rx1612_cur
    .local pmc rx1612_debug
    (rx1612_cur, rx1612_pos, rx1612_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1612_cur
    .local pmc match
    .lex "$/", match
    length rx1612_eos, rx1612_tgt
    gt rx1612_pos, rx1612_eos, rx1612_done
    set rx1612_off, 0
    lt rx1612_pos, 2, rx1612_start
    sub rx1612_off, rx1612_pos, 1
    substr rx1612_tgt, rx1612_tgt, rx1612_off
  rx1612_start:
    eq $I10, 1, rx1612_restart
    if_null rx1612_debug, debug_1119
    rx1612_cur."!cursor_debug"("START", "package_declarator:sym<module>")
  debug_1119:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1613_done
    goto rxscan1613_scan
  rxscan1613_loop:
    (rx1612_pos) = rx1612_cur."from"()
    inc rx1612_pos
    rx1612_cur."!cursor_from"(rx1612_pos)
    ge rx1612_pos, rx1612_eos, rxscan1613_done
  rxscan1613_scan:
    set_addr $I10, rxscan1613_loop
    rx1612_cur."!mark_push"(0, rx1612_pos, $I10)
  rxscan1613_done:
.annotate 'line', 735
    rx1612_cur."!cursor_pos"(rx1612_pos)
    find_dynamic_lex $P107, "$*PACKAGE"
    unless_null $P107, vivify_1120
    get_hll_global $P105, "GLOBAL"
    get_who $P106, $P105
    set $P107, $P106["$PACKAGE"]
    unless_null $P107, vivify_1121
    die "Contextual $*PACKAGE not found"
  vivify_1121:
  vivify_1120:
    store_lex "$*OUTERPACKAGE", $P107
.annotate 'line', 736
    rx1612_cur."!cursor_pos"(rx1612_pos)
    new $P108, "String"
    assign $P108, "module"
    store_lex "$*PKGDECL", $P108
.annotate 'line', 737
  # rx subcapture "sym"
    set_addr $I10, rxcap_1614_fail
    rx1612_cur."!mark_push"(0, rx1612_pos, $I10)
  # rx literal  "module"
    add $I11, rx1612_pos, 6
    gt $I11, rx1612_eos, rx1612_fail
    sub $I11, rx1612_pos, rx1612_off
    substr $S10, rx1612_tgt, $I11, 6
    ne $S10, "module", rx1612_fail
    add rx1612_pos, 6
    set_addr $I10, rxcap_1614_fail
    ($I12, $I11) = rx1612_cur."!mark_peek"($I10)
    rx1612_cur."!cursor_pos"($I11)
    ($P10) = rx1612_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1612_pos, "")
    rx1612_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1614_done
  rxcap_1614_fail:
    goto rx1612_fail
  rxcap_1614_done:
  # rx subrule "package_def" subtype=capture negate=
    rx1612_cur."!cursor_pos"(rx1612_pos)
    $P10 = rx1612_cur."package_def"()
    unless $P10, rx1612_fail
    rx1612_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx1612_pos = $P10."pos"()
.annotate 'line', 734
  # rx pass
    rx1612_cur."!cursor_pass"(rx1612_pos, "package_declarator:sym<module>")
    if_null rx1612_debug, debug_1122
    rx1612_cur."!cursor_debug"("PASS", "package_declarator:sym<module>", " at pos=", rx1612_pos)
  debug_1122:
    .return (rx1612_cur)
  rx1612_restart:
.annotate 'line', 435
    if_null rx1612_debug, debug_1123
    rx1612_cur."!cursor_debug"("NEXT", "package_declarator:sym<module>")
  debug_1123:
  rx1612_fail:
    (rx1612_rep, rx1612_pos, $I10, $P10) = rx1612_cur."!mark_fail"(0)
    lt rx1612_pos, -1, rx1612_done
    eq rx1612_pos, -1, rx1612_fail
    jump $I10
  rx1612_done:
    rx1612_cur."!cursor_fail"()
    if_null rx1612_debug, debug_1124
    rx1612_cur."!cursor_debug"("FAIL", "package_declarator:sym<module>")
  debug_1124:
    .return (rx1612_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<module>"  :subid("169_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P109 = self."!PREFIX__!subrule"("package_def", "module")
    new $P110, "ResizablePMCArray"
    push $P110, $P109
    .return ($P110)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<knowhow>"  :subid("170_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 740
    new $P103, "Undef"
    set $P1617, $P103
    .lex "$*OUTERPACKAGE", $P1617
.annotate 'line', 741
    new $P104, "Undef"
    set $P1618, $P104
    .lex "$*PKGDECL", $P1618
.annotate 'line', 435
    .local string rx1619_tgt
    .local int rx1619_pos
    .local int rx1619_off
    .local int rx1619_eos
    .local int rx1619_rep
    .local pmc rx1619_cur
    .local pmc rx1619_debug
    (rx1619_cur, rx1619_pos, rx1619_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1619_cur
    .local pmc match
    .lex "$/", match
    length rx1619_eos, rx1619_tgt
    gt rx1619_pos, rx1619_eos, rx1619_done
    set rx1619_off, 0
    lt rx1619_pos, 2, rx1619_start
    sub rx1619_off, rx1619_pos, 1
    substr rx1619_tgt, rx1619_tgt, rx1619_off
  rx1619_start:
    eq $I10, 1, rx1619_restart
    if_null rx1619_debug, debug_1125
    rx1619_cur."!cursor_debug"("START", "package_declarator:sym<knowhow>")
  debug_1125:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1620_done
    goto rxscan1620_scan
  rxscan1620_loop:
    (rx1619_pos) = rx1619_cur."from"()
    inc rx1619_pos
    rx1619_cur."!cursor_from"(rx1619_pos)
    ge rx1619_pos, rx1619_eos, rxscan1620_done
  rxscan1620_scan:
    set_addr $I10, rxscan1620_loop
    rx1619_cur."!mark_push"(0, rx1619_pos, $I10)
  rxscan1620_done:
.annotate 'line', 740
    rx1619_cur."!cursor_pos"(rx1619_pos)
    find_dynamic_lex $P107, "$*PACKAGE"
    unless_null $P107, vivify_1126
    get_hll_global $P105, "GLOBAL"
    get_who $P106, $P105
    set $P107, $P106["$PACKAGE"]
    unless_null $P107, vivify_1127
    die "Contextual $*PACKAGE not found"
  vivify_1127:
  vivify_1126:
    store_lex "$*OUTERPACKAGE", $P107
.annotate 'line', 741
    rx1619_cur."!cursor_pos"(rx1619_pos)
    new $P108, "String"
    assign $P108, "knowhow"
    store_lex "$*PKGDECL", $P108
.annotate 'line', 742
  # rx subcapture "sym"
    set_addr $I10, rxcap_1621_fail
    rx1619_cur."!mark_push"(0, rx1619_pos, $I10)
  # rx literal  "knowhow"
    add $I11, rx1619_pos, 7
    gt $I11, rx1619_eos, rx1619_fail
    sub $I11, rx1619_pos, rx1619_off
    substr $S10, rx1619_tgt, $I11, 7
    ne $S10, "knowhow", rx1619_fail
    add rx1619_pos, 7
    set_addr $I10, rxcap_1621_fail
    ($I12, $I11) = rx1619_cur."!mark_peek"($I10)
    rx1619_cur."!cursor_pos"($I11)
    ($P10) = rx1619_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1619_pos, "")
    rx1619_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1621_done
  rxcap_1621_fail:
    goto rx1619_fail
  rxcap_1621_done:
  # rx subrule "package_def" subtype=capture negate=
    rx1619_cur."!cursor_pos"(rx1619_pos)
    $P10 = rx1619_cur."package_def"()
    unless $P10, rx1619_fail
    rx1619_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx1619_pos = $P10."pos"()
.annotate 'line', 739
  # rx pass
    rx1619_cur."!cursor_pass"(rx1619_pos, "package_declarator:sym<knowhow>")
    if_null rx1619_debug, debug_1128
    rx1619_cur."!cursor_debug"("PASS", "package_declarator:sym<knowhow>", " at pos=", rx1619_pos)
  debug_1128:
    .return (rx1619_cur)
  rx1619_restart:
.annotate 'line', 435
    if_null rx1619_debug, debug_1129
    rx1619_cur."!cursor_debug"("NEXT", "package_declarator:sym<knowhow>")
  debug_1129:
  rx1619_fail:
    (rx1619_rep, rx1619_pos, $I10, $P10) = rx1619_cur."!mark_fail"(0)
    lt rx1619_pos, -1, rx1619_done
    eq rx1619_pos, -1, rx1619_fail
    jump $I10
  rx1619_done:
    rx1619_cur."!cursor_fail"()
    if_null rx1619_debug, debug_1130
    rx1619_cur."!cursor_debug"("FAIL", "package_declarator:sym<knowhow>")
  debug_1130:
    .return (rx1619_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<knowhow>"  :subid("171_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P109 = self."!PREFIX__!subrule"("package_def", "knowhow")
    new $P110, "ResizablePMCArray"
    push $P110, $P109
    .return ($P110)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<class>"  :subid("172_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 745
    new $P103, "Undef"
    set $P1624, $P103
    .lex "$*OUTERPACKAGE", $P1624
.annotate 'line', 746
    new $P104, "Undef"
    set $P1625, $P104
    .lex "$*PKGDECL", $P1625
.annotate 'line', 435
    .local string rx1626_tgt
    .local int rx1626_pos
    .local int rx1626_off
    .local int rx1626_eos
    .local int rx1626_rep
    .local pmc rx1626_cur
    .local pmc rx1626_debug
    (rx1626_cur, rx1626_pos, rx1626_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1626_cur
    .local pmc match
    .lex "$/", match
    length rx1626_eos, rx1626_tgt
    gt rx1626_pos, rx1626_eos, rx1626_done
    set rx1626_off, 0
    lt rx1626_pos, 2, rx1626_start
    sub rx1626_off, rx1626_pos, 1
    substr rx1626_tgt, rx1626_tgt, rx1626_off
  rx1626_start:
    eq $I10, 1, rx1626_restart
    if_null rx1626_debug, debug_1131
    rx1626_cur."!cursor_debug"("START", "package_declarator:sym<class>")
  debug_1131:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1627_done
    goto rxscan1627_scan
  rxscan1627_loop:
    (rx1626_pos) = rx1626_cur."from"()
    inc rx1626_pos
    rx1626_cur."!cursor_from"(rx1626_pos)
    ge rx1626_pos, rx1626_eos, rxscan1627_done
  rxscan1627_scan:
    set_addr $I10, rxscan1627_loop
    rx1626_cur."!mark_push"(0, rx1626_pos, $I10)
  rxscan1627_done:
.annotate 'line', 745
    rx1626_cur."!cursor_pos"(rx1626_pos)
    find_dynamic_lex $P107, "$*PACKAGE"
    unless_null $P107, vivify_1132
    get_hll_global $P105, "GLOBAL"
    get_who $P106, $P105
    set $P107, $P106["$PACKAGE"]
    unless_null $P107, vivify_1133
    die "Contextual $*PACKAGE not found"
  vivify_1133:
  vivify_1132:
    store_lex "$*OUTERPACKAGE", $P107
.annotate 'line', 746
    rx1626_cur."!cursor_pos"(rx1626_pos)
    new $P108, "String"
    assign $P108, "class"
    store_lex "$*PKGDECL", $P108
.annotate 'line', 747
  # rx subcapture "sym"
    set_addr $I10, rxcap_1628_fail
    rx1626_cur."!mark_push"(0, rx1626_pos, $I10)
  # rx literal  "class"
    add $I11, rx1626_pos, 5
    gt $I11, rx1626_eos, rx1626_fail
    sub $I11, rx1626_pos, rx1626_off
    substr $S10, rx1626_tgt, $I11, 5
    ne $S10, "class", rx1626_fail
    add rx1626_pos, 5
    set_addr $I10, rxcap_1628_fail
    ($I12, $I11) = rx1626_cur."!mark_peek"($I10)
    rx1626_cur."!cursor_pos"($I11)
    ($P10) = rx1626_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1626_pos, "")
    rx1626_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1628_done
  rxcap_1628_fail:
    goto rx1626_fail
  rxcap_1628_done:
  # rx subrule "package_def" subtype=capture negate=
    rx1626_cur."!cursor_pos"(rx1626_pos)
    $P10 = rx1626_cur."package_def"()
    unless $P10, rx1626_fail
    rx1626_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx1626_pos = $P10."pos"()
.annotate 'line', 744
  # rx pass
    rx1626_cur."!cursor_pass"(rx1626_pos, "package_declarator:sym<class>")
    if_null rx1626_debug, debug_1134
    rx1626_cur."!cursor_debug"("PASS", "package_declarator:sym<class>", " at pos=", rx1626_pos)
  debug_1134:
    .return (rx1626_cur)
  rx1626_restart:
.annotate 'line', 435
    if_null rx1626_debug, debug_1135
    rx1626_cur."!cursor_debug"("NEXT", "package_declarator:sym<class>")
  debug_1135:
  rx1626_fail:
    (rx1626_rep, rx1626_pos, $I10, $P10) = rx1626_cur."!mark_fail"(0)
    lt rx1626_pos, -1, rx1626_done
    eq rx1626_pos, -1, rx1626_fail
    jump $I10
  rx1626_done:
    rx1626_cur."!cursor_fail"()
    if_null rx1626_debug, debug_1136
    rx1626_cur."!cursor_debug"("FAIL", "package_declarator:sym<class>")
  debug_1136:
    .return (rx1626_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<class>"  :subid("173_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P109 = self."!PREFIX__!subrule"("package_def", "class")
    new $P110, "ResizablePMCArray"
    push $P110, $P109
    .return ($P110)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<grammar>"  :subid("174_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 750
    new $P103, "Undef"
    set $P1631, $P103
    .lex "$*OUTERPACKAGE", $P1631
.annotate 'line', 751
    new $P104, "Undef"
    set $P1632, $P104
    .lex "$*PKGDECL", $P1632
.annotate 'line', 435
    .local string rx1633_tgt
    .local int rx1633_pos
    .local int rx1633_off
    .local int rx1633_eos
    .local int rx1633_rep
    .local pmc rx1633_cur
    .local pmc rx1633_debug
    (rx1633_cur, rx1633_pos, rx1633_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1633_cur
    .local pmc match
    .lex "$/", match
    length rx1633_eos, rx1633_tgt
    gt rx1633_pos, rx1633_eos, rx1633_done
    set rx1633_off, 0
    lt rx1633_pos, 2, rx1633_start
    sub rx1633_off, rx1633_pos, 1
    substr rx1633_tgt, rx1633_tgt, rx1633_off
  rx1633_start:
    eq $I10, 1, rx1633_restart
    if_null rx1633_debug, debug_1137
    rx1633_cur."!cursor_debug"("START", "package_declarator:sym<grammar>")
  debug_1137:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1634_done
    goto rxscan1634_scan
  rxscan1634_loop:
    (rx1633_pos) = rx1633_cur."from"()
    inc rx1633_pos
    rx1633_cur."!cursor_from"(rx1633_pos)
    ge rx1633_pos, rx1633_eos, rxscan1634_done
  rxscan1634_scan:
    set_addr $I10, rxscan1634_loop
    rx1633_cur."!mark_push"(0, rx1633_pos, $I10)
  rxscan1634_done:
.annotate 'line', 750
    rx1633_cur."!cursor_pos"(rx1633_pos)
    find_dynamic_lex $P107, "$*PACKAGE"
    unless_null $P107, vivify_1138
    get_hll_global $P105, "GLOBAL"
    get_who $P106, $P105
    set $P107, $P106["$PACKAGE"]
    unless_null $P107, vivify_1139
    die "Contextual $*PACKAGE not found"
  vivify_1139:
  vivify_1138:
    store_lex "$*OUTERPACKAGE", $P107
.annotate 'line', 751
    rx1633_cur."!cursor_pos"(rx1633_pos)
    new $P108, "String"
    assign $P108, "grammar"
    store_lex "$*PKGDECL", $P108
.annotate 'line', 752
  # rx subcapture "sym"
    set_addr $I10, rxcap_1635_fail
    rx1633_cur."!mark_push"(0, rx1633_pos, $I10)
  # rx literal  "grammar"
    add $I11, rx1633_pos, 7
    gt $I11, rx1633_eos, rx1633_fail
    sub $I11, rx1633_pos, rx1633_off
    substr $S10, rx1633_tgt, $I11, 7
    ne $S10, "grammar", rx1633_fail
    add rx1633_pos, 7
    set_addr $I10, rxcap_1635_fail
    ($I12, $I11) = rx1633_cur."!mark_peek"($I10)
    rx1633_cur."!cursor_pos"($I11)
    ($P10) = rx1633_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1633_pos, "")
    rx1633_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1635_done
  rxcap_1635_fail:
    goto rx1633_fail
  rxcap_1635_done:
  # rx subrule "package_def" subtype=capture negate=
    rx1633_cur."!cursor_pos"(rx1633_pos)
    $P10 = rx1633_cur."package_def"()
    unless $P10, rx1633_fail
    rx1633_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx1633_pos = $P10."pos"()
.annotate 'line', 749
  # rx pass
    rx1633_cur."!cursor_pass"(rx1633_pos, "package_declarator:sym<grammar>")
    if_null rx1633_debug, debug_1140
    rx1633_cur."!cursor_debug"("PASS", "package_declarator:sym<grammar>", " at pos=", rx1633_pos)
  debug_1140:
    .return (rx1633_cur)
  rx1633_restart:
.annotate 'line', 435
    if_null rx1633_debug, debug_1141
    rx1633_cur."!cursor_debug"("NEXT", "package_declarator:sym<grammar>")
  debug_1141:
  rx1633_fail:
    (rx1633_rep, rx1633_pos, $I10, $P10) = rx1633_cur."!mark_fail"(0)
    lt rx1633_pos, -1, rx1633_done
    eq rx1633_pos, -1, rx1633_fail
    jump $I10
  rx1633_done:
    rx1633_cur."!cursor_fail"()
    if_null rx1633_debug, debug_1142
    rx1633_cur."!cursor_debug"("FAIL", "package_declarator:sym<grammar>")
  debug_1142:
    .return (rx1633_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<grammar>"  :subid("175_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P109 = self."!PREFIX__!subrule"("package_def", "grammar")
    new $P110, "ResizablePMCArray"
    push $P110, $P109
    .return ($P110)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<role>"  :subid("176_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 755
    new $P103, "Undef"
    set $P1638, $P103
    .lex "$*OUTERPACKAGE", $P1638
.annotate 'line', 756
    new $P104, "Undef"
    set $P1639, $P104
    .lex "$*PKGDECL", $P1639
.annotate 'line', 435
    .local string rx1640_tgt
    .local int rx1640_pos
    .local int rx1640_off
    .local int rx1640_eos
    .local int rx1640_rep
    .local pmc rx1640_cur
    .local pmc rx1640_debug
    (rx1640_cur, rx1640_pos, rx1640_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1640_cur
    .local pmc match
    .lex "$/", match
    length rx1640_eos, rx1640_tgt
    gt rx1640_pos, rx1640_eos, rx1640_done
    set rx1640_off, 0
    lt rx1640_pos, 2, rx1640_start
    sub rx1640_off, rx1640_pos, 1
    substr rx1640_tgt, rx1640_tgt, rx1640_off
  rx1640_start:
    eq $I10, 1, rx1640_restart
    if_null rx1640_debug, debug_1143
    rx1640_cur."!cursor_debug"("START", "package_declarator:sym<role>")
  debug_1143:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1641_done
    goto rxscan1641_scan
  rxscan1641_loop:
    (rx1640_pos) = rx1640_cur."from"()
    inc rx1640_pos
    rx1640_cur."!cursor_from"(rx1640_pos)
    ge rx1640_pos, rx1640_eos, rxscan1641_done
  rxscan1641_scan:
    set_addr $I10, rxscan1641_loop
    rx1640_cur."!mark_push"(0, rx1640_pos, $I10)
  rxscan1641_done:
.annotate 'line', 755
    rx1640_cur."!cursor_pos"(rx1640_pos)
    find_dynamic_lex $P107, "$*PACKAGE"
    unless_null $P107, vivify_1144
    get_hll_global $P105, "GLOBAL"
    get_who $P106, $P105
    set $P107, $P106["$PACKAGE"]
    unless_null $P107, vivify_1145
    die "Contextual $*PACKAGE not found"
  vivify_1145:
  vivify_1144:
    store_lex "$*OUTERPACKAGE", $P107
.annotate 'line', 756
    rx1640_cur."!cursor_pos"(rx1640_pos)
    new $P108, "String"
    assign $P108, "role"
    store_lex "$*PKGDECL", $P108
.annotate 'line', 757
  # rx subcapture "sym"
    set_addr $I10, rxcap_1642_fail
    rx1640_cur."!mark_push"(0, rx1640_pos, $I10)
  # rx literal  "role"
    add $I11, rx1640_pos, 4
    gt $I11, rx1640_eos, rx1640_fail
    sub $I11, rx1640_pos, rx1640_off
    substr $S10, rx1640_tgt, $I11, 4
    ne $S10, "role", rx1640_fail
    add rx1640_pos, 4
    set_addr $I10, rxcap_1642_fail
    ($I12, $I11) = rx1640_cur."!mark_peek"($I10)
    rx1640_cur."!cursor_pos"($I11)
    ($P10) = rx1640_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1640_pos, "")
    rx1640_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1642_done
  rxcap_1642_fail:
    goto rx1640_fail
  rxcap_1642_done:
  # rx subrule "package_def" subtype=capture negate=
    rx1640_cur."!cursor_pos"(rx1640_pos)
    $P10 = rx1640_cur."package_def"()
    unless $P10, rx1640_fail
    rx1640_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx1640_pos = $P10."pos"()
.annotate 'line', 754
  # rx pass
    rx1640_cur."!cursor_pass"(rx1640_pos, "package_declarator:sym<role>")
    if_null rx1640_debug, debug_1146
    rx1640_cur."!cursor_debug"("PASS", "package_declarator:sym<role>", " at pos=", rx1640_pos)
  debug_1146:
    .return (rx1640_cur)
  rx1640_restart:
.annotate 'line', 435
    if_null rx1640_debug, debug_1147
    rx1640_cur."!cursor_debug"("NEXT", "package_declarator:sym<role>")
  debug_1147:
  rx1640_fail:
    (rx1640_rep, rx1640_pos, $I10, $P10) = rx1640_cur."!mark_fail"(0)
    lt rx1640_pos, -1, rx1640_done
    eq rx1640_pos, -1, rx1640_fail
    jump $I10
  rx1640_done:
    rx1640_cur."!cursor_fail"()
    if_null rx1640_debug, debug_1148
    rx1640_cur."!cursor_debug"("FAIL", "package_declarator:sym<role>")
  debug_1148:
    .return (rx1640_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<role>"  :subid("177_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P109 = self."!PREFIX__!subrule"("package_def", "role")
    new $P110, "ResizablePMCArray"
    push $P110, $P109
    .return ($P110)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<native>"  :subid("178_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 760
    new $P103, "Undef"
    set $P1645, $P103
    .lex "$*OUTERPACKAGE", $P1645
.annotate 'line', 761
    new $P104, "Undef"
    set $P1646, $P104
    .lex "$*PKGDECL", $P1646
.annotate 'line', 435
    .local string rx1647_tgt
    .local int rx1647_pos
    .local int rx1647_off
    .local int rx1647_eos
    .local int rx1647_rep
    .local pmc rx1647_cur
    .local pmc rx1647_debug
    (rx1647_cur, rx1647_pos, rx1647_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1647_cur
    .local pmc match
    .lex "$/", match
    length rx1647_eos, rx1647_tgt
    gt rx1647_pos, rx1647_eos, rx1647_done
    set rx1647_off, 0
    lt rx1647_pos, 2, rx1647_start
    sub rx1647_off, rx1647_pos, 1
    substr rx1647_tgt, rx1647_tgt, rx1647_off
  rx1647_start:
    eq $I10, 1, rx1647_restart
    if_null rx1647_debug, debug_1149
    rx1647_cur."!cursor_debug"("START", "package_declarator:sym<native>")
  debug_1149:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1648_done
    goto rxscan1648_scan
  rxscan1648_loop:
    (rx1647_pos) = rx1647_cur."from"()
    inc rx1647_pos
    rx1647_cur."!cursor_from"(rx1647_pos)
    ge rx1647_pos, rx1647_eos, rxscan1648_done
  rxscan1648_scan:
    set_addr $I10, rxscan1648_loop
    rx1647_cur."!mark_push"(0, rx1647_pos, $I10)
  rxscan1648_done:
.annotate 'line', 760
    rx1647_cur."!cursor_pos"(rx1647_pos)
    find_dynamic_lex $P107, "$*PACKAGE"
    unless_null $P107, vivify_1150
    get_hll_global $P105, "GLOBAL"
    get_who $P106, $P105
    set $P107, $P106["$PACKAGE"]
    unless_null $P107, vivify_1151
    die "Contextual $*PACKAGE not found"
  vivify_1151:
  vivify_1150:
    store_lex "$*OUTERPACKAGE", $P107
.annotate 'line', 761
    rx1647_cur."!cursor_pos"(rx1647_pos)
    new $P108, "String"
    assign $P108, "native"
    store_lex "$*PKGDECL", $P108
.annotate 'line', 762
  # rx subcapture "sym"
    set_addr $I10, rxcap_1649_fail
    rx1647_cur."!mark_push"(0, rx1647_pos, $I10)
  # rx literal  "native"
    add $I11, rx1647_pos, 6
    gt $I11, rx1647_eos, rx1647_fail
    sub $I11, rx1647_pos, rx1647_off
    substr $S10, rx1647_tgt, $I11, 6
    ne $S10, "native", rx1647_fail
    add rx1647_pos, 6
    set_addr $I10, rxcap_1649_fail
    ($I12, $I11) = rx1647_cur."!mark_peek"($I10)
    rx1647_cur."!cursor_pos"($I11)
    ($P10) = rx1647_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1647_pos, "")
    rx1647_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1649_done
  rxcap_1649_fail:
    goto rx1647_fail
  rxcap_1649_done:
  # rx subrule "package_def" subtype=capture negate=
    rx1647_cur."!cursor_pos"(rx1647_pos)
    $P10 = rx1647_cur."package_def"()
    unless $P10, rx1647_fail
    rx1647_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx1647_pos = $P10."pos"()
.annotate 'line', 759
  # rx pass
    rx1647_cur."!cursor_pass"(rx1647_pos, "package_declarator:sym<native>")
    if_null rx1647_debug, debug_1152
    rx1647_cur."!cursor_debug"("PASS", "package_declarator:sym<native>", " at pos=", rx1647_pos)
  debug_1152:
    .return (rx1647_cur)
  rx1647_restart:
.annotate 'line', 435
    if_null rx1647_debug, debug_1153
    rx1647_cur."!cursor_debug"("NEXT", "package_declarator:sym<native>")
  debug_1153:
  rx1647_fail:
    (rx1647_rep, rx1647_pos, $I10, $P10) = rx1647_cur."!mark_fail"(0)
    lt rx1647_pos, -1, rx1647_done
    eq rx1647_pos, -1, rx1647_fail
    jump $I10
  rx1647_done:
    rx1647_cur."!cursor_fail"()
    if_null rx1647_debug, debug_1154
    rx1647_cur."!cursor_debug"("FAIL", "package_declarator:sym<native>")
  debug_1154:
    .return (rx1647_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<native>"  :subid("179_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P109 = self."!PREFIX__!subrule"("package_def", "native")
    new $P110, "ResizablePMCArray"
    push $P110, $P109
    .return ($P110)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<stub>"  :subid("180_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 765
    new $P103, "Undef"
    set $P1652, $P103
    .lex "$*OUTERPACKAGE", $P1652
.annotate 'line', 766
    new $P104, "Undef"
    set $P1653, $P104
    .lex "$*PKGDECL", $P1653
.annotate 'line', 435
    .local string rx1654_tgt
    .local int rx1654_pos
    .local int rx1654_off
    .local int rx1654_eos
    .local int rx1654_rep
    .local pmc rx1654_cur
    .local pmc rx1654_debug
    (rx1654_cur, rx1654_pos, rx1654_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1654_cur
    .local pmc match
    .lex "$/", match
    length rx1654_eos, rx1654_tgt
    gt rx1654_pos, rx1654_eos, rx1654_done
    set rx1654_off, 0
    lt rx1654_pos, 2, rx1654_start
    sub rx1654_off, rx1654_pos, 1
    substr rx1654_tgt, rx1654_tgt, rx1654_off
  rx1654_start:
    eq $I10, 1, rx1654_restart
    if_null rx1654_debug, debug_1155
    rx1654_cur."!cursor_debug"("START", "package_declarator:sym<stub>")
  debug_1155:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1655_done
    goto rxscan1655_scan
  rxscan1655_loop:
    (rx1654_pos) = rx1654_cur."from"()
    inc rx1654_pos
    rx1654_cur."!cursor_from"(rx1654_pos)
    ge rx1654_pos, rx1654_eos, rxscan1655_done
  rxscan1655_scan:
    set_addr $I10, rxscan1655_loop
    rx1654_cur."!mark_push"(0, rx1654_pos, $I10)
  rxscan1655_done:
.annotate 'line', 764
  # rx subrule "ws" subtype=method negate=
    rx1654_cur."!cursor_pos"(rx1654_pos)
    $P10 = rx1654_cur."ws"()
    unless $P10, rx1654_fail
    rx1654_pos = $P10."pos"()
.annotate 'line', 765
    rx1654_cur."!cursor_pos"(rx1654_pos)
    find_dynamic_lex $P108, "$*PACKAGE"
    unless_null $P108, vivify_1156
    get_hll_global $P106, "GLOBAL"
    get_who $P107, $P106
    set $P108, $P107["$PACKAGE"]
    unless_null $P108, vivify_1157
    die "Contextual $*PACKAGE not found"
  vivify_1157:
  vivify_1156:
    store_lex "$*OUTERPACKAGE", $P108
  # rx subrule "ws" subtype=method negate=
    rx1654_cur."!cursor_pos"(rx1654_pos)
    $P10 = rx1654_cur."ws"()
    unless $P10, rx1654_fail
    rx1654_pos = $P10."pos"()
.annotate 'line', 766
    rx1654_cur."!cursor_pos"(rx1654_pos)
    new $P110, "String"
    assign $P110, "stub"
    store_lex "$*PKGDECL", $P110
  # rx subrule "ws" subtype=method negate=
    rx1654_cur."!cursor_pos"(rx1654_pos)
    $P10 = rx1654_cur."ws"()
    unless $P10, rx1654_fail
    rx1654_pos = $P10."pos"()
.annotate 'line', 767
  # rx subcapture "sym"
    set_addr $I10, rxcap_1656_fail
    rx1654_cur."!mark_push"(0, rx1654_pos, $I10)
  # rx literal  "stub"
    add $I11, rx1654_pos, 4
    gt $I11, rx1654_eos, rx1654_fail
    sub $I11, rx1654_pos, rx1654_off
    substr $S10, rx1654_tgt, $I11, 4
    ne $S10, "stub", rx1654_fail
    add rx1654_pos, 4
    set_addr $I10, rxcap_1656_fail
    ($I12, $I11) = rx1654_cur."!mark_peek"($I10)
    rx1654_cur."!cursor_pos"($I11)
    ($P10) = rx1654_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1654_pos, "")
    rx1654_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1656_done
  rxcap_1656_fail:
    goto rx1654_fail
  rxcap_1656_done:
  # rx subrule "ws" subtype=method negate=
    rx1654_cur."!cursor_pos"(rx1654_pos)
    $P10 = rx1654_cur."ws"()
    unless $P10, rx1654_fail
    rx1654_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx1654_cur."!cursor_pos"(rx1654_pos)
    $P10 = rx1654_cur."name"()
    unless $P10, rx1654_fail
    rx1654_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1654_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1654_cur."!cursor_pos"(rx1654_pos)
    $P10 = rx1654_cur."ws"()
    unless $P10, rx1654_fail
    rx1654_pos = $P10."pos"()
.annotate 'line', 768
  # rx literal  "metaclass"
    add $I11, rx1654_pos, 9
    gt $I11, rx1654_eos, rx1654_fail
    sub $I11, rx1654_pos, rx1654_off
    substr $S10, rx1654_tgt, $I11, 9
    ne $S10, "metaclass", rx1654_fail
    add rx1654_pos, 9
  # rx subrule "ws" subtype=method negate=
    rx1654_cur."!cursor_pos"(rx1654_pos)
    $P10 = rx1654_cur."ws"()
    unless $P10, rx1654_fail
    rx1654_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx1654_cur."!cursor_pos"(rx1654_pos)
    $P10 = rx1654_cur."name"()
    unless $P10, rx1654_fail
    rx1654_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("metaclass")
    rx1654_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1654_cur."!cursor_pos"(rx1654_pos)
    $P10 = rx1654_cur."ws"()
    unless $P10, rx1654_fail
    rx1654_pos = $P10."pos"()
.annotate 'line', 769
  # rx literal  "{"
    add $I11, rx1654_pos, 1
    gt $I11, rx1654_eos, rx1654_fail
    sub $I11, rx1654_pos, rx1654_off
    ord $I11, rx1654_tgt, $I11
    ne $I11, 123, rx1654_fail
    add rx1654_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1654_cur."!cursor_pos"(rx1654_pos)
    $P10 = rx1654_cur."ws"()
    unless $P10, rx1654_fail
    rx1654_pos = $P10."pos"()
  # rx literal  "..."
    add $I11, rx1654_pos, 3
    gt $I11, rx1654_eos, rx1654_fail
    sub $I11, rx1654_pos, rx1654_off
    substr $S10, rx1654_tgt, $I11, 3
    ne $S10, "...", rx1654_fail
    add rx1654_pos, 3
  # rx subrule "ws" subtype=method negate=
    rx1654_cur."!cursor_pos"(rx1654_pos)
    $P10 = rx1654_cur."ws"()
    unless $P10, rx1654_fail
    rx1654_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1654_pos, 1
    gt $I11, rx1654_eos, rx1654_fail
    sub $I11, rx1654_pos, rx1654_off
    ord $I11, rx1654_tgt, $I11
    ne $I11, 125, rx1654_fail
    add rx1654_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1654_cur."!cursor_pos"(rx1654_pos)
    $P10 = rx1654_cur."ws"()
    unless $P10, rx1654_fail
    rx1654_pos = $P10."pos"()
.annotate 'line', 764
  # rx pass
    rx1654_cur."!cursor_pass"(rx1654_pos, "package_declarator:sym<stub>")
    if_null rx1654_debug, debug_1158
    rx1654_cur."!cursor_debug"("PASS", "package_declarator:sym<stub>", " at pos=", rx1654_pos)
  debug_1158:
    .return (rx1654_cur)
  rx1654_restart:
.annotate 'line', 435
    if_null rx1654_debug, debug_1159
    rx1654_cur."!cursor_debug"("NEXT", "package_declarator:sym<stub>")
  debug_1159:
  rx1654_fail:
    (rx1654_rep, rx1654_pos, $I10, $P10) = rx1654_cur."!mark_fail"(0)
    lt rx1654_pos, -1, rx1654_done
    eq rx1654_pos, -1, rx1654_fail
    jump $I10
  rx1654_done:
    rx1654_cur."!cursor_fail"()
    if_null rx1654_debug, debug_1160
    rx1654_cur."!cursor_debug"("FAIL", "package_declarator:sym<stub>")
  debug_1160:
    .return (rx1654_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<stub>"  :subid("181_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P119 = self."!PREFIX__!subrule"("ws", "")
    new $P120, "ResizablePMCArray"
    push $P120, $P119
    .return ($P120)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_def"  :subid("182_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .const 'Sub' $P1664 = "183_1310110678.31883" 
    capture_lex $P1664
.annotate 'line', 773
    new $P103, "Undef"
    set $P1659, $P103
    .lex "$*PACKAGE", $P1659
.annotate 'line', 435
    .local string rx1660_tgt
    .local int rx1660_pos
    .local int rx1660_off
    .local int rx1660_eos
    .local int rx1660_rep
    .local pmc rx1660_cur
    .local pmc rx1660_debug
    (rx1660_cur, rx1660_pos, rx1660_tgt, $I10) = self."!cursor_start"()
    rx1660_cur."!cursor_caparray"("repr", "parent", "role")
    .lex unicode:"$\x{a2}", rx1660_cur
    .local pmc match
    .lex "$/", match
    length rx1660_eos, rx1660_tgt
    gt rx1660_pos, rx1660_eos, rx1660_done
    set rx1660_off, 0
    lt rx1660_pos, 2, rx1660_start
    sub rx1660_off, rx1660_pos, 1
    substr rx1660_tgt, rx1660_tgt, rx1660_off
  rx1660_start:
    eq $I10, 1, rx1660_restart
    if_null rx1660_debug, debug_1161
    rx1660_cur."!cursor_debug"("START", "package_def")
  debug_1161:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1661_done
    goto rxscan1661_scan
  rxscan1661_loop:
    (rx1660_pos) = rx1660_cur."from"()
    inc rx1660_pos
    rx1660_cur."!cursor_from"(rx1660_pos)
    ge rx1660_pos, rx1660_eos, rxscan1661_done
  rxscan1661_scan:
    set_addr $I10, rxscan1661_loop
    rx1660_cur."!mark_push"(0, rx1660_pos, $I10)
  rxscan1661_done:
.annotate 'line', 772
  # rx subrule "ws" subtype=method negate=
    rx1660_cur."!cursor_pos"(rx1660_pos)
    $P10 = rx1660_cur."ws"()
    unless $P10, rx1660_fail
    rx1660_pos = $P10."pos"()
.annotate 'line', 773
    rx1660_cur."!cursor_pos"(rx1660_pos)
    find_lex $P107, "$*PACKAGE"
    unless_null $P107, vivify_1162
    get_hll_global $P105, "GLOBAL"
    get_who $P106, $P105
    set $P107, $P106["$PACKAGE"]
    unless_null $P107, vivify_1163
    die "Contextual $*PACKAGE not found"
  vivify_1163:
  vivify_1162:
  # rx subrule "ws" subtype=method negate=
    rx1660_cur."!cursor_pos"(rx1660_pos)
    $P10 = rx1660_cur."ws"()
    unless $P10, rx1660_fail
    rx1660_pos = $P10."pos"()
.annotate 'line', 775
  # rx subrule "name" subtype=capture negate=
    rx1660_cur."!cursor_pos"(rx1660_pos)
    $P10 = rx1660_cur."name"()
    unless $P10, rx1660_fail
    rx1660_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1660_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1660_cur."!cursor_pos"(rx1660_pos)
    $P10 = rx1660_cur."ws"()
    unless $P10, rx1660_fail
    rx1660_pos = $P10."pos"()
.annotate 'line', 776
  # rx rxquantr1662 ** 0..1
    set_addr $I10, rxquantr1662_done
    rx1660_cur."!mark_push"(0, rx1660_pos, $I10)
  rxquantr1662_loop:
  # rx subrule "ws" subtype=method negate=
    rx1660_cur."!cursor_pos"(rx1660_pos)
    $P10 = rx1660_cur."ws"()
    unless $P10, rx1660_fail
    rx1660_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx1660_pos, 2
    gt $I11, rx1660_eos, rx1660_fail
    sub $I11, rx1660_pos, rx1660_off
    substr $S10, rx1660_tgt, $I11, 2
    ne $S10, "is", rx1660_fail
    add rx1660_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx1660_cur."!cursor_pos"(rx1660_pos)
    $P10 = rx1660_cur."ws"()
    unless $P10, rx1660_fail
    rx1660_pos = $P10."pos"()
  # rx literal  "repr("
    add $I11, rx1660_pos, 5
    gt $I11, rx1660_eos, rx1660_fail
    sub $I11, rx1660_pos, rx1660_off
    substr $S10, rx1660_tgt, $I11, 5
    ne $S10, "repr(", rx1660_fail
    add rx1660_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx1660_cur."!cursor_pos"(rx1660_pos)
    $P10 = rx1660_cur."ws"()
    unless $P10, rx1660_fail
    rx1660_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1660_cur."!cursor_pos"(rx1660_pos)
    $P10 = rx1660_cur."quote_EXPR"()
    unless $P10, rx1660_fail
    rx1660_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("repr")
    rx1660_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1660_cur."!cursor_pos"(rx1660_pos)
    $P10 = rx1660_cur."ws"()
    unless $P10, rx1660_fail
    rx1660_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1660_pos, 1
    gt $I11, rx1660_eos, rx1660_fail
    sub $I11, rx1660_pos, rx1660_off
    ord $I11, rx1660_tgt, $I11
    ne $I11, 41, rx1660_fail
    add rx1660_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1660_cur."!cursor_pos"(rx1660_pos)
    $P10 = rx1660_cur."ws"()
    unless $P10, rx1660_fail
    rx1660_pos = $P10."pos"()
    set_addr $I10, rxquantr1662_done
    (rx1660_rep) = rx1660_cur."!mark_commit"($I10)
  rxquantr1662_done:
  # rx subrule "ws" subtype=method negate=
    rx1660_cur."!cursor_pos"(rx1660_pos)
    $P10 = rx1660_cur."ws"()
    unless $P10, rx1660_fail
    rx1660_pos = $P10."pos"()
.annotate 'line', 778
    rx1660_cur."!cursor_pos"(rx1660_pos)
    find_lex $P116, unicode:"$\x{a2}"
    $P117 = $P116."MATCH"()
    store_lex "$/", $P117
    .const 'Sub' $P1664 = "183_1310110678.31883" 
    capture_lex $P1664
    $P119 = $P1664()
.annotate 'line', 804
  # rx subrule "ws" subtype=method negate=
    rx1660_cur."!cursor_pos"(rx1660_pos)
    $P10 = rx1660_cur."ws"()
    unless $P10, rx1660_fail
    rx1660_pos = $P10."pos"()
.annotate 'line', 806
  # rx rxquantr1699 ** 0..1
    set_addr $I10, rxquantr1699_done
    rx1660_cur."!mark_push"(0, rx1660_pos, $I10)
  rxquantr1699_loop:
  # rx subrule "ws" subtype=method negate=
    rx1660_cur."!cursor_pos"(rx1660_pos)
    $P10 = rx1660_cur."ws"()
    unless $P10, rx1660_fail
    rx1660_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx1660_pos, 2
    gt $I11, rx1660_eos, rx1660_fail
    sub $I11, rx1660_pos, rx1660_off
    substr $S10, rx1660_tgt, $I11, 2
    ne $S10, "is", rx1660_fail
    add rx1660_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx1660_cur."!cursor_pos"(rx1660_pos)
    $P10 = rx1660_cur."ws"()
    unless $P10, rx1660_fail
    rx1660_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx1660_cur."!cursor_pos"(rx1660_pos)
    $P10 = rx1660_cur."name"()
    unless $P10, rx1660_fail
    rx1660_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parent")
    rx1660_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1660_cur."!cursor_pos"(rx1660_pos)
    $P10 = rx1660_cur."ws"()
    unless $P10, rx1660_fail
    rx1660_pos = $P10."pos"()
    set_addr $I10, rxquantr1699_done
    (rx1660_rep) = rx1660_cur."!mark_commit"($I10)
  rxquantr1699_done:
  # rx subrule "ws" subtype=method negate=
    rx1660_cur."!cursor_pos"(rx1660_pos)
    $P10 = rx1660_cur."ws"()
    unless $P10, rx1660_fail
    rx1660_pos = $P10."pos"()
.annotate 'line', 807
  # rx rxquantr1700 ** 0..*
    set_addr $I10, rxquantr1700_done
    rx1660_cur."!mark_push"(0, rx1660_pos, $I10)
  rxquantr1700_loop:
  # rx subrule "ws" subtype=method negate=
    rx1660_cur."!cursor_pos"(rx1660_pos)
    $P10 = rx1660_cur."ws"()
    unless $P10, rx1660_fail
    rx1660_pos = $P10."pos"()
  # rx literal  "does"
    add $I11, rx1660_pos, 4
    gt $I11, rx1660_eos, rx1660_fail
    sub $I11, rx1660_pos, rx1660_off
    substr $S10, rx1660_tgt, $I11, 4
    ne $S10, "does", rx1660_fail
    add rx1660_pos, 4
  # rx subrule "ws" subtype=method negate=
    rx1660_cur."!cursor_pos"(rx1660_pos)
    $P10 = rx1660_cur."ws"()
    unless $P10, rx1660_fail
    rx1660_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx1660_cur."!cursor_pos"(rx1660_pos)
    $P10 = rx1660_cur."name"()
    unless $P10, rx1660_fail
    rx1660_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("role")
    rx1660_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1660_cur."!cursor_pos"(rx1660_pos)
    $P10 = rx1660_cur."ws"()
    unless $P10, rx1660_fail
    rx1660_pos = $P10."pos"()
    set_addr $I10, rxquantr1700_done
    (rx1660_rep) = rx1660_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1700_done
    rx1660_cur."!mark_push"(rx1660_rep, rx1660_pos, $I10)
    goto rxquantr1700_loop
  rxquantr1700_done:
  # rx subrule "ws" subtype=method negate=
    rx1660_cur."!cursor_pos"(rx1660_pos)
    $P10 = rx1660_cur."ws"()
    unless $P10, rx1660_fail
    rx1660_pos = $P10."pos"()
  alt1701_0:
.annotate 'line', 808
    set_addr $I10, alt1701_1
    rx1660_cur."!mark_push"(0, rx1660_pos, $I10)
.annotate 'line', 809
  # rx subrule "ws" subtype=method negate=
    rx1660_cur."!cursor_pos"(rx1660_pos)
    $P10 = rx1660_cur."ws"()
    unless $P10, rx1660_fail
    rx1660_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx1660_pos, 1
    gt $I11, rx1660_eos, rx1660_fail
    sub $I11, rx1660_pos, rx1660_off
    ord $I11, rx1660_tgt, $I11
    ne $I11, 59, rx1660_fail
    add rx1660_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1660_cur."!cursor_pos"(rx1660_pos)
    $P10 = rx1660_cur."ws"()
    unless $P10, rx1660_fail
    rx1660_pos = $P10."pos"()
  # rx subrule "comp_unit" subtype=capture negate=
    rx1660_cur."!cursor_pos"(rx1660_pos)
    $P10 = rx1660_cur."comp_unit"()
    unless $P10, rx1660_fail
    rx1660_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("comp_unit")
    rx1660_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1660_cur."!cursor_pos"(rx1660_pos)
    $P10 = rx1660_cur."ws"()
    unless $P10, rx1660_fail
    rx1660_pos = $P10."pos"()
    goto alt1701_end
  alt1701_1:
    set_addr $I10, alt1701_2
    rx1660_cur."!mark_push"(0, rx1660_pos, $I10)
.annotate 'line', 810
  # rx subrule "ws" subtype=method negate=
    rx1660_cur."!cursor_pos"(rx1660_pos)
    $P10 = rx1660_cur."ws"()
    unless $P10, rx1660_fail
    rx1660_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1660_pos, rx1660_off
    substr $S10, rx1660_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1660_fail
  # rx subrule "ws" subtype=method negate=
    rx1660_cur."!cursor_pos"(rx1660_pos)
    $P10 = rx1660_cur."ws"()
    unless $P10, rx1660_fail
    rx1660_pos = $P10."pos"()
  # rx subrule "block" subtype=capture negate=
    rx1660_cur."!cursor_pos"(rx1660_pos)
    $P10 = rx1660_cur."block"()
    unless $P10, rx1660_fail
    rx1660_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1660_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1660_cur."!cursor_pos"(rx1660_pos)
    $P10 = rx1660_cur."ws"()
    unless $P10, rx1660_fail
    rx1660_pos = $P10."pos"()
    goto alt1701_end
  alt1701_2:
.annotate 'line', 811
  # rx subrule "ws" subtype=method negate=
    rx1660_cur."!cursor_pos"(rx1660_pos)
    $P10 = rx1660_cur."ws"()
    unless $P10, rx1660_fail
    rx1660_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1660_cur."!cursor_pos"(rx1660_pos)
    $P10 = rx1660_cur."panic"("Malformed package declaration")
    unless $P10, rx1660_fail
    rx1660_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1660_cur."!cursor_pos"(rx1660_pos)
    $P10 = rx1660_cur."ws"()
    unless $P10, rx1660_fail
    rx1660_pos = $P10."pos"()
  alt1701_end:
.annotate 'line', 812
  # rx subrule "ws" subtype=method negate=
    rx1660_cur."!cursor_pos"(rx1660_pos)
    $P10 = rx1660_cur."ws"()
    unless $P10, rx1660_fail
    rx1660_pos = $P10."pos"()
.annotate 'line', 772
  # rx pass
    rx1660_cur."!cursor_pass"(rx1660_pos, "package_def")
    if_null rx1660_debug, debug_1231
    rx1660_cur."!cursor_debug"("PASS", "package_def", " at pos=", rx1660_pos)
  debug_1231:
    .return (rx1660_cur)
  rx1660_restart:
.annotate 'line', 435
    if_null rx1660_debug, debug_1232
    rx1660_cur."!cursor_debug"("NEXT", "package_def")
  debug_1232:
  rx1660_fail:
    (rx1660_rep, rx1660_pos, $I10, $P10) = rx1660_cur."!mark_fail"(0)
    lt rx1660_pos, -1, rx1660_done
    eq rx1660_pos, -1, rx1660_fail
    jump $I10
  rx1660_done:
    rx1660_cur."!cursor_fail"()
    if_null rx1660_debug, debug_1233
    rx1660_cur."!cursor_debug"("FAIL", "package_def")
  debug_1233:
    .return (rx1660_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1663"  :anon :subid("183_1310110678.31883") :outer("182_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 781
    $P1666 = root_new ['parrot';'Hash']
    set $P1665, $P1666
    .lex "%args", $P1665
.annotate 'line', 778
    find_lex $P1667, "%args"
    unless_null $P1667, vivify_1164
    $P1667 = root_new ['parrot';'Hash']
  vivify_1164:
.annotate 'line', 782
    find_lex $P1668, "$/"
    unless_null $P1668, vivify_1165
    $P1668 = root_new ['parrot';'Hash']
  vivify_1165:
    set $P118, $P1668["name"]
    unless_null $P118, vivify_1166
    new $P118, "Undef"
  vivify_1166:
    set $S100, $P118
    new $P119, 'String'
    set $P119, $S100
    find_lex $P1669, "%args"
    unless_null $P1669, vivify_1167
    $P1669 = root_new ['parrot';'Hash']
    store_lex "%args", $P1669
  vivify_1167:
    set $P1669["name"], $P119
.annotate 'line', 783
    find_lex $P1671, "$/"
    unless_null $P1671, vivify_1168
    $P1671 = root_new ['parrot';'Hash']
  vivify_1168:
    set $P118, $P1671["repr"]
    unless_null $P118, vivify_1169
    new $P118, "Undef"
  vivify_1169:
    unless $P118, if_1670_end
.annotate 'line', 784
    find_lex $P1672, "$/"
    unless_null $P1672, vivify_1170
    $P1672 = root_new ['parrot';'Hash']
  vivify_1170:
    set $P1673, $P1672["repr"]
    unless_null $P1673, vivify_1171
    $P1673 = root_new ['parrot';'ResizablePMCArray']
  vivify_1171:
    set $P1674, $P1673[0]
    unless_null $P1674, vivify_1172
    $P1674 = root_new ['parrot';'Hash']
  vivify_1172:
    set $P1675, $P1674["quote_delimited"]
    unless_null $P1675, vivify_1173
    $P1675 = root_new ['parrot';'Hash']
  vivify_1173:
    set $P1676, $P1675["quote_atom"]
    unless_null $P1676, vivify_1174
    $P1676 = root_new ['parrot';'ResizablePMCArray']
  vivify_1174:
    set $P119, $P1676[0]
    unless_null $P119, vivify_1175
    new $P119, "Undef"
  vivify_1175:
    set $S100, $P119
    new $P120, 'String'
    set $P120, $S100
    find_lex $P1677, "%args"
    unless_null $P1677, vivify_1176
    $P1677 = root_new ['parrot';'Hash']
    store_lex "%args", $P1677
  vivify_1176:
    set $P1677["repr"], $P120
  if_1670_end:
.annotate 'line', 786
    find_dynamic_lex $P120, "$*SC"
    unless_null $P120, vivify_1177
    get_hll_global $P118, "GLOBAL"
    get_who $P119, $P118
    set $P120, $P119["$SC"]
    unless_null $P120, vivify_1178
    die "Contextual $*SC not found"
  vivify_1178:
  vivify_1177:
    find_dynamic_lex $P123, "$*PKGDECL"
    unless_null $P123, vivify_1179
    get_hll_global $P121, "GLOBAL"
    get_who $P122, $P121
    set $P123, $P122["$PKGDECL"]
    unless_null $P123, vivify_1180
    die "Contextual $*PKGDECL not found"
  vivify_1180:
  vivify_1179:
    find_dynamic_lex $P126, "%*HOW"
    unless_null $P126, vivify_1181
    get_hll_global $P124, "GLOBAL"
    get_who $P125, $P124
    set $P126, $P125["%HOW"]
    unless_null $P126, vivify_1182
    die "Contextual %*HOW not found"
  vivify_1182:
  vivify_1181:
    set $P127, $P126[$P123]
    unless_null $P127, vivify_1183
    new $P127, "Undef"
  vivify_1183:
    find_lex $P1678, "%args"
    unless_null $P1678, vivify_1184
    $P1678 = root_new ['parrot';'Hash']
  vivify_1184:
    $P128 = $P120."pkg_create_mo"($P127, $P1678 :flat)
    store_dynamic_lex "$*PACKAGE", $P128
.annotate 'line', 789
    find_dynamic_lex $P122, "$*SCOPE"
    unless_null $P122, vivify_1185
    get_hll_global $P120, "GLOBAL"
    get_who $P121, $P120
    set $P122, $P121["$SCOPE"]
    unless_null $P122, vivify_1186
    die "Contextual $*SCOPE not found"
  vivify_1186:
  vivify_1185:
    set $S100, $P122
    iseq $I100, $S100, "our"
    unless $I100, unless_1680
    new $P119, 'Integer'
    set $P119, $I100
    goto unless_1680_end
  unless_1680:
    find_dynamic_lex $P125, "$*SCOPE"
    unless_null $P125, vivify_1187
    get_hll_global $P123, "GLOBAL"
    get_who $P124, $P123
    set $P125, $P124["$SCOPE"]
    unless_null $P125, vivify_1188
    die "Contextual $*SCOPE not found"
  vivify_1188:
  vivify_1187:
    set $S101, $P125
    iseq $I101, $S101, ""
    new $P119, 'Integer'
    set $P119, $I101
  unless_1680_end:
    if $P119, if_1679
.annotate 'line', 795
    find_dynamic_lex $P130, "$*SCOPE"
    unless_null $P130, vivify_1189
    get_hll_global $P128, "GLOBAL"
    get_who $P129, $P128
    set $P130, $P129["$SCOPE"]
    unless_null $P130, vivify_1190
    die "Contextual $*SCOPE not found"
  vivify_1190:
  vivify_1189:
    set $S102, $P130
    iseq $I102, $S102, "my"
    if $I102, if_1690
.annotate 'line', 802
    find_lex $P131, "$/"
    unless_null $P131, vivify_1191
    new $P131, "Undef"
  vivify_1191:
    $P132 = $P131."CURSOR"()
    find_dynamic_lex $P135, "$*SCOPE"
    unless_null $P135, vivify_1192
    get_hll_global $P133, "GLOBAL"
    get_who $P134, $P133
    set $P135, $P134["$SCOPE"]
    unless_null $P135, vivify_1193
    die "Contextual $*SCOPE not found"
  vivify_1193:
  vivify_1192:
    concat $P136, $P135, " scoped packages are not supported"
    $P137 = $P132."panic"($P136)
.annotate 'line', 801
    set $P127, $P137
.annotate 'line', 795
    goto if_1690_end
  if_1690:
.annotate 'line', 796
    find_lex $P1692, "$/"
    unless_null $P1692, vivify_1194
    $P1692 = root_new ['parrot';'Hash']
  vivify_1194:
    set $P1693, $P1692["name"]
    unless_null $P1693, vivify_1195
    $P1693 = root_new ['parrot';'Hash']
  vivify_1195:
    set $P131, $P1693["identifier"]
    unless_null $P131, vivify_1196
    new $P131, "Undef"
  vivify_1196:
    set $N100, $P131
    isne $I103, $N100, 1.0
    unless $I103, if_1691_end
.annotate 'line', 797
    find_lex $P1694, "$/"
    unless_null $P1694, vivify_1197
    $P1694 = root_new ['parrot';'Hash']
  vivify_1197:
    set $P132, $P1694["name"]
    unless_null $P132, vivify_1198
    new $P132, "Undef"
  vivify_1198:
    $P133 = $P132."CURSOR"()
    $P133."panic"("A my scoped package cannot have a multi-part name yet")
  if_1691_end:
.annotate 'line', 799
    find_dynamic_lex $P133, "$*SC"
    unless_null $P133, vivify_1199
    get_hll_global $P131, "GLOBAL"
    get_who $P132, $P131
    set $P133, $P132["$SC"]
    unless_null $P133, vivify_1200
    die "Contextual $*SC not found"
  vivify_1200:
  vivify_1199:
    get_hll_global $P134, "GLOBAL"
    nqp_get_package_through_who $P135, $P134, "NQP"
    nqp_get_package_through_who $P136, $P135, "Actions"
    get_who $P137, $P136
    set $P1695, $P137["@BLOCK"]
    unless_null $P1695, vivify_1201
    $P1695 = root_new ['parrot';'ResizablePMCArray']
  vivify_1201:
    set $P138, $P1695[0]
    unless_null $P138, vivify_1202
    new $P138, "Undef"
  vivify_1202:
    find_lex $P1696, "$/"
    unless_null $P1696, vivify_1203
    $P1696 = root_new ['parrot';'Hash']
  vivify_1203:
    set $P1697, $P1696["name"]
    unless_null $P1697, vivify_1204
    $P1697 = root_new ['parrot';'Hash']
  vivify_1204:
    set $P1698, $P1697["identifier"]
    unless_null $P1698, vivify_1205
    $P1698 = root_new ['parrot';'ResizablePMCArray']
  vivify_1205:
    set $P139, $P1698[0]
    unless_null $P139, vivify_1206
    new $P139, "Undef"
  vivify_1206:
    find_dynamic_lex $P142, "$*PACKAGE"
    unless_null $P142, vivify_1207
    get_hll_global $P140, "GLOBAL"
    get_who $P141, $P140
    set $P142, $P141["$PACKAGE"]
    unless_null $P142, vivify_1208
    die "Contextual $*PACKAGE not found"
  vivify_1208:
  vivify_1207:
    $P143 = $P133."install_lexical_symbol"($P138, $P139, $P142)
.annotate 'line', 795
    set $P127, $P143
  if_1690_end:
    set $P118, $P127
.annotate 'line', 789
    goto if_1679_end
  if_1679:
.annotate 'line', 790
    find_dynamic_lex $P128, "$*SC"
    unless_null $P128, vivify_1209
    get_hll_global $P126, "GLOBAL"
    get_who $P127, $P126
    set $P128, $P127["$SC"]
    unless_null $P128, vivify_1210
    die "Contextual $*SC not found"
  vivify_1210:
  vivify_1209:
    find_dynamic_lex $P131, "$*OUTERPACKAGE"
    unless_null $P131, vivify_1211
    get_hll_global $P129, "GLOBAL"
    get_who $P130, $P129
    set $P131, $P130["$OUTERPACKAGE"]
    unless_null $P131, vivify_1212
    die "Contextual $*OUTERPACKAGE not found"
  vivify_1212:
  vivify_1211:
    find_lex $P1681, "$/"
    unless_null $P1681, vivify_1213
    $P1681 = root_new ['parrot';'Hash']
  vivify_1213:
    set $P1682, $P1681["name"]
    unless_null $P1682, vivify_1214
    $P1682 = root_new ['parrot';'Hash']
  vivify_1214:
    set $P132, $P1682["identifier"]
    unless_null $P132, vivify_1215
    new $P132, "Undef"
  vivify_1215:
    find_dynamic_lex $P135, "$*PACKAGE"
    unless_null $P135, vivify_1216
    get_hll_global $P133, "GLOBAL"
    get_who $P134, $P133
    set $P135, $P134["$PACKAGE"]
    unless_null $P135, vivify_1217
    die "Contextual $*PACKAGE not found"
  vivify_1217:
  vivify_1216:
    $P128."install_package_symbol"($P131, $P132, $P135)
.annotate 'line', 791
    find_lex $P1684, "$/"
    unless_null $P1684, vivify_1218
    $P1684 = root_new ['parrot';'Hash']
  vivify_1218:
    set $P1685, $P1684["name"]
    unless_null $P1685, vivify_1219
    $P1685 = root_new ['parrot';'Hash']
  vivify_1219:
    set $P127, $P1685["identifier"]
    unless_null $P127, vivify_1220
    new $P127, "Undef"
  vivify_1220:
    set $N100, $P127
    iseq $I102, $N100, 1.0
    if $I102, if_1683
    new $P126, 'Integer'
    set $P126, $I102
    goto if_1683_end
  if_1683:
.annotate 'line', 792
    find_dynamic_lex $P130, "$*SC"
    unless_null $P130, vivify_1221
    get_hll_global $P128, "GLOBAL"
    get_who $P129, $P128
    set $P130, $P129["$SC"]
    unless_null $P130, vivify_1222
    die "Contextual $*SC not found"
  vivify_1222:
  vivify_1221:
    get_hll_global $P131, "GLOBAL"
    nqp_get_package_through_who $P132, $P131, "NQP"
    nqp_get_package_through_who $P133, $P132, "Actions"
    get_who $P134, $P133
    set $P1686, $P134["@BLOCK"]
    unless_null $P1686, vivify_1223
    $P1686 = root_new ['parrot';'ResizablePMCArray']
  vivify_1223:
    set $P135, $P1686[0]
    unless_null $P135, vivify_1224
    new $P135, "Undef"
  vivify_1224:
    find_lex $P1687, "$/"
    unless_null $P1687, vivify_1225
    $P1687 = root_new ['parrot';'Hash']
  vivify_1225:
    set $P1688, $P1687["name"]
    unless_null $P1688, vivify_1226
    $P1688 = root_new ['parrot';'Hash']
  vivify_1226:
    set $P1689, $P1688["identifier"]
    unless_null $P1689, vivify_1227
    $P1689 = root_new ['parrot';'ResizablePMCArray']
  vivify_1227:
    set $P136, $P1689[0]
    unless_null $P136, vivify_1228
    new $P136, "Undef"
  vivify_1228:
    find_dynamic_lex $P139, "$*PACKAGE"
    unless_null $P139, vivify_1229
    get_hll_global $P137, "GLOBAL"
    get_who $P138, $P137
    set $P139, $P138["$PACKAGE"]
    unless_null $P139, vivify_1230
    die "Contextual $*PACKAGE not found"
  vivify_1230:
  vivify_1229:
    $P140 = $P130."install_lexical_symbol"($P135, $P136, $P139)
.annotate 'line', 791
    set $P126, $P140
  if_1683_end:
.annotate 'line', 789
    set $P118, $P126
  if_1679_end:
.annotate 'line', 778
    .return ($P118)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_def"  :subid("184_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P138 = self."!PREFIX__!subrule"("ws", "")
    new $P139, "ResizablePMCArray"
    push $P139, $P138
    .return ($P139)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator"  :subid("185_1310110678.31883")
    .param pmc param_1704
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 815
    .lex "self", param_1704
    $P103 = param_1704."!protoregex"("scope_declarator")
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator"  :subid("186_1310110678.31883")
    .param pmc param_1706
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 815
    .lex "self", param_1706
    $P104 = param_1706."!PREFIX__!protoregex"("scope_declarator")
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<my>"  :subid("187_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1708_tgt
    .local int rx1708_pos
    .local int rx1708_off
    .local int rx1708_eos
    .local int rx1708_rep
    .local pmc rx1708_cur
    .local pmc rx1708_debug
    (rx1708_cur, rx1708_pos, rx1708_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1708_cur
    .local pmc match
    .lex "$/", match
    length rx1708_eos, rx1708_tgt
    gt rx1708_pos, rx1708_eos, rx1708_done
    set rx1708_off, 0
    lt rx1708_pos, 2, rx1708_start
    sub rx1708_off, rx1708_pos, 1
    substr rx1708_tgt, rx1708_tgt, rx1708_off
  rx1708_start:
    eq $I10, 1, rx1708_restart
    if_null rx1708_debug, debug_1234
    rx1708_cur."!cursor_debug"("START", "scope_declarator:sym<my>")
  debug_1234:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1709_done
    goto rxscan1709_scan
  rxscan1709_loop:
    (rx1708_pos) = rx1708_cur."from"()
    inc rx1708_pos
    rx1708_cur."!cursor_from"(rx1708_pos)
    ge rx1708_pos, rx1708_eos, rxscan1709_done
  rxscan1709_scan:
    set_addr $I10, rxscan1709_loop
    rx1708_cur."!mark_push"(0, rx1708_pos, $I10)
  rxscan1709_done:
.annotate 'line', 816
  # rx subcapture "sym"
    set_addr $I10, rxcap_1710_fail
    rx1708_cur."!mark_push"(0, rx1708_pos, $I10)
  # rx literal  "my"
    add $I11, rx1708_pos, 2
    gt $I11, rx1708_eos, rx1708_fail
    sub $I11, rx1708_pos, rx1708_off
    substr $S10, rx1708_tgt, $I11, 2
    ne $S10, "my", rx1708_fail
    add rx1708_pos, 2
    set_addr $I10, rxcap_1710_fail
    ($I12, $I11) = rx1708_cur."!mark_peek"($I10)
    rx1708_cur."!cursor_pos"($I11)
    ($P10) = rx1708_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1708_pos, "")
    rx1708_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1710_done
  rxcap_1710_fail:
    goto rx1708_fail
  rxcap_1710_done:
  # rx subrule "scoped" subtype=capture negate=
    rx1708_cur."!cursor_pos"(rx1708_pos)
    $P10 = rx1708_cur."scoped"("my")
    unless $P10, rx1708_fail
    rx1708_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx1708_pos = $P10."pos"()
  # rx pass
    rx1708_cur."!cursor_pass"(rx1708_pos, "scope_declarator:sym<my>")
    if_null rx1708_debug, debug_1235
    rx1708_cur."!cursor_debug"("PASS", "scope_declarator:sym<my>", " at pos=", rx1708_pos)
  debug_1235:
    .return (rx1708_cur)
  rx1708_restart:
.annotate 'line', 435
    if_null rx1708_debug, debug_1236
    rx1708_cur."!cursor_debug"("NEXT", "scope_declarator:sym<my>")
  debug_1236:
  rx1708_fail:
    (rx1708_rep, rx1708_pos, $I10, $P10) = rx1708_cur."!mark_fail"(0)
    lt rx1708_pos, -1, rx1708_done
    eq rx1708_pos, -1, rx1708_fail
    jump $I10
  rx1708_done:
    rx1708_cur."!cursor_fail"()
    if_null rx1708_debug, debug_1237
    rx1708_cur."!cursor_debug"("FAIL", "scope_declarator:sym<my>")
  debug_1237:
    .return (rx1708_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<my>"  :subid("188_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("scoped", "my")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<our>"  :subid("189_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1713_tgt
    .local int rx1713_pos
    .local int rx1713_off
    .local int rx1713_eos
    .local int rx1713_rep
    .local pmc rx1713_cur
    .local pmc rx1713_debug
    (rx1713_cur, rx1713_pos, rx1713_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1713_cur
    .local pmc match
    .lex "$/", match
    length rx1713_eos, rx1713_tgt
    gt rx1713_pos, rx1713_eos, rx1713_done
    set rx1713_off, 0
    lt rx1713_pos, 2, rx1713_start
    sub rx1713_off, rx1713_pos, 1
    substr rx1713_tgt, rx1713_tgt, rx1713_off
  rx1713_start:
    eq $I10, 1, rx1713_restart
    if_null rx1713_debug, debug_1238
    rx1713_cur."!cursor_debug"("START", "scope_declarator:sym<our>")
  debug_1238:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1714_done
    goto rxscan1714_scan
  rxscan1714_loop:
    (rx1713_pos) = rx1713_cur."from"()
    inc rx1713_pos
    rx1713_cur."!cursor_from"(rx1713_pos)
    ge rx1713_pos, rx1713_eos, rxscan1714_done
  rxscan1714_scan:
    set_addr $I10, rxscan1714_loop
    rx1713_cur."!mark_push"(0, rx1713_pos, $I10)
  rxscan1714_done:
.annotate 'line', 817
  # rx subcapture "sym"
    set_addr $I10, rxcap_1715_fail
    rx1713_cur."!mark_push"(0, rx1713_pos, $I10)
  # rx literal  "our"
    add $I11, rx1713_pos, 3
    gt $I11, rx1713_eos, rx1713_fail
    sub $I11, rx1713_pos, rx1713_off
    substr $S10, rx1713_tgt, $I11, 3
    ne $S10, "our", rx1713_fail
    add rx1713_pos, 3
    set_addr $I10, rxcap_1715_fail
    ($I12, $I11) = rx1713_cur."!mark_peek"($I10)
    rx1713_cur."!cursor_pos"($I11)
    ($P10) = rx1713_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1713_pos, "")
    rx1713_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1715_done
  rxcap_1715_fail:
    goto rx1713_fail
  rxcap_1715_done:
  # rx subrule "scoped" subtype=capture negate=
    rx1713_cur."!cursor_pos"(rx1713_pos)
    $P10 = rx1713_cur."scoped"("our")
    unless $P10, rx1713_fail
    rx1713_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx1713_pos = $P10."pos"()
  # rx pass
    rx1713_cur."!cursor_pass"(rx1713_pos, "scope_declarator:sym<our>")
    if_null rx1713_debug, debug_1239
    rx1713_cur."!cursor_debug"("PASS", "scope_declarator:sym<our>", " at pos=", rx1713_pos)
  debug_1239:
    .return (rx1713_cur)
  rx1713_restart:
.annotate 'line', 435
    if_null rx1713_debug, debug_1240
    rx1713_cur."!cursor_debug"("NEXT", "scope_declarator:sym<our>")
  debug_1240:
  rx1713_fail:
    (rx1713_rep, rx1713_pos, $I10, $P10) = rx1713_cur."!mark_fail"(0)
    lt rx1713_pos, -1, rx1713_done
    eq rx1713_pos, -1, rx1713_fail
    jump $I10
  rx1713_done:
    rx1713_cur."!cursor_fail"()
    if_null rx1713_debug, debug_1241
    rx1713_cur."!cursor_debug"("FAIL", "scope_declarator:sym<our>")
  debug_1241:
    .return (rx1713_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<our>"  :subid("190_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("scoped", "our")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<has>"  :subid("191_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1718_tgt
    .local int rx1718_pos
    .local int rx1718_off
    .local int rx1718_eos
    .local int rx1718_rep
    .local pmc rx1718_cur
    .local pmc rx1718_debug
    (rx1718_cur, rx1718_pos, rx1718_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1718_cur
    .local pmc match
    .lex "$/", match
    length rx1718_eos, rx1718_tgt
    gt rx1718_pos, rx1718_eos, rx1718_done
    set rx1718_off, 0
    lt rx1718_pos, 2, rx1718_start
    sub rx1718_off, rx1718_pos, 1
    substr rx1718_tgt, rx1718_tgt, rx1718_off
  rx1718_start:
    eq $I10, 1, rx1718_restart
    if_null rx1718_debug, debug_1242
    rx1718_cur."!cursor_debug"("START", "scope_declarator:sym<has>")
  debug_1242:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1719_done
    goto rxscan1719_scan
  rxscan1719_loop:
    (rx1718_pos) = rx1718_cur."from"()
    inc rx1718_pos
    rx1718_cur."!cursor_from"(rx1718_pos)
    ge rx1718_pos, rx1718_eos, rxscan1719_done
  rxscan1719_scan:
    set_addr $I10, rxscan1719_loop
    rx1718_cur."!mark_push"(0, rx1718_pos, $I10)
  rxscan1719_done:
.annotate 'line', 818
  # rx subcapture "sym"
    set_addr $I10, rxcap_1720_fail
    rx1718_cur."!mark_push"(0, rx1718_pos, $I10)
  # rx literal  "has"
    add $I11, rx1718_pos, 3
    gt $I11, rx1718_eos, rx1718_fail
    sub $I11, rx1718_pos, rx1718_off
    substr $S10, rx1718_tgt, $I11, 3
    ne $S10, "has", rx1718_fail
    add rx1718_pos, 3
    set_addr $I10, rxcap_1720_fail
    ($I12, $I11) = rx1718_cur."!mark_peek"($I10)
    rx1718_cur."!cursor_pos"($I11)
    ($P10) = rx1718_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1718_pos, "")
    rx1718_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1720_done
  rxcap_1720_fail:
    goto rx1718_fail
  rxcap_1720_done:
  # rx subrule "scoped" subtype=capture negate=
    rx1718_cur."!cursor_pos"(rx1718_pos)
    $P10 = rx1718_cur."scoped"("has")
    unless $P10, rx1718_fail
    rx1718_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx1718_pos = $P10."pos"()
  # rx pass
    rx1718_cur."!cursor_pass"(rx1718_pos, "scope_declarator:sym<has>")
    if_null rx1718_debug, debug_1243
    rx1718_cur."!cursor_debug"("PASS", "scope_declarator:sym<has>", " at pos=", rx1718_pos)
  debug_1243:
    .return (rx1718_cur)
  rx1718_restart:
.annotate 'line', 435
    if_null rx1718_debug, debug_1244
    rx1718_cur."!cursor_debug"("NEXT", "scope_declarator:sym<has>")
  debug_1244:
  rx1718_fail:
    (rx1718_rep, rx1718_pos, $I10, $P10) = rx1718_cur."!mark_fail"(0)
    lt rx1718_pos, -1, rx1718_done
    eq rx1718_pos, -1, rx1718_fail
    jump $I10
  rx1718_done:
    rx1718_cur."!cursor_fail"()
    if_null rx1718_debug, debug_1245
    rx1718_cur."!cursor_debug"("FAIL", "scope_declarator:sym<has>")
  debug_1245:
    .return (rx1718_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<has>"  :subid("192_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("scoped", "has")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scoped"  :subid("193_1310110678.31883") :method :outer("40_1310110678.31883")
    .param pmc param_1723
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 820
    .lex "$*SCOPE", param_1723
.annotate 'line', 435
    .local string rx1724_tgt
    .local int rx1724_pos
    .local int rx1724_off
    .local int rx1724_eos
    .local int rx1724_rep
    .local pmc rx1724_cur
    .local pmc rx1724_debug
    (rx1724_cur, rx1724_pos, rx1724_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1724_cur
    .local pmc match
    .lex "$/", match
    length rx1724_eos, rx1724_tgt
    gt rx1724_pos, rx1724_eos, rx1724_done
    set rx1724_off, 0
    lt rx1724_pos, 2, rx1724_start
    sub rx1724_off, rx1724_pos, 1
    substr rx1724_tgt, rx1724_tgt, rx1724_off
  rx1724_start:
    eq $I10, 1, rx1724_restart
    if_null rx1724_debug, debug_1246
    rx1724_cur."!cursor_debug"("START", "scoped")
  debug_1246:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1725_done
    goto rxscan1725_scan
  rxscan1725_loop:
    (rx1724_pos) = rx1724_cur."from"()
    inc rx1724_pos
    rx1724_cur."!cursor_from"(rx1724_pos)
    ge rx1724_pos, rx1724_eos, rxscan1725_done
  rxscan1725_scan:
    set_addr $I10, rxscan1725_loop
    rx1724_cur."!mark_push"(0, rx1724_pos, $I10)
  rxscan1725_done:
  alt1726_0:
.annotate 'line', 820
    set_addr $I10, alt1726_1
    rx1724_cur."!mark_push"(0, rx1724_pos, $I10)
.annotate 'line', 821
  # rx subrule "ws" subtype=method negate=
    rx1724_cur."!cursor_pos"(rx1724_pos)
    $P10 = rx1724_cur."ws"()
    unless $P10, rx1724_fail
    rx1724_pos = $P10."pos"()
  # rx subrule "declarator" subtype=capture negate=
    rx1724_cur."!cursor_pos"(rx1724_pos)
    $P10 = rx1724_cur."declarator"()
    unless $P10, rx1724_fail
    rx1724_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1724_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1724_cur."!cursor_pos"(rx1724_pos)
    $P10 = rx1724_cur."ws"()
    unless $P10, rx1724_fail
    rx1724_pos = $P10."pos"()
    goto alt1726_end
  alt1726_1:
    set_addr $I10, alt1726_2
    rx1724_cur."!mark_push"(0, rx1724_pos, $I10)
.annotate 'line', 822
  # rx subrule "ws" subtype=method negate=
    rx1724_cur."!cursor_pos"(rx1724_pos)
    $P10 = rx1724_cur."ws"()
    unless $P10, rx1724_fail
    rx1724_pos = $P10."pos"()
  # rx subrule "multi_declarator" subtype=capture negate=
    rx1724_cur."!cursor_pos"(rx1724_pos)
    $P10 = rx1724_cur."multi_declarator"()
    unless $P10, rx1724_fail
    rx1724_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx1724_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1724_cur."!cursor_pos"(rx1724_pos)
    $P10 = rx1724_cur."ws"()
    unless $P10, rx1724_fail
    rx1724_pos = $P10."pos"()
    goto alt1726_end
  alt1726_2:
.annotate 'line', 823
  # rx subrule "ws" subtype=method negate=
    rx1724_cur."!cursor_pos"(rx1724_pos)
    $P10 = rx1724_cur."ws"()
    unless $P10, rx1724_fail
    rx1724_pos = $P10."pos"()
  # rx subrule "package_declarator" subtype=capture negate=
    rx1724_cur."!cursor_pos"(rx1724_pos)
    $P10 = rx1724_cur."package_declarator"()
    unless $P10, rx1724_fail
    rx1724_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx1724_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1724_cur."!cursor_pos"(rx1724_pos)
    $P10 = rx1724_cur."ws"()
    unless $P10, rx1724_fail
    rx1724_pos = $P10."pos"()
  alt1726_end:
.annotate 'line', 820
  # rx pass
    rx1724_cur."!cursor_pass"(rx1724_pos, "scoped")
    if_null rx1724_debug, debug_1247
    rx1724_cur."!cursor_debug"("PASS", "scoped", " at pos=", rx1724_pos)
  debug_1247:
    .return (rx1724_cur)
  rx1724_restart:
.annotate 'line', 435
    if_null rx1724_debug, debug_1248
    rx1724_cur."!cursor_debug"("NEXT", "scoped")
  debug_1248:
  rx1724_fail:
    (rx1724_rep, rx1724_pos, $I10, $P10) = rx1724_cur."!mark_fail"(0)
    lt rx1724_pos, -1, rx1724_done
    eq rx1724_pos, -1, rx1724_fail
    jump $I10
  rx1724_done:
    rx1724_cur."!cursor_fail"()
    if_null rx1724_debug, debug_1249
    rx1724_cur."!cursor_debug"("FAIL", "scoped")
  debug_1249:
    .return (rx1724_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scoped"  :subid("194_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P109 = self."!PREFIX__!subrule"("ws", "")
    $P110 = self."!PREFIX__!subrule"("ws", "")
    $P111 = self."!PREFIX__!subrule"("ws", "")
    new $P112, "ResizablePMCArray"
    push $P112, $P109
    push $P112, $P110
    push $P112, $P111
    .return ($P112)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "typename"  :subid("195_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .const 'Sub' $P1732 = "196_1310110678.31883" 
    capture_lex $P1732
    .local string rx1729_tgt
    .local int rx1729_pos
    .local int rx1729_off
    .local int rx1729_eos
    .local int rx1729_rep
    .local pmc rx1729_cur
    .local pmc rx1729_debug
    (rx1729_cur, rx1729_pos, rx1729_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1729_cur
    .local pmc match
    .lex "$/", match
    length rx1729_eos, rx1729_tgt
    gt rx1729_pos, rx1729_eos, rx1729_done
    set rx1729_off, 0
    lt rx1729_pos, 2, rx1729_start
    sub rx1729_off, rx1729_pos, 1
    substr rx1729_tgt, rx1729_tgt, rx1729_off
  rx1729_start:
    eq $I10, 1, rx1729_restart
    if_null rx1729_debug, debug_1250
    rx1729_cur."!cursor_debug"("START", "typename")
  debug_1250:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1730_done
    goto rxscan1730_scan
  rxscan1730_loop:
    (rx1729_pos) = rx1729_cur."from"()
    inc rx1729_pos
    rx1729_cur."!cursor_from"(rx1729_pos)
    ge rx1729_pos, rx1729_eos, rxscan1730_done
  rxscan1730_scan:
    set_addr $I10, rxscan1730_loop
    rx1729_cur."!mark_push"(0, rx1729_pos, $I10)
  rxscan1730_done:
.annotate 'line', 827
  # rx subrule "name" subtype=capture negate=
    rx1729_cur."!cursor_pos"(rx1729_pos)
    $P10 = rx1729_cur."name"()
    unless $P10, rx1729_fail
    rx1729_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1729_pos = $P10."pos"()
.annotate 'line', 828
    rx1729_cur."!cursor_pos"(rx1729_pos)
    find_lex $P103, unicode:"$\x{a2}"
    $P104 = $P103."MATCH"()
    store_lex "$/", $P104
    .const 'Sub' $P1732 = "196_1310110678.31883" 
    capture_lex $P1732
    $P105 = $P1732()
    unless $P105, rx1729_fail
.annotate 'line', 826
  # rx pass
    rx1729_cur."!cursor_pass"(rx1729_pos, "typename")
    if_null rx1729_debug, debug_1257
    rx1729_cur."!cursor_debug"("PASS", "typename", " at pos=", rx1729_pos)
  debug_1257:
    .return (rx1729_cur)
  rx1729_restart:
.annotate 'line', 435
    if_null rx1729_debug, debug_1258
    rx1729_cur."!cursor_debug"("NEXT", "typename")
  debug_1258:
  rx1729_fail:
    (rx1729_rep, rx1729_pos, $I10, $P10) = rx1729_cur."!mark_fail"(0)
    lt rx1729_pos, -1, rx1729_done
    eq rx1729_pos, -1, rx1729_fail
    jump $I10
  rx1729_done:
    rx1729_cur."!cursor_fail"()
    if_null rx1729_debug, debug_1259
    rx1729_cur."!cursor_debug"("FAIL", "typename")
  debug_1259:
    .return (rx1729_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1731"  :anon :subid("196_1310110678.31883") :outer("195_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 828
    find_dynamic_lex $P107, "$*ACTIONS"
    unless_null $P107, vivify_1251
    get_hll_global $P105, "GLOBAL"
    get_who $P106, $P105
    set $P107, $P106["$ACTIONS"]
    unless_null $P107, vivify_1252
    die "Contextual $*ACTIONS not found"
  vivify_1252:
  vivify_1251:
    find_lex $P108, "$/"
    unless_null $P108, vivify_1253
    new $P108, "Undef"
  vivify_1253:
    find_lex $P1733, "$/"
    unless_null $P1733, vivify_1254
    $P1733 = root_new ['parrot';'Hash']
  vivify_1254:
    set $P1734, $P1733["name"]
    unless_null $P1734, vivify_1255
    $P1734 = root_new ['parrot';'Hash']
  vivify_1255:
    set $P109, $P1734["identifier"]
    unless_null $P109, vivify_1256
    new $P109, "Undef"
  vivify_1256:
    $P110 = $P107."known_sym"($P108, $P109)
    .return ($P110)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__typename"  :subid("197_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P106 = self."!PREFIX__!subrule"("name", "")
    new $P107, "ResizablePMCArray"
    push $P107, $P106
    .return ($P107)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "declarator"  :subid("198_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1737_tgt
    .local int rx1737_pos
    .local int rx1737_off
    .local int rx1737_eos
    .local int rx1737_rep
    .local pmc rx1737_cur
    .local pmc rx1737_debug
    (rx1737_cur, rx1737_pos, rx1737_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1737_cur
    .local pmc match
    .lex "$/", match
    length rx1737_eos, rx1737_tgt
    gt rx1737_pos, rx1737_eos, rx1737_done
    set rx1737_off, 0
    lt rx1737_pos, 2, rx1737_start
    sub rx1737_off, rx1737_pos, 1
    substr rx1737_tgt, rx1737_tgt, rx1737_off
  rx1737_start:
    eq $I10, 1, rx1737_restart
    if_null rx1737_debug, debug_1260
    rx1737_cur."!cursor_debug"("START", "declarator")
  debug_1260:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1738_done
    goto rxscan1738_scan
  rxscan1738_loop:
    (rx1737_pos) = rx1737_cur."from"()
    inc rx1737_pos
    rx1737_cur."!cursor_from"(rx1737_pos)
    ge rx1737_pos, rx1737_eos, rxscan1738_done
  rxscan1738_scan:
    set_addr $I10, rxscan1738_loop
    rx1737_cur."!mark_push"(0, rx1737_pos, $I10)
  rxscan1738_done:
  alt1739_0:
.annotate 'line', 831
    set_addr $I10, alt1739_1
    rx1737_cur."!mark_push"(0, rx1737_pos, $I10)
.annotate 'line', 832
  # rx subrule "variable_declarator" subtype=capture negate=
    rx1737_cur."!cursor_pos"(rx1737_pos)
    $P10 = rx1737_cur."variable_declarator"()
    unless $P10, rx1737_fail
    rx1737_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable_declarator")
    rx1737_pos = $P10."pos"()
    goto alt1739_end
  alt1739_1:
.annotate 'line', 833
  # rx subrule "routine_declarator" subtype=capture negate=
    rx1737_cur."!cursor_pos"(rx1737_pos)
    $P10 = rx1737_cur."routine_declarator"()
    unless $P10, rx1737_fail
    rx1737_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx1737_pos = $P10."pos"()
  alt1739_end:
.annotate 'line', 831
  # rx pass
    rx1737_cur."!cursor_pass"(rx1737_pos, "declarator")
    if_null rx1737_debug, debug_1261
    rx1737_cur."!cursor_debug"("PASS", "declarator", " at pos=", rx1737_pos)
  debug_1261:
    .return (rx1737_cur)
  rx1737_restart:
.annotate 'line', 435
    if_null rx1737_debug, debug_1262
    rx1737_cur."!cursor_debug"("NEXT", "declarator")
  debug_1262:
  rx1737_fail:
    (rx1737_rep, rx1737_pos, $I10, $P10) = rx1737_cur."!mark_fail"(0)
    lt rx1737_pos, -1, rx1737_done
    eq rx1737_pos, -1, rx1737_fail
    jump $I10
  rx1737_done:
    rx1737_cur."!cursor_fail"()
    if_null rx1737_debug, debug_1263
    rx1737_cur."!cursor_debug"("FAIL", "declarator")
  debug_1263:
    .return (rx1737_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__declarator"  :subid("199_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("routine_declarator", "")
    $P104 = self."!PREFIX__!subrule"("variable_declarator", "")
    new $P105, "ResizablePMCArray"
    push $P105, $P103
    push $P105, $P104
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable_declarator"  :subid("200_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .const 'Sub' $P1748 = "201_1310110678.31883" 
    capture_lex $P1748
.annotate 'line', 838
    new $P103, "Undef"
    set $P1742, $P103
    .lex "$*IN_DECL", $P1742
.annotate 'line', 435
    .local string rx1743_tgt
    .local int rx1743_pos
    .local int rx1743_off
    .local int rx1743_eos
    .local int rx1743_rep
    .local pmc rx1743_cur
    .local pmc rx1743_debug
    (rx1743_cur, rx1743_pos, rx1743_tgt, $I10) = self."!cursor_start"()
    rx1743_cur."!cursor_caparray"("typename", "trait")
    .lex unicode:"$\x{a2}", rx1743_cur
    .local pmc match
    .lex "$/", match
    length rx1743_eos, rx1743_tgt
    gt rx1743_pos, rx1743_eos, rx1743_done
    set rx1743_off, 0
    lt rx1743_pos, 2, rx1743_start
    sub rx1743_off, rx1743_pos, 1
    substr rx1743_tgt, rx1743_tgt, rx1743_off
  rx1743_start:
    eq $I10, 1, rx1743_restart
    if_null rx1743_debug, debug_1264
    rx1743_cur."!cursor_debug"("START", "variable_declarator")
  debug_1264:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1744_done
    goto rxscan1744_scan
  rxscan1744_loop:
    (rx1743_pos) = rx1743_cur."from"()
    inc rx1743_pos
    rx1743_cur."!cursor_from"(rx1743_pos)
    ge rx1743_pos, rx1743_eos, rxscan1744_done
  rxscan1744_scan:
    set_addr $I10, rxscan1744_loop
    rx1743_cur."!mark_push"(0, rx1743_pos, $I10)
  rxscan1744_done:
.annotate 'line', 836
  # rx subrule "ws" subtype=method negate=
    rx1743_cur."!cursor_pos"(rx1743_pos)
    $P10 = rx1743_cur."ws"()
    unless $P10, rx1743_fail
    rx1743_pos = $P10."pos"()
.annotate 'line', 837
  # rx rxquantr1745 ** 0..1
    set_addr $I10, rxquantr1745_done
    rx1743_cur."!mark_push"(0, rx1743_pos, $I10)
  rxquantr1745_loop:
  # rx subrule "typename" subtype=capture negate=
    rx1743_cur."!cursor_pos"(rx1743_pos)
    $P10 = rx1743_cur."typename"()
    unless $P10, rx1743_fail
    goto rxsubrule1746_pass
  rxsubrule1746_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1743_fail
  rxsubrule1746_pass:
    set_addr $I10, rxsubrule1746_back
    rx1743_cur."!mark_push"(0, rx1743_pos, $I10, $P10)
    $P10."!cursor_names"("typename")
    rx1743_pos = $P10."pos"()
    set_addr $I10, rxquantr1745_done
    (rx1743_rep) = rx1743_cur."!mark_commit"($I10)
  rxquantr1745_done:
  # rx subrule "ws" subtype=method negate=
    rx1743_cur."!cursor_pos"(rx1743_pos)
    $P10 = rx1743_cur."ws"()
    unless $P10, rx1743_fail
    rx1743_pos = $P10."pos"()
.annotate 'line', 838
    rx1743_cur."!cursor_pos"(rx1743_pos)
    new $P106, "String"
    assign $P106, "variable"
    store_lex "$*IN_DECL", $P106
  # rx subrule "ws" subtype=method negate=
    rx1743_cur."!cursor_pos"(rx1743_pos)
    $P10 = rx1743_cur."ws"()
    unless $P10, rx1743_fail
    rx1743_pos = $P10."pos"()
.annotate 'line', 839
  # rx subrule "variable" subtype=capture negate=
    rx1743_cur."!cursor_pos"(rx1743_pos)
    $P10 = rx1743_cur."variable"()
    unless $P10, rx1743_fail
    rx1743_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx1743_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1743_cur."!cursor_pos"(rx1743_pos)
    $P10 = rx1743_cur."ws"()
    unless $P10, rx1743_fail
    rx1743_pos = $P10."pos"()
.annotate 'line', 840
    rx1743_cur."!cursor_pos"(rx1743_pos)
    find_lex $P109, unicode:"$\x{a2}"
    $P110 = $P109."MATCH"()
    store_lex "$/", $P110
    .const 'Sub' $P1748 = "201_1310110678.31883" 
    capture_lex $P1748
    $P112 = $P1748()
  # rx subrule "ws" subtype=method negate=
    rx1743_cur."!cursor_pos"(rx1743_pos)
    $P10 = rx1743_cur."ws"()
    unless $P10, rx1743_fail
    rx1743_pos = $P10."pos"()
.annotate 'line', 841
  # rx rxquantr1749 ** 0..*
    set_addr $I10, rxquantr1749_done
    rx1743_cur."!mark_push"(0, rx1743_pos, $I10)
  rxquantr1749_loop:
  # rx subrule "trait" subtype=capture negate=
    rx1743_cur."!cursor_pos"(rx1743_pos)
    $P10 = rx1743_cur."trait"()
    unless $P10, rx1743_fail
    goto rxsubrule1750_pass
  rxsubrule1750_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1743_fail
  rxsubrule1750_pass:
    set_addr $I10, rxsubrule1750_back
    rx1743_cur."!mark_push"(0, rx1743_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx1743_pos = $P10."pos"()
    set_addr $I10, rxquantr1749_done
    (rx1743_rep) = rx1743_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1749_done
    rx1743_cur."!mark_push"(rx1743_rep, rx1743_pos, $I10)
    goto rxquantr1749_loop
  rxquantr1749_done:
  # rx subrule "ws" subtype=method negate=
    rx1743_cur."!cursor_pos"(rx1743_pos)
    $P10 = rx1743_cur."ws"()
    unless $P10, rx1743_fail
    rx1743_pos = $P10."pos"()
.annotate 'line', 836
  # rx pass
    rx1743_cur."!cursor_pass"(rx1743_pos, "variable_declarator")
    if_null rx1743_debug, debug_1265
    rx1743_cur."!cursor_debug"("PASS", "variable_declarator", " at pos=", rx1743_pos)
  debug_1265:
    .return (rx1743_cur)
  rx1743_restart:
.annotate 'line', 435
    if_null rx1743_debug, debug_1266
    rx1743_cur."!cursor_debug"("NEXT", "variable_declarator")
  debug_1266:
  rx1743_fail:
    (rx1743_rep, rx1743_pos, $I10, $P10) = rx1743_cur."!mark_fail"(0)
    lt rx1743_pos, -1, rx1743_done
    eq rx1743_pos, -1, rx1743_fail
    jump $I10
  rx1743_done:
    rx1743_cur."!cursor_fail"()
    if_null rx1743_debug, debug_1267
    rx1743_cur."!cursor_debug"("FAIL", "variable_declarator")
  debug_1267:
    .return (rx1743_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1747"  :anon :subid("201_1310110678.31883") :outer("200_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 840
    new $P111, "Integer"
    assign $P111, 0
    store_dynamic_lex "$*IN_DECL", $P111
    .return ($P111)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable_declarator"  :subid("202_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P115 = self."!PREFIX__!subrule"("ws", "")
    new $P116, "ResizablePMCArray"
    push $P116, $P115
    .return ($P116)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator"  :subid("203_1310110678.31883")
    .param pmc param_1753
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 844
    .lex "self", param_1753
    $P103 = param_1753."!protoregex"("routine_declarator")
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator"  :subid("204_1310110678.31883")
    .param pmc param_1755
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 844
    .lex "self", param_1755
    $P104 = param_1755."!PREFIX__!protoregex"("routine_declarator")
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<sub>"  :subid("205_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1757_tgt
    .local int rx1757_pos
    .local int rx1757_off
    .local int rx1757_eos
    .local int rx1757_rep
    .local pmc rx1757_cur
    .local pmc rx1757_debug
    (rx1757_cur, rx1757_pos, rx1757_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1757_cur
    .local pmc match
    .lex "$/", match
    length rx1757_eos, rx1757_tgt
    gt rx1757_pos, rx1757_eos, rx1757_done
    set rx1757_off, 0
    lt rx1757_pos, 2, rx1757_start
    sub rx1757_off, rx1757_pos, 1
    substr rx1757_tgt, rx1757_tgt, rx1757_off
  rx1757_start:
    eq $I10, 1, rx1757_restart
    if_null rx1757_debug, debug_1268
    rx1757_cur."!cursor_debug"("START", "routine_declarator:sym<sub>")
  debug_1268:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1758_done
    goto rxscan1758_scan
  rxscan1758_loop:
    (rx1757_pos) = rx1757_cur."from"()
    inc rx1757_pos
    rx1757_cur."!cursor_from"(rx1757_pos)
    ge rx1757_pos, rx1757_eos, rxscan1758_done
  rxscan1758_scan:
    set_addr $I10, rxscan1758_loop
    rx1757_cur."!mark_push"(0, rx1757_pos, $I10)
  rxscan1758_done:
.annotate 'line', 845
  # rx subcapture "sym"
    set_addr $I10, rxcap_1759_fail
    rx1757_cur."!mark_push"(0, rx1757_pos, $I10)
  # rx literal  "sub"
    add $I11, rx1757_pos, 3
    gt $I11, rx1757_eos, rx1757_fail
    sub $I11, rx1757_pos, rx1757_off
    substr $S10, rx1757_tgt, $I11, 3
    ne $S10, "sub", rx1757_fail
    add rx1757_pos, 3
    set_addr $I10, rxcap_1759_fail
    ($I12, $I11) = rx1757_cur."!mark_peek"($I10)
    rx1757_cur."!cursor_pos"($I11)
    ($P10) = rx1757_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1757_pos, "")
    rx1757_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1759_done
  rxcap_1759_fail:
    goto rx1757_fail
  rxcap_1759_done:
  # rx subrule "routine_def" subtype=capture negate=
    rx1757_cur."!cursor_pos"(rx1757_pos)
    $P10 = rx1757_cur."routine_def"()
    unless $P10, rx1757_fail
    rx1757_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx1757_pos = $P10."pos"()
  # rx pass
    rx1757_cur."!cursor_pass"(rx1757_pos, "routine_declarator:sym<sub>")
    if_null rx1757_debug, debug_1269
    rx1757_cur."!cursor_debug"("PASS", "routine_declarator:sym<sub>", " at pos=", rx1757_pos)
  debug_1269:
    .return (rx1757_cur)
  rx1757_restart:
.annotate 'line', 435
    if_null rx1757_debug, debug_1270
    rx1757_cur."!cursor_debug"("NEXT", "routine_declarator:sym<sub>")
  debug_1270:
  rx1757_fail:
    (rx1757_rep, rx1757_pos, $I10, $P10) = rx1757_cur."!mark_fail"(0)
    lt rx1757_pos, -1, rx1757_done
    eq rx1757_pos, -1, rx1757_fail
    jump $I10
  rx1757_done:
    rx1757_cur."!cursor_fail"()
    if_null rx1757_debug, debug_1271
    rx1757_cur."!cursor_debug"("FAIL", "routine_declarator:sym<sub>")
  debug_1271:
    .return (rx1757_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<sub>"  :subid("206_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("routine_def", "sub")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<method>"  :subid("207_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1762_tgt
    .local int rx1762_pos
    .local int rx1762_off
    .local int rx1762_eos
    .local int rx1762_rep
    .local pmc rx1762_cur
    .local pmc rx1762_debug
    (rx1762_cur, rx1762_pos, rx1762_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1762_cur
    .local pmc match
    .lex "$/", match
    length rx1762_eos, rx1762_tgt
    gt rx1762_pos, rx1762_eos, rx1762_done
    set rx1762_off, 0
    lt rx1762_pos, 2, rx1762_start
    sub rx1762_off, rx1762_pos, 1
    substr rx1762_tgt, rx1762_tgt, rx1762_off
  rx1762_start:
    eq $I10, 1, rx1762_restart
    if_null rx1762_debug, debug_1272
    rx1762_cur."!cursor_debug"("START", "routine_declarator:sym<method>")
  debug_1272:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1763_done
    goto rxscan1763_scan
  rxscan1763_loop:
    (rx1762_pos) = rx1762_cur."from"()
    inc rx1762_pos
    rx1762_cur."!cursor_from"(rx1762_pos)
    ge rx1762_pos, rx1762_eos, rxscan1763_done
  rxscan1763_scan:
    set_addr $I10, rxscan1763_loop
    rx1762_cur."!mark_push"(0, rx1762_pos, $I10)
  rxscan1763_done:
.annotate 'line', 846
  # rx subcapture "sym"
    set_addr $I10, rxcap_1764_fail
    rx1762_cur."!mark_push"(0, rx1762_pos, $I10)
  # rx literal  "method"
    add $I11, rx1762_pos, 6
    gt $I11, rx1762_eos, rx1762_fail
    sub $I11, rx1762_pos, rx1762_off
    substr $S10, rx1762_tgt, $I11, 6
    ne $S10, "method", rx1762_fail
    add rx1762_pos, 6
    set_addr $I10, rxcap_1764_fail
    ($I12, $I11) = rx1762_cur."!mark_peek"($I10)
    rx1762_cur."!cursor_pos"($I11)
    ($P10) = rx1762_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1762_pos, "")
    rx1762_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1764_done
  rxcap_1764_fail:
    goto rx1762_fail
  rxcap_1764_done:
  # rx subrule "method_def" subtype=capture negate=
    rx1762_cur."!cursor_pos"(rx1762_pos)
    $P10 = rx1762_cur."method_def"()
    unless $P10, rx1762_fail
    rx1762_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("method_def")
    rx1762_pos = $P10."pos"()
  # rx pass
    rx1762_cur."!cursor_pass"(rx1762_pos, "routine_declarator:sym<method>")
    if_null rx1762_debug, debug_1273
    rx1762_cur."!cursor_debug"("PASS", "routine_declarator:sym<method>", " at pos=", rx1762_pos)
  debug_1273:
    .return (rx1762_cur)
  rx1762_restart:
.annotate 'line', 435
    if_null rx1762_debug, debug_1274
    rx1762_cur."!cursor_debug"("NEXT", "routine_declarator:sym<method>")
  debug_1274:
  rx1762_fail:
    (rx1762_rep, rx1762_pos, $I10, $P10) = rx1762_cur."!mark_fail"(0)
    lt rx1762_pos, -1, rx1762_done
    eq rx1762_pos, -1, rx1762_fail
    jump $I10
  rx1762_done:
    rx1762_cur."!cursor_fail"()
    if_null rx1762_debug, debug_1275
    rx1762_cur."!cursor_debug"("FAIL", "routine_declarator:sym<method>")
  debug_1275:
    .return (rx1762_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<method>"  :subid("208_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("method_def", "method")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_def"  :subid("209_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 849
    new $P103, "Undef"
    set $P1767, $P103
    .lex "$*RETURN_USED", $P1767
.annotate 'line', 435
    .local string rx1768_tgt
    .local int rx1768_pos
    .local int rx1768_off
    .local int rx1768_eos
    .local int rx1768_rep
    .local pmc rx1768_cur
    .local pmc rx1768_debug
    (rx1768_cur, rx1768_pos, rx1768_tgt, $I10) = self."!cursor_start"()
    rx1768_cur."!cursor_caparray"("sigil", "deflongname", "trait")
    .lex unicode:"$\x{a2}", rx1768_cur
    .local pmc match
    .lex "$/", match
    length rx1768_eos, rx1768_tgt
    gt rx1768_pos, rx1768_eos, rx1768_done
    set rx1768_off, 0
    lt rx1768_pos, 2, rx1768_start
    sub rx1768_off, rx1768_pos, 1
    substr rx1768_tgt, rx1768_tgt, rx1768_off
  rx1768_start:
    eq $I10, 1, rx1768_restart
    if_null rx1768_debug, debug_1276
    rx1768_cur."!cursor_debug"("START", "routine_def")
  debug_1276:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1769_done
    goto rxscan1769_scan
  rxscan1769_loop:
    (rx1768_pos) = rx1768_cur."from"()
    inc rx1768_pos
    rx1768_cur."!cursor_from"(rx1768_pos)
    ge rx1768_pos, rx1768_eos, rxscan1769_done
  rxscan1769_scan:
    set_addr $I10, rxscan1769_loop
    rx1768_cur."!mark_push"(0, rx1768_pos, $I10)
  rxscan1769_done:
.annotate 'line', 848
  # rx subrule "ws" subtype=method negate=
    rx1768_cur."!cursor_pos"(rx1768_pos)
    $P10 = rx1768_cur."ws"()
    unless $P10, rx1768_fail
    rx1768_pos = $P10."pos"()
.annotate 'line', 849
    rx1768_cur."!cursor_pos"(rx1768_pos)
    new $P105, "Integer"
    assign $P105, 0
    store_lex "$*RETURN_USED", $P105
  # rx subrule "ws" subtype=method negate=
    rx1768_cur."!cursor_pos"(rx1768_pos)
    $P10 = rx1768_cur."ws"()
    unless $P10, rx1768_fail
    rx1768_pos = $P10."pos"()
.annotate 'line', 850
  # rx rxquantr1770 ** 0..1
    set_addr $I10, rxquantr1770_done
    rx1768_cur."!mark_push"(0, rx1768_pos, $I10)
  rxquantr1770_loop:
  # rx subrule "ws" subtype=method negate=
    rx1768_cur."!cursor_pos"(rx1768_pos)
    $P10 = rx1768_cur."ws"()
    unless $P10, rx1768_fail
    rx1768_pos = $P10."pos"()
  # rx subcapture "sigil"
    set_addr $I10, rxcap_1772_fail
    rx1768_cur."!mark_push"(0, rx1768_pos, $I10)
  # rx rxquantr1771 ** 0..1
    set_addr $I10, rxquantr1771_done
    rx1768_cur."!mark_push"(0, rx1768_pos, $I10)
  rxquantr1771_loop:
  # rx literal  "&"
    add $I11, rx1768_pos, 1
    gt $I11, rx1768_eos, rx1768_fail
    sub $I11, rx1768_pos, rx1768_off
    ord $I11, rx1768_tgt, $I11
    ne $I11, 38, rx1768_fail
    add rx1768_pos, 1
    set_addr $I10, rxquantr1771_done
    (rx1768_rep) = rx1768_cur."!mark_commit"($I10)
  rxquantr1771_done:
    set_addr $I10, rxcap_1772_fail
    ($I12, $I11) = rx1768_cur."!mark_peek"($I10)
    rx1768_cur."!cursor_pos"($I11)
    ($P10) = rx1768_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1768_pos, "")
    rx1768_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_1772_done
  rxcap_1772_fail:
    goto rx1768_fail
  rxcap_1772_done:
  # rx subrule "deflongname" subtype=capture negate=
    rx1768_cur."!cursor_pos"(rx1768_pos)
    $P10 = rx1768_cur."deflongname"()
    unless $P10, rx1768_fail
    rx1768_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1768_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1768_cur."!cursor_pos"(rx1768_pos)
    $P10 = rx1768_cur."ws"()
    unless $P10, rx1768_fail
    rx1768_pos = $P10."pos"()
    set_addr $I10, rxquantr1770_done
    (rx1768_rep) = rx1768_cur."!mark_commit"($I10)
  rxquantr1770_done:
  # rx subrule "ws" subtype=method negate=
    rx1768_cur."!cursor_pos"(rx1768_pos)
    $P10 = rx1768_cur."ws"()
    unless $P10, rx1768_fail
    rx1768_pos = $P10."pos"()
.annotate 'line', 851
  # rx subrule "newpad" subtype=method negate=
    rx1768_cur."!cursor_pos"(rx1768_pos)
    $P10 = rx1768_cur."newpad"()
    unless $P10, rx1768_fail
    rx1768_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1768_cur."!cursor_pos"(rx1768_pos)
    $P10 = rx1768_cur."ws"()
    unless $P10, rx1768_fail
    rx1768_pos = $P10."pos"()
  alt1773_0:
.annotate 'line', 852
    set_addr $I10, alt1773_1
    rx1768_cur."!mark_push"(0, rx1768_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx1768_cur."!cursor_pos"(rx1768_pos)
    $P10 = rx1768_cur."ws"()
    unless $P10, rx1768_fail
    rx1768_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1768_pos, 1
    gt $I11, rx1768_eos, rx1768_fail
    sub $I11, rx1768_pos, rx1768_off
    ord $I11, rx1768_tgt, $I11
    ne $I11, 40, rx1768_fail
    add rx1768_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1768_cur."!cursor_pos"(rx1768_pos)
    $P10 = rx1768_cur."ws"()
    unless $P10, rx1768_fail
    rx1768_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx1768_cur."!cursor_pos"(rx1768_pos)
    $P10 = rx1768_cur."signature"()
    unless $P10, rx1768_fail
    rx1768_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx1768_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1768_cur."!cursor_pos"(rx1768_pos)
    $P10 = rx1768_cur."ws"()
    unless $P10, rx1768_fail
    rx1768_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1768_pos, 1
    gt $I11, rx1768_eos, rx1768_fail
    sub $I11, rx1768_pos, rx1768_off
    ord $I11, rx1768_tgt, $I11
    ne $I11, 41, rx1768_fail
    add rx1768_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1768_cur."!cursor_pos"(rx1768_pos)
    $P10 = rx1768_cur."ws"()
    unless $P10, rx1768_fail
    rx1768_pos = $P10."pos"()
    goto alt1773_end
  alt1773_1:
.annotate 'line', 853
  # rx subrule "ws" subtype=method negate=
    rx1768_cur."!cursor_pos"(rx1768_pos)
    $P10 = rx1768_cur."ws"()
    unless $P10, rx1768_fail
    rx1768_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1768_cur."!cursor_pos"(rx1768_pos)
    $P10 = rx1768_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx1768_fail
    rx1768_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1768_cur."!cursor_pos"(rx1768_pos)
    $P10 = rx1768_cur."ws"()
    unless $P10, rx1768_fail
    rx1768_pos = $P10."pos"()
  alt1773_end:
  # rx subrule "ws" subtype=method negate=
    rx1768_cur."!cursor_pos"(rx1768_pos)
    $P10 = rx1768_cur."ws"()
    unless $P10, rx1768_fail
    rx1768_pos = $P10."pos"()
.annotate 'line', 854
  # rx rxquantr1774 ** 0..*
    set_addr $I10, rxquantr1774_done
    rx1768_cur."!mark_push"(0, rx1768_pos, $I10)
  rxquantr1774_loop:
  # rx subrule "trait" subtype=capture negate=
    rx1768_cur."!cursor_pos"(rx1768_pos)
    $P10 = rx1768_cur."trait"()
    unless $P10, rx1768_fail
    goto rxsubrule1775_pass
  rxsubrule1775_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1768_fail
  rxsubrule1775_pass:
    set_addr $I10, rxsubrule1775_back
    rx1768_cur."!mark_push"(0, rx1768_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx1768_pos = $P10."pos"()
    set_addr $I10, rxquantr1774_done
    (rx1768_rep) = rx1768_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1774_done
    rx1768_cur."!mark_push"(rx1768_rep, rx1768_pos, $I10)
    goto rxquantr1774_loop
  rxquantr1774_done:
  # rx subrule "ws" subtype=method negate=
    rx1768_cur."!cursor_pos"(rx1768_pos)
    $P10 = rx1768_cur."ws"()
    unless $P10, rx1768_fail
    rx1768_pos = $P10."pos"()
  alt1776_0:
.annotate 'line', 855
    set_addr $I10, alt1776_1
    rx1768_cur."!mark_push"(0, rx1768_pos, $I10)
.annotate 'line', 856
  # rx subrule "ws" subtype=method negate=
    rx1768_cur."!cursor_pos"(rx1768_pos)
    $P10 = rx1768_cur."ws"()
    unless $P10, rx1768_fail
    rx1768_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx1768_cur."!cursor_pos"(rx1768_pos)
    $P10 = rx1768_cur."onlystar"()
    unless $P10, rx1768_fail
    rx1768_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx1768_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1768_cur."!cursor_pos"(rx1768_pos)
    $P10 = rx1768_cur."ws"()
    unless $P10, rx1768_fail
    rx1768_pos = $P10."pos"()
    goto alt1776_end
  alt1776_1:
.annotate 'line', 857
  # rx subrule "ws" subtype=method negate=
    rx1768_cur."!cursor_pos"(rx1768_pos)
    $P10 = rx1768_cur."ws"()
    unless $P10, rx1768_fail
    rx1768_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx1768_cur."!cursor_pos"(rx1768_pos)
    $P10 = rx1768_cur."blockoid"()
    unless $P10, rx1768_fail
    rx1768_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx1768_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1768_cur."!cursor_pos"(rx1768_pos)
    $P10 = rx1768_cur."ws"()
    unless $P10, rx1768_fail
    rx1768_pos = $P10."pos"()
  alt1776_end:
.annotate 'line', 858
  # rx subrule "ws" subtype=method negate=
    rx1768_cur."!cursor_pos"(rx1768_pos)
    $P10 = rx1768_cur."ws"()
    unless $P10, rx1768_fail
    rx1768_pos = $P10."pos"()
.annotate 'line', 848
  # rx pass
    rx1768_cur."!cursor_pass"(rx1768_pos, "routine_def")
    if_null rx1768_debug, debug_1277
    rx1768_cur."!cursor_debug"("PASS", "routine_def", " at pos=", rx1768_pos)
  debug_1277:
    .return (rx1768_cur)
  rx1768_restart:
.annotate 'line', 435
    if_null rx1768_debug, debug_1278
    rx1768_cur."!cursor_debug"("NEXT", "routine_def")
  debug_1278:
  rx1768_fail:
    (rx1768_rep, rx1768_pos, $I10, $P10) = rx1768_cur."!mark_fail"(0)
    lt rx1768_pos, -1, rx1768_done
    eq rx1768_pos, -1, rx1768_fail
    jump $I10
  rx1768_done:
    rx1768_cur."!cursor_fail"()
    if_null rx1768_debug, debug_1279
    rx1768_cur."!cursor_debug"("FAIL", "routine_def")
  debug_1279:
    .return (rx1768_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_def"  :subid("210_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P124 = self."!PREFIX__!subrule"("ws", "")
    new $P125, "ResizablePMCArray"
    push $P125, $P124
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "method_def"  :subid("211_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .const 'Sub' $P1789 = "212_1310110678.31883" 
    capture_lex $P1789
.annotate 'line', 862
    new $P103, "Undef"
    set $P1779, $P103
    .lex "$*RETURN_USED", $P1779
.annotate 'line', 863
    new $P104, "Undef"
    set $P1780, $P104
    .lex "$*INVOCANT_OK", $P1780
.annotate 'line', 435
    .local string rx1781_tgt
    .local int rx1781_pos
    .local int rx1781_off
    .local int rx1781_eos
    .local int rx1781_rep
    .local pmc rx1781_cur
    .local pmc rx1781_debug
    (rx1781_cur, rx1781_pos, rx1781_tgt, $I10) = self."!cursor_start"()
    rx1781_cur."!cursor_caparray"("deflongname", "trait")
    .lex unicode:"$\x{a2}", rx1781_cur
    .local pmc match
    .lex "$/", match
    length rx1781_eos, rx1781_tgt
    gt rx1781_pos, rx1781_eos, rx1781_done
    set rx1781_off, 0
    lt rx1781_pos, 2, rx1781_start
    sub rx1781_off, rx1781_pos, 1
    substr rx1781_tgt, rx1781_tgt, rx1781_off
  rx1781_start:
    eq $I10, 1, rx1781_restart
    if_null rx1781_debug, debug_1280
    rx1781_cur."!cursor_debug"("START", "method_def")
  debug_1280:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1782_done
    goto rxscan1782_scan
  rxscan1782_loop:
    (rx1781_pos) = rx1781_cur."from"()
    inc rx1781_pos
    rx1781_cur."!cursor_from"(rx1781_pos)
    ge rx1781_pos, rx1781_eos, rxscan1782_done
  rxscan1782_scan:
    set_addr $I10, rxscan1782_loop
    rx1781_cur."!mark_push"(0, rx1781_pos, $I10)
  rxscan1782_done:
.annotate 'line', 861
  # rx subrule "ws" subtype=method negate=
    rx1781_cur."!cursor_pos"(rx1781_pos)
    $P10 = rx1781_cur."ws"()
    unless $P10, rx1781_fail
    rx1781_pos = $P10."pos"()
.annotate 'line', 862
    rx1781_cur."!cursor_pos"(rx1781_pos)
    new $P106, "Integer"
    assign $P106, 0
    store_lex "$*RETURN_USED", $P106
  # rx subrule "ws" subtype=method negate=
    rx1781_cur."!cursor_pos"(rx1781_pos)
    $P10 = rx1781_cur."ws"()
    unless $P10, rx1781_fail
    rx1781_pos = $P10."pos"()
.annotate 'line', 863
    rx1781_cur."!cursor_pos"(rx1781_pos)
    new $P108, "Integer"
    assign $P108, 1
    store_lex "$*INVOCANT_OK", $P108
  # rx subrule "ws" subtype=method negate=
    rx1781_cur."!cursor_pos"(rx1781_pos)
    $P10 = rx1781_cur."ws"()
    unless $P10, rx1781_fail
    rx1781_pos = $P10."pos"()
.annotate 'line', 864
  # rx subcapture "private"
    set_addr $I10, rxcap_1784_fail
    rx1781_cur."!mark_push"(0, rx1781_pos, $I10)
  # rx rxquantr1783 ** 0..1
    set_addr $I10, rxquantr1783_done
    rx1781_cur."!mark_push"(0, rx1781_pos, $I10)
  rxquantr1783_loop:
  # rx literal  "!"
    add $I11, rx1781_pos, 1
    gt $I11, rx1781_eos, rx1781_fail
    sub $I11, rx1781_pos, rx1781_off
    ord $I11, rx1781_tgt, $I11
    ne $I11, 33, rx1781_fail
    add rx1781_pos, 1
    set_addr $I10, rxquantr1783_done
    (rx1781_rep) = rx1781_cur."!mark_commit"($I10)
  rxquantr1783_done:
    set_addr $I10, rxcap_1784_fail
    ($I12, $I11) = rx1781_cur."!mark_peek"($I10)
    rx1781_cur."!cursor_pos"($I11)
    ($P10) = rx1781_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1781_pos, "")
    rx1781_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("private")
    goto rxcap_1784_done
  rxcap_1784_fail:
    goto rx1781_fail
  rxcap_1784_done:
  # rx subrule "ws" subtype=method negate=
    rx1781_cur."!cursor_pos"(rx1781_pos)
    $P10 = rx1781_cur."ws"()
    unless $P10, rx1781_fail
    rx1781_pos = $P10."pos"()
.annotate 'line', 865
  # rx rxquantr1785 ** 0..1
    set_addr $I10, rxquantr1785_done
    rx1781_cur."!mark_push"(0, rx1781_pos, $I10)
  rxquantr1785_loop:
  # rx subrule "deflongname" subtype=capture negate=
    rx1781_cur."!cursor_pos"(rx1781_pos)
    $P10 = rx1781_cur."deflongname"()
    unless $P10, rx1781_fail
    goto rxsubrule1786_pass
  rxsubrule1786_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1781_fail
  rxsubrule1786_pass:
    set_addr $I10, rxsubrule1786_back
    rx1781_cur."!mark_push"(0, rx1781_pos, $I10, $P10)
    $P10."!cursor_names"("deflongname")
    rx1781_pos = $P10."pos"()
    set_addr $I10, rxquantr1785_done
    (rx1781_rep) = rx1781_cur."!mark_commit"($I10)
  rxquantr1785_done:
  # rx subrule "ws" subtype=method negate=
    rx1781_cur."!cursor_pos"(rx1781_pos)
    $P10 = rx1781_cur."ws"()
    unless $P10, rx1781_fail
    rx1781_pos = $P10."pos"()
.annotate 'line', 866
  # rx subrule "newpad" subtype=method negate=
    rx1781_cur."!cursor_pos"(rx1781_pos)
    $P10 = rx1781_cur."newpad"()
    unless $P10, rx1781_fail
    rx1781_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1781_cur."!cursor_pos"(rx1781_pos)
    $P10 = rx1781_cur."ws"()
    unless $P10, rx1781_fail
    rx1781_pos = $P10."pos"()
  alt1787_0:
.annotate 'line', 867
    set_addr $I10, alt1787_1
    rx1781_cur."!mark_push"(0, rx1781_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx1781_cur."!cursor_pos"(rx1781_pos)
    $P10 = rx1781_cur."ws"()
    unless $P10, rx1781_fail
    rx1781_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1781_pos, 1
    gt $I11, rx1781_eos, rx1781_fail
    sub $I11, rx1781_pos, rx1781_off
    ord $I11, rx1781_tgt, $I11
    ne $I11, 40, rx1781_fail
    add rx1781_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1781_cur."!cursor_pos"(rx1781_pos)
    $P10 = rx1781_cur."ws"()
    unless $P10, rx1781_fail
    rx1781_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx1781_cur."!cursor_pos"(rx1781_pos)
    $P10 = rx1781_cur."signature"()
    unless $P10, rx1781_fail
    rx1781_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx1781_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1781_cur."!cursor_pos"(rx1781_pos)
    $P10 = rx1781_cur."ws"()
    unless $P10, rx1781_fail
    rx1781_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1781_pos, 1
    gt $I11, rx1781_eos, rx1781_fail
    sub $I11, rx1781_pos, rx1781_off
    ord $I11, rx1781_tgt, $I11
    ne $I11, 41, rx1781_fail
    add rx1781_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1781_cur."!cursor_pos"(rx1781_pos)
    $P10 = rx1781_cur."ws"()
    unless $P10, rx1781_fail
    rx1781_pos = $P10."pos"()
    goto alt1787_end
  alt1787_1:
.annotate 'line', 868
  # rx subrule "ws" subtype=method negate=
    rx1781_cur."!cursor_pos"(rx1781_pos)
    $P10 = rx1781_cur."ws"()
    unless $P10, rx1781_fail
    rx1781_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1781_cur."!cursor_pos"(rx1781_pos)
    $P10 = rx1781_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx1781_fail
    rx1781_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1781_cur."!cursor_pos"(rx1781_pos)
    $P10 = rx1781_cur."ws"()
    unless $P10, rx1781_fail
    rx1781_pos = $P10."pos"()
  alt1787_end:
  # rx subrule "ws" subtype=method negate=
    rx1781_cur."!cursor_pos"(rx1781_pos)
    $P10 = rx1781_cur."ws"()
    unless $P10, rx1781_fail
    rx1781_pos = $P10."pos"()
.annotate 'line', 869
    rx1781_cur."!cursor_pos"(rx1781_pos)
    find_lex $P120, unicode:"$\x{a2}"
    $P121 = $P120."MATCH"()
    store_lex "$/", $P121
    .const 'Sub' $P1789 = "212_1310110678.31883" 
    capture_lex $P1789
    $P123 = $P1789()
  # rx subrule "ws" subtype=method negate=
    rx1781_cur."!cursor_pos"(rx1781_pos)
    $P10 = rx1781_cur."ws"()
    unless $P10, rx1781_fail
    rx1781_pos = $P10."pos"()
.annotate 'line', 870
  # rx rxquantr1790 ** 0..*
    set_addr $I10, rxquantr1790_done
    rx1781_cur."!mark_push"(0, rx1781_pos, $I10)
  rxquantr1790_loop:
  # rx subrule "trait" subtype=capture negate=
    rx1781_cur."!cursor_pos"(rx1781_pos)
    $P10 = rx1781_cur."trait"()
    unless $P10, rx1781_fail
    goto rxsubrule1791_pass
  rxsubrule1791_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1781_fail
  rxsubrule1791_pass:
    set_addr $I10, rxsubrule1791_back
    rx1781_cur."!mark_push"(0, rx1781_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx1781_pos = $P10."pos"()
    set_addr $I10, rxquantr1790_done
    (rx1781_rep) = rx1781_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1790_done
    rx1781_cur."!mark_push"(rx1781_rep, rx1781_pos, $I10)
    goto rxquantr1790_loop
  rxquantr1790_done:
  # rx subrule "ws" subtype=method negate=
    rx1781_cur."!cursor_pos"(rx1781_pos)
    $P10 = rx1781_cur."ws"()
    unless $P10, rx1781_fail
    rx1781_pos = $P10."pos"()
  alt1792_0:
.annotate 'line', 871
    set_addr $I10, alt1792_1
    rx1781_cur."!mark_push"(0, rx1781_pos, $I10)
.annotate 'line', 872
  # rx subrule "ws" subtype=method negate=
    rx1781_cur."!cursor_pos"(rx1781_pos)
    $P10 = rx1781_cur."ws"()
    unless $P10, rx1781_fail
    rx1781_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx1781_cur."!cursor_pos"(rx1781_pos)
    $P10 = rx1781_cur."onlystar"()
    unless $P10, rx1781_fail
    rx1781_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx1781_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1781_cur."!cursor_pos"(rx1781_pos)
    $P10 = rx1781_cur."ws"()
    unless $P10, rx1781_fail
    rx1781_pos = $P10."pos"()
    goto alt1792_end
  alt1792_1:
.annotate 'line', 873
  # rx subrule "ws" subtype=method negate=
    rx1781_cur."!cursor_pos"(rx1781_pos)
    $P10 = rx1781_cur."ws"()
    unless $P10, rx1781_fail
    rx1781_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx1781_cur."!cursor_pos"(rx1781_pos)
    $P10 = rx1781_cur."blockoid"()
    unless $P10, rx1781_fail
    rx1781_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx1781_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1781_cur."!cursor_pos"(rx1781_pos)
    $P10 = rx1781_cur."ws"()
    unless $P10, rx1781_fail
    rx1781_pos = $P10."pos"()
  alt1792_end:
.annotate 'line', 874
  # rx subrule "ws" subtype=method negate=
    rx1781_cur."!cursor_pos"(rx1781_pos)
    $P10 = rx1781_cur."ws"()
    unless $P10, rx1781_fail
    rx1781_pos = $P10."pos"()
.annotate 'line', 861
  # rx pass
    rx1781_cur."!cursor_pass"(rx1781_pos, "method_def")
    if_null rx1781_debug, debug_1281
    rx1781_cur."!cursor_debug"("PASS", "method_def", " at pos=", rx1781_pos)
  debug_1281:
    .return (rx1781_cur)
  rx1781_restart:
.annotate 'line', 435
    if_null rx1781_debug, debug_1282
    rx1781_cur."!cursor_debug"("NEXT", "method_def")
  debug_1282:
  rx1781_fail:
    (rx1781_rep, rx1781_pos, $I10, $P10) = rx1781_cur."!mark_fail"(0)
    lt rx1781_pos, -1, rx1781_done
    eq rx1781_pos, -1, rx1781_fail
    jump $I10
  rx1781_done:
    rx1781_cur."!cursor_fail"()
    if_null rx1781_debug, debug_1283
    rx1781_cur."!cursor_debug"("FAIL", "method_def")
  debug_1283:
    .return (rx1781_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1788"  :anon :subid("212_1310110678.31883") :outer("211_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 869
    new $P122, "Integer"
    assign $P122, 0
    store_dynamic_lex "$*INVOCANT_OK", $P122
    .return ($P122)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__method_def"  :subid("213_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P131 = self."!PREFIX__!subrule"("ws", "")
    new $P132, "ResizablePMCArray"
    push $P132, $P131
    .return ($P132)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "onlystar"  :subid("214_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .const 'Sub' $P1798 = "215_1310110678.31883" 
    capture_lex $P1798
    .local string rx1795_tgt
    .local int rx1795_pos
    .local int rx1795_off
    .local int rx1795_eos
    .local int rx1795_rep
    .local pmc rx1795_cur
    .local pmc rx1795_debug
    (rx1795_cur, rx1795_pos, rx1795_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1795_cur
    .local pmc match
    .lex "$/", match
    length rx1795_eos, rx1795_tgt
    gt rx1795_pos, rx1795_eos, rx1795_done
    set rx1795_off, 0
    lt rx1795_pos, 2, rx1795_start
    sub rx1795_off, rx1795_pos, 1
    substr rx1795_tgt, rx1795_tgt, rx1795_off
  rx1795_start:
    eq $I10, 1, rx1795_restart
    if_null rx1795_debug, debug_1284
    rx1795_cur."!cursor_debug"("START", "onlystar")
  debug_1284:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1796_done
    goto rxscan1796_scan
  rxscan1796_loop:
    (rx1795_pos) = rx1795_cur."from"()
    inc rx1795_pos
    rx1795_cur."!cursor_from"(rx1795_pos)
    ge rx1795_pos, rx1795_eos, rxscan1796_done
  rxscan1796_scan:
    set_addr $I10, rxscan1796_loop
    rx1795_cur."!mark_push"(0, rx1795_pos, $I10)
  rxscan1796_done:
.annotate 'line', 878
    rx1795_cur."!cursor_pos"(rx1795_pos)
    find_lex $P103, unicode:"$\x{a2}"
    $P104 = $P103."MATCH"()
    store_lex "$/", $P104
    .const 'Sub' $P1798 = "215_1310110678.31883" 
    capture_lex $P1798
    $P105 = $P1798()
    unless $P105, rx1795_fail
.annotate 'line', 879
  # rx literal  "{"
    add $I11, rx1795_pos, 1
    gt $I11, rx1795_eos, rx1795_fail
    sub $I11, rx1795_pos, rx1795_off
    ord $I11, rx1795_tgt, $I11
    ne $I11, 123, rx1795_fail
    add rx1795_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1795_cur."!cursor_pos"(rx1795_pos)
    $P10 = rx1795_cur."ws"()
    unless $P10, rx1795_fail
    rx1795_pos = $P10."pos"()
  # rx literal  "*"
    add $I11, rx1795_pos, 1
    gt $I11, rx1795_eos, rx1795_fail
    sub $I11, rx1795_pos, rx1795_off
    ord $I11, rx1795_tgt, $I11
    ne $I11, 42, rx1795_fail
    add rx1795_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1795_cur."!cursor_pos"(rx1795_pos)
    $P10 = rx1795_cur."ws"()
    unless $P10, rx1795_fail
    rx1795_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1795_pos, 1
    gt $I11, rx1795_eos, rx1795_fail
    sub $I11, rx1795_pos, rx1795_off
    ord $I11, rx1795_tgt, $I11
    ne $I11, 125, rx1795_fail
    add rx1795_pos, 1
.annotate 'line', 880
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1795_cur."!cursor_pos"(rx1795_pos)
    $P10 = rx1795_cur."ENDSTMT"()
    unless $P10, rx1795_fail
.annotate 'line', 881
  # rx subrule "finishpad" subtype=method negate=
    rx1795_cur."!cursor_pos"(rx1795_pos)
    $P10 = rx1795_cur."finishpad"()
    unless $P10, rx1795_fail
    rx1795_pos = $P10."pos"()
.annotate 'line', 877
  # rx pass
    rx1795_cur."!cursor_pass"(rx1795_pos, "onlystar")
    if_null rx1795_debug, debug_1287
    rx1795_cur."!cursor_debug"("PASS", "onlystar", " at pos=", rx1795_pos)
  debug_1287:
    .return (rx1795_cur)
  rx1795_restart:
.annotate 'line', 435
    if_null rx1795_debug, debug_1288
    rx1795_cur."!cursor_debug"("NEXT", "onlystar")
  debug_1288:
  rx1795_fail:
    (rx1795_rep, rx1795_pos, $I10, $P10) = rx1795_cur."!mark_fail"(0)
    lt rx1795_pos, -1, rx1795_done
    eq rx1795_pos, -1, rx1795_fail
    jump $I10
  rx1795_done:
    rx1795_cur."!cursor_fail"()
    if_null rx1795_debug, debug_1289
    rx1795_cur."!cursor_debug"("FAIL", "onlystar")
  debug_1289:
    .return (rx1795_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1797"  :anon :subid("215_1310110678.31883") :outer("214_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 878
    find_dynamic_lex $P107, "$*MULTINESS"
    unless_null $P107, vivify_1285
    get_hll_global $P105, "GLOBAL"
    get_who $P106, $P105
    set $P107, $P106["$MULTINESS"]
    unless_null $P107, vivify_1286
    die "Contextual $*MULTINESS not found"
  vivify_1286:
  vivify_1285:
    set $S100, $P107
    iseq $I100, $S100, "proto"
    .return ($I100)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__onlystar"  :subid("216_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    new $P106, "ResizablePMCArray"
    push $P106, ""
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator"  :subid("217_1310110678.31883")
    .param pmc param_1801
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 884
    .lex "self", param_1801
    $P103 = param_1801."!protoregex"("multi_declarator")
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator"  :subid("218_1310110678.31883")
    .param pmc param_1803
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 884
    .lex "self", param_1803
    $P104 = param_1803."!PREFIX__!protoregex"("multi_declarator")
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<multi>"  :subid("219_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 886
    new $P103, "Undef"
    set $P1805, $P103
    .lex "$*MULTINESS", $P1805
.annotate 'line', 435
    .local string rx1806_tgt
    .local int rx1806_pos
    .local int rx1806_off
    .local int rx1806_eos
    .local int rx1806_rep
    .local pmc rx1806_cur
    .local pmc rx1806_debug
    (rx1806_cur, rx1806_pos, rx1806_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1806_cur
    .local pmc match
    .lex "$/", match
    length rx1806_eos, rx1806_tgt
    gt rx1806_pos, rx1806_eos, rx1806_done
    set rx1806_off, 0
    lt rx1806_pos, 2, rx1806_start
    sub rx1806_off, rx1806_pos, 1
    substr rx1806_tgt, rx1806_tgt, rx1806_off
  rx1806_start:
    eq $I10, 1, rx1806_restart
    if_null rx1806_debug, debug_1290
    rx1806_cur."!cursor_debug"("START", "multi_declarator:sym<multi>")
  debug_1290:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1807_done
    goto rxscan1807_scan
  rxscan1807_loop:
    (rx1806_pos) = rx1806_cur."from"()
    inc rx1806_pos
    rx1806_cur."!cursor_from"(rx1806_pos)
    ge rx1806_pos, rx1806_eos, rxscan1807_done
  rxscan1807_scan:
    set_addr $I10, rxscan1807_loop
    rx1806_cur."!mark_push"(0, rx1806_pos, $I10)
  rxscan1807_done:
.annotate 'line', 886
    rx1806_cur."!cursor_pos"(rx1806_pos)
    new $P104, "String"
    assign $P104, "multi"
    store_lex "$*MULTINESS", $P104
.annotate 'line', 887
  # rx subcapture "sym"
    set_addr $I10, rxcap_1808_fail
    rx1806_cur."!mark_push"(0, rx1806_pos, $I10)
  # rx literal  "multi"
    add $I11, rx1806_pos, 5
    gt $I11, rx1806_eos, rx1806_fail
    sub $I11, rx1806_pos, rx1806_off
    substr $S10, rx1806_tgt, $I11, 5
    ne $S10, "multi", rx1806_fail
    add rx1806_pos, 5
    set_addr $I10, rxcap_1808_fail
    ($I12, $I11) = rx1806_cur."!mark_peek"($I10)
    rx1806_cur."!cursor_pos"($I11)
    ($P10) = rx1806_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1806_pos, "")
    rx1806_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1808_done
  rxcap_1808_fail:
    goto rx1806_fail
  rxcap_1808_done:
.annotate 'line', 888
  # rx subrule "ws" subtype=method negate=
    rx1806_cur."!cursor_pos"(rx1806_pos)
    $P10 = rx1806_cur."ws"()
    unless $P10, rx1806_fail
    rx1806_pos = $P10."pos"()
  alt1809_0:
    set_addr $I10, alt1809_1
    rx1806_cur."!mark_push"(0, rx1806_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx1806_cur."!cursor_pos"(rx1806_pos)
    $P10 = rx1806_cur."declarator"()
    unless $P10, rx1806_fail
    rx1806_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1806_pos = $P10."pos"()
    goto alt1809_end
  alt1809_1:
    set_addr $I10, alt1809_2
    rx1806_cur."!mark_push"(0, rx1806_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx1806_cur."!cursor_pos"(rx1806_pos)
    $P10 = rx1806_cur."routine_def"()
    unless $P10, rx1806_fail
    rx1806_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx1806_pos = $P10."pos"()
    goto alt1809_end
  alt1809_2:
  # rx subrule "panic" subtype=method negate=
    rx1806_cur."!cursor_pos"(rx1806_pos)
    $P10 = rx1806_cur."panic"("Malformed multi")
    unless $P10, rx1806_fail
    rx1806_pos = $P10."pos"()
  alt1809_end:
.annotate 'line', 885
  # rx pass
    rx1806_cur."!cursor_pass"(rx1806_pos, "multi_declarator:sym<multi>")
    if_null rx1806_debug, debug_1291
    rx1806_cur."!cursor_debug"("PASS", "multi_declarator:sym<multi>", " at pos=", rx1806_pos)
  debug_1291:
    .return (rx1806_cur)
  rx1806_restart:
.annotate 'line', 435
    if_null rx1806_debug, debug_1292
    rx1806_cur."!cursor_debug"("NEXT", "multi_declarator:sym<multi>")
  debug_1292:
  rx1806_fail:
    (rx1806_rep, rx1806_pos, $I10, $P10) = rx1806_cur."!mark_fail"(0)
    lt rx1806_pos, -1, rx1806_done
    eq rx1806_pos, -1, rx1806_fail
    jump $I10
  rx1806_done:
    rx1806_cur."!cursor_fail"()
    if_null rx1806_debug, debug_1293
    rx1806_cur."!cursor_debug"("FAIL", "multi_declarator:sym<multi>")
  debug_1293:
    .return (rx1806_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<multi>"  :subid("220_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P105 = self."!PREFIX__!subrule"("ws", "multi")
    new $P106, "ResizablePMCArray"
    push $P106, $P105
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<proto>"  :subid("221_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 891
    new $P103, "Undef"
    set $P1812, $P103
    .lex "$*MULTINESS", $P1812
.annotate 'line', 435
    .local string rx1813_tgt
    .local int rx1813_pos
    .local int rx1813_off
    .local int rx1813_eos
    .local int rx1813_rep
    .local pmc rx1813_cur
    .local pmc rx1813_debug
    (rx1813_cur, rx1813_pos, rx1813_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1813_cur
    .local pmc match
    .lex "$/", match
    length rx1813_eos, rx1813_tgt
    gt rx1813_pos, rx1813_eos, rx1813_done
    set rx1813_off, 0
    lt rx1813_pos, 2, rx1813_start
    sub rx1813_off, rx1813_pos, 1
    substr rx1813_tgt, rx1813_tgt, rx1813_off
  rx1813_start:
    eq $I10, 1, rx1813_restart
    if_null rx1813_debug, debug_1294
    rx1813_cur."!cursor_debug"("START", "multi_declarator:sym<proto>")
  debug_1294:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1814_done
    goto rxscan1814_scan
  rxscan1814_loop:
    (rx1813_pos) = rx1813_cur."from"()
    inc rx1813_pos
    rx1813_cur."!cursor_from"(rx1813_pos)
    ge rx1813_pos, rx1813_eos, rxscan1814_done
  rxscan1814_scan:
    set_addr $I10, rxscan1814_loop
    rx1813_cur."!mark_push"(0, rx1813_pos, $I10)
  rxscan1814_done:
.annotate 'line', 891
    rx1813_cur."!cursor_pos"(rx1813_pos)
    new $P104, "String"
    assign $P104, "proto"
    store_lex "$*MULTINESS", $P104
.annotate 'line', 892
  # rx subcapture "sym"
    set_addr $I10, rxcap_1815_fail
    rx1813_cur."!mark_push"(0, rx1813_pos, $I10)
  # rx literal  "proto"
    add $I11, rx1813_pos, 5
    gt $I11, rx1813_eos, rx1813_fail
    sub $I11, rx1813_pos, rx1813_off
    substr $S10, rx1813_tgt, $I11, 5
    ne $S10, "proto", rx1813_fail
    add rx1813_pos, 5
    set_addr $I10, rxcap_1815_fail
    ($I12, $I11) = rx1813_cur."!mark_peek"($I10)
    rx1813_cur."!cursor_pos"($I11)
    ($P10) = rx1813_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1813_pos, "")
    rx1813_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1815_done
  rxcap_1815_fail:
    goto rx1813_fail
  rxcap_1815_done:
.annotate 'line', 893
  # rx subrule "ws" subtype=method negate=
    rx1813_cur."!cursor_pos"(rx1813_pos)
    $P10 = rx1813_cur."ws"()
    unless $P10, rx1813_fail
    rx1813_pos = $P10."pos"()
  alt1816_0:
    set_addr $I10, alt1816_1
    rx1813_cur."!mark_push"(0, rx1813_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx1813_cur."!cursor_pos"(rx1813_pos)
    $P10 = rx1813_cur."declarator"()
    unless $P10, rx1813_fail
    rx1813_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1813_pos = $P10."pos"()
    goto alt1816_end
  alt1816_1:
    set_addr $I10, alt1816_2
    rx1813_cur."!mark_push"(0, rx1813_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx1813_cur."!cursor_pos"(rx1813_pos)
    $P10 = rx1813_cur."routine_def"()
    unless $P10, rx1813_fail
    rx1813_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx1813_pos = $P10."pos"()
    goto alt1816_end
  alt1816_2:
  # rx subrule "panic" subtype=method negate=
    rx1813_cur."!cursor_pos"(rx1813_pos)
    $P10 = rx1813_cur."panic"("Malformed proto")
    unless $P10, rx1813_fail
    rx1813_pos = $P10."pos"()
  alt1816_end:
.annotate 'line', 890
  # rx pass
    rx1813_cur."!cursor_pass"(rx1813_pos, "multi_declarator:sym<proto>")
    if_null rx1813_debug, debug_1295
    rx1813_cur."!cursor_debug"("PASS", "multi_declarator:sym<proto>", " at pos=", rx1813_pos)
  debug_1295:
    .return (rx1813_cur)
  rx1813_restart:
.annotate 'line', 435
    if_null rx1813_debug, debug_1296
    rx1813_cur."!cursor_debug"("NEXT", "multi_declarator:sym<proto>")
  debug_1296:
  rx1813_fail:
    (rx1813_rep, rx1813_pos, $I10, $P10) = rx1813_cur."!mark_fail"(0)
    lt rx1813_pos, -1, rx1813_done
    eq rx1813_pos, -1, rx1813_fail
    jump $I10
  rx1813_done:
    rx1813_cur."!cursor_fail"()
    if_null rx1813_debug, debug_1297
    rx1813_cur."!cursor_debug"("FAIL", "multi_declarator:sym<proto>")
  debug_1297:
    .return (rx1813_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<proto>"  :subid("222_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P105 = self."!PREFIX__!subrule"("ws", "proto")
    new $P106, "ResizablePMCArray"
    push $P106, $P105
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<null>"  :subid("223_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 896
    new $P103, "Undef"
    set $P1819, $P103
    .lex "$*MULTINESS", $P1819
.annotate 'line', 435
    .local string rx1820_tgt
    .local int rx1820_pos
    .local int rx1820_off
    .local int rx1820_eos
    .local int rx1820_rep
    .local pmc rx1820_cur
    .local pmc rx1820_debug
    (rx1820_cur, rx1820_pos, rx1820_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1820_cur
    .local pmc match
    .lex "$/", match
    length rx1820_eos, rx1820_tgt
    gt rx1820_pos, rx1820_eos, rx1820_done
    set rx1820_off, 0
    lt rx1820_pos, 2, rx1820_start
    sub rx1820_off, rx1820_pos, 1
    substr rx1820_tgt, rx1820_tgt, rx1820_off
  rx1820_start:
    eq $I10, 1, rx1820_restart
    if_null rx1820_debug, debug_1298
    rx1820_cur."!cursor_debug"("START", "multi_declarator:sym<null>")
  debug_1298:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1821_done
    goto rxscan1821_scan
  rxscan1821_loop:
    (rx1820_pos) = rx1820_cur."from"()
    inc rx1820_pos
    rx1820_cur."!cursor_from"(rx1820_pos)
    ge rx1820_pos, rx1820_eos, rxscan1821_done
  rxscan1821_scan:
    set_addr $I10, rxscan1821_loop
    rx1820_cur."!mark_push"(0, rx1820_pos, $I10)
  rxscan1821_done:
.annotate 'line', 896
    rx1820_cur."!cursor_pos"(rx1820_pos)
    new $P104, "String"
    assign $P104, ""
    store_lex "$*MULTINESS", $P104
.annotate 'line', 897
  # rx subrule "declarator" subtype=capture negate=
    rx1820_cur."!cursor_pos"(rx1820_pos)
    $P10 = rx1820_cur."declarator"()
    unless $P10, rx1820_fail
    rx1820_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1820_pos = $P10."pos"()
.annotate 'line', 895
  # rx pass
    rx1820_cur."!cursor_pass"(rx1820_pos, "multi_declarator:sym<null>")
    if_null rx1820_debug, debug_1299
    rx1820_cur."!cursor_debug"("PASS", "multi_declarator:sym<null>", " at pos=", rx1820_pos)
  debug_1299:
    .return (rx1820_cur)
  rx1820_restart:
.annotate 'line', 435
    if_null rx1820_debug, debug_1300
    rx1820_cur."!cursor_debug"("NEXT", "multi_declarator:sym<null>")
  debug_1300:
  rx1820_fail:
    (rx1820_rep, rx1820_pos, $I10, $P10) = rx1820_cur."!mark_fail"(0)
    lt rx1820_pos, -1, rx1820_done
    eq rx1820_pos, -1, rx1820_fail
    jump $I10
  rx1820_done:
    rx1820_cur."!cursor_fail"()
    if_null rx1820_debug, debug_1301
    rx1820_cur."!cursor_debug"("FAIL", "multi_declarator:sym<null>")
  debug_1301:
    .return (rx1820_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<null>"  :subid("224_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P105 = self."!PREFIX__!subrule"("declarator", "")
    new $P106, "ResizablePMCArray"
    push $P106, $P105
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "signature"  :subid("225_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .const 'Sub' $P1828 = "226_1310110678.31883" 
    capture_lex $P1828
    .local string rx1824_tgt
    .local int rx1824_pos
    .local int rx1824_off
    .local int rx1824_eos
    .local int rx1824_rep
    .local pmc rx1824_cur
    .local pmc rx1824_debug
    (rx1824_cur, rx1824_pos, rx1824_tgt, $I10) = self."!cursor_start"()
    rx1824_cur."!cursor_caparray"("invocant", "parameter")
    .lex unicode:"$\x{a2}", rx1824_cur
    .local pmc match
    .lex "$/", match
    length rx1824_eos, rx1824_tgt
    gt rx1824_pos, rx1824_eos, rx1824_done
    set rx1824_off, 0
    lt rx1824_pos, 2, rx1824_start
    sub rx1824_off, rx1824_pos, 1
    substr rx1824_tgt, rx1824_tgt, rx1824_off
  rx1824_start:
    eq $I10, 1, rx1824_restart
    if_null rx1824_debug, debug_1302
    rx1824_cur."!cursor_debug"("START", "signature")
  debug_1302:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1825_done
    goto rxscan1825_scan
  rxscan1825_loop:
    (rx1824_pos) = rx1824_cur."from"()
    inc rx1824_pos
    rx1824_cur."!cursor_from"(rx1824_pos)
    ge rx1824_pos, rx1824_eos, rxscan1825_done
  rxscan1825_scan:
    set_addr $I10, rxscan1825_loop
    rx1824_cur."!mark_push"(0, rx1824_pos, $I10)
  rxscan1825_done:
.annotate 'line', 901
  # rx rxquantr1826 ** 0..1
    set_addr $I10, rxquantr1826_done
    rx1824_cur."!mark_push"(0, rx1824_pos, $I10)
  rxquantr1826_loop:
    rx1824_cur."!cursor_pos"(rx1824_pos)
    find_lex $P103, unicode:"$\x{a2}"
    $P104 = $P103."MATCH"()
    store_lex "$/", $P104
    .const 'Sub' $P1828 = "226_1310110678.31883" 
    capture_lex $P1828
    $P105 = $P1828()
    unless $P105, rx1824_fail
  # rx subrule "ws" subtype=method negate=
    rx1824_cur."!cursor_pos"(rx1824_pos)
    $P10 = rx1824_cur."ws"()
    unless $P10, rx1824_fail
    rx1824_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx1824_cur."!cursor_pos"(rx1824_pos)
    $P10 = rx1824_cur."parameter"()
    unless $P10, rx1824_fail
    rx1824_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("invocant")
    rx1824_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1824_cur."!cursor_pos"(rx1824_pos)
    $P10 = rx1824_cur."ws"()
    unless $P10, rx1824_fail
    rx1824_pos = $P10."pos"()
  # rx literal  ":"
    add $I11, rx1824_pos, 1
    gt $I11, rx1824_eos, rx1824_fail
    sub $I11, rx1824_pos, rx1824_off
    ord $I11, rx1824_tgt, $I11
    ne $I11, 58, rx1824_fail
    add rx1824_pos, 1
    set_addr $I10, rxquantr1826_done
    (rx1824_rep) = rx1824_cur."!mark_commit"($I10)
  rxquantr1826_done:
.annotate 'line', 902
  # rx rxquantr1829 ** 0..1
    set_addr $I10, rxquantr1829_done
    rx1824_cur."!mark_push"(0, rx1824_pos, $I10)
  rxquantr1829_loop:
  # rx rxquantr1830 ** 1..*
    set_addr $I10, rxquantr1830_done
    rx1824_cur."!mark_push"(0, -1, $I10)
  rxquantr1830_loop:
  # rx subrule "ws" subtype=method negate=
    rx1824_cur."!cursor_pos"(rx1824_pos)
    $P10 = rx1824_cur."ws"()
    unless $P10, rx1824_fail
    rx1824_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx1824_cur."!cursor_pos"(rx1824_pos)
    $P10 = rx1824_cur."parameter"()
    unless $P10, rx1824_fail
    rx1824_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parameter")
    rx1824_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1824_cur."!cursor_pos"(rx1824_pos)
    $P10 = rx1824_cur."ws"()
    unless $P10, rx1824_fail
    rx1824_pos = $P10."pos"()
    set_addr $I10, rxquantr1830_done
    (rx1824_rep) = rx1824_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1830_done
    rx1824_cur."!mark_push"(rx1824_rep, rx1824_pos, $I10)
  # rx literal  ","
    add $I11, rx1824_pos, 1
    gt $I11, rx1824_eos, rx1824_fail
    sub $I11, rx1824_pos, rx1824_off
    ord $I11, rx1824_tgt, $I11
    ne $I11, 44, rx1824_fail
    add rx1824_pos, 1
    goto rxquantr1830_loop
  rxquantr1830_done:
    set_addr $I10, rxquantr1829_done
    (rx1824_rep) = rx1824_cur."!mark_commit"($I10)
  rxquantr1829_done:
.annotate 'line', 900
  # rx pass
    rx1824_cur."!cursor_pass"(rx1824_pos, "signature")
    if_null rx1824_debug, debug_1305
    rx1824_cur."!cursor_debug"("PASS", "signature", " at pos=", rx1824_pos)
  debug_1305:
    .return (rx1824_cur)
  rx1824_restart:
.annotate 'line', 435
    if_null rx1824_debug, debug_1306
    rx1824_cur."!cursor_debug"("NEXT", "signature")
  debug_1306:
  rx1824_fail:
    (rx1824_rep, rx1824_pos, $I10, $P10) = rx1824_cur."!mark_fail"(0)
    lt rx1824_pos, -1, rx1824_done
    eq rx1824_pos, -1, rx1824_fail
    jump $I10
  rx1824_done:
    rx1824_cur."!cursor_fail"()
    if_null rx1824_debug, debug_1307
    rx1824_cur."!cursor_debug"("FAIL", "signature")
  debug_1307:
    .return (rx1824_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1827"  :anon :subid("226_1310110678.31883") :outer("225_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 901
    find_dynamic_lex $P107, "$*INVOCANT_OK"
    unless_null $P107, vivify_1303
    get_hll_global $P105, "GLOBAL"
    get_who $P106, $P105
    set $P107, $P106["$INVOCANT_OK"]
    unless_null $P107, vivify_1304
    die "Contextual $*INVOCANT_OK not found"
  vivify_1304:
  vivify_1303:
    .return ($P107)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__signature"  :subid("227_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    new $P106, "ResizablePMCArray"
    push $P106, ""
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "parameter"  :subid("228_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1833_tgt
    .local int rx1833_pos
    .local int rx1833_off
    .local int rx1833_eos
    .local int rx1833_rep
    .local pmc rx1833_cur
    .local pmc rx1833_debug
    (rx1833_cur, rx1833_pos, rx1833_tgt, $I10) = self."!cursor_start"()
    rx1833_cur."!cursor_caparray"("typename", "definedness", "default_value")
    .lex unicode:"$\x{a2}", rx1833_cur
    .local pmc match
    .lex "$/", match
    length rx1833_eos, rx1833_tgt
    gt rx1833_pos, rx1833_eos, rx1833_done
    set rx1833_off, 0
    lt rx1833_pos, 2, rx1833_start
    sub rx1833_off, rx1833_pos, 1
    substr rx1833_tgt, rx1833_tgt, rx1833_off
  rx1833_start:
    eq $I10, 1, rx1833_restart
    if_null rx1833_debug, debug_1308
    rx1833_cur."!cursor_debug"("START", "parameter")
  debug_1308:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1834_done
    goto rxscan1834_scan
  rxscan1834_loop:
    (rx1833_pos) = rx1833_cur."from"()
    inc rx1833_pos
    rx1833_cur."!cursor_from"(rx1833_pos)
    ge rx1833_pos, rx1833_eos, rxscan1834_done
  rxscan1834_scan:
    set_addr $I10, rxscan1834_loop
    rx1833_cur."!mark_push"(0, rx1833_pos, $I10)
  rxscan1834_done:
.annotate 'line', 906
  # rx rxquantr1835 ** 0..*
    set_addr $I10, rxquantr1835_done
    rx1833_cur."!mark_push"(0, rx1833_pos, $I10)
  rxquantr1835_loop:
  # rx subrule "typename" subtype=capture negate=
    rx1833_cur."!cursor_pos"(rx1833_pos)
    $P10 = rx1833_cur."typename"()
    unless $P10, rx1833_fail
    rx1833_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("typename")
    rx1833_pos = $P10."pos"()
  # rx rxquantr1836 ** 0..1
    set_addr $I10, rxquantr1836_done
    rx1833_cur."!mark_push"(0, rx1833_pos, $I10)
  rxquantr1836_loop:
  # rx literal  ":"
    add $I11, rx1833_pos, 1
    gt $I11, rx1833_eos, rx1833_fail
    sub $I11, rx1833_pos, rx1833_off
    ord $I11, rx1833_tgt, $I11
    ne $I11, 58, rx1833_fail
    add rx1833_pos, 1
  # rx subcapture "definedness"
    set_addr $I10, rxcap_1837_fail
    rx1833_cur."!mark_push"(0, rx1833_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1833_pos, rx1833_eos, rx1833_fail
    sub $I10, rx1833_pos, rx1833_off
    substr $S10, rx1833_tgt, $I10, 1
    index $I11, "_DU", $S10
    lt $I11, 0, rx1833_fail
    inc rx1833_pos
    set_addr $I10, rxcap_1837_fail
    ($I12, $I11) = rx1833_cur."!mark_peek"($I10)
    rx1833_cur."!cursor_pos"($I11)
    ($P10) = rx1833_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1833_pos, "")
    rx1833_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("definedness")
    goto rxcap_1837_done
  rxcap_1837_fail:
    goto rx1833_fail
  rxcap_1837_done:
    set_addr $I10, rxquantr1836_done
    (rx1833_rep) = rx1833_cur."!mark_commit"($I10)
  rxquantr1836_done:
  # rx subrule "ws" subtype=method negate=
    rx1833_cur."!cursor_pos"(rx1833_pos)
    $P10 = rx1833_cur."ws"()
    unless $P10, rx1833_fail
    rx1833_pos = $P10."pos"()
    set_addr $I10, rxquantr1835_done
    (rx1833_rep) = rx1833_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1835_done
    rx1833_cur."!mark_push"(rx1833_rep, rx1833_pos, $I10)
    goto rxquantr1835_loop
  rxquantr1835_done:
  alt1838_0:
.annotate 'line', 907
    set_addr $I10, alt1838_1
    rx1833_cur."!mark_push"(0, rx1833_pos, $I10)
.annotate 'line', 908
  # rx subcapture "quant"
    set_addr $I10, rxcap_1839_fail
    rx1833_cur."!mark_push"(0, rx1833_pos, $I10)
  # rx literal  "*"
    add $I11, rx1833_pos, 1
    gt $I11, rx1833_eos, rx1833_fail
    sub $I11, rx1833_pos, rx1833_off
    ord $I11, rx1833_tgt, $I11
    ne $I11, 42, rx1833_fail
    add rx1833_pos, 1
    set_addr $I10, rxcap_1839_fail
    ($I12, $I11) = rx1833_cur."!mark_peek"($I10)
    rx1833_cur."!cursor_pos"($I11)
    ($P10) = rx1833_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1833_pos, "")
    rx1833_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_1839_done
  rxcap_1839_fail:
    goto rx1833_fail
  rxcap_1839_done:
  # rx subrule "param_var" subtype=capture negate=
    rx1833_cur."!cursor_pos"(rx1833_pos)
    $P10 = rx1833_cur."param_var"()
    unless $P10, rx1833_fail
    rx1833_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx1833_pos = $P10."pos"()
    goto alt1838_end
  alt1838_1:
  alt1840_0:
.annotate 'line', 909
    set_addr $I10, alt1840_1
    rx1833_cur."!mark_push"(0, rx1833_pos, $I10)
  # rx subrule "param_var" subtype=capture negate=
    rx1833_cur."!cursor_pos"(rx1833_pos)
    $P10 = rx1833_cur."param_var"()
    unless $P10, rx1833_fail
    rx1833_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx1833_pos = $P10."pos"()
    goto alt1840_end
  alt1840_1:
  # rx subrule "named_param" subtype=capture negate=
    rx1833_cur."!cursor_pos"(rx1833_pos)
    $P10 = rx1833_cur."named_param"()
    unless $P10, rx1833_fail
    rx1833_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("named_param")
    rx1833_pos = $P10."pos"()
  alt1840_end:
  # rx subcapture "quant"
    set_addr $I10, rxcap_1842_fail
    rx1833_cur."!mark_push"(0, rx1833_pos, $I10)
  alt1841_0:
    set_addr $I10, alt1841_1
    rx1833_cur."!mark_push"(0, rx1833_pos, $I10)
  # rx literal  "?"
    add $I11, rx1833_pos, 1
    gt $I11, rx1833_eos, rx1833_fail
    sub $I11, rx1833_pos, rx1833_off
    ord $I11, rx1833_tgt, $I11
    ne $I11, 63, rx1833_fail
    add rx1833_pos, 1
    goto alt1841_end
  alt1841_1:
    set_addr $I10, alt1841_2
    rx1833_cur."!mark_push"(0, rx1833_pos, $I10)
  # rx literal  "!"
    add $I11, rx1833_pos, 1
    gt $I11, rx1833_eos, rx1833_fail
    sub $I11, rx1833_pos, rx1833_off
    ord $I11, rx1833_tgt, $I11
    ne $I11, 33, rx1833_fail
    add rx1833_pos, 1
    goto alt1841_end
  alt1841_2:
  alt1841_end:
    set_addr $I10, rxcap_1842_fail
    ($I12, $I11) = rx1833_cur."!mark_peek"($I10)
    rx1833_cur."!cursor_pos"($I11)
    ($P10) = rx1833_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1833_pos, "")
    rx1833_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_1842_done
  rxcap_1842_fail:
    goto rx1833_fail
  rxcap_1842_done:
  alt1838_end:
.annotate 'line', 911
  # rx rxquantr1843 ** 0..1
    set_addr $I10, rxquantr1843_done
    rx1833_cur."!mark_push"(0, rx1833_pos, $I10)
  rxquantr1843_loop:
  # rx subrule "default_value" subtype=capture negate=
    rx1833_cur."!cursor_pos"(rx1833_pos)
    $P10 = rx1833_cur."default_value"()
    unless $P10, rx1833_fail
    goto rxsubrule1844_pass
  rxsubrule1844_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1833_fail
  rxsubrule1844_pass:
    set_addr $I10, rxsubrule1844_back
    rx1833_cur."!mark_push"(0, rx1833_pos, $I10, $P10)
    $P10."!cursor_names"("default_value")
    rx1833_pos = $P10."pos"()
    set_addr $I10, rxquantr1843_done
    (rx1833_rep) = rx1833_cur."!mark_commit"($I10)
  rxquantr1843_done:
.annotate 'line', 905
  # rx pass
    rx1833_cur."!cursor_pass"(rx1833_pos, "parameter")
    if_null rx1833_debug, debug_1309
    rx1833_cur."!cursor_debug"("PASS", "parameter", " at pos=", rx1833_pos)
  debug_1309:
    .return (rx1833_cur)
  rx1833_restart:
.annotate 'line', 435
    if_null rx1833_debug, debug_1310
    rx1833_cur."!cursor_debug"("NEXT", "parameter")
  debug_1310:
  rx1833_fail:
    (rx1833_rep, rx1833_pos, $I10, $P10) = rx1833_cur."!mark_fail"(0)
    lt rx1833_pos, -1, rx1833_done
    eq rx1833_pos, -1, rx1833_fail
    jump $I10
  rx1833_done:
    rx1833_cur."!cursor_fail"()
    if_null rx1833_debug, debug_1311
    rx1833_cur."!cursor_debug"("FAIL", "parameter")
  debug_1311:
    .return (rx1833_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__parameter"  :subid("229_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "param_var"  :subid("230_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1847_tgt
    .local int rx1847_pos
    .local int rx1847_off
    .local int rx1847_eos
    .local int rx1847_rep
    .local pmc rx1847_cur
    .local pmc rx1847_debug
    (rx1847_cur, rx1847_pos, rx1847_tgt, $I10) = self."!cursor_start"()
    rx1847_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx1847_cur
    .local pmc match
    .lex "$/", match
    length rx1847_eos, rx1847_tgt
    gt rx1847_pos, rx1847_eos, rx1847_done
    set rx1847_off, 0
    lt rx1847_pos, 2, rx1847_start
    sub rx1847_off, rx1847_pos, 1
    substr rx1847_tgt, rx1847_tgt, rx1847_off
  rx1847_start:
    eq $I10, 1, rx1847_restart
    if_null rx1847_debug, debug_1312
    rx1847_cur."!cursor_debug"("START", "param_var")
  debug_1312:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1848_done
    goto rxscan1848_scan
  rxscan1848_loop:
    (rx1847_pos) = rx1847_cur."from"()
    inc rx1847_pos
    rx1847_cur."!cursor_from"(rx1847_pos)
    ge rx1847_pos, rx1847_eos, rxscan1848_done
  rxscan1848_scan:
    set_addr $I10, rxscan1848_loop
    rx1847_cur."!mark_push"(0, rx1847_pos, $I10)
  rxscan1848_done:
.annotate 'line', 915
  # rx subrule "sigil" subtype=capture negate=
    rx1847_cur."!cursor_pos"(rx1847_pos)
    $P10 = rx1847_cur."sigil"()
    unless $P10, rx1847_fail
    rx1847_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1847_pos = $P10."pos"()
  # rx rxquantr1849 ** 0..1
    set_addr $I10, rxquantr1849_done
    rx1847_cur."!mark_push"(0, rx1847_pos, $I10)
  rxquantr1849_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx1847_cur."!cursor_pos"(rx1847_pos)
    $P10 = rx1847_cur."twigil"()
    unless $P10, rx1847_fail
    goto rxsubrule1850_pass
  rxsubrule1850_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1847_fail
  rxsubrule1850_pass:
    set_addr $I10, rxsubrule1850_back
    rx1847_cur."!mark_push"(0, rx1847_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx1847_pos = $P10."pos"()
    set_addr $I10, rxquantr1849_done
    (rx1847_rep) = rx1847_cur."!mark_commit"($I10)
  rxquantr1849_done:
  alt1851_0:
.annotate 'line', 916
    set_addr $I10, alt1851_1
    rx1847_cur."!mark_push"(0, rx1847_pos, $I10)
  # rx subrule "ident" subtype=capture negate=
    rx1847_cur."!cursor_pos"(rx1847_pos)
    $P10 = rx1847_cur."ident"()
    unless $P10, rx1847_fail
    rx1847_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1847_pos = $P10."pos"()
    goto alt1851_end
  alt1851_1:
  # rx subcapture "name"
    set_addr $I10, rxcap_1852_fail
    rx1847_cur."!mark_push"(0, rx1847_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1847_pos, rx1847_eos, rx1847_fail
    sub $I10, rx1847_pos, rx1847_off
    substr $S10, rx1847_tgt, $I10, 1
    index $I11, "/!", $S10
    lt $I11, 0, rx1847_fail
    inc rx1847_pos
    set_addr $I10, rxcap_1852_fail
    ($I12, $I11) = rx1847_cur."!mark_peek"($I10)
    rx1847_cur."!cursor_pos"($I11)
    ($P10) = rx1847_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1847_pos, "")
    rx1847_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    goto rxcap_1852_done
  rxcap_1852_fail:
    goto rx1847_fail
  rxcap_1852_done:
  alt1851_end:
.annotate 'line', 914
  # rx pass
    rx1847_cur."!cursor_pass"(rx1847_pos, "param_var")
    if_null rx1847_debug, debug_1313
    rx1847_cur."!cursor_debug"("PASS", "param_var", " at pos=", rx1847_pos)
  debug_1313:
    .return (rx1847_cur)
  rx1847_restart:
.annotate 'line', 435
    if_null rx1847_debug, debug_1314
    rx1847_cur."!cursor_debug"("NEXT", "param_var")
  debug_1314:
  rx1847_fail:
    (rx1847_rep, rx1847_pos, $I10, $P10) = rx1847_cur."!mark_fail"(0)
    lt rx1847_pos, -1, rx1847_done
    eq rx1847_pos, -1, rx1847_fail
    jump $I10
  rx1847_done:
    rx1847_cur."!cursor_fail"()
    if_null rx1847_debug, debug_1315
    rx1847_cur."!cursor_debug"("FAIL", "param_var")
  debug_1315:
    .return (rx1847_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__param_var"  :subid("231_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("sigil", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "named_param"  :subid("232_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1855_tgt
    .local int rx1855_pos
    .local int rx1855_off
    .local int rx1855_eos
    .local int rx1855_rep
    .local pmc rx1855_cur
    .local pmc rx1855_debug
    (rx1855_cur, rx1855_pos, rx1855_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1855_cur
    .local pmc match
    .lex "$/", match
    length rx1855_eos, rx1855_tgt
    gt rx1855_pos, rx1855_eos, rx1855_done
    set rx1855_off, 0
    lt rx1855_pos, 2, rx1855_start
    sub rx1855_off, rx1855_pos, 1
    substr rx1855_tgt, rx1855_tgt, rx1855_off
  rx1855_start:
    eq $I10, 1, rx1855_restart
    if_null rx1855_debug, debug_1316
    rx1855_cur."!cursor_debug"("START", "named_param")
  debug_1316:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1856_done
    goto rxscan1856_scan
  rxscan1856_loop:
    (rx1855_pos) = rx1855_cur."from"()
    inc rx1855_pos
    rx1855_cur."!cursor_from"(rx1855_pos)
    ge rx1855_pos, rx1855_eos, rxscan1856_done
  rxscan1856_scan:
    set_addr $I10, rxscan1856_loop
    rx1855_cur."!mark_push"(0, rx1855_pos, $I10)
  rxscan1856_done:
.annotate 'line', 920
  # rx literal  ":"
    add $I11, rx1855_pos, 1
    gt $I11, rx1855_eos, rx1855_fail
    sub $I11, rx1855_pos, rx1855_off
    ord $I11, rx1855_tgt, $I11
    ne $I11, 58, rx1855_fail
    add rx1855_pos, 1
  # rx subrule "param_var" subtype=capture negate=
    rx1855_cur."!cursor_pos"(rx1855_pos)
    $P10 = rx1855_cur."param_var"()
    unless $P10, rx1855_fail
    rx1855_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx1855_pos = $P10."pos"()
.annotate 'line', 919
  # rx pass
    rx1855_cur."!cursor_pass"(rx1855_pos, "named_param")
    if_null rx1855_debug, debug_1317
    rx1855_cur."!cursor_debug"("PASS", "named_param", " at pos=", rx1855_pos)
  debug_1317:
    .return (rx1855_cur)
  rx1855_restart:
.annotate 'line', 435
    if_null rx1855_debug, debug_1318
    rx1855_cur."!cursor_debug"("NEXT", "named_param")
  debug_1318:
  rx1855_fail:
    (rx1855_rep, rx1855_pos, $I10, $P10) = rx1855_cur."!mark_fail"(0)
    lt rx1855_pos, -1, rx1855_done
    eq rx1855_pos, -1, rx1855_fail
    jump $I10
  rx1855_done:
    rx1855_cur."!cursor_fail"()
    if_null rx1855_debug, debug_1319
    rx1855_cur."!cursor_debug"("FAIL", "named_param")
  debug_1319:
    .return (rx1855_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__named_param"  :subid("233_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("param_var", ":")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "default_value"  :subid("234_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1859_tgt
    .local int rx1859_pos
    .local int rx1859_off
    .local int rx1859_eos
    .local int rx1859_rep
    .local pmc rx1859_cur
    .local pmc rx1859_debug
    (rx1859_cur, rx1859_pos, rx1859_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1859_cur
    .local pmc match
    .lex "$/", match
    length rx1859_eos, rx1859_tgt
    gt rx1859_pos, rx1859_eos, rx1859_done
    set rx1859_off, 0
    lt rx1859_pos, 2, rx1859_start
    sub rx1859_off, rx1859_pos, 1
    substr rx1859_tgt, rx1859_tgt, rx1859_off
  rx1859_start:
    eq $I10, 1, rx1859_restart
    if_null rx1859_debug, debug_1320
    rx1859_cur."!cursor_debug"("START", "default_value")
  debug_1320:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1860_done
    goto rxscan1860_scan
  rxscan1860_loop:
    (rx1859_pos) = rx1859_cur."from"()
    inc rx1859_pos
    rx1859_cur."!cursor_from"(rx1859_pos)
    ge rx1859_pos, rx1859_eos, rxscan1860_done
  rxscan1860_scan:
    set_addr $I10, rxscan1860_loop
    rx1859_cur."!mark_push"(0, rx1859_pos, $I10)
  rxscan1860_done:
.annotate 'line', 923
  # rx subrule "ws" subtype=method negate=
    rx1859_cur."!cursor_pos"(rx1859_pos)
    $P10 = rx1859_cur."ws"()
    unless $P10, rx1859_fail
    rx1859_pos = $P10."pos"()
  # rx literal  "="
    add $I11, rx1859_pos, 1
    gt $I11, rx1859_eos, rx1859_fail
    sub $I11, rx1859_pos, rx1859_off
    ord $I11, rx1859_tgt, $I11
    ne $I11, 61, rx1859_fail
    add rx1859_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1859_cur."!cursor_pos"(rx1859_pos)
    $P10 = rx1859_cur."ws"()
    unless $P10, rx1859_fail
    rx1859_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1859_cur."!cursor_pos"(rx1859_pos)
    $P10 = rx1859_cur."EXPR"("i=")
    unless $P10, rx1859_fail
    rx1859_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1859_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1859_cur."!cursor_pos"(rx1859_pos)
    $P10 = rx1859_cur."ws"()
    unless $P10, rx1859_fail
    rx1859_pos = $P10."pos"()
  # rx pass
    rx1859_cur."!cursor_pass"(rx1859_pos, "default_value")
    if_null rx1859_debug, debug_1321
    rx1859_cur."!cursor_debug"("PASS", "default_value", " at pos=", rx1859_pos)
  debug_1321:
    .return (rx1859_cur)
  rx1859_restart:
.annotate 'line', 435
    if_null rx1859_debug, debug_1322
    rx1859_cur."!cursor_debug"("NEXT", "default_value")
  debug_1322:
  rx1859_fail:
    (rx1859_rep, rx1859_pos, $I10, $P10) = rx1859_cur."!mark_fail"(0)
    lt rx1859_pos, -1, rx1859_done
    eq rx1859_pos, -1, rx1859_fail
    jump $I10
  rx1859_done:
    rx1859_cur."!cursor_fail"()
    if_null rx1859_debug, debug_1323
    rx1859_cur."!cursor_debug"("FAIL", "default_value")
  debug_1323:
    .return (rx1859_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__default_value"  :subid("235_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P106 = self."!PREFIX__!subrule"("ws", "")
    new $P107, "ResizablePMCArray"
    push $P107, $P106
    .return ($P107)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait"  :subid("236_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1863_tgt
    .local int rx1863_pos
    .local int rx1863_off
    .local int rx1863_eos
    .local int rx1863_rep
    .local pmc rx1863_cur
    .local pmc rx1863_debug
    (rx1863_cur, rx1863_pos, rx1863_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1863_cur
    .local pmc match
    .lex "$/", match
    length rx1863_eos, rx1863_tgt
    gt rx1863_pos, rx1863_eos, rx1863_done
    set rx1863_off, 0
    lt rx1863_pos, 2, rx1863_start
    sub rx1863_off, rx1863_pos, 1
    substr rx1863_tgt, rx1863_tgt, rx1863_off
  rx1863_start:
    eq $I10, 1, rx1863_restart
    if_null rx1863_debug, debug_1324
    rx1863_cur."!cursor_debug"("START", "trait")
  debug_1324:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1864_done
    goto rxscan1864_scan
  rxscan1864_loop:
    (rx1863_pos) = rx1863_cur."from"()
    inc rx1863_pos
    rx1863_cur."!cursor_from"(rx1863_pos)
    ge rx1863_pos, rx1863_eos, rxscan1864_done
  rxscan1864_scan:
    set_addr $I10, rxscan1864_loop
    rx1863_cur."!mark_push"(0, rx1863_pos, $I10)
  rxscan1864_done:
.annotate 'line', 925
  # rx subrule "ws" subtype=method negate=
    rx1863_cur."!cursor_pos"(rx1863_pos)
    $P10 = rx1863_cur."ws"()
    unless $P10, rx1863_fail
    rx1863_pos = $P10."pos"()
  # rx subrule "trait_mod" subtype=capture negate=
    rx1863_cur."!cursor_pos"(rx1863_pos)
    $P10 = rx1863_cur."trait_mod"()
    unless $P10, rx1863_fail
    rx1863_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("trait_mod")
    rx1863_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1863_cur."!cursor_pos"(rx1863_pos)
    $P10 = rx1863_cur."ws"()
    unless $P10, rx1863_fail
    rx1863_pos = $P10."pos"()
  # rx pass
    rx1863_cur."!cursor_pass"(rx1863_pos, "trait")
    if_null rx1863_debug, debug_1325
    rx1863_cur."!cursor_debug"("PASS", "trait", " at pos=", rx1863_pos)
  debug_1325:
    .return (rx1863_cur)
  rx1863_restart:
.annotate 'line', 435
    if_null rx1863_debug, debug_1326
    rx1863_cur."!cursor_debug"("NEXT", "trait")
  debug_1326:
  rx1863_fail:
    (rx1863_rep, rx1863_pos, $I10, $P10) = rx1863_cur."!mark_fail"(0)
    lt rx1863_pos, -1, rx1863_done
    eq rx1863_pos, -1, rx1863_fail
    jump $I10
  rx1863_done:
    rx1863_cur."!cursor_fail"()
    if_null rx1863_debug, debug_1327
    rx1863_cur."!cursor_debug"("FAIL", "trait")
  debug_1327:
    .return (rx1863_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait"  :subid("237_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P105 = self."!PREFIX__!subrule"("ws", "")
    new $P106, "ResizablePMCArray"
    push $P106, $P105
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod"  :subid("238_1310110678.31883")
    .param pmc param_1867
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 927
    .lex "self", param_1867
    $P103 = param_1867."!protoregex"("trait_mod")
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod"  :subid("239_1310110678.31883")
    .param pmc param_1869
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 927
    .lex "self", param_1869
    $P104 = param_1869."!PREFIX__!protoregex"("trait_mod")
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod:sym<is>"  :subid("240_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1871_tgt
    .local int rx1871_pos
    .local int rx1871_off
    .local int rx1871_eos
    .local int rx1871_rep
    .local pmc rx1871_cur
    .local pmc rx1871_debug
    (rx1871_cur, rx1871_pos, rx1871_tgt, $I10) = self."!cursor_start"()
    rx1871_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx1871_cur
    .local pmc match
    .lex "$/", match
    length rx1871_eos, rx1871_tgt
    gt rx1871_pos, rx1871_eos, rx1871_done
    set rx1871_off, 0
    lt rx1871_pos, 2, rx1871_start
    sub rx1871_off, rx1871_pos, 1
    substr rx1871_tgt, rx1871_tgt, rx1871_off
  rx1871_start:
    eq $I10, 1, rx1871_restart
    if_null rx1871_debug, debug_1328
    rx1871_cur."!cursor_debug"("START", "trait_mod:sym<is>")
  debug_1328:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1872_done
    goto rxscan1872_scan
  rxscan1872_loop:
    (rx1871_pos) = rx1871_cur."from"()
    inc rx1871_pos
    rx1871_cur."!cursor_from"(rx1871_pos)
    ge rx1871_pos, rx1871_eos, rxscan1872_done
  rxscan1872_scan:
    set_addr $I10, rxscan1872_loop
    rx1871_cur."!mark_push"(0, rx1871_pos, $I10)
  rxscan1872_done:
.annotate 'line', 928
  # rx subcapture "sym"
    set_addr $I10, rxcap_1873_fail
    rx1871_cur."!mark_push"(0, rx1871_pos, $I10)
  # rx literal  "is"
    add $I11, rx1871_pos, 2
    gt $I11, rx1871_eos, rx1871_fail
    sub $I11, rx1871_pos, rx1871_off
    substr $S10, rx1871_tgt, $I11, 2
    ne $S10, "is", rx1871_fail
    add rx1871_pos, 2
    set_addr $I10, rxcap_1873_fail
    ($I12, $I11) = rx1871_cur."!mark_peek"($I10)
    rx1871_cur."!cursor_pos"($I11)
    ($P10) = rx1871_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1871_pos, "")
    rx1871_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1873_done
  rxcap_1873_fail:
    goto rx1871_fail
  rxcap_1873_done:
  # rx subrule "ws" subtype=method negate=
    rx1871_cur."!cursor_pos"(rx1871_pos)
    $P10 = rx1871_cur."ws"()
    unless $P10, rx1871_fail
    rx1871_pos = $P10."pos"()
  # rx subrule "deflongname" subtype=capture negate=
    rx1871_cur."!cursor_pos"(rx1871_pos)
    $P10 = rx1871_cur."deflongname"()
    unless $P10, rx1871_fail
    rx1871_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx1871_pos = $P10."pos"()
  # rx rxquantr1874 ** 0..1
    set_addr $I10, rxquantr1874_done
    rx1871_cur."!mark_push"(0, rx1871_pos, $I10)
  rxquantr1874_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx1871_cur."!cursor_pos"(rx1871_pos)
    $P10 = rx1871_cur."circumfix"()
    unless $P10, rx1871_fail
    goto rxsubrule1875_pass
  rxsubrule1875_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1871_fail
  rxsubrule1875_pass:
    set_addr $I10, rxsubrule1875_back
    rx1871_cur."!mark_push"(0, rx1871_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx1871_pos = $P10."pos"()
    set_addr $I10, rxquantr1874_done
    (rx1871_rep) = rx1871_cur."!mark_commit"($I10)
  rxquantr1874_done:
  # rx subrule "ws" subtype=method negate=
    rx1871_cur."!cursor_pos"(rx1871_pos)
    $P10 = rx1871_cur."ws"()
    unless $P10, rx1871_fail
    rx1871_pos = $P10."pos"()
  # rx pass
    rx1871_cur."!cursor_pass"(rx1871_pos, "trait_mod:sym<is>")
    if_null rx1871_debug, debug_1329
    rx1871_cur."!cursor_debug"("PASS", "trait_mod:sym<is>", " at pos=", rx1871_pos)
  debug_1329:
    .return (rx1871_cur)
  rx1871_restart:
.annotate 'line', 435
    if_null rx1871_debug, debug_1330
    rx1871_cur."!cursor_debug"("NEXT", "trait_mod:sym<is>")
  debug_1330:
  rx1871_fail:
    (rx1871_rep, rx1871_pos, $I10, $P10) = rx1871_cur."!mark_fail"(0)
    lt rx1871_pos, -1, rx1871_done
    eq rx1871_pos, -1, rx1871_fail
    jump $I10
  rx1871_done:
    rx1871_cur."!cursor_fail"()
    if_null rx1871_debug, debug_1331
    rx1871_cur."!cursor_debug"("FAIL", "trait_mod:sym<is>")
  debug_1331:
    .return (rx1871_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod:sym<is>"  :subid("241_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P105 = self."!PREFIX__!subrule"("ws", "is")
    new $P106, "ResizablePMCArray"
    push $P106, $P105
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "regex_declarator"  :subid("242_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1878_tgt
    .local int rx1878_pos
    .local int rx1878_off
    .local int rx1878_eos
    .local int rx1878_rep
    .local pmc rx1878_cur
    .local pmc rx1878_debug
    (rx1878_cur, rx1878_pos, rx1878_tgt, $I10) = self."!cursor_start"()
    rx1878_cur."!cursor_caparray"("signature")
    .lex unicode:"$\x{a2}", rx1878_cur
    .local pmc match
    .lex "$/", match
    length rx1878_eos, rx1878_tgt
    gt rx1878_pos, rx1878_eos, rx1878_done
    set rx1878_off, 0
    lt rx1878_pos, 2, rx1878_start
    sub rx1878_off, rx1878_pos, 1
    substr rx1878_tgt, rx1878_tgt, rx1878_off
  rx1878_start:
    eq $I10, 1, rx1878_restart
    if_null rx1878_debug, debug_1332
    rx1878_cur."!cursor_debug"("START", "regex_declarator")
  debug_1332:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1879_done
    goto rxscan1879_scan
  rxscan1879_loop:
    (rx1878_pos) = rx1878_cur."from"()
    inc rx1878_pos
    rx1878_cur."!cursor_from"(rx1878_pos)
    ge rx1878_pos, rx1878_eos, rxscan1879_done
  rxscan1879_scan:
    set_addr $I10, rxscan1879_loop
    rx1878_cur."!mark_push"(0, rx1878_pos, $I10)
  rxscan1879_done:
.annotate 'line', 930
  # rx subrule "ws" subtype=method negate=
    rx1878_cur."!cursor_pos"(rx1878_pos)
    $P10 = rx1878_cur."ws"()
    unless $P10, rx1878_fail
    rx1878_pos = $P10."pos"()
  alt1880_0:
.annotate 'line', 931
    set_addr $I10, alt1880_1
    rx1878_cur."!mark_push"(0, rx1878_pos, $I10)
.annotate 'line', 932
  # rx subrule "ws" subtype=method negate=
    rx1878_cur."!cursor_pos"(rx1878_pos)
    $P10 = rx1878_cur."ws"()
    unless $P10, rx1878_fail
    rx1878_pos = $P10."pos"()
  # rx subcapture "proto"
    set_addr $I10, rxcap_1881_fail
    rx1878_cur."!mark_push"(0, rx1878_pos, $I10)
  # rx literal  "proto"
    add $I11, rx1878_pos, 5
    gt $I11, rx1878_eos, rx1878_fail
    sub $I11, rx1878_pos, rx1878_off
    substr $S10, rx1878_tgt, $I11, 5
    ne $S10, "proto", rx1878_fail
    add rx1878_pos, 5
    set_addr $I10, rxcap_1881_fail
    ($I12, $I11) = rx1878_cur."!mark_peek"($I10)
    rx1878_cur."!cursor_pos"($I11)
    ($P10) = rx1878_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1878_pos, "")
    rx1878_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("proto")
    goto rxcap_1881_done
  rxcap_1881_fail:
    goto rx1878_fail
  rxcap_1881_done:
  # rx subrule "ws" subtype=method negate=
    rx1878_cur."!cursor_pos"(rx1878_pos)
    $P10 = rx1878_cur."ws"()
    unless $P10, rx1878_fail
    rx1878_pos = $P10."pos"()
  alt1882_0:
    set_addr $I10, alt1882_1
    rx1878_cur."!mark_push"(0, rx1878_pos, $I10)
  # rx literal  "regex"
    add $I11, rx1878_pos, 5
    gt $I11, rx1878_eos, rx1878_fail
    sub $I11, rx1878_pos, rx1878_off
    substr $S10, rx1878_tgt, $I11, 5
    ne $S10, "regex", rx1878_fail
    add rx1878_pos, 5
    goto alt1882_end
  alt1882_1:
    set_addr $I10, alt1882_2
    rx1878_cur."!mark_push"(0, rx1878_pos, $I10)
  # rx literal  "token"
    add $I11, rx1878_pos, 5
    gt $I11, rx1878_eos, rx1878_fail
    sub $I11, rx1878_pos, rx1878_off
    substr $S10, rx1878_tgt, $I11, 5
    ne $S10, "token", rx1878_fail
    add rx1878_pos, 5
    goto alt1882_end
  alt1882_2:
  # rx literal  "rule"
    add $I11, rx1878_pos, 4
    gt $I11, rx1878_eos, rx1878_fail
    sub $I11, rx1878_pos, rx1878_off
    substr $S10, rx1878_tgt, $I11, 4
    ne $S10, "rule", rx1878_fail
    add rx1878_pos, 4
  alt1882_end:
  # rx subrule "ws" subtype=method negate=
    rx1878_cur."!cursor_pos"(rx1878_pos)
    $P10 = rx1878_cur."ws"()
    unless $P10, rx1878_fail
    rx1878_pos = $P10."pos"()
.annotate 'line', 933
  # rx subrule "deflongname" subtype=capture negate=
    rx1878_cur."!cursor_pos"(rx1878_pos)
    $P10 = rx1878_cur."deflongname"()
    unless $P10, rx1878_fail
    rx1878_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1878_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1878_cur."!cursor_pos"(rx1878_pos)
    $P10 = rx1878_cur."ws"()
    unless $P10, rx1878_fail
    rx1878_pos = $P10."pos"()
  alt1883_0:
.annotate 'line', 934
    set_addr $I10, alt1883_1
    rx1878_cur."!mark_push"(0, rx1878_pos, $I10)
.annotate 'line', 935
  # rx subrule "ws" subtype=method negate=
    rx1878_cur."!cursor_pos"(rx1878_pos)
    $P10 = rx1878_cur."ws"()
    unless $P10, rx1878_fail
    rx1878_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx1878_pos, 1
    gt $I11, rx1878_eos, rx1878_fail
    sub $I11, rx1878_pos, rx1878_off
    ord $I11, rx1878_tgt, $I11
    ne $I11, 123, rx1878_fail
    add rx1878_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1878_cur."!cursor_pos"(rx1878_pos)
    $P10 = rx1878_cur."ws"()
    unless $P10, rx1878_fail
    rx1878_pos = $P10."pos"()
  # rx literal  "<...>"
    add $I11, rx1878_pos, 5
    gt $I11, rx1878_eos, rx1878_fail
    sub $I11, rx1878_pos, rx1878_off
    substr $S10, rx1878_tgt, $I11, 5
    ne $S10, "<...>", rx1878_fail
    add rx1878_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx1878_cur."!cursor_pos"(rx1878_pos)
    $P10 = rx1878_cur."ws"()
    unless $P10, rx1878_fail
    rx1878_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1878_pos, 1
    gt $I11, rx1878_eos, rx1878_fail
    sub $I11, rx1878_pos, rx1878_off
    ord $I11, rx1878_tgt, $I11
    ne $I11, 125, rx1878_fail
    add rx1878_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1878_cur."!cursor_pos"(rx1878_pos)
    $P10 = rx1878_cur."ENDSTMT"()
    unless $P10, rx1878_fail
  # rx subrule "ws" subtype=method negate=
    rx1878_cur."!cursor_pos"(rx1878_pos)
    $P10 = rx1878_cur."ws"()
    unless $P10, rx1878_fail
    rx1878_pos = $P10."pos"()
    goto alt1883_end
  alt1883_1:
    set_addr $I10, alt1883_2
    rx1878_cur."!mark_push"(0, rx1878_pos, $I10)
.annotate 'line', 936
  # rx subrule "ws" subtype=method negate=
    rx1878_cur."!cursor_pos"(rx1878_pos)
    $P10 = rx1878_cur."ws"()
    unless $P10, rx1878_fail
    rx1878_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx1878_pos, 1
    gt $I11, rx1878_eos, rx1878_fail
    sub $I11, rx1878_pos, rx1878_off
    ord $I11, rx1878_tgt, $I11
    ne $I11, 123, rx1878_fail
    add rx1878_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1878_cur."!cursor_pos"(rx1878_pos)
    $P10 = rx1878_cur."ws"()
    unless $P10, rx1878_fail
    rx1878_pos = $P10."pos"()
  # rx literal  "<*>"
    add $I11, rx1878_pos, 3
    gt $I11, rx1878_eos, rx1878_fail
    sub $I11, rx1878_pos, rx1878_off
    substr $S10, rx1878_tgt, $I11, 3
    ne $S10, "<*>", rx1878_fail
    add rx1878_pos, 3
  # rx subrule "ws" subtype=method negate=
    rx1878_cur."!cursor_pos"(rx1878_pos)
    $P10 = rx1878_cur."ws"()
    unless $P10, rx1878_fail
    rx1878_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1878_pos, 1
    gt $I11, rx1878_eos, rx1878_fail
    sub $I11, rx1878_pos, rx1878_off
    ord $I11, rx1878_tgt, $I11
    ne $I11, 125, rx1878_fail
    add rx1878_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1878_cur."!cursor_pos"(rx1878_pos)
    $P10 = rx1878_cur."ENDSTMT"()
    unless $P10, rx1878_fail
  # rx subrule "ws" subtype=method negate=
    rx1878_cur."!cursor_pos"(rx1878_pos)
    $P10 = rx1878_cur."ws"()
    unless $P10, rx1878_fail
    rx1878_pos = $P10."pos"()
    goto alt1883_end
  alt1883_2:
.annotate 'line', 937
  # rx subrule "ws" subtype=method negate=
    rx1878_cur."!cursor_pos"(rx1878_pos)
    $P10 = rx1878_cur."ws"()
    unless $P10, rx1878_fail
    rx1878_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1878_cur."!cursor_pos"(rx1878_pos)
    $P10 = rx1878_cur."panic"("Proto regex body must be <*> (or <...>, which is deprecated)")
    unless $P10, rx1878_fail
    rx1878_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1878_cur."!cursor_pos"(rx1878_pos)
    $P10 = rx1878_cur."ws"()
    unless $P10, rx1878_fail
    rx1878_pos = $P10."pos"()
  alt1883_end:
.annotate 'line', 938
  # rx subrule "ws" subtype=method negate=
    rx1878_cur."!cursor_pos"(rx1878_pos)
    $P10 = rx1878_cur."ws"()
    unless $P10, rx1878_fail
    rx1878_pos = $P10."pos"()
.annotate 'line', 932
    goto alt1880_end
  alt1880_1:
.annotate 'line', 939
  # rx subrule "ws" subtype=method negate=
    rx1878_cur."!cursor_pos"(rx1878_pos)
    $P10 = rx1878_cur."ws"()
    unless $P10, rx1878_fail
    rx1878_pos = $P10."pos"()
  # rx subcapture "sym"
    set_addr $I10, rxcap_1885_fail
    rx1878_cur."!mark_push"(0, rx1878_pos, $I10)
  alt1884_0:
    set_addr $I10, alt1884_1
    rx1878_cur."!mark_push"(0, rx1878_pos, $I10)
  # rx literal  "regex"
    add $I11, rx1878_pos, 5
    gt $I11, rx1878_eos, rx1878_fail
    sub $I11, rx1878_pos, rx1878_off
    substr $S10, rx1878_tgt, $I11, 5
    ne $S10, "regex", rx1878_fail
    add rx1878_pos, 5
    goto alt1884_end
  alt1884_1:
    set_addr $I10, alt1884_2
    rx1878_cur."!mark_push"(0, rx1878_pos, $I10)
  # rx literal  "token"
    add $I11, rx1878_pos, 5
    gt $I11, rx1878_eos, rx1878_fail
    sub $I11, rx1878_pos, rx1878_off
    substr $S10, rx1878_tgt, $I11, 5
    ne $S10, "token", rx1878_fail
    add rx1878_pos, 5
    goto alt1884_end
  alt1884_2:
  # rx literal  "rule"
    add $I11, rx1878_pos, 4
    gt $I11, rx1878_eos, rx1878_fail
    sub $I11, rx1878_pos, rx1878_off
    substr $S10, rx1878_tgt, $I11, 4
    ne $S10, "rule", rx1878_fail
    add rx1878_pos, 4
  alt1884_end:
    set_addr $I10, rxcap_1885_fail
    ($I12, $I11) = rx1878_cur."!mark_peek"($I10)
    rx1878_cur."!cursor_pos"($I11)
    ($P10) = rx1878_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1878_pos, "")
    rx1878_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1885_done
  rxcap_1885_fail:
    goto rx1878_fail
  rxcap_1885_done:
  # rx subrule "ws" subtype=method negate=
    rx1878_cur."!cursor_pos"(rx1878_pos)
    $P10 = rx1878_cur."ws"()
    unless $P10, rx1878_fail
    rx1878_pos = $P10."pos"()
.annotate 'line', 940
  # rx subrule "deflongname" subtype=capture negate=
    rx1878_cur."!cursor_pos"(rx1878_pos)
    $P10 = rx1878_cur."deflongname"()
    unless $P10, rx1878_fail
    rx1878_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1878_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1878_cur."!cursor_pos"(rx1878_pos)
    $P10 = rx1878_cur."ws"()
    unless $P10, rx1878_fail
    rx1878_pos = $P10."pos"()
.annotate 'line', 941
  # rx subrule "newpad" subtype=method negate=
    rx1878_cur."!cursor_pos"(rx1878_pos)
    $P10 = rx1878_cur."newpad"()
    unless $P10, rx1878_fail
    rx1878_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1878_cur."!cursor_pos"(rx1878_pos)
    $P10 = rx1878_cur."ws"()
    unless $P10, rx1878_fail
    rx1878_pos = $P10."pos"()
.annotate 'line', 942
  # rx rxquantr1886 ** 0..1
    set_addr $I10, rxquantr1886_done
    rx1878_cur."!mark_push"(0, rx1878_pos, $I10)
  rxquantr1886_loop:
  # rx subrule "ws" subtype=method negate=
    rx1878_cur."!cursor_pos"(rx1878_pos)
    $P10 = rx1878_cur."ws"()
    unless $P10, rx1878_fail
    rx1878_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1878_pos, 1
    gt $I11, rx1878_eos, rx1878_fail
    sub $I11, rx1878_pos, rx1878_off
    ord $I11, rx1878_tgt, $I11
    ne $I11, 40, rx1878_fail
    add rx1878_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1878_cur."!cursor_pos"(rx1878_pos)
    $P10 = rx1878_cur."ws"()
    unless $P10, rx1878_fail
    rx1878_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx1878_cur."!cursor_pos"(rx1878_pos)
    $P10 = rx1878_cur."signature"()
    unless $P10, rx1878_fail
    rx1878_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx1878_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1878_cur."!cursor_pos"(rx1878_pos)
    $P10 = rx1878_cur."ws"()
    unless $P10, rx1878_fail
    rx1878_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1878_pos, 1
    gt $I11, rx1878_eos, rx1878_fail
    sub $I11, rx1878_pos, rx1878_off
    ord $I11, rx1878_tgt, $I11
    ne $I11, 41, rx1878_fail
    add rx1878_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1878_cur."!cursor_pos"(rx1878_pos)
    $P10 = rx1878_cur."ws"()
    unless $P10, rx1878_fail
    rx1878_pos = $P10."pos"()
    set_addr $I10, rxquantr1886_done
    (rx1878_rep) = rx1878_cur."!mark_commit"($I10)
  rxquantr1886_done:
  # rx subrule "ws" subtype=method negate=
    rx1878_cur."!cursor_pos"(rx1878_pos)
    $P10 = rx1878_cur."ws"()
    unless $P10, rx1878_fail
    rx1878_pos = $P10."pos"()
.annotate 'line', 943
  # rx reduce name="regex_declarator" key="open"
    rx1878_cur."!cursor_pos"(rx1878_pos)
    rx1878_cur."!reduce"("regex_declarator", "open")
  # rx subrule "ws" subtype=method negate=
    rx1878_cur."!cursor_pos"(rx1878_pos)
    $P10 = rx1878_cur."ws"()
    unless $P10, rx1878_fail
    rx1878_pos = $P10."pos"()
.annotate 'line', 944
  # rx literal  "{"
    add $I11, rx1878_pos, 1
    gt $I11, rx1878_eos, rx1878_fail
    sub $I11, rx1878_pos, rx1878_off
    ord $I11, rx1878_tgt, $I11
    ne $I11, 123, rx1878_fail
    add rx1878_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx1878_cur."!cursor_pos"(rx1878_pos)
    $P10 = rx1878_cur."LANG"("Regex", "nibbler")
    unless $P10, rx1878_fail
    rx1878_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx1878_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1878_pos, 1
    gt $I11, rx1878_eos, rx1878_fail
    sub $I11, rx1878_pos, rx1878_off
    ord $I11, rx1878_tgt, $I11
    ne $I11, 125, rx1878_fail
    add rx1878_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1878_cur."!cursor_pos"(rx1878_pos)
    $P10 = rx1878_cur."ENDSTMT"()
    unless $P10, rx1878_fail
  # rx subrule "ws" subtype=method negate=
    rx1878_cur."!cursor_pos"(rx1878_pos)
    $P10 = rx1878_cur."ws"()
    unless $P10, rx1878_fail
    rx1878_pos = $P10."pos"()
  alt1880_end:
.annotate 'line', 945
  # rx subrule "ws" subtype=method negate=
    rx1878_cur."!cursor_pos"(rx1878_pos)
    $P10 = rx1878_cur."ws"()
    unless $P10, rx1878_fail
    rx1878_pos = $P10."pos"()
.annotate 'line', 930
  # rx pass
    rx1878_cur."!cursor_pass"(rx1878_pos, "regex_declarator")
    if_null rx1878_debug, debug_1333
    rx1878_cur."!cursor_debug"("PASS", "regex_declarator", " at pos=", rx1878_pos)
  debug_1333:
    .return (rx1878_cur)
  rx1878_restart:
.annotate 'line', 435
    if_null rx1878_debug, debug_1334
    rx1878_cur."!cursor_debug"("NEXT", "regex_declarator")
  debug_1334:
  rx1878_fail:
    (rx1878_rep, rx1878_pos, $I10, $P10) = rx1878_cur."!mark_fail"(0)
    lt rx1878_pos, -1, rx1878_done
    eq rx1878_pos, -1, rx1878_fail
    jump $I10
  rx1878_done:
    rx1878_cur."!cursor_fail"()
    if_null rx1878_debug, debug_1335
    rx1878_cur."!cursor_debug"("FAIL", "regex_declarator")
  debug_1335:
    .return (rx1878_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__regex_declarator"  :subid("243_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P131 = self."!PREFIX__!subrule"("ws", "")
    new $P132, "ResizablePMCArray"
    push $P132, $P131
    .return ($P132)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "dotty"  :subid("244_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1889_tgt
    .local int rx1889_pos
    .local int rx1889_off
    .local int rx1889_eos
    .local int rx1889_rep
    .local pmc rx1889_cur
    .local pmc rx1889_debug
    (rx1889_cur, rx1889_pos, rx1889_tgt, $I10) = self."!cursor_start"()
    rx1889_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1889_cur
    .local pmc match
    .lex "$/", match
    length rx1889_eos, rx1889_tgt
    gt rx1889_pos, rx1889_eos, rx1889_done
    set rx1889_off, 0
    lt rx1889_pos, 2, rx1889_start
    sub rx1889_off, rx1889_pos, 1
    substr rx1889_tgt, rx1889_tgt, rx1889_off
  rx1889_start:
    eq $I10, 1, rx1889_restart
    if_null rx1889_debug, debug_1336
    rx1889_cur."!cursor_debug"("START", "dotty")
  debug_1336:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1890_done
    goto rxscan1890_scan
  rxscan1890_loop:
    (rx1889_pos) = rx1889_cur."from"()
    inc rx1889_pos
    rx1889_cur."!cursor_from"(rx1889_pos)
    ge rx1889_pos, rx1889_eos, rxscan1890_done
  rxscan1890_scan:
    set_addr $I10, rxscan1890_loop
    rx1889_cur."!mark_push"(0, rx1889_pos, $I10)
  rxscan1890_done:
.annotate 'line', 949
  # rx literal  "."
    add $I11, rx1889_pos, 1
    gt $I11, rx1889_eos, rx1889_fail
    sub $I11, rx1889_pos, rx1889_off
    ord $I11, rx1889_tgt, $I11
    ne $I11, 46, rx1889_fail
    add rx1889_pos, 1
  alt1891_0:
.annotate 'line', 950
    set_addr $I10, alt1891_1
    rx1889_cur."!mark_push"(0, rx1889_pos, $I10)
  # rx subrule "deflongname" subtype=capture negate=
    rx1889_cur."!cursor_pos"(rx1889_pos)
    $P10 = rx1889_cur."deflongname"()
    unless $P10, rx1889_fail
    rx1889_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname=deflongname")
    rx1889_pos = $P10."pos"()
    goto alt1891_end
  alt1891_1:
.annotate 'line', 951
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1889_pos, rx1889_off
    substr $S10, rx1889_tgt, $I10, 1
    index $I11, "'\"", $S10
    lt $I11, 0, rx1889_fail
  # rx subrule "quote" subtype=capture negate=
    rx1889_cur."!cursor_pos"(rx1889_pos)
    $P10 = rx1889_cur."quote"()
    unless $P10, rx1889_fail
    rx1889_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1889_pos = $P10."pos"()
  alt1892_0:
.annotate 'line', 952
    set_addr $I10, alt1892_1
    rx1889_cur."!mark_push"(0, rx1889_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1889_pos, rx1889_off
    substr $S10, rx1889_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1889_fail
    goto alt1892_end
  alt1892_1:
  # rx subrule "panic" subtype=method negate=
    rx1889_cur."!cursor_pos"(rx1889_pos)
    $P10 = rx1889_cur."panic"("Quoted method name requires parenthesized arguments")
    unless $P10, rx1889_fail
    rx1889_pos = $P10."pos"()
  alt1892_end:
  alt1891_end:
.annotate 'line', 958
  # rx rxquantr1893 ** 0..1
    set_addr $I10, rxquantr1893_done
    rx1889_cur."!mark_push"(0, rx1889_pos, $I10)
  rxquantr1893_loop:
  alt1894_0:
.annotate 'line', 955
    set_addr $I10, alt1894_1
    rx1889_cur."!mark_push"(0, rx1889_pos, $I10)
.annotate 'line', 956
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1889_pos, rx1889_off
    substr $S10, rx1889_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1889_fail
  # rx subrule "args" subtype=capture negate=
    rx1889_cur."!cursor_pos"(rx1889_pos)
    $P10 = rx1889_cur."args"()
    unless $P10, rx1889_fail
    rx1889_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1889_pos = $P10."pos"()
    goto alt1894_end
  alt1894_1:
.annotate 'line', 957
  # rx literal  ":"
    add $I11, rx1889_pos, 1
    gt $I11, rx1889_eos, rx1889_fail
    sub $I11, rx1889_pos, rx1889_off
    ord $I11, rx1889_tgt, $I11
    ne $I11, 58, rx1889_fail
    add rx1889_pos, 1
  # rx charclass s
    ge rx1889_pos, rx1889_eos, rx1889_fail
    sub $I10, rx1889_pos, rx1889_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1889_tgt, $I10
    unless $I11, rx1889_fail
    inc rx1889_pos
  # rx subrule "arglist" subtype=capture negate=
    rx1889_cur."!cursor_pos"(rx1889_pos)
    $P10 = rx1889_cur."arglist"()
    unless $P10, rx1889_fail
    rx1889_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1889_pos = $P10."pos"()
  alt1894_end:
.annotate 'line', 958
    set_addr $I10, rxquantr1893_done
    (rx1889_rep) = rx1889_cur."!mark_commit"($I10)
  rxquantr1893_done:
.annotate 'line', 948
  # rx pass
    rx1889_cur."!cursor_pass"(rx1889_pos, "dotty")
    if_null rx1889_debug, debug_1337
    rx1889_cur."!cursor_debug"("PASS", "dotty", " at pos=", rx1889_pos)
  debug_1337:
    .return (rx1889_cur)
  rx1889_restart:
.annotate 'line', 435
    if_null rx1889_debug, debug_1338
    rx1889_cur."!cursor_debug"("NEXT", "dotty")
  debug_1338:
  rx1889_fail:
    (rx1889_rep, rx1889_pos, $I10, $P10) = rx1889_cur."!mark_fail"(0)
    lt rx1889_pos, -1, rx1889_done
    eq rx1889_pos, -1, rx1889_fail
    jump $I10
  rx1889_done:
    rx1889_cur."!cursor_fail"()
    if_null rx1889_debug, debug_1339
    rx1889_cur."!cursor_debug"("FAIL", "dotty")
  debug_1339:
    .return (rx1889_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__dotty"  :subid("245_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("deflongname", ".")
    new $P104, "ResizablePMCArray"
    push $P104, "'"
    push $P104, "\""
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term"  :subid("246_1310110678.31883")
    .param pmc param_1897
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 962
    .lex "self", param_1897
    $P103 = param_1897."!protoregex"("term")
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term"  :subid("247_1310110678.31883")
    .param pmc param_1899
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 962
    .lex "self", param_1899
    $P104 = param_1899."!PREFIX__!protoregex"("term")
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<self>"  :subid("248_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1901_tgt
    .local int rx1901_pos
    .local int rx1901_off
    .local int rx1901_eos
    .local int rx1901_rep
    .local pmc rx1901_cur
    .local pmc rx1901_debug
    (rx1901_cur, rx1901_pos, rx1901_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1901_cur
    .local pmc match
    .lex "$/", match
    length rx1901_eos, rx1901_tgt
    gt rx1901_pos, rx1901_eos, rx1901_done
    set rx1901_off, 0
    lt rx1901_pos, 2, rx1901_start
    sub rx1901_off, rx1901_pos, 1
    substr rx1901_tgt, rx1901_tgt, rx1901_off
  rx1901_start:
    eq $I10, 1, rx1901_restart
    if_null rx1901_debug, debug_1340
    rx1901_cur."!cursor_debug"("START", "term:sym<self>")
  debug_1340:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1902_done
    goto rxscan1902_scan
  rxscan1902_loop:
    (rx1901_pos) = rx1901_cur."from"()
    inc rx1901_pos
    rx1901_cur."!cursor_from"(rx1901_pos)
    ge rx1901_pos, rx1901_eos, rxscan1902_done
  rxscan1902_scan:
    set_addr $I10, rxscan1902_loop
    rx1901_cur."!mark_push"(0, rx1901_pos, $I10)
  rxscan1902_done:
.annotate 'line', 964
  # rx subcapture "sym"
    set_addr $I10, rxcap_1903_fail
    rx1901_cur."!mark_push"(0, rx1901_pos, $I10)
  # rx literal  "self"
    add $I11, rx1901_pos, 4
    gt $I11, rx1901_eos, rx1901_fail
    sub $I11, rx1901_pos, rx1901_off
    substr $S10, rx1901_tgt, $I11, 4
    ne $S10, "self", rx1901_fail
    add rx1901_pos, 4
    set_addr $I10, rxcap_1903_fail
    ($I12, $I11) = rx1901_cur."!mark_peek"($I10)
    rx1901_cur."!cursor_pos"($I11)
    ($P10) = rx1901_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1901_pos, "")
    rx1901_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1903_done
  rxcap_1903_fail:
    goto rx1901_fail
  rxcap_1903_done:
  # rxanchor rwb
    le rx1901_pos, 0, rx1901_fail
    sub $I10, rx1901_pos, rx1901_off
    is_cclass $I11, .CCLASS_WORD, rx1901_tgt, $I10
    if $I11, rx1901_fail
    dec $I10
    is_cclass $I11, .CCLASS_WORD, rx1901_tgt, $I10
    unless $I11, rx1901_fail
  # rx pass
    rx1901_cur."!cursor_pass"(rx1901_pos, "term:sym<self>")
    if_null rx1901_debug, debug_1341
    rx1901_cur."!cursor_debug"("PASS", "term:sym<self>", " at pos=", rx1901_pos)
  debug_1341:
    .return (rx1901_cur)
  rx1901_restart:
.annotate 'line', 435
    if_null rx1901_debug, debug_1342
    rx1901_cur."!cursor_debug"("NEXT", "term:sym<self>")
  debug_1342:
  rx1901_fail:
    (rx1901_rep, rx1901_pos, $I10, $P10) = rx1901_cur."!mark_fail"(0)
    lt rx1901_pos, -1, rx1901_done
    eq rx1901_pos, -1, rx1901_fail
    jump $I10
  rx1901_done:
    rx1901_cur."!cursor_fail"()
    if_null rx1901_debug, debug_1343
    rx1901_cur."!cursor_debug"("FAIL", "term:sym<self>")
  debug_1343:
    .return (rx1901_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<self>"  :subid("249_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    new $P103, "ResizablePMCArray"
    push $P103, "self"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<identifier>"  :subid("250_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1906_tgt
    .local int rx1906_pos
    .local int rx1906_off
    .local int rx1906_eos
    .local int rx1906_rep
    .local pmc rx1906_cur
    .local pmc rx1906_debug
    (rx1906_cur, rx1906_pos, rx1906_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1906_cur
    .local pmc match
    .lex "$/", match
    length rx1906_eos, rx1906_tgt
    gt rx1906_pos, rx1906_eos, rx1906_done
    set rx1906_off, 0
    lt rx1906_pos, 2, rx1906_start
    sub rx1906_off, rx1906_pos, 1
    substr rx1906_tgt, rx1906_tgt, rx1906_off
  rx1906_start:
    eq $I10, 1, rx1906_restart
    if_null rx1906_debug, debug_1344
    rx1906_cur."!cursor_debug"("START", "term:sym<identifier>")
  debug_1344:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1907_done
    goto rxscan1907_scan
  rxscan1907_loop:
    (rx1906_pos) = rx1906_cur."from"()
    inc rx1906_pos
    rx1906_cur."!cursor_from"(rx1906_pos)
    ge rx1906_pos, rx1906_eos, rxscan1907_done
  rxscan1907_scan:
    set_addr $I10, rxscan1907_loop
    rx1906_cur."!mark_push"(0, rx1906_pos, $I10)
  rxscan1907_done:
.annotate 'line', 967
  # rx subrule "deflongname" subtype=capture negate=
    rx1906_cur."!cursor_pos"(rx1906_pos)
    $P10 = rx1906_cur."deflongname"()
    unless $P10, rx1906_fail
    rx1906_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1906_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1906_pos, rx1906_off
    substr $S10, rx1906_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1906_fail
  # rx subrule "args" subtype=capture negate=
    rx1906_cur."!cursor_pos"(rx1906_pos)
    $P10 = rx1906_cur."args"()
    unless $P10, rx1906_fail
    rx1906_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1906_pos = $P10."pos"()
.annotate 'line', 966
  # rx pass
    rx1906_cur."!cursor_pass"(rx1906_pos, "term:sym<identifier>")
    if_null rx1906_debug, debug_1345
    rx1906_cur."!cursor_debug"("PASS", "term:sym<identifier>", " at pos=", rx1906_pos)
  debug_1345:
    .return (rx1906_cur)
  rx1906_restart:
.annotate 'line', 435
    if_null rx1906_debug, debug_1346
    rx1906_cur."!cursor_debug"("NEXT", "term:sym<identifier>")
  debug_1346:
  rx1906_fail:
    (rx1906_rep, rx1906_pos, $I10, $P10) = rx1906_cur."!mark_fail"(0)
    lt rx1906_pos, -1, rx1906_done
    eq rx1906_pos, -1, rx1906_fail
    jump $I10
  rx1906_done:
    rx1906_cur."!cursor_fail"()
    if_null rx1906_debug, debug_1347
    rx1906_cur."!cursor_debug"("FAIL", "term:sym<identifier>")
  debug_1347:
    .return (rx1906_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<identifier>"  :subid("251_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("deflongname", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<name>"  :subid("252_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1910_tgt
    .local int rx1910_pos
    .local int rx1910_off
    .local int rx1910_eos
    .local int rx1910_rep
    .local pmc rx1910_cur
    .local pmc rx1910_debug
    (rx1910_cur, rx1910_pos, rx1910_tgt, $I10) = self."!cursor_start"()
    rx1910_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1910_cur
    .local pmc match
    .lex "$/", match
    length rx1910_eos, rx1910_tgt
    gt rx1910_pos, rx1910_eos, rx1910_done
    set rx1910_off, 0
    lt rx1910_pos, 2, rx1910_start
    sub rx1910_off, rx1910_pos, 1
    substr rx1910_tgt, rx1910_tgt, rx1910_off
  rx1910_start:
    eq $I10, 1, rx1910_restart
    if_null rx1910_debug, debug_1348
    rx1910_cur."!cursor_debug"("START", "term:sym<name>")
  debug_1348:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1911_done
    goto rxscan1911_scan
  rxscan1911_loop:
    (rx1910_pos) = rx1910_cur."from"()
    inc rx1910_pos
    rx1910_cur."!cursor_from"(rx1910_pos)
    ge rx1910_pos, rx1910_eos, rxscan1911_done
  rxscan1911_scan:
    set_addr $I10, rxscan1911_loop
    rx1910_cur."!mark_push"(0, rx1910_pos, $I10)
  rxscan1911_done:
.annotate 'line', 971
  # rx subrule "name" subtype=capture negate=
    rx1910_cur."!cursor_pos"(rx1910_pos)
    $P10 = rx1910_cur."name"()
    unless $P10, rx1910_fail
    rx1910_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1910_pos = $P10."pos"()
  # rx rxquantr1912 ** 0..1
    set_addr $I10, rxquantr1912_done
    rx1910_cur."!mark_push"(0, rx1910_pos, $I10)
  rxquantr1912_loop:
  # rx subrule "args" subtype=capture negate=
    rx1910_cur."!cursor_pos"(rx1910_pos)
    $P10 = rx1910_cur."args"()
    unless $P10, rx1910_fail
    goto rxsubrule1913_pass
  rxsubrule1913_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1910_fail
  rxsubrule1913_pass:
    set_addr $I10, rxsubrule1913_back
    rx1910_cur."!mark_push"(0, rx1910_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1910_pos = $P10."pos"()
    set_addr $I10, rxquantr1912_done
    (rx1910_rep) = rx1910_cur."!mark_commit"($I10)
  rxquantr1912_done:
.annotate 'line', 970
  # rx pass
    rx1910_cur."!cursor_pass"(rx1910_pos, "term:sym<name>")
    if_null rx1910_debug, debug_1349
    rx1910_cur."!cursor_debug"("PASS", "term:sym<name>", " at pos=", rx1910_pos)
  debug_1349:
    .return (rx1910_cur)
  rx1910_restart:
.annotate 'line', 435
    if_null rx1910_debug, debug_1350
    rx1910_cur."!cursor_debug"("NEXT", "term:sym<name>")
  debug_1350:
  rx1910_fail:
    (rx1910_rep, rx1910_pos, $I10, $P10) = rx1910_cur."!mark_fail"(0)
    lt rx1910_pos, -1, rx1910_done
    eq rx1910_pos, -1, rx1910_fail
    jump $I10
  rx1910_done:
    rx1910_cur."!cursor_fail"()
    if_null rx1910_debug, debug_1351
    rx1910_cur."!cursor_debug"("FAIL", "term:sym<name>")
  debug_1351:
    .return (rx1910_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<name>"  :subid("253_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("name", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<pir::op>"  :subid("254_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1916_tgt
    .local int rx1916_pos
    .local int rx1916_off
    .local int rx1916_eos
    .local int rx1916_rep
    .local pmc rx1916_cur
    .local pmc rx1916_debug
    (rx1916_cur, rx1916_pos, rx1916_tgt, $I10) = self."!cursor_start"()
    rx1916_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1916_cur
    .local pmc match
    .lex "$/", match
    length rx1916_eos, rx1916_tgt
    gt rx1916_pos, rx1916_eos, rx1916_done
    set rx1916_off, 0
    lt rx1916_pos, 2, rx1916_start
    sub rx1916_off, rx1916_pos, 1
    substr rx1916_tgt, rx1916_tgt, rx1916_off
  rx1916_start:
    eq $I10, 1, rx1916_restart
    if_null rx1916_debug, debug_1352
    rx1916_cur."!cursor_debug"("START", "term:sym<pir::op>")
  debug_1352:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1917_done
    goto rxscan1917_scan
  rxscan1917_loop:
    (rx1916_pos) = rx1916_cur."from"()
    inc rx1916_pos
    rx1916_cur."!cursor_from"(rx1916_pos)
    ge rx1916_pos, rx1916_eos, rxscan1917_done
  rxscan1917_scan:
    set_addr $I10, rxscan1917_loop
    rx1916_cur."!mark_push"(0, rx1916_pos, $I10)
  rxscan1917_done:
.annotate 'line', 975
  # rx literal  "pir::"
    add $I11, rx1916_pos, 5
    gt $I11, rx1916_eos, rx1916_fail
    sub $I11, rx1916_pos, rx1916_off
    substr $S10, rx1916_tgt, $I11, 5
    ne $S10, "pir::", rx1916_fail
    add rx1916_pos, 5
  # rx subcapture "op"
    set_addr $I10, rxcap_1918_fail
    rx1916_cur."!mark_push"(0, rx1916_pos, $I10)
  # rx charclass_q w r 1..-1
    sub $I10, rx1916_pos, rx1916_off
    find_not_cclass $I11, .CCLASS_WORD, rx1916_tgt, $I10, rx1916_eos
    add $I12, $I10, 1
    lt $I11, $I12, rx1916_fail
    add rx1916_pos, rx1916_off, $I11
    set_addr $I10, rxcap_1918_fail
    ($I12, $I11) = rx1916_cur."!mark_peek"($I10)
    rx1916_cur."!cursor_pos"($I11)
    ($P10) = rx1916_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1916_pos, "")
    rx1916_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("op")
    goto rxcap_1918_done
  rxcap_1918_fail:
    goto rx1916_fail
  rxcap_1918_done:
  # rx rxquantr1919 ** 0..1
    set_addr $I10, rxquantr1919_done
    rx1916_cur."!mark_push"(0, rx1916_pos, $I10)
  rxquantr1919_loop:
  # rx subrule "args" subtype=capture negate=
    rx1916_cur."!cursor_pos"(rx1916_pos)
    $P10 = rx1916_cur."args"()
    unless $P10, rx1916_fail
    goto rxsubrule1920_pass
  rxsubrule1920_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1916_fail
  rxsubrule1920_pass:
    set_addr $I10, rxsubrule1920_back
    rx1916_cur."!mark_push"(0, rx1916_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1916_pos = $P10."pos"()
    set_addr $I10, rxquantr1919_done
    (rx1916_rep) = rx1916_cur."!mark_commit"($I10)
  rxquantr1919_done:
.annotate 'line', 974
  # rx pass
    rx1916_cur."!cursor_pass"(rx1916_pos, "term:sym<pir::op>")
    if_null rx1916_debug, debug_1353
    rx1916_cur."!cursor_debug"("PASS", "term:sym<pir::op>", " at pos=", rx1916_pos)
  debug_1353:
    .return (rx1916_cur)
  rx1916_restart:
.annotate 'line', 435
    if_null rx1916_debug, debug_1354
    rx1916_cur."!cursor_debug"("NEXT", "term:sym<pir::op>")
  debug_1354:
  rx1916_fail:
    (rx1916_rep, rx1916_pos, $I10, $P10) = rx1916_cur."!mark_fail"(0)
    lt rx1916_pos, -1, rx1916_done
    eq rx1916_pos, -1, rx1916_fail
    jump $I10
  rx1916_done:
    rx1916_cur."!cursor_fail"()
    if_null rx1916_debug, debug_1355
    rx1916_cur."!cursor_debug"("FAIL", "term:sym<pir::op>")
  debug_1355:
    .return (rx1916_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<pir::op>"  :subid("255_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    new $P103, "ResizablePMCArray"
    push $P103, "pir::"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<pir::const>"  :subid("256_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1923_tgt
    .local int rx1923_pos
    .local int rx1923_off
    .local int rx1923_eos
    .local int rx1923_rep
    .local pmc rx1923_cur
    .local pmc rx1923_debug
    (rx1923_cur, rx1923_pos, rx1923_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1923_cur
    .local pmc match
    .lex "$/", match
    length rx1923_eos, rx1923_tgt
    gt rx1923_pos, rx1923_eos, rx1923_done
    set rx1923_off, 0
    lt rx1923_pos, 2, rx1923_start
    sub rx1923_off, rx1923_pos, 1
    substr rx1923_tgt, rx1923_tgt, rx1923_off
  rx1923_start:
    eq $I10, 1, rx1923_restart
    if_null rx1923_debug, debug_1356
    rx1923_cur."!cursor_debug"("START", "term:sym<pir::const>")
  debug_1356:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1924_done
    goto rxscan1924_scan
  rxscan1924_loop:
    (rx1923_pos) = rx1923_cur."from"()
    inc rx1923_pos
    rx1923_cur."!cursor_from"(rx1923_pos)
    ge rx1923_pos, rx1923_eos, rxscan1924_done
  rxscan1924_scan:
    set_addr $I10, rxscan1924_loop
    rx1923_cur."!mark_push"(0, rx1923_pos, $I10)
  rxscan1924_done:
.annotate 'line', 979
  # rx literal  "pir::const::"
    add $I11, rx1923_pos, 12
    gt $I11, rx1923_eos, rx1923_fail
    sub $I11, rx1923_pos, rx1923_off
    substr $S10, rx1923_tgt, $I11, 12
    ne $S10, "pir::const::", rx1923_fail
    add rx1923_pos, 12
  # rx subcapture "const"
    set_addr $I10, rxcap_1925_fail
    rx1923_cur."!mark_push"(0, rx1923_pos, $I10)
  # rx charclass_q w r 1..-1
    sub $I10, rx1923_pos, rx1923_off
    find_not_cclass $I11, .CCLASS_WORD, rx1923_tgt, $I10, rx1923_eos
    add $I12, $I10, 1
    lt $I11, $I12, rx1923_fail
    add rx1923_pos, rx1923_off, $I11
    set_addr $I10, rxcap_1925_fail
    ($I12, $I11) = rx1923_cur."!mark_peek"($I10)
    rx1923_cur."!cursor_pos"($I11)
    ($P10) = rx1923_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1923_pos, "")
    rx1923_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("const")
    goto rxcap_1925_done
  rxcap_1925_fail:
    goto rx1923_fail
  rxcap_1925_done:
.annotate 'line', 978
  # rx pass
    rx1923_cur."!cursor_pass"(rx1923_pos, "term:sym<pir::const>")
    if_null rx1923_debug, debug_1357
    rx1923_cur."!cursor_debug"("PASS", "term:sym<pir::const>", " at pos=", rx1923_pos)
  debug_1357:
    .return (rx1923_cur)
  rx1923_restart:
.annotate 'line', 435
    if_null rx1923_debug, debug_1358
    rx1923_cur."!cursor_debug"("NEXT", "term:sym<pir::const>")
  debug_1358:
  rx1923_fail:
    (rx1923_rep, rx1923_pos, $I10, $P10) = rx1923_cur."!mark_fail"(0)
    lt rx1923_pos, -1, rx1923_done
    eq rx1923_pos, -1, rx1923_fail
    jump $I10
  rx1923_done:
    rx1923_cur."!cursor_fail"()
    if_null rx1923_debug, debug_1359
    rx1923_cur."!cursor_debug"("FAIL", "term:sym<pir::const>")
  debug_1359:
    .return (rx1923_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<pir::const>"  :subid("257_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    new $P103, "ResizablePMCArray"
    push $P103, "pir::const::"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<nqp::op>"  :subid("258_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1928_tgt
    .local int rx1928_pos
    .local int rx1928_off
    .local int rx1928_eos
    .local int rx1928_rep
    .local pmc rx1928_cur
    .local pmc rx1928_debug
    (rx1928_cur, rx1928_pos, rx1928_tgt, $I10) = self."!cursor_start"()
    rx1928_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1928_cur
    .local pmc match
    .lex "$/", match
    length rx1928_eos, rx1928_tgt
    gt rx1928_pos, rx1928_eos, rx1928_done
    set rx1928_off, 0
    lt rx1928_pos, 2, rx1928_start
    sub rx1928_off, rx1928_pos, 1
    substr rx1928_tgt, rx1928_tgt, rx1928_off
  rx1928_start:
    eq $I10, 1, rx1928_restart
    if_null rx1928_debug, debug_1360
    rx1928_cur."!cursor_debug"("START", "term:sym<nqp::op>")
  debug_1360:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1929_done
    goto rxscan1929_scan
  rxscan1929_loop:
    (rx1928_pos) = rx1928_cur."from"()
    inc rx1928_pos
    rx1928_cur."!cursor_from"(rx1928_pos)
    ge rx1928_pos, rx1928_eos, rxscan1929_done
  rxscan1929_scan:
    set_addr $I10, rxscan1929_loop
    rx1928_cur."!mark_push"(0, rx1928_pos, $I10)
  rxscan1929_done:
.annotate 'line', 983
  # rx literal  "nqp::"
    add $I11, rx1928_pos, 5
    gt $I11, rx1928_eos, rx1928_fail
    sub $I11, rx1928_pos, rx1928_off
    substr $S10, rx1928_tgt, $I11, 5
    ne $S10, "nqp::", rx1928_fail
    add rx1928_pos, 5
  # rx subcapture "op"
    set_addr $I10, rxcap_1930_fail
    rx1928_cur."!mark_push"(0, rx1928_pos, $I10)
  # rx charclass_q w r 1..-1
    sub $I10, rx1928_pos, rx1928_off
    find_not_cclass $I11, .CCLASS_WORD, rx1928_tgt, $I10, rx1928_eos
    add $I12, $I10, 1
    lt $I11, $I12, rx1928_fail
    add rx1928_pos, rx1928_off, $I11
    set_addr $I10, rxcap_1930_fail
    ($I12, $I11) = rx1928_cur."!mark_peek"($I10)
    rx1928_cur."!cursor_pos"($I11)
    ($P10) = rx1928_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1928_pos, "")
    rx1928_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("op")
    goto rxcap_1930_done
  rxcap_1930_fail:
    goto rx1928_fail
  rxcap_1930_done:
  # rx rxquantr1931 ** 0..1
    set_addr $I10, rxquantr1931_done
    rx1928_cur."!mark_push"(0, rx1928_pos, $I10)
  rxquantr1931_loop:
  # rx subrule "args" subtype=capture negate=
    rx1928_cur."!cursor_pos"(rx1928_pos)
    $P10 = rx1928_cur."args"()
    unless $P10, rx1928_fail
    goto rxsubrule1932_pass
  rxsubrule1932_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1928_fail
  rxsubrule1932_pass:
    set_addr $I10, rxsubrule1932_back
    rx1928_cur."!mark_push"(0, rx1928_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1928_pos = $P10."pos"()
    set_addr $I10, rxquantr1931_done
    (rx1928_rep) = rx1928_cur."!mark_commit"($I10)
  rxquantr1931_done:
.annotate 'line', 982
  # rx pass
    rx1928_cur."!cursor_pass"(rx1928_pos, "term:sym<nqp::op>")
    if_null rx1928_debug, debug_1361
    rx1928_cur."!cursor_debug"("PASS", "term:sym<nqp::op>", " at pos=", rx1928_pos)
  debug_1361:
    .return (rx1928_cur)
  rx1928_restart:
.annotate 'line', 435
    if_null rx1928_debug, debug_1362
    rx1928_cur."!cursor_debug"("NEXT", "term:sym<nqp::op>")
  debug_1362:
  rx1928_fail:
    (rx1928_rep, rx1928_pos, $I10, $P10) = rx1928_cur."!mark_fail"(0)
    lt rx1928_pos, -1, rx1928_done
    eq rx1928_pos, -1, rx1928_fail
    jump $I10
  rx1928_done:
    rx1928_cur."!cursor_fail"()
    if_null rx1928_debug, debug_1363
    rx1928_cur."!cursor_debug"("FAIL", "term:sym<nqp::op>")
  debug_1363:
    .return (rx1928_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<nqp::op>"  :subid("259_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    new $P103, "ResizablePMCArray"
    push $P103, "nqp::"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<onlystar>"  :subid("260_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .const 'Sub' $P1939 = "261_1310110678.31883" 
    capture_lex $P1939
    .local string rx1935_tgt
    .local int rx1935_pos
    .local int rx1935_off
    .local int rx1935_eos
    .local int rx1935_rep
    .local pmc rx1935_cur
    .local pmc rx1935_debug
    (rx1935_cur, rx1935_pos, rx1935_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1935_cur
    .local pmc match
    .lex "$/", match
    length rx1935_eos, rx1935_tgt
    gt rx1935_pos, rx1935_eos, rx1935_done
    set rx1935_off, 0
    lt rx1935_pos, 2, rx1935_start
    sub rx1935_off, rx1935_pos, 1
    substr rx1935_tgt, rx1935_tgt, rx1935_off
  rx1935_start:
    eq $I10, 1, rx1935_restart
    if_null rx1935_debug, debug_1364
    rx1935_cur."!cursor_debug"("START", "term:sym<onlystar>")
  debug_1364:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1936_done
    goto rxscan1936_scan
  rxscan1936_loop:
    (rx1935_pos) = rx1935_cur."from"()
    inc rx1935_pos
    rx1935_cur."!cursor_from"(rx1935_pos)
    ge rx1935_pos, rx1935_eos, rxscan1936_done
  rxscan1936_scan:
    set_addr $I10, rxscan1936_loop
    rx1935_cur."!mark_push"(0, rx1935_pos, $I10)
  rxscan1936_done:
.annotate 'line', 987
  # rx literal  "{*}"
    add $I11, rx1935_pos, 3
    gt $I11, rx1935_eos, rx1935_fail
    sub $I11, rx1935_pos, rx1935_off
    substr $S10, rx1935_tgt, $I11, 3
    ne $S10, "{*}", rx1935_fail
    add rx1935_pos, 3
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1935_cur."!cursor_pos"(rx1935_pos)
    $P10 = rx1935_cur."ENDSTMT"()
    unless $P10, rx1935_fail
  alt1937_0:
.annotate 'line', 988
    set_addr $I10, alt1937_1
    rx1935_cur."!mark_push"(0, rx1935_pos, $I10)
    rx1935_cur."!cursor_pos"(rx1935_pos)
    find_lex $P103, unicode:"$\x{a2}"
    $P104 = $P103."MATCH"()
    store_lex "$/", $P104
    .const 'Sub' $P1939 = "261_1310110678.31883" 
    capture_lex $P1939
    $P105 = $P1939()
    unless $P105, rx1935_fail
    goto alt1937_end
  alt1937_1:
  # rx subrule "panic" subtype=method negate=
    rx1935_cur."!cursor_pos"(rx1935_pos)
    $P10 = rx1935_cur."panic"("{*} may only appear in proto")
    unless $P10, rx1935_fail
    rx1935_pos = $P10."pos"()
  alt1937_end:
.annotate 'line', 986
  # rx pass
    rx1935_cur."!cursor_pass"(rx1935_pos, "term:sym<onlystar>")
    if_null rx1935_debug, debug_1367
    rx1935_cur."!cursor_debug"("PASS", "term:sym<onlystar>", " at pos=", rx1935_pos)
  debug_1367:
    .return (rx1935_cur)
  rx1935_restart:
.annotate 'line', 435
    if_null rx1935_debug, debug_1368
    rx1935_cur."!cursor_debug"("NEXT", "term:sym<onlystar>")
  debug_1368:
  rx1935_fail:
    (rx1935_rep, rx1935_pos, $I10, $P10) = rx1935_cur."!mark_fail"(0)
    lt rx1935_pos, -1, rx1935_done
    eq rx1935_pos, -1, rx1935_fail
    jump $I10
  rx1935_done:
    rx1935_cur."!cursor_fail"()
    if_null rx1935_debug, debug_1369
    rx1935_cur."!cursor_debug"("FAIL", "term:sym<onlystar>")
  debug_1369:
    .return (rx1935_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1938"  :anon :subid("261_1310110678.31883") :outer("260_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 988
    find_dynamic_lex $P107, "$*MULTINESS"
    unless_null $P107, vivify_1365
    get_hll_global $P105, "GLOBAL"
    get_who $P106, $P105
    set $P107, $P106["$MULTINESS"]
    unless_null $P107, vivify_1366
    die "Contextual $*MULTINESS not found"
  vivify_1366:
  vivify_1365:
    set $S100, $P107
    iseq $I100, $S100, "proto"
    .return ($I100)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<onlystar>"  :subid("262_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    new $P106, "ResizablePMCArray"
    push $P106, "{*}"
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "args"  :subid("263_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1942_tgt
    .local int rx1942_pos
    .local int rx1942_off
    .local int rx1942_eos
    .local int rx1942_rep
    .local pmc rx1942_cur
    .local pmc rx1942_debug
    (rx1942_cur, rx1942_pos, rx1942_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1942_cur
    .local pmc match
    .lex "$/", match
    length rx1942_eos, rx1942_tgt
    gt rx1942_pos, rx1942_eos, rx1942_done
    set rx1942_off, 0
    lt rx1942_pos, 2, rx1942_start
    sub rx1942_off, rx1942_pos, 1
    substr rx1942_tgt, rx1942_tgt, rx1942_off
  rx1942_start:
    eq $I10, 1, rx1942_restart
    if_null rx1942_debug, debug_1370
    rx1942_cur."!cursor_debug"("START", "args")
  debug_1370:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1943_done
    goto rxscan1943_scan
  rxscan1943_loop:
    (rx1942_pos) = rx1942_cur."from"()
    inc rx1942_pos
    rx1942_cur."!cursor_from"(rx1942_pos)
    ge rx1942_pos, rx1942_eos, rxscan1943_done
  rxscan1943_scan:
    set_addr $I10, rxscan1943_loop
    rx1942_cur."!mark_push"(0, rx1942_pos, $I10)
  rxscan1943_done:
.annotate 'line', 992
  # rx literal  "("
    add $I11, rx1942_pos, 1
    gt $I11, rx1942_eos, rx1942_fail
    sub $I11, rx1942_pos, rx1942_off
    ord $I11, rx1942_tgt, $I11
    ne $I11, 40, rx1942_fail
    add rx1942_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx1942_cur."!cursor_pos"(rx1942_pos)
    $P10 = rx1942_cur."arglist"()
    unless $P10, rx1942_fail
    rx1942_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1942_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1942_pos, 1
    gt $I11, rx1942_eos, rx1942_fail
    sub $I11, rx1942_pos, rx1942_off
    ord $I11, rx1942_tgt, $I11
    ne $I11, 41, rx1942_fail
    add rx1942_pos, 1
  # rx pass
    rx1942_cur."!cursor_pass"(rx1942_pos, "args")
    if_null rx1942_debug, debug_1371
    rx1942_cur."!cursor_debug"("PASS", "args", " at pos=", rx1942_pos)
  debug_1371:
    .return (rx1942_cur)
  rx1942_restart:
.annotate 'line', 435
    if_null rx1942_debug, debug_1372
    rx1942_cur."!cursor_debug"("NEXT", "args")
  debug_1372:
  rx1942_fail:
    (rx1942_rep, rx1942_pos, $I10, $P10) = rx1942_cur."!mark_fail"(0)
    lt rx1942_pos, -1, rx1942_done
    eq rx1942_pos, -1, rx1942_fail
    jump $I10
  rx1942_done:
    rx1942_cur."!cursor_fail"()
    if_null rx1942_debug, debug_1373
    rx1942_cur."!cursor_debug"("FAIL", "args")
  debug_1373:
    .return (rx1942_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__args"  :subid("264_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("arglist", "(")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "arglist"  :subid("265_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1946_tgt
    .local int rx1946_pos
    .local int rx1946_off
    .local int rx1946_eos
    .local int rx1946_rep
    .local pmc rx1946_cur
    .local pmc rx1946_debug
    (rx1946_cur, rx1946_pos, rx1946_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1946_cur
    .local pmc match
    .lex "$/", match
    length rx1946_eos, rx1946_tgt
    gt rx1946_pos, rx1946_eos, rx1946_done
    set rx1946_off, 0
    lt rx1946_pos, 2, rx1946_start
    sub rx1946_off, rx1946_pos, 1
    substr rx1946_tgt, rx1946_tgt, rx1946_off
  rx1946_start:
    eq $I10, 1, rx1946_restart
    if_null rx1946_debug, debug_1374
    rx1946_cur."!cursor_debug"("START", "arglist")
  debug_1374:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1947_done
    goto rxscan1947_scan
  rxscan1947_loop:
    (rx1946_pos) = rx1946_cur."from"()
    inc rx1946_pos
    rx1946_cur."!cursor_from"(rx1946_pos)
    ge rx1946_pos, rx1946_eos, rxscan1947_done
  rxscan1947_scan:
    set_addr $I10, rxscan1947_loop
    rx1946_cur."!mark_push"(0, rx1946_pos, $I10)
  rxscan1947_done:
.annotate 'line', 996
  # rx subrule "ws" subtype=method negate=
    rx1946_cur."!cursor_pos"(rx1946_pos)
    $P10 = rx1946_cur."ws"()
    unless $P10, rx1946_fail
    rx1946_pos = $P10."pos"()
  alt1948_0:
.annotate 'line', 997
    set_addr $I10, alt1948_1
    rx1946_cur."!mark_push"(0, rx1946_pos, $I10)
.annotate 'line', 998
  # rx subrule "EXPR" subtype=capture negate=
    rx1946_cur."!cursor_pos"(rx1946_pos)
    $P10 = rx1946_cur."EXPR"("f=")
    unless $P10, rx1946_fail
    rx1946_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1946_pos = $P10."pos"()
    goto alt1948_end
  alt1948_1:
  alt1948_end:
.annotate 'line', 995
  # rx pass
    rx1946_cur."!cursor_pass"(rx1946_pos, "arglist")
    if_null rx1946_debug, debug_1375
    rx1946_cur."!cursor_debug"("PASS", "arglist", " at pos=", rx1946_pos)
  debug_1375:
    .return (rx1946_cur)
  rx1946_restart:
.annotate 'line', 435
    if_null rx1946_debug, debug_1376
    rx1946_cur."!cursor_debug"("NEXT", "arglist")
  debug_1376:
  rx1946_fail:
    (rx1946_rep, rx1946_pos, $I10, $P10) = rx1946_cur."!mark_fail"(0)
    lt rx1946_pos, -1, rx1946_done
    eq rx1946_pos, -1, rx1946_fail
    jump $I10
  rx1946_done:
    rx1946_cur."!cursor_fail"()
    if_null rx1946_debug, debug_1377
    rx1946_cur."!cursor_debug"("FAIL", "arglist")
  debug_1377:
    .return (rx1946_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__arglist"  :subid("266_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("ws", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<value>"  :subid("267_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1951_tgt
    .local int rx1951_pos
    .local int rx1951_off
    .local int rx1951_eos
    .local int rx1951_rep
    .local pmc rx1951_cur
    .local pmc rx1951_debug
    (rx1951_cur, rx1951_pos, rx1951_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1951_cur
    .local pmc match
    .lex "$/", match
    length rx1951_eos, rx1951_tgt
    gt rx1951_pos, rx1951_eos, rx1951_done
    set rx1951_off, 0
    lt rx1951_pos, 2, rx1951_start
    sub rx1951_off, rx1951_pos, 1
    substr rx1951_tgt, rx1951_tgt, rx1951_off
  rx1951_start:
    eq $I10, 1, rx1951_restart
    if_null rx1951_debug, debug_1378
    rx1951_cur."!cursor_debug"("START", "term:sym<value>")
  debug_1378:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1952_done
    goto rxscan1952_scan
  rxscan1952_loop:
    (rx1951_pos) = rx1951_cur."from"()
    inc rx1951_pos
    rx1951_cur."!cursor_from"(rx1951_pos)
    ge rx1951_pos, rx1951_eos, rxscan1952_done
  rxscan1952_scan:
    set_addr $I10, rxscan1952_loop
    rx1951_cur."!mark_push"(0, rx1951_pos, $I10)
  rxscan1952_done:
.annotate 'line', 1004
  # rx subrule "value" subtype=capture negate=
    rx1951_cur."!cursor_pos"(rx1951_pos)
    $P10 = rx1951_cur."value"()
    unless $P10, rx1951_fail
    rx1951_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("value")
    rx1951_pos = $P10."pos"()
  # rx pass
    rx1951_cur."!cursor_pass"(rx1951_pos, "term:sym<value>")
    if_null rx1951_debug, debug_1379
    rx1951_cur."!cursor_debug"("PASS", "term:sym<value>", " at pos=", rx1951_pos)
  debug_1379:
    .return (rx1951_cur)
  rx1951_restart:
.annotate 'line', 435
    if_null rx1951_debug, debug_1380
    rx1951_cur."!cursor_debug"("NEXT", "term:sym<value>")
  debug_1380:
  rx1951_fail:
    (rx1951_rep, rx1951_pos, $I10, $P10) = rx1951_cur."!mark_fail"(0)
    lt rx1951_pos, -1, rx1951_done
    eq rx1951_pos, -1, rx1951_fail
    jump $I10
  rx1951_done:
    rx1951_cur."!cursor_fail"()
    if_null rx1951_debug, debug_1381
    rx1951_cur."!cursor_debug"("FAIL", "term:sym<value>")
  debug_1381:
    .return (rx1951_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<value>"  :subid("268_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("value", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "value"  :subid("269_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1955_tgt
    .local int rx1955_pos
    .local int rx1955_off
    .local int rx1955_eos
    .local int rx1955_rep
    .local pmc rx1955_cur
    .local pmc rx1955_debug
    (rx1955_cur, rx1955_pos, rx1955_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1955_cur
    .local pmc match
    .lex "$/", match
    length rx1955_eos, rx1955_tgt
    gt rx1955_pos, rx1955_eos, rx1955_done
    set rx1955_off, 0
    lt rx1955_pos, 2, rx1955_start
    sub rx1955_off, rx1955_pos, 1
    substr rx1955_tgt, rx1955_tgt, rx1955_off
  rx1955_start:
    eq $I10, 1, rx1955_restart
    if_null rx1955_debug, debug_1382
    rx1955_cur."!cursor_debug"("START", "value")
  debug_1382:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1956_done
    goto rxscan1956_scan
  rxscan1956_loop:
    (rx1955_pos) = rx1955_cur."from"()
    inc rx1955_pos
    rx1955_cur."!cursor_from"(rx1955_pos)
    ge rx1955_pos, rx1955_eos, rxscan1956_done
  rxscan1956_scan:
    set_addr $I10, rxscan1956_loop
    rx1955_cur."!mark_push"(0, rx1955_pos, $I10)
  rxscan1956_done:
  alt1957_0:
.annotate 'line', 1006
    set_addr $I10, alt1957_1
    rx1955_cur."!mark_push"(0, rx1955_pos, $I10)
.annotate 'line', 1007
  # rx subrule "quote" subtype=capture negate=
    rx1955_cur."!cursor_pos"(rx1955_pos)
    $P10 = rx1955_cur."quote"()
    unless $P10, rx1955_fail
    rx1955_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1955_pos = $P10."pos"()
    goto alt1957_end
  alt1957_1:
.annotate 'line', 1008
  # rx subrule "number" subtype=capture negate=
    rx1955_cur."!cursor_pos"(rx1955_pos)
    $P10 = rx1955_cur."number"()
    unless $P10, rx1955_fail
    rx1955_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("number")
    rx1955_pos = $P10."pos"()
  alt1957_end:
.annotate 'line', 1006
  # rx pass
    rx1955_cur."!cursor_pass"(rx1955_pos, "value")
    if_null rx1955_debug, debug_1383
    rx1955_cur."!cursor_debug"("PASS", "value", " at pos=", rx1955_pos)
  debug_1383:
    .return (rx1955_cur)
  rx1955_restart:
.annotate 'line', 435
    if_null rx1955_debug, debug_1384
    rx1955_cur."!cursor_debug"("NEXT", "value")
  debug_1384:
  rx1955_fail:
    (rx1955_rep, rx1955_pos, $I10, $P10) = rx1955_cur."!mark_fail"(0)
    lt rx1955_pos, -1, rx1955_done
    eq rx1955_pos, -1, rx1955_fail
    jump $I10
  rx1955_done:
    rx1955_cur."!cursor_fail"()
    if_null rx1955_debug, debug_1385
    rx1955_cur."!cursor_debug"("FAIL", "value")
  debug_1385:
    .return (rx1955_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__value"  :subid("270_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("number", "")
    $P104 = self."!PREFIX__!subrule"("quote", "")
    new $P105, "ResizablePMCArray"
    push $P105, $P103
    push $P105, $P104
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "number"  :subid("271_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1960_tgt
    .local int rx1960_pos
    .local int rx1960_off
    .local int rx1960_eos
    .local int rx1960_rep
    .local pmc rx1960_cur
    .local pmc rx1960_debug
    (rx1960_cur, rx1960_pos, rx1960_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1960_cur
    .local pmc match
    .lex "$/", match
    length rx1960_eos, rx1960_tgt
    gt rx1960_pos, rx1960_eos, rx1960_done
    set rx1960_off, 0
    lt rx1960_pos, 2, rx1960_start
    sub rx1960_off, rx1960_pos, 1
    substr rx1960_tgt, rx1960_tgt, rx1960_off
  rx1960_start:
    eq $I10, 1, rx1960_restart
    if_null rx1960_debug, debug_1386
    rx1960_cur."!cursor_debug"("START", "number")
  debug_1386:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1961_done
    goto rxscan1961_scan
  rxscan1961_loop:
    (rx1960_pos) = rx1960_cur."from"()
    inc rx1960_pos
    rx1960_cur."!cursor_from"(rx1960_pos)
    ge rx1960_pos, rx1960_eos, rxscan1961_done
  rxscan1961_scan:
    set_addr $I10, rxscan1961_loop
    rx1960_cur."!mark_push"(0, rx1960_pos, $I10)
  rxscan1961_done:
.annotate 'line', 1012
  # rx subcapture "sign"
    set_addr $I10, rxcap_1963_fail
    rx1960_cur."!mark_push"(0, rx1960_pos, $I10)
  # rx enumcharlist_q negate=0  r 0..1
    sub $I10, rx1960_pos, rx1960_off
    set rx1960_rep, 0
    sub $I12, rx1960_eos, rx1960_pos
    le $I12, 1, rxenumcharlistq1962_loop
    set $I12, 1
  rxenumcharlistq1962_loop:
    le $I12, 0, rxenumcharlistq1962_done
    substr $S10, rx1960_tgt, $I10, 1
    index $I11, "+-", $S10
    lt $I11, 0, rxenumcharlistq1962_done
    inc rx1960_rep
  rxenumcharlistq1962_done:
    add rx1960_pos, rx1960_pos, rx1960_rep
    set_addr $I10, rxcap_1963_fail
    ($I12, $I11) = rx1960_cur."!mark_peek"($I10)
    rx1960_cur."!cursor_pos"($I11)
    ($P10) = rx1960_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1960_pos, "")
    rx1960_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sign")
    goto rxcap_1963_done
  rxcap_1963_fail:
    goto rx1960_fail
  rxcap_1963_done:
  alt1964_0:
.annotate 'line', 1013
    set_addr $I10, alt1964_1
    rx1960_cur."!mark_push"(0, rx1960_pos, $I10)
  # rx subrule "dec_number" subtype=capture negate=
    rx1960_cur."!cursor_pos"(rx1960_pos)
    $P10 = rx1960_cur."dec_number"()
    unless $P10, rx1960_fail
    rx1960_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dec_number")
    rx1960_pos = $P10."pos"()
    goto alt1964_end
  alt1964_1:
  # rx subrule "integer" subtype=capture negate=
    rx1960_cur."!cursor_pos"(rx1960_pos)
    $P10 = rx1960_cur."integer"()
    unless $P10, rx1960_fail
    rx1960_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("integer")
    rx1960_pos = $P10."pos"()
  alt1964_end:
.annotate 'line', 1011
  # rx pass
    rx1960_cur."!cursor_pass"(rx1960_pos, "number")
    if_null rx1960_debug, debug_1387
    rx1960_cur."!cursor_debug"("PASS", "number", " at pos=", rx1960_pos)
  debug_1387:
    .return (rx1960_cur)
  rx1960_restart:
.annotate 'line', 435
    if_null rx1960_debug, debug_1388
    rx1960_cur."!cursor_debug"("NEXT", "number")
  debug_1388:
  rx1960_fail:
    (rx1960_rep, rx1960_pos, $I10, $P10) = rx1960_cur."!mark_fail"(0)
    lt rx1960_pos, -1, rx1960_done
    eq rx1960_pos, -1, rx1960_fail
    jump $I10
  rx1960_done:
    rx1960_cur."!cursor_fail"()
    if_null rx1960_debug, debug_1389
    rx1960_cur."!cursor_debug"("FAIL", "number")
  debug_1389:
    .return (rx1960_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__number"  :subid("272_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote"  :subid("273_1310110678.31883")
    .param pmc param_1967
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1016
    .lex "self", param_1967
    $P103 = param_1967."!protoregex"("quote")
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote"  :subid("274_1310110678.31883")
    .param pmc param_1969
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1016
    .lex "self", param_1969
    $P104 = param_1969."!PREFIX__!protoregex"("quote")
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<apos>"  :subid("275_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1971_tgt
    .local int rx1971_pos
    .local int rx1971_off
    .local int rx1971_eos
    .local int rx1971_rep
    .local pmc rx1971_cur
    .local pmc rx1971_debug
    (rx1971_cur, rx1971_pos, rx1971_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1971_cur
    .local pmc match
    .lex "$/", match
    length rx1971_eos, rx1971_tgt
    gt rx1971_pos, rx1971_eos, rx1971_done
    set rx1971_off, 0
    lt rx1971_pos, 2, rx1971_start
    sub rx1971_off, rx1971_pos, 1
    substr rx1971_tgt, rx1971_tgt, rx1971_off
  rx1971_start:
    eq $I10, 1, rx1971_restart
    if_null rx1971_debug, debug_1390
    rx1971_cur."!cursor_debug"("START", "quote:sym<apos>")
  debug_1390:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1972_done
    goto rxscan1972_scan
  rxscan1972_loop:
    (rx1971_pos) = rx1971_cur."from"()
    inc rx1971_pos
    rx1971_cur."!cursor_from"(rx1971_pos)
    ge rx1971_pos, rx1971_eos, rxscan1972_done
  rxscan1972_scan:
    set_addr $I10, rxscan1972_loop
    rx1971_cur."!mark_push"(0, rx1971_pos, $I10)
  rxscan1972_done:
.annotate 'line', 1017
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1971_pos, rx1971_off
    substr $S10, rx1971_tgt, $I10, 1
    index $I11, "'", $S10
    lt $I11, 0, rx1971_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1971_cur."!cursor_pos"(rx1971_pos)
    $P10 = rx1971_cur."quote_EXPR"(":q")
    unless $P10, rx1971_fail
    rx1971_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1971_pos = $P10."pos"()
  # rx pass
    rx1971_cur."!cursor_pass"(rx1971_pos, "quote:sym<apos>")
    if_null rx1971_debug, debug_1391
    rx1971_cur."!cursor_debug"("PASS", "quote:sym<apos>", " at pos=", rx1971_pos)
  debug_1391:
    .return (rx1971_cur)
  rx1971_restart:
.annotate 'line', 435
    if_null rx1971_debug, debug_1392
    rx1971_cur."!cursor_debug"("NEXT", "quote:sym<apos>")
  debug_1392:
  rx1971_fail:
    (rx1971_rep, rx1971_pos, $I10, $P10) = rx1971_cur."!mark_fail"(0)
    lt rx1971_pos, -1, rx1971_done
    eq rx1971_pos, -1, rx1971_fail
    jump $I10
  rx1971_done:
    rx1971_cur."!cursor_fail"()
    if_null rx1971_debug, debug_1393
    rx1971_cur."!cursor_debug"("FAIL", "quote:sym<apos>")
  debug_1393:
    .return (rx1971_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<apos>"  :subid("276_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    new $P103, "ResizablePMCArray"
    push $P103, "'"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<dblq>"  :subid("277_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1975_tgt
    .local int rx1975_pos
    .local int rx1975_off
    .local int rx1975_eos
    .local int rx1975_rep
    .local pmc rx1975_cur
    .local pmc rx1975_debug
    (rx1975_cur, rx1975_pos, rx1975_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1975_cur
    .local pmc match
    .lex "$/", match
    length rx1975_eos, rx1975_tgt
    gt rx1975_pos, rx1975_eos, rx1975_done
    set rx1975_off, 0
    lt rx1975_pos, 2, rx1975_start
    sub rx1975_off, rx1975_pos, 1
    substr rx1975_tgt, rx1975_tgt, rx1975_off
  rx1975_start:
    eq $I10, 1, rx1975_restart
    if_null rx1975_debug, debug_1394
    rx1975_cur."!cursor_debug"("START", "quote:sym<dblq>")
  debug_1394:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1976_done
    goto rxscan1976_scan
  rxscan1976_loop:
    (rx1975_pos) = rx1975_cur."from"()
    inc rx1975_pos
    rx1975_cur."!cursor_from"(rx1975_pos)
    ge rx1975_pos, rx1975_eos, rxscan1976_done
  rxscan1976_scan:
    set_addr $I10, rxscan1976_loop
    rx1975_cur."!mark_push"(0, rx1975_pos, $I10)
  rxscan1976_done:
.annotate 'line', 1018
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1975_pos, rx1975_off
    substr $S10, rx1975_tgt, $I10, 1
    index $I11, "\"", $S10
    lt $I11, 0, rx1975_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1975_cur."!cursor_pos"(rx1975_pos)
    $P10 = rx1975_cur."quote_EXPR"(":qq")
    unless $P10, rx1975_fail
    rx1975_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1975_pos = $P10."pos"()
  # rx pass
    rx1975_cur."!cursor_pass"(rx1975_pos, "quote:sym<dblq>")
    if_null rx1975_debug, debug_1395
    rx1975_cur."!cursor_debug"("PASS", "quote:sym<dblq>", " at pos=", rx1975_pos)
  debug_1395:
    .return (rx1975_cur)
  rx1975_restart:
.annotate 'line', 435
    if_null rx1975_debug, debug_1396
    rx1975_cur."!cursor_debug"("NEXT", "quote:sym<dblq>")
  debug_1396:
  rx1975_fail:
    (rx1975_rep, rx1975_pos, $I10, $P10) = rx1975_cur."!mark_fail"(0)
    lt rx1975_pos, -1, rx1975_done
    eq rx1975_pos, -1, rx1975_fail
    jump $I10
  rx1975_done:
    rx1975_cur."!cursor_fail"()
    if_null rx1975_debug, debug_1397
    rx1975_cur."!cursor_debug"("FAIL", "quote:sym<dblq>")
  debug_1397:
    .return (rx1975_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<dblq>"  :subid("278_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    new $P103, "ResizablePMCArray"
    push $P103, "\""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<q>"  :subid("279_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1979_tgt
    .local int rx1979_pos
    .local int rx1979_off
    .local int rx1979_eos
    .local int rx1979_rep
    .local pmc rx1979_cur
    .local pmc rx1979_debug
    (rx1979_cur, rx1979_pos, rx1979_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1979_cur
    .local pmc match
    .lex "$/", match
    length rx1979_eos, rx1979_tgt
    gt rx1979_pos, rx1979_eos, rx1979_done
    set rx1979_off, 0
    lt rx1979_pos, 2, rx1979_start
    sub rx1979_off, rx1979_pos, 1
    substr rx1979_tgt, rx1979_tgt, rx1979_off
  rx1979_start:
    eq $I10, 1, rx1979_restart
    if_null rx1979_debug, debug_1398
    rx1979_cur."!cursor_debug"("START", "quote:sym<q>")
  debug_1398:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1980_done
    goto rxscan1980_scan
  rxscan1980_loop:
    (rx1979_pos) = rx1979_cur."from"()
    inc rx1979_pos
    rx1979_cur."!cursor_from"(rx1979_pos)
    ge rx1979_pos, rx1979_eos, rxscan1980_done
  rxscan1980_scan:
    set_addr $I10, rxscan1980_loop
    rx1979_cur."!mark_push"(0, rx1979_pos, $I10)
  rxscan1980_done:
.annotate 'line', 1019
  # rx subcapture "sym"
    set_addr $I10, rxcap_1981_fail
    rx1979_cur."!mark_push"(0, rx1979_pos, $I10)
  # rx literal  "q"
    add $I11, rx1979_pos, 1
    gt $I11, rx1979_eos, rx1979_fail
    sub $I11, rx1979_pos, rx1979_off
    ord $I11, rx1979_tgt, $I11
    ne $I11, 113, rx1979_fail
    add rx1979_pos, 1
    set_addr $I10, rxcap_1981_fail
    ($I12, $I11) = rx1979_cur."!mark_peek"($I10)
    rx1979_cur."!cursor_pos"($I11)
    ($P10) = rx1979_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1979_pos, "")
    rx1979_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1981_done
  rxcap_1981_fail:
    goto rx1979_fail
  rxcap_1981_done:
  # rxanchor rwb
    le rx1979_pos, 0, rx1979_fail
    sub $I10, rx1979_pos, rx1979_off
    is_cclass $I11, .CCLASS_WORD, rx1979_tgt, $I10
    if $I11, rx1979_fail
    dec $I10
    is_cclass $I11, .CCLASS_WORD, rx1979_tgt, $I10
    unless $I11, rx1979_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1979_pos, rx1979_off
    substr $S10, rx1979_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1979_fail
  # rx subrule "ws" subtype=method negate=
    rx1979_cur."!cursor_pos"(rx1979_pos)
    $P10 = rx1979_cur."ws"()
    unless $P10, rx1979_fail
    rx1979_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1979_cur."!cursor_pos"(rx1979_pos)
    $P10 = rx1979_cur."quote_EXPR"(":q")
    unless $P10, rx1979_fail
    rx1979_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1979_pos = $P10."pos"()
  # rx pass
    rx1979_cur."!cursor_pass"(rx1979_pos, "quote:sym<q>")
    if_null rx1979_debug, debug_1399
    rx1979_cur."!cursor_debug"("PASS", "quote:sym<q>", " at pos=", rx1979_pos)
  debug_1399:
    .return (rx1979_cur)
  rx1979_restart:
.annotate 'line', 435
    if_null rx1979_debug, debug_1400
    rx1979_cur."!cursor_debug"("NEXT", "quote:sym<q>")
  debug_1400:
  rx1979_fail:
    (rx1979_rep, rx1979_pos, $I10, $P10) = rx1979_cur."!mark_fail"(0)
    lt rx1979_pos, -1, rx1979_done
    eq rx1979_pos, -1, rx1979_fail
    jump $I10
  rx1979_done:
    rx1979_cur."!cursor_fail"()
    if_null rx1979_debug, debug_1401
    rx1979_cur."!cursor_debug"("FAIL", "quote:sym<q>")
  debug_1401:
    .return (rx1979_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<q>"  :subid("280_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("ws", "q")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<qq>"  :subid("281_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1984_tgt
    .local int rx1984_pos
    .local int rx1984_off
    .local int rx1984_eos
    .local int rx1984_rep
    .local pmc rx1984_cur
    .local pmc rx1984_debug
    (rx1984_cur, rx1984_pos, rx1984_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1984_cur
    .local pmc match
    .lex "$/", match
    length rx1984_eos, rx1984_tgt
    gt rx1984_pos, rx1984_eos, rx1984_done
    set rx1984_off, 0
    lt rx1984_pos, 2, rx1984_start
    sub rx1984_off, rx1984_pos, 1
    substr rx1984_tgt, rx1984_tgt, rx1984_off
  rx1984_start:
    eq $I10, 1, rx1984_restart
    if_null rx1984_debug, debug_1402
    rx1984_cur."!cursor_debug"("START", "quote:sym<qq>")
  debug_1402:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1985_done
    goto rxscan1985_scan
  rxscan1985_loop:
    (rx1984_pos) = rx1984_cur."from"()
    inc rx1984_pos
    rx1984_cur."!cursor_from"(rx1984_pos)
    ge rx1984_pos, rx1984_eos, rxscan1985_done
  rxscan1985_scan:
    set_addr $I10, rxscan1985_loop
    rx1984_cur."!mark_push"(0, rx1984_pos, $I10)
  rxscan1985_done:
.annotate 'line', 1020
  # rx subcapture "sym"
    set_addr $I10, rxcap_1986_fail
    rx1984_cur."!mark_push"(0, rx1984_pos, $I10)
  # rx literal  "qq"
    add $I11, rx1984_pos, 2
    gt $I11, rx1984_eos, rx1984_fail
    sub $I11, rx1984_pos, rx1984_off
    substr $S10, rx1984_tgt, $I11, 2
    ne $S10, "qq", rx1984_fail
    add rx1984_pos, 2
    set_addr $I10, rxcap_1986_fail
    ($I12, $I11) = rx1984_cur."!mark_peek"($I10)
    rx1984_cur."!cursor_pos"($I11)
    ($P10) = rx1984_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1984_pos, "")
    rx1984_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1986_done
  rxcap_1986_fail:
    goto rx1984_fail
  rxcap_1986_done:
  # rxanchor rwb
    le rx1984_pos, 0, rx1984_fail
    sub $I10, rx1984_pos, rx1984_off
    is_cclass $I11, .CCLASS_WORD, rx1984_tgt, $I10
    if $I11, rx1984_fail
    dec $I10
    is_cclass $I11, .CCLASS_WORD, rx1984_tgt, $I10
    unless $I11, rx1984_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1984_pos, rx1984_off
    substr $S10, rx1984_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1984_fail
  # rx subrule "ws" subtype=method negate=
    rx1984_cur."!cursor_pos"(rx1984_pos)
    $P10 = rx1984_cur."ws"()
    unless $P10, rx1984_fail
    rx1984_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1984_cur."!cursor_pos"(rx1984_pos)
    $P10 = rx1984_cur."quote_EXPR"(":qq")
    unless $P10, rx1984_fail
    rx1984_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1984_pos = $P10."pos"()
  # rx pass
    rx1984_cur."!cursor_pass"(rx1984_pos, "quote:sym<qq>")
    if_null rx1984_debug, debug_1403
    rx1984_cur."!cursor_debug"("PASS", "quote:sym<qq>", " at pos=", rx1984_pos)
  debug_1403:
    .return (rx1984_cur)
  rx1984_restart:
.annotate 'line', 435
    if_null rx1984_debug, debug_1404
    rx1984_cur."!cursor_debug"("NEXT", "quote:sym<qq>")
  debug_1404:
  rx1984_fail:
    (rx1984_rep, rx1984_pos, $I10, $P10) = rx1984_cur."!mark_fail"(0)
    lt rx1984_pos, -1, rx1984_done
    eq rx1984_pos, -1, rx1984_fail
    jump $I10
  rx1984_done:
    rx1984_cur."!cursor_fail"()
    if_null rx1984_debug, debug_1405
    rx1984_cur."!cursor_debug"("FAIL", "quote:sym<qq>")
  debug_1405:
    .return (rx1984_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<qq>"  :subid("282_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("ws", "qq")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q>"  :subid("283_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1989_tgt
    .local int rx1989_pos
    .local int rx1989_off
    .local int rx1989_eos
    .local int rx1989_rep
    .local pmc rx1989_cur
    .local pmc rx1989_debug
    (rx1989_cur, rx1989_pos, rx1989_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1989_cur
    .local pmc match
    .lex "$/", match
    length rx1989_eos, rx1989_tgt
    gt rx1989_pos, rx1989_eos, rx1989_done
    set rx1989_off, 0
    lt rx1989_pos, 2, rx1989_start
    sub rx1989_off, rx1989_pos, 1
    substr rx1989_tgt, rx1989_tgt, rx1989_off
  rx1989_start:
    eq $I10, 1, rx1989_restart
    if_null rx1989_debug, debug_1406
    rx1989_cur."!cursor_debug"("START", "quote:sym<Q>")
  debug_1406:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1990_done
    goto rxscan1990_scan
  rxscan1990_loop:
    (rx1989_pos) = rx1989_cur."from"()
    inc rx1989_pos
    rx1989_cur."!cursor_from"(rx1989_pos)
    ge rx1989_pos, rx1989_eos, rxscan1990_done
  rxscan1990_scan:
    set_addr $I10, rxscan1990_loop
    rx1989_cur."!mark_push"(0, rx1989_pos, $I10)
  rxscan1990_done:
.annotate 'line', 1021
  # rx subcapture "sym"
    set_addr $I10, rxcap_1991_fail
    rx1989_cur."!mark_push"(0, rx1989_pos, $I10)
  # rx literal  "Q"
    add $I11, rx1989_pos, 1
    gt $I11, rx1989_eos, rx1989_fail
    sub $I11, rx1989_pos, rx1989_off
    ord $I11, rx1989_tgt, $I11
    ne $I11, 81, rx1989_fail
    add rx1989_pos, 1
    set_addr $I10, rxcap_1991_fail
    ($I12, $I11) = rx1989_cur."!mark_peek"($I10)
    rx1989_cur."!cursor_pos"($I11)
    ($P10) = rx1989_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1989_pos, "")
    rx1989_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1991_done
  rxcap_1991_fail:
    goto rx1989_fail
  rxcap_1991_done:
  # rxanchor rwb
    le rx1989_pos, 0, rx1989_fail
    sub $I10, rx1989_pos, rx1989_off
    is_cclass $I11, .CCLASS_WORD, rx1989_tgt, $I10
    if $I11, rx1989_fail
    dec $I10
    is_cclass $I11, .CCLASS_WORD, rx1989_tgt, $I10
    unless $I11, rx1989_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1989_pos, rx1989_off
    substr $S10, rx1989_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1989_fail
  # rx subrule "ws" subtype=method negate=
    rx1989_cur."!cursor_pos"(rx1989_pos)
    $P10 = rx1989_cur."ws"()
    unless $P10, rx1989_fail
    rx1989_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1989_cur."!cursor_pos"(rx1989_pos)
    $P10 = rx1989_cur."quote_EXPR"()
    unless $P10, rx1989_fail
    rx1989_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1989_pos = $P10."pos"()
  # rx pass
    rx1989_cur."!cursor_pass"(rx1989_pos, "quote:sym<Q>")
    if_null rx1989_debug, debug_1407
    rx1989_cur."!cursor_debug"("PASS", "quote:sym<Q>", " at pos=", rx1989_pos)
  debug_1407:
    .return (rx1989_cur)
  rx1989_restart:
.annotate 'line', 435
    if_null rx1989_debug, debug_1408
    rx1989_cur."!cursor_debug"("NEXT", "quote:sym<Q>")
  debug_1408:
  rx1989_fail:
    (rx1989_rep, rx1989_pos, $I10, $P10) = rx1989_cur."!mark_fail"(0)
    lt rx1989_pos, -1, rx1989_done
    eq rx1989_pos, -1, rx1989_fail
    jump $I10
  rx1989_done:
    rx1989_cur."!cursor_fail"()
    if_null rx1989_debug, debug_1409
    rx1989_cur."!cursor_debug"("FAIL", "quote:sym<Q>")
  debug_1409:
    .return (rx1989_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q>"  :subid("284_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("ws", "Q")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q:PIR>"  :subid("285_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1994_tgt
    .local int rx1994_pos
    .local int rx1994_off
    .local int rx1994_eos
    .local int rx1994_rep
    .local pmc rx1994_cur
    .local pmc rx1994_debug
    (rx1994_cur, rx1994_pos, rx1994_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1994_cur
    .local pmc match
    .lex "$/", match
    length rx1994_eos, rx1994_tgt
    gt rx1994_pos, rx1994_eos, rx1994_done
    set rx1994_off, 0
    lt rx1994_pos, 2, rx1994_start
    sub rx1994_off, rx1994_pos, 1
    substr rx1994_tgt, rx1994_tgt, rx1994_off
  rx1994_start:
    eq $I10, 1, rx1994_restart
    if_null rx1994_debug, debug_1410
    rx1994_cur."!cursor_debug"("START", "quote:sym<Q:PIR>")
  debug_1410:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1995_done
    goto rxscan1995_scan
  rxscan1995_loop:
    (rx1994_pos) = rx1994_cur."from"()
    inc rx1994_pos
    rx1994_cur."!cursor_from"(rx1994_pos)
    ge rx1994_pos, rx1994_eos, rxscan1995_done
  rxscan1995_scan:
    set_addr $I10, rxscan1995_loop
    rx1994_cur."!mark_push"(0, rx1994_pos, $I10)
  rxscan1995_done:
.annotate 'line', 1022
  # rx subcapture "sym"
    set_addr $I10, rxcap_1996_fail
    rx1994_cur."!mark_push"(0, rx1994_pos, $I10)
  # rx literal  "Q:PIR"
    add $I11, rx1994_pos, 5
    gt $I11, rx1994_eos, rx1994_fail
    sub $I11, rx1994_pos, rx1994_off
    substr $S10, rx1994_tgt, $I11, 5
    ne $S10, "Q:PIR", rx1994_fail
    add rx1994_pos, 5
    set_addr $I10, rxcap_1996_fail
    ($I12, $I11) = rx1994_cur."!mark_peek"($I10)
    rx1994_cur."!cursor_pos"($I11)
    ($P10) = rx1994_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1994_pos, "")
    rx1994_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1996_done
  rxcap_1996_fail:
    goto rx1994_fail
  rxcap_1996_done:
  # rx subrule "ws" subtype=method negate=
    rx1994_cur."!cursor_pos"(rx1994_pos)
    $P10 = rx1994_cur."ws"()
    unless $P10, rx1994_fail
    rx1994_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1994_cur."!cursor_pos"(rx1994_pos)
    $P10 = rx1994_cur."quote_EXPR"()
    unless $P10, rx1994_fail
    rx1994_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1994_pos = $P10."pos"()
  # rx pass
    rx1994_cur."!cursor_pass"(rx1994_pos, "quote:sym<Q:PIR>")
    if_null rx1994_debug, debug_1411
    rx1994_cur."!cursor_debug"("PASS", "quote:sym<Q:PIR>", " at pos=", rx1994_pos)
  debug_1411:
    .return (rx1994_cur)
  rx1994_restart:
.annotate 'line', 435
    if_null rx1994_debug, debug_1412
    rx1994_cur."!cursor_debug"("NEXT", "quote:sym<Q:PIR>")
  debug_1412:
  rx1994_fail:
    (rx1994_rep, rx1994_pos, $I10, $P10) = rx1994_cur."!mark_fail"(0)
    lt rx1994_pos, -1, rx1994_done
    eq rx1994_pos, -1, rx1994_fail
    jump $I10
  rx1994_done:
    rx1994_cur."!cursor_fail"()
    if_null rx1994_debug, debug_1413
    rx1994_cur."!cursor_debug"("FAIL", "quote:sym<Q:PIR>")
  debug_1413:
    .return (rx1994_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q:PIR>"  :subid("286_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("ws", "Q:PIR")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym</ />"  :subid("287_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx1999_tgt
    .local int rx1999_pos
    .local int rx1999_off
    .local int rx1999_eos
    .local int rx1999_rep
    .local pmc rx1999_cur
    .local pmc rx1999_debug
    (rx1999_cur, rx1999_pos, rx1999_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1999_cur
    .local pmc match
    .lex "$/", match
    length rx1999_eos, rx1999_tgt
    gt rx1999_pos, rx1999_eos, rx1999_done
    set rx1999_off, 0
    lt rx1999_pos, 2, rx1999_start
    sub rx1999_off, rx1999_pos, 1
    substr rx1999_tgt, rx1999_tgt, rx1999_off
  rx1999_start:
    eq $I10, 1, rx1999_restart
    if_null rx1999_debug, debug_1414
    rx1999_cur."!cursor_debug"("START", "quote:sym</ />")
  debug_1414:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2000_done
    goto rxscan2000_scan
  rxscan2000_loop:
    (rx1999_pos) = rx1999_cur."from"()
    inc rx1999_pos
    rx1999_cur."!cursor_from"(rx1999_pos)
    ge rx1999_pos, rx1999_eos, rxscan2000_done
  rxscan2000_scan:
    set_addr $I10, rxscan2000_loop
    rx1999_cur."!mark_push"(0, rx1999_pos, $I10)
  rxscan2000_done:
.annotate 'line', 1024
  # rx literal  "/"
    add $I11, rx1999_pos, 1
    gt $I11, rx1999_eos, rx1999_fail
    sub $I11, rx1999_pos, rx1999_off
    ord $I11, rx1999_tgt, $I11
    ne $I11, 47, rx1999_fail
    add rx1999_pos, 1
.annotate 'line', 1025
  # rx subrule "newpad" subtype=method negate=
    rx1999_cur."!cursor_pos"(rx1999_pos)
    $P10 = rx1999_cur."newpad"()
    unless $P10, rx1999_fail
    rx1999_pos = $P10."pos"()
.annotate 'line', 1026
  # rx reduce name="quote:sym</ />" key="open"
    rx1999_cur."!cursor_pos"(rx1999_pos)
    rx1999_cur."!reduce"("quote:sym</ />", "open")
.annotate 'line', 1027
  # rx subrule "LANG" subtype=capture negate=
    rx1999_cur."!cursor_pos"(rx1999_pos)
    $P10 = rx1999_cur."LANG"("Regex", "nibbler")
    unless $P10, rx1999_fail
    rx1999_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx1999_pos = $P10."pos"()
.annotate 'line', 1028
  # rx literal  "/"
    add $I11, rx1999_pos, 1
    gt $I11, rx1999_eos, rx1999_fail
    sub $I11, rx1999_pos, rx1999_off
    ord $I11, rx1999_tgt, $I11
    ne $I11, 47, rx1999_fail
    add rx1999_pos, 1
.annotate 'line', 1023
  # rx pass
    rx1999_cur."!cursor_pass"(rx1999_pos, "quote:sym</ />")
    if_null rx1999_debug, debug_1415
    rx1999_cur."!cursor_debug"("PASS", "quote:sym</ />", " at pos=", rx1999_pos)
  debug_1415:
    .return (rx1999_cur)
  rx1999_restart:
.annotate 'line', 435
    if_null rx1999_debug, debug_1416
    rx1999_cur."!cursor_debug"("NEXT", "quote:sym</ />")
  debug_1416:
  rx1999_fail:
    (rx1999_rep, rx1999_pos, $I10, $P10) = rx1999_cur."!mark_fail"(0)
    lt rx1999_pos, -1, rx1999_done
    eq rx1999_pos, -1, rx1999_fail
    jump $I10
  rx1999_done:
    rx1999_cur."!cursor_fail"()
    if_null rx1999_debug, debug_1417
    rx1999_cur."!cursor_debug"("FAIL", "quote:sym</ />")
  debug_1417:
    .return (rx1999_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym</ />"  :subid("288_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("newpad", "/")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<$>"  :subid("289_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2003_tgt
    .local int rx2003_pos
    .local int rx2003_off
    .local int rx2003_eos
    .local int rx2003_rep
    .local pmc rx2003_cur
    .local pmc rx2003_debug
    (rx2003_cur, rx2003_pos, rx2003_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2003_cur
    .local pmc match
    .lex "$/", match
    length rx2003_eos, rx2003_tgt
    gt rx2003_pos, rx2003_eos, rx2003_done
    set rx2003_off, 0
    lt rx2003_pos, 2, rx2003_start
    sub rx2003_off, rx2003_pos, 1
    substr rx2003_tgt, rx2003_tgt, rx2003_off
  rx2003_start:
    eq $I10, 1, rx2003_restart
    if_null rx2003_debug, debug_1418
    rx2003_cur."!cursor_debug"("START", "quote_escape:sym<$>")
  debug_1418:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2004_done
    goto rxscan2004_scan
  rxscan2004_loop:
    (rx2003_pos) = rx2003_cur."from"()
    inc rx2003_pos
    rx2003_cur."!cursor_from"(rx2003_pos)
    ge rx2003_pos, rx2003_eos, rxscan2004_done
  rxscan2004_scan:
    set_addr $I10, rxscan2004_loop
    rx2003_cur."!mark_push"(0, rx2003_pos, $I10)
  rxscan2004_done:
.annotate 'line', 1031
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2003_pos, rx2003_off
    substr $S10, rx2003_tgt, $I10, 1
    index $I11, "$", $S10
    lt $I11, 0, rx2003_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx2003_cur."!cursor_pos"(rx2003_pos)
    $P10 = rx2003_cur."quotemod_check"("s")
    unless $P10, rx2003_fail
  # rx subrule "variable" subtype=capture negate=
    rx2003_cur."!cursor_pos"(rx2003_pos)
    $P10 = rx2003_cur."variable"()
    unless $P10, rx2003_fail
    rx2003_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx2003_pos = $P10."pos"()
  # rx pass
    rx2003_cur."!cursor_pass"(rx2003_pos, "quote_escape:sym<$>")
    if_null rx2003_debug, debug_1419
    rx2003_cur."!cursor_debug"("PASS", "quote_escape:sym<$>", " at pos=", rx2003_pos)
  debug_1419:
    .return (rx2003_cur)
  rx2003_restart:
.annotate 'line', 435
    if_null rx2003_debug, debug_1420
    rx2003_cur."!cursor_debug"("NEXT", "quote_escape:sym<$>")
  debug_1420:
  rx2003_fail:
    (rx2003_rep, rx2003_pos, $I10, $P10) = rx2003_cur."!mark_fail"(0)
    lt rx2003_pos, -1, rx2003_done
    eq rx2003_pos, -1, rx2003_fail
    jump $I10
  rx2003_done:
    rx2003_cur."!cursor_fail"()
    if_null rx2003_debug, debug_1421
    rx2003_cur."!cursor_debug"("FAIL", "quote_escape:sym<$>")
  debug_1421:
    .return (rx2003_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<$>"  :subid("290_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    new $P103, "ResizablePMCArray"
    push $P103, "$"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<{ }>"  :subid("291_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2007_tgt
    .local int rx2007_pos
    .local int rx2007_off
    .local int rx2007_eos
    .local int rx2007_rep
    .local pmc rx2007_cur
    .local pmc rx2007_debug
    (rx2007_cur, rx2007_pos, rx2007_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2007_cur
    .local pmc match
    .lex "$/", match
    length rx2007_eos, rx2007_tgt
    gt rx2007_pos, rx2007_eos, rx2007_done
    set rx2007_off, 0
    lt rx2007_pos, 2, rx2007_start
    sub rx2007_off, rx2007_pos, 1
    substr rx2007_tgt, rx2007_tgt, rx2007_off
  rx2007_start:
    eq $I10, 1, rx2007_restart
    if_null rx2007_debug, debug_1422
    rx2007_cur."!cursor_debug"("START", "quote_escape:sym<{ }>")
  debug_1422:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2008_done
    goto rxscan2008_scan
  rxscan2008_loop:
    (rx2007_pos) = rx2007_cur."from"()
    inc rx2007_pos
    rx2007_cur."!cursor_from"(rx2007_pos)
    ge rx2007_pos, rx2007_eos, rxscan2008_done
  rxscan2008_scan:
    set_addr $I10, rxscan2008_loop
    rx2007_cur."!mark_push"(0, rx2007_pos, $I10)
  rxscan2008_done:
.annotate 'line', 1032
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2007_pos, rx2007_off
    substr $S10, rx2007_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2007_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx2007_cur."!cursor_pos"(rx2007_pos)
    $P10 = rx2007_cur."quotemod_check"("c")
    unless $P10, rx2007_fail
  # rx subrule "block" subtype=capture negate=
    rx2007_cur."!cursor_pos"(rx2007_pos)
    $P10 = rx2007_cur."block"()
    unless $P10, rx2007_fail
    rx2007_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx2007_pos = $P10."pos"()
  # rx pass
    rx2007_cur."!cursor_pass"(rx2007_pos, "quote_escape:sym<{ }>")
    if_null rx2007_debug, debug_1423
    rx2007_cur."!cursor_debug"("PASS", "quote_escape:sym<{ }>", " at pos=", rx2007_pos)
  debug_1423:
    .return (rx2007_cur)
  rx2007_restart:
.annotate 'line', 435
    if_null rx2007_debug, debug_1424
    rx2007_cur."!cursor_debug"("NEXT", "quote_escape:sym<{ }>")
  debug_1424:
  rx2007_fail:
    (rx2007_rep, rx2007_pos, $I10, $P10) = rx2007_cur."!mark_fail"(0)
    lt rx2007_pos, -1, rx2007_done
    eq rx2007_pos, -1, rx2007_fail
    jump $I10
  rx2007_done:
    rx2007_cur."!cursor_fail"()
    if_null rx2007_debug, debug_1425
    rx2007_cur."!cursor_debug"("FAIL", "quote_escape:sym<{ }>")
  debug_1425:
    .return (rx2007_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<{ }>"  :subid("292_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    new $P103, "ResizablePMCArray"
    push $P103, "{"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<esc>"  :subid("293_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2011_tgt
    .local int rx2011_pos
    .local int rx2011_off
    .local int rx2011_eos
    .local int rx2011_rep
    .local pmc rx2011_cur
    .local pmc rx2011_debug
    (rx2011_cur, rx2011_pos, rx2011_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2011_cur
    .local pmc match
    .lex "$/", match
    length rx2011_eos, rx2011_tgt
    gt rx2011_pos, rx2011_eos, rx2011_done
    set rx2011_off, 0
    lt rx2011_pos, 2, rx2011_start
    sub rx2011_off, rx2011_pos, 1
    substr rx2011_tgt, rx2011_tgt, rx2011_off
  rx2011_start:
    eq $I10, 1, rx2011_restart
    if_null rx2011_debug, debug_1426
    rx2011_cur."!cursor_debug"("START", "quote_escape:sym<esc>")
  debug_1426:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2012_done
    goto rxscan2012_scan
  rxscan2012_loop:
    (rx2011_pos) = rx2011_cur."from"()
    inc rx2011_pos
    rx2011_cur."!cursor_from"(rx2011_pos)
    ge rx2011_pos, rx2011_eos, rxscan2012_done
  rxscan2012_scan:
    set_addr $I10, rxscan2012_loop
    rx2011_cur."!mark_push"(0, rx2011_pos, $I10)
  rxscan2012_done:
.annotate 'line', 1033
  # rx literal  "\\e"
    add $I11, rx2011_pos, 2
    gt $I11, rx2011_eos, rx2011_fail
    sub $I11, rx2011_pos, rx2011_off
    substr $S10, rx2011_tgt, $I11, 2
    ne $S10, "\\e", rx2011_fail
    add rx2011_pos, 2
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx2011_cur."!cursor_pos"(rx2011_pos)
    $P10 = rx2011_cur."quotemod_check"("b")
    unless $P10, rx2011_fail
  # rx pass
    rx2011_cur."!cursor_pass"(rx2011_pos, "quote_escape:sym<esc>")
    if_null rx2011_debug, debug_1427
    rx2011_cur."!cursor_debug"("PASS", "quote_escape:sym<esc>", " at pos=", rx2011_pos)
  debug_1427:
    .return (rx2011_cur)
  rx2011_restart:
.annotate 'line', 435
    if_null rx2011_debug, debug_1428
    rx2011_cur."!cursor_debug"("NEXT", "quote_escape:sym<esc>")
  debug_1428:
  rx2011_fail:
    (rx2011_rep, rx2011_pos, $I10, $P10) = rx2011_cur."!mark_fail"(0)
    lt rx2011_pos, -1, rx2011_done
    eq rx2011_pos, -1, rx2011_fail
    jump $I10
  rx2011_done:
    rx2011_cur."!cursor_fail"()
    if_null rx2011_debug, debug_1429
    rx2011_cur."!cursor_debug"("FAIL", "quote_escape:sym<esc>")
  debug_1429:
    .return (rx2011_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<esc>"  :subid("294_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    new $P103, "ResizablePMCArray"
    push $P103, "\\e"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<( )>"  :subid("295_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2015_tgt
    .local int rx2015_pos
    .local int rx2015_off
    .local int rx2015_eos
    .local int rx2015_rep
    .local pmc rx2015_cur
    .local pmc rx2015_debug
    (rx2015_cur, rx2015_pos, rx2015_tgt, $I10) = self."!cursor_start"()
    rx2015_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx2015_cur
    .local pmc match
    .lex "$/", match
    length rx2015_eos, rx2015_tgt
    gt rx2015_pos, rx2015_eos, rx2015_done
    set rx2015_off, 0
    lt rx2015_pos, 2, rx2015_start
    sub rx2015_off, rx2015_pos, 1
    substr rx2015_tgt, rx2015_tgt, rx2015_off
  rx2015_start:
    eq $I10, 1, rx2015_restart
    if_null rx2015_debug, debug_1430
    rx2015_cur."!cursor_debug"("START", "circumfix:sym<( )>")
  debug_1430:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2016_done
    goto rxscan2016_scan
  rxscan2016_loop:
    (rx2015_pos) = rx2015_cur."from"()
    inc rx2015_pos
    rx2015_cur."!cursor_from"(rx2015_pos)
    ge rx2015_pos, rx2015_eos, rxscan2016_done
  rxscan2016_scan:
    set_addr $I10, rxscan2016_loop
    rx2015_cur."!mark_push"(0, rx2015_pos, $I10)
  rxscan2016_done:
.annotate 'line', 1035
  # rx literal  "("
    add $I11, rx2015_pos, 1
    gt $I11, rx2015_eos, rx2015_fail
    sub $I11, rx2015_pos, rx2015_off
    ord $I11, rx2015_tgt, $I11
    ne $I11, 40, rx2015_fail
    add rx2015_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2015_cur."!cursor_pos"(rx2015_pos)
    $P10 = rx2015_cur."ws"()
    unless $P10, rx2015_fail
    rx2015_pos = $P10."pos"()
  # rx rxquantr2017 ** 0..1
    set_addr $I10, rxquantr2017_done
    rx2015_cur."!mark_push"(0, rx2015_pos, $I10)
  rxquantr2017_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx2015_cur."!cursor_pos"(rx2015_pos)
    $P10 = rx2015_cur."EXPR"()
    unless $P10, rx2015_fail
    goto rxsubrule2018_pass
  rxsubrule2018_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx2015_fail
  rxsubrule2018_pass:
    set_addr $I10, rxsubrule2018_back
    rx2015_cur."!mark_push"(0, rx2015_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx2015_pos = $P10."pos"()
    set_addr $I10, rxquantr2017_done
    (rx2015_rep) = rx2015_cur."!mark_commit"($I10)
  rxquantr2017_done:
  # rx literal  ")"
    add $I11, rx2015_pos, 1
    gt $I11, rx2015_eos, rx2015_fail
    sub $I11, rx2015_pos, rx2015_off
    ord $I11, rx2015_tgt, $I11
    ne $I11, 41, rx2015_fail
    add rx2015_pos, 1
  # rx pass
    rx2015_cur."!cursor_pass"(rx2015_pos, "circumfix:sym<( )>")
    if_null rx2015_debug, debug_1431
    rx2015_cur."!cursor_debug"("PASS", "circumfix:sym<( )>", " at pos=", rx2015_pos)
  debug_1431:
    .return (rx2015_cur)
  rx2015_restart:
.annotate 'line', 435
    if_null rx2015_debug, debug_1432
    rx2015_cur."!cursor_debug"("NEXT", "circumfix:sym<( )>")
  debug_1432:
  rx2015_fail:
    (rx2015_rep, rx2015_pos, $I10, $P10) = rx2015_cur."!mark_fail"(0)
    lt rx2015_pos, -1, rx2015_done
    eq rx2015_pos, -1, rx2015_fail
    jump $I10
  rx2015_done:
    rx2015_cur."!cursor_fail"()
    if_null rx2015_debug, debug_1433
    rx2015_cur."!cursor_debug"("FAIL", "circumfix:sym<( )>")
  debug_1433:
    .return (rx2015_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<( )>"  :subid("296_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("ws", "(")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<[ ]>"  :subid("297_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2021_tgt
    .local int rx2021_pos
    .local int rx2021_off
    .local int rx2021_eos
    .local int rx2021_rep
    .local pmc rx2021_cur
    .local pmc rx2021_debug
    (rx2021_cur, rx2021_pos, rx2021_tgt, $I10) = self."!cursor_start"()
    rx2021_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx2021_cur
    .local pmc match
    .lex "$/", match
    length rx2021_eos, rx2021_tgt
    gt rx2021_pos, rx2021_eos, rx2021_done
    set rx2021_off, 0
    lt rx2021_pos, 2, rx2021_start
    sub rx2021_off, rx2021_pos, 1
    substr rx2021_tgt, rx2021_tgt, rx2021_off
  rx2021_start:
    eq $I10, 1, rx2021_restart
    if_null rx2021_debug, debug_1434
    rx2021_cur."!cursor_debug"("START", "circumfix:sym<[ ]>")
  debug_1434:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2022_done
    goto rxscan2022_scan
  rxscan2022_loop:
    (rx2021_pos) = rx2021_cur."from"()
    inc rx2021_pos
    rx2021_cur."!cursor_from"(rx2021_pos)
    ge rx2021_pos, rx2021_eos, rxscan2022_done
  rxscan2022_scan:
    set_addr $I10, rxscan2022_loop
    rx2021_cur."!mark_push"(0, rx2021_pos, $I10)
  rxscan2022_done:
.annotate 'line', 1036
  # rx literal  "["
    add $I11, rx2021_pos, 1
    gt $I11, rx2021_eos, rx2021_fail
    sub $I11, rx2021_pos, rx2021_off
    ord $I11, rx2021_tgt, $I11
    ne $I11, 91, rx2021_fail
    add rx2021_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2021_cur."!cursor_pos"(rx2021_pos)
    $P10 = rx2021_cur."ws"()
    unless $P10, rx2021_fail
    rx2021_pos = $P10."pos"()
  # rx rxquantr2023 ** 0..1
    set_addr $I10, rxquantr2023_done
    rx2021_cur."!mark_push"(0, rx2021_pos, $I10)
  rxquantr2023_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx2021_cur."!cursor_pos"(rx2021_pos)
    $P10 = rx2021_cur."EXPR"()
    unless $P10, rx2021_fail
    goto rxsubrule2024_pass
  rxsubrule2024_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx2021_fail
  rxsubrule2024_pass:
    set_addr $I10, rxsubrule2024_back
    rx2021_cur."!mark_push"(0, rx2021_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx2021_pos = $P10."pos"()
    set_addr $I10, rxquantr2023_done
    (rx2021_rep) = rx2021_cur."!mark_commit"($I10)
  rxquantr2023_done:
  # rx literal  "]"
    add $I11, rx2021_pos, 1
    gt $I11, rx2021_eos, rx2021_fail
    sub $I11, rx2021_pos, rx2021_off
    ord $I11, rx2021_tgt, $I11
    ne $I11, 93, rx2021_fail
    add rx2021_pos, 1
  # rx pass
    rx2021_cur."!cursor_pass"(rx2021_pos, "circumfix:sym<[ ]>")
    if_null rx2021_debug, debug_1435
    rx2021_cur."!cursor_debug"("PASS", "circumfix:sym<[ ]>", " at pos=", rx2021_pos)
  debug_1435:
    .return (rx2021_cur)
  rx2021_restart:
.annotate 'line', 435
    if_null rx2021_debug, debug_1436
    rx2021_cur."!cursor_debug"("NEXT", "circumfix:sym<[ ]>")
  debug_1436:
  rx2021_fail:
    (rx2021_rep, rx2021_pos, $I10, $P10) = rx2021_cur."!mark_fail"(0)
    lt rx2021_pos, -1, rx2021_done
    eq rx2021_pos, -1, rx2021_fail
    jump $I10
  rx2021_done:
    rx2021_cur."!cursor_fail"()
    if_null rx2021_debug, debug_1437
    rx2021_cur."!cursor_debug"("FAIL", "circumfix:sym<[ ]>")
  debug_1437:
    .return (rx2021_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<[ ]>"  :subid("298_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("ws", "[")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<ang>"  :subid("299_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2027_tgt
    .local int rx2027_pos
    .local int rx2027_off
    .local int rx2027_eos
    .local int rx2027_rep
    .local pmc rx2027_cur
    .local pmc rx2027_debug
    (rx2027_cur, rx2027_pos, rx2027_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2027_cur
    .local pmc match
    .lex "$/", match
    length rx2027_eos, rx2027_tgt
    gt rx2027_pos, rx2027_eos, rx2027_done
    set rx2027_off, 0
    lt rx2027_pos, 2, rx2027_start
    sub rx2027_off, rx2027_pos, 1
    substr rx2027_tgt, rx2027_tgt, rx2027_off
  rx2027_start:
    eq $I10, 1, rx2027_restart
    if_null rx2027_debug, debug_1438
    rx2027_cur."!cursor_debug"("START", "circumfix:sym<ang>")
  debug_1438:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2028_done
    goto rxscan2028_scan
  rxscan2028_loop:
    (rx2027_pos) = rx2027_cur."from"()
    inc rx2027_pos
    rx2027_cur."!cursor_from"(rx2027_pos)
    ge rx2027_pos, rx2027_eos, rxscan2028_done
  rxscan2028_scan:
    set_addr $I10, rxscan2028_loop
    rx2027_cur."!mark_push"(0, rx2027_pos, $I10)
  rxscan2028_done:
.annotate 'line', 1037
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2027_pos, rx2027_off
    substr $S10, rx2027_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx2027_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx2027_cur."!cursor_pos"(rx2027_pos)
    $P10 = rx2027_cur."quote_EXPR"(":q", ":w")
    unless $P10, rx2027_fail
    rx2027_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx2027_pos = $P10."pos"()
  # rx pass
    rx2027_cur."!cursor_pass"(rx2027_pos, "circumfix:sym<ang>")
    if_null rx2027_debug, debug_1439
    rx2027_cur."!cursor_debug"("PASS", "circumfix:sym<ang>", " at pos=", rx2027_pos)
  debug_1439:
    .return (rx2027_cur)
  rx2027_restart:
.annotate 'line', 435
    if_null rx2027_debug, debug_1440
    rx2027_cur."!cursor_debug"("NEXT", "circumfix:sym<ang>")
  debug_1440:
  rx2027_fail:
    (rx2027_rep, rx2027_pos, $I10, $P10) = rx2027_cur."!mark_fail"(0)
    lt rx2027_pos, -1, rx2027_done
    eq rx2027_pos, -1, rx2027_fail
    jump $I10
  rx2027_done:
    rx2027_cur."!cursor_fail"()
    if_null rx2027_debug, debug_1441
    rx2027_cur."!cursor_debug"("FAIL", "circumfix:sym<ang>")
  debug_1441:
    .return (rx2027_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<ang>"  :subid("300_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    new $P103, "ResizablePMCArray"
    push $P103, "<"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("301_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2031_tgt
    .local int rx2031_pos
    .local int rx2031_off
    .local int rx2031_eos
    .local int rx2031_rep
    .local pmc rx2031_cur
    .local pmc rx2031_debug
    (rx2031_cur, rx2031_pos, rx2031_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2031_cur
    .local pmc match
    .lex "$/", match
    length rx2031_eos, rx2031_tgt
    gt rx2031_pos, rx2031_eos, rx2031_done
    set rx2031_off, 0
    lt rx2031_pos, 2, rx2031_start
    sub rx2031_off, rx2031_pos, 1
    substr rx2031_tgt, rx2031_tgt, rx2031_off
  rx2031_start:
    eq $I10, 1, rx2031_restart
    if_null rx2031_debug, debug_1442
    rx2031_cur."!cursor_debug"("START", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1442:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2032_done
    goto rxscan2032_scan
  rxscan2032_loop:
    (rx2031_pos) = rx2031_cur."from"()
    inc rx2031_pos
    rx2031_cur."!cursor_from"(rx2031_pos)
    ge rx2031_pos, rx2031_eos, rxscan2032_done
  rxscan2032_scan:
    set_addr $I10, rxscan2032_loop
    rx2031_cur."!mark_push"(0, rx2031_pos, $I10)
  rxscan2032_done:
.annotate 'line', 1038
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2031_pos, rx2031_off
    substr $S10, rx2031_tgt, $I10, 1
    index $I11, unicode:"\x{ab}", $S10
    lt $I11, 0, rx2031_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx2031_cur."!cursor_pos"(rx2031_pos)
    $P10 = rx2031_cur."quote_EXPR"(":qq", ":w")
    unless $P10, rx2031_fail
    rx2031_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx2031_pos = $P10."pos"()
  # rx pass
    rx2031_cur."!cursor_pass"(rx2031_pos, unicode:"circumfix:sym<\x{ab} \x{bb}>")
    if_null rx2031_debug, debug_1443
    rx2031_cur."!cursor_debug"("PASS", unicode:"circumfix:sym<\x{ab} \x{bb}>", " at pos=", rx2031_pos)
  debug_1443:
    .return (rx2031_cur)
  rx2031_restart:
.annotate 'line', 435
    if_null rx2031_debug, debug_1444
    rx2031_cur."!cursor_debug"("NEXT", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1444:
  rx2031_fail:
    (rx2031_rep, rx2031_pos, $I10, $P10) = rx2031_cur."!mark_fail"(0)
    lt rx2031_pos, -1, rx2031_done
    eq rx2031_pos, -1, rx2031_fail
    jump $I10
  rx2031_done:
    rx2031_cur."!cursor_fail"()
    if_null rx2031_debug, debug_1445
    rx2031_cur."!cursor_debug"("FAIL", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1445:
    .return (rx2031_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"  :subid("302_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    new $P103, "ResizablePMCArray"
    push $P103, unicode:"\x{ab}"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<{ }>"  :subid("303_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2035_tgt
    .local int rx2035_pos
    .local int rx2035_off
    .local int rx2035_eos
    .local int rx2035_rep
    .local pmc rx2035_cur
    .local pmc rx2035_debug
    (rx2035_cur, rx2035_pos, rx2035_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2035_cur
    .local pmc match
    .lex "$/", match
    length rx2035_eos, rx2035_tgt
    gt rx2035_pos, rx2035_eos, rx2035_done
    set rx2035_off, 0
    lt rx2035_pos, 2, rx2035_start
    sub rx2035_off, rx2035_pos, 1
    substr rx2035_tgt, rx2035_tgt, rx2035_off
  rx2035_start:
    eq $I10, 1, rx2035_restart
    if_null rx2035_debug, debug_1446
    rx2035_cur."!cursor_debug"("START", "circumfix:sym<{ }>")
  debug_1446:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2036_done
    goto rxscan2036_scan
  rxscan2036_loop:
    (rx2035_pos) = rx2035_cur."from"()
    inc rx2035_pos
    rx2035_cur."!cursor_from"(rx2035_pos)
    ge rx2035_pos, rx2035_eos, rxscan2036_done
  rxscan2036_scan:
    set_addr $I10, rxscan2036_loop
    rx2035_cur."!mark_push"(0, rx2035_pos, $I10)
  rxscan2036_done:
.annotate 'line', 1039
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2035_pos, rx2035_off
    substr $S10, rx2035_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2035_fail
  # rx subrule "pblock" subtype=capture negate=
    rx2035_cur."!cursor_pos"(rx2035_pos)
    $P10 = rx2035_cur."pblock"()
    unless $P10, rx2035_fail
    rx2035_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx2035_pos = $P10."pos"()
  # rx pass
    rx2035_cur."!cursor_pass"(rx2035_pos, "circumfix:sym<{ }>")
    if_null rx2035_debug, debug_1447
    rx2035_cur."!cursor_debug"("PASS", "circumfix:sym<{ }>", " at pos=", rx2035_pos)
  debug_1447:
    .return (rx2035_cur)
  rx2035_restart:
.annotate 'line', 435
    if_null rx2035_debug, debug_1448
    rx2035_cur."!cursor_debug"("NEXT", "circumfix:sym<{ }>")
  debug_1448:
  rx2035_fail:
    (rx2035_rep, rx2035_pos, $I10, $P10) = rx2035_cur."!mark_fail"(0)
    lt rx2035_pos, -1, rx2035_done
    eq rx2035_pos, -1, rx2035_fail
    jump $I10
  rx2035_done:
    rx2035_cur."!cursor_fail"()
    if_null rx2035_debug, debug_1449
    rx2035_cur."!cursor_debug"("FAIL", "circumfix:sym<{ }>")
  debug_1449:
    .return (rx2035_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<{ }>"  :subid("304_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    new $P103, "ResizablePMCArray"
    push $P103, "{"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<sigil>"  :subid("305_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2039_tgt
    .local int rx2039_pos
    .local int rx2039_off
    .local int rx2039_eos
    .local int rx2039_rep
    .local pmc rx2039_cur
    .local pmc rx2039_debug
    (rx2039_cur, rx2039_pos, rx2039_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2039_cur
    .local pmc match
    .lex "$/", match
    length rx2039_eos, rx2039_tgt
    gt rx2039_pos, rx2039_eos, rx2039_done
    set rx2039_off, 0
    lt rx2039_pos, 2, rx2039_start
    sub rx2039_off, rx2039_pos, 1
    substr rx2039_tgt, rx2039_tgt, rx2039_off
  rx2039_start:
    eq $I10, 1, rx2039_restart
    if_null rx2039_debug, debug_1450
    rx2039_cur."!cursor_debug"("START", "circumfix:sym<sigil>")
  debug_1450:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2040_done
    goto rxscan2040_scan
  rxscan2040_loop:
    (rx2039_pos) = rx2039_cur."from"()
    inc rx2039_pos
    rx2039_cur."!cursor_from"(rx2039_pos)
    ge rx2039_pos, rx2039_eos, rxscan2040_done
  rxscan2040_scan:
    set_addr $I10, rxscan2040_loop
    rx2039_cur."!mark_push"(0, rx2039_pos, $I10)
  rxscan2040_done:
.annotate 'line', 1040
  # rx subrule "sigil" subtype=capture negate=
    rx2039_cur."!cursor_pos"(rx2039_pos)
    $P10 = rx2039_cur."sigil"()
    unless $P10, rx2039_fail
    rx2039_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx2039_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx2039_pos, 1
    gt $I11, rx2039_eos, rx2039_fail
    sub $I11, rx2039_pos, rx2039_off
    ord $I11, rx2039_tgt, $I11
    ne $I11, 40, rx2039_fail
    add rx2039_pos, 1
  # rx subrule "semilist" subtype=capture negate=
    rx2039_cur."!cursor_pos"(rx2039_pos)
    $P10 = rx2039_cur."semilist"()
    unless $P10, rx2039_fail
    rx2039_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("semilist")
    rx2039_pos = $P10."pos"()
  alt2041_0:
    set_addr $I10, alt2041_1
    rx2039_cur."!mark_push"(0, rx2039_pos, $I10)
  # rx literal  ")"
    add $I11, rx2039_pos, 1
    gt $I11, rx2039_eos, rx2039_fail
    sub $I11, rx2039_pos, rx2039_off
    ord $I11, rx2039_tgt, $I11
    ne $I11, 41, rx2039_fail
    add rx2039_pos, 1
    goto alt2041_end
  alt2041_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx2039_cur."!cursor_pos"(rx2039_pos)
    $P10 = rx2039_cur."FAILGOAL"("')'")
    unless $P10, rx2039_fail
    goto rxsubrule2042_pass
  rxsubrule2042_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx2039_fail
  rxsubrule2042_pass:
    set_addr $I10, rxsubrule2042_back
    rx2039_cur."!mark_push"(0, rx2039_pos, $I10, $P10)
    rx2039_pos = $P10."pos"()
  alt2041_end:
  # rx pass
    rx2039_cur."!cursor_pass"(rx2039_pos, "circumfix:sym<sigil>")
    if_null rx2039_debug, debug_1451
    rx2039_cur."!cursor_debug"("PASS", "circumfix:sym<sigil>", " at pos=", rx2039_pos)
  debug_1451:
    .return (rx2039_cur)
  rx2039_restart:
.annotate 'line', 435
    if_null rx2039_debug, debug_1452
    rx2039_cur."!cursor_debug"("NEXT", "circumfix:sym<sigil>")
  debug_1452:
  rx2039_fail:
    (rx2039_rep, rx2039_pos, $I10, $P10) = rx2039_cur."!mark_fail"(0)
    lt rx2039_pos, -1, rx2039_done
    eq rx2039_pos, -1, rx2039_fail
    jump $I10
  rx2039_done:
    rx2039_cur."!cursor_fail"()
    if_null rx2039_debug, debug_1453
    rx2039_cur."!cursor_debug"("FAIL", "circumfix:sym<sigil>")
  debug_1453:
    .return (rx2039_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<sigil>"  :subid("306_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P104 = self."!PREFIX__!subrule"("sigil", "")
    new $P105, "ResizablePMCArray"
    push $P105, $P104
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "semilist"  :subid("307_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2045_tgt
    .local int rx2045_pos
    .local int rx2045_off
    .local int rx2045_eos
    .local int rx2045_rep
    .local pmc rx2045_cur
    .local pmc rx2045_debug
    (rx2045_cur, rx2045_pos, rx2045_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2045_cur
    .local pmc match
    .lex "$/", match
    length rx2045_eos, rx2045_tgt
    gt rx2045_pos, rx2045_eos, rx2045_done
    set rx2045_off, 0
    lt rx2045_pos, 2, rx2045_start
    sub rx2045_off, rx2045_pos, 1
    substr rx2045_tgt, rx2045_tgt, rx2045_off
  rx2045_start:
    eq $I10, 1, rx2045_restart
    if_null rx2045_debug, debug_1454
    rx2045_cur."!cursor_debug"("START", "semilist")
  debug_1454:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2046_done
    goto rxscan2046_scan
  rxscan2046_loop:
    (rx2045_pos) = rx2045_cur."from"()
    inc rx2045_pos
    rx2045_cur."!cursor_from"(rx2045_pos)
    ge rx2045_pos, rx2045_eos, rxscan2046_done
  rxscan2046_scan:
    set_addr $I10, rxscan2046_loop
    rx2045_cur."!mark_push"(0, rx2045_pos, $I10)
  rxscan2046_done:
.annotate 'line', 1042
  # rx subrule "ws" subtype=method negate=
    rx2045_cur."!cursor_pos"(rx2045_pos)
    $P10 = rx2045_cur."ws"()
    unless $P10, rx2045_fail
    rx2045_pos = $P10."pos"()
  # rx subrule "statement" subtype=capture negate=
    rx2045_cur."!cursor_pos"(rx2045_pos)
    $P10 = rx2045_cur."statement"()
    unless $P10, rx2045_fail
    rx2045_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx2045_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2045_cur."!cursor_pos"(rx2045_pos)
    $P10 = rx2045_cur."ws"()
    unless $P10, rx2045_fail
    rx2045_pos = $P10."pos"()
  # rx pass
    rx2045_cur."!cursor_pass"(rx2045_pos, "semilist")
    if_null rx2045_debug, debug_1455
    rx2045_cur."!cursor_debug"("PASS", "semilist", " at pos=", rx2045_pos)
  debug_1455:
    .return (rx2045_cur)
  rx2045_restart:
.annotate 'line', 435
    if_null rx2045_debug, debug_1456
    rx2045_cur."!cursor_debug"("NEXT", "semilist")
  debug_1456:
  rx2045_fail:
    (rx2045_rep, rx2045_pos, $I10, $P10) = rx2045_cur."!mark_fail"(0)
    lt rx2045_pos, -1, rx2045_done
    eq rx2045_pos, -1, rx2045_fail
    jump $I10
  rx2045_done:
    rx2045_cur."!cursor_fail"()
    if_null rx2045_debug, debug_1457
    rx2045_cur."!cursor_debug"("FAIL", "semilist")
  debug_1457:
    .return (rx2045_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__semilist"  :subid("308_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P105 = self."!PREFIX__!subrule"("ws", "")
    new $P106, "ResizablePMCArray"
    push $P106, $P105
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixish"  :subid("309_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2049_tgt
    .local int rx2049_pos
    .local int rx2049_off
    .local int rx2049_eos
    .local int rx2049_rep
    .local pmc rx2049_cur
    .local pmc rx2049_debug
    (rx2049_cur, rx2049_pos, rx2049_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2049_cur
    .local pmc match
    .lex "$/", match
    length rx2049_eos, rx2049_tgt
    gt rx2049_pos, rx2049_eos, rx2049_done
    set rx2049_off, 0
    lt rx2049_pos, 2, rx2049_start
    sub rx2049_off, rx2049_pos, 1
    substr rx2049_tgt, rx2049_tgt, rx2049_off
  rx2049_start:
    eq $I10, 1, rx2049_restart
    if_null rx2049_debug, debug_1458
    rx2049_cur."!cursor_debug"("START", "infixish")
  debug_1458:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2050_done
    goto rxscan2050_scan
  rxscan2050_loop:
    (rx2049_pos) = rx2049_cur."from"()
    inc rx2049_pos
    rx2049_cur."!cursor_from"(rx2049_pos)
    ge rx2049_pos, rx2049_eos, rxscan2050_done
  rxscan2050_scan:
    set_addr $I10, rxscan2050_loop
    rx2049_cur."!mark_push"(0, rx2049_pos, $I10)
  rxscan2050_done:
.annotate 'line', 1065
  # rx subrule "infixstopper" subtype=zerowidth negate=1
    rx2049_cur."!cursor_pos"(rx2049_pos)
    $P10 = rx2049_cur."infixstopper"()
    if $P10, rx2049_fail
  # rx subrule "infix" subtype=capture negate=
    rx2049_cur."!cursor_pos"(rx2049_pos)
    $P10 = rx2049_cur."infix"()
    unless $P10, rx2049_fail
    rx2049_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("OPER=infix")
    rx2049_pos = $P10."pos"()
  # rx pass
    rx2049_cur."!cursor_pass"(rx2049_pos, "infixish")
    if_null rx2049_debug, debug_1459
    rx2049_cur."!cursor_debug"("PASS", "infixish", " at pos=", rx2049_pos)
  debug_1459:
    .return (rx2049_cur)
  rx2049_restart:
.annotate 'line', 435
    if_null rx2049_debug, debug_1460
    rx2049_cur."!cursor_debug"("NEXT", "infixish")
  debug_1460:
  rx2049_fail:
    (rx2049_rep, rx2049_pos, $I10, $P10) = rx2049_cur."!mark_fail"(0)
    lt rx2049_pos, -1, rx2049_done
    eq rx2049_pos, -1, rx2049_fail
    jump $I10
  rx2049_done:
    rx2049_cur."!cursor_fail"()
    if_null rx2049_debug, debug_1461
    rx2049_cur."!cursor_debug"("FAIL", "infixish")
  debug_1461:
    .return (rx2049_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixish"  :subid("310_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixstopper"  :subid("311_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2053_tgt
    .local int rx2053_pos
    .local int rx2053_off
    .local int rx2053_eos
    .local int rx2053_rep
    .local pmc rx2053_cur
    .local pmc rx2053_debug
    (rx2053_cur, rx2053_pos, rx2053_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2053_cur
    .local pmc match
    .lex "$/", match
    length rx2053_eos, rx2053_tgt
    gt rx2053_pos, rx2053_eos, rx2053_done
    set rx2053_off, 0
    lt rx2053_pos, 2, rx2053_start
    sub rx2053_off, rx2053_pos, 1
    substr rx2053_tgt, rx2053_tgt, rx2053_off
  rx2053_start:
    eq $I10, 1, rx2053_restart
    if_null rx2053_debug, debug_1462
    rx2053_cur."!cursor_debug"("START", "infixstopper")
  debug_1462:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2054_done
    goto rxscan2054_scan
  rxscan2054_loop:
    (rx2053_pos) = rx2053_cur."from"()
    inc rx2053_pos
    rx2053_cur."!cursor_from"(rx2053_pos)
    ge rx2053_pos, rx2053_eos, rxscan2054_done
  rxscan2054_scan:
    set_addr $I10, rxscan2054_loop
    rx2053_cur."!mark_push"(0, rx2053_pos, $I10)
  rxscan2054_done:
.annotate 'line', 1066
  # rx subrule "lambda" subtype=zerowidth negate=
    rx2053_cur."!cursor_pos"(rx2053_pos)
    $P10 = rx2053_cur."lambda"()
    unless $P10, rx2053_fail
  # rx pass
    rx2053_cur."!cursor_pass"(rx2053_pos, "infixstopper")
    if_null rx2053_debug, debug_1463
    rx2053_cur."!cursor_debug"("PASS", "infixstopper", " at pos=", rx2053_pos)
  debug_1463:
    .return (rx2053_cur)
  rx2053_restart:
.annotate 'line', 435
    if_null rx2053_debug, debug_1464
    rx2053_cur."!cursor_debug"("NEXT", "infixstopper")
  debug_1464:
  rx2053_fail:
    (rx2053_rep, rx2053_pos, $I10, $P10) = rx2053_cur."!mark_fail"(0)
    lt rx2053_pos, -1, rx2053_done
    eq rx2053_pos, -1, rx2053_fail
    jump $I10
  rx2053_done:
    rx2053_cur."!cursor_fail"()
    if_null rx2053_debug, debug_1465
    rx2053_cur."!cursor_debug"("FAIL", "infixstopper")
  debug_1465:
    .return (rx2053_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixstopper"  :subid("312_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<[ ]>"  :subid("313_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2057_tgt
    .local int rx2057_pos
    .local int rx2057_off
    .local int rx2057_eos
    .local int rx2057_rep
    .local pmc rx2057_cur
    .local pmc rx2057_debug
    (rx2057_cur, rx2057_pos, rx2057_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2057_cur
    .local pmc match
    .lex "$/", match
    length rx2057_eos, rx2057_tgt
    gt rx2057_pos, rx2057_eos, rx2057_done
    set rx2057_off, 0
    lt rx2057_pos, 2, rx2057_start
    sub rx2057_off, rx2057_pos, 1
    substr rx2057_tgt, rx2057_tgt, rx2057_off
  rx2057_start:
    eq $I10, 1, rx2057_restart
    if_null rx2057_debug, debug_1466
    rx2057_cur."!cursor_debug"("START", "postcircumfix:sym<[ ]>")
  debug_1466:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2058_done
    goto rxscan2058_scan
  rxscan2058_loop:
    (rx2057_pos) = rx2057_cur."from"()
    inc rx2057_pos
    rx2057_cur."!cursor_from"(rx2057_pos)
    ge rx2057_pos, rx2057_eos, rxscan2058_done
  rxscan2058_scan:
    set_addr $I10, rxscan2058_loop
    rx2057_cur."!mark_push"(0, rx2057_pos, $I10)
  rxscan2058_done:
.annotate 'line', 1069
  # rx literal  "["
    add $I11, rx2057_pos, 1
    gt $I11, rx2057_eos, rx2057_fail
    sub $I11, rx2057_pos, rx2057_off
    ord $I11, rx2057_tgt, $I11
    ne $I11, 91, rx2057_fail
    add rx2057_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2057_cur."!cursor_pos"(rx2057_pos)
    $P10 = rx2057_cur."ws"()
    unless $P10, rx2057_fail
    rx2057_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx2057_cur."!cursor_pos"(rx2057_pos)
    $P10 = rx2057_cur."EXPR"()
    unless $P10, rx2057_fail
    rx2057_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx2057_pos = $P10."pos"()
  # rx literal  "]"
    add $I11, rx2057_pos, 1
    gt $I11, rx2057_eos, rx2057_fail
    sub $I11, rx2057_pos, rx2057_off
    ord $I11, rx2057_tgt, $I11
    ne $I11, 93, rx2057_fail
    add rx2057_pos, 1
.annotate 'line', 1070
  # rx subrule "O" subtype=capture negate=
    rx2057_cur."!cursor_pos"(rx2057_pos)
    $P10 = rx2057_cur."O"("%methodop")
    unless $P10, rx2057_fail
    rx2057_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2057_pos = $P10."pos"()
.annotate 'line', 1068
  # rx pass
    rx2057_cur."!cursor_pass"(rx2057_pos, "postcircumfix:sym<[ ]>")
    if_null rx2057_debug, debug_1467
    rx2057_cur."!cursor_debug"("PASS", "postcircumfix:sym<[ ]>", " at pos=", rx2057_pos)
  debug_1467:
    .return (rx2057_cur)
  rx2057_restart:
.annotate 'line', 435
    if_null rx2057_debug, debug_1468
    rx2057_cur."!cursor_debug"("NEXT", "postcircumfix:sym<[ ]>")
  debug_1468:
  rx2057_fail:
    (rx2057_rep, rx2057_pos, $I10, $P10) = rx2057_cur."!mark_fail"(0)
    lt rx2057_pos, -1, rx2057_done
    eq rx2057_pos, -1, rx2057_fail
    jump $I10
  rx2057_done:
    rx2057_cur."!cursor_fail"()
    if_null rx2057_debug, debug_1469
    rx2057_cur."!cursor_debug"("FAIL", "postcircumfix:sym<[ ]>")
  debug_1469:
    .return (rx2057_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<[ ]>"  :subid("314_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("ws", "[")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<{ }>"  :subid("315_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2061_tgt
    .local int rx2061_pos
    .local int rx2061_off
    .local int rx2061_eos
    .local int rx2061_rep
    .local pmc rx2061_cur
    .local pmc rx2061_debug
    (rx2061_cur, rx2061_pos, rx2061_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2061_cur
    .local pmc match
    .lex "$/", match
    length rx2061_eos, rx2061_tgt
    gt rx2061_pos, rx2061_eos, rx2061_done
    set rx2061_off, 0
    lt rx2061_pos, 2, rx2061_start
    sub rx2061_off, rx2061_pos, 1
    substr rx2061_tgt, rx2061_tgt, rx2061_off
  rx2061_start:
    eq $I10, 1, rx2061_restart
    if_null rx2061_debug, debug_1470
    rx2061_cur."!cursor_debug"("START", "postcircumfix:sym<{ }>")
  debug_1470:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2062_done
    goto rxscan2062_scan
  rxscan2062_loop:
    (rx2061_pos) = rx2061_cur."from"()
    inc rx2061_pos
    rx2061_cur."!cursor_from"(rx2061_pos)
    ge rx2061_pos, rx2061_eos, rxscan2062_done
  rxscan2062_scan:
    set_addr $I10, rxscan2062_loop
    rx2061_cur."!mark_push"(0, rx2061_pos, $I10)
  rxscan2062_done:
.annotate 'line', 1074
  # rx literal  "{"
    add $I11, rx2061_pos, 1
    gt $I11, rx2061_eos, rx2061_fail
    sub $I11, rx2061_pos, rx2061_off
    ord $I11, rx2061_tgt, $I11
    ne $I11, 123, rx2061_fail
    add rx2061_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2061_cur."!cursor_pos"(rx2061_pos)
    $P10 = rx2061_cur."ws"()
    unless $P10, rx2061_fail
    rx2061_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx2061_cur."!cursor_pos"(rx2061_pos)
    $P10 = rx2061_cur."EXPR"()
    unless $P10, rx2061_fail
    rx2061_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx2061_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx2061_pos, 1
    gt $I11, rx2061_eos, rx2061_fail
    sub $I11, rx2061_pos, rx2061_off
    ord $I11, rx2061_tgt, $I11
    ne $I11, 125, rx2061_fail
    add rx2061_pos, 1
.annotate 'line', 1075
  # rx subrule "O" subtype=capture negate=
    rx2061_cur."!cursor_pos"(rx2061_pos)
    $P10 = rx2061_cur."O"("%methodop")
    unless $P10, rx2061_fail
    rx2061_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2061_pos = $P10."pos"()
.annotate 'line', 1073
  # rx pass
    rx2061_cur."!cursor_pass"(rx2061_pos, "postcircumfix:sym<{ }>")
    if_null rx2061_debug, debug_1471
    rx2061_cur."!cursor_debug"("PASS", "postcircumfix:sym<{ }>", " at pos=", rx2061_pos)
  debug_1471:
    .return (rx2061_cur)
  rx2061_restart:
.annotate 'line', 435
    if_null rx2061_debug, debug_1472
    rx2061_cur."!cursor_debug"("NEXT", "postcircumfix:sym<{ }>")
  debug_1472:
  rx2061_fail:
    (rx2061_rep, rx2061_pos, $I10, $P10) = rx2061_cur."!mark_fail"(0)
    lt rx2061_pos, -1, rx2061_done
    eq rx2061_pos, -1, rx2061_fail
    jump $I10
  rx2061_done:
    rx2061_cur."!cursor_fail"()
    if_null rx2061_debug, debug_1473
    rx2061_cur."!cursor_debug"("FAIL", "postcircumfix:sym<{ }>")
  debug_1473:
    .return (rx2061_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<{ }>"  :subid("316_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("ws", "{")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<ang>"  :subid("317_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2065_tgt
    .local int rx2065_pos
    .local int rx2065_off
    .local int rx2065_eos
    .local int rx2065_rep
    .local pmc rx2065_cur
    .local pmc rx2065_debug
    (rx2065_cur, rx2065_pos, rx2065_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2065_cur
    .local pmc match
    .lex "$/", match
    length rx2065_eos, rx2065_tgt
    gt rx2065_pos, rx2065_eos, rx2065_done
    set rx2065_off, 0
    lt rx2065_pos, 2, rx2065_start
    sub rx2065_off, rx2065_pos, 1
    substr rx2065_tgt, rx2065_tgt, rx2065_off
  rx2065_start:
    eq $I10, 1, rx2065_restart
    if_null rx2065_debug, debug_1474
    rx2065_cur."!cursor_debug"("START", "postcircumfix:sym<ang>")
  debug_1474:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2066_done
    goto rxscan2066_scan
  rxscan2066_loop:
    (rx2065_pos) = rx2065_cur."from"()
    inc rx2065_pos
    rx2065_cur."!cursor_from"(rx2065_pos)
    ge rx2065_pos, rx2065_eos, rxscan2066_done
  rxscan2066_scan:
    set_addr $I10, rxscan2066_loop
    rx2065_cur."!mark_push"(0, rx2065_pos, $I10)
  rxscan2066_done:
.annotate 'line', 1079
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2065_pos, rx2065_off
    substr $S10, rx2065_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx2065_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx2065_cur."!cursor_pos"(rx2065_pos)
    $P10 = rx2065_cur."quote_EXPR"(":q")
    unless $P10, rx2065_fail
    rx2065_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx2065_pos = $P10."pos"()
.annotate 'line', 1080
  # rx subrule "O" subtype=capture negate=
    rx2065_cur."!cursor_pos"(rx2065_pos)
    $P10 = rx2065_cur."O"("%methodop")
    unless $P10, rx2065_fail
    rx2065_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2065_pos = $P10."pos"()
.annotate 'line', 1078
  # rx pass
    rx2065_cur."!cursor_pass"(rx2065_pos, "postcircumfix:sym<ang>")
    if_null rx2065_debug, debug_1475
    rx2065_cur."!cursor_debug"("PASS", "postcircumfix:sym<ang>", " at pos=", rx2065_pos)
  debug_1475:
    .return (rx2065_cur)
  rx2065_restart:
.annotate 'line', 435
    if_null rx2065_debug, debug_1476
    rx2065_cur."!cursor_debug"("NEXT", "postcircumfix:sym<ang>")
  debug_1476:
  rx2065_fail:
    (rx2065_rep, rx2065_pos, $I10, $P10) = rx2065_cur."!mark_fail"(0)
    lt rx2065_pos, -1, rx2065_done
    eq rx2065_pos, -1, rx2065_fail
    jump $I10
  rx2065_done:
    rx2065_cur."!cursor_fail"()
    if_null rx2065_debug, debug_1477
    rx2065_cur."!cursor_debug"("FAIL", "postcircumfix:sym<ang>")
  debug_1477:
    .return (rx2065_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<ang>"  :subid("318_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    new $P103, "ResizablePMCArray"
    push $P103, "<"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<( )>"  :subid("319_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2069_tgt
    .local int rx2069_pos
    .local int rx2069_off
    .local int rx2069_eos
    .local int rx2069_rep
    .local pmc rx2069_cur
    .local pmc rx2069_debug
    (rx2069_cur, rx2069_pos, rx2069_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2069_cur
    .local pmc match
    .lex "$/", match
    length rx2069_eos, rx2069_tgt
    gt rx2069_pos, rx2069_eos, rx2069_done
    set rx2069_off, 0
    lt rx2069_pos, 2, rx2069_start
    sub rx2069_off, rx2069_pos, 1
    substr rx2069_tgt, rx2069_tgt, rx2069_off
  rx2069_start:
    eq $I10, 1, rx2069_restart
    if_null rx2069_debug, debug_1478
    rx2069_cur."!cursor_debug"("START", "postcircumfix:sym<( )>")
  debug_1478:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2070_done
    goto rxscan2070_scan
  rxscan2070_loop:
    (rx2069_pos) = rx2069_cur."from"()
    inc rx2069_pos
    rx2069_cur."!cursor_from"(rx2069_pos)
    ge rx2069_pos, rx2069_eos, rxscan2070_done
  rxscan2070_scan:
    set_addr $I10, rxscan2070_loop
    rx2069_cur."!mark_push"(0, rx2069_pos, $I10)
  rxscan2070_done:
.annotate 'line', 1084
  # rx literal  "("
    add $I11, rx2069_pos, 1
    gt $I11, rx2069_eos, rx2069_fail
    sub $I11, rx2069_pos, rx2069_off
    ord $I11, rx2069_tgt, $I11
    ne $I11, 40, rx2069_fail
    add rx2069_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2069_cur."!cursor_pos"(rx2069_pos)
    $P10 = rx2069_cur."ws"()
    unless $P10, rx2069_fail
    rx2069_pos = $P10."pos"()
  # rx subrule "arglist" subtype=capture negate=
    rx2069_cur."!cursor_pos"(rx2069_pos)
    $P10 = rx2069_cur."arglist"()
    unless $P10, rx2069_fail
    rx2069_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2069_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx2069_pos, 1
    gt $I11, rx2069_eos, rx2069_fail
    sub $I11, rx2069_pos, rx2069_off
    ord $I11, rx2069_tgt, $I11
    ne $I11, 41, rx2069_fail
    add rx2069_pos, 1
.annotate 'line', 1085
  # rx subrule "O" subtype=capture negate=
    rx2069_cur."!cursor_pos"(rx2069_pos)
    $P10 = rx2069_cur."O"("%methodop")
    unless $P10, rx2069_fail
    rx2069_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2069_pos = $P10."pos"()
.annotate 'line', 1083
  # rx pass
    rx2069_cur."!cursor_pass"(rx2069_pos, "postcircumfix:sym<( )>")
    if_null rx2069_debug, debug_1479
    rx2069_cur."!cursor_debug"("PASS", "postcircumfix:sym<( )>", " at pos=", rx2069_pos)
  debug_1479:
    .return (rx2069_cur)
  rx2069_restart:
.annotate 'line', 435
    if_null rx2069_debug, debug_1480
    rx2069_cur."!cursor_debug"("NEXT", "postcircumfix:sym<( )>")
  debug_1480:
  rx2069_fail:
    (rx2069_rep, rx2069_pos, $I10, $P10) = rx2069_cur."!mark_fail"(0)
    lt rx2069_pos, -1, rx2069_done
    eq rx2069_pos, -1, rx2069_fail
    jump $I10
  rx2069_done:
    rx2069_cur."!cursor_fail"()
    if_null rx2069_debug, debug_1481
    rx2069_cur."!cursor_debug"("FAIL", "postcircumfix:sym<( )>")
  debug_1481:
    .return (rx2069_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<( )>"  :subid("320_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("ws", "(")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<.>"  :subid("321_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2073_tgt
    .local int rx2073_pos
    .local int rx2073_off
    .local int rx2073_eos
    .local int rx2073_rep
    .local pmc rx2073_cur
    .local pmc rx2073_debug
    (rx2073_cur, rx2073_pos, rx2073_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2073_cur
    .local pmc match
    .lex "$/", match
    length rx2073_eos, rx2073_tgt
    gt rx2073_pos, rx2073_eos, rx2073_done
    set rx2073_off, 0
    lt rx2073_pos, 2, rx2073_start
    sub rx2073_off, rx2073_pos, 1
    substr rx2073_tgt, rx2073_tgt, rx2073_off
  rx2073_start:
    eq $I10, 1, rx2073_restart
    if_null rx2073_debug, debug_1482
    rx2073_cur."!cursor_debug"("START", "postfix:sym<.>")
  debug_1482:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2074_done
    goto rxscan2074_scan
  rxscan2074_loop:
    (rx2073_pos) = rx2073_cur."from"()
    inc rx2073_pos
    rx2073_cur."!cursor_from"(rx2073_pos)
    ge rx2073_pos, rx2073_eos, rxscan2074_done
  rxscan2074_scan:
    set_addr $I10, rxscan2074_loop
    rx2073_cur."!mark_push"(0, rx2073_pos, $I10)
  rxscan2074_done:
.annotate 'line', 1088
  # rx subrule "dotty" subtype=capture negate=
    rx2073_cur."!cursor_pos"(rx2073_pos)
    $P10 = rx2073_cur."dotty"()
    unless $P10, rx2073_fail
    rx2073_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dotty")
    rx2073_pos = $P10."pos"()
  # rx subrule "O" subtype=capture negate=
    rx2073_cur."!cursor_pos"(rx2073_pos)
    $P10 = rx2073_cur."O"("%methodop")
    unless $P10, rx2073_fail
    rx2073_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2073_pos = $P10."pos"()
  # rx pass
    rx2073_cur."!cursor_pass"(rx2073_pos, "postfix:sym<.>")
    if_null rx2073_debug, debug_1483
    rx2073_cur."!cursor_debug"("PASS", "postfix:sym<.>", " at pos=", rx2073_pos)
  debug_1483:
    .return (rx2073_cur)
  rx2073_restart:
.annotate 'line', 435
    if_null rx2073_debug, debug_1484
    rx2073_cur."!cursor_debug"("NEXT", "postfix:sym<.>")
  debug_1484:
  rx2073_fail:
    (rx2073_rep, rx2073_pos, $I10, $P10) = rx2073_cur."!mark_fail"(0)
    lt rx2073_pos, -1, rx2073_done
    eq rx2073_pos, -1, rx2073_fail
    jump $I10
  rx2073_done:
    rx2073_cur."!cursor_fail"()
    if_null rx2073_debug, debug_1485
    rx2073_cur."!cursor_debug"("FAIL", "postfix:sym<.>")
  debug_1485:
    .return (rx2073_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<.>"  :subid("322_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("dotty", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<++>"  :subid("323_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2077_tgt
    .local int rx2077_pos
    .local int rx2077_off
    .local int rx2077_eos
    .local int rx2077_rep
    .local pmc rx2077_cur
    .local pmc rx2077_debug
    (rx2077_cur, rx2077_pos, rx2077_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2077_cur
    .local pmc match
    .lex "$/", match
    length rx2077_eos, rx2077_tgt
    gt rx2077_pos, rx2077_eos, rx2077_done
    set rx2077_off, 0
    lt rx2077_pos, 2, rx2077_start
    sub rx2077_off, rx2077_pos, 1
    substr rx2077_tgt, rx2077_tgt, rx2077_off
  rx2077_start:
    eq $I10, 1, rx2077_restart
    if_null rx2077_debug, debug_1486
    rx2077_cur."!cursor_debug"("START", "prefix:sym<++>")
  debug_1486:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2078_done
    goto rxscan2078_scan
  rxscan2078_loop:
    (rx2077_pos) = rx2077_cur."from"()
    inc rx2077_pos
    rx2077_cur."!cursor_from"(rx2077_pos)
    ge rx2077_pos, rx2077_eos, rxscan2078_done
  rxscan2078_scan:
    set_addr $I10, rxscan2078_loop
    rx2077_cur."!mark_push"(0, rx2077_pos, $I10)
  rxscan2078_done:
.annotate 'line', 1090
  # rx subcapture "sym"
    set_addr $I10, rxcap_2079_fail
    rx2077_cur."!mark_push"(0, rx2077_pos, $I10)
  # rx literal  "++"
    add $I11, rx2077_pos, 2
    gt $I11, rx2077_eos, rx2077_fail
    sub $I11, rx2077_pos, rx2077_off
    substr $S10, rx2077_tgt, $I11, 2
    ne $S10, "++", rx2077_fail
    add rx2077_pos, 2
    set_addr $I10, rxcap_2079_fail
    ($I12, $I11) = rx2077_cur."!mark_peek"($I10)
    rx2077_cur."!cursor_pos"($I11)
    ($P10) = rx2077_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2077_pos, "")
    rx2077_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2079_done
  rxcap_2079_fail:
    goto rx2077_fail
  rxcap_2079_done:
  # rx subrule "O" subtype=capture negate=
    rx2077_cur."!cursor_pos"(rx2077_pos)
    $P10 = rx2077_cur."O"("%autoincrement, :pirop<inc>")
    unless $P10, rx2077_fail
    rx2077_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2077_pos = $P10."pos"()
  # rx pass
    rx2077_cur."!cursor_pass"(rx2077_pos, "prefix:sym<++>")
    if_null rx2077_debug, debug_1487
    rx2077_cur."!cursor_debug"("PASS", "prefix:sym<++>", " at pos=", rx2077_pos)
  debug_1487:
    .return (rx2077_cur)
  rx2077_restart:
.annotate 'line', 435
    if_null rx2077_debug, debug_1488
    rx2077_cur."!cursor_debug"("NEXT", "prefix:sym<++>")
  debug_1488:
  rx2077_fail:
    (rx2077_rep, rx2077_pos, $I10, $P10) = rx2077_cur."!mark_fail"(0)
    lt rx2077_pos, -1, rx2077_done
    eq rx2077_pos, -1, rx2077_fail
    jump $I10
  rx2077_done:
    rx2077_cur."!cursor_fail"()
    if_null rx2077_debug, debug_1489
    rx2077_cur."!cursor_debug"("FAIL", "prefix:sym<++>")
  debug_1489:
    .return (rx2077_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<++>"  :subid("324_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("O", "++")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<-->"  :subid("325_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2082_tgt
    .local int rx2082_pos
    .local int rx2082_off
    .local int rx2082_eos
    .local int rx2082_rep
    .local pmc rx2082_cur
    .local pmc rx2082_debug
    (rx2082_cur, rx2082_pos, rx2082_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2082_cur
    .local pmc match
    .lex "$/", match
    length rx2082_eos, rx2082_tgt
    gt rx2082_pos, rx2082_eos, rx2082_done
    set rx2082_off, 0
    lt rx2082_pos, 2, rx2082_start
    sub rx2082_off, rx2082_pos, 1
    substr rx2082_tgt, rx2082_tgt, rx2082_off
  rx2082_start:
    eq $I10, 1, rx2082_restart
    if_null rx2082_debug, debug_1490
    rx2082_cur."!cursor_debug"("START", "prefix:sym<-->")
  debug_1490:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2083_done
    goto rxscan2083_scan
  rxscan2083_loop:
    (rx2082_pos) = rx2082_cur."from"()
    inc rx2082_pos
    rx2082_cur."!cursor_from"(rx2082_pos)
    ge rx2082_pos, rx2082_eos, rxscan2083_done
  rxscan2083_scan:
    set_addr $I10, rxscan2083_loop
    rx2082_cur."!mark_push"(0, rx2082_pos, $I10)
  rxscan2083_done:
.annotate 'line', 1091
  # rx subcapture "sym"
    set_addr $I10, rxcap_2084_fail
    rx2082_cur."!mark_push"(0, rx2082_pos, $I10)
  # rx literal  "--"
    add $I11, rx2082_pos, 2
    gt $I11, rx2082_eos, rx2082_fail
    sub $I11, rx2082_pos, rx2082_off
    substr $S10, rx2082_tgt, $I11, 2
    ne $S10, "--", rx2082_fail
    add rx2082_pos, 2
    set_addr $I10, rxcap_2084_fail
    ($I12, $I11) = rx2082_cur."!mark_peek"($I10)
    rx2082_cur."!cursor_pos"($I11)
    ($P10) = rx2082_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2082_pos, "")
    rx2082_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2084_done
  rxcap_2084_fail:
    goto rx2082_fail
  rxcap_2084_done:
  # rx subrule "O" subtype=capture negate=
    rx2082_cur."!cursor_pos"(rx2082_pos)
    $P10 = rx2082_cur."O"("%autoincrement, :pirop<dec>")
    unless $P10, rx2082_fail
    rx2082_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2082_pos = $P10."pos"()
  # rx pass
    rx2082_cur."!cursor_pass"(rx2082_pos, "prefix:sym<-->")
    if_null rx2082_debug, debug_1491
    rx2082_cur."!cursor_debug"("PASS", "prefix:sym<-->", " at pos=", rx2082_pos)
  debug_1491:
    .return (rx2082_cur)
  rx2082_restart:
.annotate 'line', 435
    if_null rx2082_debug, debug_1492
    rx2082_cur."!cursor_debug"("NEXT", "prefix:sym<-->")
  debug_1492:
  rx2082_fail:
    (rx2082_rep, rx2082_pos, $I10, $P10) = rx2082_cur."!mark_fail"(0)
    lt rx2082_pos, -1, rx2082_done
    eq rx2082_pos, -1, rx2082_fail
    jump $I10
  rx2082_done:
    rx2082_cur."!cursor_fail"()
    if_null rx2082_debug, debug_1493
    rx2082_cur."!cursor_debug"("FAIL", "prefix:sym<-->")
  debug_1493:
    .return (rx2082_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<-->"  :subid("326_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("O", "--")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<++>"  :subid("327_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2087_tgt
    .local int rx2087_pos
    .local int rx2087_off
    .local int rx2087_eos
    .local int rx2087_rep
    .local pmc rx2087_cur
    .local pmc rx2087_debug
    (rx2087_cur, rx2087_pos, rx2087_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2087_cur
    .local pmc match
    .lex "$/", match
    length rx2087_eos, rx2087_tgt
    gt rx2087_pos, rx2087_eos, rx2087_done
    set rx2087_off, 0
    lt rx2087_pos, 2, rx2087_start
    sub rx2087_off, rx2087_pos, 1
    substr rx2087_tgt, rx2087_tgt, rx2087_off
  rx2087_start:
    eq $I10, 1, rx2087_restart
    if_null rx2087_debug, debug_1494
    rx2087_cur."!cursor_debug"("START", "postfix:sym<++>")
  debug_1494:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2088_done
    goto rxscan2088_scan
  rxscan2088_loop:
    (rx2087_pos) = rx2087_cur."from"()
    inc rx2087_pos
    rx2087_cur."!cursor_from"(rx2087_pos)
    ge rx2087_pos, rx2087_eos, rxscan2088_done
  rxscan2088_scan:
    set_addr $I10, rxscan2088_loop
    rx2087_cur."!mark_push"(0, rx2087_pos, $I10)
  rxscan2088_done:
.annotate 'line', 1094
  # rx subcapture "sym"
    set_addr $I10, rxcap_2089_fail
    rx2087_cur."!mark_push"(0, rx2087_pos, $I10)
  # rx literal  "++"
    add $I11, rx2087_pos, 2
    gt $I11, rx2087_eos, rx2087_fail
    sub $I11, rx2087_pos, rx2087_off
    substr $S10, rx2087_tgt, $I11, 2
    ne $S10, "++", rx2087_fail
    add rx2087_pos, 2
    set_addr $I10, rxcap_2089_fail
    ($I12, $I11) = rx2087_cur."!mark_peek"($I10)
    rx2087_cur."!cursor_pos"($I11)
    ($P10) = rx2087_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2087_pos, "")
    rx2087_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2089_done
  rxcap_2089_fail:
    goto rx2087_fail
  rxcap_2089_done:
  # rx subrule "O" subtype=capture negate=
    rx2087_cur."!cursor_pos"(rx2087_pos)
    $P10 = rx2087_cur."O"("%autoincrement")
    unless $P10, rx2087_fail
    rx2087_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2087_pos = $P10."pos"()
  # rx pass
    rx2087_cur."!cursor_pass"(rx2087_pos, "postfix:sym<++>")
    if_null rx2087_debug, debug_1495
    rx2087_cur."!cursor_debug"("PASS", "postfix:sym<++>", " at pos=", rx2087_pos)
  debug_1495:
    .return (rx2087_cur)
  rx2087_restart:
.annotate 'line', 435
    if_null rx2087_debug, debug_1496
    rx2087_cur."!cursor_debug"("NEXT", "postfix:sym<++>")
  debug_1496:
  rx2087_fail:
    (rx2087_rep, rx2087_pos, $I10, $P10) = rx2087_cur."!mark_fail"(0)
    lt rx2087_pos, -1, rx2087_done
    eq rx2087_pos, -1, rx2087_fail
    jump $I10
  rx2087_done:
    rx2087_cur."!cursor_fail"()
    if_null rx2087_debug, debug_1497
    rx2087_cur."!cursor_debug"("FAIL", "postfix:sym<++>")
  debug_1497:
    .return (rx2087_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<++>"  :subid("328_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("O", "++")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<-->"  :subid("329_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2092_tgt
    .local int rx2092_pos
    .local int rx2092_off
    .local int rx2092_eos
    .local int rx2092_rep
    .local pmc rx2092_cur
    .local pmc rx2092_debug
    (rx2092_cur, rx2092_pos, rx2092_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2092_cur
    .local pmc match
    .lex "$/", match
    length rx2092_eos, rx2092_tgt
    gt rx2092_pos, rx2092_eos, rx2092_done
    set rx2092_off, 0
    lt rx2092_pos, 2, rx2092_start
    sub rx2092_off, rx2092_pos, 1
    substr rx2092_tgt, rx2092_tgt, rx2092_off
  rx2092_start:
    eq $I10, 1, rx2092_restart
    if_null rx2092_debug, debug_1498
    rx2092_cur."!cursor_debug"("START", "postfix:sym<-->")
  debug_1498:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2093_done
    goto rxscan2093_scan
  rxscan2093_loop:
    (rx2092_pos) = rx2092_cur."from"()
    inc rx2092_pos
    rx2092_cur."!cursor_from"(rx2092_pos)
    ge rx2092_pos, rx2092_eos, rxscan2093_done
  rxscan2093_scan:
    set_addr $I10, rxscan2093_loop
    rx2092_cur."!mark_push"(0, rx2092_pos, $I10)
  rxscan2093_done:
.annotate 'line', 1095
  # rx subcapture "sym"
    set_addr $I10, rxcap_2094_fail
    rx2092_cur."!mark_push"(0, rx2092_pos, $I10)
  # rx literal  "--"
    add $I11, rx2092_pos, 2
    gt $I11, rx2092_eos, rx2092_fail
    sub $I11, rx2092_pos, rx2092_off
    substr $S10, rx2092_tgt, $I11, 2
    ne $S10, "--", rx2092_fail
    add rx2092_pos, 2
    set_addr $I10, rxcap_2094_fail
    ($I12, $I11) = rx2092_cur."!mark_peek"($I10)
    rx2092_cur."!cursor_pos"($I11)
    ($P10) = rx2092_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2092_pos, "")
    rx2092_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2094_done
  rxcap_2094_fail:
    goto rx2092_fail
  rxcap_2094_done:
  # rx subrule "O" subtype=capture negate=
    rx2092_cur."!cursor_pos"(rx2092_pos)
    $P10 = rx2092_cur."O"("%autoincrement")
    unless $P10, rx2092_fail
    rx2092_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2092_pos = $P10."pos"()
  # rx pass
    rx2092_cur."!cursor_pass"(rx2092_pos, "postfix:sym<-->")
    if_null rx2092_debug, debug_1499
    rx2092_cur."!cursor_debug"("PASS", "postfix:sym<-->", " at pos=", rx2092_pos)
  debug_1499:
    .return (rx2092_cur)
  rx2092_restart:
.annotate 'line', 435
    if_null rx2092_debug, debug_1500
    rx2092_cur."!cursor_debug"("NEXT", "postfix:sym<-->")
  debug_1500:
  rx2092_fail:
    (rx2092_rep, rx2092_pos, $I10, $P10) = rx2092_cur."!mark_fail"(0)
    lt rx2092_pos, -1, rx2092_done
    eq rx2092_pos, -1, rx2092_fail
    jump $I10
  rx2092_done:
    rx2092_cur."!cursor_fail"()
    if_null rx2092_debug, debug_1501
    rx2092_cur."!cursor_debug"("FAIL", "postfix:sym<-->")
  debug_1501:
    .return (rx2092_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<-->"  :subid("330_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("O", "--")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<**>"  :subid("331_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2097_tgt
    .local int rx2097_pos
    .local int rx2097_off
    .local int rx2097_eos
    .local int rx2097_rep
    .local pmc rx2097_cur
    .local pmc rx2097_debug
    (rx2097_cur, rx2097_pos, rx2097_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2097_cur
    .local pmc match
    .lex "$/", match
    length rx2097_eos, rx2097_tgt
    gt rx2097_pos, rx2097_eos, rx2097_done
    set rx2097_off, 0
    lt rx2097_pos, 2, rx2097_start
    sub rx2097_off, rx2097_pos, 1
    substr rx2097_tgt, rx2097_tgt, rx2097_off
  rx2097_start:
    eq $I10, 1, rx2097_restart
    if_null rx2097_debug, debug_1502
    rx2097_cur."!cursor_debug"("START", "infix:sym<**>")
  debug_1502:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2098_done
    goto rxscan2098_scan
  rxscan2098_loop:
    (rx2097_pos) = rx2097_cur."from"()
    inc rx2097_pos
    rx2097_cur."!cursor_from"(rx2097_pos)
    ge rx2097_pos, rx2097_eos, rxscan2098_done
  rxscan2098_scan:
    set_addr $I10, rxscan2098_loop
    rx2097_cur."!mark_push"(0, rx2097_pos, $I10)
  rxscan2098_done:
.annotate 'line', 1097
  # rx subcapture "sym"
    set_addr $I10, rxcap_2099_fail
    rx2097_cur."!mark_push"(0, rx2097_pos, $I10)
  # rx literal  "**"
    add $I11, rx2097_pos, 2
    gt $I11, rx2097_eos, rx2097_fail
    sub $I11, rx2097_pos, rx2097_off
    substr $S10, rx2097_tgt, $I11, 2
    ne $S10, "**", rx2097_fail
    add rx2097_pos, 2
    set_addr $I10, rxcap_2099_fail
    ($I12, $I11) = rx2097_cur."!mark_peek"($I10)
    rx2097_cur."!cursor_pos"($I11)
    ($P10) = rx2097_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2097_pos, "")
    rx2097_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2099_done
  rxcap_2099_fail:
    goto rx2097_fail
  rxcap_2099_done:
  # rx subrule "O" subtype=capture negate=
    rx2097_cur."!cursor_pos"(rx2097_pos)
    $P10 = rx2097_cur."O"("%exponentiation, :pirop<pow__NNN>")
    unless $P10, rx2097_fail
    rx2097_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2097_pos = $P10."pos"()
  # rx pass
    rx2097_cur."!cursor_pass"(rx2097_pos, "infix:sym<**>")
    if_null rx2097_debug, debug_1503
    rx2097_cur."!cursor_debug"("PASS", "infix:sym<**>", " at pos=", rx2097_pos)
  debug_1503:
    .return (rx2097_cur)
  rx2097_restart:
.annotate 'line', 435
    if_null rx2097_debug, debug_1504
    rx2097_cur."!cursor_debug"("NEXT", "infix:sym<**>")
  debug_1504:
  rx2097_fail:
    (rx2097_rep, rx2097_pos, $I10, $P10) = rx2097_cur."!mark_fail"(0)
    lt rx2097_pos, -1, rx2097_done
    eq rx2097_pos, -1, rx2097_fail
    jump $I10
  rx2097_done:
    rx2097_cur."!cursor_fail"()
    if_null rx2097_debug, debug_1505
    rx2097_cur."!cursor_debug"("FAIL", "infix:sym<**>")
  debug_1505:
    .return (rx2097_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<**>"  :subid("332_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("O", "**")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<+>"  :subid("333_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2102_tgt
    .local int rx2102_pos
    .local int rx2102_off
    .local int rx2102_eos
    .local int rx2102_rep
    .local pmc rx2102_cur
    .local pmc rx2102_debug
    (rx2102_cur, rx2102_pos, rx2102_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2102_cur
    .local pmc match
    .lex "$/", match
    length rx2102_eos, rx2102_tgt
    gt rx2102_pos, rx2102_eos, rx2102_done
    set rx2102_off, 0
    lt rx2102_pos, 2, rx2102_start
    sub rx2102_off, rx2102_pos, 1
    substr rx2102_tgt, rx2102_tgt, rx2102_off
  rx2102_start:
    eq $I10, 1, rx2102_restart
    if_null rx2102_debug, debug_1506
    rx2102_cur."!cursor_debug"("START", "prefix:sym<+>")
  debug_1506:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2103_done
    goto rxscan2103_scan
  rxscan2103_loop:
    (rx2102_pos) = rx2102_cur."from"()
    inc rx2102_pos
    rx2102_cur."!cursor_from"(rx2102_pos)
    ge rx2102_pos, rx2102_eos, rxscan2103_done
  rxscan2103_scan:
    set_addr $I10, rxscan2103_loop
    rx2102_cur."!mark_push"(0, rx2102_pos, $I10)
  rxscan2103_done:
.annotate 'line', 1099
  # rx subcapture "sym"
    set_addr $I10, rxcap_2104_fail
    rx2102_cur."!mark_push"(0, rx2102_pos, $I10)
  # rx literal  "+"
    add $I11, rx2102_pos, 1
    gt $I11, rx2102_eos, rx2102_fail
    sub $I11, rx2102_pos, rx2102_off
    ord $I11, rx2102_tgt, $I11
    ne $I11, 43, rx2102_fail
    add rx2102_pos, 1
    set_addr $I10, rxcap_2104_fail
    ($I12, $I11) = rx2102_cur."!mark_peek"($I10)
    rx2102_cur."!cursor_pos"($I11)
    ($P10) = rx2102_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2102_pos, "")
    rx2102_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2104_done
  rxcap_2104_fail:
    goto rx2102_fail
  rxcap_2104_done:
  # rx subrule "O" subtype=capture negate=
    rx2102_cur."!cursor_pos"(rx2102_pos)
    $P10 = rx2102_cur."O"("%symbolic_unary, :pirop<set N*>")
    unless $P10, rx2102_fail
    rx2102_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2102_pos = $P10."pos"()
  # rx pass
    rx2102_cur."!cursor_pass"(rx2102_pos, "prefix:sym<+>")
    if_null rx2102_debug, debug_1507
    rx2102_cur."!cursor_debug"("PASS", "prefix:sym<+>", " at pos=", rx2102_pos)
  debug_1507:
    .return (rx2102_cur)
  rx2102_restart:
.annotate 'line', 435
    if_null rx2102_debug, debug_1508
    rx2102_cur."!cursor_debug"("NEXT", "prefix:sym<+>")
  debug_1508:
  rx2102_fail:
    (rx2102_rep, rx2102_pos, $I10, $P10) = rx2102_cur."!mark_fail"(0)
    lt rx2102_pos, -1, rx2102_done
    eq rx2102_pos, -1, rx2102_fail
    jump $I10
  rx2102_done:
    rx2102_cur."!cursor_fail"()
    if_null rx2102_debug, debug_1509
    rx2102_cur."!cursor_debug"("FAIL", "prefix:sym<+>")
  debug_1509:
    .return (rx2102_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<+>"  :subid("334_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("O", "+")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<~>"  :subid("335_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2107_tgt
    .local int rx2107_pos
    .local int rx2107_off
    .local int rx2107_eos
    .local int rx2107_rep
    .local pmc rx2107_cur
    .local pmc rx2107_debug
    (rx2107_cur, rx2107_pos, rx2107_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2107_cur
    .local pmc match
    .lex "$/", match
    length rx2107_eos, rx2107_tgt
    gt rx2107_pos, rx2107_eos, rx2107_done
    set rx2107_off, 0
    lt rx2107_pos, 2, rx2107_start
    sub rx2107_off, rx2107_pos, 1
    substr rx2107_tgt, rx2107_tgt, rx2107_off
  rx2107_start:
    eq $I10, 1, rx2107_restart
    if_null rx2107_debug, debug_1510
    rx2107_cur."!cursor_debug"("START", "prefix:sym<~>")
  debug_1510:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2108_done
    goto rxscan2108_scan
  rxscan2108_loop:
    (rx2107_pos) = rx2107_cur."from"()
    inc rx2107_pos
    rx2107_cur."!cursor_from"(rx2107_pos)
    ge rx2107_pos, rx2107_eos, rxscan2108_done
  rxscan2108_scan:
    set_addr $I10, rxscan2108_loop
    rx2107_cur."!mark_push"(0, rx2107_pos, $I10)
  rxscan2108_done:
.annotate 'line', 1100
  # rx subcapture "sym"
    set_addr $I10, rxcap_2109_fail
    rx2107_cur."!mark_push"(0, rx2107_pos, $I10)
  # rx literal  "~"
    add $I11, rx2107_pos, 1
    gt $I11, rx2107_eos, rx2107_fail
    sub $I11, rx2107_pos, rx2107_off
    ord $I11, rx2107_tgt, $I11
    ne $I11, 126, rx2107_fail
    add rx2107_pos, 1
    set_addr $I10, rxcap_2109_fail
    ($I12, $I11) = rx2107_cur."!mark_peek"($I10)
    rx2107_cur."!cursor_pos"($I11)
    ($P10) = rx2107_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2107_pos, "")
    rx2107_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2109_done
  rxcap_2109_fail:
    goto rx2107_fail
  rxcap_2109_done:
  # rx subrule "O" subtype=capture negate=
    rx2107_cur."!cursor_pos"(rx2107_pos)
    $P10 = rx2107_cur."O"("%symbolic_unary, :pirop<set S*>")
    unless $P10, rx2107_fail
    rx2107_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2107_pos = $P10."pos"()
  # rx pass
    rx2107_cur."!cursor_pass"(rx2107_pos, "prefix:sym<~>")
    if_null rx2107_debug, debug_1511
    rx2107_cur."!cursor_debug"("PASS", "prefix:sym<~>", " at pos=", rx2107_pos)
  debug_1511:
    .return (rx2107_cur)
  rx2107_restart:
.annotate 'line', 435
    if_null rx2107_debug, debug_1512
    rx2107_cur."!cursor_debug"("NEXT", "prefix:sym<~>")
  debug_1512:
  rx2107_fail:
    (rx2107_rep, rx2107_pos, $I10, $P10) = rx2107_cur."!mark_fail"(0)
    lt rx2107_pos, -1, rx2107_done
    eq rx2107_pos, -1, rx2107_fail
    jump $I10
  rx2107_done:
    rx2107_cur."!cursor_fail"()
    if_null rx2107_debug, debug_1513
    rx2107_cur."!cursor_debug"("FAIL", "prefix:sym<~>")
  debug_1513:
    .return (rx2107_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<~>"  :subid("336_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("O", "~")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<->"  :subid("337_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2112_tgt
    .local int rx2112_pos
    .local int rx2112_off
    .local int rx2112_eos
    .local int rx2112_rep
    .local pmc rx2112_cur
    .local pmc rx2112_debug
    (rx2112_cur, rx2112_pos, rx2112_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2112_cur
    .local pmc match
    .lex "$/", match
    length rx2112_eos, rx2112_tgt
    gt rx2112_pos, rx2112_eos, rx2112_done
    set rx2112_off, 0
    lt rx2112_pos, 2, rx2112_start
    sub rx2112_off, rx2112_pos, 1
    substr rx2112_tgt, rx2112_tgt, rx2112_off
  rx2112_start:
    eq $I10, 1, rx2112_restart
    if_null rx2112_debug, debug_1514
    rx2112_cur."!cursor_debug"("START", "prefix:sym<->")
  debug_1514:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2113_done
    goto rxscan2113_scan
  rxscan2113_loop:
    (rx2112_pos) = rx2112_cur."from"()
    inc rx2112_pos
    rx2112_cur."!cursor_from"(rx2112_pos)
    ge rx2112_pos, rx2112_eos, rxscan2113_done
  rxscan2113_scan:
    set_addr $I10, rxscan2113_loop
    rx2112_cur."!mark_push"(0, rx2112_pos, $I10)
  rxscan2113_done:
.annotate 'line', 1101
  # rx subcapture "sym"
    set_addr $I10, rxcap_2114_fail
    rx2112_cur."!mark_push"(0, rx2112_pos, $I10)
  # rx literal  "-"
    add $I11, rx2112_pos, 1
    gt $I11, rx2112_eos, rx2112_fail
    sub $I11, rx2112_pos, rx2112_off
    ord $I11, rx2112_tgt, $I11
    ne $I11, 45, rx2112_fail
    add rx2112_pos, 1
    set_addr $I10, rxcap_2114_fail
    ($I12, $I11) = rx2112_cur."!mark_peek"($I10)
    rx2112_cur."!cursor_pos"($I11)
    ($P10) = rx2112_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2112_pos, "")
    rx2112_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2114_done
  rxcap_2114_fail:
    goto rx2112_fail
  rxcap_2114_done:
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx2112_pos, rx2112_off
    substr $S10, rx2112_tgt, $I10, 1
    index $I11, ">", $S10
    ge $I11, 0, rx2112_fail
  # rx subrule "number" subtype=zerowidth negate=1
    rx2112_cur."!cursor_pos"(rx2112_pos)
    $P10 = rx2112_cur."number"()
    if $P10, rx2112_fail
  # rx subrule "O" subtype=capture negate=
    rx2112_cur."!cursor_pos"(rx2112_pos)
    $P10 = rx2112_cur."O"("%symbolic_unary, :pirop<neg>")
    unless $P10, rx2112_fail
    rx2112_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2112_pos = $P10."pos"()
  # rx pass
    rx2112_cur."!cursor_pass"(rx2112_pos, "prefix:sym<->")
    if_null rx2112_debug, debug_1515
    rx2112_cur."!cursor_debug"("PASS", "prefix:sym<->", " at pos=", rx2112_pos)
  debug_1515:
    .return (rx2112_cur)
  rx2112_restart:
.annotate 'line', 435
    if_null rx2112_debug, debug_1516
    rx2112_cur."!cursor_debug"("NEXT", "prefix:sym<->")
  debug_1516:
  rx2112_fail:
    (rx2112_rep, rx2112_pos, $I10, $P10) = rx2112_cur."!mark_fail"(0)
    lt rx2112_pos, -1, rx2112_done
    eq rx2112_pos, -1, rx2112_fail
    jump $I10
  rx2112_done:
    rx2112_cur."!cursor_fail"()
    if_null rx2112_debug, debug_1517
    rx2112_cur."!cursor_debug"("FAIL", "prefix:sym<->")
  debug_1517:
    .return (rx2112_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<->"  :subid("338_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    new $P103, "ResizablePMCArray"
    push $P103, "-"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<?>"  :subid("339_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2117_tgt
    .local int rx2117_pos
    .local int rx2117_off
    .local int rx2117_eos
    .local int rx2117_rep
    .local pmc rx2117_cur
    .local pmc rx2117_debug
    (rx2117_cur, rx2117_pos, rx2117_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2117_cur
    .local pmc match
    .lex "$/", match
    length rx2117_eos, rx2117_tgt
    gt rx2117_pos, rx2117_eos, rx2117_done
    set rx2117_off, 0
    lt rx2117_pos, 2, rx2117_start
    sub rx2117_off, rx2117_pos, 1
    substr rx2117_tgt, rx2117_tgt, rx2117_off
  rx2117_start:
    eq $I10, 1, rx2117_restart
    if_null rx2117_debug, debug_1518
    rx2117_cur."!cursor_debug"("START", "prefix:sym<?>")
  debug_1518:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2118_done
    goto rxscan2118_scan
  rxscan2118_loop:
    (rx2117_pos) = rx2117_cur."from"()
    inc rx2117_pos
    rx2117_cur."!cursor_from"(rx2117_pos)
    ge rx2117_pos, rx2117_eos, rxscan2118_done
  rxscan2118_scan:
    set_addr $I10, rxscan2118_loop
    rx2117_cur."!mark_push"(0, rx2117_pos, $I10)
  rxscan2118_done:
.annotate 'line', 1102
  # rx subcapture "sym"
    set_addr $I10, rxcap_2119_fail
    rx2117_cur."!mark_push"(0, rx2117_pos, $I10)
  # rx literal  "?"
    add $I11, rx2117_pos, 1
    gt $I11, rx2117_eos, rx2117_fail
    sub $I11, rx2117_pos, rx2117_off
    ord $I11, rx2117_tgt, $I11
    ne $I11, 63, rx2117_fail
    add rx2117_pos, 1
    set_addr $I10, rxcap_2119_fail
    ($I12, $I11) = rx2117_cur."!mark_peek"($I10)
    rx2117_cur."!cursor_pos"($I11)
    ($P10) = rx2117_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2117_pos, "")
    rx2117_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2119_done
  rxcap_2119_fail:
    goto rx2117_fail
  rxcap_2119_done:
  # rx subrule "O" subtype=capture negate=
    rx2117_cur."!cursor_pos"(rx2117_pos)
    $P10 = rx2117_cur."O"("%symbolic_unary, :pirop<istrue>")
    unless $P10, rx2117_fail
    rx2117_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2117_pos = $P10."pos"()
  # rx pass
    rx2117_cur."!cursor_pass"(rx2117_pos, "prefix:sym<?>")
    if_null rx2117_debug, debug_1519
    rx2117_cur."!cursor_debug"("PASS", "prefix:sym<?>", " at pos=", rx2117_pos)
  debug_1519:
    .return (rx2117_cur)
  rx2117_restart:
.annotate 'line', 435
    if_null rx2117_debug, debug_1520
    rx2117_cur."!cursor_debug"("NEXT", "prefix:sym<?>")
  debug_1520:
  rx2117_fail:
    (rx2117_rep, rx2117_pos, $I10, $P10) = rx2117_cur."!mark_fail"(0)
    lt rx2117_pos, -1, rx2117_done
    eq rx2117_pos, -1, rx2117_fail
    jump $I10
  rx2117_done:
    rx2117_cur."!cursor_fail"()
    if_null rx2117_debug, debug_1521
    rx2117_cur."!cursor_debug"("FAIL", "prefix:sym<?>")
  debug_1521:
    .return (rx2117_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<?>"  :subid("340_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("O", "?")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<!>"  :subid("341_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2122_tgt
    .local int rx2122_pos
    .local int rx2122_off
    .local int rx2122_eos
    .local int rx2122_rep
    .local pmc rx2122_cur
    .local pmc rx2122_debug
    (rx2122_cur, rx2122_pos, rx2122_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2122_cur
    .local pmc match
    .lex "$/", match
    length rx2122_eos, rx2122_tgt
    gt rx2122_pos, rx2122_eos, rx2122_done
    set rx2122_off, 0
    lt rx2122_pos, 2, rx2122_start
    sub rx2122_off, rx2122_pos, 1
    substr rx2122_tgt, rx2122_tgt, rx2122_off
  rx2122_start:
    eq $I10, 1, rx2122_restart
    if_null rx2122_debug, debug_1522
    rx2122_cur."!cursor_debug"("START", "prefix:sym<!>")
  debug_1522:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2123_done
    goto rxscan2123_scan
  rxscan2123_loop:
    (rx2122_pos) = rx2122_cur."from"()
    inc rx2122_pos
    rx2122_cur."!cursor_from"(rx2122_pos)
    ge rx2122_pos, rx2122_eos, rxscan2123_done
  rxscan2123_scan:
    set_addr $I10, rxscan2123_loop
    rx2122_cur."!mark_push"(0, rx2122_pos, $I10)
  rxscan2123_done:
.annotate 'line', 1103
  # rx subcapture "sym"
    set_addr $I10, rxcap_2124_fail
    rx2122_cur."!mark_push"(0, rx2122_pos, $I10)
  # rx literal  "!"
    add $I11, rx2122_pos, 1
    gt $I11, rx2122_eos, rx2122_fail
    sub $I11, rx2122_pos, rx2122_off
    ord $I11, rx2122_tgt, $I11
    ne $I11, 33, rx2122_fail
    add rx2122_pos, 1
    set_addr $I10, rxcap_2124_fail
    ($I12, $I11) = rx2122_cur."!mark_peek"($I10)
    rx2122_cur."!cursor_pos"($I11)
    ($P10) = rx2122_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2122_pos, "")
    rx2122_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2124_done
  rxcap_2124_fail:
    goto rx2122_fail
  rxcap_2124_done:
  # rx subrule "O" subtype=capture negate=
    rx2122_cur."!cursor_pos"(rx2122_pos)
    $P10 = rx2122_cur."O"("%symbolic_unary, :pirop<isfalse>")
    unless $P10, rx2122_fail
    rx2122_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2122_pos = $P10."pos"()
  # rx pass
    rx2122_cur."!cursor_pass"(rx2122_pos, "prefix:sym<!>")
    if_null rx2122_debug, debug_1523
    rx2122_cur."!cursor_debug"("PASS", "prefix:sym<!>", " at pos=", rx2122_pos)
  debug_1523:
    .return (rx2122_cur)
  rx2122_restart:
.annotate 'line', 435
    if_null rx2122_debug, debug_1524
    rx2122_cur."!cursor_debug"("NEXT", "prefix:sym<!>")
  debug_1524:
  rx2122_fail:
    (rx2122_rep, rx2122_pos, $I10, $P10) = rx2122_cur."!mark_fail"(0)
    lt rx2122_pos, -1, rx2122_done
    eq rx2122_pos, -1, rx2122_fail
    jump $I10
  rx2122_done:
    rx2122_cur."!cursor_fail"()
    if_null rx2122_debug, debug_1525
    rx2122_cur."!cursor_debug"("FAIL", "prefix:sym<!>")
  debug_1525:
    .return (rx2122_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<!>"  :subid("342_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("O", "!")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<|>"  :subid("343_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2127_tgt
    .local int rx2127_pos
    .local int rx2127_off
    .local int rx2127_eos
    .local int rx2127_rep
    .local pmc rx2127_cur
    .local pmc rx2127_debug
    (rx2127_cur, rx2127_pos, rx2127_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2127_cur
    .local pmc match
    .lex "$/", match
    length rx2127_eos, rx2127_tgt
    gt rx2127_pos, rx2127_eos, rx2127_done
    set rx2127_off, 0
    lt rx2127_pos, 2, rx2127_start
    sub rx2127_off, rx2127_pos, 1
    substr rx2127_tgt, rx2127_tgt, rx2127_off
  rx2127_start:
    eq $I10, 1, rx2127_restart
    if_null rx2127_debug, debug_1526
    rx2127_cur."!cursor_debug"("START", "prefix:sym<|>")
  debug_1526:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2128_done
    goto rxscan2128_scan
  rxscan2128_loop:
    (rx2127_pos) = rx2127_cur."from"()
    inc rx2127_pos
    rx2127_cur."!cursor_from"(rx2127_pos)
    ge rx2127_pos, rx2127_eos, rxscan2128_done
  rxscan2128_scan:
    set_addr $I10, rxscan2128_loop
    rx2127_cur."!mark_push"(0, rx2127_pos, $I10)
  rxscan2128_done:
.annotate 'line', 1104
  # rx subcapture "sym"
    set_addr $I10, rxcap_2129_fail
    rx2127_cur."!mark_push"(0, rx2127_pos, $I10)
  # rx literal  "|"
    add $I11, rx2127_pos, 1
    gt $I11, rx2127_eos, rx2127_fail
    sub $I11, rx2127_pos, rx2127_off
    ord $I11, rx2127_tgt, $I11
    ne $I11, 124, rx2127_fail
    add rx2127_pos, 1
    set_addr $I10, rxcap_2129_fail
    ($I12, $I11) = rx2127_cur."!mark_peek"($I10)
    rx2127_cur."!cursor_pos"($I11)
    ($P10) = rx2127_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2127_pos, "")
    rx2127_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2129_done
  rxcap_2129_fail:
    goto rx2127_fail
  rxcap_2129_done:
  # rx subrule "O" subtype=capture negate=
    rx2127_cur."!cursor_pos"(rx2127_pos)
    $P10 = rx2127_cur."O"("%symbolic_unary")
    unless $P10, rx2127_fail
    rx2127_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2127_pos = $P10."pos"()
  # rx pass
    rx2127_cur."!cursor_pass"(rx2127_pos, "prefix:sym<|>")
    if_null rx2127_debug, debug_1527
    rx2127_cur."!cursor_debug"("PASS", "prefix:sym<|>", " at pos=", rx2127_pos)
  debug_1527:
    .return (rx2127_cur)
  rx2127_restart:
.annotate 'line', 435
    if_null rx2127_debug, debug_1528
    rx2127_cur."!cursor_debug"("NEXT", "prefix:sym<|>")
  debug_1528:
  rx2127_fail:
    (rx2127_rep, rx2127_pos, $I10, $P10) = rx2127_cur."!mark_fail"(0)
    lt rx2127_pos, -1, rx2127_done
    eq rx2127_pos, -1, rx2127_fail
    jump $I10
  rx2127_done:
    rx2127_cur."!cursor_fail"()
    if_null rx2127_debug, debug_1529
    rx2127_cur."!cursor_debug"("FAIL", "prefix:sym<|>")
  debug_1529:
    .return (rx2127_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<|>"  :subid("344_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("O", "|")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<*>"  :subid("345_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2132_tgt
    .local int rx2132_pos
    .local int rx2132_off
    .local int rx2132_eos
    .local int rx2132_rep
    .local pmc rx2132_cur
    .local pmc rx2132_debug
    (rx2132_cur, rx2132_pos, rx2132_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2132_cur
    .local pmc match
    .lex "$/", match
    length rx2132_eos, rx2132_tgt
    gt rx2132_pos, rx2132_eos, rx2132_done
    set rx2132_off, 0
    lt rx2132_pos, 2, rx2132_start
    sub rx2132_off, rx2132_pos, 1
    substr rx2132_tgt, rx2132_tgt, rx2132_off
  rx2132_start:
    eq $I10, 1, rx2132_restart
    if_null rx2132_debug, debug_1530
    rx2132_cur."!cursor_debug"("START", "infix:sym<*>")
  debug_1530:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2133_done
    goto rxscan2133_scan
  rxscan2133_loop:
    (rx2132_pos) = rx2132_cur."from"()
    inc rx2132_pos
    rx2132_cur."!cursor_from"(rx2132_pos)
    ge rx2132_pos, rx2132_eos, rxscan2133_done
  rxscan2133_scan:
    set_addr $I10, rxscan2133_loop
    rx2132_cur."!mark_push"(0, rx2132_pos, $I10)
  rxscan2133_done:
.annotate 'line', 1106
  # rx subcapture "sym"
    set_addr $I10, rxcap_2134_fail
    rx2132_cur."!mark_push"(0, rx2132_pos, $I10)
  # rx literal  "*"
    add $I11, rx2132_pos, 1
    gt $I11, rx2132_eos, rx2132_fail
    sub $I11, rx2132_pos, rx2132_off
    ord $I11, rx2132_tgt, $I11
    ne $I11, 42, rx2132_fail
    add rx2132_pos, 1
    set_addr $I10, rxcap_2134_fail
    ($I12, $I11) = rx2132_cur."!mark_peek"($I10)
    rx2132_cur."!cursor_pos"($I11)
    ($P10) = rx2132_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2132_pos, "")
    rx2132_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2134_done
  rxcap_2134_fail:
    goto rx2132_fail
  rxcap_2134_done:
  # rx subrule "O" subtype=capture negate=
    rx2132_cur."!cursor_pos"(rx2132_pos)
    $P10 = rx2132_cur."O"("%multiplicative, :pirop<mul>")
    unless $P10, rx2132_fail
    rx2132_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2132_pos = $P10."pos"()
  # rx pass
    rx2132_cur."!cursor_pass"(rx2132_pos, "infix:sym<*>")
    if_null rx2132_debug, debug_1531
    rx2132_cur."!cursor_debug"("PASS", "infix:sym<*>", " at pos=", rx2132_pos)
  debug_1531:
    .return (rx2132_cur)
  rx2132_restart:
.annotate 'line', 435
    if_null rx2132_debug, debug_1532
    rx2132_cur."!cursor_debug"("NEXT", "infix:sym<*>")
  debug_1532:
  rx2132_fail:
    (rx2132_rep, rx2132_pos, $I10, $P10) = rx2132_cur."!mark_fail"(0)
    lt rx2132_pos, -1, rx2132_done
    eq rx2132_pos, -1, rx2132_fail
    jump $I10
  rx2132_done:
    rx2132_cur."!cursor_fail"()
    if_null rx2132_debug, debug_1533
    rx2132_cur."!cursor_debug"("FAIL", "infix:sym<*>")
  debug_1533:
    .return (rx2132_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<*>"  :subid("346_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("O", "*")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym</>"  :subid("347_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2137_tgt
    .local int rx2137_pos
    .local int rx2137_off
    .local int rx2137_eos
    .local int rx2137_rep
    .local pmc rx2137_cur
    .local pmc rx2137_debug
    (rx2137_cur, rx2137_pos, rx2137_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2137_cur
    .local pmc match
    .lex "$/", match
    length rx2137_eos, rx2137_tgt
    gt rx2137_pos, rx2137_eos, rx2137_done
    set rx2137_off, 0
    lt rx2137_pos, 2, rx2137_start
    sub rx2137_off, rx2137_pos, 1
    substr rx2137_tgt, rx2137_tgt, rx2137_off
  rx2137_start:
    eq $I10, 1, rx2137_restart
    if_null rx2137_debug, debug_1534
    rx2137_cur."!cursor_debug"("START", "infix:sym</>")
  debug_1534:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2138_done
    goto rxscan2138_scan
  rxscan2138_loop:
    (rx2137_pos) = rx2137_cur."from"()
    inc rx2137_pos
    rx2137_cur."!cursor_from"(rx2137_pos)
    ge rx2137_pos, rx2137_eos, rxscan2138_done
  rxscan2138_scan:
    set_addr $I10, rxscan2138_loop
    rx2137_cur."!mark_push"(0, rx2137_pos, $I10)
  rxscan2138_done:
.annotate 'line', 1107
  # rx subcapture "sym"
    set_addr $I10, rxcap_2139_fail
    rx2137_cur."!mark_push"(0, rx2137_pos, $I10)
  # rx literal  "/"
    add $I11, rx2137_pos, 1
    gt $I11, rx2137_eos, rx2137_fail
    sub $I11, rx2137_pos, rx2137_off
    ord $I11, rx2137_tgt, $I11
    ne $I11, 47, rx2137_fail
    add rx2137_pos, 1
    set_addr $I10, rxcap_2139_fail
    ($I12, $I11) = rx2137_cur."!mark_peek"($I10)
    rx2137_cur."!cursor_pos"($I11)
    ($P10) = rx2137_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2137_pos, "")
    rx2137_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2139_done
  rxcap_2139_fail:
    goto rx2137_fail
  rxcap_2139_done:
  # rx subrule "O" subtype=capture negate=
    rx2137_cur."!cursor_pos"(rx2137_pos)
    $P10 = rx2137_cur."O"("%multiplicative, :pirop<div>")
    unless $P10, rx2137_fail
    rx2137_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2137_pos = $P10."pos"()
  # rx pass
    rx2137_cur."!cursor_pass"(rx2137_pos, "infix:sym</>")
    if_null rx2137_debug, debug_1535
    rx2137_cur."!cursor_debug"("PASS", "infix:sym</>", " at pos=", rx2137_pos)
  debug_1535:
    .return (rx2137_cur)
  rx2137_restart:
.annotate 'line', 435
    if_null rx2137_debug, debug_1536
    rx2137_cur."!cursor_debug"("NEXT", "infix:sym</>")
  debug_1536:
  rx2137_fail:
    (rx2137_rep, rx2137_pos, $I10, $P10) = rx2137_cur."!mark_fail"(0)
    lt rx2137_pos, -1, rx2137_done
    eq rx2137_pos, -1, rx2137_fail
    jump $I10
  rx2137_done:
    rx2137_cur."!cursor_fail"()
    if_null rx2137_debug, debug_1537
    rx2137_cur."!cursor_debug"("FAIL", "infix:sym</>")
  debug_1537:
    .return (rx2137_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym</>"  :subid("348_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("O", "/")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<%>"  :subid("349_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2142_tgt
    .local int rx2142_pos
    .local int rx2142_off
    .local int rx2142_eos
    .local int rx2142_rep
    .local pmc rx2142_cur
    .local pmc rx2142_debug
    (rx2142_cur, rx2142_pos, rx2142_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2142_cur
    .local pmc match
    .lex "$/", match
    length rx2142_eos, rx2142_tgt
    gt rx2142_pos, rx2142_eos, rx2142_done
    set rx2142_off, 0
    lt rx2142_pos, 2, rx2142_start
    sub rx2142_off, rx2142_pos, 1
    substr rx2142_tgt, rx2142_tgt, rx2142_off
  rx2142_start:
    eq $I10, 1, rx2142_restart
    if_null rx2142_debug, debug_1538
    rx2142_cur."!cursor_debug"("START", "infix:sym<%>")
  debug_1538:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2143_done
    goto rxscan2143_scan
  rxscan2143_loop:
    (rx2142_pos) = rx2142_cur."from"()
    inc rx2142_pos
    rx2142_cur."!cursor_from"(rx2142_pos)
    ge rx2142_pos, rx2142_eos, rxscan2143_done
  rxscan2143_scan:
    set_addr $I10, rxscan2143_loop
    rx2142_cur."!mark_push"(0, rx2142_pos, $I10)
  rxscan2143_done:
.annotate 'line', 1108
  # rx subcapture "sym"
    set_addr $I10, rxcap_2144_fail
    rx2142_cur."!mark_push"(0, rx2142_pos, $I10)
  # rx literal  "%"
    add $I11, rx2142_pos, 1
    gt $I11, rx2142_eos, rx2142_fail
    sub $I11, rx2142_pos, rx2142_off
    ord $I11, rx2142_tgt, $I11
    ne $I11, 37, rx2142_fail
    add rx2142_pos, 1
    set_addr $I10, rxcap_2144_fail
    ($I12, $I11) = rx2142_cur."!mark_peek"($I10)
    rx2142_cur."!cursor_pos"($I11)
    ($P10) = rx2142_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2142_pos, "")
    rx2142_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2144_done
  rxcap_2144_fail:
    goto rx2142_fail
  rxcap_2144_done:
  # rx subrule "O" subtype=capture negate=
    rx2142_cur."!cursor_pos"(rx2142_pos)
    $P10 = rx2142_cur."O"("%multiplicative, :pirop<mod>")
    unless $P10, rx2142_fail
    rx2142_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2142_pos = $P10."pos"()
  # rx pass
    rx2142_cur."!cursor_pass"(rx2142_pos, "infix:sym<%>")
    if_null rx2142_debug, debug_1539
    rx2142_cur."!cursor_debug"("PASS", "infix:sym<%>", " at pos=", rx2142_pos)
  debug_1539:
    .return (rx2142_cur)
  rx2142_restart:
.annotate 'line', 435
    if_null rx2142_debug, debug_1540
    rx2142_cur."!cursor_debug"("NEXT", "infix:sym<%>")
  debug_1540:
  rx2142_fail:
    (rx2142_rep, rx2142_pos, $I10, $P10) = rx2142_cur."!mark_fail"(0)
    lt rx2142_pos, -1, rx2142_done
    eq rx2142_pos, -1, rx2142_fail
    jump $I10
  rx2142_done:
    rx2142_cur."!cursor_fail"()
    if_null rx2142_debug, debug_1541
    rx2142_cur."!cursor_debug"("FAIL", "infix:sym<%>")
  debug_1541:
    .return (rx2142_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<%>"  :subid("350_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("O", "%")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+&>"  :subid("351_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2147_tgt
    .local int rx2147_pos
    .local int rx2147_off
    .local int rx2147_eos
    .local int rx2147_rep
    .local pmc rx2147_cur
    .local pmc rx2147_debug
    (rx2147_cur, rx2147_pos, rx2147_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2147_cur
    .local pmc match
    .lex "$/", match
    length rx2147_eos, rx2147_tgt
    gt rx2147_pos, rx2147_eos, rx2147_done
    set rx2147_off, 0
    lt rx2147_pos, 2, rx2147_start
    sub rx2147_off, rx2147_pos, 1
    substr rx2147_tgt, rx2147_tgt, rx2147_off
  rx2147_start:
    eq $I10, 1, rx2147_restart
    if_null rx2147_debug, debug_1542
    rx2147_cur."!cursor_debug"("START", "infix:sym<+&>")
  debug_1542:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2148_done
    goto rxscan2148_scan
  rxscan2148_loop:
    (rx2147_pos) = rx2147_cur."from"()
    inc rx2147_pos
    rx2147_cur."!cursor_from"(rx2147_pos)
    ge rx2147_pos, rx2147_eos, rxscan2148_done
  rxscan2148_scan:
    set_addr $I10, rxscan2148_loop
    rx2147_cur."!mark_push"(0, rx2147_pos, $I10)
  rxscan2148_done:
.annotate 'line', 1109
  # rx subcapture "sym"
    set_addr $I10, rxcap_2149_fail
    rx2147_cur."!mark_push"(0, rx2147_pos, $I10)
  # rx literal  "+&"
    add $I11, rx2147_pos, 2
    gt $I11, rx2147_eos, rx2147_fail
    sub $I11, rx2147_pos, rx2147_off
    substr $S10, rx2147_tgt, $I11, 2
    ne $S10, "+&", rx2147_fail
    add rx2147_pos, 2
    set_addr $I10, rxcap_2149_fail
    ($I12, $I11) = rx2147_cur."!mark_peek"($I10)
    rx2147_cur."!cursor_pos"($I11)
    ($P10) = rx2147_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2147_pos, "")
    rx2147_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2149_done
  rxcap_2149_fail:
    goto rx2147_fail
  rxcap_2149_done:
  # rx subrule "O" subtype=capture negate=
    rx2147_cur."!cursor_pos"(rx2147_pos)
    $P10 = rx2147_cur."O"("%multiplicative, :pirop<band III>")
    unless $P10, rx2147_fail
    rx2147_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2147_pos = $P10."pos"()
  # rx pass
    rx2147_cur."!cursor_pass"(rx2147_pos, "infix:sym<+&>")
    if_null rx2147_debug, debug_1543
    rx2147_cur."!cursor_debug"("PASS", "infix:sym<+&>", " at pos=", rx2147_pos)
  debug_1543:
    .return (rx2147_cur)
  rx2147_restart:
.annotate 'line', 435
    if_null rx2147_debug, debug_1544
    rx2147_cur."!cursor_debug"("NEXT", "infix:sym<+&>")
  debug_1544:
  rx2147_fail:
    (rx2147_rep, rx2147_pos, $I10, $P10) = rx2147_cur."!mark_fail"(0)
    lt rx2147_pos, -1, rx2147_done
    eq rx2147_pos, -1, rx2147_fail
    jump $I10
  rx2147_done:
    rx2147_cur."!cursor_fail"()
    if_null rx2147_debug, debug_1545
    rx2147_cur."!cursor_debug"("FAIL", "infix:sym<+&>")
  debug_1545:
    .return (rx2147_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+&>"  :subid("352_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("O", "+&")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+>"  :subid("353_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2152_tgt
    .local int rx2152_pos
    .local int rx2152_off
    .local int rx2152_eos
    .local int rx2152_rep
    .local pmc rx2152_cur
    .local pmc rx2152_debug
    (rx2152_cur, rx2152_pos, rx2152_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2152_cur
    .local pmc match
    .lex "$/", match
    length rx2152_eos, rx2152_tgt
    gt rx2152_pos, rx2152_eos, rx2152_done
    set rx2152_off, 0
    lt rx2152_pos, 2, rx2152_start
    sub rx2152_off, rx2152_pos, 1
    substr rx2152_tgt, rx2152_tgt, rx2152_off
  rx2152_start:
    eq $I10, 1, rx2152_restart
    if_null rx2152_debug, debug_1546
    rx2152_cur."!cursor_debug"("START", "infix:sym<+>")
  debug_1546:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2153_done
    goto rxscan2153_scan
  rxscan2153_loop:
    (rx2152_pos) = rx2152_cur."from"()
    inc rx2152_pos
    rx2152_cur."!cursor_from"(rx2152_pos)
    ge rx2152_pos, rx2152_eos, rxscan2153_done
  rxscan2153_scan:
    set_addr $I10, rxscan2153_loop
    rx2152_cur."!mark_push"(0, rx2152_pos, $I10)
  rxscan2153_done:
.annotate 'line', 1111
  # rx subcapture "sym"
    set_addr $I10, rxcap_2154_fail
    rx2152_cur."!mark_push"(0, rx2152_pos, $I10)
  # rx literal  "+"
    add $I11, rx2152_pos, 1
    gt $I11, rx2152_eos, rx2152_fail
    sub $I11, rx2152_pos, rx2152_off
    ord $I11, rx2152_tgt, $I11
    ne $I11, 43, rx2152_fail
    add rx2152_pos, 1
    set_addr $I10, rxcap_2154_fail
    ($I12, $I11) = rx2152_cur."!mark_peek"($I10)
    rx2152_cur."!cursor_pos"($I11)
    ($P10) = rx2152_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2152_pos, "")
    rx2152_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2154_done
  rxcap_2154_fail:
    goto rx2152_fail
  rxcap_2154_done:
  # rx subrule "O" subtype=capture negate=
    rx2152_cur."!cursor_pos"(rx2152_pos)
    $P10 = rx2152_cur."O"("%additive, :pirop<add>")
    unless $P10, rx2152_fail
    rx2152_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2152_pos = $P10."pos"()
  # rx pass
    rx2152_cur."!cursor_pass"(rx2152_pos, "infix:sym<+>")
    if_null rx2152_debug, debug_1547
    rx2152_cur."!cursor_debug"("PASS", "infix:sym<+>", " at pos=", rx2152_pos)
  debug_1547:
    .return (rx2152_cur)
  rx2152_restart:
.annotate 'line', 435
    if_null rx2152_debug, debug_1548
    rx2152_cur."!cursor_debug"("NEXT", "infix:sym<+>")
  debug_1548:
  rx2152_fail:
    (rx2152_rep, rx2152_pos, $I10, $P10) = rx2152_cur."!mark_fail"(0)
    lt rx2152_pos, -1, rx2152_done
    eq rx2152_pos, -1, rx2152_fail
    jump $I10
  rx2152_done:
    rx2152_cur."!cursor_fail"()
    if_null rx2152_debug, debug_1549
    rx2152_cur."!cursor_debug"("FAIL", "infix:sym<+>")
  debug_1549:
    .return (rx2152_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+>"  :subid("354_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("O", "+")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<->"  :subid("355_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2157_tgt
    .local int rx2157_pos
    .local int rx2157_off
    .local int rx2157_eos
    .local int rx2157_rep
    .local pmc rx2157_cur
    .local pmc rx2157_debug
    (rx2157_cur, rx2157_pos, rx2157_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2157_cur
    .local pmc match
    .lex "$/", match
    length rx2157_eos, rx2157_tgt
    gt rx2157_pos, rx2157_eos, rx2157_done
    set rx2157_off, 0
    lt rx2157_pos, 2, rx2157_start
    sub rx2157_off, rx2157_pos, 1
    substr rx2157_tgt, rx2157_tgt, rx2157_off
  rx2157_start:
    eq $I10, 1, rx2157_restart
    if_null rx2157_debug, debug_1550
    rx2157_cur."!cursor_debug"("START", "infix:sym<->")
  debug_1550:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2158_done
    goto rxscan2158_scan
  rxscan2158_loop:
    (rx2157_pos) = rx2157_cur."from"()
    inc rx2157_pos
    rx2157_cur."!cursor_from"(rx2157_pos)
    ge rx2157_pos, rx2157_eos, rxscan2158_done
  rxscan2158_scan:
    set_addr $I10, rxscan2158_loop
    rx2157_cur."!mark_push"(0, rx2157_pos, $I10)
  rxscan2158_done:
.annotate 'line', 1112
  # rx subcapture "sym"
    set_addr $I10, rxcap_2159_fail
    rx2157_cur."!mark_push"(0, rx2157_pos, $I10)
  # rx literal  "-"
    add $I11, rx2157_pos, 1
    gt $I11, rx2157_eos, rx2157_fail
    sub $I11, rx2157_pos, rx2157_off
    ord $I11, rx2157_tgt, $I11
    ne $I11, 45, rx2157_fail
    add rx2157_pos, 1
    set_addr $I10, rxcap_2159_fail
    ($I12, $I11) = rx2157_cur."!mark_peek"($I10)
    rx2157_cur."!cursor_pos"($I11)
    ($P10) = rx2157_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2157_pos, "")
    rx2157_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2159_done
  rxcap_2159_fail:
    goto rx2157_fail
  rxcap_2159_done:
  # rx subrule "O" subtype=capture negate=
    rx2157_cur."!cursor_pos"(rx2157_pos)
    $P10 = rx2157_cur."O"("%additive, :pirop<sub>")
    unless $P10, rx2157_fail
    rx2157_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2157_pos = $P10."pos"()
  # rx pass
    rx2157_cur."!cursor_pass"(rx2157_pos, "infix:sym<->")
    if_null rx2157_debug, debug_1551
    rx2157_cur."!cursor_debug"("PASS", "infix:sym<->", " at pos=", rx2157_pos)
  debug_1551:
    .return (rx2157_cur)
  rx2157_restart:
.annotate 'line', 435
    if_null rx2157_debug, debug_1552
    rx2157_cur."!cursor_debug"("NEXT", "infix:sym<->")
  debug_1552:
  rx2157_fail:
    (rx2157_rep, rx2157_pos, $I10, $P10) = rx2157_cur."!mark_fail"(0)
    lt rx2157_pos, -1, rx2157_done
    eq rx2157_pos, -1, rx2157_fail
    jump $I10
  rx2157_done:
    rx2157_cur."!cursor_fail"()
    if_null rx2157_debug, debug_1553
    rx2157_cur."!cursor_debug"("FAIL", "infix:sym<->")
  debug_1553:
    .return (rx2157_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<->"  :subid("356_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("O", "-")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+|>"  :subid("357_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2162_tgt
    .local int rx2162_pos
    .local int rx2162_off
    .local int rx2162_eos
    .local int rx2162_rep
    .local pmc rx2162_cur
    .local pmc rx2162_debug
    (rx2162_cur, rx2162_pos, rx2162_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2162_cur
    .local pmc match
    .lex "$/", match
    length rx2162_eos, rx2162_tgt
    gt rx2162_pos, rx2162_eos, rx2162_done
    set rx2162_off, 0
    lt rx2162_pos, 2, rx2162_start
    sub rx2162_off, rx2162_pos, 1
    substr rx2162_tgt, rx2162_tgt, rx2162_off
  rx2162_start:
    eq $I10, 1, rx2162_restart
    if_null rx2162_debug, debug_1554
    rx2162_cur."!cursor_debug"("START", "infix:sym<+|>")
  debug_1554:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2163_done
    goto rxscan2163_scan
  rxscan2163_loop:
    (rx2162_pos) = rx2162_cur."from"()
    inc rx2162_pos
    rx2162_cur."!cursor_from"(rx2162_pos)
    ge rx2162_pos, rx2162_eos, rxscan2163_done
  rxscan2163_scan:
    set_addr $I10, rxscan2163_loop
    rx2162_cur."!mark_push"(0, rx2162_pos, $I10)
  rxscan2163_done:
.annotate 'line', 1113
  # rx subcapture "sym"
    set_addr $I10, rxcap_2164_fail
    rx2162_cur."!mark_push"(0, rx2162_pos, $I10)
  # rx literal  "+|"
    add $I11, rx2162_pos, 2
    gt $I11, rx2162_eos, rx2162_fail
    sub $I11, rx2162_pos, rx2162_off
    substr $S10, rx2162_tgt, $I11, 2
    ne $S10, "+|", rx2162_fail
    add rx2162_pos, 2
    set_addr $I10, rxcap_2164_fail
    ($I12, $I11) = rx2162_cur."!mark_peek"($I10)
    rx2162_cur."!cursor_pos"($I11)
    ($P10) = rx2162_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2162_pos, "")
    rx2162_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2164_done
  rxcap_2164_fail:
    goto rx2162_fail
  rxcap_2164_done:
  # rx subrule "O" subtype=capture negate=
    rx2162_cur."!cursor_pos"(rx2162_pos)
    $P10 = rx2162_cur."O"("%additive, :pirop<bor III>")
    unless $P10, rx2162_fail
    rx2162_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2162_pos = $P10."pos"()
  # rx pass
    rx2162_cur."!cursor_pass"(rx2162_pos, "infix:sym<+|>")
    if_null rx2162_debug, debug_1555
    rx2162_cur."!cursor_debug"("PASS", "infix:sym<+|>", " at pos=", rx2162_pos)
  debug_1555:
    .return (rx2162_cur)
  rx2162_restart:
.annotate 'line', 435
    if_null rx2162_debug, debug_1556
    rx2162_cur."!cursor_debug"("NEXT", "infix:sym<+|>")
  debug_1556:
  rx2162_fail:
    (rx2162_rep, rx2162_pos, $I10, $P10) = rx2162_cur."!mark_fail"(0)
    lt rx2162_pos, -1, rx2162_done
    eq rx2162_pos, -1, rx2162_fail
    jump $I10
  rx2162_done:
    rx2162_cur."!cursor_fail"()
    if_null rx2162_debug, debug_1557
    rx2162_cur."!cursor_debug"("FAIL", "infix:sym<+|>")
  debug_1557:
    .return (rx2162_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+|>"  :subid("358_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("O", "+|")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+^>"  :subid("359_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2167_tgt
    .local int rx2167_pos
    .local int rx2167_off
    .local int rx2167_eos
    .local int rx2167_rep
    .local pmc rx2167_cur
    .local pmc rx2167_debug
    (rx2167_cur, rx2167_pos, rx2167_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2167_cur
    .local pmc match
    .lex "$/", match
    length rx2167_eos, rx2167_tgt
    gt rx2167_pos, rx2167_eos, rx2167_done
    set rx2167_off, 0
    lt rx2167_pos, 2, rx2167_start
    sub rx2167_off, rx2167_pos, 1
    substr rx2167_tgt, rx2167_tgt, rx2167_off
  rx2167_start:
    eq $I10, 1, rx2167_restart
    if_null rx2167_debug, debug_1558
    rx2167_cur."!cursor_debug"("START", "infix:sym<+^>")
  debug_1558:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2168_done
    goto rxscan2168_scan
  rxscan2168_loop:
    (rx2167_pos) = rx2167_cur."from"()
    inc rx2167_pos
    rx2167_cur."!cursor_from"(rx2167_pos)
    ge rx2167_pos, rx2167_eos, rxscan2168_done
  rxscan2168_scan:
    set_addr $I10, rxscan2168_loop
    rx2167_cur."!mark_push"(0, rx2167_pos, $I10)
  rxscan2168_done:
.annotate 'line', 1114
  # rx subcapture "sym"
    set_addr $I10, rxcap_2169_fail
    rx2167_cur."!mark_push"(0, rx2167_pos, $I10)
  # rx literal  "+^"
    add $I11, rx2167_pos, 2
    gt $I11, rx2167_eos, rx2167_fail
    sub $I11, rx2167_pos, rx2167_off
    substr $S10, rx2167_tgt, $I11, 2
    ne $S10, "+^", rx2167_fail
    add rx2167_pos, 2
    set_addr $I10, rxcap_2169_fail
    ($I12, $I11) = rx2167_cur."!mark_peek"($I10)
    rx2167_cur."!cursor_pos"($I11)
    ($P10) = rx2167_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2167_pos, "")
    rx2167_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2169_done
  rxcap_2169_fail:
    goto rx2167_fail
  rxcap_2169_done:
  # rx subrule "O" subtype=capture negate=
    rx2167_cur."!cursor_pos"(rx2167_pos)
    $P10 = rx2167_cur."O"("%additive, :pirop<bxor III>")
    unless $P10, rx2167_fail
    rx2167_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2167_pos = $P10."pos"()
  # rx pass
    rx2167_cur."!cursor_pass"(rx2167_pos, "infix:sym<+^>")
    if_null rx2167_debug, debug_1559
    rx2167_cur."!cursor_debug"("PASS", "infix:sym<+^>", " at pos=", rx2167_pos)
  debug_1559:
    .return (rx2167_cur)
  rx2167_restart:
.annotate 'line', 435
    if_null rx2167_debug, debug_1560
    rx2167_cur."!cursor_debug"("NEXT", "infix:sym<+^>")
  debug_1560:
  rx2167_fail:
    (rx2167_rep, rx2167_pos, $I10, $P10) = rx2167_cur."!mark_fail"(0)
    lt rx2167_pos, -1, rx2167_done
    eq rx2167_pos, -1, rx2167_fail
    jump $I10
  rx2167_done:
    rx2167_cur."!cursor_fail"()
    if_null rx2167_debug, debug_1561
    rx2167_cur."!cursor_debug"("FAIL", "infix:sym<+^>")
  debug_1561:
    .return (rx2167_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+^>"  :subid("360_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("O", "+^")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~>"  :subid("361_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2172_tgt
    .local int rx2172_pos
    .local int rx2172_off
    .local int rx2172_eos
    .local int rx2172_rep
    .local pmc rx2172_cur
    .local pmc rx2172_debug
    (rx2172_cur, rx2172_pos, rx2172_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2172_cur
    .local pmc match
    .lex "$/", match
    length rx2172_eos, rx2172_tgt
    gt rx2172_pos, rx2172_eos, rx2172_done
    set rx2172_off, 0
    lt rx2172_pos, 2, rx2172_start
    sub rx2172_off, rx2172_pos, 1
    substr rx2172_tgt, rx2172_tgt, rx2172_off
  rx2172_start:
    eq $I10, 1, rx2172_restart
    if_null rx2172_debug, debug_1562
    rx2172_cur."!cursor_debug"("START", "infix:sym<~>")
  debug_1562:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2173_done
    goto rxscan2173_scan
  rxscan2173_loop:
    (rx2172_pos) = rx2172_cur."from"()
    inc rx2172_pos
    rx2172_cur."!cursor_from"(rx2172_pos)
    ge rx2172_pos, rx2172_eos, rxscan2173_done
  rxscan2173_scan:
    set_addr $I10, rxscan2173_loop
    rx2172_cur."!mark_push"(0, rx2172_pos, $I10)
  rxscan2173_done:
.annotate 'line', 1116
  # rx subcapture "sym"
    set_addr $I10, rxcap_2174_fail
    rx2172_cur."!mark_push"(0, rx2172_pos, $I10)
  # rx literal  "~"
    add $I11, rx2172_pos, 1
    gt $I11, rx2172_eos, rx2172_fail
    sub $I11, rx2172_pos, rx2172_off
    ord $I11, rx2172_tgt, $I11
    ne $I11, 126, rx2172_fail
    add rx2172_pos, 1
    set_addr $I10, rxcap_2174_fail
    ($I12, $I11) = rx2172_cur."!mark_peek"($I10)
    rx2172_cur."!cursor_pos"($I11)
    ($P10) = rx2172_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2172_pos, "")
    rx2172_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2174_done
  rxcap_2174_fail:
    goto rx2172_fail
  rxcap_2174_done:
  # rx subrule "O" subtype=capture negate=
    rx2172_cur."!cursor_pos"(rx2172_pos)
    $P10 = rx2172_cur."O"("%concatenation , :pirop<concat>")
    unless $P10, rx2172_fail
    rx2172_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2172_pos = $P10."pos"()
  # rx pass
    rx2172_cur."!cursor_pass"(rx2172_pos, "infix:sym<~>")
    if_null rx2172_debug, debug_1563
    rx2172_cur."!cursor_debug"("PASS", "infix:sym<~>", " at pos=", rx2172_pos)
  debug_1563:
    .return (rx2172_cur)
  rx2172_restart:
.annotate 'line', 435
    if_null rx2172_debug, debug_1564
    rx2172_cur."!cursor_debug"("NEXT", "infix:sym<~>")
  debug_1564:
  rx2172_fail:
    (rx2172_rep, rx2172_pos, $I10, $P10) = rx2172_cur."!mark_fail"(0)
    lt rx2172_pos, -1, rx2172_done
    eq rx2172_pos, -1, rx2172_fail
    jump $I10
  rx2172_done:
    rx2172_cur."!cursor_fail"()
    if_null rx2172_debug, debug_1565
    rx2172_cur."!cursor_debug"("FAIL", "infix:sym<~>")
  debug_1565:
    .return (rx2172_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~>"  :subid("362_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("O", "~")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<==>"  :subid("363_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2177_tgt
    .local int rx2177_pos
    .local int rx2177_off
    .local int rx2177_eos
    .local int rx2177_rep
    .local pmc rx2177_cur
    .local pmc rx2177_debug
    (rx2177_cur, rx2177_pos, rx2177_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2177_cur
    .local pmc match
    .lex "$/", match
    length rx2177_eos, rx2177_tgt
    gt rx2177_pos, rx2177_eos, rx2177_done
    set rx2177_off, 0
    lt rx2177_pos, 2, rx2177_start
    sub rx2177_off, rx2177_pos, 1
    substr rx2177_tgt, rx2177_tgt, rx2177_off
  rx2177_start:
    eq $I10, 1, rx2177_restart
    if_null rx2177_debug, debug_1566
    rx2177_cur."!cursor_debug"("START", "infix:sym<==>")
  debug_1566:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2178_done
    goto rxscan2178_scan
  rxscan2178_loop:
    (rx2177_pos) = rx2177_cur."from"()
    inc rx2177_pos
    rx2177_cur."!cursor_from"(rx2177_pos)
    ge rx2177_pos, rx2177_eos, rxscan2178_done
  rxscan2178_scan:
    set_addr $I10, rxscan2178_loop
    rx2177_cur."!mark_push"(0, rx2177_pos, $I10)
  rxscan2178_done:
.annotate 'line', 1118
  # rx subcapture "sym"
    set_addr $I10, rxcap_2179_fail
    rx2177_cur."!mark_push"(0, rx2177_pos, $I10)
  # rx literal  "=="
    add $I11, rx2177_pos, 2
    gt $I11, rx2177_eos, rx2177_fail
    sub $I11, rx2177_pos, rx2177_off
    substr $S10, rx2177_tgt, $I11, 2
    ne $S10, "==", rx2177_fail
    add rx2177_pos, 2
    set_addr $I10, rxcap_2179_fail
    ($I12, $I11) = rx2177_cur."!mark_peek"($I10)
    rx2177_cur."!cursor_pos"($I11)
    ($P10) = rx2177_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2177_pos, "")
    rx2177_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2179_done
  rxcap_2179_fail:
    goto rx2177_fail
  rxcap_2179_done:
  # rx subrule "O" subtype=capture negate=
    rx2177_cur."!cursor_pos"(rx2177_pos)
    $P10 = rx2177_cur."O"("%relational, :pirop<iseq INn>")
    unless $P10, rx2177_fail
    rx2177_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2177_pos = $P10."pos"()
  # rx pass
    rx2177_cur."!cursor_pass"(rx2177_pos, "infix:sym<==>")
    if_null rx2177_debug, debug_1567
    rx2177_cur."!cursor_debug"("PASS", "infix:sym<==>", " at pos=", rx2177_pos)
  debug_1567:
    .return (rx2177_cur)
  rx2177_restart:
.annotate 'line', 435
    if_null rx2177_debug, debug_1568
    rx2177_cur."!cursor_debug"("NEXT", "infix:sym<==>")
  debug_1568:
  rx2177_fail:
    (rx2177_rep, rx2177_pos, $I10, $P10) = rx2177_cur."!mark_fail"(0)
    lt rx2177_pos, -1, rx2177_done
    eq rx2177_pos, -1, rx2177_fail
    jump $I10
  rx2177_done:
    rx2177_cur."!cursor_fail"()
    if_null rx2177_debug, debug_1569
    rx2177_cur."!cursor_debug"("FAIL", "infix:sym<==>")
  debug_1569:
    .return (rx2177_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<==>"  :subid("364_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("O", "==")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<!=>"  :subid("365_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2182_tgt
    .local int rx2182_pos
    .local int rx2182_off
    .local int rx2182_eos
    .local int rx2182_rep
    .local pmc rx2182_cur
    .local pmc rx2182_debug
    (rx2182_cur, rx2182_pos, rx2182_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2182_cur
    .local pmc match
    .lex "$/", match
    length rx2182_eos, rx2182_tgt
    gt rx2182_pos, rx2182_eos, rx2182_done
    set rx2182_off, 0
    lt rx2182_pos, 2, rx2182_start
    sub rx2182_off, rx2182_pos, 1
    substr rx2182_tgt, rx2182_tgt, rx2182_off
  rx2182_start:
    eq $I10, 1, rx2182_restart
    if_null rx2182_debug, debug_1570
    rx2182_cur."!cursor_debug"("START", "infix:sym<!=>")
  debug_1570:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2183_done
    goto rxscan2183_scan
  rxscan2183_loop:
    (rx2182_pos) = rx2182_cur."from"()
    inc rx2182_pos
    rx2182_cur."!cursor_from"(rx2182_pos)
    ge rx2182_pos, rx2182_eos, rxscan2183_done
  rxscan2183_scan:
    set_addr $I10, rxscan2183_loop
    rx2182_cur."!mark_push"(0, rx2182_pos, $I10)
  rxscan2183_done:
.annotate 'line', 1119
  # rx subcapture "sym"
    set_addr $I10, rxcap_2184_fail
    rx2182_cur."!mark_push"(0, rx2182_pos, $I10)
  # rx literal  "!="
    add $I11, rx2182_pos, 2
    gt $I11, rx2182_eos, rx2182_fail
    sub $I11, rx2182_pos, rx2182_off
    substr $S10, rx2182_tgt, $I11, 2
    ne $S10, "!=", rx2182_fail
    add rx2182_pos, 2
    set_addr $I10, rxcap_2184_fail
    ($I12, $I11) = rx2182_cur."!mark_peek"($I10)
    rx2182_cur."!cursor_pos"($I11)
    ($P10) = rx2182_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2182_pos, "")
    rx2182_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2184_done
  rxcap_2184_fail:
    goto rx2182_fail
  rxcap_2184_done:
  # rx subrule "O" subtype=capture negate=
    rx2182_cur."!cursor_pos"(rx2182_pos)
    $P10 = rx2182_cur."O"("%relational, :pirop<isne INn>")
    unless $P10, rx2182_fail
    rx2182_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2182_pos = $P10."pos"()
  # rx pass
    rx2182_cur."!cursor_pass"(rx2182_pos, "infix:sym<!=>")
    if_null rx2182_debug, debug_1571
    rx2182_cur."!cursor_debug"("PASS", "infix:sym<!=>", " at pos=", rx2182_pos)
  debug_1571:
    .return (rx2182_cur)
  rx2182_restart:
.annotate 'line', 435
    if_null rx2182_debug, debug_1572
    rx2182_cur."!cursor_debug"("NEXT", "infix:sym<!=>")
  debug_1572:
  rx2182_fail:
    (rx2182_rep, rx2182_pos, $I10, $P10) = rx2182_cur."!mark_fail"(0)
    lt rx2182_pos, -1, rx2182_done
    eq rx2182_pos, -1, rx2182_fail
    jump $I10
  rx2182_done:
    rx2182_cur."!cursor_fail"()
    if_null rx2182_debug, debug_1573
    rx2182_cur."!cursor_debug"("FAIL", "infix:sym<!=>")
  debug_1573:
    .return (rx2182_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<!=>"  :subid("366_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("O", "!=")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<=>"  :subid("367_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2187_tgt
    .local int rx2187_pos
    .local int rx2187_off
    .local int rx2187_eos
    .local int rx2187_rep
    .local pmc rx2187_cur
    .local pmc rx2187_debug
    (rx2187_cur, rx2187_pos, rx2187_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2187_cur
    .local pmc match
    .lex "$/", match
    length rx2187_eos, rx2187_tgt
    gt rx2187_pos, rx2187_eos, rx2187_done
    set rx2187_off, 0
    lt rx2187_pos, 2, rx2187_start
    sub rx2187_off, rx2187_pos, 1
    substr rx2187_tgt, rx2187_tgt, rx2187_off
  rx2187_start:
    eq $I10, 1, rx2187_restart
    if_null rx2187_debug, debug_1574
    rx2187_cur."!cursor_debug"("START", "infix:sym<<=>")
  debug_1574:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2188_done
    goto rxscan2188_scan
  rxscan2188_loop:
    (rx2187_pos) = rx2187_cur."from"()
    inc rx2187_pos
    rx2187_cur."!cursor_from"(rx2187_pos)
    ge rx2187_pos, rx2187_eos, rxscan2188_done
  rxscan2188_scan:
    set_addr $I10, rxscan2188_loop
    rx2187_cur."!mark_push"(0, rx2187_pos, $I10)
  rxscan2188_done:
.annotate 'line', 1120
  # rx subcapture "sym"
    set_addr $I10, rxcap_2189_fail
    rx2187_cur."!mark_push"(0, rx2187_pos, $I10)
  # rx literal  "<="
    add $I11, rx2187_pos, 2
    gt $I11, rx2187_eos, rx2187_fail
    sub $I11, rx2187_pos, rx2187_off
    substr $S10, rx2187_tgt, $I11, 2
    ne $S10, "<=", rx2187_fail
    add rx2187_pos, 2
    set_addr $I10, rxcap_2189_fail
    ($I12, $I11) = rx2187_cur."!mark_peek"($I10)
    rx2187_cur."!cursor_pos"($I11)
    ($P10) = rx2187_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2187_pos, "")
    rx2187_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2189_done
  rxcap_2189_fail:
    goto rx2187_fail
  rxcap_2189_done:
  # rx subrule "O" subtype=capture negate=
    rx2187_cur."!cursor_pos"(rx2187_pos)
    $P10 = rx2187_cur."O"("%relational, :pirop<isle INn>")
    unless $P10, rx2187_fail
    rx2187_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2187_pos = $P10."pos"()
  # rx pass
    rx2187_cur."!cursor_pass"(rx2187_pos, "infix:sym<<=>")
    if_null rx2187_debug, debug_1575
    rx2187_cur."!cursor_debug"("PASS", "infix:sym<<=>", " at pos=", rx2187_pos)
  debug_1575:
    .return (rx2187_cur)
  rx2187_restart:
.annotate 'line', 435
    if_null rx2187_debug, debug_1576
    rx2187_cur."!cursor_debug"("NEXT", "infix:sym<<=>")
  debug_1576:
  rx2187_fail:
    (rx2187_rep, rx2187_pos, $I10, $P10) = rx2187_cur."!mark_fail"(0)
    lt rx2187_pos, -1, rx2187_done
    eq rx2187_pos, -1, rx2187_fail
    jump $I10
  rx2187_done:
    rx2187_cur."!cursor_fail"()
    if_null rx2187_debug, debug_1577
    rx2187_cur."!cursor_debug"("FAIL", "infix:sym<<=>")
  debug_1577:
    .return (rx2187_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<=>"  :subid("368_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("O", "<=")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>=>"  :subid("369_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2192_tgt
    .local int rx2192_pos
    .local int rx2192_off
    .local int rx2192_eos
    .local int rx2192_rep
    .local pmc rx2192_cur
    .local pmc rx2192_debug
    (rx2192_cur, rx2192_pos, rx2192_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2192_cur
    .local pmc match
    .lex "$/", match
    length rx2192_eos, rx2192_tgt
    gt rx2192_pos, rx2192_eos, rx2192_done
    set rx2192_off, 0
    lt rx2192_pos, 2, rx2192_start
    sub rx2192_off, rx2192_pos, 1
    substr rx2192_tgt, rx2192_tgt, rx2192_off
  rx2192_start:
    eq $I10, 1, rx2192_restart
    if_null rx2192_debug, debug_1578
    rx2192_cur."!cursor_debug"("START", "infix:sym<>=>")
  debug_1578:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2193_done
    goto rxscan2193_scan
  rxscan2193_loop:
    (rx2192_pos) = rx2192_cur."from"()
    inc rx2192_pos
    rx2192_cur."!cursor_from"(rx2192_pos)
    ge rx2192_pos, rx2192_eos, rxscan2193_done
  rxscan2193_scan:
    set_addr $I10, rxscan2193_loop
    rx2192_cur."!mark_push"(0, rx2192_pos, $I10)
  rxscan2193_done:
.annotate 'line', 1121
  # rx subcapture "sym"
    set_addr $I10, rxcap_2194_fail
    rx2192_cur."!mark_push"(0, rx2192_pos, $I10)
  # rx literal  ">="
    add $I11, rx2192_pos, 2
    gt $I11, rx2192_eos, rx2192_fail
    sub $I11, rx2192_pos, rx2192_off
    substr $S10, rx2192_tgt, $I11, 2
    ne $S10, ">=", rx2192_fail
    add rx2192_pos, 2
    set_addr $I10, rxcap_2194_fail
    ($I12, $I11) = rx2192_cur."!mark_peek"($I10)
    rx2192_cur."!cursor_pos"($I11)
    ($P10) = rx2192_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2192_pos, "")
    rx2192_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2194_done
  rxcap_2194_fail:
    goto rx2192_fail
  rxcap_2194_done:
  # rx subrule "O" subtype=capture negate=
    rx2192_cur."!cursor_pos"(rx2192_pos)
    $P10 = rx2192_cur."O"("%relational, :pirop<isge INn>")
    unless $P10, rx2192_fail
    rx2192_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2192_pos = $P10."pos"()
  # rx pass
    rx2192_cur."!cursor_pass"(rx2192_pos, "infix:sym<>=>")
    if_null rx2192_debug, debug_1579
    rx2192_cur."!cursor_debug"("PASS", "infix:sym<>=>", " at pos=", rx2192_pos)
  debug_1579:
    .return (rx2192_cur)
  rx2192_restart:
.annotate 'line', 435
    if_null rx2192_debug, debug_1580
    rx2192_cur."!cursor_debug"("NEXT", "infix:sym<>=>")
  debug_1580:
  rx2192_fail:
    (rx2192_rep, rx2192_pos, $I10, $P10) = rx2192_cur."!mark_fail"(0)
    lt rx2192_pos, -1, rx2192_done
    eq rx2192_pos, -1, rx2192_fail
    jump $I10
  rx2192_done:
    rx2192_cur."!cursor_fail"()
    if_null rx2192_debug, debug_1581
    rx2192_cur."!cursor_debug"("FAIL", "infix:sym<>=>")
  debug_1581:
    .return (rx2192_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>=>"  :subid("370_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("O", ">=")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<>"  :subid("371_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2197_tgt
    .local int rx2197_pos
    .local int rx2197_off
    .local int rx2197_eos
    .local int rx2197_rep
    .local pmc rx2197_cur
    .local pmc rx2197_debug
    (rx2197_cur, rx2197_pos, rx2197_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2197_cur
    .local pmc match
    .lex "$/", match
    length rx2197_eos, rx2197_tgt
    gt rx2197_pos, rx2197_eos, rx2197_done
    set rx2197_off, 0
    lt rx2197_pos, 2, rx2197_start
    sub rx2197_off, rx2197_pos, 1
    substr rx2197_tgt, rx2197_tgt, rx2197_off
  rx2197_start:
    eq $I10, 1, rx2197_restart
    if_null rx2197_debug, debug_1582
    rx2197_cur."!cursor_debug"("START", "infix:sym<<>")
  debug_1582:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2198_done
    goto rxscan2198_scan
  rxscan2198_loop:
    (rx2197_pos) = rx2197_cur."from"()
    inc rx2197_pos
    rx2197_cur."!cursor_from"(rx2197_pos)
    ge rx2197_pos, rx2197_eos, rxscan2198_done
  rxscan2198_scan:
    set_addr $I10, rxscan2198_loop
    rx2197_cur."!mark_push"(0, rx2197_pos, $I10)
  rxscan2198_done:
.annotate 'line', 1122
  # rx subcapture "sym"
    set_addr $I10, rxcap_2199_fail
    rx2197_cur."!mark_push"(0, rx2197_pos, $I10)
  # rx literal  "<"
    add $I11, rx2197_pos, 1
    gt $I11, rx2197_eos, rx2197_fail
    sub $I11, rx2197_pos, rx2197_off
    ord $I11, rx2197_tgt, $I11
    ne $I11, 60, rx2197_fail
    add rx2197_pos, 1
    set_addr $I10, rxcap_2199_fail
    ($I12, $I11) = rx2197_cur."!mark_peek"($I10)
    rx2197_cur."!cursor_pos"($I11)
    ($P10) = rx2197_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2197_pos, "")
    rx2197_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2199_done
  rxcap_2199_fail:
    goto rx2197_fail
  rxcap_2199_done:
  # rx subrule "O" subtype=capture negate=
    rx2197_cur."!cursor_pos"(rx2197_pos)
    $P10 = rx2197_cur."O"("%relational, :pirop<islt INn>")
    unless $P10, rx2197_fail
    rx2197_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2197_pos = $P10."pos"()
  # rx pass
    rx2197_cur."!cursor_pass"(rx2197_pos, "infix:sym<<>")
    if_null rx2197_debug, debug_1583
    rx2197_cur."!cursor_debug"("PASS", "infix:sym<<>", " at pos=", rx2197_pos)
  debug_1583:
    .return (rx2197_cur)
  rx2197_restart:
.annotate 'line', 435
    if_null rx2197_debug, debug_1584
    rx2197_cur."!cursor_debug"("NEXT", "infix:sym<<>")
  debug_1584:
  rx2197_fail:
    (rx2197_rep, rx2197_pos, $I10, $P10) = rx2197_cur."!mark_fail"(0)
    lt rx2197_pos, -1, rx2197_done
    eq rx2197_pos, -1, rx2197_fail
    jump $I10
  rx2197_done:
    rx2197_cur."!cursor_fail"()
    if_null rx2197_debug, debug_1585
    rx2197_cur."!cursor_debug"("FAIL", "infix:sym<<>")
  debug_1585:
    .return (rx2197_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<>"  :subid("372_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("O", "<")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>>"  :subid("373_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2202_tgt
    .local int rx2202_pos
    .local int rx2202_off
    .local int rx2202_eos
    .local int rx2202_rep
    .local pmc rx2202_cur
    .local pmc rx2202_debug
    (rx2202_cur, rx2202_pos, rx2202_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2202_cur
    .local pmc match
    .lex "$/", match
    length rx2202_eos, rx2202_tgt
    gt rx2202_pos, rx2202_eos, rx2202_done
    set rx2202_off, 0
    lt rx2202_pos, 2, rx2202_start
    sub rx2202_off, rx2202_pos, 1
    substr rx2202_tgt, rx2202_tgt, rx2202_off
  rx2202_start:
    eq $I10, 1, rx2202_restart
    if_null rx2202_debug, debug_1586
    rx2202_cur."!cursor_debug"("START", "infix:sym<>>")
  debug_1586:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2203_done
    goto rxscan2203_scan
  rxscan2203_loop:
    (rx2202_pos) = rx2202_cur."from"()
    inc rx2202_pos
    rx2202_cur."!cursor_from"(rx2202_pos)
    ge rx2202_pos, rx2202_eos, rxscan2203_done
  rxscan2203_scan:
    set_addr $I10, rxscan2203_loop
    rx2202_cur."!mark_push"(0, rx2202_pos, $I10)
  rxscan2203_done:
.annotate 'line', 1123
  # rx subcapture "sym"
    set_addr $I10, rxcap_2204_fail
    rx2202_cur."!mark_push"(0, rx2202_pos, $I10)
  # rx literal  ">"
    add $I11, rx2202_pos, 1
    gt $I11, rx2202_eos, rx2202_fail
    sub $I11, rx2202_pos, rx2202_off
    ord $I11, rx2202_tgt, $I11
    ne $I11, 62, rx2202_fail
    add rx2202_pos, 1
    set_addr $I10, rxcap_2204_fail
    ($I12, $I11) = rx2202_cur."!mark_peek"($I10)
    rx2202_cur."!cursor_pos"($I11)
    ($P10) = rx2202_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2202_pos, "")
    rx2202_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2204_done
  rxcap_2204_fail:
    goto rx2202_fail
  rxcap_2204_done:
  # rx subrule "O" subtype=capture negate=
    rx2202_cur."!cursor_pos"(rx2202_pos)
    $P10 = rx2202_cur."O"("%relational, :pirop<isgt INn>")
    unless $P10, rx2202_fail
    rx2202_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2202_pos = $P10."pos"()
  # rx pass
    rx2202_cur."!cursor_pass"(rx2202_pos, "infix:sym<>>")
    if_null rx2202_debug, debug_1587
    rx2202_cur."!cursor_debug"("PASS", "infix:sym<>>", " at pos=", rx2202_pos)
  debug_1587:
    .return (rx2202_cur)
  rx2202_restart:
.annotate 'line', 435
    if_null rx2202_debug, debug_1588
    rx2202_cur."!cursor_debug"("NEXT", "infix:sym<>>")
  debug_1588:
  rx2202_fail:
    (rx2202_rep, rx2202_pos, $I10, $P10) = rx2202_cur."!mark_fail"(0)
    lt rx2202_pos, -1, rx2202_done
    eq rx2202_pos, -1, rx2202_fail
    jump $I10
  rx2202_done:
    rx2202_cur."!cursor_fail"()
    if_null rx2202_debug, debug_1589
    rx2202_cur."!cursor_debug"("FAIL", "infix:sym<>>")
  debug_1589:
    .return (rx2202_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>>"  :subid("374_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("O", ">")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<eq>"  :subid("375_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2207_tgt
    .local int rx2207_pos
    .local int rx2207_off
    .local int rx2207_eos
    .local int rx2207_rep
    .local pmc rx2207_cur
    .local pmc rx2207_debug
    (rx2207_cur, rx2207_pos, rx2207_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2207_cur
    .local pmc match
    .lex "$/", match
    length rx2207_eos, rx2207_tgt
    gt rx2207_pos, rx2207_eos, rx2207_done
    set rx2207_off, 0
    lt rx2207_pos, 2, rx2207_start
    sub rx2207_off, rx2207_pos, 1
    substr rx2207_tgt, rx2207_tgt, rx2207_off
  rx2207_start:
    eq $I10, 1, rx2207_restart
    if_null rx2207_debug, debug_1590
    rx2207_cur."!cursor_debug"("START", "infix:sym<eq>")
  debug_1590:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2208_done
    goto rxscan2208_scan
  rxscan2208_loop:
    (rx2207_pos) = rx2207_cur."from"()
    inc rx2207_pos
    rx2207_cur."!cursor_from"(rx2207_pos)
    ge rx2207_pos, rx2207_eos, rxscan2208_done
  rxscan2208_scan:
    set_addr $I10, rxscan2208_loop
    rx2207_cur."!mark_push"(0, rx2207_pos, $I10)
  rxscan2208_done:
.annotate 'line', 1124
  # rx subcapture "sym"
    set_addr $I10, rxcap_2209_fail
    rx2207_cur."!mark_push"(0, rx2207_pos, $I10)
  # rx literal  "eq"
    add $I11, rx2207_pos, 2
    gt $I11, rx2207_eos, rx2207_fail
    sub $I11, rx2207_pos, rx2207_off
    substr $S10, rx2207_tgt, $I11, 2
    ne $S10, "eq", rx2207_fail
    add rx2207_pos, 2
    set_addr $I10, rxcap_2209_fail
    ($I12, $I11) = rx2207_cur."!mark_peek"($I10)
    rx2207_cur."!cursor_pos"($I11)
    ($P10) = rx2207_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2207_pos, "")
    rx2207_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2209_done
  rxcap_2209_fail:
    goto rx2207_fail
  rxcap_2209_done:
  # rx subrule "O" subtype=capture negate=
    rx2207_cur."!cursor_pos"(rx2207_pos)
    $P10 = rx2207_cur."O"("%relational, :pirop<iseq ISs>")
    unless $P10, rx2207_fail
    rx2207_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2207_pos = $P10."pos"()
  # rx pass
    rx2207_cur."!cursor_pass"(rx2207_pos, "infix:sym<eq>")
    if_null rx2207_debug, debug_1591
    rx2207_cur."!cursor_debug"("PASS", "infix:sym<eq>", " at pos=", rx2207_pos)
  debug_1591:
    .return (rx2207_cur)
  rx2207_restart:
.annotate 'line', 435
    if_null rx2207_debug, debug_1592
    rx2207_cur."!cursor_debug"("NEXT", "infix:sym<eq>")
  debug_1592:
  rx2207_fail:
    (rx2207_rep, rx2207_pos, $I10, $P10) = rx2207_cur."!mark_fail"(0)
    lt rx2207_pos, -1, rx2207_done
    eq rx2207_pos, -1, rx2207_fail
    jump $I10
  rx2207_done:
    rx2207_cur."!cursor_fail"()
    if_null rx2207_debug, debug_1593
    rx2207_cur."!cursor_debug"("FAIL", "infix:sym<eq>")
  debug_1593:
    .return (rx2207_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<eq>"  :subid("376_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("O", "eq")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ne>"  :subid("377_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2212_tgt
    .local int rx2212_pos
    .local int rx2212_off
    .local int rx2212_eos
    .local int rx2212_rep
    .local pmc rx2212_cur
    .local pmc rx2212_debug
    (rx2212_cur, rx2212_pos, rx2212_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2212_cur
    .local pmc match
    .lex "$/", match
    length rx2212_eos, rx2212_tgt
    gt rx2212_pos, rx2212_eos, rx2212_done
    set rx2212_off, 0
    lt rx2212_pos, 2, rx2212_start
    sub rx2212_off, rx2212_pos, 1
    substr rx2212_tgt, rx2212_tgt, rx2212_off
  rx2212_start:
    eq $I10, 1, rx2212_restart
    if_null rx2212_debug, debug_1594
    rx2212_cur."!cursor_debug"("START", "infix:sym<ne>")
  debug_1594:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2213_done
    goto rxscan2213_scan
  rxscan2213_loop:
    (rx2212_pos) = rx2212_cur."from"()
    inc rx2212_pos
    rx2212_cur."!cursor_from"(rx2212_pos)
    ge rx2212_pos, rx2212_eos, rxscan2213_done
  rxscan2213_scan:
    set_addr $I10, rxscan2213_loop
    rx2212_cur."!mark_push"(0, rx2212_pos, $I10)
  rxscan2213_done:
.annotate 'line', 1125
  # rx subcapture "sym"
    set_addr $I10, rxcap_2214_fail
    rx2212_cur."!mark_push"(0, rx2212_pos, $I10)
  # rx literal  "ne"
    add $I11, rx2212_pos, 2
    gt $I11, rx2212_eos, rx2212_fail
    sub $I11, rx2212_pos, rx2212_off
    substr $S10, rx2212_tgt, $I11, 2
    ne $S10, "ne", rx2212_fail
    add rx2212_pos, 2
    set_addr $I10, rxcap_2214_fail
    ($I12, $I11) = rx2212_cur."!mark_peek"($I10)
    rx2212_cur."!cursor_pos"($I11)
    ($P10) = rx2212_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2212_pos, "")
    rx2212_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2214_done
  rxcap_2214_fail:
    goto rx2212_fail
  rxcap_2214_done:
  # rx subrule "O" subtype=capture negate=
    rx2212_cur."!cursor_pos"(rx2212_pos)
    $P10 = rx2212_cur."O"("%relational, :pirop<isne ISs>")
    unless $P10, rx2212_fail
    rx2212_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2212_pos = $P10."pos"()
  # rx pass
    rx2212_cur."!cursor_pass"(rx2212_pos, "infix:sym<ne>")
    if_null rx2212_debug, debug_1595
    rx2212_cur."!cursor_debug"("PASS", "infix:sym<ne>", " at pos=", rx2212_pos)
  debug_1595:
    .return (rx2212_cur)
  rx2212_restart:
.annotate 'line', 435
    if_null rx2212_debug, debug_1596
    rx2212_cur."!cursor_debug"("NEXT", "infix:sym<ne>")
  debug_1596:
  rx2212_fail:
    (rx2212_rep, rx2212_pos, $I10, $P10) = rx2212_cur."!mark_fail"(0)
    lt rx2212_pos, -1, rx2212_done
    eq rx2212_pos, -1, rx2212_fail
    jump $I10
  rx2212_done:
    rx2212_cur."!cursor_fail"()
    if_null rx2212_debug, debug_1597
    rx2212_cur."!cursor_debug"("FAIL", "infix:sym<ne>")
  debug_1597:
    .return (rx2212_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ne>"  :subid("378_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("O", "ne")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<le>"  :subid("379_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2217_tgt
    .local int rx2217_pos
    .local int rx2217_off
    .local int rx2217_eos
    .local int rx2217_rep
    .local pmc rx2217_cur
    .local pmc rx2217_debug
    (rx2217_cur, rx2217_pos, rx2217_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2217_cur
    .local pmc match
    .lex "$/", match
    length rx2217_eos, rx2217_tgt
    gt rx2217_pos, rx2217_eos, rx2217_done
    set rx2217_off, 0
    lt rx2217_pos, 2, rx2217_start
    sub rx2217_off, rx2217_pos, 1
    substr rx2217_tgt, rx2217_tgt, rx2217_off
  rx2217_start:
    eq $I10, 1, rx2217_restart
    if_null rx2217_debug, debug_1598
    rx2217_cur."!cursor_debug"("START", "infix:sym<le>")
  debug_1598:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2218_done
    goto rxscan2218_scan
  rxscan2218_loop:
    (rx2217_pos) = rx2217_cur."from"()
    inc rx2217_pos
    rx2217_cur."!cursor_from"(rx2217_pos)
    ge rx2217_pos, rx2217_eos, rxscan2218_done
  rxscan2218_scan:
    set_addr $I10, rxscan2218_loop
    rx2217_cur."!mark_push"(0, rx2217_pos, $I10)
  rxscan2218_done:
.annotate 'line', 1126
  # rx subcapture "sym"
    set_addr $I10, rxcap_2219_fail
    rx2217_cur."!mark_push"(0, rx2217_pos, $I10)
  # rx literal  "le"
    add $I11, rx2217_pos, 2
    gt $I11, rx2217_eos, rx2217_fail
    sub $I11, rx2217_pos, rx2217_off
    substr $S10, rx2217_tgt, $I11, 2
    ne $S10, "le", rx2217_fail
    add rx2217_pos, 2
    set_addr $I10, rxcap_2219_fail
    ($I12, $I11) = rx2217_cur."!mark_peek"($I10)
    rx2217_cur."!cursor_pos"($I11)
    ($P10) = rx2217_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2217_pos, "")
    rx2217_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2219_done
  rxcap_2219_fail:
    goto rx2217_fail
  rxcap_2219_done:
  # rx subrule "O" subtype=capture negate=
    rx2217_cur."!cursor_pos"(rx2217_pos)
    $P10 = rx2217_cur."O"("%relational, :pirop<isle ISs>")
    unless $P10, rx2217_fail
    rx2217_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2217_pos = $P10."pos"()
  # rx pass
    rx2217_cur."!cursor_pass"(rx2217_pos, "infix:sym<le>")
    if_null rx2217_debug, debug_1599
    rx2217_cur."!cursor_debug"("PASS", "infix:sym<le>", " at pos=", rx2217_pos)
  debug_1599:
    .return (rx2217_cur)
  rx2217_restart:
.annotate 'line', 435
    if_null rx2217_debug, debug_1600
    rx2217_cur."!cursor_debug"("NEXT", "infix:sym<le>")
  debug_1600:
  rx2217_fail:
    (rx2217_rep, rx2217_pos, $I10, $P10) = rx2217_cur."!mark_fail"(0)
    lt rx2217_pos, -1, rx2217_done
    eq rx2217_pos, -1, rx2217_fail
    jump $I10
  rx2217_done:
    rx2217_cur."!cursor_fail"()
    if_null rx2217_debug, debug_1601
    rx2217_cur."!cursor_debug"("FAIL", "infix:sym<le>")
  debug_1601:
    .return (rx2217_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<le>"  :subid("380_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("O", "le")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ge>"  :subid("381_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2222_tgt
    .local int rx2222_pos
    .local int rx2222_off
    .local int rx2222_eos
    .local int rx2222_rep
    .local pmc rx2222_cur
    .local pmc rx2222_debug
    (rx2222_cur, rx2222_pos, rx2222_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2222_cur
    .local pmc match
    .lex "$/", match
    length rx2222_eos, rx2222_tgt
    gt rx2222_pos, rx2222_eos, rx2222_done
    set rx2222_off, 0
    lt rx2222_pos, 2, rx2222_start
    sub rx2222_off, rx2222_pos, 1
    substr rx2222_tgt, rx2222_tgt, rx2222_off
  rx2222_start:
    eq $I10, 1, rx2222_restart
    if_null rx2222_debug, debug_1602
    rx2222_cur."!cursor_debug"("START", "infix:sym<ge>")
  debug_1602:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2223_done
    goto rxscan2223_scan
  rxscan2223_loop:
    (rx2222_pos) = rx2222_cur."from"()
    inc rx2222_pos
    rx2222_cur."!cursor_from"(rx2222_pos)
    ge rx2222_pos, rx2222_eos, rxscan2223_done
  rxscan2223_scan:
    set_addr $I10, rxscan2223_loop
    rx2222_cur."!mark_push"(0, rx2222_pos, $I10)
  rxscan2223_done:
.annotate 'line', 1127
  # rx subcapture "sym"
    set_addr $I10, rxcap_2224_fail
    rx2222_cur."!mark_push"(0, rx2222_pos, $I10)
  # rx literal  "ge"
    add $I11, rx2222_pos, 2
    gt $I11, rx2222_eos, rx2222_fail
    sub $I11, rx2222_pos, rx2222_off
    substr $S10, rx2222_tgt, $I11, 2
    ne $S10, "ge", rx2222_fail
    add rx2222_pos, 2
    set_addr $I10, rxcap_2224_fail
    ($I12, $I11) = rx2222_cur."!mark_peek"($I10)
    rx2222_cur."!cursor_pos"($I11)
    ($P10) = rx2222_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2222_pos, "")
    rx2222_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2224_done
  rxcap_2224_fail:
    goto rx2222_fail
  rxcap_2224_done:
  # rx subrule "O" subtype=capture negate=
    rx2222_cur."!cursor_pos"(rx2222_pos)
    $P10 = rx2222_cur."O"("%relational, :pirop<isge ISs>")
    unless $P10, rx2222_fail
    rx2222_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2222_pos = $P10."pos"()
  # rx pass
    rx2222_cur."!cursor_pass"(rx2222_pos, "infix:sym<ge>")
    if_null rx2222_debug, debug_1603
    rx2222_cur."!cursor_debug"("PASS", "infix:sym<ge>", " at pos=", rx2222_pos)
  debug_1603:
    .return (rx2222_cur)
  rx2222_restart:
.annotate 'line', 435
    if_null rx2222_debug, debug_1604
    rx2222_cur."!cursor_debug"("NEXT", "infix:sym<ge>")
  debug_1604:
  rx2222_fail:
    (rx2222_rep, rx2222_pos, $I10, $P10) = rx2222_cur."!mark_fail"(0)
    lt rx2222_pos, -1, rx2222_done
    eq rx2222_pos, -1, rx2222_fail
    jump $I10
  rx2222_done:
    rx2222_cur."!cursor_fail"()
    if_null rx2222_debug, debug_1605
    rx2222_cur."!cursor_debug"("FAIL", "infix:sym<ge>")
  debug_1605:
    .return (rx2222_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ge>"  :subid("382_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("O", "ge")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<lt>"  :subid("383_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2227_tgt
    .local int rx2227_pos
    .local int rx2227_off
    .local int rx2227_eos
    .local int rx2227_rep
    .local pmc rx2227_cur
    .local pmc rx2227_debug
    (rx2227_cur, rx2227_pos, rx2227_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2227_cur
    .local pmc match
    .lex "$/", match
    length rx2227_eos, rx2227_tgt
    gt rx2227_pos, rx2227_eos, rx2227_done
    set rx2227_off, 0
    lt rx2227_pos, 2, rx2227_start
    sub rx2227_off, rx2227_pos, 1
    substr rx2227_tgt, rx2227_tgt, rx2227_off
  rx2227_start:
    eq $I10, 1, rx2227_restart
    if_null rx2227_debug, debug_1606
    rx2227_cur."!cursor_debug"("START", "infix:sym<lt>")
  debug_1606:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2228_done
    goto rxscan2228_scan
  rxscan2228_loop:
    (rx2227_pos) = rx2227_cur."from"()
    inc rx2227_pos
    rx2227_cur."!cursor_from"(rx2227_pos)
    ge rx2227_pos, rx2227_eos, rxscan2228_done
  rxscan2228_scan:
    set_addr $I10, rxscan2228_loop
    rx2227_cur."!mark_push"(0, rx2227_pos, $I10)
  rxscan2228_done:
.annotate 'line', 1128
  # rx subcapture "sym"
    set_addr $I10, rxcap_2229_fail
    rx2227_cur."!mark_push"(0, rx2227_pos, $I10)
  # rx literal  "lt"
    add $I11, rx2227_pos, 2
    gt $I11, rx2227_eos, rx2227_fail
    sub $I11, rx2227_pos, rx2227_off
    substr $S10, rx2227_tgt, $I11, 2
    ne $S10, "lt", rx2227_fail
    add rx2227_pos, 2
    set_addr $I10, rxcap_2229_fail
    ($I12, $I11) = rx2227_cur."!mark_peek"($I10)
    rx2227_cur."!cursor_pos"($I11)
    ($P10) = rx2227_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2227_pos, "")
    rx2227_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2229_done
  rxcap_2229_fail:
    goto rx2227_fail
  rxcap_2229_done:
  # rx subrule "O" subtype=capture negate=
    rx2227_cur."!cursor_pos"(rx2227_pos)
    $P10 = rx2227_cur."O"("%relational, :pirop<islt ISs>")
    unless $P10, rx2227_fail
    rx2227_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2227_pos = $P10."pos"()
  # rx pass
    rx2227_cur."!cursor_pass"(rx2227_pos, "infix:sym<lt>")
    if_null rx2227_debug, debug_1607
    rx2227_cur."!cursor_debug"("PASS", "infix:sym<lt>", " at pos=", rx2227_pos)
  debug_1607:
    .return (rx2227_cur)
  rx2227_restart:
.annotate 'line', 435
    if_null rx2227_debug, debug_1608
    rx2227_cur."!cursor_debug"("NEXT", "infix:sym<lt>")
  debug_1608:
  rx2227_fail:
    (rx2227_rep, rx2227_pos, $I10, $P10) = rx2227_cur."!mark_fail"(0)
    lt rx2227_pos, -1, rx2227_done
    eq rx2227_pos, -1, rx2227_fail
    jump $I10
  rx2227_done:
    rx2227_cur."!cursor_fail"()
    if_null rx2227_debug, debug_1609
    rx2227_cur."!cursor_debug"("FAIL", "infix:sym<lt>")
  debug_1609:
    .return (rx2227_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<lt>"  :subid("384_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("O", "lt")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<gt>"  :subid("385_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2232_tgt
    .local int rx2232_pos
    .local int rx2232_off
    .local int rx2232_eos
    .local int rx2232_rep
    .local pmc rx2232_cur
    .local pmc rx2232_debug
    (rx2232_cur, rx2232_pos, rx2232_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2232_cur
    .local pmc match
    .lex "$/", match
    length rx2232_eos, rx2232_tgt
    gt rx2232_pos, rx2232_eos, rx2232_done
    set rx2232_off, 0
    lt rx2232_pos, 2, rx2232_start
    sub rx2232_off, rx2232_pos, 1
    substr rx2232_tgt, rx2232_tgt, rx2232_off
  rx2232_start:
    eq $I10, 1, rx2232_restart
    if_null rx2232_debug, debug_1610
    rx2232_cur."!cursor_debug"("START", "infix:sym<gt>")
  debug_1610:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2233_done
    goto rxscan2233_scan
  rxscan2233_loop:
    (rx2232_pos) = rx2232_cur."from"()
    inc rx2232_pos
    rx2232_cur."!cursor_from"(rx2232_pos)
    ge rx2232_pos, rx2232_eos, rxscan2233_done
  rxscan2233_scan:
    set_addr $I10, rxscan2233_loop
    rx2232_cur."!mark_push"(0, rx2232_pos, $I10)
  rxscan2233_done:
.annotate 'line', 1129
  # rx subcapture "sym"
    set_addr $I10, rxcap_2234_fail
    rx2232_cur."!mark_push"(0, rx2232_pos, $I10)
  # rx literal  "gt"
    add $I11, rx2232_pos, 2
    gt $I11, rx2232_eos, rx2232_fail
    sub $I11, rx2232_pos, rx2232_off
    substr $S10, rx2232_tgt, $I11, 2
    ne $S10, "gt", rx2232_fail
    add rx2232_pos, 2
    set_addr $I10, rxcap_2234_fail
    ($I12, $I11) = rx2232_cur."!mark_peek"($I10)
    rx2232_cur."!cursor_pos"($I11)
    ($P10) = rx2232_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2232_pos, "")
    rx2232_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2234_done
  rxcap_2234_fail:
    goto rx2232_fail
  rxcap_2234_done:
  # rx subrule "O" subtype=capture negate=
    rx2232_cur."!cursor_pos"(rx2232_pos)
    $P10 = rx2232_cur."O"("%relational, :pirop<isgt ISs>")
    unless $P10, rx2232_fail
    rx2232_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2232_pos = $P10."pos"()
  # rx pass
    rx2232_cur."!cursor_pass"(rx2232_pos, "infix:sym<gt>")
    if_null rx2232_debug, debug_1611
    rx2232_cur."!cursor_debug"("PASS", "infix:sym<gt>", " at pos=", rx2232_pos)
  debug_1611:
    .return (rx2232_cur)
  rx2232_restart:
.annotate 'line', 435
    if_null rx2232_debug, debug_1612
    rx2232_cur."!cursor_debug"("NEXT", "infix:sym<gt>")
  debug_1612:
  rx2232_fail:
    (rx2232_rep, rx2232_pos, $I10, $P10) = rx2232_cur."!mark_fail"(0)
    lt rx2232_pos, -1, rx2232_done
    eq rx2232_pos, -1, rx2232_fail
    jump $I10
  rx2232_done:
    rx2232_cur."!cursor_fail"()
    if_null rx2232_debug, debug_1613
    rx2232_cur."!cursor_debug"("FAIL", "infix:sym<gt>")
  debug_1613:
    .return (rx2232_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<gt>"  :subid("386_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("O", "gt")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=:=>"  :subid("387_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2237_tgt
    .local int rx2237_pos
    .local int rx2237_off
    .local int rx2237_eos
    .local int rx2237_rep
    .local pmc rx2237_cur
    .local pmc rx2237_debug
    (rx2237_cur, rx2237_pos, rx2237_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2237_cur
    .local pmc match
    .lex "$/", match
    length rx2237_eos, rx2237_tgt
    gt rx2237_pos, rx2237_eos, rx2237_done
    set rx2237_off, 0
    lt rx2237_pos, 2, rx2237_start
    sub rx2237_off, rx2237_pos, 1
    substr rx2237_tgt, rx2237_tgt, rx2237_off
  rx2237_start:
    eq $I10, 1, rx2237_restart
    if_null rx2237_debug, debug_1614
    rx2237_cur."!cursor_debug"("START", "infix:sym<=:=>")
  debug_1614:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2238_done
    goto rxscan2238_scan
  rxscan2238_loop:
    (rx2237_pos) = rx2237_cur."from"()
    inc rx2237_pos
    rx2237_cur."!cursor_from"(rx2237_pos)
    ge rx2237_pos, rx2237_eos, rxscan2238_done
  rxscan2238_scan:
    set_addr $I10, rxscan2238_loop
    rx2237_cur."!mark_push"(0, rx2237_pos, $I10)
  rxscan2238_done:
.annotate 'line', 1130
  # rx subcapture "sym"
    set_addr $I10, rxcap_2239_fail
    rx2237_cur."!mark_push"(0, rx2237_pos, $I10)
  # rx literal  "=:="
    add $I11, rx2237_pos, 3
    gt $I11, rx2237_eos, rx2237_fail
    sub $I11, rx2237_pos, rx2237_off
    substr $S10, rx2237_tgt, $I11, 3
    ne $S10, "=:=", rx2237_fail
    add rx2237_pos, 3
    set_addr $I10, rxcap_2239_fail
    ($I12, $I11) = rx2237_cur."!mark_peek"($I10)
    rx2237_cur."!cursor_pos"($I11)
    ($P10) = rx2237_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2237_pos, "")
    rx2237_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2239_done
  rxcap_2239_fail:
    goto rx2237_fail
  rxcap_2239_done:
  # rx subrule "O" subtype=capture negate=
    rx2237_cur."!cursor_pos"(rx2237_pos)
    $P10 = rx2237_cur."O"("%relational, :pirop<issame>")
    unless $P10, rx2237_fail
    rx2237_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2237_pos = $P10."pos"()
  # rx pass
    rx2237_cur."!cursor_pass"(rx2237_pos, "infix:sym<=:=>")
    if_null rx2237_debug, debug_1615
    rx2237_cur."!cursor_debug"("PASS", "infix:sym<=:=>", " at pos=", rx2237_pos)
  debug_1615:
    .return (rx2237_cur)
  rx2237_restart:
.annotate 'line', 435
    if_null rx2237_debug, debug_1616
    rx2237_cur."!cursor_debug"("NEXT", "infix:sym<=:=>")
  debug_1616:
  rx2237_fail:
    (rx2237_rep, rx2237_pos, $I10, $P10) = rx2237_cur."!mark_fail"(0)
    lt rx2237_pos, -1, rx2237_done
    eq rx2237_pos, -1, rx2237_fail
    jump $I10
  rx2237_done:
    rx2237_cur."!cursor_fail"()
    if_null rx2237_debug, debug_1617
    rx2237_cur."!cursor_debug"("FAIL", "infix:sym<=:=>")
  debug_1617:
    .return (rx2237_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=:=>"  :subid("388_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("O", "=:=")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~~>"  :subid("389_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2242_tgt
    .local int rx2242_pos
    .local int rx2242_off
    .local int rx2242_eos
    .local int rx2242_rep
    .local pmc rx2242_cur
    .local pmc rx2242_debug
    (rx2242_cur, rx2242_pos, rx2242_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2242_cur
    .local pmc match
    .lex "$/", match
    length rx2242_eos, rx2242_tgt
    gt rx2242_pos, rx2242_eos, rx2242_done
    set rx2242_off, 0
    lt rx2242_pos, 2, rx2242_start
    sub rx2242_off, rx2242_pos, 1
    substr rx2242_tgt, rx2242_tgt, rx2242_off
  rx2242_start:
    eq $I10, 1, rx2242_restart
    if_null rx2242_debug, debug_1618
    rx2242_cur."!cursor_debug"("START", "infix:sym<~~>")
  debug_1618:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2243_done
    goto rxscan2243_scan
  rxscan2243_loop:
    (rx2242_pos) = rx2242_cur."from"()
    inc rx2242_pos
    rx2242_cur."!cursor_from"(rx2242_pos)
    ge rx2242_pos, rx2242_eos, rxscan2243_done
  rxscan2243_scan:
    set_addr $I10, rxscan2243_loop
    rx2242_cur."!mark_push"(0, rx2242_pos, $I10)
  rxscan2243_done:
.annotate 'line', 1131
  # rx subcapture "sym"
    set_addr $I10, rxcap_2244_fail
    rx2242_cur."!mark_push"(0, rx2242_pos, $I10)
  # rx literal  "~~"
    add $I11, rx2242_pos, 2
    gt $I11, rx2242_eos, rx2242_fail
    sub $I11, rx2242_pos, rx2242_off
    substr $S10, rx2242_tgt, $I11, 2
    ne $S10, "~~", rx2242_fail
    add rx2242_pos, 2
    set_addr $I10, rxcap_2244_fail
    ($I12, $I11) = rx2242_cur."!mark_peek"($I10)
    rx2242_cur."!cursor_pos"($I11)
    ($P10) = rx2242_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2242_pos, "")
    rx2242_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2244_done
  rxcap_2244_fail:
    goto rx2242_fail
  rxcap_2244_done:
  # rx subrule "O" subtype=capture negate=
    rx2242_cur."!cursor_pos"(rx2242_pos)
    $P10 = rx2242_cur."O"("%relational, :reducecheck<smartmatch>")
    unless $P10, rx2242_fail
    rx2242_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2242_pos = $P10."pos"()
  # rx pass
    rx2242_cur."!cursor_pass"(rx2242_pos, "infix:sym<~~>")
    if_null rx2242_debug, debug_1619
    rx2242_cur."!cursor_debug"("PASS", "infix:sym<~~>", " at pos=", rx2242_pos)
  debug_1619:
    .return (rx2242_cur)
  rx2242_restart:
.annotate 'line', 435
    if_null rx2242_debug, debug_1620
    rx2242_cur."!cursor_debug"("NEXT", "infix:sym<~~>")
  debug_1620:
  rx2242_fail:
    (rx2242_rep, rx2242_pos, $I10, $P10) = rx2242_cur."!mark_fail"(0)
    lt rx2242_pos, -1, rx2242_done
    eq rx2242_pos, -1, rx2242_fail
    jump $I10
  rx2242_done:
    rx2242_cur."!cursor_fail"()
    if_null rx2242_debug, debug_1621
    rx2242_cur."!cursor_debug"("FAIL", "infix:sym<~~>")
  debug_1621:
    .return (rx2242_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~~>"  :subid("390_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("O", "~~")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<&&>"  :subid("391_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2247_tgt
    .local int rx2247_pos
    .local int rx2247_off
    .local int rx2247_eos
    .local int rx2247_rep
    .local pmc rx2247_cur
    .local pmc rx2247_debug
    (rx2247_cur, rx2247_pos, rx2247_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2247_cur
    .local pmc match
    .lex "$/", match
    length rx2247_eos, rx2247_tgt
    gt rx2247_pos, rx2247_eos, rx2247_done
    set rx2247_off, 0
    lt rx2247_pos, 2, rx2247_start
    sub rx2247_off, rx2247_pos, 1
    substr rx2247_tgt, rx2247_tgt, rx2247_off
  rx2247_start:
    eq $I10, 1, rx2247_restart
    if_null rx2247_debug, debug_1622
    rx2247_cur."!cursor_debug"("START", "infix:sym<&&>")
  debug_1622:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2248_done
    goto rxscan2248_scan
  rxscan2248_loop:
    (rx2247_pos) = rx2247_cur."from"()
    inc rx2247_pos
    rx2247_cur."!cursor_from"(rx2247_pos)
    ge rx2247_pos, rx2247_eos, rxscan2248_done
  rxscan2248_scan:
    set_addr $I10, rxscan2248_loop
    rx2247_cur."!mark_push"(0, rx2247_pos, $I10)
  rxscan2248_done:
.annotate 'line', 1133
  # rx subcapture "sym"
    set_addr $I10, rxcap_2249_fail
    rx2247_cur."!mark_push"(0, rx2247_pos, $I10)
  # rx literal  "&&"
    add $I11, rx2247_pos, 2
    gt $I11, rx2247_eos, rx2247_fail
    sub $I11, rx2247_pos, rx2247_off
    substr $S10, rx2247_tgt, $I11, 2
    ne $S10, "&&", rx2247_fail
    add rx2247_pos, 2
    set_addr $I10, rxcap_2249_fail
    ($I12, $I11) = rx2247_cur."!mark_peek"($I10)
    rx2247_cur."!cursor_pos"($I11)
    ($P10) = rx2247_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2247_pos, "")
    rx2247_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2249_done
  rxcap_2249_fail:
    goto rx2247_fail
  rxcap_2249_done:
  # rx subrule "O" subtype=capture negate=
    rx2247_cur."!cursor_pos"(rx2247_pos)
    $P10 = rx2247_cur."O"("%tight_and, :pasttype<if>")
    unless $P10, rx2247_fail
    rx2247_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2247_pos = $P10."pos"()
  # rx pass
    rx2247_cur."!cursor_pass"(rx2247_pos, "infix:sym<&&>")
    if_null rx2247_debug, debug_1623
    rx2247_cur."!cursor_debug"("PASS", "infix:sym<&&>", " at pos=", rx2247_pos)
  debug_1623:
    .return (rx2247_cur)
  rx2247_restart:
.annotate 'line', 435
    if_null rx2247_debug, debug_1624
    rx2247_cur."!cursor_debug"("NEXT", "infix:sym<&&>")
  debug_1624:
  rx2247_fail:
    (rx2247_rep, rx2247_pos, $I10, $P10) = rx2247_cur."!mark_fail"(0)
    lt rx2247_pos, -1, rx2247_done
    eq rx2247_pos, -1, rx2247_fail
    jump $I10
  rx2247_done:
    rx2247_cur."!cursor_fail"()
    if_null rx2247_debug, debug_1625
    rx2247_cur."!cursor_debug"("FAIL", "infix:sym<&&>")
  debug_1625:
    .return (rx2247_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<&&>"  :subid("392_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("O", "&&")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<||>"  :subid("393_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2252_tgt
    .local int rx2252_pos
    .local int rx2252_off
    .local int rx2252_eos
    .local int rx2252_rep
    .local pmc rx2252_cur
    .local pmc rx2252_debug
    (rx2252_cur, rx2252_pos, rx2252_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2252_cur
    .local pmc match
    .lex "$/", match
    length rx2252_eos, rx2252_tgt
    gt rx2252_pos, rx2252_eos, rx2252_done
    set rx2252_off, 0
    lt rx2252_pos, 2, rx2252_start
    sub rx2252_off, rx2252_pos, 1
    substr rx2252_tgt, rx2252_tgt, rx2252_off
  rx2252_start:
    eq $I10, 1, rx2252_restart
    if_null rx2252_debug, debug_1626
    rx2252_cur."!cursor_debug"("START", "infix:sym<||>")
  debug_1626:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2253_done
    goto rxscan2253_scan
  rxscan2253_loop:
    (rx2252_pos) = rx2252_cur."from"()
    inc rx2252_pos
    rx2252_cur."!cursor_from"(rx2252_pos)
    ge rx2252_pos, rx2252_eos, rxscan2253_done
  rxscan2253_scan:
    set_addr $I10, rxscan2253_loop
    rx2252_cur."!mark_push"(0, rx2252_pos, $I10)
  rxscan2253_done:
.annotate 'line', 1135
  # rx subcapture "sym"
    set_addr $I10, rxcap_2254_fail
    rx2252_cur."!mark_push"(0, rx2252_pos, $I10)
  # rx literal  "||"
    add $I11, rx2252_pos, 2
    gt $I11, rx2252_eos, rx2252_fail
    sub $I11, rx2252_pos, rx2252_off
    substr $S10, rx2252_tgt, $I11, 2
    ne $S10, "||", rx2252_fail
    add rx2252_pos, 2
    set_addr $I10, rxcap_2254_fail
    ($I12, $I11) = rx2252_cur."!mark_peek"($I10)
    rx2252_cur."!cursor_pos"($I11)
    ($P10) = rx2252_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2252_pos, "")
    rx2252_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2254_done
  rxcap_2254_fail:
    goto rx2252_fail
  rxcap_2254_done:
  # rx subrule "O" subtype=capture negate=
    rx2252_cur."!cursor_pos"(rx2252_pos)
    $P10 = rx2252_cur."O"("%tight_or, :pasttype<unless>")
    unless $P10, rx2252_fail
    rx2252_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2252_pos = $P10."pos"()
  # rx pass
    rx2252_cur."!cursor_pass"(rx2252_pos, "infix:sym<||>")
    if_null rx2252_debug, debug_1627
    rx2252_cur."!cursor_debug"("PASS", "infix:sym<||>", " at pos=", rx2252_pos)
  debug_1627:
    .return (rx2252_cur)
  rx2252_restart:
.annotate 'line', 435
    if_null rx2252_debug, debug_1628
    rx2252_cur."!cursor_debug"("NEXT", "infix:sym<||>")
  debug_1628:
  rx2252_fail:
    (rx2252_rep, rx2252_pos, $I10, $P10) = rx2252_cur."!mark_fail"(0)
    lt rx2252_pos, -1, rx2252_done
    eq rx2252_pos, -1, rx2252_fail
    jump $I10
  rx2252_done:
    rx2252_cur."!cursor_fail"()
    if_null rx2252_debug, debug_1629
    rx2252_cur."!cursor_debug"("FAIL", "infix:sym<||>")
  debug_1629:
    .return (rx2252_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<||>"  :subid("394_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("O", "||")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<//>"  :subid("395_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2257_tgt
    .local int rx2257_pos
    .local int rx2257_off
    .local int rx2257_eos
    .local int rx2257_rep
    .local pmc rx2257_cur
    .local pmc rx2257_debug
    (rx2257_cur, rx2257_pos, rx2257_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2257_cur
    .local pmc match
    .lex "$/", match
    length rx2257_eos, rx2257_tgt
    gt rx2257_pos, rx2257_eos, rx2257_done
    set rx2257_off, 0
    lt rx2257_pos, 2, rx2257_start
    sub rx2257_off, rx2257_pos, 1
    substr rx2257_tgt, rx2257_tgt, rx2257_off
  rx2257_start:
    eq $I10, 1, rx2257_restart
    if_null rx2257_debug, debug_1630
    rx2257_cur."!cursor_debug"("START", "infix:sym<//>")
  debug_1630:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2258_done
    goto rxscan2258_scan
  rxscan2258_loop:
    (rx2257_pos) = rx2257_cur."from"()
    inc rx2257_pos
    rx2257_cur."!cursor_from"(rx2257_pos)
    ge rx2257_pos, rx2257_eos, rxscan2258_done
  rxscan2258_scan:
    set_addr $I10, rxscan2258_loop
    rx2257_cur."!mark_push"(0, rx2257_pos, $I10)
  rxscan2258_done:
.annotate 'line', 1136
  # rx subcapture "sym"
    set_addr $I10, rxcap_2259_fail
    rx2257_cur."!mark_push"(0, rx2257_pos, $I10)
  # rx literal  "//"
    add $I11, rx2257_pos, 2
    gt $I11, rx2257_eos, rx2257_fail
    sub $I11, rx2257_pos, rx2257_off
    substr $S10, rx2257_tgt, $I11, 2
    ne $S10, "//", rx2257_fail
    add rx2257_pos, 2
    set_addr $I10, rxcap_2259_fail
    ($I12, $I11) = rx2257_cur."!mark_peek"($I10)
    rx2257_cur."!cursor_pos"($I11)
    ($P10) = rx2257_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2257_pos, "")
    rx2257_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2259_done
  rxcap_2259_fail:
    goto rx2257_fail
  rxcap_2259_done:
  # rx subrule "O" subtype=capture negate=
    rx2257_cur."!cursor_pos"(rx2257_pos)
    $P10 = rx2257_cur."O"("%tight_or, :pasttype<def_or>")
    unless $P10, rx2257_fail
    rx2257_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2257_pos = $P10."pos"()
  # rx pass
    rx2257_cur."!cursor_pass"(rx2257_pos, "infix:sym<//>")
    if_null rx2257_debug, debug_1631
    rx2257_cur."!cursor_debug"("PASS", "infix:sym<//>", " at pos=", rx2257_pos)
  debug_1631:
    .return (rx2257_cur)
  rx2257_restart:
.annotate 'line', 435
    if_null rx2257_debug, debug_1632
    rx2257_cur."!cursor_debug"("NEXT", "infix:sym<//>")
  debug_1632:
  rx2257_fail:
    (rx2257_rep, rx2257_pos, $I10, $P10) = rx2257_cur."!mark_fail"(0)
    lt rx2257_pos, -1, rx2257_done
    eq rx2257_pos, -1, rx2257_fail
    jump $I10
  rx2257_done:
    rx2257_cur."!cursor_fail"()
    if_null rx2257_debug, debug_1633
    rx2257_cur."!cursor_debug"("FAIL", "infix:sym<//>")
  debug_1633:
    .return (rx2257_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<//>"  :subid("396_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("O", "//")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<?? !!>"  :subid("397_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2262_tgt
    .local int rx2262_pos
    .local int rx2262_off
    .local int rx2262_eos
    .local int rx2262_rep
    .local pmc rx2262_cur
    .local pmc rx2262_debug
    (rx2262_cur, rx2262_pos, rx2262_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2262_cur
    .local pmc match
    .lex "$/", match
    length rx2262_eos, rx2262_tgt
    gt rx2262_pos, rx2262_eos, rx2262_done
    set rx2262_off, 0
    lt rx2262_pos, 2, rx2262_start
    sub rx2262_off, rx2262_pos, 1
    substr rx2262_tgt, rx2262_tgt, rx2262_off
  rx2262_start:
    eq $I10, 1, rx2262_restart
    if_null rx2262_debug, debug_1634
    rx2262_cur."!cursor_debug"("START", "infix:sym<?? !!>")
  debug_1634:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2263_done
    goto rxscan2263_scan
  rxscan2263_loop:
    (rx2262_pos) = rx2262_cur."from"()
    inc rx2262_pos
    rx2262_cur."!cursor_from"(rx2262_pos)
    ge rx2262_pos, rx2262_eos, rxscan2263_done
  rxscan2263_scan:
    set_addr $I10, rxscan2263_loop
    rx2262_cur."!mark_push"(0, rx2262_pos, $I10)
  rxscan2263_done:
.annotate 'line', 1139
  # rx literal  "??"
    add $I11, rx2262_pos, 2
    gt $I11, rx2262_eos, rx2262_fail
    sub $I11, rx2262_pos, rx2262_off
    substr $S10, rx2262_tgt, $I11, 2
    ne $S10, "??", rx2262_fail
    add rx2262_pos, 2
.annotate 'line', 1140
  # rx subrule "ws" subtype=method negate=
    rx2262_cur."!cursor_pos"(rx2262_pos)
    $P10 = rx2262_cur."ws"()
    unless $P10, rx2262_fail
    rx2262_pos = $P10."pos"()
.annotate 'line', 1141
  # rx subrule "EXPR" subtype=capture negate=
    rx2262_cur."!cursor_pos"(rx2262_pos)
    $P10 = rx2262_cur."EXPR"("i=")
    unless $P10, rx2262_fail
    rx2262_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx2262_pos = $P10."pos"()
.annotate 'line', 1142
  # rx literal  "!!"
    add $I11, rx2262_pos, 2
    gt $I11, rx2262_eos, rx2262_fail
    sub $I11, rx2262_pos, rx2262_off
    substr $S10, rx2262_tgt, $I11, 2
    ne $S10, "!!", rx2262_fail
    add rx2262_pos, 2
.annotate 'line', 1143
  # rx subrule "O" subtype=capture negate=
    rx2262_cur."!cursor_pos"(rx2262_pos)
    $P10 = rx2262_cur."O"("%conditional, :reducecheck<ternary>, :pasttype<if>")
    unless $P10, rx2262_fail
    rx2262_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2262_pos = $P10."pos"()
.annotate 'line', 1138
  # rx pass
    rx2262_cur."!cursor_pass"(rx2262_pos, "infix:sym<?? !!>")
    if_null rx2262_debug, debug_1635
    rx2262_cur."!cursor_debug"("PASS", "infix:sym<?? !!>", " at pos=", rx2262_pos)
  debug_1635:
    .return (rx2262_cur)
  rx2262_restart:
.annotate 'line', 435
    if_null rx2262_debug, debug_1636
    rx2262_cur."!cursor_debug"("NEXT", "infix:sym<?? !!>")
  debug_1636:
  rx2262_fail:
    (rx2262_rep, rx2262_pos, $I10, $P10) = rx2262_cur."!mark_fail"(0)
    lt rx2262_pos, -1, rx2262_done
    eq rx2262_pos, -1, rx2262_fail
    jump $I10
  rx2262_done:
    rx2262_cur."!cursor_fail"()
    if_null rx2262_debug, debug_1637
    rx2262_cur."!cursor_debug"("FAIL", "infix:sym<?? !!>")
  debug_1637:
    .return (rx2262_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<?? !!>"  :subid("398_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("ws", "??")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=>"  :subid("399_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2266_tgt
    .local int rx2266_pos
    .local int rx2266_off
    .local int rx2266_eos
    .local int rx2266_rep
    .local pmc rx2266_cur
    .local pmc rx2266_debug
    (rx2266_cur, rx2266_pos, rx2266_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2266_cur
    .local pmc match
    .lex "$/", match
    length rx2266_eos, rx2266_tgt
    gt rx2266_pos, rx2266_eos, rx2266_done
    set rx2266_off, 0
    lt rx2266_pos, 2, rx2266_start
    sub rx2266_off, rx2266_pos, 1
    substr rx2266_tgt, rx2266_tgt, rx2266_off
  rx2266_start:
    eq $I10, 1, rx2266_restart
    if_null rx2266_debug, debug_1638
    rx2266_cur."!cursor_debug"("START", "infix:sym<=>")
  debug_1638:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2267_done
    goto rxscan2267_scan
  rxscan2267_loop:
    (rx2266_pos) = rx2266_cur."from"()
    inc rx2266_pos
    rx2266_cur."!cursor_from"(rx2266_pos)
    ge rx2266_pos, rx2266_eos, rxscan2267_done
  rxscan2267_scan:
    set_addr $I10, rxscan2267_loop
    rx2266_cur."!mark_push"(0, rx2266_pos, $I10)
  rxscan2267_done:
.annotate 'line', 1147
  # rx subcapture "sym"
    set_addr $I10, rxcap_2268_fail
    rx2266_cur."!mark_push"(0, rx2266_pos, $I10)
  # rx literal  "="
    add $I11, rx2266_pos, 1
    gt $I11, rx2266_eos, rx2266_fail
    sub $I11, rx2266_pos, rx2266_off
    ord $I11, rx2266_tgt, $I11
    ne $I11, 61, rx2266_fail
    add rx2266_pos, 1
    set_addr $I10, rxcap_2268_fail
    ($I12, $I11) = rx2266_cur."!mark_peek"($I10)
    rx2266_cur."!cursor_pos"($I11)
    ($P10) = rx2266_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2266_pos, "")
    rx2266_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2268_done
  rxcap_2268_fail:
    goto rx2266_fail
  rxcap_2268_done:
  # rx subrule "panic" subtype=method negate=
    rx2266_cur."!cursor_pos"(rx2266_pos)
    $P10 = rx2266_cur."panic"("Assignment (\"=\") not supported in NQP, use \":=\" instead")
    unless $P10, rx2266_fail
    rx2266_pos = $P10."pos"()
.annotate 'line', 1146
  # rx pass
    rx2266_cur."!cursor_pass"(rx2266_pos, "infix:sym<=>")
    if_null rx2266_debug, debug_1639
    rx2266_cur."!cursor_debug"("PASS", "infix:sym<=>", " at pos=", rx2266_pos)
  debug_1639:
    .return (rx2266_cur)
  rx2266_restart:
.annotate 'line', 435
    if_null rx2266_debug, debug_1640
    rx2266_cur."!cursor_debug"("NEXT", "infix:sym<=>")
  debug_1640:
  rx2266_fail:
    (rx2266_rep, rx2266_pos, $I10, $P10) = rx2266_cur."!mark_fail"(0)
    lt rx2266_pos, -1, rx2266_done
    eq rx2266_pos, -1, rx2266_fail
    jump $I10
  rx2266_done:
    rx2266_cur."!cursor_fail"()
    if_null rx2266_debug, debug_1641
    rx2266_cur."!cursor_debug"("FAIL", "infix:sym<=>")
  debug_1641:
    .return (rx2266_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=>"  :subid("400_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("panic", "=")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<:=>"  :subid("401_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2271_tgt
    .local int rx2271_pos
    .local int rx2271_off
    .local int rx2271_eos
    .local int rx2271_rep
    .local pmc rx2271_cur
    .local pmc rx2271_debug
    (rx2271_cur, rx2271_pos, rx2271_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2271_cur
    .local pmc match
    .lex "$/", match
    length rx2271_eos, rx2271_tgt
    gt rx2271_pos, rx2271_eos, rx2271_done
    set rx2271_off, 0
    lt rx2271_pos, 2, rx2271_start
    sub rx2271_off, rx2271_pos, 1
    substr rx2271_tgt, rx2271_tgt, rx2271_off
  rx2271_start:
    eq $I10, 1, rx2271_restart
    if_null rx2271_debug, debug_1642
    rx2271_cur."!cursor_debug"("START", "infix:sym<:=>")
  debug_1642:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2272_done
    goto rxscan2272_scan
  rxscan2272_loop:
    (rx2271_pos) = rx2271_cur."from"()
    inc rx2271_pos
    rx2271_cur."!cursor_from"(rx2271_pos)
    ge rx2271_pos, rx2271_eos, rxscan2272_done
  rxscan2272_scan:
    set_addr $I10, rxscan2272_loop
    rx2271_cur."!mark_push"(0, rx2271_pos, $I10)
  rxscan2272_done:
.annotate 'line', 1149
  # rx subcapture "sym"
    set_addr $I10, rxcap_2273_fail
    rx2271_cur."!mark_push"(0, rx2271_pos, $I10)
  # rx literal  ":="
    add $I11, rx2271_pos, 2
    gt $I11, rx2271_eos, rx2271_fail
    sub $I11, rx2271_pos, rx2271_off
    substr $S10, rx2271_tgt, $I11, 2
    ne $S10, ":=", rx2271_fail
    add rx2271_pos, 2
    set_addr $I10, rxcap_2273_fail
    ($I12, $I11) = rx2271_cur."!mark_peek"($I10)
    rx2271_cur."!cursor_pos"($I11)
    ($P10) = rx2271_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2271_pos, "")
    rx2271_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2273_done
  rxcap_2273_fail:
    goto rx2271_fail
  rxcap_2273_done:
  # rx subrule "O" subtype=capture negate=
    rx2271_cur."!cursor_pos"(rx2271_pos)
    $P10 = rx2271_cur."O"("%assignment, :pasttype<bind_6model>")
    unless $P10, rx2271_fail
    rx2271_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2271_pos = $P10."pos"()
  # rx pass
    rx2271_cur."!cursor_pass"(rx2271_pos, "infix:sym<:=>")
    if_null rx2271_debug, debug_1643
    rx2271_cur."!cursor_debug"("PASS", "infix:sym<:=>", " at pos=", rx2271_pos)
  debug_1643:
    .return (rx2271_cur)
  rx2271_restart:
.annotate 'line', 435
    if_null rx2271_debug, debug_1644
    rx2271_cur."!cursor_debug"("NEXT", "infix:sym<:=>")
  debug_1644:
  rx2271_fail:
    (rx2271_rep, rx2271_pos, $I10, $P10) = rx2271_cur."!mark_fail"(0)
    lt rx2271_pos, -1, rx2271_done
    eq rx2271_pos, -1, rx2271_fail
    jump $I10
  rx2271_done:
    rx2271_cur."!cursor_fail"()
    if_null rx2271_debug, debug_1645
    rx2271_cur."!cursor_debug"("FAIL", "infix:sym<:=>")
  debug_1645:
    .return (rx2271_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<:=>"  :subid("402_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("O", ":=")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<::=>"  :subid("403_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2276_tgt
    .local int rx2276_pos
    .local int rx2276_off
    .local int rx2276_eos
    .local int rx2276_rep
    .local pmc rx2276_cur
    .local pmc rx2276_debug
    (rx2276_cur, rx2276_pos, rx2276_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2276_cur
    .local pmc match
    .lex "$/", match
    length rx2276_eos, rx2276_tgt
    gt rx2276_pos, rx2276_eos, rx2276_done
    set rx2276_off, 0
    lt rx2276_pos, 2, rx2276_start
    sub rx2276_off, rx2276_pos, 1
    substr rx2276_tgt, rx2276_tgt, rx2276_off
  rx2276_start:
    eq $I10, 1, rx2276_restart
    if_null rx2276_debug, debug_1646
    rx2276_cur."!cursor_debug"("START", "infix:sym<::=>")
  debug_1646:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2277_done
    goto rxscan2277_scan
  rxscan2277_loop:
    (rx2276_pos) = rx2276_cur."from"()
    inc rx2276_pos
    rx2276_cur."!cursor_from"(rx2276_pos)
    ge rx2276_pos, rx2276_eos, rxscan2277_done
  rxscan2277_scan:
    set_addr $I10, rxscan2277_loop
    rx2276_cur."!mark_push"(0, rx2276_pos, $I10)
  rxscan2277_done:
.annotate 'line', 1150
  # rx subcapture "sym"
    set_addr $I10, rxcap_2278_fail
    rx2276_cur."!mark_push"(0, rx2276_pos, $I10)
  # rx literal  "::="
    add $I11, rx2276_pos, 3
    gt $I11, rx2276_eos, rx2276_fail
    sub $I11, rx2276_pos, rx2276_off
    substr $S10, rx2276_tgt, $I11, 3
    ne $S10, "::=", rx2276_fail
    add rx2276_pos, 3
    set_addr $I10, rxcap_2278_fail
    ($I12, $I11) = rx2276_cur."!mark_peek"($I10)
    rx2276_cur."!cursor_pos"($I11)
    ($P10) = rx2276_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2276_pos, "")
    rx2276_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2278_done
  rxcap_2278_fail:
    goto rx2276_fail
  rxcap_2278_done:
  # rx subrule "O" subtype=capture negate=
    rx2276_cur."!cursor_pos"(rx2276_pos)
    $P10 = rx2276_cur."O"("%assignment, :pasttype<bind_6model>")
    unless $P10, rx2276_fail
    rx2276_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2276_pos = $P10."pos"()
  # rx pass
    rx2276_cur."!cursor_pass"(rx2276_pos, "infix:sym<::=>")
    if_null rx2276_debug, debug_1647
    rx2276_cur."!cursor_debug"("PASS", "infix:sym<::=>", " at pos=", rx2276_pos)
  debug_1647:
    .return (rx2276_cur)
  rx2276_restart:
.annotate 'line', 435
    if_null rx2276_debug, debug_1648
    rx2276_cur."!cursor_debug"("NEXT", "infix:sym<::=>")
  debug_1648:
  rx2276_fail:
    (rx2276_rep, rx2276_pos, $I10, $P10) = rx2276_cur."!mark_fail"(0)
    lt rx2276_pos, -1, rx2276_done
    eq rx2276_pos, -1, rx2276_fail
    jump $I10
  rx2276_done:
    rx2276_cur."!cursor_fail"()
    if_null rx2276_debug, debug_1649
    rx2276_cur."!cursor_debug"("FAIL", "infix:sym<::=>")
  debug_1649:
    .return (rx2276_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<::=>"  :subid("404_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("O", "::=")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<,>"  :subid("405_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2281_tgt
    .local int rx2281_pos
    .local int rx2281_off
    .local int rx2281_eos
    .local int rx2281_rep
    .local pmc rx2281_cur
    .local pmc rx2281_debug
    (rx2281_cur, rx2281_pos, rx2281_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2281_cur
    .local pmc match
    .lex "$/", match
    length rx2281_eos, rx2281_tgt
    gt rx2281_pos, rx2281_eos, rx2281_done
    set rx2281_off, 0
    lt rx2281_pos, 2, rx2281_start
    sub rx2281_off, rx2281_pos, 1
    substr rx2281_tgt, rx2281_tgt, rx2281_off
  rx2281_start:
    eq $I10, 1, rx2281_restart
    if_null rx2281_debug, debug_1650
    rx2281_cur."!cursor_debug"("START", "infix:sym<,>")
  debug_1650:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2282_done
    goto rxscan2282_scan
  rxscan2282_loop:
    (rx2281_pos) = rx2281_cur."from"()
    inc rx2281_pos
    rx2281_cur."!cursor_from"(rx2281_pos)
    ge rx2281_pos, rx2281_eos, rxscan2282_done
  rxscan2282_scan:
    set_addr $I10, rxscan2282_loop
    rx2281_cur."!mark_push"(0, rx2281_pos, $I10)
  rxscan2282_done:
.annotate 'line', 1152
  # rx subcapture "sym"
    set_addr $I10, rxcap_2283_fail
    rx2281_cur."!mark_push"(0, rx2281_pos, $I10)
  # rx literal  ","
    add $I11, rx2281_pos, 1
    gt $I11, rx2281_eos, rx2281_fail
    sub $I11, rx2281_pos, rx2281_off
    ord $I11, rx2281_tgt, $I11
    ne $I11, 44, rx2281_fail
    add rx2281_pos, 1
    set_addr $I10, rxcap_2283_fail
    ($I12, $I11) = rx2281_cur."!mark_peek"($I10)
    rx2281_cur."!cursor_pos"($I11)
    ($P10) = rx2281_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2281_pos, "")
    rx2281_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2283_done
  rxcap_2283_fail:
    goto rx2281_fail
  rxcap_2283_done:
  # rx subrule "O" subtype=capture negate=
    rx2281_cur."!cursor_pos"(rx2281_pos)
    $P10 = rx2281_cur."O"("%comma, :pasttype<list>")
    unless $P10, rx2281_fail
    rx2281_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2281_pos = $P10."pos"()
  # rx pass
    rx2281_cur."!cursor_pass"(rx2281_pos, "infix:sym<,>")
    if_null rx2281_debug, debug_1651
    rx2281_cur."!cursor_debug"("PASS", "infix:sym<,>", " at pos=", rx2281_pos)
  debug_1651:
    .return (rx2281_cur)
  rx2281_restart:
.annotate 'line', 435
    if_null rx2281_debug, debug_1652
    rx2281_cur."!cursor_debug"("NEXT", "infix:sym<,>")
  debug_1652:
  rx2281_fail:
    (rx2281_rep, rx2281_pos, $I10, $P10) = rx2281_cur."!mark_fail"(0)
    lt rx2281_pos, -1, rx2281_done
    eq rx2281_pos, -1, rx2281_fail
    jump $I10
  rx2281_done:
    rx2281_cur."!cursor_fail"()
    if_null rx2281_debug, debug_1653
    rx2281_cur."!cursor_debug"("FAIL", "infix:sym<,>")
  debug_1653:
    .return (rx2281_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<,>"  :subid("406_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    $P103 = self."!PREFIX__!subrule"("O", ",")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<return>"  :subid("407_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .const 'Sub' $P2290 = "408_1310110678.31883" 
    capture_lex $P2290
    .local string rx2286_tgt
    .local int rx2286_pos
    .local int rx2286_off
    .local int rx2286_eos
    .local int rx2286_rep
    .local pmc rx2286_cur
    .local pmc rx2286_debug
    (rx2286_cur, rx2286_pos, rx2286_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2286_cur
    .local pmc match
    .lex "$/", match
    length rx2286_eos, rx2286_tgt
    gt rx2286_pos, rx2286_eos, rx2286_done
    set rx2286_off, 0
    lt rx2286_pos, 2, rx2286_start
    sub rx2286_off, rx2286_pos, 1
    substr rx2286_tgt, rx2286_tgt, rx2286_off
  rx2286_start:
    eq $I10, 1, rx2286_restart
    if_null rx2286_debug, debug_1654
    rx2286_cur."!cursor_debug"("START", "prefix:sym<return>")
  debug_1654:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2287_done
    goto rxscan2287_scan
  rxscan2287_loop:
    (rx2286_pos) = rx2286_cur."from"()
    inc rx2286_pos
    rx2286_cur."!cursor_from"(rx2286_pos)
    ge rx2286_pos, rx2286_eos, rxscan2287_done
  rxscan2287_scan:
    set_addr $I10, rxscan2287_loop
    rx2286_cur."!mark_push"(0, rx2286_pos, $I10)
  rxscan2287_done:
.annotate 'line', 1154
  # rx subcapture "sym"
    set_addr $I10, rxcap_2288_fail
    rx2286_cur."!mark_push"(0, rx2286_pos, $I10)
  # rx literal  "return"
    add $I11, rx2286_pos, 6
    gt $I11, rx2286_eos, rx2286_fail
    sub $I11, rx2286_pos, rx2286_off
    substr $S10, rx2286_tgt, $I11, 6
    ne $S10, "return", rx2286_fail
    add rx2286_pos, 6
    set_addr $I10, rxcap_2288_fail
    ($I12, $I11) = rx2286_cur."!mark_peek"($I10)
    rx2286_cur."!cursor_pos"($I11)
    ($P10) = rx2286_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2286_pos, "")
    rx2286_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2288_done
  rxcap_2288_fail:
    goto rx2286_fail
  rxcap_2288_done:
  # rx charclass s
    ge rx2286_pos, rx2286_eos, rx2286_fail
    sub $I10, rx2286_pos, rx2286_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx2286_tgt, $I10
    unless $I11, rx2286_fail
    inc rx2286_pos
  # rx subrule "O" subtype=capture negate=
    rx2286_cur."!cursor_pos"(rx2286_pos)
    $P10 = rx2286_cur."O"("%list_prefix, :pasttype<return>")
    unless $P10, rx2286_fail
    rx2286_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2286_pos = $P10."pos"()
    rx2286_cur."!cursor_pos"(rx2286_pos)
    find_lex $P103, unicode:"$\x{a2}"
    $P104 = $P103."MATCH"()
    store_lex "$/", $P104
    .const 'Sub' $P2290 = "408_1310110678.31883" 
    capture_lex $P2290
    $P106 = $P2290()
  # rx pass
    rx2286_cur."!cursor_pass"(rx2286_pos, "prefix:sym<return>")
    if_null rx2286_debug, debug_1655
    rx2286_cur."!cursor_debug"("PASS", "prefix:sym<return>", " at pos=", rx2286_pos)
  debug_1655:
    .return (rx2286_cur)
  rx2286_restart:
.annotate 'line', 435
    if_null rx2286_debug, debug_1656
    rx2286_cur."!cursor_debug"("NEXT", "prefix:sym<return>")
  debug_1656:
  rx2286_fail:
    (rx2286_rep, rx2286_pos, $I10, $P10) = rx2286_cur."!mark_fail"(0)
    lt rx2286_pos, -1, rx2286_done
    eq rx2286_pos, -1, rx2286_fail
    jump $I10
  rx2286_done:
    rx2286_cur."!cursor_fail"()
    if_null rx2286_debug, debug_1657
    rx2286_cur."!cursor_debug"("FAIL", "prefix:sym<return>")
  debug_1657:
    .return (rx2286_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block2289"  :anon :subid("408_1310110678.31883") :outer("407_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1154
    new $P105, "Integer"
    assign $P105, 1
    store_dynamic_lex "$*RETURN_USED", $P105
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<return>"  :subid("409_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    new $P107, "ResizablePMCArray"
    push $P107, "return"
    .return ($P107)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<make>"  :subid("410_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2293_tgt
    .local int rx2293_pos
    .local int rx2293_off
    .local int rx2293_eos
    .local int rx2293_rep
    .local pmc rx2293_cur
    .local pmc rx2293_debug
    (rx2293_cur, rx2293_pos, rx2293_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2293_cur
    .local pmc match
    .lex "$/", match
    length rx2293_eos, rx2293_tgt
    gt rx2293_pos, rx2293_eos, rx2293_done
    set rx2293_off, 0
    lt rx2293_pos, 2, rx2293_start
    sub rx2293_off, rx2293_pos, 1
    substr rx2293_tgt, rx2293_tgt, rx2293_off
  rx2293_start:
    eq $I10, 1, rx2293_restart
    if_null rx2293_debug, debug_1658
    rx2293_cur."!cursor_debug"("START", "prefix:sym<make>")
  debug_1658:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2294_done
    goto rxscan2294_scan
  rxscan2294_loop:
    (rx2293_pos) = rx2293_cur."from"()
    inc rx2293_pos
    rx2293_cur."!cursor_from"(rx2293_pos)
    ge rx2293_pos, rx2293_eos, rxscan2294_done
  rxscan2294_scan:
    set_addr $I10, rxscan2294_loop
    rx2293_cur."!mark_push"(0, rx2293_pos, $I10)
  rxscan2294_done:
.annotate 'line', 1155
  # rx subcapture "sym"
    set_addr $I10, rxcap_2295_fail
    rx2293_cur."!mark_push"(0, rx2293_pos, $I10)
  # rx literal  "make"
    add $I11, rx2293_pos, 4
    gt $I11, rx2293_eos, rx2293_fail
    sub $I11, rx2293_pos, rx2293_off
    substr $S10, rx2293_tgt, $I11, 4
    ne $S10, "make", rx2293_fail
    add rx2293_pos, 4
    set_addr $I10, rxcap_2295_fail
    ($I12, $I11) = rx2293_cur."!mark_peek"($I10)
    rx2293_cur."!cursor_pos"($I11)
    ($P10) = rx2293_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2293_pos, "")
    rx2293_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2295_done
  rxcap_2295_fail:
    goto rx2293_fail
  rxcap_2295_done:
  # rx charclass s
    ge rx2293_pos, rx2293_eos, rx2293_fail
    sub $I10, rx2293_pos, rx2293_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx2293_tgt, $I10
    unless $I11, rx2293_fail
    inc rx2293_pos
  # rx subrule "O" subtype=capture negate=
    rx2293_cur."!cursor_pos"(rx2293_pos)
    $P10 = rx2293_cur."O"("%list_prefix")
    unless $P10, rx2293_fail
    rx2293_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2293_pos = $P10."pos"()
  # rx pass
    rx2293_cur."!cursor_pass"(rx2293_pos, "prefix:sym<make>")
    if_null rx2293_debug, debug_1659
    rx2293_cur."!cursor_debug"("PASS", "prefix:sym<make>", " at pos=", rx2293_pos)
  debug_1659:
    .return (rx2293_cur)
  rx2293_restart:
.annotate 'line', 435
    if_null rx2293_debug, debug_1660
    rx2293_cur."!cursor_debug"("NEXT", "prefix:sym<make>")
  debug_1660:
  rx2293_fail:
    (rx2293_rep, rx2293_pos, $I10, $P10) = rx2293_cur."!mark_fail"(0)
    lt rx2293_pos, -1, rx2293_done
    eq rx2293_pos, -1, rx2293_fail
    jump $I10
  rx2293_done:
    rx2293_cur."!cursor_fail"()
    if_null rx2293_debug, debug_1661
    rx2293_cur."!cursor_debug"("FAIL", "prefix:sym<make>")
  debug_1661:
    .return (rx2293_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<make>"  :subid("411_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    new $P103, "ResizablePMCArray"
    push $P103, "make"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<last>"  :subid("412_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2298_tgt
    .local int rx2298_pos
    .local int rx2298_off
    .local int rx2298_eos
    .local int rx2298_rep
    .local pmc rx2298_cur
    .local pmc rx2298_debug
    (rx2298_cur, rx2298_pos, rx2298_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2298_cur
    .local pmc match
    .lex "$/", match
    length rx2298_eos, rx2298_tgt
    gt rx2298_pos, rx2298_eos, rx2298_done
    set rx2298_off, 0
    lt rx2298_pos, 2, rx2298_start
    sub rx2298_off, rx2298_pos, 1
    substr rx2298_tgt, rx2298_tgt, rx2298_off
  rx2298_start:
    eq $I10, 1, rx2298_restart
    if_null rx2298_debug, debug_1662
    rx2298_cur."!cursor_debug"("START", "term:sym<last>")
  debug_1662:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2299_done
    goto rxscan2299_scan
  rxscan2299_loop:
    (rx2298_pos) = rx2298_cur."from"()
    inc rx2298_pos
    rx2298_cur."!cursor_from"(rx2298_pos)
    ge rx2298_pos, rx2298_eos, rxscan2299_done
  rxscan2299_scan:
    set_addr $I10, rxscan2299_loop
    rx2298_cur."!mark_push"(0, rx2298_pos, $I10)
  rxscan2299_done:
.annotate 'line', 1156
  # rx subcapture "sym"
    set_addr $I10, rxcap_2300_fail
    rx2298_cur."!mark_push"(0, rx2298_pos, $I10)
  # rx literal  "last"
    add $I11, rx2298_pos, 4
    gt $I11, rx2298_eos, rx2298_fail
    sub $I11, rx2298_pos, rx2298_off
    substr $S10, rx2298_tgt, $I11, 4
    ne $S10, "last", rx2298_fail
    add rx2298_pos, 4
    set_addr $I10, rxcap_2300_fail
    ($I12, $I11) = rx2298_cur."!mark_peek"($I10)
    rx2298_cur."!cursor_pos"($I11)
    ($P10) = rx2298_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2298_pos, "")
    rx2298_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2300_done
  rxcap_2300_fail:
    goto rx2298_fail
  rxcap_2300_done:
  # rx pass
    rx2298_cur."!cursor_pass"(rx2298_pos, "term:sym<last>")
    if_null rx2298_debug, debug_1663
    rx2298_cur."!cursor_debug"("PASS", "term:sym<last>", " at pos=", rx2298_pos)
  debug_1663:
    .return (rx2298_cur)
  rx2298_restart:
.annotate 'line', 435
    if_null rx2298_debug, debug_1664
    rx2298_cur."!cursor_debug"("NEXT", "term:sym<last>")
  debug_1664:
  rx2298_fail:
    (rx2298_rep, rx2298_pos, $I10, $P10) = rx2298_cur."!mark_fail"(0)
    lt rx2298_pos, -1, rx2298_done
    eq rx2298_pos, -1, rx2298_fail
    jump $I10
  rx2298_done:
    rx2298_cur."!cursor_fail"()
    if_null rx2298_debug, debug_1665
    rx2298_cur."!cursor_debug"("FAIL", "term:sym<last>")
  debug_1665:
    .return (rx2298_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<last>"  :subid("413_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    new $P103, "ResizablePMCArray"
    push $P103, "last"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<next>"  :subid("414_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2303_tgt
    .local int rx2303_pos
    .local int rx2303_off
    .local int rx2303_eos
    .local int rx2303_rep
    .local pmc rx2303_cur
    .local pmc rx2303_debug
    (rx2303_cur, rx2303_pos, rx2303_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2303_cur
    .local pmc match
    .lex "$/", match
    length rx2303_eos, rx2303_tgt
    gt rx2303_pos, rx2303_eos, rx2303_done
    set rx2303_off, 0
    lt rx2303_pos, 2, rx2303_start
    sub rx2303_off, rx2303_pos, 1
    substr rx2303_tgt, rx2303_tgt, rx2303_off
  rx2303_start:
    eq $I10, 1, rx2303_restart
    if_null rx2303_debug, debug_1666
    rx2303_cur."!cursor_debug"("START", "term:sym<next>")
  debug_1666:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2304_done
    goto rxscan2304_scan
  rxscan2304_loop:
    (rx2303_pos) = rx2303_cur."from"()
    inc rx2303_pos
    rx2303_cur."!cursor_from"(rx2303_pos)
    ge rx2303_pos, rx2303_eos, rxscan2304_done
  rxscan2304_scan:
    set_addr $I10, rxscan2304_loop
    rx2303_cur."!mark_push"(0, rx2303_pos, $I10)
  rxscan2304_done:
.annotate 'line', 1157
  # rx subcapture "sym"
    set_addr $I10, rxcap_2305_fail
    rx2303_cur."!mark_push"(0, rx2303_pos, $I10)
  # rx literal  "next"
    add $I11, rx2303_pos, 4
    gt $I11, rx2303_eos, rx2303_fail
    sub $I11, rx2303_pos, rx2303_off
    substr $S10, rx2303_tgt, $I11, 4
    ne $S10, "next", rx2303_fail
    add rx2303_pos, 4
    set_addr $I10, rxcap_2305_fail
    ($I12, $I11) = rx2303_cur."!mark_peek"($I10)
    rx2303_cur."!cursor_pos"($I11)
    ($P10) = rx2303_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2303_pos, "")
    rx2303_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2305_done
  rxcap_2305_fail:
    goto rx2303_fail
  rxcap_2305_done:
  # rx pass
    rx2303_cur."!cursor_pass"(rx2303_pos, "term:sym<next>")
    if_null rx2303_debug, debug_1667
    rx2303_cur."!cursor_debug"("PASS", "term:sym<next>", " at pos=", rx2303_pos)
  debug_1667:
    .return (rx2303_cur)
  rx2303_restart:
.annotate 'line', 435
    if_null rx2303_debug, debug_1668
    rx2303_cur."!cursor_debug"("NEXT", "term:sym<next>")
  debug_1668:
  rx2303_fail:
    (rx2303_rep, rx2303_pos, $I10, $P10) = rx2303_cur."!mark_fail"(0)
    lt rx2303_pos, -1, rx2303_done
    eq rx2303_pos, -1, rx2303_fail
    jump $I10
  rx2303_done:
    rx2303_cur."!cursor_fail"()
    if_null rx2303_debug, debug_1669
    rx2303_cur."!cursor_debug"("FAIL", "term:sym<next>")
  debug_1669:
    .return (rx2303_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<next>"  :subid("415_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    new $P103, "ResizablePMCArray"
    push $P103, "next"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<redo>"  :subid("416_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    .local string rx2308_tgt
    .local int rx2308_pos
    .local int rx2308_off
    .local int rx2308_eos
    .local int rx2308_rep
    .local pmc rx2308_cur
    .local pmc rx2308_debug
    (rx2308_cur, rx2308_pos, rx2308_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2308_cur
    .local pmc match
    .lex "$/", match
    length rx2308_eos, rx2308_tgt
    gt rx2308_pos, rx2308_eos, rx2308_done
    set rx2308_off, 0
    lt rx2308_pos, 2, rx2308_start
    sub rx2308_off, rx2308_pos, 1
    substr rx2308_tgt, rx2308_tgt, rx2308_off
  rx2308_start:
    eq $I10, 1, rx2308_restart
    if_null rx2308_debug, debug_1670
    rx2308_cur."!cursor_debug"("START", "term:sym<redo>")
  debug_1670:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2309_done
    goto rxscan2309_scan
  rxscan2309_loop:
    (rx2308_pos) = rx2308_cur."from"()
    inc rx2308_pos
    rx2308_cur."!cursor_from"(rx2308_pos)
    ge rx2308_pos, rx2308_eos, rxscan2309_done
  rxscan2309_scan:
    set_addr $I10, rxscan2309_loop
    rx2308_cur."!mark_push"(0, rx2308_pos, $I10)
  rxscan2309_done:
.annotate 'line', 1158
  # rx subcapture "sym"
    set_addr $I10, rxcap_2310_fail
    rx2308_cur."!mark_push"(0, rx2308_pos, $I10)
  # rx literal  "redo"
    add $I11, rx2308_pos, 4
    gt $I11, rx2308_eos, rx2308_fail
    sub $I11, rx2308_pos, rx2308_off
    substr $S10, rx2308_tgt, $I11, 4
    ne $S10, "redo", rx2308_fail
    add rx2308_pos, 4
    set_addr $I10, rxcap_2310_fail
    ($I12, $I11) = rx2308_cur."!mark_peek"($I10)
    rx2308_cur."!cursor_pos"($I11)
    ($P10) = rx2308_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2308_pos, "")
    rx2308_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2310_done
  rxcap_2310_fail:
    goto rx2308_fail
  rxcap_2310_done:
  # rx pass
    rx2308_cur."!cursor_pass"(rx2308_pos, "term:sym<redo>")
    if_null rx2308_debug, debug_1671
    rx2308_cur."!cursor_debug"("PASS", "term:sym<redo>", " at pos=", rx2308_pos)
  debug_1671:
    .return (rx2308_cur)
  rx2308_restart:
.annotate 'line', 435
    if_null rx2308_debug, debug_1672
    rx2308_cur."!cursor_debug"("NEXT", "term:sym<redo>")
  debug_1672:
  rx2308_fail:
    (rx2308_rep, rx2308_pos, $I10, $P10) = rx2308_cur."!mark_fail"(0)
    lt rx2308_pos, -1, rx2308_done
    eq rx2308_pos, -1, rx2308_fail
    jump $I10
  rx2308_done:
    rx2308_cur."!cursor_fail"()
    if_null rx2308_debug, debug_1673
    rx2308_cur."!cursor_debug"("FAIL", "term:sym<redo>")
  debug_1673:
    .return (rx2308_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<redo>"  :subid("417_1310110678.31883") :method :outer("40_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 435
    new $P103, "ResizablePMCArray"
    push $P103, "redo"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "smartmatch" :anon :subid("418_1310110678.31883") :outer("40_1310110678.31883")
    .param pmc param_2313
    .param pmc param_2314
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1160
    .lex "self", param_2313
    .lex "$/", param_2314
.annotate 'line', 1162
    new $P103, "Undef"
    set $P2315, $P103
    .lex "$t", $P2315
    find_lex $P2316, "$/"
    unless_null $P2316, vivify_1674
    $P2316 = root_new ['parrot';'ResizablePMCArray']
  vivify_1674:
    set $P104, $P2316[0]
    unless_null $P104, vivify_1675
    new $P104, "Undef"
  vivify_1675:
    store_lex "$t", $P104
    find_lex $P2317, "$/"
    unless_null $P2317, vivify_1676
    $P2317 = root_new ['parrot';'ResizablePMCArray']
  vivify_1676:
    set $P104, $P2317[1]
    unless_null $P104, vivify_1677
    new $P104, "Undef"
  vivify_1677:
    find_lex $P2318, "$/"
    unless_null $P2318, vivify_1678
    $P2318 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P2318
  vivify_1678:
    set $P2318[0], $P104
    find_lex $P104, "$t"
    unless_null $P104, vivify_1679
    new $P104, "Undef"
  vivify_1679:
    find_lex $P2319, "$/"
    unless_null $P2319, vivify_1680
    $P2319 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P2319
  vivify_1680:
    set $P2319[1], $P104
.annotate 'line', 1160
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2321"  :subid("419_1310110678.31883") :outer("10_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1166
    .const 'Sub' $P2375 = "439_1310110678.31883" 
    capture_lex $P2375
    .const 'Sub' $P2372 = "438_1310110678.31883" 
    capture_lex $P2372
    .const 'Sub' $P2371 = "437_1310110678.31883" 
    capture_lex $P2371
    .const 'Sub' $P2368 = "436_1310110678.31883" 
    capture_lex $P2368
    .const 'Sub' $P2367 = "435_1310110678.31883" 
    capture_lex $P2367
    .const 'Sub' $P2358 = "433_1310110678.31883" 
    capture_lex $P2358
    .const 'Sub' $P2357 = "432_1310110678.31883" 
    capture_lex $P2357
    .const 'Sub' $P2349 = "430_1310110678.31883" 
    capture_lex $P2349
    .const 'Sub' $P2348 = "429_1310110678.31883" 
    capture_lex $P2348
    .const 'Sub' $P2345 = "428_1310110678.31883" 
    capture_lex $P2345
    .const 'Sub' $P2344 = "427_1310110678.31883" 
    capture_lex $P2344
    .const 'Sub' $P2337 = "425_1310110678.31883" 
    capture_lex $P2337
    .const 'Sub' $P2336 = "424_1310110678.31883" 
    capture_lex $P2336
    .const 'Sub' $P2333 = "423_1310110678.31883" 
    capture_lex $P2333
    .const 'Sub' $P2332 = "422_1310110678.31883" 
    capture_lex $P2332
    .const 'Sub' $P2325 = "420_1310110678.31883" 
    capture_lex $P2325
    .lex "$?PACKAGE", $P2323
    .lex "$?CLASS", $P2324
    .const 'Sub' $P2375 = "439_1310110678.31883" 
    capture_lex $P2375
    .return ($P2375)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<:my>"  :subid("420_1310110678.31883") :method :outer("419_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1166
    .const 'Sub' $P2329 = "421_1310110678.31883" 
    capture_lex $P2329
    .local string rx2326_tgt
    .local int rx2326_pos
    .local int rx2326_off
    .local int rx2326_eos
    .local int rx2326_rep
    .local pmc rx2326_cur
    .local pmc rx2326_debug
    (rx2326_cur, rx2326_pos, rx2326_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2326_cur
    .local pmc match
    .lex "$/", match
    length rx2326_eos, rx2326_tgt
    gt rx2326_pos, rx2326_eos, rx2326_done
    set rx2326_off, 0
    lt rx2326_pos, 2, rx2326_start
    sub rx2326_off, rx2326_pos, 1
    substr rx2326_tgt, rx2326_tgt, rx2326_off
  rx2326_start:
    eq $I10, 1, rx2326_restart
    if_null rx2326_debug, debug_1681
    rx2326_cur."!cursor_debug"("START", "metachar:sym<:my>")
  debug_1681:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2327_done
    goto rxscan2327_scan
  rxscan2327_loop:
    (rx2326_pos) = rx2326_cur."from"()
    inc rx2326_pos
    rx2326_cur."!cursor_from"(rx2326_pos)
    ge rx2326_pos, rx2326_eos, rxscan2327_done
  rxscan2327_scan:
    set_addr $I10, rxscan2327_loop
    rx2326_cur."!mark_push"(0, rx2326_pos, $I10)
  rxscan2327_done:
.annotate 'line', 1168
  # rx literal  ":"
    add $I11, rx2326_pos, 1
    gt $I11, rx2326_eos, rx2326_fail
    sub $I11, rx2326_pos, rx2326_off
    ord $I11, rx2326_tgt, $I11
    ne $I11, 58, rx2326_fail
    add rx2326_pos, 1
  # rx subrule "before" subtype=zerowidth negate=
    rx2326_cur."!cursor_pos"(rx2326_pos)
    .const 'Sub' $P2329 = "421_1310110678.31883" 
    capture_lex $P2329
    $P10 = rx2326_cur."before"($P2329)
    unless $P10, rx2326_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2326_cur."!cursor_pos"(rx2326_pos)
    $P10 = rx2326_cur."LANG"("MAIN", "statement")
    unless $P10, rx2326_fail
    rx2326_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx2326_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2326_cur."!cursor_pos"(rx2326_pos)
    $P10 = rx2326_cur."ws"()
    unless $P10, rx2326_fail
    rx2326_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx2326_pos, 1
    gt $I11, rx2326_eos, rx2326_fail
    sub $I11, rx2326_pos, rx2326_off
    ord $I11, rx2326_tgt, $I11
    ne $I11, 59, rx2326_fail
    add rx2326_pos, 1
.annotate 'line', 1167
  # rx pass
    rx2326_cur."!cursor_pass"(rx2326_pos, "metachar:sym<:my>")
    if_null rx2326_debug, debug_1686
    rx2326_cur."!cursor_debug"("PASS", "metachar:sym<:my>", " at pos=", rx2326_pos)
  debug_1686:
    .return (rx2326_cur)
  rx2326_restart:
.annotate 'line', 1166
    if_null rx2326_debug, debug_1687
    rx2326_cur."!cursor_debug"("NEXT", "metachar:sym<:my>")
  debug_1687:
  rx2326_fail:
    (rx2326_rep, rx2326_pos, $I10, $P10) = rx2326_cur."!mark_fail"(0)
    lt rx2326_pos, -1, rx2326_done
    eq rx2326_pos, -1, rx2326_fail
    jump $I10
  rx2326_done:
    rx2326_cur."!cursor_fail"()
    if_null rx2326_debug, debug_1688
    rx2326_cur."!cursor_debug"("FAIL", "metachar:sym<:my>")
  debug_1688:
    .return (rx2326_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2328"  :anon :subid("421_1310110678.31883") :method :outer("420_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1168
    .local string rx2330_tgt
    .local int rx2330_pos
    .local int rx2330_off
    .local int rx2330_eos
    .local int rx2330_rep
    .local pmc rx2330_cur
    .local pmc rx2330_debug
    (rx2330_cur, rx2330_pos, rx2330_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2330_cur
    .local pmc match
    .lex "$/", match
    length rx2330_eos, rx2330_tgt
    gt rx2330_pos, rx2330_eos, rx2330_done
    set rx2330_off, 0
    lt rx2330_pos, 2, rx2330_start
    sub rx2330_off, rx2330_pos, 1
    substr rx2330_tgt, rx2330_tgt, rx2330_off
  rx2330_start:
    eq $I10, 1, rx2330_restart
    if_null rx2330_debug, debug_1682
    rx2330_cur."!cursor_debug"("START", "")
  debug_1682:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2331_done
    goto rxscan2331_scan
  rxscan2331_loop:
    (rx2330_pos) = rx2330_cur."from"()
    inc rx2330_pos
    rx2330_cur."!cursor_from"(rx2330_pos)
    ge rx2330_pos, rx2330_eos, rxscan2331_done
  rxscan2331_scan:
    set_addr $I10, rxscan2331_loop
    rx2330_cur."!mark_push"(0, rx2330_pos, $I10)
  rxscan2331_done:
  # rx literal  "my"
    add $I11, rx2330_pos, 2
    gt $I11, rx2330_eos, rx2330_fail
    sub $I11, rx2330_pos, rx2330_off
    substr $S10, rx2330_tgt, $I11, 2
    ne $S10, "my", rx2330_fail
    add rx2330_pos, 2
  # rx pass
    rx2330_cur."!cursor_pass"(rx2330_pos, "")
    if_null rx2330_debug, debug_1683
    rx2330_cur."!cursor_debug"("PASS", "", " at pos=", rx2330_pos)
  debug_1683:
    .return (rx2330_cur)
  rx2330_restart:
    if_null rx2330_debug, debug_1684
    rx2330_cur."!cursor_debug"("NEXT", "")
  debug_1684:
  rx2330_fail:
    (rx2330_rep, rx2330_pos, $I10, $P10) = rx2330_cur."!mark_fail"(0)
    lt rx2330_pos, -1, rx2330_done
    eq rx2330_pos, -1, rx2330_fail
    jump $I10
  rx2330_done:
    rx2330_cur."!cursor_fail"()
    if_null rx2330_debug, debug_1685
    rx2330_cur."!cursor_debug"("FAIL", "")
  debug_1685:
    .return (rx2330_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<:my>"  :subid("422_1310110678.31883") :method :outer("419_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1166
    new $P103, "ResizablePMCArray"
    push $P103, ":"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<{ }>"  :subid("423_1310110678.31883") :method :outer("419_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1166
    .local string rx2334_tgt
    .local int rx2334_pos
    .local int rx2334_off
    .local int rx2334_eos
    .local int rx2334_rep
    .local pmc rx2334_cur
    .local pmc rx2334_debug
    (rx2334_cur, rx2334_pos, rx2334_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2334_cur
    .local pmc match
    .lex "$/", match
    length rx2334_eos, rx2334_tgt
    gt rx2334_pos, rx2334_eos, rx2334_done
    set rx2334_off, 0
    lt rx2334_pos, 2, rx2334_start
    sub rx2334_off, rx2334_pos, 1
    substr rx2334_tgt, rx2334_tgt, rx2334_off
  rx2334_start:
    eq $I10, 1, rx2334_restart
    if_null rx2334_debug, debug_1689
    rx2334_cur."!cursor_debug"("START", "metachar:sym<{ }>")
  debug_1689:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2335_done
    goto rxscan2335_scan
  rxscan2335_loop:
    (rx2334_pos) = rx2334_cur."from"()
    inc rx2334_pos
    rx2334_cur."!cursor_from"(rx2334_pos)
    ge rx2334_pos, rx2334_eos, rxscan2335_done
  rxscan2335_scan:
    set_addr $I10, rxscan2335_loop
    rx2334_cur."!mark_push"(0, rx2334_pos, $I10)
  rxscan2335_done:
.annotate 'line', 1172
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2334_pos, rx2334_off
    substr $S10, rx2334_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2334_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx2334_cur."!cursor_pos"(rx2334_pos)
    $P10 = rx2334_cur."codeblock"()
    unless $P10, rx2334_fail
    rx2334_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2334_pos = $P10."pos"()
.annotate 'line', 1171
  # rx pass
    rx2334_cur."!cursor_pass"(rx2334_pos, "metachar:sym<{ }>")
    if_null rx2334_debug, debug_1690
    rx2334_cur."!cursor_debug"("PASS", "metachar:sym<{ }>", " at pos=", rx2334_pos)
  debug_1690:
    .return (rx2334_cur)
  rx2334_restart:
.annotate 'line', 1166
    if_null rx2334_debug, debug_1691
    rx2334_cur."!cursor_debug"("NEXT", "metachar:sym<{ }>")
  debug_1691:
  rx2334_fail:
    (rx2334_rep, rx2334_pos, $I10, $P10) = rx2334_cur."!mark_fail"(0)
    lt rx2334_pos, -1, rx2334_done
    eq rx2334_pos, -1, rx2334_fail
    jump $I10
  rx2334_done:
    rx2334_cur."!cursor_fail"()
    if_null rx2334_debug, debug_1692
    rx2334_cur."!cursor_debug"("FAIL", "metachar:sym<{ }>")
  debug_1692:
    .return (rx2334_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<{ }>"  :subid("424_1310110678.31883") :method :outer("419_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1166
    new $P103, "ResizablePMCArray"
    push $P103, "{"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<nqpvar>"  :subid("425_1310110678.31883") :method :outer("419_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1166
    .const 'Sub' $P2341 = "426_1310110678.31883" 
    capture_lex $P2341
    .local string rx2338_tgt
    .local int rx2338_pos
    .local int rx2338_off
    .local int rx2338_eos
    .local int rx2338_rep
    .local pmc rx2338_cur
    .local pmc rx2338_debug
    (rx2338_cur, rx2338_pos, rx2338_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2338_cur
    .local pmc match
    .lex "$/", match
    length rx2338_eos, rx2338_tgt
    gt rx2338_pos, rx2338_eos, rx2338_done
    set rx2338_off, 0
    lt rx2338_pos, 2, rx2338_start
    sub rx2338_off, rx2338_pos, 1
    substr rx2338_tgt, rx2338_tgt, rx2338_off
  rx2338_start:
    eq $I10, 1, rx2338_restart
    if_null rx2338_debug, debug_1693
    rx2338_cur."!cursor_debug"("START", "metachar:sym<nqpvar>")
  debug_1693:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2339_done
    goto rxscan2339_scan
  rxscan2339_loop:
    (rx2338_pos) = rx2338_cur."from"()
    inc rx2338_pos
    rx2338_cur."!cursor_from"(rx2338_pos)
    ge rx2338_pos, rx2338_eos, rxscan2339_done
  rxscan2339_scan:
    set_addr $I10, rxscan2339_loop
    rx2338_cur."!mark_push"(0, rx2338_pos, $I10)
  rxscan2339_done:
.annotate 'line', 1176
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2338_pos, rx2338_off
    substr $S10, rx2338_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx2338_fail
  # rx subrule "before" subtype=zerowidth negate=
    rx2338_cur."!cursor_pos"(rx2338_pos)
    .const 'Sub' $P2341 = "426_1310110678.31883" 
    capture_lex $P2341
    $P10 = rx2338_cur."before"($P2341)
    unless $P10, rx2338_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2338_cur."!cursor_pos"(rx2338_pos)
    $P10 = rx2338_cur."LANG"("MAIN", "variable")
    unless $P10, rx2338_fail
    rx2338_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx2338_pos = $P10."pos"()
.annotate 'line', 1175
  # rx pass
    rx2338_cur."!cursor_pass"(rx2338_pos, "metachar:sym<nqpvar>")
    if_null rx2338_debug, debug_1698
    rx2338_cur."!cursor_debug"("PASS", "metachar:sym<nqpvar>", " at pos=", rx2338_pos)
  debug_1698:
    .return (rx2338_cur)
  rx2338_restart:
.annotate 'line', 1166
    if_null rx2338_debug, debug_1699
    rx2338_cur."!cursor_debug"("NEXT", "metachar:sym<nqpvar>")
  debug_1699:
  rx2338_fail:
    (rx2338_rep, rx2338_pos, $I10, $P10) = rx2338_cur."!mark_fail"(0)
    lt rx2338_pos, -1, rx2338_done
    eq rx2338_pos, -1, rx2338_fail
    jump $I10
  rx2338_done:
    rx2338_cur."!cursor_fail"()
    if_null rx2338_debug, debug_1700
    rx2338_cur."!cursor_debug"("FAIL", "metachar:sym<nqpvar>")
  debug_1700:
    .return (rx2338_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2340"  :anon :subid("426_1310110678.31883") :method :outer("425_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1176
    .local string rx2342_tgt
    .local int rx2342_pos
    .local int rx2342_off
    .local int rx2342_eos
    .local int rx2342_rep
    .local pmc rx2342_cur
    .local pmc rx2342_debug
    (rx2342_cur, rx2342_pos, rx2342_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2342_cur
    .local pmc match
    .lex "$/", match
    length rx2342_eos, rx2342_tgt
    gt rx2342_pos, rx2342_eos, rx2342_done
    set rx2342_off, 0
    lt rx2342_pos, 2, rx2342_start
    sub rx2342_off, rx2342_pos, 1
    substr rx2342_tgt, rx2342_tgt, rx2342_off
  rx2342_start:
    eq $I10, 1, rx2342_restart
    if_null rx2342_debug, debug_1694
    rx2342_cur."!cursor_debug"("START", "")
  debug_1694:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2343_done
    goto rxscan2343_scan
  rxscan2343_loop:
    (rx2342_pos) = rx2342_cur."from"()
    inc rx2342_pos
    rx2342_cur."!cursor_from"(rx2342_pos)
    ge rx2342_pos, rx2342_eos, rxscan2343_done
  rxscan2343_scan:
    set_addr $I10, rxscan2343_loop
    rx2342_cur."!mark_push"(0, rx2342_pos, $I10)
  rxscan2343_done:
  # rx charclass .
    ge rx2342_pos, rx2342_eos, rx2342_fail
    inc rx2342_pos
  # rx charclass w
    ge rx2342_pos, rx2342_eos, rx2342_fail
    sub $I10, rx2342_pos, rx2342_off
    is_cclass $I11, .CCLASS_WORD, rx2342_tgt, $I10
    unless $I11, rx2342_fail
    inc rx2342_pos
  # rx pass
    rx2342_cur."!cursor_pass"(rx2342_pos, "")
    if_null rx2342_debug, debug_1695
    rx2342_cur."!cursor_debug"("PASS", "", " at pos=", rx2342_pos)
  debug_1695:
    .return (rx2342_cur)
  rx2342_restart:
    if_null rx2342_debug, debug_1696
    rx2342_cur."!cursor_debug"("NEXT", "")
  debug_1696:
  rx2342_fail:
    (rx2342_rep, rx2342_pos, $I10, $P10) = rx2342_cur."!mark_fail"(0)
    lt rx2342_pos, -1, rx2342_done
    eq rx2342_pos, -1, rx2342_fail
    jump $I10
  rx2342_done:
    rx2342_cur."!cursor_fail"()
    if_null rx2342_debug, debug_1697
    rx2342_cur."!cursor_debug"("FAIL", "")
  debug_1697:
    .return (rx2342_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<nqpvar>"  :subid("427_1310110678.31883") :method :outer("419_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1166
    new $P103, "ResizablePMCArray"
    push $P103, "$"
    push $P103, "@"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<{ }>"  :subid("428_1310110678.31883") :method :outer("419_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1166
    .local string rx2346_tgt
    .local int rx2346_pos
    .local int rx2346_off
    .local int rx2346_eos
    .local int rx2346_rep
    .local pmc rx2346_cur
    .local pmc rx2346_debug
    (rx2346_cur, rx2346_pos, rx2346_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2346_cur
    .local pmc match
    .lex "$/", match
    length rx2346_eos, rx2346_tgt
    gt rx2346_pos, rx2346_eos, rx2346_done
    set rx2346_off, 0
    lt rx2346_pos, 2, rx2346_start
    sub rx2346_off, rx2346_pos, 1
    substr rx2346_tgt, rx2346_tgt, rx2346_off
  rx2346_start:
    eq $I10, 1, rx2346_restart
    if_null rx2346_debug, debug_1701
    rx2346_cur."!cursor_debug"("START", "assertion:sym<{ }>")
  debug_1701:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2347_done
    goto rxscan2347_scan
  rxscan2347_loop:
    (rx2346_pos) = rx2346_cur."from"()
    inc rx2346_pos
    rx2346_cur."!cursor_from"(rx2346_pos)
    ge rx2346_pos, rx2346_eos, rxscan2347_done
  rxscan2347_scan:
    set_addr $I10, rxscan2347_loop
    rx2346_cur."!mark_push"(0, rx2346_pos, $I10)
  rxscan2347_done:
.annotate 'line', 1180
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2346_pos, rx2346_off
    substr $S10, rx2346_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2346_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx2346_cur."!cursor_pos"(rx2346_pos)
    $P10 = rx2346_cur."codeblock"()
    unless $P10, rx2346_fail
    rx2346_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2346_pos = $P10."pos"()
.annotate 'line', 1179
  # rx pass
    rx2346_cur."!cursor_pass"(rx2346_pos, "assertion:sym<{ }>")
    if_null rx2346_debug, debug_1702
    rx2346_cur."!cursor_debug"("PASS", "assertion:sym<{ }>", " at pos=", rx2346_pos)
  debug_1702:
    .return (rx2346_cur)
  rx2346_restart:
.annotate 'line', 1166
    if_null rx2346_debug, debug_1703
    rx2346_cur."!cursor_debug"("NEXT", "assertion:sym<{ }>")
  debug_1703:
  rx2346_fail:
    (rx2346_rep, rx2346_pos, $I10, $P10) = rx2346_cur."!mark_fail"(0)
    lt rx2346_pos, -1, rx2346_done
    eq rx2346_pos, -1, rx2346_fail
    jump $I10
  rx2346_done:
    rx2346_cur."!cursor_fail"()
    if_null rx2346_debug, debug_1704
    rx2346_cur."!cursor_debug"("FAIL", "assertion:sym<{ }>")
  debug_1704:
    .return (rx2346_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<{ }>"  :subid("429_1310110678.31883") :method :outer("419_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1166
    new $P103, "ResizablePMCArray"
    push $P103, "{"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<?{ }>"  :subid("430_1310110678.31883") :method :outer("419_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1166
    .const 'Sub' $P2353 = "431_1310110678.31883" 
    capture_lex $P2353
    .local string rx2350_tgt
    .local int rx2350_pos
    .local int rx2350_off
    .local int rx2350_eos
    .local int rx2350_rep
    .local pmc rx2350_cur
    .local pmc rx2350_debug
    (rx2350_cur, rx2350_pos, rx2350_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2350_cur
    .local pmc match
    .lex "$/", match
    length rx2350_eos, rx2350_tgt
    gt rx2350_pos, rx2350_eos, rx2350_done
    set rx2350_off, 0
    lt rx2350_pos, 2, rx2350_start
    sub rx2350_off, rx2350_pos, 1
    substr rx2350_tgt, rx2350_tgt, rx2350_off
  rx2350_start:
    eq $I10, 1, rx2350_restart
    if_null rx2350_debug, debug_1705
    rx2350_cur."!cursor_debug"("START", "assertion:sym<?{ }>")
  debug_1705:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2351_done
    goto rxscan2351_scan
  rxscan2351_loop:
    (rx2350_pos) = rx2350_cur."from"()
    inc rx2350_pos
    rx2350_cur."!cursor_from"(rx2350_pos)
    ge rx2350_pos, rx2350_eos, rxscan2351_done
  rxscan2351_scan:
    set_addr $I10, rxscan2351_loop
    rx2350_cur."!mark_push"(0, rx2350_pos, $I10)
  rxscan2351_done:
.annotate 'line', 1184
  # rx subcapture "zw"
    set_addr $I10, rxcap_2356_fail
    rx2350_cur."!mark_push"(0, rx2350_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx2350_pos, rx2350_eos, rx2350_fail
    sub $I10, rx2350_pos, rx2350_off
    substr $S10, rx2350_tgt, $I10, 1
    index $I11, "?!", $S10
    lt $I11, 0, rx2350_fail
    inc rx2350_pos
  # rx subrule "before" subtype=zerowidth negate=
    rx2350_cur."!cursor_pos"(rx2350_pos)
    .const 'Sub' $P2353 = "431_1310110678.31883" 
    capture_lex $P2353
    $P10 = rx2350_cur."before"($P2353)
    unless $P10, rx2350_fail
    set_addr $I10, rxcap_2356_fail
    ($I12, $I11) = rx2350_cur."!mark_peek"($I10)
    rx2350_cur."!cursor_pos"($I11)
    ($P10) = rx2350_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2350_pos, "")
    rx2350_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("zw")
    goto rxcap_2356_done
  rxcap_2356_fail:
    goto rx2350_fail
  rxcap_2356_done:
  # rx subrule "codeblock" subtype=capture negate=
    rx2350_cur."!cursor_pos"(rx2350_pos)
    $P10 = rx2350_cur."codeblock"()
    unless $P10, rx2350_fail
    rx2350_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2350_pos = $P10."pos"()
.annotate 'line', 1183
  # rx pass
    rx2350_cur."!cursor_pass"(rx2350_pos, "assertion:sym<?{ }>")
    if_null rx2350_debug, debug_1710
    rx2350_cur."!cursor_debug"("PASS", "assertion:sym<?{ }>", " at pos=", rx2350_pos)
  debug_1710:
    .return (rx2350_cur)
  rx2350_restart:
.annotate 'line', 1166
    if_null rx2350_debug, debug_1711
    rx2350_cur."!cursor_debug"("NEXT", "assertion:sym<?{ }>")
  debug_1711:
  rx2350_fail:
    (rx2350_rep, rx2350_pos, $I10, $P10) = rx2350_cur."!mark_fail"(0)
    lt rx2350_pos, -1, rx2350_done
    eq rx2350_pos, -1, rx2350_fail
    jump $I10
  rx2350_done:
    rx2350_cur."!cursor_fail"()
    if_null rx2350_debug, debug_1712
    rx2350_cur."!cursor_debug"("FAIL", "assertion:sym<?{ }>")
  debug_1712:
    .return (rx2350_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2352"  :anon :subid("431_1310110678.31883") :method :outer("430_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1184
    .local string rx2354_tgt
    .local int rx2354_pos
    .local int rx2354_off
    .local int rx2354_eos
    .local int rx2354_rep
    .local pmc rx2354_cur
    .local pmc rx2354_debug
    (rx2354_cur, rx2354_pos, rx2354_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2354_cur
    .local pmc match
    .lex "$/", match
    length rx2354_eos, rx2354_tgt
    gt rx2354_pos, rx2354_eos, rx2354_done
    set rx2354_off, 0
    lt rx2354_pos, 2, rx2354_start
    sub rx2354_off, rx2354_pos, 1
    substr rx2354_tgt, rx2354_tgt, rx2354_off
  rx2354_start:
    eq $I10, 1, rx2354_restart
    if_null rx2354_debug, debug_1706
    rx2354_cur."!cursor_debug"("START", "")
  debug_1706:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2355_done
    goto rxscan2355_scan
  rxscan2355_loop:
    (rx2354_pos) = rx2354_cur."from"()
    inc rx2354_pos
    rx2354_cur."!cursor_from"(rx2354_pos)
    ge rx2354_pos, rx2354_eos, rxscan2355_done
  rxscan2355_scan:
    set_addr $I10, rxscan2355_loop
    rx2354_cur."!mark_push"(0, rx2354_pos, $I10)
  rxscan2355_done:
  # rx literal  "{"
    add $I11, rx2354_pos, 1
    gt $I11, rx2354_eos, rx2354_fail
    sub $I11, rx2354_pos, rx2354_off
    ord $I11, rx2354_tgt, $I11
    ne $I11, 123, rx2354_fail
    add rx2354_pos, 1
  # rx pass
    rx2354_cur."!cursor_pass"(rx2354_pos, "")
    if_null rx2354_debug, debug_1707
    rx2354_cur."!cursor_debug"("PASS", "", " at pos=", rx2354_pos)
  debug_1707:
    .return (rx2354_cur)
  rx2354_restart:
    if_null rx2354_debug, debug_1708
    rx2354_cur."!cursor_debug"("NEXT", "")
  debug_1708:
  rx2354_fail:
    (rx2354_rep, rx2354_pos, $I10, $P10) = rx2354_cur."!mark_fail"(0)
    lt rx2354_pos, -1, rx2354_done
    eq rx2354_pos, -1, rx2354_fail
    jump $I10
  rx2354_done:
    rx2354_cur."!cursor_fail"()
    if_null rx2354_debug, debug_1709
    rx2354_cur."!cursor_debug"("FAIL", "")
  debug_1709:
    .return (rx2354_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<?{ }>"  :subid("432_1310110678.31883") :method :outer("419_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1166
    new $P103, "ResizablePMCArray"
    push $P103, "!"
    push $P103, "?"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<name>"  :subid("433_1310110678.31883") :method :outer("419_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1166
    .const 'Sub' $P2364 = "434_1310110678.31883" 
    capture_lex $P2364
    .local string rx2359_tgt
    .local int rx2359_pos
    .local int rx2359_off
    .local int rx2359_eos
    .local int rx2359_rep
    .local pmc rx2359_cur
    .local pmc rx2359_debug
    (rx2359_cur, rx2359_pos, rx2359_tgt, $I10) = self."!cursor_start"()
    rx2359_cur."!cursor_caparray"("assertion", "arglist", "nibbler")
    .lex unicode:"$\x{a2}", rx2359_cur
    .local pmc match
    .lex "$/", match
    length rx2359_eos, rx2359_tgt
    gt rx2359_pos, rx2359_eos, rx2359_done
    set rx2359_off, 0
    lt rx2359_pos, 2, rx2359_start
    sub rx2359_off, rx2359_pos, 1
    substr rx2359_tgt, rx2359_tgt, rx2359_off
  rx2359_start:
    eq $I10, 1, rx2359_restart
    if_null rx2359_debug, debug_1713
    rx2359_cur."!cursor_debug"("START", "assertion:sym<name>")
  debug_1713:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2360_done
    goto rxscan2360_scan
  rxscan2360_loop:
    (rx2359_pos) = rx2359_cur."from"()
    inc rx2359_pos
    rx2359_cur."!cursor_from"(rx2359_pos)
    ge rx2359_pos, rx2359_eos, rxscan2360_done
  rxscan2360_scan:
    set_addr $I10, rxscan2360_loop
    rx2359_cur."!mark_push"(0, rx2359_pos, $I10)
  rxscan2360_done:
.annotate 'line', 1188
  # rx subrule "identifier" subtype=capture negate=
    rx2359_cur."!cursor_pos"(rx2359_pos)
    $P10 = rx2359_cur."identifier"()
    unless $P10, rx2359_fail
    rx2359_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx2359_pos = $P10."pos"()
.annotate 'line', 1195
  # rx rxquantr2361 ** 0..1
    set_addr $I10, rxquantr2361_done
    rx2359_cur."!mark_push"(0, rx2359_pos, $I10)
  rxquantr2361_loop:
  alt2362_0:
.annotate 'line', 1189
    set_addr $I10, alt2362_1
    rx2359_cur."!mark_push"(0, rx2359_pos, $I10)
.annotate 'line', 1190
  # rx subrule "before" subtype=zerowidth negate=
    rx2359_cur."!cursor_pos"(rx2359_pos)
    .const 'Sub' $P2364 = "434_1310110678.31883" 
    capture_lex $P2364
    $P10 = rx2359_cur."before"($P2364)
    unless $P10, rx2359_fail
    goto alt2362_end
  alt2362_1:
    set_addr $I10, alt2362_2
    rx2359_cur."!mark_push"(0, rx2359_pos, $I10)
.annotate 'line', 1191
  # rx literal  "="
    add $I11, rx2359_pos, 1
    gt $I11, rx2359_eos, rx2359_fail
    sub $I11, rx2359_pos, rx2359_off
    ord $I11, rx2359_tgt, $I11
    ne $I11, 61, rx2359_fail
    add rx2359_pos, 1
  # rx subrule "assertion" subtype=capture negate=
    rx2359_cur."!cursor_pos"(rx2359_pos)
    $P10 = rx2359_cur."assertion"()
    unless $P10, rx2359_fail
    rx2359_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("assertion")
    rx2359_pos = $P10."pos"()
    goto alt2362_end
  alt2362_2:
    set_addr $I10, alt2362_3
    rx2359_cur."!mark_push"(0, rx2359_pos, $I10)
.annotate 'line', 1192
  # rx literal  ":"
    add $I11, rx2359_pos, 1
    gt $I11, rx2359_eos, rx2359_fail
    sub $I11, rx2359_pos, rx2359_off
    ord $I11, rx2359_tgt, $I11
    ne $I11, 58, rx2359_fail
    add rx2359_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx2359_cur."!cursor_pos"(rx2359_pos)
    $P10 = rx2359_cur."arglist"()
    unless $P10, rx2359_fail
    rx2359_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2359_pos = $P10."pos"()
    goto alt2362_end
  alt2362_3:
    set_addr $I10, alt2362_4
    rx2359_cur."!mark_push"(0, rx2359_pos, $I10)
.annotate 'line', 1193
  # rx literal  "("
    add $I11, rx2359_pos, 1
    gt $I11, rx2359_eos, rx2359_fail
    sub $I11, rx2359_pos, rx2359_off
    ord $I11, rx2359_tgt, $I11
    ne $I11, 40, rx2359_fail
    add rx2359_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx2359_cur."!cursor_pos"(rx2359_pos)
    $P10 = rx2359_cur."LANG"("MAIN", "arglist")
    unless $P10, rx2359_fail
    rx2359_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2359_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx2359_pos, 1
    gt $I11, rx2359_eos, rx2359_fail
    sub $I11, rx2359_pos, rx2359_off
    ord $I11, rx2359_tgt, $I11
    ne $I11, 41, rx2359_fail
    add rx2359_pos, 1
    goto alt2362_end
  alt2362_4:
.annotate 'line', 1194
  # rx subrule "normspace" subtype=method negate=
    rx2359_cur."!cursor_pos"(rx2359_pos)
    $P10 = rx2359_cur."normspace"()
    unless $P10, rx2359_fail
    rx2359_pos = $P10."pos"()
  # rx subrule "nibbler" subtype=capture negate=
    rx2359_cur."!cursor_pos"(rx2359_pos)
    $P10 = rx2359_cur."nibbler"()
    unless $P10, rx2359_fail
    rx2359_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("nibbler")
    rx2359_pos = $P10."pos"()
  alt2362_end:
.annotate 'line', 1195
    set_addr $I10, rxquantr2361_done
    (rx2359_rep) = rx2359_cur."!mark_commit"($I10)
  rxquantr2361_done:
.annotate 'line', 1187
  # rx pass
    rx2359_cur."!cursor_pass"(rx2359_pos, "assertion:sym<name>")
    if_null rx2359_debug, debug_1718
    rx2359_cur."!cursor_debug"("PASS", "assertion:sym<name>", " at pos=", rx2359_pos)
  debug_1718:
    .return (rx2359_cur)
  rx2359_restart:
.annotate 'line', 1166
    if_null rx2359_debug, debug_1719
    rx2359_cur."!cursor_debug"("NEXT", "assertion:sym<name>")
  debug_1719:
  rx2359_fail:
    (rx2359_rep, rx2359_pos, $I10, $P10) = rx2359_cur."!mark_fail"(0)
    lt rx2359_pos, -1, rx2359_done
    eq rx2359_pos, -1, rx2359_fail
    jump $I10
  rx2359_done:
    rx2359_cur."!cursor_fail"()
    if_null rx2359_debug, debug_1720
    rx2359_cur."!cursor_debug"("FAIL", "assertion:sym<name>")
  debug_1720:
    .return (rx2359_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2363"  :anon :subid("434_1310110678.31883") :method :outer("433_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1190
    .local string rx2365_tgt
    .local int rx2365_pos
    .local int rx2365_off
    .local int rx2365_eos
    .local int rx2365_rep
    .local pmc rx2365_cur
    .local pmc rx2365_debug
    (rx2365_cur, rx2365_pos, rx2365_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2365_cur
    .local pmc match
    .lex "$/", match
    length rx2365_eos, rx2365_tgt
    gt rx2365_pos, rx2365_eos, rx2365_done
    set rx2365_off, 0
    lt rx2365_pos, 2, rx2365_start
    sub rx2365_off, rx2365_pos, 1
    substr rx2365_tgt, rx2365_tgt, rx2365_off
  rx2365_start:
    eq $I10, 1, rx2365_restart
    if_null rx2365_debug, debug_1714
    rx2365_cur."!cursor_debug"("START", "")
  debug_1714:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2366_done
    goto rxscan2366_scan
  rxscan2366_loop:
    (rx2365_pos) = rx2365_cur."from"()
    inc rx2365_pos
    rx2365_cur."!cursor_from"(rx2365_pos)
    ge rx2365_pos, rx2365_eos, rxscan2366_done
  rxscan2366_scan:
    set_addr $I10, rxscan2366_loop
    rx2365_cur."!mark_push"(0, rx2365_pos, $I10)
  rxscan2366_done:
  # rx literal  ">"
    add $I11, rx2365_pos, 1
    gt $I11, rx2365_eos, rx2365_fail
    sub $I11, rx2365_pos, rx2365_off
    ord $I11, rx2365_tgt, $I11
    ne $I11, 62, rx2365_fail
    add rx2365_pos, 1
  # rx pass
    rx2365_cur."!cursor_pass"(rx2365_pos, "")
    if_null rx2365_debug, debug_1715
    rx2365_cur."!cursor_debug"("PASS", "", " at pos=", rx2365_pos)
  debug_1715:
    .return (rx2365_cur)
  rx2365_restart:
    if_null rx2365_debug, debug_1716
    rx2365_cur."!cursor_debug"("NEXT", "")
  debug_1716:
  rx2365_fail:
    (rx2365_rep, rx2365_pos, $I10, $P10) = rx2365_cur."!mark_fail"(0)
    lt rx2365_pos, -1, rx2365_done
    eq rx2365_pos, -1, rx2365_fail
    jump $I10
  rx2365_done:
    rx2365_cur."!cursor_fail"()
    if_null rx2365_debug, debug_1717
    rx2365_cur."!cursor_debug"("FAIL", "")
  debug_1717:
    .return (rx2365_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<name>"  :subid("435_1310110678.31883") :method :outer("419_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1166
    $P103 = self."!PREFIX__!subrule"("identifier", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<var>"  :subid("436_1310110678.31883") :method :outer("419_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1166
    .local string rx2369_tgt
    .local int rx2369_pos
    .local int rx2369_off
    .local int rx2369_eos
    .local int rx2369_rep
    .local pmc rx2369_cur
    .local pmc rx2369_debug
    (rx2369_cur, rx2369_pos, rx2369_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2369_cur
    .local pmc match
    .lex "$/", match
    length rx2369_eos, rx2369_tgt
    gt rx2369_pos, rx2369_eos, rx2369_done
    set rx2369_off, 0
    lt rx2369_pos, 2, rx2369_start
    sub rx2369_off, rx2369_pos, 1
    substr rx2369_tgt, rx2369_tgt, rx2369_off
  rx2369_start:
    eq $I10, 1, rx2369_restart
    if_null rx2369_debug, debug_1721
    rx2369_cur."!cursor_debug"("START", "assertion:sym<var>")
  debug_1721:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2370_done
    goto rxscan2370_scan
  rxscan2370_loop:
    (rx2369_pos) = rx2369_cur."from"()
    inc rx2369_pos
    rx2369_cur."!cursor_from"(rx2369_pos)
    ge rx2369_pos, rx2369_eos, rxscan2370_done
  rxscan2370_scan:
    set_addr $I10, rxscan2370_loop
    rx2369_cur."!mark_push"(0, rx2369_pos, $I10)
  rxscan2370_done:
.annotate 'line', 1199
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2369_pos, rx2369_off
    substr $S10, rx2369_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx2369_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2369_cur."!cursor_pos"(rx2369_pos)
    $P10 = rx2369_cur."LANG"("MAIN", "variable")
    unless $P10, rx2369_fail
    rx2369_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx2369_pos = $P10."pos"()
.annotate 'line', 1198
  # rx pass
    rx2369_cur."!cursor_pass"(rx2369_pos, "assertion:sym<var>")
    if_null rx2369_debug, debug_1722
    rx2369_cur."!cursor_debug"("PASS", "assertion:sym<var>", " at pos=", rx2369_pos)
  debug_1722:
    .return (rx2369_cur)
  rx2369_restart:
.annotate 'line', 1166
    if_null rx2369_debug, debug_1723
    rx2369_cur."!cursor_debug"("NEXT", "assertion:sym<var>")
  debug_1723:
  rx2369_fail:
    (rx2369_rep, rx2369_pos, $I10, $P10) = rx2369_cur."!mark_fail"(0)
    lt rx2369_pos, -1, rx2369_done
    eq rx2369_pos, -1, rx2369_fail
    jump $I10
  rx2369_done:
    rx2369_cur."!cursor_fail"()
    if_null rx2369_debug, debug_1724
    rx2369_cur."!cursor_debug"("FAIL", "assertion:sym<var>")
  debug_1724:
    .return (rx2369_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<var>"  :subid("437_1310110678.31883") :method :outer("419_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1166
    new $P103, "ResizablePMCArray"
    push $P103, "$"
    push $P103, "@"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "codeblock"  :subid("438_1310110678.31883") :method :outer("419_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1166
    .local string rx2373_tgt
    .local int rx2373_pos
    .local int rx2373_off
    .local int rx2373_eos
    .local int rx2373_rep
    .local pmc rx2373_cur
    .local pmc rx2373_debug
    (rx2373_cur, rx2373_pos, rx2373_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2373_cur
    .local pmc match
    .lex "$/", match
    length rx2373_eos, rx2373_tgt
    gt rx2373_pos, rx2373_eos, rx2373_done
    set rx2373_off, 0
    lt rx2373_pos, 2, rx2373_start
    sub rx2373_off, rx2373_pos, 1
    substr rx2373_tgt, rx2373_tgt, rx2373_off
  rx2373_start:
    eq $I10, 1, rx2373_restart
    if_null rx2373_debug, debug_1725
    rx2373_cur."!cursor_debug"("START", "codeblock")
  debug_1725:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2374_done
    goto rxscan2374_scan
  rxscan2374_loop:
    (rx2373_pos) = rx2373_cur."from"()
    inc rx2373_pos
    rx2373_cur."!cursor_from"(rx2373_pos)
    ge rx2373_pos, rx2373_eos, rxscan2374_done
  rxscan2374_scan:
    set_addr $I10, rxscan2374_loop
    rx2373_cur."!mark_push"(0, rx2373_pos, $I10)
  rxscan2374_done:
.annotate 'line', 1203
  # rx subrule "LANG" subtype=capture negate=
    rx2373_cur."!cursor_pos"(rx2373_pos)
    $P10 = rx2373_cur."LANG"("MAIN", "pblock")
    unless $P10, rx2373_fail
    rx2373_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx2373_pos = $P10."pos"()
.annotate 'line', 1202
  # rx pass
    rx2373_cur."!cursor_pass"(rx2373_pos, "codeblock")
    if_null rx2373_debug, debug_1726
    rx2373_cur."!cursor_debug"("PASS", "codeblock", " at pos=", rx2373_pos)
  debug_1726:
    .return (rx2373_cur)
  rx2373_restart:
.annotate 'line', 1166
    if_null rx2373_debug, debug_1727
    rx2373_cur."!cursor_debug"("NEXT", "codeblock")
  debug_1727:
  rx2373_fail:
    (rx2373_rep, rx2373_pos, $I10, $P10) = rx2373_cur."!mark_fail"(0)
    lt rx2373_pos, -1, rx2373_done
    eq rx2373_pos, -1, rx2373_fail
    jump $I10
  rx2373_done:
    rx2373_cur."!cursor_fail"()
    if_null rx2373_debug, debug_1728
    rx2373_cur."!cursor_debug"("FAIL", "codeblock")
  debug_1728:
    .return (rx2373_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__codeblock"  :subid("439_1310110678.31883") :method :outer("419_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1166
    $P103 = self."!PREFIX__!subrule"("LANG", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2376"  :subid("440_1310110678.31883") :outer("10_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1209
    .const 'Sub' $P3699 = "620_1310110678.31883" 
    capture_lex $P3699
    .const 'Sub' $P3696 = "619_1310110678.31883" 
    capture_lex $P3696
    .const 'Sub' $P3693 = "618_1310110678.31883" 
    capture_lex $P3693
    .const 'Sub' $P3690 = "617_1310110678.31883" 
    capture_lex $P3690
    .const 'Sub' $P3687 = "616_1310110678.31883" 
    capture_lex $P3687
    .const 'Sub' $P3684 = "615_1310110678.31883" 
    capture_lex $P3684
    .const 'Sub' $P3681 = "614_1310110678.31883" 
    capture_lex $P3681
    .const 'Sub' $P3678 = "613_1310110678.31883" 
    capture_lex $P3678
    .const 'Sub' $P3674 = "612_1310110678.31883" 
    capture_lex $P3674
    .const 'Sub' $P3671 = "611_1310110678.31883" 
    capture_lex $P3671
    .const 'Sub' $P3667 = "610_1310110678.31883" 
    capture_lex $P3667
    .const 'Sub' $P3663 = "609_1310110678.31883" 
    capture_lex $P3663
    .const 'Sub' $P3649 = "608_1310110678.31883" 
    capture_lex $P3649
    .const 'Sub' $P3645 = "607_1310110678.31883" 
    capture_lex $P3645
    .const 'Sub' $P3641 = "606_1310110678.31883" 
    capture_lex $P3641
    .const 'Sub' $P3637 = "605_1310110678.31883" 
    capture_lex $P3637
    .const 'Sub' $P3633 = "604_1310110678.31883" 
    capture_lex $P3633
    .const 'Sub' $P3629 = "603_1310110678.31883" 
    capture_lex $P3629
    .const 'Sub' $P3625 = "602_1310110678.31883" 
    capture_lex $P3625
    .const 'Sub' $P3615 = "601_1310110678.31883" 
    capture_lex $P3615
    .const 'Sub' $P3608 = "600_1310110678.31883" 
    capture_lex $P3608
    .const 'Sub' $P3604 = "599_1310110678.31883" 
    capture_lex $P3604
    .const 'Sub' $P3600 = "598_1310110678.31883" 
    capture_lex $P3600
    .const 'Sub' $P3596 = "597_1310110678.31883" 
    capture_lex $P3596
    .const 'Sub' $P3592 = "596_1310110678.31883" 
    capture_lex $P3592
    .const 'Sub' $P3588 = "595_1310110678.31883" 
    capture_lex $P3588
    .const 'Sub' $P3579 = "594_1310110678.31883" 
    capture_lex $P3579
    .const 'Sub' $P3561 = "592_1310110678.31883" 
    capture_lex $P3561
    .const 'Sub' $P3557 = "591_1310110678.31883" 
    capture_lex $P3557
    .const 'Sub' $P3553 = "590_1310110678.31883" 
    capture_lex $P3553
    .const 'Sub' $P3544 = "589_1310110678.31883" 
    capture_lex $P3544
    .const 'Sub' $P3537 = "588_1310110678.31883" 
    capture_lex $P3537
    .const 'Sub' $P3533 = "587_1310110678.31883" 
    capture_lex $P3533
    .const 'Sub' $P3529 = "586_1310110678.31883" 
    capture_lex $P3529
    .const 'Sub' $P3498 = "583_1310110678.31883" 
    capture_lex $P3498
    .const 'Sub' $P3494 = "582_1310110678.31883" 
    capture_lex $P3494
    .const 'Sub' $P3491 = "581_1310110678.31883" 
    capture_lex $P3491
    .const 'Sub' $P3479 = "580_1310110678.31883" 
    capture_lex $P3479
    .const 'Sub' $P3475 = "579_1310110678.31883" 
    capture_lex $P3475
    .const 'Sub' $P3465 = "578_1310110678.31883" 
    capture_lex $P3465
    .const 'Sub' $P3446 = "576_1310110678.31883" 
    capture_lex $P3446
    .const 'Sub' $P3440 = "575_1310110678.31883" 
    capture_lex $P3440
    .const 'Sub' $P3437 = "574_1310110678.31883" 
    capture_lex $P3437
    .const 'Sub' $P3419 = "573_1310110678.31883" 
    capture_lex $P3419
    .const 'Sub' $P3367 = "568_1310110678.31883" 
    capture_lex $P3367
    .const 'Sub' $P3331 = "563_1310110678.31883" 
    capture_lex $P3331
    .const 'Sub' $P3327 = "562_1310110678.31883" 
    capture_lex $P3327
    .const 'Sub' $P3309 = "560_1310110678.31883" 
    capture_lex $P3309
    .const 'Sub' $P3302 = "559_1310110678.31883" 
    capture_lex $P3302
    .const 'Sub' $P3296 = "558_1310110678.31883" 
    capture_lex $P3296
    .const 'Sub' $P3257 = "557_1310110678.31883" 
    capture_lex $P3257
    .const 'Sub' $P3237 = "554_1310110678.31883" 
    capture_lex $P3237
    .const 'Sub' $P3204 = "551_1310110678.31883" 
    capture_lex $P3204
    .const 'Sub' $P3123 = "544_1310110678.31883" 
    capture_lex $P3123
    .const 'Sub' $P3119 = "543_1310110678.31883" 
    capture_lex $P3119
    .const 'Sub' $P3115 = "542_1310110678.31883" 
    capture_lex $P3115
    .const 'Sub' $P3074 = "539_1310110678.31883" 
    capture_lex $P3074
    .const 'Sub' $P3070 = "538_1310110678.31883" 
    capture_lex $P3070
    .const 'Sub' $P3063 = "537_1310110678.31883" 
    capture_lex $P3063
    .const 'Sub' $P3056 = "536_1310110678.31883" 
    capture_lex $P3056
    .const 'Sub' $P3049 = "535_1310110678.31883" 
    capture_lex $P3049
    .const 'Sub' $P3039 = "534_1310110678.31883" 
    capture_lex $P3039
    .const 'Sub' $P3035 = "533_1310110678.31883" 
    capture_lex $P3035
    .const 'Sub' $P3031 = "532_1310110678.31883" 
    capture_lex $P3031
    .const 'Sub' $P3027 = "531_1310110678.31883" 
    capture_lex $P3027
    .const 'Sub' $P2960 = "525_1310110678.31883" 
    capture_lex $P2960
    .const 'Sub' $P2932 = "524_1310110678.31883" 
    capture_lex $P2932
    .const 'Sub' $P2928 = "523_1310110678.31883" 
    capture_lex $P2928
    .const 'Sub' $P2924 = "522_1310110678.31883" 
    capture_lex $P2924
    .const 'Sub' $P2920 = "521_1310110678.31883" 
    capture_lex $P2920
    .const 'Sub' $P2916 = "520_1310110678.31883" 
    capture_lex $P2916
    .const 'Sub' $P2912 = "519_1310110678.31883" 
    capture_lex $P2912
    .const 'Sub' $P2908 = "518_1310110678.31883" 
    capture_lex $P2908
    .const 'Sub' $P2857 = "512_1310110678.31883" 
    capture_lex $P2857
    .const 'Sub' $P2847 = "511_1310110678.31883" 
    capture_lex $P2847
    .const 'Sub' $P2841 = "510_1310110678.31883" 
    capture_lex $P2841
    .const 'Sub' $P2837 = "509_1310110678.31883" 
    capture_lex $P2837
    .const 'Sub' $P2833 = "508_1310110678.31883" 
    capture_lex $P2833
    .const 'Sub' $P2829 = "507_1310110678.31883" 
    capture_lex $P2829
    .const 'Sub' $P2825 = "506_1310110678.31883" 
    capture_lex $P2825
    .const 'Sub' $P2821 = "505_1310110678.31883" 
    capture_lex $P2821
    .const 'Sub' $P2817 = "504_1310110678.31883" 
    capture_lex $P2817
    .const 'Sub' $P2813 = "503_1310110678.31883" 
    capture_lex $P2813
    .const 'Sub' $P2809 = "502_1310110678.31883" 
    capture_lex $P2809
    .const 'Sub' $P2805 = "501_1310110678.31883" 
    capture_lex $P2805
    .const 'Sub' $P2801 = "500_1310110678.31883" 
    capture_lex $P2801
    .const 'Sub' $P2797 = "499_1310110678.31883" 
    capture_lex $P2797
    .const 'Sub' $P2793 = "498_1310110678.31883" 
    capture_lex $P2793
    .const 'Sub' $P2789 = "497_1310110678.31883" 
    capture_lex $P2789
    .const 'Sub' $P2782 = "496_1310110678.31883" 
    capture_lex $P2782
    .const 'Sub' $P2775 = "495_1310110678.31883" 
    capture_lex $P2775
    .const 'Sub' $P2770 = "494_1310110678.31883" 
    capture_lex $P2770
    .const 'Sub' $P2764 = "493_1310110678.31883" 
    capture_lex $P2764
    .const 'Sub' $P2758 = "492_1310110678.31883" 
    capture_lex $P2758
    .const 'Sub' $P2749 = "491_1310110678.31883" 
    capture_lex $P2749
    .const 'Sub' $P2738 = "490_1310110678.31883" 
    capture_lex $P2738
    .const 'Sub' $P2732 = "489_1310110678.31883" 
    capture_lex $P2732
    .const 'Sub' $P2727 = "488_1310110678.31883" 
    capture_lex $P2727
    .const 'Sub' $P2708 = "486_1310110678.31883" 
    capture_lex $P2708
    .const 'Sub' $P2702 = "485_1310110678.31883" 
    capture_lex $P2702
    .const 'Sub' $P2699 = "484_1310110678.31883" 
    capture_lex $P2699
    .const 'Sub' $P2694 = "483_1310110678.31883" 
    capture_lex $P2694
    .const 'Sub' $P2679 = "481_1310110678.31883" 
    capture_lex $P2679
    .const 'Sub' $P2675 = "480_1310110678.31883" 
    capture_lex $P2675
    .const 'Sub' $P2662 = "478_1310110678.31883" 
    capture_lex $P2662
    .const 'Sub' $P2658 = "477_1310110678.31883" 
    capture_lex $P2658
    .const 'Sub' $P2654 = "476_1310110678.31883" 
    capture_lex $P2654
    .const 'Sub' $P2649 = "475_1310110678.31883" 
    capture_lex $P2649
    .const 'Sub' $P2620 = "473_1310110678.31883" 
    capture_lex $P2620
    .const 'Sub' $P2602 = "471_1310110678.31883" 
    capture_lex $P2602
    .const 'Sub' $P2581 = "469_1310110678.31883" 
    capture_lex $P2581
    .const 'Sub' $P2571 = "468_1310110678.31883" 
    capture_lex $P2571
    .const 'Sub' $P2567 = "467_1310110678.31883" 
    capture_lex $P2567
    .const 'Sub' $P2512 = "461_1310110678.31883" 
    capture_lex $P2512
    .const 'Sub' $P2495 = "459_1310110678.31883" 
    capture_lex $P2495
    .const 'Sub' $P2491 = "458_1310110678.31883" 
    capture_lex $P2491
    .const 'Sub' $P2487 = "457_1310110678.31883" 
    capture_lex $P2487
    .const 'Sub' $P2459 = "454_1310110678.31883" 
    capture_lex $P2459
    .const 'Sub' $P2454 = "453_1310110678.31883" 
    capture_lex $P2454
    .const 'Sub' $P2434 = "451_1310110678.31883" 
    capture_lex $P2434
    .const 'Sub' $P2429 = "450_1310110678.31883" 
    capture_lex $P2429
    .const 'Sub' $P2419 = "449_1310110678.31883" 
    capture_lex $P2419
    .const 'Sub' $P2409 = "447_1310110678.31883" 
    capture_lex $P2409
    .const 'Sub' $P2404 = "446_1310110678.31883" 
    capture_lex $P2404
    .const 'Sub' $P2398 = "445_1310110678.31883" 
    capture_lex $P2398
    .const 'Sub' $P2385 = "442_1310110678.31883" 
    capture_lex $P2385
    .const 'Sub' $P2379 = "441_1310110678.31883" 
    capture_lex $P2379
.annotate 'line', 1213
    .const 'Sub' $P2379 = "441_1310110678.31883" 
    newclosure $P2383, $P2379
    set $P2378, $P2383
    .lex "xblock_immediate", $P2378
.annotate 'line', 1218
    .const 'Sub' $P2385 = "442_1310110678.31883" 
    newclosure $P2396, $P2385
    set $P2384, $P2396
    .lex "block_immediate", $P2384
.annotate 'line', 1228
    .const 'Sub' $P2398 = "445_1310110678.31883" 
    newclosure $P2402, $P2398
    set $P2397, $P2402
    .lex "vivitype", $P2397
.annotate 'line', 1247
    .const 'Sub' $P2404 = "446_1310110678.31883" 
    newclosure $P2407, $P2404
    set $P2403, $P2407
    .lex "colonpair_str", $P2403
.annotate 'line', 1427
    .const 'Sub' $P2409 = "447_1310110678.31883" 
    newclosure $P2417, $P2409
    set $P2408, $P2417
    .lex "import_HOW_exports", $P2408
.annotate 'line', 1532
    .const 'Sub' $P2419 = "449_1310110678.31883" 
    newclosure $P2427, $P2419
    set $P2418, $P2427
    .lex "push_block_handler", $P2418
.annotate 'line', 2077
    .const 'Sub' $P2429 = "450_1310110678.31883" 
    newclosure $P2432, $P2429
    set $P2428, $P2432
    .lex "only_star_block", $P2428
.annotate 'line', 2086
    .const 'Sub' $P2434 = "451_1310110678.31883" 
    newclosure $P2452, $P2434
    set $P2433, $P2452
    .lex "attach_multi_signature", $P2433
.annotate 'line', 2564
    .const 'Sub' $P2454 = "453_1310110678.31883" 
    newclosure $P2457, $P2454
    set $P2453, $P2457
    .lex "control", $P2453
.annotate 'line', 2583
    .const 'Sub' $P2459 = "454_1310110678.31883" 
    newclosure $P2485, $P2459
    set $P2458, $P2485
    .lex "lexical_package_lookup", $P2458
.annotate 'line', 2632
    .const 'Sub' $P2487 = "457_1310110678.31883" 
    newclosure $P2489, $P2487
    set $P2486, $P2489
    .lex "is_lexical", $P2486
.annotate 'line', 2638
    .const 'Sub' $P2491 = "458_1310110678.31883" 
    newclosure $P2493, $P2491
    set $P2490, $P2493
    .lex "is_package", $P2490
.annotate 'line', 2644
    .const 'Sub' $P2495 = "459_1310110678.31883" 
    newclosure $P2510, $P2495
    set $P2494, $P2510
    .lex "is_scope", $P2494
.annotate 'line', 2667
    .const 'Sub' $P2512 = "461_1310110678.31883" 
    newclosure $P2564, $P2512
    set $P2511, $P2564
    .lex "find_sym", $P2511
.annotate 'line', 1209
    .lex "$?PACKAGE", $P2565
    .lex "$?CLASS", $P2566
.annotate 'line', 1211
    new $P122, "ResizablePMCArray"
    find_lex $P123, "$?PACKAGE"
    get_who $P124, $P123
    set $P124["@BLOCK"], $P122
.annotate 'line', 1209
    find_lex $P122, "xblock_immediate"
    find_lex $P122, "block_immediate"
    find_lex $P122, "vivitype"
    find_lex $P122, "colonpair_str"
    find_lex $P122, "import_HOW_exports"
    find_lex $P122, "push_block_handler"
    find_lex $P122, "only_star_block"
    find_lex $P122, "attach_multi_signature"
    find_lex $P122, "control"
    find_lex $P122, "lexical_package_lookup"
    find_lex $P122, "is_lexical"
    find_lex $P122, "is_package"
    find_lex $P122, "is_scope"
    find_lex $P122, "find_sym"
    .return ($P122)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock_immediate"  :subid("441_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2380
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1213
    .lex "$xblock", param_2380
.annotate 'line', 1214
    find_lex $P2381, "$xblock"
    unless_null $P2381, vivify_1729
    $P2381 = root_new ['parrot';'ResizablePMCArray']
  vivify_1729:
    set $P103, $P2381[1]
    unless_null $P103, vivify_1730
    new $P103, "Undef"
  vivify_1730:
    $P104 = "block_immediate"($P103)
    find_lex $P2382, "$xblock"
    unless_null $P2382, vivify_1731
    $P2382 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$xblock", $P2382
  vivify_1731:
    set $P2382[1], $P104
.annotate 'line', 1213
    find_lex $P103, "$xblock"
    unless_null $P103, vivify_1732
    new $P103, "Undef"
  vivify_1732:
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block_immediate"  :subid("442_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2386
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1218
    .const 'Sub' $P2390 = "443_1310110678.31883" 
    capture_lex $P2390
    .lex "$block", param_2386
.annotate 'line', 1219
    find_lex $P104, "$block"
    unless_null $P104, vivify_1733
    new $P104, "Undef"
  vivify_1733:
    $P104."blocktype"("immediate")
.annotate 'line', 1220
    find_lex $P105, "$block"
    unless_null $P105, vivify_1734
    new $P105, "Undef"
  vivify_1734:
    $P106 = $P105."symtable"()
    unless $P106, unless_2388
    set $P104, $P106
    goto unless_2388_end
  unless_2388:
    find_lex $P107, "$block"
    unless_null $P107, vivify_1735
    new $P107, "Undef"
  vivify_1735:
    $P108 = $P107."handlers"()
    set $P104, $P108
  unless_2388_end:
    if $P104, unless_2387_end
    .const 'Sub' $P2390 = "443_1310110678.31883" 
    capture_lex $P2390
    $P2390()
  unless_2387_end:
.annotate 'line', 1218
    find_lex $P104, "$block"
    unless_null $P104, vivify_1742
    new $P104, "Undef"
  vivify_1742:
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2389"  :anon :subid("443_1310110678.31883") :outer("442_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1220
    .const 'Sub' $P2393 = "444_1310110678.31883" 
    capture_lex $P2393
.annotate 'line', 1221
    new $P109, "Undef"
    set $P2391, $P109
    .lex "$stmts", $P2391
    get_hll_global $P110, "GLOBAL"
    nqp_get_package_through_who $P111, $P110, "PAST"
    get_who $P112, $P111
    set $P113, $P112["Stmts"]
    find_lex $P114, "$block"
    unless_null $P114, vivify_1736
    new $P114, "Undef"
  vivify_1736:
    $P115 = $P113."new"($P114 :named("node"))
    store_lex "$stmts", $P115
.annotate 'line', 1222
    find_lex $P111, "$block"
    unless_null $P111, vivify_1737
    new $P111, "Undef"
  vivify_1737:
    $P112 = $P111."list"()
    defined $I100, $P112
    unless $I100, for_undef_1738
    iter $P110, $P112
    new $P114, 'ExceptionHandler'
    set_label $P114, loop2395_handler
    $P114."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P114
  loop2395_test:
    unless $P110, loop2395_done
    shift $P113, $P110
  loop2395_redo:
    .const 'Sub' $P2393 = "444_1310110678.31883" 
    capture_lex $P2393
    $P2393($P113)
  loop2395_next:
    goto loop2395_test
  loop2395_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P115, exception, 'type'
    eq $P115, .CONTROL_LOOP_NEXT, loop2395_next
    eq $P115, .CONTROL_LOOP_REDO, loop2395_redo
  loop2395_done:
    pop_eh 
  for_undef_1738:
.annotate 'line', 1223
    find_lex $P110, "$stmts"
    unless_null $P110, vivify_1741
    new $P110, "Undef"
  vivify_1741:
    store_lex "$block", $P110
.annotate 'line', 1220
    .return ($P110)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2392"  :anon :subid("444_1310110678.31883") :outer("443_1310110678.31883")
    .param pmc param_2394
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1222
    .lex "$_", param_2394
    find_lex $P114, "$stmts"
    unless_null $P114, vivify_1739
    new $P114, "Undef"
  vivify_1739:
    find_lex $P115, "$_"
    unless_null $P115, vivify_1740
    new $P115, "Undef"
  vivify_1740:
    $P116 = $P114."push"($P115)
    .return ($P116)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "vivitype"  :subid("445_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2399
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1228
    .lex "$sigil", param_2399
.annotate 'line', 1229
    find_lex $P106, "$sigil"
    unless_null $P106, vivify_1743
    new $P106, "Undef"
  vivify_1743:
    set $S100, $P106
    iseq $I100, $S100, "%"
    if $I100, if_2400
.annotate 'line', 1231
    find_lex $P113, "$sigil"
    unless_null $P113, vivify_1744
    new $P113, "Undef"
  vivify_1744:
    set $S101, $P113
    iseq $I101, $S101, "@"
    if $I101, if_2401
    new $P119, "String"
    assign $P119, "Undef"
    set $P112, $P119
    goto if_2401_end
  if_2401:
.annotate 'line', 1232
    get_hll_global $P114, "GLOBAL"
    nqp_get_package_through_who $P115, $P114, "PAST"
    get_who $P116, $P115
    set $P117, $P116["Op"]
    $P118 = $P117."new"("    %r = root_new ['parrot';'ResizablePMCArray']" :named("inline"))
    set $P112, $P118
  if_2401_end:
    set $P105, $P112
.annotate 'line', 1229
    goto if_2400_end
  if_2400:
.annotate 'line', 1230
    get_hll_global $P107, "GLOBAL"
    nqp_get_package_through_who $P108, $P107, "PAST"
    get_who $P109, $P108
    set $P110, $P109["Op"]
    $P111 = $P110."new"("    %r = root_new ['parrot';'Hash']" :named("inline"))
    set $P105, $P111
  if_2400_end:
.annotate 'line', 1228
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair_str"  :subid("446_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2405
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1247
    .lex "$ast", param_2405
.annotate 'line', 1248
    get_hll_global $P107, "GLOBAL"
    nqp_get_package_through_who $P108, $P107, "PAST"
    get_who $P109, $P108
    set $P110, $P109["Op"]
    find_lex $P111, "$ast"
    unless_null $P111, vivify_1745
    new $P111, "Undef"
  vivify_1745:
    $P112 = $P110."ACCEPTS"($P111)
    if $P112, if_2406
.annotate 'line', 1250
    find_lex $P115, "$ast"
    unless_null $P115, vivify_1746
    new $P115, "Undef"
  vivify_1746:
    $P116 = $P115."value"()
    set $P106, $P116
.annotate 'line', 1248
    goto if_2406_end
  if_2406:
.annotate 'line', 1249
    find_lex $P113, "$ast"
    unless_null $P113, vivify_1747
    new $P113, "Undef"
  vivify_1747:
    $P114 = $P113."list"()
    join $S100, " ", $P114
    new $P106, 'String'
    set $P106, $S100
  if_2406_end:
.annotate 'line', 1247
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "import_HOW_exports"  :subid("447_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2410
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1427
    .const 'Sub' $P2414 = "448_1310110678.31883" 
    capture_lex $P2414
    .lex "$UNIT", param_2410
.annotate 'line', 1429
    find_lex $P108, "$UNIT"
    unless_null $P108, vivify_1748
    new $P108, "Undef"
  vivify_1748:
    exists $I100, $P108["EXPORTHOW"]
    if $I100, if_2411
    new $P107, 'Integer'
    set $P107, $I100
    goto if_2411_end
  if_2411:
.annotate 'line', 1430
    find_lex $P2412, "$UNIT"
    unless_null $P2412, vivify_1749
    $P2412 = root_new ['parrot';'Hash']
  vivify_1749:
    set $P110, $P2412["EXPORTHOW"]
    unless_null $P110, vivify_1750
    new $P110, "Undef"
  vivify_1750:
    get_who $P111, $P110
    defined $I101, $P111
    unless $I101, for_undef_1751
    iter $P109, $P111
    new $P113, 'ExceptionHandler'
    set_label $P113, loop2416_handler
    $P113."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P113
  loop2416_test:
    unless $P109, loop2416_done
    shift $P112, $P109
  loop2416_redo:
    .const 'Sub' $P2414 = "448_1310110678.31883" 
    capture_lex $P2414
    $P2414($P112)
  loop2416_next:
    goto loop2416_test
  loop2416_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P115, exception, 'type'
    eq $P115, .CONTROL_LOOP_NEXT, loop2416_next
    eq $P115, .CONTROL_LOOP_REDO, loop2416_redo
  loop2416_done:
    pop_eh 
  for_undef_1751:
.annotate 'line', 1429
    set $P107, $P109
  if_2411_end:
.annotate 'line', 1427
    .return ($P107)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2413"  :anon :subid("448_1310110678.31883") :outer("447_1310110678.31883")
    .param pmc param_2415
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1430
    .lex "$_", param_2415
.annotate 'line', 1431
    find_lex $P113, "$_"
    unless_null $P113, vivify_1752
    new $P113, "Undef"
  vivify_1752:
    $P114 = $P113."value"()
    find_lex $P115, "$_"
    unless_null $P115, vivify_1753
    new $P115, "Undef"
  vivify_1753:
    $P116 = $P115."key"()
    find_dynamic_lex $P119, "%*HOW"
    unless_null $P119, vivify_1754
    get_hll_global $P117, "GLOBAL"
    get_who $P118, $P117
    set $P119, $P118["%HOW"]
    unless_null $P119, vivify_1755
    die "Contextual %*HOW not found"
  vivify_1755:
    store_dynamic_lex "%*HOW", $P119
  vivify_1754:
    set $P119[$P116], $P114
.annotate 'line', 1430
    .return ($P114)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "push_block_handler"  :subid("449_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2420
    .param pmc param_2421
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1532
    .lex "$/", param_2420
    .lex "$block", param_2421
.annotate 'line', 1533
    find_lex $P108, "$?PACKAGE"
    get_who $P109, $P108
    set $P2423, $P109["@BLOCK"]
    unless_null $P2423, vivify_1756
    $P2423 = root_new ['parrot';'ResizablePMCArray']
  vivify_1756:
    set $P110, $P2423[0]
    unless_null $P110, vivify_1757
    new $P110, "Undef"
  vivify_1757:
    $P111 = $P110."handlers"()
    if $P111, unless_2422_end
.annotate 'line', 1534
    find_lex $P112, "$?PACKAGE"
    get_who $P113, $P112
    set $P2424, $P113["@BLOCK"]
    unless_null $P2424, vivify_1758
    $P2424 = root_new ['parrot';'ResizablePMCArray']
  vivify_1758:
    set $P114, $P2424[0]
    unless_null $P114, vivify_1759
    new $P114, "Undef"
  vivify_1759:
    new $P115, "ResizablePMCArray"
    $P114."handlers"($P115)
  unless_2422_end:
.annotate 'line', 1536
    find_lex $P108, "$block"
    unless_null $P108, vivify_1760
    new $P108, "Undef"
  vivify_1760:
    $P109 = $P108."arity"()
    if $P109, unless_2425_end
.annotate 'line', 1537
    find_lex $P110, "$block"
    unless_null $P110, vivify_1761
    new $P110, "Undef"
  vivify_1761:
.annotate 'line', 1538
    get_hll_global $P111, "GLOBAL"
    nqp_get_package_through_who $P112, $P111, "PAST"
    get_who $P113, $P112
    set $P114, $P113["Op"]
.annotate 'line', 1539
    get_hll_global $P115, "GLOBAL"
    nqp_get_package_through_who $P116, $P115, "PAST"
    get_who $P117, $P116
    set $P118, $P117["Var"]
    $P119 = $P118."new"("lexical" :named("scope"), "$!" :named("name"), 1 :named("isdecl"))
.annotate 'line', 1540
    get_hll_global $P120, "GLOBAL"
    nqp_get_package_through_who $P121, $P120, "PAST"
    get_who $P122, $P121
    set $P123, $P122["Var"]
    $P124 = $P123."new"("lexical" :named("scope"), "$_" :named("name"))
    $P125 = $P114."new"($P119, $P124, "bind_6model" :named("pasttype"))
.annotate 'line', 1538
    $P110."unshift"($P125)
.annotate 'line', 1543
    find_lex $P110, "$block"
    unless_null $P110, vivify_1762
    new $P110, "Undef"
  vivify_1762:
    get_hll_global $P111, "GLOBAL"
    nqp_get_package_through_who $P112, $P111, "PAST"
    get_who $P113, $P112
    set $P114, $P113["Var"]
    $P115 = $P114."new"("$_" :named("name"), "parameter" :named("scope"))
    $P110."unshift"($P115)
.annotate 'line', 1544
    find_lex $P110, "$block"
    unless_null $P110, vivify_1763
    new $P110, "Undef"
  vivify_1763:
    $P110."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 1545
    find_lex $P110, "$block"
    unless_null $P110, vivify_1764
    new $P110, "Undef"
  vivify_1764:
    $P110."symbol"("$!", "lexical" :named("scope"))
.annotate 'line', 1546
    find_lex $P110, "$block"
    unless_null $P110, vivify_1765
    new $P110, "Undef"
  vivify_1765:
    $P110."arity"(1)
  unless_2425_end:
.annotate 'line', 1548
    find_lex $P108, "$block"
    unless_null $P108, vivify_1766
    new $P108, "Undef"
  vivify_1766:
    $P108."blocktype"("declaration")
.annotate 'line', 1549
    find_lex $P108, "$?PACKAGE"
    get_who $P109, $P108
    set $P2426, $P109["@BLOCK"]
    unless_null $P2426, vivify_1767
    $P2426 = root_new ['parrot';'ResizablePMCArray']
  vivify_1767:
    set $P110, $P2426[0]
    unless_null $P110, vivify_1768
    new $P110, "Undef"
  vivify_1768:
    $P111 = $P110."handlers"()
.annotate 'line', 1550
    get_hll_global $P112, "GLOBAL"
    nqp_get_package_through_who $P113, $P112, "PAST"
    get_who $P114, $P113
    set $P115, $P114["Control"]
    find_lex $P116, "$/"
    unless_null $P116, vivify_1769
    new $P116, "Undef"
  vivify_1769:
.annotate 'line', 1552
    get_hll_global $P117, "GLOBAL"
    nqp_get_package_through_who $P118, $P117, "PAST"
    get_who $P119, $P118
    set $P120, $P119["Stmts"]
.annotate 'line', 1553
    get_hll_global $P121, "GLOBAL"
    nqp_get_package_through_who $P122, $P121, "PAST"
    get_who $P123, $P122
    set $P124, $P123["Op"]
    find_lex $P125, "$block"
    unless_null $P125, vivify_1770
    new $P125, "Undef"
  vivify_1770:
.annotate 'line', 1555
    get_hll_global $P126, "GLOBAL"
    nqp_get_package_through_who $P127, $P126, "PAST"
    get_who $P128, $P127
    set $P129, $P128["Var"]
    $P130 = $P129."new"("register" :named("scope"), "exception" :named("name"))
    $P131 = $P124."new"($P125, $P130, "call" :named("pasttype"))
.annotate 'line', 1557
    get_hll_global $P132, "GLOBAL"
    nqp_get_package_through_who $P133, $P132, "PAST"
    get_who $P134, $P133
    set $P135, $P134["Op"]
.annotate 'line', 1558
    get_hll_global $P136, "GLOBAL"
    nqp_get_package_through_who $P137, $P136, "PAST"
    get_who $P138, $P137
    set $P139, $P138["Var"]
.annotate 'line', 1559
    get_hll_global $P140, "GLOBAL"
    nqp_get_package_through_who $P141, $P140, "PAST"
    get_who $P142, $P141
    set $P143, $P142["Var"]
    $P144 = $P143."new"("register" :named("scope"), "exception" :named("name"))
    $P145 = $P139."new"($P144, "handled", "keyed" :named("scope"))
.annotate 'line', 1558
    $P146 = $P135."new"($P145, 1, "bind_6model" :named("pasttype"))
.annotate 'line', 1557
    $P147 = $P120."new"($P131, $P146)
.annotate 'line', 1552
    $P148 = $P115."new"($P147, $P116 :named("node"))
.annotate 'line', 1550
    $P149 = $P111."unshift"($P148)
.annotate 'line', 1532
    .return ($P149)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "only_star_block"  :subid("450_1310110678.31883") :outer("440_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2078
    new $P108, "Undef"
    set $P2430, $P108
    .lex "$past", $P2430
    find_lex $P109, "$?PACKAGE"
    get_who $P110, $P109
    set $P2431, $P110["@BLOCK"]
    unless_null $P2431, vivify_1771
    $P2431 = root_new ['parrot';'ResizablePMCArray']
  vivify_1771:
    $P111 = $P2431."shift"()
    store_lex "$past", $P111
.annotate 'line', 2079
    find_lex $P109, "$past"
    unless_null $P109, vivify_1772
    new $P109, "Undef"
  vivify_1772:
    $P109."closure"(1)
.annotate 'line', 2080
    find_lex $P109, "$past"
    unless_null $P109, vivify_1773
    new $P109, "Undef"
  vivify_1773:
    get_hll_global $P110, "GLOBAL"
    nqp_get_package_through_who $P111, $P110, "PAST"
    get_who $P112, $P111
    set $P113, $P112["Op"]
    $P114 = $P113."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P109."push"($P114)
.annotate 'line', 2077
    find_lex $P109, "$past"
    unless_null $P109, vivify_1774
    new $P109, "Undef"
  vivify_1774:
    .return ($P109)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "attach_multi_signature"  :subid("451_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2435
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2086
    .const 'Sub' $P2440 = "452_1310110678.31883" 
    capture_lex $P2440
    .lex "$routine", param_2435
.annotate 'line', 2090
    new $P110, "Undef"
    set $P2436, $P110
    .lex "$types", $P2436
.annotate 'line', 2091
    new $P111, "Undef"
    set $P2437, $P111
    .lex "$definednesses", $P2437
.annotate 'line', 2090
    get_hll_global $P112, "GLOBAL"
    nqp_get_package_through_who $P113, $P112, "PAST"
    get_who $P114, $P113
    set $P115, $P114["Op"]
    $P116 = $P115."new"("list" :named("pasttype"))
    store_lex "$types", $P116
.annotate 'line', 2091
    get_hll_global $P112, "GLOBAL"
    nqp_get_package_through_who $P113, $P112, "PAST"
    get_who $P114, $P113
    set $P115, $P114["Op"]
    $P116 = $P115."new"("list" :named("pasttype"))
    store_lex "$definednesses", $P116
.annotate 'line', 2092
    find_lex $P2438, "$routine"
    unless_null $P2438, vivify_1775
    $P2438 = root_new ['parrot';'ResizablePMCArray']
  vivify_1775:
    set $P113, $P2438[0]
    unless_null $P113, vivify_1776
    new $P113, "Undef"
  vivify_1776:
    $P114 = $P113."list"()
    defined $I100, $P114
    unless $I100, for_undef_1777
    iter $P112, $P114
    new $P117, 'ExceptionHandler'
    set_label $P117, loop2451_handler
    $P117."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P117
  loop2451_test:
    unless $P112, loop2451_done
    shift $P115, $P112
  loop2451_redo:
    .const 'Sub' $P2440 = "452_1310110678.31883" 
    capture_lex $P2440
    $P2440($P115)
  loop2451_next:
    goto loop2451_test
  loop2451_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P118, exception, 'type'
    eq $P118, .CONTROL_LOOP_NEXT, loop2451_next
    eq $P118, .CONTROL_LOOP_REDO, loop2451_redo
  loop2451_done:
    pop_eh 
  for_undef_1777:
.annotate 'line', 2099
    find_dynamic_lex $P114, "$*SC"
    unless_null $P114, vivify_1787
    get_hll_global $P112, "GLOBAL"
    get_who $P113, $P112
    set $P114, $P113["$SC"]
    unless_null $P114, vivify_1788
    die "Contextual $*SC not found"
  vivify_1788:
  vivify_1787:
    find_lex $P115, "$routine"
    unless_null $P115, vivify_1789
    new $P115, "Undef"
  vivify_1789:
    find_lex $P116, "$types"
    unless_null $P116, vivify_1790
    new $P116, "Undef"
  vivify_1790:
    find_lex $P117, "$definednesses"
    unless_null $P117, vivify_1791
    new $P117, "Undef"
  vivify_1791:
    $P118 = $P114."set_routine_signature"($P115, $P116, $P117)
.annotate 'line', 2086
    .return ($P118)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2439"  :anon :subid("452_1310110678.31883") :outer("451_1310110678.31883")
    .param pmc param_2441
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2092
    .lex "$_", param_2441
.annotate 'line', 2093
    get_hll_global $P118, "GLOBAL"
    nqp_get_package_through_who $P119, $P118, "PAST"
    get_who $P120, $P119
    set $P121, $P120["Var"]
    find_lex $P122, "$_"
    unless_null $P122, vivify_1778
    new $P122, "Undef"
  vivify_1778:
    $P123 = $P121."ACCEPTS"($P122)
    if $P123, if_2443
    set $P117, $P123
    goto if_2443_end
  if_2443:
    find_lex $P124, "$_"
    unless_null $P124, vivify_1779
    new $P124, "Undef"
  vivify_1779:
    $S100 = $P124."scope"()
    iseq $I101, $S100, "parameter"
    new $P117, 'Integer'
    set $P117, $I101
  if_2443_end:
    if $P117, if_2442
    set $P116, $P117
    goto if_2442_end
  if_2442:
.annotate 'line', 2094
    find_lex $P125, "$types"
    unless_null $P125, vivify_1780
    new $P125, "Undef"
  vivify_1780:
    find_lex $P126, "$_"
    unless_null $P126, vivify_1781
    new $P126, "Undef"
  vivify_1781:
    $P127 = $P126."multitype"()
    set $P2444, $P127
    defined $I2446, $P2444
    if $I2446, default_2445
    get_hll_global $P128, "GLOBAL"
    nqp_get_package_through_who $P129, $P128, "PAST"
    get_who $P130, $P129
    set $P131, $P130["Op"]
    $P132 = $P131."new"("null P" :named("pirop"))
    set $P2444, $P132
  default_2445:
    $P125."push"($P2444)
.annotate 'line', 2095
    find_lex $P125, "$definednesses"
    unless_null $P125, vivify_1782
    new $P125, "Undef"
  vivify_1782:
    find_lex $P2448, "$_"
    unless_null $P2448, vivify_1783
    $P2448 = root_new ['parrot';'Hash']
  vivify_1783:
    set $P127, $P2448["definedness"]
    unless_null $P127, vivify_1784
    new $P127, "Undef"
  vivify_1784:
    set $S101, $P127
    iseq $I102, $S101, "D"
    if $I102, if_2447
.annotate 'line', 2096
    find_lex $P2450, "$_"
    unless_null $P2450, vivify_1785
    $P2450 = root_new ['parrot';'Hash']
  vivify_1785:
    set $P130, $P2450["definedness"]
    unless_null $P130, vivify_1786
    new $P130, "Undef"
  vivify_1786:
    set $S102, $P130
    iseq $I103, $S102, "U"
    if $I103, if_2449
    new $P132, "Integer"
    assign $P132, 0
    set $P129, $P132
    goto if_2449_end
  if_2449:
    new $P131, "Integer"
    assign $P131, 2
    set $P129, $P131
  if_2449_end:
    set $P126, $P129
.annotate 'line', 2095
    goto if_2447_end
  if_2447:
    new $P128, "Integer"
    assign $P128, 1
    set $P126, $P128
  if_2447_end:
    $P133 = $P125."push"($P126)
.annotate 'line', 2093
    set $P116, $P133
  if_2442_end:
.annotate 'line', 2092
    .return ($P116)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "control"  :subid("453_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2455
    .param pmc param_2456
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2564
    .lex "$/", param_2455
    .lex "$type", param_2456
.annotate 'line', 2565
    find_lex $P112, "$/"
    get_hll_global $P113, "GLOBAL"
    nqp_get_package_through_who $P114, $P113, "PAST"
    get_who $P115, $P114
    set $P116, $P115["Op"]
    find_lex $P117, "$/"
    unless_null $P117, vivify_1792
    new $P117, "Undef"
  vivify_1792:
.annotate 'line', 2569
    get_hll_global $P119, "GLOBAL"
    nqp_get_package_through_who $P120, $P119, "PAST"
    get_who $P121, $P120
    set $P122, $P121["Val"]
    find_lex $P123, "$type"
    unless_null $P123, vivify_1793
    new $P123, "Undef"
  vivify_1793:
    $P124 = $P122."new"($P123 :named("value"), "!macro_const" :named("returns"))
    $P125 = $P116."new"(0, $P124, $P117 :named("node"), "die__vii" :named("pirop"))
.annotate 'line', 2565
    $P126 = $P112."!make"($P125)
.annotate 'line', 2564
    .return ($P126)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "lexical_package_lookup"  :subid("454_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2462
    .param pmc param_2463
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2583
    .const 'Sub' $P2472 = "455_1310110678.31883" 
    capture_lex $P2472
    new $P2461, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2461, control_2460
    push_eh $P2461
    .lex "@name", param_2462
    .lex "$/", param_2463
.annotate 'line', 2589
    new $P112, "Undef"
    set $P2464, $P112
    .lex "$final_name", $P2464
.annotate 'line', 2590
    new $P113, "Undef"
    set $P2465, $P113
    .lex "$lookup", $P2465
.annotate 'line', 2585
    find_lex $P2467, "@name"
    unless_null $P2467, vivify_1794
    $P2467 = root_new ['parrot';'ResizablePMCArray']
  vivify_1794:
    set $N100, $P2467
    iseq $I100, $N100, 0.0
    unless $I100, if_2466_end
    find_lex $P114, "$/"
    unless_null $P114, vivify_1795
    new $P114, "Undef"
  vivify_1795:
    $P115 = $P114."CURSOR"()
    $P115."panic"("Cannot compile empty name")
  if_2466_end:
.annotate 'line', 2589
    find_lex $P2468, "@name"
    unless_null $P2468, vivify_1796
    $P2468 = root_new ['parrot';'ResizablePMCArray']
  vivify_1796:
    $P114 = $P2468."pop"()
    store_lex "$final_name", $P114
.annotate 'line', 2590
    get_hll_global $P114, "GLOBAL"
    nqp_get_package_through_who $P115, $P114, "PAST"
    get_who $P116, $P115
    set $P117, $P116["Var"]
    find_lex $P119, "$final_name"
    unless_null $P119, vivify_1797
    new $P119, "Undef"
  vivify_1797:
    set $S100, $P119
    $P120 = $P117."new"($S100, "keyed" :named("scope"))
    store_lex "$lookup", $P120
.annotate 'line', 2594
    find_lex $P2470, "@name"
    unless_null $P2470, vivify_1798
    $P2470 = root_new ['parrot';'ResizablePMCArray']
  vivify_1798:
    set $N100, $P2470
    iseq $I100, $N100, 0.0
    if $I100, if_2469
.annotate 'line', 2612
    .const 'Sub' $P2472 = "455_1310110678.31883" 
    capture_lex $P2472
    $P2472()
    goto if_2469_end
  if_2469:
.annotate 'line', 2595
    find_lex $P114, "$lookup"
    unless_null $P114, vivify_1811
    new $P114, "Undef"
  vivify_1811:
    get_hll_global $P115, "GLOBAL"
    nqp_get_package_through_who $P116, $P115, "PAST"
    get_who $P117, $P116
    set $P119, $P117["Op"]
.annotate 'line', 2597
    get_hll_global $P120, "GLOBAL"
    nqp_get_package_through_who $P121, $P120, "PAST"
    get_who $P122, $P121
    set $P123, $P122["Var"]
    $P124 = $P123."new"("$?PACKAGE" :named("name"), "lexical" :named("scope"))
    $P125 = $P119."new"($P124, "get_who PP" :named("pirop"))
.annotate 'line', 2595
    $P114."unshift"($P125)
.annotate 'line', 2599
    find_lex $P114, "$lookup"
    unless_null $P114, vivify_1812
    new $P114, "Undef"
  vivify_1812:
    get_hll_global $P115, "GLOBAL"
    nqp_get_package_through_who $P116, $P115, "PAST"
    get_who $P117, $P116
    set $P119, $P117["Var"]
.annotate 'line', 2601
    get_hll_global $P120, "GLOBAL"
    nqp_get_package_through_who $P121, $P120, "PAST"
    get_who $P122, $P121
    set $P123, $P122["Op"]
.annotate 'line', 2603
    get_hll_global $P124, "GLOBAL"
    nqp_get_package_through_who $P125, $P124, "PAST"
    get_who $P127, $P125
    set $P128, $P127["Var"]
    new $P129, "ResizablePMCArray"
    $P130 = $P128."new"("GLOBAL" :named("name"), $P129 :named("namespace"), "package" :named("scope"))
    $P131 = $P123."new"($P130, "get_who PP" :named("pirop"))
.annotate 'line', 2605
    find_lex $P132, "$final_name"
    unless_null $P132, vivify_1813
    new $P132, "Undef"
  vivify_1813:
    set $S100, $P132
    $P133 = $P119."new"($P131, $S100, "keyed" :named("scope"))
.annotate 'line', 2599
    $P114."viviself"($P133)
  if_2469_end:
.annotate 'line', 2627
    new $P114, "Exception"
    set $P114['type'], .CONTROL_RETURN
    find_lex $P115, "$lookup"
    unless_null $P115, vivify_1814
    new $P115, "Undef"
  vivify_1814:
    setattribute $P114, 'payload', $P115
    throw $P114
.annotate 'line', 2583
    .return ()
  control_2460:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P114, exception, "payload"
    .return ($P114)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2471"  :anon :subid("455_1310110678.31883") :outer("454_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2612
    .const 'Sub' $P2482 = "456_1310110678.31883" 
    capture_lex $P2482
.annotate 'line', 2613
    new $P114, "Undef"
    set $P2473, $P114
    .lex "$path", $P2473
    find_lex $P2475, "@name"
    unless_null $P2475, vivify_1799
    $P2475 = root_new ['parrot';'ResizablePMCArray']
  vivify_1799:
    set $P116, $P2475[0]
    unless_null $P116, vivify_1800
    new $P116, "Undef"
  vivify_1800:
    $P117 = "is_lexical"($P116)
    if $P117, if_2474
.annotate 'line', 2615
    get_hll_global $P125, "GLOBAL"
    nqp_get_package_through_who $P127, $P125, "PAST"
    get_who $P128, $P127
    set $P129, $P128["Var"]
    new $P130, "ResizablePMCArray"
    $P131 = $P129."new"("GLOBAL" :named("name"), $P130 :named("namespace"), "package" :named("scope"))
    set $P115, $P131
.annotate 'line', 2613
    goto if_2474_end
  if_2474:
.annotate 'line', 2614
    get_hll_global $P119, "GLOBAL"
    nqp_get_package_through_who $P120, $P119, "PAST"
    get_who $P121, $P120
    set $P122, $P121["Var"]
    find_lex $P2476, "@name"
    unless_null $P2476, vivify_1801
    $P2476 = root_new ['parrot';'ResizablePMCArray']
  vivify_1801:
    $P123 = $P2476."shift"()
    $P124 = $P122."new"($P123 :named("name"), "lexical" :named("scope"))
    set $P115, $P124
  if_2474_end:
.annotate 'line', 2613
    store_lex "$path", $P115
.annotate 'line', 2616
    find_lex $P2478, "@name"
    unless_null $P2478, vivify_1802
    $P2478 = root_new ['parrot';'ResizablePMCArray']
  vivify_1802:
    set $P115, $P2478[0]
    unless_null $P115, vivify_1803
    new $P115, "Undef"
  vivify_1803:
    set $S100, $P115
    iseq $I101, $S100, "GLOBAL"
    unless $I101, if_2477_end
.annotate 'line', 2617
    find_lex $P2479, "@name"
    unless_null $P2479, vivify_1804
    $P2479 = root_new ['parrot';'ResizablePMCArray']
  vivify_1804:
    $P2479."shift"()
  if_2477_end:
.annotate 'line', 2619
    find_lex $P2480, "@name"
    unless_null $P2480, vivify_1805
    $P2480 = root_new ['parrot';'ResizablePMCArray']
  vivify_1805:
    defined $I101, $P2480
    unless $I101, for_undef_1806
    iter $P115, $P2480
    new $P117, 'ExceptionHandler'
    set_label $P117, loop2484_handler
    $P117."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P117
  loop2484_test:
    unless $P115, loop2484_done
    shift $P116, $P115
  loop2484_redo:
    .const 'Sub' $P2482 = "456_1310110678.31883" 
    capture_lex $P2482
    $P2482($P116)
  loop2484_next:
    goto loop2484_test
  loop2484_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P119, exception, 'type'
    eq $P119, .CONTROL_LOOP_NEXT, loop2484_next
    eq $P119, .CONTROL_LOOP_REDO, loop2484_redo
  loop2484_done:
    pop_eh 
  for_undef_1806:
.annotate 'line', 2624
    find_lex $P115, "$lookup"
    unless_null $P115, vivify_1809
    new $P115, "Undef"
  vivify_1809:
    get_hll_global $P116, "GLOBAL"
    nqp_get_package_through_who $P117, $P116, "PAST"
    get_who $P119, $P117
    set $P120, $P119["Op"]
    find_lex $P121, "$path"
    unless_null $P121, vivify_1810
    new $P121, "Undef"
  vivify_1810:
    $P122 = $P120."new"($P121, "get_who PP" :named("pirop"))
    $P123 = $P115."unshift"($P122)
.annotate 'line', 2612
    .return ($P123)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2481"  :anon :subid("456_1310110678.31883") :outer("455_1310110678.31883")
    .param pmc param_2483
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2619
    .lex "$_", param_2483
.annotate 'line', 2620
    get_hll_global $P117, "GLOBAL"
    nqp_get_package_through_who $P119, $P117, "PAST"
    get_who $P120, $P119
    set $P121, $P120["Op"]
    find_lex $P122, "$path"
    unless_null $P122, vivify_1807
    new $P122, "Undef"
  vivify_1807:
.annotate 'line', 2622
    find_lex $P123, "$_"
    unless_null $P123, vivify_1808
    new $P123, "Undef"
  vivify_1808:
    set $S100, $P123
    $P124 = $P121."new"($P122, $S100, "nqp_get_package_through_who PPs" :named("pirop"))
.annotate 'line', 2620
    store_lex "$path", $P124
.annotate 'line', 2619
    .return ($P124)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "is_lexical"  :subid("457_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2488
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2632
    .lex "$name", param_2488
.annotate 'line', 2633
    find_lex $P115, "$name"
    unless_null $P115, vivify_1815
    new $P115, "Undef"
  vivify_1815:
    $P116 = "is_scope"($P115, "lexical")
.annotate 'line', 2632
    .return ($P116)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "is_package"  :subid("458_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2492
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2638
    .lex "$name", param_2492
.annotate 'line', 2639
    find_lex $P115, "$name"
    unless_null $P115, vivify_1816
    new $P115, "Undef"
  vivify_1816:
    $P117 = "is_scope"($P115, "package")
.annotate 'line', 2638
    .return ($P117)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "is_scope"  :subid("459_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2498
    .param pmc param_2499
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2644
    .const 'Sub' $P2502 = "460_1310110678.31883" 
    capture_lex $P2502
    new $P2497, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2497, control_2496
    push_eh $P2497
    .lex "$name", param_2498
    .lex "$wanted_scope", param_2499
.annotate 'line', 2645
    find_lex $P119, "$?PACKAGE"
    get_who $P120, $P119
    set $P2500, $P120["@BLOCK"]
    unless_null $P2500, vivify_1817
    $P2500 = root_new ['parrot';'ResizablePMCArray']
  vivify_1817:
    defined $I100, $P2500
    unless $I100, for_undef_1818
    iter $P115, $P2500
    new $P123, 'ExceptionHandler'
    set_label $P123, loop2509_handler
    $P123."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P123
  loop2509_test:
    unless $P115, loop2509_done
    shift $P121, $P115
  loop2509_redo:
    .const 'Sub' $P2502 = "460_1310110678.31883" 
    capture_lex $P2502
    $P2502($P121)
  loop2509_next:
    goto loop2509_test
  loop2509_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P124, exception, 'type'
    eq $P124, .CONTROL_LOOP_NEXT, loop2509_next
    eq $P124, .CONTROL_LOOP_REDO, loop2509_redo
  loop2509_done:
    pop_eh 
  for_undef_1818:
.annotate 'line', 2644
    .return (0)
  control_2496:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P115, exception, "payload"
    .return ($P115)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2501"  :anon :subid("460_1310110678.31883") :outer("459_1310110678.31883")
    .param pmc param_2505
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2646
    $P2504 = root_new ['parrot';'Hash']
    set $P2503, $P2504
    .lex "%sym", $P2503
    .lex "$_", param_2505
    find_lex $P122, "$_"
    unless_null $P122, vivify_1819
    new $P122, "Undef"
  vivify_1819:
    find_lex $P123, "$name"
    unless_null $P123, vivify_1820
    new $P123, "Undef"
  vivify_1820:
    $P124 = $P122."symbol"($P123)
    store_lex "%sym", $P124
.annotate 'line', 2647
    find_lex $P2507, "%sym"
    unless_null $P2507, vivify_1821
    $P2507 = root_new ['parrot';'Hash']
  vivify_1821:
    set $N100, $P2507
    if $N100, if_2506
    new $P122, 'Float'
    set $P122, $N100
    goto if_2506_end
  if_2506:
.annotate 'line', 2648
    new $P123, "Exception"
    set $P123['type'], .CONTROL_RETURN
    find_lex $P2508, "%sym"
    unless_null $P2508, vivify_1822
    $P2508 = root_new ['parrot';'Hash']
  vivify_1822:
    set $P124, $P2508["scope"]
    unless_null $P124, vivify_1823
    new $P124, "Undef"
  vivify_1823:
    set $S100, $P124
    find_lex $P125, "$wanted_scope"
    unless_null $P125, vivify_1824
    new $P125, "Undef"
  vivify_1824:
    set $S101, $P125
    iseq $I101, $S100, $S101
    new $P127, 'Integer'
    set $P127, $I101
    setattribute $P123, 'payload', $P127
    throw $P123
  if_2506_end:
.annotate 'line', 2645
    .return ($P122)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "find_sym"  :subid("461_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2515
    .param pmc param_2516
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2667
    .const 'Sub' $P2559 = "466_1310110678.31883" 
    capture_lex $P2559
    .const 'Sub' $P2541 = "464_1310110678.31883" 
    capture_lex $P2541
    .const 'Sub' $P2523 = "462_1310110678.31883" 
    capture_lex $P2523
    new $P2514, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2514, control_2513
    push_eh $P2514
    .lex "@name", param_2515
    .lex "$/", param_2516
.annotate 'line', 2691
    new $P119, "Undef"
    set $P2517, $P119
    .lex "$result", $P2517
.annotate 'line', 2669
    find_lex $P2519, "@name"
    unless_null $P2519, vivify_1825
    $P2519 = root_new ['parrot';'ResizablePMCArray']
  vivify_1825:
    set $N100, $P2519
    if $N100, unless_2518_end
    find_lex $P120, "$/"
    unless_null $P120, vivify_1826
    new $P120, "Undef"
  vivify_1826:
    $P121 = $P120."CURSOR"()
    $P121."panic"("Cannot look up empty name")
  unless_2518_end:
.annotate 'line', 2673
    find_lex $P2521, "@name"
    unless_null $P2521, vivify_1827
    $P2521 = root_new ['parrot';'ResizablePMCArray']
  vivify_1827:
    set $N100, $P2521
    iseq $I100, $N100, 1.0
    unless $I100, if_2520_end
    .const 'Sub' $P2523 = "462_1310110678.31883" 
    capture_lex $P2523
    $P2523()
  if_2520_end:
.annotate 'line', 2691
    find_dynamic_lex $P122, "$*GLOBALish"
    unless_null $P122, vivify_1839
    get_hll_global $P120, "GLOBAL"
    get_who $P121, $P120
    set $P122, $P121["$GLOBALish"]
    unless_null $P122, vivify_1840
    die "Contextual $*GLOBALish not found"
  vivify_1840:
  vivify_1839:
    store_lex "$result", $P122
.annotate 'line', 2692
    find_lex $P2539, "@name"
    unless_null $P2539, vivify_1841
    $P2539 = root_new ['parrot';'ResizablePMCArray']
  vivify_1841:
    set $N100, $P2539
    isge $I100, $N100, 2.0
    unless $I100, if_2538_end
    .const 'Sub' $P2541 = "464_1310110678.31883" 
    capture_lex $P2541
    $P2541()
  if_2538_end:
.annotate 'line', 2710
    find_lex $P2557, "@name"
    unless_null $P2557, vivify_1854
    $P2557 = root_new ['parrot';'ResizablePMCArray']
  vivify_1854:
    defined $I100, $P2557
    unless $I100, for_undef_1855
    iter $P120, $P2557
    new $P123, 'ExceptionHandler'
    set_label $P123, loop2563_handler
    $P123."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P123
  loop2563_test:
    unless $P120, loop2563_done
    shift $P121, $P120
  loop2563_redo:
    .const 'Sub' $P2559 = "466_1310110678.31883" 
    capture_lex $P2559
    $P2559($P121)
  loop2563_next:
    goto loop2563_test
  loop2563_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P124, exception, 'type'
    eq $P124, .CONTROL_LOOP_NEXT, loop2563_next
    eq $P124, .CONTROL_LOOP_REDO, loop2563_redo
  loop2563_done:
    pop_eh 
  for_undef_1855:
.annotate 'line', 2667
    find_lex $P120, "$result"
    unless_null $P120, vivify_1862
    new $P120, "Undef"
  vivify_1862:
    .return ($P120)
  control_2513:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P121, exception, "payload"
    .return ($P121)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2522"  :anon :subid("462_1310110678.31883") :outer("461_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2673
    .const 'Sub' $P2528 = "463_1310110678.31883" 
    capture_lex $P2528
.annotate 'line', 2674
    new $P120, "Undef"
    set $P2524, $P120
    .lex "$final_name", $P2524
    find_lex $P2525, "@name"
    unless_null $P2525, vivify_1828
    $P2525 = root_new ['parrot';'ResizablePMCArray']
  vivify_1828:
    set $P121, $P2525[0]
    unless_null $P121, vivify_1829
    new $P121, "Undef"
  vivify_1829:
    store_lex "$final_name", $P121
.annotate 'line', 2675
    find_lex $P122, "$?PACKAGE"
    get_who $P123, $P122
    set $P2526, $P123["@BLOCK"]
    unless_null $P2526, vivify_1830
    $P2526 = root_new ['parrot';'ResizablePMCArray']
  vivify_1830:
    defined $I101, $P2526
    unless $I101, for_undef_1831
    iter $P121, $P2526
    new $P127, 'ExceptionHandler'
    set_label $P127, loop2537_handler
    $P127."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P127
  loop2537_test:
    unless $P121, loop2537_done
    shift $P124, $P121
  loop2537_redo:
    .const 'Sub' $P2528 = "463_1310110678.31883" 
    capture_lex $P2528
    $P2528($P124)
  loop2537_next:
    goto loop2537_test
  loop2537_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P128, exception, 'type'
    eq $P128, .CONTROL_LOOP_NEXT, loop2537_next
    eq $P128, .CONTROL_LOOP_REDO, loop2537_redo
  loop2537_done:
    pop_eh 
  for_undef_1831:
.annotate 'line', 2673
    .return ($P121)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2527"  :anon :subid("463_1310110678.31883") :outer("462_1310110678.31883")
    .param pmc param_2531
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2676
    $P2530 = root_new ['parrot';'Hash']
    set $P2529, $P2530
    .lex "%sym", $P2529
    .lex "$_", param_2531
    find_lex $P125, "$_"
    unless_null $P125, vivify_1832
    new $P125, "Undef"
  vivify_1832:
    find_lex $P127, "$final_name"
    unless_null $P127, vivify_1833
    new $P127, "Undef"
  vivify_1833:
    $P128 = $P125."symbol"($P127)
    store_lex "%sym", $P128
.annotate 'line', 2677
    find_lex $P2533, "%sym"
    unless_null $P2533, vivify_1834
    $P2533 = root_new ['parrot';'Hash']
  vivify_1834:
    set $N101, $P2533
    if $N101, if_2532
    new $P125, 'Float'
    set $P125, $N101
    goto if_2532_end
  if_2532:
.annotate 'line', 2678
    find_lex $P2535, "%sym"
    unless_null $P2535, vivify_1835
    $P2535 = root_new ['parrot';'Hash']
  vivify_1835:
    exists $I102, $P2535["value"]
    if $I102, if_2534
.annotate 'line', 2682
    new $P128, 'String'
    set $P128, "No compile-time value for "
    find_lex $P129, "$final_name"
    unless_null $P129, vivify_1836
    new $P129, "Undef"
  vivify_1836:
    concat $P130, $P128, $P129
    die $P130
.annotate 'line', 2681
    goto if_2534_end
  if_2534:
.annotate 'line', 2679
    new $P128, "Exception"
    set $P128['type'], .CONTROL_RETURN
    find_lex $P2536, "%sym"
    unless_null $P2536, vivify_1837
    $P2536 = root_new ['parrot';'Hash']
  vivify_1837:
    set $P129, $P2536["value"]
    unless_null $P129, vivify_1838
    new $P129, "Undef"
  vivify_1838:
    setattribute $P128, 'payload', $P129
    throw $P128
  if_2534_end:
.annotate 'line', 2677
    set $P125, $P127
  if_2532_end:
.annotate 'line', 2675
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2540"  :anon :subid("464_1310110678.31883") :outer("461_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2692
    .const 'Sub' $P2546 = "465_1310110678.31883" 
    capture_lex $P2546
.annotate 'line', 2693
    new $P120, "Undef"
    set $P2542, $P120
    .lex "$first", $P2542
    find_lex $P2543, "@name"
    unless_null $P2543, vivify_1842
    $P2543 = root_new ['parrot';'ResizablePMCArray']
  vivify_1842:
    set $P121, $P2543[0]
    unless_null $P121, vivify_1843
    new $P121, "Undef"
  vivify_1843:
    store_lex "$first", $P121
.annotate 'line', 2694
    find_lex $P122, "$?PACKAGE"
    get_who $P123, $P122
    set $P2544, $P123["@BLOCK"]
    unless_null $P2544, vivify_1844
    $P2544 = root_new ['parrot';'ResizablePMCArray']
  vivify_1844:
    defined $I101, $P2544
    unless $I101, for_undef_1845
    iter $P121, $P2544
    new $P127, 'ExceptionHandler'
    set_label $P127, loop2556_handler
    $P127."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P127
  loop2556_test:
    unless $P121, loop2556_done
    shift $P124, $P121
  loop2556_redo:
    .const 'Sub' $P2546 = "465_1310110678.31883" 
    capture_lex $P2546
    $P2546($P124)
  loop2556_next:
    goto loop2556_test
  loop2556_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P128, exception, 'type'
    eq $P128, .CONTROL_LOOP_NEXT, loop2556_next
    eq $P128, .CONTROL_LOOP_REDO, loop2556_redo
  loop2556_done:
    pop_eh 
  for_undef_1845:
.annotate 'line', 2692
    .return ($P121)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2545"  :anon :subid("465_1310110678.31883") :outer("464_1310110678.31883")
    .param pmc param_2549
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2695
    $P2548 = root_new ['parrot';'Hash']
    set $P2547, $P2548
    .lex "%sym", $P2547
    .lex "$_", param_2549
    find_lex $P125, "$_"
    unless_null $P125, vivify_1846
    new $P125, "Undef"
  vivify_1846:
    find_lex $P127, "$first"
    unless_null $P127, vivify_1847
    new $P127, "Undef"
  vivify_1847:
    $P128 = $P125."symbol"($P127)
    store_lex "%sym", $P128
.annotate 'line', 2696
    find_lex $P2551, "%sym"
    unless_null $P2551, vivify_1848
    $P2551 = root_new ['parrot';'Hash']
  vivify_1848:
    set $N101, $P2551
    if $N101, if_2550
    new $P125, 'Float'
    set $P125, $N101
    goto if_2550_end
  if_2550:
.annotate 'line', 2697
    find_lex $P2553, "%sym"
    unless_null $P2553, vivify_1849
    $P2553 = root_new ['parrot';'Hash']
  vivify_1849:
    exists $I102, $P2553["value"]
    if $I102, if_2552
.annotate 'line', 2703
    new $P128, 'String'
    set $P128, "No compile-time value for "
    find_lex $P129, "$first"
    unless_null $P129, vivify_1850
    new $P129, "Undef"
  vivify_1850:
    concat $P130, $P128, $P129
    die $P130
.annotate 'line', 2702
    goto if_2552_end
  if_2552:
.annotate 'line', 2698
    find_lex $P2554, "%sym"
    unless_null $P2554, vivify_1851
    $P2554 = root_new ['parrot';'Hash']
  vivify_1851:
    set $P128, $P2554["value"]
    unless_null $P128, vivify_1852
    new $P128, "Undef"
  vivify_1852:
    store_lex "$result", $P128
.annotate 'line', 2699
    find_lex $P2555, "@name"
    unless_null $P2555, vivify_1853
    $P2555 = root_new ['parrot';'ResizablePMCArray']
  vivify_1853:
    $P2555."shift"()
.annotate 'line', 2700
    die 0, .CONTROL_LOOP_LAST
  if_2552_end:
.annotate 'line', 2696
    set $P125, $P127
  if_2550_end:
.annotate 'line', 2694
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2558"  :anon :subid("466_1310110678.31883") :outer("461_1310110678.31883")
    .param pmc param_2560
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2710
    .lex "$_", param_2560
.annotate 'line', 2711
    find_lex $P125, "$_"
    unless_null $P125, vivify_1856
    new $P125, "Undef"
  vivify_1856:
    set $S100, $P125
    find_lex $P123, "$result"
    unless_null $P123, vivify_1857
    new $P123, "Undef"
  vivify_1857:
    get_who $P124, $P123
    exists $I101, $P124[$S100]
    if $I101, if_2561
.annotate 'line', 2715
    new $P127, "String"
    assign $P127, "Could not locate compile-time value for symbol "
.annotate 'line', 2716
    find_lex $P2562, "@name"
    unless_null $P2562, vivify_1858
    $P2562 = root_new ['parrot';'ResizablePMCArray']
  vivify_1858:
    join $S101, "::", $P2562
    concat $P128, $P127, $S101
.annotate 'line', 2715
    die $P128
.annotate 'line', 2714
    goto if_2561_end
  if_2561:
.annotate 'line', 2712
    find_lex $P127, "$_"
    unless_null $P127, vivify_1859
    new $P127, "Undef"
  vivify_1859:
    find_lex $P128, "$result"
    unless_null $P128, vivify_1860
    new $P128, "Undef"
  vivify_1860:
    get_who $P129, $P128
    set $P130, $P129[$P127]
    unless_null $P130, vivify_1861
    new $P130, "Undef"
  vivify_1861:
    store_lex "$result", $P130
.annotate 'line', 2711
    set $P122, $P130
  if_2561_end:
.annotate 'line', 2710
    .return ($P122)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "TOP" :anon :subid("467_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2568
    .param pmc param_2569
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1237
    .lex "self", param_2568
    .lex "$/", param_2569
    find_lex $P122, "$/"
    find_lex $P2570, "$/"
    unless_null $P2570, vivify_1863
    $P2570 = root_new ['parrot';'Hash']
  vivify_1863:
    set $P123, $P2570["comp_unit"]
    unless_null $P123, vivify_1864
    new $P123, "Undef"
  vivify_1864:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "deflongname" :anon :subid("468_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2572
    .param pmc param_2573
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1239
    .lex "self", param_2572
    .lex "$/", param_2573
.annotate 'line', 1240
    find_lex $P122, "$/"
.annotate 'line', 1241
    find_lex $P2575, "$/"
    unless_null $P2575, vivify_1865
    $P2575 = root_new ['parrot';'Hash']
  vivify_1865:
    set $P124, $P2575["colonpair"]
    unless_null $P124, vivify_1866
    new $P124, "Undef"
  vivify_1866:
    if $P124, if_2574
.annotate 'line', 1243
    find_lex $P137, "$/"
    unless_null $P137, vivify_1867
    new $P137, "Undef"
  vivify_1867:
    set $S103, $P137
    new $P123, 'String'
    set $P123, $S103
.annotate 'line', 1241
    goto if_2574_end
  if_2574:
    find_lex $P2576, "$/"
    unless_null $P2576, vivify_1868
    $P2576 = root_new ['parrot';'Hash']
  vivify_1868:
    set $P125, $P2576["identifier"]
    unless_null $P125, vivify_1869
    new $P125, "Undef"
  vivify_1869:
    set $S100, $P125
    new $P127, 'String'
    set $P127, $S100
    concat $P128, $P127, ":"
    find_lex $P2577, "$/"
    unless_null $P2577, vivify_1870
    $P2577 = root_new ['parrot';'Hash']
  vivify_1870:
    set $P2578, $P2577["colonpair"]
    unless_null $P2578, vivify_1871
    $P2578 = root_new ['parrot';'ResizablePMCArray']
  vivify_1871:
    set $P129, $P2578[0]
    unless_null $P129, vivify_1872
    new $P129, "Undef"
  vivify_1872:
    $P130 = $P129."ast"()
    $S101 = $P130."named"()
    concat $P131, $P128, $S101
    concat $P132, $P131, "<"
.annotate 'line', 1242
    find_lex $P2579, "$/"
    unless_null $P2579, vivify_1873
    $P2579 = root_new ['parrot';'Hash']
  vivify_1873:
    set $P2580, $P2579["colonpair"]
    unless_null $P2580, vivify_1874
    $P2580 = root_new ['parrot';'ResizablePMCArray']
  vivify_1874:
    set $P133, $P2580[0]
    unless_null $P133, vivify_1875
    new $P133, "Undef"
  vivify_1875:
    $P134 = $P133."ast"()
    $S102 = "colonpair_str"($P134)
    concat $P135, $P132, $S102
    concat $P136, $P135, ">"
    set $P123, $P136
  if_2574_end:
.annotate 'line', 1241
    $P138 = $P122."!make"($P123)
.annotate 'line', 1239
    .return ($P138)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "comp_unit" :anon :subid("469_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2582
    .param pmc param_2583
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1253
    .const 'Sub' $P2596 = "470_1310110678.31883" 
    capture_lex $P2596
    .lex "self", param_2582
    .lex "$/", param_2583
.annotate 'line', 1254
    new $P122, "Undef"
    set $P2584, $P122
    .lex "$mainline", $P2584
.annotate 'line', 1255
    new $P123, "Undef"
    set $P2585, $P123
    .lex "$unit", $P2585
.annotate 'line', 1278
    $P2587 = root_new ['parrot';'ResizablePMCArray']
    set $P2586, $P2587
    .lex "@loadlibs", $P2586
.annotate 'line', 1291
    new $P124, "Undef"
    set $P2588, $P124
    .lex "$main_tasks", $P2588
.annotate 'line', 1254
    find_lex $P2589, "$/"
    unless_null $P2589, vivify_1876
    $P2589 = root_new ['parrot';'Hash']
  vivify_1876:
    set $P125, $P2589["statementlist"]
    unless_null $P125, vivify_1877
    new $P125, "Undef"
  vivify_1877:
    $P127 = $P125."ast"()
    store_lex "$mainline", $P127
.annotate 'line', 1255
    find_lex $P125, "$?PACKAGE"
    get_who $P127, $P125
    set $P2590, $P127["@BLOCK"]
    unless_null $P2590, vivify_1878
    $P2590 = root_new ['parrot';'ResizablePMCArray']
  vivify_1878:
    $P128 = $P2590."shift"()
    store_lex "$unit", $P128
.annotate 'line', 1259
    find_lex $P125, "$unit"
    unless_null $P125, vivify_1879
    new $P125, "Undef"
  vivify_1879:
    $P127 = $P125."loadinit"()
    find_dynamic_lex $P130, "$*SC"
    unless_null $P130, vivify_1880
    get_hll_global $P128, "GLOBAL"
    get_who $P129, $P128
    set $P130, $P129["$SC"]
    unless_null $P130, vivify_1881
    die "Contextual $*SC not found"
  vivify_1881:
  vivify_1880:
    $P131 = $P130."to_past"()
    $P127."push"($P131)
.annotate 'line', 1264
    find_lex $P125, "$unit"
    unless_null $P125, vivify_1882
    new $P125, "Undef"
  vivify_1882:
    $P127 = $P125."loadinit"()
    get_hll_global $P128, "GLOBAL"
    nqp_get_package_through_who $P129, $P128, "PAST"
    get_who $P130, $P129
    set $P131, $P130["Op"]
.annotate 'line', 1266
    get_hll_global $P132, "GLOBAL"
    nqp_get_package_through_who $P133, $P132, "PAST"
    get_who $P134, $P133
    set $P135, $P134["Var"]
    new $P136, "ResizablePMCArray"
    $P137 = $P135."new"("GLOBAL" :named("name"), $P136 :named("namespace"), "package" :named("scope"))
.annotate 'line', 1267
    find_dynamic_lex $P140, "$*SC"
    unless_null $P140, vivify_1883
    get_hll_global $P138, "GLOBAL"
    get_who $P139, $P138
    set $P140, $P139["$SC"]
    unless_null $P140, vivify_1884
    die "Contextual $*SC not found"
  vivify_1884:
  vivify_1883:
    find_dynamic_lex $P143, "$*PACKAGE"
    unless_null $P143, vivify_1885
    get_hll_global $P141, "GLOBAL"
    get_who $P142, $P141
    set $P143, $P142["$PACKAGE"]
    unless_null $P143, vivify_1886
    die "Contextual $*PACKAGE not found"
  vivify_1886:
  vivify_1885:
    $P144 = $P140."get_slot_past_for_object"($P143)
    $P145 = $P131."new"($P137, $P144, "bind_6model" :named("pasttype"))
.annotate 'line', 1264
    $P127."push"($P145)
.annotate 'line', 1273
    find_dynamic_lex $P128, "$*HAS_YOU_ARE_HERE"
    unless_null $P128, vivify_1887
    get_hll_global $P125, "GLOBAL"
    get_who $P127, $P125
    set $P128, $P127["$HAS_YOU_ARE_HERE"]
    unless_null $P128, vivify_1888
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_1888:
  vivify_1887:
    if $P128, unless_2591_end
.annotate 'line', 1274
    find_lex $P129, "$unit"
    unless_null $P129, vivify_1889
    new $P129, "Undef"
  vivify_1889:
    find_lex $P130, "self"
    $P131 = $P130."CTXSAVE"()
    $P129."push"($P131)
  unless_2591_end:
.annotate 'line', 1278
    new $P125, "ResizablePMCArray"
    push $P125, "nqp_group"
    push $P125, "nqp_ops"
    push $P125, "trans_ops"
    push $P125, "io_ops"
    store_lex "@loadlibs", $P125
.annotate 'line', 1279
    find_dynamic_lex $P128, "%*COMPILING"
    unless_null $P128, vivify_1890
    get_hll_global $P125, "GLOBAL"
    get_who $P127, $P125
    set $P128, $P127["%COMPILING"]
    unless_null $P128, vivify_1891
    die "Contextual %*COMPILING not found"
  vivify_1891:
  vivify_1890:
    set $P2593, $P128["%?OPTIONS"]
    unless_null $P2593, vivify_1892
    $P2593 = root_new ['parrot';'Hash']
  vivify_1892:
    set $P129, $P2593["vmlibs"]
    unless_null $P129, vivify_1893
    new $P129, "Undef"
  vivify_1893:
    unless $P129, if_2592_end
.annotate 'line', 1280
    find_dynamic_lex $P133, "%*COMPILING"
    unless_null $P133, vivify_1894
    get_hll_global $P131, "GLOBAL"
    get_who $P132, $P131
    set $P133, $P132["%COMPILING"]
    unless_null $P133, vivify_1895
    die "Contextual %*COMPILING not found"
  vivify_1895:
  vivify_1894:
    set $P2594, $P133["%?OPTIONS"]
    unless_null $P2594, vivify_1896
    $P2594 = root_new ['parrot';'Hash']
  vivify_1896:
    set $P134, $P2594["vmlibs"]
    unless_null $P134, vivify_1897
    new $P134, "Undef"
  vivify_1897:
    set $S100, $P134
    split $P135, ",", $S100
    defined $I100, $P135
    unless $I100, for_undef_1898
    iter $P130, $P135
    new $P137, 'ExceptionHandler'
    set_label $P137, loop2599_handler
    $P137."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P137
  loop2599_test:
    unless $P130, loop2599_done
    shift $P136, $P130
  loop2599_redo:
    .const 'Sub' $P2596 = "470_1310110678.31883" 
    capture_lex $P2596
    $P2596($P136)
  loop2599_next:
    goto loop2599_test
  loop2599_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P139, exception, 'type'
    eq $P139, .CONTROL_LOOP_NEXT, loop2599_next
    eq $P139, .CONTROL_LOOP_REDO, loop2599_redo
  loop2599_done:
    pop_eh 
  for_undef_1898:
  if_2592_end:
.annotate 'line', 1284
    find_lex $P125, "$unit"
    unless_null $P125, vivify_1901
    new $P125, "Undef"
  vivify_1901:
    find_lex $P2600, "@loadlibs"
    unless_null $P2600, vivify_1902
    $P2600 = root_new ['parrot';'ResizablePMCArray']
  vivify_1902:
    $P125."loadlibs"($P2600 :flat)
.annotate 'line', 1290
    find_lex $P125, "$unit"
    unless_null $P125, vivify_1903
    new $P125, "Undef"
  vivify_1903:
    get_hll_global $P127, "GLOBAL"
    nqp_get_package_through_who $P128, $P127, "PAST"
    get_who $P129, $P128
    set $P130, $P129["Var"]
    $P131 = $P130."new"("parameter" :named("scope"), "@ARGS" :named("name"), 1 :named("slurpy"))
    $P125."unshift"($P131)
.annotate 'line', 1291
    get_hll_global $P125, "GLOBAL"
    nqp_get_package_through_who $P127, $P125, "PAST"
    get_who $P128, $P127
    set $P129, $P128["Stmts"]
.annotate 'line', 1292
    get_hll_global $P130, "GLOBAL"
    nqp_get_package_through_who $P131, $P130, "PAST"
    get_who $P132, $P131
    set $P133, $P132["Op"]
    $P134 = $P133."new"("ModuleLoader.pbc", "load_bytecode vs" :named("pirop"))
.annotate 'line', 1293
    get_hll_global $P135, "GLOBAL"
    nqp_get_package_through_who $P136, $P135, "PAST"
    get_who $P137, $P136
    set $P138, $P137["Op"]
.annotate 'line', 1295
    get_hll_global $P139, "GLOBAL"
    nqp_get_package_through_who $P140, $P139, "PAST"
    get_who $P141, $P140
    set $P142, $P141["Var"]
    new $P143, "ResizablePMCArray"
    $P144 = $P142."new"("ModuleLoader" :named("name"), $P143 :named("namespace"), "package" :named("scope"))
.annotate 'line', 1296
    get_hll_global $P145, "GLOBAL"
    nqp_get_package_through_who $P146, $P145, "PAST"
    get_who $P147, $P146
    set $P148, $P147["Var"]
    get_hll_global $P150, "GLOBAL"
    nqp_get_package_through_who $P151, $P150, "PAST"
    get_who $P152, $P151
    set $P153, $P152["Op"]
    $P154 = $P153."new"("getinterp P" :named("pirop"))
    $P155 = $P148."new"($P154, "context", "keyed" :named("scope"))
    $P156 = $P138."new"($P144, $P155, "callmethod" :named("pasttype"), "set_mainline_module" :named("name"))
.annotate 'line', 1293
    $P157 = $P129."new"($P134, $P156)
.annotate 'line', 1291
    store_lex "$main_tasks", $P157
.annotate 'line', 1299
    find_dynamic_lex $P128, "$*MAIN_SUB"
    unless_null $P128, vivify_1904
    get_hll_global $P125, "GLOBAL"
    get_who $P127, $P125
    set $P128, $P127["$MAIN_SUB"]
    unless_null $P128, vivify_1905
    die "Contextual $*MAIN_SUB not found"
  vivify_1905:
  vivify_1904:
    unless $P128, if_2601_end
.annotate 'line', 1300
    find_lex $P129, "$main_tasks"
    unless_null $P129, vivify_1906
    new $P129, "Undef"
  vivify_1906:
    get_hll_global $P130, "GLOBAL"
    nqp_get_package_through_who $P131, $P130, "PAST"
    get_who $P132, $P131
    set $P133, $P132["Op"]
.annotate 'line', 1301
    get_hll_global $P134, "GLOBAL"
    nqp_get_package_through_who $P135, $P134, "PAST"
    get_who $P136, $P135
    set $P137, $P136["Val"]
    find_dynamic_lex $P140, "$*MAIN_SUB"
    unless_null $P140, vivify_1907
    get_hll_global $P138, "GLOBAL"
    get_who $P139, $P138
    set $P140, $P139["$MAIN_SUB"]
    unless_null $P140, vivify_1908
    die "Contextual $*MAIN_SUB not found"
  vivify_1908:
  vivify_1907:
    $P141 = $P137."new"($P140 :named("value"))
.annotate 'line', 1302
    get_hll_global $P142, "GLOBAL"
    nqp_get_package_through_who $P143, $P142, "PAST"
    get_who $P144, $P143
    set $P145, $P144["Var"]
    $P146 = $P145."new"("lexical" :named("scope"), "@ARGS" :named("name"), 1 :named("flat"))
    $P147 = $P133."new"($P141, $P146, "call" :named("pasttype"))
.annotate 'line', 1300
    $P129."push"($P147)
  if_2601_end:
.annotate 'line', 1305
    find_lex $P125, "$mainline"
    unless_null $P125, vivify_1909
    new $P125, "Undef"
  vivify_1909:
    get_hll_global $P127, "GLOBAL"
    nqp_get_package_through_who $P128, $P127, "PAST"
    get_who $P129, $P128
    set $P130, $P129["Op"]
.annotate 'line', 1307
    get_hll_global $P131, "GLOBAL"
    nqp_get_package_through_who $P132, $P131, "PAST"
    get_who $P133, $P132
    set $P134, $P133["Var"]
    $P135 = $P134."new"("lexical" :named("scope"), "@ARGS" :named("name"))
    find_lex $P136, "$main_tasks"
    unless_null $P136, vivify_1910
    new $P136, "Undef"
  vivify_1910:
    $P137 = $P130."new"($P135, $P136, "if" :named("pasttype"))
.annotate 'line', 1305
    $P125."push"($P137)
.annotate 'line', 1314
    find_lex $P125, "$unit"
    unless_null $P125, vivify_1911
    new $P125, "Undef"
  vivify_1911:
.annotate 'line', 1315
    get_hll_global $P127, "GLOBAL"
    nqp_get_package_through_who $P128, $P127, "PAST"
    get_who $P129, $P128
    set $P130, $P129["Op"]
    find_lex $P131, "$mainline"
    unless_null $P131, vivify_1912
    new $P131, "Undef"
  vivify_1912:
    $P132 = $P130."new"($P131, "return" :named("pirop"))
    $P125."push"($P132)
.annotate 'line', 1320
    find_lex $P125, "$unit"
    unless_null $P125, vivify_1913
    new $P125, "Undef"
  vivify_1913:
.annotate 'line', 1321
    get_hll_global $P127, "GLOBAL"
    nqp_get_package_through_who $P128, $P127, "PAST"
    get_who $P129, $P128
    set $P130, $P129["Block"]
.annotate 'line', 1323
    get_hll_global $P131, "GLOBAL"
    nqp_get_package_through_who $P132, $P131, "PAST"
    get_who $P133, $P132
    set $P134, $P133["Op"]
    get_hll_global $P135, "GLOBAL"
    nqp_get_package_through_who $P136, $P135, "PAST"
    get_who $P137, $P136
    set $P138, $P137["Val"]
    find_lex $P139, "$unit"
    unless_null $P139, vivify_1914
    new $P139, "Undef"
  vivify_1914:
    $P140 = $P138."new"($P139 :named("value"))
    $P141 = $P134."new"($P140, "call" :named("pasttype"))
    $P142 = $P130."new"($P141, ":load" :named("pirflags"), 0 :named("lexical"), "" :named("namespace"))
.annotate 'line', 1321
    $P125."push"($P142)
.annotate 'line', 1326
    find_lex $P125, "$unit"
    unless_null $P125, vivify_1915
    new $P125, "Undef"
  vivify_1915:
    find_lex $P127, "$/"
    unless_null $P127, vivify_1916
    new $P127, "Undef"
  vivify_1916:
    $P125."node"($P127)
.annotate 'line', 1329
    find_lex $P125, "$unit"
    unless_null $P125, vivify_1917
    new $P125, "Undef"
  vivify_1917:
    $P125."hll"("nqp")
.annotate 'line', 1331
    find_lex $P125, "$/"
    find_lex $P127, "$unit"
    unless_null $P127, vivify_1918
    new $P127, "Undef"
  vivify_1918:
    $P128 = $P125."!make"($P127)
.annotate 'line', 1253
    .return ($P128)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2595"  :anon :subid("470_1310110678.31883") :outer("469_1310110678.31883")
    .param pmc param_2597
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1280
    .lex "$_", param_2597
.annotate 'line', 1281
    find_lex $P2598, "@loadlibs"
    unless_null $P2598, vivify_1899
    $P2598 = root_new ['parrot';'ResizablePMCArray']
  vivify_1899:
    find_lex $P137, "$_"
    unless_null $P137, vivify_1900
    new $P137, "Undef"
  vivify_1900:
    $P138 = $P2598."push"($P137)
.annotate 'line', 1280
    .return ($P138)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statementlist" :anon :subid("471_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2603
    .param pmc param_2604
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1334
    .const 'Sub' $P2610 = "472_1310110678.31883" 
    capture_lex $P2610
    .lex "self", param_2603
    .lex "$/", param_2604
.annotate 'line', 1335
    new $P122, "Undef"
    set $P2605, $P122
    .lex "$past", $P2605
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Stmts"]
    find_lex $P128, "$/"
    unless_null $P128, vivify_1919
    new $P128, "Undef"
  vivify_1919:
    $P129 = $P127."new"($P128 :named("node"))
    store_lex "$past", $P129
.annotate 'line', 1336
    find_lex $P2607, "$/"
    unless_null $P2607, vivify_1920
    $P2607 = root_new ['parrot';'Hash']
  vivify_1920:
    set $P123, $P2607["statement"]
    unless_null $P123, vivify_1921
    new $P123, "Undef"
  vivify_1921:
    unless $P123, if_2606_end
.annotate 'line', 1337
    find_lex $P2608, "$/"
    unless_null $P2608, vivify_1922
    $P2608 = root_new ['parrot';'Hash']
  vivify_1922:
    set $P125, $P2608["statement"]
    unless_null $P125, vivify_1923
    new $P125, "Undef"
  vivify_1923:
    defined $I100, $P125
    unless $I100, for_undef_1924
    iter $P124, $P125
    new $P129, 'ExceptionHandler'
    set_label $P129, loop2619_handler
    $P129."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P129
  loop2619_test:
    unless $P124, loop2619_done
    shift $P127, $P124
  loop2619_redo:
    .const 'Sub' $P2610 = "472_1310110678.31883" 
    capture_lex $P2610
    $P2610($P127)
  loop2619_next:
    goto loop2619_test
  loop2619_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P130, exception, 'type'
    eq $P130, .CONTROL_LOOP_NEXT, loop2619_next
    eq $P130, .CONTROL_LOOP_REDO, loop2619_redo
  loop2619_done:
    pop_eh 
  for_undef_1924:
  if_2606_end:
.annotate 'line', 1345
    find_lex $P123, "$/"
    find_lex $P124, "$past"
    unless_null $P124, vivify_1937
    new $P124, "Undef"
  vivify_1937:
    $P125 = $P123."!make"($P124)
.annotate 'line', 1334
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2609"  :anon :subid("472_1310110678.31883") :outer("471_1310110678.31883")
    .param pmc param_2612
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1338
    new $P128, "Undef"
    set $P2611, $P128
    .lex "$ast", $P2611
    .lex "$_", param_2612
    find_lex $P129, "$_"
    unless_null $P129, vivify_1925
    new $P129, "Undef"
  vivify_1925:
    $P130 = $P129."ast"()
    store_lex "$ast", $P130
.annotate 'line', 1339
    find_lex $P2614, "$ast"
    unless_null $P2614, vivify_1926
    $P2614 = root_new ['parrot';'Hash']
  vivify_1926:
    set $P129, $P2614["sink"]
    unless_null $P129, vivify_1927
    new $P129, "Undef"
  vivify_1927:
    defined $I101, $P129
    unless $I101, if_2613_end
    find_lex $P2615, "$ast"
    unless_null $P2615, vivify_1928
    $P2615 = root_new ['parrot';'Hash']
  vivify_1928:
    set $P130, $P2615["sink"]
    unless_null $P130, vivify_1929
    new $P130, "Undef"
  vivify_1929:
    store_lex "$ast", $P130
  if_2613_end:
.annotate 'line', 1340
    find_lex $P2617, "$ast"
    unless_null $P2617, vivify_1930
    $P2617 = root_new ['parrot';'Hash']
  vivify_1930:
    set $P129, $P2617["bareblock"]
    unless_null $P129, vivify_1931
    new $P129, "Undef"
  vivify_1931:
    unless $P129, if_2616_end
    find_lex $P130, "$ast"
    unless_null $P130, vivify_1932
    new $P130, "Undef"
  vivify_1932:
    $P131 = "block_immediate"($P130)
    store_lex "$ast", $P131
  if_2616_end:
.annotate 'line', 1341
    get_hll_global $P129, "GLOBAL"
    nqp_get_package_through_who $P130, $P129, "PAST"
    get_who $P131, $P130
    set $P132, $P131["Node"]
    find_lex $P133, "$ast"
    unless_null $P133, vivify_1933
    new $P133, "Undef"
  vivify_1933:
    $P134 = $P132."ACCEPTS"($P133)
    unless $P134, if_2618_end
    get_hll_global $P135, "GLOBAL"
    nqp_get_package_through_who $P136, $P135, "PAST"
    get_who $P137, $P136
    set $P138, $P137["Stmt"]
    find_lex $P139, "$ast"
    unless_null $P139, vivify_1934
    new $P139, "Undef"
  vivify_1934:
    $P140 = $P138."new"($P139)
    store_lex "$ast", $P140
  if_2618_end:
.annotate 'line', 1342
    find_lex $P129, "$past"
    unless_null $P129, vivify_1935
    new $P129, "Undef"
  vivify_1935:
    find_lex $P130, "$ast"
    unless_null $P130, vivify_1936
    new $P130, "Undef"
  vivify_1936:
    $P131 = $P129."push"($P130)
.annotate 'line', 1337
    .return ($P131)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement" :anon :subid("473_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2621
    .param pmc param_2622
    .param pmc param_2623 :optional
    .param int has_param_2623 :opt_flag
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1348
    .const 'Sub' $P2628 = "474_1310110678.31883" 
    capture_lex $P2628
    .lex "self", param_2621
    .lex "$/", param_2622
    if has_param_2623, optparam_1938
    new $P122, "Undef"
    set param_2623, $P122
  optparam_1938:
    .lex "$key", param_2623
.annotate 'line', 1349
    new $P123, "Undef"
    set $P2624, $P123
    .lex "$past", $P2624
.annotate 'line', 1348
    find_lex $P124, "$past"
    unless_null $P124, vivify_1939
    new $P124, "Undef"
  vivify_1939:
.annotate 'line', 1350
    find_lex $P2626, "$/"
    unless_null $P2626, vivify_1940
    $P2626 = root_new ['parrot';'Hash']
  vivify_1940:
    set $P124, $P2626["EXPR"]
    unless_null $P124, vivify_1941
    new $P124, "Undef"
  vivify_1941:
    if $P124, if_2625
.annotate 'line', 1371
    find_lex $P2647, "$/"
    unless_null $P2647, vivify_1942
    $P2647 = root_new ['parrot';'Hash']
  vivify_1942:
    set $P129, $P2647["statement_control"]
    unless_null $P129, vivify_1943
    new $P129, "Undef"
  vivify_1943:
    if $P129, if_2646
.annotate 'line', 1372
    new $P130, "Integer"
    assign $P130, 0
    store_lex "$past", $P130
    goto if_2646_end
  if_2646:
.annotate 'line', 1371
    find_lex $P2648, "$/"
    unless_null $P2648, vivify_1944
    $P2648 = root_new ['parrot';'Hash']
  vivify_1944:
    set $P130, $P2648["statement_control"]
    unless_null $P130, vivify_1945
    new $P130, "Undef"
  vivify_1945:
    $P131 = $P130."ast"()
    store_lex "$past", $P131
  if_2646_end:
    goto if_2625_end
  if_2625:
.annotate 'line', 1350
    .const 'Sub' $P2628 = "474_1310110678.31883" 
    capture_lex $P2628
    $P2628()
  if_2625_end:
.annotate 'line', 1373
    find_lex $P124, "$/"
    find_lex $P125, "$past"
    unless_null $P125, vivify_1979
    new $P125, "Undef"
  vivify_1979:
    $P127 = $P124."!make"($P125)
.annotate 'line', 1348
    .return ($P127)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2627"  :anon :subid("474_1310110678.31883") :outer("473_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1351
    new $P125, "Undef"
    set $P2629, $P125
    .lex "$mc", $P2629
.annotate 'line', 1352
    new $P127, "Undef"
    set $P2630, $P127
    .lex "$ml", $P2630
.annotate 'line', 1351
    find_lex $P2631, "$/"
    unless_null $P2631, vivify_1946
    $P2631 = root_new ['parrot';'Hash']
  vivify_1946:
    set $P2632, $P2631["statement_mod_cond"]
    unless_null $P2632, vivify_1947
    $P2632 = root_new ['parrot';'ResizablePMCArray']
  vivify_1947:
    set $P128, $P2632[0]
    unless_null $P128, vivify_1948
    new $P128, "Undef"
  vivify_1948:
    store_lex "$mc", $P128
.annotate 'line', 1352
    find_lex $P2633, "$/"
    unless_null $P2633, vivify_1949
    $P2633 = root_new ['parrot';'Hash']
  vivify_1949:
    set $P2634, $P2633["statement_mod_loop"]
    unless_null $P2634, vivify_1950
    $P2634 = root_new ['parrot';'ResizablePMCArray']
  vivify_1950:
    set $P128, $P2634[0]
    unless_null $P128, vivify_1951
    new $P128, "Undef"
  vivify_1951:
    store_lex "$ml", $P128
.annotate 'line', 1353
    find_lex $P2635, "$/"
    unless_null $P2635, vivify_1952
    $P2635 = root_new ['parrot';'Hash']
  vivify_1952:
    set $P128, $P2635["EXPR"]
    unless_null $P128, vivify_1953
    new $P128, "Undef"
  vivify_1953:
    $P129 = $P128."ast"()
    store_lex "$past", $P129
.annotate 'line', 1354
    find_lex $P128, "$mc"
    unless_null $P128, vivify_1954
    new $P128, "Undef"
  vivify_1954:
    unless $P128, if_2636_end
.annotate 'line', 1355
    get_hll_global $P129, "GLOBAL"
    nqp_get_package_through_who $P130, $P129, "PAST"
    get_who $P131, $P130
    set $P132, $P131["Op"]
    find_lex $P2637, "$mc"
    unless_null $P2637, vivify_1955
    $P2637 = root_new ['parrot';'Hash']
  vivify_1955:
    set $P133, $P2637["cond"]
    unless_null $P133, vivify_1956
    new $P133, "Undef"
  vivify_1956:
    $P134 = $P133."ast"()
    find_lex $P135, "$past"
    unless_null $P135, vivify_1957
    new $P135, "Undef"
  vivify_1957:
    find_lex $P2638, "$mc"
    unless_null $P2638, vivify_1958
    $P2638 = root_new ['parrot';'Hash']
  vivify_1958:
    set $P136, $P2638["sym"]
    unless_null $P136, vivify_1959
    new $P136, "Undef"
  vivify_1959:
    set $S100, $P136
    find_lex $P137, "$/"
    unless_null $P137, vivify_1960
    new $P137, "Undef"
  vivify_1960:
    $P138 = $P132."new"($P134, $P135, $S100 :named("pasttype"), $P137 :named("node"))
    store_lex "$past", $P138
  if_2636_end:
.annotate 'line', 1357
    find_lex $P129, "$ml"
    unless_null $P129, vivify_1961
    new $P129, "Undef"
  vivify_1961:
    if $P129, if_2639
    set $P128, $P129
    goto if_2639_end
  if_2639:
.annotate 'line', 1358
    find_lex $P2641, "$ml"
    unless_null $P2641, vivify_1962
    $P2641 = root_new ['parrot';'Hash']
  vivify_1962:
    set $P131, $P2641["sym"]
    unless_null $P131, vivify_1963
    new $P131, "Undef"
  vivify_1963:
    set $S100, $P131
    iseq $I100, $S100, "for"
    if $I100, if_2640
.annotate 'line', 1367
    get_hll_global $P132, "GLOBAL"
    nqp_get_package_through_who $P133, $P132, "PAST"
    get_who $P134, $P133
    set $P135, $P134["Op"]
    find_lex $P2644, "$ml"
    unless_null $P2644, vivify_1964
    $P2644 = root_new ['parrot';'Hash']
  vivify_1964:
    set $P136, $P2644["cond"]
    unless_null $P136, vivify_1965
    new $P136, "Undef"
  vivify_1965:
    $P137 = $P136."ast"()
    find_lex $P138, "$past"
    unless_null $P138, vivify_1966
    new $P138, "Undef"
  vivify_1966:
    find_lex $P2645, "$ml"
    unless_null $P2645, vivify_1967
    $P2645 = root_new ['parrot';'Hash']
  vivify_1967:
    set $P139, $P2645["sym"]
    unless_null $P139, vivify_1968
    new $P139, "Undef"
  vivify_1968:
    set $S101, $P139
    find_lex $P140, "$/"
    unless_null $P140, vivify_1969
    new $P140, "Undef"
  vivify_1969:
    $P142 = $P135."new"($P137, $P138, $S101 :named("pasttype"), $P140 :named("node"))
    store_lex "$past", $P142
.annotate 'line', 1366
    set $P130, $P142
.annotate 'line', 1358
    goto if_2640_end
  if_2640:
.annotate 'line', 1359
    get_hll_global $P132, "GLOBAL"
    nqp_get_package_through_who $P133, $P132, "PAST"
    get_who $P134, $P133
    set $P135, $P134["Block"]
.annotate 'line', 1360
    get_hll_global $P136, "GLOBAL"
    nqp_get_package_through_who $P137, $P136, "PAST"
    get_who $P138, $P137
    set $P139, $P138["Var"]
    $P140 = $P139."new"("$_" :named("name"), "parameter" :named("scope"), 1 :named("isdecl"))
    find_lex $P141, "$past"
    unless_null $P141, vivify_1970
    new $P141, "Undef"
  vivify_1970:
    $P142 = $P135."new"($P140, $P141, "immediate" :named("blocktype"))
.annotate 'line', 1359
    store_lex "$past", $P142
.annotate 'line', 1362
    find_lex $P132, "$past"
    unless_null $P132, vivify_1971
    new $P132, "Undef"
  vivify_1971:
    $P132."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 1363
    find_lex $P132, "$past"
    unless_null $P132, vivify_1972
    new $P132, "Undef"
  vivify_1972:
    $P132."arity"(1)
.annotate 'line', 1364
    get_hll_global $P132, "GLOBAL"
    nqp_get_package_through_who $P133, $P132, "PAST"
    get_who $P134, $P133
    set $P135, $P134["Op"]
    find_lex $P2642, "$ml"
    unless_null $P2642, vivify_1973
    $P2642 = root_new ['parrot';'Hash']
  vivify_1973:
    set $P136, $P2642["cond"]
    unless_null $P136, vivify_1974
    new $P136, "Undef"
  vivify_1974:
    $P137 = $P136."ast"()
    find_lex $P138, "$past"
    unless_null $P138, vivify_1975
    new $P138, "Undef"
  vivify_1975:
    find_lex $P2643, "$ml"
    unless_null $P2643, vivify_1976
    $P2643 = root_new ['parrot';'Hash']
  vivify_1976:
    set $P139, $P2643["sym"]
    unless_null $P139, vivify_1977
    new $P139, "Undef"
  vivify_1977:
    set $S101, $P139
    find_lex $P140, "$/"
    unless_null $P140, vivify_1978
    new $P140, "Undef"
  vivify_1978:
    $P141 = $P135."new"($P137, $P138, $S101 :named("pasttype"), $P140 :named("node"))
    store_lex "$past", $P141
.annotate 'line', 1358
    set $P130, $P141
  if_2640_end:
.annotate 'line', 1357
    set $P128, $P130
  if_2639_end:
.annotate 'line', 1350
    .return ($P128)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock" :anon :subid("475_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2650
    .param pmc param_2651
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1376
    .lex "self", param_2650
    .lex "$/", param_2651
.annotate 'line', 1377
    find_lex $P122, "$/"
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Op"]
    find_lex $P2652, "$/"
    unless_null $P2652, vivify_1980
    $P2652 = root_new ['parrot';'Hash']
  vivify_1980:
    set $P128, $P2652["EXPR"]
    unless_null $P128, vivify_1981
    new $P128, "Undef"
  vivify_1981:
    $P129 = $P128."ast"()
    find_lex $P2653, "$/"
    unless_null $P2653, vivify_1982
    $P2653 = root_new ['parrot';'Hash']
  vivify_1982:
    set $P130, $P2653["pblock"]
    unless_null $P130, vivify_1983
    new $P130, "Undef"
  vivify_1983:
    $P131 = $P130."ast"()
    find_lex $P132, "$/"
    unless_null $P132, vivify_1984
    new $P132, "Undef"
  vivify_1984:
    $P133 = $P127."new"($P129, $P131, "if" :named("pasttype"), $P132 :named("node"))
    $P134 = $P122."!make"($P133)
.annotate 'line', 1376
    .return ($P134)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "pblock" :anon :subid("476_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2655
    .param pmc param_2656
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1380
    .lex "self", param_2655
    .lex "$/", param_2656
.annotate 'line', 1381
    find_lex $P122, "$/"
    find_lex $P2657, "$/"
    unless_null $P2657, vivify_1985
    $P2657 = root_new ['parrot';'Hash']
  vivify_1985:
    set $P123, $P2657["blockoid"]
    unless_null $P123, vivify_1986
    new $P123, "Undef"
  vivify_1986:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
.annotate 'line', 1380
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block" :anon :subid("477_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2659
    .param pmc param_2660
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1384
    .lex "self", param_2659
    .lex "$/", param_2660
.annotate 'line', 1385
    find_lex $P122, "$/"
    find_lex $P2661, "$/"
    unless_null $P2661, vivify_1987
    $P2661 = root_new ['parrot';'Hash']
  vivify_1987:
    set $P123, $P2661["blockoid"]
    unless_null $P123, vivify_1988
    new $P123, "Undef"
  vivify_1988:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
.annotate 'line', 1384
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blockoid" :anon :subid("478_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2663
    .param pmc param_2664
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1388
    .const 'Sub' $P2670 = "479_1310110678.31883" 
    capture_lex $P2670
    .lex "self", param_2663
    .lex "$/", param_2664
.annotate 'line', 1389
    new $P122, "Undef"
    set $P2665, $P122
    .lex "$BLOCK", $P2665
    find_lex $P123, "$?PACKAGE"
    get_who $P124, $P123
    set $P2666, $P124["@BLOCK"]
    unless_null $P2666, vivify_1989
    $P2666 = root_new ['parrot';'ResizablePMCArray']
  vivify_1989:
    $P125 = $P2666."shift"()
    store_lex "$BLOCK", $P125
.annotate 'line', 1390
    find_lex $P2668, "$/"
    unless_null $P2668, vivify_1990
    $P2668 = root_new ['parrot';'Hash']
  vivify_1990:
    set $P124, $P2668["statementlist"]
    unless_null $P124, vivify_1991
    new $P124, "Undef"
  vivify_1991:
    if $P124, if_2667
.annotate 'line', 1398
    find_dynamic_lex $P131, "$*HAS_YOU_ARE_HERE"
    unless_null $P131, vivify_1992
    get_hll_global $P128, "GLOBAL"
    get_who $P130, $P128
    set $P131, $P130["$HAS_YOU_ARE_HERE"]
    unless_null $P131, vivify_1993
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_1993:
  vivify_1992:
    unless $P131, if_2673_end
.annotate 'line', 1399
    find_lex $P132, "$/"
    unless_null $P132, vivify_1994
    new $P132, "Undef"
  vivify_1994:
    $P133 = $P132."CURSOR"()
    $P133."panic"("{YOU_ARE_HERE} may only appear once in a setting")
  if_2673_end:
.annotate 'line', 1401
    new $P128, "Integer"
    assign $P128, 1
    store_dynamic_lex "$*HAS_YOU_ARE_HERE", $P128
.annotate 'line', 1402
    find_lex $P128, "$/"
    find_lex $P2674, "$/"
    unless_null $P2674, vivify_1995
    $P2674 = root_new ['parrot';'Hash']
  vivify_1995:
    set $P130, $P2674["you_are_here"]
    unless_null $P130, vivify_1996
    new $P130, "Undef"
  vivify_1996:
    $P131 = $P130."ast"()
    $P132 = $P128."!make"($P131)
.annotate 'line', 1397
    set $P123, $P132
.annotate 'line', 1390
    goto if_2667_end
  if_2667:
    .const 'Sub' $P2670 = "479_1310110678.31883" 
    capture_lex $P2670
    $P127 = $P2670()
    set $P123, $P127
  if_2667_end:
.annotate 'line', 1388
    .return ($P123)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2669"  :anon :subid("479_1310110678.31883") :outer("478_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1391
    new $P125, "Undef"
    set $P2671, $P125
    .lex "$past", $P2671
    find_lex $P2672, "$/"
    unless_null $P2672, vivify_1997
    $P2672 = root_new ['parrot';'Hash']
  vivify_1997:
    set $P127, $P2672["statementlist"]
    unless_null $P127, vivify_1998
    new $P127, "Undef"
  vivify_1998:
    $P128 = $P127."ast"()
    store_lex "$past", $P128
.annotate 'line', 1392
    find_lex $P127, "$BLOCK"
    unless_null $P127, vivify_1999
    new $P127, "Undef"
  vivify_1999:
    find_lex $P128, "$past"
    unless_null $P128, vivify_2000
    new $P128, "Undef"
  vivify_2000:
    $P127."push"($P128)
.annotate 'line', 1393
    find_lex $P127, "$BLOCK"
    unless_null $P127, vivify_2001
    new $P127, "Undef"
  vivify_2001:
    find_lex $P128, "$/"
    unless_null $P128, vivify_2002
    new $P128, "Undef"
  vivify_2002:
    $P127."node"($P128)
.annotate 'line', 1394
    find_lex $P127, "$BLOCK"
    unless_null $P127, vivify_2003
    new $P127, "Undef"
  vivify_2003:
    $P127."closure"(1)
.annotate 'line', 1395
    find_dynamic_lex $P127, "$/"
    find_lex $P128, "$BLOCK"
    unless_null $P128, vivify_2004
    new $P128, "Undef"
  vivify_2004:
    $P129 = $P127."!make"($P128)
.annotate 'line', 1390
    .return ($P129)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "newpad" :anon :subid("480_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2676
    .param pmc param_2677
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1406
    .lex "self", param_2676
    .lex "$/", param_2677
.annotate 'line', 1407
    find_lex $P122, "$?PACKAGE"
    get_who $P123, $P122
    set $P2678, $P123["@BLOCK"]
    unless_null $P2678, vivify_2005
    $P2678 = root_new ['parrot';'ResizablePMCArray']
  vivify_2005:
    get_hll_global $P124, "GLOBAL"
    nqp_get_package_through_who $P125, $P124, "PAST"
    get_who $P127, $P125
    set $P128, $P127["Block"]
    get_hll_global $P129, "GLOBAL"
    nqp_get_package_through_who $P130, $P129, "PAST"
    get_who $P131, $P130
    set $P132, $P131["Stmts"]
    $P133 = $P132."new"()
    $P134 = $P128."new"($P133)
    $P135 = $P2678."unshift"($P134)
.annotate 'line', 1406
    .return ($P135)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "outerctx" :anon :subid("481_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2680
    .param pmc param_2681
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1410
    .const 'Sub' $P2685 = "482_1310110678.31883" 
    capture_lex $P2685
    .lex "self", param_2680
    .lex "$/", param_2681
.annotate 'line', 1411
    find_dynamic_lex $P124, "%*COMPILING"
    unless_null $P124, vivify_2006
    get_hll_global $P122, "GLOBAL"
    get_who $P123, $P122
    set $P124, $P123["%COMPILING"]
    unless_null $P124, vivify_2007
    die "Contextual %*COMPILING not found"
  vivify_2007:
  vivify_2006:
    set $P2683, $P124["%?OPTIONS"]
    unless_null $P2683, vivify_2008
    $P2683 = root_new ['parrot';'Hash']
  vivify_2008:
    set $P125, $P2683["outer_ctx"]
    unless_null $P125, vivify_2009
    new $P125, "Undef"
  vivify_2009:
    defined $I100, $P125
    if $I100, unless_2682_end
    .const 'Sub' $P2685 = "482_1310110678.31883" 
    capture_lex $P2685
    $P2685()
  unless_2682_end:
.annotate 'line', 1424
    find_lex $P122, "self"
    find_lex $P123, "$?PACKAGE"
    get_who $P124, $P123
    set $P2693, $P124["@BLOCK"]
    unless_null $P2693, vivify_2025
    $P2693 = root_new ['parrot';'ResizablePMCArray']
  vivify_2025:
    set $P125, $P2693[0]
    unless_null $P125, vivify_2026
    new $P125, "Undef"
  vivify_2026:
    $P127 = $P122."SET_BLOCK_OUTER_CTX"($P125)
.annotate 'line', 1410
    .return ($P127)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2684"  :anon :subid("482_1310110678.31883") :outer("481_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1414
    new $P127, "Undef"
    set $P2686, $P127
    .lex "$SETTING", $P2686
    find_dynamic_lex $P130, "$*SC"
    unless_null $P130, vivify_2010
    get_hll_global $P128, "GLOBAL"
    get_who $P129, $P128
    set $P130, $P129["$SC"]
    unless_null $P130, vivify_2011
    die "Contextual $*SC not found"
  vivify_2011:
  vivify_2010:
    find_dynamic_lex $P133, "%*COMPILING"
    unless_null $P133, vivify_2012
    get_hll_global $P131, "GLOBAL"
    get_who $P132, $P131
    set $P133, $P132["%COMPILING"]
    unless_null $P133, vivify_2013
    die "Contextual %*COMPILING not found"
  vivify_2013:
  vivify_2012:
    set $P2688, $P133["%?OPTIONS"]
    unless_null $P2688, vivify_2014
    $P2688 = root_new ['parrot';'Hash']
  vivify_2014:
    set $P134, $P2688["setting"]
    unless_null $P134, vivify_2015
    new $P134, "Undef"
  vivify_2015:
    set $P2687, $P134
    defined $I2690, $P2687
    if $I2690, default_2689
    new $P135, "String"
    assign $P135, "NQPCORE"
    set $P2687, $P135
  default_2689:
    $P136 = $P130."load_setting"($P2687)
    store_lex "$SETTING", $P136
.annotate 'line', 1419
    find_dynamic_lex $P131, "%*COMPILING"
    unless_null $P131, vivify_2016
    get_hll_global $P129, "GLOBAL"
    get_who $P130, $P129
    set $P131, $P130["%COMPILING"]
    unless_null $P131, vivify_2017
    die "Contextual %*COMPILING not found"
  vivify_2017:
  vivify_2016:
    set $P2692, $P131["%?OPTIONS"]
    unless_null $P2692, vivify_2018
    $P2692 = root_new ['parrot';'Hash']
  vivify_2018:
    set $P132, $P2692["setting"]
    unless_null $P132, vivify_2019
    new $P132, "Undef"
  vivify_2019:
    set $S100, $P132
    iseq $I101, $S100, "NULL"
    unless $I101, unless_2691
    new $P128, 'Integer'
    set $P128, $I101
    goto unless_2691_end
  unless_2691:
.annotate 'line', 1420
    find_lex $P133, "$SETTING"
    unless_null $P133, vivify_2020
    new $P133, "Undef"
  vivify_2020:
    "import_HOW_exports"($P133)
.annotate 'line', 1421
    find_dynamic_lex $P135, "$*SC"
    unless_null $P135, vivify_2021
    get_hll_global $P133, "GLOBAL"
    get_who $P134, $P133
    set $P135, $P134["$SC"]
    unless_null $P135, vivify_2022
    die "Contextual $*SC not found"
  vivify_2022:
  vivify_2021:
    find_dynamic_lex $P138, "$*GLOBALish"
    unless_null $P138, vivify_2023
    get_hll_global $P136, "GLOBAL"
    get_who $P137, $P136
    set $P138, $P137["$GLOBALish"]
    unless_null $P138, vivify_2024
    die "Contextual $*GLOBALish not found"
  vivify_2024:
  vivify_2023:
    $P139 = $P135."load_module"("NQPRegex", $P138)
.annotate 'line', 1419
    set $P128, $P139
  unless_2691_end:
.annotate 'line', 1411
    .return ($P128)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "GLOBALish" :anon :subid("483_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2695
    .param pmc param_2696
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1436
    .lex "self", param_2695
    .lex "$/", param_2696
.annotate 'line', 1440
    find_dynamic_lex $P124, "$*SC"
    unless_null $P124, vivify_2027
    get_hll_global $P122, "GLOBAL"
    get_who $P123, $P122
    set $P124, $P123["$SC"]
    unless_null $P124, vivify_2028
    die "Contextual $*SC not found"
  vivify_2028:
  vivify_2027:
    find_dynamic_lex $P128, "%*HOW"
    unless_null $P128, vivify_2029
    get_hll_global $P125, "GLOBAL"
    get_who $P127, $P125
    set $P128, $P127["%HOW"]
    unless_null $P128, vivify_2030
    die "Contextual %*HOW not found"
  vivify_2030:
  vivify_2029:
    set $P129, $P128["knowhow"]
    unless_null $P129, vivify_2031
    new $P129, "Undef"
  vivify_2031:
    $P130 = $P124."pkg_create_mo"($P129, "GLOBALish" :named("name"))
    store_dynamic_lex "$*GLOBALish", $P130
.annotate 'line', 1441
    find_dynamic_lex $P124, "$*GLOBALish"
    unless_null $P124, vivify_2032
    get_hll_global $P122, "GLOBAL"
    get_who $P123, $P122
    set $P124, $P123["$GLOBALish"]
    unless_null $P124, vivify_2033
    die "Contextual $*GLOBALish not found"
  vivify_2033:
  vivify_2032:
    get_how $P125, $P124
    find_dynamic_lex $P129, "$*GLOBALish"
    unless_null $P129, vivify_2034
    get_hll_global $P127, "GLOBAL"
    get_who $P128, $P127
    set $P129, $P128["$GLOBALish"]
    unless_null $P129, vivify_2035
    die "Contextual $*GLOBALish not found"
  vivify_2035:
  vivify_2034:
    $P125."compose"($P129)
.annotate 'line', 1442
    find_dynamic_lex $P124, "$*SC"
    unless_null $P124, vivify_2036
    get_hll_global $P122, "GLOBAL"
    get_who $P123, $P122
    set $P124, $P123["$SC"]
    unless_null $P124, vivify_2037
    die "Contextual $*SC not found"
  vivify_2037:
  vivify_2036:
    find_lex $P125, "$?PACKAGE"
    get_who $P127, $P125
    set $P2697, $P127["@BLOCK"]
    unless_null $P2697, vivify_2038
    $P2697 = root_new ['parrot';'ResizablePMCArray']
  vivify_2038:
    set $P128, $P2697[0]
    unless_null $P128, vivify_2039
    new $P128, "Undef"
  vivify_2039:
    find_dynamic_lex $P131, "$*GLOBALish"
    unless_null $P131, vivify_2040
    get_hll_global $P129, "GLOBAL"
    get_who $P130, $P129
    set $P131, $P130["$GLOBALish"]
    unless_null $P131, vivify_2041
    die "Contextual $*GLOBALish not found"
  vivify_2041:
  vivify_2040:
    $P124."install_lexical_symbol"($P128, "GLOBALish", $P131)
.annotate 'line', 1445
    find_dynamic_lex $P124, "$*GLOBALish"
    unless_null $P124, vivify_2042
    get_hll_global $P122, "GLOBAL"
    get_who $P123, $P122
    set $P124, $P123["$GLOBALish"]
    unless_null $P124, vivify_2043
    die "Contextual $*GLOBALish not found"
  vivify_2043:
  vivify_2042:
    store_dynamic_lex "$*PACKAGE", $P124
.annotate 'line', 1446
    find_dynamic_lex $P124, "$*SC"
    unless_null $P124, vivify_2044
    get_hll_global $P122, "GLOBAL"
    get_who $P123, $P122
    set $P124, $P123["$SC"]
    unless_null $P124, vivify_2045
    die "Contextual $*SC not found"
  vivify_2045:
  vivify_2044:
    find_lex $P125, "$?PACKAGE"
    get_who $P127, $P125
    set $P2698, $P127["@BLOCK"]
    unless_null $P2698, vivify_2046
    $P2698 = root_new ['parrot';'ResizablePMCArray']
  vivify_2046:
    set $P128, $P2698[0]
    unless_null $P128, vivify_2047
    new $P128, "Undef"
  vivify_2047:
    find_dynamic_lex $P131, "$*PACKAGE"
    unless_null $P131, vivify_2048
    get_hll_global $P129, "GLOBAL"
    get_who $P130, $P129
    set $P131, $P130["$PACKAGE"]
    unless_null $P131, vivify_2049
    die "Contextual $*PACKAGE not found"
  vivify_2049:
  vivify_2048:
    $P132 = $P124."install_lexical_symbol"($P128, "$?PACKAGE", $P131)
.annotate 'line', 1436
    .return ($P132)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "you_are_here" :anon :subid("484_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2700
    .param pmc param_2701
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1449
    .lex "self", param_2700
    .lex "$/", param_2701
.annotate 'line', 1450
    find_lex $P122, "$/"
    find_lex $P123, "self"
    $P124 = $P123."CTXSAVE"()
    $P125 = $P122."!make"($P124)
.annotate 'line', 1449
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<use>" :anon :subid("485_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2703
    .param pmc param_2704
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1455
    .lex "self", param_2703
    .lex "$/", param_2704
.annotate 'line', 1456
    new $P122, "Undef"
    set $P2705, $P122
    .lex "$module", $P2705
    find_dynamic_lex $P125, "$*SC"
    unless_null $P125, vivify_2050
    get_hll_global $P123, "GLOBAL"
    get_who $P124, $P123
    set $P125, $P124["$SC"]
    unless_null $P125, vivify_2051
    die "Contextual $*SC not found"
  vivify_2051:
  vivify_2050:
    find_lex $P2706, "$/"
    unless_null $P2706, vivify_2052
    $P2706 = root_new ['parrot';'Hash']
  vivify_2052:
    set $P127, $P2706["name"]
    unless_null $P127, vivify_2053
    new $P127, "Undef"
  vivify_2053:
    set $S100, $P127
    find_dynamic_lex $P130, "$*GLOBALish"
    unless_null $P130, vivify_2054
    get_hll_global $P128, "GLOBAL"
    get_who $P129, $P128
    set $P130, $P129["$GLOBALish"]
    unless_null $P130, vivify_2055
    die "Contextual $*GLOBALish not found"
  vivify_2055:
  vivify_2054:
    $P131 = $P125."load_module"($S100, $P130)
    store_lex "$module", $P131
.annotate 'line', 1457
    find_lex $P123, "$module"
    unless_null $P123, vivify_2056
    new $P123, "Undef"
  vivify_2056:
    defined $I100, $P123
    unless $I100, if_2707_end
.annotate 'line', 1458
    find_lex $P124, "$module"
    unless_null $P124, vivify_2057
    new $P124, "Undef"
  vivify_2057:
    "import_HOW_exports"($P124)
  if_2707_end:
.annotate 'line', 1460
    find_lex $P123, "$/"
    get_hll_global $P124, "GLOBAL"
    nqp_get_package_through_who $P125, $P124, "PAST"
    get_who $P127, $P125
    set $P128, $P127["Stmts"]
    $P129 = $P128."new"()
    $P130 = $P123."!make"($P129)
.annotate 'line', 1455
    .return ($P130)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statement_control:sym<if>" :anon :subid("486_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2709
    .param pmc param_2710
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1463
    .const 'Sub' $P2721 = "487_1310110678.31883" 
    capture_lex $P2721
    .lex "self", param_2709
    .lex "$/", param_2710
.annotate 'line', 1464
    new $P122, "Undef"
    set $P2711, $P122
    .lex "$count", $P2711
.annotate 'line', 1465
    new $P123, "Undef"
    set $P2712, $P123
    .lex "$past", $P2712
.annotate 'line', 1464
    find_lex $P2713, "$/"
    unless_null $P2713, vivify_2058
    $P2713 = root_new ['parrot';'Hash']
  vivify_2058:
    set $P124, $P2713["xblock"]
    unless_null $P124, vivify_2059
    new $P124, "Undef"
  vivify_2059:
    set $N100, $P124
    new $P125, 'Float'
    set $P125, $N100
    sub $P127, $P125, 1
    store_lex "$count", $P127
.annotate 'line', 1465
    find_lex $P124, "$count"
    unless_null $P124, vivify_2060
    new $P124, "Undef"
  vivify_2060:
    set $I100, $P124
    find_lex $P2714, "$/"
    unless_null $P2714, vivify_2061
    $P2714 = root_new ['parrot';'Hash']
  vivify_2061:
    set $P2715, $P2714["xblock"]
    unless_null $P2715, vivify_2062
    $P2715 = root_new ['parrot';'ResizablePMCArray']
  vivify_2062:
    set $P125, $P2715[$I100]
    unless_null $P125, vivify_2063
    new $P125, "Undef"
  vivify_2063:
    $P127 = $P125."ast"()
    $P128 = "xblock_immediate"($P127)
    store_lex "$past", $P128
.annotate 'line', 1466
    find_lex $P2717, "$/"
    unless_null $P2717, vivify_2064
    $P2717 = root_new ['parrot';'Hash']
  vivify_2064:
    set $P124, $P2717["else"]
    unless_null $P124, vivify_2065
    new $P124, "Undef"
  vivify_2065:
    unless $P124, if_2716_end
.annotate 'line', 1467
    find_lex $P125, "$past"
    unless_null $P125, vivify_2066
    new $P125, "Undef"
  vivify_2066:
    find_lex $P2718, "$/"
    unless_null $P2718, vivify_2067
    $P2718 = root_new ['parrot';'Hash']
  vivify_2067:
    set $P2719, $P2718["else"]
    unless_null $P2719, vivify_2068
    $P2719 = root_new ['parrot';'ResizablePMCArray']
  vivify_2068:
    set $P127, $P2719[0]
    unless_null $P127, vivify_2069
    new $P127, "Undef"
  vivify_2069:
    $P128 = $P127."ast"()
    $P129 = "block_immediate"($P128)
    $P125."push"($P129)
  if_2716_end:
.annotate 'line', 1470
    new $P127, 'ExceptionHandler'
    set_label $P127, loop2726_handler
    $P127."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P127
  loop2726_test:
    find_lex $P124, "$count"
    unless_null $P124, vivify_2070
    new $P124, "Undef"
  vivify_2070:
    set $N100, $P124
    isgt $I100, $N100, 0.0
    unless $I100, loop2726_done
  loop2726_redo:
    .const 'Sub' $P2721 = "487_1310110678.31883" 
    capture_lex $P2721
    $P2721()
  loop2726_next:
    goto loop2726_test
  loop2726_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P128, exception, 'type'
    eq $P128, .CONTROL_LOOP_NEXT, loop2726_next
    eq $P128, .CONTROL_LOOP_REDO, loop2726_redo
  loop2726_done:
    pop_eh 
.annotate 'line', 1476
    find_lex $P124, "$/"
    find_lex $P125, "$past"
    unless_null $P125, vivify_2079
    new $P125, "Undef"
  vivify_2079:
    $P127 = $P124."!make"($P125)
.annotate 'line', 1463
    .return ($P127)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2720"  :anon :subid("487_1310110678.31883") :outer("486_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1472
    new $P125, "Undef"
    set $P2722, $P125
    .lex "$else", $P2722
.annotate 'line', 1470
    find_lex $P127, "$count"
    unless_null $P127, vivify_2071
    new $P127, "Undef"
  vivify_2071:
    clone $P2723, $P127
    dec $P127
.annotate 'line', 1472
    find_lex $P127, "$past"
    unless_null $P127, vivify_2072
    new $P127, "Undef"
  vivify_2072:
    store_lex "$else", $P127
.annotate 'line', 1473
    find_lex $P127, "$count"
    unless_null $P127, vivify_2073
    new $P127, "Undef"
  vivify_2073:
    set $I101, $P127
    find_lex $P2724, "$/"
    unless_null $P2724, vivify_2074
    $P2724 = root_new ['parrot';'Hash']
  vivify_2074:
    set $P2725, $P2724["xblock"]
    unless_null $P2725, vivify_2075
    $P2725 = root_new ['parrot';'ResizablePMCArray']
  vivify_2075:
    set $P128, $P2725[$I101]
    unless_null $P128, vivify_2076
    new $P128, "Undef"
  vivify_2076:
    $P129 = $P128."ast"()
    $P130 = "xblock_immediate"($P129)
    store_lex "$past", $P130
.annotate 'line', 1474
    find_lex $P127, "$past"
    unless_null $P127, vivify_2077
    new $P127, "Undef"
  vivify_2077:
    find_lex $P128, "$else"
    unless_null $P128, vivify_2078
    new $P128, "Undef"
  vivify_2078:
    $P129 = $P127."push"($P128)
.annotate 'line', 1470
    .return ($P129)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<unless>" :anon :subid("488_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2728
    .param pmc param_2729
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1479
    .lex "self", param_2728
    .lex "$/", param_2729
.annotate 'line', 1480
    new $P122, "Undef"
    set $P2730, $P122
    .lex "$past", $P2730
    find_lex $P2731, "$/"
    unless_null $P2731, vivify_2080
    $P2731 = root_new ['parrot';'Hash']
  vivify_2080:
    set $P123, $P2731["xblock"]
    unless_null $P123, vivify_2081
    new $P123, "Undef"
  vivify_2081:
    $P124 = $P123."ast"()
    $P125 = "xblock_immediate"($P124)
    store_lex "$past", $P125
.annotate 'line', 1481
    find_lex $P123, "$past"
    unless_null $P123, vivify_2082
    new $P123, "Undef"
  vivify_2082:
    $P123."pasttype"("unless")
.annotate 'line', 1482
    find_lex $P123, "$/"
    find_lex $P124, "$past"
    unless_null $P124, vivify_2083
    new $P124, "Undef"
  vivify_2083:
    $P125 = $P123."!make"($P124)
.annotate 'line', 1479
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<while>" :anon :subid("489_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2733
    .param pmc param_2734
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1485
    .lex "self", param_2733
    .lex "$/", param_2734
.annotate 'line', 1486
    new $P122, "Undef"
    set $P2735, $P122
    .lex "$past", $P2735
    find_lex $P2736, "$/"
    unless_null $P2736, vivify_2084
    $P2736 = root_new ['parrot';'Hash']
  vivify_2084:
    set $P123, $P2736["xblock"]
    unless_null $P123, vivify_2085
    new $P123, "Undef"
  vivify_2085:
    $P124 = $P123."ast"()
    $P125 = "xblock_immediate"($P124)
    store_lex "$past", $P125
.annotate 'line', 1487
    find_lex $P123, "$past"
    unless_null $P123, vivify_2086
    new $P123, "Undef"
  vivify_2086:
    find_lex $P2737, "$/"
    unless_null $P2737, vivify_2087
    $P2737 = root_new ['parrot';'Hash']
  vivify_2087:
    set $P124, $P2737["sym"]
    unless_null $P124, vivify_2088
    new $P124, "Undef"
  vivify_2088:
    set $S100, $P124
    $P123."pasttype"($S100)
.annotate 'line', 1488
    find_lex $P123, "$/"
    find_lex $P124, "$past"
    unless_null $P124, vivify_2089
    new $P124, "Undef"
  vivify_2089:
    $P125 = $P123."!make"($P124)
.annotate 'line', 1485
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<repeat>" :anon :subid("490_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2739
    .param pmc param_2740
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1491
    .lex "self", param_2739
    .lex "$/", param_2740
.annotate 'line', 1492
    new $P122, "Undef"
    set $P2741, $P122
    .lex "$pasttype", $P2741
.annotate 'line', 1493
    new $P123, "Undef"
    set $P2742, $P123
    .lex "$past", $P2742
.annotate 'line', 1492
    new $P124, "String"
    assign $P124, "repeat_"
    find_lex $P2743, "$/"
    unless_null $P2743, vivify_2090
    $P2743 = root_new ['parrot';'Hash']
  vivify_2090:
    set $P125, $P2743["wu"]
    unless_null $P125, vivify_2091
    new $P125, "Undef"
  vivify_2091:
    set $S100, $P125
    concat $P127, $P124, $S100
    store_lex "$pasttype", $P127
.annotate 'line', 1491
    find_lex $P124, "$past"
    unless_null $P124, vivify_2092
    new $P124, "Undef"
  vivify_2092:
.annotate 'line', 1494
    find_lex $P2745, "$/"
    unless_null $P2745, vivify_2093
    $P2745 = root_new ['parrot';'Hash']
  vivify_2093:
    set $P124, $P2745["xblock"]
    unless_null $P124, vivify_2094
    new $P124, "Undef"
  vivify_2094:
    if $P124, if_2744
.annotate 'line', 1499
    get_hll_global $P125, "GLOBAL"
    nqp_get_package_through_who $P127, $P125, "PAST"
    get_who $P128, $P127
    set $P129, $P128["Op"]
    find_lex $P2747, "$/"
    unless_null $P2747, vivify_2095
    $P2747 = root_new ['parrot';'Hash']
  vivify_2095:
    set $P130, $P2747["EXPR"]
    unless_null $P130, vivify_2096
    new $P130, "Undef"
  vivify_2096:
    $P131 = $P130."ast"()
    find_lex $P2748, "$/"
    unless_null $P2748, vivify_2097
    $P2748 = root_new ['parrot';'Hash']
  vivify_2097:
    set $P132, $P2748["pblock"]
    unless_null $P132, vivify_2098
    new $P132, "Undef"
  vivify_2098:
    $P133 = $P132."ast"()
    $P134 = "block_immediate"($P133)
    find_lex $P135, "$pasttype"
    unless_null $P135, vivify_2099
    new $P135, "Undef"
  vivify_2099:
    find_lex $P136, "$/"
    unless_null $P136, vivify_2100
    new $P136, "Undef"
  vivify_2100:
    $P137 = $P129."new"($P131, $P134, $P135 :named("pasttype"), $P136 :named("node"))
    store_lex "$past", $P137
.annotate 'line', 1498
    goto if_2744_end
  if_2744:
.annotate 'line', 1495
    find_lex $P2746, "$/"
    unless_null $P2746, vivify_2101
    $P2746 = root_new ['parrot';'Hash']
  vivify_2101:
    set $P125, $P2746["xblock"]
    unless_null $P125, vivify_2102
    new $P125, "Undef"
  vivify_2102:
    $P127 = $P125."ast"()
    $P128 = "xblock_immediate"($P127)
    store_lex "$past", $P128
.annotate 'line', 1496
    find_lex $P125, "$past"
    unless_null $P125, vivify_2103
    new $P125, "Undef"
  vivify_2103:
    find_lex $P127, "$pasttype"
    unless_null $P127, vivify_2104
    new $P127, "Undef"
  vivify_2104:
    $P125."pasttype"($P127)
  if_2744_end:
.annotate 'line', 1502
    find_lex $P124, "$/"
    find_lex $P125, "$past"
    unless_null $P125, vivify_2105
    new $P125, "Undef"
  vivify_2105:
    $P127 = $P124."!make"($P125)
.annotate 'line', 1491
    .return ($P127)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<for>" :anon :subid("491_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2750
    .param pmc param_2751
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1505
    .lex "self", param_2750
    .lex "$/", param_2751
.annotate 'line', 1506
    new $P122, "Undef"
    set $P2752, $P122
    .lex "$past", $P2752
.annotate 'line', 1508
    new $P123, "Undef"
    set $P2753, $P123
    .lex "$block", $P2753
.annotate 'line', 1506
    find_lex $P2754, "$/"
    unless_null $P2754, vivify_2106
    $P2754 = root_new ['parrot';'Hash']
  vivify_2106:
    set $P124, $P2754["xblock"]
    unless_null $P124, vivify_2107
    new $P124, "Undef"
  vivify_2107:
    $P125 = $P124."ast"()
    store_lex "$past", $P125
.annotate 'line', 1507
    find_lex $P124, "$past"
    unless_null $P124, vivify_2108
    new $P124, "Undef"
  vivify_2108:
    $P124."pasttype"("for")
.annotate 'line', 1508
    find_lex $P2755, "$past"
    unless_null $P2755, vivify_2109
    $P2755 = root_new ['parrot';'ResizablePMCArray']
  vivify_2109:
    set $P124, $P2755[1]
    unless_null $P124, vivify_2110
    new $P124, "Undef"
  vivify_2110:
    store_lex "$block", $P124
.annotate 'line', 1509
    find_lex $P124, "$block"
    unless_null $P124, vivify_2111
    new $P124, "Undef"
  vivify_2111:
    $P125 = $P124."arity"()
    if $P125, unless_2756_end
.annotate 'line', 1510
    find_lex $P2757, "$block"
    unless_null $P2757, vivify_2112
    $P2757 = root_new ['parrot';'ResizablePMCArray']
  vivify_2112:
    set $P127, $P2757[0]
    unless_null $P127, vivify_2113
    new $P127, "Undef"
  vivify_2113:
    get_hll_global $P128, "GLOBAL"
    nqp_get_package_through_who $P129, $P128, "PAST"
    get_who $P130, $P129
    set $P131, $P130["Var"]
    $P132 = $P131."new"("$_" :named("name"), "parameter" :named("scope"))
    $P127."push"($P132)
.annotate 'line', 1511
    find_lex $P127, "$block"
    unless_null $P127, vivify_2114
    new $P127, "Undef"
  vivify_2114:
    $P127."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 1512
    find_lex $P127, "$block"
    unless_null $P127, vivify_2115
    new $P127, "Undef"
  vivify_2115:
    $P127."arity"(1)
  unless_2756_end:
.annotate 'line', 1514
    find_lex $P124, "$block"
    unless_null $P124, vivify_2116
    new $P124, "Undef"
  vivify_2116:
    $P124."blocktype"("immediate")
.annotate 'line', 1515
    find_lex $P124, "$/"
    find_lex $P125, "$past"
    unless_null $P125, vivify_2117
    new $P125, "Undef"
  vivify_2117:
    $P127 = $P124."!make"($P125)
.annotate 'line', 1505
    .return ($P127)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CATCH>" :anon :subid("492_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2759
    .param pmc param_2760
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1518
    .lex "self", param_2759
    .lex "$/", param_2760
.annotate 'line', 1519
    new $P122, "Undef"
    set $P2761, $P122
    .lex "$block", $P2761
    find_lex $P2762, "$/"
    unless_null $P2762, vivify_2118
    $P2762 = root_new ['parrot';'Hash']
  vivify_2118:
    set $P123, $P2762["block"]
    unless_null $P123, vivify_2119
    new $P123, "Undef"
  vivify_2119:
    $P124 = $P123."ast"()
    store_lex "$block", $P124
.annotate 'line', 1520
    find_lex $P123, "$/"
    unless_null $P123, vivify_2120
    new $P123, "Undef"
  vivify_2120:
    find_lex $P124, "$block"
    unless_null $P124, vivify_2121
    new $P124, "Undef"
  vivify_2121:
    "push_block_handler"($P123, $P124)
.annotate 'line', 1521
    find_lex $P123, "$?PACKAGE"
    get_who $P124, $P123
    set $P2763, $P124["@BLOCK"]
    unless_null $P2763, vivify_2122
    $P2763 = root_new ['parrot';'ResizablePMCArray']
  vivify_2122:
    set $P125, $P2763[0]
    unless_null $P125, vivify_2123
    new $P125, "Undef"
  vivify_2123:
    $P127 = $P125."handlers"()
    set $P128, $P127[0]
    unless_null $P128, vivify_2124
    new $P128, "Undef"
  vivify_2124:
    $P128."handle_types_except"("CONTROL")
.annotate 'line', 1522
    find_lex $P123, "$/"
    get_hll_global $P124, "GLOBAL"
    nqp_get_package_through_who $P125, $P124, "PAST"
    get_who $P127, $P125
    set $P128, $P127["Stmts"]
    find_lex $P129, "$/"
    unless_null $P129, vivify_2125
    new $P129, "Undef"
  vivify_2125:
    $P130 = $P128."new"($P129 :named("node"))
    $P131 = $P123."!make"($P130)
.annotate 'line', 1518
    .return ($P131)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CONTROL>" :anon :subid("493_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2765
    .param pmc param_2766
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1525
    .lex "self", param_2765
    .lex "$/", param_2766
.annotate 'line', 1526
    new $P122, "Undef"
    set $P2767, $P122
    .lex "$block", $P2767
    find_lex $P2768, "$/"
    unless_null $P2768, vivify_2126
    $P2768 = root_new ['parrot';'Hash']
  vivify_2126:
    set $P123, $P2768["block"]
    unless_null $P123, vivify_2127
    new $P123, "Undef"
  vivify_2127:
    $P124 = $P123."ast"()
    store_lex "$block", $P124
.annotate 'line', 1527
    find_lex $P123, "$/"
    unless_null $P123, vivify_2128
    new $P123, "Undef"
  vivify_2128:
    find_lex $P124, "$block"
    unless_null $P124, vivify_2129
    new $P124, "Undef"
  vivify_2129:
    "push_block_handler"($P123, $P124)
.annotate 'line', 1528
    find_lex $P123, "$?PACKAGE"
    get_who $P124, $P123
    set $P2769, $P124["@BLOCK"]
    unless_null $P2769, vivify_2130
    $P2769 = root_new ['parrot';'ResizablePMCArray']
  vivify_2130:
    set $P125, $P2769[0]
    unless_null $P125, vivify_2131
    new $P125, "Undef"
  vivify_2131:
    $P127 = $P125."handlers"()
    set $P128, $P127[0]
    unless_null $P128, vivify_2132
    new $P128, "Undef"
  vivify_2132:
    $P128."handle_types"("CONTROL")
.annotate 'line', 1529
    find_lex $P123, "$/"
    get_hll_global $P124, "GLOBAL"
    nqp_get_package_through_who $P125, $P124, "PAST"
    get_who $P127, $P125
    set $P128, $P127["Stmts"]
    find_lex $P129, "$/"
    unless_null $P129, vivify_2133
    new $P129, "Undef"
  vivify_2133:
    $P130 = $P128."new"($P129 :named("node"))
    $P131 = $P123."!make"($P130)
.annotate 'line', 1525
    .return ($P131)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<INIT>" :anon :subid("494_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2771
    .param pmc param_2772
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1569
    .lex "self", param_2771
    .lex "$/", param_2772
.annotate 'line', 1570
    find_lex $P122, "$?PACKAGE"
    get_who $P123, $P122
    set $P2773, $P123["@BLOCK"]
    unless_null $P2773, vivify_2134
    $P2773 = root_new ['parrot';'ResizablePMCArray']
  vivify_2134:
    set $P124, $P2773[0]
    unless_null $P124, vivify_2135
    new $P124, "Undef"
  vivify_2135:
    find_lex $P2774, "$/"
    unless_null $P2774, vivify_2136
    $P2774 = root_new ['parrot';'Hash']
  vivify_2136:
    set $P125, $P2774["blorst"]
    unless_null $P125, vivify_2137
    new $P125, "Undef"
  vivify_2137:
    $P127 = $P125."ast"()
    $P124."push"($P127)
.annotate 'line', 1571
    find_lex $P122, "$/"
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Stmts"]
    $P128 = $P127."new"()
    $P129 = $P122."!make"($P128)
.annotate 'line', 1569
    .return ($P129)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<try>" :anon :subid("495_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2776
    .param pmc param_2777
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1574
    .lex "self", param_2776
    .lex "$/", param_2777
.annotate 'line', 1575
    new $P122, "Undef"
    set $P2778, $P122
    .lex "$past", $P2778
    find_lex $P2779, "$/"
    unless_null $P2779, vivify_2138
    $P2779 = root_new ['parrot';'Hash']
  vivify_2138:
    set $P123, $P2779["blorst"]
    unless_null $P123, vivify_2139
    new $P123, "Undef"
  vivify_2139:
    $P124 = $P123."ast"()
    store_lex "$past", $P124
.annotate 'line', 1576
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Block"]
    find_lex $P128, "$past"
    unless_null $P128, vivify_2140
    new $P128, "Undef"
  vivify_2140:
    $P129 = $P127."ACCEPTS"($P128)
    if $P129, unless_2780_end
.annotate 'line', 1577
    get_hll_global $P130, "GLOBAL"
    nqp_get_package_through_who $P131, $P130, "PAST"
    get_who $P132, $P131
    set $P133, $P132["Block"]
    find_lex $P134, "$past"
    unless_null $P134, vivify_2141
    new $P134, "Undef"
  vivify_2141:
    find_lex $P135, "$/"
    unless_null $P135, vivify_2142
    new $P135, "Undef"
  vivify_2142:
    $P136 = $P133."new"($P134, "immediate" :named("blocktype"), $P135 :named("node"))
    store_lex "$past", $P136
  unless_2780_end:
.annotate 'line', 1579
    find_lex $P123, "$past"
    unless_null $P123, vivify_2143
    new $P123, "Undef"
  vivify_2143:
    $P124 = $P123."handlers"()
    if $P124, unless_2781_end
.annotate 'line', 1580
    find_lex $P125, "$past"
    unless_null $P125, vivify_2144
    new $P125, "Undef"
  vivify_2144:
    get_hll_global $P127, "GLOBAL"
    nqp_get_package_through_who $P128, $P127, "PAST"
    get_who $P129, $P128
    set $P130, $P129["Control"]
.annotate 'line', 1582
    get_hll_global $P131, "GLOBAL"
    nqp_get_package_through_who $P132, $P131, "PAST"
    get_who $P133, $P132
    set $P134, $P133["Stmts"]
.annotate 'line', 1583
    get_hll_global $P135, "GLOBAL"
    nqp_get_package_through_who $P136, $P135, "PAST"
    get_who $P137, $P136
    set $P138, $P137["Op"]
.annotate 'line', 1584
    get_hll_global $P139, "GLOBAL"
    nqp_get_package_through_who $P140, $P139, "PAST"
    get_who $P141, $P140
    set $P142, $P141["Var"]
.annotate 'line', 1585
    get_hll_global $P143, "GLOBAL"
    nqp_get_package_through_who $P144, $P143, "PAST"
    get_who $P145, $P144
    set $P146, $P145["Var"]
    $P147 = $P146."new"("register" :named("scope"), "exception" :named("name"))
    $P148 = $P142."new"($P147, "handled", "keyed" :named("scope"))
.annotate 'line', 1584
    $P150 = $P138."new"($P148, 1, "bind_6model" :named("pasttype"))
.annotate 'line', 1583
    $P151 = $P134."new"($P150)
.annotate 'line', 1582
    $P152 = $P130."new"($P151, "CONTROL" :named("handle_types_except"))
.annotate 'line', 1580
    new $P153, "ResizablePMCArray"
    push $P153, $P152
    $P125."handlers"($P153)
  unless_2781_end:
.annotate 'line', 1594
    find_lex $P123, "$/"
    find_lex $P124, "$past"
    unless_null $P124, vivify_2145
    new $P124, "Undef"
  vivify_2145:
    $P125 = $P123."!make"($P124)
.annotate 'line', 1574
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blorst" :anon :subid("496_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2783
    .param pmc param_2784
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1597
    .lex "self", param_2783
    .lex "$/", param_2784
.annotate 'line', 1598
    find_lex $P122, "$/"
.annotate 'line', 1599
    find_lex $P2786, "$/"
    unless_null $P2786, vivify_2146
    $P2786 = root_new ['parrot';'Hash']
  vivify_2146:
    set $P124, $P2786["block"]
    unless_null $P124, vivify_2147
    new $P124, "Undef"
  vivify_2147:
    if $P124, if_2785
.annotate 'line', 1600
    find_lex $P2788, "$/"
    unless_null $P2788, vivify_2148
    $P2788 = root_new ['parrot';'Hash']
  vivify_2148:
    set $P129, $P2788["statement"]
    unless_null $P129, vivify_2149
    new $P129, "Undef"
  vivify_2149:
    $P130 = $P129."ast"()
    set $P123, $P130
.annotate 'line', 1599
    goto if_2785_end
  if_2785:
    find_lex $P2787, "$/"
    unless_null $P2787, vivify_2150
    $P2787 = root_new ['parrot';'Hash']
  vivify_2150:
    set $P125, $P2787["block"]
    unless_null $P125, vivify_2151
    new $P125, "Undef"
  vivify_2151:
    $P127 = $P125."ast"()
    $P128 = "block_immediate"($P127)
    set $P123, $P128
  if_2785_end:
    $P131 = $P122."!make"($P123)
.annotate 'line', 1597
    .return ($P131)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<if>" :anon :subid("497_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2790
    .param pmc param_2791
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1605
    .lex "self", param_2790
    .lex "$/", param_2791
    find_lex $P122, "$/"
    find_lex $P2792, "$/"
    unless_null $P2792, vivify_2152
    $P2792 = root_new ['parrot';'Hash']
  vivify_2152:
    set $P123, $P2792["cond"]
    unless_null $P123, vivify_2153
    new $P123, "Undef"
  vivify_2153:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<unless>" :anon :subid("498_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2794
    .param pmc param_2795
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1606
    .lex "self", param_2794
    .lex "$/", param_2795
    find_lex $P122, "$/"
    find_lex $P2796, "$/"
    unless_null $P2796, vivify_2154
    $P2796 = root_new ['parrot';'Hash']
  vivify_2154:
    set $P123, $P2796["cond"]
    unless_null $P123, vivify_2155
    new $P123, "Undef"
  vivify_2155:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<while>" :anon :subid("499_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2798
    .param pmc param_2799
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1608
    .lex "self", param_2798
    .lex "$/", param_2799
    find_lex $P122, "$/"
    find_lex $P2800, "$/"
    unless_null $P2800, vivify_2156
    $P2800 = root_new ['parrot';'Hash']
  vivify_2156:
    set $P123, $P2800["cond"]
    unless_null $P123, vivify_2157
    new $P123, "Undef"
  vivify_2157:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<until>" :anon :subid("500_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2802
    .param pmc param_2803
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1609
    .lex "self", param_2802
    .lex "$/", param_2803
    find_lex $P122, "$/"
    find_lex $P2804, "$/"
    unless_null $P2804, vivify_2158
    $P2804 = root_new ['parrot';'Hash']
  vivify_2158:
    set $P123, $P2804["cond"]
    unless_null $P123, vivify_2159
    new $P123, "Undef"
  vivify_2159:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<fatarrow>" :anon :subid("501_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2806
    .param pmc param_2807
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1613
    .lex "self", param_2806
    .lex "$/", param_2807
    find_lex $P122, "$/"
    find_lex $P2808, "$/"
    unless_null $P2808, vivify_2160
    $P2808 = root_new ['parrot';'Hash']
  vivify_2160:
    set $P123, $P2808["fatarrow"]
    unless_null $P123, vivify_2161
    new $P123, "Undef"
  vivify_2161:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<colonpair>" :anon :subid("502_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2810
    .param pmc param_2811
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1614
    .lex "self", param_2810
    .lex "$/", param_2811
    find_lex $P122, "$/"
    find_lex $P2812, "$/"
    unless_null $P2812, vivify_2162
    $P2812 = root_new ['parrot';'Hash']
  vivify_2162:
    set $P123, $P2812["colonpair"]
    unless_null $P123, vivify_2163
    new $P123, "Undef"
  vivify_2163:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<variable>" :anon :subid("503_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2814
    .param pmc param_2815
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1615
    .lex "self", param_2814
    .lex "$/", param_2815
    find_lex $P122, "$/"
    find_lex $P2816, "$/"
    unless_null $P2816, vivify_2164
    $P2816 = root_new ['parrot';'Hash']
  vivify_2164:
    set $P123, $P2816["variable"]
    unless_null $P123, vivify_2165
    new $P123, "Undef"
  vivify_2165:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<package_declarator>" :anon :subid("504_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2818
    .param pmc param_2819
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1616
    .lex "self", param_2818
    .lex "$/", param_2819
    find_lex $P122, "$/"
    find_lex $P2820, "$/"
    unless_null $P2820, vivify_2166
    $P2820 = root_new ['parrot';'Hash']
  vivify_2166:
    set $P123, $P2820["package_declarator"]
    unless_null $P123, vivify_2167
    new $P123, "Undef"
  vivify_2167:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<scope_declarator>" :anon :subid("505_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2822
    .param pmc param_2823
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1617
    .lex "self", param_2822
    .lex "$/", param_2823
    find_lex $P122, "$/"
    find_lex $P2824, "$/"
    unless_null $P2824, vivify_2168
    $P2824 = root_new ['parrot';'Hash']
  vivify_2168:
    set $P123, $P2824["scope_declarator"]
    unless_null $P123, vivify_2169
    new $P123, "Undef"
  vivify_2169:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<routine_declarator>" :anon :subid("506_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2826
    .param pmc param_2827
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1618
    .lex "self", param_2826
    .lex "$/", param_2827
    find_lex $P122, "$/"
    find_lex $P2828, "$/"
    unless_null $P2828, vivify_2170
    $P2828 = root_new ['parrot';'Hash']
  vivify_2170:
    set $P123, $P2828["routine_declarator"]
    unless_null $P123, vivify_2171
    new $P123, "Undef"
  vivify_2171:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<regex_declarator>" :anon :subid("507_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2830
    .param pmc param_2831
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1619
    .lex "self", param_2830
    .lex "$/", param_2831
    find_lex $P122, "$/"
    find_lex $P2832, "$/"
    unless_null $P2832, vivify_2172
    $P2832 = root_new ['parrot';'Hash']
  vivify_2172:
    set $P123, $P2832["regex_declarator"]
    unless_null $P123, vivify_2173
    new $P123, "Undef"
  vivify_2173:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<statement_prefix>" :anon :subid("508_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2834
    .param pmc param_2835
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1620
    .lex "self", param_2834
    .lex "$/", param_2835
    find_lex $P122, "$/"
    find_lex $P2836, "$/"
    unless_null $P2836, vivify_2174
    $P2836 = root_new ['parrot';'Hash']
  vivify_2174:
    set $P123, $P2836["statement_prefix"]
    unless_null $P123, vivify_2175
    new $P123, "Undef"
  vivify_2175:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<lambda>" :anon :subid("509_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2838
    .param pmc param_2839
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1621
    .lex "self", param_2838
    .lex "$/", param_2839
    find_lex $P122, "$/"
    find_lex $P2840, "$/"
    unless_null $P2840, vivify_2176
    $P2840 = root_new ['parrot';'Hash']
  vivify_2176:
    set $P123, $P2840["pblock"]
    unless_null $P123, vivify_2177
    new $P123, "Undef"
  vivify_2177:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "fatarrow" :anon :subid("510_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2842
    .param pmc param_2843
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1623
    .lex "self", param_2842
    .lex "$/", param_2843
.annotate 'line', 1624
    new $P122, "Undef"
    set $P2844, $P122
    .lex "$past", $P2844
    find_lex $P2845, "$/"
    unless_null $P2845, vivify_2178
    $P2845 = root_new ['parrot';'Hash']
  vivify_2178:
    set $P123, $P2845["val"]
    unless_null $P123, vivify_2179
    new $P123, "Undef"
  vivify_2179:
    $P124 = $P123."ast"()
    store_lex "$past", $P124
.annotate 'line', 1625
    find_lex $P123, "$past"
    unless_null $P123, vivify_2180
    new $P123, "Undef"
  vivify_2180:
    find_lex $P2846, "$/"
    unless_null $P2846, vivify_2181
    $P2846 = root_new ['parrot';'Hash']
  vivify_2181:
    set $P124, $P2846["key"]
    unless_null $P124, vivify_2182
    new $P124, "Undef"
  vivify_2182:
    $P125 = $P124."Str"()
    $P123."named"($P125)
.annotate 'line', 1626
    find_lex $P123, "$/"
    find_lex $P124, "$past"
    unless_null $P124, vivify_2183
    new $P124, "Undef"
  vivify_2183:
    $P125 = $P123."!make"($P124)
.annotate 'line', 1623
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair" :anon :subid("511_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2848
    .param pmc param_2849
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1629
    .lex "self", param_2848
    .lex "$/", param_2849
.annotate 'line', 1630
    new $P122, "Undef"
    set $P2850, $P122
    .lex "$past", $P2850
.annotate 'line', 1631
    find_lex $P2852, "$/"
    unless_null $P2852, vivify_2184
    $P2852 = root_new ['parrot';'Hash']
  vivify_2184:
    set $P124, $P2852["circumfix"]
    unless_null $P124, vivify_2185
    new $P124, "Undef"
  vivify_2185:
    if $P124, if_2851
.annotate 'line', 1632
    get_hll_global $P128, "GLOBAL"
    nqp_get_package_through_who $P129, $P128, "PAST"
    get_who $P130, $P129
    set $P131, $P130["Val"]
    find_lex $P2855, "$/"
    unless_null $P2855, vivify_2186
    $P2855 = root_new ['parrot';'Hash']
  vivify_2186:
    set $P132, $P2855["not"]
    unless_null $P132, vivify_2187
    new $P132, "Undef"
  vivify_2187:
    isfalse $I100, $P132
    $P133 = $P131."new"($I100 :named("value"))
    set $P123, $P133
.annotate 'line', 1631
    goto if_2851_end
  if_2851:
    find_lex $P2853, "$/"
    unless_null $P2853, vivify_2188
    $P2853 = root_new ['parrot';'Hash']
  vivify_2188:
    set $P2854, $P2853["circumfix"]
    unless_null $P2854, vivify_2189
    $P2854 = root_new ['parrot';'ResizablePMCArray']
  vivify_2189:
    set $P125, $P2854[0]
    unless_null $P125, vivify_2190
    new $P125, "Undef"
  vivify_2190:
    $P127 = $P125."ast"()
    set $P123, $P127
  if_2851_end:
    store_lex "$past", $P123
.annotate 'line', 1633
    find_lex $P123, "$past"
    unless_null $P123, vivify_2191
    new $P123, "Undef"
  vivify_2191:
    find_lex $P2856, "$/"
    unless_null $P2856, vivify_2192
    $P2856 = root_new ['parrot';'Hash']
  vivify_2192:
    set $P124, $P2856["identifier"]
    unless_null $P124, vivify_2193
    new $P124, "Undef"
  vivify_2193:
    set $S100, $P124
    $P123."named"($S100)
.annotate 'line', 1634
    find_lex $P123, "$/"
    find_lex $P124, "$past"
    unless_null $P124, vivify_2194
    new $P124, "Undef"
  vivify_2194:
    $P125 = $P123."!make"($P124)
.annotate 'line', 1629
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "variable" :anon :subid("512_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2858
    .param pmc param_2859
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1637
    .const 'Sub' $P2865 = "513_1310110678.31883" 
    capture_lex $P2865
    .lex "self", param_2858
    .lex "$/", param_2859
.annotate 'line', 1638
    new $P122, "Undef"
    set $P2860, $P122
    .lex "$past", $P2860
.annotate 'line', 1637
    find_lex $P123, "$past"
    unless_null $P123, vivify_2195
    new $P123, "Undef"
  vivify_2195:
.annotate 'line', 1639
    find_lex $P2862, "$/"
    unless_null $P2862, vivify_2196
    $P2862 = root_new ['parrot';'Hash']
  vivify_2196:
    set $P123, $P2862["postcircumfix"]
    unless_null $P123, vivify_2197
    new $P123, "Undef"
  vivify_2197:
    if $P123, if_2861
.annotate 'line', 1643
    .const 'Sub' $P2865 = "513_1310110678.31883" 
    capture_lex $P2865
    $P2865()
    goto if_2861_end
  if_2861:
.annotate 'line', 1640
    find_lex $P2863, "$/"
    unless_null $P2863, vivify_2254
    $P2863 = root_new ['parrot';'Hash']
  vivify_2254:
    set $P124, $P2863["postcircumfix"]
    unless_null $P124, vivify_2255
    new $P124, "Undef"
  vivify_2255:
    $P125 = $P124."ast"()
    store_lex "$past", $P125
.annotate 'line', 1641
    find_lex $P124, "$past"
    unless_null $P124, vivify_2256
    new $P124, "Undef"
  vivify_2256:
    get_hll_global $P125, "GLOBAL"
    nqp_get_package_through_who $P127, $P125, "PAST"
    get_who $P128, $P127
    set $P129, $P128["Var"]
    $P130 = $P129."new"("$/" :named("name"))
    $P124."unshift"($P130)
  if_2861_end:
.annotate 'line', 1702
    find_lex $P123, "$/"
    find_lex $P124, "$past"
    unless_null $P124, vivify_2257
    new $P124, "Undef"
  vivify_2257:
    $P125 = $P123."!make"($P124)
.annotate 'line', 1637
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2864"  :anon :subid("513_1310110678.31883") :outer("512_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1643
    .const 'Sub' $P2887 = "515_1310110678.31883" 
    capture_lex $P2887
    .const 'Sub' $P2878 = "514_1310110678.31883" 
    capture_lex $P2878
.annotate 'line', 1644
    $P2867 = root_new ['parrot';'ResizablePMCArray']
    set $P2866, $P2867
    .lex "@name", $P2866
    get_hll_global $P124, "GLOBAL"
    nqp_get_package_through_who $P125, $P124, "NQP"
    get_who $P127, $P125
    set $P128, $P127["Compiler"]
    find_lex $P129, "$/"
    unless_null $P129, vivify_2198
    new $P129, "Undef"
  vivify_2198:
    set $S100, $P129
    $P130 = $P128."parse_name"($S100)
    store_lex "@name", $P130
.annotate 'line', 1645
    find_lex $P2869, "@name"
    unless_null $P2869, vivify_2199
    $P2869 = root_new ['parrot';'ResizablePMCArray']
  vivify_2199:
    set $N100, $P2869
    isgt $I100, $N100, 1.0
    if $I100, if_2868
.annotate 'line', 1652
    find_lex $P2875, "$/"
    unless_null $P2875, vivify_2200
    $P2875 = root_new ['parrot';'Hash']
  vivify_2200:
    set $P2876, $P2875["twigil"]
    unless_null $P2876, vivify_2201
    $P2876 = root_new ['parrot';'ResizablePMCArray']
  vivify_2201:
    set $P127, $P2876[0]
    unless_null $P127, vivify_2202
    new $P127, "Undef"
  vivify_2202:
    set $S100, $P127
    iseq $I101, $S100, "*"
    if $I101, if_2874
.annotate 'line', 1663
    find_lex $P2884, "$/"
    unless_null $P2884, vivify_2203
    $P2884 = root_new ['parrot';'Hash']
  vivify_2203:
    set $P2885, $P2884["twigil"]
    unless_null $P2885, vivify_2204
    $P2885 = root_new ['parrot';'ResizablePMCArray']
  vivify_2204:
    set $P132, $P2885[0]
    unless_null $P132, vivify_2205
    new $P132, "Undef"
  vivify_2205:
    set $S101, $P132
    iseq $I102, $S101, "!"
    if $I102, if_2883
.annotate 'line', 1692
    find_lex $P2903, "@name"
    unless_null $P2903, vivify_2206
    $P2903 = root_new ['parrot';'ResizablePMCArray']
  vivify_2206:
    set $P138, $P2903[0]
    unless_null $P138, vivify_2207
    new $P138, "Undef"
  vivify_2207:
    set $S102, $P138
    $P139 = "is_package"($S102)
    if $P139, if_2902
.annotate 'line', 1697
    get_hll_global $P140, "GLOBAL"
    nqp_get_package_through_who $P141, $P140, "PAST"
    get_who $P142, $P141
    set $P144, $P142["Var"]
.annotate 'line', 1698
    find_lex $P2906, "@name"
    unless_null $P2906, vivify_2208
    $P2906 = root_new ['parrot';'ResizablePMCArray']
  vivify_2208:
    $P145 = $P2906."pop"()
    set $S103, $P145
    find_lex $P2907, "$/"
    unless_null $P2907, vivify_2209
    $P2907 = root_new ['parrot';'Hash']
  vivify_2209:
    set $P146, $P2907["sigil"]
    unless_null $P146, vivify_2210
    new $P146, "Undef"
  vivify_2210:
    $P147 = "vivitype"($P146)
.annotate 'line', 1697
    $P148 = $P144."new"($S103 :named("name"), $P147 :named("viviself"))
    store_lex "$past", $P148
.annotate 'line', 1696
    set $P137, $P148
.annotate 'line', 1692
    goto if_2902_end
  if_2902:
.annotate 'line', 1693
    find_lex $P2904, "@name"
    unless_null $P2904, vivify_2211
    $P2904 = root_new ['parrot';'ResizablePMCArray']
  vivify_2211:
    find_lex $P140, "$/"
    unless_null $P140, vivify_2212
    new $P140, "Undef"
  vivify_2212:
    $P141 = "lexical_package_lookup"($P2904, $P140)
    store_lex "$past", $P141
.annotate 'line', 1694
    find_lex $P140, "$past"
    unless_null $P140, vivify_2213
    new $P140, "Undef"
  vivify_2213:
    find_lex $P2905, "$/"
    unless_null $P2905, vivify_2214
    $P2905 = root_new ['parrot';'Hash']
  vivify_2214:
    set $P141, $P2905["sigil"]
    unless_null $P141, vivify_2215
    new $P141, "Undef"
  vivify_2215:
    $P142 = "vivitype"($P141)
    $P143 = $P140."viviself"($P142)
.annotate 'line', 1692
    set $P137, $P143
  if_2902_end:
    set $P131, $P137
.annotate 'line', 1663
    goto if_2883_end
  if_2883:
    .const 'Sub' $P2887 = "515_1310110678.31883" 
    capture_lex $P2887
    $P135 = $P2887()
    set $P131, $P135
  if_2883_end:
    set $P125, $P131
.annotate 'line', 1652
    goto if_2874_end
  if_2874:
    .const 'Sub' $P2878 = "514_1310110678.31883" 
    capture_lex $P2878
    $P130 = $P2878()
    set $P125, $P130
  if_2874_end:
    set $P124, $P125
.annotate 'line', 1645
    goto if_2868_end
  if_2868:
.annotate 'line', 1646
    find_lex $P2871, "$/"
    unless_null $P2871, vivify_2246
    $P2871 = root_new ['parrot';'Hash']
  vivify_2246:
    set $P125, $P2871["twigil"]
    unless_null $P125, vivify_2247
    new $P125, "Undef"
  vivify_2247:
    unless $P125, if_2870_end
.annotate 'line', 1647
    find_lex $P127, "$/"
    unless_null $P127, vivify_2248
    new $P127, "Undef"
  vivify_2248:
    $P128 = $P127."CURSOR"()
    $P128."panic"("Twigil not allowed on multi-part name")
  if_2870_end:
.annotate 'line', 1649
    find_lex $P2872, "@name"
    unless_null $P2872, vivify_2249
    $P2872 = root_new ['parrot';'ResizablePMCArray']
  vivify_2249:
    find_lex $P125, "$/"
    unless_null $P125, vivify_2250
    new $P125, "Undef"
  vivify_2250:
    $P127 = "lexical_package_lookup"($P2872, $P125)
    store_lex "$past", $P127
.annotate 'line', 1650
    find_lex $P125, "$past"
    unless_null $P125, vivify_2251
    new $P125, "Undef"
  vivify_2251:
    find_lex $P2873, "$/"
    unless_null $P2873, vivify_2252
    $P2873 = root_new ['parrot';'Hash']
  vivify_2252:
    set $P127, $P2873["sigil"]
    unless_null $P127, vivify_2253
    new $P127, "Undef"
  vivify_2253:
    $P128 = "vivitype"($P127)
    $P129 = $P125."viviself"($P128)
.annotate 'line', 1645
    set $P124, $P129
  if_2868_end:
.annotate 'line', 1643
    .return ($P124)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2886"  :anon :subid("515_1310110678.31883") :outer("513_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1663
    .const 'Sub' $P2893 = "516_1310110678.31883" 
    capture_lex $P2893
.annotate 'line', 1665
    new $P133, "Undef"
    set $P2888, $P133
    .lex "$name", $P2888
    find_lex $P2889, "@name"
    unless_null $P2889, vivify_2216
    $P2889 = root_new ['parrot';'ResizablePMCArray']
  vivify_2216:
    $P134 = $P2889."pop"()
    set $S102, $P134
    new $P135, 'String'
    set $P135, $S102
    store_lex "$name", $P135
.annotate 'line', 1666
    get_hll_global $P134, "GLOBAL"
    nqp_get_package_through_who $P135, $P134, "PAST"
    get_who $P137, $P135
    set $P138, $P137["Var"]
    find_lex $P139, "$name"
    unless_null $P139, vivify_2217
    new $P139, "Undef"
  vivify_2217:
.annotate 'line', 1668
    find_lex $P2890, "$/"
    unless_null $P2890, vivify_2218
    $P2890 = root_new ['parrot';'Hash']
  vivify_2218:
    set $P140, $P2890["sigil"]
    unless_null $P140, vivify_2219
    new $P140, "Undef"
  vivify_2219:
    $P141 = "vivitype"($P140)
.annotate 'line', 1669
    get_hll_global $P142, "GLOBAL"
    nqp_get_package_through_who $P143, $P142, "PAST"
    get_who $P144, $P143
    set $P145, $P144["Var"]
    $P146 = $P145."new"("self" :named("name"))
.annotate 'line', 1670
    get_hll_global $P147, "GLOBAL"
    nqp_get_package_through_who $P148, $P147, "PAST"
    get_who $P150, $P148
    set $P151, $P150["Var"]
    $P152 = $P151."new"("$?CLASS" :named("name"))
    $P153 = $P138."new"($P146, $P152, $P139 :named("name"), "attribute_6model" :named("scope"), $P141 :named("viviself"))
.annotate 'line', 1666
    store_lex "$past", $P153
.annotate 'line', 1674
    find_dynamic_lex $P138, "$*IN_DECL"
    unless_null $P138, vivify_2220
    get_hll_global $P135, "GLOBAL"
    get_who $P137, $P135
    set $P138, $P137["$IN_DECL"]
    unless_null $P138, vivify_2221
    die "Contextual $*IN_DECL not found"
  vivify_2221:
  vivify_2220:
    unless $P138, unless_2891
    set $P134, $P138
    goto unless_2891_end
  unless_2891:
    .const 'Sub' $P2893 = "516_1310110678.31883" 
    capture_lex $P2893
    $P141 = $P2893()
    set $P134, $P141
  unless_2891_end:
.annotate 'line', 1663
    .return ($P134)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2892"  :anon :subid("516_1310110678.31883") :outer("515_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1674
    .const 'Sub' $P2896 = "517_1310110678.31883" 
    capture_lex $P2896
.annotate 'line', 1675
    new $P139, "Undef"
    set $P2894, $P139
    .lex "$attr", $P2894
.annotate 'line', 1674
    find_lex $P140, "$attr"
    unless_null $P140, vivify_2222
    new $P140, "Undef"
  vivify_2222:
.annotate 'line', 1676
    find_dynamic_lex $P143, "$*PACKAGE"
    unless_null $P143, vivify_2223
    get_hll_global $P141, "GLOBAL"
    get_who $P142, $P141
    set $P143, $P142["$PACKAGE"]
    unless_null $P143, vivify_2224
    die "Contextual $*PACKAGE not found"
  vivify_2224:
  vivify_2223:
    get_how $P144, $P143
    find_dynamic_lex $P147, "$*PACKAGE"
    unless_null $P147, vivify_2225
    get_hll_global $P145, "GLOBAL"
    get_who $P146, $P145
    set $P147, $P146["$PACKAGE"]
    unless_null $P147, vivify_2226
    die "Contextual $*PACKAGE not found"
  vivify_2226:
  vivify_2225:
    $P148 = $P144."attributes"($P147, 1 :named("local"))
    defined $I103, $P148
    unless $I103, for_undef_2227
    iter $P140, $P148
    new $P152, 'ExceptionHandler'
    set_label $P152, loop2899_handler
    $P152."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P152
  loop2899_test:
    unless $P140, loop2899_done
    shift $P150, $P140
  loop2899_redo:
    .const 'Sub' $P2896 = "517_1310110678.31883" 
    capture_lex $P2896
    $P2896($P150)
  loop2899_next:
    goto loop2899_test
  loop2899_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P153, exception, 'type'
    eq $P153, .CONTROL_LOOP_NEXT, loop2899_next
    eq $P153, .CONTROL_LOOP_REDO, loop2899_redo
  loop2899_done:
    pop_eh 
  for_undef_2227:
.annotate 'line', 1682
    find_lex $P141, "$attr"
    unless_null $P141, vivify_2231
    new $P141, "Undef"
  vivify_2231:
    defined $I103, $P141
    if $I103, if_2900
.annotate 'line', 1688
    find_lex $P143, "$/"
    unless_null $P143, vivify_2232
    new $P143, "Undef"
  vivify_2232:
    $P144 = $P143."CURSOR"()
    new $P145, 'String'
    set $P145, "Attribute '"
    find_lex $P146, "$name"
    unless_null $P146, vivify_2233
    new $P146, "Undef"
  vivify_2233:
    concat $P147, $P145, $P146
    concat $P148, $P147, "' not declared"
    $P150 = $P144."panic"($P148)
.annotate 'line', 1687
    set $P140, $P150
.annotate 'line', 1682
    goto if_2900_end
  if_2900:
.annotate 'line', 1683
    find_lex $P143, "$attr"
    unless_null $P143, vivify_2234
    new $P143, "Undef"
  vivify_2234:
    can $I104, $P143, "type"
    if $I104, if_2901
    new $P142, 'Integer'
    set $P142, $I104
    goto if_2901_end
  if_2901:
.annotate 'line', 1684
    find_lex $P144, "$past"
    unless_null $P144, vivify_2235
    new $P144, "Undef"
  vivify_2235:
    find_lex $P145, "$attr"
    unless_null $P145, vivify_2236
    new $P145, "Undef"
  vivify_2236:
    $P146 = $P145."type"()
    $P147 = $P144."type"($P146)
.annotate 'line', 1683
    set $P142, $P147
  if_2901_end:
.annotate 'line', 1682
    set $P140, $P142
  if_2900_end:
.annotate 'line', 1674
    .return ($P140)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2895"  :anon :subid("517_1310110678.31883") :outer("516_1310110678.31883")
    .param pmc param_2897
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1676
    .lex "$_", param_2897
.annotate 'line', 1677
    find_lex $P152, "$_"
    unless_null $P152, vivify_2228
    new $P152, "Undef"
  vivify_2228:
    $S102 = $P152."name"()
    find_lex $P153, "$name"
    unless_null $P153, vivify_2229
    new $P153, "Undef"
  vivify_2229:
    set $S103, $P153
    iseq $I104, $S102, $S103
    if $I104, if_2898
    new $P151, 'Integer'
    set $P151, $I104
    goto if_2898_end
  if_2898:
.annotate 'line', 1678
    find_lex $P154, "$_"
    unless_null $P154, vivify_2230
    new $P154, "Undef"
  vivify_2230:
    store_lex "$attr", $P154
.annotate 'line', 1679
    die 0, .CONTROL_LOOP_LAST
  if_2898_end:
.annotate 'line', 1676
    .return ($P151)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2877"  :anon :subid("514_1310110678.31883") :outer("513_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1653
    new $P128, "Undef"
    set $P2879, $P128
    .lex "$global_fallback", $P2879
    find_lex $P2880, "$/"
    unless_null $P2880, vivify_2237
    $P2880 = root_new ['parrot';'Hash']
  vivify_2237:
    set $P130, $P2880["sigil"]
    unless_null $P130, vivify_2238
    new $P130, "Undef"
  vivify_2238:
    set $S101, $P130
    new $P131, 'String'
    set $P131, $S101
    find_lex $P2881, "$/"
    unless_null $P2881, vivify_2239
    $P2881 = root_new ['parrot';'Hash']
  vivify_2239:
    set $P132, $P2881["desigilname"]
    unless_null $P132, vivify_2240
    new $P132, "Undef"
  vivify_2240:
    concat $P133, $P131, $P132
    new $P134, "ResizablePMCArray"
    push $P134, "GLOBAL"
    push $P134, $P133
    find_lex $P135, "$/"
    unless_null $P135, vivify_2241
    new $P135, "Undef"
  vivify_2241:
    $P136 = "lexical_package_lookup"($P134, $P135)
    store_lex "$global_fallback", $P136
.annotate 'line', 1654
    find_lex $P130, "$global_fallback"
    unless_null $P130, vivify_2242
    new $P130, "Undef"
  vivify_2242:
    get_hll_global $P131, "GLOBAL"
    nqp_get_package_through_who $P132, $P131, "PAST"
    get_who $P133, $P132
    set $P134, $P133["Op"]
.annotate 'line', 1655
    new $P135, "String"
    assign $P135, "Contextual "
    find_lex $P136, "$/"
    unless_null $P136, vivify_2243
    new $P136, "Undef"
  vivify_2243:
    set $S101, $P136
    concat $P137, $P135, $S101
    concat $P138, $P137, " not found"
    $P139 = $P134."new"($P138, "die" :named("pirop"))
.annotate 'line', 1654
    $P130."viviself"($P139)
.annotate 'line', 1658
    get_hll_global $P130, "GLOBAL"
    nqp_get_package_through_who $P131, $P130, "PAST"
    get_who $P132, $P131
    set $P133, $P132["Var"]
.annotate 'line', 1659
    find_lex $P2882, "@name"
    unless_null $P2882, vivify_2244
    $P2882 = root_new ['parrot';'ResizablePMCArray']
  vivify_2244:
    $P134 = $P2882."pop"()
    set $S101, $P134
.annotate 'line', 1658
    find_lex $P135, "$global_fallback"
    unless_null $P135, vivify_2245
    new $P135, "Undef"
  vivify_2245:
    $P136 = $P133."new"($S101 :named("name"), "contextual" :named("scope"), $P135 :named("viviself"))
    store_lex "$past", $P136
.annotate 'line', 1652
    .return ($P136)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<module>" :anon :subid("518_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2909
    .param pmc param_2910
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1705
    .lex "self", param_2909
    .lex "$/", param_2910
    find_lex $P122, "$/"
    find_lex $P2911, "$/"
    unless_null $P2911, vivify_2258
    $P2911 = root_new ['parrot';'Hash']
  vivify_2258:
    set $P123, $P2911["package_def"]
    unless_null $P123, vivify_2259
    new $P123, "Undef"
  vivify_2259:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<knowhow>" :anon :subid("519_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2913
    .param pmc param_2914
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1706
    .lex "self", param_2913
    .lex "$/", param_2914
    find_lex $P122, "$/"
    find_lex $P2915, "$/"
    unless_null $P2915, vivify_2260
    $P2915 = root_new ['parrot';'Hash']
  vivify_2260:
    set $P123, $P2915["package_def"]
    unless_null $P123, vivify_2261
    new $P123, "Undef"
  vivify_2261:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<class>" :anon :subid("520_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2917
    .param pmc param_2918
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1707
    .lex "self", param_2917
    .lex "$/", param_2918
    find_lex $P122, "$/"
    find_lex $P2919, "$/"
    unless_null $P2919, vivify_2262
    $P2919 = root_new ['parrot';'Hash']
  vivify_2262:
    set $P123, $P2919["package_def"]
    unless_null $P123, vivify_2263
    new $P123, "Undef"
  vivify_2263:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<grammar>" :anon :subid("521_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2921
    .param pmc param_2922
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1708
    .lex "self", param_2921
    .lex "$/", param_2922
    find_lex $P122, "$/"
    find_lex $P2923, "$/"
    unless_null $P2923, vivify_2264
    $P2923 = root_new ['parrot';'Hash']
  vivify_2264:
    set $P123, $P2923["package_def"]
    unless_null $P123, vivify_2265
    new $P123, "Undef"
  vivify_2265:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<role>" :anon :subid("522_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2925
    .param pmc param_2926
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1709
    .lex "self", param_2925
    .lex "$/", param_2926
    find_lex $P122, "$/"
    find_lex $P2927, "$/"
    unless_null $P2927, vivify_2266
    $P2927 = root_new ['parrot';'Hash']
  vivify_2266:
    set $P123, $P2927["package_def"]
    unless_null $P123, vivify_2267
    new $P123, "Undef"
  vivify_2267:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<native>" :anon :subid("523_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2929
    .param pmc param_2930
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1710
    .lex "self", param_2929
    .lex "$/", param_2930
    find_lex $P122, "$/"
    find_lex $P2931, "$/"
    unless_null $P2931, vivify_2268
    $P2931 = root_new ['parrot';'Hash']
  vivify_2268:
    set $P123, $P2931["package_def"]
    unless_null $P123, vivify_2269
    new $P123, "Undef"
  vivify_2269:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<stub>" :anon :subid("524_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2933
    .param pmc param_2934
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1712
    .lex "self", param_2933
    .lex "$/", param_2934
.annotate 'line', 1715
    new $P122, "Undef"
    set $P2935, $P122
    .lex "$HOW", $P2935
.annotate 'line', 1716
    new $P123, "Undef"
    set $P2936, $P123
    .lex "$PACKAGE", $P2936
.annotate 'line', 1715
    find_lex $P2937, "$/"
    unless_null $P2937, vivify_2270
    $P2937 = root_new ['parrot';'Hash']
  vivify_2270:
    set $P2938, $P2937["metaclass"]
    unless_null $P2938, vivify_2271
    $P2938 = root_new ['parrot';'Hash']
  vivify_2271:
    set $P124, $P2938["identifier"]
    unless_null $P124, vivify_2272
    new $P124, "Undef"
  vivify_2272:
    find_lex $P125, "$/"
    unless_null $P125, vivify_2273
    new $P125, "Undef"
  vivify_2273:
    $P127 = "find_sym"($P124, $P125)
    store_lex "$HOW", $P127
.annotate 'line', 1716
    find_dynamic_lex $P127, "$*SC"
    unless_null $P127, vivify_2274
    get_hll_global $P124, "GLOBAL"
    get_who $P125, $P124
    set $P127, $P125["$SC"]
    unless_null $P127, vivify_2275
    die "Contextual $*SC not found"
  vivify_2275:
  vivify_2274:
    find_lex $P128, "$HOW"
    unless_null $P128, vivify_2276
    new $P128, "Undef"
  vivify_2276:
    find_lex $P2939, "$/"
    unless_null $P2939, vivify_2277
    $P2939 = root_new ['parrot';'Hash']
  vivify_2277:
    set $P129, $P2939["name"]
    unless_null $P129, vivify_2278
    new $P129, "Undef"
  vivify_2278:
    set $S100, $P129
    $P130 = $P127."pkg_create_mo"($P128, $S100 :named("name"))
    store_lex "$PACKAGE", $P130
.annotate 'line', 1719
    find_dynamic_lex $P128, "$*SCOPE"
    unless_null $P128, vivify_2279
    get_hll_global $P125, "GLOBAL"
    get_who $P127, $P125
    set $P128, $P127["$SCOPE"]
    unless_null $P128, vivify_2280
    die "Contextual $*SCOPE not found"
  vivify_2280:
  vivify_2279:
    set $S100, $P128
    iseq $I100, $S100, "our"
    unless $I100, unless_2941
    new $P124, 'Integer'
    set $P124, $I100
    goto unless_2941_end
  unless_2941:
    find_dynamic_lex $P131, "$*SCOPE"
    unless_null $P131, vivify_2281
    get_hll_global $P129, "GLOBAL"
    get_who $P130, $P129
    set $P131, $P130["$SCOPE"]
    unless_null $P131, vivify_2282
    die "Contextual $*SCOPE not found"
  vivify_2282:
  vivify_2281:
    set $S101, $P131
    iseq $I101, $S101, ""
    new $P124, 'Integer'
    set $P124, $I101
  unless_2941_end:
    if $P124, if_2940
.annotate 'line', 1725
    find_dynamic_lex $P134, "$*SCOPE"
    unless_null $P134, vivify_2283
    get_hll_global $P132, "GLOBAL"
    get_who $P133, $P132
    set $P134, $P133["$SCOPE"]
    unless_null $P134, vivify_2284
    die "Contextual $*SCOPE not found"
  vivify_2284:
  vivify_2283:
    set $S102, $P134
    iseq $I102, $S102, "my"
    if $I102, if_2951
.annotate 'line', 1732
    find_lex $P135, "$/"
    unless_null $P135, vivify_2285
    new $P135, "Undef"
  vivify_2285:
    $P136 = $P135."CURSOR"()
    find_dynamic_lex $P139, "$*SCOPE"
    unless_null $P139, vivify_2286
    get_hll_global $P137, "GLOBAL"
    get_who $P138, $P137
    set $P139, $P138["$SCOPE"]
    unless_null $P139, vivify_2287
    die "Contextual $*SCOPE not found"
  vivify_2287:
  vivify_2286:
    concat $P140, $P139, " scoped packages are not supported"
    $P136."panic"($P140)
.annotate 'line', 1731
    goto if_2951_end
  if_2951:
.annotate 'line', 1726
    find_lex $P2953, "$/"
    unless_null $P2953, vivify_2288
    $P2953 = root_new ['parrot';'Hash']
  vivify_2288:
    set $P2954, $P2953["name"]
    unless_null $P2954, vivify_2289
    $P2954 = root_new ['parrot';'Hash']
  vivify_2289:
    set $P135, $P2954["identifier"]
    unless_null $P135, vivify_2290
    new $P135, "Undef"
  vivify_2290:
    set $N100, $P135
    isne $I103, $N100, 1.0
    unless $I103, if_2952_end
.annotate 'line', 1727
    find_lex $P2955, "$/"
    unless_null $P2955, vivify_2291
    $P2955 = root_new ['parrot';'Hash']
  vivify_2291:
    set $P136, $P2955["name"]
    unless_null $P136, vivify_2292
    new $P136, "Undef"
  vivify_2292:
    $P137 = $P136."CURSOR"()
    $P137."panic"("A my scoped package cannot have a multi-part name yet")
  if_2952_end:
.annotate 'line', 1729
    find_dynamic_lex $P137, "$*SC"
    unless_null $P137, vivify_2293
    get_hll_global $P135, "GLOBAL"
    get_who $P136, $P135
    set $P137, $P136["$SC"]
    unless_null $P137, vivify_2294
    die "Contextual $*SC not found"
  vivify_2294:
  vivify_2293:
    find_lex $P138, "$?PACKAGE"
    get_who $P139, $P138
    set $P2956, $P139["@BLOCK"]
    unless_null $P2956, vivify_2295
    $P2956 = root_new ['parrot';'ResizablePMCArray']
  vivify_2295:
    set $P140, $P2956[0]
    unless_null $P140, vivify_2296
    new $P140, "Undef"
  vivify_2296:
    find_lex $P2957, "$/"
    unless_null $P2957, vivify_2297
    $P2957 = root_new ['parrot';'Hash']
  vivify_2297:
    set $P2958, $P2957["name"]
    unless_null $P2958, vivify_2298
    $P2958 = root_new ['parrot';'Hash']
  vivify_2298:
    set $P2959, $P2958["identifier"]
    unless_null $P2959, vivify_2299
    $P2959 = root_new ['parrot';'ResizablePMCArray']
  vivify_2299:
    set $P141, $P2959[0]
    unless_null $P141, vivify_2300
    new $P141, "Undef"
  vivify_2300:
    find_lex $P142, "$PACKAGE"
    unless_null $P142, vivify_2301
    new $P142, "Undef"
  vivify_2301:
    $P137."install_lexical_symbol"($P140, $P141, $P142)
  if_2951_end:
.annotate 'line', 1725
    goto if_2940_end
  if_2940:
.annotate 'line', 1720
    find_dynamic_lex $P134, "$*SC"
    unless_null $P134, vivify_2302
    get_hll_global $P132, "GLOBAL"
    get_who $P133, $P132
    set $P134, $P133["$SC"]
    unless_null $P134, vivify_2303
    die "Contextual $*SC not found"
  vivify_2303:
  vivify_2302:
    find_dynamic_lex $P137, "$*OUTERPACKAGE"
    unless_null $P137, vivify_2304
    get_hll_global $P135, "GLOBAL"
    get_who $P136, $P135
    set $P137, $P136["$OUTERPACKAGE"]
    unless_null $P137, vivify_2305
    die "Contextual $*OUTERPACKAGE not found"
  vivify_2305:
  vivify_2304:
    find_lex $P2942, "$/"
    unless_null $P2942, vivify_2306
    $P2942 = root_new ['parrot';'Hash']
  vivify_2306:
    set $P2943, $P2942["name"]
    unless_null $P2943, vivify_2307
    $P2943 = root_new ['parrot';'Hash']
  vivify_2307:
    set $P138, $P2943["identifier"]
    unless_null $P138, vivify_2308
    new $P138, "Undef"
  vivify_2308:
    find_lex $P139, "$PACKAGE"
    unless_null $P139, vivify_2309
    new $P139, "Undef"
  vivify_2309:
    $P134."install_package_symbol"($P137, $P138, $P139)
.annotate 'line', 1721
    find_lex $P2945, "$/"
    unless_null $P2945, vivify_2310
    $P2945 = root_new ['parrot';'Hash']
  vivify_2310:
    set $P2946, $P2945["name"]
    unless_null $P2946, vivify_2311
    $P2946 = root_new ['parrot';'Hash']
  vivify_2311:
    set $P132, $P2946["identifier"]
    unless_null $P132, vivify_2312
    new $P132, "Undef"
  vivify_2312:
    set $N100, $P132
    iseq $I102, $N100, 1.0
    unless $I102, if_2944_end
.annotate 'line', 1722
    find_dynamic_lex $P135, "$*SC"
    unless_null $P135, vivify_2313
    get_hll_global $P133, "GLOBAL"
    get_who $P134, $P133
    set $P135, $P134["$SC"]
    unless_null $P135, vivify_2314
    die "Contextual $*SC not found"
  vivify_2314:
  vivify_2313:
    find_lex $P136, "$?PACKAGE"
    get_who $P137, $P136
    set $P2947, $P137["@BLOCK"]
    unless_null $P2947, vivify_2315
    $P2947 = root_new ['parrot';'ResizablePMCArray']
  vivify_2315:
    set $P138, $P2947[0]
    unless_null $P138, vivify_2316
    new $P138, "Undef"
  vivify_2316:
    find_lex $P2948, "$/"
    unless_null $P2948, vivify_2317
    $P2948 = root_new ['parrot';'Hash']
  vivify_2317:
    set $P2949, $P2948["name"]
    unless_null $P2949, vivify_2318
    $P2949 = root_new ['parrot';'Hash']
  vivify_2318:
    set $P2950, $P2949["identifier"]
    unless_null $P2950, vivify_2319
    $P2950 = root_new ['parrot';'ResizablePMCArray']
  vivify_2319:
    set $P139, $P2950[0]
    unless_null $P139, vivify_2320
    new $P139, "Undef"
  vivify_2320:
    find_lex $P140, "$PACKAGE"
    unless_null $P140, vivify_2321
    new $P140, "Undef"
  vivify_2321:
    $P135."install_lexical_symbol"($P138, $P139, $P140)
  if_2944_end:
  if_2940_end:
.annotate 'line', 1735
    find_lex $P124, "$/"
    get_hll_global $P125, "GLOBAL"
    nqp_get_package_through_who $P127, $P125, "PAST"
    get_who $P128, $P127
    set $P129, $P128["Stmts"]
    $P130 = $P129."new"()
    $P131 = $P124."!make"($P130)
.annotate 'line', 1712
    .return ($P131)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "package_def" :anon :subid("525_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_2961
    .param pmc param_2962
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1738
    .const 'Sub' $P3011 = "529_1310110678.31883" 
    capture_lex $P3011
    .const 'Sub' $P3004 = "528_1310110678.31883" 
    capture_lex $P3004
    .const 'Sub' $P2984 = "526_1310110678.31883" 
    capture_lex $P2984
    .lex "self", param_2961
    .lex "$/", param_2962
.annotate 'line', 1740
    $P2964 = root_new ['parrot';'ResizablePMCArray']
    set $P2963, $P2964
    .lex "@ns", $P2963
.annotate 'line', 1741
    new $P122, "Undef"
    set $P2965, $P122
    .lex "$name", $P2965
.annotate 'line', 1742
    new $P123, "Undef"
    set $P2966, $P123
    .lex "$how", $P2966
.annotate 'line', 1745
    new $P124, "Undef"
    set $P2967, $P124
    .lex "$past", $P2967
.annotate 'line', 1740
    find_lex $P2968, "$/"
    unless_null $P2968, vivify_2322
    $P2968 = root_new ['parrot';'Hash']
  vivify_2322:
    set $P2969, $P2968["name"]
    unless_null $P2969, vivify_2323
    $P2969 = root_new ['parrot';'Hash']
  vivify_2323:
    set $P125, $P2969["identifier"]
    unless_null $P125, vivify_2324
    new $P125, "Undef"
  vivify_2324:
    clone $P127, $P125
    store_lex "@ns", $P127
.annotate 'line', 1741
    find_lex $P2970, "@ns"
    unless_null $P2970, vivify_2325
    $P2970 = root_new ['parrot';'ResizablePMCArray']
  vivify_2325:
    $P125 = $P2970."pop"()
    set $S100, $P125
    new $P127, 'String'
    set $P127, $S100
    store_lex "$name", $P127
.annotate 'line', 1742
    find_dynamic_lex $P128, "$*PKGDECL"
    unless_null $P128, vivify_2326
    get_hll_global $P125, "GLOBAL"
    get_who $P127, $P125
    set $P128, $P127["$PKGDECL"]
    unless_null $P128, vivify_2327
    die "Contextual $*PKGDECL not found"
  vivify_2327:
  vivify_2326:
    find_dynamic_lex $P131, "%*HOW"
    unless_null $P131, vivify_2328
    get_hll_global $P129, "GLOBAL"
    get_who $P130, $P129
    set $P131, $P130["%HOW"]
    unless_null $P131, vivify_2329
    die "Contextual %*HOW not found"
  vivify_2329:
  vivify_2328:
    set $P132, $P131[$P128]
    unless_null $P132, vivify_2330
    new $P132, "Undef"
  vivify_2330:
    store_lex "$how", $P132
.annotate 'line', 1745
    find_lex $P2972, "$/"
    unless_null $P2972, vivify_2331
    $P2972 = root_new ['parrot';'Hash']
  vivify_2331:
    set $P127, $P2972["block"]
    unless_null $P127, vivify_2332
    new $P127, "Undef"
  vivify_2332:
    if $P127, if_2971
    find_lex $P2974, "$/"
    unless_null $P2974, vivify_2333
    $P2974 = root_new ['parrot';'Hash']
  vivify_2333:
    set $P130, $P2974["comp_unit"]
    unless_null $P130, vivify_2334
    new $P130, "Undef"
  vivify_2334:
    $P131 = $P130."ast"()
    set $P125, $P131
    goto if_2971_end
  if_2971:
    find_lex $P2973, "$/"
    unless_null $P2973, vivify_2335
    $P2973 = root_new ['parrot';'Hash']
  vivify_2335:
    set $P128, $P2973["block"]
    unless_null $P128, vivify_2336
    new $P128, "Undef"
  vivify_2336:
    $P129 = $P128."ast"()
    set $P125, $P129
  if_2971_end:
    store_lex "$past", $P125
.annotate 'line', 1746
    find_dynamic_lex $P129, "$*SCOPE"
    unless_null $P129, vivify_2337
    get_hll_global $P127, "GLOBAL"
    get_who $P128, $P127
    set $P129, $P128["$SCOPE"]
    unless_null $P129, vivify_2338
    die "Contextual $*SCOPE not found"
  vivify_2338:
  vivify_2337:
    set $S100, $P129
    iseq $I100, $S100, "our"
    unless $I100, unless_2976
    new $P125, 'Integer'
    set $P125, $I100
    goto unless_2976_end
  unless_2976:
    find_dynamic_lex $P132, "$*SCOPE"
    unless_null $P132, vivify_2339
    get_hll_global $P130, "GLOBAL"
    get_who $P131, $P130
    set $P132, $P131["$SCOPE"]
    unless_null $P132, vivify_2340
    die "Contextual $*SCOPE not found"
  vivify_2340:
  vivify_2339:
    set $S101, $P132
    iseq $I101, $S101, ""
    new $P125, 'Integer'
    set $P125, $I101
  unless_2976_end:
    unless $P125, if_2975_end
.annotate 'line', 1747
    find_lex $P133, "$past"
    unless_null $P133, vivify_2341
    new $P133, "Undef"
  vivify_2341:
    find_lex $P2977, "$/"
    unless_null $P2977, vivify_2342
    $P2977 = root_new ['parrot';'Hash']
  vivify_2342:
    set $P2978, $P2977["name"]
    unless_null $P2978, vivify_2343
    $P2978 = root_new ['parrot';'Hash']
  vivify_2343:
    set $P134, $P2978["identifier"]
    unless_null $P134, vivify_2344
    new $P134, "Undef"
  vivify_2344:
    $P133."namespace"($P134)
  if_2975_end:
.annotate 'line', 1754
    find_lex $P127, "$how"
    unless_null $P127, vivify_2345
    new $P127, "Undef"
  vivify_2345:
    can $I100, $P127, "parametric"
    if $I100, if_2980
    new $P125, 'Integer'
    set $P125, $I100
    goto if_2980_end
  if_2980:
    find_lex $P128, "$how"
    unless_null $P128, vivify_2346
    new $P128, "Undef"
  vivify_2346:
    find_lex $P129, "$how"
    unless_null $P129, vivify_2347
    new $P129, "Undef"
  vivify_2347:
    $P130 = $P128."parametric"($P129)
    set $P125, $P130
  if_2980_end:
    if $P125, if_2979
.annotate 'line', 1763
    find_lex $P131, "$past"
    unless_null $P131, vivify_2348
    new $P131, "Undef"
  vivify_2348:
    $P131."blocktype"("immediate")
.annotate 'line', 1764
    find_dynamic_lex $P133, "$*SC"
    unless_null $P133, vivify_2349
    get_hll_global $P131, "GLOBAL"
    get_who $P132, $P131
    set $P133, $P132["$SC"]
    unless_null $P133, vivify_2350
    die "Contextual $*SC not found"
  vivify_2350:
  vivify_2349:
    find_lex $P134, "$past"
    unless_null $P134, vivify_2351
    new $P134, "Undef"
  vivify_2351:
    find_dynamic_lex $P137, "$*PACKAGE"
    unless_null $P137, vivify_2352
    get_hll_global $P135, "GLOBAL"
    get_who $P136, $P135
    set $P137, $P136["$PACKAGE"]
    unless_null $P137, vivify_2353
    die "Contextual $*PACKAGE not found"
  vivify_2353:
  vivify_2352:
    $P133."install_lexical_symbol"($P134, "$?PACKAGE", $P137)
.annotate 'line', 1765
    find_dynamic_lex $P133, "$*SC"
    unless_null $P133, vivify_2354
    get_hll_global $P131, "GLOBAL"
    get_who $P132, $P131
    set $P133, $P132["$SC"]
    unless_null $P133, vivify_2355
    die "Contextual $*SC not found"
  vivify_2355:
  vivify_2354:
    find_lex $P134, "$past"
    unless_null $P134, vivify_2356
    new $P134, "Undef"
  vivify_2356:
    find_dynamic_lex $P137, "$*PACKAGE"
    unless_null $P137, vivify_2357
    get_hll_global $P135, "GLOBAL"
    get_who $P136, $P135
    set $P137, $P136["$PACKAGE"]
    unless_null $P137, vivify_2358
    die "Contextual $*PACKAGE not found"
  vivify_2358:
  vivify_2357:
    $P133."install_lexical_symbol"($P134, "$?CLASS", $P137)
.annotate 'line', 1762
    goto if_2979_end
  if_2979:
.annotate 'line', 1755
    find_lex $P131, "$past"
    unless_null $P131, vivify_2359
    new $P131, "Undef"
  vivify_2359:
    $P131."blocktype"("declaration")
.annotate 'line', 1756
    find_lex $P131, "$past"
    unless_null $P131, vivify_2360
    new $P131, "Undef"
  vivify_2360:
    get_hll_global $P132, "GLOBAL"
    nqp_get_package_through_who $P133, $P132, "PAST"
    get_who $P134, $P133
    set $P135, $P134["Var"]
    $P136 = $P135."new"("$?CLASS" :named("name"), "parameter" :named("scope"))
    $P131."unshift"($P136)
.annotate 'line', 1757
    find_lex $P131, "$past"
    unless_null $P131, vivify_2361
    new $P131, "Undef"
  vivify_2361:
    $P131."symbol"("$?CLASS", "lexical" :named("scope"))
.annotate 'line', 1758
    find_dynamic_lex $P133, "$*SC"
    unless_null $P133, vivify_2362
    get_hll_global $P131, "GLOBAL"
    get_who $P132, $P131
    set $P133, $P132["$SC"]
    unless_null $P133, vivify_2363
    die "Contextual $*SC not found"
  vivify_2363:
  vivify_2362:
    find_dynamic_lex $P136, "$*PACKAGE"
    unless_null $P136, vivify_2364
    get_hll_global $P134, "GLOBAL"
    get_who $P135, $P134
    set $P136, $P135["$PACKAGE"]
    unless_null $P136, vivify_2365
    die "Contextual $*PACKAGE not found"
  vivify_2365:
  vivify_2364:
    find_lex $P137, "$past"
    unless_null $P137, vivify_2366
    new $P137, "Undef"
  vivify_2366:
    $P133."pkg_set_body_block"($P136, $P137)
.annotate 'line', 1759
    find_dynamic_lex $P133, "$*SC"
    unless_null $P133, vivify_2367
    get_hll_global $P131, "GLOBAL"
    get_who $P132, $P131
    set $P133, $P132["$SC"]
    unless_null $P133, vivify_2368
    die "Contextual $*SC not found"
  vivify_2368:
  vivify_2367:
    find_lex $P134, "$past"
    unless_null $P134, vivify_2369
    new $P134, "Undef"
  vivify_2369:
    find_dynamic_lex $P137, "$*PACKAGE"
    unless_null $P137, vivify_2370
    get_hll_global $P135, "GLOBAL"
    get_who $P136, $P135
    set $P137, $P136["$PACKAGE"]
    unless_null $P137, vivify_2371
    die "Contextual $*PACKAGE not found"
  vivify_2371:
  vivify_2370:
    $P133."install_lexical_symbol"($P134, "$?PACKAGE", $P137)
.annotate 'line', 1760
    find_dynamic_lex $P133, "$*SC"
    unless_null $P133, vivify_2372
    get_hll_global $P131, "GLOBAL"
    get_who $P132, $P131
    set $P133, $P132["$SC"]
    unless_null $P133, vivify_2373
    die "Contextual $*SC not found"
  vivify_2373:
  vivify_2372:
    find_lex $P134, "$past"
    unless_null $P134, vivify_2374
    new $P134, "Undef"
  vivify_2374:
    find_dynamic_lex $P137, "$*PACKAGE"
    unless_null $P137, vivify_2375
    get_hll_global $P135, "GLOBAL"
    get_who $P136, $P135
    set $P137, $P136["$PACKAGE"]
    unless_null $P137, vivify_2376
    die "Contextual $*PACKAGE not found"
  vivify_2376:
  vivify_2375:
    $P133."install_lexical_symbol"($P134, "$?ROLE", $P137)
  if_2979_end:
.annotate 'line', 1769
    find_lex $P2982, "$/"
    unless_null $P2982, vivify_2377
    $P2982 = root_new ['parrot';'Hash']
  vivify_2377:
    set $P125, $P2982["parent"]
    unless_null $P125, vivify_2378
    new $P125, "Undef"
  vivify_2378:
    if $P125, if_2981
.annotate 'line', 1783
    find_lex $P130, "$how"
    unless_null $P130, vivify_2379
    new $P130, "Undef"
  vivify_2379:
    can $I100, $P130, "set_default_parent"
    unless $I100, if_3002_end
    .const 'Sub' $P3004 = "528_1310110678.31883" 
    capture_lex $P3004
    $P3004()
  if_3002_end:
    goto if_2981_end
  if_2981:
.annotate 'line', 1769
    .const 'Sub' $P2984 = "526_1310110678.31883" 
    capture_lex $P2984
    $P2984()
  if_2981_end:
.annotate 'line', 1790
    find_lex $P3008, "$/"
    unless_null $P3008, vivify_2405
    $P3008 = root_new ['parrot';'Hash']
  vivify_2405:
    set $P125, $P3008["role"]
    unless_null $P125, vivify_2406
    new $P125, "Undef"
  vivify_2406:
    unless $P125, if_3007_end
.annotate 'line', 1791
    find_lex $P3009, "$/"
    unless_null $P3009, vivify_2407
    $P3009 = root_new ['parrot';'Hash']
  vivify_2407:
    set $P128, $P3009["role"]
    unless_null $P128, vivify_2408
    new $P128, "Undef"
  vivify_2408:
    defined $I100, $P128
    unless $I100, for_undef_2409
    iter $P127, $P128
    new $P133, 'ExceptionHandler'
    set_label $P133, loop3026_handler
    $P133."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P133
  loop3026_test:
    unless $P127, loop3026_done
    shift $P129, $P127
  loop3026_redo:
    .const 'Sub' $P3011 = "529_1310110678.31883" 
    capture_lex $P3011
    $P3011($P129)
  loop3026_next:
    goto loop3026_test
  loop3026_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P134, exception, 'type'
    eq $P134, .CONTROL_LOOP_NEXT, loop3026_next
    eq $P134, .CONTROL_LOOP_REDO, loop3026_redo
  loop3026_done:
    pop_eh 
  for_undef_2409:
  if_3007_end:
.annotate 'line', 1808
    find_dynamic_lex $P128, "$*SC"
    unless_null $P128, vivify_2423
    get_hll_global $P125, "GLOBAL"
    get_who $P127, $P125
    set $P128, $P127["$SC"]
    unless_null $P128, vivify_2424
    die "Contextual $*SC not found"
  vivify_2424:
  vivify_2423:
    find_dynamic_lex $P131, "$*PACKAGE"
    unless_null $P131, vivify_2425
    get_hll_global $P129, "GLOBAL"
    get_who $P130, $P129
    set $P131, $P130["$PACKAGE"]
    unless_null $P131, vivify_2426
    die "Contextual $*PACKAGE not found"
  vivify_2426:
  vivify_2425:
    $P128."pkg_compose"($P131)
.annotate 'line', 1810
    find_lex $P125, "$/"
    find_lex $P127, "$past"
    unless_null $P127, vivify_2427
    new $P127, "Undef"
  vivify_2427:
    $P128 = $P125."!make"($P127)
.annotate 'line', 1738
    .return ($P128)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3003"  :anon :subid("528_1310110678.31883") :outer("525_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1784
    new $P131, "Undef"
    set $P3005, $P131
    .lex "$default", $P3005
    find_dynamic_lex $P135, "$*PKGDECL"
    unless_null $P135, vivify_2380
    get_hll_global $P133, "GLOBAL"
    get_who $P134, $P133
    set $P135, $P134["$PKGDECL"]
    unless_null $P135, vivify_2381
    die "Contextual $*PKGDECL not found"
  vivify_2381:
  vivify_2380:
    set $S100, $P135
    iseq $I101, $S100, "grammar"
    if $I101, if_3006
    new $P137, "ResizablePMCArray"
    push $P137, "NQPMu"
    set $P132, $P137
    goto if_3006_end
  if_3006:
    new $P136, "ResizablePMCArray"
    push $P136, "Regex"
    push $P136, "Cursor"
    set $P132, $P136
  if_3006_end:
    store_lex "$default", $P132
.annotate 'line', 1785
    find_dynamic_lex $P134, "$*SC"
    unless_null $P134, vivify_2382
    get_hll_global $P132, "GLOBAL"
    get_who $P133, $P132
    set $P134, $P133["$SC"]
    unless_null $P134, vivify_2383
    die "Contextual $*SC not found"
  vivify_2383:
  vivify_2382:
    find_dynamic_lex $P137, "$*PACKAGE"
    unless_null $P137, vivify_2384
    get_hll_global $P135, "GLOBAL"
    get_who $P136, $P135
    set $P137, $P136["$PACKAGE"]
    unless_null $P137, vivify_2385
    die "Contextual $*PACKAGE not found"
  vivify_2385:
  vivify_2384:
.annotate 'line', 1786
    find_lex $P138, "$default"
    unless_null $P138, vivify_2386
    new $P138, "Undef"
  vivify_2386:
    find_lex $P139, "$/"
    unless_null $P139, vivify_2387
    new $P139, "Undef"
  vivify_2387:
    $P140 = "find_sym"($P138, $P139)
    $P141 = $P134."pkg_add_parent_or_role"($P137, "set_default_parent", $P140)
.annotate 'line', 1783
    .return ($P141)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2983"  :anon :subid("526_1310110678.31883") :outer("525_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1769
    .const 'Sub' $P2988 = "527_1310110678.31883" 
    capture_lex $P2988
.annotate 'line', 1770
    new $P127, "Undef"
    set $P2985, $P127
    .lex "$parent", $P2985
.annotate 'line', 1771
    new $P128, "Undef"
    set $P2986, $P128
    .lex "$parent_found", $P2986
.annotate 'line', 1769
    find_lex $P129, "$parent"
    unless_null $P129, vivify_2388
    new $P129, "Undef"
  vivify_2388:
    find_lex $P129, "$parent_found"
    unless_null $P129, vivify_2389
    new $P129, "Undef"
  vivify_2389:
.annotate 'line', 1772
    .const 'Sub' $P2988 = "527_1310110678.31883" 
    capture_lex $P2988
    $P2988()
.annotate 'line', 1776
    find_lex $P130, "$parent_found"
    unless_null $P130, vivify_2395
    new $P130, "Undef"
  vivify_2395:
    if $P130, if_2999
.annotate 'line', 1780
    find_lex $P131, "$/"
    unless_null $P131, vivify_2396
    new $P131, "Undef"
  vivify_2396:
    $P132 = $P131."CURSOR"()
    new $P133, "String"
    assign $P133, "Could not find parent class '"
    find_lex $P3000, "$/"
    unless_null $P3000, vivify_2397
    $P3000 = root_new ['parrot';'Hash']
  vivify_2397:
    set $P3001, $P3000["parent"]
    unless_null $P3001, vivify_2398
    $P3001 = root_new ['parrot';'ResizablePMCArray']
  vivify_2398:
    set $P134, $P3001[0]
    unless_null $P134, vivify_2399
    new $P134, "Undef"
  vivify_2399:
    set $S100, $P134
    concat $P135, $P133, $S100
    concat $P136, $P135, "'"
    $P137 = $P132."panic"($P136)
.annotate 'line', 1779
    set $P129, $P137
.annotate 'line', 1776
    goto if_2999_end
  if_2999:
.annotate 'line', 1777
    find_dynamic_lex $P133, "$*SC"
    unless_null $P133, vivify_2400
    get_hll_global $P131, "GLOBAL"
    get_who $P132, $P131
    set $P133, $P132["$SC"]
    unless_null $P133, vivify_2401
    die "Contextual $*SC not found"
  vivify_2401:
  vivify_2400:
    find_dynamic_lex $P136, "$*PACKAGE"
    unless_null $P136, vivify_2402
    get_hll_global $P134, "GLOBAL"
    get_who $P135, $P134
    set $P136, $P135["$PACKAGE"]
    unless_null $P136, vivify_2403
    die "Contextual $*PACKAGE not found"
  vivify_2403:
  vivify_2402:
    find_lex $P137, "$parent"
    unless_null $P137, vivify_2404
    new $P137, "Undef"
  vivify_2404:
    $P138 = $P133."pkg_add_parent_or_role"($P136, "add_parent", $P137)
.annotate 'line', 1776
    set $P129, $P138
  if_2999_end:
.annotate 'line', 1769
    .return ($P129)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2987"  :anon :subid("527_1310110678.31883") :outer("526_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1772
    new $P2994, 'ExceptionHandler'
    set_label $P2994, control_2993
    $P2994."handle_types_except"(.CONTROL_RETURN,  .CONTROL_OK,  .CONTROL_BREAK,  .CONTROL_CONTINUE,  .CONTROL_TAKE,  .CONTROL_LEAVE,  .CONTROL_EXIT,  .CONTROL_LOOP_NEXT,  .CONTROL_LOOP_LAST,  .CONTROL_LOOP_REDO)
    push_eh $P2994
.annotate 'line', 1773
    find_lex $P2989, "$/"
    unless_null $P2989, vivify_2390
    $P2989 = root_new ['parrot';'Hash']
  vivify_2390:
    set $P2990, $P2989["parent"]
    unless_null $P2990, vivify_2391
    $P2990 = root_new ['parrot';'ResizablePMCArray']
  vivify_2391:
    set $P2991, $P2990[0]
    unless_null $P2991, vivify_2392
    $P2991 = root_new ['parrot';'Hash']
  vivify_2392:
    set $P129, $P2991["identifier"]
    unless_null $P129, vivify_2393
    new $P129, "Undef"
  vivify_2393:
    clone $P130, $P129
    find_lex $P131, "$/"
    unless_null $P131, vivify_2394
    new $P131, "Undef"
  vivify_2394:
    $P132 = "find_sym"($P130, $P131)
    store_lex "$parent", $P132
.annotate 'line', 1774
    new $P129, "Integer"
    assign $P129, 1
    store_lex "$parent_found", $P129
.annotate 'line', 1772
    pop_eh 
    goto skip_handler_2992
  control_2993:
    .local pmc exception 
    .get_results (exception) 
    new $P2997, 'Integer'
    set $P2997, 1
    set exception["handled"], $P2997
    set $I2998, exception["handled"]
    ne $I2998, 1, nothandled_2996
  handled_2995:
    .return (exception)
  nothandled_2996:
    rethrow exception
  skip_handler_2992:
    .return ($P129)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3010"  :anon :subid("529_1310110678.31883") :outer("525_1310110678.31883")
    .param pmc param_3014
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1791
    .const 'Sub' $P3016 = "530_1310110678.31883" 
    capture_lex $P3016
.annotate 'line', 1792
    new $P130, "Undef"
    set $P3012, $P130
    .lex "$role", $P3012
.annotate 'line', 1793
    new $P131, "Undef"
    set $P3013, $P131
    .lex "$role_found", $P3013
    .lex "$_", param_3014
.annotate 'line', 1791
    find_lex $P132, "$role"
    unless_null $P132, vivify_2410
    new $P132, "Undef"
  vivify_2410:
    find_lex $P132, "$role_found"
    unless_null $P132, vivify_2411
    new $P132, "Undef"
  vivify_2411:
.annotate 'line', 1794
    .const 'Sub' $P3016 = "530_1310110678.31883" 
    capture_lex $P3016
    $P3016()
.annotate 'line', 1798
    find_lex $P133, "$role_found"
    unless_null $P133, vivify_2415
    new $P133, "Undef"
  vivify_2415:
    if $P133, if_3025
.annotate 'line', 1802
    find_lex $P134, "$/"
    unless_null $P134, vivify_2416
    new $P134, "Undef"
  vivify_2416:
    $P135 = $P134."CURSOR"()
    new $P136, "String"
    assign $P136, "Could not find role '"
    find_lex $P137, "$_"
    unless_null $P137, vivify_2417
    new $P137, "Undef"
  vivify_2417:
    set $S100, $P137
    concat $P138, $P136, $S100
    concat $P139, $P138, "'"
    $P140 = $P135."panic"($P139)
.annotate 'line', 1801
    set $P132, $P140
.annotate 'line', 1798
    goto if_3025_end
  if_3025:
.annotate 'line', 1799
    find_dynamic_lex $P136, "$*SC"
    unless_null $P136, vivify_2418
    get_hll_global $P134, "GLOBAL"
    get_who $P135, $P134
    set $P136, $P135["$SC"]
    unless_null $P136, vivify_2419
    die "Contextual $*SC not found"
  vivify_2419:
  vivify_2418:
    find_dynamic_lex $P139, "$*PACKAGE"
    unless_null $P139, vivify_2420
    get_hll_global $P137, "GLOBAL"
    get_who $P138, $P137
    set $P139, $P138["$PACKAGE"]
    unless_null $P139, vivify_2421
    die "Contextual $*PACKAGE not found"
  vivify_2421:
  vivify_2420:
    find_lex $P140, "$role"
    unless_null $P140, vivify_2422
    new $P140, "Undef"
  vivify_2422:
    $P141 = $P136."pkg_add_parent_or_role"($P139, "add_role", $P140)
.annotate 'line', 1798
    set $P132, $P141
  if_3025_end:
.annotate 'line', 1791
    .return ($P132)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3015"  :anon :subid("530_1310110678.31883") :outer("529_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1794
    new $P3020, 'ExceptionHandler'
    set_label $P3020, control_3019
    $P3020."handle_types_except"(.CONTROL_RETURN,  .CONTROL_OK,  .CONTROL_BREAK,  .CONTROL_CONTINUE,  .CONTROL_TAKE,  .CONTROL_LEAVE,  .CONTROL_EXIT,  .CONTROL_LOOP_NEXT,  .CONTROL_LOOP_LAST,  .CONTROL_LOOP_REDO)
    push_eh $P3020
.annotate 'line', 1795
    find_lex $P3017, "$_"
    unless_null $P3017, vivify_2412
    $P3017 = root_new ['parrot';'Hash']
  vivify_2412:
    set $P132, $P3017["identifier"]
    unless_null $P132, vivify_2413
    new $P132, "Undef"
  vivify_2413:
    clone $P133, $P132
    find_lex $P134, "$/"
    unless_null $P134, vivify_2414
    new $P134, "Undef"
  vivify_2414:
    $P135 = "find_sym"($P133, $P134)
    store_lex "$role", $P135
.annotate 'line', 1796
    new $P132, "Integer"
    assign $P132, 1
    store_lex "$role_found", $P132
.annotate 'line', 1794
    pop_eh 
    goto skip_handler_3018
  control_3019:
    .local pmc exception 
    .get_results (exception) 
    new $P3023, 'Integer'
    set $P3023, 1
    set exception["handled"], $P3023
    set $I3024, exception["handled"]
    ne $I3024, 1, nothandled_3022
  handled_3021:
    .return (exception)
  nothandled_3022:
    rethrow exception
  skip_handler_3018:
    .return ($P132)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<my>" :anon :subid("531_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3028
    .param pmc param_3029
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1813
    .lex "self", param_3028
    .lex "$/", param_3029
    find_lex $P122, "$/"
    find_lex $P3030, "$/"
    unless_null $P3030, vivify_2428
    $P3030 = root_new ['parrot';'Hash']
  vivify_2428:
    set $P123, $P3030["scoped"]
    unless_null $P123, vivify_2429
    new $P123, "Undef"
  vivify_2429:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<our>" :anon :subid("532_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3032
    .param pmc param_3033
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1814
    .lex "self", param_3032
    .lex "$/", param_3033
    find_lex $P122, "$/"
    find_lex $P3034, "$/"
    unless_null $P3034, vivify_2430
    $P3034 = root_new ['parrot';'Hash']
  vivify_2430:
    set $P123, $P3034["scoped"]
    unless_null $P123, vivify_2431
    new $P123, "Undef"
  vivify_2431:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<has>" :anon :subid("533_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3036
    .param pmc param_3037
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1815
    .lex "self", param_3036
    .lex "$/", param_3037
    find_lex $P122, "$/"
    find_lex $P3038, "$/"
    unless_null $P3038, vivify_2432
    $P3038 = root_new ['parrot';'Hash']
  vivify_2432:
    set $P123, $P3038["scoped"]
    unless_null $P123, vivify_2433
    new $P123, "Undef"
  vivify_2433:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scoped" :anon :subid("534_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3040
    .param pmc param_3041
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1817
    .lex "self", param_3040
    .lex "$/", param_3041
.annotate 'line', 1818
    find_lex $P122, "$/"
    find_lex $P3043, "$/"
    unless_null $P3043, vivify_2434
    $P3043 = root_new ['parrot';'Hash']
  vivify_2434:
    set $P124, $P3043["declarator"]
    unless_null $P124, vivify_2435
    new $P124, "Undef"
  vivify_2435:
    if $P124, if_3042
.annotate 'line', 1819
    find_lex $P3046, "$/"
    unless_null $P3046, vivify_2436
    $P3046 = root_new ['parrot';'Hash']
  vivify_2436:
    set $P129, $P3046["multi_declarator"]
    unless_null $P129, vivify_2437
    new $P129, "Undef"
  vivify_2437:
    if $P129, if_3045
.annotate 'line', 1820
    find_lex $P3048, "$/"
    unless_null $P3048, vivify_2438
    $P3048 = root_new ['parrot';'Hash']
  vivify_2438:
    set $P132, $P3048["package_declarator"]
    unless_null $P132, vivify_2439
    new $P132, "Undef"
  vivify_2439:
    $P133 = $P132."ast"()
    set $P128, $P133
.annotate 'line', 1819
    goto if_3045_end
  if_3045:
    find_lex $P3047, "$/"
    unless_null $P3047, vivify_2440
    $P3047 = root_new ['parrot';'Hash']
  vivify_2440:
    set $P130, $P3047["multi_declarator"]
    unless_null $P130, vivify_2441
    new $P130, "Undef"
  vivify_2441:
    $P131 = $P130."ast"()
    set $P128, $P131
  if_3045_end:
    set $P123, $P128
.annotate 'line', 1818
    goto if_3042_end
  if_3042:
    find_lex $P3044, "$/"
    unless_null $P3044, vivify_2442
    $P3044 = root_new ['parrot';'Hash']
  vivify_2442:
    set $P125, $P3044["declarator"]
    unless_null $P125, vivify_2443
    new $P125, "Undef"
  vivify_2443:
    $P127 = $P125."ast"()
    set $P123, $P127
  if_3042_end:
    $P134 = $P122."!make"($P123)
.annotate 'line', 1817
    .return ($P134)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "declarator" :anon :subid("535_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3050
    .param pmc param_3051
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1823
    .lex "self", param_3050
    .lex "$/", param_3051
.annotate 'line', 1824
    find_lex $P122, "$/"
.annotate 'line', 1825
    find_lex $P3053, "$/"
    unless_null $P3053, vivify_2444
    $P3053 = root_new ['parrot';'Hash']
  vivify_2444:
    set $P124, $P3053["routine_declarator"]
    unless_null $P124, vivify_2445
    new $P124, "Undef"
  vivify_2445:
    if $P124, if_3052
.annotate 'line', 1826
    find_lex $P3055, "$/"
    unless_null $P3055, vivify_2446
    $P3055 = root_new ['parrot';'Hash']
  vivify_2446:
    set $P128, $P3055["variable_declarator"]
    unless_null $P128, vivify_2447
    new $P128, "Undef"
  vivify_2447:
    $P129 = $P128."ast"()
    set $P123, $P129
.annotate 'line', 1825
    goto if_3052_end
  if_3052:
    find_lex $P3054, "$/"
    unless_null $P3054, vivify_2448
    $P3054 = root_new ['parrot';'Hash']
  vivify_2448:
    set $P125, $P3054["routine_declarator"]
    unless_null $P125, vivify_2449
    new $P125, "Undef"
  vivify_2449:
    $P127 = $P125."ast"()
    set $P123, $P127
  if_3052_end:
    $P130 = $P122."!make"($P123)
.annotate 'line', 1823
    .return ($P130)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<multi>" :anon :subid("536_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3057
    .param pmc param_3058
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1829
    .lex "self", param_3057
    .lex "$/", param_3058
    find_lex $P122, "$/"
    find_lex $P3060, "$/"
    unless_null $P3060, vivify_2450
    $P3060 = root_new ['parrot';'Hash']
  vivify_2450:
    set $P124, $P3060["declarator"]
    unless_null $P124, vivify_2451
    new $P124, "Undef"
  vivify_2451:
    if $P124, if_3059
    find_lex $P3062, "$/"
    unless_null $P3062, vivify_2452
    $P3062 = root_new ['parrot';'Hash']
  vivify_2452:
    set $P128, $P3062["routine_def"]
    unless_null $P128, vivify_2453
    new $P128, "Undef"
  vivify_2453:
    $P129 = $P128."ast"()
    set $P123, $P129
    goto if_3059_end
  if_3059:
    find_lex $P3061, "$/"
    unless_null $P3061, vivify_2454
    $P3061 = root_new ['parrot';'Hash']
  vivify_2454:
    set $P125, $P3061["declarator"]
    unless_null $P125, vivify_2455
    new $P125, "Undef"
  vivify_2455:
    $P127 = $P125."ast"()
    set $P123, $P127
  if_3059_end:
    $P130 = $P122."!make"($P123)
    .return ($P130)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<proto>" :anon :subid("537_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3064
    .param pmc param_3065
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1830
    .lex "self", param_3064
    .lex "$/", param_3065
    find_lex $P122, "$/"
    find_lex $P3067, "$/"
    unless_null $P3067, vivify_2456
    $P3067 = root_new ['parrot';'Hash']
  vivify_2456:
    set $P124, $P3067["declarator"]
    unless_null $P124, vivify_2457
    new $P124, "Undef"
  vivify_2457:
    if $P124, if_3066
    find_lex $P3069, "$/"
    unless_null $P3069, vivify_2458
    $P3069 = root_new ['parrot';'Hash']
  vivify_2458:
    set $P128, $P3069["routine_def"]
    unless_null $P128, vivify_2459
    new $P128, "Undef"
  vivify_2459:
    $P129 = $P128."ast"()
    set $P123, $P129
    goto if_3066_end
  if_3066:
    find_lex $P3068, "$/"
    unless_null $P3068, vivify_2460
    $P3068 = root_new ['parrot';'Hash']
  vivify_2460:
    set $P125, $P3068["declarator"]
    unless_null $P125, vivify_2461
    new $P125, "Undef"
  vivify_2461:
    $P127 = $P125."ast"()
    set $P123, $P127
  if_3066_end:
    $P130 = $P122."!make"($P123)
    .return ($P130)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<null>" :anon :subid("538_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3071
    .param pmc param_3072
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1831
    .lex "self", param_3071
    .lex "$/", param_3072
    find_lex $P122, "$/"
    find_lex $P3073, "$/"
    unless_null $P3073, vivify_2462
    $P3073 = root_new ['parrot';'Hash']
  vivify_2462:
    set $P123, $P3073["declarator"]
    unless_null $P123, vivify_2463
    new $P123, "Undef"
  vivify_2463:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "variable_declarator" :anon :subid("539_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3075
    .param pmc param_3076
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1834
    .const 'Sub' $P3112 = "541_1310110678.31883" 
    capture_lex $P3112
    .const 'Sub' $P3089 = "540_1310110678.31883" 
    capture_lex $P3089
    .lex "self", param_3075
    .lex "$/", param_3076
.annotate 'line', 1835
    new $P122, "Undef"
    set $P3077, $P122
    .lex "$past", $P3077
.annotate 'line', 1836
    new $P123, "Undef"
    set $P3078, $P123
    .lex "$sigil", $P3078
.annotate 'line', 1837
    new $P124, "Undef"
    set $P3079, $P124
    .lex "$name", $P3079
.annotate 'line', 1838
    new $P125, "Undef"
    set $P3080, $P125
    .lex "$BLOCK", $P3080
.annotate 'line', 1835
    find_lex $P3081, "$/"
    unless_null $P3081, vivify_2464
    $P3081 = root_new ['parrot';'Hash']
  vivify_2464:
    set $P127, $P3081["variable"]
    unless_null $P127, vivify_2465
    new $P127, "Undef"
  vivify_2465:
    $P128 = $P127."ast"()
    store_lex "$past", $P128
.annotate 'line', 1836
    find_lex $P3082, "$/"
    unless_null $P3082, vivify_2466
    $P3082 = root_new ['parrot';'Hash']
  vivify_2466:
    set $P3083, $P3082["variable"]
    unless_null $P3083, vivify_2467
    $P3083 = root_new ['parrot';'Hash']
  vivify_2467:
    set $P127, $P3083["sigil"]
    unless_null $P127, vivify_2468
    new $P127, "Undef"
  vivify_2468:
    store_lex "$sigil", $P127
.annotate 'line', 1837
    find_lex $P127, "$past"
    unless_null $P127, vivify_2469
    new $P127, "Undef"
  vivify_2469:
    $P128 = $P127."name"()
    store_lex "$name", $P128
.annotate 'line', 1838
    find_lex $P127, "$?PACKAGE"
    get_who $P128, $P127
    set $P3084, $P128["@BLOCK"]
    unless_null $P3084, vivify_2470
    $P3084 = root_new ['parrot';'ResizablePMCArray']
  vivify_2470:
    set $P129, $P3084[0]
    unless_null $P129, vivify_2471
    new $P129, "Undef"
  vivify_2471:
    store_lex "$BLOCK", $P129
.annotate 'line', 1839
    find_lex $P128, "$name"
    unless_null $P128, vivify_2472
    new $P128, "Undef"
  vivify_2472:
    if $P128, if_3086
    set $P127, $P128
    goto if_3086_end
  if_3086:
    find_lex $P129, "$BLOCK"
    unless_null $P129, vivify_2473
    new $P129, "Undef"
  vivify_2473:
    find_lex $P130, "$name"
    unless_null $P130, vivify_2474
    new $P130, "Undef"
  vivify_2474:
    $P131 = $P129."symbol"($P130)
    set $P127, $P131
  if_3086_end:
    unless $P127, if_3085_end
.annotate 'line', 1840
    find_lex $P132, "$/"
    unless_null $P132, vivify_2475
    new $P132, "Undef"
  vivify_2475:
    $P133 = $P132."CURSOR"()
    find_lex $P134, "$name"
    unless_null $P134, vivify_2476
    new $P134, "Undef"
  vivify_2476:
    $P133."panic"("Redeclaration of symbol ", $P134)
  if_3085_end:
.annotate 'line', 1842
    find_dynamic_lex $P129, "$*SCOPE"
    unless_null $P129, vivify_2477
    get_hll_global $P127, "GLOBAL"
    get_who $P128, $P127
    set $P129, $P128["$SCOPE"]
    unless_null $P129, vivify_2478
    die "Contextual $*SCOPE not found"
  vivify_2478:
  vivify_2477:
    set $S100, $P129
    iseq $I100, $S100, "has"
    if $I100, if_3087
.annotate 'line', 1862
    find_dynamic_lex $P132, "$*SCOPE"
    unless_null $P132, vivify_2479
    get_hll_global $P130, "GLOBAL"
    get_who $P131, $P130
    set $P132, $P131["$SCOPE"]
    unless_null $P132, vivify_2480
    die "Contextual $*SCOPE not found"
  vivify_2480:
  vivify_2479:
    set $S101, $P132
    iseq $I101, $S101, "our"
    if $I101, if_3105
.annotate 'line', 1872
    find_lex $P3107, "$BLOCK"
    unless_null $P3107, vivify_2481
    $P3107 = root_new ['parrot';'ResizablePMCArray']
  vivify_2481:
    set $P133, $P3107[0]
    unless_null $P133, vivify_2482
    new $P133, "Undef"
  vivify_2482:
    get_hll_global $P135, "GLOBAL"
    nqp_get_package_through_who $P136, $P135, "PAST"
    get_who $P137, $P136
    set $P138, $P137["Var"]
    find_lex $P139, "$name"
    unless_null $P139, vivify_2483
    new $P139, "Undef"
  vivify_2483:
.annotate 'line', 1874
    find_lex $P140, "$sigil"
    unless_null $P140, vivify_2484
    new $P140, "Undef"
  vivify_2484:
    $P141 = "vivitype"($P140)
.annotate 'line', 1872
    find_lex $P142, "$/"
    unless_null $P142, vivify_2485
    new $P142, "Undef"
  vivify_2485:
    $P143 = $P138."new"($P139 :named("name"), "lexical" :named("scope"), 1 :named("isdecl"), 1 :named("lvalue"), $P141 :named("viviself"), $P142 :named("node"))
    $P133."push"($P143)
.annotate 'line', 1877
    find_lex $P133, "$BLOCK"
    unless_null $P133, vivify_2486
    new $P133, "Undef"
  vivify_2486:
    find_lex $P135, "$name"
    unless_null $P135, vivify_2487
    new $P135, "Undef"
  vivify_2487:
    $P133."symbol"($P135, "lexical" :named("scope"))
.annotate 'line', 1871
    goto if_3105_end
  if_3105:
.annotate 'line', 1866
    find_lex $P3106, "$/"
    unless_null $P3106, vivify_2488
    $P3106 = root_new ['parrot';'Hash']
  vivify_2488:
    set $P133, $P3106["variable"]
    unless_null $P133, vivify_2489
    new $P133, "Undef"
  vivify_2489:
    set $S102, $P133
    new $P135, 'String'
    set $P135, $S102
    store_lex "$name", $P135
.annotate 'line', 1867
    find_lex $P133, "$name"
    unless_null $P133, vivify_2490
    new $P133, "Undef"
  vivify_2490:
    new $P135, "ResizablePMCArray"
    push $P135, $P133
    find_lex $P136, "$/"
    unless_null $P136, vivify_2491
    new $P136, "Undef"
  vivify_2491:
    $P137 = "lexical_package_lookup"($P135, $P136)
    store_lex "$past", $P137
.annotate 'line', 1868
    find_lex $P133, "$past"
    unless_null $P133, vivify_2492
    new $P133, "Undef"
  vivify_2492:
    find_lex $P135, "$sigil"
    unless_null $P135, vivify_2493
    new $P135, "Undef"
  vivify_2493:
    $P136 = "vivitype"($P135)
    $P133."viviself"($P136)
.annotate 'line', 1869
    find_lex $P133, "$BLOCK"
    unless_null $P133, vivify_2494
    new $P133, "Undef"
  vivify_2494:
    find_lex $P135, "$name"
    unless_null $P135, vivify_2495
    new $P135, "Undef"
  vivify_2495:
    $P133."symbol"($P135, "package" :named("scope"))
  if_3105_end:
.annotate 'line', 1862
    goto if_3087_end
  if_3087:
.annotate 'line', 1842
    .const 'Sub' $P3089 = "540_1310110678.31883" 
    capture_lex $P3089
    $P3089()
  if_3087_end:
.annotate 'line', 1881
    find_lex $P127, "$/"
    find_lex $P128, "$past"
    unless_null $P128, vivify_2525
    new $P128, "Undef"
  vivify_2525:
    $P127."!make"($P128)
.annotate 'line', 1883
    find_lex $P3109, "$/"
    unless_null $P3109, vivify_2526
    $P3109 = root_new ['parrot';'Hash']
  vivify_2526:
    set $P128, $P3109["trait"]
    unless_null $P128, vivify_2527
    new $P128, "Undef"
  vivify_2527:
    if $P128, if_3108
    set $P127, $P128
    goto if_3108_end
  if_3108:
.annotate 'line', 1884
    find_lex $P3110, "$/"
    unless_null $P3110, vivify_2528
    $P3110 = root_new ['parrot';'Hash']
  vivify_2528:
    set $P130, $P3110["trait"]
    unless_null $P130, vivify_2529
    new $P130, "Undef"
  vivify_2529:
    defined $I100, $P130
    unless $I100, for_undef_2530
    iter $P129, $P130
    new $P132, 'ExceptionHandler'
    set_label $P132, loop3114_handler
    $P132."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P132
  loop3114_test:
    unless $P129, loop3114_done
    shift $P131, $P129
  loop3114_redo:
    .const 'Sub' $P3112 = "541_1310110678.31883" 
    capture_lex $P3112
    $P3112($P131)
  loop3114_next:
    goto loop3114_test
  loop3114_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P133, exception, 'type'
    eq $P133, .CONTROL_LOOP_NEXT, loop3114_next
    eq $P133, .CONTROL_LOOP_REDO, loop3114_redo
  loop3114_done:
    pop_eh 
  for_undef_2530:
.annotate 'line', 1883
    set $P127, $P129
  if_3108_end:
.annotate 'line', 1834
    .return ($P127)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3088"  :anon :subid("540_1310110678.31883") :outer("539_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1849
    $P3091 = root_new ['parrot';'Hash']
    set $P3090, $P3091
    .lex "%lit_args", $P3090
.annotate 'line', 1850
    $P3093 = root_new ['parrot';'Hash']
    set $P3092, $P3093
    .lex "%obj_args", $P3092
.annotate 'line', 1844
    find_dynamic_lex $P135, "$*PKGDECL"
    unless_null $P135, vivify_2496
    get_hll_global $P133, "GLOBAL"
    get_who $P134, $P133
    set $P135, $P134["$PKGDECL"]
    unless_null $P135, vivify_2497
    die "Contextual $*PKGDECL not found"
  vivify_2497:
  vivify_2496:
    concat $P136, $P135, "-attr"
    find_dynamic_lex $P132, "%*HOW"
    unless_null $P132, vivify_2498
    get_hll_global $P130, "GLOBAL"
    get_who $P131, $P130
    set $P132, $P131["%HOW"]
    unless_null $P132, vivify_2499
    die "Contextual %*HOW not found"
  vivify_2499:
  vivify_2498:
    exists $I101, $P132[$P136]
    if $I101, unless_3094_end
.annotate 'line', 1845
    find_lex $P137, "$/"
    unless_null $P137, vivify_2500
    new $P137, "Undef"
  vivify_2500:
    $P138 = $P137."CURSOR"()
    find_dynamic_lex $P141, "$*PKGDECL"
    unless_null $P141, vivify_2501
    get_hll_global $P139, "GLOBAL"
    get_who $P140, $P139
    set $P141, $P140["$PKGDECL"]
    unless_null $P141, vivify_2502
    die "Contextual $*PKGDECL not found"
  vivify_2502:
  vivify_2501:
    concat $P142, $P141, " packages do not support attributes"
    $P138."panic"($P142)
  unless_3094_end:
.annotate 'line', 1842
    find_lex $P3095, "%lit_args"
    unless_null $P3095, vivify_2503
    $P3095 = root_new ['parrot';'Hash']
  vivify_2503:
    find_lex $P3096, "%obj_args"
    unless_null $P3096, vivify_2504
    $P3096 = root_new ['parrot';'Hash']
  vivify_2504:
.annotate 'line', 1851
    find_lex $P130, "$name"
    unless_null $P130, vivify_2505
    new $P130, "Undef"
  vivify_2505:
    find_lex $P3097, "%lit_args"
    unless_null $P3097, vivify_2506
    $P3097 = root_new ['parrot';'Hash']
    store_lex "%lit_args", $P3097
  vivify_2506:
    set $P3097["name"], $P130
.annotate 'line', 1852
    find_lex $P3099, "$/"
    unless_null $P3099, vivify_2507
    $P3099 = root_new ['parrot';'Hash']
  vivify_2507:
    set $P130, $P3099["typename"]
    unless_null $P130, vivify_2508
    new $P130, "Undef"
  vivify_2508:
    unless $P130, if_3098_end
.annotate 'line', 1853
    find_lex $P3100, "$/"
    unless_null $P3100, vivify_2509
    $P3100 = root_new ['parrot';'Hash']
  vivify_2509:
    set $P3101, $P3100["typename"]
    unless_null $P3101, vivify_2510
    $P3101 = root_new ['parrot';'ResizablePMCArray']
  vivify_2510:
    set $P131, $P3101[0]
    unless_null $P131, vivify_2511
    new $P131, "Undef"
  vivify_2511:
    set $S101, $P131
    new $P132, "ResizablePMCArray"
    push $P132, $S101
    find_lex $P133, "$/"
    unless_null $P133, vivify_2512
    new $P133, "Undef"
  vivify_2512:
    $P134 = "find_sym"($P132, $P133)
    find_lex $P3102, "%obj_args"
    unless_null $P3102, vivify_2513
    $P3102 = root_new ['parrot';'Hash']
    store_lex "%obj_args", $P3102
  vivify_2513:
    set $P3102["type"], $P134
  if_3098_end:
.annotate 'line', 1857
    find_dynamic_lex $P132, "$*SC"
    unless_null $P132, vivify_2514
    get_hll_global $P130, "GLOBAL"
    get_who $P131, $P130
    set $P132, $P131["$SC"]
    unless_null $P132, vivify_2515
    die "Contextual $*SC not found"
  vivify_2515:
  vivify_2514:
    find_dynamic_lex $P135, "$*PACKAGE"
    unless_null $P135, vivify_2516
    get_hll_global $P133, "GLOBAL"
    get_who $P134, $P133
    set $P135, $P134["$PACKAGE"]
    unless_null $P135, vivify_2517
    die "Contextual $*PACKAGE not found"
  vivify_2517:
  vivify_2516:
    find_dynamic_lex $P138, "$*PKGDECL"
    unless_null $P138, vivify_2518
    get_hll_global $P136, "GLOBAL"
    get_who $P137, $P136
    set $P138, $P137["$PKGDECL"]
    unless_null $P138, vivify_2519
    die "Contextual $*PKGDECL not found"
  vivify_2519:
  vivify_2518:
    concat $P139, $P138, "-attr"
    find_dynamic_lex $P142, "%*HOW"
    unless_null $P142, vivify_2520
    get_hll_global $P140, "GLOBAL"
    get_who $P141, $P140
    set $P142, $P141["%HOW"]
    unless_null $P142, vivify_2521
    die "Contextual %*HOW not found"
  vivify_2521:
  vivify_2520:
    set $P143, $P142[$P139]
    unless_null $P143, vivify_2522
    new $P143, "Undef"
  vivify_2522:
    find_lex $P3103, "%lit_args"
    unless_null $P3103, vivify_2523
    $P3103 = root_new ['parrot';'Hash']
  vivify_2523:
    find_lex $P3104, "%obj_args"
    unless_null $P3104, vivify_2524
    $P3104 = root_new ['parrot';'Hash']
  vivify_2524:
    $P132."pkg_add_attribute"($P135, $P143, $P3103, $P3104)
.annotate 'line', 1860
    get_hll_global $P130, "GLOBAL"
    nqp_get_package_through_who $P131, $P130, "PAST"
    get_who $P132, $P131
    set $P133, $P132["Stmts"]
    $P134 = $P133."new"()
    store_lex "$past", $P134
.annotate 'line', 1842
    .return ($P134)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3111"  :anon :subid("541_1310110678.31883") :outer("539_1310110678.31883")
    .param pmc param_3113
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1884
    .lex "$_", param_3113
    find_lex $P132, "$_"
    unless_null $P132, vivify_2531
    new $P132, "Undef"
  vivify_2531:
    $P133 = $P132."ast"()
    find_lex $P134, "$/"
    unless_null $P134, vivify_2532
    new $P134, "Undef"
  vivify_2532:
    $P135 = $P133($P134)
    .return ($P135)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<sub>" :anon :subid("542_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3116
    .param pmc param_3117
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1889
    .lex "self", param_3116
    .lex "$/", param_3117
    find_lex $P122, "$/"
    find_lex $P3118, "$/"
    unless_null $P3118, vivify_2533
    $P3118 = root_new ['parrot';'Hash']
  vivify_2533:
    set $P123, $P3118["routine_def"]
    unless_null $P123, vivify_2534
    new $P123, "Undef"
  vivify_2534:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<method>" :anon :subid("543_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3120
    .param pmc param_3121
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1890
    .lex "self", param_3120
    .lex "$/", param_3121
    find_lex $P122, "$/"
    find_lex $P3122, "$/"
    unless_null $P3122, vivify_2535
    $P3122 = root_new ['parrot';'Hash']
  vivify_2535:
    set $P123, $P3122["method_def"]
    unless_null $P123, vivify_2536
    new $P123, "Undef"
  vivify_2536:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "routine_def" :anon :subid("544_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3124
    .param pmc param_3125
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1892
    .const 'Sub' $P3201 = "550_1310110678.31883" 
    capture_lex $P3201
    .const 'Sub' $P3135 = "545_1310110678.31883" 
    capture_lex $P3135
    .lex "self", param_3124
    .lex "$/", param_3125
.annotate 'line', 1895
    new $P122, "Undef"
    set $P3126, $P122
    .lex "$past", $P3126
.annotate 'line', 1906
    new $P123, "Undef"
    set $P3127, $P123
    .lex "$block", $P3127
.annotate 'line', 1892
    find_lex $P124, "$past"
    unless_null $P124, vivify_2537
    new $P124, "Undef"
  vivify_2537:
.annotate 'line', 1896
    find_lex $P3129, "$/"
    unless_null $P3129, vivify_2538
    $P3129 = root_new ['parrot';'Hash']
  vivify_2538:
    set $P124, $P3129["onlystar"]
    unless_null $P124, vivify_2539
    new $P124, "Undef"
  vivify_2539:
    if $P124, if_3128
.annotate 'line', 1900
    find_lex $P3130, "$/"
    unless_null $P3130, vivify_2540
    $P3130 = root_new ['parrot';'Hash']
  vivify_2540:
    set $P125, $P3130["blockoid"]
    unless_null $P125, vivify_2541
    new $P125, "Undef"
  vivify_2541:
    $P127 = $P125."ast"()
    store_lex "$past", $P127
.annotate 'line', 1901
    find_lex $P125, "$past"
    unless_null $P125, vivify_2542
    new $P125, "Undef"
  vivify_2542:
    $P125."blocktype"("declaration")
.annotate 'line', 1902
    find_dynamic_lex $P128, "$*RETURN_USED"
    unless_null $P128, vivify_2543
    get_hll_global $P125, "GLOBAL"
    get_who $P127, $P125
    set $P128, $P127["$RETURN_USED"]
    unless_null $P128, vivify_2544
    die "Contextual $*RETURN_USED not found"
  vivify_2544:
  vivify_2543:
    unless $P128, if_3131_end
.annotate 'line', 1903
    find_lex $P129, "$past"
    unless_null $P129, vivify_2545
    new $P129, "Undef"
  vivify_2545:
    $P129."control"("return_pir")
  if_3131_end:
.annotate 'line', 1899
    goto if_3128_end
  if_3128:
.annotate 'line', 1897
    $P125 = "only_star_block"()
    store_lex "$past", $P125
  if_3128_end:
.annotate 'line', 1906
    find_lex $P124, "$past"
    unless_null $P124, vivify_2546
    new $P124, "Undef"
  vivify_2546:
    store_lex "$block", $P124
.annotate 'line', 1908
    find_lex $P3133, "$/"
    unless_null $P3133, vivify_2547
    $P3133 = root_new ['parrot';'Hash']
  vivify_2547:
    set $P124, $P3133["deflongname"]
    unless_null $P124, vivify_2548
    new $P124, "Undef"
  vivify_2548:
    unless $P124, if_3132_end
    .const 'Sub' $P3135 = "545_1310110678.31883" 
    capture_lex $P3135
    $P3135()
  if_3132_end:
.annotate 'line', 2009
    find_lex $P124, "$block"
    unless_null $P124, vivify_2654
    new $P124, "Undef"
  vivify_2654:
    find_lex $P3196, "$past"
    unless_null $P3196, vivify_2655
    $P3196 = root_new ['parrot';'Hash']
    store_lex "$past", $P3196
  vivify_2655:
    set $P3196["block_past"], $P124
.annotate 'line', 2010
    find_lex $P3198, "$/"
    unless_null $P3198, vivify_2656
    $P3198 = root_new ['parrot';'Hash']
  vivify_2656:
    set $P124, $P3198["trait"]
    unless_null $P124, vivify_2657
    new $P124, "Undef"
  vivify_2657:
    unless $P124, if_3197_end
.annotate 'line', 2011
    find_lex $P3199, "$/"
    unless_null $P3199, vivify_2658
    $P3199 = root_new ['parrot';'Hash']
  vivify_2658:
    set $P127, $P3199["trait"]
    unless_null $P127, vivify_2659
    new $P127, "Undef"
  vivify_2659:
    defined $I100, $P127
    unless $I100, for_undef_2660
    iter $P125, $P127
    new $P129, 'ExceptionHandler'
    set_label $P129, loop3203_handler
    $P129."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P129
  loop3203_test:
    unless $P125, loop3203_done
    shift $P128, $P125
  loop3203_redo:
    .const 'Sub' $P3201 = "550_1310110678.31883" 
    capture_lex $P3201
    $P3201($P128)
  loop3203_next:
    goto loop3203_test
  loop3203_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P130, exception, 'type'
    eq $P130, .CONTROL_LOOP_NEXT, loop3203_next
    eq $P130, .CONTROL_LOOP_REDO, loop3203_redo
  loop3203_done:
    pop_eh 
  for_undef_2660:
  if_3197_end:
.annotate 'line', 2014
    find_lex $P124, "$/"
    find_lex $P125, "$past"
    unless_null $P125, vivify_2663
    new $P125, "Undef"
  vivify_2663:
    $P127 = $P124."!make"($P125)
.annotate 'line', 1892
    .return ($P127)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3134"  :anon :subid("545_1310110678.31883") :outer("544_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1908
    .const 'Sub' $P3180 = "549_1310110678.31883" 
    capture_lex $P3180
    .const 'Sub' $P3146 = "546_1310110678.31883" 
    capture_lex $P3146
.annotate 'line', 1909
    new $P125, "Undef"
    set $P3136, $P125
    .lex "$name", $P3136
    find_lex $P3137, "$/"
    unless_null $P3137, vivify_2549
    $P3137 = root_new ['parrot';'Hash']
  vivify_2549:
    set $P3138, $P3137["sigil"]
    unless_null $P3138, vivify_2550
    $P3138 = root_new ['parrot';'ResizablePMCArray']
  vivify_2550:
    set $P127, $P3138[0]
    unless_null $P127, vivify_2551
    new $P127, "Undef"
  vivify_2551:
    set $S100, $P127
    new $P128, 'String'
    set $P128, $S100
    find_lex $P3139, "$/"
    unless_null $P3139, vivify_2552
    $P3139 = root_new ['parrot';'Hash']
  vivify_2552:
    set $P3140, $P3139["deflongname"]
    unless_null $P3140, vivify_2553
    $P3140 = root_new ['parrot';'ResizablePMCArray']
  vivify_2553:
    set $P129, $P3140[0]
    unless_null $P129, vivify_2554
    new $P129, "Undef"
  vivify_2554:
    $S101 = $P129."ast"()
    concat $P130, $P128, $S101
    store_lex "$name", $P130
.annotate 'line', 1910
    find_lex $P127, "$past"
    unless_null $P127, vivify_2555
    new $P127, "Undef"
  vivify_2555:
    find_lex $P128, "$name"
    unless_null $P128, vivify_2556
    new $P128, "Undef"
  vivify_2556:
    $P127."name"($P128)
.annotate 'line', 1911
    find_dynamic_lex $P131, "$*SCOPE"
    unless_null $P131, vivify_2557
    get_hll_global $P129, "GLOBAL"
    get_who $P130, $P129
    set $P131, $P130["$SCOPE"]
    unless_null $P131, vivify_2558
    die "Contextual $*SCOPE not found"
  vivify_2558:
  vivify_2557:
    set $S100, $P131
    iseq $I100, $S100, ""
    unless $I100, unless_3143
    new $P128, 'Integer'
    set $P128, $I100
    goto unless_3143_end
  unless_3143:
    find_dynamic_lex $P134, "$*SCOPE"
    unless_null $P134, vivify_2559
    get_hll_global $P132, "GLOBAL"
    get_who $P133, $P132
    set $P134, $P133["$SCOPE"]
    unless_null $P134, vivify_2560
    die "Contextual $*SCOPE not found"
  vivify_2560:
  vivify_2559:
    set $S101, $P134
    iseq $I101, $S101, "my"
    new $P128, 'Integer'
    set $P128, $I101
  unless_3143_end:
    unless $P128, unless_3142
    set $P127, $P128
    goto unless_3142_end
  unless_3142:
    find_dynamic_lex $P137, "$*SCOPE"
    unless_null $P137, vivify_2561
    get_hll_global $P135, "GLOBAL"
    get_who $P136, $P135
    set $P137, $P136["$SCOPE"]
    unless_null $P137, vivify_2562
    die "Contextual $*SCOPE not found"
  vivify_2562:
  vivify_2561:
    set $S102, $P137
    iseq $I102, $S102, "our"
    new $P127, 'Integer'
    set $P127, $I102
  unless_3142_end:
    if $P127, if_3141
.annotate 'line', 1999
    find_lex $P138, "$/"
    unless_null $P138, vivify_2563
    new $P138, "Undef"
  vivify_2563:
    $P139 = $P138."CURSOR"()
    find_dynamic_lex $P142, "$*SCOPE"
    unless_null $P142, vivify_2564
    get_hll_global $P140, "GLOBAL"
    get_who $P141, $P140
    set $P142, $P141["$SCOPE"]
    unless_null $P142, vivify_2565
    die "Contextual $*SCOPE not found"
  vivify_2565:
  vivify_2564:
    concat $P143, $P142, " scoped routines are not supported yet"
    $P139."panic"($P143)
.annotate 'line', 1998
    goto if_3141_end
  if_3141:
.annotate 'line', 1912
    find_dynamic_lex $P140, "$*MULTINESS"
    unless_null $P140, vivify_2566
    get_hll_global $P138, "GLOBAL"
    get_who $P139, $P138
    set $P140, $P139["$MULTINESS"]
    unless_null $P140, vivify_2567
    die "Contextual $*MULTINESS not found"
  vivify_2567:
  vivify_2566:
    set $S103, $P140
    iseq $I103, $S103, "multi"
    if $I103, if_3144
.annotate 'line', 1963
    find_dynamic_lex $P145, "$*MULTINESS"
    unless_null $P145, vivify_2568
    get_hll_global $P142, "GLOBAL"
    get_who $P144, $P142
    set $P145, $P144["$MULTINESS"]
    unless_null $P145, vivify_2569
    die "Contextual $*MULTINESS not found"
  vivify_2569:
  vivify_2568:
    set $S104, $P145
    iseq $I104, $S104, "proto"
    if $I104, if_3178
.annotate 'line', 1982
    find_lex $P147, "$?PACKAGE"
    get_who $P150, $P147
    set $P3188, $P150["@BLOCK"]
    unless_null $P3188, vivify_2570
    $P3188 = root_new ['parrot';'ResizablePMCArray']
  vivify_2570:
    set $P3189, $P3188[0]
    unless_null $P3189, vivify_2571
    $P3189 = root_new ['parrot';'ResizablePMCArray']
  vivify_2571:
    set $P151, $P3189[0]
    unless_null $P151, vivify_2572
    new $P151, "Undef"
  vivify_2572:
    get_hll_global $P152, "GLOBAL"
    nqp_get_package_through_who $P153, $P152, "PAST"
    get_who $P154, $P153
    set $P155, $P154["Var"]
    find_lex $P156, "$name"
    unless_null $P156, vivify_2573
    new $P156, "Undef"
  vivify_2573:
    find_lex $P157, "$past"
    unless_null $P157, vivify_2574
    new $P157, "Undef"
  vivify_2574:
    $P158 = $P155."new"($P156 :named("name"), 1 :named("isdecl"), $P157 :named("viviself"), "lexical" :named("scope"))
    $P151."push"($P158)
.annotate 'line', 1984
    find_lex $P147, "$?PACKAGE"
    get_who $P150, $P147
    set $P3190, $P150["@BLOCK"]
    unless_null $P3190, vivify_2575
    $P3190 = root_new ['parrot';'ResizablePMCArray']
  vivify_2575:
    set $P151, $P3190[0]
    unless_null $P151, vivify_2576
    new $P151, "Undef"
  vivify_2576:
    find_lex $P152, "$name"
    unless_null $P152, vivify_2577
    new $P152, "Undef"
  vivify_2577:
    $P151."symbol"($P152, "lexical" :named("scope"))
.annotate 'line', 1985
    find_dynamic_lex $P151, "$*SCOPE"
    unless_null $P151, vivify_2578
    get_hll_global $P147, "GLOBAL"
    get_who $P150, $P147
    set $P151, $P150["$SCOPE"]
    unless_null $P151, vivify_2579
    die "Contextual $*SCOPE not found"
  vivify_2579:
  vivify_2578:
    set $S105, $P151
    iseq $I105, $S105, "our"
    unless $I105, if_3191_end
.annotate 'line', 1988
    find_dynamic_lex $P154, "$*SC"
    unless_null $P154, vivify_2580
    get_hll_global $P152, "GLOBAL"
    get_who $P153, $P152
    set $P154, $P153["$SC"]
    unless_null $P154, vivify_2581
    die "Contextual $*SC not found"
  vivify_2581:
  vivify_2580:
    find_dynamic_lex $P157, "$*PACKAGE"
    unless_null $P157, vivify_2582
    get_hll_global $P155, "GLOBAL"
    get_who $P156, $P155
    set $P157, $P156["$PACKAGE"]
    unless_null $P157, vivify_2583
    die "Contextual $*PACKAGE not found"
  vivify_2583:
  vivify_2582:
    find_lex $P158, "$name"
    unless_null $P158, vivify_2584
    new $P158, "Undef"
  vivify_2584:
    find_lex $P159, "$past"
    unless_null $P159, vivify_2585
    new $P159, "Undef"
  vivify_2585:
    $P154."install_package_routine"($P157, $P158, $P159)
.annotate 'line', 1989
    find_lex $P152, "$?PACKAGE"
    get_who $P153, $P152
    set $P3192, $P153["@BLOCK"]
    unless_null $P3192, vivify_2586
    $P3192 = root_new ['parrot';'ResizablePMCArray']
  vivify_2586:
    set $P3193, $P3192[0]
    unless_null $P3193, vivify_2587
    $P3193 = root_new ['parrot';'ResizablePMCArray']
  vivify_2587:
    set $P154, $P3193[0]
    unless_null $P154, vivify_2588
    new $P154, "Undef"
  vivify_2588:
    get_hll_global $P155, "GLOBAL"
    nqp_get_package_through_who $P156, $P155, "PAST"
    get_who $P157, $P156
    set $P158, $P157["Op"]
.annotate 'line', 1991
    find_lex $P159, "$name"
    unless_null $P159, vivify_2589
    new $P159, "Undef"
  vivify_2589:
    new $P160, "ResizablePMCArray"
    push $P160, $P159
    find_lex $P161, "$/"
    unless_null $P161, vivify_2590
    new $P161, "Undef"
  vivify_2590:
    $P162 = "lexical_package_lookup"($P160, $P161)
.annotate 'line', 1992
    get_hll_global $P163, "GLOBAL"
    nqp_get_package_through_who $P164, $P163, "PAST"
    get_who $P165, $P164
    set $P166, $P165["Var"]
    find_lex $P167, "$name"
    unless_null $P167, vivify_2591
    new $P167, "Undef"
  vivify_2591:
    $P168 = $P166."new"($P167 :named("name"), "lexical" :named("scope"))
    $P169 = $P158."new"($P162, $P168, "bind_6model" :named("pasttype"))
.annotate 'line', 1989
    $P154."push"($P169)
  if_3191_end:
.annotate 'line', 1981
    goto if_3178_end
  if_3178:
.annotate 'line', 1963
    .const 'Sub' $P3180 = "549_1310110678.31883" 
    capture_lex $P3180
    $P3180()
  if_3178_end:
    goto if_3144_end
  if_3144:
.annotate 'line', 1912
    .const 'Sub' $P3146 = "546_1310110678.31883" 
    capture_lex $P3146
    $P3146()
  if_3144_end:
.annotate 'line', 1996
    get_hll_global $P138, "GLOBAL"
    nqp_get_package_through_who $P139, $P138, "PAST"
    get_who $P140, $P139
    set $P141, $P140["Var"]
    find_lex $P142, "$name"
    unless_null $P142, vivify_2649
    new $P142, "Undef"
  vivify_2649:
    $P143 = $P141."new"($P142 :named("name"))
    store_lex "$past", $P143
  if_3141_end:
.annotate 'line', 2003
    find_lex $P129, "$name"
    unless_null $P129, vivify_2650
    new $P129, "Undef"
  vivify_2650:
    set $S100, $P129
    iseq $I100, $S100, "MAIN"
    if $I100, if_3195
    new $P128, 'Integer'
    set $P128, $I100
    goto if_3195_end
  if_3195:
    find_dynamic_lex $P132, "$*MULTINESS"
    unless_null $P132, vivify_2651
    get_hll_global $P130, "GLOBAL"
    get_who $P131, $P130
    set $P132, $P131["$MULTINESS"]
    unless_null $P132, vivify_2652
    die "Contextual $*MULTINESS not found"
  vivify_2652:
  vivify_2651:
    set $S101, $P132
    isne $I101, $S101, "multi"
    new $P128, 'Integer'
    set $P128, $I101
  if_3195_end:
    if $P128, if_3194
    set $P127, $P128
    goto if_3194_end
  if_3194:
.annotate 'line', 2004
    find_lex $P133, "$block"
    unless_null $P133, vivify_2653
    new $P133, "Undef"
  vivify_2653:
    store_dynamic_lex "$*MAIN_SUB", $P133
.annotate 'line', 2003
    set $P127, $P133
  if_3194_end:
.annotate 'line', 1908
    .return ($P127)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3179"  :anon :subid("549_1310110678.31883") :outer("545_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1968
    new $P146, "Undef"
    set $P3181, $P146
    .lex "$cholder", $P3181
.annotate 'line', 1967
    find_dynamic_lex $P150, "$*SCOPE"
    unless_null $P150, vivify_2592
    get_hll_global $P147, "GLOBAL"
    get_who $P148, $P147
    set $P150, $P148["$SCOPE"]
    unless_null $P150, vivify_2593
    die "Contextual $*SCOPE not found"
  vivify_2593:
  vivify_2592:
    set $S105, $P150
    iseq $I105, $S105, "our"
    unless $I105, if_3182_end
    die "our-scoped protos not yet implemented"
  if_3182_end:
.annotate 'line', 1968
    get_hll_global $P147, "GLOBAL"
    nqp_get_package_through_who $P148, $P147, "PAST"
    get_who $P150, $P148
    set $P151, $P150["Op"]
    $P152 = $P151."new"("list" :named("pasttype"))
    store_lex "$cholder", $P152
.annotate 'line', 1969
    find_lex $P147, "$?PACKAGE"
    get_who $P148, $P147
    set $P3183, $P148["@BLOCK"]
    unless_null $P3183, vivify_2594
    $P3183 = root_new ['parrot';'ResizablePMCArray']
  vivify_2594:
    set $P3184, $P3183[0]
    unless_null $P3184, vivify_2595
    $P3184 = root_new ['parrot';'ResizablePMCArray']
  vivify_2595:
    set $P150, $P3184[0]
    unless_null $P150, vivify_2596
    new $P150, "Undef"
  vivify_2596:
    get_hll_global $P151, "GLOBAL"
    nqp_get_package_through_who $P152, $P151, "PAST"
    get_who $P153, $P152
    set $P154, $P153["Var"]
    find_lex $P155, "$name"
    unless_null $P155, vivify_2597
    new $P155, "Undef"
  vivify_2597:
    find_lex $P156, "$past"
    unless_null $P156, vivify_2598
    new $P156, "Undef"
  vivify_2598:
    $P157 = $P154."new"($P155 :named("name"), 1 :named("isdecl"), $P156 :named("viviself"), "lexical" :named("scope"))
    $P150."push"($P157)
.annotate 'line', 1971
    find_lex $P147, "$?PACKAGE"
    get_who $P148, $P147
    set $P3185, $P148["@BLOCK"]
    unless_null $P3185, vivify_2599
    $P3185 = root_new ['parrot';'ResizablePMCArray']
  vivify_2599:
    set $P3186, $P3185[0]
    unless_null $P3186, vivify_2600
    $P3186 = root_new ['parrot';'ResizablePMCArray']
  vivify_2600:
    set $P150, $P3186[0]
    unless_null $P150, vivify_2601
    new $P150, "Undef"
  vivify_2601:
    get_hll_global $P151, "GLOBAL"
    nqp_get_package_through_who $P152, $P151, "PAST"
    get_who $P153, $P152
    set $P154, $P153["Op"]
.annotate 'line', 1973
    get_hll_global $P155, "GLOBAL"
    nqp_get_package_through_who $P156, $P155, "PAST"
    get_who $P157, $P156
    set $P158, $P157["Var"]
    find_lex $P159, "$name"
    unless_null $P159, vivify_2602
    new $P159, "Undef"
  vivify_2602:
    $P160 = $P158."new"($P159 :named("name"))
    find_lex $P161, "$cholder"
    unless_null $P161, vivify_2603
    new $P161, "Undef"
  vivify_2603:
    $P162 = $P154."new"($P160, $P161, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 1971
    $P150."push"($P162)
.annotate 'line', 1976
    find_lex $P147, "$?PACKAGE"
    get_who $P148, $P147
    set $P3187, $P148["@BLOCK"]
    unless_null $P3187, vivify_2604
    $P3187 = root_new ['parrot';'ResizablePMCArray']
  vivify_2604:
    set $P150, $P3187[0]
    unless_null $P150, vivify_2605
    new $P150, "Undef"
  vivify_2605:
    find_lex $P151, "$name"
    unless_null $P151, vivify_2606
    new $P151, "Undef"
  vivify_2606:
    find_lex $P152, "$cholder"
    unless_null $P152, vivify_2607
    new $P152, "Undef"
  vivify_2607:
    $P150."symbol"($P151, "lexical" :named("scope"), 1 :named("proto"), $P152 :named("cholder"))
.annotate 'line', 1979
    find_lex $P147, "$past"
    unless_null $P147, vivify_2608
    new $P147, "Undef"
  vivify_2608:
    $P148 = $P147."pirflags"(":instanceof(\"DispatcherSub\")")
.annotate 'line', 1963
    .return ($P148)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3145"  :anon :subid("546_1310110678.31883") :outer("545_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1912
    .const 'Sub' $P3156 = "547_1310110678.31883" 
    capture_lex $P3156
.annotate 'line', 1915
    new $P141, "Undef"
    set $P3147, $P141
    .lex "$cholder", $P3147
.annotate 'line', 1916
    $P3149 = root_new ['parrot';'Hash']
    set $P3148, $P3149
    .lex "%sym", $P3148
.annotate 'line', 1914
    find_dynamic_lex $P144, "$*SCOPE"
    unless_null $P144, vivify_2609
    get_hll_global $P142, "GLOBAL"
    get_who $P143, $P142
    set $P144, $P143["$SCOPE"]
    unless_null $P144, vivify_2610
    die "Contextual $*SCOPE not found"
  vivify_2610:
  vivify_2609:
    set $S104, $P144
    iseq $I104, $S104, "our"
    unless $I104, if_3150_end
    die "our-scoped multis not yet implemented"
  if_3150_end:
.annotate 'line', 1912
    find_lex $P142, "$cholder"
    unless_null $P142, vivify_2611
    new $P142, "Undef"
  vivify_2611:
.annotate 'line', 1916
    find_lex $P142, "$?PACKAGE"
    get_who $P143, $P142
    set $P3151, $P143["@BLOCK"]
    unless_null $P3151, vivify_2612
    $P3151 = root_new ['parrot';'ResizablePMCArray']
  vivify_2612:
    set $P144, $P3151[0]
    unless_null $P144, vivify_2613
    new $P144, "Undef"
  vivify_2613:
    find_lex $P145, "$name"
    unless_null $P145, vivify_2614
    new $P145, "Undef"
  vivify_2614:
    $P146 = $P144."symbol"($P145)
    store_lex "%sym", $P146
.annotate 'line', 1917
    find_lex $P3153, "%sym"
    unless_null $P3153, vivify_2615
    $P3153 = root_new ['parrot';'Hash']
  vivify_2615:
    set $P142, $P3153["cholder"]
    unless_null $P142, vivify_2616
    new $P142, "Undef"
  vivify_2616:
    if $P142, if_3152
.annotate 'line', 1922
    .const 'Sub' $P3156 = "547_1310110678.31883" 
    capture_lex $P3156
    $P3156()
    goto if_3152_end
  if_3152:
.annotate 'line', 1918
    find_lex $P3154, "%sym"
    unless_null $P3154, vivify_2644
    $P3154 = root_new ['parrot';'Hash']
  vivify_2644:
    set $P143, $P3154["cholder"]
    unless_null $P143, vivify_2645
    new $P143, "Undef"
  vivify_2645:
    store_lex "$cholder", $P143
  if_3152_end:
.annotate 'line', 1958
    find_lex $P142, "$cholder"
    unless_null $P142, vivify_2646
    new $P142, "Undef"
  vivify_2646:
    find_lex $P143, "$past"
    unless_null $P143, vivify_2647
    new $P143, "Undef"
  vivify_2647:
    $P142."push"($P143)
.annotate 'line', 1961
    find_lex $P142, "$past"
    unless_null $P142, vivify_2648
    new $P142, "Undef"
  vivify_2648:
    $P143 = "attach_multi_signature"($P142)
.annotate 'line', 1912
    .return ($P143)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3155"  :anon :subid("547_1310110678.31883") :outer("546_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1922
    .const 'Sub' $P3163 = "548_1310110678.31883" 
    capture_lex $P3163
.annotate 'line', 1929
    new $P143, "Undef"
    set $P3157, $P143
    .lex "$found_proto", $P3157
.annotate 'line', 1947
    new $P144, "Undef"
    set $P3158, $P144
    .lex "$dispatch_setup", $P3158
.annotate 'line', 1924
    find_lex $P3160, "%sym"
    unless_null $P3160, vivify_2617
    $P3160 = root_new ['parrot';'Hash']
  vivify_2617:
    set $P145, $P3160["proto"]
    unless_null $P145, vivify_2618
    new $P145, "Undef"
  vivify_2618:
    unless $P145, if_3159_end
.annotate 'line', 1927
    find_lex $P146, "$/"
    unless_null $P146, vivify_2619
    new $P146, "Undef"
  vivify_2619:
    $P147 = $P146."CURSOR"()
    $P147."panic"("Internal Error: Current scope has a proto, but no candidate list holder was set up. (This should never happen.)")
  if_3159_end:
.annotate 'line', 1922
    find_lex $P145, "$found_proto"
    unless_null $P145, vivify_2620
    new $P145, "Undef"
  vivify_2620:
.annotate 'line', 1930
    find_lex $P146, "$?PACKAGE"
    get_who $P147, $P146
    set $P3161, $P147["@BLOCK"]
    unless_null $P3161, vivify_2621
    $P3161 = root_new ['parrot';'ResizablePMCArray']
  vivify_2621:
    defined $I104, $P3161
    unless $I104, for_undef_2622
    iter $P145, $P3161
    new $P151, 'ExceptionHandler'
    set_label $P151, loop3173_handler
    $P151."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P151
  loop3173_test:
    unless $P145, loop3173_done
    shift $P148, $P145
  loop3173_redo:
    .const 'Sub' $P3163 = "548_1310110678.31883" 
    capture_lex $P3163
    $P3163($P148)
  loop3173_next:
    goto loop3173_test
  loop3173_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P152, exception, 'type'
    eq $P152, .CONTROL_LOOP_NEXT, loop3173_next
    eq $P152, .CONTROL_LOOP_REDO, loop3173_redo
  loop3173_done:
    pop_eh 
  for_undef_2622:
.annotate 'line', 1941
    find_lex $P145, "$found_proto"
    unless_null $P145, vivify_2631
    new $P145, "Undef"
  vivify_2631:
    if $P145, unless_3174_end
.annotate 'line', 1942
    find_lex $P146, "$/"
    unless_null $P146, vivify_2632
    new $P146, "Undef"
  vivify_2632:
    $P147 = $P146."CURSOR"()
    $P147."panic"("Sorry, no proto sub in scope, and auto-generation of protos is not yet implemented.")
  unless_3174_end:
.annotate 'line', 1946
    get_hll_global $P145, "GLOBAL"
    nqp_get_package_through_who $P146, $P145, "PAST"
    get_who $P147, $P146
    set $P148, $P147["Op"]
    $P150 = $P148."new"("list" :named("pasttype"))
    store_lex "$cholder", $P150
.annotate 'line', 1947
    get_hll_global $P145, "GLOBAL"
    nqp_get_package_through_who $P146, $P145, "PAST"
    get_who $P147, $P146
    set $P148, $P147["Op"]
.annotate 'line', 1949
    get_hll_global $P150, "GLOBAL"
    nqp_get_package_through_who $P151, $P150, "PAST"
    get_who $P152, $P151
    set $P153, $P152["Var"]
    find_lex $P154, "$name"
    unless_null $P154, vivify_2633
    new $P154, "Undef"
  vivify_2633:
    $P155 = $P153."new"($P154 :named("name"), "outer" :named("scope"))
    find_lex $P156, "$cholder"
    unless_null $P156, vivify_2634
    new $P156, "Undef"
  vivify_2634:
    $P157 = $P148."new"($P155, $P156, "create_dispatch_and_add_candidates PPP" :named("pirop"))
.annotate 'line', 1947
    store_lex "$dispatch_setup", $P157
.annotate 'line', 1952
    find_lex $P145, "$?PACKAGE"
    get_who $P146, $P145
    set $P3175, $P146["@BLOCK"]
    unless_null $P3175, vivify_2635
    $P3175 = root_new ['parrot';'ResizablePMCArray']
  vivify_2635:
    set $P3176, $P3175[0]
    unless_null $P3176, vivify_2636
    $P3176 = root_new ['parrot';'ResizablePMCArray']
  vivify_2636:
    set $P147, $P3176[0]
    unless_null $P147, vivify_2637
    new $P147, "Undef"
  vivify_2637:
    get_hll_global $P148, "GLOBAL"
    nqp_get_package_through_who $P150, $P148, "PAST"
    get_who $P151, $P150
    set $P152, $P151["Var"]
    find_lex $P153, "$name"
    unless_null $P153, vivify_2638
    new $P153, "Undef"
  vivify_2638:
    find_lex $P154, "$dispatch_setup"
    unless_null $P154, vivify_2639
    new $P154, "Undef"
  vivify_2639:
    $P155 = $P152."new"($P153 :named("name"), 1 :named("isdecl"), $P154 :named("viviself"), "lexical" :named("scope"))
    $P147."push"($P155)
.annotate 'line', 1954
    find_lex $P145, "$?PACKAGE"
    get_who $P146, $P145
    set $P3177, $P146["@BLOCK"]
    unless_null $P3177, vivify_2640
    $P3177 = root_new ['parrot';'ResizablePMCArray']
  vivify_2640:
    set $P147, $P3177[0]
    unless_null $P147, vivify_2641
    new $P147, "Undef"
  vivify_2641:
    find_lex $P148, "$name"
    unless_null $P148, vivify_2642
    new $P148, "Undef"
  vivify_2642:
    find_lex $P150, "$cholder"
    unless_null $P150, vivify_2643
    new $P150, "Undef"
  vivify_2643:
    $P151 = $P147."symbol"($P148, "lexical" :named("scope"), $P150 :named("cholder"))
.annotate 'line', 1922
    .return ($P151)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3162"  :anon :subid("548_1310110678.31883") :outer("547_1310110678.31883")
    .param pmc param_3166
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1931
    $P3165 = root_new ['parrot';'Hash']
    set $P3164, $P3165
    .lex "%sym", $P3164
    .lex "$_", param_3166
    find_lex $P150, "$_"
    unless_null $P150, vivify_2623
    new $P150, "Undef"
  vivify_2623:
    find_lex $P151, "$name"
    unless_null $P151, vivify_2624
    new $P151, "Undef"
  vivify_2624:
    $P152 = $P150."symbol"($P151)
    store_lex "%sym", $P152
.annotate 'line', 1932
    find_lex $P3169, "%sym"
    unless_null $P3169, vivify_2625
    $P3169 = root_new ['parrot';'Hash']
  vivify_2625:
    set $P152, $P3169["proto"]
    unless_null $P152, vivify_2626
    new $P152, "Undef"
  vivify_2626:
    unless $P152, unless_3168
    set $P151, $P152
    goto unless_3168_end
  unless_3168:
    find_lex $P3170, "%sym"
    unless_null $P3170, vivify_2627
    $P3170 = root_new ['parrot';'Hash']
  vivify_2627:
    set $P153, $P3170["cholder"]
    unless_null $P153, vivify_2628
    new $P153, "Undef"
  vivify_2628:
    set $P151, $P153
  unless_3168_end:
    if $P151, if_3167
.annotate 'line', 1935
    find_lex $P3172, "%sym"
    unless_null $P3172, vivify_2629
    $P3172 = root_new ['parrot';'Hash']
  vivify_2629:
    if $P3172, if_3171
    set $P155, $P3172
    goto if_3171_end
  if_3171:
.annotate 'line', 1936
    find_lex $P156, "$/"
    unless_null $P156, vivify_2630
    new $P156, "Undef"
  vivify_2630:
    $P157 = $P156."CURSOR"()
    $P158 = $P157."panic"("Cannot declare a multi when an only is already in scope.")
.annotate 'line', 1935
    set $P155, $P158
  if_3171_end:
    set $P150, $P155
.annotate 'line', 1932
    goto if_3167_end
  if_3167:
.annotate 'line', 1933
    new $P154, "Integer"
    assign $P154, 1
    store_lex "$found_proto", $P154
.annotate 'line', 1932
    set $P150, $P154
  if_3167_end:
.annotate 'line', 1930
    .return ($P150)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3200"  :anon :subid("550_1310110678.31883") :outer("544_1310110678.31883")
    .param pmc param_3202
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2011
    .lex "$_", param_3202
    find_lex $P129, "$_"
    unless_null $P129, vivify_2661
    new $P129, "Undef"
  vivify_2661:
    $P130 = $P129."ast"()
    find_lex $P131, "$/"
    unless_null $P131, vivify_2662
    new $P131, "Undef"
  vivify_2662:
    $P132 = $P130($P131)
    .return ($P132)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "method_def" :anon :subid("551_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3205
    .param pmc param_3206
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2018
    .const 'Sub' $P3234 = "553_1310110678.31883" 
    capture_lex $P3234
    .const 'Sub' $P3218 = "552_1310110678.31883" 
    capture_lex $P3218
    .lex "self", param_3205
    .lex "$/", param_3206
.annotate 'line', 2021
    new $P122, "Undef"
    set $P3207, $P122
    .lex "$past", $P3207
.annotate 'line', 2018
    find_lex $P123, "$past"
    unless_null $P123, vivify_2664
    new $P123, "Undef"
  vivify_2664:
.annotate 'line', 2022
    find_lex $P3209, "$/"
    unless_null $P3209, vivify_2665
    $P3209 = root_new ['parrot';'Hash']
  vivify_2665:
    set $P123, $P3209["onlystar"]
    unless_null $P123, vivify_2666
    new $P123, "Undef"
  vivify_2666:
    if $P123, if_3208
.annotate 'line', 2026
    find_lex $P3210, "$/"
    unless_null $P3210, vivify_2667
    $P3210 = root_new ['parrot';'Hash']
  vivify_2667:
    set $P124, $P3210["blockoid"]
    unless_null $P124, vivify_2668
    new $P124, "Undef"
  vivify_2668:
    $P125 = $P124."ast"()
    store_lex "$past", $P125
.annotate 'line', 2027
    find_lex $P124, "$past"
    unless_null $P124, vivify_2669
    new $P124, "Undef"
  vivify_2669:
    $P124."blocktype"("declaration")
.annotate 'line', 2028
    find_dynamic_lex $P127, "$*RETURN_USED"
    unless_null $P127, vivify_2670
    get_hll_global $P124, "GLOBAL"
    get_who $P125, $P124
    set $P127, $P125["$RETURN_USED"]
    unless_null $P127, vivify_2671
    die "Contextual $*RETURN_USED not found"
  vivify_2671:
  vivify_2670:
    unless $P127, if_3211_end
.annotate 'line', 2029
    find_lex $P128, "$past"
    unless_null $P128, vivify_2672
    new $P128, "Undef"
  vivify_2672:
    $P128."control"("return_pir")
  if_3211_end:
.annotate 'line', 2025
    goto if_3208_end
  if_3208:
.annotate 'line', 2023
    $P124 = "only_star_block"()
    store_lex "$past", $P124
  if_3208_end:
.annotate 'line', 2034
    find_lex $P3213, "$past"
    unless_null $P3213, vivify_2673
    $P3213 = root_new ['parrot';'Hash']
  vivify_2673:
    set $P123, $P3213["signature_has_invocant"]
    unless_null $P123, vivify_2674
    new $P123, "Undef"
  vivify_2674:
    if $P123, unless_3212_end
.annotate 'line', 2035
    find_lex $P3214, "$past"
    unless_null $P3214, vivify_2675
    $P3214 = root_new ['parrot';'ResizablePMCArray']
  vivify_2675:
    set $P124, $P3214[0]
    unless_null $P124, vivify_2676
    new $P124, "Undef"
  vivify_2676:
    get_hll_global $P125, "GLOBAL"
    nqp_get_package_through_who $P127, $P125, "PAST"
    get_who $P128, $P127
    set $P129, $P128["Var"]
.annotate 'line', 2037
    find_dynamic_lex $P132, "$*SC"
    unless_null $P132, vivify_2677
    get_hll_global $P130, "GLOBAL"
    get_who $P131, $P130
    set $P132, $P131["$SC"]
    unless_null $P132, vivify_2678
    die "Contextual $*SC not found"
  vivify_2678:
  vivify_2677:
    find_dynamic_lex $P135, "$*PACKAGE"
    unless_null $P135, vivify_2679
    get_hll_global $P133, "GLOBAL"
    get_who $P134, $P133
    set $P135, $P134["$PACKAGE"]
    unless_null $P135, vivify_2680
    die "Contextual $*PACKAGE not found"
  vivify_2680:
  vivify_2679:
    $P136 = $P132."get_object_sc_ref_past"($P135)
.annotate 'line', 2035
    $P137 = $P129."new"("self" :named("name"), "parameter" :named("scope"), $P136 :named("multitype"))
    $P124."unshift"($P137)
  unless_3212_end:
.annotate 'line', 2040
    find_lex $P123, "$past"
    unless_null $P123, vivify_2681
    new $P123, "Undef"
  vivify_2681:
    $P123."symbol"("self", "lexical" :named("scope"))
.annotate 'line', 2043
    find_lex $P3216, "$/"
    unless_null $P3216, vivify_2682
    $P3216 = root_new ['parrot';'Hash']
  vivify_2682:
    set $P123, $P3216["deflongname"]
    unless_null $P123, vivify_2683
    new $P123, "Undef"
  vivify_2683:
    unless $P123, if_3215_end
    .const 'Sub' $P3218 = "552_1310110678.31883" 
    capture_lex $P3218
    $P3218()
  if_3215_end:
.annotate 'line', 2070
    find_lex $P123, "$/"
    find_lex $P124, "$past"
    unless_null $P124, vivify_2718
    new $P124, "Undef"
  vivify_2718:
    $P123."!make"($P124)
.annotate 'line', 2071
    find_lex $P123, "$past"
    unless_null $P123, vivify_2719
    new $P123, "Undef"
  vivify_2719:
    find_lex $P3229, "$past"
    unless_null $P3229, vivify_2720
    $P3229 = root_new ['parrot';'Hash']
    store_lex "$past", $P3229
  vivify_2720:
    set $P3229["block_past"], $P123
.annotate 'line', 2072
    find_lex $P3231, "$/"
    unless_null $P3231, vivify_2721
    $P3231 = root_new ['parrot';'Hash']
  vivify_2721:
    set $P124, $P3231["trait"]
    unless_null $P124, vivify_2722
    new $P124, "Undef"
  vivify_2722:
    if $P124, if_3230
    set $P123, $P124
    goto if_3230_end
  if_3230:
.annotate 'line', 2073
    find_lex $P3232, "$/"
    unless_null $P3232, vivify_2723
    $P3232 = root_new ['parrot';'Hash']
  vivify_2723:
    set $P127, $P3232["trait"]
    unless_null $P127, vivify_2724
    new $P127, "Undef"
  vivify_2724:
    defined $I100, $P127
    unless $I100, for_undef_2725
    iter $P125, $P127
    new $P129, 'ExceptionHandler'
    set_label $P129, loop3236_handler
    $P129."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P129
  loop3236_test:
    unless $P125, loop3236_done
    shift $P128, $P125
  loop3236_redo:
    .const 'Sub' $P3234 = "553_1310110678.31883" 
    capture_lex $P3234
    $P3234($P128)
  loop3236_next:
    goto loop3236_test
  loop3236_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P130, exception, 'type'
    eq $P130, .CONTROL_LOOP_NEXT, loop3236_next
    eq $P130, .CONTROL_LOOP_REDO, loop3236_redo
  loop3236_done:
    pop_eh 
  for_undef_2725:
.annotate 'line', 2072
    set $P123, $P125
  if_3230_end:
.annotate 'line', 2018
    .return ($P123)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3217"  :anon :subid("552_1310110678.31883") :outer("551_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2045
    new $P124, "Undef"
    set $P3219, $P124
    .lex "$name", $P3219
.annotate 'line', 2053
    new $P125, "Undef"
    set $P3220, $P125
    .lex "$meta_meth", $P3220
.annotate 'line', 2054
    new $P127, "Undef"
    set $P3221, $P127
    .lex "$is_dispatcher", $P3221
.annotate 'line', 2045
    find_lex $P3222, "$/"
    unless_null $P3222, vivify_2684
    $P3222 = root_new ['parrot';'Hash']
  vivify_2684:
    set $P128, $P3222["private"]
    unless_null $P128, vivify_2685
    new $P128, "Undef"
  vivify_2685:
    set $S100, $P128
    new $P129, 'String'
    set $P129, $S100
    find_lex $P3223, "$/"
    unless_null $P3223, vivify_2686
    $P3223 = root_new ['parrot';'Hash']
  vivify_2686:
    set $P3224, $P3223["deflongname"]
    unless_null $P3224, vivify_2687
    $P3224 = root_new ['parrot';'ResizablePMCArray']
  vivify_2687:
    set $P130, $P3224[0]
    unless_null $P130, vivify_2688
    new $P130, "Undef"
  vivify_2688:
    $P131 = $P130."ast"()
    set $S101, $P131
    concat $P132, $P129, $S101
    store_lex "$name", $P132
.annotate 'line', 2046
    find_lex $P128, "$past"
    unless_null $P128, vivify_2689
    new $P128, "Undef"
  vivify_2689:
    find_lex $P129, "$name"
    unless_null $P129, vivify_2690
    new $P129, "Undef"
  vivify_2690:
    $P128."name"($P129)
.annotate 'line', 2050
    find_dynamic_lex $P130, "$*MULTINESS"
    unless_null $P130, vivify_2691
    get_hll_global $P128, "GLOBAL"
    get_who $P129, $P128
    set $P130, $P129["$MULTINESS"]
    unless_null $P130, vivify_2692
    die "Contextual $*MULTINESS not found"
  vivify_2692:
  vivify_2691:
    set $S100, $P130
    iseq $I100, $S100, "multi"
    unless $I100, if_3225_end
    find_lex $P131, "$past"
    unless_null $P131, vivify_2693
    new $P131, "Undef"
  vivify_2693:
    "attach_multi_signature"($P131)
  if_3225_end:
.annotate 'line', 2053
    find_dynamic_lex $P131, "$*MULTINESS"
    unless_null $P131, vivify_2694
    get_hll_global $P129, "GLOBAL"
    get_who $P130, $P129
    set $P131, $P130["$MULTINESS"]
    unless_null $P131, vivify_2695
    die "Contextual $*MULTINESS not found"
  vivify_2695:
  vivify_2694:
    set $S100, $P131
    iseq $I100, $S100, "multi"
    if $I100, if_3226
    new $P133, "String"
    assign $P133, "add_method"
    set $P128, $P133
    goto if_3226_end
  if_3226:
    new $P132, "String"
    assign $P132, "add_multi_method"
    set $P128, $P132
  if_3226_end:
    store_lex "$meta_meth", $P128
.annotate 'line', 2054
    find_dynamic_lex $P130, "$*MULTINESS"
    unless_null $P130, vivify_2696
    get_hll_global $P128, "GLOBAL"
    get_who $P129, $P128
    set $P130, $P129["$MULTINESS"]
    unless_null $P130, vivify_2697
    die "Contextual $*MULTINESS not found"
  vivify_2697:
  vivify_2696:
    set $S100, $P130
    iseq $I100, $S100, "proto"
    new $P131, 'Integer'
    set $P131, $I100
    store_lex "$is_dispatcher", $P131
.annotate 'line', 2055
    find_dynamic_lex $P130, "$*SC"
    unless_null $P130, vivify_2698
    get_hll_global $P128, "GLOBAL"
    get_who $P129, $P128
    set $P130, $P129["$SC"]
    unless_null $P130, vivify_2699
    die "Contextual $*SC not found"
  vivify_2699:
  vivify_2698:
    find_dynamic_lex $P133, "$*PACKAGE"
    unless_null $P133, vivify_2700
    get_hll_global $P131, "GLOBAL"
    get_who $P132, $P131
    set $P133, $P132["$PACKAGE"]
    unless_null $P133, vivify_2701
    die "Contextual $*PACKAGE not found"
  vivify_2701:
  vivify_2700:
    find_lex $P134, "$meta_meth"
    unless_null $P134, vivify_2702
    new $P134, "Undef"
  vivify_2702:
    find_lex $P135, "$name"
    unless_null $P135, vivify_2703
    new $P135, "Undef"
  vivify_2703:
    find_lex $P136, "$past"
    unless_null $P136, vivify_2704
    new $P136, "Undef"
  vivify_2704:
    find_lex $P137, "$is_dispatcher"
    unless_null $P137, vivify_2705
    new $P137, "Undef"
  vivify_2705:
    $P130."pkg_add_method"($P133, $P134, $P135, $P136, $P137)
.annotate 'line', 2058
    find_dynamic_lex $P131, "$*SCOPE"
    unless_null $P131, vivify_2706
    get_hll_global $P129, "GLOBAL"
    get_who $P130, $P129
    set $P131, $P130["$SCOPE"]
    unless_null $P131, vivify_2707
    die "Contextual $*SCOPE not found"
  vivify_2707:
  vivify_2706:
    set $S100, $P131
    iseq $I100, $S100, "our"
    if $I100, if_3227
.annotate 'line', 2061
    find_lex $P133, "$past"
    unless_null $P133, vivify_2708
    new $P133, "Undef"
  vivify_2708:
    $P134 = $P133."pirflags"()
    if $P134, if_3228
.annotate 'line', 2064
    find_lex $P135, "$past"
    unless_null $P135, vivify_2709
    new $P135, "Undef"
  vivify_2709:
    $P136 = $P135."pirflags"(":anon")
.annotate 'line', 2063
    set $P132, $P136
.annotate 'line', 2061
    goto if_3228_end
  if_3228:
.annotate 'line', 2062
    find_lex $P135, "$past"
    unless_null $P135, vivify_2710
    new $P135, "Undef"
  vivify_2710:
    find_lex $P136, "$past"
    unless_null $P136, vivify_2711
    new $P136, "Undef"
  vivify_2711:
    $P137 = $P136."pirflags"()
    set $S101, $P137
    new $P138, 'String'
    set $P138, $S101
    concat $P139, $P138, ":anon"
    $P141 = $P135."pirflags"($P139)
.annotate 'line', 2061
    set $P132, $P141
  if_3228_end:
.annotate 'line', 2060
    set $P128, $P132
.annotate 'line', 2058
    goto if_3227_end
  if_3227:
.annotate 'line', 2059
    find_dynamic_lex $P134, "$*SC"
    unless_null $P134, vivify_2712
    get_hll_global $P132, "GLOBAL"
    get_who $P133, $P132
    set $P134, $P133["$SC"]
    unless_null $P134, vivify_2713
    die "Contextual $*SC not found"
  vivify_2713:
  vivify_2712:
    find_dynamic_lex $P137, "$*PACKAGE"
    unless_null $P137, vivify_2714
    get_hll_global $P135, "GLOBAL"
    get_who $P136, $P135
    set $P137, $P136["$PACKAGE"]
    unless_null $P137, vivify_2715
    die "Contextual $*PACKAGE not found"
  vivify_2715:
  vivify_2714:
    find_lex $P138, "$name"
    unless_null $P138, vivify_2716
    new $P138, "Undef"
  vivify_2716:
    find_lex $P139, "$past"
    unless_null $P139, vivify_2717
    new $P139, "Undef"
  vivify_2717:
    $P140 = $P134."install_package_routine"($P137, $P138, $P139)
.annotate 'line', 2058
    set $P128, $P140
  if_3227_end:
.annotate 'line', 2043
    .return ($P128)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3233"  :anon :subid("553_1310110678.31883") :outer("551_1310110678.31883")
    .param pmc param_3235
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2073
    .lex "$_", param_3235
    find_lex $P129, "$_"
    unless_null $P129, vivify_2726
    new $P129, "Undef"
  vivify_2726:
    $P130 = $P129."ast"()
    find_lex $P131, "$/"
    unless_null $P131, vivify_2727
    new $P131, "Undef"
  vivify_2727:
    $P132 = $P130($P131)
    .return ($P132)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "signature" :anon :subid("554_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3238
    .param pmc param_3239
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2102
    .const 'Sub' $P3254 = "556_1310110678.31883" 
    capture_lex $P3254
    .const 'Sub' $P3246 = "555_1310110678.31883" 
    capture_lex $P3246
    .lex "self", param_3238
    .lex "$/", param_3239
.annotate 'line', 2103
    new $P122, "Undef"
    set $P3240, $P122
    .lex "$BLOCKINIT", $P3240
    find_lex $P123, "$?PACKAGE"
    get_who $P124, $P123
    set $P3241, $P124["@BLOCK"]
    unless_null $P3241, vivify_2728
    $P3241 = root_new ['parrot';'ResizablePMCArray']
  vivify_2728:
    set $P3242, $P3241[0]
    unless_null $P3242, vivify_2729
    $P3242 = root_new ['parrot';'ResizablePMCArray']
  vivify_2729:
    set $P125, $P3242[0]
    unless_null $P125, vivify_2730
    new $P125, "Undef"
  vivify_2730:
    store_lex "$BLOCKINIT", $P125
.annotate 'line', 2104
    find_lex $P3244, "$/"
    unless_null $P3244, vivify_2731
    $P3244 = root_new ['parrot';'Hash']
  vivify_2731:
    set $P123, $P3244["invocant"]
    unless_null $P123, vivify_2732
    new $P123, "Undef"
  vivify_2732:
    unless $P123, if_3243_end
    .const 'Sub' $P3246 = "555_1310110678.31883" 
    capture_lex $P3246
    $P3246()
  if_3243_end:
.annotate 'line', 2113
    find_lex $P3252, "$/"
    unless_null $P3252, vivify_2742
    $P3252 = root_new ['parrot';'Hash']
  vivify_2742:
    set $P124, $P3252["parameter"]
    unless_null $P124, vivify_2743
    new $P124, "Undef"
  vivify_2743:
    defined $I100, $P124
    unless $I100, for_undef_2744
    iter $P123, $P124
    new $P127, 'ExceptionHandler'
    set_label $P127, loop3256_handler
    $P127."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P127
  loop3256_test:
    unless $P123, loop3256_done
    shift $P125, $P123
  loop3256_redo:
    .const 'Sub' $P3254 = "556_1310110678.31883" 
    capture_lex $P3254
    $P3254($P125)
  loop3256_next:
    goto loop3256_test
  loop3256_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P128, exception, 'type'
    eq $P128, .CONTROL_LOOP_NEXT, loop3256_next
    eq $P128, .CONTROL_LOOP_REDO, loop3256_redo
  loop3256_done:
    pop_eh 
  for_undef_2744:
.annotate 'line', 2102
    .return ($P123)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3245"  :anon :subid("555_1310110678.31883") :outer("554_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2105
    new $P124, "Undef"
    set $P3247, $P124
    .lex "$inv", $P3247
    find_lex $P3248, "$/"
    unless_null $P3248, vivify_2733
    $P3248 = root_new ['parrot';'Hash']
  vivify_2733:
    set $P3249, $P3248["invocant"]
    unless_null $P3249, vivify_2734
    $P3249 = root_new ['parrot';'ResizablePMCArray']
  vivify_2734:
    set $P125, $P3249[0]
    unless_null $P125, vivify_2735
    new $P125, "Undef"
  vivify_2735:
    $P127 = $P125."ast"()
    store_lex "$inv", $P127
.annotate 'line', 2106
    find_lex $P125, "$BLOCKINIT"
    unless_null $P125, vivify_2736
    new $P125, "Undef"
  vivify_2736:
    find_lex $P127, "$inv"
    unless_null $P127, vivify_2737
    new $P127, "Undef"
  vivify_2737:
    $P125."push"($P127)
.annotate 'line', 2107
    find_lex $P125, "$BLOCKINIT"
    unless_null $P125, vivify_2738
    new $P125, "Undef"
  vivify_2738:
    get_hll_global $P127, "GLOBAL"
    nqp_get_package_through_who $P128, $P127, "PAST"
    get_who $P129, $P128
    set $P130, $P129["Var"]
.annotate 'line', 2109
    get_hll_global $P131, "GLOBAL"
    nqp_get_package_through_who $P132, $P131, "PAST"
    get_who $P133, $P132
    set $P134, $P133["Var"]
    find_lex $P135, "$inv"
    unless_null $P135, vivify_2739
    new $P135, "Undef"
  vivify_2739:
    $P136 = $P135."name"()
    $P137 = $P134."new"("lexical" :named("scope"), $P136 :named("name"))
.annotate 'line', 2107
    $P138 = $P130."new"("self" :named("name"), "lexical" :named("scope"), 1 :named("isdecl"), $P137 :named("viviself"))
    $P125."push"($P138)
.annotate 'line', 2111
    new $P125, "Integer"
    assign $P125, 1
    find_lex $P127, "$?PACKAGE"
    get_who $P128, $P127
    set $P3250, $P128["@BLOCK"]
    unless_null $P3250, vivify_2740
    $P3250 = root_new ['parrot';'ResizablePMCArray']
    set $P128["@BLOCK"], $P3250
  vivify_2740:
    set $P3251, $P3250[0]
    unless_null $P3251, vivify_2741
    $P3251 = root_new ['parrot';'Hash']
    set $P3250[0], $P3251
  vivify_2741:
    set $P3251["signature_has_invocant"], $P125
.annotate 'line', 2104
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3253"  :anon :subid("556_1310110678.31883") :outer("554_1310110678.31883")
    .param pmc param_3255
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2113
    .lex "$_", param_3255
    find_lex $P127, "$BLOCKINIT"
    unless_null $P127, vivify_2745
    new $P127, "Undef"
  vivify_2745:
    find_lex $P128, "$_"
    unless_null $P128, vivify_2746
    new $P128, "Undef"
  vivify_2746:
    $P129 = $P128."ast"()
    $P130 = $P127."push"($P129)
    .return ($P130)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "parameter" :anon :subid("557_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3258
    .param pmc param_3259
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2116
    .lex "self", param_3258
    .lex "$/", param_3259
.annotate 'line', 2117
    new $P122, "Undef"
    set $P3260, $P122
    .lex "$quant", $P3260
.annotate 'line', 2118
    new $P123, "Undef"
    set $P3261, $P123
    .lex "$past", $P3261
.annotate 'line', 2117
    find_lex $P3262, "$/"
    unless_null $P3262, vivify_2747
    $P3262 = root_new ['parrot';'Hash']
  vivify_2747:
    set $P124, $P3262["quant"]
    unless_null $P124, vivify_2748
    new $P124, "Undef"
  vivify_2748:
    store_lex "$quant", $P124
.annotate 'line', 2116
    find_lex $P124, "$past"
    unless_null $P124, vivify_2749
    new $P124, "Undef"
  vivify_2749:
.annotate 'line', 2119
    find_lex $P3264, "$/"
    unless_null $P3264, vivify_2750
    $P3264 = root_new ['parrot';'Hash']
  vivify_2750:
    set $P124, $P3264["named_param"]
    unless_null $P124, vivify_2751
    new $P124, "Undef"
  vivify_2751:
    if $P124, if_3263
.annotate 'line', 2126
    find_lex $P3270, "$/"
    unless_null $P3270, vivify_2752
    $P3270 = root_new ['parrot';'Hash']
  vivify_2752:
    set $P125, $P3270["param_var"]
    unless_null $P125, vivify_2753
    new $P125, "Undef"
  vivify_2753:
    $P127 = $P125."ast"()
    store_lex "$past", $P127
.annotate 'line', 2127
    find_lex $P125, "$quant"
    unless_null $P125, vivify_2754
    new $P125, "Undef"
  vivify_2754:
    set $S100, $P125
    iseq $I100, $S100, "*"
    if $I100, if_3271
.annotate 'line', 2131
    find_lex $P127, "$quant"
    unless_null $P127, vivify_2755
    new $P127, "Undef"
  vivify_2755:
    set $S101, $P127
    iseq $I101, $S101, "?"
    unless $I101, if_3274_end
.annotate 'line', 2132
    find_lex $P128, "$past"
    unless_null $P128, vivify_2756
    new $P128, "Undef"
  vivify_2756:
    find_lex $P3275, "$/"
    unless_null $P3275, vivify_2757
    $P3275 = root_new ['parrot';'Hash']
  vivify_2757:
    set $P3276, $P3275["param_var"]
    unless_null $P3276, vivify_2758
    $P3276 = root_new ['parrot';'Hash']
  vivify_2758:
    set $P129, $P3276["sigil"]
    unless_null $P129, vivify_2759
    new $P129, "Undef"
  vivify_2759:
    $P130 = "vivitype"($P129)
    $P128."viviself"($P130)
  if_3274_end:
.annotate 'line', 2131
    goto if_3271_end
  if_3271:
.annotate 'line', 2128
    find_lex $P127, "$past"
    unless_null $P127, vivify_2760
    new $P127, "Undef"
  vivify_2760:
    $P127."slurpy"(1)
.annotate 'line', 2129
    find_lex $P127, "$past"
    unless_null $P127, vivify_2761
    new $P127, "Undef"
  vivify_2761:
    find_lex $P3272, "$/"
    unless_null $P3272, vivify_2762
    $P3272 = root_new ['parrot';'Hash']
  vivify_2762:
    set $P3273, $P3272["param_var"]
    unless_null $P3273, vivify_2763
    $P3273 = root_new ['parrot';'Hash']
  vivify_2763:
    set $P128, $P3273["sigil"]
    unless_null $P128, vivify_2764
    new $P128, "Undef"
  vivify_2764:
    set $S101, $P128
    iseq $I101, $S101, "%"
    $P127."named"($I101)
  if_3271_end:
.annotate 'line', 2125
    goto if_3263_end
  if_3263:
.annotate 'line', 2120
    find_lex $P3265, "$/"
    unless_null $P3265, vivify_2765
    $P3265 = root_new ['parrot';'Hash']
  vivify_2765:
    set $P125, $P3265["named_param"]
    unless_null $P125, vivify_2766
    new $P125, "Undef"
  vivify_2766:
    $P127 = $P125."ast"()
    store_lex "$past", $P127
.annotate 'line', 2121
    find_lex $P125, "$quant"
    unless_null $P125, vivify_2767
    new $P125, "Undef"
  vivify_2767:
    set $S100, $P125
    isne $I100, $S100, "!"
    unless $I100, if_3266_end
.annotate 'line', 2122
    find_lex $P127, "$past"
    unless_null $P127, vivify_2768
    new $P127, "Undef"
  vivify_2768:
    find_lex $P3267, "$/"
    unless_null $P3267, vivify_2769
    $P3267 = root_new ['parrot';'Hash']
  vivify_2769:
    set $P3268, $P3267["named_param"]
    unless_null $P3268, vivify_2770
    $P3268 = root_new ['parrot';'Hash']
  vivify_2770:
    set $P3269, $P3268["param_var"]
    unless_null $P3269, vivify_2771
    $P3269 = root_new ['parrot';'Hash']
  vivify_2771:
    set $P128, $P3269["sigil"]
    unless_null $P128, vivify_2772
    new $P128, "Undef"
  vivify_2772:
    $P129 = "vivitype"($P128)
    $P127."viviself"($P129)
  if_3266_end:
  if_3263_end:
.annotate 'line', 2135
    find_lex $P3278, "$/"
    unless_null $P3278, vivify_2773
    $P3278 = root_new ['parrot';'Hash']
  vivify_2773:
    set $P124, $P3278["default_value"]
    unless_null $P124, vivify_2774
    new $P124, "Undef"
  vivify_2774:
    unless $P124, if_3277_end
.annotate 'line', 2136
    find_lex $P125, "$quant"
    unless_null $P125, vivify_2775
    new $P125, "Undef"
  vivify_2775:
    set $S100, $P125
    iseq $I100, $S100, "*"
    unless $I100, if_3279_end
.annotate 'line', 2137
    find_lex $P127, "$/"
    unless_null $P127, vivify_2776
    new $P127, "Undef"
  vivify_2776:
    $P128 = $P127."CURSOR"()
    $P128."panic"("Can't put default on slurpy parameter")
  if_3279_end:
.annotate 'line', 2139
    find_lex $P125, "$quant"
    unless_null $P125, vivify_2777
    new $P125, "Undef"
  vivify_2777:
    set $S100, $P125
    iseq $I100, $S100, "!"
    unless $I100, if_3280_end
.annotate 'line', 2140
    find_lex $P127, "$/"
    unless_null $P127, vivify_2778
    new $P127, "Undef"
  vivify_2778:
    $P128 = $P127."CURSOR"()
    $P128."panic"("Can't put default on required parameter")
  if_3280_end:
.annotate 'line', 2142
    find_lex $P125, "$past"
    unless_null $P125, vivify_2779
    new $P125, "Undef"
  vivify_2779:
    find_lex $P3281, "$/"
    unless_null $P3281, vivify_2780
    $P3281 = root_new ['parrot';'Hash']
  vivify_2780:
    set $P3282, $P3281["default_value"]
    unless_null $P3282, vivify_2781
    $P3282 = root_new ['parrot';'ResizablePMCArray']
  vivify_2781:
    set $P3283, $P3282[0]
    unless_null $P3283, vivify_2782
    $P3283 = root_new ['parrot';'Hash']
  vivify_2782:
    set $P127, $P3283["EXPR"]
    unless_null $P127, vivify_2783
    new $P127, "Undef"
  vivify_2783:
    $P128 = $P127."ast"()
    $P125."viviself"($P128)
  if_3277_end:
.annotate 'line', 2144
    find_lex $P124, "$past"
    unless_null $P124, vivify_2784
    new $P124, "Undef"
  vivify_2784:
    $P125 = $P124."viviself"()
    if $P125, unless_3284_end
    find_lex $P127, "$?PACKAGE"
    get_who $P128, $P127
    set $P3285, $P128["@BLOCK"]
    unless_null $P3285, vivify_2785
    $P3285 = root_new ['parrot';'ResizablePMCArray']
  vivify_2785:
    set $P129, $P3285[0]
    unless_null $P129, vivify_2786
    new $P129, "Undef"
  vivify_2786:
    find_lex $P130, "$?PACKAGE"
    get_who $P131, $P130
    set $P3286, $P131["@BLOCK"]
    unless_null $P3286, vivify_2787
    $P3286 = root_new ['parrot';'ResizablePMCArray']
  vivify_2787:
    set $P132, $P3286[0]
    unless_null $P132, vivify_2788
    new $P132, "Undef"
  vivify_2788:
    $P133 = $P132."arity"()
    set $N100, $P133
    new $P134, 'Float'
    set $P134, $N100
    add $P135, $P134, 1
    $P129."arity"($P135)
  unless_3284_end:
.annotate 'line', 2148
    find_lex $P3288, "$/"
    unless_null $P3288, vivify_2789
    $P3288 = root_new ['parrot';'Hash']
  vivify_2789:
    set $P124, $P3288["typename"]
    unless_null $P124, vivify_2790
    new $P124, "Undef"
  vivify_2790:
    unless $P124, if_3287_end
.annotate 'line', 2149
    find_lex $P125, "$past"
    unless_null $P125, vivify_2791
    new $P125, "Undef"
  vivify_2791:
    find_lex $P3289, "$/"
    unless_null $P3289, vivify_2792
    $P3289 = root_new ['parrot';'Hash']
  vivify_2792:
    set $P3290, $P3289["typename"]
    unless_null $P3290, vivify_2793
    $P3290 = root_new ['parrot';'ResizablePMCArray']
  vivify_2793:
    set $P127, $P3290[0]
    unless_null $P127, vivify_2794
    new $P127, "Undef"
  vivify_2794:
    $P128 = $P127."ast"()
    $P125."multitype"($P128)
  if_3287_end:
.annotate 'line', 2153
    find_lex $P3292, "$/"
    unless_null $P3292, vivify_2795
    $P3292 = root_new ['parrot';'Hash']
  vivify_2795:
    set $P124, $P3292["definedness"]
    unless_null $P124, vivify_2796
    new $P124, "Undef"
  vivify_2796:
    unless $P124, if_3291_end
.annotate 'line', 2154
    find_lex $P3293, "$/"
    unless_null $P3293, vivify_2797
    $P3293 = root_new ['parrot';'Hash']
  vivify_2797:
    set $P3294, $P3293["definedness"]
    unless_null $P3294, vivify_2798
    $P3294 = root_new ['parrot';'ResizablePMCArray']
  vivify_2798:
    set $P125, $P3294[0]
    unless_null $P125, vivify_2799
    new $P125, "Undef"
  vivify_2799:
    set $S100, $P125
    new $P127, 'String'
    set $P127, $S100
    find_lex $P3295, "$past"
    unless_null $P3295, vivify_2800
    $P3295 = root_new ['parrot';'Hash']
    store_lex "$past", $P3295
  vivify_2800:
    set $P3295["definedness"], $P127
  if_3291_end:
.annotate 'line', 2157
    find_lex $P124, "$/"
    find_lex $P125, "$past"
    unless_null $P125, vivify_2801
    new $P125, "Undef"
  vivify_2801:
    $P127 = $P124."!make"($P125)
.annotate 'line', 2116
    .return ($P127)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "param_var" :anon :subid("558_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3297
    .param pmc param_3298
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2160
    .lex "self", param_3297
    .lex "$/", param_3298
.annotate 'line', 2161
    new $P122, "Undef"
    set $P3299, $P122
    .lex "$name", $P3299
.annotate 'line', 2162
    new $P123, "Undef"
    set $P3300, $P123
    .lex "$past", $P3300
.annotate 'line', 2161
    find_lex $P124, "$/"
    unless_null $P124, vivify_2802
    new $P124, "Undef"
  vivify_2802:
    set $S100, $P124
    new $P125, 'String'
    set $P125, $S100
    store_lex "$name", $P125
.annotate 'line', 2162
    get_hll_global $P124, "GLOBAL"
    nqp_get_package_through_who $P125, $P124, "PAST"
    get_who $P127, $P125
    set $P128, $P127["Var"]
    find_lex $P129, "$name"
    unless_null $P129, vivify_2803
    new $P129, "Undef"
  vivify_2803:
    find_lex $P130, "$/"
    unless_null $P130, vivify_2804
    new $P130, "Undef"
  vivify_2804:
    $P131 = $P128."new"($P129 :named("name"), "parameter" :named("scope"), 1 :named("isdecl"), $P130 :named("node"))
    store_lex "$past", $P131
.annotate 'line', 2164
    find_lex $P124, "$?PACKAGE"
    get_who $P125, $P124
    set $P3301, $P125["@BLOCK"]
    unless_null $P3301, vivify_2805
    $P3301 = root_new ['parrot';'ResizablePMCArray']
  vivify_2805:
    set $P127, $P3301[0]
    unless_null $P127, vivify_2806
    new $P127, "Undef"
  vivify_2806:
    find_lex $P128, "$name"
    unless_null $P128, vivify_2807
    new $P128, "Undef"
  vivify_2807:
    $P127."symbol"($P128, "lexical" :named("scope"))
.annotate 'line', 2165
    find_lex $P124, "$/"
    find_lex $P125, "$past"
    unless_null $P125, vivify_2808
    new $P125, "Undef"
  vivify_2808:
    $P127 = $P124."!make"($P125)
.annotate 'line', 2160
    .return ($P127)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "named_param" :anon :subid("559_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3303
    .param pmc param_3304
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2168
    .lex "self", param_3303
    .lex "$/", param_3304
.annotate 'line', 2169
    new $P122, "Undef"
    set $P3305, $P122
    .lex "$past", $P3305
    find_lex $P3306, "$/"
    unless_null $P3306, vivify_2809
    $P3306 = root_new ['parrot';'Hash']
  vivify_2809:
    set $P123, $P3306["param_var"]
    unless_null $P123, vivify_2810
    new $P123, "Undef"
  vivify_2810:
    $P124 = $P123."ast"()
    store_lex "$past", $P124
.annotate 'line', 2170
    find_lex $P123, "$past"
    unless_null $P123, vivify_2811
    new $P123, "Undef"
  vivify_2811:
    find_lex $P3307, "$/"
    unless_null $P3307, vivify_2812
    $P3307 = root_new ['parrot';'Hash']
  vivify_2812:
    set $P3308, $P3307["param_var"]
    unless_null $P3308, vivify_2813
    $P3308 = root_new ['parrot';'Hash']
  vivify_2813:
    set $P124, $P3308["name"]
    unless_null $P124, vivify_2814
    new $P124, "Undef"
  vivify_2814:
    set $S100, $P124
    $P123."named"($S100)
.annotate 'line', 2171
    find_lex $P123, "$/"
    find_lex $P124, "$past"
    unless_null $P124, vivify_2815
    new $P124, "Undef"
  vivify_2815:
    $P125 = $P123."!make"($P124)
.annotate 'line', 2168
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "typename" :anon :subid("560_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3310
    .param pmc param_3311
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2174
    .const 'Sub' $P3316 = "561_1310110678.31883" 
    capture_lex $P3316
    .lex "self", param_3310
    .lex "$/", param_3311
.annotate 'line', 2178
    $P3313 = root_new ['parrot';'ResizablePMCArray']
    set $P3312, $P3313
    .lex "@name", $P3312
.annotate 'line', 2179
    new $P122, "Undef"
    set $P3314, $P122
    .lex "$found", $P3314
.annotate 'line', 2178
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "HLL"
    get_who $P125, $P124
    set $P127, $P125["Compiler"]
    find_lex $P128, "$/"
    unless_null $P128, vivify_2816
    new $P128, "Undef"
  vivify_2816:
    set $S100, $P128
    $P129 = $P127."parse_name"($S100)
    store_lex "@name", $P129
.annotate 'line', 2179
    new $P123, "Integer"
    assign $P123, 0
    store_lex "$found", $P123
.annotate 'line', 2180
    .const 'Sub' $P3316 = "561_1310110678.31883" 
    capture_lex $P3316
    $P3316()
.annotate 'line', 2185
    find_lex $P124, "$found"
    unless_null $P124, vivify_2822
    new $P124, "Undef"
  vivify_2822:
    unless $P124, unless_3326
    set $P123, $P124
    goto unless_3326_end
  unless_3326:
.annotate 'line', 2186
    find_lex $P125, "$/"
    unless_null $P125, vivify_2823
    new $P125, "Undef"
  vivify_2823:
    $P127 = $P125."CURSOR"()
    new $P128, "String"
    assign $P128, "Use of undeclared type '"
    find_lex $P129, "$/"
    unless_null $P129, vivify_2824
    new $P129, "Undef"
  vivify_2824:
    set $S100, $P129
    concat $P130, $P128, $S100
    concat $P131, $P130, "'"
    $P132 = $P127."panic"($P131)
.annotate 'line', 2185
    set $P123, $P132
  unless_3326_end:
.annotate 'line', 2174
    .return ($P123)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3315"  :anon :subid("561_1310110678.31883") :outer("560_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2180
    new $P3321, 'ExceptionHandler'
    set_label $P3321, control_3320
    $P3321."handle_types_except"(.CONTROL_RETURN,  .CONTROL_OK,  .CONTROL_BREAK,  .CONTROL_CONTINUE,  .CONTROL_TAKE,  .CONTROL_LEAVE,  .CONTROL_EXIT,  .CONTROL_LOOP_NEXT,  .CONTROL_LOOP_LAST,  .CONTROL_LOOP_REDO)
    push_eh $P3321
.annotate 'line', 2181
    new $P123, "Undef"
    set $P3317, $P123
    .lex "$sym", $P3317
    find_lex $P3318, "@name"
    unless_null $P3318, vivify_2817
    $P3318 = root_new ['parrot';'ResizablePMCArray']
  vivify_2817:
    find_lex $P124, "$/"
    unless_null $P124, vivify_2818
    new $P124, "Undef"
  vivify_2818:
    $P125 = "find_sym"($P3318, $P124)
    store_lex "$sym", $P125
.annotate 'line', 2182
    find_dynamic_lex $P124, "$/"
    find_dynamic_lex $P128, "$*SC"
    unless_null $P128, vivify_2819
    get_hll_global $P125, "GLOBAL"
    get_who $P127, $P125
    set $P128, $P127["$SC"]
    unless_null $P128, vivify_2820
    die "Contextual $*SC not found"
  vivify_2820:
  vivify_2819:
    find_lex $P129, "$sym"
    unless_null $P129, vivify_2821
    new $P129, "Undef"
  vivify_2821:
    $P130 = $P128."get_object_sc_ref_past"($P129)
    $P124."!make"($P130)
.annotate 'line', 2183
    new $P124, "Integer"
    assign $P124, 1
    store_lex "$found", $P124
.annotate 'line', 2180
    pop_eh 
    goto skip_handler_3319
  control_3320:
    .local pmc exception 
    .get_results (exception) 
    new $P3324, 'Integer'
    set $P3324, 1
    set exception["handled"], $P3324
    set $I3325, exception["handled"]
    ne $I3325, 1, nothandled_3323
  handled_3322:
    .return (exception)
  nothandled_3323:
    rethrow exception
  skip_handler_3319:
    .return ($P124)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait" :anon :subid("562_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3328
    .param pmc param_3329
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2190
    .lex "self", param_3328
    .lex "$/", param_3329
.annotate 'line', 2191
    find_lex $P122, "$/"
    find_lex $P3330, "$/"
    unless_null $P3330, vivify_2825
    $P3330 = root_new ['parrot';'Hash']
  vivify_2825:
    set $P123, $P3330["trait_mod"]
    unless_null $P123, vivify_2826
    new $P123, "Undef"
  vivify_2826:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
.annotate 'line', 2190
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait_mod:sym<is>" :anon :subid("563_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3332
    .param pmc param_3333
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2194
    .const 'Sub' $P3352 = "566_1310110678.31883" 
    capture_lex $P3352
    .const 'Sub' $P3337 = "564_1310110678.31883" 
    capture_lex $P3337
    .lex "self", param_3332
    .lex "$/", param_3333
.annotate 'line', 2195
    find_lex $P3335, "$/"
    unless_null $P3335, vivify_2827
    $P3335 = root_new ['parrot';'Hash']
  vivify_2827:
    set $P123, $P3335["longname"]
    unless_null $P123, vivify_2828
    new $P123, "Undef"
  vivify_2828:
    set $S100, $P123
    iseq $I100, $S100, "parrot_vtable"
    if $I100, if_3334
.annotate 'line', 2208
    find_lex $P3350, "$/"
    unless_null $P3350, vivify_2829
    $P3350 = root_new ['parrot';'Hash']
  vivify_2829:
    set $P132, $P3350["longname"]
    unless_null $P132, vivify_2830
    new $P132, "Undef"
  vivify_2830:
    set $S101, $P132
    iseq $I101, $S101, "parrot_vtable_handler"
    if $I101, if_3349
.annotate 'line', 2219
    find_lex $P3365, "$/"
    unless_null $P3365, vivify_2831
    $P3365 = root_new ['parrot';'Hash']
  vivify_2831:
    set $P139, $P3365["longname"]
    unless_null $P139, vivify_2832
    new $P139, "Undef"
  vivify_2832:
    set $S102, $P139
    iseq $I102, $S102, "pirflags"
    if $I102, if_3364
.annotate 'line', 2223
    find_lex $P140, "$/"
    unless_null $P140, vivify_2833
    new $P140, "Undef"
  vivify_2833:
    $P141 = $P140."CURSOR"()
    new $P143, 'String'
    set $P143, "Trait '"
    find_lex $P3366, "$/"
    unless_null $P3366, vivify_2834
    $P3366 = root_new ['parrot';'Hash']
  vivify_2834:
    set $P144, $P3366["longname"]
    unless_null $P144, vivify_2835
    new $P144, "Undef"
  vivify_2835:
    concat $P145, $P143, $P144
    concat $P146, $P145, "' not implemented"
    $P147 = $P141."panic"($P146)
.annotate 'line', 2222
    set $P138, $P147
.annotate 'line', 2219
    goto if_3364_end
  if_3364:
.annotate 'line', 2220
    find_lex $P140, "$/"
    unless_null $P140, vivify_2836
    new $P140, "Undef"
  vivify_2836:
    $P141 = $P140."CURSOR"()
    $P142 = $P141."panic"("Trait 'pirflags' no longer supported; use 'is vtable'")
.annotate 'line', 2219
    set $P138, $P142
  if_3364_end:
    set $P131, $P138
.annotate 'line', 2208
    goto if_3349_end
  if_3349:
    .const 'Sub' $P3352 = "566_1310110678.31883" 
    capture_lex $P3352
    $P136 = $P3352()
    set $P131, $P136
  if_3349_end:
    set $P122, $P131
.annotate 'line', 2195
    goto if_3334_end
  if_3334:
    .const 'Sub' $P3337 = "564_1310110678.31883" 
    capture_lex $P3337
    $P129 = $P3337()
    set $P122, $P129
  if_3334_end:
.annotate 'line', 2194
    .return ($P122)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3351"  :anon :subid("566_1310110678.31883") :outer("563_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2208
    .const 'Sub' $P3360 = "567_1310110678.31883" 
    capture_lex $P3360
.annotate 'line', 2210
    new $P133, "Undef"
    set $P3353, $P133
    .lex "$cpast", $P3353
.annotate 'line', 2213
    new $P134, "Undef"
    set $P3354, $P134
    .lex "$name", $P3354
.annotate 'line', 2214
    new $P135, "Undef"
    set $P3355, $P135
    .lex "$package", $P3355
.annotate 'line', 2210
    find_lex $P3356, "$/"
    unless_null $P3356, vivify_2837
    $P3356 = root_new ['parrot';'Hash']
  vivify_2837:
    set $P3357, $P3356["circumfix"]
    unless_null $P3357, vivify_2838
    $P3357 = root_new ['parrot';'ResizablePMCArray']
  vivify_2838:
    set $P136, $P3357[0]
    unless_null $P136, vivify_2839
    new $P136, "Undef"
  vivify_2839:
    $P137 = $P136."ast"()
    store_lex "$cpast", $P137
.annotate 'line', 2212
    get_hll_global $P136, "GLOBAL"
    nqp_get_package_through_who $P137, $P136, "PAST"
    get_who $P138, $P137
    set $P139, $P138["Val"]
    find_lex $P140, "$cpast"
    unless_null $P140, vivify_2840
    new $P140, "Undef"
  vivify_2840:
    $P141 = $P139."ACCEPTS"($P140)
    if $P141, unless_3358_end
.annotate 'line', 2211
    find_lex $P142, "$/"
    unless_null $P142, vivify_2841
    new $P142, "Undef"
  vivify_2841:
    $P143 = $P142."CURSOR"()
    $P143."panic"("Trait 'parrot_vtable_handler' requires constant scalar argument")
  unless_3358_end:
.annotate 'line', 2213
    find_lex $P136, "$cpast"
    unless_null $P136, vivify_2842
    new $P136, "Undef"
  vivify_2842:
    $P137 = $P136."value"()
    store_lex "$name", $P137
.annotate 'line', 2214
    find_dynamic_lex $P138, "$*PACKAGE"
    unless_null $P138, vivify_2843
    get_hll_global $P136, "GLOBAL"
    get_who $P137, $P136
    set $P138, $P137["$PACKAGE"]
    unless_null $P138, vivify_2844
    die "Contextual $*PACKAGE not found"
  vivify_2844:
  vivify_2843:
    store_lex "$package", $P138
.annotate 'line', 2215
    find_dynamic_lex $P136, "$/"
    .const 'Sub' $P3360 = "567_1310110678.31883" 
    newclosure $P3363, $P3360
    $P137 = $P136."!make"($P3363)
.annotate 'line', 2208
    .return ($P137)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3359"  :anon :subid("567_1310110678.31883") :outer("566_1310110678.31883")
    .param pmc param_3361
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2215
    .lex "$match", param_3361
.annotate 'line', 2216
    find_dynamic_lex $P139, "$*SC"
    unless_null $P139, vivify_2845
    get_hll_global $P137, "GLOBAL"
    get_who $P138, $P137
    set $P139, $P138["$SC"]
    unless_null $P139, vivify_2846
    die "Contextual $*SC not found"
  vivify_2846:
  vivify_2845:
    find_lex $P140, "$package"
    unless_null $P140, vivify_2847
    new $P140, "Undef"
  vivify_2847:
    find_lex $P141, "$name"
    unless_null $P141, vivify_2848
    new $P141, "Undef"
  vivify_2848:
    find_lex $P3362, "$match"
    unless_null $P3362, vivify_2849
    $P3362 = root_new ['parrot';'Hash']
  vivify_2849:
    set $P142, $P3362["variable"]
    unless_null $P142, vivify_2850
    new $P142, "Undef"
  vivify_2850:
    set $S102, $P142
    $P143 = $P139."pkg_add_parrot_vtable_handler_mapping"($P140, $P141, $S102)
.annotate 'line', 2215
    .return ($P143)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3336"  :anon :subid("564_1310110678.31883") :outer("563_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2195
    .const 'Sub' $P3346 = "565_1310110678.31883" 
    capture_lex $P3346
.annotate 'line', 2197
    new $P124, "Undef"
    set $P3338, $P124
    .lex "$cpast", $P3338
.annotate 'line', 2200
    new $P125, "Undef"
    set $P3339, $P125
    .lex "$name", $P3339
.annotate 'line', 2201
    new $P127, "Undef"
    set $P3340, $P127
    .lex "$package", $P3340
.annotate 'line', 2202
    new $P128, "Undef"
    set $P3341, $P128
    .lex "$is_dispatcher", $P3341
.annotate 'line', 2197
    find_lex $P3342, "$/"
    unless_null $P3342, vivify_2851
    $P3342 = root_new ['parrot';'Hash']
  vivify_2851:
    set $P3343, $P3342["circumfix"]
    unless_null $P3343, vivify_2852
    $P3343 = root_new ['parrot';'ResizablePMCArray']
  vivify_2852:
    set $P129, $P3343[0]
    unless_null $P129, vivify_2853
    new $P129, "Undef"
  vivify_2853:
    $P130 = $P129."ast"()
    store_lex "$cpast", $P130
.annotate 'line', 2199
    get_hll_global $P129, "GLOBAL"
    nqp_get_package_through_who $P130, $P129, "PAST"
    get_who $P131, $P130
    set $P132, $P131["Val"]
    find_lex $P133, "$cpast"
    unless_null $P133, vivify_2854
    new $P133, "Undef"
  vivify_2854:
    $P134 = $P132."ACCEPTS"($P133)
    if $P134, unless_3344_end
.annotate 'line', 2198
    find_lex $P135, "$/"
    unless_null $P135, vivify_2855
    new $P135, "Undef"
  vivify_2855:
    $P136 = $P135."CURSOR"()
    $P136."panic"("Trait 'parrot_vtable' requires constant scalar argument")
  unless_3344_end:
.annotate 'line', 2200
    find_lex $P129, "$cpast"
    unless_null $P129, vivify_2856
    new $P129, "Undef"
  vivify_2856:
    $P130 = $P129."value"()
    store_lex "$name", $P130
.annotate 'line', 2201
    find_dynamic_lex $P131, "$*PACKAGE"
    unless_null $P131, vivify_2857
    get_hll_global $P129, "GLOBAL"
    get_who $P130, $P129
    set $P131, $P130["$PACKAGE"]
    unless_null $P131, vivify_2858
    die "Contextual $*PACKAGE not found"
  vivify_2858:
  vivify_2857:
    store_lex "$package", $P131
.annotate 'line', 2202
    find_dynamic_lex $P131, "$*SCOPE"
    unless_null $P131, vivify_2859
    get_hll_global $P129, "GLOBAL"
    get_who $P130, $P129
    set $P131, $P130["$SCOPE"]
    unless_null $P131, vivify_2860
    die "Contextual $*SCOPE not found"
  vivify_2860:
  vivify_2859:
    set $S101, $P131
    iseq $I101, $S101, "proto"
    new $P132, 'Integer'
    set $P132, $I101
    store_lex "$is_dispatcher", $P132
.annotate 'line', 2203
    find_dynamic_lex $P129, "$/"
    .const 'Sub' $P3346 = "565_1310110678.31883" 
    newclosure $P3348, $P3346
    $P130 = $P129."!make"($P3348)
.annotate 'line', 2195
    .return ($P130)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3345"  :anon :subid("565_1310110678.31883") :outer("564_1310110678.31883")
    .param pmc param_3347
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2203
    .lex "$match", param_3347
.annotate 'line', 2204
    find_dynamic_lex $P132, "$*SC"
    unless_null $P132, vivify_2861
    get_hll_global $P130, "GLOBAL"
    get_who $P131, $P130
    set $P132, $P131["$SC"]
    unless_null $P132, vivify_2862
    die "Contextual $*SC not found"
  vivify_2862:
  vivify_2861:
    find_lex $P133, "$package"
    unless_null $P133, vivify_2863
    new $P133, "Undef"
  vivify_2863:
    find_lex $P134, "$name"
    unless_null $P134, vivify_2864
    new $P134, "Undef"
  vivify_2864:
.annotate 'line', 2205
    find_lex $P135, "$match"
    unless_null $P135, vivify_2865
    new $P135, "Undef"
  vivify_2865:
    $P136 = $P135."ast"()
    set $P137, $P136["block_past"]
    unless_null $P137, vivify_2866
    new $P137, "Undef"
  vivify_2866:
.annotate 'line', 2204
    find_lex $P138, "$is_dispatcher"
    unless_null $P138, vivify_2867
    new $P138, "Undef"
  vivify_2867:
    $P139 = $P132."pkg_add_method"($P133, "add_parrot_vtable_mapping", $P134, $P137, $P138)
.annotate 'line', 2203
    .return ($P139)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "regex_declarator" :anon :subid("568_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3370
    .param pmc param_3371
    .param pmc param_3372 :optional
    .param int has_param_3372 :opt_flag
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2227
    .const 'Sub' $P3403 = "571_1310110678.31883" 
    capture_lex $P3403
    .const 'Sub' $P3387 = "570_1310110678.31883" 
    capture_lex $P3387
    .const 'Sub' $P3382 = "569_1310110678.31883" 
    capture_lex $P3382
    new $P3369, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P3369, control_3368
    push_eh $P3369
    .lex "self", param_3370
    .lex "$/", param_3371
    if has_param_3372, optparam_2868
    new $P122, "Undef"
    set param_3372, $P122
  optparam_2868:
    .lex "$key", param_3372
.annotate 'line', 2228
    $P3374 = root_new ['parrot';'ResizablePMCArray']
    set $P3373, $P3374
    .lex "@MODIFIERS", $P3373
.annotate 'line', 2229
    new $P123, "Undef"
    set $P3375, $P123
    .lex "$name", $P3375
.annotate 'line', 2230
    new $P124, "Undef"
    set $P3376, $P124
    .lex "$past", $P3376
.annotate 'line', 2228
    get_hll_global $P125, "GLOBAL"
    nqp_get_package_through_who $P127, $P125, "Regex"
    nqp_get_package_through_who $P128, $P127, "P6Regex"
    nqp_get_package_through_who $P129, $P128, "Actions"
    get_who $P130, $P129
    set $P3377, $P130["@MODIFIERS"]
    unless_null $P3377, vivify_2869
    $P3377 = root_new ['parrot';'ResizablePMCArray']
  vivify_2869:
    store_lex "@MODIFIERS", $P3377
.annotate 'line', 2229
    find_lex $P3378, "$/"
    unless_null $P3378, vivify_2870
    $P3378 = root_new ['parrot';'Hash']
  vivify_2870:
    set $P125, $P3378["deflongname"]
    unless_null $P125, vivify_2871
    new $P125, "Undef"
  vivify_2871:
    $P127 = $P125."ast"()
    set $S100, $P127
    new $P128, 'String'
    set $P128, $S100
    store_lex "$name", $P128
.annotate 'line', 2227
    find_lex $P125, "$past"
    unless_null $P125, vivify_2872
    new $P125, "Undef"
  vivify_2872:
.annotate 'line', 2231
    find_lex $P3380, "$/"
    unless_null $P3380, vivify_2873
    $P3380 = root_new ['parrot';'Hash']
  vivify_2873:
    set $P125, $P3380["proto"]
    unless_null $P125, vivify_2874
    new $P125, "Undef"
  vivify_2874:
    if $P125, if_3379
.annotate 'line', 2261
    find_lex $P127, "$key"
    unless_null $P127, vivify_2875
    new $P127, "Undef"
  vivify_2875:
    set $S100, $P127
    iseq $I100, $S100, "open"
    if $I100, if_3385
.annotate 'line', 2271
    .const 'Sub' $P3403 = "571_1310110678.31883" 
    capture_lex $P3403
    $P3403()
    goto if_3385_end
  if_3385:
.annotate 'line', 2261
    .const 'Sub' $P3387 = "570_1310110678.31883" 
    capture_lex $P3387
    $P3387()
  if_3385_end:
    goto if_3379_end
  if_3379:
.annotate 'line', 2233
    get_hll_global $P127, "GLOBAL"
    nqp_get_package_through_who $P128, $P127, "PAST"
    get_who $P129, $P128
    set $P130, $P129["Stmts"]
.annotate 'line', 2234
    get_hll_global $P131, "GLOBAL"
    nqp_get_package_through_who $P132, $P131, "PAST"
    get_who $P133, $P132
    set $P134, $P133["Block"]
    find_lex $P135, "$name"
    unless_null $P135, vivify_2925
    new $P135, "Undef"
  vivify_2925:
.annotate 'line', 2235
    get_hll_global $P136, "GLOBAL"
    nqp_get_package_through_who $P137, $P136, "PAST"
    get_who $P138, $P137
    set $P139, $P138["Op"]
.annotate 'line', 2236
    get_hll_global $P140, "GLOBAL"
    nqp_get_package_through_who $P141, $P140, "PAST"
    get_who $P142, $P141
    set $P143, $P142["Var"]
    $P144 = $P143."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P145, "$name"
    unless_null $P145, vivify_2926
    new $P145, "Undef"
  vivify_2926:
    $P146 = $P139."new"($P144, $P145, "!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 2235
    find_lex $P147, "$/"
    unless_null $P147, vivify_2927
    new $P147, "Undef"
  vivify_2927:
    $P148 = $P134."new"($P146, $P135 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P147 :named("node"))
.annotate 'line', 2245
    get_hll_global $P150, "GLOBAL"
    nqp_get_package_through_who $P151, $P150, "PAST"
    get_who $P152, $P151
    set $P153, $P152["Block"]
    new $P154, "String"
    assign $P154, "!PREFIX__"
    find_lex $P155, "$name"
    unless_null $P155, vivify_2928
    new $P155, "Undef"
  vivify_2928:
    concat $P156, $P154, $P155
.annotate 'line', 2246
    get_hll_global $P157, "GLOBAL"
    nqp_get_package_through_who $P158, $P157, "PAST"
    get_who $P159, $P158
    set $P160, $P159["Op"]
.annotate 'line', 2247
    get_hll_global $P161, "GLOBAL"
    nqp_get_package_through_who $P162, $P161, "PAST"
    get_who $P163, $P162
    set $P164, $P163["Var"]
    $P165 = $P164."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P166, "$name"
    unless_null $P166, vivify_2929
    new $P166, "Undef"
  vivify_2929:
    $P167 = $P160."new"($P165, $P166, "!PREFIX__!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 2246
    find_lex $P168, "$/"
    unless_null $P168, vivify_2930
    new $P168, "Undef"
  vivify_2930:
    $P169 = $P153."new"($P167, $P156 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P168 :named("node"))
.annotate 'line', 2245
    $P170 = $P130."new"($P148, $P169)
.annotate 'line', 2233
    store_lex "$past", $P170
.annotate 'line', 2257
    find_lex $P128, "$past"
    unless_null $P128, vivify_2931
    new $P128, "Undef"
  vivify_2931:
    $P129 = $P128."list"()
    defined $I100, $P129
    unless $I100, for_undef_2932
    iter $P127, $P129
    new $P131, 'ExceptionHandler'
    set_label $P131, loop3384_handler
    $P131."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P131
  loop3384_test:
    unless $P127, loop3384_done
    shift $P130, $P127
  loop3384_redo:
    .const 'Sub' $P3382 = "569_1310110678.31883" 
    capture_lex $P3382
    $P3382($P130)
  loop3384_next:
    goto loop3384_test
  loop3384_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P132, exception, 'type'
    eq $P132, .CONTROL_LOOP_NEXT, loop3384_next
    eq $P132, .CONTROL_LOOP_REDO, loop3384_redo
  loop3384_done:
    pop_eh 
  for_undef_2932:
  if_3379_end:
.annotate 'line', 2302
    find_lex $P125, "$/"
    find_lex $P127, "$past"
    unless_null $P127, vivify_2939
    new $P127, "Undef"
  vivify_2939:
    $P128 = $P125."!make"($P127)
.annotate 'line', 2227
    .return ($P128)
  control_3368:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P125, exception, "payload"
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3402"  :anon :subid("571_1310110678.31883") :outer("568_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2271
    .const 'Sub' $P3411 = "572_1310110678.31883" 
    capture_lex $P3411
.annotate 'line', 2272
    new $P128, "Undef"
    set $P3404, $P128
    .lex "$regex", $P3404
.annotate 'line', 2275
    new $P129, "Undef"
    set $P3405, $P129
    .lex "$prefix_meth", $P3405
.annotate 'line', 2273
    get_hll_global $P130, "GLOBAL"
    nqp_get_package_through_who $P131, $P130, "Regex"
    nqp_get_package_through_who $P132, $P131, "P6Regex"
    nqp_get_package_through_who $P133, $P132, "Actions"
    get_who $P134, $P133
    set $P135, $P134["buildsub"]
    find_lex $P3406, "$/"
    unless_null $P3406, vivify_2876
    $P3406 = root_new ['parrot';'Hash']
  vivify_2876:
    set $P136, $P3406["p6regex"]
    unless_null $P136, vivify_2877
    new $P136, "Undef"
  vivify_2877:
    $P137 = $P136."ast"()
    find_lex $P138, "$?PACKAGE"
    get_who $P139, $P138
    set $P3407, $P139["@BLOCK"]
    unless_null $P3407, vivify_2878
    $P3407 = root_new ['parrot';'ResizablePMCArray']
  vivify_2878:
    $P140 = $P3407."shift"()
    $P141 = $P135($P137, $P140)
    store_lex "$regex", $P141
.annotate 'line', 2274
    find_lex $P130, "$regex"
    unless_null $P130, vivify_2879
    new $P130, "Undef"
  vivify_2879:
    find_lex $P131, "$name"
    unless_null $P131, vivify_2880
    new $P131, "Undef"
  vivify_2880:
    $P130."name"($P131)
.annotate 'line', 2271
    find_lex $P130, "$prefix_meth"
    unless_null $P130, vivify_2881
    new $P130, "Undef"
  vivify_2881:
.annotate 'line', 2277
    find_dynamic_lex $P133, "$*PKGDECL"
    unless_null $P133, vivify_2882
    get_hll_global $P131, "GLOBAL"
    get_who $P132, $P131
    set $P133, $P132["$PKGDECL"]
    unless_null $P133, vivify_2883
    die "Contextual $*PKGDECL not found"
  vivify_2883:
  vivify_2882:
    if $P133, if_3409
    set $P130, $P133
    goto if_3409_end
  if_3409:
    find_dynamic_lex $P136, "$*PACKAGE"
    unless_null $P136, vivify_2884
    get_hll_global $P134, "GLOBAL"
    get_who $P135, $P134
    set $P136, $P135["$PACKAGE"]
    unless_null $P136, vivify_2885
    die "Contextual $*PACKAGE not found"
  vivify_2885:
  vivify_2884:
    get_how $P137, $P136
    can $I101, $P137, "add_method"
    new $P130, 'Integer'
    set $P130, $I101
  if_3409_end:
    unless $P130, if_3408_end
    .const 'Sub' $P3411 = "572_1310110678.31883" 
    capture_lex $P3411
    $P3411()
  if_3408_end:
.annotate 'line', 2292
    get_hll_global $P130, "GLOBAL"
    nqp_get_package_through_who $P131, $P130, "PAST"
    get_who $P132, $P131
    set $P133, $P132["Op"]
.annotate 'line', 2294
    new $P134, "ResizablePMCArray"
    push $P134, "Regex"
    push $P134, "Method"
    find_lex $P135, "$/"
    unless_null $P135, vivify_2902
    new $P135, "Undef"
  vivify_2902:
    $P136 = "lexical_package_lookup"($P134, $P135)
    find_lex $P137, "$regex"
    unless_null $P137, vivify_2903
    new $P137, "Undef"
  vivify_2903:
    $P138 = $P133."new"($P136, $P137, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 2292
    store_lex "$past", $P138
.annotate 'line', 2297
    find_lex $P131, "$prefix_meth"
    unless_null $P131, vivify_2904
    new $P131, "Undef"
  vivify_2904:
    if $P131, if_3416
    find_lex $P139, "$regex"
    unless_null $P139, vivify_2905
    new $P139, "Undef"
  vivify_2905:
    set $P130, $P139
    goto if_3416_end
  if_3416:
.annotate 'line', 2298
    get_hll_global $P132, "GLOBAL"
    nqp_get_package_through_who $P133, $P132, "PAST"
    get_who $P134, $P133
    set $P135, $P134["Stmts"]
    find_lex $P136, "$regex"
    unless_null $P136, vivify_2906
    new $P136, "Undef"
  vivify_2906:
    find_lex $P137, "$prefix_meth"
    unless_null $P137, vivify_2907
    new $P137, "Undef"
  vivify_2907:
    $P138 = $P135."new"($P136, $P137)
    set $P130, $P138
  if_3416_end:
.annotate 'line', 2297
    find_lex $P3417, "$past"
    unless_null $P3417, vivify_2908
    $P3417 = root_new ['parrot';'Hash']
    store_lex "$past", $P3417
  vivify_2908:
    set $P3417["sink"], $P130
.annotate 'line', 2300
    find_lex $P3418, "@MODIFIERS"
    unless_null $P3418, vivify_2909
    $P3418 = root_new ['parrot';'ResizablePMCArray']
  vivify_2909:
    $P130 = $P3418."shift"()
.annotate 'line', 2271
    .return ($P130)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3410"  :anon :subid("572_1310110678.31883") :outer("571_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2282
    $P3413 = root_new ['parrot';'ResizablePMCArray']
    set $P3412, $P3413
    .lex "@prefixes", $P3412
.annotate 'line', 2279
    find_dynamic_lex $P140, "$*SC"
    unless_null $P140, vivify_2886
    get_hll_global $P138, "GLOBAL"
    get_who $P139, $P138
    set $P140, $P139["$SC"]
    unless_null $P140, vivify_2887
    die "Contextual $*SC not found"
  vivify_2887:
  vivify_2886:
    find_dynamic_lex $P143, "$*PACKAGE"
    unless_null $P143, vivify_2888
    get_hll_global $P141, "GLOBAL"
    get_who $P142, $P141
    set $P143, $P142["$PACKAGE"]
    unless_null $P143, vivify_2889
    die "Contextual $*PACKAGE not found"
  vivify_2889:
  vivify_2888:
    find_lex $P144, "$name"
    unless_null $P144, vivify_2890
    new $P144, "Undef"
  vivify_2890:
    find_lex $P145, "$regex"
    unless_null $P145, vivify_2891
    new $P145, "Undef"
  vivify_2891:
    $P140."pkg_add_method"($P143, "add_method", $P144, $P145, 0)
.annotate 'line', 2282
    find_lex $P3414, "$/"
    unless_null $P3414, vivify_2892
    $P3414 = root_new ['parrot';'Hash']
  vivify_2892:
    set $P138, $P3414["p6regex"]
    unless_null $P138, vivify_2893
    new $P138, "Undef"
  vivify_2893:
    $P139 = $P138."ast"()
    $P140 = $P139."prefix_list"()
    store_lex "@prefixes", $P140
.annotate 'line', 2283
    get_hll_global $P138, "GLOBAL"
    nqp_get_package_through_who $P139, $P138, "PAST"
    get_who $P140, $P139
    set $P141, $P140["Block"]
.annotate 'line', 2284
    new $P142, "String"
    assign $P142, "!PREFIX__"
    find_lex $P143, "$name"
    unless_null $P143, vivify_2894
    new $P143, "Undef"
  vivify_2894:
    concat $P144, $P142, $P143
.annotate 'line', 2285
    get_hll_global $P145, "GLOBAL"
    nqp_get_package_through_who $P146, $P145, "PAST"
    get_who $P147, $P146
    set $P148, $P147["Op"]
    find_lex $P3415, "@prefixes"
    unless_null $P3415, vivify_2895
    $P3415 = root_new ['parrot';'ResizablePMCArray']
  vivify_2895:
    $P150 = $P148."new"($P3415 :flat, "list" :named("pasttype"))
    $P151 = $P141."new"($P150, $P144 :named("name"), "method" :named("blocktype"))
.annotate 'line', 2283
    store_lex "$prefix_meth", $P151
.annotate 'line', 2287
    find_dynamic_lex $P140, "$*SC"
    unless_null $P140, vivify_2896
    get_hll_global $P138, "GLOBAL"
    get_who $P139, $P138
    set $P140, $P139["$SC"]
    unless_null $P140, vivify_2897
    die "Contextual $*SC not found"
  vivify_2897:
  vivify_2896:
    find_dynamic_lex $P143, "$*PACKAGE"
    unless_null $P143, vivify_2898
    get_hll_global $P141, "GLOBAL"
    get_who $P142, $P141
    set $P143, $P142["$PACKAGE"]
    unless_null $P143, vivify_2899
    die "Contextual $*PACKAGE not found"
  vivify_2899:
  vivify_2898:
    find_lex $P144, "$prefix_meth"
    unless_null $P144, vivify_2900
    new $P144, "Undef"
  vivify_2900:
    $P145 = $P144."name"()
    find_lex $P146, "$prefix_meth"
    unless_null $P146, vivify_2901
    new $P146, "Undef"
  vivify_2901:
    $P147 = $P140."pkg_add_method"($P143, "add_method", $P145, $P146, 0)
.annotate 'line', 2277
    .return ($P147)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3386"  :anon :subid("570_1310110678.31883") :outer("568_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2262
    $P3389 = root_new ['parrot';'Hash']
    set $P3388, $P3389
    .lex "%h", $P3388
.annotate 'line', 2261
    find_lex $P3390, "%h"
    unless_null $P3390, vivify_2910
    $P3390 = root_new ['parrot';'Hash']
  vivify_2910:
.annotate 'line', 2263
    find_lex $P3392, "$/"
    unless_null $P3392, vivify_2911
    $P3392 = root_new ['parrot';'Hash']
  vivify_2911:
    set $P128, $P3392["sym"]
    unless_null $P128, vivify_2912
    new $P128, "Undef"
  vivify_2912:
    set $S101, $P128
    iseq $I101, $S101, "token"
    unless $I101, if_3391_end
    new $P129, "Integer"
    assign $P129, 1
    find_lex $P3393, "%h"
    unless_null $P3393, vivify_2913
    $P3393 = root_new ['parrot';'Hash']
    store_lex "%h", $P3393
  vivify_2913:
    set $P3393["r"], $P129
  if_3391_end:
.annotate 'line', 2264
    find_lex $P3395, "$/"
    unless_null $P3395, vivify_2914
    $P3395 = root_new ['parrot';'Hash']
  vivify_2914:
    set $P128, $P3395["sym"]
    unless_null $P128, vivify_2915
    new $P128, "Undef"
  vivify_2915:
    set $S101, $P128
    iseq $I101, $S101, "rule"
    unless $I101, if_3394_end
    new $P129, "Integer"
    assign $P129, 1
    find_lex $P3396, "%h"
    unless_null $P3396, vivify_2916
    $P3396 = root_new ['parrot';'Hash']
    store_lex "%h", $P3396
  vivify_2916:
    set $P3396["r"], $P129
    new $P129, "Integer"
    assign $P129, 1
    find_lex $P3397, "%h"
    unless_null $P3397, vivify_2917
    $P3397 = root_new ['parrot';'Hash']
    store_lex "%h", $P3397
  vivify_2917:
    set $P3397["s"], $P129
  if_3394_end:
.annotate 'line', 2265
    find_lex $P3398, "@MODIFIERS"
    unless_null $P3398, vivify_2918
    $P3398 = root_new ['parrot';'ResizablePMCArray']
  vivify_2918:
    find_lex $P3399, "%h"
    unless_null $P3399, vivify_2919
    $P3399 = root_new ['parrot';'Hash']
  vivify_2919:
    $P3398."unshift"($P3399)
.annotate 'line', 2266
    find_lex $P128, "$name"
    unless_null $P128, vivify_2920
    new $P128, "Undef"
  vivify_2920:
    get_hll_global $P129, "GLOBAL"
    nqp_get_package_through_who $P130, $P129, "Regex"
    nqp_get_package_through_who $P131, $P130, "P6Regex"
    nqp_get_package_through_who $P132, $P131, "Actions"
    get_who $P133, $P132
    set $P133["$REGEXNAME"], $P128
.annotate 'line', 2267
    find_lex $P128, "$?PACKAGE"
    get_who $P129, $P128
    set $P3400, $P129["@BLOCK"]
    unless_null $P3400, vivify_2921
    $P3400 = root_new ['parrot';'ResizablePMCArray']
  vivify_2921:
    set $P130, $P3400[0]
    unless_null $P130, vivify_2922
    new $P130, "Undef"
  vivify_2922:
    $P130."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 2268
    find_lex $P128, "$?PACKAGE"
    get_who $P129, $P128
    set $P3401, $P129["@BLOCK"]
    unless_null $P3401, vivify_2923
    $P3401 = root_new ['parrot';'ResizablePMCArray']
  vivify_2923:
    set $P130, $P3401[0]
    unless_null $P130, vivify_2924
    new $P130, "Undef"
  vivify_2924:
    $P130."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 2269
    new $P128, "Exception"
    set $P128['type'], .CONTROL_RETURN
    new $P129, "Integer"
    assign $P129, 0
    setattribute $P128, 'payload', $P129
    throw $P128
.annotate 'line', 2261
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3381"  :anon :subid("569_1310110678.31883") :outer("568_1310110678.31883")
    .param pmc param_3383
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2257
    .lex "$_", param_3383
.annotate 'line', 2258
    find_dynamic_lex $P133, "$*SC"
    unless_null $P133, vivify_2933
    get_hll_global $P131, "GLOBAL"
    get_who $P132, $P131
    set $P133, $P132["$SC"]
    unless_null $P133, vivify_2934
    die "Contextual $*SC not found"
  vivify_2934:
  vivify_2933:
    find_dynamic_lex $P136, "$*PACKAGE"
    unless_null $P136, vivify_2935
    get_hll_global $P134, "GLOBAL"
    get_who $P135, $P134
    set $P136, $P135["$PACKAGE"]
    unless_null $P136, vivify_2936
    die "Contextual $*PACKAGE not found"
  vivify_2936:
  vivify_2935:
    find_lex $P137, "$_"
    unless_null $P137, vivify_2937
    new $P137, "Undef"
  vivify_2937:
    $P138 = $P137."name"()
    find_lex $P139, "$_"
    unless_null $P139, vivify_2938
    new $P139, "Undef"
  vivify_2938:
    $P140 = $P133."pkg_add_method"($P136, "add_method", $P138, $P139, 0)
.annotate 'line', 2257
    .return ($P140)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "dotty" :anon :subid("573_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3420
    .param pmc param_3421
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2306
    .lex "self", param_3420
    .lex "$/", param_3421
.annotate 'line', 2307
    new $P122, "Undef"
    set $P3422, $P122
    .lex "$past", $P3422
    find_lex $P3424, "$/"
    unless_null $P3424, vivify_2940
    $P3424 = root_new ['parrot';'Hash']
  vivify_2940:
    set $P124, $P3424["args"]
    unless_null $P124, vivify_2941
    new $P124, "Undef"
  vivify_2941:
    if $P124, if_3423
    get_hll_global $P128, "GLOBAL"
    nqp_get_package_through_who $P129, $P128, "PAST"
    get_who $P130, $P129
    set $P131, $P130["Op"]
    find_lex $P132, "$/"
    unless_null $P132, vivify_2942
    new $P132, "Undef"
  vivify_2942:
    $P133 = $P131."new"($P132 :named("node"))
    set $P123, $P133
    goto if_3423_end
  if_3423:
    find_lex $P3425, "$/"
    unless_null $P3425, vivify_2943
    $P3425 = root_new ['parrot';'Hash']
  vivify_2943:
    set $P3426, $P3425["args"]
    unless_null $P3426, vivify_2944
    $P3426 = root_new ['parrot';'ResizablePMCArray']
  vivify_2944:
    set $P125, $P3426[0]
    unless_null $P125, vivify_2945
    new $P125, "Undef"
  vivify_2945:
    $P127 = $P125."ast"()
    set $P123, $P127
  if_3423_end:
    store_lex "$past", $P123
.annotate 'line', 2308
    find_lex $P3428, "$/"
    unless_null $P3428, vivify_2946
    $P3428 = root_new ['parrot';'Hash']
  vivify_2946:
    set $P123, $P3428["quote"]
    unless_null $P123, vivify_2947
    new $P123, "Undef"
  vivify_2947:
    if $P123, if_3427
.annotate 'line', 2312
    find_lex $P3431, "$/"
    unless_null $P3431, vivify_2948
    $P3431 = root_new ['parrot';'Hash']
  vivify_2948:
    set $P124, $P3431["longname"]
    unless_null $P124, vivify_2949
    new $P124, "Undef"
  vivify_2949:
    set $S100, $P124
    iseq $I100, $S100, "HOW"
    if $I100, if_3430
.annotate 'line', 2315
    find_lex $P3433, "$/"
    unless_null $P3433, vivify_2950
    $P3433 = root_new ['parrot';'Hash']
  vivify_2950:
    set $P125, $P3433["longname"]
    unless_null $P125, vivify_2951
    new $P125, "Undef"
  vivify_2951:
    set $S101, $P125
    iseq $I101, $S101, "WHAT"
    if $I101, if_3432
.annotate 'line', 2318
    find_lex $P3435, "$/"
    unless_null $P3435, vivify_2952
    $P3435 = root_new ['parrot';'Hash']
  vivify_2952:
    set $P127, $P3435["longname"]
    unless_null $P127, vivify_2953
    new $P127, "Undef"
  vivify_2953:
    set $S102, $P127
    iseq $I102, $S102, "WHO"
    if $I102, if_3434
.annotate 'line', 2322
    find_lex $P128, "$past"
    unless_null $P128, vivify_2954
    new $P128, "Undef"
  vivify_2954:
    find_lex $P3436, "$/"
    unless_null $P3436, vivify_2955
    $P3436 = root_new ['parrot';'Hash']
  vivify_2955:
    set $P129, $P3436["longname"]
    unless_null $P129, vivify_2956
    new $P129, "Undef"
  vivify_2956:
    set $S103, $P129
    $P128."name"($S103)
.annotate 'line', 2323
    find_lex $P128, "$past"
    unless_null $P128, vivify_2957
    new $P128, "Undef"
  vivify_2957:
    $P128."pasttype"("callmethod")
.annotate 'line', 2321
    goto if_3434_end
  if_3434:
.annotate 'line', 2319
    find_lex $P128, "$past"
    unless_null $P128, vivify_2958
    new $P128, "Undef"
  vivify_2958:
    $P128."pirop"("get_who PP")
  if_3434_end:
.annotate 'line', 2318
    goto if_3432_end
  if_3432:
.annotate 'line', 2316
    find_lex $P127, "$past"
    unless_null $P127, vivify_2959
    new $P127, "Undef"
  vivify_2959:
    $P127."pirop"("get_what PP")
  if_3432_end:
.annotate 'line', 2315
    goto if_3430_end
  if_3430:
.annotate 'line', 2313
    find_lex $P125, "$past"
    unless_null $P125, vivify_2960
    new $P125, "Undef"
  vivify_2960:
    $P125."pirop"("get_how PP")
  if_3430_end:
.annotate 'line', 2312
    goto if_3427_end
  if_3427:
.annotate 'line', 2309
    find_lex $P124, "$past"
    unless_null $P124, vivify_2961
    new $P124, "Undef"
  vivify_2961:
    find_lex $P3429, "$/"
    unless_null $P3429, vivify_2962
    $P3429 = root_new ['parrot';'Hash']
  vivify_2962:
    set $P125, $P3429["quote"]
    unless_null $P125, vivify_2963
    new $P125, "Undef"
  vivify_2963:
    $P127 = $P125."ast"()
    $P124."name"($P127)
.annotate 'line', 2310
    find_lex $P124, "$past"
    unless_null $P124, vivify_2964
    new $P124, "Undef"
  vivify_2964:
    $P124."pasttype"("callmethod")
  if_3427_end:
.annotate 'line', 2325
    find_lex $P123, "$/"
    find_lex $P124, "$past"
    unless_null $P124, vivify_2965
    new $P124, "Undef"
  vivify_2965:
    $P125 = $P123."!make"($P124)
.annotate 'line', 2306
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<self>" :anon :subid("574_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3438
    .param pmc param_3439
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2330
    .lex "self", param_3438
    .lex "$/", param_3439
.annotate 'line', 2331
    find_lex $P122, "$/"
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Var"]
    $P128 = $P127."new"("self" :named("name"))
    $P129 = $P122."!make"($P128)
.annotate 'line', 2330
    .return ($P129)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<identifier>" :anon :subid("575_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3441
    .param pmc param_3442
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2334
    .lex "self", param_3441
    .lex "$/", param_3442
.annotate 'line', 2335
    new $P122, "Undef"
    set $P3443, $P122
    .lex "$past", $P3443
    find_lex $P3444, "$/"
    unless_null $P3444, vivify_2966
    $P3444 = root_new ['parrot';'Hash']
  vivify_2966:
    set $P123, $P3444["args"]
    unless_null $P123, vivify_2967
    new $P123, "Undef"
  vivify_2967:
    $P124 = $P123."ast"()
    store_lex "$past", $P124
.annotate 'line', 2336
    find_lex $P123, "$past"
    unless_null $P123, vivify_2968
    new $P123, "Undef"
  vivify_2968:
    find_lex $P3445, "$/"
    unless_null $P3445, vivify_2969
    $P3445 = root_new ['parrot';'Hash']
  vivify_2969:
    set $P124, $P3445["deflongname"]
    unless_null $P124, vivify_2970
    new $P124, "Undef"
  vivify_2970:
    set $S100, $P124
    $P123."name"($S100)
.annotate 'line', 2337
    find_lex $P123, "$/"
    find_lex $P124, "$past"
    unless_null $P124, vivify_2971
    new $P124, "Undef"
  vivify_2971:
    $P125 = $P123."!make"($P124)
.annotate 'line', 2334
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<name>" :anon :subid("576_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3447
    .param pmc param_3448
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2340
    .const 'Sub' $P3455 = "577_1310110678.31883" 
    capture_lex $P3455
    .lex "self", param_3447
    .lex "$/", param_3448
.annotate 'line', 2342
    new $P122, "Undef"
    set $P3449, $P122
    .lex "$var", $P3449
.annotate 'line', 2352
    new $P123, "Undef"
    set $P3450, $P123
    .lex "$past", $P3450
.annotate 'line', 2340
    find_lex $P124, "$var"
    unless_null $P124, vivify_2972
    new $P124, "Undef"
  vivify_2972:
.annotate 'line', 2343
    find_lex $P3452, "$/"
    unless_null $P3452, vivify_2973
    $P3452 = root_new ['parrot';'Hash']
  vivify_2973:
    set $P124, $P3452["name"]
    unless_null $P124, vivify_2974
    new $P124, "Undef"
  vivify_2974:
    set $S100, $P124
    $P125 = "is_lexical"($S100)
    if $P125, if_3451
.annotate 'line', 2346
    .const 'Sub' $P3455 = "577_1310110678.31883" 
    capture_lex $P3455
    $P3455()
    goto if_3451_end
  if_3451:
.annotate 'line', 2344
    get_hll_global $P127, "GLOBAL"
    nqp_get_package_through_who $P128, $P127, "PAST"
    get_who $P129, $P128
    set $P130, $P129["Var"]
    find_lex $P3453, "$/"
    unless_null $P3453, vivify_2980
    $P3453 = root_new ['parrot';'Hash']
  vivify_2980:
    set $P131, $P3453["name"]
    unless_null $P131, vivify_2981
    new $P131, "Undef"
  vivify_2981:
    set $S101, $P131
    $P132 = $P130."new"($S101 :named("name"), "lexical" :named("scope"))
    store_lex "$var", $P132
  if_3451_end:
.annotate 'line', 2352
    find_lex $P124, "$var"
    unless_null $P124, vivify_2982
    new $P124, "Undef"
  vivify_2982:
    store_lex "$past", $P124
.annotate 'line', 2353
    find_lex $P3462, "$/"
    unless_null $P3462, vivify_2983
    $P3462 = root_new ['parrot';'Hash']
  vivify_2983:
    set $P124, $P3462["args"]
    unless_null $P124, vivify_2984
    new $P124, "Undef"
  vivify_2984:
    unless $P124, if_3461_end
.annotate 'line', 2354
    find_lex $P3463, "$/"
    unless_null $P3463, vivify_2985
    $P3463 = root_new ['parrot';'Hash']
  vivify_2985:
    set $P3464, $P3463["args"]
    unless_null $P3464, vivify_2986
    $P3464 = root_new ['parrot';'ResizablePMCArray']
  vivify_2986:
    set $P125, $P3464[0]
    unless_null $P125, vivify_2987
    new $P125, "Undef"
  vivify_2987:
    $P127 = $P125."ast"()
    store_lex "$past", $P127
.annotate 'line', 2355
    find_lex $P125, "$past"
    unless_null $P125, vivify_2988
    new $P125, "Undef"
  vivify_2988:
    find_lex $P127, "$var"
    unless_null $P127, vivify_2989
    new $P127, "Undef"
  vivify_2989:
    $P125."unshift"($P127)
  if_3461_end:
.annotate 'line', 2357
    find_lex $P124, "$/"
    find_lex $P125, "$past"
    unless_null $P125, vivify_2990
    new $P125, "Undef"
  vivify_2990:
    $P127 = $P124."!make"($P125)
.annotate 'line', 2340
    .return ($P127)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3454"  :anon :subid("577_1310110678.31883") :outer("576_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2347
    $P3457 = root_new ['parrot';'ResizablePMCArray']
    set $P3456, $P3457
    .lex "@ns", $P3456
    find_lex $P3458, "$/"
    unless_null $P3458, vivify_2975
    $P3458 = root_new ['parrot';'Hash']
  vivify_2975:
    set $P3459, $P3458["name"]
    unless_null $P3459, vivify_2976
    $P3459 = root_new ['parrot';'Hash']
  vivify_2976:
    set $P127, $P3459["identifier"]
    unless_null $P127, vivify_2977
    new $P127, "Undef"
  vivify_2977:
    clone $P128, $P127
    store_lex "@ns", $P128
.annotate 'line', 2348
    find_lex $P3460, "@ns"
    unless_null $P3460, vivify_2978
    $P3460 = root_new ['parrot';'ResizablePMCArray']
  vivify_2978:
    find_lex $P127, "$/"
    unless_null $P127, vivify_2979
    new $P127, "Undef"
  vivify_2979:
    $P128 = "lexical_package_lookup"($P3460, $P127)
    store_lex "$var", $P128
.annotate 'line', 2346
    .return ($P128)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<pir::op>" :anon :subid("578_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3466
    .param pmc param_3467
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2360
    .lex "self", param_3466
    .lex "$/", param_3467
.annotate 'line', 2361
    new $P122, "Undef"
    set $P3468, $P122
    .lex "$past", $P3468
.annotate 'line', 2362
    new $P123, "Undef"
    set $P3469, $P123
    .lex "$pirop", $P3469
.annotate 'line', 2361
    find_lex $P3471, "$/"
    unless_null $P3471, vivify_2991
    $P3471 = root_new ['parrot';'Hash']
  vivify_2991:
    set $P125, $P3471["args"]
    unless_null $P125, vivify_2992
    new $P125, "Undef"
  vivify_2992:
    if $P125, if_3470
    get_hll_global $P129, "GLOBAL"
    nqp_get_package_through_who $P130, $P129, "PAST"
    get_who $P131, $P130
    set $P132, $P131["Op"]
    find_lex $P133, "$/"
    unless_null $P133, vivify_2993
    new $P133, "Undef"
  vivify_2993:
    $P134 = $P132."new"($P133 :named("node"))
    set $P124, $P134
    goto if_3470_end
  if_3470:
    find_lex $P3472, "$/"
    unless_null $P3472, vivify_2994
    $P3472 = root_new ['parrot';'Hash']
  vivify_2994:
    set $P3473, $P3472["args"]
    unless_null $P3473, vivify_2995
    $P3473 = root_new ['parrot';'ResizablePMCArray']
  vivify_2995:
    set $P127, $P3473[0]
    unless_null $P127, vivify_2996
    new $P127, "Undef"
  vivify_2996:
    $P128 = $P127."ast"()
    set $P124, $P128
  if_3470_end:
    store_lex "$past", $P124
.annotate 'line', 2362
    find_lex $P3474, "$/"
    unless_null $P3474, vivify_2997
    $P3474 = root_new ['parrot';'Hash']
  vivify_2997:
    set $P124, $P3474["op"]
    unless_null $P124, vivify_2998
    new $P124, "Undef"
  vivify_2998:
    set $S100, $P124
    new $P125, 'String'
    set $P125, $S100
    store_lex "$pirop", $P125
.annotate 'line', 2363
    find_lex $P124, "$pirop"
    unless_null $P124, vivify_2999
    new $P124, "Undef"
  vivify_2999:
    set $S100, $P124
    split $P125, "__", $S100
    join $S101, " ", $P125
    new $P127, 'String'
    set $P127, $S101
    store_lex "$pirop", $P127
.annotate 'line', 2364
    find_lex $P124, "$past"
    unless_null $P124, vivify_3000
    new $P124, "Undef"
  vivify_3000:
    find_lex $P125, "$pirop"
    unless_null $P125, vivify_3001
    new $P125, "Undef"
  vivify_3001:
    $P124."pirop"($P125)
.annotate 'line', 2365
    find_lex $P124, "$past"
    unless_null $P124, vivify_3002
    new $P124, "Undef"
  vivify_3002:
    $P124."pasttype"("pirop")
.annotate 'line', 2366
    find_lex $P124, "$/"
    find_lex $P125, "$past"
    unless_null $P125, vivify_3003
    new $P125, "Undef"
  vivify_3003:
    $P127 = $P124."!make"($P125)
.annotate 'line', 2360
    .return ($P127)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<pir::const>" :anon :subid("579_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3476
    .param pmc param_3477
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2369
    .lex "self", param_3476
    .lex "$/", param_3477
.annotate 'line', 2370
    find_lex $P122, "$/"
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Val"]
    find_lex $P3478, "$/"
    unless_null $P3478, vivify_3004
    $P3478 = root_new ['parrot';'Hash']
  vivify_3004:
    set $P128, $P3478["const"]
    unless_null $P128, vivify_3005
    new $P128, "Undef"
  vivify_3005:
    set $S100, $P128
    find_lex $P129, "$/"
    unless_null $P129, vivify_3006
    new $P129, "Undef"
  vivify_3006:
    $P130 = $P127."new"($S100 :named("value"), "!macro_const" :named("returns"), $P129 :named("node"))
    $P131 = $P122."!make"($P130)
.annotate 'line', 2369
    .return ($P131)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<nqp::op>" :anon :subid("580_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3480
    .param pmc param_3481
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2373
    .lex "self", param_3480
    .lex "$/", param_3481
.annotate 'line', 2374
    new $P122, "Undef"
    set $P3482, $P122
    .lex "$op", $P3482
.annotate 'line', 2375
    new $P123, "Undef"
    set $P3483, $P123
    .lex "$args", $P3483
.annotate 'line', 2376
    new $P124, "Undef"
    set $P3484, $P124
    .lex "$past", $P3484
.annotate 'line', 2374
    find_lex $P3485, "$/"
    unless_null $P3485, vivify_3007
    $P3485 = root_new ['parrot';'Hash']
  vivify_3007:
    set $P125, $P3485["op"]
    unless_null $P125, vivify_3008
    new $P125, "Undef"
  vivify_3008:
    set $S100, $P125
    new $P127, 'String'
    set $P127, $S100
    store_lex "$op", $P127
.annotate 'line', 2375
    find_lex $P3487, "$/"
    unless_null $P3487, vivify_3009
    $P3487 = root_new ['parrot';'Hash']
  vivify_3009:
    set $P127, $P3487["args"]
    unless_null $P127, vivify_3010
    new $P127, "Undef"
  vivify_3010:
    if $P127, if_3486
    new $P131, "ResizablePMCArray"
    set $P125, $P131
    goto if_3486_end
  if_3486:
    find_lex $P3488, "$/"
    unless_null $P3488, vivify_3011
    $P3488 = root_new ['parrot';'Hash']
  vivify_3011:
    set $P3489, $P3488["args"]
    unless_null $P3489, vivify_3012
    $P3489 = root_new ['parrot';'ResizablePMCArray']
  vivify_3012:
    set $P128, $P3489[0]
    unless_null $P128, vivify_3013
    new $P128, "Undef"
  vivify_3013:
    $P129 = $P128."ast"()
    $P130 = $P129."list"()
    set $P125, $P130
  if_3486_end:
    store_lex "$args", $P125
.annotate 'line', 2376
    get_hll_global $P125, "GLOBAL"
    nqp_get_package_through_who $P127, $P125, "PAST"
    get_who $P128, $P127
    set $P129, $P128["Node"]
    find_lex $P130, "$args"
    unless_null $P130, vivify_3014
    new $P130, "Undef"
  vivify_3014:
    find_lex $P131, "$op"
    unless_null $P131, vivify_3015
    new $P131, "Undef"
  vivify_3015:
    find_lex $P132, "$/"
    unless_null $P132, vivify_3016
    new $P132, "Undef"
  vivify_3016:
    $P133 = $P129."map_node"($P130 :flat, "nqp" :named("map"), $P131 :named("op"), $P132 :named("node"))
    store_lex "$past", $P133
.annotate 'line', 2379
    find_lex $P125, "$past"
    unless_null $P125, vivify_3017
    new $P125, "Undef"
  vivify_3017:
    defined $I100, $P125
    if $I100, unless_3490_end
.annotate 'line', 2380
    find_lex $P127, "$/"
    unless_null $P127, vivify_3018
    new $P127, "Undef"
  vivify_3018:
    $P128 = $P127."CURSOR"()
    new $P129, 'String'
    set $P129, "Unrecognized nqp:: opcode 'nqp::"
    find_lex $P130, "$op"
    unless_null $P130, vivify_3019
    new $P130, "Undef"
  vivify_3019:
    concat $P131, $P129, $P130
    concat $P132, $P131, "'"
    $P128."panic"($P132)
  unless_3490_end:
.annotate 'line', 2381
    find_lex $P125, "$/"
    find_lex $P127, "$past"
    unless_null $P127, vivify_3020
    new $P127, "Undef"
  vivify_3020:
    $P128 = $P125."!make"($P127)
.annotate 'line', 2373
    .return ($P128)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<onlystar>" :anon :subid("581_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3492
    .param pmc param_3493
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2384
    .lex "self", param_3492
    .lex "$/", param_3493
.annotate 'line', 2385
    find_lex $P122, "$/"
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Op"]
    $P128 = $P127."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P129 = $P122."!make"($P128)
.annotate 'line', 2384
    .return ($P129)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "args" :anon :subid("582_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3495
    .param pmc param_3496
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2390
    .lex "self", param_3495
    .lex "$/", param_3496
    find_lex $P122, "$/"
    find_lex $P3497, "$/"
    unless_null $P3497, vivify_3021
    $P3497 = root_new ['parrot';'Hash']
  vivify_3021:
    set $P123, $P3497["arglist"]
    unless_null $P123, vivify_3022
    new $P123, "Undef"
  vivify_3022:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "arglist" :anon :subid("583_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3499
    .param pmc param_3500
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2392
    .const 'Sub' $P3507 = "584_1310110678.31883" 
    capture_lex $P3507
    .lex "self", param_3499
    .lex "$/", param_3500
.annotate 'line', 2393
    new $P122, "Undef"
    set $P3501, $P122
    .lex "$past", $P3501
.annotate 'line', 2401
    new $P123, "Undef"
    set $P3502, $P123
    .lex "$i", $P3502
.annotate 'line', 2402
    new $P124, "Undef"
    set $P3503, $P124
    .lex "$n", $P3503
.annotate 'line', 2393
    get_hll_global $P125, "GLOBAL"
    nqp_get_package_through_who $P127, $P125, "PAST"
    get_who $P128, $P127
    set $P129, $P128["Op"]
    find_lex $P130, "$/"
    unless_null $P130, vivify_3023
    new $P130, "Undef"
  vivify_3023:
    $P131 = $P129."new"("call" :named("pasttype"), $P130 :named("node"))
    store_lex "$past", $P131
.annotate 'line', 2394
    find_lex $P3505, "$/"
    unless_null $P3505, vivify_3024
    $P3505 = root_new ['parrot';'Hash']
  vivify_3024:
    set $P125, $P3505["EXPR"]
    unless_null $P125, vivify_3025
    new $P125, "Undef"
  vivify_3025:
    unless $P125, if_3504_end
    .const 'Sub' $P3507 = "584_1310110678.31883" 
    capture_lex $P3507
    $P3507()
  if_3504_end:
.annotate 'line', 2401
    new $P125, "Integer"
    assign $P125, 0
    store_lex "$i", $P125
.annotate 'line', 2402
    find_lex $P125, "$past"
    unless_null $P125, vivify_3036
    new $P125, "Undef"
  vivify_3036:
    $P127 = $P125."list"()
    set $N100, $P127
    new $P128, 'Float'
    set $P128, $N100
    store_lex "$n", $P128
.annotate 'line', 2403
    new $P128, 'ExceptionHandler'
    set_label $P128, loop3528_handler
    $P128."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P128
  loop3528_test:
    find_lex $P125, "$i"
    unless_null $P125, vivify_3037
    new $P125, "Undef"
  vivify_3037:
    set $N100, $P125
    find_lex $P127, "$n"
    unless_null $P127, vivify_3038
    new $P127, "Undef"
  vivify_3038:
    set $N101, $P127
    islt $I100, $N100, $N101
    unless $I100, loop3528_done
  loop3528_redo:
.annotate 'line', 2404
    find_lex $P128, "$i"
    unless_null $P128, vivify_3039
    new $P128, "Undef"
  vivify_3039:
    set $I101, $P128
    find_lex $P3517, "$past"
    unless_null $P3517, vivify_3040
    $P3517 = root_new ['parrot';'ResizablePMCArray']
  vivify_3040:
    set $P129, $P3517[$I101]
    unless_null $P129, vivify_3041
    new $P129, "Undef"
  vivify_3041:
    $S100 = $P129."name"()
    iseq $I102, $S100, "&prefix:<|>"
    unless $I102, if_3516_end
.annotate 'line', 2405
    find_lex $P130, "$i"
    unless_null $P130, vivify_3042
    new $P130, "Undef"
  vivify_3042:
    set $I103, $P130
    find_lex $P3518, "$past"
    unless_null $P3518, vivify_3043
    $P3518 = root_new ['parrot';'ResizablePMCArray']
  vivify_3043:
    set $P3519, $P3518[$I103]
    unless_null $P3519, vivify_3044
    $P3519 = root_new ['parrot';'ResizablePMCArray']
  vivify_3044:
    set $P131, $P3519[0]
    unless_null $P131, vivify_3045
    new $P131, "Undef"
  vivify_3045:
    find_lex $P132, "$i"
    unless_null $P132, vivify_3046
    new $P132, "Undef"
  vivify_3046:
    set $I104, $P132
    find_lex $P3520, "$past"
    unless_null $P3520, vivify_3047
    $P3520 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$past", $P3520
  vivify_3047:
    set $P3520[$I104], $P131
.annotate 'line', 2406
    find_lex $P130, "$i"
    unless_null $P130, vivify_3048
    new $P130, "Undef"
  vivify_3048:
    set $I103, $P130
    find_lex $P3521, "$past"
    unless_null $P3521, vivify_3049
    $P3521 = root_new ['parrot';'ResizablePMCArray']
  vivify_3049:
    set $P131, $P3521[$I103]
    unless_null $P131, vivify_3050
    new $P131, "Undef"
  vivify_3050:
    $P131."flat"(1)
.annotate 'line', 2407
    find_lex $P131, "$i"
    unless_null $P131, vivify_3051
    new $P131, "Undef"
  vivify_3051:
    set $I103, $P131
    find_lex $P3524, "$past"
    unless_null $P3524, vivify_3052
    $P3524 = root_new ['parrot';'ResizablePMCArray']
  vivify_3052:
    set $P132, $P3524[$I103]
    unless_null $P132, vivify_3053
    new $P132, "Undef"
  vivify_3053:
    get_hll_global $P133, "GLOBAL"
    nqp_get_package_through_who $P134, $P133, "PAST"
    get_who $P135, $P134
    set $P136, $P135["Val"]
    $P137 = $P132."isa"($P136)
    if $P137, if_3523
    set $P130, $P137
    goto if_3523_end
  if_3523:
.annotate 'line', 2408
    find_lex $P138, "$i"
    unless_null $P138, vivify_3054
    new $P138, "Undef"
  vivify_3054:
    set $I104, $P138
    find_lex $P3525, "$past"
    unless_null $P3525, vivify_3055
    $P3525 = root_new ['parrot';'ResizablePMCArray']
  vivify_3055:
    set $P139, $P3525[$I104]
    unless_null $P139, vivify_3056
    new $P139, "Undef"
  vivify_3056:
    $S101 = $P139."name"()
    substr $S102, $S101, 0, 1
    iseq $I105, $S102, "%"
    new $P130, 'Integer'
    set $P130, $I105
  if_3523_end:
    unless $P130, if_3522_end
.annotate 'line', 2409
    find_lex $P140, "$i"
    unless_null $P140, vivify_3057
    new $P140, "Undef"
  vivify_3057:
    set $I106, $P140
    find_lex $P3526, "$past"
    unless_null $P3526, vivify_3058
    $P3526 = root_new ['parrot';'ResizablePMCArray']
  vivify_3058:
    set $P141, $P3526[$I106]
    unless_null $P141, vivify_3059
    new $P141, "Undef"
  vivify_3059:
    $P141."named"(1)
  if_3522_end:
  if_3516_end:
.annotate 'line', 2403
    find_lex $P128, "$i"
    unless_null $P128, vivify_3060
    new $P128, "Undef"
  vivify_3060:
    clone $P3527, $P128
    inc $P128
  loop3528_next:
    goto loop3528_test
  loop3528_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P129, exception, 'type'
    eq $P129, .CONTROL_LOOP_NEXT, loop3528_next
    eq $P129, .CONTROL_LOOP_REDO, loop3528_redo
  loop3528_done:
    pop_eh 
.annotate 'line', 2414
    find_lex $P125, "$/"
    find_lex $P127, "$past"
    unless_null $P127, vivify_3061
    new $P127, "Undef"
  vivify_3061:
    $P128 = $P125."!make"($P127)
.annotate 'line', 2392
    .return ($P128)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3506"  :anon :subid("584_1310110678.31883") :outer("583_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2394
    .const 'Sub' $P3513 = "585_1310110678.31883" 
    capture_lex $P3513
.annotate 'line', 2395
    new $P127, "Undef"
    set $P3508, $P127
    .lex "$expr", $P3508
    find_lex $P3509, "$/"
    unless_null $P3509, vivify_3026
    $P3509 = root_new ['parrot';'Hash']
  vivify_3026:
    set $P128, $P3509["EXPR"]
    unless_null $P128, vivify_3027
    new $P128, "Undef"
  vivify_3027:
    $P129 = $P128."ast"()
    store_lex "$expr", $P129
.annotate 'line', 2396
    find_lex $P130, "$expr"
    unless_null $P130, vivify_3028
    new $P130, "Undef"
  vivify_3028:
    $S100 = $P130."name"()
    iseq $I100, $S100, "&infix:<,>"
    if $I100, if_3511
    new $P129, 'Integer'
    set $P129, $I100
    goto if_3511_end
  if_3511:
    find_lex $P131, "$expr"
    unless_null $P131, vivify_3029
    new $P131, "Undef"
  vivify_3029:
    $P132 = $P131."named"()
    isfalse $I101, $P132
    new $P129, 'Integer'
    set $P129, $I101
  if_3511_end:
    if $P129, if_3510
.annotate 'line', 2399
    find_lex $P134, "$past"
    unless_null $P134, vivify_3030
    new $P134, "Undef"
  vivify_3030:
    find_lex $P135, "$expr"
    unless_null $P135, vivify_3031
    new $P135, "Undef"
  vivify_3031:
    $P136 = $P134."push"($P135)
    set $P128, $P136
.annotate 'line', 2396
    goto if_3510_end
  if_3510:
.annotate 'line', 2397
    find_lex $P134, "$expr"
    unless_null $P134, vivify_3032
    new $P134, "Undef"
  vivify_3032:
    $P135 = $P134."list"()
    defined $I102, $P135
    unless $I102, for_undef_3033
    iter $P133, $P135
    new $P137, 'ExceptionHandler'
    set_label $P137, loop3515_handler
    $P137."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P137
  loop3515_test:
    unless $P133, loop3515_done
    shift $P136, $P133
  loop3515_redo:
    .const 'Sub' $P3513 = "585_1310110678.31883" 
    capture_lex $P3513
    $P3513($P136)
  loop3515_next:
    goto loop3515_test
  loop3515_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P138, exception, 'type'
    eq $P138, .CONTROL_LOOP_NEXT, loop3515_next
    eq $P138, .CONTROL_LOOP_REDO, loop3515_redo
  loop3515_done:
    pop_eh 
  for_undef_3033:
.annotate 'line', 2396
    set $P128, $P133
  if_3510_end:
.annotate 'line', 2394
    .return ($P128)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3512"  :anon :subid("585_1310110678.31883") :outer("584_1310110678.31883")
    .param pmc param_3514
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2397
    .lex "$_", param_3514
    find_lex $P137, "$past"
    unless_null $P137, vivify_3034
    new $P137, "Undef"
  vivify_3034:
    find_lex $P138, "$_"
    unless_null $P138, vivify_3035
    new $P138, "Undef"
  vivify_3035:
    $P139 = $P137."push"($P138)
    .return ($P139)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<multi_declarator>" :anon :subid("586_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3530
    .param pmc param_3531
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2417
    .lex "self", param_3530
    .lex "$/", param_3531
    find_lex $P122, "$/"
    find_lex $P3532, "$/"
    unless_null $P3532, vivify_3062
    $P3532 = root_new ['parrot';'Hash']
  vivify_3062:
    set $P123, $P3532["multi_declarator"]
    unless_null $P123, vivify_3063
    new $P123, "Undef"
  vivify_3063:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<value>" :anon :subid("587_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3534
    .param pmc param_3535
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2419
    .lex "self", param_3534
    .lex "$/", param_3535
    find_lex $P122, "$/"
    find_lex $P3536, "$/"
    unless_null $P3536, vivify_3064
    $P3536 = root_new ['parrot';'Hash']
  vivify_3064:
    set $P123, $P3536["value"]
    unless_null $P123, vivify_3065
    new $P123, "Undef"
  vivify_3065:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<( )>" :anon :subid("588_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3538
    .param pmc param_3539
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2421
    .lex "self", param_3538
    .lex "$/", param_3539
.annotate 'line', 2422
    find_lex $P122, "$/"
.annotate 'line', 2423
    find_lex $P3541, "$/"
    unless_null $P3541, vivify_3066
    $P3541 = root_new ['parrot';'Hash']
  vivify_3066:
    set $P124, $P3541["EXPR"]
    unless_null $P124, vivify_3067
    new $P124, "Undef"
  vivify_3067:
    if $P124, if_3540
.annotate 'line', 2424
    get_hll_global $P128, "GLOBAL"
    nqp_get_package_through_who $P129, $P128, "PAST"
    get_who $P130, $P129
    set $P131, $P130["Op"]
    find_lex $P132, "$/"
    unless_null $P132, vivify_3068
    new $P132, "Undef"
  vivify_3068:
    $P133 = $P131."new"("list" :named("pasttype"), $P132 :named("node"))
    set $P123, $P133
.annotate 'line', 2423
    goto if_3540_end
  if_3540:
    find_lex $P3542, "$/"
    unless_null $P3542, vivify_3069
    $P3542 = root_new ['parrot';'Hash']
  vivify_3069:
    set $P3543, $P3542["EXPR"]
    unless_null $P3543, vivify_3070
    $P3543 = root_new ['parrot';'ResizablePMCArray']
  vivify_3070:
    set $P125, $P3543[0]
    unless_null $P125, vivify_3071
    new $P125, "Undef"
  vivify_3071:
    $P127 = $P125."ast"()
    set $P123, $P127
  if_3540_end:
    $P134 = $P122."!make"($P123)
.annotate 'line', 2421
    .return ($P134)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<[ ]>" :anon :subid("589_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3545
    .param pmc param_3546
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2427
    .lex "self", param_3545
    .lex "$/", param_3546
.annotate 'line', 2428
    new $P122, "Undef"
    set $P3547, $P122
    .lex "$past", $P3547
.annotate 'line', 2427
    find_lex $P123, "$past"
    unless_null $P123, vivify_3072
    new $P123, "Undef"
  vivify_3072:
.annotate 'line', 2429
    find_lex $P3549, "$/"
    unless_null $P3549, vivify_3073
    $P3549 = root_new ['parrot';'Hash']
  vivify_3073:
    set $P123, $P3549["EXPR"]
    unless_null $P123, vivify_3074
    new $P123, "Undef"
  vivify_3074:
    if $P123, if_3548
.annotate 'line', 2436
    get_hll_global $P124, "GLOBAL"
    nqp_get_package_through_who $P125, $P124, "PAST"
    get_who $P127, $P125
    set $P128, $P127["Op"]
    $P129 = $P128."new"("list" :named("pasttype"))
    store_lex "$past", $P129
.annotate 'line', 2435
    goto if_3548_end
  if_3548:
.annotate 'line', 2430
    find_lex $P3550, "$/"
    unless_null $P3550, vivify_3075
    $P3550 = root_new ['parrot';'Hash']
  vivify_3075:
    set $P3551, $P3550["EXPR"]
    unless_null $P3551, vivify_3076
    $P3551 = root_new ['parrot';'ResizablePMCArray']
  vivify_3076:
    set $P124, $P3551[0]
    unless_null $P124, vivify_3077
    new $P124, "Undef"
  vivify_3077:
    $P125 = $P124."ast"()
    store_lex "$past", $P125
.annotate 'line', 2431
    find_lex $P124, "$past"
    unless_null $P124, vivify_3078
    new $P124, "Undef"
  vivify_3078:
    $S100 = $P124."name"()
    isne $I100, $S100, "&infix:<,>"
    unless $I100, if_3552_end
.annotate 'line', 2432
    get_hll_global $P125, "GLOBAL"
    nqp_get_package_through_who $P127, $P125, "PAST"
    get_who $P128, $P127
    set $P129, $P128["Op"]
    find_lex $P130, "$past"
    unless_null $P130, vivify_3079
    new $P130, "Undef"
  vivify_3079:
    $P131 = $P129."new"($P130, "list" :named("pasttype"))
    store_lex "$past", $P131
  if_3552_end:
  if_3548_end:
.annotate 'line', 2438
    find_lex $P123, "$past"
    unless_null $P123, vivify_3080
    new $P123, "Undef"
  vivify_3080:
    $P123."name"("&circumfix:<[ ]>")
.annotate 'line', 2439
    find_lex $P123, "$/"
    find_lex $P124, "$past"
    unless_null $P124, vivify_3081
    new $P124, "Undef"
  vivify_3081:
    $P125 = $P123."!make"($P124)
.annotate 'line', 2427
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<ang>" :anon :subid("590_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3554
    .param pmc param_3555
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2442
    .lex "self", param_3554
    .lex "$/", param_3555
    find_lex $P122, "$/"
    find_lex $P3556, "$/"
    unless_null $P3556, vivify_3082
    $P3556 = root_new ['parrot';'Hash']
  vivify_3082:
    set $P123, $P3556["quote_EXPR"]
    unless_null $P123, vivify_3083
    new $P123, "Undef"
  vivify_3083:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>" :anon :subid("591_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3558
    .param pmc param_3559
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2443
    .lex "self", param_3558
    .lex "$/", param_3559
    find_lex $P122, "$/"
    find_lex $P3560, "$/"
    unless_null $P3560, vivify_3084
    $P3560 = root_new ['parrot';'Hash']
  vivify_3084:
    set $P123, $P3560["quote_EXPR"]
    unless_null $P123, vivify_3085
    new $P123, "Undef"
  vivify_3085:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<{ }>" :anon :subid("592_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3562
    .param pmc param_3563
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2445
    .const 'Sub' $P3570 = "593_1310110678.31883" 
    capture_lex $P3570
    .lex "self", param_3562
    .lex "$/", param_3563
.annotate 'line', 2446
    find_lex $P3565, "$/"
    unless_null $P3565, vivify_3086
    $P3565 = root_new ['parrot';'Hash']
  vivify_3086:
    set $P3566, $P3565["pblock"]
    unless_null $P3566, vivify_3087
    $P3566 = root_new ['parrot';'Hash']
  vivify_3087:
    set $P3567, $P3566["blockoid"]
    unless_null $P3567, vivify_3088
    $P3567 = root_new ['parrot';'Hash']
  vivify_3088:
    set $P3568, $P3567["statementlist"]
    unless_null $P3568, vivify_3089
    $P3568 = root_new ['parrot';'Hash']
  vivify_3089:
    set $P123, $P3568["statement"]
    unless_null $P123, vivify_3090
    new $P123, "Undef"
  vivify_3090:
    set $N100, $P123
    isgt $I100, $N100, 0.0
    if $I100, if_3564
.annotate 'line', 2451
    find_lex $P3575, "$/"
    unless_null $P3575, vivify_3091
    $P3575 = root_new ['parrot';'Hash']
  vivify_3091:
    set $P3576, $P3575["pblock"]
    unless_null $P3576, vivify_3092
    $P3576 = root_new ['parrot';'Hash']
  vivify_3092:
    set $P3577, $P3576["blockoid"]
    unless_null $P3577, vivify_3093
    $P3577 = root_new ['parrot';'Hash']
  vivify_3093:
    set $P129, $P3577["you_are_here"]
    unless_null $P129, vivify_3094
    new $P129, "Undef"
  vivify_3094:
    if $P129, if_3574
.annotate 'line', 2455
    find_lex $P130, "$/"
    $P131 = "vivitype"("%")
    $P132 = $P130."!make"($P131)
.annotate 'line', 2454
    set $P127, $P132
.annotate 'line', 2451
    goto if_3574_end
  if_3574:
.annotate 'line', 2452
    find_lex $P130, "$/"
    find_lex $P3578, "$/"
    unless_null $P3578, vivify_3095
    $P3578 = root_new ['parrot';'Hash']
  vivify_3095:
    set $P131, $P3578["pblock"]
    unless_null $P131, vivify_3096
    new $P131, "Undef"
  vivify_3096:
    $P132 = $P131."ast"()
    $P133 = $P130."!make"($P132)
.annotate 'line', 2451
    set $P127, $P133
  if_3574_end:
    set $P122, $P127
.annotate 'line', 2446
    goto if_3564_end
  if_3564:
    .const 'Sub' $P3570 = "593_1310110678.31883" 
    capture_lex $P3570
    $P125 = $P3570()
    set $P122, $P125
  if_3564_end:
.annotate 'line', 2445
    .return ($P122)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3569"  :anon :subid("593_1310110678.31883") :outer("592_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2447
    new $P124, "Undef"
    set $P3571, $P124
    .lex "$past", $P3571
    find_lex $P3572, "$/"
    unless_null $P3572, vivify_3097
    $P3572 = root_new ['parrot';'Hash']
  vivify_3097:
    set $P125, $P3572["pblock"]
    unless_null $P125, vivify_3098
    new $P125, "Undef"
  vivify_3098:
    $P127 = $P125."ast"()
    store_lex "$past", $P127
.annotate 'line', 2448
    new $P125, "Integer"
    assign $P125, 1
    find_lex $P3573, "$past"
    unless_null $P3573, vivify_3099
    $P3573 = root_new ['parrot';'Hash']
    store_lex "$past", $P3573
  vivify_3099:
    set $P3573["bareblock"], $P125
.annotate 'line', 2449
    find_dynamic_lex $P125, "$/"
    find_lex $P127, "$past"
    unless_null $P127, vivify_3100
    new $P127, "Undef"
  vivify_3100:
    $P128 = $P125."!make"($P127)
.annotate 'line', 2446
    .return ($P128)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<sigil>" :anon :subid("594_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3580
    .param pmc param_3581
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2459
    .lex "self", param_3580
    .lex "$/", param_3581
.annotate 'line', 2460
    new $P122, "Undef"
    set $P3582, $P122
    .lex "$name", $P3582
    find_lex $P3584, "$/"
    unless_null $P3584, vivify_3101
    $P3584 = root_new ['parrot';'Hash']
  vivify_3101:
    set $P124, $P3584["sigil"]
    unless_null $P124, vivify_3102
    new $P124, "Undef"
  vivify_3102:
    set $S100, $P124
    iseq $I100, $S100, "@"
    if $I100, if_3583
.annotate 'line', 2461
    find_lex $P3586, "$/"
    unless_null $P3586, vivify_3103
    $P3586 = root_new ['parrot';'Hash']
  vivify_3103:
    set $P128, $P3586["sigil"]
    unless_null $P128, vivify_3104
    new $P128, "Undef"
  vivify_3104:
    set $S101, $P128
    iseq $I101, $S101, "%"
    if $I101, if_3585
    new $P130, "String"
    assign $P130, "item"
    set $P127, $P130
    goto if_3585_end
  if_3585:
    new $P129, "String"
    assign $P129, "hash"
    set $P127, $P129
  if_3585_end:
    set $P123, $P127
.annotate 'line', 2460
    goto if_3583_end
  if_3583:
    new $P125, "String"
    assign $P125, "list"
    set $P123, $P125
  if_3583_end:
    store_lex "$name", $P123
.annotate 'line', 2463
    find_lex $P123, "$/"
    get_hll_global $P124, "GLOBAL"
    nqp_get_package_through_who $P125, $P124, "PAST"
    get_who $P127, $P125
    set $P128, $P127["Op"]
    find_lex $P129, "$name"
    unless_null $P129, vivify_3105
    new $P129, "Undef"
  vivify_3105:
    find_lex $P3587, "$/"
    unless_null $P3587, vivify_3106
    $P3587 = root_new ['parrot';'Hash']
  vivify_3106:
    set $P130, $P3587["semilist"]
    unless_null $P130, vivify_3107
    new $P130, "Undef"
  vivify_3107:
    $P131 = $P130."ast"()
    $P132 = $P128."new"($P131, "callmethod" :named("pasttype"), $P129 :named("name"))
    $P133 = $P123."!make"($P132)
.annotate 'line', 2459
    .return ($P133)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "semilist" :anon :subid("595_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3589
    .param pmc param_3590
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2466
    .lex "self", param_3589
    .lex "$/", param_3590
    find_lex $P122, "$/"
    find_lex $P3591, "$/"
    unless_null $P3591, vivify_3108
    $P3591 = root_new ['parrot';'Hash']
  vivify_3108:
    set $P123, $P3591["statement"]
    unless_null $P123, vivify_3109
    new $P123, "Undef"
  vivify_3109:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<[ ]>" :anon :subid("596_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3593
    .param pmc param_3594
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2468
    .lex "self", param_3593
    .lex "$/", param_3594
.annotate 'line', 2469
    find_lex $P122, "$/"
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Var"]
    find_lex $P3595, "$/"
    unless_null $P3595, vivify_3110
    $P3595 = root_new ['parrot';'Hash']
  vivify_3110:
    set $P128, $P3595["EXPR"]
    unless_null $P128, vivify_3111
    new $P128, "Undef"
  vivify_3111:
    $P129 = $P128."ast"()
.annotate 'line', 2471
    $P130 = "vivitype"("@")
.annotate 'line', 2469
    $P131 = $P127."new"($P129, "keyed_int" :named("scope"), "Undef" :named("viviself"), $P130 :named("vivibase"))
    $P132 = $P122."!make"($P131)
.annotate 'line', 2468
    .return ($P132)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<{ }>" :anon :subid("597_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3597
    .param pmc param_3598
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2474
    .lex "self", param_3597
    .lex "$/", param_3598
.annotate 'line', 2475
    find_lex $P122, "$/"
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Var"]
    find_lex $P3599, "$/"
    unless_null $P3599, vivify_3112
    $P3599 = root_new ['parrot';'Hash']
  vivify_3112:
    set $P128, $P3599["EXPR"]
    unless_null $P128, vivify_3113
    new $P128, "Undef"
  vivify_3113:
    $P129 = $P128."ast"()
.annotate 'line', 2477
    $P130 = "vivitype"("%")
.annotate 'line', 2475
    $P131 = $P127."new"($P129, "keyed" :named("scope"), "Undef" :named("viviself"), $P130 :named("vivibase"))
    $P132 = $P122."!make"($P131)
.annotate 'line', 2474
    .return ($P132)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<ang>" :anon :subid("598_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3601
    .param pmc param_3602
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2480
    .lex "self", param_3601
    .lex "$/", param_3602
.annotate 'line', 2481
    find_lex $P122, "$/"
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Var"]
    find_lex $P3603, "$/"
    unless_null $P3603, vivify_3114
    $P3603 = root_new ['parrot';'Hash']
  vivify_3114:
    set $P128, $P3603["quote_EXPR"]
    unless_null $P128, vivify_3115
    new $P128, "Undef"
  vivify_3115:
    $P129 = $P128."ast"()
.annotate 'line', 2483
    $P130 = "vivitype"("%")
.annotate 'line', 2481
    $P131 = $P127."new"($P129, "keyed" :named("scope"), "Undef" :named("viviself"), $P130 :named("vivibase"))
    $P132 = $P122."!make"($P131)
.annotate 'line', 2480
    .return ($P132)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<( )>" :anon :subid("599_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3605
    .param pmc param_3606
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2486
    .lex "self", param_3605
    .lex "$/", param_3606
.annotate 'line', 2487
    find_lex $P122, "$/"
    find_lex $P3607, "$/"
    unless_null $P3607, vivify_3116
    $P3607 = root_new ['parrot';'Hash']
  vivify_3116:
    set $P123, $P3607["arglist"]
    unless_null $P123, vivify_3117
    new $P123, "Undef"
  vivify_3117:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
.annotate 'line', 2486
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "value" :anon :subid("600_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3609
    .param pmc param_3610
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2490
    .lex "self", param_3609
    .lex "$/", param_3610
.annotate 'line', 2491
    find_lex $P122, "$/"
    find_lex $P3612, "$/"
    unless_null $P3612, vivify_3118
    $P3612 = root_new ['parrot';'Hash']
  vivify_3118:
    set $P124, $P3612["quote"]
    unless_null $P124, vivify_3119
    new $P124, "Undef"
  vivify_3119:
    if $P124, if_3611
    find_lex $P3614, "$/"
    unless_null $P3614, vivify_3120
    $P3614 = root_new ['parrot';'Hash']
  vivify_3120:
    set $P128, $P3614["number"]
    unless_null $P128, vivify_3121
    new $P128, "Undef"
  vivify_3121:
    $P129 = $P128."ast"()
    set $P123, $P129
    goto if_3611_end
  if_3611:
    find_lex $P3613, "$/"
    unless_null $P3613, vivify_3122
    $P3613 = root_new ['parrot';'Hash']
  vivify_3122:
    set $P125, $P3613["quote"]
    unless_null $P125, vivify_3123
    new $P125, "Undef"
  vivify_3123:
    $P127 = $P125."ast"()
    set $P123, $P127
  if_3611_end:
    $P130 = $P122."!make"($P123)
.annotate 'line', 2490
    .return ($P130)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "number" :anon :subid("601_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3616
    .param pmc param_3617
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2494
    .lex "self", param_3616
    .lex "$/", param_3617
.annotate 'line', 2495
    new $P122, "Undef"
    set $P3618, $P122
    .lex "$value", $P3618
    find_lex $P3620, "$/"
    unless_null $P3620, vivify_3124
    $P3620 = root_new ['parrot';'Hash']
  vivify_3124:
    set $P124, $P3620["dec_number"]
    unless_null $P124, vivify_3125
    new $P124, "Undef"
  vivify_3125:
    if $P124, if_3619
    find_lex $P3622, "$/"
    unless_null $P3622, vivify_3126
    $P3622 = root_new ['parrot';'Hash']
  vivify_3126:
    set $P128, $P3622["integer"]
    unless_null $P128, vivify_3127
    new $P128, "Undef"
  vivify_3127:
    $P129 = $P128."ast"()
    set $P123, $P129
    goto if_3619_end
  if_3619:
    find_lex $P3621, "$/"
    unless_null $P3621, vivify_3128
    $P3621 = root_new ['parrot';'Hash']
  vivify_3128:
    set $P125, $P3621["dec_number"]
    unless_null $P125, vivify_3129
    new $P125, "Undef"
  vivify_3129:
    $P127 = $P125."ast"()
    set $P123, $P127
  if_3619_end:
    store_lex "$value", $P123
.annotate 'line', 2496
    find_lex $P3624, "$/"
    unless_null $P3624, vivify_3130
    $P3624 = root_new ['parrot';'Hash']
  vivify_3130:
    set $P123, $P3624["sign"]
    unless_null $P123, vivify_3131
    new $P123, "Undef"
  vivify_3131:
    set $S100, $P123
    iseq $I100, $S100, "-"
    unless $I100, if_3623_end
    find_lex $P124, "$value"
    unless_null $P124, vivify_3132
    new $P124, "Undef"
  vivify_3132:
    neg $P125, $P124
    store_lex "$value", $P125
  if_3623_end:
.annotate 'line', 2497
    find_lex $P123, "$/"
    get_hll_global $P124, "GLOBAL"
    nqp_get_package_through_who $P125, $P124, "PAST"
    get_who $P127, $P125
    set $P128, $P127["Val"]
    find_lex $P129, "$value"
    unless_null $P129, vivify_3133
    new $P129, "Undef"
  vivify_3133:
    $P130 = $P128."new"($P129 :named("value"))
    $P131 = $P123."!make"($P130)
.annotate 'line', 2494
    .return ($P131)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<apos>" :anon :subid("602_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3626
    .param pmc param_3627
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2500
    .lex "self", param_3626
    .lex "$/", param_3627
    find_lex $P122, "$/"
    find_lex $P3628, "$/"
    unless_null $P3628, vivify_3134
    $P3628 = root_new ['parrot';'Hash']
  vivify_3134:
    set $P123, $P3628["quote_EXPR"]
    unless_null $P123, vivify_3135
    new $P123, "Undef"
  vivify_3135:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<dblq>" :anon :subid("603_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3630
    .param pmc param_3631
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2501
    .lex "self", param_3630
    .lex "$/", param_3631
    find_lex $P122, "$/"
    find_lex $P3632, "$/"
    unless_null $P3632, vivify_3136
    $P3632 = root_new ['parrot';'Hash']
  vivify_3136:
    set $P123, $P3632["quote_EXPR"]
    unless_null $P123, vivify_3137
    new $P123, "Undef"
  vivify_3137:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<qq>" :anon :subid("604_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3634
    .param pmc param_3635
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2502
    .lex "self", param_3634
    .lex "$/", param_3635
    find_lex $P122, "$/"
    find_lex $P3636, "$/"
    unless_null $P3636, vivify_3138
    $P3636 = root_new ['parrot';'Hash']
  vivify_3138:
    set $P123, $P3636["quote_EXPR"]
    unless_null $P123, vivify_3139
    new $P123, "Undef"
  vivify_3139:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<q>" :anon :subid("605_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3638
    .param pmc param_3639
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2503
    .lex "self", param_3638
    .lex "$/", param_3639
    find_lex $P122, "$/"
    find_lex $P3640, "$/"
    unless_null $P3640, vivify_3140
    $P3640 = root_new ['parrot';'Hash']
  vivify_3140:
    set $P123, $P3640["quote_EXPR"]
    unless_null $P123, vivify_3141
    new $P123, "Undef"
  vivify_3141:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q>" :anon :subid("606_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3642
    .param pmc param_3643
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2504
    .lex "self", param_3642
    .lex "$/", param_3643
    find_lex $P122, "$/"
    find_lex $P3644, "$/"
    unless_null $P3644, vivify_3142
    $P3644 = root_new ['parrot';'Hash']
  vivify_3142:
    set $P123, $P3644["quote_EXPR"]
    unless_null $P123, vivify_3143
    new $P123, "Undef"
  vivify_3143:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q:PIR>" :anon :subid("607_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3646
    .param pmc param_3647
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2505
    .lex "self", param_3646
    .lex "$/", param_3647
.annotate 'line', 2506
    find_lex $P122, "$/"
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Op"]
    find_lex $P3648, "$/"
    unless_null $P3648, vivify_3144
    $P3648 = root_new ['parrot';'Hash']
  vivify_3144:
    set $P128, $P3648["quote_EXPR"]
    unless_null $P128, vivify_3145
    new $P128, "Undef"
  vivify_3145:
    $P129 = $P128."ast"()
    $P130 = $P129."value"()
    find_lex $P131, "$/"
    unless_null $P131, vivify_3146
    new $P131, "Undef"
  vivify_3146:
    $P132 = $P127."new"($P130 :named("inline"), "inline" :named("pasttype"), $P131 :named("node"))
    $P133 = $P122."!make"($P132)
.annotate 'line', 2505
    .return ($P133)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "quote:sym</ />" :anon :subid("608_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3652
    .param pmc param_3653
    .param pmc param_3654 :optional
    .param int has_param_3654 :opt_flag
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2511
    new $P3651, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P3651, control_3650
    push_eh $P3651
    .lex "self", param_3652
    .lex "$/", param_3653
    if has_param_3654, optparam_3147
    new $P122, "Undef"
    set param_3654, $P122
  optparam_3147:
    .lex "$key", param_3654
.annotate 'line', 2518
    new $P123, "Undef"
    set $P3655, $P123
    .lex "$regex", $P3655
.annotate 'line', 2520
    new $P124, "Undef"
    set $P3656, $P124
    .lex "$past", $P3656
.annotate 'line', 2512
    find_lex $P125, "$key"
    unless_null $P125, vivify_3148
    new $P125, "Undef"
  vivify_3148:
    set $S100, $P125
    iseq $I100, $S100, "open"
    unless $I100, if_3657_end
.annotate 'line', 2513
    null $P127
    get_hll_global $P128, "GLOBAL"
    nqp_get_package_through_who $P129, $P128, "Regex"
    nqp_get_package_through_who $P130, $P129, "P6Regex"
    nqp_get_package_through_who $P131, $P130, "Actions"
    get_who $P132, $P131
    set $P132["$REGEXNAME"], $P127
.annotate 'line', 2514
    find_lex $P127, "$?PACKAGE"
    get_who $P128, $P127
    set $P3658, $P128["@BLOCK"]
    unless_null $P3658, vivify_3149
    $P3658 = root_new ['parrot';'ResizablePMCArray']
  vivify_3149:
    set $P129, $P3658[0]
    unless_null $P129, vivify_3150
    new $P129, "Undef"
  vivify_3150:
    $P129."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 2515
    find_lex $P127, "$?PACKAGE"
    get_who $P128, $P127
    set $P3659, $P128["@BLOCK"]
    unless_null $P3659, vivify_3151
    $P3659 = root_new ['parrot';'ResizablePMCArray']
  vivify_3151:
    set $P129, $P3659[0]
    unless_null $P129, vivify_3152
    new $P129, "Undef"
  vivify_3152:
    $P129."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 2516
    new $P127, "Exception"
    set $P127['type'], .CONTROL_RETURN
    new $P128, "Integer"
    assign $P128, 0
    setattribute $P127, 'payload', $P128
    throw $P127
  if_3657_end:
.annotate 'line', 2519
    get_hll_global $P125, "GLOBAL"
    nqp_get_package_through_who $P127, $P125, "Regex"
    nqp_get_package_through_who $P128, $P127, "P6Regex"
    nqp_get_package_through_who $P129, $P128, "Actions"
    get_who $P130, $P129
    set $P131, $P130["buildsub"]
    find_lex $P3660, "$/"
    unless_null $P3660, vivify_3153
    $P3660 = root_new ['parrot';'Hash']
  vivify_3153:
    set $P132, $P3660["p6regex"]
    unless_null $P132, vivify_3154
    new $P132, "Undef"
  vivify_3154:
    $P133 = $P132."ast"()
    find_lex $P134, "$?PACKAGE"
    get_who $P135, $P134
    set $P3661, $P135["@BLOCK"]
    unless_null $P3661, vivify_3155
    $P3661 = root_new ['parrot';'ResizablePMCArray']
  vivify_3155:
    $P136 = $P3661."shift"()
    $P137 = $P131($P133, $P136)
    store_lex "$regex", $P137
.annotate 'line', 2521
    get_hll_global $P125, "GLOBAL"
    nqp_get_package_through_who $P127, $P125, "PAST"
    get_who $P128, $P127
    set $P129, $P128["Op"]
.annotate 'line', 2523
    new $P130, "ResizablePMCArray"
    push $P130, "Regex"
    push $P130, "Regex"
    find_lex $P131, "$/"
    unless_null $P131, vivify_3156
    new $P131, "Undef"
  vivify_3156:
    $P132 = "lexical_package_lookup"($P130, $P131)
    find_lex $P133, "$regex"
    unless_null $P133, vivify_3157
    new $P133, "Undef"
  vivify_3157:
    $P134 = $P129."new"($P132, $P133, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 2521
    store_lex "$past", $P134
.annotate 'line', 2527
    find_lex $P125, "$regex"
    unless_null $P125, vivify_3158
    new $P125, "Undef"
  vivify_3158:
    find_lex $P3662, "$past"
    unless_null $P3662, vivify_3159
    $P3662 = root_new ['parrot';'Hash']
    store_lex "$past", $P3662
  vivify_3159:
    set $P3662["sink"], $P125
.annotate 'line', 2528
    find_lex $P125, "$/"
    find_lex $P127, "$past"
    unless_null $P127, vivify_3160
    new $P127, "Undef"
  vivify_3160:
    $P128 = $P125."!make"($P127)
.annotate 'line', 2511
    .return ($P128)
  control_3650:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P125, exception, "payload"
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<$>" :anon :subid("609_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3664
    .param pmc param_3665
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2531
    .lex "self", param_3664
    .lex "$/", param_3665
    find_lex $P122, "$/"
    find_lex $P3666, "$/"
    unless_null $P3666, vivify_3161
    $P3666 = root_new ['parrot';'Hash']
  vivify_3161:
    set $P123, $P3666["variable"]
    unless_null $P123, vivify_3162
    new $P123, "Undef"
  vivify_3162:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<{ }>" :anon :subid("610_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3668
    .param pmc param_3669
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2532
    .lex "self", param_3668
    .lex "$/", param_3669
.annotate 'line', 2533
    find_lex $P122, "$/"
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Op"]
.annotate 'line', 2534
    find_lex $P3670, "$/"
    unless_null $P3670, vivify_3163
    $P3670 = root_new ['parrot';'Hash']
  vivify_3163:
    set $P128, $P3670["block"]
    unless_null $P128, vivify_3164
    new $P128, "Undef"
  vivify_3164:
    $P129 = $P128."ast"()
    $P130 = "block_immediate"($P129)
    find_lex $P131, "$/"
    unless_null $P131, vivify_3165
    new $P131, "Undef"
  vivify_3165:
    $P132 = $P127."new"($P130, "set S*" :named("pirop"), $P131 :named("node"))
.annotate 'line', 2533
    $P133 = $P122."!make"($P132)
.annotate 'line', 2532
    .return ($P133)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<esc>" :anon :subid("611_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3672
    .param pmc param_3673
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2537
    .lex "self", param_3672
    .lex "$/", param_3673
    find_lex $P122, "$/"
    $P123 = $P122."!make"("\e")
    .return ($P123)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<.>" :anon :subid("612_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3675
    .param pmc param_3676
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2541
    .lex "self", param_3675
    .lex "$/", param_3676
    find_lex $P122, "$/"
    find_lex $P3677, "$/"
    unless_null $P3677, vivify_3166
    $P3677 = root_new ['parrot';'Hash']
  vivify_3166:
    set $P123, $P3677["dotty"]
    unless_null $P123, vivify_3167
    new $P123, "Undef"
  vivify_3167:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<++>" :anon :subid("613_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3679
    .param pmc param_3680
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2543
    .lex "self", param_3679
    .lex "$/", param_3680
.annotate 'line', 2544
    find_lex $P122, "$/"
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Op"]
.annotate 'line', 2545
    new $P128, "ResizablePMCArray"
    push $P128, "    clone %r, %0"
    push $P128, "    inc %0"
.annotate 'line', 2544
    $P129 = $P127."new"("postfix:<++>" :named("name"), $P128 :named("inline"), "inline" :named("pasttype"))
    $P130 = $P122."!make"($P129)
.annotate 'line', 2543
    .return ($P130)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<-->" :anon :subid("614_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3682
    .param pmc param_3683
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2549
    .lex "self", param_3682
    .lex "$/", param_3683
.annotate 'line', 2550
    find_lex $P122, "$/"
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Op"]
.annotate 'line', 2551
    new $P128, "ResizablePMCArray"
    push $P128, "    clone %r, %0"
    push $P128, "    dec %0"
.annotate 'line', 2550
    $P129 = $P127."new"("postfix:<-->" :named("name"), $P128 :named("inline"), "inline" :named("pasttype"))
    $P130 = $P122."!make"($P129)
.annotate 'line', 2549
    .return ($P130)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "prefix:sym<make>" :anon :subid("615_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3685
    .param pmc param_3686
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2555
    .lex "self", param_3685
    .lex "$/", param_3686
.annotate 'line', 2556
    find_lex $P122, "$/"
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Op"]
.annotate 'line', 2557
    get_hll_global $P128, "GLOBAL"
    nqp_get_package_through_who $P129, $P128, "PAST"
    get_who $P130, $P129
    set $P131, $P130["Var"]
    $P132 = $P131."new"("$/" :named("name"), "contextual" :named("scope"))
    find_lex $P133, "$/"
    unless_null $P133, vivify_3168
    new $P133, "Undef"
  vivify_3168:
    $P134 = $P127."new"($P132, "callmethod" :named("pasttype"), "!make" :named("name"), $P133 :named("node"))
.annotate 'line', 2556
    $P135 = $P122."!make"($P134)
.annotate 'line', 2555
    .return ($P135)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<next>" :anon :subid("616_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3688
    .param pmc param_3689
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2573
    .lex "self", param_3688
    .lex "$/", param_3689
    find_lex $P122, "$/"
    unless_null $P122, vivify_3169
    new $P122, "Undef"
  vivify_3169:
    $P123 = "control"($P122, "CONTROL_LOOP_NEXT")
    .return ($P123)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<last>" :anon :subid("617_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3691
    .param pmc param_3692
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2574
    .lex "self", param_3691
    .lex "$/", param_3692
    find_lex $P122, "$/"
    unless_null $P122, vivify_3170
    new $P122, "Undef"
  vivify_3170:
    $P123 = "control"($P122, "CONTROL_LOOP_LAST")
    .return ($P123)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<redo>" :anon :subid("618_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3694
    .param pmc param_3695
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2575
    .lex "self", param_3694
    .lex "$/", param_3695
    find_lex $P122, "$/"
    unless_null $P122, vivify_3171
    new $P122, "Undef"
  vivify_3171:
    $P123 = "control"($P122, "CONTROL_LOOP_REDO")
    .return ($P123)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "infix:sym<~~>" :anon :subid("619_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3697
    .param pmc param_3698
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2577
    .lex "self", param_3697
    .lex "$/", param_3698
.annotate 'line', 2578
    find_lex $P122, "$/"
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Op"]
    find_lex $P128, "$/"
    unless_null $P128, vivify_3172
    new $P128, "Undef"
  vivify_3172:
    $P129 = $P127."new"("callmethod" :named("pasttype"), "ACCEPTS" :named("name"), $P128 :named("node"))
    $P130 = $P122."!make"($P129)
.annotate 'line', 2577
    .return ($P130)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "known_sym" :anon :subid("620_1310110678.31883") :outer("440_1310110678.31883")
    .param pmc param_3700
    .param pmc param_3701
    .param pmc param_3702
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2655
    .const 'Sub' $P3705 = "621_1310110678.31883" 
    capture_lex $P3705
    .lex "self", param_3700
    .lex "$/", param_3701
    .lex "@name", param_3702
.annotate 'line', 2656
    new $P122, "Undef"
    set $P3703, $P122
    .lex "$known", $P3703
    new $P123, "Integer"
    assign $P123, 0
    store_lex "$known", $P123
.annotate 'line', 2657
    .const 'Sub' $P3705 = "621_1310110678.31883" 
    capture_lex $P3705
    $P3705()
.annotate 'line', 2655
    find_lex $P123, "$known"
    unless_null $P123, vivify_3175
    new $P123, "Undef"
  vivify_3175:
    .return ($P123)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3704"  :anon :subid("621_1310110678.31883") :outer("620_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2657
    new $P3709, 'ExceptionHandler'
    set_label $P3709, control_3708
    $P3709."handle_types_except"(.CONTROL_RETURN,  .CONTROL_OK,  .CONTROL_BREAK,  .CONTROL_CONTINUE,  .CONTROL_TAKE,  .CONTROL_LEAVE,  .CONTROL_EXIT,  .CONTROL_LOOP_NEXT,  .CONTROL_LOOP_LAST,  .CONTROL_LOOP_REDO)
    push_eh $P3709
.annotate 'line', 2658
    find_lex $P3706, "@name"
    unless_null $P3706, vivify_3173
    $P3706 = root_new ['parrot';'ResizablePMCArray']
  vivify_3173:
    find_lex $P123, "$/"
    unless_null $P123, vivify_3174
    new $P123, "Undef"
  vivify_3174:
    "find_sym"($P3706, $P123)
.annotate 'line', 2659
    new $P123, "Integer"
    assign $P123, 1
    store_lex "$known", $P123
.annotate 'line', 2657
    pop_eh 
    goto skip_handler_3707
  control_3708:
    .local pmc exception 
    .get_results (exception) 
    new $P3712, 'Integer'
    set $P3712, 1
    set exception["handled"], $P3712
    set $I3713, exception["handled"]
    ne $I3713, 1, nothandled_3711
  handled_3710:
    .return (exception)
  nothandled_3711:
    rethrow exception
  skip_handler_3707:
    .return ($P123)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "_block3714"  :subid("622_1310110678.31883") :outer("10_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2724
    .const 'Sub' $P3744 = "629_1310110678.31883" 
    capture_lex $P3744
    .const 'Sub' $P3740 = "628_1310110678.31883" 
    capture_lex $P3740
    .const 'Sub' $P3735 = "627_1310110678.31883" 
    capture_lex $P3735
    .const 'Sub' $P3731 = "626_1310110678.31883" 
    capture_lex $P3731
    .const 'Sub' $P3727 = "625_1310110678.31883" 
    capture_lex $P3727
    .const 'Sub' $P3723 = "624_1310110678.31883" 
    capture_lex $P3723
    .const 'Sub' $P3718 = "623_1310110678.31883" 
    capture_lex $P3718
    .lex "$?PACKAGE", $P3716
    .lex "$?CLASS", $P3717
.annotate 'line', 2758
    .const 'Sub' $P3744 = "629_1310110678.31883" 
    newclosure $P3750, $P3744
.annotate 'line', 2724
    .return ($P3750)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<:my>" :anon :subid("623_1310110678.31883") :outer("622_1310110678.31883")
    .param pmc param_3719
    .param pmc param_3720
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2726
    .lex "self", param_3719
    .lex "$/", param_3720
.annotate 'line', 2727
    new $P103, "Undef"
    set $P3721, $P103
    .lex "$past", $P3721
    find_lex $P3722, "$/"
    unless_null $P3722, vivify_3176
    $P3722 = root_new ['parrot';'Hash']
  vivify_3176:
    set $P104, $P3722["statement"]
    unless_null $P104, vivify_3177
    new $P104, "Undef"
  vivify_3177:
    $P105 = $P104."ast"()
    store_lex "$past", $P105
.annotate 'line', 2728
    find_lex $P104, "$/"
    get_hll_global $P105, "GLOBAL"
    nqp_get_package_through_who $P106, $P105, "PAST"
    get_who $P107, $P106
    set $P108, $P107["Regex"]
    find_lex $P109, "$past"
    unless_null $P109, vivify_3178
    new $P109, "Undef"
  vivify_3178:
    find_lex $P110, "$/"
    unless_null $P110, vivify_3179
    new $P110, "Undef"
  vivify_3179:
    $P111 = $P108."new"($P109, "pastnode" :named("pasttype"), "declarative" :named("subtype"), $P110 :named("node"))
    $P112 = $P104."!make"($P111)
.annotate 'line', 2726
    .return ($P112)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<{ }>" :anon :subid("624_1310110678.31883") :outer("622_1310110678.31883")
    .param pmc param_3724
    .param pmc param_3725
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2732
    .lex "self", param_3724
    .lex "$/", param_3725
.annotate 'line', 2733
    find_lex $P103, "$/"
    get_hll_global $P104, "GLOBAL"
    nqp_get_package_through_who $P105, $P104, "PAST"
    get_who $P106, $P105
    set $P107, $P106["Regex"]
    find_lex $P3726, "$/"
    unless_null $P3726, vivify_3180
    $P3726 = root_new ['parrot';'Hash']
  vivify_3180:
    set $P108, $P3726["codeblock"]
    unless_null $P108, vivify_3181
    new $P108, "Undef"
  vivify_3181:
    $P109 = $P108."ast"()
    find_lex $P110, "$/"
    unless_null $P110, vivify_3182
    new $P110, "Undef"
  vivify_3182:
    $P111 = $P107."new"($P109, "pastnode" :named("pasttype"), $P110 :named("node"))
    $P112 = $P103."!make"($P111)
.annotate 'line', 2732
    .return ($P112)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<nqpvar>" :anon :subid("625_1310110678.31883") :outer("622_1310110678.31883")
    .param pmc param_3728
    .param pmc param_3729
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2737
    .lex "self", param_3728
    .lex "$/", param_3729
.annotate 'line', 2738
    find_lex $P103, "$/"
    get_hll_global $P104, "GLOBAL"
    nqp_get_package_through_who $P105, $P104, "PAST"
    get_who $P106, $P105
    set $P107, $P106["Regex"]
    find_lex $P3730, "$/"
    unless_null $P3730, vivify_3183
    $P3730 = root_new ['parrot';'Hash']
  vivify_3183:
    set $P108, $P3730["var"]
    unless_null $P108, vivify_3184
    new $P108, "Undef"
  vivify_3184:
    $P109 = $P108."ast"()
    find_lex $P110, "$/"
    unless_null $P110, vivify_3185
    new $P110, "Undef"
  vivify_3185:
    $P111 = $P107."new"("!INTERPOLATE", $P109, "subrule" :named("pasttype"), "method" :named("subtype"), $P110 :named("node"))
    $P112 = $P103."!make"($P111)
.annotate 'line', 2737
    .return ($P112)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<{ }>" :anon :subid("626_1310110678.31883") :outer("622_1310110678.31883")
    .param pmc param_3732
    .param pmc param_3733
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2742
    .lex "self", param_3732
    .lex "$/", param_3733
.annotate 'line', 2743
    find_lex $P103, "$/"
    get_hll_global $P104, "GLOBAL"
    nqp_get_package_through_who $P105, $P104, "PAST"
    get_who $P106, $P105
    set $P107, $P106["Regex"]
    find_lex $P3734, "$/"
    unless_null $P3734, vivify_3186
    $P3734 = root_new ['parrot';'Hash']
  vivify_3186:
    set $P108, $P3734["codeblock"]
    unless_null $P108, vivify_3187
    new $P108, "Undef"
  vivify_3187:
    $P109 = $P108."ast"()
    find_lex $P110, "$/"
    unless_null $P110, vivify_3188
    new $P110, "Undef"
  vivify_3188:
    $P111 = $P107."new"("!INTERPOLATE_REGEX", $P109, "subrule" :named("pasttype"), "method" :named("subtype"), $P110 :named("node"))
    $P112 = $P103."!make"($P111)
.annotate 'line', 2742
    .return ($P112)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<?{ }>" :anon :subid("627_1310110678.31883") :outer("622_1310110678.31883")
    .param pmc param_3736
    .param pmc param_3737
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2747
    .lex "self", param_3736
    .lex "$/", param_3737
.annotate 'line', 2748
    find_lex $P103, "$/"
    get_hll_global $P104, "GLOBAL"
    nqp_get_package_through_who $P105, $P104, "PAST"
    get_who $P106, $P105
    set $P107, $P106["Regex"]
    find_lex $P3738, "$/"
    unless_null $P3738, vivify_3189
    $P3738 = root_new ['parrot';'Hash']
  vivify_3189:
    set $P108, $P3738["codeblock"]
    unless_null $P108, vivify_3190
    new $P108, "Undef"
  vivify_3190:
    $P109 = $P108."ast"()
.annotate 'line', 2749
    find_lex $P3739, "$/"
    unless_null $P3739, vivify_3191
    $P3739 = root_new ['parrot';'Hash']
  vivify_3191:
    set $P110, $P3739["zw"]
    unless_null $P110, vivify_3192
    new $P110, "Undef"
  vivify_3192:
    set $S100, $P110
    iseq $I100, $S100, "!"
.annotate 'line', 2748
    find_lex $P111, "$/"
    unless_null $P111, vivify_3193
    new $P111, "Undef"
  vivify_3193:
    $P112 = $P107."new"($P109, "zerowidth" :named("subtype"), $I100 :named("negate"), "pastnode" :named("pasttype"), $P111 :named("node"))
    $P113 = $P103."!make"($P112)
.annotate 'line', 2747
    .return ($P113)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<var>" :anon :subid("628_1310110678.31883") :outer("622_1310110678.31883")
    .param pmc param_3741
    .param pmc param_3742
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2753
    .lex "self", param_3741
    .lex "$/", param_3742
.annotate 'line', 2754
    find_lex $P103, "$/"
    get_hll_global $P104, "GLOBAL"
    nqp_get_package_through_who $P105, $P104, "PAST"
    get_who $P106, $P105
    set $P107, $P106["Regex"]
    find_lex $P3743, "$/"
    unless_null $P3743, vivify_3194
    $P3743 = root_new ['parrot';'Hash']
  vivify_3194:
    set $P108, $P3743["var"]
    unless_null $P108, vivify_3195
    new $P108, "Undef"
  vivify_3195:
    $P109 = $P108."ast"()
    find_lex $P110, "$/"
    unless_null $P110, vivify_3196
    new $P110, "Undef"
  vivify_3196:
    $P111 = $P107."new"("!INTERPOLATE_REGEX", $P109, "subrule" :named("pasttype"), "method" :named("subtype"), $P110 :named("node"))
    $P112 = $P103."!make"($P111)
.annotate 'line', 2753
    .return ($P112)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "codeblock" :anon :subid("629_1310110678.31883") :outer("622_1310110678.31883")
    .param pmc param_3745
    .param pmc param_3746
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2758
    .lex "self", param_3745
    .lex "$/", param_3746
.annotate 'line', 2759
    new $P103, "Undef"
    set $P3747, $P103
    .lex "$block", $P3747
.annotate 'line', 2761
    new $P104, "Undef"
    set $P3748, $P104
    .lex "$past", $P3748
.annotate 'line', 2759
    find_lex $P3749, "$/"
    unless_null $P3749, vivify_3197
    $P3749 = root_new ['parrot';'Hash']
  vivify_3197:
    set $P105, $P3749["block"]
    unless_null $P105, vivify_3198
    new $P105, "Undef"
  vivify_3198:
    $P106 = $P105."ast"()
    store_lex "$block", $P106
.annotate 'line', 2760
    find_lex $P105, "$block"
    unless_null $P105, vivify_3199
    new $P105, "Undef"
  vivify_3199:
    $P105."blocktype"("immediate")
.annotate 'line', 2762
    get_hll_global $P105, "GLOBAL"
    nqp_get_package_through_who $P106, $P105, "PAST"
    get_who $P107, $P106
    set $P108, $P107["Stmts"]
.annotate 'line', 2763
    get_hll_global $P109, "GLOBAL"
    nqp_get_package_through_who $P110, $P109, "PAST"
    get_who $P111, $P110
    set $P112, $P111["Op"]
.annotate 'line', 2764
    get_hll_global $P113, "GLOBAL"
    nqp_get_package_through_who $P114, $P113, "PAST"
    get_who $P115, $P114
    set $P116, $P115["Var"]
    $P117 = $P116."new"("$/" :named("name"))
.annotate 'line', 2765
    get_hll_global $P118, "GLOBAL"
    nqp_get_package_through_who $P119, $P118, "PAST"
    get_who $P120, $P119
    set $P121, $P120["Op"]
.annotate 'line', 2766
    get_hll_global $P122, "GLOBAL"
    nqp_get_package_through_who $P123, $P122, "PAST"
    get_who $P124, $P123
    set $P125, $P124["Var"]
    $P126 = $P125."new"(unicode:"$\x{a2}" :named("name"))
    $P127 = $P121."new"($P126, "MATCH" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 2765
    $P128 = $P112."new"($P117, $P127, "bind_6model" :named("pasttype"))
.annotate 'line', 2763
    find_lex $P129, "$block"
    unless_null $P129, vivify_3200
    new $P129, "Undef"
  vivify_3200:
    $P130 = $P108."new"($P128, $P129)
.annotate 'line', 2762
    store_lex "$past", $P130
.annotate 'line', 2774
    find_lex $P105, "$/"
    find_lex $P106, "$past"
    unless_null $P106, vivify_3201
    new $P106, "Undef"
  vivify_3201:
    $P107 = $P105."!make"($P106)
.annotate 'line', 2758
    .return ($P107)
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "_block3751"  :subid("630_1310110678.31883") :outer("10_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2779
    .lex "$?PACKAGE", $P3753
    .lex "$?CLASS", $P3754
    .return ()
.end


.HLL "nqp"

.namespace []
.sub "_block3757" :load :anon :subid("631_1310110678.31883")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1
    .const 'Sub' $P3759 = "10_1310110678.31883" 
    $P110 = $P3759()
    .return ($P110)
.end

